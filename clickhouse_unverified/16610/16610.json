{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16610,
  "instance_id": "ClickHouse__ClickHouse-16610",
  "issue_numbers": [
    "16574",
    "16231"
  ],
  "base_commit": "f39457bc77b4175f70a757470751894b1a9203d2",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionCount.cpp b/src/AggregateFunctions/AggregateFunctionCount.cpp\nindex 6ea63bedaf00..05824947b874 100644\n--- a/src/AggregateFunctions/AggregateFunctionCount.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionCount.cpp\n@@ -8,7 +8,7 @@ namespace DB\n {\n \n AggregateFunctionPtr AggregateFunctionCount::getOwnNullAdapter(\n-    const AggregateFunctionPtr &, const DataTypes & types, const Array & params) const\n+    const AggregateFunctionPtr &, const DataTypes & types, const Array & params, const AggregateFunctionProperties & /*properties*/) const\n {\n     return std::make_shared<AggregateFunctionCountNotNullUnary>(types[0], params);\n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionCount.h b/src/AggregateFunctions/AggregateFunctionCount.h\nindex 29c5de0021c3..eb1583df92a2 100644\n--- a/src/AggregateFunctions/AggregateFunctionCount.h\n+++ b/src/AggregateFunctions/AggregateFunctionCount.h\n@@ -69,7 +69,7 @@ class AggregateFunctionCount final : public IAggregateFunctionDataHelper<Aggrega\n     }\n \n     AggregateFunctionPtr getOwnNullAdapter(\n-        const AggregateFunctionPtr &, const DataTypes & types, const Array & params) const override;\n+        const AggregateFunctionPtr &, const DataTypes & types, const Array & params, const AggregateFunctionProperties & /*properties*/) const override;\n };\n \n \ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.cpp b/src/AggregateFunctions/AggregateFunctionIf.cpp\nindex 19a175de9113..276abb909203 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionIf.cpp\n@@ -1,6 +1,7 @@\n #include <AggregateFunctions/AggregateFunctionIf.h>\n #include <AggregateFunctions/AggregateFunctionCombinatorFactory.h>\n #include \"registerAggregateFunctions.h\"\n+#include \"AggregateFunctionNull.h\"\n \n \n namespace DB\n@@ -8,6 +9,7 @@ namespace DB\n \n namespace ErrorCodes\n {\n+    extern const int LOGICAL_ERROR;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n@@ -40,6 +42,164 @@ class AggregateFunctionCombinatorIf final : public IAggregateFunctionCombinator\n     }\n };\n \n+/** There are two cases: for single argument and variadic.\n+  * Code for single argument is much more efficient.\n+  */\n+template <bool result_is_nullable, bool serialize_flag>\n+class AggregateFunctionIfNullUnary final\n+    : public AggregateFunctionNullBase<result_is_nullable, serialize_flag,\n+        AggregateFunctionIfNullUnary<result_is_nullable, serialize_flag>>\n+{\n+private:\n+    size_t num_arguments;\n+\n+    using Base = AggregateFunctionNullBase<result_is_nullable, serialize_flag,\n+        AggregateFunctionIfNullUnary<result_is_nullable, serialize_flag>>;\n+public:\n+\n+    String getName() const override\n+    {\n+        return Base::getName();\n+    }\n+\n+    AggregateFunctionIfNullUnary(AggregateFunctionPtr nested_function_, const DataTypes & arguments, const Array & params)\n+        : Base(std::move(nested_function_), arguments, params), num_arguments(arguments.size())\n+    {\n+        if (num_arguments == 0)\n+            throw Exception(\"Aggregate function \" + getName() + \" require at least one argument\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+    }\n+\n+    static inline bool singleFilter(const IColumn ** columns, size_t row_num, size_t num_arguments)\n+    {\n+        const IColumn * filter_column = columns[num_arguments - 1];\n+        if (const ColumnNullable * nullable_column = typeid_cast<const ColumnNullable *>(filter_column))\n+            filter_column = nullable_column->getNestedColumnPtr().get();\n+\n+        return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num];\n+    }\n+\n+    void add(AggregateDataPtr place, const IColumn ** columns, size_t row_num, Arena * arena) const override\n+    {\n+        const ColumnNullable * column = assert_cast<const ColumnNullable *>(columns[0]);\n+        const IColumn * nested_column = &column->getNestedColumn();\n+        if (!column->isNullAt(row_num) && singleFilter(columns, row_num, num_arguments))\n+        {\n+            this->setFlag(place);\n+            this->nested_function->add(this->nestedPlace(place), &nested_column, row_num, arena);\n+        }\n+    }\n+};\n+\n+template <bool result_is_nullable, bool serialize_flag, bool null_is_skipped>\n+class AggregateFunctionIfNullVariadic final\n+    : public AggregateFunctionNullBase<result_is_nullable, serialize_flag,\n+        AggregateFunctionIfNullVariadic<result_is_nullable, serialize_flag, null_is_skipped>>\n+{\n+public:\n+\n+    String getName() const override\n+    {\n+        return Base::getName();\n+    }\n+\n+    AggregateFunctionIfNullVariadic(AggregateFunctionPtr nested_function_, const DataTypes & arguments, const Array & params)\n+        : Base(std::move(nested_function_), arguments, params), number_of_arguments(arguments.size())\n+    {\n+        if (number_of_arguments == 1)\n+            throw Exception(\"Logical error: single argument is passed to AggregateFunctionIfNullVariadic\", ErrorCodes::LOGICAL_ERROR);\n+\n+        if (number_of_arguments > MAX_ARGS)\n+            throw Exception(\"Maximum number of arguments for aggregate function with Nullable types is \" + toString(size_t(MAX_ARGS)),\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        for (size_t i = 0; i < number_of_arguments; ++i)\n+            is_nullable[i] = arguments[i]->isNullable();\n+    }\n+\n+    static inline bool singleFilter(const IColumn ** columns, size_t row_num, size_t num_arguments)\n+    {\n+        return assert_cast<const ColumnUInt8 &>(*columns[num_arguments - 1]).getData()[row_num];\n+    }\n+\n+    void add(AggregateDataPtr place, const IColumn ** columns, size_t row_num, Arena * arena) const override\n+    {\n+        /// This container stores the columns we really pass to the nested function.\n+        const IColumn * nested_columns[number_of_arguments];\n+\n+        for (size_t i = 0; i < number_of_arguments; ++i)\n+        {\n+            if (is_nullable[i])\n+            {\n+                const ColumnNullable & nullable_col = assert_cast<const ColumnNullable &>(*columns[i]);\n+                if (null_is_skipped && nullable_col.isNullAt(row_num))\n+                {\n+                    /// If at least one column has a null value in the current row,\n+                    /// we don't process this row.\n+                    return;\n+                }\n+                nested_columns[i] = &nullable_col.getNestedColumn();\n+            }\n+            else\n+                nested_columns[i] = columns[i];\n+        }\n+\n+        if (singleFilter(nested_columns, row_num, number_of_arguments))\n+        {\n+            this->setFlag(place);\n+            this->nested_function->add(this->nestedPlace(place), nested_columns, row_num, arena);\n+        }\n+    }\n+\n+private:\n+    using Base = AggregateFunctionNullBase<result_is_nullable, serialize_flag,\n+        AggregateFunctionIfNullVariadic<result_is_nullable, serialize_flag, null_is_skipped>>;\n+\n+    enum { MAX_ARGS = 8 };\n+    size_t number_of_arguments = 0;\n+    std::array<char, MAX_ARGS> is_nullable;    /// Plain array is better than std::vector due to one indirection less.\n+};\n+\n+\n+AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(\n+    const AggregateFunctionPtr & nested_function, const DataTypes & arguments,\n+    const Array & params, const AggregateFunctionProperties & properties) const\n+{\n+    bool return_type_is_nullable = !properties.returns_default_when_only_null && getReturnType()->canBeInsideNullable();\n+    size_t nullable_size = std::count_if(arguments.begin(), arguments.end(), [](const auto & element) { return element->isNullable(); });\n+    return_type_is_nullable &= nullable_size != 1 || !arguments.back()->isNullable();   /// If only condition is nullable. we should non-nullable type.\n+    bool serialize_flag = return_type_is_nullable || properties.returns_default_when_only_null;\n+\n+    if (arguments.size() <= 2 && arguments.front()->isNullable())\n+    {\n+        if (return_type_is_nullable)\n+        {\n+            return std::make_shared<AggregateFunctionIfNullUnary<true, true>>(nested_func, arguments, params);\n+        }\n+        else\n+        {\n+            if (serialize_flag)\n+                return std::make_shared<AggregateFunctionIfNullUnary<false, true>>(nested_func, arguments, params);\n+            else\n+                return std::make_shared<AggregateFunctionIfNullUnary<false, false>>(nested_func, arguments, params);\n+        }\n+    }\n+    else\n+    {\n+        if (return_type_is_nullable)\n+        {\n+            return std::make_shared<AggregateFunctionIfNullVariadic<true, true, true>>(nested_function, arguments, params);\n+        }\n+        else\n+        {\n+            if (serialize_flag)\n+                return std::make_shared<AggregateFunctionIfNullVariadic<false, true, true>>(nested_function, arguments, params);\n+            else\n+                return std::make_shared<AggregateFunctionIfNullVariadic<false, false, true>>(nested_function, arguments, params);\n+        }\n+    }\n+}\n+\n void registerAggregateFunctionCombinatorIf(AggregateFunctionCombinatorFactory & factory)\n {\n     factory.registerCombinator(std::make_shared<AggregateFunctionCombinatorIf>());\ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.h b/src/AggregateFunctions/AggregateFunctionIf.h\nindex f04450c91427..d5d2b9be0dd8 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.h\n+++ b/src/AggregateFunctions/AggregateFunctionIf.h\n@@ -109,6 +109,10 @@ class AggregateFunctionIf final : public IAggregateFunctionHelper<AggregateFunct\n     {\n         return nested_func->isState();\n     }\n+\n+    AggregateFunctionPtr getOwnNullAdapter(\n+        const AggregateFunctionPtr & nested_function, const DataTypes & arguments,\n+        const Array & params, const AggregateFunctionProperties & properties) const override;\n };\n \n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionNull.cpp b/src/AggregateFunctions/AggregateFunctionNull.cpp\nindex 5e0d6ee6e217..f584ae1f34cc 100644\n--- a/src/AggregateFunctions/AggregateFunctionNull.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionNull.cpp\n@@ -72,7 +72,7 @@ class AggregateFunctionCombinatorNull final : public IAggregateFunctionCombinato\n \n         assert(nested_function);\n \n-        if (auto adapter = nested_function->getOwnNullAdapter(nested_function, arguments, params))\n+        if (auto adapter = nested_function->getOwnNullAdapter(nested_function, arguments, params, properties))\n             return adapter;\n \n         /// If applied to aggregate function with -State combinator, we apply -Null combinator to it's nested_function instead of itself.\ndiff --git a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\nindex 3297819a9ffc..fe45fec4b763 100644\n--- a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n+++ b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n@@ -241,7 +241,8 @@ class AggregateFunctionWindowFunnel final\n     }\n \n     AggregateFunctionPtr getOwnNullAdapter(\n-        const AggregateFunctionPtr & nested_function, const DataTypes & arguments, const Array & params) const override\n+        const AggregateFunctionPtr & nested_function, const DataTypes & arguments, const Array & params,\n+        const AggregateFunctionProperties & /*properties*/) const override\n     {\n         return std::make_shared<AggregateFunctionNullVariadic<false, false, false>>(nested_function, arguments, params);\n     }\ndiff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex 4f9552d23453..b5a15eb8cbe4 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -33,6 +33,7 @@ using ConstAggregateDataPtr = const char *;\n \n class IAggregateFunction;\n using AggregateFunctionPtr = std::shared_ptr<IAggregateFunction>;\n+struct AggregateFunctionProperties;\n \n /** Aggregate functions interface.\n   * Instances of classes with this interface do not contain the data itself for aggregation,\n@@ -185,7 +186,8 @@ class IAggregateFunction\n      *  arguments and params are for nested_function.\n      */\n     virtual AggregateFunctionPtr getOwnNullAdapter(\n-        const AggregateFunctionPtr & /*nested_function*/, const DataTypes & /*arguments*/, const Array & /*params*/) const\n+        const AggregateFunctionPtr & /*nested_function*/, const DataTypes & /*arguments*/,\n+        const Array & /*params*/, const AggregateFunctionProperties & /*properties*/) const\n     {\n         return nullptr;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.reference b/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.reference\nnew file mode 100644\nindex 000000000000..77f38b722ce3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.reference\n@@ -0,0 +1,3 @@\n+\\N\tNullable(UInt8)\n+\\N\tNullable(UInt8)\n+0\tUInt8\ndiff --git a/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.sql b/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.sql\nnew file mode 100644\nindex 000000000000..852660117f54\n--- /dev/null\n+++ b/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.sql\n@@ -0,0 +1,6 @@\n+-- Value nullable\n+SELECT anyIf(CAST(number, 'Nullable(UInt8)'), number = 3) AS a, toTypeName(a) FROM numbers(2);\n+-- Value and condition nullable\n+SELECT anyIf(number, number = 3) AS a, toTypeName(a) FROM (SELECT CAST(number, 'Nullable(UInt8)') AS number FROM numbers(2));\n+-- Condition nullable\n+SELECT anyIf(CAST(number, 'UInt8'), number = 3) AS a, toTypeName(a) FROM (SELECT CAST(number, 'Nullable(UInt8)') AS number FROM numbers(2));\ndiff --git a/tests/queries/0_stateless/01556_if_null.reference b/tests/queries/0_stateless/01556_if_null.reference\nindex a0c5e7faf406..adc63ecf47b8 100644\n--- a/tests/queries/0_stateless/01556_if_null.reference\n+++ b/tests/queries/0_stateless/01556_if_null.reference\n@@ -1,1 +1,1 @@\n-([1],[5])\t4\t4\n+([1],[4])\t4\t4\ndiff --git a/tests/queries/0_stateless/01576_if_null_external_aggregation.reference b/tests/queries/0_stateless/01576_if_null_external_aggregation.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01576_if_null_external_aggregation.sql b/tests/queries/0_stateless/01576_if_null_external_aggregation.sql\nnew file mode 100644\nindex 000000000000..b9c36a9ceccb\n--- /dev/null\n+++ b/tests/queries/0_stateless/01576_if_null_external_aggregation.sql\n@@ -0,0 +1,7 @@\n+SET max_bytes_before_external_group_by = 200000000;\n+\n+SET max_memory_usage = 1500000000;\n+SET max_threads = 12;\n+\n+SELECT bitAnd(number, pow(2, 20) - 1) as k, argMaxIf(k, number % 2 = 0 ? number : Null, number > 42),  uniq(number) AS u FROM numbers(1000000) GROUP BY k format Null;\n+\n",
  "problem_statement": "Wrong behavior for sumIf with non-nullable first argument and nullable second argument\nhttps://github.com/ClickHouse/ClickHouse/pull/13964 introduced following tricky bug. It does not appear on versions before mentioned PR.\r\n\r\nListing below uses environment for tests (test_cluster_two_shards is a cluster consisting of two copies of local shard).\r\n\r\nWhen making a distributed query, subj leads to the following error:\r\n`\r\nCode: 42. DB::Exception: Received from localhost:59000. DB::Exception: Aggregate function sum requires single argument: while receiving packet from 127.0.0.2:59000: While executing Remote.\r\n`\r\n\r\n```\r\nmax42-dev.sas.yp-c.yandex.net :) create table T(a Nullable(Int64)) engine = Memory()                                                                                                                                                          \r\n                                                                                                                                                                                                                                              \r\nCREATE TABLE T                                                                                                                                                                                                                                \r\n(                                                                                                                                                                                                                                             \r\n    `a` Nullable(Int64)                                                                                                                                                                                                                       \r\n)                                                                                                                                                                                                                                             \r\nENGINE = Memory()                                                                                                                                                                                                                             \r\n                                                                                                                                                                                                                                              \r\nOk.                                                                                                                                                                                                                                           \r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n\r\nmax42-dev.sas.yp-c.yandex.net :) insert into T values (1), (2), (3), (4), (5)\r\n\r\nINSERT INTO T VALUES\r\n\r\nOk.\r\n\r\n5 rows in set. Elapsed: 0.004 sec.\r\n\r\nmax42-dev.sas.yp-c.yandex.net :) create table default.DT as default.T engine = Distributed(test_cluster_two_shards, default, T)                                                                                                               \r\n                                                                                                                                                                                                                                              \r\nCREATE TABLE default.DT AS default.T                                                                                                                                                                                                          \r\nENGINE = Distributed(test_cluster_two_shards, default, T)                                                                                                                                                                                     \r\n                                                                                                                                                                                                                                              \r\nOk.                                                                                                                                                                                                                                           \r\n                                                                                                                                                                                                                                              \r\n0 rows in set. Elapsed: 0.005 sec.                                                                                                                                                                                                            \r\n                                                                                                                                                                                                                                              \r\nmax42-dev.sas.yp-c.yandex.net :) select sumIf(42, (a % 2) = 0) from DT\r\n\r\nSELECT sumIf(42, (a % 2) = 0)\r\nFROM DT\r\n\r\n\u2192 Progress: 5.00 rows, 45.00 B (46.77 rows/s., 420.89 B/s.)\r\nReceived exception from server (version 20.8.1):\r\nCode: 42. DB::Exception: Received from localhost:59000. DB::Exception: Aggregate function sum requires single argument: while receiving packet from 127.0.0.2:59000: While executing Remote.\r\n\r\n0 rows in set. Elapsed: 0.107 sec.\r\n\r\nmax42-dev.sas.yp-c.yandex.net :) select sumIf(42, (a % 2) = 0) from T\r\n\r\nSELECT sumIf(42, (a % 2) = 0)\r\nFROM T\r\n\r\n\u250c\u2500sumIf(42, equals(modulo(a, 2), 0))\u2500\u2510\r\n\u2502                                 84 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.005 sec.\r\n\r\n```\r\n\r\nReproduces on clickhouse client and clickhouse server from Arcadia since r7258384 (including current trunk version).\n-If combinator and NULLs\nClickhouse version: 20.9.2 revision 54439\r\n\r\n```SQL\r\nSELECT\r\n    sumMapIf([1], [1], nullIf(number, 3) > 0) AS col1,\r\n    countIf(1, nullIf(number, 3) > 0) AS col2,\r\n    sumIf(1, nullIf(number, 3) > 0) AS col3\r\nFROM numbers(1, 5)\r\n```\r\n\r\n`col1` is expected to be `([1],[4])` as NULLs must be skipped\r\n`col3` value is expected to be the same as `col2`'s as the condition part is identical and both should return `4`\r\n\r\nin fact we get the following values:\r\n```\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[5]) \u2502    4 \u2502    5 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nas a workaround one can wrap the condition part with `coalesce(..., 0)`\n",
  "hints_text": "A few more examples (note that error differs in following cases):\r\n\r\n```\r\nmax42-dev.sas.yp-c.yandex.net :) select sumIf(42, toNullable(1)) from DT\r\n\r\nSELECT sumIf(42, toNullable(1))\r\nFROM DT\r\n\r\n\u2193 Progress: 5.00 rows, 45.00 B (47.39 rows/s., 426.47 B/s.) \r\nReceived exception from server (version 20.8.1):\r\nCode: 42. DB::Exception: Received from localhost:59000. DB::Exception: Aggregate function sum requires single argument: while receiving packet from 127.0.0.2:59000: While executing Remote. \r\n\r\n0 rows in set. Elapsed: 0.106 sec. \r\n\r\nmax42-dev.sas.yp-c.yandex.net :) select sumIf(42, toNullable(toInt64(1))) from DT\r\n\r\nSELECT sumIf(42, toNullable(toInt64(1)))\r\nFROM DT\r\n\r\n\r\nReceived exception from server (version 20.8.1):\r\nCode: 43. DB::Exception: Received from localhost:59000. DB::Exception: Illegal type Int64 of last argument for aggregate function with If suffix. \r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n```\n```\r\n20.3.19.4\r\n\r\nSELECT\r\n    sumMapIf([1], [1], nullIf(number, 3) > 0) AS col1,\r\n    countIf(1, nullIf(number, 3) > 0) AS col2,\r\n    sumIf(1, nullIf(number, 3) > 0) AS col3\r\nFROM numbers(1, 5)\r\n\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[4]) \u2502    4 \u2502    4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n20.4.9.110\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[4]) \u2502    4 \u2502    4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\n\r\n\r\n20.5.5.74\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[5]) \u2502    4 \u2502    4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n20.7.4.11\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[5]) \u2502    4 \u2502    4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n20.8.2.3\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[5]) \u2502    4 \u2502    5 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n20.9.3.45\r\n\u250c\u2500col1\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500col2\u2500\u252c\u2500col3\u2500\u2510\r\n\u2502 ([1],[5]) \u2502    4 \u2502    5 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nassigne to me",
  "created_at": "2020-11-02T16:02:44Z",
  "modified_files": [
    "src/AggregateFunctions/AggregateFunctionCount.cpp",
    "src/AggregateFunctions/AggregateFunctionCount.h",
    "src/AggregateFunctions/AggregateFunctionIf.cpp",
    "src/AggregateFunctions/AggregateFunctionIf.h",
    "src/AggregateFunctions/AggregateFunctionNull.cpp",
    "src/AggregateFunctions/AggregateFunctionWindowFunnel.h",
    "src/AggregateFunctions/IAggregateFunction.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.reference",
    "b/tests/queries/0_stateless/01455_nullable_type_with_if_agg_combinator.sql",
    "tests/queries/0_stateless/01556_if_null.reference",
    "b/tests/queries/0_stateless/01576_if_null_external_aggregation.sql"
  ]
}