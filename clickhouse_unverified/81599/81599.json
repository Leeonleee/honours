{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 81599,
  "instance_id": "ClickHouse__ClickHouse-81599",
  "issue_numbers": [
    "81326"
  ],
  "base_commit": "d45703c72df97fca5d50d75add35995da94ff862",
  "patch": "diff --git a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\nindex 562b56145daa..4ebd52df7b2e 100644\n--- a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n+++ b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n@@ -306,6 +306,7 @@ Ethereum\n ExactEdgeLengthKm\n ExactEdgeLengthM\n ExactEdgeLengthRads\n+Excel's\n ExecutablePool\n ExperimentalBadge\n ExtType\n@@ -901,6 +902,7 @@ RWLockWaitingWriters\n RabbitMQ\n Rabl\n RangeHashed\n+Raphson\n RawBLOB\n RawSum\n RawWithNames\n@@ -1205,6 +1207,8 @@ WriteBuffer\n WriteBuffers\n XCode\n XHTML\n+XIRR\n+XNPV\n XORs\n Xeon\n YAML\n@@ -1480,6 +1484,8 @@ cardinalities\n cardinality\n cartesian\n caseWithExpression\n+cashflow\n+cashflows\n cassandra\n catboost\n catboostEvaluate\n@@ -1829,6 +1835,10 @@ filesystemFree\n filesystemUnreserved\n filesystems\n finalizeAggregation\n+financialInternalRateOfReturn\n+financialInternalRateOfReturnExtended\n+financialNetPresentValue\n+financialNetPresentValueExtended\n fips\n firstLine\n firstSignficantSubdomain\n@@ -2075,6 +2085,7 @@ isFinite\n isIPAddressInRange\n isIPv\n isInfinite\n+isMergeTreePartCoveredBy\n isNaN\n isNotDistinctFrom\n isNotNull\n@@ -2083,7 +2094,6 @@ isNullable\n isValidJSON\n isValidUTF\n isZeroOrNull\n-isMergeTreePartCoveredBy\n iteratively\n jaccard\n jaccardIndex\n@@ -2261,6 +2271,7 @@ mebibytes\n memtable\n memtables\n mergeTreeIndex\n+mergeTreePartInfo\n mergeTreeProjection\n mergeable\n mergetree\n@@ -2269,7 +2280,6 @@ metacharacters\n metasymbols\n metrica\n metroHash\n-mergeTreePartInfo\n mfedotov\n mflix\n minMap\ndiff --git a/ci/jobs/scripts/check_style/codespell-ignore-words.list b/ci/jobs/scripts/check_style/codespell-ignore-words.list\nindex 9593f98ff5d6..7803287c4af3 100644\n--- a/ci/jobs/scripts/check_style/codespell-ignore-words.list\n+++ b/ci/jobs/scripts/check_style/codespell-ignore-words.list\n@@ -33,3 +33,11 @@ ubuntu\n toolchain\n vie\n nin\n+cashflow\n+cashflows\n+Excel's\n+Raphson\n+xirr\n+XIRR\n+xnpv\n+XNPV\ndiff --git a/docs/en/sql-reference/functions/financial-functions.md b/docs/en/sql-reference/functions/financial-functions.md\nnew file mode 100644\nindex 000000000000..8e00e03757ad\n--- /dev/null\n+++ b/docs/en/sql-reference/functions/financial-functions.md\n@@ -0,0 +1,250 @@\n+---\n+description: 'Documentation for Financial Functions'\n+sidebar_label: 'Financial'\n+sidebar_position: 125\n+slug: /sql-reference/functions/financial-functions\n+title: 'Financial Functions'\n+---\n+\n+# Financial Functions\n+\n+## financialInternalRateOfReturn {#financialInternalRateOfReturn}\n+\n+Calculates the Internal Rate of Return (IRR) for a series of cash flows occurring at regular intervals. IRR is the discount rate at which the Net Present Value (NPV) equals zero.\n+\n+IRR attempts to solve the following equation:\n+\n+$$\n+\\sum_{i=0}^n \\frac{cashflow_i}{(1 + irr)^i} = 0\n+$$\n+\n+**Syntax**\n+\n+```sql\n+financialInternalRateOfReturn(cashflows[, guess])\n+```\n+\n+**Arguments**\n+\n+- `cashflows` \u2014 Array of cash flows. Each value represents a payment (negative value) or income (positive value). Type: Array of numeric values (Int8, Int16, Int32, Int64, Float32, Float64).\n+- `guess` \u2014 Optional initial guess (constant value) for the internal rate of return. Default: 0.1. Type: Float32|Float64.\n+\n+**Returned value**\n+\n+- Returns the internal rate of return as a Float64 value.\n+- Returns NaN if:\n+  - The calculation cannot converge\n+  - Input array is empty or has only one element\n+  - All cash flows are zero\n+  - Other calculation errors occur\n+\n+**Examples**\n+\n+Basic usage:\n+```sql\n+SELECT financialInternalRateOfReturn([-100000, 25000, 25000, 25000, 25000, 25000]);\n+```\n+```text\n+\u250c\u2500financialInt_00, 25000])\u2500\u2510\n+\u2502      0.07930826116052862 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+With initial guess:\n+```sql\n+SELECT financialInternalRateOfReturn([-100, 60, 60], 0.2);\n+```\n+```text\n+\u250c\u2500financialInt_, 60], 0.2)\u2500\u2510\n+\u2502      0.13066238629180732 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Notes**\n+\n+- The function uses Newton-Raphson and TOMS748 methods for finding the root.\n+- At least one cash flow must be negative and one must be positive for a meaningful IRR calculation.\n+\n+\n+## financialInternalRateOfReturnExtended {#financialInternalRateOfReturnExtended}\n+\n+Calculates the Extended Internal Rate of Return (XIRR) for a series of cash flows occurring at irregular intervals. XIRR is the discount rate at which the net present value (NPV) of all cash flows equals zero.\n+\n+XIRR attempts to solve the following equation (example for `ACT_365F`):\n+\n+$$\n+\\sum_{i=0}^n \\frac{cashflow_i}{(1 + rate)^{(date_i - date_0)/365}} = 0\n+$$\n+\n+**Syntax**\n+\n+```sql\n+financialInternalRateOfReturnExtended(cashflows, dates[, guess[, daycount]])\n+```\n+\n+**Arguments**\n+\n+- `cashflows` \u2014 Array of cash flows. Each value represents a payment (negative value) or income (positive value). Type: Array of numeric values (Int8, Int16, Int32, Int64, Float32, Float64).\n+- `dates` \u2014 Array of dates corresponding to each cash flow. Must be sorted in ascending order with unique values. Type: Array of Date or Date32.\n+- `guess` \u2014 Optional initial guess (constant value) for the internal rate of return. Default: 0.1. Type: Float32|Float64.\n+- `daycount` \u2014 Optional day count convention. Supported values:\n+  - 'ACT_365F' (default) \u2014 Actual/365 Fixed\n+  - 'ACT_365_25' \u2014 Actual/365.25\n+\n+**Returned value**\n+\n+- Returns the internal rate of return as a Float64 value.\n+- Returns NaN if:\n+  - The calculation cannot converge\n+  - Input arrays are empty or have only one element\n+  - All cash flows are zero\n+  - Dates are not sorted or not unique\n+  - Other calculation errors occur\n+\n+**Examples**\n+\n+Basic usage:\n+```sql\n+SELECT financialInternalRateOfReturnExtended(\n+    [-10000, 5750, 4250, 3250],\n+    [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')]\n+);\n+```\n+```text\n+\u250c\u2500financialInt_1-02-15')])\u2500\u2510\n+\u2502       0.6342972615260243 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Using different day count convention:\n+```sql\n+SELECT round(\n+    financialInternalRateOfReturnExtended([100000, -110000],\n+    [toDate('2020-01-01'), toDate('2021-01-01')],\n+    0.1,\n+    'ACT_365_25'\n+), 6) AS xirr_365_25;\n+```\n+```text\n+\u250c\u2500xirr_365_25\u2500\u2510\n+\u2502    0.099785 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Notes**\n+\n+- The function uses Newton-Raphson and TOMS748 methods for finding the root.\n+- The dates array must be sorted in ascending order with unique values.\n+\n+## financialNetPresentValueExtended {#financialNetPresentValueExtended}\n+\n+Calculates the Extended Net Present Value (XNPV) for a series of cash flows occurring at irregular intervals. XNPV considers the specific timing of each cash flow when calculating present value.\n+\n+XNPV equation for `ACT_365F`:\n+\n+$$\n+XNPV=\\sum_{i=1}^n \\frac{cashflow_i}{(1 + rate)^{(date_i - date_0)/365}}\n+$$\n+\n+**Syntax**\n+\n+```sql\n+financialNetPresentValueExtended(rate, cashflows, dates[, daycount])\n+```\n+\n+**Arguments**\n+\n+- `rate` \u2014 The discount rate to apply. Type: Float64.\n+- `cashflows` \u2014 Array of cash flows. Each value represents a payment (negative value) or income (positive value). Must contain at least one positive and one negative value. Type: Array of numeric values (Int8, Int16, Int32, Int64, Float32, Float64).\n+- `dates` \u2014 Array of dates corresponding to each cash flow. Must have the same size as cashflows array. Type: Array of Date or Date32.\n+- `daycount` \u2014 Optional day count convention. Supported values:\n+  - 'ACT_365F' (default) \u2014 Actual/365 Fixed\n+  - 'ACT_365_25' \u2014 Actual/365.25\n+\n+**Returned value**\n+\n+- Returns the net present value as a Float64 value.\n+\n+**Examples**\n+\n+Basic usage:\n+```sql\n+SELECT financialNetPresentValueExtended(0.1, [-10_000., 5750., 4250., 3250.], \n+    [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')]);\n+```\n+```text\n+\u250c\u2500financialNet_1-02-15')])\u2500\u2510\n+\u2502        2506.579458169746 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Using different day count convention:\n+```sql\n+SELECT financialNetPresentValueExtended(0.1, [-10_000., 5750., 4250., 3250.], \n+    [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')], \n+    'ACT_365_25');\n+```\n+```text\n+\u250c\u2500financialNet_CT_365_25')\u2500\u2510\n+\u2502        2507.067268742502 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## financialNetPresentValue {#financialNetPresentValue}\n+\n+Calculates the Net Present Value (NPV) of a series of cash flows assuming equal time intervals between each cash flow.\n+\n+Default variant:\n+\n+$$\n+\\sum_{i=0}^{N-1} \\frac{values_i}{(1 + rate)^i}\n+$$\n+\n+Variant with `start_from_zero` set to `False` (Excel style):\n+\n+$$\n+\\sum_{i=1}^{N} \\frac{values_i}{(1 + rate)^i}\n+$$\n+\n+**Syntax**\n+\n+```sql\n+financialNetPresentValue(rate, cashflows[, start_from_zero])\n+```\n+\n+**Arguments**\n+\n+- `rate` \u2014 The discount rate to apply. Type: Float64.\n+- `cashflows` \u2014 Array of cash flows. Each value represents a payment (negative value) or income (positive value). Type: Array of numeric values (Int8, Int16, Int32, Int64, Float32, Float64).\n+- `start_from_zero` \u2014 Optional boolean parameter indicating whether to start the NPV calculation from period 0 (true) or period 1 (false). Default: true.\n+\n+**Returned value**\n+\n+- Returns the net present value as a Float64 value.\n+\n+**Examples**\n+\n+Basic usage:\n+```sql\n+SELECT financialNetPresentValue(0.08, [-40_000., 5_000., 8_000., 12_000., 30_000.]);\n+```\n+```text\n+\u250c\u2500financialNet_., 30000.])\u2500\u2510\n+\u2502       3065.2226681795255 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+With start_from_zero = false (Excel compatibility mode):\n+```sql\n+SELECT financialNetPresentValue(0.08, [-40_000., 5_000., 8_000., 12_000., 30_000.], False);\n+```\n+```text\n+\u250c\u2500financialNet_30000.], 0)\u2500\u2510\n+\u2502       2838.1691372032656 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Notes**\n+\n+- When `start_from_zero = true`, the first cash flow is discounted by `(1 + rate)^0`, which equals 1\n+- When `start_from_zero = false`, the first cash flow is discounted by `(1 + rate)^1`, matching Excel's NPV function behavior\ndiff --git a/docs/en/sql-reference/functions/regular-functions-index.md b/docs/en/sql-reference/functions/regular-functions-index.md\nindex 043a527cacd4..b45a20f7e736 100644\n--- a/docs/en/sql-reference/functions/regular-functions-index.md\n+++ b/docs/en/sql-reference/functions/regular-functions-index.md\n@@ -44,6 +44,7 @@ title: 'Regular Functions'\n | [Distance](/sql-reference/functions/distance-functions) | Functions for calculating vector norms, distances, normalization, and common operations in linear algebra and machine learning. |\n | [Bitmap](/sql-reference/functions/bitmap-functions) | Functions for bitmaps.                                                                                                          |\n | [Math](/sql-reference/functions/math-functions)  | Mathematical functions.                                                                                                         |\n+| [Financial](/sql-reference/functions/financial-functions) | Financial functions.                                                                                                            |\n | [Encryption](/sql-reference/functions/encryption-functions) | Functions for encryption.                                                                                                       |\n | [Arithmetic](/sql-reference/functions/arithmetic-functions) | Functions for performing arithmetic on `UInt`, `Int` or `Float` types.                                                          |\n | [Embedded Dictionaries](/sql-reference/functions/ym-dict-functions) | Functions for Working with Embedded Dictionaries                                                                                |\ndiff --git a/src/Common/FunctionDocumentation.cpp b/src/Common/FunctionDocumentation.cpp\nindex dd52890e500b..eb86008c2eed 100644\n--- a/src/Common/FunctionDocumentation.cpp\n+++ b/src/Common/FunctionDocumentation.cpp\n@@ -201,6 +201,7 @@ String FunctionDocumentation::categoryAsString() const\n         {Category::Encoding, \"Encoding\"},\n         {Category::Encryption, \"Encryption\"},\n         {Category::File, \"File\"},\n+        {Category::Financial, \"Financial\"},\n         {Category::Hash, \"Hash\"},\n         {Category::IPAddress, \"IP Address\"},\n         {Category::Introspection, \"Introspection\"},\ndiff --git a/src/Common/FunctionDocumentation.h b/src/Common/FunctionDocumentation.h\nindex 47be29bb35dc..b0dfa5a91498 100644\n--- a/src/Common/FunctionDocumentation.h\n+++ b/src/Common/FunctionDocumentation.h\n@@ -94,6 +94,7 @@ struct FunctionDocumentation\n         Encoding,\n         Encryption,\n         File,\n+        Financial,\n         Hash,\n         IPAddress,\n         Introspection,\ndiff --git a/src/Functions/xirr.cpp b/src/Functions/xirr.cpp\nnew file mode 100644\nindex 000000000000..19bbd9905702\n--- /dev/null\n+++ b/src/Functions/xirr.cpp\n@@ -0,0 +1,1011 @@\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnVector.h>\n+#include <Columns/ColumnsDateTime.h>\n+#include <Columns/IColumn.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/IDataType.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <Interpreters/Context_fwd.h>\n+#include <base/types.h>\n+#include <Common/Exception.h>\n+#include <Common/FunctionDocumentation.h>\n+\n+#include <boost/math/tools/roots.hpp>\n+\n+#include <algorithm>\n+#include <expected>\n+#include <limits>\n+#include <optional>\n+#include <span>\n+#include <string_view>\n+#include <utility>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int LOGICAL_ERROR;\n+extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+namespace\n+{\n+\n+// To add new day count types:\n+// - add to DayCountType enum\n+// - add to parseDayCount function\n+// - add to yearFraction function and implement new date difference logic if necessary\n+enum class DayCountType\n+{\n+    ACT_365F,\n+    ACT_365_25,\n+};\n+\n+std::optional<DayCountType> parseDayCount(std::string_view day_count)\n+{\n+    using enum DayCountType;\n+    if (day_count == \"ACT_365F\")\n+        return ACT_365F;\n+    if (day_count == \"ACT_365_25\")\n+        return ACT_365_25;\n+    return std::nullopt;\n+}\n+\n+constexpr int daysBetweenAct(int d1, int d2)\n+{\n+    return d2 - d1;\n+}\n+\n+template <DayCountType day_count, typename D>\n+constexpr double yearFraction(D d1, D d2)\n+{\n+    if constexpr (day_count == DayCountType::ACT_365F)\n+        return daysBetweenAct(d1, d2) / 365.0;\n+    else if constexpr (day_count == DayCountType::ACT_365_25)\n+        return daysBetweenAct(d1, d2) / 365.25;\n+    else\n+        []<bool flag = false>() { static_assert(flag, \"Unsupported DayCountType\"); }();\n+}\n+\n+enum class IndexMode\n+{\n+    ZeroBased, // Cashflows are indexed starting from 0\n+    OneBased // Cashflows are indexed starting from 1 (Excel style) - option for NPV\n+};\n+\n+// NPV function and its derivative. Used for irr calculation\n+template <typename T>\n+struct NpvCalculator\n+{\n+    using FloatType = std::conditional_t<std::floating_point<T>, T, double>;\n+\n+    explicit NpvCalculator(std::span<T> cashflows_)\n+        : cashflows(cashflows_)\n+    {\n+        if (cashflows.empty()) [[unlikely]]\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow array must not be empty\");\n+    }\n+\n+    template <IndexMode index_mode = IndexMode::ZeroBased>\n+    double calculate(double rate) const\n+    {\n+        if (rate == 0)\n+            return std::accumulate(cashflows.begin(), cashflows.end(), 0.0);\n+        if (rate <= -1.0)\n+            return std::numeric_limits<double>::infinity();\n+\n+        double npv = 0.0;\n+        const double growth_factor = 1.0 + rate;\n+        if constexpr (index_mode == IndexMode::ZeroBased)\n+        {\n+            // First cashflow (t=0) is not discounted\n+            npv = cashflows[0];\n+\n+            // Discount subsequent cashflows (t=1, t=2, ...)\n+            double discount_factor = growth_factor; // (1+r)^1\n+            for (size_t i = 1; i < cashflows.size(); ++i)\n+            {\n+                npv += static_cast<FloatType>(cashflows[i]) / discount_factor;\n+                discount_factor *= growth_factor;\n+            }\n+        }\n+        else\n+        {\n+            // IndexMode::OneBased\n+            // All cashflows are discounted (t=1, t=2, ...)\n+            double discount_factor = growth_factor; // Start with (1+r)^1 for t=1\n+            for (size_t i = 0; i < cashflows.size(); ++i)\n+            {\n+                npv += static_cast<FloatType>(cashflows[i]) / discount_factor;\n+                discount_factor *= growth_factor;\n+            }\n+        }\n+        return npv;\n+    }\n+\n+    // Used only for IRR calculation, hence just ZeroBased\n+    double derivative(double rate) const\n+    {\n+        if (rate <= -1.0)\n+            return std::numeric_limits<double>::quiet_NaN();\n+\n+        double derivative = 0.0;\n+        double compound = (1.0 + rate);\n+\n+        for (size_t i = 1; i < cashflows.size(); ++i)\n+        {\n+            compound *= (1.0 + rate);\n+            derivative += -static_cast<FloatType>(cashflows[i]) * i / compound;\n+        }\n+        return derivative;\n+    }\n+\n+    std::span<T> cashflows;\n+};\n+\n+// NPV function used in the implementation of npv function\n+template <IndexMode index_mode, typename T>\n+double npv(double rate, std::span<T> cashflows)\n+{\n+    auto calc = NpvCalculator<T>(cashflows);\n+    return calc.template calculate<index_mode>(rate);\n+}\n+\n+\n+// XNPV function and its derivative. Used for xirr calculation\n+template <typename T, typename D, DayCountType day_count>\n+struct XnpvCalculator\n+{\n+    using FloatType = std::conditional_t<std::floating_point<T>, T, double>;\n+\n+    XnpvCalculator(std::span<T> cashflows_, std::span<D> dates_)\n+        : cashflows(cashflows_)\n+        , dates(dates_)\n+    {\n+        if (cashflows.size() != dates.size()) [[unlikely]]\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow and date arrays must have the same size\");\n+    }\n+\n+    double calculate(double rate) const\n+    {\n+        if (rate <= -1.0)\n+            return std::numeric_limits<double>::infinity();\n+\n+        double npv = 0.0;\n+\n+        for (size_t i = 0; i < cashflows.size(); ++i)\n+        {\n+            double time = yearFraction<day_count>(dates[0], dates[i]);\n+            if (time == 0.0)\n+                npv += cashflows[i];\n+            else\n+                npv += static_cast<FloatType>(cashflows[i]) / std::pow(1.0 + rate, time);\n+        }\n+\n+        return npv;\n+    }\n+\n+    double derivative(double rate) const\n+    {\n+        if (rate <= -1.0)\n+            return std::numeric_limits<double>::infinity();\n+\n+        double derivative = 0.0;\n+\n+        for (size_t i = 0; i < cashflows.size(); ++i)\n+        {\n+            double time = yearFraction<day_count>(dates[0], dates[i]);\n+            if (time != 0.0)\n+                derivative -= static_cast<FloatType>(cashflows[i]) * time / std::pow(1.0 + rate, time + 1);\n+        }\n+\n+        return derivative;\n+    }\n+\n+    std::span<T> cashflows;\n+    std::span<D> dates;\n+};\n+\n+// XNPV function used in the implementation of xnpv function\n+template <DayCountType day_count, typename T, typename D>\n+double xnpv(double rate, std::span<T> cashflows, std::span<D> dates)\n+{\n+    auto calc = XnpvCalculator<T, D, day_count>(cashflows, dates);\n+    return calc.calculate(rate);\n+}\n+\n+\n+enum class SolverErrorCode\n+{\n+    CANNOT_EVALUATE_VALUE,\n+    CANNOT_CONVERGE_DUE_TO_ROUNDING_ERRORS,\n+    CANNOT_CONVERGE_DUE_TO_INVALID_ARGUMENTS,\n+    CANNOT_CONVERGE_TOO_MANY_ITERATIONS,\n+    INPUT_DATES_NOT_SORTED_UNIQUE,\n+    NO_ROOT_FOUND_IN_BRACKET,\n+    OTHER_ERROR\n+};\n+\n+template <typename Function, typename Derivative>\n+std::expected<double, SolverErrorCode> solver(Function && fun, Derivative && der, double guess)\n+{\n+    constexpr int max_iterations = 100;\n+    constexpr double start_lower_bound = -0.999999; // Avoid the rate of -1.\n+    constexpr double start_upper_bound = 100.0; // Reasonable upper bound for financial applications IRR/XIRR\n+    constexpr double tolerance = 1e-6; // Tolerance for the result check\n+    try\n+    {\n+        boost::uintmax_t max_iter = max_iterations;\n+\n+        // 53 - 4 bits of precision => ~14.75 decimal digits - accurate enough for our purpose\n+        constexpr auto binary_precision = std::numeric_limits<double>::digits - 4;\n+\n+        double result = boost::math::tools::newton_raphson_iterate(\n+            [&fun, &der](double x) { return std::make_tuple(fun(x), der(x)); },\n+            guess,\n+            start_lower_bound,\n+            start_upper_bound,\n+            binary_precision,\n+            max_iter);\n+\n+        if (result >= start_lower_bound && result <= start_upper_bound && std::abs(fun(result)) < tolerance)\n+            return result;\n+\n+        // Fallback to TOMS748\n+        const double f_lower = fun(start_lower_bound);\n+        const double f_upper = fun(start_upper_bound);\n+\n+        if (f_lower * f_upper >= 0.0)\n+            return std::unexpected(SolverErrorCode::NO_ROOT_FOUND_IN_BRACKET);\n+\n+        max_iter = max_iterations;\n+        boost::math::tools::eps_tolerance<double> tol(std::numeric_limits<double>::digits - 4);\n+        auto toms_result = boost::math::tools::toms748_solve(fun, start_lower_bound, start_upper_bound, tol, max_iter);\n+\n+        return toms_result.first;\n+    }\n+    catch (const boost::math::evaluation_error &)\n+    {\n+        return std::unexpected(SolverErrorCode::CANNOT_EVALUATE_VALUE);\n+    }\n+    catch (const boost::math::rounding_error &)\n+    {\n+        return std::unexpected(SolverErrorCode::CANNOT_CONVERGE_DUE_TO_ROUNDING_ERRORS);\n+    }\n+    catch (const std::domain_error &)\n+    {\n+        return std::unexpected(SolverErrorCode::CANNOT_CONVERGE_DUE_TO_INVALID_ARGUMENTS);\n+    }\n+    catch (...)\n+    {\n+        return std::unexpected(SolverErrorCode::OTHER_ERROR);\n+    }\n+}\n+\n+template <DayCountType day_count, typename T, typename D>\n+std::expected<double, SolverErrorCode> calculateXirr(std::span<T> cashflows, std::span<D> dates, double guess)\n+{\n+    if (cashflows.size() != dates.size()) [[unlikely]]\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow and date arrays must have the same size\");\n+\n+    if (cashflows.size() <= 1) [[unlikely]]\n+        return std::numeric_limits<double>::quiet_NaN();\n+\n+    if (std::all_of(cashflows.begin(), cashflows.end(), [](T cf) { return cf == 0; })) [[unlikely]]\n+        return std::numeric_limits<double>::quiet_NaN();\n+\n+    for (size_t i = 1; i < dates.size(); ++i)\n+    {\n+        if (dates[i] <= dates[i - 1]) [[unlikely]]\n+            return std::unexpected(SolverErrorCode::INPUT_DATES_NOT_SORTED_UNIQUE);\n+    }\n+\n+    auto xnpv = XnpvCalculator<T, D, day_count>(cashflows, dates);\n+\n+    auto xnpv_function = [&](double rate) { return xnpv.calculate(rate); };\n+    auto xnpv_derivative = [&](double rate) { return xnpv.derivative(rate); };\n+\n+    return solver(xnpv_function, xnpv_derivative, guess);\n+}\n+\n+template <typename T>\n+std::expected<double, SolverErrorCode> calculateIrr(std::span<T> cashflows, double guess)\n+{\n+    if (cashflows.size() <= 1) [[unlikely]]\n+        return std::numeric_limits<double>::quiet_NaN();\n+\n+    bool any_positive = std::any_of(cashflows.begin(), cashflows.end(), [](T cf) { return cf > 0; });\n+    bool any_negative = std::any_of(cashflows.begin(), cashflows.end(), [](T cf) { return cf < 0; });\n+\n+    if (!(any_negative && any_positive)) [[unlikely]]\n+        return std::numeric_limits<double>::quiet_NaN();\n+\n+    auto npv = NpvCalculator<T>(cashflows);\n+\n+    auto npv_function = [&](double rate) { return npv.calculate(rate); };\n+    auto npv_derivative = [&](double rate) { return npv.derivative(rate); };\n+\n+    return solver(npv_function, npv_derivative, guess);\n+}\n+\n+bool isCashFlowColumn(const IDataType & type)\n+{\n+    if (isArray(type))\n+    {\n+        const auto & nested = checkAndGetDataType<DataTypeArray>(type).getNestedType();\n+        return isNativeInt(nested) || isFloat(nested);\n+    }\n+    return false;\n+}\n+\n+bool isXirrDateColumn(const IDataType & type)\n+{\n+    return isArray(type) && isDateOrDate32(checkAndGetDataType<DataTypeArray>(type).getNestedType());\n+}\n+\n+// Similar dispatch is needed in two of the functions below, so we define it here\n+template <typename T, typename F>\n+void dispatchDate(const T * cashflow_data, const IColumn * date_data, F && f)\n+{\n+    if (const auto * d = typeid_cast<const ColumnDate *>(date_data))\n+        f(cashflow_data, d);\n+    else if (const auto * d32 = typeid_cast<const ColumnDate32 *>(date_data))\n+        f(cashflow_data, d32);\n+    else\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Date array must contain Date or Date32 values\");\n+}\n+\n+template <typename F>\n+void dispatchCashflowDate(const IColumn * cashflow_data, const IColumn * date_data, F && f)\n+{\n+    if (const auto * cf64 = typeid_cast<const ColumnVector<Float64> *>(cashflow_data))\n+        dispatchDate(cf64, date_data, std::forward<F>(f));\n+    else if (const auto * cf32 = typeid_cast<const ColumnVector<Float32> *>(cashflow_data))\n+        dispatchDate(cf32, date_data, std::forward<F>(f));\n+    else if (const auto * ci8 = typeid_cast<const ColumnVector<Int8> *>(cashflow_data))\n+        dispatchDate(ci8, date_data, std::forward<F>(f));\n+    else if (const auto * ci16 = typeid_cast<const ColumnVector<Int16> *>(cashflow_data))\n+        dispatchDate(ci16, date_data, std::forward<F>(f));\n+    else if (const auto * ci32 = typeid_cast<const ColumnVector<Int32> *>(cashflow_data))\n+        dispatchDate(ci32, date_data, std::forward<F>(f));\n+    else if (const auto * ci64 = typeid_cast<const ColumnVector<Int64> *>(cashflow_data))\n+        dispatchDate(ci64, date_data, std::forward<F>(f));\n+    else\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cashflow array must contain Float64/Float32/Int64/Int32/Int16/Int8 values\");\n+}\n+\n+class FunctionXirr : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"financialInternalRateOfReturnExtended\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionXirr>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        auto mandatory_args = FunctionArgumentDescriptors{\n+            {\"cashflow\",\n+             static_cast<FunctionArgumentDescriptor::TypeValidator>(&isCashFlowColumn),\n+             nullptr,\n+             \"Array[Float64|Float32|Int64|Int32|Int16|Int8]\"},\n+            {\"date\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isXirrDateColumn), nullptr, \"Array[Date/Date32]\"},\n+        };\n+\n+        auto optional_args = FunctionArgumentDescriptors{\n+            {\"guess\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isFloat), nullptr, \"Float32|Float64\"},\n+            {\"daycount\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"},\n+        };\n+\n+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n+\n+        return std::make_shared<DataTypeFloat64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto cashflow_col = arguments[0].column->convertToFullIfNeeded();\n+        auto date_col = arguments[1].column->convertToFullIfNeeded();\n+\n+        const auto * cashflow_array = checkAndGetColumn<ColumnArray>(cashflow_col.get());\n+        const auto * date_array = checkAndGetColumn<ColumnArray>(date_col.get());\n+\n+        if (!cashflow_array || !date_array)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Both cashflow and date arguments must be arrays\");\n+\n+        const ColumnArray::Offsets & cashflow_offsets = cashflow_array->getOffsets();\n+        const ColumnArray::Offsets & date_offsets = date_array->getOffsets();\n+        if (cashflow_offsets.size() != date_offsets.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow and date arrays must have the same number of rows\");\n+\n+        double guess = 0.1;\n+        if (arguments.size() > 2)\n+        {\n+            if (!isColumnConst(*arguments[2].column))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Third argument (guess) must be a constant\");\n+            guess = arguments[2].column->getFloat64(0);\n+        }\n+\n+        DayCountType day_count = DayCountType::ACT_365F;\n+        if (arguments.size() > 3)\n+        {\n+            if (!isColumnConst(*arguments[3].column) || !isString(arguments[3].type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Fourth argument (daycount) must be a constant string\");\n+            auto day_count_str = arguments[3].column->getDataAt(0).toString();\n+            auto parsed_day_count = parseDayCount(day_count_str);\n+            if (!parsed_day_count.has_value())\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Invalid day count value: {}\", day_count_str);\n+            day_count = parsed_day_count.value();\n+        }\n+\n+        auto result_col = ColumnVector<Float64>::create(input_rows_count);\n+        auto & result_data = result_col->getData();\n+\n+        auto process_arrays\n+            = [&]<typename CashFlowCol, typename DateTypeCol>(const CashFlowCol * cashflow_values, const DateTypeCol * date_values)\n+        {\n+            using CashFlowType = const typename CashFlowCol::ValueType;\n+            using DateType = const typename DateTypeCol::ValueType;\n+\n+            auto loop = [&]<DayCountType day_count_type>\n+            {\n+                ColumnArray::Offset previous_offset = 0;\n+                for (size_t i = 0; i < cashflow_offsets.size(); ++i)\n+                {\n+                    const auto current_offset = cashflow_offsets[i];\n+                    if (current_offset != date_offsets[i])\n+                        throw Exception(\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow and date arrays must have the same size for each row\");\n+\n+                    const auto length = current_offset - previous_offset;\n+                    auto cashflow_span = std::span<CashFlowType>(cashflow_values->getData().data() + previous_offset, length);\n+                    auto date_span = std::span<DateType>(date_values->getData().data() + previous_offset, length);\n+\n+                    auto xirr = calculateXirr<day_count_type, CashFlowType, DateType>(cashflow_span, date_span, guess);\n+                    if (xirr.has_value()) [[likely]]\n+                        result_data[i] = xirr.value();\n+                    else\n+                        result_data[i] = std::numeric_limits<double>::quiet_NaN();\n+\n+                    previous_offset = current_offset;\n+                }\n+            };\n+            switch (day_count)\n+            {\n+                case DayCountType::ACT_365F:\n+                    return loop.template operator()<DayCountType::ACT_365F>();\n+                case DayCountType::ACT_365_25:\n+                    return loop.template operator()<DayCountType::ACT_365_25>();\n+            }\n+        };\n+\n+        const auto * cashflow_data = &cashflow_array->getData();\n+        const auto * date_data = &date_array->getData();\n+        dispatchCashflowDate(cashflow_data, date_data, process_arrays);\n+\n+        return result_col;\n+    }\n+};\n+\n+class FunctionIRR : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"financialInternalRateOfReturn\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIRR>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        auto mandatory_args = FunctionArgumentDescriptors{\n+            {\"cashflow\",\n+             static_cast<FunctionArgumentDescriptor::TypeValidator>(&isCashFlowColumn),\n+             nullptr,\n+             \"Array[Float64|Float32|Int64|Int32|Int16|Int8]\"},\n+        };\n+\n+        auto optional_args = FunctionArgumentDescriptors{\n+            {\"guess\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isFloat), nullptr, \"Float32|Float64\"},\n+        };\n+\n+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n+\n+        return std::make_shared<DataTypeFloat64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto cashflow_col = arguments[0].column->convertToFullIfNeeded();\n+        const auto * cashflow_array = checkAndGetColumn<ColumnArray>(cashflow_col.get());\n+        if (!cashflow_array)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cashflow argument must be an array\");\n+        const ColumnArray::Offsets & cashflow_offsets = cashflow_array->getOffsets();\n+\n+        double guess = 0.1;\n+        if (arguments.size() > 1)\n+        {\n+            if (!isColumnConst(*arguments[1].column))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Second argument (guess) must be a constant\");\n+            guess = arguments[1].column->getFloat64(0);\n+        }\n+\n+        auto result_col = ColumnVector<Float64>::create(input_rows_count);\n+        auto & result_data = result_col->getData();\n+        auto process_array = [&](const auto * cashflow_values)\n+        {\n+            ColumnArray::Offset previous_offset = 0;\n+            for (size_t i = 0; i < cashflow_offsets.size(); ++i)\n+            {\n+                const auto current_offset = cashflow_offsets[i];\n+                const auto length = current_offset - previous_offset;\n+\n+                if (length <= 1) [[unlikely]]\n+                {\n+                    result_data[i] = std::numeric_limits<double>::quiet_NaN();\n+                    previous_offset = current_offset;\n+                    continue;\n+                }\n+\n+                auto cashflow_span = std::span(cashflow_values->getData().data() + previous_offset, length);\n+                auto irr_result = calculateIrr(cashflow_span, guess);\n+\n+                if (irr_result.has_value())\n+                    result_data[i] = irr_result.value();\n+                else\n+                    result_data[i] = std::numeric_limits<double>::quiet_NaN();\n+\n+                previous_offset = current_offset;\n+            }\n+        };\n+\n+        const auto * cashflow_data = &cashflow_array->getData();\n+        if (const auto * cf64 = typeid_cast<const ColumnVector<Float64> *>(cashflow_data))\n+            process_array(cf64);\n+        else if (const auto * cf32 = typeid_cast<const ColumnVector<Float32> *>(cashflow_data))\n+            process_array(cf32);\n+        else if (const auto * ci8 = typeid_cast<const ColumnVector<Int8> *>(cashflow_data))\n+            process_array(ci8);\n+        else if (const auto * ci16 = typeid_cast<const ColumnVector<Int16> *>(cashflow_data))\n+            process_array(ci16);\n+        else if (const auto * ci32 = typeid_cast<const ColumnVector<Int32> *>(cashflow_data))\n+            process_array(ci32);\n+        else if (const auto * ci64 = typeid_cast<const ColumnVector<Int64> *>(cashflow_data))\n+            process_array(ci64);\n+        else\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cashflow array must contain Float64/Float32/Int64/Int32/Int16/Int8 values\");\n+\n+        return result_col;\n+    }\n+};\n+\n+class FunctionXnpv : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"financialNetPresentValueExtended\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionXnpv>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+\n+    bool isDeterministic() const override { return false; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        auto mandatory_args = FunctionArgumentDescriptors{\n+            {\"rate\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isFloat), nullptr, \"Float32|Float64\"},\n+            {\"cashflow\",\n+             static_cast<FunctionArgumentDescriptor::TypeValidator>(&isCashFlowColumn),\n+             nullptr,\n+             \"Array[Float64|Float32|Int64|Int32|Int16|Int8]\"},\n+            {\"date\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isXirrDateColumn), nullptr, \"Array[Date|Date32]\"},\n+        };\n+\n+        auto optional_args = FunctionArgumentDescriptors{\n+            {\"daycount\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"},\n+        };\n+\n+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n+\n+        return std::make_shared<DataTypeFloat64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto rate_col = arguments[0].column->convertToFullIfNeeded();\n+        auto cashflow_col = arguments[1].column->convertToFullIfNeeded();\n+        auto date_col = arguments[2].column->convertToFullIfNeeded();\n+\n+        const auto * cashflow_array = checkAndGetColumn<ColumnArray>(cashflow_col.get());\n+        const auto * date_array = checkAndGetColumn<ColumnArray>(date_col.get());\n+\n+        if (!cashflow_array || !date_array)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Both cashflow and date arguments must be arrays\");\n+\n+        const ColumnArray::Offsets & cashflow_offsets = cashflow_array->getOffsets();\n+        const ColumnArray::Offsets & date_offsets = date_array->getOffsets();\n+        if (cashflow_offsets.size() != date_offsets.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow and date arrays must have the same number of rows\");\n+\n+        DayCountType day_count = DayCountType::ACT_365F;\n+        if (arguments.size() > 3)\n+        {\n+            if (!isColumnConst(*arguments[3].column) || !isString(arguments[3].type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Fourth argument (daycount) must be a constant string\");\n+            auto day_count_str = arguments[3].column->getDataAt(0).toString();\n+            auto parsed_day_count = parseDayCount(day_count_str);\n+            if (!parsed_day_count.has_value())\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Invalid day count value: {}\", day_count_str);\n+            day_count = parsed_day_count.value();\n+        }\n+\n+        auto result_col = ColumnVector<Float64>::create(input_rows_count);\n+        auto & result_data = result_col->getData();\n+\n+        auto process_arrays = [&]<typename CashFlowCol, typename DateTypeCol>(\n+                                  const CashFlowCol * cashflow_values, const DateTypeCol * date_values, const auto & rate_pod)\n+        {\n+            using CashFlowType = const typename CashFlowCol::ValueType;\n+            using DateType = const typename DateTypeCol::ValueType;\n+            auto loop = [&]<DayCountType day_count_type>\n+            {\n+                ColumnArray::Offset previous_offset = 0;\n+                for (size_t i = 0; i < cashflow_offsets.size(); ++i)\n+                {\n+                    const auto current_offset = cashflow_offsets[i];\n+                    if (current_offset != date_offsets[i])\n+                        throw Exception(\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Cashflow and date arrays must have the same size for each row\");\n+                    const auto rate = rate_pod[i];\n+\n+                    const auto length = current_offset - previous_offset;\n+                    auto cashflow_span = std::span<CashFlowType>(cashflow_values->getData().data() + previous_offset, length);\n+                    auto date_span = std::span<DateType>(date_values->getData().data() + previous_offset, length);\n+\n+                    result_data[i] = xnpv<day_count_type, CashFlowType, DateType>(rate, cashflow_span, date_span);\n+\n+                    previous_offset = current_offset;\n+                }\n+            };\n+            switch (day_count)\n+            {\n+                case DayCountType::ACT_365F:\n+                    return loop.template operator()<DayCountType::ACT_365F>();\n+                case DayCountType::ACT_365_25:\n+                    return loop.template operator()<DayCountType::ACT_365_25>();\n+            }\n+        };\n+\n+        auto dispatch = [&](const auto * cashflow_data, const auto * date_data)\n+        {\n+            if (const auto * rate_f64 = checkAndGetColumn<ColumnVector<Float64>>(rate_col.get()))\n+                process_arrays(cashflow_data, date_data, rate_f64->getData());\n+            else if (const auto * rate_f32 = checkAndGetColumn<ColumnVector<Float32>>(rate_col.get()))\n+                process_arrays(cashflow_data, date_data, rate_f32->getData());\n+            else\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Rate argument must be a Float32|Float64 column\");\n+        };\n+\n+        const auto * cashflow_data = &cashflow_array->getData();\n+        const auto * date_data = &date_array->getData();\n+        dispatchCashflowDate(cashflow_data, date_data, dispatch);\n+\n+        return result_col;\n+    }\n+};\n+\n+class FunctionNPV : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"financialNetPresentValue\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionNPV>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    bool isVariadic() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        auto mandatory_args = FunctionArgumentDescriptors{\n+            {\"rate\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isFloat), nullptr, \"Float32|Float64\"},\n+            {\"cashflow\",\n+             static_cast<FunctionArgumentDescriptor::TypeValidator>(&isCashFlowColumn),\n+             nullptr,\n+             \"Array[Float64|Float32|Int64|Int32|Int16|Int8]\"},\n+        };\n+\n+        auto optional_args = FunctionArgumentDescriptors{\n+            {\"start_from_zero\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isInteger), nullptr, \"Bool\"},\n+        };\n+\n+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n+\n+        return std::make_shared<DataTypeFloat64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto rate_col = arguments[0].column->convertToFullIfNeeded();\n+        auto cashflow_col = arguments[1].column->convertToFullIfNeeded();\n+\n+        const auto * cashflow_array = checkAndGetColumn<ColumnArray>(cashflow_col.get());\n+        if (!cashflow_array)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cashflow argument must be an array\");\n+\n+        bool start_from_zero = true;\n+        if (arguments.size() > 2)\n+        {\n+            if (!isColumnConst(*arguments[2].column) || !isInteger(arguments[2].type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Third argument (start_from_zero) must be a constant boolean\");\n+            start_from_zero = arguments[2].column->getUInt(0) != 0;\n+        }\n+\n+        auto result_col = ColumnVector<Float64>::create(input_rows_count);\n+        auto & result_data = result_col->getData();\n+\n+        const ColumnArray::Offsets & cashflow_offsets = cashflow_array->getOffsets();\n+\n+        auto process_array = [&]<typename CashFlowCol>(const CashFlowCol * cashflow_values, const auto & rate_pod)\n+        {\n+            using CashFlowType = const typename CashFlowCol::ValueType;\n+            auto loop = [&]<IndexMode index_mode>()\n+            {\n+                ColumnArray::Offset previous_offset = 0;\n+                for (size_t i = 0; i < cashflow_offsets.size(); ++i)\n+                {\n+                    const auto current_offset = cashflow_offsets[i];\n+                    const auto length = current_offset - previous_offset;\n+                    const auto rate = rate_pod[i];\n+                    auto cashflow_span = std::span(cashflow_values->getData().data() + previous_offset, length);\n+\n+                    result_data[i] = npv<index_mode, CashFlowType>(rate, cashflow_span);\n+\n+                    previous_offset = current_offset;\n+                }\n+            };\n+\n+            if (start_from_zero)\n+                loop.template operator()<IndexMode::ZeroBased>();\n+            else\n+                loop.template operator()<IndexMode::OneBased>();\n+        };\n+\n+        auto dispatch = [&](const auto * cashflow_data)\n+        {\n+            if (const auto * rate_f64 = checkAndGetColumn<ColumnVector<Float64>>(rate_col.get()))\n+                process_array(cashflow_data, rate_f64->getData());\n+            else if (const auto * rate_f32 = checkAndGetColumn<ColumnVector<Float32>>(rate_col.get()))\n+                process_array(cashflow_data, rate_f32->getData());\n+            else\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Rate argument must be a Float32|Float64 column\");\n+        };\n+\n+        const auto * cashflow_data = &cashflow_array->getData();\n+\n+        if (const auto * cf64 = typeid_cast<const ColumnVector<Float64> *>(cashflow_data))\n+            dispatch(cf64);\n+        else if (const auto * cf32 = typeid_cast<const ColumnVector<Float32> *>(cashflow_data))\n+            dispatch(cf32);\n+        else if (const auto * ci8 = typeid_cast<const ColumnVector<Int8> *>(cashflow_data))\n+            dispatch(ci8);\n+        else if (const auto * ci16 = typeid_cast<const ColumnVector<Int16> *>(cashflow_data))\n+            dispatch(ci16);\n+        else if (const auto * ci32 = typeid_cast<const ColumnVector<Int32> *>(cashflow_data))\n+            dispatch(ci32);\n+        else if (const auto * ci64 = typeid_cast<const ColumnVector<Int64> *>(cashflow_data))\n+            dispatch(ci64);\n+        else\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cashflow array must contain Float64/Float32/Int64/Int32/Int16/Int8 values\");\n+\n+        return result_col;\n+    }\n+};\n+\n+}\n+\n+REGISTER_FUNCTION(FunctionXirr)\n+{\n+    FunctionDocumentation::Description description = R\"(\n+Calculates the Extended Internal Rate of Return (XIRR) for a series of cash flows occurring at irregular intervals. XIRR is the discount rate at which the net present value (NPV) of all cash flows equals zero.\n+\n+XIRR attempts to solve the following equation (example for `ACT_365F`):\n+\n+$$\n+\\sum_{i=0}^n \\frac{cashflow_i}{(1 + rate)^{(date_i - date_0)/365}} = 0\n+$$\n+\n+Arrays should be sorted by date in ascending order. Dates need to be unique.\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"financialInternalRateOfReturnExtended(cashflow, date [, guess, daycount])\";\n+    FunctionDocumentation::Arguments arguments\n+        = {{\"cashflow\",\n+            \"An array of cash flows corresponding to the dates in second param. \"\n+            \"[`Array(Int8|Int16|Int32|Int64|Float32|Float64)`](/sql-reference/data-types/array)\"},\n+           {\"date\",\n+            \"A sorted array of unique dates corresponding to the cash flows. \"\n+            \"[`Array(Date|Date32)`](/sql-reference/data-types/array).\"},\n+           {\"[, guess]\",\n+            \"Optional. Initial guess (constant value) for the XIRR calculation. [`Float32|Float64`](/sql-reference/data-types/float)\"},\n+           {\"[, daycount]\",\n+            \"Optional day count convention (default 'ACT_365F'). Supported values:\\n\"\n+            \"- 'ACT_365F' - Actual/365 Fixed: Uses actual number of days between dates divided by 365\\n\"\n+            \"- 'ACT_365_25' - Actual/365.25: Uses actual number of days between dates divided by 365.25\"}};\n+    FunctionDocumentation::ReturnedValue returned_value{\n+        \"Returns the XIRR value. If the calculation cannot be performed, it returns NaN. [`Float64`](/sql-reference/data-types/float)\"};\n+    FunctionDocumentation::Examples examples = {\n+        {\"simple_example\",\n+         R\"(\n+SELECT financialInternalRateOfReturnExtended([-10000, 5750, 4250, 3250], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')])\n+        )\",\n+         \"0.6342972615260243\"},\n+        {\"simple_example_with_guess\",\n+         R\"(\n+SELECT financialInternalRateOfReturnExtended([-10000, 5750, 4250, 3250], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')], 0.5)\n+        )\",\n+         \"0.6342972615260243\"},\n+        {\"simple_example_daycount\",\n+         R\"(\n+SELECT round(financialInternalRateOfReturnExtended([100000, -110000], [toDate('2020-01-01'), toDate('2021-01-01')], 0.1, 'ACT_365_25'), 6) AS xirr_365_25\n+        )\",\n+         \"0.099785\"},\n+    };\n+    FunctionDocumentation::IntroducedIn introduced_in = {25, 7};\n+    FunctionDocumentation::Category category = FunctionDocumentation::Category::Financial;\n+    FunctionDocumentation documentation = {description, syntax, arguments, returned_value, examples, introduced_in, category};\n+\n+    factory.registerFunction<FunctionXirr>(documentation);\n+}\n+\n+REGISTER_FUNCTION(FunctionIRR)\n+{\n+    FunctionDocumentation::Description description = R\"(\n+Calculates the Internal Rate of Return (IRR) for a series of cash flows occurring at regular intervals. IRR is the discount rate at which the Net Present Value (NPV) equals zero.\n+\n+IRR attempts to solve the following equation:\n+\n+$$\n+\\sum_{i=0}^n \\frac{cashflow_i}{(1 + irr)^i} = 0\n+$$\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"financialInternalRateOfReturn(cashflows[, guess])\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"cashflows\",\n+         \"Array of cash flows. Each value represents a payment (negative value) or income (positive value). \"\n+         \"[`Array(Int8|Int16|Int32|Int64|Float32|Float64)`](/sql-reference/data-types/array)\"},\n+        {\"[, guess]\",\n+         \"Optional initial guess (constant value) for the internal rate of return (default 0.1). \"\n+         \"[`Float32|Float64`](/sql-reference/data-types/float)\"},\n+    };\n+    FunctionDocumentation::ReturnedValue returned_value{\n+        \"Returns the internal rate of return as a Float64 value. Returns NaN if the calculation cannot converge, input array is empty or \"\n+        \"has only one element, all cash flows are zero, or other calculation errors occur. [`Float64`](/sql-reference/data-types/float)\"};\n+    FunctionDocumentation::Examples examples = {\n+        {\"simple_example\", \"SELECT financialInternalRateOfReturn([-100, 39, 59, 55, 20])\", \"0.2809484211599611\"},\n+        {\"simple_example_with_guess\", \"SELECT financialInternalRateOfReturn([-100, 39, 59, 55, 20], 0.1)\", \"0.2809484211599611\"},\n+    };\n+    FunctionDocumentation::IntroducedIn introduced_in = {25, 7};\n+    FunctionDocumentation::Category category = FunctionDocumentation::Category::Financial;\n+    FunctionDocumentation documentation = {description, syntax, arguments, returned_value, examples, introduced_in, category};\n+\n+    factory.registerFunction<FunctionIRR>(documentation);\n+}\n+\n+REGISTER_FUNCTION(FunctionXnpv)\n+{\n+    FunctionDocumentation::Description description = R\"(\n+Calculates the Extended Net Present Value (XNPV) for a series of cash flows occurring at irregular intervals. XNPV considers the specific timing of each cash flow when calculating present value.\n+\n+XNPV equation for `ACT_365F`:\n+\n+$$\n+XNPV=\\sum_{i=1}^n \\frac{cashflow_i}{(1 + rate)^{(date_i - date_0)/365}}\n+$$\n+\n+Arrays should be sorted by date in ascending order. Dates need to be unique.\n+    )\";\n+    FunctionDocumentation::Syntax syntax = \"financialNetPresentValueExtended(rate, cashflow, date [, daycount])\";\n+    FunctionDocumentation::Arguments arguments\n+        = {{\"rate\",\n+            \"The discount rate to apply. \"\n+            \"[`Float32|Float64`](/sql-reference/data-types/float)\"},\n+           {\"cashflow\",\n+            \"Array of cash flows. Each value represents a payment (negative value) or income (positive value). Must contain at least one \"\n+            \"positive and one negative value. \"\n+            \"[`Array(Int8|Int16|Int32|Int64|Float32|Float64)`](/sql-reference/data-types/array)\"},\n+           {\"date\",\n+            \"Array of dates corresponding to each cash flow. Must have the same size as cashflows array. \"\n+            \"[`Array(Date|Date32)`](/sql-reference/data-types/array)\"},\n+           {\"[, daycount]\",\n+            \"Optional day count convention (default 'ACT_365F'). Supported values:\\n\"\n+            \"- 'ACT_365F' - Actual/365 Fixed: Uses actual number of days between dates divided by 365\\n\"\n+            \"- 'ACT_365_25' - Actual/365.25: Uses actual number of days between dates divided by 365.25\"}};\n+    FunctionDocumentation::ReturnedValue returned_value{\n+        \"Returns the net present value as a Float64 value. [`Float64`](/sql-reference/data-types/float)\"};\n+    FunctionDocumentation::Examples examples = {\n+        {\"simple_example\",\n+         R\"(\n+SELECT financialNetPresentValueExtended(0.1, [-10000., 5750., 4250., 3250.], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')])\n+         )\",\n+         \"2506.579458169746\"},\n+        {\"simple_example_with_daycount\",\n+         R\"(\n+SELECT financialNetPresentValueExtended(0.1, [-10000., 5750., 4250., 3250.], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')], 'ACT_365_25')\n+         )\",\n+         \"2507.067268742502\"},\n+    };\n+    FunctionDocumentation::IntroducedIn introduced_in = {25, 7};\n+    FunctionDocumentation::Category category = FunctionDocumentation::Category::Financial;\n+    FunctionDocumentation documentation = {description, syntax, arguments, returned_value, examples, introduced_in, category};\n+\n+    factory.registerFunction<FunctionXnpv>(documentation);\n+}\n+\n+REGISTER_FUNCTION(FunctionNPV)\n+{\n+    FunctionDocumentation::Description description = R\"(\n+Calculates the Net Present Value (NPV) of a series of cash flows assuming equal time intervals between each cash flow.\n+\n+Default variant (start_from_zero = true):\n+\n+$$\n+\\sum_{i=0}^{N-1} \\frac{values_i}{(1 + rate)^i}\n+$$\n+\n+Excel-compatible variant (start_from_zero = false):\n+\n+$$\n+\\sum_{i=1}^{N} \\frac{values_i}{(1 + rate)^i}\n+$$\n+    )\";\n+\n+    FunctionDocumentation::Syntax syntax = \"financialNetPresentValue(rate, cashflows[, start_from_zero])\";\n+    FunctionDocumentation::Arguments arguments\n+        = {{\"rate\",\n+            \"The discount rate to apply. \"\n+            \"[`Float32|Float64`](/sql-reference/data-types/float)\"},\n+           {\"cashflows\",\n+            \"Array of cash flows. Each value represents a payment (negative value) or income (positive value). \"\n+            \"[`Array(Int8|Int16|Int32|Int64|Float32|Float64)`](/sql-reference/data-types/array)\"},\n+           {\"[, start_from_zero]\",\n+            \"Optional boolean parameter indicating whether to start the NPV calculation from period 0 (true) or period 1 (false, \"\n+            \"Excel-compatible). Default: true. \"\n+            \"[`Boolean`](/sql-reference/data-types/boolean)\"}};\n+\n+    FunctionDocumentation::ReturnedValue returned_value{\n+        \"Returns the net present value as a Float64 value. [`Float64`](/sql-reference/data-types/float)\"};\n+\n+    FunctionDocumentation::Examples examples\n+        = {{\"default_calculation\", \"SELECT financialNetPresentValue(0.08, [-40000., 5000., 8000., 12000., 30000.])\", \"3065.2226681795255\"},\n+           {\"excel_compatible_calculation\",\n+            \"SELECT financialNetPresentValue(0.08, [-40000., 5000., 8000., 12000., 30000.], false)\",\n+            \"2838.1691372032656\"}};\n+\n+    FunctionDocumentation::IntroducedIn introduced_in = {25, 7};\n+    FunctionDocumentation::Category category = FunctionDocumentation::Category::Financial;\n+    FunctionDocumentation documentation = {description, syntax, arguments, returned_value, examples, introduced_in, category};\n+\n+    factory.registerFunction<FunctionNPV>(documentation);\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/fuzz/all.dict b/tests/fuzz/all.dict\nindex 24d766c678c0..543721505623 100644\n--- a/tests/fuzz/all.dict\n+++ b/tests/fuzz/all.dict\n@@ -1980,6 +1980,10 @@\n \"filesystemCapacity\"\n \"filesystemUnreserved\"\n \"finalizeAggregation\"\n+\"financialInternalRateOfReturn\"\n+\"financialInternalRateOfReturnExtended\"\n+\"financialNetPresentValue\"\n+\"financialNetPresentValueExtended\"\n \"firstLine\"\n \"firstSignificantSubdomain\"\n \"firstSignificantSubdomainCustom\"\ndiff --git a/tests/fuzz/dictionaries/functions.dict b/tests/fuzz/dictionaries/functions.dict\nindex d400cf23c6ce..ef43fae898f7 100644\n--- a/tests/fuzz/dictionaries/functions.dict\n+++ b/tests/fuzz/dictionaries/functions.dict\n@@ -1288,6 +1288,10 @@\n \"filesystemCapacity\"\n \"filesystemUnreserved\"\n \"finalizeAggregation\"\n+\"financialInternalRateOfReturn\"\n+\"financialInternalRateOfReturnExtended\"\n+\"financialNetPresentValue\"\n+\"financialNetPresentValueExtended\"\n \"firstLine\"\n \"firstSignificantSubdomain\"\n \"firstSignificantSubdomainCustom\"\ndiff --git a/tests/queries/0_stateless/03533_xirr.reference b/tests/queries/0_stateless/03533_xirr.reference\nnew file mode 100644\nindex 000000000000..1f3352449ccd\n--- /dev/null\n+++ b/tests/queries/0_stateless/03533_xirr.reference\n@@ -0,0 +1,45 @@\n+0.634297\n+0.634297\n+0.634297\n+Different day count modes:\n+0.099714\t0.099785\n+Zero cashflow entries -> NaN:\n+nan\n+Just one cashflow entry -> NaN:\n+nan\n+Zero cashflow -> NaN:\n+nan\n+Unsorted dates -> NaN:\n+nan\n+Non-unique dates -> NaN:\n+nan\n+a\t0.120613\t0.120613\t0.120613\t0.120613\t0.120613\t0.120613\n+b\t0.131617\t0.131617\t0.131617\t0.131617\t0.131617\t0.131617\n+c\t0.291987\t0.291987\t0.291987\t0.291987\t0.291987\t0.291987\n+d\t0.634297\t0.634297\t0.634297\t0.634297\t0.634297\t0.634297\n+IRR\n+[-100,39,59,55,20]\t0.280948\t0.000069\n+nan\n+XNPV:\n+-10\n+0\n+2506.579458\n+2507.067269\n+a\t312.783248\t312.783248\t312.783263\n+b\t146.011394\t146.011394\t146.011381\n+c\t1808.313857\t1808.313857\t1808.313841\n+d\t2439.178213\t2439.178213\t2439.178217\n+NPV:\n+3065.222668\n+3065.222668\n+2838.169137\n+a\t-363.51166\t-363.51166\t-363.511632\n+b\t-181.382039\t-181.382039\t-181.382063\n+c\t-373.266853\t-373.266853\t-373.266896\n+d\t1005.947511\t1005.947511\t1005.947521\n+Excel docs example:\n+1188.443412\n+1922.0615550000002\n+2086.647602\n+0.086631\n+0.373363\ndiff --git a/tests/queries/0_stateless/03533_xirr.sql b/tests/queries/0_stateless/03533_xirr.sql\nnew file mode 100644\nindex 000000000000..6ce675f2bace\n--- /dev/null\n+++ b/tests/queries/0_stateless/03533_xirr.sql\n@@ -0,0 +1,145 @@\n+SELECT round(financialInternalRateOfReturnExtended([-10000, 5750, 4250, 3250], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')]), 6) AS xirr_rate;\n+SELECT round(financialInternalRateOfReturnExtended([-10000, 5750, 4250, 3250], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')], 0.5), 6) AS xirr_rate;\n+SELECT round(financialInternalRateOfReturnExtended([-10000, 5750, 4250, 3250], [toDate32('2020-01-01'), toDate32('2020-03-01'), toDate32('2020-10-30'), toDate32('2021-02-15')]), 6) AS xirr_rate;\n+\n+SELECT 'Different day count modes:';\n+SELECT round(financialInternalRateOfReturnExtended([100000, -110000], [toDate('2020-01-01'), toDate('2021-01-01')], 0.1, 'ACT_365F'), 6) AS xirr_365,\n+    round(financialInternalRateOfReturnExtended([100000, -110000], [toDate('2020-01-01'), toDate('2021-01-01')], 0.1, 'ACT_365_25'), 6) AS xirr_365_25;\n+\n+SELECT financialInternalRateOfReturnExtended(123, toDate('2020-01-01')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialInternalRateOfReturnExtended([123], toDate('2020-01-01')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialInternalRateOfReturnExtended(123, [toDate('2020-01-01')]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT round(financialInternalRateOfReturnExtended([-10000], [toDate32('2020-01-01'), toDate32('2020-03-01'), toDate32('2020-10-30'), toDate32('2021-02-15')]), 6) AS xirr_rate; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT round(financialInternalRateOfReturnExtended([-10000, NULL, 4250, 3250], [toDate32('2020-01-01'), toDate32('2020-03-01'), toDate32('2020-10-30'), toDate32('2021-02-15')]), 6) AS xirr_rate; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialInternalRateOfReturnExtended([-100, 110], [toDate('2020-01-01'), toDate('2020-02-01')], 1);  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialInternalRateOfReturnExtended([-100, 110], [toDate('2020-01-01'), toDate('2020-02-01')], 1.0, 'QWERTY');  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Zero cashflow entries -> NaN:';\n+SELECT financialInternalRateOfReturnExtended([]::Array(Float32), []::Array(Date));\n+SELECT 'Just one cashflow entry -> NaN:';\n+SELECT financialInternalRateOfReturnExtended([-10000], [toDate('2020-01-01')]);\n+SELECT 'Zero cashflow -> NaN:';\n+SELECT financialInternalRateOfReturnExtended([-0., 0.], [toDate('2020-01-01'), toDate('2020-01-02')]);\n+SELECT 'Unsorted dates -> NaN:';\n+SELECT round(financialInternalRateOfReturnExtended([-10000, 5750, 4250, 3250], [toDate('2025-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')]), 6) AS xirr_rate;\n+SELECT 'Non-unique dates -> NaN:';\n+SELECT financialInternalRateOfReturnExtended([-100, 10], [toDate('2020-01-01'), toDate('2020-01-01')]);\n+\n+CREATE TABLE IF NOT EXISTS 3533_xirr_test (\n+    tag String,\n+    date Date,\n+    date32 Date32,\n+    value Float64,\n+    r Float64\n+) ENGINE = Memory;\n+\n+INSERT INTO 3533_xirr_test VALUES\n+('a', '2020-01-01', '2020-01-01', -10000, 0.08),\n+('a', '2020-06-01', '2020-06-01', 3000, 0.08),\n+('a', '2020-12-31', '2020-12-31', 8000, 0.08),\n+('b', '2020-03-15', '2020-03-15', -5000, 0.09),\n+('b', '2020-09-15', '2020-09-15', 2500, 0.09),\n+('b', '2021-03-15', '2021-03-15', 3000, 0.09),\n+('c', '2019-12-31', '2019-12-31', -15000, 0.10),\n+('c', '2020-04-30', '2020-04-30', 5000, 0.10),\n+('c', '2020-08-31', '2020-08-31', 6000, 0.10),\n+('c', '2020-12-31', '2020-12-31', 5000, 0.10),\n+('c', '2021-02-28', '2021-02-28', 2000, 0.10),\n+('d', '2020-01-01', '2020-01-01', -10000, 0.11),\n+('d', '2020-03-01', '2020-03-01', 5750, 0.11),\n+('d', '2020-10-30', '2020-10-30', 4250, 0.11),\n+('d', '2021-02-15', '2021-02-15', 3250, 0.11)\n+;\n+\n+SELECT\n+    tag,\n+    round( financialInternalRateOfReturnExtended(groupArray(value), groupArray(date)), 6) AS result_f64_date,\n+    round( financialInternalRateOfReturnExtended(groupArray(value), groupArray(date32)), 6) AS result_f64_date32,\n+    round( financialInternalRateOfReturnExtended(groupArray(toFloat32(value)), groupArray(date)), 6) AS result_f32_date,\n+    round( financialInternalRateOfReturnExtended(groupArray(toFloat32(value)), groupArray(date32)), 6) AS result_f32_date32,\n+    round( financialInternalRateOfReturnExtended(groupArray(toInt64(value)), groupArray(date)), 6) AS result_i64_date,\n+    round( financialInternalRateOfReturnExtended(groupArray(toInt64(value)), groupArray(date32)), 6) AS result_i64_date32\n+FROM (\n+    SELECT\n+        tag,\n+        date,\n+        date32,\n+        value\n+    FROM 3533_xirr_test\n+    ORDER BY tag, date\n+)\n+GROUP BY tag\n+ORDER BY tag;\n+\n+SELECT 'IRR';\n+SELECT financialInternalRateOfReturn(123);  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialInternalRateOfReturn([1,2,NULL]);  -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialInternalRateOfReturn([]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT [-100, 39, 59, 55, 20] as cf, round(financialInternalRateOfReturn(cf), 6) as irr_rate, round(financialNetPresentValue(irr_rate, cf), 6) as financialNetPresentValue_from_irr;\n+SELECT financialInternalRateOfReturn([0., 39., 59., 55., 20.]);\n+\n+SELECT 'XNPV:';\n+SELECT financialNetPresentValueExtended(0.1, 123., [toDate('2020-01-01')]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialNetPresentValueExtended(0.1, [123.], toDate('2020-01-01')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialNetPresentValueExtended(0.1, [-100, 110], [toDate('2020-01-01'), toDate('2020-02-01')], 'QWERTY'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialNetPresentValueExtended(0.1, [], []); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT financialNetPresentValueExtended(0.1, [-10], [toDate('2020-01-01')]);\n+SELECT financialNetPresentValueExtended(0.1, [-0., 0.], [toDate('2020-01-01'), toDate('2020-01-02')]);\n+SELECT round(financialNetPresentValueExtended(0.1, [-10_000., 5750., 4250., 3250.], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')]), 6);\n+SELECT round(financialNetPresentValueExtended(0.1, [-10_000., 5750., 4250., 3250.], [toDate('2020-01-01'), toDate('2020-03-01'), toDate('2020-10-30'), toDate('2021-02-15')], 'ACT_365_25'), 6);\n+\n+SELECT tag,\n+    round(financialNetPresentValueExtended(any(r), groupArray(value), groupArray(date)), 6) AS financialNetPresentValueExtended_f64_date,\n+    round(financialNetPresentValueExtended(any(r), groupArray(value), groupArray(date32)), 6) AS financialNetPresentValueExtended_f64_date32,\n+    round(financialNetPresentValueExtended(any(toFloat32(r)), groupArray(toFloat32(value)), groupArray(date)), 6) AS financialNetPresentValueExtended_f32_date\n+FROM (\n+    SELECT\n+        tag,\n+        date,\n+        date32,\n+        value,\n+        r\n+    FROM 3533_xirr_test\n+    ORDER BY tag, date\n+)\n+GROUP BY tag\n+ORDER BY tag;\n+\n+\n+SELECT 'NPV:';\n+SELECT financialNetPresentValue(0.1, 123., True); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialNetPresentValue(0.1, [1.,2.], 2.); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialNetPresentValue(0.1, [1.,NULL]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT financialNetPresentValue(0.1, []); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT round(financialNetPresentValue(0.08, [-40_000., 5_000., 8_000., 12_000., 30_000.]), 6);\n+SELECT round(financialNetPresentValue(0.08, [-40_000., 5_000., 8_000., 12_000., 30_000.], True), 6);\n+SELECT round(financialNetPresentValue(0.08, [-40_000., 5_000., 8_000., 12_000., 30_000.], False), 6);\n+\n+SELECT tag,\n+    round(financialNetPresentValue(any(r), groupArray(value)), 6) AS financialNetPresentValueExtended_f64_date,\n+    round(financialNetPresentValue(any(r), groupArray(value)), 6) AS financialNetPresentValueExtended_f64_date32,\n+    round(financialNetPresentValue(any(toFloat32(r)), groupArray(toFloat32(value))), 6) AS financialNetPresentValueExtended_f32_date\n+FROM (\n+    SELECT\n+        tag,\n+        date,\n+        date32,\n+        value,\n+        r\n+    FROM 3533_xirr_test\n+    ORDER BY tag, date\n+)\n+GROUP BY tag\n+ORDER BY tag;\n+\n+\n+DROP TABLE IF EXISTS 3533_xirr_test;\n+\n+SELECT 'Excel docs example:';\n+SELECT round(financialNetPresentValue(0.1, [-10000, 3000, 4200, 6800], False), 6);\n+SELECT round(financialNetPresentValue(0.08, [8000., 9200., 10000., 12000., 14500.], False), 6) - 40000;\n+SELECT round(financialNetPresentValueExtended(0.09, [-10_000, 2750, 4250, 3250, 2750], [toDate('2008-01-01'), toDate('2008-03-01'), toDate('2008-10-30'), toDate('2009-02-15'), toDate('2009-04-01')], 'ACT_365F'), 6);\n+SELECT round(financialInternalRateOfReturn([-70000, 12000, 15000, 18000, 21000, 26000]), 6);\n+SELECT round(financialInternalRateOfReturnExtended([-10000, 2750, 4250, 3250, 2750], [toDate32('2008-01-01'), toDate32('2008-03-01'), toDate32('2008-10-30'), toDate32('2009-02-15'), toDate32('2009-04-01')]), 6);\n+\n",
  "problem_statement": "Feature request - IRR function\n### Company or project name\n\nGridcog / Clickhouse Cloud users\n\n### Use case\n\nHey guys, any chance of implementing a function to compute [x]IRR? This is quite difficult to self-implement in a SQL-bodied function, and Cloud users can't use external UDFs.\n\nRef:\n\n- some dude doing it with procedural T-SQL for MS SQL Server: https://blog.sqlauthority.com/2023/07/14/calculating-extended-internal-rate-of-return-xirr-in-sql-server-with-t-sql/\n- a Postgres binary addin: https://github.com/intgr/pg_financial\n- A Python lib with computation written in Rust: https://github.com/Anexen/pyxirr\n\n### Describe the solution you'd like\n\nfor the sake of something concrete, the pg_financial extension has an interface that looks like this:\n```\n> SELECT xirr(amount, time ORDER BY time) FROM transaction;\n        xirr        \n--------------------\n 0.0176201237088334\n```\n\nI'm not sure if clickhouse has precedent for a general `order by` syntax when calling agg functions though?\n\n### Describe alternatives you've considered\n\nHand-implement newton-raphson in a recursive CTE?\n\n### Additional context\n\n_No response_\n",
  "hints_text": "I would like to have a look at this one if possible.",
  "created_at": "2025-06-10T16:31:01Z"
}