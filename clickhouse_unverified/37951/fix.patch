diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 621429fb02cb..8a595b63bdfc 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -950,9 +950,28 @@ SELECT
 
 ## timeSlots(StartTime, Duration,\[, Size\])
 
-For a time interval starting at ‘StartTime’ and continuing for ‘Duration’ seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the ‘Size’ in seconds. ‘Size’ is an optional parameter: a constant UInt32, set to 1800 by default.
-For example, `timeSlots(toDateTime('2012-01-01 12:20:00'), 600) = [toDateTime('2012-01-01 12:00:00'), toDateTime('2012-01-01 12:30:00')]`.
-This is necessary for searching for pageviews in the corresponding session.
+For a time interval starting at ‘StartTime’ and continuing for ‘Duration’ seconds, it returns an array of moments in time, consisting of points from this interval rounded down to the ‘Size’ in seconds. ‘Size’ is an optional parameter set to 1800 (30 minutes) by default.  
+This is necessary, for example, when searching for pageviews in the corresponding session.  
+Accepts DateTime and DateTime64 as ’StartTime’ argument. For DateTime, ’Duration’ and ’Size’ arguments must be `UInt32`. For ’DateTime64’ they must be `Decimal64`.  
+Returns an array of DateTime/DateTime64 (return type matches the type of ’StartTime’). For DateTime64, the return value's scale can differ from the scale of ’StartTime’ --- the highest scale among all given arguments is taken.
+
+Example:
+```sql
+SELECT timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600));
+SELECT timeSlots(toDateTime('1980-12-12 21:01:02', 'UTC'), toUInt32(600), 299);
+SELECT timeSlots(toDateTime64('1980-12-12 21:01:02.1234', 4, 'UTC'), toDecimal64(600.1, 1), toDecimal64(299, 0));
+``` 
+``` text
+┌─timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600))─┐
+│ ['2012-01-01 12:00:00','2012-01-01 12:30:00']               │
+└─────────────────────────────────────────────────────────────┘
+┌─timeSlots(toDateTime('1980-12-12 21:01:02', 'UTC'), toUInt32(600), 299)─┐
+│ ['1980-12-12 20:56:13','1980-12-12 21:01:12','1980-12-12 21:06:11']     │
+└─────────────────────────────────────────────────────────────────────────┘
+┌─timeSlots(toDateTime64('1980-12-12 21:01:02.1234', 4, 'UTC'), toDecimal64(600.1, 1), toDecimal64(299, 0))─┐
+│ ['1980-12-12 20:56:13.0000','1980-12-12 21:01:12.0000','1980-12-12 21:06:11.0000']                        │
+└───────────────────────────────────────────────────────────────────────────────────────────────────────────┘
+```
 
 ## formatDateTime
 
diff --git a/docs/ru/sql-reference/functions/date-time-functions.md b/docs/ru/sql-reference/functions/date-time-functions.md
index da48cd940a72..5a214fe2664b 100644
--- a/docs/ru/sql-reference/functions/date-time-functions.md
+++ b/docs/ru/sql-reference/functions/date-time-functions.md
@@ -944,14 +944,31 @@ SELECT now('Europe/Moscow');
 ## timeSlot {#timeslot}
 
 Округляет время до получаса.
-Эта функция является специфичной для Яндекс.Метрики, так как пол часа - минимальное время, для которого, если соседние по времени хиты одного посетителя на одном счётчике отстоят друг от друга строго более, чем на это время, визит может быть разбит на два визита. То есть, кортежи (номер счётчика, идентификатор посетителя, тайм-слот) могут использоваться для поиска хитов, входящий в соответствующий визит.
+Эта функция является специфичной для Яндекс.Метрики, так как полчаса - минимальное время, для которого, если соседние по времени хиты одного посетителя на одном счётчике отстоят друг от друга строго более, чем на это время, визит может быть разбит на два визита. То есть, кортежи (номер счётчика, идентификатор посетителя, тайм-слот) могут использоваться для поиска хитов, входящий в соответствующий визит.
 
 ## timeSlots(StartTime, Duration,\[, Size\]) {#timeslotsstarttime-duration-size}
+Для интервала, начинающегося в `StartTime` и длящегося `Duration` секунд, возвращает массив моментов времени, кратных `Size`. Параметр `Size` указывать необязательно, по умолчанию он равен 1800 секундам (30 минутам) - необязательный параметр.
+Данная функция может использоваться, например, для анализа количества просмотров страницы за соответствующую сессию. 
+Аргумент `StartTime` может иметь тип `DateTime` или `DateTime64`. В случае, если используется `DateTime`, аргументы `Duration` и `Size` должны иметь тип `UInt32`; Для DateTime64 они должны быть типа `Decimal64`.  
+Возвращает массив DateTime/DateTime64 (тип будет совпадать с типом параметра ’StartTime’). Для DateTime64 масштаб(scale) возвращаемой величины может отличаться от масштаба фргумента ’StartTime’ --- результат будет иметь наибольший масштаб среди всех данных аргументов.
 
-Для интервала времени, начинающегося в ‘StartTime’ и продолжающегося ‘Duration’ секунд, возвращает массив моментов времени, состоящий из округлений вниз до ‘Size’ точек в секундах из этого интервала. ‘Size’ - необязательный параметр, константный UInt32, по умолчанию равен 1800.
-
-Например, `timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600)) = [toDateTime('2012-01-01 12:00:00'), toDateTime('2012-01-01 12:30:00')]`.
-Это нужно для поиска хитов, входящих в соответствующий визит.
+Пример использования:
+```sql
+SELECT timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600));
+SELECT timeSlots(toDateTime('1980-12-12 21:01:02', 'UTC'), toUInt32(600), 299);
+SELECT timeSlots(toDateTime64('1980-12-12 21:01:02.1234', 4, 'UTC'), toDecimal64(600.1, 1), toDecimal64(299, 0));
+```
+``` text
+┌─timeSlots(toDateTime('2012-01-01 12:20:00'), toUInt32(600))─┐
+│ ['2012-01-01 12:00:00','2012-01-01 12:30:00']               │
+└─────────────────────────────────────────────────────────────┘
+┌─timeSlots(toDateTime('1980-12-12 21:01:02', 'UTC'), toUInt32(600), 299)─┐
+│ ['1980-12-12 20:56:13','1980-12-12 21:01:12','1980-12-12 21:06:11']     │
+└─────────────────────────────────────────────────────────────────────────┘
+┌─timeSlots(toDateTime64('1980-12-12 21:01:02.1234', 4, 'UTC'), toDecimal64(600.1, 1), toDecimal64(299, 0))─┐
+│ ['1980-12-12 20:56:13.0000','1980-12-12 21:01:12.0000','1980-12-12 21:06:11.0000']                        │
+└───────────────────────────────────────────────────────────────────────────────────────────────────────────┘
+```
 
 ## toYYYYMM
 
diff --git a/src/Functions/timeSlots.cpp b/src/Functions/timeSlots.cpp
index a19ccf62565e..382d7131bf38 100644
--- a/src/Functions/timeSlots.cpp
+++ b/src/Functions/timeSlots.cpp
@@ -1,6 +1,7 @@
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypeDateTime64.h>
+#include <DataTypes/DataTypesDecimal.h>
 #include <Columns/ColumnArray.h>
 #include <Columns/ColumnsNumber.h>
 
@@ -23,9 +24,9 @@ namespace ErrorCodes
 namespace
 {
 
-/** timeSlots(StartTime, Duration)
+/** timeSlots(StartTime, Duration[, Size=1800])
   * - for the time interval beginning at `StartTime` and continuing `Duration` seconds,
-  *   returns an array of time points, consisting of rounding down to half an hour (default; or another value) of points from this interval.
+  *   returns an array of time points, consisting of rounding down to Size (1800 seconds by default) of points from this interval.
   *  For example, timeSlots(toDateTime('2012-01-01 12:20:00'), 600) = [toDateTime('2012-01-01 12:00:00'), toDateTime('2012-01-01 12:30:00')].
   *  This is necessary to search for hits that are part of the corresponding visit.
   *
@@ -33,11 +34,11 @@ namespace
   * But this function was adopted by wider audience.
   */
 
-template <typename DurationType>
 struct TimeSlotsImpl
 {
+    /// The following three methods process DateTime type
     static void vectorVector(
-        const PaddedPODArray<UInt32> & starts, const PaddedPODArray<DurationType> & durations, UInt32 time_slot_size,
+        const PaddedPODArray<UInt32> & starts, const PaddedPODArray<UInt32> & durations, UInt32 time_slot_size,
         PaddedPODArray<UInt32> & result_values, ColumnArray::Offsets & result_offsets)
     {
         size_t size = starts.size();
@@ -59,7 +60,7 @@ struct TimeSlotsImpl
     }
 
     static void vectorConstant(
-        const PaddedPODArray<UInt32> & starts, DurationType duration, UInt32 time_slot_size,
+        const PaddedPODArray<UInt32> & starts, UInt32 duration, UInt32 time_slot_size,
         PaddedPODArray<UInt32> & result_values, ColumnArray::Offsets & result_offsets)
     {
         size_t size = starts.size();
@@ -81,7 +82,7 @@ struct TimeSlotsImpl
     }
 
     static void constantVector(
-        UInt32 start, const PaddedPODArray<DurationType> & durations, UInt32 time_slot_size,
+        UInt32 start, const PaddedPODArray<UInt32> & durations, UInt32 time_slot_size,
         PaddedPODArray<UInt32> & result_values, ColumnArray::Offsets & result_offsets)
     {
         size_t size = durations.size();
@@ -101,6 +102,99 @@ struct TimeSlotsImpl
             result_offsets[i] = current_offset;
         }
     }
+    /*
+    The following three methods process DateTime64 type
+    NO_SANITIZE_UNDEFINED is put here because user shall be careful when working with Decimal
+    Adjusting different scales can cause overflow -- it is OK for us. Don't use scales that differ a lot :)
+    */
+    static NO_SANITIZE_UNDEFINED void vectorVector(
+        const PaddedPODArray<DateTime64> & starts, const PaddedPODArray<Decimal64> & durations, Decimal64 time_slot_size,
+        PaddedPODArray<DateTime64> & result_values, ColumnArray::Offsets & result_offsets, UInt16 dt_scale, UInt16 duration_scale, UInt16 time_slot_scale)
+    {
+        size_t size = starts.size();
+
+        result_offsets.resize(size);
+        result_values.reserve(size);
+
+        /// Modify all units to have same scale
+        UInt16 max_scale = std::max({dt_scale, duration_scale, time_slot_scale});
+
+        Int64 dt_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - dt_scale);
+        Int64 dur_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - duration_scale);
+        Int64 ts_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - time_slot_scale);
+
+        ColumnArray::Offset current_offset = 0;
+        time_slot_size = time_slot_size.value * ts_multiplier;
+        for (size_t i = 0; i < size; ++i)
+        {
+            for (DateTime64 value = (starts[i] * dt_multiplier) / time_slot_size, end = (starts[i] * dt_multiplier + durations[i] * dur_multiplier) / time_slot_size; value <= end; value += 1)
+            {
+                result_values.push_back(value * time_slot_size);
+                ++current_offset;
+            }
+            result_offsets[i] = current_offset;
+        }
+    }
+
+    static NO_SANITIZE_UNDEFINED void vectorConstant(
+        const PaddedPODArray<DateTime64> & starts, Decimal64 duration, Decimal64 time_slot_size,
+        PaddedPODArray<DateTime64> & result_values, ColumnArray::Offsets & result_offsets, UInt16 dt_scale, UInt16 duration_scale, UInt16 time_slot_scale)
+    {
+        size_t size = starts.size();
+
+        result_offsets.resize(size);
+        result_values.reserve(size);
+
+        /// Modify all units to have same scale
+        UInt16 max_scale = std::max({dt_scale, duration_scale, time_slot_scale});
+
+        Int64 dt_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - dt_scale);
+        Int64 dur_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - duration_scale);
+        Int64 ts_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - time_slot_scale);
+
+        ColumnArray::Offset current_offset = 0;
+        duration = duration * dur_multiplier;
+        time_slot_size = time_slot_size.value * ts_multiplier;
+        for (size_t i = 0; i < size; ++i)
+        {
+            for (DateTime64 value = (starts[i] * dt_multiplier) / time_slot_size, end = (starts[i] * dt_multiplier + duration) / time_slot_size; value <= end; value += 1)
+            {
+                result_values.push_back(value * time_slot_size);
+                ++current_offset;
+            }
+            result_offsets[i] = current_offset;
+        }
+    }
+
+    static NO_SANITIZE_UNDEFINED void constantVector(
+        DateTime64 start, const PaddedPODArray<Decimal64> & durations, Decimal64 time_slot_size,
+        PaddedPODArray<DateTime64> & result_values, ColumnArray::Offsets & result_offsets, UInt16 dt_scale, UInt16 duration_scale, UInt16 time_slot_scale)
+    {
+        size_t size = durations.size();
+
+        result_offsets.resize(size);
+        result_values.reserve(size);
+
+        /// Modify all units to have same scale
+        UInt16 max_scale = std::max({dt_scale, duration_scale, time_slot_scale});
+
+        Int64 dt_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - dt_scale);
+        Int64 dur_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - duration_scale);
+        Int64 ts_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(max_scale - time_slot_scale);
+
+        ColumnArray::Offset current_offset = 0;
+        start = dt_multiplier * start;
+        time_slot_size = time_slot_size.value * ts_multiplier;
+        for (size_t i = 0; i < size; ++i)
+        {
+            for (DateTime64 value = start / time_slot_size, end = (start + durations[i] * dur_multiplier) / time_slot_size; value <= end; value += 1)
+            {
+                result_values.push_back(value * time_slot_size);
+                ++current_offset;
+            }
+            result_offsets[i] = current_offset;
+        }
+    }
 };
 
 
@@ -108,7 +202,6 @@ class FunctionTimeSlots : public IFunction
 {
 public:
     static constexpr auto name = "timeSlots";
-    static constexpr UInt32 TIME_SLOT_SIZE = 1800;
     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTimeSlots>(); }
 
     String getName() const override
@@ -129,67 +222,154 @@ class FunctionTimeSlots : public IFunction
                             + toString(arguments.size()) + ", should be 2 or 3",
                             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
-        if (!WhichDataType(arguments[0].type).isDateTime())
-            throw Exception("Illegal type " + arguments[0].type->getName() + " of first argument of function " + getName() + ". Must be DateTime.",
-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-
-        if (!WhichDataType(arguments[1].type).isUInt32())
-            throw Exception("Illegal type " + arguments[1].type->getName() + " of second argument of function " + getName() + ". Must be UInt32.",
-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-
-        if (arguments.size() == 3 && !WhichDataType(arguments[2].type).isNativeUInt())
-            throw Exception("Illegal type " + arguments[2].type->getName() + " of third argument of function " + getName() + ". Must be UInt32.",
-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        if (WhichDataType(arguments[0].type).isDateTime())
+        {
+            if (!WhichDataType(arguments[1].type).isUInt32())
+                throw Exception(
+                    "Illegal type " + arguments[1].type->getName() + " of second argument of function " + getName() + ". Must be UInt32 when first argument is DateTime.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+            if (arguments.size() == 3 && !WhichDataType(arguments[2].type).isNativeUInt())
+                throw Exception(
+                    "Illegal type " + arguments[2].type->getName() + " of third argument of function " + getName() + ". Must be UInt32 when first argument is DateTime.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else if (WhichDataType(arguments[0].type).isDateTime64())
+        {
+            if (!WhichDataType(arguments[1].type).isDecimal64())
+                throw Exception(
+                    "Illegal type " + arguments[1].type->getName() + " of second argument of function " + getName() + ". Must be Decimal64 when first argument is DateTime64.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+            if (arguments.size() == 3 && !WhichDataType(arguments[2].type).isDecimal64())
+                throw Exception(
+                    "Illegal type " + arguments[2].type->getName() + " of third argument of function " + getName() + ". Must be Decimal64 when first argument is DateTime64.",
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+        }
+        else
+            throw Exception("Illegal type " + arguments[0].type->getName() + " of first argument of function " + getName()
+                                + ". Must be DateTime or DateTime64.", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         /// If time zone is specified for source data type, attach it to the resulting type.
         /// Note that there is no explicit time zone argument for this function (we specify 2 as an argument number with explicit time zone).
-        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 3, 0)));
+        if (WhichDataType(arguments[0].type).isDateTime())
+        {
+            return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 3, 0)));
+        }
+        else
+        {
+            auto start_time_scale = assert_cast<const DataTypeDateTime64 &>(*arguments[0].type).getScale();
+            auto duration_scale = assert_cast<const DataTypeDecimal64 &>(*arguments[1].type).getScale();
+            return std::make_shared<DataTypeArray>(
+                std::make_shared<DataTypeDateTime64>(std::max(start_time_scale, duration_scale), extractTimeZoneNameFromFunctionArguments(arguments, 3, 0)));
+        }
+
     }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t) const override
     {
-        const auto * starts = checkAndGetColumn<ColumnUInt32>(arguments[0].column.get());
-        const auto * const_starts = checkAndGetColumnConst<ColumnUInt32>(arguments[0].column.get());
-
-        const auto * durations = checkAndGetColumn<ColumnUInt32>(arguments[1].column.get());
-        const auto * const_durations = checkAndGetColumnConst<ColumnUInt32>(arguments[1].column.get());
+        if (WhichDataType(arguments[0].type).isDateTime())
+        {
+            UInt32 time_slot_size = 1800;
+            if (arguments.size() == 3)
+            {
+                const auto * time_slot_column = checkAndGetColumn<ColumnConst>(arguments[2].column.get());
+                if (!time_slot_column)
+                    throw Exception("Third argument for function " + getName() + " must be constant UInt32", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
-        auto res = ColumnArray::create(ColumnUInt32::create());
-        ColumnUInt32::Container & res_values = typeid_cast<ColumnUInt32 &>(res->getData()).getData();
+                if (time_slot_size = time_slot_column->getValue<UInt32>(); time_slot_size <= 0)
+                    throw Exception("Third argument for function " + getName() + " must be greater than zero", ErrorCodes::ILLEGAL_COLUMN);
+            }
 
-        auto time_slot_size = TIME_SLOT_SIZE;
+            const auto * dt_starts = checkAndGetColumn<ColumnUInt32>(arguments[0].column.get());
+            const auto * dt_const_starts = checkAndGetColumnConst<ColumnUInt32>(arguments[0].column.get());
 
-        if (arguments.size() == 3)
-        {
-            const auto * time_slot_column = checkAndGetColumn<ColumnConst>(arguments[2].column.get());
-            if (!time_slot_column)
-                throw Exception("Third argument for function " + getName() + " must be constant UInt32", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+            const auto * durations = checkAndGetColumn<ColumnUInt32>(arguments[1].column.get());
+            const auto * const_durations = checkAndGetColumnConst<ColumnUInt32>(arguments[1].column.get());
 
-            if (time_slot_size = time_slot_column->getValue<UInt32>(); time_slot_size == 0)
-                throw Exception("Third argument for function " + getName() + " must be greater than zero", ErrorCodes::ILLEGAL_COLUMN);
-        }
+            auto res = ColumnArray::create(ColumnUInt32::create());
+            ColumnUInt32::Container & res_values = typeid_cast<ColumnUInt32 &>(res->getData()).getData();
 
-        if (starts && durations)
-        {
-            TimeSlotsImpl<UInt32>::vectorVector(starts->getData(), durations->getData(), time_slot_size, res_values, res->getOffsets());
-            return res;
+            if (dt_starts && durations)
+            {
+                TimeSlotsImpl::vectorVector(dt_starts->getData(), durations->getData(), time_slot_size, res_values, res->getOffsets());
+                return res;
+            }
+            else if (dt_starts && const_durations)
+            {
+                TimeSlotsImpl::vectorConstant(dt_starts->getData(), const_durations->getValue<UInt32>(), time_slot_size, res_values, res->getOffsets());
+                return res;
+            }
+            else if (dt_const_starts && durations)
+            {
+                TimeSlotsImpl::constantVector(dt_const_starts->getValue<UInt32>(), durations->getData(), time_slot_size, res_values, res->getOffsets());
+                return res;
+            }
         }
-        else if (starts && const_durations)
+        else
         {
-            TimeSlotsImpl<UInt32>::vectorConstant(starts->getData(), const_durations->getValue<UInt32>(), time_slot_size, res_values, res->getOffsets());
-            return res;
+            assert(WhichDataType(arguments[0].type).isDateTime64());
+            Decimal64 time_slot_size = Decimal64(1800);
+            UInt16 time_slot_scale = 0;
+            if (arguments.size() == 3)
+            {
+                const auto * time_slot_column = checkAndGetColumn<ColumnConst>(arguments[2].column.get());
+                if (!time_slot_column)
+                    throw Exception("Third argument for function " + getName() + " must be constant Decimal64", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
+                if (time_slot_size = time_slot_column->getValue<Decimal64>(); time_slot_size <= 0)
+                    throw Exception("Third argument for function " + getName() + " must be greater than zero", ErrorCodes::ILLEGAL_COLUMN);
+                time_slot_scale = assert_cast<const DataTypeDecimal64 *>(arguments[2].type.get())->getScale();
+            }
+
+            const auto * starts = checkAndGetColumn<DataTypeDateTime64::ColumnType>(arguments[0].column.get());
+            const auto * const_starts = checkAndGetColumnConst<DataTypeDateTime64::ColumnType>(arguments[0].column.get());
+
+            const auto * durations = checkAndGetColumn<ColumnDecimal<Decimal64>>(arguments[1].column.get());
+            const auto * const_durations = checkAndGetColumnConst<ColumnDecimal<Decimal64>>(arguments[1].column.get());
+
+            const auto start_time_scale = assert_cast<const DataTypeDateTime64 *>(arguments[0].type.get())->getScale();
+            const auto duration_scale = assert_cast<const DataTypeDecimal64 *>(arguments[1].type.get())->getScale();
+
+            auto res = ColumnArray::create(DataTypeDateTime64(start_time_scale).createColumn());
+            DataTypeDateTime64::ColumnType::Container & res_values = typeid_cast<DataTypeDateTime64::ColumnType &>(res->getData()).getData();
+
+            if (starts && durations)
+            {
+                TimeSlotsImpl::vectorVector(starts->getData(), durations->getData(), time_slot_size, res_values, res->getOffsets(),
+                    start_time_scale, duration_scale, time_slot_scale);
+                return res;
+            }
+            else if (starts && const_durations)
+            {
+                TimeSlotsImpl::vectorConstant(
+                    starts->getData(), const_durations->getValue<Decimal64>(), time_slot_size, res_values, res->getOffsets(),
+                    start_time_scale, duration_scale, time_slot_scale);
+                return res;
+            }
+            else if (const_starts && durations)
+            {
+                TimeSlotsImpl::constantVector(
+                    const_starts->getValue<DateTime64>(), durations->getData(), time_slot_size, res_values, res->getOffsets(),
+                    start_time_scale, duration_scale, time_slot_scale);
+                return res;
+            }
         }
-        else if (const_starts && durations)
+
+        if (arguments.size() == 3)
         {
-            TimeSlotsImpl<UInt32>::constantVector(const_starts->getValue<UInt32>(), durations->getData(), time_slot_size, res_values, res->getOffsets());
-            return res;
+            throw Exception(
+                "Illegal columns " + arguments[0].column->getName() + ", " + arguments[1].column->getName() + ", "
+                    + arguments[2].column->getName() + " of arguments of function " + getName(),
+                ErrorCodes::ILLEGAL_COLUMN);
         }
         else
-            throw Exception("Illegal columns " + arguments[0].column->getName()
-                    + ", " + arguments[1].column->getName()
-                    + ", " + arguments[2].column->getName()
+        {
+            throw Exception(
+                "Illegal columns " + arguments[0].column->getName() + ", " + arguments[1].column->getName()
                     + " of arguments of function " + getName(),
                 ErrorCodes::ILLEGAL_COLUMN);
+        }
     }
 };
 
