{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54942,
  "instance_id": "ClickHouse__ClickHouse-54942",
  "issue_numbers": [
    "54486"
  ],
  "base_commit": "ba6f0431a5e904a7c8861a2061ed2fed8756217e",
  "patch": "diff --git a/src/Common/OptimizedRegularExpression.cpp b/src/Common/OptimizedRegularExpression.cpp\nindex 3501a355c19a..d64b26a28a33 100644\n--- a/src/Common/OptimizedRegularExpression.cpp\n+++ b/src/Common/OptimizedRegularExpression.cpp\n@@ -496,6 +496,14 @@ OptimizedRegularExpression::OptimizedRegularExpression(const std::string & regex\n             regexp_options.set_dot_nl(true);\n \n         re2 = std::make_unique<re2::RE2>(regexp_, regexp_options);\n+\n+        /// Fallback to latin1 to allow matching binary data.\n+        if (!re2->ok() && re2->error_code() == re2::RE2::ErrorCode::ErrorBadUTF8)\n+        {\n+            regexp_options.set_encoding(re2::RE2::Options::EncodingLatin1);\n+            re2 = std::make_unique<re2::RE2>(regexp_, regexp_options);\n+        }\n+\n         if (!re2->ok())\n         {\n             throw DB::Exception(DB::ErrorCodes::CANNOT_COMPILE_REGEXP,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02886_binary_like.reference b/tests/queries/0_stateless/02886_binary_like.reference\nnew file mode 100644\nindex 000000000000..c23ceaf97849\n--- /dev/null\n+++ b/tests/queries/0_stateless/02886_binary_like.reference\n@@ -0,0 +1,24 @@\n+1\n+1\n+1\n+1\n+1\n+0\n+0\n+1\n+1\n+1\n+1\n+1\n+1\n+0\n+0\n+1\n+1\n+1\n+1\n+1\n+1\n+0\n+0\n+1\ndiff --git a/tests/queries/0_stateless/02886_binary_like.sql b/tests/queries/0_stateless/02886_binary_like.sql\nnew file mode 100644\nindex 000000000000..ba11f1fc0604\n--- /dev/null\n+++ b/tests/queries/0_stateless/02886_binary_like.sql\n@@ -0,0 +1,26 @@\n+SELECT 'a\u044fb' LIKE 'a_b';\n+SELECT 'a\\0b' LIKE 'a_b';\n+SELECT 'a\\0b' LIKE 'a\\0b';\n+SELECT 'a\\0b' LIKE 'a%\\0b';\n+SELECT 'a\\xFFb' LIKE 'a%\\xFFb';\n+SELECT 'a\\xFFb' LIKE 'a%\\xFF\\xFEb';\n+SELECT 'a\\xFFb' LIKE '%a\\xFF\\xFEb';\n+SELECT 'a\\xFF\\xFEb' LIKE '%a\\xFF\\xFEb';\n+\n+SELECT materialize('a\u044fb') LIKE 'a_b';\n+SELECT materialize('a\\0b') LIKE 'a_b';\n+SELECT materialize('a\\0b') LIKE 'a\\0b';\n+SELECT materialize('a\\0b') LIKE 'a%\\0b';\n+SELECT materialize('a\\xFFb') LIKE 'a%\\xFFb';\n+SELECT materialize('a\\xFFb') LIKE 'a%\\xFF\\xFEb';\n+SELECT materialize('a\\xFFb') LIKE '%a\\xFF\\xFEb';\n+SELECT materialize('a\\xFF\\xFEb') LIKE '%a\\xFF\\xFEb';\n+\n+SELECT materialize('a\u044fb') LIKE materialize('a_b');\n+SELECT materialize('a\\0b') LIKE materialize('a_b');\n+SELECT materialize('a\\0b') LIKE materialize('a\\0b');\n+SELECT materialize('a\\0b') LIKE materialize('a%\\0b');\n+SELECT materialize('a\\xFFb') LIKE materialize('a%\\xFFb');\n+SELECT materialize('a\\xFFb') LIKE materialize('a%\\xFF\\xFEb');\n+SELECT materialize('a\\xFFb') LIKE materialize('%a\\xFF\\xFEb');\n+SELECT materialize('a\\xFF\\xFEb') LIKE materialize('%a\\xFF\\xFEb');\n",
  "problem_statement": "Some LIKE expressions don't work\n**Use case**\r\n\r\n```\r\nmilovidov-desktop :) SELECT 'test' LIKE '\\xFF\\xFE%'\r\n\r\nSELECT 'test' LIKE '\ufffd\ufffd%'\r\n\r\nQuery id: 1de419f8-e9d8-4da1-8544-21ed91b8b088\r\n\r\n\r\n0 rows in set. Elapsed: 0.030 sec. \r\n\r\nReceived exception:\r\nCode: 427. DB::Exception: OptimizedRegularExpression: cannot compile re2: ^\ufffd\ufffd, error: invalid UTF-8. Look at https://github.com/google/re2/wiki/Syntax for reference. Please note that if you specify regex as an SQL string literal, the slashes have to be additionally escaped. For example, to match an opening brace, write '\\(' -- the first slash is for SQL and the second one is for regex: While processing 'test' LIKE '\ufffd\ufffd%'. (CANNOT_COMPILE_REGEXP)\r\n```\n",
  "hints_text": "`\\xFF\\xFE%` is internally a [string literal](https://clickhouse.com/docs/en/sql-reference/syntax#string) of three bytes length.\r\n\r\n[Operator LIKE](https://clickhouse.com/docs/en/sql-reference/functions/string-search-functions#like) assumes that the haystack \\+ pattern are valid UTF-8. Let's check if this is the case: The first pattern byte `\\xFF` indicates the start of a four-byte UTF-8 value ([here](https://en.wikipedia.org/wiki/UTF-8#Encoding)) in which case the second byte needs to be 10xxxxxx but it is 11111110. This can also be seen in a [byte-to-UTF8 converter](https://onlinetools.com/utf8/convert-bytes-to-utf8) (set base=16, bytes=fffe). Re2 complains rightfully that the input isn't valid UTF-8.\r\n\r\nNotes:\r\n- Using `\\xHH` to construct valid (multi-byte) UTF-8 values is generally legitimate, e.g. `SELECT 'test\u20ac' LIKE '%test\\xE2\\x82\\xAC'` works. Usually, it is easier to write the display character directly `SELECT 'test\u20ac' LIKE '%test\u20ac'`.\r\n- One could argue that ClickHouse instead of re2 should check if the input is UTF-8. This would create a little less confusion, on the other hands, as re2 checks anyways and we should avoid checking twice.\n> Operator LIKE assumes that the haystack + pattern are valid UTF-8.\r\n\r\nThis is a mistake. It should work on any byte sequence.\nI will try to fix it by specifying that the regexp uses Latin1 in trivial cases (LIKE).\nI just see that re2 has `\\C` = \"match a single byte even in UTF-8 mode\" ([here](https://github.com/google/re2/wiki/Syntax)). Maybe we can prepend every input byte with that in Common/likePatternToRegexp.cpp?\nDoesn't work:\r\n\r\n```\r\nmilovidov-desktop :) SELECT 'test' LIKE '\\C\\xFF\\C\\xFE%'\r\n\r\nSELECT 'test' LIKE '\\\\C\ufffd\\\\C\ufffd%'\r\n\r\nQuery id: 329b9f9e-a4c1-494e-8f31-36a5d27b485a\r\n\r\n\r\n0 rows in set. Elapsed: 0.055 sec. \r\n\r\nReceived exception:\r\nCode: 427. DB::Exception: OptimizedRegularExpression: cannot compile re2: ^\\\\C\ufffd\\\\C\ufffd, error: invalid UTF-8. Look at https://github.com/google/re2/wiki/Syntax for reference. Please note that if you specify regex as an SQL string literal, the slashes have to be additionally escaped. For example, to match an opening brace, write '\\(' -- the first slash is for SQL and the second one is for regex: While processing 'test' LIKE '\\\\C\ufffd\\\\C\ufffd%'. (CANNOT_COMPILE_REGEXP)\r\n```\nI hacked a bit around and also couldn't get `\\C` to work (I first thought it can only be used if the Perl flag is passed to re2) :-(\r\nAnyways, re2 devs agree [with](https://github.com/google/re2/issues/200#issuecomment-483652446) that Latin1 mode is necessary.",
  "created_at": "2023-09-23T02:16:27Z"
}