{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28803,
  "instance_id": "ClickHouse__ClickHouse-28803",
  "issue_numbers": [
    "11"
  ],
  "base_commit": "4adc4e915257aac2f4c50fb3d550f92a657bd305",
  "patch": "diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex d2661874beb9..c70f0c07ea92 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -13,7 +13,7 @@\n #include <Interpreters/executeQuery.h>\n #include <Interpreters/loadMetadata.h>\n #include <Interpreters/DatabaseCatalog.h>\n-#include <Interpreters/UserDefinedObjectsLoader.h>\n+#include <Interpreters/UserDefinedSQLObjectsLoader.h>\n #include <Interpreters/Session.h>\n #include <Common/Exception.h>\n #include <Common/Macros.h>\n@@ -295,7 +295,7 @@ try\n         fs::create_directories(fs::path(path) / \"user_defined/\");\n         LOG_DEBUG(log, \"Loading user defined objects from {}\", path);\n         Poco::File(path + \"user_defined/\").createDirectories();\n-        UserDefinedObjectsLoader::instance().loadObjects(global_context);\n+        UserDefinedSQLObjectsLoader::instance().loadObjects(global_context);\n         LOG_DEBUG(log, \"Loaded user defined objects.\");\n \n         LOG_DEBUG(log, \"Loading metadata from {}\", path);\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 5ca9007bdcc4..961d8e7b4cf6 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -51,8 +51,8 @@\n #include <Interpreters/ExternalModelsLoader.h>\n #include <Interpreters/ProcessList.h>\n #include <Interpreters/loadMetadata.h>\n+#include <Interpreters/UserDefinedSQLObjectsLoader.h>\n #include <Interpreters/JIT/CompiledExpressionCache.h>\n-#include <Interpreters/UserDefinedObjectsLoader.h>\n #include <Access/AccessControlManager.h>\n #include <Storages/StorageReplicatedMergeTree.h>\n #include <Storages/System/attachSystemTables.h>\n@@ -1086,7 +1086,7 @@ if (ThreadFuzzer::instance().isEffective())\n     LOG_INFO(log, \"Loading user defined objects from {}\", path_str);\n     try\n     {\n-        UserDefinedObjectsLoader::instance().loadObjects(global_context);\n+        UserDefinedSQLObjectsLoader::instance().loadObjects(global_context);\n     }\n     catch (...)\n     {\n@@ -1473,6 +1473,17 @@ if (ThreadFuzzer::instance().isEffective())\n             throw;\n         }\n \n+        /// try to load user defined executable functions, throw on error and die\n+        try\n+        {\n+            global_context->loadUserDefinedExecutableFunctions(config());\n+        }\n+        catch (...)\n+        {\n+            LOG_ERROR(log, \"Caught exception while loading user defined executable functions.\");\n+            throw;\n+        }\n+\n         if (has_zookeeper && config().has(\"distributed_ddl\"))\n         {\n             /// DDL worker should be started after all tables were loaded\ndiff --git a/programs/server/config.xml b/programs/server/config.xml\nindex fe17d5045a4f..bd1c20ffa927 100644\n--- a/programs/server/config.xml\n+++ b/programs/server/config.xml\n@@ -1003,6 +1003,9 @@\n     -->\n     <dictionaries_config>*_dictionary.xml</dictionaries_config>\n \n+    <!-- Configuration of user defined executable functions -->\n+    <user_defined_executable_functions_config>*_function.xml</user_defined_executable_functions_config>\n+\n     <!-- Uncomment if you want data to be compressed 30-100% better.\n          Don't do that if you just started using ClickHouse.\n       -->\ndiff --git a/src/Access/AccessType.h b/src/Access/AccessType.h\nindex 8e6a8be8e36f..df060d46658e 100644\n--- a/src/Access/AccessType.h\n+++ b/src/Access/AccessType.h\n@@ -143,6 +143,7 @@ enum class AccessType\n     M(SYSTEM_RELOAD_SYMBOLS, \"RELOAD SYMBOLS\", GLOBAL, SYSTEM_RELOAD) \\\n     M(SYSTEM_RELOAD_DICTIONARY, \"SYSTEM RELOAD DICTIONARIES, RELOAD DICTIONARY, RELOAD DICTIONARIES\", GLOBAL, SYSTEM_RELOAD) \\\n     M(SYSTEM_RELOAD_MODEL, \"SYSTEM RELOAD MODELS, RELOAD MODEL, RELOAD MODELS\", GLOBAL, SYSTEM_RELOAD) \\\n+    M(SYSTEM_RELOAD_FUNCTION, \"SYSTEM RELOAD FUNCTIONS, RELOAD FUNCTION, RELOAD FUNCTIONS\", GLOBAL, SYSTEM_RELOAD) \\\n     M(SYSTEM_RELOAD_EMBEDDED_DICTIONARIES, \"RELOAD EMBEDDED DICTIONARIES\", GLOBAL, SYSTEM_RELOAD) /* implicitly enabled by the grant SYSTEM_RELOAD_DICTIONARY ON *.* */\\\n     M(SYSTEM_RELOAD, \"\", GROUP, SYSTEM) \\\n     M(SYSTEM_RESTART_DISK, \"SYSTEM RESTART DISK\", GLOBAL, SYSTEM) \\\ndiff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex 90ee30904c70..953eb68cff7d 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -37,6 +37,8 @@\n #include <Interpreters/interpretSubquery.h>\n #include <Interpreters/DatabaseAndTableWithAlias.h>\n #include <Interpreters/IdentifierSemantic.h>\n+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>\n+\n \n namespace DB\n {\n@@ -854,17 +856,21 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n     if (AggregateFunctionFactory::instance().isAggregateFunctionName(node.name))\n         return;\n \n-    FunctionOverloadResolverPtr function_builder;\n-    try\n-    {\n-        function_builder = FunctionFactory::instance().get(node.name, data.getContext());\n-    }\n-    catch (Exception & e)\n+    FunctionOverloadResolverPtr function_builder = UserDefinedExecutableFunctionFactory::instance().tryGet(node.name, data.getContext());\n+\n+    if (!function_builder)\n     {\n-        auto hints = AggregateFunctionFactory::instance().getHints(node.name);\n-        if (!hints.empty())\n-            e.addMessage(\"Or unknown aggregate function \" + node.name + \". Maybe you meant: \" + toString(hints));\n-        throw;\n+        try\n+        {\n+            function_builder = FunctionFactory::instance().get(node.name, data.getContext());\n+        }\n+        catch (Exception & e)\n+        {\n+            auto hints = AggregateFunctionFactory::instance().getHints(node.name);\n+            if (!hints.empty())\n+                e.addMessage(\"Or unknown aggregate function \" + node.name + \". Maybe you meant: \" + toString(hints));\n+            throw;\n+        }\n     }\n \n     Names argument_names;\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex be1cb21bbc35..14a91959d5cc 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -50,6 +50,7 @@\n #include <Dictionaries/Embedded/GeoDictionariesLoader.h>\n #include <Interpreters/EmbeddedDictionaries.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n+#include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>\n #include <Interpreters/ExternalModelsLoader.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/ProcessList.h>\n@@ -145,6 +146,7 @@ struct ContextSharedPart\n     /// Separate mutex for access of dictionaries. Separate mutex to avoid locks when server doing request to itself.\n     mutable std::mutex embedded_dictionaries_mutex;\n     mutable std::mutex external_dictionaries_mutex;\n+    mutable std::mutex external_user_defined_executable_functions_mutex;\n     mutable std::mutex external_models_mutex;\n     /// Separate mutex for storage policies. During server startup we may\n     /// initialize some important storages (system logs with MergeTree engine)\n@@ -183,11 +185,13 @@ struct ContextSharedPart\n \n     mutable std::optional<EmbeddedDictionaries> embedded_dictionaries;    /// Metrica's dictionaries. Have lazy initialization.\n     mutable std::optional<ExternalDictionariesLoader> external_dictionaries_loader;\n+    mutable std::optional<ExternalUserDefinedExecutableFunctionsLoader> external_user_defined_executable_functions_loader;\n     mutable std::optional<ExternalModelsLoader> external_models_loader;\n     ConfigurationPtr external_models_config;\n     scope_guard models_repository_guard;\n \n     scope_guard dictionaries_xmls;\n+    scope_guard user_defined_executable_functions_xmls;\n \n #if USE_NLP\n     mutable std::optional<SynonymsExtensions> synonyms_extensions;\n@@ -341,10 +345,12 @@ struct ContextSharedPart\n             /// But they cannot be created before storages since they may required table as a source,\n             /// but at least they can be preserved for storage termination.\n             dictionaries_xmls.reset();\n+            user_defined_executable_functions_xmls.reset();\n \n             delete_system_logs = std::move(system_logs);\n             embedded_dictionaries.reset();\n             external_dictionaries_loader.reset();\n+            external_user_defined_executable_functions_loader.reset();\n             models_repository_guard.reset();\n             external_models_loader.reset();\n             buffer_flush_schedule_pool.reset();\n@@ -1324,6 +1330,18 @@ ExternalDictionariesLoader & Context::getExternalDictionariesLoader()\n     return *shared->external_dictionaries_loader;\n }\n \n+const ExternalUserDefinedExecutableFunctionsLoader & Context::getExternalUserDefinedExecutableFunctionsLoader() const\n+{\n+    return const_cast<Context *>(this)->getExternalUserDefinedExecutableFunctionsLoader();\n+}\n+\n+ExternalUserDefinedExecutableFunctionsLoader & Context::getExternalUserDefinedExecutableFunctionsLoader()\n+{\n+    std::lock_guard lock(shared->external_user_defined_executable_functions_mutex);\n+    if (!shared->external_user_defined_executable_functions_loader)\n+        shared->external_user_defined_executable_functions_loader.emplace(getGlobalContext());\n+    return *shared->external_user_defined_executable_functions_loader;\n+}\n \n const ExternalModelsLoader & Context::getExternalModelsLoader() const\n {\n@@ -1391,6 +1409,13 @@ void Context::loadDictionaries(const Poco::Util::AbstractConfiguration & config)\n         std::make_unique<ExternalLoaderXMLConfigRepository>(config, \"dictionaries_config\"));\n }\n \n+void Context::loadUserDefinedExecutableFunctions(const Poco::Util::AbstractConfiguration & config)\n+{\n+    getExternalUserDefinedExecutableFunctionsLoader().enableAlwaysLoadEverything(true);\n+    shared->user_defined_executable_functions_xmls = getExternalUserDefinedExecutableFunctionsLoader().addConfigRepository(\n+        std::make_unique<ExternalLoaderXMLConfigRepository>(config, \"user_defined_executable_functions_config\"));\n+}\n+\n #if USE_NLP\n \n SynonymsExtensions & Context::getSynonymsExtensions() const\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex 815bd3d23e72..b7472fb1c29b 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -48,6 +48,7 @@ class AccessRightsElements;\n class EmbeddedDictionaries;\n class ExternalDictionariesLoader;\n class ExternalModelsLoader;\n+class ExternalUserDefinedExecutableFunctionsLoader;\n class InterserverCredentials;\n using InterserverCredentialsPtr = std::shared_ptr<const InterserverCredentials>;\n class InterserverIOHandler;\n@@ -545,12 +546,15 @@ class Context: public std::enable_shared_from_this<Context>\n     const EmbeddedDictionaries & getEmbeddedDictionaries() const;\n     const ExternalDictionariesLoader & getExternalDictionariesLoader() const;\n     const ExternalModelsLoader & getExternalModelsLoader() const;\n+    const ExternalUserDefinedExecutableFunctionsLoader & getExternalUserDefinedExecutableFunctionsLoader() const;\n     EmbeddedDictionaries & getEmbeddedDictionaries();\n     ExternalDictionariesLoader & getExternalDictionariesLoader();\n+    ExternalUserDefinedExecutableFunctionsLoader & getExternalUserDefinedExecutableFunctionsLoader();\n     ExternalModelsLoader & getExternalModelsLoader();\n     ExternalModelsLoader & getExternalModelsLoaderUnlocked();\n     void tryCreateEmbeddedDictionaries() const;\n     void loadDictionaries(const Poco::Util::AbstractConfiguration & config);\n+    void loadUserDefinedExecutableFunctions(const Poco::Util::AbstractConfiguration & config);\n \n #if USE_NLP\n     SynonymsExtensions & getSynonymsExtensions() const;\ndiff --git a/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp\nnew file mode 100644\nindex 000000000000..0b1c30f2b142\n--- /dev/null\n+++ b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp\n@@ -0,0 +1,123 @@\n+#include \"ExternalUserDefinedExecutableFunctionsLoader.h\"\n+\n+#include <DataTypes/DataTypeFactory.h>\n+\n+#include <Interpreters/UserDefinedExecutableFunction.h>\n+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>\n+#include <Functions/FunctionFactory.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int FUNCTION_ALREADY_EXISTS;\n+}\n+\n+ExternalUserDefinedExecutableFunctionsLoader::ExternalUserDefinedExecutableFunctionsLoader(ContextPtr global_context_)\n+    : ExternalLoader(\"external user defined function\", &Poco::Logger::get(\"ExternalUserDefinedExecutableFunctionsLoader\"))\n+    , WithContext(global_context_)\n+{\n+    setConfigSettings({\"function\", \"name\", \"database\", \"uuid\"});\n+    enableAsyncLoading(false);\n+    enablePeriodicUpdates(true);\n+}\n+\n+ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr ExternalUserDefinedExecutableFunctionsLoader::getUserDefinedFunction(const std::string & user_defined_function_name) const\n+{\n+    return std::static_pointer_cast<const UserDefinedExecutableFunction>(load(user_defined_function_name));\n+}\n+\n+ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr ExternalUserDefinedExecutableFunctionsLoader::tryGetUserDefinedFunction(const std::string & user_defined_function_name) const\n+{\n+    return std::static_pointer_cast<const UserDefinedExecutableFunction>(tryLoad(user_defined_function_name));\n+}\n+\n+void ExternalUserDefinedExecutableFunctionsLoader::reloadFunction(const std::string & user_defined_function_name) const\n+{\n+    loadOrReload(user_defined_function_name);\n+}\n+\n+ExternalLoader::LoadablePtr ExternalUserDefinedExecutableFunctionsLoader::create(const std::string & name,\n+    const Poco::Util::AbstractConfiguration & config,\n+    const std::string & key_in_config,\n+    const std::string &) const\n+{\n+    if (FunctionFactory::instance().hasNameOrAlias(name))\n+        throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, \"The function '{}' already exists\", name);\n+\n+    if (AggregateFunctionFactory::instance().hasNameOrAlias(name))\n+        throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, \"The aggregate function '{}' already exists\", name);\n+\n+    String type = config.getString(key_in_config + \".type\");\n+    UserDefinedExecutableFunctionType function_type;\n+\n+    if (type == \"executable\")\n+        function_type = UserDefinedExecutableFunctionType::executable;\n+    else if (type == \"executable_pool\")\n+        function_type = UserDefinedExecutableFunctionType::executable_pool;\n+    else\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Wrong user defined function type expected 'executable' or 'executable_pool' actual {}\",\n+            function_type);\n+\n+    String command = config.getString(key_in_config + \".command\");\n+    String format = config.getString(key_in_config + \".format\");\n+    DataTypePtr result_type = DataTypeFactory::instance().get(config.getString(key_in_config + \".return_type\"));\n+    bool send_chunk_header = config.getBool(key_in_config + \".send_chunk_header\", false);\n+\n+    size_t pool_size = 0;\n+    size_t command_termination_timeout = 0;\n+    size_t max_command_execution_time = 0;\n+    if (function_type == UserDefinedExecutableFunctionType::executable_pool)\n+    {\n+        pool_size = config.getUInt64(key_in_config + \".pool_size\", 16);\n+        command_termination_timeout = config.getUInt64(key_in_config + \".command_termination_timeout\", 10);\n+        max_command_execution_time = config.getUInt64(key_in_config + \".max_command_execution_time\", 10);\n+\n+        size_t max_execution_time_seconds = static_cast<size_t>(getContext()->getSettings().max_execution_time.totalSeconds());\n+        if (max_execution_time_seconds != 0 && max_command_execution_time > max_execution_time_seconds)\n+            max_command_execution_time = max_execution_time_seconds;\n+    }\n+\n+    ExternalLoadableLifetime lifetime;\n+\n+    if (config.has(key_in_config + \".lifetime\"))\n+        lifetime = ExternalLoadableLifetime(config, key_in_config + \".lifetime\");\n+\n+    std::vector<DataTypePtr> argument_types;\n+\n+    Poco::Util::AbstractConfiguration::Keys config_elems;\n+    config.keys(key_in_config, config_elems);\n+\n+    for (const auto & config_elem : config_elems)\n+    {\n+        if (!startsWith(config_elem, \"argument\"))\n+            continue;\n+\n+        const auto argument_prefix = key_in_config + '.' + config_elem + '.';\n+        auto argument_type = DataTypeFactory::instance().get(config.getString(argument_prefix + \"type\"));\n+        argument_types.emplace_back(std::move(argument_type));\n+    }\n+\n+    UserDefinedExecutableFunctionConfiguration function_configuration\n+    {\n+        .type = function_type,\n+        .name = std::move(name),\n+        .script_path = std::move(command),\n+        .format = std::move(format),\n+        .argument_types = std::move(argument_types),\n+        .result_type = std::move(result_type),\n+        .pool_size = pool_size,\n+        .command_termination_timeout = command_termination_timeout,\n+        .max_command_execution_time = max_command_execution_time,\n+        .send_chunk_header = send_chunk_header\n+    };\n+\n+    return std::make_shared<UserDefinedExecutableFunction>(function_configuration, lifetime);\n+}\n+\n+}\ndiff --git a/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h\nnew file mode 100644\nindex 000000000000..4d4843e86779\n--- /dev/null\n+++ b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h\n@@ -0,0 +1,38 @@\n+#pragma once\n+\n+#include <memory>\n+\n+#include <Interpreters/Context_fwd.h>\n+#include <Interpreters/ExternalLoader.h>\n+#include <Interpreters/UserDefinedExecutableFunction.h>\n+\n+namespace DB\n+{\n+\n+class IExternalLoaderConfigRepository;\n+\n+/// Manages external user-defined functions.\n+class ExternalUserDefinedExecutableFunctionsLoader : public ExternalLoader, WithContext\n+{\n+public:\n+\n+    using UserDefinedExecutableFunctionPtr = std::shared_ptr<const UserDefinedExecutableFunction>;\n+\n+    /// External user-defined functions will be loaded immediately and then will be updated in separate thread, each 'reload_period' seconds.\n+    explicit ExternalUserDefinedExecutableFunctionsLoader(ContextPtr global_context_);\n+\n+    UserDefinedExecutableFunctionPtr getUserDefinedFunction(const std::string & user_defined_function_name) const;\n+\n+    UserDefinedExecutableFunctionPtr tryGetUserDefinedFunction(const std::string & user_defined_function_name) const;\n+\n+    void reloadFunction(const std::string & user_defined_function_name) const;\n+\n+protected:\n+    LoadablePtr create(const std::string & name,\n+        const Poco::Util::AbstractConfiguration & config,\n+        const std::string & key_in_config,\n+        const std::string & repository_name) const override;\n+\n+};\n+\n+}\ndiff --git a/src/Interpreters/InterpreterCreateFunctionQuery.cpp b/src/Interpreters/InterpreterCreateFunctionQuery.cpp\nindex 01fc60060b3a..74d8c9cf9805 100644\n--- a/src/Interpreters/InterpreterCreateFunctionQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateFunctionQuery.cpp\n@@ -6,8 +6,8 @@\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/InterpreterCreateFunctionQuery.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n-#include <Interpreters/UserDefinedObjectsLoader.h>\n-#include <Interpreters/UserDefinedFunctionFactory.h>\n+#include <Interpreters/UserDefinedSQLObjectsLoader.h>\n+#include <Interpreters/UserDefinedSQLFunctionFactory.h>\n \n \n namespace DB\n@@ -34,17 +34,17 @@ BlockIO InterpreterCreateFunctionQuery::execute()\n     auto & function_name = create_function_query->function_name;\n     validateFunction(create_function_query->function_core, function_name);\n \n-    UserDefinedFunctionFactory::instance().registerFunction(function_name, query_ptr);\n+    UserDefinedSQLFunctionFactory::instance().registerFunction(function_name, query_ptr);\n \n     if (!is_internal)\n     {\n         try\n         {\n-            UserDefinedObjectsLoader::instance().storeObject(current_context, UserDefinedObjectType::Function, function_name, *query_ptr);\n+            UserDefinedSQLObjectsLoader::instance().storeObject(current_context, UserDefinedSQLObjectType::Function, function_name, *query_ptr);\n         }\n         catch (Exception & exception)\n         {\n-            UserDefinedFunctionFactory::instance().unregisterFunction(function_name);\n+            UserDefinedSQLFunctionFactory::instance().unregisterFunction(function_name);\n             exception.addMessage(fmt::format(\"while storing user defined function {} on disk\", backQuote(function_name)));\n             throw;\n         }\ndiff --git a/src/Interpreters/InterpreterDropFunctionQuery.cpp b/src/Interpreters/InterpreterDropFunctionQuery.cpp\nindex 9f945c11aac5..53cb96b42fe5 100644\n--- a/src/Interpreters/InterpreterDropFunctionQuery.cpp\n+++ b/src/Interpreters/InterpreterDropFunctionQuery.cpp\n@@ -2,8 +2,8 @@\n #include <Interpreters/Context.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n #include <Interpreters/InterpreterDropFunctionQuery.h>\n-#include <Interpreters/UserDefinedObjectsLoader.h>\n-#include <Interpreters/UserDefinedFunctionFactory.h>\n+#include <Interpreters/UserDefinedSQLObjectsLoader.h>\n+#include <Interpreters/UserDefinedSQLFunctionFactory.h>\n #include <Parsers/ASTDropFunctionQuery.h>\n \n \n@@ -18,8 +18,8 @@ BlockIO InterpreterDropFunctionQuery::execute()\n     FunctionNameNormalizer().visit(query_ptr.get());\n     auto & drop_function_query = query_ptr->as<ASTDropFunctionQuery &>();\n \n-    UserDefinedFunctionFactory::instance().unregisterFunction(drop_function_query.function_name);\n-    UserDefinedObjectsLoader::instance().removeObject(current_context, UserDefinedObjectType::Function, drop_function_query.function_name);\n+    UserDefinedSQLFunctionFactory::instance().unregisterFunction(drop_function_query.function_name);\n+    UserDefinedSQLObjectsLoader::instance().removeObject(current_context, UserDefinedSQLObjectType::Function, drop_function_query.function_name);\n \n     return {};\n }\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 8d25e464271e..226ff124cfbb 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -11,6 +11,7 @@\n #include <Interpreters/DatabaseCatalog.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n #include <Interpreters/ExternalModelsLoader.h>\n+#include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>\n #include <Interpreters/EmbeddedDictionaries.h>\n #include <Interpreters/ActionLocksManager.h>\n #include <Interpreters/InterpreterDropQuery.h>\n@@ -296,7 +297,6 @@ BlockIO InterpreterSystemQuery::execute()\n             auto & external_dictionaries_loader = system_context->getExternalDictionariesLoader();\n             external_dictionaries_loader.reloadDictionary(query.table, getContext());\n \n-\n             ExternalDictionariesLoader::resetAll();\n             break;\n         }\n@@ -326,6 +326,22 @@ BlockIO InterpreterSystemQuery::execute()\n             external_models_loader.reloadAllTriedToLoad();\n             break;\n         }\n+        case Type::RELOAD_FUNCTION:\n+        {\n+            getContext()->checkAccess(AccessType::SYSTEM_RELOAD_FUNCTION);\n+\n+            auto & external_user_defined_executable_functions_loader = system_context->getExternalUserDefinedExecutableFunctionsLoader();\n+            external_user_defined_executable_functions_loader.reloadFunction(query.target_function);\n+            break;\n+        }\n+        case Type::RELOAD_FUNCTIONS:\n+        {\n+            getContext()->checkAccess(AccessType::SYSTEM_RELOAD_FUNCTION);\n+\n+            auto & external_user_defined_executable_functions_loader = system_context->getExternalUserDefinedExecutableFunctionsLoader();\n+            external_user_defined_executable_functions_loader.reloadAllTriedToLoad();\n+            break;\n+        }\n         case Type::RELOAD_EMBEDDED_DICTIONARIES:\n             getContext()->checkAccess(AccessType::SYSTEM_RELOAD_EMBEDDED_DICTIONARIES);\n             system_context->getEmbeddedDictionaries().reload();\n@@ -740,6 +756,12 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()\n             required_access.emplace_back(AccessType::SYSTEM_RELOAD_MODEL);\n             break;\n         }\n+        case Type::RELOAD_FUNCTION: [[fallthrough]];\n+        case Type::RELOAD_FUNCTIONS:\n+        {\n+            required_access.emplace_back(AccessType::SYSTEM_RELOAD_FUNCTION);\n+            break;\n+        }\n         case Type::RELOAD_CONFIG:\n         {\n             required_access.emplace_back(AccessType::SYSTEM_RELOAD_CONFIG);\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 11402e052dca..f92baf5536e3 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -14,7 +14,7 @@\n #include <Interpreters/CollectJoinOnKeysVisitor.h>\n #include <Interpreters/RequiredSourceColumnsVisitor.h>\n #include <Interpreters/GetAggregatesVisitor.h>\n-#include <Interpreters/UserDefinedFunctionsVisitor.h>\n+#include <Interpreters/UserDefinedSQLFunctionVisitor.h>\n #include <Interpreters/TableJoin.h>\n #include <Interpreters/ExpressionActions.h> /// getSmallestColumn()\n #include <Interpreters/getTableExpressions.h>\n@@ -1041,8 +1041,8 @@ TreeRewriterResultPtr TreeRewriter::analyze(\n void TreeRewriter::normalize(\n     ASTPtr & query, Aliases & aliases, const NameSet & source_columns_set, bool ignore_alias, const Settings & settings, bool allow_self_aliases)\n {\n-    UserDefinedFunctionsVisitor::Data data_user_defined_functions_visitor;\n-    UserDefinedFunctionsVisitor(data_user_defined_functions_visitor).visit(query);\n+    UserDefinedSQLFunctionVisitor::Data data_user_defined_functions_visitor;\n+    UserDefinedSQLFunctionVisitor(data_user_defined_functions_visitor).visit(query);\n \n     CustomizeCountDistinctVisitor::Data data_count_distinct{settings.count_distinct_implementation};\n     CustomizeCountDistinctVisitor(data_count_distinct).visit(query);\ndiff --git a/src/Interpreters/UserDefinedExecutableFunction.cpp b/src/Interpreters/UserDefinedExecutableFunction.cpp\nnew file mode 100644\nindex 000000000000..06830df68e6c\n--- /dev/null\n+++ b/src/Interpreters/UserDefinedExecutableFunction.cpp\n@@ -0,0 +1,26 @@\n+#include \"UserDefinedExecutableFunction.h\"\n+\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+\n+#include <DataStreams/ShellCommandSource.h>\n+#include <DataStreams/formatBlock.h>\n+\n+\n+namespace DB\n+{\n+\n+UserDefinedExecutableFunction::UserDefinedExecutableFunction(\n+    const UserDefinedExecutableFunctionConfiguration & configuration_,\n+    const ExternalLoadableLifetime & lifetime_,\n+    std::shared_ptr<ProcessPool> process_pool_)\n+    : configuration(configuration_)\n+    , lifetime(lifetime_)\n+    , process_pool(process_pool_)\n+{\n+    if (!process_pool && configuration.type == UserDefinedExecutableFunctionType::executable_pool)\n+        process_pool = std::make_shared<ProcessPool>(configuration.pool_size == 0 ? std::numeric_limits<int>::max() : configuration.pool_size);\n+}\n+\n+};\ndiff --git a/src/Interpreters/UserDefinedExecutableFunction.h b/src/Interpreters/UserDefinedExecutableFunction.h\nnew file mode 100644\nindex 000000000000..dc5b92ea7451\n--- /dev/null\n+++ b/src/Interpreters/UserDefinedExecutableFunction.h\n@@ -0,0 +1,100 @@\n+#pragma once\n+\n+#include <string>\n+\n+#include <DataTypes/IDataType.h>\n+#include <DataStreams/ShellCommandSource.h>\n+#include <Interpreters/IExternalLoadable.h>\n+\n+\n+namespace DB\n+{\n+\n+enum class UserDefinedExecutableFunctionType\n+{\n+    executable,\n+    executable_pool\n+};\n+\n+struct UserDefinedExecutableFunctionConfiguration\n+{\n+    UserDefinedExecutableFunctionType type = UserDefinedExecutableFunctionType::executable;\n+    std::string name;\n+    std::string script_path;\n+    std::string format;\n+    std::vector<DataTypePtr> argument_types;\n+    DataTypePtr result_type;\n+    /// Pool settings\n+    size_t pool_size = 0;\n+    size_t command_termination_timeout = 0;\n+    size_t max_command_execution_time = 0;\n+    /// Send number_of_rows\\n before sending chunk to process\n+    bool send_chunk_header = false;\n+};\n+\n+class UserDefinedExecutableFunction final : public IExternalLoadable\n+{\n+public:\n+\n+    UserDefinedExecutableFunction(\n+        const UserDefinedExecutableFunctionConfiguration & configuration_,\n+        const ExternalLoadableLifetime & lifetime_,\n+        std::shared_ptr<ProcessPool> process_pool_ = nullptr);\n+\n+    const ExternalLoadableLifetime & getLifetime() const override\n+    {\n+        return lifetime;\n+    }\n+\n+    const std::string & getLoadableName() const override\n+    {\n+        return configuration.name;\n+    }\n+\n+    bool supportUpdates() const override\n+    {\n+        return true;\n+    }\n+\n+    bool isModified() const override\n+    {\n+        return true;\n+    }\n+\n+    std::shared_ptr<const IExternalLoadable> clone() const override\n+    {\n+        std::cerr << \"UserDefinedExecutableFunction::clone \" << this << std::endl;\n+        return std::make_shared<UserDefinedExecutableFunction>(configuration, lifetime, process_pool);\n+    }\n+\n+    const UserDefinedExecutableFunctionConfiguration & getConfiguration() const\n+    {\n+        return configuration;\n+    }\n+\n+    std::shared_ptr<ProcessPool> getProcessPool() const\n+    {\n+        return process_pool;\n+    }\n+\n+    std::shared_ptr<UserDefinedExecutableFunction> shared_from_this()\n+    {\n+        return std::static_pointer_cast<UserDefinedExecutableFunction>(IExternalLoadable::shared_from_this());\n+    }\n+\n+    std::shared_ptr<const UserDefinedExecutableFunction> shared_from_this() const\n+    {\n+        return std::static_pointer_cast<const UserDefinedExecutableFunction>(IExternalLoadable::shared_from_this());\n+    }\n+\n+private:\n+    UserDefinedExecutableFunction(const UserDefinedExecutableFunctionConfiguration & configuration_,\n+        std::shared_ptr<ProcessPool> process_pool_,\n+        const ExternalLoadableLifetime & lifetime_);\n+\n+    UserDefinedExecutableFunctionConfiguration configuration;\n+    ExternalLoadableLifetime lifetime;\n+    std::shared_ptr<ProcessPool> process_pool;\n+};\n+\n+}\ndiff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\nnew file mode 100644\nindex 000000000000..b6fb4d8d5e57\n--- /dev/null\n+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\n@@ -0,0 +1,218 @@\n+#include \"UserDefinedExecutableFunctionFactory.h\"\n+\n+#include <IO/WriteHelpers.h>\n+\n+#include <DataStreams/ShellCommandSource.h>\n+#include <DataStreams/formatBlock.h>\n+\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>\n+#include <Interpreters/Context.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNSUPPORTED_METHOD;\n+    extern const int TIMEOUT_EXCEEDED;\n+}\n+\n+class UserDefinedFunction final : public IFunction\n+{\n+public:\n+\n+    explicit UserDefinedFunction(\n+        ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr executable_function_,\n+        ContextPtr context_)\n+        : executable_function(std::move(executable_function_))\n+        , context(context_)\n+    {\n+    }\n+\n+    String getName() const override { return executable_function->getConfiguration().name; }\n+\n+    bool isVariadic() const override { return false; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return executable_function->getConfiguration().argument_types.size(); }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool useDefaultImplementationForNulls() const override { return true; }\n+    bool isDeterministic() const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        const auto & configuration = executable_function->getConfiguration();\n+\n+        for (size_t i = 0; i < arguments.size(); ++i)\n+        {\n+            const auto & expected_argument_type = configuration.argument_types[i];\n+            if (!areTypesEqual(expected_argument_type, arguments[i]))\n+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                    \"Function {} for {} argument expected {} actual {}\",\n+                    getName(),\n+                    i,\n+                    expected_argument_type->getName(),\n+                    arguments[i]->getName());\n+        }\n+\n+        return configuration.result_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        std::unique_ptr<ShellCommand> process = getProcess();\n+\n+        ColumnWithTypeAndName result(result_type, \"result\");\n+        Block result_block({result});\n+\n+        Block arguments_block(arguments);\n+        auto * process_in = &process->in;\n+\n+        const auto & configuration = executable_function->getConfiguration();\n+        auto process_pool = executable_function->getProcessPool();\n+        bool is_executable_pool_function = (process_pool != nullptr);\n+\n+        ShellCommandSourceConfiguration shell_command_source_configuration;\n+\n+        if (is_executable_pool_function)\n+        {\n+            shell_command_source_configuration.read_fixed_number_of_rows = true;\n+            shell_command_source_configuration.number_of_rows_to_read = input_rows_count;\n+        }\n+\n+        ShellCommandSource::SendDataTask task = {[process_in, arguments_block, &configuration, is_executable_pool_function, this]()\n+        {\n+            auto & out = *process_in;\n+\n+            if (configuration.send_chunk_header)\n+            {\n+                writeText(arguments_block.rows(), out);\n+                writeChar('\\n', out);\n+            }\n+\n+            auto output_stream = context->getOutputStream(configuration.format, out, arguments_block.cloneEmpty());\n+            formatBlock(output_stream, arguments_block);\n+            if (!is_executable_pool_function)\n+                out.close();\n+        }};\n+        std::vector<ShellCommandSource::SendDataTask> tasks = {std::move(task)};\n+\n+        Pipe pipe(std::make_unique<ShellCommandSource>(\n+            context,\n+            configuration.format,\n+            result_block.cloneEmpty(),\n+            std::move(process),\n+            std::move(tasks),\n+            shell_command_source_configuration,\n+            process_pool));\n+\n+        QueryPipeline pipeline;\n+        pipeline.init(std::move(pipe));\n+\n+        PullingPipelineExecutor executor(pipeline);\n+\n+        auto result_column = result_type->createColumn();\n+        result_column->reserve(input_rows_count);\n+\n+        Block block;\n+        while (executor.pull(block))\n+        {\n+            const auto & result_column_to_add = *block.safeGetByPosition(0).column;\n+            result_column->insertRangeFrom(result_column_to_add, 0, result_column_to_add.size());\n+        }\n+\n+        size_t result_column_size = result_column->size();\n+        if (result_column_size != input_rows_count)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                \"Function {} wrong result rows count expected {} actual {}\",\n+                getName(),\n+                input_rows_count,\n+                result_column_size);\n+\n+        return result_column;\n+    }\n+\n+private:\n+\n+    std::unique_ptr<ShellCommand> getProcess() const\n+    {\n+        auto process_pool = executable_function->getProcessPool();\n+        auto executable_function_configuration = executable_function->getConfiguration();\n+\n+        std::unique_ptr<ShellCommand> process;\n+        bool is_executable_pool_function = (process_pool != nullptr);\n+        if (is_executable_pool_function)\n+        {\n+            bool result = process_pool->tryBorrowObject(process, [&]()\n+            {\n+                ShellCommand::Config process_config(executable_function_configuration.script_path);\n+                process_config.terminate_in_destructor_strategy = ShellCommand::DestructorStrategy{ true /*terminate_in_destructor*/, executable_function_configuration.command_termination_timeout };\n+                auto shell_command = ShellCommand::execute(process_config);\n+                return shell_command;\n+            }, executable_function_configuration.max_command_execution_time * 1000);\n+\n+            if (!result)\n+                throw Exception(ErrorCodes::TIMEOUT_EXCEEDED,\n+                    \"Could not get process from pool, max command execution timeout exceeded {} seconds\",\n+                    executable_function_configuration.max_command_execution_time);\n+        }\n+        else\n+        {\n+            process = ShellCommand::execute(executable_function_configuration.script_path);\n+        }\n+\n+        return process;\n+    }\n+\n+    ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr executable_function;\n+    ContextPtr context;\n+};\n+\n+UserDefinedExecutableFunctionFactory & UserDefinedExecutableFunctionFactory::instance()\n+{\n+    static UserDefinedExecutableFunctionFactory result;\n+    return result;\n+}\n+\n+FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::get(const String & function_name, ContextPtr context)\n+{\n+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\n+    auto executable_function = std::static_pointer_cast<const UserDefinedExecutableFunction>(loader.load(function_name));\n+    auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context));\n+    return std::make_unique<FunctionToOverloadResolverAdaptor>(std::move(function));\n+}\n+\n+FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::tryGet(const String & function_name, ContextPtr context)\n+{\n+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\n+    auto load_result = loader.getLoadResult(function_name);\n+\n+    if (load_result.object)\n+    {\n+        auto executable_function = std::static_pointer_cast<const UserDefinedExecutableFunction>(load_result.object);\n+        auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context));\n+        return std::make_unique<FunctionToOverloadResolverAdaptor>(std::move(function));\n+    }\n+\n+    return nullptr;\n+}\n+\n+std::vector<String> UserDefinedExecutableFunctionFactory::getRegisteredNames(ContextPtr context)\n+{\n+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\n+    auto loaded_objects = loader.getLoadedObjects();\n+\n+    std::vector<std::string> registered_names;\n+    registered_names.reserve(loaded_objects.size());\n+\n+    for (auto & loaded_object : loaded_objects)\n+        registered_names.emplace_back(loaded_object->getLoadableName());\n+\n+    return registered_names;\n+}\n+\n+}\ndiff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.h b/src/Interpreters/UserDefinedExecutableFunctionFactory.h\nnew file mode 100644\nindex 000000000000..0afeeecbca7f\n--- /dev/null\n+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.h\n@@ -0,0 +1,31 @@\n+#pragma once\n+\n+#include <functional>\n+#include <memory>\n+#include <string>\n+#include <unordered_map>\n+\n+#include <Common/NamePrompter.h>\n+#include <Interpreters/Context_fwd.h>\n+#include <Functions/IFunction.h>\n+\n+\n+namespace DB\n+{\n+\n+class UserDefinedExecutableFunctionFactory\n+{\n+public:\n+    using Creator = std::function<FunctionOverloadResolverPtr(ContextPtr)>;\n+\n+    static UserDefinedExecutableFunctionFactory & instance();\n+\n+    static FunctionOverloadResolverPtr get(const String & function_name, ContextPtr context);\n+\n+    static FunctionOverloadResolverPtr tryGet(const String & function_name, ContextPtr context);\n+\n+    static std::vector<String> getRegisteredNames(ContextPtr context);\n+\n+};\n+\n+}\ndiff --git a/src/Interpreters/UserDefinedFunctionFactory.h b/src/Interpreters/UserDefinedFunctionFactory.h\ndeleted file mode 100644\nindex 0d7167eb1b78..000000000000\n--- a/src/Interpreters/UserDefinedFunctionFactory.h\n+++ /dev/null\n@@ -1,39 +0,0 @@\n-#pragma once\n-\n-#include <unordered_map>\n-#include <mutex>\n-\n-#include <Common/NamePrompter.h>\n-\n-#include <Parsers/ASTCreateFunctionQuery.h>\n-\n-namespace DB\n-{\n-\n-///Factory for user defined functions stores functions.\n-class UserDefinedFunctionFactory : public IHints<1, UserDefinedFunctionFactory>\n-{\n-public:\n-    static UserDefinedFunctionFactory & instance();\n-\n-    /// Register function with function_name. create_function_query pointer must be ASTCreateFunctionQuery.\n-    void registerFunction(const String & function_name, ASTPtr create_function_query);\n-\n-    /// Unregister function with function_name.\n-    void unregisterFunction(const String & function_name);\n-\n-    /// Throws an exception if not found. Result ast pointer safely can be casted to ASTCreateFunctionQuery.\n-    ASTPtr get(const String & function_name) const;\n-\n-    /// Returns nullptr if not found. Result ast pointer safely can be casted to ASTCreateFunctionQuery.\n-    ASTPtr tryGet(const String & function_name) const;\n-\n-    /// Get all registered function names.\n-    std::vector<String> getAllRegisteredNames() const override;\n-\n-private:\n-    std::unordered_map<String, ASTPtr> function_name_to_create_query;\n-    mutable std::mutex mutex;\n-};\n-\n-}\ndiff --git a/src/Interpreters/UserDefinedObjectsLoader.h b/src/Interpreters/UserDefinedObjectsLoader.h\ndeleted file mode 100644\nindex f0054fac450b..000000000000\n--- a/src/Interpreters/UserDefinedObjectsLoader.h\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-#pragma once\n-\n-#include <Interpreters/Context_fwd.h>\n-#include <Parsers/IAST.h>\n-\n-#include <boost/noncopyable.hpp>\n-\n-\n-namespace DB\n-{\n-\n-enum class UserDefinedObjectType\n-{\n-    Function\n-};\n-\n-class UserDefinedObjectsLoader : private boost::noncopyable\n-{\n-public:\n-    static UserDefinedObjectsLoader & instance();\n-    UserDefinedObjectsLoader();\n-\n-    void loadObjects(ContextPtr context);\n-    void storeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name, const IAST & ast);\n-    void removeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name);\n-\n-private:\n-\n-    void loadUserDefinedObject(ContextPtr context, UserDefinedObjectType object_type, const std::string_view & object_name, const String & file_path);\n-    Poco::Logger * log;\n-};\n-\n-}\ndiff --git a/src/Interpreters/UserDefinedFunctionFactory.cpp b/src/Interpreters/UserDefinedSQLFunctionFactory.cpp\nsimilarity index 79%\nrename from src/Interpreters/UserDefinedFunctionFactory.cpp\nrename to src/Interpreters/UserDefinedSQLFunctionFactory.cpp\nindex 0970b09f8638..434f5523b428 100644\n--- a/src/Interpreters/UserDefinedFunctionFactory.cpp\n+++ b/src/Interpreters/UserDefinedSQLFunctionFactory.cpp\n@@ -1,4 +1,4 @@\n-#include \"UserDefinedFunctionFactory.h\"\n+#include \"UserDefinedSQLFunctionFactory.h\"\n \n #include <Functions/FunctionFactory.h>\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n@@ -13,13 +13,13 @@ namespace ErrorCodes\n     extern const int CANNOT_DROP_SYSTEM_FUNCTION;\n }\n \n-UserDefinedFunctionFactory & UserDefinedFunctionFactory::instance()\n+UserDefinedSQLFunctionFactory & UserDefinedSQLFunctionFactory::instance()\n {\n-    static UserDefinedFunctionFactory result;\n+    static UserDefinedSQLFunctionFactory result;\n     return result;\n }\n \n-void UserDefinedFunctionFactory::registerFunction(const String & function_name, ASTPtr create_function_query)\n+void UserDefinedSQLFunctionFactory::registerFunction(const String & function_name, ASTPtr create_function_query)\n {\n     if (FunctionFactory::instance().hasNameOrAlias(function_name))\n         throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, \"The function '{}' already exists\", function_name);\n@@ -36,7 +36,7 @@ void UserDefinedFunctionFactory::registerFunction(const String & function_name,\n             function_name);\n }\n \n-void UserDefinedFunctionFactory::unregisterFunction(const String & function_name)\n+void UserDefinedSQLFunctionFactory::unregisterFunction(const String & function_name)\n {\n     if (FunctionFactory::instance().hasNameOrAlias(function_name) ||\n         AggregateFunctionFactory::instance().hasNameOrAlias(function_name))\n@@ -53,7 +53,7 @@ void UserDefinedFunctionFactory::unregisterFunction(const String & function_name\n     function_name_to_create_query.erase(it);\n }\n \n-ASTPtr UserDefinedFunctionFactory::get(const String & function_name) const\n+ASTPtr UserDefinedSQLFunctionFactory::get(const String & function_name) const\n {\n     std::lock_guard lock(mutex);\n \n@@ -66,7 +66,7 @@ ASTPtr UserDefinedFunctionFactory::get(const String & function_name) const\n     return it->second;\n }\n \n-ASTPtr UserDefinedFunctionFactory::tryGet(const std::string & function_name) const\n+ASTPtr UserDefinedSQLFunctionFactory::tryGet(const std::string & function_name) const\n {\n     std::lock_guard lock(mutex);\n \n@@ -77,7 +77,7 @@ ASTPtr UserDefinedFunctionFactory::tryGet(const std::string & function_name) con\n     return it->second;\n }\n \n-std::vector<std::string> UserDefinedFunctionFactory::getAllRegisteredNames() const\n+std::vector<std::string> UserDefinedSQLFunctionFactory::getAllRegisteredNames() const\n {\n     std::vector<std::string> registered_names;\n \ndiff --git a/src/Interpreters/UserDefinedSQLFunctionFactory.h b/src/Interpreters/UserDefinedSQLFunctionFactory.h\nnew file mode 100644\nindex 000000000000..366e27e833da\n--- /dev/null\n+++ b/src/Interpreters/UserDefinedSQLFunctionFactory.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <unordered_map>\n+#include <mutex>\n+\n+#include <Common/NamePrompter.h>\n+\n+#include <Parsers/ASTCreateFunctionQuery.h>\n+\n+namespace DB\n+{\n+\n+class UserDefinedSQLFunctionFactory : public IHints<1, UserDefinedSQLFunctionFactory>\n+{\n+public:\n+    static UserDefinedSQLFunctionFactory & instance();\n+\n+    void registerFunction(const String & function_name, ASTPtr create_function_query);\n+\n+    void unregisterFunction(const String & function_name);\n+\n+    ASTPtr get(const String & function_name) const;\n+\n+    ASTPtr tryGet(const String & function_name) const;\n+\n+    std::vector<String> getAllRegisteredNames() const override;\n+\n+private:\n+    std::unordered_map<String, ASTPtr> function_name_to_create_query;\n+    mutable std::mutex mutex;\n+};\n+\n+}\ndiff --git a/src/Interpreters/UserDefinedFunctionsVisitor.cpp b/src/Interpreters/UserDefinedSQLFunctionVisitor.cpp\nsimilarity index 86%\nrename from src/Interpreters/UserDefinedFunctionsVisitor.cpp\nrename to src/Interpreters/UserDefinedSQLFunctionVisitor.cpp\nindex 2a793d178176..6471f9cbf628 100644\n--- a/src/Interpreters/UserDefinedFunctionsVisitor.cpp\n+++ b/src/Interpreters/UserDefinedSQLFunctionVisitor.cpp\n@@ -1,4 +1,4 @@\n-#include \"UserDefinedFunctionsVisitor.h\"\n+#include \"UserDefinedSQLFunctionVisitor.h\"\n \n #include <unordered_map>\n #include <stack>\n@@ -7,7 +7,7 @@\n #include <Parsers/ASTCreateFunctionQuery.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTIdentifier.h>\n-#include <Interpreters/UserDefinedFunctionFactory.h>\n+#include <Interpreters/UserDefinedSQLFunctionFactory.h>\n \n \n namespace DB\n@@ -18,7 +18,7 @@ namespace ErrorCodes\n     extern const int UNSUPPORTED_METHOD;\n }\n \n-void UserDefinedFunctionsMatcher::visit(ASTPtr & ast, Data &)\n+void UserDefinedSQLFunctionMatcher::visit(ASTPtr & ast, Data &)\n {\n     auto * function = ast->as<ASTFunction>();\n     if (!function)\n@@ -29,14 +29,14 @@ void UserDefinedFunctionsMatcher::visit(ASTPtr & ast, Data &)\n         ast = result;\n }\n \n-bool UserDefinedFunctionsMatcher::needChildVisit(const ASTPtr &, const ASTPtr &)\n+bool UserDefinedSQLFunctionMatcher::needChildVisit(const ASTPtr &, const ASTPtr &)\n {\n     return true;\n }\n \n-ASTPtr UserDefinedFunctionsMatcher::tryToReplaceFunction(const ASTFunction & function)\n+ASTPtr UserDefinedSQLFunctionMatcher::tryToReplaceFunction(const ASTFunction & function)\n {\n-    auto user_defined_function = UserDefinedFunctionFactory::instance().tryGet(function.name);\n+    auto user_defined_function = UserDefinedSQLFunctionFactory::instance().tryGet(function.name);\n     if (!user_defined_function)\n         return nullptr;\n \ndiff --git a/src/Interpreters/UserDefinedFunctionsVisitor.h b/src/Interpreters/UserDefinedSQLFunctionVisitor.h\nsimilarity index 82%\nrename from src/Interpreters/UserDefinedFunctionsVisitor.h\nrename to src/Interpreters/UserDefinedSQLFunctionVisitor.h\nindex c24e0327ddc7..46f95f29ab90 100644\n--- a/src/Interpreters/UserDefinedFunctionsVisitor.h\n+++ b/src/Interpreters/UserDefinedSQLFunctionVisitor.h\n@@ -19,10 +19,10 @@ class ASTFunction;\n   * After applying visitor:\n   * SELECT number + 1 FROM system.numbers LIMIT 10;\n   */\n-class UserDefinedFunctionsMatcher\n+class UserDefinedSQLFunctionMatcher\n {\n public:\n-    using Visitor = InDepthNodeVisitor<UserDefinedFunctionsMatcher, true>;\n+    using Visitor = InDepthNodeVisitor<UserDefinedSQLFunctionMatcher, true>;\n \n     struct Data\n     {\n@@ -39,6 +39,6 @@ class UserDefinedFunctionsMatcher\n };\n \n /// Visits AST nodes and collect their aliases in one map (with links to source nodes).\n-using UserDefinedFunctionsVisitor = UserDefinedFunctionsMatcher::Visitor;\n+using UserDefinedSQLFunctionVisitor = UserDefinedSQLFunctionMatcher::Visitor;\n \n }\ndiff --git a/src/Interpreters/UserDefinedObjectsLoader.cpp b/src/Interpreters/UserDefinedSQLObjectsLoader.cpp\nsimilarity index 79%\nrename from src/Interpreters/UserDefinedObjectsLoader.cpp\nrename to src/Interpreters/UserDefinedSQLObjectsLoader.cpp\nindex 5237de594f48..5b2a5605de7a 100644\n--- a/src/Interpreters/UserDefinedObjectsLoader.cpp\n+++ b/src/Interpreters/UserDefinedSQLObjectsLoader.cpp\n@@ -1,4 +1,4 @@\n-#include \"UserDefinedObjectsLoader.h\"\n+#include \"UserDefinedSQLObjectsLoader.h\"\n \n #include <filesystem>\n \n@@ -32,17 +32,17 @@ namespace ErrorCodes\n     extern const int OBJECT_WAS_NOT_STORED_ON_DISK;\n }\n \n-UserDefinedObjectsLoader & UserDefinedObjectsLoader::instance()\n+UserDefinedSQLObjectsLoader & UserDefinedSQLObjectsLoader::instance()\n {\n-    static UserDefinedObjectsLoader ret;\n+    static UserDefinedSQLObjectsLoader ret;\n     return ret;\n }\n \n-UserDefinedObjectsLoader::UserDefinedObjectsLoader()\n-    : log(&Poco::Logger::get(\"UserDefinedObjectsLoader\"))\n+UserDefinedSQLObjectsLoader::UserDefinedSQLObjectsLoader()\n+    : log(&Poco::Logger::get(\"UserDefinedSQLObjectsLoader\"))\n {}\n \n-void UserDefinedObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDefinedObjectType object_type, const std::string_view & name, const String & path)\n+void UserDefinedSQLObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDefinedSQLObjectType object_type, const std::string_view & name, const String & path)\n {\n     auto name_ref = StringRef(name.data(), name.size());\n     LOG_DEBUG(log, \"Loading user defined object {} from file {}\", backQuote(name_ref), path);\n@@ -57,7 +57,7 @@ void UserDefinedObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDef\n     {\n         switch (object_type)\n         {\n-            case UserDefinedObjectType::Function:\n+            case UserDefinedSQLObjectType::Function:\n             {\n                 ParserCreateFunctionQuery parser;\n                 ASTPtr ast = parseQuery(\n@@ -80,7 +80,7 @@ void UserDefinedObjectsLoader::loadUserDefinedObject(ContextPtr context, UserDef\n     }\n }\n \n-void UserDefinedObjectsLoader::loadObjects(ContextPtr context)\n+void UserDefinedSQLObjectsLoader::loadObjects(ContextPtr context)\n {\n     LOG_DEBUG(log, \"loading user defined objects\");\n \n@@ -102,19 +102,19 @@ void UserDefinedObjectsLoader::loadObjects(ContextPtr context)\n             std::string_view object_name = file_name;\n             object_name.remove_suffix(strlen(\".sql\"));\n             object_name.remove_prefix(strlen(\"function_\"));\n-            loadUserDefinedObject(context, UserDefinedObjectType::Function, object_name, dir_path + it.name());\n+            loadUserDefinedObject(context, UserDefinedSQLObjectType::Function, object_name, dir_path + it.name());\n         }\n     }\n }\n \n-void UserDefinedObjectsLoader::storeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name, const IAST & ast)\n+void UserDefinedSQLObjectsLoader::storeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name, const IAST & ast)\n {\n     String dir_path = context->getPath() + \"user_defined/\";\n     String file_path;\n \n     switch (object_type)\n     {\n-        case UserDefinedObjectType::Function:\n+        case UserDefinedSQLObjectType::Function:\n         {\n             file_path = dir_path + \"function_\" + escapeForFileName(object_name) + \".sql\";\n         }\n@@ -140,7 +140,7 @@ void UserDefinedObjectsLoader::storeObject(ContextPtr context, UserDefinedObject\n     LOG_DEBUG(log, \"Stored object {}\", backQuote(object_name));\n }\n \n-void UserDefinedObjectsLoader::removeObject(ContextPtr context, UserDefinedObjectType object_type, const String & object_name)\n+void UserDefinedSQLObjectsLoader::removeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name)\n {\n     String dir_path = context->getPath() + \"user_defined/\";\n     LOG_DEBUG(log, \"Removing file for user defined object {} from {}\", backQuote(object_name), dir_path);\n@@ -149,7 +149,7 @@ void UserDefinedObjectsLoader::removeObject(ContextPtr context, UserDefinedObjec\n \n     switch (object_type)\n     {\n-        case UserDefinedObjectType::Function:\n+        case UserDefinedSQLObjectType::Function:\n         {\n             file_path = dir_path + \"function_\" + escapeForFileName(object_name) + \".sql\";\n         }\ndiff --git a/src/Interpreters/UserDefinedSQLObjectsLoader.h b/src/Interpreters/UserDefinedSQLObjectsLoader.h\nnew file mode 100644\nindex 000000000000..6daf3e99833e\n--- /dev/null\n+++ b/src/Interpreters/UserDefinedSQLObjectsLoader.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <Interpreters/Context_fwd.h>\n+#include <Parsers/IAST.h>\n+\n+#include <boost/noncopyable.hpp>\n+\n+\n+namespace DB\n+{\n+\n+enum class UserDefinedSQLObjectType\n+{\n+    Function\n+};\n+\n+class UserDefinedSQLObjectsLoader : private boost::noncopyable\n+{\n+public:\n+    static UserDefinedSQLObjectsLoader & instance();\n+    UserDefinedSQLObjectsLoader();\n+\n+    void loadObjects(ContextPtr context);\n+    void storeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name, const IAST & ast);\n+    void removeObject(ContextPtr context, UserDefinedSQLObjectType object_type, const String & object_name);\n+\n+private:\n+\n+    void loadUserDefinedObject(ContextPtr context, UserDefinedSQLObjectType object_type, const std::string_view & object_name, const String & file_path);\n+    Poco::Logger * log;\n+};\n+\n+}\ndiff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make\nindex ed9e28b5a11b..e8b33d09914c 100644\n--- a/src/Interpreters/ya.make\n+++ b/src/Interpreters/ya.make\n@@ -60,6 +60,7 @@ SRCS(\n     ExternalLoaderTempConfigRepository.cpp\n     ExternalLoaderXMLConfigRepository.cpp\n     ExternalModelsLoader.cpp\n+    ExternalUserDefinedExecutableFunctionsLoader.cpp\n     ExtractExpressionInfoVisitor.cpp\n     FillingRow.cpp\n     FunctionNameNormalizer.cpp\n@@ -165,9 +166,11 @@ SRCS(\n     TranslateQualifiedNamesVisitor.cpp\n     TreeOptimizer.cpp\n     TreeRewriter.cpp\n-    UserDefinedFunctionFactory.cpp\n-    UserDefinedFunctionsVisitor.cpp\n-    UserDefinedObjectsLoader.cpp\n+    UserDefinedExecutableFunction.cpp\n+    UserDefinedExecutableFunctionFactory.cpp\n+    UserDefinedSQLFunctionFactory.cpp\n+    UserDefinedSQLFunctionVisitor.cpp\n+    UserDefinedSQLObjectsLoader.cpp\n     WindowDescription.cpp\n     ZooKeeperLog.cpp\n     addMissingDefaults.cpp\ndiff --git a/src/Parsers/ASTSystemQuery.h b/src/Parsers/ASTSystemQuery.h\nindex a14537957d10..f55ccc591605 100644\n--- a/src/Parsers/ASTSystemQuery.h\n+++ b/src/Parsers/ASTSystemQuery.h\n@@ -39,6 +39,8 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster\n         RELOAD_DICTIONARIES,\n         RELOAD_MODEL,\n         RELOAD_MODELS,\n+        RELOAD_FUNCTION,\n+        RELOAD_FUNCTIONS,\n         RELOAD_EMBEDDED_DICTIONARIES,\n         RELOAD_CONFIG,\n         RELOAD_SYMBOLS,\n@@ -65,6 +67,7 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster\n     Type type = Type::UNKNOWN;\n \n     String target_model;\n+    String target_function;\n     String database;\n     String table;\n     String replica;\ndiff --git a/src/Parsers/ParserSystemQuery.cpp b/src/Parsers/ParserSystemQuery.cpp\nindex 147436d0d834..5381566263e9 100644\n--- a/src/Parsers/ParserSystemQuery.cpp\n+++ b/src/Parsers/ParserSystemQuery.cpp\n@@ -125,6 +125,35 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n \n             break;\n         }\n+        case Type::RELOAD_FUNCTION:\n+        {\n+            String cluster_str;\n+            if (ParserKeyword{\"ON\"}.ignore(pos, expected))\n+            {\n+                if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n+                    return false;\n+            }\n+            res->cluster = cluster_str;\n+            ASTPtr ast;\n+            if (ParserStringLiteral{}.parse(pos, ast, expected))\n+            {\n+                res->target_function = ast->as<ASTLiteral &>().value.safeGet<String>();\n+            }\n+            else\n+            {\n+                ParserIdentifier function_parser;\n+                ASTPtr function;\n+                String target_function;\n+\n+                if (!function_parser.parse(pos, function, expected))\n+                    return false;\n+\n+                if (!tryGetIdentifierNameInto(function, res->target_function))\n+                    return false;\n+            }\n+\n+            break;\n+        }\n         case Type::DROP_REPLICA:\n         {\n             ASTPtr ast;\ndiff --git a/src/Storages/System/StorageSystemFunctions.cpp b/src/Storages/System/StorageSystemFunctions.cpp\nindex f19cffee37cc..b3f1231bd1a7 100644\n--- a/src/Storages/System/StorageSystemFunctions.cpp\n+++ b/src/Storages/System/StorageSystemFunctions.cpp\n@@ -1,24 +1,34 @@\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeEnum.h>\n #include <Parsers/queryToString.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/IFunction.h>\n #include <Interpreters/Context.h>\n-#include <Interpreters/UserDefinedFunctionFactory.h>\n+#include <Interpreters/UserDefinedSQLFunctionFactory.h>\n+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>\n #include <Storages/System/StorageSystemFunctions.h>\n \n namespace DB\n {\n+\n+enum class FunctionOrigin : Int8\n+{\n+    SYSTEM = 0,\n+    SQL_USER_DEFINED = 1,\n+    EXECUTABLE_USER_DEFINED = 2\n+};\n+\n namespace\n {\n     template <typename Factory>\n-    void fillRow(MutableColumns & res_columns, const String & name, UInt64 is_aggregate, const String & create_query, const Factory & f)\n+    void fillRow(MutableColumns & res_columns, const String & name, UInt64 is_aggregate, const String & create_query, FunctionOrigin function_origin, const Factory & f)\n     {\n         res_columns[0]->insert(name);\n         res_columns[1]->insert(is_aggregate);\n \n-        if constexpr (std::is_same_v<Factory, UserDefinedFunctionFactory>)\n+        if constexpr (std::is_same_v<Factory, UserDefinedSQLFunctionFactory> || std::is_same_v<Factory, UserDefinedExecutableFunctionFactory>)\n         {\n             res_columns[2]->insert(false);\n             res_columns[3]->insertDefault();\n@@ -33,9 +43,19 @@ namespace\n         }\n \n         res_columns[4]->insert(create_query);\n+        res_columns[5]->insert(static_cast<Int8>(function_origin));\n     }\n }\n \n+std::vector<std::pair<String, Int8>> getOriginEnumsAndValues()\n+{\n+    return std::vector<std::pair<String, Int8>>{\n+        {\"System\", static_cast<Int8>(FunctionOrigin::SYSTEM)},\n+        {\"SQLUserDefined\", static_cast<Int8>(FunctionOrigin::SQL_USER_DEFINED)},\n+        {\"ExecutableUserDefined\", static_cast<Int8>(FunctionOrigin::EXECUTABLE_USER_DEFINED)}\n+    };\n+}\n+\n NamesAndTypesList StorageSystemFunctions::getNamesAndTypes()\n {\n     return {\n@@ -43,32 +63,40 @@ NamesAndTypesList StorageSystemFunctions::getNamesAndTypes()\n         {\"is_aggregate\", std::make_shared<DataTypeUInt8>()},\n         {\"case_insensitive\", std::make_shared<DataTypeUInt8>()},\n         {\"alias_to\", std::make_shared<DataTypeString>()},\n-        {\"create_query\", std::make_shared<DataTypeString>()}\n+        {\"create_query\", std::make_shared<DataTypeString>()},\n+        {\"origin\", std::make_shared<DataTypeEnum8>(getOriginEnumsAndValues())}\n     };\n }\n \n-void StorageSystemFunctions::fillData(MutableColumns & res_columns, ContextPtr, const SelectQueryInfo &) const\n+void StorageSystemFunctions::fillData(MutableColumns & res_columns, ContextPtr context, const SelectQueryInfo &) const\n {\n     const auto & functions_factory = FunctionFactory::instance();\n     const auto & function_names = functions_factory.getAllRegisteredNames();\n     for (const auto & function_name : function_names)\n     {\n-        fillRow(res_columns, function_name, UInt64(0), \"\", functions_factory);\n+        fillRow(res_columns, function_name, UInt64(0), \"\", FunctionOrigin::SYSTEM, functions_factory);\n     }\n \n     const auto & aggregate_functions_factory = AggregateFunctionFactory::instance();\n     const auto & aggregate_function_names = aggregate_functions_factory.getAllRegisteredNames();\n     for (const auto & function_name : aggregate_function_names)\n     {\n-        fillRow(res_columns, function_name, UInt64(1), \"\", aggregate_functions_factory);\n+        fillRow(res_columns, function_name, UInt64(1), \"\", FunctionOrigin::SYSTEM, aggregate_functions_factory);\n+    }\n+\n+    const auto & user_defined_sql_functions_factory = UserDefinedSQLFunctionFactory::instance();\n+    const auto & user_defined_sql_functions_names = user_defined_sql_functions_factory.getAllRegisteredNames();\n+    for (const auto & function_name : user_defined_sql_functions_names)\n+    {\n+        auto create_query = queryToString(user_defined_sql_functions_factory.get(function_name));\n+        fillRow(res_columns, function_name, UInt64(0), create_query, FunctionOrigin::SQL_USER_DEFINED, user_defined_sql_functions_factory);\n     }\n \n-    const auto & user_defined_functions_factory = UserDefinedFunctionFactory::instance();\n-    const auto & user_defined_functions_names = user_defined_functions_factory.getAllRegisteredNames();\n-    for (const auto & function_name : user_defined_functions_names)\n+    const auto & user_defined_executable_functions_factory = UserDefinedExecutableFunctionFactory::instance();\n+    const auto & user_defined_executable_functions_names = user_defined_executable_functions_factory.getRegisteredNames(context);\n+    for (const auto & function_name : user_defined_executable_functions_names)\n     {\n-        auto create_query = queryToString(user_defined_functions_factory.get(function_name));\n-        fillRow(res_columns, function_name, UInt64(0), create_query, user_defined_functions_factory);\n+        fillRow(res_columns, function_name, UInt64(0), \"\", FunctionOrigin::EXECUTABLE_USER_DEFINED, user_defined_executable_functions_factory);\n     }\n }\n }\n",
  "test_patch": "diff --git a/tests/config/install.sh b/tests/config/install.sh\nindex 7f95f200719a..df62cba0ea94 100755\n--- a/tests/config/install.sh\n+++ b/tests/config/install.sh\n@@ -57,6 +57,7 @@ ln -sf $SRC_PATH/strings_dictionary.xml $DEST_SERVER_PATH/\n ln -sf $SRC_PATH/decimals_dictionary.xml $DEST_SERVER_PATH/\n ln -sf $SRC_PATH/executable_dictionary.xml $DEST_SERVER_PATH/\n ln -sf $SRC_PATH/executable_pool_dictionary.xml $DEST_SERVER_PATH/\n+ln -sf $SRC_PATH/test_function.xml $DEST_SERVER_PATH/\n \n ln -sf $SRC_PATH/top_level_domains $DEST_SERVER_PATH/\n \ndiff --git a/tests/config/test_function.xml b/tests/config/test_function.xml\nnew file mode 100644\nindex 000000000000..2e31c9677ec9\n--- /dev/null\n+++ b/tests/config/test_function.xml\n@@ -0,0 +1,16 @@\n+<functions>\n+    <function>\n+        <type>executable</type>\n+        <name>test_function</name>\n+        <return_type>UInt64</return_type>\n+        <argument>\n+            <type>UInt64</type>\n+        </argument>\n+        <argument>\n+            <type>UInt64</type>\n+        </argument>\n+        <format>TabSeparated</format>\n+        <command>cd /; clickhouse-local --input-format TabSeparated --output-format TabSeparated --structure 'x UInt64, y UInt64' --query \"SELECT x + y FROM table\"</command>\n+        <lifetime>0</lifetime>\n+    </function>\n+</functions>\ndiff --git a/tests/queries/0_stateless/01271_show_privileges.reference b/tests/queries/0_stateless/01271_show_privileges.reference\nindex 7dcf0a48dab8..65e3e2448dd2 100644\n--- a/tests/queries/0_stateless/01271_show_privileges.reference\n+++ b/tests/queries/0_stateless/01271_show_privileges.reference\n@@ -92,6 +92,7 @@ SYSTEM RELOAD CONFIG\t['RELOAD CONFIG']\tGLOBAL\tSYSTEM RELOAD\n SYSTEM RELOAD SYMBOLS\t['RELOAD SYMBOLS']\tGLOBAL\tSYSTEM RELOAD\n SYSTEM RELOAD DICTIONARY\t['SYSTEM RELOAD DICTIONARIES','RELOAD DICTIONARY','RELOAD DICTIONARIES']\tGLOBAL\tSYSTEM RELOAD\n SYSTEM RELOAD MODEL\t['SYSTEM RELOAD MODELS','RELOAD MODEL','RELOAD MODELS']\tGLOBAL\tSYSTEM RELOAD\n+SYSTEM RELOAD FUNCTION\t['SYSTEM RELOAD FUNCTIONS','RELOAD FUNCTION','RELOAD FUNCTIONS']\tGLOBAL\tSYSTEM RELOAD\n SYSTEM RELOAD EMBEDDED DICTIONARIES\t['RELOAD EMBEDDED DICTIONARIES']\tGLOBAL\tSYSTEM RELOAD\n SYSTEM RELOAD\t[]\t\\N\tSYSTEM\n SYSTEM RESTART DISK\t['SYSTEM RESTART DISK']\tGLOBAL\tSYSTEM\ndiff --git a/tests/queries/0_stateless/2015_executable_user_defined_functions.reference b/tests/queries/0_stateless/2015_executable_user_defined_functions.reference\nnew file mode 100644\nindex 000000000000..b8626c4cff28\n--- /dev/null\n+++ b/tests/queries/0_stateless/2015_executable_user_defined_functions.reference\n@@ -0,0 +1,1 @@\n+4\ndiff --git a/tests/queries/0_stateless/2015_executable_user_defined_functions.sql b/tests/queries/0_stateless/2015_executable_user_defined_functions.sql\nnew file mode 100644\nindex 000000000000..68848f49cfc4\n--- /dev/null\n+++ b/tests/queries/0_stateless/2015_executable_user_defined_functions.sql\n@@ -0,0 +1,1 @@\n+SELECT test_function(toUInt64(2), toUInt64(2));\ndiff --git a/tests/server-test.xml b/tests/server-test.xml\nindex 1f67317ad0a0..3f4030e07d1d 100644\n--- a/tests/server-test.xml\n+++ b/tests/server-test.xml\n@@ -134,6 +134,7 @@\n         <flush_interval_milliseconds>7500</flush_interval_milliseconds>\n     </query_log>\n     <dictionaries_config>*_dictionary.xml</dictionaries_config>\n+    <user_defined_executable_functions_config>*_function.xml</user_defined_executable_functions_config>\n     <compression incl=\"clickhouse_compression\">\n     </compression>\n     <distributed_ddl>\n",
  "problem_statement": "UDF support\nIt would be great if we could create user defined functions in ClickHouse. I don't know whether it has C++ API for that but a high level language such as V8 for Lua would be better since they allow us to create functions in runtime similar to PL/pgSQL and PL/SQL.\n\nSince ClickHouse is an analytical database, users will want to perform complex analytical queries such as funnel and retention and implementing them in ANSI SQL (with joins, CTEs etc.) is quite inefficient. UDFs would help us to avoid expensive JOINS so it would be a huge win.\n\nUDFs can be created using `CREATE FUNCTION` syntax similar to this one:\n\n```\nCREATE FUNCTION dummy_func() RETURNS int8 AS '\n    return 1;\n' LANGUAGE V8;\n```\n\nImplementing aggregate functions may be harder than scalar functions but even the support for scalar functions would be great.\n\n",
  "hints_text": "We have not support for UDFs yet for several reasons:\n1. To not fixate on some API. Internal interfaces are subjects to change. We want to have the ability to \"break\" the code.\n2. Interface of ordinary functions is quite complex: due to vector engine, functions are dispatched not on single values, but on arrays of values. It allows to unroll and vectorize loops; or for example, to run substring search on whole array. Also, functions provide different code path for constants and for non-constants - they depend on memory layout of data, for efficiency. It made interface quite ugly for using from foreign language. It is possible to provide some simple interface (without ability to vectorize) for foreign languages and it could be done in different ways... Whole idea remains reasonable for implementing 'dirty' temporary functions.\n\nFor now, it is better to add every new function directly to ClickHouse source. If function is not too specific, code will be merged.\n\nSince CH already bundles Clang, how about UDFs in C/CPP? Scalar functions could be a good start...\n> Since CH already bundles Clang, how about UDFs in C/CPP? Scalar functions could be a good start...\r\n\r\nFirst we will try to add dynamic code generation for compositions of simple functions.\r\nFor example, `a * b + c` will be compiled to single loop.\r\n\r\nOnly after we will think about adding C++ UDF.\n> First we will try to add dynamic code generation for compositions of simple functions.\r\n\r\nFYI, dynamic code generation has been implemented.\nThis task is assigned to @ObjatieGroba and he will do research and proof-of-concepts on various variants of UDFs.\nSome discussion around UDF in ClickHouse with code is [here](https://github.com/ClickHouse/ClickHouse/pull/6991)\nMaybe this is a crazy idea, but that about the [Julia](https://julialang.org/) language as UDF language? It's fast, can broadcast function calls to arrays out of box and can be embedded into c/c++ code.  ",
  "created_at": "2021-09-09T13:48:32Z",
  "modified_files": [
    "programs/local/LocalServer.cpp",
    "programs/server/Server.cpp",
    "programs/server/config.xml",
    "src/Access/AccessType.h",
    "src/Interpreters/ActionsVisitor.cpp",
    "src/Interpreters/Context.cpp",
    "src/Interpreters/Context.h",
    "b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp",
    "b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h",
    "src/Interpreters/InterpreterCreateFunctionQuery.cpp",
    "src/Interpreters/InterpreterDropFunctionQuery.cpp",
    "src/Interpreters/InterpreterSystemQuery.cpp",
    "src/Interpreters/TreeRewriter.cpp",
    "b/src/Interpreters/UserDefinedExecutableFunction.cpp",
    "b/src/Interpreters/UserDefinedExecutableFunction.h",
    "b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp",
    "b/src/Interpreters/UserDefinedExecutableFunctionFactory.h",
    "src/Interpreters/UserDefinedFunctionFactory.h",
    "src/Interpreters/UserDefinedObjectsLoader.h",
    "src/Interpreters/UserDefinedFunctionFactory.cpp",
    "b/src/Interpreters/UserDefinedSQLFunctionFactory.h",
    "src/Interpreters/UserDefinedFunctionsVisitor.cpp",
    "src/Interpreters/UserDefinedFunctionsVisitor.h",
    "src/Interpreters/UserDefinedObjectsLoader.cpp",
    "b/src/Interpreters/UserDefinedSQLObjectsLoader.h",
    "src/Interpreters/ya.make",
    "src/Parsers/ASTSystemQuery.h",
    "src/Parsers/ParserSystemQuery.cpp",
    "src/Storages/System/StorageSystemFunctions.cpp"
  ],
  "modified_test_files": [
    "tests/config/install.sh",
    "b/tests/config/test_function.xml",
    "tests/queries/0_stateless/01271_show_privileges.reference",
    "b/tests/queries/0_stateless/2015_executable_user_defined_functions.reference",
    "b/tests/queries/0_stateless/2015_executable_user_defined_functions.sql",
    "tests/server-test.xml"
  ]
}