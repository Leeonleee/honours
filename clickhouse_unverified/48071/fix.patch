diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md
index 785d9d34b255..3e70f94a0d2f 100644
--- a/docs/en/sql-reference/functions/array-functions.md
+++ b/docs/en/sql-reference/functions/array-functions.md
@@ -646,7 +646,7 @@ SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
 
 Array elements set to `NULL` are handled as normal values.
 
-## arraySort(\[func,\] arr, …)
+## arraySort(\[func,\] arr, …) {#array_functions-sort}
 
 Sorts the elements of the `arr` array in ascending order. If the `func` function is specified, sorting order is determined by the result of the `func` function applied to the elements of the array. If `func` accepts multiple arguments, the `arraySort` function is passed several arrays that the arguments of `func` will correspond to. Detailed examples are shown at the end of `arraySort` description.
 
@@ -751,7 +751,7 @@ To improve sorting efficiency, the [Schwartzian transform](https://en.wikipedia.
 
 Same as `arraySort` with additional `limit` argument allowing partial sorting. Returns an array of the same size as the original array where elements in range `[1..limit]` are sorted in ascending order. Remaining elements `(limit..N]` shall contain elements in unspecified order.
 
-## arrayReverseSort(\[func,\] arr, …)
+## arrayReverseSort(\[func,\] arr, …) {#array_functions-reverse-sort}
 
 Sorts the elements of the `arr` array in descending order. If the `func` function is specified, `arr` is sorted according to the result of the `func` function applied to the elements of the array, and then the sorted array is reversed. If `func` accepts multiple arguments, the `arrayReverseSort` function is passed several arrays that the arguments of `func` will correspond to. Detailed examples are shown at the end of `arrayReverseSort` description.
 
diff --git a/docs/en/sql-reference/functions/tuple-map-functions.md b/docs/en/sql-reference/functions/tuple-map-functions.md
index 087a133500e7..786ea47f12cd 100644
--- a/docs/en/sql-reference/functions/tuple-map-functions.md
+++ b/docs/en/sql-reference/functions/tuple-map-functions.md
@@ -69,24 +69,27 @@ Result:
 
 Merges an [Array](../../sql-reference/data-types/array.md) of keys and an [Array](../../sql-reference/data-types/array.md) of values into a [Map(key, value)](../../sql-reference/data-types/map.md). Notice that the second argument could also be a [Map](../../sql-reference/data-types/map.md), thus it is casted to an Array when executing.
 
+
 The function is a more convenient alternative to `CAST((key_array, value_array_or_map), 'Map(key_type, value_type)')`. For example, instead of writing `CAST((['aa', 'bb'], [4, 5]), 'Map(String, UInt32)')`, you can write `mapFromArrays(['aa', 'bb'], [4, 5])`.
-  
+
+
 **Syntax**
 
 ```sql
 mapFromArrays(keys, values)
-```  
+```
 
 Alias: `MAP_FROM_ARRAYS(keys, values)`
-  
+
 **Arguments**
+
 - `keys` — Given key array to create a map from. The nested type of array must be: [String](../../sql-reference/data-types/string.md), [Integer](../../sql-reference/data-types/int-uint.md), [LowCardinality](../../sql-reference/data-types/lowcardinality.md), [FixedString](../../sql-reference/data-types/fixedstring.md), [UUID](../../sql-reference/data-types/uuid.md), [Date](../../sql-reference/data-types/date.md), [DateTime](../../sql-reference/data-types/datetime.md), [Date32](../../sql-reference/data-types/date32.md), [Enum](../../sql-reference/data-types/enum.md)
 - `values`  - Given value array or map to create a map from.
-  
+
 **Returned value**
 
 - A map whose keys and values are constructed from the key array and value array/map.
-  
+
 **Example**
 
 Query:
@@ -94,6 +97,7 @@ Query:
 ```sql
 select mapFromArrays(['a', 'b', 'c'], [1, 2, 3])
 
+
 ┌─mapFromArrays(['a', 'b', 'c'], [1, 2, 3])─┐
 │ {'a':1,'b':2,'c':3}                       │
 └───────────────────────────────────────────┘
@@ -391,25 +395,24 @@ Result:
 │ ['eleven','11']  │
 │ ['twelve','6.0'] │
 └──────────────────┘
-```  
-  
-## mapContainsKeyLike  
-  
+```
+
+## mapContainsKeyLike
+
 **Syntax**
 
 ```sql
 mapContainsKeyLike(map, pattern)
-```  
-  
+```
+
 **Arguments**
-  
-- `map` — Map. [Map](../../sql-reference/data-types/map.md).  
-- `pattern`  - String pattern to match.  
-  
+- `map` — Map. [Map](../../sql-reference/data-types/map.md).
+- `pattern`  - String pattern to match.
+
 **Returned value**
 
-- `1` if `map` contains `key` like specified pattern, `0` if not.  
-  
+- `1` if `map` contains `key` like specified pattern, `0` if not.
+
 **Example**
 
 Query:
@@ -420,34 +423,34 @@ CREATE TABLE test (a Map(String,String)) ENGINE = Memory;
 INSERT INTO test VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});
 
 SELECT mapContainsKeyLike(a, 'a%') FROM test;
-```  
-  
-Result:  
-  
+```
+
+Result:
+
 ```text
 ┌─mapContainsKeyLike(a, 'a%')─┐
 │                           1 │
 │                           0 │
-└─────────────────────────────┘  
-```  
-  
-## mapExtractKeyLike  
-  
+└─────────────────────────────┘
+```
+
+## mapExtractKeyLike
+
 **Syntax**
 
 ```sql
 mapExtractKeyLike(map, pattern)
-```  
-  
+```
+
 **Arguments**
-  
-- `map` — Map. [Map](../../sql-reference/data-types/map.md).  
-- `pattern`  - String pattern to match.  
-  
+
+- `map` — Map. [Map](../../sql-reference/data-types/map.md).
+- `pattern`  - String pattern to match.
+
 **Returned value**
 
 - A map contained elements the key of which matchs the specified pattern. If there are no elements matched the pattern, it will return an empty map.
-  
+
 **Example**
 
 Query:
@@ -458,34 +461,34 @@ CREATE TABLE test (a Map(String,String)) ENGINE = Memory;
 INSERT INTO test VALUES ({'abc':'abc','def':'def'}), ({'hij':'hij','klm':'klm'});
 
 SELECT mapExtractKeyLike(a, 'a%') FROM test;
-```  
-  
-Result:  
-  
+```
+
+Result:
+
 ```text
 ┌─mapExtractKeyLike(a, 'a%')─┐
 │ {'abc':'abc'}              │
 │ {}                         │
 └────────────────────────────┘
-```  
-  
-## mapApply  
-  
+```
+
+## mapApply
+
 **Syntax**
 
 ```sql
 mapApply(func, map)
-```  
-  
+```
+
 **Arguments**
-  
+
 - `func`  - [Lambda function](../../sql-reference/functions/index.md#higher-order-functions---operator-and-lambdaparams-expr-function).
 - `map` — [Map](../../sql-reference/data-types/map.md).
 
 **Returned value**
 
 - Returns a map obtained from the original map by application of `func(map1[i], …, mapN[i])` for each element.
-  
+
 **Example**
 
 Query:
@@ -497,36 +500,36 @@ FROM
     SELECT map('key1', number, 'key2', number * 2) AS _map
     FROM numbers(3)
 )
-```  
-  
-Result:  
-  
+```
+
+Result:
+
 ```text
 ┌─r─────────────────────┐
 │ {'key1':0,'key2':0}   │
 │ {'key1':10,'key2':20} │
 │ {'key1':20,'key2':40} │
 └───────────────────────┘
-```  
+```
+
+## mapFilter
 
-## mapFilter  
-  
 **Syntax**
 
 ```sql
 mapFilter(func, map)
-```  
-  
+```
+
 **Arguments**
 
 - `func`  - [Lambda function](../../sql-reference/functions/index.md#higher-order-functions---operator-and-lambdaparams-expr-function).
-- `map` — [Map](../../sql-reference/data-types/map.md).  
+- `map` — [Map](../../sql-reference/data-types/map.md).
 
 **Returned value**
 
 - Returns a map containing only the elements in `map` for which `func(map1[i], …, mapN[i])` returns something other than 0.
-  
-  
+
+
 **Example**
 
 Query:
@@ -538,27 +541,27 @@ FROM
     SELECT map('key1', number, 'key2', number * 2) AS _map
     FROM numbers(3)
 )
-```  
-  
-Result:  
-  
+```
+
+Result:
+
 ```text
 ┌─r───────────────────┐
 │ {'key1':0,'key2':0} │
 │ {'key2':2}          │
 │ {'key1':2,'key2':4} │
 └─────────────────────┘
-```  
+```
+
 
+## mapUpdate
 
-## mapUpdate  
-  
 **Syntax**
 
 ```sql
 mapUpdate(map1, map2)
-```  
-  
+```
+
 **Arguments**
 
 - `map1` [Map](../../sql-reference/data-types/map.md).
@@ -567,19 +570,166 @@ mapUpdate(map1, map2)
 **Returned value**
 
 - Returns a map1 with values updated of values for the corresponding keys in map2.
-  
+
 **Example**
 
 Query:
 
 ```sql
 SELECT mapUpdate(map('key1', 0, 'key3', 0), map('key1', 10, 'key2', 10)) AS map;
-```  
-  
-Result:  
-  
+```
+
+Result:
+
 ```text
 ┌─map────────────────────────────┐
 │ {'key3':0,'key1':10,'key2':10} │
 └────────────────────────────────┘
-```  
+```
+
+## mapConcat
+
+**Syntax**
+
+```sql
+mapConcat(maps)
+```
+
+**Arguments**
+
+-   `maps` – Arbitrary number of arguments of [Map](../../sql-reference/data-types/map.md) type.
+
+**Returned value**
+
+- Returns a map with concatenated maps passed as arguments. If there are same keys in two or more maps, all of them are added to the result map, but only the first one is accessible via operator `[]`
+
+**Examples**
+
+Query:
+
+```sql
+SELECT mapConcat(map('key1', 1, 'key3', 3), map('key2', 2)) AS map;
+```
+
+Result:
+
+```text
+┌─map──────────────────────────┐
+│ {'key1':1,'key3':3,'key2':2} │
+└──────────────────────────────┘
+```
+
+Query:
+
+```sql
+SELECT mapConcat(map('key1', 1, 'key2', 2), map('key1', 3)) AS map, map['key1'];
+```
+
+Result:
+
+```text
+┌─map──────────────────────────┬─elem─┐
+│ {'key1':1,'key2':2,'key1':3} │    1 │
+└──────────────────────────────┴──────┘
+```
+
+## mapExists(\[func,\], map)
+
+Returns 1 if there is at least one key-value pair in `map` for which `func(key, value)` returns something other than 0. Otherwise, it returns 0.
+
+Note that the `mapExists` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You can pass a lambda function to it as the first argument.
+
+**Example**
+
+Query:
+
+```sql
+SELECT mapExists((k, v) -> (v = 1), map('k1', 1, 'k2', 2)) AS res
+```
+
+Result:
+
+```text
+┌─res─┐
+│   1 │
+└─────┘
+```
+
+## mapAll(\[func,\] map)
+
+Returns 1 if `func(key, value)` returns something other than 0 for all key-value pairs in `map`. Otherwise, it returns 0.
+
+Note that the `mapAll` is a [higher-order function](../../sql-reference/functions/index.md#higher-order-functions). You can pass a lambda function to it as the first argument.
+
+**Example**
+
+Query:
+
+```sql
+SELECT mapAll((k, v) -> (v = 1), map('k1', 1, 'k2', 2)) AS res
+```
+
+Result:
+
+```text
+┌─res─┐
+│   0 │
+└─────┘
+```
+
+## mapSort(\[func,\], map)
+
+Sorts the elements of the `map` in ascending order. If the `func` function is specified, sorting order is determined by the result of the `func` function applied to the keys and values of the map.
+
+**Examples**
+
+``` sql
+SELECT mapSort(map('key2', 2, 'key3', 1, 'key1', 3)) AS map;
+```
+
+``` text
+┌─map──────────────────────────┐
+│ {'key1':3,'key2':2,'key3':1} │
+└──────────────────────────────┘
+```
+
+``` sql
+SELECT mapSort((k, v) -> v, map('key2', 2, 'key3', 1, 'key1', 3)) AS map;
+```
+
+``` text
+┌─map──────────────────────────┐
+│ {'key3':1,'key2':2,'key1':3} │
+└──────────────────────────────┘
+```
+
+For more details see the [reference](../../sql-reference/functions/array-functions.md#array_functions-sort) for `arraySort` function.
+
+## mapReverseSort(\[func,\], map)
+
+Sorts the elements of the `map` in descending order. If the `func` function is specified, sorting order is determined by the result of the `func` function applied to the keys and values of the map.
+
+
+**Examples**
+
+``` sql
+SELECT mapReverseSort(map('key2', 2, 'key3', 1, 'key1', 3)) AS map;
+```
+
+``` text
+┌─map──────────────────────────┐
+│ {'key3':1,'key2':2,'key1':3} │
+└──────────────────────────────┘
+```
+
+``` sql
+SELECT mapReverseSort((k, v) -> v, map('key2', 2, 'key3', 1, 'key1', 3)) AS map;
+```
+
+``` text
+┌─map──────────────────────────┐
+│ {'key1':3,'key2':2,'key3':1} │
+└──────────────────────────────┘
+```
+
+For more details see the [reference](../../sql-reference/functions/array-functions.md#array_functions-reverse-sort) for `arrayReverseSort` function.
diff --git a/src/Columns/ColumnFunction.cpp b/src/Columns/ColumnFunction.cpp
index 59ee93410c89..3ea7073d8c87 100644
--- a/src/Columns/ColumnFunction.cpp
+++ b/src/Columns/ColumnFunction.cpp
@@ -258,12 +258,11 @@ void ColumnFunction::appendArguments(const ColumnsWithTypeAndName & columns)
 
 void ColumnFunction::appendArgument(const ColumnWithTypeAndName & column)
 {
-    const auto & argumnet_types = function->getArgumentTypes();
-
+    const auto & argument_types = function->getArgumentTypes();
     auto index = captured_columns.size();
-    if (!is_short_circuit_argument && !column.type->equals(*argumnet_types[index]))
+    if (!is_short_circuit_argument && !column.type->equals(*argument_types[index]))
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Cannot capture column {} because it has incompatible type: "
-                        "got {}, but {} is expected.", argumnet_types.size(), column.type->getName(), argumnet_types[index]->getName());
+                        "got {}, but {} is expected.", argument_types.size(), column.type->getName(), argument_types[index]->getName());
 
     captured_columns.push_back(column);
 }
diff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp
index 879e40eb0986..0f5d97e67616 100644
--- a/src/DataTypes/DataTypeMap.cpp
+++ b/src/DataTypes/DataTypeMap.cpp
@@ -128,6 +128,13 @@ bool DataTypeMap::checkKeyType(DataTypePtr key_type)
     return true;
 }
 
+DataTypePtr DataTypeMap::getNestedTypeWithUnnamedTuple() const
+{
+    const auto & from_array = assert_cast<const DataTypeArray &>(*nested);
+    const auto & from_tuple = assert_cast<const DataTypeTuple &>(*from_array.getNestedType());
+    return std::make_shared<DataTypeArray>(std::make_shared<DataTypeTuple>(from_tuple.getElements()));
+}
+
 static DataTypePtr create(const ASTPtr & arguments)
 {
     if (!arguments || arguments->children.size() != 2)
diff --git a/src/DataTypes/DataTypeMap.h b/src/DataTypes/DataTypeMap.h
index 2ab5c602a259..4712f6bbdefe 100644
--- a/src/DataTypes/DataTypeMap.h
+++ b/src/DataTypes/DataTypeMap.h
@@ -47,6 +47,7 @@ class DataTypeMap final : public IDataType
     const DataTypePtr & getValueType() const { return value_type; }
     DataTypes getKeyValueTypes() const { return {key_type, value_type}; }
     const DataTypePtr & getNestedType() const { return nested; }
+    DataTypePtr getNestedTypeWithUnnamedTuple() const;
 
     SerializationPtr doGetDefaultSerialization() const override;
 
diff --git a/src/Functions/FunctionFactory.h b/src/Functions/FunctionFactory.h
index 1a909ea05987..b9063e2c29a8 100644
--- a/src/Functions/FunctionFactory.h
+++ b/src/Functions/FunctionFactory.h
@@ -37,7 +37,6 @@ class FunctionFactory : private boost::noncopyable, public IFactoryWithAliases<F
     template <typename Function>
     void registerFunction(const std::string & name, Documentation doc = {}, CaseSensitiveness case_sensitiveness = CaseSensitive)
     {
-
         if constexpr (std::is_base_of_v<IFunction, Function>)
             registerFunction(name, &adaptFunctionToOverloadResolver<Function>, std::move(doc), case_sensitiveness);
         else
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index 28002d34acc4..46717923f7ec 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -3098,12 +3098,18 @@ class FunctionCast final : public FunctionCastBase
             return &ConvertImplGenericFromString<ColumnString>::execute;
         }
 
+        DataTypePtr from_type_holder;
         const auto * from_type = checkAndGetDataType<DataTypeArray>(from_type_untyped.get());
         const auto * from_type_map = checkAndGetDataType<DataTypeMap>(from_type_untyped.get());
 
         /// Convert from Map
         if (from_type_map)
-            from_type = checkAndGetDataType<DataTypeArray>(from_type_map->getNestedType().get());
+        {
+            /// Recreate array of unnamed tuples because otherwise it may work
+            /// unexpectedly while converting to array of named tuples.
+            from_type_holder = from_type_map->getNestedTypeWithUnnamedTuple();
+            from_type = assert_cast<const DataTypeArray *>(from_type_holder.get());
+        }
 
         if (!from_type)
         {
diff --git a/src/Functions/array/CMakeLists.txt b/src/Functions/array/CMakeLists.txt
index 98335dbb8e76..2800b5b4e289 100644
--- a/src/Functions/array/CMakeLists.txt
+++ b/src/Functions/array/CMakeLists.txt
@@ -3,6 +3,10 @@ add_headers_and_sources(clickhouse_functions_array .)
 add_library(clickhouse_functions_array OBJECT ${clickhouse_functions_array_sources} ${clickhouse_functions_array_headers})
 target_link_libraries(clickhouse_functions_array PRIVATE dbms clickhouse_functions_gatherutils)
 
+if (TARGET ch_contrib::vectorscan)
+    target_link_libraries(clickhouse_functions_array PRIVATE ch_contrib::vectorscan)
+endif()
+
 if (OMIT_HEAVY_DEBUG_SYMBOLS)
     target_compile_options(clickhouse_functions_array PRIVATE "-g0")
 endif()
diff --git a/src/Functions/array/FunctionArrayMapped.h b/src/Functions/array/FunctionArrayMapped.h
index 61abc607349e..9917a38e144e 100644
--- a/src/Functions/array/FunctionArrayMapped.h
+++ b/src/Functions/array/FunctionArrayMapped.h
@@ -19,6 +19,7 @@
 #include <DataTypes/DataTypeLowCardinality.h>
 #include <DataTypes/DataTypeMap.h>
 #include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/DataTypeTuple.h>
 
 #include <Functions/FunctionHelpers.h>
 #include <Functions/IFunction.h>
@@ -41,33 +42,6 @@ namespace ErrorCodes
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
 }
 
-
-template <typename T>
-ColumnPtr getOffsetsPtr(const T & column)
-{
-    if constexpr (std::is_same_v<T, ColumnArray>)
-    {
-        return column.getOffsetsPtr();
-    }
-    else // ColumnMap
-    {
-        return column.getNestedColumn().getOffsetsPtr();
-    }
-}
-
-template <typename T>
-const IColumn::Offsets & getOffsets(const T & column)
-{
-    if constexpr (std::is_same_v<T, ColumnArray>)
-    {
-        return column.getOffsets();
-    }
-    else // ColumnMap
-    {
-        return column.getNestedColumn().getOffsets();
-    }
-}
-
 /** Higher-order functions for arrays.
   * These functions optionally apply a map (transform) to array (or multiple arrays of identical size) by lambda function,
   *  and return some result based on that transformation.
@@ -90,10 +64,6 @@ class FunctionArrayMapped : public IFunction
 {
 public:
     static constexpr auto name = Name::name;
-    static constexpr bool is_argument_type_map = std::is_same_v<typename Impl::data_type, DataTypeMap>;
-    static constexpr bool is_argument_type_array = std::is_same_v<typename Impl::data_type, DataTypeArray>;
-    static constexpr auto argument_type_name = is_argument_type_map ? "Map" : "Array";
-
     static constexpr size_t num_fixed_params = []{ if constexpr (requires { Impl::num_fixed_params; }) return Impl::num_fixed_params; else return 0; }();
 
     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayMapped>(); }
@@ -131,32 +101,56 @@ class FunctionArrayMapped : public IFunction
                 num_fixed_params + 1,
                 (num_fixed_params + 1 == 1) ? "" : "s");
 
-        size_t nested_types_count = (arguments.size() - num_fixed_params - 1) * (is_argument_type_map ? 2 : 1);
-        DataTypes nested_types(nested_types_count);
-        for (size_t i = 0; i < arguments.size() - 1 - num_fixed_params; ++i)
+        bool is_single_array_argument = arguments.size() == num_fixed_params + 2;
+        size_t tuple_argument_size = 0;
+
+        size_t num_nested_types = arguments.size() - num_fixed_params - 1;
+        DataTypes nested_types(num_nested_types);
+
+        for (size_t i = 0; i < num_nested_types; ++i)
         {
-            const auto * array_type = checkAndGetDataType<typename Impl::data_type>(&*arguments[i + 1 + num_fixed_params]);
+            const auto * array_type = checkAndGetDataType<DataTypeArray>(&*arguments[i + 1 + num_fixed_params]);
             if (!array_type)
                 throw Exception(
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "Argument {} of function {} must be {}. Found {} instead",
+                    "Argument {} of function {} must be Array. Found {} instead",
                     i + 2 + num_fixed_params,
                     getName(),
-                    argument_type_name,
                     arguments[i + 1 + num_fixed_params]->getName());
-            if constexpr (is_argument_type_map)
-            {
-                nested_types[2 * i] = recursiveRemoveLowCardinality(array_type->getKeyType());
-                nested_types[2 * i + 1] = recursiveRemoveLowCardinality(array_type->getValueType());
-            }
-            else if constexpr (is_argument_type_array)
-            {
-                nested_types[i] = recursiveRemoveLowCardinality(array_type->getNestedType());
-            }
+
+            if (const auto * tuple_type = checkAndGetDataType<DataTypeTuple>(array_type->getNestedType().get()))
+                tuple_argument_size = tuple_type->getElements().size();
+
+            nested_types[i] = recursiveRemoveLowCardinality(array_type->getNestedType());
+        }
+
+        const auto * function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].get());
+        if (!function_type)
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "First argument for this overload of {} must be a function with {} arguments, found {} instead",
+                getName(),
+                nested_types.size(),
+                arguments[0]->getName());
+
+        size_t num_function_arguments = function_type->getArgumentTypes().size();
+        if (is_single_array_argument
+            && tuple_argument_size
+            && tuple_argument_size == num_function_arguments)
+        {
+            assert(nested_types.size() == 1);
+
+            auto argument_type = nested_types[0];
+            const auto & tuple_type = assert_cast<const DataTypeTuple &>(*argument_type);
+
+            nested_types.clear();
+            nested_types.reserve(tuple_argument_size);
+
+            for (const auto & element : tuple_type.getElements())
+                nested_types.push_back(element);
         }
 
-        const DataTypeFunction * function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].get());
-        if (!function_type || function_type->getArgumentTypes().size() != nested_types.size())
+        if (num_function_arguments != nested_types.size())
             throw Exception(
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                 "First argument for this overload of {} must be a function with {} arguments, found {} instead",
@@ -179,11 +173,11 @@ class FunctionArrayMapped : public IFunction
                 (min_args > 1 ? "s" : ""),
                 arguments.size());
 
-        if ((arguments.size() == 1 + num_fixed_params) && is_argument_type_array)
+        if (arguments.size() == 1 + num_fixed_params)
         {
-            const auto * data_type = checkAndGetDataType<typename Impl::data_type>(arguments[num_fixed_params].type.get());
+            const auto * array_type = checkAndGetDataType<DataTypeArray>(arguments[num_fixed_params].type.get());
 
-            if (!data_type)
+            if (!array_type)
                 throw Exception(
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "The {}{}{} argument for function {} must be array. Found {} instead",
@@ -196,7 +190,7 @@ class FunctionArrayMapped : public IFunction
             if constexpr (num_fixed_params)
                 Impl::checkArguments(getName(), arguments.data());
 
-            DataTypePtr nested_type = data_type->getNestedType();
+            DataTypePtr nested_type = array_type->getNestedType();
 
             if (Impl::needBoolean() && !isUInt8(nested_type))
                 throw Exception(
@@ -208,10 +202,7 @@ class FunctionArrayMapped : public IFunction
                     getName(),
                     arguments[num_fixed_params].type->getName());
 
-            if constexpr (is_argument_type_array)
-                return Impl::getReturnType(nested_type, nested_type);
-            else
-                throw DB::Exception(ErrorCodes::LOGICAL_ERROR, "Unreachable code reached");
+            return Impl::getReturnType(nested_type, nested_type);
         }
         else
         {
@@ -246,26 +237,15 @@ class FunctionArrayMapped : public IFunction
                     getName(),
                     return_type->getName());
 
-            static_assert(is_argument_type_map || is_argument_type_array, "unsupported type");
-
             if (arguments.size() < 2 + num_fixed_params)
-            {
                 throw DB::Exception(ErrorCodes::LOGICAL_ERROR, "Incorrect number of arguments: {}", arguments.size());
-            }
-
-            const auto * first_array_type = checkAndGetDataType<typename Impl::data_type>(arguments[1 + num_fixed_params].type.get());
 
+            const auto * first_array_type = checkAndGetDataType<DataTypeArray>(arguments[1 + num_fixed_params].type.get());
             if (!first_array_type)
                 throw DB::Exception(
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Unsupported type {}", arguments[1 + num_fixed_params].type->getName());
 
-            if constexpr (is_argument_type_array)
-                return Impl::getReturnType(return_type, first_array_type->getNestedType());
-
-            if constexpr (is_argument_type_map)
-                return Impl::getReturnType(return_type, first_array_type->getKeyValueTypes());
-
-            throw DB::Exception(ErrorCodes::LOGICAL_ERROR, "Unreachable code reached");
+            return Impl::getReturnType(return_type, first_array_type->getNestedType());
         }
     }
 
@@ -274,38 +254,26 @@ class FunctionArrayMapped : public IFunction
         if (arguments.size() == 1 + num_fixed_params)
         {
             ColumnPtr column_array_ptr = arguments[num_fixed_params].column;
-            const auto * column_array = checkAndGetColumn<typename Impl::column_type>(column_array_ptr.get());
+            const auto * column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());
 
             if (!column_array)
             {
-                const ColumnConst * column_const_array = checkAndGetColumnConst<typename Impl::column_type>(column_array_ptr.get());
+                const auto * column_const_array = checkAndGetColumnConst<ColumnArray>(column_array_ptr.get());
                 if (!column_const_array)
                     throw Exception(
-                        ErrorCodes::ILLEGAL_COLUMN, "Expected {} column, found {}", argument_type_name, column_array_ptr->getName());
+                        ErrorCodes::ILLEGAL_COLUMN, "Expected Array column, found {}", column_array_ptr->getName());
+
                 column_array_ptr = column_const_array->convertToFullColumn();
-                column_array = assert_cast<const typename Impl::column_type *>(column_array_ptr.get());
+                column_array = assert_cast<const ColumnArray *>(column_array_ptr.get());
             }
 
-            if constexpr (std::is_same_v<typename Impl::column_type, ColumnMap>)
-            {
-                if constexpr (num_fixed_params)
-                    return Impl::execute(
-                        *column_array,
-                        column_array->getNestedColumn().getDataPtr(),
-                        arguments.data());
-                else
-                    return Impl::execute(*column_array, column_array->getNestedColumn().getDataPtr());
-            }
+            if constexpr (num_fixed_params)
+                return Impl::execute(
+                    *column_array,
+                    column_array->getDataPtr(),
+                    arguments.data());
             else
-            {
-                if constexpr (num_fixed_params)
-                    return Impl::execute(
-                        *column_array,
-                        column_array->getDataPtr(),
-                        arguments.data());
-                else
-                    return Impl::execute(*column_array, column_array->getDataPtr());
-            }
+                return Impl::execute(*column_array, column_array->getDataPtr());
         }
         else
         {
@@ -315,81 +283,92 @@ class FunctionArrayMapped : public IFunction
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a function.", getName());
 
             const auto * column_function = typeid_cast<const ColumnFunction *>(column_with_type_and_name.column.get());
-
             if (!column_function)
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a function.", getName());
 
-            ColumnPtr offsets_column;
+            const auto & type_function = assert_cast<const DataTypeFunction &>(*arguments[0].type);
+            size_t num_function_arguments = type_function.getArgumentTypes().size();
 
+            ColumnPtr offsets_column;
             ColumnPtr column_first_array_ptr;
-            const typename Impl::column_type * column_first_array = nullptr;
+            const ColumnArray * column_first_array = nullptr;
 
             ColumnsWithTypeAndName arrays;
-            arrays.reserve(arguments.size() - 1);
+            arrays.reserve(arguments.size() - 1 - num_fixed_params);
 
+            bool is_single_array_argument = arguments.size() == num_fixed_params + 2;
             for (size_t i = 1 + num_fixed_params; i < arguments.size(); ++i)
             {
                 const auto & array_with_type_and_name = arguments[i];
 
-                ColumnPtr column_array_ptr = array_with_type_and_name.column;
-                const auto * column_array = checkAndGetColumn<typename Impl::column_type>(column_array_ptr.get());
+                auto column_array_ptr = array_with_type_and_name.column;
+                const auto * column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());
 
-                const DataTypePtr & array_type_ptr = array_with_type_and_name.type;
-                const auto * array_type = checkAndGetDataType<typename Impl::data_type>(array_type_ptr.get());
+                const auto & array_type_ptr = array_with_type_and_name.type;
+                const auto * array_type = checkAndGetDataType<DataTypeArray>(array_type_ptr.get());
 
                 if (!column_array)
                 {
-                    const ColumnConst * column_const_array = checkAndGetColumnConst<typename Impl::column_type>(column_array_ptr.get());
+                    const auto * column_const_array = checkAndGetColumnConst<ColumnArray>(column_array_ptr.get());
                     if (!column_const_array)
                         throw Exception(
-                            ErrorCodes::ILLEGAL_COLUMN, "Expected {} column, found {}", argument_type_name, column_array_ptr->getName());
+                            ErrorCodes::ILLEGAL_COLUMN, "Expected Array column, found {}", column_array_ptr->getName());
+
                     column_array_ptr = recursiveRemoveLowCardinality(column_const_array->convertToFullColumn());
-                    column_array = checkAndGetColumn<typename Impl::column_type>(column_array_ptr.get());
+                    column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());
                 }
 
                 if (!array_type)
                     throw Exception(
-                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Expected {} type, found {}", argument_type_name, array_type_ptr->getName());
+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Expected Array type, found {}", array_type_ptr->getName());
 
                 if (!offsets_column)
                 {
-                    offsets_column = getOffsetsPtr(*column_array);
+                    offsets_column = column_array->getOffsetsPtr();
                 }
                 else
                 {
                     /// The first condition is optimization: do not compare data if the pointers are equal.
-                    if (getOffsetsPtr(*column_array) != offsets_column
-                        && getOffsets(*column_array) != typeid_cast<const ColumnArray::ColumnOffsets &>(*offsets_column).getData())
+                    if (column_array->getOffsetsPtr() != offsets_column
+                        && column_array->getOffsets() != typeid_cast<const ColumnArray::ColumnOffsets &>(*offsets_column).getData())
                         throw Exception(
                             ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,
-                            "{}s passed to {} must have equal size",
-                            argument_type_name,
-                            getName());
+                                "Arrays passed to {} must have equal size", getName());
                 }
 
-                if (i == 1 + num_fixed_params)
+                const auto * column_tuple = checkAndGetColumn<ColumnTuple>(&column_array->getData());
+                if (is_single_array_argument && column_tuple && column_tuple->getColumns().size() == num_function_arguments)
                 {
-                    column_first_array_ptr = column_array_ptr;
-                    column_first_array = column_array;
-                }
+                    const auto & type_tuple = assert_cast<const DataTypeTuple &>(*array_type->getNestedType());
+                    const auto & tuple_names = type_tuple.getElementNames();
 
-                if constexpr (is_argument_type_map)
-                {
-                    arrays.emplace_back(ColumnWithTypeAndName(
-                        column_array->getNestedData().getColumnPtr(0), recursiveRemoveLowCardinality(array_type->getKeyType()), array_with_type_and_name.name+".key"));
-                    arrays.emplace_back(ColumnWithTypeAndName(
-                        column_array->getNestedData().getColumnPtr(1), recursiveRemoveLowCardinality(array_type->getValueType()), array_with_type_and_name.name+".value"));
+                    size_t tuple_size = column_tuple->getColumns().size();
+                    arrays.reserve(column_tuple->getColumns().size());
+                    for (size_t j = 0; j < tuple_size; ++j)
+                    {
+                        arrays.emplace_back(
+                            column_tuple->getColumnPtr(j),
+                            recursiveRemoveLowCardinality(type_tuple.getElement(j)),
+                            array_with_type_and_name.name + "." + tuple_names[j]);
+                    }
                 }
                 else
                 {
-                    arrays.emplace_back(ColumnWithTypeAndName(column_array->getDataPtr(),
-                                                            recursiveRemoveLowCardinality(array_type->getNestedType()),
-                                                            array_with_type_and_name.name));
+                    arrays.emplace_back(
+                        column_array->getDataPtr(),
+                        recursiveRemoveLowCardinality(array_type->getNestedType()),
+                        array_with_type_and_name.name);
+                }
+
+                if (i == 1 + num_fixed_params)
+                {
+                    column_first_array_ptr = column_array_ptr;
+                    column_first_array = column_array;
                 }
             }
 
             /// Put all the necessary columns multiplied by the sizes of arrays into the columns.
-            auto replicated_column_function_ptr = IColumn::mutate(column_function->replicate(getOffsets(*column_first_array)));
+            auto replicated_column_function_ptr = IColumn::mutate(column_function->replicate(column_first_array->getOffsets()));
             auto * replicated_column_function = typeid_cast<ColumnFunction *>(replicated_column_function_ptr.get());
             replicated_column_function->appendArguments(arrays);
 
diff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp
new file mode 100644
index 000000000000..853156fcafc0
--- /dev/null
+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp
@@ -0,0 +1,464 @@
+#include <Columns/ColumnArray.h>
+#include <Columns/ColumnFunction.h>
+#include <Columns/ColumnMap.h>
+#include <Columns/ColumnTuple.h>
+#include <Columns/ColumnConst.h>
+
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypeFunction.h>
+#include <DataTypes/DataTypeMap.h>
+#include <DataTypes/DataTypeTuple.h>
+
+#include <Functions/FunctionHelpers.h>
+#include <Functions/like.h>
+#include <Functions/array/arrayConcat.h>
+#include <Functions/array/arrayFilter.h>
+#include <Functions/array/arrayMap.h>
+#include <Functions/array/arraySort.h>
+#include <Functions/array/arrayIndex.h>
+#include <Functions/array/arrayExists.h>
+#include <Functions/array/arrayAll.h>
+#include <Functions/identity.h>
+#include <Functions/FunctionFactory.h>
+
+#include <base/map.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+}
+
+/** An adapter that allows to execute array* functions over Map types arguments.
+  * E.g. transform mapConcat to arrayConcat.
+  *
+  * Impl - the implementation of function that is applied
+  * to internal column of Map arguments (e.g. 'arrayConcat').
+  *
+  * Adapter - a struct that determines the way how to extract the internal array columns
+  * from Map arguments and possibly modify other columns.
+*/
+template <typename Impl, typename Adapter, typename Name>
+class FunctionMapToArrayAdapter : public IFunction
+{
+public:
+    static constexpr auto name = Name::name;
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionMapToArrayAdapter>(); }
+    String getName() const override { return name; }
+
+    bool isVariadic() const override { return impl.isVariadic(); }
+    size_t getNumberOfArguments() const override { return impl.getNumberOfArguments(); }
+    bool useDefaultImplementationForConstants() const override { return impl.useDefaultImplementationForConstants(); }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override  { return false; }
+
+    void getLambdaArgumentTypes(DataTypes & arguments) const override
+    {
+        Adapter::extractNestedTypes(arguments);
+        impl.getLambdaArgumentTypes(arguments);
+    }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        if (arguments.empty())
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                    "Function {} requires at least one argument, passed {}", getName(), arguments.size());
+
+        auto nested_arguments = arguments;
+        Adapter::extractNestedTypesAndColumns(nested_arguments);
+
+        constexpr bool impl_has_get_return_type = requires
+        {
+            impl.getReturnTypeImpl(nested_arguments);
+        };
+
+        /// If method is not overloaded in the implementation call default implementation
+        /// from IFunction. Here inheritance cannot be used for template parameterized field.
+        if constexpr (impl_has_get_return_type)
+            return Adapter::wrapType(impl.getReturnTypeImpl(nested_arguments));
+        else
+            return Adapter::wrapType(dynamic_cast<const IFunction &>(impl).getReturnTypeImpl(nested_arguments));
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+    {
+        auto nested_arguments = arguments;
+        Adapter::extractNestedTypesAndColumns(nested_arguments);
+        return Adapter::wrapColumn(impl.executeImpl(nested_arguments, Adapter::extractResultType(result_type), input_rows_count));
+    }
+
+private:
+    Impl impl;
+};
+
+
+template <typename Derived, typename Name>
+struct MapAdapterBase
+{
+    static void extractNestedTypes(DataTypes & types)
+    {
+        bool has_map_column = false;
+        for (auto & type : types)
+        {
+            if (const auto * type_map = typeid_cast<const DataTypeMap *>(type.get()))
+            {
+                has_map_column = true;
+                type = Derived::extractNestedType(*type_map);
+            }
+        }
+
+        if (!has_map_column)
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "Function {} requires at least one argument of type Map", Name::name);
+    }
+
+    static void extractNestedTypesAndColumns(ColumnsWithTypeAndName & arguments)
+    {
+        bool has_map_column = false;
+        for (auto & argument : arguments)
+        {
+            if (const auto * type_map = typeid_cast<const DataTypeMap *>(argument.type.get()))
+            {
+                has_map_column = true;
+                argument.type = Derived::extractNestedType(*type_map);
+
+                if (argument.column)
+                {
+                    if (const auto * const_map = checkAndGetColumnConstData<ColumnMap>(argument.column.get()))
+                        argument.column = ColumnConst::create(Derived::extractNestedColumn(*const_map), argument.column->size());
+                    else
+                        argument.column = Derived::extractNestedColumn(assert_cast<const ColumnMap &>(*argument.column));
+                }
+            }
+        }
+
+        if (!has_map_column)
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "Function {} requires at least one argument of type Map", Name::name);
+    }
+};
+
+/// Adapter that extracts nested Array(Tuple(key, value)) from Map columns.
+template <typename Name, bool returns_map = true>
+struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, returns_map>, Name>
+{
+    using MapAdapterBase<MapToNestedAdapter, Name>::extractNestedTypes;
+    using MapAdapterBase<MapToNestedAdapter, Name>::extractNestedTypesAndColumns;
+
+    static DataTypePtr extractNestedType(const DataTypeMap & type_map)
+    {
+        return type_map.getNestedTypeWithUnnamedTuple();
+    }
+
+    static ColumnPtr extractNestedColumn(const ColumnMap & column_map)
+    {
+        return column_map.getNestedColumnPtr();
+    }
+
+    static DataTypePtr extractResultType(const DataTypePtr & result_type)
+    {
+        if constexpr (returns_map)
+            return assert_cast<const DataTypeMap &>(*result_type).getNestedType();
+        return result_type;
+    }
+
+    static DataTypePtr wrapType(DataTypePtr type)
+    {
+        if constexpr (returns_map)
+            return std::make_shared<DataTypeMap>(std::move(type));
+        return type;
+    }
+
+    static ColumnPtr wrapColumn(ColumnPtr column)
+    {
+        if constexpr (returns_map)
+            return ColumnMap::create(std::move(column));
+        return column;
+    }
+};
+
+/// Adapter that extracts array with keys or values from Map columns.
+template <typename Name, size_t position>
+struct MapToSubcolumnAdapter : public MapAdapterBase<MapToSubcolumnAdapter<Name, position>, Name>
+{
+    static_assert(position <= 1);
+    using MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypes;
+    using MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypesAndColumns;
+
+    static DataTypePtr extractNestedType(const DataTypeMap & type_map)
+    {
+        const auto & array_type = assert_cast<const DataTypeArray &>(*type_map.getNestedType());
+        const auto & tuple_type = assert_cast<const DataTypeTuple &>(*array_type.getNestedType());
+        return std::make_shared<DataTypeArray>(tuple_type.getElement(position));
+    }
+
+    static ColumnPtr extractNestedColumn(const ColumnMap & column_map)
+    {
+        const auto & array_column = column_map.getNestedColumn();
+        const auto & tuple_column = column_map.getNestedData();
+        return ColumnArray::create(tuple_column.getColumnPtr(position), array_column.getOffsetsPtr());
+    }
+
+    static DataTypePtr extractResultType(const DataTypePtr & result_type) { return result_type; }
+    static DataTypePtr wrapType(DataTypePtr type) { return type; }
+    static ColumnPtr wrapColumn(ColumnPtr column) { return column; }
+};
+
+/// A special function that works like the following:
+/// mapKeyLike(pattern, key, value) <=> key LIKE pattern
+/// It is used to mimic lambda: (key, value) -> key LIKE pattern.
+class FunctionMapKeyLike : public IFunction
+{
+public:
+    String getName() const override { return "mapKeyLike"; }
+    size_t getNumberOfArguments() const override { return 3; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+    bool useDefaultImplementationForNulls() const override { return false; }
+
+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    {
+        DataTypes new_arguments{arguments[1], arguments[0]};
+        return impl.getReturnTypeImpl(new_arguments);
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
+    {
+        ColumnsWithTypeAndName new_arguments{arguments[1], arguments[0]};
+        return impl.executeImpl(new_arguments, result_type, input_rows_count);
+    }
+
+private:
+    FunctionLike impl;
+};
+
+/// Adapter for map*KeyLike functions.
+/// It extracts nested Array(Tuple(key, value)) from Map columns
+/// and prepares ColumnFunction as first argument which works
+/// like lambda (k, v) -> k LIKE pattern to pass it to the nested
+/// function derived from FunctionArrayMapped.
+template <typename Name, bool returns_map>
+struct MapKeyLikeAdapter
+{
+    static void checkTypes(const DataTypes & types)
+    {
+        if (types.size() != 2)
+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Number of arguments for function {} doesn't match: passed {}, should be 2",
+                Name::name, types.size());
+
+        const auto * map_type = checkAndGetDataType<DataTypeMap>(types[0].get());
+        if (!map_type)
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a Map", Name::name);
+
+        if (!isStringOrFixedString(types[1]))
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Second argument for function {} must be String or FixedString", Name::name);
+
+        if (!isStringOrFixedString(map_type->getKeyType()))
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Key type of map for function {} must be String or FixedString", Name::name);
+    }
+
+    static void extractNestedTypes(DataTypes & types)
+    {
+        checkTypes(types);
+        const auto & map_type = assert_cast<const DataTypeMap &>(*types[0]);
+
+        DataTypes lambda_argument_types{types[1], map_type.getKeyType(), map_type.getValueType()};
+        auto result_type = FunctionMapKeyLike().getReturnTypeImpl(lambda_argument_types);
+
+        DataTypes argument_types{map_type.getKeyType(), map_type.getValueType()};
+        auto function_type = std::make_shared<DataTypeFunction>(argument_types, result_type);
+
+        types = {function_type, types[0]};
+        MapToNestedAdapter<Name, returns_map>::extractNestedTypes(types);
+    }
+
+    static void extractNestedTypesAndColumns(ColumnsWithTypeAndName & arguments)
+    {
+        checkTypes(collections::map<DataTypes>(arguments, [](const auto & elem) { return elem.type; }));
+
+        const auto & map_type = assert_cast<const DataTypeMap &>(*arguments[0].type);
+        const auto & pattern_arg = arguments[1];
+
+        ColumnPtr function_column;
+        auto function = std::make_shared<FunctionMapKeyLike>();
+
+        DataTypes lambda_argument_types{pattern_arg.type, map_type.getKeyType(), map_type.getValueType()};
+        auto result_type = function->getReturnTypeImpl(lambda_argument_types);
+
+        DataTypes argument_types{map_type.getKeyType(), map_type.getValueType()};
+        auto function_type = std::make_shared<DataTypeFunction>(argument_types, result_type);
+
+        if (pattern_arg.column)
+        {
+            /// Here we create ColumnFunction with already captured pattern column.
+            /// Nested function will append keys and values column and it will work as desired lambda.
+            auto function_base = std::make_shared<FunctionToFunctionBaseAdaptor>(function, lambda_argument_types, result_type);
+            function_column = ColumnFunction::create(pattern_arg.column->size(), std::move(function_base), ColumnsWithTypeAndName{pattern_arg});
+        }
+
+        ColumnWithTypeAndName function_arg{function_column, function_type, "__function_map_key_like"};
+        arguments = {function_arg, arguments[0]};
+        MapToNestedAdapter<Name, returns_map>::extractNestedTypesAndColumns(arguments);
+    }
+
+    static DataTypePtr extractResultType(const DataTypePtr & result_type)
+    {
+        return MapToNestedAdapter<Name, returns_map>::extractResultType(result_type);
+    }
+
+    static DataTypePtr wrapType(DataTypePtr type)
+    {
+        return MapToNestedAdapter<Name, returns_map>::wrapType(std::move(type));
+    }
+
+    static ColumnPtr wrapColumn(ColumnPtr column)
+    {
+        return MapToNestedAdapter<Name, returns_map>::wrapColumn(std::move(column));
+    }
+};
+
+struct NameMapConcat { static constexpr auto name = "mapConcat"; };
+using FunctionMapConcat = FunctionMapToArrayAdapter<FunctionArrayConcat, MapToNestedAdapter<NameMapConcat>, NameMapConcat>;
+
+struct NameMapKeys { static constexpr auto name = "mapKeys"; };
+using FunctionMapKeys = FunctionMapToArrayAdapter<FunctionIdentity, MapToSubcolumnAdapter<NameMapKeys, 0>, NameMapKeys>;
+
+struct NameMapValues { static constexpr auto name = "mapValues"; };
+using FunctionMapValues = FunctionMapToArrayAdapter<FunctionIdentity, MapToSubcolumnAdapter<NameMapValues, 1>, NameMapValues>;
+
+struct NameMapContains { static constexpr auto name = "mapContains"; };
+using FunctionMapContains = FunctionMapToArrayAdapter<FunctionArrayIndex<HasAction, NameMapContains>, MapToSubcolumnAdapter<NameMapKeys, 0>, NameMapContains>;
+
+struct NameMapFilter { static constexpr auto name = "mapFilter"; };
+using FunctionMapFilter = FunctionMapToArrayAdapter<FunctionArrayFilter, MapToNestedAdapter<NameMapFilter>, NameMapFilter>;
+
+struct NameMapApply { static constexpr auto name = "mapApply"; };
+using FunctionMapApply = FunctionMapToArrayAdapter<FunctionArrayMap, MapToNestedAdapter<NameMapApply>, NameMapApply>;
+
+struct NameMapExists { static constexpr auto name = "mapExists"; };
+using FunctionMapExists = FunctionMapToArrayAdapter<FunctionArrayExists, MapToNestedAdapter<NameMapExists, false>, NameMapExists>;
+
+struct NameMapAll { static constexpr auto name = "mapAll"; };
+using FunctionMapAll = FunctionMapToArrayAdapter<FunctionArrayAll, MapToNestedAdapter<NameMapAll, false>, NameMapAll>;
+
+struct NameMapContainsKeyLike { static constexpr auto name = "mapContainsKeyLike"; };
+using FunctionMapContainsKeyLike = FunctionMapToArrayAdapter<FunctionArrayExists, MapKeyLikeAdapter<NameMapContainsKeyLike, false>, NameMapContainsKeyLike>;
+
+struct NameMapExtractKeyLike { static constexpr auto name = "mapExtractKeyLike"; };
+using FunctionMapExtractKeyLike = FunctionMapToArrayAdapter<FunctionArrayFilter, MapKeyLikeAdapter<NameMapExtractKeyLike, true>, NameMapExtractKeyLike>;
+
+struct NameMapSort { static constexpr auto name = "mapSort"; };
+struct NameMapReverseSort { static constexpr auto name = "mapReverseSort"; };
+struct NameMapPartialSort { static constexpr auto name = "mapPartialSort"; };
+struct NameMapPartialReverseSort { static constexpr auto name = "mapPartialReverseSort"; };
+
+using FunctionMapSort = FunctionMapToArrayAdapter<FunctionArraySort, MapToNestedAdapter<NameMapSort>, NameMapSort>;
+using FunctionMapReverseSort = FunctionMapToArrayAdapter<FunctionArrayReverseSort, MapToNestedAdapter<NameMapReverseSort>, NameMapReverseSort>;
+using FunctionMapPartialSort = FunctionMapToArrayAdapter<FunctionArrayPartialSort, MapToNestedAdapter<NameMapPartialSort>, NameMapPartialSort>;
+using FunctionMapPartialReverseSort = FunctionMapToArrayAdapter<FunctionArrayPartialReverseSort, MapToNestedAdapter<NameMapPartialReverseSort>, NameMapPartialReverseSort>;
+
+REGISTER_FUNCTION(MapMiscellaneous)
+{
+    factory.registerFunction<FunctionMapConcat>(
+    {
+        "The same as arrayConcat.",
+        Documentation::Examples{{"mapConcat", "SELECT mapConcat(map('k1', 'v1'), map('k2', 'v2'))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapKeys>(
+    {
+        "Returns an array with the keys of map.",
+        Documentation::Examples{{"mapKeys", "SELECT mapKeys(map('k1', 'v1', 'k2', 'v2'))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapValues>(
+    {
+        "Returns an array with the values of map.",
+        Documentation::Examples{{"mapValues", "SELECT mapValues(map('k1', 'v1', 'k2', 'v2'))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapContains>(
+    {
+        "Checks whether the map has the specified key.",
+        Documentation::Examples{{"mapContains", "SELECT mapContains(map('k1', 'v1', 'k2', 'v2'), 'k1')"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapFilter>(
+    {
+        "The same as arrayFilter.",
+        Documentation::Examples{{"mapFilter", "SELECT mapFilter((k, v) -> v > 1, map('k1', 1, 'k2', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapApply>(
+    {
+        "The same as arrayMap.",
+        Documentation::Examples{{"mapApply", "SELECT mapApply((k, v) -> (k, v * 2), map('k1', 1, 'k2', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapExists>(
+    {
+        "The same as arrayExists.",
+        Documentation::Examples{{"mapExists", "SELECT mapExists((k, v) -> v = 1, map('k1', 1, 'k2', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+     factory.registerFunction<FunctionMapAll>(
+    {
+        "The same as arrayAll.",
+        Documentation::Examples{{"mapAll", "SELECT mapAll((k, v) -> v = 1, map('k1', 1, 'k2', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapSort>(
+    {
+        "The same as arraySort.",
+        Documentation::Examples{{"mapSort", "SELECT mapSort((k, v) -> v, map('k1', 3, 'k2', 1, 'k3', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapReverseSort>(
+    {
+        "The same as arrayReverseSort.",
+        Documentation::Examples{{"mapReverseSort", "SELECT mapReverseSort((k, v) -> v, map('k1', 3, 'k2', 1, 'k3', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapPartialSort>(
+    {
+        "The same as arrayReverseSort.",
+        Documentation::Examples{{"mapPartialSort", "SELECT mapPartialSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapPartialReverseSort>(
+    {
+        "The same as arrayPartialReverseSort.",
+        Documentation::Examples{{"mapPartialReverseSort", "SELECT mapPartialReverseSort((k, v) -> v, 2, map('k1', 3, 'k2', 1, 'k3', 2))"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapContainsKeyLike>(
+    {
+        "Checks whether map contains key LIKE specified pattern.",
+        Documentation::Examples{{"mapContainsKeyLike", "SELECT mapContainsKeyLike(map('k1-1', 1, 'k2-1', 2), 'k1%')"}},
+        Documentation::Categories{"Map"},
+    });
+
+    factory.registerFunction<FunctionMapExtractKeyLike>(
+    {
+        "Returns a map with elements which key matches the specified pattern.",
+        Documentation::Examples{{"mapExtractKeyLike", "SELECT mapExtractKeyLike(map('k1-1', 1, 'k2-1', 2), 'k1%')"}},
+        Documentation::Categories{"Map"},
+    });
+}
+
+}
diff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp
index e13b5b1d2f1a..6a0010e4124d 100644
--- a/src/Functions/array/arrayAggregation.cpp
+++ b/src/Functions/array/arrayAggregation.cpp
@@ -96,9 +96,6 @@ using ArrayAggregateResult = typename ArrayAggregateResultImpl<ArrayElement, ope
 template<AggregateOperation aggregate_operation>
 struct ArrayAggregateImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayAll.cpp b/src/Functions/array/arrayAll.cpp
index 1d02342b704c..b3b0413f3bee 100644
--- a/src/Functions/array/arrayAll.cpp
+++ b/src/Functions/array/arrayAll.cpp
@@ -1,90 +1,67 @@
-#include <Columns/ColumnsNumber.h>
-#include <DataTypes/DataTypesNumber.h>
+#include <Functions/array/arrayAll.h>
 #include <Functions/FunctionFactory.h>
 
-#include "FunctionArrayMapped.h"
-
 namespace DB
 {
+
 namespace ErrorCodes
 {
     extern const int ILLEGAL_COLUMN;
 }
 
-/** arrayAll(x1,...,xn -> expression, array1,...,arrayn) - is the expression true for all elements of the array.
-  * An overload of the form f(array) is available, which works in the same way as f(x -> x, array).
-  */
-struct ArrayAllImpl
+ColumnPtr ArrayAllImpl::execute(const ColumnArray & array, ColumnPtr mapped)
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
+    const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
 
-    static bool needBoolean() { return true; }
-    static bool needExpression() { return false; }
-    static bool needOneArray() { return false; }
-
-    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & /*array_element*/)
+    if (!column_filter)
     {
-        return std::make_shared<DataTypeUInt8>();
-    }
+        const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
 
-    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)
-    {
-        const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
+        if (!column_filter_const)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
 
-        if (!column_filter)
+        if (column_filter_const->getValue<UInt8>())
+            return DataTypeUInt8().createColumnConst(array.size(), 1u);
+        else
         {
-            const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
-
-            if (!column_filter_const)
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
+            const IColumn::Offsets & offsets = array.getOffsets();
+            auto out_column = ColumnUInt8::create(offsets.size());
+            ColumnUInt8::Container & out_all = out_column->getData();
 
-            if (column_filter_const->getValue<UInt8>())
-                return DataTypeUInt8().createColumnConst(array.size(), 1u);
-            else
+            size_t pos = 0;
+            for (size_t i = 0; i < offsets.size(); ++i)
             {
-                const IColumn::Offsets & offsets = array.getOffsets();
-                auto out_column = ColumnUInt8::create(offsets.size());
-                ColumnUInt8::Container & out_all = out_column->getData();
-
-                size_t pos = 0;
-                for (size_t i = 0; i < offsets.size(); ++i)
-                {
-                    out_all[i] = offsets[i] == pos;
-                    pos = offsets[i];
-                }
-
-                return out_column;
+                out_all[i] = offsets[i] == pos;
+                pos = offsets[i];
             }
+
+            return out_column;
         }
+    }
 
-        const IColumn::Filter & filter = column_filter->getData();
-        const IColumn::Offsets & offsets = array.getOffsets();
-        auto out_column = ColumnUInt8::create(offsets.size());
-        ColumnUInt8::Container & out_all = out_column->getData();
+    const IColumn::Filter & filter = column_filter->getData();
+    const IColumn::Offsets & offsets = array.getOffsets();
+    auto out_column = ColumnUInt8::create(offsets.size());
+    ColumnUInt8::Container & out_all = out_column->getData();
 
-        size_t pos = 0;
-        for (size_t i = 0; i < offsets.size(); ++i)
+    size_t pos = 0;
+    for (size_t i = 0; i < offsets.size(); ++i)
+    {
+        UInt8 all = 1;
+        for (; pos < offsets[i]; ++pos)
         {
-            UInt8 all = 1;
-            for (; pos < offsets[i]; ++pos)
+            if (!filter[pos])
             {
-                if (!filter[pos])
-                {
-                    all = 0;
-                    pos = offsets[i];
-                    break;
-                }
+                all = 0;
+                pos = offsets[i];
+                break;
             }
-            out_all[i] = all;
         }
-
-        return out_column;
+        out_all[i] = all;
     }
-};
 
-struct NameArrayAll { static constexpr auto name = "arrayAll"; };
-using FunctionArrayAll = FunctionArrayMapped<ArrayAllImpl, NameArrayAll>;
+    return out_column;
+}
 
 REGISTER_FUNCTION(ArrayAll)
 {
@@ -92,5 +69,3 @@ REGISTER_FUNCTION(ArrayAll)
 }
 
 }
-
-
diff --git a/src/Functions/array/arrayAll.h b/src/Functions/array/arrayAll.h
new file mode 100644
index 000000000000..3d8d33576765
--- /dev/null
+++ b/src/Functions/array/arrayAll.h
@@ -0,0 +1,30 @@
+#pragma once
+
+#include <Columns/ColumnsNumber.h>
+#include <DataTypes/DataTypesNumber.h>
+#include "FunctionArrayMapped.h"
+
+namespace DB
+{
+
+/** arrayAll(x1,...,xn -> expression, array1,...,arrayn) - is the expression true for all elements of the array.
+  * An overload of the form f(array) is available, which works in the same way as f(x -> x, array).
+  */
+struct ArrayAllImpl
+{
+    static bool needBoolean() { return true; }
+    static bool needExpression() { return false; }
+    static bool needOneArray() { return false; }
+
+    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & /*array_element*/)
+    {
+        return std::make_shared<DataTypeUInt8>();
+    }
+
+    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped);
+};
+
+struct NameArrayAll { static constexpr auto name = "arrayAll"; };
+using FunctionArrayAll = FunctionArrayMapped<ArrayAllImpl, NameArrayAll>;
+
+}
diff --git a/src/Functions/array/arrayCompact.cpp b/src/Functions/array/arrayCompact.cpp
index 15df9f0d0082..7d09d1078d54 100644
--- a/src/Functions/array/arrayCompact.cpp
+++ b/src/Functions/array/arrayCompact.cpp
@@ -19,9 +19,6 @@ namespace ErrorCodes
 
 struct ArrayCompactImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayConcat.cpp b/src/Functions/array/arrayConcat.cpp
index c49565d7b239..cdb361b73b9b 100644
--- a/src/Functions/array/arrayConcat.cpp
+++ b/src/Functions/array/arrayConcat.cpp
@@ -1,4 +1,4 @@
-#include <Functions/IFunction.h>
+#include <Functions/array/arrayConcat.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/GatherUtils/GatherUtils.h>
 #include <DataTypes/DataTypeArray.h>
@@ -6,10 +6,8 @@
 #include <Interpreters/castColumn.h>
 #include <Columns/ColumnArray.h>
 #include <Columns/ColumnConst.h>
-#include <Common/typeid_cast.h>
 #include <base/range.h>
 
-
 namespace DB
 {
 
@@ -20,84 +18,66 @@ namespace ErrorCodes
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
-
-/// arrayConcat(arr1, ...) - concatenate arrays.
-class FunctionArrayConcat : public IFunction
+DataTypePtr FunctionArrayConcat::getReturnTypeImpl(const DataTypes & arguments) const
 {
-public:
-    static constexpr auto name = "arrayConcat";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayConcat>(); }
-
-    String getName() const override { return name; }
+    if (arguments.empty())
+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Function {} requires at least one argument.", getName());
 
-    bool isVariadic() const override { return true; }
-    size_t getNumberOfArguments() const override { return 0; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    for (auto i : collections::range(0, arguments.size()))
     {
-        if (arguments.empty())
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Function {} requires at least one argument.", getName());
+        const auto * array_type = typeid_cast<const DataTypeArray *>(arguments[i].get());
+        if (!array_type)
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                            "Argument {} for function {} must be an array but it has type {}.",
+                            i, getName(), arguments[i]->getName());
+    }
 
-        for (auto i : collections::range(0, arguments.size()))
-        {
-            const auto * array_type = typeid_cast<const DataTypeArray *>(arguments[i].get());
-            if (!array_type)
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                                "Argument {} for function {} must be an array but it has type {}.",
-                                i, getName(), arguments[i]->getName());
-        }
+    return getLeastSupertype(arguments);
+}
 
-        return getLeastSupertype(arguments);
-    }
+ColumnPtr FunctionArrayConcat::executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const
+{
+    if (result_type->onlyNull())
+        return result_type->createColumnConstWithDefaultValue(input_rows_count);
 
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
-    {
-        if (result_type->onlyNull())
-            return result_type->createColumnConstWithDefaultValue(input_rows_count);
+    size_t rows = input_rows_count;
+    size_t num_args = arguments.size();
 
-        size_t rows = input_rows_count;
-        size_t num_args = arguments.size();
+    Columns preprocessed_columns(num_args);
 
-        Columns preprocessed_columns(num_args);
+    for (size_t i = 0; i < num_args; ++i)
+    {
+        const ColumnWithTypeAndName & arg = arguments[i];
+        ColumnPtr preprocessed_column = arg.column;
 
-        for (size_t i = 0; i < num_args; ++i)
-        {
-            const ColumnWithTypeAndName & arg = arguments[i];
-            ColumnPtr preprocessed_column = arg.column;
+        if (!arg.type->equals(*result_type))
+            preprocessed_column = castColumn(arg, result_type);
 
-            if (!arg.type->equals(*result_type))
-                preprocessed_column = castColumn(arg, result_type);
+        preprocessed_columns[i] = std::move(preprocessed_column);
+    }
 
-            preprocessed_columns[i] = std::move(preprocessed_column);
-        }
+    std::vector<std::unique_ptr<GatherUtils::IArraySource>> sources;
 
-        std::vector<std::unique_ptr<GatherUtils::IArraySource>> sources;
+    for (auto & argument_column : preprocessed_columns)
+    {
+        bool is_const = false;
 
-        for (auto & argument_column : preprocessed_columns)
+        if (const auto * argument_column_const = typeid_cast<const ColumnConst *>(argument_column.get()))
         {
-            bool is_const = false;
-
-            if (const auto * argument_column_const = typeid_cast<const ColumnConst *>(argument_column.get()))
-            {
-                is_const = true;
-                argument_column = argument_column_const->getDataColumnPtr();
-            }
-
-            if (const auto * argument_column_array = typeid_cast<const ColumnArray *>(argument_column.get()))
-                sources.emplace_back(GatherUtils::createArraySource(*argument_column_array, is_const, rows));
-            else
-                throw Exception(ErrorCodes::LOGICAL_ERROR, "Arguments for function {} must be arrays.", getName());
+            is_const = true;
+            argument_column = argument_column_const->getDataColumnPtr();
         }
 
-        auto sink = GatherUtils::concat(sources);
-
-        return sink;
+        if (const auto * argument_column_array = typeid_cast<const ColumnArray *>(argument_column.get()))
+            sources.emplace_back(GatherUtils::createArraySource(*argument_column_array, is_const, rows));
+        else
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Arguments for function {} must be arrays.", getName());
     }
 
-    bool useDefaultImplementationForConstants() const override { return true; }
-};
+    auto sink = GatherUtils::concat(sources);
 
+    return sink;
+}
 
 REGISTER_FUNCTION(ArrayConcat)
 {
diff --git a/src/Functions/array/arrayConcat.h b/src/Functions/array/arrayConcat.h
new file mode 100644
index 000000000000..130d58b35f98
--- /dev/null
+++ b/src/Functions/array/arrayConcat.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include <Functions/IFunction.h>
+#include <Interpreters/Context_fwd.h>
+
+namespace DB
+{
+
+/// arrayConcat(arr1, ...) - concatenate arrays.
+class FunctionArrayConcat : public IFunction
+{
+public:
+    static constexpr auto name = "arrayConcat";
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayConcat>(); }
+
+    String getName() const override { return name; }
+
+    bool isVariadic() const override { return true; }
+    size_t getNumberOfArguments() const override { return 0; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override;
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override;
+
+    bool useDefaultImplementationForConstants() const override { return true; }
+};
+
+}
diff --git a/src/Functions/array/arrayCount.cpp b/src/Functions/array/arrayCount.cpp
index 9aeefbab4feb..019f07e8e6ae 100644
--- a/src/Functions/array/arrayCount.cpp
+++ b/src/Functions/array/arrayCount.cpp
@@ -17,9 +17,6 @@ namespace ErrorCodes
   */
 struct ArrayCountImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return true; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayCumSum.cpp b/src/Functions/array/arrayCumSum.cpp
index c91498ee50a0..7ad7b90cf0a6 100644
--- a/src/Functions/array/arrayCumSum.cpp
+++ b/src/Functions/array/arrayCumSum.cpp
@@ -18,9 +18,6 @@ namespace ErrorCodes
 
 struct ArrayCumSumImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayCumSumNonNegative.cpp b/src/Functions/array/arrayCumSumNonNegative.cpp
index 9a34ec12cd8c..cb21a853ea0a 100644
--- a/src/Functions/array/arrayCumSumNonNegative.cpp
+++ b/src/Functions/array/arrayCumSumNonNegative.cpp
@@ -19,9 +19,6 @@ namespace ErrorCodes
   */
 struct ArrayCumSumNonNegativeImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayDifference.cpp b/src/Functions/array/arrayDifference.cpp
index 9dcc730d4f61..857a88b82a2b 100644
--- a/src/Functions/array/arrayDifference.cpp
+++ b/src/Functions/array/arrayDifference.cpp
@@ -21,9 +21,6 @@ namespace ErrorCodes
   */
 struct ArrayDifferenceImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayExists.cpp b/src/Functions/array/arrayExists.cpp
index d80556b1475f..d59425338a5f 100644
--- a/src/Functions/array/arrayExists.cpp
+++ b/src/Functions/array/arrayExists.cpp
@@ -1,91 +1,67 @@
-#include <Columns/ColumnsNumber.h>
-#include <DataTypes/DataTypesNumber.h>
+#include <Functions/array/arrayExists.h>
 #include <Functions/FunctionFactory.h>
 
-#include "FunctionArrayMapped.h"
-
-
 namespace DB
 {
+
 namespace ErrorCodes
 {
     extern const int ILLEGAL_COLUMN;
 }
 
-/** arrayExists(x1,...,xn -> expression, array1,...,arrayn) - is the expression true for at least one array element.
-  * An overload of the form f(array) is available, which works in the same way as f(x -> x, array).
-  */
-struct ArrayExistsImpl
+ColumnPtr ArrayExistsImpl::execute(const ColumnArray & array, ColumnPtr mapped)
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
-    static bool needBoolean() { return true; }
-    static bool needExpression() { return false; }
-    static bool needOneArray() { return false; }
+    const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
 
-    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & /*array_element*/)
+    if (!column_filter)
     {
-        return std::make_shared<DataTypeUInt8>();
-    }
+        const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
 
-    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)
-    {
-        const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
+        if (!column_filter_const)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
 
-        if (!column_filter)
+        if (column_filter_const->getValue<UInt8>())
         {
-            const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
+            const IColumn::Offsets & offsets = array.getOffsets();
+            auto out_column = ColumnUInt8::create(offsets.size());
+            ColumnUInt8::Container & out_exists = out_column->getData();
 
-            if (!column_filter_const)
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
-
-            if (column_filter_const->getValue<UInt8>())
+            size_t pos = 0;
+            for (size_t i = 0; i < offsets.size(); ++i)
             {
-                const IColumn::Offsets & offsets = array.getOffsets();
-                auto out_column = ColumnUInt8::create(offsets.size());
-                ColumnUInt8::Container & out_exists = out_column->getData();
-
-                size_t pos = 0;
-                for (size_t i = 0; i < offsets.size(); ++i)
-                {
-                    out_exists[i] = offsets[i] - pos > 0;
-                    pos = offsets[i];
-                }
-
-                return out_column;
+                out_exists[i] = offsets[i] - pos > 0;
+                pos = offsets[i];
             }
-            else
-                return DataTypeUInt8().createColumnConst(array.size(), 0u);
+
+            return out_column;
         }
+        else
+            return DataTypeUInt8().createColumnConst(array.size(), 0u);
+    }
 
-        const IColumn::Filter & filter = column_filter->getData();
-        const IColumn::Offsets & offsets = array.getOffsets();
-        auto out_column = ColumnUInt8::create(offsets.size());
-        ColumnUInt8::Container & out_exists = out_column->getData();
+    const IColumn::Filter & filter = column_filter->getData();
+    const IColumn::Offsets & offsets = array.getOffsets();
+    auto out_column = ColumnUInt8::create(offsets.size());
+    ColumnUInt8::Container & out_exists = out_column->getData();
 
-        size_t pos = 0;
-        for (size_t i = 0; i < offsets.size(); ++i)
+    size_t pos = 0;
+    for (size_t i = 0; i < offsets.size(); ++i)
+    {
+        UInt8 exists = 0;
+        for (; pos < offsets[i]; ++pos)
         {
-            UInt8 exists = 0;
-            for (; pos < offsets[i]; ++pos)
+            if (filter[pos])
             {
-                if (filter[pos])
-                {
-                    exists = 1;
-                    pos = offsets[i];
-                    break;
-                }
+                exists = 1;
+                pos = offsets[i];
+                break;
             }
-            out_exists[i] = exists;
         }
-
-        return out_column;
+        out_exists[i] = exists;
     }
-};
 
-struct NameArrayExists { static constexpr auto name = "arrayExists"; };
-using FunctionArrayExists = FunctionArrayMapped<ArrayExistsImpl, NameArrayExists>;
+    return out_column;
+}
 
 REGISTER_FUNCTION(ArrayExists)
 {
@@ -93,5 +69,3 @@ REGISTER_FUNCTION(ArrayExists)
 }
 
 }
-
-
diff --git a/src/Functions/array/arrayExists.h b/src/Functions/array/arrayExists.h
new file mode 100644
index 000000000000..5b302ccb1508
--- /dev/null
+++ b/src/Functions/array/arrayExists.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include <Columns/ColumnsNumber.h>
+#include <DataTypes/DataTypesNumber.h>
+#include "FunctionArrayMapped.h"
+
+
+namespace DB
+{
+
+/** arrayExists(x1,...,xn -> expression, array1,...,arrayn) - is the expression true for at least one array element.
+  * An overload of the form f(array) is available, which works in the same way as f(x -> x, array).
+  */
+struct ArrayExistsImpl
+{
+    static bool needBoolean() { return true; }
+    static bool needExpression() { return false; }
+    static bool needOneArray() { return false; }
+
+    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & /*array_element*/)
+    {
+        return std::make_shared<DataTypeUInt8>();
+    }
+
+    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped);
+};
+
+struct NameArrayExists { static constexpr auto name = "arrayExists"; };
+using FunctionArrayExists = FunctionArrayMapped<ArrayExistsImpl, NameArrayExists>;
+
+}
diff --git a/src/Functions/array/arrayFill.cpp b/src/Functions/array/arrayFill.cpp
index b395584b8e26..89b5dce2331b 100644
--- a/src/Functions/array/arrayFill.cpp
+++ b/src/Functions/array/arrayFill.cpp
@@ -20,9 +20,6 @@ namespace ErrorCodes
 template <bool reverse>
 struct ArrayFillImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return true; }
     static bool needExpression() { return true; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayFilter.cpp b/src/Functions/array/arrayFilter.cpp
index 528fb7bc5c71..618abd93845c 100644
--- a/src/Functions/array/arrayFilter.cpp
+++ b/src/Functions/array/arrayFilter.cpp
@@ -1,78 +1,54 @@
-#include <Columns/ColumnsNumber.h>
-#include <DataTypes/DataTypesNumber.h>
+#include <Functions/array/arrayFilter.h>
 #include <Functions/FunctionFactory.h>
 
-#include "FunctionArrayMapped.h"
-
-
 namespace DB
 {
+
 namespace ErrorCodes
 {
     extern const int ILLEGAL_COLUMN;
 }
 
-/** arrayFilter(x -> predicate, array) - leave in the array only the elements for which the expression is true.
-  */
-struct ArrayFilterImpl
+ColumnPtr ArrayFilterImpl::execute(const ColumnArray & array, ColumnPtr mapped)
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
-    static bool needBoolean() { return true; }
-    static bool needExpression() { return true; }
-    static bool needOneArray() { return false; }
+    const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
 
-    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & array_element)
+    if (!column_filter)
     {
-        return std::make_shared<DataTypeArray>(array_element);
-    }
-
-    /// If there are several arrays, the first one is passed here.
-    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)
-    {
-        const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
-
-        if (!column_filter)
-        {
-            const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
+        const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
 
-            if (!column_filter_const)
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
+        if (!column_filter_const)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
 
-            if (column_filter_const->getValue<UInt8>())
-                return array.clone();
-            else
-                return ColumnArray::create(
-                    array.getDataPtr()->cloneEmpty(),
-                    ColumnArray::ColumnOffsets::create(array.size(), 0));
-        }
+        if (column_filter_const->getValue<UInt8>())
+            return array.clone();
+        else
+            return ColumnArray::create(
+                array.getDataPtr()->cloneEmpty(),
+                ColumnArray::ColumnOffsets::create(array.size(), 0));
+    }
 
-        const IColumn::Filter & filter = column_filter->getData();
-        ColumnPtr filtered = array.getData().filter(filter, -1);
+    const IColumn::Filter & filter = column_filter->getData();
+    ColumnPtr filtered = array.getData().filter(filter, -1);
 
-        const IColumn::Offsets & in_offsets = array.getOffsets();
-        auto column_offsets = ColumnArray::ColumnOffsets::create(in_offsets.size());
-        IColumn::Offsets & out_offsets = column_offsets->getData();
+    const IColumn::Offsets & in_offsets = array.getOffsets();
+    auto column_offsets = ColumnArray::ColumnOffsets::create(in_offsets.size());
+    IColumn::Offsets & out_offsets = column_offsets->getData();
 
-        size_t in_pos = 0;
-        size_t out_pos = 0;
-        for (size_t i = 0; i < in_offsets.size(); ++i)
+    size_t in_pos = 0;
+    size_t out_pos = 0;
+    for (size_t i = 0; i < in_offsets.size(); ++i)
+    {
+        for (; in_pos < in_offsets[i]; ++in_pos)
         {
-            for (; in_pos < in_offsets[i]; ++in_pos)
-            {
-                if (filter[in_pos])
-                    ++out_pos;
-            }
-            out_offsets[i] = out_pos;
+            if (filter[in_pos])
+                ++out_pos;
         }
-
-        return ColumnArray::create(filtered, std::move(column_offsets));
+        out_offsets[i] = out_pos;
     }
-};
 
-struct NameArrayFilter { static constexpr auto name = "arrayFilter"; };
-using FunctionArrayFilter = FunctionArrayMapped<ArrayFilterImpl, NameArrayFilter>;
+    return ColumnArray::create(filtered, std::move(column_offsets));
+}
 
 REGISTER_FUNCTION(ArrayFilter)
 {
@@ -80,5 +56,3 @@ REGISTER_FUNCTION(ArrayFilter)
 }
 
 }
-
-
diff --git a/src/Functions/array/arrayFilter.h b/src/Functions/array/arrayFilter.h
new file mode 100644
index 000000000000..f3a5a29e1d1d
--- /dev/null
+++ b/src/Functions/array/arrayFilter.h
@@ -0,0 +1,31 @@
+#pragma once
+
+#include <Columns/ColumnsNumber.h>
+#include <DataTypes/DataTypesNumber.h>
+#include "FunctionArrayMapped.h"
+
+
+namespace DB
+{
+
+/** arrayFilter(x -> predicate, array) - leave in the array only the elements for which the expression is true.
+  */
+struct ArrayFilterImpl
+{
+    static bool needBoolean() { return true; }
+    static bool needExpression() { return true; }
+    static bool needOneArray() { return false; }
+
+    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & array_element)
+    {
+        return std::make_shared<DataTypeArray>(array_element);
+    }
+
+    /// If there are several arrays, the first one is passed here.
+    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped);
+};
+
+struct NameArrayFilter { static constexpr auto name = "arrayFilter"; };
+using FunctionArrayFilter = FunctionArrayMapped<ArrayFilterImpl, NameArrayFilter>;
+
+}
diff --git a/src/Functions/array/arrayFirstLast.cpp b/src/Functions/array/arrayFirstLast.cpp
index 6a2700811697..055c2a0f79a2 100644
--- a/src/Functions/array/arrayFirstLast.cpp
+++ b/src/Functions/array/arrayFirstLast.cpp
@@ -28,9 +28,6 @@ enum class ArrayFirstLastElementNotExistsStrategy : uint8_t
 template <ArrayFirstLastStrategy strategy, ArrayFirstLastElementNotExistsStrategy element_not_exists_strategy>
 struct ArrayFirstLastImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return true; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayFirstLastIndex.cpp b/src/Functions/array/arrayFirstLastIndex.cpp
index f985075b1d8b..045558609a45 100644
--- a/src/Functions/array/arrayFirstLastIndex.cpp
+++ b/src/Functions/array/arrayFirstLastIndex.cpp
@@ -21,9 +21,6 @@ enum class ArrayFirstLastIndexStrategy
 template <ArrayFirstLastIndexStrategy strategy>
 struct ArrayFirstLastIndexImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return false; }
     static bool needExpression() { return true; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/array/arrayMap.cpp b/src/Functions/array/arrayMap.cpp
index 216d488a360c..10a7ca45cfab 100644
--- a/src/Functions/array/arrayMap.cpp
+++ b/src/Functions/array/arrayMap.cpp
@@ -1,44 +1,12 @@
+#include <Functions/array/arrayMap.h>
 #include <Functions/FunctionFactory.h>
 
-#include "FunctionArrayMapped.h"
-
-
 namespace DB
 {
 
-/** arrayMap(x1, ..., xn -> expression, array1, ..., arrayn) - apply the expression to each element of the array (or set of parallel arrays).
-  */
-struct ArrayMapImpl
-{
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
-    /// true if the expression (for an overload of f(expression, arrays)) or an array (for f(array)) should be boolean.
-    static bool needBoolean() { return false; }
-    /// true if the f(array) overload is unavailable.
-    static bool needExpression() { return true; }
-    /// true if the array must be exactly one.
-    static bool needOneArray() { return false; }
-
-    static DataTypePtr getReturnType(const DataTypePtr & expression_return, const DataTypePtr & /*array_element*/)
-    {
-        return std::make_shared<DataTypeArray>(expression_return);
-    }
-
-    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)
-    {
-        return ColumnArray::create(mapped->convertToFullColumnIfConst(), array.getOffsetsPtr());
-    }
-};
-
-struct NameArrayMap { static constexpr auto name = "arrayMap"; };
-using FunctionArrayMap = FunctionArrayMapped<ArrayMapImpl, NameArrayMap>;
-
 REGISTER_FUNCTION(ArrayMap)
 {
     factory.registerFunction<FunctionArrayMap>();
 }
 
 }
-
-
diff --git a/src/Functions/array/arrayMap.h b/src/Functions/array/arrayMap.h
new file mode 100644
index 000000000000..106b62a9c9ff
--- /dev/null
+++ b/src/Functions/array/arrayMap.h
@@ -0,0 +1,33 @@
+#pragma once
+#include "FunctionArrayMapped.h"
+
+
+namespace DB
+{
+
+/** arrayMap(x1, ..., xn -> expression, array1, ..., arrayn) - apply the expression to each element of the array (or set of parallel arrays).
+  */
+struct ArrayMapImpl
+{
+    /// true if the expression (for an overload of f(expression, arrays)) or an array (for f(array)) should be boolean.
+    static bool needBoolean() { return false; }
+    /// true if the f(array) overload is unavailable.
+    static bool needExpression() { return true; }
+    /// true if the array must be exactly one.
+    static bool needOneArray() { return false; }
+
+    static DataTypePtr getReturnType(const DataTypePtr & expression_return, const DataTypePtr & /*array_element*/)
+    {
+        return std::make_shared<DataTypeArray>(expression_return);
+    }
+
+    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)
+    {
+        return ColumnArray::create(mapped->convertToFullColumnIfConst(), array.getOffsetsPtr());
+    }
+};
+
+struct NameArrayMap { static constexpr auto name = "arrayMap"; };
+using FunctionArrayMap = FunctionArrayMapped<ArrayMapImpl, NameArrayMap>;
+
+}
diff --git a/src/Functions/array/arraySort.cpp b/src/Functions/array/arraySort.cpp
index 0188324bc198..b4593ec910c7 100644
--- a/src/Functions/array/arraySort.cpp
+++ b/src/Functions/array/arraySort.cpp
@@ -1,140 +1,85 @@
-#include "FunctionArrayMapped.h"
-
+#include <Functions/array/arraySort.h>
 #include <Functions/FunctionFactory.h>
-#include <base/sort.h>
 
 namespace DB
 {
 
 namespace ErrorCodes
 {
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
     extern const int LOGICAL_ERROR;
 }
 
-/** Sort arrays, by values of its elements, or by values of corresponding elements of calculated expression (known as "schwartzsort").
-  */
-template <bool positive, bool is_partial>
-struct ArraySortImpl
+namespace
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
 
-    static constexpr auto num_fixed_params = is_partial;
+template <bool positive>
+struct Less
+{
+    const IColumn & column;
 
-    static bool needBoolean() { return false; }
-    static bool needExpression() { return false; }
-    static bool needOneArray() { return false; }
+    explicit Less(const IColumn & column_) : column(column_) { }
 
-    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & array_element)
+    bool operator()(size_t lhs, size_t rhs) const
     {
-        return std::make_shared<DataTypeArray>(array_element);
+        if constexpr (positive)
+            return column.compareAt(lhs, rhs, column, 1) < 0;
+        else
+            return column.compareAt(lhs, rhs, column, -1) > 0;
     }
+};
 
-    struct Less
-    {
-        const IColumn & column;
-
-        explicit Less(const IColumn & column_) : column(column_) { }
-
-        bool operator()(size_t lhs, size_t rhs) const
-        {
-            if (positive)
-                return column.compareAt(lhs, rhs, column, 1) < 0;
-            else
-                return column.compareAt(lhs, rhs, column, -1) > 0;
-        }
-    };
-
-    static void checkArguments(const String & name, const ColumnWithTypeAndName * fixed_arguments)
-        requires(num_fixed_params)
-    {
-        if (!fixed_arguments)
-            throw Exception(
-                ErrorCodes::LOGICAL_ERROR,
-                "Expected fixed arguments to get the limit for partial array sort"
-            );
-        WhichDataType which(fixed_arguments[0].type.get());
-        if (!which.isUInt() && !which.isInt())
-            throw Exception(
-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                "Illegal type {} of limit argument of function {} (must be UInt or Int)",
-                fixed_arguments[0].type->getName(),
-                name);
-    }
+}
 
-    static ColumnPtr execute(
-        const ColumnArray & array,
-        ColumnPtr mapped,
-        const ColumnWithTypeAndName * fixed_arguments [[maybe_unused]] = nullptr)
+template <bool positive, bool is_partial>
+ColumnPtr ArraySortImpl<positive, is_partial>::execute(
+    const ColumnArray & array,
+    ColumnPtr mapped,
+    const ColumnWithTypeAndName * fixed_arguments)
+{
+    [[maybe_unused]] const auto limit = [&]() -> size_t
     {
-        [[maybe_unused]] const auto limit = [&]() -> size_t
+        if constexpr (is_partial)
         {
-            if constexpr (is_partial)
-            {
-                if (!fixed_arguments)
-                    throw Exception(
-                        ErrorCodes::LOGICAL_ERROR,
-                        "Expected fixed arguments to get the limit for partial array sort"
-                    );
-                return fixed_arguments[0].column.get()->getUInt(0);
-            }
-            return 0;
-        }();
+            if (!fixed_arguments)
+                throw Exception(
+                    ErrorCodes::LOGICAL_ERROR,
+                    "Expected fixed arguments to get the limit for partial array sort"
+                );
+            return fixed_arguments[0].column.get()->getUInt(0);
+        }
+        return 0;
+    }();
 
-        const ColumnArray::Offsets & offsets = array.getOffsets();
+    const ColumnArray::Offsets & offsets = array.getOffsets();
 
-        size_t size = offsets.size();
-        size_t nested_size = array.getData().size();
-        IColumn::Permutation permutation(nested_size);
+    size_t size = offsets.size();
+    size_t nested_size = array.getData().size();
+    IColumn::Permutation permutation(nested_size);
 
-        for (size_t i = 0; i < nested_size; ++i)
-            permutation[i] = i;
+    for (size_t i = 0; i < nested_size; ++i)
+        permutation[i] = i;
 
-        ColumnArray::Offset current_offset = 0;
-        for (size_t i = 0; i < size; ++i)
+    ColumnArray::Offset current_offset = 0;
+    for (size_t i = 0; i < size; ++i)
+    {
+        auto next_offset = offsets[i];
+        if constexpr (is_partial)
         {
-            auto next_offset = offsets[i];
-            if constexpr (is_partial)
+            if (limit)
             {
-                if (limit)
-                {
-                    const auto effective_limit = std::min<size_t>(limit, next_offset - current_offset);
-                    ::partial_sort(&permutation[current_offset], &permutation[current_offset + effective_limit], &permutation[next_offset], Less(*mapped));
-                }
-                else
-                    ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));
+                const auto effective_limit = std::min<size_t>(limit, next_offset - current_offset);
+                ::partial_sort(&permutation[current_offset], &permutation[current_offset + effective_limit], &permutation[next_offset], Less<positive>(*mapped));
             }
             else
-                ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));
-            current_offset = next_offset;
+                ::sort(&permutation[current_offset], &permutation[next_offset], Less<positive>(*mapped));
         }
-
-        return ColumnArray::create(array.getData().permute(permutation, 0), array.getOffsetsPtr());
+        else
+            ::sort(&permutation[current_offset], &permutation[next_offset], Less<positive>(*mapped));
+        current_offset = next_offset;
     }
-};
-
-struct NameArraySort
-{
-    static constexpr auto name = "arraySort";
-};
-struct NameArrayReverseSort
-{
-    static constexpr auto name = "arrayReverseSort";
-};
-struct NameArrayPartialSort
-{
-    static constexpr auto name = "arrayPartialSort";
-};
-struct NameArrayPartialReverseSort
-{
-    static constexpr auto name = "arrayPartialReverseSort";
-};
 
-using FunctionArraySort = FunctionArrayMapped<ArraySortImpl<true, false>, NameArraySort>;
-using FunctionArrayReverseSort = FunctionArrayMapped<ArraySortImpl<false, false>, NameArrayReverseSort>;
-using FunctionArrayPartialSort = FunctionArrayMapped<ArraySortImpl<true, true>, NameArrayPartialSort>;
-using FunctionArrayPartialReverseSort = FunctionArrayMapped<ArraySortImpl<false, true>, NameArrayPartialReverseSort>;
+    return ColumnArray::create(array.getData().permute(permutation, 0), array.getOffsetsPtr());
+}
 
 REGISTER_FUNCTION(ArraySort)
 {
diff --git a/src/Functions/array/arraySort.h b/src/Functions/array/arraySort.h
new file mode 100644
index 000000000000..a1ab376957d9
--- /dev/null
+++ b/src/Functions/array/arraySort.h
@@ -0,0 +1,79 @@
+#pragma once
+
+#include "FunctionArrayMapped.h"
+#include <base/sort.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int LOGICAL_ERROR;
+}
+
+
+/** Sort arrays, by values of its elements, or by values of corresponding elements of calculated expression (known as "schwartzsort").
+  */
+template <bool positive, bool is_partial>
+struct ArraySortImpl
+{
+    static constexpr auto num_fixed_params = is_partial;
+
+    static bool needBoolean() { return false; }
+    static bool needExpression() { return false; }
+    static bool needOneArray() { return false; }
+
+    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypePtr & array_element)
+    {
+        return std::make_shared<DataTypeArray>(array_element);
+    }
+
+    static void checkArguments(
+        const String & name,
+        const ColumnWithTypeAndName * fixed_arguments)
+        requires(num_fixed_params)
+    {
+        if (!fixed_arguments)
+            throw Exception(
+                ErrorCodes::LOGICAL_ERROR,
+                "Expected fixed arguments to get the limit for partial array sort");
+
+        WhichDataType which(fixed_arguments[0].type.get());
+        if (!which.isUInt() && !which.isInt())
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "Illegal type {} of limit argument of function {} (must be UInt or Int)",
+                fixed_arguments[0].type->getName(),
+                name);
+    }
+
+    static ColumnPtr execute(
+        const ColumnArray & array,
+        ColumnPtr mapped,
+        const ColumnWithTypeAndName * fixed_arguments [[maybe_unused]] = nullptr);
+};
+
+struct NameArraySort
+{
+    static constexpr auto name = "arraySort";
+};
+struct NameArrayReverseSort
+{
+    static constexpr auto name = "arrayReverseSort";
+};
+struct NameArrayPartialSort
+{
+    static constexpr auto name = "arrayPartialSort";
+};
+struct NameArrayPartialReverseSort
+{
+    static constexpr auto name = "arrayPartialReverseSort";
+};
+
+using FunctionArraySort = FunctionArrayMapped<ArraySortImpl<true, false>, NameArraySort>;
+using FunctionArrayReverseSort = FunctionArrayMapped<ArraySortImpl<false, false>, NameArrayReverseSort>;
+using FunctionArrayPartialSort = FunctionArrayMapped<ArraySortImpl<true, true>, NameArrayPartialSort>;
+using FunctionArrayPartialReverseSort = FunctionArrayMapped<ArraySortImpl<false, true>, NameArrayPartialReverseSort>;
+
+}
diff --git a/src/Functions/array/arraySplit.cpp b/src/Functions/array/arraySplit.cpp
index dd1cfc64c1b1..e68d779f67e6 100644
--- a/src/Functions/array/arraySplit.cpp
+++ b/src/Functions/array/arraySplit.cpp
@@ -15,9 +15,6 @@ namespace ErrorCodes
 template <bool reverse>
 struct ArraySplitImpl
 {
-    using column_type = ColumnArray;
-    using data_type = DataTypeArray;
-
     static bool needBoolean() { return true; }
     static bool needExpression() { return true; }
     static bool needOneArray() { return false; }
diff --git a/src/Functions/identity.cpp b/src/Functions/identity.cpp
index 8a29eafca524..7174f1fd3188 100644
--- a/src/Functions/identity.cpp
+++ b/src/Functions/identity.cpp
@@ -1,38 +1,8 @@
-#include <Functions/IFunction.h>
+#include <Functions/identity.h>
 #include <Functions/FunctionFactory.h>
 
-
 namespace DB
 {
-namespace
-{
-
-class FunctionIdentity : public IFunction
-{
-public:
-    static constexpr auto name = "identity";
-    static FunctionPtr create(ContextPtr)
-    {
-        return std::make_shared<FunctionIdentity>();
-    }
-
-    String getName() const override { return name; }
-    size_t getNumberOfArguments() const override { return 1; }
-    bool isSuitableForConstantFolding() const override { return false; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
-
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
-    {
-        return arguments.front();
-    }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
-    {
-        return arguments.front().column;
-    }
-};
-
-}
 
 REGISTER_FUNCTION(Identity)
 {
diff --git a/src/Functions/identity.h b/src/Functions/identity.h
new file mode 100644
index 000000000000..efee95841f53
--- /dev/null
+++ b/src/Functions/identity.h
@@ -0,0 +1,31 @@
+#pragma once
+#include <Functions/IFunction.h>
+#include <Interpreters/Context_fwd.h>
+
+
+namespace DB
+{
+
+class FunctionIdentity : public IFunction
+{
+public:
+    static constexpr auto name = "identity";
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIdentity>(); }
+
+    String getName() const override { return name; }
+    size_t getNumberOfArguments() const override { return 1; }
+    bool isSuitableForConstantFolding() const override { return false; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+
+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
+    {
+        return arguments.front();
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
+    {
+        return arguments.front().column;
+    }
+};
+
+}
diff --git a/src/Functions/map.cpp b/src/Functions/map.cpp
index 6b9d22591be6..c950a0491a5b 100644
--- a/src/Functions/map.cpp
+++ b/src/Functions/map.cpp
@@ -2,22 +2,12 @@
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
 #include <DataTypes/DataTypeMap.h>
-#include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/DataTypesNumber.h>
-#include <DataTypes/DataTypeFixedString.h>
-#include <Columns/ColumnMap.h>
-#include <Columns/ColumnArray.h>
-#include <Columns/ColumnString.h>
-#include <Columns/ColumnsNumber.h>
+#include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/getLeastSupertype.h>
+#include <Columns/ColumnMap.h>
 #include <Interpreters/castColumn.h>
-#include <memory>
-
-#include <Common/assert_cast.h>
-#include <Common/typeid_cast.h>
-#include "array/arrayIndex.h"
-#include "Functions/like.h"
-#include "Functions/FunctionsStringSearch.h"
 #include <Common/HashTable/HashSet.h>
 
 
@@ -239,372 +229,6 @@ class FunctionMapFromArrays : public IFunction
     }
 };
 
-struct NameMapContains { static constexpr auto name = "mapContains"; };
-
-class FunctionMapContains : public IFunction
-{
-public:
-    static constexpr auto name = NameMapContains::name;
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionMapContains>(); }
-
-    String getName() const override
-    {
-        return NameMapContains::name;
-    }
-
-    size_t getNumberOfArguments() const override { return impl.getNumberOfArguments(); }
-
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override
-    {
-        return impl.isSuitableForShortCircuitArgumentsExecution(arguments);
-    }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        return impl.getReturnTypeImpl(arguments);
-    }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
-    {
-        return impl.executeImpl(arguments, result_type, input_rows_count);
-    }
-
-private:
-    FunctionArrayIndex<HasAction, NameMapContains> impl;
-};
-
-
-class FunctionMapKeys : public IFunction
-{
-public:
-    static constexpr auto name = "mapKeys";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionMapKeys>(); }
-
-    String getName() const override
-    {
-        return name;
-    }
-
-    size_t getNumberOfArguments() const override { return 1; }
-
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        if (arguments.size() != 1)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                "Number of arguments for function {} doesn't match: passed {}, should be 1",
-                getName(), arguments.size());
-
-        const DataTypeMap * map_type = checkAndGetDataType<DataTypeMap>(arguments[0].type.get());
-
-        if (!map_type)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a map", getName());
-
-        auto key_type = map_type->getKeyType();
-
-        return std::make_shared<DataTypeArray>(key_type);
-    }
-
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t /*input_rows_count*/) const override
-    {
-        const ColumnMap * col_map = typeid_cast<const ColumnMap *>(arguments[0].column.get());
-        if (!col_map)
-            return nullptr;
-
-        const auto & nested_column = col_map->getNestedColumn();
-        const auto & keys_data = col_map->getNestedData().getColumn(0);
-
-        return ColumnArray::create(keys_data.getPtr(), nested_column.getOffsetsPtr());
-    }
-};
-
-
-class FunctionMapValues : public IFunction
-{
-public:
-    static constexpr auto name = "mapValues";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionMapValues>(); }
-
-    String getName() const override
-    {
-        return name;
-    }
-
-    size_t getNumberOfArguments() const override { return 1; }
-
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        if (arguments.size() != 1)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                "Number of arguments for function {} doesn't match: passed {}, should be 1",
-                getName(), arguments.size());
-
-        const DataTypeMap * map_type = checkAndGetDataType<DataTypeMap>(arguments[0].type.get());
-
-        if (!map_type)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a map", getName());
-
-        auto value_type = map_type->getValueType();
-
-        return std::make_shared<DataTypeArray>(value_type);
-    }
-
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t /*input_rows_count*/) const override
-    {
-        const ColumnMap * col_map = typeid_cast<const ColumnMap *>(arguments[0].column.get());
-        if (!col_map)
-            return nullptr;
-
-        const auto & nested_column = col_map->getNestedColumn();
-        const auto & values_data = col_map->getNestedData().getColumn(1);
-
-        return ColumnArray::create(values_data.getPtr(), nested_column.getOffsetsPtr());
-    }
-};
-
-class FunctionMapContainsKeyLike : public IFunction
-{
-public:
-    static constexpr auto name = "mapContainsKeyLike";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionMapContainsKeyLike>(); }
-    String getName() const override { return name; }
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*info*/) const override { return true; }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
-    {
-        bool is_const = isColumnConst(*arguments[0].column);
-        const ColumnMap * col_map = is_const ? checkAndGetColumnConstData<ColumnMap>(arguments[0].column.get())
-                                             : checkAndGetColumn<ColumnMap>(arguments[0].column.get());
-        const DataTypeMap * map_type = checkAndGetDataType<DataTypeMap>(arguments[0].type.get());
-        if (!col_map || !map_type)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a map", getName());
-
-        auto col_res = ColumnVector<UInt8>::create();
-        typename ColumnVector<UInt8>::Container & vec_res = col_res->getData();
-
-        if (input_rows_count == 0)
-            return col_res;
-
-        vec_res.resize(input_rows_count);
-
-        const auto & column_array = typeid_cast<const ColumnArray &>(col_map->getNestedColumn());
-        const auto & column_tuple = typeid_cast<const ColumnTuple &>(column_array.getData());
-
-        const ColumnString * column_string = checkAndGetColumn<ColumnString>(column_tuple.getColumn(0));
-        const ColumnFixedString * column_fixed_string = checkAndGetColumn<ColumnFixedString>(column_tuple.getColumn(0));
-
-        FunctionLike func_like;
-
-        for (size_t row = 0; row < input_rows_count; ++row)
-        {
-            size_t element_start_row = row != 0 ? column_array.getOffsets()[row-1] : 0;
-            size_t elem_size = column_array.getOffsets()[row]- element_start_row;
-
-            ColumnPtr sub_map_column;
-            DataTypePtr data_type;
-
-            //The keys of one row map will be processed as a single ColumnString
-            if (column_string)
-            {
-               sub_map_column = column_string->cut(element_start_row, elem_size);
-               data_type = std::make_shared<DataTypeString>();
-            }
-            else
-            {
-               sub_map_column = column_fixed_string->cut(element_start_row, elem_size);
-               data_type = std::make_shared<DataTypeFixedString>(checkAndGetColumn<ColumnFixedString>(sub_map_column.get())->getN());
-            }
-
-            size_t col_key_size = sub_map_column->size();
-            auto column = is_const ? ColumnConst::create(std::move(sub_map_column), std::move(col_key_size)) : std::move(sub_map_column);
-
-            ColumnsWithTypeAndName new_arguments =
-                {
-                    {
-                        column,
-                        data_type,
-                        ""
-                    },
-                    arguments[1]
-                };
-
-            auto res = func_like.executeImpl(new_arguments, result_type, input_rows_count);
-            const auto & container = checkAndGetColumn<ColumnUInt8>(res.get())->getData();
-
-            const auto it = std::find_if(container.begin(), container.end(), [](int element){ return element == 1; });  // NOLINT
-            vec_res[row] = it == container.end() ? 0 : 1;
-        }
-
-        return col_res;
-    }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        if (arguments.size() != 2)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                            "Number of arguments for function {} doesn't match: passed {}, should be 2",
-                            getName(), arguments.size());
-
-        const DataTypeMap * map_type = checkAndGetDataType<DataTypeMap>(arguments[0].type.get());
-        const DataTypeString * pattern_type = checkAndGetDataType<DataTypeString>(arguments[1].type.get());
-
-        if (!map_type)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a Map", getName());
-        if (!pattern_type)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Second argument for function {} must be String", getName());
-
-        if (!isStringOrFixedString(map_type->getKeyType()))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Key type of map for function {} must be `String` or `FixedString`", getName());
-
-        return std::make_shared<DataTypeUInt8>();
-    }
-
-    size_t getNumberOfArguments() const override { return 2; }
-
-    bool useDefaultImplementationForConstants() const override { return true; }
-};
-
-class FunctionExtractKeyLike : public IFunction
-{
-public:
-    static constexpr auto name = "mapExtractKeyLike";
-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionExtractKeyLike>(); }
-
-    String getName() const override
-    {
-        return name;
-    }
-
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*info*/) const override { return true; }
-
-    size_t getNumberOfArguments() const override { return 2; }
-
-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
-    {
-        if (arguments.size() != 2)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                "Number of arguments for function {} doesn't match: passed {}, should be 2",
-                getName(), arguments.size());
-
-
-        const DataTypeMap * map_type = checkAndGetDataType<DataTypeMap>(arguments[0].type.get());
-
-        if (!map_type)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "First argument for function {} must be a map", getName());
-
-
-        auto key_type = map_type->getKeyType();
-
-        WhichDataType which(key_type);
-
-        if (!which.isStringOrFixedString())
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Function {}only support the map with String or FixedString key",
-                getName());
-
-        if (!isStringOrFixedString(arguments[1].type))
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Second argument passed to function {} must be String or FixedString", getName());
-
-        return std::make_shared<DataTypeMap>(map_type->getKeyType(), map_type->getValueType());
-    }
-
-    bool useDefaultImplementationForConstants() const override { return true; }
-
-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
-    {
-        bool is_const = isColumnConst(*arguments[0].column);
-        const ColumnMap * col_map = typeid_cast<const ColumnMap *>(arguments[0].column.get());
-
-        //It may not be necessary to check this condition, cause it will be checked in getReturnTypeImpl function
-        if (!col_map)
-            return nullptr;
-
-        const DataTypeMap * map_type = checkAndGetDataType<DataTypeMap>(arguments[0].type.get());
-        auto key_type = map_type->getKeyType();
-        auto value_type = map_type->getValueType();
-
-        const auto & nested_column = col_map->getNestedColumn();
-        const auto & keys_column = col_map->getNestedData().getColumn(0);
-        const auto & values_column = col_map->getNestedData().getColumn(1);
-        const ColumnString * keys_string_column = checkAndGetColumn<ColumnString>(keys_column);
-        const ColumnFixedString * keys_fixed_string_column = checkAndGetColumn<ColumnFixedString>(keys_column);
-
-        FunctionLike func_like;
-
-        //create result data
-        MutableColumnPtr keys_data = key_type->createColumn();
-        MutableColumnPtr values_data = value_type->createColumn();
-        MutableColumnPtr offsets = DataTypeNumber<IColumn::Offset>().createColumn();
-
-        IColumn::Offset current_offset = 0;
-
-        for (size_t row = 0; row < input_rows_count; ++row)
-        {
-            size_t element_start_row = row != 0 ? nested_column.getOffsets()[row-1] : 0;
-            size_t element_size = nested_column.getOffsets()[row]- element_start_row;
-
-            ColumnsWithTypeAndName new_arguments;
-            ColumnPtr sub_map_column;
-            DataTypePtr data_type;
-
-            if (keys_string_column)
-            {
-                sub_map_column = keys_string_column->cut(element_start_row, element_size);
-                data_type = std::make_shared<DataTypeString>();
-            }
-            else
-            {
-                sub_map_column = keys_fixed_string_column->cut(element_start_row, element_size);
-                data_type =std::make_shared<DataTypeFixedString>(checkAndGetColumn<ColumnFixedString>(sub_map_column.get())->getN());
-            }
-
-            size_t col_key_size = sub_map_column->size();
-            auto column = is_const? ColumnConst::create(std::move(sub_map_column), std::move(col_key_size)) : std::move(sub_map_column);
-
-            new_arguments = {
-                    {
-                        column,
-                        data_type,
-                        ""
-                        },
-                    arguments[1]
-                    };
-
-            auto res = func_like.executeImpl(new_arguments, result_type, input_rows_count);
-            const auto & container = checkAndGetColumn<ColumnUInt8>(res.get())->getData();
-
-            for (size_t row_num = 0; row_num < element_size; ++row_num)
-            {
-                if (container[row_num] == 1)
-                {
-                    auto key_ref = keys_string_column ?
-                                   keys_string_column->getDataAt(element_start_row + row_num) :
-                                   keys_fixed_string_column->getDataAt(element_start_row + row_num);
-                    auto value_ref = values_column.getDataAt(element_start_row + row_num);
-
-                    keys_data->insertData(key_ref.data, key_ref.size);
-                    values_data->insertData(value_ref.data, value_ref.size);
-                    current_offset += 1;
-                }
-            }
-
-            offsets->insert(current_offset);
-        }
-
-        auto result_nested_column = ColumnArray::create(
-            ColumnTuple::create(Columns{std::move(keys_data), std::move(values_data)}),
-            std::move(offsets));
-
-        return ColumnMap::create(result_nested_column);
-    }
-};
-
 class FunctionMapUpdate : public IFunction
 {
 public:
@@ -747,15 +371,9 @@ class FunctionMapUpdate : public IFunction
 REGISTER_FUNCTION(Map)
 {
     factory.registerFunction<FunctionMap>();
-    factory.registerFunction<FunctionMapContains>();
-    factory.registerFunction<FunctionMapKeys>();
-    factory.registerFunction<FunctionMapValues>();
-    factory.registerFunction<FunctionMapContainsKeyLike>();
-    factory.registerFunction<FunctionExtractKeyLike>();
     factory.registerFunction<FunctionMapUpdate>();
     factory.registerFunction<FunctionMapFromArrays>();
     factory.registerAlias("MAP_FROM_ARRAYS", "mapFromArrays");
-
 }
 
 }
diff --git a/src/Functions/mapFilter.cpp b/src/Functions/mapFilter.cpp
deleted file mode 100644
index 038e3bb3ce01..000000000000
--- a/src/Functions/mapFilter.cpp
+++ /dev/null
@@ -1,144 +0,0 @@
-#include <Columns/ColumnMap.h>
-#include <Columns/ColumnTuple.h>
-#include <Columns/ColumnsNumber.h>
-#include <DataTypes/DataTypeTuple.h>
-#include <Functions/FunctionFactory.h>
-#include <Functions/FunctionHelpers.h>
-#include <Functions/array/FunctionArrayMapped.h>
-
-
-namespace DB
-{
-
-namespace ErrorCodes
-{
-    extern const int ILLEGAL_COLUMN;
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
-}
-
-/** Higher-order functions for map.
-  * These functions optionally apply a map by lambda function,
-  *  and return some result based on that transformation.
-  */
-
-
-/** mapFilter((k, v) -> predicate, map) - leave in the map only the kv elements for which the expression is true.
-  */
-struct MapFilterImpl
-{
-    using data_type = DataTypeMap;
-    using column_type = ColumnMap;
-
-    static constexpr auto name = "mapFilter";
-
-    static bool needBoolean() { return true; }
-    static bool needExpression() { return true; }
-    static bool needOneArray() { return true; }
-
-    static DataTypePtr getReturnType(const DataTypePtr & /*expression_return*/, const DataTypes & elems)
-    {
-        return std::make_shared<DataTypeMap>(elems);
-    }
-
-    /// If there are several arrays, the first one is passed here.
-    static ColumnPtr execute(const ColumnMap & map_column, ColumnPtr mapped)
-    {
-        const ColumnUInt8 * column_filter = typeid_cast<const ColumnUInt8 *>(&*mapped);
-
-        if (!column_filter)
-        {
-            const auto * column_filter_const = checkAndGetColumnConst<ColumnUInt8>(&*mapped);
-
-            if (!column_filter_const)
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Unexpected type of filter column");
-
-            if (column_filter_const->getValue<UInt8>())
-                return map_column.clone();
-            else
-            {
-                const auto * column_array = typeid_cast<const ColumnArray *>(map_column.getNestedColumnPtr().get());
-                const auto * column_tuple = typeid_cast<const ColumnTuple *>(column_array->getDataPtr().get());
-                ColumnPtr keys = column_tuple->getColumnPtr(0)->cloneEmpty();
-                ColumnPtr values = column_tuple->getColumnPtr(1)->cloneEmpty();
-                return ColumnMap::create(keys, values, ColumnArray::ColumnOffsets::create(map_column.size(), 0));
-            }
-        }
-
-        const IColumn::Filter & filter = column_filter->getData();
-        ColumnPtr filtered = map_column.getNestedColumn().getData().filter(filter, -1);
-
-        const IColumn::Offsets & in_offsets = map_column.getNestedColumn().getOffsets();
-        auto column_offsets = ColumnArray::ColumnOffsets::create(in_offsets.size());
-        IColumn::Offsets & out_offsets = column_offsets->getData();
-
-        size_t in_pos = 0;
-        size_t out_pos = 0;
-        for (size_t i = 0; i < in_offsets.size(); ++i)
-        {
-            for (; in_pos < in_offsets[i]; ++in_pos)
-            {
-                if (filter[in_pos])
-                    ++out_pos;
-            }
-            out_offsets[i] = out_pos;
-        }
-
-        return ColumnMap::create(ColumnArray::create(filtered, std::move(column_offsets)));
-    }
-};
-
-
-/** mapApply((k,v) -> expression, map) - apply the expression to the map.
-  */
-struct MapApplyImpl
-{
-    using data_type = DataTypeMap;
-    using column_type = ColumnMap;
-
-    static constexpr auto name = "mapApply";
-
-    /// true if the expression (for an overload of f(expression, maps)) or a map (for f(map)) should be boolean.
-    static bool needBoolean() { return false; }
-    static bool needExpression() { return true; }
-    static bool needOneArray() { return true; }
-
-    static DataTypePtr getReturnType(const DataTypePtr & expression_return, const DataTypes & /*elems*/)
-    {
-        const auto * tuple_types = typeid_cast<const DataTypeTuple *>(expression_return.get());
-        if (!tuple_types)
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                            "Expected return type is tuple, got {}", expression_return->getName());
-        if (tuple_types->getElements().size() != 2)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                            "Expected 2 columns as map's key and value, but found {}", tuple_types->getElements().size());
-
-        return std::make_shared<DataTypeMap>(tuple_types->getElements());
-    }
-
-    static ColumnPtr execute(const ColumnMap & map, ColumnPtr mapped)
-    {
-        const auto * column_tuple = checkAndGetColumn<ColumnTuple>(mapped.get());
-        if (!column_tuple)
-        {
-            const ColumnConst * column_const_tuple = checkAndGetColumnConst<ColumnTuple>(mapped.get());
-            if (!column_const_tuple)
-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Expected tuple column, found {}", mapped->getName());
-            auto cols = convertConstTupleToConstantElements(*column_const_tuple);
-            return ColumnMap::create(cols[0]->convertToFullColumnIfConst(), cols[1]->convertToFullColumnIfConst(), map.getNestedColumn().getOffsetsPtr());
-        }
-
-        return ColumnMap::create(column_tuple->getColumnPtr(0), column_tuple->getColumnPtr(1),
-            map.getNestedColumn().getOffsetsPtr());
-    }
-};
-
-REGISTER_FUNCTION(MapApply)
-{
-    factory.registerFunction<FunctionArrayMapped<MapFilterImpl, MapFilterImpl>>();
-    factory.registerFunction<FunctionArrayMapped<MapApplyImpl, MapApplyImpl>>();
-}
-
-}
-
-
