diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp
index 1c450d531d6a..2ea9369f4762 100644
--- a/src/Interpreters/HashJoin.cpp
+++ b/src/Interpreters/HashJoin.cpp
@@ -1095,7 +1095,7 @@ IColumn::Filter dictionaryJoinRightColumns(const TableJoin & table_join, AddedCo
                 std::move(key_getter), nullptr, added_columns, null_map, flags);
     }
 
-    throw Exception("Logical error: wrong JOIN combination", ErrorCodes::LOGICAL_ERROR);
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Wrong JOIN combination: {} {}", STRICTNESS, KIND);
 }
 
 } /// nameless
@@ -1414,13 +1414,13 @@ void HashJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)
                     joinBlockImpl<Kind::Left, Strictness::Anti>(block, key_names_left, sample_block_with_columns_to_add, map);
                     break;
                 default:
-                    throw Exception("Logical error: wrong JOIN combination", ErrorCodes::LOGICAL_ERROR);
+                    throw Exception(ErrorCodes::LOGICAL_ERROR, "Wrong JOIN combination: dictionary + {} {}", strictness, kind);
             }
         }
         else if (kind == Kind::Inner && strictness == Strictness::All)
             joinBlockImpl<Kind::Left, Strictness::Semi>(block, key_names_left, sample_block_with_columns_to_add, map);
         else
-            throw Exception("Logical error: wrong JOIN combination", ErrorCodes::LOGICAL_ERROR);
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Wrong JOIN combination: dictionary + {} {}", strictness, kind);
     }
     else if (joinDispatch(kind, strictness, data->maps, [&](auto kind_, auto strictness_, auto & map)
         {
@@ -1432,7 +1432,7 @@ void HashJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)
     else if (kind == ASTTableJoin::Kind::Cross)
         joinBlockImplCross(block, not_processed);
     else
-        throw Exception("Logical error: unknown combination of JOIN", ErrorCodes::LOGICAL_ERROR);
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Wrong JOIN combination: {} {}", strictness, kind);
 }
 
 template <typename Mapped>
@@ -1494,7 +1494,7 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller
         };
 
         if (!joinDispatch(parent.kind, parent.strictness, parent.data->maps, fill_callback))
-            throw Exception("Logical error: unknown JOIN strictness (must be on of: ANY, ALL, ASOF)", ErrorCodes::LOGICAL_ERROR);
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Unknown JOIN strictness '{}' (must be on of: ANY, ALL, ASOF)", parent.strictness);
 
         fillNullsFromBlocks(columns_right, rows_added);
         return rows_added;
diff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp
index 9194de3073ac..b0c89adee454 100644
--- a/src/Interpreters/TableJoin.cpp
+++ b/src/Interpreters/TableJoin.cpp
@@ -339,8 +339,16 @@ static std::optional<String> getDictKeyName(const String & dict_name , ContextPt
 
 bool TableJoin::tryInitDictJoin(const Block & sample_block, ContextPtr context)
 {
+    using Strictness = ASTTableJoin::Strictness;
+
+    bool allowed_inner = isInner(kind()) && strictness() == Strictness::All;
+    bool allowed_left = isLeft(kind()) && (strictness() == Strictness::Any ||
+                                           strictness() == Strictness::All ||
+                                           strictness() == Strictness::Semi ||
+                                           strictness() == Strictness::Anti);
+
     /// Support ALL INNER, [ANY | ALL | SEMI | ANTI] LEFT
-    if (!isLeft(kind()) && !(isInner(kind()) && strictness() == ASTTableJoin::Strictness::All))
+    if (!allowed_inner && !allowed_left)
         return false;
 
     const Names & right_keys = keyNamesRight();
diff --git a/src/Parsers/ASTTablesInSelectQuery.h b/src/Parsers/ASTTablesInSelectQuery.h
index 8b4899748043..9d31ca6f6539 100644
--- a/src/Parsers/ASTTablesInSelectQuery.h
+++ b/src/Parsers/ASTTablesInSelectQuery.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <Parsers/IAST.h>
+#include <common/EnumReflection.h>
 
 
 namespace DB
