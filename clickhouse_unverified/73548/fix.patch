diff --git a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp
index a57aa81c9fce..beffb777d131 100644
--- a/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp
+++ b/src/Analyzer/Passes/FunctionToSubcolumnsPass.cpp
@@ -71,23 +71,47 @@ void optimizeFunctionEmpty(QueryTreeNodePtr &, FunctionNode & function_node, Col
     resolveOrdinaryFunctionNodeByName(function_node, function_name, ctx.context);
 }
 
-String getSubcolumnNameForElement(const Field & value, const DataTypeTuple & data_type_tuple)
+std::optional<NameAndTypePair> getSubcolumnForElement(const Field & value, const DataTypeTuple & data_type_tuple)
 {
+    const auto & names = data_type_tuple.getElementNames();
+    const auto & types = data_type_tuple.getElements();
+
     if (value.getType() == Field::Types::String)
-        return value.safeGet<const String &>();
+    {
+        const auto & name = value.safeGet<const String &>();
+        auto pos = data_type_tuple.tryGetPositionByName(name);
+
+        if (!pos)
+            return {};
+
+        return NameAndTypePair{name, types[*pos]};
+    }
 
     if (value.getType() == Field::Types::UInt64)
-        return data_type_tuple.getNameByPosition(value.safeGet<UInt64>());
+    {
+        size_t index = value.safeGet<UInt64>();
+
+        if (index == 0 || index > types.size())
+            return {};
+
+        return NameAndTypePair{names[index - 1], types[index - 1]};
+    }
 
-    return "";
+    return {};
 }
 
-String getSubcolumnNameForElement(const Field & value, const DataTypeVariant &)
+std::optional<NameAndTypePair> getSubcolumnForElement(const Field & value, const DataTypeVariant & data_type_variant)
 {
-    if (value.getType() == Field::Types::String)
-        return value.safeGet<const String &>();
+    if (value.getType() != Field::Types::String)
+        return {};
+
+    const auto & name = value.safeGet<const String &>();
+    auto discr = data_type_variant.tryGetVariantDiscriminator(name);
+
+    if (!discr)
+        return {};
 
-    return "";
+    return NameAndTypePair{name, data_type_variant.getVariant(*discr)};
 }
 
 template <typename DataType>
@@ -105,12 +129,12 @@ void optimizeTupleOrVariantElement(QueryTreeNodePtr & node, FunctionNode & funct
         return;
 
     const auto & data_type_concrete = assert_cast<const DataType &>(*ctx.column.type);
-    auto subcolumn_name = getSubcolumnNameForElement(second_argument_constant_node->getValue(), data_type_concrete);
+    auto subcolumn = getSubcolumnForElement(second_argument_constant_node->getValue(), data_type_concrete);
 
-    if (subcolumn_name.empty())
+    if (!subcolumn)
         return;
 
-    NameAndTypePair column{ctx.column.name + "." + subcolumn_name, function_node.getResultType()};
+    NameAndTypePair column{ctx.column.name + "." + subcolumn->name, subcolumn->type};
     node = std::make_shared<ColumnNode>(column, ctx.column_source);
 }
 
