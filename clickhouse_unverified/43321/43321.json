{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 43321,
  "instance_id": "ClickHouse__ClickHouse-43321",
  "issue_numbers": [
    "43305"
  ],
  "base_commit": "843401c3a3002f8193ff003dfd9fbee1c481e175",
  "patch": "diff --git a/src/Analyzer/HashUtils.h b/src/Analyzer/HashUtils.h\nnew file mode 100644\nindex 000000000000..46222755938e\n--- /dev/null\n+++ b/src/Analyzer/HashUtils.h\n@@ -0,0 +1,60 @@\n+#pragma once\n+\n+#include <Analyzer/IQueryTreeNode.h>\n+\n+namespace DB\n+{\n+\n+/** This structure holds query tree node ptr and its hash. It can be used as hash map key to avoid unnecessary hash\n+  * recalculations.\n+  *\n+  * Example of usage:\n+  * std::unordered_map<QueryTreeNodeConstRawPtrWithHash, std::string> map;\n+  */\n+template <typename QueryTreeNodePtrType>\n+struct QueryTreeNodeWithHash\n+{\n+    QueryTreeNodeWithHash(QueryTreeNodePtrType node_) /// NOLINT\n+        : node(std::move(node_))\n+        , hash(node->getTreeHash().first)\n+    {}\n+\n+    QueryTreeNodePtrType node = nullptr;\n+    size_t hash = 0;\n+};\n+\n+template <typename T>\n+inline bool operator==(const QueryTreeNodeWithHash<T> & lhs, const QueryTreeNodeWithHash<T> & rhs)\n+{\n+    return lhs.hash == rhs.hash && lhs.node->isEqual(*rhs.node);\n+}\n+\n+template <typename T>\n+inline bool operator!=(const QueryTreeNodeWithHash<T> & lhs, const QueryTreeNodeWithHash<T> & rhs)\n+{\n+    return !(lhs == rhs);\n+}\n+\n+using QueryTreeNodePtrWithHash = QueryTreeNodeWithHash<QueryTreeNodePtr>;\n+using QueryTreeNodeRawPtrWithHash = QueryTreeNodeWithHash<IQueryTreeNode *>;\n+using QueryTreeNodeConstRawPtrWithHash = QueryTreeNodeWithHash<const IQueryTreeNode *>;\n+\n+using QueryTreeNodePtrWithHashSet = std::unordered_set<QueryTreeNodePtrWithHash>;\n+using QueryTreeNodeConstRawPtrWithHashSet = std::unordered_set<QueryTreeNodeConstRawPtrWithHash>;\n+\n+template <typename Value>\n+using QueryTreeNodePtrWithHashMap = std::unordered_map<QueryTreeNodePtrWithHash, Value>;\n+\n+template <typename Value>\n+using QueryTreeNodeConstRawPtrWithHashMap = std::unordered_map<QueryTreeNodeConstRawPtrWithHash, Value>;\n+\n+}\n+\n+template <typename T>\n+struct std::hash<DB::QueryTreeNodeWithHash<T>>\n+{\n+    size_t operator()(const DB::QueryTreeNodeWithHash<T> & node_with_hash) const\n+    {\n+        return node_with_hash.hash;\n+    }\n+};\ndiff --git a/src/Analyzer/Passes/FuseFunctionsPass.cpp b/src/Analyzer/Passes/FuseFunctionsPass.cpp\nindex 6c6613e75984..a75afc7cfa69 100644\n--- a/src/Analyzer/Passes/FuseFunctionsPass.cpp\n+++ b/src/Analyzer/Passes/FuseFunctionsPass.cpp\n@@ -8,6 +8,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/ConstantNode.h>\n+#include <Analyzer/HashUtils.h>\n \n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeArray.h>\n@@ -48,43 +49,24 @@ class FuseFunctionsVisitor : public InDepthQueryTreeVisitor<FuseFunctionsVisitor\n             /// Do not apply for `count()` with without arguments or `count(*)`, only `count(x)` is supported.\n             return;\n \n-        mapping[QueryTreeNodeWithHash(argument_nodes[0])].push_back(&node);\n+        argument_to_functions_mapping[argument_nodes[0]].push_back(&node);\n     }\n \n-    struct QueryTreeNodeWithHash\n-    {\n-        const QueryTreeNodePtr & node;\n-        IQueryTreeNode::Hash hash;\n-\n-        explicit QueryTreeNodeWithHash(const QueryTreeNodePtr & node_)\n-            : node(node_)\n-            , hash(node->getTreeHash())\n-        {}\n-\n-        bool operator==(const QueryTreeNodeWithHash & rhs) const\n-        {\n-            return hash == rhs.hash && node->isEqual(*rhs.node);\n-        }\n-\n-        struct Hash\n-        {\n-            size_t operator() (const QueryTreeNodeWithHash & key) const { return key.hash.first ^ key.hash.second; }\n-        };\n-    };\n-\n     /// argument -> list of sum/count/avg functions with this argument\n-    std::unordered_map<QueryTreeNodeWithHash, std::vector<QueryTreeNodePtr *>, QueryTreeNodeWithHash::Hash> mapping;\n+    QueryTreeNodePtrWithHashMap<std::vector<QueryTreeNodePtr *>> argument_to_functions_mapping;\n \n private:\n     std::unordered_set<String> names_to_collect;\n };\n \n-QueryTreeNodePtr createResolvedFunction(ContextPtr context, const String & name, DataTypePtr result_type, QueryTreeNodes arguments)\n+QueryTreeNodePtr createResolvedFunction(const ContextPtr & context, const String & name, const DataTypePtr & result_type, QueryTreeNodes arguments)\n {\n     auto function_node = std::make_shared<FunctionNode>(name);\n+\n     auto function = FunctionFactory::instance().get(name, context);\n     function_node->resolveAsFunction(std::move(function), result_type);\n     function_node->getArguments().getNodes() = std::move(arguments);\n+\n     return function_node;\n }\n \n@@ -94,21 +76,20 @@ FunctionNodePtr createResolvedAggregateFunction(const String & name, const Query\n \n     AggregateFunctionProperties properties;\n     auto aggregate_function = AggregateFunctionFactory::instance().get(name, {argument->getResultType()}, parameters, properties);\n-\n     function_node->resolveAsAggregateFunction(aggregate_function, aggregate_function->getReturnType());\n+    function_node->getArguments().getNodes() = { argument };\n \n-    function_node->getArgumentsNode() = std::make_shared<ListNode>(QueryTreeNodes{argument});\n     return function_node;\n }\n \n-QueryTreeNodePtr createTupleElementFunction(ContextPtr context, DataTypePtr result_type, QueryTreeNodePtr argument, UInt64 index)\n+QueryTreeNodePtr createTupleElementFunction(const ContextPtr & context, const DataTypePtr & result_type, QueryTreeNodePtr argument, UInt64 index)\n {\n-    return createResolvedFunction(context, \"tupleElement\", result_type, {argument, std::make_shared<ConstantNode>(index)});\n+    return createResolvedFunction(context, \"tupleElement\", result_type, {std::move(argument), std::make_shared<ConstantNode>(index)});\n }\n \n-QueryTreeNodePtr createArrayElementFunction(ContextPtr context, DataTypePtr result_type, QueryTreeNodePtr argument, UInt64 index)\n+QueryTreeNodePtr createArrayElementFunction(const ContextPtr & context, const DataTypePtr & result_type, QueryTreeNodePtr argument, UInt64 index)\n {\n-    return createResolvedFunction(context, \"arrayElement\", result_type, {argument, std::make_shared<ConstantNode>(index)});\n+    return createResolvedFunction(context, \"arrayElement\", result_type, {std::move(argument), std::make_shared<ConstantNode>(index)});\n }\n \n void replaceWithSumCount(QueryTreeNodePtr & node, const FunctionNodePtr & sum_count_node, ContextPtr context)\n@@ -151,6 +132,7 @@ FunctionNodePtr createFusedQuantilesNode(const std::vector<QueryTreeNodePtr *> n\n {\n     Array parameters;\n     parameters.reserve(nodes.size());\n+\n     for (const auto * node : nodes)\n     {\n         const FunctionNode & function_node = (*node)->as<const FunctionNode &>();\n@@ -172,6 +154,7 @@ FunctionNodePtr createFusedQuantilesNode(const std::vector<QueryTreeNodePtr *> n\n \n         parameters.push_back(constant_value->getValue());\n     }\n+\n     return createResolvedAggregateFunction(\"quantiles\", argument, parameters);\n }\n \n@@ -181,7 +164,7 @@ void tryFuseSumCountAvg(QueryTreeNodePtr query_tree_node, ContextPtr context)\n     FuseFunctionsVisitor visitor({\"sum\", \"count\", \"avg\"});\n     visitor.visit(query_tree_node);\n \n-    for (auto & [argument, nodes] : visitor.mapping)\n+    for (auto & [argument, nodes] : visitor.argument_to_functions_mapping)\n     {\n         if (nodes.size() < 2)\n             continue;\n@@ -199,24 +182,22 @@ void tryFuseQuantiles(QueryTreeNodePtr query_tree_node, ContextPtr context)\n {\n     FuseFunctionsVisitor visitor_quantile({\"quantile\"});\n     visitor_quantile.visit(query_tree_node);\n-    for (auto & [argument, nodes] : visitor_quantile.mapping)\n+\n+    for (auto & [argument, nodes] : visitor_quantile.argument_to_functions_mapping)\n     {\n-        if (nodes.size() < 2)\n+        size_t nodes_size = nodes.size();\n+        if (nodes_size < 2)\n             continue;\n \n         auto quantiles_node = createFusedQuantilesNode(nodes, argument.node);\n         auto result_array_type = std::dynamic_pointer_cast<const DataTypeArray>(quantiles_node->getResultType());\n         if (!result_array_type)\n-        {\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n                 \"Unexpected return type '{}' of function '{}', should be array\",\n                 quantiles_node->getResultType(), quantiles_node->getFunctionName());\n-        }\n \n-        for (size_t i = 0; i < nodes.size(); ++i)\n-        {\n+        for (size_t i = 0; i < nodes_size; ++i)\n             *nodes[i] = createArrayElementFunction(context, result_array_type->getNestedType(), quantiles_node, i + 1);\n-        }\n     }\n }\n \ndiff --git a/src/Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.cpp b/src/Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.cpp\nindex e4d6633b6e6e..3632c41028b5 100644\n--- a/src/Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.cpp\n+++ b/src/Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.cpp\n@@ -3,6 +3,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/QueryNode.h>\n #include <Analyzer/SortNode.h>\n+#include <Analyzer/HashUtils.h>\n \n namespace DB\n {\n@@ -10,35 +11,6 @@ namespace DB\n namespace\n {\n \n-struct QueryTreeNodeWithHash\n-{\n-    explicit QueryTreeNodeWithHash(const IQueryTreeNode * node_)\n-        : node(node_)\n-        , hash(node->getTreeHash().first)\n-    {}\n-\n-    const IQueryTreeNode * node = nullptr;\n-    size_t hash = 0;\n-};\n-\n-struct QueryTreeNodeWithHashHash\n-{\n-    size_t operator()(const QueryTreeNodeWithHash & node_with_hash) const\n-    {\n-        return node_with_hash.hash;\n-    }\n-};\n-\n-struct QueryTreeNodeWithHashEqualTo\n-{\n-    bool operator()(const QueryTreeNodeWithHash & lhs_node, const QueryTreeNodeWithHash & rhs_node) const\n-    {\n-        return lhs_node.hash == rhs_node.hash && lhs_node.node->isEqual(*rhs_node.node);\n-    }\n-};\n-\n-using QueryTreeNodeWithHashSet = std::unordered_set<QueryTreeNodeWithHash, QueryTreeNodeWithHashHash, QueryTreeNodeWithHashEqualTo>;\n-\n class OrderByLimitByDuplicateEliminationVisitor : public InDepthQueryTreeVisitor<OrderByLimitByDuplicateEliminationVisitor>\n {\n public:\n@@ -93,7 +65,7 @@ class OrderByLimitByDuplicateEliminationVisitor : public InDepthQueryTreeVisitor\n     }\n \n private:\n-    QueryTreeNodeWithHashSet unique_expressions_nodes_set;\n+    QueryTreeNodeConstRawPtrWithHashSet unique_expressions_nodes_set;\n };\n \n }\ndiff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex 138ff721f997..7e18bf13d770 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -517,7 +517,7 @@ class ExpressionsStack\n \n private:\n     QueryTreeNodes expressions;\n-    std::unordered_map<std::string, std::vector<QueryTreeNodePtr>> alias_name_to_expressions;\n+    std::unordered_map<std::string, QueryTreeNodes> alias_name_to_expressions;\n };\n \n /** Projection names is name of query tree node that is used in projection part of query node.\n@@ -2171,18 +2171,19 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier\n         auto & alias_identifier_node = it->second->as<IdentifierNode &>();\n         auto identifier = alias_identifier_node.getIdentifier();\n         auto lookup_result = tryResolveIdentifier(IdentifierLookup{identifier, identifier_lookup.lookup_context}, scope, identifier_resolve_settings);\n-        if (!lookup_result.isResolved())\n+        if (!lookup_result.resolved_identifier)\n         {\n             std::unordered_set<Identifier> valid_identifiers;\n             collectScopeWithParentScopesValidIdentifiersForTypoCorrection(identifier, scope, true, false, false, valid_identifiers);\n-\n             auto hints = collectIdentifierTypoHints(identifier, valid_identifiers);\n-            throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER, \"Unknown {} identifier '{}' in scope {}{}\",\n-                toStringLowercase(IdentifierLookupContext::EXPRESSION),\n+\n+            throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER, \"Unknown {} identifier '{}'. In scope {}{}\",\n+                toStringLowercase(identifier_lookup.lookup_context),\n                 identifier.getFullName(),\n                 scope.scope_node->formatASTForErrorMessage(),\n                 getHintsErrorMessageSuffix(hints));\n         }\n+\n         it->second = lookup_result.resolved_identifier;\n \n         /** During collection of aliases if node is identifier and has alias, we cannot say if it is\n@@ -2193,9 +2194,9 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier\n           * If we resolved identifier node as function, we must remove identifier node alias from\n           * expression alias map.\n           */\n-        if (identifier_lookup.isExpressionLookup() && it->second)\n+        if (identifier_lookup.isExpressionLookup())\n             scope.alias_name_to_lambda_node.erase(identifier_bind_part);\n-        else if (identifier_lookup.isFunctionLookup() && it->second)\n+        else if (identifier_lookup.isFunctionLookup())\n             scope.alias_name_to_expression_node.erase(identifier_bind_part);\n \n         scope.expressions_in_resolve_process_stack.popNode();\n@@ -3203,11 +3204,9 @@ QueryAnalyzer::QueryTreeNodesWithNames QueryAnalyzer::resolveUnqualifiedMatcher(\n \n         if (auto * array_join_node = table_expression->as<ArrayJoinNode>())\n         {\n-            size_t table_expressions_column_nodes_with_names_stack_size = table_expressions_column_nodes_with_names_stack.size();\n-            if (table_expressions_column_nodes_with_names_stack_size < 1)\n+            if (table_expressions_column_nodes_with_names_stack.empty())\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Expected at least 1 table expressions on stack before ARRAY JOIN processing. Actual {}\",\n-                    table_expressions_column_nodes_with_names_stack_size);\n+                    \"Expected at least 1 table expressions on stack before ARRAY JOIN processing\");\n \n             auto & table_expression_column_nodes_with_names = table_expressions_column_nodes_with_names_stack.back();\n \ndiff --git a/src/Planner/PlannerJoins.cpp b/src/Planner/PlannerJoins.cpp\nindex 53b9cfc5d99d..b59dccc92c21 100644\n--- a/src/Planner/PlannerJoins.cpp\n+++ b/src/Planner/PlannerJoins.cpp\n@@ -87,8 +87,8 @@ void JoinClause::dump(WriteBuffer & buffer) const\n         {\n             const auto & asof_condition = asof_conditions[i];\n \n-            buffer << \"key_index: \" << asof_condition.key_index;\n-            buffer << \"inequality: \" << toString(asof_condition.asof_inequality);\n+            buffer << \" key_index: \" << asof_condition.key_index;\n+            buffer << \" inequality: \" << toString(asof_condition.asof_inequality);\n \n             if (i + 1 != asof_conditions_size)\n                 buffer << ',';\ndiff --git a/src/Planner/TableExpressionData.h b/src/Planner/TableExpressionData.h\nindex 57eaa28e072e..4537065c58ab 100644\n--- a/src/Planner/TableExpressionData.h\n+++ b/src/Planner/TableExpressionData.h\n@@ -183,19 +183,19 @@ class TableExpressionData\n     }\n \n private:\n-    /// Valid for table, table function, query, union, array join table expression nodes\n+    /// Valid for table, table function, array join, query, union nodes\n     NamesAndTypesList columns;\n \n-    /// Valid for table, table function, query, union, array join table expression nodes\n+    /// Valid for table, table function, array join, query, union nodes\n     NameSet columns_names;\n \n-    /// Valid only for table table expression node\n+    /// Valid only for table node\n     NameSet alias_columns_names;\n \n-    /// Valid for table, table function, query, union table, array join expression nodes\n+    /// Valid for table, table function, array join, query, union nodes\n     ColumnNameToColumnIdentifier column_name_to_column_identifier;\n \n-    /// Valid for table, table function, query, union table, array join expression nodes\n+    /// Valid for table, table function, array join, query, union nodes\n     ColumnIdentifierToColumnName column_identifier_to_column_name;\n \n     /// Is storage remote\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.reference b/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.reference\nnew file mode 100644\nindex 000000000000..0a9ed2fb4c8d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.reference\n@@ -0,0 +1,1 @@\n+String\tValue_1\ndiff --git a/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.sql b/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.sql\nnew file mode 100644\nindex 000000000000..b0983159eaf9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.sql\n@@ -0,0 +1,36 @@\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS test_table_join_1;\n+CREATE TABLE test_table_join_1\n+(\n+    id UInt8,\n+    value String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO test_table_join_1 VALUES (0, 'Value_0');\n+\n+DROP TABLE IF EXISTS test_table_join_2;\n+CREATE TABLE test_table_join_2\n+(\n+    id UInt16,\n+    value String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO test_table_join_2 VALUES (0, 'Value_1');\n+\n+SELECT\n+    toTypeName(t2_value),\n+    t2.value AS t2_value\n+FROM test_table_join_1 AS t1\n+INNER JOIN test_table_join_2 USING (id); -- { serverError 47 };\n+\n+SELECT\n+    toTypeName(t2_value),\n+    t2.value AS t2_value\n+FROM test_table_join_1 AS t1\n+INNER JOIN test_table_join_2 AS t2 USING (id);\n+\n+DROP TABLE test_table_join_1;\n+DROP TABLE test_table_join_2;\n",
  "problem_statement": "Crash in `JOIN` with experimental analyzer\n**Describe the bug**\r\n[A link to the report\r\n](https://s3.amazonaws.com/clickhouse-test-reports/43233/c383d1fdb18ce5c61ab3c1692b2dfdfc74060933/fuzzer_astfuzzerasan//report.html)\r\n\r\n**How to reproduce**\r\n```sql\r\nDROP TABLE IF EXISTS test_table_join_1;\r\n\r\nCREATE TABLE test_table_join_1\r\n(\r\n    `id` UInt8,\r\n    `value` String\r\n)\r\nENGINE = TinyLog;\r\n\r\n\r\nDROP TABLE IF EXISTS test_table_join_2;\r\n\r\nCREATE TABLE test_table_join_2\r\n(\r\n    `id` UInt16,\r\n    `value` String\r\n)\r\nENGINE = TinyLog;\r\n\r\nSELECT\r\n    toTypeName(t2_value),\r\n    t2.value AS t2_value\r\nFROM test_table_join_1 AS t1\r\nINNER JOIN test_table_join_2 USING (id)\r\nSETTINGS allow_experimental_analyzer = 0;\r\n\r\nReceived exception from server (version 22.11.1):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 't2.value' while processing query: 'SELECT toTypeName(t2.value AS t2_value), t2_value FROM test_table_join_1 AS t1 ALL INNER JOIN (SELECT * FROM test_table_join_2) AS test_table_join_2 USING (id) SETTINGS allow_experimental_analyzer = 0', required columns: 't2.value' 'id', maybe you meant: ['id'], joined columns: 'test_table_join_2.id' 'test_table_join_2.value'. (UNKNOWN_IDENTIFIER)\r\n\r\nSELECT\r\n    toTypeName(t2_value),\r\n    t2.value AS t2_value\r\nFROM test_table_join_1 AS t1\r\nINNER JOIN test_table_join_2 USING (id)\r\nSETTINGS allow_experimental_analyzer = 1;\r\n```\r\n\r\n```\r\n2022.11.16 19:19:52.921094 [ 2351042 ] <Fatal> BaseDaemon: ########################################\r\n2022.11.16 19:19:52.921198 [ 2351042 ] <Fatal> BaseDaemon: (version 22.11.1.1295 (official build), build id: 3C94F6F35B207654A5D0D928A9ECDB1662081D5B) (from thread 2350559) (query_id: 60db6d9b-a866-4acd-839f-9ed7bfa0e0bf) (query: SELECT toTypeName(t2_value), t2.value AS t2_value FROM test_table_join_1 AS t1 INNER JOIN test_table_join_2 USING (id) SETTINGS allow_experimental_analyzer = 1;) Received signal Segmentation fault (11)\r\n2022.11.16 19:19:52.921245 [ 2351042 ] <Fatal> BaseDaemon: Address: NULL pointer. Access: read. Address not mapped to object.\r\n2022.11.16 19:19:52.921284 [ 2351042 ] <Fatal> BaseDaemon: Stack trace: 0x130d0aba 0x130cc0ed 0x130e68d9 0x130cd35c 0x130cc0ed 0x130c5326 0x130c3200 0x130c1c25 0x131cad5a 0x1314414a 0x1351db00 0x1351b28d 0x1419cc6e 0x141b00b9 0x16fe57d4 0x16fe717b 0x17175f87 0x171739bd 0x7f2a2646b609 0x7f2a26390163\r\n2022.11.16 19:19:52.966856 [ 2351042 ] <Fatal> BaseDaemon: 2.1. inlined from ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:1523: DB::(anonymous namespace)::QueryAnalyzer::collectScopeValidIdentifiersForTypoCorrection(DB::Identifier const&, DB::(anonymous namespace)::IdentifierResolveScope const&, bool, bool, bool, std::__1::unordered_set<DB::Identifier, std::__1::hash<DB::Identifier>, std::__1::equal_to<DB::Identifier>, std::__1::allocator<DB::Identifier>>&)\r\n2022.11.16 19:19:52.966902 [ 2351042 ] <Fatal> BaseDaemon: 2.2. inlined from ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:1599: DB::(anonymous namespace)::QueryAnalyzer::collectScopeWithParentScopesValidIdentifiersForTypoCorrection(DB::Identifier const&, DB::(anonymous namespace)::IdentifierResolveScope const&, bool, bool, bool, std::__1::unordered_set<DB::Identifier, std::__1::hash<DB::Identifier>, std::__1::equal_to<DB::Identifier>, std::__1::allocator<DB::Identifier>>&)\r\n2022.11.16 19:19:52.966934 [ 2351042 ] <Fatal> BaseDaemon: 2. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:4634: DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x130d0aba in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.007082 [ 2351042 ] <Fatal> BaseDaemon: 3. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:4835: DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNodeList(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x130cc0ed in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.071627 [ 2351042 ] <Fatal> BaseDaemon: 4. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:3969: DB::(anonymous namespace)::QueryAnalyzer::resolveFunction(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x130e68d9 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.113088 [ 2351042 ] <Fatal> BaseDaemon: 5.1. inlined from ./build_docker/../contrib/libcxx/include/vector:543: std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>>::empty[abi:v15003]() const\r\n2022.11.16 19:19:53.113111 [ 2351042 ] <Fatal> BaseDaemon: 5. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:4710: DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNode(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x130cd35c in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.152961 [ 2351042 ] <Fatal> BaseDaemon: 6. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:4835: DB::(anonymous namespace)::QueryAnalyzer::resolveExpressionNodeList(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&, bool, bool) @ 0x130cc0ed in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.199241 [ 2351042 ] <Fatal> BaseDaemon: 7.1. inlined from ./build_docker/../contrib/libcxx/include/__memory/shared_ptr.h:815: std::__1::shared_ptr<DB::IQueryTreeNode>::operator->[abi:v15003]() const\r\n2022.11.16 19:19:53.199294 [ 2351042 ] <Fatal> BaseDaemon: 7.2. inlined from ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:5005: DB::(anonymous namespace)::QueryAnalyzer::resolveProjectionExpressionNodeList(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::(anonymous namespace)::IdentifierResolveScope&)\r\n2022.11.16 19:19:53.199316 [ 2351042 ] <Fatal> BaseDaemon: 7. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:5858: DB::(anonymous namespace)::QueryAnalyzer::resolveQuery(std::__1::shared_ptr<DB::IQueryTreeNode> const&, DB::(anonymous namespace)::IdentifierResolveScope&) @ 0x130c5326 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.236235 [ 2351042 ] <Fatal> BaseDaemon: 8.1. inlined from ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:987: DB::(anonymous namespace)::QueryAnalyzer::resolve(std::__1::shared_ptr<DB::IQueryTreeNode>, std::__1::shared_ptr<DB::IQueryTreeNode> const&, std::__1::shared_ptr<DB::Context const>)\r\n2022.11.16 19:19:53.236269 [ 2351042 ] <Fatal> BaseDaemon: 8. ./build_docker/../src/Analyzer/Passes/QueryAnalysisPass.cpp:6176: DB::QueryAnalysisPass::run(std::__1::shared_ptr<DB::IQueryTreeNode>, std::__1::shared_ptr<DB::Context const>) @ 0x130c3200 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.240345 [ 2351042 ] <Fatal> BaseDaemon: 9. ./build_docker/../src/Analyzer/QueryTreePassManager.cpp:97: DB::QueryTreePassManager::run(std::__1::shared_ptr<DB::IQueryTreeNode>) @ 0x130c1c25 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.247430 [ 2351042 ] <Fatal> BaseDaemon: 10.1. inlined from ./build_docker/../contrib/libcxx/include/vector:434: ~vector\r\n2022.11.16 19:19:53.247452 [ 2351042 ] <Fatal> BaseDaemon: 10.2. inlined from ./build_docker/../src/Analyzer/QueryTreePassManager.h:13: ~QueryTreePassManager\r\n2022.11.16 19:19:53.247504 [ 2351042 ] <Fatal> BaseDaemon: 10.3. inlined from ./build_docker/../src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:57: DB::(anonymous namespace)::buildQueryTreeAndRunPasses(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context const> const&)\r\n2022.11.16 19:19:53.247535 [ 2351042 ] <Fatal> BaseDaemon: 10. ./build_docker/../src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:67: DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::__1::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::__1::shared_ptr<DB::Context const>) @ 0x131cad5a in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.255678 [ 2351042 ] <Fatal> BaseDaemon: 11.1. inlined from ./build_docker/../contrib/libcxx/include/__memory/unique_ptr.h:0: std::__1::__unique_if<DB::InterpreterSelectQueryAnalyzer>::__unique_single std::__1::make_unique[abi:v15003]<DB::InterpreterSelectQueryAnalyzer, std::__1::shared_ptr<DB::IAST>&, DB::SelectQueryOptions const&, std::__1::shared_ptr<DB::Context>&>(std::__1::shared_ptr<DB::IAST>&, DB::SelectQueryOptions const&, std::__1::shared_ptr<DB::Context>&)\r\n2022.11.16 19:19:53.255722 [ 2351042 ] <Fatal> BaseDaemon: 11. ./build_docker/../src/Interpreters/InterpreterFactory.cpp:134: DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context>, DB::SelectQueryOptions const&) @ 0x1314414a in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.279204 [ 2351042 ] <Fatal> BaseDaemon: 12. ./build_docker/../src/Interpreters/executeQuery.cpp:0: DB::executeQueryImpl(char const*, char const*, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x1351db00 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.306451 [ 2351042 ] <Fatal> BaseDaemon: 13. ./build_docker/../src/Interpreters/executeQuery.cpp:1074: DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x1351b28d in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.333983 [ 2351042 ] <Fatal> BaseDaemon: 14. ./build_docker/../src/Server/TCPHandler.cpp:0: DB::TCPHandler::runImpl() @ 0x1419cc6e in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.375656 [ 2351042 ] <Fatal> BaseDaemon: 15. ./build_docker/../src/Server/TCPHandler.cpp:1904: DB::TCPHandler::run() @ 0x141b00b9 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.377183 [ 2351042 ] <Fatal> BaseDaemon: 16. ./build_docker/../contrib/poco/Net/src/TCPServerConnection.cpp:57: Poco::Net::TCPServerConnection::start() @ 0x16fe57d4 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.379590 [ 2351042 ] <Fatal> BaseDaemon: 17.1. inlined from ./build_docker/../contrib/libcxx/include/__memory/unique_ptr.h:48: std::__1::default_delete<Poco::Net::TCPServerConnection>::operator()[abi:v15003](Poco::Net::TCPServerConnection*) const\r\n2022.11.16 19:19:53.379611 [ 2351042 ] <Fatal> BaseDaemon: 17.2. inlined from ./build_docker/../contrib/libcxx/include/__memory/unique_ptr.h:305: std::__1::unique_ptr<Poco::Net::TCPServerConnection, std::__1::default_delete<Poco::Net::TCPServerConnection>>::reset[abi:v15003](Poco::Net::TCPServerConnection*)\r\n2022.11.16 19:19:53.379649 [ 2351042 ] <Fatal> BaseDaemon: 17.3. inlined from ./build_docker/../contrib/libcxx/include/__memory/unique_ptr.h:259: ~unique_ptr\r\n2022.11.16 19:19:53.379691 [ 2351042 ] <Fatal> BaseDaemon: 17. ./build_docker/../contrib/poco/Net/src/TCPServerDispatcher.cpp:116: Poco::Net::TCPServerDispatcher::run() @ 0x16fe717b in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.382534 [ 2351042 ] <Fatal> BaseDaemon: 18. ./build_docker/../contrib/poco/Foundation/src/ThreadPool.cpp:213: Poco::PooledThread::run() @ 0x17175f87 in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.384856 [ 2351042 ] <Fatal> BaseDaemon: 19.1. inlined from ./build_docker/../contrib/poco/Foundation/include/Poco/SharedPtr.h:277: Poco::SharedPtr<Poco::Runnable, Poco::ReferenceCounter, Poco::ReleasePolicy<Poco::Runnable>>::get()\r\n2022.11.16 19:19:53.384902 [ 2351042 ] <Fatal> BaseDaemon: 19.2. inlined from ./build_docker/../contrib/poco/Foundation/include/Poco/SharedPtr.h:156: Poco::SharedPtr<Poco::Runnable, Poco::ReferenceCounter, Poco::ReleasePolicy<Poco::Runnable>>::assign(Poco::Runnable*)\r\n2022.11.16 19:19:53.384915 [ 2351042 ] <Fatal> BaseDaemon: 19.3. inlined from ./build_docker/../contrib/poco/Foundation/include/Poco/SharedPtr.h:208: Poco::SharedPtr<Poco::Runnable, Poco::ReferenceCounter, Poco::ReleasePolicy<Poco::Runnable>>::operator=(Poco::Runnable*)\r\n2022.11.16 19:19:53.384944 [ 2351042 ] <Fatal> BaseDaemon: 19. ./build_docker/../contrib/poco/Foundation/src/Thread_POSIX.cpp:360: Poco::ThreadImpl::runnableEntry(void*) @ 0x171739bd in /usr/lib/debug/usr/bin/clickhouse.debug\r\n2022.11.16 19:19:53.384976 [ 2351042 ] <Fatal> BaseDaemon: 20. ? @ 0x7f2a2646b609 in ?\r\n2022.11.16 19:19:53.385007 [ 2351042 ] <Fatal> BaseDaemon: 21. __clone @ 0x7f2a26390163 in ?\r\n2022.11.16 19:19:53.530036 [ 2351042 ] <Fatal> BaseDaemon: Integrity check of the executable successfully passed (checksum: AEC87B4F3DBF44C1BD933135837E6F59)\r\n```\n",
  "hints_text": "",
  "created_at": "2022-11-17T11:30:44Z",
  "modified_files": [
    "b/src/Analyzer/HashUtils.h",
    "src/Analyzer/Passes/FuseFunctionsPass.cpp",
    "src/Analyzer/Passes/OrderByLimitByDuplicateEliminationPass.cpp",
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Planner/PlannerJoins.cpp",
    "src/Planner/TableExpressionData.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.reference",
    "b/tests/queries/0_stateless/02481_analyzer_join_alias_unknown_identifier_crash.sql"
  ]
}