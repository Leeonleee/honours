{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71966,
  "instance_id": "ClickHouse__ClickHouse-71966",
  "issue_numbers": [
    "71941"
  ],
  "base_commit": "3b0b42cbbbb3c0c0972c3f28441b0aea48cabd9c",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 9e19ffe1b046..b8c03ba2cd64 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -945,6 +945,8 @@ static FieldRef applyFunction(const FunctionBasePtr & func, const DataTypePtr &\n     return {field.columns, field.row_idx, result_idx};\n }\n \n+DataTypePtr getArgumentTypeOfMonotonicFunction(const IFunctionBase & func);\n+\n /// Sequentially applies functions to the column, returns `true`\n /// if all function arguments are compatible with functions\n /// signatures, and none of the functions produce `NULL` output.\n@@ -976,7 +978,7 @@ bool applyFunctionChainToColumn(\n     }\n \n     // And cast it to the argument type of the first function in the chain\n-    auto in_argument_type = functions[0]->getArgumentTypes()[0];\n+    auto in_argument_type = getArgumentTypeOfMonotonicFunction(*functions[0]);\n     if (canBeSafelyCasted(result_type, in_argument_type))\n     {\n         result_column = castColumnAccurate({result_column, result_type, \"\"}, in_argument_type);\n@@ -1005,7 +1007,7 @@ bool applyFunctionChainToColumn(\n         if (func->getArgumentTypes().empty())\n             return false;\n \n-        auto argument_type = func->getArgumentTypes()[0];\n+        auto argument_type = getArgumentTypeOfMonotonicFunction(*func);\n         if (!canBeSafelyCasted(result_type, argument_type))\n             return false;\n \n@@ -1489,6 +1491,18 @@ class FunctionWithOptionalConstArg : public IFunctionBase\n     Kind kind = Kind::NO_CONST;\n };\n \n+DataTypePtr getArgumentTypeOfMonotonicFunction(const IFunctionBase & func)\n+{\n+    const auto & arg_types = func.getArgumentTypes();\n+    if (const auto * func_ptr = typeid_cast<const FunctionWithOptionalConstArg *>(&func))\n+    {\n+        if (func_ptr->getKind() == FunctionWithOptionalConstArg::Kind::LEFT_CONST)\n+            return arg_types.at(1);\n+    }\n+\n+    return arg_types.at(0);\n+}\n+\n \n bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctions(\n     const RPNBuilderTreeNode & node,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03272_partition_pruning_monotonic_func_bug.reference b/tests/queries/0_stateless/03272_partition_pruning_monotonic_func_bug.reference\nnew file mode 100644\nindex 000000000000..cbb68477a293\n--- /dev/null\n+++ b/tests/queries/0_stateless/03272_partition_pruning_monotonic_func_bug.reference\n@@ -0,0 +1,11 @@\n+1\n+2\n+Expression\n+  ReadFromMergeTree\n+  Indexes:\n+    PrimaryKey\n+      Keys: \n+        dateTrunc(\\'hour\\', ts)\n+      Condition: and((dateTrunc(\\'hour\\', ts) in (-Inf, 1731592800]), (dateTrunc(\\'hour\\', ts) in [1731506400, +Inf)))\n+      Parts: 1/1\n+      Granules: 1/1\ndiff --git a/tests/queries/0_stateless/03272_partition_pruning_monotonic_func_bug.sql b/tests/queries/0_stateless/03272_partition_pruning_monotonic_func_bug.sql\nnew file mode 100644\nindex 000000000000..b69b7b8a7541\n--- /dev/null\n+++ b/tests/queries/0_stateless/03272_partition_pruning_monotonic_func_bug.sql\n@@ -0,0 +1,19 @@\n+SET session_timezone = 'Etc/UTC';\n+\n+DROP TABLE IF EXISTS tt;\n+CREATE TABLE tt\n+(\n+    `id` Int64,\n+    `ts` DateTime\n+)\n+ENGINE = MergeTree()\n+ORDER BY dateTrunc('hour', ts)\n+SETTINGS index_granularity = 8192;\n+\n+INSERT INTO tt VALUES (1, '2024-11-14 00:00:00'), (2, '2024-11-14 00:00:00');\n+\n+SELECT id FROM tt PREWHERE ts BETWEEN toDateTime(1731506400) AND toDateTime(1731594420);\n+\n+explain indexes=1, description=0 SELECT id FROM tt PREWHERE ts BETWEEN toDateTime(1731506400) AND toDateTime(1731594420);\n+\n+DROP TABLE tt;\n",
  "problem_statement": "24.7+: Broken query by partition pruning\nRepro:\r\n```\r\nCREATE TABLE tt\r\n(\r\n    `id` Int64,\r\n    `ts` DateTime\r\n)\r\nENGINE = MergeTree()\r\nORDER BY dateTrunc('hour', ts)\r\nSETTINGS index_granularity = 8192;\r\n\r\nINSERT INTO tt VALUES (1, '2024-11-14 00:00:00'), (2, '2024-11-14 00:00:00');\r\n\r\nSELECT id\r\nFROM tt\r\nPREWHERE ts BETWEEN toDateTime(1731506400) AND toDateTime(1731594420);\r\n```\r\n\r\n```\r\nReceived exception from server (version 24.11.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Illegal type String of 1st argument of function toStartOfInterval, expected a Date, Date32, DateTime or DateTime64. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n(query: SELECT id\r\nFROM tt\r\nPREWHERE ts BETWEEN toDateTime(1731506400) AND toDateTime(1731594420);)\r\n```\r\n\r\nWorked fine until https://github.com/ClickHouse/ClickHouse/pull/65335. Fails since then\n",
  "hints_text": "",
  "created_at": "2024-11-15T10:39:19Z"
}