{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71403,
  "instance_id": "ClickHouse__ClickHouse-71403",
  "issue_numbers": [
    "71401"
  ],
  "base_commit": "1de0d2f46c21529a5613cea5fd437dec897fd502",
  "patch": "diff --git a/docs/en/sql-reference/aggregate-functions/reference/any.md b/docs/en/sql-reference/aggregate-functions/reference/any.md\nindex 972263585f27..e7bebd4d460b 100644\n--- a/docs/en/sql-reference/aggregate-functions/reference/any.md\n+++ b/docs/en/sql-reference/aggregate-functions/reference/any.md\n@@ -5,7 +5,15 @@ sidebar_position: 102\n \n # any\n \n-Selects the first encountered value of a column, ignoring any `NULL` values.\n+Selects the first encountered value of a column.\n+\n+:::warning\n+As a query can be executed in arbitrary order, the result of this function is non-deterministic.\n+If you need an arbitrary but deterministic result, use functions [`min`](../reference/min.md) or [`max`](../reference/max.md).\n+:::\n+\n+By default, the function never returns NULL, i.e. ignores NULL values in the input column.\n+However, if the function is used with the `RESPECT NULLS` modifier, it returns the first value reads no matter if NULL or not.\n \n **Syntax**\n \n@@ -13,46 +21,51 @@ Selects the first encountered value of a column, ignoring any `NULL` values.\n any(column) [RESPECT NULLS]\n ```\n \n-Aliases: `any_value`, [`first_value`](../reference/first_value.md).\n+Aliases `any(column)` (without `RESPECT NULLS`)\n+- `any_value`\n+- [`first_value`](../reference/first_value.md).\n+\n+Alias for `any(column) RESPECT NULLS`\n+- `anyRespectNulls`, `any_respect_nulls`\n+- `firstValueRespectNulls`, `first_value_respect_nulls`\n+- `anyValueRespectNulls`, `any_value_respect_nulls`\n \n **Parameters**\n-- `column`: The column name. \n+- `column`: The column name.\n \n **Returned value**\n \n-:::note\n-Supports the `RESPECT NULLS` modifier after the function name. Using this modifier will ensure the function selects the first value passed, regardless of whether it is `NULL` or not.\n-:::\n+The first value encountered.\n \n :::note\n-The return type of the function is the same as the input, except for LowCardinality which is discarded. This means that given no rows as input it will return the default value of that type (0 for integers, or Null for a Nullable() column). You might use the `-OrNull` [combinator](../../../sql-reference/aggregate-functions/combinators.md) ) to modify this behaviour.\n-:::\n-\n-:::warning\n-The query can be executed in any order and even in a different order each time, so the result of this function is indeterminate.\n-To get a determinate result, you can use the [`min`](../reference/min.md) or [`max`](../reference/max.md) function instead of `any`.\n+The return type of the function is the same as the input, except for LowCardinality which is discarded.\n+This means that given no rows as input it will return the default value of that type (0 for integers, or Null for a Nullable() column).\n+You might use the `-OrNull` [combinator](../../../sql-reference/aggregate-functions/combinators.md) ) to modify this behaviour.\n :::\n \n **Implementation details**\n \n-In some cases, you can rely on the order of execution. This applies to cases when `SELECT` comes from a subquery that uses `ORDER BY`.\n+In some cases, you can rely on the order of execution.\n+This applies to cases when `SELECT` comes from a subquery that uses `ORDER BY`.\n \n-When a `SELECT` query has the `GROUP BY` clause or at least one aggregate function, ClickHouse (in contrast to MySQL) requires that all expressions in the `SELECT`, `HAVING`, and `ORDER BY` clauses be calculated from keys or from aggregate functions. In other words, each column selected from the table must be used either in keys or inside aggregate functions. To get behavior like in MySQL, you can put the other columns in the `any` aggregate function.\n+When a `SELECT` query has the `GROUP BY` clause or at least one aggregate function, ClickHouse (in contrast to MySQL) requires that all expressions in the `SELECT`, `HAVING`, and `ORDER BY` clauses be calculated from keys or from aggregate functions.\n+In other words, each column selected from the table must be used either in keys or inside aggregate functions.\n+To get behavior like in MySQL, you can put the other columns in the `any` aggregate function.\n \n **Example**\n \n Query:\n \n ```sql\n-CREATE TABLE any_nulls (city Nullable(String)) ENGINE=Log;\n+CREATE TABLE tab (city Nullable(String)) ENGINE=Memory;\n \n-INSERT INTO any_nulls (city) VALUES (NULL), ('Amsterdam'), ('New York'), ('Tokyo'), ('Valencia'), (NULL);\n+INSERT INTO tab (city) VALUES (NULL), ('Amsterdam'), ('New York'), ('Tokyo'), ('Valencia'), (NULL);\n \n-SELECT any(city) FROM any_nulls;\n+SELECT any(city), anyRespectNulls(city) FROM tab;\n ```\n \n ```response\n-\u250c\u2500any(city)\u2500\u2510\n-\u2502 Amsterdam \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500any(city)\u2500\u252c\u2500anyRespectNulls(city)\u2500\u2510\n+\u2502 Amsterdam \u2502 \u1d3a\u1d41\u1d38\u1d38                  \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\ndiff --git a/docs/en/sql-reference/aggregate-functions/reference/anylast.md b/docs/en/sql-reference/aggregate-functions/reference/anylast.md\nindex 4fe21531c761..3d80533e146e 100644\n--- a/docs/en/sql-reference/aggregate-functions/reference/anylast.md\n+++ b/docs/en/sql-reference/aggregate-functions/reference/anylast.md\n@@ -5,7 +5,15 @@ sidebar_position: 105\n \n # anyLast\n \n-Selects the last value encountered, ignoring any `NULL` values by default. The result is just as indeterminate as for the [any](../../../sql-reference/aggregate-functions/reference/any.md) function.\n+Selects the last encountered value of a column.\n+\n+:::warning\n+As a query can be executed in arbitrary order, the result of this function is non-deterministic.\n+If you need an arbitrary but deterministic result, use functions [`min`](../reference/min.md) or [`max`](../reference/max.md).\n+:::\n+\n+By default, the function never returns NULL, i.e. ignores NULL values in the input column.\n+However, if the function is used with the `RESPECT NULLS` modifier, it returns the first value reads no matter if NULL or not.\n \n **Syntax**\n \n@@ -13,12 +21,15 @@ Selects the last value encountered, ignoring any `NULL` values by default. The r\n anyLast(column) [RESPECT NULLS]\n ```\n \n-**Parameters**\n-- `column`: The column name. \n+Alias `anyLast(column)` (without `RESPECT NULLS`)\n+- [`last_value`](../reference/last_value.md).\n \n-:::note\n-Supports the `RESPECT NULLS` modifier after the function name. Using this modifier will ensure the function selects the last value passed, regardless of whether it is `NULL` or not.\n-:::\n+Aliases for `anyLast(column) RESPECT NULLS`\n+- `anyLastRespectNulls`, `anyLast_respect_nulls`\n+- `lastValueRespectNulls`, `last_value_respect_nulls`\n+\n+**Parameters**\n+- `column`: The column name.\n \n **Returned value**\n \n@@ -29,15 +40,15 @@ Supports the `RESPECT NULLS` modifier after the function name. Using this modifi\n Query:\n \n ```sql\n-CREATE TABLE any_last_nulls (city Nullable(String)) ENGINE=Log;\n+CREATE TABLE tab (city Nullable(String)) ENGINE=Memory;\n \n-INSERT INTO any_last_nulls (city) VALUES ('Amsterdam'),(NULL),('New York'),('Tokyo'),('Valencia'),(NULL);\n+INSERT INTO tab (city) VALUES ('Amsterdam'),(NULL),('New York'),('Tokyo'),('Valencia'),(NULL);\n \n-SELECT anyLast(city) FROM any_last_nulls;\n+SELECT anyLast(city), anyLastRespectNulls(city) FROM tab;\n ```\n \n ```response\n-\u250c\u2500anyLast(city)\u2500\u2510\n-\u2502 Valencia      \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500anyLast(city)\u2500\u252c\u2500anyLastRespectNulls(city)\u2500\u2510\n+\u2502 Valencia      \u2502 \u1d3a\u1d41\u1d38\u1d38                      \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\ndiff --git a/docs/en/sql-reference/window-functions/first_value.md b/docs/en/sql-reference/window-functions/first_value.md\nindex 30c3b1f99dc8..c6e978bfc921 100644\n--- a/docs/en/sql-reference/window-functions/first_value.md\n+++ b/docs/en/sql-reference/window-functions/first_value.md\n@@ -15,7 +15,7 @@ first_value (column_name) [[RESPECT NULLS] | [IGNORE NULLS]]\n   OVER ([[PARTITION BY grouping_column] [ORDER BY sorting_column] \n         [ROWS or RANGE expression_to_bound_rows_withing_the_group]] | [window_name])\n FROM table_name\n-WINDOW window_name as ([[PARTITION BY grouping_column] [ORDER BY sorting_column])\n+WINDOW window_name as ([PARTITION BY grouping_column] [ORDER BY sorting_column])\n ```\n \n Alias: `any`.\n@@ -23,6 +23,8 @@ Alias: `any`.\n :::note\n Using the optional modifier `RESPECT NULLS` after `first_value(column_name)` will ensure that `NULL` arguments are not skipped.\n See [NULL processing](../aggregate-functions/index.md/#null-processing) for more information.\n+\n+Alias: `firstValueRespectNulls`\n :::\n \n For more detail on window function syntax see: [Window Functions - Syntax](./index.md/#syntax).\n@@ -48,7 +50,7 @@ CREATE TABLE salaries\n )\n Engine = Memory;\n \n-INSERT INTO salaries FORMAT Values\n+INSERT INTO salaries FORMAT VALUES\n     ('Port Elizabeth Barbarians', 'Gary Chen', 196000, 'F'),\n     ('New Coreystad Archdukes', 'Charles Juarez', 190000, 'F'),\n     ('Port Elizabeth Barbarians', 'Michael Stanley', 100000, 'D'),\ndiff --git a/docs/en/sql-reference/window-functions/last_value.md b/docs/en/sql-reference/window-functions/last_value.md\nindex dd7f5fa078a2..9f3ef8ba4f68 100644\n--- a/docs/en/sql-reference/window-functions/last_value.md\n+++ b/docs/en/sql-reference/window-functions/last_value.md\n@@ -23,6 +23,8 @@ Alias: `anyLast`.\n :::note\n Using the optional modifier `RESPECT NULLS` after `first_value(column_name)` will ensure that `NULL` arguments are not skipped.\n See [NULL processing](../aggregate-functions/index.md/#null-processing) for more information.\n+\n+Alias: `lastValueRespectNulls`\n :::\n \n For more detail on window function syntax see: [Window Functions - Syntax](./index.md/#syntax).\n@@ -33,7 +35,7 @@ For more detail on window function syntax see: [Window Functions - Syntax](./ind\n \n **Example**\n \n-In this example the `last_value` function is used to find the highest paid footballer from a fictional dataset of salaries of Premier League football players.\n+In this example the `last_value` function is used to find the lowest paid footballer from a fictional dataset of salaries of Premier League football players.\n \n Query:\n \n@@ -48,7 +50,7 @@ CREATE TABLE salaries\n )\n Engine = Memory;\n \n-INSERT INTO salaries FORMAT Values\n+INSERT INTO salaries FORMAT VALUES\n     ('Port Elizabeth Barbarians', 'Gary Chen', 196000, 'F'),\n     ('New Coreystad Archdukes', 'Charles Juarez', 190000, 'F'),\n     ('Port Elizabeth Barbarians', 'Michael Stanley', 100000, 'D'),\ndiff --git a/src/AggregateFunctions/AggregateFunctionAnyRespectNulls.cpp b/src/AggregateFunctions/AggregateFunctionAnyRespectNulls.cpp\nindex cce4f26d813e..83fc98ada11a 100644\n--- a/src/AggregateFunctions/AggregateFunctionAnyRespectNulls.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionAnyRespectNulls.cpp\n@@ -221,11 +221,16 @@ void registerAggregateFunctionsAnyRespectNulls(AggregateFunctionFactory & factor\n         = {.returns_default_when_only_null = false, .is_order_dependent = true, .is_window_function = true};\n \n     factory.registerFunction(\"any_respect_nulls\", {createAggregateFunctionAnyRespectNulls, default_properties_for_respect_nulls});\n-    factory.registerAlias(\"any_value_respect_nulls\", \"any_respect_nulls\", AggregateFunctionFactory::Case::Insensitive);\n+    factory.registerAlias(\"anyRespectNulls\", \"any_respect_nulls\", AggregateFunctionFactory::Case::Sensitive);\n     factory.registerAlias(\"first_value_respect_nulls\", \"any_respect_nulls\", AggregateFunctionFactory::Case::Insensitive);\n+    factory.registerAlias(\"firstValueRespectNulls\", \"any_respect_nulls\", AggregateFunctionFactory::Case::Sensitive);\n+    factory.registerAlias(\"any_value_respect_nulls\", \"any_respect_nulls\", AggregateFunctionFactory::Case::Insensitive);\n+    factory.registerAlias(\"anyValueRespectNulls\", \"any_respect_nulls\", AggregateFunctionFactory::Case::Sensitive);\n \n     factory.registerFunction(\"anyLast_respect_nulls\", {createAggregateFunctionAnyLastRespectNulls, default_properties_for_respect_nulls});\n+    factory.registerAlias(\"anyLastRespectNulls\", \"anyLast_respect_nulls\", AggregateFunctionFactory::Case::Sensitive);\n     factory.registerAlias(\"last_value_respect_nulls\", \"anyLast_respect_nulls\", AggregateFunctionFactory::Case::Insensitive);\n+    factory.registerAlias(\"lastValueRespectNulls\", \"anyLast_respect_nulls\", AggregateFunctionFactory::Case::Sensitive);\n \n     /// Must happen after registering any and anyLast\n     factory.registerNullsActionTransformation(\"any\", \"any_respect_nulls\");\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03261_any_respect_camelCase_aliases.reference b/tests/queries/0_stateless/03261_any_respect_camelCase_aliases.reference\nnew file mode 100644\nindex 000000000000..39f78128b24a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03261_any_respect_camelCase_aliases.reference\n@@ -0,0 +1,30 @@\n+anyRespectNulls\n+0\n+\\N\n+\\N\n+0\n+6\n+firstValueRespectNulls\n+0\n+\\N\n+\\N\n+0\n+6\n+anyValueRespectNulls\n+0\n+\\N\n+\\N\n+0\n+6\n+lastValueRespectNulls\n+4\n+\\N\n+\\N\n+0\n+9\n+anyLastRespectNulls\n+4\n+\\N\n+\\N\n+0\n+9\ndiff --git a/tests/queries/0_stateless/03261_any_respect_camelCase_aliases.sql b/tests/queries/0_stateless/03261_any_respect_camelCase_aliases.sql\nnew file mode 100644\nindex 000000000000..c56f096242c8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03261_any_respect_camelCase_aliases.sql\n@@ -0,0 +1,40 @@\n+-- Tests aliases of any and anyLast functions\n+\n+-- aliases of any\n+\n+SELECT 'anyRespectNulls';\n+SELECT anyRespectNulls(number) FROM numbers(5);\n+SELECT arrayReduce('anyRespectNulls', [NULL, 10]::Array(Nullable(UInt8)));\n+SELECT anyRespectNullsMerge(t) FROM (SELECT anyRespectNullsState(NULL::Nullable(UInt8)) as t FROM numbers(5));\n+SELECT finalizeAggregation(CAST(unhex('01'), 'AggregateFunction(anyRespectNulls, UInt64)'));\n+SELECT anyRespectNullsIf (number, NOT isNull(number) AND (assumeNotNull(number) > 5)) FROM numbers(10);\n+\n+SELECT 'firstValueRespectNulls';\n+SELECT firstValueRespectNulls(number) FROM numbers(5);\n+SELECT arrayReduce('firstValueRespectNulls', [NULL, 10]::Array(Nullable(UInt8)));\n+SELECT firstValueRespectNullsMerge(t) FROM (SELECT firstValueRespectNullsState(NULL::Nullable(UInt8)) as t FROM numbers(5));\n+SELECT finalizeAggregation(CAST(unhex('01'), 'AggregateFunction(firstValueRespectNulls, UInt64)'));\n+SELECT firstValueRespectNullsIf (number, NOT isNull(number) AND (assumeNotNull(number) > 5)) FROM numbers(10);\n+\n+SELECT 'anyValueRespectNulls';\n+SELECT anyValueRespectNulls(number) FROM numbers(5);\n+SELECT arrayReduce('anyValueRespectNulls', [NULL, 10]::Array(Nullable(UInt8)));\n+SELECT anyValueRespectNullsMerge(t) FROM (SELECT anyValueRespectNullsState(NULL::Nullable(UInt8)) as t FROM numbers(5));\n+SELECT finalizeAggregation(CAST(unhex('01'), 'AggregateFunction(anyValueRespectNulls, UInt64)'));\n+SELECT anyValueRespectNullsIf (number, NOT isNull(number) AND (assumeNotNull(number) > 5)) FROM numbers(10);\n+\n+-- aliases of anyLast\n+\n+SELECT 'lastValueRespectNulls';\n+SELECT lastValueRespectNulls(number) FROM numbers(5);\n+SELECT arrayReduce('lastValueRespectNulls', [10, NULL]::Array(Nullable(UInt8)));\n+SELECT lastValueRespectNullsMerge(t) FROM (SELECT lastValueRespectNullsState(NULL::Nullable(UInt8)) as t FROM numbers(5));\n+SELECT finalizeAggregation(CAST(unhex('01'), 'AggregateFunction(lastValueRespectNulls, UInt64)'));\n+SELECT lastValueRespectNullsIf (number, NOT isNull(number) AND (assumeNotNull(number) > 5)) FROM numbers(10);\n+\n+SELECT 'anyLastRespectNulls';\n+SELECT anyLastRespectNulls(number) FROM numbers(5);\n+SELECT arrayReduce('anyLastRespectNulls', [10, NULL]::Array(Nullable(UInt8)));\n+SELECT anyLastRespectNullsMerge(t) FROM (SELECT anyLastRespectNullsState(NULL::Nullable(UInt8)) as t FROM numbers(5));\n+SELECT finalizeAggregation(CAST(unhex('01'), 'AggregateFunction(anyLastRespectNulls, UInt64)'));\n+SELECT anyLastRespectNullsIf (number, NOT isNull(number) AND (assumeNotNull(number) > 5)) FROM numbers(10);\n",
  "problem_statement": "Aliases for anyLast_respect_nulls / any_respect_nulls with Camel case\n`anyLast_respect_nullsStateIf` looks unpleasant. It will be much prettier `anyLastRespectNullsStateIf`.\r\n\r\nAlso the error message looks weird:\r\n```sql\r\nselect anyLast_respect_nullsStateIf(10);\r\n\r\nDB::Exception: Aggregate function anyLast_respect_nulls requires single argument. (NUMBER_OF_ARGUMENTS_DOESNT_MATCH)\r\n```\n",
  "hints_text": "I'll take care of this.",
  "created_at": "2024-11-03T17:04:48Z"
}