{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52947,
  "instance_id": "ClickHouse__ClickHouse-52947",
  "issue_numbers": [
    "48318"
  ],
  "base_commit": "1b71c038f97905aa3e10be36d1f3f95f5a2a042a",
  "patch": "diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex 34432d054e15..0b3d19f1861b 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -6887,13 +6887,12 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n                 scope.scope_node->formatASTForErrorMessage());\n     }\n \n-    std::erase_if(with_nodes, [](const QueryTreeNodePtr & node)\n-    {\n-        auto * subquery_node = node->as<QueryNode>();\n-        auto * union_node = node->as<UnionNode>();\n-\n-        return (subquery_node && subquery_node->isCTE()) || (union_node && union_node->isCTE());\n-    });\n+    /** WITH section can be safely removed, because WITH section only can provide aliases to query expressions\n+      * and CTE for other sections to use.\n+      *\n+      * Example: WITH 1 AS constant, (x -> x + 1) AS lambda, a AS (SELECT * FROM test_table);\n+      */\n+    query_node_typed.getWith().getNodes().clear();\n \n     for (auto & window_node : query_node_typed.getWindow().getNodes())\n     {\n@@ -6952,9 +6951,6 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n                 scope.scope_node->formatASTForErrorMessage());\n     }\n \n-    if (query_node_typed.hasWith())\n-        resolveExpressionNodeList(query_node_typed.getWithNode(), scope, true /*allow_lambda_expression*/, false /*allow_table_expression*/);\n-\n     if (query_node_typed.getPrewhere())\n         resolveExpressionNode(query_node_typed.getPrewhere(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n \n@@ -7123,13 +7119,6 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n                 scope.scope_node->formatASTForErrorMessage());\n     }\n \n-    /** WITH section can be safely removed, because WITH section only can provide aliases to query expressions\n-      * and CTE for other sections to use.\n-      *\n-      * Example: WITH 1 AS constant, (x -> x + 1) AS lambda, a AS (SELECT * FROM test_table);\n-      */\n-    query_node_typed.getWith().getNodes().clear();\n-\n     /** WINDOW section can be safely removed, because WINDOW section can only provide window definition to window functions.\n       *\n       * Example: SELECT count(*) OVER w FROM test_table WINDOW w AS (PARTITION BY id);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02174_cte_scalar_cache.sql b/tests/queries/0_stateless/02174_cte_scalar_cache.sql\nindex 50a10834e642..86cfff214464 100644\n--- a/tests/queries/0_stateless/02174_cte_scalar_cache.sql\n+++ b/tests/queries/0_stateless/02174_cte_scalar_cache.sql\n@@ -6,7 +6,7 @@ WITH\n     ( SELECT sleep(0.0001) FROM system.one ) as a3,\n     ( SELECT sleep(0.0001) FROM system.one ) as a4,\n     ( SELECT sleep(0.0001) FROM system.one ) as a5\n-SELECT '02177_CTE_GLOBAL_ON', a5 FROM system.numbers LIMIT 100\n+SELECT '02177_CTE_GLOBAL_ON', a1, a2, a3, a4, a5 FROM system.numbers LIMIT 100\n FORMAT Null\n SETTINGS enable_global_with_statement = 1;\n \n@@ -16,17 +16,17 @@ WITH\n     ( SELECT sleep(0.0001) FROM system.one ) as a3,\n     ( SELECT sleep(0.0001) FROM system.one ) as a4,\n     ( SELECT sleep(0.0001) FROM system.one ) as a5\n-SELECT '02177_CTE_GLOBAL_OFF', a5 FROM system.numbers LIMIT 100\n+SELECT '02177_CTE_GLOBAL_OFF', a1, a2, a3, a4, a5 FROM system.numbers LIMIT 100\n         FORMAT Null\n SETTINGS enable_global_with_statement = 0;\n \n WITH\n-    ( SELECT sleep(0.0001) FROM system.one ),\n-    ( SELECT sleep(0.0001) FROM system.one ),\n-    ( SELECT sleep(0.0001) FROM system.one ),\n-    ( SELECT sleep(0.0001) FROM system.one ),\n+    ( SELECT sleep(0.0001) FROM system.one ) as a1,\n+    ( SELECT sleep(0.0001) FROM system.one ) as a2,\n+    ( SELECT sleep(0.0001) FROM system.one ) as a3,\n+    ( SELECT sleep(0.0001) FROM system.one ) as a4,\n     ( SELECT sleep(0.0001) FROM system.one ) as a5\n-SELECT '02177_CTE_NEW_ANALYZER', a5 FROM system.numbers LIMIT 100\n+SELECT '02177_CTE_NEW_ANALYZER', a1, a2, a3, a4, a5 FROM system.numbers LIMIT 100\n         FORMAT Null\n SETTINGS allow_experimental_analyzer = 1;\n \ndiff --git a/tests/queries/0_stateless/02483_elapsed_time.sh b/tests/queries/0_stateless/02483_elapsed_time.sh\nindex e3b983129fbe..fdb23d6da017 100755\n--- a/tests/queries/0_stateless/02483_elapsed_time.sh\n+++ b/tests/queries/0_stateless/02483_elapsed_time.sh\n@@ -32,7 +32,7 @@ OK_QUERY_JSON=\"\n WITH (\n         SELECT sleepEachRow(1.0)\n     ) AS sub\n-SELECT *\n+SELECT *, sub\n FROM\n (\n     SELECT *\n@@ -50,7 +50,7 @@ WITH (\n SELECT *\n FROM\n (\n-   SELECT *\n+   SELECT *, sub\n    FROM system.one\n )\n FORMAT XML\ndiff --git a/tests/queries/0_stateless/02841_with_clause_resolve.reference b/tests/queries/0_stateless/02841_with_clause_resolve.reference\nnew file mode 100644\nindex 000000000000..e2dfc4d85a9e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02841_with_clause_resolve.reference\n@@ -0,0 +1,15 @@\n+2.5\n+2.5\n+2.5\n+2.5\n+2.5\n+(9399,2858)\n+(7159,6972)\n+(7456,3524)\n+(12685,10191)\n+(12598,4979)\n+(9824,2699)\n+(5655,7793)\n+(14410,10296)\n+(16211,7662)\n+(9349,9053)\ndiff --git a/tests/queries/0_stateless/02841_with_clause_resolve.sql b/tests/queries/0_stateless/02841_with_clause_resolve.sql\nnew file mode 100644\nindex 000000000000..b416446461b4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02841_with_clause_resolve.sql\n@@ -0,0 +1,141 @@\n+set allow_experimental_analyzer = 1;\n+\n+WITH\n+    -- Input\n+    44100 AS sample_frequency\n+    , number AS tick\n+    , tick / sample_frequency AS time\n+    \n+    -- Delay\n+    , (time, wave, delay_, decay, count) -> arraySum(n1 -> wave(time - delay_ * n1), range(count)) AS delay\n+\n+    , delay(time, (time -> 0.5), 0.2, 0.5, 5) AS kick\n+    \n+SELECT\n+\n+    kick\n+\n+FROM system.numbers\n+LIMIT 5;\n+\n+WITH\n+    -- Input\n+    44100 AS sample_frequency\n+    , number AS tick\n+    , tick / sample_frequency AS time\n+    \n+    -- Output control\n+    , 1 AS master_volume\n+    , level -> least(1.0, greatest(-1.0, level)) AS clamp\n+    , level -> (clamp(level) * 0x7FFF * master_volume)::Int16 AS output\n+    , x -> (x, x) AS mono\n+    \n+    -- Basic waves\n+    , time -> sin(time * 2 * pi()) AS sine_wave\n+    , time -> time::UInt64 % 2 * 2 - 1 AS square_wave\n+    , time -> (time - floor(time)) * 2 - 1 AS sawtooth_wave\n+    , time -> abs(sawtooth_wave(time)) * 2 - 1 AS triangle_wave\n+    \n+    -- Helpers\n+    , (from, to, wave, time) -> from + ((wave(time) + 1) / 2) * (to - from) AS lfo\n+    , (from, to, steps, time) -> from + floor((time - floor(time)) * steps) / steps * (to - from) AS step_lfo\n+    , (from, to, steps, time) -> exp(step_lfo(log(from), log(to), steps, time)) AS exp_step_lfo\n+    \n+    -- Noise\n+    , time -> cityHash64(time) / 0xFFFFFFFFFFFFFFFF AS uniform_noise\n+    , time -> erf(uniform_noise(time)) AS white_noise\n+    , time -> cityHash64(time) % 2 ? 1 : -1 AS bernoulli_noise\n+    \n+    -- Distortion\n+    , (x, amount) -> clamp(x * amount) AS clipping\n+    , (x, amount) -> clamp(x > 0 ? pow(x, amount) : -pow(-x, amount)) AS power_distortion\n+    , (x, amount) -> round(x * exp2(amount)) / exp2(amount) AS bitcrush\n+    , (time, sample_frequency) -> round(time * sample_frequency) / sample_frequency AS desample\n+    , (time, wave, amount) -> (time - floor(time) < (1 - amount)) ? wave(time * (1 - amount)) : 0 AS thin\n+    , (time, wave, amount) -> wave(floor(time) + pow(time - floor(time), amount)) AS skew\n+    \n+    -- Combining\n+    , (a, b, weight) -> a * (1 - weight) + b * weight AS combine\n+    \n+    -- Envelopes\n+    , (time, offset, attack, hold, release) ->\n+        time < offset ? 0\n+        : (time < offset + attack                  ? ((time - offset) / attack)\n+        : (time < offset + attack + hold           ? 1\n+        : (time < offset + attack + hold + release ? (offset + attack + hold + release - time) / release\n+        : 0))) AS envelope\n+    \n+    , (bpm, time, offset, attack, hold, release) ->\n+        envelope(\n+            time * (bpm / 60) - floor(time * (bpm / 60)),\n+            offset,\n+            attack,\n+            hold,\n+            release) AS running_envelope\n+    \n+    -- Sequencers\n+    , (sequence, time) -> sequence[1 + time::UInt64 % length(sequence)] AS sequencer\n+    \n+    -- Delay\n+    , (time, wave, delay, decay, count) -> arraySum(n -> wave(time - delay * n) * pow(decay, n), range(count)) AS delay\n+    \n+    \n+    , delay(time, (time -> power_distortion(sine_wave(time * 80 + sine_wave(time * 2)), lfo(0.5, 1, sine_wave, time / 16))\n+            * running_envelope(60, time, 0, 0.0, 0.01, 0.1)),\n+            0.2, 0.5, 5) AS kick\n+    \n+SELECT\n+    \n+    (output(\n+        kick +\n+        delay(time, (time ->\n+            power_distortion(\n+                sine_wave(time * 50 + 1 * sine_wave(time * 100 + 1/4))\n+                    * running_envelope(60, time, 0, 0.01, 0.01, 0.1),\n+                lfo(1, 0.75, triangle_wave, time / 8))),\n+            0.2, 0.5, 10)\n+        * lfo(0.5, 1, triangle_wave, time / 7)\n+    \n+        + delay(time, (time ->\n+            power_distortion(\n+                sine_wave(time * sequencer([50, 100, 200, 400], time / 2) + 1 * sine_wave(time * sequencer([50, 100, 200], time / 4) + 1/4))\n+                    * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1),\n+                lfo(1, 0.75, triangle_wave, time / 8))),\n+            0.2, 0.5, 10)\n+        * lfo(0.5, 1, triangle_wave, 16 + time / 11)\n+    \n+        + delay(time, (time ->\n+            white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)),\n+            0.2, 0.5, 10)\n+        * lfo(0.5, 1, triangle_wave, 24 + time / 13)\n+    \n+        + sine_wave(time * 100 + 1 * sine_wave(time * 10 + 1/4))\n+            * running_envelope(120, time, 0, 0.01, 0.01, 0.1)\n+    ),\n+    \n+    output(\n+        kick +\n+        delay(time + 0.01, (time ->\n+            power_distortion(\n+                sine_wave(time * 50 + 1 * sine_wave(time * 100 + 1/4))\n+                    * running_envelope(60, time, 0, 0.01, 0.01, 0.1),\n+                lfo(1, 0.75, triangle_wave, time / 8))),\n+            0.2, 0.5, 10)\n+        * lfo(0.5, 1, triangle_wave, time / 7)\n+    \n+        + delay(time - 0.01, (time ->\n+            power_distortion(\n+                sine_wave(time * sequencer([50, 100, 200, 400], time / 2) + 1 * sine_wave(time * sequencer([50, 100, 200], time / 4) + 1/4))\n+                    * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1),\n+                lfo(1, 0.75, triangle_wave, time / 8))),\n+            0.2, 0.5, 10)\n+        * lfo(0.5, 1, triangle_wave, 16 + time / 11)\n+    \n+        + delay(time + 0.005, (time ->\n+            white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)),\n+            0.2, 0.5, 10)\n+        * lfo(0.5, 1, triangle_wave, 24 + time / 13)\n+    ))\n+    \n+FROM system.numbers\n+LIMIT 10;\n",
  "problem_statement": "[Analyzer] Bad cast in a simple query\n**Describe what's wrong**\r\n\r\n```\r\nmilovidov@milovidov-desktop:~$ clickhouse-local \r\nClickHouse local version 23.3.1.2537.\r\n\r\nmilovidov-desktop :) SET allow_experimental_analyzer = 1\r\n\r\nSET allow_experimental_analyzer = 1\r\n\r\nQuery id: 857ffa3c-786e-4f98-832a-bc100a08dcce\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.000 sec. \r\n\r\nmilovidov-desktop :) WITH\r\n                     \r\n                     -- Input\r\n                     44100 AS sample_frequency\r\n                     , number AS tick\r\n                     , tick / sample_frequency AS time\r\n                     \r\n                     -- Output control\r\n                     , 1 AS master_volume\r\n                     , level -> least(1.0, greatest(-1.0, level)) AS clamp\r\n                     , level -> (clamp(level) * 0x7FFF * master_volume)::Int16 AS output\r\n                     , x -> (x, x) AS mono\r\n                     \r\n                     -- Basic waves\r\n                     , time -> sin(time * 2 * pi()) AS sine_wave\r\n                     , time -> time::UInt64 % 2 * 2 - 1 AS square_wave\r\n                     , time -> (time - floor(time)) * 2 - 1 AS sawtooth_wave\r\n                     , time -> abs(sawtooth_wave(time)) * 2 - 1 AS triangle_wave\r\n                     \r\n                     -- Helpers\r\n                     , (from, to, wave, time) -> from + ((wave(time) + 1) / 2) * (to - from) AS lfo\r\n                     , (from, to, steps, time) -> from + floor((time - floor(time)) * steps) / steps * (to - from) AS step_lfo\r\n                     , (from, to, steps, time) -> exp(step_lfo(log(from), log(to), steps, time)) AS exp_step_lfo\r\n                     \r\n                     -- Noise\r\n                     , time -> cityHash64(time) / 0xFFFFFFFFFFFFFFFF AS uniform_noise\r\n                     , time -> erf(uniform_noise(time)) AS white_noise\r\n                     , time -> cityHash64(time) % 2 ? 1 : -1 AS bernoulli_noise\r\n                     \r\n                     -- Distortion\r\n                     , (x, amount) -> clamp(x * amount) AS clipping\r\n                     , (x, amount) -> clamp(x > 0 ? pow(x, amount) : -pow(-x, amount)) AS power_distortion\r\n                     , (x, amount) -> round(x * exp2(amount)) / exp2(amount) AS bitcrush\r\n                     , (time, sample_frequency) -> round(time * sample_frequency) / sample_frequency AS desample\r\n                     , (time, wave, amount) -> (time - floor(time) < (1 - amount)) ? wave(time * (1 - amount)) : 0 AS thin\r\n                     , (time, wave, amount) -> wave(floor(time) + pow(time - floor(time), amount)) AS skew\r\n                     \r\n                     -- Combining\r\n                     , (a, b, weight) -> a * (1 - weight) + b * weight AS combine\r\n                     \r\n                     -- Envelopes\r\n                     , (time, offset, attack, hold, release) ->\r\n                            time < offset ? 0\r\n                         : (time < offset + attack                  ? ((time - offset) / attack)\r\n                         : (time < offset + attack + hold           ? 1\r\n                         : (time < offset + attack + hold + release ? (offset + attack + hold + release - time) / release\r\n                         : 0))) AS envelope\r\n                     \r\n                     , (bpm, time, offset, attack, hold, release) ->\r\n                         envelope(\r\n                             time * (bpm / 60) - floor(time * (bpm / 60)),\r\n                             offset,\r\n                             attack,\r\n                     WITH\r\n                     \r\n                     -- Input\r\n                     44100 AS sample_frequency\r\n                     , number AS tick\r\n                     , tick / sample_frequency AS time\r\n                     \r\n                     -- Output control\r\n                     , 1 AS master_volume\r\n                     , level -> least(1.0, greatest(-1.0, level)) AS clamp\r\n                     , level -> (clamp(level) * 0x7FFF * master_volume)::Int16 AS output\r\n                     , x -> (x, x) AS mono\r\n                     \r\n                     -- Basic waves\r\n                     , time -> sin(time * 2 * pi()) AS sine_wave\r\n                     , time -> time::UInt64 % 2 * 2 - 1 AS square_wave\r\n                     , time -> (time - floor(time)) * 2 - 1 AS sawtooth_wave\r\n                     , time -> abs(sawtooth_wave(time)) * 2 - 1 AS triangle_wave\r\n                     \r\n                     -- Helpers\r\n                     , (from, to, wave, time) -> from + ((wave(time) + 1) / 2) * (to - from) AS lfo\r\n                     , (from, to, steps, time) -> from + floor((time - floor(time)) * steps) / steps * (to - from) AS step_lfo\r\n                     , (from, to, steps, time) -> exp(step_lfo(log(from), log(to), steps, time)) AS exp_step_lfo\r\n                     \r\n                     -- Noise\r\n                     , time -> cityHash64(time) / 0xFFFFFFFFFFFFFFFF AS uniform_noise\r\n                     , time -> erf(uniform_noise(time)) AS white_noise\r\n                     , time -> cityHash64(time) % 2 ? 1 : -1 AS bernoulli_noise\r\n                     \r\n                     -- Distortion\r\n                     , (x, amount) -> clamp(x * amount) AS clipping\r\n                     , (x, amount) -> clamp(x > 0 ? pow(x, amount) : -pow(-x, amount)) AS power_distortion\r\n                     , (x, amount) -> round(x * exp2(amount)) / exp2(amount) AS bitcrush\r\n                     , (time, sample_frequency) -> round(time * sample_frequency) / sample_frequency AS desample\r\n                     , (time, wave, amount) -> (time - floor(time) < (1 - amount)) ? wave(time * (1 - amount)) : 0 AS thin\r\n                     , (time, wave, amount) -> wave(floor(time) + pow(time - floor(time), amount)) AS skew\r\n                     \r\n                     -- Combining\r\n                     , (a, b, weight) -> a * (1 - weight) + b * weight AS combine\r\n                     \r\n                     -- Envelopes\r\n                     , (time, offset, attack, hold, release) ->\r\n                            time < offset ? 0\r\n                         : (time < offset + attack                  ? ((time - offset) / attack)\r\n                         : (time < offset + attack + hold           ? 1\r\n                         : (time < offset + attack + hold + release ? (offset + attack + hold + release - time) / release\r\n                         : 0))) AS envelope\r\n                     \r\n                     , (bpm, time, offset, attack, hold, release) ->\r\n                         envelope(\r\n                             time * (bpm / 60) - floor(time * (bpm / 60)),\r\n                             offset,\r\n                             attack,\r\n                             hold,\r\n                             release) AS running_envelope\r\n                     \r\n                     -- Sequencers\r\n                     , (sequence, time) -> sequence[1 + time::UInt64 % length(sequence)] AS sequencer\r\n                     \r\n                     -- Delay\r\n                     , (time, wave, delay, decay, count) -> arraySum(n -> wave(time - delay * n) * pow(decay, n), range(count)) AS delay\r\n                     \r\n                     \r\n                     , delay(time, (time -> power_distortion(sine_wave(time * 80 + sine_wave(time * 2)), lfo(0.5, 1, sine_wave, time / 16))\r\n                             * running_envelope(60, time, 0, 0.0, 0.01, 0.1)),\r\n                             0.2, 0.5, 5) AS kick\r\n                     \r\n                     SELECT\r\n                     \r\n                     (output(\r\n                         kick +\r\n                         delay(time, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * 50 + 1 * sine_wave(time * 100 + 1/4))\r\n                                     * running_envelope(60, time, 0, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, time / 7)\r\n                     \r\n                         + delay(time, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * sequencer([50, 100, 200, 400], time / 2) + 1 * sine_wave(time * sequencer([50, 100, 200], time / 4) + 1/4))\r\n                                     * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 16 + time / 11)\r\n                     \r\n                         + delay(time, (time ->\r\n                             white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 24 + time / 13)\r\n                     \r\n                         + sine_wave(time * 100 + 1 * sine_wave(time * 10 + 1/4))\r\n                             * running_envelope(120, time, 0, 0.01, 0.01, 0.1)\r\n                     ),\r\n                     \r\n                     output(\r\n                         kick +\r\n                         delay(time + 0.01, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * 50 + 1 * sine_wave(time * 100 + 1/4))\r\n                                     * running_envelope(60, time, 0, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, time / 7)\r\n                     \r\n                         + delay(time - 0.01, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * sequencer([50, 100, 200, 400], time / 2) + 1 * sine_wave(time * sequencer([50, 100, 200], time / 4) + 1/4))\r\n                                     * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 16 + time / 11)\r\n                     \r\n                         + delay(time + 0.005, (time ->\r\n                             white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 24 + time / 13)\r\n                     ))\r\n                     \r\n                     FROM system.numbers;\r\n                     \r\n\r\nWITH\r\n    44100 AS sample_frequency,\r\n    number AS tick,\r\n    tick / sample_frequency AS time,\r\n    1 AS master_volume,\r\n    level -> least(1., greatest(-1., level)) AS clamp,\r\n    level -> CAST((clamp(level) * 32767) * master_volume, 'Int16') AS output,\r\n    x -> (x, x) AS mono,\r\n    time -> sin((time * 2) * pi()) AS sine_wave,\r\n    time -> (((CAST(time, 'UInt64') % 2) * 2) - 1) AS square_wave,\r\n    time -> (((time - floor(time)) * 2) - 1) AS sawtooth_wave,\r\n    time -> ((abs(sawtooth_wave(time)) * 2) - 1) AS triangle_wave,\r\n    (from, to, wave, time) -> (from + (((wave(time) + 1) / 2) * (to - from))) AS lfo,\r\n    (from, to, steps, time) -> (from + ((floor((time - floor(time)) * steps) / steps) * (to - from))) AS step_lfo,\r\n    (from, to, steps, time) -> exp(step_lfo(log(from), log(to), steps, time)) AS exp_step_lfo,\r\n    time -> (cityHash64(time) / 18446744073709551615) AS uniform_noise,\r\n    time -> erf(uniform_noise(time)) AS white_noise,\r\n    time -> if(cityHash64(time) % 2, 1, -1) AS bernoulli_noise,\r\n    (x, amount) -> clamp(x * amount) AS clipping,\r\n    (x, amount) -> clamp(if(x > 0, pow(x, amount), -pow(-x, amount))) AS power_distortion,\r\n    (x, amount) -> (round(x * exp2(amount)) / exp2(amount)) AS bitcrush,\r\n    (time, sample_frequency) -> (round(time * sample_frequency) / sample_frequency) AS desample,\r\n    (time, wave, amount) -> if((time - floor(time)) < (1 - amount), wave(time * (1 - amount)), 0) AS thin,\r\n    (time, wave, amount) -> wave(floor(time) + pow(time - floor(time), amount)) AS skew,\r\n    (a, b, weight) -> ((a * (1 - weight)) + (b * weight)) AS combine,\r\n    (time, offset, attack, hold, release) -> if(time < offset, 0, if(time < (offset + attack), (time - offset) / attack, if(time < ((offset + attack) + hold), 1, if(time < (((offset + attack) + hold) + release), ((((offset + attack) + hold) + release) - time) / release, 0)))) AS envelope,\r\n    (bpm, time, offset, attack, hold, release) -> envelope((time * (bpm / 60)) - floor(time * (bpm / 60)), offset, attack, hold, release) AS running_envelope,\r\n    (sequence, time) -> (sequence[1 + (CAST(time, 'UInt64') % length(sequence))]) AS sequencer,\r\n    (time, wave, delay, decay, count) -> arraySum(n -> (wave(time - (delay * n)) * pow(decay, n)), range(count)) AS delay,\r\n    delay(time, time -> (power_distortion(sine_wave((time * 80) + sine_wave(time * 2)), lfo(0.5, 1, sine_wave, time / 16)) * running_envelope(60, time, 0, 0., 0.01, 0.1)), 0.2, 0.5, 5) AS kick\r\nSELECT (output((((kick + (delay(time, time -> power_distortion(sine_wave((time * 50) + (1 * sine_wave((time * 100) + (1 / 4)))) * running_envelope(60, time, 0, 0.01, 0.01, 0.1), lfo(1, 0.75, triangle_wave, time / 8)), 0.2, 0.5, 10) * lfo(0.5, 1, triangle_wave, time / 7))) + (delay(time, time -> power_distortion(sine_wave((time * sequencer([50, 100, 200, 400], time / 2)) + (1 * sine_wave((time * sequencer([50, 100, 200], time / 4)) + (1 / 4)))) * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1), lfo(1, 0.75, triangle_wave, time / 8)), 0.2, 0.5, 10) * lfo(0.5, 1, triangle_wave, 16 + (time / 11)))) + (delay(time, time -> (white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)), 0.2, 0.5, 10) * lfo(0.5, 1, triangle_wave, 24 + (time / 13)))) + (sine_wave((time * 100) + (1 * sine_wave((time * 10) + (1 / 4)))) * running_envelope(120, time, 0, 0.01, 0.01, 0.1))), output(((kick + (delay(time + 0.01, time -> power_distortion(sine_wave((time * 50) + (1 * sine_wave((time * 100) + (1 / 4)))) * running_envelope(60, time, 0, 0.01, 0.01, 0.1), lfo(1, 0.75, triangle_wave, time / 8)), 0.2, 0.5, 10) * lfo(0.5, 1, triangle_wave, time / 7))) + (delay(time - 0.01, time -> power_distortion(sine_wave((time * sequencer([50, 100, 200, 400], time / 2)) + (1 * sine_wave((time * sequencer([50, 100, 200], time / 4)) + (1 / 4)))) * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1), lfo(1, 0.75, triangle_wave, time / 8)), 0.2, 0.5, 10) * lfo(0.5, 1, triangle_wave, 16 + (time / 11)))) + (delay(time + 0.005, time -> (white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)), 0.2, 0.5, 10) * lfo(0.5, 1, triangle_wave, 24 + (time / 13)))))\r\nFROM system.numbers\r\n\r\nQuery id: 84d88935-ec0e-4522-b1dc-906c26b0a56b\r\n\r\n\r\n0 rows in set. Elapsed: 0.203 sec. \r\n\r\nReceived exception:\r\nCode: 49. DB::Exception: Bad cast from type DB::ColumnNode to DB::IdentifierNode. (LOGICAL_ERROR)\r\n```\r\n\r\nSee https://github.com/ClickHouse/NoiSQL\n",
  "hints_text": "Can not reproduce it\n```\r\nWITH\r\n                     \r\n                     -- Input\r\n                     44100 AS sample_frequency\r\n                     , number AS tick\r\n                     , tick / sample_frequency AS time\r\n                     \r\n                     -- Output control\r\n                     , 1 AS master_volume\r\n                     , level -> least(1.0, greatest(-1.0, level)) AS clamp\r\n                     , level -> (clamp(level) * 0x7FFF * master_volume)::Int16 AS output\r\n                     , x -> (x, x) AS mono\r\n                     \r\n                     -- Basic waves\r\n                     , time -> sin(time * 2 * pi()) AS sine_wave\r\n                     , time -> time::UInt64 % 2 * 2 - 1 AS square_wave\r\n                     , time -> (time - floor(time)) * 2 - 1 AS sawtooth_wave\r\n                     , time -> abs(sawtooth_wave(time)) * 2 - 1 AS triangle_wave\r\n                     \r\n                     -- Helpers\r\n                     , (from, to, wave, time) -> from + ((wave(time) + 1) / 2) * (to - from) AS lfo\r\n                     , (from, to, steps, time) -> from + floor((time - floor(time)) * steps) / steps * (to - from) AS step_lfo\r\n                     , (from, to, steps, time) -> exp(step_lfo(log(from), log(to), steps, time)) AS exp_step_lfo\r\n                     \r\n                     -- Noise\r\n                     , time -> cityHash64(time) / 0xFFFFFFFFFFFFFFFF AS uniform_noise\r\n                     , time -> erf(uniform_noise(time)) AS white_noise\r\n                     , time -> cityHash64(time) % 2 ? 1 : -1 AS bernoulli_noise\r\n                     \r\n                     -- Distortion\r\n                     , (x, amount) -> clamp(x * amount) AS clipping\r\n                     , (x, amount) -> clamp(x > 0 ? pow(x, amount) : -pow(-x, amount)) AS power_distortion\r\n                     , (x, amount) -> round(x * exp2(amount)) / exp2(amount) AS bitcrush\r\n                     , (time, sample_frequency) -> round(time * sample_frequency) / sample_frequency AS desample\r\n                     , (time, wave, amount) -> (time - floor(time) < (1 - amount)) ? wave(time * (1 - amount)) : 0 AS thin\r\n                     , (time, wave, amount) -> wave(floor(time) + pow(time - floor(time), amount)) AS skew\r\n                     \r\n                     -- Combining\r\n                     , (a, b, weight) -> a * (1 - weight) + b * weight AS combine\r\n                     \r\n                     -- Envelopes\r\n                     , (time, offset, attack, hold, release) ->\r\n                            time < offset ? 0\r\n                         : (time < offset + attack                  ? ((time - offset) / attack)\r\n                         : (time < offset + attack + hold           ? 1\r\n                         : (time < offset + attack + hold + release ? (offset + attack + hold + release - time) / release\r\n                         : 0))) AS envelope\r\n                     \r\n                     , (bpm, time, offset, attack, hold, release) ->\r\n                         envelope(\r\n                             time * (bpm / 60) - floor(time * (bpm / 60)),\r\n                             offset,\r\n                             attack,\r\n                             hold,\r\n                             release) AS running_envelope\r\n                     \r\n                     -- Sequencers\r\n                     , (sequence, time) -> sequence[1 + time::UInt64 % length(sequence)] AS sequencer\r\n                     \r\n                     -- Delay\r\n                     , (time, wave, delay, decay, count) -> arraySum(n -> wave(time - delay * n) * pow(decay, n), range(count)) AS delay\r\n                     \r\n                     \r\n                     , delay(time, (time -> power_distortion(sine_wave(time * 80 + sine_wave(time * 2)), lfo(0.5, 1, sine_wave, time / 16))\r\n                             * running_envelope(60, time, 0, 0.0, 0.01, 0.1)),\r\n                             0.2, 0.5, 5) AS kick\r\n                     \r\n                     SELECT\r\n                     \r\n                     (output(\r\n                         kick +\r\n                         delay(time, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * 50 + 1 * sine_wave(time * 100 + 1/4))\r\n                                     * running_envelope(60, time, 0, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, time / 7)\r\n                     \r\n                         + delay(time, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * sequencer([50, 100, 200, 400], time / 2) + 1 * sine_wave(time * sequencer([50, 100, 200], time / 4) + 1/4))\r\n                                     * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 16 + time / 11)\r\n                     \r\n                         + delay(time, (time ->\r\n                             white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 24 + time / 13)\r\n                     \r\n                         + sine_wave(time * 100 + 1 * sine_wave(time * 10 + 1/4))\r\n                             * running_envelope(120, time, 0, 0.01, 0.01, 0.1)\r\n                     ),\r\n                     \r\n                     output(\r\n                         kick +\r\n                         delay(time + 0.01, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * 50 + 1 * sine_wave(time * 100 + 1/4))\r\n                                     * running_envelope(60, time, 0, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, time / 7)\r\n                     \r\n                         + delay(time - 0.01, (time ->\r\n                             power_distortion(\r\n                                 sine_wave(time * sequencer([50, 100, 200, 400], time / 2) + 1 * sine_wave(time * sequencer([50, 100, 200], time / 4) + 1/4))\r\n                                     * running_envelope(60, time, 0.5, 0.01, 0.01, 0.1),\r\n                                 lfo(1, 0.75, triangle_wave, time / 8))),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 16 + time / 11)\r\n                     \r\n                         + delay(time + 0.005, (time ->\r\n                             white_noise(time) * running_envelope(60, time, 0.75, 0.01, 0.01, 0.1)),\r\n                             0.2, 0.5, 10)\r\n                         * lfo(0.5, 1, triangle_wave, 24 + time / 13)\r\n                     ))\r\n                     \r\n                     FROM system.numbers;\r\n```\nSimplified example:\r\n```sql\r\nWITH\r\n    -- Input\r\n    44100 AS sample_frequency\r\n    , number AS tick\r\n    , tick / sample_frequency AS time\r\n    \r\n    -- Delay\r\n    , (time, wave, delay_, decay, count) -> arraySum(n1 -> wave(time - delay_ * n1), range(count)) AS delay\r\n\r\n    , delay(time, (time -> 0.5), 0.2, 0.5, 5) AS kick\r\n    \r\nSELECT\r\n\r\n    kick\r\n\r\nFROM system.numbers;\r\n```",
  "created_at": "2023-08-02T16:29:30Z"
}