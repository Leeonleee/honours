{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 22011,
  "instance_id": "ClickHouse__ClickHouse-22011",
  "issue_numbers": [
    "18244"
  ],
  "base_commit": "ce67afd9e3a39e47de72f1cd4ad5cc6dbb5bb159",
  "patch": "diff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex 1f18c8944657..453edcdbbcd3 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -333,40 +333,49 @@ IMergeTreeDataPart::State IMergeTreeDataPart::getState() const\n }\n \n \n-DayNum IMergeTreeDataPart::getMinDate() const\n+std::pair<DayNum, DayNum> IMergeTreeDataPart::getMinMaxDate() const\n {\n     if (storage.minmax_idx_date_column_pos != -1 && minmax_idx.initialized)\n-        return DayNum(minmax_idx.hyperrectangle[storage.minmax_idx_date_column_pos].left.get<UInt64>());\n-    else\n-        return DayNum();\n-}\n-\n-\n-DayNum IMergeTreeDataPart::getMaxDate() const\n-{\n-    if (storage.minmax_idx_date_column_pos != -1 && minmax_idx.initialized)\n-        return DayNum(minmax_idx.hyperrectangle[storage.minmax_idx_date_column_pos].right.get<UInt64>());\n+    {\n+        const auto & hyperrectangle = minmax_idx.hyperrectangle[storage.minmax_idx_date_column_pos];\n+        return {DayNum(hyperrectangle.left.get<UInt64>()), DayNum(hyperrectangle.right.get<UInt64>())};\n+    }\n     else\n-        return DayNum();\n+        return {};\n }\n \n-time_t IMergeTreeDataPart::getMinTime() const\n+std::pair<time_t, time_t> IMergeTreeDataPart::getMinMaxTime() const\n {\n     if (storage.minmax_idx_time_column_pos != -1 && minmax_idx.initialized)\n-        return minmax_idx.hyperrectangle[storage.minmax_idx_time_column_pos].left.get<UInt64>();\n-    else\n-        return 0;\n-}\n+    {\n+        const auto & hyperrectangle = minmax_idx.hyperrectangle[storage.minmax_idx_time_column_pos];\n \n+        /// The case of DateTime\n+        if (hyperrectangle.left.getType() == Field::Types::UInt64)\n+        {\n+            assert(hyperrectangle.right.getType() == Field::Types::UInt64);\n+            return {hyperrectangle.left.get<UInt64>(), hyperrectangle.right.get<UInt64>()};\n+        }\n+        /// The case of DateTime64\n+        else if (hyperrectangle.left.getType() == Field::Types::Decimal64)\n+        {\n+            assert(hyperrectangle.right.getType() == Field::Types::Decimal64);\n \n-time_t IMergeTreeDataPart::getMaxTime() const\n-{\n-    if (storage.minmax_idx_time_column_pos != -1 && minmax_idx.initialized)\n-        return minmax_idx.hyperrectangle[storage.minmax_idx_time_column_pos].right.get<UInt64>();\n+            auto left = hyperrectangle.left.get<DecimalField<Decimal64>>();\n+            auto right = hyperrectangle.right.get<DecimalField<Decimal64>>();\n+\n+            assert(left.getScale() == right.getScale());\n+\n+            return { left.getValue() / left.getScaleMultiplier(), right.getValue() / right.getScaleMultiplier() };\n+        }\n+        else\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Part minmax index by time is neither DateTime or DateTime64\");\n+    }\n     else\n-        return 0;\n+        return {};\n }\n \n+\n void IMergeTreeDataPart::setColumns(const NamesAndTypesList & new_columns)\n {\n     columns = new_columns;\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h\nindex 83f8c672001a..92b05e5cbd2e 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h\n@@ -155,13 +155,11 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n \n     bool contains(const IMergeTreeDataPart & other) const { return info.contains(other.info); }\n \n-    /// If the partition key includes date column (a common case), these functions will return min and max values for this column.\n-    DayNum getMinDate() const;\n-    DayNum getMaxDate() const;\n+    /// If the partition key includes date column (a common case), this function will return min and max values for that column.\n+    std::pair<DayNum, DayNum> getMinMaxDate() const;\n \n-    /// otherwise, if the partition key includes dateTime column (also a common case), these functions will return min and max values for this column.\n-    time_t getMinTime() const;\n-    time_t getMaxTime() const;\n+    /// otherwise, if the partition key includes dateTime column (also a common case), this function will return min and max values for that column.\n+    std::pair<time_t, time_t> getMinMaxTime() const;\n \n     bool isEmpty() const { return rows_count == 0; }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex cf69de44a279..d02f9df4ad19 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -469,15 +469,19 @@ void MergeTreeData::checkPartitionKeyAndInitMinMax(const KeyDescription & new_pa\n     DataTypes minmax_idx_columns_types = getMinMaxColumnsTypes(new_partition_key);\n \n     /// Try to find the date column in columns used by the partition key (a common case).\n-    bool encountered_date_column = false;\n+    /// If there are no - DateTime or DateTime64 would also suffice.\n+\n+    bool has_date_column = false;\n+    bool has_datetime_column = false;\n+\n     for (size_t i = 0; i < minmax_idx_columns_types.size(); ++i)\n     {\n-        if (typeid_cast<const DataTypeDate *>(minmax_idx_columns_types[i].get()))\n+        if (isDate(minmax_idx_columns_types[i]))\n         {\n-            if (!encountered_date_column)\n+            if (!has_date_column)\n             {\n                 minmax_idx_date_column_pos = i;\n-                encountered_date_column = true;\n+                has_date_column = true;\n             }\n             else\n             {\n@@ -486,16 +490,18 @@ void MergeTreeData::checkPartitionKeyAndInitMinMax(const KeyDescription & new_pa\n             }\n         }\n     }\n-    if (!encountered_date_column)\n+    if (!has_date_column)\n     {\n         for (size_t i = 0; i < minmax_idx_columns_types.size(); ++i)\n         {\n-            if (typeid_cast<const DataTypeDateTime *>(minmax_idx_columns_types[i].get()))\n+            if (isDateTime(minmax_idx_columns_types[i])\n+                || isDateTime64(minmax_idx_columns_types[i])\n+            )\n             {\n-                if (!encountered_date_column)\n+                if (!has_datetime_column)\n                 {\n                     minmax_idx_time_column_pos = i;\n-                    encountered_date_column = true;\n+                    has_datetime_column = true;\n                 }\n                 else\n                 {\ndiff --git a/src/Storages/System/StorageSystemParts.cpp b/src/Storages/System/StorageSystemParts.cpp\nindex eece092206d2..6a643dbe1b97 100644\n--- a/src/Storages/System/StorageSystemParts.cpp\n+++ b/src/Storages/System/StorageSystemParts.cpp\n@@ -137,14 +137,17 @@ void StorageSystemParts::processNextStorage(\n         if (columns_mask[src_index++])\n             columns[res_index++]->insert(static_cast<UInt64>(part.use_count() - 1));\n \n+        auto min_max_date = part->getMinMaxDate();\n+        auto min_max_time = part->getMinMaxTime();\n+\n         if (columns_mask[src_index++])\n-            columns[res_index++]->insert(part->getMinDate());\n+            columns[res_index++]->insert(min_max_date.first);\n         if (columns_mask[src_index++])\n-            columns[res_index++]->insert(part->getMaxDate());\n+            columns[res_index++]->insert(min_max_date.second);\n         if (columns_mask[src_index++])\n-            columns[res_index++]->insert(static_cast<UInt32>(part->getMinTime()));\n+            columns[res_index++]->insert(static_cast<UInt32>(min_max_time.first));\n         if (columns_mask[src_index++])\n-            columns[res_index++]->insert(static_cast<UInt32>(part->getMaxTime()));\n+            columns[res_index++]->insert(static_cast<UInt32>(min_max_time.second));\n         if (columns_mask[src_index++])\n             columns[res_index++]->insert(part->info.partition_id);\n         if (columns_mask[src_index++])\ndiff --git a/src/Storages/System/StorageSystemPartsColumns.cpp b/src/Storages/System/StorageSystemPartsColumns.cpp\nindex 8754e4242813..703de70d17fb 100644\n--- a/src/Storages/System/StorageSystemPartsColumns.cpp\n+++ b/src/Storages/System/StorageSystemPartsColumns.cpp\n@@ -32,6 +32,8 @@ StorageSystemPartsColumns::StorageSystemPartsColumns(const StorageID & table_id_\n         {\"refcount\",                                   std::make_shared<DataTypeUInt32>()},\n         {\"min_date\",                                   std::make_shared<DataTypeDate>()},\n         {\"max_date\",                                   std::make_shared<DataTypeDate>()},\n+        {\"min_time\",                                   std::make_shared<DataTypeDateTime>()},\n+        {\"max_time\",                                   std::make_shared<DataTypeDateTime>()},\n         {\"partition_id\",                               std::make_shared<DataTypeString>()},\n         {\"min_block_number\",                           std::make_shared<DataTypeInt64>()},\n         {\"max_block_number\",                           std::make_shared<DataTypeInt64>()},\n@@ -95,8 +97,10 @@ void StorageSystemPartsColumns::processNextStorage(\n \n         /// For convenience, in returned refcount, don't add references that was due to local variables in this method: all_parts, active_parts.\n         auto use_count = part.use_count() - 1;\n-        auto min_date = part->getMinDate();\n-        auto max_date = part->getMaxDate();\n+\n+        auto min_max_date = part->getMinMaxDate();\n+        auto min_max_time = part->getMinMaxTime();\n+\n         auto index_size_in_bytes = part->getIndexSizeInBytes();\n         auto index_size_in_allocated_bytes = part->getIndexSizeInAllocatedBytes();\n \n@@ -141,9 +145,14 @@ void StorageSystemPartsColumns::processNextStorage(\n                 columns[res_index++]->insert(UInt64(use_count));\n \n             if (columns_mask[src_index++])\n-                columns[res_index++]->insert(min_date);\n+                columns[res_index++]->insert(min_max_date.first);\n+            if (columns_mask[src_index++])\n+                columns[res_index++]->insert(min_max_date.second);\n             if (columns_mask[src_index++])\n-                columns[res_index++]->insert(max_date);\n+                columns[res_index++]->insert(static_cast<UInt32>(min_max_time.first));\n+            if (columns_mask[src_index++])\n+                columns[res_index++]->insert(static_cast<UInt32>(min_max_time.second));\n+\n             if (columns_mask[src_index++])\n                 columns[res_index++]->insert(part->info.partition_id);\n             if (columns_mask[src_index++])\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01773_min_max_time_system_parts_datetime64.reference b/tests/queries/0_stateless/01773_min_max_time_system_parts_datetime64.reference\nnew file mode 100644\nindex 000000000000..1cea52ec1c2d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01773_min_max_time_system_parts_datetime64.reference\n@@ -0,0 +1,2 @@\n+2000-01-02 03:04:05\t2001-02-03 04:05:06\n+2000-01-02 03:04:05\t2001-02-03 04:05:06\ndiff --git a/tests/queries/0_stateless/01773_min_max_time_system_parts_datetime64.sql b/tests/queries/0_stateless/01773_min_max_time_system_parts_datetime64.sql\nnew file mode 100644\nindex 000000000000..5a1f809b03b5\n--- /dev/null\n+++ b/tests/queries/0_stateless/01773_min_max_time_system_parts_datetime64.sql\n@@ -0,0 +1,9 @@\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (time DateTime64(3)) ENGINE = MergeTree ORDER BY tuple() PARTITION BY toStartOfInterval(time, INTERVAL 2 YEAR);\n+\n+INSERT INTO test VALUES ('2000-01-02 03:04:05.123'), ('2001-02-03 04:05:06.789');\n+\n+SELECT min_time, max_time FROM system.parts WHERE table = 'test' AND database = currentDatabase();\n+SELECT min_time, max_time FROM system.parts_columns WHERE table = 'test' AND database = currentDatabase();\n+\n+DROP TABLE test;\n",
  "problem_statement": "Tables with DateTime64 don't have min/max_time set?\n**Describe the bug**\r\n\r\nI have a table like:\r\n\r\n```\r\nCREATE TABLE test (\r\n    time DateTime64(3)\r\n    ...\r\n) ENGINE = MergeTree()\r\nPARTITION BY toStartOfInterval(time, INTERVAL 1 HOUR)\r\n...\r\n```\r\n\r\nBut when I search in `system.parts` it does not appear to have the `min/max` columns appropriately set?\r\n\r\n```\r\npartition:                             2020-06-01 01:00:00\r\nmin_date:                              1970-01-01\r\nmax_date:                              1970-01-01\r\nmin_time:                              1970-01-01 00:00:00\r\nmax_time:                              1970-01-01 00:00:00\r\n```\r\n\r\nI assume that if these were correctly set, doing a `select toStartOfInterval(time, interval 1 day), count()` type query would be pretty instant rather than trying to scan everything? I am guessing this is due to the `DateTime64` type in use?\r\n\r\nClickhouse 20.11.3.3\r\n\n",
  "hints_text": "They are just informational columns.\r\nIt does not related to partition pruning/elimination (pruning works with DateTime64 perfectly).\r\n\r\n\n@Enmk why not?",
  "created_at": "2021-03-22T22:19:05Z"
}