diff --git a/src/Processors/tests/gtest_exception_on_incorrect_pipeline.cpp b/src/Processors/tests/gtest_exception_on_incorrect_pipeline.cpp
index b137eaf0f477..40718bd968a9 100644
--- a/src/Processors/tests/gtest_exception_on_incorrect_pipeline.cpp
+++ b/src/Processors/tests/gtest_exception_on_incorrect_pipeline.cpp
@@ -23,11 +23,11 @@ TEST(Processors, PortsConnected)
 
     connect(source->getPort(), sink->getPort());
 
-    Processors processors;
-    processors.emplace_back(std::move(source));
-    processors.emplace_back(std::move(sink));
+    auto processors = std::make_shared<Processors>();
+    processors->emplace_back(std::move(source));
+    processors->emplace_back(std::move(sink));
 
-    QueryStatus * element = nullptr;
+    QueryStatusPtr element;
     PipelineExecutor executor(processors, element);
     executor.execute(1);
 }
@@ -46,14 +46,14 @@ TEST(Processors, PortsNotConnected)
 
     /// connect(source->getPort(), sink->getPort());
 
-    Processors processors;
-    processors.emplace_back(std::move(source));
-    processors.emplace_back(std::move(sink));
+    auto processors = std::make_shared<Processors>();
+    processors->emplace_back(std::move(source));
+    processors->emplace_back(std::move(sink));
 
 #ifndef ABORT_ON_LOGICAL_ERROR
     try
     {
-        QueryStatus * element = nullptr;
+        QueryStatusPtr element;
         PipelineExecutor executor(processors, element);
         executor.execute(1);
         ASSERT_TRUE(false) << "Should have thrown.";
diff --git a/tests/queries/0_stateless/02461_cancel_finish_race.reference b/tests/queries/0_stateless/02461_cancel_finish_race.reference
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/tests/queries/0_stateless/02461_cancel_finish_race.sh b/tests/queries/0_stateless/02461_cancel_finish_race.sh
new file mode 100755
index 000000000000..7e775437da14
--- /dev/null
+++ b/tests/queries/0_stateless/02461_cancel_finish_race.sh
@@ -0,0 +1,59 @@
+#!/usr/bin/env bash
+# Tags: no-fasttest
+
+
+CURDIR=$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)
+# shellcheck source=../shell_config.sh
+. "$CURDIR"/../shell_config.sh
+
+function thread_query()
+{
+    while true; do
+        $CLICKHOUSE_CLIENT --query "SELECT count() FROM numbers_mt(10000) WHERE rand() = 0 FORMAT Null";
+    done
+}
+
+function thread_cancel()
+{
+    while true; do
+        $CLICKHOUSE_CLIENT --query "KILL QUERY WHERE current_database = '$CLICKHOUSE_DATABASE' SYNC FORMAT Null";
+    done
+}
+
+# https://stackoverflow.com/questions/9954794/execute-a-shell-function-with-timeout
+export -f thread_query;
+export -f thread_cancel;
+
+TIMEOUT=30
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+timeout $TIMEOUT bash -c thread_query 2> /dev/null &
+timeout $TIMEOUT bash -c thread_cancel 2> /dev/null &
+
+wait
