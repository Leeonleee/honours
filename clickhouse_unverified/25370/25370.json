{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25370,
  "instance_id": "ClickHouse__ClickHouse-25370",
  "issue_numbers": [
    "25368"
  ],
  "base_commit": "d2df23a959d65f45a765a9b7615714b55b291245",
  "patch": "diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 35251c7b9b7b..9fa48f6ceab7 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -1554,6 +1554,7 @@ ConjunctionNodes getConjunctionNodes(ActionsDAG::Node * predicate, std::unordere\n     struct Frame\n     {\n         const ActionsDAG::Node * node = nullptr;\n+        /// Node is a part of predicate (predicate itself, or some part of AND)\n         bool is_predicate = false;\n         size_t next_child_to_visit = 0;\n         size_t num_allowed_children = 0;\n@@ -1595,35 +1596,27 @@ ConjunctionNodes getConjunctionNodes(ActionsDAG::Node * predicate, std::unordere\n                 if (cur.node->type != ActionsDAG::ActionType::ARRAY_JOIN && cur.node->type != ActionsDAG::ActionType::INPUT)\n                     allowed_nodes.emplace(cur.node);\n             }\n-            else if (is_conjunction)\n+\n+            /// Add parts of AND to result. Do not add function AND.\n+            if (cur.is_predicate && ! is_conjunction)\n             {\n-                for (const auto * child : cur.node->children)\n+                if (allowed_nodes.count(cur.node))\n                 {\n-                    if (allowed_nodes.count(child))\n-                    {\n-                        if (allowed.insert(child).second)\n-                            conjunction.allowed.push_back(child);\n+                    if (allowed.insert(cur.node).second)\n+                        conjunction.allowed.push_back(cur.node);\n \n-                    }\n                 }\n-            }\n-            else if (cur.is_predicate)\n-            {\n-                if (rejected.insert(cur.node).second)\n-                    conjunction.rejected.push_back(cur.node);\n+                else\n+                {\n+                    if (rejected.insert(cur.node).second)\n+                        conjunction.rejected.push_back(cur.node);\n+                }\n             }\n \n             stack.pop();\n         }\n     }\n \n-    if (conjunction.allowed.empty())\n-    {\n-        /// If nothing was added to conjunction, check if it is trivial.\n-        if (allowed_nodes.count(predicate))\n-            conjunction.allowed.push_back(predicate);\n-    }\n-\n     return conjunction;\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01913_join_push_down_bug.reference b/tests/queries/0_stateless/01913_join_push_down_bug.reference\nnew file mode 100644\nindex 000000000000..386bde518ea7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_join_push_down_bug.reference\n@@ -0,0 +1,6 @@\n+1\t0\n+2\t0\n+3\t0\n+4\t0\n+5\t0\n+6\t0\ndiff --git a/tests/queries/0_stateless/01913_join_push_down_bug.sql b/tests/queries/0_stateless/01913_join_push_down_bug.sql\nnew file mode 100644\nindex 000000000000..00fd8cb5ddba\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_join_push_down_bug.sql\n@@ -0,0 +1,22 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test\n+(\n+    `t` UInt8,\n+    `flag` UInt8,\n+    `id` UInt8\n+)\n+ENGINE = MergeTree\n+PARTITION BY t\n+ORDER BY (t, id)\n+SETTINGS index_granularity = 8192;\n+\n+INSERT INTO test VALUES (1,0,1),(1,0,2),(1,0,3),(1,0,4),(1,0,5),(1,0,6),(1,1,7),(0,0,7);\n+\n+set query_plan_filter_push_down = true;\n+\n+SELECT id, flag FROM test t1\n+INNER JOIN  (SELECT DISTINCT id FROM test) AS t2 ON t1.id = t2.id\n+WHERE flag = 0 and t = 1 AND id NOT IN (SELECT 1 WHERE 0);\n+\n+DROP TABLE IF EXISTS test;\n",
  "problem_statement": "Incorrect results (ignoring WHERE) when using JOIN combined with NOT IN \nI get incorrect results as if particular WHERE condition is ignored when there is JOIN and NOT IN condition (empty set) in a query. I've created as minimal example as I could.\r\n\r\n```\r\n\r\n# Test dataset\r\nCREATE TABLE test\r\n(\r\n    `t` UInt8,\r\n    `flag` UInt8,\r\n    `id` UInt8\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY t\r\nORDER BY (t, id)\r\nSETTINGS index_granularity = 8192;\r\n\r\nINSERT INTO test VALUES (1,0,1),(1,0,2),(1,0,3),(1,0,4),(1,0,5),(1,0,6),(1,1,7),(0,0,7);\r\n\r\n# Explore dataset\r\n\r\nSELECT * FROM test\r\n\r\n\u250c\u2500t\u2500\u252c\u2500flag\u2500\u252c\u2500id\u2500\u2510\r\n\u2502 0 \u2502    0 \u2502  7 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500t\u2500\u252c\u2500flag\u2500\u252c\u2500id\u2500\u2510\r\n\u2502 1 \u2502    0 \u2502  1 \u2502\r\n\u2502 1 \u2502    0 \u2502  2 \u2502\r\n\u2502 1 \u2502    0 \u2502  3 \u2502\r\n\u2502 1 \u2502    0 \u2502  4 \u2502\r\n\u2502 1 \u2502    0 \u2502  5 \u2502\r\n\u2502 1 \u2502    0 \u2502  6 \u2502\r\n\u2502 1 \u2502    1 \u2502  7 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\r\n\r\n# Problematic query\r\n\r\nSELECT id, flag FROM test t1\r\nINNER JOIN  (SELECT DISTINCT id FROM test) AS t2 ON t1.id = t2.id\r\nWHERE flag = 0 and t = 1 AND id NOT IN (SELECT 1 WHERE 0)\r\n\r\n\u250c\u2500id\u2500\u252c\u2500flag\u2500\u2510\r\n\u2502  1 \u2502    0 \u2502\r\n\u2502  2 \u2502    0 \u2502\r\n\u2502  3 \u2502    0 \u2502\r\n\u2502  4 \u2502    0 \u2502\r\n\u2502  5 \u2502    0 \u2502\r\n\u2502  6 \u2502    0 \u2502\r\n\u2502  7 \u2502    1 \u2502 <---- this row should NOT be in result set because of flag = 0 condition in WHERE\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n# If I remove NOT IN part (which should not affect anything because it is an empty set) I got correct results\r\n\r\nSELECT id, flag FROM test t1\r\nINNER JOIN  (SELECT DISTINCT id FROM test) AS t2 ON t1.id = t2.id\r\nWHERE flag = 0 and t = 1\r\n\u250c\u2500id\u2500\u252c\u2500flag\u2500\u2510\r\n\u2502  1 \u2502    0 \u2502\r\n\u2502  2 \u2502    0 \u2502\r\n\u2502  3 \u2502    0 \u2502\r\n\u2502  4 \u2502    0 \u2502\r\n\u2502  5 \u2502    0 \u2502\r\n\u2502  6 \u2502    0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nOriginal query was a way more complex, didn't use self join and NOT IN wasn't empty set, I've boiled it down to above simple example while trying to figure out why it's happening. It seems that all things matters here: table and query structure and dataset.\r\n\r\nYes, it is reproducing in current release with default settings.\r\n21.6.4.26 - reproduced (current release)\r\n21.5.6.6 - reproduced\r\n\r\nDoes NOT reproduce in 20.10.3.30\n",
  "hints_text": "Check with `set query_plan_enable_optimizations=0`\nreproduced with (set optimize_move_to_prewhere=1, compile_expressions=1, query_plan_enable_optimizations=1)\nYes, setting `set query_plan_enable_optimizations=0` make this bug to disappear.",
  "created_at": "2021-06-16T17:52:12Z"
}