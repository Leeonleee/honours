diff --git a/src/AggregateFunctions/AggregateFunctionUniq.cpp b/src/AggregateFunctions/AggregateFunctionUniq.cpp
index bc44eb8eece1..ba4e041a4668 100644
--- a/src/AggregateFunctions/AggregateFunctionUniq.cpp
+++ b/src/AggregateFunctions/AggregateFunctionUniq.cpp
@@ -5,11 +5,8 @@
 
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDateTime.h>
-#include <DataTypes/DataTypeString.h>
-#include <DataTypes/DataTypeFixedString.h>
 #include <DataTypes/DataTypeTuple.h>
 #include <DataTypes/DataTypeUUID.h>
-#include "registerAggregateFunctions.h"
 
 
 namespace DB
@@ -18,6 +15,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
 
@@ -39,6 +37,12 @@ AggregateFunctionPtr createAggregateFunctionUniq(const std::string & name, const
 
     bool use_exact_hash_function = !isAllArgumentsContiguousInMemory(argument_types);
 
+    const WhichDataType t(argument_types[0]);
+    if (t.isAggregateFunction())
+        throw Exception(
+            "Illegal type " + argument_types[0]->getName() + " of argument for aggregate function " + name,
+            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
     if (argument_types.size() == 1)
     {
         const IDataType & argument_type = *argument_types[0];
@@ -81,6 +85,12 @@ AggregateFunctionPtr createAggregateFunctionUniq(const std::string & name, const
         throw Exception("Incorrect number of arguments for aggregate function " + name,
             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
+    const WhichDataType t(argument_types[0]);
+    if (t.isAggregateFunction())
+        throw Exception(
+            "Illegal type " + argument_types[0]->getName() + " of argument for aggregate function " + name,
+            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
+
     /// We use exact hash function if the user wants it;
     /// or if the arguments are not contiguous in memory, because only exact hash function have support for this case.
     bool use_exact_hash_function = is_exact || !isAllArgumentsContiguousInMemory(argument_types);
diff --git a/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp b/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp
index 84a9267ffe0f..e6843a326420 100644
--- a/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp
+++ b/src/AggregateFunctions/AggregateFunctionUniqCombined.cpp
@@ -17,6 +17,7 @@ namespace ErrorCodes
 {
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ARGUMENT_OUT_OF_BOUND;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
 namespace
@@ -102,6 +103,11 @@ namespace
 
         if (argument_types.empty())
             throw Exception("Incorrect number of arguments for aggregate function " + name, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+        const WhichDataType t(argument_types[0]);
+        if (t.isAggregateFunction())
+            throw Exception(
+                "Illegal type " + argument_types[0]->getName() + " of argument for aggregate function " + name,
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
         switch (precision)
         {
diff --git a/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp b/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp
index 8195bd8964c5..4a9d006cae91 100644
--- a/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp
+++ b/src/AggregateFunctions/AggregateFunctionUniqUpTo.cpp
@@ -15,6 +15,7 @@ namespace ErrorCodes
 {
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ARGUMENT_OUT_OF_BOUND;
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
 }
 
 
@@ -45,6 +46,11 @@ AggregateFunctionPtr createAggregateFunctionUniqUpTo(const std::string & name, c
     if (argument_types.empty())
         throw Exception("Incorrect number of arguments for aggregate function " + name,
             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+    const WhichDataType t(argument_types[0]);
+    if (t.isAggregateFunction())
+        throw Exception(
+            "Illegal type " + argument_types[0]->getName() + " of argument for aggregate function " + name,
+            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
 
     bool use_exact_hash_function = !isAllArgumentsContiguousInMemory(argument_types);
 
