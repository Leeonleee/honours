{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13220,
  "instance_id": "ClickHouse__ClickHouse-13220",
  "issue_numbers": [
    "13215"
  ],
  "base_commit": "d17284e7bc5d798ecc9cf8eb132f7c792ef10dce",
  "patch": "diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex 377f612d2da6..41784d5e35c2 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -161,6 +161,8 @@ static Block createBlockFromAST(const ASTPtr & node, const DataTypes & types, co\n     {\n         if (num_columns == 1)\n         {\n+            /// One column at the left of IN.\n+\n             Field value = extractValueFromNode(elem, *types[0], context);\n \n             if (!value.isNull() || context.getSettingsRef().transform_null_in)\n@@ -168,15 +170,20 @@ static Block createBlockFromAST(const ASTPtr & node, const DataTypes & types, co\n         }\n         else if (elem->as<ASTFunction>() || elem->as<ASTLiteral>())\n         {\n+            /// Multiple columns at the left of IN.\n+            /// The right hand side of in should be a set of tuples.\n+\n             Field function_result;\n             const Tuple * tuple = nullptr;\n \n+            /// Tuple can be represented as a function in AST.\n             auto * func = elem->as<ASTFunction>();\n             if (func && func->name != \"tuple\")\n             {\n                 if (!tuple_type)\n                     tuple_type = std::make_shared<DataTypeTuple>(types);\n \n+                /// If the function is not a tuple, treat it as a constant expression that returns tuple and extract it.\n                 function_result = extractValueFromNode(elem, *tuple_type, context);\n                 if (function_result.getType() != Field::Types::Tuple)\n                     throw Exception(\"Invalid type of set. Expected tuple, got \" + String(function_result.getTypeName()),\n@@ -185,10 +192,12 @@ static Block createBlockFromAST(const ASTPtr & node, const DataTypes & types, co\n                 tuple = &function_result.get<Tuple>();\n             }\n \n+            /// Tuple can be represented as a literal in AST.\n             auto * literal = elem->as<ASTLiteral>();\n             if (literal)\n             {\n-                 if (literal->value.getType() != Field::Types::Tuple)\n+                /// The literal must be tuple.\n+                if (literal->value.getType() != Field::Types::Tuple)\n                     throw Exception(\"Invalid type in set. Expected tuple, got \"\n                         + String(literal->value.getTypeName()), ErrorCodes::INCORRECT_ELEMENT_OF_SET);\n \n@@ -203,13 +212,15 @@ static Block createBlockFromAST(const ASTPtr & node, const DataTypes & types, co\n             if (tuple_values.empty())\n                 tuple_values.resize(tuple_size);\n \n+            /// Fill tuple values by evaluation of constant expressions.\n             size_t i = 0;\n             for (; i < tuple_size; ++i)\n             {\n-                Field value = tuple ? (*tuple)[i]\n+                Field value = tuple ? convertFieldToType((*tuple)[i], *types[i])\n                                     : extractValueFromNode(func->arguments->children[i], *types[i], context);\n \n-                /// If at least one of the elements of the tuple has an impossible (outside the range of the type) value, then the entire tuple too.\n+                /// If at least one of the elements of the tuple has an impossible (outside the range of the type) value,\n+                ///  then the entire tuple too.\n                 if (value.isNull() && !context.getSettings().transform_null_in)\n                     break;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01421_assert_in_in.reference b/tests/queries/0_stateless/01421_assert_in_in.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01421_assert_in_in.sql b/tests/queries/0_stateless/01421_assert_in_in.sql\nnew file mode 100644\nindex 000000000000..73f712b40158\n--- /dev/null\n+++ b/tests/queries/0_stateless/01421_assert_in_in.sql\n@@ -0,0 +1,1 @@\n+SELECT (1, 2) IN ((1, (2, 3)), (1 + 1, 1)); -- { serverError 53 }\n",
  "problem_statement": "Assertion found by fuzz test in Field cast.\nThe query\r\n\r\n```\r\nSELECT (1, 2) IN ((-9223372036854775808, (256, 10)), (3, 4), ((((((10 IN (NULL, 1048577, 1.)) IN (inf, NULL, NULL)) IN (((7 IN (-1, 2, 3, 1025, 1025)) IN (NULL, 1023 IN (inf, 1048576, (7, 100, 1024, 3)), NULL, 100.0000991821289)) IN (256, 65537), -9223372036854775808, 1048575)) IN (-2, NULL, 10 IN (NULL, 10, -2, 1.000100016593933))) IN (10 IN (NULL, 10, -2, 1.000100016593933), 1048577, 0.)) IN (65536, ((-2, 9223372036854775807 IN (-2, 10, 1025, 1., -1), 1025, 1., -1), 100, 4, 1025), NULL), 6), (7, 8), (1024, 6))\r\nSETTINGS max_temporary_columns = 4\r\n```\r\n\r\nTriggers logical error exception.\n",
  "hints_text": "```\r\nSELECT (1, 2) IN \r\n(\r\n    (1, (2, 3)), \r\n    (1 + 1, 1)\r\n)\r\n```\nCC @CurtizJ \nI'm getting \r\n```\r\nSELECT (1, 2) IN ((1, (2, 3)), (1 + 1, 1))\r\n\r\nReceived exception from server (version 20.7.1):\r\nCode: 53. DB::Exception: Received from localhost:9000. DB::Exception: Type mismatch in IN or VALUES section. Expected: UInt8. Got: Tuple.\r\n```\r\n\r\nIt's expected behavior. Looks like you choose wrong query from report. There is also\r\n```\r\nSELECT \r\n    (257, NULL, NULL),\r\n    (1, -2),\r\n    (-2, 7),\r\n    ('102.5', '0.03', NULL, NULL, NULL),\r\n    A.k,\r\n    toString((10, 0), (10.000100135803223)),\r\n    A.a,\r\n    B.b,\r\n    toString(B.t),\r\n    B.k\r\nFROM A\r\nASOF INNER JOIN B ON (A.k = B.k) AND NULL AND greaterOrEquals(B.t)\r\nORDER BY tuple(A.k) ASC\r\n\r\nReceived exception from server (version 20.7.1):\r\nCode: 1001. DB::Exception: Received from localhost:9000. DB::Exception: St12out_of_range: vector.\r\n```",
  "created_at": "2020-08-01T23:26:05Z"
}