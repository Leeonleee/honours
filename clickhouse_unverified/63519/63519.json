{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63519,
  "instance_id": "ClickHouse__ClickHouse-63519",
  "issue_numbers": [
    "63345"
  ],
  "base_commit": "44e8cf0e41557081014d39006fcb90cf3d243fb1",
  "patch": "diff --git a/src/Analyzer/Resolve/IdentifierResolveScope.h b/src/Analyzer/Resolve/IdentifierResolveScope.h\nindex 63f9d092c250..68e6cc6c7efa 100644\n--- a/src/Analyzer/Resolve/IdentifierResolveScope.h\n+++ b/src/Analyzer/Resolve/IdentifierResolveScope.h\n@@ -147,6 +147,8 @@ struct IdentifierResolveScope\n     /// Table column name to column node. Valid only during table ALIAS columns resolve.\n     ColumnNameToColumnNodeMap column_name_to_column_node;\n \n+    std::list<std::unordered_map<std::string, ColumnNodePtr> *> join_using_columns;\n+\n     /// CTE name to query node\n     std::unordered_map<std::string, QueryTreeNodePtr> cte_name_to_query_node;\n \ndiff --git a/src/Analyzer/Resolve/IdentifierResolver.cpp b/src/Analyzer/Resolve/IdentifierResolver.cpp\nindex 8ed8fcb413db..0d621087b242 100644\n--- a/src/Analyzer/Resolve/IdentifierResolver.cpp\n+++ b/src/Analyzer/Resolve/IdentifierResolver.cpp\n@@ -30,6 +30,7 @@\n #include <Analyzer/Resolve/TypoCorrection.h>\n \n #include <Core/Settings.h>\n+#include <iostream>\n \n namespace DB\n {\n@@ -329,6 +330,21 @@ bool IdentifierResolver::tryBindIdentifierToAliases(const IdentifierLookup & ide\n     return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr;\n }\n \n+bool IdentifierResolver::tryBindIdentifierToJoinUsingColumn(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)\n+{\n+    for (const auto * join_using : scope.join_using_columns)\n+    {\n+        for (const auto & [using_column_name, _] : *join_using)\n+        {\n+            // std::cerr << identifier_lookup.identifier.getFullName() << \" <===========> \" << using_column_name << std::endl;\n+            if (identifier_lookup.identifier.getFullName() == using_column_name)\n+                return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n /** Resolve identifier from table columns.\n   *\n   * 1. If table column nodes are empty or identifier is not expression lookup return nullptr.\n@@ -634,11 +650,15 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromStorage(\n             tryBindIdentifierToTableExpressions(column_identifier_lookup, table_expression_node, scope))\n             break;\n \n+        if (tryBindIdentifierToJoinUsingColumn(column_identifier_lookup, scope))\n+            break;\n+\n         qualified_identifier = std::move(qualified_identifier_with_removed_part);\n     }\n \n     auto qualified_identifier_full_name = qualified_identifier.getFullName();\n     node_to_projection_name.emplace(result_expression, std::move(qualified_identifier_full_name));\n+    // std::cerr << \"resolved from storage : \" << qualified_identifier.getFullName() << \" as \" << result_expression->dumpTree() << std::endl;\n \n     return { .resolved_identifier = result_expression, .resolve_place = IdentifierResolvePlace::JOIN_TREE };\n }\n@@ -857,8 +877,36 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const I\n     IdentifierResolveScope & scope)\n {\n     const auto & from_join_node = table_expression_node->as<const JoinNode &>();\n-    auto left_resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_join_node.getLeftTableExpression(), scope).resolved_identifier;\n-    auto right_resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_join_node.getRightTableExpression(), scope).resolved_identifier;\n+    JoinKind join_kind = from_join_node.getKind();\n+\n+    bool join_node_in_resolve_process = scope.table_expressions_in_resolve_process.contains(table_expression_node.get());\n+    std::unordered_map<std::string, ColumnNodePtr> join_using_column_name_to_column_node;\n+\n+    if (!join_node_in_resolve_process && from_join_node.isUsingJoinExpression())\n+    {\n+        auto & join_using_list = from_join_node.getJoinExpression()->as<ListNode &>();\n+        for (auto & join_using_node : join_using_list.getNodes())\n+        {\n+            auto & column_node = join_using_node->as<ColumnNode &>();\n+            join_using_column_name_to_column_node.emplace(column_node.getColumnName(), std::static_pointer_cast<ColumnNode>(join_using_node));\n+        }\n+    }\n+\n+    auto try_resolve_identifier_from_join_tree_node = [&](const QueryTreeNodePtr & join_tree_node, bool may_be_override_by_using_column)\n+    {\n+        if (may_be_override_by_using_column && !join_using_column_name_to_column_node.empty())\n+            scope.join_using_columns.push_back(&join_using_column_name_to_column_node);\n+\n+        auto res = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, join_tree_node, scope);\n+\n+        if (may_be_override_by_using_column && !join_using_column_name_to_column_node.empty())\n+            scope.join_using_columns.pop_back();\n+\n+        return std::move(res.resolved_identifier);\n+    };\n+\n+    auto left_resolved_identifier = try_resolve_identifier_from_join_tree_node(from_join_node.getLeftTableExpression(), join_kind == JoinKind::Right);\n+    auto right_resolved_identifier = try_resolve_identifier_from_join_tree_node(from_join_node.getRightTableExpression(), join_kind != JoinKind::Right);\n \n     if (!identifier_lookup.isExpressionLookup())\n     {\n@@ -875,20 +923,6 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const I\n             };\n     }\n \n-    bool join_node_in_resolve_process = scope.table_expressions_in_resolve_process.contains(table_expression_node.get());\n-\n-    std::unordered_map<std::string, ColumnNodePtr> join_using_column_name_to_column_node;\n-\n-    if (!join_node_in_resolve_process && from_join_node.isUsingJoinExpression())\n-    {\n-        auto & join_using_list = from_join_node.getJoinExpression()->as<ListNode &>();\n-        for (auto & join_using_node : join_using_list.getNodes())\n-        {\n-            auto & column_node = join_using_node->as<ColumnNode &>();\n-            join_using_column_name_to_column_node.emplace(column_node.getColumnName(), std::static_pointer_cast<ColumnNode>(join_using_node));\n-        }\n-    }\n-\n     auto check_nested_column_not_in_using = [&join_using_column_name_to_column_node, &identifier_lookup](const QueryTreeNodePtr & node)\n     {\n         /** tldr: When an identifier is resolved into the function `nested` or `getSubcolumn`, and\n@@ -950,13 +984,45 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const I\n     std::optional<JoinTableSide> resolved_side;\n     QueryTreeNodePtr resolved_identifier;\n \n-    JoinKind join_kind = from_join_node.getKind();\n+    auto convert_resolved_result_type_if_needed = [](\n+        const QueryTreeNodePtr & resolved_identifier_candidate,\n+        const std::unordered_map<std::string, ColumnNodePtr> & using_column_name_to_column_node,\n+        QueryTreeNodePtr & resolve_result,\n+        IdentifierResolveScope & current_scope,\n+        std::unordered_map<QueryTreeNodePtr, ProjectionName> & projection_name_mapping)\n+    {\n+        auto & resolved_column = resolved_identifier_candidate->as<ColumnNode &>();\n+        auto using_column_node_it = using_column_name_to_column_node.find(resolved_column.getColumnName());\n+        if (using_column_node_it != using_column_name_to_column_node.end() &&\n+            !using_column_node_it->second->getColumnType()->equals(*resolved_column.getColumnType()))\n+        {\n+            // std::cerr << \"... fixing type for \" << resolved_column.dumpTree() << std::endl;\n+            auto resolved_column_clone = std::static_pointer_cast<ColumnNode>(resolved_column.clone());\n+            resolved_column_clone->setColumnType(using_column_node_it->second->getColumnType());\n+\n+            auto projection_name_it = projection_name_mapping.find(resolved_identifier_candidate);\n+            if (projection_name_it != projection_name_mapping.end())\n+            {\n+                projection_name_mapping[resolved_column_clone] = projection_name_it->second;\n+                // std::cerr << \".. upd name \" << projection_name_it->second << \" for col \" << resolved_column_clone->dumpTree() << std::endl;\n+            }\n+\n+            resolve_result = std::move(resolved_column_clone);\n+\n+            if (!resolve_result->isEqual(*using_column_node_it->second))\n+                current_scope.join_columns_with_changed_types[resolve_result] = using_column_node_it->second;\n+        }\n+    };\n \n     /// If columns from left or right table were missed Object(Nullable('json')) subcolumns, they will be replaced\n     /// to ConstantNode(NULL), which can't be cast to ColumnNode, so we resolve it here.\n     if (auto missed_subcolumn_identifier = checkIsMissedObjectJSONSubcolumn(left_resolved_identifier, right_resolved_identifier))\n         return { .resolved_identifier = missed_subcolumn_identifier, .resolve_place = IdentifierResolvePlace::JOIN_TREE };\n \n+\n+    // for (const auto & [k, v] : join_using_column_name_to_column_node)\n+    //     std::cerr << k << \" -> \" << v->dumpTree() << std::endl;\n+\n     if (left_resolved_identifier && right_resolved_identifier)\n     {\n         auto using_column_node_it = join_using_column_name_to_column_node.end();\n@@ -1036,18 +1102,7 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const I\n         }\n         else\n         {\n-            auto & left_resolved_column = left_resolved_identifier->as<ColumnNode &>();\n-            auto using_column_node_it = join_using_column_name_to_column_node.find(left_resolved_column.getColumnName());\n-            if (using_column_node_it != join_using_column_name_to_column_node.end() &&\n-                !using_column_node_it->second->getColumnType()->equals(*left_resolved_column.getColumnType()))\n-            {\n-                auto left_resolved_column_clone = std::static_pointer_cast<ColumnNode>(left_resolved_column.clone());\n-                left_resolved_column_clone->setColumnType(using_column_node_it->second->getColumnType());\n-                resolved_identifier = std::move(left_resolved_column_clone);\n-\n-                if (!resolved_identifier->isEqual(*using_column_node_it->second))\n-                    scope.join_columns_with_changed_types[resolved_identifier] = using_column_node_it->second;\n-            }\n+            convert_resolved_result_type_if_needed(left_resolved_identifier, join_using_column_name_to_column_node, resolved_identifier, scope, node_to_projection_name);\n         }\n     }\n     else if (right_resolved_identifier)\n@@ -1061,17 +1116,7 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const I\n         }\n         else\n         {\n-            auto & right_resolved_column = right_resolved_identifier->as<ColumnNode &>();\n-            auto using_column_node_it = join_using_column_name_to_column_node.find(right_resolved_column.getColumnName());\n-            if (using_column_node_it != join_using_column_name_to_column_node.end() &&\n-                !using_column_node_it->second->getColumnType()->equals(*right_resolved_column.getColumnType()))\n-            {\n-                auto right_resolved_column_clone = std::static_pointer_cast<ColumnNode>(right_resolved_column.clone());\n-                right_resolved_column_clone->setColumnType(using_column_node_it->second->getColumnType());\n-                resolved_identifier = std::move(right_resolved_column_clone);\n-                if (!resolved_identifier->isEqual(*using_column_node_it->second))\n-                    scope.join_columns_with_changed_types[resolved_identifier] = using_column_node_it->second;\n-            }\n+            convert_resolved_result_type_if_needed(right_resolved_identifier, join_using_column_name_to_column_node, resolved_identifier, scope, node_to_projection_name);\n         }\n     }\n \n@@ -1087,10 +1132,12 @@ IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const I\n         auto nullable_resolved_identifier = convertJoinedColumnTypeToNullIfNeeded(resolved_identifier, join_kind, resolved_side, scope);\n         if (nullable_resolved_identifier)\n         {\n+            // std::cerr << \".. convert to null \" << nullable_resolved_identifier->dumpTree() << std::endl;\n             resolved_identifier = nullable_resolved_identifier;\n             /// Set the same projection name for new nullable node\n             if (projection_name_it != node_to_projection_name.end())\n             {\n+                // std::cerr << \"... upd name for null \" << projection_name_it->second << \" -> \" << resolved_identifier->dumpTree() << std::endl;\n                 node_to_projection_name.emplace(resolved_identifier, projection_name_it->second);\n             }\n         }\ndiff --git a/src/Analyzer/Resolve/IdentifierResolver.h b/src/Analyzer/Resolve/IdentifierResolver.h\nindex 854eabdedca1..abb110f4d43b 100644\n--- a/src/Analyzer/Resolve/IdentifierResolver.h\n+++ b/src/Analyzer/Resolve/IdentifierResolver.h\n@@ -48,6 +48,10 @@ class IdentifierResolver\n         const IdentifierLookup & identifier_lookup,\n         const IdentifierResolveScope & scope);\n \n+    static bool tryBindIdentifierToJoinUsingColumn(\n+        const IdentifierLookup & identifier_lookup,\n+        const IdentifierResolveScope & scope);\n+\n     static bool tryBindIdentifierToTableExpression(\n         const IdentifierLookup & identifier_lookup,\n         const QueryTreeNodePtr & table_expression_node,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03149_analyzer_join_projection_name.reference b/tests/queries/0_stateless/03149_analyzer_join_projection_name.reference\nnew file mode 100644\nindex 000000000000..f180c3869c37\n--- /dev/null\n+++ b/tests/queries/0_stateless/03149_analyzer_join_projection_name.reference\n@@ -0,0 +1,19 @@\n+analyzer=1, join with dictionary\n+   \u250c\u2500\u2500uid\u2500\u252c\u2500name\u2500\u252c\u2500gid\u2500\u252c\u2500gname\u2500\u2500\u2510\n+1. \u2502 1231 \u2502 John \u2502 1   \u2502 Group1 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+analyzer=1, join with table\n+   \u250c\u2500\u2500uid\u2500\u252c\u2500name\u2500\u252c\u2500gid\u2500\u252c\u2500gname\u2500\u2500\u2510\n+1. \u2502 1231 \u2502 John \u2502 1   \u2502 Group1 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+analyzer=0, join with dictionary\n+   \u250c\u2500\u2500uid\u2500\u252c\u2500name\u2500\u252c\u2500gid\u2500\u252c\u2500gname\u2500\u2500\u2510\n+1. \u2502 1231 \u2502 John \u2502 1   \u2502 Group1 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+analyzer=0, join with table\n+   \u250c\u2500\u2500uid\u2500\u252c\u2500name\u2500\u252c\u2500gid\u2500\u252c\u2500gname\u2500\u2500\u2510\n+1. \u2502 1231 \u2502 John \u2502 1   \u2502 Group1 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/tests/queries/0_stateless/03149_analyzer_join_projection_name.sql b/tests/queries/0_stateless/03149_analyzer_join_projection_name.sql\nnew file mode 100644\nindex 000000000000..6d40dd6fb8f7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03149_analyzer_join_projection_name.sql\n@@ -0,0 +1,51 @@\n+DROP DATABASE IF EXISTS db_for_dict_03149;\n+CREATE DATABASE db_for_dict_03149;\n+\n+CREATE TABLE db_for_dict_03149.users (uid Int16, name String, gid LowCardinality(String), gname LowCardinality(String))\n+  ENGINE=MergeTree order by tuple();\n+CREATE TABLE db_for_dict_03149.groups (gid LowCardinality(String), gname LowCardinality(String))\n+  ENGINE=MergeTree order by tuple();\n+\n+CREATE DICTIONARY db_for_dict_03149.groups_dict (\n+    gid String, gname String\n+)\n+PRIMARY KEY gid, gname\n+LAYOUT(COMPLEX_KEY_HASHED())\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() QUERY 'select * from db_for_dict_03149.groups'))\n+LIFETIME(MIN 0 MAX 0);\n+\n+\n+INSERT INTO db_for_dict_03149.groups VALUES ('1', 'Group1');\n+\n+INSERT INTO db_for_dict_03149.users VALUES (1231, 'John', '1', 'Group1');\n+\n+select 'analyzer=1, join with dictionary';\n+\n+SELECT u.uid, u.name, u.gid, u.gname\n+FROM db_for_dict_03149.users u left join db_for_dict_03149.groups_dict g using gid, gname\n+format PrettyCompactMonoBlock;\n+\n+select '';\n+select 'analyzer=1, join with table';\n+\n+SELECT u.uid, u.name, u.gid, u.gname\n+FROM db_for_dict_03149.users u left join db_for_dict_03149.groups g using gid, gname\n+format PrettyCompactMonoBlock;\n+\n+\n+set allow_experimental_analyzer=0;\n+\n+select '';\n+select 'analyzer=0, join with dictionary';\n+\n+SELECT u.uid, u.name, u.gid, u.gname\n+FROM db_for_dict_03149.users u left join db_for_dict_03149.groups_dict g using gid, gname\n+format PrettyCompactMonoBlock;\n+\n+select '';\n+select 'analyzer=0, join with table';\n+SELECT u.uid, u.name, u.gid, u.gname\n+FROM db_for_dict_03149.users u left join db_for_dict_03149.groups g using gid, gname\n+format PrettyCompactMonoBlock;\n+\n+DROP DATABASE IF EXISTS db_for_dict_03149;\ndiff --git a/tests/queries/0_stateless/03149_analyzer_join_projection_name_2.reference b/tests/queries/0_stateless/03149_analyzer_join_projection_name_2.reference\nnew file mode 100644\nindex 000000000000..7ac7783b26e8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03149_analyzer_join_projection_name_2.reference\n@@ -0,0 +1,6 @@\n+   \u250c\u2500\u2500uid\u2500\u252c\u2500name\u2500\u2500\u2500\u252c\u2500gid\u2500\u252c\u2500gname\u2500\u2500\u2510\n+1. \u2502 1231 \u2502 John   \u2502 1   \u2502 Group1 \u2502\n+2. \u2502 1234 \u2502 Test   \u2502 2   \u2502 Group1 \u2502\n+3. \u2502 6666 \u2502 Ksenia \u2502 1   \u2502 Group1 \u2502\n+4. \u2502 8888 \u2502 Alice  \u2502 1   \u2502 Group1 \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/tests/queries/0_stateless/03149_analyzer_join_projection_name_2.sql b/tests/queries/0_stateless/03149_analyzer_join_projection_name_2.sql\nnew file mode 100644\nindex 000000000000..ea4122f33eaa\n--- /dev/null\n+++ b/tests/queries/0_stateless/03149_analyzer_join_projection_name_2.sql\n@@ -0,0 +1,33 @@\n+DROP DATABASE IF EXISTS db_for_dict_03149;\n+CREATE DATABASE db_for_dict_03149;\n+\n+CREATE TABLE db_for_dict_03149.users (uid Int16, name String, gid LowCardinality(String), gname LowCardinality(String))\n+  ENGINE=MergeTree order by tuple();\n+CREATE TABLE db_for_dict_03149.groups (gid LowCardinality(String), gname LowCardinality(String))\n+  ENGINE=MergeTree order by tuple();\n+\n+CREATE TABLE db_for_dict_03149.target (uid Int16, name String, gid LowCardinality(String), gname LowCardinality(String))\n+  ENGINE=MergeTree order by tuple();\n+\n+CREATE DICTIONARY db_for_dict_03149.groups_dict (\n+    gid String, gname String\n+)\n+PRIMARY KEY gid, gname\n+LAYOUT(COMPLEX_KEY_HASHED())\n+SOURCE(CLICKHOUSE(QUERY 'select * from db_for_dict_03149.groups'))\n+LIFETIME(MIN 0 MAX 0);\n+\n+CREATE MATERIALIZED VIEW db_for_dict_03149.mv to db_for_dict_03149.target AS\n+SELECT u.uid, u.name, u.gid, u.gname\n+FROM db_for_dict_03149.users u left join db_for_dict_03149.groups_dict g using gid, gname;\n+\n+INSERT INTO db_for_dict_03149.groups VALUES ('1', 'Group1');\n+\n+INSERT INTO db_for_dict_03149.users VALUES (1231, 'John', '1', 'Group1');\n+INSERT INTO db_for_dict_03149.users VALUES (6666, 'Ksenia', '1', 'Group1');\n+INSERT INTO db_for_dict_03149.users VALUES (8888, 'Alice', '1', 'Group1');\n+INSERT INTO db_for_dict_03149.users VALUES (1234, 'Test', '2', 'Group1');\n+\n+SELECT * FROM db_for_dict_03149.target ORDER BY uid format PrettyCompactMonoBlock;\n+\n+DROP DATABASE IF EXISTS db_for_dict_03149;\ndiff --git a/tests/queries/0_stateless/03408_cte_self_reference.sql b/tests/queries/0_stateless/03408_cte_self_reference.sql\nindex 3284a03cb3f6..8e6ce4ec747e 100644\n--- a/tests/queries/0_stateless/03408_cte_self_reference.sql\n+++ b/tests/queries/0_stateless/03408_cte_self_reference.sql\n@@ -1,3 +1,4 @@\n+-- Tags: no-tsan\n SET enable_analyzer = 1;\n \n WITH `cte1` AS (\n",
  "problem_statement": "Materialize view doesn't populate columns after join and migration to 24.3.2.23\n**Describe what's wrong**\r\n\r\nAfter migration from 23.8 to 24.3 I noticed that some columns are not populated in the destination table (after materialized view processing). After investigating and narrowing down the issue, I noticed that it applies only when we use join in the materialized view and final column names are the same as in the joined table. It doesn't matter if columns from the joined table are used.\r\n\r\nCREATE TABLE IF NOT EXISTS bug_reproduction (\r\n    missingId                  LowCardinality(String),\r\n    someId                  LowCardinality(String),\r\n    dateTime                    DateTime64(3, 'UTC')\r\n) ENGINE MergeTree()\r\nPARTITION BY toYYYYMM(dateTime)\r\nORDER BY (someId, dateTime);\r\n\r\n\r\nCREATE MATERIALIZED VIEW IF NOT EXISTS bug_reproduction_mv TO bug_reproduction AS\r\nselect\r\n    st.missingId,\r\n    st.someId,\r\n    st.dateTime\r\nfrom\r\n     source_table st\r\nLEFT JOIN joined_table i\r\nusing (missingId, some_column1, some_column2, some_column3);\r\n\r\nIf I remove the left join from materialized view or change the column names in the final table (and use aliast in MV) the missingId is populated correctly. It also worked correctly in version 23.8.\r\n\r\n**Expected behavior**\r\n\r\nmissingId should be populated\r\n\n",
  "hints_text": "try\r\n\r\n```\r\nCREATE MATERIALIZED VIEW IF NOT EXISTS bug_reproduction_mv TO bug_reproduction AS\r\nselect\r\nst.missingId as missingId,\r\nst.someId as someId,\r\nst.dateTime as dateTime\r\n...\r\n```\r\n\n@p-pekala  I cannot reproduce it https://fiddle.clickhouse.com/8fa47363-5efa-47aa-9fbc-f9b2332d8ac4\n@den-crane Yes the alias seems to help. I also updated your example that reproduces the problem (not sure which modification changed the behavior but I adjusted it to more like my case - with a dictionary and different types).\n>I also updated your example that reproduces the problem\r\n\r\nYou cannot update my example. fiddle generates a different url on each execution. You need to share your own URL.\nright: https://fiddle.clickhouse.com/a7a28ab1-1675-4da6-a573-d4d83bd40a0d\nrelated to an `allow_experimental_analyzer` and the join with a dictionary.\r\n\r\nhttps://fiddle.clickhouse.com/76d74308-b8ba-4df6-b519-3b0de9b120b5\nIn the `QueryAnalyzer::tryResolveIdentifierFromJoin` function resolved column is promoted to the common type of columns in the both tables.\r\nhttps://github.com/ClickHouse/ClickHouse/blob/92bb69e062bea800bd7eaeb0b5cb95f70448d7bf/src/Analyzer/Passes/QueryAnalysisPass.cpp#L3622-L3624\r\nCurrently when this promotion takes place, `node_to_projection_name` hash table is not updated, so projection name is not properly calculated and the fall back is used:\r\nhttps://github.com/ClickHouse/ClickHouse/blob/92bb69e062bea800bd7eaeb0b5cb95f70448d7bf/src/Analyzer/Passes/QueryAnalysisPass.cpp#L6370\r\nI'm working on the fix.",
  "created_at": "2024-05-08T11:53:36Z"
}