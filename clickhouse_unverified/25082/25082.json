{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25082,
  "instance_id": "ClickHouse__ClickHouse-25082",
  "issue_numbers": [
    "24011"
  ],
  "base_commit": "fa35383071be1054d06e2c4e8a090f06ffa23b86",
  "patch": "diff --git a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\nindex 3cb8004a29f6..65848e4fbb95 100644\n--- a/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\n+++ b/src/Interpreters/JoinToSubqueryTransformVisitor.cpp\n@@ -91,7 +91,20 @@ class ExtractAsterisksMatcher\n             {\n                 if (should_add_column_predicate(column.name))\n                 {\n-                    auto identifier = std::make_shared<ASTIdentifier>(std::vector<String>{it->first, column.name});\n+                    ASTPtr identifier;\n+                    if (it->first.empty())\n+                        /// We want tables from JOIN to have aliases.\n+                        /// But it is possible to set joined_subquery_requires_alias = 0,\n+                        /// and write a query like `select * FROM (SELECT 1), (SELECT 1), (SELECT 1)`.\n+                        /// If so, table name will be empty here.\n+                        ///\n+                        /// We cannot create compound identifier with empty part (there is an assert).\n+                        /// So, try our luck and use only column name.\n+                        /// (Rewriting AST for JOIN is not an efficient design).\n+                        identifier = std::make_shared<ASTIdentifier>(column.name);\n+                    else\n+                        identifier = std::make_shared<ASTIdentifier>(std::vector<String>{it->first, column.name});\n+\n                     new_select_expression_list->children.emplace_back(std::move(identifier));\n                 }\n             }\ndiff --git a/src/Parsers/ASTIdentifier.cpp b/src/Parsers/ASTIdentifier.cpp\nindex 54ccc155dbfc..02430cb40f7d 100644\n--- a/src/Parsers/ASTIdentifier.cpp\n+++ b/src/Parsers/ASTIdentifier.cpp\n@@ -80,7 +80,7 @@ void ASTIdentifier::setShortName(const String & new_name)\n     name_parts = {new_name};\n \n     bool special = semantic->special;\n-    //how about keep the semantic info here, such as table\n+    /// How about keep the semantic info here, such as table\n     auto table = semantic->table;\n \n     *semantic = IdentifierSemanticImpl();\n@@ -116,8 +116,14 @@ void ASTIdentifier::formatImplWithoutAlias(const FormatSettings & settings, Form\n             if (i != 0)\n                 settings.ostr << '.';\n \n-            if (name_parts[i].empty())\n-                children[j++]->formatImpl(settings, state, frame);\n+            /// Some AST rewriting code, like IdentifierSemantic::setColumnLongName,\n+            /// does not respect children of identifier.\n+            /// Here we also ignore children if they are empty.\n+            if (name_parts[i].empty() && j < children.size())\n+            {\n+                children[j]->formatImpl(settings, state, frame);\n+                ++j;\n+            }\n             else\n                 format_element(name_parts[i]);\n         }\n@@ -125,7 +131,7 @@ void ASTIdentifier::formatImplWithoutAlias(const FormatSettings & settings, Form\n     else\n     {\n         const auto & name = shortName();\n-        if (name.empty())\n+        if (name.empty() && !children.empty())\n             children.front()->formatImpl(settings, state, frame);\n         else\n             format_element(name);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01890_cross_join_explain_crash.reference b/tests/queries/0_stateless/01890_cross_join_explain_crash.reference\nnew file mode 100644\nindex 000000000000..76315843adb0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01890_cross_join_explain_crash.reference\n@@ -0,0 +1,3 @@\n+2\t1\t1\n+1\t2\t1\n+1\t1\t2\ndiff --git a/tests/queries/0_stateless/01890_cross_join_explain_crash.sql b/tests/queries/0_stateless/01890_cross_join_explain_crash.sql\nnew file mode 100644\nindex 000000000000..20a1956ea6b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01890_cross_join_explain_crash.sql\n@@ -0,0 +1,8 @@\n+SET joined_subquery_requires_alias = 0;\n+select * FROM (SELECT 1), (SELECT 1), (SELECT 1); -- { serverError 352 }\n+\n+-- This queries work by luck.\n+-- Feel free to remove then if it is the only failed test.\n+select * from (select 2), (select 1) as a, (select 1) as b;\n+select * from (select 1) as a, (select 2), (select 1) as b;\n+select * from (select 1) as a, (select 1) as b, (select 2);\n",
  "problem_statement": "EXPLAIN SYNTAX Causing Segfault v21.3\nClickHouse v21.3.9.1\r\n\r\n```\r\n# clickhouse-client\r\nClickHouse client version 21.3.9.1.\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 21.3.9 revision 54447.\r\n\r\nhostname :)\r\n\r\nEXPLAIN SYNTAX\r\nSELECT *\r\nFROM \r\n(\r\n    SELECT 1\r\n)\r\n,\r\n(\r\n    SELECT 1\r\n)\r\n,\r\n(\r\n    SELECT 1\r\n)\r\n\r\nQuery id: 509c46c9-5f96-4bb7-bdcd-4a3e9169abce\r\n\r\n[hostname] 2021.05.11 15:19:22.906838 [ 28452 ] <Fatal> BaseDaemon: ########################################\r\n[hostname] 2021.05.11 15:19:22.907377 [ 28452 ] <Fatal> BaseDaemon: (version 21.3.9.1, build id: 1DD0C685978F2988C19E01ABDC698C78A31B3E5C) (from thread 26179) (query_id: 509c46c9-5f96-4bb7-bdcd-4a3e9169abce) Received signal Segmentation fault (\r\n11)\r\n[hostname] 2021.05.11 15:19:22.907669 [ 28452 ] <Fatal> BaseDaemon: Address: NULL pointer. Access: read. Address not mapped to object.\r\n[hostname] 2021.05.11 15:19:22.907855 [ 28452 ] <Fatal> BaseDaemon: Stack trace: 0x116ac6a1 0x116da613 0x116a349c 0x116bf70e 0x116fffdf 0xeb587c0 0xeb3a4af 0xeb394f1 0xeb06663 0xeb06980 0xeb06980 0xeb06980 0xeb03e27 0xeb036a2 0xf00801b 0xf00671\r\n3 0xf7a5c6d 0xf7b80f9 0x11e9533f 0x11e96d51 0x11fcf2a9 0x11fcb0fa 0x7f462cc0f494 0x7f462c951aff\r\n[hostname] 2021.05.11 15:19:22.908295 [ 28452 ] <Fatal> BaseDaemon: 1. DB::ASTIdentifier::formatImplWithoutAlias(DB::IAST::FormatSettings const&, DB::IAST::FormatState&, DB::IAST::FormatStateStacked) const @ 0x116ac6a1 in /usr/bin/clickhouse  \r\n[hostname] 2021.05.11 15:19:22.908483 [ 28452 ] <Fatal> BaseDaemon: 2. DB::ASTWithAlias::formatImpl(DB::IAST::FormatSettings const&, DB::IAST::FormatState&, DB::IAST::FormatStateStacked) const @ 0x116da613 in /usr/bin/clickhouse               \r\n[hostname] 2021.05.11 15:19:22.908694 [ 28452 ] <Fatal> BaseDaemon: 3. DB::ASTExpressionList::formatImpl(DB::IAST::FormatSettings const&, DB::IAST::FormatState&, DB::IAST::FormatStateStacked) const @ 0x116a349c in /usr/bin/clickhouse          \r\n[hostname] 2021.05.11 15:19:22.908985 [ 28452 ] <Fatal> BaseDaemon: 4. DB::ASTSelectQuery::formatImpl(DB::IAST::FormatSettings const&, DB::IAST::FormatState&, DB::IAST::FormatStateStacked) const @ 0x116bf70e in /usr/bin/clickhouse             \r\n[hostname] 2021.05.11 15:19:22.909307 [ 28452 ] <Fatal> BaseDaemon: 5. DB::IAST::formatForErrorMessage() const @ 0x116fffdf in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.910119 [ 28452 ] <Fatal> BaseDaemon: 6. DB::InDepthNodeVisitor<DB::JoinToSubqueryTransformMatcher, true, std::__1::shared_ptr<DB::IAST> >::visit(std::__1::shared_ptr<DB::IAST>&) @ 0xeb587c0 in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.911184 [ 28452 ] <Fatal> BaseDaemon: 7. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::o\r\nptional<DB::Pipe>, std::__1::shared_ptr<DB::IStorage> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_tr\r\naits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&) @ 0xeb3a4af in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.912077 [ 28452 ] <Fatal> BaseDaemon: 8. DB::InterpreterSelectQuery::InterpreterSelectQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic\r\n_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0xeb394f1 in /usr/bin/clickhouse                                      \r\n[hostname] 2021.05.11 15:19:22.912243 [ 28452 ] <Fatal> BaseDaemon: 9. ? @ 0xeb06663 in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.912493 [ 28452 ] <Fatal> BaseDaemon: 10. ? @ 0xeb06980 in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.912700 [ 28452 ] <Fatal> BaseDaemon: 11. ? @ 0xeb06980 in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.912870 [ 28452 ] <Fatal> BaseDaemon: 12. ? @ 0xeb06980 in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.913017 [ 28452 ] <Fatal> BaseDaemon: 13. DB::InterpreterExplainQuery::executeImpl() @ 0xeb03e27 in /usr/bin/clickhouse                                                                                              \r\n[hostname] 2021.05.11 15:19:22.913295 [ 28452 ] <Fatal> BaseDaemon: 14. DB::InterpreterExplainQuery::execute() @ 0xeb036a2 in /usr/bin/clickhouse                                                                                                  \r\n[hostname] 2021.05.11 15:19:22.913478 [ 28452 ] <Fatal> BaseDaemon: 15. ? @ 0xf00801b in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.913753 [ 28452 ] <Fatal> BaseDaemon: 16. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) @ 0\r\nxf006713 in /usr/bin/clickhouse\r\n[hostname] 2021.05.11 15:19:22.914271 [ 28452 ] <Fatal> BaseDaemon: 17. DB::TCPHandler::runImpl() @ 0xf7a5c6d in /usr/bin/clickhouse                                                                                                               \r\n[hostname] 2021.05.11 15:19:22.914513 [ 28452 ] <Fatal> BaseDaemon: 18. DB::TCPHandler::run() @ 0xf7b80f9 in /usr/bin/clickhouse                                                                                                                   \r\n[hostname] 2021.05.11 15:19:22.914714 [ 28452 ] <Fatal> BaseDaemon: 19. Poco::Net::TCPServerConnection::start() @ 0x11e9533f in /usr/bin/clickhouse                                                                                                \r\n[hostname] 2021.05.11 15:19:22.914919 [ 28452 ] <Fatal> BaseDaemon: 20. Poco::Net::TCPServerDispatcher::run() @ 0x11e96d51 in /usr/bin/clickhouse                                                                                                  \r\n[hostname] 2021.05.11 15:19:22.915188 [ 28452 ] <Fatal> BaseDaemon: 21. Poco::PooledThread::run() @ 0x11fcf2a9 in /usr/bin/clickhouse                                                                                                              \r\n[hostname] 2021.05.11 15:19:22.915362 [ 28452 ] <Fatal> BaseDaemon: 22. Poco::ThreadImpl::runnableEntry(void*) @ 0x11fcb0fa in /usr/bin/clickhouse                                                                                                 \r\n[hostname] 2021.05.11 15:19:22.915607 [ 28452 ] <Fatal> BaseDaemon: 23. start_thread @ 0x7494 in /lib/x86_64-linux-gnu/libpthread-2.24.so                                                                                                          \r\n[hostname] 2021.05.11 15:19:22.916040 [ 28452 ] <Fatal> BaseDaemon: 24. clone @ 0xe8aff in /lib/x86_64-linux-gnu/libc-2.24.so                                                                                                                      \r\n[hostname] 2021.05.11 15:19:31.771616 [ 28452 ] <Fatal> BaseDaemon: Calculated checksum of the binary: 5F45ECE08DC475DC578C3275037D7A34. There is no information about the reference checksum.                                                     \r\n\r\nException on client:\r\nCode: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000\r\n\r\nConnecting to localhost:9000 as user default.\r\nCode: 210. DB::NetException: Connection refused (localhost:9000)\r\n```\n",
  "hints_text": "Confirmed. Also needs setting: \r\n```\r\nset joined_subquery_requires_alias=0\r\n```\r\n\nYes, with `joined_subquery_requires_alias=1` it's not crashing\r\n```\r\n:) select * FROM (SELECT 1), (SELECT 1), (SELECT 1);\r\n\r\nSELECT *\r\nFROM \r\n(\r\n    SELECT 1\r\n)\r\n, \r\n(\r\n    SELECT 1\r\n)\r\n, \r\n(\r\n    SELECT 1\r\n)\r\n\r\nQuery id: 00d48d73-781f-483d-8b2a-329d207e7865\r\n\r\n\r\n0 rows in set. Elapsed: 0.120 sec. \r\n\r\nReceived exception from server (version 21.3.9):\r\nCode: 206. DB::Exception: Received from localhost:9000. DB::Exception: No alias for subquery or table function in JOIN (set joined_subquery_requires_alias=0 to disable restriction). While processing '(SELECT 1)'. \r\n\r\nhostname :) set joined_subquery_requires_alias=0;\r\n                                                                                                                                                                                                                                                                      \r\nSET joined_subquery_requires_alias = 0                                                                                                                                                                                                                                \r\n                                                                                                                                                                                                                                                                      \r\nQuery id: 198f9e92-4662-4940-acad-135884a197f1                                                                                                                                                                                                                        \r\n                                                                                                                                                                                                                                                                      \r\nOk.                                                                                                                                                                                                                                                                   \r\n                                                                                                                                                                                                                                                                      \r\n0 rows in set. Elapsed: 0.003 sec.                                                                                                                                                                                                                                    \r\n                                                                                                                                                                                                                                                                      \r\nhostname :) select * FROM (SELECT 1), (SELECT 1), (SELECT 1);                                                                                                                                                                          \r\n                                                                                                                                                                                                                                                                      \r\nSELECT *                                                                                                                                                                                                                                                              \r\nFROM                                                                                                                                                                                                                                                                  \r\n(                                                                                                                                                                                                                                                                     \r\n    SELECT 1                                                                                                                                                                                                                                                          \r\n)                                                                                                                                                                                                                                                                     \r\n,\r\n(                                                                                                                                                                                                                                                                     \r\n    SELECT 1\r\n)                                                                                                                                                                                                                                                                     \r\n,                                                                                                                                                                                                                                                                     \r\n(                                                                                                                                                                                                                                                                     \r\n    SELECT 1                                                                                                                                                                                                                                                          \r\n)                                                                                                                                                                                                                                                                     \r\n                                                                                                                                                                                                                                                                      \r\nQuery id: 43237d55-1bed-492c-9150-0064fbc22823                                                                                                                                                                                                                        \r\n                                                                                                                                                                                                                                                                      \r\n[hostname] 2021.05.11 15:31:36.928578 [ 21647 ] <Fatal> BaseDaemon: ########################################                                                                                                                                       \r\n[hostname] 2021.05.11 15:31:36.929007 [ 21647 ] <Fatal> BaseDaemon: (version 21.3.9.1, build id: 1DD0C685978F2988C19E01ABDC698C78A31B3E5C) (from thread 1313) (query_id: 43237d55-1bed-492c-9150-0064fbc22823) Received signal Segmentation fault (1\r\n1)\r\n```\r\n\r\nI actually just realized that\r\n```\r\nselect * FROM (SELECT 1), (SELECT 1), (SELECT 1);  \r\n```\r\nquery causing a problem, when\r\n```\r\nselect * FROM (SELECT 1), (SELECT 1);  \r\n```\r\nworks fine. So, it's not a problem with `EXPLAIN SYNTAX`\n@KochetovNicolai This issue is of high priority and cannot be ignored.",
  "created_at": "2021-06-08T14:00:09Z",
  "modified_files": [
    "src/Interpreters/JoinToSubqueryTransformVisitor.cpp",
    "src/Parsers/ASTIdentifier.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01890_cross_join_explain_crash.reference",
    "b/tests/queries/0_stateless/01890_cross_join_explain_crash.sql"
  ]
}