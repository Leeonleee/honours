{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79854,
  "instance_id": "ClickHouse__ClickHouse-79854",
  "issue_numbers": [
    "78161"
  ],
  "base_commit": "15ad4779c89ccff38662599a952c921c21d37012",
  "patch": "diff --git a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\nindex 200b11e763dc..77b5556a7e84 100644\n--- a/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n+++ b/ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt\n@@ -2484,6 +2484,7 @@ positionCaseInsensitiveUTF\n positionUTF\n positiveModulo\n positiveModuloOrNull\n+postfilter\n postfix\n postfixes\n postgres\n@@ -2501,6 +2502,7 @@ prefetched\n prefetches\n prefetching\n prefetchsize\n+prefilter\n preflight\n preimage\n preloaded\ndiff --git a/docs/en/engines/table-engines/mergetree-family/annindexes.md b/docs/en/engines/table-engines/mergetree-family/annindexes.md\nindex db4e9fc02997..e640321f83d4 100644\n--- a/docs/en/engines/table-engines/mergetree-family/annindexes.md\n+++ b/docs/en/engines/table-engines/mergetree-family/annindexes.md\n@@ -78,7 +78,7 @@ ClickHouse provides a special \"vector similarity\" index to perform approximate n\n :::note\n Vector similarity indexes are currently experimental.\n To enable them, please first run `SET allow_experimental_vector_similarity_index = 1`.\n-If you run into problems, kindly open an issue at github.com/clickhouse/clickhouse/issues.\n+If you run into problems, kindly open an issue in the [ClickHouse repository](https://github.com/clickhouse/clickhouse/issues).\n :::\n \n ### Creating a Vector Similarity Index {#creating-a-vector-similarity-index}\n@@ -174,13 +174,13 @@ LIMIT <N>\n ClickHouse's query optimizer tries to match above query template and make use of available vector similarity indexes.\n A query can only use a vector similarity index if the distance function in the SELECT query is the same as the distance function in the index definition.\n \n-Advanced users may provide a custom value for setting [hnsw_candidate_list_size_for_search](../../../operations/settings/settings.md#hnsw_candidate_list_size_for_search) (also know as HNSW hyperparameter `ef_search`) to tune the size of the candidate list during search (e.g.  `SELECT [...] SETTINGS hnsw_candidate_list_size_for_search = <value>`).\n+Advanced users may provide a custom value for setting [hnsw_candidate_list_size_for_search](../../../operations/settings/settings.md#hnsw_candidate_list_size_for_search) (also know as HNSW hyperparameter \"ef_search\") to tune the size of the candidate list during search (e.g.  `SELECT [...] SETTINGS hnsw_candidate_list_size_for_search = <value>`).\n The default value of the setting 256 works well in the majority of use cases.\n Higher setting values mean better accuracy at the cost of slower performance.\n \n If the query can use a vector similarity index, ClickHouse checks that the LIMIT `<N>` provided in SELECT queries is within reasonable bounds.\n More specifically, an error is returned if `<N>` is bigger than the value of setting [max_limit_for_vector_search_queries](../../../operations/settings/settings.md#max_limit_for_vector_search_queries) with default value 100.\n-Too large LIMITs can slow down searches and usually indicate a usage error.\n+Too large LIMIT values can slow down searches and usually indicate a usage error.\n \n To check if a SELECT query uses a vector similarity index, you can prefix the query with `EXPLAIN indexes = 1`.\n \n@@ -231,23 +231,22 @@ To enforce index usage, you can run the SELECT query with setting [force_data_sk\n \n **Post-filtering and Pre-filtering**\n \n-Users may optionally specify a `WHERE` clause with additional filter conditions in SELECT queries.\n-Depending on these filter conditions, ClickHouse will utilize post-filtering or pre-filtering.\n-These two strategies determine the order in which the filters are evaluated:\n-- With post-filtering, the vector similarity index is evaluated first, afterwards ClickHouse evaluates the additional filter(s) specified of the `WHERE` clause.\n-- With pre-filtering, the filter evaluation order is the other way round.\n+Users may optionally specify a `WHERE` clause with additional filter conditions for the SELECT query.\n+ClickHouse will evaluate these filter conditions using post-filtering or pre-filtering strategy.\n+In short, both strategies determine the order in which the filters are evaluated:\n+- Post-filtering means that the vector similarity index is evaluated first, afterwards ClickHouse evaluates the additional filter(s) specified in the `WHERE` clause.\n+- Pre-filtering means that the filter evaluation order is the other way round.\n \n-Both strategies have different trade-offs:\n-- Post-filtering has the general problem that it may return less than the number of rows requested in the `LIMIT <N>` clause. This happens when at least one of the result rows returned by the vector similarity index fails to satisfy the additional filters. In ClickHouse, this situation is luckily unlikely to happen because vector similarity indexes do not return rows but blocks with thousands of rows (see \"Differences to Regular Skipping Indexes\" below).\n-- Pre-filtering is an unsolved problem. Some specialized vector databases implement it but most databases including ClickHouse will fall back to exact neighbor search, i.e., a brute-force scan without index.\n+The strategies have different trade-offs:\n+- Post-filtering has the general problem that it may return less than the number of rows requested in the `LIMIT <N>` clause. This situation happens when one or more result rows returned by the vector similarity index fails to satisfy the additional filters.\n+- Pre-filtering is generally an unsolved problem. Certain specialized vector databases provide pre-filtering algorithms but most relational databases (including ClickHouse) will fall back to exact neighbor search, i.e., a brute-force scan without index.\n \n-What strategy is used comes down to whether ClickHouse can use indexes for the additional filter conditions.\n+What strategy is used depends on the filter condition.\n \n-If no index can be used, post-filtering will be applied.\n+*Additional filters are part of the partition key*\n \n If the additional filter condition is part of the partition key, then ClickHouse will apply partition pruning.\n-\n-Example, assuming that the table is range-partitioned by `year`:\n+As an example, a table is range-partitioned by column `year` and the following query is run:\n \n ```sql\n WITH [0., 2.] AS reference_vec\n@@ -258,10 +257,58 @@ ORDER BY L2Distance(vec, reference_vec) ASC\n LIMIT 3;\n ```\n \n-ClickHouse will ignore all partitions but the one for year 2025.\n-Within this partition, a post-filtering strategy will be applied.\n+ClickHouse will prune all partitions except the 2025 one.\n+\n+*Additional filters cannot be evaluated using indexes*\n+\n+If additional filter conditions cannot be evaluated using indexes (primary key index, skipping index), ClickHouse will apply post-filtering.\n+\n+*Additional filters can be evaluated using the primary key index*\n+\n+If additional filter conditions can be evaluated using the [primary key](mergetree.md#primary-key) (i.e., they form a prefix of the primary key) and\n+- the filter condition eliminates at least one row within a part, the ClickHouse will fall back to pre-filtering for the \"surviving\" ranges within the part,\n+- the filter condition eliminates no rows within a part, the ClickHouse will perform post-filtering for the part.\n+\n+In practical use cases, the latter case is rather unlikely.\n+\n+*Additional filters can be evaluated using skipping index*\n+\n+If additional filter conditions can be evaluated using [skipping indexes](mergetree.md#table_engine-mergetree-data_skipping-indexes) (minmax index, set index, etc.), Clickhouse performs post-filtering.\n+In such cases, the vector similarity index is evaluated first as it is expected to remove the most rows relative to other skipping indexes.\n+\n+For finer control over post-filtering vs. pre-filtering, two settings can be used:\n+\n+Setting [vector_search_filter_strategy](../../../operations/settings/settings#vector_search_filter_strategy) (default: `auto` which implements above heuristics) may be set to `prefilter`.\n+This is useful to force pre-filtering in cases where the additional filter conditions are extremely selective.\n+As an example, the following query may benefit from pre-filtering:\n+\n+```sql\n+SELECT bookid, author, title\n+FROM books\n+WHERE price < 2.00\n+ORDER BY cosineDistance(book_vector, getEmbedding('Books on ancient Asian empires'))\n+LIMIT 10\n+```\n+\n+Assuming that only a very small number of books cost less than $2, post-filtering may return zero rows because the top 10 matches returned by the vector index could all be priced above $2.\n+By forcing pre-filtering (add `SETTINGS vector_search_filter_strategy = 'prefilter'` to the query), ClickHouse first finds all books with a price of less than $2 and then executes a brute-force vector search for the found books.\n+\n+As an alternative approach to resolve above issue, setting [vector_search_postfilter_multiplier](../../../operations/settings/settings#vector_search_postfilter_multiplier) (default: `1.0`) may be configured to a value > `1.0` (for example, `2.0`).\n+The number of nearest neighbors fetched from the vector index is multiplied by the setting value and then the additional filter to be applied on those rows to return LIMIT-many rows.\n+As an example, we can query again but with multiplier `3.0`:\n+\n+```sql\n+SELECT bookid, author, title\n+FROM books\n+WHERE price < 2.00\n+ORDER BY cosineDistance(book_vector, getEmbedding('Books on ancient Asian empires'))\n+LIMIT 10\n+SETTING vector_search_postfilter_multiplier = 3.0;\n+```\n \n-If the additional filter condition is part of the primary key, then ClickHouse will always apply pre-filtering.\n+ClickHouse will fetch 3.0 x 10 = 30 nearest neighbors from the vector index in each part and afterwards evaluate the additional filters.\n+Only the ten closest neighbors will be returned.\n+We note that setting `vector_search_postfilter_multiplier` can mitigate the problem but in extreme cases (very selective WHERE condition), it is still possible that less than N requested rows returned.\n \n ### Performance Tuning {#performance-tuning}\n \ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex bf7a6c235ee4..26d6f0009977 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -6567,10 +6567,7 @@ Enable experimental hash functions\n Allow the obsolete Object data type\n )\", EXPERIMENTAL) \\\n     DECLARE(Bool, allow_experimental_time_series_table, false, R\"(\n-Allows creation of tables with the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine.\n-\n-Possible values:\n-\n+Allows creation of tables with the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine. Possible values:\n - 0 \u2014 the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine is disabled.\n - 1 \u2014 the [TimeSeries](../../engines/table-engines/integrations/time-series.md) table engine is enabled.\n )\", EXPERIMENTAL) \\\n@@ -6585,6 +6582,15 @@ SELECT queries with LIMIT bigger than this setting cannot use vector similarity\n )\", EXPERIMENTAL) \\\n     DECLARE(UInt64, hnsw_candidate_list_size_for_search, 256, R\"(\n The size of the dynamic candidate list when searching the vector similarity index, also known as 'ef_search'.\n+)\", EXPERIMENTAL) \\\n+    DECLARE(VectorSearchFilterStrategy, vector_search_filter_strategy, VectorSearchFilterStrategy::AUTO, R\"(\n+If a vector search query has a WHERE clause, this setting determines if it is evaluated first (pre-filtering) OR if the vector similarity index is checked first (post-filtering). Possible values:\n+- 'auto' - Postfiltering (the exact semantics may change in future).\n+- 'postfilter' - Use vector similarity index to identify the nearest neighbours, then apply other filters\n+- 'prefilter' - Evaluate other filters first, then perform brute-force search to identify neighbours.\n+)\", EXPERIMENTAL) \\\n+    DECLARE(Float, vector_search_postfilter_multiplier, 1.0, R\"(\n+Multiply the fetched nearest neighbors from the vector similarity index by this number before performing post-filtering on other predicates.\n )\", EXPERIMENTAL) \\\n     DECLARE(Bool, throw_on_unsupported_query_inside_transaction, true, R\"(\n Throw exception if unsupported query is used inside transaction\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex f3918181eb64..5e2f8aaaedee 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -103,7 +103,8 @@ class WriteBuffer;\n     M(CLASS_NAME, TransactionsWaitCSNMode) \\\n     M(CLASS_NAME, UInt64) \\\n     M(CLASS_NAME, UInt64Auto) \\\n-    M(CLASS_NAME, URI)\n+    M(CLASS_NAME, URI) \\\n+    M(CLASS_NAME, VectorSearchFilterStrategy)\n \n \n COMMON_SETTINGS_SUPPORTED_TYPES(Settings, DECLARE_SETTING_TRAIT)\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 3371989c3d00..35a94f022bbc 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -98,6 +98,8 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()\n             {\"allow_experimental_lightweight_update\", false, false, \"A new setting\"},\n             {\"allow_experimental_delta_kernel_rs\", true, true, \"New setting\"},\n             {\"allow_experimental_database_hms_catalog\", false, false, \"Allow experimental database engine DataLakeCatalog with catalog_type = 'hive'\"},\n+            {\"vector_search_filter_strategy\", \"auto\", \"auto\", \"New setting\"},\n+            {\"vector_search_postfilter_multiplier\", 1, 1, \"New setting\"},\n             {\"compile_expressions\", false, true, \"We believe that the LLVM infrastructure behind the JIT compiler is stable enough to enable this setting by default.\"},\n             {\"use_legacy_to_time\", false, false, \"New setting. Allows for user to use the old function logic for toTime, which works as toTimeWithFixedDate.\"},\n         });\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex 27042de1a2c2..845efa2e189f 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -305,4 +305,11 @@ IMPLEMENT_SETTING_ENUM(\n      {\"glue\", DatabaseDataLakeCatalogType::GLUE},\n      {\"hive\", DatabaseDataLakeCatalogType::ICEBERG_HIVE}})\n \n+IMPLEMENT_SETTING_ENUM(\n+    VectorSearchFilterStrategy,\n+    ErrorCodes::BAD_ARGUMENTS,\n+    {{\"auto\", VectorSearchFilterStrategy::AUTO},\n+     {\"prefilter\", VectorSearchFilterStrategy::PREFILTER},\n+     {\"postfilter\", VectorSearchFilterStrategy::POSTFILTER}})\n+\n }\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex f8eeb17b7e9e..965a666ad1e5 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -396,4 +396,13 @@ enum class DatabaseDataLakeCatalogType : uint8_t\n \n DECLARE_SETTING_ENUM(DatabaseDataLakeCatalogType)\n \n+enum class VectorSearchFilterStrategy : uint8_t\n+{\n+    AUTO,\n+    PREFILTER,\n+    POSTFILTER,\n+};\n+\n+DECLARE_SETTING_ENUM(VectorSearchFilterStrategy)\n+\n }\ndiff --git a/src/Processors/QueryPlan/Optimizations/Optimizations.h b/src/Processors/QueryPlan/Optimizations/Optimizations.h\nindex 560a01419bd1..6a8d820ae9f5 100644\n--- a/src/Processors/QueryPlan/Optimizations/Optimizations.h\n+++ b/src/Processors/QueryPlan/Optimizations/Optimizations.h\n@@ -32,6 +32,7 @@ struct Optimization\n     struct ExtraSettings\n     {\n         size_t max_limit_for_vector_search_queries;\n+        VectorSearchFilterStrategy vector_search_filter_strategy;\n         size_t use_index_for_in_with_subqueries_max_values;\n         SizeLimits network_transfer_limits;\n     };\ndiff --git a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp\nindex 229db5dc5db0..1f752fd61548 100644\n--- a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp\n@@ -37,21 +37,22 @@ namespace Setting\n     extern const SettingsBool query_plan_convert_join_to_in;\n     extern const SettingsBool use_query_condition_cache;\n     extern const SettingsBool query_condition_cache_store_conditions_as_plaintext;\n+    extern const SettingsBool collect_hash_table_stats_during_joins;\n+    extern const SettingsBool query_plan_join_shard_by_pk_ranges;\n+    extern const SettingsBool query_plan_optimize_lazy_materialization;\n     extern const SettingsBoolAuto query_plan_join_swap_table;\n     extern const SettingsMaxThreads max_threads;\n+    extern const SettingsOverflowMode transfer_overflow_mode;\n     extern const SettingsSeconds lock_acquire_timeout;\n     extern const SettingsString force_optimize_projection_name;\n-    extern const SettingsUInt64 max_limit_for_vector_search_queries;\n-    extern const SettingsUInt64 query_plan_max_optimizations_to_apply;\n-    extern const SettingsBool query_plan_optimize_lazy_materialization;\n-    extern const SettingsUInt64 query_plan_max_limit_for_lazy_materialization;\n-    extern const SettingsBool query_plan_join_shard_by_pk_ranges;\n     extern const SettingsUInt64 max_bytes_to_transfer;\n+    extern const SettingsUInt64 max_limit_for_vector_search_queries;\n     extern const SettingsUInt64 max_rows_to_transfer;\n-    extern const SettingsOverflowMode transfer_overflow_mode;\n-    extern const SettingsUInt64 use_index_for_in_with_subqueries_max_values;\n     extern const SettingsUInt64 max_size_to_preallocate_for_joins;\n-    extern const SettingsBool collect_hash_table_stats_during_joins;\n+    extern const SettingsUInt64 query_plan_max_limit_for_lazy_materialization;\n+    extern const SettingsUInt64 query_plan_max_optimizations_to_apply;\n+    extern const SettingsUInt64 use_index_for_in_with_subqueries_max_values;\n+    extern const SettingsVectorSearchFilterStrategy vector_search_filter_strategy;\n }\n \n namespace ServerSetting\n@@ -106,7 +107,9 @@ QueryPlanOptimizationSettings::QueryPlanOptimizationSettings(\n     optimize_lazy_materialization = from[Setting::query_plan_optimize_lazy_materialization];\n     max_limit_for_lazy_materialization = from[Setting::query_plan_max_limit_for_lazy_materialization];\n \n+    vector_search_filter_strategy = from[Setting::vector_search_filter_strategy].value;\n     max_limit_for_vector_search_queries = from[Setting::max_limit_for_vector_search_queries].value;\n+\n     query_plan_join_shard_by_pk_ranges = from[Setting::query_plan_join_shard_by_pk_ranges].value;\n \n     network_transfer_limits = SizeLimits(from[Setting::max_rows_to_transfer], from[Setting::max_bytes_to_transfer], from[Setting::transfer_overflow_mode]);\ndiff --git a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h\nindex 72a866036538..ed80219a4bd3 100644\n--- a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h\n+++ b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <Core/SettingsEnums.h>\n #include <Interpreters/Context_fwd.h>\n #include <Interpreters/ExpressionActionsSettings.h>\n #include <QueryPipeline/SizeLimits.h>\n@@ -87,6 +88,7 @@ struct QueryPlanOptimizationSettings\n     bool optimize_lazy_materialization = false;\n     size_t max_limit_for_lazy_materialization = 0;\n \n+    VectorSearchFilterStrategy vector_search_filter_strategy;\n     size_t max_limit_for_vector_search_queries;\n \n     /// Setting needed for Sets (JOIN -> IN optimization)\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\nindex a60dec1f9be1..816a8a6639bc 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\n@@ -48,6 +48,7 @@ void optimizeTreeFirstPass(const QueryPlanOptimizationSettings & optimization_se\n \n     Optimization::ExtraSettings extra_settings = {\n         optimization_settings.max_limit_for_vector_search_queries,\n+        optimization_settings.vector_search_filter_strategy,\n         optimization_settings.use_index_for_in_with_subqueries_max_values,\n         optimization_settings.network_transfer_limits,\n     };\ndiff --git a/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp b/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp\nindex 161b7ad1666e..a0ed98841f18 100644\n--- a/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp\n@@ -5,6 +5,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/IFunction.h>\n #include <Processors/QueryPlan/ExpressionStep.h>\n+#include <Processors/QueryPlan/FilterStep.h>\n #include <Processors/QueryPlan/LimitStep.h>\n #include <Processors/QueryPlan/Optimizations/Optimizations.h>\n #include <Processors/QueryPlan/QueryPlan.h>\n@@ -38,6 +39,8 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n     /// This optimization pass doesn't change the structure of the query plan.\n     constexpr size_t updated_layers = 0;\n \n+    bool additional_filters_present = false; /// WHERE or PREWHERE\n+\n     /// Expect this query plan:\n     /// LimitStep\n     ///    ^\n@@ -48,6 +51,9 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n     /// ExpressionStep\n     ///    ^\n     ///    |\n+    /// (FilterStep, optional)\n+    ///    ^\n+    ///    |\n     /// ReadFromMergeTree\n \n     auto * limit_step = typeid_cast<LimitStep *>(node->step.get());\n@@ -73,7 +79,25 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n     node = node->children.front();\n     auto * read_from_mergetree_step = typeid_cast<ReadFromMergeTree *>(node->step.get());\n     if (!read_from_mergetree_step)\n-        return updated_layers;\n+    {\n+        /// Do we have a FilterStep on top of ReadFromMergeTree?\n+        auto * filter_step = typeid_cast<FilterStep *>(node->step.get());\n+        if (!filter_step)\n+            return updated_layers;\n+        if (node->children.size() != 1)\n+            return updated_layers;\n+        node = node->children.front();\n+        read_from_mergetree_step = typeid_cast<ReadFromMergeTree *>(node->step.get());\n+        if (!read_from_mergetree_step)\n+            return updated_layers;\n+        additional_filters_present = true;\n+    }\n+\n+    if (const auto & prewhere_info = read_from_mergetree_step->getPrewhereInfo())\n+        additional_filters_present = true;\n+\n+    if (additional_filters_present && settings.vector_search_filter_strategy == VectorSearchFilterStrategy::PREFILTER)\n+        return updated_layers; /// user explicitly wanted exact (brute-force) vector search\n \n     /// Extract N\n     size_t n = limit_step->getLimitForSorting();\n@@ -126,6 +150,8 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n         else if (child->type == ActionsDAG::ActionType::INPUT) /// old analyzer\n         {\n             search_column = child->result_name;\n+            if (search_column.contains('.'))\n+                search_column = search_column.substr(search_column.find('.') + 1); /// admittedly fragile but hey, it's the old path ...\n         }\n         else if (child->type == ActionsDAG::ActionType::COLUMN)\n         {\n@@ -166,7 +192,7 @@ size_t tryUseVectorSearch(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*no\n     if (search_column.empty() || reference_vector.empty())\n         return updated_layers;\n \n-    auto vector_search_parameters = std::make_optional<VectorSearchParameters>(search_column, distance_function, n, reference_vector);\n+    auto vector_search_parameters = std::make_optional<VectorSearchParameters>(search_column, distance_function, n, reference_vector, additional_filters_present);\n     read_from_mergetree_step->setVectorSearchParameters(std::move(vector_search_parameters));\n \n     return updated_layers;\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex 50a6d7a57db4..ce2cb5c48934 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1788,15 +1788,24 @@ static void buildIndexes(\n             skip_indexes.useful_indices.emplace_back(index_helper, condition);\n     }\n \n-    // move minmax indices to first positions, so they will be applied first as cheapest ones\n-    std::stable_sort(begin(skip_indexes.useful_indices), end(skip_indexes.useful_indices), [](const auto & l, const auto & r)\n+    // Move minmax indices to first positions, so they will be applied first as cheapest ones\n+    std::stable_sort(skip_indexes.useful_indices.begin(), skip_indexes.useful_indices.end(), [](const auto & l, const auto & r)\n     {\n-        const bool l_min_max = (typeid_cast<const MergeTreeIndexMinMax *>(l.index.get()));\n-        const bool r_min_max = (typeid_cast<const MergeTreeIndexMinMax *>(r.index.get()));\n-        if (l_min_max == r_min_max)\n+        bool l_is_minmax = typeid_cast<const MergeTreeIndexMinMax *>(l.index.get());\n+        bool r_is_minmax = typeid_cast<const MergeTreeIndexMinMax *>(r.index.get());\n+        if (l_is_minmax == r_is_minmax)\n             return false;\n \n-        if (l_min_max)\n+#if USE_USEARCH\n+        // A vector similarity index (if present) is the most selective, hence move it to front\n+        bool l_is_vectorsimilarity = typeid_cast<const MergeTreeIndexVectorSimilarity *>(l.index.get());\n+        bool r_is_vectorsimilarity = typeid_cast<const MergeTreeIndexVectorSimilarity *>(r.index.get());\n+        if (l_is_vectorsimilarity)\n+            return true;\n+        if (r_is_vectorsimilarity)\n+            return false;\n+#endif\n+        if (l_is_minmax)\n             return true; // left is min max but right is not\n \n         return false; // right is min max but left is not\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex ea661676f2fa..f8f0fda161df 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -1610,6 +1610,12 @@ MarkRanges MergeTreeDataSelectExecutor::filterMarksUsingIndex(\n     size_t marks_count = part->index_granularity->getMarksCountWithoutFinal();\n     size_t index_marks_count = (marks_count + index_granularity - 1) / index_granularity;\n \n+    /// The vector similarity index can only be used if the PK did not prune some ranges within the part.\n+    /// (the vector index is built on the entire part).\n+    const bool all_match  = (marks_count == ranges.getNumberOfMarks());\n+    if (index_helper->isVectorSimilarityIndex() && !all_match)\n+        return ranges;\n+\n     MarkRanges index_ranges;\n     for (const auto & range : ranges)\n     {\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\nindex 66e758c0514e..af85c8729663 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\n@@ -40,6 +40,8 @@ namespace DB\n namespace Setting\n {\n     extern const SettingsUInt64 hnsw_candidate_list_size_for_search;\n+    extern const SettingsFloat vector_search_postfilter_multiplier;\n+    extern const SettingsUInt64 max_limit_for_vector_search_queries;\n }\n \n namespace ServerSetting\n@@ -415,9 +417,14 @@ MergeTreeIndexConditionVectorSimilarity::MergeTreeIndexConditionVectorSimilarity\n     , index_column(index_column_)\n     , metric_kind(metric_kind_)\n     , expansion_search(context->getSettingsRef()[Setting::hnsw_candidate_list_size_for_search])\n+    , postfilter_multiplier(context->getSettingsRef()[Setting::vector_search_postfilter_multiplier])\n+    , max_limit(context->getSettingsRef()[Setting::max_limit_for_vector_search_queries])\n {\n     if (expansion_search == 0)\n         throw Exception(ErrorCodes::INVALID_SETTING_VALUE, \"Setting 'hnsw_candidate_list_size_for_search' must not be 0\");\n+    if (!std::isfinite(postfilter_multiplier) || postfilter_multiplier < 0.0 ||\n+        (parameters && !std::isfinite(postfilter_multiplier * parameters->limit)))\n+            throw Exception(ErrorCodes::INVALID_SETTING_VALUE, \"Setting 'vector_search_postfilter_multiplier' must be bigger than 0.0\");\n }\n \n bool MergeTreeIndexConditionVectorSimilarity::mayBeTrueOnGranule(MergeTreeIndexGranulePtr) const\n@@ -459,12 +466,16 @@ std::vector<UInt64> MergeTreeIndexConditionVectorSimilarity::calculateApproximat\n         throw Exception(ErrorCodes::INCORRECT_QUERY, \"The dimension of the reference vector in the query ({}) does not match the dimension in the index ({})\",\n             parameters->reference_vector.size(), index->dimensions());\n \n+    size_t limit = parameters->limit;\n+    if (parameters->additional_filters_present)\n+        /// Additional filters mean post-filtering which means that matches may be removed. To compensate, allow to fetch more rows by a factor.\n+        limit = std::min(static_cast<size_t>(limit * postfilter_multiplier), max_limit);\n+\n     /// We want to run the search with the user-provided value for setting hnsw_candidate_list_size_for_search (aka. expansion_search).\n     /// The way to do this in USearch is to call index_dense_gt::change_expansion_search. Unfortunately, this introduces a need to\n     /// synchronize index access, see https://github.com/unum-cloud/usearch/issues/500. As a workaround, we extended USearch' search method\n     /// to accept a custom expansion_add setting. The config value is only used on the fly, i.e. not persisted in the index.\n-\n-    auto search_result = index->search(parameters->reference_vector.data(), parameters->limit, USearchIndex::any_thread(), false, expansion_search);\n+    auto search_result = index->search(parameters->reference_vector.data(), limit, USearchIndex::any_thread(), false, expansion_search);\n     if (!search_result)\n         throw Exception(ErrorCodes::INCORRECT_DATA, \"Could not search in vector similarity index. Error: {}\", search_result.error.release());\n \ndiff --git a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\nindex 15c7f2c08964..78ca3247fd21 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\n@@ -159,6 +159,8 @@ class MergeTreeIndexConditionVectorSimilarity final : public IMergeTreeIndexCond\n     const String index_column;\n     const unum::usearch::metric_kind_t metric_kind;\n     const size_t expansion_search;\n+    const float postfilter_multiplier;\n+    const size_t max_limit;\n };\n \n \ndiff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h\nindex fb56f60ea601..fd1027183379 100644\n--- a/src/Storages/MergeTree/MergeTreeIndices.h\n+++ b/src/Storages/MergeTree/MergeTreeIndices.h\n@@ -98,10 +98,14 @@ struct MergeTreeIndexFormat\n /// A vehicle which transports elements of the SELECT query to the vector similarity index.\n struct VectorSearchParameters\n {\n+    /// Elements of the SELECT query\n     String column;\n     String distance_function;\n     size_t limit;\n     std::vector<Float64> reference_vector;\n+\n+    /// Other metadata\n+    bool additional_filters_present; /// SELECT contains a WHERE or PREWHERE clause\n };\n \n /// Stores some info about a single block of data.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02354_vector_search_postfiltering_bug.reference b/tests/queries/0_stateless/02354_vector_search_postfiltering_bug.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02354_vector_search_postfiltering_bug.sql b/tests/queries/0_stateless/02354_vector_search_postfiltering_bug.sql\nnew file mode 100644\nindex 000000000000..32a0e2d3a769\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_vector_search_postfiltering_bug.sql\n@@ -0,0 +1,20 @@\n+-- Tags: no-fasttest, long, no-asan, no-ubsan, no-msan, no-tsan, no-debug\n+-- Test for Bug 78161\n+\n+SET allow_experimental_vector_similarity_index = 1;\n+SET enable_analyzer = 1;\n+\n+CREATE TABLE tab (id Int32, vec Array(Float32)) ENGINE = MergeTree() ORDER BY id SETTINGS index_granularity = 128;\n+INSERT INTO tab SELECT number, [randCanonical(), randCanonical()] FROM numbers(100000);\n+\n+-- Create index\n+ALTER TABLE tab ADD INDEX idx_vec vec TYPE vector_similarity('hnsw', 'cosineDistance', 2, 'f32', 64, 400);\n+ALTER TABLE tab MATERIALIZE INDEX idx_vec SETTINGS mutations_sync=2;\n+\n+WITH [1., 2.] AS reference_vec\n+SELECT *\n+FROM tab\n+PREWHERE id < 5000\n+ORDER BY cosineDistance(vec, reference_vec) ASC\n+LIMIT 10\n+FORMAT Null;\ndiff --git a/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.reference b/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.reference\nnew file mode 100644\nindex 000000000000..394fb8df7802\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.reference\n@@ -0,0 +1,25 @@\n+Test vector_search_filter_strategy = prefilter\n+-- No additional WHERE clauses present, expect index usage\n+Description: vector_similarity GRANULARITY 10000\n+Granules: 3/4\n+-- Additional WHERE clauses present, index usage not expected\n+-- Additional WHERE clauses present, index usage not expected\n+-- Additional WHERE clauses present, index usage not expected\n+Test vector_search_filter_strategy = postfilter\n+-- No additional WHERE clauses present, expect index usage\n+Description: vector_similarity GRANULARITY 10000\n+Granules: 3/4\n+-- Additional WHERE clauses on partition key present (2 full parts selected), expect index usage\n+Description: vector_similarity GRANULARITY 10000\n+-- Additional WHERE clauses on partition key present (2 full parts selected), expect index usage\n+Description: vector_similarity GRANULARITY 10000\n+-- Additional WHERE clauses present, 2 full parts selected by partition key / 1 part partially selected by PK, index usage not expected\n+7\n+8\n+0\n+The first 3 neighbours returned by vector index dont pass the attr2 >= 1008 filter. Hence no rows returned by the query...\n+... but there are results for the same query with postfilter multiplier = 2.0\n+10\n+11\n+12\n+-- Negative parameter values throw an exception\ndiff --git a/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.sql b/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.sql\nnew file mode 100644\nindex 000000000000..6c315ba3668b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.sql\n@@ -0,0 +1,166 @@\n+-- Tags: no-fasttest, no-ordinary-database\n+\n+-- Tests pre vs. post-filtering for vector search.\n+\n+SET allow_experimental_vector_similarity_index = 1;\n+SET enable_analyzer = 1;\n+SET parallel_replicas_local_plan = 1; -- this setting is randomized, set it explicitly to have local plan for parallel replicas\n+\n+DROP TABLE IF EXISTS tab;\n+\n+CREATE TABLE tab\n+(\n+    id Int32,\n+    date Date,\n+    attr1 Int32,\n+    attr2 Int32,\n+    vec Array(Float32),\n+    INDEX idx_attr1 attr1 TYPE minmax,\n+    INDEX idx_vec vec TYPE vector_similarity('hnsw', 'L2Distance', 2) GRANULARITY 10000\n+)\n+ENGINE = MergeTree\n+PARTITION BY date\n+ORDER BY id\n+SETTINGS index_granularity = 3;\n+\n+INSERT INTO tab VALUES\n+  (1, '2025-01-01', 101, 1001, [1.0, 0.0]),\n+  (2, '2025-01-01', 102, 1002, [1.1, 0.0]),\n+  (3, '2025-01-01', 103, 1003, [1.2, 0.0]),\n+  (4, '2025-01-02', 104, 1003, [1.3, 0.0]),\n+  (5, '2025-01-02', 105, 1004, [1.4, 0.0]),\n+  (6, '2025-01-02', 106, 1005, [1.5, 0.0]),\n+  (7, '2025-01-03', 107, 1005, [1.6, 0.0]),\n+  (8, '2025-01-03', 108, 1006, [1.7, 0.0]),\n+  (9, '2025-01-03', 109, 1007, [1.8, 0.0]),\n+  (10, '2025-01-03', 110, 1008, [1.9, 0.0]),\n+  (11, '2025-01-03', 111, 1009, [2.0, 0.0]),\n+  (12, '2025-01-03', 112, 1010, [2.1, 0.0]);\n+\n+SELECT 'Test vector_search_filter_strategy = prefilter';\n+\n+SELECT '-- No additional WHERE clauses present, expect index usage';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'prefilter'\n+)\n+WHERE explain LIKE '%vector_similarity%' OR explain LIKE '%Granules: 3/4%';\n+\n+SELECT '-- Additional WHERE clauses present, index usage not expected';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    WHERE attr2 >= 1006\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'prefilter'\n+)\n+WHERE explain LIKE '%vector_similarity%';\n+\n+SELECT '-- Additional WHERE clauses present, index usage not expected';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    WHERE attr1 <= 105\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'prefilter'\n+)\n+WHERE explain LIKE '%vector_similarity%';\n+\n+SELECT '-- Additional WHERE clauses present, index usage not expected';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    WHERE id <= 6\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'prefilter'\n+)\n+WHERE explain LIKE '%vector_similarity%';\n+\n+SELECT 'Test vector_search_filter_strategy = postfilter';\n+\n+SELECT '-- No additional WHERE clauses present, expect index usage';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'postfilter'\n+)\n+WHERE explain LIKE '%vector_similarity%' OR explain LIKE '%Granules: 3/4%';\n+\n+SELECT '-- Additional WHERE clauses on partition key present (2 full parts selected), expect index usage';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    WHERE date <= '2025-01-02'\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'postfilter'\n+)\n+WHERE explain LIKE '%vector_similarity%';\n+\n+SELECT '-- Additional WHERE clauses on partition key present (2 full parts selected), expect index usage';\n+SELECT trimLeft(explain) FROM (\n+    EXPLAIN indexes = 1\n+    SELECT id\n+    FROM tab\n+    WHERE date = '2025-01-03'\n+    AND attr1 = 110\n+    ORDER BY L2Distance(vec, [1.0, 1.0])\n+    LIMIT 2\n+    SETTINGS vector_search_filter_strategy = 'postfilter'\n+)\n+WHERE explain LIKE '%vector_similarity%';\n+\n+SELECT '-- Additional WHERE clauses present, 2 full parts selected by partition key / 1 part partially selected by PK, index usage not expected';\n+SELECT id\n+FROM tab\n+WHERE date = '2025-01-03' AND id <= 9\n+ORDER BY L2Distance(vec, [1.0, 1.0])\n+LIMIT 2\n+SETTINGS log_comment = '02354_vector_search_post_filter_strategy_query1';\n+\n+SYSTEM FLUSH LOGS query_log;\n+\n+SELECT DISTINCT ProfileEvents['USearchSearchCount']\n+FROM system.query_log\n+WHERE log_comment = '02354_vector_search_post_filter_strategy_query1'\n+AND current_database = currentDatabase()\n+AND type = 'QueryFinish';\n+\n+SELECT 'The first 3 neighbours returned by vector index dont pass the attr2 >= 1008 filter. Hence no rows returned by the query...';\n+SELECT id\n+FROM tab\n+WHERE date = '2025-01-03' AND attr2 >= 1008\n+ORDER BY L2Distance(vec, [1.0, 1.0])\n+LIMIT 3;\n+\n+SELECT '... but there are results for the same query with postfilter multiplier = 2.0';\n+SELECT id\n+FROM tab\n+WHERE date = '2025-01-03' AND attr2 >= 1008\n+ORDER BY L2Distance(vec, [1.0, 1.0])\n+LIMIT 3\n+SETTINGS vector_search_postfilter_multiplier = 2.0;\n+\n+SELECT '-- Negative parameter values throw an exception';\n+SELECT id\n+FROM tab\n+WHERE date = '2025-01-03' AND attr2 >= 1008\n+ORDER BY L2Distance(vec, [1.0, 1.0])\n+LIMIT 3\n+SETTINGS vector_search_postfilter_multiplier = -1.0; -- { serverError INVALID_SETTING_VALUE }\n+\n+DROP TABLE tab;\n",
  "problem_statement": "Clickhouse server process can assert / crash if vector index search is performed after initial range pruning by primary key or other skip index\n### Company or project name\n\nClickhouse Vector Search\n\n### Describe what's wrong\n\nFollowing type of query can assert or crash Clickhouse server process -\n\n```sql\nSELECT id FROM items\nPREWHERE id < 300000\nORDER BY cosineDistance(vector, [-0.004410677 ...])\nLIMIT 10\n```\nThe EXPLAIN looks like this -\n\n```\nExpression (Project names)\n  Limit (preliminary LIMIT (without OFFSET))\n    Sorting (Sorting for ORDER BY)\n      Expression ((Before ORDER BY + (Projection + Change column names to column identifiers)))\n        ReadFromMergeTree (default.items)\n        Indexes:\n          PrimaryKey\n            Keys:\n              id\n            Condition: (id in (-Inf, 299999])\n            Parts: 1/1\n            Granules: 175/575\n          Skip\n            Name: vector_index\n            Description: vector_similarity GRANULARITY 100000000\n            Parts: 1/1\n            Granules: 18446744073709551566/175     <<<<<< \n```\nNote the last line. \n\nThe assert is -\n\n```\n2025.03.24 04:52:09.160569 [ 1239968 ] {fb2b487a-511d-4568-b318-d5c4bd64bf07} <Error> PipelineExecutor: Code: 49. DB::Exception: \nTrying to get non existing mark 384307168202282550, while size is 576: While executing \nMergeTreeSelect(pool: ReadPool, algorithm: Thread). (LOGICAL_ERROR), \nStack trace (when copying this message, always include the lines below):\n```\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\nVersion : 25.4.1\nCheck above query\n\n### Expected behavior\n\nNo errors/crashes\n\n### Error message and/or stacktrace\n\n```\n0. ./contrib/llvm-project/libcxx/include/__exception/exception.h:113: Poco::Exception::Exception(String const&, int) @ 0x00000000176614d2\n1. ./build/./src/Common/Exception.cpp:108: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000d6c5219\n2. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x000000000806beac\n3. DB::Exception::Exception<unsigned long&, unsigned long>(int, FormatStringHelperImpl<std::type_identity<unsigned long&>::type, std::type_identity<unsigned long>::type>, unsigned long&, unsigned long&&) @ 0x00000000080f430b\n4. ./build/./src/Storages/MergeTree/MergeTreeIndexGranularityAdaptive.cpp:24: DB::MergeTreeIndexGranularityAdaptive::getMarkRows(unsigned long) const @ 0x0000000013c25558\n5. ./build/./src/Storages/MergeTree/MergeTreeReadTask.cpp:139: DB::MergeTreeReadTask::estimateNumRows() const @ 0x0000000013cbb1ca\n6. ./build/./src/Storages/MergeTree/MergeTreeReadTask.cpp:169: DB::MergeTreeReadTask::read() @ 0x0000000013cbb3f2\n7. ./src/Storages/MergeTree/MergeTreeSelectAlgorithms.h:38: DB::MergeTreeThreadSelectAlgorithm::readFromTask(DB::MergeTreeReadTask&) @ 0x000000001463702c\n8. ./build/./src/Storages/MergeTree/MergeTreeSelectProcessor.cpp:204: DB::MergeTreeSelectProcessor::read() @ 0x0000000013cc534e\n9. ./build/./src/Storages/MergeTree/MergeTreeSource.cpp:229: DB::MergeTreeSource::tryGenerate() @ 0x000000001463e929\n10. ./build/./src/Processors/ISource.cpp:108: DB::ISource::work() @ 0x00000000141f6c05\n11. ./build/./src/Processors/Executors/ExecutionThreadContext.cpp:53: DB::ExecutionThreadContext::executeTask() @ 0x000000001420f6e1\n12. ./build/./src/Processors/Executors/PipelineExecutor.cpp:296: DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x0000000014205285\n13. ./build/./src/Processors/Executors/PipelineExecutor.cpp:262: void std::__function::__policy_invoker<void ()>::__call_impl[abi:ne190107]<std::__function::__default_alloc_func<DB::PipelineExecutor::spawnThreadsImpl()::$_0, void ()>>(std::__function::__policy_storage const*) @ 0x0000000014205f81\n14. ./contrib/llvm-project/libcxx/include/__functional/function.h:716: ? @ 0x000000000d7f0bbb\n15. ./contrib/llvm-project/libcxx/include/__type_traits/invoke.h:117: ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<void (ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::ThreadFromThreadPool::*)(), ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::ThreadFromThreadPool*>(void (ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::ThreadFromThreadPool::*&&)(), ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::ThreadFromThreadPool*&&)::'lambda'()::operator()() @ 0x000000000d7f5de2\n16. ./contrib/llvm-project/libcxx/include/__functional/function.h:716: ? @ 0x000000000d7ee836\n17. ./contrib/llvm-project/libcxx/include/__type_traits/invoke.h:117: void* std::__thread_proxy[abi:ne190107]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void (ThreadPoolImpl<std::thread>::ThreadFromThreadPool::*)(), ThreadPoolImpl<std::thread>::ThreadFromThreadPool*>>(void*) @ 0x000000000d7f419b\n18. ? @ 0x000072b69de9caa4\n19. ? @ 0x000072b69df29c3c\n```\n\n### Additional context\n\n_No response_\n",
  "hints_text": "@shankar-iyer Do you have a complete repro, in particular which data was INSERTed into the table? I tried to reproduce locally but the SELECT succeeded?\nPlease try this\n\n```sql\nCREATE TABLE  r (id Int32, v Array(Float32)) ENGINE=MergeTree() ORDER BY (id) SETTINGS index_granularity=128;\n\nINSERT INTO r SELECT number, [randCanonical(), randCanonical()] FROM numbers(100000);\n\nALTER TABLE r ADD INDEX vector_index v TYPE vector_similarity('hnsw', 'cosineDistance', 'f32', 64, 400);\n\nALTER TABLE r MATERIALIZE INDEX vector_index SETTINGS mutations_sync=2;\n\n```\nAnd\n\n```sql\nip-172-31-41-45.eu-central-1.compute.internal :) explain indexes=1 with [1.0, 2.0] as rv  select * from r prewhere id < 5000 order by cosineDistance(v, rv) limit 10 SETTINGS allow_experimental_vector_similarity_index=1;\n\nEXPLAIN indexes = 1\nWITH [1., 2.] AS rv\nSELECT *\nFROM r\nPREWHERE id < 5000\nORDER BY cosineDistance(v, rv) ASC\nLIMIT 10\nSETTINGS allow_experimental_vector_similarity_index = 1\n\nQuery id: b1d5cc2c-7e92-45b2-b554-f5540c314dbf\n\n    \u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n 1. \u2502 Expression (Project names)                                                                      \u2502\n 2. \u2502   Limit (preliminary LIMIT (without OFFSET))                                                    \u2502\n 3. \u2502     Sorting (Sorting for ORDER BY)                                                              \u2502\n 4. \u2502       Expression ((Before ORDER BY + (Projection + Change column names to column identifiers))) \u2502\n 5. \u2502         ReadFromMergeTree (default.r)                                                           \u2502\n 6. \u2502         Indexes:                                                                                \u2502\n 7. \u2502           PrimaryKey                                                                            \u2502\n 8. \u2502             Keys:                                                                               \u2502\n 9. \u2502               id                                                                                \u2502\n10. \u2502             Condition: (id in (-Inf, 4999])                                                     \u2502\n11. \u2502             Parts: 1/1                                                                          \u2502\n12. \u2502             Granules: 40/781                                                                    \u2502\n13. \u2502           Skip                                                                                  \u2502\n14. \u2502             Name: vector_index                                                                  \u2502\n15. \u2502             Description: vector_similarity GRANULARITY 100000000                                \u2502\n16. \u2502             Parts: 1/1                                                                          \u2502\n17. \u2502             Granules: 18446744073709551613/40                                                   \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\nip-172-31-41-45.eu-central-1.compute.internal :) with [1.0, 2.0] as rv  select * from r prewhere id < 5000 order by cosineDistance(v, rv) limit 10 SETTINGS allow_experimental_vector_similarity_index=1;\n\nWITH [1., 2.] AS rv\nSELECT *\nFROM r\nPREWHERE id < 5000\nORDER BY cosineDistance(v, rv) ASC\nLIMIT 10\nSETTINGS allow_experimental_vector_similarity_index = 1\n\nQuery id: c7cbdcfb-dba6-4ef9-bba3-e5ee7388ec03\n\n\nElapsed: 0.032 sec.\n\nReceived exception from server (version 25.4.1):\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Trying create stream to read to mark \u211648 but total marks count is 782: While executing MergeTreeSelect(pool: ReadPool, algorithm: Thread). (LOGICAL_ERROR)\n```",
  "created_at": "2025-05-05T16:47:34Z",
  "modified_files": [
    "ci/jobs/scripts/check_style/aspell-ignore/en/aspell-dict.txt",
    "docs/en/engines/table-engines/mergetree-family/annindexes.md",
    "src/Core/Settings.cpp",
    "src/Core/Settings.h",
    "src/Core/SettingsChangesHistory.cpp",
    "src/Core/SettingsEnums.cpp",
    "src/Core/SettingsEnums.h",
    "src/Processors/QueryPlan/Optimizations/Optimizations.h",
    "src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp",
    "src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h",
    "src/Processors/QueryPlan/Optimizations/optimizeTree.cpp",
    "src/Processors/QueryPlan/Optimizations/useVectorSearch.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp",
    "src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp",
    "src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h",
    "src/Storages/MergeTree/MergeTreeIndices.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02354_vector_search_postfiltering_bug.sql",
    "b/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.reference",
    "b/tests/queries/0_stateless/02354_vector_search_pre_and_post_filtering.sql"
  ]
}