{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9050,
  "instance_id": "ClickHouse__ClickHouse-9050",
  "issue_numbers": [
    "8964"
  ],
  "base_commit": "bd6d9a427b13cd0e6022fc8fad35c9cb82347646",
  "patch": "diff --git a/dbms/src/Storages/MergeTree/MarkRange.h b/dbms/src/Storages/MergeTree/MarkRange.h\nindex 657ffe32f78e..8380914a4556 100644\n--- a/dbms/src/Storages/MergeTree/MarkRange.h\n+++ b/dbms/src/Storages/MergeTree/MarkRange.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <cstddef>\n-#include <vector>\n+#include <deque>\n \n \n namespace DB\n@@ -19,7 +19,7 @@ struct MarkRange\n     MarkRange(const size_t begin_, const size_t end_) : begin{begin_}, end{end_} {}\n };\n \n-using MarkRanges = std::vector<MarkRange>;\n+using MarkRanges = std::deque<MarkRange>;\n \n \n }\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp b/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\nindex 920697f3c329..e1c0305abfd6 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n@@ -73,7 +73,8 @@ MergeTreeReadTask::MergeTreeReadTask(\n     : data_part{data_part_}, mark_ranges{mark_ranges_}, part_index_in_query{part_index_in_query_},\n     ordered_names{ordered_names_}, column_name_set{column_name_set_}, columns{columns_}, pre_columns{pre_columns_},\n     remove_prewhere_column{remove_prewhere_column_}, should_reorder{should_reorder_}, size_predictor{std::move(size_predictor_)}\n-{}\n+{\n+}\n \n MergeTreeReadTask::~MergeTreeReadTask() = default;\n \ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.h b/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\nindex 19c6adbd9c75..108742e11012 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\n+++ b/dbms/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\n@@ -30,8 +30,7 @@ struct MergeTreeReadTask\n {\n     /// data part which should be read while performing this task\n     MergeTreeData::DataPartPtr data_part;\n-    /** Ranges to read from `data_part`.\n-     *    Specified in reverse order for MergeTreeThreadSelectBlockInputStream's convenience of calling .pop_back(). */\n+    /// Ranges to read from `data_part`.\n     MarkRanges mark_ranges;\n     /// for virtual `part_index` virtual column\n     size_t part_index_in_query;\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex 33b5ac4999d4..28e8eb486d34 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -718,9 +718,6 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreams(\n     for (size_t i = 0; i < parts.size(); ++i)\n     {\n         total_rows += parts[i].getRowsCount();\n-        /// Let the ranges be listed from right to left so that the leftmost range can be dropped using `pop_back()`.\n-        std::reverse(parts[i].ranges.begin(), parts[i].ranges.end());\n-\n         sum_marks_in_parts[i] = parts[i].getMarksCount();\n         sum_marks += sum_marks_in_parts[i];\n \n@@ -826,9 +823,6 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n         sum_marks_in_parts[i] = parts[i].getMarksCount();\n         sum_marks += sum_marks_in_parts[i];\n \n-        /// Let the ranges be listed from right to left so that the leftmost range can be dropped using `pop_back()`.\n-        std::reverse(parts[i].ranges.begin(), parts[i].ranges.end());\n-\n         if (parts[i].data_part->index_granularity_info.is_adaptive)\n             adaptive_parts++;\n     }\n@@ -891,13 +885,12 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n                 auto range = *it;\n                 while (range.begin + marks_in_range < range.end)\n                 {\n-                    new_ranges.emplace_back(range.end - marks_in_range, range.end);\n+                    new_ranges.emplace_front(range.end - marks_in_range, range.end);\n                     range.end -= marks_in_range;\n                     marks_in_range = std::min(marks_in_range * 2, max_marks_in_range);\n                 }\n-                new_ranges.emplace_back(range.begin, range.end);\n+                new_ranges.emplace_front(range.begin, range.end);\n             }\n-            std::reverse(new_ranges.begin(), new_ranges.end());\n         }\n \n         return new_ranges;\n@@ -919,7 +912,7 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n             RangesInDataPart part = parts.back();\n             parts.pop_back();\n \n-            size_t & marks_in_part = sum_marks_in_parts.back();\n+            size_t & marks_in_part = sum_marks_in_parts.front();\n \n             /// We will not take too few rows from a part.\n             if (marks_in_part >= min_marks_for_concurrent_read &&\n@@ -936,9 +929,6 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n             /// We take the whole part if it is small enough.\n             if (marks_in_part <= need_marks)\n             {\n-                /// Restore the order of segments.\n-                std::reverse(part.ranges.begin(), part.ranges.end());\n-\n                 ranges_to_get_from_part = part.ranges;\n \n                 need_marks -= marks_in_part;\n@@ -952,7 +942,7 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n                     if (part.ranges.empty())\n                         throw Exception(\"Unexpected end of ranges while spreading marks among streams\", ErrorCodes::LOGICAL_ERROR);\n \n-                    MarkRange & range = part.ranges.back();\n+                    MarkRange & range = part.ranges.front();\n \n                     const size_t marks_in_range = range.end - range.begin;\n                     const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);\n@@ -962,7 +952,7 @@ Pipes MergeTreeDataSelectExecutor::spreadMarkRangesAmongStreamsWithOrder(\n                     marks_in_part -= marks_to_get_from_range;\n                     need_marks -= marks_to_get_from_range;\n                     if (range.begin == range.end)\n-                        part.ranges.pop_back();\n+                        part.ranges.pop_front();\n                 }\n                 parts.emplace_back(part);\n             }\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeRangeReader.cpp b/dbms/src/Storages/MergeTree/MergeTreeRangeReader.cpp\nindex a0bd2567fe50..56e5cfdb3d2d 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeRangeReader.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeRangeReader.cpp\n@@ -690,9 +690,9 @@ MergeTreeRangeReader::ReadResult MergeTreeRangeReader::startReadingChain(size_t\n             if (stream.isFinished())\n             {\n                 result.addRows(stream.finalize(result.columns));\n-                stream = Stream(ranges.back().begin, ranges.back().end, merge_tree_reader);\n-                result.addRange(ranges.back());\n-                ranges.pop_back();\n+                stream = Stream(ranges.front().begin, ranges.front().end, merge_tree_reader);\n+                result.addRange(ranges.front());\n+                ranges.pop_front();\n             }\n \n             auto rows_to_read = std::min(space_left, stream.numPendingRowsInCurrentGranule());\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeReadPool.cpp b/dbms/src/Storages/MergeTree/MergeTreeReadPool.cpp\nindex a70dfc2d78c2..15d87e60e243 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeReadPool.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeReadPool.cpp\n@@ -28,11 +28,6 @@ MergeTreeReadPool::MergeTreeReadPool(\n       column_names{column_names_}, do_not_steal_tasks{do_not_steal_tasks_},\n       predict_block_size_bytes{preferred_block_size_bytes_ > 0}, prewhere_info{prewhere_info_}, parts_ranges{parts_}\n {\n-    /// reverse from right-to-left to left-to-right\n-    /// because 'reverse' was done in MergeTreeDataSelectExecutor\n-    for (auto & part_ranges : parts_ranges)\n-        std::reverse(std::begin(part_ranges.ranges), std::end(part_ranges.ranges));\n-\n     /// parts don't contain duplicate MergeTreeDataPart's.\n     const auto per_part_sum_marks = fillPerPartInfo(parts_, check_columns_);\n     fillPerThreadInfo(threads_, sum_marks_, per_part_sum_marks, parts_, min_marks_for_concurrent_read_);\n@@ -78,10 +73,6 @@ MergeTreeReadTaskPtr MergeTreeReadPool::getTask(const size_t min_marks_to_read,\n     if (marks_in_part <= need_marks)\n     {\n         const auto marks_to_get_from_range = marks_in_part;\n-\n-        /** Ranges are in right-to-left order, because 'reverse' was done in MergeTreeDataSelectExecutor\n-            *     and that order is supported in 'fillPerThreadInfo'.\n-            */\n         ranges_to_get_from_part = thread_task.ranges;\n \n         marks_in_part -= marks_to_get_from_range;\n@@ -97,7 +88,7 @@ MergeTreeReadTaskPtr MergeTreeReadPool::getTask(const size_t min_marks_to_read,\n         /// Loop through part ranges.\n         while (need_marks > 0 && !thread_task.ranges.empty())\n         {\n-            auto & range = thread_task.ranges.back();\n+            auto & range = thread_task.ranges.front();\n \n             const size_t marks_in_range = range.end - range.begin;\n             const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);\n@@ -105,19 +96,11 @@ MergeTreeReadTaskPtr MergeTreeReadPool::getTask(const size_t min_marks_to_read,\n             ranges_to_get_from_part.emplace_back(range.begin, range.begin + marks_to_get_from_range);\n             range.begin += marks_to_get_from_range;\n             if (range.begin == range.end)\n-            {\n-                std::swap(range, thread_task.ranges.back());\n-                thread_task.ranges.pop_back();\n-            }\n+                thread_task.ranges.pop_front();\n \n             marks_in_part -= marks_to_get_from_range;\n             need_marks -= marks_to_get_from_range;\n         }\n-\n-        /** Change order to right-to-left, for MergeTreeThreadSelectBlockInputStream to get ranges with .pop_back()\n-            *  (order was changed to left-to-right due to .pop_back() above).\n-            */\n-        std::reverse(std::begin(ranges_to_get_from_part), std::end(ranges_to_get_from_part));\n     }\n \n     auto curr_task_size_predictor = !per_part_size_predictor[part_idx] ? nullptr\n@@ -211,7 +194,6 @@ std::vector<size_t> MergeTreeReadPool::fillPerPartInfo(\n \n         /// Read marks for every data part.\n         size_t sum_marks = 0;\n-        /// Ranges are in right-to-left order, due to 'reverse' in MergeTreeDataSelectExecutor.\n         for (const auto & range : part.ranges)\n             sum_marks += range.end - range.begin;\n \n@@ -279,7 +261,6 @@ void MergeTreeReadPool::fillPerThreadInfo(\n             /// Get whole part to read if it is small enough.\n             if (marks_in_part <= need_marks)\n             {\n-                /// Leave ranges in right-to-left order for convenience to use .pop_back() in .getTask()\n                 ranges_to_get_from_part = part.ranges;\n                 marks_in_ranges = marks_in_part;\n \n@@ -295,7 +276,7 @@ void MergeTreeReadPool::fillPerThreadInfo(\n                     if (part.ranges.empty())\n                         throw Exception(\"Unexpected end of ranges while spreading marks among threads\", ErrorCodes::LOGICAL_ERROR);\n \n-                    MarkRange & range = part.ranges.back();\n+                    MarkRange & range = part.ranges.front();\n \n                     const size_t marks_in_range = range.end - range.begin;\n                     const size_t marks_to_get_from_range = std::min(marks_in_range, need_marks);\n@@ -305,13 +286,8 @@ void MergeTreeReadPool::fillPerThreadInfo(\n                     marks_in_part -= marks_to_get_from_range;\n                     need_marks -= marks_to_get_from_range;\n                     if (range.begin == range.end)\n-                        part.ranges.pop_back();\n+                        part.ranges.pop_front();\n                 }\n-\n-                /** Change order to right-to-left, for getTask() to get ranges with .pop_back()\n-                    *  (order was changed to left-to-right due to .pop_back() above).\n-                    */\n-                std::reverse(std::begin(ranges_to_get_from_part), std::end(ranges_to_get_from_part));\n             }\n \n             threads_tasks[i].parts_and_ranges.push_back({ part_idx, ranges_to_get_from_part });\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeReader.h b/dbms/src/Storages/MergeTree/MergeTreeReader.h\nindex b0642c061081..65485f950c6e 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeReader.h\n+++ b/dbms/src/Storages/MergeTree/MergeTreeReader.h\n@@ -57,7 +57,7 @@ class MergeTreeReader : private boost::noncopyable\n \n     size_t getFirstMarkToRead() const\n     {\n-        return all_mark_ranges.back().begin;\n+        return all_mark_ranges.front().begin;\n     }\n private:\n     using FileStreams = std::map<std::string, std::unique_ptr<MergeTreeReaderStream>>;\ndiff --git a/dbms/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp b/dbms/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\nindex dac42859eef4..0f0822cd88c9 100644\n--- a/dbms/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n+++ b/dbms/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n@@ -95,11 +95,6 @@ try\n \n     task_columns = getReadTaskColumns(storage, data_part, required_columns, prewhere_info, check_columns);\n \n-    /** @note you could simply swap `reverse` in if and else branches of MergeTreeDataSelectExecutor,\n-     * and remove this reverse. */\n-    MarkRanges remaining_mark_ranges = all_mark_ranges;\n-    std::reverse(remaining_mark_ranges.begin(), remaining_mark_ranges.end());\n-\n     auto size_predictor = (preferred_block_size_bytes == 0)\n         ? nullptr\n         : std::make_unique<MergeTreeBlockSizePredictor>(data_part, ordered_names, data_part->storage.getSampleBlock());\n@@ -109,7 +104,7 @@ try\n     column_name_set = NameSet{column_names.begin(), column_names.end()};\n \n     task = std::make_unique<MergeTreeReadTask>(\n-        data_part, remaining_mark_ranges, part_index_in_query, ordered_names, column_name_set, task_columns.columns,\n+        data_part, all_mark_ranges, part_index_in_query, ordered_names, column_name_set, task_columns.columns,\n         task_columns.pre_columns, prewhere_info && prewhere_info->remove_prewhere_column,\n         task_columns.should_reorder, std::move(size_predictor));\n \n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01078_merge_tree_read_one_thread.reference b/dbms/tests/queries/0_stateless/01078_merge_tree_read_one_thread.reference\nnew file mode 100644\nindex 000000000000..697cb3a26d77\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01078_merge_tree_read_one_thread.reference\n@@ -0,0 +1,1 @@\n+300\ndiff --git a/dbms/tests/queries/0_stateless/01078_merge_tree_read_one_thread.sql b/dbms/tests/queries/0_stateless/01078_merge_tree_read_one_thread.sql\nnew file mode 100644\nindex 000000000000..41fcbe817090\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01078_merge_tree_read_one_thread.sql\n@@ -0,0 +1,16 @@\n+drop table if exists t;\n+\n+create table t (a Int, b Int) engine = MergeTree order by (a, b) settings index_granularity = 400;\n+\n+insert into t select 0, 0 from numbers(50);\n+insert into t select 0, 1  from numbers(350);\n+insert into t select 1, 2  from numbers(400);\n+insert into t select 2, 2  from numbers(400);\n+insert into t select 3, 0 from numbers(100);\n+\n+select sleep(1) format Null; -- sleep a bit to wait possible merges after insert\n+\n+set max_threads = 1;\n+optimize table t final;\n+\n+select sum(a) from t where a in (0, 3) and b = 0; \n",
  "problem_statement": "DB::Exception: RangeReader read 7523 rows, but 7550 expected..\nQuery:\r\n\r\n```\r\nSELECT \r\n         *\r\n     FROM reporting_events\r\n     WHERE (device_id = 51);\r\n```\r\n\r\nResult:\r\n\r\n`DB::Exception: RangeReader read 7523 rows, but 7550 expected..`\r\n\r\nTable:\r\n\r\n```\r\nCREATE TABLE reporting_events (\r\n  id UInt64,\r\n  a UInt32,\r\n  b UInt64,\r\n  c UInt32,\r\n  d DEFAULT 0,\r\n  e UInt32 DEFAULT 0,\r\n  device_id UInt32,\r\n  ts DateTime DEFAULT now(),\r\n  name String,\r\n  type Enum8('ONLINE'      = 0,\r\n             'OFFLINE'     = 1,\r\n             'INFORMATION' = 2,\r\n             'WARNING'     = 3,\r\n             'CRITICAL'    = 4),\r\n  description String\r\n)\r\nENGINE = MergeTree()\r\nPARTITION BY toYYYYMM(ts)\r\nORDER BY (a, b, e, device_id, ts, type)\r\nTTL ts + INTERVAL 6 MONTH;\r\n```\r\n\r\nClickhouse version 20.1.2, same with 20.1.3.7. Probably this error due to update to the latest clickhouse version.\n",
  "hints_text": "Error from the log:\r\n\r\n```\r\n2020.02.03 11:12:35.185941 [ 50 ] {e56d27a0-9040-45e8-b1c2-8f3246dddf26} <Error> executeQuery: Code: 49, e.displayText() = DB::Exception: RangeReader read 7524 rows, but 7551 expected. (version 20.1.3.7 (official build)) (from 127.0.0.1:33204) (in query: SELECT * FROM reporting_events WHERE device_id = 51), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. 0xbc3212c Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int)  in /usr/bin/clickhouse\r\n1. 0x4f6cbc9 DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int)  in /usr/bin/clickhouse\r\n2. 0x4cb3235 ?  in /usr/bin/clickhouse\r\n3. 0x97a594f DB::MergeTreeRangeReader::read(unsigned long, std::__1::vector<DB::MarkRange, std::__1::allocator<DB::MarkRange> >&)  in /usr/bin/clickhouse\r\n4. 0x97684c6 DB::MergeTreeBaseSelectProcessor::readFromPartImpl()  in /usr/bin/clickhouse\r\n5. 0x9769cc3 DB::MergeTreeBaseSelectProcessor::generate()  in /usr/bin/clickhouse\r\n6. 0x91a4c87 DB::ISource::work()  in /usr/bin/clickhouse\r\n7. 0x91d6e84 DB::TreeExecutorBlockInputStream::execute()  in /usr/bin/clickhouse\r\n8. 0x91d70a3 DB::TreeExecutorBlockInputStream::readImpl()  in /usr/bin/clickhouse\r\n9. 0x8a6d24f DB::IBlockInputStream::read()  in /usr/bin/clickhouse\r\n10. 0x949c1c8 DB::ExpressionBlockInputStream::readImpl()  in /usr/bin/clickhouse\r\n11. 0x8a6d24f DB::IBlockInputStream::read()  in /usr/bin/clickhouse\r\n12. 0x949c1c8 DB::ExpressionBlockInputStream::readImpl()  in /usr/bin/clickhouse\r\n13. 0x8a6d24f DB::IBlockInputStream::read()  in /usr/bin/clickhouse\r\n14. 0x8c2a6ec DB::ParallelInputsProcessor<DB::UnionBlockInputStream::Handler>::thread(std::__1::shared_ptr<DB::ThreadGroupStatus>, unsigned long)  in /usr/bin/clickhouse\r\n15. 0x8c2b465 ThreadFromGlobalPool::ThreadFromGlobalPool<void (DB::ParallelInputsProcessor<DB::UnionBlockInputStream::Handler>::*)(std::__1::shared_ptr<DB::ThreadGroupStatus>, unsigned long), DB::ParallelInputsProcessor<DB::UnionBlockInputStream::Handler>*, std::__1::shared_ptr<DB::ThreadGroupStatus>, unsigned long&>(void (DB::ParallelInputsProcessor<DB::UnionBlockInputStream::Handler>::*&&)(std::__1::shared_ptr<DB::ThreadGroupStatus>, unsigned long), DB::ParallelInputsProcessor<DB::UnionBlockInputStream::Handler>*&&, std::__1::shared_ptr<DB::ThreadGroupStatus>&&, unsigned long&)::'lambda'()::operator()() const  in /usr/bin/clickhouse\r\n16. 0x4fa3a77 ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>)  in /usr/bin/clickhouse\r\n17. 0x4fa202f ?  in /usr/bin/clickhouse\r\n18. 0x76db start_thread  in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n19. 0x12188f clone  in /lib/x86_64-linux-gnu/libc-2.27.so\r\n\r\n```\nThis bug is very hard to reproduce. It would be great if you could send data parts from table privately to our mailing list clickhouse-feedback@yandex-team.ru or make a reproducible example on synthetic data.\n@CurtizJ I can prepare VM with the issue and give you access to it. Would that help?\nYes, it's ok.\n@CurtizJ created VM, email sent. Thanks.\nI reproduced it by this example:\r\n```\r\ndrop table if exists t;\r\n\r\ncreate table t (a Int, b Int) engine = MergeTree order by (a, b) settings index_granularity = 400;\r\n\r\ninsert into t select 0, 0 from numbers(50);\r\ninsert into t select 0, 1  from numbers(350);\r\ninsert into t select 1, 2  from numbers(400);\r\ninsert into t select 2, 2  from numbers(400);\r\ninsert into t select 3, 0 from numbers(100);\r\n\r\nset max_threads=1;\r\noptimize table t final;\r\n\r\nselect sum(a) from t where a in (0, 3) and b = 0; \r\n\r\n\u2196 Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.) Received exception from server (version 20.2.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: RangeReader read 100 rows, but 150 expected.: While executing MergeTree.\r\n```\r\n\r\nIt doesn't work only when `MergeTreeSelectProcessor` is used instead of `MergeTreeThreadSelectProcessor`. It's used in several cases: reading in 1 thread, `SELECT` with `FINAL` modifier, reading in order of primary key.\n@CurtizJ I see, thanks. From what I understand I'm the only one who see this issue is because our test env. using low-end VM with only 1 core (and thus `max_threads=1`). Interesting. However, those still look like regression introduced in the latest version. Before the update the were no errors. (and we have multiple similar envs).",
  "created_at": "2020-02-07T21:12:17Z"
}