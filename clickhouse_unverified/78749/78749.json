{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 78749,
  "instance_id": "ClickHouse__ClickHouse-78749",
  "issue_numbers": [
    "77742",
    "66617"
  ],
  "base_commit": "d680e0c060d1e4e7bb8848e5fd4cab164fec9ef3",
  "patch": "diff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex 5934b7875418..32d86f632638 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -58,6 +58,7 @@\n #include <Analyzer/Passes/QueryAnalysisPass.h>\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/WindowFunctionsUtils.h>\n+#include <Analyzer/Utils.h>\n \n #include <Planner/Planner.h>\n #include <Planner/Utils.h>\n@@ -170,6 +171,7 @@ namespace Setting\n     extern const SettingsUInt64 parallel_distributed_insert_select;\n     extern const SettingsBool prefer_localhost_replica;\n     extern const SettingsUInt64 allow_experimental_parallel_reading_from_replicas;\n+    extern const SettingsBool prefer_global_in_and_join;\n }\n \n namespace DistributedSetting\n@@ -779,6 +781,84 @@ class ReplaseAliasColumnsVisitor : public InDepthQueryTreeVisitor<ReplaseAliasCo\n     }\n };\n \n+class RewriteInToGlobalInVisitor : public InDepthQueryTreeVisitorWithContext<RewriteInToGlobalInVisitor>\n+{\n+public:\n+    using Base = InDepthQueryTreeVisitorWithContext<RewriteInToGlobalInVisitor>;\n+    using Base::Base;\n+\n+    void enterImpl(QueryTreeNodePtr & node)\n+    {\n+        if (auto * function_node = node->as<FunctionNode>(); function_node && isNameOfLocalInFunction(function_node->getFunctionName()))\n+        {\n+            auto * query = function_node->getArguments().getNodes()[1]->as<QueryNode>();\n+            if (!query)\n+                return;\n+            bool no_replace = true;\n+            for (const auto & table_node : extractTableExpressions(query->getJoinTree(), false, true))\n+            {\n+                const StorageDistributed * storage_distributed = nullptr;\n+                if (const TableNode * table_node_typed = table_node->as<TableNode>())\n+                    storage_distributed = typeid_cast<const StorageDistributed *>(table_node_typed->getStorage().get());\n+                else if (const TableFunctionNode * table_function_node_typed = table_node->as<TableFunctionNode>())\n+                    storage_distributed = typeid_cast<const StorageDistributed *>(table_function_node_typed->getStorage().get());\n+\n+                if (!storage_distributed)\n+                {\n+                    no_replace = false;\n+                    break;\n+                }\n+            }\n+            if (no_replace)\n+                return;\n+\n+            auto result_function = std::make_shared<FunctionNode>(getGlobalInFunctionNameForLocalInFunctionName(function_node->getFunctionName()));\n+            result_function->getArguments().getNodes() = std::move(function_node->getArguments().getNodes());\n+            resolveOrdinaryFunctionNodeByName(*result_function, result_function->getFunctionName(), getContext());\n+            node = result_function;\n+        }\n+    }\n+\n+    static bool needChildVisit(QueryTreeNodePtr & parent, QueryTreeNodePtr &)\n+    {\n+        if (auto * function_node = parent->as<FunctionNode>(); function_node && function_node->getFunctionName().starts_with(\"global\"))\n+            return false;\n+\n+        return true;\n+    }\n+};\n+\n+bool rewriteJoinToGlobalJoinIfNeeded(QueryTreeNodePtr join_tree)\n+{\n+    bool rewrite = false;\n+\n+    auto * join = join_tree->as<JoinNode>();\n+    if (!join)\n+        return rewrite;\n+\n+    auto table_expression = join->getRightTableExpression();\n+\n+    if (QueryNode * query = table_expression->as<QueryNode>())\n+        rewrite = rewriteJoinToGlobalJoinIfNeeded(query->getJoinTree());\n+    else if (const TableNode * table_node_typed = table_expression->as<TableNode>())\n+    {\n+        if (!typeid_cast<const StorageDistributed *>(table_node_typed->getStorage().get()))\n+            rewrite = true;\n+    }\n+    else if (const TableFunctionNode * table_function_node_typed = table_expression->as<TableFunctionNode>())\n+    {\n+        if (!typeid_cast<const StorageDistributed *>(table_function_node_typed->getStorage().get()))\n+            rewrite = true;\n+    }\n+\n+    if (rewrite)\n+        join->setLocality(JoinLocality::Global);\n+\n+    rewriteJoinToGlobalJoinIfNeeded(join->getLeftTableExpression());\n+\n+    return rewrite;\n+}\n+\n QueryTreeNodePtr buildQueryTreeDistributed(SelectQueryInfo & query_info,\n     const StorageSnapshotPtr & distributed_storage_snapshot,\n     const StorageID & remote_storage_id,\n@@ -834,6 +914,20 @@ QueryTreeNodePtr buildQueryTreeDistributed(SelectQueryInfo & query_info,\n     ReplaseAliasColumnsVisitor replase_alias_columns_visitor;\n     replase_alias_columns_visitor.visit(query_tree_to_modify);\n \n+    const auto & settings = query_context->getSettingsRef();\n+\n+    if (settings[Setting::prefer_global_in_and_join])\n+    {\n+        auto & query_node = query_tree_to_modify->as<QueryNode&>();\n+        if (query_node.hasWhere())\n+        {\n+            RewriteInToGlobalInVisitor visitor(query_context);\n+            visitor.visit(query_node.getWhere());\n+        }\n+\n+        rewriteJoinToGlobalJoinIfNeeded(query_node.getJoinTree());\n+    }\n+\n     return buildQueryTreeForShard(query_info.planner_context, query_tree_to_modify);\n }\n \n",
  "test_patch": "diff --git a/tests/integration/test_prefer_global_in_and_join/__init__.py b/tests/integration/test_prefer_global_in_and_join/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_prefer_global_in_and_join/configs/config.d/clusters.xml b/tests/integration/test_prefer_global_in_and_join/configs/config.d/clusters.xml\nnew file mode 100644\nindex 000000000000..4c1e21554989\n--- /dev/null\n+++ b/tests/integration/test_prefer_global_in_and_join/configs/config.d/clusters.xml\n@@ -0,0 +1,18 @@\n+<clickhouse>\n+<remote_servers>\n+    <cluster>\n+        <shard>\n+            <replica>\n+                <host>ch1</host>\n+                <port>9000</port>\n+            </replica>\n+        </shard>\n+        <shard>\n+            <replica>\n+                <host>ch2</host>\n+                <port>9000</port>\n+            </replica>\n+        </shard>\n+    </cluster>\n+</remote_servers>\n+</clickhouse>\ndiff --git a/tests/integration/test_prefer_global_in_and_join/configs/config.d/distributed_ddl.xml b/tests/integration/test_prefer_global_in_and_join/configs/config.d/distributed_ddl.xml\nnew file mode 100644\nindex 000000000000..1656b6dbeadf\n--- /dev/null\n+++ b/tests/integration/test_prefer_global_in_and_join/configs/config.d/distributed_ddl.xml\n@@ -0,0 +1,5 @@\n+<clickhouse>\n+<distributed_ddl>\n+    <path>/clickhouse/task_queue/ddl</path>\n+</distributed_ddl>\n+</clickhouse>\ndiff --git a/tests/integration/test_prefer_global_in_and_join/test.py b/tests/integration/test_prefer_global_in_and_join/test.py\nnew file mode 100644\nindex 000000000000..6a0d521b6720\n--- /dev/null\n+++ b/tests/integration/test_prefer_global_in_and_join/test.py\n@@ -0,0 +1,73 @@\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+ch1 = cluster.add_instance(\n+    \"ch1\",\n+    main_configs=[\n+        \"configs/config.d/clusters.xml\",\n+        \"configs/config.d/distributed_ddl.xml\",\n+    ],\n+    with_zookeeper=True,\n+)\n+ch2 = cluster.add_instance(\n+    \"ch2\",\n+    main_configs=[\n+        \"configs/config.d/clusters.xml\",\n+        \"configs/config.d/distributed_ddl.xml\",\n+    ],\n+    with_zookeeper=True,\n+)\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+\n+def test_in_and_join(started_cluster):\n+    ch1.query(\"CREATE DATABASE test_default_database ON CLUSTER 'cluster';\")\n+\n+    ch1.query(\n+        database=\"test_default_database\",\n+        sql=\"CREATE TABLE t1 (A Int64) ENGINE = MergeTree ORDER BY A AS SELECT * FROM values((1),(2),(3));\",\n+    )\n+\n+    ch2.query(\n+        database=\"test_default_database\",\n+        sql=\"\"\"\n+CREATE TABLE t1 (A Int64) ENGINE = MergeTree ORDER BY A;\n+CREATE TABLE t1_d AS t1 ENGINE = Distributed('cluster', currentDatabase(), t1);\n+CREATE TABLE t2 (A Int64) ENGINE = MergeTree ORDER BY A AS SELECT * FROM values((1),(2));\n+        \"\"\"\n+    )\n+\n+    assert (\n+        ch2.query(\n+            database=\"test_default_database\",\n+            sql=\"SELECT * FROM t1_d WHERE A IN ( SELECT A FROM t2 ) SETTINGS prefer_global_in_and_join = 1, enable_analyzer = 1\"\n+        ) == \"1\\n2\\n\"\n+    )\n+\n+    assert (\n+        ch2.query(\n+            database=\"test_default_database\",\n+            sql=\"SELECT * FROM t1_d JOIN t2 USING (A) JOIN t2 USING (A) SETTINGS prefer_global_in_and_join = 1, enable_analyzer = 1\"\n+        ) == \"1\\n2\\n\"\n+    )\n+\n+    assert (\n+        ch2.query(\n+            database=\"test_default_database\",\n+            sql=\"SELECT * FROM t1_d JOIN t2 USING (A) SETTINGS prefer_global_in_and_join = 1, enable_analyzer = 1\"\n+        ) == \"1\\n2\\n\"\n+    )\n+\n+    ch1.query(\"DROP DATABASE IF EXISTS test_default_database ON CLUSTER 'cluster' SYNC\")\n",
  "problem_statement": "'distributed_product_mode' not working correctly with new Analyzer\n### Company or project name\n\n_No response_\n\n### Describe what's wrong\n\nWhen running a query like \n`SELECT ...... \nFROM distributed_table \n           INNER JOIN non_distributed_table \nSETTINGS distributed_product_mode = 'global', enable_analyzer = 1`\n\nit throws an error, saying `non_distributed_table` does not exist. My understanding was that distributed_product_mode='global' replaces the IN/JOIN query with GLOBAL IN/GLOBAL JOIN.\n\nBut if I explicitly write GLOBAL INNER JOIN in the query - then it works. It also works if i disable the analyzer.\n\nThis issue is tested on versions 24.8.14.39 and 24.3.11.7.\n\nAt the moment my solution is just to disable the \"new\" analyzer. Any other ideas?\n\n### Does it reproduce on the most recent release?\n\nNo\n\n### How to reproduce\n\nversion: 24.8.14.39\n\n### Expected behavior\n\n_No response_\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n_No response_\nprefer_global_in_and_join has different behaviour with experimental_analyzer with non-distributed tables.\ncluster with 2 shards: `host1 | host2`\r\n\r\n```sql\r\nhost1:\r\ncreate table t1 (A Int64) Engine=MergeTree order by A as select * from values((1),(2),(3));\r\n\r\nhost2:\r\n\r\ncreate table t1 (A Int64) Engine=MergeTree order by A;\r\ncreate table t1_d as t1 Engine=Distributed('cluster', currentDatabase(), t1);\r\ncreate table t2 (A Int64) Engine=MergeTree order by A  as select * from values((1),(2));\r\n\r\nset prefer_global_in_and_join=1;\r\n\r\nselect * from t1_d where A in (select A from t2);\r\nDB::Exception: Received from host1. DB::Exception: Unknown table expression identifier 'default.t2' \r\nin scope (SELECT __table1.A AS A FROM default.t2 AS __table1). (UNKNOWN_TABLE)\r\n\r\n\r\nselect * from t1_d where A global in (select A from t2);\r\n\u250c\u2500A\u2500\u2510 ---- correct result with explicit global\r\n\u2502 1 \u2502 \r\n\u2502 2 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n\r\n\r\nselect * from t1_d where A in (select A from t2) settings allow_experimental_analyzer=0;\r\n\u250c\u2500A\u2500\u2510  ---- correct result without experimental_analyzer\r\n\u2502 1 \u2502   \r\n\u2502 2 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "My guess is that the `distributed_product_mode` setting only applies to joins between two distributed tables.\nWhen you join a distributed table with a non-distributed table the setting is simply ignored.\nBut if you join 2 distributed tables, you don't need the distributed_product_mode setting at all, because the data is already available on each shard - you don't need to \"distribute\" anything. When you join distributed with non-distributed table, you need somehow to \"distribute\" the missing data to other shards. And in such cases I was using `SETTINGS distributed_product_mode = 'global' `(because I don't want to write GLOBAL INNER JOIN all the time in my queries). In the old Analyzer it was working fine, but if the new Analyzer is enabled - it gives an error. \nAnd because many other new features are working only if the new Analyzer is enabled, I don't see a point to upgrade to a new ClickHouse version (currently I'm on 24.3), if I have to disable the Analyzer...\n@ivaniv10 by default Clickhouse assumes that sharding is not proper (like sharding expression `rand()`) and you cannot join two sharded tables even if they have a matching sharding expression (which is not in general). \n`distributed_product_mode = local` -- enforces local joins.\n\nBut I agree that it's at least a backward compatibility issue.\nHow can this backward compatibility issue be addresses and potentially fixed (patched)?\n",
  "created_at": "2025-04-07T04:32:01Z",
  "modified_files": [
    "src/Storages/StorageDistributed.cpp"
  ],
  "modified_test_files": [
    "b/tests/integration/test_prefer_global_in_and_join/configs/config.d/clusters.xml",
    "b/tests/integration/test_prefer_global_in_and_join/configs/config.d/distributed_ddl.xml",
    "b/tests/integration/test_prefer_global_in_and_join/test.py"
  ]
}