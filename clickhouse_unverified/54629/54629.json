{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54629,
  "instance_id": "ClickHouse__ClickHouse-54629",
  "issue_numbers": [
    "38585"
  ],
  "base_commit": "2619eecd2f3311f96474d415d3a1e388030b9fd0",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex cf60eea547bf..69c5aa48155f 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -89,6 +89,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int NOT_IMPLEMENTED;\n     extern const int CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN;\n+    extern const int CANNOT_PARSE_BOOL;\n }\n \n \n@@ -1683,7 +1684,25 @@ struct ConvertImplGenericFromString\n \n                 const auto & val = col_from_string->getDataAt(i);\n                 ReadBufferFromMemory read_buffer(val.data, val.size);\n-                serialization_from.deserializeWholeText(column_to, read_buffer, format_settings);\n+                try\n+                {\n+                    serialization_from.deserializeWholeText(column_to, read_buffer, format_settings);\n+                }\n+                catch (const Exception & e)\n+                {\n+                    auto * nullable_column = typeid_cast<ColumnNullable *>(&column_to);\n+                    if (e.code() == ErrorCodes::CANNOT_PARSE_BOOL && nullable_column)\n+                    {\n+                        auto & col_nullmap = nullable_column->getNullMapData();\n+                        if (col_nullmap.size() != nullable_column->size())\n+                            col_nullmap.resize_fill(nullable_column->size());\n+                        if (nullable_column->size() == (i + 1))\n+                            nullable_column->popBack(1);\n+                        nullable_column->insertDefault();\n+                        continue;\n+                    }\n+                    throw;\n+                }\n \n                 if (!read_buffer.eof())\n                 {\n@@ -4177,15 +4196,21 @@ class FunctionCast final : public FunctionCastBase\n             {\n                 if constexpr (std::is_same_v<ToDataType, DataTypeIPv4>)\n                 {\n-                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv4_default_on_conversion_error_value, requested_result_is_nullable](\n-                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n-                            -> ColumnPtr\n+                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n+                           input_format_ipv4_default_on_conversion_error_value,\n+                           requested_result_is_nullable](\n+                              ColumnsWithTypeAndName & arguments,\n+                              const DataTypePtr & result_type,\n+                              const ColumnNullable * column_nullable,\n+                              size_t) -> ColumnPtr\n                     {\n                         if (!WhichDataType(result_type).isIPv4())\n                             throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n \n                         const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                        if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value || requested_result_is_nullable)\n+                        if (requested_result_is_nullable)\n+                            return convertToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n+                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv4_default_on_conversion_error_value)\n                             return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                         else\n                             return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n@@ -4196,16 +4221,22 @@ class FunctionCast final : public FunctionCastBase\n \n                 if constexpr (std::is_same_v<ToDataType, DataTypeIPv6>)\n                 {\n-                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value, input_format_ipv6_default_on_conversion_error_value, requested_result_is_nullable](\n-                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n-                            -> ColumnPtr\n+                    ret = [cast_ipv4_ipv6_default_on_conversion_error_value,\n+                           input_format_ipv6_default_on_conversion_error_value,\n+                           requested_result_is_nullable](\n+                              ColumnsWithTypeAndName & arguments,\n+                              const DataTypePtr & result_type,\n+                              const ColumnNullable * column_nullable,\n+                              size_t) -> ColumnPtr\n                     {\n                         if (!WhichDataType(result_type).isIPv6())\n                             throw Exception(\n                                 ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv6\", result_type->getName());\n \n                         const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                        if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value || requested_result_is_nullable)\n+                        if (requested_result_is_nullable)\n+                            return convertToIPv6<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n+                        else if (cast_ipv4_ipv6_default_on_conversion_error_value || input_format_ipv6_default_on_conversion_error_value)\n                             return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                         else\n                             return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n@@ -4216,7 +4247,18 @@ class FunctionCast final : public FunctionCastBase\n \n                 if (to_type->getCustomSerialization() && to_type->getCustomName())\n                 {\n-                    ret = &ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute;\n+                    ret = [requested_result_is_nullable](\n+                              ColumnsWithTypeAndName & arguments,\n+                              const DataTypePtr & result_type,\n+                              const ColumnNullable * column_nullable,\n+                              size_t input_rows_count) -> ColumnPtr\n+                    {\n+                        auto wrapped_result_type = result_type;\n+                        if (requested_result_is_nullable)\n+                            wrapped_result_type = makeNullable(result_type);\n+                        return ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute(\n+                            arguments, wrapped_result_type, column_nullable, input_rows_count);\n+                    };\n                     return true;\n                 }\n             }\n@@ -4231,7 +4273,9 @@ class FunctionCast final : public FunctionCastBase\n                             ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n \n                     const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n-                    if (cast_ipv4_ipv6_default_on_conversion_error_value || requested_result_is_nullable)\n+                    if (requested_result_is_nullable)\n+                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Null>(arguments[0].column, null_map);\n+                    else if (cast_ipv4_ipv6_default_on_conversion_error_value)\n                         return convertIPv6ToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n                     else\n                         return convertIPv6ToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\nindex 31a9c37421e8..a2ccd5af8688 100644\n--- a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n@@ -42,3 +42,21 @@\n 2023-05-30\n 2149-06-06\n 1970-01-20\n+\\N\n+\\N\n+\\N\n+true\n+false\n+true\n+false\n+true\n+false\n+\\N\n+\\N\n+\\N\n+192.0.2.1\n+\\N\n+\\N\n+::ffff:192.0.2.1\n+2001:db8::1\n+\\N\ndiff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\nindex f00f6ef837ff..2fb7b1177e61 100644\n--- a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n@@ -49,3 +49,24 @@ SELECT accurateCastOrNull('1xxx', 'Date');\n SELECT accurateCastOrNull('2023-05-30', 'Date');\n SELECT accurateCastOrNull('2180-01-01', 'Date');\n SELECT accurateCastOrNull(19, 'Date');\n+\n+select accurateCastOrNull('test', 'Bool');\n+select accurateCastOrNull('truex', 'Bool');\n+select accurateCastOrNull('xfalse', 'Bool');\n+select accurateCastOrNull('true', 'Bool');\n+select accurateCastOrNull('false', 'Bool');\n+select accurateCastOrNull('1', 'Bool');\n+select accurateCastOrNull('0', 'Bool');\n+select accurateCastOrNull(1, 'Bool');\n+select accurateCastOrNull(0, 'Bool');\n+\n+select accurateCastOrNull('test', 'IPv4');\n+select accurateCastOrNull('2001:db8::1', 'IPv4');\n+select accurateCastOrNull('::ffff:192.0.2.1', 'IPv4');\n+select accurateCastOrNull('192.0.2.1', 'IPv4');\n+select accurateCastOrNull('192.0.2.1x', 'IPv4');\n+\n+select accurateCastOrNull('test', 'IPv6');\n+select accurateCastOrNull('192.0.2.1', 'IPv6');\n+select accurateCastOrNull('2001:db8::1', 'IPv6');\n+select accurateCastOrNull('2001:db8::1x', 'IPv6');\ndiff --git a/tests/queries/0_stateless/01601_accurate_cast.reference b/tests/queries/0_stateless/01601_accurate_cast.reference\nindex 3c6dceb1f168..dbf9666f4cd8 100644\n--- a/tests/queries/0_stateless/01601_accurate_cast.reference\n+++ b/tests/queries/0_stateless/01601_accurate_cast.reference\n@@ -10,3 +10,15 @@\n 1970-01-01 00:00:19\n 2023-05-30\n 1970-01-20\n+\\N\n+true\n+false\n+true\n+false\n+true\n+false\n+\\N\n+192.0.2.1\n+\\N\n+::ffff:192.0.2.1\n+2001:db8::1\ndiff --git a/tests/queries/0_stateless/01601_accurate_cast.sql b/tests/queries/0_stateless/01601_accurate_cast.sql\nindex 2108e42df055..d2ecede24023 100644\n--- a/tests/queries/0_stateless/01601_accurate_cast.sql\n+++ b/tests/queries/0_stateless/01601_accurate_cast.sql\n@@ -34,3 +34,27 @@ SELECT accurateCast(0xFFFFFFFF + 1, 'Date');   -- { serverError CANNOT_CONVERT_T\n SELECT accurateCast('1xxx', 'Date');   -- { serverError CANNOT_PARSE_DATE }\n SELECT accurateCast('2023-05-30', 'Date');\n SELECT accurateCast(19, 'Date');\n+\n+select accurateCast('test', 'Nullable(Bool)');\n+select accurateCast('test', 'Bool');   -- { serverError CANNOT_PARSE_BOOL }\n+select accurateCast('truex', 'Bool');   -- { serverError CANNOT_PARSE_BOOL }\n+select accurateCast('xfalse', 'Bool');   -- { serverError CANNOT_PARSE_BOOL }\n+select accurateCast('true', 'Bool');\n+select accurateCast('false', 'Bool');\n+select accurateCast('1', 'Bool');\n+select accurateCast('0', 'Bool');\n+select accurateCast(1, 'Bool');\n+select accurateCast(0, 'Bool');\n+\n+select accurateCast('test', 'Nullable(IPv4)');\n+select accurateCast('test', 'IPv4');   -- { serverError CANNOT_PARSE_IPV4 }\n+select accurateCast('2001:db8::1', 'IPv4');   -- { serverError CANNOT_PARSE_IPV4 }\n+select accurateCast('::ffff:192.0.2.1', 'IPv4');   -- { serverError CANNOT_PARSE_IPV4 }\n+select accurateCast('192.0.2.1', 'IPv4');\n+select accurateCast('192.0.2.1x', 'IPv4');   -- { serverError CANNOT_PARSE_IPV4 }\n+\n+select accurateCast('test', 'Nullable(IPv6)');\n+select accurateCast('test', 'IPv6');   -- { serverError CANNOT_PARSE_IPV6 }\n+select accurateCast('192.0.2.1', 'IPv6');\n+select accurateCast('2001:db8::1', 'IPv6');\n+select accurateCast('2001:db8::1x', 'IPv6');   -- { serverError CANNOT_PARSE_IPV6 }\ndiff --git a/tests/queries/0_stateless/02026_accurate_cast_or_default.reference b/tests/queries/0_stateless/02026_accurate_cast_or_default.reference\nindex 67be2da9975e..c31e00dd8f40 100644\n--- a/tests/queries/0_stateless/02026_accurate_cast_or_default.reference\n+++ b/tests/queries/0_stateless/02026_accurate_cast_or_default.reference\n@@ -30,3 +30,24 @@\n 0\t5\n 127\t127\n 0\t5\n+\\N\n+false\n+false\n+false\n+true\n+false\n+true\n+false\n+true\n+false\n+\\N\n+0.0.0.0\n+0.0.0.0\n+0.0.0.0\n+192.0.2.1\n+0.0.0.0\n+\\N\n+::\n+::ffff:192.0.2.1\n+2001:db8::1\n+::\ndiff --git a/tests/queries/0_stateless/02026_accurate_cast_or_default.sql b/tests/queries/0_stateless/02026_accurate_cast_or_default.sql\nindex 1c35055749e8..d493914c9567 100644\n--- a/tests/queries/0_stateless/02026_accurate_cast_or_default.sql\n+++ b/tests/queries/0_stateless/02026_accurate_cast_or_default.sql\n@@ -34,3 +34,27 @@ SELECT accurateCastOrDefault(nan, 'UInt64'), accurateCastOrDefault(nan, 'UInt64'\n SELECT accurateCastOrDefault(nan, 'UInt256'), accurateCastOrDefault(nan, 'UInt256', toUInt256(5));\n \n SELECT accurateCastOrDefault(number + 127, 'Int8') AS x, accurateCastOrDefault(number + 127, 'Int8', toInt8(5)) AS x_with_default FROM numbers (2) ORDER BY number;\n+\n+select accurateCastOrDefault('test', 'Nullable(Bool)');\n+select accurateCastOrDefault('test', 'Bool');\n+select accurateCastOrDefault('truex', 'Bool');\n+select accurateCastOrDefault('xfalse', 'Bool');\n+select accurateCastOrDefault('true', 'Bool');\n+select accurateCastOrDefault('false', 'Bool');\n+select accurateCastOrDefault('1', 'Bool');\n+select accurateCastOrDefault('0', 'Bool');\n+select accurateCastOrDefault(1, 'Bool');\n+select accurateCastOrDefault(0, 'Bool');\n+\n+select accurateCastOrDefault('test', 'Nullable(IPv4)');\n+select accurateCastOrDefault('test', 'IPv4');\n+select accurateCastOrDefault('2001:db8::1', 'IPv4');\n+select accurateCastOrDefault('::ffff:192.0.2.1', 'IPv4');\n+select accurateCastOrDefault('192.0.2.1', 'IPv4');\n+select accurateCastOrDefault('192.0.2.1x', 'IPv4');\n+\n+select accurateCastOrDefault('test', 'Nullable(IPv6)');\n+select accurateCastOrDefault('test', 'IPv6');\n+select accurateCastOrDefault('192.0.2.1', 'IPv6');\n+select accurateCastOrDefault('2001:db8::1', 'IPv6');\n+select accurateCastOrDefault('2001:db8::1x', 'IPv6');\ndiff --git a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference\nindex 159ee805f265..717484d46704 100644\n--- a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference\n+++ b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.reference\n@@ -17,7 +17,7 @@ true\n \\N\n 0.0.0.0\n \\N\n-0.0.0.0\n+\\N\n \\N\n \\N\n \\N\n@@ -25,8 +25,21 @@ true\n \\N\n ::\n \\N\n-::\n+\\N\n \\N\n \\N\n \\N\n \\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\n+fuzzer issue\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql\nindex 1cc5140f3399..b56ebc2b09dc 100644\n--- a/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql\n+++ b/tests/queries/0_stateless/02303_cast_nullable_to_custom_types.sql\n@@ -22,3 +22,9 @@ select toIPv6(number % 2 ? '0000:0000:0000:0000:0000:0000:0000:0000' : NULL) fro\n select toIPv6OrDefault(number % 2 ? '' : NULL) from numbers(2);\n select toIPv6OrNull(number % 2 ? '' : NULL) from numbers(2);\n select IPv6StringToNum(number % 2 ? '0000:0000:0000:0000:0000:0000:0000:0000' : NULL) from numbers(2);\n+\n+select 'fuzzer issue';\n+SELECT CAST(if(number % 2, 'truetrue', NULL), 'Nullable(Bool)') FROM numbers(2);\n+SELECT CAST(if(number % 2, 'falsefalse', NULL), 'Nullable(Bool)') FROM numbers(2);\n+SELECT accurateCastOrNull(if(number % 2, NULL, 'truex'), 'Bool') FROM numbers(4);\n+SELECT accurateCastOrNull(if(number % 2, 'truex', NULL), 'Bool') FROM numbers(4);\n",
  "problem_statement": "accurateCastOrNull raises an exception, rather than simply returning null when casting an invalid value to Bool\n**Describe what's wrong**\r\n\r\naccurateCastOrNull raises an exception, rather than simply returning null when casting an invalid value to Bool\r\n\r\n```\r\nCode: 467. DB::Exception: Received from 127.0.0.1:9000. DB::Exception: Cannot parse boolean value here: 'test', should be 'true' or 'false' controlled by setting bool_true_representation and bool_false_representation or one of True/False/T/F/Y/N/Yes/No/On/Off/Enable/Disable/Enabled/Disabled/1/0: While processing accurateCastOrNull('test', 'Bool'). (CANNOT_PARSE_BOOL)\r\n```\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nClickHouse server version 22.7.1.906 (official build).\r\n\r\n**How to reproduce**\r\n\r\n```\r\nselect accurateCastOrNull('test', 'Bool')\r\n```\r\n\r\n**Expected behavior**\r\n\r\n```\r\nI expect it to behave the same as an invalid cast to something like UInt8\r\n\r\nSELECT accurateCastOrNull('test', 'UInt8')\r\n\r\nQuery id: e7d0473b-6ae0-455d-9eae-fb3827e7c671\r\n\r\n\u250c\u2500accurateCastOrNull('test', 'UInt8')\u2500\u2510\r\n\u2502                                \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "@alexey-milovidov @antonio2368 \r\nI'm also experiencing this, and it's pretty easy to reproduce as well. \r\nThe work around that I found - which is suitable for our use case, doesn't mean it works for every case - is to use `reinterpret` which will return true if there's a value:\r\n\r\n```\r\na60baef7f266 :) select reinterpret('', 'Boolean')\r\n\r\nSELECT reinterpret('', 'Boolean')\r\n\r\nQuery id: b5324ddf-9854-4f16-bdac-c3f95348cb5e\r\n\r\n\u250c\u2500reinterpret('', 'Boolean')\u2500\u2510\r\n\u2502 false                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.005 sec.\r\n\r\na60baef7f266 :) select reinterpret('test', 'Boolean')\r\n\r\nSELECT reinterpret('test', 'Boolean')\r\n\r\nQuery id: 4006fc47-d025-4931-a90c-fccd03f87bac\r\n\r\n\u250c\u2500reinterpret('test', 'Boolean')\u2500\u2510\r\n\u2502 true                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.004 sec.\r\n```\r\n\r\nCan we get some \ud83d\udc40 ?\r\nThanks in advanced!",
  "created_at": "2023-09-14T11:57:45Z"
}