{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 2958,
  "instance_id": "ClickHouse__ClickHouse-2958",
  "issue_numbers": [
    "2367"
  ],
  "base_commit": "3be0b6ca6dba9507306033e62d421b672703ba83",
  "patch": "diff --git a/dbms/src/Formats/JSONEachRowRowInputStream.cpp b/dbms/src/Formats/JSONEachRowRowInputStream.cpp\nindex c47111e047d7..01ddfa96df97 100644\n--- a/dbms/src/Formats/JSONEachRowRowInputStream.cpp\n+++ b/dbms/src/Formats/JSONEachRowRowInputStream.cpp\n@@ -120,7 +120,7 @@ bool JSONEachRowRowInputStream::read(MutableColumns & columns)\n                 throw Exception(\"Unknown field found while parsing JSONEachRow format: \" + name_ref.toString(), ErrorCodes::INCORRECT_DATA);\n \n             skipColonDelimeter(istr);\n-            skipJSONFieldPlain(istr, name_ref);\n+            skipJSONField(istr, name_ref);\n             continue;\n         }\n \ndiff --git a/dbms/src/IO/ReadHelpers.cpp b/dbms/src/IO/ReadHelpers.cpp\nindex 6c982e688915..f9f051ab0914 100644\n--- a/dbms/src/IO/ReadHelpers.cpp\n+++ b/dbms/src/IO/ReadHelpers.cpp\n@@ -777,10 +777,10 @@ template void readDateTimeTextFallback<void>(time_t &, ReadBuffer &, const DateL\n template bool readDateTimeTextFallback<bool>(time_t &, ReadBuffer &, const DateLUTImpl &);\n \n \n-void skipJSONFieldPlain(ReadBuffer & buf, const StringRef & name_of_filed)\n+void skipJSONField(ReadBuffer & buf, const StringRef & name_of_field)\n {\n     if (buf.eof())\n-        throw Exception(\"Unexpected EOF for key '\" + name_of_filed.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+        throw Exception(\"Unexpected EOF for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n     else if (*buf.position() == '\"') /// skip double-quoted string\n     {\n         NullSink sink;\n@@ -793,7 +793,7 @@ void skipJSONFieldPlain(ReadBuffer & buf, const StringRef & name_of_filed)\n \n         double v;\n         if (!tryReadFloatText(v, buf))\n-            throw Exception(\"Expected a number field for key '\" + name_of_filed.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+            throw Exception(\"Expected a number field for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n     }\n     else if (*buf.position() == 'n') /// skip null\n     {\n@@ -820,7 +820,7 @@ void skipJSONFieldPlain(ReadBuffer & buf, const StringRef & name_of_filed)\n \n         while (true)\n         {\n-            skipJSONFieldPlain(buf, name_of_filed);\n+            skipJSONField(buf, name_of_field);\n             skipWhitespaceIfAny(buf);\n \n             if (!buf.eof() && *buf.position() == ',')\n@@ -834,16 +834,50 @@ void skipJSONFieldPlain(ReadBuffer & buf, const StringRef & name_of_filed)\n                 break;\n             }\n             else\n-                throw Exception(\"Unexpected symbol for key '\" + name_of_filed.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+                throw Exception(\"Unexpected symbol for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n         }\n     }\n-    else if (*buf.position() == '{') /// fail on objects\n+    else if (*buf.position() == '{') /// skip whole object\n     {\n-        throw Exception(\"Unexpected nested field for key '\" + name_of_filed.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+        ++buf.position();\n+        skipWhitespaceIfAny(buf);\n+\n+        while (!buf.eof() && *buf.position() != '}')\n+        {\n+            // field name\n+            if (*buf.position() == '\"')\n+            {\n+                NullSink sink;\n+                readJSONStringInto(sink, buf);\n+            } \n+            else\n+                throw Exception(\"Unexpected symbol for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+\n+            // ':'\n+            skipWhitespaceIfAny(buf);\n+            if (buf.eof() || !(*buf.position() == ':'))\n+                throw Exception(\"Unexpected symbol for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+            ++buf.position();\n+            skipWhitespaceIfAny(buf);\n+\n+            skipJSONField(buf, name_of_field);\n+            skipWhitespaceIfAny(buf);\n+\n+            // optional ','\n+            if (!buf.eof() && *buf.position() == ',')\n+            {\n+                ++buf.position();\n+                skipWhitespaceIfAny(buf);\n+            }\n+        }\n+\n+        if (buf.eof())\n+            throw Exception(\"Unexpected EOF for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+        ++buf.position();\n     }\n     else\n     {\n-        throw Exception(\"Unexpected symbol '\" + std::string(*buf.position(), 1) + \"' for key '\" + name_of_filed.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n+        throw Exception(\"Unexpected symbol '\" + std::string(*buf.position(), 1) + \"' for key '\" + name_of_field.toString() + \"'\", ErrorCodes::INCORRECT_DATA);\n     }\n }\n \ndiff --git a/dbms/src/IO/ReadHelpers.h b/dbms/src/IO/ReadHelpers.h\nindex 5bb89db65469..6c13b83c69dc 100644\n--- a/dbms/src/IO/ReadHelpers.h\n+++ b/dbms/src/IO/ReadHelpers.h\n@@ -818,8 +818,8 @@ inline void skipWhitespaceIfAny(ReadBuffer & buf)\n         ++buf.position();\n }\n \n-/// Skips json value. If the value contains objects (i.e. {...} sequence), an exception will be thrown.\n-void skipJSONFieldPlain(ReadBuffer & buf, const StringRef & name_of_filed);\n+/// Skips json value.\n+void skipJSONField(ReadBuffer & buf, const StringRef & name_of_field);\n \n \n /** Read serialized exception.\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.reference b/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.reference\nindex 9c6e5280882d..8d299f231351 100644\n--- a/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.reference\n+++ b/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.reference\n@@ -4,5 +4,6 @@\n 1\tok\n 1\tok\n 1\tok\n+1\tok\n \n 2017-08-31 18:36:48\ndiff --git a/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.sh b/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.sh\nindex d5410c44e9a2..dfe508ad1243 100755\n--- a/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.sh\n+++ b/dbms/tests/queries/0_stateless/00374_json_each_row_input_with_noisy_fields.sh\n@@ -13,6 +13,7 @@ echo '{\"d1\" : 1, \"d2\" : \"ok\"}\n {\"t1\" : 0, \"t2\":true,\"t3\":false, \"t4\":null,\"t5\":[],\"t6\":\"trash\" }\n {\"d2\":\"ok\",\"t1\":[[[]],true, null, false, \"1\",\"2\",9.03,101], \"t2\":[[\"1\",\"2\"]], \"d1\":\"1\"}\n {\"d2\":\"ok\",\"t1\":[[[]],true, null, false, \"1\",\"2\", 0.03, 1], \"d1\":\"1\", \"t2\":[\"1\",\"2\"]}\n+{\"d2\":\"ok\",\"t1\":{\"a\":{\"b\": {} ,\"c\":false},\"b\":[true,null, false]}, \"t2\":  { \"a\": [  ] } , \"d1\":1}\n {\"t0\" : -0.1, \"t1\" : +1, \"t2\" : 0, \"t3\" : [0.0, -0.1], \"d2\" : \"ok\", \"d1\" : 1}' \\\n | $CLICKHOUSE_CLIENT --input_format_skip_unknown_fields=1 -q \"INSERT INTO test.json_noisy FORMAT JSONEachRow\"\n \n",
  "problem_statement": "Cannot skip nested JSON field when inserting JSON data with input_format_skip_unknown_fields=1\nHello,\r\nFollowing cmd fails if input JSON contains nested fields: \r\n\r\n`clickhouse-client --input_format_skip_unknown_fields=1 --query=\"INSERT INTO my_table FORMAT JSONEachRow\" < my.json`\r\n\r\n**Code: 117. DB::Exception: Unexpected nested field for key 'originalMsg'**\r\n\r\nIn my case input JSON contains fields prepared for insertion into clickhouse and  'originalMsg' filed containing 'backup data' which is valid JSON object too.\n",
  "hints_text": "Clickhouse doesn't support deep structures in JSON like `{\"x\": {\"a\":\"1\", \"b\":\"2\"}}`.\r\nIf your input data doesn't contain such a deep structures, and ClickHouse still complain that something's wrong, please provide some sample of your JSON. \nI don't use nested fields in target table however nested field exists in my input JSON. \r\nI use --input_format_skip_unknown_fields=1 specifically to ignore that nested field. \r\n\r\nHowever it doesn't work. See exception above.\r\nIf I don't use that field then why Clickhouse cares if it's nested or not? \nClickhouse use quick and dirty JSON parser, which does not how to read complex deep structures. So it can't skip that field as it does not know where that nested structure ends.\r\nSorry. :/\r\n\r\nSo you should preprocess your json with some external tools, of you can contribute to Clickhouse and improve JSON parser.",
  "created_at": "2018-08-27T04:03:47Z"
}