{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41110,
  "instance_id": "ClickHouse__ClickHouse-41110",
  "issue_numbers": [
    "40325"
  ],
  "base_commit": "8bdf63f8e59a070a2e46df4b17abf0fb141f303a",
  "patch": "diff --git a/.github/workflows/backport_branches.yml b/.github/workflows/backport_branches.yml\nindex cbd3bd7bec42..c52a58eac8aa 100644\n--- a/.github/workflows/backport_branches.yml\n+++ b/.github/workflows/backport_branches.yml\n@@ -683,3 +683,4 @@ jobs:\n         run: |\n           cd \"$GITHUB_WORKSPACE/tests/ci\"\n           python3 finish_check.py\n+          python3 merge_pr.py\ndiff --git a/.github/workflows/docs_check.yml b/.github/workflows/docs_check.yml\nindex a513eb9216de..d69020d810e8 100644\n--- a/.github/workflows/docs_check.yml\n+++ b/.github/workflows/docs_check.yml\n@@ -169,3 +169,4 @@ jobs:\n         run: |\n           cd \"$GITHUB_WORKSPACE/tests/ci\"\n           python3 finish_check.py\n+          python3 merge_pr.py --check-approved\ndiff --git a/.github/workflows/pull_request.yml b/.github/workflows/pull_request.yml\nindex aecf3799a5d2..c677ec4bf5c7 100644\n--- a/.github/workflows/pull_request.yml\n+++ b/.github/workflows/pull_request.yml\n@@ -4388,3 +4388,4 @@ jobs:\n         run: |\n           cd \"$GITHUB_WORKSPACE/tests/ci\"\n           python3 finish_check.py\n+          python3 merge_pr.py --check-approved\n",
  "test_patch": "diff --git a/tests/ci/merge_pr.py b/tests/ci/merge_pr.py\nnew file mode 100644\nindex 000000000000..d5569ff0d993\n--- /dev/null\n+++ b/tests/ci/merge_pr.py\n@@ -0,0 +1,205 @@\n+#!/usr/bin/env python\n+\n+\"\"\"Script to check if PR is mergeable and merge it\"\"\"\n+\n+import argparse\n+import logging\n+\n+from datetime import datetime\n+from os import getenv\n+from typing import Dict, List\n+\n+from github.PullRequestReview import PullRequestReview\n+\n+from commit_status_helper import get_commit_filtered_statuses\n+from get_robot_token import get_best_robot_token\n+from github_helper import GitHub, NamedUser, PullRequest\n+from pr_info import PRInfo\n+\n+\n+# The team name for accepted approvals\n+TEAM_NAME = getenv(\"GITHUB_TEAM_NAME\", \"core\")\n+\n+\n+class Reviews:\n+    STATES = [\"CHANGES_REQUESTED\", \"APPROVED\"]\n+\n+    def __init__(self, pr: PullRequest):\n+        \"\"\"The reviews are proceed in the next logic:\n+        - if review for an author does not exist, set it\n+        - the review status can be changed from CHANGES_REQUESTED and APPROVED\n+            only to either one\n+        \"\"\"\n+        logging.info(\"Checking the PR for approvals\")\n+        self.pr = pr\n+        self.reviews = pr.get_reviews()\n+        # the reviews are ordered by time\n+        self._review_per_user = {}  # type: Dict[NamedUser, PullRequestReview]\n+        self.approved_at = datetime.fromtimestamp(0)\n+        for r in self.reviews:\n+            user = r.user\n+            if self._review_per_user.get(user):\n+                if r.state in self.STATES:\n+                    self._review_per_user[user] = r\n+                    if r.state == \"APPROVED\":\n+                        self.approved_at = max(r.submitted_at, self.approved_at)\n+                continue\n+            self._review_per_user[user] = r\n+\n+    def is_approved(self, team: List[NamedUser]) -> bool:\n+        \"\"\"Checks if the PR is approved, and no changes made after the last approval\"\"\"\n+        if not self.reviews:\n+            logging.info(\"There aren't reviews for PR #%s\", self.pr.number)\n+            return False\n+\n+        # We consider reviews only from the given list of users\n+        statuses = {\n+            r.state\n+            for user, r in self._review_per_user.items()\n+            if r.state == \"CHANGES_REQUESTED\"\n+            or (r.state == \"APPROVED\" and user in team)\n+        }\n+\n+        if \"CHANGES_REQUESTED\" in statuses:\n+            logging.info(\n+                \"The following users requested changes for the PR: %s\",\n+                \", \".join(\n+                    user.login\n+                    for user, r in self._review_per_user.items()\n+                    if r.state == \"CHANGES_REQUESTED\"\n+                ),\n+            )\n+            return False\n+\n+        if \"APPROVED\" in statuses:\n+            logging.info(\n+                \"The following users from %s team approved the PR: %s\",\n+                TEAM_NAME,\n+                \", \".join(\n+                    user.login\n+                    for user, r in self._review_per_user.items()\n+                    if r.state == \"APPROVED\" and user in team\n+                ),\n+            )\n+            # The only reliable place to get the 100% accurate last_modified\n+            # info is when the commit was pushed to GitHub. The info is\n+            # available as a header 'last-modified' of /{org}/{repo}/commits/{sha}.\n+            # Unfortunately, it's formatted as 'Wed, 04 Jan 2023 11:05:13 GMT'\n+\n+            commit = self.pr.head.repo.get_commit(self.pr.head.sha)\n+            if commit.stats.last_modified is None:\n+                logging.warning(\n+                    \"Unable to get info about the commit %s\", self.pr.head.sha\n+                )\n+                return False\n+\n+            last_changed = datetime.strptime(\n+                commit.stats.last_modified, \"%a, %d %b %Y %H:%M:%S GMT\"\n+            )\n+            if self.approved_at < last_changed:\n+                logging.info(\n+                    \"There are changes after approve at %s\",\n+                    self.approved_at.isoformat(),\n+                )\n+                return False\n+            return True\n+\n+        logging.info(\"The PR #%s is not approved\", self.pr.number)\n+        return False\n+\n+\n+def parse_args() -> argparse.Namespace:\n+    pr_info = PRInfo()\n+    parser = argparse.ArgumentParser(\n+        formatter_class=argparse.ArgumentDefaultsHelpFormatter,\n+        description=\"Script to merge the given PR. Additional checks for approved \"\n+        \"status and green commit statuses could be done\",\n+    )\n+    parser.add_argument(\n+        \"--check-approved\",\n+        action=\"store_true\",\n+        help=\"if set, checks that the PR is approved and no changes required\",\n+    )\n+    parser.add_argument(\"--check-green\", default=True, help=argparse.SUPPRESS)\n+    parser.add_argument(\n+        \"--no-check-green\",\n+        dest=\"check_green\",\n+        action=\"store_false\",\n+        default=argparse.SUPPRESS,\n+        help=\"(dangerous) if set, skip check commit to having all green statuses\",\n+    )\n+    parser.add_argument(\n+        \"--repo\",\n+        default=pr_info.repo_full_name,\n+        help=\"PR number to check\",\n+    )\n+    parser.add_argument(\n+        \"--pr\",\n+        type=int,\n+        default=pr_info.number,\n+        help=\"PR number to check\",\n+    )\n+    parser.add_argument(\n+        \"--token\",\n+        type=str,\n+        default=\"\",\n+        help=\"a token to use for GitHub API requests, will be received from SSM \"\n+        \"if empty\",\n+    )\n+    args = parser.parse_args()\n+    args.pr_info = pr_info\n+    return args\n+\n+\n+def main():\n+    logging.basicConfig(level=logging.INFO, format=\"%(asctime)s %(message)s\")\n+    args = parse_args()\n+    logging.info(\"Going to process PR #%s in repo %s\", args.pr, args.repo)\n+    token = args.token or get_best_robot_token()\n+    gh = GitHub(token, per_page=100)\n+    repo = gh.get_repo(args.repo)\n+    # An ugly and not nice fix to patch the wrong organization URL,\n+    # see https://github.com/PyGithub/PyGithub/issues/2395#issuecomment-1378629710\n+    # pylint: disable=protected-access\n+    repo.organization._url.value = repo.organization.url.replace(  # type: ignore\n+        \"/users/\", \"/orgs/\", 1\n+    )\n+    # pylint: enable=protected-access\n+    pr = repo.get_pull(args.pr)\n+    if pr.is_merged():\n+        logging.info(\"The PR #%s is already merged\", pr.number)\n+        return\n+\n+    not_ready_to_merge = pr.draft or \"WIP\" in pr.title\n+    if not_ready_to_merge:\n+        logging.info(\"The PR #%s is not ready for merge, stopping\", pr.number)\n+        return\n+\n+    if args.check_green:\n+        logging.info(\"Checking that all PR's statuses are green\")\n+        commit = repo.get_commit(pr.head.sha)\n+        failed_statuses = [\n+            status.context\n+            for status in get_commit_filtered_statuses(commit)\n+            if status.state != \"success\"\n+        ]\n+        if failed_statuses:\n+            logging.warning(\n+                \"Some statuses aren't success:\\n  %s\", \",\\n  \".join(failed_statuses)\n+            )\n+            return\n+\n+    if args.check_approved:\n+        reviews = Reviews(pr)\n+        team = repo.organization.get_team_by_slug(TEAM_NAME)\n+        members = list(team.get_members())\n+        if not reviews.is_approved(members):\n+            logging.warning(\"We don't merge the PR\")\n+            return\n+\n+    logging.info(\"Merging the PR\")\n+    pr.merge()\n+\n+\n+if __name__ == \"__main__\":\n+    main()\n",
  "problem_statement": "Automatically merge the best pull requests\nIf a pull request is approved and has no modifications after it is approved and all the checks are green and there are more than 100 checks, merge automatically.\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/be29057de1835f6f4a17e03a422b45b81efe6833/docs/ru/whats-new/extended-roadmap.md#735-%D0%BD%D0%B0%D1%87%D0%B0%D0%BB%D1%8C%D0%BD%D1%8B%D0%B5-%D0%BF%D1%80%D0%B0%D0%B2%D0%B8%D0%BB%D0%B0-%D0%B4%D0%BB%D1%8F-%D0%B0%D0%B2%D1%82%D0%BE-merge-nachalnye-pravila-dlia-avto-merge\n",
  "hints_text": "Usually, it's the github button `automatic merge on the green`. But with our `Mergeable` we can't actually use this.\r\n\r\nIn our case, it works another way around. `Mergeable` is green from the beginning, and eventually can be red.\r\n\r\nWhat we can do is add an automatic merge to the `Finish` check. But once added, it will merge anything green.\n> What we can do is add an automatic merge to the Finish check. But once added, it will merge anything green.\r\n\r\nJust check if there is approval, and no commits after the approval.\nIt makes sense. Would work, for sure.\r\n\r\nDo we consider only merges to master, or backports too?\nThis is for master.\r\n\r\nFor backports we need to use an even simpler method - only check for green checks and nothing else (no review).",
  "created_at": "2022-09-08T15:24:52Z",
  "modified_files": [
    ".github/workflows/backport_branches.yml",
    ".github/workflows/docs_check.yml",
    ".github/workflows/pull_request.yml"
  ],
  "modified_test_files": [
    "b/tests/ci/merge_pr.py"
  ]
}