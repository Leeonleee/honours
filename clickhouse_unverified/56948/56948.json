{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56948,
  "instance_id": "ClickHouse__ClickHouse-56948",
  "issue_numbers": [
    "56932"
  ],
  "base_commit": "a32c5e976a58470d84317f9e4ff0a7b311f57eca",
  "patch": "diff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 8227df3b0fc1..d19f92ae7677 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -15,6 +15,7 @@\n #include <Interpreters/TreeRewriter.h>\n #include <Interpreters/RenameColumnVisitor.h>\n #include <Interpreters/GinFilter.h>\n+#include <Interpreters/inplaceBlockConversions.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n #include <Interpreters/InterpreterSelectQueryAnalyzer.h>\n #include <Parsers/ASTAlterQuery.h>\n@@ -51,6 +52,7 @@ namespace ErrorCodes\n     extern const int DUPLICATE_COLUMN;\n     extern const int NOT_IMPLEMENTED;\n     extern const int SUPPORT_IS_DISABLED;\n+    extern const int ALTER_OF_COLUMN_IS_FORBIDDEN;\n }\n \n namespace\n@@ -1111,7 +1113,15 @@ void AlterCommands::apply(StorageInMemoryMetadata & metadata, ContextPtr context\n     {\n         try\n         {\n-            new_projections.add(ProjectionDescription::getProjectionFromAST(projection.definition_ast, metadata_copy.columns, context));\n+            /// Check if we can still build projection from new metadata.\n+            auto new_projection = ProjectionDescription::getProjectionFromAST(projection.definition_ast, metadata_copy.columns, context);\n+            /// Check if new metadata has the same keys as the old one.\n+            if (!blocksHaveEqualStructure(projection.sample_block_for_keys, new_projection.sample_block_for_keys))\n+                throw Exception(ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN, \"Cannot ALTER column\");\n+            /// Check if new metadata is convertible from old metadata for projection.\n+            Block old_projection_block = projection.sample_block;\n+            performRequiredConversions(old_projection_block, new_projection.sample_block.getNamesAndTypesList(), context);\n+            new_projections.add(std::move(new_projection));\n         }\n         catch (Exception & exception)\n         {\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 5be186d2092b..d9d4654cd99a 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -2975,12 +2975,6 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n             columns_alter_type_check_safe_for_partition.insert(col);\n     }\n \n-    for (const auto & index : old_metadata.getSecondaryIndices())\n-    {\n-        for (const String & col : index.expression->getRequiredColumns())\n-            columns_alter_type_forbidden.insert(col);\n-    }\n-\n     if (old_metadata.hasSortingKey())\n     {\n         auto sorting_key_expr = old_metadata.getSortingKey().expression;\n@@ -3004,6 +2998,20 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n     columns_in_keys.insert(columns_alter_type_metadata_only.begin(), columns_alter_type_metadata_only.end());\n     columns_in_keys.insert(columns_alter_type_check_safe_for_partition.begin(), columns_alter_type_check_safe_for_partition.end());\n \n+    std::unordered_map<String, String> columns_in_indices;\n+    for (const auto & index : old_metadata.getSecondaryIndices())\n+    {\n+        for (const String & col : index.expression->getRequiredColumns())\n+            columns_in_indices.emplace(col, index.name);\n+    }\n+\n+    std::unordered_map<String, String> columns_in_projections;\n+    for (const auto & projection : old_metadata.getProjections())\n+    {\n+        for (const String & col : projection.getRequiredColumns())\n+            columns_in_projections.emplace(col, projection.name);\n+    }\n+\n     NameSet dropped_columns;\n \n     std::map<String, const IDataType *> old_types;\n@@ -3089,6 +3097,17 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n                                 \"Trying to ALTER RENAME key {} column which is a part of key expression\",\n                                 backQuoteIfNeed(command.column_name));\n             }\n+\n+            /// Don't check columns in indices here. RENAME works fine with index columns.\n+\n+            if (auto it = columns_in_projections.find(command.column_name); it != columns_in_projections.end())\n+            {\n+                throw Exception(\n+                    ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN,\n+                    \"Trying to ALTER RENAME {} column which is a part of projection {}\",\n+                    backQuoteIfNeed(command.column_name),\n+                    it->second);\n+            }\n         }\n         else if (command.type == AlterCommand::DROP_COLUMN)\n         {\n@@ -3098,6 +3117,11 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n                     \"Trying to ALTER DROP key {} column which is a part of key expression\", backQuoteIfNeed(command.column_name));\n             }\n \n+            /// Don't check columns in indices or projections here. If required columns of indices\n+            /// or projections get dropped, it will be checked later in AlterCommands::apply. This\n+            /// allows projections with * to drop columns. One example can be found in\n+            /// 02691_drop_column_with_projections_replicated.sql.\n+\n             if (!command.clear)\n             {\n                 if (!name_deps)\n@@ -3141,6 +3165,18 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, Context\n                 throw Exception(ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN, \"ALTER of key column {} is forbidden\",\n                     backQuoteIfNeed(command.column_name));\n \n+            if (auto it = columns_in_indices.find(command.column_name); it != columns_in_indices.end())\n+            {\n+                throw Exception(\n+                    ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN,\n+                    \"Trying to ALTER {} column which is a part of index {}\",\n+                    backQuoteIfNeed(command.column_name),\n+                    it->second);\n+            }\n+\n+            /// Don't check columns in projections here. If required columns of projections get\n+            /// modified, it will be checked later in AlterCommands::apply.\n+\n             if (command.type == AlterCommand::MODIFY_COLUMN)\n             {\n                 if (columns_alter_type_check_safe_for_partition.contains(command.column_name))\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01213_alter_rename_primary_key_zookeeper_long.sql b/tests/queries/0_stateless/01213_alter_rename_primary_key_zookeeper_long.sql\nindex 406507089c39..ecb6018a3854 100644\n--- a/tests/queries/0_stateless/01213_alter_rename_primary_key_zookeeper_long.sql\n+++ b/tests/queries/0_stateless/01213_alter_rename_primary_key_zookeeper_long.sql\n@@ -52,6 +52,4 @@ ALTER TABLE table_for_rename_with_primary_key RENAME COLUMN key2 TO renamed_key2\n \n ALTER TABLE table_for_rename_with_primary_key RENAME COLUMN key3 TO renamed_key3; --{serverError 524}\n \n-ALTER TABLE table_for_rename_with_primary_key RENAME COLUMN value1 TO renamed_value1; --{serverError 524}\n-\n DROP TABLE IF EXISTS table_for_rename_with_primary_key;\ndiff --git a/tests/queries/0_stateless/02920_alter_column_of_projections.reference b/tests/queries/0_stateless/02920_alter_column_of_projections.reference\nnew file mode 100644\nindex 000000000000..c18b4e9b0829\n--- /dev/null\n+++ b/tests/queries/0_stateless/02920_alter_column_of_projections.reference\n@@ -0,0 +1,8 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02920_alter_column_of_projections.sql b/tests/queries/0_stateless/02920_alter_column_of_projections.sql\nnew file mode 100644\nindex 000000000000..ab7b79783d77\n--- /dev/null\n+++ b/tests/queries/0_stateless/02920_alter_column_of_projections.sql\n@@ -0,0 +1,33 @@\n+DROP TABLE IF EXISTS t;\n+\n+CREATE TABLE t (uid Int16, name String, age Nullable(Int8), i Int16, j Int16, projection p1 (select name, age, uniq(i), count(j) group by name, age)) ENGINE=MergeTree order by uid settings index_granularity = 1;\n+\n+INSERT INTO t VALUES (1231, 'John', 11, 1, 1), (6666, 'Ksenia', 1, 2, 2), (8888, 'Alice', 1, 3, 3), (6667, 'Ksenia', null, 4, 4);\n+\n+-- Cannot ALTER, which breaks key column of projection.\n+ALTER TABLE t MODIFY COLUMN age Nullable(Int32); -- { serverError ALTER_OF_COLUMN_IS_FORBIDDEN }\n+\n+-- Cannot ALTER, uniq(Int16) is not compatible with uniq(Int32).\n+ALTER TABLE t MODIFY COLUMN i Int32; -- { serverError CANNOT_CONVERT_TYPE }\n+\n+SYSTEM STOP MERGES t;\n+\n+SET alter_sync = 0;\n+\n+-- Can ALTER, count(Int16) is compatible with count(Int32).\n+ALTER TABLE t MODIFY COLUMN j Int32;\n+\n+-- Projection query works without mutation applied.\n+SELECT count(j) FROM t GROUP BY name, age;\n+\n+SYSTEM START MERGES t;\n+\n+SET alter_sync = 1;\n+\n+-- Another ALTER to wait for.\n+ALTER TABLE t MODIFY COLUMN j Int64 SETTINGS mutations_sync = 2;\n+\n+-- Projection query works with mutation applied.\n+SELECT count(j) FROM t GROUP BY name, age;\n+\n+DROP TABLE t;\ndiff --git a/tests/queries/0_stateless/02920_rename_column_of_skip_indices.reference b/tests/queries/0_stateless/02920_rename_column_of_skip_indices.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02920_rename_column_of_skip_indices.sql b/tests/queries/0_stateless/02920_rename_column_of_skip_indices.sql\nnew file mode 100644\nindex 000000000000..cb48d8b5043b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02920_rename_column_of_skip_indices.sql\n@@ -0,0 +1,31 @@\n+DROP TABLE IF EXISTS t;\n+\n+CREATE TABLE t\n+(\n+  key1 UInt64,\n+  value1 String,\n+  value2 String,\n+  INDEX idx (value1) TYPE set(10) GRANULARITY 1\n+)\n+ENGINE MergeTree ORDER BY key1 SETTINGS index_granularity = 1;\n+\n+INSERT INTO t SELECT toDate('2019-10-01') + number % 3, toString(number), toString(number) from numbers(9);\n+\n+SYSTEM STOP MERGES t;\n+\n+SET alter_sync = 0;\n+\n+ALTER TABLE t RENAME COLUMN value1 TO value11;\n+\n+-- Index works without mutation applied.\n+SELECT * FROM t WHERE value11 = '000' SETTINGS max_rows_to_read = 0;\n+\n+SYSTEM START MERGES t;\n+\n+-- Another ALTER to wait for.\n+ALTER TABLE t RENAME COLUMN value11 TO value12 SETTINGS mutations_sync = 2;\n+\n+-- Index works with mutation applied.\n+SELECT * FROM t WHERE value12 = '000' SETTINGS max_rows_to_read = 0;\n+\n+DROP TABLE t;\n",
  "problem_statement": "Altering column that is part of a projection may lead to loosing data\n```sql\r\nCREATE TABLE users (uid Int16, name String, age Nullable(Int8),\r\n  projection p1 (select age, count() group by age)\r\n  ) ENGINE=MergeTree order by uid;\r\n\r\nINSERT INTO users VALUES (1231, 'John', 11);\r\nINSERT INTO users VALUES (6666, 'Ksenia', 1);\r\nINSERT INTO users VALUES (8888, 'Alice', 1);\r\nINSERT INTO users VALUES (6667, 'Ksenia', null);\r\n\r\nalter table users modify column age Nullable(Int32) ;\r\nDB::Exception: Exception happened during execution of mutation 'mutation_5.txt' with part 'all_2_2_0' reas\r\n\r\nselect count() from users;\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\ndetach table users;\r\n\r\nattach table users;\r\n\r\nselect count() from users;\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "```\r\nalter table users modify column age Nullable(Int8);\r\n\r\nmv broken-on-start_all_1_1_0 all_1_1_0\r\nmv broken-on-start_all_2_2_0 all_2_2_0\r\nmv broken-on-start_all_3_3_0 all_3_3_0\r\n\r\nalter table users attach partition tuple();\r\n\r\nselect count() from users;\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nI see two options:\r\n\r\n* prohibit to modify columns if they are part of the projection (similar to LWD)\r\n* rebuild projection during a part mutation due to modify column.\r\n\r\nAny of options is OK.",
  "created_at": "2023-11-18T07:51:15Z",
  "modified_files": [
    "src/Storages/AlterCommands.cpp",
    "src/Storages/MergeTree/MergeTreeData.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01213_alter_rename_primary_key_zookeeper_long.sql",
    "b/tests/queries/0_stateless/02920_alter_column_of_projections.reference",
    "b/tests/queries/0_stateless/02920_alter_column_of_projections.sql",
    "b/tests/queries/0_stateless/02920_rename_column_of_skip_indices.sql"
  ]
}