diff --git a/src/Dictionaries/CacheDictionary.cpp b/src/Dictionaries/CacheDictionary.cpp
index 4b242ee7fd9d..cad3e3b8799c 100644
--- a/src/Dictionaries/CacheDictionary.cpp
+++ b/src/Dictionaries/CacheDictionary.cpp
@@ -271,7 +271,6 @@ ColumnUInt8::Ptr CacheDictionary<dictionary_key_type>::hasKeys(const Columns & k
     if (dictionary_key_type == DictionaryKeyType::Complex)
         dict_struct.validateKeyTypes(key_types);
 
-
     DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;
     DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());
     const auto keys = extractor.extractAllKeys();
diff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp
index e99503b881ba..40cc735557c4 100644
--- a/src/Dictionaries/FlatDictionary.cpp
+++ b/src/Dictionaries/FlatDictionary.cpp
@@ -294,7 +294,36 @@ void FlatDictionary::blockToAttributes(const Block & block)
     size_t keys_size = keys_extractor.getKeysSize();
 
     static constexpr size_t key_offset = 1;
-    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)
+
+    size_t attributes_size = attributes.size();
+
+    if (unlikely(attributes_size == 0))
+    {
+        for (size_t i = 0; i < keys_size; ++i)
+        {
+            auto key = keys_extractor.extractCurrentKey();
+
+            if (unlikely(key >= configuration.max_array_size))
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,
+                    "{}: identifier should be less than {}",
+                    getFullName(),
+                    toString(configuration.max_array_size));
+
+            if (key >= loaded_keys.size())
+            {
+                const size_t elements_count = key + 1;
+                loaded_keys.resize(elements_count, false);
+            }
+
+            loaded_keys[key] = true;
+
+            keys_extractor.rollbackCurrentKey();
+        }
+
+        return;
+    }
+
+    for (size_t attribute_index = 0; attribute_index < attributes_size; ++attribute_index)
     {
         const IColumn & attribute_column = *block.safeGetByPosition(attribute_index + key_offset).column;
         Attribute & attribute = attributes[attribute_index];
@@ -494,21 +523,6 @@ void FlatDictionary::resize(Attribute & attribute, UInt64 key)
     }
 }
 
-template <typename T>
-void FlatDictionary::setAttributeValueImpl(Attribute & attribute, UInt64 key, const T & value)
-{
-    auto & array = std::get<ContainerType<T>>(attribute.container);
-    array[key] = value;
-    loaded_keys[key] = true;
-}
-
-template <>
-void FlatDictionary::setAttributeValueImpl<String>(Attribute & attribute, UInt64 key, const String & value)
-{
-    auto arena_value = copyStringInArena(string_arena, value);
-    setAttributeValueImpl(attribute, key, arena_value);
-}
-
 void FlatDictionary::setAttributeValue(Attribute & attribute, const UInt64 key, const Field & value)
 {
     auto type_call = [&](const auto & dictionary_attribute_type)
@@ -526,7 +540,20 @@ void FlatDictionary::setAttributeValue(Attribute & attribute, const UInt64 key,
             return;
         }
 
-        setAttributeValueImpl<AttributeType>(attribute, key, value.get<AttributeType>());
+        auto & attribute_value = value.get<AttributeType>();
+
+        auto & container = std::get<ContainerType<ValueType>>(attribute.container);
+        loaded_keys[key] = true;
+
+        if constexpr (std::is_same_v<ValueType, StringRef>)
+        {
+            auto arena_value = copyStringInArena(string_arena, attribute_value);
+            container[key] = arena_value;
+        }
+        else
+        {
+            container[key] = attribute_value;
+        }
     };
 
     callOnDictionaryAttributeType(attribute.type, type_call);
diff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h
index e8f40ea1d662..55898a0d1792 100644
--- a/src/Dictionaries/FlatDictionary.h
+++ b/src/Dictionaries/FlatDictionary.h
@@ -154,9 +154,6 @@ class FlatDictionary final : public IDictionary
     template <typename T>
     void resize(Attribute & attribute, UInt64 key);
 
-    template <typename T>
-    void setAttributeValueImpl(Attribute & attribute, UInt64 key, const T & value);
-
     void setAttributeValue(Attribute & attribute, UInt64 key, const Field & value);
 
     const DictionaryStructure dict_struct;
diff --git a/src/Dictionaries/HashedArrayDictionary.cpp b/src/Dictionaries/HashedArrayDictionary.cpp
index 55a3adc32ae4..e35340c76189 100644
--- a/src/Dictionaries/HashedArrayDictionary.cpp
+++ b/src/Dictionaries/HashedArrayDictionary.cpp
@@ -158,12 +158,6 @@ ColumnUInt8::Ptr HashedArrayDictionary<dictionary_key_type>::hasKeys(const Colum
     auto result = ColumnUInt8::create(keys_size, false);
     auto & out = result->getData();
 
-    if (attributes.empty())
-    {
-        query_count.fetch_add(keys_size, std::memory_order_relaxed);
-        return result;
-    }
-
     size_t keys_found = 0;
 
     for (size_t requested_key_index = 0; requested_key_index < keys_size; ++requested_key_index)
diff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp
index 8417455087e0..c83735a63303 100644
--- a/src/Dictionaries/HashedDictionary.cpp
+++ b/src/Dictionaries/HashedDictionary.cpp
@@ -177,15 +177,25 @@ ColumnUInt8::Ptr HashedDictionary<dictionary_key_type, sparse>::hasKeys(const Co
     auto result = ColumnUInt8::create(keys_size, false);
     auto & out = result->getData();
 
-    if (attributes.empty())
+    size_t keys_found = 0;
+
+    if (unlikely(attributes.empty()))
     {
+        for (size_t requested_key_index = 0; requested_key_index < keys_size; ++requested_key_index)
+        {
+            auto requested_key = extractor.extractCurrentKey();
+            out[requested_key_index] = no_attributes_container.find(requested_key) != no_attributes_container.end();
+            keys_found += out[requested_key_index];
+            extractor.rollbackCurrentKey();
+        }
+
         query_count.fetch_add(keys_size, std::memory_order_relaxed);
+        found_count.fetch_add(keys_found, std::memory_order_relaxed);
         return result;
     }
 
     const auto & attribute = attributes.front();
     bool is_attribute_nullable = attribute.is_nullable_set.has_value();
-    size_t keys_found = 0;
 
     getAttributeContainer(0, [&](const auto & container)
     {
@@ -423,7 +433,25 @@ void HashedDictionary<dictionary_key_type, sparse>::blockToAttributes(const Bloc
 
     Field column_value_to_insert;
 
-    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)
+    size_t attributes_size = attributes.size();
+
+    if (unlikely(attributes_size == 0))
+    {
+        for (size_t key_index = 0; key_index < keys_size; ++key_index)
+        {
+            auto key = keys_extractor.extractCurrentKey();
+
+            if constexpr (std::is_same_v<KeyType, StringRef>)
+                key = copyStringInArena(string_arena, key);
+
+            no_attributes_container.insert(key);
+            keys_extractor.rollbackCurrentKey();
+        }
+
+        return;
+    }
+
+    for (size_t attribute_index = 0; attribute_index < attributes_size; ++attribute_index)
     {
         const IColumn & attribute_column = *block.safeGetByPosition(skip_keys_size_offset + attribute_index).column;
         auto & attribute = attributes[attribute_index];
@@ -487,7 +515,21 @@ void HashedDictionary<dictionary_key_type, sparse>::resize(size_t added_rows)
     if (unlikely(!added_rows))
         return;
 
-    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)
+    size_t attributes_size = attributes.size();
+
+    if (unlikely(attributes_size == 0))
+    {
+        size_t reserve_size = added_rows + no_attributes_container.size();
+
+        if constexpr (sparse)
+            no_attributes_container.resize(reserve_size);
+        else
+            no_attributes_container.reserve(reserve_size);
+
+        return;
+    }
+
+    for (size_t attribute_index = 0; attribute_index < attributes_size; ++attribute_index)
     {
         getAttributeContainer(attribute_index, [added_rows](auto & attribute_map)
         {
@@ -570,7 +612,9 @@ void HashedDictionary<dictionary_key_type, sparse>::loadData()
                 }
             }
             else
+            {
                 resize(block.rows());
+            }
 
             blockToAttributes(block);
         }
@@ -589,9 +633,10 @@ void HashedDictionary<dictionary_key_type, sparse>::loadData()
 template <DictionaryKeyType dictionary_key_type, bool sparse>
 void HashedDictionary<dictionary_key_type, sparse>::calculateBytesAllocated()
 {
-    bytes_allocated += attributes.size() * sizeof(attributes.front());
+    size_t attributes_size = attributes.size();
+    bytes_allocated += attributes_size * sizeof(attributes.front());
 
-    for (size_t i = 0; i < attributes.size(); ++i)
+    for (size_t i = 0; i < attributes_size; ++i)
     {
         getAttributeContainer(i, [&](const auto & container)
         {
@@ -622,6 +667,22 @@ void HashedDictionary<dictionary_key_type, sparse>::calculateBytesAllocated()
             bytes_allocated = attributes[i].is_nullable_set->getBufferSizeInBytes();
     }
 
+    if (unlikely(attributes_size == 0))
+    {
+        bytes_allocated += sizeof(no_attributes_container);
+
+        if constexpr (sparse)
+        {
+            bytes_allocated += no_attributes_container.size() * (sizeof(KeyType));
+            bucket_count = no_attributes_container.bucket_count();
+        }
+        else
+        {
+            bytes_allocated += no_attributes_container.getBufferSizeInBytes();
+            bucket_count = no_attributes_container.getBufferSizeInCells();
+        }
+    }
+
     bytes_allocated += string_arena.size();
 
     if (update_field_loaded_block)
@@ -657,6 +718,18 @@ Pipe HashedDictionary<dictionary_key_type, sparse>::read(const Names & column_na
             }
         });
     }
+    else
+    {
+        keys.reserve(no_attributes_container.size());
+
+        for (const auto & key : no_attributes_container)
+        {
+            if constexpr (sparse)
+                keys.emplace_back(key);
+            else
+                keys.emplace_back(key.getKey());
+        }
+    }
 
     ColumnsWithTypeAndName key_columns;
 
diff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h
index c1761944b14b..605477efc78f 100644
--- a/src/Dictionaries/HashedDictionary.h
+++ b/src/Dictionaries/HashedDictionary.h
@@ -5,6 +5,7 @@
 #include <variant>
 #include <optional>
 #include <sparsehash/sparse_hash_map>
+#include <sparsehash/sparse_hash_set>
 
 #include <Common/HashTable/HashMap.h>
 #include <Common/HashTable/HashSet.h>
@@ -120,9 +121,14 @@ class HashedDictionary final : public IDictionary
     template <typename Value>
     using CollectionTypeNonSparse = std::conditional_t<
         dictionary_key_type == DictionaryKeyType::Simple,
-        HashMap<UInt64, Value>,
+        HashMap<UInt64, Value, DefaultHash<UInt64>>,
         HashMapWithSavedHash<StringRef, Value, DefaultHash<StringRef>>>;
 
+    using NoAttributesCollectionTypeNonSparse = std::conditional_t<
+        dictionary_key_type == DictionaryKeyType::Simple,
+        HashSet<UInt64, DefaultHash<UInt64>>,
+        HashSetWithSavedHash<StringRef, DefaultHash<StringRef>>>;
+
     /// Here we use sparse_hash_map with DefaultHash<> for the following reasons:
     ///
     /// - DefaultHash<> is used for HashMap
@@ -140,9 +146,13 @@ class HashedDictionary final : public IDictionary
         google::sparse_hash_map<UInt64, Value, DefaultHash<KeyType>>,
         google::sparse_hash_map<StringRef, Value, DefaultHash<KeyType>>>;
 
+    using NoAttributesCollectionTypeSparse = google::sparse_hash_set<KeyType, DefaultHash<KeyType>>;
+
     template <typename Value>
     using CollectionType = std::conditional_t<sparse, CollectionTypeSparse<Value>, CollectionTypeNonSparse<Value>>;
 
+    using NoAttributesCollectionType = std::conditional_t<sparse, NoAttributesCollectionTypeSparse, NoAttributesCollectionTypeNonSparse>;
+
     using NullableSet = HashSet<KeyType, DefaultHash<KeyType>>;
 
     struct Attribute final
@@ -214,6 +224,7 @@ class HashedDictionary final : public IDictionary
 
     BlockPtr update_field_loaded_block;
     Arena string_arena;
+    NoAttributesCollectionType no_attributes_container;
 };
 
 extern template class HashedDictionary<DictionaryKeyType::Simple, false>;
diff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp
index e5c08b52881f..979cfce6ce22 100644
--- a/src/Dictionaries/RangeHashedDictionary.cpp
+++ b/src/Dictionaries/RangeHashedDictionary.cpp
@@ -780,6 +780,9 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)
                 "{}: dictionary of layout 'range_hashed' requires .structure.range_min and .structure.range_max",
                 full_name);
 
+        if (dict_struct.attributes.empty())
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Empty attributes are not supported for dictionary of layout 'range_hashed'");
+
         const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);
         const DictionaryLifetime dict_lifetime{config, config_prefix + ".lifetime"};
         const bool require_nonempty = config.getBool(config_prefix + ".require_nonempty", false);
@@ -803,6 +806,9 @@ void registerDictionaryRangeHashed(DictionaryFactory & factory)
                 "{}: dictionary of layout 'complex_key_range_hashed' requires .structure.range_min and .structure.range_max",
                 full_name);
 
+        if (dict_struct.attributes.empty())
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Empty attributes are not supported for dictionary of layout 'complex_key_range_hashed'");
+
         const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);
         const DictionaryLifetime dict_lifetime{config, config_prefix + ".lifetime"};
         const bool require_nonempty = config.getBool(config_prefix + ".require_nonempty", false);
diff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h
index f31d6415dc80..f7859d304269 100644
--- a/src/Dictionaries/RangeHashedDictionary.h
+++ b/src/Dictionaries/RangeHashedDictionary.h
@@ -96,9 +96,14 @@ class RangeHashedDictionary final : public IDictionary
     template <typename Value>
     using CollectionType = std::conditional_t<
         dictionary_key_type == DictionaryKeyType::Simple,
-        HashMap<UInt64, Values<Value>>,
+        HashMap<UInt64, Values<Value>, DefaultHash<UInt64>>,
         HashMapWithSavedHash<StringRef, Values<Value>, DefaultHash<StringRef>>>;
 
+    using NoAttributesCollectionType = std::conditional_t<
+        dictionary_key_type == DictionaryKeyType::Simple,
+        HashMap<UInt64, IntervalSet<RangeInterval>>,
+        HashMapWithSavedHash<StringRef, IntervalSet<RangeInterval>>>;
+
     struct Attribute final
     {
     public:
@@ -189,6 +194,7 @@ class RangeHashedDictionary final : public IDictionary
     mutable std::atomic<size_t> query_count{0};
     mutable std::atomic<size_t> found_count{0};
     Arena string_arena;
+    NoAttributesCollectionType no_attributes_container;
 };
 
 }
