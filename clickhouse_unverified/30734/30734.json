{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 30734,
  "instance_id": "ClickHouse__ClickHouse-30734",
  "issue_numbers": [
    "30666"
  ],
  "base_commit": "fc19a06a990d0c9184513a6d48df7a94d165bf17",
  "patch": "diff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex 2aadda426e75..3cd914a89bb6 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -577,7 +577,7 @@\n     M(607, BACKUP_ELEMENT_DUPLICATE) \\\n     M(608, CANNOT_RESTORE_TABLE) \\\n     M(609, FUNCTION_ALREADY_EXISTS) \\\n-    M(610, CANNOT_DROP_SYSTEM_FUNCTION) \\\n+    M(610, CANNOT_DROP_FUNCTION) \\\n     M(611, CANNOT_CREATE_RECURSIVE_FUNCTION) \\\n     M(612, OBJECT_ALREADY_STORED_ON_DISK) \\\n     M(613, OBJECT_WAS_NOT_STORED_ON_DISK) \\\ndiff --git a/src/Interpreters/InterpreterCreateFunctionQuery.cpp b/src/Interpreters/InterpreterCreateFunctionQuery.cpp\nindex fe331985aa4e..d39e22f55f05 100644\n--- a/src/Interpreters/InterpreterCreateFunctionQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateFunctionQuery.cpp\n@@ -1,7 +1,5 @@\n #include <Interpreters/InterpreterCreateFunctionQuery.h>\n \n-#include <stack>\n-\n #include <Access/ContextAccess.h>\n #include <Parsers/ASTCreateFunctionQuery.h>\n #include <Parsers/ASTIdentifier.h>\n@@ -11,6 +9,7 @@\n #include <Interpreters/FunctionNameNormalizer.h>\n #include <Interpreters/UserDefinedSQLObjectsLoader.h>\n #include <Interpreters/UserDefinedSQLFunctionFactory.h>\n+#include <Interpreters/executeDDLQueryOnCluster.h>\n \n \n namespace DB\n@@ -24,45 +23,33 @@ namespace ErrorCodes\n \n BlockIO InterpreterCreateFunctionQuery::execute()\n {\n-    auto current_context = getContext();\n-    current_context->checkAccess(AccessType::CREATE_FUNCTION);\n-\n     FunctionNameNormalizer().visit(query_ptr.get());\n-    auto * create_function_query = query_ptr->as<ASTCreateFunctionQuery>();\n+    ASTCreateFunctionQuery & create_function_query = query_ptr->as<ASTCreateFunctionQuery &>();\n \n-    if (!create_function_query)\n-        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Expected CREATE FUNCTION query\");\n+    AccessRightsElements access_rights_elements;\n+    access_rights_elements.emplace_back(AccessType::CREATE_FUNCTION);\n \n-    auto & user_defined_function_factory = UserDefinedSQLFunctionFactory::instance();\n+    if (create_function_query.or_replace)\n+        access_rights_elements.emplace_back(AccessType::DROP_FUNCTION);\n \n-    auto & function_name = create_function_query->function_name;\n+    if (!create_function_query.cluster.empty())\n+        return executeDDLQueryOnCluster(query_ptr, getContext(), access_rights_elements);\n \n-    bool if_not_exists = create_function_query->if_not_exists;\n-    bool replace = create_function_query->or_replace;\n+    auto current_context = getContext();\n+    current_context->checkAccess(access_rights_elements);\n \n-    create_function_query->if_not_exists = false;\n-    create_function_query->or_replace = false;\n+    auto & user_defined_function_factory = UserDefinedSQLFunctionFactory::instance();\n \n-    if (if_not_exists && user_defined_function_factory.tryGet(function_name) != nullptr)\n-        return {};\n+    auto & function_name = create_function_query.function_name;\n \n-    validateFunction(create_function_query->function_core, function_name);\n+    bool if_not_exists = create_function_query.if_not_exists;\n+    bool replace = create_function_query.or_replace;\n \n-    user_defined_function_factory.registerFunction(function_name, query_ptr, replace);\n+    create_function_query.if_not_exists = false;\n+    create_function_query.or_replace = false;\n \n-    if (persist_function)\n-    {\n-        try\n-        {\n-            UserDefinedSQLObjectsLoader::instance().storeObject(current_context, UserDefinedSQLObjectType::Function, function_name, *query_ptr, replace);\n-        }\n-        catch (Exception & exception)\n-        {\n-            user_defined_function_factory.unregisterFunction(function_name);\n-            exception.addMessage(fmt::format(\"while storing user defined function {} on disk\", backQuote(function_name)));\n-            throw;\n-        }\n-    }\n+    validateFunction(create_function_query.function_core, function_name);\n+    user_defined_function_factory.registerFunction(current_context, function_name, query_ptr, replace, if_not_exists, persist_function);\n \n     return {};\n }\ndiff --git a/src/Interpreters/InterpreterDropFunctionQuery.cpp b/src/Interpreters/InterpreterDropFunctionQuery.cpp\nindex b788c8f960fd..be67ea68cdd8 100644\n--- a/src/Interpreters/InterpreterDropFunctionQuery.cpp\n+++ b/src/Interpreters/InterpreterDropFunctionQuery.cpp\n@@ -1,10 +1,12 @@\n+#include <Parsers/ASTDropFunctionQuery.h>\n+\n #include <Access/ContextAccess.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n #include <Interpreters/InterpreterDropFunctionQuery.h>\n #include <Interpreters/UserDefinedSQLObjectsLoader.h>\n #include <Interpreters/UserDefinedSQLFunctionFactory.h>\n-#include <Parsers/ASTDropFunctionQuery.h>\n+#include <Interpreters/executeDDLQueryOnCluster.h>\n \n \n namespace DB\n@@ -12,19 +14,19 @@ namespace DB\n \n BlockIO InterpreterDropFunctionQuery::execute()\n {\n-    auto current_context = getContext();\n-    current_context->checkAccess(AccessType::DROP_FUNCTION);\n-\n     FunctionNameNormalizer().visit(query_ptr.get());\n-    auto & drop_function_query = query_ptr->as<ASTDropFunctionQuery &>();\n+    ASTDropFunctionQuery & drop_function_query = query_ptr->as<ASTDropFunctionQuery &>();\n+\n+    AccessRightsElements access_rights_elements;\n+    access_rights_elements.emplace_back(AccessType::DROP_FUNCTION);\n \n-    auto & user_defined_functions_factory = UserDefinedSQLFunctionFactory::instance();\n+    if (!drop_function_query.cluster.empty())\n+        return executeDDLQueryOnCluster(query_ptr, getContext(), access_rights_elements);\n \n-    if (drop_function_query.if_exists && !user_defined_functions_factory.has(drop_function_query.function_name))\n-        return {};\n+    auto current_context = getContext();\n+    current_context->checkAccess(access_rights_elements);\n \n-    UserDefinedSQLFunctionFactory::instance().unregisterFunction(drop_function_query.function_name);\n-    UserDefinedSQLObjectsLoader::instance().removeObject(current_context, UserDefinedSQLObjectType::Function, drop_function_query.function_name);\n+    UserDefinedSQLFunctionFactory::instance().unregisterFunction(current_context, drop_function_query.function_name, drop_function_query.if_exists);\n \n     return {};\n }\ndiff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\nindex cfa1171a84b2..4cb3e034b013 100644\n--- a/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\n+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\n@@ -206,6 +206,15 @@ FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::tryGet(const S\n     return nullptr;\n }\n \n+bool UserDefinedExecutableFunctionFactory::has(const String & function_name, ContextPtr context)\n+{\n+    const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\n+    auto load_result = loader.getLoadResult(function_name);\n+\n+    bool result = load_result.object != nullptr;\n+    return result;\n+}\n+\n std::vector<String> UserDefinedExecutableFunctionFactory::getRegisteredNames(ContextPtr context)\n {\n     const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\ndiff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.h b/src/Interpreters/UserDefinedExecutableFunctionFactory.h\nindex 0afeeecbca7f..989db4c481b0 100644\n--- a/src/Interpreters/UserDefinedExecutableFunctionFactory.h\n+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.h\n@@ -24,6 +24,8 @@ class UserDefinedExecutableFunctionFactory\n \n     static FunctionOverloadResolverPtr tryGet(const String & function_name, ContextPtr context);\n \n+    static bool has(const String & function_name, ContextPtr context);\n+\n     static std::vector<String> getRegisteredNames(ContextPtr context);\n \n };\ndiff --git a/src/Interpreters/UserDefinedSQLFunctionFactory.cpp b/src/Interpreters/UserDefinedSQLFunctionFactory.cpp\nindex f036741ca21f..afe51de99a44 100644\n--- a/src/Interpreters/UserDefinedSQLFunctionFactory.cpp\n+++ b/src/Interpreters/UserDefinedSQLFunctionFactory.cpp\n@@ -1,7 +1,13 @@\n #include \"UserDefinedSQLFunctionFactory.h\"\n \n+#include <Common/quoteString.h>\n+\n #include <Functions/FunctionFactory.h>\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <Interpreters/UserDefinedSQLObjectsLoader.h>\n+#include <Interpreters/UserDefinedExecutableFunctionFactory.h>\n+#include <Interpreters/Context.h>\n+\n \n namespace DB\n {\n@@ -10,7 +16,7 @@ namespace ErrorCodes\n {\n     extern const int FUNCTION_ALREADY_EXISTS;\n     extern const int UNKNOWN_FUNCTION;\n-    extern const int CANNOT_DROP_SYSTEM_FUNCTION;\n+    extern const int CANNOT_DROP_FUNCTION;\n }\n \n UserDefinedSQLFunctionFactory & UserDefinedSQLFunctionFactory::instance()\n@@ -19,13 +25,31 @@ UserDefinedSQLFunctionFactory & UserDefinedSQLFunctionFactory::instance()\n     return result;\n }\n \n-void UserDefinedSQLFunctionFactory::registerFunction(const String & function_name, ASTPtr create_function_query, bool replace)\n+void UserDefinedSQLFunctionFactory::registerFunction(ContextPtr context, const String & function_name, ASTPtr create_function_query, bool replace, bool if_not_exists, bool persist)\n {\n     if (FunctionFactory::instance().hasNameOrAlias(function_name))\n+    {\n+        if (if_not_exists)\n+            return;\n+\n         throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, \"The function '{}' already exists\", function_name);\n+    }\n \n     if (AggregateFunctionFactory::instance().hasNameOrAlias(function_name))\n+    {\n+        if (if_not_exists)\n+            return;\n+\n         throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS, \"The aggregate function '{}' already exists\", function_name);\n+    }\n+\n+    if (UserDefinedExecutableFunctionFactory::instance().has(function_name, context))\n+    {\n+        if (if_not_exists)\n+            return;\n+\n+        throw Exception(ErrorCodes::CANNOT_DROP_FUNCTION, \"User defined executable function '{}'\", function_name);\n+    }\n \n     std::lock_guard lock(mutex);\n \n@@ -33,28 +57,63 @@ void UserDefinedSQLFunctionFactory::registerFunction(const String & function_nam\n \n     if (!inserted)\n     {\n+        if (if_not_exists)\n+            return;\n+\n         if (replace)\n-            it->second = std::move(create_function_query);\n+            it->second = create_function_query;\n         else\n             throw Exception(ErrorCodes::FUNCTION_ALREADY_EXISTS,\n                 \"The function name '{}' is not unique\",\n                 function_name);\n     }\n+\n+    if (persist)\n+    {\n+        try\n+        {\n+            UserDefinedSQLObjectsLoader::instance().storeObject(context, UserDefinedSQLObjectType::Function, function_name, *create_function_query, replace);\n+        }\n+        catch (Exception & exception)\n+        {\n+            function_name_to_create_query.erase(it);\n+            exception.addMessage(fmt::format(\"while storing user defined function {} on disk\", backQuote(function_name)));\n+            throw;\n+        }\n+    }\n }\n \n-void UserDefinedSQLFunctionFactory::unregisterFunction(const String & function_name)\n+void UserDefinedSQLFunctionFactory::unregisterFunction(ContextPtr context, const String & function_name, bool if_exists)\n {\n     if (FunctionFactory::instance().hasNameOrAlias(function_name) ||\n         AggregateFunctionFactory::instance().hasNameOrAlias(function_name))\n-        throw Exception(ErrorCodes::CANNOT_DROP_SYSTEM_FUNCTION, \"Cannot drop system function '{}'\", function_name);\n+        throw Exception(ErrorCodes::CANNOT_DROP_FUNCTION, \"Cannot drop system function '{}'\", function_name);\n+\n+    if (UserDefinedExecutableFunctionFactory::instance().has(function_name, context))\n+        throw Exception(ErrorCodes::CANNOT_DROP_FUNCTION, \"Cannot drop user defined executable function '{}'\", function_name);\n \n     std::lock_guard lock(mutex);\n \n     auto it = function_name_to_create_query.find(function_name);\n     if (it == function_name_to_create_query.end())\n+    {\n+        if (if_exists)\n+            return;\n+\n         throw Exception(ErrorCodes::UNKNOWN_FUNCTION,\n             \"The function name '{}' is not registered\",\n             function_name);\n+    }\n+\n+    try\n+    {\n+        UserDefinedSQLObjectsLoader::instance().removeObject(context, UserDefinedSQLObjectType::Function, function_name);\n+    }\n+    catch (Exception & exception)\n+    {\n+        exception.addMessage(fmt::format(\"while removing user defined function {} from disk\", backQuote(function_name)));\n+        throw;\n+    }\n \n     function_name_to_create_query.erase(it);\n }\ndiff --git a/src/Interpreters/UserDefinedSQLFunctionFactory.h b/src/Interpreters/UserDefinedSQLFunctionFactory.h\nindex 6487b951705a..63bf5d73c15d 100644\n--- a/src/Interpreters/UserDefinedSQLFunctionFactory.h\n+++ b/src/Interpreters/UserDefinedSQLFunctionFactory.h\n@@ -6,6 +6,8 @@\n #include <Common/NamePrompter.h>\n \n #include <Parsers/ASTCreateFunctionQuery.h>\n+#include <Interpreters/Context_fwd.h>\n+\n \n namespace DB\n {\n@@ -17,13 +19,17 @@ class UserDefinedSQLFunctionFactory : public IHints<1, UserDefinedSQLFunctionFac\n     static UserDefinedSQLFunctionFactory & instance();\n \n     /** Register function for function_name in factory for specified create_function_query.\n-      * If replace = true and function with function_name already exists replace it with create_function_query.\n-      * Otherwise throws exception.\n+      * If function exists and if_not_exists = false and replace = false throws exception.\n+      * If replace = true and sql user defined function with function_name already exists replace it with create_function_query.\n+      * If persist = true persist function on disk.\n       */\n-    void registerFunction(const String & function_name, ASTPtr create_function_query, bool replace);\n+    void registerFunction(ContextPtr context, const String & function_name, ASTPtr create_function_query, bool replace, bool if_not_exists, bool persist);\n \n-    /// Unregister function for function_name\n-    void unregisterFunction(const String & function_name);\n+    /** Unregister function for function_name.\n+      * If if_exists = true then do not throw exception if function is not registered.\n+      * If if_exists = false then throw exception if function is not registered.\n+      */\n+    void unregisterFunction(ContextPtr context, const String & function_name, bool if_exists);\n \n     /// Get function create query for function_name. If no function registered with function_name throws exception.\n     ASTPtr get(const String & function_name) const;\ndiff --git a/src/Parsers/ASTCreateFunctionQuery.cpp b/src/Parsers/ASTCreateFunctionQuery.cpp\nindex 4e1e7de660dc..9209b1f18694 100644\n--- a/src/Parsers/ASTCreateFunctionQuery.cpp\n+++ b/src/Parsers/ASTCreateFunctionQuery.cpp\n@@ -1,6 +1,9 @@\n #include <Common/quoteString.h>\n #include <IO/Operators.h>\n #include <Parsers/ASTCreateFunctionQuery.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTFunction.h>\n+\n \n namespace DB\n {\n@@ -25,6 +28,9 @@ void ASTCreateFunctionQuery::formatImpl(const IAST::FormatSettings & settings, I\n     settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n     settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(function_name) << (settings.hilite ? hilite_none : \"\");\n+\n+    formatOnCluster(settings);\n+\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\");\n     function_core->formatImpl(settings, state, frame);\n }\ndiff --git a/src/Parsers/ASTCreateFunctionQuery.h b/src/Parsers/ASTCreateFunctionQuery.h\nindex a58fe64c435e..fccc18371356 100644\n--- a/src/Parsers/ASTCreateFunctionQuery.h\n+++ b/src/Parsers/ASTCreateFunctionQuery.h\n@@ -1,12 +1,13 @@\n #pragma once\n \n-#include <Parsers/ASTExpressionList.h>\n-#include <Parsers/ASTFunction.h>\n+#include <Parsers/IAST.h>\n+#include <Parsers/ASTQueryWithOnCluster.h>\n+\n \n namespace DB\n {\n \n-class ASTCreateFunctionQuery : public IAST\n+class ASTCreateFunctionQuery : public IAST, public ASTQueryWithOnCluster\n {\n public:\n     String function_name;\n@@ -20,6 +21,8 @@ class ASTCreateFunctionQuery : public IAST\n     ASTPtr clone() const override;\n \n     void formatImpl(const FormatSettings & s, FormatState & state, FormatStateStacked frame) const override;\n+\n+    ASTPtr getRewrittenASTWithoutOnCluster(const std::string &) const override { return removeOnCluster<ASTCreateFunctionQuery>(clone()); }\n };\n \n }\ndiff --git a/src/Parsers/ASTDropFunctionQuery.cpp b/src/Parsers/ASTDropFunctionQuery.cpp\nindex 47665aa52f90..3409d6990421 100644\n--- a/src/Parsers/ASTDropFunctionQuery.cpp\n+++ b/src/Parsers/ASTDropFunctionQuery.cpp\n@@ -19,6 +19,7 @@ void ASTDropFunctionQuery::formatImpl(const IAST::FormatSettings & settings, IAS\n \n     settings.ostr << (settings.hilite ? hilite_none : \"\");\n     settings.ostr << (settings.hilite ? hilite_identifier : \"\") << backQuoteIfNeed(function_name) << (settings.hilite ? hilite_none : \"\");\n+    formatOnCluster(settings);\n }\n \n }\ndiff --git a/src/Parsers/ASTDropFunctionQuery.h b/src/Parsers/ASTDropFunctionQuery.h\nindex a9d70a3016f5..c9f673578a90 100644\n--- a/src/Parsers/ASTDropFunctionQuery.h\n+++ b/src/Parsers/ASTDropFunctionQuery.h\n@@ -1,11 +1,13 @@\n #pragma once\n \n-#include \"IAST.h\"\n+#include <Parsers/IAST.h>\n+#include <Parsers/ASTQueryWithOnCluster.h>\n+\n \n namespace DB\n {\n \n-class ASTDropFunctionQuery : public IAST\n+class ASTDropFunctionQuery : public IAST, public ASTQueryWithOnCluster\n {\n public:\n     String function_name;\n@@ -17,6 +19,8 @@ class ASTDropFunctionQuery : public IAST\n     ASTPtr clone() const override;\n \n     void formatImpl(const FormatSettings & s, FormatState & state, FormatStateStacked frame) const override;\n+\n+    ASTPtr getRewrittenASTWithoutOnCluster(const std::string &) const override { return removeOnCluster<ASTDropFunctionQuery>(clone()); }\n };\n \n }\ndiff --git a/src/Parsers/ParserCreateFunctionQuery.cpp b/src/Parsers/ParserCreateFunctionQuery.cpp\nindex 5d84b6bc2dc2..55e6e2df1d2b 100644\n--- a/src/Parsers/ParserCreateFunctionQuery.cpp\n+++ b/src/Parsers/ParserCreateFunctionQuery.cpp\n@@ -17,6 +17,7 @@ bool ParserCreateFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Exp\n     ParserKeyword s_function(\"FUNCTION\");\n     ParserKeyword s_or_replace(\"OR REPLACE\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n+    ParserKeyword s_on(\"ON\");\n     ParserIdentifier function_name_p;\n     ParserKeyword s_as(\"AS\");\n     ParserLambdaExpression lambda_p;\n@@ -24,6 +25,7 @@ bool ParserCreateFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Exp\n     ASTPtr function_name;\n     ASTPtr function_core;\n \n+    String cluster_str;\n     bool or_replace = false;\n     bool if_not_exists = false;\n \n@@ -42,6 +44,12 @@ bool ParserCreateFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Exp\n     if (!function_name_p.parse(pos, function_name, expected))\n         return false;\n \n+    if (s_on.ignore(pos, expected))\n+    {\n+        if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n+            return false;\n+    }\n+\n     if (!s_as.ignore(pos, expected))\n         return false;\n \n@@ -55,6 +63,7 @@ bool ParserCreateFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Exp\n     create_function_query->function_core = function_core;\n     create_function_query->or_replace = or_replace;\n     create_function_query->if_not_exists = if_not_exists;\n+    create_function_query->cluster = std::move(cluster_str);\n \n     return true;\n }\ndiff --git a/src/Parsers/ParserDropFunctionQuery.cpp b/src/Parsers/ParserDropFunctionQuery.cpp\nindex d8c866464107..3f35124f9abd 100644\n--- a/src/Parsers/ParserDropFunctionQuery.cpp\n+++ b/src/Parsers/ParserDropFunctionQuery.cpp\n@@ -12,8 +12,10 @@ bool ParserDropFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expec\n     ParserKeyword s_drop(\"DROP\");\n     ParserKeyword s_function(\"FUNCTION\");\n     ParserKeyword s_if_exists(\"IF EXISTS\");\n-\n+    ParserKeyword s_on(\"ON\");\n     ParserIdentifier function_name_p;\n+\n+    String cluster_str;\n     bool if_exists = false;\n \n     ASTPtr function_name;\n@@ -30,8 +32,16 @@ bool ParserDropFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expec\n     if (!function_name_p.parse(pos, function_name, expected))\n         return false;\n \n+    if (s_on.ignore(pos, expected))\n+    {\n+        if (!ASTQueryWithOnCluster::parse(pos, cluster_str, expected))\n+            return false;\n+    }\n+\n     auto drop_function_query = std::make_shared<ASTDropFunctionQuery>();\n     drop_function_query->if_exists = if_exists;\n+    drop_function_query->cluster = std::move(cluster_str);\n+\n     node = drop_function_query;\n \n     drop_function_query->function_name = function_name->as<ASTIdentifier &>().name();\n",
  "test_patch": "diff --git a/tests/integration/test_sql_user_defined_functions_on_cluster/__init__.py b/tests/integration/test_sql_user_defined_functions_on_cluster/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_sql_user_defined_functions_on_cluster/configs/config.d/clusters.xml b/tests/integration/test_sql_user_defined_functions_on_cluster/configs/config.d/clusters.xml\nnew file mode 100644\nindex 000000000000..4d668f591b93\n--- /dev/null\n+++ b/tests/integration/test_sql_user_defined_functions_on_cluster/configs/config.d/clusters.xml\n@@ -0,0 +1,22 @@\n+<clickhouse>\n+<remote_servers>\n+    <cluster>\n+        <shard>\n+            <replica>\n+                <host>ch1</host>\n+                <port>9000</port>\n+            </replica>\n+            <replica>\n+                <host>ch2</host>\n+                <port>9000</port>\n+            </replica>\n+        </shard>\n+        <shard>\n+            <replica>\n+                <host>ch3</host>\n+                <port>9000</port>\n+            </replica>\n+        </shard>\n+    </cluster>\n+</remote_servers>\n+</clickhouse>\ndiff --git a/tests/integration/test_sql_user_defined_functions_on_cluster/test.py b/tests/integration/test_sql_user_defined_functions_on_cluster/test.py\nnew file mode 100644\nindex 000000000000..d5c74a99622d\n--- /dev/null\n+++ b/tests/integration/test_sql_user_defined_functions_on_cluster/test.py\n@@ -0,0 +1,34 @@\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+ch1 = cluster.add_instance('ch1', main_configs=[\"configs/config.d/clusters.xml\"], with_zookeeper=True)\n+ch2 = cluster.add_instance('ch2', main_configs=[\"configs/config.d/clusters.xml\"], with_zookeeper=True)\n+ch3 = cluster.add_instance('ch3', main_configs=[\"configs/config.d/clusters.xml\"], with_zookeeper=True)\n+\n+\n+@pytest.fixture(scope=\"module\", autouse=True)\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_sql_user_defined_functions_on_cluster():\n+    assert \"Unknown function test_function\" in ch1.query_and_get_error(\"SELECT test_function(1);\")\n+    assert \"Unknown function test_function\" in ch2.query_and_get_error(\"SELECT test_function(1);\")\n+    assert \"Unknown function test_function\" in ch3.query_and_get_error(\"SELECT test_function(1);\")\n+\n+    ch1.query_with_retry(\"CREATE FUNCTION test_function ON CLUSTER 'cluster' AS x -> x + 1;\")\n+\n+    assert ch1.query(\"SELECT test_function(1);\") == \"2\\n\"\n+    assert ch2.query(\"SELECT test_function(1);\") == \"2\\n\"\n+    assert ch3.query(\"SELECT test_function(1);\") == \"2\\n\"\n+\n+    ch2.query_with_retry(\"DROP FUNCTION test_function ON CLUSTER 'cluster'\")\n+    assert \"Unknown function test_function\" in ch1.query_and_get_error(\"SELECT test_function(1);\")\n+    assert \"Unknown function test_function\" in ch2.query_and_get_error(\"SELECT test_function(1);\")\n+    assert \"Unknown function test_function\" in ch3.query_and_get_error(\"SELECT test_function(1);\")\n",
  "problem_statement": "CREATE OR REPLACE FUNCTION / IF NOT EXISTS ...\n```sql\r\nCREATE OR REPLACE FUNCTION linear_equation AS (x, k, b) -> k*x + b;\r\n\r\nSyntax error: failed at position 19 ('FUNCTION'):\r\n\r\n\r\nCREATE FUNCTION IF NOT EXISTS linear_equation AS (x, k, b) -> k*x + b;\r\n\r\nSyntax error: failed at position 20 ('NOT'):\r\n\r\n\r\nDROP FUNCTION IF EXISTS linear_equation;\r\n\r\nSyntax error: failed at position 15 ('IF'):\r\n\r\n```\n",
  "hints_text": "@kitaisreal \nBTW, on_cluster also is not implemented?\r\n\r\n```sql\r\nCREATE FUNCTION linear_equation on cluster test_shard_localhost AS (x, k, b) -> k*x + b;\r\n\r\nSyntax error: failed at position 33 ('on'):\r\n```\n@den-crane already implemented in master.\r\nCREATE OR REPLACE, IF NOT EXISTS https://github.com/ClickHouse/ClickHouse/pull/30454.\r\nDROP IF EXISTS https://github.com/ClickHouse/ClickHouse/pull/30437.\r\nOn cluster is not implemented yet.",
  "created_at": "2021-10-27T08:30:47Z"
}