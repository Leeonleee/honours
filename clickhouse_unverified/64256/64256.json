{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64256,
  "instance_id": "ClickHouse__ClickHouse-64256",
  "issue_numbers": [
    "57400"
  ],
  "base_commit": "e513fc19856e30d8f6a4181510cb2fdb1896caa2",
  "patch": "diff --git a/src/Analyzer/Passes/ConvertQueryToCNFPass.cpp b/src/Analyzer/Passes/ConvertQueryToCNFPass.cpp\nindex 96bc62212fd4..5951e8fc5eaf 100644\n--- a/src/Analyzer/Passes/ConvertQueryToCNFPass.cpp\n+++ b/src/Analyzer/Passes/ConvertQueryToCNFPass.cpp\n@@ -99,6 +99,23 @@ bool checkIfGroupAlwaysTrueGraph(const Analyzer::CNF::OrGroup & group, const Com\n     return false;\n }\n \n+bool checkIfGroupAlwaysTrueAtoms(const Analyzer::CNF::OrGroup & group)\n+{\n+    /// Filters out groups containing mutually exclusive atoms,\n+    /// since these groups are always True\n+\n+    for (const auto & atom : group)\n+    {\n+        auto negated(atom);\n+        negated.negative = !atom.negative;\n+        if (group.contains(negated))\n+        {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n bool checkIfAtomAlwaysFalseFullMatch(const Analyzer::CNF::AtomicFormula & atom, const ConstraintsDescription::QueryTreeData & query_tree_constraints)\n {\n     const auto constraint_atom_ids = query_tree_constraints.getAtomIds(atom.node_with_hash);\n@@ -644,7 +661,8 @@ void optimizeWithConstraints(Analyzer::CNF & cnf, const QueryTreeNodes & table_e\n         cnf.filterAlwaysTrueGroups([&](const auto & group)\n            {\n                /// remove always true groups from CNF\n-               return !checkIfGroupAlwaysTrueFullMatch(group, query_tree_constraints) && !checkIfGroupAlwaysTrueGraph(group, compare_graph);\n+               return !checkIfGroupAlwaysTrueFullMatch(group, query_tree_constraints)\n+                   && !checkIfGroupAlwaysTrueGraph(group, compare_graph) && !checkIfGroupAlwaysTrueAtoms(group);\n            })\n            .filterAlwaysFalseAtoms([&](const Analyzer::CNF::AtomicFormula & atom)\n            {\ndiff --git a/src/Interpreters/TreeCNFConverter.h b/src/Interpreters/TreeCNFConverter.h\nindex 8258412f1a63..ec4b029eee94 100644\n--- a/src/Interpreters/TreeCNFConverter.h\n+++ b/src/Interpreters/TreeCNFConverter.h\n@@ -164,6 +164,12 @@ class TreeCNFConverter\n \n void pushNotIn(CNFQuery::AtomicFormula & atom);\n \n+/// Reduces CNF groups by removing mutually exclusive atoms\n+/// found across groups, in case other atoms are identical.\n+/// Might require multiple passes to complete reduction.\n+///\n+/// Example:\n+/// (x OR y) AND (x OR !y) -> x\n template <typename TAndGroup>\n TAndGroup reduceOnceCNFStatements(const TAndGroup & groups)\n {\n@@ -175,10 +181,19 @@ TAndGroup reduceOnceCNFStatements(const TAndGroup & groups)\n         bool inserted = false;\n         for (const auto & atom : group)\n         {\n-            copy.erase(atom);\n             using AtomType = std::decay_t<decltype(atom)>;\n             AtomType negative_atom(atom);\n             negative_atom.negative = !atom.negative;\n+\n+            // Sikpping erase-insert for mutually exclusive atoms within\n+            // single group, since it won't insert negative atom, which\n+            // will break the logic of this rule\n+            if (copy.contains(negative_atom))\n+            {\n+                continue;\n+            }\n+\n+            copy.erase(atom);\n             copy.insert(negative_atom);\n \n             if (groups.contains(copy))\n@@ -209,6 +224,10 @@ bool isCNFGroupSubset(const TOrGroup & left, const TOrGroup & right)\n     return true;\n }\n \n+/// Removes CNF groups if subset group is found in CNF.\n+///\n+/// Example:\n+/// (x OR y) AND (x) -> x\n template <typename TAndGroup>\n TAndGroup filterCNFSubsets(const TAndGroup & groups)\n {\ndiff --git a/src/Interpreters/WhereConstraintsOptimizer.cpp b/src/Interpreters/WhereConstraintsOptimizer.cpp\nindex 979a4f4dbf57..456cf76b9871 100644\n--- a/src/Interpreters/WhereConstraintsOptimizer.cpp\n+++ b/src/Interpreters/WhereConstraintsOptimizer.cpp\n@@ -91,6 +91,22 @@ bool checkIfGroupAlwaysTrueGraph(const CNFQuery::OrGroup & group, const Comparis\n     return false;\n }\n \n+bool checkIfGroupAlwaysTrueAtoms(const CNFQuery::OrGroup & group)\n+{\n+    /// Filters out groups containing mutually exclusive atoms,\n+    /// since these groups are always True\n+\n+    for (const auto & atom : group)\n+    {\n+        auto negated(atom);\n+        negated.negative = !atom.negative;\n+        if (group.contains(negated))\n+        {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n \n bool checkIfAtomAlwaysFalseFullMatch(const CNFQuery::AtomicFormula & atom, const ConstraintsDescription & constraints_description)\n {\n@@ -158,7 +174,8 @@ void WhereConstraintsOptimizer::perform()\n             .filterAlwaysTrueGroups([&compare_graph, this](const auto & group)\n             {\n                 /// remove always true groups from CNF\n-                return !checkIfGroupAlwaysTrueFullMatch(group, metadata_snapshot->getConstraints()) && !checkIfGroupAlwaysTrueGraph(group, compare_graph);\n+                return !checkIfGroupAlwaysTrueFullMatch(group, metadata_snapshot->getConstraints())\n+                    && !checkIfGroupAlwaysTrueGraph(group, compare_graph) && !checkIfGroupAlwaysTrueAtoms(group);\n             })\n             .filterAlwaysFalseAtoms([&compare_graph, this](const auto & atom)\n             {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03161_cnf_reduction.reference b/tests/queries/0_stateless/03161_cnf_reduction.reference\nnew file mode 100644\nindex 000000000000..5e39c0f32234\n--- /dev/null\n+++ b/tests/queries/0_stateless/03161_cnf_reduction.reference\n@@ -0,0 +1,23 @@\n+-- Expected plan with analyzer:\n+SELECT id\n+FROM `03161_table`\n+WHERE f\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 1\n+\n+-- Expected result with analyzer:\n+1\n+\n+-- Expected plan w/o analyzer:\n+SELECT id\n+FROM `03161_table`\n+WHERE f\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 0\n+\n+-- Expected result w/o analyzer:\n+1\n+\n+-- Reproducer from the issue with analyzer\n+2\n+\n+-- Reproducer from the issue w/o analyzer\n+2\ndiff --git a/tests/queries/0_stateless/03161_cnf_reduction.sql b/tests/queries/0_stateless/03161_cnf_reduction.sql\nnew file mode 100644\nindex 000000000000..b34e9171d45b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03161_cnf_reduction.sql\n@@ -0,0 +1,72 @@\n+DROP TABLE IF EXISTS 03161_table;\n+\n+CREATE TABLE 03161_table (id UInt32, f UInt8) ENGINE = Memory;\n+\n+INSERT INTO 03161_table VALUES (0, 0), (1, 1), (2, 0);\n+\n+SELECT '-- Expected plan with analyzer:';\n+\n+EXPLAIN SYNTAX\n+SELECT id\n+FROM 03161_table\n+WHERE f AND (NOT(f) OR f)\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 1;\n+\n+SELECT '';\n+\n+SELECT '-- Expected result with analyzer:';\n+\n+SELECT id\n+FROM 03161_table\n+WHERE f AND (NOT(f) OR f)\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 1;\n+\n+SELECT '';\n+\n+SELECT '-- Expected plan w/o analyzer:';\n+\n+EXPLAIN SYNTAX\n+SELECT id\n+FROM 03161_table\n+WHERE f AND (NOT(f) OR f)\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 0;\n+\n+SELECT '';\n+\n+SELECT '-- Expected result w/o analyzer:';\n+\n+SELECT id\n+FROM 03161_table\n+WHERE f AND (NOT(f) OR f)\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 0;\n+\n+DROP TABLE IF EXISTS 03161_table;\n+\n+-- Checking reproducer from GitHub issue\n+-- https://github.com/ClickHouse/ClickHouse/issues/57400\n+\n+DROP TABLE IF EXISTS 03161_reproducer;\n+\n+CREATE TABLE 03161_reproducer (c0 UInt8, c1 UInt8, c2 UInt8, c3 UInt8, c4 UInt8, c5 UInt8, c6 UInt8, c7 UInt8, c8 UInt8, c9 UInt8) ENGINE = Memory;\n+\n+INSERT INTO 03161_reproducer VALUES (0, 0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0, 1), (0, 0, 0, 0, 0, 0, 0, 0, 1, 0), (0, 0, 0, 0, 0, 0, 0, 0, 1, 1), (0, 0, 0, 0, 0, 0, 0, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 1, 0, 1), (0, 0, 0, 0, 0, 0, 0, 1, 1, 0), (0, 0, 0, 0, 0, 0, 0, 1, 1, 1);\n+\n+SELECT '';\n+\n+SELECT '-- Reproducer from the issue with analyzer';\n+\n+SELECT count()\n+FROM 03161_reproducer\n+WHERE ((NOT c2) AND c2 AND (NOT c1)) OR ((NOT c2) AND c3 AND (NOT c5)) OR ((NOT c7) AND (NOT c8)) OR (c9 AND c6 AND c8 AND (NOT c8) AND (NOT c7))\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 1;\n+\n+SELECT '';\n+\n+SELECT '-- Reproducer from the issue w/o analyzer';\n+\n+SELECT count()\n+FROM 03161_reproducer\n+WHERE ((NOT c2) AND c2 AND (NOT c1)) OR ((NOT c2) AND c3 AND (NOT c5)) OR ((NOT c7) AND (NOT c8)) OR (c9 AND c6 AND c8 AND (NOT c8) AND (NOT c7))\n+SETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1, allow_experimental_analyzer = 0;\n+\n+DROP TABLE IF EXISTS 03161_reproducer;\n",
  "problem_statement": "Wrong query result with convert_query_to_cnf + optimize_using_constraints\nComes from 02725_cnf_large_check.sql:\r\n\r\n\r\nSetup\r\n```sql\r\nCREATE TABLE 02725_cnf (c0 UInt8, c1 UInt8, c2 UInt8, c3 UInt8, c4 UInt8, c5 UInt8, c6 UInt8, c7 UInt8, c8 UInt8, c9 UInt8) ENGINE = Memory;\r\n\r\nINSERT INTO 02725_cnf VALUES (0, 0, 0, 0, 0, 0, 0, 0, 0, 0), (0, 0, 0, 0, 0, 0, 0, 0, 0, 1), (0, 0, 0, 0, 0, 0, 0, 0, 1, 0), (0, 0, 0, 0, 0, 0, 0, 0, 1, 1), (0, 0, 0, 0, 0, 0, 0, 1, 0, 0), (0, 0, 0, 0, 0, 0, 0, 1, 0, 1), (0, 0, 0, 0, 0, 0, 0, 1, 1, 0), (0, 0, 0, 0, 0, 0, 0, 1, 1, 1);\r\n```\r\n\r\nDefault settings:\r\n```\r\nSELECT count()\r\nFROM `02725_cnf`\r\nWHERE ((NOT c2) AND c2 AND (NOT c1)) OR ((NOT c2) AND c3 AND (NOT c5)) OR ((NOT c7) AND (NOT c8)) OR (c9 AND c6 AND c8 AND (NOT c8) AND (NOT c7))\r\n\r\nQuery id: b2f5bc62-1eec-40d4-bf48-720233d7c611\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       2 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nWith convert_query_to_cnf and optimize_using_constraints:\r\n\r\n```\r\nSELECT count()\r\nFROM `02725_cnf`\r\nWHERE ((NOT c2) AND c2 AND (NOT c1)) OR ((NOT c2) AND c3 AND (NOT c5)) OR ((NOT c7) AND (NOT c8)) OR (c9 AND c6 AND c8 AND (NOT c8) AND (NOT c7))\r\nSETTINGS convert_query_to_cnf = 1, optimize_using_constraints = 1\r\n\r\nQuery id: b1fc0d50-e581-4211-aa35-4ef0f3bf8903\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.008 sec. \r\n```\r\n\r\nEnabling only one of them does not trigger the problem. Fails both with and without the analyzer.\n",
  "hints_text": "Fails both with and without the analyzer too",
  "created_at": "2024-05-23T08:00:36Z",
  "modified_files": [
    "src/Analyzer/Passes/ConvertQueryToCNFPass.cpp",
    "src/Interpreters/TreeCNFConverter.h",
    "src/Interpreters/WhereConstraintsOptimizer.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03161_cnf_reduction.reference",
    "b/tests/queries/0_stateless/03161_cnf_reduction.sql"
  ]
}