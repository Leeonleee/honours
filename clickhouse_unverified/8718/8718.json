{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8718,
  "instance_id": "ClickHouse__ClickHouse-8718",
  "issue_numbers": [
    "8469"
  ],
  "base_commit": "93887371f332850b507af97b2acb7d3df27730c4",
  "patch": "diff --git a/dbms/src/Functions/FunctionsLogical.cpp b/dbms/src/Functions/FunctionsLogical.cpp\nindex 75c602df0880..6070ec735db3 100644\n--- a/dbms/src/Functions/FunctionsLogical.cpp\n+++ b/dbms/src/Functions/FunctionsLogical.cpp\n@@ -282,29 +282,33 @@ template <\n     typename Op, template <typename, size_t> typename OperationApplierImpl, size_t N = 10>\n struct OperationApplier\n {\n-    template <typename Columns, typename ResultColumn>\n-    static void apply(Columns & in, ResultColumn & result)\n+    template <typename Columns, typename ResultData>\n+    static void apply(Columns & in, ResultData & result_data)\n     {\n-        while (in.size() > 1)\n-        {\n-            doBatchedApply(in, result->getData());\n-            in.push_back(result.get());\n-        }\n+        /// TODO: Maybe reuse this code for constants (which may form precalculated result)\n+        doBatchedApply<false>(in, result_data);\n+\n+        while (in.size() > 0)\n+            doBatchedApply<true>(in, result_data);\n     }\n \n-    template <typename Columns, typename ResultData>\n+    template <bool carryResult, typename Columns, typename ResultData>\n     static void NO_INLINE doBatchedApply(Columns & in, ResultData & result_data)\n     {\n         if (N > in.size())\n         {\n-            OperationApplier<Op, OperationApplierImpl, N - 1>::doBatchedApply(in, result_data);\n+            OperationApplier<Op, OperationApplierImpl, N - 1>\n+                ::template doBatchedApply<carryResult>(in, result_data);\n             return;\n         }\n \n         const OperationApplierImpl<Op, N> operationApplierImpl(in);\n         size_t i = 0;\n         for (auto & res : result_data)\n-            res = operationApplierImpl.apply(i++);\n+            if constexpr (carryResult)\n+                res = Op::apply(res, operationApplierImpl.apply(i++));\n+            else\n+                res = operationApplierImpl.apply(i++);\n \n         in.erase(in.end() - N, in.end());\n     }\n@@ -312,9 +316,9 @@ struct OperationApplier\n \n template <\n     typename Op, template <typename, size_t> typename OperationApplierImpl>\n-struct OperationApplier<Op, OperationApplierImpl, 1>\n+struct OperationApplier<Op, OperationApplierImpl, 0>\n {\n-    template <typename Columns, typename Result>\n+    template <bool, typename Columns, typename Result>\n     static void NO_INLINE doBatchedApply(Columns &, Result &)\n     {\n         throw Exception(\n@@ -332,7 +336,7 @@ static void executeForTernaryLogicImpl(ColumnRawPtrs arguments, ColumnWithTypeAn\n     const bool has_consts = extractConstColumnsTernary<Op>(arguments, const_3v_value);\n \n     /// If the constant value uniquely determines the result, return it.\n-    if (has_consts && (arguments.empty() || (Op::isSaturable() && Op::isSaturatedValue(const_3v_value))))\n+    if (has_consts && (arguments.empty() || Op::isSaturatedValue(const_3v_value)))\n     {\n         result_info.column = ColumnConst::create(\n             convertFromTernaryData(UInt8Container({const_3v_value}), result_info.type->isNullable()),\n@@ -350,7 +354,7 @@ static void executeForTernaryLogicImpl(ColumnRawPtrs arguments, ColumnWithTypeAn\n         arguments.push_back(const_column_holder.get());\n     }\n \n-    OperationApplier<Op, AssociativeGenericApplierImpl>::apply(arguments, result_column);\n+    OperationApplier<Op, AssociativeGenericApplierImpl>::apply(arguments, result_column->getData());\n \n     result_info.column = convertFromTernaryData(result_column->getData(), result_info.type->isNullable());\n }\n@@ -425,32 +429,30 @@ static void basicExecuteImpl(ColumnRawPtrs arguments, ColumnWithTypeAndName & re\n     if (has_consts && Op::apply(const_val, 0) == 0 && Op::apply(const_val, 1) == 1)\n         has_consts = false;\n \n-    UInt8ColumnPtrs uint8_args;\n-\n-    auto col_res = ColumnUInt8::create();\n+    auto col_res = ColumnUInt8::create(input_rows_count, const_val);\n     UInt8Container & vec_res = col_res->getData();\n-    if (has_consts)\n-    {\n-        vec_res.assign(input_rows_count, const_val);\n-        uint8_args.push_back(col_res.get());\n-    }\n-    else\n-    {\n-        vec_res.resize(input_rows_count);\n-    }\n \n     /// FastPath detection goes in here\n     if (arguments.size() == (has_consts ? 1 : 2))\n     {\n         if (has_consts)\n-            FastApplierImpl<Op>::apply(*arguments[0], *col_res, col_res->getData());\n+            FastApplierImpl<Op>::apply(*arguments[0], *col_res, vec_res);\n         else\n-            FastApplierImpl<Op>::apply(*arguments[0], *arguments[1], col_res->getData());\n+            FastApplierImpl<Op>::apply(*arguments[0], *arguments[1], vec_res);\n \n         result_info.column = std::move(col_res);\n         return;\n     }\n \n+    UInt8ColumnPtrs uint8_args;\n+    if (has_consts)\n+    {\n+        /// TODO: This will FAIL (or not =) ) after correction b/c we now overwrite\n+        /// the result column in the first pass of OperationApplier\n+        //  vec_res.assign(input_rows_count, const_val);\n+        uint8_args.push_back(col_res.get());\n+    }\n+\n     /// Convert all columns to UInt8\n     Columns converted_columns;\n     for (const IColumn * column : arguments)\n@@ -466,11 +468,17 @@ static void basicExecuteImpl(ColumnRawPtrs arguments, ColumnWithTypeAndName & re\n         }\n     }\n \n-    OperationApplier<Op, AssociativeApplierImpl>::apply(uint8_args, col_res);\n+    OperationApplier<Op, AssociativeApplierImpl>::apply(uint8_args, col_res->getData());\n \n+    /// TODO: The following code is obsolete and is to be removed now\n+    ///\n     /// This is possible if there is exactly one non-constant among the arguments, and it is of type UInt8.\n+    /// Suppose we have all constants folded into a neutral value and there is only one non-constant column.\n+    /// Although not all logical functions have a neutral value.\n+    /*\n     if (uint8_args[0] != col_res.get())\n         vec_res.assign(uint8_args[0]->getData());\n+     */\n \n     result_info.column = std::move(col_res);\n }\ndiff --git a/dbms/src/Functions/FunctionsLogical.h b/dbms/src/Functions/FunctionsLogical.h\nindex e671c7184d86..814c9319f527 100644\n--- a/dbms/src/Functions/FunctionsLogical.h\n+++ b/dbms/src/Functions/FunctionsLogical.h\n@@ -83,12 +83,7 @@ struct XorImpl\n \n     static inline constexpr bool isSaturable() { return false; }\n     static inline constexpr bool isSaturatedValue(bool) { return false; }\n-    /** Considering that CH uses UInt8 for representation of boolean values this function\n-      * returns 255 as \"true\" but the current implementation of logical functions suggests that\n-      * any nonzero value is \"true\" as well. Also the current code provides no guarantee\n-      * for \"true\" to be represented with the value of 1.\n-      */\n-    static inline constexpr ResultType apply(UInt8 a, UInt8 b) { return (a != b) ? Ternary::True : Ternary::False; }\n+    static inline constexpr ResultType apply(UInt8 a, UInt8 b) { return !!a != !!b; }\n     static inline constexpr bool specialImplementationForNulls() { return false; }\n \n #if USE_EMBEDDED_COMPILER\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00552_logical_functions_simple.reference b/dbms/tests/queries/0_stateless/00552_logical_functions_simple.reference\nnew file mode 100644\nindex 000000000000..d86bac9de59a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00552_logical_functions_simple.reference\n@@ -0,0 +1,1 @@\n+OK\ndiff --git a/dbms/tests/queries/0_stateless/00552_logical_functions_simple.sql b/dbms/tests/queries/0_stateless/00552_logical_functions_simple.sql\nnew file mode 100644\nindex 000000000000..2043199b9c29\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00552_logical_functions_simple.sql\n@@ -0,0 +1,56 @@\n+\n+-- Test simple logic over smaller batch of columns\n+SELECT\n+    -- x1, x2, x3, x4,\n+    xor(x1, x2, x3, x4) AS xor1,\n+    xor(xor(x1, x2), xor(x3, x4)) AS xor2,\n+\n+    or(x1, x2, x3, x4) AS or1,\n+    or(x1 or x2, x3 or x4) AS or2,\n+\n+    and(x1, x2, x3, x4) AS and1,\n+    and(x1 and x2, x3 and x4) AS and2\n+FROM (\n+    SELECT\n+        toUInt8(number % 2) AS x1,\n+        toUInt8(number / 2 % 2) AS x2,\n+        toUInt8(number / 4 % 2) AS x3,\n+        toUInt8(number / 8 % 2) AS x4\n+    FROM numbers(16)\n+)\n+WHERE\n+    xor1 != xor2 OR (and1 != and2 OR or1 != or2)\n+;\n+\n+-- Test simple logic over multiple batches of columns (currently batch spans over 10 columns)\n+SELECT\n+    -- x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11,\n+    xor(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) AS xor1,\n+    xor(x1, xor(xor(xor(x2, x3), xor(x4, x5)), xor(xor(x6, x7), xor(x8, xor(x9, xor(x10, x11)))))) AS xor2,\n+\n+    or(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) AS or1,\n+    or(x1, or(or(or(x2, x3), or(x4, x5)), or(or(x6, x7), or(x8, or(x9, or(x10, x11)))))) AS or2,\n+\n+    and(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) AS and1,\n+    and(x1, and((x2 and x3) and (x4 and x5), (x6 and x7) and (x8 and (x9 and (x10 and x11))))) AS and2\n+FROM (\n+    SELECT\n+        toUInt8(number % 2) AS x1,\n+        toUInt8(number / 2 % 2) AS x2,\n+        toUInt8(number / 4 % 2) AS x3,\n+        toUInt8(number / 8 % 2) AS x4,\n+        toUInt8(number / 16 % 2) AS x5,\n+        toUInt8(number / 32 % 2) AS x6,\n+        toUInt8(number / 64 % 2) AS x7,\n+        toUInt8(number / 128 % 2) AS x8,\n+        toUInt8(number / 256 % 2) AS x9,\n+        toUInt8(number / 512 % 2) AS x10,\n+        toUInt8(number / 1024 % 2) AS x11\n+    FROM numbers(2048)\n+)\n+WHERE\n+    xor1 != xor2 OR (and1 != and2 OR or1 != or2)\n+;\n+\n+\n+SELECT 'OK';\ndiff --git a/dbms/tests/queries/0_stateless/00552_logical_functions_ternary.reference b/dbms/tests/queries/0_stateless/00552_logical_functions_ternary.reference\nnew file mode 100644\nindex 000000000000..d86bac9de59a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00552_logical_functions_ternary.reference\n@@ -0,0 +1,1 @@\n+OK\ndiff --git a/dbms/tests/queries/0_stateless/00552_logical_functions_ternary.sql b/dbms/tests/queries/0_stateless/00552_logical_functions_ternary.sql\nnew file mode 100644\nindex 000000000000..b22e5c61f0f4\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00552_logical_functions_ternary.sql\n@@ -0,0 +1,59 @@\n+\n+-- Tests codepath for ternary logic\n+SELECT\n+    -- x1, x2, x3, x4,\n+    xor(x1, x2, x3, x4) AS xor1,\n+    xor(xor(x1, x2), xor(x3, x4)) AS xor2,\n+\n+    or(x1, x2, x3, x4) AS or1,\n+    or(x1 or x2, x3 or x4) AS or2,\n+\n+    and(x1, x2, x3, x4) AS and1,\n+    and(x1 and x2, x3 and x4) AS and2\n+FROM (\n+    SELECT\n+        nullIf(toUInt8(number % 3), 2) AS x1,\n+        nullIf(toUInt8(number / 3 % 3), 2) AS x2,\n+        nullIf(toUInt8(number / 9 % 3), 2) AS x3,\n+        nullIf(toUInt8(number / 27 % 3), 2) AS x4\n+    FROM numbers(81)\n+)\n+WHERE\n+    (xor1 != xor2 OR (xor1 is NULL) != (xor2 is NULL)) OR\n+    (or1 != or2 OR (or1 is NULL) != (or2 is NULL) OR (and1 != and2 OR (and1 is NULL) != (and2 is NULL)))\n+;\n+\n+\n+-- Test ternary logic over multiple batches of columns (currently batch spans over 10 columns)\n+SELECT\n+    -- x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11,\n+    xor(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) AS xor1,\n+    xor(x1, xor(xor(xor(x2, x3), xor(x4, x5)), xor(xor(x6, x7), xor(x8, xor(x9, xor(x10, x11)))))) AS xor2,\n+\n+    or(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) AS or1,\n+    or(x1, or(or(or(x2, x3), or(x4, x5)), or(or(x6, x7), or(x8, or(x9, or(x10, x11)))))) AS or2,\n+\n+    and(x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11) AS and1,\n+    and(x1, and((x2 and x3) and (x4 and x5), (x6 and x7) and (x8 and (x9 and (x10 and x11))))) AS and2\n+FROM (\n+    SELECT\n+        nullIf(toUInt8(number % 3), 2) AS x1,\n+        nullIf(toUInt8(number / 3 % 3), 2) AS x2,\n+        nullIf(toUInt8(number / 9 % 3), 2) AS x3,\n+        nullIf(toUInt8(number / 27 % 3), 2) AS x4,\n+        nullIf(toUInt8(number / 81 % 3), 2) AS x5,\n+        nullIf(toUInt8(number / 243 % 3), 2) AS x6,\n+        nullIf(toUInt8(number / 729 % 3), 2) AS x7,\n+        nullIf(toUInt8(number / 2187 % 3), 2) AS x8,\n+        nullIf(toUInt8(number / 6561 % 3), 2) AS x9,\n+        nullIf(toUInt8(number / 19683 % 3), 2) AS x10,\n+        nullIf(toUInt8(number / 59049 % 3), 2) AS x11\n+    FROM numbers(177147)\n+)\n+WHERE\n+    (xor1 != xor2 OR (xor1 is NULL) != (xor2 is NULL)) OR\n+    (or1 != or2 OR (or1 is NULL) != (or2 is NULL) OR (and1 != and2 OR (and1 is NULL) != (and2 is NULL)))\n+;\n+\n+\n+SELECT 'OK';\n",
  "problem_statement": "Inconstitency about the WHERE filtering with Nullable columns with operator <= and >=\n**Describe the bug or unexpected behaviour**\r\n\r\nWhen we try to filter using a `Nullable` column using the operator `>=` and `<=`, we could have some unexpected results depending the complexity of the filtering, where the `NULL` columns could be returned. \r\n\r\n**How to reproduce**\r\n\r\n```\r\nCREATE TABLE foo (\r\n    `id` UInt32,\r\n    `status` Nullable(UInt32)\r\n)  ENGINE = MergeTree()\r\n   PARTITION BY id % 5\r\n   PRIMARY KEY (id)\r\n   ORDER BY (id, assumeNotNull(status));\r\n\r\nINSERT INTO foo SELECT number, nullIf(number % 3, 1) from system.numbers LIMIT 1000000;\r\n```\r\n\r\nOn this example, we set every status where his `status = 1` to `NULL`, so we don't have any status who correspond to 1.\r\n\r\n```\r\nSELECT count()\r\nFROM foo\r\nWHERE ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1));\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502  333333 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\nOn this case, if we show what values we got on the table `foo` for the column `status`, the value is equal to `NULL`\r\n\r\nWhile :\r\n\r\n```\r\nSELECT count()\r\nFROM foo\r\nWHERE status = 1;\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nor even a bit weirder, if we remove only one clause from the original `SELECT` query.\r\n\r\n```\r\nSELECT count()\r\nFROM foo\r\nWHERE ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1))\r\n      OR ((status >= 1) AND (status <= 1));\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\n* Which ClickHouse server version to use\r\n\r\n`19.17.2.4`\r\n\r\n**Expected behavior**\r\nWe should have a consistent result for the three queries, where ClickHouse shouldn't return any rows.\n",
  "hints_text": "",
  "created_at": "2020-01-18T21:16:35Z"
}