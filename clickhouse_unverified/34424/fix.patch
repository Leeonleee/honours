diff --git a/docs/en/sql-reference/statements/create/table.md b/docs/en/sql-reference/statements/create/table.md
index 7bbbb6f32bd1..409ec422ade3 100644
--- a/docs/en/sql-reference/statements/create/table.md
+++ b/docs/en/sql-reference/statements/create/table.md
@@ -16,8 +16,8 @@ By default, tables are created only on the current server. Distributed DDL queri
 ``` sql
 CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
 (
-    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr1] [compression_codec] [TTL expr1],
-    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr2] [compression_codec] [TTL expr2],
+    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1] [compression_codec] [TTL expr1],
+    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr2] [compression_codec] [TTL expr2],
     ...
 ) ENGINE = engine
 ```
@@ -112,6 +112,13 @@ Materialized expression. Such a column can’t be specified for INSERT, because
 For an INSERT without a list of columns, these columns are not considered.
 In addition, this column is not substituted when using an asterisk in a SELECT query. This is to preserve the invariant that the dump obtained using `SELECT *` can be inserted back into the table using INSERT without specifying the list of columns.
 
+### EPHEMERAL {#ephemeral}
+
+`EPHEMERAL expr`
+
+Ephemeral column. Such a column isn't stored in the table and cannot be SELECTed, but can be referenced in the defaults of CREATE statement.
+INSERT without list of columns will skip such column, so SELECT/INSERT invariant is preserved -  the dump obtained using `SELECT *` can be inserted back into the table using INSERT without specifying the list of columns.
+
 ### ALIAS {#alias}
 
 `ALIAS expr`
diff --git a/docs/ru/sql-reference/statements/create/table.md b/docs/ru/sql-reference/statements/create/table.md
index 8567a0ff2db9..b9c2a4f0f0b5 100644
--- a/docs/ru/sql-reference/statements/create/table.md
+++ b/docs/ru/sql-reference/statements/create/table.md
@@ -14,8 +14,8 @@ toc_title: "Таблица"
 ``` sql
 CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]
 (
-    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr1] [compression_codec] [TTL expr1],
-    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|ALIAS expr2] [compression_codec] [TTL expr2],
+    name1 [type1] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr1] [compression_codec] [TTL expr1],
+    name2 [type2] [NULL|NOT NULL] [DEFAULT|MATERIALIZED|EPHEMERAL|ALIAS expr2] [compression_codec] [TTL expr2],
     ...
 ) ENGINE = engine
 ```
@@ -108,6 +108,13 @@ SELECT x, toTypeName(x) FROM t1;
 При INSERT без указания списка столбцов, такие столбцы не рассматриваются.
 Также этот столбец не подставляется при использовании звёздочки в запросе SELECT. Это необходимо, чтобы сохранить инвариант, что дамп, полученный путём `SELECT *`, можно вставить обратно в таблицу INSERT-ом без указания списка столбцов.
 
+### EPHEMERAL {#ephemeral}
+
+`EPHEMERAL expr`
+
+Эфемерное выражение. Такой столбец не хранится в таблице и не может быть получен в запросе SELECT, но на него можно ссылаться в выражениях по умолчанию запроса CREATE.
+INSERT без списка столбцов игнорирует этот столбец, таким образом сохраняется инвариант - т.е. дамп, полученный путём `SELECT *`, можно вставить обратно в таблицу INSERT-ом без указания списка столбцов.
+
 ### ALIAS {#alias}
 
 `ALIAS expr`
diff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp
index d340308122fa..f43d108de9e7 100644
--- a/src/Interpreters/InterpreterInsertQuery.cpp
+++ b/src/Interpreters/InterpreterInsertQuery.cpp
@@ -109,22 +109,31 @@ Block InterpreterInsertQuery::getSampleBlock(
     const StoragePtr & table,
     const StorageMetadataPtr & metadata_snapshot) const
 {
-    Block table_sample = metadata_snapshot->getSampleBlock();
-    Block table_sample_non_materialized = metadata_snapshot->getSampleBlockNonMaterialized();
+    Block table_sample_physical = metadata_snapshot->getSampleBlock();
+    Block table_sample_insertable = metadata_snapshot->getSampleBlockInsertable();
     Block res;
     for (const auto & current_name : names)
     {
-        /// The table does not have a column with that name
-        if (!table_sample.has(current_name))
-            throw Exception("No such column " + current_name + " in table " + table->getStorageID().getNameForLogs(),
-                ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);
-
-        if (!allow_materialized && !table_sample_non_materialized.has(current_name))
-            throw Exception("Cannot insert column " + current_name + ", because it is MATERIALIZED column.", ErrorCodes::ILLEGAL_COLUMN);
         if (res.has(current_name))
             throw Exception("Column " + current_name + " specified more than once", ErrorCodes::DUPLICATE_COLUMN);
 
-        res.insert(ColumnWithTypeAndName(table_sample.getByName(current_name).type, current_name));
+        /// Column is not ordinary or ephemeral
+        if (!table_sample_insertable.has(current_name))
+        {
+            /// Column is materialized
+            if (table_sample_physical.has(current_name))
+            {
+                if (!allow_materialized)
+                    throw Exception("Cannot insert column " + current_name + ", because it is MATERIALIZED column.",
+                        ErrorCodes::ILLEGAL_COLUMN);
+                res.insert(ColumnWithTypeAndName(table_sample_physical.getByName(current_name).type, current_name));
+            }
+            else /// The table does not have a column with that name
+                throw Exception("No such column " + current_name + " in table " + table->getStorageID().getNameForLogs(),
+                    ErrorCodes::NO_SUCH_COLUMN_IN_TABLE);
+        }
+        else
+            res.insert(ColumnWithTypeAndName(table_sample_insertable.getByName(current_name).type, current_name));
     }
     return res;
 }
diff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h
index c48cea9c4805..a4dbe6356642 100644
--- a/src/Parsers/ParserCreateQuery.h
+++ b/src/Parsers/ParserCreateQuery.h
@@ -124,6 +124,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     ParserKeyword s_null{"NULL"};
     ParserKeyword s_not{"NOT"};
     ParserKeyword s_materialized{"MATERIALIZED"};
+    ParserKeyword s_ephemeral{"EPHEMERAL"};
     ParserKeyword s_alias{"ALIAS"};
     ParserKeyword s_comment{"COMMENT"};
     ParserKeyword s_codec{"CODEC"};
@@ -171,6 +172,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
 
     if (!s_default.checkWithoutMoving(pos, expected)
         && !s_materialized.checkWithoutMoving(pos, expected)
+        && !s_ephemeral.checkWithoutMoving(pos, expected)
         && !s_alias.checkWithoutMoving(pos, expected)
         && (require_type
             || (!s_comment.checkWithoutMoving(pos, expected)
@@ -183,7 +185,8 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     }
 
     Pos pos_before_specifier = pos;
-    if (s_default.ignore(pos, expected) || s_materialized.ignore(pos, expected) || s_alias.ignore(pos, expected))
+    if (s_default.ignore(pos, expected) || s_materialized.ignore(pos, expected) ||
+        s_ephemeral.ignore(pos, expected) || s_alias.ignore(pos, expected))
     {
         default_specifier = Poco::toUpper(std::string{pos_before_specifier->begin, pos_before_specifier->end});
 
diff --git a/src/Parsers/obfuscateQueries.cpp b/src/Parsers/obfuscateQueries.cpp
index c0b57d9b1f58..a4eb54045521 100644
--- a/src/Parsers/obfuscateQueries.cpp
+++ b/src/Parsers/obfuscateQueries.cpp
@@ -26,20 +26,20 @@ namespace
 
 const std::unordered_set<std::string_view> keywords
 {
-    "CREATE",       "DATABASE", "IF",     "NOT",       "EXISTS",   "TEMPORARY",   "TABLE",    "ON",          "CLUSTER", "DEFAULT",
-    "MATERIALIZED", "ALIAS",    "ENGINE", "AS",        "VIEW",     "POPULATE",    "SETTINGS", "ATTACH",      "DETACH",  "DROP",
-    "RENAME",       "TO",       "ALTER",  "ADD",       "MODIFY",   "CLEAR",       "COLUMN",   "AFTER",       "COPY",    "PROJECT",
-    "PRIMARY",      "KEY",      "CHECK",  "PARTITION", "PART",     "FREEZE",      "FETCH",    "FROM",        "SHOW",    "INTO",
-    "OUTFILE",      "FORMAT",   "TABLES", "DATABASES", "LIKE",     "PROCESSLIST", "CASE",     "WHEN",        "THEN",    "ELSE",
-    "END",          "DESCRIBE", "DESC",   "USE",       "SET",      "OPTIMIZE",    "FINAL",    "DEDUPLICATE", "INSERT",  "VALUES",
-    "SELECT",       "DISTINCT", "SAMPLE", "ARRAY",     "JOIN",     "GLOBAL",      "LOCAL",    "ANY",         "ALL",     "INNER",
-    "LEFT",         "RIGHT",    "FULL",   "OUTER",     "CROSS",    "USING",       "PREWHERE", "WHERE",       "GROUP",   "BY",
-    "WITH",         "TOTALS",   "HAVING", "ORDER",     "COLLATE",  "LIMIT",       "UNION",    "AND",         "OR",      "ASC",
-    "IN",           "KILL",     "QUERY",  "SYNC",      "ASYNC",    "TEST",        "BETWEEN",  "TRUNCATE",    "USER",    "ROLE",
-    "PROFILE",      "QUOTA",    "POLICY", "ROW",       "GRANT",    "REVOKE",      "OPTION",   "ADMIN",       "EXCEPT",  "REPLACE",
-    "IDENTIFIED",   "HOST",     "NAME",   "READONLY",  "WRITABLE", "PERMISSIVE",  "FOR",      "RESTRICTIVE", "RANDOMIZED",
-    "INTERVAL",     "LIMITS",   "ONLY",   "TRACKING",  "IP",       "REGEXP",      "ILIKE",    "DICTIONARY",  "OFFSET",
-    "TRIM", "LTRIM", "RTRIM", "BOTH", "LEADING", "TRAILING"
+    "CREATE",       "DATABASE",   "IF",       "NOT",      "EXISTS",    "TEMPORARY", "TABLE",       "ON",         "CLUSTER",     "DEFAULT",
+    "MATERIALIZED", "EPHEMERAL",  "ALIAS",    "ENGINE",   "AS",        "VIEW",      "POPULATE",    "SETTINGS",   "ATTACH",      "DETACH",
+    "DROP",         "RENAME",     "TO",       "ALTER",    "ADD",       "MODIFY",    "CLEAR",       "COLUMN",     "AFTER",       "COPY",
+    "PROJECT",      "PRIMARY",    "KEY",      "CHECK",    "PARTITION", "PART",      "FREEZE",      "FETCH",      "FROM",        "SHOW",
+    "INTO",         "OUTFILE",    "FORMAT",   "TABLES",   "DATABASES", "LIKE",      "PROCESSLIST", "CASE",       "WHEN",        "THEN",
+    "ELSE",         "END",        "DESCRIBE", "DESC",     "USE",       "SET",       "OPTIMIZE",    "FINAL",      "DEDUPLICATE", "INSERT",
+    "VALUES",       "SELECT",     "DISTINCT", "SAMPLE",   "ARRAY",     "JOIN",      "GLOBAL",      "LOCAL",      "ANY",         "ALL",
+    "INNER",        "LEFT",       "RIGHT",    "FULL",     "OUTER",     "CROSS",     "USING",       "PREWHERE",   "WHERE",       "GROUP",
+    "BY",           "WITH",       "TOTALS",   "HAVING",   "ORDER",     "COLLATE",   "LIMIT",       "UNION",      "AND",         "OR",
+    "ASC",          "IN",         "KILL",     "QUERY",    "SYNC",      "ASYNC",     "TEST",        "BETWEEN",    "TRUNCATE",    "USER",
+    "ROLE",         "PROFILE",    "QUOTA",    "POLICY",   "ROW",       "GRANT",     "REVOKE",      "OPTION",     "ADMIN",       "EXCEPT",
+    "REPLACE",      "IDENTIFIED", "HOST",     "NAME",     "READONLY",  "WRITABLE",  "PERMISSIVE",  "FOR",        "RESTRICTIVE", "RANDOMIZED",
+    "INTERVAL",     "LIMITS",     "ONLY",     "TRACKING", "IP",        "REGEXP",    "ILIKE",       "DICTIONARY", "OFFSET",      "TRIM",
+    "LTRIM",        "RTRIM",      "BOTH",     "LEADING",  "TRAILING"
 };
 
 const std::unordered_set<std::string_view> keep_words
diff --git a/src/Storages/ColumnDefault.cpp b/src/Storages/ColumnDefault.cpp
index d35d3c31470b..3cf49ea69fc9 100644
--- a/src/Storages/ColumnDefault.cpp
+++ b/src/Storages/ColumnDefault.cpp
@@ -9,6 +9,7 @@ struct AliasNames
     static constexpr const char * DEFAULT = "DEFAULT";
     static constexpr const char * MATERIALIZED = "MATERIALIZED";
     static constexpr const char * ALIAS = "ALIAS";
+    static constexpr const char * EPHEMERAL = "EPHEMERAL";
 };
 
 }
@@ -27,7 +28,8 @@ ColumnDefaultKind columnDefaultKindFromString(const std::string & str)
     static const std::unordered_map<std::string, ColumnDefaultKind> map{
         { AliasNames::DEFAULT, ColumnDefaultKind::Default },
         { AliasNames::MATERIALIZED, ColumnDefaultKind::Materialized },
-        { AliasNames::ALIAS, ColumnDefaultKind::Alias }
+        { AliasNames::ALIAS, ColumnDefaultKind::Alias },
+        { AliasNames::EPHEMERAL, ColumnDefaultKind::Ephemeral }
     };
 
     const auto it = map.find(str);
@@ -43,7 +45,8 @@ std::string toString(const ColumnDefaultKind kind)
     static const std::unordered_map<ColumnDefaultKind, std::string> map{
         { ColumnDefaultKind::Default, AliasNames::DEFAULT },
         { ColumnDefaultKind::Materialized, AliasNames::MATERIALIZED },
-        { ColumnDefaultKind::Alias, AliasNames::ALIAS }
+        { ColumnDefaultKind::Alias, AliasNames::ALIAS },
+        { ColumnDefaultKind::Ephemeral, AliasNames::EPHEMERAL }
     };
 
     const auto it = map.find(kind);
diff --git a/src/Storages/ColumnDefault.h b/src/Storages/ColumnDefault.h
index 38b61415a9ad..096a1f177ab1 100644
--- a/src/Storages/ColumnDefault.h
+++ b/src/Storages/ColumnDefault.h
@@ -13,7 +13,8 @@ enum class ColumnDefaultKind
 {
     Default,
     Materialized,
-    Alias
+    Alias,
+    Ephemeral
 };
 
 
diff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp
index 568257b4fd77..964fad8f4b5e 100644
--- a/src/Storages/ColumnsDescription.cpp
+++ b/src/Storages/ColumnsDescription.cpp
@@ -340,6 +340,15 @@ NamesAndTypesList ColumnsDescription::getOrdinary() const
     return ret;
 }
 
+NamesAndTypesList ColumnsDescription::getInsertable() const
+{
+    NamesAndTypesList ret;
+    for (const auto & col : columns)
+        if (col.default_desc.kind == ColumnDefaultKind::Default || col.default_desc.kind == ColumnDefaultKind::Ephemeral)
+            ret.emplace_back(col.name, col.type);
+    return ret;
+}
+
 NamesAndTypesList ColumnsDescription::getMaterialized() const
 {
     NamesAndTypesList ret;
@@ -358,6 +367,15 @@ NamesAndTypesList ColumnsDescription::getAliases() const
     return ret;
 }
 
+NamesAndTypesList ColumnsDescription::getEphemeral() const
+{
+    NamesAndTypesList ret;
+        for (const auto & col : columns)
+            if (col.default_desc.kind == ColumnDefaultKind::Ephemeral)
+                ret.emplace_back(col.name, col.type);
+    return ret;
+}
+
 NamesAndTypesList ColumnsDescription::getAll() const
 {
     NamesAndTypesList ret;
@@ -402,6 +420,8 @@ static ColumnsDescription::GetFlags defaultKindToGetFlag(ColumnDefaultKind kind)
             return ColumnsDescription::Materialized;
         case ColumnDefaultKind::Alias:
             return ColumnsDescription::Aliases;
+        case ColumnDefaultKind::Ephemeral:
+            return ColumnsDescription::Ephemeral;
     }
     __builtin_unreachable();
 }
@@ -441,7 +461,7 @@ NamesAndTypesList ColumnsDescription::getAllPhysical() const
 {
     NamesAndTypesList ret;
     for (const auto & col : columns)
-        if (col.default_desc.kind != ColumnDefaultKind::Alias)
+        if (col.default_desc.kind != ColumnDefaultKind::Alias && col.default_desc.kind != ColumnDefaultKind::Ephemeral)
             ret.emplace_back(col.name, col.type);
     return ret;
 }
@@ -450,7 +470,7 @@ Names ColumnsDescription::getNamesOfPhysical() const
 {
     Names ret;
     for (const auto & col : columns)
-        if (col.default_desc.kind != ColumnDefaultKind::Alias)
+        if (col.default_desc.kind != ColumnDefaultKind::Alias && col.default_desc.kind != ColumnDefaultKind::Ephemeral)
             ret.emplace_back(col.name);
     return ret;
 }
@@ -481,7 +501,8 @@ NameAndTypePair ColumnsDescription::getColumnOrSubcolumn(GetFlags flags, const S
 std::optional<NameAndTypePair> ColumnsDescription::tryGetPhysical(const String & column_name) const
 {
     auto it = columns.get<1>().find(column_name);
-    if (it == columns.get<1>().end() || it->default_desc.kind == ColumnDefaultKind::Alias)
+    if (it == columns.get<1>().end() ||
+            it->default_desc.kind == ColumnDefaultKind::Alias || it->default_desc.kind == ColumnDefaultKind::Ephemeral)
         return {};
 
     return NameAndTypePair(it->name, it->type);
@@ -500,7 +521,8 @@ NameAndTypePair ColumnsDescription::getPhysical(const String & column_name) cons
 bool ColumnsDescription::hasPhysical(const String & column_name) const
 {
     auto it = columns.get<1>().find(column_name);
-    return it != columns.get<1>().end() && it->default_desc.kind != ColumnDefaultKind::Alias;
+    return it != columns.get<1>().end() &&
+        it->default_desc.kind != ColumnDefaultKind::Alias && it->default_desc.kind != ColumnDefaultKind::Ephemeral;
 }
 
 bool ColumnsDescription::hasColumnOrSubcolumn(GetFlags flags, const String & column_name) const
diff --git a/src/Storages/ColumnsDescription.h b/src/Storages/ColumnsDescription.h
index 44f895c89ce3..6cf863c6cb45 100644
--- a/src/Storages/ColumnsDescription.h
+++ b/src/Storages/ColumnsDescription.h
@@ -84,18 +84,21 @@ class ColumnsDescription
         Ordinary = 1,
         Materialized = 2,
         Aliases = 4,
+        Ephemeral = 8,
 
         AllPhysical = Ordinary | Materialized,
-        All = AllPhysical | Aliases,
+        All = AllPhysical | Aliases | Ephemeral,
     };
 
     NamesAndTypesList getByNames(GetFlags flags, const Names & names, bool with_subcolumns) const;
 
     NamesAndTypesList getOrdinary() const;
     NamesAndTypesList getMaterialized() const;
+    NamesAndTypesList getInsertable() const; /// ordinary + ephemeral
     NamesAndTypesList getAliases() const;
+    NamesAndTypesList getEphemeral() const;
     NamesAndTypesList getAllPhysical() const; /// ordinary + materialized.
-    NamesAndTypesList getAll() const; /// ordinary + materialized + aliases
+    NamesAndTypesList getAll() const; /// ordinary + materialized + aliases + ephemeral
     NamesAndTypesList getAllWithSubcolumns() const;
     NamesAndTypesList getAllPhysicalWithSubcolumns() const;
 
diff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp
index 061319bc1c0d..8439c721c1fd 100644
--- a/src/Storages/StorageInMemoryMetadata.cpp
+++ b/src/Storages/StorageInMemoryMetadata.cpp
@@ -300,6 +300,16 @@ ColumnDependencies StorageInMemoryMetadata::getColumnDependencies(const NameSet
 
 }
 
+Block StorageInMemoryMetadata::getSampleBlockInsertable() const
+{
+    Block res;
+
+    for (const auto & column : getColumns().getInsertable())
+        res.insert({column.type->createColumn(), column.type, column.name});
+
+    return res;
+}
+
 Block StorageInMemoryMetadata::getSampleBlockNonMaterialized() const
 {
     Block res;
diff --git a/src/Storages/StorageInMemoryMetadata.h b/src/Storages/StorageInMemoryMetadata.h
index a8912d44f2c1..9d6935b609b2 100644
--- a/src/Storages/StorageInMemoryMetadata.h
+++ b/src/Storages/StorageInMemoryMetadata.h
@@ -151,6 +151,9 @@ struct StorageInMemoryMetadata
     /// Block with ordinary + materialized columns.
     Block getSampleBlock() const;
 
+    /// Block with ordinary + ephemeral.
+    Block getSampleBlockInsertable() const;
+
     /// Block with ordinary columns.
     Block getSampleBlockNonMaterialized() const;
 
