{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 26003,
  "instance_id": "ClickHouse__ClickHouse-26003",
  "issue_numbers": [
    "25997",
    "24124"
  ],
  "base_commit": "103b860555d52787d90da2e8f07a87bde2c6e6fb",
  "patch": "diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex dffe2239e62a..915d14466b6b 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -22,10 +22,6 @@\n     M(WriteBufferFromFileDescriptorWrite, \"Number of writes (write/pwrite) to a file descriptor. Does not include sockets.\") \\\n     M(WriteBufferFromFileDescriptorWriteFailed, \"Number of times the write (write/pwrite) to a file descriptor have failed.\") \\\n     M(WriteBufferFromFileDescriptorWriteBytes, \"Number of bytes written to file descriptors. If the file is compressed, this will show compressed data size.\") \\\n-    M(ReadBufferAIORead, \"\") \\\n-    M(ReadBufferAIOReadBytes, \"\") \\\n-    M(WriteBufferAIOWrite, \"\") \\\n-    M(WriteBufferAIOWriteBytes, \"\") \\\n     M(ReadCompressedBytes, \"Number of bytes (the number of bytes before decompression) read from compressed sources (files, network).\") \\\n     M(CompressedReadBufferBlocks, \"Number of compressed blocks (the blocks of data that are compressed independent of each other) read from compressed sources (files, network).\") \\\n     M(CompressedReadBufferBytes, \"Number of uncompressed bytes (the number of bytes after decompression) read from compressed sources (files, network).\") \\\n@@ -34,6 +30,10 @@\n     M(UncompressedCacheWeightLost, \"\") \\\n     M(MMappedFileCacheHits, \"\") \\\n     M(MMappedFileCacheMisses, \"\") \\\n+    M(AIOWrite, \"Number of writes with Linux or FreeBSD AIO interface\") \\\n+    M(AIOWriteBytes, \"Number of bytes written with Linux or FreeBSD AIO interface\") \\\n+    M(AIORead, \"Number of reads with Linux or FreeBSD AIO interface\") \\\n+    M(AIOReadBytes, \"Number of bytes read with Linux or FreeBSD AIO interface\") \\\n     M(IOBufferAllocs, \"\") \\\n     M(IOBufferAllocBytes, \"\") \\\n     M(ArenaAllocChunks, \"\") \\\n@@ -43,8 +43,8 @@\n     M(MarkCacheHits, \"\") \\\n     M(MarkCacheMisses, \"\") \\\n     M(CreatedReadBufferOrdinary, \"\") \\\n-    M(CreatedReadBufferAIO, \"\") \\\n-    M(CreatedReadBufferAIOFailed, \"\") \\\n+    M(CreatedReadBufferDirectIO, \"\") \\\n+    M(CreatedReadBufferDirectIOFailed, \"\") \\\n     M(CreatedReadBufferMMap, \"\") \\\n     M(CreatedReadBufferMMapFailed, \"\") \\\n     M(DiskReadElapsedMicroseconds, \"Total time spent waiting for read syscall. This include reads from page cache.\") \\\ndiff --git a/src/Compression/CompressedReadBufferFromFile.cpp b/src/Compression/CompressedReadBufferFromFile.cpp\nindex e14a1784b144..22ffb74f61a7 100644\n--- a/src/Compression/CompressedReadBufferFromFile.cpp\n+++ b/src/Compression/CompressedReadBufferFromFile.cpp\n@@ -47,13 +47,13 @@ CompressedReadBufferFromFile::CompressedReadBufferFromFile(std::unique_ptr<ReadB\n CompressedReadBufferFromFile::CompressedReadBufferFromFile(\n     const std::string & path,\n     size_t estimated_size,\n-    size_t aio_threshold,\n+    size_t direct_io_threshold,\n     size_t mmap_threshold,\n     MMappedFileCache * mmap_cache,\n     size_t buf_size,\n     bool allow_different_codecs_)\n     : BufferWithOwnMemory<ReadBuffer>(0)\n-    , p_file_in(createReadBufferFromFileBase(path, estimated_size, aio_threshold, mmap_threshold, mmap_cache, buf_size))\n+    , p_file_in(createReadBufferFromFileBase(path, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache, buf_size))\n     , file_in(*p_file_in)\n {\n     compressed_in = &file_in;\ndiff --git a/src/Compression/CompressedReadBufferFromFile.h b/src/Compression/CompressedReadBufferFromFile.h\nindex 2ee7021b35ad..fe9add6f0153 100644\n--- a/src/Compression/CompressedReadBufferFromFile.h\n+++ b/src/Compression/CompressedReadBufferFromFile.h\n@@ -33,7 +33,7 @@ class CompressedReadBufferFromFile : public CompressedReadBufferBase, public Buf\n     CompressedReadBufferFromFile(std::unique_ptr<ReadBufferFromFileBase> buf, bool allow_different_codecs_ = false);\n \n     CompressedReadBufferFromFile(\n-        const std::string & path, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,\n+        const std::string & path, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE, bool allow_different_codecs_ = false);\n \n     void seek(size_t offset_in_compressed_file, size_t offset_in_decompressed_block);\ndiff --git a/src/Dictionaries/SSDCacheDictionaryStorage.h b/src/Dictionaries/SSDCacheDictionaryStorage.h\nindex 7232d2d01b73..395328a904d7 100644\n--- a/src/Dictionaries/SSDCacheDictionaryStorage.h\n+++ b/src/Dictionaries/SSDCacheDictionaryStorage.h\n@@ -26,8 +26,10 @@\n namespace ProfileEvents\n {\n     extern const Event FileOpen;\n-    extern const Event WriteBufferAIOWrite;\n-    extern const Event WriteBufferAIOWriteBytes;\n+    extern const Event AIOWrite;\n+    extern const Event AIOWriteBytes;\n+    extern const Event AIORead;\n+    extern const Event AIOReadBytes;\n }\n \n namespace DB\n@@ -531,8 +533,8 @@ class SSDCacheFileBuffer : private boost::noncopyable\n \n         auto bytes_written = eventResult(event);\n \n-        ProfileEvents::increment(ProfileEvents::WriteBufferAIOWrite);\n-        ProfileEvents::increment(ProfileEvents::WriteBufferAIOWriteBytes, bytes_written);\n+        ProfileEvents::increment(ProfileEvents::AIOWrite);\n+        ProfileEvents::increment(ProfileEvents::AIOWriteBytes, bytes_written);\n \n         if (bytes_written != static_cast<decltype(bytes_written)>(block_size * buffer_size_in_blocks))\n             throw Exception(ErrorCodes::AIO_WRITE_ERROR,\n@@ -600,6 +602,9 @@ class SSDCacheFileBuffer : private boost::noncopyable\n                 buffer_size_in_bytes,\n                 read_bytes);\n \n+        ProfileEvents::increment(ProfileEvents::AIORead);\n+        ProfileEvents::increment(ProfileEvents::AIOReadBytes, read_bytes);\n+\n         SSDCacheBlock block(block_size);\n \n         for (size_t i = 0; i < blocks_length; ++i)\n@@ -687,6 +692,9 @@ class SSDCacheFileBuffer : private boost::noncopyable\n                     throw Exception(ErrorCodes::AIO_READ_ERROR,\n                         \"GC: AIO failed to read file ({}). Expected bytes ({}). Actual bytes ({})\", file_path, block_size, read_bytes);\n \n+                ProfileEvents::increment(ProfileEvents::AIORead);\n+                ProfileEvents::increment(ProfileEvents::AIOReadBytes, read_bytes);\n+\n                 char * request_buffer = getRequestBuffer(request);\n \n                 // Unpoison the memory returned from an uninstrumented system function.\ndiff --git a/src/Disks/DiskCacheWrapper.cpp b/src/Disks/DiskCacheWrapper.cpp\nindex d5b82edb134a..f672376841e2 100644\n--- a/src/Disks/DiskCacheWrapper.cpp\n+++ b/src/Disks/DiskCacheWrapper.cpp\n@@ -90,17 +90,17 @@ DiskCacheWrapper::readFile(\n     const String & path,\n     size_t buf_size,\n     size_t estimated_size,\n-    size_t aio_threshold,\n+    size_t direct_io_threshold,\n     size_t mmap_threshold,\n     MMappedFileCache * mmap_cache) const\n {\n     if (!cache_file_predicate(path))\n-        return DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+        return DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n \n     LOG_DEBUG(log, \"Read file {} from cache\", backQuote(path));\n \n     if (cache_disk->exists(path))\n-        return cache_disk->readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+        return cache_disk->readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n \n     auto metadata = acquireDownloadMetadata(path);\n \n@@ -134,7 +134,7 @@ DiskCacheWrapper::readFile(\n \n                 auto tmp_path = path + \".tmp\";\n                 {\n-                    auto src_buffer = DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+                    auto src_buffer = DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n                     auto dst_buffer = cache_disk->writeFile(tmp_path, buf_size, WriteMode::Rewrite);\n                     copyData(*src_buffer, *dst_buffer);\n                 }\n@@ -158,9 +158,9 @@ DiskCacheWrapper::readFile(\n     }\n \n     if (metadata->status == DOWNLOADED)\n-        return cache_disk->readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+        return cache_disk->readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n \n-    return DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+    return DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n }\n \n std::unique_ptr<WriteBufferFromFileBase>\ndiff --git a/src/Disks/DiskCacheWrapper.h b/src/Disks/DiskCacheWrapper.h\nindex 6d58394640fd..7e711dd521c4 100644\n--- a/src/Disks/DiskCacheWrapper.h\n+++ b/src/Disks/DiskCacheWrapper.h\n@@ -38,7 +38,7 @@ class DiskCacheWrapper : public DiskDecorator\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n \ndiff --git a/src/Disks/DiskDecorator.cpp b/src/Disks/DiskDecorator.cpp\nindex d1ff3f9f8277..7237a249bcb2 100644\n--- a/src/Disks/DiskDecorator.cpp\n+++ b/src/Disks/DiskDecorator.cpp\n@@ -115,9 +115,9 @@ void DiskDecorator::listFiles(const String & path, std::vector<String> & file_na\n \n std::unique_ptr<ReadBufferFromFileBase>\n DiskDecorator::readFile(\n-    const String & path, size_t buf_size, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const\n+    const String & path, size_t buf_size, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const\n {\n-    return delegate->readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+    return delegate->readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n }\n \n std::unique_ptr<WriteBufferFromFileBase>\ndiff --git a/src/Disks/DiskDecorator.h b/src/Disks/DiskDecorator.h\nindex 401078e6b2eb..0910f4c28cd6 100644\n--- a/src/Disks/DiskDecorator.h\n+++ b/src/Disks/DiskDecorator.h\n@@ -39,7 +39,7 @@ class DiskDecorator : public IDisk\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n \ndiff --git a/src/Disks/DiskLocal.cpp b/src/Disks/DiskLocal.cpp\nindex 89c1514f5c88..4ceb76ab0593 100644\n--- a/src/Disks/DiskLocal.cpp\n+++ b/src/Disks/DiskLocal.cpp\n@@ -211,9 +211,9 @@ void DiskLocal::replaceFile(const String & from_path, const String & to_path)\n \n std::unique_ptr<ReadBufferFromFileBase>\n DiskLocal::readFile(\n-    const String & path, size_t buf_size, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const\n+    const String & path, size_t buf_size, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache) const\n {\n-    return createReadBufferFromFileBase(fs::path(disk_path) / path, estimated_size, aio_threshold, mmap_threshold, mmap_cache, buf_size);\n+    return createReadBufferFromFileBase(fs::path(disk_path) / path, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache, buf_size);\n }\n \n std::unique_ptr<WriteBufferFromFileBase>\ndiff --git a/src/Disks/DiskLocal.h b/src/Disks/DiskLocal.h\nindex 47482ad8d673..63a6fe59beaa 100644\n--- a/src/Disks/DiskLocal.h\n+++ b/src/Disks/DiskLocal.h\n@@ -74,7 +74,7 @@ class DiskLocal : public IDisk\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n \ndiff --git a/src/Disks/DiskMemory.h b/src/Disks/DiskMemory.h\nindex d5c57b20a4a8..40fd2b2a9f91 100644\n--- a/src/Disks/DiskMemory.h\n+++ b/src/Disks/DiskMemory.h\n@@ -66,7 +66,7 @@ class DiskMemory : public IDisk\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n \ndiff --git a/src/Disks/DiskRestartProxy.cpp b/src/Disks/DiskRestartProxy.cpp\nindex 2600dc5a1e14..1bd5b2acf50f 100644\n--- a/src/Disks/DiskRestartProxy.cpp\n+++ b/src/Disks/DiskRestartProxy.cpp\n@@ -187,11 +187,11 @@ void DiskRestartProxy::listFiles(const String & path, std::vector<String> & file\n }\n \n std::unique_ptr<ReadBufferFromFileBase> DiskRestartProxy::readFile(\n-    const String & path, size_t buf_size, size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache)\n+    const String & path, size_t buf_size, size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache)\n     const\n {\n     ReadLock lock (mutex);\n-    auto impl = DiskDecorator::readFile(path, buf_size, estimated_size, aio_threshold, mmap_threshold, mmap_cache);\n+    auto impl = DiskDecorator::readFile(path, buf_size, estimated_size, direct_io_threshold, mmap_threshold, mmap_cache);\n     return std::make_unique<RestartAwareReadBuffer>(*this, std::move(impl));\n }\n \ndiff --git a/src/Disks/DiskRestartProxy.h b/src/Disks/DiskRestartProxy.h\nindex f5502d9d68f5..e6c94d9ad7bc 100644\n--- a/src/Disks/DiskRestartProxy.h\n+++ b/src/Disks/DiskRestartProxy.h\n@@ -47,7 +47,7 @@ class DiskRestartProxy : public DiskDecorator\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n     std::unique_ptr<WriteBufferFromFileBase> writeFile(const String & path, size_t buf_size, WriteMode mode) override;\ndiff --git a/src/Disks/HDFS/DiskHDFS.h b/src/Disks/HDFS/DiskHDFS.h\nindex 49fdf44728b7..1f93192fd573 100644\n--- a/src/Disks/HDFS/DiskHDFS.h\n+++ b/src/Disks/HDFS/DiskHDFS.h\n@@ -48,7 +48,7 @@ class DiskHDFS final : public IDiskRemote\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n \ndiff --git a/src/Disks/IDisk.h b/src/Disks/IDisk.h\nindex ecaf7d63fdcc..f9e7624f4ab8 100644\n--- a/src/Disks/IDisk.h\n+++ b/src/Disks/IDisk.h\n@@ -156,7 +156,7 @@ class IDisk : public Space\n         const String & path,\n         size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE,\n         size_t estimated_size = 0,\n-        size_t aio_threshold = 0,\n+        size_t direct_io_threshold = 0,\n         size_t mmap_threshold = 0,\n         MMappedFileCache * mmap_cache = nullptr) const = 0;\n \ndiff --git a/src/Disks/S3/DiskS3.h b/src/Disks/S3/DiskS3.h\nindex 21bf0d3867b9..fc7c832e45d6 100644\n--- a/src/Disks/S3/DiskS3.h\n+++ b/src/Disks/S3/DiskS3.h\n@@ -77,7 +77,7 @@ class DiskS3 final : public IDiskRemote\n         const String & path,\n         size_t buf_size,\n         size_t estimated_size,\n-        size_t aio_threshold,\n+        size_t direct_io_threshold,\n         size_t mmap_threshold,\n         MMappedFileCache * mmap_cache) const override;\n \ndiff --git a/src/IO/HashingReadBuffer.h b/src/IO/HashingReadBuffer.h\nindex 08b6de69dcbf..5d42c64478c6 100644\n--- a/src/IO/HashingReadBuffer.h\n+++ b/src/IO/HashingReadBuffer.h\n@@ -34,7 +34,7 @@ class HashingReadBuffer : public IHashingBuffer<ReadBuffer>\n         working_buffer = in.buffer();\n         pos = in.position();\n \n-        // `pos` may be different from working_buffer.begin() when using AIO.\n+        // `pos` may be different from working_buffer.begin() when using sophisticated ReadBuffers.\n         calculateHash(pos, working_buffer.end() - pos);\n \n         return res;\ndiff --git a/src/IO/ReadBufferAIO.cpp b/src/IO/ReadBufferAIO.cpp\ndeleted file mode 100644\nindex c064e0d4ed9b..000000000000\n--- a/src/IO/ReadBufferAIO.cpp\n+++ /dev/null\n@@ -1,312 +0,0 @@\n-#if defined(OS_LINUX) || defined(__FreeBSD__)\n-\n-#include <IO/ReadBufferAIO.h>\n-#include <IO/AIOContextPool.h>\n-#include <Common/ProfileEvents.h>\n-#include <Common/Stopwatch.h>\n-#include <Common/MemorySanitizer.h>\n-#include <Core/Defines.h>\n-\n-#include <sys/types.h>\n-#include <sys/stat.h>\n-#include <errno.h>\n-\n-#include <optional>\n-\n-\n-namespace ProfileEvents\n-{\n-    extern const Event FileOpen;\n-    extern const Event ReadBufferAIORead;\n-    extern const Event ReadBufferAIOReadBytes;\n-}\n-\n-namespace CurrentMetrics\n-{\n-    extern const Metric Read;\n-}\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int FILE_DOESNT_EXIST;\n-    extern const int CANNOT_OPEN_FILE;\n-    extern const int LOGICAL_ERROR;\n-    extern const int ARGUMENT_OUT_OF_BOUND;\n-    extern const int AIO_READ_ERROR;\n-}\n-\n-\n-/// Note: an additional page is allocated that will contain the data that\n-/// does not fit into the main buffer.\n-ReadBufferAIO::ReadBufferAIO(const std::string & filename_, size_t buffer_size_, int flags_, char * existing_memory_)\n-    : ReadBufferFromFileBase(buffer_size_ + DEFAULT_AIO_FILE_BLOCK_SIZE, existing_memory_, DEFAULT_AIO_FILE_BLOCK_SIZE),\n-      fill_buffer(BufferWithOwnMemory<ReadBuffer>(internalBuffer().size(), nullptr, DEFAULT_AIO_FILE_BLOCK_SIZE)),\n-      filename(filename_)\n-{\n-    ProfileEvents::increment(ProfileEvents::FileOpen);\n-\n-    int open_flags = (flags_ == -1) ? O_RDONLY : flags_;\n-    open_flags |= O_DIRECT;\n-    open_flags |= O_CLOEXEC;\n-\n-    fd = ::open(filename.c_str(), open_flags);\n-    if (fd == -1)\n-    {\n-        auto error_code = (errno == ENOENT) ? ErrorCodes::FILE_DOESNT_EXIST : ErrorCodes::CANNOT_OPEN_FILE;\n-        throwFromErrnoWithPath(\"Cannot open file \" + filename, filename, error_code);\n-    }\n-}\n-\n-ReadBufferAIO::~ReadBufferAIO()\n-{\n-    if (!aio_failed)\n-    {\n-        try\n-        {\n-            (void) waitForAIOCompletion();\n-        }\n-        catch (...)\n-        {\n-            tryLogCurrentException(__PRETTY_FUNCTION__);\n-        }\n-    }\n-\n-    if (fd != -1)\n-        ::close(fd);\n-}\n-\n-void ReadBufferAIO::setMaxBytes(size_t max_bytes_read_)\n-{\n-    if (is_started)\n-        throw Exception(\"Illegal attempt to set the maximum number of bytes to read from file \" + filename, ErrorCodes::LOGICAL_ERROR);\n-    max_bytes_read = max_bytes_read_;\n-}\n-\n-bool ReadBufferAIO::nextImpl()\n-{\n-    /// If the end of the file has already been reached by calling this function,\n-    /// then the current call is wrong.\n-    if (is_eof)\n-        return false;\n-\n-    std::optional<Stopwatch> watch;\n-    if (profile_callback)\n-        watch.emplace(clock_type);\n-\n-    if (!is_pending_read)\n-        synchronousRead();\n-    else\n-        receive();\n-\n-    if (profile_callback)\n-    {\n-        ProfileInfo info;\n-        info.bytes_requested = requested_byte_count;\n-        info.bytes_read = bytes_read;\n-        info.nanoseconds = watch->elapsed(); //-V1007\n-        profile_callback(info);\n-    }\n-\n-    is_started = true;\n-\n-    /// If the end of the file is just reached, do nothing else.\n-    if (is_eof)\n-        return bytes_read != 0;\n-\n-    /// Create an asynchronous request.\n-    prepare();\n-\n-#if defined(__FreeBSD__)\n-    request.aio.aio_lio_opcode = LIO_READ;\n-    request.aio.aio_fildes = fd;\n-    request.aio.aio_buf = reinterpret_cast<volatile void *>(buffer_begin);\n-    request.aio.aio_nbytes = region_aligned_size;\n-    request.aio.aio_offset = region_aligned_begin;\n-#else\n-    request.aio_lio_opcode = IOCB_CMD_PREAD;\n-    request.aio_fildes = fd;\n-    request.aio_buf = reinterpret_cast<UInt64>(buffer_begin);\n-    request.aio_nbytes = region_aligned_size;\n-    request.aio_offset = region_aligned_begin;\n-#endif\n-\n-    /// Send the request.\n-    try\n-    {\n-        future_bytes_read = AIOContextPool::instance().post(request);\n-    }\n-    catch (...)\n-    {\n-        aio_failed = true;\n-        throw;\n-    }\n-\n-    is_pending_read = true;\n-    return true;\n-}\n-\n-off_t ReadBufferAIO::seek(off_t off, int whence)\n-{\n-    off_t new_pos_in_file;\n-\n-    if (whence == SEEK_SET)\n-    {\n-        if (off < 0)\n-            throw Exception(\"SEEK_SET underflow\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-        new_pos_in_file = off;\n-    }\n-    else if (whence == SEEK_CUR)\n-    {\n-        if (off >= 0)\n-        {\n-            if (off > (std::numeric_limits<off_t>::max() - getPosition()))\n-                throw Exception(\"SEEK_CUR overflow\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-        }\n-        else if (off < -getPosition())\n-            throw Exception(\"SEEK_CUR underflow\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-        new_pos_in_file = getPosition() + off;\n-    }\n-    else\n-        throw Exception(\"ReadBufferAIO::seek expects SEEK_SET or SEEK_CUR as whence\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-\n-    if (new_pos_in_file != getPosition())\n-    {\n-        off_t first_read_pos_in_file = first_unread_pos_in_file - static_cast<off_t>(working_buffer.size());\n-        if (hasPendingData() && (new_pos_in_file >= first_read_pos_in_file) && (new_pos_in_file <= first_unread_pos_in_file))\n-        {\n-            /// Moved, but remained within the buffer.\n-            pos = working_buffer.begin() + (new_pos_in_file - first_read_pos_in_file);\n-        }\n-        else\n-        {\n-            /// Moved past the buffer.\n-            pos = working_buffer.end();\n-            first_unread_pos_in_file = new_pos_in_file;\n-\n-            /// If we go back, than it's not eof\n-            is_eof = false;\n-\n-            /// We can not use the result of the current asynchronous request.\n-            skip();\n-        }\n-    }\n-\n-    return new_pos_in_file;\n-}\n-\n-void ReadBufferAIO::synchronousRead()\n-{\n-    CurrentMetrics::Increment metric_increment_read{CurrentMetrics::Read};\n-\n-    prepare();\n-    bytes_read = ::pread(fd, buffer_begin, region_aligned_size, region_aligned_begin);\n-\n-    ProfileEvents::increment(ProfileEvents::ReadBufferAIORead);\n-    ProfileEvents::increment(ProfileEvents::ReadBufferAIOReadBytes, bytes_read);\n-\n-    finalize();\n-}\n-\n-void ReadBufferAIO::receive()\n-{\n-    if (!waitForAIOCompletion())\n-    {\n-        throw Exception(\"Trying to receive data from AIO, but nothing was queued. It's a bug\", ErrorCodes::LOGICAL_ERROR);\n-    }\n-    finalize();\n-}\n-\n-void ReadBufferAIO::skip()\n-{\n-    if (!waitForAIOCompletion())\n-        return;\n-\n-    /// @todo I presume this assignment is redundant since waitForAIOCompletion() performs a similar one\n-//    bytes_read = future_bytes_read.get();\n-    if ((bytes_read < 0) || (static_cast<size_t>(bytes_read) < region_left_padding))\n-        throw Exception(\"Asynchronous read error on file \" + filename, ErrorCodes::AIO_READ_ERROR);\n-}\n-\n-bool ReadBufferAIO::waitForAIOCompletion()\n-{\n-    if (is_eof || !is_pending_read)\n-        return false;\n-\n-    CurrentMetrics::Increment metric_increment_read{CurrentMetrics::Read};\n-\n-    bytes_read = future_bytes_read.get();\n-    is_pending_read = false;\n-\n-    ProfileEvents::increment(ProfileEvents::ReadBufferAIORead);\n-    ProfileEvents::increment(ProfileEvents::ReadBufferAIOReadBytes, bytes_read);\n-\n-    return true;\n-}\n-\n-void ReadBufferAIO::prepare()\n-{\n-    requested_byte_count = std::min(fill_buffer.internalBuffer().size() - DEFAULT_AIO_FILE_BLOCK_SIZE, max_bytes_read);\n-\n-    /// Region of the disk from which we want to read data.\n-    const off_t region_begin = first_unread_pos_in_file;\n-\n-    if ((requested_byte_count > static_cast<size_t>(std::numeric_limits<off_t>::max())) ||\n-        (first_unread_pos_in_file > (std::numeric_limits<off_t>::max() - static_cast<off_t>(requested_byte_count))))\n-        throw Exception(\"An overflow occurred during file operation\", ErrorCodes::LOGICAL_ERROR);\n-\n-    const off_t region_end = first_unread_pos_in_file + requested_byte_count;\n-\n-    /// The aligned region of the disk from which we will read the data.\n-    region_left_padding = region_begin % DEFAULT_AIO_FILE_BLOCK_SIZE;\n-    const size_t region_right_padding = (DEFAULT_AIO_FILE_BLOCK_SIZE - (region_end % DEFAULT_AIO_FILE_BLOCK_SIZE)) % DEFAULT_AIO_FILE_BLOCK_SIZE;\n-\n-    region_aligned_begin = region_begin - region_left_padding;\n-\n-    if (region_end > (std::numeric_limits<off_t>::max() - static_cast<off_t>(region_right_padding)))\n-        throw Exception(\"An overflow occurred during file operation\", ErrorCodes::LOGICAL_ERROR);\n-\n-    const off_t region_aligned_end = region_end + region_right_padding;\n-    region_aligned_size = region_aligned_end - region_aligned_begin;\n-\n-    buffer_begin = fill_buffer.internalBuffer().begin();\n-\n-    /// Unpoison because msan doesn't instrument linux AIO\n-    __msan_unpoison(buffer_begin, fill_buffer.internalBuffer().size());\n-}\n-\n-void ReadBufferAIO::finalize()\n-{\n-    if ((bytes_read < 0) || (static_cast<size_t>(bytes_read) < region_left_padding))\n-        throw Exception(\"Asynchronous read error on file \" + filename, ErrorCodes::AIO_READ_ERROR);\n-\n-    /// Ignore redundant bytes on the left.\n-    bytes_read -= region_left_padding;\n-\n-    /// Ignore redundant bytes on the right.\n-    bytes_read = std::min(static_cast<off_t>(bytes_read), static_cast<off_t>(requested_byte_count));\n-\n-    if (bytes_read > 0)\n-        fill_buffer.buffer().resize(region_left_padding + bytes_read);\n-    if (static_cast<size_t>(bytes_read) < requested_byte_count)\n-        is_eof = true;\n-\n-    if (first_unread_pos_in_file > (std::numeric_limits<off_t>::max() - bytes_read))\n-        throw Exception(\"An overflow occurred during file operation\", ErrorCodes::LOGICAL_ERROR);\n-\n-    first_unread_pos_in_file += bytes_read;\n-    total_bytes_read += bytes_read;\n-    nextimpl_working_buffer_offset = region_left_padding;\n-\n-    if (total_bytes_read == max_bytes_read)\n-        is_eof = true;\n-\n-    /// Swap the main and duplicate buffers.\n-    swap(fill_buffer);\n-}\n-\n-}\n-\n-#endif\ndiff --git a/src/IO/ReadBufferAIO.h b/src/IO/ReadBufferAIO.h\ndeleted file mode 100644\nindex d476865747db..000000000000\n--- a/src/IO/ReadBufferAIO.h\n+++ /dev/null\n@@ -1,111 +0,0 @@\n-#pragma once\n-\n-#if defined(OS_LINUX) || defined(__FreeBSD__)\n-\n-#include <IO/ReadBufferFromFileBase.h>\n-#include <IO/ReadBuffer.h>\n-#include <IO/BufferWithOwnMemory.h>\n-#include <IO/AIO.h>\n-#include <Core/Defines.h>\n-#include <Common/CurrentMetrics.h>\n-#include <string>\n-#include <limits>\n-#include <future>\n-#include <unistd.h>\n-#include <fcntl.h>\n-\n-\n-namespace CurrentMetrics\n-{\n-    extern const Metric OpenFileForRead;\n-}\n-\n-namespace DB\n-{\n-\n-/** Class for asynchronous data reading.\n-  */\n-class ReadBufferAIO final : public ReadBufferFromFileBase\n-{\n-public:\n-    ReadBufferAIO(const std::string & filename_, size_t buffer_size_ = DBMS_DEFAULT_BUFFER_SIZE, int flags_ = -1,\n-        char * existing_memory_ = nullptr);\n-    ~ReadBufferAIO() override;\n-\n-    ReadBufferAIO(const ReadBufferAIO &) = delete;\n-    ReadBufferAIO & operator=(const ReadBufferAIO &) = delete;\n-\n-    void setMaxBytes(size_t max_bytes_read_);\n-    off_t getPosition() override { return first_unread_pos_in_file - (working_buffer.end() - pos); }\n-    std::string getFileName() const override { return filename; }\n-    int getFD() const { return fd; }\n-\n-    off_t seek(off_t off, int whence) override;\n-\n-private:\n-    ///\n-    bool nextImpl() override;\n-    /// Synchronously read the data.\n-    void synchronousRead();\n-    /// Get data from an asynchronous request.\n-    void receive();\n-    /// Ignore data from an asynchronous request.\n-    void skip();\n-    /// Wait for the end of the current asynchronous task.\n-    bool waitForAIOCompletion();\n-    /// Prepare the request.\n-    void prepare();\n-    /// Prepare for reading a duplicate buffer containing data from\n-    /// of the last request.\n-    void finalize();\n-\n-private:\n-    /// Buffer for asynchronous data read operations.\n-    BufferWithOwnMemory<ReadBuffer> fill_buffer;\n-\n-    /// Description of the asynchronous read request.\n-    iocb request{};\n-    std::future<ssize_t> future_bytes_read;\n-\n-    const std::string filename;\n-\n-    /// The maximum number of bytes that can be read.\n-    size_t max_bytes_read = std::numeric_limits<size_t>::max();\n-    /// Number of bytes requested.\n-    size_t requested_byte_count = 0;\n-    /// The number of bytes read at the last request.\n-    ssize_t bytes_read = 0;\n-    /// The total number of bytes read.\n-    size_t total_bytes_read = 0;\n-\n-    /// The position of the first unread byte in the file.\n-    off_t first_unread_pos_in_file = 0;\n-\n-    /// The starting position of the aligned region of the disk from which the data is read.\n-    off_t region_aligned_begin = 0;\n-    /// Left offset to align the region of the disk.\n-    size_t region_left_padding = 0;\n-    /// The size of the aligned region of the disk.\n-    size_t region_aligned_size = 0;\n-\n-    /// The file descriptor for read.\n-    int fd = -1;\n-\n-    /// The buffer to which the received data is written.\n-    Position buffer_begin = nullptr;\n-\n-    /// The asynchronous read operation is not yet completed.\n-    bool is_pending_read = false;\n-    /// The end of the file is reached.\n-    bool is_eof = false;\n-    /// At least one read request was sent.\n-    bool is_started = false;\n-    /// Did the asynchronous operation fail?\n-    bool aio_failed = false;\n-\n-    CurrentMetrics::Increment metric_increment{CurrentMetrics::OpenFileForRead};\n-};\n-\n-}\n-\n-#endif\ndiff --git a/src/IO/ReadBufferFromFileDescriptor.cpp b/src/IO/ReadBufferFromFileDescriptor.cpp\nindex 893c2bcb5d8c..c3b7f33f533c 100644\n--- a/src/IO/ReadBufferFromFileDescriptor.cpp\n+++ b/src/IO/ReadBufferFromFileDescriptor.cpp\n@@ -128,8 +128,8 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)\n     if (new_pos + (working_buffer.end() - pos) == file_offset_of_buffer_end)\n         return new_pos;\n \n-    // file_offset_of_buffer_end corresponds to working_buffer.end(); it's a past-the-end pos,\n-    // so the second inequality is strict.\n+    /// file_offset_of_buffer_end corresponds to working_buffer.end(); it's a past-the-end pos,\n+    /// so the second inequality is strict.\n     if (file_offset_of_buffer_end - working_buffer.size() <= static_cast<size_t>(new_pos)\n         && new_pos < file_offset_of_buffer_end)\n     {\n@@ -142,19 +142,29 @@ off_t ReadBufferFromFileDescriptor::seek(off_t offset, int whence)\n     }\n     else\n     {\n+        size_t seek_pos = required_alignment > 1\n+            ? new_pos / required_alignment * required_alignment\n+            : new_pos;\n+\n+        size_t offset_after_seek_pos = new_pos - seek_pos;\n+\n         ProfileEvents::increment(ProfileEvents::Seek);\n         Stopwatch watch(profile_callback ? clock_type : CLOCK_MONOTONIC);\n \n         pos = working_buffer.end();\n-        off_t res = ::lseek(fd, new_pos, SEEK_SET);\n+        off_t res = ::lseek(fd, seek_pos, SEEK_SET);\n         if (-1 == res)\n             throwFromErrnoWithPath(\"Cannot seek through file \" + getFileName(), getFileName(),\n                 ErrorCodes::CANNOT_SEEK_THROUGH_FILE);\n-        file_offset_of_buffer_end = new_pos;\n \n         watch.stop();\n         ProfileEvents::increment(ProfileEvents::DiskReadElapsedMicroseconds, watch.elapsedMicroseconds());\n \n+        file_offset_of_buffer_end = seek_pos;\n+\n+        if (offset_after_seek_pos > 0)\n+            ignore(offset_after_seek_pos);\n+\n         return res;\n     }\n }\ndiff --git a/src/IO/ReadBufferFromFileDescriptor.h b/src/IO/ReadBufferFromFileDescriptor.h\nindex 1883c6802bc7..5a79193445ea 100644\n--- a/src/IO/ReadBufferFromFileDescriptor.h\n+++ b/src/IO/ReadBufferFromFileDescriptor.h\n@@ -14,8 +14,9 @@ namespace DB\n class ReadBufferFromFileDescriptor : public ReadBufferFromFileBase\n {\n protected:\n+    const size_t required_alignment = 0;    /// For O_DIRECT both file offsets and memory addresses have to be aligned.\n+    size_t file_offset_of_buffer_end = 0;       /// What offset in file corresponds to working_buffer.end().\n     int fd;\n-    size_t file_offset_of_buffer_end; /// What offset in file corresponds to working_buffer.end().\n \n     bool nextImpl() override;\n \n@@ -24,7 +25,7 @@ class ReadBufferFromFileDescriptor : public ReadBufferFromFileBase\n \n public:\n     ReadBufferFromFileDescriptor(int fd_, size_t buf_size = DBMS_DEFAULT_BUFFER_SIZE, char * existing_memory = nullptr, size_t alignment = 0)\n-        : ReadBufferFromFileBase(buf_size, existing_memory, alignment), fd(fd_), file_offset_of_buffer_end(0) {}\n+        : ReadBufferFromFileBase(buf_size, existing_memory, alignment), required_alignment(alignment), fd(fd_) {}\n \n     int getFD() const\n     {\ndiff --git a/src/IO/createReadBufferFromFileBase.cpp b/src/IO/createReadBufferFromFileBase.cpp\nindex 230f049b2cba..11a0937ee48f 100644\n--- a/src/IO/createReadBufferFromFileBase.cpp\n+++ b/src/IO/createReadBufferFromFileBase.cpp\n@@ -1,8 +1,5 @@\n #include <IO/createReadBufferFromFileBase.h>\n #include <IO/ReadBufferFromFile.h>\n-#if defined(OS_LINUX) || defined(__FreeBSD__)\n-#include <IO/ReadBufferAIO.h>\n-#endif\n #include <IO/MMapReadBufferFromFileWithCache.h>\n #include <Common/ProfileEvents.h>\n \n@@ -10,8 +7,8 @@\n namespace ProfileEvents\n {\n     extern const Event CreatedReadBufferOrdinary;\n-    extern const Event CreatedReadBufferAIO;\n-    extern const Event CreatedReadBufferAIOFailed;\n+    extern const Event CreatedReadBufferDirectIO;\n+    extern const Event CreatedReadBufferDirectIOFailed;\n     extern const Event CreatedReadBufferMMap;\n     extern const Event CreatedReadBufferMMapFailed;\n }\n@@ -20,48 +17,82 @@ namespace DB\n {\n \n std::unique_ptr<ReadBufferFromFileBase> createReadBufferFromFileBase(\n-    const std::string & filename_,\n-    size_t estimated_size, size_t aio_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,\n-    size_t buffer_size_, int flags_, char * existing_memory_, size_t alignment)\n+    const std::string & filename,\n+    size_t estimated_size, size_t direct_io_threshold, size_t mmap_threshold, MMappedFileCache * mmap_cache,\n+    size_t buffer_size, int flags, char * existing_memory, size_t alignment)\n {\n-#if defined(OS_LINUX) || defined(__FreeBSD__)\n-    if (aio_threshold && estimated_size >= aio_threshold)\n+    if (!existing_memory && mmap_threshold && mmap_cache && estimated_size >= mmap_threshold)\n     {\n-        /// Attempt to open a file with O_DIRECT\n         try\n         {\n-            auto res = std::make_unique<ReadBufferAIO>(filename_, buffer_size_, flags_, existing_memory_);\n-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferAIO);\n+            auto res = std::make_unique<MMapReadBufferFromFileWithCache>(*mmap_cache, filename, 0);\n+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMap);\n             return res;\n         }\n         catch (const ErrnoException &)\n         {\n-            /// Fallback to cached IO if O_DIRECT is not supported.\n-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferAIOFailed);\n+            /// Fallback if mmap is not supported (example: pipe).\n+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMapFailed);\n         }\n     }\n-#else\n-    (void)aio_threshold;\n-    (void)estimated_size;\n-#endif\n \n-    if (!existing_memory_ && mmap_threshold && mmap_cache && estimated_size >= mmap_threshold)\n+#if defined(OS_LINUX) || defined(__FreeBSD__)\n+    if (direct_io_threshold && estimated_size >= direct_io_threshold)\n     {\n+        /** O_DIRECT\n+          * The O_DIRECT flag may impose alignment restrictions on the length and address of user-space buffers and the file offset of I/Os.\n+          * In Linux alignment restrictions vary by filesystem and kernel version and might be absent entirely.\n+          * However there is currently no filesystem-independent interface for an application to discover these restrictions\n+          * for a given file or filesystem. Some filesystems provide their own interfaces for doing so, for example the\n+          * XFS_IOC_DIOINFO operation in xfsctl(3).\n+          *\n+          * Under Linux 2.4, transfer sizes, and the alignment of the user buffer and the file offset must all be\n+          * multiples of the logical block size of the filesystem. Since Linux 2.6.0, alignment to the logical block size\n+          * of the underlying storage (typically 512 bytes) suffices.\n+          *\n+          * - man 2 open\n+          */\n+        constexpr size_t min_alignment = DEFAULT_AIO_FILE_BLOCK_SIZE;\n+\n+        auto align_up = [=](size_t value) { return (value + min_alignment - 1) / min_alignment * min_alignment; };\n+\n+        if (alignment == 0)\n+            alignment = min_alignment;\n+        else if (alignment % min_alignment)\n+            alignment = align_up(alignment);\n+\n+        if (buffer_size % min_alignment)\n+        {\n+            existing_memory = nullptr;  /// Cannot reuse existing memory is it has unaligned size.\n+            buffer_size = align_up(buffer_size);\n+        }\n+\n+        if (reinterpret_cast<uintptr_t>(existing_memory) % min_alignment)\n+        {\n+            existing_memory = nullptr;  /// Cannot reuse existing memory is it has unaligned offset.\n+        }\n+\n+        /// Attempt to open a file with O_DIRECT\n         try\n         {\n-            auto res = std::make_unique<MMapReadBufferFromFileWithCache>(*mmap_cache, filename_, 0);\n-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMap);\n+            auto res = std::make_unique<ReadBufferFromFile>(\n+                filename, buffer_size, (flags == -1 ? O_RDONLY | O_CLOEXEC : flags) | O_DIRECT, existing_memory, alignment);\n+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferDirectIO);\n             return res;\n         }\n         catch (const ErrnoException &)\n         {\n-            /// Fallback if mmap is not supported (example: pipe).\n-            ProfileEvents::increment(ProfileEvents::CreatedReadBufferMMapFailed);\n+            /// Fallback to cached IO if O_DIRECT is not supported.\n+            ProfileEvents::increment(ProfileEvents::CreatedReadBufferDirectIOFailed);\n         }\n     }\n+#else\n+    (void)direct_io_threshold;\n+    (void)estimated_size;\n+#endif\n \n     ProfileEvents::increment(ProfileEvents::CreatedReadBufferOrdinary);\n-    return std::make_unique<ReadBufferFromFile>(filename_, buffer_size_, flags_, existing_memory_, alignment);\n+    return std::make_unique<ReadBufferFromFile>(filename, buffer_size, flags, existing_memory, alignment);\n }\n \n }\ndiff --git a/src/IO/createReadBufferFromFileBase.h b/src/IO/createReadBufferFromFileBase.h\nindex 46d5b39ea449..dc2912ea7528 100644\n--- a/src/IO/createReadBufferFromFileBase.h\n+++ b/src/IO/createReadBufferFromFileBase.h\n@@ -13,20 +13,20 @@ class MMappedFileCache;\n \n /** Create an object to read data from a file.\n   * estimated_size - the number of bytes to read\n-  * aio_threshold - the minimum number of bytes for asynchronous reads\n+  * direct_io_threshold - the minimum number of bytes for asynchronous reads\n   *\n-  * If aio_threshold = 0 or estimated_size < aio_threshold, read operations are executed synchronously.\n+  * If direct_io_threshold = 0 or estimated_size < direct_io_threshold, read operations are executed synchronously.\n   * Otherwise, the read operations are performed asynchronously.\n   */\n std::unique_ptr<ReadBufferFromFileBase> createReadBufferFromFileBase(\n-    const std::string & filename_,\n+    const std::string & filename,\n     size_t estimated_size,\n-    size_t aio_threshold,\n+    size_t direct_io_threshold,\n     size_t mmap_threshold,\n     MMappedFileCache * mmap_cache,\n-    size_t buffer_size_ = DBMS_DEFAULT_BUFFER_SIZE,\n+    size_t buffer_size = DBMS_DEFAULT_BUFFER_SIZE,\n     int flags_ = -1,\n-    char * existing_memory_ = nullptr,\n+    char * existing_memory = nullptr,\n     size_t alignment = 0);\n \n }\ndiff --git a/src/IO/examples/CMakeLists.txt b/src/IO/examples/CMakeLists.txt\nindex bcd0a8bba241..d5907bf67ad9 100644\n--- a/src/IO/examples/CMakeLists.txt\n+++ b/src/IO/examples/CMakeLists.txt\n@@ -49,11 +49,6 @@ target_link_libraries (io_operators PRIVATE clickhouse_common_io)\n add_executable (write_int write_int.cpp)\n target_link_libraries (write_int PRIVATE clickhouse_common_io)\n \n-if (OS_LINUX OR OS_FREEBSD)\n-    add_executable(read_buffer_aio read_buffer_aio.cpp)\n-    target_link_libraries (read_buffer_aio PRIVATE clickhouse_common_io)\n-endif ()\n-\n add_executable (zlib_buffers zlib_buffers.cpp)\n target_link_libraries (zlib_buffers PRIVATE clickhouse_common_io)\n \ndiff --git a/src/IO/examples/read_buffer_aio.cpp b/src/IO/examples/read_buffer_aio.cpp\ndeleted file mode 100644\nindex 01ac9808cbb6..000000000000\n--- a/src/IO/examples/read_buffer_aio.cpp\n+++ /dev/null\n@@ -1,670 +0,0 @@\n-#include <IO/ReadBufferAIO.h>\n-#include <Core/Defines.h>\n-#include <filesystem>\n-#include <vector>\n-#include <iostream>\n-#include <fstream>\n-#include <functional>\n-#include <cstdlib>\n-#include <unistd.h>\n-\n-\n-namespace\n-{\n-\n-void run();\n-void prepare(std::string & filename, std::string & buf);\n-void prepare2(std::string & filename, std::string & buf);\n-void prepare3(std::string & filename, std::string & buf);\n-void prepare4(std::string & filename, std::string & buf);\n-std::string createTmpFile();\n-[[noreturn]] void die(const std::string & msg);\n-void runTest(unsigned int num, const std::function<bool()> & func);\n-\n-bool test1(const std::string & filename);\n-bool test2(const std::string & filename, const std::string & buf);\n-bool test3(const std::string & filename, const std::string & buf);\n-bool test4(const std::string & filename, const std::string & buf);\n-bool test5(const std::string & filename, const std::string & buf);\n-bool test6(const std::string & filename, const std::string & buf);\n-bool test7(const std::string & filename, const std::string & buf);\n-bool test8(const std::string & filename, const std::string & buf);\n-bool test9(const std::string & filename, const std::string & buf);\n-bool test10(const std::string & filename, const std::string & buf);\n-bool test11(const std::string & filename);\n-bool test12(const std::string & filename, const std::string & buf);\n-bool test13(const std::string & filename, const std::string & buf);\n-bool test14(const std::string & filename, const std::string & buf);\n-bool test15(const std::string & filename, const std::string & buf);\n-bool test16(const std::string & filename, const std::string & buf);\n-bool test17(const std::string & filename, const std::string & buf);\n-bool test18(const std::string & filename, const std::string & buf);\n-bool test19(const std::string & filename, const std::string & buf);\n-bool test20(const std::string & filename, const std::string & buf);\n-\n-void run()\n-{\n-    namespace fs = std::filesystem;\n-\n-    std::string filename;\n-    std::string buf;\n-    prepare(filename, buf);\n-\n-    std::string filename2;\n-    std::string buf2;\n-    prepare(filename2, buf2);\n-\n-    std::string filename3;\n-    std::string buf3;\n-    prepare2(filename3, buf3);\n-\n-    std::string filename4;\n-    std::string buf4;\n-    prepare3(filename4, buf4);\n-\n-    std::string filename5;\n-    std::string buf5;\n-    prepare4(filename5, buf5);\n-\n-    const std::vector<std::function<bool()>> tests =\n-    {\n-        [&]{ return test1(filename); },\n-        [&]{ return test2(filename, buf); },\n-        [&]{ return test3(filename, buf); },\n-        [&]{ return test4(filename, buf); },\n-        [&]{ return test5(filename, buf); },\n-        [&]{ return test6(filename, buf); },\n-        [&]{ return test7(filename, buf); },\n-        [&]{ return test8(filename, buf); },\n-        [&]{ return test9(filename, buf); },\n-        [&]{ return test10(filename, buf); },\n-        [&]{ return test11(filename); },\n-        [&]{ return test12(filename, buf); },\n-        [&]{ return test13(filename2, buf2); },\n-        [&]{ return test14(filename, buf); },\n-        [&]{ return test15(filename3, buf3); },\n-        [&]{ return test16(filename3, buf3); },\n-        [&]{ return test17(filename4, buf4); },\n-        [&]{ return test18(filename5, buf5); },\n-        [&]{ return test19(filename, buf); },\n-        [&]{ return test20(filename, buf); }\n-    };\n-\n-    unsigned int num = 0;\n-    for (const auto & test : tests)\n-    {\n-        ++num;\n-        runTest(num, test);\n-    }\n-\n-    fs::remove_all(fs::path(filename).parent_path().string());\n-    fs::remove_all(fs::path(filename2).parent_path().string());\n-    fs::remove_all(fs::path(filename3).parent_path().string());\n-    fs::remove_all(fs::path(filename4).parent_path().string());\n-    fs::remove_all(fs::path(filename5).parent_path().string());\n-}\n-\n-void prepare(std::string & filename, std::string & buf)\n-{\n-    static const std::string symbols = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-    filename = createTmpFile();\n-\n-    size_t n = 10 * DEFAULT_AIO_FILE_BLOCK_SIZE;\n-    buf.reserve(n);\n-\n-    for (size_t i = 0; i < n; ++i)\n-        buf += symbols[i % symbols.length()];\n-\n-    std::ofstream out(filename.c_str());\n-    if (!out.is_open())\n-        die(\"Could not open file\");\n-\n-    out << buf;\n-}\n-\n-void prepare2(std::string & filename, std::string & buf)\n-{\n-    filename = createTmpFile();\n-\n-    buf = \"122333444455555666666777777788888888999999999\";\n-\n-    std::ofstream out(filename.c_str());\n-    if (!out.is_open())\n-        die(\"Could not open file\");\n-\n-    out << buf;\n-}\n-\n-void prepare3(std::string & filename, std::string & buf)\n-{\n-    filename = createTmpFile();\n-\n-    buf = \"122333444455555666666777777788888888999999999\";\n-\n-    std::ofstream out(filename.c_str());\n-    if (!out.is_open())\n-        die(\"Could not open file\");\n-\n-    out.seekp(7, std::ios_base::beg);\n-    out << buf;\n-}\n-\n-void prepare4(std::string & filename, std::string & buf)\n-{\n-    static const std::string symbols = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-    filename = createTmpFile();\n-\n-    std::ofstream out(filename.c_str());\n-    if (!out.is_open())\n-        die(\"Could not open file\");\n-\n-    for (size_t i = 0; i < 1340; ++i)\n-        buf += symbols[i % symbols.length()];\n-\n-    out.seekp(2984, std::ios_base::beg);\n-    out << buf;\n-}\n-\n-std::string createTmpFile()\n-{\n-    char pattern[] = \"/tmp/fileXXXXXX\";\n-    char * dir = ::mkdtemp(pattern);\n-    if (dir == nullptr)\n-        die(\"Could not create directory\");\n-\n-    return std::string(dir) + \"/foo\";\n-}\n-\n-void die(const std::string & msg)\n-{\n-    std::cout << msg << \"\\n\";\n-    ::exit(EXIT_FAILURE);\n-}\n-\n-void runTest(unsigned int num, const std::function<bool()> & func)\n-{\n-    bool ok;\n-\n-    try\n-    {\n-        ok = func();\n-    }\n-    catch (const DB::Exception & ex)\n-    {\n-        ok = false;\n-        std::cout << \"Caught exception \" << ex.displayText() << \"\\n\";\n-    }\n-    catch (const std::exception & ex)\n-    {\n-        ok = false;\n-        std::cout << \"Caught exception \" << ex.what() << \"\\n\";\n-    }\n-\n-    if (ok)\n-        std::cout << \"Test \" << num << \" passed\\n\";\n-    else\n-        std::cout << \"Test \" << num << \" failed\\n\";\n-}\n-\n-bool test1(const std::string & filename)\n-{\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    if (in.getFileName() != filename)\n-        return false;\n-    if (in.getFD() == -1)\n-        return false;\n-    return true;\n-}\n-\n-bool test2(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(buf.length());\n-\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-    if (count != newbuf.length())\n-        return false;\n-\n-    return (newbuf == buf);\n-}\n-\n-bool test3(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(buf.length());\n-\n-    size_t requested = 9 * DEFAULT_AIO_FILE_BLOCK_SIZE;\n-\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    in.setMaxBytes(requested);\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-\n-    newbuf.resize(count);\n-    return (newbuf == buf.substr(0, requested));\n-}\n-\n-bool test4(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(buf.length());\n-\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    in.setMaxBytes(0);\n-    size_t n_read = in.read(newbuf.data(), newbuf.length());\n-\n-    return n_read == 0;\n-}\n-\n-bool test5(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(1 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));\n-\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    in.setMaxBytes(1 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));\n-\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-    if (count != newbuf.length())\n-        return false;\n-\n-    if (newbuf != buf.substr(0, newbuf.length()))\n-        return false;\n-\n-    return true;\n-}\n-\n-bool test6(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(buf.length());\n-\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    if (in.getPosition() != 0)\n-        return false;\n-\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-    if (count != newbuf.length())\n-        return false;\n-\n-    if (static_cast<size_t>(in.getPosition()) != buf.length())\n-        return false;\n-\n-    return true;\n-}\n-\n-bool test7(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(buf.length() - DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    (void) in.seek(DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_SET);\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-    if (count != (9 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-        return false;\n-\n-    return (newbuf == buf.substr(DEFAULT_AIO_FILE_BLOCK_SIZE));\n-}\n-\n-bool test8(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(DEFAULT_AIO_FILE_BLOCK_SIZE - 1);\n-\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    (void) in.seek(DEFAULT_AIO_FILE_BLOCK_SIZE + 1, SEEK_CUR);\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-\n-    if (count != newbuf.length())\n-        return false;\n-\n-    if (newbuf != buf.substr(DEFAULT_AIO_FILE_BLOCK_SIZE + 1, newbuf.length()))\n-        return false;\n-\n-    return true;\n-}\n-\n-bool test9(const std::string & filename, const std::string & buf)\n-{\n-    bool ok = false;\n-\n-    try\n-    {\n-        std::string newbuf;\n-        newbuf.resize(buf.length());\n-\n-        DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-        size_t count = in.read(newbuf.data(), newbuf.length());\n-        if (count != newbuf.length())\n-            return false;\n-        in.setMaxBytes(9 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    }\n-    catch (const DB::Exception &)\n-    {\n-        ok = true;\n-    }\n-\n-    return ok;\n-}\n-\n-bool test10(const std::string & filename, const std::string & buf)\n-{\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(4 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        size_t count1 = in.read(newbuf.data(), newbuf.length());\n-        if (count1 != newbuf.length())\n-            return false;\n-\n-        if (newbuf != buf.substr(0, 4 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-            return false;\n-    }\n-\n-    (void) in.seek(2 * DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_CUR);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(4 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        size_t count2 = in.read(newbuf.data(), newbuf.length());\n-        if (count2 != newbuf.length())\n-            return false;\n-\n-        if (newbuf != buf.substr(6 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool test11(const std::string & filename)\n-{\n-    bool ok = false;\n-\n-    try\n-    {\n-        DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-        (void) in.seek(-DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_SET);\n-    }\n-    catch (const DB::Exception &)\n-    {\n-        ok = true;\n-    }\n-\n-    return ok;\n-}\n-\n-bool test12(const std::string & filename, const std::string &)\n-{\n-    bool ok = false;\n-\n-    try\n-    {\n-        std::string newbuf;\n-        newbuf.resize(4 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-        size_t count = in.read(newbuf.data(), newbuf.length());\n-        if (count != newbuf.length())\n-            return false;\n-\n-        (void) in.seek(-(10 * DEFAULT_AIO_FILE_BLOCK_SIZE), SEEK_CUR);\n-    }\n-    catch (const DB::Exception &)\n-    {\n-        ok = true;\n-    }\n-\n-    return ok;\n-}\n-\n-bool test13(const std::string & filename, const std::string &)\n-{\n-    std::string newbuf;\n-    newbuf.resize(2 * DEFAULT_AIO_FILE_BLOCK_SIZE - 3);\n-\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    size_t count1 = in.read(newbuf.data(), newbuf.length());\n-    return count1 == newbuf.length();\n-}\n-\n-bool test14(const std::string & filename, const std::string & buf)\n-{\n-    std::string newbuf;\n-    newbuf.resize(1 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));\n-\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    (void) in.seek(2, SEEK_SET);\n-    in.setMaxBytes(3 + (DEFAULT_AIO_FILE_BLOCK_SIZE >> 1));\n-\n-    size_t count = in.read(newbuf.data(), newbuf.length());\n-    if (count != newbuf.length())\n-        return false;\n-\n-    if (newbuf != buf.substr(2, newbuf.length()))\n-        return false;\n-\n-    return true;\n-}\n-\n-bool test15(const std::string & filename, const std::string &)\n-{\n-    std::string newbuf;\n-    newbuf.resize(1000);\n-\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    size_t count = in.read(newbuf.data(), 1);\n-    if (count != 1)\n-        return false;\n-    if (newbuf[0] != '1')\n-        return false;\n-    return true;\n-}\n-\n-bool test16(const std::string & filename, const std::string &)\n-{\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    size_t count;\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(1);\n-        count = in.read(newbuf.data(), 1);\n-        if (count != 1)\n-            return false;\n-        if (newbuf[0] != '1')\n-            return false;\n-    }\n-\n-    in.seek(2, SEEK_CUR);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(3);\n-        count = in.read(newbuf.data(), 3);\n-        if (count != 3)\n-            return false;\n-        if (newbuf != \"333\")\n-            return false;\n-    }\n-\n-    in.seek(4, SEEK_CUR);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(5);\n-        count = in.read(newbuf.data(), 5);\n-        if (count != 5)\n-            return false;\n-        if (newbuf != \"55555\")\n-            return false;\n-    }\n-\n-    in.seek(6, SEEK_CUR);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(7);\n-        count = in.read(newbuf.data(), 7);\n-        if (count != 7)\n-            return false;\n-        if (newbuf != \"7777777\")\n-            return false;\n-    }\n-\n-    in.seek(8, SEEK_CUR);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(9);\n-        count = in.read(newbuf.data(), 9);\n-        if (count != 9)\n-            return false;\n-        if (newbuf != \"999999999\")\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool test17(const std::string & filename, const std::string & buf)\n-{\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-    size_t count;\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(10);\n-        count = in.read(newbuf.data(), 10);\n-\n-        if (count != 10)\n-            return false;\n-        if (newbuf.substr(0, 7) != std::string(7, '\\0'))\n-            return false;\n-        if (newbuf.substr(7) != \"122\")\n-            return false;\n-    }\n-\n-    in.seek(7 + buf.length() - 2, SEEK_SET);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(160);\n-        count = in.read(newbuf.data(), 160);\n-\n-        if (count != 2)\n-            return false;\n-        if (newbuf.substr(0, 2) != \"99\")\n-            return false;\n-    }\n-\n-    in.seek(7 + buf.length() + DEFAULT_AIO_FILE_BLOCK_SIZE, SEEK_SET);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(50);\n-        count = in.read(newbuf.data(), 50);\n-        if (count != 0)\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool test18(const std::string & filename, const std::string & buf)\n-{\n-    DB::ReadBufferAIO in(filename, DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    std::string newbuf;\n-    newbuf.resize(1340);\n-\n-    in.seek(2984, SEEK_SET);\n-    size_t count = in.read(newbuf.data(), 1340);\n-\n-    if (count != 1340)\n-        return false;\n-    if (newbuf != buf)\n-        return false;\n-\n-    return true;\n-}\n-\n-bool test19(const std::string & filename, const std::string & buf)\n-{\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        size_t count1 = in.read(newbuf.data(), newbuf.length());\n-        if (count1 != newbuf.length())\n-            return false;\n-\n-        if (newbuf != buf.substr(0, 5 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-            return false;\n-    }\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        size_t count2 = in.read(newbuf.data(), newbuf.length());\n-        if (count2 != newbuf.length())\n-            return false;\n-\n-        if (newbuf != buf.substr(5 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-bool test20(const std::string & filename, const std::string & buf)\n-{\n-    DB::ReadBufferAIO in(filename, 3 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        size_t count1 = in.read(newbuf.data(), newbuf.length());\n-        if (count1 != newbuf.length())\n-            return false;\n-\n-        if (newbuf != buf.substr(0, 5 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-            return false;\n-    }\n-\n-    (void) in.getPosition();\n-\n-    {\n-        std::string newbuf;\n-        newbuf.resize(5 * DEFAULT_AIO_FILE_BLOCK_SIZE);\n-\n-        size_t count2 = in.read(newbuf.data(), newbuf.length());\n-        if (count2 != newbuf.length())\n-            return false;\n-\n-        if (newbuf != buf.substr(5 * DEFAULT_AIO_FILE_BLOCK_SIZE))\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-}\n-\n-int main()\n-{\n-    run();\n-    return 0;\n-}\ndiff --git a/src/IO/ya.make b/src/IO/ya.make\nindex d8bdfa95295e..bca108ca4269 100644\n--- a/src/IO/ya.make\n+++ b/src/IO/ya.make\n@@ -44,7 +44,6 @@ SRCS(\n     NullWriteBuffer.cpp\n     PeekableReadBuffer.cpp\n     Progress.cpp\n-    ReadBufferAIO.cpp\n     ReadBufferFromFile.cpp\n     ReadBufferFromFileBase.cpp\n     ReadBufferFromFileDecorator.cpp\ndiff --git a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\nindex f9ed30ed4ed1..a777c244426d 100644\n--- a/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp\n@@ -828,7 +828,7 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataMergerMutator::mergePartsToTempor\n     UInt64 watch_prev_elapsed = 0;\n \n     /// We count total amount of bytes in parts\n-    /// and use direct_io + aio if there is more than min_merge_bytes_to_use_direct_io\n+    /// and use direct_io if there is more than min_merge_bytes_to_use_direct_io\n     bool read_with_direct_io = false;\n     if (data_settings->min_merge_bytes_to_use_direct_io != 0)\n     {\ndiff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\nindex e82b1966461a..2a3c7ed00a1d 100644\n--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n@@ -54,7 +54,7 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(\n \n     MergeTreeReaderSettings reader_settings =\n     {\n-        /// bytes to use AIO (this is hack)\n+        /// bytes to use direct IO (this is hack)\n         .min_bytes_to_use_direct_io = read_with_direct_io ? 1UL : std::numeric_limits<size_t>::max(),\n         .max_read_buffer_size = DBMS_DEFAULT_BUFFER_SIZE,\n         .save_marks_in_cache = false\ndiff --git a/src/Storages/System/StorageSystemStackTrace.cpp b/src/Storages/System/StorageSystemStackTrace.cpp\nindex 8b119492340d..7a8ee75803f4 100644\n--- a/src/Storages/System/StorageSystemStackTrace.cpp\n+++ b/src/Storages/System/StorageSystemStackTrace.cpp\n@@ -223,7 +223,7 @@ void StorageSystemStackTrace::fillData(MutableColumns & res_columns, ContextPtr,\n         {\n             constexpr size_t comm_buf_size = 32; /// More than enough for thread name\n             ReadBufferFromFile comm(thread_name_path.string(), comm_buf_size);\n-            readStringUntilEOF(thread_name, comm);\n+            readEscapedStringUntilEOL(thread_name, comm);\n             comm.close();\n         }\n \n",
  "test_patch": "diff --git a/src/IO/tests/gtest_aio_seek_back_after_eof.cpp b/src/IO/tests/gtest_aio_seek_back_after_eof.cpp\ndeleted file mode 100644\nindex 784f54796573..000000000000\n--- a/src/IO/tests/gtest_aio_seek_back_after_eof.cpp\n+++ /dev/null\n@@ -1,91 +0,0 @@\n-#if defined(__linux__) || defined(__FreeBSD__)\n-\n-#include <gtest/gtest.h>\n-\n-#include <Core/Defines.h>\n-#include <unistd.h>\n-#include <IO/ReadBufferAIO.h>\n-#include <Common/randomSeed.h>\n-#include <filesystem>\n-#include <fstream>\n-#include <string>\n-\n-\n-namespace\n-{\n-std::string createTmpFileForEOFtest()\n-{\n-    char pattern[] = \"./EOFtestFolderXXXXXX\";\n-    if (char * dir = ::mkdtemp(pattern); dir)\n-    {\n-        return std::string(dir) + \"/foo\";\n-    }\n-    else\n-    {\n-        /// We have no tmp in docker\n-        /// So we have to use root\n-        std::string almost_rand_dir = std::string{\"/\"} + std::to_string(randomSeed()) + \"foo\";\n-        return almost_rand_dir;\n-    }\n-\n-}\n-\n-void prepareForEOF(std::string & filename, std::string & buf)\n-{\n-    static const std::string symbols = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-    filename = createTmpFileForEOFtest();\n-\n-    size_t n = 10 * DEFAULT_AIO_FILE_BLOCK_SIZE;\n-    buf.reserve(n);\n-\n-    for (size_t i = 0; i < n; ++i)\n-        buf += symbols[i % symbols.length()];\n-\n-    std::ofstream out(filename);\n-    out << buf;\n-}\n-\n-\n-}\n-TEST(ReadBufferAIOTest, TestReadAfterAIO)\n-{\n-    using namespace DB;\n-    std::string data;\n-    std::string file_path;\n-    prepareForEOF(file_path, data);\n-    ReadBufferAIO testbuf(file_path);\n-\n-    std::string newdata;\n-    newdata.resize(data.length());\n-\n-    size_t total_read = testbuf.read(newdata.data(), newdata.length());\n-    EXPECT_EQ(total_read, data.length());\n-    EXPECT_TRUE(testbuf.eof());\n-\n-\n-    testbuf.seek(data.length() - 100, SEEK_SET);\n-\n-    std::string smalldata;\n-    smalldata.resize(100);\n-    size_t read_after_eof = testbuf.read(smalldata.data(), smalldata.size());\n-    EXPECT_EQ(read_after_eof, 100);\n-    EXPECT_TRUE(testbuf.eof());\n-\n-\n-    testbuf.seek(0, SEEK_SET);\n-    std::string repeatdata;\n-    repeatdata.resize(data.length());\n-    size_t read_after_eof_big = testbuf.read(repeatdata.data(), repeatdata.size());\n-    EXPECT_EQ(read_after_eof_big, data.length());\n-    EXPECT_TRUE(testbuf.eof());\n-\n-    if (file_path[0] != '/')\n-    {\n-        const size_t last_slash = file_path.rfind('/');\n-        const std::string temp_dir = file_path.substr(0, last_slash);\n-        std::filesystem::remove_all(temp_dir);\n-    }\n-}\n-\n-#endif\n",
  "problem_statement": "`min_bytes_to_use_direct_io` works incorrectly for `max_threads` > 1\n**Describe the bug**\r\n\r\nDataset from:\r\nhttps://clickhouse.tech/docs/en/getting-started/example-datasets/metrica/\r\n> Obtaining Tables from Prepared Partitions\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes, it is reproduced on master.\r\n\r\n**How to reproduce**\r\n\r\n```\r\nSET min_bytes_to_use_direct_io = 1, max_threads = 2;\r\n\r\nSELECT sum(cityHash64(*)) FROM test.hits\r\n\r\nSELECT sum(cityHash64(*))\r\nFROM test.hits\r\n\r\nQuery id: 115cee6f-7f66-42e4-a964-cf7b0db39686\r\n\r\n\u2191 Progress: 8.71 million rows, 8.29 GB (2.28 million rows/s., 2.17 GB/s.) \u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b    97%\r\n0 rows in set. Elapsed: 86.030 sec. Processed 8.71 million rows, 8.29 GB (101.24 thousand rows/s., 96.37 MB/s.)\r\n```\r\n\nAdd thread_name in system.stack_trace\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- New Feature\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nAdd `thread_name` column in `system.stack_trace`. This closes #23256.\r\n\r\nDetailed description / Documentation draft:\r\n\r\nadd thread_name column in system.stack_trace\r\nhttps://github.com/ClickHouse/ClickHouse/issues/23256\r\n\r\nBy adding documentation, you'll allow users to try your new feature immediately, not when someone else will have time to document it later. Documentation is necessary for all features that affect user experience in any way. You can add brief documentation draft above, or add documentation right into your patch as Markdown files in [docs](https://github.com/ClickHouse/ClickHouse/tree/master/docs) folder.\r\n\r\nIf you are doing this for the first time, it's recommended to read the lightweight [Contributing to ClickHouse Documentation](https://github.com/ClickHouse/ClickHouse/tree/master/docs/README.md) guide first.\r\n\r\n\r\nInformation about CI checks: https://clickhouse.tech/docs/en/development/continuous-integration/\r\n\n",
  "hints_text": "\nInternal documentation ticket: DOCSUP-9597.",
  "created_at": "2021-07-05T20:05:53Z",
  "modified_files": [
    "src/Common/ProfileEvents.cpp",
    "src/Compression/CompressedReadBufferFromFile.cpp",
    "src/Compression/CompressedReadBufferFromFile.h",
    "src/Dictionaries/SSDCacheDictionaryStorage.h",
    "src/Disks/DiskCacheWrapper.cpp",
    "src/Disks/DiskCacheWrapper.h",
    "src/Disks/DiskDecorator.cpp",
    "src/Disks/DiskDecorator.h",
    "src/Disks/DiskLocal.cpp",
    "src/Disks/DiskLocal.h",
    "src/Disks/DiskMemory.h",
    "src/Disks/DiskRestartProxy.cpp",
    "src/Disks/DiskRestartProxy.h",
    "src/Disks/HDFS/DiskHDFS.h",
    "src/Disks/IDisk.h",
    "src/Disks/S3/DiskS3.h",
    "src/IO/HashingReadBuffer.h",
    "src/IO/ReadBufferAIO.cpp",
    "src/IO/ReadBufferAIO.h",
    "src/IO/ReadBufferFromFileDescriptor.cpp",
    "src/IO/ReadBufferFromFileDescriptor.h",
    "src/IO/createReadBufferFromFileBase.cpp",
    "src/IO/createReadBufferFromFileBase.h",
    "src/IO/examples/CMakeLists.txt",
    "src/IO/examples/read_buffer_aio.cpp",
    "src/IO/ya.make",
    "src/Storages/MergeTree/MergeTreeDataMergerMutator.cpp",
    "src/Storages/MergeTree/MergeTreeSequentialSource.cpp",
    "src/Storages/System/StorageSystemStackTrace.cpp"
  ],
  "modified_test_files": [
    "src/IO/tests/gtest_aio_seek_back_after_eof.cpp"
  ]
}