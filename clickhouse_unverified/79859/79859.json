{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79859,
  "instance_id": "ClickHouse__ClickHouse-79859",
  "issue_numbers": [
    "79792",
    "52253"
  ],
  "base_commit": "8a2b568e12ca73e41bea95a747deb4ff2bfb763e",
  "patch": "diff --git a/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h b/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h\nindex 125b9ca54f30..adee1a6edccd 100644\n--- a/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h\n+++ b/src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h\n@@ -2,11 +2,11 @@\n \n #include <AggregateFunctions/IAggregateFunction.h>\n #include <AggregateFunctions/KeyHolderHelpers.h>\n-#include <Common/assert_cast.h>\n #include <DataTypes/DataTypeArray.h>\n-#include <Common/HashTable/HashSet.h>\n-#include <Common/HashTable/HashMap.h>\n #include <IO/ReadHelpersArena.h>\n+#include <Common/HashTable/HashMap.h>\n+#include <Common/HashTable/HashSet.h>\n+#include <Common/assert_cast.h>\n \n \n namespace DB\n@@ -20,37 +20,39 @@ struct AggregateFunctionDistinctSingleNumericData\n     /// When creating, the hash table must be small.\n     using Set = HashSetWithStackMemory<T, DefaultHash<T>, 4>;\n     using Self = AggregateFunctionDistinctSingleNumericData<T>;\n-    Set set;\n \n-    void add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena *)\n+    /// history will hold all values added so far\n+    Set history;\n+\n+    /// Returns true if the value did not exist in the history before\n+    bool add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena *)\n     {\n         const auto & vec = assert_cast<const ColumnVector<T> &>(*columns[0]).getData();\n-        set.insert(vec[row_num]);\n+        const T value = vec[row_num];\n+        return history.insert(value).second;\n     }\n \n-    void merge(const Self & rhs, Arena *)\n+    /// Pass the new values from rhs to the nested function via argument_columns\n+    void merge(const Self & rhs, MutableColumns & argument_columns, Arena *)\n     {\n-        set.merge(rhs.set);\n+        for (const auto & elem : rhs.history)\n+        {\n+            const auto & value = elem.getValue();\n+            bool inserted = history.insert(value).second;\n+\n+            if (inserted)\n+                argument_columns[0]->insert(value);\n+        }\n     }\n \n     void serialize(WriteBuffer & buf) const\n     {\n-        set.write(buf);\n+        history.write(buf);\n     }\n \n     void deserialize(ReadBuffer & buf, Arena *)\n     {\n-        set.read(buf);\n-    }\n-\n-    MutableColumns getArguments(const DataTypes & argument_types) const\n-    {\n-        MutableColumns argument_columns;\n-        argument_columns.emplace_back(argument_types[0]->createColumn());\n-        for (const auto & elem : set)\n-            argument_columns[0]->insert(elem.getValue());\n-\n-        return argument_columns;\n+        history.read(buf);\n     }\n };\n \n@@ -59,20 +61,13 @@ struct AggregateFunctionDistinctGenericData\n     /// When creating, the hash table must be small.\n     using Set = HashSetWithSavedHashWithStackMemory<StringRef, StringRefHash, 4>;\n     using Self = AggregateFunctionDistinctGenericData;\n-    Set set;\n \n-    void merge(const Self & rhs, Arena * arena)\n-    {\n-        Set::LookupResult it;\n-        bool inserted;\n-        for (const auto & elem : rhs.set)\n-            set.emplace(ArenaKeyHolder{elem.getValue(), *arena}, it, inserted);\n-    }\n+    Set history;\n \n     void serialize(WriteBuffer & buf) const\n     {\n-        writeVarUInt(set.size(), buf);\n-        for (const auto & elem : set)\n+        writeVarUInt(history.size(), buf);\n+        for (const auto & elem : history)\n             writeStringBinary(elem.getValue(), buf);\n     }\n \n@@ -81,35 +76,41 @@ struct AggregateFunctionDistinctGenericData\n         size_t size;\n         readVarUInt(size, buf);\n         for (size_t i = 0; i < size; ++i)\n-            set.insert(readStringBinaryInto(*arena, buf));\n+            history.insert(readStringBinaryInto(*arena, buf));\n     }\n };\n \n template <bool is_plain_column>\n struct AggregateFunctionDistinctSingleGenericData : public AggregateFunctionDistinctGenericData\n {\n-    void add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena * arena)\n+    bool add(const IColumn ** columns, size_t /* columns_num */, size_t row_num, Arena * arena)\n     {\n+        auto key_holder = getKeyHolder<is_plain_column>(*columns[0], row_num, *arena);\n         Set::LookupResult it;\n         bool inserted;\n-        auto key_holder = getKeyHolder<is_plain_column>(*columns[0], row_num, *arena);\n-        set.emplace(key_holder, it, inserted);\n+        history.emplace(key_holder, it, inserted);\n+\n+        return inserted;\n     }\n \n-    MutableColumns getArguments(const DataTypes & argument_types) const\n+    void merge(const Self & rhs, MutableColumns & argument_columns, Arena * arena)\n     {\n-        MutableColumns argument_columns;\n-        argument_columns.emplace_back(argument_types[0]->createColumn());\n-        for (const auto & elem : set)\n-            deserializeAndInsert<is_plain_column>(elem.getValue(), *argument_columns[0]);\n+        for (const auto & elem : rhs.history)\n+        {\n+            const auto & value = elem.getValue();\n+            Set::LookupResult it;\n+            bool inserted;\n+            history.emplace(ArenaKeyHolder{value, *arena}, it, inserted);\n \n-        return argument_columns;\n+            if (inserted)\n+                deserializeAndInsert<is_plain_column>(it->getValue(), *argument_columns[0]);\n+        }\n     }\n };\n \n struct AggregateFunctionDistinctMultipleGenericData : public AggregateFunctionDistinctGenericData\n {\n-    void add(const IColumn ** columns, size_t columns_num, size_t row_num, Arena * arena)\n+    bool add(const IColumn ** columns, size_t columns_num, size_t row_num, Arena * arena)\n     {\n         const char * begin = nullptr;\n         StringRef value(begin, 0);\n@@ -122,24 +123,26 @@ struct AggregateFunctionDistinctMultipleGenericData : public AggregateFunctionDi\n \n         Set::LookupResult it;\n         bool inserted;\n-        auto key_holder = SerializedKeyHolder{value, *arena};\n-        set.emplace(key_holder, it, inserted);\n+        history.emplace(SerializedKeyHolder{value, *arena}, it, inserted);\n+\n+        return inserted;\n     }\n \n-    MutableColumns getArguments(const DataTypes & argument_types) const\n+    void merge(const Self & rhs, MutableColumns & argument_columns, Arena * arena)\n     {\n-        MutableColumns argument_columns(argument_types.size());\n-        for (size_t i = 0; i < argument_types.size(); ++i)\n-            argument_columns[i] = argument_types[i]->createColumn();\n-\n-        for (const auto & elem : set)\n+        for (const auto & elem : rhs.history)\n         {\n-            const char * begin = elem.getValue().data;\n-            for (auto & column : argument_columns)\n-                begin = column->deserializeAndInsertFromArena(begin);\n+            const auto & value = elem.getValue();\n+            if (!history.contains(value))\n+            {\n+                Set::LookupResult it;\n+                bool inserted;\n+                history.emplace(ArenaKeyHolder{value, *arena}, it, inserted);\n+                const char * pos = it->getValue().data;\n+                for (auto & column : argument_columns)\n+                    pos = column->deserializeAndInsertFromArena(pos);\n+            }\n         }\n-\n-        return argument_columns;\n     }\n };\n \n@@ -164,6 +167,31 @@ class AggregateFunctionDistinct final : public IAggregateFunctionDataHelper<Data\n         return place + prefix_size;\n     }\n \n+    MutableColumns prepareArgumentColumns() const\n+    {\n+        MutableColumns argument_columns;\n+        argument_columns.reserve(this->argument_types.size());\n+        for (const auto & type : this->argument_types)\n+            argument_columns.emplace_back(type->createColumn());\n+\n+        return argument_columns;\n+    }\n+\n+    void addToNested(size_t row_begin, size_t row_end, AggregateDataPtr __restrict place, const IColumn ** columns, Arena * arena) const\n+    {\n+        nested_func->addBatchSinglePlace(row_begin, row_end, getNestedPlace(place), columns, arena);\n+    }\n+\n+    void addToNested(AggregateDataPtr __restrict place, const MutableColumns & argument_columns, Arena * arena) const\n+    {\n+        ColumnRawPtrs arguments_raw(argument_columns.size());\n+        for (size_t i = 0; i < argument_columns.size(); ++i)\n+            arguments_raw[i] = argument_columns[i].get();\n+\n+        assert(!argument_columns.empty());\n+        addToNested(0, argument_columns[0]->size(), place, arguments_raw.data(), arena);\n+    }\n+\n public:\n     AggregateFunctionDistinct(AggregateFunctionPtr nested_func_, const DataTypes & arguments, const Array & params_)\n     : IAggregateFunctionDataHelper<Data, AggregateFunctionDistinct>(arguments, params_, nested_func_->getResultType())\n@@ -176,12 +204,16 @@ class AggregateFunctionDistinct final : public IAggregateFunctionDataHelper<Data\n \n     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena * arena) const override\n     {\n-        this->data(place).add(columns, arguments_num, row_num, arena);\n+        bool added = this->data(place).add(columns, arguments_num, row_num, arena);\n+        if (added)\n+            addToNested(row_num, row_num + 1, place, columns, arena);\n     }\n \n     void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena * arena) const override\n     {\n-        this->data(place).merge(this->data(rhs), arena);\n+        auto argument_columns = prepareArgumentColumns();\n+        this->data(place).merge(this->data(rhs), argument_columns, arena);\n+        addToNested(place, argument_columns, arena);\n     }\n \n     void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override\n@@ -194,30 +226,14 @@ class AggregateFunctionDistinct final : public IAggregateFunctionDataHelper<Data\n         this->data(place).deserialize(buf, arena);\n     }\n \n-    template <bool MergeResult>\n-    void insertResultIntoImpl(AggregateDataPtr __restrict place, IColumn & to, Arena * arena) const\n-    {\n-        auto arguments = this->data(place).getArguments(this->argument_types);\n-        ColumnRawPtrs arguments_raw(arguments.size());\n-        for (size_t i = 0; i < arguments.size(); ++i)\n-            arguments_raw[i] = arguments[i].get();\n-\n-        assert(!arguments.empty());\n-        nested_func->addBatchSinglePlace(0, arguments[0]->size(), getNestedPlace(place), arguments_raw.data(), arena);\n-        if constexpr (MergeResult)\n-            nested_func->insertMergeResultInto(getNestedPlace(place), to, arena);\n-        else\n-            nested_func->insertResultInto(getNestedPlace(place), to, arena);\n-    }\n-\n     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena * arena) const override\n     {\n-        insertResultIntoImpl<false>(place, to, arena);\n+        nested_func->insertResultInto(getNestedPlace(place), to, arena);\n     }\n \n     void insertMergeResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena * arena) const override\n     {\n-        insertResultIntoImpl<true>(place, to, arena);\n+        nested_func->insertMergeResultInto(getNestedPlace(place), to, arena);\n     }\n \n     size_t sizeOfData() const override\ndiff --git a/src/Functions/toDecimalString.cpp b/src/Functions/toDecimalString.cpp\nindex eb607127fc5e..8feee5ee604c 100644\n--- a/src/Functions/toDecimalString.cpp\n+++ b/src/Functions/toDecimalString.cpp\n@@ -182,8 +182,8 @@ class FunctionToDecimalString : public IFunction\n             writeChar('.', out);\n             for (int i = 0; i < precision; ++i)\n                 writeChar('0', out);\n-            writeChar(0, out);\n         }\n+        writeChar(0, out);\n     }\n \n public:\n",
  "test_patch": "diff --git a/tests/performance/window_functions_distinct.xml b/tests/performance/window_functions_distinct.xml\nnew file mode 100644\nindex 000000000000..9e352eda6cd8\n--- /dev/null\n+++ b/tests/performance/window_functions_distinct.xml\n@@ -0,0 +1,32 @@\n+<test>\n+    <query>\n+        SELECT number, avg(DISTINCT number) OVER () FROM numbers(0, 100_000) FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT number, avg(DISTINCT number) OVER (ORDER BY number) FROM numbers(0, 100_000) FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT number, avg(DISTINCT number) OVER (ORDER BY number ROWS BETWEEN UNBOUNDED PRECEDING AND 20 FOLLOWING)\n+        FROM numbers(0, 100_000) FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT number, s, min(DISTINCT s) OVER(PARTITION BY number % 5_000) AS min_varlen_string\n+        FROM\n+        (\n+            SELECT number, toString(number % 10_000) AS s\n+            FROM numbers(100_000)\n+        ) FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT s, ts, argMax(DISTINCT ts, s) OVER(PARTITION BY ts % 5_000) AS value_with_max_ts\n+        FROM\n+        (\n+            SELECT number AS ts, toString(number % 10_000) AS s\n+            FROM numbers(100_000)\n+        ) FORMAT Null;\n+    </query>\n+</test>\ndiff --git a/tests/queries/0_stateless/01656_sequence_next_node_distinct.reference b/tests/queries/0_stateless/01656_sequence_next_node_distinct.reference\nnew file mode 100644\nindex 000000000000..c3cabd178db2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01656_sequence_next_node_distinct.reference\n@@ -0,0 +1,6 @@\n+(forward, head, A->B)\t0\t\\N\n+(forward, head, A->B)\t1\tB\n+(forward, head, A->B)\t1\t\\N\n+(forward, head, A->B)\t2\t\\N\n+\n+(forward, head, A->B)\t0\t\\N\ndiff --git a/tests/queries/0_stateless/01656_sequence_next_node_distinct.sql b/tests/queries/0_stateless/01656_sequence_next_node_distinct.sql\nnew file mode 100644\nindex 000000000000..f88a780f665d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01656_sequence_next_node_distinct.sql\n@@ -0,0 +1,46 @@\n+SET allow_experimental_funnel_functions = 1;\n+\n+DROP TABLE IF EXISTS events_demo;\n+\n+CREATE TABLE events_demo (\n+  id UInt32,\n+  dt DateTime,\n+  action Nullable(String)\n+) ENGINE = MergeTree()\n+ORDER BY\n+  (id, dt);\n+\n+INSERT INTO\n+  events_demo (id, dt, action)\n+VALUES\n+  (1, '2025-06-17 09:00:00', 'A'),\n+  (1, '2025-06-17 09:00:10', 'B'),\n+  (1, '2025-06-17 09:00:20', 'B'),\n+  (1, '2025-06-17 09:00:30', 'C'),\n+  (1, '2025-06-17 09:00:40', NULL),\n+  (2, '2025-06-17 08:00:00', 'X'),\n+  (2, '2025-06-17 08:00:00', 'X'),\n+  (2, '2025-06-17 08:00:10', 'A'),\n+  (2, '2025-06-17 08:00:20', NULL),\n+  (2, '2025-06-17 08:00:30', 'Y'),\n+  (2, '2025-06-17 08:00:30', 'Y'),\n+  (2, '2025-06-17 08:00:40', 'A'),\n+  (2, '2025-06-17 08:00:50', 'Y'),\n+  (1, '2025-06-17 09:00:40', NULL);\n+\n+SELECT\n+  DISTINCT '(forward, head, A->B)',\n+  id,\n+  sequenceNextNodeDistinct('forward', 'head', 4) (\n+    dt,\n+    action,\n+    action = 'A',\n+    toNullable(1 IS NOT NULL)\n+    AND (NOT toNullable(isNullable(1)))\n+  ) IGNORE NULLS AS next_node\n+FROM\n+  events_demo\n+GROUP BY\n+  * WITH ROLLUP WITH TOTALS\n+ORDER BY\n+  ALL ASC NULLS LAST;\ndiff --git a/tests/queries/0_stateless/02676_to_decimal_string.reference b/tests/queries/0_stateless/02676_to_decimal_string.reference\nindex 4c27ee5b5286..b1c93f5bd3bd 100644\n--- a/tests/queries/0_stateless/02676_to_decimal_string.reference\n+++ b/tests/queries/0_stateless/02676_to_decimal_string.reference\n@@ -19,3 +19,7 @@\n 128.78932312332132985464000000000000000000000000000000000000000000000000000000000\n 128.7893231233\n -128.78932312332132985464123123789323123321329854600000000000000000000000000000000\n+1\n+1\n+-1\n+-1\ndiff --git a/tests/queries/0_stateless/02676_to_decimal_string.sql b/tests/queries/0_stateless/02676_to_decimal_string.sql\nindex 1dae139deb1c..d24deb91be97 100644\n--- a/tests/queries/0_stateless/02676_to_decimal_string.sql\n+++ b/tests/queries/0_stateless/02676_to_decimal_string.sql\n@@ -39,3 +39,9 @@ SELECT toDecimalString('256.256'::Decimal256(45), *); -- {serverError ILLEGAL_CO\n SELECT toDecimalString('128.128'::Decimal128(30), 'str'); -- {serverError ILLEGAL_TYPE_OF_ARGUMENT}\n SELECT toDecimalString('64.64'::Decimal64(10)); -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n SELECT toDecimalString('64.64'::Decimal64(10), 3, 3); -- {serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH}\n+\n+-- Zero precision checks\n+SELECT toDecimalString(1, 0);\n+SELECT toDecimalString(1.123456, 0);  -- rounding\n+SELECT toDecimalString(-1, 0);\n+SELECT toDecimalString(-1.123456, 0);  -- rounding\ndiff --git a/tests/queries/0_stateless/03447_window_functions_distinct.reference b/tests/queries/0_stateless/03447_window_functions_distinct.reference\nnew file mode 100644\nindex 000000000000..e952bff25f43\n--- /dev/null\n+++ b/tests/queries/0_stateless/03447_window_functions_distinct.reference\n@@ -0,0 +1,68 @@\n+Single Numeric Data:\n+0\t10\n+1\t10\n+2\t10\n+3\t10\n+4\t10\n+0\t0\n+1\t1\n+2\t3\n+3\t6\n+4\t10\n+0\t0\t30\n+2\t2\t30\n+9\t11\t30\n+4\t15\t21\n+8\t23\t17\n+0\t23\t17\n+2\t23\t17\n+8\t23\t15\n+0\t23\t7\n+7\t30\t7\n+Single Generic Plain Column:\n+0\t0\t0\n+1\t1\t0\n+2\t2\t0\n+3\t3\t0\n+4\t4\t0\n+5\t0\t0\n+6\t1\t0\n+7\t2\t0\n+8\t3\t0\n+9\t4\t0\n+10\t0\t0\n+Single Generic Non-Plain Column:\n+['0','1']\t['0','1']\n+['1','2']\t['0','1']\n+['2','3']\t['0','1']\n+['3','4']\t['0','1']\n+['4','5']\t['0','1']\n+['5','6']\t['0','1']\n+['6','7']\t['0','1']\n+['7','8']\t['0','1']\n+['8','9']\t['0','1']\n+['9','10']\t['0','1']\n+Multiple Generic Columns:\n+0\t0\t4\n+1\t1\t9\n+2\t2\t4\n+3\t3\t9\n+4\t4\t4\n+0\t5\t9\n+1\t6\t4\n+2\t7\t9\n+3\t8\t4\n+4\t9\t9\n+0\t10\t4\n+Aggregate State Checks:\n+6\t9\t10\t6\t9\n+5\t7\t9\t5\t7\n+5\t7\t9\t5\t7\n+9\t12\t14\t9\t12\n+10\t13\t20\t10\t13\n+11\t14\t22\t11\t14\n+12\t15\t24\t12\t15\n+13\t16\t26\t13\t16\n+14\t17\t28\t14\t17\n+15\t18\t30\t15\t18\n+6\t9\t12\t10\t15\t14\t15\t15\t15\ndiff --git a/tests/queries/0_stateless/03447_window_functions_distinct.sql b/tests/queries/0_stateless/03447_window_functions_distinct.sql\nnew file mode 100644\nindex 000000000000..d54eeee5404e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03447_window_functions_distinct.sql\n@@ -0,0 +1,61 @@\n+SELECT 'Single Numeric Data:';\n+SELECT number, sum(DISTINCT number) OVER () FROM numbers(0, 5) ORDER BY number;\n+SELECT number, sum(DISTINCT number) OVER (ORDER BY number) FROM numbers(0, 5) ORDER BY number;\n+\n+WITH intHash64(number) % 10 AS x\n+SELECT\n+    x,\n+    sumDistinct(x) OVER (ORDER BY number ASC ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS a,\n+    sumDistinct(x) OVER (ORDER BY number ASC ROWS BETWEEN CURRENT ROW AND UNBOUNDED FOLLOWING) AS b\n+FROM numbers(10);\n+\n+SELECT 'Single Generic Plain Column:';\n+SELECT number, s, min(DISTINCT s) OVER(PARTITION BY number % 2) AS min_varlen_string\n+FROM\n+(\n+    SELECT number, toString(number % 5) AS s\n+    FROM numbers(11)\n+) ORDER BY number;\n+\n+SELECT 'Single Generic Non-Plain Column:';\n+SELECT arr, min(DISTINCT arr) OVER (ORDER BY arr)\n+FROM\n+(\n+    SELECT [toString(number), toString(number+1)] AS arr\n+    FROM numbers(10)\n+) ORDER BY arr;\n+\n+SELECT 'Multiple Generic Columns:';\n+SELECT s, ts, argMax(DISTINCT ts, s) OVER(PARTITION BY ts % 2) AS value_with_max_ts\n+FROM\n+(\n+    SELECT number AS ts, toString(number % 5) AS s\n+    FROM numbers(11)\n+) ORDER BY ts;\n+\n+SELECT 'Aggregate State Checks:';\n+WITH\n+    arrayReduce('sumDistinctState', [1 + number, 2, 3]) AS a,\n+    arrayReduce('sumDistinctState', [2 + number, 3, 4]) AS b\n+SELECT\n+    finalizeAggregation(a),\n+    finalizeAggregation(b),\n+    finalizeAggregation(a + b),\n+    finalizeAggregation(a * 2),\n+    finalizeAggregation(b * 2)\n+FROM numbers(10);\n+\n+WITH\n+    arrayReduce('sumDistinctState', [1, 2, 3]) AS a,\n+    arrayReduce('sumDistinctState', [2, 3, 4]) AS b,\n+    arrayReduce('sumDistinctState', [3, 4, 5]) AS c\n+SELECT\n+    finalizeAggregation(a),\n+    finalizeAggregation(b),\n+    finalizeAggregation(c),\n+    finalizeAggregation(a + b),\n+    finalizeAggregation(a + c),\n+    finalizeAggregation(b + c),\n+    finalizeAggregation((a + b) + c),\n+    finalizeAggregation((b + c) + a),\n+    finalizeAggregation((c + a) + b);\ndiff --git a/tests/queries/0_stateless/03448_window_functions_distinct_distributed.reference b/tests/queries/0_stateless/03448_window_functions_distinct_distributed.reference\nnew file mode 100644\nindex 000000000000..933f22c74a41\n--- /dev/null\n+++ b/tests/queries/0_stateless/03448_window_functions_distinct_distributed.reference\n@@ -0,0 +1,8 @@\n+49999.5\n+49999.5\n+[(0,'4'),(1,'4'),(2,'4'),(3,'4'),(4,'4'),(5,'4'),(6,'4'),(7,'4'),(8,'4'),(9,'4')]\n+[(0,0),(0,5),(0,10),(1,0),(1,1),(1,5),(1,10),(2,0),(2,2),(2,5),(2,10),(3,0),(3,5),(3,10),(4,0),(4,1),(4,5),(4,10),(5,0),(5,5),(5,10),(6,0),(6,5),(6,10),(7,0),(7,1),(7,5),(7,10),(8,0),(8,5),(8,10),(9,0),(9,5),(9,10)]\n+49999.5\n+49999.5\n+[(0,'4'),(1,'4'),(2,'4'),(3,'4'),(4,'4'),(5,'4'),(6,'4'),(7,'4'),(8,'4'),(9,'4')]\n+[(0,0),(0,5),(0,10),(1,0),(1,1),(1,5),(1,10),(2,0),(2,2),(2,5),(2,10),(3,0),(3,5),(3,10),(4,0),(4,1),(4,5),(4,10),(5,0),(5,5),(5,10),(6,0),(6,5),(6,10),(7,0),(7,1),(7,5),(7,10),(8,0),(8,5),(8,10),(9,0),(9,5),(9,10)]\ndiff --git a/tests/queries/0_stateless/03448_window_functions_distinct_distributed.sql b/tests/queries/0_stateless/03448_window_functions_distinct_distributed.sql\nnew file mode 100644\nindex 000000000000..cab3ca071149\n--- /dev/null\n+++ b/tests/queries/0_stateless/03448_window_functions_distinct_distributed.sql\n@@ -0,0 +1,73 @@\n+-- Tags: distributed\n+\n+SET distributed_aggregation_memory_efficient = 1;\n+\n+SELECT any(total) AS total_distinct_avg\n+FROM (\n+    SELECT number,\n+        avgDistinct(number) OVER () AS total\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000))\n+);\n+\n+SELECT max(running_avg) AS final_running_avg\n+FROM (\n+    SELECT number,\n+        avgDistinct(number) OVER (ORDER BY number) AS running_avg\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000))\n+);\n+\n+SELECT\n+    arraySort(groupUniqArray((partition_mod, max_val))) AS max_strings_per_partition\n+FROM (\n+    SELECT\n+        number % 10 AS partition_mod,\n+        maxDistinct(toString(number % 5)) OVER (PARTITION BY number % 7) AS max_val\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000))\n+);\n+\n+SELECT\n+    arraySort(groupUniqArray((partition_mod, argMin_val))) AS argmin_per_partition\n+FROM (\n+    SELECT\n+        number                             AS ts,\n+        ts % 10                            AS partition_mod,\n+        toString(ts % 5)                   AS s,\n+        argMinDistinct(ts, s) OVER (PARTITION BY ts % 3 ORDER BY ts) AS argMin_val\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000)) ORDER BY ts\n+);\n+\n+SET distributed_aggregation_memory_efficient = 0;\n+\n+SELECT any(total) AS total_distinct_avg\n+FROM (\n+    SELECT number,\n+        avgDistinct(number) OVER () AS total\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000))\n+);\n+\n+SELECT max(running_avg) AS final_running_avg\n+FROM (\n+    SELECT number,\n+        avgDistinct(number) OVER (ORDER BY number) AS running_avg\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000))\n+);\n+\n+SELECT\n+    arraySort(groupUniqArray((partition_mod, max_val))) AS max_strings_per_partition\n+FROM (\n+    SELECT\n+        number % 10 AS partition_mod,\n+        maxDistinct(toString(number % 5)) OVER (PARTITION BY number % 7) AS max_val\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000))\n+);\n+\n+SELECT\n+    arraySort(groupUniqArray((partition_mod, argMin_val))) AS argmin_per_partition\n+FROM (\n+    SELECT\n+        number                             AS ts,\n+        ts % 10                            AS partition_mod,\n+        toString(ts % 5)                   AS s,\n+        argMinDistinct(ts, s) OVER (PARTITION BY ts % 3 ORDER BY ts) AS argMin_val\n+    FROM remote('127.0.0.{1,2,3}', numbers_mt(100_000)) ORDER BY ts\n+);\n",
  "problem_statement": "Slow distinct aggregate window function\n### Company or project name\n\nClickHouse employee \ud83d\ude04 \n\n### Describe the unexpected behaviour\n\nA distinct aggregate over a window function in ClickHouse becomes very slow compared to other analytical databases. Maybe an optimization is missing?\n\n### How to reproduce\n\nRun:\n\n```sql\nSELECT avg(DISTINCT number) OVER () FROM numbers(0, 100000);\n```\n\n### Expected behavior\n\nIt shouldn't take several minutes, but some seconds at most.\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n_No response_\nsumDistinct in window function the result is wrong\nWhen I use sumDistinct in window function the result is wrong.\r\nFor example\uff1a\r\n```SQL\r\n CREATE TABLE t1 ( `ID` UInt64, `col1` Int64) ENGINE = MergeTree ORDER BY ID;\r\n insert into events(ID, col1) select number, number % 3 from numbers(10);\r\n insert into events(ID, col1) select number, number % 3 from numbers(8);\r\nselect ID, col1, sum(Distinct(ID)) OVER (partition by col1) from events ORDER BY col1;\r\n```\r\n\r\n\r\n\n",
  "hints_text": "Thanks for the finding!\n\nI checked the implementation and found out that it works in the following way:\n- collect distinct values of the arguments in a set;\n- when the result is needed, pass all these values into the aggregate function.\n\nThis leads to a quadratic complexity when we obtain the result for every record, such as in the case of window functions.\n\nA better implementation would be:\n- collect a set for filtering distinct values;\n- at the same time, collect the state of aggregate function with the distinct values;\n- when the result is needed, finalize this state;\n\nThe function was introduced here https://github.com/ClickHouse/ClickHouse/pull/10930 as a part of a coursework, and its implementation didn't consider the combination with window functions.\n@alexey-milovidov, I was also looking at this issue. Initially, two approaches came to my mind:\n\n1. Cache when no `ORDER BY`: If a window lacks an explicit `ORDER BY`, `WindowTransform` could compute the result once, cache it, and reuse the same value for every row in the partition. This would require careful modification of `WindowTransform`.\n\n2. Add specialised `DISTINCT` aggregates: We could implement dedicated aggregates classes for distinct `max`, `avg`, `sum`, similar to `count`'s `AggregateFunctionUniq.cpp`. (that's why `count(DISTINCT number)` version runs in `O(n)`).\n\nI was leaning towards approach 2 as it avoids potentially introducing new bugs in `WindowTransform` via approach 1. Additionally, approach 2 will allow for more flexibility for optimisation. What are your thoughts?\nWouldn't rewriting the state of the Distinct-combined aggregate function, so that it included the state of the nested aggregate function, solve the problem?\nYou are right. I initially had a wrong idea. Modifying the Distinct-combined aggregate function is the cleanest way to resolve it.\n\n@alexey-milovidov May I work on this issue?\n@nihalzp, thanks, this will be amazing!\nThis query:\n\n```SELECT number, sum(DISTINCT number) OVER () FROM numbers(10);```\n\nGave the response:\n\nSELECT\n    number,\n    sumDistinct(number) OVER ()\nFROM numbers(10)\n\n 1. \u2502      0 \u2502                          45 \u2502\n 2. \u2502      1 \u2502                          90 \u2502\n 3. \u2502      2 \u2502                         135 \u2502\n 4. \u2502      3 \u2502                         180 \u2502\n 5. \u2502      4 \u2502                         225 \u2502\n 6. \u2502      5 \u2502                         270 \u2502\n 7. \u2502      6 \u2502                         315 \u2502\n 8. \u2502      7 \u2502                         360 \u2502\n 9. \u2502      8 \u2502                         405 \u2502\n10. \u2502      9 \u2502                         450 \u2502\n\n\nI also checked it in the ClickHouse Playground. This seems wrong? It should be 45 everywhere, right? @alexey-milovidov \nYes, looks wrong.\nPlease explain what is wrong here ? https://fiddle.clickhouse.com/7333879f-c7b9-4d4b-804d-ba7579490306\r\n\r\n```\r\nselect ID, \r\n       col1, \r\n       groupArray(ID) OVER (partition by col1) b,\r\n       groupArray(distinct(ID)) OVER (partition by col1) a,\r\n       sum(distinct(ID)) OVER (partition by col1) r \r\nfrom t1 \r\nORDER BY  col1 format Pretty;\r\n\r\n\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n| ID | col1 | b               | a                                                         |   r |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  0 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3]                                                 |  18 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  3 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3]                                         |  36 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  6 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3,0,6,9,3]                                 |  54 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  0 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3]                         |  72 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  3 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3]                 |  90 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  6 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3]         | 108 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  9 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3,0,6,9,3] | 126 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  1 |    1 | [1,4,7,1,4,7]   | [4,1,7]                                                   |  12 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  4 |    1 | [1,4,7,1,4,7]   | [4,1,7,4,1,7]                                             |  24 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  7 |    1 | [1,4,7,1,4,7]   | [4,1,7,4,1,7,4,1,7]                                       |  36 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  1 |    1 | [1,4,7,1,4,7]   | [4,1,7,4,1,7,4,1,7,4,1,7]                                 |  48 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  4 |    1 | [1,4,7,1,4,7]   | [4,1,7,4,1,7,4,1,7,4,1,7,4,1,7]                           |  60 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  7 |    1 | [1,4,7,1,4,7]   | [4,1,7,4,1,7,4,1,7,4,1,7,4,1,7,4,1,7]                     |  72 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  2 |    2 | [2,5,2,5,8]     | [5,2,8]                                                   |  15 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  5 |    2 | [2,5,2,5,8]     | [5,2,8,5,2,8]                                             |  30 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  2 |    2 | [2,5,2,5,8]     | [5,2,8,5,2,8,5,2,8]                                       |  45 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  5 |    2 | [2,5,2,5,8]     | [5,2,8,5,2,8,5,2,8,5,2,8]                                 |  60 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n|  8 |    2 | [2,5,2,5,8]     | [5,2,8,5,2,8,5,2,8,5,2,8,5,2,8]                           |  75 |\r\n+----+------+-----------------+-----------------------------------------------------------+-----+\r\n```\nThough,\r\n\r\npg\r\n```sql\r\nCREATE TABLE t1 (ID int, col1 int);\r\n\r\ninsert into t1 values (0,0),(3,0),(1,1),(2,2);\r\n\r\nselect ID, \r\n       col1, \r\n       sum(distinct(ID)) OVER (partition by col1) r \r\nfrom t1 \r\nORDER BY  col1;\r\n\r\nERROR:  DISTINCT is not implemented for window functions\r\nLINE 3:        sum(distinct(ID)) OVER (partition by col1) r\r\n```\n@sunshup check this https://fiddle.clickhouse.com/f387bdaf-75a8-46f8-b015-25206fd8ee0c\r\n\r\n```sql\r\nCREATE TABLE t1 ( `ID` UInt64, `col1` Int64) ENGINE = MergeTree ORDER BY ID;\r\n\r\n insert into t1(ID, col1) select number, number % 3 from numbers(10);\r\n insert into t1(ID, col1) select number, number % 3 from numbers(8);\r\n\r\nselect ID, \r\n       col1, \r\n       groupArray(ID) OVER (partition by col1) b,\r\n       groupUniqArray(ID) OVER (partition by col1) a,\r\n       arraySum(a) r \r\nfrom t1 \r\nORDER BY  col1 format Pretty;\r\n```\n@den-crane thanks, that is a great idea. It can also be used this [https://fiddle.clickhouse.com/2f0d4262-2042-436d-a63f-b3798d65a146](https://fiddle.clickhouse.com/2f0d4262-2042-436d-a63f-b3798d65a146)\r\n```SQL \r\nCREATE TABLE t1 ( `ID` UInt64, `col1` Int64) ENGINE = MergeTree ORDER BY ID;\r\n\r\n insert into t1(ID, col1) select number, number % 3 from numbers(10);\r\n insert into t1(ID, col1) select number, number % 3 from numbers(8);\r\n\r\nselect ID, \r\n       col1, \r\n       uniqExact(ID) OVER (partition by col1) *  avgDistinct(ID) OVER (partition by col1)   as res\r\nfrom t1 \r\nORDER BY  col1 format Pretty;```\r\n\nIt should be a bug,  please check this [https://fiddle.clickhouse.com/062dd750-dcd2-4d0d-a1c1-fd860cd65aa7](https://fiddle.clickhouse.com/062dd750-dcd2-4d0d-a1c1-fd860cd65aa7)\r\n\r\n```\r\n+----+------+-----------------+-----------------------------------------------------------+\r\n| ID | col1 | b               | a                                                         |\r\n+----+------+-----------------+-----------------------------------------------------------+\r\n|  0 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3]                                                 |\r\n+----+------+-----------------+-----------------------------------------------------------+\r\n|  3 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3]                                         |\r\n+----+------+-----------------+-----------------------------------------------------------+\r\n|  6 |    0 | [0,3,6,0,3,6,9] | [0,6,9,3,0,6,9,3,0,6,9,3]                                 |\r\n+----+------+-----------------+-----------------------------------------------------------+\r\n... ... \r\n```\r\nThe distinct set is expected to be `[0,6,9,3]` but the line 2 and 3 have repeated values.\r\n\r\n\n`distinct` is not an aggregate function. It should be forbidden in this context, the same as PG https://github.com/ClickHouse/ClickHouse/issues/52253#issuecomment-1640299806.\r\n\r\n\nBut we have distinct combinator, so it should work IMO: `groupArrayDistinct`\nSo is it obliged to fix the `sum(Distinct(ID))` over window? \nsum(Distinct(ID)) is sum aggregation function with combinator `distinct`. \nYes, but it's just IMO.",
  "created_at": "2025-05-05T18:56:50Z",
  "modified_files": [
    "src/AggregateFunctions/Combinators/AggregateFunctionDistinct.h",
    "src/Functions/toDecimalString.cpp"
  ],
  "modified_test_files": [
    "b/tests/performance/window_functions_distinct.xml",
    "b/tests/queries/0_stateless/01656_sequence_next_node_distinct.reference",
    "b/tests/queries/0_stateless/01656_sequence_next_node_distinct.sql",
    "tests/queries/0_stateless/02676_to_decimal_string.reference",
    "tests/queries/0_stateless/02676_to_decimal_string.sql",
    "b/tests/queries/0_stateless/03447_window_functions_distinct.reference",
    "b/tests/queries/0_stateless/03447_window_functions_distinct.sql",
    "b/tests/queries/0_stateless/03448_window_functions_distinct_distributed.reference",
    "b/tests/queries/0_stateless/03448_window_functions_distinct_distributed.sql"
  ]
}