{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68024,
  "instance_id": "ClickHouse__ClickHouse-68024",
  "issue_numbers": [
    "44817"
  ],
  "base_commit": "659a6a22f681f372924e40117811e65c5e0da2eb",
  "patch": "diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex ebcb593dcb6b..e6f8ecef097c 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -14,6 +14,7 @@\n #include <Databases/registerDatabases.h>\n #include <Databases/DatabaseFilesystem.h>\n #include <Databases/DatabaseMemory.h>\n+#include <Databases/DatabaseAtomic.h>\n #include <Databases/DatabasesOverlay.h>\n #include <Storages/System/attachSystemTables.h>\n #include <Storages/System/attachInformationSchemaTables.h>\n@@ -257,12 +258,12 @@ static DatabasePtr createMemoryDatabaseIfNotExists(ContextPtr context, const Str\n     return system_database;\n }\n \n-static DatabasePtr createClickHouseLocalDatabaseOverlay(const String & name_, ContextPtr context_)\n+static DatabasePtr createClickHouseLocalDatabaseOverlay(const String & name_, ContextPtr context)\n {\n-    auto databaseCombiner = std::make_shared<DatabasesOverlay>(name_, context_);\n-    databaseCombiner->registerNextDatabase(std::make_shared<DatabaseFilesystem>(name_, \"\", context_));\n-    databaseCombiner->registerNextDatabase(std::make_shared<DatabaseMemory>(name_, context_));\n-    return databaseCombiner;\n+    auto overlay = std::make_shared<DatabasesOverlay>(name_, context);\n+    overlay->registerNextDatabase(std::make_shared<DatabaseAtomic>(name_, fs::weakly_canonical(context->getPath()), UUIDHelpers::generateV4(), context));\n+    overlay->registerNextDatabase(std::make_shared<DatabaseFilesystem>(name_, \"\", context));\n+    return overlay;\n }\n \n /// If path is specified and not empty, will try to setup server environment and load existing metadata\n@@ -811,7 +812,12 @@ void LocalServer::processConfig()\n     DatabaseCatalog::instance().initializeAndLoadTemporaryDatabase();\n \n     std::string default_database = server_settings[ServerSetting::default_database];\n-    DatabaseCatalog::instance().attachDatabase(default_database, createClickHouseLocalDatabaseOverlay(default_database, global_context));\n+    {\n+        DatabasePtr database = createClickHouseLocalDatabaseOverlay(default_database, global_context);\n+        if (UUID uuid = database->getUUID(); uuid != UUIDHelpers::Nil)\n+            DatabaseCatalog::instance().addUUIDMapping(uuid);\n+        DatabaseCatalog::instance().attachDatabase(default_database, database);\n+    }\n     global_context->setCurrentDatabase(default_database);\n \n     if (getClientConfiguration().has(\"path\"))\ndiff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex 13230fdf545a..bd077ccd7b53 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -6,7 +6,6 @@\n #include <Databases/DatabaseReplicated.h>\n #include <IO/ReadBufferFromFile.h>\n #include <IO/ReadHelpers.h>\n-#include <IO/WriteHelpers.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/DDLTask.h>\n #include <Interpreters/DatabaseCatalog.h>\n@@ -19,6 +18,7 @@\n #include <Common/filesystemHelpers.h>\n #include <Core/Settings.h>\n \n+\n namespace fs = std::filesystem;\n \n namespace DB\n@@ -60,9 +60,6 @@ DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, c\n     , db_uuid(uuid)\n {\n     assert(db_uuid != UUIDHelpers::Nil);\n-    fs::create_directories(fs::path(getContext()->getPath()) / \"metadata\");\n-    fs::create_directories(path_to_table_symlinks);\n-    tryCreateMetadataSymlink();\n }\n \n DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, ContextPtr context_)\n@@ -70,6 +67,20 @@ DatabaseAtomic::DatabaseAtomic(String name_, String metadata_path_, UUID uuid, C\n {\n }\n \n+void DatabaseAtomic::createDirectories()\n+{\n+    std::lock_guard lock(mutex);\n+    createDirectoriesUnlocked();\n+}\n+\n+void DatabaseAtomic::createDirectoriesUnlocked()\n+{\n+    DatabaseOnDisk::createDirectoriesUnlocked();\n+    fs::create_directories(fs::path(getContext()->getPath()) / \"metadata\");\n+    fs::create_directories(path_to_table_symlinks);\n+    tryCreateMetadataSymlink();\n+}\n+\n String DatabaseAtomic::getTableDataPath(const String & table_name) const\n {\n     std::lock_guard lock(mutex);\n@@ -108,6 +119,7 @@ void DatabaseAtomic::attachTable(ContextPtr /* context_ */, const String & name,\n     assert(relative_table_path != data_path && !relative_table_path.empty());\n     DetachedTables not_in_use;\n     std::lock_guard lock(mutex);\n+    createDirectoriesUnlocked();\n     not_in_use = cleanupDetachedTables();\n     auto table_id = table->getStorageID();\n     assertDetachedTableNotInUse(table_id.uuid);\n@@ -208,11 +220,15 @@ void DatabaseAtomic::renameTable(ContextPtr local_context, const String & table_\n     if (exchange && !supportsAtomicRename(&message))\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"RENAME EXCHANGE is not supported because exchanging files is not supported by the OS ({})\", message);\n \n+    createDirectories();\n     waitDatabaseStarted();\n \n     auto & other_db = dynamic_cast<DatabaseAtomic &>(to_database);\n     bool inside_database = this == &other_db;\n \n+    if (!inside_database)\n+        other_db.createDirectories();\n+\n     String old_metadata_path = getObjectMetadataPath(table_name);\n     String new_metadata_path = to_database.getObjectMetadataPath(to_table_name);\n \n@@ -333,6 +349,7 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora\n                                        const String & table_metadata_tmp_path, const String & table_metadata_path,\n                                        ContextPtr query_context)\n {\n+    createDirectories();\n     DetachedTables not_in_use;\n     auto table_data_path = getTableDataPath(query);\n     try\n@@ -469,6 +486,9 @@ void DatabaseAtomic::beforeLoadingMetadata(ContextMutablePtr /*context*/, Loadin\n     if (mode < LoadingStrictnessLevel::FORCE_RESTORE)\n         return;\n \n+    if (!fs::exists(path_to_table_symlinks))\n+        return;\n+\n     /// Recreate symlinks to table data dirs in case of force restore, because some of them may be broken\n     for (const auto & table_path : fs::directory_iterator(path_to_table_symlinks))\n     {\n@@ -611,6 +631,7 @@ void DatabaseAtomic::renameDatabase(ContextPtr query_context, const String & new\n {\n     /// CREATE, ATTACH, DROP, DETACH and RENAME DATABASE must hold DDLGuard\n \n+    createDirectories();\n     waitDatabaseStarted();\n \n     bool check_ref_deps = query_context->getSettingsRef()[Setting::check_referential_table_dependencies];\n@@ -702,4 +723,5 @@ void registerDatabaseAtomic(DatabaseFactory & factory)\n     };\n     factory.registerDatabase(\"Atomic\", create_fn);\n }\n+\n }\ndiff --git a/src/Databases/DatabaseAtomic.h b/src/Databases/DatabaseAtomic.h\nindex 07a1f9c7fa1b..7e9091286355 100644\n--- a/src/Databases/DatabaseAtomic.h\n+++ b/src/Databases/DatabaseAtomic.h\n@@ -76,6 +76,9 @@ class DatabaseAtomic : public DatabaseOrdinary\n     using DetachedTables = std::unordered_map<UUID, StoragePtr>;\n     [[nodiscard]] DetachedTables cleanupDetachedTables() TSA_REQUIRES(mutex);\n \n+    void createDirectories();\n+    void createDirectoriesUnlocked() TSA_REQUIRES(mutex);\n+\n     void tryCreateMetadataSymlink();\n \n     virtual bool allowMoveTableToOtherDatabaseEngine(IDatabase & /*to_database*/) const { return false; }\ndiff --git a/src/Databases/DatabaseLazy.cpp b/src/Databases/DatabaseLazy.cpp\nindex 0a4b02c49175..d63dea201201 100644\n--- a/src/Databases/DatabaseLazy.cpp\n+++ b/src/Databases/DatabaseLazy.cpp\n@@ -47,6 +47,7 @@ DatabaseLazy::DatabaseLazy(const String & name_, const String & metadata_path_,\n     : DatabaseOnDisk(name_, metadata_path_, std::filesystem::path(\"data\") / escapeForFileName(name_) / \"\", \"DatabaseLazy (\" + name_ + \")\", context_)\n     , expiration_time(expiration_time_)\n {\n+    createDirectories();\n }\n \n \ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex f914d9024e1d..93ecf9cf11cb 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -180,7 +180,18 @@ DatabaseOnDisk::DatabaseOnDisk(\n     , metadata_path(metadata_path_)\n     , data_path(data_path_)\n {\n-    fs::create_directories(local_context->getPath() + data_path);\n+}\n+\n+\n+void DatabaseOnDisk::createDirectories()\n+{\n+    std::lock_guard lock(mutex);\n+    createDirectoriesUnlocked();\n+}\n+\n+void DatabaseOnDisk::createDirectoriesUnlocked()\n+{\n+    fs::create_directories(std::filesystem::path(getContext()->getPath()) / data_path);\n     fs::create_directories(metadata_path);\n }\n \n@@ -198,6 +209,8 @@ void DatabaseOnDisk::createTable(\n     const StoragePtr & table,\n     const ASTPtr & query)\n {\n+    createDirectories();\n+\n     const auto & settings = local_context->getSettingsRef();\n     const auto & create = query->as<ASTCreateQuery &>();\n     assert(table_name == create.getTable());\n@@ -265,7 +278,6 @@ void DatabaseOnDisk::createTable(\n     }\n \n     commitCreateTable(create, table, table_metadata_tmp_path, table_metadata_path, local_context);\n-\n     removeDetachedPermanentlyFlag(local_context, table_name, table_metadata_path, false);\n }\n \n@@ -293,6 +305,8 @@ void DatabaseOnDisk::commitCreateTable(const ASTCreateQuery & query, const Stora\n {\n     try\n     {\n+        createDirectories();\n+\n         /// Add a table to the map of known tables.\n         attachTable(query_context, query.getTable(), table, getTableDataPath(query));\n \n@@ -426,6 +440,7 @@ void DatabaseOnDisk::renameTable(\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Moving tables between databases of different engines is not supported\");\n     }\n \n+    createDirectories();\n     waitDatabaseStarted();\n \n     auto table_data_relative_path = getTableDataPath(table_name);\n@@ -621,6 +636,9 @@ time_t DatabaseOnDisk::getObjectMetadataModificationTime(const String & object_n\n \n void DatabaseOnDisk::iterateMetadataFiles(const IteratingFunction & process_metadata_file) const\n {\n+    if (!fs::exists(metadata_path))\n+        return;\n+\n     auto process_tmp_drop_metadata_file = [&](const String & file_name)\n     {\n         assert(getUUID() == UUIDHelpers::Nil);\ndiff --git a/src/Databases/DatabaseOnDisk.h b/src/Databases/DatabaseOnDisk.h\nindex ffc95a7c1288..1e11d21cc87b 100644\n--- a/src/Databases/DatabaseOnDisk.h\n+++ b/src/Databases/DatabaseOnDisk.h\n@@ -99,6 +99,9 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n     virtual void removeDetachedPermanentlyFlag(ContextPtr context, const String & table_name, const String & table_metadata_path, bool attach);\n     virtual void setDetachedTableNotInUseForce(const UUID & /*uuid*/) {}\n \n+    void createDirectories();\n+    void createDirectoriesUnlocked() TSA_REQUIRES(mutex);\n+\n     const String metadata_path;\n     const String data_path;\n };\ndiff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h\nindex f94326d220e4..02418abb2b06 100644\n--- a/src/Databases/IDatabase.h\n+++ b/src/Databases/IDatabase.h\n@@ -416,6 +416,7 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n         std::lock_guard lock{mutex};\n         return database_name;\n     }\n+\n     /// Get UUID of database.\n     virtual UUID getUUID() const { return UUIDHelpers::Nil; }\n \ndiff --git a/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp b/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp\nindex e097ffab0d71..3d5fcc153fdd 100644\n--- a/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp\n+++ b/src/Databases/MySQL/DatabaseMaterializedMySQL.cpp\n@@ -62,6 +62,7 @@ DatabaseMaterializedMySQL::DatabaseMaterializedMySQL(\n     , settings(std::move(settings_))\n     , materialize_thread(context_, database_name_, mysql_database_name_, std::move(pool_), std::move(client_), binlog_client_, settings.get())\n {\n+    createDirectories();\n }\n \n DatabaseMaterializedMySQL::~DatabaseMaterializedMySQL() = default;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference b/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference\nnew file mode 100644\nindex 000000000000..1975397394b7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03199_atomic_clickhouse_local.reference\n@@ -0,0 +1,6 @@\n+123\n+Hello\n+['Hello','world']\n+Hello\n+Hello\n+['Hello','world']\ndiff --git a/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh b/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh\nnew file mode 100755\nindex 000000000000..edaa83b8f959\n--- /dev/null\n+++ b/tests/queries/0_stateless/03199_atomic_clickhouse_local.sh\n@@ -0,0 +1,24 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_LOCAL} -n \"\n+CREATE TABLE test (x UInt8) ORDER BY x;\n+INSERT INTO test VALUES (123);\n+SELECT * FROM test;\n+CREATE OR REPLACE TABLE test (s String) ORDER BY s;\n+INSERT INTO test VALUES ('Hello');\n+SELECT * FROM test;\n+RENAME TABLE test TO test2;\n+CREATE OR REPLACE TABLE test (s Array(String)) ORDER BY s;\n+INSERT INTO test VALUES (['Hello', 'world']);\n+SELECT * FROM test;\n+SELECT * FROM test2;\n+EXCHANGE TABLES test AND test2;\n+SELECT * FROM test;\n+SELECT * FROM test2;\n+DROP TABLE test;\n+DROP TABLE test2;\n+\"\n",
  "problem_statement": "CREATE OR REPLACE and EXCHANGE TABLES for Memory database\n**Use case**\r\n\r\n`Memory` database engine is used in `clickhouse-local`, and nothing prevents implementing these queries.\r\n\r\n**Describe the solution you'd like**\r\n\r\nA mutex.\n",
  "hints_text": "The Memory database engine does not use UUIDs in tables and databases, and if the table stores data on the disk then the table data is stored directly in the `data/database_name/table_name` folder and not in (for example) `store/xxx/1e8dfeba-73a1-4b40-8238-63e58c9a3893`.\r\n\r\nSo in the case of RENAME query, we would need to either modify every table engine that stores data to have the ability to move its data from `data/database_name/table_name` to `data/database_name/new_table_name` (and hope that nothing breaks) or to use UUIDs and store the data in the `store/` directory which kind of makes it not temporary and basically an Atomic engine without saving metadata.\r\n\r\nIs there a reason for using the Memory engine in clickhouse-local? Either way, we will store the data in the `/tmp/clickhouse-local-.../` directory and it seems like the better solution would be to just use the Atomic engine.\nMemory database engine is like another database engine, but without persisting the .sql files.\r\nCurrently, it is modeled after the Ordinary database engine.\r\nBut the Ordinary database engine is obsolete. Let's make the tables' paths like in the Atomic database engine.\r\n\r\nLet's not worry about compatibility because it's expected that everything in the Memory database is temporary.\r\n\r\nPS. These operations should be supported:\r\n\r\n`REPLACE TABLE`\r\n`CREATE OR REPLACE TABLE`\r\n`EXCHANGE TABLES`\r\n`ATTACH TABLE ... UUID '...'`\r\n\r\nPS. Maybe we can decouple the way how DB's metadata is stored with the way how the table's paths are determined? It will also help with the implementation of the Replicated database engine. But this will be a much broader task. Let's consider it only after making the first solution.",
  "created_at": "2024-08-08T08:07:53Z"
}