{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33360,
  "instance_id": "ClickHouse__ClickHouse-33360",
  "issue_numbers": [
    "28535"
  ],
  "base_commit": "9619b0fd96ad5924c38568b0480a666ba66dd182",
  "patch": "diff --git a/docs/en/sql-reference/functions/bit-functions.md b/docs/en/sql-reference/functions/bit-functions.md\nindex 899b6385a3e4..24adb362c987 100644\n--- a/docs/en/sql-reference/functions/bit-functions.md\n+++ b/docs/en/sql-reference/functions/bit-functions.md\n@@ -117,6 +117,59 @@ Result:\n \n ## bitRotateRight(a, b) {#bitrotaterighta-b}\n \n+## bitSlice(s, offset, length)\n+\n+Returns a substring starting with the bit from the \u2018offset\u2019 index that is \u2018length\u2019 bits long. bits indexing starts from\n+1\n+\n+**Syntax**\n+\n+``` sql\n+bitSlice(s, offset[, length])\n+```\n+\n+**Arguments**\n+\n+- `s` \u2014 s is [String](../../sql-reference/data-types/string.md)\n+  or [FixedString](../../sql-reference/data-types/fixedstring.md).\n+- `offset` \u2014 The start index with bit, A positive value indicates an offset on the left, and a negative value is an\n+  indent on the right. Numbering of the bits begins with 1.\n+- `length` \u2014 The length of substring with bit. If you specify a negative value, the function returns an open substring [\n+  offset, array_length - length). If you omit the value, the function returns the substring [offset, the_end_string]. \n+  If length exceeds s, it will be truncate.If length isn't multiple of 8, will fill 0 on the right.\n+\n+**Returned value**\n+\n+- The substring. [String](../../sql-reference/data-types/string.md)\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+select bin('Hello'), bin(bitSlice('Hello', 1, 8))\n+select bin('Hello'), bin(bitSlice('Hello', 1, 2))\n+select bin('Hello'), bin(bitSlice('Hello', 1, 9))\n+select bin('Hello'), bin(bitSlice('Hello', -4, 8))\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500bin('Hello')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500bin(bitSlice('Hello', 1, 8))\u2500\u2510\n+\u2502 0100100001100101011011000110110001101111 \u2502 01001000                     \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500bin('Hello')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500bin(bitSlice('Hello', 1, 2))\u2500\u2510\n+\u2502 0100100001100101011011000110110001101111 \u2502 01000000                     \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500bin('Hello')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500bin(bitSlice('Hello', 1, 9))\u2500\u2510\n+\u2502 0100100001100101011011000110110001101111 \u2502 0100100000000000             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500bin('Hello')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500bin(bitSlice('Hello', -4, 8))\u2500\u2510\n+\u2502 0100100001100101011011000110110001101111 \u2502 11110000                      \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## bitTest {#bittest}\n \n Takes any integer and converts it into [binary form](https://en.wikipedia.org/wiki/Binary_number), returns the value of a bit at specified position. The countdown starts from 0 from the right to the left.\ndiff --git a/src/Functions/bitSlice.cpp b/src/Functions/bitSlice.cpp\nnew file mode 100644\nindex 000000000000..7d9b48acc89a\n--- /dev/null\n+++ b/src/Functions/bitSlice.cpp\n@@ -0,0 +1,428 @@\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnString.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/GatherUtils/Algorithms.h>\n+#include <Functions/GatherUtils/Sinks.h>\n+#include <Functions/GatherUtils/Slices.h>\n+#include <Functions/GatherUtils/Sources.h>\n+#include <Functions/IFunction.h>\n+#include <IO/WriteHelpers.h>\n+\n+namespace DB\n+{\n+using namespace GatherUtils;\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ZERO_ARRAY_OR_TUPLE_INDEX;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+class FunctionBitSlice : public IFunction\n+{\n+    const UInt8 word_size = 8;\n+\n+public:\n+    static constexpr auto name = \"bitSlice\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionBitSlice>(); }\n+\n+    String getName() const override { return name; }\n+\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        const size_t number_of_arguments = arguments.size();\n+\n+        if (number_of_arguments < 2 || number_of_arguments > 3)\n+            throw Exception(\n+                \"Number of arguments for function \" + getName() + \" doesn't match: passed \" + toString(number_of_arguments)\n+                    + \", should be 2 or 3\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        if (!isString(arguments[0]) && !isStringOrFixedString(arguments[0]))\n+            throw Exception(\n+                \"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        if (arguments[0]->onlyNull())\n+            return arguments[0];\n+\n+        if (!isNativeNumber(arguments[1]))\n+            throw Exception(\n+                \"Illegal type \" + arguments[1]->getName() + \" of second argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        if (number_of_arguments == 3 && !isNativeNumber(arguments[2]))\n+            throw Exception(\n+                \"Illegal type \" + arguments[2]->getName() + \" of second argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        size_t number_of_arguments = arguments.size();\n+\n+        ColumnPtr column_string = arguments[0].column;\n+        ColumnPtr column_start = arguments[1].column;\n+        ColumnPtr column_length;\n+\n+        std::optional<Int64> start_const;\n+        std::optional<Int64> length_const;\n+\n+        if (const auto * column_start_const = checkAndGetColumn<ColumnConst>(column_start.get()))\n+        {\n+            start_const = column_start_const->getInt(0);\n+        }\n+\n+        if (number_of_arguments == 3)\n+        {\n+            column_length = arguments[2].column;\n+            if (const auto * column_length_const = checkAndGetColumn<ColumnConst>(column_length.get()))\n+                length_const = column_length_const->getInt(0);\n+        }\n+\n+\n+        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column_string.get()))\n+            return executeForSource(column_start, column_length, start_const, length_const, StringSource(*col), input_rows_count);\n+        else if (const ColumnFixedString * col_fixed = checkAndGetColumn<ColumnFixedString>(column_string.get()))\n+            return executeForSource(\n+                column_start, column_length, start_const, length_const, FixedStringSource(*col_fixed), input_rows_count);\n+        else if (const ColumnConst * col_const = checkAndGetColumnConst<ColumnString>(column_string.get()))\n+            return executeForSource(\n+                column_start, column_length, start_const, length_const, ConstSource<StringSource>(*col_const), input_rows_count);\n+        else if (const ColumnConst * col_const_fixed = checkAndGetColumnConst<ColumnFixedString>(column_string.get()))\n+            return executeForSource(\n+                column_start, column_length, start_const, length_const, ConstSource<FixedStringSource>(*col_const_fixed), input_rows_count);\n+        else\n+            throw Exception(\n+                \"Illegal column \" + arguments[0].column->getName() + \" of first argument of function \" + getName(),\n+                ErrorCodes::ILLEGAL_COLUMN);\n+    }\n+\n+    template <class Source>\n+    ColumnPtr executeForSource(\n+        const ColumnPtr & column_start,\n+        const ColumnPtr & column_length,\n+        std::optional<Int64> start_const,\n+        std::optional<Int64> length_const,\n+        Source && source,\n+        size_t input_rows_count) const\n+    {\n+        auto col_res = ColumnString::create();\n+\n+        if (!column_length)\n+        {\n+            if (start_const)\n+            {\n+                Int64 start_value = start_const.value();\n+                if (start_value > 0)\n+                    bitSliceFromLeftConstantOffsetUnbounded(\n+                        source, StringSink(*col_res, input_rows_count), static_cast<size_t>(start_value - 1));\n+                else if (start_value < 0)\n+                    bitSliceFromRightConstantOffsetUnbounded(\n+                        source, StringSink(*col_res, input_rows_count), -static_cast<size_t>(start_value));\n+                else\n+                    throw Exception(\"Indices in strings are 1-based\", ErrorCodes::ZERO_ARRAY_OR_TUPLE_INDEX);\n+            }\n+            else\n+                bitSliceDynamicOffsetUnbounded(source, StringSink(*col_res, input_rows_count), *column_start);\n+        }\n+        else\n+        {\n+            if (start_const && length_const)\n+            {\n+                Int64 start_value = start_const.value();\n+                Int64 length_value = length_const.value();\n+                if (start_value > 0)\n+                    bitSliceFromLeftConstantOffsetBounded(\n+                        source, StringSink(*col_res, input_rows_count), static_cast<size_t>(start_value - 1), length_value);\n+                else if (start_value < 0)\n+                    bitSliceFromRightConstantOffsetBounded(\n+                        source, StringSink(*col_res, input_rows_count), -static_cast<size_t>(start_value), length_value);\n+                else\n+                    throw Exception(\"Indices in strings are 1-based\", ErrorCodes::ZERO_ARRAY_OR_TUPLE_INDEX);\n+            }\n+            else\n+                bitSliceDynamicOffsetBounded(source, StringSink(*col_res, input_rows_count), *column_start, *column_length);\n+        }\n+\n+        return col_res;\n+    }\n+\n+    void writeSliceWithLeftShift(const StringSource::Slice & slice, StringSink & sink, size_t shift_bit, size_t abandon_last_bit = 0) const\n+    {\n+        if (!shift_bit && !abandon_last_bit)\n+        {\n+            writeSlice(slice, sink);\n+            return;\n+        }\n+        size_t size = slice.size;\n+        if (!size)\n+            return;\n+        bool abandon_last_byte = abandon_last_bit + shift_bit >= word_size;\n+        if (abandon_last_byte) // shift may eliminate last byte\n+            size--;\n+        sink.elements.resize(sink.current_offset + size);\n+        UInt8 * out = &sink.elements[sink.current_offset];\n+        const UInt8 * input = slice.data;\n+\n+        for (size_t i = 0; i < size - 1; i++)\n+        {\n+            out[i] = (input[i] << shift_bit) | (input[i + 1] >> (word_size - shift_bit));\n+        }\n+        if (abandon_last_byte)\n+        {\n+            out[size - 1] = (input[size - 1] << shift_bit) | (input[size] >> (word_size - shift_bit));\n+            out[size - 1] = out[size - 1] & (0xFF << (abandon_last_bit + shift_bit - word_size));\n+        }\n+        else\n+        {\n+            out[size - 1] = (input[size - 1] << shift_bit) & (0xFF << (abandon_last_bit + shift_bit));\n+        }\n+\n+\n+        sink.current_offset += size;\n+    }\n+\n+\n+    template <class Source>\n+    void bitSliceFromLeftConstantOffsetUnbounded(Source && src, StringSink && sink, size_t offset) const\n+    {\n+        size_t offset_byte = offset / word_size;\n+        size_t offset_bit = offset % word_size;\n+        while (!src.isEnd())\n+        {\n+            auto sl = src.getSliceFromLeft(offset_byte);\n+            if (sl.size)\n+                writeSliceWithLeftShift(sl, sink, offset_bit);\n+\n+            sink.next();\n+            src.next();\n+        }\n+    }\n+\n+    template <class Source>\n+    void bitSliceFromRightConstantOffsetUnbounded(Source && src, StringSink && sink, size_t offset) const\n+    {\n+        size_t offset_byte = offset / word_size;\n+        size_t offset_bit = (word_size - (offset % word_size)) % word_size; // offset_bit always represent left offset bit\n+        if (offset_bit)\n+            offset_byte++;\n+        while (!src.isEnd())\n+        {\n+            auto slice = src.getSliceFromRight(offset_byte);\n+            size_t size = src.getElementSize();\n+            bool left_truncate = offset_byte > size;\n+            size_t shift_bit = left_truncate ? 0 : offset_bit;\n+            if (slice.size)\n+                writeSliceWithLeftShift(slice, sink, shift_bit);\n+\n+            sink.next();\n+            src.next();\n+        }\n+    }\n+\n+    template <class Source>\n+    void bitSliceDynamicOffsetUnbounded(Source && src, StringSink && sink, const IColumn & offset_column) const\n+    {\n+        while (!src.isEnd())\n+        {\n+            auto row_num = src.rowNum();\n+            Int64 start = offset_column.getInt(row_num);\n+            if (start != 0)\n+            {\n+                typename std::decay_t<Source>::Slice slice;\n+                size_t shift_bit;\n+\n+                if (start > 0)\n+                {\n+                    UInt64 offset = start - 1;\n+                    size_t offset_byte = offset / word_size;\n+                    size_t offset_bit = offset % word_size;\n+                    shift_bit = offset_bit;\n+                    slice = src.getSliceFromLeft(offset_byte);\n+                }\n+                else\n+                {\n+                    UInt64 offset = -static_cast<UInt64>(start);\n+                    size_t offset_byte = offset / word_size;\n+                    size_t offset_bit = (word_size - (offset % word_size)) % word_size; // offset_bit always represent left offset bit\n+                    if (offset_bit)\n+                        offset_byte++;\n+                    size_t size = src.getElementSize();\n+                    bool left_truncate = offset_byte > size;\n+                    shift_bit = left_truncate ? 0 : offset_bit;\n+                    slice = src.getSliceFromRight(offset_byte);\n+                }\n+                if (slice.size)\n+                    writeSliceWithLeftShift(slice, sink, shift_bit);\n+            }\n+\n+            sink.next();\n+            src.next();\n+        }\n+    }\n+\n+    template <class Source>\n+    void bitSliceFromLeftConstantOffsetBounded(Source && src, StringSink && sink, size_t offset, ssize_t length) const\n+    {\n+        size_t offset_byte = offset / word_size;\n+        size_t offset_bit = offset % word_size;\n+        size_t shift_bit = offset_bit;\n+        size_t length_byte = 0;\n+        size_t over_bit = 0;\n+        if (length > 0)\n+        {\n+            length_byte = (length + offset_bit) / word_size;\n+            over_bit = (length + offset_bit) % word_size;\n+            if (over_bit && (length_byte || over_bit > offset_bit)) // begin and end are not in same byte OR there are gaps\n+                length_byte++;\n+        }\n+\n+        while (!src.isEnd())\n+        {\n+            ssize_t remain_byte = src.getElementSize() - offset_byte;\n+            if (length < 0)\n+            {\n+                length_byte = std::max(remain_byte + (length / word_size), static_cast<ssize_t>(0));\n+                over_bit = word_size + (length % word_size);\n+                if (length_byte == 1 && over_bit <= offset_bit) // begin and end are in same byte AND there are no gaps\n+                    length_byte = 0;\n+            }\n+            bool right_truncate = static_cast<ssize_t>(length_byte) > remain_byte;\n+            size_t abandon_last_bit = (over_bit && !right_truncate) ? word_size - over_bit : 0;\n+            auto slice = src.getSliceFromLeft(offset_byte, length_byte);\n+            if (slice.size)\n+                writeSliceWithLeftShift(slice, sink, shift_bit, abandon_last_bit);\n+\n+            sink.next();\n+            src.next();\n+        }\n+    }\n+\n+\n+    template <class Source>\n+    void bitSliceFromRightConstantOffsetBounded(Source && src, StringSink && sink, size_t offset, ssize_t length) const\n+    {\n+        size_t offset_byte = offset / word_size;\n+        size_t offset_bit = (word_size - (offset % word_size)) % word_size; // offset_bit always represent left offset bit\n+        if (offset_bit)\n+            offset_byte++;\n+        size_t length_byte = 0;\n+        size_t over_bit = 0;\n+        if (length > 0)\n+        {\n+            length_byte = (length + offset_bit) / word_size;\n+            over_bit = (length + offset_bit) % word_size;\n+            if (over_bit && (length_byte || over_bit > offset_bit)) // begin and end are not in same byte OR there are gaps\n+                length_byte++;\n+        }\n+\n+        while (!src.isEnd())\n+        {\n+            size_t size = src.getElementSize();\n+            if (length < 0)\n+            {\n+                length_byte = std::max(static_cast<ssize_t>(offset_byte) + (length / word_size), static_cast<ssize_t>(0));\n+                over_bit = word_size + (length % word_size);\n+                if (length_byte == 1 && over_bit <= offset_bit) // begin and end are in same byte AND there are no gaps\n+                    length_byte = 0;\n+            }\n+            bool left_truncate = offset_byte > size;\n+            bool right_truncate = length_byte > offset_byte;\n+            size_t shift_bit = left_truncate ? 0 : offset_bit;\n+            size_t abandon_last_bit = (over_bit && !right_truncate) ? word_size - over_bit : 0;\n+            auto slice = src.getSliceFromRight(offset_byte, length_byte);\n+            if (slice.size)\n+                writeSliceWithLeftShift(slice, sink, shift_bit, abandon_last_bit);\n+\n+            sink.next();\n+            src.next();\n+        }\n+    }\n+\n+    template <class Source>\n+    void bitSliceDynamicOffsetBounded(Source && src, StringSink && sink, const IColumn & offset_column, const IColumn & length_column) const\n+    {\n+        while (!src.isEnd())\n+        {\n+            size_t row_num = src.rowNum();\n+            Int64 start = offset_column.getInt(row_num);\n+            Int64 length = length_column.getInt(row_num);\n+\n+            if (start && length)\n+            {\n+                bool left_offset = start > 0;\n+                size_t offset = left_offset ? static_cast<size_t>(start - 1) : -static_cast<size_t>(start);\n+                size_t size = src.getElementSize();\n+\n+                size_t offset_byte;\n+                size_t offset_bit;\n+                size_t shift_bit;\n+                if (left_offset)\n+                {\n+                    offset_byte = offset / word_size;\n+                    offset_bit = offset % word_size;\n+                    shift_bit = offset_bit;\n+                }\n+                else\n+                {\n+                    offset_byte = offset / word_size;\n+                    offset_bit = (word_size - (offset % word_size)) % word_size; // offset_bit always represent left offset bit\n+                    if (offset_bit)\n+                        offset_byte++;\n+                    bool left_truncate = offset_byte > size;\n+                    shift_bit = left_truncate ? 0 : offset_bit;\n+                }\n+\n+                ssize_t remain_byte = left_offset ? size - offset_byte : offset_byte;\n+\n+                size_t length_byte;\n+                size_t over_bit;\n+                if (length > 0)\n+                {\n+                    length_byte = (length + offset_bit) / word_size;\n+                    over_bit = (length + offset_bit) % word_size;\n+                    if (over_bit && (length_byte || (over_bit > offset_bit))) // begin and end are not in same byte OR there are gaps\n+                        length_byte++;\n+                }\n+                else\n+                {\n+                    length_byte = std::max(remain_byte + (static_cast<ssize_t>(length) / word_size), static_cast<ssize_t>(0));\n+                    over_bit = word_size + (length % word_size);\n+                    if (length_byte == 1 && over_bit <= offset_bit) // begin and end are in same byte AND there are no gaps\n+                        length_byte = 0;\n+                }\n+\n+                bool right_truncate = static_cast<ssize_t>(length_byte) > remain_byte;\n+                size_t abandon_last_bit = (over_bit && !right_truncate) ? word_size - over_bit : 0;\n+                auto slice = left_offset ? src.getSliceFromLeft(offset_byte, length_byte) : src.getSliceFromRight(offset_byte, length_byte);\n+                if (slice.size)\n+                    writeSliceWithLeftShift(slice, sink, shift_bit, abandon_last_bit);\n+            }\n+\n+            sink.next();\n+            src.next();\n+        }\n+    }\n+};\n+\n+\n+void registerFunctionBitSlice(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionBitSlice>();\n+}\n+\n+\n+}\ndiff --git a/src/Functions/registerFunctionsArithmetic.cpp b/src/Functions/registerFunctionsArithmetic.cpp\nindex 857f370fde32..d3d82ca0dd84 100644\n--- a/src/Functions/registerFunctionsArithmetic.cpp\n+++ b/src/Functions/registerFunctionsArithmetic.cpp\n@@ -20,6 +20,7 @@ void registerFunctionBitXor(FunctionFactory & factory);\n void registerFunctionBitNot(FunctionFactory & factory);\n void registerFunctionBitShiftLeft(FunctionFactory & factory);\n void registerFunctionBitShiftRight(FunctionFactory & factory);\n+void registerFunctionBitSlice(FunctionFactory & factory);\n void registerFunctionBitRotateLeft(FunctionFactory & factory);\n void registerFunctionBitRotateRight(FunctionFactory & factory);\n void registerFunctionBitCount(FunctionFactory & factory);\n@@ -64,6 +65,7 @@ void registerFunctionsArithmetic(FunctionFactory & factory)\n     registerFunctionBitRotateLeft(factory);\n     registerFunctionBitRotateRight(factory);\n     registerFunctionBitCount(factory);\n+    registerFunctionBitSlice(factory);\n     registerFunctionLeast(factory);\n     registerFunctionGreatest(factory);\n     registerFunctionBitTest(factory);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02154_bit_slice_for_fixedstring.reference b/tests/queries/0_stateless/02154_bit_slice_for_fixedstring.reference\nnew file mode 100644\nindex 000000000000..1f9e0f10266b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02154_bit_slice_for_fixedstring.reference\n@@ -0,0 +1,244 @@\n+Const Offset\n+1\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+2\tHello\\0\t10010000110010101101100011011000110111100000000\t100100001100101011011000110110001101111000000000\n+3\tHello\\0\t0010000110010101101100011011000110111100000000\t001000011001010110110001101100011011110000000000\n+4\tHello\\0\t010000110010101101100011011000110111100000000\t010000110010101101100011011000110111100000000000\n+5\tHello\\0\t10000110010101101100011011000110111100000000\t100001100101011011000110110001101111000000000000\n+6\tHello\\0\t0000110010101101100011011000110111100000000\t000011001010110110001101100011011110000000000000\n+7\tHello\\0\t000110010101101100011011000110111100000000\t000110010101101100011011000110111100000000000000\n+8\tHello\\0\t00110010101101100011011000110111100000000\t001100101011011000110110001101111000000000000000\n+9\tHello\\0\t0110010101101100011011000110111100000000\t0110010101101100011011000110111100000000\n+10\tHello\\0\t110010101101100011011000110111100000000\t1100101011011000110110001101111000000000\n+11\tHello\\0\t10010101101100011011000110111100000000\t1001010110110001101100011011110000000000\n+12\tHello\\0\t0010101101100011011000110111100000000\t0010101101100011011000110111100000000000\n+13\tHello\\0\t010101101100011011000110111100000000\t0101011011000110110001101111000000000000\n+14\tHello\\0\t10101101100011011000110111100000000\t1010110110001101100011011110000000000000\n+15\tHello\\0\t0101101100011011000110111100000000\t0101101100011011000110111100000000000000\n+16\tHello\\0\t101101100011011000110111100000000\t1011011000110110001101111000000000000000\n+-1\tHello\\0\t0\t00000000\n+-2\tHello\\0\t00\t00000000\n+-3\tHello\\0\t000\t00000000\n+-4\tHello\\0\t0000\t00000000\n+-5\tHello\\0\t00000\t00000000\n+-6\tHello\\0\t000000\t00000000\n+-7\tHello\\0\t0000000\t00000000\n+-8\tHello\\0\t00000000\t00000000\n+-9\tHello\\0\t100000000\t1000000000000000\n+-10\tHello\\0\t1100000000\t1100000000000000\n+-11\tHello\\0\t11100000000\t1110000000000000\n+-12\tHello\\0\t111100000000\t1111000000000000\n+-13\tHello\\0\t0111100000000\t0111100000000000\n+-14\tHello\\0\t10111100000000\t1011110000000000\n+-15\tHello\\0\t110111100000000\t1101111000000000\n+-16\tHello\\0\t0110111100000000\t0110111100000000\n+Const Truncate Offset\n+49\tHello\\0\t\t\n+-49\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+Const Nullable Offset\n+1\t\\N\t\\N\t\\N\n+\\N\tHello\\0\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\n+Const Offset, Const Length\n+1\t1\tHello\\0\t0\t00000000\n+2\t2\tHello\\0\t10\t10000000\n+3\t3\tHello\\0\t001\t00100000\n+4\t4\tHello\\0\t0100\t01000000\n+5\t5\tHello\\0\t10000\t10000000\n+6\t6\tHello\\0\t000011\t00001100\n+7\t7\tHello\\0\t0001100\t00011000\n+8\t8\tHello\\0\t00110010\t00110010\n+9\t9\tHello\\0\t011001010\t0110010100000000\n+10\t10\tHello\\0\t1100101011\t1100101011000000\n+11\t11\tHello\\0\t10010101101\t1001010110100000\n+12\t12\tHello\\0\t001010110110\t0010101101100000\n+13\t13\tHello\\0\t0101011011000\t0101011011000000\n+14\t14\tHello\\0\t10101101100011\t1010110110001100\n+15\t15\tHello\\0\t010110110001101\t0101101100011010\n+16\t16\tHello\\0\t1011011000110110\t1011011000110110\n+1\t-1\tHello\\0\t01001000011001010110110001101100011011110000000\t010010000110010101101100011011000110111100000000\n+2\t-2\tHello\\0\t100100001100101011011000110110001101111000000\t100100001100101011011000110110001101111000000000\n+3\t-3\tHello\\0\t0010000110010101101100011011000110111100000\t001000011001010110110001101100011011110000000000\n+4\t-4\tHello\\0\t01000011001010110110001101100011011110000\t010000110010101101100011011000110111100000000000\n+5\t-5\tHello\\0\t100001100101011011000110110001101111000\t1000011001010110110001101100011011110000\n+6\t-6\tHello\\0\t0000110010101101100011011000110111100\t0000110010101101100011011000110111100000\n+7\t-7\tHello\\0\t00011001010110110001101100011011110\t0001100101011011000110110001101111000000\n+8\t-8\tHello\\0\t001100101011011000110110001101111\t0011001010110110001101100011011110000000\n+9\t-9\tHello\\0\t0110010101101100011011000110111\t01100101011011000110110001101110\n+10\t-10\tHello\\0\t11001010110110001101100011011\t11001010110110001101100011011000\n+11\t-11\tHello\\0\t100101011011000110110001101\t10010101101100011011000110100000\n+12\t-12\tHello\\0\t0010101101100011011000110\t00101011011000110110001100000000\n+13\t-13\tHello\\0\t01010110110001101100011\t010101101100011011000110\n+14\t-14\tHello\\0\t101011011000110110001\t101011011000110110001000\n+15\t-15\tHello\\0\t0101101100011011000\t010110110001101100000000\n+16\t-16\tHello\\0\t10110110001101100\t101101100011011000000000\n+-1\t1\tHello\\0\t0\t00000000\n+-2\t2\tHello\\0\t00\t00000000\n+-3\t3\tHello\\0\t000\t00000000\n+-4\t4\tHello\\0\t0000\t00000000\n+-5\t5\tHello\\0\t00000\t00000000\n+-6\t6\tHello\\0\t000000\t00000000\n+-7\t7\tHello\\0\t0000000\t00000000\n+-8\t8\tHello\\0\t00000000\t00000000\n+-9\t9\tHello\\0\t100000000\t1000000000000000\n+-10\t10\tHello\\0\t1100000000\t1100000000000000\n+-11\t11\tHello\\0\t11100000000\t1110000000000000\n+-12\t12\tHello\\0\t111100000000\t1111000000000000\n+-13\t13\tHello\\0\t0111100000000\t0111100000000000\n+-14\t14\tHello\\0\t10111100000000\t1011110000000000\n+-15\t15\tHello\\0\t110111100000000\t1101111000000000\n+-16\t16\tHello\\0\t0110111100000000\t0110111100000000\n+-1\t-16\tHello\\0\t\t\n+-2\t-15\tHello\\0\t\t\n+-3\t-14\tHello\\0\t\t\n+-4\t-13\tHello\\0\t\t\n+-5\t-12\tHello\\0\t\t\n+-6\t-11\tHello\\0\t\t\n+-7\t-10\tHello\\0\t\t\n+-8\t-9\tHello\\0\t\t\n+-9\t-8\tHello\\0\t1\t10000000\n+-10\t-7\tHello\\0\t110\t11000000\n+-11\t-6\tHello\\0\t11100\t11100000\n+-12\t-5\tHello\\0\t1111000\t11110000\n+-13\t-4\tHello\\0\t011110000\t0111100000000000\n+-14\t-3\tHello\\0\t10111100000\t1011110000000000\n+-15\t-2\tHello\\0\t1101111000000\t1101111000000000\n+-16\t-1\tHello\\0\t011011110000000\t0110111100000000\n+Const Truncate Offset, Const Truncate Length\n+36\t16\tHello\\0\t0111100000000\t0111100000000000\n+49\t1\tHello\\0\t\t\n+-52\t-44\tHello\\0\t0100\t01000000\n+-49\t-48\tHello\\0\t\t\n+-49\t49\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+Const Nullable Offset, Const Nullable Length\n+1\t1\t\\N\t\\N\t\\N\n+\\N\t1\tHello\\0\t\\N\t\\N\n+1\t\\N\tHello\\0\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\t\\N\n+Dynamic Offset, Dynamic Length\n+0\t0\tHello\\0\t\t\n+1\t1\tHello\\0\t0\t00000000\n+2\t2\tHello\\0\t10\t10000000\n+3\t3\tHello\\0\t001\t00100000\n+4\t4\tHello\\0\t0100\t01000000\n+5\t5\tHello\\0\t10000\t10000000\n+6\t6\tHello\\0\t000011\t00001100\n+7\t7\tHello\\0\t0001100\t00011000\n+8\t8\tHello\\0\t00110010\t00110010\n+9\t9\tHello\\0\t011001010\t0110010100000000\n+10\t10\tHello\\0\t1100101011\t1100101011000000\n+11\t11\tHello\\0\t10010101101\t1001010110100000\n+12\t12\tHello\\0\t001010110110\t0010101101100000\n+13\t13\tHello\\0\t0101011011000\t0101011011000000\n+14\t14\tHello\\0\t10101101100011\t1010110110001100\n+15\t15\tHello\\0\t010110110001101\t0101101100011010\n+0\t0\tHello\\0\t\t\n+1\t-1\tHello\\0\t01001000011001010110110001101100011011110000000\t010010000110010101101100011011000110111100000000\n+2\t-2\tHello\\0\t100100001100101011011000110110001101111000000\t100100001100101011011000110110001101111000000000\n+3\t-3\tHello\\0\t0010000110010101101100011011000110111100000\t001000011001010110110001101100011011110000000000\n+4\t-4\tHello\\0\t01000011001010110110001101100011011110000\t010000110010101101100011011000110111100000000000\n+5\t-5\tHello\\0\t100001100101011011000110110001101111000\t1000011001010110110001101100011011110000\n+6\t-6\tHello\\0\t0000110010101101100011011000110111100\t0000110010101101100011011000110111100000\n+7\t-7\tHello\\0\t00011001010110110001101100011011110\t0001100101011011000110110001101111000000\n+8\t-8\tHello\\0\t001100101011011000110110001101111\t0011001010110110001101100011011110000000\n+9\t-9\tHello\\0\t0110010101101100011011000110111\t01100101011011000110110001101110\n+10\t-10\tHello\\0\t11001010110110001101100011011\t11001010110110001101100011011000\n+11\t-11\tHello\\0\t100101011011000110110001101\t10010101101100011011000110100000\n+12\t-12\tHello\\0\t0010101101100011011000110\t00101011011000110110001100000000\n+13\t-13\tHello\\0\t01010110110001101100011\t010101101100011011000110\n+14\t-14\tHello\\0\t101011011000110110001\t101011011000110110001000\n+15\t-15\tHello\\0\t0101101100011011000\t010110110001101100000000\n+0\t-16\tHello\\0\t\t\n+-1\t-15\tHello\\0\t\t\n+-2\t-14\tHello\\0\t\t\n+-3\t-13\tHello\\0\t\t\n+-4\t-12\tHello\\0\t\t\n+-5\t-11\tHello\\0\t\t\n+-6\t-10\tHello\\0\t\t\n+-7\t-9\tHello\\0\t\t\n+-8\t-8\tHello\\0\t\t\n+-9\t-7\tHello\\0\t10\t10000000\n+-10\t-6\tHello\\0\t1100\t11000000\n+-11\t-5\tHello\\0\t111000\t11100000\n+-12\t-4\tHello\\0\t11110000\t11110000\n+-13\t-3\tHello\\0\t0111100000\t0111100000000000\n+-14\t-2\tHello\\0\t101111000000\t1011110000000000\n+-15\t-1\tHello\\0\t11011110000000\t1101111000000000\n+0\t0\tHello\\0\t\t\n+-1\t1\tHello\\0\t0\t00000000\n+-2\t2\tHello\\0\t00\t00000000\n+-3\t3\tHello\\0\t000\t00000000\n+-4\t4\tHello\\0\t0000\t00000000\n+-5\t5\tHello\\0\t00000\t00000000\n+-6\t6\tHello\\0\t000000\t00000000\n+-7\t7\tHello\\0\t0000000\t00000000\n+-8\t8\tHello\\0\t00000000\t00000000\n+-9\t9\tHello\\0\t100000000\t1000000000000000\n+-10\t10\tHello\\0\t1100000000\t1100000000000000\n+-11\t11\tHello\\0\t11100000000\t1110000000000000\n+-12\t12\tHello\\0\t111100000000\t1111000000000000\n+-13\t13\tHello\\0\t0111100000000\t0111100000000000\n+-14\t14\tHello\\0\t10111100000000\t1011110000000000\n+-15\t15\tHello\\0\t110111100000000\t1101111000000000\n+Dynamic Truncate Offset, Dynamic Truncate Length\n+-8\t8\tHello\\0\t00000000\t00000000\n+-7\t8\tHello\\0\t0000000\t00000000\n+-6\t8\tHello\\0\t000000\t00000000\n+-5\t8\tHello\\0\t00000\t00000000\n+-4\t8\tHello\\0\t0000\t00000000\n+-3\t8\tHello\\0\t000\t00000000\n+-2\t8\tHello\\0\t00\t00000000\n+-1\t8\tHello\\0\t0\t00000000\n+0\t8\tHello\\0\t\t\n+-4\t0\tHello\\0\t\t\n+-4\t1\tHello\\0\t0\t00000000\n+-4\t2\tHello\\0\t00\t00000000\n+-4\t3\tHello\\0\t000\t00000000\n+-4\t4\tHello\\0\t0000\t00000000\n+-4\t5\tHello\\0\t0000\t00000000\n+-4\t6\tHello\\0\t0000\t00000000\n+-4\t7\tHello\\0\t0000\t00000000\n+-4\t8\tHello\\0\t0000\t00000000\n+-44\t8\tHello\\0\t10000110\t10000110\n+-45\t8\tHello\\0\t01000011\t01000011\n+-46\t8\tHello\\0\t00100001\t00100001\n+-47\t8\tHello\\0\t10010000\t10010000\n+-48\t8\tHello\\0\t01001000\t01001000\n+-49\t8\tHello\\0\t0100100\t01001000\n+-50\t8\tHello\\0\t010010\t01001000\n+-51\t8\tHello\\0\t01001\t01001000\n+-52\t8\tHello\\0\t0100\t01000000\n+-52\t0\tHello\\0\t\t\n+-52\t1\tHello\\0\t\t\n+-52\t2\tHello\\0\t\t\n+-52\t3\tHello\\0\t\t\n+-52\t4\tHello\\0\t\t\n+-52\t5\tHello\\0\t0\t00000000\n+-52\t6\tHello\\0\t01\t01000000\n+-52\t7\tHello\\0\t010\t01000000\n+-52\t8\tHello\\0\t0100\t01000000\n+-52\t48\tHello\\0\t01001000011001010110110001101100011011110000\t010010000110010101101100011011000110111100000000\n+-52\t49\tHello\\0\t010010000110010101101100011011000110111100000\t010010000110010101101100011011000110111100000000\n+-52\t50\tHello\\0\t0100100001100101011011000110110001101111000000\t010010000110010101101100011011000110111100000000\n+-52\t51\tHello\\0\t01001000011001010110110001101100011011110000000\t010010000110010101101100011011000110111100000000\n+-52\t52\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+-52\t53\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+-52\t54\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+-52\t55\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+-52\t56\tHello\\0\t010010000110010101101100011011000110111100000000\t010010000110010101101100011011000110111100000000\n+Dynamic Nullable Offset, Dynamic Nullable Length\n+0\t0\tHello\\0\t\t\n+\\N\t1\tHello\\0\t\\N\t\\N\n+2\t\\N\tHello\\0\t\\N\t\\N\n+3\t3\t\\N\t\\N\t\\N\n+4\t4\tHello\\0\t0100\t01000000\n+\\N\t5\tHello\\0\t\\N\t\\N\n+6\t\\N\tHello\\0\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\t\\N\n+8\t8\tHello\\0\t00110010\t00110010\n+\\N\t9\tHello\\0\t\\N\t\\N\n+10\t\\N\tHello\\0\t\\N\t\\N\n+11\t11\t\\N\t\\N\t\\N\n+12\t12\tHello\\0\t001010110110\t0010101101100000\n+\\N\t13\tHello\\0\t\\N\t\\N\n+14\t\\N\tHello\\0\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\t\\N\ndiff --git a/tests/queries/0_stateless/02154_bit_slice_for_fixedstring.sql b/tests/queries/0_stateless/02154_bit_slice_for_fixedstring.sql\nnew file mode 100644\nindex 000000000000..f3e803396e9d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02154_bit_slice_for_fixedstring.sql\n@@ -0,0 +1,143 @@\n+SELECT 'Const Offset';\n+select 1 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 2 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 3 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 4 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 5 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 6 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 7 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 8 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 9 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 10 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 11 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 12 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 13 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 14 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 15 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 16 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+select -1 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -2 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -3 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -4 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -5 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -6 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -7 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -8 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -9 as offset, toFixedString('Hello', 6) as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -10 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -11 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -12 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -13 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -14 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -15 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -16 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+SELECT 'Const Truncate Offset';\n+select 49 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -49 as offset, toFixedString('Hello', 6) as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+SELECT 'Const Nullable Offset';\n+select 1 as offset, null as s,          subString(bin(s), offset), bin(bitSlice(s, offset));\n+select null as offset, toFixedString('Hello', 6) as s,    subString(bin(s), offset), bin(bitSlice(s, offset));\n+select null as offset, null as s,       subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+SELECT 'Const Offset, Const Length';\n+select 1 as offset, 1 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 2 as offset, 2 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 3 as offset, 3 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 4 as offset, 4 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 5 as offset, 5 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 6 as offset, 6 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 7 as offset, 7 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 8 as offset, 8 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 9 as offset, 9 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 10 as offset, 10 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 11 as offset, 11 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 12 as offset, 12 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 13 as offset, 13 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 14 as offset, 14 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 15 as offset, 15 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 16 as offset, 16 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select 1 as offset, -1 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 2 as offset, -2 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 3 as offset, -3 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 4 as offset, -4 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 5 as offset, -5 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 6 as offset, -6 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 7 as offset, -7 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 8 as offset, -8 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 9 as offset, -9 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 10 as offset, -10 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 11 as offset, -11 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 12 as offset, -12 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 13 as offset, -13 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 14 as offset, -14 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 15 as offset, -15 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 16 as offset, -16 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select -1 as offset, 1 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -2 as offset, 2 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -3 as offset, 3 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -4 as offset, 4 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -5 as offset, 5 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -6 as offset, 6 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -7 as offset, 7 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -8 as offset, 8 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -9 as offset, 9 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -10 as offset, 10 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -11 as offset, 11 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -12 as offset, 12 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -13 as offset, 13 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -14 as offset, 14 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -15 as offset, 15 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -16 as offset, 16 as length, toFixedString('Hello', 6) as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select -1 as offset, -16 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -2 as offset, -15 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -3 as offset, -14 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -4 as offset, -13 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -5 as offset, -12 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -6 as offset, -11 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -7 as offset, -10 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -8 as offset, -9 as length, toFixedString('Hello', 6) as s,    subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -9 as offset, -8 as length, toFixedString('Hello', 6) as s,    subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -10 as offset, -7 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -11 as offset, -6 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -12 as offset, -5 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -13 as offset, -4 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -14 as offset, -3 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -15 as offset, -2 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -16 as offset, -1 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select 'Const Truncate Offset, Const Truncate Length';\n+select 36 as offset, 16 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 49 as offset, 1 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -52 as offset, -44 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -49 as offset, -48 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -49 as offset,  49 as length, toFixedString('Hello', 6) as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select 'Const Nullable Offset, Const Nullable Length';\n+select 1 as offset, 1 as length, null as s,         subString(bin(s), offset , length), bin(bitSlice(s, offset, length));\n+select null as offset, 1 as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 1 as offset, null as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset , length), bin(bitSlice(s, offset, length));\n+select null as offset, null as length, null as s,   subString(bin(s), offset , length), bin(bitSlice(s, offset, length));\n+\n+select 'Dynamic Offset, Dynamic Length';\n+select number as offset, number as length, toFixedString('Hello', 6) as s,        subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+select number as offset, -number as length, toFixedString('Hello', 6) as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+select -number as offset, -16+number as length, toFixedString('Hello', 6) as s,   subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+select -number as offset, number as length, toFixedString('Hello', 6) as s,        subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+\n+select 'Dynamic Truncate Offset, Dynamic Truncate Length';\n+select number-8 as offset, 8 as length, toFixedString('Hello', 6) as s,        subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -4 as offset, number as length, toFixedString('Hello', 6) as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -44-number as offset, 8 as length, toFixedString('Hello', 6) as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -52 as offset, number as length, toFixedString('Hello', 6) as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -52 as offset, number + 48 as length, toFixedString('Hello', 6) as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+\n+select 'Dynamic Nullable Offset, Dynamic Nullable Length';\n+select if(number%4 ==1 or number%8==7, null, number) as offset, if(number%4==2 or number%8==7, null, number) as length,if(number%4 ==3, null, toFixedString('Hello', 6)) as s,\n+       subString(bin(s), offset, length), bin(bitSlice(s, offset , length))\n+from numbers(16);\ndiff --git a/tests/queries/0_stateless/02154_bit_slice_for_string.reference b/tests/queries/0_stateless/02154_bit_slice_for_string.reference\nnew file mode 100644\nindex 000000000000..71a80c7abf3b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02154_bit_slice_for_string.reference\n@@ -0,0 +1,244 @@\n+Const Offset\n+1\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+2\tHello\t100100001100101011011000110110001101111\t1001000011001010110110001101100011011110\n+3\tHello\t00100001100101011011000110110001101111\t0010000110010101101100011011000110111100\n+4\tHello\t0100001100101011011000110110001101111\t0100001100101011011000110110001101111000\n+5\tHello\t100001100101011011000110110001101111\t1000011001010110110001101100011011110000\n+6\tHello\t00001100101011011000110110001101111\t0000110010101101100011011000110111100000\n+7\tHello\t0001100101011011000110110001101111\t0001100101011011000110110001101111000000\n+8\tHello\t001100101011011000110110001101111\t0011001010110110001101100011011110000000\n+9\tHello\t01100101011011000110110001101111\t01100101011011000110110001101111\n+10\tHello\t1100101011011000110110001101111\t11001010110110001101100011011110\n+11\tHello\t100101011011000110110001101111\t10010101101100011011000110111100\n+12\tHello\t00101011011000110110001101111\t00101011011000110110001101111000\n+13\tHello\t0101011011000110110001101111\t01010110110001101100011011110000\n+14\tHello\t101011011000110110001101111\t10101101100011011000110111100000\n+15\tHello\t01011011000110110001101111\t01011011000110110001101111000000\n+16\tHello\t1011011000110110001101111\t10110110001101100011011110000000\n+-1\tHello\t1\t10000000\n+-2\tHello\t11\t11000000\n+-3\tHello\t111\t11100000\n+-4\tHello\t1111\t11110000\n+-5\tHello\t01111\t01111000\n+-6\tHello\t101111\t10111100\n+-7\tHello\t1101111\t11011110\n+-8\tHello\t01101111\t01101111\n+-9\tHello\t001101111\t0011011110000000\n+-10\tHello\t0001101111\t0001101111000000\n+-11\tHello\t10001101111\t1000110111100000\n+-12\tHello\t110001101111\t1100011011110000\n+-13\tHello\t0110001101111\t0110001101111000\n+-14\tHello\t10110001101111\t1011000110111100\n+-15\tHello\t110110001101111\t1101100011011110\n+-16\tHello\t0110110001101111\t0110110001101111\n+Const Truncate Offset\n+41\tHello\t\t\n+-41\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+Const Nullable Offset\n+1\t\\N\t\\N\t\\N\n+\\N\tHello\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\n+Const Offset, Const Length\n+1\t1\tHello\t0\t00000000\n+2\t2\tHello\t10\t10000000\n+3\t3\tHello\t001\t00100000\n+4\t4\tHello\t0100\t01000000\n+5\t5\tHello\t10000\t10000000\n+6\t6\tHello\t000011\t00001100\n+7\t7\tHello\t0001100\t00011000\n+8\t8\tHello\t00110010\t00110010\n+9\t9\tHello\t011001010\t0110010100000000\n+10\t10\tHello\t1100101011\t1100101011000000\n+11\t11\tHello\t10010101101\t1001010110100000\n+12\t12\tHello\t001010110110\t0010101101100000\n+13\t13\tHello\t0101011011000\t0101011011000000\n+14\t14\tHello\t10101101100011\t1010110110001100\n+15\t15\tHello\t010110110001101\t0101101100011010\n+16\t16\tHello\t1011011000110110\t1011011000110110\n+1\t-1\tHello\t010010000110010101101100011011000110111\t0100100001100101011011000110110001101110\n+2\t-2\tHello\t1001000011001010110110001101100011011\t1001000011001010110110001101100011011000\n+3\t-3\tHello\t00100001100101011011000110110001101\t0010000110010101101100011011000110100000\n+4\t-4\tHello\t010000110010101101100011011000110\t0100001100101011011000110110001100000000\n+5\t-5\tHello\t1000011001010110110001101100011\t10000110010101101100011011000110\n+6\t-6\tHello\t00001100101011011000110110001\t00001100101011011000110110001000\n+7\t-7\tHello\t000110010101101100011011000\t00011001010110110001101100000000\n+8\t-8\tHello\t0011001010110110001101100\t00110010101101100011011000000000\n+9\t-9\tHello\t01100101011011000110110\t011001010110110001101100\n+10\t-10\tHello\t110010101101100011011\t110010101101100011011000\n+11\t-11\tHello\t1001010110110001101\t100101011011000110100000\n+12\t-12\tHello\t00101011011000110\t001010110110001100000000\n+13\t-13\tHello\t010101101100011\t0101011011000110\n+14\t-14\tHello\t1010110110001\t1010110110001000\n+15\t-15\tHello\t01011011000\t0101101100000000\n+16\t-16\tHello\t101101100\t1011011000000000\n+-1\t1\tHello\t1\t10000000\n+-2\t2\tHello\t11\t11000000\n+-3\t3\tHello\t111\t11100000\n+-4\t4\tHello\t1111\t11110000\n+-5\t5\tHello\t01111\t01111000\n+-6\t6\tHello\t101111\t10111100\n+-7\t7\tHello\t1101111\t11011110\n+-8\t8\tHello\t01101111\t01101111\n+-9\t9\tHello\t001101111\t0011011110000000\n+-10\t10\tHello\t0001101111\t0001101111000000\n+-11\t11\tHello\t10001101111\t1000110111100000\n+-12\t12\tHello\t110001101111\t1100011011110000\n+-13\t13\tHello\t0110001101111\t0110001101111000\n+-14\t14\tHello\t10110001101111\t1011000110111100\n+-15\t15\tHello\t110110001101111\t1101100011011110\n+-16\t16\tHello\t0110110001101111\t0110110001101111\n+-1\t-16\tHello\t\t\n+-2\t-15\tHello\t\t\n+-3\t-14\tHello\t\t\n+-4\t-13\tHello\t\t\n+-5\t-12\tHello\t\t\n+-6\t-11\tHello\t\t\n+-7\t-10\tHello\t\t\n+-8\t-9\tHello\t\t\n+-9\t-8\tHello\t0\t00000000\n+-10\t-7\tHello\t000\t00000000\n+-11\t-6\tHello\t10001\t10001000\n+-12\t-5\tHello\t1100011\t11000110\n+-13\t-4\tHello\t011000110\t0110001100000000\n+-14\t-3\tHello\t10110001101\t1011000110100000\n+-15\t-2\tHello\t1101100011011\t1101100011011000\n+-16\t-1\tHello\t011011000110111\t0110110001101110\n+Const Truncate Offset, Const Truncate Length\n+36\t8\tHello\t01111\t01111000\n+41\t1\tHello\t\t\n+-44\t-36\tHello\t0100\t01000000\n+-41\t-40\tHello\t\t\n+-41\t41\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+Const Nullable Offset, Const Nullable Length\n+1\t1\t\\N\t\\N\t\\N\n+\\N\t1\tHello\t\\N\t\\N\n+1\t\\N\tHello\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\t\\N\n+Dynamic Offset, Dynamic Length\n+0\t0\tHello\t\t\n+1\t1\tHello\t0\t00000000\n+2\t2\tHello\t10\t10000000\n+3\t3\tHello\t001\t00100000\n+4\t4\tHello\t0100\t01000000\n+5\t5\tHello\t10000\t10000000\n+6\t6\tHello\t000011\t00001100\n+7\t7\tHello\t0001100\t00011000\n+8\t8\tHello\t00110010\t00110010\n+9\t9\tHello\t011001010\t0110010100000000\n+10\t10\tHello\t1100101011\t1100101011000000\n+11\t11\tHello\t10010101101\t1001010110100000\n+12\t12\tHello\t001010110110\t0010101101100000\n+13\t13\tHello\t0101011011000\t0101011011000000\n+14\t14\tHello\t10101101100011\t1010110110001100\n+15\t15\tHello\t010110110001101\t0101101100011010\n+0\t0\tHello\t\t\n+1\t-1\tHello\t010010000110010101101100011011000110111\t0100100001100101011011000110110001101110\n+2\t-2\tHello\t1001000011001010110110001101100011011\t1001000011001010110110001101100011011000\n+3\t-3\tHello\t00100001100101011011000110110001101\t0010000110010101101100011011000110100000\n+4\t-4\tHello\t010000110010101101100011011000110\t0100001100101011011000110110001100000000\n+5\t-5\tHello\t1000011001010110110001101100011\t10000110010101101100011011000110\n+6\t-6\tHello\t00001100101011011000110110001\t00001100101011011000110110001000\n+7\t-7\tHello\t000110010101101100011011000\t00011001010110110001101100000000\n+8\t-8\tHello\t0011001010110110001101100\t00110010101101100011011000000000\n+9\t-9\tHello\t01100101011011000110110\t011001010110110001101100\n+10\t-10\tHello\t110010101101100011011\t110010101101100011011000\n+11\t-11\tHello\t1001010110110001101\t100101011011000110100000\n+12\t-12\tHello\t00101011011000110\t001010110110001100000000\n+13\t-13\tHello\t010101101100011\t0101011011000110\n+14\t-14\tHello\t1010110110001\t1010110110001000\n+15\t-15\tHello\t01011011000\t0101101100000000\n+0\t-16\tHello\t\t\n+-1\t-15\tHello\t\t\n+-2\t-14\tHello\t\t\n+-3\t-13\tHello\t\t\n+-4\t-12\tHello\t\t\n+-5\t-11\tHello\t\t\n+-6\t-10\tHello\t\t\n+-7\t-9\tHello\t\t\n+-8\t-8\tHello\t\t\n+-9\t-7\tHello\t00\t00000000\n+-10\t-6\tHello\t0001\t00010000\n+-11\t-5\tHello\t100011\t10001100\n+-12\t-4\tHello\t11000110\t11000110\n+-13\t-3\tHello\t0110001101\t0110001101000000\n+-14\t-2\tHello\t101100011011\t1011000110110000\n+-15\t-1\tHello\t11011000110111\t1101100011011100\n+0\t0\tHello\t\t\n+-1\t1\tHello\t1\t10000000\n+-2\t2\tHello\t11\t11000000\n+-3\t3\tHello\t111\t11100000\n+-4\t4\tHello\t1111\t11110000\n+-5\t5\tHello\t01111\t01111000\n+-6\t6\tHello\t101111\t10111100\n+-7\t7\tHello\t1101111\t11011110\n+-8\t8\tHello\t01101111\t01101111\n+-9\t9\tHello\t001101111\t0011011110000000\n+-10\t10\tHello\t0001101111\t0001101111000000\n+-11\t11\tHello\t10001101111\t1000110111100000\n+-12\t12\tHello\t110001101111\t1100011011110000\n+-13\t13\tHello\t0110001101111\t0110001101111000\n+-14\t14\tHello\t10110001101111\t1011000110111100\n+-15\t15\tHello\t110110001101111\t1101100011011110\n+Dynamic Truncate Offset, Dynamic Truncate Length\n+-8\t8\tHello\t01101111\t01101111\n+-7\t8\tHello\t1101111\t11011110\n+-6\t8\tHello\t101111\t10111100\n+-5\t8\tHello\t01111\t01111000\n+-4\t8\tHello\t1111\t11110000\n+-3\t8\tHello\t111\t11100000\n+-2\t8\tHello\t11\t11000000\n+-1\t8\tHello\t1\t10000000\n+0\t8\tHello\t\t\n+-4\t0\tHello\t\t\n+-4\t1\tHello\t1\t10000000\n+-4\t2\tHello\t11\t11000000\n+-4\t3\tHello\t111\t11100000\n+-4\t4\tHello\t1111\t11110000\n+-4\t5\tHello\t1111\t11110000\n+-4\t6\tHello\t1111\t11110000\n+-4\t7\tHello\t1111\t11110000\n+-4\t8\tHello\t1111\t11110000\n+-36\t8\tHello\t10000110\t10000110\n+-37\t8\tHello\t01000011\t01000011\n+-38\t8\tHello\t00100001\t00100001\n+-39\t8\tHello\t10010000\t10010000\n+-40\t8\tHello\t01001000\t01001000\n+-41\t8\tHello\t0100100\t01001000\n+-42\t8\tHello\t010010\t01001000\n+-43\t8\tHello\t01001\t01001000\n+-44\t8\tHello\t0100\t01000000\n+-44\t0\tHello\t\t\n+-44\t1\tHello\t\t\n+-44\t2\tHello\t\t\n+-44\t3\tHello\t\t\n+-44\t4\tHello\t\t\n+-44\t5\tHello\t0\t00000000\n+-44\t6\tHello\t01\t01000000\n+-44\t7\tHello\t010\t01000000\n+-44\t8\tHello\t0100\t01000000\n+-44\t40\tHello\t010010000110010101101100011011000110\t0100100001100101011011000110110001100000\n+-44\t41\tHello\t0100100001100101011011000110110001101\t0100100001100101011011000110110001101000\n+-44\t42\tHello\t01001000011001010110110001101100011011\t0100100001100101011011000110110001101100\n+-44\t43\tHello\t010010000110010101101100011011000110111\t0100100001100101011011000110110001101110\n+-44\t44\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+-44\t45\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+-44\t46\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+-44\t47\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+-44\t48\tHello\t0100100001100101011011000110110001101111\t0100100001100101011011000110110001101111\n+Dynamic Nullable Offset, Dynamic Nullable Length\n+0\t0\tHello\t\t\n+\\N\t1\tHello\t\\N\t\\N\n+2\t\\N\tHello\t\\N\t\\N\n+3\t3\t\\N\t\\N\t\\N\n+4\t4\tHello\t0100\t01000000\n+\\N\t5\tHello\t\\N\t\\N\n+6\t\\N\tHello\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\t\\N\n+8\t8\tHello\t00110010\t00110010\n+\\N\t9\tHello\t\\N\t\\N\n+10\t\\N\tHello\t\\N\t\\N\n+11\t11\t\\N\t\\N\t\\N\n+12\t12\tHello\t001010110110\t0010101101100000\n+\\N\t13\tHello\t\\N\t\\N\n+14\t\\N\tHello\t\\N\t\\N\n+\\N\t\\N\t\\N\t\\N\t\\N\ndiff --git a/tests/queries/0_stateless/02154_bit_slice_for_string.sql b/tests/queries/0_stateless/02154_bit_slice_for_string.sql\nnew file mode 100644\nindex 000000000000..f192301a7c32\n--- /dev/null\n+++ b/tests/queries/0_stateless/02154_bit_slice_for_string.sql\n@@ -0,0 +1,144 @@\n+SELECT 'Const Offset';\n+select 1 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 2 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 3 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 4 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 5 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 6 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 7 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 8 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 9 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 10 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 11 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 12 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 13 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 14 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 15 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select 16 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+select -1 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -2 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -3 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -4 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -5 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -6 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -7 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -8 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -9 as offset, 'Hello' as s,  subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -10 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -11 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -12 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -13 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -14 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -15 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -16 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+\n+SELECT 'Const Truncate Offset';\n+select 41 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+select -41 as offset, 'Hello' as s, subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+SELECT 'Const Nullable Offset';\n+select 1 as offset, null as s,          subString(bin(s), offset), bin(bitSlice(s, offset));\n+select null as offset, 'Hello' as s,    subString(bin(s), offset), bin(bitSlice(s, offset));\n+select null as offset, null as s,       subString(bin(s), offset), bin(bitSlice(s, offset));\n+\n+SELECT 'Const Offset, Const Length';\n+select 1 as offset, 1 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 2 as offset, 2 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 3 as offset, 3 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 4 as offset, 4 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 5 as offset, 5 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 6 as offset, 6 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 7 as offset, 7 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 8 as offset, 8 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 9 as offset, 9 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 10 as offset, 10 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 11 as offset, 11 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 12 as offset, 12 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 13 as offset, 13 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 14 as offset, 14 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 15 as offset, 15 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 16 as offset, 16 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select 1 as offset, -1 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 2 as offset, -2 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 3 as offset, -3 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 4 as offset, -4 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 5 as offset, -5 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 6 as offset, -6 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 7 as offset, -7 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 8 as offset, -8 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 9 as offset, -9 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 10 as offset, -10 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 11 as offset, -11 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 12 as offset, -12 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 13 as offset, -13 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 14 as offset, -14 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 15 as offset, -15 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 16 as offset, -16 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select -1 as offset, 1 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -2 as offset, 2 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -3 as offset, 3 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -4 as offset, 4 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -5 as offset, 5 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -6 as offset, 6 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -7 as offset, 7 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -8 as offset, 8 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -9 as offset, 9 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -10 as offset, 10 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -11 as offset, 11 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -12 as offset, 12 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -13 as offset, 13 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -14 as offset, 14 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -15 as offset, 15 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -16 as offset, 16 as length, 'Hello' as s, subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select -1 as offset, -16 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -2 as offset, -15 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -3 as offset, -14 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -4 as offset, -13 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -5 as offset, -12 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -6 as offset, -11 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -7 as offset, -10 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -8 as offset, -9 as length, 'Hello' as s,    subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -9 as offset, -8 as length, 'Hello' as s,    subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -10 as offset, -7 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -11 as offset, -6 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -12 as offset, -5 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -13 as offset, -4 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -14 as offset, -3 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -15 as offset, -2 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -16 as offset, -1 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select 'Const Truncate Offset, Const Truncate Length';\n+select 36 as offset, 8 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 41 as offset, 1 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -44 as offset, -36 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -41 as offset, -40 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select -41 as offset,  41 as length, 'Hello' as s,  subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+\n+select 'Const Nullable Offset, Const Nullable Length';\n+select 1 as offset, 1 as length, null as s,         subString(bin(s), offset , length), bin(bitSlice(s, offset, length));\n+select null as offset, 1 as length, 'Hello' as s,   subString(bin(s), offset, length), bin(bitSlice(s, offset, length));\n+select 1 as offset, null as length, 'Hello' as s,   subString(bin(s), offset , length), bin(bitSlice(s, offset, length));\n+select null as offset, null as length, null as s,   subString(bin(s), offset , length), bin(bitSlice(s, offset, length));\n+\n+select 'Dynamic Offset, Dynamic Length';\n+select number as offset, number as length, 'Hello' as s,        subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+select number as offset, -number as length, 'Hello' as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+select -number as offset, -16+number as length, 'Hello' as s,   subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+select -number as offset, number as length, 'Hello' as s,        subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(16);\n+\n+select 'Dynamic Truncate Offset, Dynamic Truncate Length';\n+select number-8 as offset, 8 as length, 'Hello' as s,        subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -4 as offset, number as length, 'Hello' as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -36-number as offset, 8 as length, 'Hello' as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -44 as offset, number as length, 'Hello' as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+select -44 as offset, number + 40 as length, 'Hello' as s,       subString(bin(s), offset , length), bin(bitSlice(s, offset, length)) from numbers(9);\n+\n+select 'Dynamic Nullable Offset, Dynamic Nullable Length';\n+select if(number%4 ==1 or number%8==7, null, number) as offset, if(number%4==2 or number%8==7, null, number) as length,if(number%4 ==3, null, 'Hello') as s,\n+       subString(bin(s), offset, length), bin(bitSlice(s, offset , length))\n+from numbers(16);\n",
  "problem_statement": "`bitSlice` function\n**Use case**\r\n\r\n#8922\r\n\r\n**Describe the solution you'd like**\r\n\r\n`bitSlice(s, offset, length)`\r\n\r\ns is FixedString or String\r\nthe return value has String data type.\r\n\r\nOffset starts from 1 for consistency with `substring` and `arraySlice`.\n",
  "hints_text": "Interested in working on this, can you assign it to me\uff1f\nSure, welcome!\n@ljcui Are you working on this? This feature makes sense.\nseems easy, I want to try it\n@RogerYK Thank you, it will be wonderful!",
  "created_at": "2022-01-02T11:11:02Z"
}