{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27153,
  "instance_id": "ClickHouse__ClickHouse-27153",
  "issue_numbers": [
    "26782"
  ],
  "base_commit": "af1d41a3def93a82fb046f7314b6a77ae747af40",
  "patch": "diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex 03fa756276e8..61e484ff6f19 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -348,7 +348,7 @@ SetPtr makeExplicitSet(\n     const ASTPtr & left_arg = args.children.at(0);\n     const ASTPtr & right_arg = args.children.at(1);\n \n-    auto column_name = left_arg->getColumnName(context->getSettingsRef());\n+    auto column_name = left_arg->getColumnName();\n     const auto & dag_node = actions.findInIndex(column_name);\n     const DataTypePtr & left_arg_type = dag_node.result_type;\n \n@@ -641,7 +641,7 @@ std::optional<NameAndTypePair> ActionsMatcher::getNameAndTypeFromAST(const ASTPt\n {\n     // If the argument is a literal, we generated a unique column name for it.\n     // Use it instead of a generic display name.\n-    auto child_column_name = ast->getColumnName(data.getContext()->getSettingsRef());\n+    auto child_column_name = ast->getColumnName();\n     const auto * as_literal = ast->as<ASTLiteral>();\n     if (as_literal)\n     {\n@@ -698,7 +698,7 @@ ASTs ActionsMatcher::doUntuple(const ASTFunction * function, ActionsMatcher::Dat\n         auto func = makeASTFunction(\"tupleElement\", tuple_ast, literal);\n \n         auto function_builder = FunctionFactory::instance().get(func->name, data.getContext());\n-        data.addFunction(function_builder, {tuple_name_type->name, literal->getColumnName(data.getContext()->getSettingsRef())}, func->getColumnName(data.getContext()->getSettingsRef()));\n+        data.addFunction(function_builder, {tuple_name_type->name, literal->getColumnName()}, func->getColumnName());\n \n         columns.push_back(std::move(func));\n     }\n@@ -762,7 +762,7 @@ void ActionsMatcher::visit(const ASTIdentifier & identifier, const ASTPtr &, Dat\n \n void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data & data)\n {\n-    auto column_name = ast->getColumnName(data.getContext()->getSettingsRef());\n+    auto column_name = ast->getColumnName();\n     if (data.hasColumn(column_name))\n         return;\n \n@@ -778,7 +778,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n         ASTPtr arg = node.arguments->children.at(0);\n         visit(arg, data);\n         if (!data.only_consts)\n-            data.addArrayJoin(arg->getColumnName(data.getContext()->getSettingsRef()), column_name);\n+            data.addArrayJoin(arg->getColumnName(), column_name);\n \n         return;\n     }\n@@ -800,7 +800,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n                 /// We are in the part of the tree that we are not going to compute. You just need to define types.\n                 /// Do not subquery and create sets. We replace \"in*\" function to \"in*IgnoreSet\".\n \n-                auto argument_name = node.arguments->children.at(0)->getColumnName(data.getContext()->getSettingsRef());\n+                auto argument_name = node.arguments->children.at(0)->getColumnName();\n \n                 data.addFunction(\n                         FunctionFactory::instance().get(node.name + \"IgnoreSet\", data.getContext()),\n@@ -929,7 +929,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n                 if (!prepared_set->empty())\n                     column.name = data.getUniqueName(\"__set\");\n                 else\n-                    column.name = child->getColumnName(data.getContext()->getSettingsRef());\n+                    column.name = child->getColumnName();\n \n                 if (!data.hasColumn(column.name))\n                 {\n@@ -1008,7 +1008,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n                     visit(lambda->arguments->children.at(1), data);\n                     auto lambda_dag = data.actions_stack.popLevel();\n \n-                    String result_name = lambda->arguments->children.at(1)->getColumnName(data.getContext()->getSettingsRef());\n+                    String result_name = lambda->arguments->children.at(1)->getColumnName();\n                     lambda_dag->removeUnusedActions(Names(1, result_name));\n \n                     auto lambda_actions = std::make_shared<ExpressionActions>(\n@@ -1023,7 +1023,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n                         if (findColumn(required_arg, lambda_arguments) == lambda_arguments.end())\n                             captured.push_back(required_arg);\n \n-                    /// We can not name `getColumnName(data.getContext()->getSettingsRef())`,\n+                    /// We can not name `getColumnName()`,\n                     ///  because it does not uniquely define the expression (the types of arguments can be different).\n                     String lambda_name = data.getUniqueName(\"__lambda\");\n \n@@ -1053,7 +1053,7 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n     if (arguments_present)\n     {\n         /// Calculate column name here again, because AST may be changed here (in case of untuple).\n-        data.addFunction(function_builder, argument_names, ast->getColumnName(data.getContext()->getSettingsRef()));\n+        data.addFunction(function_builder, argument_names, ast->getColumnName());\n     }\n }\n \n@@ -1067,7 +1067,7 @@ void ActionsMatcher::visit(const ASTLiteral & literal, const ASTPtr & /* ast */,\n     // AST here? Anyway, do not modify the column name if it is set already.\n     if (literal.unique_column_name.empty())\n     {\n-        const auto default_name = literal.getColumnName(data.getContext()->getSettingsRef());\n+        const auto default_name = literal.getColumnName();\n         const auto & index = data.actions_stack.getLastActionsIndex();\n         const auto * existing_column = index.tryGetNode(default_name);\n \n@@ -1147,7 +1147,7 @@ SetPtr ActionsMatcher::makeSet(const ASTFunction & node, Data & data, bool no_su\n         }\n \n         /// We get the stream of blocks for the subquery. Create Set and put it in place of the subquery.\n-        String set_id = right_in_operand->getColumnName(data.getContext()->getSettingsRef());\n+        String set_id = right_in_operand->getColumnName();\n \n         SubqueryForSet & subquery_for_set = data.subqueries_for_sets[set_id];\n \n@@ -1183,7 +1183,7 @@ SetPtr ActionsMatcher::makeSet(const ASTFunction & node, Data & data, bool no_su\n     {\n         const auto & last_actions = data.actions_stack.getLastActions();\n         const auto & index = data.actions_stack.getLastActionsIndex();\n-        if (index.contains(left_in_operand->getColumnName(data.getContext()->getSettingsRef())))\n+        if (index.contains(left_in_operand->getColumnName()))\n             /// An explicit enumeration of values in parentheses.\n             return makeExplicitSet(&node, last_actions, false, data.getContext(), data.set_size_limit, data.prepared_sets);\n         else\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 6245b297b368..77598e69c00a 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -243,7 +243,7 @@ void ExpressionAnalyzer::analyzeAggregation()\n                     ssize_t size = group_asts.size();\n                     getRootActionsNoMakeSet(group_asts[i], true, temp_actions, false);\n \n-                    const auto & column_name = group_asts[i]->getColumnName(getContext()->getSettingsRef());\n+                    const auto & column_name = group_asts[i]->getColumnName();\n                     const auto * node = temp_actions->tryFindInIndex(column_name);\n                     if (!node)\n                         throw Exception(\"Unknown identifier (in GROUP BY): \" + column_name, ErrorCodes::UNKNOWN_IDENTIFIER);\n@@ -408,7 +408,7 @@ void SelectQueryExpressionAnalyzer::makeSetsForIndex(const ASTPtr & node)\n                 auto temp_actions = std::make_shared<ActionsDAG>(columns_after_join);\n                 getRootActions(left_in_operand, true, temp_actions);\n \n-                if (temp_actions->tryFindInIndex(left_in_operand->getColumnName(getContext()->getSettingsRef())))\n+                if (temp_actions->tryFindInIndex(left_in_operand->getColumnName()))\n                     makeExplicitSet(func, *temp_actions, true, getContext(), settings.size_limits_for_set, prepared_sets);\n             }\n         }\n@@ -456,7 +456,7 @@ bool ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions)\n         if (node->arguments)\n             getRootActionsNoMakeSet(node->arguments, true, actions);\n \n-        aggregate.column_name = node->getColumnName(getContext()->getSettingsRef());\n+        aggregate.column_name = node->getColumnName();\n \n         const ASTs & arguments = node->arguments ? node->arguments->children : ASTs();\n         aggregate.argument_names.resize(arguments.size());\n@@ -464,7 +464,7 @@ bool ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions)\n \n         for (size_t i = 0; i < arguments.size(); ++i)\n         {\n-            const std::string & name = arguments[i]->getColumnName(getContext()->getSettingsRef());\n+            const std::string & name = arguments[i]->getColumnName();\n             const auto * dag_node = actions->tryFindInIndex(name);\n             if (!dag_node)\n             {\n@@ -645,7 +645,7 @@ void ExpressionAnalyzer::makeWindowDescriptions(ActionsDAGPtr actions)\n         WindowFunctionDescription window_function;\n         window_function.function_node = function_node;\n         window_function.column_name\n-            = window_function.function_node->getColumnName(getContext()->getSettingsRef());\n+            = window_function.function_node->getColumnName();\n         window_function.function_parameters\n             = window_function.function_node->parameters\n                 ? getAggregateFunctionParametersArray(\n@@ -664,7 +664,7 @@ void ExpressionAnalyzer::makeWindowDescriptions(ActionsDAGPtr actions)\n         window_function.argument_names.resize(arguments.size());\n         for (size_t i = 0; i < arguments.size(); ++i)\n         {\n-            const std::string & name = arguments[i]->getColumnName(getContext()->getSettingsRef());\n+            const std::string & name = arguments[i]->getColumnName();\n             const auto * node = actions->tryFindInIndex(name);\n \n             if (!node)\n@@ -961,7 +961,7 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendPrewhere(\n \n     auto & step = chain.lastStep(sourceColumns());\n     getRootActions(select_query->prewhere(), only_types, step.actions());\n-    String prewhere_column_name = select_query->prewhere()->getColumnName(getContext()->getSettingsRef());\n+    String prewhere_column_name = select_query->prewhere()->getColumnName();\n     step.addRequiredOutput(prewhere_column_name);\n \n     const auto & node = step.actions()->findInIndex(prewhere_column_name);\n@@ -1047,7 +1047,7 @@ bool SelectQueryExpressionAnalyzer::appendWhere(ExpressionActionsChain & chain,\n \n     getRootActions(select_query->where(), only_types, step.actions());\n \n-    auto where_column_name = select_query->where()->getColumnName(getContext()->getSettingsRef());\n+    auto where_column_name = select_query->where()->getColumnName();\n     step.addRequiredOutput(where_column_name);\n \n     const auto & node = step.actions()->findInIndex(where_column_name);\n@@ -1072,7 +1072,7 @@ bool SelectQueryExpressionAnalyzer::appendGroupBy(ExpressionActionsChain & chain\n     ASTs asts = select_query->groupBy()->children;\n     for (const auto & ast : asts)\n     {\n-        step.addRequiredOutput(ast->getColumnName(getContext()->getSettingsRef()));\n+        step.addRequiredOutput(ast->getColumnName());\n         getRootActions(ast, only_types, step.actions());\n     }\n \n@@ -1100,7 +1100,7 @@ void SelectQueryExpressionAnalyzer::appendAggregateFunctionsArguments(Expression\n         for (const auto & name : desc.argument_names)\n             step.addRequiredOutput(name);\n \n-    /// Collect aggregates removing duplicates by node.getColumnName(getContext()->getSettingsRef())\n+    /// Collect aggregates removing duplicates by node.getColumnName()\n     /// It's not clear why we recollect aggregates (for query parts) while we're able to use previously collected ones (for entire query)\n     /// @note The original recollection logic didn't remove duplicates.\n     GetAggregatesVisitor::Data data;\n@@ -1155,7 +1155,7 @@ void SelectQueryExpressionAnalyzer::appendWindowFunctionsArguments(\n             // (2b) Required function argument columns.\n             for (const auto & a : f.function_node->arguments->children)\n             {\n-                step.addRequiredOutput(a->getColumnName(getContext()->getSettingsRef()));\n+                step.addRequiredOutput(a->getColumnName());\n             }\n         }\n \n@@ -1177,7 +1177,7 @@ bool SelectQueryExpressionAnalyzer::appendHaving(ExpressionActionsChain & chain,\n     ExpressionActionsChain::Step & step = chain.lastStep(aggregated_columns);\n \n     getRootActionsForHaving(select_query->having(), only_types, step.actions());\n-    step.addRequiredOutput(select_query->having()->getColumnName(getContext()->getSettingsRef()));\n+    step.addRequiredOutput(select_query->having()->getColumnName());\n \n     return true;\n }\n@@ -1201,7 +1201,7 @@ void SelectQueryExpressionAnalyzer::appendSelect(ExpressionActionsChain & chain,\n             continue;\n         }\n \n-        step.addRequiredOutput(child->getColumnName(getContext()->getSettingsRef()));\n+        step.addRequiredOutput(child->getColumnName());\n     }\n }\n \n@@ -1229,7 +1229,7 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChai\n         if (!ast || ast->children.empty())\n             throw Exception(\"Bad order expression AST\", ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE);\n         ASTPtr order_expression = ast->children.at(0);\n-        step.addRequiredOutput(order_expression->getColumnName(getContext()->getSettingsRef()));\n+        step.addRequiredOutput(order_expression->getColumnName());\n \n         if (ast->with_fill)\n             with_fill = true;\n@@ -1279,7 +1279,7 @@ bool SelectQueryExpressionAnalyzer::appendLimitBy(ExpressionActionsChain & chain\n \n     for (const auto & child : select_query->limitBy()->children)\n     {\n-        auto child_name = child->getColumnName(getContext()->getSettingsRef());\n+        auto child_name = child->getColumnName();\n         if (!aggregated_names.count(child_name))\n             step.addRequiredOutput(std::move(child_name));\n     }\n@@ -1295,15 +1295,13 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendProjectResult(ExpressionActio\n \n     NamesWithAliases result_columns;\n \n-    const auto & settings = getContext()->getSettingsRef();\n-\n     ASTs asts = select_query->select()->children;\n     for (const auto & ast : asts)\n     {\n-        String result_name = ast->getAliasOrColumnName(settings);\n+        String result_name = ast->getAliasOrColumnName();\n         if (required_result_columns.empty() || required_result_columns.count(result_name))\n         {\n-            std::string source_name = ast->getColumnName(settings);\n+            std::string source_name = ast->getColumnName();\n \n             /*\n              * For temporary columns created by ExpressionAnalyzer for literals,\n@@ -1345,7 +1343,7 @@ void ExpressionAnalyzer::appendExpression(ExpressionActionsChain & chain, const\n {\n     ExpressionActionsChain::Step & step = chain.lastStep(sourceColumns());\n     getRootActions(expr, only_types, step.actions());\n-    step.addRequiredOutput(expr->getColumnName(getContext()->getSettingsRef()));\n+    step.addRequiredOutput(expr->getColumnName());\n }\n \n \n@@ -1362,13 +1360,12 @@ ActionsDAGPtr ExpressionAnalyzer::getActionsDAG(bool add_aliases, bool project_r\n     else\n         asts = ASTs(1, query);\n \n-    const auto & settings = getContext()->getSettingsRef();\n     for (const auto & ast : asts)\n     {\n-        std::string name = ast->getColumnName(settings);\n+        std::string name = ast->getColumnName();\n         std::string alias;\n         if (add_aliases)\n-            alias = ast->getAliasOrColumnName(settings);\n+            alias = ast->getAliasOrColumnName();\n         else\n             alias = name;\n         result_columns.emplace_back(name, alias);\n@@ -1497,7 +1494,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n \n         if (auto actions = query_analyzer.appendPrewhere(chain, !first_stage, additional_required_columns_after_prewhere))\n         {\n-            prewhere_info = std::make_shared<PrewhereInfo>(actions, query.prewhere()->getColumnName(settings));\n+            prewhere_info = std::make_shared<PrewhereInfo>(actions, query.prewhere()->getColumnName());\n \n             if (allowEarlyConstantFolding(*prewhere_info->prewhere_actions, settings))\n             {\n@@ -1507,7 +1504,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n                     ExpressionActions(\n                         prewhere_info->prewhere_actions,\n                         ExpressionActionsSettings::fromSettings(context->getSettingsRef())).execute(before_prewhere_sample);\n-                    auto & column_elem = before_prewhere_sample.getByName(query.prewhere()->getColumnName(settings));\n+                    auto & column_elem = before_prewhere_sample.getByName(query.prewhere()->getColumnName());\n                     /// If the filter column is a constant, record it.\n                     if (column_elem.column)\n                         prewhere_constant_filter_description = ConstantFilterDescription(*column_elem.column);\n@@ -1542,7 +1539,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n                     ExpressionActions(\n                         before_where,\n                         ExpressionActionsSettings::fromSettings(context->getSettingsRef())).execute(before_where_sample);\n-                    auto & column_elem = before_where_sample.getByName(query.where()->getColumnName(settings));\n+                    auto & column_elem = before_where_sample.getByName(query.where()->getColumnName());\n                     /// If the filter column is a constant, record it.\n                     if (column_elem.column)\n                         where_constant_filter_description = ConstantFilterDescription(*column_elem.column);\n@@ -1633,7 +1630,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n             const auto * select_query = query_analyzer.getSelectQuery();\n             for (const auto & child : select_query->select()->children)\n             {\n-                step.addRequiredOutput(child->getColumnName(settings));\n+                step.addRequiredOutput(child->getColumnName());\n             }\n         }\n \n@@ -1689,8 +1686,7 @@ void ExpressionAnalysisResult::finalize(const ExpressionActionsChain & chain, si\n \n     if (hasWhere())\n     {\n-        const auto & settings = chain.getContext()->getSettingsRef();\n-        where_column_name = query.where()->getColumnName(settings);\n+        where_column_name = query.where()->getColumnName();\n         remove_where_filter = chain.steps.at(where_step_num)->required_output.find(where_column_name)->second;\n     }\n }\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex ed76074c4968..f3efad0d6998 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -141,7 +141,7 @@ String InterpreterSelectQuery::generateFilterActions(ActionsDAGPtr & actions, co\n     SelectQueryExpressionAnalyzer analyzer(query_ast, syntax_result, context, metadata_snapshot);\n     actions = analyzer.simpleSelectActions();\n \n-    auto column_name = expr_list->children.at(0)->getColumnName(context->getSettingsRef());\n+    auto column_name = expr_list->children.at(0)->getColumnName();\n     actions->removeUnusedActions(NameSet{column_name});\n     actions->projectInput(false);\n \n@@ -782,7 +782,7 @@ static SortDescription getSortDescription(const ASTSelectQuery & query, ContextP\n     order_descr.reserve(query.orderBy()->children.size());\n     for (const auto & elem : query.orderBy()->children)\n     {\n-        String name = elem->children.front()->getColumnName(context->getSettingsRef());\n+        String name = elem->children.front()->getColumnName();\n         const auto & order_by_elem = elem->as<ASTOrderByElement &>();\n \n         std::shared_ptr<Collator> collator;\n@@ -801,14 +801,14 @@ static SortDescription getSortDescription(const ASTSelectQuery & query, ContextP\n     return order_descr;\n }\n \n-static SortDescription getSortDescriptionFromGroupBy(const ASTSelectQuery & query, ContextPtr context)\n+static SortDescription getSortDescriptionFromGroupBy(const ASTSelectQuery & query)\n {\n     SortDescription order_descr;\n     order_descr.reserve(query.groupBy()->children.size());\n \n     for (const auto & elem : query.groupBy()->children)\n     {\n-        String name = elem->getColumnName(context->getSettingsRef());\n+        String name = elem->getColumnName();\n         order_descr.emplace_back(name, 1, 1);\n     }\n \n@@ -1928,13 +1928,13 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n                 {\n                     query_info.projection->order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n                         query_info.projection->group_by_elements_actions,\n-                        getSortDescriptionFromGroupBy(query, context),\n+                        getSortDescriptionFromGroupBy(query),\n                         query_info.syntax_analyzer_result);\n                 }\n                 else\n                 {\n                     query_info.order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n-                        analysis_result.group_by_elements_actions, getSortDescriptionFromGroupBy(query, context), query_info.syntax_analyzer_result);\n+                        analysis_result.group_by_elements_actions, getSortDescriptionFromGroupBy(query), query_info.syntax_analyzer_result);\n                 }\n             }\n \n@@ -2015,7 +2015,7 @@ void InterpreterSelectQuery::executeFetchColumns(QueryProcessingStage::Enum proc\n void InterpreterSelectQuery::executeWhere(QueryPlan & query_plan, const ActionsDAGPtr & expression, bool remove_filter)\n {\n     auto where_step = std::make_unique<FilterStep>(\n-        query_plan.getCurrentDataStream(), expression, getSelectQuery().where()->getColumnName(context->getSettingsRef()), remove_filter);\n+        query_plan.getCurrentDataStream(), expression, getSelectQuery().where()->getColumnName(), remove_filter);\n \n     where_step->setStepDescription(\"WHERE\");\n     query_plan.addStep(std::move(where_step));\n@@ -2064,7 +2064,7 @@ void InterpreterSelectQuery::executeAggregation(QueryPlan & query_plan, const Ac\n     SortDescription group_by_sort_description;\n \n     if (group_by_info && settings.optimize_aggregation_in_order)\n-        group_by_sort_description = getSortDescriptionFromGroupBy(getSelectQuery(), context);\n+        group_by_sort_description = getSortDescriptionFromGroupBy(getSelectQuery());\n     else\n         group_by_info = nullptr;\n \n@@ -2112,7 +2112,7 @@ void InterpreterSelectQuery::executeMergeAggregated(QueryPlan & query_plan, bool\n void InterpreterSelectQuery::executeHaving(QueryPlan & query_plan, const ActionsDAGPtr & expression)\n {\n     auto having_step\n-        = std::make_unique<FilterStep>(query_plan.getCurrentDataStream(), expression, getSelectQuery().having()->getColumnName(context->getSettingsRef()), false);\n+        = std::make_unique<FilterStep>(query_plan.getCurrentDataStream(), expression, getSelectQuery().having()->getColumnName(), false);\n \n     having_step->setStepDescription(\"HAVING\");\n     query_plan.addStep(std::move(having_step));\n@@ -2128,7 +2128,7 @@ void InterpreterSelectQuery::executeTotalsAndHaving(\n         query_plan.getCurrentDataStream(),\n         overflow_row,\n         expression,\n-        has_having ? getSelectQuery().having()->getColumnName(context->getSettingsRef()) : \"\",\n+        has_having ? getSelectQuery().having()->getColumnName() : \"\",\n         settings.totals_mode,\n         settings.totals_auto_threshold,\n         final);\n@@ -2456,7 +2456,7 @@ void InterpreterSelectQuery::executeLimitBy(QueryPlan & query_plan)\n \n     Names columns;\n     for (const auto & elem : query.limitBy()->children)\n-        columns.emplace_back(elem->getColumnName(context->getSettingsRef()));\n+        columns.emplace_back(elem->getColumnName());\n \n     UInt64 length = getLimitUIntValue(query.limitByLength(), context, \"LIMIT\");\n     UInt64 offset = (query.limitByOffset() ? getLimitUIntValue(query.limitByOffset(), context, \"OFFSET\") : 0);\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex cc345004f6f9..9294cca7bb44 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -609,6 +609,27 @@ std::vector<const ASTFunction *> getWindowFunctions(ASTPtr & query, const ASTSel\n     return data.window_functions;\n }\n \n+class MarkTupleLiteralsAsLegacyData\n+{\n+public:\n+    using TypeToVisit = ASTLiteral;\n+\n+    static void visit(ASTLiteral & literal, ASTPtr &)\n+    {\n+        if (literal.value.getType() == Field::Types::Tuple)\n+            literal.use_legacy_column_name_of_tuple = true;\n+    }\n+};\n+\n+using MarkTupleLiteralsAsLegacyMatcher = OneTypeMatcher<MarkTupleLiteralsAsLegacyData>;\n+using MarkTupleLiteralsAsLegacyVisitor = InDepthNodeVisitor<MarkTupleLiteralsAsLegacyMatcher, true>;\n+\n+void markTupleLiteralsAsLegacy(ASTPtr & query)\n+{\n+    MarkTupleLiteralsAsLegacyVisitor::Data data;\n+    MarkTupleLiteralsAsLegacyVisitor(data).visit(query);\n+}\n+\n }\n \n TreeRewriterResult::TreeRewriterResult(\n@@ -927,6 +948,9 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n     /// Executing scalar subqueries - replacing them with constant values.\n     executeScalarSubqueries(query, getContext(), subquery_depth, result.scalars, select_options.only_analyze);\n \n+    if (settings.legacy_column_name_of_tuple_literal)\n+        markTupleLiteralsAsLegacy(query);\n+\n     TreeOptimizer::apply(query, result, tables_with_columns, getContext());\n \n     /// array_join_alias_to_name, array_join_result_to_source.\n@@ -994,6 +1018,9 @@ TreeRewriterResultPtr TreeRewriter::analyze(\n     /// Executing scalar subqueries. Column defaults could be a scalar subquery.\n     executeScalarSubqueries(query, getContext(), 0, result.scalars, false);\n \n+    if (settings.legacy_column_name_of_tuple_literal)\n+        markTupleLiteralsAsLegacy(query);\n+\n     TreeOptimizer::optimizeIf(query, result.aliases, settings.optimize_if_chain_to_multiif);\n \n     if (allow_aggregations)\ndiff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex f814e1d8c02d..e46f644e8364 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -39,7 +39,7 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co\n     if (context->getSettingsRef().normalize_function_names)\n         FunctionNameNormalizer().visit(ast.get());\n \n-    String name = ast->getColumnName(context->getSettingsRef());\n+    String name = ast->getColumnName();\n     auto syntax_result = TreeRewriter(context).analyze(ast, source_columns);\n     ExpressionActionsPtr expr_for_constant_folding = ExpressionAnalyzer(ast, syntax_result, context).getConstActions();\n \ndiff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp\nindex daae3e76aa14..1ff27c61836f 100644\n--- a/src/Parsers/ASTFunction.cpp\n+++ b/src/Parsers/ASTFunction.cpp\n@@ -24,16 +24,6 @@ namespace ErrorCodes\n }\n \n void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr) const\n-{\n-    appendColumnNameImpl(ostr, nullptr);\n-}\n-\n-void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr, const Settings & settings) const\n-{\n-    appendColumnNameImpl(ostr, &settings);\n-}\n-\n-void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr, const Settings * settings) const\n {\n     if (name == \"view\")\n         throw Exception(\"Table function view cannot be used as an expression\", ErrorCodes::UNEXPECTED_EXPRESSION);\n@@ -48,10 +38,7 @@ void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr, const Settings * sett\n             if (it != parameters->children.begin())\n                 writeCString(\", \", ostr);\n \n-            if (settings)\n-                (*it)->appendColumnName(ostr, *settings);\n-            else\n-                (*it)->appendColumnName(ostr);\n+            (*it)->appendColumnName(ostr);\n         }\n         writeChar(')', ostr);\n     }\n@@ -64,10 +51,7 @@ void ASTFunction::appendColumnNameImpl(WriteBuffer & ostr, const Settings * sett\n             if (it != arguments->children.begin())\n                 writeCString(\", \", ostr);\n \n-            if (settings)\n-                (*it)->appendColumnName(ostr, *settings);\n-            else\n-                (*it)->appendColumnName(ostr);\n+            (*it)->appendColumnName(ostr);\n         }\n     }\n \ndiff --git a/src/Parsers/ASTFunction.h b/src/Parsers/ASTFunction.h\nindex 8e657afbf6e5..685aaaadd262 100644\n--- a/src/Parsers/ASTFunction.h\n+++ b/src/Parsers/ASTFunction.h\n@@ -54,10 +54,6 @@ class ASTFunction : public ASTWithAlias\n protected:\n     void formatImplWithoutAlias(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n     void appendColumnNameImpl(WriteBuffer & ostr) const override;\n-    void appendColumnNameImpl(WriteBuffer & ostr, const Settings & settings) const override;\n-\n-private:\n-    void appendColumnNameImpl(WriteBuffer & ostr, const Settings * settings) const;\n };\n \n \ndiff --git a/src/Parsers/ASTLiteral.cpp b/src/Parsers/ASTLiteral.cpp\nindex c456cb3e9334..93d490bc645e 100644\n--- a/src/Parsers/ASTLiteral.cpp\n+++ b/src/Parsers/ASTLiteral.cpp\n@@ -50,16 +50,14 @@ String FieldVisitorToColumnName::operator() (const Tuple & x) const\n \n }\n \n-void ASTLiteral::appendColumnNameImpl(WriteBuffer & ostr, const Settings & settings) const\n+void ASTLiteral::appendColumnNameImpl(WriteBuffer & ostr) const\n {\n-    if (settings.legacy_column_name_of_tuple_literal)\n+    if (use_legacy_column_name_of_tuple)\n+    {\n         appendColumnNameImplLegacy(ostr);\n-    else\n-        appendColumnNameImpl(ostr);\n-}\n+        return;\n+    }\n \n-void ASTLiteral::appendColumnNameImpl(WriteBuffer & ostr) const\n-{\n     /// 100 - just arbitrary value.\n     constexpr auto min_elements_for_hashing = 100;\n \ndiff --git a/src/Parsers/ASTLiteral.h b/src/Parsers/ASTLiteral.h\nindex c17310f719bc..856bed61979e 100644\n--- a/src/Parsers/ASTLiteral.h\n+++ b/src/Parsers/ASTLiteral.h\n@@ -33,6 +33,10 @@ class ASTLiteral : public ASTWithAlias\n      */\n     String unique_column_name;\n \n+    /// For compatibility reasons in distributed queries,\n+    /// we may need to use legacy column name for tuple literal.\n+    bool use_legacy_column_name_of_tuple = false;\n+\n     /** Get the text that identifies this element. */\n     String getID(char delim) const override { return \"Literal\" + (delim + applyVisitor(FieldVisitorDump(), value)); }\n \n@@ -44,7 +48,6 @@ class ASTLiteral : public ASTWithAlias\n     void formatImplWithoutAlias(const FormatSettings & settings, FormatState &, FormatStateStacked) const override;\n \n     void appendColumnNameImpl(WriteBuffer & ostr) const override;\n-    void appendColumnNameImpl(WriteBuffer & ostr, const Settings & settings) const override;\n \n private:\n     /// Legacy version of 'appendColumnNameImpl'. It differs only with tuple literals.\ndiff --git a/src/Parsers/ASTWithAlias.cpp b/src/Parsers/ASTWithAlias.cpp\nindex 0f5b86763e0c..88f6568a7196 100644\n--- a/src/Parsers/ASTWithAlias.cpp\n+++ b/src/Parsers/ASTWithAlias.cpp\n@@ -48,14 +48,6 @@ void ASTWithAlias::appendColumnName(WriteBuffer & ostr) const\n         appendColumnNameImpl(ostr);\n }\n \n-void ASTWithAlias::appendColumnName(WriteBuffer & ostr, const Settings & settings) const\n-{\n-    if (prefer_alias_to_column_name && !alias.empty())\n-        writeString(alias, ostr);\n-    else\n-        appendColumnNameImpl(ostr, settings);\n-}\n-\n void ASTWithAlias::appendColumnNameWithoutAlias(WriteBuffer & ostr) const\n {\n     appendColumnNameImpl(ostr);\ndiff --git a/src/Parsers/ASTWithAlias.h b/src/Parsers/ASTWithAlias.h\nindex 249be17b74ca..ea4419402b0b 100644\n--- a/src/Parsers/ASTWithAlias.h\n+++ b/src/Parsers/ASTWithAlias.h\n@@ -21,10 +21,8 @@ class ASTWithAlias : public IAST\n     using IAST::IAST;\n \n     void appendColumnName(WriteBuffer & ostr) const final;\n-    void appendColumnName(WriteBuffer & ostr, const Settings & settings) const final;\n     void appendColumnNameWithoutAlias(WriteBuffer & ostr) const final;\n     String getAliasOrColumnName() const override { return alias.empty() ? getColumnName() : alias; }\n-    String getAliasOrColumnName(const Settings & settings) const override { return alias.empty() ? getColumnName(settings) : alias; }\n     String tryGetAlias() const override { return alias; }\n     void setAlias(const String & to) override { alias = to; }\n \n@@ -35,7 +33,6 @@ class ASTWithAlias : public IAST\n \n protected:\n     virtual void appendColumnNameImpl(WriteBuffer & ostr) const = 0;\n-    virtual void appendColumnNameImpl(WriteBuffer & ostr, const Settings &) const { appendColumnNameImpl(ostr); }\n };\n \n /// helper for setting aliases and chaining result to other functions\ndiff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp\nindex 0f38fcf98dd8..3a21d704eb90 100644\n--- a/src/Parsers/IAST.cpp\n+++ b/src/Parsers/IAST.cpp\n@@ -109,14 +109,6 @@ String IAST::getColumnName() const\n }\n \n \n-String IAST::getColumnName(const Settings & settings) const\n-{\n-    WriteBufferFromOwnString write_buffer;\n-    appendColumnName(write_buffer, settings);\n-    return write_buffer.str();\n-}\n-\n-\n String IAST::getColumnNameWithoutAlias() const\n {\n     WriteBufferFromOwnString write_buffer;\ndiff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h\nindex 94a7b1a52ab0..2f9212da6321 100644\n--- a/src/Parsers/IAST.h\n+++ b/src/Parsers/IAST.h\n@@ -42,7 +42,6 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n \n     /** Get the canonical name of the column if the element is a column */\n     String getColumnName() const;\n-    String getColumnName(const Settings & settings) const;\n \n     /** Same as the above but ensure no alias names are used. This is for index analysis */\n     String getColumnNameWithoutAlias() const;\n@@ -52,8 +51,6 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n         throw Exception(\"Trying to get name of not a column: \" + getID(), ErrorCodes::LOGICAL_ERROR);\n     }\n \n-    virtual void appendColumnName(WriteBuffer & ostr, const Settings &) const { appendColumnName(ostr); }\n-\n     virtual void appendColumnNameWithoutAlias(WriteBuffer &) const\n     {\n         throw Exception(\"Trying to get name of not a column: \" + getID(), ErrorCodes::LOGICAL_ERROR);\n@@ -61,7 +58,6 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n \n     /** Get the alias, if any, or the canonical name of the column, if it is not. */\n     virtual String getAliasOrColumnName() const { return getColumnName(); }\n-    virtual String getAliasOrColumnName(const Settings & settings) const { return getColumnName(settings); }\n \n     /** Get the alias, if any, or an empty string if it does not exist, or if the element does not support aliases. */\n     virtual String tryGetAlias() const { return String(); }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02002_system_table_with_tuple.reference b/tests/queries/0_stateless/02002_system_table_with_tuple.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02002_system_table_with_tuple.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/02002_system_table_with_tuple.sh b/tests/queries/0_stateless/02002_system_table_with_tuple.sh\nnew file mode 100755\nindex 000000000000..2abf5b8b5253\n--- /dev/null\n+++ b/tests/queries/0_stateless/02002_system_table_with_tuple.sh\n@@ -0,0 +1,9 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+$CLICKHOUSE_CLIENT -q \"SELECT count() > 0 FROM system.tables \\\n+    WHERE database IN ('system', '$CLICKHOUSE_DATABASE') \\\n+    SETTINGS legacy_column_name_of_tuple_literal = 1\"\n",
  "problem_statement": "legacy_column_name_of_tuple_literal doesn't always work\nWith `legacy_column_name_of_tuple_literal` enabled I get an exception in some queries to LOCAL tables: `Not found column in(...) in block. There are only columns: ..., in(..., tuple(...))`\r\n```\r\n:) select count() from system.tables where database in ('system','system') settings legacy_column_name_of_tuple_literal=0\r\n\r\nSELECT count()\r\nFROM system.tables\r\nWHERE database IN ('system', 'system')\r\nSETTINGS legacy_column_name_of_tuple_literal = 0\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502      71 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n:) select count() from system.tables where database in ('system','system') settings legacy_column_name_of_tuple_literal=1\r\n\r\nSELECT count()\r\nFROM system.tables\r\nWHERE database IN ('system', 'system')\r\nSETTINGS legacy_column_name_of_tuple_literal = 1\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 21.7.4):\r\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column in(database, ('system', 'system')) in block. There are only columns: database, in(database, tuple('system', 'system')).\r\n\r\n:) select count() from system.databases where name in ('system','system') settings legacy_column_name_of_tuple_literal=1\r\n\r\nSELECT count()\r\nFROM system.databases\r\nWHERE name IN ('system', 'system')\r\nSETTINGS legacy_column_name_of_tuple_literal = 1\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2021-08-03T18:07:12Z"
}