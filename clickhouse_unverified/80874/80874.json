{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80874,
  "instance_id": "ClickHouse__ClickHouse-80874",
  "issue_numbers": [
    "75023"
  ],
  "base_commit": "40e02022da48b82bc191b9031dd0bd6e6ddb8df9",
  "patch": "diff --git a/docs/en/sql-reference/statements/system.md b/docs/en/sql-reference/statements/system.md\nindex 6cfc637ba2ba..4ad4d94f7e34 100644\n--- a/docs/en/sql-reference/statements/system.md\n+++ b/docs/en/sql-reference/statements/system.md\n@@ -160,12 +160,13 @@ If a tag is specified, only query cache entries with the specified tag are delet\n \n Clears cache for schemas loaded from [`format_schema_path`](../../operations/server-configuration-parameters/settings.md#format_schema_path).\n \n-Supported formats:\n-\n-- Protobuf\n+Supported targets:\n+- Protobuf: Removes imported Protobuf message definitions from memory.\n+- Files: Deletes cached schema files stored locally in the [`format_schema_path`](../../operations/server-configuration-parameters/settings.md#format_schema_path), generated when `format_schema_source` is set to `query`.\n+Note: If no target is specified, both caches are cleared.\n \n ```sql\n-SYSTEM DROP FORMAT SCHEMA CACHE [FOR Protobuf]\n+SYSTEM DROP FORMAT SCHEMA CACHE [FOR Protobuf/Files]\n ```\n \n ## FLUSH LOGS {#flush-logs}\ndiff --git a/src/Core/FormatFactorySettings.h b/src/Core/FormatFactorySettings.h\nindex e0896a01b09e..022194d20c57 100644\n--- a/src/Core/FormatFactorySettings.h\n+++ b/src/Core/FormatFactorySettings.h\n@@ -1081,8 +1081,29 @@ Path of the file used to record errors while reading text formats (CSV, TSV).\n Method to write Errors to text output.\n )\", 0) \\\n     \\\n+    DECLARE(String, format_schema_source, \"file\", R\"(\n+Define the source of `format_schema`.\n+Possible values:\n+- 'file' (default):: The `format_schema` is the name of a schema file located in the `format_schemas` directory.\n+- 'string': The `format_schema` is the literal content of the schema.\n+- 'query': The `format_schema` is a query to retrieve the schema.\n+When `format_schema_source` is set to 'query', the following conditions apply:\n+- The query must return exactly one value: a single row with a single string column.\n+- The result of the query is treated as the schema content.\n+- This result is cached locally in the `format_schemas` directory.\n+- You can clear the local cache using the command: `SYSTEM DROP FORMAT SCHEMA CACHE FOR Files`.\n+- Once cached, identical queries are not executed to fetch the schema again until the cache is explicitly cleared\n+- In addition to local cache files, Protobuf messages are also cached in memory. Even after clearing the local cache files, the in-memory cache must be cleared using `SYSTEM DROP FORMAT SCHEMA CACHE [FOR Protobuf]` to fully refresh the schema.\n+- Run the query `SYSTEM DROP FORMAT SCHEMA CACHE` to clear the cache for both cache files and Protobuf messages schemas at once.\n+)\", 0) \\\n     DECLARE(String, format_schema, \"\", R\"(\n This parameter is useful when you are using formats that require a schema definition, such as [Cap'n Proto](https://capnproto.org/) or [Protobuf](https://developers.google.com/protocol-buffers/). The value depends on the format.\n+)\", 0) \\\n+    DECLARE(String, format_schema_message_name, \"\", R\"(\n+Define the name of the required message in the schema defined in `format_schema`.\n+To maintain compatibility with the legacy format_schema format (`file_name:message_name`):\n+- If `format_schema_message_name` is not specified, the message name is inferred from the `message_name` part of the legacy `format_schema` value.\n+- If `format_schema_message_name` is specified while using the legacy format, an error will be raised.\n )\", 0) \\\n     DECLARE(String, format_template_resultset, \"\", R\"(\n Path to file which contains format string for result set (for Template format)\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex edba38ed5dcd..c01d5fdbd221 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -69,7 +69,8 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()\n         /// Note: please check if the key already exists to prevent duplicate entries.\n         addSettingsChanges(settings_changes_history, \"25.7\",\n         {\n-\n+            {\"format_schema_source\", \"file\", \"file\", \"New setting\"},\n+            {\"format_schema_message_name\", \"\", \"\", \"New setting\"},\n         });\n         addSettingsChanges(settings_changes_history, \"25.6\",\n         {\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 41d944819fc2..8b85e48acfc6 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -246,7 +246,9 @@ FormatSettings getFormatSettings(const ContextPtr & context, const Settings & se\n     format_settings.regexp.escaping_rule = settings[Setting::format_regexp_escaping_rule];\n     format_settings.regexp.regexp = settings[Setting::format_regexp];\n     format_settings.regexp.skip_unmatched = settings[Setting::format_regexp_skip_unmatched];\n+    format_settings.schema.format_schema_source = settings[Setting::format_schema_source];\n     format_settings.schema.format_schema = settings[Setting::format_schema];\n+    format_settings.schema.format_schema_message_name = settings[Setting::format_schema_message_name];\n     format_settings.schema.format_schema_path = context->getFormatSchemaPath();\n     format_settings.schema.is_server = context->hasGlobalContext() && (context->getGlobalContext()->getApplicationType() == Context::ApplicationType::SERVER);\n     format_settings.schema.output_format_schema = settings[Setting::output_format_schema];\ndiff --git a/src/Formats/FormatSchemaInfo.cpp b/src/Formats/FormatSchemaInfo.cpp\nindex caa89fb7d0f8..801c2d3f2a55 100644\n--- a/src/Formats/FormatSchemaInfo.cpp\n+++ b/src/Formats/FormatSchemaInfo.cpp\n@@ -1,13 +1,30 @@\n+#include <filesystem>\n #include <Formats/FormatSchemaInfo.h>\n+\n+#include <fcntl.h>\n+\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnString.h>\n+#include <Core/Block.h>\n+#include <Disks/IO/WriteBufferFromTemporaryFile.h>\n+#include <Formats/FormatSettings.h>\n+#include <IO/WriteHelpers.h>\n #include <Interpreters/Context.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/QueryFlags.h>\n+#include <Interpreters/SelectQueryOptions.h>\n+#include <Parsers/ParserSelectQuery.h>\n+#include <Parsers/parseQuery.h>\n+#include <Processors/Executors/PullingPipelineExecutor.h>\n+#include <boost/algorithm/hex.hpp>\n+#include <Common/CurrentThread.h>\n #include <Common/Exception.h>\n+#include <Common/Logger.h>\n+#include <Common/OpenSSLHelpers.h>\n+#include <Common/SipHash.h>\n+#include <Common/atomicRename.h>\n #include <Common/filesystemHelpers.h>\n-#include <Core/Block.h>\n-#include <Disks/IO/WriteBufferFromTemporaryFile.h>\n-\n-#include <filesystem>\n-\n-\n+#include <Common/logger_useful.h>\n namespace DB\n {\n namespace ErrorCodes\n@@ -15,7 +32,6 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n-namespace fs = std::filesystem;\n \n namespace\n {\n@@ -30,47 +46,259 @@ namespace\n }\n \n \n-FormatSchemaInfo::FormatSchemaInfo(const String & format_schema, const String & format, bool require_message, bool is_server, const std::string & format_schema_path)\n+FormatSchemaInfo::FormatSchemaInfo(\n+    const String & format_schema_source,\n+    const String & format_schema,\n+    const String & format_schema_message_name,\n+    const String & format,\n+    bool require_message,\n+    bool is_server,\n+    const String & format_schema_path)\n+    : message_name(format_schema_message_name)\n+    , log(getLogger(\"FormatSchemaInfo\"))\n {\n+    if (format_schema_source.empty())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The format_schema_source setting should be set\");\n+\n     if (format_schema.empty())\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The format {} requires a schema. The corresponding setting should be set\", format);\n \n+    if (!require_message && !message_name.empty())\n+    {\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"format_schema_message_name is specified {} when not required\", message_name);\n+    }\n+\n+    auto default_schema_directory = [&format_schema_path]()\n+    {\n+        static const String str = fs::canonical(format_schema_path) / \"\";\n+        return str;\n+    };\n+\n+    if (format_schema_source == FormatSettings::FORMAT_SCHEMA_SOURCE_FILE)\n+    {\n+        handleSchemaFile(format_schema, format, require_message, is_server, default_schema_directory());\n+        return;\n+    }\n+\n+    if (format_schema_source == FormatSettings::FORMAT_SCHEMA_SOURCE_STRING)\n+    {\n+        handleSchemaContent(format_schema, format, is_server, default_schema_directory());\n+        return;\n+    }\n+\n+    if (format_schema_source == FormatSettings::FORMAT_SCHEMA_SOURCE_QUERY)\n+    {\n+        handleSchemaSourceQuery(format_schema, format, is_server, default_schema_directory());\n+        return;\n+    }\n+\n+    throw Exception(\n+        ErrorCodes::BAD_ARGUMENTS,\n+        \"Invalid format_schema_source setting. Possible value: '{}', '{}', '{}', actual '{}'\",\n+        FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+        FormatSettings::FORMAT_SCHEMA_SOURCE_STRING,\n+        FormatSettings::FORMAT_SCHEMA_SOURCE_QUERY,\n+        format_schema_source);\n+}\n+\n+FormatSchemaInfo::FormatSchemaInfo(const FormatSettings & settings, const String & format, bool require_message)\n+    : FormatSchemaInfo(\n+          settings.schema.format_schema_source,\n+          settings.schema.format_schema,\n+          settings.schema.format_schema_message_name,\n+          format,\n+          require_message,\n+          settings.schema.is_server,\n+          settings.schema.format_schema_path)\n+{\n+}\n+\n+void FormatSchemaInfo::handleSchemaFile(\n+    const String & format_schema, const String & format, bool require_message, bool is_server, const String & format_schema_path)\n+{\n     String default_file_extension = getFormatSchemaDefaultFileExtension(format);\n \n     fs::path path;\n+    verifySchemaFileName(format_schema, require_message, path);\n+    processSchemaFile(path, default_file_extension, is_server, format_schema_path);\n+}\n+\n+void FormatSchemaInfo::verifySchemaFileName(const String & format_schema, bool require_message, fs::path & path)\n+{\n+    size_t colon_pos = format_schema.find(':');\n+    String format_schema_file_name;\n+    String format_schema_message_name;\n+    if (colon_pos != String::npos)\n+    {\n+        if (!message_name.empty())\n+            throw Exception(\n+                ErrorCodes::BAD_ARGUMENTS,\n+                \"Require message is already defined in `format_schema_message_name` and should not be defined in 'format_schema'\");\n+\n+        format_schema_file_name = format_schema.substr(0, colon_pos);\n+        format_schema_message_name = format_schema.substr(colon_pos + 1);\n+    }\n+    else\n+    {\n+        format_schema_file_name = format_schema;\n+    }\n+\n     if (require_message)\n     {\n-        size_t colon_pos = format_schema.find(':');\n-        if ((colon_pos == String::npos) || (colon_pos == 0) || (colon_pos == format_schema.length() - 1))\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Format schema requires the 'format_schema' setting to have the 'schema_file:message_name' format{}. Got '{}'\",\n-                    (default_file_extension.empty() ? \"\" : \", e.g. 'schema.\" + default_file_extension + \":Message'\"), format_schema);\n-        path = fs::path(format_schema.substr(0, colon_pos));\n+        if (message_name.empty() && format_schema_message_name.empty())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected 'format_schema_message_name' setting\");\n+\n+        if (message_name.empty())\n+            message_name = format_schema_message_name;\n+\n+        path = fs::path(format_schema_file_name);\n         String filename = path.has_filename() ? path.filename() : path.parent_path().filename();\n         if (filename.empty())\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Format schema requires the 'format_schema' setting to have the 'schema_file:message_name' format{}. Got '{}'\",\n-                (default_file_extension.empty() ? \"\" : \", e.g. 'schema.\" + default_file_extension + \":Message'\"), format_schema);\n-\n-        message_name = format_schema.substr(colon_pos + 1);\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid file name in 'format_schema' setting\");\n     }\n     else\n     {\n-        path = fs::path(format_schema);\n+        path = fs::path(format_schema_file_name);\n         if (!path.has_filename())\n             path = path.parent_path() / \"\";\n     }\n+}\n \n-    auto default_schema_directory = [&format_schema_path]()\n+void FormatSchemaInfo::handleSchemaContent(const String & content, const String & format, bool is_server, const String & format_schema_path)\n+{\n+    String default_file_extension = getFormatSchemaDefaultFileExtension(format);\n+    auto file_name = generateSchemaFileName(content, default_file_extension);\n+    auto cached_file_path = fs::path(CACHE_DIR_NAME) / file_name;\n+    auto file_path = fs::path(format_schema_path) / cached_file_path;\n+    if (fs::exists(file_path))\n     {\n-        static const String str = fs::canonical(format_schema_path) / \"\";\n-        return str;\n-    };\n+        LOG_DEBUG(log, \"Cached file exists '{}', skip storing schema file\", file_path.string());\n+    }\n+    else\n+    {\n+        storeSchemaOnDisk(/*file_path=*/file_path, /*content=*/content);\n+    }\n+    processSchemaFile(cached_file_path, default_file_extension, is_server, format_schema_path);\n+}\n+\n+void FormatSchemaInfo::handleSchemaSourceQuery(\n+    const String & format_schema, const String & format, bool is_server, const String & format_schema_path)\n+{\n+    String default_file_extension = getFormatSchemaDefaultFileExtension(format);\n+    auto file_name = generateSchemaFileName(format_schema, default_file_extension);\n+    auto cached_file_path = fs::path(CACHE_DIR_NAME) / file_name;\n+    auto file_path = fs::path(format_schema_path) / cached_file_path;\n+    if (fs::exists(file_path))\n+    {\n+        LOG_DEBUG(log, \"Cached file exists '{}' for query '{}', skip querying schema\", file_path.string(), format_schema);\n+    }\n+    else\n+    {\n+        auto content = querySchema(format_schema);\n+        storeSchemaOnDisk(/*file_path=*/file_path, /*content=*/content);\n+    }\n+    processSchemaFile(cached_file_path, default_file_extension, is_server, format_schema_path);\n+}\n+\n+String FormatSchemaInfo::querySchema(const String & query)\n+{\n+    auto current_query_context = CurrentThread::get().getQueryContext();\n+    if (!current_query_context)\n+        current_query_context = Context::getGlobalContextInstance();\n+\n+    ParserSelectQuery parser;\n+    ASTPtr select_ast = parseQuery(parser, query, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH, DBMS_DEFAULT_MAX_PARSER_BACKTRACKS);\n+\n+    auto query_context = Context::createCopy(current_query_context);\n+    InterpreterSelectQuery interpreter(select_ast, query_context, SelectQueryOptions().setInternal());\n+    BlockIO io = interpreter.execute();\n+\n+    PullingPipelineExecutor executor(io.pipeline);\n+\n+    Block block;\n+    std::optional<String> result;\n+    while (executor.pull(block))\n+    {\n+        if (result.has_value())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected the schema query result to have one row\");\n+        if (block.columns() != 1)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected the schema query result to have one column\");\n+\n+        auto & column = block.getByPosition(0).column;\n+        if (const auto * col_str = typeid_cast<const ColumnString *>(column.get()))\n+        {\n+            result = col_str->getDataAt(0).toString();\n+            continue;\n+        }\n+\n+        if (const auto * col_const = typeid_cast<const ColumnConst *>(column.get()))\n+        {\n+            if (const auto * col_str_const = typeid_cast<const ColumnString *>(col_const->getDataColumnPtr().get()))\n+            {\n+                result = col_str_const->getDataAt(0).toString();\n+                continue;\n+            }\n+        }\n \n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected the schema query result to have one String column\");\n+    }\n+    if (!result.has_value())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Schema query result is empty\");\n+\n+    return *result;\n+}\n+\n+void FormatSchemaInfo::storeSchemaOnDisk(const fs::path & file_path, const String & content)\n+{\n+    if (!file_path.has_filename() || file_path.filename().empty())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Invalid file path {}\", file_path.string());\n+\n+    if (fs::exists(file_path))\n+    {\n+        LOG_DEBUG(log, \"Cache file {} existed, skip storing\", file_path.string());\n+        return;\n+    }\n+\n+    LOG_INFO(log, \"Storing schema to {}\", file_path.string());\n+    auto dir_path = file_path.parent_path();\n+    if (!fs::exists(dir_path))\n+    {\n+        fs::create_directory(dir_path);\n+    }\n+\n+    auto temp_path = fs::path(file_path.string() + \".tmp\");\n+\n+    try\n+    {\n+        WriteBufferFromFile out(temp_path, content.size(), O_WRONLY | O_CREAT | O_EXCL);\n+        writeString(content, out);\n+        out.next();\n+        out.sync();\n+        out.close();\n+\n+        if (fs::exists(file_path))\n+            DB::renameExchange(temp_path, file_path);\n+        else\n+            DB::renameNoReplace(temp_path, file_path);\n+\n+        fs::remove(temp_path);\n+    }\n+    catch (...)\n+    {\n+        fs::remove(temp_path);\n+        tryLogCurrentException(\"FormatSchemaInfo\", \"Unable to store schema file \" + file_path.string() + \" on disk\");\n+        if (!fs::exists(file_path))\n+            throw;\n+    }\n+}\n+\n+void FormatSchemaInfo::processSchemaFile(\n+    fs::path path, const String & default_file_extension, bool is_server, const String & format_schema_path)\n+{\n     if (!path.has_extension() && !default_file_extension.empty())\n         path = path.parent_path() / (path.stem().string() + '.' + default_file_extension);\n \n-    fs::path default_schema_directory_path(default_schema_directory());\n+    fs::path default_schema_directory_path(format_schema_path);\n     if (path.is_absolute())\n     {\n         if (is_server)\n@@ -78,15 +306,19 @@ FormatSchemaInfo::FormatSchemaInfo(const String & format_schema, const String &\n         schema_path = path.filename();\n         schema_directory = path.parent_path() / \"\";\n     }\n-    else if (path.has_parent_path() && !fs::weakly_canonical(default_schema_directory_path / path).string().starts_with(fs::weakly_canonical(default_schema_directory_path).string()))\n+    else if (\n+        path.has_parent_path()\n+        && !fs::weakly_canonical(default_schema_directory_path / path)\n+                .string()\n+                .starts_with(fs::weakly_canonical(default_schema_directory_path).string()))\n     {\n         if (is_server)\n             throw Exception(\n                 ErrorCodes::BAD_ARGUMENTS,\n                 \"Path in the 'format_schema' setting shouldn't go outside the 'format_schema_path' directory: {} ({} not in {})\",\n-                default_schema_directory(),\n+                format_schema_path,\n                 path.string(),\n-                default_schema_directory());\n+                format_schema_path);\n         path = default_schema_directory_path / path;\n         schema_path = path.filename();\n         schema_directory = path.parent_path() / \"\";\n@@ -94,14 +326,32 @@ FormatSchemaInfo::FormatSchemaInfo(const String & format_schema, const String &\n     else\n     {\n         schema_path = path;\n-        schema_directory = default_schema_directory();\n+        schema_directory = format_schema_path;\n     }\n }\n \n-FormatSchemaInfo::FormatSchemaInfo(const FormatSettings & settings, const String & format, bool require_message)\n-    : FormatSchemaInfo(\n-        settings.schema.format_schema, format, require_message, settings.schema.is_server, settings.schema.format_schema_path)\n+String FormatSchemaInfo::generateSchemaFileName(const String & hashing_content, const String & file_extention)\n {\n+#if USE_SSL\n+    String content_hash_hex;\n+    auto hash = encodeSHA256(hashing_content);\n+    content_hash_hex.resize(hash.size() * 2);\n+    boost::algorithm::hex(hash.begin(), hash.end(), content_hash_hex.data());\n+#else\n+    String content_hash_hex = getHexUIntLowercase(sipHash64(hashing_content));\n+#endif\n+\n+    static constexpr size_t CONTENT_SAMPLE_MAX_LEN = 32;\n+    size_t content_sample_len = std::min(CONTENT_SAMPLE_MAX_LEN, hashing_content.size());\n+\n+    String content_sample;\n+    content_sample.resize(content_sample_len * 2);\n+    boost::algorithm::hex(content_sample.begin(), content_sample.begin() + content_sample_len, content_sample.data());\n+\n+    if (file_extention.empty())\n+        return fmt::format(\"{}-{}\", content_sample, content_hash_hex);\n+    else\n+        return fmt::format(\"{}-{}.{}\", content_sample, content_hash_hex, file_extention);\n }\n \n template <typename SchemaGenerator>\n@@ -162,7 +412,14 @@ MaybeAutogeneratedFormatSchemaInfo<SchemaGenerator>::MaybeAutogeneratedFormatSch\n     SchemaGenerator::writeSchema(buf, \"Message\", header.getNamesAndTypesList());\n     buf.finalize();\n \n-    schema_info = std::make_unique<FormatSchemaInfo>(schema_path + \":Message\", format, true, settings.schema.is_server, settings.schema.format_schema_path);\n+    schema_info = std::make_unique<FormatSchemaInfo>(\n+        /*format_schema_source=*/FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+        /*format_schema=*/schema_path,\n+        /*format_schema_message_name=*/\"Message\",\n+        /*format=*/format,\n+        /*require_message=*/true,\n+        /*is_server*/ settings.schema.is_server,\n+        /*format_schema_path=*/settings.schema.format_schema_path);\n }\n \n template <typename SchemaGenerator>\ndiff --git a/src/Formats/FormatSchemaInfo.h b/src/Formats/FormatSchemaInfo.h\nindex 6b4ebf99aabc..fedfd3064983 100644\n--- a/src/Formats/FormatSchemaInfo.h\n+++ b/src/Formats/FormatSchemaInfo.h\n@@ -1,22 +1,36 @@\n #pragma once\n \n-#include <base/types.h>\n #include <Formats/StructureToCapnProtoSchema.h>\n #include <Formats/StructureToProtobufSchema.h>\n+#include <base/types.h>\n+#include <Common/Macros.h>\n+\n+#include <filesystem>\n \n namespace DB\n {\n class Context;\n class Block;\n struct FormatSettings;\n+namespace fs = std::filesystem;\n+\n \n /// Extracts information about where the format schema file is from passed context and keep it.\n class FormatSchemaInfo\n {\n public:\n-    FormatSchemaInfo(const String & format_schema, const String & format, bool require_message, bool is_server, const std::string & format_schema_path);\n+    FormatSchemaInfo(\n+        const String & format_schema_source,\n+        const String & format_schema,\n+        const String & format_schema_message_name,\n+        const String & format,\n+        bool require_message,\n+        bool is_server,\n+        const String & format_schema_path);\n     FormatSchemaInfo(const FormatSettings & settings, const String & format, bool require_message);\n \n+    inline static const String CACHE_DIR_NAME = \"__cache__\";\n+\n     /// Returns path to the schema file.\n     const String & schemaPath() const { return schema_path; }\n     String absoluteSchemaPath() const { return schema_directory + schema_path; }\n@@ -28,9 +42,22 @@ class FormatSchemaInfo\n     const String & messageName() const { return message_name; }\n \n private:\n+    void handleSchemaFile(\n+        const String & format_schema, const String & format, bool require_message, bool is_server, const String & format_schema_path);\n+    void verifySchemaFileName(const String & format_schema, bool require_message, fs::path & path);\n+    void handleSchemaContent(const String & content, const String & format, bool is_server, const String & format_schema_path);\n+    void handleSchemaSourceQuery(const String & format_schema, const String & format, bool is_server, const String & format_schema_path);\n+    String querySchema(const String & query);\n+    void storeSchemaOnDisk(const fs::path & file_path, const String & content);\n+    void processSchemaFile(fs::path path, const String & default_file_extension, bool is_server, const String & format_schema_path);\n+\n+    static String generateSchemaFileName(const String & hashing_content, const String & file_extention);\n+\n     String schema_path;\n     String schema_directory;\n     String message_name;\n+\n+    LoggerPtr log;\n };\n \n \ndiff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h\nindex 060f0c768fd2..cd1dcf7de329 100644\n--- a/src/Formats/FormatSettings.h\n+++ b/src/Formats/FormatSettings.h\n@@ -46,6 +46,10 @@ struct FormatSettings\n     bool try_infer_datetimes_only_datetime64 = false;\n     bool try_infer_exponent_floats = false;\n \n+    inline static const String FORMAT_SCHEMA_SOURCE_FILE = \"file\";\n+    inline static const String FORMAT_SCHEMA_SOURCE_STRING = \"string\";\n+    inline static const String FORMAT_SCHEMA_SOURCE_QUERY = \"query\";\n+\n     enum class DateTimeInputFormat : uint8_t\n     {\n         Basic,        /// Default format for fast parsing: YYYY-MM-DD hh:mm:ss (ISO-8601 without fractional part and timezone) or NNNNNNNNNN unix timestamp.\n@@ -384,7 +388,9 @@ struct FormatSettings\n \n     struct\n     {\n+        std::string format_schema_source = FORMAT_SCHEMA_SOURCE_FILE;\n         std::string format_schema;\n+        std::string format_schema_message_name;\n         std::string format_schema_path;\n         bool is_server = false;\n         std::string output_format_schema;\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 31300963d988..e1857aa29fe1 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -1,76 +1,79 @@\n-#include <Interpreters/InterpreterFactory.h>\n-#include <Interpreters/InterpreterSystemQuery.h>\n-#include <Common/DNSResolver.h>\n-#include <Common/ActionLock.h>\n-#include <Common/typeid_cast.h>\n-#include <Common/getNumberOfCPUCoresToUse.h>\n-#include <Common/SymbolIndex.h>\n-#include <Common/ThreadPool.h>\n-#include <Common/escapeForFileName.h>\n-#include <Common/ShellCommand.h>\n-#include <Common/CurrentMetrics.h>\n-#include <Common/FailPoint.h>\n-#include <Common/PageCache.h>\n-#include <Common/HostResolvePool.h>\n+#include <algorithm>\n+#include <csignal>\n+#include <filesystem>\n+#include <unistd.h>\n+#include <Access/AccessControl.h>\n+#include <Access/Common/AllowedClientHosts.h>\n+#include <Access/ContextAccess.h>\n+#include <BridgeHelper/CatBoostLibraryBridgeHelper.h>\n #include <Core/ServerSettings.h>\n #include <Core/Settings.h>\n-#include <Interpreters/Cache/FileCacheFactory.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Databases/DatabaseReplicated.h>\n+#include <Disks/ObjectStorages/IMetadataStorage.h>\n+#include <Formats/FormatSchemaInfo.h>\n+#include <Functions/UserDefined/ExternalUserDefinedExecutableFunctionsLoader.h>\n+#include <Interpreters/ActionLocksManager.h>\n+#include <Interpreters/AsynchronousInsertLog.h>\n+#include <Interpreters/AsynchronousInsertQueue.h>\n+#include <Interpreters/AsynchronousMetricLog.h>\n+#include <Interpreters/BackupLog.h>\n #include <Interpreters/Cache/FileCache.h>\n+#include <Interpreters/Cache/FileCacheFactory.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/DatabaseCatalog.h>\n-#include <Interpreters/ExternalDictionariesLoader.h>\n-#include <Functions/UserDefined/ExternalUserDefinedExecutableFunctionsLoader.h>\n #include <Interpreters/EmbeddedDictionaries.h>\n-#include <Interpreters/ActionLocksManager.h>\n+#include <Interpreters/ExternalDictionariesLoader.h>\n+#include <Interpreters/FilesystemCacheLog.h>\n #include <Interpreters/InterpreterCreateQuery.h>\n+#include <Interpreters/InterpreterFactory.h>\n #include <Interpreters/InterpreterRenameQuery.h>\n-#include <Interpreters/executeDDLQueryOnCluster.h>\n+#include <Interpreters/InterpreterSystemQuery.h>\n+#include <Interpreters/JIT/CompiledExpressionCache.h>\n+#include <Interpreters/MetricLog.h>\n+#include <Interpreters/OpenTelemetrySpanLog.h>\n+#include <Interpreters/ProcessorsProfileLog.h>\n #include <Interpreters/QueryThreadLog.h>\n #include <Interpreters/QueryViewsLog.h>\n #include <Interpreters/SessionLog.h>\n-#include <Interpreters/TraceLog.h>\n #include <Interpreters/TextLog.h>\n-#include <Interpreters/MetricLog.h>\n-#include <Interpreters/AsynchronousMetricLog.h>\n-#include <Interpreters/OpenTelemetrySpanLog.h>\n-#include <Interpreters/ZooKeeperLog.h>\n-#include <Interpreters/FilesystemCacheLog.h>\n-#include <Interpreters/TransactionsInfoLog.h>\n-#include <Interpreters/ProcessorsProfileLog.h>\n-#include <Interpreters/AsynchronousInsertLog.h>\n-#include <Interpreters/BackupLog.h>\n-#include <Interpreters/JIT/CompiledExpressionCache.h>\n+#include <Interpreters/TraceLog.h>\n #include <Interpreters/TransactionLog.h>\n-#include <Interpreters/AsynchronousInsertQueue.h>\n-#include <BridgeHelper/CatBoostLibraryBridgeHelper.h>\n-#include <Access/AccessControl.h>\n-#include <Access/ContextAccess.h>\n-#include <Access/Common/AllowedClientHosts.h>\n-#include <Databases/DatabaseReplicated.h>\n-#include <DataTypes/DataTypeString.h>\n-#include <Disks/ObjectStorages/IMetadataStorage.h>\n-#include <Storages/StorageDistributed.h>\n-#include <Storages/StorageReplicatedMergeTree.h>\n+#include <Interpreters/TransactionsInfoLog.h>\n+#include <Interpreters/ZooKeeperLog.h>\n+#include <Interpreters/executeDDLQueryOnCluster.h>\n+#include <Parsers/ASTCreateQuery.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Parsers/ASTSystemQuery.h>\n+#include <Processors/Sources/SourceFromSingleChunk.h>\n #include <Storages/Freeze.h>\n+#include <Storages/MaterializedView/RefreshTask.h>\n+#include <Storages/ObjectStorage/Azure/Configuration.h>\n+#include <Storages/ObjectStorage/HDFS/Configuration.h>\n+#include <Storages/ObjectStorage/S3/Configuration.h>\n+#include <Storages/ObjectStorage/StorageObjectStorage.h>\n+#include <Storages/StorageDistributed.h>\n #include <Storages/StorageFactory.h>\n #include <Storages/StorageFile.h>\n #include <Storages/StorageMaterializedView.h>\n+#include <Storages/StorageReplicatedMergeTree.h>\n #include <Storages/StorageURL.h>\n-#include <Storages/ObjectStorage/StorageObjectStorage.h>\n-#include <Storages/ObjectStorage/S3/Configuration.h>\n-#include <Storages/ObjectStorage/HDFS/Configuration.h>\n-#include <Storages/ObjectStorage/Azure/Configuration.h>\n-#include <Storages/MaterializedView/RefreshTask.h>\n #include <Storages/System/StorageSystemFilesystemCache.h>\n-#include <Parsers/ASTSystemQuery.h>\n-#include <Parsers/ASTCreateQuery.h>\n-#include <Parsers/ASTSetQuery.h>\n-#include <Processors/Sources/SourceFromSingleChunk.h>\n-#include <Common/ThreadFuzzer.h>\n #include <base/coverage.h>\n-#include <csignal>\n-#include <algorithm>\n-#include <unistd.h>\n+#include <Common/ActionLock.h>\n+#include <Common/CurrentMetrics.h>\n+#include <Common/DNSResolver.h>\n+#include <Common/FailPoint.h>\n+#include <Common/HostResolvePool.h>\n+#include <Common/PageCache.h>\n+#include <Common/ShellCommand.h>\n+#include <Common/SymbolIndex.h>\n+#include <Common/ThreadFuzzer.h>\n+#include <Common/ThreadPool.h>\n+#include <Common/escapeForFileName.h>\n+#include <Common/getNumberOfCPUCoresToUse.h>\n+#include <Common/logger_useful.h>\n+#include <Common/typeid_cast.h>\n \n #if USE_PROTOBUF\n #include <Formats/ProtobufSchemas.h>\n@@ -578,13 +581,30 @@ BlockIO InterpreterSystemQuery::execute()\n             getContext()->checkAccess(AccessType::SYSTEM_DROP_FORMAT_SCHEMA_CACHE);\n             std::unordered_set<String> caches_to_drop;\n             if (query.schema_cache_format.empty())\n-                caches_to_drop = {\"Protobuf\"};\n+                caches_to_drop = {\"Protobuf\", \"Files\"};\n             else\n                 caches_to_drop = {query.schema_cache_format};\n #if USE_PROTOBUF\n             if (caches_to_drop.contains(\"Protobuf\"))\n                 ProtobufSchemas::instance().clear();\n #endif\n+            if (caches_to_drop.contains(\"Files\"))\n+            {\n+                fs::path format_schema_cached_dir = fs::path(system_context->getFormatSchemaPath()) / FormatSchemaInfo::CACHE_DIR_NAME;\n+                if (fs::exists(format_schema_cached_dir))\n+                {\n+                    size_t count = 0;\n+                    for (const auto & entry : fs::directory_iterator(format_schema_cached_dir))\n+                    {\n+                        if (entry.is_regular_file())\n+                        {\n+                            fs::remove(entry.path());\n+                            count++;\n+                        }\n+                    }\n+                    LOG_INFO(log, \"Cleared format schema cache files {}\", count);\n+                }\n+            }\n             break;\n         }\n         case Type::RELOAD_DICTIONARY:\ndiff --git a/src/Parsers/CommonParsers.h b/src/Parsers/CommonParsers.h\nindex ef6bd1154618..e4db7beb9d4e 100644\n--- a/src/Parsers/CommonParsers.h\n+++ b/src/Parsers/CommonParsers.h\n@@ -83,7 +83,7 @@ namespace DB\n     MR_MACROS(CHARACTER, \"CHARACTER\") \\\n     MR_MACROS(CHECK_ALL_TABLES, \"CHECK ALL TABLES\") \\\n     MR_MACROS(CHECK_TABLE, \"CHECK TABLE\") \\\n-    MR_MACROS(CHECK_GRANT, \"CHECK GRANT\")\\\n+    MR_MACROS(CHECK_GRANT, \"CHECK GRANT\") \\\n     MR_MACROS(CHECK, \"CHECK\") \\\n     MR_MACROS(CLEANUP, \"CLEANUP\") \\\n     MR_MACROS(CLEAR_COLUMN, \"CLEAR COLUMN\") \\\n@@ -393,6 +393,7 @@ namespace DB\n     MR_MACROS(PROFILES, \"PROFILES\") \\\n     MR_MACROS(PROJECTION, \"PROJECTION\") \\\n     MR_MACROS(PROTOBUF, \"Protobuf\") \\\n+    MR_MACROS(FILES, \"Files\") \\\n     MR_MACROS(PULL, \"PULL\") \\\n     MR_MACROS(Q, \"Q\") \\\n     MR_MACROS(QQ, \"QQ\") \\\n@@ -457,7 +458,7 @@ namespace DB\n     MR_MACROS(SET_ROLE_DEFAULT, \"SET ROLE DEFAULT\") \\\n     MR_MACROS(SET_ROLE, \"SET ROLE\") \\\n     MR_MACROS(SET_TRANSACTION_SNAPSHOT, \"SET TRANSACTION SNAPSHOT\") \\\n-    MR_MACROS(SET, \"SET\")                    \\\n+    MR_MACROS(SET, \"SET\") \\\n     MR_MACROS(SETTING, \"SETTING\") \\\n     MR_MACROS(SETTINGS, \"SETTINGS\") \\\n     MR_MACROS(SHOW_ACCESS, \"SHOW ACCESS\") \\\n@@ -562,7 +563,7 @@ namespace DB\n     MR_MACROS(YY, \"YY\") \\\n     MR_MACROS(YYYY, \"YYYY\") \\\n     MR_MACROS(ZKPATH, \"ZKPATH\") \\\n-    MR_MACROS(STALENESS, \"STALENESS\") \\\n+    MR_MACROS(STALENESS, \"STALENESS\")\n \n /// The list of keywords where underscore is intentional\n #define APPLY_FOR_PARSER_KEYWORDS_WITH_UNDERSCORES(MR_MACROS) \\\ndiff --git a/src/Parsers/ParserSystemQuery.cpp b/src/Parsers/ParserSystemQuery.cpp\nindex 195fe6937733..62e8cc5cfdc4 100644\n--- a/src/Parsers/ParserSystemQuery.cpp\n+++ b/src/Parsers/ParserSystemQuery.cpp\n@@ -582,7 +582,8 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n             {\n                 if (ParserKeyword{Keyword::PROTOBUF}.ignore(pos, expected))\n                     res->schema_cache_format = toStringView(Keyword::PROTOBUF);\n-\n+                else if (ParserKeyword{Keyword::FILES}.ignore(pos, expected))\n+                    res->schema_cache_format = toStringView(Keyword::FILES);\n                 else\n                     return false;\n             }\ndiff --git a/src/Processors/Formats/Impl/CapnProtoRowInputFormat.cpp b/src/Processors/Formats/Impl/CapnProtoRowInputFormat.cpp\nindex 12bb5aef1688..106c68ecf37b 100644\n--- a/src/Processors/Formats/Impl/CapnProtoRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/CapnProtoRowInputFormat.cpp\n@@ -121,11 +121,13 @@ CapnProtoSchemaReader::CapnProtoSchemaReader(const FormatSettings & format_setti\n NamesAndTypesList CapnProtoSchemaReader::readSchema()\n {\n     auto schema_info = FormatSchemaInfo(\n-        format_settings.schema.format_schema,\n-        \"CapnProto\",\n-        true,\n-        format_settings.schema.is_server,\n-        format_settings.schema.format_schema_path);\n+        /*format_schema_source=*/format_settings.schema.format_schema_source,\n+        /*format_schema=*/format_settings.schema.format_schema,\n+        /*format_schema_message_name=*/format_settings.schema.format_schema_message_name,\n+        /*format=*/\"CapnProto\",\n+        /*require_message=*/true,\n+        /*is_server=*/format_settings.schema.is_server,\n+        /*format_schema_path=*/format_settings.schema.format_schema_path);\n \n     auto schema_parser = CapnProtoSchemaParser();\n     auto schema = schema_parser.getMessageSchema(schema_info);\ndiff --git a/src/Processors/Formats/Impl/ProtobufListInputFormat.cpp b/src/Processors/Formats/Impl/ProtobufListInputFormat.cpp\nindex 4f8105a3c5b0..ec6d3411f093 100644\n--- a/src/Processors/Formats/Impl/ProtobufListInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ProtobufListInputFormat.cpp\n@@ -87,7 +87,13 @@ size_t ProtobufListInputFormat::countRows(size_t max_block_size)\n \n ProtobufListSchemaReader::ProtobufListSchemaReader(const FormatSettings & format_settings)\n     : schema_info(\n-        format_settings.schema.format_schema, \"Protobuf\", true, format_settings.schema.is_server, format_settings.schema.format_schema_path)\n+          /*format_schema_source=*/format_settings.schema.format_schema_source,\n+          /*format_schema=*/format_settings.schema.format_schema,\n+          /*format_schema_message_name=*/format_settings.schema.format_schema_message_name,\n+          /*format=*/\"Protobuf\",\n+          /*require_message=*/true,\n+          /*is_server=*/format_settings.schema.is_server,\n+          /*format_schema_path=*/format_settings.schema.format_schema_path)\n     , skip_unsupported_fields(format_settings.protobuf.skip_fields_with_unsupported_types_in_schema_inference)\n     , google_protos_path(format_settings.protobuf.google_protos_path)\n {\ndiff --git a/src/Processors/Formats/Impl/ProtobufRowInputFormat.cpp b/src/Processors/Formats/Impl/ProtobufRowInputFormat.cpp\nindex e7454e2951e5..2e03f0ce283f 100644\n--- a/src/Processors/Formats/Impl/ProtobufRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ProtobufRowInputFormat.cpp\n@@ -125,7 +125,13 @@ void registerInputFormatProtobuf(FormatFactory & factory)\n \n ProtobufSchemaReader::ProtobufSchemaReader(const FormatSettings & format_settings)\n     : schema_info(\n-        format_settings.schema.format_schema, \"Protobuf\", true, format_settings.schema.is_server, format_settings.schema.format_schema_path)\n+          /*format_schema_source=*/format_settings.schema.format_schema_source,\n+          /*format_schema=*/format_settings.schema.format_schema,\n+          /*format_schema_message_name=*/format_settings.schema.format_schema_message_name,\n+          /*format=*/\"Protobuf\",\n+          /*require_message=*/true,\n+          /*is_server=*/format_settings.schema.is_server,\n+          /*format_schema_path=*/format_settings.schema.format_schema_path)\n     , skip_unsupported_fields(format_settings.protobuf.skip_fields_with_unsupported_types_in_schema_inference)\n     , google_protos_path(format_settings.protobuf.google_protos_path)\n {\ndiff --git a/src/Processors/Formats/Impl/TemplateBlockOutputFormat.cpp b/src/Processors/Formats/Impl/TemplateBlockOutputFormat.cpp\nindex f68a82eb73e8..9280ba95ec7e 100644\n--- a/src/Processors/Formats/Impl/TemplateBlockOutputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TemplateBlockOutputFormat.cpp\n@@ -1,9 +1,10 @@\n-#include <Processors/Formats/Impl/TemplateBlockOutputFormat.h>\n-#include <Formats/FormatFactory.h>\n-#include <Formats/EscapingRuleUtils.h>\n #include <Columns/IColumn.h>\n-#include <IO/WriteHelpers.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <Formats/EscapingRuleUtils.h>\n+#include <Formats/FormatFactory.h>\n+#include <Formats/FormatSettings.h>\n+#include <IO/WriteHelpers.h>\n+#include <Processors/Formats/Impl/TemplateBlockOutputFormat.h>\n #include <Processors/Port.h>\n \n \n@@ -228,9 +229,15 @@ void registerOutputFormatTemplate(FormatFactory & factory)\n         {\n             /// Read format string from file\n             resultset_format = ParsedTemplateFormatString(\n-                    FormatSchemaInfo(settings.template_settings.resultset_format, \"Template\", false,\n-                            settings.schema.is_server, settings.schema.format_schema_path),\n-                    idx_resultset_by_name);\n+                FormatSchemaInfo(\n+                    /*format_schema_source=*/FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+                    /*format_schema=*/settings.template_settings.resultset_format,\n+                    /*format_schema_message_name=*/\"\",\n+                    /*format=*/\"Template\",\n+                    /*require_message=*/false,\n+                    /*is_server=*/settings.schema.is_server,\n+                    /*format_schema_path=*/settings.schema.format_schema_path),\n+                idx_resultset_by_name);\n             if (!settings.template_settings.resultset_format_template.empty())\n             {\n                 throw Exception(DB::ErrorCodes::INVALID_TEMPLATE_FORMAT, \"Expected either format_template_resultset or format_template_resultset_format, but not both\");\n@@ -250,8 +257,14 @@ void registerOutputFormatTemplate(FormatFactory & factory)\n         else\n         {\n             row_format = ParsedTemplateFormatString(\n-                FormatSchemaInfo(settings.template_settings.row_format, \"Template\", false,\n-                        settings.schema.is_server, settings.schema.format_schema_path),\n+                FormatSchemaInfo(\n+                    /*format_schema_source=*/FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+                    /*format_schema=*/settings.template_settings.row_format,\n+                    /*format_schema_message_name=*/\"\",\n+                    /*format=*/\"Template\",\n+                    /*require_message=*/false,\n+                    /*is_server=*/settings.schema.is_server,\n+                    /*format_schema_path=*/settings.schema.format_schema_path),\n                 idx_row_by_name);\n             if (!settings.template_settings.row_format_template.empty())\n             {\n@@ -266,12 +279,15 @@ void registerOutputFormatTemplate(FormatFactory & factory)\n         if (settings.template_settings.resultset_format.empty())\n             return true;\n         auto resultset_format = ParsedTemplateFormatString(\n-            FormatSchemaInfo(settings.template_settings.resultset_format, \"Template\", false,\n-                             settings.schema.is_server, settings.schema.format_schema_path),\n-            [&](const String & partName)\n-            {\n-                return static_cast<size_t>(TemplateBlockOutputFormat::stringToResultsetPart(partName));\n-            });\n+            FormatSchemaInfo(\n+                /*format_schema_source=*/FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+                /*format_schema=*/settings.template_settings.resultset_format,\n+                /*format_schema_message_name=*/\"\",\n+                /*format=*/\"Template\",\n+                /*require_message=*/false,\n+                /*is_server=*/settings.schema.is_server,\n+                /*format_schema_path=*/settings.schema.format_schema_path),\n+            [&](const String & partName) { return static_cast<size_t>(TemplateBlockOutputFormat::stringToResultsetPart(partName)); });\n         return resultset_format.delimiters.empty() || resultset_format.delimiters.back().empty();\n     });\n }\ndiff --git a/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp b/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\nindex f5edfb7c9d4d..69eea8a2e36a 100644\n--- a/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n@@ -545,8 +545,14 @@ static ParsedTemplateFormatString fillResultSetFormat(const FormatSettings & set\n     {\n         /// Read format string from file\n         resultset_format = ParsedTemplateFormatString(\n-            FormatSchemaInfo(settings.template_settings.resultset_format, \"Template\", false,\n-                             settings.schema.is_server, settings.schema.format_schema_path),\n+            FormatSchemaInfo(\n+                /*format_schema_source=*/FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+                /*format_schema=*/settings.template_settings.resultset_format,\n+                /*format_schema_message_name=*/\"\",\n+                /*format=*/\"Template\",\n+                /*require_message=*/false,\n+                /*is_server=*/settings.schema.is_server,\n+                /*format_schema_path=*/settings.schema.format_schema_path),\n             [&](const String & partName) -> std::optional<size_t>\n             {\n                 if (partName == \"data\")\n@@ -561,8 +567,15 @@ static ParsedTemplateFormatString fillRowFormat(const FormatSettings & settings,\n {\n     return ParsedTemplateFormatString(\n         FormatSchemaInfo(\n-            settings.template_settings.row_format, \"Template\", false, settings.schema.is_server, settings.schema.format_schema_path),\n-        idx_getter, allow_indexes);\n+            /*format_schema_source=*/FormatSettings::FORMAT_SCHEMA_SOURCE_FILE,\n+            /*format_schema=*/settings.template_settings.row_format,\n+            /*format_schema_message_name=*/\"\",\n+            /*format=*/\"Template\",\n+            /*require_message=*/false,\n+            /*is_server=*/settings.schema.is_server,\n+            /*format_schema_path=*/settings.schema.format_schema_path),\n+        idx_getter,\n+        allow_indexes);\n }\n \n void registerInputFormatTemplate(FormatFactory & factory)\n",
  "test_patch": "diff --git a/tests/integration/test_format_schema_source/__init__.py b/tests/integration/test_format_schema_source/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/new_simple.capnp b/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/new_simple.capnp\nnew file mode 100755\nindex 000000000000..ca4d2dd4bf26\n--- /dev/null\n+++ b/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/new_simple.capnp\n@@ -0,0 +1,6 @@\n+@0x801f030c2b67bf19;\n+\n+struct MessageTmp {\n+    key2 @0 :UInt64;\n+    value2 @1 :Text;\n+}\n\\ No newline at end of file\ndiff --git a/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/simple.capnp b/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/simple.capnp\nnew file mode 100755\nindex 000000000000..5de6c86dda2d\n--- /dev/null\n+++ b/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/simple.capnp\n@@ -0,0 +1,6 @@\n+@0x801f030c2b67bf19;\n+\n+struct MessageTmp {\n+    key @0 :UInt64;\n+    value @1 :Text;\n+}\n\\ No newline at end of file\ndiff --git a/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/simple.proto b/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/simple.proto\nnew file mode 100755\nindex 000000000000..96b24be49389\n--- /dev/null\n+++ b/tests/integration/test_format_schema_source/clickhouse_path/format_schemas/simple.proto\n@@ -0,0 +1,6 @@\n+syntax = \"proto3\";\n+\n+message KeyValuePair {\n+  uint64 key = 1;\n+  string value = 2;\n+}\n\\ No newline at end of file\ndiff --git a/tests/integration/test_format_schema_source/test.py b/tests/integration/test_format_schema_source/test.py\nnew file mode 100644\nindex 000000000000..1121d9165a57\n--- /dev/null\n+++ b/tests/integration/test_format_schema_source/test.py\n@@ -0,0 +1,365 @@\n+import os\n+import uuid\n+\n+import pytest\n+\n+from helpers.client import QueryRuntimeException\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+instance = cluster.add_instance(\"instance\", clickhouse_path_dir=\"clickhouse_path\")\n+database_path = os.path.abspath(os.path.join(instance.path, \"database\"))\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def create_simple_table():\n+    instance.query(\"DROP TABLE IF EXISTS test.simple\")\n+    instance.query(\n+        \"\"\"\n+        CREATE TABLE test.simple (key UInt64, value String)\n+            ENGINE = MergeTree ORDER BY tuple();\n+        \"\"\"\n+    )\n+\n+\n+def get_format_schema(\n+    format_schema_source: str,\n+    schema_content: str,\n+    target_file_name: str = \"\",\n+    file_extention=\"proto\",\n+):\n+    if format_schema_source == \"file\":\n+        if target_file_name == \"\":\n+            target_file_name = f\"__generated__{uuid.uuid4().hex}.{file_extention}\"\n+        file_path = os.path.join(database_path, \"format_schemas\", target_file_name)\n+        if os.path.exists(file_path):\n+            os.remove(file_path)\n+        with open(file_path, \"w\") as file:\n+            file.write(schema_content)\n+        return target_file_name\n+\n+    if format_schema_source == \"string\":\n+        return schema_content\n+\n+    if format_schema_source == \"query\":\n+        instance.query(\n+            \"CREATE OR REPLACE TABLE test.schemas (id Int, format_schema String) ENGINE=MergeTree ORDER BY id\"\n+        )\n+        instance.query(\n+            f\"INSERT INTO test.schemas VALUES(1, '{schema_content.encode('utf-8').hex()}')\"\n+        )\n+        return \"SELECT unhex(format_schema) FROM test.schemas WHERE id=1\"\n+\n+    raise Exception(f\"Invalid format_schema_source {format_schema_source}\")\n+\n+\n+def test_protobuf_format_input_with_old_setting(started_cluster):\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    instance.http_query(\n+        \"INSERT INTO test.simple SETTINGS format_schema='simple:KeyValuePair' FORMAT Protobuf\",\n+        \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\",\n+    )\n+    assert instance.query(\"SELECT * from test.simple\") == \"1\\tabc\\n2\\tdef\\n\"\n+\n+    with pytest.raises(Exception) as exc:\n+        instance.http_query(\n+            \"INSERT INTO test.simple SETTINGS format_schema='simple:KeyValuePair' format_schema_message_name='KeyValuePair' FORMAT Protobuf\",\n+            \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\",\n+        )\n+\n+    with pytest.raises(Exception) as exc:\n+        instance.http_query(\n+            \"INSERT INTO test.simple SETTINGS format_schema='simple:KeyValuePair' format_schema_message_name='Tmp' FORMAT Protobuf\",\n+            \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\",\n+        )\n+    with pytest.raises(Exception) as exc:\n+        instance.http_query(\n+            \"INSERT INTO test.simple SETTINGS format_schema='simple:' format_schema_message_name='Tmp' FORMAT Protobuf\",\n+            \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\",\n+        )\n+\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+\n+def test_protobuf_format_output_with_old_setting(started_cluster):\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    instance.query(\"INSERT INTO test.simple VALUES (1, 'abc'), (2, 'def')\")\n+    assert (\n+        instance.http_query(\n+            \"SELECT * FROM test.simple FORMAT Protobuf SETTINGS format_schema='simple:KeyValuePair'\"\n+        )\n+        == \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\"\n+    )\n+\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+\n+\n+@pytest.mark.parametrize(\"format_schema_source\", [\"file\", \"string\", \"query\"])\n+def test_protobuf_format_input_with_format_schema_source(started_cluster, format_schema_source : str):\n+    schema = \"\"\"\n+syntax = \"proto3\";\n+\n+message KeyValuePair { \n+    uint64 key = 1;\n+    string value = 2;\n+}\n+\"\"\"\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE\")\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    format_schema = get_format_schema(format_schema_source, schema)\n+    instance.http_query(\n+        f\"INSERT INTO test.simple SETTINGS format_schema_source='{format_schema_source}', format_schema='{format_schema}', format_schema_message_name='KeyValuePair' FORMAT Protobuf\",\n+        \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\",\n+    )\n+    assert instance.query(\"SELECT * from test.simple\") == \"1\\tabc\\n2\\tdef\\n\"\n+\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    if format_schema_source == \"file\":\n+        os.remove(os.path.join(database_path, \"format_schemas\", format_schema))\n+\n+@pytest.mark.parametrize(\"format_schema_source\", [\"file\", \"string\", \"query\"])\n+def test_protobuf_format_output_with_format_schema_source(started_cluster, format_schema_source : str):\n+    schema = \"\"\"\n+syntax = \"proto3\";\n+\n+message KeyValuePair { \n+    uint64 key = 1;\n+    string value = 2;\n+}\n+\"\"\"\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE\")\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    instance.query(\"INSERT INTO test.simple VALUES (1, 'abc'), (2, 'def')\")\n+\n+    format_schema = get_format_schema(format_schema_source, schema)\n+    assert (\n+        instance.http_query(\n+            f\"SELECT * FROM test.simple SETTINGS format_schema_source='{format_schema_source}', format_schema='{format_schema}', format_schema_message_name='KeyValuePair' FORMAT Protobuf\"\n+        )\n+        == \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\"\n+    )\n+\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    if format_schema_source == \"file\":\n+        os.remove(os.path.join(database_path, \"format_schemas\", format_schema))\n+\n+\n+def test_protobuf_format_output_with_format_schema_source_clear_cache_files(\n+    started_cluster,\n+):\n+    schema = \"\"\"\n+syntax = \"proto3\";\n+\n+message KeyValuePair { \n+    uint64 key = 1;\n+    string value = 2;\n+}\n+\"\"\"\n+\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE\")\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    instance.query(\"INSERT INTO test.simple VALUES (1, 'abc'), (2, 'def')\")\n+\n+    format_schema = get_format_schema(\"query\", schema)\n+    format_schema_content = instance.query(format_schema)\n+    assert (\n+        instance.http_query(\n+            f\"SELECT * FROM test.simple SETTINGS format_schema_source='query', format_schema='{format_schema}', format_schema_message_name='KeyValuePair' FORMAT Protobuf\"\n+        )\n+        == \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\"\n+    )\n+\n+    new_schema = \"\"\"\n+syntax = \"proto3\";\n+\n+message MessageTmp { \n+    uint64 key2 = 1;\n+    string value2 = 2;\n+}\n+\"\"\"\n+    new_format_schema = get_format_schema(\"query\", new_schema)\n+    new_format_schema_content = instance.query(new_format_schema)\n+\n+    assert new_format_schema == format_schema\n+    assert new_format_schema_content != format_schema_content\n+\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE FOR Protobuf\")\n+    # Not clear cached file yet, still work as the old schema is still being used\n+    assert (\n+        instance.http_query(\n+            f\"SELECT * FROM test.simple SETTINGS format_schema_source='query', format_schema='{format_schema}', format_schema_message_name='KeyValuePair' FORMAT Protobuf\"\n+        )\n+        == \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\"\n+    )\n+\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE FOR Files\")\n+    # After clearing, not work with new schema\n+    with pytest.raises(Exception) as exc:\n+        instance.http_query(\n+            f\"SELECT * FROM test.simple SETTINGS format_schema_source='query', format_schema='{format_schema}', format_schema_message_name='MessageTmp' FORMAT Protobuf\"\n+        )\n+\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+\n+\n+@pytest.mark.parametrize(\"format_schema_source\", [\"file\", \"string\", \"query\"])\n+def test_drop_cache_protobuf_format_with_format_schema_source(\n+    started_cluster, format_schema_source: str\n+):\n+\n+    schema = \"\"\"\n+syntax = \"proto3\";\n+\n+message MessageTmp {\n+    uint64 key = 1;\n+    string value = 2;\n+}\n+\"\"\"\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE\")\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    instance.query(\"INSERT INTO test.simple VALUES (1, 'abc'), (2, 'def')\")\n+\n+    format_schema = get_format_schema(format_schema_source, schema, \"message_tmp.proto\")\n+    assert (\n+        instance.http_query(\n+            f\"SELECT * FROM test.simple SETTINGS format_schema_source='{format_schema_source}', format_schema='{format_schema}', format_schema_message_name='MessageTmp' FORMAT Protobuf\"\n+        )\n+        == \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\"\n+    )\n+\n+    # Replace simple.proto with a new Protobuf schema\n+    new_schema = \"\"\"\n+syntax = \"proto3\";\n+\n+message MessageTmp { \n+    uint64 key2 = 1;\n+    string value2 = 2;\n+}\n+\"\"\"\n+    new_format_schema = get_format_schema(format_schema_source, new_schema, \"message_tmp.proto\")\n+\n+    instance.query(\"DROP TABLE IF EXISTS test.new_simple\")\n+    instance.query(\n+        \"\"\"\n+        CREATE TABLE test.new_simple (key2 UInt64, value2 String)\n+            ENGINE = MergeTree ORDER BY tuple();\n+        \"\"\"\n+    )\n+    instance.query(\"INSERT INTO test.new_simple VALUES (1, 'abc'), (2, 'def')\")\n+\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE FOR Protobuf\")\n+    if format_schema_source != \"file\":\n+        instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE FOR Files\")\n+\n+    # Tets works with new scheme\n+    assert (\n+        instance.http_query(\n+            f\"SELECT * FROM test.new_simple SETTINGS format_schema_source='{format_schema_source}', format_schema='{new_format_schema}', format_schema_message_name='MessageTmp' FORMAT Protobuf\"\n+        )\n+        == \"\\x07\\x08\\x01\\x12\\x03abc\\x07\\x08\\x02\\x12\\x03def\"\n+    )\n+    # Tests that stop working with old scheme\n+    with pytest.raises(Exception) as exc:\n+        instance.http_query(\n+            \"SELECT * FROM test.simple SETTINGS format_schema_source='{format_schema_source}', format_schema='{new_format_schema}', format_schema_message_name='MessageTmp' FORMAT Protobuf\"\n+        )\n+\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    if format_schema_source == \"file\":\n+        os.remove(os.path.join(database_path, \"format_schemas\", format_schema))\n+\n+\n+@pytest.mark.parametrize(\"format_schema_source\", [\"file\", \"string\", \"query\"])\n+def test_drop_capn_proto_format_with_format_schema_source(\n+    started_cluster, format_schema_source: str\n+):\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE\")\n+    instance.query(\"DROP DATABASE IF EXISTS test SYNC\")\n+    instance.query(\"CREATE DATABASE test\")\n+\n+    create_simple_table()\n+    instance.query(\"INSERT INTO test.simple VALUES (1, 'abc'), (2, 'def')\")\n+    capn_proto_schema = \"\"\"\n+@0x801f030c2b67bf19;\n+\n+struct MessageTmp {\n+    key @0 :UInt64;\n+    value @1 :Text;\n+}\n+\"\"\"\n+    format_schema = get_format_schema(\n+        format_schema_source, capn_proto_schema, \"message_tmp.capnp\"\n+    )\n+\n+    database_path = os.path.abspath(os.path.join(instance.path, \"database\"))\n+    format_schemas_path = os.path.join(database_path, \"format_schemas\")\n+\n+    assert instance.http_query(\n+        f\"SELECT * FROM test.simple FORMAT CapnProto SETTINGS format_schema_source='{format_schema_source}', format_schema='{format_schema}', format_schema_message_name='MessageTmp'\"\n+    ) == instance.query(\n+        f\"SELECT * FROM test.simple Format CapnProto SETTINGS format_schema='{format_schemas_path}/simple:MessageTmp'\"\n+    )\n+\n+    instance.query(\"SYSTEM DROP FORMAT SCHEMA CACHE\")\n+\n+    new_schema = \"\"\"\n+@0x801f030c2b67bf19;\n+\n+struct MessageTmp {\n+    key2 @0 :UInt64;\n+    value2 @1 :Text;\n+}\n+\"\"\"\n+    new_format_schema = get_format_schema(\n+        format_schema_source, new_schema, \"message_tmp.capnp\"\n+    )\n+\n+    instance.query(\"DROP TABLE IF EXISTS test.new_simple\")\n+    instance.query(\n+        \"\"\"\n+        CREATE TABLE test.new_simple (key2 UInt64, value2 String)\n+            ENGINE = MergeTree ORDER BY tuple();\n+        \"\"\"\n+    )\n+    instance.query(\"INSERT INTO test.new_simple VALUES (1, 'abc'), (2, 'def')\")\n+\n+    # Tets works with new scheme\n+    assert instance.http_query(\n+        f\"SELECT * FROM test.new_simple FORMAT CapnProto SETTINGS format_schema_source='{format_schema_source}', format_schema='{new_format_schema}', format_schema_message_name='MessageTmp'\"\n+    ) == instance.query(\n+        f\"SELECT * FROM test.new_simple Format CapnProto SETTINGS format_schema='{format_schemas_path}/new_simple:MessageTmp'\"\n+    )\n+    # Tests that stop working with old scheme\n+    with pytest.raises(Exception) as exc:\n+        instance.http_query(\n+            f\"SELECT * FROM test.simple FORMAT CapnProto SETTINGS format_schema_source='{format_schema_source}', format_schema='{new_format_schema}', format_schema_message_name='MessageTmp'\"\n+        )\n+    assert (\n+        \"Capnproto schema doesn't contain field with name key. (THERE_IS_NO_COLUMN)\"\n+        in str(exc.value)\n+    )\n",
  "problem_statement": "Add a setting `format_schema_source`\n### Company or project name\n\n_No response_\n\n### Use case\n\nLoading Protobuf and CapNProto schemas dynamically.\n\nThis is a duplicate of #21096.\n\n### Describe the solution you'd like\n\nThe new setting, `format_schema_source` can have one of the following values:\n- `file` - the default: the value of `format_schema` determines the file name with the schema inside the `format_schemas` directory;\n- `string` - the value of `format_schema` is the actual content of the corresponding Protobuf or CapNProto schema;\n- `table` - the value of `format_schema` determines the name that is looked up in the `system.format_schemas` table.\n\nIf the source is `string`, the value of the `format_schema` will be used as the explicit format_schema. So you can dump the whole Protobuf schema into it.\n\nThe downside of this \"immediate value\" mode is that it will be sent over the network every time and pollute the query_log. However, it is usable for small schemas under several KB, which are the most common schemas.\n\nIf the source is `table`, the schema will be loaded from the `system.format_schemas` table with the following query: `SELECT value FROM system.format_schemas WHERE name = 'format_schema'` and use the corresponding value as the schema. The query should be run only if the format needs the schema. This query is run every time and caching is out of scope. We don't have to check access control to this table, as creating and managing the `system.format_schemas` table is the operator's responsibility.\n\n### Describe alternatives you've considered\n\n_No response_\n\n### Additional context\n\nWe should do fuzzing the Protobuf and CapNProto schemas.\nWhile we don't compile the schema and don't use Protobuf's or CapNProto structures (we read and write data manually), we still use these 3rd-party libraries to parse the schema definition.\n",
  "hints_text": "WDYT about a `query` value? So `format_schema` will contain a scalar query that returns a string. It's more flexible than `table`, and it will be possible to fetch schemas from S3, for example, without changing `system.format_schemas` (which requires extra grants)\nSlightly worried as\n> This query is run every time and caching is out of scope.",
  "created_at": "2025-05-27T08:20:48Z"
}