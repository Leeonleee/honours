diff --git a/src/Parsers/ParserCreateIndexQuery.cpp b/src/Parsers/ParserCreateIndexQuery.cpp
index fd2bbbab1778..2fa34696c58f 100644
--- a/src/Parsers/ParserCreateIndexQuery.cpp
+++ b/src/Parsers/ParserCreateIndexQuery.cpp
@@ -17,9 +17,9 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected
 {
     ParserKeyword s_type(Keyword::TYPE);
     ParserKeyword s_granularity(Keyword::GRANULARITY);
-    ParserToken open(TokenType::OpeningRoundBracket);
-    ParserToken close(TokenType::ClosingRoundBracket);
-    ParserOrderByExpressionList order_list;
+    ParserToken open_p(TokenType::OpeningRoundBracket);
+    ParserToken close_p(TokenType::ClosingRoundBracket);
+    ParserOrderByExpressionList order_list_p;
 
     ParserDataType data_type_p;
     ParserExpression expression_p;
@@ -29,17 +29,41 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected
     ASTPtr type;
     ASTPtr granularity;
 
-    /// Skip name parser for SQL-standard CREATE INDEX
-    if (expression_p.parse(pos, expr, expected))
+    if (open_p.ignore(pos, expected))
     {
-    }
-    else if (open.ignore(pos, expected))
-    {
-        if (!order_list.parse(pos, expr, expected))
+        ASTPtr order_list;
+        if (!order_list_p.parse(pos, order_list, expected))
+            return false;
+
+        if (!close_p.ignore(pos, expected))
             return false;
 
-        if (!close.ignore(pos, expected))
+        if (order_list->children.empty())
             return false;
+
+        /// CREATE INDEX with ASC, DESC is implemented only for SQL compatibility.
+        /// ASC and DESC modifiers are not supported and are ignored further.
+        if (order_list->children.size() == 1)
+        {
+            auto order_by_elem = order_list->children[0];
+            expr = order_by_elem->children[0];
+        }
+        else
+        {
+            auto tuple_func = makeASTFunction("tuple");
+            tuple_func->arguments = std::make_shared<ASTExpressionList>();
+
+            for (const auto & order_by_elem : order_list->children)
+            {
+                auto elem_expr = order_by_elem->children[0];
+                tuple_func->arguments->children.push_back(std::move(elem_expr));
+            }
+            expr = std::move(tuple_func);
+        }
+    }
+    else if (!expression_p.parse(pos, expr, expected))
+    {
+        return false;
     }
 
     if (s_type.ignore(pos, expected))
@@ -59,7 +83,9 @@ bool ParserCreateIndexDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected
     index->part_of_create_index_query = true;
 
     if (granularity)
+    {
         index->granularity = granularity->as<ASTLiteral &>().value.safeGet<UInt64>();
+    }
     else
     {
         auto index_type = index->getType();
