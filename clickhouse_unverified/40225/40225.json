{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40225,
  "instance_id": "ClickHouse__ClickHouse-40225",
  "issue_numbers": [
    "13014"
  ],
  "base_commit": "9cc34fb6df98c29639d9b1ad85078d15d32d072f",
  "patch": "diff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex f158df30204d..ddb41a00f842 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -139,14 +139,12 @@ class ExpressionAnalyzer : protected ExpressionAnalyzerData, private boost::nonc\n     void makeWindowDescriptionFromAST(const Context & context, const WindowDescriptions & existing_descriptions, WindowDescription & desc, const IAST * ast);\n     void makeWindowDescriptions(ActionsDAGPtr actions);\n \n-    /**\n-      * Create Set from a subquery or a table expression in the query. The created set is suitable for using the index.\n+    /** Create Set from a subquery or a table expression in the query. The created set is suitable for using the index.\n       * The set will not be created if its size hits the limit.\n       */\n     void tryMakeSetForIndexFromSubquery(const ASTPtr & subquery_or_table_name, const SelectQueryOptions & query_options = {});\n \n-    /**\n-      * Checks if subquery is not a plain StorageSet.\n+    /** Checks if subquery is not a plain StorageSet.\n       * Because while making set we will read data from StorageSet which is not allowed.\n       * Returns valid SetPtr from StorageSet if the latter is used after IN or nullptr otherwise.\n       */\ndiff --git a/src/Storages/StorageJoin.h b/src/Storages/StorageJoin.h\nindex 2a28ff6d01b6..390af09422c2 100644\n--- a/src/Storages/StorageJoin.h\n+++ b/src/Storages/StorageJoin.h\n@@ -76,14 +76,10 @@ class StorageJoin final : public StorageSetOrJoinBase\n     Block getRightSampleBlock() const\n     {\n         auto metadata_snapshot = getInMemoryMetadataPtr();\n-        Block block = metadata_snapshot->getSampleBlock().sortColumns();\n+        Block block = metadata_snapshot->getSampleBlock();\n         if (use_nulls && isLeftOrFull(kind))\n-        {\n             for (auto & col : block)\n-            {\n                 JoinCommon::convertColumnToNullable(col);\n-            }\n-        }\n         return block;\n     }\n \ndiff --git a/src/Storages/StorageSet.cpp b/src/Storages/StorageSet.cpp\nindex 2f586a3c26cb..48f8adfece25 100644\n--- a/src/Storages/StorageSet.cpp\n+++ b/src/Storages/StorageSet.cpp\n@@ -81,12 +81,11 @@ SetOrJoinSink::SetOrJoinSink(\n \n void SetOrJoinSink::consume(Chunk chunk)\n {\n-    /// Sort columns in the block. This is necessary, since Set and Join count on the same column order in different blocks.\n-    Block sorted_block = getHeader().cloneWithColumns(chunk.detachColumns()).sortColumns();\n+    Block block = getHeader().cloneWithColumns(chunk.detachColumns());\n \n-    table.insertBlock(sorted_block, getContext());\n+    table.insertBlock(block, getContext());\n     if (persistent)\n-        backup_stream.write(sorted_block);\n+        backup_stream.write(block);\n }\n \n void SetOrJoinSink::onFinish()\n@@ -147,9 +146,7 @@ StorageSet::StorageSet(\n     : StorageSetOrJoinBase{disk_, relative_path_, table_id_, columns_, constraints_, comment, persistent_}\n     , set(std::make_shared<Set>(SizeLimits(), false, true))\n {\n-\n     Block header = getInMemoryMetadataPtr()->getSampleBlock();\n-    header = header.sortColumns();\n     set->setHeader(header.getColumnsWithTypeAndName());\n \n     restore();\n@@ -170,7 +167,6 @@ void StorageSet::truncate(const ASTPtr &, const StorageMetadataPtr & metadata_sn\n     disk->createDirectories(fs::path(path) / \"tmp/\");\n \n     Block header = metadata_snapshot->getSampleBlock();\n-    header = header.sortColumns();\n \n     increment = 0;\n     set = std::make_shared<Set>(SizeLimits(), false, true);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02386_set_columns_order.reference b/tests/queries/0_stateless/02386_set_columns_order.reference\nnew file mode 100644\nindex 000000000000..6312b4b05a9a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02386_set_columns_order.reference\n@@ -0,0 +1,2 @@\n+3\tMary\n+1\ndiff --git a/tests/queries/0_stateless/02386_set_columns_order.sql b/tests/queries/0_stateless/02386_set_columns_order.sql\nnew file mode 100644\nindex 000000000000..dab5ad305797\n--- /dev/null\n+++ b/tests/queries/0_stateless/02386_set_columns_order.sql\n@@ -0,0 +1,22 @@\n+DROP TABLE IF EXISTS userid_set;\n+DROP TABLE IF EXISTS userid_test;\n+DROP TABLE IF EXISTS userid_set2;\n+\n+CREATE TABLE userid_set(userid UInt64, name String) ENGINE = Set;\n+INSERT INTO userid_set VALUES (1, 'Mary'),(2, 'Jane'),(3, 'Mary'),(4, 'Jack');\n+\n+CREATE TABLE userid_test (userid UInt64, name String) ENGINE = MergeTree() PARTITION BY (intDiv(userid, 500)) ORDER BY (userid) SETTINGS index_granularity = 8192;\n+INSERT INTO userid_test VALUES (1, 'Jack'),(2, 'Mary'),(3, 'Mary'),(4, 'John'),(5, 'Mary');\n+\n+SELECT * FROM userid_test WHERE (userid, name) IN (userid_set);\n+\n+CREATE TABLE userid_set2(userid UInt64, name String, birthdate Date) ENGINE = Set;\n+INSERT INTO userid_set2 values (1,'John', '1990-01-01');\n+\n+WITH  'John' AS name,  toDate('1990-01-01') AS birthdate\n+SELECT * FROM numbers(10)\n+WHERE (number, name, birthdate) IN (userid_set2);\n+\n+DROP TABLE userid_set;\n+DROP TABLE userid_test;\n+DROP TABLE userid_set2;\n",
  "problem_statement": "Engine=Set with multiple columns enforces reversed column order\n2 columns sample\r\n\r\n```sql\r\nCREATE TABLE userid_set(userid UInt64, name String) ENGINE = Set;\r\nINSERT INTO userid_set VALUES (1, 'Mary'),(2, 'Jane'),(3, 'Mary'),(4, 'Jack');\r\n\r\nCREATE TABLE userid_test (userid UInt64, name String) ENGINE = MergeTree() PARTITION BY (intDiv(userid, 500)) ORDER BY (userid) SETTINGS index_granularity = 8192;\r\nINSERT INTO userid_test VALUES (1, 'Jack'),(2, 'Mary'),(3, 'Mary'),(4, 'John'),(5, 'Mary');\r\n\r\nSELECT * FROM userid_test WHERE (userid, name) IN (userid_set); -- fails\r\n\r\nSELECT * FROM userid_test WHERE (name, userid) IN (userid_set); -- works, but order of columns is reversed.\r\n\r\n```\r\n\r\n3 columns sample\r\n```sql\r\nCREATE TABLE userid_set2(userid UInt64, name String, birthdate Date) ENGINE = Set;\r\n insert into userid_set2 values (1,'John', '1990-01-01');\r\n\r\nWITH  'John' AS name,  toDate('1990-01-01') AS birthdate\r\nSELECT * FROM numbers(10)\r\nWHERE (number, name, birthdate) IN (userid_set2); -- fails\r\n\r\nWITH  'John' AS name,  toDate('1990-01-01') AS birthdate\r\nSELECT * FROM numbers(10)\r\nWHERE (birthdate, name, number) IN (userid_set2); -- works, but order of column is reversed\r\n```\r\n\n",
  "hints_text": "Still relevant on 20.11.\n@abyss7 Still relevant in 21.3.\n@abyss7 You've promised to fix this issue \"soon\", but now almost one year has passed.\nStill relevant in master.",
  "created_at": "2022-08-15T04:56:53Z"
}