{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 72608,
  "instance_id": "ClickHouse__ClickHouse-72608",
  "issue_numbers": [
    "69276"
  ],
  "base_commit": "f00b0b02c9f2c925702e803480862aa9310e6ceb",
  "patch": "diff --git a/src/Analyzer/ArrayJoinNode.cpp b/src/Analyzer/ArrayJoinNode.cpp\nindex 0cfb5d80b2a3..b37f35fd84c9 100644\n--- a/src/Analyzer/ArrayJoinNode.cpp\n+++ b/src/Analyzer/ArrayJoinNode.cpp\n@@ -66,10 +66,7 @@ ASTPtr ArrayJoinNode::toASTImpl(const ConvertToASTOptions & options) const\n         auto * column_node = array_join_expression->as<ColumnNode>();\n         if (column_node && column_node->getExpression())\n         {\n-            if (const auto * function_node = column_node->getExpression()->as<FunctionNode>(); function_node && function_node->getFunctionName() == \"nested\")\n-                array_join_expression_ast = array_join_expression->toAST(options);\n-            else\n-                array_join_expression_ast = column_node->getExpression()->toAST(options);\n+            array_join_expression_ast = column_node->getExpression()->toAST(options);\n         }\n         else\n             array_join_expression_ast = array_join_expression->toAST(options);\ndiff --git a/src/Analyzer/Resolve/IdentifierResolveScope.h b/src/Analyzer/Resolve/IdentifierResolveScope.h\nindex 9a09c645189a..ec46ce4370e1 100644\n--- a/src/Analyzer/Resolve/IdentifierResolveScope.h\n+++ b/src/Analyzer/Resolve/IdentifierResolveScope.h\n@@ -165,6 +165,9 @@ struct IdentifierResolveScope\n     /// Table expression node to data\n     std::unordered_map<QueryTreeNodePtr, AnalysisTableExpressionData> table_expression_node_to_data;\n \n+    /// Table expression nodes that appear in the join tree of the corresponding query\n+    std::unordered_set<QueryTreeNodePtr> registered_table_expression_nodes;\n+\n     QueryTreeNodePtrWithHashIgnoreTypesSet nullable_group_by_keys;\n     /// Here we count the number of nullable GROUP BY keys we met resolving expression.\n     /// E.g. for a query `SELECT tuple(tuple(number)) FROM numbers(10) GROUP BY (number, tuple(number)) with cube`\ndiff --git a/src/Analyzer/Resolve/IdentifierResolver.cpp b/src/Analyzer/Resolve/IdentifierResolver.cpp\nindex 317a02a60f2d..60cff0d62c7b 100644\n--- a/src/Analyzer/Resolve/IdentifierResolver.cpp\n+++ b/src/Analyzer/Resolve/IdentifierResolver.cpp\n@@ -565,7 +565,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromExpressionArguments\n \n bool IdentifierResolver::tryBindIdentifierToAliases(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)\n {\n-    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr || scope.aliases.array_join_aliases.contains(identifier_lookup.identifier.front());\n+    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr;\n }\n \n /** Resolve identifier from table columns.\n@@ -680,6 +680,27 @@ bool IdentifierResolver::tryBindIdentifierToTableExpressions(const IdentifierLoo\n     return can_bind_identifier_to_table_expression;\n }\n \n+bool IdentifierResolver::tryBindIdentifierToArrayJoinExpressions(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)\n+{\n+    bool result = false;\n+\n+    for (const auto & table_expression : scope.registered_table_expression_nodes)\n+    {\n+        auto * array_join_node = table_expression->as<ArrayJoinNode>();\n+        if (!array_join_node)\n+            continue;\n+\n+        for (const auto & array_join_expression : array_join_node->getJoinExpressions())\n+        {\n+            auto array_join_expression_alias = array_join_expression->getAlias();\n+            if (identifier_lookup.identifier.front() == array_join_expression_alias)\n+                return true;\n+        }\n+    }\n+\n+    return result;\n+}\n+\n QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromStorage(\n     const Identifier & identifier,\n     const QueryTreeNodePtr & table_expression_node,\n@@ -1415,9 +1436,6 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const Ide\n \n         IdentifierView identifier_view(identifier_lookup.identifier);\n \n-        if (identifier_view.isCompound() && from_array_join_node.hasAlias() && identifier_view.front() == from_array_join_node.getAlias())\n-            identifier_view.popFirst();\n-\n         const auto & alias_or_name = array_join_column_expression_typed.hasAlias()\n             ? array_join_column_expression_typed.getAlias()\n             : array_join_column_expression_typed.getColumnName();\n@@ -1429,18 +1447,16 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const Ide\n         else\n             continue;\n \n+        auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),\n+            array_join_column_expression_typed.getColumnSource());\n         if (identifier_view.empty())\n-        {\n-            auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),\n-                array_join_column_expression_typed.getColumnSource());\n             return array_join_column;\n-        }\n \n         /// Resolve subcolumns. Example : SELECT x.y.z FROM tab ARRAY JOIN arr AS x\n         auto compound_expr = tryResolveIdentifierFromCompoundExpression(\n             identifier_lookup.identifier,\n             identifier_lookup.identifier.getPartsSize() - identifier_view.getPartsSize() /*identifier_bind_size*/,\n-            array_join_column_expression,\n+            array_join_column,\n             {} /* compound_expression_source */,\n             scope,\n             true /* can_be_not_found */);\ndiff --git a/src/Analyzer/Resolve/IdentifierResolver.h b/src/Analyzer/Resolve/IdentifierResolver.h\nindex cdbd7610b5ee..ea7b940427ae 100644\n--- a/src/Analyzer/Resolve/IdentifierResolver.h\n+++ b/src/Analyzer/Resolve/IdentifierResolver.h\n@@ -109,6 +109,9 @@ class IdentifierResolver\n         const QueryTreeNodePtr & table_expression_node,\n         const IdentifierResolveScope & scope);\n \n+    static bool tryBindIdentifierToArrayJoinExpressions(const IdentifierLookup & identifier_lookup,\n+        const IdentifierResolveScope & scope);\n+\n     QueryTreeNodePtr tryResolveIdentifierFromTableExpression(const IdentifierLookup & identifier_lookup,\n         const QueryTreeNodePtr & table_expression_node,\n         IdentifierResolveScope & scope);\ndiff --git a/src/Analyzer/Resolve/QueryAnalysisPass.cpp b/src/Analyzer/Resolve/QueryAnalysisPass.cpp\nindex 36c747555fcc..896154c63b03 100644\n--- a/src/Analyzer/Resolve/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalysisPass.cpp\n@@ -1,6 +1,6 @@\n #include <Analyzer/Passes/QueryAnalysisPass.h>\n #include <Analyzer/Resolve/QueryAnalyzer.h>\n-#include <Analyzer/createUniqueTableAliases.h>\n+#include <Analyzer/createUniqueAliasesIfNecessary.h>\n \n namespace DB\n {\n@@ -16,7 +16,7 @@ void QueryAnalysisPass::run(QueryTreeNodePtr & query_tree_node, ContextPtr conte\n {\n     QueryAnalyzer analyzer(only_analyze);\n     analyzer.resolve(query_tree_node, table_expression, context);\n-    createUniqueTableAliases(query_tree_node, table_expression, context);\n+    createUniqueAliasesIfNecessary(query_tree_node, context);\n }\n \n }\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex d118cb281ae7..6c4e2551c6c4 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -1593,7 +1593,7 @@ void QueryAnalyzer::qualifyColumnNodesWithProjectionNames(const QueryTreeNodes &\n             if (need_to_qualify)\n                 need_to_qualify = IdentifierResolver::tryBindIdentifierToTableExpressions(identifier_lookup, table_expression_node, scope);\n \n-            if (IdentifierResolver::tryBindIdentifierToAliases(identifier_lookup, scope))\n+            if (IdentifierResolver::tryBindIdentifierToAliases(identifier_lookup, scope) || IdentifierResolver::tryBindIdentifierToArrayJoinExpressions(identifier_lookup, scope))\n                 need_to_qualify = true;\n \n             if (need_to_qualify)\n@@ -4977,6 +4977,16 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n         throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n             \"ARRAY JOIN requires at least single expression\");\n \n+    /// Register expression aliases in the scope\n+    for (const auto & elem : array_join_nodes)\n+    {\n+        for (auto & child : elem->getChildren())\n+        {\n+            if (child)\n+                expressions_visitor.visit(child);\n+        }\n+    }\n+\n     std::vector<QueryTreeNodePtr> array_join_column_expressions;\n     array_join_column_expressions.reserve(array_join_nodes_size);\n \n@@ -4984,18 +4994,6 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n     {\n         auto array_join_expression_alias = array_join_expression->getAlias();\n \n-        for (const auto & elem : array_join_nodes)\n-        {\n-            if (elem->hasAlias())\n-                scope.aliases.array_join_aliases.insert(elem->getAlias());\n-\n-            for (auto & child : elem->getChildren())\n-            {\n-                if (child)\n-                    expressions_visitor.visit(child);\n-            }\n-        }\n-\n         std::string identifier_full_name;\n \n         if (auto * identifier_node = array_join_expression->as<IdentifierNode>())\n@@ -5368,6 +5366,7 @@ void QueryAnalyzer::resolveQueryJoinTreeNode(QueryTreeNodePtr & join_tree_node,\n     };\n \n     add_table_expression_alias_into_scope(join_tree_node);\n+    scope.registered_table_expression_nodes.insert(join_tree_node);\n     scope.table_expressions_in_resolve_process.erase(join_tree_node.get());\n }\n \ndiff --git a/src/Analyzer/Resolve/ScopeAliases.h b/src/Analyzer/Resolve/ScopeAliases.h\nindex 830ae72144b8..c67a94ef2348 100644\n--- a/src/Analyzer/Resolve/ScopeAliases.h\n+++ b/src/Analyzer/Resolve/ScopeAliases.h\n@@ -27,10 +27,6 @@ struct ScopeAliases\n     std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;\n     std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;\n \n-    /// Names which are aliases from ARRAY JOIN.\n-    /// This is needed to properly qualify columns from matchers and avoid name collision.\n-    std::unordered_set<std::string> array_join_aliases;\n-\n     std::unordered_map<std::string, QueryTreeNodePtr> & getAliasMap(IdentifierLookupContext lookup_context)\n     {\n         switch (lookup_context)\ndiff --git a/src/Analyzer/createUniqueTableAliases.cpp b/src/Analyzer/createUniqueAliasesIfNecessary.cpp\nsimilarity index 57%\nrename from src/Analyzer/createUniqueTableAliases.cpp\nrename to src/Analyzer/createUniqueAliasesIfNecessary.cpp\nindex 8f850fe8deca..fa2ccb09e438 100644\n--- a/src/Analyzer/createUniqueTableAliases.cpp\n+++ b/src/Analyzer/createUniqueAliasesIfNecessary.cpp\n@@ -1,6 +1,7 @@\n-#include <memory>\n-#include <unordered_map>\n-#include <Analyzer/createUniqueTableAliases.h>\n+#include <Analyzer/createUniqueAliasesIfNecessary.h>\n+\n+#include <Analyzer/ArrayJoinNode.h>\n+#include <Analyzer/ColumnNode.h>\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/IQueryTreeNode.h>\n@@ -48,8 +49,6 @@ class CreateUniqueTableAliasesVisitor : public InDepthQueryTreeVisitorWithContex\n             case QueryTreeNodeType::TABLE:\n                 [[fallthrough]];\n             case QueryTreeNodeType::TABLE_FUNCTION:\n-                [[fallthrough]];\n-            case QueryTreeNodeType::ARRAY_JOIN:\n             {\n                 auto & alias = table_expression_to_alias[node];\n                 if (alias.empty())\n@@ -60,6 +59,12 @@ class CreateUniqueTableAliasesVisitor : public InDepthQueryTreeVisitorWithContex\n                 }\n                 break;\n             }\n+            case QueryTreeNodeType::ARRAY_JOIN:\n+            {\n+                /// Simulate previous behaviour and preserve table naming with previous versions\n+                ++next_id;\n+                break;\n+            }\n             default:\n                 break;\n         }\n@@ -130,12 +135,97 @@ class CreateUniqueTableAliasesVisitor : public InDepthQueryTreeVisitorWithContex\n     std::unordered_map<QueryTreeNodePtr, String> table_expression_to_alias;\n };\n \n-}\n+class CreateUniqueArrayJoinAliasesVisitor : public InDepthQueryTreeVisitorWithContext<CreateUniqueArrayJoinAliasesVisitor>\n+{\n+public:\n+    using Base = InDepthQueryTreeVisitorWithContext<CreateUniqueArrayJoinAliasesVisitor>;\n+    using Base::Base;\n+\n+    void enterImpl(QueryTreeNodePtr & node)\n+    {\n+        if (auto * array_join_typed = node->as<ArrayJoinNode>())\n+        {\n+            populateRenamingMap(array_join_typed, renaming[array_join_typed]);\n+            return;\n+        }\n+\n+        auto * column_node = node->as<ColumnNode>();\n+        if (!column_node || replaced_nodes_set.contains(node))\n+            return;\n+\n+        auto column_source = column_node->getColumnSource();\n+        auto * array_join = column_source->as<ArrayJoinNode>();\n+        if (!array_join)\n+            return;\n+\n+        auto & renaming_map = getRenamingMap(array_join);\n+\n+        auto new_column = column_node->getColumn();\n+        new_column.name = renaming_map[column_node->getColumnName()];\n+        auto new_column_node = std::make_shared<ColumnNode>(new_column, column_source);\n+\n+        node = std::move(new_column_node);\n+        replaced_nodes_set.insert(node);\n+    }\n+\n+private:\n \n+    using RenamingMap = std::unordered_map<String, String>;\n \n-void createUniqueTableAliases(QueryTreeNodePtr & node, const QueryTreeNodePtr &  /*table_expression*/, const ContextPtr & context)\n+    void populateRenamingMap(ArrayJoinNode * array_join, RenamingMap & result)\n+    {\n+        if (result.empty())\n+        {\n+            for (auto & array_join_expression : array_join->getJoinExpressions())\n+            {\n+                auto * array_join_column = array_join_expression->as<ColumnNode>();\n+                chassert(array_join_column != nullptr);\n+\n+                String unique_expression_name = fmt::format(\"__array_join_exp_{}\", ++next_id);\n+                result.emplace(array_join_column->getColumnName(), unique_expression_name);\n+\n+                auto replacement_column = array_join_column->getColumn();\n+                replacement_column.name = unique_expression_name;\n+                auto replacement_column_node = std::make_shared<ColumnNode>(replacement_column, array_join_column->getExpression(), array_join_column->getColumnSource());\n+                replacement_column_node->setAlias(unique_expression_name);\n+\n+                array_join_expression = std::move(replacement_column_node);\n+                replaced_nodes_set.insert(array_join_expression);\n+            }\n+        }\n+    }\n+\n+    RenamingMap & getRenamingMap(ArrayJoinNode * array_join)\n+    {\n+        auto & result  = renaming[array_join];\n+\n+        populateRenamingMap(array_join, result);\n+\n+        return result;\n+    }\n+\n+    size_t next_id = 0;\n+\n+    std::unordered_map<ArrayJoinNode *, RenamingMap> renaming;\n+\n+    // TODO: Remove this field when identifier resolution cache removed from analyzer.\n+    std::unordered_set<QueryTreeNodePtr> replaced_nodes_set;\n+};\n+\n+}\n+\n+void createUniqueAliasesIfNecessary(QueryTreeNodePtr & node, const ContextPtr & context)\n {\n+    /*\n+     * For each table expression in the Query Tree generate and add a unique alias.\n+     * If table expression had an alias in initial query tree, override it.\n+     */\n     CreateUniqueTableAliasesVisitor(context).visit(node);\n+\n+    /* Generate unique aliases for array join expressions.\n+     * It's required to create a valid AST for distributed query.\n+     */\n+    CreateUniqueArrayJoinAliasesVisitor(context).visit(node);\n }\n \n }\ndiff --git a/src/Analyzer/createUniqueAliasesIfNecessary.h b/src/Analyzer/createUniqueAliasesIfNecessary.h\nnew file mode 100644\nindex 000000000000..078bcada3872\n--- /dev/null\n+++ b/src/Analyzer/createUniqueAliasesIfNecessary.h\n@@ -0,0 +1,14 @@\n+#pragma once\n+\n+#include <memory>\n+#include <Interpreters/Context_fwd.h>\n+\n+class IQueryTreeNode;\n+using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;\n+\n+namespace DB\n+{\n+\n+void createUniqueAliasesIfNecessary(QueryTreeNodePtr & node, const ContextPtr & context);\n+\n+}\ndiff --git a/src/Analyzer/createUniqueTableAliases.h b/src/Analyzer/createUniqueTableAliases.h\ndeleted file mode 100644\nindex d57a198498c7..000000000000\n--- a/src/Analyzer/createUniqueTableAliases.h\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-#pragma once\n-\n-#include <memory>\n-#include <Interpreters/Context_fwd.h>\n-\n-class IQueryTreeNode;\n-using QueryTreeNodePtr = std::shared_ptr<IQueryTreeNode>;\n-\n-namespace DB\n-{\n-\n-/*\n- * For each table expression in the Query Tree generate and add a unique alias.\n- * If table expression had an alias in initial query tree, override it.\n- */\n-void createUniqueTableAliases(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, const ContextPtr & context);\n-\n-}\ndiff --git a/src/Storages/buildQueryTreeForShard.cpp b/src/Storages/buildQueryTreeForShard.cpp\nindex bce30260954f..20ceae6a06a9 100644\n--- a/src/Storages/buildQueryTreeForShard.cpp\n+++ b/src/Storages/buildQueryTreeForShard.cpp\n@@ -2,7 +2,7 @@\n #include <Storages/buildQueryTreeForShard.h>\n \n #include <Analyzer/ColumnNode.h>\n-#include <Analyzer/createUniqueTableAliases.h>\n+#include <Analyzer/createUniqueAliasesIfNecessary.h>\n #include <Analyzer/FunctionNode.h>\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/IQueryTreeNode.h>\n@@ -427,7 +427,7 @@ QueryTreeNodePtr buildQueryTreeForShard(const PlannerContextPtr & planner_contex\n \n     removeGroupingFunctionSpecializations(query_tree_to_modify);\n \n-    createUniqueTableAliases(query_tree_to_modify, nullptr, planner_context->getQueryContext());\n+    createUniqueAliasesIfNecessary(query_tree_to_modify, planner_context->getQueryContext());\n \n     // Get rid of the settings clause so we don't send them to remote. Thus newly non-important\n     // settings won't break any remote parser. It's also more reasonable since the query settings\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01655_plan_optimizations.reference b/tests/queries/0_stateless/01655_plan_optimizations.reference\nindex fb27e0c3d74f..eb13997f0d1b 100644\n--- a/tests/queries/0_stateless/01655_plan_optimizations.reference\n+++ b/tests/queries/0_stateless/01655_plan_optimizations.reference\n@@ -121,8 +121,8 @@ Filter column: and(notEquals(y, 2), notEquals(x, 0))\n ARRAY JOIN x\n Filter column: notEquals(y, 2)\n > (analyzer) filter is split, one part is filtered before ARRAY JOIN\n-Filter column: and(notEquals(__table2.y, 2_UInt8), notEquals(__table1.x, 0_UInt8))\n-ARRAY JOIN __table1.x\n+Filter column: and(notEquals(__table2.y, 2_UInt8), notEquals(__array_join_exp_1, 0_UInt8))\n+ARRAY JOIN __array_join_exp_1\n Filter column: notEquals(__table2.y, 2_UInt8)\n 1\t3\n > filter is pushed down before Distinct\ndiff --git a/tests/queries/0_stateless/01655_plan_optimizations.sh b/tests/queries/0_stateless/01655_plan_optimizations.sh\nindex 52bfdb91467c..1a283a3027bc 100755\n--- a/tests/queries/0_stateless/01655_plan_optimizations.sh\n+++ b/tests/queries/0_stateless/01655_plan_optimizations.sh\n@@ -134,7 +134,7 @@ $CLICKHOUSE_CLIENT --enable_analyzer=1 -q \"\n     explain actions = 1 select x, y from (\n         select range(number) as x, number + 1 as y from numbers(3)\n     ) array join x where y != 2 and x != 0\" |\n-    grep -o \"Filter column: and(notEquals(__table2.y, 2_UInt8), notEquals(__table1.x, 0_UInt8))\\|ARRAY JOIN __table1.x\\|Filter column: notEquals(__table2.y, 2_UInt8)\"\n+    grep -o \"Filter column: and(notEquals(__table2.y, 2_UInt8), notEquals(__array_join_exp_1, 0_UInt8))\\|ARRAY JOIN __array_join_exp_1\\|Filter column: notEquals(__table2.y, 2_UInt8)\"\n $CLICKHOUSE_CLIENT -q \"\n     select x, y from (\n         select range(number) as x, number + 1 as y from numbers(3)\ndiff --git a/tests/queries/0_stateless/01823_explain_json.reference b/tests/queries/0_stateless/01823_explain_json.reference\nindex 6612fd232bf1..0a6100c85eb0 100644\n--- a/tests/queries/0_stateless/01823_explain_json.reference\n+++ b/tests/queries/0_stateless/01823_explain_json.reference\n@@ -81,7 +81,7 @@\n           \"Node Type\": \"ArrayJoin\",\n           \"Node Id\": \"ArrayJoin_4\",\n           \"Left\": false,\n-          \"Columns\": [\"__table1.x\", \"__table1.y\"],\n+          \"Columns\": [\"__array_join_exp_1\", \"__array_join_exp_2\"],\n --------\n           \"Node Type\": \"Distinct\",\n           \"Node Id\": \"Distinct_4\",\ndiff --git a/tests/queries/0_stateless/03277_analyzer_array_join_fix.reference b/tests/queries/0_stateless/03277_analyzer_array_join_fix.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03277_analyzer_array_join_fix.sql b/tests/queries/0_stateless/03277_analyzer_array_join_fix.sql\nnew file mode 100644\nindex 000000000000..9d6f05dd8266\n--- /dev/null\n+++ b/tests/queries/0_stateless/03277_analyzer_array_join_fix.sql\n@@ -0,0 +1,21 @@\n+CREATE TABLE IF NOT EXISTS repro\n+(\n+    `a` LowCardinality(String),\n+    `foos` Nested(x LowCardinality(String))\n+)\n+ENGINE = MergeTree\n+ORDER BY a;\n+\n+CREATE TABLE IF NOT EXISTS repro_dist\n+(\n+   \"a\" LowCardinality(String),\n+   \"foos\" Nested(\n+      \"x\" LowCardinality(String),\n+   )\n+) ENGINE = Distributed('test_cluster_two_shards', currentDatabase(), 'repro');\n+\n+SELECT\n+    a,\n+    foo.x\n+FROM repro_dist\n+ARRAY JOIN foos AS foo;\n",
  "problem_statement": "ARRAY JOIN alias recognition broken in production analyzer\nVersion: Latest LTS (24.8)\r\n\r\nSomething seems wrong with `ARRAY JOIN [arrayColName] AS [itemAlias]` when `allow_experimental_analyzer=1` which seems to be the default behavior in the latest LTS version (24.8)\r\n\r\n```\r\nCREATE DATABASE IF NOT EXISTS reprodb;\r\n\r\nUSE reprodb;\r\n\r\nCREATE TABLE IF NOT EXISTS repro\r\n(\r\n   \"a\" LowCardinality(String),\r\n   \"foos\" Nested(\r\n      \"x\" LowCardinality(String),\r\n   )\r\n) ENGINE = MergeTree ORDER BY a;\r\n\r\nCREATE TABLE IF NOT EXISTS repro_dist\r\n(\r\n   \"a\" LowCardinality(String),\r\n   \"foos\" Nested(\r\n      \"x\" LowCardinality(String),\r\n   )\r\n) ENGINE = Distributed('repro-cluster', 'reprodb', 'repro');\r\n```\r\n\r\nQuery with default (same result using explicit setting for allow_experimental_analyzer=1)\r\n```\r\nSELECT\r\n    a,\r\n    foo.x\r\nFROM repro_dist\r\nARRAY JOIN foos AS foo\r\n\r\nQuery id: e7d46628-68d7-450f-b24f-6fd5788f50e0\r\nElapsed: 0.010 sec.\r\nReceived exception from server (version 24.8.3):\r\n\r\nDB::Exception: Unknown expression identifier 'foo'. In scope SELECT __table2.a AS a, getSubcolumn(foo AS foo, 'x') AS `foo.x` FROM reprodb.repro AS __table2 ARRAY JOIN foo. Maybe you meant: ['foo']. (UNKNOWN_IDENTIFIER)\r\n```\r\n\r\nQuery with `allow_experimental_analyzer=0`\r\n```\r\nSELECT\r\n    a,\r\n    foo.x\r\nFROM repro_dist\r\nARRAY JOIN foos AS foo\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\nQuery id: 6a8c296b-6ac5-44b1-8842-5b7671627889\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.007 sec.\r\n```\r\n\r\nNote: this doesn't seem to happen for direct querying of `MergeTree`, just the distributed equivalent.\r\n```\r\nselect a, foo.x from repro array join foos as foo settings  allow_experimental_analyzer=1;\r\n\r\nSELECT\r\n    a,\r\n    foo.x\r\nFROM repro\r\nARRAY JOIN foos AS foo\r\nSETTINGS allow_experimental_analyzer = 1\r\n\r\nQuery id: 0e4b4fc4-843c-48d4-8096-b56ccf6fa949\r\n\r\nOk.\r\n```\r\n\r\nNote: this might be specific to nested?\r\n```\r\nCREATE TABLE IF NOT EXISTS repro_without_nest\r\n(\r\n   \"a\" LowCardinality(String),\r\n   \"foos\" Array(LowCardinality(String))\r\n) ENGINE = MergeTree ORDER BY a;\r\n\r\nCREATE TABLE IF NOT EXISTS repro_without_nest_dist\r\n(\r\n   \"a\" LowCardinality(String),\r\n   \"foos\" Array(LowCardinality(String))\r\n) ENGINE = Distributed('repro-cluster', 'reprodb', 'repro_without_nest');\r\n\r\nSELECT\r\n    a,\r\n    foo\r\nFROM repro_without_nest_dist\r\nARRAY JOIN foos AS foo\r\nSETTINGS allow_experimental_analyzer = 1\r\n\r\nQuery id: e6443d83-4395-4381-99d0-c67705b69112\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.007 sec.\r\n```\r\n\r\nThis looks a bit suspect:\r\n```\r\nUnknown expression identifier 'foo'. ... Maybe you meant: ['foo']. (UNKNOWN_IDENTIFIER)\r\n```\r\n\r\nThe fragment around getSubColumn looks like maybe the wrong arg is passed?\r\n```\r\n...In scope SELECT __table2.a AS a, getSubcolumn(foo AS foo, 'x') AS `foo.x` FROM...\r\n```\r\n\r\nMaybe this needs to be something like this (a sketch, probably wrong), but you get the idea:\r\n```\r\nSELECT __table2.a AS a, getSubcolumn(__table2.foos, 'x') AS 'foo.x' FROM...\r\n```\r\n\r\nEdit: yeah, here's what I assume is the internal representation of the query that is generated from the raw input, which results in the error about the identifier\r\n```\r\nSELECT\r\n    __table2.a AS a,\r\n    getSubcolumn(foo AS foo, 'x') AS `foo.x`\r\nFROM reprodb.repro AS __table2\r\nARRAY JOIN foos\r\n\r\n...DB::Exception: Unknown expression or function identifier 'foo'...\r\n```\r\n\r\nAnd here's my manual \"correction\" that seems to work\r\n```\r\nSELECT\r\n    __table2.a AS a,\r\n    getSubcolumn(__table2.foos, 'x') AS `foo.x`\r\nFROM reprodb.repro AS __table2\r\nARRAY JOIN foos\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n```\n",
  "hints_text": "I see that my examples weren't actually needed, since the docs for `ARRAY JOIN` include test tables and repro what I'm experiencing:\r\n\r\nhttps://clickhouse.com/docs/en/sql-reference/statements/select/array-join\r\n\r\n```\r\nCREATE TABLE nested_test\r\n(\r\n    s String,\r\n    nest Nested(\r\n    x UInt8,\r\n    y UInt32)\r\n) ENGINE = Memory;\r\n\r\nINSERT INTO nested_test\r\nVALUES ('Hello', [1,2], [10,20]), ('World', [3,4,5], [30,40,50]), ('Goodbye', [], []);\r\n```\r\n\r\n> An alias may be used for a nested data structure, in order to select either the JOIN result or the source array. Example:\r\n\r\n```\r\nSELECT s, `n.x`, `n.y`, `nest.x`, `nest.y`\r\nFROM nested_test\r\nARRAY JOIN nest AS n;\r\n\r\nSELECT\r\n    s,\r\n    `n.x`,\r\n    `n.y`,\r\n    `nest.x`,\r\n    `nest.y`\r\nFROM nested_test\r\nARRAY JOIN nest AS n\r\n\r\nQuery id: 12b59e67-82c2-4a52-8dc0-66077d685792\r\n\r\n\r\nElapsed: 0.003 sec.\r\n\r\nReceived exception from server (version 24.8.3):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown expression identifier 'n.x' in scope SELECT s, `n.x`, `n.y`, `nest.x`, `nest.y` FROM nested_test ARRAY JOIN nest AS n. (UNKNOWN_IDENTIFIER)\r\n```\nThanks for reading!\n`getSubcolumn(foo AS foo, 'x')` looks suspicious in the query that is sent to the follower node:\r\n```sql\r\nSELECT __table2.a AS a, getSubcolumn(foo AS foo, 'x') AS `foo.x` FROM reprodb.repro AS __table2 ARRAY JOIN foo\r\n```\r\nI'd expect to see something like `getSubcolumn(__table2.foo AS foo, 'x')`\nAny chance this code is relevant? And if so, does the problem jump out to anyone familiar? I'm just digging around in sources for usage of `getSubcolumn` that seems close to logic related to `Nested` (and notably, within analyzer sources)\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/DataTypes/NestedUtils.cpp#L208\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/DataTypes/NestedUtils.cpp#L164\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Analyzer/Resolve/IdentifierResolver.cpp#L720\r\n",
  "created_at": "2024-11-28T18:10:50Z",
  "modified_files": [
    "src/Analyzer/ArrayJoinNode.cpp",
    "src/Analyzer/Resolve/IdentifierResolveScope.h",
    "src/Analyzer/Resolve/IdentifierResolver.cpp",
    "src/Analyzer/Resolve/IdentifierResolver.h",
    "src/Analyzer/Resolve/QueryAnalysisPass.cpp",
    "src/Analyzer/Resolve/QueryAnalyzer.cpp",
    "src/Analyzer/Resolve/ScopeAliases.h",
    "src/Analyzer/createUniqueTableAliases.cpp",
    "b/src/Analyzer/createUniqueAliasesIfNecessary.h",
    "src/Analyzer/createUniqueTableAliases.h",
    "src/Storages/buildQueryTreeForShard.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01655_plan_optimizations.reference",
    "tests/queries/0_stateless/01655_plan_optimizations.sh",
    "tests/queries/0_stateless/01823_explain_json.reference",
    "b/tests/queries/0_stateless/03277_analyzer_array_join_fix.sql"
  ]
}