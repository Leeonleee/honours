{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 73950,
  "instance_id": "ClickHouse__ClickHouse-73950",
  "issue_numbers": [
    "62485"
  ],
  "base_commit": "1b271c0c74d6a3bab6d93716cc5101c492921bcc",
  "patch": "diff --git a/src/Core/ServerSettings.cpp b/src/Core/ServerSettings.cpp\nindex 3bf001a136cc..147378cc791b 100644\n--- a/src/Core/ServerSettings.cpp\n+++ b/src/Core/ServerSettings.cpp\n@@ -867,6 +867,9 @@ namespace DB\n     **See Also**\n     - [Workload Scheduling](/docs/en/operations/workload-scheduling.md)\n     )\", 0) \\\n+    DECLARE(String, series_keeper_path, \"/clickhouse/series\", R\"(\n+    Path in Keeper with auto-incremental numbers, generated by the `generateSerialID` function. Each series will be a node under this path.\n+    )\", 0) \\\n     DECLARE(Bool, prepare_system_log_tables_on_startup, false, R\"(\n     If true, ClickHouse creates all configured `system.*_log` tables before the startup. It can be helpful if some startup scripts depend on these tables.\n     )\", 0) \\\ndiff --git a/src/Core/Settings.cpp b/src/Core/Settings.cpp\nindex cf42871d3c0a..6b3f19a95a4a 100644\n--- a/src/Core/Settings.cpp\n+++ b/src/Core/Settings.cpp\n@@ -5864,6 +5864,11 @@ Allows creation of [JSON](../../sql-reference/data-types/newjson.md) data type.\n Allows a more general join planning algorithm that can handle more complex conditions, but only works with hash join. If hash join is not enabled, then the usual join planning algorithm is used regardless of the value of this setting.\n )\", 0) \\\n     \\\n+    DECLARE(UInt64, max_autoincrement_series, 1000, R\"(\n+The limit on the number of series created by the `generateSeriesID` function.\n+\n+As each series represents a node in Keeper, it is recommended to have no more than a couple of millions of them.\n+)\", 0) \\\n     \\\n     /* ####################################################### */ \\\n     /* ########### START OF EXPERIMENTAL FEATURES ############ */ \\\ndiff --git a/src/Core/SettingsChangesHistory.cpp b/src/Core/SettingsChangesHistory.cpp\nindex 18e268526f09..4c199b24178b 100644\n--- a/src/Core/SettingsChangesHistory.cpp\n+++ b/src/Core/SettingsChangesHistory.cpp\n@@ -83,6 +83,7 @@ const VersionToSettingsChangesMap & getSettingsChangesHistory()\n             {\"allow_experimental_bfloat16_type\", false, true, \"Add new BFloat16 type\"},\n             {\"output_format_pretty_max_column_name_width_cut_to\", 0, 24, \"A new setting\"},\n             {\"output_format_pretty_max_column_name_width_min_chars_to_cut\", 0, 4, \"A new setting\"},\n+            {\"max_autoincrement_series\", 1000, 1000, \"A new setting\"},\n         });\n         addSettingsChanges(settings_changes_history, \"24.12\",\n         {\ndiff --git a/src/Functions/generateSerialID.cpp b/src/Functions/generateSerialID.cpp\nnew file mode 100644\nindex 000000000000..99f1d8b6c03b\n--- /dev/null\n+++ b/src/Functions/generateSerialID.cpp\n@@ -0,0 +1,201 @@\n+#include <Common/ZooKeeper/ZooKeeper.h>\n+#include <Common/ZooKeeper/KeeperException.h>\n+#include <Common/escapeForFileName.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnString.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Interpreters/Context.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n+#include <Core/ServerSettings.h>\n+#include <Core/Settings.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LIMIT_EXCEEDED;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+namespace ServerSetting\n+{\n+    extern const ServerSettingsString series_keeper_path;\n+}\n+\n+namespace Setting\n+{\n+    extern const SettingsUInt64 max_autoincrement_series;\n+}\n+\n+\n+namespace\n+{\n+\n+class FunctionSerial : public IFunction\n+{\n+private:\n+    ContextPtr context;\n+    String keeper_path;\n+    size_t max_series = 0;\n+    bool at_capacity = false;\n+\n+public:\n+    static constexpr auto name = \"generateSerialID\";\n+\n+    explicit FunctionSerial(ContextPtr context_) : context(context_)\n+    {\n+        keeper_path = context->getServerSettings()[ServerSetting::series_keeper_path];\n+        zkutil::ZooKeeperPtr keeper = context->getZooKeeper();\n+        max_series = context->getSettingsRef()[Setting::max_autoincrement_series];\n+\n+        Coordination::Stat stat;\n+        if (keeper->exists(keeper_path, &stat))\n+        {\n+            if (static_cast<size_t>(stat.numChildren) > max_series)\n+                throw Exception(ErrorCodes::LIMIT_EXCEEDED,\n+                    \"Too many series created by {} function, maximum: {}. This is controlled by the `max_autoincrement_series` setting.\",\n+                    name, max_series);\n+\n+            if (static_cast<size_t>(stat.numChildren) == max_series)\n+                at_capacity = true;\n+        }\n+        else\n+        {\n+            keeper->createAncestors(keeper_path);\n+            keeper->create(keeper_path, \"\", zkutil::CreateMode::Persistent);\n+        }\n+    }\n+\n+    static FunctionPtr create(ContextPtr context)\n+    {\n+        return std::make_shared<FunctionSerial>(std::move(context));\n+    }\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool isStateful() const override { return true; }\n+    bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return false; }\n+    bool isSuitableForConstantFolding() const override { return false; }\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForNothing() const override { return false; }\n+    bool canBeExecutedOnDefaultArguments() const override { return false; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo &) const override { return false; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"series name\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"}\n+        };\n+        validateFunctionArguments(*this, arguments, mandatory_args);\n+\n+        return std::make_shared<DataTypeUInt64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        if (!checkColumnConst<ColumnString>(arguments[0].column.get()))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Argument of function {} must be constant string\", getName());\n+\n+        String series_name = assert_cast<const ColumnConst &>(*arguments[0].column).getValue<String>();\n+\n+        if (series_name.empty())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Series name cannot be empty\");\n+        series_name = escapeForFileName(series_name);\n+        if (series_name.size() > 100) /// Arbitrary safety threshold\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Series name '{}' is too long\", series_name);\n+\n+        auto col_res = ColumnUInt64::create();\n+        typename ColumnUInt64::Container & vec_to = col_res->getData();\n+\n+        vec_to.resize(input_rows_count);\n+\n+        String serial_path = std::filesystem::path(keeper_path) / series_name;\n+\n+        zkutil::ZooKeeperPtr keeper = context->getZooKeeper();\n+        if (at_capacity)\n+        {\n+            if (!keeper->exists(serial_path))\n+                throw Exception(ErrorCodes::LIMIT_EXCEEDED,\n+                    \"Too many series created by {} function, maximum: {}. This is controlled by the `max_autoincrement_series` setting.\",\n+                    name, max_series);\n+        }\n+        else\n+            keeper->createIfNotExists(serial_path, \"0\");\n+\n+        UInt64 counter = 0;\n+        Coordination::Stat stat;\n+        while (true)\n+        {\n+            String old_value = keeper->get(serial_path, &stat);\n+            counter = parse<UInt64>(old_value);\n+            String new_value = toString(counter + input_rows_count);\n+            auto code = keeper->trySet(serial_path, new_value, stat.version);\n+\n+            if (code == Coordination::Error::ZOK)\n+                break;\n+\n+            if (code == Coordination::Error::ZBADVERSION)\n+                continue;\n+\n+            throw zkutil::KeeperException::fromPath(code, serial_path);\n+        }\n+\n+        for (auto & val : vec_to)\n+        {\n+            val = counter;\n+            ++counter;\n+        }\n+\n+        return col_res;\n+    }\n+};\n+\n+}\n+\n+REGISTER_FUNCTION(Serial)\n+{\n+    factory.registerFunction<FunctionSerial>(FunctionDocumentation\n+    {\n+        .description=R\"(\n+Generates and returns sequential numbers starting from the previous counter value.\n+This function takes a constant string argument - a series identifier.\n+\n+The server should be configured with Keeper.\n+The series are stored in Keeper nodes under the path, which can be configured in `series_keeper_path` in the server configuration.\n+By default, it is `/clickhouse/series/`.\n+)\",\n+        .syntax = \"generateSerialID('identifier')\",\n+        .arguments{\n+            {\"series identifier\", \"Series identifier (a short constant String)\"}\n+        },\n+        .returned_value = \"Sequential numbers starting from the previous counter value\",\n+        .examples{\n+            {\"first call\", \"SELECT generateSerialID('id1')\", R\"(\n+\u250c\u2500generateSerialID('id1')\u2500\u2500\u2510\n+\u2502                        1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"},\n+            {\"second call\", \"SELECT generateSerialID('id1')\", R\"(\n+\u250c\u2500generateSerialID('id1')\u2500\u2500\u2510\n+\u2502                        2 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518)\"},\n+            {\"column call\", \"SELECT *, generateSerialID('id1') FROM test_table\", R\"(\n+\u250c\u2500CounterID\u2500\u252c\u2500UserID\u2500\u252c\u2500ver\u2500\u252c\u2500generateSerialID('id1')\u2500\u2500\u2510\n+\u2502         1 \u2502      3 \u2502   3 \u2502                        3 \u2502\n+\u2502         1 \u2502      1 \u2502   1 \u2502                        4 \u2502\n+\u2502         1 \u2502      2 \u2502   2 \u2502                        5 \u2502\n+\u2502         1 \u2502      5 \u2502   5 \u2502                        6 \u2502\n+\u2502         1 \u2502      4 \u2502   4 \u2502                        7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+                  )\"}},\n+        .categories{\"Unique identifiers\"}\n+    });\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03129_serial_test_zookeeper.reference b/tests/queries/0_stateless/03129_serial_test_zookeeper.reference\nnew file mode 100644\nindex 000000000000..76b931c1ac85\n--- /dev/null\n+++ b/tests/queries/0_stateless/03129_serial_test_zookeeper.reference\n@@ -0,0 +1,13 @@\n+0\n+1\n+0\n+2\n+3\n+4\n+5\n+6\n+0\t0\n+1\t1\n+2\t2\n+3\t3\n+4\t4\ndiff --git a/tests/queries/0_stateless/03129_serial_test_zookeeper.sql b/tests/queries/0_stateless/03129_serial_test_zookeeper.sql\nnew file mode 100644\nindex 000000000000..05bda3686e2f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03129_serial_test_zookeeper.sql\n@@ -0,0 +1,16 @@\n+-- Tags: zookeeper\n+\n+SELECT generateSerialID(currentDatabase() || 'x');\n+SELECT generateSerialID(currentDatabase() || 'x');\n+SELECT generateSerialID(currentDatabase() || 'y');\n+SELECT generateSerialID(currentDatabase() || 'x') FROM numbers(5);\n+\n+SELECT generateSerialID(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT generateSerialID('x', 'y'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT generateSerialID(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+-- Here the functions are identical and fall into common-subexpression-elimination:\n+SELECT generateSerialID(currentDatabase() || 'z'), generateSerialID(currentDatabase() || 'z') FROM numbers(5);\n+\n+SET max_autoincrement_series = 3;\n+SELECT generateSerialID('a'); -- { serverError LIMIT_EXCEEDED }\n",
  "problem_statement": "A new function, `serial`\nA new function, `serial`, which takes a constant string argument - a series identifier.\r\nOn every block, it goes to Keeper and atomically increments the counter with the corresponding name by the block size, then it generates and returns sequential numbers starting from the previous counter value.\r\n\r\nThe server can be configured with a keeper path - a prefix for these counter nodes, and with a limit on the total number of distinct counters (e.g., 100,000).\r\n\r\nThe usage of `serial` function will be controlled by a separate access right.\r\n\r\nThere should be a shortcut syntax for a table definition: if you specify `AUTO_INCREMENT`, it is equivalent to `DEFAULT serial('table_uuid')` or `serial('table_path_in_keeper')`. We can also support `SERIAL` for compatibility with Postgres.\r\n\r\nAs a result, it will provide a monotonic but not necessarily continuous counter. The discontinuity will appear for rejected or deduplicated INSERTs.\r\n\r\nAlternatively, Replicated tables can store the counter inside their path in Keeper, and interpret `AUTO_INCREMENT` directly.\r\n\r\nCaveats: special support is needed for BACKUP and RESTORE.\r\n\r\n_Originally posted by @alexey-milovidov in https://github.com/ClickHouse/ClickHouse/issues/56228#issuecomment-1789933636_\r\n            \n",
  "hints_text": "to get updates cc @tchaton\nAny ETA for this one ?\nHaving a `serial` is one thing, having proper SQL SEQUENCE would be even better.  These are part of SQL92 anyway if I'm not mistaken.",
  "created_at": "2024-12-29T11:28:15Z"
}