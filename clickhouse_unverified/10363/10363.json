{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10363,
  "instance_id": "ClickHouse__ClickHouse-10363",
  "issue_numbers": [
    "9272"
  ],
  "base_commit": "fd738f9a61bdc7673fe21ca5c7b3e48009338143",
  "patch": "diff --git a/src/Common/memcmpSmall.h b/src/Common/memcmpSmall.h\nindex 5dc5e04a7071..bafc08a9cbee 100644\n--- a/src/Common/memcmpSmall.h\n+++ b/src/Common/memcmpSmall.h\n@@ -64,6 +64,80 @@ inline int memcmpSmallAllowOverflow15(const Char * a, size_t a_size, const Char\n }\n \n \n+/** Variant when memory regions may have different sizes.\n+  * But compare the regions as the smaller one is padded with zero bytes up to the size of the larger.\n+  * It's needed to hold that: toFixedString('abc', 5) = 'abc'\n+  *  for compatibility with SQL standard.\n+  */\n+template <typename Char>\n+inline int memcmpSmallLikeZeroPaddedAllowOverflow15(const Char * a, size_t a_size, const Char * b, size_t b_size)\n+{\n+    size_t min_size = std::min(a_size, b_size);\n+\n+    for (size_t offset = 0; offset < min_size; offset += 16)\n+    {\n+        uint16_t mask = _mm_movemask_epi8(_mm_cmpeq_epi8(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i *>(a + offset)),\n+            _mm_loadu_si128(reinterpret_cast<const __m128i *>(b + offset))));\n+        mask = ~mask;\n+\n+        if (mask)\n+        {\n+            offset += __builtin_ctz(mask);\n+\n+            if (offset >= min_size)\n+                break;\n+\n+            return detail::cmp(a[offset], b[offset]);\n+        }\n+    }\n+\n+    /// The strings are equal up to min_size.\n+    /// If the rest of the larger string is zero bytes then the strings are considered equal.\n+\n+    size_t max_size;\n+    const Char * longest;\n+    int cmp;\n+\n+    if (a_size == b_size)\n+    {\n+        return 0;\n+    }\n+    else if (a_size > b_size)\n+    {\n+        max_size = a_size;\n+        longest = a;\n+        cmp = 1;\n+    }\n+    else\n+    {\n+        max_size = b_size;\n+        longest = b;\n+        cmp = -1;\n+    }\n+\n+    const __m128i zero16 = _mm_setzero_si128();\n+\n+    for (size_t offset = min_size; offset < max_size; offset += 16)\n+    {\n+        uint16_t mask = _mm_movemask_epi8(_mm_cmpgt_epi8(\n+            _mm_loadu_si128(reinterpret_cast<const __m128i *>(longest + offset)),\n+            zero16));\n+\n+        if (mask)\n+        {\n+            offset += __builtin_ctz(mask);\n+\n+            if (offset >= max_size)\n+                return 0;\n+            return cmp;\n+        }\n+    }\n+\n+    return 0;\n+}\n+\n+\n /** Variant when memory regions have same size.\n   * TODO Check if the compiler can optimize previous function when the caller pass identical sizes.\n   */\n@@ -206,6 +280,46 @@ inline int memcmpSmallAllowOverflow15(const Char * a, size_t a_size, const Char\n         return detail::cmp(a_size, b_size);\n }\n \n+template <typename Char>\n+inline int memcmpSmallLikeZeroPaddedAllowOverflow15(const Char * a, size_t a_size, const Char * b, size_t b_size)\n+{\n+    size_t min_size;\n+    size_t max_size;\n+    const Char * longest;\n+    int size_cmp;\n+\n+    if (a_size == b_size)\n+    {\n+        min_size = a_size;\n+        max_size = a_size;\n+        longest = a;\n+        size_cmp = 0;\n+    }\n+    else if (a_size > b_size)\n+    {\n+        min_size = b_size;\n+        max_size = a_size;\n+        longest = a;\n+        size_cmp = 1;\n+    }\n+    else\n+    {\n+        min_size = a_size;\n+        max_size = b_size;\n+        longest = b;\n+        size_cmp = -1;\n+    }\n+\n+    if (auto res = memcmp(a, b, min_size))\n+        return res;\n+\n+    for (size_t i = min_size; i < max_size; ++i)\n+        if (longest[i] != 0)\n+            return size_cmp;\n+\n+    return 0;\n+}\n+\n template <typename Char>\n inline int memcmpSmallAllowOverflow15(const Char * a, const Char * b, size_t size)\n {\n@@ -248,3 +362,13 @@ inline bool memoryIsZeroSmallAllowOverflow15(const void * data, size_t size)\n }\n \n #endif\n+\n+\n+/** Compare memory regions for equality.\n+  * But if the sizes are different, compare the regions as the smaller one is padded with zero bytes up to the size of the larger.\n+  */\n+template <typename Char>\n+inline bool memequalSmallLikeZeroPaddedAllowOverflow15(const Char * a, size_t a_size, const Char * b, size_t b_size)\n+{\n+    return 0 == memcmpSmallLikeZeroPaddedAllowOverflow15(a, a_size, b, b_size);\n+}\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 97a996bbe7e7..5671a8674e82 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -160,7 +160,7 @@ struct StringComparisonImpl\n \n         for (size_t i = 0; i < size; ++i)\n         {\n-            c[i] = Op::apply(memcmpSmallAllowOverflow15(\n+            c[i] = Op::apply(memcmpSmallLikeZeroPaddedAllowOverflow15(\n                 a_data.data() + prev_a_offset, a_offsets[i] - prev_a_offset - 1,\n                 b_data.data() + i * b_n, b_n), 0);\n \n@@ -168,7 +168,7 @@ struct StringComparisonImpl\n         }\n     }\n \n-    static void NO_INLINE string_vectorConstant(\n+    static void NO_INLINE string_vector_constant(\n         const ColumnString::Chars & a_data, const ColumnString::Offsets & a_offsets,\n         const ColumnString::Chars & b_data, ColumnString::Offset b_size,\n         PaddedPODArray<UInt8> & c)\n@@ -239,11 +239,11 @@ struct StringComparisonImpl\n             size_t size = a_data.size() / a_n;\n \n             for (size_t i = 0; i < size; ++i)\n-                c[i] = Op::apply(memcmpSmallAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data() + i * b_n, b_n), 0);\n+                c[i] = Op::apply(memcmpSmallLikeZeroPaddedAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data() + i * b_n, b_n), 0);\n         }\n     }\n \n-    static void NO_INLINE fixed_string_vectorConstant(\n+    static void NO_INLINE fixed_string_vector_constant(\n         const ColumnString::Chars & a_data, ColumnString::Offset a_n,\n         const ColumnString::Chars & b_data, ColumnString::Offset b_size,\n         PaddedPODArray<UInt8> & c)\n@@ -262,7 +262,7 @@ struct StringComparisonImpl\n         {\n             size_t size = a_data.size();\n             for (size_t i = 0, j = 0; i < size; i += a_n, ++j)\n-                c[j] = Op::apply(memcmpSmallAllowOverflow15(a_data.data() + i, a_n, b_data.data(), b_size), 0);\n+                c[j] = Op::apply(0, memcmpSmallLikeZeroPaddedAllowOverflow15(a_data.data() + i, a_n, b_data.data(), b_size));\n         }\n     }\n \n@@ -271,7 +271,7 @@ struct StringComparisonImpl\n         const ColumnString::Chars & b_data, const ColumnString::Offsets & b_offsets,\n         PaddedPODArray<UInt8> & c)\n     {\n-        StringComparisonImpl<typename Op::SymmetricOp>::string_vectorConstant(b_data, b_offsets, a_data, a_size, c);\n+        StringComparisonImpl<typename Op::SymmetricOp>::string_vector_constant(b_data, b_offsets, a_data, a_size, c);\n     }\n \n     static void constant_fixed_string_vector(\n@@ -279,15 +279,7 @@ struct StringComparisonImpl\n         const ColumnString::Chars & b_data, ColumnString::Offset b_n,\n         PaddedPODArray<UInt8> & c)\n     {\n-        StringComparisonImpl<typename Op::SymmetricOp>::fixed_string_vectorConstant(b_data, b_n, a_data, a_size, c);\n-    }\n-\n-    static void constantConstant(\n-        const ColumnString::Chars & a_data, ColumnString::Offset a_size,\n-        const ColumnString::Chars & b_data, ColumnString::Offset b_size,\n-        UInt8 & c)\n-    {\n-        c = Op::apply(memcmpSmallAllowOverflow15(a_data.data(), a_size, b_data.data(), b_size), 0);\n+        StringComparisonImpl<typename Op::SymmetricOp>::fixed_string_vector_constant(b_data, b_n, a_data, a_size, c);\n     }\n };\n \n@@ -331,7 +323,7 @@ struct StringEqualsImpl\n         {\n             auto a_size = a_offsets[i] - prev_a_offset - 1;\n \n-            c[i] = positive == memequalSmallAllowOverflow15(\n+            c[i] = positive == memequalSmallLikeZeroPaddedAllowOverflow15(\n                 a_data.data() + prev_a_offset, a_size,\n                 b_data.data() + b_n * i, b_n);\n \n@@ -339,7 +331,7 @@ struct StringEqualsImpl\n         }\n     }\n \n-    static void NO_INLINE string_vectorConstant(\n+    static void NO_INLINE string_vector_constant(\n         const ColumnString::Chars & a_data, const ColumnString::Offsets & a_offsets,\n         const ColumnString::Chars & b_data, ColumnString::Offset b_size,\n         PaddedPODArray<UInt8> & c)\n@@ -397,15 +389,21 @@ struct StringEqualsImpl\n         {\n             fixed_string_vector_fixed_string_vector_16(a_data, b_data, c);\n         }\n+        else if (a_n == b_n)\n+        {\n+            size_t size = a_data.size() / a_n;\n+            for (size_t i = 0; i < size; ++i)\n+                c[i] = positive == memequalSmallAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data() + i * a_n, a_n);\n+        }\n         else\n         {\n             size_t size = a_data.size() / a_n;\n             for (size_t i = 0; i < size; ++i)\n-                c[i] = positive == memequalSmallAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data() + i * b_n, b_n);\n+                c[i] = positive == memequalSmallLikeZeroPaddedAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data() + i * b_n, b_n);\n         }\n     }\n \n-    static void NO_INLINE fixed_string_vectorConstant(\n+    static void NO_INLINE fixed_string_vector_constant(\n         const ColumnString::Chars & a_data, ColumnString::Offset a_n,\n         const ColumnString::Chars & b_data, ColumnString::Offset b_size,\n         PaddedPODArray<UInt8> & c)\n@@ -418,7 +416,7 @@ struct StringEqualsImpl\n         {\n             size_t size = a_data.size() / a_n;\n             for (size_t i = 0; i < size; ++i)\n-                c[i] = positive == memequalSmallAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data(), b_size);\n+                c[i] = positive == memequalSmallLikeZeroPaddedAllowOverflow15(a_data.data() + i * a_n, a_n, b_data.data(), b_size);\n         }\n     }\n \n@@ -435,7 +433,7 @@ struct StringEqualsImpl\n         const ColumnString::Chars & b_data, const ColumnString::Offsets & b_offsets,\n         PaddedPODArray<UInt8> & c)\n     {\n-        string_vectorConstant(b_data, b_offsets, a_data, a_size, c);\n+        string_vector_constant(b_data, b_offsets, a_data, a_size, c);\n     }\n \n     static void constant_fixed_string_vector(\n@@ -443,15 +441,7 @@ struct StringEqualsImpl\n         const ColumnString::Chars & b_data, ColumnString::Offset b_n,\n         PaddedPODArray<UInt8> & c)\n     {\n-        fixed_string_vectorConstant(b_data, b_n, a_data, a_size, c);\n-    }\n-\n-    static void constantConstant(\n-        const ColumnString::Chars & a_data, ColumnString::Offset a_size,\n-        const ColumnString::Chars & b_data, ColumnString::Offset b_size,\n-        UInt8 & c)\n-    {\n-        c = positive == memequalSmallAllowOverflow15(a_data.data(), a_size, b_data.data(), b_size);\n+        fixed_string_vector_constant(b_data, b_n, a_data, a_size, c);\n     }\n };\n \n@@ -758,9 +748,11 @@ class FunctionComparison : public IFunction\n \n         if (c0_const && c1_const)\n         {\n-            UInt8 res = 0;\n-            StringImpl::constantConstant(*c0_const_chars, c0_const_size, *c1_const_chars, c1_const_size, res);\n-            block.getByPosition(result).column = block.getByPosition(result).type->createColumnConst(c0_const->size(), toField(res));\n+            auto res = executeString(block, result, &c0_const->getDataColumn(), &c1_const->getDataColumn());\n+            if (!res)\n+                return false;\n+\n+            block.getByPosition(result).column = ColumnConst::create(block.getByPosition(result).column, c0_const->size());\n             return true;\n         }\n         else\n@@ -780,7 +772,7 @@ class FunctionComparison : public IFunction\n                     c1_fixed_string->getChars(), c1_fixed_string->getN(),\n                     c_res->getData());\n             else if (c0_string && c1_const)\n-                StringImpl::string_vectorConstant(\n+                StringImpl::string_vector_constant(\n                     c0_string->getChars(), c0_string->getOffsets(),\n                     *c1_const_chars, c1_const_size,\n                     c_res->getData());\n@@ -795,7 +787,7 @@ class FunctionComparison : public IFunction\n                     c1_fixed_string->getChars(), c1_fixed_string->getN(),\n                     c_res->getData());\n             else if (c0_fixed_string && c1_const)\n-                StringImpl::fixed_string_vectorConstant(\n+                StringImpl::fixed_string_vector_constant(\n                     c0_fixed_string->getChars(), c0_fixed_string->getN(),\n                     *c1_const_chars, c1_const_size,\n                     c_res->getData());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01250_fixed_string_comparison.reference b/tests/queries/0_stateless/01250_fixed_string_comparison.reference\nnew file mode 100644\nindex 000000000000..197545734782\n--- /dev/null\n+++ b/tests/queries/0_stateless/01250_fixed_string_comparison.reference\n@@ -0,0 +1,110 @@\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+equals(b, b):    1\n+greater(b, b):   0\n+less(b, b):      0\n+equals(b, c):    0\n+greater(b, c):   0\n+less(b, c):      1\n+equals(b, d):    0\n+greater(b, d):   0\n+less(b, d):      1\n+equals(b, bf):   1\n+greater(b, bf):  0\n+less(b, bf):     0\n+equals(b, cf):   0\n+greater(b, cf):  0\n+less(b, cf):     1\n+equals(b, df):   0\n+greater(b, df):  0\n+less(b, df):     1\n+equals(c, b):    0\n+greater(c, b):   1\n+less(c, b):      0\n+equals(c, c):    1\n+greater(c, c):   0\n+less(c, c):      0\n+equals(c, d):    0\n+greater(c, d):   0\n+less(c, d):      1\n+equals(c, bf):   0\n+greater(c, bf):  1\n+less(c, bf):     0\n+equals(c, cf):   1\n+greater(c, cf):  0\n+less(c, cf):     0\n+equals(c, df):   0\n+greater(c, df):  0\n+less(c, df):     1\n+equals(d, b):    0\n+greater(d, b):   1\n+less(d, b):      0\n+equals(d, c):    0\n+greater(d, c):   1\n+less(d, c):      0\n+equals(d, d):    1\n+greater(d, d):   0\n+less(d, d):      0\n+equals(d, bf):   0\n+greater(d, bf):  1\n+less(d, bf):     0\n+equals(d, cf):   0\n+greater(d, cf):  1\n+less(d, cf):     0\n+equals(d, df):   1\n+greater(d, df):  0\n+less(d, df):     0\n+equals(bf, b):   1\n+greater(bf, b):  0\n+less(bf, b):     0\n+equals(bf, c):   0\n+greater(bf, c):  0\n+less(bf, c):     1\n+equals(bf, d):   0\n+greater(bf, d):  0\n+less(bf, d):     1\n+equals(bf, bf):  1\n+greater(bf, bf): 0\n+less(bf, bf):    0\n+equals(bf, cf):  0\n+greater(bf, cf): 0\n+less(bf, cf):    1\n+equals(bf, df):  0\n+greater(bf, df): 0\n+less(bf, df):    1\n+equals(cf, b):   0\n+greater(cf, b):  1\n+less(cf, b):     0\n+equals(cf, c):   1\n+greater(cf, c):  0\n+less(cf, c):     0\n+equals(cf, d):   0\n+greater(cf, d):  0\n+less(cf, d):     1\n+equals(cf, bf):  0\n+greater(cf, bf): 1\n+less(cf, bf):    0\n+equals(cf, cf):  1\n+greater(cf, cf): 0\n+less(cf, cf):    0\n+equals(cf, df):  0\n+greater(cf, df): 0\n+less(cf, df):    1\n+equals(df, b):   0\n+greater(df, b):  1\n+less(df, b):     0\n+equals(df, c):   0\n+greater(df, c):  1\n+less(df, c):     0\n+equals(df, d):   1\n+greater(df, d):  0\n+less(df, d):     0\n+equals(df, bf):  0\n+greater(df, bf): 1\n+less(df, bf):    0\n+equals(df, cf):  0\n+greater(df, cf): 1\n+less(df, cf):    0\n+equals(df, df):  1\n+greater(df, df): 0\n+less(df, df):    0\ndiff --git a/tests/queries/0_stateless/01250_fixed_string_comparison.sql b/tests/queries/0_stateless/01250_fixed_string_comparison.sql\nnew file mode 100644\nindex 000000000000..8481b3572bba\n--- /dev/null\n+++ b/tests/queries/0_stateless/01250_fixed_string_comparison.sql\n@@ -0,0 +1,45 @@\n+WITH 'abb' AS b, 'abc' AS c, 'abd' AS d, toFixedString(b, 5) AS bf, toFixedString(c, 5) AS cf, toFixedString(d, 5) AS df\n+SELECT \n+    b = b, b > b, b < b,\n+    b = c, b > c, b < c,\n+    b = d, b > d, b < d,\n+    b = bf, b > bf, b < bf,\n+    b = cf, b > cf, b < cf,\n+    b = df, b > df, b < df,\n+\n+    c = b, c > b, c < b,\n+    c = c, c > c, c < c,\n+    c = d, c > d, c < d,\n+    c = bf, c > bf, c < bf,\n+    c = cf, c > cf, c < cf,\n+    c = df, c > df, c < df,\n+\n+    d = b, d > b, d < b,\n+    d = c, d > c, d < c,\n+    d = d, d > d, d < d,\n+    d = bf, d > bf, d < bf,\n+    d = cf, d > cf, d < cf,\n+    d = df, d > df, d < df,\n+\n+    bf = b, bf > b, bf < b,\n+    bf = c, bf > c, bf < c,\n+    bf = d, bf > d, bf < d,\n+    bf = bf, bf > bf, bf < bf,\n+    bf = cf, bf > cf, bf < cf,\n+    bf = df, bf > df, bf < df,\n+\n+    cf = b, cf > b, cf < b,\n+    cf = c, cf > c, cf < c,\n+    cf = d, cf > d, cf < d,\n+    cf = bf, cf > bf, cf < bf,\n+    cf = cf, cf > cf, cf < cf,\n+    cf = df, cf > df, cf < df,\n+\n+    df = b, df > b, df < b,\n+    df = c, df > c, df < c,\n+    df = d, df > d, df < d,\n+    df = bf, df > bf, df < bf,\n+    df = cf, df > cf, df < cf,\n+    df = df, df > df, df < df\n+\n+FORMAT Vertical;\ndiff --git a/tests/queries/0_stateless/01251_string_comparison.reference b/tests/queries/0_stateless/01251_string_comparison.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01251_string_comparison.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/01251_string_comparison.sql b/tests/queries/0_stateless/01251_string_comparison.sql\nnew file mode 100644\nindex 000000000000..b2923ba43209\n--- /dev/null\n+++ b/tests/queries/0_stateless/01251_string_comparison.sql\n@@ -0,0 +1,1 @@\n+SELECT isConstant('a' = 'b');\n",
  "problem_statement": "equals() for FixedString and String returns false if string has smaller length than FixedString\n**Describe the bug or unexpected behaviour**\r\nequals() for FixedString and String returns false if string has smaller length than FixedString\r\n\r\n**How to reproduce**\r\n* 20.2.1.1\r\n\r\n```sql\r\n:) SELECT toFixedString('12345', 10) == '12345';\r\n\r\nSELECT toFixedString('12345', 10) = '12345'\r\n\r\n\u250c\u2500equals(toFixedString('12345', 10), '12345')\u2500\u2510\r\n\u2502                                           0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.002 sec.\r\n\r\n:) SELECT toFixedString('12345', 5) == '12345';\r\n\r\nSELECT toFixedString('12345', 5) = '12345'\r\n\r\n\u250c\u2500equals(toFixedString('12345', 5), '12345')\u2500\u2510\r\n\u2502                                          1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.002 sec.\r\n\r\n:) SELECT toString(toFixedString('12345', 10)) == '12345';\r\n\r\nSELECT toString(toFixedString('12345', 10)) = '12345'\r\n\r\n\u250c\u2500equals(toString(toFixedString('12345', 10)), '12345')\u2500\u2510\r\n\u2502                                                     1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n```\r\n**Expected behavior**\r\nSomething like we add padding to String to the length of FixedString and compare them.\r\nIt is closer to Standard than current behavior\r\n\r\nSQL92\r\n\r\n> 3) The comparison of two character strings is determined as follows:\r\n> \r\n> a) If the length in characters of X is not equal to the length in characters of Y, then the shorter string is effectively replaced, for the purposes of comparison, with a copy of itself that has been extended to the length of the longer string by concatenation on the right of one or more pad characters, where the pad character is chosen based on CS. [...] Otherwise, the pad character is a <space>.\r\n\n",
  "hints_text": "",
  "created_at": "2020-04-20T01:18:23Z"
}