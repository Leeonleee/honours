{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11454,
  "instance_id": "ClickHouse__ClickHouse-11454",
  "issue_numbers": [
    "10530"
  ],
  "base_commit": "b66ad25841030870a27b0120b2d4da6bc283fb31",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 64a58e332318..23cb753e96fd 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -958,28 +958,16 @@ void InterpreterSelectQuery::executeFetchColumns(\n     const Settings & settings = context->getSettingsRef();\n \n     /// Optimization for trivial query like SELECT count() FROM table.\n-    auto check_trivial_count_query = [&]() -> std::optional<AggregateDescription>\n-    {\n-        if (!settings.optimize_trivial_count_query || !syntax_analyzer_result->maybe_optimize_trivial_count || !storage\n-            || query.sampleSize() || query.sampleOffset() || query.final() || query.prewhere() || query.where() || query.groupBy()\n-            || !query_analyzer->hasAggregation() || processing_stage != QueryProcessingStage::FetchColumns)\n-            return {};\n-\n-        const AggregateDescriptions & aggregates = query_analyzer->aggregates();\n-\n-        if (aggregates.size() != 1)\n-            return {};\n-\n-        const AggregateDescription & desc = aggregates[0];\n-        if (typeid_cast<AggregateFunctionCount *>(desc.function.get()))\n-            return desc;\n-\n-        return {};\n-    };\n+    bool optimize_trivial_count =\n+        syntax_analyzer_result->optimize_trivial_count && storage &&\n+        processing_stage == QueryProcessingStage::FetchColumns &&\n+        query_analyzer->hasAggregation() && (query_analyzer->aggregates().size() == 1) &&\n+        typeid_cast<AggregateFunctionCount *>(query_analyzer->aggregates()[0].function.get());\n \n-    if (auto desc = check_trivial_count_query())\n+    if (optimize_trivial_count)\n     {\n-        auto func = desc->function;\n+        const auto & desc = query_analyzer->aggregates()[0];\n+        const auto & func = desc.function;\n         std::optional<UInt64> num_rows = storage->totalRows();\n         if (num_rows)\n         {\n@@ -998,13 +986,13 @@ void InterpreterSelectQuery::executeFetchColumns(\n             column->insertFrom(place);\n \n             auto header = analysis_result.before_aggregation->getSampleBlock();\n-            size_t arguments_size = desc->argument_names.size();\n+            size_t arguments_size = desc.argument_names.size();\n             DataTypes argument_types(arguments_size);\n             for (size_t j = 0; j < arguments_size; ++j)\n-                argument_types[j] = header.getByName(desc->argument_names[j]).type;\n+                argument_types[j] = header.getByName(desc.argument_names[j]).type;\n \n             Block block_with_count{\n-                {std::move(column), std::make_shared<DataTypeAggregateFunction>(func, argument_types, desc->parameters), desc->column_name}};\n+                {std::move(column), std::make_shared<DataTypeAggregateFunction>(func, argument_types, desc.parameters), desc.column_name}};\n \n             auto istream = std::make_shared<OneBlockInputStream>(block_with_count);\n             pipeline.init(Pipe(std::make_shared<SourceFromInputStream>(istream)));\ndiff --git a/src/Interpreters/SyntaxAnalyzer.cpp b/src/Interpreters/SyntaxAnalyzer.cpp\nindex 831379090adf..5f1bf79e053f 100644\n--- a/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -598,7 +598,7 @@ void SyntaxAnalyzerResult::collectSourceColumns(bool add_special)\n /// Calculate which columns are required to execute the expression.\n /// Then, delete all other columns from the list of available columns.\n /// After execution, columns will only contain the list of columns needed to read from the table.\n-void SyntaxAnalyzerResult::collectUsedColumns(const ASTPtr & query)\n+void SyntaxAnalyzerResult::collectUsedColumns(const ASTPtr & query, bool is_select)\n {\n     /// We calculate required_source_columns with source_columns modifications and swap them on exit\n     required_source_columns = source_columns;\n@@ -648,12 +648,11 @@ void SyntaxAnalyzerResult::collectUsedColumns(const ASTPtr & query)\n                 required.insert(column_name_type.name);\n     }\n \n-    const auto * select_query = query->as<ASTSelectQuery>();\n-\n     /// You need to read at least one column to find the number of rows.\n-    if (select_query && required.empty())\n+    if (is_select && required.empty())\n     {\n-        maybe_optimize_trivial_count = true;\n+        optimize_trivial_count = true;\n+\n         /// We will find a column with minimum <compressed_size, type_size, uncompressed_size>.\n         /// Because it is the column that is cheapest to read.\n         struct ColumnSizeTuple\n@@ -662,12 +661,14 @@ void SyntaxAnalyzerResult::collectUsedColumns(const ASTPtr & query)\n             size_t type_size;\n             size_t uncompressed_size;\n             String name;\n+\n             bool operator<(const ColumnSizeTuple & that) const\n             {\n                 return std::tie(compressed_size, type_size, uncompressed_size)\n                     < std::tie(that.compressed_size, that.type_size, that.uncompressed_size);\n             }\n         };\n+\n         std::vector<ColumnSizeTuple> columns;\n         if (storage)\n         {\n@@ -681,6 +682,7 @@ void SyntaxAnalyzerResult::collectUsedColumns(const ASTPtr & query)\n                 columns.emplace_back(ColumnSizeTuple{c->second.data_compressed, type_size, c->second.data_uncompressed, source_column.name});\n             }\n         }\n+\n         if (!columns.empty())\n             required.insert(std::min_element(columns.begin(), columns.end())->name);\n         else\n@@ -760,6 +762,7 @@ void SyntaxAnalyzerResult::collectUsedColumns(const ASTPtr & query)\n     required_source_columns.swap(source_columns);\n }\n \n+\n SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyzeSelect(\n     ASTPtr & query,\n     SyntaxAnalyzerResult && result,\n@@ -848,7 +851,14 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyzeSelect(\n     }\n \n     result.aggregates = getAggregates(query, *select_query);\n-    result.collectUsedColumns(query);\n+    result.collectUsedColumns(query, true);\n+\n+    if (result.optimize_trivial_count)\n+        result.optimize_trivial_count = settings.optimize_trivial_count_query &&\n+            !select_query->where() && !select_query->prewhere() && !select_query->groupBy() && !select_query->having() &&\n+            !select_query->sampleSize() && !select_query->sampleOffset() && !select_query->final() &&\n+            (tables_with_column_names.size() < 2 || isLeft(result.analyzed_join->kind()));\n+\n     return std::make_shared<const SyntaxAnalyzerResult>(result);\n }\n \n@@ -882,7 +892,7 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(ASTPtr & query, const NamesAndTy\n     else\n         assertNoAggregates(query, \"in wrong place\");\n \n-    result.collectUsedColumns(query);\n+    result.collectUsedColumns(query, false);\n     return std::make_shared<const SyntaxAnalyzerResult>(result);\n }\n \ndiff --git a/src/Interpreters/SyntaxAnalyzer.h b/src/Interpreters/SyntaxAnalyzer.h\nindex abacb25ac4d8..175c2db295a3 100644\n--- a/src/Interpreters/SyntaxAnalyzer.h\n+++ b/src/Interpreters/SyntaxAnalyzer.h\n@@ -46,11 +46,11 @@ struct SyntaxAnalyzerResult\n     /// Predicate optimizer overrides the sub queries\n     bool rewrite_subqueries = false;\n \n+    bool optimize_trivial_count = false;\n+\n     /// Results of scalar sub queries\n     Scalars scalars;\n \n-    bool maybe_optimize_trivial_count = false;\n-\n     SyntaxAnalyzerResult(const NamesAndTypesList & source_columns_, ConstStoragePtr storage_ = {}, bool add_special = true)\n         : storage(storage_)\n         , source_columns(source_columns_)\n@@ -59,7 +59,7 @@ struct SyntaxAnalyzerResult\n     }\n \n     void collectSourceColumns(bool add_special);\n-    void collectUsedColumns(const ASTPtr & query);\n+    void collectUsedColumns(const ASTPtr & query, bool is_select);\n     Names requiredSourceColumns() const { return required_source_columns.getNames(); }\n     const Scalars & getScalars() const { return scalars; }\n };\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01143_trivial_count_with_join.reference b/tests/queries/0_stateless/01143_trivial_count_with_join.reference\nnew file mode 100644\nindex 000000000000..9c3f6a570ce6\n--- /dev/null\n+++ b/tests/queries/0_stateless/01143_trivial_count_with_join.reference\n@@ -0,0 +1,5 @@\n+4\n+4\n+4\n+4\n+4\ndiff --git a/tests/queries/0_stateless/01143_trivial_count_with_join.sql b/tests/queries/0_stateless/01143_trivial_count_with_join.sql\nnew file mode 100644\nindex 000000000000..d31750e37dc3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01143_trivial_count_with_join.sql\n@@ -0,0 +1,10 @@\n+drop table if exists t;\n+create table t engine Memory as select * from numbers(2);\n+\n+select count(*) from t, numbers(2) r;\n+select count(*) from t cross join numbers(2) r;\n+select count() from t cross join numbers(2) r;\n+select count(t.number) from t cross join numbers(2) r;\n+select count(r.number) from t cross join numbers(2) r;\n+\n+drop table t;\n",
  "problem_statement": "count(*) with cross join doesn't always work\n````\r\n*2* :) select count(*) from numbers(10) l, numbers(10) r;\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502     100 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n*2* :) create table l engine Memory as select * from numbers(10);\r\n\r\nOk.\r\n\r\n*2* :) select count(*) from l, numbers(10) r;\r\n\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502      10 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n*2* :) select * from l, numbers(10) r;\r\n\r\n\u250c\u2500number\u2500\u252c\u2500r.number\u2500\u2510\r\n\u2502      0 \u2502        0 \u2502\r\n...\r\n\u2502      9 \u2502        9 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n100 rows in set. Elapsed: 0.003 sec. \r\n```\r\n\n",
  "hints_text": "It looks like it use column from right table for `count(*)` as smallest one. But it's not correct for some reason.\r\n\r\n```\r\ncreate table t engine Memory as select * from numbers(2);\r\nselect count(number) from t cross join numbers(2) r;\r\nselect count(r.number) from t cross join numbers(2) r;\r\n```\r\n\r\n```\r\n4\r\n2\r\n```\r\nResult itself is OK. Only `count()` is affected.\r\n```\r\nselect r.number from t cross join numbers(2) r;\r\n```\r\n```\r\n0\r\n1\r\n0\r\n1\r\n```",
  "created_at": "2020-06-04T22:06:31Z"
}