diff --git a/dbms/src/Interpreters/DDLWorker.cpp b/dbms/src/Interpreters/DDLWorker.cpp
index e89476115a8a..f01bd8424e6d 100644
--- a/dbms/src/Interpreters/DDLWorker.cpp
+++ b/dbms/src/Interpreters/DDLWorker.cpp
@@ -1097,15 +1097,9 @@ class DDLQueryStatusInputSream : public IProfilingBlockInputStream
 
 BlockIO executeDDLQueryOnCluster(const ASTPtr & query_ptr_, const Context & context)
 {
+    /// Remove FORMAT <fmt> and INTO OUTFILE <file> if exists
     ASTPtr query_ptr = query_ptr_->clone();
-
-    /// Remove FORMAT ... INTO OUTFILE if exists
-    if (dynamic_cast<const ASTQueryWithOutput *>(query_ptr_.get()))
-    {
-        auto query_with_output = dynamic_cast<ASTQueryWithOutput *>(query_ptr.get());
-        query_with_output->out_file = nullptr;
-        query_with_output->format = nullptr;
-    }
+    ASTQueryWithOutput::resetOutputASTIfExist(*query_ptr);
 
     auto query = dynamic_cast<ASTQueryWithOnCluster *>(query_ptr.get());
     if (!query)
diff --git a/dbms/src/Interpreters/InterpreterCreateQuery.cpp b/dbms/src/Interpreters/InterpreterCreateQuery.cpp
index 8e803a39f7de..853d42c5ccfd 100644
--- a/dbms/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterCreateQuery.cpp
@@ -587,6 +587,7 @@ BlockIO InterpreterCreateQuery::execute()
 {
     ASTCreateQuery & create = typeid_cast<ASTCreateQuery &>(*query_ptr);
     checkAccess(create);
+    ASTQueryWithOutput::resetOutputASTIfExist(create);
 
     /// CREATE|ATTACH DATABASE
     if (!create.database.empty() && create.table.empty())
diff --git a/dbms/src/Parsers/ASTQueryWithOutput.cpp b/dbms/src/Parsers/ASTQueryWithOutput.cpp
index 7548ac0cc54c..62abe5de9e11 100644
--- a/dbms/src/Parsers/ASTQueryWithOutput.cpp
+++ b/dbms/src/Parsers/ASTQueryWithOutput.cpp
@@ -36,4 +36,17 @@ void ASTQueryWithOutput::formatImpl(const FormatSettings & s, FormatState & stat
     }
 }
 
+bool ASTQueryWithOutput::resetOutputASTIfExist(IAST & ast)
+{
+    if (auto ast_with_output = dynamic_cast<ASTQueryWithOutput *>(&ast))
+    {
+        ast_with_output->format.reset();
+        ast_with_output->out_file.reset();
+        return true;
+    }
+
+    return false;
+}
+
+
 }
diff --git a/dbms/src/Parsers/ASTQueryWithOutput.h b/dbms/src/Parsers/ASTQueryWithOutput.h
index 8f2482ddeb7b..40ac02380e5b 100644
--- a/dbms/src/Parsers/ASTQueryWithOutput.h
+++ b/dbms/src/Parsers/ASTQueryWithOutput.h
@@ -19,6 +19,9 @@ class ASTQueryWithOutput : public IAST
 
     void formatImpl(const FormatSettings & s, FormatState & state, FormatStateStacked frame) const final;
 
+    /// Remove 'FORMAT <fmt> and INTO OUTFILE <file>' if exists
+    static bool resetOutputASTIfExist(IAST & ast);
+
 protected:
     /// NOTE: call this helper at the end of the clone() method of descendant class.
     void cloneOutputOptions(ASTQueryWithOutput & cloned) const;
diff --git a/dbms/src/Storages/StorageMaterializedView.cpp b/dbms/src/Storages/StorageMaterializedView.cpp
index f1326a52933f..820ccdb969ea 100644
--- a/dbms/src/Storages/StorageMaterializedView.cpp
+++ b/dbms/src/Storages/StorageMaterializedView.cpp
@@ -190,6 +190,12 @@ StoragePtr StorageMaterializedView::getTargetTable() const
     return global_context.getTable(target_database_name, target_table_name);
 }
 
+bool StorageMaterializedView::checkTableCanBeDropped() const
+{
+    /// Don't drop the target table if it was created manually via 'TO inner_table' statement
+    return has_inner_table ? getTargetTable()->checkTableCanBeDropped() : true;
+}
+
 
 void registerStorageMaterializedView(StorageFactory & factory)
 {
diff --git a/dbms/src/Storages/StorageMaterializedView.h b/dbms/src/Storages/StorageMaterializedView.h
index b2a2069166aa..9b9b538b31f1 100644
--- a/dbms/src/Storages/StorageMaterializedView.h
+++ b/dbms/src/Storages/StorageMaterializedView.h
@@ -33,6 +33,7 @@ class StorageMaterializedView : public ext::shared_ptr_helper<StorageMaterialize
     void drop() override;
     bool optimize(const ASTPtr & query, const ASTPtr & partition, bool final, bool deduplicate, const Context & context) override;
     void shutdown() override;
+    bool checkTableCanBeDropped() const override;
 
     BlockInputStreams read(
         const Names & column_names,
diff --git a/dbms/src/TableFunctions/TableFunctionRemote.cpp b/dbms/src/TableFunctions/TableFunctionRemote.cpp
index 63c917b6832c..58537492e530 100644
--- a/dbms/src/TableFunctions/TableFunctionRemote.cpp
+++ b/dbms/src/TableFunctions/TableFunctionRemote.cpp
@@ -185,18 +185,18 @@ StoragePtr TableFunctionRemote::execute(const ASTPtr & ast_function, const Conte
 {
     ASTs & args_func = typeid_cast<ASTFunction &>(*ast_function).children;
 
-    const char * err = "Table function 'remote' requires from 2 to 5 parameters: "
-        "addresses pattern, name of remote database, name of remote table, [username, [password]].";
+    const size_t max_args = is_cluster_function ? 3 : 5;
 
     if (args_func.size() != 1)
-        throw Exception(err, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+        throw Exception(help_message, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
     ASTs & args = typeid_cast<ASTExpressionList &>(*args_func.at(0)).children;
 
-    if (args.size() < 2 || args.size() > 5)
-        throw Exception(err, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+    if (args.size() < 2 || args.size() > max_args)
+        throw Exception(help_message, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
-    String description;
+    String cluster_name;
+    String cluster_description;
     String remote_database;
     String remote_table;
     String username;
@@ -216,7 +216,18 @@ StoragePtr TableFunctionRemote::execute(const ASTPtr & ast_function, const Conte
         return safeGet<const String &>(lit->value);
     };
 
-    description = getStringLiteral(*args[arg_num], "Hosts pattern");
+    if (is_cluster_function)
+    {
+        ASTPtr ast_name = evaluateConstantExpressionOrIdentifierAsLiteral(args[arg_num], context);
+        cluster_name = static_cast<const ASTLiteral &>(*ast_name).value.safeGet<const String &>();
+    }
+    else
+    {
+        if (auto ast_cluster = typeid_cast<const ASTIdentifier *>(args[arg_num].get()))
+            cluster_name = ast_cluster->name;
+        else
+            cluster_description = getStringLiteral(*args[arg_num], "Hosts pattern");
+    }
     ++arg_num;
 
     args[arg_num] = evaluateConstantExpressionOrIdentifierAsLiteral(args[arg_num], context);
@@ -233,29 +244,33 @@ StoragePtr TableFunctionRemote::execute(const ASTPtr & ast_function, const Conte
     else
     {
         if (arg_num >= args.size())
-            throw Exception(err, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+            throw Exception(help_message, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
         args[arg_num] = evaluateConstantExpressionOrIdentifierAsLiteral(args[arg_num], context);
         remote_table = static_cast<const ASTLiteral &>(*args[arg_num]).value.safeGet<String>();
         ++arg_num;
     }
 
-    if (arg_num < args.size())
+    /// Username and password parameters are prohibited in cluster version of the function
+    if (!is_cluster_function)
     {
-        username = getStringLiteral(*args[arg_num], "Username");
-        ++arg_num;
-    }
-    else
-        username = "default";
+        if (arg_num < args.size())
+        {
+            username = getStringLiteral(*args[arg_num], "Username");
+            ++arg_num;
+        }
+        else
+            username = "default";
 
-    if (arg_num < args.size())
-    {
-        password = getStringLiteral(*args[arg_num], "Password");
-        ++arg_num;
+        if (arg_num < args.size())
+        {
+            password = getStringLiteral(*args[arg_num], "Password");
+            ++arg_num;
+        }
     }
 
     if (arg_num < args.size())
-        throw Exception(err, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
+        throw Exception(help_message, ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
 
     /// ExpressionAnalyzer will be created in InterpreterSelectQuery that will meet these `Identifier` when processing the request.
     /// We need to mark them as the name of the database or table, because the default value is column.
@@ -265,16 +280,26 @@ StoragePtr TableFunctionRemote::execute(const ASTPtr & ast_function, const Conte
 
     size_t max_addresses = context.getSettingsRef().table_function_remote_max_addresses;
 
-    std::vector<std::vector<String>> names;
-    std::vector<String> shards = parseDescription(description, 0, description.size(), ',', max_addresses);
+    ClusterPtr cluster;
+    if (!cluster_name.empty())
+    {
+        /// Use an existing cluster from the main config
+        cluster = context.getCluster(cluster_name);
+    }
+    else
+    {
+        /// Create new cluster from the scratch
+        std::vector<String> shards = parseDescription(cluster_description, 0, cluster_description.size(), ',', max_addresses);
 
-    for (size_t i = 0; i < shards.size(); ++i)
-        names.push_back(parseDescription(shards[i], 0, shards[i].size(), '|', max_addresses));
+        std::vector<std::vector<String>> names;
+        for (size_t i = 0; i < shards.size(); ++i)
+            names.push_back(parseDescription(shards[i], 0, shards[i].size(), '|', max_addresses));
 
-    if (names.empty())
-        throw Exception("Shard list is empty after parsing first argument", ErrorCodes::BAD_ARGUMENTS);
+        if (names.empty())
+            throw Exception("Shard list is empty after parsing first argument", ErrorCodes::BAD_ARGUMENTS);
 
-    auto cluster = std::make_shared<Cluster>(context.getSettings(), names, username, password, context.getTCPPort());
+        cluster = std::make_shared<Cluster>(context.getSettings(), names, username, password, context.getTCPPort());
+    }
 
     auto res = StorageDistributed::createWithOwnCluster(
         getName(),
@@ -288,9 +313,23 @@ StoragePtr TableFunctionRemote::execute(const ASTPtr & ast_function, const Conte
 }
 
 
+TableFunctionRemote::TableFunctionRemote(const std::string & name_)
+    : name(name_)
+{
+    is_cluster_function = name == "cluster";
+
+    std::stringstream ss;
+    ss << "Table function '" << name + "' requires from 2 to " << (is_cluster_function ? 3 : 5) << " parameters"
+       << ": <addresses pattern or cluster name>, <name of remote database>, <name of remote table>"
+       << (is_cluster_function ? "" : ", [username, [password]].");
+    help_message = ss.str();
+}
+
+
 void registerTableFunctionRemote(TableFunctionFactory & factory)
 {
-    factory.registerFunction<TableFunctionRemote>();
+    factory.registerFunction("remote", [] () -> TableFunctionPtr { return std::make_shared<TableFunctionRemote>("remote"); });
+    factory.registerFunction("cluster", [] () -> TableFunctionPtr { return std::make_shared<TableFunctionRemote>("cluster"); });
 }
 
 }
diff --git a/dbms/src/TableFunctions/TableFunctionRemote.h b/dbms/src/TableFunctions/TableFunctionRemote.h
index 1891dbd3795a..d1cce5999036 100644
--- a/dbms/src/TableFunctions/TableFunctionRemote.h
+++ b/dbms/src/TableFunctions/TableFunctionRemote.h
@@ -11,13 +11,23 @@ namespace DB
  * For example
  * SELECT count() FROM remote('example01-01-1', merge, hits) - go to `example01-01-1`, in the merge database, the hits table.
  * An expression that generates a set of shards and replicas can also be specified as the host name - see below.
+ * Also, there is a cluster version of the function: cluster('existing_cluster_name', 'db', 'table')
  */
 class TableFunctionRemote : public ITableFunction
 {
 public:
-    static constexpr auto name = "remote";
+
+    explicit TableFunctionRemote(const std::string & name_ = "remote");
+
     std::string getName() const override { return name; }
+
     StoragePtr execute(const ASTPtr & ast_function, const Context & context) const override;
+
+private:
+
+    std::string name;
+    bool is_cluster_function;
+    std::string help_message;
 };
 
 }
