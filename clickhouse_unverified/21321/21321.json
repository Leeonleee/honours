{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21321,
  "instance_id": "ClickHouse__ClickHouse-21321",
  "issue_numbers": [
    "14528"
  ],
  "base_commit": "4e61f45dbbf8fb527ef1367a284b563d2d97a707",
  "patch": "diff --git a/src/Common/BorrowedObjectPool.h b/src/Common/BorrowedObjectPool.h\nnew file mode 100644\nindex 000000000000..d5263cf92a81\n--- /dev/null\n+++ b/src/Common/BorrowedObjectPool.h\n@@ -0,0 +1,157 @@\n+#pragma once\n+\n+#include <cstdint>\n+#include <vector>\n+#include <chrono>\n+#include <mutex>\n+#include <condition_variable>\n+\n+#include <common/defines.h>\n+\n+#include <Common/MoveOrCopyIfThrow.h>\n+\n+/** Pool for limited size objects that cannot be used from different threads simultaneously.\n+  * The main use case is to have fixed size of objects that can be reused in difference threads during their lifetime\n+  * and have to be initialized on demand.\n+  * Two main properties of pool are allocated objects size and borrowed objects size.\n+  * Allocated objects size is size of objects that are currently allocated by the pool.\n+  * Borrowed objects size is size of objects that are borrowed by clients.\n+  * If max_size == 0 then pool has unlimited size and objects will be allocated without limit.\n+  *\n+  * Pool provides following strategy for borrowing object:\n+  * If max_size == 0 then pool has unlimited size and objects will be allocated without limit.\n+  * 1. If pool has objects that can be borrowed increase borrowed objects size and return it.\n+  * 2. If pool allocatedObjectsSize is lower than max objects size or pool has unlimited size\n+  * allocate new object, increase borrowed objects size and return it.\n+  * 3. If pool is full wait on condition variable with or without timeout until some object\n+  * will be returned to the pool.\n+  */\n+template <typename T>\n+class BorrowedObjectPool final\n+{\n+public:\n+    explicit BorrowedObjectPool(size_t max_size_) : max_size(max_size_) {}\n+\n+    /// Borrow object from pool. If pull is full and all objects were borrowed\n+    /// then calling thread will wait until some object will be returned into pool.\n+    template <typename FactoryFunc>\n+    void borrowObject(T & dest, FactoryFunc && func)\n+    {\n+        std::unique_lock<std::mutex> lock(objects_mutex);\n+\n+        if (!objects.empty())\n+        {\n+            dest = borrowFromObjects(lock);\n+            return;\n+        }\n+\n+        bool has_unlimited_size = (max_size == 0);\n+\n+        if (unlikely(has_unlimited_size) || allocated_objects_size < max_size)\n+        {\n+            dest = allocateObjectForBorrowing(lock, std::forward<FactoryFunc>(func));\n+            return;\n+        }\n+\n+        condition_variable.wait(lock, [this] { return !objects.empty(); });\n+        dest = borrowFromObjects(lock);\n+    }\n+\n+    /// Same as borrowObject function, but wait with timeout.\n+    /// Returns true if object was borrowed during timeout.\n+    template <typename FactoryFunc>\n+    bool tryBorrowObject(T & dest, FactoryFunc && func, size_t timeout_in_milliseconds = 0)\n+    {\n+        std::unique_lock<std::mutex> lock(objects_mutex);\n+\n+        if (!objects.empty())\n+        {\n+            dest = borrowFromObjects(lock);\n+            return true;\n+        }\n+\n+        bool has_unlimited_size = (max_size == 0);\n+\n+        if (unlikely(has_unlimited_size) || allocated_objects_size < max_size)\n+        {\n+            dest = allocateObjectForBorrowing(lock, std::forward<FactoryFunc>(func));\n+            return true;\n+        }\n+\n+        bool wait_result = condition_variable.wait_for(lock, std::chrono::milliseconds(timeout_in_milliseconds), [this] { return !objects.empty(); });\n+\n+        if (wait_result)\n+            dest = borrowFromObjects(lock);\n+\n+        return wait_result;\n+    }\n+\n+    /// Return object into pool. Client must return same object that was borrowed.\n+    inline void returnObject(T && object_to_return)\n+    {\n+        std::unique_lock<std::mutex> lck(objects_mutex);\n+\n+        objects.emplace_back(std::move(object_to_return));\n+        --borrowed_objects_size;\n+\n+        condition_variable.notify_one();\n+    }\n+\n+    /// Max pool size\n+    inline size_t maxSize() const\n+    {\n+        return max_size;\n+    }\n+\n+    /// Allocated objects size by the pool. If allocatedObjectsSize == maxSize then pool is full.\n+    inline size_t allocatedObjectsSize() const\n+    {\n+        std::unique_lock<std::mutex> lock(objects_mutex);\n+        return allocated_objects_size;\n+    }\n+\n+    /// Returns allocatedObjectsSize == maxSize\n+    inline bool isFull() const\n+    {\n+        std::unique_lock<std::mutex> lock(objects_mutex);\n+        return allocated_objects_size == max_size;\n+    }\n+\n+    /// Borrowed objects size. If borrowedObjectsSize == allocatedObjectsSize and pool is full.\n+    /// Then client will wait during borrowObject function call.\n+    inline size_t borrowedObjectsSize() const\n+    {\n+        std::unique_lock<std::mutex> lock(objects_mutex);\n+        return borrowed_objects_size;\n+    }\n+\n+private:\n+\n+    template <typename FactoryFunc>\n+    inline T allocateObjectForBorrowing(const std::unique_lock<std::mutex> &, FactoryFunc && func)\n+    {\n+        ++allocated_objects_size;\n+        ++borrowed_objects_size;\n+\n+        return std::forward<FactoryFunc>(func)();\n+    }\n+\n+    inline T borrowFromObjects(const std::unique_lock<std::mutex> &)\n+    {\n+        T dst;\n+        detail::moveOrCopyIfThrow(std::move(objects.back()), dst);\n+        objects.pop_back();\n+\n+        ++borrowed_objects_size;\n+\n+        return dst;\n+    }\n+\n+    size_t max_size;\n+\n+    mutable std::mutex objects_mutex;\n+    std::condition_variable condition_variable;\n+    size_t allocated_objects_size = 0;\n+    size_t borrowed_objects_size = 0;\n+    std::vector<T> objects;\n+};\ndiff --git a/src/Common/ConcurrentBoundedQueue.h b/src/Common/ConcurrentBoundedQueue.h\nindex b888d68a286c..7bc7f362095e 100644\n--- a/src/Common/ConcurrentBoundedQueue.h\n+++ b/src/Common/ConcurrentBoundedQueue.h\n@@ -6,38 +6,7 @@\n #include <Poco/Mutex.h>\n #include <Poco/Semaphore.h>\n \n-#include <common/types.h>\n-\n-\n-namespace detail\n-{\n-    template <typename T, bool is_nothrow_move_assignable = std::is_nothrow_move_assignable_v<T>>\n-    struct MoveOrCopyIfThrow;\n-\n-    template <typename T>\n-    struct MoveOrCopyIfThrow<T, true>\n-    {\n-        void operator()(T && src, T & dst) const\n-        {\n-            dst = std::forward<T>(src);\n-        }\n-    };\n-\n-    template <typename T>\n-    struct MoveOrCopyIfThrow<T, false>\n-    {\n-        void operator()(T && src, T & dst) const\n-        {\n-            dst = src;\n-        }\n-    };\n-\n-    template <typename T>\n-    void moveOrCopyIfThrow(T && src, T & dst)\n-    {\n-        MoveOrCopyIfThrow<T>()(std::forward<T>(src), dst);\n-    }\n-}\n+#include <Common/MoveOrCopyIfThrow.h>\n \n /** A very simple thread-safe queue of limited size.\n   * If you try to pop an item from an empty queue, the thread is blocked until the queue becomes nonempty.\n@@ -53,8 +22,10 @@ class ConcurrentBoundedQueue\n     Poco::Semaphore empty_count;\n \n public:\n-    ConcurrentBoundedQueue(size_t max_fill)\n-        : fill_count(0, max_fill), empty_count(max_fill, max_fill) {}\n+    explicit ConcurrentBoundedQueue(size_t max_fill)\n+        : fill_count(0, max_fill)\n+        , empty_count(max_fill, max_fill)\n+    {}\n \n     void push(const T & x)\n     {\ndiff --git a/src/Common/MoveOrCopyIfThrow.h b/src/Common/MoveOrCopyIfThrow.h\nnew file mode 100644\nindex 000000000000..caa1b51e2bc7\n--- /dev/null\n+++ b/src/Common/MoveOrCopyIfThrow.h\n@@ -0,0 +1,33 @@\n+#pragma once\n+\n+#include <common/types.h>\n+\n+namespace detail\n+{\n+    template <typename T, bool is_nothrow_move_assignable = std::is_nothrow_move_assignable_v<T>>\n+    struct MoveOrCopyIfThrow;\n+\n+    template <typename T>\n+    struct MoveOrCopyIfThrow<T, true>\n+    {\n+        void operator()(T && src, T & dst) const\n+        {\n+            dst = std::forward<T>(src);\n+        }\n+    };\n+\n+    template <typename T>\n+    struct MoveOrCopyIfThrow<T, false>\n+    {\n+        void operator()(T && src, T & dst) const\n+        {\n+            dst = src;\n+        }\n+    };\n+\n+    template <typename T>\n+    void moveOrCopyIfThrow(T && src, T & dst)\n+    {\n+        MoveOrCopyIfThrow<T>()(std::forward<T>(src), dst);\n+    }\n+}\ndiff --git a/src/Common/ShellCommand.cpp b/src/Common/ShellCommand.cpp\nindex 069c77747292..44f68f0071c2 100644\n--- a/src/Common/ShellCommand.cpp\n+++ b/src/Common/ShellCommand.cpp\n@@ -2,15 +2,18 @@\n #include <sys/wait.h>\n #include <fcntl.h>\n #include <dlfcn.h>\n+#include <unistd.h>\n+#include <time.h>\n+#include <csignal>\n+\n+#include <common/logger_useful.h>\n+#include <common/errnoToString.h>\n #include <Common/Exception.h>\n #include <Common/ShellCommand.h>\n #include <Common/PipeFDs.h>\n-#include <common/logger_useful.h>\n-#include <common/errnoToString.h>\n #include <IO/WriteHelpers.h>\n #include <IO/Operators.h>\n-#include <unistd.h>\n-#include <csignal>\n+\n \n namespace\n {\n@@ -36,9 +39,9 @@ namespace ErrorCodes\n     extern const int CANNOT_CREATE_CHILD_PROCESS;\n }\n \n-ShellCommand::ShellCommand(pid_t pid_, int & in_fd_, int & out_fd_, int & err_fd_, bool terminate_in_destructor_)\n+ShellCommand::ShellCommand(pid_t pid_, int & in_fd_, int & out_fd_, int & err_fd_, ShellCommandDestructorStrategy destructor_strategy_)\n     : pid(pid_)\n-    , terminate_in_destructor(terminate_in_destructor_)\n+    , destructor_strategy(destructor_strategy_)\n     , in(in_fd_)\n     , out(out_fd_)\n     , err(err_fd_)\n@@ -52,14 +55,24 @@ Poco::Logger * ShellCommand::getLogger()\n \n ShellCommand::~ShellCommand()\n {\n-    if (terminate_in_destructor)\n+    if (wait_called)\n+        return;\n+\n+    if (destructor_strategy.terminate_in_destructor)\n     {\n-        LOG_TRACE(getLogger(), \"Will kill shell command pid {} with SIGTERM\", pid);\n-        int retcode = kill(pid, SIGTERM);\n-        if (retcode != 0)\n-            LOG_WARNING(getLogger(), \"Cannot kill shell command pid {} errno '{}'\", pid, errnoToString(retcode));\n+        size_t try_wait_timeout = destructor_strategy.wait_for_normal_exit_before_termination_seconds;\n+        bool process_terminated_normally = tryWaitProcessWithTimeout(try_wait_timeout);\n+\n+        if (!process_terminated_normally)\n+        {\n+            LOG_TRACE(getLogger(), \"Will kill shell command pid {} with SIGTERM\", pid);\n+\n+            int retcode = kill(pid, SIGTERM);\n+            if (retcode != 0)\n+                LOG_WARNING(getLogger(), \"Cannot kill shell command pid {} errno '{}'\", pid, errnoToString(retcode));\n+        }\n     }\n-    else if (!wait_called)\n+    else\n     {\n         try\n         {\n@@ -72,6 +85,54 @@ ShellCommand::~ShellCommand()\n     }\n }\n \n+bool ShellCommand::tryWaitProcessWithTimeout(size_t timeout_in_seconds)\n+{\n+    int status = 0;\n+\n+    LOG_TRACE(getLogger(), \"Try wait for shell command pid ({}) with timeout ({})\", pid, timeout_in_seconds);\n+\n+    wait_called = true;\n+    struct timespec interval {.tv_sec = 1, .tv_nsec = 0};\n+\n+    in.close();\n+    out.close();\n+    err.close();\n+\n+    if (timeout_in_seconds == 0)\n+    {\n+        /// If there is no timeout before signal try to waitpid 1 time without block so we can avoid sending\n+        /// signal if process is already normally terminated.\n+\n+        int waitpid_res = waitpid(pid, &status, WNOHANG);\n+        bool process_terminated_normally = (waitpid_res == pid);\n+        return process_terminated_normally;\n+    }\n+\n+    /// If timeout is positive try waitpid without block in loop until\n+    /// process is normally terminated or waitpid return error\n+\n+    while (timeout_in_seconds != 0)\n+    {\n+        int waitpid_res = waitpid(pid, &status, WNOHANG);\n+\n+        bool process_terminated_normally = (waitpid_res == pid);\n+\n+        if (process_terminated_normally)\n+            return true;\n+        else if (waitpid_res == 0)\n+        {\n+            --timeout_in_seconds;\n+            nanosleep(&interval, nullptr);\n+\n+            continue;\n+        }\n+        else if (waitpid_res == -1 && errno != EINTR)\n+            return false;\n+    }\n+\n+    return false;\n+}\n+\n void ShellCommand::logCommand(const char * filename, char * const argv[])\n {\n     WriteBufferFromOwnString args;\n@@ -87,7 +148,10 @@ void ShellCommand::logCommand(const char * filename, char * const argv[])\n }\n \n std::unique_ptr<ShellCommand> ShellCommand::executeImpl(\n-    const char * filename, char * const argv[], bool pipe_stdin_only, bool terminate_in_destructor)\n+    const char * filename,\n+    char * const argv[],\n+    bool pipe_stdin_only,\n+    ShellCommandDestructorStrategy terminate_in_destructor_strategy)\n {\n     logCommand(filename, argv);\n \n@@ -144,7 +208,7 @@ std::unique_ptr<ShellCommand> ShellCommand::executeImpl(\n     }\n \n     std::unique_ptr<ShellCommand> res(new ShellCommand(\n-        pid, pipe_stdin.fds_rw[1], pipe_stdout.fds_rw[0], pipe_stderr.fds_rw[0], terminate_in_destructor));\n+        pid, pipe_stdin.fds_rw[1], pipe_stdout.fds_rw[0], pipe_stderr.fds_rw[0], terminate_in_destructor_strategy));\n \n     LOG_TRACE(getLogger(), \"Started shell command '{}' with pid {}\", filename, pid);\n     return res;\n@@ -152,7 +216,9 @@ std::unique_ptr<ShellCommand> ShellCommand::executeImpl(\n \n \n std::unique_ptr<ShellCommand> ShellCommand::execute(\n-    const std::string & command, bool pipe_stdin_only, bool terminate_in_destructor)\n+    const std::string & command,\n+    bool pipe_stdin_only,\n+    ShellCommandDestructorStrategy terminate_in_destructor_strategy)\n {\n     /// Arguments in non-constant chunks of memory (as required for `execv`).\n     /// Moreover, their copying must be done before calling `vfork`, so after `vfork` do a minimum of things.\n@@ -162,12 +228,14 @@ std::unique_ptr<ShellCommand> ShellCommand::execute(\n \n     char * const argv[] = { argv0.data(), argv1.data(), argv2.data(), nullptr };\n \n-    return executeImpl(\"/bin/sh\", argv, pipe_stdin_only, terminate_in_destructor);\n+    return executeImpl(\"/bin/sh\", argv, pipe_stdin_only, terminate_in_destructor_strategy);\n }\n \n \n std::unique_ptr<ShellCommand> ShellCommand::executeDirect(\n-    const std::string & path, const std::vector<std::string> & arguments, bool terminate_in_destructor)\n+    const std::string & path,\n+    const std::vector<std::string> & arguments,\n+    ShellCommandDestructorStrategy terminate_in_destructor_strategy)\n {\n     size_t argv_sum_size = path.size() + 1;\n     for (const auto & arg : arguments)\n@@ -188,7 +256,7 @@ std::unique_ptr<ShellCommand> ShellCommand::executeDirect(\n \n     argv[arguments.size() + 1] = nullptr;\n \n-    return executeImpl(path.data(), argv.data(), false, terminate_in_destructor);\n+    return executeImpl(path.data(), argv.data(), false, terminate_in_destructor_strategy);\n }\n \n \ndiff --git a/src/Common/ShellCommand.h b/src/Common/ShellCommand.h\nindex 1c681227efdc..f1d808128fff 100644\n--- a/src/Common/ShellCommand.h\n+++ b/src/Common/ShellCommand.h\n@@ -23,21 +23,38 @@ namespace DB\n   * The second difference - allows to work simultaneously with stdin, and with stdout, and with stderr of running process,\n   *  and also to obtain the return code and completion status.\n   */\n-class ShellCommand\n+\n+struct ShellCommandDestructorStrategy final\n+{\n+    explicit ShellCommandDestructorStrategy(bool terminate_in_destructor_, size_t wait_for_normal_exit_before_termination_seconds_ = 0)\n+        : terminate_in_destructor(terminate_in_destructor_)\n+        , wait_for_normal_exit_before_termination_seconds(wait_for_normal_exit_before_termination_seconds_)\n+    {\n+    }\n+\n+    bool terminate_in_destructor;\n+\n+    /// If terminate in destructor is true, command will wait until send SIGTERM signal to created process\n+    size_t wait_for_normal_exit_before_termination_seconds = 0;\n+};\n+\n+class ShellCommand final\n {\n private:\n     pid_t pid;\n     bool wait_called = false;\n-    bool terminate_in_destructor;\n+    ShellCommandDestructorStrategy destructor_strategy;\n+\n+    ShellCommand(pid_t pid_, int & in_fd_, int & out_fd_, int & err_fd_, ShellCommandDestructorStrategy destructor_strategy_);\n \n-    ShellCommand(pid_t pid_, int & in_fd_, int & out_fd_, int & err_fd_, bool terminate_in_destructor_);\n+    bool tryWaitProcessWithTimeout(size_t timeout_in_seconds);\n \n     static Poco::Logger * getLogger();\n \n     /// Print command name and the list of arguments to log. NOTE: No escaping of arguments is performed.\n     static void logCommand(const char * filename, char * const argv[]);\n \n-    static std::unique_ptr<ShellCommand> executeImpl(const char * filename, char * const argv[], bool pipe_stdin_only, bool terminate_in_destructor);\n+    static std::unique_ptr<ShellCommand> executeImpl(const char * filename, char * const argv[], bool pipe_stdin_only, ShellCommandDestructorStrategy terminate_in_destructor_strategy);\n \n public:\n     WriteBufferFromFile in;        /// If the command reads from stdin, do not forget to call in.close() after writing all the data there.\n@@ -48,11 +65,11 @@ class ShellCommand\n \n     /// Run the command using /bin/sh -c.\n     /// If terminate_in_destructor is true, send terminate signal in destructor and don't wait process.\n-    static std::unique_ptr<ShellCommand> execute(const std::string & command, bool pipe_stdin_only = false, bool terminate_in_destructor = false);\n+    static std::unique_ptr<ShellCommand> execute(const std::string & command, bool pipe_stdin_only = false, ShellCommandDestructorStrategy terminate_in_destructor_strategy = ShellCommandDestructorStrategy(false));\n \n     /// Run the executable with the specified arguments. `arguments` - without argv[0].\n     /// If terminate_in_destructor is true, send terminate signal in destructor and don't wait process.\n-    static std::unique_ptr<ShellCommand> executeDirect(const std::string & path, const std::vector<std::string> & arguments, bool terminate_in_destructor = false);\n+    static std::unique_ptr<ShellCommand> executeDirect(const std::string & path, const std::vector<std::string> & arguments, ShellCommandDestructorStrategy terminate_in_destructor_strategy = ShellCommandDestructorStrategy(false));\n \n     /// Wait for the process to end, throw an exception if the code is not 0 or if the process was not completed by itself.\n     void wait();\ndiff --git a/src/Common/XDBCBridgeHelper.h b/src/Common/XDBCBridgeHelper.h\nindex 8da735c6fe32..1e552157a561 100644\n--- a/src/Common/XDBCBridgeHelper.h\n+++ b/src/Common/XDBCBridgeHelper.h\n@@ -345,7 +345,7 @@ struct ODBCBridgeMixin\n \n         LOG_TRACE(log, \"Starting {}\", serviceAlias());\n \n-        return ShellCommand::executeDirect(path.toString(), cmd_args, true);\n+        return ShellCommand::executeDirect(path.toString(), cmd_args, ShellCommandDestructorStrategy(true));\n     }\n };\n }\ndiff --git a/src/Dictionaries/DictionarySourceHelpers.cpp b/src/Dictionaries/DictionarySourceHelpers.cpp\nindex 2a872672aff0..64527a78e8ee 100644\n--- a/src/Dictionaries/DictionarySourceHelpers.cpp\n+++ b/src/Dictionaries/DictionarySourceHelpers.cpp\n@@ -13,6 +13,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;\n+}\n+\n void formatBlock(BlockOutputStreamPtr & out, const Block & block)\n {\n     out->writePrefix();\n@@ -88,4 +93,63 @@ Context copyContextAndApplySettings(\n     return local_context;\n }\n \n+\n+BlockInputStreamWithAdditionalColumns::BlockInputStreamWithAdditionalColumns(\n+    Block block_to_add_, std::unique_ptr<IBlockInputStream> && stream_)\n+    : block_to_add(std::move(block_to_add_))\n+    , stream(std::move(stream_))\n+{\n+}\n+\n+Block BlockInputStreamWithAdditionalColumns::getHeader() const\n+{\n+    auto header = stream->getHeader();\n+\n+    if (header)\n+    {\n+        for (Int64 i = static_cast<Int64>(block_to_add.columns() - 1); i >= 0; --i)\n+            header.insert(0, block_to_add.getByPosition(i).cloneEmpty());\n+    }\n+\n+    return header;\n+}\n+\n+Block BlockInputStreamWithAdditionalColumns::readImpl()\n+{\n+    auto block = stream->read();\n+\n+    if (block)\n+    {\n+        auto block_rows = block.rows();\n+\n+        auto cut_block = block_to_add.cloneWithCutColumns(current_range_index, block_rows);\n+\n+        if (cut_block.rows() != block_rows)\n+            throw Exception(\n+                \"Number of rows in block to add after cut must equal to number of rows in block from inner stream\",\n+                ErrorCodes::SIZES_OF_COLUMNS_DOESNT_MATCH);\n+\n+        for (Int64 i = static_cast<Int64>(cut_block.columns() - 1); i >= 0; --i)\n+            block.insert(0, cut_block.getByPosition(i));\n+\n+        current_range_index += block_rows;\n+    }\n+\n+    return block;\n+}\n+\n+void BlockInputStreamWithAdditionalColumns::readPrefix()\n+{\n+    stream->readPrefix();\n+}\n+\n+void BlockInputStreamWithAdditionalColumns::readSuffix()\n+{\n+    stream->readSuffix();\n+}\n+\n+String BlockInputStreamWithAdditionalColumns::getName() const\n+{\n+    return \"BlockInputStreamWithAdditionalColumns\";\n+}\n }\ndiff --git a/src/Dictionaries/DictionarySourceHelpers.h b/src/Dictionaries/DictionarySourceHelpers.h\nindex cad5441c66e1..b429136a9812 100644\n--- a/src/Dictionaries/DictionarySourceHelpers.h\n+++ b/src/Dictionaries/DictionarySourceHelpers.h\n@@ -6,12 +6,13 @@\n \n #include <Poco/File.h>\n #include <Poco/Util/AbstractConfiguration.h>\n-\n+#include <DataStreams/IBlockInputStream.h>\n #include <Columns/IColumn.h>\n #include <Core/Block.h>\n \n namespace DB\n {\n+\n class IBlockOutputStream;\n using BlockOutputStreamPtr = std::shared_ptr<IBlockOutputStream>;\n \n@@ -46,4 +47,29 @@ void applySettingsToContext(\n     Context & context,\n     const Poco::Util::AbstractConfiguration & config);\n \n+/** A stream, adds additional columns to each block that it will read from inner stream.\n+     *\n+     *  block_to_add rows size must be equal to final sum rows size of all inner stream blocks.\n+     */\n+class BlockInputStreamWithAdditionalColumns final : public IBlockInputStream\n+{\n+public:\n+    BlockInputStreamWithAdditionalColumns(Block block_to_add_, std::unique_ptr<IBlockInputStream> && stream_);\n+\n+    Block getHeader() const override;\n+\n+    Block readImpl() override;\n+\n+    void readPrefix() override;\n+\n+    void readSuffix() override;\n+\n+    String getName() const override;\n+\n+private:\n+    Block block_to_add;\n+    std::unique_ptr<IBlockInputStream> stream;\n+    size_t current_range_index = 0;\n+};\n+\n }\ndiff --git a/src/Dictionaries/ExecutableDictionarySource.cpp b/src/Dictionaries/ExecutableDictionarySource.cpp\nindex 37dde600adff..8066de41b207 100644\n--- a/src/Dictionaries/ExecutableDictionarySource.cpp\n+++ b/src/Dictionaries/ExecutableDictionarySource.cpp\n@@ -27,7 +27,6 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n     extern const int DICTIONARY_ACCESS_DENIED;\n     extern const int UNSUPPORTED_METHOD;\n-    extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;\n }\n \n namespace\n@@ -58,7 +57,6 @@ namespace\n \n }\n \n-\n ExecutableDictionarySource::ExecutableDictionarySource(\n     const DictionaryStructure & dict_struct_,\n     const Poco::Util::AbstractConfiguration & config,\n@@ -200,101 +198,14 @@ namespace\n         std::function<void(WriteBufferFromFile &)> send_data;\n         ThreadFromGlobalPool thread;\n     };\n-\n-    /** A stream, adds additional columns to each block that it will read from inner stream.\n-     *\n-     *  block_to_add rows size must be equal to final sum rows size of all inner stream blocks.\n-     */\n-    class BlockInputStreamWithAdditionalColumns final: public IBlockInputStream\n-    {\n-    public:\n-        BlockInputStreamWithAdditionalColumns(\n-            Block block_to_add_,\n-            std::unique_ptr<IBlockInputStream>&& stream_)\n-            : block_to_add(std::move(block_to_add_))\n-            , stream(std::move(stream_))\n-        {\n-        }\n-\n-        Block getHeader() const override\n-        {\n-            auto header = stream->getHeader();\n-\n-            if (header)\n-            {\n-                for (Int64 i = static_cast<Int64>(block_to_add.columns() - 1); i >= 0; --i)\n-                    header.insert(0, block_to_add.getByPosition(i).cloneEmpty());\n-            }\n-\n-            return header;\n-        }\n-\n-        Block readImpl() override\n-        {\n-            auto block = stream->read();\n-\n-            if (block)\n-            {\n-                auto block_rows = block.rows();\n-\n-                auto cut_block = block_to_add.cloneWithCutColumns(current_range_index, block_rows);\n-\n-                if (cut_block.rows() != block_rows)\n-                    throw Exception(\n-                        \"Number of rows in block to add after cut must equal to number of rows in block from inner stream\",\n-                        ErrorCodes::SIZES_OF_COLUMNS_DOESNT_MATCH);\n-\n-                for (Int64 i = static_cast<Int64>(cut_block.columns() - 1); i >= 0; --i)\n-                    block.insert(0, cut_block.getByPosition(i));\n-\n-                current_range_index += block_rows;\n-            }\n-\n-            return block;\n-        }\n-\n-        void readPrefix() override\n-        {\n-            stream->readPrefix();\n-        }\n-\n-        void readSuffix() override\n-        {\n-            stream->readSuffix();\n-        }\n-\n-        String getName() const override { return \"BlockInputStreamWithAdditionalColumns\"; }\n-\n-    private:\n-        Block block_to_add;\n-        std::unique_ptr<IBlockInputStream> stream;\n-        size_t current_range_index = 0;\n-    };\n-\n }\n \n-\n BlockInputStreamPtr ExecutableDictionarySource::loadIds(const std::vector<UInt64> & ids)\n {\n     LOG_TRACE(log, \"loadIds {} size = {}\", toString(), ids.size());\n \n     auto block = blockForIds(dict_struct, ids);\n-\n-    auto stream = std::make_unique<BlockInputStreamWithBackgroundThread>(\n-        context, format, sample_block, command, log,\n-        [block, this](WriteBufferFromFile & out) mutable\n-        {\n-            auto output_stream = context.getOutputStream(format, out, block.cloneEmpty());\n-            formatBlock(output_stream, block);\n-            out.close();\n-        });\n-\n-    if (implicit_key)\n-    {\n-        return std::make_shared<BlockInputStreamWithAdditionalColumns>(block, std::move(stream));\n-    }\n-    else\n-        return std::shared_ptr<BlockInputStreamWithBackgroundThread>(stream.release());\n+    return getStreamForBlock(block);\n }\n \n BlockInputStreamPtr ExecutableDictionarySource::loadKeys(const Columns & key_columns, const std::vector<size_t> & requested_rows)\n@@ -302,7 +213,11 @@ BlockInputStreamPtr ExecutableDictionarySource::loadKeys(const Columns & key_col\n     LOG_TRACE(log, \"loadKeys {} size = {}\", toString(), requested_rows.size());\n \n     auto block = blockForKeys(dict_struct, key_columns, requested_rows);\n+    return getStreamForBlock(block);\n+}\n \n+BlockInputStreamPtr ExecutableDictionarySource::getStreamForBlock(const Block & block)\n+{\n     auto stream = std::make_unique<BlockInputStreamWithBackgroundThread>(\n         context, format, sample_block, command, log,\n         [block, this](WriteBufferFromFile & out) mutable\n@@ -354,13 +269,13 @@ void registerDictionarySourceExecutable(DictionarySourceFactory & factory)\n                                  bool check_config) -> DictionarySourcePtr\n     {\n         if (dict_struct.has_expressions)\n-            throw Exception{\"Dictionary source of type `executable` does not support attribute expressions\", ErrorCodes::LOGICAL_ERROR};\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Dictionary source of type `executable` does not support attribute expressions\");\n \n         /// Executable dictionaries may execute arbitrary commands.\n         /// It's OK for dictionaries created by administrator from xml-file, but\n         /// maybe dangerous for dictionaries created from DDL-queries.\n         if (check_config)\n-            throw Exception(\"Dictionaries with Executable dictionary source is not allowed\", ErrorCodes::DICTIONARY_ACCESS_DENIED);\n+            throw Exception(ErrorCodes::DICTIONARY_ACCESS_DENIED, \"Dictionaries with executable dictionary source are not allowed to be created from DDL query\");\n \n         Context context_local_copy = copyContextAndApplySettings(config_prefix, context, config);\n \ndiff --git a/src/Dictionaries/ExecutableDictionarySource.h b/src/Dictionaries/ExecutableDictionarySource.h\nindex 7aa203f267b2..9dc152bf580d 100644\n--- a/src/Dictionaries/ExecutableDictionarySource.h\n+++ b/src/Dictionaries/ExecutableDictionarySource.h\n@@ -47,6 +47,8 @@ class ExecutableDictionarySource final : public IDictionarySource\n \n     std::string toString() const override;\n \n+    BlockInputStreamPtr getStreamForBlock(const Block & block);\n+\n private:\n     Poco::Logger * log;\n     time_t update_time = 0;\ndiff --git a/src/Dictionaries/ExecutablePoolDictionarySource.cpp b/src/Dictionaries/ExecutablePoolDictionarySource.cpp\nnew file mode 100644\nindex 000000000000..4bafeeecf7e7\n--- /dev/null\n+++ b/src/Dictionaries/ExecutablePoolDictionarySource.cpp\n@@ -0,0 +1,321 @@\n+#include \"ExecutablePoolDictionarySource.h\"\n+\n+#include <functional>\n+#include <ext/scope_guard.h>\n+#include <DataStreams/IBlockOutputStream.h>\n+#include <Interpreters/Context.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/copyData.h>\n+#include <Common/ShellCommand.h>\n+#include <Common/ThreadPool.h>\n+#include <common/logger_useful.h>\n+#include <common/LocalDateTime.h>\n+#include \"DictionarySourceFactory.h\"\n+#include \"DictionarySourceHelpers.h\"\n+#include \"DictionaryStructure.h\"\n+#include \"registerDictionaries.h\"\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int DICTIONARY_ACCESS_DENIED;\n+    extern const int UNSUPPORTED_METHOD;\n+    extern const int TIMEOUT_EXCEEDED;\n+}\n+\n+ExecutablePoolDictionarySource::ExecutablePoolDictionarySource(\n+    const DictionaryStructure & dict_struct_,\n+    const Configuration & configuration_,\n+    Block & sample_block_,\n+    const Context & context_)\n+    : log(&Poco::Logger::get(\"ExecutablePoolDictionarySource\"))\n+    , dict_struct{dict_struct_}\n+    , configuration{configuration_}\n+    , sample_block{sample_block_}\n+    , context{context_}\n+    /// If pool size == 0 then there is no size restrictions. Poco max size of semaphore is integer type.\n+    , process_pool{std::make_shared<ProcessPool>(configuration.pool_size == 0 ? std::numeric_limits<int>::max() : configuration.pool_size)}\n+{\n+    /// Remove keys from sample_block for implicit_key dictionary because\n+    /// these columns will not be returned from source\n+    /// Implicit key means that the source script will return only values,\n+    /// and the correspondence to the requested keys is determined implicitly - by the order of rows in the result.\n+    if (configuration.implicit_key)\n+    {\n+        auto keys_names = dict_struct.getKeysNames();\n+\n+        for (auto & key_name : keys_names)\n+        {\n+            size_t key_column_position_in_block = sample_block.getPositionByName(key_name);\n+            sample_block.erase(key_column_position_in_block);\n+        }\n+    }\n+}\n+\n+ExecutablePoolDictionarySource::ExecutablePoolDictionarySource(const ExecutablePoolDictionarySource & other)\n+    : log(&Poco::Logger::get(\"ExecutablePoolDictionarySource\"))\n+    , update_time{other.update_time}\n+    , dict_struct{other.dict_struct}\n+    , configuration{other.configuration}\n+    , sample_block{other.sample_block}\n+    , context{other.context}\n+    , process_pool{std::make_shared<ProcessPool>(configuration.pool_size)}\n+{\n+}\n+\n+BlockInputStreamPtr ExecutablePoolDictionarySource::loadAll()\n+{\n+    throw Exception(\"ExecutablePoolDictionarySource with implicit_key does not support loadAll method\", ErrorCodes::UNSUPPORTED_METHOD);\n+}\n+\n+BlockInputStreamPtr ExecutablePoolDictionarySource::loadUpdatedAll()\n+{\n+    throw Exception(\"ExecutablePoolDictionarySource with implicit_key does not support loadAll method\", ErrorCodes::UNSUPPORTED_METHOD);\n+}\n+\n+namespace\n+{\n+    /** A stream, that runs child process and sends data to its stdin in background thread,\n+      *  and receives data from its stdout.\n+      */\n+    class PoolBlockInputStreamWithBackgroundThread final : public IBlockInputStream\n+    {\n+    public:\n+        PoolBlockInputStreamWithBackgroundThread(\n+            std::shared_ptr<ProcessPool> process_pool_,\n+            std::unique_ptr<ShellCommand> && command_,\n+            BlockInputStreamPtr && stream_,\n+            size_t read_rows_,\n+            Poco::Logger * log_,\n+            std::function<void(WriteBufferFromFile &)> && send_data_)\n+            : process_pool(process_pool_)\n+            , command(std::move(command_))\n+            , stream(std::move(stream_))\n+            , rows_to_read(read_rows_)\n+            , log(log_)\n+            , send_data(std::move(send_data_))\n+            , thread([this]\n+            {\n+                try\n+                {\n+                    send_data(command->in);\n+                }\n+                catch (...)\n+                {\n+                    std::lock_guard<std::mutex> lck(exception_during_read_lock);\n+                    exception_during_read = std::current_exception();\n+                }\n+            })\n+        {}\n+\n+        ~PoolBlockInputStreamWithBackgroundThread() override\n+        {\n+            if (thread.joinable())\n+                thread.join();\n+\n+            if (command)\n+                process_pool->returnObject(std::move(command));\n+        }\n+\n+        Block getHeader() const override\n+        {\n+            return stream->getHeader();\n+        }\n+\n+    private:\n+        Block readImpl() override\n+        {\n+            rethrowExceptionDuringReadIfNeeded();\n+\n+            if (current_read_rows == rows_to_read)\n+                return Block();\n+\n+            Block block;\n+\n+            try\n+            {\n+                block = stream->read();\n+                current_read_rows += block.rows();\n+            }\n+            catch (...)\n+            {\n+                tryLogCurrentException(log);\n+                command = nullptr;\n+                throw;\n+            }\n+\n+            return block;\n+        }\n+\n+        void readPrefix() override\n+        {\n+            rethrowExceptionDuringReadIfNeeded();\n+            stream->readPrefix();\n+        }\n+\n+        void readSuffix() override\n+        {\n+            if (thread.joinable())\n+                thread.join();\n+\n+            rethrowExceptionDuringReadIfNeeded();\n+            stream->readSuffix();\n+        }\n+\n+        void rethrowExceptionDuringReadIfNeeded()\n+        {\n+            std::lock_guard<std::mutex> lck(exception_during_read_lock);\n+            if (exception_during_read)\n+            {\n+                command = nullptr;\n+                std::rethrow_exception(exception_during_read);\n+            }\n+        }\n+\n+        String getName() const override { return \"PoolWithBackgroundThread\"; }\n+\n+        std::shared_ptr<ProcessPool> process_pool;\n+        std::unique_ptr<ShellCommand> command;\n+        BlockInputStreamPtr stream;\n+        size_t rows_to_read;\n+        Poco::Logger * log;\n+        std::function<void(WriteBufferFromFile &)> send_data;\n+        ThreadFromGlobalPool thread;\n+        size_t current_read_rows = 0;\n+        std::mutex exception_during_read_lock;\n+        std::exception_ptr exception_during_read;\n+    };\n+\n+}\n+\n+BlockInputStreamPtr ExecutablePoolDictionarySource::loadIds(const std::vector<UInt64> & ids)\n+{\n+    LOG_TRACE(log, \"loadIds {} size = {}\", toString(), ids.size());\n+\n+    auto block = blockForIds(dict_struct, ids);\n+    return getStreamForBlock(block);\n+}\n+\n+BlockInputStreamPtr ExecutablePoolDictionarySource::loadKeys(const Columns & key_columns, const std::vector<size_t> & requested_rows)\n+{\n+    LOG_TRACE(log, \"loadKeys {} size = {}\", toString(), requested_rows.size());\n+\n+    auto block = blockForKeys(dict_struct, key_columns, requested_rows);\n+    return getStreamForBlock(block);\n+}\n+\n+BlockInputStreamPtr ExecutablePoolDictionarySource::getStreamForBlock(const Block & block)\n+{\n+    std::unique_ptr<ShellCommand> process;\n+    bool result = process_pool->tryBorrowObject(process, [this]()\n+    {\n+        bool terminate_in_destructor = true;\n+        ShellCommandDestructorStrategy strategy { terminate_in_destructor, configuration.command_termination_timeout };\n+        auto shell_command = ShellCommand::execute(configuration.command, false, strategy);\n+        return shell_command;\n+    }, configuration.max_command_execution_time * 10000);\n+\n+    if (!result)\n+        throw Exception(ErrorCodes::TIMEOUT_EXCEEDED, \"Could not get process from pool, max command execution timeout exceeded\");\n+\n+    size_t rows_to_read = block.rows();\n+    auto read_stream = context.getInputFormat(configuration.format, process->out, sample_block, rows_to_read);\n+\n+    auto stream = std::make_unique<PoolBlockInputStreamWithBackgroundThread>(\n+        process_pool, std::move(process), std::move(read_stream), rows_to_read, log,\n+        [block, this](WriteBufferFromFile & out) mutable\n+        {\n+            auto output_stream = context.getOutputStream(configuration.format, out, block.cloneEmpty());\n+            formatBlock(output_stream, block);\n+        });\n+\n+    if (configuration.implicit_key)\n+        return std::make_shared<BlockInputStreamWithAdditionalColumns>(block, std::move(stream));\n+    else\n+        return std::shared_ptr<PoolBlockInputStreamWithBackgroundThread>(stream.release());\n+}\n+\n+bool ExecutablePoolDictionarySource::isModified() const\n+{\n+    return true;\n+}\n+\n+bool ExecutablePoolDictionarySource::supportsSelectiveLoad() const\n+{\n+    return true;\n+}\n+\n+bool ExecutablePoolDictionarySource::hasUpdateField() const\n+{\n+    return !configuration.update_field.empty();\n+}\n+\n+DictionarySourcePtr ExecutablePoolDictionarySource::clone() const\n+{\n+    return std::make_unique<ExecutablePoolDictionarySource>(*this);\n+}\n+\n+std::string ExecutablePoolDictionarySource::toString() const\n+{\n+    return \"ExecutablePool size: \" + std::to_string(configuration.pool_size) + \" command: \" + configuration.command;\n+}\n+\n+void registerDictionarySourceExecutablePool(DictionarySourceFactory & factory)\n+{\n+    auto create_table_source = [=](const DictionaryStructure & dict_struct,\n+                                 const Poco::Util::AbstractConfiguration & config,\n+                                 const std::string & config_prefix,\n+                                 Block & sample_block,\n+                                 const Context & context,\n+                                 const std::string & /* default_database */,\n+                                 bool check_config) -> DictionarySourcePtr\n+    {\n+        if (dict_struct.has_expressions)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Dictionary source of type `executable_pool` does not support attribute expressions\");\n+\n+        /// Executable dictionaries may execute arbitrary commands.\n+        /// It's OK for dictionaries created by administrator from xml-file, but\n+        /// maybe dangerous for dictionaries created from DDL-queries.\n+        if (check_config)\n+            throw Exception(ErrorCodes::DICTIONARY_ACCESS_DENIED, \"Dictionaries with executable pool dictionary source are not allowed to be created from DDL query\");\n+\n+        Context context_local_copy = copyContextAndApplySettings(config_prefix, context, config);\n+\n+        /** Currently parallel parsing input format cannot read exactly max_block_size rows from input,\n+         *  so it will be blocked on ReadBufferFromFileDescriptor because this file descriptor represent pipe that does not have eof.\n+         */\n+        auto settings_no_parallel_parsing = context_local_copy.getSettings();\n+        settings_no_parallel_parsing.input_format_parallel_parsing = false;\n+        context_local_copy.setSettings(settings_no_parallel_parsing);\n+\n+        String configuration_config_prefix = config_prefix + \".executable_pool\";\n+\n+        size_t max_command_execution_time = config.getUInt64(configuration_config_prefix + \".max_command_execution_time\", 10);\n+\n+        size_t max_execution_time_seconds = static_cast<size_t>(context.getSettings().max_execution_time.totalSeconds());\n+        if (max_command_execution_time > max_execution_time_seconds)\n+            max_command_execution_time = max_execution_time_seconds;\n+\n+        ExecutablePoolDictionarySource::Configuration configuration\n+        {\n+            .command = config.getString(configuration_config_prefix + \".command\"),\n+            .format = config.getString(configuration_config_prefix + \".format\"),\n+            .pool_size = config.getUInt64(configuration_config_prefix + \".size\"),\n+            .update_field = config.getString(configuration_config_prefix + \".update_field\", \"\"),\n+            .implicit_key = config.getBool(configuration_config_prefix + \".implicit_key\", false),\n+            .command_termination_timeout = config.getUInt64(configuration_config_prefix + \".command_termination_timeout\", 10),\n+            .max_command_execution_time = max_command_execution_time\n+        };\n+\n+        return std::make_unique<ExecutablePoolDictionarySource>(dict_struct, configuration, sample_block, context_local_copy);\n+    };\n+\n+    factory.registerSource(\"executable_pool\", create_table_source);\n+}\n+\n+}\ndiff --git a/src/Dictionaries/ExecutablePoolDictionarySource.h b/src/Dictionaries/ExecutablePoolDictionarySource.h\nnew file mode 100644\nindex 000000000000..da75881b7992\n--- /dev/null\n+++ b/src/Dictionaries/ExecutablePoolDictionarySource.h\n@@ -0,0 +1,84 @@\n+#pragma once\n+\n+#include <Core/Block.h>\n+#include <Common/BorrowedObjectPool.h>\n+#include <Interpreters/Context.h>\n+\n+#include \"IDictionarySource.h\"\n+#include \"DictionaryStructure.h\"\n+\n+namespace Poco { class Logger; }\n+\n+\n+namespace DB\n+{\n+\n+using ProcessPool = BorrowedObjectPool<std::unique_ptr<ShellCommand>>;\n+\n+/** ExecutablePoolDictionarySource allows loading data from pool of processes.\n+  * When client requests ids or keys source get process from ProcessPool\n+  * and create stream based on source format from process stdout.\n+  * It is important that stream format will expect only rows that were requested.\n+  * When stream is finished process is returned back to the ProcessPool.\n+  * If there are no processes in pool during request client will be blocked\n+  * until some process will be retunred to pool.\n+  */\n+class ExecutablePoolDictionarySource final : public IDictionarySource\n+{\n+public:\n+    struct Configuration\n+    {\n+        const String command;\n+        const String format;\n+        const size_t pool_size;\n+        const String update_field;\n+        const bool implicit_key;\n+        const size_t command_termination_timeout;\n+        const size_t max_command_execution_time;\n+    };\n+\n+    ExecutablePoolDictionarySource(\n+        const DictionaryStructure & dict_struct_,\n+        const Configuration & configuration_,\n+        Block & sample_block_,\n+        const Context & context_);\n+\n+    ExecutablePoolDictionarySource(const ExecutablePoolDictionarySource & other);\n+    ExecutablePoolDictionarySource & operator=(const ExecutablePoolDictionarySource &) = delete;\n+\n+    BlockInputStreamPtr loadAll() override;\n+\n+    /** The logic of this method is flawed, absolutely incorrect and ignorant.\n+      * It may lead to skipping some values due to clock sync or timezone changes.\n+      * The intended usage of \"update_field\" is totally different.\n+      */\n+    BlockInputStreamPtr loadUpdatedAll() override;\n+\n+    BlockInputStreamPtr loadIds(const std::vector<UInt64> & ids) override;\n+\n+    BlockInputStreamPtr loadKeys(const Columns & key_columns, const std::vector<size_t> & requested_rows) override;\n+\n+    bool isModified() const override;\n+\n+    bool supportsSelectiveLoad() const override;\n+\n+    bool hasUpdateField() const override;\n+\n+    DictionarySourcePtr clone() const override;\n+\n+    std::string toString() const override;\n+\n+    BlockInputStreamPtr getStreamForBlock(const Block & block);\n+\n+private:\n+    Poco::Logger * log;\n+    time_t update_time = 0;\n+    const DictionaryStructure dict_struct;\n+    const Configuration configuration;\n+\n+    Block sample_block;\n+    Context context;\n+    std::shared_ptr<ProcessPool> process_pool;\n+};\n+\n+}\ndiff --git a/src/Dictionaries/registerDictionaries.cpp b/src/Dictionaries/registerDictionaries.cpp\nindex abcc0ce06ad5..13048e0099ac 100644\n--- a/src/Dictionaries/registerDictionaries.cpp\n+++ b/src/Dictionaries/registerDictionaries.cpp\n@@ -18,6 +18,7 @@ void registerDictionarySourceJDBC(DictionarySourceFactory & source_factory);\n void registerDictionarySourcePostgreSQL(DictionarySourceFactory & source_factory);\n #endif\n void registerDictionarySourceExecutable(DictionarySourceFactory & source_factory);\n+void registerDictionarySourceExecutablePool(DictionarySourceFactory & source_factory);\n void registerDictionarySourceHTTP(DictionarySourceFactory & source_factory);\n void registerDictionarySourceLibrary(DictionarySourceFactory & source_factory);\n \n@@ -54,6 +55,7 @@ void registerDictionaries()\n         registerDictionarySourcePostgreSQL(source_factory);\n #endif\n         registerDictionarySourceExecutable(source_factory);\n+        registerDictionarySourceExecutablePool(source_factory);\n         registerDictionarySourceHTTP(source_factory);\n         registerDictionarySourceLibrary(source_factory);\n     }\ndiff --git a/src/Dictionaries/ya.make b/src/Dictionaries/ya.make\nindex 4f33dc805591..6701be64f0c2 100644\n--- a/src/Dictionaries/ya.make\n+++ b/src/Dictionaries/ya.make\n@@ -42,6 +42,7 @@ SRCS(\n     Embedded/RegionsHierarchy.cpp\n     Embedded/RegionsNames.cpp\n     ExecutableDictionarySource.cpp\n+    ExecutablePoolDictionarySource.cpp\n     ExternalQueryBuilder.cpp\n     FileDictionarySource.cpp\n     FlatDictionary.cpp\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex ac59775a7552..6e7aff2ceba6 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -361,6 +361,13 @@ class FunctionDictGetNoType final : public IFunction\n             /// Functions in external dictionaries_loader only support full-value (not constant) columns with keys.\n             ColumnPtr key_column_full = key_col_with_type.column->convertToFullColumnIfConst();\n \n+            if (!isTuple(key_col_with_type.type))\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Third argument of function ({}) must be tuple when dictionary is complex. Actual type ({}).\",\n+                    getName(),\n+                    key_col_with_type.type->getName());\n+\n             const auto & key_columns = typeid_cast<const ColumnTuple &>(*key_column_full).getColumnsCopy();\n             const auto & key_types = static_cast<const DataTypeTuple &>(*key_col_with_type.type).getElements();\n \n",
  "test_patch": "diff --git a/tests/clickhouse-test-server b/tests/clickhouse-test-server\nindex a6b6bd86dfae..4087468b597c 100755\n--- a/tests/clickhouse-test-server\n+++ b/tests/clickhouse-test-server\n@@ -60,6 +60,7 @@ if [ \"$DATA_DIR_PATTERN\" != \"$DATA_DIR\" ]; then\n     cat ${CONFIG_SERVER_DIR}/ints_dictionary.xml | sed -e s!9000!$CLICKHOUSE_PORT_TCP! > $DATA_DIR/etc/ints_dictionary.xml\n     cat ${CONFIG_SERVER_DIR}/strings_dictionary.xml | sed -e s!9000!$CLICKHOUSE_PORT_TCP! > $DATA_DIR/etc/strings_dictionary.xml\n     cat ${CONFIG_SERVER_DIR}/decimals_dictionary.xml | sed -e s!9000!$CLICKHOUSE_PORT_TCP! > $DATA_DIR/etc/decimals_dictionary.xml\n+    cat ${CONFIG_SERVER_DIR}/executable_pool_dictionary.xml | sed -e s!9000!$CLICKHOUSE_PORT_TCP! > $DATA_DIR/etc/executable_pool_dictionary.xml\n fi\n \n CLICKHOUSE_EXTRACT_CONFIG=${CLICKHOUSE_EXTRACT_CONFIG:=\"${CLICKHOUSE_EXTRACT} --config=$CLICKHOUSE_CONFIG\"}\ndiff --git a/tests/config/executable_pool_dictionary.xml b/tests/config/executable_pool_dictionary.xml\nnew file mode 100644\nindex 000000000000..13f34f0048ee\n--- /dev/null\n+++ b/tests/config/executable_pool_dictionary.xml\n@@ -0,0 +1,154 @@\n+<dictionaries>\n+\n+<dictionary>\n+    <name>executable_pool_simple</name>\n+\n+    <structure>\n+        <id>\n+            <name>x</name>\n+        </id>\n+        <attribute>\n+            <name>a</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+        <attribute>\n+            <name>b</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable_pool>\n+            <format>TabSeparated</format>\n+            <command>while read read_data; do printf \"$read_data\\t$read_data a\\t$read_data b\\n\"; done</command>\n+            <size>5</size>\n+        </executable_pool>\n+    </source>\n+\n+    <layout>\n+        <direct />\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+<dictionary>\n+    <name>executable_pool_complex</name>\n+\n+    <structure>\n+        <key>\n+            <attribute>\n+                <name>x</name>\n+                <type>String</type>\n+            </attribute>\n+            <attribute>\n+                <name>y</name>\n+                <type>String</type>\n+            </attribute>\n+        </key>\n+        <attribute>\n+            <name>a</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+        <attribute>\n+            <name>b</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable>\n+            <format>TabSeparated</format>\n+            <command>while read read_data; do printf \"$read_data\\tvalue a\\tvalue b\\n\"; done</command>\n+        </executable>\n+    </source>\n+\n+    <layout>\n+        <complex_key_direct />\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+<dictionary>\n+    <name>executable_pool_simple_implicit_key</name>\n+\n+    <structure>\n+        <id>\n+            <name>x</name>\n+        </id>\n+        <attribute>\n+            <name>a</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+        <attribute>\n+            <name>b</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable_pool>\n+            <format>TabSeparated</format>\n+            <command>while read read_data; do printf \"$read_data a\\t$read_data b\\n\"; done</command>\n+            <size>5</size>\n+            <implicit_key>true</implicit_key>\n+        </executable_pool>\n+    </source>\n+\n+    <layout>\n+        <direct />\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+<dictionary>\n+    <name>executable_pool_complex_implicit_key</name>\n+\n+    <structure>\n+        <key>\n+            <attribute>\n+                <name>x</name>\n+                <type>String</type>\n+            </attribute>\n+            <attribute>\n+                <name>y</name>\n+                <type>String</type>\n+            </attribute>\n+        </key>\n+        <attribute>\n+            <name>a</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+        <attribute>\n+            <name>b</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable_pool>\n+            <format>TabSeparated</format>\n+            <command>while read read_data; do printf \"data a\\tdata b\\n\"; done</command>\n+            <size>5</size>\n+            <implicit_key>true</implicit_key>\n+        </executable_pool>\n+    </source>\n+\n+    <layout>\n+        <complex_key_direct />\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+</dictionaries>\ndiff --git a/tests/config/install.sh b/tests/config/install.sh\nindex de6ba2a7a091..17859d37c5ff 100755\n--- a/tests/config/install.sh\n+++ b/tests/config/install.sh\n@@ -44,6 +44,7 @@ ln -sf $SRC_PATH/ints_dictionary.xml $DEST_SERVER_PATH/\n ln -sf $SRC_PATH/strings_dictionary.xml $DEST_SERVER_PATH/\n ln -sf $SRC_PATH/decimals_dictionary.xml $DEST_SERVER_PATH/\n ln -sf $SRC_PATH/executable_dictionary.xml $DEST_SERVER_PATH/\n+ln -sf $SRC_PATH/executable_pool_dictionary.xml $DEST_SERVER_PATH/\n \n ln -sf $SRC_PATH/top_level_domains $DEST_SERVER_PATH/\n \ndiff --git a/tests/queries/0_stateless/01746_executable_pool_dictionary.reference b/tests/queries/0_stateless/01746_executable_pool_dictionary.reference\nnew file mode 100644\nindex 000000000000..cf79a75e3f15\n--- /dev/null\n+++ b/tests/queries/0_stateless/01746_executable_pool_dictionary.reference\n@@ -0,0 +1,10 @@\n+executable_pool_simple\n+1 a\n+1 b\n+2 a\n+2 b\n+executable_pool_complex\n+value a\n+value b\n+value a\n+value b\ndiff --git a/tests/queries/0_stateless/01746_executable_pool_dictionary.sql b/tests/queries/0_stateless/01746_executable_pool_dictionary.sql\nnew file mode 100644\nindex 000000000000..aa59d209b510\n--- /dev/null\n+++ b/tests/queries/0_stateless/01746_executable_pool_dictionary.sql\n@@ -0,0 +1,15 @@\n+SELECT 'executable_pool_simple';\n+\n+SELECT dictGet('executable_pool_simple', 'a', toUInt64(1));\n+SELECT dictGet('executable_pool_simple', 'b', toUInt64(1));\n+\n+SELECT dictGet('executable_pool_simple', 'a', toUInt64(2));\n+SELECT dictGet('executable_pool_simple', 'b', toUInt64(2));\n+\n+SELECT 'executable_pool_complex';\n+\n+SELECT dictGet('executable_pool_complex', 'a', ('First_1', 'Second_1'));\n+SELECT dictGet('executable_pool_complex', 'b', ('First_1', 'Second_1'));\n+\n+SELECT dictGet('executable_pool_complex', 'a', ('First_2', 'Second_2'));\n+SELECT dictGet('executable_pool_complex', 'b', ('First_2', 'Second_2'));\ndiff --git a/tests/queries/0_stateless/01747_executable_pool_dictionary_implicit_key.reference b/tests/queries/0_stateless/01747_executable_pool_dictionary_implicit_key.reference\nnew file mode 100644\nindex 000000000000..ab44ba51330c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01747_executable_pool_dictionary_implicit_key.reference\n@@ -0,0 +1,10 @@\n+executable_pool_simple_implicit_key\n+1 a\n+1 b\n+2 a\n+2 b\n+executable_pool_complex_implicit_key\n+data a\n+data b\n+data a\n+data b\ndiff --git a/tests/queries/0_stateless/01747_executable_pool_dictionary_implicit_key.sql b/tests/queries/0_stateless/01747_executable_pool_dictionary_implicit_key.sql\nnew file mode 100644\nindex 000000000000..6c6d33c7d43a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01747_executable_pool_dictionary_implicit_key.sql\n@@ -0,0 +1,15 @@\n+SELECT 'executable_pool_simple_implicit_key';\n+\n+SELECT dictGet('executable_pool_simple_implicit_key', 'a', toUInt64(1));\n+SELECT dictGet('executable_pool_simple_implicit_key', 'b', toUInt64(1));\n+\n+SELECT dictGet('executable_pool_simple_implicit_key', 'a', toUInt64(2));\n+SELECT dictGet('executable_pool_simple_implicit_key', 'b', toUInt64(2));\n+\n+SELECT 'executable_pool_complex_implicit_key';\n+\n+SELECT dictGet('executable_pool_complex_implicit_key', 'a', ('First_1', 'Second_1'));\n+SELECT dictGet('executable_pool_complex_implicit_key', 'b', ('First_1', 'Second_1'));\n+\n+SELECT dictGet('executable_pool_complex_implicit_key', 'a', ('First_2', 'Second_2'));\n+SELECT dictGet('executable_pool_complex_implicit_key', 'b', ('First_2', 'Second_2'));\n",
  "problem_statement": "Variant of executable dictionary source with pool of processes.\nExecutable dictionary runs a program (spawns a child process) for every block to process (typically 65536 rows), pipes data to its stdin, reads data from stdout. Program can work in streaming fashion, so it can read and write simultanously (it does not have to buffer any data).\r\n\r\nThe drawback is that we spawn and wait for child process to exit for every processed block of data.\r\nIt is not efficient if the child process takes long time to initialize.\r\n\r\nWe can make another dictionary source (let's name it `executable_pool`) that will spawn up to N child processes (the pool size) and keep them running until they exit. The program should read data from stdin while it is available and output result to stdout, and it can wait for next block of data on stdin. We will not close stdin after processing a block of data but will pipe another chunk of data when we will need it.\r\n\r\nThe program should be ready for this way of data processing - it should poll stdin and flush data to stdout early (when more data in stdin is not available at this moment).\r\n\r\nAdditional uses:\r\n- this mechanism will be used to reimplement `library` dictionary source;\r\n- this mechanism will be used to implement simple UDFs;\n",
  "hints_text": "Reminds CGI vs FastCGI.",
  "created_at": "2021-02-28T21:05:45Z"
}