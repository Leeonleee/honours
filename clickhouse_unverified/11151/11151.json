{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11151,
  "instance_id": "ClickHouse__ClickHouse-11151",
  "issue_numbers": [
    "7224"
  ],
  "base_commit": "a2ed8267add1cfc28fa2ca17f7227a816921e7d7",
  "patch": "diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex aa7affda2433..a75339a644d3 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -8,6 +8,9 @@\n     M(Query, \"Number of queries to be interpreted and potentially executed. Does not include queries that failed to parse or were rejected due to AST size limits, quota limits or limits on the number of simultaneously running queries. May include internal queries initiated by ClickHouse itself. Does not count subqueries.\") \\\n     M(SelectQuery, \"Same as Query, but only for SELECT queries.\") \\\n     M(InsertQuery, \"Same as Query, but only for INSERT queries.\") \\\n+    M(FailedQuery, \"Number of failed queries.\") \\\n+    M(FailedSelectQuery, \"Same as FailedQuery, but only for SELECT queries.\") \\\n+    M(FailedInsertQuery, \"Same as FailedQuery, but only for INSERT queries.\") \\\n     M(FileOpen, \"Number of files opened.\") \\\n     M(Seek, \"Number of times the 'lseek' function was called.\") \\\n     M(ReadBufferFromFileDescriptorRead, \"Number of reads (read/pread) from a file descriptor. Does not include sockets.\") \\\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 4d609395c3ad..fe02f3886b89 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -15,6 +15,7 @@\n #include <DataStreams/CountingBlockOutputStream.h>\n \n #include <Parsers/ASTInsertQuery.h>\n+#include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTShowProcesslistQuery.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n@@ -45,6 +46,9 @@\n namespace ProfileEvents\n {\n     extern const Event QueryMaskingRulesMatch;\n+    extern const Event FailedQuery;\n+    extern const Event FailedInsertQuery;\n+    extern const Event FailedSelectQuery;\n }\n \n namespace DB\n@@ -146,7 +150,7 @@ static void logException(Context & context, QueryLogElement & elem)\n }\n \n \n-static void onExceptionBeforeStart(const String & query_for_logging, Context & context, time_t current_time)\n+static void onExceptionBeforeStart(const String & query_for_logging, Context & context, time_t current_time, ASTPtr ast)\n {\n     /// Exception before the query execution.\n     if (auto quota = context.getQuota())\n@@ -178,6 +182,20 @@ static void onExceptionBeforeStart(const String & query_for_logging, Context & c\n     if (settings.log_queries && elem.type >= settings.log_queries_min_type)\n         if (auto query_log = context.getQueryLog())\n             query_log->add(elem);\n+\n+    ProfileEvents::increment(ProfileEvents::FailedQuery);\n+\n+    if (ast)\n+    {\n+        if (ast->as<ASTSelectQuery>() || ast->as<ASTSelectWithUnionQuery>())\n+        {\n+            ProfileEvents::increment(ProfileEvents::FailedSelectQuery);\n+        }\n+        else if (ast->as<ASTInsertQuery>())\n+        {\n+            ProfileEvents::increment(ProfileEvents::FailedInsertQuery);\n+        }\n+    }\n }\n \n static void setQuerySpecificSettings(ASTPtr & ast, Context & context)\n@@ -249,7 +267,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         logQuery(query_for_logging, context, internal);\n \n         if (!internal)\n-            onExceptionBeforeStart(query_for_logging, context, current_time);\n+            onExceptionBeforeStart(query_for_logging, context, current_time, ast);\n \n         throw;\n     }\n@@ -501,7 +519,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 }\n             };\n \n-            auto exception_callback = [elem, &context, log_queries, log_queries_min_type = settings.log_queries_min_type, quota(quota)] () mutable\n+            auto exception_callback = [elem, &context, ast, log_queries, log_queries_min_type = settings.log_queries_min_type, quota(quota)] () mutable\n             {\n                 if (quota)\n                     quota->used(Quota::ERRORS, 1, /* check_exceeded = */ false);\n@@ -544,6 +562,17 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     if (auto query_log = context.getQueryLog())\n                         query_log->add(elem);\n                 }\n+\n+                ProfileEvents::increment(ProfileEvents::FailedQuery);\n+                if (ast->as<ASTSelectQuery>() || ast->as<ASTSelectWithUnionQuery>())\n+                {\n+                    ProfileEvents::increment(ProfileEvents::FailedSelectQuery);\n+                }\n+                else if (ast->as<ASTInsertQuery>())\n+                {\n+                    ProfileEvents::increment(ProfileEvents::FailedInsertQuery);\n+                }\n+\n             };\n \n             res.finish_callback = std::move(finish_callback);\n@@ -565,7 +594,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             if (query_for_logging.empty())\n                 query_for_logging = prepareQueryForLogging(query, context);\n \n-            onExceptionBeforeStart(query_for_logging, context, current_time);\n+            onExceptionBeforeStart(query_for_logging, context, current_time, ast);\n         }\n \n         throw;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01281_failed_insert_select_queries_couner.reference b/tests/queries/0_stateless/01281_failed_insert_select_queries_couner.reference\nnew file mode 100644\nindex 000000000000..099b7d91c923\n--- /dev/null\n+++ b/tests/queries/0_stateless/01281_failed_insert_select_queries_couner.reference\n@@ -0,0 +1,4 @@\n+1\n+2\n+1\n+2\ndiff --git a/tests/queries/0_stateless/01281_failed_insert_select_queries_couner.sql b/tests/queries/0_stateless/01281_failed_insert_select_queries_couner.sql\nnew file mode 100644\nindex 000000000000..f5efb2b56d57\n--- /dev/null\n+++ b/tests/queries/0_stateless/01281_failed_insert_select_queries_couner.sql\n@@ -0,0 +1,66 @@\n+DROP TABLE IF EXISTS current_failed_query_metrics;\n+DROP TABLE IF EXISTS to_insert;\n+\n+CREATE TABLE current_failed_query_metrics (event LowCardinality(String), value UInt64) ENGINE = Memory();\n+\n+\n+INSERT INTO current_failed_query_metrics \n+SELECT event, value\n+FROM system.events\n+WHERE event in ('FailedQuery', 'FailedInsertQuery', 'FailedSelectQuery');\n+\n+CREATE TABLE to_insert (value UInt64) ENGINE = Memory();\n+\n+-- Failed insert before execution\n+INSERT INTO table_that_do_not_exists VALUES (42); -- { serverError 60 }\n+\n+SELECT current_value - previous_value\n+FROM (\n+    SELECT event, value as current_value FROM system.events WHERE event like 'FailedInsertQuery'\n+) AS previous\n+ALL LEFT JOIN (\n+    SELECT event, value as previous_value FROM current_failed_query_metrics\n+) AS current\n+on previous.event = current.event;\n+\n+\n+-- Failed insert in execution\n+INSERT INTO to_insert SELECT throwIf(1); -- { serverError 395 }\n+\n+SELECT current_value - previous_value\n+FROM (\n+    SELECT event, value as current_value FROM system.events WHERE event like 'FailedInsertQuery'\n+) AS previous\n+ALL LEFT JOIN (\n+    SELECT event, value as previous_value FROM current_failed_query_metrics\n+) AS current\n+on previous.event = current.event;\n+\n+\n+-- Failed select before execution\n+SELECT * FROM table_that_do_not_exists; -- { serverError 60 }\n+\n+SELECT current_value - previous_value\n+FROM (\n+    SELECT event, value as current_value FROM system.events WHERE event like 'FailedSelectQuery'\n+) AS previous\n+ALL LEFT  JOIN (\n+    SELECT event, value as previous_value FROM current_failed_query_metrics\n+) AS current\n+on previous.event = current.event;\n+\n+-- Failed select in execution\n+SELECT throwIf(1); -- { serverError 395 }\n+\n+SELECT current_value - previous_value\n+FROM (\n+    SELECT event, value as current_value FROM system.events WHERE event like 'FailedSelectQuery'\n+) AS previous\n+ALL LEFT JOIN (\n+    SELECT event, value as previous_value FROM current_failed_query_metrics\n+) AS current\n+on previous.event = current.event;\n+\n+\n+DROP TABLE current_failed_query_metrics;\n+DROP TABLE to_insert;\n",
  "problem_statement": "Add a metric to monitor bad requests (INSERT, SELECT, etc.)\n**Use case**\r\nWe have a service which inserts data. Once our devops accidentally checked the logs of CH and found this service was making wrong INSERT requests for a week. That's was because of a wrong migration script which didn't update a table field correctly, so we were consistently getting an error like this:\r\n```\r\n2019.10.02 10:48:24.410700 [ 53 ] {18b9d57a-0d07-4cfe-9b86-c2d2b931be2b} <Debug> executeQuery: (from 10.0.0.1:51588) INSERT INTO stats.events FORMAT JSONEachRow \r\n2019.10.02 10:48:24.411091 [ 53 ] {18b9d57a-0d07-4cfe-9b86-c2d2b931be2b} <Debug> executeQuery: Query pipeline:\r\nNullAndDoCopy\r\n InputStreamFromASTInsertQuery\r\n2019.10.02 10:48:24.411413 [ 53 ] {18b9d57a-0d07-4cfe-9b86-c2d2b931be2b} <Error> executeQuery: Code: 117, e.displayText() = DB::Exception: Unknown field found while parsing JSONEachRow format: version: (at row 1)\r\n (version 19.13.1.11 (official build)) (from 10.0.0.1:51588) (in query: INSERT INTO stats.events FORMAT JSONEachRow ), Stack trace:\r\n0. /usr/bin/clickhouse-server(StackTrace::StackTrace()+0x30) [0x7f58f30]\r\n1. /usr/bin/clickhouse-server(DB::Exception::Exception(std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&, int)+0x25) [0x3c427b5]\r\n2. /usr/bin/clickhouse-server() [0x39ea700]\r\n3. /usr/bin/clickhouse-server(DB::JSONEachRowRowInputStream::readJSONObject(std::vector<COW<DB::IColumn>::mutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::mutable_ptr<DB::IColumn> > >&)+0xe65) [0x7141805]\r\n4. /usr/bin/clickhouse-server(DB::JSONEachRowRowInputStream::read(std::vector<COW<DB::IColumn>::mutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::mutable_ptr<DB::IColumn> > >&, DB::RowReadExtension&)+0x10a) [0x7141bea]\r\n5. /usr/bin/clickhouse-server(DB::BlockInputStreamFromRowInputStream::readImpl()+0x170) [0x757d1c0]\r\n6. /usr/bin/clickhouse-server(DB::IBlockInputStream::read()+0x187) [0x6c04667]\r\n7. /usr/bin/clickhouse-server(DB::InputStreamFromASTInsertQuery::readImpl()+0x28) [0x6e899f8]\r\n8. /usr/bin/clickhouse-server(DB::IBlockInputStream::read()+0x187) [0x6c04667]\r\n9. /usr/bin/clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x6b) [0x6c1c9db]\r\n10. /usr/bin/clickhouse-server(DB::NullAndDoCopyBlockInputStream::readImpl()+0x25) [0x6d437c5]\r\n11. /usr/bin/clickhouse-server(DB::IBlockInputStream::read()+0x187) [0x6c04667]\r\n12. /usr/bin/clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x6b) [0x6c1c9db]\r\n13. /usr/bin/clickhouse-server(DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>, std::function<void (std::__cxx11::basic_string<char, std::char_traits<char>, std::allocator<char> > const&)>)+0x6a7) [0x6e88dd7]\r\n14. /usr/bin/clickhouse-server(DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&)+0x1a5e) [0x3c8fc3e]\r\n15. /usr/bin/clickhouse-server(DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&)+0x45a) [0x3c91fba]\r\n16. /usr/bin/clickhouse-server(Poco::Net::HTTPServerConnection::run()+0x2a9) [0x7932009]\r\n17. /usr/bin/clickhouse-server(Poco::Net::TCPServerConnection::start()+0x10) [0x792cde0]\r\n18. /usr/bin/clickhouse-server(Poco::Net::TCPServerDispatcher::run()+0xed) [0x792d4fd]\r\n19. /usr/bin/clickhouse-server(Poco::PooledThread::run()+0x81) [0x8057e21]\r\n20. /usr/bin/clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x3c) [0x8055bcc]\r\n21. /usr/bin/clickhouse-server() [0xba2baa0]\r\n22. /lib/x86_64-linux-gnu/libpthread.so.0(+0x76db) [0x7f4f81ad76db]\r\n```\r\n\r\nAs service was in alpha stage, it was not well-tested by our QAs. We are using https://github.com/f1yegor/clickhouse_exporter with alerts on several metrics. Of course we didn't notice this bug, because CH doesn't have any related metric.\r\n\r\n**Describe the solution you'd like**\r\nAdd a new row into `system.events`, like `FailedInserts`. CH already has `DelayedInserts` and `RejectedInserts`.\r\nOr maybe even more generic metric, like `FailedRequests`, because I can predict we can have issues with wrong SELECT requests to CH due to bad data sanitization.\r\n\r\n**Describe alternatives you've considered**\r\nWe currently see 2 alternatives, but they will be more complex to implement:\r\n- Monitor CH logs and try to match for exceptions\r\n- Make a service that sends INSERT requests to send error metrics\n",
  "hints_text": "JFYI: Another alternative is using `system.query_log` table to get various information about failed (`type=3 or type=4`) queries without parsing server logs for exceptions.\n@tavplubix  Again, not so easy to use and maintain:\r\n- need to enable it first\r\n- need to deal with clearing old data (`The storage period for logs is unlimited. Logs aren't automatically deleted from the table. You need to organize the removal of outdated logs yourself.`)\r\n- need to integrate with https://github.com/f1yegor/clickhouse_exporter\r\n\r\nBut anyway, thanks for suggestion.\nWe can add two ProfileEvents: FailedSelectQuery, FailedInsertQuery. This is very easy task.",
  "created_at": "2020-05-22T23:11:46Z"
}