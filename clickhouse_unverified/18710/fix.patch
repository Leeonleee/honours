diff --git a/src/AggregateFunctions/AggregateFunctionSumMap.cpp b/src/AggregateFunctions/AggregateFunctionSumMap.cpp
index ebae17a8a07d..2d4e6dfaf32e 100644
--- a/src/AggregateFunctions/AggregateFunctionSumMap.cpp
+++ b/src/AggregateFunctions/AggregateFunctionSumMap.cpp
@@ -66,8 +66,7 @@ auto parseArguments(const std::string & name, const DataTypes & arguments)
         values_types.push_back(array_type->getNestedType());
     }
 
-    return  std::tuple{std::move(keys_type), std::move(values_types),
-                tuple_argument};
+    return std::tuple{std::move(keys_type), std::move(values_types), tuple_argument};
 }
 
 // This function instantiates a particular overload of the sumMap family of
diff --git a/src/AggregateFunctions/AggregateFunctionSumMap.h b/src/AggregateFunctions/AggregateFunctionSumMap.h
index c991474d0e65..6c8155f967ca 100644
--- a/src/AggregateFunctions/AggregateFunctionSumMap.h
+++ b/src/AggregateFunctions/AggregateFunctionSumMap.h
@@ -54,6 +54,8 @@ struct AggregateFunctionMapData
   *  ([1,2,3,4,5,6,7,8,9,10],[10,10,45,20,35,20,15,30,20,20])
   *
   * minMap and maxMap share the same idea, but calculate min and max correspondingly.
+  *
+  * NOTE: The implementation of these functions are "amateur grade" - not efficient and low quality.
   */
 
 template <typename T, typename Derived, typename Visitor, bool overflow, bool tuple_argument, bool compact>
@@ -72,7 +74,8 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
             const DataTypes & values_types_, const DataTypes & argument_types_)
         : Base(argument_types_, {} /* parameters */), keys_type(keys_type_),
           values_types(values_types_)
-    {}
+    {
+    }
 
     DataTypePtr getReturnType() const override
     {
@@ -81,13 +84,26 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
 
         for (const auto & value_type : values_types)
         {
+            if constexpr (std::is_same_v<Visitor, FieldVisitorSum>)
+            {
+                if (!value_type->isSummable())
+                    throw Exception{ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Values for {} cannot be summed, passed type {}",
+                        getName(), value_type->getName()};
+            }
+
             DataTypePtr result_type;
 
             if constexpr (overflow)
             {
+                if (value_type->onlyNull())
+                    throw Exception{ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                        "Cannot calculate {} of type {}",
+                        getName(), value_type->getName()};
+
                 // Overflow, meaning that the returned type is the same as
-                // the input type.
-                result_type = value_type;
+                // the input type. Nulls are skipped.
+                result_type = removeNullable(value_type);
             }
             else
             {
@@ -120,9 +136,9 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
         }
     }
 
-    void add(AggregateDataPtr place, const IColumn** _columns, const size_t row_num, Arena *) const override
+    void add(AggregateDataPtr place, const IColumn ** columns_, const size_t row_num, Arena *) const override
     {
-        const auto & columns = getArgumentColumns(_columns);
+        const auto & columns = getArgumentColumns(columns_);
 
         // Column 0 contains array of keys of known type
         const ColumnArray & array_column0 = assert_cast<const ColumnArray &>(*columns[0]);
@@ -148,16 +164,13 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
             // Insert column values for all keys
             for (size_t i = 0; i < keys_vec_size; ++i)
             {
-                auto value = value_column.operator[](values_vec_offset + i);
-                auto key = key_column.operator[](keys_vec_offset + i).get<T>();
+                auto value = value_column[values_vec_offset + i];
+                auto key = key_column[keys_vec_offset + i].get<T>();
 
                 if (!keepKey(key))
                     continue;
 
-                if (value.isNull())
-                    continue;
-
-                typename std::decay_t<decltype(merged_maps)>::iterator it;
+                decltype(merged_maps.begin()) it;
                 if constexpr (IsDecimalNumber<T>)
                 {
                     // FIXME why is storing NearestFieldType not enough, and we
@@ -170,17 +183,20 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
 
                 if (it != merged_maps.end())
                 {
-                    applyVisitor(Visitor(value), it->second[col]);
+                    if (!value.isNull())
+                    {
+                        if (it->second[col].isNull())
+                            it->second[col] = value;
+                        else
+                            applyVisitor(Visitor(value), it->second[col]);
+                    }
                 }
                 else
                 {
                     // Create a value array for this key
                     Array new_values;
-                    new_values.resize(values_types.size());
-                    for (size_t k = 0; k < new_values.size(); ++k)
-                    {
-                        new_values[k] = (k == col) ? value : values_types[k]->getDefault();
-                    }
+                    new_values.resize(size);
+                    new_values[col] = value;
 
                     if constexpr (IsDecimalNumber<T>)
                     {
@@ -207,7 +223,8 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
             if (it != merged_maps.end())
             {
                 for (size_t col = 0; col < values_types.size(); ++col)
-                    applyVisitor(Visitor(elem.second[col]), it->second[col]);
+                    if (!elem.second[col].isNull())
+                        applyVisitor(Visitor(elem.second[col]), it->second[col]);
             }
             else
                 merged_maps[elem.first] = elem.second;
@@ -253,6 +270,8 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
 
     void insertResultInto(AggregateDataPtr place, IColumn & to, Arena *) const override
     {
+        size_t num_columns = values_types.size();
+
         // Final step does compaction of keys that have zero values, this mutates the state
         auto & merged_maps = this->data(place).merged_maps;
 
@@ -263,9 +282,9 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
             {
                 // Key is not compacted if it has at least one non-zero value
                 bool erase = true;
-                for (size_t col = 0; col < values_types.size(); ++col)
+                for (size_t col = 0; col < num_columns; ++col)
                 {
-                    if (it->second[col] != values_types[col]->getDefault())
+                    if (!it->second[col].isNull() && it->second[col] != values_types[col]->getDefault())
                     {
                         erase = false;
                         break;
@@ -290,7 +309,7 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
         to_keys_offsets.push_back(to_keys_offsets.back() + size);
         to_keys_col.reserve(size);
 
-        for (size_t col = 0; col < values_types.size(); ++col)
+        for (size_t col = 0; col < num_columns; ++col)
         {
             auto & to_values_arr = assert_cast<ColumnArray &>(to_tuple.getColumn(col + 1));
             auto & to_values_offsets = to_values_arr.getOffsets();
@@ -305,10 +324,13 @@ class AggregateFunctionMapBase : public IAggregateFunctionDataHelper<
             to_keys_col.insert(elem.first);
 
             // Write 0..n arrays of values
-            for (size_t col = 0; col < values_types.size(); ++col)
+            for (size_t col = 0; col < num_columns; ++col)
             {
                 auto & to_values_col = assert_cast<ColumnArray &>(to_tuple.getColumn(col + 1)).getData();
-                to_values_col.insert(elem.second[col]);
+                if (elem.second[col].isNull())
+                    to_values_col.insertDefault();
+                else
+                    to_values_col.insert(elem.second[col]);
             }
         }
     }
