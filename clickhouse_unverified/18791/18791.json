{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 18791,
  "instance_id": "ClickHouse__ClickHouse-18791",
  "issue_numbers": [
    "18713"
  ],
  "base_commit": "1d6bfe8ad7b4ab90b0c3417d604c578215ddb8e5",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h\nindex 3acaa29de7ed..39ab846e61ef 100644\n--- a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h\n+++ b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h\n@@ -419,7 +419,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable\n         if (isSmall())\n             return small.find(x) != small.end();\n         else\n-            return rb->contains(x);\n+            return rb->contains(static_cast<Value>(x));\n     }\n \n     /**\n@@ -613,7 +613,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable\n     /**\n      * Replace value\n      */\n-    void rb_replace(const UInt32 * from_vals, const UInt32 * to_vals, size_t num)\n+    void rb_replace(const UInt64 * from_vals, const UInt64 * to_vals, size_t num)\n     {\n         if (isSmall())\n             toLarge();\n@@ -622,9 +622,9 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable\n         {\n             if (from_vals[i] == to_vals[i])\n                 continue;\n-            bool changed = rb->removeChecked(from_vals[i]);\n+            bool changed = rb->removeChecked(static_cast<Value>(from_vals[i]));\n             if (changed)\n-                rb->add(to_vals[i]);\n+                rb->add(static_cast<Value>(to_vals[i]));\n         }\n     }\n };\ndiff --git a/src/Functions/FunctionsBitmap.h b/src/Functions/FunctionsBitmap.h\nindex 93da49066584..4d9621338f8e 100644\n--- a/src/Functions/FunctionsBitmap.h\n+++ b/src/Functions/FunctionsBitmap.h\n@@ -6,6 +6,7 @@\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnsNumber.h>\n+#include <Interpreters/castColumn.h>\n #include <DataTypes/DataTypeAggregateFunction.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypesNumber.h>\n@@ -14,6 +15,7 @@\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\n \n+\n // TODO include this last because of a broken roaring header. See the comment\n // inside.\n #include <AggregateFunctions/AggregateFunctionGroupBitmapData.h>\n@@ -282,18 +284,16 @@ class FunctionBitmapSubset : public IFunction\n                 \"First argument for function \" + getName() + \" must be a bitmap but it has type \" + arguments[0]->getName() + \".\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n-        const auto * arg_type1 = typeid_cast<const DataTypeNumber<UInt32> *>(arguments[1].get());\n-        if (!(arg_type1))\n-            throw Exception(\n-                \"Second argument for function \" + getName() + \" must be UInt32 but it has type \" + arguments[1]->getName() + \".\",\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        const auto * arg_type2 = typeid_cast<const DataTypeNumber<UInt32> *>(arguments[1].get());\n-        if (!(arg_type2))\n-            throw Exception(\n-                \"Third argument for function \" + getName() + \" must be UInt32 but it has type \" + arguments[2]->getName() + \".\",\n-                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n+        for (size_t i = 1; i < 3; ++i)\n+        {\n+            WhichDataType which(arguments[i].get());\n+            if (!(which.isUInt8() || which.isUInt16() || which.isUInt32() || which.isUInt64()))\n+            {\n+                throw Exception(\n+                    \"The second and third arguments for function \" + getName() + \" must be one of [UInt8, UInt16, UInt32, UInt64] but one of them has type \" + arguments[1]->getName() + \".\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            }\n+        }\n         return arguments[0];\n     }\n \n@@ -327,13 +327,23 @@ class FunctionBitmapSubset : public IFunction\n         bool is_column_const[3];\n         const ColumnAggregateFunction * col_agg_func;\n         const PaddedPODArray<AggregateDataPtr> * container0;\n-        const PaddedPODArray<UInt32> * container1, * container2;\n+        const PaddedPODArray<UInt64> * container1, * container2;\n \n+        ColumnPtr column_holder[2];\n         for (size_t i = 0; i < 3; ++i)\n         {\n-            column_ptrs[i] = arguments[i].column.get();\n+            if (i > 0)\n+            {\n+                column_holder[i - 1] = castColumn(arguments[i], std::make_shared<DataTypeUInt64>());\n+                column_ptrs[i] = column_holder[i-1].get();\n+            }\n+            else\n+            {\n+                column_ptrs[i] = arguments[i].column.get();\n+            }\n             is_column_const[i] = isColumnConst(*column_ptrs[i]);\n         }\n+\n         if (is_column_const[0])\n             col_agg_func = typeid_cast<const ColumnAggregateFunction*>(typeid_cast<const ColumnConst*>(column_ptrs[0])->getDataColumnPtr().get());\n         else\n@@ -341,13 +351,13 @@ class FunctionBitmapSubset : public IFunction\n \n         container0 = &col_agg_func->getData();\n         if (is_column_const[1])\n-            container1 = &typeid_cast<const ColumnUInt32*>(typeid_cast<const ColumnConst*>(column_ptrs[1])->getDataColumnPtr().get())->getData();\n+            container1 = &typeid_cast<const ColumnUInt64*>(typeid_cast<const ColumnConst*>(column_ptrs[1])->getDataColumnPtr().get())->getData();\n         else\n-            container1 = &typeid_cast<const ColumnUInt32*>(column_ptrs[1])->getData();\n+            container1 = &typeid_cast<const ColumnUInt64*>(column_ptrs[1])->getData();\n         if (is_column_const[2])\n-            container2 = &typeid_cast<const ColumnUInt32*>(typeid_cast<const ColumnConst*>(column_ptrs[2])->getDataColumnPtr().get())->getData();\n+            container2 = &typeid_cast<const ColumnUInt64*>(typeid_cast<const ColumnConst*>(column_ptrs[2])->getDataColumnPtr().get())->getData();\n         else\n-            container2 = &typeid_cast<const ColumnUInt32*>(column_ptrs[2])->getData();\n+            container2 = &typeid_cast<const ColumnUInt64*>(column_ptrs[2])->getData();\n \n         auto col_to = ColumnAggregateFunction::create(col_agg_func->getAggregateFunction());\n         col_to->reserve(input_rows_count);\n@@ -357,8 +367,8 @@ class FunctionBitmapSubset : public IFunction\n             const AggregateDataPtr data_ptr_0 = is_column_const[0] ? (*container0)[0] : (*container0)[i];\n             const AggregateFunctionGroupBitmapData<T> & bitmap_data_0\n                 = *reinterpret_cast<const AggregateFunctionGroupBitmapData<T>*>(data_ptr_0);\n-            const UInt32 range_start = is_column_const[1] ? (*container1)[0] : (*container1)[i];\n-            const UInt32 range_end = is_column_const[2] ? (*container2)[0] : (*container2)[i];\n+            const UInt64 range_start = is_column_const[1] ? (*container1)[0] : (*container1)[i];\n+            const UInt64 range_end = is_column_const[2] ? (*container2)[0] : (*container2)[i];\n \n             col_to->insertDefault();\n             AggregateFunctionGroupBitmapData<T> & bitmap_data_2\n@@ -374,7 +384,7 @@ struct BitmapSubsetInRangeImpl\n public:\n     static constexpr auto name = \"bitmapSubsetInRange\";\n     template <typename T>\n-    static void apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_0, UInt32 range_start, UInt32 range_end, AggregateFunctionGroupBitmapData<T> & bitmap_data_2)\n+    static void apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_0, UInt64 range_start, UInt64 range_end, AggregateFunctionGroupBitmapData<T> & bitmap_data_2)\n     {\n         bitmap_data_0.rbs.rb_range(range_start, range_end, bitmap_data_2.rbs);\n     }\n@@ -385,7 +395,7 @@ struct BitmapSubsetLimitImpl\n public:\n     static constexpr auto name = \"bitmapSubsetLimit\";\n     template <typename T>\n-    static void apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_0, UInt32 range_start, UInt32 range_end, AggregateFunctionGroupBitmapData<T> & bitmap_data_2)\n+    static void apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_0, UInt64 range_start, UInt64 range_end, AggregateFunctionGroupBitmapData<T> & bitmap_data_2)\n     {\n         bitmap_data_0.rbs.rb_limit(range_start, range_end, bitmap_data_2.rbs);\n     }\n@@ -418,14 +428,14 @@ class FunctionBitmapTransform : public IFunction\n         for (size_t i = 0; i < 2; ++i)\n         {\n             const auto * array_type = typeid_cast<const DataTypeArray *>(arguments[i + 1].get());\n-            String msg(i == 0 ? \"Second\" : \"Third\");\n-            msg += \" argument for function \" + getName() + \" must be an UInt32 array but it has type \" + arguments[i + 1]->getName() + \".\";\n+            String msg = \"The second and third arguments for function \" + getName() + \" must be an one of [Array(UInt8), Array(UInt16), Array(UInt32), Array(UInt64)] but one of them has type \" + arguments[i + 1]->getName() + \".\";\n+\n             if (!array_type)\n                 throw Exception(msg, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n             auto nested_type = array_type->getNestedType();\n             WhichDataType which(nested_type);\n-            if (!which.isUInt32())\n+            if (!(which.isUInt8() || which.isUInt16() || which.isUInt32() || which.isUInt64()))\n                 throw Exception(msg, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         }\n         return arguments[0];\n@@ -461,13 +471,26 @@ class FunctionBitmapTransform : public IFunction\n         bool is_column_const[3];\n         const ColumnAggregateFunction * col_agg_func;\n         const PaddedPODArray<AggregateDataPtr> * container0;\n-        const ColumnArray * array;\n \n+        const ColumnArray * array1;\n+        const ColumnArray * array2;\n+\n+        ColumnPtr column_holder[2];\n         for (size_t i = 0; i < 3; ++i)\n         {\n-            column_ptrs[i] = arguments[i].column.get();\n+            if (i > 0)\n+            {\n+                auto array_type = std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+                column_holder[i - 1] = castColumn(arguments[i], array_type);\n+                column_ptrs[i] = column_holder[i-1].get();\n+            }\n+            else\n+            {\n+                column_ptrs[i] = arguments[i].column.get();\n+            }\n             is_column_const[i] = isColumnConst(*column_ptrs[i]);\n         }\n+\n         if (is_column_const[0])\n         {\n             col_agg_func = typeid_cast<const ColumnAggregateFunction*>(typeid_cast<const ColumnConst*>(column_ptrs[0])->getDataColumnPtr().get());\n@@ -479,21 +502,20 @@ class FunctionBitmapTransform : public IFunction\n         container0 = &col_agg_func->getData();\n \n         if (is_column_const[1])\n-            array = typeid_cast<const ColumnArray*>(typeid_cast<const ColumnConst*>(column_ptrs[1])->getDataColumnPtr().get());\n+            array1 = typeid_cast<const ColumnArray*>(typeid_cast<const ColumnConst*>(column_ptrs[1])->getDataColumnPtr().get());\n         else\n-        {\n-            array = typeid_cast<const ColumnArray *>(arguments[1].column.get());\n-        }\n-        const ColumnArray::Offsets & from_offsets = array->getOffsets();\n-        const ColumnVector<UInt32>::Container & from_container = typeid_cast<const ColumnVector<UInt32> *>(&array->getData())->getData();\n+            array1 = typeid_cast<const ColumnArray *>(column_ptrs[1]);\n+\n+        const ColumnArray::Offsets & from_offsets = array1->getOffsets();\n+        const ColumnVector<UInt64>::Container & from_container = typeid_cast<const ColumnVector<UInt64> *>(&array1->getData())->getData();\n \n         if (is_column_const[2])\n-            array = typeid_cast<const ColumnArray*>(typeid_cast<const ColumnConst*>(column_ptrs[2])->getDataColumnPtr().get());\n+            array2 = typeid_cast<const ColumnArray*>(typeid_cast<const ColumnConst*>(column_ptrs[2])->getDataColumnPtr().get());\n         else\n-            array = typeid_cast<const ColumnArray *>(arguments[2].column.get());\n+            array2 = typeid_cast<const ColumnArray *>(column_ptrs[2]);\n \n-        const ColumnArray::Offsets & to_offsets = array->getOffsets();\n-        const ColumnVector<UInt32>::Container & to_container = typeid_cast<const ColumnVector<UInt32> *>(&array->getData())->getData();\n+        const ColumnArray::Offsets & to_offsets = array2->getOffsets();\n+        const ColumnVector<UInt64>::Container & to_container = typeid_cast<const ColumnVector<UInt64> *>(&array2->getData())->getData();\n         auto col_to = ColumnAggregateFunction::create(col_agg_func->getAggregateFunction());\n         col_to->reserve(input_rows_count);\n \n@@ -526,6 +548,7 @@ class FunctionBitmapTransform : public IFunction\n                 to_start = i == 0 ? 0 : to_offsets[i - 1];\n                 to_end = to_offsets[i];\n             }\n+\n             if (from_end - from_start != to_end - to_start)\n                 throw Exception(\"From array size and to array size mismatch\", ErrorCodes::LOGICAL_ERROR);\n \n@@ -724,10 +747,11 @@ class FunctionBitmapContains : public IFunction\n             throw Exception(\n                 \"First argument for function \" + getName() + \" must be a bitmap but it has type \" + arguments[0]->getName() + \".\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        const auto * arg_type1 = typeid_cast<const DataTypeNumber<UInt32> *>(arguments[1].get());\n-        if (!(arg_type1))\n+\n+        WhichDataType which(arguments[1].get());\n+        if (!(which.isUInt8() || which.isUInt16() || which.isUInt32() || which.isUInt64()))\n             throw Exception(\n-                \"Second argument for function \" + getName() + \" must be UInt32 but it has type \" + arguments[1]->getName() + \".\",\n+                \"Second argument for function \" + getName() + \" must be one of [UInt8, UInt16, UInt32, UInt64] but it has type \" + arguments[1]->getName() + \".\",\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeNumber<UInt8>>();\n@@ -765,27 +789,32 @@ class FunctionBitmapContains : public IFunction\n     {\n         const IColumn * column_ptrs[2];\n         bool is_column_const[2];\n+\n         const PaddedPODArray<AggregateDataPtr> * container0;\n-        const PaddedPODArray<UInt32> * container1;\n+        const PaddedPODArray<UInt64> * container1;\n+\n+        column_ptrs[0] = arguments[0].column.get();\n+        is_column_const[0] = isColumnConst(*column_ptrs[0]);\n \n-        for (size_t i = 0; i < 2; ++i)\n-        {\n-            column_ptrs[i] = arguments[i].column.get();\n-            is_column_const[i] = isColumnConst(*column_ptrs[i]);\n-        }\n         if (is_column_const[0])\n             container0 = &typeid_cast<const ColumnAggregateFunction*>(typeid_cast<const ColumnConst*>(column_ptrs[0])->getDataColumnPtr().get())->getData();\n         else\n             container0 = &typeid_cast<const ColumnAggregateFunction*>(column_ptrs[0])->getData();\n+\n+        // we can always cast the second column to ColumnUInt64\n+        auto uint64_column = castColumn(arguments[1], std::make_shared<DataTypeUInt64>());\n+        column_ptrs[1] = uint64_column.get();\n+        is_column_const[1] = isColumnConst(*column_ptrs[1]);\n+\n         if (is_column_const[1])\n-            container1 = &typeid_cast<const ColumnUInt32*>(typeid_cast<const ColumnConst*>(column_ptrs[1])->getDataColumnPtr().get())->getData();\n+            container1 = &typeid_cast<const ColumnUInt64*>(typeid_cast<const ColumnConst*>(column_ptrs[1])->getDataColumnPtr().get())->getData();\n         else\n-            container1 = &typeid_cast<const ColumnUInt32*>(column_ptrs[1])->getData();\n+            container1 = &typeid_cast<const ColumnUInt64*>(column_ptrs[1])->getData();\n \n         for (size_t i = 0; i < input_rows_count; ++i)\n         {\n             const AggregateDataPtr data_ptr_0 = is_column_const[0] ? (*container0)[0] : (*container0)[i];\n-            const UInt32 data1 = is_column_const[1] ? (*container1)[0] : (*container1)[i];\n+            const UInt64 data1 = is_column_const[1] ? (*container1)[0] : (*container1)[i];\n             const AggregateFunctionGroupBitmapData<T> & bitmap_data_0\n                 = *reinterpret_cast<const AggregateFunctionGroupBitmapData<T> *>(data_ptr_0);\n             vec_to[i] = bitmap_data_0.rbs.rb_contains(data1);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00829_bitmap_function.sql b/tests/queries/0_stateless/00829_bitmap_function.sql\nindex 3ed2ae5530e4..b9e9664a56e6 100644\n--- a/tests/queries/0_stateless/00829_bitmap_function.sql\n+++ b/tests/queries/0_stateless/00829_bitmap_function.sql\n@@ -137,10 +137,10 @@ DROP TABLE IF EXISTS bitmap_column_expr_test3;\n CREATE TABLE bitmap_column_expr_test3\n (\n     tag_id String,\n-    z AggregateFunction(groupBitmap, UInt32),\n+    z AggregateFunction(groupBitmap, UInt64),\n     replace Nested (\n-        from UInt32,\n-        to UInt32\n+        from UInt16,\n+        to UInt64\n     )\n )\n ENGINE = MergeTree\n@@ -149,10 +149,10 @@ ORDER BY tag_id;\n DROP TABLE IF EXISTS numbers10;\n CREATE VIEW numbers10 AS SELECT number FROM system.numbers LIMIT 10;\n \n-INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag1', groupBitmapState(toUInt32(number)), cast([] as Array(UInt32)), cast([] as Array(UInt32)) FROM numbers10;\n-INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag2', groupBitmapState(toUInt32(number)), cast([0] as Array(UInt32)), cast([2] as Array(UInt32)) FROM numbers10;\n-INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag3', groupBitmapState(toUInt32(number)), cast([0,7] as Array(UInt32)), cast([3,101] as Array(UInt32)) FROM numbers10;\n-INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag4', groupBitmapState(toUInt32(number)), cast([5,999,2] as Array(UInt32)), cast([2,888,20] as Array(UInt32)) FROM numbers10;\n+INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag1', groupBitmapState(toUInt64(number)), cast([] as Array(UInt16)), cast([] as Array(UInt64)) FROM numbers10;\n+INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag2', groupBitmapState(toUInt64(number)), cast([0] as Array(UInt16)), cast([2] as Array(UInt64)) FROM numbers10;\n+INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag3', groupBitmapState(toUInt64(number)), cast([0,7] as Array(UInt16)), cast([3,101] as Array(UInt64)) FROM numbers10;\n+INSERT INTO bitmap_column_expr_test3(tag_id, z, replace.from, replace.to) SELECT 'tag4', groupBitmapState(toUInt64(number)), cast([5,999,2] as Array(UInt16)), cast([2,888,20] as Array(UInt64)) FROM numbers10;\n \n SELECT tag_id, bitmapToArray(z), replace.from, replace.to, bitmapToArray(bitmapTransform(z, replace.from, replace.to)) FROM bitmap_column_expr_test3 ORDER BY tag_id;\n \n@@ -232,11 +232,11 @@ select bitmapHasAll(bitmapBuild([\n \n -- bitmapContains:\n ---- Empty\n-SELECT bitmapContains(bitmapBuild(emptyArrayUInt32()), toUInt32(0));\n-SELECT bitmapContains(bitmapBuild(emptyArrayUInt16()), toUInt32(5));\n+SELECT bitmapContains(bitmapBuild(emptyArrayUInt32()), toUInt8(0));\n+SELECT bitmapContains(bitmapBuild(emptyArrayUInt16()), toUInt16(5));\n ---- Small\n select bitmapContains(bitmapBuild([1,5,7,9]),toUInt32(0));\n-select bitmapContains(bitmapBuild([1,5,7,9]),toUInt32(9));\n+select bitmapContains(bitmapBuild([1,5,7,9]),toUInt64(9));\n ---- Large\n select bitmapContains(bitmapBuild([\n     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,\n@@ -250,31 +250,31 @@ select bitmapContains(bitmapBuild([\n \n -- bitmapSubsetInRange:\n ---- Empty\n-SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild(emptyArrayUInt32()), toUInt32(0), toUInt32(10)));\n-SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild(emptyArrayUInt16()), toUInt32(0), toUInt32(10)));\n+SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild(emptyArrayUInt32()), toUInt64(0), toUInt32(10)));\n+SELECT bitmapToArray(bitmapSubsetInRange(bitmapBuild(emptyArrayUInt16()), toUInt32(0), toUInt64(10)));\n ---- Small\n-select bitmapToArray(bitmapSubsetInRange(bitmapBuild([1,5,7,9]), toUInt32(0), toUInt32(4)));\n-select bitmapToArray(bitmapSubsetInRange(bitmapBuild([1,5,7,9]), toUInt32(10), toUInt32(10)));\n-select bitmapToArray(bitmapSubsetInRange(bitmapBuild([1,5,7,9]), toUInt32(3), toUInt32(7)));\n+select bitmapToArray(bitmapSubsetInRange(bitmapBuild([1,5,7,9]), toUInt8(0), toUInt16(4)));\n+select bitmapToArray(bitmapSubsetInRange(bitmapBuild([1,5,7,9]), toUInt32(10), toUInt64(10)));\n+select bitmapToArray(bitmapSubsetInRange(bitmapBuild([1,5,7,9]), toUInt64(3), toUInt32(7)));\n ---- Large\n select bitmapToArray(bitmapSubsetInRange(bitmapBuild([\n     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,\n-    100,200,500]), toUInt32(0), toUInt32(100)));\n+    100,200,500]), toUInt8(0), toUInt32(100)));\n select bitmapToArray(bitmapSubsetInRange(bitmapBuild([\n     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,\n-    100,200,500]), toUInt32(30), toUInt32(200)));\n+    100,200,500]), toUInt64(30), toUInt32(200)));\n select bitmapToArray(bitmapSubsetInRange(bitmapBuild([\n     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,\n-    100,200,500]), toUInt32(100), toUInt32(200)));\n+    100,200,500]), toUInt32(100), toUInt64(200)));\n \n -- bitmapSubsetLimit:\n ---- Empty\n-SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild(emptyArrayUInt32()), toUInt32(0), toUInt32(10)));\n-SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild(emptyArrayUInt16()), toUInt32(0), toUInt32(10)));\n+SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild(emptyArrayUInt32()), toUInt8(0), toUInt32(10)));\n+SELECT bitmapToArray(bitmapSubsetLimit(bitmapBuild(emptyArrayUInt16()), toUInt32(0), toUInt64(10)));\n ---- Small\n-select bitmapToArray(bitmapSubsetLimit(bitmapBuild([1,5,7,9]), toUInt32(0), toUInt32(4)));\n-select bitmapToArray(bitmapSubsetLimit(bitmapBuild([1,5,7,9]), toUInt32(10), toUInt32(10)));\n-select bitmapToArray(bitmapSubsetLimit(bitmapBuild([1,5,7,9]), toUInt32(3), toUInt32(7)));\n+select bitmapToArray(bitmapSubsetLimit(bitmapBuild([1,5,7,9]), toUInt8(0), toUInt32(4)));\n+select bitmapToArray(bitmapSubsetLimit(bitmapBuild([1,5,7,9]), toUInt32(10), toUInt64(10)));\n+select bitmapToArray(bitmapSubsetLimit(bitmapBuild([1,5,7,9]), toUInt16(3), toUInt32(7)));\n ---- Large\n select bitmapToArray(bitmapSubsetLimit(bitmapBuild([\n     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,\n@@ -284,7 +284,7 @@ select bitmapToArray(bitmapSubsetLimit(bitmapBuild([\n     100,200,500]), toUInt32(30), toUInt32(200)));\n select bitmapToArray(bitmapSubsetLimit(bitmapBuild([\n     0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,\n-    100,200,500]), toUInt32(100), toUInt32(200)));\n+    100,200,500]), toUInt32(100), toUInt16(200)));\n \n -- bitmapMin:\n ---- Empty\ndiff --git a/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.reference b/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.reference\nindex d00491fd7e5b..98fb6a686563 100644\n--- a/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.reference\n+++ b/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.reference\n@@ -1,1 +1,4 @@\n 1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.sql b/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.sql\nindex 81dd7cab9f4c..520b4a03057d 100644\n--- a/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.sql\n+++ b/tests/queries/0_stateless/00974_bitmapContains_with_primary_key.sql\n@@ -1,5 +1,8 @@\n DROP TABLE IF EXISTS test;\n CREATE TABLE test (num UInt64, str String) ENGINE = MergeTree ORDER BY num;\n INSERT INTO test (num) VALUES (1), (2), (10), (15), (23);\n+SELECT count(*) FROM test WHERE bitmapContains(bitmapBuild([1, 5, 7, 9]), toUInt8(num));\n+SELECT count(*) FROM test WHERE bitmapContains(bitmapBuild([1, 5, 7, 9]), toUInt16(num));\n SELECT count(*) FROM test WHERE bitmapContains(bitmapBuild([1, 5, 7, 9]), toUInt32(num));\n+SELECT count(*) FROM test WHERE bitmapContains(bitmapBuild([1, 5, 7, 9]), toUInt64(num));\n DROP TABLE test;\n",
  "problem_statement": "bitmapContains does not worked for UInt64 while the bitmap is a AggregateFunction(groupBitmap, UInt64)\n\r\n**Describe the bug**\r\nbitmapContains does not worked for UInt64 while the bitmap is of type AggregateFunction(groupBitmap, UInt64)\r\n\r\n\r\n**How to reproduce**\r\nSELECT \r\n    bitmapBuild([toUInt64(1), toUInt64(10000)]) AS res, \r\n    bitmapContains(res, toUInt64(200000000)) AS aa\r\n\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Second argument for function bitmapContains must be UInt32 but it has type UInt64.. \r\n\r\n**Expected behavior**\r\nfor a 64-bit bitmap, bitmapContains should be able to take UInt64 for the parameter.\r\n \r\n**Error message and/or stacktrace**\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Second argument for function bitmapContains must be UInt32 but it has type UInt64.. \r\n\r\n**Additional context**\r\nTried with many versions such as 19.13, 20.3 etc including the latest 20.12.3, still not working.\n",
  "hints_text": "we also have the same problem , help ! \nSame issue!\n/assign",
  "created_at": "2021-01-06T13:21:46Z"
}