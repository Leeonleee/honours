{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 73418,
  "instance_id": "ClickHouse__ClickHouse-73418",
  "issue_numbers": [
    "73400"
  ],
  "base_commit": "66bfec8aaf8781638de1da8f2a659fa48ecbe827",
  "patch": "diff --git a/src/Processors/QueryPlan/PartsSplitter.cpp b/src/Processors/QueryPlan/PartsSplitter.cpp\nindex 07e3a3cd2c95..7276b87cd108 100644\n--- a/src/Processors/QueryPlan/PartsSplitter.cpp\n+++ b/src/Processors/QueryPlan/PartsSplitter.cpp\n@@ -99,17 +99,31 @@ bool isSafePrimaryKey(const KeyDescription & primary_key)\n     return true;\n }\n \n-int compareValues(const Values & lhs, const Values & rhs)\n+int compareValues(const Values & lhs, const Values & rhs, bool in_reverse_order)\n {\n     size_t size = std::min(lhs.size(), rhs.size());\n \n-    for (size_t i = 0; i < size; ++i)\n+    if (in_reverse_order)\n     {\n-        if (applyVisitor(FieldVisitorAccurateLess(), lhs[i], rhs[i]))\n-            return -1;\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            if (applyVisitor(FieldVisitorAccurateLess(), rhs[i], lhs[i]))\n+                return -1;\n+\n+            if (!applyVisitor(FieldVisitorAccurateEquals(), rhs[i], lhs[i]))\n+                return 1;\n+        }\n+    }\n+    else\n+    {\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            if (applyVisitor(FieldVisitorAccurateLess(), lhs[i], rhs[i]))\n+                return -1;\n \n-        if (!applyVisitor(FieldVisitorAccurateEquals(), lhs[i], rhs[i]))\n-            return 1;\n+            if (!applyVisitor(FieldVisitorAccurateEquals(), lhs[i], rhs[i]))\n+                return 1;\n+        }\n     }\n \n     return 0;\n@@ -147,7 +161,8 @@ class IndexAccess\n         return values;\n     }\n \n-    std::optional<size_t> findRightmostMarkLessThanValueInRange(size_t part_index, Values value, size_t range_begin, size_t range_end) const\n+    std::optional<size_t> findRightmostMarkLessThanValueInRange(\n+        size_t part_index, Values value, size_t range_begin, size_t range_end, bool in_reverse_order) const\n     {\n         size_t left = range_begin;\n         size_t right = range_end;\n@@ -155,7 +170,7 @@ class IndexAccess\n         while (left < right)\n         {\n             size_t middle = left + (right - left) / 2;\n-            int compare_result = compareValues(getValue(part_index, middle), value);\n+            int compare_result = compareValues(getValue(part_index, middle), value, in_reverse_order);\n             if (compare_result != -1)\n                 right = middle;\n             else\n@@ -168,12 +183,14 @@ class IndexAccess\n         return right - 1;\n     }\n \n-    std::optional<size_t> findRightmostMarkLessThanValueInRange(size_t part_index, Values value, MarkRange mark_range) const\n+    std::optional<size_t>\n+    findRightmostMarkLessThanValueInRange(size_t part_index, Values value, MarkRange mark_range, bool in_reverse_order) const\n     {\n-        return findRightmostMarkLessThanValueInRange(part_index, value, mark_range.begin, mark_range.end);\n+        return findRightmostMarkLessThanValueInRange(part_index, value, mark_range.begin, mark_range.end, in_reverse_order);\n     }\n \n-    std::optional<size_t> findLeftmostMarkGreaterThanValueInRange(size_t part_index, Values value, size_t range_begin, size_t range_end) const\n+    std::optional<size_t> findLeftmostMarkGreaterThanValueInRange(\n+        size_t part_index, Values value, size_t range_begin, size_t range_end, bool in_reverse_order) const\n     {\n         size_t left = range_begin;\n         size_t right = range_end;\n@@ -181,7 +198,7 @@ class IndexAccess\n         while (left < right)\n         {\n             size_t middle = left + (right - left) / 2;\n-            int compare_result = compareValues(getValue(part_index, middle), value);\n+            int compare_result = compareValues(getValue(part_index, middle), value, in_reverse_order);\n             if (compare_result != 1)\n                 left = middle + 1;\n             else\n@@ -194,9 +211,10 @@ class IndexAccess\n         return left;\n     }\n \n-    std::optional<size_t> findLeftmostMarkGreaterThanValueInRange(size_t part_index, Values value, MarkRange mark_range) const\n+    std::optional<size_t>\n+    findLeftmostMarkGreaterThanValueInRange(size_t part_index, Values value, MarkRange mark_range, bool in_reverse_order) const\n     {\n-        return findLeftmostMarkGreaterThanValueInRange(part_index, value, mark_range.begin, mark_range.end);\n+        return findLeftmostMarkGreaterThanValueInRange(part_index, value, mark_range.begin, mark_range.end, in_reverse_order);\n     }\n \n     size_t getMarkRows(size_t part_idx, size_t mark) const\n@@ -253,7 +271,7 @@ struct PartsRangesIterator\n \n     [[maybe_unused]] bool operator<(const PartsRangesIterator & other) const\n     {\n-        int compare_result = compareValues(value, other.value);\n+        int compare_result = compareValues(value, other.value, in_reverse_order);\n         if (compare_result == -1)\n             return true;\n         if (compare_result == 1)\n@@ -315,6 +333,7 @@ struct PartsRangesIterator\n     }\n \n     Values value;\n+    bool in_reverse_order;\n     MarkRange range;\n     size_t part_index;\n     EventType event;\n@@ -374,7 +393,7 @@ String toString(const std::vector<PartsRangesIterator> & ranges_iterators)\n     return buffer.str();\n }\n \n-SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts, const LoggerPtr & logger)\n+SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts, bool in_reverse_order, const LoggerPtr & logger)\n {\n     /** Split ranges in data parts into intersecting ranges in data parts and non intersecting ranges in data parts.\n       *\n@@ -442,14 +461,22 @@ SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts,\n         {\n             const auto & index_granularity = ranges_in_data_parts[part_index].data_part->index_granularity;\n             parts_ranges.push_back(\n-                {index_access.getValue(part_index, range.begin), range, part_index, PartsRangesIterator::EventType::RangeStart});\n+                {index_access.getValue(part_index, range.begin),\n+                 in_reverse_order,\n+                 range,\n+                 part_index,\n+                 PartsRangesIterator::EventType::RangeStart});\n \n             const bool value_is_defined_at_end_mark = range.end < index_granularity->getMarksCount();\n             if (!value_is_defined_at_end_mark)\n                 continue;\n \n             parts_ranges.push_back(\n-                {index_access.getValue(part_index, range.end), range, part_index, PartsRangesIterator::EventType::RangeEnd});\n+                {index_access.getValue(part_index, range.end),\n+                 in_reverse_order,\n+                 range,\n+                 part_index,\n+                 PartsRangesIterator::EventType::RangeEnd});\n         }\n     }\n \n@@ -507,9 +534,8 @@ SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts,\n \n                 /// Case 1 Range Start after Range Start\n                 size_t begin = previous_part_range.range.begin;\n-                std::optional<size_t> end_optional = index_access.findRightmostMarkLessThanValueInRange(previous_part_range.part_index,\n-                    current_part_range.value,\n-                    previous_part_range.range);\n+                std::optional<size_t> end_optional = index_access.findRightmostMarkLessThanValueInRange(\n+                    previous_part_range.part_index, current_part_range.value, previous_part_range.range, in_reverse_order);\n \n                 if (!end_optional)\n                     continue;\n@@ -543,15 +569,13 @@ SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts,\n                 continue;\n \n             /// Case 2 Range Start after Range End\n-            std::optional<size_t> begin_optional = index_access.findLeftmostMarkGreaterThanValueInRange(other_interval_part_index,\n-                previous_part_range.value,\n-                other_interval_range);\n+            std::optional<size_t> begin_optional = index_access.findLeftmostMarkGreaterThanValueInRange(\n+                other_interval_part_index, previous_part_range.value, other_interval_range, in_reverse_order);\n             if (!begin_optional)\n                 continue;\n \n-            std::optional<size_t> end_optional = index_access.findRightmostMarkLessThanValueInRange(other_interval_part_index,\n-                current_part_range.value,\n-                other_interval_range);\n+            std::optional<size_t> end_optional = index_access.findRightmostMarkLessThanValueInRange(\n+                other_interval_part_index, current_part_range.value, other_interval_range, in_reverse_order);\n             if (!end_optional)\n                 continue;\n \n@@ -596,9 +620,8 @@ SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts,\n         chassert(previous_part_range.event == PartsRangesIterator::EventType::RangeEnd);\n \n         /// Case 4 Range End after Range End\n-        std::optional<size_t> begin_optional = index_access.findLeftmostMarkGreaterThanValueInRange(current_part_range.part_index,\n-            previous_part_range.value,\n-            current_part_range.range);\n+        std::optional<size_t> begin_optional = index_access.findLeftmostMarkGreaterThanValueInRange(\n+            current_part_range.part_index, previous_part_range.value, current_part_range.range, in_reverse_order);\n         size_t end = current_part_range.range.end;\n \n         if (begin_optional && end - *begin_optional >= min_number_of_marks_for_non_intersecting_range)\n@@ -641,9 +664,8 @@ SplitPartsRangesResult splitPartsRanges(RangesInDataParts ranges_in_data_parts,\n     return {std::move(non_intersecting_ranges_in_data_parts), std::move(intersecting_ranges_in_data_parts)};\n }\n \n-std::pair<std::vector<RangesInDataParts>, std::vector<Values>> splitIntersectingPartsRangesIntoLayers(RangesInDataParts intersecting_ranges_in_data_parts,\n-    size_t max_layers,\n-    const LoggerPtr & logger)\n+std::pair<std::vector<RangesInDataParts>, std::vector<Values>> splitIntersectingPartsRangesIntoLayers(\n+    RangesInDataParts intersecting_ranges_in_data_parts, size_t max_layers, bool in_reverse_order, const LoggerPtr & logger)\n {\n     /** We will advance the iterator pointing to the mark with the smallest PK value until\n       * there will be not less than rows_per_layer rows in the current layer (roughly speaking).\n@@ -663,7 +685,12 @@ std::pair<std::vector<RangesInDataParts>, std::vector<Values>> splitIntersecting\n         for (const auto & range : intersecting_ranges_in_data_parts[part_index].ranges)\n         {\n             const auto & index_granularity = intersecting_ranges_in_data_parts[part_index].data_part->index_granularity;\n-            PartsRangesIterator parts_range_start{index_access.getValue(part_index, range.begin), range, part_index, PartsRangesIterator::EventType::RangeStart};\n+            PartsRangesIterator parts_range_start{\n+                index_access.getValue(part_index, range.begin),\n+                in_reverse_order,\n+                range,\n+                part_index,\n+                PartsRangesIterator::EventType::RangeStart};\n             PartRangeIndex parts_range_start_index(parts_range_start);\n             parts_ranges_queue.push({std::move(parts_range_start), std::move(parts_range_start_index)});\n \n@@ -671,7 +698,12 @@ std::pair<std::vector<RangesInDataParts>, std::vector<Values>> splitIntersecting\n             if (!value_is_defined_at_end_mark)\n                 continue;\n \n-            PartsRangesIterator parts_range_end{index_access.getValue(part_index, range.end), range, part_index, PartsRangesIterator::EventType::RangeEnd};\n+            PartsRangesIterator parts_range_end{\n+                index_access.getValue(part_index, range.end),\n+                in_reverse_order,\n+                range,\n+                part_index,\n+                PartsRangesIterator::EventType::RangeEnd};\n             PartRangeIndex parts_range_end_index(parts_range_end);\n             parts_ranges_queue.push({std::move(parts_range_end), std::move(parts_range_end_index)});\n         }\n@@ -764,10 +796,20 @@ std::pair<std::vector<RangesInDataParts>, std::vector<Values>> splitIntersecting\n     {\n         auto & layer = result_layers[i];\n \n-        LOG_TEST(logger, \"Layer {} {} filter values in ({}, {}])\",\n-            i,\n-            layer.getDescriptions().describe(),\n-            i ? ::toString(borders[i - 1]) : \"-inf\", i < borders.size() ? ::toString(borders[i]) : \"+inf\");\n+        if (in_reverse_order)\n+        {\n+            LOG_TEST(logger, \"Layer {} {} filter values in [{}, {}))\",\n+                i,\n+                layer.getDescriptions().describe(),\n+                i < borders.size() ? ::toString(borders[i]) : \"-inf\", i ? ::toString(borders[i - 1]) : \"+inf\");\n+        }\n+        else\n+        {\n+            LOG_TEST(logger, \"Layer {} {} filter values in ({}, {}])\",\n+                i,\n+                layer.getDescriptions().describe(),\n+                i ? ::toString(borders[i - 1]) : \"-inf\", i < borders.size() ? ::toString(borders[i]) : \"+inf\");\n+        }\n \n         std::stable_sort(\n             layer.begin(),\n@@ -780,13 +822,14 @@ std::pair<std::vector<RangesInDataParts>, std::vector<Values>> splitIntersecting\n \n \n /// Will return borders.size()+1 filters in total, i-th filter will accept rows with PK values within the range (borders[i-1], borders[i]].\n-ASTs buildFilters(const KeyDescription & primary_key, const std::vector<Values> & borders)\n+ASTs buildFilters(const KeyDescription & primary_key, const std::vector<Values> & borders, bool in_reverse_order)\n {\n     auto add_and_condition = [&](ASTPtr & result, const ASTPtr & foo) { result = (!result) ? foo : makeASTFunction(\"and\", result, foo); };\n \n     /// Produces ASTPtr to predicate (pk_col0, pk_col1, ... , pk_colN) > (value[0], value[1], ... , value[N]), possibly with conversions.\n     /// For example, if table PK is (a, toDate(d)), where `a` is UInt32 and `d` is DateTime, and PK columns values are (8192, 19160),\n     /// it will build the following predicate: greater(tuple(a, toDate(d)), tuple(8192, cast(19160, 'Date'))).\n+    /// If @in_reverse_order == true, compare values in reverse order.\n     auto lexicographically_greater = [&](const Values & values) -> ASTPtr\n     {\n         ASTs pks_ast;\n@@ -831,7 +874,7 @@ ASTs buildFilters(const KeyDescription & primary_key, const std::vector<Values>\n         ASTPtr pk_columns_as_tuple = makeASTFunction(\"tuple\", pks_ast);\n         ASTPtr values_as_tuple = makeASTFunction(\"tuple\", values_ast);\n \n-        return makeASTFunction(\"greater\", pk_columns_as_tuple, values_as_tuple);\n+        return makeASTFunction(in_reverse_order ? \"less\" : \"greater\", pk_columns_as_tuple, values_as_tuple);\n     };\n \n     ASTs filters(borders.size() + 1);\n@@ -916,9 +959,25 @@ SplitPartsWithRangesByPrimaryKeyResult splitPartsWithRangesByPrimaryKey(\n         return result;\n     }\n \n+    bool in_reverse_order = false;\n+    if (!primary_key.reverse_flags.empty())\n+    {\n+        in_reverse_order = primary_key.reverse_flags[0];\n+        for (size_t i = 1; i < primary_key.reverse_flags.size(); ++i)\n+        {\n+            /// It's not possible to split parts when some keys are in ascending\n+            /// order while others are in descending order.\n+            if (in_reverse_order != primary_key.reverse_flags[i])\n+            {\n+                result.merging_pipes.emplace_back(create_merging_pipe(intersecting_parts_ranges));\n+                return result;\n+            }\n+        }\n+    }\n+\n     if (split_parts_ranges_into_intersecting_and_non_intersecting_final)\n     {\n-        SplitPartsRangesResult split_result = splitPartsRanges(intersecting_parts_ranges, logger);\n+        SplitPartsRangesResult split_result = splitPartsRanges(intersecting_parts_ranges, in_reverse_order, logger);\n         result.non_intersecting_parts_ranges = std::move(split_result.non_intersecting_parts_ranges);\n         intersecting_parts_ranges = std::move(split_result.intersecting_parts_ranges);\n     }\n@@ -933,8 +992,8 @@ SplitPartsWithRangesByPrimaryKeyResult splitPartsWithRangesByPrimaryKey(\n     if (max_layers <= 1)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"max_layer should be greater than 1\");\n \n-    auto && [layers, borders] = splitIntersectingPartsRangesIntoLayers(intersecting_parts_ranges, max_layers, logger);\n-    auto filters = buildFilters(primary_key, borders);\n+    auto && [layers, borders] = splitIntersectingPartsRangesIntoLayers(intersecting_parts_ranges, max_layers, in_reverse_order, logger);\n+    auto filters = buildFilters(primary_key, borders, in_reverse_order);\n     result.merging_pipes.resize(layers.size());\n \n     for (size_t i = 0; i < layers.size(); ++i)\n@@ -949,8 +1008,14 @@ SplitPartsWithRangesByPrimaryKeyResult splitPartsWithRangesByPrimaryKey(\n         auto actions = ExpressionAnalyzer(filter_function, syntax_result, context).getActionsDAG(false);\n         reorderColumns(actions, result.merging_pipes[i].getHeader(), filter_function->getColumnName());\n         ExpressionActionsPtr expression_actions = std::make_shared<ExpressionActions>(std::move(actions));\n-        auto description = fmt::format(\n-            \"filter values in ({}, {}]\", i ? ::toString(borders[i - 1]) : \"-inf\", i < borders.size() ? ::toString(borders[i]) : \"+inf\");\n+        auto description = in_reverse_order ? fmt::format(\n+                                                  \"filter values in [{}, {})\",\n+                                                  i < borders.size() ? ::toString(borders[i]) : \"-inf\",\n+                                                  i ? ::toString(borders[i - 1]) : \"+inf\")\n+                                            : fmt::format(\n+                                                  \"filter values in ({}, {}]\",\n+                                                  i ? ::toString(borders[i - 1]) : \"-inf\",\n+                                                  i < borders.size() ? ::toString(borders[i]) : \"+inf\");\n         result.merging_pipes[i].addSimpleTransform(\n             [&](const Block & header)\n             {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03286_reverse_sorting_key_final.reference b/tests/queries/0_stateless/03286_reverse_sorting_key_final.reference\nnew file mode 100644\nindex 000000000000..ac73f9225cf4\n--- /dev/null\n+++ b/tests/queries/0_stateless/03286_reverse_sorting_key_final.reference\n@@ -0,0 +1,13 @@\n+1\n+1\n+(Expression)\n+ExpressionTransform \u00d7 2\n+  (ReadFromMergeTree)\n+  MergeTreeSelect(pool: ReadPool, algorithm: Thread) \u00d7 2 0 \u2192 1\n+(Expression)\n+ExpressionTransform\n+  (ReadFromMergeTree)\n+  ExpressionTransform\n+    ReplacingSorted 2 \u2192 1\n+      ExpressionTransform \u00d7 2\n+        MergeTreeSelect(pool: ReadPoolInOrder, algorithm: InOrder) \u00d7 2 0 \u2192 1\ndiff --git a/tests/queries/0_stateless/03286_reverse_sorting_key_final.sql b/tests/queries/0_stateless/03286_reverse_sorting_key_final.sql\nnew file mode 100644\nindex 000000000000..51eadfce9d3a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03286_reverse_sorting_key_final.sql\n@@ -0,0 +1,22 @@\n+DROP TABLE IF EXISTS t0;\n+CREATE TABLE t0 (c0 Nested(c1 Int)) ENGINE = SummingMergeTree ORDER BY (c0.c1 DESC) SETTINGS allow_experimental_reverse_key = 1;\n+INSERT INTO t0 (c0.c1) VALUES ([1]), ([2]);\n+SELECT 1 FROM t0 FINAL;\n+DROP TABLE t0;\n+\n+-- PartsSplitter should work for reverse keys.\n+CREATE TABLE t0(a Int, b Int) Engine=ReplacingMergeTree order by (a desc, b desc) SETTINGS allow_experimental_reverse_key = 1, allow_nullable_key = 1, index_granularity = 8192, index_granularity_bytes = '10Mi';\n+INSERT INTO t0 select number, number from numbers(5);\n+INSERT INTO t0 select number, number from numbers(5, 2);\n+set max_threads = 2;\n+explain pipeline select * from t0 final SETTINGS enable_vertical_final = 0;\n+DROP TABLE t0;\n+\n+-- PartsSplitter is disabled when some keys are in ascending order while others are in descending order.\n+CREATE TABLE t0(a Int, b Int) Engine=ReplacingMergeTree order by (a desc, b) SETTINGS allow_experimental_reverse_key = 1, index_granularity = 8192, index_granularity_bytes = '10Mi';\n+INSERT INTO t0 select number, number from numbers(5);\n+INSERT INTO t0 select number, number from numbers(5,2);\n+set max_threads = 2;\n+explain pipeline select * from t0 final SETTINGS enable_vertical_final = 0;\n+DROP TABLE t0;\n+\n",
  "problem_statement": "Logical error on merge algorithm with reverse key and nested field\n**Describe the bug**\r\nThe reverse sort order for MergeTree tables has an issue with Nested fields on tables that require transformations during merge, followed by the `FINAL` keyword.\r\n\r\n**How to reproduce**\r\nWith the setup from #71095, run:\r\n\r\n```sql\r\nCREATE TABLE t0 (c0 Nested(c1 Int)) ENGINE = SummingMergeTree() ORDER BY (c0.c1 DESC) SETTINGS allow_experimental_reverse_key = 1;\r\nINSERT INTO TABLE t0 (c0.c1) VALUES ([1]), ([2]);\r\nSELECT 1 FROM t0 FINAL; --Logical error\r\n```\r\nStack trace:\r\n```\r\n<Fatal> : Logical error: 'parts_ranges[0].event == PartsRangesIterator::EventType::RangeStart'.\r\n<Fatal> : Stack trace (when copying this message, always include the lines below):\r\n\r\n0. src/Common/StackTrace.cpp:381: StackTrace::tryCapture() @ 0x0000000025a9ed77\r\n1. src/Common/StackTrace.h:48: DB::abortOnFailedAssertion(String const&) @ 0x0000000025a54d17\r\n2. src/Processors/QueryPlan/PartsSplitter.cpp:480: (anonymous namespace)::splitPartsRanges(DB::RangesInDataParts, std::shared_ptr<Poco::Logger> const&) @ 0x0000000035bbd813\r\n3. src/Processors/QueryPlan/PartsSplitter.cpp:908: DB::splitPartsWithRangesByPrimaryKey(DB::KeyDescription const&, std::shared_ptr<DB::ExpressionActions>, DB::RangesInDataParts, unsigned long, std::shared_ptr<DB::Context const>, std::function<DB::Pipe (DB::RangesInDataParts)>&&, bool, bool) @ 0x0000000035bb80e9\r\n4. src/Processors/QueryPlan/ReadFromMergeTree.cpp:1355: DB::ReadFromMergeTree::spreadMarkRangesAmongStreamsFinal(DB::RangesInDataParts&&, unsigned long, std::vector<String, std::allocator<String>> const&, std::vector<String, std::allocator<String>> const&, std::optional<DB::ActionsDAG>&) @ 0x0000000035b6a943\r\n5. src/Processors/QueryPlan/ReadFromMergeTree.cpp:1992: DB::ReadFromMergeTree::spreadMarkRanges(DB::RangesInDataParts&&, unsigned long, DB::ReadFromMergeTree::AnalysisResult&, std::optional<DB::ActionsDAG>&) @ 0x0000000035b78bda\r\n6. src/Processors/QueryPlan/ReadFromMergeTree.cpp:2094: DB::ReadFromMergeTree::initializePipeline(DB::QueryPipelineBuilder&, DB::BuildQueryPipelineSettings const&) @ 0x0000000035b7b1a6\r\n7. src/Processors/QueryPlan/ISourceStep.cpp:20: DB::ISourceStep::updatePipeline(std::vector<std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>, std::allocator<std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>>>, DB::BuildQueryPipelineSettings const&) @ 0x0000000035b0987c\r\n8. src/Processors/QueryPlan/QueryPlan.cpp:188: DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&) @ 0x0000000035b40f79\r\n9. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:261: DB::InterpreterSelectQueryAnalyzer::buildQueryPipeline() @ 0x0000000032132713\r\n10. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:228: DB::InterpreterSelectQueryAnalyzer::execute() @ 0x0000000032132306\r\n11. src/Interpreters/executeQuery.cpp:1368: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000003262f243\r\n12. src/Interpreters/executeQuery.cpp:1535: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x000000003262914e\r\n13. src/Server/TCPHandler.cpp:656: DB::TCPHandler::runImpl() @ 0x00000000350e6afc\r\n14. src/Server/TCPHandler.cpp:2603: DB::TCPHandler::run() @ 0x0000000035111c6e\r\n15. base/poco/Net/src/TCPServerConnection.cpp:40: Poco::Net::TCPServerConnection::start() @ 0x0000000038c03922\r\n16. base/poco/Net/src/TCPServerDispatcher.cpp:115: Poco::Net::TCPServerDispatcher::run() @ 0x0000000038c045f2\r\n17. base/poco/Foundation/src/ThreadPool.cpp:205: Poco::PooledThread::run() @ 0x0000000038b61cb7\r\n18. base/poco/Foundation/src/Thread_POSIX.cpp:335: Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000038b5d5ae\r\n19. ? @ 0x00007ffff7ca1e2e\r\n20. ? @ 0x00007ffff7d33a4c\r\n```\n",
  "hints_text": "",
  "created_at": "2024-12-17T08:03:30Z",
  "modified_files": [
    "src/Processors/QueryPlan/PartsSplitter.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03286_reverse_sorting_key_final.reference",
    "b/tests/queries/0_stateless/03286_reverse_sorting_key_final.sql"
  ]
}