{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8086,
  "instance_id": "ClickHouse__ClickHouse-8086",
  "issue_numbers": [
    "8080"
  ],
  "base_commit": "39bb8e724c67cff82e3e1f763e744fe4f0d2521d",
  "patch": "diff --git a/dbms/src/Functions/greatCircleDistance.cpp b/dbms/src/Functions/greatCircleDistance.cpp\nindex ec852b06251a..6753f49730d4 100644\n--- a/dbms/src/Functions/greatCircleDistance.cpp\n+++ b/dbms/src/Functions/greatCircleDistance.cpp\n@@ -14,70 +14,102 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int ARGUMENT_OUT_OF_BOUND;\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int LOGICAL_ERROR;\n-}\n-\n-/** https://en.wikipedia.org/wiki/Great-circle_distance\n- *\n- *  The function calculates distance in meters between two points on Earth specified by longitude and latitude in degrees.\n- *  The function uses great circle distance formula https://en.wikipedia.org/wiki/Great-circle_distance .\n- *  Throws exception when one or several input values are not within reasonable bounds.\n- *  Latitude must be in [-90, 90], longitude must be [-180, 180].\n- *  Original code of this implementation of this function is here https://github.com/sphinxsearch/sphinx/blob/409f2c2b5b2ff70b04e38f92b6b1a890326bad65/src/sphinxexpr.cpp#L3825.\n- *  Andrey Aksenov, the author of original code, permitted to use this code in ClickHouse under the Apache 2.0 license.\n- *  Presentation about this code from Highload++ Siberia 2019 is here https://github.com/ClickHouse/ClickHouse/files/3324740/1_._._GEODIST_._.pdf\n- *  The main idea of this implementation is optimisations based on Taylor series, trigonometric identity and calculated constants once for cosine, arcsine(sqrt) and look up table.\n- */\n+/** Calculates the distance between two geographical locations.\n+  * There are two variants:\n+  * greatCircleDistance: calculates the distance on a sphere: https://en.wikipedia.org/wiki/Great-circle_distance\n+  * geoDistance: calculates the distance on WGS-84 ellipsoid.\n+  *\n+  * The function calculates distance in meters between two points on Earth specified by longitude and latitude in degrees.\n+  *\n+  * Latitude must be in [-90, 90], longitude must be [-180, 180].\n+  *\n+  * Original code of this implementation of this function is here:\n+  * https://github.com/sphinxsearch/sphinx/blob/409f2c2b5b2ff70b04e38f92b6b1a890326bad65/src/sphinxexpr.cpp#L3825.\n+  * Andrey Aksenov, the author of original code, permitted to use this code in ClickHouse under the Apache 2.0 license.\n+  * Presentation about this code from Highload++ Siberia 2019 is here https://github.com/ClickHouse/ClickHouse/files/3324740/1_._._GEODIST_._.pdf\n+  * The main idea of this implementation is optimisations based on Taylor series, trigonometric identity\n+  *  and calculated constants once for cosine, arcsine(sqrt) and look up table.\n+  */\n \n namespace\n {\n \n constexpr double PI = 3.14159265358979323846;\n-constexpr float TO_RADF = static_cast<float>(PI / 180.0);\n-constexpr float TO_RADF2 = static_cast<float>(PI / 360.0);\n+constexpr float RAD_IN_DEG = static_cast<float>(PI / 180.0);\n+constexpr float RAD_IN_DEG_HALF = static_cast<float>(PI / 360.0);\n+\n+constexpr size_t COS_LUT_SIZE = 1024; // maxerr 0.00063%\n+constexpr size_t ASIN_SQRT_LUT_SIZE = 512;\n+constexpr size_t METRIC_LUT_SIZE = 1024;\n+\n+/** We use \"WGS-84 ellipsoidal quadratic mean radius of Earth\" as the approximation to calculate distances on sphere.\n+  * The motivation for it is explained here: https://math.wikia.org/wiki/Ellipsoidal_quadratic_mean_radius\n+  *\n+  * Brief explanation:\n+  * - the radius of sphere is choosen to minimize the difference between distance on that sphere and distance on WGS-84 ellipsoid between two points,\n+  *   averaged uniformly (?) by all angles (?) between points.\n+  * This sounds not clear enough for me: what set we are averaging and by what measure?\n+  *\n+  * The value should be calculated this way:\n+  * WITH 6378137.0 AS a, 6356752.314245 AS b SELECT sqrt(3 * a * a + b * b) / 2\n+  *\n+  * But for unknown reason, slightly different value is used.\n+  * This constant may be changed in future with a note about backward incompatible change in the changelog.\n+  *\n+  * See also:\n+  * https://github.com/Project-OSRM/osrm-backend/blob/bb1f4a025a3cefd3598a38b9d3e55485d1080ec5/third_party/libosmium/include/osmium/geom/haversine.hpp#L58-L59\n+  * https://github.com/Project-OSRM/osrm-backend/issues/5051\n+  * https://github.com/mapbox/turf-swift/issues/26\n+  * https://github.com/Project-OSRM/osrm-backend/pull/5041\n+  * https://en.wikipedia.org/wiki/Talk:Great-circle_distance/Archive_1\n+  */\n+constexpr float EARTH_RADIUS = 6372797.560856;\n+constexpr float EARTH_DIAMETER = 2 * EARTH_RADIUS;\n+\n+\n+float cos_lut[COS_LUT_SIZE + 1];       /// cos(x) table\n+float asin_sqrt_lut[ASIN_SQRT_LUT_SIZE + 1]; /// asin(sqrt(x)) * earth_diameter table\n+\n+float sphere_metric_lut[METRIC_LUT_SIZE + 1];    /// sphere metric: the distance for one degree across longitude depending on latitude\n+float wgs84_metric_lut[2 * (METRIC_LUT_SIZE + 1)];  /// ellipsoid metric: the distance across one degree latitude/longitude depending on latitude\n \n-constexpr size_t GEODIST_TABLE_COS = 1024; // maxerr 0.00063%\n-constexpr size_t GEODIST_TABLE_ASIN = 512;\n-constexpr size_t GEODIST_TABLE_K = 1024;\n-\n-float g_GeoCos[GEODIST_TABLE_COS + 1];        /// cos(x) table\n-float g_GeoAsin[GEODIST_TABLE_ASIN + 1];    /// asin(sqrt(x)) table\n-float g_GeoFlatK[GEODIST_TABLE_K + 1][2];    /// geodistAdaptive() flat ellipsoid method k1, k2 coeffs table\n \n inline double sqr(double v)\n {\n     return v * v;\n }\n \n-inline float fsqr(float v)\n+inline float sqrf(float v)\n {\n     return v * v;\n }\n \n void geodistInit()\n {\n-    for (size_t i = 0; i <= GEODIST_TABLE_COS; ++i)\n-        g_GeoCos[i] = static_cast<float>(cos(2 * PI * i / GEODIST_TABLE_COS)); // [0, 2 * pi] -> [0, COSTABLE]\n+    for (size_t i = 0; i <= COS_LUT_SIZE; ++i)\n+        cos_lut[i] = static_cast<float>(cos(2 * PI * i / COS_LUT_SIZE)); // [0, 2 * pi] -> [0, COS_LUT_SIZE]\n \n-    for (size_t i = 0; i <= GEODIST_TABLE_ASIN; ++i)\n-        g_GeoAsin[i] = static_cast<float>(asin(\n-                sqrt(static_cast<double>(i) / GEODIST_TABLE_ASIN))); // [0, 1] -> [0, ASINTABLE]\n+    for (size_t i = 0; i <= ASIN_SQRT_LUT_SIZE; ++i)\n+        asin_sqrt_lut[i] = static_cast<float>(EARTH_DIAMETER * asin(\n+            sqrt(static_cast<double>(i) / ASIN_SQRT_LUT_SIZE))); // [0, 1] -> [0, ASIN_SQRT_LUT_SIZE]\n \n-    for (size_t i = 0; i <= GEODIST_TABLE_K; ++i)\n+    for (size_t i = 0; i <= METRIC_LUT_SIZE; ++i)\n     {\n-        double x = PI * i / GEODIST_TABLE_K - PI * 0.5; // [-pi / 2, pi / 2] -> [0, KTABLE]\n-        g_GeoFlatK[i][0] = static_cast<float>(sqr(111132.09 - 566.05 * cos(2 * x) + 1.20 * cos(4 * x)));\n-        g_GeoFlatK[i][1] = static_cast<float>(sqr(111415.13 * cos(x) - 94.55 * cos(3 * x) + 0.12 * cos(5 * x)));\n+        double latitude = i * (PI / METRIC_LUT_SIZE) - PI * 0.5; // [-pi / 2, pi / 2] -> [0, METRIC_LUT_SIZE]\n+\n+        /// Squared metric coefficients (for the distance in meters) on a tangent plane, for latitude and longitude (in degrees),\n+        /// depending on the latitude (in radians).\n+\n+        wgs84_metric_lut[i * 2] = static_cast<float>(sqr(111132.09 - 566.05 * cos(2 * latitude) + 1.20 * cos(4 * latitude)));\n+        wgs84_metric_lut[i * 2 + 1] = static_cast<float>(sqr(111415.13 * cos(latitude) - 94.55 * cos(3 * latitude) + 0.12 * cos(5 * latitude)));\n+\n+        sphere_metric_lut[i] = static_cast<float>(sqr((EARTH_DIAMETER * PI / 360) * cos(latitude)));\n     }\n }\n \n inline float geodistDegDiff(float f)\n {\n-    f = static_cast<float>(fabs(f));\n+    f = fabsf(f);\n     while (f > 360)\n         f -= 360;\n     if (f > 180)\n@@ -87,50 +119,113 @@ inline float geodistDegDiff(float f)\n \n inline float geodistFastCos(float x)\n {\n-    float y = static_cast<float>(fabs(x) * GEODIST_TABLE_COS / PI / 2);\n-    int i = static_cast<int>(y);\n+    float y = fabsf(x) * (COS_LUT_SIZE / PI / 2);\n+    size_t i = static_cast<size_t>(y);\n     y -= i;\n-    i &= (GEODIST_TABLE_COS - 1);\n-    return g_GeoCos[i] + (g_GeoCos[i + 1] - g_GeoCos[i]) * y;\n+    i &= (COS_LUT_SIZE - 1);\n+    return cos_lut[i] + (cos_lut[i + 1] - cos_lut[i]) * y;\n }\n \n inline float geodistFastSin(float x)\n {\n-    float y = static_cast<float>(fabs(x) * GEODIST_TABLE_COS / PI / 2);\n-    int i = static_cast<int>(y);\n+    float y = fabsf(x) * (COS_LUT_SIZE / PI / 2);\n+    size_t i = static_cast<size_t>(y);\n     y -= i;\n-    i = (i - GEODIST_TABLE_COS / 4) & (GEODIST_TABLE_COS - 1); // cos(x - pi / 2) = sin(x), costable / 4 = pi / 2\n-    return g_GeoCos[i] + (g_GeoCos[i + 1] - g_GeoCos[i]) * y;\n+    i = (i - COS_LUT_SIZE / 4) & (COS_LUT_SIZE - 1); // cos(x - pi / 2) = sin(x), costable / 4 = pi / 2\n+    return cos_lut[i] + (cos_lut[i + 1] - cos_lut[i]) * y;\n }\n \n /// fast implementation of asin(sqrt(x))\n /// max error in floats 0.00369%, in doubles 0.00072%\n inline float geodistFastAsinSqrt(float x)\n {\n-    if (x < 0.122)\n+    if (x < 0.122f)\n     {\n-        // distance under 4546km, Taylor error under 0.00072%\n-        float y = static_cast<float>(sqrt(x));\n-        return y + x * y * 0.166666666666666f + x * x * y * 0.075f + x * x * x * y * 0.044642857142857f;\n+        // distance under 4546 km, Taylor error under 0.00072%\n+        float y = sqrtf(x);\n+        return EARTH_DIAMETER * (y + x * y * 0.166666666666666f + x * x * y * 0.075f + x * x * x * y * 0.044642857142857f);\n     }\n-    if (x < 0.948)\n+    if (x < 0.948f)\n     {\n-        // distance under 17083km, 512-entry LUT error under 0.00072%\n-        x *= GEODIST_TABLE_ASIN;\n-        int i = static_cast<int>(x);\n-        return g_GeoAsin[i] + (g_GeoAsin[i + 1] - g_GeoAsin[i]) * (x - i);\n+        // distance under 17083 km, 512-entry LUT error under 0.00072%\n+        x *= ASIN_SQRT_LUT_SIZE;\n+        size_t i = static_cast<size_t>(x);\n+        return asin_sqrt_lut[i] + (asin_sqrt_lut[i + 1] - asin_sqrt_lut[i]) * (x - i);\n+    }\n+    return asinf(sqrtf(x)); // distance over 17083 km, just compute exact\n+}\n+\n+\n+enum class Method\n+{\n+    SPHERE,\n+    WGS84\n+};\n+\n+\n+template <Method method>\n+float distance(float lon1deg, float lat1deg, float lon2deg, float lat2deg)\n+{\n+    float lat_diff = geodistDegDiff(lat1deg - lat2deg);\n+    float lon_diff = geodistDegDiff(lon1deg - lon2deg);\n+\n+    if (lon_diff < 13)\n+    {\n+        // points are close enough; use flat ellipsoid model\n+        // interpolate metric coefficients using latitudes midpoint\n+\n+        /// Why comparing only difference in longitude?\n+        /// If longitudes are different enough, there is a big difference between great circle line and a line with constant latitude.\n+        ///  (Remember how a plane flies from Moscow to New York)\n+        /// But if longitude is close but latitude is different enough, there is no difference between meridian and great circle line.\n+\n+        float latitude_midpoint = (lat1deg + lat2deg + 180) * METRIC_LUT_SIZE / 360; // [-90, 90] degrees -> [0, KTABLE] indexes\n+        size_t latitude_midpoint_index = static_cast<size_t>(latitude_midpoint) & (METRIC_LUT_SIZE - 1);\n+\n+        /// This is linear interpolation between two table items at index \"latitude_midpoint_index\" and \"latitude_midpoint_index + 1\".\n+\n+        float k_lat;\n+        float k_lon;\n+\n+        if constexpr (method == Method::SPHERE)\n+        {\n+            k_lat = sqr(EARTH_DIAMETER * PI / 360);\n+\n+            k_lon = sphere_metric_lut[latitude_midpoint_index]\n+                + (sphere_metric_lut[latitude_midpoint_index + 1] - sphere_metric_lut[latitude_midpoint_index]) * (latitude_midpoint - latitude_midpoint_index);\n+        }\n+        else if constexpr (method == Method::WGS84)\n+        {\n+            k_lat = wgs84_metric_lut[latitude_midpoint_index * 2]\n+                + (wgs84_metric_lut[(latitude_midpoint_index + 1) * 2] - wgs84_metric_lut[latitude_midpoint_index * 2]) * (latitude_midpoint - latitude_midpoint_index);\n+\n+            k_lon = wgs84_metric_lut[latitude_midpoint_index * 2 + 1]\n+                + (wgs84_metric_lut[(latitude_midpoint_index + 1) * 2 + 1] - wgs84_metric_lut[latitude_midpoint_index * 2 + 1]) * (latitude_midpoint - latitude_midpoint_index);\n+        }\n+\n+        /// Metric on a tangent plane: it differs from Euclidean metric only by scale of coordinates.\n+        return sqrtf(k_lat * lat_diff * lat_diff + k_lon * lon_diff * lon_diff);\n+    }\n+    else\n+    {\n+        // points too far away; use haversine\n+\n+        float a = sqrf(geodistFastSin(lat_diff * RAD_IN_DEG_HALF))\n+            + geodistFastCos(lat1deg * RAD_IN_DEG) * geodistFastCos(lat2deg * RAD_IN_DEG) * sqrf(geodistFastSin(lon_diff * RAD_IN_DEG_HALF));\n+\n+        return geodistFastAsinSqrt(a);\n     }\n-    return static_cast<float>(asin(sqrt(x))); // distance over 17083km, just compute honestly\n }\n \n }\n \n \n-class FunctionGreatCircleDistance : public IFunction\n+template <Method method>\n+class FunctionGeoDistance : public IFunction\n {\n public:\n-    static constexpr auto name = \"greatCircleDistance\";\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionGreatCircleDistance>(); }\n+    static constexpr auto name = (method == Method::SPHERE) ? \"greatCircleDistance\" : \"geoDistance\";\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionGeoDistance<method>>(); }\n \n private:\n     String getName() const override { return name; }\n@@ -143,50 +238,15 @@ class FunctionGreatCircleDistance : public IFunction\n         for (const auto arg_idx : ext::range(0, arguments.size()))\n         {\n             const auto arg = arguments[arg_idx].get();\n-            if (!WhichDataType(arg).isFloat())\n+            if (!isNumber(WhichDataType(arg)))\n                 throw Exception(\n-                    \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(arg_idx + 1) + \" of function \" + getName() + \". Must be Float64\",\n+                    \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(arg_idx + 1) + \" of function \" + getName() + \". Must be numeric\",\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         }\n \n         return std::make_shared<DataTypeFloat32>();\n     }\n \n-    Float32 greatCircleDistance(Float32 lon1deg, Float32 lat1deg, Float32 lon2deg, Float32 lat2deg)\n-    {\n-        if (lon1deg < -180 || lon1deg > 180 ||\n-            lon2deg < -180 || lon2deg > 180 ||\n-            lat1deg < -90 || lat1deg > 90 ||\n-            lat2deg < -90 || lat2deg > 90)\n-        {\n-            throw Exception(\"Arguments values out of bounds for function \" + getName(),\n-                            ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-        }\n-\n-        float lat_diff = geodistDegDiff(lat1deg - lat2deg);\n-        float lon_diff = geodistDegDiff(lon1deg - lon2deg);\n-\n-        if (lon_diff < 13)\n-        {\n-            // points are close enough; use flat ellipsoid model\n-            // interpolate sqr(k1), sqr(k2) coefficients using latitudes midpoint\n-            float m = (lat1deg + lat2deg + 180) * GEODIST_TABLE_K / 360; // [-90, 90] degrees -> [0, KTABLE] indexes\n-            size_t i = static_cast<size_t>(m) & (GEODIST_TABLE_K - 1);\n-            float kk1 = g_GeoFlatK[i][0] + (g_GeoFlatK[i + 1][0] - g_GeoFlatK[i][0]) * (m - i);\n-            float kk2 = g_GeoFlatK[i][1] + (g_GeoFlatK[i + 1][1] - g_GeoFlatK[i][1]) * (m - i);\n-            return static_cast<float>(sqrt(kk1 * lat_diff * lat_diff + kk2 * lon_diff * lon_diff));\n-        }\n-        else\n-        {\n-            // points too far away; use haversine\n-            static const float d = 2 * 6371000;\n-            float a = fsqr(geodistFastSin(lat_diff * TO_RADF2)) +\n-                geodistFastCos(lat1deg * TO_RADF) * geodistFastCos(lat2deg * TO_RADF) *\n-                fsqr(geodistFastSin(lon_diff * TO_RADF2));\n-            return static_cast<float>(d * geodistFastAsinSqrt(a));\n-        }\n-    }\n-\n     void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n     {\n         auto dst = ColumnVector<Float32>::create();\n@@ -199,7 +259,7 @@ class FunctionGreatCircleDistance : public IFunction\n         const IColumn & col_lat2 = *block.getByPosition(arguments[3]).column;\n \n         for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n-            dst_data[row_num] = greatCircleDistance(\n+            dst_data[row_num] = distance<method>(\n                 col_lon1.getFloat32(row_num), col_lat1.getFloat32(row_num),\n                 col_lon2.getFloat32(row_num), col_lat2.getFloat32(row_num));\n \n@@ -208,10 +268,11 @@ class FunctionGreatCircleDistance : public IFunction\n };\n \n \n-void registerFunctionGreatCircleDistance(FunctionFactory & factory)\n+void registerFunctionGeoDistance(FunctionFactory & factory)\n {\n     geodistInit();\n-    factory.registerFunction<FunctionGreatCircleDistance>();\n+    factory.registerFunction<FunctionGeoDistance<Method::SPHERE>>();\n+    factory.registerFunction<FunctionGeoDistance<Method::WGS84>>();\n }\n \n }\ndiff --git a/dbms/src/Functions/registerFunctionsGeo.cpp b/dbms/src/Functions/registerFunctionsGeo.cpp\nindex adc025aafe37..f2bd7dda7e79 100644\n--- a/dbms/src/Functions/registerFunctionsGeo.cpp\n+++ b/dbms/src/Functions/registerFunctionsGeo.cpp\n@@ -5,7 +5,7 @@ namespace DB\n \n class FunctionFactory;\n \n-void registerFunctionGreatCircleDistance(FunctionFactory & factory);\n+void registerFunctionGeoDistance(FunctionFactory & factory);\n void registerFunctionPointInEllipses(FunctionFactory & factory);\n void registerFunctionPointInPolygon(FunctionFactory & factory);\n void registerFunctionGeohashEncode(FunctionFactory & factory);\n@@ -18,7 +18,7 @@ void registerFunctionGeoToH3(FunctionFactory &);\n \n void registerFunctionsGeo(FunctionFactory & factory)\n {\n-    registerFunctionGreatCircleDistance(factory);\n+    registerFunctionGeoDistance(factory);\n     registerFunctionPointInEllipses(factory);\n     registerFunctionPointInPolygon(factory);\n     registerFunctionGeohashEncode(factory);\n",
  "test_patch": "diff --git a/dbms/tests/performance/great_circle_dist.xml b/dbms/tests/performance/great_circle_dist.xml\nindex aa2096f183d0..99382543d606 100644\n--- a/dbms/tests/performance/great_circle_dist.xml\n+++ b/dbms/tests/performance/great_circle_dist.xml\n@@ -9,8 +9,8 @@\n     </stop_conditions>\n \n     <!-- lon [-180; 180], lat [-90; 90] -->\n-    <query>SELECT count() FROM system.numbers WHERE NOT ignore(greatCircleDistance((rand() % 360) * 1. - 180, (number % 150) * 1.2 - 90, (number % 360) + toFloat64(rand()) / 4294967296 - 180, (rand() % 180) * 1. - 90))</query>\n+    <query>SELECT count() FROM system.numbers WHERE NOT ignore(greatCircleDistance((rand(1) % 360) * 1. - 180, (number % 150) * 1.2 - 90, (number % 360) + toFloat64(rand(2)) / 4294967296 - 180, (rand(3) % 180) * 1. - 90))</query>\n     <!-- 55.755830, 37.617780 is center of Moscow -->\n-    <query>SELECT count() FROM system.numbers WHERE NOT ignore(greatCircleDistance(55. + toFloat64(rand()) / 4294967296, 37. + toFloat64(rand()) / 4294967296, 55. + toFloat64(rand()) / 4294967296, 37. + toFloat64(rand()) / 4294967296))</query>\n+    <query>SELECT count() FROM system.numbers WHERE NOT ignore(greatCircleDistance(55. + toFloat64(rand(1)) / 4294967296, 37. + toFloat64(rand(2)) / 4294967296, 55. + toFloat64(rand(3)) / 4294967296, 37. + toFloat64(rand(4)) / 4294967296))</query>\n </test>\n \ndiff --git a/dbms/tests/queries/0_stateless/01043_geo_distance.reference b/dbms/tests/queries/0_stateless/01043_geo_distance.reference\nnew file mode 100644\nindex 000000000000..d9712b93888f\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01043_geo_distance.reference\n@@ -0,0 +1,8 @@\n+111194.93\n+111194.93\n+110567.33\n+111699.25\n+10007543\n+10007543\n+10007543\n+10001780\ndiff --git a/dbms/tests/queries/0_stateless/01043_geo_distance.sql b/dbms/tests/queries/0_stateless/01043_geo_distance.sql\nnew file mode 100644\nindex 000000000000..c1fb29b9eb7b\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01043_geo_distance.sql\n@@ -0,0 +1,11 @@\n+SELECT greatCircleDistance(0., 0., 0., 1.);\n+SELECT greatCircleDistance(0., 89., 0, 90.);\n+\n+SELECT geoDistance(0., 0., 0., 1.);\n+SELECT geoDistance(0., 89., 0., 90.);\n+\n+SELECT greatCircleDistance(0., 0., 90., 0.);\n+SELECT greatCircleDistance(0., 0., 0., 90.);\n+\n+SELECT geoDistance(0., 0., 90., 0.);\n+SELECT geoDistance(0., 0., 0., 90.);\n",
  "problem_statement": "Behaviour of greatCircleDistance function has been changed\n**Describe the bug or unexpected behaviour**\r\nThe behaviour of `greatCircleDistance` function in current release differs from current master. Previous this function returned length of an arc on the surface of sphere with radius 6372797.560856 meters, but after commit ae2f5ad7d253243130c5f93557021a5fd4b0f91 the output of this function has been changed. It looks like now this function returns the distance between point of an ellipsoid, the constants in the code points to [WGS 84 system](https://en.wikipedia.org/wiki/World_Geodetic_System#WGS84), but I'm not sure. The new behaviour doesn't allow us to name this function after great circle because the surface is not sphere any more.\r\n\r\n**Example**\r\n\r\nThis example compares distances near the equator and the North pole.\r\n\r\n**Release 19.17.5**\r\n```sql\r\nSELECT greatCircleDistance(0., 0., 0., 1.) / greatCircleDistance(0., 89., 0., 90.) AS x\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u2510\r\n\u2502 0.9999999999999986 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**Master**\r\n```sql\r\nSELECT greatCircleDistance(0., 0., 0., 1.) / greatCircleDistance(0., 89., 0., 90.) AS x\r\n```\r\n```text\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u2510\r\n\u2502 0.9898663431043628 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n**Conclusion**\r\nI propose to keep old `greatCircleDistance` function and introduce some new function for ellipsoid distances.\n",
  "hints_text": "Comparison new and old implementation with [WGS web calculator](https://www.cqsrg.org/tools/GCDistance/)\r\n\r\n**Current implementation**\r\n```sql\r\nSELECT greatCircleDistance(0., 0., 0., 1.)\r\n```\r\n```text\r\n\u250c\u2500greatCircleDistance(0., 0., 0., 1.)\u2500\u2510\r\n\u2502                           110567.33 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**Old implementation**\r\n```sql\r\nSELECT greatCircleDistance(0., 0., 0., 1.)\r\n```\r\n```text\r\n\u250c\u2500greatCircleDistance(0., 0., 0., 1.)\u2500\u2510\r\n\u2502                  111226.30000000089 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**SQSRG**: 110574.389\r\n\r\n**Current implementation**\r\n```sql\r\nSELECT greatCircleDistance(0., 89., 0., 90.)\r\n```\r\n```text\r\n\u250c\u2500greatCircleDistance(0., 89., 0., 90.)\u2500\u2510\r\n\u2502                             111699.25 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**Old implementation**\r\n```sql\r\nSELECT greatCircleDistance(0., 89., 0., 90.)\r\n```\r\n```text\r\n\u250c\u2500greatCircleDistance(0., 89., 0., 90.)\u2500\u2510\r\n\u2502                    111226.30000000105 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**SQSRG**: 111693.865\nComment to the new `greatCircleDistance` says that the origin of the code is \r\nhttps://github.com/sphinxsearch/sphinx/blob/409f2c2b5b2ff70b04e38f92b6b1a890326bad65/src/sphinxexpr.cpp#L3825.\r\n\r\nTests of this project compare the output of this code with [Vincenty's formula](https://en.wikipedia.org/wiki/Vincenty%27s_formulae) which is approximation for ellipsoid distance, WGS 84 ellipsoid is used:\r\nhttps://github.com/sphinxsearch/sphinx/blob/409f2c2b5b2ff70b04e38f92b6b1a890326bad65/src/tests.cpp#L3577\r\nhttps://github.com/sphinxsearch/sphinx/blob/409f2c2b5b2ff70b04e38f92b6b1a890326bad65/src/tests.cpp#L3682",
  "created_at": "2019-12-08T22:06:58Z"
}