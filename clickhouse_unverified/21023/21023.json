{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21023,
  "instance_id": "ClickHouse__ClickHouse-21023",
  "issue_numbers": [
    "20543",
    "20494"
  ],
  "base_commit": "bf9af598bebb7a86f5c150c01ae46d3bb892628a",
  "patch": "diff --git a/base/common/DateLUTImpl.h b/base/common/DateLUTImpl.h\nindex 0538d3a9ab88..064787fb64e3 100644\n--- a/base/common/DateLUTImpl.h\n+++ b/base/common/DateLUTImpl.h\n@@ -7,6 +7,7 @@\n #include <ctime>\n #include <string>\n \n+\n #define DATE_LUT_MAX (0xFFFFFFFFU - 86400)\n #define DATE_LUT_MAX_DAY_NUM (0xFFFFFFFFU / 86400)\n /// Table size is bigger than DATE_LUT_MAX_DAY_NUM to fill all indices within UInt16 range: this allows to remove extra check.\n@@ -249,7 +250,7 @@ class DateLUTImpl\n     {\n         DayNum index = findIndex(t);\n \n-        if (unlikely(index == 0))\n+        if (unlikely(index == 0 || index > DATE_LUT_MAX_DAY_NUM))\n             return t + offset_at_start_of_epoch;\n \n         time_t res = t - lut[index].date;\n@@ -264,18 +265,18 @@ class DateLUTImpl\n     {\n         DayNum index = findIndex(t);\n \n-        /// If it is not 1970 year (findIndex found nothing appropriate),\n-        ///  than limit number of hours to avoid insane results like 1970-01-01 89:28:15\n-        if (unlikely(index == 0))\n+        /// If it is overflow case,\n+        ///  then limit number of hours to avoid insane results like 1970-01-01 89:28:15\n+        if (unlikely(index == 0 || index > DATE_LUT_MAX_DAY_NUM))\n             return static_cast<unsigned>((t + offset_at_start_of_epoch) / 3600) % 24;\n \n-        time_t res = t - lut[index].date;\n+        time_t time = t - lut[index].date;\n \n-        /// Data is cleaned to avoid possibility of underflow.\n-        if (res >= lut[index].time_at_offset_change)\n-            res += lut[index].amount_of_offset_change;\n+        if (time >= lut[index].time_at_offset_change)\n+            time += lut[index].amount_of_offset_change;\n \n-        return res / 3600;\n+        unsigned res = time / 3600;\n+        return res <= 23 ? res : 0;\n     }\n \n     /** Calculating offset from UTC in seconds.\n@@ -314,12 +315,12 @@ class DateLUTImpl\n       *  each minute, with added or subtracted leap second, spans exactly 60 unix timestamps.\n       */\n \n-    inline unsigned toSecond(time_t t) const { return t % 60; }\n+    inline unsigned toSecond(time_t t) const { return UInt32(t) % 60; }\n \n     inline unsigned toMinute(time_t t) const\n     {\n         if (offset_is_whole_number_of_hours_everytime)\n-            return (t / 60) % 60;\n+            return (UInt32(t) / 60) % 60;\n \n         UInt32 date = find(t).date;\n         return (UInt32(t) - date) / 60 % 60;\n@@ -555,9 +556,7 @@ class DateLUTImpl\n         }\n     }\n \n-    /*\n-     * check and change mode to effective\n-     */\n+    /// Check and change mode to effective.\n     inline UInt8 check_week_mode(UInt8 mode) const\n     {\n         UInt8 week_format = (mode & 7);\n@@ -566,10 +565,9 @@ class DateLUTImpl\n         return week_format;\n     }\n \n-    /*\n-     * Calc weekday from d\n-     * Returns 0 for monday, 1 for tuesday ...\n-     */\n+    /** Calculate weekday from d.\n+      * Returns 0 for monday, 1 for tuesday...\n+      */\n     inline unsigned calc_weekday(DayNum d, bool sunday_first_day_of_week) const\n     {\n         if (!sunday_first_day_of_week)\n@@ -578,7 +576,7 @@ class DateLUTImpl\n             return toDayOfWeek(DayNum(d + 1)) - 1;\n     }\n \n-    /* Calc days in one year. */\n+    /// Calculate days in one year.\n     inline unsigned calc_days_in_year(UInt16 year) const\n     {\n         return ((year & 3) == 0 && (year % 100 || (year % 400 == 0 && year)) ? 366 : 365);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference b/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference\nnew file mode 100644\nindex 000000000000..228086615da9\n--- /dev/null\n+++ b/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference\n@@ -0,0 +1,9 @@\n+-- { echo }\n+SELECT toString(toDateTime('-922337203.6854775808', 1));\n+2106-02-07 15:41:33.6\n+SELECT toString(toDateTime('9922337203.6854775808', 1));\n+2104-12-30 00:50:11.6\n+SELECT toDateTime64(CAST('10000000000.1' AS Decimal64(1)), 1);\n+2106-02-07 20:50:08.1\n+SELECT toDateTime64(CAST('-10000000000.1' AS Decimal64(1)), 1);\n+2011-12-23 00:38:08.1\ndiff --git a/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.sql b/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.sql\nnew file mode 100644\nindex 000000000000..d1f0416149ab\n--- /dev/null\n+++ b/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.sql\n@@ -0,0 +1,5 @@\n+-- { echo }\n+SELECT toString(toDateTime('-922337203.6854775808', 1));\n+SELECT toString(toDateTime('9922337203.6854775808', 1));\n+SELECT toDateTime64(CAST('10000000000.1' AS Decimal64(1)), 1);\n+SELECT toDateTime64(CAST('-10000000000.1' AS Decimal64(1)), 1);\n",
  "problem_statement": "Implemented clampling DateTime64 values when parsed from float string literal\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- Bug Fix\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nFixes out of range values for DateTime64 when parsed from float string literal.\r\n...\r\n\r\n\r\nDetailed description / Documentation draft:\r\n\r\n...\r\n\r\nBy adding documentation, you'll allow users to try your new feature immediately, not when someone else will have time to document it later. Documentation is necessary for all features that affect user experience in any way. You can add brief documentation draft above, or add documentation right into your patch as Markdown files in [docs](https://github.com/ClickHouse/ClickHouse/tree/master/docs) folder.\r\n\r\nIf you are doing this for the first time, it's recommended to read the lightweight [Contributing to ClickHouse Documentation](https://github.com/ClickHouse/ClickHouse/tree/master/docs/README.md) guide first.\r\n\r\n\r\nInformation about CI checks: https://clickhouse.tech/docs/en/development/continuous-integration/\r\n\r\ncloses: #20494\nDateTime64: out of bound array access, garbage results.\n```\r\nmilovidov-desktop :) SELECT toString(toDateTime('-922337203.6854775808', 1))\r\n\r\nSELECT toString(toDateTime('-922337203.6854775808', 1))\r\n\r\nQuery id: 3d51ba80-4993-4f64-b6ef-da0c0f1bdf43\r\n\r\n\u250c\u2500toString(toDateTime('-922337203.6854775808', 1))\u2500\u2510\r\n\u2502 2106-02-07 :rE:\ufffd.6                                \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "https://github.com/ClickHouse/ClickHouse/issues/19362\n> Looks like this patch does not solve the issue:\r\n> \r\n> `SELECT toDateTime64(CAST('10000000000.1' AS Decimal64(1)), 1)`\r\n\r\nAddressed that with bc4d5a09b997a450a4c5e4c36bc69ecb4c332a49 \n",
  "created_at": "2021-02-21T08:06:00Z"
}