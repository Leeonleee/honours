diff --git a/docs/en/engines/table-engines/integrations/jdbc.md b/docs/en/engines/table-engines/integrations/jdbc.md
index 2712870865e8..b2383bc51bf4 100644
--- a/docs/en/engines/table-engines/integrations/jdbc.md
+++ b/docs/en/engines/table-engines/integrations/jdbc.md
@@ -45,6 +45,8 @@ ENGINE = JDBC(datasource_uri, external_database, external_table)
 
 - `external_table` — Name of the table in `external_database` or a select query like `select * from table1 where column1=1`.
 
+- These parameters can also be passed using [named collections](operations/named-collections.md).
+
 ## Usage Example {#usage-example}
 
 Creating a table in MySQL server by connecting directly with it's console client:
diff --git a/docs/en/engines/table-engines/integrations/odbc.md b/docs/en/engines/table-engines/integrations/odbc.md
index c739fdd42b42..8137697dc477 100644
--- a/docs/en/engines/table-engines/integrations/odbc.md
+++ b/docs/en/engines/table-engines/integrations/odbc.md
@@ -44,6 +44,8 @@ The table structure can differ from the source table structure:
 - `external_database` — Name of a database in an external DBMS.
 - `external_table` — Name of a table in the `external_database`.
 
+These parameters can also be passed using [named collections](operations/named-collections.md).
+
 ## Usage Example {#usage-example}
 
 **Retrieving data from the local MySQL installation via ODBC**
diff --git a/docs/en/sql-reference/table-functions/jdbc.md b/docs/en/sql-reference/table-functions/jdbc.md
index 23a90462a9e4..533cb5468927 100644
--- a/docs/en/sql-reference/table-functions/jdbc.md
+++ b/docs/en/sql-reference/table-functions/jdbc.md
@@ -13,11 +13,19 @@ clickhouse-jdbc-bridge contains experimental codes and is no longer supported. I
 ClickHouse recommend using built-in table functions in ClickHouse which provide a better alternative for ad-hoc querying scenarios (Postgres, MySQL, MongoDB, etc).
 :::
 
-`jdbc(datasource, schema, table)` - returns table that is connected via JDBC driver.
+JDBC table function returns table that is connected via JDBC driver.
 
 This table function requires separate [clickhouse-jdbc-bridge](https://github.com/ClickHouse/clickhouse-jdbc-bridge) program to be running.
 It supports Nullable types (based on DDL of remote table that is queried).
 
+## Syntax {#syntax}
+
+```sql
+jdbc(datasource, schema, table)
+jdbc(datasource, table)
+jdbc(named_collection)
+```
+
 ## Examples {#examples}
 
 ```sql
diff --git a/docs/en/sql-reference/table-functions/odbc.md b/docs/en/sql-reference/table-functions/odbc.md
index 703dc49eb790..7fa5126ef1be 100644
--- a/docs/en/sql-reference/table-functions/odbc.md
+++ b/docs/en/sql-reference/table-functions/odbc.md
@@ -14,6 +14,8 @@ Returns table that is connected via [ODBC](https://en.wikipedia.org/wiki/Open_Da
 
 ```sql
 odbc(connection_settings, external_database, external_table)
+odbc(connection_settings, external_table)
+odbc(named_collection)
 ```
 
 ## Arguments {#arguments}
@@ -24,6 +26,8 @@ odbc(connection_settings, external_database, external_table)
 | `external_database` | Name of a database in an external DBMS.                                |
 | `external_table`    | Name of a table in the `external_database`.                            |
 
+These parameters can also be passed using [named collections](operations/named-collections.md).
+
 To safely implement ODBC connections, ClickHouse uses a separate program `clickhouse-odbc-bridge`. If the ODBC driver is loaded directly from `clickhouse-server`, driver problems can crash the ClickHouse server. ClickHouse automatically starts `clickhouse-odbc-bridge` when it is required. The ODBC bridge program is installed from the same package as the `clickhouse-server`.
 
 The fields with the `NULL` values from the external table are converted into the default values for the base data type. For example, if a remote MySQL table field has the `INT NULL` type it is converted to 0 (the default value for ClickHouse `Int32` data type).
diff --git a/src/Storages/StorageXDBC.cpp b/src/Storages/StorageXDBC.cpp
index a80bb610e1b4..58dd83a32ea0 100644
--- a/src/Storages/StorageXDBC.cpp
+++ b/src/Storages/StorageXDBC.cpp
@@ -3,6 +3,7 @@
 #include <Storages/StorageURL.h>
 #include <Storages/transformQueryForExternalDatabase.h>
 #include <Storages/checkAndGetLiteralArgument.h>
+#include <Storages/NamedCollectionsHelpers.h>
 
 #include <Core/ServerSettings.h>
 #include <Core/Settings.h>
@@ -184,22 +185,53 @@ namespace
         {
             ASTs & engine_args = args.engine_args;
 
-            if (engine_args.size() != 3)
-                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                    "Storage {} requires exactly 3 parameters: {}('DSN', database or schema, table)", name, name);
+            String connection_string;
+            String database_or_schema;
+            String table;
 
-            for (size_t i = 0; i < 3; ++i)
-                engine_args[i] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[i], args.getLocalContext());
+            if (auto named_collection = tryGetNamedCollectionWithOverrides(engine_args, args.getLocalContext()))
+            {
+                if (name == "JDBC")
+                {
+                    validateNamedCollection<>(*named_collection, {"datasource", "schema", "table"}, {});
+                    connection_string = named_collection->get<String>("datasource");
+                    database_or_schema = named_collection->get<String>("schema");
+                    table = named_collection->get<String>("table");
+                }
+                else
+                {
+                    validateNamedCollection<>(*named_collection, {"connection_settings", "external_database", "external_table"}, {});
+                    connection_string = named_collection->get<String>("connection_settings");
+                    database_or_schema = named_collection->get<String>("external_database");
+                    table = named_collection->get<String>("external_table");
+                }
+            }
+            else
+            {
+                if (engine_args.size() != 3)
+                    throw Exception(
+                        ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                        "Storage {} requires exactly 3 parameters: {}('DSN', database or schema, table)",
+                        name,
+                        name);
+
+                for (size_t i = 0; i < 3; ++i)
+                    engine_args[i] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[i], args.getLocalContext());
+
+                connection_string = checkAndGetLiteralArgument<String>(engine_args[0], "connection_string");
+                database_or_schema = checkAndGetLiteralArgument<String>(engine_args[1], "database_name");
+                table = checkAndGetLiteralArgument<String>(engine_args[2], "table_name");
+            }
 
             BridgeHelperPtr bridge_helper = std::make_shared<XDBCBridgeHelper<BridgeHelperMixin>>(
                 args.getContext(),
                 args.getContext()->getSettingsRef()[Setting::http_receive_timeout].value,
-                checkAndGetLiteralArgument<String>(engine_args[0], "connection_string"),
+                connection_string,
                 args.getContext()->getSettingsRef()[Setting::odbc_bridge_use_connection_pooling].value);
             return std::make_shared<StorageXDBC>(
                 args.table_id,
-                checkAndGetLiteralArgument<String>(engine_args[1], "database_name"),
-                checkAndGetLiteralArgument<String>(engine_args[2], "table_name"),
+                database_or_schema,
+                table,
                 args.columns,
                 args.constraints,
                 args.comment,
diff --git a/src/TableFunctions/ITableFunctionXDBC.cpp b/src/TableFunctions/ITableFunctionXDBC.cpp
index b2f3ce084450..491eb78b84de 100644
--- a/src/TableFunctions/ITableFunctionXDBC.cpp
+++ b/src/TableFunctions/ITableFunctionXDBC.cpp
@@ -10,6 +10,7 @@
 #include <Parsers/ASTLiteral.h>
 #include <Parsers/parseQuery.h>
 #include <Storages/StorageXDBC.h>
+#include <Storages/NamedCollectionsHelpers.h>
 #include <TableFunctions/ITableFunction.h>
 #include <TableFunctions/TableFunctionFactory.h>
 #include <Poco/Net/HTTPRequest.h>
@@ -35,6 +36,7 @@ namespace ErrorCodes
 {
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int LOGICAL_ERROR;
+    extern const int BAD_ARGUMENTS;
 }
 
 namespace
@@ -118,23 +120,54 @@ void ITableFunctionXDBC::parseArguments(const ASTPtr & ast_function, ContextPtr
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Table function '{}' must have arguments.", getName());
 
     ASTs & args = args_func.arguments->children;
-    if (args.size() != 2 && args.size() != 3)
-        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-            "Table function '{0}' requires 2 or 3 arguments: {0}('DSN', table) or {0}('DSN', schema, table)", getName());
 
-    for (auto & arg : args)
-        arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);
+    if (args.empty() || args.size() > 3)
+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+            "Table function '{0}' requires 1, 2 or 3 arguments: {0}(named_collection) or {0}('DSN', table) or {0}('DSN', schema, table)", getName());
 
-    if (args.size() == 3)
+    if (args.size() == 1)
     {
-        connection_string = args[0]->as<ASTLiteral &>().value.safeGet<String>();
-        schema_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();
-        remote_table_name = args[2]->as<ASTLiteral &>().value.safeGet<String>();
+        if (auto named_collection = tryGetNamedCollectionWithOverrides(ast_function->children.at(0)->children, context))
+        {
+            if (getName() == "JDBC")
+            {
+                validateNamedCollection<>(*named_collection, {"datasource"}, {"schema", "table"});
+                connection_string = named_collection->get<String>("datasource");
+                schema_name = named_collection->getOrDefault<String>("schema", "");
+                remote_table_name = named_collection->getOrDefault<String>("table", "");
+            }
+            else
+            {
+                validateNamedCollection<>(*named_collection, {"connection_settings"}, {"external_database", "external_table"});
+
+                connection_string = named_collection->get<String>("connection_settings");
+                schema_name = named_collection->getOrDefault<String>("external_database", "");
+                remote_table_name = named_collection->getOrDefault<String>("external_table", "");
+
+            }
+        }
+        else
+        {
+            throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                            "Table function '{0}' has 1 argument, it is expected to be named collection", getName());
+        }
     }
-    else if (args.size() == 2)
+    else
     {
-        connection_string = args[0]->as<ASTLiteral &>().value.safeGet<String>();
-        remote_table_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();
+        for (auto & arg : args)
+            arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);
+
+        if (args.size() == 3)
+        {
+            connection_string = args[0]->as<ASTLiteral &>().value.safeGet<String>();
+            schema_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();
+            remote_table_name = args[2]->as<ASTLiteral &>().value.safeGet<String>();
+        }
+        else if (args.size() == 2)
+        {
+            connection_string = args[0]->as<ASTLiteral &>().value.safeGet<String>();
+            remote_table_name = args[1]->as<ASTLiteral &>().value.safeGet<String>();
+        }
     }
 }
 
