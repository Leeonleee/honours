{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 69556,
  "instance_id": "ClickHouse__ClickHouse-69556",
  "issue_numbers": [
    "41971"
  ],
  "base_commit": "6597a8ed041ba1964740b4cd731f8ed2101c7e64",
  "patch": "diff --git a/src/Formats/ProtobufSerializer.cpp b/src/Formats/ProtobufSerializer.cpp\nindex 74c33e3a1d86..20426e8eccb5 100644\n--- a/src/Formats/ProtobufSerializer.cpp\n+++ b/src/Formats/ProtobufSerializer.cpp\n@@ -3322,125 +3322,139 @@ namespace\n                     }\n                 }\n \n+                /// Complex case: one or more columns are serialized as a nested message.\n                 for (const auto & [field_descriptor, suffix] : field_descriptors_with_suffixes)\n                 {\n-                    if (!suffix.empty())\n+                    if (suffix.empty())\n+                        continue;\n+\n+                    std::vector<size_t> nested_column_indices;\n+                    std::vector<std::string_view> nested_column_names;\n+                    nested_column_indices.reserve(num_columns - used_column_indices.size());\n+                    nested_column_names.reserve(num_columns - used_column_indices.size());\n+                    nested_column_indices.push_back(column_idx);\n+                    nested_column_names.push_back(suffix);\n+\n+                    for (size_t j : collections::range(column_idx + 1, num_columns))\n                     {\n-                        /// Complex case: one or more columns are serialized as a nested message.\n-                        std::vector<size_t> nested_column_indices;\n-                        std::vector<std::string_view> nested_column_names;\n-                        nested_column_indices.reserve(num_columns - used_column_indices.size());\n-                        nested_column_names.reserve(num_columns - used_column_indices.size());\n-                        nested_column_indices.push_back(column_idx);\n-                        nested_column_names.push_back(suffix);\n-\n-                        for (size_t j : collections::range(column_idx + 1, num_columns))\n-                        {\n-                            if (used_column_indices_sorted.count(j))\n-                                continue;\n-                            std::string_view other_suffix;\n-                            if (!columnNameStartsWithFieldName(column_names[j], *field_descriptor, other_suffix))\n-                                continue;\n-                            nested_column_indices.push_back(j);\n-                            nested_column_names.push_back(other_suffix);\n-                        }\n+                        if (used_column_indices_sorted.count(j))\n+                            continue;\n+                        std::string_view other_suffix;\n+                        if (!columnNameStartsWithFieldName(column_names[j], *field_descriptor, other_suffix))\n+                            continue;\n+                        nested_column_indices.push_back(j);\n+                        nested_column_names.push_back(other_suffix);\n+                    }\n+\n+                    DataTypes nested_data_types;\n+                    nested_data_types.reserve(nested_column_indices.size());\n+                    for (size_t j : nested_column_indices)\n+                        nested_data_types.push_back(data_types[j]);\n \n-                        DataTypes nested_data_types;\n-                        nested_data_types.reserve(nested_column_indices.size());\n-                        for (size_t j : nested_column_indices)\n-                            nested_data_types.push_back(data_types[j]);\n+                    /// Now we have up to `nested_message_column_names.size()` columns\n+                    /// which can be serialized as one or many nested message(s)\n \n-                        /// Now we have up to `nested_message_column_names.size()` columns\n-                        /// which can be serialized as a nested message.\n+                    /// If the field is repeated, and ALL matching columns are array, we serialize as an array of nested messages.\n+                    /// Otherwise, we first try to serialize those columns as one nested message,\n+                    /// then, if failed, as an array of nested messages (on condition if those columns are array).\n \n-                        /// We will try to serialize those columns as one nested message,\n-                        /// then, if failed, as an array of nested messages (on condition if those columns are array).\n-                        bool has_fallback_to_array_of_nested_messages = false;\n-                        if (field_descriptor->is_repeated())\n+                    bool repeated_field_matching_nested_columns_are_all_arrays = false;\n+                    bool repeated_field_matching_nested_columns_have_some_arrays = false;\n+                    if (field_descriptor->is_repeated())\n+                    {\n+                        repeated_field_matching_nested_columns_are_all_arrays = true;\n+                        for (const auto & nested_data_type : nested_data_types)\n                         {\n-                            bool has_arrays\n-                                = boost::range::find_if(\n-                                      nested_data_types, [](const DataTypePtr & dt) { return (dt->getTypeId() == TypeIndex::Array); })\n-                                != nested_data_types.end();\n-                            if (has_arrays)\n-                                has_fallback_to_array_of_nested_messages = true;\n+                            if (nested_data_type->getTypeId() == TypeIndex::Array)\n+                                repeated_field_matching_nested_columns_have_some_arrays = true;\n+                            else\n+                                repeated_field_matching_nested_columns_are_all_arrays = false;\n                         }\n+                    }\n \n-                        /// Try to serialize those columns as one nested message.\n-                        try\n-                        {\n-                            std::vector<size_t> used_column_indices_in_nested;\n-                            auto nested_message_serializer = buildMessageSerializerImpl(\n-                                nested_column_names.size(),\n-                                nested_column_names.data(),\n-                                nested_data_types.data(),\n-                                *field_descriptor->message_type(),\n-                                /* with_length_delimiter = */ false,\n-                                google_wrappers_special_treatment,\n-                                field_descriptor,\n-                                used_column_indices_in_nested,\n-                                /* columns_are_reordered_outside = */ true,\n-                                /* check_nested_while_filling_missing_columns = */ false);\n+                    std::vector<size_t> used_column_indices_in_nested;\n+                    auto attempt_build_serializer = [&](const DataTypes & passed_nested_data_types)\n+                    {\n+                        return buildMessageSerializerImpl(\n+                            nested_column_names.size(),\n+                            nested_column_names.data(),\n+                            passed_nested_data_types.data(),\n+                            *field_descriptor->message_type(),\n+                            /* with_length_delimiter = */ false,\n+                            google_wrappers_special_treatment,\n+                            field_descriptor,\n+                            used_column_indices_in_nested,\n+                            /* columns_are_reordered_outside = */ true,\n+                            /* check_nested_while_filling_missing_columns = */ false);\n \n-                            /// `columns_are_reordered_outside` is true because column indices are\n-                            /// going to be transformed and then written to the outer message,\n-                            /// see add_field_serializer() below.\n+                        /// `columns_are_reordered_outside` is true because column indices are\n+                        /// going to be transformed and then written to the outer message,\n+                        /// see next calls to add_field_serializer() further below.\n+                    };\n \n-                            if (nested_message_serializer)\n-                            {\n-                                transformColumnIndices(used_column_indices_in_nested, nested_column_indices);\n-                                add_field_serializer(\n-                                    column_name,\n-                                    std::move(used_column_indices_in_nested),\n-                                    *field_descriptor,\n-                                    std::move(nested_message_serializer));\n-                                break;\n-                            }\n-                        }\n-                        catch (Exception & e)\n+                    auto attempt_unwrap_and_build_array_serializer = [&]()\n+                    {\n+                        DataTypes unwrapped_nested_data_types;\n+                        unwrapped_nested_data_types.reserve(nested_data_types.size());\n+\n+                        for (DataTypePtr & dt : nested_data_types)\n+                            unwrapped_nested_data_types.push_back(assert_cast<const DataTypeArray &>(*dt).getNestedType());\n+\n+                        if (auto serializer = attempt_build_serializer(unwrapped_nested_data_types))\n                         {\n-                            if ((e.code() != ErrorCodes::PROTOBUF_FIELD_NOT_REPEATED) || !has_fallback_to_array_of_nested_messages)\n-                                throw;\n+                            std::vector<std::string_view> column_names_used;\n+                            column_names_used.reserve(used_column_indices_in_nested.size());\n+                            for (const size_t i : used_column_indices_in_nested)\n+                                column_names_used.emplace_back(nested_column_names[i]);\n+\n+                            auto array_serializer = std::make_unique<ProtobufSerializerFlattenedNestedAsArrayOfNestedMessages>(\n+                            std::move(column_names_used), field_descriptor, std::move(serializer), get_root_desc_function);\n+\n+                            transformColumnIndices(used_column_indices_in_nested, nested_column_indices);\n+                            add_field_serializer(column_name,std::move(used_column_indices_in_nested), *field_descriptor, std::move(array_serializer));\n+\n+                            return true;\n                         }\n \n-                        if (has_fallback_to_array_of_nested_messages)\n-                        {\n-                            /// Try to serialize those columns as an array of nested messages.\n-                            removeNonArrayElements(nested_data_types, nested_column_names, nested_column_indices);\n-                            for (DataTypePtr & dt : nested_data_types)\n-                                dt = assert_cast<const DataTypeArray &>(*dt).getNestedType();\n-\n-                            std::vector<size_t> used_column_indices_in_nested;\n-                            auto nested_message_serializer = buildMessageSerializerImpl(\n-                                nested_column_names.size(),\n-                                nested_column_names.data(),\n-                                nested_data_types.data(),\n-                                *field_descriptor->message_type(),\n-                                /* with_length_delimiter = */ false,\n-                                google_wrappers_special_treatment,\n-                                field_descriptor,\n-                                used_column_indices_in_nested,\n-                                /* columns_are_reordered_outside = */ true,\n-                                /* check_nested_while_filling_missing_columns = */ false);\n+                        return false;\n+                    };\n \n-                            /// `columns_are_reordered_outside` is true because column indices are\n-                            /// going to be transformed and then written to the outer message,\n-                            /// see add_field_serializer() below.\n+                    /// if the protobuf field has the repeated label,\n+                    /// for ALL matching nested cols, since they are all of type array\n+                    /// try as ProtobufSerializerFlattenedNestedAsArrayOfNestedMessages\n+                    if (repeated_field_matching_nested_columns_are_all_arrays)\n+                    {\n+                        if (attempt_unwrap_and_build_array_serializer())\n+                            break;\n+                    }\n \n-                            if (nested_message_serializer)\n-                            {\n-                                std::vector<std::string_view> column_names_used;\n-                                column_names_used.reserve(used_column_indices_in_nested.size());\n-                                for (size_t i : used_column_indices_in_nested)\n-                                    column_names_used.emplace_back(nested_column_names[i]);\n-                                auto field_serializer = std::make_unique<ProtobufSerializerFlattenedNestedAsArrayOfNestedMessages>(\n-                                    std::move(column_names_used), field_descriptor, std::move(nested_message_serializer), get_root_desc_function);\n-                                transformColumnIndices(used_column_indices_in_nested, nested_column_indices);\n-                                add_field_serializer(column_name, std::move(used_column_indices_in_nested), *field_descriptor, std::move(field_serializer));\n-                                break;\n-                            }\n+                    /// for ALL matching nested cols\n+                    /// try as ProtobufSerializerMessage\n+                    try\n+                    {\n+                        if (auto serializer = attempt_build_serializer(nested_data_types))\n+                        {\n+                            transformColumnIndices(used_column_indices_in_nested, nested_column_indices);\n+                            add_field_serializer(column_name,std::move(used_column_indices_in_nested), *field_descriptor, std::move(serializer));\n+                            break;\n                         }\n                     }\n+\n+                    catch (Exception & e)\n+                    {\n+                        if ((e.code() != ErrorCodes::PROTOBUF_FIELD_NOT_REPEATED) || !repeated_field_matching_nested_columns_have_some_arrays)\n+                            throw;\n+                    }\n+\n+                    /// if the protobuf field has the repeated label,\n+                    /// only for the SUBSET of matching nested cols that are of type Array,\n+                    /// try as ProtobufSerializerFlattenedNestedAsArrayOfNestedMessages\n+                    if (repeated_field_matching_nested_columns_have_some_arrays)\n+                    {\n+                        removeNonArrayElements(nested_data_types, nested_column_names, nested_column_indices);\n+                        if (attempt_unwrap_and_build_array_serializer())\n+                            break;\n+                    }\n                 }\n             }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03234_proto_complex_nested_repeated_noexception.reference b/tests/queries/0_stateless/03234_proto_complex_nested_repeated_noexception.reference\nnew file mode 100644\nindex 000000000000..cae461492b54\n--- /dev/null\n+++ b/tests/queries/0_stateless/03234_proto_complex_nested_repeated_noexception.reference\n@@ -0,0 +1,3 @@\n+{\"error_not_raised\":1}\n+{\"i\":1001,\"j.k\":[2101,2102],\"j.l\":[2201,2202],\"m\":3001,\"n\":[4001,4002,4003,4004],\"o.key\":[5001,5002],\"o.value\":[{\"p\":[{\"q\":5111,\"r\":5121}]},{\"p\":[{\"q\":5112,\"r\":5122},{\"q\":5113,\"r\":5123}]}]}\n+{\"i\":6001,\"j.k\":[7101],\"j.l\":[7201],\"m\":8001,\"n\":[],\"o.key\":[9001],\"o.value\":[{\"p\":[{\"q\":10111,\"r\":10121}]}]}\ndiff --git a/tests/queries/0_stateless/03234_proto_complex_nested_repeated_noexception.sh b/tests/queries/0_stateless/03234_proto_complex_nested_repeated_noexception.sh\nnew file mode 100755\nindex 000000000000..47541dd4f5db\n--- /dev/null\n+++ b/tests/queries/0_stateless/03234_proto_complex_nested_repeated_noexception.sh\n@@ -0,0 +1,50 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+mkdir -p \"${CLICKHOUSE_SCHEMA_FILES}\"\n+SOURCE_SCHEMA_FILE=\"${CURDIR}/format_schemas/03234_proto_complex_nested_repeated_noexception.proto\"\n+TARGET_SCHEMA_FILE=\"${CLICKHOUSE_SCHEMA_FILES}/03234_proto_complex_nested_repeated_noexception.proto\"\n+cp \"${SOURCE_SCHEMA_FILE}\" \"${TARGET_SCHEMA_FILE}\"\n+\n+cat <<'EOF' | $CLICKHOUSE_CLIENT -mn\n+\n+DROP TABLE IF EXISTS exception_counter ;\n+CREATE TABLE exception_counter (`val` UInt32) ENGINE = Memory ;\n+INSERT INTO exception_counter SELECT sum(value) FROM system.errors WHERE name = 'PROTOBUF_FIELD_NOT_REPEATED' ;\n+\n+DROP TABLE IF EXISTS table_file ;\n+CREATE TABLE table_file (\n+    `i`     UInt32,\n+    `j.k`   Array(UInt32),\n+    `j.l`   Array(UInt32),\n+    `m`     UInt32,\n+    `n`     Array(UInt32),\n+    `o`     Nested(\n+                `key`   UInt32,\n+                `value` Tuple(\n+                    `p` Nested(\n+                        `q` UInt32,\n+                        `r` UInt32\n+                    )\n+                )\n+            )\n+) ENGINE File(Protobuf) SETTINGS format_schema = '03234_proto_complex_nested_repeated_noexception.proto:A' ;\n+\n+INSERT INTO table_file VALUES\n+( 1001, [2101, 2102], [2201, 2202], 3001, [4001, 4002, 4003, 4004], [5001,5002] , [ ([(5111,5121)]), ([(5112,5122),(5113,5123)]) ] ),\n+( 6001, [7101], [7201], 8001, [], [9001] , [ ([(10111,10121)]) ] ) ;\n+\n+INSERT INTO exception_counter SELECT sum(value) FROM system.errors WHERE name = 'PROTOBUF_FIELD_NOT_REPEATED' ;\n+SELECT min(val) == max(val) as error_not_raised FROM exception_counter FORMAT JSONEachRow ;\n+\n+SELECT * FROM table_file FORMAT JSONEachRow ;\n+\n+DROP TABLE exception_counter ;\n+DROP TABLE table_file ;\n+\n+EOF\n+\n+rm -f \"${TARGET_SCHEMA_FILE}\"\ndiff --git a/tests/queries/0_stateless/03234_proto_simple_nested_repeated_noexception.reference b/tests/queries/0_stateless/03234_proto_simple_nested_repeated_noexception.reference\nnew file mode 100644\nindex 000000000000..8618ac3e0729\n--- /dev/null\n+++ b/tests/queries/0_stateless/03234_proto_simple_nested_repeated_noexception.reference\n@@ -0,0 +1,5 @@\n+{\"error_not_raised\":1}\n+{\"u\":1001,\"v.w\":[],\"v.x\":[],\"v.y\":[],\"v.z\":[]}\n+{\"u\":2002,\"v.w\":[2102],\"v.x\":[2202],\"v.y\":[[2302]],\"v.z\":[[2402,2403]]}\n+{\"u\":3003,\"v.w\":[3103,3104],\"v.x\":[3203,3204],\"v.y\":[[3303],[3304]],\"v.z\":[[3403,3404],[3405,3406]]}\n+{\"u\":4004,\"v.w\":[4104,4105,4106],\"v.x\":[4204,4205,4206],\"v.y\":[[4304],[4305],[4306]],\"v.z\":[[4304,4305],[4306,4307],[4308,4309]]}\ndiff --git a/tests/queries/0_stateless/03234_proto_simple_nested_repeated_noexception.sh b/tests/queries/0_stateless/03234_proto_simple_nested_repeated_noexception.sh\nnew file mode 100755\nindex 000000000000..a20c2ba12a6a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03234_proto_simple_nested_repeated_noexception.sh\n@@ -0,0 +1,44 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+mkdir -p \"${CLICKHOUSE_SCHEMA_FILES}\"\n+SOURCE_SCHEMA_FILE=\"${CURDIR}/format_schemas/03234_proto_simple_nested_repeated_noexception.proto\"\n+TARGET_SCHEMA_FILE=\"${CLICKHOUSE_SCHEMA_FILES}/03234_proto_simple_nested_repeated_noexception.proto\"\n+cp \"${SOURCE_SCHEMA_FILE}\" \"${TARGET_SCHEMA_FILE}\"\n+\n+cat <<'EOF' | $CLICKHOUSE_CLIENT -mn\n+\n+DROP TABLE IF EXISTS exception_counter ;\n+CREATE TABLE exception_counter (`val` UInt32) ENGINE = Memory ;\n+INSERT INTO exception_counter SELECT sum(value) FROM system.errors WHERE name = 'PROTOBUF_FIELD_NOT_REPEATED' ;\n+\n+DROP TABLE IF EXISTS table_file ;\n+CREATE TABLE table_file (\n+    `u`     UInt32,\n+    `v.w`   Array(UInt32),\n+    `v.x`   Array(UInt32),\n+    `v.y`   Array(Array(UInt32)),\n+    `v.z`   Array(Array(UInt32))\n+) ENGINE File(Protobuf) SETTINGS format_schema = '03234_proto_simple_nested_repeated_noexception.proto:M' ;\n+\n+INSERT INTO table_file VALUES\n+( 1001, [], [], [], []),\n+( 2002, [2102], [2202], [[2302]], [[2402, 2403]]),\n+( 3003, [3103, 3104], [3203, 3204], [[3303], [3304]], [[3403, 3404], [3405, 3406]]),\n+( 4004, [4104, 4105, 4106], [4204, 4205, 4206], [[4304], [4305], [4306]], [[4304, 4305], [4306, 4307], [4308, 4309]]);\n+\n+\n+INSERT INTO exception_counter SELECT sum(value) FROM system.errors WHERE name = 'PROTOBUF_FIELD_NOT_REPEATED' ;\n+SELECT min(val) == max(val) as error_not_raised FROM exception_counter FORMAT JSONEachRow ;\n+\n+SELECT * FROM table_file FORMAT JSONEachRow ;\n+\n+DROP TABLE exception_counter ;\n+DROP TABLE table_file ;\n+\n+EOF\n+\n+rm -f \"${TARGET_SCHEMA_FILE}\"\ndiff --git a/tests/queries/0_stateless/format_schemas/03234_proto_complex_nested_repeated_noexception.proto b/tests/queries/0_stateless/format_schemas/03234_proto_complex_nested_repeated_noexception.proto\nnew file mode 100644\nindex 000000000000..02d88dbd7198\n--- /dev/null\n+++ b/tests/queries/0_stateless/format_schemas/03234_proto_complex_nested_repeated_noexception.proto\n@@ -0,0 +1,25 @@\n+syntax = \"proto3\";\n+\n+message A {\n+  message B {\n+    uint32 k = 2100 ;\n+    uint32 l = 2200 ;\n+  }\n+\n+  uint32     i = 1000 ;\n+  repeated B j = 2000 ;\n+  uint32     m = 3000 ;\n+\n+  repeated uint32 n = 4000 ;\n+\n+  map<uint32, C> o = 5000 ;\n+}\n+\n+message D {\n+  uint32 q = 5110 ;\n+  uint32 r = 5120 ;\n+}\n+\n+message C {\n+  repeated D p = 5100 ;\n+}\ndiff --git a/tests/queries/0_stateless/format_schemas/03234_proto_simple_nested_repeated_noexception.proto b/tests/queries/0_stateless/format_schemas/03234_proto_simple_nested_repeated_noexception.proto\nnew file mode 100644\nindex 000000000000..fe766c4df20f\n--- /dev/null\n+++ b/tests/queries/0_stateless/format_schemas/03234_proto_simple_nested_repeated_noexception.proto\n@@ -0,0 +1,13 @@\n+syntax = \"proto3\";\n+\n+message M {\n+  uint32     u = 1000 ;\n+  repeated N v = 2000 ;\n+\n+  message N {\n+    uint32          w = 2100 ;\n+    uint32          x = 2200 ;\n+    repeated uint32 y = 2300 ;\n+    repeated uint32 z = 2400 ;\n+  }\n+}\n",
  "problem_statement": "PROTOBUF_FIELD_NOT_REPEATED when ingesting from Kafka\n**Describe what's wrong**\r\n\r\nWith a protobuf schema using a repeated message, setting up Kafka to use this schema to import into a table leads to the `PROTOBUF_FIELD_NOT_REPEATED` error. This does not happen when ingesting from `clickhouse-client`.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nReproduced on 22.8.5.29.\r\n\r\n**How to reproduce**\r\n\r\nUsing the 22.8 Docker image:\r\n1. put `flow-3.proto` in `/var/lib/clickhouse/format_schemas`\r\n2. create the Kafka table and one consumer, no need to get messages from Kafka\r\n\r\n```protobuf\r\nsyntax = \"proto3\";\r\npackage decoder;\r\n\r\nmessage FlowMessagev3 {\r\n  uint64 TimeReceived = 2;\r\n  repeated LargeCommunity DstLargeCommunities = 37;\r\n  message LargeCommunity {\r\n    uint32 ASN = 1;\r\n    uint32 LocalData1 = 2;\r\n    uint32 LocalData2 = 3;\r\n  }\r\n}\r\n```\r\n\r\n```sql\r\nCREATE TABLE default.flows_3_raw\r\n(\r\n    `TimeReceived` DateTime CODEC(DoubleDelta, LZ4),\r\n    `DstLargeCommunities.ASN` Array(UInt32),\r\n    `DstLargeCommunities.LocalData1` Array(UInt32),\r\n    `DstLargeCommunities.LocalData2` Array(UInt32)\r\n)\r\nENGINE = Kafka\r\nSETTINGS kafka_broker_list = 'kafka:9092', kafka_topic_list = 'flows-v3', kafka_group_name = 'clickhouse', kafka_format = 'Protobuf', kafka_schema = 'flow-3.proto:FlowMessagev3', kafka_num_consumers = 1, kafka_thread_per_consumer = 1\r\n\r\nCREATE TABLE default.flows\r\n(\r\n    `TimeReceived` DateTime CODEC(DoubleDelta, LZ4),\r\n    `DstLargeCommunities.ASN` Array(UInt32),\r\n    `DstLargeCommunities.LocalData1` Array(UInt32),\r\n    `DstLargeCommunities.LocalData2` Array(UInt32)\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toYYYYMMDDhhmmss(toStartOfInterval(TimeReceived, toIntervalSecond(25920)))\r\nORDER BY TimeReceived\r\nTTL TimeReceived + toIntervalSecond(1296000)\r\nSETTINGS index_granularity = 8192\r\n\r\nCREATE MATERIALIZED VIEW default.flows_3_raw_consumer TO default.flows\r\nAS SELECT * FROM default.flows_3_raw\r\n```\r\n\r\nThen, check `system.errors`. I get:\r\n\r\n```\r\nname:               PROTOBUF_FIELD_NOT_REPEATED\r\ncode:               437\r\nvalue:              440\r\nlast_error_time:    2022-09-30 13:20:34\r\nlast_error_message: The field 'decoder.FlowMessagev3.LargeCommunity.ASN' must be repeated in the protobuf schema to match the column `ASN`\r\nlast_error_trace:   [171727226,366135675,366093641,366067646,366064173,366058066,366045826,366464972,366468882,364681438,337788230,337801743,364844405,364843206,364960586,364912827,364908569,364908061,364902892,337747165,337739135,333703256,333713718,333717100,172520264,172533085,140334772680201,140334771781939]\r\nremote:             0\r\n```\r\n\r\n**Expected behavior**\r\n\r\nNo error in `system.errors`.\r\n\r\n**Additional context**\r\n\r\nIt should be noted that sending messages work, including when they have a `DstLargeCommunity` field. They appear in the `flows` table without any issue.\r\n\r\ncc @lesandie \n",
  "hints_text": "To add to this description, this is still valid and I can reproduce it with ClickHouse master ( at time of writing ).\r\n\r\n---\r\n\r\nIf I understand correctly, this is related to the current implementation using an exception based flow when attempting to ser/de a `Nested(Array(___))` from/into `message { repeated message { ___ } }` .\r\n\r\nThe code causing this behaviour is here : https://github.com/ClickHouse/ClickHouse/blob/33268f81441512c87d8cbd38976acea1a325630d/src/Formats/ProtobufSerializer.cpp#L3402\r\n\r\n\u27a1\ufe0f  **It first tries to ser/de as a _single_ item, and if the PROTOBUF_FIELD_NOT_REPEATED is thrown, then catches it and attempts as a series of _multiple_ messages _instead_.**\r\n\r\nThe fact the exception is generated in the first place (even though it is caught afterwards) is why we can find it in the counters of `system.errors`. \r\n\r\n---\r\n\r\nI have been playing around with switching this logic around, ( adding an if checking that all matching nested columns are of type array, and attempting ser/de as multiple messages right away ) and it appears to behave without generating exceptions ( and ser/de correctly my test data \ud83d\ude4c  ).\r\n\r\nI will open a PR with these changes to see if it is of interest to the maintainers in the coming days ( as soon as I can get a proper functional test for this ( _I'm facing some weird networking issues in the containers of the functional tests so I can't run them yet_ ))\r\n\r\nI believe the reason it does not appear with clickhouse-client is the same reason I need a functional test rather than a simple stateless one : clickhouse-client probably operates the ser/de internally before sending it to the server. So I believe the error is generated, but not server-side, client side instead. And unless I'm missing something, error counters from the client are not visible/accessible.\r\n\r\n---\r\n\r\nThe reason I ended up here is mostly one of performance. \u2668\ufe0f \r\n\r\nSince an equivalent of https://github.com/ClickHouse/ClickHouse/pull/59482 ( cc. https://github.com/ClickHouse/ClickHouse/issues/65297 ) hasn't been reached yet, this error is going to be thrown for **_EVERY_** row being deserialized from the Kafka engine ( matching schema described above ).\r\n\r\n I have been observing on a test cluster (with `perf`) that clickhouse was spending **_ABOVE 40% OF CPU TIME_** in `libunwind::*` generating stack traces for this error \ud83e\udd2f , so this behaviour is quite the performance bottleneck in the current implementation in ClickHouse master.\r\n \r\nHopefully if I get a first PR to address this topic merged in, we might already see some perf winnings before clickhouse gets the reuse of the deserializer impl working in tip-top shape ( that would be muchas better perf-wise ) \ud83d\udc4c \r\n ",
  "created_at": "2024-09-12T13:30:10Z"
}