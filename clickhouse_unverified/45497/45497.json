{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 45497,
  "instance_id": "ClickHouse__ClickHouse-45497",
  "issue_numbers": [
    "45486"
  ],
  "base_commit": "f818e3070db443021bf51d08d3fb467bee2b5b22",
  "patch": "diff --git a/src/Backups/BackupsWorker.cpp b/src/Backups/BackupsWorker.cpp\nindex 2d9bd3009120..924acc16d635 100644\n--- a/src/Backups/BackupsWorker.cpp\n+++ b/src/Backups/BackupsWorker.cpp\n@@ -160,17 +160,6 @@ OperationID BackupsWorker::startMakingBackup(const ASTPtr & query, const Context\n     else\n         backup_id = toString(*backup_settings.backup_uuid);\n \n-    /// Check if there are no concurrent backups\n-    if (num_active_backups && !allow_concurrent_backups)\n-    {\n-        /// If its an internal backup and we currently have 1 active backup, it could be the original query, validate using backup_uuid\n-        if (!(num_active_backups == 1 && backup_settings.internal && getAllActiveBackupInfos().at(0).id == toString(*backup_settings.backup_uuid)))\n-        {\n-            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED,\n-                            \"Concurrent backups not supported, turn on setting 'allow_concurrent_backups'\");\n-        }\n-    }\n-\n     std::shared_ptr<IBackupCoordination> backup_coordination;\n     if (backup_settings.internal)\n     {\n@@ -184,6 +173,13 @@ OperationID BackupsWorker::startMakingBackup(const ASTPtr & query, const Context\n     String backup_name_for_logging = backup_info.toStringForLogging();\n     try\n     {\n+        if (!allow_concurrent_backups && hasConcurrentBackups(backup_settings))\n+        {\n+            /// addInfo is called here to record the failed backup details\n+            addInfo(backup_id, backup_name_for_logging, backup_settings.internal, BackupStatus::BACKUP_FAILED);\n+            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED, \"Concurrent backups not supported, turn on setting 'allow_concurrent_backups'\");\n+        }\n+\n         addInfo(backup_id, backup_name_for_logging, backup_settings.internal, BackupStatus::CREATING_BACKUP);\n \n         /// Prepare context to use.\n@@ -384,8 +380,8 @@ OperationID BackupsWorker::startRestoring(const ASTPtr & query, ContextMutablePt\n     auto restore_query = std::static_pointer_cast<ASTBackupQuery>(query->clone());\n     auto restore_settings = RestoreSettings::fromRestoreQuery(*restore_query);\n \n-    if (!restore_settings.backup_uuid)\n-        restore_settings.backup_uuid = UUIDHelpers::generateV4();\n+    if (!restore_settings.restore_uuid)\n+        restore_settings.restore_uuid = UUIDHelpers::generateV4();\n \n     /// `restore_id` will be used as a key to the `infos` map, so it should be unique.\n     OperationID restore_id;\n@@ -394,18 +390,7 @@ OperationID BackupsWorker::startRestoring(const ASTPtr & query, ContextMutablePt\n     else if (!restore_settings.id.empty())\n         restore_id = restore_settings.id;\n     else\n-        restore_id = toString(*restore_settings.backup_uuid);\n-\n-    /// Check if there are no concurrent restores\n-    if (num_active_restores && !allow_concurrent_restores)\n-    {\n-        /// If its an internal restore and we currently have 1 active restore, it could be the original query, validate using iz\n-        if (!(num_active_restores == 1 && restore_settings.internal && getAllActiveRestoreInfos().at(0).id == toString(*restore_settings.backup_uuid)))\n-        {\n-            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED,\n-                            \"Concurrent restores not supported, turn on setting 'allow_concurrent_restores'\");\n-        }\n-    }\n+        restore_id = toString(*restore_settings.restore_uuid);\n \n     std::shared_ptr<IRestoreCoordination> restore_coordination;\n     if (restore_settings.internal)\n@@ -420,6 +405,14 @@ OperationID BackupsWorker::startRestoring(const ASTPtr & query, ContextMutablePt\n     {\n         auto backup_info = BackupInfo::fromAST(*restore_query->backup_name);\n         String backup_name_for_logging = backup_info.toStringForLogging();\n+\n+        if (!allow_concurrent_restores && hasConcurrentRestores(restore_settings))\n+        {\n+            /// addInfo is called here to record the failed restore details\n+            addInfo(restore_id, backup_name_for_logging, restore_settings.internal, BackupStatus::RESTORING);\n+            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED, \"Concurrent restores not supported, turn on setting 'allow_concurrent_restores'\");\n+        }\n+\n         addInfo(restore_id, backup_name_for_logging, restore_settings.internal, BackupStatus::RESTORING);\n \n         /// Prepare context to use.\n@@ -499,7 +492,7 @@ void BackupsWorker::doRestore(\n         backup_open_params.context = context;\n         backup_open_params.backup_info = backup_info;\n         backup_open_params.base_backup_info = restore_settings.base_backup_info;\n-        backup_open_params.backup_uuid = restore_settings.backup_uuid;\n+        backup_open_params.backup_uuid = restore_settings.restore_uuid;\n         backup_open_params.password = restore_settings.password;\n         BackupPtr backup = BackupFactory::instance().createBackup(backup_open_params);\n \n@@ -740,6 +733,34 @@ std::vector<BackupsWorker::Info> BackupsWorker::getAllActiveRestoreInfos() const\n     return res_infos;\n }\n \n+bool BackupsWorker::hasConcurrentBackups(const BackupSettings & backup_settings) const\n+{\n+    /// Check if there are no concurrent backups\n+    if (num_active_backups)\n+    {\n+        /// If its an internal backup and we currently have 1 active backup, it could be the original query, validate using backup_uuid\n+        if (!(num_active_backups == 1 && backup_settings.internal && getAllActiveBackupInfos().at(0).id == toString(*backup_settings.backup_uuid)))\n+        {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n+bool BackupsWorker::hasConcurrentRestores(const RestoreSettings & restore_settings) const\n+{\n+    /// Check if there are no concurrent restores\n+    if (num_active_restores)\n+    {\n+        /// If its an internal restore and we currently have 1 active restore, it could be the original query, validate using iz\n+        if (!(num_active_restores == 1 && restore_settings.internal && getAllActiveRestoreInfos().at(0).id == toString(*restore_settings.restore_uuid)))\n+        {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n+\n void BackupsWorker::shutdown()\n {\n     bool has_active_backups_and_restores = (num_active_backups || num_active_restores);\ndiff --git a/src/Backups/BackupsWorker.h b/src/Backups/BackupsWorker.h\nindex b6d9729833e8..98ba9d10e93d 100644\n--- a/src/Backups/BackupsWorker.h\n+++ b/src/Backups/BackupsWorker.h\n@@ -105,6 +105,8 @@ class BackupsWorker\n     void setNumFilesAndSize(const OperationID & id, size_t num_files, UInt64 uncompressed_size, UInt64 compressed_size);\n     std::vector<Info> getAllActiveBackupInfos() const;\n     std::vector<Info> getAllActiveRestoreInfos() const;\n+    bool hasConcurrentBackups(const BackupSettings & backup_settings) const;\n+    bool hasConcurrentRestores(const RestoreSettings & restore_settings) const;\n \n     ThreadPool backups_thread_pool;\n     ThreadPool restores_thread_pool;\ndiff --git a/src/Backups/RestoreSettings.cpp b/src/Backups/RestoreSettings.cpp\nindex 0ffa48224f7b..5e06764a2474 100644\n--- a/src/Backups/RestoreSettings.cpp\n+++ b/src/Backups/RestoreSettings.cpp\n@@ -164,7 +164,7 @@ namespace\n     M(Bool, internal) \\\n     M(String, host_id) \\\n     M(String, coordination_zk_path) \\\n-    M(OptionalUUID, backup_uuid)\n+    M(OptionalUUID, restore_uuid)\n \n \n RestoreSettings RestoreSettings::fromRestoreQuery(const ASTBackupQuery & query)\ndiff --git a/src/Backups/RestoreSettings.h b/src/Backups/RestoreSettings.h\nindex 50058d83a25b..3bfe9f869ea5 100644\n--- a/src/Backups/RestoreSettings.h\n+++ b/src/Backups/RestoreSettings.h\n@@ -123,9 +123,9 @@ struct RestoreSettings\n     String coordination_zk_path;\n \n     /// Internal, should not be specified by user.\n-    /// UUID of the backup. If it's not set it will be generated randomly.\n+    /// UUID of the restore. If it's not set it will be generated randomly.\n     /// This is used to validate internal restores when allow_concurrent_restores is turned off\n-    std::optional<UUID> backup_uuid;\n+    std::optional<UUID> restore_uuid;\n \n     static RestoreSettings fromRestoreQuery(const ASTBackupQuery & query);\n     void copySettingsToQuery(ASTBackupQuery & query) const;\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 6be0678a01a7..f0dd8de8e56c 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -1890,8 +1890,8 @@ BackupsWorker & Context::getBackupsWorker() const\n {\n     auto lock = getLock();\n \n-    const bool allow_concurrent_backups = this->getConfigRef().getBool(\"allow_concurrent_backups\", true);\n-    const bool allow_concurrent_restores = this->getConfigRef().getBool(\"allow_concurrent_restores\", true);\n+    const bool allow_concurrent_backups = this->getConfigRef().getBool(\"backups.allow_concurrent_backups\", true);\n+    const bool allow_concurrent_restores = this->getConfigRef().getBool(\"backups.allow_concurrent_restores\", true);\n \n     if (!shared->backups_worker)\n         shared->backups_worker.emplace(getSettingsRef().backup_threads, getSettingsRef().restore_threads, allow_concurrent_backups, allow_concurrent_restores);\n",
  "test_patch": "diff --git a/tests/integration/test_backup_restore_on_cluster/configs/disallow_concurrency.xml b/tests/integration/test_backup_restore_on_cluster/configs/disallow_concurrency.xml\nindex 144be77c9f92..9e67f54f8e85 100644\n--- a/tests/integration/test_backup_restore_on_cluster/configs/disallow_concurrency.xml\n+++ b/tests/integration/test_backup_restore_on_cluster/configs/disallow_concurrency.xml\n@@ -9,7 +9,7 @@\n     </storage_configuration>\n     <backups>\n         <allowed_disk>backups</allowed_disk>\n+        <allow_concurrent_backups>false</allow_concurrent_backups>\n+        <allow_concurrent_restores>false</allow_concurrent_restores>\n     </backups>\n-    <allow_concurrent_backups>false</allow_concurrent_backups>\n-    <allow_concurrent_restores>false</allow_concurrent_restores>\n </clickhouse>\ndiff --git a/tests/integration/test_backup_restore_on_cluster/test_disallow_concurrency.py b/tests/integration/test_backup_restore_on_cluster/test_disallow_concurrency.py\nindex 8f514b95d0b0..43e7682ec1d0 100644\n--- a/tests/integration/test_backup_restore_on_cluster/test_disallow_concurrency.py\n+++ b/tests/integration/test_backup_restore_on_cluster/test_disallow_concurrency.py\n@@ -148,10 +148,14 @@ def test_concurrent_backups_on_different_nodes():\n \n     backup_name = new_backup_name()\n \n-    nodes[1].query(f\"BACKUP TABLE tbl ON CLUSTER 'cluster' TO {backup_name} ASYNC\")\n+    id = (\n+        nodes[1]\n+        .query(f\"BACKUP TABLE tbl ON CLUSTER 'cluster' TO {backup_name} ASYNC\")\n+        .split(\"\\t\")[0]\n+    )\n     assert_eq_with_retry(\n         nodes[1],\n-        f\"SELECT status FROM system.backups WHERE status == 'CREATING_BACKUP'\",\n+        f\"SELECT status FROM system.backups WHERE status == 'CREATING_BACKUP' AND id = '{id}'\",\n         \"CREATING_BACKUP\",\n     )\n     assert \"Concurrent backups not supported\" in nodes[2].query_and_get_error(\n",
  "problem_statement": "Flaky test_backup_restore_on_cluster/test_disallow_concurrency.py\nThis test is to check if disallowing of concurrent backups & restores works as expected. \r\nWhen one backup/restore fails, the status is not updated properly, thus we need to set the status of backup/restore so that other nodes in cluster are aware of failures.\r\n\r\nSome occurences : \r\nhttps://play.clickhouse.com/play?user=play#c2VsZWN0IAp0b1N0YXJ0T2ZIb3VyKGNoZWNrX3N0YXJ0X3RpbWUpIGFzIGQsCmNvdW50KCksICBncm91cFVuaXFBcnJheShwdWxsX3JlcXVlc3RfbnVtYmVyKSwgIGFueShyZXBvcnRfdXJsKQpmcm9tIGNoZWNrcyB3aGVyZSAnMjAyMi0wNi0wMScgPD0gY2hlY2tfc3RhcnRfdGltZSBhbmQgdGVzdF9uYW1lIGxpa2UgJyV0ZXN0X2JhY2t1cF9yZXN0b3JlX29uX2NsdXN0ZXIvdGVzdF9kaXNhbGxvd19jb25jdXJyZW5jeS5weSUnIGFuZCB0ZXN0X3N0YXR1cyBpbiAoJ0ZBSUwnLCAnRkxBS1knKSBncm91cCBieSBkIG9yZGVyIGJ5IGQgZGVzYw==\n",
  "hints_text": "",
  "created_at": "2023-01-22T18:03:04Z"
}