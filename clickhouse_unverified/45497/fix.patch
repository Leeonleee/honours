diff --git a/src/Backups/BackupsWorker.cpp b/src/Backups/BackupsWorker.cpp
index 2d9bd3009120..924acc16d635 100644
--- a/src/Backups/BackupsWorker.cpp
+++ b/src/Backups/BackupsWorker.cpp
@@ -160,17 +160,6 @@ OperationID BackupsWorker::startMakingBackup(const ASTPtr & query, const Context
     else
         backup_id = toString(*backup_settings.backup_uuid);
 
-    /// Check if there are no concurrent backups
-    if (num_active_backups && !allow_concurrent_backups)
-    {
-        /// If its an internal backup and we currently have 1 active backup, it could be the original query, validate using backup_uuid
-        if (!(num_active_backups == 1 && backup_settings.internal && getAllActiveBackupInfos().at(0).id == toString(*backup_settings.backup_uuid)))
-        {
-            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED,
-                            "Concurrent backups not supported, turn on setting 'allow_concurrent_backups'");
-        }
-    }
-
     std::shared_ptr<IBackupCoordination> backup_coordination;
     if (backup_settings.internal)
     {
@@ -184,6 +173,13 @@ OperationID BackupsWorker::startMakingBackup(const ASTPtr & query, const Context
     String backup_name_for_logging = backup_info.toStringForLogging();
     try
     {
+        if (!allow_concurrent_backups && hasConcurrentBackups(backup_settings))
+        {
+            /// addInfo is called here to record the failed backup details
+            addInfo(backup_id, backup_name_for_logging, backup_settings.internal, BackupStatus::BACKUP_FAILED);
+            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED, "Concurrent backups not supported, turn on setting 'allow_concurrent_backups'");
+        }
+
         addInfo(backup_id, backup_name_for_logging, backup_settings.internal, BackupStatus::CREATING_BACKUP);
 
         /// Prepare context to use.
@@ -384,8 +380,8 @@ OperationID BackupsWorker::startRestoring(const ASTPtr & query, ContextMutablePt
     auto restore_query = std::static_pointer_cast<ASTBackupQuery>(query->clone());
     auto restore_settings = RestoreSettings::fromRestoreQuery(*restore_query);
 
-    if (!restore_settings.backup_uuid)
-        restore_settings.backup_uuid = UUIDHelpers::generateV4();
+    if (!restore_settings.restore_uuid)
+        restore_settings.restore_uuid = UUIDHelpers::generateV4();
 
     /// `restore_id` will be used as a key to the `infos` map, so it should be unique.
     OperationID restore_id;
@@ -394,18 +390,7 @@ OperationID BackupsWorker::startRestoring(const ASTPtr & query, ContextMutablePt
     else if (!restore_settings.id.empty())
         restore_id = restore_settings.id;
     else
-        restore_id = toString(*restore_settings.backup_uuid);
-
-    /// Check if there are no concurrent restores
-    if (num_active_restores && !allow_concurrent_restores)
-    {
-        /// If its an internal restore and we currently have 1 active restore, it could be the original query, validate using iz
-        if (!(num_active_restores == 1 && restore_settings.internal && getAllActiveRestoreInfos().at(0).id == toString(*restore_settings.backup_uuid)))
-        {
-            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED,
-                            "Concurrent restores not supported, turn on setting 'allow_concurrent_restores'");
-        }
-    }
+        restore_id = toString(*restore_settings.restore_uuid);
 
     std::shared_ptr<IRestoreCoordination> restore_coordination;
     if (restore_settings.internal)
@@ -420,6 +405,14 @@ OperationID BackupsWorker::startRestoring(const ASTPtr & query, ContextMutablePt
     {
         auto backup_info = BackupInfo::fromAST(*restore_query->backup_name);
         String backup_name_for_logging = backup_info.toStringForLogging();
+
+        if (!allow_concurrent_restores && hasConcurrentRestores(restore_settings))
+        {
+            /// addInfo is called here to record the failed restore details
+            addInfo(restore_id, backup_name_for_logging, restore_settings.internal, BackupStatus::RESTORING);
+            throw Exception(ErrorCodes::CONCURRENT_ACCESS_NOT_SUPPORTED, "Concurrent restores not supported, turn on setting 'allow_concurrent_restores'");
+        }
+
         addInfo(restore_id, backup_name_for_logging, restore_settings.internal, BackupStatus::RESTORING);
 
         /// Prepare context to use.
@@ -499,7 +492,7 @@ void BackupsWorker::doRestore(
         backup_open_params.context = context;
         backup_open_params.backup_info = backup_info;
         backup_open_params.base_backup_info = restore_settings.base_backup_info;
-        backup_open_params.backup_uuid = restore_settings.backup_uuid;
+        backup_open_params.backup_uuid = restore_settings.restore_uuid;
         backup_open_params.password = restore_settings.password;
         BackupPtr backup = BackupFactory::instance().createBackup(backup_open_params);
 
@@ -740,6 +733,34 @@ std::vector<BackupsWorker::Info> BackupsWorker::getAllActiveRestoreInfos() const
     return res_infos;
 }
 
+bool BackupsWorker::hasConcurrentBackups(const BackupSettings & backup_settings) const
+{
+    /// Check if there are no concurrent backups
+    if (num_active_backups)
+    {
+        /// If its an internal backup and we currently have 1 active backup, it could be the original query, validate using backup_uuid
+        if (!(num_active_backups == 1 && backup_settings.internal && getAllActiveBackupInfos().at(0).id == toString(*backup_settings.backup_uuid)))
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
+bool BackupsWorker::hasConcurrentRestores(const RestoreSettings & restore_settings) const
+{
+    /// Check if there are no concurrent restores
+    if (num_active_restores)
+    {
+        /// If its an internal restore and we currently have 1 active restore, it could be the original query, validate using iz
+        if (!(num_active_restores == 1 && restore_settings.internal && getAllActiveRestoreInfos().at(0).id == toString(*restore_settings.restore_uuid)))
+        {
+            return true;
+        }
+    }
+    return false;
+}
+
 void BackupsWorker::shutdown()
 {
     bool has_active_backups_and_restores = (num_active_backups || num_active_restores);
diff --git a/src/Backups/BackupsWorker.h b/src/Backups/BackupsWorker.h
index b6d9729833e8..98ba9d10e93d 100644
--- a/src/Backups/BackupsWorker.h
+++ b/src/Backups/BackupsWorker.h
@@ -105,6 +105,8 @@ class BackupsWorker
     void setNumFilesAndSize(const OperationID & id, size_t num_files, UInt64 uncompressed_size, UInt64 compressed_size);
     std::vector<Info> getAllActiveBackupInfos() const;
     std::vector<Info> getAllActiveRestoreInfos() const;
+    bool hasConcurrentBackups(const BackupSettings & backup_settings) const;
+    bool hasConcurrentRestores(const RestoreSettings & restore_settings) const;
 
     ThreadPool backups_thread_pool;
     ThreadPool restores_thread_pool;
diff --git a/src/Backups/RestoreSettings.cpp b/src/Backups/RestoreSettings.cpp
index 0ffa48224f7b..5e06764a2474 100644
--- a/src/Backups/RestoreSettings.cpp
+++ b/src/Backups/RestoreSettings.cpp
@@ -164,7 +164,7 @@ namespace
     M(Bool, internal) \
     M(String, host_id) \
     M(String, coordination_zk_path) \
-    M(OptionalUUID, backup_uuid)
+    M(OptionalUUID, restore_uuid)
 
 
 RestoreSettings RestoreSettings::fromRestoreQuery(const ASTBackupQuery & query)
diff --git a/src/Backups/RestoreSettings.h b/src/Backups/RestoreSettings.h
index 50058d83a25b..3bfe9f869ea5 100644
--- a/src/Backups/RestoreSettings.h
+++ b/src/Backups/RestoreSettings.h
@@ -123,9 +123,9 @@ struct RestoreSettings
     String coordination_zk_path;
 
     /// Internal, should not be specified by user.
-    /// UUID of the backup. If it's not set it will be generated randomly.
+    /// UUID of the restore. If it's not set it will be generated randomly.
     /// This is used to validate internal restores when allow_concurrent_restores is turned off
-    std::optional<UUID> backup_uuid;
+    std::optional<UUID> restore_uuid;
 
     static RestoreSettings fromRestoreQuery(const ASTBackupQuery & query);
     void copySettingsToQuery(ASTBackupQuery & query) const;
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index 6be0678a01a7..f0dd8de8e56c 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -1890,8 +1890,8 @@ BackupsWorker & Context::getBackupsWorker() const
 {
     auto lock = getLock();
 
-    const bool allow_concurrent_backups = this->getConfigRef().getBool("allow_concurrent_backups", true);
-    const bool allow_concurrent_restores = this->getConfigRef().getBool("allow_concurrent_restores", true);
+    const bool allow_concurrent_backups = this->getConfigRef().getBool("backups.allow_concurrent_backups", true);
+    const bool allow_concurrent_restores = this->getConfigRef().getBool("backups.allow_concurrent_restores", true);
 
     if (!shared->backups_worker)
         shared->backups_worker.emplace(getSettingsRef().backup_threads, getSettingsRef().restore_threads, allow_concurrent_backups, allow_concurrent_restores);
