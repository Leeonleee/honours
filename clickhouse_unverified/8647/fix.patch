diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h
index 724b31ca6421..227ebdcfc725 100644
--- a/dbms/src/Core/Settings.h
+++ b/dbms/src/Core/Settings.h
@@ -394,6 +394,7 @@ struct Settings : public SettingsCollection<Settings>
     M(SettingBool, allow_experimental_data_skipping_indices, true, "Obsolete setting, does nothing. Will be removed after 2020-05-31", 0) \
     M(SettingBool, merge_tree_uniform_read_distribution, true, "Obsolete setting, does nothing. Will be removed after 2020-05-20", 0) \
     M(SettingUInt64, mark_cache_min_lifetime, 0, "Obsolete setting, does nothing. Will be removed after 2020-05-31", 0) \
+    M(SettingUInt64, max_parser_depth, 1000, "Maximum parser depth.", 0) \
 
     DECLARE_SETTINGS_COLLECTION(LIST_OF_SETTINGS)
 
diff --git a/dbms/src/Databases/DatabaseDictionary.cpp b/dbms/src/Databases/DatabaseDictionary.cpp
index 9409fdc584ab..f7a145a600a4 100644
--- a/dbms/src/Databases/DatabaseDictionary.cpp
+++ b/dbms/src/Databases/DatabaseDictionary.cpp
@@ -109,11 +109,12 @@ ASTPtr DatabaseDictionary::getCreateTableQueryImpl(const Context & context,
         buffer << ") Engine = Dictionary(" << backQuoteIfNeed(table_name) << ")";
     }
 
+    auto settings = context.getSettingsRef();
     ParserCreateQuery parser;
     const char * pos = query.data();
     std::string error_message;
     auto ast = tryParseQuery(parser, pos, pos + query.size(), error_message,
-            /* hilite = */ false, "", /* allow_multi_statements = */ false, 0);
+            /* hilite = */ false, "", /* allow_multi_statements = */ false, 0, settings.max_parser_depth);
 
     if (!ast && throw_on_error)
         throw Exception(error_message, ErrorCodes::SYNTAX_ERROR);
@@ -121,15 +122,16 @@ ASTPtr DatabaseDictionary::getCreateTableQueryImpl(const Context & context,
     return ast;
 }
 
-ASTPtr DatabaseDictionary::getCreateDatabaseQuery() const
+ASTPtr DatabaseDictionary::getCreateDatabaseQuery(const Context & context) const
 {
     String query;
     {
         WriteBufferFromString buffer(query);
         buffer << "CREATE DATABASE " << backQuoteIfNeed(database_name) << " ENGINE = Dictionary";
     }
+    auto settings = context.getSettingsRef();
     ParserCreateQuery parser;
-    return parseQuery(parser, query.data(), query.data() + query.size(), "", 0);
+    return parseQuery(parser, query.data(), query.data() + query.size(), "", 0, settings.max_parser_depth);
 }
 
 void DatabaseDictionary::shutdown()
diff --git a/dbms/src/Databases/DatabaseDictionary.h b/dbms/src/Databases/DatabaseDictionary.h
index 3155e12b8622..cd5dde3177c1 100644
--- a/dbms/src/Databases/DatabaseDictionary.h
+++ b/dbms/src/Databases/DatabaseDictionary.h
@@ -41,7 +41,7 @@ class DatabaseDictionary : public IDatabase
 
     bool empty(const Context & context) const override;
 
-    ASTPtr getCreateDatabaseQuery() const override;
+    ASTPtr getCreateDatabaseQuery(const Context & context) const override;
 
     void shutdown() override;
 
diff --git a/dbms/src/Databases/DatabaseLazy.cpp b/dbms/src/Databases/DatabaseLazy.cpp
index fc71b3a63a7f..089b4651e3b3 100644
--- a/dbms/src/Databases/DatabaseLazy.cpp
+++ b/dbms/src/Databases/DatabaseLazy.cpp
@@ -230,7 +230,7 @@ StoragePtr DatabaseLazy::loadTable(const Context & context, const String & table
         StoragePtr table;
         Context context_copy(context); /// some tables can change context, but not LogTables
 
-        auto ast = parseQueryFromMetadata(table_metadata_path, /*throw_on_error*/ true, /*remove_empty*/false);
+        auto ast = parseQueryFromMetadata(context, table_metadata_path, /*throw_on_error*/ true, /*remove_empty*/false);
         if (ast)
         {
             auto & ast_create = ast->as<const ASTCreateQuery &>();
diff --git a/dbms/src/Databases/DatabaseMemory.cpp b/dbms/src/Databases/DatabaseMemory.cpp
index 996d5ca7c84d..accb7da88788 100644
--- a/dbms/src/Databases/DatabaseMemory.cpp
+++ b/dbms/src/Databases/DatabaseMemory.cpp
@@ -27,7 +27,7 @@ void DatabaseMemory::removeTable(
     detachTable(table_name);
 }
 
-ASTPtr DatabaseMemory::getCreateDatabaseQuery() const
+ASTPtr DatabaseMemory::getCreateDatabaseQuery(const Context & /*context*/) const
 {
     auto create_query = std::make_shared<ASTCreateQuery>();
     create_query->database = database_name;
diff --git a/dbms/src/Databases/DatabaseMemory.h b/dbms/src/Databases/DatabaseMemory.h
index 5609e6053cec..33cf434c982f 100644
--- a/dbms/src/Databases/DatabaseMemory.h
+++ b/dbms/src/Databases/DatabaseMemory.h
@@ -31,7 +31,7 @@ class DatabaseMemory : public DatabaseWithOwnTablesBase
         const Context & context,
         const String & table_name) override;
 
-    ASTPtr getCreateDatabaseQuery() const override;
+    ASTPtr getCreateDatabaseQuery(const Context & /*context*/) const override;
 };
 
 }
diff --git a/dbms/src/Databases/DatabaseMySQL.cpp b/dbms/src/Databases/DatabaseMySQL.cpp
index 9ae42f08d8a6..9ba7e0b28bdf 100644
--- a/dbms/src/Databases/DatabaseMySQL.cpp
+++ b/dbms/src/Databases/DatabaseMySQL.cpp
@@ -181,7 +181,7 @@ time_t DatabaseMySQL::getObjectMetadataModificationTime(const String & table_nam
     return time_t(local_tables_cache[table_name].first);
 }
 
-ASTPtr DatabaseMySQL::getCreateDatabaseQuery() const
+ASTPtr DatabaseMySQL::getCreateDatabaseQuery(const Context & /*context*/) const
 {
     const auto & create_query = std::make_shared<ASTCreateQuery>();
     create_query->database = database_name;
diff --git a/dbms/src/Databases/DatabaseMySQL.h b/dbms/src/Databases/DatabaseMySQL.h
index a327cf143ebd..f01124816615 100644
--- a/dbms/src/Databases/DatabaseMySQL.h
+++ b/dbms/src/Databases/DatabaseMySQL.h
@@ -32,7 +32,7 @@ class DatabaseMySQL : public IDatabase
 
     DatabaseTablesIteratorPtr getTablesIterator(const Context & context, const FilterByNameFunction & filter_by_table_name = {}) override;
 
-    ASTPtr getCreateDatabaseQuery() const override;
+    ASTPtr getCreateDatabaseQuery(const Context & /*context*/) const override;
 
     bool isTableExist(const Context & context, const String & name) const override;
 
diff --git a/dbms/src/Databases/DatabaseOnDisk.cpp b/dbms/src/Databases/DatabaseOnDisk.cpp
index dfeb8746a2f1..df552a2b560a 100644
--- a/dbms/src/Databases/DatabaseOnDisk.cpp
+++ b/dbms/src/Databases/DatabaseOnDisk.cpp
@@ -211,7 +211,7 @@ void DatabaseOnDisk::renameTable(
     if (!table)
         throw Exception("Table " + backQuote(getDatabaseName()) + "." + backQuote(table_name) + " doesn't exist.", ErrorCodes::UNKNOWN_TABLE);
 
-    ASTPtr ast = parseQueryFromMetadata(getObjectMetadataPath(table_name));
+    ASTPtr ast = parseQueryFromMetadata(context, getObjectMetadataPath(table_name));
     if (!ast)
         throw Exception("There is no metadata file for table " + backQuote(table_name) + ".", ErrorCodes::FILE_DOESNT_EXIST);
     auto & create = ast->as<ASTCreateQuery &>();
@@ -244,7 +244,7 @@ ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const Context & context, const St
     ASTPtr ast;
 
     auto table_metadata_path = getObjectMetadataPath(table_name);
-    ast = getCreateQueryFromMetadata(table_metadata_path, throw_on_error);
+    ast = getCreateQueryFromMetadata(context, table_metadata_path, throw_on_error);
     if (!ast && throw_on_error)
     {
         /// Handle system.* tables for which there are no table.sql files.
@@ -260,20 +260,21 @@ ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const Context & context, const St
     return ast;
 }
 
-ASTPtr DatabaseOnDisk::getCreateDatabaseQuery() const
+ASTPtr DatabaseOnDisk::getCreateDatabaseQuery(const Context & context) const
 {
     ASTPtr ast;
 
+    auto settings = context.getSettingsRef();
     auto metadata_dir_path = getMetadataPath();
     auto database_metadata_path = metadata_dir_path.substr(0, metadata_dir_path.size() - 1) + ".sql";
-    ast = getCreateQueryFromMetadata(database_metadata_path, true);
+    ast = getCreateQueryFromMetadata(context, database_metadata_path, true);
     if (!ast)
     {
         /// Handle databases (such as default) for which there are no database.sql files.
         /// If database.sql doesn't exist, then engine is Ordinary
         String query = "CREATE DATABASE " + backQuoteIfNeed(getDatabaseName()) + " ENGINE = Ordinary";
         ParserCreateQuery parser;
-        ast = parseQuery(parser, query.data(), query.data() + query.size(), "", 0);
+        ast = parseQuery(parser, query.data(), query.data() + query.size(), "", 0, settings.max_parser_depth);
     }
 
     return ast;
@@ -353,7 +354,7 @@ void DatabaseOnDisk::iterateMetadataFiles(const Context & context, const Iterati
     }
 }
 
-ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const String & metadata_file_path, bool throw_on_error /*= true*/, bool remove_empty /*= false*/) const
+ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const Context & context, const String & metadata_file_path, bool throw_on_error /*= true*/, bool remove_empty /*= false*/) const
 {
     String query;
 
@@ -380,11 +381,12 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const String & metadata_file_path,
         return nullptr;
     }
 
+    auto settings = context.getSettingsRef();
     ParserCreateQuery parser;
     const char * pos = query.data();
     std::string error_message;
     auto ast = tryParseQuery(parser, pos, pos + query.size(), error_message, /* hilite = */ false,
-                             "in file " + getMetadataPath(), /* allow_multi_statements = */ false, 0);
+                             "in file " + getMetadataPath(), /* allow_multi_statements = */ false, 0, settings.max_parser_depth);
 
     if (!ast && throw_on_error)
         throw Exception(error_message, ErrorCodes::SYNTAX_ERROR);
@@ -394,9 +396,9 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const String & metadata_file_path,
     return ast;
 }
 
-ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const String & database_metadata_path, bool throw_on_error) const
+ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const Context & context, const String & database_metadata_path, bool throw_on_error) const
 {
-    ASTPtr ast = parseQueryFromMetadata(database_metadata_path, throw_on_error);
+    ASTPtr ast = parseQueryFromMetadata(context, database_metadata_path, throw_on_error);
 
     if (ast)
     {
diff --git a/dbms/src/Databases/DatabaseOnDisk.h b/dbms/src/Databases/DatabaseOnDisk.h
index fa77e80a3a43..079d0aefd109 100644
--- a/dbms/src/Databases/DatabaseOnDisk.h
+++ b/dbms/src/Databases/DatabaseOnDisk.h
@@ -52,7 +52,7 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase
         const String & to_table_name,
         TableStructureWriteLockHolder & lock) override;
 
-    ASTPtr getCreateDatabaseQuery() const override;
+    ASTPtr getCreateDatabaseQuery(const Context & context) const override;
 
     void drop(const Context & context) override;
 
@@ -74,8 +74,8 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase
         const String & table_name,
         bool throw_on_error) const override;
 
-    ASTPtr parseQueryFromMetadata(const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false) const;
-    ASTPtr getCreateQueryFromMetadata(const String & metadata_path, bool throw_on_error) const;
+    ASTPtr parseQueryFromMetadata(const Context & context, const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false) const;
+    ASTPtr getCreateQueryFromMetadata(const Context & context, const String & metadata_path, bool throw_on_error) const;
 
 
     const String metadata_path;
diff --git a/dbms/src/Databases/DatabaseOrdinary.cpp b/dbms/src/Databases/DatabaseOrdinary.cpp
index f9f6983604ce..2b4102495d75 100644
--- a/dbms/src/Databases/DatabaseOrdinary.cpp
+++ b/dbms/src/Databases/DatabaseOrdinary.cpp
@@ -122,12 +122,12 @@ void DatabaseOrdinary::loadStoredObjects(
     FileNames file_names;
 
     size_t total_dictionaries = 0;
-    iterateMetadataFiles(context, [&file_names, &total_dictionaries, this](const String & file_name)
+    iterateMetadataFiles(context, [&context, &file_names, &total_dictionaries, this](const String & file_name)
     {
         String full_path = getMetadataPath() + file_name;
         try
         {
-            auto ast = parseQueryFromMetadata(full_path, /*throw_on_error*/ true, /*remove_empty*/false);
+            auto ast = parseQueryFromMetadata(context, full_path, /*throw_on_error*/ true, /*remove_empty*/false);
             if (ast)
             {
                 auto * create_query = ast->as<ASTCreateQuery>();
diff --git a/dbms/src/Databases/DatabaseWithDictionaries.cpp b/dbms/src/Databases/DatabaseWithDictionaries.cpp
index 716ed32b6761..2f3d4e7c237b 100644
--- a/dbms/src/Databases/DatabaseWithDictionaries.cpp
+++ b/dbms/src/Databases/DatabaseWithDictionaries.cpp
@@ -235,7 +235,7 @@ ASTPtr DatabaseWithDictionaries::getCreateDictionaryQueryImpl(
     ASTPtr ast;
 
     auto dictionary_metadata_path = getObjectMetadataPath(dictionary_name);
-    ast = getCreateQueryFromMetadata(dictionary_metadata_path, throw_on_error);
+    ast = getCreateQueryFromMetadata(context, dictionary_metadata_path, throw_on_error);
     if (!ast && throw_on_error)
     {
         /// Handle system.* tables for which there are no table.sql files.
diff --git a/dbms/src/Databases/IDatabase.h b/dbms/src/Databases/IDatabase.h
index e9211560c516..64899667ff0d 100644
--- a/dbms/src/Databases/IDatabase.h
+++ b/dbms/src/Databases/IDatabase.h
@@ -262,7 +262,7 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>
     }
 
     /// Get the CREATE DATABASE query for current database.
-    virtual ASTPtr getCreateDatabaseQuery() const = 0;
+    virtual ASTPtr getCreateDatabaseQuery(const Context & /*context*/) const = 0;
 
     /// Get name of database.
     String getDatabaseName() const { return database_name; }
diff --git a/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp b/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp
index 6f76016725fa..4ffe3917a599 100644
--- a/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp
@@ -55,7 +55,7 @@ BlockInputStreamPtr InterpreterShowCreateQuery::executeImpl()
     {
         if (show_query->temporary)
             throw Exception("Temporary databases are not possible.", ErrorCodes::SYNTAX_ERROR);
-        create_query = context.getDatabase(show_query->database)->getCreateDatabaseQuery();
+        create_query = context.getDatabase(show_query->database)->getCreateDatabaseQuery(context);
     }
     else if ((show_query = query_ptr->as<ASTShowCreateDictionaryQuery>()))
     {
diff --git a/dbms/src/Interpreters/executeQuery.cpp b/dbms/src/Interpreters/executeQuery.cpp
index 69bbb6fcd41e..1f9127384541 100644
--- a/dbms/src/Interpreters/executeQuery.cpp
+++ b/dbms/src/Interpreters/executeQuery.cpp
@@ -214,7 +214,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
     try
     {
         /// TODO Parser should fail early when max_query_size limit is reached.
-        ast = parseQuery(parser, begin, end, "", max_query_size);
+        ast = parseQuery(parser, begin, end, "", max_query_size, settings.max_parser_depth);
 
         auto * insert_query = ast->as<ASTInsertQuery>();
 
diff --git a/dbms/src/Parsers/IParser.h b/dbms/src/Parsers/IParser.h
index 7b86d0663931..925140bd25ed 100644
--- a/dbms/src/Parsers/IParser.h
+++ b/dbms/src/Parsers/IParser.h
@@ -5,6 +5,8 @@
 
 #include <Core/Defines.h>
 #include <Core/Types.h>
+#include <Core/Settings.h>
+#include <IO/WriteHelpers.h>
 #include <Parsers/IAST.h>
 #include <Parsers/TokenIterator.h>
 
@@ -57,13 +59,15 @@ class IParser
         using TokenIterator::TokenIterator;
 
         uint32_t depth = 0;
-        uint32_t max_depth = 1000;
+        uint32_t max_depth = 0;
+
+        Pos(Tokens & tokens_, uint32_t max_depth_) : TokenIterator(tokens_), max_depth(max_depth_) {}
 
         void increaseDepth()
         {
             ++depth;
-            if (depth > max_depth)
-                throw Exception("Maximum parse depth exceeded", ErrorCodes::TOO_DEEP_RECURSION);
+            if (max_depth > 0 && depth > max_depth)
+                throw Exception("Maximum parse depth (" + toString(max_depth) + ") exceeded. Consider rising max_parser_depth parameter.", ErrorCodes::TOO_DEEP_RECURSION);
         }
 
         void decreaseDepth()
diff --git a/dbms/src/Parsers/parseQuery.cpp b/dbms/src/Parsers/parseQuery.cpp
index da779ae83bae..b8ab940f2dde 100644
--- a/dbms/src/Parsers/parseQuery.cpp
+++ b/dbms/src/Parsers/parseQuery.cpp
@@ -215,10 +215,11 @@ ASTPtr tryParseQuery(
     bool hilite,
     const std::string & query_description,
     bool allow_multi_statements,
-    size_t max_query_size)
+    size_t max_query_size,
+    size_t max_parser_depth)
 {
     Tokens tokens(pos, end, max_query_size);
-    IParser::Pos token_iterator(tokens);
+    IParser::Pos token_iterator(tokens, max_parser_depth);
 
     if (token_iterator->isEnd()
         || token_iterator->type == TokenType::Semicolon)
@@ -297,10 +298,11 @@ ASTPtr parseQueryAndMovePosition(
     const char * end,
     const std::string & query_description,
     bool allow_multi_statements,
-    size_t max_query_size)
+    size_t max_query_size,
+    size_t max_parser_depth)
 {
     std::string error_message;
-    ASTPtr res = tryParseQuery(parser, pos, end, error_message, false, query_description, allow_multi_statements, max_query_size);
+    ASTPtr res = tryParseQuery(parser, pos, end, error_message, false, query_description, allow_multi_statements, max_query_size, max_parser_depth);
 
     if (res)
         return res;
@@ -314,10 +316,11 @@ ASTPtr parseQuery(
     const char * begin,
     const char * end,
     const std::string & query_description,
-    size_t max_query_size)
+    size_t max_query_size,
+    size_t max_parser_depth)
 {
     auto pos = begin;
-    return parseQueryAndMovePosition(parser, pos, end, query_description, false, max_query_size);
+    return parseQueryAndMovePosition(parser, pos, end, query_description, false, max_query_size, max_parser_depth);
 }
 
 
diff --git a/dbms/src/Parsers/parseQuery.h b/dbms/src/Parsers/parseQuery.h
index 85851eedacff..feea204181ea 100644
--- a/dbms/src/Parsers/parseQuery.h
+++ b/dbms/src/Parsers/parseQuery.h
@@ -15,8 +15,9 @@ ASTPtr tryParseQuery(
     bool hilite,
     const std::string & description,
     bool allow_multi_statements,    /// If false, check for non-space characters after semicolon and set error message if any.
-    size_t max_query_size);         /// If (end - pos) > max_query_size and query is longer than max_query_size then throws "Max query size exceeded".
+    size_t max_query_size,          /// If (end - pos) > max_query_size and query is longer than max_query_size then throws "Max query size exceeded".
                                     /// Disabled if zero. Is used in order to check query size if buffer can contains data for INSERT query.
+    size_t max_parser_depth = 0);
 
 
 /// Parse query or throw an exception with error message.
@@ -26,15 +27,16 @@ ASTPtr parseQueryAndMovePosition(
     const char * end,
     const std::string & description,
     bool allow_multi_statements,
-    size_t max_query_size);
-
+    size_t max_query_size = 0,
+    size_t max_parser_depth = 0);
 
 ASTPtr parseQuery(
     IParser & parser,
     const char * begin,
     const char * end,
     const std::string & description,
-    size_t max_query_size);
+    size_t max_query_size,
+    size_t max_parser_depth = 0);
 
 ASTPtr parseQuery(
     IParser & parser,
diff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
index 0c7f06f6022a..3bc131df07db 100644
--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp
@@ -328,12 +328,12 @@ ConstantExpressionTemplate::Cache::getFromCacheOrConstruct(const DataTypePtr & r
     return res;
 }
 
-bool ConstantExpressionTemplate::parseExpression(ReadBuffer & istr, const FormatSettings & settings)
+bool ConstantExpressionTemplate::parseExpression(ReadBuffer & istr, const FormatSettings & format_settings, const Settings & settings)
 {
     size_t cur_column = 0;
     try
     {
-        if (tryParseExpression(istr, settings, cur_column))
+        if (tryParseExpression(istr, format_settings, cur_column, settings))
         {
             ++rows_count;
             return true;
@@ -355,7 +355,7 @@ bool ConstantExpressionTemplate::parseExpression(ReadBuffer & istr, const Format
     return false;
 }
 
-bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const FormatSettings & settings, size_t & cur_column)
+bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const FormatSettings & format_settings, size_t & cur_column, const Settings & settings)
 {
     size_t cur_token = 0;
     size_t num_columns = structure->literals.columns();
@@ -372,13 +372,13 @@ bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const For
         skipWhitespaceIfAny(istr);
 
         const DataTypePtr & type = structure->literals.getByPosition(cur_column).type;
-        if (settings.values.accurate_types_of_literals && !structure->special_parser[cur_column].useDefaultParser())
+        if (format_settings.values.accurate_types_of_literals && !structure->special_parser[cur_column].useDefaultParser())
         {
-            if (!parseLiteralAndAssertType(istr, type.get(), cur_column))
+            if (!parseLiteralAndAssertType(istr, type.get(), cur_column, settings))
                 return false;
         }
         else
-            type->deserializeAsTextQuoted(*columns[cur_column], istr, settings);
+            type->deserializeAsTextQuoted(*columns[cur_column], istr, format_settings);
 
         ++cur_column;
     }
@@ -392,7 +392,7 @@ bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const For
     return true;
 }
 
-bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * complex_type, size_t column_idx)
+bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * complex_type, size_t column_idx, const Settings & settings)
 {
     using Type = Field::Types::Which;
 
@@ -410,7 +410,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co
         /// TODO faster way to check types without using Parsers
         ParserArrayOfLiterals parser_array;
         Tokens tokens_number(istr.position(), istr.buffer().end());
-        IParser::Pos iterator(tokens_number);
+        IParser::Pos iterator(tokens_number, settings.max_parser_depth);
         Expected expected;
         ASTPtr ast;
 
diff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h
index 96e1c653c037..bbac2e2a9998 100644
--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h
+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h
@@ -66,7 +66,7 @@ class ConstantExpressionTemplate : boost::noncopyable
 
     /// Read expression from istr, assert it has the same structure and the same types of literals (template matches)
     /// and parse literals into temporary columns
-    bool parseExpression(ReadBuffer & istr, const FormatSettings & settings);
+    bool parseExpression(ReadBuffer & istr, const FormatSettings & format_settings, const Settings & settings);
 
     /// Evaluate batch of expressions were parsed using template.
     /// If template was deduced with null_as_default == true, set bits in nulls for NULL values in column_idx, starting from offset.
@@ -75,8 +75,8 @@ class ConstantExpressionTemplate : boost::noncopyable
     size_t rowsCount() const { return rows_count; }
 
 private:
-    bool tryParseExpression(ReadBuffer & istr, const FormatSettings & settings, size_t & cur_column);
-    bool parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * type, size_t column_idx);
+    bool tryParseExpression(ReadBuffer & istr, const FormatSettings & format_settings, size_t & cur_column, const Settings & settings);
+    bool parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * type, size_t column_idx, const Settings & settings);
 
 private:
     TemplateStructurePtr structure;
diff --git a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
index b324719527a2..9ce3d62a2444 100644
--- a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
+++ b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
@@ -129,7 +129,8 @@ void ValuesBlockInputFormat::readRow(MutableColumns & columns, size_t row_num)
 bool ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx)
 {
     /// Try to parse expression using template if one was successfully deduced while parsing the first row
-    if (templates[column_idx]->parseExpression(buf, format_settings))
+    auto settings = context->getSettingsRef();
+    if (templates[column_idx]->parseExpression(buf, format_settings, settings))
     {
         ++rows_parsed_using_template[column_idx];
         return true;
@@ -187,6 +188,7 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx
 {
     const Block & header = getPort().getHeader();
     const IDataType & type = *header.getByPosition(column_idx).type;
+    auto settings = context->getSettingsRef();
 
     /// We need continuous memory containing the expression to use Lexer
     skipToNextRow(0, 1);
@@ -195,7 +197,7 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx
 
     Expected expected;
     Tokens tokens(buf.position(), buf.buffer().end());
-    IParser::Pos token_iterator(tokens);
+    IParser::Pos token_iterator(tokens, settings.max_parser_depth);
     ASTPtr ast;
 
     bool parsed = parser.parse(token_iterator, ast, expected);
@@ -265,7 +267,7 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx
                 ++attempts_to_deduce_template[column_idx];
 
             buf.rollbackToCheckpoint();
-            if (templates[column_idx]->parseExpression(buf, format_settings))
+            if (templates[column_idx]->parseExpression(buf, format_settings, settings))
             {
                 ++rows_parsed_using_template[column_idx];
                 parser_type_for_column[column_idx] = ParserType::BatchTemplate;
diff --git a/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp b/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp
index cdc9063d4153..41aaec9d1fbe 100644
--- a/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp
+++ b/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp
@@ -18,6 +18,8 @@ ColumnsDescription parseColumnsListFromString(const std::string & structure, con
 
     Tokens tokens(structure.c_str(), structure.c_str() + structure.size());
     IParser::Pos token_iterator(tokens);
+    const Settings & settings = context.getSettingsRef();
+    token_iterator.max_depth = settings.max_parser_depth;
 
     ParserColumnDeclarationList parser;
     ASTPtr columns_list_raw;
