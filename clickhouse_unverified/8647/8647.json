{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8647,
  "instance_id": "ClickHouse__ClickHouse-8647",
  "issue_numbers": [
    "6681"
  ],
  "base_commit": "d67b7dd4da39e636e9bcb354e4b7a40bce7271e6",
  "patch": "diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h\nindex 724b31ca6421..227ebdcfc725 100644\n--- a/dbms/src/Core/Settings.h\n+++ b/dbms/src/Core/Settings.h\n@@ -394,6 +394,7 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, allow_experimental_data_skipping_indices, true, \"Obsolete setting, does nothing. Will be removed after 2020-05-31\", 0) \\\n     M(SettingBool, merge_tree_uniform_read_distribution, true, \"Obsolete setting, does nothing. Will be removed after 2020-05-20\", 0) \\\n     M(SettingUInt64, mark_cache_min_lifetime, 0, \"Obsolete setting, does nothing. Will be removed after 2020-05-31\", 0) \\\n+    M(SettingUInt64, max_parser_depth, 1000, \"Maximum parser depth.\", 0) \\\n \n     DECLARE_SETTINGS_COLLECTION(LIST_OF_SETTINGS)\n \ndiff --git a/dbms/src/Databases/DatabaseDictionary.cpp b/dbms/src/Databases/DatabaseDictionary.cpp\nindex 9409fdc584ab..f7a145a600a4 100644\n--- a/dbms/src/Databases/DatabaseDictionary.cpp\n+++ b/dbms/src/Databases/DatabaseDictionary.cpp\n@@ -109,11 +109,12 @@ ASTPtr DatabaseDictionary::getCreateTableQueryImpl(const Context & context,\n         buffer << \") Engine = Dictionary(\" << backQuoteIfNeed(table_name) << \")\";\n     }\n \n+    auto settings = context.getSettingsRef();\n     ParserCreateQuery parser;\n     const char * pos = query.data();\n     std::string error_message;\n     auto ast = tryParseQuery(parser, pos, pos + query.size(), error_message,\n-            /* hilite = */ false, \"\", /* allow_multi_statements = */ false, 0);\n+            /* hilite = */ false, \"\", /* allow_multi_statements = */ false, 0, settings.max_parser_depth);\n \n     if (!ast && throw_on_error)\n         throw Exception(error_message, ErrorCodes::SYNTAX_ERROR);\n@@ -121,15 +122,16 @@ ASTPtr DatabaseDictionary::getCreateTableQueryImpl(const Context & context,\n     return ast;\n }\n \n-ASTPtr DatabaseDictionary::getCreateDatabaseQuery() const\n+ASTPtr DatabaseDictionary::getCreateDatabaseQuery(const Context & context) const\n {\n     String query;\n     {\n         WriteBufferFromString buffer(query);\n         buffer << \"CREATE DATABASE \" << backQuoteIfNeed(database_name) << \" ENGINE = Dictionary\";\n     }\n+    auto settings = context.getSettingsRef();\n     ParserCreateQuery parser;\n-    return parseQuery(parser, query.data(), query.data() + query.size(), \"\", 0);\n+    return parseQuery(parser, query.data(), query.data() + query.size(), \"\", 0, settings.max_parser_depth);\n }\n \n void DatabaseDictionary::shutdown()\ndiff --git a/dbms/src/Databases/DatabaseDictionary.h b/dbms/src/Databases/DatabaseDictionary.h\nindex 3155e12b8622..cd5dde3177c1 100644\n--- a/dbms/src/Databases/DatabaseDictionary.h\n+++ b/dbms/src/Databases/DatabaseDictionary.h\n@@ -41,7 +41,7 @@ class DatabaseDictionary : public IDatabase\n \n     bool empty(const Context & context) const override;\n \n-    ASTPtr getCreateDatabaseQuery() const override;\n+    ASTPtr getCreateDatabaseQuery(const Context & context) const override;\n \n     void shutdown() override;\n \ndiff --git a/dbms/src/Databases/DatabaseLazy.cpp b/dbms/src/Databases/DatabaseLazy.cpp\nindex fc71b3a63a7f..089b4651e3b3 100644\n--- a/dbms/src/Databases/DatabaseLazy.cpp\n+++ b/dbms/src/Databases/DatabaseLazy.cpp\n@@ -230,7 +230,7 @@ StoragePtr DatabaseLazy::loadTable(const Context & context, const String & table\n         StoragePtr table;\n         Context context_copy(context); /// some tables can change context, but not LogTables\n \n-        auto ast = parseQueryFromMetadata(table_metadata_path, /*throw_on_error*/ true, /*remove_empty*/false);\n+        auto ast = parseQueryFromMetadata(context, table_metadata_path, /*throw_on_error*/ true, /*remove_empty*/false);\n         if (ast)\n         {\n             auto & ast_create = ast->as<const ASTCreateQuery &>();\ndiff --git a/dbms/src/Databases/DatabaseMemory.cpp b/dbms/src/Databases/DatabaseMemory.cpp\nindex 996d5ca7c84d..accb7da88788 100644\n--- a/dbms/src/Databases/DatabaseMemory.cpp\n+++ b/dbms/src/Databases/DatabaseMemory.cpp\n@@ -27,7 +27,7 @@ void DatabaseMemory::removeTable(\n     detachTable(table_name);\n }\n \n-ASTPtr DatabaseMemory::getCreateDatabaseQuery() const\n+ASTPtr DatabaseMemory::getCreateDatabaseQuery(const Context & /*context*/) const\n {\n     auto create_query = std::make_shared<ASTCreateQuery>();\n     create_query->database = database_name;\ndiff --git a/dbms/src/Databases/DatabaseMemory.h b/dbms/src/Databases/DatabaseMemory.h\nindex 5609e6053cec..33cf434c982f 100644\n--- a/dbms/src/Databases/DatabaseMemory.h\n+++ b/dbms/src/Databases/DatabaseMemory.h\n@@ -31,7 +31,7 @@ class DatabaseMemory : public DatabaseWithOwnTablesBase\n         const Context & context,\n         const String & table_name) override;\n \n-    ASTPtr getCreateDatabaseQuery() const override;\n+    ASTPtr getCreateDatabaseQuery(const Context & /*context*/) const override;\n };\n \n }\ndiff --git a/dbms/src/Databases/DatabaseMySQL.cpp b/dbms/src/Databases/DatabaseMySQL.cpp\nindex 9ae42f08d8a6..9ba7e0b28bdf 100644\n--- a/dbms/src/Databases/DatabaseMySQL.cpp\n+++ b/dbms/src/Databases/DatabaseMySQL.cpp\n@@ -181,7 +181,7 @@ time_t DatabaseMySQL::getObjectMetadataModificationTime(const String & table_nam\n     return time_t(local_tables_cache[table_name].first);\n }\n \n-ASTPtr DatabaseMySQL::getCreateDatabaseQuery() const\n+ASTPtr DatabaseMySQL::getCreateDatabaseQuery(const Context & /*context*/) const\n {\n     const auto & create_query = std::make_shared<ASTCreateQuery>();\n     create_query->database = database_name;\ndiff --git a/dbms/src/Databases/DatabaseMySQL.h b/dbms/src/Databases/DatabaseMySQL.h\nindex a327cf143ebd..f01124816615 100644\n--- a/dbms/src/Databases/DatabaseMySQL.h\n+++ b/dbms/src/Databases/DatabaseMySQL.h\n@@ -32,7 +32,7 @@ class DatabaseMySQL : public IDatabase\n \n     DatabaseTablesIteratorPtr getTablesIterator(const Context & context, const FilterByNameFunction & filter_by_table_name = {}) override;\n \n-    ASTPtr getCreateDatabaseQuery() const override;\n+    ASTPtr getCreateDatabaseQuery(const Context & /*context*/) const override;\n \n     bool isTableExist(const Context & context, const String & name) const override;\n \ndiff --git a/dbms/src/Databases/DatabaseOnDisk.cpp b/dbms/src/Databases/DatabaseOnDisk.cpp\nindex dfeb8746a2f1..df552a2b560a 100644\n--- a/dbms/src/Databases/DatabaseOnDisk.cpp\n+++ b/dbms/src/Databases/DatabaseOnDisk.cpp\n@@ -211,7 +211,7 @@ void DatabaseOnDisk::renameTable(\n     if (!table)\n         throw Exception(\"Table \" + backQuote(getDatabaseName()) + \".\" + backQuote(table_name) + \" doesn't exist.\", ErrorCodes::UNKNOWN_TABLE);\n \n-    ASTPtr ast = parseQueryFromMetadata(getObjectMetadataPath(table_name));\n+    ASTPtr ast = parseQueryFromMetadata(context, getObjectMetadataPath(table_name));\n     if (!ast)\n         throw Exception(\"There is no metadata file for table \" + backQuote(table_name) + \".\", ErrorCodes::FILE_DOESNT_EXIST);\n     auto & create = ast->as<ASTCreateQuery &>();\n@@ -244,7 +244,7 @@ ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const Context & context, const St\n     ASTPtr ast;\n \n     auto table_metadata_path = getObjectMetadataPath(table_name);\n-    ast = getCreateQueryFromMetadata(table_metadata_path, throw_on_error);\n+    ast = getCreateQueryFromMetadata(context, table_metadata_path, throw_on_error);\n     if (!ast && throw_on_error)\n     {\n         /// Handle system.* tables for which there are no table.sql files.\n@@ -260,20 +260,21 @@ ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const Context & context, const St\n     return ast;\n }\n \n-ASTPtr DatabaseOnDisk::getCreateDatabaseQuery() const\n+ASTPtr DatabaseOnDisk::getCreateDatabaseQuery(const Context & context) const\n {\n     ASTPtr ast;\n \n+    auto settings = context.getSettingsRef();\n     auto metadata_dir_path = getMetadataPath();\n     auto database_metadata_path = metadata_dir_path.substr(0, metadata_dir_path.size() - 1) + \".sql\";\n-    ast = getCreateQueryFromMetadata(database_metadata_path, true);\n+    ast = getCreateQueryFromMetadata(context, database_metadata_path, true);\n     if (!ast)\n     {\n         /// Handle databases (such as default) for which there are no database.sql files.\n         /// If database.sql doesn't exist, then engine is Ordinary\n         String query = \"CREATE DATABASE \" + backQuoteIfNeed(getDatabaseName()) + \" ENGINE = Ordinary\";\n         ParserCreateQuery parser;\n-        ast = parseQuery(parser, query.data(), query.data() + query.size(), \"\", 0);\n+        ast = parseQuery(parser, query.data(), query.data() + query.size(), \"\", 0, settings.max_parser_depth);\n     }\n \n     return ast;\n@@ -353,7 +354,7 @@ void DatabaseOnDisk::iterateMetadataFiles(const Context & context, const Iterati\n     }\n }\n \n-ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const String & metadata_file_path, bool throw_on_error /*= true*/, bool remove_empty /*= false*/) const\n+ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const Context & context, const String & metadata_file_path, bool throw_on_error /*= true*/, bool remove_empty /*= false*/) const\n {\n     String query;\n \n@@ -380,11 +381,12 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const String & metadata_file_path,\n         return nullptr;\n     }\n \n+    auto settings = context.getSettingsRef();\n     ParserCreateQuery parser;\n     const char * pos = query.data();\n     std::string error_message;\n     auto ast = tryParseQuery(parser, pos, pos + query.size(), error_message, /* hilite = */ false,\n-                             \"in file \" + getMetadataPath(), /* allow_multi_statements = */ false, 0);\n+                             \"in file \" + getMetadataPath(), /* allow_multi_statements = */ false, 0, settings.max_parser_depth);\n \n     if (!ast && throw_on_error)\n         throw Exception(error_message, ErrorCodes::SYNTAX_ERROR);\n@@ -394,9 +396,9 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(const String & metadata_file_path,\n     return ast;\n }\n \n-ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const String & database_metadata_path, bool throw_on_error) const\n+ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const Context & context, const String & database_metadata_path, bool throw_on_error) const\n {\n-    ASTPtr ast = parseQueryFromMetadata(database_metadata_path, throw_on_error);\n+    ASTPtr ast = parseQueryFromMetadata(context, database_metadata_path, throw_on_error);\n \n     if (ast)\n     {\ndiff --git a/dbms/src/Databases/DatabaseOnDisk.h b/dbms/src/Databases/DatabaseOnDisk.h\nindex fa77e80a3a43..079d0aefd109 100644\n--- a/dbms/src/Databases/DatabaseOnDisk.h\n+++ b/dbms/src/Databases/DatabaseOnDisk.h\n@@ -52,7 +52,7 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n         const String & to_table_name,\n         TableStructureWriteLockHolder & lock) override;\n \n-    ASTPtr getCreateDatabaseQuery() const override;\n+    ASTPtr getCreateDatabaseQuery(const Context & context) const override;\n \n     void drop(const Context & context) override;\n \n@@ -74,8 +74,8 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase\n         const String & table_name,\n         bool throw_on_error) const override;\n \n-    ASTPtr parseQueryFromMetadata(const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false) const;\n-    ASTPtr getCreateQueryFromMetadata(const String & metadata_path, bool throw_on_error) const;\n+    ASTPtr parseQueryFromMetadata(const Context & context, const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false) const;\n+    ASTPtr getCreateQueryFromMetadata(const Context & context, const String & metadata_path, bool throw_on_error) const;\n \n \n     const String metadata_path;\ndiff --git a/dbms/src/Databases/DatabaseOrdinary.cpp b/dbms/src/Databases/DatabaseOrdinary.cpp\nindex f9f6983604ce..2b4102495d75 100644\n--- a/dbms/src/Databases/DatabaseOrdinary.cpp\n+++ b/dbms/src/Databases/DatabaseOrdinary.cpp\n@@ -122,12 +122,12 @@ void DatabaseOrdinary::loadStoredObjects(\n     FileNames file_names;\n \n     size_t total_dictionaries = 0;\n-    iterateMetadataFiles(context, [&file_names, &total_dictionaries, this](const String & file_name)\n+    iterateMetadataFiles(context, [&context, &file_names, &total_dictionaries, this](const String & file_name)\n     {\n         String full_path = getMetadataPath() + file_name;\n         try\n         {\n-            auto ast = parseQueryFromMetadata(full_path, /*throw_on_error*/ true, /*remove_empty*/false);\n+            auto ast = parseQueryFromMetadata(context, full_path, /*throw_on_error*/ true, /*remove_empty*/false);\n             if (ast)\n             {\n                 auto * create_query = ast->as<ASTCreateQuery>();\ndiff --git a/dbms/src/Databases/DatabaseWithDictionaries.cpp b/dbms/src/Databases/DatabaseWithDictionaries.cpp\nindex 716ed32b6761..2f3d4e7c237b 100644\n--- a/dbms/src/Databases/DatabaseWithDictionaries.cpp\n+++ b/dbms/src/Databases/DatabaseWithDictionaries.cpp\n@@ -235,7 +235,7 @@ ASTPtr DatabaseWithDictionaries::getCreateDictionaryQueryImpl(\n     ASTPtr ast;\n \n     auto dictionary_metadata_path = getObjectMetadataPath(dictionary_name);\n-    ast = getCreateQueryFromMetadata(dictionary_metadata_path, throw_on_error);\n+    ast = getCreateQueryFromMetadata(context, dictionary_metadata_path, throw_on_error);\n     if (!ast && throw_on_error)\n     {\n         /// Handle system.* tables for which there are no table.sql files.\ndiff --git a/dbms/src/Databases/IDatabase.h b/dbms/src/Databases/IDatabase.h\nindex e9211560c516..64899667ff0d 100644\n--- a/dbms/src/Databases/IDatabase.h\n+++ b/dbms/src/Databases/IDatabase.h\n@@ -262,7 +262,7 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n     }\n \n     /// Get the CREATE DATABASE query for current database.\n-    virtual ASTPtr getCreateDatabaseQuery() const = 0;\n+    virtual ASTPtr getCreateDatabaseQuery(const Context & /*context*/) const = 0;\n \n     /// Get name of database.\n     String getDatabaseName() const { return database_name; }\ndiff --git a/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp b/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp\nindex 6f76016725fa..4ffe3917a599 100644\n--- a/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterShowCreateQuery.cpp\n@@ -55,7 +55,7 @@ BlockInputStreamPtr InterpreterShowCreateQuery::executeImpl()\n     {\n         if (show_query->temporary)\n             throw Exception(\"Temporary databases are not possible.\", ErrorCodes::SYNTAX_ERROR);\n-        create_query = context.getDatabase(show_query->database)->getCreateDatabaseQuery();\n+        create_query = context.getDatabase(show_query->database)->getCreateDatabaseQuery(context);\n     }\n     else if ((show_query = query_ptr->as<ASTShowCreateDictionaryQuery>()))\n     {\ndiff --git a/dbms/src/Interpreters/executeQuery.cpp b/dbms/src/Interpreters/executeQuery.cpp\nindex 69bbb6fcd41e..1f9127384541 100644\n--- a/dbms/src/Interpreters/executeQuery.cpp\n+++ b/dbms/src/Interpreters/executeQuery.cpp\n@@ -214,7 +214,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n     try\n     {\n         /// TODO Parser should fail early when max_query_size limit is reached.\n-        ast = parseQuery(parser, begin, end, \"\", max_query_size);\n+        ast = parseQuery(parser, begin, end, \"\", max_query_size, settings.max_parser_depth);\n \n         auto * insert_query = ast->as<ASTInsertQuery>();\n \ndiff --git a/dbms/src/Parsers/IParser.h b/dbms/src/Parsers/IParser.h\nindex 7b86d0663931..925140bd25ed 100644\n--- a/dbms/src/Parsers/IParser.h\n+++ b/dbms/src/Parsers/IParser.h\n@@ -5,6 +5,8 @@\n \n #include <Core/Defines.h>\n #include <Core/Types.h>\n+#include <Core/Settings.h>\n+#include <IO/WriteHelpers.h>\n #include <Parsers/IAST.h>\n #include <Parsers/TokenIterator.h>\n \n@@ -57,13 +59,15 @@ class IParser\n         using TokenIterator::TokenIterator;\n \n         uint32_t depth = 0;\n-        uint32_t max_depth = 1000;\n+        uint32_t max_depth = 0;\n+\n+        Pos(Tokens & tokens_, uint32_t max_depth_) : TokenIterator(tokens_), max_depth(max_depth_) {}\n \n         void increaseDepth()\n         {\n             ++depth;\n-            if (depth > max_depth)\n-                throw Exception(\"Maximum parse depth exceeded\", ErrorCodes::TOO_DEEP_RECURSION);\n+            if (max_depth > 0 && depth > max_depth)\n+                throw Exception(\"Maximum parse depth (\" + toString(max_depth) + \") exceeded. Consider rising max_parser_depth parameter.\", ErrorCodes::TOO_DEEP_RECURSION);\n         }\n \n         void decreaseDepth()\ndiff --git a/dbms/src/Parsers/parseQuery.cpp b/dbms/src/Parsers/parseQuery.cpp\nindex da779ae83bae..b8ab940f2dde 100644\n--- a/dbms/src/Parsers/parseQuery.cpp\n+++ b/dbms/src/Parsers/parseQuery.cpp\n@@ -215,10 +215,11 @@ ASTPtr tryParseQuery(\n     bool hilite,\n     const std::string & query_description,\n     bool allow_multi_statements,\n-    size_t max_query_size)\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n {\n     Tokens tokens(pos, end, max_query_size);\n-    IParser::Pos token_iterator(tokens);\n+    IParser::Pos token_iterator(tokens, max_parser_depth);\n \n     if (token_iterator->isEnd()\n         || token_iterator->type == TokenType::Semicolon)\n@@ -297,10 +298,11 @@ ASTPtr parseQueryAndMovePosition(\n     const char * end,\n     const std::string & query_description,\n     bool allow_multi_statements,\n-    size_t max_query_size)\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n {\n     std::string error_message;\n-    ASTPtr res = tryParseQuery(parser, pos, end, error_message, false, query_description, allow_multi_statements, max_query_size);\n+    ASTPtr res = tryParseQuery(parser, pos, end, error_message, false, query_description, allow_multi_statements, max_query_size, max_parser_depth);\n \n     if (res)\n         return res;\n@@ -314,10 +316,11 @@ ASTPtr parseQuery(\n     const char * begin,\n     const char * end,\n     const std::string & query_description,\n-    size_t max_query_size)\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n {\n     auto pos = begin;\n-    return parseQueryAndMovePosition(parser, pos, end, query_description, false, max_query_size);\n+    return parseQueryAndMovePosition(parser, pos, end, query_description, false, max_query_size, max_parser_depth);\n }\n \n \ndiff --git a/dbms/src/Parsers/parseQuery.h b/dbms/src/Parsers/parseQuery.h\nindex 85851eedacff..feea204181ea 100644\n--- a/dbms/src/Parsers/parseQuery.h\n+++ b/dbms/src/Parsers/parseQuery.h\n@@ -15,8 +15,9 @@ ASTPtr tryParseQuery(\n     bool hilite,\n     const std::string & description,\n     bool allow_multi_statements,    /// If false, check for non-space characters after semicolon and set error message if any.\n-    size_t max_query_size);         /// If (end - pos) > max_query_size and query is longer than max_query_size then throws \"Max query size exceeded\".\n+    size_t max_query_size,          /// If (end - pos) > max_query_size and query is longer than max_query_size then throws \"Max query size exceeded\".\n                                     /// Disabled if zero. Is used in order to check query size if buffer can contains data for INSERT query.\n+    size_t max_parser_depth = 0);\n \n \n /// Parse query or throw an exception with error message.\n@@ -26,15 +27,16 @@ ASTPtr parseQueryAndMovePosition(\n     const char * end,\n     const std::string & description,\n     bool allow_multi_statements,\n-    size_t max_query_size);\n-\n+    size_t max_query_size = 0,\n+    size_t max_parser_depth = 0);\n \n ASTPtr parseQuery(\n     IParser & parser,\n     const char * begin,\n     const char * end,\n     const std::string & description,\n-    size_t max_query_size);\n+    size_t max_query_size,\n+    size_t max_parser_depth = 0);\n \n ASTPtr parseQuery(\n     IParser & parser,\ndiff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\nindex 0c7f06f6022a..3bc131df07db 100644\n--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n@@ -328,12 +328,12 @@ ConstantExpressionTemplate::Cache::getFromCacheOrConstruct(const DataTypePtr & r\n     return res;\n }\n \n-bool ConstantExpressionTemplate::parseExpression(ReadBuffer & istr, const FormatSettings & settings)\n+bool ConstantExpressionTemplate::parseExpression(ReadBuffer & istr, const FormatSettings & format_settings, const Settings & settings)\n {\n     size_t cur_column = 0;\n     try\n     {\n-        if (tryParseExpression(istr, settings, cur_column))\n+        if (tryParseExpression(istr, format_settings, cur_column, settings))\n         {\n             ++rows_count;\n             return true;\n@@ -355,7 +355,7 @@ bool ConstantExpressionTemplate::parseExpression(ReadBuffer & istr, const Format\n     return false;\n }\n \n-bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const FormatSettings & settings, size_t & cur_column)\n+bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const FormatSettings & format_settings, size_t & cur_column, const Settings & settings)\n {\n     size_t cur_token = 0;\n     size_t num_columns = structure->literals.columns();\n@@ -372,13 +372,13 @@ bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const For\n         skipWhitespaceIfAny(istr);\n \n         const DataTypePtr & type = structure->literals.getByPosition(cur_column).type;\n-        if (settings.values.accurate_types_of_literals && !structure->special_parser[cur_column].useDefaultParser())\n+        if (format_settings.values.accurate_types_of_literals && !structure->special_parser[cur_column].useDefaultParser())\n         {\n-            if (!parseLiteralAndAssertType(istr, type.get(), cur_column))\n+            if (!parseLiteralAndAssertType(istr, type.get(), cur_column, settings))\n                 return false;\n         }\n         else\n-            type->deserializeAsTextQuoted(*columns[cur_column], istr, settings);\n+            type->deserializeAsTextQuoted(*columns[cur_column], istr, format_settings);\n \n         ++cur_column;\n     }\n@@ -392,7 +392,7 @@ bool ConstantExpressionTemplate::tryParseExpression(ReadBuffer & istr, const For\n     return true;\n }\n \n-bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * complex_type, size_t column_idx)\n+bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * complex_type, size_t column_idx, const Settings & settings)\n {\n     using Type = Field::Types::Which;\n \n@@ -410,7 +410,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co\n         /// TODO faster way to check types without using Parsers\n         ParserArrayOfLiterals parser_array;\n         Tokens tokens_number(istr.position(), istr.buffer().end());\n-        IParser::Pos iterator(tokens_number);\n+        IParser::Pos iterator(tokens_number, settings.max_parser_depth);\n         Expected expected;\n         ASTPtr ast;\n \ndiff --git a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\nindex 96e1c653c037..bbac2e2a9998 100644\n--- a/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\n+++ b/dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\n@@ -66,7 +66,7 @@ class ConstantExpressionTemplate : boost::noncopyable\n \n     /// Read expression from istr, assert it has the same structure and the same types of literals (template matches)\n     /// and parse literals into temporary columns\n-    bool parseExpression(ReadBuffer & istr, const FormatSettings & settings);\n+    bool parseExpression(ReadBuffer & istr, const FormatSettings & format_settings, const Settings & settings);\n \n     /// Evaluate batch of expressions were parsed using template.\n     /// If template was deduced with null_as_default == true, set bits in nulls for NULL values in column_idx, starting from offset.\n@@ -75,8 +75,8 @@ class ConstantExpressionTemplate : boost::noncopyable\n     size_t rowsCount() const { return rows_count; }\n \n private:\n-    bool tryParseExpression(ReadBuffer & istr, const FormatSettings & settings, size_t & cur_column);\n-    bool parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * type, size_t column_idx);\n+    bool tryParseExpression(ReadBuffer & istr, const FormatSettings & format_settings, size_t & cur_column, const Settings & settings);\n+    bool parseLiteralAndAssertType(ReadBuffer & istr, const IDataType * type, size_t column_idx, const Settings & settings);\n \n private:\n     TemplateStructurePtr structure;\ndiff --git a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\nindex b324719527a2..9ce3d62a2444 100644\n--- a/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n+++ b/dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n@@ -129,7 +129,8 @@ void ValuesBlockInputFormat::readRow(MutableColumns & columns, size_t row_num)\n bool ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr & column, size_t column_idx)\n {\n     /// Try to parse expression using template if one was successfully deduced while parsing the first row\n-    if (templates[column_idx]->parseExpression(buf, format_settings))\n+    auto settings = context->getSettingsRef();\n+    if (templates[column_idx]->parseExpression(buf, format_settings, settings))\n     {\n         ++rows_parsed_using_template[column_idx];\n         return true;\n@@ -187,6 +188,7 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx\n {\n     const Block & header = getPort().getHeader();\n     const IDataType & type = *header.getByPosition(column_idx).type;\n+    auto settings = context->getSettingsRef();\n \n     /// We need continuous memory containing the expression to use Lexer\n     skipToNextRow(0, 1);\n@@ -195,7 +197,7 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx\n \n     Expected expected;\n     Tokens tokens(buf.position(), buf.buffer().end());\n-    IParser::Pos token_iterator(tokens);\n+    IParser::Pos token_iterator(tokens, settings.max_parser_depth);\n     ASTPtr ast;\n \n     bool parsed = parser.parse(token_iterator, ast, expected);\n@@ -265,7 +267,7 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx\n                 ++attempts_to_deduce_template[column_idx];\n \n             buf.rollbackToCheckpoint();\n-            if (templates[column_idx]->parseExpression(buf, format_settings))\n+            if (templates[column_idx]->parseExpression(buf, format_settings, settings))\n             {\n                 ++rows_parsed_using_template[column_idx];\n                 parser_type_for_column[column_idx] = ParserType::BatchTemplate;\ndiff --git a/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp b/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp\nindex cdc9063d4153..41aaec9d1fbe 100644\n--- a/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp\n+++ b/dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp\n@@ -18,6 +18,8 @@ ColumnsDescription parseColumnsListFromString(const std::string & structure, con\n \n     Tokens tokens(structure.c_str(), structure.c_str() + structure.size());\n     IParser::Pos token_iterator(tokens);\n+    const Settings & settings = context.getSettingsRef();\n+    token_iterator.max_depth = settings.max_parser_depth;\n \n     ParserColumnDeclarationList parser;\n     ASTPtr columns_list_raw;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01062_max_parser_depth.reference b/dbms/tests/queries/0_stateless/01062_max_parser_depth.reference\nnew file mode 100644\nindex 000000000000..590b981971bc\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01062_max_parser_depth.reference\n@@ -0,0 +1,4 @@\n+-\n+Maximum parse depth (40) exceeded.\n+-\n+Maximum parse depth (20) exceeded.\ndiff --git a/dbms/tests/queries/0_stateless/01062_max_parser_depth.sh b/dbms/tests/queries/0_stateless/01062_max_parser_depth.sh\nnew file mode 100755\nindex 000000000000..17816db47584\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01062_max_parser_depth.sh\n@@ -0,0 +1,10 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+echo 'select 1' | ${CLICKHOUSE_CURL} -sSg \"${CLICKHOUSE_URL}&max_parser_depth=40\" -d @- 2>&1 | grep -oP \"Maximum parse depth .* exceeded.\"\n+echo -\n+echo 'select (1+1)*(2+1)' | ${CLICKHOUSE_CURL} -sSg \"${CLICKHOUSE_URL}&max_parser_depth=40\" -d @- 2>&1 | grep -oP \"Maximum parse depth .* exceeded.\"\n+echo -\n+echo 'select 1' | ${CLICKHOUSE_CURL} -sSg \"${CLICKHOUSE_URL}&max_parser_depth=20\" -d @- 2>&1 | grep -oP \"Maximum parse depth .* exceeded.\"\n",
  "problem_statement": "Hardcoded IParser.h max_depth = 1000 should be configurable.\nThis pull request https://github.com/yandex/ClickHouse/commit/0a9787c7f3eb295ed94c7a6d35fe702ad59648e3#diff-7ecb930104742be8bbaf5b53aa1f00deR60\r\n \r\n`uint32_t max_depth = 1000;`\r\n\r\nbroke some existing working SQL.\r\n\r\nhttps://t.me/clickhouse_ru/115334\r\n\r\n$ wc amp_task.sql\r\n      60    4122   57661 amp_task.sql\r\n\r\n\n",
  "hints_text": "+1\r\nPlease fix it\n+1 \nIt is easy to fix.\r\n\r\nAdd a setting in `Settings.h`.\r\nExtract it in `Interpreters/executeQuery.cpp`, `executeQueryImpl`, pass it to `parseQuery`.\r\nThen pass to `IParser::Pos` in `parseQuery.cpp`, `tryParseQuery`.\nHi, all!\r\nI've tried to make suggested fix, but it didn't work for me.\r\nNow I the following lines in the server log:\r\n```\r\n2020.01.13 10:47:40.777896 [ 1 ] {} <Information> DatabaseOrdinary (system): Starting up tables.\r\n2020.01.13 10:47:40.896256 [ 1 ] {} <Error> Application: Caught exception while loading metadata: Code: 306, e.displayText() = DB::Exception: Maximum parse depth (1000) exceeded. Consider rising max_parser_depth parameter.: Cannot parse definition from metadata file /u03/clickhouse/metadata/b24stat/lvm_b24_hit_event_task_2019_v20190603.sql, Stack trace (when copying this message, always include the lines below):\r\n\r\n0. 0xbc34e9c Poco::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int)  in /usr/bin/clickhouse\r\n1. 0x4f67029 DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int)  in /usr/bin/clickhouse\r\n2. 0x4cd099f DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&) (.cold)  in /usr/bin/clickhouse\r\n3. 0x9902e34 DB::ParserNull::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n4. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n5. 0x9902224 DB::ParserLiteral::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n6. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n7. 0x9902380 DB::ParserExpressionElement::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n8. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n9. 0x9915184 DB::ParserLeftAssociativeBinaryOperatorList::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n10. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n11. 0x991061d DB::ParserArrayElementExpression::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n12. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n13. 0x9915184 DB::ParserLeftAssociativeBinaryOperatorList::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n14. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n15. 0x990f8b5 DB::ParserTupleElementExpression::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n16. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n17. 0x9911404 DB::ParserPrefixUnaryOperatorExpression::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n18. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n19. 0x990fb4d DB::ParserUnaryMinusExpression::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n20. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n21. 0x9915184 DB::ParserLeftAssociativeBinaryOperatorList::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n22. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n23. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n24. 0x9914634 DB::ParserIntervalOperatorExpression::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n25. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n26. 0x9915184 DB::ParserLeftAssociativeBinaryOperatorList::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n27. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n28. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n29. 0x9914bb0 DB::ParserVariableArityOperatorList::parseImpl(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n30. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n31. 0x9918d1b DB::IParserBase::parse(DB::IParser::Pos&, std::__1::shared_ptr<DB::IAST>&, DB::Expected&)  in /usr/bin/clickhouse\r\n (version 20.1.1.1)\r\n2020.01.13 10:47:40.896372 [ 1 ] {} <Information> Application: Shutting down storages.\r\n2020.01.13 10:47:41.727508 [ 1 ] {} <Debug> Application: Shut down storages.\r\n2020.01.13 10:47:41.728883 [ 1 ] {} <Debug> Application: Destroyed global context.\r\n```\r\nThe IParser::Pos instantiates in many places and I'd like to \"move\" settings reading into it's constructor, but I have no idea how to get \"context\" there.\r\nAny suggestions ?\n I've \"fixed\" all IParser::Pos instantions and only then found the code to fix this error.\r\nIn the file DatabaseOnDisk.cpp in function parseQueryFromMetadata where is tryParseQuery call w/o max_query_size and (just added) max_parser_depth parameters.\r\n\nOk.\r\n\r\nLet's integrate this patch... Could you please send a PR?\n> Ok.\r\n> \r\n> Let's integrate this patch... Could you please send a PR?\r\n\r\nYes I'll send one. I'll try my best to finish it today",
  "created_at": "2020-01-14T11:25:15Z",
  "modified_files": [
    "dbms/src/Core/Settings.h",
    "dbms/src/Databases/DatabaseDictionary.cpp",
    "dbms/src/Databases/DatabaseDictionary.h",
    "dbms/src/Databases/DatabaseLazy.cpp",
    "dbms/src/Databases/DatabaseMemory.cpp",
    "dbms/src/Databases/DatabaseMemory.h",
    "dbms/src/Databases/DatabaseMySQL.cpp",
    "dbms/src/Databases/DatabaseMySQL.h",
    "dbms/src/Databases/DatabaseOnDisk.cpp",
    "dbms/src/Databases/DatabaseOnDisk.h",
    "dbms/src/Databases/DatabaseOrdinary.cpp",
    "dbms/src/Databases/DatabaseWithDictionaries.cpp",
    "dbms/src/Databases/IDatabase.h",
    "dbms/src/Interpreters/InterpreterShowCreateQuery.cpp",
    "dbms/src/Interpreters/executeQuery.cpp",
    "dbms/src/Parsers/IParser.h",
    "dbms/src/Parsers/parseQuery.cpp",
    "dbms/src/Parsers/parseQuery.h",
    "dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp",
    "dbms/src/Processors/Formats/Impl/ConstantExpressionTemplate.h",
    "dbms/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp",
    "dbms/src/TableFunctions/parseColumnsListForTableFunction.cpp"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/01062_max_parser_depth.reference",
    "b/dbms/tests/queries/0_stateless/01062_max_parser_depth.sh"
  ]
}