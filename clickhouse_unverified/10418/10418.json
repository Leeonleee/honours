{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10418,
  "instance_id": "ClickHouse__ClickHouse-10418",
  "issue_numbers": [
    "10204"
  ],
  "base_commit": "fa2385b26b0021fe65e69fdecc071c61a9a4729d",
  "patch": "diff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h\nindex 6edc300eac8c..c3c7edb2221e 100644\n--- a/src/IO/readDecimalText.h\n+++ b/src/IO/readDecimalText.h\n@@ -33,17 +33,14 @@ inline bool readDigits(ReadBuffer & buf, T & x, unsigned int & digits, int & exp\n         return false;\n     }\n \n-    if (!buf.eof())\n+    switch (*buf.position())\n     {\n-        switch (*buf.position())\n-        {\n-            case '-':\n-                sign = -1;\n-                [[fallthrough]];\n-            case '+':\n-                ++buf.position();\n-                break;\n-        }\n+        case '-':\n+            sign = -1;\n+            [[fallthrough]];\n+        case '+':\n+            ++buf.position();\n+            break;\n     }\n \n     bool stop = false;\ndiff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp\nindex 74f4dccaa86b..76fc5b863394 100644\n--- a/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/src/Processors/Formats/IRowInputFormat.cpp\n@@ -18,6 +18,8 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_UUID;\n     extern const int TOO_LARGE_STRING_SIZE;\n     extern const int INCORRECT_NUMBER_OF_COLUMNS;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n+    extern const int INCORRECT_DATA;\n }\n \n \n@@ -30,7 +32,9 @@ bool isParseError(int code)\n         || code == ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT\n         || code == ErrorCodes::CANNOT_PARSE_NUMBER\n         || code == ErrorCodes::CANNOT_PARSE_UUID\n-        || code == ErrorCodes::TOO_LARGE_STRING_SIZE;\n+        || code == ErrorCodes::TOO_LARGE_STRING_SIZE\n+        || code == ErrorCodes::ARGUMENT_OUT_OF_BOUND       /// For Decimals\n+        || code == ErrorCodes::INCORRECT_DATA;             /// For some ReadHelpers\n }\n \n \n@@ -127,6 +131,10 @@ Chunk IRowInputFormat::generate()\n         {\n             verbose_diagnostic = getDiagnosticInfo();\n         }\n+        catch (const Exception & exception)\n+        {\n+            verbose_diagnostic = \"Cannot get verbose diagnostic: \" + exception.message();\n+        }\n         catch (...)\n         {\n             /// Error while trying to obtain verbose diagnostic. Ok to ignore.\ndiff --git a/src/Processors/Formats/Impl/CSVRowInputFormat.cpp b/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\nindex bd16de69f759..7bca5f2c5d95 100644\n--- a/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\n@@ -273,6 +273,7 @@ bool CSVRowInputFormat::parseRowAndPrintDiagnosticInfo(MutableColumns & columns,\n             return false;\n         }\n \n+        skipWhitespacesAndTabs(in);\n         if (column_indexes_for_input_fields[file_column].has_value())\n         {\n             const auto & header = getPort().getHeader();\n@@ -289,6 +290,7 @@ bool CSVRowInputFormat::parseRowAndPrintDiagnosticInfo(MutableColumns & columns,\n             if (!deserializeFieldAndPrintDiagnosticInfo(skipped_column_str, skipped_column_type, *skipped_column, out, file_column))\n                 return false;\n         }\n+        skipWhitespacesAndTabs(in);\n \n         /// Delimiters\n         if (file_column + 1 == column_indexes_for_input_fields.size())\n@@ -351,12 +353,8 @@ void CSVRowInputFormat::syncAfterError()\n     skipToNextLineOrEOF(in);\n }\n \n-void CSVRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column,\n-                                            ReadBuffer::Position & prev_pos, ReadBuffer::Position & curr_pos)\n+void CSVRowInputFormat::tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column)\n {\n-    skipWhitespacesAndTabs(in);\n-    prev_pos = in.position();\n-\n     if (column_indexes_for_input_fields[file_column])\n     {\n         const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();\n@@ -367,9 +365,6 @@ void CSVRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn &\n         String tmp;\n         readCSVString(tmp, in, format_settings.csv);\n     }\n-\n-    curr_pos = in.position();\n-    skipWhitespacesAndTabs(in);\n }\n \n bool CSVRowInputFormat::readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column)\ndiff --git a/src/Processors/Formats/Impl/CSVRowInputFormat.h b/src/Processors/Formats/Impl/CSVRowInputFormat.h\nindex 9916e80a0797..c884eb6c3db5 100644\n--- a/src/Processors/Formats/Impl/CSVRowInputFormat.h\n+++ b/src/Processors/Formats/Impl/CSVRowInputFormat.h\n@@ -55,11 +55,10 @@ class CSVRowInputFormat : public RowInputFormatWithDiagnosticInfo\n     void addInputColumn(const String & column_name);\n \n     bool parseRowAndPrintDiagnosticInfo(MutableColumns & columns, WriteBuffer & out) override;\n-    void tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column,\n-                             ReadBuffer::Position & prev_pos, ReadBuffer::Position & curr_pos) override;\n+    void tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column) override;\n     bool isGarbageAfterField(size_t, ReadBuffer::Position pos) override\n     {\n-        return *pos != '\\n' && *pos != '\\r' && *pos != format_settings.csv.delimiter;\n+        return *pos != '\\n' && *pos != '\\r' && *pos != format_settings.csv.delimiter && *pos != ' ' && *pos != '\\t';\n     }\n \n     bool readField(IColumn & column, const DataTypePtr & type, bool is_last_file_column);\ndiff --git a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\nindex 014795cade17..dbbd1e28aa0b 100644\n--- a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n@@ -318,10 +318,8 @@ bool TabSeparatedRowInputFormat::parseRowAndPrintDiagnosticInfo(MutableColumns &\n     return true;\n }\n \n-void TabSeparatedRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column,\n-                                                     ReadBuffer::Position & prev_pos, ReadBuffer::Position & curr_pos)\n+void TabSeparatedRowInputFormat::tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column)\n {\n-    prev_pos = in.position();\n     if (column_indexes_for_input_fields[file_column])\n     {\n         const bool is_last_file_column = file_column + 1 == column_indexes_for_input_fields.size();\n@@ -332,7 +330,6 @@ void TabSeparatedRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, I\n         NullSink null_sink;\n         readEscapedStringInto(null_sink, in);\n     }\n-    curr_pos = in.position();\n }\n \n void TabSeparatedRowInputFormat::syncAfterError()\ndiff --git a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h\nindex 5bb0a636e1ae..b0e52fdde93f 100644\n--- a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h\n+++ b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.h\n@@ -50,8 +50,7 @@ class TabSeparatedRowInputFormat : public RowInputFormatWithDiagnosticInfo\n     void fillUnreadColumnsWithDefaults(MutableColumns & columns, RowReadExtension & row_read_extension);\n \n     bool parseRowAndPrintDiagnosticInfo(MutableColumns & columns, WriteBuffer & out) override;\n-    void tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column,\n-                             ReadBuffer::Position & prev_pos, ReadBuffer::Position & curr_pos) override;\n+    void tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column) override;\n     bool isGarbageAfterField(size_t, ReadBuffer::Position pos) override { return *pos != '\\n' && *pos != '\\t'; }\n };\n \ndiff --git a/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp b/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\nindex 2a0fe6d6ec6c..271b9ea75c5a 100644\n--- a/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n@@ -410,15 +410,12 @@ void TemplateRowInputFormat::writeErrorStringForWrongDelimiter(WriteBuffer & out\n     out << '\\n';\n }\n \n-void TemplateRowInputFormat::tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column,\n-                                                 ReadBuffer::Position & prev_pos, ReadBuffer::Position & curr_pos)\n+void TemplateRowInputFormat::tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column)\n {\n-    prev_pos = buf.position();\n     if (row_format.format_idx_to_column_idx[file_column])\n         deserializeField(type, column, file_column);\n     else\n         skipField(row_format.formats[file_column]);\n-    curr_pos = buf.position();\n }\n \n bool TemplateRowInputFormat::isGarbageAfterField(size_t, ReadBuffer::Position)\ndiff --git a/src/Processors/Formats/Impl/TemplateRowInputFormat.h b/src/Processors/Formats/Impl/TemplateRowInputFormat.h\nindex 4a39396399d7..efdf6eb5e6d9 100644\n--- a/src/Processors/Formats/Impl/TemplateRowInputFormat.h\n+++ b/src/Processors/Formats/Impl/TemplateRowInputFormat.h\n@@ -42,8 +42,7 @@ class TemplateRowInputFormat : public RowInputFormatWithDiagnosticInfo\n     [[noreturn]] void throwUnexpectedEof();\n \n     bool parseRowAndPrintDiagnosticInfo(MutableColumns & columns, WriteBuffer & out) override;\n-    void tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column, ReadBuffer::Position & prev_pos,\n-                             ReadBuffer::Position & curr_pos) override;\n+    void tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column) override;\n     bool isGarbageAfterField(size_t after_col_idx, ReadBuffer::Position pos) override;\n     void writeErrorStringForWrongDelimiter(WriteBuffer & out, const String & description, const String & delim);\n \ndiff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\nindex 80428bd195aa..25e93215ddf1 100644\n--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n@@ -20,10 +20,10 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n-    extern const int CANNOT_PARSE_INPUT_ASSERTION_FAILED;\n     extern const int SYNTAX_ERROR;\n     extern const int TYPE_MISMATCH;\n     extern const int SUPPORT_IS_DISABLED;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n }\n \n \n@@ -167,7 +167,9 @@ bool ValuesBlockInputFormat::tryReadValue(IColumn & column, size_t column_idx)\n     }\n     catch (const Exception & e)\n     {\n-        if (!isParseError(e.code()) && e.code() != ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED)\n+        /// Do not consider decimal overflow as parse error to avoid attempts to parse it as expression with float literal\n+        bool decimal_overflow = e.code() == ErrorCodes::ARGUMENT_OUT_OF_BOUND;\n+        if (!isParseError(e.code()) || decimal_overflow)\n             throw;\n         if (rollback_on_exception)\n             column.popBack(1);\n@@ -226,7 +228,8 @@ bool ValuesBlockInputFormat::parseExpression(IColumn & column, size_t column_idx\n         }\n         catch (const Exception & e)\n         {\n-            if (!isParseError(e.code()))\n+            bool decimal_overflow = e.code() == ErrorCodes::ARGUMENT_OUT_OF_BOUND;\n+            if (!isParseError(e.code()) || decimal_overflow)\n                 throw;\n         }\n         if (ok)\ndiff --git a/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.cpp b/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.cpp\nindex ff40597073bd..9cd2b14238ce 100644\n--- a/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.cpp\n+++ b/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.cpp\n@@ -37,8 +37,8 @@ void RowInputFormatWithDiagnosticInfo::updateDiagnosticInfo()\n \n String RowInputFormatWithDiagnosticInfo::getDiagnosticInfo()\n {\n-    if (in.eof())        /// Buffer has gone, cannot extract information about what has been parsed.\n-        return {};\n+    if (in.eof())\n+        return \"Buffer has gone, cannot extract information about what has been parsed.\";\n \n     WriteBufferFromOwnString out;\n \n@@ -102,17 +102,17 @@ bool RowInputFormatWithDiagnosticInfo::deserializeFieldAndPrintDiagnosticInfo(co\n         << \"type: \" << alignedName(type->getName(), max_length_of_data_type_name);\n \n     auto * prev_position = in.position();\n-    auto * curr_position = in.position();\n     std::exception_ptr exception;\n \n     try\n     {\n-        tryDeserializeFiled(type, column, file_column, prev_position, curr_position);\n+        tryDeserializeField(type, column, file_column);\n     }\n     catch (...)\n     {\n         exception = std::current_exception();\n     }\n+    auto * curr_position = in.position();\n \n     if (curr_position < prev_position)\n         throw Exception(\"Logical error: parsing is non-deterministic.\", ErrorCodes::LOGICAL_ERROR);\ndiff --git a/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.h b/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.h\nindex 1d502ddc2812..5bad24cd482a 100644\n--- a/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.h\n+++ b/src/Processors/Formats/RowInputFormatWithDiagnosticInfo.h\n@@ -24,8 +24,7 @@ class RowInputFormatWithDiagnosticInfo : public IRowInputFormat\n                                                 WriteBuffer & out, size_t file_column);\n \n     virtual bool parseRowAndPrintDiagnosticInfo(MutableColumns & columns, WriteBuffer & out) = 0;\n-    virtual void tryDeserializeFiled(const DataTypePtr & type, IColumn & column, size_t file_column,\n-                                     ReadBuffer::Position & prev_pos, ReadBuffer::Position & curr_pos) = 0;\n+    virtual void tryDeserializeField(const DataTypePtr & type, IColumn & column, size_t file_column) = 0;\n     virtual bool isGarbageAfterField(size_t after_input_pos_idx, ReadBuffer::Position pos) = 0;\n \n     /// For convenient diagnostics in case of an error.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01195_formats_diagnostic_info.reference b/tests/queries/0_stateless/01195_formats_diagnostic_info.reference\nnew file mode 100644\nindex 000000000000..708841559c26\n--- /dev/null\n+++ b/tests/queries/0_stateless/01195_formats_diagnostic_info.reference\n@@ -0,0 +1,29 @@\n+CSV\n+Column 2,   name: d, type: Decimal(18, 10), parsed text: \"123456789\"ERROR\n+ERROR: garbage after DateTime: \"7, <DOUBLE QUOTE>Hello<DOUBLE QUOTE>\"\n+ERROR: DateTime must be in YYYY-MM-DD hh:mm:ss or NNNNNNNNNN (unix timestamp, exactly 10 digits) format.\n+ERROR: There is no line feed. \"1\" found instead.\n+ERROR: garbage after Decimal(18, 10): \"Hello<LINE FEED>\"\n+Column 0,   name: t, type: DateTime,        ERROR: text \"<LINE FEED>\" is not like DateTime\n+\n+CustomSeparatedIgnoreSpaces\n+Column 2,   name: d, type: Decimal(18, 10), parsed text: \"123456789\"ERROR\n+ERROR: There is no delimiter before field 1: expected \",\", got \"7, <DOUBLE QUOTE>Hello<DOUBLE QUOTE>,\"\n+Column 0,   name: t, type: DateTime,        ERROR: text \",1<LINE FEED>\" is not like DateTime\n+Column 0,   name: t, type: DateTime,        ERROR: text \"Hello<LINE FEED>\" is not like DateTime\n+OK\n+\n+TSV\n+Column 2,   name: d, type: Decimal(18, 10), parsed text: \"123456789\"ERROR\n+ERROR: garbage after DateTime: \"7<TAB>Hello<TAB>12\"\n+ERROR: DateTime must be in YYYY-MM-DD hh:mm:ss or NNNNNNNNNN (unix timestamp, exactly 10 digits) format.\n+ERROR: Tab found where line feed is expected. It's like your file has more columns than expected.\n+ERROR: garbage after Decimal(18, 10): \"Hello<LINE FEED>\"\n+Column 0,   name: t, type: DateTime,        ERROR: text \"<LINE FEED>\" is not like DateTime\n+\n+CustomSeparated\n+Column 2,   name: d, type: Decimal(18, 10), parsed text: \"123456789\"ERROR\n+ERROR: There is no delimiter before field 1: expected \"<TAB>\", got \"7<TAB>Hello<TAB>123\"\n+ERROR: There is no delimiter after last field: expected \"<LINE FEED>\", got \"<TAB>1<LINE FEED>\"\n+ERROR: There is no delimiter after last field: expected \"<LINE FEED>\", got \"Hello<LINE FEED>\"\n+Column 0,   name: t, type: DateTime,        ERROR: text \"<LINE FEED>\" is not like DateTime\ndiff --git a/tests/queries/0_stateless/01195_formats_diagnostic_info.sh b/tests/queries/0_stateless/01195_formats_diagnostic_info.sh\nnew file mode 100755\nindex 000000000000..e07b03e9512b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01195_formats_diagnostic_info.sh\n@@ -0,0 +1,37 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+PARSER=(${CLICKHOUSE_LOCAL} --query 'SELECT t, s, d FROM table' --structure 't DateTime, s String, d Decimal64(10)' --input-format CSV)\n+echo '2020-04-21 12:34:56, \"Hello\", 12345678' | \"${PARSER[@]}\"  2>&1| grep \"ERROR\" || echo \"CSV\"\n+echo '2020-04-21 12:34:56, \"Hello\", 123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo '2020-04-21 12:34:567, \"Hello\", 123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+#echo '2020-04-21, \"Hello\", 123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"    # DateTime parsing is unsafe, it produces unexpected result (\"Hello\" is parsed as time)\n+echo '2020-04-21 12:34:56, \"Hello\", 12345678,1' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo '2020-04-21 12:34:56,,123Hello' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56, \"Hello\", 12345678\\n' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+\n+PARSER=(${CLICKHOUSE_LOCAL} --query 'SELECT t, s, d FROM table' --structure 't DateTime, s String, d Decimal64(10)' --input-format CustomSeparatedIgnoreSpaces --format_custom_escaping_rule CSV --format_custom_field_delimiter ',' --format_custom_row_after_delimiter \"\")\n+echo '2020-04-21 12:34:56, \"Hello\", 12345678' | \"${PARSER[@]}\"  2>&1| grep \"ERROR\" || echo -e  \"\\nCustomSeparatedIgnoreSpaces\"\n+echo '2020-04-21 12:34:56, \"Hello\", 123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo '2020-04-21 12:34:567, \"Hello\", 123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo '2020-04-21 12:34:56, \"Hello\", 12345678,1' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo '2020-04-21 12:34:56,,123Hello' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56, \"Hello\", 12345678\\n\\n\\n\\n   ' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\" || echo \"OK\"\n+\n+PARSER=(${CLICKHOUSE_LOCAL} --query 'SELECT t, s, d FROM table' --structure 't DateTime, s String, d Decimal64(10)' --input-format TSV)\n+echo -e '2020-04-21 12:34:56\\tHello\\t12345678' | \"${PARSER[@]}\"  2>&1| grep \"ERROR\" || echo -e \"\\nTSV\"\n+echo -e '2020-04-21 12:34:56\\tHello\\t123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:567\\tHello\\t123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56\\tHello\\t12345678\\t1' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56\\t\\t123Hello' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56\\tHello\\t12345678\\n' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+\n+PARSER=(${CLICKHOUSE_LOCAL} --query 'SELECT t, s, d FROM table' --structure 't DateTime, s String, d Decimal64(10)' --input-format CustomSeparated)\n+echo -e '2020-04-21 12:34:56\\tHello\\t12345678' | \"${PARSER[@]}\"  2>&1| grep \"ERROR\" || echo -e \"\\nCustomSeparated\"\n+echo -e '2020-04-21 12:34:56\\tHello\\t123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:567\\tHello\\t123456789' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56\\tHello\\t12345678\\t1' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56\\t\\t123Hello' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n+echo -e '2020-04-21 12:34:56\\tHello\\t12345678\\n' | \"${PARSER[@]}\" 2>&1| grep \"ERROR\"\n",
  "problem_statement": "Logical error: parsing is non-deterministic.\n```\r\nclickhouse-local --query \"SELECT * FROM table\" --input-format CSV --structure 's String, d Decimal64(10)' <<<'\"Hello\", 123456789'\r\n```\r\n\r\nThis command will yield logical error.\n",
  "hints_text": "",
  "created_at": "2020-04-21T20:47:54Z"
}