{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56331,
  "instance_id": "ClickHouse__ClickHouse-56331",
  "issue_numbers": [
    "55651"
  ],
  "base_commit": "980ab94e8d06d1766eb94738ffca8c24ec247057",
  "patch": "diff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex f851607000c0..54b4334eda9d 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -105,7 +105,6 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n     if (table->isStaticStorage())\n         throw Exception(ErrorCodes::TABLE_IS_READ_ONLY, \"Table is read-only\");\n     auto table_lock = table->lockForShare(getContext()->getCurrentQueryId(), getContext()->getSettingsRef().lock_acquire_timeout);\n-    auto metadata_snapshot = table->getInMemoryMetadataPtr();\n \n     /// Add default database to table identifiers that we can encounter in e.g. default expressions, mutation expression, etc.\n     AddDefaultDatabaseVisitor visitor(getContext(), table_id.getDatabaseName());\n@@ -128,10 +127,6 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n         }\n         else if (auto mut_command = MutationCommand::parse(command_ast))\n         {\n-            if (mut_command->type == MutationCommand::MATERIALIZE_TTL && !metadata_snapshot->hasAnyTTL())\n-                throw Exception(ErrorCodes::INCORRECT_QUERY, \"Cannot MATERIALIZE TTL as there is no TTL set for table {}\",\n-                    table->getStorageID().getNameForLogs());\n-\n             if (mut_command->type == MutationCommand::UPDATE || mut_command->type == MutationCommand::DELETE)\n             {\n                 /// TODO: add a check for result query size.\n@@ -162,8 +157,30 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n                                                          \"to execute ALTERs of different types (replicated and non replicated) in single query\");\n     }\n \n+    if (!alter_commands.empty())\n+    {\n+        auto alter_lock = table->lockForAlter(getContext()->getSettingsRef().lock_acquire_timeout);\n+        StorageInMemoryMetadata metadata = table->getInMemoryMetadata();\n+        alter_commands.validate(table, getContext());\n+        alter_commands.prepare(metadata);\n+        table->checkAlterIsPossible(alter_commands, getContext());\n+        table->alter(alter_commands, getContext(), alter_lock);\n+    }\n+\n+    /// Get newest metadata_snapshot after execute ALTER command, in order to\n+    /// support like materialize index in the same ALTER query that creates it.\n+    auto metadata_snapshot = table->getInMemoryMetadataPtr();\n+\n     if (mutation_commands.hasNonEmptyMutationCommands())\n     {\n+        for (const auto & command : mutation_commands)\n+        {\n+            /// Check it after alter finished, so we can add TTL and materialize TTL in the same ALTER query.\n+            if (command.type == MutationCommand::MATERIALIZE_TTL && !metadata_snapshot->hasAnyTTL())\n+                throw Exception(ErrorCodes::INCORRECT_QUERY, \"Cannot MATERIALIZE TTL as there is no TTL set for table {}\",\n+                    table->getStorageID().getNameForLogs());\n+\n+        }\n         table->checkMutationIsPossible(mutation_commands, getContext()->getSettingsRef());\n         MutationsInterpreter::Settings settings(false);\n         MutationsInterpreter(table, metadata_snapshot, mutation_commands, getContext(), settings).validate();\n@@ -178,16 +195,6 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)\n             res.pipeline = QueryPipeline(std::move(partition_commands_pipe));\n     }\n \n-    if (!alter_commands.empty())\n-    {\n-        auto alter_lock = table->lockForAlter(getContext()->getSettingsRef().lock_acquire_timeout);\n-        StorageInMemoryMetadata metadata = table->getInMemoryMetadata();\n-        alter_commands.validate(table, getContext());\n-        alter_commands.prepare(metadata);\n-        table->checkAlterIsPossible(alter_commands, getContext());\n-        table->alter(alter_commands, getContext(), alter_lock);\n-    }\n-\n     return res;\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02911_add_index_and_materialize_index.reference b/tests/queries/0_stateless/02911_add_index_and_materialize_index.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02911_add_index_and_materialize_index.sql b/tests/queries/0_stateless/02911_add_index_and_materialize_index.sql\nnew file mode 100644\nindex 000000000000..f8785ec9a38e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02911_add_index_and_materialize_index.sql\n@@ -0,0 +1,18 @@\n+-- Tags: no-replicated-database\n+\n+DROP TABLE IF EXISTS index_test;\n+\n+CREATE TABLE index_test\n+(\n+\tx UInt32,\n+\ty UInt32,\n+\tz UInt32\n+) ENGINE = MergeTree order by x;\n+\n+ALTER TABLE index_test\n+    ADD INDEX i_x mortonDecode(2, z).1 TYPE minmax GRANULARITY 1,\n+    ADD INDEX i_y mortonDecode(2, z).2 TYPE minmax GRANULARITY 1,\n+    MATERIALIZE INDEX i_x,\n+    MATERIALIZE INDEX i_y;\n+\n+drop table index_test;\n",
  "problem_statement": "Cannot materialize index in the same ALTER query that creates it.\n**Use case**\r\n\r\n```\r\nmilovidov-desktop :) ALTER TABLE index_test ADD INDEX i_x (mortonDecode(2, z).1) TYPE minmax, ADD INDEX i_y (mortonDecode(2, z).2) TYPE minmax, MATERIALIZE INDEX i_x, MATERIALIZE INDEX i_y\r\n\r\nALTER TABLE index_test\r\n    ADD INDEX i_x mortonDecode(2, z).1 TYPE minmax GRANULARITY 1,\r\n    ADD INDEX i_y mortonDecode(2, z).2 TYPE minmax GRANULARITY 1,\r\n    MATERIALIZE INDEX i_x,\r\n    MATERIALIZE INDEX i_y\r\n\r\nQuery id: dcf2a9f0-f20e-4e49-ab6c-e0aa4f30eccb\r\n\r\n\r\n0 rows in set. Elapsed: 0.015 sec. \r\n\r\nReceived exception from server (version 23.10.1):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: Unknown index: i_x. (BAD_ARGUMENTS)\r\n```\n",
  "hints_text": "",
  "created_at": "2023-11-04T14:38:11Z",
  "modified_files": [
    "src/Interpreters/InterpreterAlterQuery.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02911_add_index_and_materialize_index.sql"
  ]
}