diff --git a/docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md b/docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md
deleted file mode 100644
index e34fcbc57880..000000000000
--- a/docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md
+++ /dev/null
@@ -1,48 +0,0 @@
----
-sidebar_position: 108
----
-
-# groupArraySorted {#groupArraySorted}
-
-Returns an array with the first N items in ascending order.
-
-``` sql
-groupArraySorted(N)(column)
-```
-
-**Arguments**
-
--   `N` – The number of elements to return.
-
-If the parameter is omitted, default value 10 is used.
-
-**Arguments**
-
--   `column` – The value.
--   `expr` — Optional. The field or expresion to sort by. If not set values are sorted by themselves.
-
-**Example**
-
-Gets the first 10 numbers:
-
-``` sql
-SELECT groupArraySorted(10)(number) FROM numbers(100)
-```
-
-``` text
-┌─groupArraySorted(10)(number)─┐
-│ [0,1,2,3,4,5,6,7,8,9]        │
-└──────────────────────────────┘
-```
-
-Or the last 10:
-
-``` sql
-SELECT groupArraySorted(10)(number, -number) FROM numbers(100)
-```
-
-``` text
-┌─groupArraySorted(10)(number, negate(number))─┐
-│ [99,98,97,96,95,94,93,92,91,90]              │
-└──────────────────────────────────────────────┘
-```
\ No newline at end of file
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp b/src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp
deleted file mode 100644
index 50d5f075322b..000000000000
--- a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp
+++ /dev/null
@@ -1,147 +0,0 @@
-#include <AggregateFunctions/AggregateFunctionFactory.h>
-#include <AggregateFunctions/AggregateFunctionGroupArraySorted.h>
-#include <AggregateFunctions/FactoryHelpers.h>
-#include <AggregateFunctions/Helpers.h>
-#include <DataTypes/DataTypeDate.h>
-#include <DataTypes/DataTypeDateTime.h>
-#include <DataTypes/DataTypeString.h>
-#include <Common/FieldVisitorConvertToNumber.h>
-
-
-static inline constexpr UInt64 GROUP_SORTED_ARRAY_MAX_SIZE = 0xFFFFFF;
-static inline constexpr UInt64 GROUP_SORTED_ARRAY_DEFAULT_THRESHOLD = 10;
-
-
-namespace DB
-{
-struct Settings;
-
-namespace ErrorCodes
-{
-    extern const int ARGUMENT_OUT_OF_BOUND;
-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
-}
-
-
-namespace
-{
-    template <typename T, bool expr_sorted, typename TColumnB, bool is_plain_b>
-    class AggregateFunctionGroupArraySortedNumeric : public AggregateFunctionGroupArraySorted<T, false, expr_sorted, TColumnB, is_plain_b>
-    {
-        using AggregateFunctionGroupArraySorted<T, false, expr_sorted, TColumnB, is_plain_b>::AggregateFunctionGroupArraySorted;
-    };
-
-    template <typename T, bool expr_sorted, typename TColumnB, bool is_plain_b>
-    class AggregateFunctionGroupArraySortedFieldType
-        : public AggregateFunctionGroupArraySorted<typename T::FieldType, false, expr_sorted, TColumnB, is_plain_b>
-    {
-        using AggregateFunctionGroupArraySorted<typename T::FieldType, false, expr_sorted, TColumnB, is_plain_b>::
-            AggregateFunctionGroupArraySorted;
-        DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<T>()); }
-    };
-
-    template <template <typename, bool, typename, bool> class AggregateFunctionTemplate, typename TColumnA, bool expr_sorted, typename TColumnB, bool is_plain_b, typename... TArgs>
-    AggregateFunctionPtr
-    createAggregateFunctionGroupArraySortedTypedFinal(TArgs && ... args)
-    {
-        return AggregateFunctionPtr(new AggregateFunctionTemplate<TColumnA, expr_sorted, TColumnB, is_plain_b>(std::forward<TArgs>(args)...));
-    }
-
-    template <bool expr_sorted = false, typename TColumnB = UInt64, bool is_plain_b = false>
-    AggregateFunctionPtr
-    createAggregateFunctionGroupArraySortedTyped(const DataTypes & argument_types, const Array & params, UInt64 threshold)
-    {
-#define DISPATCH(A, C, B) \
-    if (which.idx == TypeIndex::A) \
-        return createAggregateFunctionGroupArraySortedTypedFinal<C, B, expr_sorted, TColumnB, is_plain_b>(threshold, argument_types, params);
-#define DISPATCH_NUMERIC(A) DISPATCH(A, AggregateFunctionGroupArraySortedNumeric, A)
-        WhichDataType which(argument_types[0]);
-        FOR_NUMERIC_TYPES(DISPATCH_NUMERIC)
-        DISPATCH(Enum8, AggregateFunctionGroupArraySortedNumeric, Int8)
-        DISPATCH(Enum16, AggregateFunctionGroupArraySortedNumeric, Int16)
-        DISPATCH(Date, AggregateFunctionGroupArraySortedFieldType, DataTypeDate)
-        DISPATCH(DateTime, AggregateFunctionGroupArraySortedFieldType, DataTypeDateTime)
-#undef DISPATCH
-#undef DISPATCH_NUMERIC
-
-        if (argument_types[0]->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
-        {
-            return AggregateFunctionPtr(new AggregateFunctionGroupArraySorted<StringRef, true, expr_sorted, TColumnB, is_plain_b>(
-                threshold, argument_types, params));
-        }
-        else
-        {
-            return AggregateFunctionPtr(new AggregateFunctionGroupArraySorted<StringRef, false, expr_sorted, TColumnB, is_plain_b>(
-                threshold, argument_types, params));
-        }
-    }
-
-
-    AggregateFunctionPtr createAggregateFunctionGroupArraySorted(
-        const std::string & name, const DataTypes & argument_types, const Array & params, const Settings *)
-    {
-        UInt64 threshold = GROUP_SORTED_ARRAY_DEFAULT_THRESHOLD;
-
-        if (params.size() == 1)
-        {
-            UInt64 k = applyVisitor(FieldVisitorConvertToNumber<UInt64>(), params[0]);
-
-            if (k > GROUP_SORTED_ARRAY_MAX_SIZE)
-                throw Exception(
-                    "Too large parameter(s) for aggregate function " + name + ". Maximum: " + toString(GROUP_SORTED_ARRAY_MAX_SIZE),
-                    ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-
-            if (k == 0)
-                throw Exception("Parameter 0 is illegal for aggregate function " + name, ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-
-            threshold = k;
-        }
-        else if (!params.empty())
-        {
-            throw Exception("Aggregate function " + name + " only supports 1 parameter.", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
-        }
-
-        if (argument_types.size() == 2)
-        {
-            if (isNumber(argument_types[1]))
-            {
-#define DISPATCH2(A, B) \
-    if (which.idx == TypeIndex::A) \
-        return createAggregateFunctionGroupArraySortedTyped<true, B>(argument_types, params, threshold);
-#define DISPATCH(A) DISPATCH2(A, A)
-                WhichDataType which(argument_types[1]);
-                FOR_NUMERIC_TYPES(DISPATCH)
-                DISPATCH2(Enum8, Int8)
-                DISPATCH2(Enum16, Int16)
-#undef DISPATCH
-#undef DISPATCH2
-                throw Exception("Invalid parameter type.", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);
-            }
-            else if (argument_types[1]->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())
-            {
-                return createAggregateFunctionGroupArraySortedTyped<true, StringRef, true>(argument_types, params, threshold);
-            }
-            else
-            {
-                return createAggregateFunctionGroupArraySortedTyped<true, StringRef, false>(argument_types, params, threshold);
-            }
-        }
-        else if (argument_types.size() == 1)
-        {
-            return createAggregateFunctionGroupArraySortedTyped<>(argument_types, params, threshold);
-        }
-        else
-        {
-            throw Exception(
-                "Aggregate function " + name + " requires one or two parameters.", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);
-        }
-    }
-}
-
-void registerAggregateFunctionGroupArraySorted(AggregateFunctionFactory & factory)
-{
-    AggregateFunctionProperties properties = {.returns_default_when_only_null = false, .is_order_dependent = true};
-    factory.registerFunction("groupArraySorted", {createAggregateFunctionGroupArraySorted, properties});
-}
-}
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.h b/src/AggregateFunctions/AggregateFunctionGroupArraySorted.h
deleted file mode 100644
index 0a9111297f2d..000000000000
--- a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.h
+++ /dev/null
@@ -1,315 +0,0 @@
-#pragma once
-
-#include <Columns/ColumnArray.h>
-#include <DataTypes/DataTypeArray.h>
-
-#include <AggregateFunctions/AggregateFunctionGroupArraySortedData.h>
-#include <AggregateFunctions/IAggregateFunction.h>
-
-namespace DB
-{
-template <typename TColumn, bool is_plain>
-inline TColumn readItem(const IColumn * column, Arena * arena, size_t row)
-{
-    if constexpr (std::is_same_v<TColumn, StringRef>)
-    {
-        if constexpr (is_plain)
-        {
-            StringRef str = column->getDataAt(row);
-            auto ptr = arena->alloc(str.size);
-            std::copy(str.data, str.data + str.size, ptr);
-            return StringRef(ptr, str.size);
-        }
-        else
-        {
-            const char * begin = nullptr;
-            return column->serializeValueIntoArena(row, *arena, begin);
-        }
-    }
-    else
-    {
-        if constexpr (std::is_same_v<TColumn, UInt64>)
-            return column->getUInt(row);
-        else
-            return column->getInt(row);
-    }
-}
-
-template <typename TColumn, typename TFilter = void>
-size_t
-getFirstNElements_low_threshold(const TColumn * data, size_t row_begin, size_t row_end, size_t threshold, size_t * results, const TFilter * filter = nullptr)
-{
-    for (size_t i = 0; i < threshold; i++)
-    {
-        results[i] = 0;
-    }
-
-    threshold = std::min(row_end - row_begin, threshold);
-    size_t current_max = 0;
-    size_t cur;
-    size_t z;
-    for (size_t i = row_begin; i < row_end; i++)
-    {
-        if constexpr (!std::is_same_v<TFilter, void>)
-        {
-            if (filter[i] == 0)
-                continue;
-        }
-
-        //Starting from the highest values and we look for the immediately lower than the given one
-        for (cur = current_max; cur > 0; cur--)
-        {
-            if (data[i] > data[results[cur - 1]])
-                break;
-        }
-
-        if (cur < threshold)
-        {
-            //Move all the higher values 1 position to the right
-            for (z = std::min(threshold - 1, current_max); z > cur; z--)
-                results[z] = results[z - 1];
-
-            if (current_max < threshold)
-                ++current_max;
-
-            //insert element into the given position
-            results[cur] = i;
-        }
-    }
-
-    return current_max;
-}
-
-template <typename T>
-struct SortableItem
-{
-    T a;
-    size_t b;
-    bool operator<(const SortableItem & other) const { return (this->a < other.a); }
-};
-
-template <typename TColumn, typename TFilter = void>
-size_t getFirstNElements_high_threshold(
-    const TColumn * data, size_t row_begin, size_t row_end, size_t threshold, size_t * results, const TFilter * filter = nullptr)
-{
-    std::vector<SortableItem<TColumn>> dataIndexed(row_end);
-    size_t num_elements_filtered = 0;
-
-    for (size_t i = row_begin; i < row_end; i++)
-    {
-        if constexpr (!std::is_same_v<TFilter, void>)
-        {
-            if (filter[i] == 0)
-                continue;
-        }
-
-        dataIndexed.data()[num_elements_filtered].a = data[i];
-        dataIndexed.data()[num_elements_filtered].b = i;
-        num_elements_filtered++;
-    }
-
-    threshold = std::min(num_elements_filtered, threshold);
-
-    std::nth_element(dataIndexed.data(), dataIndexed.data() + threshold, dataIndexed.data() + num_elements_filtered);
-    std::sort(dataIndexed.data(), dataIndexed.data() + threshold);
-
-    for (size_t i = 0; i < threshold; i++)
-    {
-        results[i] = dataIndexed[i].b;
-    }
-
-    return threshold;
-}
-
-static const size_t THRESHOLD_MAX_CUSTOM_FUNCTION = 1000;
-
-template <typename TColumn>
-size_t getFirstNElements(const TColumn * data, size_t row_begin, size_t row_end, size_t threshold, size_t * results, const UInt8 * filter = nullptr)
-{
-    if (threshold < THRESHOLD_MAX_CUSTOM_FUNCTION)
-    {
-        if (filter != nullptr)
-            return getFirstNElements_low_threshold(data, row_begin, row_end, threshold, results, filter);
-        else
-            return getFirstNElements_low_threshold(data, row_begin, row_end, threshold, results);
-    }
-    else
-    {
-        if (filter != nullptr)
-            return getFirstNElements_high_threshold(data, row_begin, row_end, threshold, results, filter);
-        else
-            return getFirstNElements_high_threshold(data, row_begin, row_end, threshold, results);
-    }
-}
-
-template <typename TColumnA, bool is_plain_a, bool use_column_b, typename TColumnB, bool is_plain_b>
-class AggregateFunctionGroupArraySorted : public IAggregateFunctionDataHelper<
-                                              AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>,
-                                              AggregateFunctionGroupArraySorted<TColumnA, is_plain_a, use_column_b, TColumnB, is_plain_b>>
-{
-protected:
-    using State = AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>;
-    using Base = IAggregateFunctionDataHelper<
-        AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>,
-        AggregateFunctionGroupArraySorted>;
-
-    UInt64 threshold;
-    DataTypePtr & input_data_type;
-    mutable std::mutex mutex;
-
-    static void deserializeAndInsert(StringRef str, IColumn & data_to);
-
-public:
-    AggregateFunctionGroupArraySorted(UInt64 threshold_, const DataTypes & argument_types_, const Array & params)
-        : IAggregateFunctionDataHelper<
-            AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>,
-            AggregateFunctionGroupArraySorted>(argument_types_, params)
-        , threshold(threshold_)
-        , input_data_type(this->argument_types[0])
-    {
-    }
-
-    void create(AggregateDataPtr place) const override
-    {
-        Base::create(place);
-        this->data(place).threshold = threshold;
-    }
-
-    String getName() const override { return "groupArraySorted"; }
-
-    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(input_data_type); }
-
-    bool allocatesMemoryInArena() const override
-    {
-        if constexpr (std::is_same_v<TColumnA, StringRef>)
-            return true;
-        else
-            return false;
-    }
-
-    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena * arena) const override
-    {
-        State & data = this->data(place);
-        if constexpr (use_column_b)
-        {
-            data.add(
-                readItem<TColumnA, is_plain_a>(columns[0], arena, row_num), readItem<TColumnB, is_plain_b>(columns[1], arena, row_num));
-        }
-        else
-        {
-            data.add(readItem<TColumnA, is_plain_a>(columns[0], arena, row_num));
-        }
-    }
-
-    template <typename TColumn, bool is_plain, typename TFunc>
-    void
-    forFirstRows(size_t row_begin, size_t row_end, const IColumn ** columns, size_t data_column, Arena * arena, ssize_t if_argument_pos, TFunc func) const
-    {
-        const TColumn * values = nullptr;
-        std::unique_ptr<std::vector<TColumn>> values_vector;
-        std::vector<size_t> best_rows(threshold);
-
-        if constexpr (std::is_same_v<TColumn, StringRef>)
-        {
-            values_vector.reset(new std::vector<TColumn>(row_end));
-            for (size_t i = row_begin; i < row_end; i++)
-                (*values_vector)[i] = readItem<TColumn, is_plain>(columns[data_column], arena, i);
-            values = (*values_vector).data();
-        }
-        else
-        {
-            const auto & column = assert_cast<const ColumnVector<TColumn> &>(*columns[data_column]);
-            values = column.getData().data();
-        }
-
-        const UInt8 * filter = nullptr;
-        StringRef refFilter;
-
-        if (if_argument_pos >= 0)
-        {
-            refFilter = columns[if_argument_pos]->getRawData();
-            filter = reinterpret_cast<const UInt8 *>(refFilter.data);
-        }
-
-        size_t num_elements = getFirstNElements(values, row_begin, row_end, threshold, best_rows.data(), filter);
-        for (size_t i = 0; i < num_elements; i++)
-        {
-            func(best_rows[i], values);
-        }
-    }
-
-    void addBatchSinglePlace(
-        size_t row_begin,
-        size_t row_end,
-        AggregateDataPtr place,
-        const IColumn ** columns,
-        Arena * arena,
-        ssize_t if_argument_pos) const override
-    {
-        State & data = this->data(place);
-
-        if constexpr (use_column_b)
-        {
-            forFirstRows<TColumnB, is_plain_b>(
-                row_begin, row_end, columns, 1, arena, if_argument_pos, [columns, &arena, &data](size_t row, const TColumnB * values)
-                {
-                    data.add(readItem<TColumnA, is_plain_a>(columns[0], arena, row), values[row]);
-                });
-        }
-        else
-        {
-            forFirstRows<TColumnA, is_plain_a>(
-                row_begin, row_end, columns, 0, arena, if_argument_pos, [&data](size_t row, const TColumnA * values)
-                {
-                    data.add(values[row]);
-                });
-        }
-    }
-
-    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override
-    {
-        this->data(place).merge(this->data(rhs));
-    }
-
-    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override
-    {
-        this->data(place).serialize(buf);
-    }
-
-    void
-    deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version  */, Arena * arena) const override
-    {
-        this->data(place).deserialize(buf, arena);
-    }
-
-    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena * /*arena*/) const override
-    {
-        ColumnArray & arr_to = assert_cast<ColumnArray &>(to);
-        ColumnArray::Offsets & offsets_to = arr_to.getOffsets();
-
-        auto & values = this->data(place).values;
-        offsets_to.push_back(offsets_to.back() + values.size());
-
-        IColumn & data_to = arr_to.getData();
-        for (auto value : values)
-        {
-            if constexpr (std::is_same_v<TColumnA, StringRef>)
-            {
-                auto str = State::itemValue(value);
-                if constexpr (is_plain_a)
-                {
-                    data_to.insertData(str.data, str.size);
-                }
-                else
-                {
-                    data_to.deserializeAndInsertFromArena(str.data);
-                }
-            }
-            else
-            {
-                data_to.insert(State::itemValue(value));
-            }
-        }
-    }
-};
-}
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h b/src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h
deleted file mode 100644
index c3f60a8dbb93..000000000000
--- a/src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h
+++ /dev/null
@@ -1,162 +0,0 @@
-#pragma once
-
-#include <IO/ReadBuffer.h>
-#include <IO/ReadHelpers.h>
-#include <IO/VarInt.h>
-#include <IO/WriteBuffer.h>
-#include <IO/WriteHelpers.h>
-
-
-static inline constexpr UInt64 GROUP_SORTED_DEFAULT_THRESHOLD = 0xFFFFFF;
-
-namespace DB
-{
-template <typename T>
-static void writeOneItem(WriteBuffer & buf, T item)
-{
-    if constexpr (std::numeric_limits<T>::is_signed)
-    {
-        writeVarInt(item, buf);
-    }
-    else
-    {
-        writeVarUInt(item, buf);
-    }
-}
-
-static void writeOneItem(WriteBuffer & buf, const StringRef & item)
-{
-    writeBinary(item, buf);
-}
-
-template <typename T>
-static void readOneItem(ReadBuffer & buf, Arena * /*arena*/, T & item)
-{
-    if constexpr (std::numeric_limits<T>::is_signed)
-    {
-        DB::Int64 val;
-        readVarT(val, buf);
-        item = val;
-    }
-    else
-    {
-        DB::UInt64 val;
-        readVarT(val, buf);
-        item = val;
-    }
-}
-
-static void readOneItem(ReadBuffer & buf, Arena * arena, StringRef & item)
-{
-    item = readStringBinaryInto(*arena, buf);
-}
-
-template <typename Storage>
-struct AggregateFunctionGroupArraySortedDataBase
-{
-    typedef typename Storage::value_type ValueType;
-    AggregateFunctionGroupArraySortedDataBase(UInt64 threshold_ = GROUP_SORTED_DEFAULT_THRESHOLD) : threshold(threshold_) { }
-
-    virtual ~AggregateFunctionGroupArraySortedDataBase() { }
-    inline void narrowDown()
-    {
-        while (values.size() > threshold)
-            values.erase(--values.end());
-    }
-
-    void merge(const AggregateFunctionGroupArraySortedDataBase & other)
-    {
-        values.merge(Storage(other.values));
-        narrowDown();
-    }
-
-    void serialize(WriteBuffer & buf) const
-    {
-        writeOneItem(buf, UInt64(values.size()));
-        for (auto value : values)
-        {
-            serializeItem(buf, value);
-        }
-    }
-
-    virtual void serializeItem(WriteBuffer & buf, ValueType & val) const = 0;
-    virtual ValueType deserializeItem(ReadBuffer & buf, Arena * arena) const = 0;
-
-    void deserialize(ReadBuffer & buf, Arena * arena)
-    {
-        values.clear();
-        UInt64 length;
-        readOneItem(buf, nullptr, length);
-
-        while (length--)
-        {
-            values.insert(deserializeItem(buf, arena));
-        }
-
-        narrowDown();
-    }
-
-    UInt64 threshold;
-    Storage values;
-};
-
-template <typename T, bool expr_sorted, typename TIndex>
-struct AggregateFunctionGroupArraySortedData
-{
-};
-
-template <typename T, typename TIndex>
-struct AggregateFunctionGroupArraySortedData<T, true, TIndex> : public AggregateFunctionGroupArraySortedDataBase<std::multimap<TIndex, T>>
-{
-    using Base = AggregateFunctionGroupArraySortedDataBase<std::multimap<TIndex, T>>;
-    using Base::Base;
-
-    void add(T item, TIndex weight)
-    {
-        Base::values.insert({weight, item});
-        Base::narrowDown();
-    }
-
-    void serializeItem(WriteBuffer & buf, typename Base::ValueType & value) const override
-    {
-        writeOneItem(buf, value.first);
-        writeOneItem(buf, value.second);
-    }
-
-    virtual typename Base::ValueType deserializeItem(ReadBuffer & buf, Arena * arena) const override
-    {
-        TIndex first;
-        T second;
-        readOneItem(buf, arena, first);
-        readOneItem(buf, arena, second);
-
-        return {first, second};
-    }
-
-    static T itemValue(typename Base::ValueType & value) { return value.second; }
-};
-
-template <typename T, typename TIndex>
-struct AggregateFunctionGroupArraySortedData<T, false, TIndex> : public AggregateFunctionGroupArraySortedDataBase<std::multiset<T>>
-{
-    using Base = AggregateFunctionGroupArraySortedDataBase<std::multiset<T>>;
-    using Base::Base;
-
-    void add(T item)
-    {
-        Base::values.insert(item);
-        Base::narrowDown();
-    }
-
-    void serializeItem(WriteBuffer & buf, typename Base::ValueType & value) const override { writeOneItem(buf, value); }
-
-    typename Base::ValueType deserializeItem(ReadBuffer & buf, Arena * arena) const override
-    {
-        T value;
-        readOneItem(buf, arena, value);
-        return value;
-    }
-
-    static T itemValue(typename Base::ValueType & value) { return value; }
-};
-}
diff --git a/src/AggregateFunctions/registerAggregateFunctions.cpp b/src/AggregateFunctions/registerAggregateFunctions.cpp
index 034f36340e24..351adac31bb3 100644
--- a/src/AggregateFunctions/registerAggregateFunctions.cpp
+++ b/src/AggregateFunctions/registerAggregateFunctions.cpp
@@ -59,7 +59,6 @@ void registerAggregateFunctionNothing(AggregateFunctionFactory &);
 void registerAggregateFunctionExponentialMovingAverage(AggregateFunctionFactory &);
 void registerAggregateFunctionSparkbar(AggregateFunctionFactory &);
 void registerAggregateFunctionIntervalLengthSum(AggregateFunctionFactory &);
-void registerAggregateFunctionGroupArraySorted(AggregateFunctionFactory & factory);
 
 class AggregateFunctionCombinatorFactory;
 void registerAggregateFunctionCombinatorIf(AggregateFunctionCombinatorFactory &);
@@ -131,7 +130,6 @@ void registerAggregateFunctions()
         registerAggregateFunctionIntervalLengthSum(factory);
         registerAggregateFunctionExponentialMovingAverage(factory);
         registerAggregateFunctionSparkbar(factory);
-        registerAggregateFunctionGroupArraySorted(factory);
 
         registerWindowFunctions(factory);
     }
