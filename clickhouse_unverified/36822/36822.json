{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36822,
  "instance_id": "ClickHouse__ClickHouse-36822",
  "issue_numbers": [
    "36815"
  ],
  "base_commit": "b76406fc8f7b7192a18333b489ccda178e4c1409",
  "patch": "diff --git a/docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md b/docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md\ndeleted file mode 100644\nindex e34fcbc57880..000000000000\n--- a/docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md\n+++ /dev/null\n@@ -1,48 +0,0 @@\n----\n-sidebar_position: 108\n----\n-\n-# groupArraySorted {#groupArraySorted}\n-\n-Returns an array with the first N items in ascending order.\n-\n-``` sql\n-groupArraySorted(N)(column)\n-```\n-\n-**Arguments**\n-\n--   `N` \u2013 The number of elements to return.\n-\n-If the parameter is omitted, default value 10 is used.\n-\n-**Arguments**\n-\n--   `column` \u2013 The value.\n--   `expr` \u2014 Optional. The field or expresion to sort by. If not set values are sorted by themselves.\n-\n-**Example**\n-\n-Gets the first 10 numbers:\n-\n-``` sql\n-SELECT groupArraySorted(10)(number) FROM numbers(100)\n-```\n-\n-``` text\n-\u250c\u2500groupArraySorted(10)(number)\u2500\u2510\n-\u2502 [0,1,2,3,4,5,6,7,8,9]        \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n-Or the last 10:\n-\n-``` sql\n-SELECT groupArraySorted(10)(number, -number) FROM numbers(100)\n-```\n-\n-``` text\n-\u250c\u2500groupArraySorted(10)(number, negate(number))\u2500\u2510\n-\u2502 [99,98,97,96,95,94,93,92,91,90]              \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n\\ No newline at end of file\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp b/src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp\ndeleted file mode 100644\nindex 50d5f075322b..000000000000\n--- a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp\n+++ /dev/null\n@@ -1,147 +0,0 @@\n-#include <AggregateFunctions/AggregateFunctionFactory.h>\n-#include <AggregateFunctions/AggregateFunctionGroupArraySorted.h>\n-#include <AggregateFunctions/FactoryHelpers.h>\n-#include <AggregateFunctions/Helpers.h>\n-#include <DataTypes/DataTypeDate.h>\n-#include <DataTypes/DataTypeDateTime.h>\n-#include <DataTypes/DataTypeString.h>\n-#include <Common/FieldVisitorConvertToNumber.h>\n-\n-\n-static inline constexpr UInt64 GROUP_SORTED_ARRAY_MAX_SIZE = 0xFFFFFF;\n-static inline constexpr UInt64 GROUP_SORTED_ARRAY_DEFAULT_THRESHOLD = 10;\n-\n-\n-namespace DB\n-{\n-struct Settings;\n-\n-namespace ErrorCodes\n-{\n-    extern const int ARGUMENT_OUT_OF_BOUND;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-}\n-\n-\n-namespace\n-{\n-    template <typename T, bool expr_sorted, typename TColumnB, bool is_plain_b>\n-    class AggregateFunctionGroupArraySortedNumeric : public AggregateFunctionGroupArraySorted<T, false, expr_sorted, TColumnB, is_plain_b>\n-    {\n-        using AggregateFunctionGroupArraySorted<T, false, expr_sorted, TColumnB, is_plain_b>::AggregateFunctionGroupArraySorted;\n-    };\n-\n-    template <typename T, bool expr_sorted, typename TColumnB, bool is_plain_b>\n-    class AggregateFunctionGroupArraySortedFieldType\n-        : public AggregateFunctionGroupArraySorted<typename T::FieldType, false, expr_sorted, TColumnB, is_plain_b>\n-    {\n-        using AggregateFunctionGroupArraySorted<typename T::FieldType, false, expr_sorted, TColumnB, is_plain_b>::\n-            AggregateFunctionGroupArraySorted;\n-        DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<T>()); }\n-    };\n-\n-    template <template <typename, bool, typename, bool> class AggregateFunctionTemplate, typename TColumnA, bool expr_sorted, typename TColumnB, bool is_plain_b, typename... TArgs>\n-    AggregateFunctionPtr\n-    createAggregateFunctionGroupArraySortedTypedFinal(TArgs && ... args)\n-    {\n-        return AggregateFunctionPtr(new AggregateFunctionTemplate<TColumnA, expr_sorted, TColumnB, is_plain_b>(std::forward<TArgs>(args)...));\n-    }\n-\n-    template <bool expr_sorted = false, typename TColumnB = UInt64, bool is_plain_b = false>\n-    AggregateFunctionPtr\n-    createAggregateFunctionGroupArraySortedTyped(const DataTypes & argument_types, const Array & params, UInt64 threshold)\n-    {\n-#define DISPATCH(A, C, B) \\\n-    if (which.idx == TypeIndex::A) \\\n-        return createAggregateFunctionGroupArraySortedTypedFinal<C, B, expr_sorted, TColumnB, is_plain_b>(threshold, argument_types, params);\n-#define DISPATCH_NUMERIC(A) DISPATCH(A, AggregateFunctionGroupArraySortedNumeric, A)\n-        WhichDataType which(argument_types[0]);\n-        FOR_NUMERIC_TYPES(DISPATCH_NUMERIC)\n-        DISPATCH(Enum8, AggregateFunctionGroupArraySortedNumeric, Int8)\n-        DISPATCH(Enum16, AggregateFunctionGroupArraySortedNumeric, Int16)\n-        DISPATCH(Date, AggregateFunctionGroupArraySortedFieldType, DataTypeDate)\n-        DISPATCH(DateTime, AggregateFunctionGroupArraySortedFieldType, DataTypeDateTime)\n-#undef DISPATCH\n-#undef DISPATCH_NUMERIC\n-\n-        if (argument_types[0]->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n-        {\n-            return AggregateFunctionPtr(new AggregateFunctionGroupArraySorted<StringRef, true, expr_sorted, TColumnB, is_plain_b>(\n-                threshold, argument_types, params));\n-        }\n-        else\n-        {\n-            return AggregateFunctionPtr(new AggregateFunctionGroupArraySorted<StringRef, false, expr_sorted, TColumnB, is_plain_b>(\n-                threshold, argument_types, params));\n-        }\n-    }\n-\n-\n-    AggregateFunctionPtr createAggregateFunctionGroupArraySorted(\n-        const std::string & name, const DataTypes & argument_types, const Array & params, const Settings *)\n-    {\n-        UInt64 threshold = GROUP_SORTED_ARRAY_DEFAULT_THRESHOLD;\n-\n-        if (params.size() == 1)\n-        {\n-            UInt64 k = applyVisitor(FieldVisitorConvertToNumber<UInt64>(), params[0]);\n-\n-            if (k > GROUP_SORTED_ARRAY_MAX_SIZE)\n-                throw Exception(\n-                    \"Too large parameter(s) for aggregate function \" + name + \". Maximum: \" + toString(GROUP_SORTED_ARRAY_MAX_SIZE),\n-                    ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-\n-            if (k == 0)\n-                throw Exception(\"Parameter 0 is illegal for aggregate function \" + name, ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-\n-            threshold = k;\n-        }\n-        else if (!params.empty())\n-        {\n-            throw Exception(\"Aggregate function \" + name + \" only supports 1 parameter.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n-        }\n-\n-        if (argument_types.size() == 2)\n-        {\n-            if (isNumber(argument_types[1]))\n-            {\n-#define DISPATCH2(A, B) \\\n-    if (which.idx == TypeIndex::A) \\\n-        return createAggregateFunctionGroupArraySortedTyped<true, B>(argument_types, params, threshold);\n-#define DISPATCH(A) DISPATCH2(A, A)\n-                WhichDataType which(argument_types[1]);\n-                FOR_NUMERIC_TYPES(DISPATCH)\n-                DISPATCH2(Enum8, Int8)\n-                DISPATCH2(Enum16, Int16)\n-#undef DISPATCH\n-#undef DISPATCH2\n-                throw Exception(\"Invalid parameter type.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-            }\n-            else if (argument_types[1]->isValueUnambiguouslyRepresentedInContiguousMemoryRegion())\n-            {\n-                return createAggregateFunctionGroupArraySortedTyped<true, StringRef, true>(argument_types, params, threshold);\n-            }\n-            else\n-            {\n-                return createAggregateFunctionGroupArraySortedTyped<true, StringRef, false>(argument_types, params, threshold);\n-            }\n-        }\n-        else if (argument_types.size() == 1)\n-        {\n-            return createAggregateFunctionGroupArraySortedTyped<>(argument_types, params, threshold);\n-        }\n-        else\n-        {\n-            throw Exception(\n-                \"Aggregate function \" + name + \" requires one or two parameters.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n-        }\n-    }\n-}\n-\n-void registerAggregateFunctionGroupArraySorted(AggregateFunctionFactory & factory)\n-{\n-    AggregateFunctionProperties properties = {.returns_default_when_only_null = false, .is_order_dependent = true};\n-    factory.registerFunction(\"groupArraySorted\", {createAggregateFunctionGroupArraySorted, properties});\n-}\n-}\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.h b/src/AggregateFunctions/AggregateFunctionGroupArraySorted.h\ndeleted file mode 100644\nindex 0a9111297f2d..000000000000\n--- a/src/AggregateFunctions/AggregateFunctionGroupArraySorted.h\n+++ /dev/null\n@@ -1,315 +0,0 @@\n-#pragma once\n-\n-#include <Columns/ColumnArray.h>\n-#include <DataTypes/DataTypeArray.h>\n-\n-#include <AggregateFunctions/AggregateFunctionGroupArraySortedData.h>\n-#include <AggregateFunctions/IAggregateFunction.h>\n-\n-namespace DB\n-{\n-template <typename TColumn, bool is_plain>\n-inline TColumn readItem(const IColumn * column, Arena * arena, size_t row)\n-{\n-    if constexpr (std::is_same_v<TColumn, StringRef>)\n-    {\n-        if constexpr (is_plain)\n-        {\n-            StringRef str = column->getDataAt(row);\n-            auto ptr = arena->alloc(str.size);\n-            std::copy(str.data, str.data + str.size, ptr);\n-            return StringRef(ptr, str.size);\n-        }\n-        else\n-        {\n-            const char * begin = nullptr;\n-            return column->serializeValueIntoArena(row, *arena, begin);\n-        }\n-    }\n-    else\n-    {\n-        if constexpr (std::is_same_v<TColumn, UInt64>)\n-            return column->getUInt(row);\n-        else\n-            return column->getInt(row);\n-    }\n-}\n-\n-template <typename TColumn, typename TFilter = void>\n-size_t\n-getFirstNElements_low_threshold(const TColumn * data, size_t row_begin, size_t row_end, size_t threshold, size_t * results, const TFilter * filter = nullptr)\n-{\n-    for (size_t i = 0; i < threshold; i++)\n-    {\n-        results[i] = 0;\n-    }\n-\n-    threshold = std::min(row_end - row_begin, threshold);\n-    size_t current_max = 0;\n-    size_t cur;\n-    size_t z;\n-    for (size_t i = row_begin; i < row_end; i++)\n-    {\n-        if constexpr (!std::is_same_v<TFilter, void>)\n-        {\n-            if (filter[i] == 0)\n-                continue;\n-        }\n-\n-        //Starting from the highest values and we look for the immediately lower than the given one\n-        for (cur = current_max; cur > 0; cur--)\n-        {\n-            if (data[i] > data[results[cur - 1]])\n-                break;\n-        }\n-\n-        if (cur < threshold)\n-        {\n-            //Move all the higher values 1 position to the right\n-            for (z = std::min(threshold - 1, current_max); z > cur; z--)\n-                results[z] = results[z - 1];\n-\n-            if (current_max < threshold)\n-                ++current_max;\n-\n-            //insert element into the given position\n-            results[cur] = i;\n-        }\n-    }\n-\n-    return current_max;\n-}\n-\n-template <typename T>\n-struct SortableItem\n-{\n-    T a;\n-    size_t b;\n-    bool operator<(const SortableItem & other) const { return (this->a < other.a); }\n-};\n-\n-template <typename TColumn, typename TFilter = void>\n-size_t getFirstNElements_high_threshold(\n-    const TColumn * data, size_t row_begin, size_t row_end, size_t threshold, size_t * results, const TFilter * filter = nullptr)\n-{\n-    std::vector<SortableItem<TColumn>> dataIndexed(row_end);\n-    size_t num_elements_filtered = 0;\n-\n-    for (size_t i = row_begin; i < row_end; i++)\n-    {\n-        if constexpr (!std::is_same_v<TFilter, void>)\n-        {\n-            if (filter[i] == 0)\n-                continue;\n-        }\n-\n-        dataIndexed.data()[num_elements_filtered].a = data[i];\n-        dataIndexed.data()[num_elements_filtered].b = i;\n-        num_elements_filtered++;\n-    }\n-\n-    threshold = std::min(num_elements_filtered, threshold);\n-\n-    std::nth_element(dataIndexed.data(), dataIndexed.data() + threshold, dataIndexed.data() + num_elements_filtered);\n-    std::sort(dataIndexed.data(), dataIndexed.data() + threshold);\n-\n-    for (size_t i = 0; i < threshold; i++)\n-    {\n-        results[i] = dataIndexed[i].b;\n-    }\n-\n-    return threshold;\n-}\n-\n-static const size_t THRESHOLD_MAX_CUSTOM_FUNCTION = 1000;\n-\n-template <typename TColumn>\n-size_t getFirstNElements(const TColumn * data, size_t row_begin, size_t row_end, size_t threshold, size_t * results, const UInt8 * filter = nullptr)\n-{\n-    if (threshold < THRESHOLD_MAX_CUSTOM_FUNCTION)\n-    {\n-        if (filter != nullptr)\n-            return getFirstNElements_low_threshold(data, row_begin, row_end, threshold, results, filter);\n-        else\n-            return getFirstNElements_low_threshold(data, row_begin, row_end, threshold, results);\n-    }\n-    else\n-    {\n-        if (filter != nullptr)\n-            return getFirstNElements_high_threshold(data, row_begin, row_end, threshold, results, filter);\n-        else\n-            return getFirstNElements_high_threshold(data, row_begin, row_end, threshold, results);\n-    }\n-}\n-\n-template <typename TColumnA, bool is_plain_a, bool use_column_b, typename TColumnB, bool is_plain_b>\n-class AggregateFunctionGroupArraySorted : public IAggregateFunctionDataHelper<\n-                                              AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>,\n-                                              AggregateFunctionGroupArraySorted<TColumnA, is_plain_a, use_column_b, TColumnB, is_plain_b>>\n-{\n-protected:\n-    using State = AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>;\n-    using Base = IAggregateFunctionDataHelper<\n-        AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>,\n-        AggregateFunctionGroupArraySorted>;\n-\n-    UInt64 threshold;\n-    DataTypePtr & input_data_type;\n-    mutable std::mutex mutex;\n-\n-    static void deserializeAndInsert(StringRef str, IColumn & data_to);\n-\n-public:\n-    AggregateFunctionGroupArraySorted(UInt64 threshold_, const DataTypes & argument_types_, const Array & params)\n-        : IAggregateFunctionDataHelper<\n-            AggregateFunctionGroupArraySortedData<TColumnA, use_column_b, TColumnB>,\n-            AggregateFunctionGroupArraySorted>(argument_types_, params)\n-        , threshold(threshold_)\n-        , input_data_type(this->argument_types[0])\n-    {\n-    }\n-\n-    void create(AggregateDataPtr place) const override\n-    {\n-        Base::create(place);\n-        this->data(place).threshold = threshold;\n-    }\n-\n-    String getName() const override { return \"groupArraySorted\"; }\n-\n-    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(input_data_type); }\n-\n-    bool allocatesMemoryInArena() const override\n-    {\n-        if constexpr (std::is_same_v<TColumnA, StringRef>)\n-            return true;\n-        else\n-            return false;\n-    }\n-\n-    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena * arena) const override\n-    {\n-        State & data = this->data(place);\n-        if constexpr (use_column_b)\n-        {\n-            data.add(\n-                readItem<TColumnA, is_plain_a>(columns[0], arena, row_num), readItem<TColumnB, is_plain_b>(columns[1], arena, row_num));\n-        }\n-        else\n-        {\n-            data.add(readItem<TColumnA, is_plain_a>(columns[0], arena, row_num));\n-        }\n-    }\n-\n-    template <typename TColumn, bool is_plain, typename TFunc>\n-    void\n-    forFirstRows(size_t row_begin, size_t row_end, const IColumn ** columns, size_t data_column, Arena * arena, ssize_t if_argument_pos, TFunc func) const\n-    {\n-        const TColumn * values = nullptr;\n-        std::unique_ptr<std::vector<TColumn>> values_vector;\n-        std::vector<size_t> best_rows(threshold);\n-\n-        if constexpr (std::is_same_v<TColumn, StringRef>)\n-        {\n-            values_vector.reset(new std::vector<TColumn>(row_end));\n-            for (size_t i = row_begin; i < row_end; i++)\n-                (*values_vector)[i] = readItem<TColumn, is_plain>(columns[data_column], arena, i);\n-            values = (*values_vector).data();\n-        }\n-        else\n-        {\n-            const auto & column = assert_cast<const ColumnVector<TColumn> &>(*columns[data_column]);\n-            values = column.getData().data();\n-        }\n-\n-        const UInt8 * filter = nullptr;\n-        StringRef refFilter;\n-\n-        if (if_argument_pos >= 0)\n-        {\n-            refFilter = columns[if_argument_pos]->getRawData();\n-            filter = reinterpret_cast<const UInt8 *>(refFilter.data);\n-        }\n-\n-        size_t num_elements = getFirstNElements(values, row_begin, row_end, threshold, best_rows.data(), filter);\n-        for (size_t i = 0; i < num_elements; i++)\n-        {\n-            func(best_rows[i], values);\n-        }\n-    }\n-\n-    void addBatchSinglePlace(\n-        size_t row_begin,\n-        size_t row_end,\n-        AggregateDataPtr place,\n-        const IColumn ** columns,\n-        Arena * arena,\n-        ssize_t if_argument_pos) const override\n-    {\n-        State & data = this->data(place);\n-\n-        if constexpr (use_column_b)\n-        {\n-            forFirstRows<TColumnB, is_plain_b>(\n-                row_begin, row_end, columns, 1, arena, if_argument_pos, [columns, &arena, &data](size_t row, const TColumnB * values)\n-                {\n-                    data.add(readItem<TColumnA, is_plain_a>(columns[0], arena, row), values[row]);\n-                });\n-        }\n-        else\n-        {\n-            forFirstRows<TColumnA, is_plain_a>(\n-                row_begin, row_end, columns, 0, arena, if_argument_pos, [&data](size_t row, const TColumnA * values)\n-                {\n-                    data.add(values[row]);\n-                });\n-        }\n-    }\n-\n-    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override\n-    {\n-        this->data(place).merge(this->data(rhs));\n-    }\n-\n-    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override\n-    {\n-        this->data(place).serialize(buf);\n-    }\n-\n-    void\n-    deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version  */, Arena * arena) const override\n-    {\n-        this->data(place).deserialize(buf, arena);\n-    }\n-\n-    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena * /*arena*/) const override\n-    {\n-        ColumnArray & arr_to = assert_cast<ColumnArray &>(to);\n-        ColumnArray::Offsets & offsets_to = arr_to.getOffsets();\n-\n-        auto & values = this->data(place).values;\n-        offsets_to.push_back(offsets_to.back() + values.size());\n-\n-        IColumn & data_to = arr_to.getData();\n-        for (auto value : values)\n-        {\n-            if constexpr (std::is_same_v<TColumnA, StringRef>)\n-            {\n-                auto str = State::itemValue(value);\n-                if constexpr (is_plain_a)\n-                {\n-                    data_to.insertData(str.data, str.size);\n-                }\n-                else\n-                {\n-                    data_to.deserializeAndInsertFromArena(str.data);\n-                }\n-            }\n-            else\n-            {\n-                data_to.insert(State::itemValue(value));\n-            }\n-        }\n-    }\n-};\n-}\ndiff --git a/src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h b/src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h\ndeleted file mode 100644\nindex c3f60a8dbb93..000000000000\n--- a/src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h\n+++ /dev/null\n@@ -1,162 +0,0 @@\n-#pragma once\n-\n-#include <IO/ReadBuffer.h>\n-#include <IO/ReadHelpers.h>\n-#include <IO/VarInt.h>\n-#include <IO/WriteBuffer.h>\n-#include <IO/WriteHelpers.h>\n-\n-\n-static inline constexpr UInt64 GROUP_SORTED_DEFAULT_THRESHOLD = 0xFFFFFF;\n-\n-namespace DB\n-{\n-template <typename T>\n-static void writeOneItem(WriteBuffer & buf, T item)\n-{\n-    if constexpr (std::numeric_limits<T>::is_signed)\n-    {\n-        writeVarInt(item, buf);\n-    }\n-    else\n-    {\n-        writeVarUInt(item, buf);\n-    }\n-}\n-\n-static void writeOneItem(WriteBuffer & buf, const StringRef & item)\n-{\n-    writeBinary(item, buf);\n-}\n-\n-template <typename T>\n-static void readOneItem(ReadBuffer & buf, Arena * /*arena*/, T & item)\n-{\n-    if constexpr (std::numeric_limits<T>::is_signed)\n-    {\n-        DB::Int64 val;\n-        readVarT(val, buf);\n-        item = val;\n-    }\n-    else\n-    {\n-        DB::UInt64 val;\n-        readVarT(val, buf);\n-        item = val;\n-    }\n-}\n-\n-static void readOneItem(ReadBuffer & buf, Arena * arena, StringRef & item)\n-{\n-    item = readStringBinaryInto(*arena, buf);\n-}\n-\n-template <typename Storage>\n-struct AggregateFunctionGroupArraySortedDataBase\n-{\n-    typedef typename Storage::value_type ValueType;\n-    AggregateFunctionGroupArraySortedDataBase(UInt64 threshold_ = GROUP_SORTED_DEFAULT_THRESHOLD) : threshold(threshold_) { }\n-\n-    virtual ~AggregateFunctionGroupArraySortedDataBase() { }\n-    inline void narrowDown()\n-    {\n-        while (values.size() > threshold)\n-            values.erase(--values.end());\n-    }\n-\n-    void merge(const AggregateFunctionGroupArraySortedDataBase & other)\n-    {\n-        values.merge(Storage(other.values));\n-        narrowDown();\n-    }\n-\n-    void serialize(WriteBuffer & buf) const\n-    {\n-        writeOneItem(buf, UInt64(values.size()));\n-        for (auto value : values)\n-        {\n-            serializeItem(buf, value);\n-        }\n-    }\n-\n-    virtual void serializeItem(WriteBuffer & buf, ValueType & val) const = 0;\n-    virtual ValueType deserializeItem(ReadBuffer & buf, Arena * arena) const = 0;\n-\n-    void deserialize(ReadBuffer & buf, Arena * arena)\n-    {\n-        values.clear();\n-        UInt64 length;\n-        readOneItem(buf, nullptr, length);\n-\n-        while (length--)\n-        {\n-            values.insert(deserializeItem(buf, arena));\n-        }\n-\n-        narrowDown();\n-    }\n-\n-    UInt64 threshold;\n-    Storage values;\n-};\n-\n-template <typename T, bool expr_sorted, typename TIndex>\n-struct AggregateFunctionGroupArraySortedData\n-{\n-};\n-\n-template <typename T, typename TIndex>\n-struct AggregateFunctionGroupArraySortedData<T, true, TIndex> : public AggregateFunctionGroupArraySortedDataBase<std::multimap<TIndex, T>>\n-{\n-    using Base = AggregateFunctionGroupArraySortedDataBase<std::multimap<TIndex, T>>;\n-    using Base::Base;\n-\n-    void add(T item, TIndex weight)\n-    {\n-        Base::values.insert({weight, item});\n-        Base::narrowDown();\n-    }\n-\n-    void serializeItem(WriteBuffer & buf, typename Base::ValueType & value) const override\n-    {\n-        writeOneItem(buf, value.first);\n-        writeOneItem(buf, value.second);\n-    }\n-\n-    virtual typename Base::ValueType deserializeItem(ReadBuffer & buf, Arena * arena) const override\n-    {\n-        TIndex first;\n-        T second;\n-        readOneItem(buf, arena, first);\n-        readOneItem(buf, arena, second);\n-\n-        return {first, second};\n-    }\n-\n-    static T itemValue(typename Base::ValueType & value) { return value.second; }\n-};\n-\n-template <typename T, typename TIndex>\n-struct AggregateFunctionGroupArraySortedData<T, false, TIndex> : public AggregateFunctionGroupArraySortedDataBase<std::multiset<T>>\n-{\n-    using Base = AggregateFunctionGroupArraySortedDataBase<std::multiset<T>>;\n-    using Base::Base;\n-\n-    void add(T item)\n-    {\n-        Base::values.insert(item);\n-        Base::narrowDown();\n-    }\n-\n-    void serializeItem(WriteBuffer & buf, typename Base::ValueType & value) const override { writeOneItem(buf, value); }\n-\n-    typename Base::ValueType deserializeItem(ReadBuffer & buf, Arena * arena) const override\n-    {\n-        T value;\n-        readOneItem(buf, arena, value);\n-        return value;\n-    }\n-\n-    static T itemValue(typename Base::ValueType & value) { return value; }\n-};\n-}\ndiff --git a/src/AggregateFunctions/registerAggregateFunctions.cpp b/src/AggregateFunctions/registerAggregateFunctions.cpp\nindex 034f36340e24..351adac31bb3 100644\n--- a/src/AggregateFunctions/registerAggregateFunctions.cpp\n+++ b/src/AggregateFunctions/registerAggregateFunctions.cpp\n@@ -59,7 +59,6 @@ void registerAggregateFunctionNothing(AggregateFunctionFactory &);\n void registerAggregateFunctionExponentialMovingAverage(AggregateFunctionFactory &);\n void registerAggregateFunctionSparkbar(AggregateFunctionFactory &);\n void registerAggregateFunctionIntervalLengthSum(AggregateFunctionFactory &);\n-void registerAggregateFunctionGroupArraySorted(AggregateFunctionFactory & factory);\n \n class AggregateFunctionCombinatorFactory;\n void registerAggregateFunctionCombinatorIf(AggregateFunctionCombinatorFactory &);\n@@ -131,7 +130,6 @@ void registerAggregateFunctions()\n         registerAggregateFunctionIntervalLengthSum(factory);\n         registerAggregateFunctionExponentialMovingAverage(factory);\n         registerAggregateFunctionSparkbar(factory);\n-        registerAggregateFunctionGroupArraySorted(factory);\n \n         registerWindowFunctions(factory);\n     }\n",
  "test_patch": "diff --git a/tests/performance/group_array_sorted.xml b/tests/performance/group_array_sorted.xml\ndeleted file mode 100644\nindex d0092e38659f..000000000000\n--- a/tests/performance/group_array_sorted.xml\n+++ /dev/null\n@@ -1,11 +0,0 @@\n-<test>\n-    <create_query>CREATE TABLE test (`id` UInt64, `value` UInt64, `text` String ) ENGINE = Memory</create_query>\n-    <fill_query>INSERT INTO test SELECT number as id, rand64() as value, toString(number) as text FROM system.numbers_mt LIMIT 10000000</fill_query>\n-\n-    <query>SELECT groupArraySorted(100000)(id, value) FROM test</query>\n-    <query>SELECT groupArraySorted(100000)(text, value) FROM test</query>\n-    <query>SELECT groupArraySorted(100000)((id, text), value) FROM test</query>\n-    <query>SELECT groupArraySorted(100000)(text) FROM test</query>\n-\n-    <drop_query>DROP TABLE IF EXISTS test</drop_query>\n-</test>\ndiff --git a/tests/queries/0_stateless/02158_grouparraysorted.reference b/tests/queries/0_stateless/02158_grouparraysorted.reference\ndeleted file mode 100644\nindex 2d93478c9cbb..000000000000\n--- a/tests/queries/0_stateless/02158_grouparraysorted.reference\n+++ /dev/null\n@@ -1,18 +0,0 @@\n-[0,1,2,3,4]\n-[0,1,2,3,4,5,6,7,8,9]\n-[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99]\n-[999,998,997,996,995,994,993,992,991,990,989,988,987,986,985,984,983,982,981,980,979,978,977,976,975,974,973,972,971,970,969,968,967,966,965,964,963,962,961,960,959,958,957,956,955,954,953,952,951,950,949,948,947,946,945,944,943,942,941,940,939,938,937,936,935,934,933,932,931,930,929,928,927,926,925,924,923,922,921,920,919,918,917,916,915,914,913,912,911,910,909,908,907,906,905,904,903,902,901,900]\n-['0','1','2','3','4']\n-['0','1','2','3','4']\n-['9','8','7','6','5']\n-[(0,'0'),(1,'1'),(2,'2'),(3,'3'),(4,'4')]\n-['0','1','10','11','12']\n-['0','1','2','3','4','5','6','7','8','9','10','11','12','13','14','15','16','17','18','19','20','21','22','23','24','25','26','27','28','29','30','31','32','33','34','35','36','37','38','39','40','41','42','43','44','45','46','47','48','49']\n-[0,0,1,1,2,2,3,3,4,4]\n-pablo\t[1,2]\n-luis\t[1,3]\n-pablo\t[1,2]\n-luis\t[1,3]\n-[4,5,6,7,8]\n-[10,11,12,13,14]\n-['10','11','12','13','14']\ndiff --git a/tests/queries/0_stateless/02158_grouparraysorted.sql b/tests/queries/0_stateless/02158_grouparraysorted.sql\ndeleted file mode 100644\nindex 00cb32142ca9..000000000000\n--- a/tests/queries/0_stateless/02158_grouparraysorted.sql\n+++ /dev/null\n@@ -1,43 +0,0 @@\n-\n-SELECT groupArraySorted(5)(number) from numbers(100);\n-\n-SELECT groupArraySorted(number, number) from numbers(100);\n-\n-SELECT groupArraySorted(100)(number, number) from numbers(1000);\n-\n-SELECT groupArraySorted(100)(number, -number) from numbers(1000);\n-\n-SELECT groupArraySorted(5)(str, number) FROM (SELECT toString(number) as str, number FROM numbers(10));\n-\n-SELECT groupArraySorted(5)(text) FROM (select toString(number) as text from numbers(10));\n-\n-SELECT groupArraySorted(5)(text, -number) FROM (select toString(number) as text, number from numbers(10));\n-\n-SELECT groupArraySorted(5)((number,text)) from (SELECT toString(number) as text, number FROM numbers(100));\n-\n-SELECT groupArraySorted(5)(text,text) from (SELECT toString(number) as text FROM numbers(100));\n-\n-SELECT groupArraySorted(50)(text,(number,text)) from (SELECT toString(number) as text, number FROM numbers(100));\n-\n-SELECT groupArraySorted(10)(toInt64(number/2)) FROM numbers(100);\n-\n-\n-DROP TABLE IF EXISTS test;\n-DROP VIEW IF EXISTS mv_test;\n-CREATE TABLE test (`n` String, `h` Int64) ENGINE = MergeTree ORDER BY n;\n-CREATE MATERIALIZED VIEW mv_test (`n` String, `h` AggregateFunction(groupArraySorted(2), Int64, Int64)) ENGINE = AggregatingMergeTree ORDER BY n AS SELECT n, groupArraySortedState(2)(h, h) as h FROM test GROUP BY n;\n-INSERT INTO test VALUES ('pablo',1)('pablo', 2)('luis', 1)('luis', 3)('pablo', 5)('pablo',4)('pablo', 5)('luis', 6)('luis', 7)('pablo', 8)('pablo',9)('pablo',10)('luis',11)('luis',12)('pablo',13);\n-SELECT n, groupArraySortedMerge(2)(h) from mv_test GROUP BY n;\n-\n-DROP TABLE IF EXISTS test;\n-DROP VIEW IF EXISTS mv_test;\n-CREATE TABLE test (`n` String, `h` Int64) ENGINE = MergeTree ORDER BY n;\n-CREATE MATERIALIZED VIEW mv_test (`n` String, `h` AggregateFunction(groupArraySorted(2), Int64)) ENGINE = AggregatingMergeTree ORDER BY n AS SELECT n, groupArraySortedState(2)(h) as h FROM test GROUP BY n;\n-INSERT INTO test VALUES ('pablo',1)('pablo', 2)('luis', 1)('luis', 3)('pablo', 5)('pablo',4)('pablo', 5)('luis', 6)('luis', 7)('pablo', 8)('pablo',9)('pablo',10)('luis',11)('luis',12)('pablo',13);\n-SELECT n, groupArraySortedMerge(2)(h) from mv_test GROUP BY n;\n-DROP TABLE test;\n-DROP VIEW mv_test;\n-\n-SELECT groupArraySortedIf(5)(number, number, number>3) from numbers(100);\n-SELECT groupArraySortedIf(5)(number, toString(number), number>3) from numbers(100);\n-SELECT groupArraySortedIf(5)(toString(number), number>3) from numbers(100);\ndiff --git a/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.reference b/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.reference\nindex c4eb90020119..0b689506ed35 100644\n--- a/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.reference\n+++ b/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.reference\n@@ -1,69 +1,5 @@\n--- { echoOn }\n-explain pipeline select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings max_threads=1, optimize_aggregation_in_order=1;\n-(Expression)\n-ExpressionTransform \u00d7 2\n-  (Sorting)\n-  MergeSortingTransform\n-    LimitsCheckingTransform\n-      PartialSortingTransform\n-        (Expression)\n-        ExpressionTransform \u00d7 2\n-          (TotalsHaving)\n-          TotalsHavingTransform 1 \u2192 2\n-            (Aggregating)\n-            MergingAggregatedBucketTransform\n-              FinishAggregatingInOrderTransform 2 \u2192 1\n-                AggregatingInOrderTransform \u00d7 2\n-                  (Expression)\n-                  ExpressionTransform \u00d7 2\n-                    (SettingQuotaAndLimits)\n-                      (ReadFromMergeTree)\n-                      MergeTreeInOrder \u00d7 2 0 \u2192 1\n-explain pipeline select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings max_threads=1;\n-(Expression)\n-ExpressionTransform \u00d7 2\n-  (Sorting)\n-  MergeSortingTransform\n-    LimitsCheckingTransform\n-      PartialSortingTransform\n-        (Expression)\n-        ExpressionTransform \u00d7 2\n-          (TotalsHaving)\n-          TotalsHavingTransform 1 \u2192 2\n-            (Aggregating)\n-            AggregatingTransform\n-              (Expression)\n-              ExpressionTransform\n-                (SettingQuotaAndLimits)\n-                  (ReadFromMergeTree)\n-                  Concat 2 \u2192 1\n-                    MergeTreeInOrder \u00d7 2 0 \u2192 1\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings optimize_aggregation_in_order=1;\n-[1,2]\t10\t100\t2000\n-[1,2]\t20\t200\t4000\n-\n-[1,1,2,2]\t0\t0\t6000\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings optimize_aggregation_in_order=1, max_block_size=1;\n-[1,2]\t10\t100\t2000\n-[1,2]\t20\t200\t4000\n-\n-[1,1,2,2]\t0\t0\t6000\n--- sum() can be compiled, check that compiled version works correctly\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings optimize_aggregation_in_order=1, compile_aggregate_expressions=1, min_count_to_compile_aggregate_expression=0;\n-[1,2]\t10\t100\t2000\n-[1,2]\t20\t200\t4000\n-\n-[1,1,2,2]\t0\t0\t6000\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key;\n-[1,2]\t10\t100\t2000\n-[1,2]\t20\t200\t4000\n-\n-[1,1,2,2]\t0\t0\t6000\n--- fuzzer\n-SELECT child_key, parent_key, child_key FROM data_02233 GROUP BY parent_key, child_key, child_key ORDER BY child_key, parent_key ASC NULLS LAST SETTINGS max_threads = 1, optimize_aggregation_in_order = 1;\n 100\t10\t100\n 200\t20\t200\n-SELECT child_key, parent_key, child_key FROM data_02233 GROUP BY parent_key, child_key, child_key WITH TOTALS ORDER BY child_key, parent_key ASC NULLS LAST SETTINGS max_threads = 1, optimize_aggregation_in_order = 1;\n 100\t10\t100\n 200\t20\t200\n \ndiff --git a/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.sql b/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.sql\nindex f9eeca3da3c8..19812fe733f2 100644\n--- a/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.sql\n+++ b/tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.sql\n@@ -4,18 +4,8 @@ create table data_02233 (partition Int, parent_key Int, child_key Int, value Int\n insert into data_02233 values (1, 10, 100, 1000)(1, 20, 200, 2000);\n insert into data_02233 values (2, 10, 100, 1000)(2, 20, 200, 2000);\n \n--- { echoOn }\n-explain pipeline select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings max_threads=1, optimize_aggregation_in_order=1;\n-explain pipeline select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings max_threads=1;\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings optimize_aggregation_in_order=1;\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings optimize_aggregation_in_order=1, max_block_size=1;\n--- sum() can be compiled, check that compiled version works correctly\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key settings optimize_aggregation_in_order=1, compile_aggregate_expressions=1, min_count_to_compile_aggregate_expression=0;\n-select groupArraySorted(partition), parent_key, child_key, sum(value) from data_02233 group by parent_key, child_key with totals order by parent_key, child_key;\n-\n -- fuzzer\n SELECT child_key, parent_key, child_key FROM data_02233 GROUP BY parent_key, child_key, child_key ORDER BY child_key, parent_key ASC NULLS LAST SETTINGS max_threads = 1, optimize_aggregation_in_order = 1;\n SELECT child_key, parent_key, child_key FROM data_02233 GROUP BY parent_key, child_key, child_key WITH TOTALS ORDER BY child_key, parent_key ASC NULLS LAST SETTINGS max_threads = 1, optimize_aggregation_in_order = 1;\n \n--- { echoOff }\n drop table data_02233;\n",
  "problem_statement": "Fix groupArraySorted() for optimize_aggregation_in_order and WITH TOTALS\n### Changelog category (leave one):\r\n- Bug Fix (user-visible misbehaviour in official stable or prestable release)\r\n\r\n### Changelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nFix use-after-free in `groupArraySorted()` for `optimize_aggregation_in_order` and `WITH TOTALS`\r\n\r\ngroupArraySorted() merge operation was incorrect, it does not moves data\r\nto new arena, and hence triggers use-after-free.\r\n\r\nASan report [1]:\r\n\r\n    ==103==ERROR: AddressSanitizer: heap-use-after-free on address 0x62100c12022c at pc 0x00000d49cbcc bp 0x7f345c320e40 sp 0x7f345c3205e8\r\n    READ of size 12 at 0x62100c12022c thread T244 (QueryPipelineEx)\r\n        7 0x143e19e4 in DB::AggregateFunctionGroupArraySortedDataBase<>::merge() build_docker/../src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h:69:16\r\n        8 0x2c80296e in DB::ColumnAggregateFunction::insertMergeFrom() build_docker/../src/Columns/ColumnAggregateFunction.cpp:470:11\r\n        9 0x2ec61996 in DB::TotalsHavingTransform::addToTotals() build_docker/../src/Processors/Transforms/TotalsHavingTransform.cpp:283:35\r\n        10 0x2ec5f400 in DB::TotalsHavingTransform::transform() build_docker/../src/Processors/Transforms/TotalsHavingTransform.cpp:188:9\r\n\r\n    0x62100c12022c is located 300 bytes inside of 4096-byte region [0x62100c120100,0x62100c121100)\r\n    freed by thread T244 (QueryPipelineEx) here:\r\n        14 0x2c7f8ecd in DB::ColumnAggregateFunction::~ColumnAggregateFunction() build_docker/../src/Columns/ColumnAggregateFunction.cpp:85:1\r\n        26 0x2d23ffc3 in DB::Chunk::operator=(DB::Chunk&&) build_docker/../src/Processors/Chunk.h:53:17\r\n        27 0x2ec5f410 in DB::TotalsHavingTransform::transform(DB::Chunk&) build_docker/../src/Processors/Transforms/TotalsHavingTransform.cpp:189:15\r\n\r\n    previously allocated by thread T3 (TCPHandler) here:\r\n        18 0x2ed80019 in DB::AggregatingInOrderTransform::AggregatingInOrderTransform() build_docker/../src/Processors/Transforms/AggregatingInOrderTransform.cpp:20:9\r\n\r\n    SUMMARY: AddressSanitizer: heap-use-after-free crtstuff.c in MemcmpInterceptorCommon(void*, int (*)(void const*, void const*, unsigned long), void const*, void const*, unsigned long)\r\n\r\n  [1]: https://s3.amazonaws.com/clickhouse-test-reports/35111/0ce44f30210d362c3436f03e926bf7893b034f06/fuzzer_astfuzzerasan,actions//report.html\r\n\r\nFixes: #34055 (cc @palegre-tiny @evillique)\r\n\r\n_P.S. Serializing objects into StringRef looks odd_\n",
  "hints_text": "",
  "created_at": "2022-04-30T10:31:37Z",
  "modified_files": [
    "docs/en/sql-reference/aggregate-functions/reference/grouparraysorted.md",
    "src/AggregateFunctions/AggregateFunctionGroupArraySorted.cpp",
    "src/AggregateFunctions/AggregateFunctionGroupArraySorted.h",
    "src/AggregateFunctions/AggregateFunctionGroupArraySortedData.h",
    "src/AggregateFunctions/registerAggregateFunctions.cpp"
  ],
  "modified_test_files": [
    "tests/performance/group_array_sorted.xml",
    "tests/queries/0_stateless/02158_grouparraysorted.reference",
    "tests/queries/0_stateless/02158_grouparraysorted.sql",
    "tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.reference",
    "tests/queries/0_stateless/02233_optimize_aggregation_in_order_prefix_with_merge.sql"
  ]
}