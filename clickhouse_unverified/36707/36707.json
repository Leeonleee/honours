{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36707,
  "instance_id": "ClickHouse__ClickHouse-36707",
  "issue_numbers": [
    "36687"
  ],
  "base_commit": "d705f8ead4bdc837b8305131844f558ec002becc",
  "patch": "diff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex a1946ced2592..0f13ed9e438d 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -581,9 +581,13 @@ size_t IMergeTreeDataPart::getFileSizeOrZero(const String & file_name) const\n     return checksum->second.file_size;\n }\n \n-String IMergeTreeDataPart::getColumnNameWithMinimumCompressedSize(const StorageSnapshotPtr & storage_snapshot) const\n+String IMergeTreeDataPart::getColumnNameWithMinimumCompressedSize(\n+    const StorageSnapshotPtr & storage_snapshot, bool with_subcolumns) const\n {\n-    auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects().withSubcolumns();\n+    auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();\n+    if (with_subcolumns)\n+        options.withSubcolumns();\n+\n     auto storage_columns = storage_snapshot->getColumns(options);\n     MergeTreeData::AlterConversions alter_conversions;\n     if (!parent_part)\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.h b/src/Storages/MergeTree/IMergeTreeDataPart.h\nindex 0b57d726ccdb..8dacc6833d37 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.h\n@@ -172,7 +172,8 @@ class IMergeTreeDataPart : public std::enable_shared_from_this<IMergeTreeDataPar\n \n     /// Returns the name of a column with minimum compressed size (as returned by getColumnSize()).\n     /// If no checksums are present returns the name of the first physically existing column.\n-    String getColumnNameWithMinimumCompressedSize(const StorageSnapshotPtr & storage_snapshot) const;\n+    String getColumnNameWithMinimumCompressedSize(\n+        const StorageSnapshotPtr & storage_snapshot, bool with_subcolumns) const;\n \n     bool contains(const IMergeTreeDataPart & other) const { return info.contains(other.info); }\n \ndiff --git a/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp b/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\nindex dac304fcdffa..5cc225033484 100644\n--- a/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n+++ b/src/Storages/MergeTree/MergeTreeBlockReadUtils.cpp\n@@ -27,6 +27,7 @@ bool injectRequiredColumnsRecursively(\n     const StorageSnapshotPtr & storage_snapshot,\n     const MergeTreeData::AlterConversions & alter_conversions,\n     const MergeTreeData::DataPartPtr & part,\n+    const GetColumnsOptions & options,\n     Names & columns,\n     NameSet & required_columns,\n     NameSet & injected_columns)\n@@ -36,7 +37,6 @@ bool injectRequiredColumnsRecursively(\n     /// stages.\n     checkStackSize();\n \n-    auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withSubcolumns().withExtendedObjects();\n     auto column_in_storage = storage_snapshot->tryGetColumn(options, column_name);\n     if (column_in_storage)\n     {\n@@ -74,7 +74,9 @@ bool injectRequiredColumnsRecursively(\n \n     bool result = false;\n     for (const auto & identifier : identifiers)\n-        result |= injectRequiredColumnsRecursively(identifier, storage_snapshot, alter_conversions, part, columns, required_columns, injected_columns);\n+        result |= injectRequiredColumnsRecursively(\n+            identifier, storage_snapshot, alter_conversions, part,\n+            options, columns, required_columns, injected_columns);\n \n     return result;\n }\n@@ -85,6 +87,7 @@ NameSet injectRequiredColumns(\n     const MergeTreeData & storage,\n     const StorageSnapshotPtr & storage_snapshot,\n     const MergeTreeData::DataPartPtr & part,\n+    bool with_subcolumns,\n     Names & columns)\n {\n     NameSet required_columns{std::begin(columns), std::end(columns)};\n@@ -95,16 +98,19 @@ NameSet injectRequiredColumns(\n     if (!part->isProjectionPart())\n         alter_conversions = storage.getAlterConversionsForPart(part);\n \n+    auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();\n+    if (with_subcolumns)\n+        options.withSubcolumns();\n+\n     for (size_t i = 0; i < columns.size(); ++i)\n     {\n         /// We are going to fetch only physical columns\n-        auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withSubcolumns().withExtendedObjects();\n         if (!storage_snapshot->tryGetColumn(options, columns[i]))\n             throw Exception(ErrorCodes::NO_SUCH_COLUMN_IN_TABLE, \"There is no physical column or subcolumn {} in table\", columns[i]);\n \n         have_at_least_one_physical_column |= injectRequiredColumnsRecursively(\n             columns[i], storage_snapshot, alter_conversions,\n-            part, columns, required_columns, injected_columns);\n+            part, options, columns, required_columns, injected_columns);\n     }\n \n     /** Add a column of the minimum size.\n@@ -113,7 +119,7 @@ NameSet injectRequiredColumns(\n         */\n     if (!have_at_least_one_physical_column)\n     {\n-        const auto minimum_size_column_name = part->getColumnNameWithMinimumCompressedSize(storage_snapshot);\n+        const auto minimum_size_column_name = part->getColumnNameWithMinimumCompressedSize(storage_snapshot, with_subcolumns);\n         columns.push_back(minimum_size_column_name);\n         /// correctly report added column\n         injected_columns.insert(columns.back());\n@@ -263,13 +269,15 @@ MergeTreeReadTaskColumns getReadTaskColumns(\n     const StorageSnapshotPtr & storage_snapshot,\n     const MergeTreeData::DataPartPtr & data_part,\n     const Names & required_columns,\n-    const PrewhereInfoPtr & prewhere_info)\n+    const PrewhereInfoPtr & prewhere_info,\n+    bool with_subcolumns)\n {\n     Names column_names = required_columns;\n     Names pre_column_names;\n \n     /// inject columns required for defaults evaluation\n-    bool should_reorder = !injectRequiredColumns(storage, storage_snapshot, data_part, column_names).empty();\n+    bool should_reorder = !injectRequiredColumns(\n+        storage, storage_snapshot, data_part, with_subcolumns, column_names).empty();\n \n     if (prewhere_info)\n     {\n@@ -294,7 +302,9 @@ MergeTreeReadTaskColumns getReadTaskColumns(\n         if (pre_column_names.empty())\n             pre_column_names.push_back(column_names[0]);\n \n-        const auto injected_pre_columns = injectRequiredColumns(storage, storage_snapshot, data_part, pre_column_names);\n+        const auto injected_pre_columns = injectRequiredColumns(\n+            storage, storage_snapshot, data_part, with_subcolumns, pre_column_names);\n+\n         if (!injected_pre_columns.empty())\n             should_reorder = true;\n \n@@ -311,7 +321,10 @@ MergeTreeReadTaskColumns getReadTaskColumns(\n     MergeTreeReadTaskColumns result;\n     NamesAndTypesList all_columns;\n \n-    auto options = GetColumnsOptions(GetColumnsOptions::All).withSubcolumns().withExtendedObjects();\n+    auto options = GetColumnsOptions(GetColumnsOptions::All).withExtendedObjects();\n+    if (with_subcolumns)\n+        options.withSubcolumns();\n+\n     result.pre_columns = storage_snapshot->getColumnsByNames(options, pre_column_names);\n     result.columns = storage_snapshot->getColumnsByNames(options, column_names);\n     result.should_reorder = should_reorder;\ndiff --git a/src/Storages/MergeTree/MergeTreeBlockReadUtils.h b/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\nindex b4293b4ce3d3..a28b186a444f 100644\n--- a/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\n+++ b/src/Storages/MergeTree/MergeTreeBlockReadUtils.h\n@@ -22,7 +22,12 @@ using MergeTreeBlockSizePredictorPtr = std::shared_ptr<MergeTreeBlockSizePredict\n   * so that you can calculate the DEFAULT expression for these columns.\n   * Adds them to the `columns`.\n   */\n-NameSet injectRequiredColumns(const MergeTreeData & storage, const StorageSnapshotPtr & storage_snapshot, const MergeTreeData::DataPartPtr & part, Names & columns);\n+NameSet injectRequiredColumns(\n+    const MergeTreeData & storage,\n+    const StorageSnapshotPtr & storage_snapshot,\n+    const MergeTreeData::DataPartPtr & part,\n+    bool with_subcolumns,\n+    Names & columns);\n \n \n /// A batch of work for MergeTreeThreadSelectBlockInputStream\n@@ -76,7 +81,8 @@ MergeTreeReadTaskColumns getReadTaskColumns(\n     const StorageSnapshotPtr & storage_snapshot,\n     const MergeTreeData::DataPartPtr & data_part,\n     const Names & required_columns,\n-    const PrewhereInfoPtr & prewhere_info);\n+    const PrewhereInfoPtr & prewhere_info,\n+    bool with_subcolumns);\n \n struct MergeTreeBlockSizePredictor\n {\ndiff --git a/src/Storages/MergeTree/MergeTreeReadPool.cpp b/src/Storages/MergeTree/MergeTreeReadPool.cpp\nindex 87839edc46ff..134eba91000e 100644\n--- a/src/Storages/MergeTree/MergeTreeReadPool.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReadPool.cpp\n@@ -209,7 +209,9 @@ std::vector<size_t> MergeTreeReadPool::fillPerPartInfo(const RangesInDataParts &\n \n         per_part_sum_marks.push_back(sum_marks);\n \n-        auto task_columns = getReadTaskColumns(data, storage_snapshot, part.data_part, column_names, prewhere_info);\n+        auto task_columns = getReadTaskColumns(\n+            data, storage_snapshot, part.data_part,\n+            column_names, prewhere_info, /*with_subcolumns=*/ true);\n \n         auto size_predictor = !predict_block_size_bytes ? nullptr\n             : MergeTreeBaseSelectProcessor::getSizePredictor(part.data_part, task_columns, sample_block);\ndiff --git a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\nindex f6cbf54b752a..50d7577b7d63 100644\n--- a/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSelectProcessor.cpp\n@@ -52,7 +52,7 @@ void MergeTreeSelectProcessor::initializeReaders()\n {\n     task_columns = getReadTaskColumns(\n         storage, storage_snapshot, data_part,\n-        required_columns, prewhere_info);\n+        required_columns, prewhere_info, /*with_subcolumns=*/ true);\n \n     /// Will be used to distinguish between PREWHERE and WHERE columns when applying filter\n     const auto & column_names = task_columns.columns.getNames();\ndiff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\nindex c5a3b7935d97..62fa67235cb2 100644\n--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n@@ -41,7 +41,8 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(\n     addTotalRowsApprox(data_part->rows_count);\n \n     /// Add columns because we don't want to read empty blocks\n-    injectRequiredColumns(storage, storage_snapshot, data_part, columns_to_read);\n+    injectRequiredColumns(storage, storage_snapshot, data_part, /*with_subcolumns=*/ false, columns_to_read);\n+\n     NamesAndTypesList columns_for_reader;\n     if (take_column_types_from_storage)\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02286_vertical_merges_missed_column.reference b/tests/queries/0_stateless/02286_vertical_merges_missed_column.reference\nnew file mode 100644\nindex 000000000000..9ef2cda285ac\n--- /dev/null\n+++ b/tests/queries/0_stateless/02286_vertical_merges_missed_column.reference\n@@ -0,0 +1,2 @@\n+\\N\t1\t\n+[]\t0\ndiff --git a/tests/queries/0_stateless/02286_vertical_merges_missed_column.sql b/tests/queries/0_stateless/02286_vertical_merges_missed_column.sql\nnew file mode 100644\nindex 000000000000..950777f237f2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02286_vertical_merges_missed_column.sql\n@@ -0,0 +1,39 @@\n+DROP TABLE IF EXISTS t_vertical_merges;\n+\n+CREATE TABLE t_vertical_merges\n+(\n+  a   Nullable(String),\n+  b   Int8\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+settings\n+    vertical_merge_algorithm_min_columns_to_activate=1,\n+    vertical_merge_algorithm_min_rows_to_activate=1,\n+    min_bytes_for_wide_part=0;\n+\n+INSERT INTO t_vertical_merges SELECT NULL, 1;\n+ALTER TABLE t_vertical_merges ADD COLUMN c String;\n+OPTIMIZE TABLE t_vertical_merges FINAL;\n+SELECT a, b, c FROM t_vertical_merges;\n+\n+DROP TABLE IF EXISTS t_vertical_merges;\n+\n+CREATE TABLE t_vertical_merges\n+(\n+  a   Array(Int16),\n+  b   Int8\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+settings\n+    vertical_merge_algorithm_min_columns_to_activate=1,\n+    vertical_merge_algorithm_min_rows_to_activate=1,\n+    min_bytes_for_wide_part=0;\n+\n+INSERT INTO t_vertical_merges SELECT [], 1;\n+ALTER TABLE t_vertical_merges CLEAR COLUMN b;\n+OPTIMIZE TABLE t_vertical_merges FINAL;\n+SELECT a, b FROM t_vertical_merges;\n+\n+DROP TABLE IF EXISTS t_vertical_merges;\n",
  "problem_statement": "22.4 Vertical merges of wide parts are broken\nVertical merges of wide parts fail if there is an array in the table and not all columns are present in parts.\r\n```sql\r\nCREATE TABLE aaa \r\n(\r\n  a   Array(Int16),\r\n  b   Int8\r\n)\r\nENGINE = MergeTree\r\nORDER BY tuple() \r\nsettings\r\n    vertical_merge_algorithm_min_columns_to_activate=1,\r\n    vertical_merge_algorithm_min_rows_to_activate=1,\r\n    min_bytes_for_wide_part=0;\r\n\r\ninsert into aaa select [], 0;\r\nalter table aaa clear column b;\r\n\r\noptimize table aaa final;\r\n\r\nReceived exception from server (version 22.4.2):\r\nCode: 16. DB::Exception: Received from localhost:9000. \r\nDB::Exception: There is no column a.size0 in table. (NO_SUCH_COLUMN_IN_TABLE)\r\n```\n",
  "hints_text": "the same 22.3.4\r\n\r\n```\r\nReceived exception from server (version 22.3.4):\r\nCode: 16. DB::Exception: Received from localhost:9000. DB::Exception: There is no column a.size0 in table. (NO_SUCH_COLUMN_IN_TABLE)\r\n```\none more test with Nullable\r\n\r\n```sql\r\nCREATE TABLE aaa \r\n(\r\n  a   Nullable(String),\r\n  b   Int8\r\n)\r\nENGINE = MergeTree\r\nORDER BY tuple() \r\nsettings\r\n    vertical_merge_algorithm_min_columns_to_activate=1,\r\n    vertical_merge_algorithm_min_rows_to_activate=1,\r\n    min_bytes_for_wide_part=0;\r\n\r\ninsert into aaa select Null, 0;\r\n\r\nalter table aaa clear column b;\r\n\r\noptimize table aaa final;\r\n\r\nReceived exception from server (version 22.3.4):\r\nCode: 16. DB::Exception: Received from localhost:9000. \r\nDB::Exception: There is no column a.null in table. (NO_SUCH_COLUMN_IN_TABLE)\r\n```\n22.3.3 is not affected\n```sql\r\nCREATE TABLE aaa \r\n(\r\n  a   Nullable(String),\r\n  b   Int8\r\n)\r\nENGINE = MergeTree\r\nORDER BY tuple() \r\nsettings\r\n    vertical_merge_algorithm_min_columns_to_activate=1,\r\n    vertical_merge_algorithm_min_rows_to_activate=1,\r\n    min_bytes_for_wide_part=0;\r\n\r\ninsert into aaa select Null, 0;\r\n\r\nalter table aaa add column c String;\r\n\r\noptimize table aaa final;\r\n\r\nReceived exception from server (version 22.4.3):\r\nCode: 16. DB::Exception: Received from localhost:9000. \r\nDB::Exception: There is no column a.null in table. (NO_SUCH_COLUMN_IN_TABLE)\r\n```\n### ClickHouse release v22.3.4.20-lts as compared to v22.3.3.44-lts\r\n\r\n#### NO CL ENTRY\r\n\r\n* NO CL ENTRY:  'Fix reading of empty arrays in reverse order'. [#36215](https://github.com/ClickHouse/ClickHouse/pull/36215) ([Anton Popov](https://github.com/CurtizJ)).\r\n\r\n#### Bug Fix (user-visible misbehaviour in official stable or prestable release)\r\n\r\n* Fix possible `Can't adjust last granule` exception while reading subcolumns of type `Object`. [#35687](https://github.com/ClickHouse/ClickHouse/pull/35687) ([Anton Popov](https://github.com/CurtizJ)).\r\n* Fix possible loss of subcolumns in type `Object`. [#35682](https://github.com/ClickHouse/ClickHouse/pull/35682) ([Anton Popov](https://github.com/CurtizJ)).",
  "created_at": "2022-04-27T13:43:23Z"
}