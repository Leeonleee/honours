{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 79600,
  "instance_id": "ClickHouse__ClickHouse-79600",
  "issue_numbers": [
    "6697"
  ],
  "base_commit": "78c5eb8cd7f86c2f1a2e601d33cda7c34235d584",
  "patch": "diff --git a/src/Analyzer/QueryNode.cpp b/src/Analyzer/QueryNode.cpp\nindex b6e1a66252bf..cc8a76d55ba2 100644\n--- a/src/Analyzer/QueryNode.cpp\n+++ b/src/Analyzer/QueryNode.cpp\n@@ -1,3 +1,4 @@\n+#include <memory>\n #include <Analyzer/QueryNode.h>\n \n #include <fmt/core.h>\n@@ -34,6 +35,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int BAD_ARGUMENTS;\n+    extern const int UNSUPPORTED_METHOD;\n }\n \n QueryNode::QueryNode(ContextMutablePtr context_, SettingsChanges settings_changes_)\n@@ -135,6 +137,22 @@ void QueryNode::addCorrelatedColumn(const QueryTreeNodePtr & correlated_column)\n     correlated_columns.push_back(correlated_column);\n }\n \n+DataTypePtr QueryNode::getResultType() const\n+{\n+    if (isCorrelated())\n+    {\n+        if (projection_columns.size() == 1)\n+        {\n+            return projection_columns[0].type;\n+        }\n+        else\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                \"Method getResultType is supported only for correlated query node with 1 column, but got {}\",\n+                projection_columns.size());\n+    }\n+    throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Method getResultType is supported only for correlated query node\");\n+}\n+\n void QueryNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const\n {\n     buffer << std::string(indent, ' ') << \"QUERY id: \" << format_state.getNodeId(this);\ndiff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h\nindex 15f7aef675ca..77c192bddd35 100644\n--- a/src/Analyzer/QueryNode.h\n+++ b/src/Analyzer/QueryNode.h\n@@ -647,6 +647,10 @@ class QueryNode final : public IQueryTreeNode\n \n     void addCorrelatedColumn(const QueryTreeNodePtr & correlated_column);\n \n+    /// Returns result type of projection expression if query is correlated\n+    /// or throws an exception otherwise.\n+    DataTypePtr getResultType() const override;\n+\n     QueryTreeNodeType getNodeType() const override\n     {\n         return QueryTreeNodeType::QUERY;\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex d3177ba4af3c..64a649475ffe 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -547,6 +547,11 @@ void QueryAnalyzer::evaluateScalarSubqueryIfNeeded(QueryTreeNodePtr & node, Iden\n             node->getNodeTypeName(),\n             node->formatASTForErrorMessage());\n \n+    bool is_correlated_subquery = (query_node != nullptr && query_node->isCorrelated())\n+                                || (union_node != nullptr && union_node->isCorrelated());\n+    if (is_correlated_subquery)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Cannot evaluate correlated scalar subquery\");\n+\n     auto & context = scope.context;\n \n     Block scalar_block;\n@@ -2533,7 +2538,8 @@ ProjectionName QueryAnalyzer::resolveWindow(QueryTreeNodePtr & node, IdentifierR\n     auto & window_node = node->as<WindowNode &>();\n     window_node.setParentWindowName({});\n \n-    ProjectionNames partition_by_projection_names = resolveExpressionNodeList(window_node.getPartitionByNode(),\n+    ProjectionNames partition_by_projection_names = resolveExpressionNodeList(\n+        window_node.getPartitionByNode(),\n         scope,\n         false /*allow_lambda_expression*/,\n         false /*allow_table_expression*/);\n@@ -2743,7 +2749,8 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n \n     /// Resolve function parameters\n \n-    auto parameters_projection_names = resolveExpressionNodeList(function_node_ptr->getParametersNode(),\n+    auto parameters_projection_names = resolveExpressionNodeList(\n+        function_node_ptr->getParametersNode(),\n         scope,\n         false /*allow_lambda_expression*/,\n         false /*allow_table_expression*/);\n@@ -2924,7 +2931,8 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n \n     /// Resolve function arguments\n     bool allow_table_expressions = is_special_function_in || is_special_function_exists;\n-    auto arguments_projection_names = resolveExpressionNodeList(function_node_ptr->getArgumentsNode(),\n+    auto arguments_projection_names = resolveExpressionNodeList(\n+        function_node_ptr->getArgumentsNode(),\n         scope,\n         true /*allow_lambda_expression*/,\n         allow_table_expressions /*allow_table_expression*/);\n@@ -3929,7 +3937,11 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(\n             else\n                 resolveUnion(node, subquery_scope);\n \n-            if (!allow_table_expression)\n+            bool is_correlated_subquery = node_type == QueryTreeNodeType::QUERY\n+                ? node->as<QueryNode>()->isCorrelated()\n+                : node->as<UnionNode>()->isCorrelated();\n+\n+            if (!allow_table_expression && !is_correlated_subquery)\n                 evaluateScalarSubqueryIfNeeded(node, subquery_scope);\n \n             if (result_projection_names.empty())\n@@ -4022,7 +4034,12 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(\n   * Example: CREATE TABLE test_table (id UInt64, value UInt64) ENGINE=TinyLog; SELECT plus(*) FROM test_table;\n   * Example: SELECT *** FROM system.one;\n   */\n-ProjectionNames QueryAnalyzer::resolveExpressionNodeList(QueryTreeNodePtr & node_list, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression)\n+ProjectionNames QueryAnalyzer::resolveExpressionNodeList(\n+    QueryTreeNodePtr & node_list,\n+    IdentifierResolveScope & scope,\n+    bool allow_lambda_expression,\n+    bool allow_table_expression\n+)\n {\n     auto & node_list_typed = node_list->as<ListNode &>();\n     size_t node_list_size = node_list_typed.getNodes().size();\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 113573e23e66..ebbf90e6fb0f 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -5529,10 +5529,10 @@ void Context::setGoogleProtosPath(const String & path)\n     shared->google_protos_path = path;\n }\n \n-Context::SampleBlockCache & Context::getSampleBlockCache() const\n+std::pair<Context::SampleBlockCache *, std::unique_lock<std::mutex>> Context::getSampleBlockCache() const\n {\n     assert(hasQueryContext());\n-    return getQueryContext()->sample_block_cache;\n+    return std::make_pair(&getQueryContext()->sample_block_cache, std::unique_lock(getQueryContext()->sample_block_cache_mutex));\n }\n \n \ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex 11e64bf16cf1..7a54d965a885 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -534,6 +534,7 @@ class ContextData\n protected:\n     using SampleBlockCache = std::unordered_map<std::string, Block>;\n     mutable SampleBlockCache sample_block_cache;\n+    mutable std::mutex sample_block_cache_mutex;\n \n     PartUUIDsPtr part_uuids; /// set of parts' uuids, is used for query parts deduplication\n     PartUUIDsPtr ignored_part_uuids; /// set of parts' uuids are meant to be excluded from query processing\n@@ -1405,7 +1406,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     String getGoogleProtosPath() const;\n     void setGoogleProtosPath(const String & path);\n \n-    SampleBlockCache & getSampleBlockCache() const;\n+    std::pair<Context::SampleBlockCache *, std::unique_lock<std::mutex>> getSampleBlockCache() const;\n \n     /// Query parameters for prepared statements.\n     bool hasQueryParameters() const;\ndiff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\nindex 0dc5209d670f..3dc0a8736d76 100644\n--- a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n@@ -283,12 +283,12 @@ Block InterpreterSelectWithUnionQuery::getSampleBlock(const ASTPtr & query_ptr_,\n         return InterpreterSelectWithUnionQuery(query_ptr_, context_, std::move(options.analyze())).getSampleBlock();\n     }\n \n-    auto & cache = context_->getSampleBlockCache();\n     /// Using query string because query_ptr changes for every internal SELECT\n     auto key = query_ptr_->formatWithSecretsOneLine();\n-    if (cache.find(key) != cache.end())\n     {\n-        return cache[key];\n+        auto [cache, lock] = context_->getSampleBlockCache();\n+        if (cache->find(key) != cache->end())\n+            return cache->at(key);\n     }\n \n     SelectQueryOptions options;\n@@ -296,7 +296,10 @@ Block InterpreterSelectWithUnionQuery::getSampleBlock(const ASTPtr & query_ptr_,\n         options = options.subquery();\n     if (is_create_parameterized_view)\n         options = options.createParameterizedView();\n-    return cache[key] = InterpreterSelectWithUnionQuery(query_ptr_, context_, std::move(options.analyze())).getSampleBlock();\n+\n+    auto sample_block = InterpreterSelectWithUnionQuery(query_ptr_, context_, std::move(options.analyze())).getSampleBlock();\n+    auto [cache, lock] = context_->getSampleBlockCache();\n+    return (*cache)[key] = sample_block;\n }\n \n \ndiff --git a/src/Interpreters/JoinInfo.cpp b/src/Interpreters/JoinInfo.cpp\nindex 05ca14b6cb50..44e137057df5 100644\n--- a/src/Interpreters/JoinInfo.cpp\n+++ b/src/Interpreters/JoinInfo.cpp\n@@ -356,6 +356,16 @@ JoinActionRef JoinActionRef::deserialize(ReadBuffer & in, const ActionsDAGRawPtr\n     return res;\n }\n \n+JoinActionRef JoinActionRef::clone(const ActionsDAG * actions_dag_) const\n+{\n+    return JoinActionRef{actions_dag_, column_name};\n+}\n+\n+JoinActionRef::JoinActionRef(const ActionsDAG * actions_dag_, const String & column_name_)\n+    : actions_dag(actions_dag_)\n+    , column_name(column_name_)\n+{}\n+\n void JoinPredicate::serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const\n {\n     serializePredicateOperator(op, out);\n@@ -435,6 +445,40 @@ JoinCondition JoinCondition::deserialize(ReadBuffer & in, const JoinActionRef::A\n     };\n }\n \n+JoinCondition JoinCondition::clone(const JoinExpressionActions & expression_actions) const\n+{\n+    JoinCondition copy;\n+\n+    copy.predicates.reserve(predicates.size());\n+    for (const auto & predicate : predicates)\n+    {\n+        copy.predicates.emplace_back(\n+            predicate.left_node.clone(expression_actions.left_pre_join_actions.get()),\n+            predicate.right_node.clone(expression_actions.right_pre_join_actions.get()),\n+            predicate.op);\n+    }\n+\n+    copy.left_filter_conditions.reserve(left_filter_conditions.size());\n+    for (const auto & condition: left_filter_conditions)\n+    {\n+        copy.left_filter_conditions.emplace_back(condition.clone(expression_actions.left_pre_join_actions.get()));\n+    }\n+\n+    copy.right_filter_conditions.reserve(right_filter_conditions.size());\n+    for (const auto & condition: right_filter_conditions)\n+    {\n+        copy.right_filter_conditions.emplace_back(condition.clone(expression_actions.right_pre_join_actions.get()));\n+    }\n+\n+    copy.residual_conditions.reserve(residual_conditions.size());\n+    for (const auto & condition: residual_conditions)\n+    {\n+        copy.residual_conditions.emplace_back(condition.clone(expression_actions.post_join_actions.get()));\n+    }\n+\n+    return copy;\n+}\n+\n void JoinExpression::serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const\n {\n     UInt8 is_using_flag = is_using ? 1 : 0;\n@@ -473,6 +517,20 @@ JoinExpression JoinExpression::deserialize(ReadBuffer & in, const JoinActionRef:\n     return {std::move(condition), std::move(disjunctive_conditions), bool(is_using_flag)};\n }\n \n+JoinExpression JoinExpression::clone(const JoinExpressionActions & expression_copy) const\n+{\n+    JoinExpression copy;\n+    copy.condition = condition.clone(expression_copy);\n+\n+    copy.disjunctive_conditions.reserve(disjunctive_conditions.size());\n+    for (const auto & disjunctive_condition : disjunctive_conditions)\n+        copy.disjunctive_conditions.emplace_back(disjunctive_condition.clone(expression_copy));\n+\n+    copy.is_using = is_using;\n+\n+    return copy;\n+}\n+\n void JoinInfo::serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const\n {\n     expression.serialize(out, dags);\ndiff --git a/src/Interpreters/JoinInfo.h b/src/Interpreters/JoinInfo.h\nindex 6d39893041f4..072c3bf6ac36 100644\n--- a/src/Interpreters/JoinInfo.h\n+++ b/src/Interpreters/JoinInfo.h\n@@ -75,6 +75,20 @@ struct JoinExpressionActions\n     {\n     }\n \n+    JoinExpressionActions clone() const\n+    {\n+        return  JoinExpressionActions(\n+            std::make_unique<ActionsDAG>(left_pre_join_actions->clone()),\n+            std::make_unique<ActionsDAG>(right_pre_join_actions->clone()),\n+            std::make_unique<ActionsDAG>(post_join_actions->clone())\n+        );\n+    }\n+\n+    bool hasCorrelatedExpressions() const noexcept\n+    {\n+        return left_pre_join_actions->hasCorrelatedColumns() || right_pre_join_actions->hasCorrelatedColumns() || post_join_actions->hasCorrelatedColumns();\n+    }\n+\n     ActionsDAGPtr left_pre_join_actions;\n     ActionsDAGPtr right_pre_join_actions;\n     ActionsDAGPtr post_join_actions;\n@@ -103,7 +117,11 @@ class JoinActionRef\n     void serialize(WriteBuffer & out, const ActionsDAGRawPtrs & dags) const;\n     static JoinActionRef deserialize(ReadBuffer & in, const ActionsDAGRawPtrs & dags);\n \n+    JoinActionRef clone(const ActionsDAG * actions_dag_) const;\n+\n private:\n+    JoinActionRef(const ActionsDAG * actions_dag_, const String & column_name_);\n+\n     const ActionsDAG * actions_dag = nullptr;\n     String column_name;\n };\n@@ -136,6 +154,8 @@ struct JoinCondition\n \n     void serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const;\n     static JoinCondition deserialize(ReadBuffer & in, const JoinActionRef::ActionsDAGRawPtrs & dags);\n+\n+    JoinCondition clone(const JoinExpressionActions & expression_actions) const;\n };\n \n struct JoinExpression\n@@ -154,6 +174,8 @@ struct JoinExpression\n \n     void serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const;\n     static JoinExpression deserialize(ReadBuffer & in, const JoinActionRef::ActionsDAGRawPtrs & dags);\n+\n+    JoinExpression clone(const JoinExpressionActions & expression_copy) const;\n };\n \n struct JoinInfo\n@@ -170,6 +192,11 @@ struct JoinInfo\n     /// The locality of the join (e.g., LOCAL, GLOBAL)\n     JoinLocality locality;\n \n+    JoinInfo clone(const JoinExpressionActions & expression_actions) const\n+    {\n+        return JoinInfo{ expression.clone(expression_actions), kind, strictness, locality};\n+    }\n+\n     void serialize(WriteBuffer & out, const JoinActionRef::ActionsDAGRawPtrs & dags) const;\n     static JoinInfo deserialize(ReadBuffer & in, const JoinActionRef::ActionsDAGRawPtrs & dags);\n };\ndiff --git a/src/Planner/CollectColumnIdentifiers.cpp b/src/Planner/CollectColumnIdentifiers.cpp\nindex 373d5797bada..aab77244baff 100644\n--- a/src/Planner/CollectColumnIdentifiers.cpp\n+++ b/src/Planner/CollectColumnIdentifiers.cpp\n@@ -1,7 +1,11 @@\n #include <Planner/CollectColumnIdentifiers.h>\n \n-#include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ColumnNode.h>\n+#include <Analyzer/FunctionNode.h>\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/QueryNode.h>\n+#include <Analyzer/UnionNode.h>\n+#include <Analyzer/Utils.h>\n \n #include <Planner/PlannerContext.h>\n \n@@ -35,6 +39,30 @@ class CollectTopLevelColumnIdentifiersVisitor : public ConstInDepthQueryTreeVisi\n \n     void visitImpl(const QueryTreeNodePtr & node)\n     {\n+        if (node->getNodeType() == QueryTreeNodeType::FUNCTION)\n+        {\n+            auto * function_node = node->as<FunctionNode>();\n+            for (const auto & argument : function_node->getArguments().getNodes())\n+            {\n+                if (!isCorrelatedQueryOrUnionNode(argument))\n+                    continue;\n+\n+                auto * query_node = argument->as<QueryNode>();\n+                auto * union_node = argument->as<UnionNode>();\n+\n+                const auto & correlated_columns = query_node != nullptr ? query_node->getCorrelatedColumns() : union_node->getCorrelatedColumns();\n+                for (const auto & column : correlated_columns)\n+                {\n+                    const auto * column_identifier = planner_context->getColumnNodeIdentifierOrNull(column);\n+                    if (!column_identifier)\n+                        return;\n+\n+                    used_identifiers.insert(*column_identifier);\n+                }\n+            }\n+            return;\n+        }\n+\n         if (node->getNodeType() != QueryTreeNodeType::COLUMN)\n             return;\n \ndiff --git a/src/Planner/CollectTableExpressionData.cpp b/src/Planner/CollectTableExpressionData.cpp\nindex 9218a5b35e20..8c11e17cdcb8 100644\n--- a/src/Planner/CollectTableExpressionData.cpp\n+++ b/src/Planner/CollectTableExpressionData.cpp\n@@ -47,21 +47,25 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co\n             return;\n         }\n \n-        if (isExistsFunction(node))\n+        if (auto * function_node = node->as<FunctionNode>())\n         {\n             /// Add used in correlated subquery columns to the table expression data.\n             /// These columns can be used only by correlated subquery, but still they\n             /// must be read by query plan for current query.\n             ///\n             /// Example: SELECT 1 FROM table as t WHERE EXISTS (SELECT * FROM numbers(10) WHERE t.id = number);\n-            auto * function_node = node->as<FunctionNode>();\n-            const auto & subquery_argument = function_node->getArguments().getNodes().front();\n-            auto * query_node = subquery_argument->as<QueryNode>();\n-            auto * union_node = subquery_argument->as<UnionNode>();\n-            chassert(query_node != nullptr || union_node != nullptr);\n-\n-            auto & correlated_columns = query_node ? query_node->getCorrelatedColumnsNode() : union_node->getCorrelatedColumnsNode();\n-            visit(correlated_columns);\n+            for (const auto & argument : function_node->getArguments().getNodes())\n+            {\n+                if (!isCorrelatedQueryOrUnionNode(argument))\n+                    continue;\n+\n+                auto * query_node = argument->as<QueryNode>();\n+                auto * union_node = argument->as<UnionNode>();\n+                chassert(query_node != nullptr || union_node != nullptr);\n+\n+                auto & correlated_columns = query_node ? query_node->getCorrelatedColumnsNode() : union_node->getCorrelatedColumnsNode();\n+                visit(correlated_columns);\n+            }\n             return;\n         }\n \n@@ -205,11 +209,6 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitorWithContext<Co\n         return node->as<FunctionNode>() && node->as<FunctionNode>()->getFunctionName() == \"indexHint\";\n     }\n \n-    static bool isExistsFunction(const QueryTreeNodePtr & node)\n-    {\n-        return node->as<FunctionNode>() && node->as<FunctionNode>()->getFunctionName() == \"exists\";\n-    }\n-\n     static bool isColumnSourceMergeTree(const ColumnNode & node)\n     {\n         const auto * source_table = node.getColumnSource()->as<TableNode>();\ndiff --git a/src/Planner/PlannerActionsVisitor.cpp b/src/Planner/PlannerActionsVisitor.cpp\nindex 28b3cd477aac..ab068989fee3 100644\n--- a/src/Planner/PlannerActionsVisitor.cpp\n+++ b/src/Planner/PlannerActionsVisitor.cpp\n@@ -15,12 +15,12 @@\n #include <Analyzer/Utils.h>\n #include <Analyzer/WindowNode.h>\n \n-#include <DataTypes/FieldToDataType.h>\n #include <DataTypes/DataTypeSet.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/FieldToDataType.h>\n \n #include <Common/FieldVisitorToString.h>\n #include <Common/quoteString.h>\n-#include <DataTypes/DataTypeTuple.h>\n \n #include <Columns/ColumnSet.h>\n #include <Columns/ColumnConst.h>\n@@ -334,6 +334,18 @@ class ActionNodeNameHelper\n                 result = buffer.str();\n                 break;\n             }\n+            case QueryTreeNodeType::QUERY:\n+            {\n+                auto & query_node = node->as<QueryNode &>();\n+                if (query_node.isCorrelated())\n+                    result = query_node.getAlias();\n+                else\n+                    throw Exception(\n+                        ErrorCodes::LOGICAL_ERROR,\n+                        \"Only correlated QueryNode can be used as action query tree node, but got {}\",\n+                        node->formatASTForErrorMessage());\n+                break;\n+            }\n             default:\n             {\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid action query tree node {}\", node->formatASTForErrorMessage());\n@@ -661,6 +673,8 @@ class PlannerActionsVisitorImpl\n \n     NodeNameAndNodeMinLevel visitFunction(const QueryTreeNodePtr & node);\n \n+    NodeNameAndNodeMinLevel visitQuery(const QueryTreeNodePtr & node);\n+\n     std::vector<ActionsScopeNode> actions_stack;\n     std::unordered_map<QueryTreeNodePtr, std::string> node_to_node_name;\n     CorrelatedSubtrees correlated_subtrees;\n@@ -709,16 +723,21 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n {\n     auto node_type = node->getNodeType();\n \n-    if (node_type == QueryTreeNodeType::COLUMN)\n+    switch (node_type)\n+    {\n+    case QueryTreeNodeType::COLUMN:\n         return visitColumn(node);\n-    if (node_type == QueryTreeNodeType::CONSTANT)\n+    case QueryTreeNodeType::CONSTANT:\n         return visitConstant(node);\n-    if (node_type == QueryTreeNodeType::FUNCTION)\n+    case QueryTreeNodeType::FUNCTION:\n         return visitFunction(node);\n-\n-    throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-        \"Expected column, constant, function. Actual {} with type: {}\",\n-        node->formatASTForErrorMessage(), node_type);\n+    case QueryTreeNodeType::QUERY:\n+        return visitQuery(node);\n+    default:\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+            \"Expected column, constant, function. Actual {} with type: {}\",\n+            node->formatASTForErrorMessage(), node_type);\n+    }\n }\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitColumn(const QueryTreeNodePtr & node)\n@@ -1138,6 +1157,44 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     return {function_node_name, levels};\n }\n \n+PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitQuery(const QueryTreeNodePtr & node)\n+{\n+    auto & query_node = node->as<QueryNode &>();\n+    if (!query_node.isCorrelated())\n+        throw Exception(\n+            ErrorCodes::LOGICAL_ERROR,\n+            \"Only correlated QueryNode can be used as an action node, but got: {}\",\n+            node->formatASTForErrorMessage());\n+\n+    Levels levels(0);\n+\n+    auto correlated_subquery_name = action_node_name_helper.calculateActionNodeName(node);\n+\n+    size_t actions_stack_size = actions_stack.size();\n+    for (size_t i = 0; i < actions_stack_size; ++i)\n+    {\n+        auto & actions_stack_node = actions_stack[i];\n+        actions_stack_node.addInputColumnIfNecessary(correlated_subquery_name, query_node.getResultType());\n+    }\n+\n+    const auto & correlated_columns = query_node.getCorrelatedColumns().getNodes();\n+\n+    ColumnIdentifiers correlated_column_identifiers;\n+    correlated_column_identifiers.reserve(correlated_columns.size());\n+    for (const auto & column : correlated_columns)\n+    {\n+        correlated_column_identifiers.push_back(action_node_name_helper.calculateActionNodeName(column));\n+    }\n+\n+    correlated_subtrees.subqueries.emplace_back(\n+        node,\n+        CorrelatedSubqueryKind::SCALAR,\n+        correlated_subquery_name,\n+        std::move(correlated_column_identifiers));\n+\n+    return { correlated_subquery_name, levels };\n+}\n+\n }\n \n PlannerActionsVisitor::PlannerActionsVisitor(\ndiff --git a/src/Planner/PlannerCorrelatedSubqueries.cpp b/src/Planner/PlannerCorrelatedSubqueries.cpp\nindex b178e162eed6..53adff4541ca 100644\n--- a/src/Planner/PlannerCorrelatedSubqueries.cpp\n+++ b/src/Planner/PlannerCorrelatedSubqueries.cpp\n@@ -39,6 +39,7 @@ namespace ErrorCodes\n {\n \n extern const int NOT_IMPLEMENTED;\n+extern const int LOGICAL_ERROR;\n \n }\n \n@@ -99,6 +100,7 @@ CorrelatedPlanStepMap buildCorrelatedPlanStepMap(QueryPlan & correlated_query_pl\n \n struct DecorrelationContext\n {\n+    const CorrelatedSubquery & correlated_subquery;\n     const PlannerContextPtr & planner_context;\n     QueryPlan query_plan; // LHS plan\n     QueryPlan correlated_query_plan;\n@@ -216,10 +218,73 @@ QueryPlan decorrelateQueryPlan(\n \n         return result_plan;\n     }\n+    if (auto * aggeregating_step = typeid_cast<AggregatingStep *>(node->step.get()))\n+    {\n+        auto decorrelated_query_plan = decorrelateQueryPlan(context, node->children.front());\n+        auto input_header = decorrelated_query_plan.getCurrentHeader();\n+\n+        if (aggeregating_step->isGroupingSets())\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Decorrelation of GROUP BY GROUPING SETS is not supported yet\");\n+\n+        auto new_aggregator_params = aggeregating_step->getAggregatorParameters();\n+\n+        for (const auto & correlated_column_identifier : context.correlated_subquery.correlated_column_identifiers)\n+        {\n+            new_aggregator_params.keys.push_back(correlated_column_identifier);\n+        }\n+        new_aggregator_params.keys_size = new_aggregator_params.keys.size();\n+\n+        auto result_step = std::make_unique<AggregatingStep>(\n+            std::move(input_header),\n+            std::move(new_aggregator_params),\n+            aggeregating_step->getGroupingSetsParamsList(),\n+            aggeregating_step->getFinal(),\n+            aggeregating_step->getMaxBlockSize(),\n+            aggeregating_step->getMaxBlockSizeForAggregationInOrder(),\n+            aggeregating_step->getMergeThreads(),\n+            aggeregating_step->getTemporaryDataMergeThreads(),\n+            false /*storage_has_evenly_distributed_read_*/,\n+            aggeregating_step->isGroupByUseNulls(),\n+            SortDescription{} /*sort_description_for_merging_*/,\n+            SortDescription{} /*group_by_sort_description_*/,\n+            aggeregating_step->shouldProduceResultsInBucketOrder(),\n+            aggeregating_step->usingMemoryBoundMerging(),\n+            aggeregating_step->explicitSortingRequired()\n+        );\n+        result_step->setStepDescription(aggeregating_step->getStepDescription());\n+\n+        decorrelated_query_plan.addStep(std::move(result_step));\n+\n+        return decorrelated_query_plan;\n+    }\n     throw Exception(\n         ErrorCodes::NOT_IMPLEMENTED,\n         \"Cannot decorrelate query, because '{}' step is not supported\",\n-        node->step->getStepDescription());\n+        node->step->getName());\n+}\n+\n+void buildRenamingForScalarSubquery(\n+    QueryPlan & query_plan,\n+    const CorrelatedSubquery & correlated_subquery\n+)\n+{\n+    ActionsDAG dag(query_plan.getCurrentHeader().getNamesAndTypesList());\n+    const auto * result_node = &dag.findInOutputs(correlated_subquery.action_node_name);\n+\n+    ActionsDAG::NodeRawConstPtrs new_outputs{ result_node };\n+    new_outputs.reserve(correlated_subquery.correlated_column_identifiers.size() + 1);\n+\n+    for (const auto & column_name : correlated_subquery.correlated_column_identifiers)\n+    {\n+        new_outputs.push_back(&dag.addAlias(dag.findInOutputs(column_name), fmt::format(\"{}.{}\", correlated_subquery.action_node_name, column_name)));\n+    }\n+    new_outputs.push_back(result_node);\n+\n+    dag.getOutputs() = std::move(new_outputs);\n+\n+    auto expression_step = std::make_unique<ExpressionStep>(query_plan.getCurrentHeader(), std::move(dag));\n+    expression_step->setStepDescription(\"Create renaming actions for scalar subquery\");\n+    query_plan.addStep(std::move(expression_step));\n }\n \n void buildExistsResultExpression(\n@@ -364,6 +429,61 @@ QueryPlan buildLogicalJoin(\n     return result_plan;\n }\n \n+Planner buildPlannerForCorrelatedSubquery(\n+    const PlannerContextPtr & planner_context,\n+    const CorrelatedSubquery & correlated_subquery,\n+    const SelectQueryOptions & select_query_options\n+)\n+{\n+    auto subquery_options = select_query_options.subquery();\n+    auto global_planner_context = std::make_shared<GlobalPlannerContext>(nullptr, nullptr, FiltersForTableExpressionMap{});\n+    /// Register table expression data for correlated columns sources in the global context.\n+    /// Table expression data would be reused because it can't be initialized\n+    /// during plan construction for correlated subquery.\n+    global_planner_context->collectTableExpressionDataForCorrelatedColumns(correlated_subquery.query_tree, planner_context);\n+\n+    Planner subquery_planner(\n+        correlated_subquery.query_tree,\n+        subquery_options,\n+        std::move(global_planner_context));\n+    subquery_planner.buildQueryPlanIfNeeded();\n+\n+    return subquery_planner;\n+}\n+\n+void addStepForResultRenaming(\n+    const CorrelatedSubquery & correlated_subquery,\n+    QueryPlan & correlated_subquery_plan\n+)\n+{\n+    const auto & header = correlated_subquery_plan.getCurrentHeader();\n+    const auto & subquery_result_columns = header.getColumnsWithTypeAndName();\n+\n+    if (subquery_result_columns.size() != 1)\n+        throw Exception(\n+            ErrorCodes::LOGICAL_ERROR,\n+            \"Expected to get only 1 result column of correlated subquery, but got {}\",\n+            subquery_result_columns.size());\n+\n+    const auto & result_column = subquery_result_columns[0];\n+    auto expected_result_type = correlated_subquery.query_tree->getResultType();\n+    if (!expected_result_type->equals(*result_column.type))\n+        throw Exception(\n+            ErrorCodes::LOGICAL_ERROR,\n+            \"Expected {} as correlated subquery result, but got {}\",\n+            expected_result_type->getName(),\n+            result_column.type->getName());\n+\n+    ActionsDAG dag(subquery_result_columns);\n+\n+    const auto * alias_node = &dag.addAlias(*dag.getOutputs()[0], correlated_subquery.action_node_name);\n+    dag.getOutputs() = { alias_node };\n+\n+    auto expression_step = std::make_unique<ExpressionStep>(header, std::move(dag));\n+    expression_step->setStepDescription(\"Create correlated subquery result alias\");\n+    correlated_subquery_plan.addStep(std::move(expression_step));\n+}\n+\n }\n \n /* Build query plan for correlated subquery using decorrelation algorithm\n@@ -396,23 +516,38 @@ void buildQueryPlanForCorrelatedSubquery(\n     {\n         case DB::CorrelatedSubqueryKind::SCALAR:\n         {\n-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Scalar correlated subqueries are not supported\");\n+            Planner subquery_planner = buildPlannerForCorrelatedSubquery(planner_context, correlated_subquery, select_query_options);\n+            /// Logical plan for correlated subquery\n+            auto & correlated_query_plan = subquery_planner.getQueryPlan();\n+\n+            addStepForResultRenaming(correlated_subquery, correlated_query_plan);\n+\n+            /// Mark all query plan steps if they or their subplans contain usage of correlated subqueries.\n+            /// It's needed to identify the moment when dependent join can be replaced by CROSS JOIN.\n+            auto correlated_step_map = buildCorrelatedPlanStepMap(correlated_query_plan);\n+\n+            DecorrelationContext context{\n+                .correlated_subquery = correlated_subquery,\n+                .planner_context = planner_context,\n+                .query_plan = std::move(query_plan),\n+                .correlated_query_plan = std::move(subquery_planner).extractQueryPlan(),\n+                .correlated_plan_steps = std::move(correlated_step_map)\n+            };\n+\n+            auto decorrelated_plan = decorrelateQueryPlan(context, context.correlated_query_plan.getRootNode());\n+            buildRenamingForScalarSubquery(decorrelated_plan, correlated_subquery);\n+\n+            /// Use LEFT OUTER JOIN to produce the result plan.\n+            query_plan = buildLogicalJoin(\n+                planner_context,\n+                std::move(context.query_plan),\n+                std::move(decorrelated_plan),\n+                correlated_subquery);\n+            break;\n         }\n         case CorrelatedSubqueryKind::EXISTS:\n         {\n-            auto subquery_options = select_query_options.subquery();\n-            auto global_planner_context = std::make_shared<GlobalPlannerContext>(nullptr, nullptr, FiltersForTableExpressionMap{});\n-            /// Register table expression data for correlated columns sources in the global context.\n-            /// Table expression data would be reused because it can't be initialized\n-            /// during plan construction for correlated subquery.\n-            global_planner_context->collectTableExpressionDataForCorrelatedColumns(correlated_subquery.query_tree, planner_context);\n-\n-            Planner subquery_planner(\n-                correlated_subquery.query_tree,\n-                subquery_options,\n-                global_planner_context);\n-            subquery_planner.buildQueryPlanIfNeeded();\n-\n+            Planner subquery_planner = buildPlannerForCorrelatedSubquery(planner_context, correlated_subquery, select_query_options);\n             /// Logical plan for correlated subquery\n             auto & correlated_query_plan = subquery_planner.getQueryPlan();\n \n@@ -432,6 +567,7 @@ void buildQueryPlanForCorrelatedSubquery(\n             auto correlated_step_map = buildCorrelatedPlanStepMap(correlated_query_plan);\n \n             DecorrelationContext context{\n+                .correlated_subquery = correlated_subquery,\n                 .planner_context = planner_context,\n                 .query_plan = std::move(query_plan),\n                 .correlated_query_plan = std::move(subquery_planner).extractQueryPlan(),\ndiff --git a/src/Processors/QueryPlan/AggregatingStep.h b/src/Processors/QueryPlan/AggregatingStep.h\nindex 21b59b62ecd6..c6b68fef9018 100644\n--- a/src/Processors/QueryPlan/AggregatingStep.h\n+++ b/src/Processors/QueryPlan/AggregatingStep.h\n@@ -85,6 +85,19 @@ class AggregatingStep : public ITransformingStep\n \n     void enableMemoryBoundMerging() { memory_bound_merging_of_aggregation_results_enabled = true; }\n \n+    /// AggregatingStep does not contain any ActionDAGs.\n+    /// All the expressions used in the AggregatingStep must be evaluated before that.\n+    bool hasCorrelatedExpressions() const override { return false; }\n+\n+    Aggregator::Params getAggregatorParameters() const { return params; }\n+    bool getFinal() const noexcept { return final; }\n+    size_t getMaxBlockSize() const noexcept { return max_block_size; }\n+    size_t getMaxBlockSizeForAggregationInOrder() const noexcept { return aggregation_in_order_max_block_bytes; }\n+    size_t getMergeThreads() const noexcept { return merge_threads; }\n+    size_t getTemporaryDataMergeThreads() const noexcept { return temporary_data_merge_threads; }\n+    bool shouldProduceResultsInBucketOrder() const noexcept { return should_produce_results_in_order_of_bucket_number; }\n+    bool usingMemoryBoundMerging() const noexcept { return memory_bound_merging_of_aggregation_results_enabled; }\n+\n private:\n     void updateOutputHeader() override;\n \ndiff --git a/src/Processors/QueryPlan/JoinStepLogical.cpp b/src/Processors/QueryPlan/JoinStepLogical.cpp\nindex 7ab98dee7801..4026d04b2e76 100644\n--- a/src/Processors/QueryPlan/JoinStepLogical.cpp\n+++ b/src/Processors/QueryPlan/JoinStepLogical.cpp\n@@ -889,6 +889,23 @@ std::unique_ptr<IQueryPlanStep> JoinStepLogical::deserialize(Deserialization & c\n         std::move(sort_settings));\n }\n \n+QueryPlanStepPtr JoinStepLogical::clone() const\n+{\n+    auto new_expression_actions = expression_actions.clone();\n+    auto new_join_info = join_info.clone(new_expression_actions);\n+\n+    auto result_step = std::make_unique<JoinStepLogical>(\n+        getInputHeaders().front(), getInputHeaders().back(),\n+        std::move(new_join_info),\n+        std::move(new_expression_actions),\n+        required_output_columns,\n+        use_nulls,\n+        join_settings,\n+        sorting_settings);\n+    result_step->setStepDescription(getStepDescription());\n+    return result_step;\n+}\n+\n void registerJoinStep(QueryPlanStepRegistry & registry)\n {\n     registry.registerStep(\"Join\", JoinStepLogical::deserialize);\ndiff --git a/src/Processors/QueryPlan/JoinStepLogical.h b/src/Processors/QueryPlan/JoinStepLogical.h\nindex 1396fa7a2aeb..e71d6e8c3ae1 100644\n--- a/src/Processors/QueryPlan/JoinStepLogical.h\n+++ b/src/Processors/QueryPlan/JoinStepLogical.h\n@@ -109,6 +109,9 @@ class JoinStepLogical final : public IQueryPlanStep\n \n     static std::unique_ptr<IQueryPlanStep> deserialize(Deserialization & ctx);\n \n+    QueryPlanStepPtr clone() const override;\n+    bool hasCorrelatedExpressions() const override { return expression_actions.hasCorrelatedExpressions(); }\n+\n protected:\n     void updateOutputHeader() override;\n \ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\nindex ed41b8eb10ca..d21a4c28c18e 100644\n--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n@@ -1,3 +1,4 @@\n+#include <memory>\n #include <Processors/QueryPlan/ReadFromSystemNumbersStep.h>\n \n #include <Core/ColumnWithTypeAndName.h>\n@@ -463,6 +464,11 @@ void ReadFromSystemNumbersStep::initializePipeline(QueryPipelineBuilder & pipeli\n     pipeline.init(std::move(pipe));\n }\n \n+QueryPlanStepPtr ReadFromSystemNumbersStep::clone() const\n+{\n+    return std::make_unique<ReadFromSystemNumbersStep>(column_names, getQueryInfo(), getStorageSnapshot(), getContext(), storage, max_block_size, num_streams);\n+}\n+\n Pipe ReadFromSystemNumbersStep::makePipe()\n {\n     auto & numbers_storage = storage->as<StorageSystemNumbers &>();\ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\nindex 0177b874c931..07417cbacd52 100644\n--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.h\n@@ -28,6 +28,8 @@ class ReadFromSystemNumbersStep final : public SourceStepWithFilter\n \n     void initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &) override;\n \n+    QueryPlanStepPtr clone() const override;\n+\n private:\n     /// Fail fast if estimated number of rows to read exceeds the limit\n     void checkLimits(size_t rows);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03411_analyzer_scalar_correlated_subquery.reference b/tests/queries/0_stateless/03411_analyzer_scalar_correlated_subquery.reference\nnew file mode 100644\nindex 000000000000..ec4565a687cc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03411_analyzer_scalar_correlated_subquery.reference\n@@ -0,0 +1,35 @@\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    number UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      COLUMN id: 2, column_name: number, result_type: UInt64, source_id: 3\n+  JOIN TREE\n+    TABLE_FUNCTION id: 3, alias: __table1, table_function_name: numbers\n+      ARGUMENTS\n+        LIST id: 4, nodes: 1\n+          CONSTANT id: 5, constant_value: UInt64_2, constant_value_type: UInt8\n+  WHERE\n+    FUNCTION id: 6, function_name: equals, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 7, nodes: 2\n+          QUERY id: 8, alias: __table2, is_subquery: 1, is_correlated: 1\n+            CORRELATED COLUMNS\n+              LIST id: 9, nodes: 1\n+                COLUMN id: 10, column_name: number, result_type: UInt64, source_id: 3\n+            PROJECTION COLUMNS\n+              count() UInt64\n+            PROJECTION\n+              LIST id: 11, nodes: 1\n+                FUNCTION id: 12, function_name: count, function_type: aggregate, result_type: UInt64\n+            JOIN TREE\n+              TABLE id: 13, alias: __table3, table_name: system.one\n+            WHERE\n+              FUNCTION id: 14, function_name: equals, function_type: ordinary, result_type: UInt8\n+                ARGUMENTS\n+                  LIST id: 15, nodes: 2\n+                    COLUMN id: 10, column_name: number, result_type: UInt64, source_id: 3\n+                    CONSTANT id: 16, constant_value: UInt64_2, constant_value_type: UInt8\n+          CONSTANT id: 17, constant_value: UInt64_0, constant_value_type: UInt8\n+0\n+1\ndiff --git a/tests/queries/0_stateless/03411_analyzer_scalar_correlated_subquery.sql b/tests/queries/0_stateless/03411_analyzer_scalar_correlated_subquery.sql\nnew file mode 100644\nindex 000000000000..a4efc07412c0\n--- /dev/null\n+++ b/tests/queries/0_stateless/03411_analyzer_scalar_correlated_subquery.sql\n@@ -0,0 +1,11 @@\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+\n+EXPLAIN QUERY TREE\n+SELECT *\n+FROM numbers(2)\n+WHERE (SELECT count() FROM system.one WHERE number = 2) = 0;\n+\n+SELECT *\n+FROM numbers(2)\n+WHERE (SELECT count() FROM system.one WHERE number = 2) = 0;\ndiff --git a/tests/queries/0_stateless/03447_analyzer_correlated_subqueries_tpc_h.reference b/tests/queries/0_stateless/03447_analyzer_correlated_subqueries_tpc_h.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03447_analyzer_correlated_subqueries_tpc_h.sql b/tests/queries/0_stateless/03447_analyzer_correlated_subqueries_tpc_h.sql\nnew file mode 100644\nindex 000000000000..36c100d581f6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03447_analyzer_correlated_subqueries_tpc_h.sql\n@@ -0,0 +1,314 @@\n+CREATE TABLE nation (\n+    n_nationkey  Int32,\n+    n_name       String,\n+    n_regionkey  Int32,\n+    n_comment    String)\n+ORDER BY (n_nationkey);\n+\n+CREATE TABLE region (\n+    r_regionkey  Int32,\n+    r_name       String,\n+    r_comment    String)\n+ORDER BY (r_regionkey);\n+\n+CREATE TABLE part (\n+    p_partkey     Int32,\n+    p_name        String,\n+    p_mfgr        String,\n+    p_brand       String,\n+    p_type        String,\n+    p_size        Int32,\n+    p_container   String,\n+    p_retailprice Decimal(15,2),\n+    p_comment     String)\n+ORDER BY (p_partkey);\n+\n+CREATE TABLE supplier (\n+    s_suppkey     Int32,\n+    s_name        String,\n+    s_address     String,\n+    s_nationkey   Int32,\n+    s_phone       String,\n+    s_acctbal     Decimal(15,2),\n+    s_comment     String)\n+ORDER BY (s_suppkey);\n+\n+CREATE TABLE partsupp (\n+    ps_partkey     Int32,\n+    ps_suppkey     Int32,\n+    ps_availqty    Int32,\n+    ps_supplycost  Decimal(15,2),\n+    ps_comment     String)\n+ORDER BY (ps_partkey, ps_suppkey);\n+\n+CREATE TABLE customer (\n+    c_custkey     Int32,\n+    c_name        String,\n+    c_address     String,\n+    c_nationkey   Int32,\n+    c_phone       String,\n+    c_acctbal     Decimal(15,2),\n+    c_mktsegment  String,\n+    c_comment     String)\n+ORDER BY (c_custkey);\n+\n+CREATE TABLE orders  (\n+    o_orderkey       Int32,\n+    o_custkey        Int32,\n+    o_orderstatus    String,\n+    o_totalprice     Decimal(15,2),\n+    o_orderdate      Date,\n+    o_orderpriority  String,\n+    o_clerk          String,\n+    o_shippriority   Int32,\n+    o_comment        String)\n+ORDER BY (o_orderkey);\n+-- The following is an alternative order key which is not compliant with the official TPC-H rules but recommended by sec. 4.5 in\n+-- \"Quantifying TPC-H Choke Points and Their Optimizations\":\n+-- ORDER BY (o_orderdate, o_orderkey);\n+\n+CREATE TABLE lineitem (\n+    l_orderkey       Int32,\n+    l_partkey        Int32,\n+    l_suppkey        Int32,\n+    l_linenumber     Int32,\n+    l_quantity       Decimal(15,2),\n+    l_extendedprice  Decimal(15,2),\n+    l_discount       Decimal(15,2),\n+    l_tax            Decimal(15,2),\n+    l_returnflag     String,\n+    l_linestatus     String,\n+    l_shipdate       Date,\n+    l_commitdate     Date,\n+    l_receiptdate    Date,\n+    l_shipinstruct   String,\n+    l_shipmode       String,\n+    l_comment        String)\n+ORDER BY (l_orderkey, l_linenumber);\n+-- The following is an alternative order key which is not compliant with the official TPC-H rules but recommended by sec. 4.5 in\n+-- \"Quantifying TPC-H Choke Points and Their Optimizations\":\n+-- ORDER BY (l_shipdate, l_orderkey, l_linenumber);\n+\n+INSERT INTO nation SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO region SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO part SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO supplier SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO partsupp SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO customer SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO orders SELECT * FROM generateRandom() LIMIT 1;\n+INSERT INTO lineitem SELECT * FROM generateRandom() LIMIT 1;\n+\n+set enable_analyzer = 1;\n+set allow_experimental_correlated_subqueries = 1;\n+SET enable_parallel_replicas = 0;\n+\n+-- Q2\n+SELECT\n+    s_acctbal,\n+    s_name,\n+    n_name,\n+    p_partkey,\n+    p_mfgr,\n+    s_address,\n+    s_phone,\n+    s_comment\n+FROM\n+    part,\n+    supplier,\n+    partsupp,\n+    nation,\n+    region\n+WHERE\n+    p_partkey = ps_partkey\n+    AND s_suppkey = ps_suppkey\n+    AND p_size = 15\n+    AND p_type LIKE '%BRASS'\n+    AND s_nationkey = n_nationkey\n+    AND n_regionkey = r_regionkey\n+    AND r_name = 'EUROPE'\n+    AND ps_supplycost = (\n+        SELECT\n+            min(ps_supplycost)\n+        FROM\n+            partsupp,\n+            supplier,\n+            nation,\n+            region\n+        WHERE\n+            p_partkey = ps_partkey\n+            AND s_suppkey = ps_suppkey\n+            AND s_nationkey = n_nationkey\n+            AND n_regionkey = r_regionkey\n+            AND r_name = 'EUROPE'\n+    )\n+ORDER BY\n+    s_acctbal DESC,\n+    n_name,\n+    s_name,\n+    p_partkey\n+FORMAT Null;\n+\n+-- Q4\n+SELECT\n+    o_orderpriority,\n+    count(*) AS order_count\n+FROM\n+    orders\n+WHERE\n+    o_orderdate >= DATE '1993-07-01'\n+    AND o_orderdate < DATE '1993-07-01' + INTERVAL '3' MONTH\n+    AND EXISTS (\n+        SELECT\n+            *\n+        FROM\n+            lineitem\n+        WHERE\n+            l_orderkey = o_orderkey\n+            AND l_commitdate < l_receiptdate\n+    )\n+GROUP BY\n+    o_orderpriority\n+ORDER BY\n+    o_orderpriority\n+FORMAT Null;\n+\n+-- Q17\n+SELECT\n+    sum(l_extendedprice) / 7.0 AS avg_yearly\n+FROM\n+    lineitem,\n+    part\n+WHERE\n+    p_partkey = l_partkey\n+    AND p_brand = 'Brand#23'\n+    AND p_container = 'MED BOX'\n+    AND l_quantity < (\n+        SELECT\n+            0.2 * avg(l_quantity)\n+        FROM\n+            lineitem\n+        WHERE\n+            l_partkey = p_partkey\n+    )\n+FORMAT Null;\n+\n+-- Q20\n+SELECT\n+    s_name,\n+    s_address\n+FROM\n+    supplier,\n+    nation\n+WHERE\n+    s_suppkey in (\n+        SELECT\n+            ps_suppkey\n+        FROM\n+            partsupp\n+        WHERE\n+            ps_partkey in (\n+                SELECT\n+                    p_partkey\n+                FROM\n+                    part\n+                WHERE\n+                    p_name LIKE 'forest%'\n+            )\n+            AND ps_availqty > (\n+                SELECT\n+                    0.5 * sum(l_quantity)\n+                FROM\n+                    lineitem\n+                WHERE\n+                    l_partkey = ps_partkey\n+                    AND l_suppkey = ps_suppkey\n+                    AND l_shipdate >= DATE '1994-01-01'\n+                    AND l_shipdate < DATE '1994-01-01' + INTERVAL '1' year\n+            )\n+    )\n+    AND s_nationkey = n_nationkey\n+    AND n_name = 'CANADA'\n+ORDER BY\n+    s_name\n+FORMAT Null;\n+\n+-- Q21\n+SELECT\n+    s_name,\n+    count(*) AS numwait\n+FROM\n+    supplier,\n+    lineitem l1,\n+    orders,\n+    nation\n+WHERE\n+    s_suppkey = l1.l_suppkey\n+    AND o_orderkey = l1.l_orderkey\n+    AND o_orderstatus = 'F'\n+    AND l1.l_receiptdate > l1.l_commitdate\n+    AND EXISTS (\n+        SELECT\n+            *\n+        FROM\n+            lineitem l2\n+        WHERE\n+            l2.l_orderkey = l1.l_orderkey\n+            AND l2.l_suppkey <> l1.l_suppkey\n+    )\n+    AND NOT EXISTS (\n+        SELECT\n+            *\n+        FROM\n+            lineitem l3\n+        WHERE\n+            l3.l_orderkey = l1.l_orderkey\n+            AND l3.l_suppkey <> l1.l_suppkey\n+            AND l3.l_receiptdate > l3.l_commitdate\n+    )\n+    AND s_nationkey = n_nationkey\n+    AND n_name = 'SAUDI ARABIA'\n+GROUP BY\n+    s_name\n+ORDER BY\n+    numwait DESC,\n+    s_name\n+FORMAT Null;\n+\n+-- Q22\n+SELECT\n+    cntrycode,\n+    count(*) AS numcust,\n+    sum(c_acctbal) AS totacctbal\n+FROM (\n+    SELECT\n+        substring(c_phone FROM 1 for 2) AS cntrycode,\n+        c_acctbal\n+    FROM\n+        customer\n+    WHERE\n+        substring(c_phone FROM 1 for 2) in\n+            ('13', '31', '23', '29', '30', '18', '17')\n+        AND c_acctbal > (\n+            SELECT\n+                avg(c_acctbal)\n+            FROM\n+                customer\n+            WHERE\n+                c_acctbal > 0.00\n+                AND substring(c_phone FROM 1 for 2) in\n+                    ('13', '31', '23', '29', '30', '18', '17')\n+        )\n+        AND NOT EXISTS (\n+            SELECT\n+                *\n+            FROM\n+                orders\n+            WHERE\n+                o_custkey = c_custkey\n+        )\n+    ) AS custsale\n+GROUP BY\n+    cntrycode\n+ORDER BY\n+    cntrycode\n+FORMAT Null;\n",
  "problem_statement": "Correlated subqueries\nI want use the follow sql query, but it does work, in MySQL it is ok.\n\n```sql\nSELECT \n(SELECT A1.QTY_SOLD  FROM V_LB_DC_ITEM_CUST_MONTH A1 WHERE A1.CUST_ID=A.CUST_ID LIMIT 1) AS TQ_QTY_SOLD,\nA.QTY_SOLD\nFROM V_LB_DC_ITEM_CUST_MONTH A\n```\n\nSee https://materialize.com/blog/?search=Technical+Article how to implement correlated subqueries.\n\n![image](https://user-images.githubusercontent.com/3055810/63832906-589cc780-c9a4-11e9-9c89-d354c1435b3c.png)\n\n",
  "hints_text": "Correlated subqueries are not supported, and currently no schedule for implementing that.\r\n\r\nYou can rewrite your query using JOIN. \r\n\r\nP.S. We still have no issue to track requests for that feature. Let's use this one.\n> Correlated subqueries are not supported, and currently no schedule for implementing that.\r\n> \r\n> You can rewrite your query using JOIN.\r\n> \r\n> P.S. We still have no issue to track requests for that feature. Let's use this one.\r\n\r\nEager to have these functions  \uff0c\r\n\r\n\nSimple samples from #9861\r\n```\r\nSELECT dummy, name\r\nFROM system.one, system.columns\r\nWHERE (SELECT count() FROM system.columns WHERE name != '' AND dummy = 0) > 0\r\nLIMIT 1;\r\n\r\n# fail\r\nSELECT o.dummy, name\r\nFROM system.one o, system.columns\r\nWHERE (SELECT count() FROM system.columns WHERE name != '' AND o.dummy = 0) > 0\r\nLIMIT 1;\r\n```\nNot being able to use depended subqueries is quite limiting for analytics queries.\r\nI am looking to use  WHERE col1 NOT IN (depended subquery). Not everything can be rewritten using JOIN, especially as ClickHouse LEFT JOIN does not support  inequalities in joins: \"JOIN ON inequalities are not supported\"\nHi.\r\nDo you have any plans for this task?\nIt is planned for 2022.\n> Correlated subqueries are not supported, and currently no schedule for implementing that.\r\n> \r\n> You can rewrite your query using JOIN.\r\n> \r\n> P.S. We still have no issue to track requests for that feature. Let's use this one.\r\n\r\nWould you be able to show a solution using JOIN based on @samz406's original query?\nThe same issue occurs with window function as it happened with the subquery.\r\nThe window function works fine as is, but when putting it inside a case clause Im getting the same error.\r\nBTW I checked the solution also in 2 steps with CTE as the window function and put the identifier inside the case and still the same error occurred.\r\nIs there any plan to fix this issue?\n@SharonCastel read this https://github.com/ClickHouse/ClickHouse/issues/19857\nany update on this?\nHello, Any update in which release this feature will be available? \r\nThanks.\n> It is planned for 2022.\n\nAlmost 2023. Is it coming anytime soon?\n@pmdyy This task is not going to be solved in 2022.\r\nThe current schedule is 2023.\nAny updates on this? Thanks.\nis there any progress please\r\n\nNo updates.\nIs there any news?\nNo updates so far.\n@vdimir, this is one of the issues we discussed at the Amsterdam Meetup. Thanks for help!\n@yusufozturk, thank you for pointing that out!\r\n\r\nI see that this feature is not currently supported in both the old and new analyzers (`allow_experimental_analyzer = 1`). \r\n\r\nIt's a fundamental feature and will require some development effort. However, given its relevance to SQL compatibility, we are encouraged to implement it.\r\n\r\nI've discussed this with @KochetovNicolai and @kitaisreal, and we have decided to start working on it after the new analyzer is ready (tracking issue: https://github.com/ClickHouse/ClickHouse/issues/42648).\r\n\r\nThere are a few possible approaches we can take:\r\n1. Implement it only for limited cases where we can rewrite the query without a correlated subquery (explicit JOIN).\r\n2. Initially, implement a straightforward way that executes the subquery for each row. It may be slower, but it will at least work for small datasets. Then, on top of that, we can start implementing optimizations for specific cases.\r\n\r\nSo, we are pursuing this feature, but it's important to note that it won't be a quick task to complete.\n@vdimir - Is this feature done ?\n@ganesh-ncompass, no, and there is no support for correlated subqueries in ClickHouse as of 2024-07-10.\n@alexey-milovidov @vdimir \r\n\r\nBelow is my query. Which isn't right. \r\nthe input_dates has all list of dates against a scheme_code. now i want to get date and respective nav value from nav_details table if that date is present else return most recent previous date's nav.\r\n\r\nSo I wanted help in performing this using join queries. I tried all possible joins. need solution or some help please.\r\n\r\n> dates_query = f'''\r\n> WITH input_dates AS (\r\n>         SELECT \r\n>             arrayJoin(\r\n>                 arrayMap(\r\n>                     x -> addMonths(start_date, x * {frequency}), \r\n>                     range(toInt32((toRelativeMonthNum(toDate('{end_date}')) - toRelativeMonthNum(toDate(start_date))) / {frequency}) + 1)\r\n>                 )\r\n>             ) AS date,\r\n>             scheme_code\r\n>         FROM\r\n>         (\r\n>             SELECT\r\n>                 scheme_code,\r\n>                 max(date) AS prev_date,\r\n>                 argMax(nav, date) AS prev_nav,\r\n>                 toDate('{start_date}') as start_date\r\n>             FROM\r\n>                 nav_details_temp\r\n>             WHERE\r\n>                 date < '{start_date}' \r\n>                 AND scheme_code IN {amfi_scheme_codes}\r\n>             GROUP BY\r\n>                 scheme_code\r\n>         ) subquery\r\n> )   \r\n> SELECT \r\n>     scheme_code,\r\n>     date,\r\n>     nav\r\n> FROM \r\n>     nav_detsils\r\n> WHERE\r\n>     date <= input_dates.date and scheme_code = input_dates.scheme_code\r\n> '''\r\n\nAlso when is the plan to complete this feature, as its already 2024? @alexey-milovidov \nYes, it is included in the roadmap 2024: https://github.com/ClickHouse/ClickHouse/issues/58392\n2024 is over soon, new analyzer is done, any updates here? Please also consider lateral join support.",
  "created_at": "2025-04-25T17:34:32Z"
}