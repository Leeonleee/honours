{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 1763,
  "instance_id": "ClickHouse__ClickHouse-1763",
  "issue_numbers": [
    "320"
  ],
  "base_commit": "c430af5fb8f93558c0af0a37c739faf0493d7032",
  "patch": "diff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\nindex c59d6e3981a6..1f7615610565 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -157,11 +157,11 @@ ExpressionAnalyzer::ExpressionAnalyzer(\n     const StoragePtr & storage_,\n     const NamesAndTypesList & columns_,\n     size_t subquery_depth_,\n-    bool do_global_)\n+    bool do_global_, SubqueriesForSets subquery_for_set_)\n     : ast(ast_), context(context_), settings(context.getSettings()),\n     subquery_depth(subquery_depth_), columns(columns_),\n     storage(storage_ ? storage_ : getTable()),\n-    do_global(do_global_)\n+    do_global(do_global_), subqueries_for_sets(subquery_for_set_)\n {\n     init();\n }\ndiff --git a/dbms/src/Interpreters/ExpressionAnalyzer.h b/dbms/src/Interpreters/ExpressionAnalyzer.h\nindex cda458513cc1..cc8bf10418af 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.h\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.h\n@@ -72,7 +72,7 @@ class ExpressionAnalyzer : private boost::noncopyable\n         const StoragePtr & storage_,\n         const NamesAndTypesList & columns_,\n         size_t subquery_depth_ = 0,\n-        bool do_global_ = false);\n+        bool do_global_ = false, SubqueriesForSets subquery_for_set_ = {});\n \n     /// Does the expression have aggregate functions or a GROUP BY or HAVING section.\n     bool hasAggregation() const { return has_aggregation; }\n@@ -166,6 +166,9 @@ class ExpressionAnalyzer : private boost::noncopyable\n     NamesAndTypesList aggregation_keys;\n     AggregateDescriptions aggregate_descriptions;\n \n+    /// Do I need to prepare for execution global subqueries when analyzing the query.\n+    bool do_global;\n+\n     SubqueriesForSets subqueries_for_sets;\n \n     PreparedSets prepared_sets;\n@@ -201,14 +204,11 @@ class ExpressionAnalyzer : private boost::noncopyable\n     /// The backward mapping for array_join_alias_to_name.\n     NameToNameMap array_join_name_to_alias;\n \n-    /// Do I need to prepare for execution global subqueries when analyzing the query.\n-    bool do_global;\n \n     /// All new temporary tables obtained by performing the GLOBAL IN/JOIN subqueries.\n     Tables external_tables;\n     size_t external_table_id = 1;\n \n-\n     void init();\n \n     static NamesAndTypesList::iterator findColumn(const String & name, NamesAndTypesList & cols);\ndiff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\nindex 377967bdd2bf..284937ce6778 100644\n--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -95,7 +95,8 @@ void InterpreterSelectQuery::init(const BlockInputStreamPtr & input, const Names\n             ASTSelectQuery & head_query = static_cast<ASTSelectQuery &>(*head);\n             tail = head_query.next_union_all;\n \n-            interpreter->next_select_in_union_all = std::make_unique<InterpreterSelectQuery>(head, context, to_stage, subquery_depth);\n+            interpreter->next_select_in_union_all =\n+                std::make_unique<InterpreterSelectQuery>(head, context, to_stage, subquery_depth);\n             interpreter = interpreter->next_select_in_union_all.get();\n         }\n     }\n@@ -119,9 +120,17 @@ void InterpreterSelectQuery::init(const BlockInputStreamPtr & input, const Names\n     else\n     {\n         renameColumns();\n-        if (!required_column_names.empty())\n+        if (!required_column_names.empty()) {\n             rewriteExpressionList(required_column_names);\n \n+            if (is_first_select_inside_union_all) {\n+                for (auto p = next_select_in_union_all.get(); p != nullptr; p = p->next_select_in_union_all.get())\n+                    p->query_analyzer.reset(new ExpressionAnalyzer(\n+                        p->query_ptr, p->context, p->storage, p->table_column_names, p->subquery_depth,\n+                        false, p->query_analyzer->getSubqueriesForSets()));\n+            }\n+        }\n+\n         basicInit(input);\n     }\n }\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.reference b/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.reference\nnew file mode 100644\nindex 000000000000..947b7be99aa6\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.reference\n@@ -0,0 +1,4 @@\n+test_string\t2\n+test_string\t2\n+test_string\n+test_string\ndiff --git a/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.sql b/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.sql\nnew file mode 100644\nindex 000000000000..3527ddb3c410\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.sql\n@@ -0,0 +1,10 @@\n+DROP TABLE IF EXISTS test.test;\n+\n+CREATE TABLE test.test ( s String,  i Int64) ENGINE = Memory;\n+\n+INSERT INTO test.test VALUES('test_string', 1);\n+\n+SELECT s, SUM(i*2) AS i FROM test.test GROUP BY s  UNION ALL  SELECT s, SUM(i*2) AS i FROM test.test GROUP BY s;\n+SELECT s FROM (SELECT s, SUM(i*2) AS i FROM test.test GROUP BY s  UNION ALL  SELECT s, SUM(i*2) AS i FROM test.test GROUP BY s);\n+\n+DROP TABLE IF EXISTS test.test;\n",
  "problem_statement": "Cannot select column from view\nAfter create this view:\r\n\r\n```\r\nCREATE TABLE Test (\r\n    createdDate Date,\r\n    str String,\r\n    key Enum8('A' = 0, 'B' = 1, 'ALL' = 2),\r\n    a Int64\r\n)\r\n ENGINE = MergeTree(createdDate, str, 8192);\r\n\r\n\r\nCREATE VIEW TestView AS\r\n    SELECT str, key, sumIf(a, 0) AS sum\r\n    FROM Test\r\n    GROUP BY str, key\r\n    \r\n    UNION ALL\r\n    \r\n    SELECT str AS str, CAST('ALL' AS Enum8('A' = 0, 'B' = 1, 'ALL' = 2)) AS key, sumIf(a, 0) AS sum\r\n    FROM Test\r\n    GROUP BY str\r\n```\r\n\r\nI try to select any column, eg:\r\n\r\n`SELECT str FROM TestView`\r\n\r\nAnd receive this exception:\r\n\r\n```\r\nReceived exception from server:\r\nCode: 47. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: Unknown column: 0, there are only columns str, a. \r\n```\n",
  "hints_text": "It looks like a bug in UNION ALL implementation:\r\n```\r\nCREATE TABLE test ( s String,  i Int64) ENGINE = Memory\r\n```\r\n\r\n```\r\nSELECT s FROM (SELECT s, sum(i*2) AS i FROM test GROUP BY s  UNION ALL  SELECT s, sum(i*2) AS i FROM test GROUP BY s)\r\n```\r\nDoesn't work:\r\n```\r\nCode: 47. DB::Exception: Received from localhost:9000, ::1. DB::Exception: Unknown column: multiply(i, 2), there are only columns s, i. Stack trace:\r\n```\r\n\r\nBut the following variants work:\r\n```\r\nSELECT s, i FROM (SELECT s, sum(i*2) AS i FROM test GROUP BY s  UNION ALL  SELECT s, sum(i*2) AS i FROM test GROUP BY s)\r\nSELECT *    FROM (SELECT s, sum(i*2) AS i FROM test GROUP BY s  UNION ALL  SELECT s, sum(i*2) AS i FROM test GROUP BY s)\r\nSELECT i    FROM (SELECT s, sum(i*2) AS i FROM test GROUP BY s  UNION ALL  SELECT s, sum(i) AS i FROM test GROUP BY s)\r\n```\r\n\r\n",
  "created_at": "2018-01-14T17:29:47Z",
  "modified_files": [
    "dbms/src/Interpreters/ExpressionAnalyzer.cpp",
    "dbms/src/Interpreters/ExpressionAnalyzer.h",
    "dbms/src/Interpreters/InterpreterSelectQuery.cpp"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.reference",
    "b/dbms/tests/queries/0_stateless/00562_rewrite_select_expression_with_union.sql"
  ]
}