{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 31488,
  "instance_id": "ClickHouse__ClickHouse-31488",
  "issue_numbers": [
    "31471"
  ],
  "base_commit": "ef6079633dc5237b6affbee87553b961e4b39ef1",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionFactory.cpp b/src/AggregateFunctions/AggregateFunctionFactory.cpp\nindex 4c2c64ef5e19..eac761c1a827 100644\n--- a/src/AggregateFunctions/AggregateFunctionFactory.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionFactory.cpp\n@@ -178,6 +178,12 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(\n         /// uniqCombinedIfMergeIf is useful in cases when the underlying\n         /// storage stores AggregateFunction(uniqCombinedIf) and in SELECT you\n         /// need to filter aggregation result based on another column.\n+\n+#if defined(UNBUNDLED)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wstringop-overread\"\n+#endif\n+\n         if (!combinator->supportsNesting() && nested_name.ends_with(combinator_name))\n         {\n             throw Exception(ErrorCodes::ILLEGAL_AGGREGATION,\n@@ -185,6 +191,10 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(\n                 combinator_name);\n         }\n \n+#if defined(UNBUNDLED)\n+#pragma GCC diagnostic pop\n+#endif\n+\n         DataTypes nested_types = combinator->transformArguments(argument_types);\n         Array nested_parameters = combinator->transformParameters(parameters);\n \ndiff --git a/src/Common/Macros.cpp b/src/Common/Macros.cpp\nindex 339f3f43fc41..f66e3462e825 100644\n--- a/src/Common/Macros.cpp\n+++ b/src/Common/Macros.cpp\n@@ -106,6 +106,16 @@ String Macros::expand(const String & s,\n             res += toString(info.table_id.uuid);\n             info.expanded_uuid = true;\n         }\n+        else if (info.shard && macro_name == \"shard\")\n+        {\n+            res += *info.shard;\n+            info.expanded_uuid = true;\n+        }\n+        else if (info.replica && macro_name == \"replica\")\n+        {\n+            res += *info.replica;\n+            info.expanded_uuid = true;\n+        }\n         else if (info.ignore_unknown || info.expand_special_macros_only)\n         {\n             if (info.expand_special_macros_only)\ndiff --git a/src/Common/Macros.h b/src/Common/Macros.h\nindex 3e6fbff1519f..dea3a3851f01 100644\n--- a/src/Common/Macros.h\n+++ b/src/Common/Macros.h\n@@ -34,6 +34,8 @@ class Macros\n         StorageID table_id = StorageID::createEmpty();\n         bool ignore_unknown = false;\n         bool expand_special_macros_only = false;\n+        std::optional<String> shard;\n+        std::optional<String> replica;\n \n         /// Information about macro expansion\n         size_t level = 0;\ndiff --git a/src/Databases/DatabaseFactory.cpp b/src/Databases/DatabaseFactory.cpp\nindex 264807534b39..e5fdff97c86e 100644\n--- a/src/Databases/DatabaseFactory.cpp\n+++ b/src/Databases/DatabaseFactory.cpp\n@@ -8,6 +8,7 @@\n #include <Databases/DatabaseOrdinary.h>\n #include <Databases/DatabaseReplicated.h>\n #include <Interpreters/Context.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n #include <Parsers/ASTCreateQuery.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTIdentifier.h>\n@@ -30,7 +31,6 @@\n \n #if USE_MYSQL || USE_LIBPQXX\n #include <Common/parseRemoteDescription.h>\n-#include <Interpreters/evaluateConstantExpression.h>\n #include <Common/parseAddress.h>\n #endif\n \n@@ -258,7 +258,9 @@ DatabasePtr DatabaseFactory::getImpl(const ASTCreateQuery & create, const String\n         if (!engine->arguments || engine->arguments->children.size() != 3)\n             throw Exception(\"Replicated database requires 3 arguments: zookeeper path, shard name and replica name\", ErrorCodes::BAD_ARGUMENTS);\n \n-        const auto & arguments = engine->arguments->children;\n+        auto & arguments = engine->arguments->children;\n+        for (auto & engine_arg : arguments)\n+            engine_arg = evaluateConstantExpressionOrIdentifierAsLiteral(engine_arg, context);\n \n         String zookeeper_path = safeGetLiteralValue<String>(arguments[0], \"Replicated\");\n         String shard_name = safeGetLiteralValue<String>(arguments[1], \"Replicated\");\ndiff --git a/src/Databases/DatabaseReplicated.h b/src/Databases/DatabaseReplicated.h\nindex cc25b2128fbf..fcb8a2c4d330 100644\n--- a/src/Databases/DatabaseReplicated.h\n+++ b/src/Databases/DatabaseReplicated.h\n@@ -50,6 +50,8 @@ class DatabaseReplicated : public DatabaseAtomic\n \n     void stopReplication() override;\n \n+    String getShardName() const { return shard_name; }\n+    String getReplicaName() const { return replica_name; }\n     String getFullReplicaName() const;\n     static std::pair<String, String> parseFullReplicaName(const String & name);\n \ndiff --git a/src/Databases/DatabaseReplicatedHelpers.cpp b/src/Databases/DatabaseReplicatedHelpers.cpp\nnew file mode 100644\nindex 000000000000..26090547e2cd\n--- /dev/null\n+++ b/src/Databases/DatabaseReplicatedHelpers.cpp\n@@ -0,0 +1,17 @@\n+#include <Databases/DatabaseReplicatedHelpers.h>\n+#include <Databases/DatabaseReplicated.h>\n+\n+namespace DB\n+{\n+\n+String getReplicatedDatabaseShardName(const DatabasePtr & database)\n+{\n+    return assert_cast<const DatabaseReplicated *>(database.get())->getShardName();\n+}\n+\n+String getReplicatedDatabaseReplicaName(const DatabasePtr & database)\n+{\n+    return assert_cast<const DatabaseReplicated *>(database.get())->getReplicaName();\n+}\n+\n+}\ndiff --git a/src/Databases/DatabaseReplicatedHelpers.h b/src/Databases/DatabaseReplicatedHelpers.h\nnew file mode 100644\nindex 000000000000..ee9077e213ca\n--- /dev/null\n+++ b/src/Databases/DatabaseReplicatedHelpers.h\n@@ -0,0 +1,14 @@\n+#pragma once\n+#include <Core/Types.h>\n+#include <memory>\n+\n+namespace DB\n+{\n+\n+class IDatabase;\n+using DatabasePtr = std::shared_ptr<IDatabase>;\n+\n+String getReplicatedDatabaseShardName(const DatabasePtr & database);\n+String getReplicatedDatabaseReplicaName(const DatabasePtr & database);\n+\n+}\ndiff --git a/src/Databases/TablesLoader.cpp b/src/Databases/TablesLoader.cpp\nindex 31581a97fcc0..b8c380b7be19 100644\n--- a/src/Databases/TablesLoader.cpp\n+++ b/src/Databases/TablesLoader.cpp\n@@ -36,8 +36,19 @@ void mergeDependenciesGraphs(DependenciesInfos & main_dependencies_info, const D\n             if (maybe_existing_info.dependencies.empty())\n                 maybe_existing_info.dependencies = dependencies;\n             else if (maybe_existing_info.dependencies != dependencies)\n-                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Have different dependencies for {}: {} and {}, it's a bug\",\n-                                table, fmt::join(maybe_existing_info.dependencies, \", \"), fmt::join(dependencies, \", \"));\n+            {\n+                /// Can happen on DatabaseReplicated recovery\n+                LOG_WARNING(&Poco::Logger::get(\"TablesLoader\"), \"Replacing outdated dependencies ({}) of {} with: {}\",\n+                            fmt::join(maybe_existing_info.dependencies, \", \"),\n+                            table,\n+                            fmt::join(dependencies, \", \"));\n+                for (const auto & old_dependency : maybe_existing_info.dependencies)\n+                {\n+                    [[maybe_unused]] bool removed = main_dependencies_info[old_dependency].dependent_database_objects.erase(table);\n+                    assert(removed);\n+                }\n+                maybe_existing_info.dependencies = dependencies;\n+            }\n         }\n     }\n }\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex e2f0fc761b1e..cb52c8b86c0a 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -22,6 +22,7 @@\n #include <Interpreters/Context.h>\n #include <Interpreters/evaluateConstantExpression.h>\n \n+#include <Databases/DatabaseReplicatedHelpers.h>\n \n namespace DB\n {\n@@ -541,6 +542,12 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         /// to make possible copying metadata files between replicas.\n         Macros::MacroExpansionInfo info;\n         info.table_id = args.table_id;\n+        if (is_replicated_database)\n+        {\n+            auto database = DatabaseCatalog::instance().getDatabase(args.table_id.database_name);\n+            info.shard = getReplicatedDatabaseShardName(database);\n+            info.replica = getReplicatedDatabaseReplicaName(database);\n+        }\n         if (!allow_uuid_macro)\n             info.table_id.uuid = UUIDHelpers::Nil;\n         zookeeper_path = args.getContext()->getMacros()->expand(zookeeper_path, info);\n",
  "test_patch": "diff --git a/tests/integration/test_replicated_database/test.py b/tests/integration/test_replicated_database/test.py\nindex b688e650a8c8..171ae24b98de 100644\n--- a/tests/integration/test_replicated_database/test.py\n+++ b/tests/integration/test_replicated_database/test.py\n@@ -16,7 +16,7 @@\n dummy_node = cluster.add_instance('dummy_node', main_configs=['configs/config.xml'], user_configs=['configs/settings.xml'], with_zookeeper=True, stay_alive=True, macros={\"shard\": 1, \"replica\": 2})\n competing_node = cluster.add_instance('competing_node', main_configs=['configs/config.xml'], user_configs=['configs/settings.xml'], with_zookeeper=True, macros={\"shard\": 1, \"replica\": 3})\n snapshotting_node = cluster.add_instance('snapshotting_node', main_configs=['configs/config.xml'], user_configs=['configs/settings.xml'], with_zookeeper=True, macros={\"shard\": 2, \"replica\": 1})\n-snapshot_recovering_node = cluster.add_instance('snapshot_recovering_node', main_configs=['configs/config.xml'], user_configs=['configs/settings.xml'], with_zookeeper=True, macros={\"shard\": 2, \"replica\": 2})\n+snapshot_recovering_node = cluster.add_instance('snapshot_recovering_node', main_configs=['configs/config.xml'], user_configs=['configs/settings.xml'], with_zookeeper=True)\n \n all_nodes = [main_node, dummy_node, competing_node, snapshotting_node, snapshot_recovering_node]\n \n@@ -37,7 +37,7 @@ def started_cluster():\n         cluster.shutdown()\n \n def test_create_replicated_table(started_cluster):\n-    main_node.query(\"CREATE DATABASE testdb ENGINE = Replicated('/clickhouse/databases/test1', 'shard1', 'replica1');\")\n+    main_node.query(\"CREATE DATABASE testdb ENGINE = Replicated('/clickhouse/databases/test1', 'shard1', 'replica' || '1');\")\n     dummy_node.query(\"CREATE DATABASE testdb ENGINE = Replicated('/clickhouse/databases/test1', 'shard1', 'replica2');\")\n     assert \"Explicit zookeeper_path and replica_name are specified\" in \\\n            main_node.query_and_get_error(\"CREATE TABLE testdb.replicated_table (d Date, k UInt64, i32 Int32) \"\n",
  "problem_statement": "Pass shard and replica from DatabaseReplicated to create table\n**Describe the issue**\r\nWe have to set macro or to pass explicitly shard and replica name to create table in DatabaseReplicated\r\n\n",
  "hints_text": "",
  "created_at": "2021-11-17T19:58:07Z"
}