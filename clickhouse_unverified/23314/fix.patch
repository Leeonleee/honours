diff --git a/src/AggregateFunctions/QuantileTDigest.h b/src/AggregateFunctions/QuantileTDigest.h
index 490abd5d1342..76d2f608d59b 100644
--- a/src/AggregateFunctions/QuantileTDigest.h
+++ b/src/AggregateFunctions/QuantileTDigest.h
@@ -132,6 +132,7 @@ class QuantileTDigest
         if (unmerged > params.max_unmerged)
             compress();
     }
+
     void compressBrute()
     {
         if (centroids.size() <= params.max_centroids)
@@ -195,14 +196,12 @@ class QuantileTDigest
             BetterFloat l_count = l->count;
             while (r != centroids.end())
             {
-                if (l->mean == r->mean) // Perfect aggregation (fast). We compare l->mean, not l_mean, to avoid identical elements after compress
-                {
-                    l_count += r->count;
-                    l->count = l_count;
-                    ++r;
-                    continue;
-                }
-                // we use quantile which gives us the smallest error
+                /// N.B. Piece of logic which compresses the same singleton centroids into one centroid is removed
+                /// because: 1) singleton centroids are being processed in unusual way in recent version of algorithm
+                /// and such compression would break this logic;
+                /// 2) we shall not compress centroids further than `max_centroids` parameter requires because
+                /// this will lead to uneven compression.
+                /// For more information see: https://arxiv.org/abs/1902.04023
 
                 /// The ratio of the part of the histogram to l, including the half l to the entire histogram. That is, what level quantile in position l.
                 BetterFloat ql = (sum + l_count * 0.5) / count;
@@ -320,16 +319,29 @@ class QuantileTDigest
         Float64 prev_x = 0;
         Count sum = 0;
         Value prev_mean = centroids.front().mean;
+        Count prev_count = centroids.front().count;
 
         for (const auto & c : centroids)
         {
             Float64 current_x = sum + c.count * 0.5;
 
             if (current_x >= x)
-                return interpolate(x, prev_x, prev_mean, current_x, c.mean);
+            {
+                /// Special handling of singletons.
+                Float64 left = prev_x + 0.5 * (prev_count == 1);
+                Float64 right = current_x - 0.5 * (c.count == 1);
+
+                if (x <= left)
+                    return prev_mean;
+                else if (x >= right)
+                    return c.mean;
+                else
+                    return interpolate(x, left, prev_mean, right, c.mean);
+            }
 
             sum += c.count;
             prev_mean = c.mean;
+            prev_count = c.count;
             prev_x = current_x;
         }
 
@@ -364,25 +376,40 @@ class QuantileTDigest
         Float64 prev_x = 0;
         Count sum = 0;
         Value prev_mean = centroids.front().mean;
+        Count prev_count = centroids.front().count;
 
         size_t result_num = 0;
         for (const auto & c : centroids)
         {
             Float64 current_x = sum + c.count * 0.5;
 
-            while (current_x >= x)
+            if (current_x >= x)
             {
-                result[levels_permutation[result_num]] = interpolate(x, prev_x, prev_mean, current_x, c.mean);
+                /// Special handling of singletons.
+                Float64 left = prev_x + 0.5 * (prev_count == 1);
+                Float64 right = current_x - 0.5 * (c.count == 1);
+
+                while (current_x >= x)
+                {
+
+                    if (x <= left)
+                        result[levels_permutation[result_num]] = prev_mean;
+                    else if (x >= right)
+                        result[levels_permutation[result_num]] = c.mean;
+                    else
+                        result[levels_permutation[result_num]] = interpolate(x, left, prev_mean, right, c.mean);
 
-                ++result_num;
-                if (result_num >= size)
-                    return;
+                    ++result_num;
+                    if (result_num >= size)
+                        return;
 
-                x = levels[levels_permutation[result_num]] * count;
+                    x = levels[levels_permutation[result_num]] * count;
+                }
             }
 
             sum += c.count;
             prev_mean = c.mean;
+            prev_count = c.count;
             prev_x = current_x;
         }
 
