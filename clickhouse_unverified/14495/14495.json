{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14495,
  "instance_id": "ClickHouse__ClickHouse-14495",
  "issue_numbers": [
    "14344"
  ],
  "base_commit": "7c20aa2c621e31bcad50d4bc5eb2384d8a6286bd",
  "patch": "diff --git a/src/Columns/ColumnArray.cpp b/src/Columns/ColumnArray.cpp\nindex 58543d6a4dda..e4d17c586ac2 100644\n--- a/src/Columns/ColumnArray.cpp\n+++ b/src/Columns/ColumnArray.cpp\n@@ -781,18 +781,21 @@ void ColumnArray::getPermutation(bool reverse, size_t limit, int nan_direction_h\n \n void ColumnArray::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, Permutation & res, EqualRanges & equal_range) const\n {\n+    if (equal_range.empty())\n+        return;\n+\n     if (limit >= size() || limit >= equal_range.back().second)\n         limit = 0;\n \n-    size_t n = equal_range.size();\n+    size_t number_of_ranges = equal_range.size();\n \n     if (limit)\n-        --n;\n+        --number_of_ranges;\n \n     EqualRanges new_ranges;\n-    for (size_t i = 0; i < n; ++i)\n+    for (size_t i = 0; i < number_of_ranges; ++i)\n     {\n-        const auto& [first, last] = equal_range[i];\n+        const auto & [first, last] = equal_range[i];\n \n         if (reverse)\n             std::sort(res.begin() + first, res.begin() + last, Less<false>(*this, nan_direction_hint));\n@@ -817,7 +820,13 @@ void ColumnArray::updatePermutation(bool reverse, size_t limit, int nan_directio\n \n     if (limit)\n     {\n-        const auto& [first, last] = equal_range.back();\n+        const auto & [first, last] = equal_range.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then we are working inside the interval.\n+\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, Less<false>(*this, nan_direction_hint));\n         else\ndiff --git a/src/Columns/ColumnDecimal.cpp b/src/Columns/ColumnDecimal.cpp\nindex 6b4341a697e2..13c7ea46fbcd 100644\n--- a/src/Columns/ColumnDecimal.cpp\n+++ b/src/Columns/ColumnDecimal.cpp\n@@ -7,6 +7,7 @@\n #include <Core/BigInt.h>\n \n #include <common/unaligned.h>\n+#include <ext/scope_guard.h>\n \n #include <IO/WriteHelpers.h>\n \n@@ -142,25 +143,31 @@ void ColumnDecimal<T>::getPermutation(bool reverse, size_t limit, int , IColumn:\n }\n \n template <typename T>\n-void ColumnDecimal<T>::updatePermutation(bool reverse, size_t limit, int, IColumn::Permutation & res, EqualRanges & equal_range) const\n+void ColumnDecimal<T>::updatePermutation(bool reverse, size_t limit, int, IColumn::Permutation & res, EqualRanges & equal_ranges) const\n {\n-    if (limit >= data.size() || limit >= equal_range.back().second)\n+    if (equal_ranges.empty())\n+        return;\n+\n+    if (limit >= data.size() || limit >= equal_ranges.back().second)\n         limit = 0;\n \n-    size_t n = equal_range.size();\n+    size_t number_of_ranges = equal_ranges.size();\n     if (limit)\n-        --n;\n+        --number_of_ranges;\n \n     EqualRanges new_ranges;\n-    for (size_t i = 0; i < n; ++i)\n+    SCOPE_EXIT({equal_ranges = std::move(new_ranges);});\n+\n+    for (size_t i = 0; i < number_of_ranges; ++i)\n     {\n-        const auto& [first, last] = equal_range[i];\n+        const auto& [first, last] = equal_ranges[i];\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + last, res.begin() + last,\n                 [this](size_t a, size_t b) { return data[a] > data[b]; });\n         else\n             std::partial_sort(res.begin() + first, res.begin() + last, res.begin() + last,\n                 [this](size_t a, size_t b) { return data[a] < data[b]; });\n+\n         auto new_first = first;\n         for (auto j = first + 1; j < last; ++j)\n         {\n@@ -178,13 +185,20 @@ void ColumnDecimal<T>::updatePermutation(bool reverse, size_t limit, int, IColum\n \n     if (limit)\n     {\n-        const auto& [first, last] = equal_range.back();\n+        const auto & [first, last] = equal_ranges.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then we are working inside the interval.\n+\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last,\n                 [this](size_t a, size_t b) { return data[a] > data[b]; });\n         else\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last,\n                 [this](size_t a, size_t b) { return data[a] < data[b]; });\n+\n         auto new_first = first;\n         for (auto j = first + 1; j < limit; ++j)\n         {\n@@ -208,7 +222,6 @@ void ColumnDecimal<T>::updatePermutation(bool reverse, size_t limit, int, IColum\n         if (new_last - new_first > 1)\n             new_ranges.emplace_back(new_first, new_last);\n     }\n-    equal_range = std::move(new_ranges);\n }\n \n template <typename T>\ndiff --git a/src/Columns/ColumnFixedString.cpp b/src/Columns/ColumnFixedString.cpp\nindex 95a477e54cf8..0e44b83791cf 100644\n--- a/src/Columns/ColumnFixedString.cpp\n+++ b/src/Columns/ColumnFixedString.cpp\n@@ -9,6 +9,8 @@\n #include <Common/WeakHash.h>\n #include <Common/HashTable/Hash.h>\n \n+#include <ext/scope_guard.h>\n+\n #include <DataStreams/ColumnGathererStream.h>\n \n #include <IO/WriteHelpers.h>\n@@ -168,24 +170,29 @@ void ColumnFixedString::getPermutation(bool reverse, size_t limit, int /*nan_dir\n     }\n }\n \n-void ColumnFixedString::updatePermutation(bool reverse, size_t limit, int, Permutation & res, EqualRanges & equal_range) const\n+void ColumnFixedString::updatePermutation(bool reverse, size_t limit, int, Permutation & res, EqualRanges & equal_ranges) const\n {\n-    if (limit >= size() || limit >= equal_range.back().second)\n+    if (equal_ranges.empty())\n+        return;\n+\n+    if (limit >= size() || limit >= equal_ranges.back().second)\n         limit = 0;\n \n-    size_t k = equal_range.size();\n+    size_t number_of_ranges = equal_ranges.size();\n     if (limit)\n-        --k;\n+        --number_of_ranges;\n \n     EqualRanges new_ranges;\n+    SCOPE_EXIT({equal_ranges = std::move(new_ranges);});\n \n-    for (size_t i = 0; i < k; ++i)\n+    for (size_t i = 0; i < number_of_ranges; ++i)\n     {\n-        const auto& [first, last] = equal_range[i];\n+        const auto& [first, last] = equal_ranges[i];\n         if (reverse)\n             std::sort(res.begin() + first, res.begin() + last, less<false>(*this));\n         else\n             std::sort(res.begin() + first, res.begin() + last, less<true>(*this));\n+\n         auto new_first = first;\n         for (auto j = first + 1; j < last; ++j)\n         {\n@@ -202,11 +209,18 @@ void ColumnFixedString::updatePermutation(bool reverse, size_t limit, int, Permu\n     }\n     if (limit)\n     {\n-        const auto& [first, last] = equal_range.back();\n+        const auto & [first, last] = equal_ranges.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then we are working inside the interval.\n+\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, less<false>(*this));\n         else\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, less<true>(*this));\n+\n         auto new_first = first;\n         for (auto j = first + 1; j < limit; ++j)\n         {\n@@ -230,7 +244,6 @@ void ColumnFixedString::updatePermutation(bool reverse, size_t limit, int, Permu\n         if (new_last - new_first > 1)\n             new_ranges.emplace_back(new_first, new_last);\n     }\n-    equal_range = std::move(new_ranges);\n }\n \n void ColumnFixedString::insertRangeFrom(const IColumn & src, size_t start, size_t length)\ndiff --git a/src/Columns/ColumnLowCardinality.cpp b/src/Columns/ColumnLowCardinality.cpp\nindex 5c174d57b32b..dd1e2f603991 100644\n--- a/src/Columns/ColumnLowCardinality.cpp\n+++ b/src/Columns/ColumnLowCardinality.cpp\n@@ -6,6 +6,7 @@\n #include <Common/assert_cast.h>\n #include <Common/WeakHash.h>\n \n+#include <ext/scope_guard.h>\n \n namespace DB\n {\n@@ -329,19 +330,24 @@ void ColumnLowCardinality::getPermutation(bool reverse, size_t limit, int nan_di\n     }\n }\n \n-void ColumnLowCardinality::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_range) const\n+void ColumnLowCardinality::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_ranges) const\n {\n-    if (limit >= size() || limit >= equal_range.back().second)\n+    if (equal_ranges.empty())\n+        return;\n+\n+    if (limit >= size() || limit >= equal_ranges.back().second)\n         limit = 0;\n \n-    size_t n = equal_range.size();\n+    size_t number_of_ranges = equal_ranges.size();\n     if (limit)\n-        --n;\n+        --number_of_ranges;\n \n     EqualRanges new_ranges;\n-    for (size_t i = 0; i < n; ++i)\n+    SCOPE_EXIT({equal_ranges = std::move(new_ranges);});\n+\n+    for (size_t i = 0; i < number_of_ranges; ++i)\n     {\n-        const auto& [first, last] = equal_range[i];\n+        const auto& [first, last] = equal_ranges[i];\n         if (reverse)\n             std::sort(res.begin() + first, res.begin() + last, [this, nan_direction_hint](size_t a, size_t b)\n                       {return getDictionary().compareAt(getIndexes().getUInt(a), getIndexes().getUInt(b), getDictionary(), nan_direction_hint) > 0; });\n@@ -366,7 +372,13 @@ void ColumnLowCardinality::updatePermutation(bool reverse, size_t limit, int nan\n \n     if (limit)\n     {\n-        const auto& [first, last] = equal_range.back();\n+        const auto & [first, last] = equal_ranges.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then we are working inside the interval.\n+\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, [this, nan_direction_hint](size_t a, size_t b)\n                               {return getDictionary().compareAt(getIndexes().getUInt(a), getIndexes().getUInt(b), getDictionary(), nan_direction_hint) > 0; });\n@@ -374,6 +386,7 @@ void ColumnLowCardinality::updatePermutation(bool reverse, size_t limit, int nan\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, [this, nan_direction_hint](size_t a, size_t b)\n                               {return getDictionary().compareAt(getIndexes().getUInt(a), getIndexes().getUInt(b), getDictionary(), nan_direction_hint) < 0; });\n         auto new_first = first;\n+\n         for (auto j = first + 1; j < limit; ++j)\n         {\n             if (getDictionary().compareAt(getIndexes().getUInt(new_first), getIndexes().getUInt(j), getDictionary(), nan_direction_hint) != 0)\n@@ -384,6 +397,7 @@ void ColumnLowCardinality::updatePermutation(bool reverse, size_t limit, int nan\n                 new_first = j;\n             }\n         }\n+\n         auto new_last = limit;\n         for (auto j = limit; j < last; ++j)\n         {\n@@ -396,7 +410,6 @@ void ColumnLowCardinality::updatePermutation(bool reverse, size_t limit, int nan\n         if (new_last - new_first > 1)\n             new_ranges.emplace_back(new_first, new_last);\n     }\n-    equal_range = std::move(new_ranges);\n }\n \n std::vector<MutableColumnPtr> ColumnLowCardinality::scatter(ColumnIndex num_columns, const Selector & selector) const\ndiff --git a/src/Columns/ColumnNullable.cpp b/src/Columns/ColumnNullable.cpp\nindex 888410202f0a..bdbc941c1e71 100644\n--- a/src/Columns/ColumnNullable.cpp\n+++ b/src/Columns/ColumnNullable.cpp\n@@ -329,73 +329,113 @@ void ColumnNullable::getPermutation(bool reverse, size_t limit, int null_directi\n     }\n }\n \n-void ColumnNullable::updatePermutation(bool reverse, size_t limit, int null_direction_hint, IColumn::Permutation & res, EqualRanges & equal_range) const\n+void ColumnNullable::updatePermutation(bool reverse, size_t limit, int null_direction_hint, IColumn::Permutation & res, EqualRanges & equal_ranges) const\n {\n-    if (limit >= equal_range.back().second || limit >= size())\n-        limit = 0;\n+    if (equal_ranges.empty())\n+        return;\n+\n+    /// We will sort nested columns into `new_ranges` and call updatePermutation in next columns with `null_ranges`.\n+    EqualRanges new_ranges, null_ranges;\n \n-    EqualRanges new_ranges, temp_ranges;\n+    const auto is_nulls_last = ((null_direction_hint > 0) != reverse);\n \n-    for (const auto &[first, last] : equal_range)\n+    if (is_nulls_last)\n     {\n-        bool direction = ((null_direction_hint > 0) != reverse);\n         /// Shift all NULL values to the end.\n-\n-        size_t read_idx = first;\n-        size_t write_idx = first;\n-        while (read_idx < last && (isNullAt(res[read_idx])^direction))\n+        for (const auto & [first, last] : equal_ranges)\n         {\n-            ++read_idx;\n-            ++write_idx;\n-        }\n+            /// Current interval is righter than limit. \n+            if (limit && first > limit)\n+                break;\n \n-        ++read_idx;\n+            /// Consider a half interval [first, last)\n+            size_t read_idx = first;\n+            size_t write_idx = first;\n+            size_t end_idx = last;\n \n-        /// Invariants:\n-        ///  write_idx < read_idx\n-        ///  write_idx points to NULL\n-        ///  read_idx will be incremented to position of next not-NULL\n-        ///  there are range of NULLs between write_idx and read_idx - 1,\n-        /// We are moving elements from end to begin of this range,\n-        ///  so range will \"bubble\" towards the end.\n-        /// Relative order of NULL elements could be changed,\n-        ///  but relative order of non-NULLs is preserved.\n-\n-        while (read_idx < last && write_idx < last)\n-        {\n-            if (isNullAt(res[read_idx])^direction)\n+            /// We can't check the limit here because the interval is not sorted by nested column.\n+            while (read_idx < end_idx && !isNullAt(res[read_idx]))\n             {\n-                std::swap(res[read_idx], res[write_idx]);\n+                ++read_idx;\n                 ++write_idx;\n             }\n+\n             ++read_idx;\n-        }\n \n-        if (write_idx - first > 1)\n-        {\n-            if (direction)\n-                temp_ranges.emplace_back(first, write_idx);\n-            else\n+            /// Invariants:\n+            ///  write_idx < read_idx\n+            ///  write_idx points to NULL\n+            ///  read_idx will be incremented to position of next not-NULL\n+            ///  there are range of NULLs between write_idx and read_idx - 1,\n+            /// We are moving elements from end to begin of this range,\n+            ///  so range will \"bubble\" towards the end.\n+            /// Relative order of NULL elements could be changed,\n+            ///  but relative order of non-NULLs is preserved.\n+\n+            while (read_idx < end_idx && write_idx < end_idx)\n+            {\n+                if (!isNullAt(res[read_idx]))\n+                {\n+                    std::swap(res[read_idx], res[write_idx]);\n+                    ++write_idx;\n+                }\n+                ++read_idx;\n+            }\n+\n+            /// We have a range [first, write_idx) of non-NULL values\n+            if (first != write_idx)\n                 new_ranges.emplace_back(first, write_idx);\n \n+            /// We have a range [write_idx, list) of NULL values\n+            if (write_idx != last)\n+                null_ranges.emplace_back(write_idx, last);\n         }\n-\n-        if (last - write_idx > 1)\n+    }\n+    else\n+    {\n+        /// Shift all NULL values to the beginning.\n+        for (const auto & [first, last] : equal_ranges)\n         {\n-            if (direction)\n-                new_ranges.emplace_back(write_idx, last);\n-            else\n-                temp_ranges.emplace_back(write_idx, last);\n+            /// Current interval is righter than limit.\n+            if (limit && first > limit)\n+                break;\n+\n+            ssize_t read_idx = last - 1;\n+            ssize_t write_idx = last - 1;\n+            ssize_t begin_idx = first;\n+\n+            while (read_idx >= begin_idx && !isNullAt(res[read_idx]))\n+            {\n+                --read_idx;\n+                --write_idx;\n+            }\n+\n+            --read_idx;\n+\n+            while (read_idx >= begin_idx && write_idx >= begin_idx)\n+            {\n+                if (!isNullAt(res[read_idx]))\n+                {\n+                    std::swap(res[read_idx], res[write_idx]);\n+                    --write_idx;\n+                }\n+                --read_idx;\n+            }\n+\n+            /// We have a range [write_idx+1, last) of non-NULL values\n+            if (write_idx != static_cast<ssize_t>(last))\n+                new_ranges.emplace_back(write_idx + 1, last);\n+\n+            /// We have a range [first, write_idx+1) of NULL values\n+            if (static_cast<ssize_t>(first) != write_idx)\n+                null_ranges.emplace_back(first, write_idx + 1);\n         }\n     }\n-    while (!new_ranges.empty() && limit && limit <= new_ranges.back().first)\n-        new_ranges.pop_back();\n \n-    if (!temp_ranges.empty())\n-        getNestedColumn().updatePermutation(reverse, limit, null_direction_hint, res, temp_ranges);\n+    getNestedColumn().updatePermutation(reverse, limit, null_direction_hint, res, new_ranges);\n \n-    equal_range.resize(temp_ranges.size() + new_ranges.size());\n-    std::merge(temp_ranges.begin(), temp_ranges.end(), new_ranges.begin(), new_ranges.end(), equal_range.begin());\n+    equal_ranges = std::move(new_ranges);\n+    std::move(null_ranges.begin(), null_ranges.end(), std::back_inserter(equal_ranges));\n }\n \n void ColumnNullable::gather(ColumnGathererStream & gatherer)\ndiff --git a/src/Columns/ColumnString.cpp b/src/Columns/ColumnString.cpp\nindex 6c84107caae0..23414626a598 100644\n--- a/src/Columns/ColumnString.cpp\n+++ b/src/Columns/ColumnString.cpp\n@@ -9,7 +9,7 @@\n #include <DataStreams/ColumnGathererStream.h>\n \n #include <common/unaligned.h>\n-\n+#include <ext/scope_guard.h>\n \n namespace DB\n {\n@@ -325,25 +325,30 @@ void ColumnString::getPermutation(bool reverse, size_t limit, int /*nan_directio\n     }\n }\n \n-void ColumnString::updatePermutation(bool reverse, size_t limit, int /*nan_direction_hint*/, Permutation & res, EqualRanges & equal_range) const\n+void ColumnString::updatePermutation(bool reverse, size_t limit, int /*nan_direction_hint*/, Permutation & res, EqualRanges & equal_ranges) const\n {\n-    if (limit >= size() || limit > equal_range.back().second)\n+    if (equal_ranges.empty())\n+        return;\n+\n+    if (limit >= size() || limit > equal_ranges.back().second)\n         limit = 0;\n \n     EqualRanges new_ranges;\n-    auto less_true = less<true>(*this);\n-    auto less_false = less<false>(*this);\n-    size_t n = equal_range.size();\n+    SCOPE_EXIT({equal_ranges = std::move(new_ranges);});\n+\n+    size_t number_of_ranges = equal_ranges.size();\n     if (limit)\n-        --n;\n+        --number_of_ranges;\n \n-    for (size_t i = 0; i < n; ++i)\n+    for (size_t i = 0; i < number_of_ranges; ++i)\n     {\n-        const auto &[first, last] = equal_range[i];\n+        const auto & [first, last] = equal_ranges[i];\n+\n         if (reverse)\n-            std::sort(res.begin() + first, res.begin() + last, less_false);\n+            std::sort(res.begin() + first, res.begin() + last, less<false>(*this));\n         else\n-            std::sort(res.begin() + first, res.begin() + last, less_true);\n+            std::sort(res.begin() + first, res.begin() + last, less<true>(*this));\n+\n         size_t new_first = first;\n         for (size_t j = first + 1; j < last; ++j)\n         {\n@@ -363,11 +368,18 @@ void ColumnString::updatePermutation(bool reverse, size_t limit, int /*nan_direc\n \n     if (limit)\n     {\n-        const auto &[first, last] = equal_range.back();\n+        const auto & [first, last] = equal_ranges.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then we are working inside the interval.\n+\n         if (reverse)\n-            std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, less_false);\n+            std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, less<false>(*this));\n         else\n-            std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, less_true);\n+            std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, less<true>(*this));\n+\n         size_t new_first = first;\n         for (size_t j = first + 1; j < limit; ++j)\n         {\n@@ -394,7 +406,6 @@ void ColumnString::updatePermutation(bool reverse, size_t limit, int /*nan_direc\n         if (new_last - new_first > 1)\n             new_ranges.emplace_back(new_first, new_last);\n     }\n-    equal_range = std::move(new_ranges);\n }\n \n ColumnPtr ColumnString::replicate(const Offsets & replicate_offsets) const\n@@ -534,19 +545,25 @@ void ColumnString::getPermutationWithCollation(const Collator & collator, bool r\n     }\n }\n \n-void ColumnString::updatePermutationWithCollation(const Collator & collator, bool reverse, size_t limit, int, Permutation &res, EqualRanges &equal_range) const\n+void ColumnString::updatePermutationWithCollation(const Collator & collator, bool reverse, size_t limit, int, Permutation & res, EqualRanges & equal_ranges) const\n {\n-    if (limit >= size() || limit >= equal_range.back().second)\n+    if (equal_ranges.empty())\n+        return;\n+\n+    if (limit >= size() || limit >= equal_ranges.back().second)\n         limit = 0;\n \n-    size_t n = equal_range.size();\n+    size_t number_of_ranges = equal_ranges.size();\n     if (limit)\n-        --n;\n+        --number_of_ranges;\n \n     EqualRanges new_ranges;\n-    for (size_t i = 0; i < n; ++i)\n+    SCOPE_EXIT({equal_ranges = std::move(new_ranges);});\n+\n+    for (size_t i = 0; i < number_of_ranges; ++i)\n     {\n-        const auto& [first, last] = equal_range[i];\n+        const auto& [first, last] = equal_ranges[i];\n+\n         if (reverse)\n             std::sort(res.begin() + first, res.begin() + last, lessWithCollation<false>(*this, collator));\n         else\n@@ -566,16 +583,22 @@ void ColumnString::updatePermutationWithCollation(const Collator & collator, boo\n         }\n         if (last - new_first > 1)\n             new_ranges.emplace_back(new_first, last);\n-\n     }\n \n     if (limit)\n     {\n-        const auto& [first, last] = equal_range.back();\n+        const auto & [first, last] = equal_ranges.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then we are working inside the interval.\n+\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, lessWithCollation<false>(*this, collator));\n         else\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, lessWithCollation<true>(*this, collator));\n+\n         auto new_first = first;\n         for (auto j = first + 1; j < limit; ++j)\n         {\n@@ -603,7 +626,6 @@ void ColumnString::updatePermutationWithCollation(const Collator & collator, boo\n         if (new_last - new_first > 1)\n             new_ranges.emplace_back(new_first, new_last);\n     }\n-    equal_range = std::move(new_ranges);\n }\n \n void ColumnString::protect()\ndiff --git a/src/Columns/ColumnTuple.cpp b/src/Columns/ColumnTuple.cpp\nindex 87e5e37db518..98a6611edb7e 100644\n--- a/src/Columns/ColumnTuple.cpp\n+++ b/src/Columns/ColumnTuple.cpp\n@@ -344,15 +344,19 @@ void ColumnTuple::getPermutation(bool reverse, size_t limit, int nan_direction_h\n     }\n }\n \n-void ColumnTuple::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_range) const\n+void ColumnTuple::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_ranges) const\n {\n-    for (const auto& column : columns)\n+    if (equal_ranges.empty())\n+        return;\n+\n+    for (const auto & column : columns)\n     {\n-        column->updatePermutation(reverse, limit, nan_direction_hint, res, equal_range);\n-        while (limit && !equal_range.empty() && limit <= equal_range.back().first)\n-            equal_range.pop_back();\n+        column->updatePermutation(reverse, limit, nan_direction_hint, res, equal_ranges);\n+\n+        while (limit && !equal_ranges.empty() && limit <= equal_ranges.back().first)\n+            equal_ranges.pop_back();\n \n-        if (equal_range.empty())\n+        if (equal_ranges.empty())\n             break;\n     }\n }\ndiff --git a/src/Columns/ColumnUnique.h b/src/Columns/ColumnUnique.h\nindex d0edf65edd85..d87fdd65d155 100644\n--- a/src/Columns/ColumnUnique.h\n+++ b/src/Columns/ColumnUnique.h\n@@ -382,17 +382,20 @@ int ColumnUnique<ColumnType>::compareAt(size_t n, size_t m, const IColumn & rhs,\n         }\n     }\n \n-    auto & column_unique = static_cast<const IColumnUnique &>(rhs);\n+    const auto & column_unique = static_cast<const IColumnUnique &>(rhs);\n     return getNestedColumn()->compareAt(n, m, *column_unique.getNestedColumn(), nan_direction_hint);\n }\n \n template <typename ColumnType>\n-void ColumnUnique<ColumnType>::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_range) const\n+void ColumnUnique<ColumnType>::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_ranges) const\n {\n+    if (equal_ranges.empty())\n+        return;\n+\n     bool found_null_value_index = false;\n-    for (size_t i = 0; i < equal_range.size() && !found_null_value_index; ++i)\n+    for (size_t i = 0; i < equal_ranges.size() && !found_null_value_index; ++i)\n     {\n-        auto& [first, last] = equal_range[i];\n+        auto & [first, last] = equal_ranges[i];\n         for (auto j = first; j < last; ++j)\n         {\n             if (res[j] == getNullValueIndex())\n@@ -409,14 +412,14 @@ void ColumnUnique<ColumnType>::updatePermutation(bool reverse, size_t limit, int\n                 }\n                 if (last - first <= 1)\n                 {\n-                    equal_range.erase(equal_range.begin() + i);\n+                    equal_ranges.erase(equal_ranges.begin() + i);\n                 }\n                 found_null_value_index = true;\n                 break;\n             }\n         }\n     }\n-    getNestedColumn()->updatePermutation(reverse, limit, nan_direction_hint, res, equal_range);\n+    getNestedColumn()->updatePermutation(reverse, limit, nan_direction_hint, res, equal_ranges);\n }\n \n template <typename IndexType>\ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex b1b3ed4478a5..a09f64ad580e 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -15,8 +15,9 @@\n #include <Columns/ColumnsCommon.h>\n #include <DataStreams/ColumnGathererStream.h>\n #include <ext/bit_cast.h>\n+#include <ext/scope_guard.h>\n #include <pdqsort.h>\n-#include <numeric>\n+\n \n #if !defined(ARCADIA_BUILD)\n #    include <Common/config.h>\n@@ -243,10 +244,14 @@ void ColumnVector<T>::getPermutation(bool reverse, size_t limit, int nan_directi\n template <typename T>\n void ColumnVector<T>::updatePermutation(bool reverse, size_t limit, int nan_direction_hint, IColumn::Permutation & res, EqualRanges & equal_range) const\n {\n+    if (equal_range.empty())\n+        return;\n+\n     if (limit >= data.size() || limit >= equal_range.back().second)\n         limit = 0;\n \n     EqualRanges new_ranges;\n+    SCOPE_EXIT({equal_range = std::move(new_ranges);});\n \n     for (size_t i = 0; i < equal_range.size() - bool(limit); ++i)\n     {\n@@ -275,6 +280,12 @@ void ColumnVector<T>::updatePermutation(bool reverse, size_t limit, int nan_dire\n     if (limit)\n     {\n         const auto & [first, last] = equal_range.back();\n+\n+        if (limit < first || limit > last)\n+            return;\n+\n+        /// Since then, we are working inside the interval.\n+\n         if (reverse)\n             std::partial_sort(res.begin() + first, res.begin() + limit, res.begin() + last, greater(*this, nan_direction_hint));\n         else\n@@ -307,7 +318,6 @@ void ColumnVector<T>::updatePermutation(bool reverse, size_t limit, int nan_dire\n             new_ranges.emplace_back(new_first, new_last);\n         }\n     }\n-    equal_range = std::move(new_ranges);\n }\n \n template <typename T>\ndiff --git a/src/Interpreters/sortBlock.cpp b/src/Interpreters/sortBlock.cpp\nindex cb3c36e53564..d84708b9c574 100644\n--- a/src/Interpreters/sortBlock.cpp\n+++ b/src/Interpreters/sortBlock.cpp\n@@ -211,13 +211,11 @@ void sortBlock(Block & block, const SortDescription & description, UInt64 limit)\n             for (const auto & column : columns_with_sort_desc)\n             {\n                 while (!ranges.empty() && limit && limit <= ranges.back().first)\n-                {\n                     ranges.pop_back();\n-                }\n+\n                 if (ranges.empty())\n-                {\n                     break;\n-                }\n+\n                 column.column->updatePermutation(\n                     column.description.direction < 0, limit, column.description.nulls_direction, perm, ranges);\n             }\n@@ -225,9 +223,7 @@ void sortBlock(Block & block, const SortDescription & description, UInt64 limit)\n \n         size_t columns = block.columns();\n         for (size_t i = 0; i < columns; ++i)\n-        {\n             block.getByPosition(i).column = block.getByPosition(i).column->permute(perm, limit);\n-        }\n     }\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01457_order_by_limit.reference b/tests/queries/0_stateless/01457_order_by_limit.reference\nnew file mode 100644\nindex 000000000000..348bc7ad1d46\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_order_by_limit.reference\n@@ -0,0 +1,40 @@\n+asc nulls last, asc\n+1\t1\n+1\t2\n+1\t3\n+1\t4\n+asc nulls first, asc\n+1\t1\n+1\t2\n+1\t3\n+1\t4\n+desc nulls last, asc\n+1\t1\n+1\t2\n+1\t3\n+1\t4\n+desc nulls first, asc\n+1\t1\n+1\t2\n+1\t3\n+1\t4\n+asc nulls last, desc\n+1\t8\n+1\t7\n+1\t6\n+1\t5\n+asc nulls first, desc\n+1\t8\n+1\t7\n+1\t6\n+1\t5\n+desc nulls last, desc\n+1\t8\n+1\t7\n+1\t6\n+1\t5\n+desc nulls first, desc\n+1\t8\n+1\t7\n+1\t6\n+1\t5\ndiff --git a/tests/queries/0_stateless/01457_order_by_limit.sql b/tests/queries/0_stateless/01457_order_by_limit.sql\nnew file mode 100644\nindex 000000000000..514aaeac4ab4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_order_by_limit.sql\n@@ -0,0 +1,30 @@\n+drop table if exists order_by_another;\n+\n+create table order_by_another (a Nullable(UInt64), b UInt64) Engine = MergeTree order by tuple();\n+insert into order_by_another values (1, 8), (1, 7), (1, 6), (1, 5), (1, 4), (1, 3), (1, 2), (1, 1);\n+\n+select 'asc nulls last, asc';\n+select a, b from order_by_another order by a asc nulls last, b asc limit 4;\n+\n+select 'asc nulls first, asc';\n+select a, b from order_by_another order by a asc nulls first, b asc limit 4;\n+\n+select 'desc nulls last, asc';\n+select a, b from order_by_another order by a desc nulls last, b asc limit 4;\n+\n+select 'desc nulls first, asc';\n+select a, b from order_by_another order by a desc nulls first, b asc limit 4;\n+\n+select 'asc nulls last, desc';\n+select a, b from order_by_another order by a asc nulls last, b desc limit 4;\n+\n+select 'asc nulls first, desc';\n+select a, b from order_by_another order by a asc nulls first, b desc limit 4;\n+\n+select 'desc nulls last, desc';\n+select a, b from order_by_another order by a desc nulls last, b desc limit 4;\n+\n+select 'desc nulls first, desc';\n+select a, b from order_by_another order by a desc nulls first, b desc limit 4;\n+\n+drop table if exists order_by_another;\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/01457_order_by_nulls_first.reference b/tests/queries/0_stateless/01457_order_by_nulls_first.reference\nnew file mode 100644\nindex 000000000000..355e58120fe9\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_order_by_nulls_first.reference\n@@ -0,0 +1,76 @@\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+--- DESC NULLS FIRST, ASC\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t1\n+28\t0\n+0\t0\n+--- DESC NULLS LAST, ASC\n+28\t0\n+0\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t1\n+--- ASC NULLS FIRST, ASC\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t1\n+0\t0\n+28\t0\n+--- ASC NULLS LAST, ASC\n+0\t0\n+28\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t1\n+--- DESC NULLS FIRST, DESC\n+\\N\t1\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+28\t0\n+0\t0\n+--- DESC NULLS LAST, DESC\n+28\t0\n+0\t0\n+\\N\t1\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+--- ASC NULLS FIRST, DESC\n+\\N\t1\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+0\t0\n+28\t0\n+--- ASC NULLS LAST, DESC\n+0\t0\n+28\t0\n+\\N\t1\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\n+\\N\t0\ndiff --git a/tests/queries/0_stateless/01457_order_by_nulls_first.sql b/tests/queries/0_stateless/01457_order_by_nulls_first.sql\nnew file mode 100644\nindex 000000000000..100c87fbead4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01457_order_by_nulls_first.sql\n@@ -0,0 +1,96 @@\n+drop table if exists order_by_nulls_first;\n+\n+CREATE TABLE  order_by_nulls_first\n+(diff Nullable(Int16), traf UInt64)\n+ENGINE = MergeTree ORDER BY tuple();\n+\n+insert into order_by_nulls_first values (NULL,1),(NULL,0),(NULL,0),(NULL,0),(NULL,0),(NULL,0),(28,0),(0,0);\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+order by diff desc NULLS FIRST, traf\n+limit 1, 4;\n+\n+select '--- DESC NULLS FIRST, ASC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff DESC NULLS FIRST,\n+    traf ASC;\n+\n+select '--- DESC NULLS LAST, ASC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff DESC NULLS LAST,\n+    traf ASC;\n+\n+select '--- ASC NULLS FIRST, ASC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff ASC NULLS FIRST,\n+    traf ASC;\n+\n+select '--- ASC NULLS LAST, ASC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff ASC NULLS LAST,\n+    traf ASC;\n+\n+select '--- DESC NULLS FIRST, DESC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff DESC NULLS FIRST,\n+    traf DESC;\n+\n+select '--- DESC NULLS LAST, DESC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff DESC NULLS LAST,\n+    traf DESC;\n+\n+select '--- ASC NULLS FIRST, DESC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff ASC NULLS FIRST,\n+    traf DESC;\n+\n+select '--- ASC NULLS LAST, DESC';\n+\n+SELECT\n+    diff,\n+    traf\n+FROM order_by_nulls_first\n+ORDER BY\n+    diff ASC NULLS LAST,\n+    traf DESC;\n+\n+drop table if exists order_by_nulls_first;\n\\ No newline at end of file\n",
  "problem_statement": "Incorrect order of result rows for \"nulls first\" condition and \"limit[offset]\"\n\r\n**Describe the bug**\r\nWhen I migrated from 20.4.9.110 to 20.5.5.74 I got some unpredictable behavior of my code. When I try to execute select query with `order by` expression by multiple fields and use for one of this filed 'NULLS FIRST' with `limit` and `offset` I get incorrect order for some offsets.\r\n\r\nFor example:\r\n\r\nI have 830 records in my table and ~300 of them with diff==null.\r\nI execute query:\r\n\r\n```\r\nSELECT id,\r\n       country,\r\n       pos,\r\n       diff,\r\n       traf\r\nFROM test_table\r\nWHERE id =  'B07DJRFSDF'\r\n    AND mon=202007\r\n    AND country IN ('us')\r\norder by diff desc NULLS FIRST, traf\r\nlimit 10, 10 \r\n\r\n\r\n```\r\nI get something like that:\r\n\r\n```\r\nid: B07DJRFSDF; country: us; pos: 55; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 53; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 10; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 16; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 14; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 12; diff: 0; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 46; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 26; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 53; diff: null; traf: 0\r\n\r\nid: B07DJRFSDF; country: us; pos: 30; diff: null; traf: 0\r\n```\r\nYou can see in result a row with `diff == 0`\r\n\r\nAnd for example if I will use limit==11 everything will be ok.\r\n\r\n**How to reproduce**\r\nI attached script to import test data\r\n[test_data.txt](https://github.com/ClickHouse/ClickHouse/files/5157030/test_data.txt)\r\n**Expected behavior**\r\nResult with a correct order\r\n\n",
  "hints_text": "```\r\n$ cat test_data.sql\r\ndrop table if exists test_table;\r\n\r\nCREATE TABLE  test_table\r\n(diff            Nullable(Int16),\r\n traf            UInt64) ENGINE = MergeTree ORDER BY tuple();\r\n\r\ninsert into test_table values (NULL,1),(NULL,0),(NULL,0),(NULL,0),(NULL,0),(NULL,0),(28,0),(0,0);\r\n\r\nSELECT\r\n       diff,\r\n       traf\r\nFROM test_table\r\norder by diff desc NULLS FIRST, traf\r\nlimit 1, 4;\r\n\r\n\r\n$ cat test_data.sql |clickhouse-client -mn\r\n\\N\t0\r\n28\t0\r\n\\N\t0\r\n\\N\t0\r\n\r\n```\r\n\r\n```\r\nSELECT\r\n    diff,\r\n    traf\r\nFROM test_table\r\nORDER BY\r\n    diff DESC NULLS FIRST,\r\n    traf ASC\r\n\r\n\u250c\u2500diff\u2500\u252c\u2500traf\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502    0 \u2502\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502    0 \u2502\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502    0 \u2502\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502    0 \u2502\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502    0 \u2502\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502    1 \u2502\r\n\u2502   28 \u2502    0 \u2502\r\n\u2502    0 \u2502    0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```",
  "created_at": "2020-09-04T14:38:23Z",
  "modified_files": [
    "src/Columns/ColumnArray.cpp",
    "src/Columns/ColumnDecimal.cpp",
    "src/Columns/ColumnFixedString.cpp",
    "src/Columns/ColumnLowCardinality.cpp",
    "src/Columns/ColumnNullable.cpp",
    "src/Columns/ColumnString.cpp",
    "src/Columns/ColumnTuple.cpp",
    "src/Columns/ColumnUnique.h",
    "src/Columns/ColumnVector.cpp",
    "src/Interpreters/sortBlock.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01457_order_by_limit.reference",
    "b/tests/queries/0_stateless/01457_order_by_limit.sql",
    "b/tests/queries/0_stateless/01457_order_by_nulls_first.reference",
    "b/tests/queries/0_stateless/01457_order_by_nulls_first.sql"
  ]
}