{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 45254,
  "instance_id": "ClickHouse__ClickHouse-45254",
  "issue_numbers": [
    "44490"
  ],
  "base_commit": "13d4d40568a21d154b35e33a14f65f9d12eeb96e",
  "patch": "diff --git a/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp b/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp\nnew file mode 100644\nindex 000000000000..55152fccee90\n--- /dev/null\n+++ b/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp\n@@ -0,0 +1,253 @@\n+#include <Analyzer/Passes/GroupingFunctionsResolvePass.h>\n+\n+#include <Core/ColumnNumbers.h>\n+\n+#include <Functions/grouping.h>\n+\n+#include <Interpreters/Context.h>\n+\n+#include <Analyzer/InDepthQueryTreeVisitor.h>\n+#include <Analyzer/QueryNode.h>\n+#include <Analyzer/HashUtils.h>\n+#include <Analyzer/FunctionNode.h>\n+#include <Analyzer/ColumnNode.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+namespace\n+{\n+\n+enum class GroupByKind\n+{\n+    ORDINARY,\n+    ROLLUP,\n+    CUBE,\n+    GROUPING_SETS\n+};\n+\n+class GroupingFunctionResolveVisitor : public InDepthQueryTreeVisitor<GroupingFunctionResolveVisitor>\n+{\n+public:\n+    GroupingFunctionResolveVisitor(GroupByKind group_by_kind_,\n+        QueryTreeNodePtrWithHashMap<size_t> aggregation_key_to_index_,\n+        ColumnNumbersList grouping_sets_keys_indices_,\n+        ContextPtr context_)\n+        : group_by_kind(group_by_kind_)\n+        , aggregation_key_to_index(std::move(aggregation_key_to_index_))\n+        , grouping_sets_keys_indexes(std::move(grouping_sets_keys_indices_))\n+        , context(std::move(context_))\n+    {\n+    }\n+\n+    void visitImpl(const QueryTreeNodePtr & node)\n+    {\n+        auto * function_node = node->as<FunctionNode>();\n+        if (!function_node || function_node->getFunctionName() != \"grouping\")\n+            return;\n+\n+        auto & function_arguments = function_node->getArguments().getNodes();\n+\n+        ColumnNumbers arguments_indexes;\n+        arguments_indexes.reserve(function_arguments.size());\n+\n+        for (const auto & argument : function_arguments)\n+        {\n+            auto it = aggregation_key_to_index.find(argument);\n+            if (it == aggregation_key_to_index.end())\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Argument {} of GROUPING function is not a part of GROUP BY clause\",\n+                    argument->formatASTForErrorMessage());\n+\n+            arguments_indexes.push_back(it->second);\n+        }\n+\n+        FunctionOverloadResolverPtr grouping_function_resolver;\n+        bool add_grouping_set_column = false;\n+\n+        bool force_grouping_standard_compatibility = context->getSettingsRef().force_grouping_standard_compatibility;\n+        size_t aggregation_keys_size = aggregation_key_to_index.size();\n+\n+        switch (group_by_kind)\n+        {\n+            case GroupByKind::ORDINARY:\n+            {\n+                auto grouping_ordinary_function = std::make_shared<FunctionGroupingOrdinary>(arguments_indexes,\n+                    force_grouping_standard_compatibility);\n+                grouping_function_resolver = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_ordinary_function));\n+                break;\n+            }\n+            case GroupByKind::ROLLUP:\n+            {\n+                auto grouping_rollup_function = std::make_shared<FunctionGroupingForRollup>(arguments_indexes,\n+                    aggregation_keys_size,\n+                    force_grouping_standard_compatibility);\n+                grouping_function_resolver = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_rollup_function));\n+                add_grouping_set_column = true;\n+                break;\n+            }\n+            case GroupByKind::CUBE:\n+            {\n+                auto grouping_cube_function = std::make_shared<FunctionGroupingForCube>(arguments_indexes,\n+                    aggregation_keys_size,\n+                    force_grouping_standard_compatibility);\n+                grouping_function_resolver = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_cube_function));\n+                add_grouping_set_column = true;\n+                break;\n+            }\n+            case GroupByKind::GROUPING_SETS:\n+            {\n+                auto grouping_grouping_sets_function = std::make_shared<FunctionGroupingForGroupingSets>(arguments_indexes,\n+                    grouping_sets_keys_indexes,\n+                    force_grouping_standard_compatibility);\n+                grouping_function_resolver = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_grouping_sets_function));\n+                add_grouping_set_column = true;\n+                break;\n+            }\n+        }\n+\n+        if (add_grouping_set_column)\n+        {\n+            QueryTreeNodeWeakPtr column_source;\n+            auto grouping_set_column = NameAndTypePair{\"__grouping_set\", std::make_shared<DataTypeUInt64>()};\n+            auto grouping_set_argument_column = std::make_shared<ColumnNode>(std::move(grouping_set_column), std::move(column_source));\n+            function_arguments.insert(function_arguments.begin(), std::move(grouping_set_argument_column));\n+        }\n+\n+        function_node->resolveAsFunction(grouping_function_resolver->build(function_node->getArgumentColumns()));\n+    }\n+\n+    static bool needChildVisit(const QueryTreeNodePtr &, const QueryTreeNodePtr & child_node)\n+    {\n+        return !(child_node->getNodeType() == QueryTreeNodeType::QUERY || child_node->getNodeType() == QueryTreeNodeType::UNION);\n+    }\n+\n+private:\n+    GroupByKind group_by_kind;\n+    QueryTreeNodePtrWithHashMap<size_t> aggregation_key_to_index;\n+    ColumnNumbersList grouping_sets_keys_indexes;\n+    ContextPtr context;\n+};\n+\n+void resolveGroupingFunctions(QueryTreeNodePtr & query_node, ContextPtr context)\n+{\n+    auto & query_node_typed = query_node->as<QueryNode &>();\n+\n+    size_t aggregation_node_index = 0;\n+    QueryTreeNodePtrWithHashMap<size_t> aggregation_key_to_index;\n+\n+    std::vector<QueryTreeNodes> grouping_sets_used_aggregation_keys_list;\n+\n+    if (query_node_typed.hasGroupBy())\n+    {\n+        /// It is expected by execution layer that if there are only 1 grouping set it will be removed\n+        if (query_node_typed.isGroupByWithGroupingSets() && query_node_typed.getGroupBy().getNodes().size() == 1)\n+        {\n+            auto & grouping_set_list_node = query_node_typed.getGroupBy().getNodes().front()->as<ListNode &>();\n+            query_node_typed.getGroupBy().getNodes() = std::move(grouping_set_list_node.getNodes());\n+            query_node_typed.setIsGroupByWithGroupingSets(false);\n+        }\n+\n+        if (query_node_typed.isGroupByWithGroupingSets())\n+        {\n+            for (const auto & grouping_set_keys_list_node : query_node_typed.getGroupBy().getNodes())\n+            {\n+                auto & grouping_set_keys_list_node_typed = grouping_set_keys_list_node->as<ListNode &>();\n+\n+                grouping_sets_used_aggregation_keys_list.emplace_back();\n+                auto & grouping_sets_used_aggregation_keys = grouping_sets_used_aggregation_keys_list.back();\n+\n+                for (auto & grouping_set_key_node : grouping_set_keys_list_node_typed.getNodes())\n+                {\n+                    if (aggregation_key_to_index.contains(grouping_set_key_node))\n+                        continue;\n+\n+                    grouping_sets_used_aggregation_keys.push_back(grouping_set_key_node);\n+                    aggregation_key_to_index.emplace(grouping_set_key_node, aggregation_node_index);\n+                    ++aggregation_node_index;\n+                }\n+            }\n+        }\n+        else\n+        {\n+            for (auto & group_by_key_node : query_node_typed.getGroupBy().getNodes())\n+            {\n+                if (aggregation_key_to_index.contains(group_by_key_node))\n+                    continue;\n+\n+                aggregation_key_to_index.emplace(group_by_key_node, aggregation_node_index);\n+                ++aggregation_node_index;\n+            }\n+        }\n+    }\n+\n+    /// Indexes of aggregation keys used in each grouping set (only for GROUP BY GROUPING SETS)\n+    ColumnNumbersList grouping_sets_keys_indexes;\n+\n+    for (const auto & grouping_set_used_aggregation_keys : grouping_sets_used_aggregation_keys_list)\n+    {\n+        grouping_sets_keys_indexes.emplace_back();\n+        auto & grouping_set_keys_indexes = grouping_sets_keys_indexes.back();\n+\n+        for (const auto & used_aggregation_key : grouping_set_used_aggregation_keys)\n+        {\n+            auto aggregation_node_index_it = aggregation_key_to_index.find(used_aggregation_key);\n+            if (aggregation_node_index_it == aggregation_key_to_index.end())\n+                throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                    \"Aggregation key {} in GROUPING SETS is not found in GROUP BY keys\",\n+                    used_aggregation_key->formatASTForErrorMessage());\n+\n+            grouping_set_keys_indexes.push_back(aggregation_node_index_it->second);\n+        }\n+    }\n+\n+    GroupByKind group_by_kind = GroupByKind::ORDINARY;\n+    if (query_node_typed.isGroupByWithRollup())\n+        group_by_kind = GroupByKind::ROLLUP;\n+    else if (query_node_typed.isGroupByWithCube())\n+        group_by_kind = GroupByKind::CUBE;\n+    else if (query_node_typed.isGroupByWithGroupingSets())\n+        group_by_kind = GroupByKind::GROUPING_SETS;\n+\n+    GroupingFunctionResolveVisitor visitor(group_by_kind,\n+        std::move(aggregation_key_to_index),\n+        std::move(grouping_sets_keys_indexes),\n+        std::move(context));\n+    visitor.visit(query_node);\n+}\n+\n+class GroupingFunctionsResolveVisitor : public InDepthQueryTreeVisitor<GroupingFunctionsResolveVisitor>\n+{\n+public:\n+    explicit GroupingFunctionsResolveVisitor(ContextPtr context_)\n+        : context(std::move(context_))\n+    {}\n+\n+    void visitImpl(QueryTreeNodePtr & node)\n+    {\n+        if (node->getNodeType() != QueryTreeNodeType::QUERY)\n+            return;\n+\n+        resolveGroupingFunctions(node, context);\n+    }\n+\n+private:\n+    ContextPtr context;\n+};\n+\n+}\n+\n+void GroupingFunctionsResolvePass::run(QueryTreeNodePtr query_tree_node, ContextPtr context)\n+{\n+    GroupingFunctionsResolveVisitor visitor(std::move(context));\n+    visitor.visit(query_tree_node);\n+}\n+\n+}\n+\ndiff --git a/src/Analyzer/Passes/GroupingFunctionsResolvePass.h b/src/Analyzer/Passes/GroupingFunctionsResolvePass.h\nnew file mode 100644\nindex 000000000000..070c8dd9389d\n--- /dev/null\n+++ b/src/Analyzer/Passes/GroupingFunctionsResolvePass.h\n@@ -0,0 +1,31 @@\n+#pragma once\n+\n+#include <Analyzer/IQueryTreePass.h>\n+\n+namespace DB\n+{\n+\n+/** Resolve GROUPING functions in query node.\n+  * GROUPING function is replaced with specialized GROUPING function based on GROUP BY modifiers.\n+  * For ROLLUP, CUBE, GROUPING SETS specialized GROUPING function take special __grouping_set column as argument\n+  * and previous GROUPING function arguments.\n+  *\n+  * Example: SELECT grouping(id) FROM test_table GROUP BY id;\n+  * Result: SELECT groupingOrdinary(id) FROM test_table GROUP BY id;\n+  *\n+  * Example: SELECT grouping(id), grouping(value) FROM test_table GROUP BY GROUPING SETS ((id), (value));\n+  * Result: SELECT groupingForGroupingSets(__grouping_set, id), groupingForGroupingSets(__grouping_set, value)\n+  * FROM test_table GROUP BY GROUPING SETS ((id), (value));\n+  */\n+class GroupingFunctionsResolvePass final : public IQueryTreePass\n+{\n+public:\n+    String getName() override { return \"GroupingFunctionsResolvePass\"; }\n+\n+    String getDescription() override { return \"Resolve GROUPING functions based on GROUP BY modifiers\"; }\n+\n+    void run(QueryTreeNodePtr query_tree_node, ContextPtr context) override;\n+\n+};\n+\n+}\ndiff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex 695a542fc421..b5efd090e4ce 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -4352,7 +4352,8 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             bool force_grouping_standard_compatibility = scope.context->getSettingsRef().force_grouping_standard_compatibility;\n             auto grouping_function = std::make_shared<FunctionGrouping>(force_grouping_standard_compatibility);\n             auto grouping_function_adaptor = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_function));\n-            function_node.resolveAsFunction(grouping_function_adaptor->build({}));\n+            function_node.resolveAsFunction(grouping_function_adaptor->build(argument_columns));\n+\n             return result_projection_names;\n         }\n     }\ndiff --git a/src/Analyzer/QueryTreePassManager.cpp b/src/Analyzer/QueryTreePassManager.cpp\nindex 66b060de6c4a..33fc5f1cb6bd 100644\n--- a/src/Analyzer/QueryTreePassManager.cpp\n+++ b/src/Analyzer/QueryTreePassManager.cpp\n@@ -32,6 +32,7 @@\n #include <Analyzer/Passes/IfTransformStringsToEnumPass.h>\n #include <Analyzer/Passes/ConvertOrLikeChainPass.h>\n #include <Analyzer/Passes/OptimizeRedundantFunctionsInOrderByPass.h>\n+#include <Analyzer/Passes/GroupingFunctionsResolvePass.h>\n \n namespace DB\n {\n@@ -67,7 +68,7 @@ class ValidationChecker : public InDepthQueryTreeVisitor<ValidationChecker>\n private:\n     void visitColumn(ColumnNode * column) const\n     {\n-        if (column->getColumnSourceOrNull() == nullptr)\n+        if (column->getColumnSourceOrNull() == nullptr && column->getColumnName() != \"__grouping_set\")\n             throw Exception(ErrorCodes::LOGICAL_ERROR,\n                 \"Column {} {} query tree node does not have valid source node after running {} pass\",\n                 column->getColumnName(), column->getColumnType(), pass_name);\n@@ -258,6 +259,8 @@ void addQueryTreePasses(QueryTreePassManager & manager)\n         manager.addPass(std::make_unique<IfTransformStringsToEnumPass>());\n \n     manager.addPass(std::make_unique<ConvertOrLikeChainPass>());\n+\n+    manager.addPass(std::make_unique<GroupingFunctionsResolvePass>());\n }\n \n }\ndiff --git a/src/Planner/CollectTableExpressionData.cpp b/src/Planner/CollectTableExpressionData.cpp\nindex 897959fa456f..0b820e849f31 100644\n--- a/src/Planner/CollectTableExpressionData.cpp\n+++ b/src/Planner/CollectTableExpressionData.cpp\n@@ -35,6 +35,9 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitor<CollectSource\n         if (!column_node)\n             return;\n \n+        if (column_node->getColumnName() == \"__grouping_set\")\n+            return;\n+\n         auto column_source_node = column_node->getColumnSource();\n         auto column_source_node_type = column_source_node->getNodeType();\n \ndiff --git a/src/Planner/PlannerAggregation.cpp b/src/Planner/PlannerAggregation.cpp\nindex 05e7b5418e3e..67ce474b37ca 100644\n--- a/src/Planner/PlannerAggregation.cpp\n+++ b/src/Planner/PlannerAggregation.cpp\n@@ -1,188 +1,13 @@\n #include <Planner/PlannerAggregation.h>\n \n-#include <Functions/grouping.h>\n-\n-#include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ConstantNode.h>\n-#include <Analyzer/ColumnNode.h>\n #include <Analyzer/FunctionNode.h>\n-#include <Analyzer/QueryNode.h>\n-#include <Analyzer/AggregationUtils.h>\n-\n-#include <Interpreters/Context.h>\n-\n-#include <Processors/QueryPlan/AggregatingStep.h>\n \n #include <Planner/PlannerActionsVisitor.h>\n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int LOGICAL_ERROR;\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n-namespace\n-{\n-\n-enum class GroupByKind\n-{\n-    ORDINARY,\n-    ROLLUP,\n-    CUBE,\n-    GROUPING_SETS\n-};\n-\n-class GroupingFunctionResolveVisitor : public InDepthQueryTreeVisitor<GroupingFunctionResolveVisitor>\n-{\n-public:\n-    GroupingFunctionResolveVisitor(GroupByKind group_by_kind_,\n-        const Names & aggregation_keys_,\n-        const GroupingSetsParamsList & grouping_sets_parameters_list_,\n-        const PlannerContext & planner_context_)\n-        : group_by_kind(group_by_kind_)\n-        , planner_context(planner_context_)\n-    {\n-        size_t aggregation_keys_size = aggregation_keys_.size();\n-        for (size_t i = 0; i < aggregation_keys_size; ++i)\n-            aggegation_key_to_index.emplace(aggregation_keys_[i], i);\n-\n-        for (const auto & grouping_sets_parameter : grouping_sets_parameters_list_)\n-        {\n-            grouping_sets_keys_indices.emplace_back();\n-            auto & grouping_set_keys_indices = grouping_sets_keys_indices.back();\n-\n-            for (const auto & used_key : grouping_sets_parameter.used_keys)\n-            {\n-                auto aggregation_key_index_it = aggegation_key_to_index.find(used_key);\n-                if (aggregation_key_index_it == aggegation_key_to_index.end())\n-                    throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                        \"Aggregation key {} in GROUPING SETS is not found in GROUP BY keys\");\n-\n-                grouping_set_keys_indices.push_back(aggregation_key_index_it->second);\n-            }\n-        }\n-    }\n-\n-    void visitImpl(const QueryTreeNodePtr & node)\n-    {\n-        auto * function_node = node->as<FunctionNode>();\n-        if (!function_node || function_node->getFunctionName() != \"grouping\")\n-            return;\n-\n-        size_t aggregation_keys_size = aggegation_key_to_index.size();\n-\n-        ColumnNumbers arguments_indexes;\n-\n-        for (const auto & argument : function_node->getArguments().getNodes())\n-        {\n-            String action_node_name = calculateActionNodeName(argument, planner_context);\n-\n-            auto it = aggegation_key_to_index.find(action_node_name);\n-            if (it == aggegation_key_to_index.end())\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Argument of GROUPING function {} is not a part of GROUP BY clause\",\n-                    argument->formatASTForErrorMessage());\n-\n-            arguments_indexes.push_back(it->second);\n-        }\n-\n-        QueryTreeNodeWeakPtr column_source;\n-        auto grouping_set_argument_column = std::make_shared<ColumnNode>(NameAndTypePair{\"__grouping_set\", std::make_shared<DataTypeUInt64>()}, column_source);\n-        function_node->getArguments().getNodes().clear();\n-\n-        bool force_grouping_standard_compatibility = planner_context.getQueryContext()->getSettingsRef().force_grouping_standard_compatibility;\n-\n-        switch (group_by_kind)\n-        {\n-            case GroupByKind::ORDINARY:\n-            {\n-                auto grouping_ordinary_function = std::make_shared<FunctionGroupingOrdinary>(arguments_indexes, force_grouping_standard_compatibility);\n-                auto grouping_ordinary_function_adaptor = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_ordinary_function));\n-                function_node->resolveAsFunction(grouping_ordinary_function_adaptor->build({}));\n-                break;\n-            }\n-            case GroupByKind::ROLLUP:\n-            {\n-                auto grouping_rollup_function = std::make_shared<FunctionGroupingForRollup>(arguments_indexes, aggregation_keys_size, force_grouping_standard_compatibility);\n-                auto grouping_rollup_function_adaptor = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_rollup_function));\n-                function_node->resolveAsFunction(grouping_rollup_function_adaptor->build({}));\n-                function_node->getArguments().getNodes().push_back(std::move(grouping_set_argument_column));\n-                break;\n-            }\n-            case GroupByKind::CUBE:\n-            {\n-                auto grouping_cube_function = std::make_shared<FunctionGroupingForCube>(arguments_indexes, aggregation_keys_size, force_grouping_standard_compatibility);\n-                auto grouping_cube_function_adaptor = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_cube_function));\n-                function_node->resolveAsFunction(grouping_cube_function_adaptor->build({}));\n-                function_node->getArguments().getNodes().push_back(std::move(grouping_set_argument_column));\n-                break;\n-            }\n-            case GroupByKind::GROUPING_SETS:\n-            {\n-                auto grouping_grouping_sets_function = std::make_shared<FunctionGroupingForGroupingSets>(arguments_indexes, grouping_sets_keys_indices, force_grouping_standard_compatibility);\n-                auto grouping_grouping_sets_function_adaptor = std::make_shared<FunctionToOverloadResolverAdaptor>(std::move(grouping_grouping_sets_function));\n-                function_node->resolveAsFunction(grouping_grouping_sets_function_adaptor->build({}));\n-                function_node->getArguments().getNodes().push_back(std::move(grouping_set_argument_column));\n-                break;\n-            }\n-        }\n-    }\n-\n-    static bool needChildVisit(const QueryTreeNodePtr &, const QueryTreeNodePtr & child_node)\n-    {\n-        return !(child_node->getNodeType() == QueryTreeNodeType::QUERY || child_node->getNodeType() == QueryTreeNodeType::UNION);\n-    }\n-\n-private:\n-    GroupByKind group_by_kind;\n-    std::unordered_map<std::string, size_t> aggegation_key_to_index;\n-    // Indexes of aggregation keys used in each grouping set (only for GROUP BY GROUPING SETS)\n-    ColumnNumbersList grouping_sets_keys_indices;\n-    const PlannerContext & planner_context;\n-};\n-\n-void resolveGroupingFunctions(QueryTreeNodePtr & node,\n-    GroupByKind group_by_kind,\n-    const Names & aggregation_keys,\n-    const GroupingSetsParamsList & grouping_sets_parameters_list,\n-    const PlannerContext & planner_context)\n-{\n-    auto & query_node_typed = node->as<QueryNode &>();\n-\n-    GroupingFunctionResolveVisitor visitor(group_by_kind, aggregation_keys, grouping_sets_parameters_list, planner_context);\n-\n-    if (query_node_typed.hasHaving())\n-        visitor.visit(query_node_typed.getHaving());\n-\n-    if (query_node_typed.hasOrderBy())\n-        visitor.visit(query_node_typed.getOrderByNode());\n-\n-    visitor.visit(query_node_typed.getProjectionNode());\n-}\n-\n-}\n-\n-void resolveGroupingFunctions(QueryTreeNodePtr & query_node,\n-    const Names & aggregation_keys,\n-    const GroupingSetsParamsList & grouping_sets_parameters_list,\n-    const PlannerContext & planner_context)\n-{\n-    auto & query_node_typed = query_node->as<QueryNode &>();\n-\n-    GroupByKind group_by_kind = GroupByKind::ORDINARY;\n-    if (query_node_typed.isGroupByWithRollup())\n-        group_by_kind = GroupByKind::ROLLUP;\n-    else if (query_node_typed.isGroupByWithCube())\n-        group_by_kind = GroupByKind::CUBE;\n-    else if (query_node_typed.isGroupByWithGroupingSets())\n-        group_by_kind = GroupByKind::GROUPING_SETS;\n-\n-    resolveGroupingFunctions(query_node, group_by_kind, aggregation_keys, grouping_sets_parameters_list, planner_context);\n-}\n-\n AggregateDescriptions extractAggregateDescriptions(const QueryTreeNodes & aggregate_function_nodes, const PlannerContext & planner_context)\n {\n     QueryTreeNodeToName node_to_name;\ndiff --git a/src/Planner/PlannerAggregation.h b/src/Planner/PlannerAggregation.h\nindex 6dfd7faca22e..2c12361e9544 100644\n--- a/src/Planner/PlannerAggregation.h\n+++ b/src/Planner/PlannerAggregation.h\n@@ -11,15 +11,6 @@\n namespace DB\n {\n \n-/** Resolve GROUPING functions in query node.\n-  * GROUPING function is replaced with specialized GROUPING function based on GROUP BY modifiers.\n-  * For ROLLUP, CUBE, GROUPING SETS specialized GROUPING function take special __grouping_set column as argument.\n-  */\n-void resolveGroupingFunctions(QueryTreeNodePtr & query_node,\n-    const Names & aggregation_keys,\n-    const GroupingSetsParamsList & grouping_sets_parameters_list,\n-    const PlannerContext & planner_context);\n-\n /// Extract aggregate descriptions from aggregate function nodes\n AggregateDescriptions extractAggregateDescriptions(const QueryTreeNodes & aggregate_function_nodes, const PlannerContext & planner_context);\n \ndiff --git a/src/Planner/PlannerExpressionAnalysis.cpp b/src/Planner/PlannerExpressionAnalysis.cpp\nindex 91a04b090fc5..b1017c99c3e9 100644\n--- a/src/Planner/PlannerExpressionAnalysis.cpp\n+++ b/src/Planner/PlannerExpressionAnalysis.cpp\n@@ -52,7 +52,7 @@ FilterAnalysisResult analyzeFilter(const QueryTreeNodePtr & filter_expression_no\n /** Construct aggregation analysis result if query tree has GROUP BY or aggregates.\n   * Actions before aggregation are added into actions chain, if result is not null optional.\n   */\n-std::optional<AggregationAnalysisResult> analyzeAggregation(QueryTreeNodePtr & query_tree,\n+std::optional<AggregationAnalysisResult> analyzeAggregation(const QueryTreeNodePtr & query_tree,\n     const ColumnsWithTypeAndName & join_tree_input_columns,\n     const PlannerContextPtr & planner_context,\n     ActionsChain & actions_chain)\n@@ -79,7 +79,6 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(QueryTreeNodePtr & q\n \n     GroupingSetsParamsList grouping_sets_parameters_list;\n     bool group_by_with_constant_keys = false;\n-    bool disable_grouping_sets = false;\n \n     PlannerActionsVisitor actions_visitor(planner_context);\n \n@@ -137,13 +136,6 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(QueryTreeNodePtr & q\n \n                 grouping_sets_parameter.used_keys = std::move(grouping_sets_keys);\n             }\n-\n-            /// It is expected by execution layer that if there are only 1 grouping sets it will be removed\n-            if (grouping_sets_parameters_list.size() == 1)\n-            {\n-                disable_grouping_sets = true;\n-                grouping_sets_parameters_list.clear();\n-            }\n         }\n         else\n         {\n@@ -190,11 +182,9 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(QueryTreeNodePtr & q\n     /** For non ordinary GROUP BY we add virtual __grouping_set column\n       * With set number, which is used as an additional key at the stage of merging aggregating data.\n       */\n-    if (query_node.isGroupByWithRollup() || query_node.isGroupByWithCube() || (query_node.isGroupByWithGroupingSets() && !disable_grouping_sets))\n+    if (query_node.isGroupByWithRollup() || query_node.isGroupByWithCube() || query_node.isGroupByWithGroupingSets())\n         aggregates_columns.emplace_back(nullptr, std::make_shared<DataTypeUInt64>(), \"__grouping_set\");\n \n-    resolveGroupingFunctions(query_tree, aggregation_keys, grouping_sets_parameters_list, *planner_context);\n-\n     /// Only aggregation keys and aggregates are available for next steps after GROUP BY step\n     auto aggregate_step = std::make_unique<ActionsChainStep>(before_aggregation_actions, ActionsChainStep::AvailableOutputColumnsStrategy::OUTPUT_NODES, aggregates_columns);\n     actions_chain.addStep(std::move(aggregate_step));\n@@ -212,7 +202,7 @@ std::optional<AggregationAnalysisResult> analyzeAggregation(QueryTreeNodePtr & q\n /** Construct window analysis result if query tree has window functions.\n   * Actions before window functions are added into actions chain, if result is not null optional.\n   */\n-std::optional<WindowAnalysisResult> analyzeWindow(QueryTreeNodePtr & query_tree,\n+std::optional<WindowAnalysisResult> analyzeWindow(const QueryTreeNodePtr & query_tree,\n     const ColumnsWithTypeAndName & join_tree_input_columns,\n     const PlannerContextPtr & planner_context,\n     ActionsChain & actions_chain)\n@@ -417,7 +407,7 @@ LimitByAnalysisResult analyzeLimitBy(const QueryNode & query_node,\n \n }\n \n-PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(QueryTreeNodePtr query_tree,\n+PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNodePtr & query_tree,\n     const ColumnsWithTypeAndName & join_tree_input_columns,\n     const PlannerContextPtr & planner_context)\n {\n@@ -463,14 +453,8 @@ PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(QueryTreeNodePtr\n     project_names_actions->project(projection_analysis_result.projection_column_names_with_display_aliases);\n     actions_chain.addStep(std::make_unique<ActionsChainStep>(project_names_actions));\n \n-    // std::cout << \"Chain dump before finalize\" << std::endl;\n-    // std::cout << actions_chain.dump() << std::endl;\n-\n     actions_chain.finalize();\n \n-    // std::cout << \"Chain dump after finalize\" << std::endl;\n-    // std::cout << actions_chain.dump() << std::endl;\n-\n     projection_analysis_result.project_names_actions = std::move(project_names_actions);\n \n     PlannerExpressionsAnalysisResult expressions_analysis_result(std::move(projection_analysis_result));\ndiff --git a/src/Planner/PlannerExpressionAnalysis.h b/src/Planner/PlannerExpressionAnalysis.h\nindex aefb3c369d09..d697641964c1 100644\n--- a/src/Planner/PlannerExpressionAnalysis.h\n+++ b/src/Planner/PlannerExpressionAnalysis.h\n@@ -168,7 +168,7 @@ class PlannerExpressionsAnalysisResult\n };\n \n /// Build expression analysis result for query tree, join tree input columns and planner context\n-PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(QueryTreeNodePtr query_tree,\n+PlannerExpressionsAnalysisResult buildExpressionAnalysisResult(const QueryTreeNodePtr & query_tree,\n     const ColumnsWithTypeAndName & join_tree_input_columns,\n     const PlannerContextPtr & planner_context);\n \ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex 6a48f322ba51..2484bd093eca 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -248,7 +248,7 @@ JoinTreeQueryPlan buildQueryPlanForTableExpression(const QueryTreeNodePtr & tabl\n         if (max_streams == 0)\n             max_streams = 1;\n \n-        /// If necessary, we request more sources than the number of threads - to distribute the work evenly over the threads.\n+        /// If necessary, we request more sources than the number of threads - to distribute the work evenly over the threads\n         if (max_streams > 1 && !is_remote)\n             max_streams = static_cast<size_t>(max_streams * settings.max_streams_to_max_threads_ratio);\n \n@@ -841,7 +841,7 @@ JoinTreeQueryPlan buildJoinTreeQueryPlan(const QueryTreeNodePtr & query_node,\n     std::vector<ColumnIdentifierSet> table_expressions_outer_scope_columns(table_expressions_stack_size);\n     ColumnIdentifierSet current_outer_scope_columns = outer_scope_columns;\n \n-    for (Int64 i = table_expressions_stack_size - 1; i >= 0; --i)\n+    for (Int64 i = static_cast<Int64>(table_expressions_stack_size) - 1; i >= 0; --i)\n     {\n         table_expressions_outer_scope_columns[i] = current_outer_scope_columns;\n \n@@ -859,7 +859,8 @@ JoinTreeQueryPlan buildJoinTreeQueryPlan(const QueryTreeNodePtr & query_node,\n         {\n             if (query_plans_stack.empty())\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Expected at least 1 query plan on stack before ARRAY JOIN processing\");\n+                    \"Expected at least 1 query plan on stack before ARRAY JOIN processing. Actual {}\",\n+                    query_plans_stack.size());\n \n             auto query_plan = std::move(query_plans_stack.back());\n             query_plans_stack.back() = buildQueryPlanForArrayJoinNode(table_expression,\n@@ -868,11 +869,10 @@ JoinTreeQueryPlan buildJoinTreeQueryPlan(const QueryTreeNodePtr & query_node,\n         }\n         else if (auto * join_node = table_expression->as<JoinNode>())\n         {\n-            size_t table_expressions_column_nodes_with_names_stack_size = query_plans_stack.size();\n-            if (table_expressions_column_nodes_with_names_stack_size < 2)\n+            if (query_plans_stack.size() < 2)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR,\n                     \"Expected at least 2 query plans on stack before JOIN processing. Actual {}\",\n-                    table_expressions_column_nodes_with_names_stack_size);\n+                    query_plans_stack.size());\n \n             auto right_query_plan = std::move(query_plans_stack.back());\n             query_plans_stack.pop_back();\n@@ -901,8 +901,10 @@ JoinTreeQueryPlan buildJoinTreeQueryPlan(const QueryTreeNodePtr & query_node,\n         }\n     }\n \n-    if (query_plans_stack.empty())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Expected at least 1 query plan for JOIN TREE\");\n+    if (query_plans_stack.size() != 1)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR,\n+            \"Expected 1 query plan for JOIN TREE. Actual {}\",\n+            query_plans_stack.size());\n \n     return std::move(query_plans_stack.back());\n }\ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex 5111bd38e58d..c0818302fb2f 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -578,9 +578,9 @@ std::optional<QueryProcessingStage::Enum> StorageDistributed::getOptimizedQueryP\n \n     bool has_aggregates = query_info.has_aggregates;\n     if (query_info.syntax_analyzer_result)\n-        has_aggregates = query_info.syntax_analyzer_result->aggregates.empty();\n+        has_aggregates = !query_info.syntax_analyzer_result->aggregates.empty();\n \n-    if (!has_aggregates || group_by)\n+    if (has_aggregates || group_by)\n     {\n         if (!optimize_sharding_key_aggregation || !group_by || !expr_contains_sharding_key(group_by->children))\n             return {};\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.reference b/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.reference\nnew file mode 100644\nindex 000000000000..2ce5e9558666\n--- /dev/null\n+++ b/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.reference\n@@ -0,0 +1,10 @@\n+45\t0\t0\t0\t1\n+45\t0\t1\t0\t1\n+45\t0\t2\t0\t1\n+45\t0\t3\t0\t1\n+45\t0\t4\t0\t1\n+45\t0\t5\t0\t1\n+45\t0\t6\t0\t1\n+45\t0\t7\t0\t1\n+45\t0\t8\t0\t1\n+45\t0\t9\t0\t1\ndiff --git a/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.sql b/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.sql\nnew file mode 100644\nindex 000000000000..09097eb029fb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.sql\n@@ -0,0 +1,20 @@\n+SET allow_experimental_analyzer = 1;\n+\n+SELECT\n+    sum(a.number) AS total,\n+    c.number AS cn,\n+    b.number AS bn,\n+    grouping(c.number) + grouping(b.number) AS l,\n+    rank() OVER (PARTITION BY grouping(c.number) + grouping(b.number), multiIf(grouping(c.number) = 0, b.number, NULL) ORDER BY sum(a.number) DESC) AS r\n+FROM numbers(10) AS a, numbers(10) AS b, numbers(10) AS c\n+GROUP BY\n+    cn,\n+    bn\n+    WITH ROLLUP\n+ORDER BY\n+    total ASC,\n+    cn ASC,\n+    bn ASC,\n+    l ASC,\n+    r ASC\n+LIMIT 10;\ndiff --git a/tests/queries/0_stateless/02534_analyzer_grouping_function.reference b/tests/queries/0_stateless/02534_analyzer_grouping_function.reference\nnew file mode 100644\nindex 000000000000..fcbf625ef225\n--- /dev/null\n+++ b/tests/queries/0_stateless/02534_analyzer_grouping_function.reference\n@@ -0,0 +1,141 @@\n+-- { echoOn }\n+\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY id, value;\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    grouping(id) UInt64\n+    grouping(value) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      FUNCTION id: 2, function_name: groupingOrdinary, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 1\n+            COLUMN id: 4, column_name: id, result_type: UInt64, source_id: 5\n+      FUNCTION id: 6, function_name: groupingOrdinary, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 7, nodes: 1\n+            COLUMN id: 8, column_name: value, result_type: String, source_id: 5\n+  JOIN TREE\n+    TABLE id: 5, table_name: default.test_table\n+  GROUP BY\n+    LIST id: 9, nodes: 2\n+      COLUMN id: 4, column_name: id, result_type: UInt64, source_id: 5\n+      COLUMN id: 8, column_name: value, result_type: String, source_id: 5\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY id, value ORDER BY grouping_id, grouping_value;\n+0\t0\t0\tValue\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY ROLLUP (id, value);\n+QUERY id: 0, group_by_type: rollup\n+  PROJECTION COLUMNS\n+    grouping(id) UInt64\n+    grouping(value) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      FUNCTION id: 2, function_name: groupingForRollup, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 2\n+            COLUMN id: 4, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      FUNCTION id: 7, function_name: groupingForRollup, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 8, nodes: 2\n+            COLUMN id: 9, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+  JOIN TREE\n+    TABLE id: 6, table_name: default.test_table\n+  GROUP BY\n+    LIST id: 11, nodes: 2\n+      COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY ROLLUP (id, value) ORDER BY grouping_id, grouping_value;\n+0\t0\t0\tValue\n+0\t1\t0\t\n+1\t1\t0\t\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY CUBE (id, value);\n+QUERY id: 0, group_by_type: cube\n+  PROJECTION COLUMNS\n+    grouping(id) UInt64\n+    grouping(value) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      FUNCTION id: 2, function_name: groupingForCube, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 2\n+            COLUMN id: 4, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      FUNCTION id: 7, function_name: groupingForCube, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 8, nodes: 2\n+            COLUMN id: 9, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+  JOIN TREE\n+    TABLE id: 6, table_name: default.test_table\n+  GROUP BY\n+    LIST id: 11, nodes: 2\n+      COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY CUBE (id, value) ORDER BY grouping_id, grouping_value;\n+0\t0\t0\tValue\n+0\t1\t0\t\n+1\t0\t0\tValue\n+1\t1\t0\t\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY GROUPING SETS (id, value);\n+QUERY id: 0, group_by_type: grouping_sets\n+  PROJECTION COLUMNS\n+    grouping(id) UInt64\n+    grouping(value) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      FUNCTION id: 2, function_name: groupingForGroupingSets, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 2\n+            COLUMN id: 4, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      FUNCTION id: 7, function_name: groupingForGroupingSets, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 8, nodes: 2\n+            COLUMN id: 9, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+  JOIN TREE\n+    TABLE id: 6, table_name: default.test_table\n+  GROUP BY\n+    LIST id: 11, nodes: 2\n+      LIST id: 12, nodes: 1\n+        COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      LIST id: 13, nodes: 1\n+        COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY GROUPING SETS (id, value) ORDER BY grouping_id, grouping_value;\n+0\t1\t0\t\n+1\t0\t0\tValue\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY GROUPING SETS ((id), (value));\n+QUERY id: 0, group_by_type: grouping_sets\n+  PROJECTION COLUMNS\n+    grouping(id) UInt64\n+    grouping(value) UInt64\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      FUNCTION id: 2, function_name: groupingForGroupingSets, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 3, nodes: 2\n+            COLUMN id: 4, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      FUNCTION id: 7, function_name: groupingForGroupingSets, function_type: ordinary, result_type: UInt64\n+        ARGUMENTS\n+          LIST id: 8, nodes: 2\n+            COLUMN id: 9, column_name: __grouping_set, result_type: UInt64\n+            COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+  JOIN TREE\n+    TABLE id: 6, table_name: default.test_table\n+  GROUP BY\n+    LIST id: 11, nodes: 2\n+      LIST id: 12, nodes: 1\n+        COLUMN id: 5, column_name: id, result_type: UInt64, source_id: 6\n+      LIST id: 13, nodes: 1\n+        COLUMN id: 10, column_name: value, result_type: String, source_id: 6\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY GROUPING SETS ((id), (value)) ORDER BY grouping_id, grouping_value;\n+0\t1\t0\t\n+1\t0\t0\tValue\ndiff --git a/tests/queries/0_stateless/02534_analyzer_grouping_function.sql b/tests/queries/0_stateless/02534_analyzer_grouping_function.sql\nnew file mode 100644\nindex 000000000000..3163e03d5797\n--- /dev/null\n+++ b/tests/queries/0_stateless/02534_analyzer_grouping_function.sql\n@@ -0,0 +1,41 @@\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS test_table;\n+CREATE TABLE test_table\n+(\n+    id UInt64,\n+    value String\n+) ENGINE=MergeTree ORDER BY id;\n+\n+INSERT INTO test_table VALUES (0, 'Value');\n+\n+-- { echoOn }\n+\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY id, value;\n+\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY id, value ORDER BY grouping_id, grouping_value;\n+\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY ROLLUP (id, value);\n+\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY ROLLUP (id, value) ORDER BY grouping_id, grouping_value;\n+\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY CUBE (id, value);\n+\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY CUBE (id, value) ORDER BY grouping_id, grouping_value;\n+\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY GROUPING SETS (id, value);\n+\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY GROUPING SETS (id, value) ORDER BY grouping_id, grouping_value;\n+\n+EXPLAIN QUERY TREE SELECT grouping(id), grouping(value) FROM test_table GROUP BY GROUPING SETS ((id), (value));\n+\n+SELECT grouping(id) AS grouping_id, grouping(value) AS grouping_value, id, value FROM test_table\n+GROUP BY GROUPING SETS ((id), (value)) ORDER BY grouping_id, grouping_value;\n+\n+-- { echoOff }\n+\n+DROP TABLE test_table;\n",
  "problem_statement": "Not found column ... in block with new analyser\n```\r\nSELECT\r\n    sum(a.number) AS total,\r\n    c.number AS cn,\r\n    b.number AS bn,\r\n    grouping(c.number) + grouping(b.number) AS l,\r\n    rank() OVER (PARTITION BY grouping(c.number) + grouping(b.number), multiIf(grouping(c.number) = 0, b.number, NULL) ORDER BY sum(a.number) DESC) AS r\r\nFROM numbers(10) AS a, numbers(10) AS b, numbers(10) AS c\r\nGROUP BY\r\n    cn,\r\n    bn\r\n    WITH ROLLUP\r\nLIMIT 100\r\nSETTINGS allow_experimental_analyzer = 1\r\n\r\nQuery id: b6102535-438d-4ed8-b14f-8adc0357ec62\r\n\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 22.13.1):\r\nCode: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column a.number_0 in block. There are only columns: c.number_1, b.number_2, sum(a.number_0). Stack trace:\r\n\r\n0. ./build_docker/../src/Common/Exception.cpp:77: DB::Exception::Exception(DB::Exception::MessageMasked const&, int, bool) @ 0xd20361a in /usr/bin/clickhouse\r\n1. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, int, bool) @ 0x80b626d in /usr/bin/clickhouse\r\n2. ./build_docker/../src/Core/Block.cpp:0: DB::Block::getByName(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool) const @ 0x11e28a2e in /usr/bin/clickhouse\r\n3. ./build_docker/../contrib/llvm-project/libcxx/include/vector:1457: DB::Aggregator::Params::getHeader(DB::Block const&, bool, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, std::__1::vector<DB::AggregateDescription, std::__1::allocator<DB::AggregateDescription>> const&, bool) @ 0x124e3324 in /usr/bin/clickhouse\r\n4. ./build_docker/../src/Processors/QueryPlan/RollupStep.cpp:26: DB::RollupStep::RollupStep(DB::DataStream const&, DB::Aggregator::Params, bool, bool) @ 0x140c39d1 in /usr/bin/clickhouse\r\n5. ./build_docker/../contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:701: DB::Planner::buildQueryPlanIfNeeded() @ 0x12e561df in /usr/bin/clickhouse\r\n6. ./build_docker/../src/Planner/Planner.h:38: DB::InterpreterSelectQueryAnalyzer::execute() @ 0x12e5231f in /usr/bin/clickhouse\r\n7. ./build_docker/../src/Interpreters/executeQuery.cpp:0: DB::executeQueryImpl(char const*, char const*, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x1318c5d0 in /usr/bin/clickhouse\r\n8. ./build_docker/../src/Interpreters/executeQuery.cpp:1083: DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x131897cd in /usr/bin/clickhouse\r\n9. ./build_docker/../src/Server/TCPHandler.cpp:0: DB::TCPHandler::runImpl() @ 0x13ccd00f in /usr/bin/clickhouse\r\n10. ./build_docker/../src/Server/TCPHandler.cpp:1922: DB::TCPHandler::run() @ 0x13ce01d9 in /usr/bin/clickhouse\r\n11. ./build_docker/../contrib/poco/Net/src/TCPServerConnection.cpp:57: Poco::Net::TCPServerConnection::start() @ 0x16a30d54 in /usr/bin/clickhouse\r\n12. ./build_docker/../contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:48: Poco::Net::TCPServerDispatcher::run() @ 0x16a3265b in /usr/bin/clickhouse\r\n13. ./build_docker/../contrib/poco/Foundation/src/ThreadPool.cpp:213: Poco::PooledThread::run() @ 0x16bb9847 in /usr/bin/clickhouse\r\n14. ./build_docker/../contrib/poco/Foundation/include/Poco/SharedPtr.h:277: Poco::ThreadImpl::runnableEntry(void*) @ 0x16bb727d in /usr/bin/clickhouse\r\n15. ? @ 0x7f0c04c30609 in ?\r\n16. clone @ 0x7f0c04b55133 in ?\r\n. (NOT_FOUND_COLUMN_IN_BLOCK)\r\n```\r\n\r\ncc: @novikd @kitaisreal \n",
  "hints_text": "",
  "created_at": "2023-01-13T16:54:33Z",
  "modified_files": [
    "b/src/Analyzer/Passes/GroupingFunctionsResolvePass.cpp",
    "b/src/Analyzer/Passes/GroupingFunctionsResolvePass.h",
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Analyzer/QueryTreePassManager.cpp",
    "src/Planner/CollectTableExpressionData.cpp",
    "src/Planner/PlannerAggregation.cpp",
    "src/Planner/PlannerAggregation.h",
    "src/Planner/PlannerExpressionAnalysis.cpp",
    "src/Planner/PlannerExpressionAnalysis.h",
    "src/Planner/PlannerJoinTree.cpp",
    "src/Storages/StorageDistributed.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.reference",
    "b/tests/queries/0_stateless/02532_analyzer_aggregation_with_rollup.sql",
    "b/tests/queries/0_stateless/02534_analyzer_grouping_function.reference",
    "b/tests/queries/0_stateless/02534_analyzer_grouping_function.sql"
  ]
}