{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50153,
  "instance_id": "ClickHouse__ClickHouse-50153",
  "issue_numbers": [
    "44504"
  ],
  "base_commit": "d33caa5215e73bdae1d89876bf4fc13f52139d3d",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex b8ef2152a991..16bd555092e1 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -943,6 +943,26 @@ static FieldRef applyFunction(const FunctionBasePtr & func, const DataTypePtr &\n     return {field.columns, field.row_idx, result_idx};\n }\n \n+/** When table's key has expression with these functions from a column,\n+  * and when a column in a query is compared with a constant, such as:\n+  * CREATE TABLE (x String) ORDER BY toDate(x)\n+  * SELECT ... WHERE x LIKE 'Hello%'\n+  * we want to apply the function to the constant for index analysis,\n+  * but should modify it to pass on unparseable values.\n+  */\n+static std::set<std::string_view> date_time_parsing_functions = {\n+    \"toDate\",\n+    \"toDate32\",\n+    \"toDateTime\",\n+    \"toDateTime64\",\n+    \"ParseDateTimeBestEffort\",\n+    \"ParseDateTimeBestEffortUS\",\n+    \"ParseDateTime32BestEffort\",\n+    \"ParseDateTime64BestEffort\",\n+    \"parseDateTime\",\n+    \"parseDateTimeInJodaSyntax\",\n+};\n+\n /** The key functional expression constraint may be inferred from a plain column in the expression.\n   * For example, if the key contains `toStartOfHour(Timestamp)` and query contains `WHERE Timestamp >= now()`,\n   * it can be assumed that if `toStartOfHour()` is monotonic on [now(), inf), the `toStartOfHour(Timestamp) >= toStartOfHour(now())`\n@@ -1026,10 +1046,24 @@ bool KeyCondition::transformConstantWithValidFunctions(\n                     if (func->type != ActionsDAG::ActionType::FUNCTION)\n                         continue;\n \n+                    const auto & func_name = func->function_base->getName();\n+                    auto func_base = func->function_base;\n+                    const auto & arg_types = func_base->getArgumentTypes();\n+                    if (date_time_parsing_functions.contains(func_name) && !arg_types.empty() && isStringOrFixedString(arg_types[0]))\n+                    {\n+                        auto func_or_null = FunctionFactory::instance().get(func_name + \"OrNull\", context);\n+                        ColumnsWithTypeAndName arguments;\n+                        int i = 0;\n+                        for (const auto & type : func->function_base->getArgumentTypes())\n+                            arguments.push_back({nullptr, type, fmt::format(\"_{}\", i++)});\n+\n+                        func_base = func_or_null->build(arguments);\n+                    }\n+\n                     if (func->children.size() == 1)\n                     {\n                         std::tie(const_value, const_type)\n-                            = applyFunctionForFieldOfUnknownType(func->function_base, const_type, const_value);\n+                            = applyFunctionForFieldOfUnknownType(func_base, const_type, const_value);\n                     }\n                     else if (func->children.size() == 2)\n                     {\n@@ -1040,7 +1074,7 @@ bool KeyCondition::transformConstantWithValidFunctions(\n                             auto left_arg_type = left->result_type;\n                             auto left_arg_value = (*left->column)[0];\n                             std::tie(const_value, const_type) = applyBinaryFunctionForFieldOfUnknownType(\n-                                FunctionFactory::instance().get(func->function_base->getName(), context),\n+                                FunctionFactory::instance().get(func_base->getName(), context),\n                                 left_arg_type, left_arg_value, const_type, const_value);\n                         }\n                         else\n@@ -1048,10 +1082,13 @@ bool KeyCondition::transformConstantWithValidFunctions(\n                             auto right_arg_type = right->result_type;\n                             auto right_arg_value = (*right->column)[0];\n                             std::tie(const_value, const_type) = applyBinaryFunctionForFieldOfUnknownType(\n-                                FunctionFactory::instance().get(func->function_base->getName(), context),\n+                                FunctionFactory::instance().get(func_base->getName(), context),\n                                 const_type, const_value, right_arg_type, right_arg_value);\n                         }\n                     }\n+\n+                    if (const_value.isNull())\n+                        return false;\n                 }\n \n                 out_key_column_num = it->second;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02764_index_analysis_fix.reference b/tests/queries/0_stateless/02764_index_analysis_fix.reference\nnew file mode 100644\nindex 000000000000..8eeacf99fa8c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02764_index_analysis_fix.reference\n@@ -0,0 +1,1 @@\n+2022-10-01 10:10:10\ndiff --git a/tests/queries/0_stateless/02764_index_analysis_fix.sql b/tests/queries/0_stateless/02764_index_analysis_fix.sql\nnew file mode 100644\nindex 000000000000..541a3444ef30\n--- /dev/null\n+++ b/tests/queries/0_stateless/02764_index_analysis_fix.sql\n@@ -0,0 +1,9 @@\n+drop table if exists x;\n+\n+create table x (dt String) engine MergeTree partition by toYYYYMM(toDate(dt)) order by tuple();\n+\n+insert into x values ('2022-10-01 10:10:10');\n+\n+select * from x where dt like '2022-10-01%';\n+\n+drop table x;\n",
  "problem_statement": "Valid queries my fail due to a bug in partition pruning\nwhen i use \"LIKE\" in version 20.3.3.6 is all right,but in 22.3.2.1 something was wrong\r\n```\r\nclickhouse-180 :) show create table act.goodsdeliverflow_local\r\n\r\nSHOW CREATE TABLE act.goodsdeliverflow_local\r\n\r\nQuery id: 846831d1-a00c-4ae4-bbe1-8322dd118141\r\n\r\n\u250c\u2500statement\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 CREATE TABLE act.goodsdeliverflow_local\r\n(\r\n\r\n     .......\r\n    `dtEventTime` String,\r\n     .......\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toYYYYMM(toDate(dtEventTime))\r\nORDER BY (dtEventTime, localeCountryCode, PlatID)\r\nSETTINGS index_granularity = 8192 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n\r\nclickhouse-180 :) select * from act.goodsdeliverflow_local where dtEventTime LIKE '2022-10-01%'\r\n\r\nSELECT *\r\nFROM act.goodsdeliverflow_local\r\nWHERE dtEventTime LIKE '2022-10-01%'\r\n\r\nQuery id: f335868e-edf1-42c3-a7c1-36d774096db6\r\n\r\n\r\n0 rows in set. Elapsed: 0.007 sec.\r\n\r\nReceived exception from server (version 22.3.2):\r\nCode: 6. DB::Exception: Received from localhost:9099. DB::Exception: Cannot parse string '2022-10-01%' as Date: syntax error at position 10 (parsed just '2022-10-01'). (CANNOT_PARSE_TEXT)\r\n\r\nclickhouse-180 :)\r\n````\r\n\r\nwhy i use \"like\" for a `String` column,but the error messsage told me `Cannot parse string to Date`\r\nIs it because the column is the partition key\n",
  "hints_text": "CH tries to run partition pruning with the condition `WHERE dtEventTime LIKE '2022-10-01%'`, which causes the exception.\n> CH tries to run partition pruning with the condition `WHERE dtEventTime LIKE '2022-10-01%'`, which causes the exception.\r\n\r\n@canhld94 \r\ni don't really understand the process,Could you please explain it in more detail?\r\nit's running correctly in CH 20.3.36 .but incorrectly in CH 22.3.2\n> > CH tries to run partition pruning with the condition `WHERE dtEventTime LIKE '2022-10-01%'`, which causes the exception.\r\n> \r\n> @canhld94 i don't really understand the process,Could you please explain it in more detail? it's running correctly in CH 20.3.36 .but incorrectly in CH 22.3.2\r\n\r\nWhen you define the table and query this way, the query will try to prune parts by partition with the condition `dtEventTime LIKE '2022-10-01%'`. Because the partition expression is `toYYYYMM(toDate(dtEventTime))` and `toYYYYMM` is a monotonic function, key condition analysis will try to wrap the right hand side of the expression (i.e. `'2022-10-01%'`) with function `toYYYYMM`, and it throws exception because `'2022-10-01%'` cannot be converted to `Date`. It not only happens with `LIKE` but also `=`. \n> > > CH tries to run partition pruning with the condition `WHERE dtEventTime LIKE '2022-10-01%'`, which causes the exception.\r\n> > \r\n> > \r\n> > @canhld94 i don't really understand the process,Could you please explain it in more detail? it's running correctly in CH 20.3.36 .but incorrectly in CH 22.3.2\r\n> \r\n> When you define the table and query this way, the query will try to prune parts by partition with the condition `dtEventTime LIKE '2022-10-01%'`. Because the partition expression is `toYYYYMM(toDate(dtEventTime))` and `toYYYYMM` is a monotonic function, key condition analysis will try to wrap the right hand side of the expression (i.e. `'2022-10-01%'`) with function `toYYYYMM`, and it throws exception because `'2022-10-01%'` cannot be converted to `Date`. It not only happens with `LIKE` but also `=`.\r\n\r\n@canhld94 \r\n\r\nwhen is change the condition to `WHERE toString(dtEventTime) LIKE '2022-10-01%'`, The error disappeared\r\n\r\nis there any different between these two condition?\r\n\r\n\n> @canhld94\r\n> \r\n> when is change the condition to `WHERE toString(dtEventTime) LIKE '2022-10-01%'`, The error disappeared\r\n> \r\n> is there any different between these two condition?\r\n\r\nThe effect of both conditions are the same I think. But the ways key condition analysis treats them are different. When you use `WHERE toString(dtEventTime) LIKE '2022-10-01%'`, it will no try to wrap the rhs with `toYYYYMM` because the lhs `toString(dtEventTime)` is not a subexpression of partition key expression `toYYYYMM(toDate(dtEventTime))`. The partition pruning logic will not work in this case.\r\n\r\nHowever, I think that you can still use `WHERE toString(dtEventTime) LIKE '2022-10-01%'` as a workaround now. Partition pruning actually doesn't work, but the query still can filter parts based on minmax index of partition columns (created automatically for each part).\r\n\n```\r\ndell9510 :) create table test (dtEventTime String) ENGINE = MergeTree\r\n            PARTITION BY toYYYYMM(toDate(dtEventTime))\r\n            ORDER BY tuple()\r\ndell9510 :) insert into test values ('2022-10-01'), ('2022-10-02')\r\ndell9510 :) set send_logs_level='test'\r\ndell9510 :) select * from test where dtEventTime LIKE '2022-10-01%'\r\n\r\nSELECT *\r\nFROM test\r\nWHERE dtEventTime LIKE '2022-10-01%'\r\n\r\nQuery id: 2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c\r\n\r\n[dell9510] 2022.12.22 17:42:19.864143 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Debug> executeQuery: (from [::1]:37010) select * from test where dtEventTime LIKE '2022-10-01%' (stage: Complete)\r\n[dell9510] 2022.12.22 17:42:19.864539 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Trace> ContextAccess (default): Access granted: SELECT(dtEventTime) ON default.test\r\n[dell9510] 2022.12.22 17:42:19.864649 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Trace> ContextAccess (default): Access granted: SELECT(dtEventTime) ON default.test\r\n[dell9510] 2022.12.22 17:42:19.864706 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Trace> InterpreterSelectQuery: FetchColumns -> Complete\r\n[dell9510] 2022.12.22 17:42:19.864840 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Debug> default.test (73c80b8c-ffbe-496c-86f6-779dea3fc197) (SelectExecutor): Key condition: unknown\r\n[dell9510] 2022.12.22 17:42:19.865245 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Error> executeQuery: Code: 6. DB::Exception: Cannot parse string '2022-10-01%' as Date: syntax error at position 10 (parsed just '2022-10-01'). (CANNOT_PARSE_TEXT) (version 22.8.9.24 (official build)) (from [::1]:37010) (in query: select * from test where dtEventTime LIKE '2022-10-01%'), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xa3efd5a in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n1. DB::throwExceptionForIncompletelyParsedValue(DB::ReadBuffer&, DB::IDataType const&) @ 0xcb92637 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n2. COW<DB::IColumn>::immutable_ptr<DB::IColumn> DB::ConvertThroughParsing<DB::DataTypeString, DB::DataTypeDate, DB::NameToDate, (DB::ConvertFromStringExceptionMode)0, (DB::ConvertFromStringParsingMode)0>::execute<void*>(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, void*) @ 0xcdc837d in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n3. bool DB::callOnIndexAndDataType<DB::DataTypeDate, DB::FunctionConvert<DB::DataTypeDate, DB::NameToDate, DB::ToDateMonotonicity>::executeInternal(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const::'lambda'(auto const&, auto const&)&, DB::ConvertDefaultBehaviorTag>(DB::TypeIndex, auto&&, DB::ConvertDefaultBehaviorTag&&) @ 0xcdbb560 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n4. DB::FunctionConvert<DB::DataTypeDate, DB::NameToDate, DB::ToDateMonotonicity>::executeInternal(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xcdba9ea in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n5. DB::FunctionConvert<DB::DataTypeDate, DB::NameToDate, DB::ToDateMonotonicity>::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xcdb9ebc in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n6. DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xcb7b66e in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n7. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x13cbcc67 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n8. DB::IExecutableFunction::defaultImplementationForConstantArguments(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x13cbc72d in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n9. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x13cbcc0d in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n10. DB::IExecutableFunction::executeWithoutSparseColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x13cbd55d in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n11. DB::IExecutableFunction::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x13cbea09 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n12. DB::IFunctionBase::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xcb7b12d in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n13. DB::KeyCondition::transformConstantWithValidFunctions(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, unsigned long&, std::__1::shared_ptr<DB::IDataType const>&, DB::Field&, std::__1::shared_ptr<DB::IDataType const>&, std::__1::function<bool (DB::IFunctionBase&, DB::IDataType const&)>) const @ 0x157f05e0 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n14. DB::KeyCondition::canConstantBeWrappedByMonotonicFunctions(DB::KeyCondition::Tree const&, unsigned long&, std::__1::shared_ptr<DB::IDataType const>&, DB::Field&, std::__1::shared_ptr<DB::IDataType const>&) @ 0x157f11a0 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n15. DB::KeyCondition::tryParseAtomFromAST(DB::KeyCondition::Tree const&, std::__1::shared_ptr<DB::Context const>, DB::Block&, DB::KeyCondition::RPNElement&) @ 0x157ee04b in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n16. DB::KeyCondition::traverseAST(DB::KeyCondition::Tree const&, std::__1::shared_ptr<DB::Context const>, DB::Block&) @ 0x157ebb06 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n17. DB::KeyCondition::KeyCondition(std::__1::shared_ptr<DB::IAST> const&, std::__1::vector<std::__1::shared_ptr<DB::IAST>, std::__1::allocator<std::__1::shared_ptr<DB::IAST> > > const&, std::__1::shared_ptr<DB::TreeRewriterResult const>, std::__1::shared_ptr<DB::PreparedSets>, std::__1::shared_ptr<DB::Context const>, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, std::__1::shared_ptr<DB::ExpressionActions> const&, bool, bool) @ 0x157eb46f in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n18. DB::MergeTreeDataSelectExecutor::filterPartsByPartition(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const> > >&, std::__1::optional<std::__1::unordered_set<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > > const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, DB::MergeTreeData const&, DB::SelectQueryInfo const&, std::__1::shared_ptr<DB::Context const> const&, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, long, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, long> > > const*, Poco::Logger*, std::__1::vector<DB::ReadFromMergeTree::IndexStat, std::__1::allocator<DB::ReadFromMergeTree::IndexStat> >&) @ 0x158fe038 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n19. DB::ReadFromMergeTree::selectRangesToRead(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const> > >, std::__1::shared_ptr<DB::PrewhereInfo> const&, DB::ActionDAGNodes const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, DB::SelectQueryInfo const&, std::__1::shared_ptr<DB::Context const>, unsigned int, std::__1::shared_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, long, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, long> > > >, DB::MergeTreeData const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, bool, Poco::Logger*) @ 0x160142c5 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n20. DB::ReadFromMergeTree::selectRangesToRead(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const> > >) const @ 0x16013210 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n21. DB::ReadFromMergeTree::getAnalysisResult() const @ 0x16015efd in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n22. DB::ReadFromMergeTree::initializePipeline(DB::QueryPipelineBuilder&, DB::BuildQueryPipelineSettings const&) @ 0x1601644c in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n23. DB::ISourceStep::updatePipeline(std::__1::vector<std::__1::unique_ptr<DB::QueryPipelineBuilder, std::__1::default_delete<DB::QueryPipelineBuilder> >, std::__1::allocator<std::__1::unique_ptr<DB::QueryPipelineBuilder, std::__1::default_delete<DB::QueryPipelineBuilder> > > >, DB::BuildQueryPipelineSettings const&) @ 0x15fdf526 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n24. DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&) @ 0x15ff9d7c in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n25. DB::InterpreterSelectWithUnionQuery::execute() @ 0x14e74a42 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n26. ? @ 0x15165569 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n27. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x15162a97 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n28. DB::TCPHandler::runImpl() @ 0x15c5a96c in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n29. DB::TCPHandler::run() @ 0x15c6ef79 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n30. Poco::Net::TCPServerConnection::start() @ 0x189dd3f3 in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n31. Poco::Net::TCPServerDispatcher::run() @ 0x189de74d in /home/tavplubix/ch/ClickHouse/utils/_bisect/bin/clickhouse_22.8.9.24\r\n\r\n[dell9510] 2022.12.22 17:42:19.865391 [ 1362319 ] {2d6e0618-47aa-4d55-a2a9-a6a1c224ab3c} <Unknown> TCPHandler: Going to close connection due to exception: Cannot parse string '2022-10-01%' as Date: syntax error at position 10 (parsed just '2022-10-01')\r\n\r\n0 rows in set. Elapsed: 0.004 sec. \r\n\r\n```\r\ncc: @amosbird \n@amosbird I think the easiest way is to put a try-catch block in `DB::KeyCondition::transformConstantWithValidFunctions`. Otherwise, we need to implement a function like `tryExecute` for `IFunction`, which is quite a burden.\n@canhld94 It's not allowed to introduce exceptions in a normal code path.\r\n\r\nI think we can extend the function node of `ActionsDAG` to contain an additional `-OrNull` variant, which can be used during index analysis.\n> @canhld94 It's not allowed to introduce exceptions in a normal code path.\r\n> \r\n> I think we can extend the function node of `ActionsDAG` to contain an additional `-OrNull` variant, which can be used during index analysis.\r\n\r\nCan we do it in `applyFunctionForFieldOfUnknownType` and `applyBinaryFunctionForFieldOfUnknownType`? For example, we can try to replace the function with `-OrNull` variant, and break the chain if `const_value` is `NULL` after applying a function.\nI think the proper fix would be to only specialize date and datetime parsing functions during key analysis. This should cover most sane use cases.",
  "created_at": "2023-05-23T15:13:27Z"
}