diff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h
index 291a287919d7..446d6c008f06 100644
--- a/src/Functions/FunctionsComparison.h
+++ b/src/Functions/FunctionsComparison.h
@@ -1279,8 +1279,15 @@ class FunctionComparison : public IFunction
         bool date_and_datetime = (which_left.idx != which_right.idx) && (which_left.isDate() || which_left.isDate32() || which_left.isDateTime() || which_left.isDateTime64())
             && (which_right.isDate() || which_right.isDate32() || which_right.isDateTime() || which_right.isDateTime64());
 
+        /// Interval data types can be compared only when having equal units.
+        bool left_is_interval = which_left.isInterval();
+        bool right_is_interval = which_right.isInterval();
+
+        bool types_equal = left_type->equals(*right_type);
+
         ColumnPtr res;
-        if (left_is_num && right_is_num && !date_and_datetime)
+        if (left_is_num && right_is_num && !date_and_datetime
+            && (!left_is_interval || !right_is_interval || types_equal))
         {
             if (!((res = executeNumLeftType<UInt8>(col_left_untyped, col_right_untyped))
                 || (res = executeNumLeftType<UInt16>(col_left_untyped, col_right_untyped))
@@ -1372,7 +1379,7 @@ class FunctionComparison : public IFunction
                 throw Exception(ErrorCodes::LOGICAL_ERROR, "Date related common types can only be UInt32/UInt64/Int32/Decimal");
             return res;
         }
-        else if (left_type->equals(*right_type))
+        else if (types_equal)
         {
             return executeGenericIdenticalTypes(col_left_untyped, col_right_untyped);
         }
diff --git a/src/Interpreters/InterpreterShowIndexesQuery.cpp b/src/Interpreters/InterpreterShowIndexesQuery.cpp
index 63cda814683b..549afd325062 100644
--- a/src/Interpreters/InterpreterShowIndexesQuery.cpp
+++ b/src/Interpreters/InterpreterShowIndexesQuery.cpp
@@ -89,7 +89,7 @@ ORDER BY index_type, expression, column_name, seq_in_index;)", database, table,
     ///   can be functional indexes.
     /// Above SELECT tries to emulate that. Caveats:
     /// 1. The primary key index sub-SELECT assumes the primary key expression is non-functional. Non-functional primary key indexes in
-    ///    ClickHouse are possible but quiete obscure. In MySQL they are not possible at all.
+    ///    ClickHouse are possible but quite obscure. In MySQL they are not possible at all.
     /// 2. Related to 1.: Poor man's tuple parsing with splitByString() in the PK sub-SELECT messes up for functional primary key index
     ///    expressions where the comma is not only used as separator between tuple components, e.g. in 'col1 + 1, concat(col2, col3)'.
     /// 3. The data skipping index sub-SELECT assumes the index expression is functional. 3rd party tools that expect MySQL semantics from
@@ -106,4 +106,3 @@ BlockIO InterpreterShowIndexesQuery::execute()
 
 
 }
-
