diff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp
index fdf3d91b9361..0b6d992e2937 100644
--- a/src/Planner/Planner.cpp
+++ b/src/Planner/Planner.cpp
@@ -1062,6 +1062,16 @@ void addPreliminarySortOrDistinctOrLimitStepsIfNeeded(
         addLimitByStep(query_plan, limit_by_analysis_result, query_node, true /*do_not_skip_offset*/);
     }
 
+    /// Do not apply PreLimit at first stage for LIMIT BY and `exact_rows_before_limit`,
+    /// as it may break `rows_before_limit_at_least` value during the second stage in
+    /// case it also contains LIMIT BY
+    const Settings & settings = planner_context->getQueryContext()->getSettingsRef();
+
+    if (query_node.hasLimitBy() && settings[Setting::exact_rows_before_limit])
+    {
+        return;
+    }
+
     /// WITH TIES simply not supported properly for preliminary steps, so let's disable it.
     if (query_node.hasLimit() && !query_node.hasLimitByOffset() && !query_node.isLimitWithTies())
         addPreliminaryLimitStep(query_plan, query_analysis_result, planner_context, true /*do_not_skip_offset*/);
diff --git a/src/Processors/Transforms/LimitByTransform.cpp b/src/Processors/Transforms/LimitByTransform.cpp
index 9ca84f7a2cc2..80041e2ff2ee 100644
--- a/src/Processors/Transforms/LimitByTransform.cpp
+++ b/src/Processors/Transforms/LimitByTransform.cpp
@@ -64,6 +64,9 @@ void LimitByTransform::transform(Chunk & chunk)
                 column = column->filter(filter, inserted_count);
     }
 
+    if (rows_before_limit_at_least)
+        rows_before_limit_at_least->add(inserted_count);
+
     chunk.setColumns(std::move(columns), inserted_count);
 }
 
diff --git a/src/Processors/Transforms/LimitByTransform.h b/src/Processors/Transforms/LimitByTransform.h
index 8c2b46af69ef..020bbd93f05a 100644
--- a/src/Processors/Transforms/LimitByTransform.h
+++ b/src/Processors/Transforms/LimitByTransform.h
@@ -1,5 +1,6 @@
 #pragma once
 #include <Processors/ISimpleTransform.h>
+#include <Processors/RowsBeforeStepCounter.h>
 #include <Common/HashTable/HashMap.h>
 
 
@@ -14,6 +15,8 @@ class LimitByTransform : public ISimpleTransform
 
     String getName() const override { return "LimitByTransform"; }
 
+    void setRowsBeforeLimitCounter(RowsBeforeStepCounterPtr counter) override { rows_before_limit_at_least.swap(counter); }
+
 protected:
     void transform(Chunk & chunk) override;
 
@@ -24,6 +27,8 @@ class LimitByTransform : public ISimpleTransform
     std::vector<size_t> key_positions;
     const UInt64 group_length;
     const UInt64 group_offset;
+
+    RowsBeforeStepCounterPtr rows_before_limit_at_least;
 };
 
 }
diff --git a/src/QueryPipeline/QueryPipeline.cpp b/src/QueryPipeline/QueryPipeline.cpp
index 7e1fc90c1dc3..b2f8d9cc6362 100644
--- a/src/QueryPipeline/QueryPipeline.cpp
+++ b/src/QueryPipeline/QueryPipeline.cpp
@@ -22,6 +22,7 @@
 #include <Processors/Transforms/AggregatingTransform.h>
 #include <Processors/Transforms/CountingTransform.h>
 #include <Processors/Transforms/ExpressionTransform.h>
+#include <Processors/Transforms/LimitByTransform.h>
 #include <Processors/Transforms/LimitsCheckingTransform.h>
 #include <Processors/Transforms/MaterializingTransform.h>
 #include <Processors/Transforms/PartialSortingTransform.h>
@@ -178,7 +179,8 @@ static void initRowsBeforeLimit(IOutputFormat * output_format)
         ///   2. Limit ... PartialSorting: Set counter on PartialSorting
         ///   3. Limit ... TotalsHaving(with filter) ... Remote: Set counter on the input port of Limit
         ///   4. Limit ... Remote: Set counter on Remote
-        ///   5. Limit ... : Set counter on the input port of Limit
+        ///   5. Limit ... LimitBy: Set counter on LimitBy, as it may not be executed on initiator
+        ///   6. Limit ... : Set counter on the input port of Limit
 
         /// Case 1.
         if ((typeid_cast<RemoteSource *>(processor) || typeid_cast<DelayedSource *>(processor)) && !limit_processor)
@@ -222,6 +224,14 @@ static void initRowsBeforeLimit(IOutputFormat * output_format)
                 limit_candidates[limit_processor].push_back(limit_input_port);
                 continue;
             }
+
+            /// Case 5.
+            if (typeid_cast<LimitByTransform *>(processor))
+            {
+                processors.emplace_back(processor);
+                limit_candidates[limit_processor].push_back(limit_input_port);
+                continue;
+            }
         }
 
         /// Skip totals and extremes port for output format.
@@ -256,7 +266,7 @@ static void initRowsBeforeLimit(IOutputFormat * output_format)
         }
     }
 
-    /// Case 5.
+    /// Case 6.
     for (auto && [limit, ports] : limit_candidates)
     {
         /// If there are some input ports which don't have the counter, add it to LimitTransform.
