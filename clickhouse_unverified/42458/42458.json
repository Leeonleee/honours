{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42458,
  "instance_id": "ClickHouse__ClickHouse-42458",
  "issue_numbers": [
    "37333"
  ],
  "base_commit": "2a7f5823a6dcfdc84155ed6aec9e357351b735ad",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 927ca98cc9a0..8fc5f13d27da 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -86,6 +86,88 @@ String extractFixedPrefixFromLikePattern(const String & like_pattern)\n     return fixed_prefix;\n }\n \n+/// for \"^prefix...\" string it returns \"prefix\"\n+static String extractFixedPrefixFromRegularExpression(const String & regexp)\n+{\n+    if (regexp.size() <= 1 || regexp[0] != '^')\n+        return {};\n+\n+    String fixed_prefix;\n+    const char * begin = regexp.data() + 1;\n+    const char * pos = begin;\n+    const char * end = regexp.data() + regexp.size();\n+\n+    while (pos != end)\n+    {\n+        switch (*pos)\n+        {\n+            case '\\0':\n+                pos = end;\n+                break;\n+\n+            case '\\\\':\n+            {\n+                ++pos;\n+                if (pos == end)\n+                    break;\n+\n+                switch (*pos)\n+                {\n+                    case '|':\n+                    case '(':\n+                    case ')':\n+                    case '^':\n+                    case '$':\n+                    case '.':\n+                    case '[':\n+                    case '?':\n+                    case '*':\n+                    case '+':\n+                    case '{':\n+                        fixed_prefix += *pos;\n+                        break;\n+                    default:\n+                        /// all other escape sequences are not supported\n+                        pos = end;\n+                        break;\n+                }\n+\n+                ++pos;\n+                break;\n+            }\n+\n+            /// non-trivial cases\n+            case '|':\n+                fixed_prefix.clear();\n+                [[fallthrough]];\n+            case '(':\n+            case '[':\n+            case '^':\n+            case '$':\n+            case '.':\n+            case '+':\n+                pos = end;\n+                break;\n+\n+            /// Quantifiers that allow a zero number of occurrences.\n+            case '{':\n+            case '?':\n+            case '*':\n+                if (!fixed_prefix.empty())\n+                    fixed_prefix.pop_back();\n+\n+                pos = end;\n+                break;\n+            default:\n+                fixed_prefix += *pos;\n+                pos++;\n+                break;\n+        }\n+    }\n+\n+    return fixed_prefix;\n+}\n+\n \n /** For a given string, get a minimum string that is strictly greater than all strings with this prefix,\n   *  or return an empty string if there are no such strings.\n@@ -581,6 +663,27 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n             return true;\n         }\n     },\n+    {\n+        \"match\",\n+        [] (RPNElement & out, const Field & value)\n+        {\n+            if (value.getType() != Field::Types::String)\n+                return false;\n+\n+            String prefix = extractFixedPrefixFromRegularExpression(value.get<const String &>());\n+            if (prefix.empty())\n+                return false;\n+\n+            String right_bound = firstStringThatIsGreaterThanAllStringsWithPrefix(prefix);\n+\n+            out.function = RPNElement::FUNCTION_IN_RANGE;\n+            out.range = !right_bound.empty()\n+                ? Range(prefix, true, right_bound, false)\n+                : Range::createLeftBounded(prefix, true);\n+\n+            return true;\n+        }\n+    },\n     {\n         \"isNotNull\",\n         [] (RPNElement & out, const Field &)\n@@ -1738,7 +1841,7 @@ bool KeyCondition::tryParseAtomFromAST(const Tree & node, ContextPtr context, Bl\n                 else if (func_name == \"in\" || func_name == \"notIn\" ||\n                          func_name == \"like\" || func_name == \"notLike\" ||\n                          func_name == \"ilike\" || func_name == \"notIlike\" ||\n-                         func_name == \"startsWith\")\n+                         func_name == \"startsWith\" || func_name == \"match\")\n                 {\n                     /// \"const IN data_column\" doesn't make sense (unlike \"data_column IN const\")\n                     return false;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02462_match_regexp_pk.reference b/tests/queries/0_stateless/02462_match_regexp_pk.reference\nnew file mode 100644\nindex 000000000000..428d6556f4cc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02462_match_regexp_pk.reference\n@@ -0,0 +1,5 @@\n+4\n+1\n+3\n+4\n+4\ndiff --git a/tests/queries/0_stateless/02462_match_regexp_pk.sql b/tests/queries/0_stateless/02462_match_regexp_pk.sql\nnew file mode 100644\nindex 000000000000..1a944b961962\n--- /dev/null\n+++ b/tests/queries/0_stateless/02462_match_regexp_pk.sql\n@@ -0,0 +1,9 @@\n+CREATE TABLE mt_match_pk (v String) ENGINE = MergeTree ORDER BY v SETTINGS index_granularity = 1;\n+INSERT INTO mt_match_pk VALUES ('a'), ('aaa'), ('aba'), ('bac'), ('acccca');\n+\n+SET force_primary_key = 1;\n+SELECT count() FROM mt_match_pk WHERE match(v, '^a');\n+SELECT count() FROM mt_match_pk WHERE match(v, '^ab');\n+SELECT count() FROM mt_match_pk WHERE match(v, '^a.');\n+SELECT count() FROM mt_match_pk WHERE match(v, '^ab*');\n+SELECT count() FROM mt_match_pk WHERE match(v, '^ac?');\n",
  "problem_statement": "`match` function can use index if it's a condition on string prefix.\n`SELECT ... WHERE match(key, '^prefix...')`\r\nshould use index similarly to\r\n`SELECT ... WHERE key LIKE 'prefix%'`\n",
  "hints_text": "",
  "created_at": "2022-10-18T19:38:06Z"
}