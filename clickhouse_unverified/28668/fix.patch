diff --git a/programs/copier/ClusterCopier.cpp b/programs/copier/ClusterCopier.cpp
index 8b6cb9a98810..141a6d4f911d 100644
--- a/programs/copier/ClusterCopier.cpp
+++ b/programs/copier/ClusterCopier.cpp
@@ -744,8 +744,8 @@ std::shared_ptr<ASTCreateQuery> rewriteCreateQueryStorage(const ASTPtr & create_
     if (create.storage == nullptr || new_storage_ast == nullptr)
         throw Exception("Storage is not specified", ErrorCodes::LOGICAL_ERROR);
 
-    res->database = new_table.first;
-    res->table = new_table.second;
+    res->setDatabase(new_table.first);
+    res->setTable(new_table.second);
 
     res->children.clear();
     res->set(res->columns_list, create.columns_list->clone());
@@ -1659,7 +1659,7 @@ TaskStatus ClusterCopier::processPartitionPieceTaskImpl(
 void ClusterCopier::dropAndCreateLocalTable(const ASTPtr & create_ast)
 {
     const auto & create = create_ast->as<ASTCreateQuery &>();
-    dropLocalTableIfExists({create.database, create.table});
+    dropLocalTableIfExists({create.getDatabase(), create.getTable()});
 
     auto create_context = Context::createCopy(getContext());
 
@@ -1671,8 +1671,8 @@ void ClusterCopier::dropLocalTableIfExists(const DatabaseAndTableName & table_na
 {
     auto drop_ast = std::make_shared<ASTDropQuery>();
     drop_ast->if_exists = true;
-    drop_ast->database = table_name.first;
-    drop_ast->table = table_name.second;
+    drop_ast->setDatabase(table_name.first);
+    drop_ast->setTable(table_name.second);
 
     auto drop_context = Context::createCopy(getContext());
 
diff --git a/src/Backups/BackupUtils.cpp b/src/Backups/BackupUtils.cpp
index bd5a31e0bf70..5da87cfd6f7b 100644
--- a/src/Backups/BackupUtils.cpp
+++ b/src/Backups/BackupUtils.cpp
@@ -312,11 +312,11 @@ namespace
     String getDataPathInBackup(const IAST & create_query)
     {
         const auto & create = create_query.as<const ASTCreateQuery &>();
-        if (create.table.empty())
+        if (!create.table)
             return {};
         if (create.temporary)
-            return getDataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.table});
-        return getDataPathInBackup({create.database, create.table});
+            return getDataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.getTable()});
+        return getDataPathInBackup({create.getDatabase(), create.getTable()});
     }
 
     String getMetadataPathInBackup(const DatabaseAndTableName & table_name)
@@ -336,11 +336,11 @@ namespace
     String getMetadataPathInBackup(const IAST & create_query)
     {
         const auto & create = create_query.as<const ASTCreateQuery &>();
-        if (create.table.empty())
-            return getMetadataPathInBackup(create.database);
+        if (!create.table)
+            return getMetadataPathInBackup(create.getDatabase());
         if (create.temporary)
-            return getMetadataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.table});
-        return getMetadataPathInBackup({create.database, create.table});
+            return getMetadataPathInBackup({DatabaseCatalog::TEMPORARY_DATABASE, create.getTable()});
+        return getMetadataPathInBackup({create.getDatabase(), create.getTable()});
     }
 
     void backupCreateQuery(const IAST & create_query, BackupEntries & backup_entries)
@@ -419,7 +419,7 @@ namespace
 
         /// We create and execute `create` query for the database name.
         auto create_query = std::make_shared<ASTCreateQuery>();
-        create_query->database = database_name;
+        create_query->setDatabase(database_name);
         create_query->if_not_exists = true;
         InterpreterCreateQuery create_interpreter{create_query, context};
         create_interpreter.execute();
@@ -460,7 +460,7 @@ namespace
 
         restore_tasks.emplace_back([table_name, new_create_query, partitions, context, backup]() -> RestoreDataTasks
         {
-            DatabaseAndTableName new_table_name{new_create_query->database, new_create_query->table};
+            DatabaseAndTableName new_table_name{new_create_query->getDatabase(), new_create_query->getTable()};
             if (new_create_query->temporary)
                 new_table_name.first = DatabaseCatalog::TEMPORARY_DATABASE;
 
@@ -536,7 +536,7 @@ namespace
 
         restore_tasks.emplace_back([database_name, new_create_query, except_list, context, backup, renaming_config]() -> RestoreDataTasks
         {
-            const String & new_database_name = new_create_query->database;
+            const String & new_database_name = new_create_query->getDatabase();
             context->checkAccess(AccessType::SHOW_TABLES, new_database_name);
 
             if (!DatabaseCatalog::instance().isDatabaseExist(new_database_name))
diff --git a/src/Backups/renameInCreateQuery.cpp b/src/Backups/renameInCreateQuery.cpp
index 4c78844d2662..7a94a755f677 100644
--- a/src/Backups/renameInCreateQuery.cpp
+++ b/src/Backups/renameInCreateQuery.cpp
@@ -48,21 +48,23 @@ namespace
         {
             if (create.temporary)
             {
-                if (create.table.empty())
+                if (!create.table)
                     throw Exception(ErrorCodes::LOGICAL_ERROR, "Table name specified in the CREATE TEMPORARY TABLE query must not be empty");
-                create.table = data.renaming_config->getNewTemporaryTableName(create.table);
+                create.setTable(data.renaming_config->getNewTemporaryTableName(create.getTable()));
             }
-            else if (create.table.empty())
+            else if (!create.table)
             {
-                if (create.database.empty())
+                if (!create.database)
                     throw Exception(ErrorCodes::LOGICAL_ERROR, "Database name specified in the CREATE DATABASE query must not be empty");
-                create.database = data.renaming_config->getNewDatabaseName(create.database);
+                create.setDatabase(data.renaming_config->getNewDatabaseName(create.getDatabase()));
             }
             else
             {
-                if (create.database.empty())
+                if (!create.database)
                     throw Exception(ErrorCodes::LOGICAL_ERROR, "Database name specified in the CREATE TABLE query must not be empty");
-                std::tie(create.database, create.table) = data.renaming_config->getNewTableName({create.database, create.table});
+                auto table_and_database_name = data.renaming_config->getNewTableName({create.getDatabase(), create.getTable()});
+                create.setDatabase(table_and_database_name.first);
+                create.setTable(table_and_database_name.second);
             }
 
             create.uuid = UUIDHelpers::Nil;
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index 3998f5586203..c4b4009a5ff4 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -490,7 +490,7 @@ void ClientBase::processOrdinaryQuery(const String & query_to_execute, ASTPtr pa
         ReplaceQueryParameterVisitor visitor(query_parameters);
         visitor.visit(parsed_query);
 
-        /// Get new query after substitutions. Note that it cannot be done for INSERT query with embedded data.
+        /// Get new query after substitutions.
         query = serializeAST(*parsed_query);
     }
 
@@ -824,6 +824,17 @@ bool ClientBase::receiveSampleBlock(Block & out, ColumnsDescription & columns_de
 
 void ClientBase::processInsertQuery(const String & query_to_execute, ASTPtr parsed_query)
 {
+    auto query = query_to_execute;
+    if (!query_parameters.empty())
+    {
+        /// Replace ASTQueryParameter with ASTLiteral for prepared statements.
+        ReplaceQueryParameterVisitor visitor(query_parameters);
+        visitor.visit(parsed_query);
+
+        /// Get new query after substitutions.
+        query = serializeAST(*parsed_query);
+    }
+
     /// Process the query that requires transferring data blocks to the server.
     const auto parsed_insert_query = parsed_query->as<ASTInsertQuery &>();
     if ((!parsed_insert_query.data && !parsed_insert_query.infile) && (is_interactive || (!stdin_is_a_tty && std_in.eof())))
@@ -831,7 +842,7 @@ void ClientBase::processInsertQuery(const String & query_to_execute, ASTPtr pars
 
     connection->sendQuery(
         connection_parameters.timeouts,
-        query_to_execute,
+        query,
         global_context->getCurrentQueryId(),
         query_processing_stage,
         &global_context->getSettingsRef(),
@@ -884,8 +895,7 @@ void ClientBase::sendData(Block & sample, const ColumnsDescription & columns_des
         /// Get name of this file (path to file)
         const auto & in_file_node = parsed_insert_query->infile->as<ASTLiteral &>();
         const auto in_file = in_file_node.value.safeGet<std::string>();
-        /// Get name of table
-        const auto table_name = parsed_insert_query->table_id.getTableName();
+
         std::string compression_method;
         /// Compression method can be specified in query
         if (parsed_insert_query->compression)
diff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp
index 0ada66b806a4..76e836a9b71a 100644
--- a/src/Databases/DatabaseAtomic.cpp
+++ b/src/Databases/DatabaseAtomic.cpp
@@ -295,9 +295,9 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora
     try
     {
         std::unique_lock lock{mutex};
-        if (query.database != database_name)
+        if (query.getDatabase() != database_name)
             throw Exception(ErrorCodes::UNKNOWN_DATABASE, "Database was renamed to `{}`, cannot create table in `{}`",
-                            database_name, query.database);
+                            database_name, query.getDatabase());
         /// Do some checks before renaming file from .tmp to .sql
         not_in_use = cleanupDetachedTables();
         assertDetachedTableNotInUse(query.uuid);
@@ -314,8 +314,8 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora
 
         /// It throws if `table_metadata_path` already exists (it's possible if table was detached)
         renameNoReplace(table_metadata_tmp_path, table_metadata_path);  /// Commit point (a sort of)
-        attachTableUnlocked(query.table, table, lock);   /// Should never throw
-        table_name_to_path.emplace(query.table, table_data_path);
+        attachTableUnlocked(query.getTable(), table, lock);   /// Should never throw
+        table_name_to_path.emplace(query.getTable(), table_data_path);
     }
     catch (...)
     {
@@ -325,7 +325,7 @@ void DatabaseAtomic::commitCreateTable(const ASTCreateQuery & query, const Stora
         throw;
     }
     if (table->storesDataOnDisk())
-        tryCreateSymlink(query.table, table_data_path);
+        tryCreateSymlink(query.getTable(), table_data_path);
 }
 
 void DatabaseAtomic::commitAlterTable(const StorageID & table_id, const String & table_metadata_tmp_path, const String & table_metadata_path,
diff --git a/src/Databases/DatabaseFactory.cpp b/src/Databases/DatabaseFactory.cpp
index 03d913246728..74b103afbc42 100644
--- a/src/Databases/DatabaseFactory.cpp
+++ b/src/Databases/DatabaseFactory.cpp
@@ -103,7 +103,7 @@ static inline ValueType safeGetLiteralValue(const ASTPtr &ast, const String &eng
 DatabasePtr DatabaseFactory::getImpl(const ASTCreateQuery & create, const String & metadata_path, ContextPtr context)
 {
     auto * engine_define = create.storage;
-    const String & database_name = create.database;
+    const String & database_name = create.getDatabase();
     const String & engine_name = engine_define->engine->name;
     const UUID & uuid = create.uuid;
 
diff --git a/src/Databases/DatabaseMemory.cpp b/src/Databases/DatabaseMemory.cpp
index 288f34ad7d18..8128bb8378e0 100644
--- a/src/Databases/DatabaseMemory.cpp
+++ b/src/Databases/DatabaseMemory.cpp
@@ -75,7 +75,7 @@ void DatabaseMemory::dropTable(
 ASTPtr DatabaseMemory::getCreateDatabaseQuery() const
 {
     auto create_query = std::make_shared<ASTCreateQuery>();
-    create_query->database = getDatabaseName();
+    create_query->setDatabase(getDatabaseName());
     create_query->set(create_query->storage, std::make_shared<ASTStorage>());
     create_query->storage->set(create_query->storage->engine, makeASTFunction(getEngineName()));
 
diff --git a/src/Databases/DatabaseMemory.h b/src/Databases/DatabaseMemory.h
index a661d1c49b0f..b854d9be1f34 100644
--- a/src/Databases/DatabaseMemory.h
+++ b/src/Databases/DatabaseMemory.h
@@ -42,7 +42,7 @@ class DatabaseMemory final : public DatabaseWithOwnTablesBase
     /// TODO May be it's better to use DiskMemory for such tables.
     ///      To save data on disk it's possible to explicitly CREATE DATABASE db ENGINE=Ordinary in clickhouse-local.
     String getTableDataPath(const String & table_name) const override { return data_path + escapeForFileName(table_name) + "/"; }
-    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.table); }
+    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.getTable()); }
 
     UUID tryGetTableUUID(const String & table_name) const override;
 
diff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp
index 55e5a3071bcb..a1e0a8257361 100644
--- a/src/Databases/DatabaseOnDisk.cpp
+++ b/src/Databases/DatabaseOnDisk.cpp
@@ -51,7 +51,7 @@ std::pair<String, StoragePtr> createTableFromAST(
     bool force_restore)
 {
     ast_create_query.attach = true;
-    ast_create_query.database = database_name;
+    ast_create_query.setDatabase(database_name);
 
     if (ast_create_query.as_table_function)
     {
@@ -60,9 +60,9 @@ std::pair<String, StoragePtr> createTableFromAST(
         ColumnsDescription columns;
         if (ast_create_query.columns_list && ast_create_query.columns_list->columns)
             columns = InterpreterCreateQuery::getColumnsDescription(*ast_create_query.columns_list->columns, context, true);
-        StoragePtr storage = table_function->execute(ast_create_query.as_table_function, context, ast_create_query.table, std::move(columns));
+        StoragePtr storage = table_function->execute(ast_create_query.as_table_function, context, ast_create_query.getTable(), std::move(columns));
         storage->renameInMemory(ast_create_query);
-        return {ast_create_query.table, storage};
+        return {ast_create_query.getTable(), storage};
     }
 
     ColumnsDescription columns;
@@ -82,7 +82,7 @@ std::pair<String, StoragePtr> createTableFromAST(
 
     return
     {
-        ast_create_query.table,
+        ast_create_query.getTable(),
         StorageFactory::instance().get(
             ast_create_query,
             table_data_path_relative,
@@ -112,7 +112,7 @@ String getObjectDefinitionFromCreateQuery(const ASTPtr & query)
 
     /// We remove everything that is not needed for ATTACH from the query.
     assert(!create->temporary);
-    create->database.clear();
+    create->database.reset();
     create->as_database.clear();
     create->as_table.clear();
     create->if_not_exists = false;
@@ -129,7 +129,7 @@ String getObjectDefinitionFromCreateQuery(const ASTPtr & query)
     create->out_file = nullptr;
 
     if (create->uuid != UUIDHelpers::Nil)
-        create->table = TABLE_WITH_UUID_NAME_PLACEHOLDER;
+        create->setTable(TABLE_WITH_UUID_NAME_PLACEHOLDER);
 
     WriteBufferFromOwnString statement_buf;
     formatAST(*create, statement_buf, false);
@@ -161,7 +161,7 @@ void DatabaseOnDisk::createTable(
 {
     const auto & settings = local_context->getSettingsRef();
     const auto & create = query->as<ASTCreateQuery &>();
-    assert(table_name == create.table);
+    assert(table_name == create.getTable());
 
     /// Create a file with metadata if necessary - if the query is not ATTACH.
     /// Write the query of `ATTACH table` to it.
@@ -251,7 +251,7 @@ void DatabaseOnDisk::commitCreateTable(const ASTCreateQuery & query, const Stora
     try
     {
         /// Add a table to the map of known tables.
-        attachTable(query.table, table, getTableDataPath(query));
+        attachTable(query.getTable(), table, getTableDataPath(query));
 
         /// If it was ATTACH query and file with table metadata already exist
         /// (so, ATTACH is done after DETACH), then rename atomically replaces old file with new one.
@@ -382,8 +382,8 @@ void DatabaseOnDisk::renameTable(
         table_metadata_path = getObjectMetadataPath(table_name);
         attach_query = parseQueryFromMetadata(log, local_context, table_metadata_path);
         auto & create = attach_query->as<ASTCreateQuery &>();
-        create.database = to_database.getDatabaseName();
-        create.table = to_table_name;
+        create.setDatabase(to_database.getDatabaseName());
+        create.setTable(to_table_name);
         if (from_ordinary_to_atomic)
             create.uuid = UUIDHelpers::generateV4();
         if (from_atomic_to_ordinary)
@@ -458,7 +458,7 @@ ASTPtr DatabaseOnDisk::getCreateDatabaseQuery() const
         ast = parseQueryFromMetadata(log, getContext(), database_metadata_path, true);
         auto & ast_create_query = ast->as<ASTCreateQuery &>();
         ast_create_query.attach = false;
-        ast_create_query.database = database_name;
+        ast_create_query.setDatabase(database_name);
     }
     if (!ast)
     {
@@ -642,18 +642,18 @@ ASTPtr DatabaseOnDisk::parseQueryFromMetadata(
         return nullptr;
 
     auto & create = ast->as<ASTCreateQuery &>();
-    if (!create.table.empty() && create.uuid != UUIDHelpers::Nil)
+    if (create.table && create.uuid != UUIDHelpers::Nil)
     {
         String table_name = unescapeForFileName(fs::path(metadata_file_path).stem());
 
-        if (create.table != TABLE_WITH_UUID_NAME_PLACEHOLDER && logger)
+        if (create.getTable() != TABLE_WITH_UUID_NAME_PLACEHOLDER && logger)
             LOG_WARNING(
                 logger,
                 "File {} contains both UUID and table name. Will use name `{}` instead of `{}`",
                 metadata_file_path,
                 table_name,
-                create.table);
-        create.table = table_name;
+                create.getTable());
+        create.setTable(table_name);
     }
 
     return ast;
@@ -667,7 +667,7 @@ ASTPtr DatabaseOnDisk::getCreateQueryFromMetadata(const String & database_metada
     {
         auto & ast_create_query = ast->as<ASTCreateQuery &>();
         ast_create_query.attach = false;
-        ast_create_query.database = getDatabaseName();
+        ast_create_query.setDatabase(getDatabaseName());
     }
 
     return ast;
diff --git a/src/Databases/DatabaseOnDisk.h b/src/Databases/DatabaseOnDisk.h
index 81d5bd5adcb8..f27a332fa3e1 100644
--- a/src/Databases/DatabaseOnDisk.h
+++ b/src/Databases/DatabaseOnDisk.h
@@ -63,7 +63,7 @@ class DatabaseOnDisk : public DatabaseWithOwnTablesBase
 
     String getDataPath() const override { return data_path; }
     String getTableDataPath(const String & table_name) const override { return data_path + escapeForFileName(table_name) + "/"; }
-    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.table); }
+    String getTableDataPath(const ASTCreateQuery & query) const override { return getTableDataPath(query.getTable()); }
     String getMetadataPath() const override { return metadata_path; }
 
     static ASTPtr parseQueryFromMetadata(Poco::Logger * log, ContextPtr context, const String & metadata_file_path, bool throw_on_error = true, bool remove_empty = false);
diff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp
index 061529f4e127..2da17ed388f5 100644
--- a/src/Databases/DatabaseOrdinary.cpp
+++ b/src/Databases/DatabaseOrdinary.cpp
@@ -55,7 +55,7 @@ namespace
         catch (Exception & e)
         {
             e.addMessage(
-                "Cannot attach table " + backQuote(database_name) + "." + backQuote(query.table) + " from metadata file " + metadata_path
+                "Cannot attach table " + backQuote(database_name) + "." + backQuote(query.getTable()) + " from metadata file " + metadata_path
                 + " from query " + serializeAST(query));
             throw;
         }
@@ -168,7 +168,7 @@ void DatabaseOrdinary::loadTablesMetadata(ContextPtr local_context, ParsedTables
             if (ast)
             {
                 auto * create_query = ast->as<ASTCreateQuery>();
-                create_query->database = database_name;
+                create_query->setDatabase(database_name);
 
                 if (fs::exists(full_path.string() + detached_suffix))
                 {
@@ -182,7 +182,7 @@ void DatabaseOrdinary::loadTablesMetadata(ContextPtr local_context, ParsedTables
                 }
 
                 TableNamesSet loading_dependencies = getDependenciesSetFromCreateQuery(getContext(), ast);
-                QualifiedTableName qualified_name{database_name, create_query->table};
+                QualifiedTableName qualified_name{database_name, create_query->getTable()};
 
                 std::lock_guard lock{metadata.mutex};
                 metadata.parsed_tables[qualified_name] = ParsedTableMetadata{full_path.string(), ast};
diff --git a/src/Databases/DatabaseReplicated.cpp b/src/Databases/DatabaseReplicated.cpp
index 3f253ed0924e..89d1f96857e2 100644
--- a/src/Databases/DatabaseReplicated.cpp
+++ b/src/Databases/DatabaseReplicated.cpp
@@ -349,9 +349,9 @@ void DatabaseReplicated::checkQueryValid(const ASTPtr & query, ContextPtr query_
     /// Replicas will set correct name of current database in query context (database name can be different on replicas)
     if (auto * ddl_query = dynamic_cast<ASTQueryWithTableAndOutput *>(query.get()))
     {
-        if (ddl_query->database != getDatabaseName())
+        if (ddl_query->getDatabase() != getDatabaseName())
             throw Exception(ErrorCodes::UNKNOWN_DATABASE, "Database was renamed");
-        ddl_query->database.clear();
+        ddl_query->database.reset();
 
         if (auto * create = query->as<ASTCreateQuery>())
         {
@@ -391,7 +391,7 @@ void DatabaseReplicated::checkQueryValid(const ASTPtr & query, ContextPtr query_
             /// NOTE: we cannot check here that substituted values will be actually different on shards and replicas.
 
             Macros::MacroExpansionInfo info;
-            info.table_id = {getDatabaseName(), create->table, create->uuid};
+            info.table_id = {getDatabaseName(), create->getTable(), create->uuid};
             query_context->getMacros()->expand(maybe_path, info);
             bool maybe_shard_macros = info.expanded_other;
             info.expanded_other = false;
@@ -715,13 +715,13 @@ ASTPtr DatabaseReplicated::parseQueryFromMetadataInZooKeeper(const String & node
     auto ast = parseQuery(parser, query, description, 0, getContext()->getSettingsRef().max_parser_depth);
 
     auto & create = ast->as<ASTCreateQuery &>();
-    if (create.uuid == UUIDHelpers::Nil || create.table != TABLE_WITH_UUID_NAME_PLACEHOLDER || !create.database.empty())
+    if (create.uuid == UUIDHelpers::Nil || create.getTable() != TABLE_WITH_UUID_NAME_PLACEHOLDER || create.database)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Got unexpected query from {}: {}", node_name, query);
 
     bool is_materialized_view_with_inner_table = create.is_materialized_view && create.to_table_id.empty();
 
-    create.database = getDatabaseName();
-    create.table = unescapeForFileName(node_name);
+    create.setDatabase(getDatabaseName());
+    create.setTable(unescapeForFileName(node_name));
     create.attach = is_materialized_view_with_inner_table;
 
     return ast;
@@ -811,7 +811,7 @@ void DatabaseReplicated::commitCreateTable(const ASTCreateQuery & query, const S
     assert(!ddl_worker->isCurrentlyActive() || txn);
     if (txn && txn->isInitialQuery())
     {
-        String metadata_zk_path = zookeeper_path + "/metadata/" + escapeForFileName(query.table);
+        String metadata_zk_path = zookeeper_path + "/metadata/" + escapeForFileName(query.getTable());
         String statement = getObjectDefinitionFromCreateQuery(query.clone());
         /// zk::multi(...) will throw if `metadata_zk_path` exists
         txn->addOp(zkutil::makeCreateRequest(metadata_zk_path, statement, zkutil::CreateMode::Persistent));
diff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp
index e5e54f287ecf..c92aac44083c 100644
--- a/src/Databases/DatabasesCommon.cpp
+++ b/src/Databases/DatabasesCommon.cpp
@@ -29,7 +29,7 @@ void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemo
     bool has_structure = ast_create_query.columns_list && ast_create_query.columns_list->columns;
     if (ast_create_query.as_table_function && !has_structure)
         throw Exception(ErrorCodes::NOT_IMPLEMENTED, "Cannot alter table {} because it was created AS table function"
-                                                     " and doesn't have structure in metadata", backQuote(ast_create_query.table));
+                                                     " and doesn't have structure in metadata", backQuote(ast_create_query.getTable()));
 
     assert(has_structure);
     ASTPtr new_columns = InterpreterCreateQuery::formatColumns(metadata.columns);
diff --git a/src/Databases/MySQL/DatabaseMySQL.cpp b/src/Databases/MySQL/DatabaseMySQL.cpp
index feebf33f58a0..275a1015c7b9 100644
--- a/src/Databases/MySQL/DatabaseMySQL.cpp
+++ b/src/Databases/MySQL/DatabaseMySQL.cpp
@@ -129,8 +129,8 @@ static ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr
     {
         /// init create query.
         auto table_id = storage->getStorageID();
-        create_table_query->table = table_id.table_name;
-        create_table_query->database = table_id.database_name;
+        create_table_query->setTable(table_id.table_name);
+        create_table_query->setDatabase(table_id.database_name);
 
         auto metadata_snapshot = storage->getInMemoryMetadataPtr();
         for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())
@@ -192,7 +192,7 @@ time_t DatabaseMySQL::getObjectMetadataModificationTime(const String & table_nam
 ASTPtr DatabaseMySQL::getCreateDatabaseQuery() const
 {
     const auto & create_query = std::make_shared<ASTCreateQuery>();
-    create_query->database = getDatabaseName();
+    create_query->setDatabase(getDatabaseName());
     create_query->set(create_query->storage, database_engine_define);
 
     if (const auto comment_value = getDatabaseComment(); !comment_value.empty())
diff --git a/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp b/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp
index 2b0d73a02ae4..14488f088119 100644
--- a/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp
+++ b/src/Databases/PostgreSQL/DatabaseMaterializedPostgreSQL.cpp
@@ -238,7 +238,7 @@ ASTPtr DatabaseMaterializedPostgreSQL::createAlterSettingsQuery(const SettingCha
     auto * alter = query->as<ASTAlterQuery>();
 
     alter->alter_object = ASTAlterQuery::AlterObjectType::DATABASE;
-    alter->database = database_name;
+    alter->setDatabase(database_name);
     alter->set(alter->command_list, command_list);
 
     return query;
diff --git a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp
index 5d3493d0c82b..e995a6d2377a 100644
--- a/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp
+++ b/src/Databases/PostgreSQL/DatabasePostgreSQL.cpp
@@ -355,7 +355,7 @@ void DatabasePostgreSQL::shutdown()
 ASTPtr DatabasePostgreSQL::getCreateDatabaseQuery() const
 {
     const auto & create_query = std::make_shared<ASTCreateQuery>();
-    create_query->database = getDatabaseName();
+    create_query->setDatabase(getDatabaseName());
     create_query->set(create_query->storage, database_engine_define);
 
     if (const auto comment_value = getDatabaseComment(); !comment_value.empty())
@@ -388,8 +388,8 @@ ASTPtr DatabasePostgreSQL::getCreateTableQueryImpl(const String & table_name, Co
 
     /// init create query.
     auto table_id = storage->getStorageID();
-    create_table_query->table = table_id.table_name;
-    create_table_query->database = table_id.database_name;
+    create_table_query->setTable(table_id.table_name);
+    create_table_query->setDatabase(table_id.database_name);
 
     auto metadata_snapshot = storage->getInMemoryMetadataPtr();
     for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())
diff --git a/src/Databases/SQLite/DatabaseSQLite.cpp b/src/Databases/SQLite/DatabaseSQLite.cpp
index 05bc2f248344..ba53ab084074 100644
--- a/src/Databases/SQLite/DatabaseSQLite.cpp
+++ b/src/Databases/SQLite/DatabaseSQLite.cpp
@@ -160,7 +160,7 @@ StoragePtr DatabaseSQLite::fetchTable(const String & table_name, ContextPtr loca
 ASTPtr DatabaseSQLite::getCreateDatabaseQuery() const
 {
     const auto & create_query = std::make_shared<ASTCreateQuery>();
-    create_query->database = getDatabaseName();
+    create_query->setDatabase(getDatabaseName());
     create_query->set(create_query->storage, database_engine_define);
 
     if (const auto comment_value = getDatabaseComment(); !comment_value.empty())
@@ -193,8 +193,8 @@ ASTPtr DatabaseSQLite::getCreateTableQueryImpl(const String & table_name, Contex
 
     /// init create query.
     auto table_id = storage->getStorageID();
-    create_table_query->table = table_id.table_name;
-    create_table_query->database = table_id.database_name;
+    create_table_query->setTable(table_id.table_name);
+    create_table_query->setDatabase(table_id.database_name);
 
     auto metadata_snapshot = storage->getInMemoryMetadataPtr();
     for (const auto & column_type_and_name : metadata_snapshot->getColumns().getOrdinary())
diff --git a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp
index 0c6944eeccc5..f031e8ff038d 100644
--- a/src/Dictionaries/getDictionaryConfigurationFromAST.cpp
+++ b/src/Dictionaries/getDictionaryConfigurationFromAST.cpp
@@ -536,12 +536,12 @@ getDictionaryConfigurationFromAST(const ASTCreateQuery & query, ContextPtr conte
 
     AutoPtr<Poco::XML::Element> name_element(xml_document->createElement("name"));
     current_dictionary->appendChild(name_element);
-    AutoPtr<Text> name(xml_document->createTextNode(query.table));
+    AutoPtr<Text> name(xml_document->createTextNode(query.getTable()));
     name_element->appendChild(name);
 
     AutoPtr<Poco::XML::Element> database_element(xml_document->createElement("database"));
     current_dictionary->appendChild(database_element);
-    AutoPtr<Text> database(xml_document->createTextNode(!database_.empty() ? database_ : query.database));
+    AutoPtr<Text> database(xml_document->createTextNode(!database_.empty() ? database_ : query.getDatabase()));
     database_element->appendChild(database);
 
     if (query.uuid != UUIDHelpers::Nil)
diff --git a/src/Interpreters/AddDefaultDatabaseVisitor.h b/src/Interpreters/AddDefaultDatabaseVisitor.h
index 480a7c01b98e..d5039a2f19e2 100644
--- a/src/Interpreters/AddDefaultDatabaseVisitor.h
+++ b/src/Interpreters/AddDefaultDatabaseVisitor.h
@@ -239,8 +239,8 @@ class AddDefaultDatabaseVisitor
         if (only_replace_current_database_function)
             return;
 
-        if (node.database.empty())
-            node.database = database_name;
+        if (!node.database)
+            node.setDatabase(database_name);
     }
 
     void visitDDL(ASTRenameQuery & node, ASTPtr &) const
@@ -262,8 +262,8 @@ class AddDefaultDatabaseVisitor
         if (only_replace_current_database_function)
             return;
 
-        if (node.database.empty())
-            node.database = database_name;
+        if (!node.database)
+            node.setDatabase(database_name);
 
         for (const auto & child : node.command_list->children)
         {
diff --git a/src/Interpreters/DDLTask.cpp b/src/Interpreters/DDLTask.cpp
index cfce6ac94639..b8d3d64feea8 100644
--- a/src/Interpreters/DDLTask.cpp
+++ b/src/Interpreters/DDLTask.cpp
@@ -257,12 +257,12 @@ bool DDLTask::tryFindHostInCluster()
                          * */
                         is_circular_replicated = true;
                         auto * query_with_table = dynamic_cast<ASTQueryWithTableAndOutput *>(query.get());
-                        if (!query_with_table || query_with_table->database.empty())
+                        if (!query_with_table || !query_with_table->database)
                         {
                             throw Exception(ErrorCodes::INCONSISTENT_CLUSTER_DEFINITION,
                                             "For a distributed DDL on circular replicated cluster its table name must be qualified by database name.");
                         }
-                        if (default_database == query_with_table->database)
+                        if (default_database == query_with_table->getDatabase())
                             return true;
                     }
                 }
@@ -351,8 +351,8 @@ void DatabaseReplicatedTask::parseQueryFromEntry(ContextPtr context)
     if (auto * ddl_query = dynamic_cast<ASTQueryWithTableAndOutput *>(query.get()))
     {
         /// Update database name with actual name of local database
-        assert(ddl_query->database.empty());
-        ddl_query->database = database->getDatabaseName();
+        assert(!ddl_query->database);
+        ddl_query->setDatabase(database->getDatabaseName());
     }
 }
 
diff --git a/src/Interpreters/DDLWorker.cpp b/src/Interpreters/DDLWorker.cpp
index 4633b22ca493..9fefcf012a9e 100644
--- a/src/Interpreters/DDLWorker.cpp
+++ b/src/Interpreters/DDLWorker.cpp
@@ -662,7 +662,7 @@ void DDLWorker::processTask(DDLTaskBase & task, const ZooKeeperPtr & zookeeper)
             StoragePtr storage;
             if (auto * query_with_table = dynamic_cast<ASTQueryWithTableAndOutput *>(task.query.get()); query_with_table)
             {
-                if (!query_with_table->table.empty())
+                if (query_with_table->table)
                 {
                     /// It's not CREATE DATABASE
                     auto table_id = context->tryResolveStorageID(*query_with_table, Context::ResolveOrdinary);
diff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp
index fa8f3e099ff9..898e169bc44c 100644
--- a/src/Interpreters/DatabaseCatalog.cpp
+++ b/src/Interpreters/DatabaseCatalog.cpp
@@ -66,9 +66,9 @@ TemporaryTableHolder::TemporaryTableHolder(ContextPtr context_, const TemporaryT
         if (create->uuid == UUIDHelpers::Nil)
             create->uuid = UUIDHelpers::generateV4();
         id = create->uuid;
-        create->table = "_tmp_" + toString(id);
-        global_name = create->table;
-        create->database = DatabaseCatalog::TEMPORARY_DATABASE;
+        create->setTable("_tmp_" + toString(id));
+        global_name = create->getTable();
+        create->setDatabase(DatabaseCatalog::TEMPORARY_DATABASE);
     }
     else
     {
@@ -786,8 +786,8 @@ void DatabaseCatalog::enqueueDroppedTableCleanup(StorageID table_id, StoragePtr
         if (create)
         {
             String data_path = "store/" + getPathForUUID(table_id.uuid);
-            create->database = table_id.database_name;
-            create->table = table_id.table_name;
+            create->setDatabase(table_id.database_name);
+            create->setTable(table_id.table_name);
             try
             {
                 table = createTableFromAST(*create, table_id.getDatabaseName(), data_path, getContext(), false).second;
diff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp
index 354d25fbe8fc..665d76625ef8 100644
--- a/src/Interpreters/InterpreterAlterQuery.cpp
+++ b/src/Interpreters/InterpreterAlterQuery.cpp
@@ -62,7 +62,7 @@ BlockIO InterpreterAlterQuery::executeToTable(const ASTAlterQuery & alter)
 
     getContext()->checkAccess(getRequiredAccess());
     auto table_id = getContext()->resolveStorageID(alter, Context::ResolveOrdinary);
-    query_ptr->as<ASTAlterQuery &>().database = table_id.database_name;
+    query_ptr->as<ASTAlterQuery &>().setDatabase(table_id.database_name);
 
     DatabasePtr database = DatabaseCatalog::instance().getDatabase(table_id.database_name);
     if (typeid_cast<DatabaseReplicated *>(database.get())
@@ -175,7 +175,7 @@ BlockIO InterpreterAlterQuery::executeToDatabase(const ASTAlterQuery & alter)
 {
     BlockIO res;
     getContext()->checkAccess(getRequiredAccess());
-    DatabasePtr database = DatabaseCatalog::instance().getDatabase(alter.database);
+    DatabasePtr database = DatabaseCatalog::instance().getDatabase(alter.getDatabase());
     AlterCommands alter_commands;
 
     for (const auto & child : alter.command_list->children)
@@ -215,7 +215,7 @@ AccessRightsElements InterpreterAlterQuery::getRequiredAccess() const
     AccessRightsElements required_access;
     const auto & alter = query_ptr->as<ASTAlterQuery &>();
     for (const auto & child : alter.command_list->children)
-        boost::range::push_back(required_access, getRequiredAccessForCommand(child->as<ASTAlterCommand&>(), alter.database, alter.table));
+        boost::range::push_back(required_access, getRequiredAccessForCommand(child->as<ASTAlterCommand&>(), alter.getDatabase(), alter.getTable()));
     return required_access;
 }
 
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 7e6c3f113b50..bef599077824 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -101,7 +101,7 @@ InterpreterCreateQuery::InterpreterCreateQuery(const ASTPtr & query_ptr_, Contex
 
 BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)
 {
-    String database_name = create.database;
+    String database_name = create.getDatabase();
 
     auto guard = DatabaseCatalog::instance().getDDLGuard(database_name, "");
 
@@ -127,11 +127,11 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)
         /// Short syntax: try read database definition from file
         auto ast = DatabaseOnDisk::parseQueryFromMetadata(nullptr, getContext(), metadata_file_path);
         create = ast->as<ASTCreateQuery &>();
-        if (!create.table.empty() || !create.storage)
+        if (create.table || !create.storage)
             throw Exception(ErrorCodes::INCORRECT_QUERY, "Metadata file {} contains incorrect CREATE DATABASE query", metadata_file_path.string());
         create.attach = true;
         create.attach_short_syntax = true;
-        create.database = database_name;
+        create.setDatabase(database_name);
     }
     else if (!create.storage)
     {
@@ -161,7 +161,7 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)
     {
         if (create.attach && create.uuid == UUIDHelpers::Nil)
             throw Exception(ErrorCodes::INCORRECT_QUERY, "UUID must be specified for ATTACH. "
-                            "If you want to attach existing database, use just ATTACH DATABASE {};", create.database);
+                            "If you want to attach existing database, use just ATTACH DATABASE {};", create.getDatabase());
         else if (create.uuid == UUIDHelpers::Nil)
             create.uuid = UUIDHelpers::generateV4();
 
@@ -238,7 +238,7 @@ BlockIO InterpreterCreateQuery::createDatabase(ASTCreateQuery & create)
     DatabasePtr database = DatabaseFactory::get(create, metadata_path / "", getContext());
 
     if (create.uuid != UUIDHelpers::Nil)
-        create.database = TABLE_WITH_UUID_NAME_PLACEHOLDER;
+        create.setDatabase(TABLE_WITH_UUID_NAME_PLACEHOLDER);
 
     bool need_write_metadata = !create.attach || !fs::exists(metadata_file_path);
 
@@ -823,7 +823,7 @@ void InterpreterCreateQuery::assertOrSetUUID(ASTCreateQuery & create, const Data
         bool has_uuid = create.uuid != UUIDHelpers::Nil || create.to_inner_uuid != UUIDHelpers::Nil;
         if (has_uuid && !is_on_cluster)
             throw Exception(ErrorCodes::INCORRECT_QUERY,
-                            "{} UUID specified, but engine of database {} is not Atomic", kind, create.database);
+                            "{} UUID specified, but engine of database {} is not Atomic", kind, create.getDatabase());
 
         /// Ignore UUID if it's ON CLUSTER query
         create.uuid = UUIDHelpers::Nil;
@@ -835,12 +835,12 @@ void InterpreterCreateQuery::assertOrSetUUID(ASTCreateQuery & create, const Data
 BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)
 {
     /// Temporary tables are created out of databases.
-    if (create.temporary && !create.database.empty())
+    if (create.temporary && create.database)
         throw Exception("Temporary tables cannot be inside a database. You should not specify a database for a temporary table.",
             ErrorCodes::BAD_DATABASE_FOR_TEMPORARY_TABLE);
 
     String current_database = getContext()->getCurrentDatabase();
-    auto database_name = create.database.empty() ? current_database : create.database;
+    auto database_name = create.database ? create.getDatabase() : current_database;
 
     // If this is a stub ATTACH query, read the query definition from the database
     if (create.attach && !create.storage && !create.columns_list)
@@ -849,12 +849,12 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)
 
         if (database->getEngineName() == "Replicated")
         {
-            auto guard = DatabaseCatalog::instance().getDDLGuard(database_name, create.table);
+            auto guard = DatabaseCatalog::instance().getDDLGuard(database_name, create.getTable());
 
             if (auto* ptr = typeid_cast<DatabaseReplicated *>(database.get());
                 ptr && !getContext()->getClientInfo().is_replicated_database_internal)
             {
-                create.database = database_name;
+                create.setDatabase(database_name);
                 guard->releaseTableLock();
                 return ptr->tryEnqueueReplicatedDDL(query_ptr, getContext());
             }
@@ -863,18 +863,18 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)
         bool if_not_exists = create.if_not_exists;
 
         // Table SQL definition is available even if the table is detached (even permanently)
-        auto query = database->getCreateTableQuery(create.table, getContext());
+        auto query = database->getCreateTableQuery(create.getTable(), getContext());
         auto create_query = query->as<ASTCreateQuery &>();
 
         if (!create.is_dictionary && create_query.is_dictionary)
             throw Exception(ErrorCodes::INCORRECT_QUERY,
                 "Cannot ATTACH TABLE {}.{}, it is a Dictionary",
-                backQuoteIfNeed(database_name), backQuoteIfNeed(create.table));
+                backQuoteIfNeed(database_name), backQuoteIfNeed(create.getTable()));
 
         if (create.is_dictionary && !create_query.is_dictionary)
             throw Exception(ErrorCodes::INCORRECT_QUERY,
                 "Cannot ATTACH DICTIONARY {}.{}, it is a Table",
-                backQuoteIfNeed(database_name), backQuoteIfNeed(create.table));
+                backQuoteIfNeed(database_name), backQuoteIfNeed(create.getTable()));
 
         create = create_query; // Copy the saved create query, but use ATTACH instead of CREATE
 
@@ -917,11 +917,11 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)
                          "use either ATTACH TABLE {}; to attach existing table "
                          "or CREATE TABLE {} <table definition>; to create new table "
                          "or ATTACH TABLE {} FROM '/path/to/data/' <table definition>; to create new table and attach data.",
-                         create.table, create.table, create.table);
+                         create.getTable(), create.getTable(), create.getTable());
     }
 
-    if (!create.temporary && create.database.empty())
-        create.database = current_database;
+    if (!create.temporary && !create.database)
+        create.setDatabase(current_database);
     if (create.to_table_id && create.to_table_id.database_name.empty())
         create.to_table_id.database_name = current_database;
 
@@ -949,7 +949,7 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)
 
     if (need_add_to_database && database->getEngineName() == "Replicated")
     {
-        auto guard = DatabaseCatalog::instance().getDDLGuard(create.database, create.table);
+        auto guard = DatabaseCatalog::instance().getDDLGuard(create.getDatabase(), create.getTable());
 
         if (auto * ptr = typeid_cast<DatabaseReplicated *>(database.get());
             ptr && !getContext()->getClientInfo().is_replicated_database_internal)
@@ -972,7 +972,7 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)
     /// If table has dependencies - add them to the graph
     TableNamesSet loading_dependencies = getDependenciesSetFromCreateQuery(getContext()->getGlobalContext(), query_ptr);
     if (!loading_dependencies.empty())
-        DatabaseCatalog::instance().addLoadingDependencies(QualifiedTableName{database_name, create.table}, std::move(loading_dependencies));
+        DatabaseCatalog::instance().addLoadingDependencies(QualifiedTableName{database_name, create.getTable()}, std::move(loading_dependencies));
 
     return fillTableIfNeeded(create);
 }
@@ -991,16 +991,16 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
         /** If the request specifies IF NOT EXISTS, we allow concurrent CREATE queries (which do nothing).
           * If table doesn't exist, one thread is creating table, while others wait in DDLGuard.
           */
-        guard = DatabaseCatalog::instance().getDDLGuard(create.database, create.table);
+        guard = DatabaseCatalog::instance().getDDLGuard(create.getDatabase(), create.getTable());
 
-        database = DatabaseCatalog::instance().getDatabase(create.database);
+        database = DatabaseCatalog::instance().getDatabase(create.getDatabase());
         assertOrSetUUID(create, database);
 
         String storage_name = create.is_dictionary ? "Dictionary" : "Table";
         auto storage_already_exists_error_code = create.is_dictionary ? ErrorCodes::DICTIONARY_ALREADY_EXISTS : ErrorCodes::TABLE_ALREADY_EXISTS;
 
         /// Table can be created before or it can be created concurrently in another thread, while we were waiting in DDLGuard.
-        if (database->isTableExist(create.table, getContext()))
+        if (database->isTableExist(create.getTable(), getContext()))
         {
             /// TODO Check structure of table
             if (create.if_not_exists)
@@ -1009,8 +1009,8 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
             {
                 /// when executing CREATE OR REPLACE VIEW, drop current existing view
                 auto drop_ast = std::make_shared<ASTDropQuery>();
-                drop_ast->database = create.database;
-                drop_ast->table = create.table;
+                drop_ast->setDatabase(create.getDatabase());
+                drop_ast->setTable(create.getTable());
                 drop_ast->no_ddl_lock = true;
 
                 auto drop_context = Context::createCopy(context);
@@ -1019,7 +1019,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
             }
             else
                 throw Exception(storage_already_exists_error_code,
-                    "{} {}.{} already exists", storage_name, backQuoteIfNeed(create.database), backQuoteIfNeed(create.table));
+                    "{} {}.{} already exists", storage_name, backQuoteIfNeed(create.getDatabase()), backQuoteIfNeed(create.getTable()));
         }
 
         data_path = database->getTableDataPath(create);
@@ -1030,10 +1030,10 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
     }
     else
     {
-        if (create.if_not_exists && getContext()->tryResolveStorageID({"", create.table}, Context::ResolveExternal))
+        if (create.if_not_exists && getContext()->tryResolveStorageID({"", create.getTable()}, Context::ResolveExternal))
             return false;
 
-        String temporary_table_name = create.table;
+        String temporary_table_name = create.getTable();
         auto temporary_table = TemporaryTableHolder(getContext(), properties.columns, properties.constraints, query_ptr);
         getContext()->getSessionContext()->addExternalTable(temporary_table_name, std::move(temporary_table));
         return true;
@@ -1070,8 +1070,8 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
     {
         const auto & factory = TableFunctionFactory::instance();
         auto table_func = factory.get(create.as_table_function, getContext());
-        res = table_func->execute(create.as_table_function, getContext(), create.table, properties.columns);
-        res->renameInMemory({create.database, create.table, create.uuid});
+        res = table_func->execute(create.as_table_function, getContext(), create.getTable(), properties.columns);
+        res->renameInMemory({create.getDatabase(), create.getTable(), create.uuid});
     }
     else
     {
@@ -1089,12 +1089,12 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
                         "ATTACH ... FROM ... query is not supported for {} table engine, "
                         "because such tables do not store any data on disk. Use CREATE instead.", res->getName());
 
-    database->createTable(getContext(), create.table, res, query_ptr);
+    database->createTable(getContext(), create.getTable(), res, query_ptr);
 
     /// Move table data to the proper place. Wo do not move data earlier to avoid situations
     /// when data directory moved, but table has not been created due to some error.
     if (from_path)
-        res->rename(actual_data_path, {create.database, create.table, create.uuid});
+        res->rename(actual_data_path, {create.getDatabase(), create.getTable(), create.uuid});
 
     /// We must call "startup" and "shutdown" while holding DDLGuard.
     /// Because otherwise method "shutdown" (from InterpreterDropQuery) can be called before startup
@@ -1142,30 +1142,30 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,
     };
 
     auto ast_drop = std::make_shared<ASTDropQuery>();
-    String table_to_replace_name = create.table;
+    String table_to_replace_name = create.getTable();
 
     {
-        auto database = DatabaseCatalog::instance().getDatabase(create.database);
+        auto database = DatabaseCatalog::instance().getDatabase(create.getDatabase());
         if (database->getUUID() == UUIDHelpers::Nil)
             throw Exception(ErrorCodes::INCORRECT_QUERY,
                             "{} query is supported only for Atomic databases",
                             create.create_or_replace ? "CREATE OR REPLACE TABLE" : "REPLACE TABLE");
 
 
-        UInt64 name_hash = sipHash64(create.database + create.table);
+        UInt64 name_hash = sipHash64(create.getDatabase() + create.getTable());
         UInt16 random_suffix = thread_local_rng();
         if (auto txn = current_context->getZooKeeperMetadataTransaction())
         {
             /// Avoid different table name on database replicas
             random_suffix = sipHash64(txn->getTaskZooKeeperPath());
         }
-        create.table = fmt::format("_tmp_replace_{}_{}",
-                                   getHexUIntLowercase(name_hash),
-                                   getHexUIntLowercase(random_suffix));
+        create.setTable(fmt::format("_tmp_replace_{}_{}",
+                            getHexUIntLowercase(name_hash),
+                            getHexUIntLowercase(random_suffix)));
 
-        ast_drop->table = create.table;
+        ast_drop->setTable(create.getTable());
         ast_drop->is_dictionary = create.is_dictionary;
-        ast_drop->database = create.database;
+        ast_drop->setDatabase(create.getDatabase());
         ast_drop->kind = ASTDropQuery::Drop;
     }
 
@@ -1186,8 +1186,8 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,
         auto ast_rename = std::make_shared<ASTRenameQuery>();
         ASTRenameQuery::Element elem
         {
-            ASTRenameQuery::Table{create.database, create.table},
-            ASTRenameQuery::Table{create.database, table_to_replace_name}
+            ASTRenameQuery::Table{create.getDatabase(), create.getTable()},
+            ASTRenameQuery::Table{create.getDatabase(), table_to_replace_name}
         };
 
         ast_rename->elements.push_back(std::move(elem));
@@ -1217,7 +1217,7 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,
             InterpreterDropQuery(ast_drop, drop_context).execute();
         }
 
-        create.table = table_to_replace_name;
+        create.setTable(table_to_replace_name);
 
         return {};
     }
@@ -1240,7 +1240,7 @@ BlockIO InterpreterCreateQuery::fillTableIfNeeded(const ASTCreateQuery & create)
         && !create.is_ordinary_view && !create.is_live_view && (!create.is_materialized_view || create.is_populate))
     {
         auto insert = std::make_shared<ASTInsertQuery>();
-        insert->table_id = {create.database, create.table, create.uuid};
+        insert->table_id = {create.getDatabase(), create.getTable(), create.uuid};
         insert->select = create.select->clone();
 
         if (create.temporary && !getContext()->getSessionContext()->hasQueryContext())
@@ -1316,7 +1316,7 @@ BlockIO InterpreterCreateQuery::execute()
     ASTQueryWithOutput::resetOutputASTIfExist(create);
 
     /// CREATE|ATTACH DATABASE
-    if (!create.database.empty() && create.table.empty())
+    if (create.database && !create.table)
         return createDatabase(create);
     else
         return createTable(create);
@@ -1332,21 +1332,21 @@ AccessRightsElements InterpreterCreateQuery::getRequiredAccess() const
     AccessRightsElements required_access;
     const auto & create = query_ptr->as<const ASTCreateQuery &>();
 
-    if (create.table.empty())
+    if (!create.table)
     {
-        required_access.emplace_back(AccessType::CREATE_DATABASE, create.database);
+        required_access.emplace_back(AccessType::CREATE_DATABASE, create.getDatabase());
     }
     else if (create.is_dictionary)
     {
-        required_access.emplace_back(AccessType::CREATE_DICTIONARY, create.database, create.table);
+        required_access.emplace_back(AccessType::CREATE_DICTIONARY, create.getDatabase(), create.getTable());
     }
     else if (create.isView())
     {
         assert(!create.temporary);
         if (create.replace_view)
-            required_access.emplace_back(AccessType::DROP_VIEW | AccessType::CREATE_VIEW, create.database, create.table);
+            required_access.emplace_back(AccessType::DROP_VIEW | AccessType::CREATE_VIEW, create.getDatabase(), create.getTable());
         else
-            required_access.emplace_back(AccessType::CREATE_VIEW, create.database, create.table);
+            required_access.emplace_back(AccessType::CREATE_VIEW, create.getDatabase(), create.getTable());
     }
     else
     {
@@ -1355,8 +1355,8 @@ AccessRightsElements InterpreterCreateQuery::getRequiredAccess() const
         else
         {
             if (create.replace_table)
-                required_access.emplace_back(AccessType::DROP_TABLE, create.database, create.table);
-            required_access.emplace_back(AccessType::CREATE_TABLE, create.database, create.table);
+                required_access.emplace_back(AccessType::DROP_TABLE, create.getDatabase(), create.getTable());
+            required_access.emplace_back(AccessType::CREATE_TABLE, create.getDatabase(), create.getTable());
         }
     }
 
diff --git a/src/Interpreters/InterpreterDropQuery.cpp b/src/Interpreters/InterpreterDropQuery.cpp
index 03ec34fb6be0..ce54ecc529ad 100644
--- a/src/Interpreters/InterpreterDropQuery.cpp
+++ b/src/Interpreters/InterpreterDropQuery.cpp
@@ -56,9 +56,9 @@ BlockIO InterpreterDropQuery::execute()
     if (getContext()->getSettingsRef().database_atomic_wait_for_drop_and_detach_synchronously)
         drop.no_delay = true;
 
-    if (!drop.table.empty())
+    if (drop.table)
         return executeToTable(drop);
-    else if (!drop.database.empty())
+    else if (drop.database)
         return executeToDatabase(drop);
     else
         throw Exception("Nothing to drop, both names are empty", ErrorCodes::LOGICAL_ERROR);
@@ -95,7 +95,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ASTDropQuery & query, DatabaseP
         if (getContext()->tryResolveStorageID(table_id, Context::ResolveExternal))
             return executeToTemporaryTable(table_id.getTableName(), query.kind);
         else
-            query.database = table_id.database_name = getContext()->getCurrentDatabase();
+            query.setDatabase(table_id.database_name = getContext()->getCurrentDatabase());
     }
 
     if (query.temporary)
@@ -130,7 +130,7 @@ BlockIO InterpreterDropQuery::executeToTableImpl(ASTDropQuery & query, DatabaseP
         table_id.uuid = database->tryGetTableUUID(table_id.table_name);
 
         /// Prevents recursive drop from drop database query. The original query must specify a table.
-        bool is_drop_or_detach_database = query_ptr->as<ASTDropQuery>()->table.empty();
+        bool is_drop_or_detach_database = !query_ptr->as<ASTDropQuery>()->table;
         bool is_replicated_ddl_query = typeid_cast<DatabaseReplicated *>(database.get()) &&
                                        !getContext()->getClientInfo().is_replicated_database_internal &&
                                        !is_drop_or_detach_database;
@@ -302,7 +302,7 @@ BlockIO InterpreterDropQuery::executeToDatabase(const ASTDropQuery & query)
 
 BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query, DatabasePtr & database, std::vector<UUID> & uuids_to_wait)
 {
-    const auto & database_name = query.database;
+    const auto & database_name = query.getDatabase();
     auto ddl_guard = DatabaseCatalog::instance().getDDLGuard(database_name, "");
 
     database = tryGetDatabase(database_name, query.if_exists);
@@ -336,7 +336,7 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,
                 ASTDropQuery query_for_table;
                 query_for_table.kind = query.kind;
                 query_for_table.if_exists = true;
-                query_for_table.database = database_name;
+                query_for_table.setDatabase(database_name);
                 query_for_table.no_delay = query.no_delay;
 
                 /// Flush should not be done if shouldBeEmptyOnDetach() == false,
@@ -351,7 +351,7 @@ BlockIO InterpreterDropQuery::executeToDatabaseImpl(const ASTDropQuery & query,
                 {
                     DatabasePtr db;
                     UUID table_to_wait = UUIDHelpers::Nil;
-                    query_for_table.table = iterator->name();
+                    query_for_table.setTable(iterator->name());
                     query_for_table.is_dictionary = iterator->table()->isDictionary();
                     executeToTableImpl(query_for_table, db, table_to_wait);
                     uuids_to_wait.push_back(table_to_wait);
@@ -385,29 +385,29 @@ AccessRightsElements InterpreterDropQuery::getRequiredAccessForDDLOnCluster() co
     AccessRightsElements required_access;
     const auto & drop = query_ptr->as<const ASTDropQuery &>();
 
-    if (drop.table.empty())
+    if (!drop.table)
     {
         if (drop.kind == ASTDropQuery::Kind::Detach)
-            required_access.emplace_back(AccessType::DROP_DATABASE, drop.database);
+            required_access.emplace_back(AccessType::DROP_DATABASE, drop.getDatabase());
         else if (drop.kind == ASTDropQuery::Kind::Drop)
-            required_access.emplace_back(AccessType::DROP_DATABASE, drop.database);
+            required_access.emplace_back(AccessType::DROP_DATABASE, drop.getDatabase());
     }
     else if (drop.is_dictionary)
     {
         if (drop.kind == ASTDropQuery::Kind::Detach)
-            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.database, drop.table);
+            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.getDatabase(), drop.getTable());
         else if (drop.kind == ASTDropQuery::Kind::Drop)
-            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.database, drop.table);
+            required_access.emplace_back(AccessType::DROP_DICTIONARY, drop.getDatabase(), drop.getTable());
     }
     else if (!drop.temporary)
     {
         /// It can be view or table.
         if (drop.kind == ASTDropQuery::Kind::Drop)
-            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.database, drop.table);
+            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.getDatabase(), drop.getTable());
         else if (drop.kind == ASTDropQuery::Kind::Truncate)
-            required_access.emplace_back(AccessType::TRUNCATE, drop.database, drop.table);
+            required_access.emplace_back(AccessType::TRUNCATE, drop.getDatabase(), drop.getTable());
         else if (drop.kind == ASTDropQuery::Kind::Detach)
-            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.database, drop.table);
+            required_access.emplace_back(AccessType::DROP_TABLE | AccessType::DROP_VIEW, drop.getDatabase(), drop.getTable());
     }
 
     return required_access;
@@ -424,8 +424,8 @@ void InterpreterDropQuery::executeDropQuery(ASTDropQuery::Kind kind, ContextPtr
     {
         /// We create and execute `drop` query for internal table.
         auto drop_query = std::make_shared<ASTDropQuery>();
-        drop_query->database = target_table_id.database_name;
-        drop_query->table = target_table_id.table_name;
+        drop_query->setDatabase(target_table_id.database_name);
+        drop_query->setTable(target_table_id.table_name);
         drop_query->kind = kind;
         drop_query->no_delay = no_delay;
         drop_query->if_exists = true;
diff --git a/src/Interpreters/InterpreterExistsQuery.cpp b/src/Interpreters/InterpreterExistsQuery.cpp
index 5af51c61b295..758c6d814073 100644
--- a/src/Interpreters/InterpreterExistsQuery.cpp
+++ b/src/Interpreters/InterpreterExistsQuery.cpp
@@ -44,25 +44,25 @@ QueryPipeline InterpreterExistsQuery::executeImpl()
         if (exists_query->temporary)
         {
             result = static_cast<bool>(getContext()->tryResolveStorageID(
-                {"", exists_query->table}, Context::ResolveExternal));
+                {"", exists_query->getTable()}, Context::ResolveExternal));
         }
         else
         {
-            String database = getContext()->resolveDatabase(exists_query->database);
-            getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->table);
-            result = DatabaseCatalog::instance().isTableExist({database, exists_query->table}, getContext());
+            String database = getContext()->resolveDatabase(exists_query->getDatabase());
+            getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->getTable());
+            result = DatabaseCatalog::instance().isTableExist({database, exists_query->getTable()}, getContext());
         }
     }
     else if ((exists_query = query_ptr->as<ASTExistsViewQuery>()))
     {
-        String database = getContext()->resolveDatabase(exists_query->database);
-        getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->table);
-        auto table = DatabaseCatalog::instance().tryGetTable({database, exists_query->table}, getContext());
+        String database = getContext()->resolveDatabase(exists_query->getDatabase());
+        getContext()->checkAccess(AccessType::SHOW_TABLES, database, exists_query->getTable());
+        auto table = DatabaseCatalog::instance().tryGetTable({database, exists_query->getTable()}, getContext());
         result = table && table->isView();
     }
     else if ((exists_query = query_ptr->as<ASTExistsDatabaseQuery>()))
     {
-        String database = getContext()->resolveDatabase(exists_query->database);
+        String database = getContext()->resolveDatabase(exists_query->getDatabase());
         getContext()->checkAccess(AccessType::SHOW_DATABASES, database);
         result = DatabaseCatalog::instance().isDatabaseExist(database);
     }
@@ -70,9 +70,9 @@ QueryPipeline InterpreterExistsQuery::executeImpl()
     {
         if (exists_query->temporary)
             throw Exception("Temporary dictionaries are not possible.", ErrorCodes::SYNTAX_ERROR);
-        String database = getContext()->resolveDatabase(exists_query->database);
-        getContext()->checkAccess(AccessType::SHOW_DICTIONARIES, database, exists_query->table);
-        result = DatabaseCatalog::instance().isDictionaryExist({database, exists_query->table});
+        String database = getContext()->resolveDatabase(exists_query->getDatabase());
+        getContext()->checkAccess(AccessType::SHOW_DICTIONARIES, database, exists_query->getTable());
+        result = DatabaseCatalog::instance().isDictionaryExist({database, exists_query->getTable()});
     }
 
     return QueryPipeline(std::make_shared<SourceFromSingleChunk>(Block{{
diff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp
index 231eb15b02fe..99b68897549e 100644
--- a/src/Interpreters/InterpreterInsertQuery.cpp
+++ b/src/Interpreters/InterpreterInsertQuery.cpp
@@ -62,7 +62,18 @@ StoragePtr InterpreterInsertQuery::getTable(ASTInsertQuery & query)
         return table_function_ptr->execute(query.table_function, getContext(), table_function_ptr->getName());
     }
 
-    query.table_id = getContext()->resolveStorageID(query.table_id);
+    if (query.table_id)
+    {
+        query.table_id = getContext()->resolveStorageID(query.table_id);
+    }
+    else
+    {
+        /// Insert query parser does not fill table_id because table and
+        /// database can be parameters and be filled after parsing.
+        StorageID local_table_id(query.getDatabase(), query.getTable());
+        query.table_id = getContext()->resolveStorageID(local_table_id);
+    }
+
     return DatabaseCatalog::instance().getTable(query.table_id, getContext());
 }
 
diff --git a/src/Interpreters/InterpreterOptimizeQuery.cpp b/src/Interpreters/InterpreterOptimizeQuery.cpp
index a44a49ec0201..f9a701a0a77d 100644
--- a/src/Interpreters/InterpreterOptimizeQuery.cpp
+++ b/src/Interpreters/InterpreterOptimizeQuery.cpp
@@ -79,7 +79,7 @@ AccessRightsElements InterpreterOptimizeQuery::getRequiredAccess() const
 {
     const auto & optimize = query_ptr->as<const ASTOptimizeQuery &>();
     AccessRightsElements required_access;
-    required_access.emplace_back(AccessType::OPTIMIZE, optimize.database, optimize.table);
+    required_access.emplace_back(AccessType::OPTIMIZE, optimize.getDatabase(), optimize.getTable());
     return required_access;
 }
 
diff --git a/src/Interpreters/InterpreterShowCreateQuery.cpp b/src/Interpreters/InterpreterShowCreateQuery.cpp
index 84dbae0fac50..6ae51c1ff235 100644
--- a/src/Interpreters/InterpreterShowCreateQuery.cpp
+++ b/src/Interpreters/InterpreterShowCreateQuery.cpp
@@ -64,26 +64,26 @@ QueryPipeline InterpreterShowCreateQuery::executeImpl()
         {
             if (!ast_create_query.isView())
                 throw Exception(ErrorCodes::BAD_ARGUMENTS, "{}.{} is not a VIEW",
-                    backQuote(ast_create_query.database), backQuote(ast_create_query.table));
+                    backQuote(ast_create_query.getDatabase()), backQuote(ast_create_query.getTable()));
         }
         else if (is_dictionary)
         {
             if (!ast_create_query.is_dictionary)
                 throw Exception(ErrorCodes::BAD_ARGUMENTS, "{}.{} is not a DICTIONARY",
-                    backQuote(ast_create_query.database), backQuote(ast_create_query.table));
+                    backQuote(ast_create_query.getDatabase()), backQuote(ast_create_query.getTable()));
         }
     }
     else if ((show_query = query_ptr->as<ASTShowCreateDatabaseQuery>()))
     {
         if (show_query->temporary)
             throw Exception("Temporary databases are not possible.", ErrorCodes::SYNTAX_ERROR);
-        show_query->database = getContext()->resolveDatabase(show_query->database);
-        getContext()->checkAccess(AccessType::SHOW_DATABASES, show_query->database);
-        create_query = DatabaseCatalog::instance().getDatabase(show_query->database)->getCreateDatabaseQuery();
+        show_query->setDatabase(getContext()->resolveDatabase(show_query->getDatabase()));
+        getContext()->checkAccess(AccessType::SHOW_DATABASES, show_query->getDatabase());
+        create_query = DatabaseCatalog::instance().getDatabase(show_query->getDatabase())->getCreateDatabaseQuery();
     }
 
     if (!create_query)
-        throw Exception("Unable to show the create query of " + show_query->table + ". Maybe it was created by the system.", ErrorCodes::THERE_IS_NO_QUERY);
+        throw Exception("Unable to show the create query of " + show_query->getTable() + ". Maybe it was created by the system.", ErrorCodes::THERE_IS_NO_QUERY);
 
     if (!getContext()->getSettingsRef().show_table_uuid_in_table_create_query_if_not_nil)
     {
diff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp
index 69bf036ae97b..1610ae56280b 100644
--- a/src/Interpreters/InterpreterSystemQuery.cpp
+++ b/src/Interpreters/InterpreterSystemQuery.cpp
@@ -217,12 +217,12 @@ BlockIO InterpreterSystemQuery::execute()
     /// Make canonical query for simpler processing
     if (query.type == Type::RELOAD_DICTIONARY)
     {
-        if (!query.database.empty())
-            query.table = query.database + "." + query.table;
+        if (query.database)
+            query.setTable(query.getDatabase() + "." + query.getTable());
     }
-    else if (!query.table.empty())
+    else if (query.table)
     {
-        table_id = getContext()->resolveStorageID(StorageID(query.database, query.table), Context::ResolveOrdinary);
+        table_id = getContext()->resolveStorageID(StorageID(query.getDatabase(), query.getTable()), Context::ResolveOrdinary);
     }
 
 
@@ -302,7 +302,7 @@ BlockIO InterpreterSystemQuery::execute()
             getContext()->checkAccess(AccessType::SYSTEM_RELOAD_DICTIONARY);
 
             auto & external_dictionaries_loader = system_context->getExternalDictionariesLoader();
-            external_dictionaries_loader.reloadDictionary(query.table, getContext());
+            external_dictionaries_loader.reloadDictionary(query.getTable(), getContext());
 
             ExternalDictionariesLoader::resetAll();
             break;
@@ -594,10 +594,10 @@ void InterpreterSystemQuery::dropReplica(ASTSystemQuery & query)
         if (!dropReplicaImpl(query, table))
             throw Exception(ErrorCodes::BAD_ARGUMENTS, table_is_not_replicated.data(), table_id.getNameForLogs());
     }
-    else if (!query.database.empty())
+    else if (query.database)
     {
-        getContext()->checkAccess(AccessType::SYSTEM_DROP_REPLICA, query.database);
-        DatabasePtr database = DatabaseCatalog::instance().getDatabase(query.database);
+        getContext()->checkAccess(AccessType::SYSTEM_DROP_REPLICA, query.getDatabase());
+        DatabasePtr database = DatabaseCatalog::instance().getDatabase(query.getDatabase());
         for (auto iterator = database->getTablesIterator(getContext()); iterator->isValid(); iterator->next())
             dropReplicaImpl(query, iterator->table());
         LOG_TRACE(log, "Dropped replica {} from database {}", query.replica, backQuoteIfNeed(database->getDatabaseName()));
@@ -790,84 +790,84 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()
         case Type::STOP_MERGES: [[fallthrough]];
         case Type::START_MERGES:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_MERGES);
             else
-                required_access.emplace_back(AccessType::SYSTEM_MERGES, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_MERGES, query.getDatabase(), query.getTable());
             break;
         }
         case Type::STOP_TTL_MERGES: [[fallthrough]];
         case Type::START_TTL_MERGES:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_TTL_MERGES);
             else
-                required_access.emplace_back(AccessType::SYSTEM_TTL_MERGES, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_TTL_MERGES, query.getDatabase(), query.getTable());
             break;
         }
         case Type::STOP_MOVES: [[fallthrough]];
         case Type::START_MOVES:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_MOVES);
             else
-                required_access.emplace_back(AccessType::SYSTEM_MOVES, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_MOVES, query.getDatabase(), query.getTable());
             break;
         }
         case Type::STOP_FETCHES: [[fallthrough]];
         case Type::START_FETCHES:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_FETCHES);
             else
-                required_access.emplace_back(AccessType::SYSTEM_FETCHES, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_FETCHES, query.getDatabase(), query.getTable());
             break;
         }
         case Type::STOP_DISTRIBUTED_SENDS: [[fallthrough]];
         case Type::START_DISTRIBUTED_SENDS:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_DISTRIBUTED_SENDS);
             else
-                required_access.emplace_back(AccessType::SYSTEM_DISTRIBUTED_SENDS, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_DISTRIBUTED_SENDS, query.getDatabase(), query.getTable());
             break;
         }
         case Type::STOP_REPLICATED_SENDS: [[fallthrough]];
         case Type::START_REPLICATED_SENDS:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_REPLICATED_SENDS);
             else
-                required_access.emplace_back(AccessType::SYSTEM_REPLICATED_SENDS, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_REPLICATED_SENDS, query.getDatabase(), query.getTable());
             break;
         }
         case Type::STOP_REPLICATION_QUEUES: [[fallthrough]];
         case Type::START_REPLICATION_QUEUES:
         {
-            if (query.table.empty())
+            if (!query.table)
                 required_access.emplace_back(AccessType::SYSTEM_REPLICATION_QUEUES);
             else
-                required_access.emplace_back(AccessType::SYSTEM_REPLICATION_QUEUES, query.database, query.table);
+                required_access.emplace_back(AccessType::SYSTEM_REPLICATION_QUEUES, query.getDatabase(), query.getTable());
             break;
         }
         case Type::DROP_REPLICA:
         {
-            required_access.emplace_back(AccessType::SYSTEM_DROP_REPLICA, query.database, query.table);
+            required_access.emplace_back(AccessType::SYSTEM_DROP_REPLICA, query.getDatabase(), query.getTable());
             break;
         }
         case Type::RESTORE_REPLICA:
         {
-            required_access.emplace_back(AccessType::SYSTEM_RESTORE_REPLICA, query.database, query.table);
+            required_access.emplace_back(AccessType::SYSTEM_RESTORE_REPLICA, query.getDatabase(), query.getTable());
             break;
         }
         case Type::SYNC_REPLICA:
         {
-            required_access.emplace_back(AccessType::SYSTEM_SYNC_REPLICA, query.database, query.table);
+            required_access.emplace_back(AccessType::SYSTEM_SYNC_REPLICA, query.getDatabase(), query.getTable());
             break;
         }
         case Type::RESTART_REPLICA:
         {
-            required_access.emplace_back(AccessType::SYSTEM_RESTART_REPLICA, query.database, query.table);
+            required_access.emplace_back(AccessType::SYSTEM_RESTART_REPLICA, query.getDatabase(), query.getTable());
             break;
         }
         case Type::RESTART_REPLICAS:
@@ -877,7 +877,7 @@ AccessRightsElements InterpreterSystemQuery::getRequiredAccessForDDLOnCluster()
         }
         case Type::FLUSH_DISTRIBUTED:
         {
-            required_access.emplace_back(AccessType::SYSTEM_FLUSH_DISTRIBUTED, query.database, query.table);
+            required_access.emplace_back(AccessType::SYSTEM_FLUSH_DISTRIBUTED, query.getDatabase(), query.getTable());
             break;
         }
         case Type::FLUSH_LOGS:
diff --git a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
index 187c3dd01915..54b87e3bed6e 100644
--- a/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
+++ b/src/Interpreters/MySQL/InterpretersMySQLDDLQuery.cpp
@@ -449,8 +449,8 @@ ASTs InterpreterCreateImpl::getRewrittenQueries(
         String table_name = table_like->shortName();
         ASTPtr rewritten_create_ast = DatabaseCatalog::instance().getDatabase(mapped_to_database)->getCreateTableQuery(table_name, context);
         auto * create_ptr = rewritten_create_ast->as<ASTCreateQuery>();
-        create_ptr->database = mapped_to_database;
-        create_ptr->table = create_query.table;
+        create_ptr->setDatabase(mapped_to_database);
+        create_ptr->setTable(create_query.table);
         create_ptr->uuid = UUIDHelpers::generateV4();
         create_ptr->if_not_exists = create_query.if_not_exists;
         return ASTs{rewritten_create_ast};
@@ -513,8 +513,8 @@ ASTs InterpreterCreateImpl::getRewrittenQueries(
 
     storage->set(storage->engine, makeASTFunction("ReplacingMergeTree", std::make_shared<ASTIdentifier>(version_column_name)));
 
-    rewritten_query->database = mapped_to_database;
-    rewritten_query->table = create_query.table;
+    rewritten_query->setDatabase(mapped_to_database);
+    rewritten_query->setTable(create_query.table);
     rewritten_query->if_not_exists = create_query.if_not_exists;
     rewritten_query->set(rewritten_query->storage, storage);
     rewritten_query->set(rewritten_query->columns_list, columns);
@@ -529,14 +529,14 @@ void InterpreterDropImpl::validate(const InterpreterDropImpl::TQuery & /*query*/
 ASTs InterpreterDropImpl::getRewrittenQueries(
     const InterpreterDropImpl::TQuery & drop_query, ContextPtr context, const String & mapped_to_database, const String & mysql_database)
 {
-    const auto & database_name = resolveDatabase(drop_query.database, mysql_database, mapped_to_database, context);
+    const auto & database_name = resolveDatabase(drop_query.getDatabase(), mysql_database, mapped_to_database, context);
 
     /// Skip drop database|view|dictionary
-    if (database_name != mapped_to_database || drop_query.table.empty() || drop_query.is_view || drop_query.is_dictionary)
+    if (database_name != mapped_to_database || !drop_query.table || drop_query.is_view || drop_query.is_dictionary)
         return {};
 
     ASTPtr rewritten_query = drop_query.clone();
-    rewritten_query->as<ASTDropQuery>()->database = mapped_to_database;
+    rewritten_query->as<ASTDropQuery>()->setDatabase(mapped_to_database);
     return ASTs{rewritten_query};
 }
 
@@ -588,8 +588,8 @@ ASTs InterpreterAlterImpl::getRewrittenQueries(
 
     auto rewritten_alter_query = std::make_shared<ASTAlterQuery>();
     auto rewritten_rename_query = std::make_shared<ASTRenameQuery>();
-    rewritten_alter_query->database = mapped_to_database;
-    rewritten_alter_query->table = alter_query.table;
+    rewritten_alter_query->setDatabase(mapped_to_database);
+    rewritten_alter_query->setTable(alter_query.table);
     rewritten_alter_query->alter_object = ASTAlterQuery::AlterObjectType::TABLE;
     rewritten_alter_query->set(rewritten_alter_query->command_list, std::make_shared<ASTExpressionList>());
 
diff --git a/src/Interpreters/StorageID.cpp b/src/Interpreters/StorageID.cpp
index 2e76618e4c0d..8811adc087bd 100644
--- a/src/Interpreters/StorageID.cpp
+++ b/src/Interpreters/StorageID.cpp
@@ -18,8 +18,8 @@ namespace ErrorCodes
 
 StorageID::StorageID(const ASTQueryWithTableAndOutput & query)
 {
-    database_name = query.database;
-    table_name = query.table;
+    database_name = query.getDatabase();
+    table_name = query.getTable();
     uuid = query.uuid;
     assertNotEmpty();
 }
diff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h
index ce0062e8c77f..ee3e3062e137 100644
--- a/src/Interpreters/SystemLog.h
+++ b/src/Interpreters/SystemLog.h
@@ -595,8 +595,8 @@ ASTPtr SystemLog<LogElement>::getCreateTableQuery()
 {
     auto create = std::make_shared<ASTCreateQuery>();
 
-    create->database = table_id.database_name;
-    create->table = table_id.table_name;
+    create->setDatabase(table_id.database_name);
+    create->setTable(table_id.table_name);
 
     auto ordinary_columns = LogElement::getNamesAndTypes();
     auto alias_columns = LogElement::getNamesAndAliases();
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index f401f708ab14..f67eac108785 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -431,12 +431,6 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 InterpreterSetQuery(query_with_output->settings_ast, context).executeForCurrentContext();
         }
 
-        if (const auto * query_with_table_output = dynamic_cast<const ASTQueryWithTableAndOutput *>(ast.get()))
-        {
-            query_database = query_with_table_output->database;
-            query_table = query_with_table_output->table;
-        }
-
         if (auto * create_query = ast->as<ASTCreateQuery>())
         {
             if (create_query->select)
@@ -510,6 +504,12 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
             query = serializeAST(*ast);
         }
 
+        if (const auto * query_with_table_output = dynamic_cast<const ASTQueryWithTableAndOutput *>(ast.get()))
+        {
+            query_database = query_with_table_output->getDatabase();
+            query_table = query_with_table_output->getTable();
+        }
+
         /// MUST go before any modification (except for prepared statements,
         /// since it substitute parameters and w/o them query does not contain
         /// parameters), to keep query as-is in query_log and server log.
diff --git a/src/Interpreters/loadMetadata.cpp b/src/Interpreters/loadMetadata.cpp
index 96f94b965294..c5bef6f72055 100644
--- a/src/Interpreters/loadMetadata.cpp
+++ b/src/Interpreters/loadMetadata.cpp
@@ -39,7 +39,7 @@ static void executeCreateQuery(
         parser, query.data(), query.data() + query.size(), "in file " + file_name, 0, context->getSettingsRef().max_parser_depth);
 
     auto & ast_create_query = ast->as<ASTCreateQuery &>();
-    ast_create_query.database = database;
+    ast_create_query.setDatabase(database);
 
     InterpreterCreateQuery interpreter(ast, context);
     interpreter.setInternal(true);
diff --git a/src/Parsers/ASTAlterQuery.cpp b/src/Parsers/ASTAlterQuery.cpp
index 50c56c9aeff6..2ae494854ec7 100644
--- a/src/Parsers/ASTAlterQuery.cpp
+++ b/src/Parsers/ASTAlterQuery.cpp
@@ -485,7 +485,7 @@ bool ASTAlterQuery::isDropPartitionAlter() const
 /** Get the text that identifies this element. */
 String ASTAlterQuery::getID(char delim) const
 {
-    return "AlterQuery" + (delim + database) + delim + table;
+    return "AlterQuery" + (delim + getDatabase()) + delim + getTable();
 }
 
 ASTPtr ASTAlterQuery::clone() const
@@ -523,18 +523,18 @@ void ASTAlterQuery::formatQueryImpl(const FormatSettings & settings, FormatState
 
     settings.ostr << (settings.hilite ? hilite_none : "");
 
-    if (!table.empty())
+    if (table)
     {
-        if (!database.empty())
+        if (database)
         {
-            settings.ostr << indent_str << backQuoteIfNeed(database);
+            settings.ostr << indent_str << backQuoteIfNeed(getDatabase());
             settings.ostr << ".";
         }
-        settings.ostr << indent_str << backQuoteIfNeed(table);
+        settings.ostr << indent_str << backQuoteIfNeed(getTable());
     }
-    else if (alter_object == AlterObjectType::DATABASE && !database.empty())
+    else if (alter_object == AlterObjectType::DATABASE && database)
     {
-        settings.ostr << indent_str << backQuoteIfNeed(database);
+        settings.ostr << indent_str << backQuoteIfNeed(getDatabase());
     }
 
     formatOnCluster(settings);
diff --git a/src/Parsers/ASTCheckQuery.h b/src/Parsers/ASTCheckQuery.h
index fdd1179ec905..8b376ef8d600 100644
--- a/src/Parsers/ASTCheckQuery.h
+++ b/src/Parsers/ASTCheckQuery.h
@@ -12,13 +12,14 @@ struct ASTCheckQuery : public ASTQueryWithTableAndOutput
     ASTPtr partition;
 
     /** Get the text that identifies this element. */
-    String getID(char delim) const override { return "CheckQuery" + (delim + database) + delim + table; }
+    String getID(char delim) const override { return "CheckQuery" + (delim + getDatabase()) + delim + getTable(); }
 
     ASTPtr clone() const override
     {
         auto res = std::make_shared<ASTCheckQuery>(*this);
         res->children.clear();
         cloneOutputOptions(*res);
+        cloneTableOptions(*res);
         return res;
     }
 
@@ -32,14 +33,14 @@ struct ASTCheckQuery : public ASTQueryWithTableAndOutput
 
         settings.ostr << (settings.hilite ? hilite_keyword : "") << indent_str << "CHECK TABLE " << (settings.hilite ? hilite_none : "");
 
-        if (!table.empty())
+        if (table)
         {
-            if (!database.empty())
+            if (database)
             {
-                settings.ostr << (settings.hilite ? hilite_keyword : "") << indent_str << backQuoteIfNeed(database) << (settings.hilite ? hilite_none : "");
+                settings.ostr << (settings.hilite ? hilite_keyword : "") << indent_str << backQuoteIfNeed(getDatabase()) << (settings.hilite ? hilite_none : "");
                 settings.ostr << ".";
             }
-            settings.ostr << (settings.hilite ? hilite_keyword : "") << indent_str << backQuoteIfNeed(table) << (settings.hilite ? hilite_none : "");
+            settings.ostr << (settings.hilite ? hilite_keyword : "") << indent_str << backQuoteIfNeed(getTable()) << (settings.hilite ? hilite_none : "");
         }
 
         if (partition)
diff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp
index 2c0488862475..608098b8d953 100644
--- a/src/Parsers/ASTCreateQuery.cpp
+++ b/src/Parsers/ASTCreateQuery.cpp
@@ -212,6 +212,7 @@ ASTPtr ASTCreateQuery::clone() const
         res->set(res->comment, comment->clone());
 
     cloneOutputOptions(*res);
+    cloneTableOptions(*res);
 
     return res;
 }
@@ -220,13 +221,13 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat
 {
     frame.need_parens = false;
 
-    if (!database.empty() && table.empty())
+    if (database && !table)
     {
         settings.ostr << (settings.hilite ? hilite_keyword : "")
             << (attach ? "ATTACH DATABASE " : "CREATE DATABASE ")
             << (if_not_exists ? "IF NOT EXISTS " : "")
             << (settings.hilite ? hilite_none : "")
-            << backQuoteIfNeed(database);
+            << backQuoteIfNeed(getDatabase());
 
         if (uuid != UUIDHelpers::Nil)
         {
@@ -275,7 +276,7 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat
                 << what << " "
                 << (if_not_exists ? "IF NOT EXISTS " : "")
             << (settings.hilite ? hilite_none : "")
-            << (!database.empty() ? backQuoteIfNeed(database) + "." : "") << backQuoteIfNeed(table);
+            << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
 
         if (uuid != UUIDHelpers::Nil)
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " UUID " << (settings.hilite ? hilite_none : "")
@@ -316,7 +317,7 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat
         /// Always DICTIONARY
         settings.ostr << (settings.hilite ? hilite_keyword : "") << action << " DICTIONARY "
                       << (if_not_exists ? "IF NOT EXISTS " : "") << (settings.hilite ? hilite_none : "")
-                      << (!database.empty() ? backQuoteIfNeed(database) + "." : "") << backQuoteIfNeed(table);
+                      << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
         if (uuid != UUIDHelpers::Nil)
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " UUID " << (settings.hilite ? hilite_none : "")
                           << quoteString(toString(uuid));
diff --git a/src/Parsers/ASTCreateQuery.h b/src/Parsers/ASTCreateQuery.h
index 51c4ac15e67a..4c7768517b13 100644
--- a/src/Parsers/ASTCreateQuery.h
+++ b/src/Parsers/ASTCreateQuery.h
@@ -91,7 +91,7 @@ class ASTCreateQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnC
     bool create_or_replace{false};
 
     /** Get the text that identifies this element. */
-    String getID(char delim) const override { return (attach ? "AttachQuery" : "CreateQuery") + (delim + database) + delim + table; }
+    String getID(char delim) const override { return (attach ? "AttachQuery" : "CreateQuery") + (delim + getDatabase()) + delim + getTable(); }
 
     ASTPtr clone() const override;
 
diff --git a/src/Parsers/ASTDropQuery.cpp b/src/Parsers/ASTDropQuery.cpp
index 6ea6c81c3be8..9e815ee75deb 100644
--- a/src/Parsers/ASTDropQuery.cpp
+++ b/src/Parsers/ASTDropQuery.cpp
@@ -15,11 +15,11 @@ namespace ErrorCodes
 String ASTDropQuery::getID(char delim) const
 {
     if (kind == ASTDropQuery::Kind::Drop)
-        return "DropQuery" + (delim + database) + delim + table;
+        return "DropQuery" + (delim + getDatabase()) + delim + getTable();
     else if (kind == ASTDropQuery::Kind::Detach)
-        return "DetachQuery" + (delim + database) + delim + table;
+        return "DetachQuery" + (delim + getDatabase()) + delim + getTable();
     else if (kind == ASTDropQuery::Kind::Truncate)
-        return "TruncateQuery" + (delim + database) + delim + table;
+        return "TruncateQuery" + (delim + getDatabase()) + delim + getTable();
     else
         throw Exception("Not supported kind of drop query.", ErrorCodes::SYNTAX_ERROR);
 }
@@ -28,6 +28,7 @@ ASTPtr ASTDropQuery::clone() const
 {
     auto res = std::make_shared<ASTDropQuery>(*this);
     cloneOutputOptions(*res);
+    cloneTableOptions(*res);
     return res;
 }
 
@@ -46,7 +47,8 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState
     if (temporary)
         settings.ostr << "TEMPORARY ";
 
-    if (table.empty() && !database.empty())
+
+    if (!table && database)
         settings.ostr << "DATABASE ";
     else if (is_dictionary)
         settings.ostr << "DICTIONARY ";
@@ -60,10 +62,10 @@ void ASTDropQuery::formatQueryImpl(const FormatSettings & settings, FormatState
 
     settings.ostr << (settings.hilite ? hilite_none : "");
 
-    if (table.empty() && !database.empty())
-        settings.ostr << backQuoteIfNeed(database);
+    if (!table && database)
+        settings.ostr << backQuoteIfNeed(getDatabase());
     else
-        settings.ostr << (!database.empty() ? backQuoteIfNeed(database) + "." : "") << backQuoteIfNeed(table);
+        settings.ostr << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
 
     formatOnCluster(settings);
 
diff --git a/src/Parsers/ASTIdentifier.cpp b/src/Parsers/ASTIdentifier.cpp
index 58052b1419bb..a889680c81ff 100644
--- a/src/Parsers/ASTIdentifier.cpp
+++ b/src/Parsers/ASTIdentifier.cpp
@@ -201,6 +201,40 @@ String ASTTableIdentifier::getDatabaseName() const
     else return {};
 }
 
+ASTPtr ASTTableIdentifier::getTable() const
+{
+    if (name_parts.size() == 2)
+    {
+        if (!name_parts[1].empty())
+            return std::make_shared<ASTIdentifier>(name_parts[1]);
+
+        if (name_parts[0].empty())
+            return std::make_shared<ASTIdentifier>("", children[1]->clone());
+        else
+            return std::make_shared<ASTIdentifier>("", children[0]->clone());
+    }
+    else if (name_parts.size() == 1)
+    {
+        if (name_parts[0].empty())
+            return std::make_shared<ASTIdentifier>("", children[0]->clone());
+        else
+            return std::make_shared<ASTIdentifier>(name_parts[0]);
+    }
+    else return {};
+}
+
+ASTPtr ASTTableIdentifier::getDatabase() const
+{
+    if (name_parts.size() == 2)
+    {
+        if (name_parts[0].empty())
+            return std::make_shared<ASTIdentifier>("", children[0]->clone());
+        else
+            return std::make_shared<ASTIdentifier>(name_parts[0]);
+    }
+    else return {};
+}
+
 void ASTTableIdentifier::resetTable(const String & database_name, const String & table_name)
 {
     auto identifier = std::make_shared<ASTTableIdentifier>(database_name, table_name);
diff --git a/src/Parsers/ASTIdentifier.h b/src/Parsers/ASTIdentifier.h
index 323280e07bc1..048b32e438dc 100644
--- a/src/Parsers/ASTIdentifier.h
+++ b/src/Parsers/ASTIdentifier.h
@@ -61,6 +61,7 @@ class ASTIdentifier : public ASTWithAlias
 private:
     using ASTWithAlias::children; /// ASTIdentifier is child free
 
+    friend class ASTTableIdentifier;
     friend class ReplaceQueryParameterVisitor;
     friend struct IdentifierSemantic;
     friend void setIdentifierSpecial(ASTPtr & ast);
@@ -83,6 +84,9 @@ class ASTTableIdentifier : public ASTIdentifier
     StorageID getTableId() const;
     String getDatabaseName() const;
 
+    ASTPtr getTable() const;
+    ASTPtr getDatabase() const;
+
     // FIXME: used only when it's needed to rewrite distributed table name to real remote table name.
     void resetTable(const String & database_name, const String & table_name);  // TODO(ilezhankin): get rid of this
 
diff --git a/src/Parsers/ASTInsertQuery.cpp b/src/Parsers/ASTInsertQuery.cpp
index 3c8c31b85dd1..c733398a32b2 100644
--- a/src/Parsers/ASTInsertQuery.cpp
+++ b/src/Parsers/ASTInsertQuery.cpp
@@ -1,4 +1,5 @@
 #include <iomanip>
+#include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTInsertQuery.h>
 #include <Parsers/ASTFunction.h>
 #include <Parsers/ASTLiteral.h>
@@ -15,6 +16,35 @@ namespace ErrorCodes
     extern const int INVALID_USAGE_OF_INPUT;
 }
 
+String ASTInsertQuery::getDatabase() const
+{
+    String name;
+    tryGetIdentifierNameInto(database, name);
+    return name;
+}
+
+String ASTInsertQuery::getTable() const
+{
+    String name;
+    tryGetIdentifierNameInto(table, name);
+    return name;
+}
+
+void ASTInsertQuery::setDatabase(const String & name)
+{
+    if (name.empty())
+        database.reset();
+    else
+        database = std::make_shared<ASTIdentifier>(name);
+}
+
+void ASTInsertQuery::setTable(const String & name)
+{
+    if (name.empty())
+        table.reset();
+    else
+        table = std::make_shared<ASTIdentifier>(name);
+}
 
 void ASTInsertQuery::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
 {
@@ -31,9 +61,16 @@ void ASTInsertQuery::formatImpl(const FormatSettings & settings, FormatState & s
             partition_by->formatImpl(settings, state, frame);
         }
     }
-    else
+    else if (table_id)
+    {
         settings.ostr << (settings.hilite ? hilite_none : "")
                       << (!table_id.database_name.empty() ? backQuoteIfNeed(table_id.database_name) + "." : "") << backQuoteIfNeed(table_id.table_name);
+    }
+    else
+    {
+        settings.ostr << (settings.hilite ? hilite_none : "")
+                      << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
+    }
 
     if (columns)
     {
diff --git a/src/Parsers/ASTInsertQuery.h b/src/Parsers/ASTInsertQuery.h
index 81925ec2e66d..d539ad5fdb35 100644
--- a/src/Parsers/ASTInsertQuery.h
+++ b/src/Parsers/ASTInsertQuery.h
@@ -13,6 +13,10 @@ class ASTInsertQuery : public IAST
 {
 public:
     StorageID table_id = StorageID::createEmpty();
+
+    ASTPtr database;
+    ASTPtr table;
+
     ASTPtr columns;
     String format;
     ASTPtr table_function;
@@ -31,6 +35,12 @@ class ASTInsertQuery : public IAST
     /// Data from buffer to insert after inlined one - may be nullptr.
     ReadBuffer * tail = nullptr;
 
+    String getDatabase() const;
+    String getTable() const;
+
+    void setDatabase(const String & name);
+    void setTable(const String & name);
+
     bool hasInlinedData() const { return data || tail; }
 
     /// Try to find table function input() in SELECT part
@@ -44,6 +54,8 @@ class ASTInsertQuery : public IAST
         auto res = std::make_shared<ASTInsertQuery>(*this);
         res->children.clear();
 
+        if (database) { res->database = database->clone(); res->children.push_back(res->database); }
+        if (table) { res->table = table->clone(); res->children.push_back(res->table); }
         if (columns) { res->columns = columns->clone(); res->children.push_back(res->columns); }
         if (select) { res->select = select->clone(); res->children.push_back(res->select); }
         if (watch) { res->watch = watch->clone(); res->children.push_back(res->watch); }
diff --git a/src/Parsers/ASTOptimizeQuery.cpp b/src/Parsers/ASTOptimizeQuery.cpp
index 6423e247ecc6..720c7699fb6b 100644
--- a/src/Parsers/ASTOptimizeQuery.cpp
+++ b/src/Parsers/ASTOptimizeQuery.cpp
@@ -8,7 +8,7 @@ namespace DB
 void ASTOptimizeQuery::formatQueryImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
 {
     settings.ostr << (settings.hilite ? hilite_keyword : "") << "OPTIMIZE TABLE " << (settings.hilite ? hilite_none : "")
-                  << (!database.empty() ? backQuoteIfNeed(database) + "." : "") << backQuoteIfNeed(table);
+                  << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
 
     formatOnCluster(settings);
 
diff --git a/src/Parsers/ASTOptimizeQuery.h b/src/Parsers/ASTOptimizeQuery.h
index f4981d156c7b..cac2ef1c6d09 100644
--- a/src/Parsers/ASTOptimizeQuery.h
+++ b/src/Parsers/ASTOptimizeQuery.h
@@ -25,7 +25,7 @@ class ASTOptimizeQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithO
     /** Get the text that identifies this element. */
     String getID(char delim) const override
     {
-        return "OptimizeQuery" + (delim + database) + delim + table + (final ? "_final" : "") + (deduplicate ? "_deduplicate" : "");
+        return "OptimizeQuery" + (delim + getDatabase()) + delim + getTable() + (final ? "_final" : "") + (deduplicate ? "_deduplicate" : "");
     }
 
     ASTPtr clone() const override
diff --git a/src/Parsers/ASTQueryWithOnCluster.h b/src/Parsers/ASTQueryWithOnCluster.h
index e053b50ffb2d..b309ae5e8479 100644
--- a/src/Parsers/ASTQueryWithOnCluster.h
+++ b/src/Parsers/ASTQueryWithOnCluster.h
@@ -39,8 +39,8 @@ class ASTQueryWithOnCluster
         T & query = static_cast<T &>(*query_ptr);
 
         query.cluster.clear();
-        if (query.database.empty())
-            query.database = new_database;
+        if (!query.database)
+            query.setDatabase(new_database);
 
         return query_ptr;
     }
diff --git a/src/Parsers/ASTQueryWithTableAndOutput.cpp b/src/Parsers/ASTQueryWithTableAndOutput.cpp
index d44ba988d7ae..a216aeaa11f1 100644
--- a/src/Parsers/ASTQueryWithTableAndOutput.cpp
+++ b/src/Parsers/ASTQueryWithTableAndOutput.cpp
@@ -1,3 +1,4 @@
+#include <Parsers/ASTIdentifier.h>
 #include <Parsers/ASTQueryWithTableAndOutput.h>
 #include <Common/quoteString.h>
 #include <IO/Operators.h>
@@ -6,10 +7,67 @@
 namespace DB
 {
 
+String ASTQueryWithTableAndOutput::getDatabase() const
+{
+    String name;
+    tryGetIdentifierNameInto(database, name);
+    return name;
+}
+
+String ASTQueryWithTableAndOutput::getTable() const
+{
+    String name;
+    tryGetIdentifierNameInto(table, name);
+    return name;
+}
+
+void ASTQueryWithTableAndOutput::setDatabase(const String & name)
+{
+    if (database)
+    {
+        std::erase(children, database);
+        database.reset();
+    }
+
+    if (!name.empty())
+    {
+        database = std::make_shared<ASTIdentifier>(name);
+        children.push_back(database);
+    }
+}
+
+void ASTQueryWithTableAndOutput::setTable(const String & name)
+{
+    if (table)
+    {
+        std::erase(children, table);
+        table.reset();
+    }
+
+    if (!name.empty())
+    {
+        table = std::make_shared<ASTIdentifier>(name);
+        children.push_back(table);
+    }
+}
+
+void ASTQueryWithTableAndOutput::cloneTableOptions(ASTQueryWithTableAndOutput & cloned) const
+{
+    if (database)
+    {
+        cloned.database = database->clone();
+        cloned.children.push_back(cloned.database);
+    }
+    if (table)
+    {
+        cloned.table = table->clone();
+        cloned.children.push_back(cloned.table);
+    }
+}
 void ASTQueryWithTableAndOutput::formatHelper(const FormatSettings & settings, const char * name) const
 {
     settings.ostr << (settings.hilite ? hilite_keyword : "") << name << " " << (settings.hilite ? hilite_none : "");
-    settings.ostr << (!database.empty() ? backQuoteIfNeed(database) + "." : "") << backQuoteIfNeed(table);
+    settings.ostr << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
 }
 
 }
diff --git a/src/Parsers/ASTQueryWithTableAndOutput.h b/src/Parsers/ASTQueryWithTableAndOutput.h
index 03f5fa7bf22e..233028c50236 100644
--- a/src/Parsers/ASTQueryWithTableAndOutput.h
+++ b/src/Parsers/ASTQueryWithTableAndOutput.h
@@ -14,11 +14,21 @@ namespace DB
 class ASTQueryWithTableAndOutput : public ASTQueryWithOutput
 {
 public:
-    String database;
-    String table;
+    ASTPtr database;
+    ASTPtr table;
+
     UUID uuid = UUIDHelpers::Nil;
     bool temporary{false};
 
+    String getDatabase() const;
+    String getTable() const;
+
+    // Once database or table are set they cannot be assigned with empty value
+    void setDatabase(const String & name);
+    void setTable(const String & name);
+
+    void cloneTableOptions(ASTQueryWithTableAndOutput & cloned) const;
+
 protected:
     void formatHelper(const FormatSettings & settings, const char * name) const;
 };
@@ -28,13 +38,14 @@ template <typename AstIDAndQueryNames>
 class ASTQueryWithTableAndOutputImpl : public ASTQueryWithTableAndOutput
 {
 public:
-    String getID(char delim) const override { return AstIDAndQueryNames::ID + (delim + database) + delim + table; }
+    String getID(char delim) const override { return AstIDAndQueryNames::ID + (delim + getDatabase()) + delim + getTable(); }
 
     ASTPtr clone() const override
     {
         auto res = std::make_shared<ASTQueryWithTableAndOutputImpl<AstIDAndQueryNames>>(*this);
         res->children.clear();
         cloneOutputOptions(*res);
+        cloneTableOptions(*res);
         return res;
     }
 
diff --git a/src/Parsers/ASTSystemQuery.cpp b/src/Parsers/ASTSystemQuery.cpp
index ba8e49b98cac..b8056862bfc4 100644
--- a/src/Parsers/ASTSystemQuery.cpp
+++ b/src/Parsers/ASTSystemQuery.cpp
@@ -1,3 +1,4 @@
+#include <Parsers/ASTIdentifier.h>
 #include <Parsers/IAST.h>
 #include <Parsers/ASTSystemQuery.h>
 #include <Common/quoteString.h>
@@ -39,6 +40,50 @@ const char * ASTSystemQuery::typeToString(Type type)
     return type_name.data();
 }
 
+String ASTSystemQuery::getDatabase() const
+{
+    String name;
+    tryGetIdentifierNameInto(database, name);
+    return name;
+}
+
+String ASTSystemQuery::getTable() const
+{
+    String name;
+    tryGetIdentifierNameInto(table, name);
+    return name;
+}
+
+void ASTSystemQuery::setDatabase(const String & name)
+{
+    if (database)
+    {
+        std::erase(children, database);
+        database.reset();
+    }
+
+    if (!name.empty())
+    {
+        database = std::make_shared<ASTIdentifier>(name);
+        children.push_back(database);
+    }
+}
+
+void ASTSystemQuery::setTable(const String & name)
+{
+    if (table)
+    {
+        std::erase(children, table);
+        table.reset();
+    }
+
+    if (!name.empty())
+    {
+        table = std::make_shared<ASTIdentifier>(name);
+        children.push_back(table);
+    }
+}
+
 void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const
 {
     settings.ostr << (settings.hilite ? hilite_keyword : "") << "SYSTEM ";
@@ -47,19 +92,19 @@ void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &,
     auto print_database_table = [&]
     {
         settings.ostr << " ";
-        if (!database.empty())
+        if (database)
         {
-            settings.ostr << (settings.hilite ? hilite_identifier : "") << backQuoteIfNeed(database)
+            settings.ostr << (settings.hilite ? hilite_identifier : "") << backQuoteIfNeed(getDatabase())
                           << (settings.hilite ? hilite_none : "") << ".";
         }
-        settings.ostr << (settings.hilite ? hilite_identifier : "") << backQuoteIfNeed(table)
+        settings.ostr << (settings.hilite ? hilite_identifier : "") << backQuoteIfNeed(getTable())
                       << (settings.hilite ? hilite_none : "");
     };
 
     auto print_drop_replica = [&]
     {
         settings.ostr << " " << quoteString(replica);
-        if (!table.empty())
+        if (table)
         {
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM TABLE"
                           << (settings.hilite ? hilite_none : "");
@@ -70,11 +115,11 @@ void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &,
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM ZKPATH "
                           << (settings.hilite ? hilite_none : "") << quoteString(replica_zk_path);
         }
-        else if (!database.empty())
+        else if (database)
         {
             settings.ostr << (settings.hilite ? hilite_keyword : "") << " FROM DATABASE "
                           << (settings.hilite ? hilite_none : "");
-            settings.ostr << (settings.hilite ? hilite_identifier : "") << backQuoteIfNeed(database)
+            settings.ostr << (settings.hilite ? hilite_identifier : "") << backQuoteIfNeed(getDatabase())
                           << (settings.hilite ? hilite_none : "");
         }
     };
@@ -107,7 +152,7 @@ void ASTSystemQuery::formatImpl(const FormatSettings & settings, FormatState &,
         || type == Type::STOP_DISTRIBUTED_SENDS
         || type == Type::START_DISTRIBUTED_SENDS)
     {
-        if (!table.empty())
+        if (table)
             print_database_table();
         else if (!volume.empty())
             print_on_volume();
diff --git a/src/Parsers/ASTSystemQuery.h b/src/Parsers/ASTSystemQuery.h
index 419c22dd0d50..16f8a3c118aa 100644
--- a/src/Parsers/ASTSystemQuery.h
+++ b/src/Parsers/ASTSystemQuery.h
@@ -70,10 +70,17 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster
 
     Type type = Type::UNKNOWN;
 
+    ASTPtr database;
+    ASTPtr table;
+
+    String getDatabase() const;
+    String getTable() const;
+
+    void setDatabase(const String & name);
+    void setTable(const String & name);
+
     String target_model;
     String target_function;
-    String database;
-    String table;
     String replica;
     String replica_zk_path;
     bool is_drop_whole_replica{};
@@ -84,7 +91,16 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster
 
     String getID(char) const override { return "SYSTEM query"; }
 
-    ASTPtr clone() const override { return std::make_shared<ASTSystemQuery>(*this); }
+    ASTPtr clone() const override
+    {
+        auto res = std::make_shared<ASTSystemQuery>(*this);
+        res->children.clear();
+
+        if (database) { res->database = database->clone(); res->children.push_back(res->database); }
+        if (table) { res->table = table->clone(); res->children.push_back(res->table); }
+
+        return res;
+    }
 
     ASTPtr getRewrittenASTWithoutOnCluster(const std::string & new_database) const override
     {
diff --git a/src/Parsers/ASTWatchQuery.h b/src/Parsers/ASTWatchQuery.h
index 7db6443e024c..ea02c18a51d7 100644
--- a/src/Parsers/ASTWatchQuery.h
+++ b/src/Parsers/ASTWatchQuery.h
@@ -26,13 +26,14 @@ class ASTWatchQuery : public ASTQueryWithTableAndOutput
     bool is_watch_events;
 
     ASTWatchQuery() = default;
-    String getID(char) const override { return "WatchQuery_" + database + "_" + table; }
+    String getID(char) const override { return "WatchQuery_" + getDatabase() + "_" + getTable(); }
 
     ASTPtr clone() const override
     {
         std::shared_ptr<ASTWatchQuery> res = std::make_shared<ASTWatchQuery>(*this);
         res->children.clear();
         cloneOutputOptions(*res);
+        cloneTableOptions(*res);
         return res;
     }
 
@@ -42,7 +43,7 @@ class ASTWatchQuery : public ASTQueryWithTableAndOutput
         std::string indent_str = s.one_line ? "" : std::string(4 * frame.indent, ' ');
 
         s.ostr << (s.hilite ? hilite_keyword : "") << "WATCH " << (s.hilite ? hilite_none : "")
-            << (!database.empty() ? backQuoteIfNeed(database) + "." : "") << backQuoteIfNeed(table);
+            << (database ? backQuoteIfNeed(getDatabase()) + "." : "") << backQuoteIfNeed(getTable());
 
         if (is_watch_events)
         {
diff --git a/src/Parsers/ParserAlterQuery.cpp b/src/Parsers/ParserAlterQuery.cpp
index 1ea64d94fe7f..66645ccaf0e9 100644
--- a/src/Parsers/ParserAlterQuery.cpp
+++ b/src/Parsers/ParserAlterQuery.cpp
@@ -861,12 +861,12 @@ bool ParserAlterQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 
     if (alter_object_type == ASTAlterQuery::AlterObjectType::DATABASE)
     {
-        if (!parseDatabase(pos, expected, query->database))
+        if (!parseDatabaseAsAST(pos, expected, query->database))
             return false;
     }
     else
     {
-        if (!parseDatabaseAndTableName(pos, expected, query->database, query->table))
+        if (!parseDatabaseAndTableAsAST(pos, expected, query->database, query->table))
             return false;
 
         String cluster_str;
@@ -886,6 +886,12 @@ bool ParserAlterQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     query->set(query->command_list, command_list);
     query->alter_object = alter_object_type;
 
+    if (query->database)
+        query->children.push_back(query->database);
+
+    if (query->table)
+        query->children.push_back(query->table);
+
     return true;
 }
 
diff --git a/src/Parsers/ParserCheckQuery.cpp b/src/Parsers/ParserCheckQuery.cpp
index c397e1c33c52..a89416ab2538 100644
--- a/src/Parsers/ParserCheckQuery.cpp
+++ b/src/Parsers/ParserCheckQuery.cpp
@@ -4,6 +4,7 @@
 #include <Parsers/ExpressionElementParsers.h>
 #include <Parsers/ASTCheckQuery.h>
 #include <Parsers/ParserPartition.h>
+#include <Parsers/parseDatabaseAndTableName.h>
 
 
 namespace DB
@@ -15,31 +16,15 @@ bool ParserCheckQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     ParserKeyword s_partition("PARTITION");
     ParserToken s_dot(TokenType::Dot);
 
-    ParserIdentifier table_parser;
     ParserPartition partition_parser;
 
-    ASTPtr table;
-    ASTPtr database;
-
     if (!s_check_table.ignore(pos, expected))
         return false;
-    if (!table_parser.parse(pos, database, expected))
-        return false;
 
     auto query = std::make_shared<ASTCheckQuery>();
-    if (s_dot.ignore(pos))
-    {
-        if (!table_parser.parse(pos, table, expected))
-            return false;
 
-        tryGetIdentifierNameInto(database, query->database);
-        tryGetIdentifierNameInto(table, query->table);
-    }
-    else
-    {
-        table = database;
-        tryGetIdentifierNameInto(table, query->table);
-    }
+    if (!parseDatabaseAndTableAsAST(pos, expected, query->database, query->table))
+        return false;
 
     if (s_partition.ignore(pos, expected))
     {
@@ -47,6 +32,12 @@ bool ParserCheckQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
             return false;
     }
 
+    if (query->database)
+        query->children.push_back(query->database);
+
+    if (query->table)
+        query->children.push_back(query->table);
+
     node = query;
     return true;
 }
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index af2966948fb7..bc08d4206840 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -426,7 +426,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
     ParserKeyword s_temporary("TEMPORARY");
     ParserKeyword s_table("TABLE");
     ParserKeyword s_if_not_exists("IF NOT EXISTS");
-    ParserCompoundIdentifier table_name_p(true);
+    ParserCompoundIdentifier table_name_p(true, true);
     ParserKeyword s_from("FROM");
     ParserKeyword s_on("ON");
     ParserKeyword s_as("AS");
@@ -495,7 +495,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
             return false;
     }
 
-    auto table_id = table->as<ASTTableIdentifier>()->getTableId();
+    auto * table_id = table->as<ASTTableIdentifier>();
 
     // Shortcut for ATTACH a previously detached table
     bool short_attach = attach && !from_path;
@@ -508,9 +508,14 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
         query->if_not_exists = if_not_exists;
         query->cluster = cluster_str;
 
-        query->database = table_id.database_name;
-        query->table = table_id.table_name;
-        query->uuid = table_id.uuid;
+        query->database = table_id->getDatabase();
+        query->table = table_id->getTable();
+        query->uuid = table_id->uuid;
+
+        if (query->database)
+            query->children.push_back(query->database);
+        if (query->table)
+            query->children.push_back(query->table);
 
         return true;
     }
@@ -585,11 +590,16 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe
     query->if_not_exists = if_not_exists;
     query->temporary = is_temporary;
 
-    query->database = table_id.database_name;
-    query->table = table_id.table_name;
-    query->uuid = table_id.uuid;
+    query->database = table_id->getDatabase();
+    query->table = table_id->getTable();
+    query->uuid = table_id->uuid;
     query->cluster = cluster_str;
 
+    if (query->database)
+        query->children.push_back(query->database);
+    if (query->table)
+        query->children.push_back(query->table);
+
     query->set(query->columns_list, columns_list);
     query->set(query->storage, storage);
 
@@ -620,7 +630,7 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     ParserKeyword s_create("CREATE");
     ParserKeyword s_attach("ATTACH");
     ParserKeyword s_if_not_exists("IF NOT EXISTS");
-    ParserCompoundIdentifier table_name_p(true);
+    ParserCompoundIdentifier table_name_p(true, true);
     ParserKeyword s_as("AS");
     ParserKeyword s_view("VIEW");
     ParserKeyword s_live("LIVE");
@@ -735,12 +745,17 @@ bool ParserCreateLiveViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     query->if_not_exists = if_not_exists;
     query->is_live_view = true;
 
-    auto table_id = table->as<ASTTableIdentifier>()->getTableId();
-    query->database = table_id.database_name;
-    query->table = table_id.table_name;
-    query->uuid = table_id.uuid;
+    auto * table_id = table->as<ASTTableIdentifier>();
+    query->database = table_id->getDatabase();
+    query->table = table_id->getTable();
+    query->uuid = table_id->uuid;
     query->cluster = cluster_str;
 
+    if (query->database)
+        query->children.push_back(query->database);
+    if (query->table)
+        query->children.push_back(query->table);
+
     if (to_table)
         query->to_table_id = to_table->as<ASTTableIdentifier>()->getTableId();
 
@@ -766,7 +781,7 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     ParserKeyword s_database("DATABASE");
     ParserKeyword s_if_not_exists("IF NOT EXISTS");
     ParserStorage storage_p;
-    ParserIdentifier name_p;
+    ParserIdentifier name_p(true);
 
     ASTPtr database;
     ASTPtr storage;
@@ -817,9 +832,12 @@ bool ParserCreateDatabaseQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & e
     query->attach = attach;
     query->if_not_exists = if_not_exists;
 
-    tryGetIdentifierNameInto(database, query->database);
     query->uuid = uuid;
     query->cluster = cluster_str;
+    query->database = database;
+
+    if (database)
+        query->children.push_back(database);
 
     query->set(query->storage, storage);
     if (comment)
@@ -833,7 +851,7 @@ bool ParserCreateViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
     ParserKeyword s_create("CREATE");
     ParserKeyword s_attach("ATTACH");
     ParserKeyword s_if_not_exists("IF NOT EXISTS");
-    ParserCompoundIdentifier table_name_p(true);
+    ParserCompoundIdentifier table_name_p(true, true);
     ParserKeyword s_as("AS");
     ParserKeyword s_view("VIEW");
     ParserKeyword s_materialized("MATERIALIZED");
@@ -954,12 +972,17 @@ bool ParserCreateViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expec
     query->is_populate = is_populate;
     query->replace_view = replace_view;
 
-    auto table_id = table->as<ASTTableIdentifier>()->getTableId();
-    query->database = table_id.database_name;
-    query->table = table_id.table_name;
-    query->uuid = table_id.uuid;
+    auto * table_id = table->as<ASTTableIdentifier>();
+    query->database = table_id->getDatabase();
+    query->table = table_id->getTable();
+    query->uuid = table_id->uuid;
     query->cluster = cluster_str;
 
+    if (query->database)
+        query->children.push_back(query->database);
+    if (query->table)
+        query->children.push_back(query->table);
+
     if (to_table)
         query->to_table_id = to_table->as<ASTTableIdentifier>()->getTableId();
     if (to_inner_uuid)
@@ -987,7 +1010,7 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E
     ParserKeyword s_dictionary("DICTIONARY");
     ParserKeyword s_if_not_exists("IF NOT EXISTS");
     ParserKeyword s_on("ON");
-    ParserCompoundIdentifier dict_name_p(true);
+    ParserCompoundIdentifier dict_name_p(true, true);
     ParserToken s_left_paren(TokenType::OpeningRoundBracket);
     ParserToken s_right_paren(TokenType::ClosingRoundBracket);
     ParserToken s_dot(TokenType::Dot);
@@ -1059,10 +1082,15 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E
     query->create_or_replace = or_replace;
     query->replace_table = replace;
 
-    auto dict_id = name->as<ASTTableIdentifier>()->getTableId();
-    query->database = dict_id.database_name;
-    query->table = dict_id.table_name;
-    query->uuid = dict_id.uuid;
+    auto * dict_id = name->as<ASTTableIdentifier>();
+    query->database = dict_id->getDatabase();
+    query->table = dict_id->getTable();
+    query->uuid = dict_id->uuid;
+
+    if (query->database)
+        query->children.push_back(query->database);
+    if (query->table)
+        query->children.push_back(query->table);
 
     query->if_not_exists = if_not_exists;
     query->set(query->dictionary_attributes_list, attributes);
diff --git a/src/Parsers/ParserDropQuery.cpp b/src/Parsers/ParserDropQuery.cpp
index 5400f33fbd93..211c7699723c 100644
--- a/src/Parsers/ParserDropQuery.cpp
+++ b/src/Parsers/ParserDropQuery.cpp
@@ -20,7 +20,7 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     ParserKeyword s_database("DATABASE");
     ParserToken s_dot(TokenType::Dot);
     ParserKeyword s_if_exists("IF EXISTS");
-    ParserIdentifier name_p;
+    ParserIdentifier name_p(true);
     ParserKeyword s_permanently("PERMANENTLY");
     ParserKeyword s_no_delay("NO DELAY");
     ParserKeyword s_sync("SYNC");
@@ -96,9 +96,14 @@ bool parseDropQuery(IParser::Pos & pos, ASTPtr & node, Expected & expected, cons
     query->is_view = is_view;
     query->no_delay = no_delay;
     query->permanently = permanently;
+    query->database = database;
+    query->table = table;
 
-    tryGetIdentifierNameInto(database, query->database);
-    tryGetIdentifierNameInto(table, query->table);
+    if (database)
+        query->children.push_back(database);
+
+    if (table)
+        query->children.push_back(table);
 
     query->cluster = cluster_str;
 
diff --git a/src/Parsers/ParserInsertQuery.cpp b/src/Parsers/ParserInsertQuery.cpp
index 1bc552af384e..8925de4cf559 100644
--- a/src/Parsers/ParserInsertQuery.cpp
+++ b/src/Parsers/ParserInsertQuery.cpp
@@ -41,7 +41,7 @@ bool ParserInsertQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     ParserKeyword s_with("WITH");
     ParserToken s_lparen(TokenType::OpeningRoundBracket);
     ParserToken s_rparen(TokenType::ClosingRoundBracket);
-    ParserIdentifier name_p;
+    ParserIdentifier name_p(true);
     ParserList columns_p(std::make_unique<ParserInsertElement>(), std::make_unique<ParserToken>(TokenType::Comma), false);
     ParserFunction table_function_p{false};
     ParserStringLiteral infile_name_p;
@@ -244,8 +244,13 @@ bool ParserInsertQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     }
     else
     {
-        tryGetIdentifierNameInto(database, query->table_id.database_name);
-        tryGetIdentifierNameInto(table, query->table_id.table_name);
+        query->database = database;
+        query->table = table;
+
+        if (database)
+            query->children.push_back(database);
+        if (table)
+            query->children.push_back(table);
     }
 
     query->columns = columns;
diff --git a/src/Parsers/ParserOptimizeQuery.cpp b/src/Parsers/ParserOptimizeQuery.cpp
index 441cec1465e9..b1bfd43936b1 100644
--- a/src/Parsers/ParserOptimizeQuery.cpp
+++ b/src/Parsers/ParserOptimizeQuery.cpp
@@ -31,7 +31,7 @@ bool ParserOptimizeQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte
     ParserKeyword s_deduplicate("DEDUPLICATE");
     ParserKeyword s_by("BY");
     ParserToken s_dot(TokenType::Dot);
-    ParserIdentifier name_p;
+    ParserIdentifier name_p(true);
     ParserPartition partition_p;
 
     ASTPtr database;
@@ -80,15 +80,20 @@ bool ParserOptimizeQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte
     auto query = std::make_shared<ASTOptimizeQuery>();
     node = query;
 
-    tryGetIdentifierNameInto(database, query->database);
-    tryGetIdentifierNameInto(table, query->table);
-
     query->cluster = cluster_str;
     if ((query->partition = partition))
         query->children.push_back(partition);
     query->final = final;
     query->deduplicate = deduplicate;
     query->deduplicate_by_columns = deduplicate_by_columns;
+    query->database = database;
+    query->table = table;
+
+    if (database)
+        query->children.push_back(database);
+
+    if (table)
+        query->children.push_back(table);
 
     return true;
 }
diff --git a/src/Parsers/ParserSystemQuery.cpp b/src/Parsers/ParserSystemQuery.cpp
index b861cbd2a5a0..5a61929bdb30 100644
--- a/src/Parsers/ParserSystemQuery.cpp
+++ b/src/Parsers/ParserSystemQuery.cpp
@@ -39,14 +39,13 @@ static bool parseQueryWithOnClusterAndMaybeTable(std::shared_ptr<ASTSystemQuery>
         ASTPtr ast;
         if (ParserStringLiteral{}.parse(pos, ast, expected))
         {
-            res->database = {};
-            res->table = ast->as<ASTLiteral &>().value.safeGet<String>();
+            res->setTable(ast->as<ASTLiteral &>().value.safeGet<String>());
             parsed_table = true;
         }
     }
 
     if (!parsed_table)
-        parsed_table = parseDatabaseAndTableName(pos, expected, res->database, res->table);
+        parsed_table = parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);
 
     if (!parsed_table && require_table)
             return false;
@@ -56,6 +55,12 @@ static bool parseQueryWithOnClusterAndMaybeTable(std::shared_ptr<ASTSystemQuery>
             return false;
 
     res->cluster = cluster;
+
+    if (res->database)
+        res->children.push_back(res->database);
+    if (res->table)
+        res->children.push_back(res->table);
+
     return true;
 }
 
@@ -163,14 +168,12 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &
                 if (ParserKeyword{"DATABASE"}.ignore(pos, expected))
                 {
                     ParserIdentifier database_parser;
-                    ASTPtr database;
-                    if (!database_parser.parse(pos, database, expected))
+                    if (!database_parser.parse(pos, res->database, expected))
                         return false;
-                    tryGetIdentifierNameInto(database, res->database);
                 }
                 else if (ParserKeyword{"TABLE"}.ignore(pos, expected))
                 {
-                    parseDatabaseAndTableName(pos, expected, res->database, res->table);
+                    parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);
                 }
                 else if (ParserKeyword{"ZKPATH"}.ignore(pos, expected))
                 {
@@ -193,7 +196,7 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &
 
         case Type::RESTART_REPLICA:
         case Type::SYNC_REPLICA:
-            if (!parseDatabaseAndTableName(pos, expected, res->database, res->table))
+            if (!parseDatabaseAndTableAsAST(pos, expected, res->database, res->table))
                 return false;
             break;
 
@@ -251,7 +254,7 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &
             res->storage_policy = storage_policy_str;
             res->volume = volume_str;
             if (res->volume.empty() && res->storage_policy.empty())
-                parseDatabaseAndTableName(pos, expected, res->database, res->table);
+                parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);
             break;
         }
 
@@ -265,7 +268,7 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &
         case Type::START_REPLICATED_SENDS:
         case Type::STOP_REPLICATION_QUEUES:
         case Type::START_REPLICATION_QUEUES:
-            parseDatabaseAndTableName(pos, expected, res->database, res->table);
+            parseDatabaseAndTableAsAST(pos, expected, res->database, res->table);
             break;
 
         case Type::SUSPEND:
@@ -287,6 +290,11 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &
             break;
     }
 
+    if (res->database)
+        res->children.push_back(res->database);
+    if (res->table)
+        res->children.push_back(res->table);
+
     node = std::move(res);
     return true;
 }
diff --git a/src/Parsers/ParserTablePropertiesQuery.cpp b/src/Parsers/ParserTablePropertiesQuery.cpp
index 30be37bc4a1f..bf3ff399f61b 100644
--- a/src/Parsers/ParserTablePropertiesQuery.cpp
+++ b/src/Parsers/ParserTablePropertiesQuery.cpp
@@ -24,7 +24,7 @@ bool ParserTablePropertiesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &
     ParserKeyword s_view("VIEW");
     ParserKeyword s_dictionary("DICTIONARY");
     ParserToken s_dot(TokenType::Dot);
-    ParserIdentifier name_p;
+    ParserIdentifier name_p(true);
 
     ASTPtr database;
     ASTPtr table;
@@ -110,8 +110,14 @@ bool ParserTablePropertiesQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &
         }
     }
 
-    tryGetIdentifierNameInto(database, query->database);
-    tryGetIdentifierNameInto(table, query->table);
+    query->database = database;
+    query->table = table;
+
+    if (database)
+        query->children.push_back(database);
+
+    if (table)
+        query->children.push_back(table);
 
     node = query;
 
diff --git a/src/Parsers/ParserWatchQuery.cpp b/src/Parsers/ParserWatchQuery.cpp
index 5171f4f25364..40d2c47bd4f3 100644
--- a/src/Parsers/ParserWatchQuery.cpp
+++ b/src/Parsers/ParserWatchQuery.cpp
@@ -24,7 +24,7 @@ bool ParserWatchQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
     ParserKeyword s_watch("WATCH");
     ParserToken s_dot(TokenType::Dot);
-    ParserIdentifier name_p;
+    ParserIdentifier name_p(true);
     ParserKeyword s_events("EVENTS");
     ParserKeyword s_limit("LIMIT");
 
@@ -62,11 +62,14 @@ bool ParserWatchQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
             return false;
     }
 
+    query->database = database;
+    query->table = table;
+
     if (database)
-        query->database = getIdentifierName(database);
+        query->children.push_back(database);
 
     if (table)
-        query->table = getIdentifierName(table);
+        query->children.push_back(table);
 
     node = query;
 
diff --git a/src/Parsers/TablePropertiesQueriesASTs.h b/src/Parsers/TablePropertiesQueriesASTs.h
index edb040d72d97..b5baddcf268c 100644
--- a/src/Parsers/TablePropertiesQueriesASTs.h
+++ b/src/Parsers/TablePropertiesQueriesASTs.h
@@ -89,7 +89,7 @@ class ASTExistsDatabaseQuery : public ASTQueryWithTableAndOutputImpl<ASTExistsDa
     void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override
     {
         settings.ostr << (settings.hilite ? hilite_keyword : "") << ASTExistsDatabaseQueryIDAndQueryNames::Query
-                    << " " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(database);
+                    << " " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(getDatabase());
     }
 };
 
@@ -99,7 +99,7 @@ class ASTShowCreateDatabaseQuery : public ASTQueryWithTableAndOutputImpl<ASTShow
     void formatQueryImpl(const FormatSettings & settings, FormatState &, FormatStateStacked) const override
     {
         settings.ostr << (settings.hilite ? hilite_keyword : "") << ASTShowCreateDatabaseQueryIDAndQueryNames::Query
-                      << " " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(database);
+                      << " " << (settings.hilite ? hilite_none : "") << backQuoteIfNeed(getDatabase());
     }
 };
 
diff --git a/src/Parsers/parseDatabaseAndTableName.cpp b/src/Parsers/parseDatabaseAndTableName.cpp
index c071f1b6eb43..48f47dbb68cb 100644
--- a/src/Parsers/parseDatabaseAndTableName.cpp
+++ b/src/Parsers/parseDatabaseAndTableName.cpp
@@ -41,6 +41,24 @@ bool parseDatabaseAndTableName(IParser::Pos & pos, Expected & expected, String &
     return true;
 }
 
+bool parseDatabaseAndTableAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database, ASTPtr & table)
+{
+    ParserToken s_dot(TokenType::Dot);
+    ParserIdentifier table_parser(true);
+
+    if (!table_parser.parse(pos, table, expected))
+        return false;
+
+    if (s_dot.ignore(pos))
+    {
+        database = table;
+        if (!table_parser.parse(pos, table, expected))
+            return false;
+    }
+
+    return true;
+}
+
 
 bool parseDatabase(IParser::Pos & pos, Expected & expected, String & database_str)
 {
@@ -57,6 +75,12 @@ bool parseDatabase(IParser::Pos & pos, Expected & expected, String & database_st
     return true;
 }
 
+bool parseDatabaseAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database)
+{
+    ParserIdentifier identifier_parser(/* allow_query_parameter */true);
+    return identifier_parser.parse(pos, database, expected);
+}
+
 
 bool parseDatabaseAndTableNameOrAsterisks(IParser::Pos & pos, Expected & expected, String & database, bool & any_database, String & table, bool & any_table)
 {
diff --git a/src/Parsers/parseDatabaseAndTableName.h b/src/Parsers/parseDatabaseAndTableName.h
index dc435ca047eb..6ec354d68b44 100644
--- a/src/Parsers/parseDatabaseAndTableName.h
+++ b/src/Parsers/parseDatabaseAndTableName.h
@@ -7,9 +7,13 @@ namespace DB
 /// Parses [db.]name
 bool parseDatabaseAndTableName(IParser::Pos & pos, Expected & expected, String & database_str, String & table_str);
 
+bool parseDatabaseAndTableAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database, ASTPtr & table);
+
 /// Parses [db.]name or [db.]* or [*.]*
 bool parseDatabaseAndTableNameOrAsterisks(IParser::Pos & pos, Expected & expected, String & database, bool & any_database, String & table, bool & any_table);
 
 bool parseDatabase(IParser::Pos & pos, Expected & expected, String & database_str);
 
+bool parseDatabaseAsAST(IParser::Pos & pos, Expected & expected, ASTPtr & database);
+
 }
diff --git a/src/Server/GRPCServer.cpp b/src/Server/GRPCServer.cpp
index 676d9a61926e..bac88e350e2d 100644
--- a/src/Server/GRPCServer.cpp
+++ b/src/Server/GRPCServer.cpp
@@ -958,7 +958,18 @@ namespace
         {
             if (insert_query)
             {
-                auto table_id = query_context->resolveStorageID(insert_query->table_id, Context::ResolveOrdinary);
+                auto table_id = StorageID::createEmpty();
+
+                if (insert_query->table_id)
+                {
+                    table_id = query_context->resolveStorageID(insert_query->table_id, Context::ResolveOrdinary);
+                }
+                else
+                {
+                    StorageID local_table_id(insert_query->getDatabase(), insert_query->getTable());
+                    table_id = query_context->resolveStorageID(local_table_id, Context::ResolveOrdinary);
+                }
+
                 if (query_context->getSettingsRef().input_format_defaults_for_omitted_fields && table_id)
                 {
                     StoragePtr storage = DatabaseCatalog::instance().getTable(table_id, query_context);
diff --git a/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp b/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp
index 69369cbc1a3c..12af472247d0 100644
--- a/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp
+++ b/src/Storages/LiveView/TemporaryLiveViewCleaner.cpp
@@ -24,8 +24,8 @@ namespace
         {
             /// We create and execute `drop` query for this table
             auto drop_query = std::make_shared<ASTDropQuery>();
-            drop_query->database = storage_id.database_name;
-            drop_query->table = storage_id.table_name;
+            drop_query->setDatabase(storage_id.database_name);
+            drop_query->setTable(storage_id.table_name);
             drop_query->kind = ASTDropQuery::Kind::Drop;
             ASTPtr ast_drop_query = drop_query;
             InterpreterDropQuery drop_interpreter(ast_drop_query, context);
diff --git a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
index f771b2239efb..84afe7400912 100644
--- a/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
+++ b/src/Storages/PostgreSQL/StorageMaterializedPostgreSQL.cpp
@@ -369,8 +369,8 @@ ASTPtr StorageMaterializedPostgreSQL::getCreateNestedTableQuery(PostgreSQLTableS
     auto create_table_query = std::make_shared<ASTCreateQuery>();
 
     auto table_id = getStorageID();
-    create_table_query->table = getNestedTableName();
-    create_table_query->database = table_id.database_name;
+    create_table_query->setTable(getNestedTableName());
+    create_table_query->setDatabase(table_id.database_name);
     if (is_materialized_postgresql_database)
         create_table_query->uuid = table_id.uuid;
 
diff --git a/src/Storages/StorageFactory.cpp b/src/Storages/StorageFactory.cpp
index ba2ac3f72a3b..1aa6ae98e7a6 100644
--- a/src/Storages/StorageFactory.cpp
+++ b/src/Storages/StorageFactory.cpp
@@ -201,7 +201,7 @@ StoragePtr StorageFactory::get(
         .storage_def = storage_def,
         .query = query,
         .relative_data_path = relative_data_path,
-        .table_id = StorageID(query.database, query.table, query.uuid),
+        .table_id = StorageID(query.getDatabase(), query.getTable(), query.uuid),
         .local_context = local_context,
         .context = context,
         .columns = columns,
diff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp
index e7de3010c331..210e65484653 100644
--- a/src/Storages/StorageMaterializedView.cpp
+++ b/src/Storages/StorageMaterializedView.cpp
@@ -105,8 +105,8 @@ StorageMaterializedView::StorageMaterializedView(
         /// We will create a query to create an internal table.
         auto create_context = Context::createCopy(local_context);
         auto manual_create_query = std::make_shared<ASTCreateQuery>();
-        manual_create_query->database = getStorageID().database_name;
-        manual_create_query->table = generateInnerTableName(getStorageID());
+        manual_create_query->setDatabase(getStorageID().database_name);
+        manual_create_query->setTable(generateInnerTableName(getStorageID()));
         manual_create_query->uuid = query.to_inner_uuid;
 
         auto new_columns_list = std::make_shared<ASTColumns>();
@@ -119,7 +119,7 @@ StorageMaterializedView::StorageMaterializedView(
         create_interpreter.setInternal(true);
         create_interpreter.execute();
 
-        target_table_id = DatabaseCatalog::instance().getTable({manual_create_query->database, manual_create_query->table}, getContext())->getStorageID();
+        target_table_id = DatabaseCatalog::instance().getTable({manual_create_query->getDatabase(), manual_create_query->getTable()}, getContext())->getStorageID();
     }
 
     if (!select.select_table_id.empty())
diff --git a/src/Storages/System/attachInformationSchemaTables.cpp b/src/Storages/System/attachInformationSchemaTables.cpp
index cfe5de1dc41a..803e9d55dac7 100644
--- a/src/Storages/System/attachInformationSchemaTables.cpp
+++ b/src/Storages/System/attachInformationSchemaTables.cpp
@@ -31,14 +31,14 @@ static void createInformationSchemaView(ContextMutablePtr context, IDatabase & d
                                 DBMS_DEFAULT_MAX_QUERY_SIZE, DBMS_DEFAULT_MAX_PARSER_DEPTH);
 
         auto & ast_create = ast->as<ASTCreateQuery &>();
-        assert(view_name == ast_create.table);
+        assert(view_name == ast_create.getTable());
         if (is_uppercase)
-            ast_create.table = Poco::toUpper(view_name);
+            ast_create.setTable(Poco::toUpper(view_name));
 
         StoragePtr view = createTableFromAST(ast_create, database.getDatabaseName(),
                                              database.getTableDataPath(ast_create), context, true).second;
 
-        database.createTable(context, ast_create.table, view, ast);
+        database.createTable(context, ast_create.getTable(), view, ast);
     }
     catch (...)
     {
