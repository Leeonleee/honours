{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 2277,
  "instance_id": "ClickHouse__ClickHouse-2277",
  "issue_numbers": [
    "2277"
  ],
  "base_commit": "12905f5c6f621e7e1051e818f04bb4d56cbf06bb",
  "patch": "diff --git a/cmake/find_llvm.cmake b/cmake/find_llvm.cmake\nindex 029355ea1a12..57700df0c0e4 100644\n--- a/cmake/find_llvm.cmake\n+++ b/cmake/find_llvm.cmake\n@@ -2,7 +2,6 @@ option (ENABLE_EMBEDDED_COMPILER \"Set to TRUE to enable support for 'compile' op\n option (USE_INTERNAL_LLVM_LIBRARY \"Use bundled or system LLVM library. Default: system library for quicker developer builds.\" 0)\n \n if (ENABLE_EMBEDDED_COMPILER)\n-\n     if (USE_INTERNAL_LLVM_LIBRARY AND NOT EXISTS \"${ClickHouse_SOURCE_DIR}/contrib/llvm/llvm/CMakeLists.txt\")\n         message (WARNING \"submodule contrib/llvm is missing. to fix try run: \\n git submodule update --init --recursive\")\n         set (USE_INTERNAL_LLVM_LIBRARY 0)\ndiff --git a/contrib/llvm b/contrib/llvm\nindex 6b3975cf38d5..5618c710d9d5 160000\n--- a/contrib/llvm\n+++ b/contrib/llvm\n@@ -1,1 +1,1 @@\n-Subproject commit 6b3975cf38d5c9436e1311b7e54ad93ef1a9aa9c\n+Subproject commit 5618c710d9d5cc17d01bac3200340563ecd816ae\ndiff --git a/dbms/CMakeLists.txt b/dbms/CMakeLists.txt\nindex 906897fd0f4b..e290fad9315f 100644\n--- a/dbms/CMakeLists.txt\n+++ b/dbms/CMakeLists.txt\n@@ -99,6 +99,12 @@ else ()\n     install (TARGETS dbms LIBRARY DESTINATION ${CMAKE_INSTALL_LIBDIR} COMPONENT clickhouse)\n endif ()\n \n+if (USE_EMBEDDED_COMPILER)\n+    llvm_map_components_to_libnames(REQUIRED_LLVM_LIBRARIES all)\n+    target_link_libraries (dbms ${REQUIRED_LLVM_LIBRARIES})\n+    target_include_directories (dbms BEFORE PUBLIC ${LLVM_INCLUDE_DIRS})\n+endif ()\n+\n \n if (CMAKE_BUILD_TYPE_UC STREQUAL \"RELEASE\" OR CMAKE_BUILD_TYPE_UC STREQUAL \"RELWITHDEBINFO\" OR CMAKE_BUILD_TYPE_UC STREQUAL \"MINSIZEREL\")\n     # Won't generate debug info for files with heavy template instantiation to achieve faster linking and lower size.\ndiff --git a/dbms/src/Columns/ColumnConst.h b/dbms/src/Columns/ColumnConst.h\nindex 05c3e8e70079..d0cdaf970181 100644\n--- a/dbms/src/Columns/ColumnConst.h\n+++ b/dbms/src/Columns/ColumnConst.h\n@@ -193,6 +193,7 @@ class ColumnConst final : public COWPtrHelper<IColumn, ColumnConst>\n     bool isFixedAndContiguous() const override { return data->isFixedAndContiguous(); }\n     bool valuesHaveFixedSize() const override { return data->valuesHaveFixedSize(); }\n     size_t sizeOfValueIfFixed() const override { return data->sizeOfValueIfFixed(); }\n+    StringRef getRawData() const override { return data->getRawData(); }\n \n     /// Not part of the common interface.\n \ndiff --git a/dbms/src/Columns/ColumnFixedString.h b/dbms/src/Columns/ColumnFixedString.h\nindex cd465a1814d2..80b6ccd5456c 100644\n--- a/dbms/src/Columns/ColumnFixedString.h\n+++ b/dbms/src/Columns/ColumnFixedString.h\n@@ -129,7 +129,7 @@ class ColumnFixedString final : public COWPtrHelper<IColumn, ColumnFixedString>\n \n     bool isFixedAndContiguous() const override { return true; }\n     size_t sizeOfValueIfFixed() const override { return n; }\n-\n+    StringRef getRawData() const override { return StringRef(chars.data(), chars.size()); }\n \n     /// Specialized part of interface, not from IColumn.\n \ndiff --git a/dbms/src/Columns/ColumnVector.h b/dbms/src/Columns/ColumnVector.h\nindex 5cec1229c0e1..da4bf0dabab1 100644\n--- a/dbms/src/Columns/ColumnVector.h\n+++ b/dbms/src/Columns/ColumnVector.h\n@@ -268,7 +268,7 @@ class ColumnVector final : public COWPtrHelper<IColumn, ColumnVector<T>>\n \n     bool isFixedAndContiguous() const override { return true; }\n     size_t sizeOfValueIfFixed() const override { return sizeof(T); }\n-\n+    StringRef getRawData() const override { return StringRef(reinterpret_cast<const char*>(data.data()), data.size()); }\n \n     /** More efficient methods of manipulation - to manipulate with data directly. */\n     Container & getData()\ndiff --git a/dbms/src/Columns/IColumn.h b/dbms/src/Columns/IColumn.h\nindex c25098247326..3221b3f10443 100644\n--- a/dbms/src/Columns/IColumn.h\n+++ b/dbms/src/Columns/IColumn.h\n@@ -308,6 +308,9 @@ class IColumn : public COWPtr<IColumn>\n     /// Values in column are represented as continuous memory segment of fixed size. Implies valuesHaveFixedSize.\n     virtual bool isFixedAndContiguous() const { return false; }\n \n+    /// If isFixedAndContiguous, returns the underlying data array, otherwise throws an exception.\n+    virtual StringRef getRawData() const { throw Exception(\"Column \" + getName() + \" is not a contiguous block of memory\", ErrorCodes::NOT_IMPLEMENTED); }\n+\n     /// If valuesHaveFixedSize, returns size of value, otherwise throw an exception.\n     virtual size_t sizeOfValueIfFixed() const { throw Exception(\"Values of column \" + getName() + \" are not fixed size.\", ErrorCodes::CANNOT_GET_SIZE_OF_FIELD); }\n \ndiff --git a/dbms/src/Common/ProfileEvents.cpp b/dbms/src/Common/ProfileEvents.cpp\nindex 418d5ef715d6..d07c8d66213c 100644\n--- a/dbms/src/Common/ProfileEvents.cpp\n+++ b/dbms/src/Common/ProfileEvents.cpp\n@@ -79,6 +79,8 @@\n     M(CompileAttempt) \\\n     M(CompileSuccess) \\\n     \\\n+    M(CompileFunction) \\\n+    \\\n     M(ExternalSortWritePart) \\\n     M(ExternalSortMerge) \\\n     M(ExternalAggregationWritePart) \\\ndiff --git a/dbms/src/Common/config.h.in b/dbms/src/Common/config.h.in\nindex 2531d9ced70d..f4d155de2c8e 100644\n--- a/dbms/src/Common/config.h.in\n+++ b/dbms/src/Common/config.h.in\n@@ -9,6 +9,7 @@\n #cmakedefine01 USE_RDKAFKA\n #cmakedefine01 USE_CAPNP\n #cmakedefine01 USE_EMBEDDED_COMPILER\n+#cmakedefine01 LLVM_HAS_RTTI\n #cmakedefine01 Poco_SQLODBC_FOUND\n #cmakedefine01 Poco_DataODBC_FOUND\n #cmakedefine01 Poco_MongoDB_FOUND\ndiff --git a/dbms/src/DataTypes/Native.h b/dbms/src/DataTypes/Native.h\nnew file mode 100644\nindex 000000000000..e6167b03a739\n--- /dev/null\n+++ b/dbms/src/DataTypes/Native.h\n@@ -0,0 +1,127 @@\n+#pragma once\n+\n+#include <Common/config.h>\n+\n+#if USE_EMBEDDED_COMPILER\n+\n+#include <Common/typeid_cast.h>\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeFixedString.h>\n+#include <DataTypes/DataTypeInterval.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeUUID.h>\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n+\n+#include <llvm/IR/IRBuilder.h>\n+\n+#pragma GCC diagnostic pop\n+\n+\n+namespace DB\n+{\n+\n+template <typename... Ts>\n+static inline bool typeIsEither(const IDataType & type)\n+{\n+    return (typeid_cast<const Ts *>(&type) || ...);\n+}\n+\n+static inline bool typeIsSigned(const IDataType & type)\n+{\n+    return typeIsEither<\n+        DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64,\n+        DataTypeFloat32, DataTypeFloat64,\n+        DataTypeDate, DataTypeDateTime, DataTypeInterval\n+    >(type);\n+}\n+\n+static inline llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const IDataType & type)\n+{\n+    if (auto * nullable = typeid_cast<const DataTypeNullable *>(&type))\n+    {\n+        auto * wrapped = toNativeType(builder, *nullable->getNestedType());\n+        return wrapped ? llvm::StructType::get(wrapped, /* is null = */ builder.getInt1Ty()) : nullptr;\n+    }\n+    /// LLVM doesn't have unsigned types, it has unsigned instructions.\n+    if (typeIsEither<DataTypeInt8, DataTypeUInt8>(type))\n+        return builder.getInt8Ty();\n+    if (typeIsEither<DataTypeInt16, DataTypeUInt16, DataTypeDate>(type))\n+        return builder.getInt16Ty();\n+    if (typeIsEither<DataTypeInt32, DataTypeUInt32, DataTypeDateTime>(type))\n+        return builder.getInt32Ty();\n+    if (typeIsEither<DataTypeInt64, DataTypeUInt64, DataTypeInterval>(type))\n+        return builder.getInt64Ty();\n+    if (typeIsEither<DataTypeUUID>(type))\n+        return builder.getInt128Ty();\n+    if (typeIsEither<DataTypeFloat32>(type))\n+        return builder.getFloatTy();\n+    if (typeIsEither<DataTypeFloat64>(type))\n+        return builder.getDoubleTy();\n+    if (auto * fixed_string = typeid_cast<const DataTypeFixedString *>(&type))\n+        return llvm::VectorType::get(builder.getInt8Ty(), fixed_string->getN());\n+    return nullptr;\n+}\n+\n+static inline llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const DataTypePtr & type)\n+{\n+    return toNativeType(builder, *type);\n+}\n+\n+static inline llvm::Value * nativeBoolCast(llvm::IRBuilder<> & b, const DataTypePtr & from, llvm::Value * value)\n+{\n+    if (from->isNullable())\n+    {\n+        auto * inner = nativeBoolCast(b, removeNullable(from), b.CreateExtractValue(value, {0}));\n+        return b.CreateAnd(b.CreateNot(b.CreateExtractValue(value, {1})), inner);\n+    }\n+    auto * zero = llvm::Constant::getNullValue(value->getType());\n+    if (value->getType()->isIntegerTy())\n+        return b.CreateICmpNE(value, zero);\n+    if (value->getType()->isFloatingPointTy())\n+        return b.CreateFCmpONE(value, zero); /// QNaN is false\n+    throw Exception(\"Cannot cast non-number \" + from->getName() + \" to bool\", ErrorCodes::NOT_IMPLEMENTED);\n+}\n+\n+static inline llvm::Value * nativeCast(llvm::IRBuilder<> & b, const DataTypePtr & from, llvm::Value * value, llvm::Type * to)\n+{\n+    auto * n_from = value->getType();\n+    if (n_from == to)\n+        return value;\n+    if (n_from->isIntegerTy() && to->isFloatingPointTy())\n+        return typeIsSigned(*from) ? b.CreateSIToFP(value, to) : b.CreateUIToFP(value, to);\n+    if (n_from->isFloatingPointTy() && to->isIntegerTy())\n+        return typeIsSigned(*from) ? b.CreateFPToSI(value, to) : b.CreateFPToUI(value, to);\n+    if (n_from->isIntegerTy() && to->isIntegerTy())\n+        return b.CreateIntCast(value, to, typeIsSigned(*from));\n+    if (n_from->isFloatingPointTy() && to->isFloatingPointTy())\n+        return b.CreateFPCast(value, to);\n+    throw Exception(\"Cannot cast \" + from->getName() + \" to requested type\", ErrorCodes::NOT_IMPLEMENTED);\n+}\n+\n+static inline llvm::Value * nativeCast(llvm::IRBuilder<> & b, const DataTypePtr & from, llvm::Value * value, const DataTypePtr & to)\n+{\n+    auto * n_to = toNativeType(b, to);\n+    if (value->getType() == n_to)\n+        return value;\n+    if (from->isNullable() && to->isNullable())\n+    {\n+        auto * inner = nativeCast(b, removeNullable(from), b.CreateExtractValue(value, {0}), to);\n+        return b.CreateInsertValue(inner, b.CreateExtractValue(value, {1}), {1});\n+    }\n+    if (from->isNullable())\n+        return nativeCast(b, removeNullable(from), b.CreateExtractValue(value, {0}), to);\n+    if (to->isNullable())\n+    {\n+        auto * inner = nativeCast(b, from, value, removeNullable(to));\n+        return b.CreateInsertValue(llvm::Constant::getNullValue(n_to), inner, {0});\n+    }\n+    return nativeCast(b, from, value, n_to);\n+}\n+\n+}\n+\n+#endif\ndiff --git a/dbms/src/Functions/CMakeLists.txt b/dbms/src/Functions/CMakeLists.txt\nindex 06de43ea98b6..1a6ab2caca28 100644\n--- a/dbms/src/Functions/CMakeLists.txt\n+++ b/dbms/src/Functions/CMakeLists.txt\n@@ -86,7 +86,12 @@ list(REMOVE_ITEM clickhouse_functions_headers IFunction.h FunctionFactory.h Func\n \n add_library(clickhouse_functions ${clickhouse_functions_sources})\n \n-target_link_libraries(clickhouse_functions PUBLIC dbms PRIVATE libconsistent-hashing ${FARMHASH_LIBRARIES} ${METROHASH_LIBRARIES})\n+if (USE_EMBEDDED_COMPILER)\n+    # It is needed for llvm::sys::Process::FileDescriptorHasColors.\n+    set (CLICKHOUSE_FUNCTIONS_ADDITIONAL_LIBRARIES libtinfo.a)\n+endif ()\n+\n+target_link_libraries(clickhouse_functions PUBLIC dbms PRIVATE libconsistent-hashing ${FARMHASH_LIBRARIES} ${METROHASH_LIBRARIES} ${CLICKHOUSE_FUNCTIONS_ADDITIONAL_LIBRARIES})\n \n target_include_directories (clickhouse_functions BEFORE PUBLIC ${ClickHouse_SOURCE_DIR}/contrib/libfarmhash)\n target_include_directories (clickhouse_functions BEFORE PUBLIC ${ClickHouse_SOURCE_DIR}/contrib/libmetrohash/src)\n@@ -109,3 +114,7 @@ endif ()\n if (ENABLE_TESTS)\n     add_subdirectory (tests)\n endif ()\n+\n+if (USE_EMBEDDED_COMPILER)\n+    target_include_directories (clickhouse_functions BEFORE PUBLIC ${LLVM_INCLUDE_DIRS})\n+endif ()\ndiff --git a/dbms/src/Functions/FunctionHelpers.cpp b/dbms/src/Functions/FunctionHelpers.cpp\nindex 5c2e23248b86..43a0f73cdfc3 100644\n--- a/dbms/src/Functions/FunctionHelpers.cpp\n+++ b/dbms/src/Functions/FunctionHelpers.cpp\n@@ -5,12 +5,16 @@\n #include <Columns/ColumnNullable.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <IO/WriteHelpers.h>\n-#include \"FunctionsArithmetic.h\"\n \n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n const ColumnConst * checkAndGetColumnConstStringOrFixedString(const IColumn * column)\n {\n     if (!column->isColumnConst())\ndiff --git a/dbms/src/Functions/FunctionsArithmetic.h b/dbms/src/Functions/FunctionsArithmetic.h\nindex 326b39ceb09f..267439ae430d 100644\n--- a/dbms/src/Functions/FunctionsArithmetic.h\n+++ b/dbms/src/Functions/FunctionsArithmetic.h\n@@ -4,6 +4,7 @@\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeInterval.h>\n+#include <DataTypes/Native.h>\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnConst.h>\n #include <Functions/IFunction.h>\n@@ -19,6 +20,13 @@\n #include <common/intExp.h>\n #include <boost/integer/common_factor.hpp>\n \n+#if USE_EMBEDDED_COMPILER\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n+#include <llvm/IR/IRBuilder.h>\n+#pragma GCC diagnostic pop\n+#endif\n+\n \n namespace DB\n {\n@@ -106,6 +114,15 @@ struct PlusImpl\n         /// Next everywhere, static_cast - so that there is no wrong result in expressions of the form Int64 c = UInt32(a) * Int32(-1).\n         return static_cast<Result>(a) + b;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        return left->getType()->isIntegerTy() ? b.CreateAdd(left, right) : b.CreateFAdd(left, right);\n+    }\n+#endif\n };\n \n \n@@ -119,6 +136,15 @@ struct MultiplyImpl\n     {\n         return static_cast<Result>(a) * b;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        return left->getType()->isIntegerTy() ? b.CreateMul(left, right) : b.CreateFMul(left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -131,6 +157,15 @@ struct MinusImpl\n     {\n         return static_cast<Result>(a) - b;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        return left->getType()->isIntegerTy() ? b.CreateSub(left, right) : b.CreateFSub(left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -143,6 +178,17 @@ struct DivideFloatingImpl\n     {\n         return static_cast<Result>(a) / b;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (left->getType()->isIntegerTy())\n+            throw Exception(\"DivideFloatingImpl expected a floating-point type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateFDiv(left, right);\n+    }\n+#endif\n };\n \n \n@@ -189,6 +235,10 @@ struct DivideIntegralImpl\n         throwIfDivisionLeadsToFPE(a, b);\n         return a / b;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// don't know how to throw from LLVM IR\n+#endif\n };\n \n template <typename A, typename B>\n@@ -201,6 +251,10 @@ struct DivideIntegralOrZeroImpl\n     {\n         return unlikely(divisionLeadsToFPE(a, b)) ? 0 : a / b;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// TODO implement the checks\n+#endif\n };\n \n template <typename A, typename B>\n@@ -212,9 +266,12 @@ struct ModuloImpl\n     static inline Result apply(A a, B b)\n     {\n         throwIfDivisionLeadsToFPE(typename NumberTraits::ToInteger<A>::Type(a), typename NumberTraits::ToInteger<B>::Type(b));\n-        return typename NumberTraits::ToInteger<A>::Type(a)\n-            % typename NumberTraits::ToInteger<B>::Type(b);\n+        return typename NumberTraits::ToInteger<A>::Type(a) % typename NumberTraits::ToInteger<B>::Type(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// don't know how to throw from LLVM IR\n+#endif\n };\n \n template <typename A, typename B>\n@@ -225,9 +282,19 @@ struct BitAndImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return static_cast<Result>(a)\n-            & static_cast<Result>(b);\n+        return static_cast<Result>(a) & static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitAndImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateAnd(left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -238,9 +305,19 @@ struct BitOrImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return static_cast<Result>(a)\n-            | static_cast<Result>(b);\n+        return static_cast<Result>(a) | static_cast<Result>(b);\n+    }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitOrImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateOr(left, right);\n     }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -251,9 +328,19 @@ struct BitXorImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return static_cast<Result>(a)\n-            ^ static_cast<Result>(b);\n+        return static_cast<Result>(a) ^ static_cast<Result>(b);\n+    }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitXorImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateXor(left, right);\n     }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -264,9 +351,19 @@ struct BitShiftLeftImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return static_cast<Result>(a)\n-            << static_cast<Result>(b);\n+        return static_cast<Result>(a) << static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitShiftLeftImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateShl(left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -277,9 +374,19 @@ struct BitShiftRightImpl\n     template <typename Result = ResultType>\n     static inline Result apply(A a, B b)\n     {\n-        return static_cast<Result>(a)\n-            >> static_cast<Result>(b);\n+        return static_cast<Result>(a) >> static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool is_signed)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitShiftRightImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return is_signed ? b.CreateAShr(left, right) : b.CreateLShr(left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -293,6 +400,19 @@ struct BitRotateLeftImpl\n         return (static_cast<Result>(a) << static_cast<Result>(b))\n             | (static_cast<Result>(a) >> ((sizeof(Result) * 8) - static_cast<Result>(b)));\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitRotateLeftImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        auto * size = llvm::ConstantInt::get(left->getType(), left->getType()->getPrimitiveSizeInBits());\n+        /// XXX how is this supposed to behave in signed mode?\n+        return b.CreateOr(b.CreateShl(left, right), b.CreateLShr(left, b.CreateSub(size, right)));\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -306,14 +426,19 @@ struct BitRotateRightImpl\n         return (static_cast<Result>(a) >> static_cast<Result>(b))\n             | (static_cast<Result>(a) << ((sizeof(Result) * 8) - static_cast<Result>(b)));\n     }\n-};\n \n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n \n-template <typename T>\n-std::enable_if_t<std::is_integral_v<T>, T> toInteger(T x) { return x; }\n-\n-template <typename T>\n-std::enable_if_t<std::is_floating_point_v<T>, Int64> toInteger(T x) { return Int64(x); }\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            throw Exception(\"BitRotateRightImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        auto * size = llvm::ConstantInt::get(left->getType(), left->getType()->getPrimitiveSizeInBits());\n+        return b.CreateOr(b.CreateLShr(left, right), b.CreateShl(left, b.CreateSub(size, right)));\n+    }\n+#endif\n+};\n \n template <typename A, typename B>\n struct BitTestImpl\n@@ -321,9 +446,15 @@ struct BitTestImpl\n     using ResultType = UInt8;\n \n     template <typename Result = ResultType>\n-    static inline Result apply(A a, B b) { return (toInteger(a) >> toInteger(b)) & 1; };\n-};\n+    static inline Result apply(A a, B b)\n+    {\n+        return (typename NumberTraits::ToInteger<A>::Type(a) >> typename NumberTraits::ToInteger<B>::Type(b)) & 1;\n+    };\n \n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// TODO\n+#endif\n+};\n \n template <typename A, typename B>\n struct LeastBaseImpl\n@@ -336,6 +467,18 @@ struct LeastBaseImpl\n         /** gcc 4.9.2 successfully vectorizes a loop from this function. */\n         return static_cast<Result>(a) < static_cast<Result>(b) ? static_cast<Result>(a) : static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool is_signed)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            /// XXX minnum is basically fmin(), it may or may not match whatever apply() does\n+            return b.CreateMinNum(left, right);\n+        return b.CreateSelect(is_signed ? b.CreateICmpSLT(left, right) : b.CreateICmpULT(left, right), left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -349,6 +492,10 @@ struct LeastSpecialImpl\n         static_assert(std::is_same_v<Result, ResultType>, \"ResultType != Result\");\n         return accurate::lessOp(a, b) ? static_cast<Result>(a) : static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// ???\n+#endif\n };\n \n template <typename A, typename B>\n@@ -365,6 +512,19 @@ struct GreatestBaseImpl\n     {\n         return static_cast<Result>(a) > static_cast<Result>(b) ? static_cast<Result>(a) : static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * left, llvm::Value * right, bool is_signed)\n+    {\n+        if (!left->getType()->isIntegerTy())\n+            /// XXX maxnum is basically fmax(), it may or may not match whatever apply() does\n+            /// XXX CreateMaxNum is broken on LLVM 5.0 and 6.0 (generates minnum instead; fixed in 7)\n+            return b.CreateBinaryIntrinsic(llvm::Intrinsic::maxnum, left, right);\n+        return b.CreateSelect(is_signed ? b.CreateICmpSGT(left, right) : b.CreateICmpUGT(left, right), left, right);\n+    }\n+#endif\n };\n \n template <typename A, typename B>\n@@ -378,6 +538,10 @@ struct GreatestSpecialImpl\n         static_assert(std::is_same_v<Result, ResultType>, \"ResultType != Result\");\n         return accurate::greaterOp(a, b) ? static_cast<Result>(a) : static_cast<Result>(b);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// ???\n+#endif\n };\n \n template <typename A, typename B>\n@@ -393,6 +557,15 @@ struct NegateImpl\n     {\n         return -static_cast<ResultType>(a);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * arg, bool)\n+    {\n+        return arg->getType()->isIntegerTy() ? b.CreateNeg(arg) : b.CreateFNeg(arg);\n+    }\n+#endif\n };\n \n template <typename A>\n@@ -404,6 +577,17 @@ struct BitNotImpl\n     {\n         return ~static_cast<ResultType>(a);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * arg, bool)\n+    {\n+        if (!arg->getType()->isIntegerTy())\n+            throw Exception(\"BitNotImpl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateNot(arg);\n+    }\n+#endif\n };\n \n template <typename A>\n@@ -420,6 +604,10 @@ struct AbsImpl\n         else if constexpr (std::is_floating_point_v<A>)\n             return static_cast<ResultType>(std::abs(a));\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// special type handling, some other time\n+#endif\n };\n \n template <typename A, typename B>\n@@ -436,6 +624,10 @@ struct GCDImpl\n             typename NumberTraits::ToInteger<Result>::Type(a),\n             typename NumberTraits::ToInteger<Result>::Type(b));\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// exceptions (and a non-trivial algorithm)\n+#endif\n };\n \n template <typename A, typename B>\n@@ -452,6 +644,10 @@ struct LCMImpl\n             typename NumberTraits::ToInteger<Result>::Type(a),\n             typename NumberTraits::ToInteger<Result>::Type(b));\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// exceptions (and a non-trivial algorithm)\n+#endif\n };\n \n template <typename A>\n@@ -463,6 +659,17 @@ struct IntExp2Impl\n     {\n         return intExp2(a);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = true;\n+\n+    static inline llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * arg, bool)\n+    {\n+        if (!arg->getType()->isIntegerTy())\n+            throw Exception(\"IntExp2Impl expected an integral type\", ErrorCodes::LOGICAL_ERROR);\n+        return b.CreateShl(llvm::ConstantInt::get(arg->getType(), 1), arg);\n+    }\n+#endif\n };\n \n template <typename A>\n@@ -474,6 +681,10 @@ struct IntExp10Impl\n     {\n         return intExp10(a);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false; /// library function\n+#endif\n };\n \n /// Used to indicate undefined operation\n@@ -745,6 +956,43 @@ class FunctionBinaryArithmetic : public IFunction\n         if (!valid)\n             throw Exception(getName() + \"'s arguments do not match the expected data types\", ErrorCodes::LOGICAL_ERROR);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    bool isCompilableImpl(const DataTypes & arguments) const override\n+    {\n+        return castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)\n+        {\n+            using LeftDataType = std::decay_t<decltype(left)>;\n+            using RightDataType = std::decay_t<decltype(right)>;\n+            using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;\n+            using OpSpec = Op<typename LeftDataType::FieldType, typename RightDataType::FieldType>;\n+            return !std::is_same_v<ResultDataType, InvalidType> && OpSpec::compilable;\n+        });\n+    }\n+\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n+    {\n+        llvm::Value * result = nullptr;\n+        castBothTypes(types[0].get(), types[1].get(), [&](const auto & left, const auto & right)\n+        {\n+            using LeftDataType = std::decay_t<decltype(left)>;\n+            using RightDataType = std::decay_t<decltype(right)>;\n+            using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;\n+            using OpSpec = Op<typename LeftDataType::FieldType, typename RightDataType::FieldType>;\n+            if constexpr (!std::is_same_v<ResultDataType, InvalidType> && OpSpec::compilable)\n+            {\n+                auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+                auto type = std::make_shared<ResultDataType>();\n+                auto * lval = nativeCast(b, types[0], values[0](), type);\n+                auto * rval = nativeCast(b, types[1], values[1](), type);\n+                result = OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>);\n+                return true;\n+            }\n+            return false;\n+        });\n+        return result;\n+    }\n+#endif\n };\n \n \n@@ -821,6 +1069,35 @@ class FunctionUnaryArithmetic : public IFunction\n             throw Exception(getName() + \"'s argument does not match the expected data type\", ErrorCodes::LOGICAL_ERROR);\n     }\n \n+#if USE_EMBEDDED_COMPILER\n+    bool isCompilableImpl(const DataTypes & arguments) const override\n+    {\n+        return castType(arguments[0].get(), [&](const auto & type)\n+        {\n+            return Op<typename std::decay_t<decltype(type)>::FieldType>::compilable;\n+        });\n+    }\n+\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n+    {\n+        llvm::Value * result = nullptr;\n+        castType(types[0].get(), [&](const auto & type)\n+        {\n+            using T0 = typename std::decay_t<decltype(type)>::FieldType;\n+            using T1 = typename Op<T0>::ResultType;\n+            if constexpr (Op<T0>::compilable)\n+            {\n+                auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+                auto * v = nativeCast(b, types[0], values[0](), std::make_shared<DataTypeNumber<T1>>());\n+                result = Op<T0>::compile(b, v, std::is_signed_v<T1>);\n+                return true;\n+            }\n+            return false;\n+        });\n+        return result;\n+    }\n+#endif\n+\n     bool hasInformationAboutMonotonicity() const override\n     {\n         return FunctionUnaryArithmeticMonotonicity<Name>::has();\ndiff --git a/dbms/src/Functions/FunctionsComparison.h b/dbms/src/Functions/FunctionsComparison.h\nindex 0cf198338211..229cbfe20e2c 100644\n--- a/dbms/src/Functions/FunctionsComparison.h\n+++ b/dbms/src/Functions/FunctionsComparison.h\n@@ -53,12 +53,26 @@ template <typename A, typename B> struct EqualsOp\n     using SymmetricOp = EqualsOp<B, A>;\n \n     static UInt8 apply(A a, B b) { return accurate::equalsOp(a, b); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * x, llvm::Value * y, bool /*is_signed*/)\n+    {\n+        return x->getType()->isIntegerTy() ? b.CreateICmpEQ(x, y) : b.CreateFCmpOEQ(x, y); /// qNaNs always compare false\n+    }\n+#endif\n };\n \n template <typename A, typename B> struct NotEqualsOp\n {\n     using SymmetricOp = NotEqualsOp<B, A>;\n     static UInt8 apply(A a, B b) { return accurate::notEqualsOp(a, b); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * x, llvm::Value * y, bool /*is_signed*/)\n+    {\n+        return x->getType()->isIntegerTy() ? b.CreateICmpNE(x, y) : b.CreateFCmpONE(x, y);\n+    }\n+#endif\n };\n \n template <typename A, typename B> struct GreaterOp;\n@@ -67,12 +81,26 @@ template <typename A, typename B> struct LessOp\n {\n     using SymmetricOp = GreaterOp<B, A>;\n     static UInt8 apply(A a, B b) { return accurate::lessOp(a, b); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * x, llvm::Value * y, bool is_signed)\n+    {\n+        return x->getType()->isIntegerTy() ? (is_signed ? b.CreateICmpSLT(x, y) : b.CreateICmpULT(x, y)) : b.CreateFCmpOLT(x, y);\n+    }\n+#endif\n };\n \n template <typename A, typename B> struct GreaterOp\n {\n     using SymmetricOp = LessOp<B, A>;\n     static UInt8 apply(A a, B b) { return accurate::greaterOp(a, b); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * x, llvm::Value * y, bool is_signed)\n+    {\n+        return x->getType()->isIntegerTy() ? (is_signed ? b.CreateICmpSGT(x, y) : b.CreateICmpUGT(x, y)) : b.CreateFCmpOGT(x, y);\n+    }\n+#endif\n };\n \n template <typename A, typename B> struct GreaterOrEqualsOp;\n@@ -81,12 +109,26 @@ template <typename A, typename B> struct LessOrEqualsOp\n {\n     using SymmetricOp = GreaterOrEqualsOp<B, A>;\n     static UInt8 apply(A a, B b) { return accurate::lessOrEqualsOp(a, b); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * x, llvm::Value * y, bool is_signed)\n+    {\n+        return x->getType()->isIntegerTy() ? (is_signed ? b.CreateICmpSLE(x, y) : b.CreateICmpULE(x, y)) : b.CreateFCmpOLE(x, y);\n+    }\n+#endif\n };\n \n template <typename A, typename B> struct GreaterOrEqualsOp\n {\n     using SymmetricOp = LessOrEqualsOp<B, A>;\n     static UInt8 apply(A a, B b) { return accurate::greaterOrEqualsOp(a, b); }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static llvm::Value * compile(llvm::IRBuilder<> & b, llvm::Value * x, llvm::Value * y, bool is_signed)\n+    {\n+        return x->getType()->isIntegerTy() ? (is_signed ? b.CreateICmpSGE(x, y) : b.CreateICmpUGE(x, y)) : b.CreateFCmpOGE(x, y);\n+    }\n+#endif\n };\n \n \n@@ -1136,6 +1178,41 @@ class FunctionComparison : public IFunction\n                 col_with_type_and_name_left.type, col_with_type_and_name_right.type,\n                 left_is_num, input_rows_count);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    bool isCompilableImpl(const DataTypes & types) const override\n+    {\n+        auto isBigInteger = &typeIsEither<DataTypeInt64, DataTypeUInt64, DataTypeUUID>;\n+        auto isFloatingPoint = &typeIsEither<DataTypeFloat32, DataTypeFloat64>;\n+        if ((isBigInteger(*types[0]) && isFloatingPoint(*types[1])) || (isBigInteger(*types[1]) && isFloatingPoint(*types[0])))\n+            return false; /// TODO: implement (double, int_N where N > double's mantissa width)\n+        return types[0]->isValueRepresentedByNumber() && types[1]->isValueRepresentedByNumber();\n+    }\n+\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n+    {\n+        auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+        auto * x = values[0]();\n+        auto * y = values[1]();\n+        if (!types[0]->equals(*types[1]))\n+        {\n+            llvm::Type * common;\n+            if (x->getType()->isIntegerTy() && y->getType()->isIntegerTy())\n+                common = b.getIntNTy(std::max(\n+                    /// if one integer has a sign bit, make sure the other does as well. llvm generates optimal code\n+                    /// (e.g. uses overflow flag on x86) for (word size + 1)-bit integer operations.\n+                    x->getType()->getIntegerBitWidth() + (!typeIsSigned(*types[0]) && typeIsSigned(*types[1])),\n+                    y->getType()->getIntegerBitWidth() + (!typeIsSigned(*types[1]) && typeIsSigned(*types[0]))));\n+            else\n+                /// (double, float) or (double, int_N where N <= double's mantissa width) -> double\n+                common = b.getDoubleTy();\n+            x = nativeCast(b, types[0], x, common);\n+            y = nativeCast(b, types[1], y, common);\n+        }\n+        auto * result = Op<int, int>::compile(b, x, y, typeIsSigned(*types[0]) || typeIsSigned(*types[1]));\n+        return b.CreateSelect(result, b.getInt8(1), b.getInt8(0));\n+    }\n+#endif\n };\n \n \ndiff --git a/dbms/src/Functions/FunctionsConditional.h b/dbms/src/Functions/FunctionsConditional.h\nindex 4dae3fcc4245..355e271127ef 100644\n--- a/dbms/src/Functions/FunctionsConditional.h\n+++ b/dbms/src/Functions/FunctionsConditional.h\n@@ -6,6 +6,7 @@\n #include <DataTypes/DataTypeFixedString.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/Native.h>\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnConst.h>\n@@ -113,7 +114,65 @@ struct NumIfImpl<A, B, NumberTraits::Error>\n };\n \n \n-class FunctionIf : public IFunction\n+template <bool null_is_false>\n+class FunctionIfBase : public IFunction\n+{\n+#if USE_EMBEDDED_COMPILER\n+public:\n+    bool isCompilableImpl(const DataTypes & types) const override\n+    {\n+        for (const auto & type : types)\n+            if (!removeNullable(type)->isValueRepresentedByNumber())\n+                return false;\n+        return true;\n+    }\n+\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n+    {\n+        auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+        auto type = getReturnTypeImpl(types);\n+        llvm::Value * null = nullptr;\n+        if (!null_is_false && type->isNullable())\n+            null = b.CreateInsertValue(llvm::Constant::getNullValue(toNativeType(b, type)), b.getTrue(), {1});\n+        auto * head = b.GetInsertBlock();\n+        auto * join = llvm::BasicBlock::Create(head->getContext(), \"\", head->getParent());\n+        std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>> returns;\n+        for (size_t i = 0; i + 1 < types.size(); i += 2)\n+        {\n+            auto * then = llvm::BasicBlock::Create(head->getContext(), \"\", head->getParent());\n+            auto * next = llvm::BasicBlock::Create(head->getContext(), \"\", head->getParent());\n+            auto * cond = values[i]();\n+            if (!null_is_false && types[i]->isNullable())\n+            {\n+                auto * nonnull = llvm::BasicBlock::Create(head->getContext(), \"\", head->getParent());\n+                returns.emplace_back(b.GetInsertBlock(), null);\n+                b.CreateCondBr(b.CreateExtractValue(cond, {1}), join, nonnull);\n+                b.SetInsertPoint(nonnull);\n+                b.CreateCondBr(nativeBoolCast(b, removeNullable(types[i]), b.CreateExtractValue(cond, {0})), then, next);\n+            }\n+            else\n+            {\n+                b.CreateCondBr(nativeBoolCast(b, types[i], cond), then, next);\n+            }\n+            b.SetInsertPoint(then);\n+            auto * value = nativeCast(b, types[i + 1], values[i + 1](), type);\n+            returns.emplace_back(b.GetInsertBlock(), value);\n+            b.CreateBr(join);\n+            b.SetInsertPoint(next);\n+        }\n+        auto * value = nativeCast(b, types.back(), values.back()(), type);\n+        returns.emplace_back(b.GetInsertBlock(), value);\n+        b.CreateBr(join);\n+        b.SetInsertPoint(join);\n+        auto * phi = b.CreatePHI(toNativeType(b, type), returns.size());\n+        for (const auto & r : returns)\n+            phi->addIncoming(r.second, r.first);\n+        return phi;\n+    }\n+#endif\n+};\n+\n+class FunctionIf : public FunctionIfBase</*null_is_false=*/false>\n {\n public:\n     static constexpr auto name = \"if\";\n@@ -916,8 +975,8 @@ class FunctionIf : public IFunction\n ///    - arrays of such types.\n ///\n /// Additionally the arguments, conditions or branches, support nullable types\n-/// and the NULL value.\n-class FunctionMultiIf final : public IFunction\n+/// and the NULL value, with a NULL condition treated as false.\n+class FunctionMultiIf final : public FunctionIfBase</*null_is_false=*/true>\n {\n public:\n     static constexpr auto name = \"multiIf\";\ndiff --git a/dbms/src/Functions/FunctionsLogical.h b/dbms/src/Functions/FunctionsLogical.h\nindex cc11e598f961..d5e77c4a4506 100644\n--- a/dbms/src/Functions/FunctionsLogical.h\n+++ b/dbms/src/Functions/FunctionsLogical.h\n@@ -12,6 +12,13 @@\n #include <Functions/FunctionHelpers.h>\n #include <type_traits>\n \n+#if USE_EMBEDDED_COMPILER\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n+#include <llvm/IR/IRBuilder.h>\n+#pragma GCC diagnostic pop\n+#endif\n+\n \n namespace DB\n {\n@@ -31,65 +38,71 @@ namespace ErrorCodes\n   * For example, 1 OR NULL returns 1, not NULL.\n   */\n \n-\n struct AndImpl\n {\n-    static inline bool isSaturable()\n+    static inline constexpr bool isSaturable()\n     {\n         return true;\n     }\n \n-    static inline bool isSaturatedValue(bool a)\n+    static inline constexpr bool isSaturatedValue(bool a)\n     {\n         return !a;\n     }\n \n-    static inline bool apply(bool a, bool b)\n+    static inline constexpr bool apply(bool a, bool b)\n     {\n         return a && b;\n     }\n \n-    static inline bool specialImplementationForNulls() { return false; }\n+    static inline constexpr bool specialImplementationForNulls() { return false; }\n };\n \n struct OrImpl\n {\n-    static inline bool isSaturable()\n+    static inline constexpr bool isSaturable()\n     {\n         return true;\n     }\n \n-    static inline bool isSaturatedValue(bool a)\n+    static inline constexpr bool isSaturatedValue(bool a)\n     {\n         return a;\n     }\n \n-    static inline bool apply(bool a, bool b)\n+    static inline constexpr bool apply(bool a, bool b)\n     {\n         return a || b;\n     }\n \n-    static inline bool specialImplementationForNulls() { return true; }\n+    static inline constexpr bool specialImplementationForNulls() { return true; }\n };\n \n struct XorImpl\n {\n-    static inline bool isSaturable()\n+    static inline constexpr bool isSaturable()\n     {\n         return false;\n     }\n \n-    static inline bool isSaturatedValue(bool)\n+    static inline constexpr bool isSaturatedValue(bool)\n     {\n         return false;\n     }\n \n-    static inline bool apply(bool a, bool b)\n+    static inline constexpr bool apply(bool a, bool b)\n     {\n         return a != b;\n     }\n \n-    static inline bool specialImplementationForNulls() { return false; }\n+    static inline constexpr bool specialImplementationForNulls() { return false; }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static inline llvm::Value * apply(llvm::IRBuilder<> & builder, llvm::Value * a, llvm::Value * b)\n+    {\n+        return builder.CreateXor(a, b);\n+    }\n+#endif\n };\n \n template <typename A>\n@@ -101,6 +114,13 @@ struct NotImpl\n     {\n         return !a;\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static inline llvm::Value * apply(llvm::IRBuilder<> & builder, llvm::Value * a)\n+    {\n+        return builder.CreateNot(a);\n+    }\n+#endif\n };\n \n \n@@ -364,6 +384,44 @@ class FunctionAnyArityLogical : public IFunction\n \n         block.getByPosition(result).column = std::move(col_res);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    bool isCompilableImpl(const DataTypes &) const override { return true; }\n+\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n+    {\n+        auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+        if constexpr (!Impl::isSaturable())\n+        {\n+            auto * result = nativeBoolCast(b, types[0], values[0]());\n+            for (size_t i = 1; i < types.size(); i++)\n+                result = Impl::apply(b, result, nativeBoolCast(b, types[i], values[i]()));\n+            return b.CreateSelect(result, b.getInt8(1), b.getInt8(0));\n+        }\n+        constexpr bool breakOnTrue = Impl::isSaturatedValue(true);\n+        auto * next = b.GetInsertBlock();\n+        auto * stop = llvm::BasicBlock::Create(next->getContext(), \"\", next->getParent());\n+        b.SetInsertPoint(stop);\n+        auto * phi = b.CreatePHI(b.getInt8Ty(), values.size());\n+        for (size_t i = 0; i < types.size(); i++)\n+        {\n+            b.SetInsertPoint(next);\n+            auto * value = values[i]();\n+            auto * truth = nativeBoolCast(b, types[i], value);\n+            if (!types[i]->equals(DataTypeUInt8{}))\n+                value = b.CreateSelect(truth, b.getInt8(1), b.getInt8(0));\n+            phi->addIncoming(value, b.GetInsertBlock());\n+            if (i + 1 < types.size())\n+            {\n+                next = llvm::BasicBlock::Create(next->getContext(), \"\", next->getParent());\n+                b.CreateCondBr(truth, breakOnTrue ? stop : next, breakOnTrue ? next : stop);\n+            }\n+        }\n+        b.CreateBr(stop);\n+        b.SetInsertPoint(stop);\n+        return phi;\n+    }\n+#endif\n };\n \n \n@@ -430,6 +488,16 @@ class FunctionUnaryLogical : public IFunction\n                     + \" of argument of function \" + getName(),\n                 ErrorCodes::ILLEGAL_COLUMN);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    bool isCompilableImpl(const DataTypes &) const override { return true; }\n+\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, ValuePlaceholders values) const override\n+    {\n+        auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+        return b.CreateSelect(Impl<UInt8>::apply(b, nativeBoolCast(b, types[0], values[0]())), b.getInt8(1), b.getInt8(0));\n+    }\n+#endif\n };\n \n \ndiff --git a/dbms/src/Functions/FunctionsRound.h b/dbms/src/Functions/FunctionsRound.h\nindex ac07c0e07407..89fad9fbf1cc 100644\n--- a/dbms/src/Functions/FunctionsRound.h\n+++ b/dbms/src/Functions/FunctionsRound.h\n@@ -93,6 +93,10 @@ struct RoundToExp2Impl\n     {\n         return roundDownToPowerOfTwo<T>(x);\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false;\n+#endif\n };\n \n \n@@ -120,6 +124,10 @@ struct RoundDurationImpl\n             : (x < 36000 ? 18000\n             : 36000))))))))))))));\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false;\n+#endif\n };\n \n template <typename A>\n@@ -137,6 +145,10 @@ struct RoundAgeImpl\n             : (x < 55 ? 45\n             : 55)))));\n     }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false;\n+#endif\n };\n \n \ndiff --git a/dbms/src/Functions/IFunction.cpp b/dbms/src/Functions/IFunction.cpp\nindex 4f89811d1e76..f9727c3b3ce4 100644\n--- a/dbms/src/Functions/IFunction.cpp\n+++ b/dbms/src/Functions/IFunction.cpp\n@@ -1,15 +1,25 @@\n-#include <Functions/IFunction.h>\n-#include <Functions/FunctionHelpers.h>\n+#include <Common/config.h>\n+#include <Common/typeid_cast.h>\n+#include <Columns/ColumnConst.h>\n #include <Columns/ColumnNullable.h>\n-#include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypeNothing.h>\n-#include <Columns/ColumnConst.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/Native.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n #include <Interpreters/ExpressionActions.h>\n-#include <Common/typeid_cast.h>\n #include <ext/range.h>\n #include <ext/collection_cast.h>\n #include <cstdlib>\n #include <memory>\n+#include <optional>\n+\n+#if USE_EMBEDDED_COMPILER\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n+#include <llvm/IR/IRBuilder.h>\n+#pragma GCC diagnostic pop\n+#endif\n \n \n namespace DB\n@@ -21,6 +31,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n }\n \n+\n namespace\n {\n \n@@ -259,4 +270,71 @@ DataTypePtr FunctionBuilderImpl::getReturnType(const ColumnsWithTypeAndName & ar\n \n     return getReturnTypeImpl(arguments);\n }\n+\n+#if USE_EMBEDDED_COMPILER\n+\n+static std::optional<DataTypes> removeNullables(const DataTypes & types)\n+{\n+    for (const auto & type : types)\n+    {\n+        if (!typeid_cast<const DataTypeNullable *>(type.get()))\n+            continue;\n+        DataTypes filtered;\n+        for (const auto & type : types)\n+            filtered.emplace_back(removeNullable(type));\n+        return filtered;\n+    }\n+    return {};\n+}\n+\n+bool IFunction::isCompilable(const DataTypes & arguments) const\n+{\n+    if (useDefaultImplementationForNulls())\n+        if (auto denulled = removeNullables(arguments))\n+            return isCompilableImpl(*denulled);\n+    return isCompilableImpl(arguments);\n+}\n+\n+llvm::Value * IFunction::compile(llvm::IRBuilderBase & builder, const DataTypes & arguments, ValuePlaceholders values) const\n+{\n+    if (useDefaultImplementationForNulls())\n+    {\n+        if (auto denulled = removeNullables(arguments))\n+        {\n+            /// FIXME: when only one column is nullable, this can actually be slower than the non-jitted version\n+            ///        because this involves copying the null map while `wrapInNullable` reuses it.\n+            auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n+            auto * fail = llvm::BasicBlock::Create(b.GetInsertBlock()->getContext(), \"\", b.GetInsertBlock()->getParent());\n+            auto * join = llvm::BasicBlock::Create(b.GetInsertBlock()->getContext(), \"\", b.GetInsertBlock()->getParent());\n+            auto * zero = llvm::Constant::getNullValue(toNativeType(b, makeNullable(getReturnTypeImpl(*denulled))));\n+            for (size_t i = 0; i < arguments.size(); i++)\n+            {\n+                if (!arguments[i]->isNullable())\n+                    continue;\n+                /// Would be nice to evaluate all this lazily, but that'd change semantics: if only unevaluated\n+                /// arguments happen to contain NULLs, the return value would not be NULL, though it should be.\n+                auto * value = values[i]();\n+                auto * ok = llvm::BasicBlock::Create(b.GetInsertBlock()->getContext(), \"\", b.GetInsertBlock()->getParent());\n+                b.CreateCondBr(b.CreateExtractValue(value, {1}), fail, ok);\n+                b.SetInsertPoint(ok);\n+                values[i] = [value = b.CreateExtractValue(value, {0})]() { return value; };\n+            }\n+            auto * result = b.CreateInsertValue(zero, compileImpl(builder, *denulled, std::move(values)), {0});\n+            auto * result_block = b.GetInsertBlock();\n+            b.CreateBr(join);\n+            b.SetInsertPoint(fail);\n+            auto * null = b.CreateInsertValue(zero, b.getTrue(), {1});\n+            b.CreateBr(join);\n+            b.SetInsertPoint(join);\n+            auto * phi = b.CreatePHI(result->getType(), 2);\n+            phi->addIncoming(result, result_block);\n+            phi->addIncoming(null, fail);\n+            return phi;\n+        }\n+    }\n+    return compileImpl(builder, arguments, std::move(values));\n+}\n+\n+#endif\n+\n }\ndiff --git a/dbms/src/Functions/IFunction.h b/dbms/src/Functions/IFunction.h\nindex db67e1f4c23f..230c9624954b 100644\n--- a/dbms/src/Functions/IFunction.h\n+++ b/dbms/src/Functions/IFunction.h\n@@ -2,6 +2,7 @@\n \n #include <memory>\n \n+#include <Common/config.h>\n #include <Core/Names.h>\n #include <Core/Field.h>\n #include <Core/Block.h>\n@@ -9,6 +10,14 @@\n #include <DataTypes/IDataType.h>\n \n \n+namespace llvm\n+{\n+    class LLVMContext;\n+    class Value;\n+    class IRBuilderBase;\n+}\n+\n+\n namespace DB\n {\n \n@@ -70,6 +79,8 @@ class PreparedFunctionImpl : public IPreparedFunction\n                                                        size_t input_rows_count);\n };\n \n+using ValuePlaceholders = std::vector<std::function<llvm::Value * ()>>;\n+\n /// Function with known arguments and return type.\n class IFunctionBase\n {\n@@ -92,6 +103,25 @@ class IFunctionBase\n         return prepare(block)->execute(block, arguments, result, input_rows_count);\n     }\n \n+#if USE_EMBEDDED_COMPILER\n+\n+    virtual bool isCompilable() const { return false; }\n+\n+    /** Produce LLVM IR code that operates on scalar values. See `toNativeType` in DataTypes/Native.h\n+      * for supported value types and how they map to LLVM types.\n+      *\n+      * NOTE: the builder is actually guaranteed to be exactly `llvm::IRBuilder<>`, so you may safely\n+      *       downcast it to that type. This method is specified with `IRBuilderBase` because forward-declaring\n+      *       templates with default arguments is impossible and including LLVM in such a generic header\n+      *       as this one is a major pain.\n+      */\n+    virtual llvm::Value * compile(llvm::IRBuilderBase & /*builder*/, ValuePlaceholders /*values*/) const\n+    {\n+        throw Exception(getName() + \" is not JIT-compilable\", ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n+#endif\n+\n     /** Should we evaluate this function while constant folding, if arguments are constants?\n       * Usually this is true. Notable counterexample is function 'sleep'.\n       * If we will call it during query analysis, we will sleep extra amount of time.\n@@ -261,7 +291,6 @@ class IFunction : public std::enable_shared_from_this<IFunction>,\n     using PreparedFunctionImpl::execute;\n     using FunctionBuilderImpl::getReturnTypeImpl;\n     using FunctionBuilderImpl::getLambdaArgumentTypesImpl;\n-\n     using FunctionBuilderImpl::getReturnType;\n \n     PreparedFunctionPtr prepare(const Block & /*sample_block*/) const final\n@@ -269,17 +298,51 @@ class IFunction : public std::enable_shared_from_this<IFunction>,\n         throw Exception(\"prepare is not implemented for IFunction\", ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+#if USE_EMBEDDED_COMPILER\n+\n+    bool isCompilable() const final\n+    {\n+        throw Exception(\"isCompilable without explicit types is not implemented for IFunction\", ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n+    llvm::Value * compile(llvm::IRBuilderBase & /*builder*/, ValuePlaceholders /*values*/) const final\n+    {\n+        throw Exception(\"compile without explicit types is not implemented for IFunction\", ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n+#endif\n+\n     const DataTypes & getArgumentTypes() const final\n     {\n         throw Exception(\"getArgumentTypes is not implemented for IFunction\", ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n-    const DataTypePtr & getReturnType() const override\n+    const DataTypePtr & getReturnType() const final\n     {\n         throw Exception(\"getReturnType is not implemented for IFunction\", ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+#if USE_EMBEDDED_COMPILER\n+\n+    bool isCompilable(const DataTypes & arguments) const;\n+\n+    llvm::Value * compile(llvm::IRBuilderBase &, const DataTypes & arguments, ValuePlaceholders values) const;\n+\n+#endif\n+\n protected:\n+\n+#if USE_EMBEDDED_COMPILER\n+\n+    virtual bool isCompilableImpl(const DataTypes &) const { return false; }\n+\n+    virtual llvm::Value * compileImpl(llvm::IRBuilderBase &, const DataTypes &, ValuePlaceholders) const\n+    {\n+        throw Exception(getName() + \" is not JIT-compilable\", ErrorCodes::NOT_IMPLEMENTED);\n+    }\n+\n+#endif\n+\n     FunctionBasePtr buildImpl(const ColumnsWithTypeAndName & /*arguments*/, const DataTypePtr & /*return_type*/) const final\n     {\n         throw Exception(\"buildImpl is not implemented for IFunction\", ErrorCodes::NOT_IMPLEMENTED);\n@@ -319,6 +382,14 @@ class DefaultFunction final : public IFunctionBase\n     const DataTypes & getArgumentTypes() const override { return arguments; }\n     const DataTypePtr & getReturnType() const override { return return_type; }\n \n+#if USE_EMBEDDED_COMPILER\n+\n+    bool isCompilable() const override { return function->isCompilable(arguments); }\n+\n+    llvm::Value * compile(llvm::IRBuilderBase & builder, ValuePlaceholders values) const override { return function->compile(builder, arguments, std::move(values)); }\n+\n+#endif\n+\n     PreparedFunctionPtr prepare(const Block & /*sample_block*/) const override { return std::make_shared<DefaultExecutable>(function); }\n \n     bool isSuitableForConstantFolding() const override { return function->isSuitableForConstantFolding(); }\ndiff --git a/dbms/src/Interpreters/ExpressionActions.cpp b/dbms/src/Interpreters/ExpressionActions.cpp\nindex f327f5f11540..f472416f6892 100644\n--- a/dbms/src/Interpreters/ExpressionActions.cpp\n+++ b/dbms/src/Interpreters/ExpressionActions.cpp\n@@ -1,5 +1,7 @@\n+#include <Common/config.h>\n #include <Common/ProfileEvents.h>\n #include <Interpreters/ExpressionActions.h>\n+#include <Interpreters/ExpressionJIT.h>\n #include <Interpreters/Join.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnArray.h>\n@@ -752,6 +754,13 @@ void ExpressionActions::finalize(const Names & output_columns)\n         final_columns.insert(name);\n     }\n \n+#if USE_EMBEDDED_COMPILER\n+    /// This has to be done before removing redundant actions and inserting REMOVE_COLUMNs\n+    /// because inlining may change dependency sets.\n+    if (settings.compile_expressions)\n+        compileFunctions(actions, output_columns, sample_block);\n+#endif\n+\n     /// Which columns are needed to perform actions from the current to the last.\n     NameSet needed_columns = final_columns;\n     /// Which columns nobody will touch from the current action to the last.\n@@ -934,7 +943,7 @@ void ExpressionActions::finalize(const Names & output_columns)\n         std::cerr << action.toString() << \"\\n\";\n     std::cerr << \"\\n\";*/\n \n-    optimize();\n+    optimizeArrayJoin();\n     checkLimits(sample_block);\n }\n \n@@ -959,11 +968,6 @@ std::string ExpressionActions::dumpActions() const\n     return ss.str();\n }\n \n-void ExpressionActions::optimize()\n-{\n-    optimizeArrayJoin();\n-}\n-\n void ExpressionActions::optimizeArrayJoin()\n {\n     const size_t NONE = actions.size();\ndiff --git a/dbms/src/Interpreters/ExpressionActions.h b/dbms/src/Interpreters/ExpressionActions.h\nindex 7a021d1a8647..8da5fe2a2792 100644\n--- a/dbms/src/Interpreters/ExpressionActions.h\n+++ b/dbms/src/Interpreters/ExpressionActions.h\n@@ -215,8 +215,6 @@ class ExpressionActions\n \n     void addImpl(ExpressionAction action, Names & new_names);\n \n-    /// Try to improve something without changing the lists of input and output columns.\n-    void optimize();\n     /// Move all arrayJoin as close as possible to the end.\n     void optimizeArrayJoin();\n };\ndiff --git a/dbms/src/Interpreters/ExpressionJIT.cpp b/dbms/src/Interpreters/ExpressionJIT.cpp\nnew file mode 100644\nindex 000000000000..57f716a746f0\n--- /dev/null\n+++ b/dbms/src/Interpreters/ExpressionJIT.cpp\n@@ -0,0 +1,654 @@\n+#include <Interpreters/ExpressionJIT.h>\n+\n+#if USE_EMBEDDED_COMPILER\n+\n+#include <optional>\n+\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnVector.h>\n+#include <Common/typeid_cast.h>\n+#include <Common/ProfileEvents.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/Native.h>\n+#include <Functions/IFunction.h>\n+\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wunused-parameter\"\n+#pragma GCC diagnostic ignored \"-Wnon-virtual-dtor\"\n+\n+#include <llvm/Analysis/TargetTransformInfo.h>\n+#include <llvm/Config/llvm-config.h>\n+#include <llvm/IR/BasicBlock.h>\n+#include <llvm/IR/DataLayout.h>\n+#include <llvm/IR/DerivedTypes.h>\n+#include <llvm/IR/Function.h>\n+#include <llvm/IR/IRBuilder.h>\n+#include <llvm/IR/LLVMContext.h>\n+#include <llvm/IR/Mangler.h>\n+#include <llvm/IR/Module.h>\n+#include <llvm/IR/Type.h>\n+#include <llvm/ExecutionEngine/ExecutionEngine.h>\n+#include <llvm/ExecutionEngine/JITSymbol.h>\n+#include <llvm/ExecutionEngine/SectionMemoryManager.h>\n+#include <llvm/ExecutionEngine/Orc/CompileUtils.h>\n+#include <llvm/ExecutionEngine/Orc/IRCompileLayer.h>\n+#include <llvm/ExecutionEngine/Orc/RTDyldObjectLinkingLayer.h>\n+#include <llvm/Target/TargetMachine.h>\n+#include <llvm/MC/SubtargetFeature.h>\n+#include <llvm/Support/DynamicLibrary.h>\n+#include <llvm/Support/Host.h>\n+#include <llvm/Support/TargetRegistry.h>\n+#include <llvm/Support/TargetSelect.h>\n+#include <llvm/Transforms/IPO/PassManagerBuilder.h>\n+\n+#pragma GCC diagnostic pop\n+\n+\n+namespace ProfileEvents\n+{\n+    extern const Event CompileFunction;\n+}\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int CANNOT_COMPILE_CODE;\n+}\n+\n+namespace\n+{\n+    struct ColumnData\n+    {\n+        const char * data = nullptr;\n+        const char * null = nullptr;\n+        size_t stride;\n+    };\n+\n+    struct ColumnDataPlaceholder\n+    {\n+        llvm::Value * data_init; /// first row\n+        llvm::Value * null_init;\n+        llvm::Value * stride;\n+        llvm::PHINode * data; /// current row\n+        llvm::PHINode * null;\n+    };\n+}\n+\n+static ColumnData getColumnData(const IColumn * column)\n+{\n+    ColumnData result;\n+    const bool is_const = column->isColumnConst();\n+    if (is_const)\n+        column = &reinterpret_cast<const ColumnConst *>(column)->getDataColumn();\n+    if (auto * nullable = typeid_cast<const ColumnNullable *>(column))\n+    {\n+        result.null = nullable->getNullMapColumn().getRawData().data;\n+        column = &nullable->getNestedColumn();\n+    }\n+    result.data = column->getRawData().data;\n+    result.stride = is_const ? 0 : column->sizeOfValueIfFixed();\n+    return result;\n+}\n+\n+static void applyFunction(IFunctionBase & function, Field & value)\n+{\n+    const auto & type = function.getArgumentTypes().at(0);\n+    Block block = {{ type->createColumnConst(1, value), type, \"x\" }, { nullptr, function.getReturnType(), \"y\" }};\n+    function.execute(block, {0}, 1, 1);\n+    block.safeGetByPosition(1).column->get(0, value);\n+}\n+\n+static llvm::TargetMachine * getNativeMachine()\n+{\n+    std::string error;\n+    auto cpu = llvm::sys::getHostCPUName();\n+    auto triple = llvm::sys::getProcessTriple();\n+    auto target = llvm::TargetRegistry::lookupTarget(triple, error);\n+    if (!target)\n+        throw Exception(\"Could not initialize native target: \" + error, ErrorCodes::CANNOT_COMPILE_CODE);\n+    llvm::SubtargetFeatures features;\n+    llvm::StringMap<bool> feature_map;\n+    if (llvm::sys::getHostCPUFeatures(feature_map))\n+        for (auto& f : feature_map)\n+            features.AddFeature(f.first(), f.second);\n+    llvm::TargetOptions options;\n+    return target->createTargetMachine(\n+        triple, cpu, features.getString(), options, llvm::None,\n+#if LLVM_VERSION_MAJOR >= 6\n+        llvm::None, llvm::CodeGenOpt::Default, /*jit=*/true\n+#else\n+        llvm::CodeModel::Default, llvm::CodeGenOpt::Default\n+#endif\n+    );\n+}\n+\n+#if LLVM_VERSION_MAJOR >= 7\n+auto wrapJITSymbolResolver(llvm::JITSymbolResolver & jsr)\n+{\n+    auto flags = [&](llvm::orc::SymbolFlagsMap & flags, const llvm::orc::SymbolNameSet & symbols)\n+    {\n+        llvm::orc::SymbolNameSet missing;\n+        for (const auto & symbol : symbols)\n+        {\n+            auto resolved = jsr.lookupFlags({*symbol});\n+            if (resolved && resolved->size())\n+                flags.emplace(symbol, resolved->begin()->second);\n+            else\n+                missing.emplace(symbol);\n+        }\n+        return missing;\n+    };\n+    auto symbols = [&](std::shared_ptr<llvm::orc::AsynchronousSymbolQuery> query, llvm::orc::SymbolNameSet symbols)\n+    {\n+        llvm::orc::SymbolNameSet missing;\n+        for (const auto & symbol : symbols)\n+        {\n+            auto resolved = jsr.lookup({*symbol});\n+            if (resolved && resolved->size())\n+                query->resolve(symbol, resolved->begin()->second);\n+            else\n+                missing.emplace(symbol);\n+        }\n+        return missing;\n+    };\n+    return llvm::orc::createSymbolResolver(flags, symbols);\n+}\n+#endif\n+\n+struct LLVMContext\n+{\n+    llvm::LLVMContext context;\n+#if LLVM_VERSION_MAJOR >= 7\n+    llvm::orc::ExecutionSession execution_session;\n+    std::unique_ptr<llvm::Module> module;\n+#else\n+    std::shared_ptr<llvm::Module> module;\n+#endif\n+    std::unique_ptr<llvm::TargetMachine> machine;\n+    std::shared_ptr<llvm::SectionMemoryManager> memory_manager;\n+    llvm::orc::RTDyldObjectLinkingLayer object_layer;\n+    llvm::orc::IRCompileLayer<decltype(object_layer), llvm::orc::SimpleCompiler> compile_layer;\n+    llvm::DataLayout layout;\n+    llvm::IRBuilder<> builder;\n+    std::unordered_map<std::string, void *> symbols;\n+\n+    LLVMContext()\n+#if LLVM_VERSION_MAJOR >= 7\n+        : module(std::make_unique<llvm::Module>(\"jit\", context))\n+#else\n+        : module(std::make_shared<llvm::Module>(\"jit\", context))\n+#endif\n+        , machine(getNativeMachine())\n+        , memory_manager(std::make_shared<llvm::SectionMemoryManager>())\n+#if LLVM_VERSION_MAJOR >= 7\n+        , object_layer(execution_session, [this](llvm::orc::VModuleKey)\n+        {\n+            return llvm::orc::RTDyldObjectLinkingLayer::Resources{memory_manager, wrapJITSymbolResolver(*memory_manager)};\n+        })\n+#else\n+        , object_layer([this]() { return memory_manager; })\n+#endif\n+        , compile_layer(object_layer, llvm::orc::SimpleCompiler(*machine))\n+        , layout(machine->createDataLayout())\n+        , builder(context)\n+    {\n+        module->setDataLayout(layout);\n+        module->setTargetTriple(machine->getTargetTriple().getTriple());\n+    }\n+\n+    void finalize()\n+    {\n+        if (!module->size())\n+            return;\n+        llvm::PassManagerBuilder builder;\n+        llvm::legacy::PassManager mpm;\n+        llvm::legacy::FunctionPassManager fpm(module.get());\n+        builder.OptLevel = 3;\n+        builder.SLPVectorize = true;\n+        builder.LoopVectorize = true;\n+        builder.RerollLoops = true;\n+        builder.VerifyInput = true;\n+        builder.VerifyOutput = true;\n+        machine->adjustPassManager(builder);\n+        fpm.add(llvm::createTargetTransformInfoWrapperPass(machine->getTargetIRAnalysis()));\n+        mpm.add(llvm::createTargetTransformInfoWrapperPass(machine->getTargetIRAnalysis()));\n+        builder.populateFunctionPassManager(fpm);\n+        builder.populateModulePassManager(mpm);\n+        fpm.doInitialization();\n+        for (auto & function : *module)\n+            fpm.run(function);\n+        fpm.doFinalization();\n+        mpm.run(*module);\n+\n+        std::vector<std::string> functions;\n+        functions.reserve(module->size());\n+        for (const auto & function : *module)\n+            functions.emplace_back(function.getName());\n+\n+#if LLVM_VERSION_MAJOR >= 7\n+        llvm::orc::VModuleKey module_key = execution_session.allocateVModule();\n+        if (compile_layer.addModule(module_key, std::move(module)))\n+            throw Exception(\"Cannot add module to compile layer\", ErrorCodes::CANNOT_COMPILE_CODE);\n+#else\n+        if (!compile_layer.addModule(module, memory_manager))\n+            throw Exception(\"Cannot add module to compile layer\", ErrorCodes::CANNOT_COMPILE_CODE);\n+#endif\n+\n+        for (const auto & name : functions)\n+        {\n+            std::string mangled_name;\n+            llvm::raw_string_ostream mangled_name_stream(mangled_name);\n+            llvm::Mangler::getNameWithPrefix(mangled_name_stream, name, layout);\n+            mangled_name_stream.flush();\n+            auto symbol = compile_layer.findSymbol(mangled_name, false);\n+            if (!symbol)\n+                continue; /// external function (e.g. an intrinsic that calls into libc)\n+            auto address = symbol.getAddress();\n+            if (!address)\n+                throw Exception(\"Function \" + name + \" failed to link\", ErrorCodes::CANNOT_COMPILE_CODE);\n+            symbols[name] = reinterpret_cast<void *>(*address);\n+        }\n+    }\n+};\n+\n+class LLVMPreparedFunction : public PreparedFunctionImpl\n+{\n+    std::string name;\n+    std::shared_ptr<LLVMContext> context;\n+    void * function;\n+\n+public:\n+    LLVMPreparedFunction(std::string name_, std::shared_ptr<LLVMContext> context)\n+        : name(std::move(name_)), context(context), function(context->symbols.at(name))\n+    {}\n+\n+    String getName() const override { return name; }\n+\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t block_size) override\n+    {\n+        auto col_res = block.getByPosition(result).type->createColumn()->cloneResized(block_size);\n+        if (block_size)\n+        {\n+            std::vector<ColumnData> columns(arguments.size() + 1);\n+            for (size_t i = 0; i < arguments.size(); ++i)\n+            {\n+                auto * column = block.getByPosition(arguments[i]).column.get();\n+                if (!column)\n+                    throw Exception(\"Column \" + block.getByPosition(arguments[i]).name + \" is missing\", ErrorCodes::LOGICAL_ERROR);\n+                columns[i] = getColumnData(column);\n+            }\n+            columns[arguments.size()] = getColumnData(col_res.get());\n+            reinterpret_cast<void (*) (size_t, ColumnData *)>(function)(block_size, columns.data());\n+        }\n+        block.getByPosition(result).column = std::move(col_res);\n+    };\n+};\n+\n+static void compileFunction(std::shared_ptr<LLVMContext> & context, const IFunctionBase & f)\n+{\n+    ProfileEvents::increment(ProfileEvents::CompileFunction);\n+\n+    auto & arg_types = f.getArgumentTypes();\n+    auto & b = context->builder;\n+    auto * size_type = b.getIntNTy(sizeof(size_t) * 8);\n+    auto * data_type = llvm::StructType::get(b.getInt8PtrTy(), b.getInt8PtrTy(), size_type);\n+    auto * func_type = llvm::FunctionType::get(b.getVoidTy(), { size_type, data_type->getPointerTo() }, /*isVarArg=*/false);\n+    auto * func = llvm::Function::Create(func_type, llvm::Function::ExternalLinkage, f.getName(), context->module.get());\n+    auto args = func->args().begin();\n+    llvm::Value * counter_arg = &*args++;\n+    llvm::Value * columns_arg = &*args++;\n+\n+    auto * entry = llvm::BasicBlock::Create(b.getContext(), \"entry\", func);\n+    b.SetInsertPoint(entry);\n+    std::vector<ColumnDataPlaceholder> columns(arg_types.size() + 1);\n+    for (size_t i = 0; i <= arg_types.size(); ++i)\n+    {\n+        auto & type = i == arg_types.size() ? f.getReturnType() : arg_types[i];\n+        auto * data = b.CreateLoad(b.CreateConstInBoundsGEP1_32(data_type, columns_arg, i));\n+        columns[i].data_init = b.CreatePointerCast(b.CreateExtractValue(data, {0}), toNativeType(b, removeNullable(type))->getPointerTo());\n+        columns[i].null_init = type->isNullable() ? b.CreateExtractValue(data, {1}) : nullptr;\n+        columns[i].stride = b.CreateExtractValue(data, {2});\n+    }\n+\n+    /// assume nonzero initial value in `counter_arg`\n+    auto * loop = llvm::BasicBlock::Create(b.getContext(), \"loop\", func);\n+    b.CreateBr(loop);\n+    b.SetInsertPoint(loop);\n+    auto * counter_phi = b.CreatePHI(counter_arg->getType(), 2);\n+    counter_phi->addIncoming(counter_arg, entry);\n+    for (auto & col : columns)\n+    {\n+        col.data = b.CreatePHI(col.data_init->getType(), 2);\n+        col.data->addIncoming(col.data_init, entry);\n+        if (col.null_init)\n+        {\n+            col.null = b.CreatePHI(col.null_init->getType(), 2);\n+            col.null->addIncoming(col.null_init, entry);\n+        }\n+    }\n+    ValuePlaceholders arguments(arg_types.size());\n+    for (size_t i = 0; i < arguments.size(); ++i)\n+    {\n+        arguments[i] = [&b, &col = columns[i], &type = arg_types[i]]() -> llvm::Value *\n+        {\n+            auto * value = b.CreateLoad(col.data);\n+            if (!col.null)\n+                return value;\n+            auto * is_null = b.CreateICmpNE(b.CreateLoad(col.null), b.getInt8(0));\n+            auto * nullable = llvm::Constant::getNullValue(toNativeType(b, type));\n+            return b.CreateInsertValue(b.CreateInsertValue(nullable, value, {0}), is_null, {1});\n+        };\n+    }\n+    auto * result = f.compile(b, std::move(arguments));\n+    if (columns.back().null)\n+    {\n+        b.CreateStore(b.CreateExtractValue(result, {0}), columns.back().data);\n+        b.CreateStore(b.CreateSelect(b.CreateExtractValue(result, {1}), b.getInt8(1), b.getInt8(0)), columns.back().null);\n+    }\n+    else\n+    {\n+        b.CreateStore(result, columns.back().data);\n+    }\n+    auto * cur_block = b.GetInsertBlock();\n+    for (auto & col : columns)\n+    {\n+        /// stride is either 0 or size of native type; output column is never constant; neither is at least one input\n+        auto * is_const = &col == &columns.back() || columns.size() <= 2 ? b.getFalse() : b.CreateICmpEQ(col.stride, llvm::ConstantInt::get(size_type, 0));\n+        col.data->addIncoming(b.CreateSelect(is_const, col.data, b.CreateConstInBoundsGEP1_32(nullptr, col.data, 1)), cur_block);\n+        if (col.null)\n+            col.null->addIncoming(b.CreateSelect(is_const, col.null, b.CreateConstInBoundsGEP1_32(nullptr, col.null, 1)), cur_block);\n+    }\n+    counter_phi->addIncoming(b.CreateSub(counter_phi, llvm::ConstantInt::get(size_type, 1)), cur_block);\n+\n+    auto * end = llvm::BasicBlock::Create(b.getContext(), \"end\", func);\n+    b.CreateCondBr(b.CreateICmpNE(counter_phi, llvm::ConstantInt::get(size_type, 1)), loop, end);\n+    b.SetInsertPoint(end);\n+    b.CreateRetVoid();\n+}\n+\n+static llvm::Constant * getNativeValue(llvm::Type * type, const IColumn & column, size_t i)\n+{\n+    if (!type)\n+        return nullptr;\n+    if (auto * constant = typeid_cast<const ColumnConst *>(&column))\n+        return getNativeValue(type, constant->getDataColumn(), 0);\n+    if (auto * nullable = typeid_cast<const ColumnNullable *>(&column))\n+    {\n+        auto * value = getNativeValue(type->getContainedType(0), nullable->getNestedColumn(), i);\n+        auto * is_null = llvm::ConstantInt::get(type->getContainedType(1), nullable->isNullAt(i));\n+        return value ? llvm::ConstantStruct::get(static_cast<llvm::StructType *>(type), value, is_null) : nullptr;\n+    }\n+    if (type->isFloatTy())\n+        return llvm::ConstantFP::get(type, static_cast<const ColumnVector<Float32> &>(column).getElement(i));\n+    if (type->isDoubleTy())\n+        return llvm::ConstantFP::get(type, static_cast<const ColumnVector<Float64> &>(column).getElement(i));\n+    if (type->isIntegerTy())\n+        return llvm::ConstantInt::get(type, column.getUInt(i));\n+    /// TODO: if (type->isVectorTy())\n+    return nullptr;\n+}\n+\n+/// Same as IFunctionBase::compile, but also for constants and input columns.\n+using CompilableExpression = std::function<llvm::Value * (llvm::IRBuilderBase &, const ValuePlaceholders &)>;\n+\n+static CompilableExpression subexpression(ColumnPtr c, DataTypePtr type)\n+{\n+    return [=](llvm::IRBuilderBase & b, const ValuePlaceholders &) { return getNativeValue(toNativeType(b, type), *c, 0); };\n+}\n+\n+static CompilableExpression subexpression(size_t i)\n+{\n+    return [=](llvm::IRBuilderBase &, const ValuePlaceholders & inputs) { return inputs[i](); };\n+}\n+\n+static CompilableExpression subexpression(const IFunctionBase & f, std::vector<CompilableExpression> args)\n+{\n+    return [&, args = std::move(args)](llvm::IRBuilderBase & builder, const ValuePlaceholders & inputs)\n+    {\n+        ValuePlaceholders input;\n+        for (const auto & arg : args)\n+            input.push_back([&]() { return arg(builder, inputs); });\n+        auto * result = f.compile(builder, input);\n+        if (result->getType() != toNativeType(builder, f.getReturnType()))\n+            throw Exception(\"Function \" + f.getName() + \" generated an llvm::Value of invalid type\", ErrorCodes::LOGICAL_ERROR);\n+        return result;\n+    };\n+}\n+\n+class LLVMFunction : public IFunctionBase\n+{\n+    std::string name;\n+    Names arg_names;\n+    DataTypes arg_types;\n+    std::shared_ptr<LLVMContext> context;\n+    std::vector<FunctionBasePtr> originals;\n+    std::unordered_map<StringRef, CompilableExpression> subexpressions;\n+\n+public:\n+    LLVMFunction(const ExpressionActions::Actions & actions, std::shared_ptr<LLVMContext> context, const Block & sample_block)\n+        : name(actions.back().result_name), context(context)\n+    {\n+        for (const auto & c : sample_block)\n+            /// TODO: implement `getNativeValue` for all types & replace the check with `c.column && toNativeType(...)`\n+            if (c.column && getNativeValue(toNativeType(context->builder, c.type), *c.column, 0))\n+                subexpressions[c.name] = subexpression(c.column, c.type);\n+        for (const auto & action : actions)\n+        {\n+            const auto & names = action.argument_names;\n+            const auto & types = action.function->getArgumentTypes();\n+            std::vector<CompilableExpression> args;\n+            for (size_t i = 0; i < names.size(); ++i)\n+            {\n+                auto inserted = subexpressions.emplace(names[i], subexpression(arg_names.size()));\n+                if (inserted.second)\n+                {\n+                    arg_names.push_back(names[i]);\n+                    arg_types.push_back(types[i]);\n+                }\n+                args.push_back(inserted.first->second);\n+            }\n+            subexpressions[action.result_name] = subexpression(*action.function, std::move(args));\n+            originals.push_back(action.function);\n+        }\n+        compileFunction(context, *this);\n+    }\n+\n+    bool isCompilable() const override { return true; }\n+\n+    llvm::Value * compile(llvm::IRBuilderBase & builder, ValuePlaceholders values) const override { return subexpressions.at(name)(builder, values); }\n+\n+    String getName() const override { return name; }\n+\n+    const Names & getArgumentNames() const { return arg_names; }\n+\n+    const DataTypes & getArgumentTypes() const override { return arg_types; }\n+\n+    const DataTypePtr & getReturnType() const override { return originals.back()->getReturnType(); }\n+\n+    PreparedFunctionPtr prepare(const Block &) const override { return std::make_shared<LLVMPreparedFunction>(name, context); }\n+\n+    bool isDeterministic() override\n+    {\n+        for (const auto & f : originals)\n+            if (!f->isDeterministic())\n+                return false;\n+        return true;\n+    }\n+\n+    bool isDeterministicInScopeOfQuery() override\n+    {\n+        for (const auto & f : originals)\n+            if (!f->isDeterministicInScopeOfQuery())\n+                return false;\n+        return true;\n+    }\n+\n+    bool isSuitableForConstantFolding() const override\n+    {\n+        for (const auto & f : originals)\n+            if (!f->isSuitableForConstantFolding())\n+                return false;\n+        return true;\n+    }\n+\n+    bool isInjective(const Block & sample_block) override\n+    {\n+        for (const auto & f : originals)\n+            if (!f->isInjective(sample_block))\n+                return false;\n+        return true;\n+    }\n+\n+    bool hasInformationAboutMonotonicity() const override\n+    {\n+        for (const auto & f : originals)\n+            if (!f->hasInformationAboutMonotonicity())\n+                return false;\n+        return true;\n+    }\n+\n+    Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n+    {\n+        const IDataType * type_ = &type;\n+        Field left_ = left;\n+        Field right_ = right;\n+        Monotonicity result(true, true, true);\n+        /// monotonicity is only defined for unary functions, so the chain must describe a sequence of nested calls\n+        for (size_t i = 0; i < originals.size(); ++i)\n+        {\n+            Monotonicity m = originals[i]->getMonotonicityForRange(*type_, left_, right_);\n+            if (!m.is_monotonic)\n+                return m;\n+            result.is_positive ^= !m.is_positive;\n+            result.is_always_monotonic &= m.is_always_monotonic;\n+            if (i + 1 < originals.size())\n+            {\n+                if (left_ != Field())\n+                    applyFunction(*originals[i], left_);\n+                if (right_ != Field())\n+                    applyFunction(*originals[i], right_);\n+                if (!m.is_positive)\n+                    std::swap(left_, right_);\n+                type_ = originals[i]->getReturnType().get();\n+            }\n+        }\n+        return result;\n+    }\n+};\n+\n+static bool isCompilable(llvm::IRBuilderBase & builder, const IFunctionBase& function)\n+{\n+    if (!toNativeType(builder, function.getReturnType()))\n+        return false;\n+    for (const auto & type : function.getArgumentTypes())\n+        if (!toNativeType(builder, type))\n+            return false;\n+    return function.isCompilable();\n+}\n+\n+void compileFunctions(ExpressionActions::Actions & actions, const Names & output_columns, const Block & sample_block)\n+{\n+    auto context = std::make_shared<LLVMContext>();\n+    /// an empty optional is a poisoned value prohibiting the column's producer from being removed\n+    /// (which it could be, if it was inlined into every dependent function).\n+    std::unordered_map<std::string, std::unordered_set<std::optional<size_t>>> current_dependents;\n+    for (const auto & name : output_columns)\n+        current_dependents[name].emplace();\n+    /// a snapshot of each compilable function's dependents at the time of its execution.\n+    std::vector<std::unordered_set<std::optional<size_t>>> dependents(actions.size());\n+    for (size_t i = actions.size(); i--;)\n+    {\n+        switch (actions[i].type)\n+        {\n+            case ExpressionAction::REMOVE_COLUMN:\n+                current_dependents.erase(actions[i].source_name);\n+                /// poison every other column used after this point so that inlining chains do not cross it.\n+                for (auto & dep : current_dependents)\n+                    dep.second.emplace();\n+                break;\n+\n+            case ExpressionAction::PROJECT:\n+                current_dependents.clear();\n+                for (const auto & proj : actions[i].projection)\n+                    current_dependents[proj.first].emplace();\n+                break;\n+\n+            case ExpressionAction::ADD_COLUMN:\n+            case ExpressionAction::COPY_COLUMN:\n+            case ExpressionAction::ARRAY_JOIN:\n+            case ExpressionAction::JOIN:\n+            {\n+                Names columns = actions[i].getNeededColumns();\n+                for (const auto & column : columns)\n+                    current_dependents[column].emplace();\n+                break;\n+            }\n+\n+            case ExpressionAction::APPLY_FUNCTION:\n+            {\n+                dependents[i] = current_dependents[actions[i].result_name];\n+                const bool compilable = isCompilable(context->builder, *actions[i].function);\n+                for (const auto & name : actions[i].argument_names)\n+                {\n+                    if (compilable)\n+                        current_dependents[name].emplace(i);\n+                    else\n+                        current_dependents[name].emplace();\n+                }\n+                break;\n+            }\n+        }\n+    }\n+\n+    std::vector<ExpressionActions::Actions> fused(actions.size());\n+    for (size_t i = 0; i < actions.size(); ++i)\n+    {\n+        if (actions[i].type != ExpressionAction::APPLY_FUNCTION || !isCompilable(context->builder, *actions[i].function))\n+            continue;\n+\n+        fused[i].push_back(actions[i]);\n+        if (dependents[i].find({}) != dependents[i].end())\n+        {\n+            /// the result of compiling one function in isolation is pretty much the same as its `execute` method.\n+            if (fused[i].size() == 1)\n+                continue;\n+            auto fn = std::make_shared<LLVMFunction>(std::move(fused[i]), context, sample_block);\n+            actions[i].function = fn;\n+            actions[i].argument_names = fn->getArgumentNames();\n+            continue;\n+        }\n+\n+        /// TODO: determine whether it's profitable to inline the function if there's more than one dependent.\n+        for (const auto & dep : dependents[i])\n+            fused[*dep].insert(fused[*dep].end(), fused[i].begin(), fused[i].end());\n+    }\n+\n+    context->finalize();\n+}\n+\n+}\n+\n+\n+namespace\n+{\n+    struct LLVMTargetInitializer\n+    {\n+        LLVMTargetInitializer()\n+        {\n+            llvm::InitializeNativeTarget();\n+            llvm::InitializeNativeTargetAsmPrinter();\n+            llvm::sys::DynamicLibrary::LoadLibraryPermanently(nullptr);\n+        }\n+    } llvmInitializer;\n+}\n+\n+#endif\ndiff --git a/dbms/src/Interpreters/ExpressionJIT.h b/dbms/src/Interpreters/ExpressionJIT.h\nnew file mode 100644\nindex 000000000000..799a80171b51\n--- /dev/null\n+++ b/dbms/src/Interpreters/ExpressionJIT.h\n@@ -0,0 +1,18 @@\n+#pragma once\n+\n+#include <Common/config.h>\n+\n+#if USE_EMBEDDED_COMPILER\n+\n+#include <Interpreters/ExpressionActions.h>\n+\n+namespace DB\n+{\n+\n+/// For each APPLY_FUNCTION action, try to compile the function to native code; if the only uses of a compilable\n+/// function's result are as arguments to other compilable functions, inline it and leave the now-redundant action as-is.\n+void compileFunctions(ExpressionActions::Actions & actions, const Names & output_columns, const Block & sample_block);\n+\n+}\n+\n+#endif\ndiff --git a/dbms/src/Interpreters/Settings.h b/dbms/src/Interpreters/Settings.h\nindex b1442d65c0f8..9696e7866bf4 100644\n--- a/dbms/src/Interpreters/Settings.h\n+++ b/dbms/src/Interpreters/Settings.h\n@@ -65,6 +65,7 @@ struct Settings\n     M(SettingFloat, totals_auto_threshold, 0.5, \"The threshold for totals_mode = 'auto'.\") \\\n     \\\n     M(SettingBool, compile, false, \"Whether query compilation is enabled.\") \\\n+    M(SettingBool, compile_expressions, true, \"Compile some scalar functions and operators to native code.\") \\\n     M(SettingUInt64, min_count_to_compile, 3, \"The number of structurally identical queries before they are compiled.\") \\\n     M(SettingUInt64, group_by_two_level_threshold, 100000, \"From what number of keys, a two-level aggregation starts. 0 - the threshold is not set.\") \\\n     M(SettingUInt64, group_by_two_level_threshold_bytes, 100000000, \"From what size of the aggregation state in bytes, a two-level aggregation begins to be used. 0 - the threshold is not set. Two-level aggregation is used when at least one of the thresholds is triggered.\") \\\ndiff --git a/dbms/src/Server/Compiler-5.0.0/CMakeLists.txt b/dbms/src/Server/Compiler-5.0.0/CMakeLists.txt\nindex 5151c183bcf8..e72e3f6753b3 100644\n--- a/dbms/src/Server/Compiler-5.0.0/CMakeLists.txt\n+++ b/dbms/src/Server/Compiler-5.0.0/CMakeLists.txt\n@@ -8,12 +8,7 @@ add_library(clickhouse-compiler-lib\n \n target_compile_options(clickhouse-compiler-lib PRIVATE -fno-rtti -fno-exceptions -g0)\n \n-llvm_map_components_to_libraries(REQUIRED_LLVM_LIBRARIES all)\n-\n-# We link statically with zlib, and LLVM (sometimes) tries to bring its own dependency.\n-list(REMOVE_ITEM REQUIRED_LLVM_LIBRARIES \"-lz\")\n-# Wrong library in freebsd:\n-list(REMOVE_ITEM REQUIRED_LLVM_LIBRARIES \"-l/usr/lib/libexecinfo.so\")\n+llvm_map_components_to_libnames(REQUIRED_LLVM_LIBRARIES all)\n \n message(STATUS \"Using LLVM ${LLVM_VERSION}: ${LLVM_INCLUDE_DIRS} : ${REQUIRED_LLVM_LIBRARIES}\")\n \ndiff --git a/dbms/src/Server/Compiler-6.0.0/CMakeLists.txt b/dbms/src/Server/Compiler-6.0.0/CMakeLists.txt\nindex 4c07363abb5f..a66af8bbc7ab 100644\n--- a/dbms/src/Server/Compiler-6.0.0/CMakeLists.txt\n+++ b/dbms/src/Server/Compiler-6.0.0/CMakeLists.txt\n@@ -8,12 +8,7 @@ add_library(clickhouse-compiler-lib\n \n target_compile_options(clickhouse-compiler-lib PRIVATE -fno-rtti -fno-exceptions -g0)\n \n-llvm_map_components_to_libraries(REQUIRED_LLVM_LIBRARIES all)\n-\n-# We link statically with zlib, and LLVM (sometimes) tries to bring its own dependency.\n-list(REMOVE_ITEM REQUIRED_LLVM_LIBRARIES \"-lz\")\n-# Wrong library in freebsd:\n-list(REMOVE_ITEM REQUIRED_LLVM_LIBRARIES \"-l/usr/lib/libexecinfo.so\")\n+llvm_map_components_to_libnames(REQUIRED_LLVM_LIBRARIES all)\n \n message(STATUS \"Using LLVM ${LLVM_VERSION}: ${LLVM_INCLUDE_DIRS} : ${REQUIRED_LLVM_LIBRARIES}\")\n \n@@ -24,7 +19,7 @@ target_include_directories(clickhouse-compiler-lib PRIVATE ${LLVM_INCLUDE_DIRS})\n target_link_libraries(clickhouse-compiler-lib PRIVATE\n \n clangBasic clangCodeGen clangDriver\n-clangFrontend \n+clangFrontend\n clangFrontendTool\n clangRewriteFrontend clangARCMigrate clangStaticAnalyzerFrontend\n clangParse clangSerialization clangSema clangEdit clangStaticAnalyzerCheckers\ndiff --git a/dbms/src/Server/Compiler-7.0.0/CMakeLists.txt b/dbms/src/Server/Compiler-7.0.0/CMakeLists.txt\nindex 6b117469931e..c6e725d3badb 100644\n--- a/dbms/src/Server/Compiler-7.0.0/CMakeLists.txt\n+++ b/dbms/src/Server/Compiler-7.0.0/CMakeLists.txt\n@@ -8,12 +8,7 @@ add_library(clickhouse-compiler-lib\n \n target_compile_options(clickhouse-compiler-lib PRIVATE -fno-rtti -fno-exceptions -g0)\n \n-llvm_map_components_to_libraries(REQUIRED_LLVM_LIBRARIES all)\n-\n-# We link statically with zlib, and LLVM (sometimes) tries to bring its own dependency.\n-list(REMOVE_ITEM REQUIRED_LLVM_LIBRARIES \"-lz\")\n-# Wrong library in freebsd:\n-list(REMOVE_ITEM REQUIRED_LLVM_LIBRARIES \"-l/usr/lib/libexecinfo.so\")\n+llvm_map_components_to_libnames(REQUIRED_LLVM_LIBRARIES all)\n \n message(STATUS \"Using LLVM ${LLVM_VERSION}: ${LLVM_INCLUDE_DIRS} : ${REQUIRED_LLVM_LIBRARIES}\")\n \ndiff --git a/dbms/src/Server/Compiler-7.0.0/cc1as_main.cpp b/dbms/src/Server/Compiler-7.0.0/cc1as_main.cpp\nindex 7a467229cd0f..ce23422077f3 100644\n--- a/dbms/src/Server/Compiler-7.0.0/cc1as_main.cpp\n+++ b/dbms/src/Server/Compiler-7.0.0/cc1as_main.cpp\n@@ -60,16 +60,6 @@ using namespace llvm;\n using namespace llvm::opt;\n \n \n-/// Clang 7 with debug variant of libc++ cannot compile itself without this patch.\n-namespace llvm\n-{\n-    inline bool operator<(const StringRef & s, const SubtargetFeatureKV & feature)\n-    {\n-        return s < StringRef(feature.Key);\n-    }\n-}\n-\n-\n namespace {\n \n /// \\brief Helper class for representing a single invocation of the assembler.\n",
  "test_patch": "diff --git a/dbms/src/Analyzers/tests/CMakeLists.txt b/dbms/src/Analyzers/tests/CMakeLists.txt\nindex a4f331dbd3a6..b1abc236793e 100644\n--- a/dbms/src/Analyzers/tests/CMakeLists.txt\n+++ b/dbms/src/Analyzers/tests/CMakeLists.txt\n@@ -12,7 +12,7 @@ target_link_libraries(type_and_constant_inference\n     clickhouse_storages_system clickhouse_functions clickhouse_aggregate_functions clickhouse_table_functions)\n \n add_executable(analyze_result_of_query analyze_result_of_query.cpp)\n-target_link_libraries(analyze_result_of_query dbms clickhouse_storages_system)\n+target_link_libraries(analyze_result_of_query dbms clickhouse_storages_system libtinfo.a)\n \n add_executable(translate_positional_arguments translate_positional_arguments.cpp)\n target_link_libraries(translate_positional_arguments dbms)\n",
  "problem_statement": "LLVM JIT interface\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nThis pull request adds the capability to compile built-in functions with numeric (possibly nullable) arguments and return type to native code through `llvm::IRBuilder`. Compilable functions are automatically inlined into each other for a performance boost. The function can then also decide where to evaluate each of its inlined arguments, allowing for some laziness (non-compilable subexpressions still have to be evaluated eagerly).\r\n\r\nThis PR also includes implementations of the interface for most arithmetic and logic functions. Don't have any performance comparisons yet, though.\r\n\r\nKnown problems:\r\n\r\n * ~~this code will break with LLVM 7 when it's released due to API incompatibilities;~~\r\n * LLVM has a ton of unused parameters in its header files, so I had to add `-Wno-unused-parameter` to clickhouse_functions;\r\n * *always* inlining compilable subexpressions completely undoes all of common subexpression eliminator's work \u2014 using a heuristic, e.g. thresholding based on the size of the subexpression's graph multiplied by the number of times it is used, might be better overall;\r\n * `and` has somewhat weird semantics in that `and(false, null)` is null. This means it's impossible for `and` to be lazy in the second argument if it's nullable. (`and(x, non-nullable)` and `and(null, x)` work fine, though.)\n",
  "hints_text": "",
  "created_at": "2018-04-24T18:40:37Z"
}