{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21053,
  "instance_id": "ClickHouse__ClickHouse-21053",
  "issue_numbers": [
    "13194"
  ],
  "base_commit": "e1c4ba01691e5432801ee925e36ebb4de9779641",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 74d8d853dcbb..2e2a4ce9cfa0 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -516,6 +516,25 @@ struct ToDateTime64TransformSigned\n         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(from, 0, scale_multiplier);\n     }\n };\n+template <typename FromDataType, typename FromType>\n+struct ToDateTime64TransformFloat\n+{\n+    static constexpr auto name = \"toDateTime64\";\n+\n+    const UInt32 scale = 1;\n+\n+    ToDateTime64TransformFloat(UInt32 scale_ = 0)\n+        : scale(scale_)\n+    {}\n+\n+    inline NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n+    {\n+        if (from < 0)\n+            return 0;\n+        from = std::min<FromType>(from, FromType(0xFFFFFFFF));\n+        return convertToDecimal<FromDataType, DataTypeDateTime64>(from, scale);\n+    }\n+};\n \n template <typename Name> struct ConvertImpl<DataTypeInt8, DataTypeDateTime64, Name>\n     : DateTimeTransformImpl<DataTypeInt8, DataTypeDateTime64, ToDateTime64TransformSigned<Int8>> {};\n@@ -528,9 +547,9 @@ template <typename Name> struct ConvertImpl<DataTypeInt64, DataTypeDateTime64, N\n template <typename Name> struct ConvertImpl<DataTypeUInt64, DataTypeDateTime64, Name>\n     : DateTimeTransformImpl<DataTypeUInt64, DataTypeDateTime64, ToDateTime64TransformUnsigned<UInt64>> {};\n template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDateTime64, ToDateTime64TransformSigned<Float32>> {};\n+    : DateTimeTransformImpl<DataTypeFloat32, DataTypeDateTime64, ToDateTime64TransformFloat<DataTypeFloat32, Float32>> {};\n template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDateTime64, Name>\n-    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime64, ToDateTime64TransformSigned<Float64>> {};\n+    : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime64, ToDateTime64TransformFloat<DataTypeFloat64, Float64>> {};\n \n /** Conversion of DateTime64 to Date or DateTime: discards fractional part.\n  */\ndiff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex fe563021d2ef..72ffd74a42d6 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -831,14 +831,18 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n     static constexpr auto date_time_broken_down_length = 19;\n     /// YYYY-MM-DD\n     static constexpr auto date_broken_down_length = 10;\n-    /// unix timestamp max length\n-    static constexpr auto unix_timestamp_max_length = 10;\n \n     char s[date_time_broken_down_length];\n     char * s_pos = s;\n \n-    /// A piece similar to unix timestamp.\n-    while (s_pos < s + unix_timestamp_max_length && !buf.eof() && isNumericASCII(*buf.position()))\n+    /** Read characters, that could represent unix timestamp.\n+      * Only unix timestamp of at least 5 characters is supported.\n+      * Then look at 5th character. If it is a number - treat whole as unix timestamp.\n+      * If it is not a number - then parse datetime in YYYY-MM-DD hh:mm:ss or YYYY-MM-DD format.\n+      */\n+\n+    /// A piece similar to unix timestamp, maybe scaled to subsecond precision.\n+    while (s_pos < s + date_time_broken_down_length && !buf.eof() && isNumericASCII(*buf.position()))\n     {\n         *s_pos = *buf.position();\n         ++s_pos;\n@@ -846,7 +850,7 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n     }\n \n     /// 2015-01-01 01:02:03 or 2015-01-01\n-    if (s_pos == s + 4 && !buf.eof() && (*buf.position() < '0' || *buf.position() > '9'))\n+    if (s_pos == s + 4 && !buf.eof() && !isNumericASCII(*buf.position()))\n     {\n         const auto already_read_length = s_pos - s;\n         const size_t remaining_date_time_size = date_time_broken_down_length - already_read_length;\n@@ -885,8 +889,7 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n     }\n     else\n     {\n-        /// Only unix timestamp of 5-10 characters is supported. For consistency. See readDateTimeTextImpl.\n-        if (s_pos - s >= 5 && s_pos - s <= 10)\n+        if (s_pos - s >= 5)\n         {\n             /// Not very efficient.\n             datetime = 0;\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex d203bd7bbeef..e33de04f3221 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -703,12 +703,6 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n template <typename ReturnType = void>\n inline ReturnType readDateTimeTextImpl(time_t & datetime, ReadBuffer & buf, const DateLUTImpl & date_lut)\n {\n-    /** Read 10 characters, that could represent unix timestamp.\n-      * Only unix timestamp of 5-10 characters is supported.\n-      * Then look at 5th character. If it is a number - treat whole as unix timestamp.\n-      * If it is not a number - then parse datetime in YYYY-MM-DD hh:mm:ss or YYYY-MM-DD format.\n-      */\n-\n     /// Optimistic path, when whole value is in buffer.\n     const char * s = buf.position();\n \n@@ -779,6 +773,18 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n         while (!buf.eof() && isNumericASCII(*buf.position()))\n             ++buf.position();\n     }\n+    else if (scale && (whole >= 1000000000LL * scale))\n+    {\n+        /// Unix timestamp with subsecond precision, already scaled to integer.\n+        /// For disambiguation we support only time since 2001-09-09 01:46:40 UTC and less than 30 000 years in future.\n+\n+        for (size_t i = 0; i < scale; ++i)\n+        {\n+            components.fractional *= 10;\n+            components.fractional += components.whole % 10;\n+            components.whole /= 10;\n+        }\n+    }\n \n     datetime64 = DecimalUtils::decimalFromComponents<DateTime64>(components, scale);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01691_DateTime64_clamp.reference b/tests/queries/0_stateless/01691_DateTime64_clamp.reference\nindex de72027334c9..849f8139640e 100644\n--- a/tests/queries/0_stateless/01691_DateTime64_clamp.reference\n+++ b/tests/queries/0_stateless/01691_DateTime64_clamp.reference\n@@ -9,3 +9,11 @@ SELECT CAST('2020-01-01 00:00:00.3' AS DateTime64);\n 2020-01-01 00:00:00.300\n SELECT toDateTime64(bitShiftLeft(toUInt64(1),33), 2);\n 2106-02-07 09:28:15.00\n+SELECT toDateTime(-2., 2);\n+1970-01-01 03:00:00.00\n+SELECT toDateTime64(-2., 2);\n+1970-01-01 03:00:00.00\n+SELECT toDateTime64(toFloat32(bitShiftLeft(toUInt64(1),33)), 2);\n+2106-02-07 09:28:16.00\n+SELECT toDateTime64(toFloat64(bitShiftLeft(toUInt64(1),33)), 2);\n+2106-02-07 09:28:15.00\ndiff --git a/tests/queries/0_stateless/01691_DateTime64_clamp.sql b/tests/queries/0_stateless/01691_DateTime64_clamp.sql\nindex 6b5a4815f37e..f02d45a2cff1 100644\n--- a/tests/queries/0_stateless/01691_DateTime64_clamp.sql\n+++ b/tests/queries/0_stateless/01691_DateTime64_clamp.sql\n@@ -4,3 +4,7 @@ SELECT toDateTime64(-2, 2);\n SELECT CAST(-1 AS DateTime64);\n SELECT CAST('2020-01-01 00:00:00.3' AS DateTime64);\n SELECT toDateTime64(bitShiftLeft(toUInt64(1),33), 2);\n+SELECT toDateTime(-2., 2);\n+SELECT toDateTime64(-2., 2);\n+SELECT toDateTime64(toFloat32(bitShiftLeft(toUInt64(1),33)), 2);\n+SELECT toDateTime64(toFloat64(bitShiftLeft(toUInt64(1),33)), 2);\ndiff --git a/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.reference b/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.reference\nnew file mode 100644\nindex 000000000000..4f3181ecce0b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.reference\n@@ -0,0 +1,8 @@\n+1\t2005-03-18 01:58:31.222\n+2\t2005-03-18 01:58:31.222\n+3\t2005-03-18 01:58:31.222\n+4\t2005-03-18 01:58:31.222\n+2005-03-18 04:58:31.222\n+2005-03-18 04:58:31.222\n+2005-03-18 04:58:31.222\n+0\ndiff --git a/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.sql b/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.sql\nnew file mode 100644\nindex 000000000000..dcd874f8c45a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.sql\n@@ -0,0 +1,11 @@\n+CREATE TEMPORARY TABLE t (i UInt8, x DateTime64(3, 'UTC'));\n+INSERT INTO t VALUES (1, 1111111111222);\n+INSERT INTO t VALUES (2, 1111111111.222);\n+INSERT INTO t VALUES (3, '1111111111222');\n+INSERT INTO t VALUES (4, '1111111111.222');\n+SELECT * FROM t ORDER BY i;\n+\n+SELECT toDateTime64(1111111111.222, 3);\n+SELECT toDateTime64('1111111111.222', 3);\n+SELECT toDateTime64('1111111111222', 3);\n+SELECT ignore(toDateTime64(1111111111222, 3)); -- This gives somewhat correct but unexpected result\ndiff --git a/tests/queries/0_stateless/01734_datetime64_from_float.reference b/tests/queries/0_stateless/01734_datetime64_from_float.reference\nnew file mode 100644\nindex 000000000000..32e7d2736c6b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01734_datetime64_from_float.reference\n@@ -0,0 +1,7 @@\n+-- { echo }\n+SELECT CAST(1111111111.222 AS DateTime64(3));\n+2005-03-18 04:58:31.222\n+SELECT toDateTime(1111111111.222, 3);\n+2005-03-18 04:58:31.222\n+SELECT toDateTime64(1111111111.222, 3);\n+2005-03-18 04:58:31.222\ndiff --git a/tests/queries/0_stateless/01734_datetime64_from_float.sql b/tests/queries/0_stateless/01734_datetime64_from_float.sql\nnew file mode 100644\nindex 000000000000..b6be65cb7c25\n--- /dev/null\n+++ b/tests/queries/0_stateless/01734_datetime64_from_float.sql\n@@ -0,0 +1,4 @@\n+-- { echo }\n+SELECT CAST(1111111111.222 AS DateTime64(3));\n+SELECT toDateTime(1111111111.222, 3);\n+SELECT toDateTime64(1111111111.222, 3);\n",
  "problem_statement": "Datetime64 millisecond integers in HTTP protocol do not parse correctly\n**Describe the bug**\r\nWhen using the HTTP protocol with DateTime64 types, numerical timestamps in milliseconds do not parse correctly. This is an issue when using the Clickhouse JDBC driver with Avro Kafka records because the timestamps are integers. \r\n\r\n**How to reproduce**\r\nI'm using the following CH version: yandex/clickhouse-server:20.4.5.36\r\n\r\nCreate a sample table with: \r\n```sql\r\ncreate table tst(ts DateTime64(3)) engine TinyLog();\r\n```\r\n\r\nAttempt to insert millisecond timestamp into the column:\r\n```bash\r\necho \"1596215121682\" | http -v :8123 query==\"insert into tst format TSV\"\r\n```\r\n\r\nError:\r\n```bash\r\nCode: 27, e.displayText() = DB::Exception: Cannot parse input: expected '\\n' before: '682\\n': (at row 1)\r\n\r\nRow 1:\r\nColumn 0,   name: ts, type: DateTime64(3), parsed text: \"1596215121\"\r\nERROR: garbage after DateTime64(3): \"682<LINE FEED>\"\r\n\r\n (version 20.4.5.36 (official build))\r\n```\r\n\r\nOddly, specifying a raw query, this works:\r\n```bash\r\necho 'insert into tst values(1596215121682)' | curl 'http://localhost:8123/' --data-binary @-\r\n```\r\nResult:\r\n```bash\r\nSELECT *\r\nFROM tst\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u2510\r\n\u2502 2020-07-31 17:05:21.682 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\n\r\n**Expected behavior**\r\nI expect to be able to insert integer millisecond timestamps using the HTTP batch insert protocol. \r\n\r\nAgain, this issue is preventing us from using the Clickhouse JDBC driver because it fails to parse our Avro records from Kafka.\r\n\r\nAppreciate the help!\r\n\n",
  "hints_text": "CH expects 1596215121.682 as Decimal because DateTime64 based on Decimal\r\n\r\n```\r\ncreate table tst(ts DateTime64(3)) engine TinyLog();\r\n\r\ninsert into tst format TSV 1596215121682;\r\nDB::Exception: Cannot parse input: expected '\\n' before: '682;': (at row 1)\r\n\r\ninsert into tst format TSV 1596215121.682\r\nOk.\r\n\r\ninsert into tst format CSV '1596215121.682'\r\nOk.\r\n\r\ninsert into tst format CSV 1596215121.682\r\nOk.\r\n\r\nSELECT *\r\nFROM tst\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u2510\r\n\u2502 2020-07-31 17:05:21.682 \u2502\r\n\u2502 2020-07-31 17:05:21.682 \u2502\r\n\u2502 2020-07-31 17:05:21.682 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nAnd this `values` behavior is inconsistent `insert into tst values(1596215121682)` and probably need to resolve it somehow.\r\n\r\n\nhi @den-crane , thank you for the fast response! Glad to know it's not just the HTTP protocol. \r\n\r\nDo you know if there is a way others have gotten around the lack of integer parsing? Without it, it seems like almost all of the open source Kafka ecosystem tools will break. For how integrated Clickhouse is with Kafka, I am surprised this hasn't been an issue before. \r\n\r\nWould it be possible to add a feature request to allow this to work so we can use Avro timestamps with Clickhouse?\r\n\r\n\nCC @Enmk\n@mcgrawia you just need to define kafka table column as Int64 and use fromUnixTimestamp64Milli in kafka MV\r\n```\r\n\r\nSELECT fromUnixTimestamp64Milli(toInt64(1596215121682))\r\n\r\n\u250c\u2500fromUnixTimestamp64Milli(toInt64(1596215121682))\u2500\u2510\r\n\u2502                          2020-07-31 17:05:21.682 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nor use input function +  fromUnixTimestamp64Milli for `insert into tst format TSV 1596215121682;`\n@alexey-milovidov what do you expect from @Enmk ? \r\n\r\n>insert into tst format TSV 1596215121682;\r\n\r\nthis should work or not?\r\n\r\n>insert into tst values(1596215121682)\r\n\r\nthis should work or not?\nthank you @den-crane, that makes sense. We were actually able to find a work-around specific to the Kafka Connect use case. If anyone else stumbles on this issue, you can use the [Kafka Connect Timestamp Converter](https://docs.confluent.io/current/connect/transforms/timestampconverter.html) to transform the Avro longs into a string representation that Clickhouse can understand. \nDateTime64 expects unix timestamp with fractional number of seconds in decimal format.\r\n\r\nIf large integer is passed as you have proposed, overflow will occur. Attempt to distinguish these cases will impose performance penalty.\r\n\r\nIt can be implemented in a tricky way (only assuming 10 digits before point) with small or neglible performance penalty.\n> @alexey-milovidov what do you expect from @Enmk?\r\n\r\n@Enmk is the developer of DateTime64, he can have thoughts on this (but did not answer).\nHi @den-crane, @alexey-milovidov\r\nI also have these issues. I wonder about this random error. The table with the type field is Datatime64, the row I inserted successfully, no row. That makes users very uncomfortable. If it can report errors from the beginning it will help users find other ways to use them.\r\nHave you got the solution to this problem yet, and how to fix it now?\r\n\r\nI created table:\r\n```sql;\r\nCREATE TABLE log (\r\n`id` Int64,\r\n `time` DateTime64(3, 'Asia/Ho_Chi_Minh'),\r\n) ENGINE = MergeTree() PARTITION BY toYYYYMM(toDateTime(toUInt64(time)/1000)) ORDER BY (id) SETTINGS index_granularity = 8192;\r\n```\r\nAnd I inserted:\r\n```sql\r\nINSERT INTO  account  (`id`,`created_time`) VALUES (1, 1576225796097);\r\n```\r\n\r\nError:\r\n```\r\nru.yandex.clickhouse.except.ClickHouseException: ClickHouse exception, code: 27,  e.displayText() = DB::Exception: Cannot parse input: expected \\t before: 097\\t\\t0\\n: (at row 1)  .....\r\n......\r\nERROR: garbage after DateTime64(3, 'Asia/Ho_Chi_Minh'): \"097<TAB><TAB>0<LINE FEED>\"\r\n```\r\n\r\n\r\n\r\n\n@phamtai97 \r\n\r\nCH expects 1576225796.097 as Decimal because DateTime64 based on Decimal\r\n\r\nINSERT INTO  log   VALUES (1, 1576225796.097);\n@den-crane It works in inconsistent fashion:\r\n\r\n```\r\nmilovidov-desktop :) CREATE TEMPORARY TABLE t (x DateTime64(3))\r\n\r\nCREATE TEMPORARY TABLE t\r\n(\r\n    `x` DateTime64(3)\r\n)\r\n\r\nQuery id: bd64042b-f59a-4239-98eb-17cdbb8c650d\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nmilovidov-desktop :) INSERT INTO t VALUES (1111111111222)\r\n\r\nINSERT INTO t VALUES\r\n\r\nQuery id: 40a50c67-0f3a-4a0e-8fe1-e3b703dc1998\r\n\r\nOk.\r\n\r\n1 rows in set. Elapsed: 0.004 sec. \r\n\r\nmilovidov-desktop :) SELECT * FROM t\r\n\r\nSELECT *\r\nFROM t\r\n\r\nQuery id: c535f2d4-f391-440f-83ec-a74830b369fa\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500x\u2500\u2510\r\n\u2502 2005-03-18 04:58:31.222 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.002 sec. \r\n\r\nmilovidov-desktop :) SELECT toDateTime(1111111111)\r\n\r\nSELECT toDateTime(1111111111)\r\n\r\nQuery id: c923fc01-4586-414a-a379-a037e19d677b\r\n\r\n\u250c\u2500toDateTime(1111111111)\u2500\u2510\r\n\u2502    2005-03-18 04:58:31 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.002 sec. \r\n\r\nmilovidov-desktop :) SELECT toDateTime64(1111111111.222, 3)\r\n\r\nSELECT toDateTime64(1111111111.222, 3)\r\n\r\nQuery id: 8dc55551-5eb6-4b41-949a-868789f74642\r\n\r\n\u250c\u2500toDateTime64(1111111111.222, 3)\u2500\u2510\r\n\u2502         2005-03-18 04:58:31.000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.001 sec. \r\n\r\nmilovidov-desktop :) SELECT toDateTime64(1111111111222, 3)\r\n\r\nSELECT toDateTime64(1111111111222, 3)\r\n\r\nQuery id: 4976ec80-0482-4c1e-b213-9d90daf17b05\r\n\r\n\u250c\u2500toDateTime64(1111111111222, 3)\u2500\u2510\r\n\u2502        2106-02-07 09:28:15.000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.002 sec. \r\n\r\nmilovidov-desktop :) SELECT toDateTime64('1111111111222', 3)\r\n\r\nSELECT toDateTime64('1111111111222', 3)\r\n\r\nQuery id: 3a084cc8-c013-4160-8d6a-5bfd265a1f2e\r\n\r\n\r\n0 rows in set. Elapsed: 0.018 sec. \r\n\r\nReceived exception from server (version 21.3.1):\r\nCode: 6. DB::Exception: Received from localhost:9000. DB::Exception: Cannot parse string '1111111111222' as DateTime64(3): syntax error at position 10 (parsed just '1111111111'): While processing toDateTime64('1111111111222', 3).\r\n```",
  "created_at": "2021-02-21T20:37:18Z",
  "modified_files": [
    "src/Functions/FunctionsConversion.h",
    "src/IO/ReadHelpers.cpp",
    "src/IO/ReadHelpers.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01691_DateTime64_clamp.reference",
    "tests/queries/0_stateless/01691_DateTime64_clamp.sql",
    "b/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.reference",
    "b/tests/queries/0_stateless/01732_more_consistent_datetime64_parsing.sql",
    "b/tests/queries/0_stateless/01734_datetime64_from_float.reference",
    "b/tests/queries/0_stateless/01734_datetime64_from_float.sql"
  ]
}