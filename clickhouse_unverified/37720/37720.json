{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37720,
  "instance_id": "ClickHouse__ClickHouse-37720",
  "issue_numbers": [
    "37578"
  ],
  "base_commit": "084dd6f3c27bead9662af4a65cdc5c513d0eb311",
  "patch": "diff --git a/src/Interpreters/ActionsVisitor.cpp b/src/Interpreters/ActionsVisitor.cpp\nindex eacdd221d6e2..f9d18cda777a 100644\n--- a/src/Interpreters/ActionsVisitor.cpp\n+++ b/src/Interpreters/ActionsVisitor.cpp\n@@ -953,13 +953,34 @@ void ActionsMatcher::visit(const ASTFunction & node, const ASTPtr & ast, Data &\n     if (AggregateFunctionFactory::instance().isAggregateFunctionName(node.name))\n         return;\n \n-    FunctionOverloadResolverPtr function_builder = UserDefinedExecutableFunctionFactory::instance().tryGet(node.name, data.getContext());\n+    FunctionOverloadResolverPtr function_builder;\n+\n+    auto current_context = data.getContext();\n+\n+    if (UserDefinedExecutableFunctionFactory::instance().has(node.name, current_context))\n+    {\n+        Array parameters;\n+        if (node.parameters)\n+        {\n+            auto & node_parameters = node.parameters->children;\n+            size_t parameters_size = node_parameters.size();\n+            parameters.resize(parameters_size);\n+\n+            for (size_t i = 0; i < parameters_size; ++i)\n+            {\n+                ASTPtr literal = evaluateConstantExpressionAsLiteral(node_parameters[i], current_context);\n+                parameters[i] = literal->as<ASTLiteral>()->value;\n+            }\n+        }\n+\n+        function_builder = UserDefinedExecutableFunctionFactory::instance().tryGet(node.name, current_context, parameters);\n+    }\n \n     if (!function_builder)\n     {\n         try\n         {\n-            function_builder = FunctionFactory::instance().get(node.name, data.getContext());\n+            function_builder = FunctionFactory::instance().get(node.name, current_context);\n         }\n         catch (Exception & e)\n         {\ndiff --git a/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp\nindex e3d40033cff3..33829aceb31e 100644\n--- a/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp\n+++ b/src/Interpreters/ExternalUserDefinedExecutableFunctionsLoader.cpp\n@@ -1,6 +1,7 @@\n #include \"ExternalUserDefinedExecutableFunctionsLoader.h\"\n \n #include <boost/algorithm/string/split.hpp>\n+#include <Common/StringUtils/StringUtils.h>\n \n #include <DataTypes/DataTypeFactory.h>\n \n@@ -17,6 +18,80 @@ namespace ErrorCodes\n {\n     extern const int BAD_ARGUMENTS;\n     extern const int FUNCTION_ALREADY_EXISTS;\n+    extern const int UNSUPPORTED_METHOD;\n+    extern const int TYPE_MISMATCH;\n+}\n+\n+namespace\n+{\n+    /** Extract parameters from command and replace them with parameter names placeholders.\n+      * Example: test_script.py {parameter_name: UInt64}\n+      * After run function: test_script.py {parameter_name}\n+      */\n+    std::vector<UserDefinedExecutableFunctionParameter> extractParametersFromCommand(String & command_value)\n+    {\n+        std::vector<UserDefinedExecutableFunctionParameter> parameters;\n+        std::unordered_map<std::string_view, DataTypePtr> parameter_name_to_type;\n+\n+        size_t previous_parameter_match_position = 0;\n+        while (true)\n+        {\n+            auto start_parameter_pos = command_value.find('{', previous_parameter_match_position);\n+            if (start_parameter_pos == std::string::npos)\n+                break;\n+\n+            auto end_parameter_pos = command_value.find('}', start_parameter_pos);\n+            if (end_parameter_pos == std::string::npos)\n+                break;\n+\n+            previous_parameter_match_position = start_parameter_pos + 1;\n+\n+            auto semicolon_pos = command_value.find(':', start_parameter_pos);\n+            if (semicolon_pos == std::string::npos)\n+                break;\n+            else if (semicolon_pos > end_parameter_pos)\n+                continue;\n+\n+            std::string parameter_name(command_value.data() + start_parameter_pos + 1, command_value.data() + semicolon_pos);\n+            trim(parameter_name);\n+\n+            bool is_identifier = std::all_of(parameter_name.begin(), parameter_name.end(), [](char character)\n+            {\n+                return isWordCharASCII(character);\n+            });\n+\n+            if (parameter_name.empty() && !is_identifier)\n+                continue;\n+\n+            std::string data_type_name(command_value.data() + semicolon_pos + 1, command_value.data() + end_parameter_pos);\n+            trim(data_type_name);\n+\n+            if (data_type_name.empty())\n+                continue;\n+\n+            DataTypePtr parameter_data_type = DataTypeFactory::instance().get(data_type_name);\n+            auto parameter_name_to_type_it = parameter_name_to_type.find(parameter_name);\n+            if (parameter_name_to_type_it != parameter_name_to_type.end() && !parameter_data_type->equals(*parameter_name_to_type_it->second))\n+                throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                    \"Multiple parameters with same name {} does not have same type. Expected {}. Actual {}\",\n+                    parameter_name,\n+                    parameter_name_to_type_it->second->getName(),\n+                    parameter_data_type->getName());\n+\n+            size_t replace_size = end_parameter_pos - start_parameter_pos - 1;\n+            command_value.replace(start_parameter_pos + 1, replace_size, parameter_name);\n+            previous_parameter_match_position = start_parameter_pos + parameter_name.size();\n+\n+            if (parameter_name_to_type_it == parameter_name_to_type.end())\n+            {\n+                parameters.emplace_back(UserDefinedExecutableFunctionParameter{std::move(parameter_name), std::move(parameter_data_type)});\n+                auto & last_parameter = parameters.back();\n+                parameter_name_to_type.emplace(last_parameter.name, last_parameter.type);\n+            }\n+        }\n+\n+        return parameters;\n+    }\n }\n \n ExternalUserDefinedExecutableFunctionsLoader::ExternalUserDefinedExecutableFunctionsLoader(ContextPtr global_context_)\n@@ -71,6 +146,8 @@ ExternalLoader::LoadablePtr ExternalUserDefinedExecutableFunctionsLoader::create\n     bool execute_direct = config.getBool(key_in_config + \".execute_direct\", true);\n \n     String command_value = config.getString(key_in_config + \".command\");\n+    std::vector<UserDefinedExecutableFunctionParameter> parameters = extractParametersFromCommand(command_value);\n+\n     std::vector<String> command_arguments;\n \n     if (execute_direct)\n@@ -137,12 +214,17 @@ ExternalLoader::LoadablePtr ExternalUserDefinedExecutableFunctionsLoader::create\n         arguments.emplace_back(std::move(argument));\n     }\n \n+    if (is_executable_pool && !parameters.empty())\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+            \"Executable user defined functions with `executable_pool` type does not support parameters\");\n+\n     UserDefinedExecutableFunctionConfiguration function_configuration\n     {\n         .name = name,\n         .command = std::move(command_value),\n         .command_arguments = std::move(command_arguments),\n         .arguments = std::move(arguments),\n+        .parameters = std::move(parameters),\n         .result_type = std::move(result_type),\n         .result_name = std::move(result_name),\n     };\ndiff --git a/src/Interpreters/UserDefinedExecutableFunction.h b/src/Interpreters/UserDefinedExecutableFunction.h\nindex 434c77e9236b..989f9dfe8959 100644\n--- a/src/Interpreters/UserDefinedExecutableFunction.h\n+++ b/src/Interpreters/UserDefinedExecutableFunction.h\n@@ -16,12 +16,19 @@ struct UserDefinedExecutableFunctionArgument\n     String name;\n };\n \n+struct UserDefinedExecutableFunctionParameter\n+{\n+    String name;\n+    DataTypePtr type;\n+};\n+\n struct UserDefinedExecutableFunctionConfiguration\n {\n     std::string name;\n     std::string command;\n     std::vector<std::string> command_arguments;\n     std::vector<UserDefinedExecutableFunctionArgument> arguments;\n+    std::vector<UserDefinedExecutableFunctionParameter> parameters;\n     DataTypePtr result_type;\n     String result_name;\n };\ndiff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\nindex b67e9c16ed57..8e4b66ef893b 100644\n--- a/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\n+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.cpp\n@@ -3,6 +3,8 @@\n #include <filesystem>\n \n #include <Common/filesystemHelpers.h>\n+#include <Common/FieldVisitorToString.h>\n+#include <DataTypes/FieldToDataType.h>\n \n #include <Processors/Sources/ShellCommandSource.h>\n #include <Processors/Sources/SourceFromSingleChunk.h>\n@@ -11,6 +13,7 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <Interpreters/convertFieldToType.h>\n #include <Interpreters/ExternalUserDefinedExecutableFunctionsLoader.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/castColumn.h>\n@@ -22,6 +25,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int UNSUPPORTED_METHOD;\n+    extern const int BAD_ARGUMENTS;\n }\n \n class UserDefinedFunction final : public IFunction\n@@ -30,10 +34,65 @@ class UserDefinedFunction final : public IFunction\n \n     explicit UserDefinedFunction(\n         ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr executable_function_,\n-        ContextPtr context_)\n+        ContextPtr context_,\n+        Array parameters_)\n         : executable_function(std::move(executable_function_))\n         , context(context_)\n     {\n+        const auto & configuration = executable_function->getConfiguration();\n+        size_t command_parameters_size = configuration.parameters.size();\n+        if (command_parameters_size != parameters_.size())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Executable user defined function {} number of parameters does not match. Expected {}. Actual {}\",\n+                configuration.name,\n+                command_parameters_size,\n+                parameters_.size());\n+\n+        command_with_parameters = configuration.command;\n+        command_arguments_with_parameters = configuration.command_arguments;\n+\n+        for (size_t i = 0; i < command_parameters_size; ++i)\n+        {\n+            const auto & command_parameter = configuration.parameters[i];\n+            const auto & parameter_value = parameters_[i];\n+            auto converted_parameter = convertFieldToTypeOrThrow(parameter_value, *command_parameter.type);\n+            auto parameter_placeholder = \"{\" + command_parameter.name + \"}\";\n+\n+            auto parameter_value_string = applyVisitor(FieldVisitorToString(), converted_parameter);\n+            bool find_placedholder = false;\n+\n+            auto try_replace_parameter_placeholder_with_value = [&](std::string & command_part)\n+            {\n+                size_t previous_parameter_placeholder_position = 0;\n+\n+                while (true)\n+                {\n+                    auto parameter_placeholder_position = command_part.find(parameter_placeholder, previous_parameter_placeholder_position);\n+                    if (parameter_placeholder_position == std::string::npos)\n+                        break;\n+\n+                    size_t parameter_placeholder_size = parameter_placeholder.size();\n+                    command_part.replace(parameter_placeholder_position, parameter_placeholder_size, parameter_value_string);\n+                    previous_parameter_placeholder_position = parameter_placeholder_position + parameter_value_string.size();\n+                    find_placedholder = true;\n+                }\n+\n+                find_placedholder = true;\n+            };\n+\n+            for (auto & command_argument : command_arguments_with_parameters)\n+                try_replace_parameter_placeholder_with_value(command_argument);\n+\n+            try_replace_parameter_placeholder_with_value(command_with_parameters);\n+\n+            if (!find_placedholder)\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Executable user defined function {} no placeholder for parameter {}\",\n+                    configuration.name,\n+                    command_parameter.name);\n+            }\n+        }\n     }\n \n     String getName() const override { return executable_function->getConfiguration().name; }\n@@ -63,7 +122,7 @@ class UserDefinedFunction final : public IFunction\n         const auto & coordinator_configuration = coordinator->getConfiguration();\n         const auto & configuration = executable_function->getConfiguration();\n \n-        String command = configuration.command;\n+        String command = command_with_parameters;\n \n         if (coordinator_configuration.execute_direct)\n         {\n@@ -134,7 +193,7 @@ class UserDefinedFunction final : public IFunction\n \n         Pipe pipe = coordinator->createPipe(\n             command,\n-            configuration.command_arguments,\n+            command_arguments_with_parameters,\n             std::move(shell_input_pipes),\n             result_block,\n             context,\n@@ -165,9 +224,10 @@ class UserDefinedFunction final : public IFunction\n     }\n \n private:\n-\n     ExternalUserDefinedExecutableFunctionsLoader::UserDefinedExecutableFunctionPtr executable_function;\n     ContextPtr context;\n+    String command_with_parameters;\n+    std::vector<std::string> command_arguments_with_parameters;\n };\n \n UserDefinedExecutableFunctionFactory & UserDefinedExecutableFunctionFactory::instance()\n@@ -176,15 +236,15 @@ UserDefinedExecutableFunctionFactory & UserDefinedExecutableFunctionFactory::ins\n     return result;\n }\n \n-FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::get(const String & function_name, ContextPtr context)\n+FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::get(const String & function_name, ContextPtr context, Array parameters)\n {\n     const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\n     auto executable_function = std::static_pointer_cast<const UserDefinedExecutableFunction>(loader.load(function_name));\n-    auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context));\n+    auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context), std::move(parameters));\n     return std::make_unique<FunctionToOverloadResolverAdaptor>(std::move(function));\n }\n \n-FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::tryGet(const String & function_name, ContextPtr context)\n+FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::tryGet(const String & function_name, ContextPtr context, Array parameters)\n {\n     const auto & loader = context->getExternalUserDefinedExecutableFunctionsLoader();\n     auto load_result = loader.getLoadResult(function_name);\n@@ -192,7 +252,7 @@ FunctionOverloadResolverPtr UserDefinedExecutableFunctionFactory::tryGet(const S\n     if (load_result.object)\n     {\n         auto executable_function = std::static_pointer_cast<const UserDefinedExecutableFunction>(load_result.object);\n-        auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context));\n+        auto function = std::make_shared<UserDefinedFunction>(std::move(executable_function), std::move(context), std::move(parameters));\n         return std::make_unique<FunctionToOverloadResolverAdaptor>(std::move(function));\n     }\n \ndiff --git a/src/Interpreters/UserDefinedExecutableFunctionFactory.h b/src/Interpreters/UserDefinedExecutableFunctionFactory.h\nindex 989db4c481b0..ad10cb3c10fb 100644\n--- a/src/Interpreters/UserDefinedExecutableFunctionFactory.h\n+++ b/src/Interpreters/UserDefinedExecutableFunctionFactory.h\n@@ -5,9 +5,9 @@\n #include <string>\n #include <unordered_map>\n \n-#include <Common/NamePrompter.h>\n-#include <Interpreters/Context_fwd.h>\n+#include <Core/Field.h>\n #include <Functions/IFunction.h>\n+#include <Interpreters/Context_fwd.h>\n \n \n namespace DB\n@@ -20,9 +20,9 @@ class UserDefinedExecutableFunctionFactory\n \n     static UserDefinedExecutableFunctionFactory & instance();\n \n-    static FunctionOverloadResolverPtr get(const String & function_name, ContextPtr context);\n+    static FunctionOverloadResolverPtr get(const String & function_name, ContextPtr context, Array parameters = {});\n \n-    static FunctionOverloadResolverPtr tryGet(const String & function_name, ContextPtr context);\n+    static FunctionOverloadResolverPtr tryGet(const String & function_name, ContextPtr context, Array parameters = {});\n \n     static bool has(const String & function_name, ContextPtr context);\n \n",
  "test_patch": "diff --git a/tests/config/test_function.xml b/tests/config/test_function.xml\nindex 928cbd75c785..a50ab69422ac 100644\n--- a/tests/config/test_function.xml\n+++ b/tests/config/test_function.xml\n@@ -13,4 +13,18 @@\n         <command>cd /; clickhouse-local --input-format TabSeparated --output-format TabSeparated --structure 'x UInt64, y UInt64' --query \"SELECT x + y FROM table\"</command>\n         <execute_direct>0</execute_direct>\n     </function>\n+    <function>\n+        <type>executable</type>\n+        <name>test_function_with_parameter</name>\n+        <return_type>UInt64</return_type>\n+        <argument>\n+            <type>UInt64</type>\n+        </argument>\n+        <argument>\n+            <type>UInt64</type>\n+        </argument>\n+        <format>TabSeparated</format>\n+        <command>cd /; clickhouse-local --input-format TabSeparated --output-format TabSeparated --structure 'x UInt64, y UInt64' --query \"SELECT x + y + {test_parameter : UInt64} FROM table\"</command>\n+        <execute_direct>0</execute_direct>\n+    </function>\n </functions>\ndiff --git a/tests/integration/test_executable_user_defined_function/functions/test_function_config.xml b/tests/integration/test_executable_user_defined_function/functions/test_function_config.xml\nindex 5da2e854da80..d35cb173dd06 100644\n--- a/tests/integration/test_executable_user_defined_function/functions/test_function_config.xml\n+++ b/tests/integration/test_executable_user_defined_function/functions/test_function_config.xml\n@@ -311,4 +311,15 @@\n         <command>input_nullable.py</command>\n     </function>\n \n+    <function>\n+        <type>executable</type>\n+        <name>test_function_parameter_python</name>\n+        <return_type>String</return_type>\n+        <argument>\n+            <type>UInt64</type>\n+        </argument>\n+        <format>TabSeparated</format>\n+        <command>input_parameter.py {test_parameter:UInt64}</command>\n+    </function>\n+\n </functions>\ndiff --git a/tests/integration/test_executable_user_defined_function/test.py b/tests/integration/test_executable_user_defined_function/test.py\nindex f48547a14377..1f4e14470c37 100644\n--- a/tests/integration/test_executable_user_defined_function/test.py\n+++ b/tests/integration/test_executable_user_defined_function/test.py\n@@ -263,3 +263,25 @@ def test_executable_function_input_nullable_python(started_cluster):\n         )\n         == \"Key 0\\nKey Nullable\\nKey 2\\n\"\n     )\n+\n+\n+def test_executable_function_parameter_python(started_cluster):\n+    skip_test_msan(node)\n+\n+    assert node.query_and_get_error(\n+        \"SELECT test_function_parameter_python(2,2)(toUInt64(1))\"\n+    )\n+    assert node.query_and_get_error(\"SELECT test_function_parameter_python(2,2)(1)\")\n+    assert node.query_and_get_error(\"SELECT test_function_parameter_python(1)\")\n+    assert node.query_and_get_error(\n+        \"SELECT test_function_parameter_python('test')(toUInt64(1))\"\n+    )\n+\n+    assert (\n+        node.query(\"SELECT test_function_parameter_python('2')(toUInt64(1))\")\n+        == \"Parameter 2 key 1\\n\"\n+    )\n+    assert (\n+        node.query(\"SELECT test_function_parameter_python(2)(toUInt64(1))\")\n+        == \"Parameter 2 key 1\\n\"\n+    )\ndiff --git a/tests/integration/test_executable_user_defined_function/user_scripts/input_parameter.py b/tests/integration/test_executable_user_defined_function/user_scripts/input_parameter.py\nnew file mode 100755\nindex 000000000000..c9d6ff9f9d58\n--- /dev/null\n+++ b/tests/integration/test_executable_user_defined_function/user_scripts/input_parameter.py\n@@ -0,0 +1,8 @@\n+#!/usr/bin/python3\n+\n+import sys\n+\n+if __name__ == \"__main__\":\n+    for line in sys.stdin:\n+        print(\"Parameter \" + str(sys.argv[1]) + \" key \" + str(line), end=\"\")\n+        sys.stdout.flush()\ndiff --git a/tests/queries/0_stateless/02315_executable_user_defined_function_parameter.reference b/tests/queries/0_stateless/02315_executable_user_defined_function_parameter.reference\nnew file mode 100644\nindex 000000000000..fd3c81a4d763\n--- /dev/null\n+++ b/tests/queries/0_stateless/02315_executable_user_defined_function_parameter.reference\n@@ -0,0 +1,2 @@\n+5\n+5\ndiff --git a/tests/queries/0_stateless/02315_executable_user_defined_function_parameter.sql b/tests/queries/0_stateless/02315_executable_user_defined_function_parameter.sql\nnew file mode 100644\nindex 000000000000..f6e5678e6120\n--- /dev/null\n+++ b/tests/queries/0_stateless/02315_executable_user_defined_function_parameter.sql\n@@ -0,0 +1,6 @@\n+SELECT test_function_with_parameter('test')(1, 2); --{serverError 53}\n+SELECT test_function_with_parameter(2, 2)(1, 2); --{serverError 36}\n+SELECT test_function_with_parameter(1, 2); --{serverError 36}\n+\n+SELECT test_function_with_parameter(2)(1, 2);\n+SELECT test_function_with_parameter('2')(1, 2);\n",
  "problem_statement": "Parameters for executable UDF \n**Use case**\r\n\r\nAbility to pass (constant) parameters for user defined functions. \r\n\r\n**Describe the solution you'd like**\r\n\r\nSELECT voronoiDiagram(0,0,1000,1000)(arr_x,arr_y)\r\n\r\n```\r\n<clickhouse>\r\n<functions>\r\n        <type>executable</type>\r\n        <name>voronoiDiagram</name>\r\n        <return_type>Array(Array(UInt64))</return_type>\r\n        <argument>\r\n            <type>Array(Array(UInt64))</type>\r\n        </argument>\r\n        <parameter>\r\n            <name>min_x</name>\r\n            <type>UInt32</type>\r\n        </parameter>\r\n        <parameter>\r\n            <name>min_x</name>\r\n            <type>UInt32</type>\r\n        </parameter>\r\n        <parameter>\r\n            <name>min_y</name>\r\n            <type>UInt32</type>\r\n        </parameter>\r\n        <parameter>\r\n            <name>max_x</name>\r\n            <type>UInt32</type>\r\n        </parameter>\r\n        <parameter>\r\n            <name>max_y</name>\r\n            <type>UInt32</type>\r\n        </parameter>\r\n        <format>Native</format>\r\n        <command>voronoiDiagram --min_x ${min_x} --min_y ${min_y} --max_x ${max_x} --max_y ${max_y} </command>\r\n</functions>\r\n</clickhouse>\r\n```\r\n\r\nIt will allow to use them in function initialization and do not define them for each row independently.(which will make it more expensive to run)\r\n\n",
  "hints_text": "Make sense only for executable user defined functions, not executable pool.",
  "created_at": "2022-05-31T20:29:16Z"
}