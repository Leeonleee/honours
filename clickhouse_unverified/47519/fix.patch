diff --git a/base/base/coverage.cpp b/base/base/coverage.cpp
index 043f97f95931..1027638be3db 100644
--- a/base/base/coverage.cpp
+++ b/base/base/coverage.cpp
@@ -2,6 +2,8 @@
 
 #if WITH_COVERAGE
 
+#pragma GCC diagnostic ignored "-Wreserved-identifier"
+
 #    include <mutex>
 #    include <unistd.h>
 
diff --git a/contrib/croaring b/contrib/croaring
index 2c867e9f9c9e..f40ed52bcdd6 160000
--- a/contrib/croaring
+++ b/contrib/croaring
@@ -1,1 +1,1 @@
-Subproject commit 2c867e9f9c9e2a3a7032791f94c4c7ae3013f6e0
+Subproject commit f40ed52bcdd635840a79877cef4857315dba817c
diff --git a/contrib/croaring-cmake/CMakeLists.txt b/contrib/croaring-cmake/CMakeLists.txt
index 0bb7d0bd221a..794c0426b969 100644
--- a/contrib/croaring-cmake/CMakeLists.txt
+++ b/contrib/croaring-cmake/CMakeLists.txt
@@ -17,7 +17,8 @@ set(SRCS
     "${LIBRARY_DIR}/src/containers/run.c"
     "${LIBRARY_DIR}/src/roaring.c"
     "${LIBRARY_DIR}/src/roaring_priority_queue.c"
-    "${LIBRARY_DIR}/src/roaring_array.c")
+    "${LIBRARY_DIR}/src/roaring_array.c"
+    "${LIBRARY_DIR}/src/memory.c")
 
 add_library(_roaring ${SRCS})
 
diff --git a/docs/en/development/build.md b/docs/en/development/build.md
index d52b018a5a77..804aa8a3dc58 100644
--- a/docs/en/development/build.md
+++ b/docs/en/development/build.md
@@ -159,4 +159,3 @@ The CI checks build the binaries on each commit to [ClickHouse](https://github.c
 1. Find the type of package for your operating system that you need and download the files.
 
 ![build artifact check](images/find-build-artifact.png)
-
diff --git a/src/AggregateFunctions/AggregateFunctionForEach.h b/src/AggregateFunctions/AggregateFunctionForEach.h
index f041dd11209e..81ba298bb8a6 100644
--- a/src/AggregateFunctions/AggregateFunctionForEach.h
+++ b/src/AggregateFunctions/AggregateFunctionForEach.h
@@ -2,6 +2,7 @@
 
 #include <Columns/ColumnArray.h>
 #include <Common/assert_cast.h>
+#include <base/arithmeticOverflow.h>
 #include <DataTypes/DataTypeArray.h>
 #include <AggregateFunctions/IAggregateFunction.h>
 
@@ -20,6 +21,8 @@ namespace ErrorCodes
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int SIZES_OF_ARRAYS_DONT_MATCH;
+    extern const int TOO_LARGE_ARRAY_SIZE;
+    extern const int LOGICAL_ERROR;
 }
 
 
@@ -65,11 +68,17 @@ class AggregateFunctionForEach final : public IAggregateFunctionDataHelper<Aggre
         size_t old_size = state.dynamic_array_size;
         if (old_size < new_size)
         {
+            static constexpr size_t MAX_ARRAY_SIZE = 100_GiB;
+            if (new_size > MAX_ARRAY_SIZE)
+                throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Suspiciously large array size ({}) in -ForEach aggregate function", new_size);
+
+            size_t allocation_size = 0;
+            if (common::mulOverflow(new_size, nested_size_of_data, allocation_size))
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "Allocation size ({} * {}) overflows in -ForEach aggregate function, but it should've been prevented by previous checks", new_size, nested_size_of_data);
+
             char * old_state = state.array_of_aggregate_datas;
 
-            char * new_state = arena.alignedAlloc(
-                new_size * nested_size_of_data,
-                nested_func->alignOfData());
+            char * new_state = arena.alignedAlloc(allocation_size, nested_func->alignOfData());
 
             size_t i;
             try
diff --git a/src/AggregateFunctions/AggregateFunctionGroupArray.h b/src/AggregateFunctions/AggregateFunctionGroupArray.h
index eaffb04e2a98..5a799dc36413 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupArray.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupArray.h
@@ -366,6 +366,8 @@ struct GroupArrayNodeBase
     {
         UInt64 size;
         readVarUInt(size, buf);
+        if (unlikely(size > AGGREGATE_FUNCTION_GROUP_ARRAY_MAX_ARRAY_SIZE))
+            throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size");
 
         Node * node = reinterpret_cast<Node *>(arena->alignedAlloc(sizeof(Node) + size, alignof(Node)));
         node->size = size;
diff --git a/src/AggregateFunctions/AggregateFunctionGroupBitmap.h b/src/AggregateFunctions/AggregateFunctionGroupBitmap.h
index 5fe3128fa205..a32bb330884b 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupBitmap.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupBitmap.h
@@ -31,22 +31,28 @@ class AggregateFunctionBitmap final : public IAggregateFunctionDataHelper<Data,
 
     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override
     {
-        this->data(place).rbs.add(assert_cast<const ColumnVector<T> &>(*columns[0]).getData()[row_num]);
+        this->data(place).roaring_bitmap_with_small_set.add(assert_cast<const ColumnVector<T> &>(*columns[0]).getData()[row_num]);
     }
 
     void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override
     {
-        this->data(place).rbs.merge(this->data(rhs).rbs);
+        this->data(place).roaring_bitmap_with_small_set.merge(this->data(rhs).roaring_bitmap_with_small_set);
     }
 
-    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override { this->data(place).rbs.write(buf); }
+    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override
+    {
+        this->data(place).roaring_bitmap_with_small_set.write(buf);
+    }
 
-    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version */, Arena *) const override { this->data(place).rbs.read(buf); }
+    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version */, Arena *) const override
+    {
+        this->data(place).roaring_bitmap_with_small_set.read(buf);
+    }
 
     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override
     {
         assert_cast<ColumnVector<T> &>(to).getData().push_back(
-            static_cast<T>(this->data(place).rbs.size()));
+            static_cast<T>(this->data(place).roaring_bitmap_with_small_set.size()));
     }
 };
 
@@ -81,7 +87,7 @@ class AggregateFunctionBitmapL2 final : public IAggregateFunctionDataHelper<Data
         if (!data_lhs.init)
         {
             data_lhs.init = true;
-            data_lhs.rbs.merge(data_rhs.rbs);
+            data_lhs.roaring_bitmap_with_small_set.merge(data_rhs.roaring_bitmap_with_small_set);
         }
         else
         {
@@ -100,7 +106,7 @@ class AggregateFunctionBitmapL2 final : public IAggregateFunctionDataHelper<Data
         if (!data_lhs.init)
         {
             data_lhs.init = true;
-            data_lhs.rbs.merge(data_rhs.rbs);
+            data_lhs.roaring_bitmap_with_small_set.merge(data_rhs.roaring_bitmap_with_small_set);
         }
         else
         {
@@ -128,7 +134,7 @@ class AggregateFunctionBitmapL2 final : public IAggregateFunctionDataHelper<Data
         if (*version >= 1)
             DB::writeBoolText(this->data(place).init, buf);
 
-        this->data(place).rbs.write(buf);
+        this->data(place).roaring_bitmap_with_small_set.write(buf);
     }
 
     void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> version, Arena *) const override
@@ -138,13 +144,13 @@ class AggregateFunctionBitmapL2 final : public IAggregateFunctionDataHelper<Data
 
         if (*version >= 1)
             DB::readBoolText(this->data(place).init, buf);
-        this->data(place).rbs.read(buf);
+        this->data(place).roaring_bitmap_with_small_set.read(buf);
     }
 
     void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override
     {
         assert_cast<ColumnVector<T> &>(to).getData().push_back(
-            static_cast<T>(this->data(place).rbs.size()));
+            static_cast<T>(this->data(place).roaring_bitmap_with_small_set.size()));
     }
 };
 
@@ -154,7 +160,7 @@ class BitmapAndPolicy
 {
 public:
     static constexpr auto name = "groupBitmapAnd";
-    static void apply(Data & lhs, const Data & rhs) { lhs.rbs.rb_and(rhs.rbs); }
+    static void apply(Data & lhs, const Data & rhs) { lhs.roaring_bitmap_with_small_set.rb_and(rhs.roaring_bitmap_with_small_set); }
 };
 
 template <typename Data>
@@ -162,7 +168,7 @@ class BitmapOrPolicy
 {
 public:
     static constexpr auto name = "groupBitmapOr";
-    static void apply(Data & lhs, const Data & rhs) { lhs.rbs.rb_or(rhs.rbs); }
+    static void apply(Data & lhs, const Data & rhs) { lhs.roaring_bitmap_with_small_set.rb_or(rhs.roaring_bitmap_with_small_set); }
 };
 
 template <typename Data>
@@ -170,7 +176,7 @@ class BitmapXorPolicy
 {
 public:
     static constexpr auto name = "groupBitmapXor";
-    static void apply(Data & lhs, const Data & rhs) { lhs.rbs.rb_xor(rhs.rbs); }
+    static void apply(Data & lhs, const Data & rhs) { lhs.roaring_bitmap_with_small_set.rb_xor(rhs.roaring_bitmap_with_small_set); }
 };
 
 template <typename T, typename Data>
diff --git a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h
index 801526432ae1..62017251108d 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupBitmapData.h
@@ -20,6 +20,12 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int TOO_LARGE_ARRAY_SIZE;
+    extern const int INCORRECT_DATA;
+}
+
 enum BitmapKind
 {
     Small = 0,
@@ -41,20 +47,19 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
     using ValueBuffer = std::vector<T>;
     using RoaringBitmap = std::conditional_t<sizeof(T) >= 8, roaring::Roaring64Map, roaring::Roaring>;
     using Value = std::conditional_t<sizeof(T) >= 8, UInt64, UInt32>;
-    std::shared_ptr<RoaringBitmap> rb = nullptr;
+    std::shared_ptr<RoaringBitmap> roaring_bitmap;
 
     void toLarge()
     {
-        rb = std::make_shared<RoaringBitmap>();
+        roaring_bitmap = std::make_shared<RoaringBitmap>();
         for (const auto & x : small)
-            rb->add(static_cast<Value>(x.getValue()));
+            roaring_bitmap->add(static_cast<Value>(x.getValue()));
         small.clear();
     }
 
 public:
-    bool isLarge() const { return rb != nullptr; }
-
-    bool isSmall() const { return rb == nullptr; }
+    bool isLarge() const { return roaring_bitmap != nullptr; }
+    bool isSmall() const { return roaring_bitmap == nullptr; }
 
     void add(T value)
     {
@@ -63,17 +68,19 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
             if (small.find(value) == small.end())
             {
                 if (!small.full())
+                {
                     small.insert(value);
+                }
                 else
                 {
                     toLarge();
-                    rb->add(static_cast<Value>(value));
+                    roaring_bitmap->add(static_cast<Value>(value));
                 }
             }
         }
         else
         {
-            rb->add(static_cast<Value>(value));
+            roaring_bitmap->add(static_cast<Value>(value));
         }
     }
 
@@ -82,7 +89,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         if (isSmall())
             return small.size();
         else
-            return rb->cardinality();
+            return roaring_bitmap->cardinality();
     }
 
     void merge(const RoaringBitmapWithSmallSet & r1)
@@ -92,7 +99,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
             if (isSmall())
                 toLarge();
 
-            *rb |= *r1.rb;
+            *roaring_bitmap |= *r1.roaring_bitmap;
         }
         else
         {
@@ -105,6 +112,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
     {
         UInt8 kind;
         readBinary(kind, in);
+
         if (BitmapKind::Small == kind)
         {
             small.read(in);
@@ -113,26 +121,39 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             size_t size;
             readVarUInt(size, in);
+
+            static constexpr size_t max_size = 1_GiB;
+
+            if (size == 0)
+                throw Exception(ErrorCodes::INCORRECT_DATA, "Incorrect size (0) in groupBitmap.");
+            if (size > max_size)
+                throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size in groupBitmap.");
+
+            /// TODO: this is unnecessary copying - it will be better to read and deserialize in one pass.
             std::unique_ptr<char[]> buf(new char[size]);
             in.readStrict(buf.get(), size);
-            rb = std::make_shared<RoaringBitmap>(RoaringBitmap::read(buf.get()));
+
+            roaring_bitmap = std::make_shared<RoaringBitmap>(RoaringBitmap::readSafe(buf.get(), size));
         }
+        else
+            throw Exception(ErrorCodes::INCORRECT_DATA, "Unknown type of roaring bitmap");
     }
 
     void write(DB::WriteBuffer & out) const
     {
         UInt8 kind = isLarge() ? BitmapKind::Bitmap : BitmapKind::Small;
         writeBinary(kind, out);
+
         if (BitmapKind::Small == kind)
         {
             small.write(out);
         }
         else if (BitmapKind::Bitmap == kind)
         {
-            auto size = rb->getSizeInBytes();
+            auto size = roaring_bitmap->getSizeInBytes();
             writeVarUInt(size, out);
             std::unique_ptr<char[]> buf(new char[size]);
-            rb->write(buf.get());
+            roaring_bitmap->write(buf.get());
             out.write(buf.get(), size);
         }
     }
@@ -173,7 +194,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             for (const auto & x : small)
             {
-                if (r1.rb->contains(static_cast<Value>(x.getValue())))
+                if (r1.roaring_bitmap->contains(static_cast<Value>(x.getValue())))
                     buffer.push_back(x.getValue());
             }
 
@@ -187,15 +208,18 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         }
         else
         {
-            std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.rb;
-            *rb &= *new_rb;
+            std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.roaring_bitmap;
+            *roaring_bitmap &= *new_rb;
         }
     }
 
     /**
      * Computes the union between two bitmaps.
      */
-    void rb_or(const RoaringBitmapWithSmallSet & r1) { merge(r1); } /// NOLINT
+    void rb_or(const RoaringBitmapWithSmallSet & r1)
+    {
+        merge(r1); /// NOLINT
+    }
 
     /**
      * Computes the symmetric difference (xor) between two bitmaps.
@@ -205,8 +229,8 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         if (isSmall())
             toLarge();
 
-        std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.rb;
-        *rb ^= *new_rb;
+        std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.roaring_bitmap;
+        *roaring_bitmap ^= *new_rb;
     }
 
     /**
@@ -234,7 +258,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             for (const auto & x : small)
             {
-                if (!r1.rb->contains(static_cast<Value>(x.getValue())))
+                if (!r1.roaring_bitmap->contains(static_cast<Value>(x.getValue())))
                     buffer.push_back(x.getValue());
             }
 
@@ -248,8 +272,8 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         }
         else
         {
-            std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.rb;
-            *rb -= *new_rb;
+            std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.roaring_bitmap;
+            *roaring_bitmap -= *new_rb;
         }
     }
 
@@ -269,14 +293,14 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             for (const auto & x : small)
             {
-                if (r1.rb->contains(static_cast<Value>(x.getValue())))
+                if (r1.roaring_bitmap->contains(static_cast<Value>(x.getValue())))
                     ++ret;
             }
         }
         else
         {
-            std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.rb;
-            ret = (*rb & *new_rb).cardinality();
+            std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.roaring_bitmap;
+            ret = (*roaring_bitmap & *new_rb).cardinality();
         }
         return ret;
     }
@@ -321,8 +345,8 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         if (isSmall())
             toLarge();
 
-        std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.rb;
-        return *rb == *new_rb;
+        std::shared_ptr<RoaringBitmap> new_rb = r1.isSmall() ? r1.getNewRoaringBitmapFromSmall() : r1.roaring_bitmap;
+        return *roaring_bitmap == *new_rb;
     }
 
     /**
@@ -343,7 +367,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
             {
                 for (const auto & x : small)
                 {
-                    if (r1.rb->contains(static_cast<Value>(x.getValue())))
+                    if (r1.roaring_bitmap->contains(static_cast<Value>(x.getValue())))
                         return 1;
                 }
             }
@@ -352,13 +376,13 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             for (const auto & x : r1.small)
             {
-                if (rb->contains(static_cast<Value>(x.getValue())))
+                if (roaring_bitmap->contains(static_cast<Value>(x.getValue())))
                     return 1;
             }
         }
         else
         {
-            if ((*rb & *r1.rb).cardinality() > 0)
+            if ((*roaring_bitmap & *r1.roaring_bitmap).cardinality() > 0)
                 return 1;
         }
 
@@ -396,7 +420,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
                 // greater then r1 is not a subset.
                 for (const auto & x : small)
                 {
-                    if (!r1.rb->contains(static_cast<Value>(x.getValue())) && ++r1_size > small.size())
+                    if (!r1.roaring_bitmap->contains(static_cast<Value>(x.getValue())) && ++r1_size > small.size())
                         return 0;
                 }
             }
@@ -405,13 +429,13 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             for (const auto & x : r1.small)
             {
-                if (!rb->contains(static_cast<Value>(x.getValue())))
+                if (!roaring_bitmap->contains(static_cast<Value>(x.getValue())))
                     return 0;
             }
         }
         else
         {
-            if (!r1.rb->isSubset(*rb))
+            if (!r1.roaring_bitmap->isSubset(*roaring_bitmap))
                 return 0;
         }
         return 1;
@@ -428,46 +452,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         if (isSmall())
             return small.find(static_cast<T>(x)) != small.end();
         else
-            return rb->contains(static_cast<Value>(x));
-    }
-
-    /**
-     * Remove value
-     */
-    void rb_remove(UInt64 x) /// NOLINT
-    {
-        if (!std::is_same_v<T, UInt64> && x > rb_max())
-            return;
-
-        if (isSmall())
-            toLarge();
-
-        rb->remove(x);
-    }
-
-    /**
-     * compute (in place) the negation of the roaring bitmap within a specified
-     * interval: [range_start, range_end). The number of negated values is
-     * range_end - range_start.
-     * Areas outside the range are passed through unchanged.
-     */
-    void rb_flip(UInt64 begin, UInt64 end) /// NOLINT
-    {
-        if (isSmall())
-            toLarge();
-
-        rb->flip(begin, end);
-    }
-
-    /**
-     * returns the number of integers that are smaller or equal to offsetid.
-     */
-    UInt64 rb_rank(UInt64 x) /// NOLINT
-    {
-        if (isSmall())
-            toLarge();
-
-        return rb->rank(x);
+            return roaring_bitmap->contains(static_cast<Value>(x));
     }
 
     /**
@@ -487,7 +472,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         }
         else
         {
-            for (auto it = rb->begin(); it != rb->end(); ++it)
+            for (auto it = roaring_bitmap->begin(); it != roaring_bitmap->end(); ++it)
             {
                 res.emplace_back(*it);
                 ++count;
@@ -519,7 +504,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         }
         else
         {
-            for (auto it = rb->begin(); it != rb->end(); ++it)
+            for (auto it = roaring_bitmap->begin(); it != roaring_bitmap->end(); ++it)
             {
                 if (*it < range_start)
                     continue;
@@ -569,7 +554,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         else
         {
             UInt64 count = 0;
-            for (auto it = rb->begin(); it != rb->end(); ++it)
+            for (auto it = roaring_bitmap->begin(); it != roaring_bitmap->end(); ++it)
             {
                 if (*it < range_start)
                     continue;
@@ -607,11 +592,11 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             UInt64 count = 0;
             UInt64 offset_count = 0;
-            auto it = rb->begin();
-            for (;it != rb->end() && offset_count < offset; ++it)
+            auto it = roaring_bitmap->begin();
+            for (;it != roaring_bitmap->end() && offset_count < offset; ++it)
                 ++offset_count;
 
-            for (;it != rb->end() && count < limit; ++it, ++count)
+            for (;it != roaring_bitmap->end() && count < limit; ++it, ++count)
                 r1.add(*it);
             return count;
         }
@@ -633,7 +618,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
             return min_val;
         }
         else
-            return rb->minimum();
+            return roaring_bitmap->minimum();
     }
 
     UInt64 rb_max() const /// NOLINT
@@ -652,7 +637,7 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
             return max_val;
         }
         else
-            return rb->maximum();
+            return roaring_bitmap->maximum();
     }
 
     /**
@@ -668,9 +653,9 @@ class RoaringBitmapWithSmallSet : private boost::noncopyable
         {
             if (from_vals[i] == to_vals[i])
                 continue;
-            bool changed = rb->removeChecked(static_cast<Value>(from_vals[i]));
+            bool changed = roaring_bitmap->removeChecked(static_cast<Value>(from_vals[i]));
             if (changed)
-                rb->add(static_cast<Value>(to_vals[i]));
+                roaring_bitmap->add(static_cast<Value>(to_vals[i]));
         }
     }
 };
@@ -680,7 +665,7 @@ struct AggregateFunctionGroupBitmapData
 {
     // If false, all bitmap operations will be treated as merge to initialize the state
     bool init = false;
-    RoaringBitmapWithSmallSet<T, 32> rbs;
+    RoaringBitmapWithSmallSet<T, 32> roaring_bitmap_with_small_set;
     static const char * name() { return "groupBitmap"; }
 };
 
diff --git a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h
index f8e426363d84..bc7ccb082674 100644
--- a/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h
+++ b/src/AggregateFunctions/AggregateFunctionGroupUniqArray.h
@@ -181,7 +181,6 @@ class AggregateFunctionGroupUniqArrayGeneric
         auto & set = this->data(place).value;
         size_t size;
         readVarUInt(size, buf);
-        //TODO: set.reserve(size);
 
         for (size_t i = 0; i < size; ++i)
             set.insert(readStringBinaryInto(*arena, buf));
diff --git a/src/AggregateFunctions/AggregateFunctionHistogram.h b/src/AggregateFunctions/AggregateFunctionHistogram.h
index 35e5f241ec95..62ed071856a3 100644
--- a/src/AggregateFunctions/AggregateFunctionHistogram.h
+++ b/src/AggregateFunctions/AggregateFunctionHistogram.h
@@ -292,6 +292,9 @@ class AggregateFunctionHistogramData
         readVarUInt(size, buf);
         if (size > max_bins * 2)
             throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too many bins");
+        static constexpr size_t max_size = 1_GiB;
+        if (size > max_size)
+            throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size in histogram.");
 
         buf.readStrict(reinterpret_cast<char *>(points), size * sizeof(WeightedValue));
     }
diff --git a/src/AggregateFunctions/AggregateFunctionMap.h b/src/AggregateFunctions/AggregateFunctionMap.h
index 91530698bf4a..55f6611974e3 100644
--- a/src/AggregateFunctions/AggregateFunctionMap.h
+++ b/src/AggregateFunctions/AggregateFunctionMap.h
@@ -61,15 +61,11 @@ struct AggregateFunctionMapCombinatorData<String>
 
     static void writeKey(String key, WriteBuffer & buf)
     {
-        writeVarUInt(key.size(), buf);
-        writeString(key, buf);
+        writeStringBinary(key, buf);
     }
     static void readKey(String & key, ReadBuffer & buf)
     {
-        UInt64 size;
-        readVarUInt(size, buf);
-        key.resize(size);
-        buf.readStrict(key.data(), size);
+        readStringBinary(key, buf);
     }
 };
 
diff --git a/src/AggregateFunctions/AggregateFunctionSequenceNextNode.h b/src/AggregateFunctions/AggregateFunctionSequenceNextNode.h
index 76610772b22a..4fd7db4160e5 100644
--- a/src/AggregateFunctions/AggregateFunctionSequenceNextNode.h
+++ b/src/AggregateFunctions/AggregateFunctionSequenceNextNode.h
@@ -86,7 +86,7 @@ struct NodeBase
     {
         UInt64 size;
         readVarUInt(size, buf);
-        if unlikely (size > max_node_size_deserialize)
+        if (unlikely(size > max_node_size_deserialize))
             throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large node state size");
 
         Node * node = reinterpret_cast<Node *>(arena->alignedAlloc(sizeof(Node) + size, alignof(Node)));
@@ -323,6 +323,9 @@ class SequenceNextNodeImpl final
         if (unlikely(size == 0))
             return;
 
+        if (unlikely(size > max_node_size_deserialize))
+            throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size");
+
         auto & value = data(place).value;
 
         value.resize(size, arena);
diff --git a/src/AggregateFunctions/CMakeLists.txt b/src/AggregateFunctions/CMakeLists.txt
index 0cb38fc729a6..a45adde1a36a 100644
--- a/src/AggregateFunctions/CMakeLists.txt
+++ b/src/AggregateFunctions/CMakeLists.txt
@@ -28,3 +28,7 @@ target_link_libraries(clickhouse_aggregate_functions PRIVATE dbms PUBLIC ch_cont
 if(ENABLE_EXAMPLES)
     add_subdirectory(examples)
 endif()
+
+if (ENABLE_FUZZING)
+    add_subdirectory(fuzzers)
+endif()
diff --git a/src/AggregateFunctions/QuantileExact.h b/src/AggregateFunctions/QuantileExact.h
index b7af17b52bf5..c67621a99cec 100644
--- a/src/AggregateFunctions/QuantileExact.h
+++ b/src/AggregateFunctions/QuantileExact.h
@@ -8,6 +8,8 @@
 #include <base/sort.h>
 #include <base/types.h>
 
+#define QUANTILE_EXACT_MAX_ARRAY_SIZE 1'000'000'000
+
 
 namespace DB
 {
@@ -17,6 +19,7 @@ namespace ErrorCodes
 {
     extern const int NOT_IMPLEMENTED;
     extern const int BAD_ARGUMENTS;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 
 
@@ -54,6 +57,8 @@ struct QuantileExactBase
     {
         size_t size = 0;
         readVarUInt(size, buf);
+        if (unlikely(size > QUANTILE_EXACT_MAX_ARRAY_SIZE))
+            throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size");
         array.resize(size);
         buf.readStrict(reinterpret_cast<char *>(array.data()), size * sizeof(array[0]));
     }
diff --git a/src/AggregateFunctions/QuantileTiming.h b/src/AggregateFunctions/QuantileTiming.h
index 2c2e881c78f1..de6607b2527b 100644
--- a/src/AggregateFunctions/QuantileTiming.h
+++ b/src/AggregateFunctions/QuantileTiming.h
@@ -16,6 +16,7 @@ struct Settings;
 namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
+    extern const int INCORRECT_DATA;
 }
 
 /** Calculates quantile for time in milliseconds, less than 30 seconds.
@@ -34,7 +35,7 @@ namespace ErrorCodes
   * -- for values from 0 to 1023 - in increments of 1;
   * -- for values from 1024 to 30,000 - in increments of 16;
   *
-  * NOTE: 64-bit integer weight can overflow, see also QantileExactWeighted.h::get()
+  * NOTE: 64-bit integer weight can overflow, see also QuantileExactWeighted.h::get()
   */
 
 #define TINY_MAX_ELEMS 31
@@ -83,8 +84,12 @@ namespace detail
 
         void deserialize(ReadBuffer & buf)
         {
-            readBinary(count, buf);
-            buf.readStrict(reinterpret_cast<char *>(elems), count * sizeof(elems[0]));
+            UInt16 new_count = 0;
+            readBinary(new_count, buf);
+            if (new_count > TINY_MAX_ELEMS)
+                throw Exception(ErrorCodes::INCORRECT_DATA, "The number of elements {} for the 'tiny' kind of quantileTiming is exceeding the maximum of {}", new_count, TINY_MAX_ELEMS);
+            buf.readStrict(reinterpret_cast<char *>(elems), new_count * sizeof(elems[0]));
+            count = new_count;
         }
 
         /** This function must be called before get-functions. */
@@ -167,6 +172,9 @@ namespace detail
         {
             size_t size = 0;
             readBinary(size, buf);
+            if (size > 10'000)
+                throw Exception(ErrorCodes::INCORRECT_DATA, "The number of elements {} for the 'medium' kind of quantileTiming is too large", size);
+
             elems.resize(size);
             buf.readStrict(reinterpret_cast<char *>(elems.data()), size * sizeof(elems[0]));
         }
@@ -714,6 +722,8 @@ class QuantileTiming : private boost::noncopyable
             tinyToLarge();
             large->deserialize(buf);
         }
+        else
+            throw Exception(ErrorCodes::INCORRECT_DATA, "Incorrect kind of QuantileTiming");
     }
 
     /// Get the value of the `level` quantile. The level must be between 0 and 1.
diff --git a/src/AggregateFunctions/ReservoirSampler.h b/src/AggregateFunctions/ReservoirSampler.h
index b59f75b377e7..ef0e7c6566e3 100644
--- a/src/AggregateFunctions/ReservoirSampler.h
+++ b/src/AggregateFunctions/ReservoirSampler.h
@@ -24,6 +24,7 @@ struct Settings;
 namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 }
 
@@ -208,7 +209,13 @@ class ReservoirSampler
     {
         DB::readIntBinary<size_t>(sample_count, buf);
         DB::readIntBinary<size_t>(total_values, buf);
-        samples.resize(std::min(total_values, sample_count));
+
+        size_t size = std::min(total_values, sample_count);
+        static constexpr size_t MAX_RESERVOIR_SIZE = 1_GiB;
+        if (unlikely(size > MAX_RESERVOIR_SIZE))
+            throw DB::Exception(DB::ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size");
+
+        samples.resize(size);
 
         std::string rng_string;
         DB::readStringBinary(rng_string, buf);
diff --git a/src/AggregateFunctions/ReservoirSamplerDeterministic.h b/src/AggregateFunctions/ReservoirSamplerDeterministic.h
index 17e4ce0e4941..5e1d23ed2c2d 100644
--- a/src/AggregateFunctions/ReservoirSamplerDeterministic.h
+++ b/src/AggregateFunctions/ReservoirSamplerDeterministic.h
@@ -22,6 +22,7 @@ struct Settings;
 namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 }
 
@@ -163,6 +164,10 @@ class ReservoirSamplerDeterministic
         if (size > total_values)
             size = total_values;
 
+        static constexpr size_t MAX_RESERVOIR_SIZE = 1_GiB;
+        if (unlikely(size > MAX_RESERVOIR_SIZE))
+            throw DB::Exception(DB::ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size");
+
         samples.resize(size);
         for (size_t i = 0; i < size; ++i)
             DB::readPODBinary(samples[i], buf);
diff --git a/src/AggregateFunctions/fuzzers/CMakeLists.txt b/src/AggregateFunctions/fuzzers/CMakeLists.txt
new file mode 100644
index 000000000000..3876ffac7abf
--- /dev/null
+++ b/src/AggregateFunctions/fuzzers/CMakeLists.txt
@@ -0,0 +1,2 @@
+clickhouse_add_executable(aggregate_function_state_deserialization_fuzzer aggregate_function_state_deserialization_fuzzer.cpp ${SRCS})
+target_link_libraries(aggregate_function_state_deserialization_fuzzer PRIVATE dbms clickhouse_aggregate_functions ${LIB_FUZZING_ENGINE})
diff --git a/src/AggregateFunctions/fuzzers/aggregate_function_state_deserialization_fuzzer.cpp b/src/AggregateFunctions/fuzzers/aggregate_function_state_deserialization_fuzzer.cpp
new file mode 100644
index 000000000000..39f57e00c483
--- /dev/null
+++ b/src/AggregateFunctions/fuzzers/aggregate_function_state_deserialization_fuzzer.cpp
@@ -0,0 +1,82 @@
+#include <base/types.h>
+
+#include <IO/ReadBufferFromMemory.h>
+#include <IO/ReadHelpers.h>
+
+#include <DataTypes/DataTypeFactory.h>
+#include <DataTypes/DataTypeAggregateFunction.h>
+
+#include <Common/MemoryTracker.h>
+#include <Common/CurrentThread.h>
+
+#include <Interpreters/Context.h>
+
+#include <AggregateFunctions/registerAggregateFunctions.h>
+
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t * data, size_t size)
+try
+{
+    using namespace DB;
+
+    static SharedContextHolder shared_context;
+    static ContextMutablePtr context;
+
+    auto initialize = [&]() mutable
+    {
+        shared_context = Context::createShared();
+        context = Context::createGlobal(shared_context.get());
+        context->makeGlobalContext();
+        context->setApplicationType(Context::ApplicationType::LOCAL);
+
+        MainThreadStatus::getInstance();
+
+        registerAggregateFunctions();
+        return true;
+    };
+
+    static bool initialized = initialize();
+    (void) initialized;
+
+    total_memory_tracker.resetCounters();
+    total_memory_tracker.setHardLimit(1_GiB);
+    CurrentThread::get().memory_tracker.resetCounters();
+    CurrentThread::get().memory_tracker.setHardLimit(1_GiB);
+
+    /// The input format is as follows:
+    /// - the aggregate function name on the first line, possible with parameters, then data types of the arguments,
+    ///   example: quantile(0.5), Float64
+    /// - the serialized aggregation state for the rest of the input.
+
+    /// Compile the code as follows:
+    ///   mkdir build_asan_fuzz
+    ///   cd build_asan_fuzz
+    ///   CC=clang CXX=clang++ cmake -D SANITIZE=address -D ENABLE_FUZZING=1 -D WITH_COVERAGE=1 ..
+    ///
+    /// The corpus is located here:
+    /// https://github.com/ClickHouse/fuzz-corpus/tree/main/aggregate_function_state_deserialization
+    ///
+    /// The fuzzer can be run as follows:
+    ///   ../../../build_asan_fuzz/src/DataTypes/fuzzers/aggregate_function_state_deserialization corpus -jobs=64 -rss_limit_mb=8192
+
+    DB::ReadBufferFromMemory in(data, size);
+
+    String args;
+    readStringUntilNewlineInto(args, in);
+    assertChar('
', in);
+
+    DataTypePtr type = DataTypeFactory::instance().get(fmt::format("AggregateFunction({})", args));
+    AggregateFunctionPtr func = assert_cast<const DataTypeAggregateFunction &>(*type).getFunction();
+
+    Arena arena;
+    char * place = arena.alignedAlloc(func->sizeOfData(), func->alignOfData());
+    func->create(place);
+    SCOPE_EXIT(func->destroy(place));
+    func->deserialize(place, in, {}, &arena);
+
+    return 0;
+}
+catch (...)
+{
+    return 1;
+}
diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt
index 6c5142813c50..edf638c53504 100644
--- a/src/CMakeLists.txt
+++ b/src/CMakeLists.txt
@@ -75,6 +75,7 @@ add_subdirectory (Coordination)
 add_subdirectory (Bridge)
 add_subdirectory (Daemon)
 add_subdirectory (Loggers)
+add_subdirectory (Formats)
 
 
 set(dbms_headers)
diff --git a/src/Common/HashTable/HashSet.h b/src/Common/HashTable/HashSet.h
index bac858b16a54..8f3761599ab0 100644
--- a/src/Common/HashTable/HashSet.h
+++ b/src/Common/HashTable/HashSet.h
@@ -16,6 +16,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 }
 
@@ -60,6 +61,8 @@ class HashSetTable : public HashTable<Key, TCell, Hash, Grower, Allocator>
 
         size_t new_size = 0;
         DB::readVarUInt(new_size, rb);
+        if (new_size > 100'000'000'000)
+            throw DB::Exception(DB::ErrorCodes::TOO_LARGE_ARRAY_SIZE, "The size of serialized hash table is suspiciously large: {}", new_size);
 
         this->resize(new_size);
 
diff --git a/src/Common/HashTable/HashTable.h b/src/Common/HashTable/HashTable.h
index 5c348f936d28..7ddcbc20b22e 100644
--- a/src/Common/HashTable/HashTable.h
+++ b/src/Common/HashTable/HashTable.h
@@ -42,6 +42,7 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
     extern const int NO_AVAILABLE_DATA;
     extern const int CANNOT_ALLOCATE_MEMORY;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 }
 
@@ -1318,6 +1319,8 @@ class HashTable : private boost::noncopyable,
 
         size_t new_size = 0;
         DB::readVarUInt(new_size, rb);
+        if (new_size > 100'000'000'000)
+            throw DB::Exception(DB::ErrorCodes::TOO_LARGE_ARRAY_SIZE, "The size of serialized hash table is suspiciously large: {}", new_size);
 
         free();
         Grower new_grower = grower;
diff --git a/src/Common/HashTable/SmallTable.h b/src/Common/HashTable/SmallTable.h
index f6253c3f0b95..3229e4748ea7 100644
--- a/src/Common/HashTable/SmallTable.h
+++ b/src/Common/HashTable/SmallTable.h
@@ -9,6 +9,7 @@ namespace DB
     {
         extern const int NO_AVAILABLE_DATA;
         extern const int INCORRECT_DATA;
+        extern const int TOO_LARGE_ARRAY_SIZE;
     }
 }
 
@@ -279,6 +280,8 @@ class SmallTable :
 
         size_t new_size = 0;
         DB::readVarUInt(new_size, rb);
+        if (new_size > 1000'000)
+            throw DB::Exception(DB::ErrorCodes::TOO_LARGE_ARRAY_SIZE, "The size of serialized small table is suspiciously large: {}", new_size);
 
         if (new_size > capacity)
             throw DB::Exception(DB::ErrorCodes::INCORRECT_DATA, "Illegal size");
@@ -346,4 +349,3 @@ template
     size_t capacity
 >
 using SmallSet = SmallTable<Key, HashTableCell<Key, HashUnused>, capacity>;
-
diff --git a/src/Common/SpaceSaving.h b/src/Common/SpaceSaving.h
index 84494e25ca5c..476e107067b2 100644
--- a/src/Common/SpaceSaving.h
+++ b/src/Common/SpaceSaving.h
@@ -160,12 +160,11 @@ class SpaceSaving
         // Key doesn't exist, but can fit in the top K
         if (unlikely(size() < capacity()))
         {
-            auto * c = new Counter(arena.emplace(key), increment, error, hash);
-            push(c);
+            push(std::make_unique<Counter>(arena.emplace(key), increment, error, hash));
             return;
         }
 
-        auto * min = counter_list.back();
+        auto & min = counter_list.back();
         // The key doesn't exist and cannot fit in the current top K, but
         // the new key has a bigger weight and is virtually more present
         // compared to the element who is less present on the set. This part
@@ -173,7 +172,7 @@ class SpaceSaving
         if (increment > min->count)
         {
             destroyLastElement();
-            push(new Counter(arena.emplace(key), increment, error, hash));
+            push(std::make_unique<Counter>(arena.emplace(key), increment, error, hash));
             return;
         }
 
@@ -189,7 +188,7 @@ class SpaceSaving
         alpha_map[min->hash & alpha_mask] = min->count;
         destroyLastElement();
 
-        push(new Counter(arena.emplace(key), alpha + increment, alpha + error, hash));
+        push(std::make_unique<Counter>(arena.emplace(key), alpha + increment, alpha + error, hash));
     }
 
     /*
@@ -219,7 +218,7 @@ class SpaceSaving
          */
         if (m2 > 0)
         {
-            for (auto * counter : counter_list)
+            for (auto & counter : counter_list)
             {
                 counter->count += m2;
                 counter->error += m2;
@@ -227,7 +226,7 @@ class SpaceSaving
         }
 
         // The list is sorted in descending order, we have to scan in reverse
-        for (auto * counter : boost::adaptors::reverse(rhs.counter_list))
+        for (auto & counter : boost::adaptors::reverse(rhs.counter_list))
         {
             size_t hash = counter_map.hash(counter->key);
             if (auto * current = findCounter(counter->key, hash))
@@ -239,19 +238,16 @@ class SpaceSaving
             else
             {
                 // Counters not monitored in S1
-                counter_list.push_back(new Counter(arena.emplace(counter->key), counter->count + m1, counter->error + m1, hash));
+                counter_list.push_back(std::make_unique<Counter>(arena.emplace(counter->key), counter->count + m1, counter->error + m1, hash));
             }
         }
 
-        ::sort(counter_list.begin(), counter_list.end(), [](Counter * l, Counter * r) { return *l > *r; });
+        ::sort(counter_list.begin(), counter_list.end(), [](const auto & l, const auto & r) { return *l > *r; });
 
         if (counter_list.size() > m_capacity)
         {
             for (size_t i = m_capacity; i < counter_list.size(); ++i)
-            {
                 arena.free(counter_list[i]->key);
-                delete counter_list[i];
-            }
             counter_list.resize(m_capacity);
         }
 
@@ -263,7 +259,7 @@ class SpaceSaving
     std::vector<Counter> topK(size_t k) const
     {
         std::vector<Counter> res;
-        for (auto * counter : counter_list)
+        for (auto & counter : counter_list)
         {
             res.push_back(*counter);
             if (res.size() == k)
@@ -275,7 +271,7 @@ class SpaceSaving
     void write(WriteBuffer & wb) const
     {
         writeVarUInt(size(), wb);
-        for (auto * counter : counter_list)
+        for (auto & counter : counter_list)
             counter->write(wb);
 
         writeVarUInt(alpha_map.size(), wb);
@@ -291,10 +287,10 @@ class SpaceSaving
 
         for (size_t i = 0; i < count; ++i)
         {
-            auto * counter = new Counter();
+            std::unique_ptr counter = std::make_unique<Counter>();
             counter->read(rb);
             counter->hash = counter_map.hash(counter->key);
-            push(counter);
+            push(std::move(counter));
         }
 
         readAlphaMap(rb);
@@ -313,12 +309,13 @@ class SpaceSaving
     }
 
 protected:
-    void push(Counter * counter)
+    void push(std::unique_ptr<Counter> counter)
     {
         counter->slot = counter_list.size();
-        counter_list.push_back(counter);
-        counter_map[counter->key] = counter;
-        percolate(counter);
+        auto * ptr = counter.get();
+        counter_list.push_back(std::move(counter));
+        counter_map[ptr->key] = ptr;
+        percolate(ptr);
     }
 
     // This is equivallent to one step of bubble sort
@@ -326,7 +323,7 @@ class SpaceSaving
     {
         while (counter->slot > 0)
         {
-            auto * next = counter_list[counter->slot - 1];
+            auto & next = counter_list[counter->slot - 1];
             if (*counter > *next)
             {
                 std::swap(next->slot, counter->slot);
@@ -340,11 +337,8 @@ class SpaceSaving
 private:
     void destroyElements()
     {
-        for (auto * counter : counter_list)
-        {
+        for (auto & counter : counter_list)
             arena.free(counter->key);
-            delete counter;
-        }
 
         counter_map.clear();
         counter_list.clear();
@@ -353,10 +347,9 @@ class SpaceSaving
 
     void destroyLastElement()
     {
-        auto last_element = counter_list.back();
+        auto & last_element = counter_list.back();
         counter_map.erase(last_element->key);
         arena.free(last_element->key);
-        delete last_element;
         counter_list.pop_back();
 
         ++removed_keys;
@@ -377,14 +370,14 @@ class SpaceSaving
     {
         removed_keys = 0;
         counter_map.clear();
-        for (auto * counter : counter_list)
-            counter_map[counter->key] = counter;
+        for (auto & counter : counter_list)
+            counter_map[counter->key] = counter.get();
     }
 
     using CounterMap = HashMapWithStackMemory<TKey, Counter *, Hash, 4>;
 
     CounterMap counter_map;
-    std::vector<Counter *, AllocatorWithMemoryTracking<Counter *>> counter_list;
+    std::vector<std::unique_ptr<Counter>, AllocatorWithMemoryTracking<std::unique_ptr<Counter>>> counter_list;
     std::vector<UInt64, AllocatorWithMemoryTracking<UInt64>> alpha_map;
     SpaceSavingArena<TKey> arena;
     size_t m_capacity;
diff --git a/src/Common/ThreadStatus.cpp b/src/Common/ThreadStatus.cpp
index 11f35bc7a6ba..aa1690890d8c 100644
--- a/src/Common/ThreadStatus.cpp
+++ b/src/Common/ThreadStatus.cpp
@@ -6,8 +6,6 @@
 #include <Interpreters/Context.h>
 
 #include <Poco/Logger.h>
-#include <base/getThreadId.h>
-#include <base/getPageSize.h>
 
 #include <csignal>
 #include <sys/mman.h>
diff --git a/src/Core/ColumnWithTypeAndName.h b/src/Core/ColumnWithTypeAndName.h
index 592ad39d55ac..15807066e62d 100644
--- a/src/Core/ColumnWithTypeAndName.h
+++ b/src/Core/ColumnWithTypeAndName.h
@@ -14,8 +14,6 @@ class WriteBuffer;
   * Column data could be nullptr - to represent just 'header' of column.
   * Name could be either name from a table or some temporary generated name during expression evaluation.
   */
-#pragma GCC diagnostic push
-#pragma GCC diagnostic ignored "-Wnull-dereference"
 struct ColumnWithTypeAndName
 {
     ColumnPtr column;
@@ -37,6 +35,5 @@ struct ColumnWithTypeAndName
     void dumpStructure(WriteBuffer & out) const;
     String dumpStructure() const;
 };
-#pragma GCC diagnostic pop
 
 }
diff --git a/src/Core/NamesAndTypes.h b/src/Core/NamesAndTypes.h
index 78535a751c3f..6cada7c8a694 100644
--- a/src/Core/NamesAndTypes.h
+++ b/src/Core/NamesAndTypes.h
@@ -83,7 +83,6 @@ class NamesAndTypesList : public std::list<NameAndTypePair>
     template <typename Iterator>
     NamesAndTypesList(Iterator begin, Iterator end) : std::list<NameAndTypePair>(begin, end) {}
 
-
     void readText(ReadBuffer & buf);
     void writeText(WriteBuffer & buf) const;
 
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 755e52adb06c..3770d7f73a0e 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -844,6 +844,7 @@ class IColumn;
     /** This setting is obsolete and do nothing, left for compatibility reasons. */ \
     M(Bool, input_format_avro_null_as_default, false, "For Avro/AvroConfluent format: insert default in case of null and non Nullable column", 0) \
     M(UInt64, format_binary_max_string_size, 1_GiB, "The maximum allowed size for String in RowBinary format. It prevents allocating large amount of memory in case of corrupted data. 0 means there is no limit", 0) \
+    M(UInt64, format_binary_max_array_size, 1_GiB, "The maximum allowed size for Array in RowBinary format. It prevents allocating large amount of memory in case of corrupted data. 0 means there is no limit", 0) \
     M(URI, format_avro_schema_registry_url, "", "For AvroConfluent format: Confluent Schema Registry URL.", 0) \
     \
     M(Bool, output_format_json_quote_64bit_integers, true, "Controls quoting of 64-bit integers in JSON output format.", 0) \
diff --git a/src/DataTypes/CMakeLists.txt b/src/DataTypes/CMakeLists.txt
index 4a60d6c54cff..2902ef0a9557 100644
--- a/src/DataTypes/CMakeLists.txt
+++ b/src/DataTypes/CMakeLists.txt
@@ -3,3 +3,7 @@ add_subdirectory (Serializations)
 if (ENABLE_EXAMPLES)
     add_subdirectory (examples)
 endif ()
+
+if (ENABLE_FUZZING)
+    add_subdirectory(fuzzers)
+endif()
diff --git a/src/DataTypes/DataTypeFactory.cpp b/src/DataTypes/DataTypeFactory.cpp
index 93db16541883..415f24d8151f 100644
--- a/src/DataTypes/DataTypeFactory.cpp
+++ b/src/DataTypes/DataTypeFactory.cpp
@@ -217,10 +217,12 @@ void DataTypeFactory::registerDataTypeCustom(const String & family_name, Creator
     }, case_sensitiveness);
 }
 
-void DataTypeFactory::registerSimpleDataTypeCustom(const String &name, SimpleCreatorWithCustom creator, CaseSensitiveness case_sensitiveness)
+void DataTypeFactory::registerSimpleDataTypeCustom(const String & name, SimpleCreatorWithCustom creator, CaseSensitiveness case_sensitiveness)
 {
-    registerDataTypeCustom(name, [creator](const ASTPtr & /*ast*/)
+    registerDataTypeCustom(name, [name, creator](const ASTPtr & ast)
     {
+        if (ast)
+            throw Exception(ErrorCodes::DATA_TYPE_CANNOT_HAVE_ARGUMENTS, "Data type {} cannot have arguments", name);
         return creator();
     }, case_sensitiveness);
 }
diff --git a/src/DataTypes/Serializations/SerializationArray.cpp b/src/DataTypes/Serializations/SerializationArray.cpp
index 73b232690c7e..5ed85cd1d1a4 100644
--- a/src/DataTypes/Serializations/SerializationArray.cpp
+++ b/src/DataTypes/Serializations/SerializationArray.cpp
@@ -43,6 +43,14 @@ void SerializationArray::deserializeBinary(Field & field, ReadBuffer & istr, con
 {
     size_t size;
     readVarUInt(size, istr);
+    if (settings.max_binary_array_size && size > settings.max_binary_array_size)
+        throw Exception(
+            ErrorCodes::TOO_LARGE_ARRAY_SIZE,
+            "Too large array size: {}. The maximum is: {}. To increase the maximum, use setting "
+            "format_binary_max_array_size",
+            size,
+            settings.max_binary_array_size);
+
     field = Array();
     Array & arr = field.get<Array &>();
     arr.reserve(size);
@@ -75,6 +83,13 @@ void SerializationArray::deserializeBinary(IColumn & column, ReadBuffer & istr,
 
     size_t size;
     readVarUInt(size, istr);
+    if (settings.max_binary_array_size && size > settings.max_binary_array_size)
+        throw Exception(
+            ErrorCodes::TOO_LARGE_ARRAY_SIZE,
+            "Too large array size: {}. The maximum is: {}. To increase the maximum, use setting "
+            "format_binary_max_array_size",
+            size,
+            settings.max_binary_array_size);
 
     IColumn & nested_column = column_array.getData();
 
diff --git a/src/DataTypes/Serializations/SerializationMap.cpp b/src/DataTypes/Serializations/SerializationMap.cpp
index 34da0f11cae6..a176d4c07197 100644
--- a/src/DataTypes/Serializations/SerializationMap.cpp
+++ b/src/DataTypes/Serializations/SerializationMap.cpp
@@ -20,6 +20,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int CANNOT_READ_MAP_FROM_TEXT;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 
 SerializationMap::SerializationMap(const SerializationPtr & key_, const SerializationPtr & value_, const SerializationPtr & nested_)
@@ -54,6 +55,13 @@ void SerializationMap::deserializeBinary(Field & field, ReadBuffer & istr, const
 {
     size_t size;
     readVarUInt(size, istr);
+    if (settings.max_binary_array_size && size > settings.max_binary_array_size)
+        throw Exception(
+            ErrorCodes::TOO_LARGE_ARRAY_SIZE,
+            "Too large map size: {}. The maximum is: {}. To increase the maximum, use setting "
+            "format_binary_max_array_size",
+            size,
+            settings.max_binary_array_size);
     field = Map();
     Map & map = field.get<Map &>();
     map.reserve(size);
diff --git a/src/DataTypes/Serializations/SerializationString.cpp b/src/DataTypes/Serializations/SerializationString.cpp
index 96608fbbc041..46fd9d5272d2 100644
--- a/src/DataTypes/Serializations/SerializationString.cpp
+++ b/src/DataTypes/Serializations/SerializationString.cpp
@@ -14,6 +14,8 @@
 #include <IO/VarInt.h>
 #include <IO/ReadBufferFromString.h>
 
+#include <base/unit.h>
+
 #ifdef __SSE2__
     #include <emmintrin.h>
 #endif
@@ -158,6 +160,14 @@ static NO_INLINE void deserializeBinarySSE2(ColumnString::Chars & data, ColumnSt
         UInt64 size;
         readVarUInt(size, istr);
 
+        static constexpr size_t max_string_size = 16_GiB;   /// Arbitrary value to prevent logical errors and overflows, but large enough.
+        if (size > max_string_size)
+            throw Exception(
+                ErrorCodes::TOO_LARGE_STRING_SIZE,
+                "Too large string size: {}. The maximum is: {}.",
+                size,
+                max_string_size);
+
         offset += size + 1;
         offsets.push_back(offset);
 
diff --git a/src/DataTypes/fuzzers/CMakeLists.txt b/src/DataTypes/fuzzers/CMakeLists.txt
new file mode 100644
index 000000000000..d9c19cb7d012
--- /dev/null
+++ b/src/DataTypes/fuzzers/CMakeLists.txt
@@ -0,0 +1,2 @@
+clickhouse_add_executable(data_type_deserialization_fuzzer data_type_deserialization_fuzzer.cpp ${SRCS})
+target_link_libraries(data_type_deserialization_fuzzer PRIVATE dbms clickhouse_aggregate_functions ${LIB_FUZZING_ENGINE})
diff --git a/src/DataTypes/fuzzers/data_type_deserialization_fuzzer.cpp b/src/DataTypes/fuzzers/data_type_deserialization_fuzzer.cpp
new file mode 100644
index 000000000000..31e4c470ee7e
--- /dev/null
+++ b/src/DataTypes/fuzzers/data_type_deserialization_fuzzer.cpp
@@ -0,0 +1,82 @@
+#include <base/types.h>
+
+#include <IO/ReadBufferFromMemory.h>
+#include <IO/ReadHelpers.h>
+
+#include <DataTypes/DataTypeFactory.h>
+
+#include <Common/MemoryTracker.h>
+#include <Common/CurrentThread.h>
+
+#include <Interpreters/Context.h>
+
+#include <AggregateFunctions/registerAggregateFunctions.h>
+
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t * data, size_t size)
+try
+{
+    using namespace DB;
+
+    static SharedContextHolder shared_context;
+    static ContextMutablePtr context;
+
+    auto initialize = [&]() mutable
+    {
+        shared_context = Context::createShared();
+        context = Context::createGlobal(shared_context.get());
+        context->makeGlobalContext();
+        context->setApplicationType(Context::ApplicationType::LOCAL);
+
+        MainThreadStatus::getInstance();
+
+        registerAggregateFunctions();
+        return true;
+    };
+
+    static bool initialized = initialize();
+    (void) initialized;
+
+    total_memory_tracker.resetCounters();
+    total_memory_tracker.setHardLimit(1_GiB);
+    CurrentThread::get().memory_tracker.resetCounters();
+    CurrentThread::get().memory_tracker.setHardLimit(1_GiB);
+
+    /// The input format is as follows:
+    /// - data type name on the first line,
+    /// - the data for the rest of the input.
+
+    /// Compile the code as follows:
+    ///   mkdir build_asan_fuzz
+    ///   cd build_asan_fuzz
+    ///   CC=clang CXX=clang++ cmake -D SANITIZE=address -D ENABLE_FUZZING=1 -D WITH_COVERAGE=1 ..
+    ///
+    /// The corpus is located here:
+    /// https://github.com/ClickHouse/fuzz-corpus/tree/main/data_type_deserialization
+    ///
+    /// The fuzzer can be run as follows:
+    ///   ../../../build_asan_fuzz/src/DataTypes/fuzzers/data_type_deserialization_fuzzer corpus -jobs=64 -rss_limit_mb=8192
+
+    /// clickhouse-local --query "SELECT toJSONString(*) FROM (SELECT name FROM system.functions UNION ALL SELECT name FROM system.data_type_families)" > dictionary
+
+    DB::ReadBufferFromMemory in(data, size);
+
+    String data_type;
+    readStringUntilNewlineInto(data_type, in);
+    assertChar('
', in);
+
+    DataTypePtr type = DataTypeFactory::instance().get(data_type);
+
+    FormatSettings settings;
+    settings.max_binary_string_size = 100;
+    settings.max_binary_array_size = 100;
+
+    Field field;
+    type->getDefaultSerialization()->deserializeBinary(field, in, settings);
+
+    return 0;
+}
+catch (...)
+{
+    return 1;
+}
diff --git a/src/Formats/CMakeLists.txt b/src/Formats/CMakeLists.txt
new file mode 100644
index 000000000000..316043093c06
--- /dev/null
+++ b/src/Formats/CMakeLists.txt
@@ -0,0 +1,3 @@
+if (ENABLE_FUZZING)
+    add_subdirectory(fuzzers)
+endif()
diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp
index a951a7fdd928..c6d85a5d84f2 100644
--- a/src/Formats/FormatFactory.cpp
+++ b/src/Formats/FormatFactory.cpp
@@ -194,6 +194,7 @@ FormatSettings getFormatSettings(ContextPtr context, const Settings & settings)
     format_settings.bson.output_string_as_string = settings.output_format_bson_string_as_string;
     format_settings.bson.skip_fields_with_unsupported_types_in_schema_inference = settings.input_format_bson_skip_fields_with_unsupported_types_in_schema_inference;
     format_settings.max_binary_string_size = settings.format_binary_max_string_size;
+    format_settings.max_binary_array_size = settings.format_binary_max_array_size;
     format_settings.native.allow_types_conversion = settings.input_format_native_allow_types_conversion;
     format_settings.max_parser_depth = context->getSettingsRef().max_parser_depth;
     format_settings.client_protocol_version = context->getClientProtocolVersion();
@@ -226,9 +227,7 @@ InputFormatPtr FormatFactory::getInput(
         ? *_format_settings : getFormatSettings(context);
 
     if (!getCreators(name).input_creator)
-    {
         throw Exception(ErrorCodes::FORMAT_IS_NOT_SUITABLE_FOR_INPUT, "Format {} is not suitable for input", name);
-    }
 
     const Settings & settings = context->getSettingsRef();
     const auto & file_segmentation_engine = getCreators(name).file_segmentation_engine;
@@ -270,21 +269,19 @@ InputFormatPtr FormatFactory::getInput(
         ParallelParsingInputFormat::Params params{
             buf, sample, parser_creator, file_segmentation_engine, name, settings.max_threads,
             settings.min_chunk_bytes_for_parallel_parsing, max_block_size, context->getApplicationType() == Context::ApplicationType::SERVER};
+
         auto format = std::make_shared<ParallelParsingInputFormat>(params);
         if (!settings.input_format_record_errors_file_path.toString().empty())
-        {
             format->setErrorsLogger(std::make_shared<ParallelInputFormatErrorsLogger>(context));
-        }
         return format;
     }
-
-
-    auto format = getInputFormat(name, buf, sample, context, max_block_size, format_settings);
-    if (!settings.input_format_record_errors_file_path.toString().empty())
+    else
     {
-        format->setErrorsLogger(std::make_shared<InputFormatErrorsLogger>(context));
+        auto format = getInputFormat(name, buf, sample, context, max_block_size, format_settings);
+        if (!settings.input_format_record_errors_file_path.toString().empty())
+             format->setErrorsLogger(std::make_shared<InputFormatErrorsLogger>(context));
+        return format;
     }
-    return format;
 }
 
 InputFormatPtr FormatFactory::getInputFormat(
diff --git a/src/Formats/FormatFactory.h b/src/Formats/FormatFactory.h
index 398548e4b220..6697a22984c4 100644
--- a/src/Formats/FormatFactory.h
+++ b/src/Formats/FormatFactory.h
@@ -15,6 +15,7 @@
 #include <memory>
 #include <unordered_map>
 
+
 namespace DB
 {
 
diff --git a/src/Formats/FormatSettings.h b/src/Formats/FormatSettings.h
index 7be7b5b98aa9..053b461244b2 100644
--- a/src/Formats/FormatSettings.h
+++ b/src/Formats/FormatSettings.h
@@ -3,6 +3,7 @@
 #include <Core/Names.h>
 #include <Core/Defines.h>
 #include <base/types.h>
+#include <base/unit.h>
 
 
 namespace DB
@@ -81,7 +82,8 @@ struct FormatSettings
     UInt64 input_allow_errors_num = 0;
     Float32 input_allow_errors_ratio = 0;
 
-    UInt64 max_binary_string_size = 0;
+    UInt64 max_binary_string_size = 1_GiB;
+    UInt64 max_binary_array_size = 1_GiB;
     UInt64 client_protocol_version = 0;
 
     UInt64 max_parser_depth = DBMS_DEFAULT_MAX_PARSER_DEPTH;
diff --git a/src/Formats/NativeReader.cpp b/src/Formats/NativeReader.cpp
index eca88a41c132..ff75ffb3c027 100644
--- a/src/Formats/NativeReader.cpp
+++ b/src/Formats/NativeReader.cpp
@@ -27,6 +27,7 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
     extern const int CANNOT_READ_ALL_DATA;
     extern const int INCORRECT_DATA;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 
 
@@ -136,6 +137,11 @@ Block NativeReader::read()
     {
         readVarUInt(columns, istr);
         readVarUInt(rows, istr);
+
+        if (columns > 1'000'000uz)
+            throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Suspiciously many columns in Native format: {}", columns);
+        if (rows > 1'000'000'000'000uz)
+            throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Suspiciously many rows in Native format: {}", rows);
     }
     else
     {
diff --git a/src/Formats/fuzzers/CMakeLists.txt b/src/Formats/fuzzers/CMakeLists.txt
new file mode 100644
index 000000000000..984823f33601
--- /dev/null
+++ b/src/Formats/fuzzers/CMakeLists.txt
@@ -0,0 +1,2 @@
+clickhouse_add_executable(format_fuzzer format_fuzzer.cpp ${SRCS})
+target_link_libraries(format_fuzzer PRIVATE dbms clickhouse_aggregate_functions ${LIB_FUZZING_ENGINE})
diff --git a/src/Formats/fuzzers/format_fuzzer.cpp b/src/Formats/fuzzers/format_fuzzer.cpp
new file mode 100644
index 000000000000..e84d0913d0da
--- /dev/null
+++ b/src/Formats/fuzzers/format_fuzzer.cpp
@@ -0,0 +1,133 @@
+#include <base/types.h>
+
+#include <IO/ReadBufferFromMemory.h>
+#include <IO/ReadHelpers.h>
+
+#include <Formats/FormatFactory.h>
+#include <Formats/registerFormats.h>
+
+#include <QueryPipeline/Pipe.h>
+#include <QueryPipeline/QueryPipeline.h>
+
+#include <Processors/Formats/IInputFormat.h>
+#include <Processors/Executors/PullingPipelineExecutor.h>
+
+#include <Common/MemoryTracker.h>
+#include <Common/CurrentThread.h>
+
+#include <Interpreters/Context.h>
+#include <Interpreters/parseColumnsListForTableFunction.h>
+
+#include <AggregateFunctions/registerAggregateFunctions.h>
+
+
+extern "C" int LLVMFuzzerTestOneInput(const uint8_t * data, size_t size)
+try
+{
+    using namespace DB;
+
+    static SharedContextHolder shared_context;
+    static ContextMutablePtr context;
+
+    auto initialize = [&]() mutable
+    {
+        shared_context = Context::createShared();
+        context = Context::createGlobal(shared_context.get());
+        context->makeGlobalContext();
+        context->setApplicationType(Context::ApplicationType::LOCAL);
+
+        MainThreadStatus::getInstance();
+
+        registerAggregateFunctions();
+        registerFormats();
+
+        return true;
+    };
+
+    static bool initialized = initialize();
+    (void) initialized;
+
+    total_memory_tracker.resetCounters();
+    total_memory_tracker.setHardLimit(1_GiB);
+    CurrentThread::get().memory_tracker.resetCounters();
+    CurrentThread::get().memory_tracker.setHardLimit(1_GiB);
+
+    /// The input format is as follows:
+    /// - format name on the first line,
+    /// - table structure on the second line,
+    /// - the data for the rest of the input.
+
+    /** The corpus was generated as follows:
+
+    i=0; find ../../../../tests/queries -name '*.sql' |
+        xargs -I{} bash -c "tr '
' ' ' <{}; echo" |
+        rg -o -i 'CREATE TABLE\s+\w+\s+\(.+?\) ENGINE' |
+        sed -r -e 's/CREATE TABLE\s+\w+\s+\((.+?)\) ENGINE/\1/i' | sort | uniq |
+        while read line; do
+            i=$((i+1));
+            clickhouse-local --query "SELECT name FROM system.formats ORDER BY rand() LIMIT 1" >> $i;
+            echo "$line" >> $i;
+            echo $RANDOM >> $i;
+            echo $i;
+        done
+    */
+
+    /** And:
+
+    for format in $(clickhouse-client --query "SELECT name FROM system.formats WHERE is_output"); do
+        echo $format;
+        echo $format >> $format;
+        echo "WatchID Int64, JavaEnable Int16, Title String, GoodEvent Int16, EventTime DateTime, EventDate Date, CounterID Int32, ClientIP Int32, RegionID Int32, UserID Int64, CounterClass Int16, OS Int16, UserAgent Int16, URL String, Referer String, IsRefresh Int16, RefererCategoryID Int16, RefererRegionID Int32, URLCategoryID Int16, URLRegionID Int32, ResolutionWidth Int16, ResolutionHeight Int16, ResolutionDepth Int16, FlashMajor Int16, FlashMinor Int16, FlashMinor2 String, NetMajor Int16, NetMinor Int16, UserAgentMajor Int16, UserAgentMinor String, CookieEnable Int16, JavascriptEnable Int16, IsMobile Int16, MobilePhone Int16, MobilePhoneModel String, Params String, IPNetworkID Int32, TraficSourceID Int16, SearchEngineID Int16, SearchPhrase String, AdvEngineID Int16, IsArtifical Int16, WindowClientWidth Int16, WindowClientHeight Int16, ClientTimeZone Int16, ClientEventTime DateTime, SilverlightVersion1 Int16, SilverlightVersion2 Int16, SilverlightVersion3 Int32, SilverlightVersion4 Int16, PageCharset String, CodeVersion Int32, IsLink Int16, IsDownload Int16, IsNotBounce Int16, FUniqID Int64, OriginalURL String, HID Int32, IsOldCounter Int16, IsEvent Int16, IsParameter Int16, DontCountHits Int16, WithHash Int16, HitColor String, LocalEventTime DateTime, Age Int16, Sex Int16, Income Int16, Interests Int16, Robotness Int16, RemoteIP Int32, WindowName Int32, OpenerName Int32, HistoryLength Int16, BrowserLanguage String, BrowserCountry String, SocialNetwork String, SocialAction String, HTTPError Int16, SendTiming Int32, DNSTiming Int32, ConnectTiming Int32, ResponseStartTiming Int32, ResponseEndTiming Int32, FetchTiming Int32, SocialSourceNetworkID Int16, SocialSourcePage String, ParamPrice Int64, ParamOrderID String, ParamCurrency String, ParamCurrencyID Int16, OpenstatServiceName String, OpenstatCampaignID String, OpenstatAdID String, OpenstatSourceID String, UTMSource String, UTMMedium String, UTMCampaign String, UTMContent String, UTMTerm String, FromTag String, HasGCLID Int16, RefererHash Int64, URLHash Int64, CLID Int32" >> $format;
+        clickhouse-client --query "SELECT * FROM hits LIMIT 10 FORMAT $format" >> $format || rm $format;
+    done
+
+    */
+
+    /// Compile the code as follows:
+    ///   mkdir build_asan_fuzz
+    ///   cd build_asan_fuzz
+    ///   CC=clang CXX=clang++ cmake -D SANITIZE=address -D ENABLE_FUZZING=1 -D WITH_COVERAGE=1 ..
+    ///
+    /// The corpus is located here:
+    /// https://github.com/ClickHouse/fuzz-corpus/tree/main/format_fuzzer
+    ///
+    /// The fuzzer can be run as follows:
+    ///   ../../../build_asan_fuzz/src/Formats/fuzzers/format_fuzzer corpus -jobs=64 -rss_limit_mb=8192
+
+    DB::ReadBufferFromMemory in(data, size);
+
+    String format;
+    readStringUntilNewlineInto(format, in);
+    assertChar('
', in);
+
+    String structure;
+    readStringUntilNewlineInto(structure, in);
+    assertChar('
', in);
+
+    ColumnsDescription description = parseColumnsListFromString(structure, context);
+    auto columns_info = description.getOrdinary();
+
+    Block header;
+    for (const auto & info : columns_info)
+    {
+        ColumnWithTypeAndName column;
+        column.name = info.name;
+        column.type = info.type;
+        column.column = column.type->createColumn();
+        header.insert(std::move(column));
+    }
+
+    InputFormatPtr input_format = context->getInputFormat(format, in, header, 13 /* small block size */);
+
+    QueryPipeline pipeline(Pipe(std::move(input_format)));
+    PullingPipelineExecutor executor(pipeline);
+    Block res;
+    while (executor.pull(res))
+        ;
+
+    return 0;
+}
+catch (...)
+{
+    return 1;
+}
diff --git a/src/Functions/FunctionsBitmap.h b/src/Functions/FunctionsBitmap.h
index 29ab0abed87c..2292b896952f 100644
--- a/src/Functions/FunctionsBitmap.h
+++ b/src/Functions/FunctionsBitmap.h
@@ -211,7 +211,7 @@ class FunctionBitmapBuildImpl : public IFunction
                 = *reinterpret_cast<AggregateFunctionGroupBitmapData<T> *>(col_to->getData()[i]);
             for (; pos < offsets[i]; ++pos)
             {
-                bitmap_data.rbs.add(input_data[pos]);
+                bitmap_data.roaring_bitmap_with_small_set.add(input_data[pos]);
             }
         }
         return col_to;
@@ -303,7 +303,7 @@ class FunctionBitmapToArrayImpl : public IFunction
         {
             const AggregateFunctionGroupBitmapData<T> & bitmap_data_1
                 = *reinterpret_cast<const AggregateFunctionGroupBitmapData<T> *>(column->getData()[i]);
-            UInt64 count = bitmap_data_1.rbs.rb_to_array(res_data);
+            UInt64 count = bitmap_data_1.roaring_bitmap_with_small_set.rb_to_array(res_data);
             res_offset += count;
             res_offsets.emplace_back(res_offset);
         }
@@ -449,7 +449,7 @@ struct BitmapSubsetInRangeImpl
         UInt64 range_end,
         AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        bitmap_data_0.rbs.rb_range(range_start, range_end, bitmap_data_2.rbs);
+        bitmap_data_0.roaring_bitmap_with_small_set.rb_range(range_start, range_end, bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -464,7 +464,7 @@ struct BitmapSubsetLimitImpl
         UInt64 range_end,
         AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        bitmap_data_0.rbs.rb_limit(range_start, range_end, bitmap_data_2.rbs);
+        bitmap_data_0.roaring_bitmap_with_small_set.rb_limit(range_start, range_end, bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -479,7 +479,7 @@ struct BitmapSubsetOffsetLimitImpl
         UInt64 range_end,
         AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
         {
-        bitmap_data_0.rbs.rb_offset_limit(range_start, range_end, bitmap_data_2.rbs);
+        bitmap_data_0.roaring_bitmap_with_small_set.rb_offset_limit(range_start, range_end, bitmap_data_2.roaring_bitmap_with_small_set);
         }
 };
 
@@ -649,8 +649,8 @@ class FunctionBitmapTransform : public IFunction
             col_to->insertDefault();
             AggregateFunctionGroupBitmapData<T> & bitmap_data_2
                 = *reinterpret_cast<AggregateFunctionGroupBitmapData<T> *>(col_to->getData()[i]);
-            bitmap_data_2.rbs.merge(bitmap_data_0.rbs);
-            bitmap_data_2.rbs.rb_replace(&from_container[from_start], &to_container[to_start], from_end - from_start);
+            bitmap_data_2.roaring_bitmap_with_small_set.merge(bitmap_data_0.roaring_bitmap_with_small_set);
+            bitmap_data_2.roaring_bitmap_with_small_set.rb_replace(&from_container[from_start], &to_container[to_start], from_end - from_start);
         }
         return col_to;
     }
@@ -740,7 +740,7 @@ struct BitmapCardinalityImpl
     template <typename T>
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data)
     {
-        return bitmap_data.rbs.size();
+        return bitmap_data.roaring_bitmap_with_small_set.size();
     }
 };
 
@@ -751,7 +751,7 @@ struct BitmapMinImpl
     template <typename T>
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data)
     {
-        return bitmap_data.rbs.rb_min();
+        return bitmap_data.roaring_bitmap_with_small_set.rb_min();
     }
 };
 
@@ -762,7 +762,7 @@ struct BitmapMaxImpl
     template <typename T>
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data)
     {
-        return bitmap_data.rbs.rb_max();
+        return bitmap_data.roaring_bitmap_with_small_set.rb_max();
     }
 };
 
@@ -773,7 +773,7 @@ struct BitmapAndCardinalityImpl
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
         // roaring_bitmap_and_cardinality( rb1, rb2 );
-        return bitmap_data_1.rbs.rb_and_cardinality(bitmap_data_2.rbs);
+        return bitmap_data_1.roaring_bitmap_with_small_set.rb_and_cardinality(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -785,7 +785,7 @@ struct BitmapOrCardinalityImpl
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
         // return roaring_bitmap_or_cardinality( rb1, rb2 );
-        return bitmap_data_1.rbs.rb_or_cardinality(bitmap_data_2.rbs);
+        return bitmap_data_1.roaring_bitmap_with_small_set.rb_or_cardinality(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -796,7 +796,7 @@ struct BitmapXorCardinalityImpl
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
         // return roaring_bitmap_xor_cardinality( rb1, rb2 );
-        return bitmap_data_1.rbs.rb_xor_cardinality(bitmap_data_2.rbs);
+        return bitmap_data_1.roaring_bitmap_with_small_set.rb_xor_cardinality(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -807,7 +807,7 @@ struct BitmapAndnotCardinalityImpl
     static UInt64 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
         // roaring_bitmap_andnot_cardinality( rb1, rb2 );
-        return bitmap_data_1.rbs.rb_andnot_cardinality(bitmap_data_2.rbs);
+        return bitmap_data_1.roaring_bitmap_with_small_set.rb_andnot_cardinality(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -817,7 +817,7 @@ struct BitmapHasAllImpl
     using ReturnType = UInt8;
     static UInt8 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        return bitmap_data_1.rbs.rb_is_subset(bitmap_data_2.rbs);
+        return bitmap_data_1.roaring_bitmap_with_small_set.rb_is_subset(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -827,7 +827,7 @@ struct BitmapHasAnyImpl
     using ReturnType = UInt8;
     static UInt8 apply(const AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        return bitmap_data_1.rbs.rb_intersect(bitmap_data_2.rbs);
+        return bitmap_data_1.roaring_bitmap_with_small_set.rb_intersect(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -931,7 +931,7 @@ class FunctionBitmapContains : public IFunction
             const UInt64 data1 = is_column_const[1] ? (*container1)[0] : (*container1)[i];
             const AggregateFunctionGroupBitmapData<T> & bitmap_data_0
                 = *reinterpret_cast<const AggregateFunctionGroupBitmapData<T> *>(data_ptr_0);
-            vec_to[i] = bitmap_data_0.rbs.rb_contains(data1);
+            vec_to[i] = bitmap_data_0.roaring_bitmap_with_small_set.rb_contains(data1);
         }
     }
 };
@@ -1050,7 +1050,7 @@ struct BitmapAndImpl
 {
     static void apply(AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        bitmap_data_1.rbs.rb_and(bitmap_data_2.rbs);
+        bitmap_data_1.roaring_bitmap_with_small_set.rb_and(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -1059,7 +1059,7 @@ struct BitmapOrImpl
 {
     static void apply(AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        bitmap_data_1.rbs.rb_or(bitmap_data_2.rbs);
+        bitmap_data_1.roaring_bitmap_with_small_set.rb_or(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -1068,7 +1068,7 @@ struct BitmapXorImpl
 {
     static void apply(AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        bitmap_data_1.rbs.rb_xor(bitmap_data_2.rbs);
+        bitmap_data_1.roaring_bitmap_with_small_set.rb_xor(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -1077,7 +1077,7 @@ struct BitmapAndnotImpl
 {
     static void apply(AggregateFunctionGroupBitmapData<T> & bitmap_data_1, const AggregateFunctionGroupBitmapData<T> & bitmap_data_2)
     {
-        bitmap_data_1.rbs.rb_andnot(bitmap_data_2.rbs);
+        bitmap_data_1.roaring_bitmap_with_small_set.rb_andnot(bitmap_data_2.roaring_bitmap_with_small_set);
     }
 };
 
@@ -1190,7 +1190,7 @@ class FunctionBitmap : public IFunction
             auto * bm_2 = reinterpret_cast<AggregateFunctionGroupBitmapData<T> *>(data_ptr_1);
 
             // check the name of operation (bitmapAnd) and check if it is the situation mentioned above
-            auto need_exchange = (name == NameBitmapAnd::name) && bm_1->rbs.isLarge() && bm_2->rbs.isSmall();
+            auto need_exchange = (name == NameBitmapAnd::name) && bm_1->roaring_bitmap_with_small_set.isLarge() && bm_2->roaring_bitmap_with_small_set.isSmall();
             col_to->insertFrom(need_exchange ? data_ptr_1 : data_ptr_0);
             AggregateFunctionGroupBitmapData<T> & bitmap_data_1 = *reinterpret_cast<AggregateFunctionGroupBitmapData<T> *>(col_to->getData()[i]);
             const AggregateFunctionGroupBitmapData<T> & bitmap_data_2
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index f8931a7f6221..cac42c198b13 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -61,6 +61,8 @@ namespace ErrorCodes
     extern const int CANNOT_READ_ARRAY_FROM_TEXT;
     extern const int CANNOT_PARSE_NUMBER;
     extern const int INCORRECT_DATA;
+    extern const int TOO_LARGE_STRING_SIZE;
+    extern const int TOO_LARGE_ARRAY_SIZE;
 }
 
 /// Helper functions for formatted input.
@@ -128,13 +130,13 @@ inline void readFloatBinary(T & x, ReadBuffer & buf)
     readPODBinary(x, buf);
 }
 
-inline void readStringBinary(std::string & s, ReadBuffer & buf, size_t MAX_STRING_SIZE = DEFAULT_MAX_STRING_SIZE)
+inline void readStringBinary(std::string & s, ReadBuffer & buf, size_t max_string_size = DEFAULT_MAX_STRING_SIZE)
 {
     size_t size = 0;
     readVarUInt(size, buf);
 
-    if (size > MAX_STRING_SIZE)
-        throw Poco::Exception("Too large string size.");
+    if (size > max_string_size)
+        throw Exception(ErrorCodes::TOO_LARGE_STRING_SIZE, "Too large string size.");
 
     s.resize(size);
     buf.readStrict(s.data(), size);
@@ -146,6 +148,9 @@ inline StringRef readStringBinaryInto(Arena & arena, ReadBuffer & buf)
     size_t size = 0;
     readVarUInt(size, buf);
 
+    if (unlikely(size > DEFAULT_MAX_STRING_SIZE))
+        throw Exception(ErrorCodes::TOO_LARGE_STRING_SIZE, "Too large string size.");
+
     char * data = arena.alloc(size);
     buf.readStrict(data, size);
 
@@ -154,13 +159,13 @@ inline StringRef readStringBinaryInto(Arena & arena, ReadBuffer & buf)
 
 
 template <typename T>
-void readVectorBinary(std::vector<T> & v, ReadBuffer & buf, size_t MAX_VECTOR_SIZE = DEFAULT_MAX_STRING_SIZE)
+void readVectorBinary(std::vector<T> & v, ReadBuffer & buf)
 {
     size_t size = 0;
     readVarUInt(size, buf);
 
-    if (size > MAX_VECTOR_SIZE)
-        throw Poco::Exception("Too large vector size.");
+    if (size > DEFAULT_MAX_STRING_SIZE)
+        throw Exception(ErrorCodes::TOO_LARGE_ARRAY_SIZE, "Too large array size.");
 
     v.resize(size);
     for (size_t i = 0; i < size; ++i)
diff --git a/src/Interpreters/fuzzers/execute_query_fuzzer.cpp b/src/Interpreters/fuzzers/execute_query_fuzzer.cpp
index 30db25668cf2..284e780ed1fa 100644
--- a/src/Interpreters/fuzzers/execute_query_fuzzer.cpp
+++ b/src/Interpreters/fuzzers/execute_query_fuzzer.cpp
@@ -1,4 +1,3 @@
-#include <iostream>
 #include <Interpreters/executeQuery.h>
 #include <Interpreters/Context.h>
 #include "Processors/Executors/PullingPipelineExecutor.h"
diff --git a/src/Interpreters/parseColumnsListForTableFunction.h b/src/Interpreters/parseColumnsListForTableFunction.h
index 212c378d3b5e..14119ab55da5 100644
--- a/src/Interpreters/parseColumnsListForTableFunction.h
+++ b/src/Interpreters/parseColumnsListForTableFunction.h
@@ -31,7 +31,7 @@ struct DataTypeValidationSettings
 void validateDataType(const DataTypePtr & type, const DataTypeValidationSettings & settings);
 
 /// Parses a common argument for table functions such as table structure given in string
-ColumnsDescription parseColumnsListFromString(const std::string & structure, const ContextPtr & context);
+[[nodiscard]] ColumnsDescription parseColumnsListFromString(const std::string & structure, const ContextPtr & context);
 
 bool tryParseColumnsListFromString(const std::string & structure, ColumnsDescription & columns, const ContextPtr & context, String & error);
 
diff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h
index ef87988aab2f..2489b1080041 100644
--- a/src/Parsers/ParserCreateQuery.h
+++ b/src/Parsers/ParserCreateQuery.h
@@ -265,6 +265,10 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
         }
     }
 
+    /// This will rule out unusual expressions like *, t.* that cannot appear in DEFAULT
+    if (default_expression && !dynamic_cast<const ASTWithAlias *>(default_expression.get()))
+        return false;
+
     if (require_type && !type && !default_expression)
         return false; /// reject column name without type
 
diff --git a/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp b/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp
index ebc612a4ce31..9e3a4a85c9a1 100644
--- a/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp
+++ b/src/Processors/Formats/Impl/BSONEachRowRowInputFormat.cpp
@@ -282,6 +282,8 @@ static void readAndInsertString(ReadBuffer & in, IColumn & column, BSONType bson
     if (bson_type == BSONType::STRING || bson_type == BSONType::SYMBOL || bson_type == BSONType::JAVA_SCRIPT_CODE)
     {
         auto size = readBSONSize(in);
+        if (size == 0)
+            throw Exception(ErrorCodes::INCORRECT_DATA, "Incorrect size of a string (zero) in BSON");
         readAndInsertStringImpl<is_fixed_string>(in, column, size - 1);
         assertChar(0, in);
     }
@@ -1008,7 +1010,7 @@ fileSegmentationEngineBSONEachRow(ReadBuffer & in, DB::Memory<> & memory, size_t
 
         size_t old_size = memory.size();
         memory.resize(old_size + document_size);
-        memcpy(memory.data() + old_size, reinterpret_cast<char *>(&document_size), sizeof(document_size));
+        unalignedStore<BSONSizeT>(memory.data() + old_size, document_size);
         in.readStrict(memory.data() + old_size + sizeof(document_size), document_size - sizeof(document_size));
         ++number_of_rows;
     }
diff --git a/src/Storages/MergeTree/RangesInDataPart.cpp b/src/Storages/MergeTree/RangesInDataPart.cpp
index 29a236c98652..ab76611a5073 100644
--- a/src/Storages/MergeTree/RangesInDataPart.cpp
+++ b/src/Storages/MergeTree/RangesInDataPart.cpp
@@ -11,6 +11,12 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int TOO_LARGE_ARRAY_SIZE;
+}
+
+
 void RangesInDataPartDescription::serialize(WriteBuffer & out) const
 {
     info.serialize(out);
@@ -50,6 +56,8 @@ void RangesInDataPartsDescription::deserialize(ReadBuffer & in)
 {
     size_t new_size = 0;
     readVarUInt(new_size, in);
+    if (new_size > 100'000'000'000)
+        throw DB::Exception(DB::ErrorCodes::TOO_LARGE_ARRAY_SIZE, "The size of serialized hash table is suspiciously large: {}", new_size);
 
     this->resize(new_size);
     for (auto & desc : *this)
