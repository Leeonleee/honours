{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 59243,
  "instance_id": "ClickHouse__ClickHouse-59243",
  "issue_numbers": [
    "56414"
  ],
  "base_commit": "4c57400664ba85d78d53868635c7cad735e49521",
  "patch": "diff --git a/base/base/Decimal_fwd.h b/base/base/Decimal_fwd.h\nindex 589d62249174..beb228cea3c6 100644\n--- a/base/base/Decimal_fwd.h\n+++ b/base/base/Decimal_fwd.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <base/types.h>\n+#include <base/extended_types.h>\n \n namespace wide\n {\n@@ -44,3 +45,8 @@ concept is_over_big_int =\n     || std::is_same_v<T, Decimal128>\n     || std::is_same_v<T, Decimal256>;\n }\n+\n+template <> struct is_signed<DB::Decimal32> { static constexpr bool value = true; };\n+template <> struct is_signed<DB::Decimal64> { static constexpr bool value = true; };\n+template <> struct is_signed<DB::Decimal128> { static constexpr bool value = true; };\n+template <> struct is_signed<DB::Decimal256> { static constexpr bool value = true; };\ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex 1b2519d1ec58..d253095ca014 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -147,11 +147,32 @@ struct BinaryOperationTraits\n public:\n     static constexpr bool allow_decimal = IsOperation<Operation>::allow_decimal;\n \n+    using DecimalResultDataType = Switch<\n+        Case<!allow_decimal, InvalidType>,\n+        Case<IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType> && UseLeftDecimal<LeftDataType, RightDataType>, LeftDataType>,\n+        Case<IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType>, RightDataType>,\n+        Case<IsDataTypeDecimal<LeftDataType> && IsIntegralOrExtended<RightDataType>, LeftDataType>,\n+        Case<IsDataTypeDecimal<RightDataType> && IsIntegralOrExtended<LeftDataType>, RightDataType>,\n+\n+        /// e.g Decimal +-*/ Float, least(Decimal, Float), greatest(Decimal, Float) = Float64\n+        Case<IsDataTypeDecimal<LeftDataType> && IsFloatingPoint<RightDataType>, DataTypeFloat64>,\n+        Case<IsDataTypeDecimal<RightDataType> && IsFloatingPoint<LeftDataType>, DataTypeFloat64>,\n+\n+        Case<IsOperation<Operation>::bit_hamming_distance && IsIntegral<LeftDataType> && IsIntegral<RightDataType>, DataTypeUInt8>,\n+        Case<IsOperation<Operation>::bit_hamming_distance && IsFixedString<LeftDataType> && IsFixedString<RightDataType>, DataTypeUInt16>,\n+        Case<IsOperation<Operation>::bit_hamming_distance && IsString<LeftDataType> && IsString<RightDataType>, DataTypeUInt64>,\n+\n+          /// Decimal <op> Real is not supported (traditional DBs convert Decimal <op> Real to Real)\n+        Case<IsDataTypeDecimal<LeftDataType> && !IsIntegralOrExtendedOrDecimal<RightDataType>, InvalidType>,\n+        Case<IsDataTypeDecimal<RightDataType> && !IsIntegralOrExtendedOrDecimal<LeftDataType>, InvalidType>>;\n+\n     /// Appropriate result type for binary operator on numeric types. \"Date\" can also mean\n     /// DateTime, but if both operands are Dates, their type must be the same (e.g. Date - DateTime is invalid).\n     using ResultDataType = Switch<\n+        /// Result must be Integer\n+        Case<IsOperation<Operation>::div_int || IsOperation<Operation>::div_int_or_zero, DataTypeFromFieldType<typename Op::ResultType>>,\n         /// Decimal cases\n-        Case<!allow_decimal && (IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>), InvalidType>,\n+        Case<IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>, DecimalResultDataType>,\n         Case<\n             IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType> && UseLeftDecimal<LeftDataType, RightDataType>,\n             LeftDataType>,\n@@ -622,7 +643,11 @@ struct DecimalBinaryOperation\n             if constexpr (op_case == OpCase::RightConstant)\n             {\n                 if ((*right_nullmap)[0])\n+                {\n+                    for (size_t i = 0; i < size; ++i)\n+                        c[i] = ResultType();\n                     return;\n+                }\n \n                 for (size_t i = 0; i < size; ++i)\n                     c[i] = apply_func(undec(a[i]), undec(b));\n@@ -1665,7 +1690,9 @@ class FunctionBinaryArithmetic : public IFunction\n \n                 if constexpr (!std::is_same_v<ResultDataType, InvalidType>)\n                 {\n-                    if constexpr (IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType>)\n+                    if constexpr (is_div_int || is_div_int_or_zero)\n+                        type_res = std::make_shared<ResultDataType>();\n+                    else if constexpr (IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType>)\n                     {\n                         if constexpr (is_division)\n                         {\n@@ -1685,13 +1712,19 @@ class FunctionBinaryArithmetic : public IFunction\n                         ResultDataType result_type = decimalResultType<is_multiply, is_division>(left, right);\n                         type_res = std::make_shared<ResultDataType>(result_type.getPrecision(), result_type.getScale());\n                     }\n-                    else if constexpr ((IsDataTypeDecimal<LeftDataType> && IsFloatingPoint<RightDataType>) ||\n-                        (IsDataTypeDecimal<RightDataType> && IsFloatingPoint<LeftDataType>))\n+                    else if constexpr (((IsDataTypeDecimal<LeftDataType> && IsFloatingPoint<RightDataType>) ||\n+                        (IsDataTypeDecimal<RightDataType> && IsFloatingPoint<LeftDataType>)))\n+                    {\n                         type_res = std::make_shared<DataTypeFloat64>();\n+                    }\n                     else if constexpr (IsDataTypeDecimal<LeftDataType>)\n+                    {\n                         type_res = std::make_shared<LeftDataType>(left.getPrecision(), left.getScale());\n+                    }\n                     else if constexpr (IsDataTypeDecimal<RightDataType>)\n+                    {\n                         type_res = std::make_shared<RightDataType>(right.getPrecision(), right.getScale());\n+                    }\n                     else if constexpr (std::is_same_v<ResultDataType, DataTypeDateTime>)\n                     {\n                         // Special case for DateTime: binary OPS should reuse timezone\n@@ -2000,6 +2033,7 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n         using LeftDataType = std::decay_t<decltype(left)>;\n         using RightDataType = std::decay_t<decltype(right)>;\n         using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;\n+        using DecimalResultType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::DecimalResultDataType;\n \n         if constexpr (std::is_same_v<ResultDataType, InvalidType>)\n             return nullptr;\n@@ -2051,6 +2085,35 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n                     col_left_size,\n                     right_nullmap);\n             }\n+            /// Here we check if we have `intDiv` or `intDivOrZero` and at least one of the arguments is decimal, because in this case originally we had result as decimal, so we need to convert result into integer after calculations\n+            else if constexpr (!decimal_with_float && (is_div_int || is_div_int_or_zero) && (IsDataTypeDecimal<LeftDataType> || IsDataTypeDecimal<RightDataType>))\n+            {\n+\n+                if constexpr (!std::is_same_v<DecimalResultType, InvalidType>)\n+                {\n+                    DataTypePtr type_res;\n+                    if constexpr (IsDataTypeDecimal<LeftDataType> && IsDataTypeDecimal<RightDataType>)\n+                    {\n+                        DecimalResultType result_type = decimalResultType<is_multiply, is_division>(left, right);\n+                        type_res = std::make_shared<DecimalResultType>(result_type.getPrecision(), result_type.getScale());\n+                    }\n+                    else if constexpr (IsDataTypeDecimal<LeftDataType>)\n+                        type_res = std::make_shared<LeftDataType>(left.getPrecision(), left.getScale());\n+                    else\n+                        type_res = std::make_shared<RightDataType>(right.getPrecision(), right.getScale());\n+\n+                    auto res = executeNumericWithDecimal<LeftDataType, RightDataType, DecimalResultType>(\n+                            left, right,\n+                            col_left_const, col_right_const,\n+                            col_left, col_right,\n+                            col_left_size,\n+                            right_nullmap);\n+\n+                    auto col = ColumnWithTypeAndName(res, type_res, name);\n+                    return castColumn(col, std::make_shared<ResultDataType>());\n+                }\n+                return nullptr;\n+            }\n             else // can't avoid else and another indentation level, otherwise the compiler would try to instantiate\n                  // ColVecResult for Decimals which would lead to a compile error.\n             {\ndiff --git a/src/Functions/IsOperation.h b/src/Functions/IsOperation.h\nindex 8ea53c865ced..b2c7a27d3752 100644\n--- a/src/Functions/IsOperation.h\n+++ b/src/Functions/IsOperation.h\n@@ -61,7 +61,7 @@ struct IsOperation\n     static constexpr bool bit_hamming_distance = IsSameOperation<Op, BitHammingDistanceImpl>::value;\n \n     static constexpr bool division = div_floating || div_int || div_int_or_zero || modulo;\n-\n+    // NOTE: allow_decimal should not fully contain `division` because of divInt\n     static constexpr bool allow_decimal = plus || minus || multiply || division || least || greatest;\n };\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00700_decimal_arithm.reference b/tests/queries/0_stateless/00700_decimal_arithm.reference\nindex 811946c87e06..109c0632fb1f 100644\n--- a/tests/queries/0_stateless/00700_decimal_arithm.reference\n+++ b/tests/queries/0_stateless/00700_decimal_arithm.reference\n@@ -10,18 +10,18 @@\n 63\t21\t-42\t882\t-882\t2\t0\t2\t0\n 63\t21\t-42\t882\t-882\t2\t0\t2\t0\n 1.00305798474369219219752355409390731264\t-0.16305798474369219219752355409390731264\t1.490591730234615865843651857942052864\t-1.38847100762815390390123822295304634368\t1.38847100762815390390123822295304634368\t0.02\t0.005\n-63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.505\t2.02\t0.505\n-63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.505\t2.02\t0.505\n-63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.505\t2.02\t0.505\n-63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.5\t2.02\t0.5\n+63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.505\t2\t0\n+63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.505\t2\t0\n+63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.505\t2\t0\n+63.42\t21.42\t-41.58\t890.82\t-890.82\t2.02\t0.5\t2\t0\n 63\t-21\t42\t882\t-882\t0\t2\t0\t2\n 63\t-21\t42\t882\t-882\t0\t2\t0\t2\n 63\t-21\t42\t882\t-882\t0\t2\t0\t2\n 1.00305798474369219219752355409390731264\t0.16305798474369219219752355409390731264\t-1.490591730234615865843651857942052864\t-1.38847100762815390390123822295304634368\t1.38847100762815390390123822295304634368\t-0.00000000000000000000000000000000000001\t0.00000000000000000000000000000000000001\n-63.42\t-21.42\t41.58\t890.82\t-890.82\t0.495\t1.98\t0.495\t1.98\n+63.42\t-21.42\t41.58\t890.82\t-890.82\t0.495\t1.98\t0\t1\n 63.42\t-21.42\t41.58\t890.82\t-890.82\n-63.42\t-21.42\t41.58\t890.82\t-890.82\t0.495049504950495049\t1.980198019801980198\t0.495049504950495049\t1.980198019801980198\n-63.42\t-21.42\t41.58\t890.82\t-890.82\t0.49\t1.98\t0.49\t1.98\n+63.42\t-21.42\t41.58\t890.82\t-890.82\t0.495049504950495049\t1.980198019801980198\t0\t1\n+63.42\t-21.42\t41.58\t890.82\t-890.82\t0.49\t1.98\t0\t1\n -42\t42\t42\t42\t0.42\t0.42\t0.42\t42.42\t42.42\t42.42\n 0\t0\t0\t0\t0\t0\t0\t0\t0\t0\n 42\t-42\t-42\t-42\t-0.42\t-0.42\t-0.42\t-42.42\t-42.42\t-42.42\ndiff --git a/tests/queries/0_stateless/01717_int_div_float_too_large_ubsan.sql b/tests/queries/0_stateless/01717_int_div_float_too_large_ubsan.sql\nindex c4f26a079f09..dc1e5b370506 100644\n--- a/tests/queries/0_stateless/01717_int_div_float_too_large_ubsan.sql\n+++ b/tests/queries/0_stateless/01717_int_div_float_too_large_ubsan.sql\n@@ -1,2 +1,2 @@\n-SELECT intDiv(9223372036854775807, 0.9998999834060669); -- { serverError 153 }\n-SELECT intDiv(9223372036854775807, 1.);  -- { serverError 153 }\n+SELECT intDiv(18446744073709551615, 0.9998999834060669); -- { serverError 153 }\n+SELECT intDiv(18446744073709551615, 1.);  -- { serverError 153 }\ndiff --git a/tests/queries/0_stateless/02975_intdiv_with_decimal.reference b/tests/queries/0_stateless/02975_intdiv_with_decimal.reference\nnew file mode 100644\nindex 000000000000..5540734ae4ca\n--- /dev/null\n+++ b/tests/queries/0_stateless/02975_intdiv_with_decimal.reference\n@@ -0,0 +1,68 @@\n+2\n+2\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+1\n+2\n+1\n+2\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+1\n+1\n+1\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+1\n+2\n+1\n+2\n+1\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+1\n+1\n+1\n+1\n+2\n+2\n+2\n+2\ndiff --git a/tests/queries/0_stateless/02975_intdiv_with_decimal.sql b/tests/queries/0_stateless/02975_intdiv_with_decimal.sql\nnew file mode 100644\nindex 000000000000..0911a4812515\n--- /dev/null\n+++ b/tests/queries/0_stateless/02975_intdiv_with_decimal.sql\n@@ -0,0 +1,70 @@\n+--intDiv--\n+SELECT intDiv(4,2);\n+SELECT intDiv(toDecimal32(4.4, 2), 2);\n+SELECT intDiv(4, toDecimal32(2.2, 2));\n+SELECT intDiv(toDecimal32(4.4, 2), 2);\n+SELECT intDiv(toDecimal32(4.4, 2), toDecimal32(2.2, 2));\n+SELECT intDiv(toDecimal64(4.4, 3), 2);\n+SELECT intDiv(toDecimal64(4.4, 3), toDecimal32(2.2, 2));\n+SELECT intDiv(toDecimal128(4.4, 4), 2);\n+SELECT intDiv(toDecimal128(4.4, 4), toDecimal32(2.2, 2));\n+SELECT intDiv(toDecimal256(4.4, 5), 2);\n+SELECT intDiv(toDecimal256(4.4, 5), toDecimal32(2.2, 2));\n+SELECT intDiv(4, toDecimal64(2.2, 2));\n+SELECT intDiv(toDecimal32(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDiv(4, toDecimal128(2.2, 3));\n+SELECT intDiv(toDecimal32(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDiv(4, toDecimal256(2.2, 4));\n+SELECT intDiv(toDecimal32(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDiv(toDecimal64(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDiv(toDecimal128(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDiv(toDecimal256(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDiv(toDecimal64(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDiv(toDecimal128(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDiv(toDecimal256(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDiv(toDecimal64(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDiv(toDecimal128(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDiv(toDecimal256(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDiv(4.2, toDecimal32(2.2, 2));\n+SELECT intDiv(4.2, toDecimal64(2.2, 2));\n+SELECT intDiv(4.2, toDecimal128(2.2, 2));\n+SELECT intDiv(4.2, toDecimal256(2.2, 2));\n+SELECT intDiv(toDecimal32(4.4, 2), 2.2);\n+SELECT intDiv(toDecimal64(4.4, 2), 2.2);\n+SELECT intDiv(toDecimal128(4.4, 2), 2.2);\n+SELECT intDiv(toDecimal256(4.4, 2), 2.2);\n+--intDivOrZero--\n+SELECT intDivOrZero(4,2);\n+SELECT intDivOrZero(toDecimal32(4.4, 2), 2);\n+SELECT intDivOrZero(4, toDecimal32(2.2, 2));\n+SELECT intDivOrZero(toDecimal32(4.4, 2), 2);\n+SELECT intDivOrZero(toDecimal32(4.4, 2), toDecimal32(2.2, 2));\n+SELECT intDivOrZero(toDecimal64(4.4, 3), 2);\n+SELECT intDivOrZero(toDecimal64(4.4, 3), toDecimal32(2.2, 2));\n+SELECT intDivOrZero(toDecimal128(4.4, 4), 2);\n+SELECT intDivOrZero(toDecimal128(4.4, 4), toDecimal32(2.2, 2));\n+SELECT intDivOrZero(toDecimal256(4.4, 5), 2);\n+SELECT intDivOrZero(toDecimal256(4.4, 5), toDecimal32(2.2, 2));\n+SELECT intDivOrZero(4, toDecimal64(2.2, 2));\n+SELECT intDivOrZero(toDecimal32(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDivOrZero(4, toDecimal128(2.2, 3));\n+SELECT intDivOrZero(toDecimal32(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDivOrZero(4, toDecimal256(2.2, 4));\n+SELECT intDivOrZero(toDecimal32(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDivOrZero(toDecimal64(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDivOrZero(toDecimal128(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDivOrZero(toDecimal256(4.4, 2), toDecimal64(2.2, 2));\n+SELECT intDivOrZero(toDecimal64(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDivOrZero(toDecimal128(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDivOrZero(toDecimal256(4.4, 2), toDecimal128(2.2, 2));\n+SELECT intDivOrZero(toDecimal64(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDivOrZero(toDecimal128(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDivOrZero(toDecimal256(4.4, 2), toDecimal256(2.2, 2));\n+SELECT intDivOrZero(4.2, toDecimal32(2.2, 2));\n+SELECT intDivOrZero(4.2, toDecimal64(2.2, 2));\n+SELECT intDivOrZero(4.2, toDecimal128(2.2, 2));\n+SELECT intDivOrZero(4.2, toDecimal256(2.2, 2));\n+SELECT intDivOrZero(toDecimal32(4.4, 2), 2.2);\n+SELECT intDivOrZero(toDecimal64(4.4, 2), 2.2);\n+SELECT intDivOrZero(toDecimal128(4.4, 2), 2.2);\n+SELECT intDivOrZero(toDecimal256(4.4, 2), 2.2);\n",
  "problem_statement": "why intDivOrZero result is  decimal\nSELECT\r\ntoDecimal32(161.73,4) sumRevenue,\r\n6962 sumInstall,\r\nif(sumInstall >0,intDivOrZero(sumRevenue,sumInstall) ,0) eachOfferRevenue \r\n![image](https://github.com/ClickHouse/ClickHouse/assets/49109001/df67b12b-5ea8-4568-abe1-6319f7603a4a)\r\n\n",
  "hints_text": "",
  "created_at": "2024-01-25T22:42:39Z",
  "modified_files": [
    "base/base/Decimal_fwd.h",
    "src/Functions/FunctionBinaryArithmetic.h",
    "src/Functions/IsOperation.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00700_decimal_arithm.reference",
    "tests/queries/0_stateless/01717_int_div_float_too_large_ubsan.sql",
    "b/tests/queries/0_stateless/02975_intdiv_with_decimal.reference",
    "b/tests/queries/0_stateless/02975_intdiv_with_decimal.sql"
  ]
}