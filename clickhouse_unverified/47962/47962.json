{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47962,
  "instance_id": "ClickHouse__ClickHouse-47962",
  "issue_numbers": [
    "47730"
  ],
  "base_commit": "1b1fdeddd2503526c0a74d6b7d5ef48d192f7541",
  "patch": "diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex 3b27561450b8..d62c9af366c9 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -32,6 +32,7 @@\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n \n #include <TableFunctions/TableFunctionFactory.h>\n+#include <Formats/FormatFactory.h>\n \n #include <Databases/IDatabase.h>\n \n@@ -75,6 +76,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/QueryTreeBuilder.h>\n #include <Analyzer/IQueryTreeNode.h>\n+#include <Analyzer/Identifier.h>\n \n namespace ProfileEvents\n {\n@@ -112,6 +114,8 @@ namespace ErrorCodes\n     extern const int ALIAS_REQUIRED;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int UNKNOWN_TABLE;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int NUMBER_OF_COLUMNS_DOESNT_MATCH;\n }\n \n /** Query analyzer implementation overview. Please check documentation in QueryAnalysisPass.h before.\n@@ -6079,6 +6083,18 @@ void QueryAnalyzer::initializeTableExpressionData(const QueryTreeNodePtr & table\n     scope.table_expression_node_to_data.emplace(table_expression_node, std::move(table_expression_data));\n }\n \n+bool findIdentifier(const FunctionNode & function)\n+{\n+    for (const auto & argument : function.getArguments())\n+    {\n+        if (argument->as<IdentifierNode>())\n+            return true;\n+        if (const auto * f = argument->as<FunctionNode>(); f && findIdentifier(*f))\n+            return true;\n+    }\n+    return false;\n+}\n+\n /// Resolve table function node in scope\n void QueryAnalyzer::resolveTableFunction(QueryTreeNodePtr & table_function_node,\n     IdentifierResolveScope & scope,\n@@ -6090,12 +6106,11 @@ void QueryAnalyzer::resolveTableFunction(QueryTreeNodePtr & table_function_node,\n     if (!nested_table_function)\n         expressions_visitor.visit(table_function_node_typed.getArgumentsNode());\n \n-    const auto & table_function_factory = TableFunctionFactory::instance();\n     const auto & table_function_name = table_function_node_typed.getTableFunctionName();\n \n     auto & scope_context = scope.context;\n \n-    TableFunctionPtr table_function_ptr = table_function_factory.tryGet(table_function_name, scope_context);\n+    TableFunctionPtr table_function_ptr = TableFunctionFactory::instance().tryGet(table_function_name, scope_context);\n     if (!table_function_ptr)\n     {\n         auto hints = TableFunctionFactory::instance().getHints(table_function_name);\n@@ -6110,17 +6125,131 @@ void QueryAnalyzer::resolveTableFunction(QueryTreeNodePtr & table_function_node,\n                 table_function_name);\n     }\n \n+    uint64_t use_structure_from_insertion_table_in_table_functions = scope_context->getSettingsRef().use_structure_from_insertion_table_in_table_functions;\n     if (!nested_table_function &&\n-        scope_context->getSettingsRef().use_structure_from_insertion_table_in_table_functions &&\n+        use_structure_from_insertion_table_in_table_functions &&\n         scope_context->hasInsertionTable() &&\n         table_function_ptr->needStructureHint())\n     {\n         const auto & insertion_table = scope_context->getInsertionTable();\n         if (!insertion_table.empty())\n         {\n-            auto insertion_table_storage = DatabaseCatalog::instance().getTable(insertion_table, scope_context);\n-            const auto & structure_hint = insertion_table_storage->getInMemoryMetadataPtr()->columns;\n-            table_function_ptr->setStructureHint(structure_hint);\n+            const auto & insert_structure = DatabaseCatalog::instance().getTable(insertion_table, scope_context)->getInMemoryMetadataPtr()->getColumns();\n+            DB::ColumnsDescription structure_hint;\n+\n+            bool use_columns_from_insert_query = true;\n+\n+            /// Insert table matches columns against SELECT expression by position, so we want to map\n+            /// insert table columns to table function columns through names from SELECT expression.\n+\n+            auto insert_column = insert_structure.begin();\n+            auto insert_structure_end = insert_structure.end();  /// end iterator of the range covered by possible asterisk\n+            auto virtual_column_names = table_function_ptr->getVirtualsToCheckBeforeUsingStructureHint();\n+            bool asterisk = false;\n+            const auto & expression_list = scope.scope_node->as<QueryNode &>().getProjection();\n+            auto expression = expression_list.begin();\n+\n+            /// We want to go through SELECT expression list and correspond each expression to column in insert table\n+            /// which type will be used as a hint for the file structure inference.\n+            for (; expression != expression_list.end() && insert_column != insert_structure_end; ++expression)\n+            {\n+                if (auto * identifier_node = (*expression)->as<IdentifierNode>())\n+                {\n+\n+                    if (!virtual_column_names.contains(identifier_node->getIdentifier().getFullName()))\n+                    {\n+                        if (asterisk)\n+                        {\n+                            if (use_structure_from_insertion_table_in_table_functions == 1)\n+                                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Asterisk cannot be mixed with column list in INSERT SELECT query.\");\n+\n+                            use_columns_from_insert_query = false;\n+                            break;\n+                        }\n+\n+                        structure_hint.add({ identifier_node->getIdentifier().getFullName(), insert_column->type });\n+                    }\n+\n+                    /// Once we hit asterisk we want to find end of the range covered by asterisk\n+                    /// contributing every further SELECT expression to the tail of insert structure\n+                    if (asterisk)\n+                        --insert_structure_end;\n+                    else\n+                        ++insert_column;\n+                }\n+                else if (auto * matcher_node = (*expression)->as<MatcherNode>(); matcher_node && matcher_node->getMatcherType() == MatcherNodeType::ASTERISK)\n+                {\n+                    if (asterisk)\n+                    {\n+                        if (use_structure_from_insertion_table_in_table_functions == 1)\n+                            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Only one asterisk can be used in INSERT SELECT query.\");\n+\n+                        use_columns_from_insert_query = false;\n+                        break;\n+                    }\n+                    if (!structure_hint.empty())\n+                    {\n+                        if (use_structure_from_insertion_table_in_table_functions == 1)\n+                            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Asterisk cannot be mixed with column list in INSERT SELECT query.\");\n+\n+                        use_columns_from_insert_query = false;\n+                        break;\n+                    }\n+\n+                    asterisk = true;\n+                }\n+                else if (auto * function = (*expression)->as<FunctionNode>())\n+                {\n+                    if (use_structure_from_insertion_table_in_table_functions == 2 && findIdentifier(*function))\n+                    {\n+                        use_columns_from_insert_query = false;\n+                        break;\n+                    }\n+\n+                    /// Once we hit asterisk we want to find end of the range covered by asterisk\n+                    /// contributing every further SELECT expression to the tail of insert structure\n+                    if (asterisk)\n+                        --insert_structure_end;\n+                    else\n+                        ++insert_column;\n+                }\n+                else\n+                {\n+                    /// Once we hit asterisk we want to find end of the range covered by asterisk\n+                    /// contributing every further SELECT expression to the tail of insert structure\n+                    if (asterisk)\n+                        --insert_structure_end;\n+                    else\n+                        ++insert_column;\n+                }\n+            }\n+\n+            if (use_structure_from_insertion_table_in_table_functions == 2 && !asterisk)\n+            {\n+                /// For input function we should check if input format supports reading subset of columns.\n+                if (table_function_ptr->getName() == \"input\")\n+                    use_columns_from_insert_query = FormatFactory::instance().checkIfFormatSupportsSubsetOfColumns(scope.context->getInsertFormat());\n+                else\n+                    use_columns_from_insert_query = table_function_ptr->supportsReadingSubsetOfColumns();\n+            }\n+\n+            if (use_columns_from_insert_query)\n+            {\n+                if (expression == expression_list.end())\n+                {\n+                    /// Append tail of insert structure to the hint\n+                    if (asterisk)\n+                    {\n+                        for (; insert_column != insert_structure_end; ++insert_column)\n+                            structure_hint.add({ insert_column->name, insert_column->type });\n+                    }\n+\n+                    if (!structure_hint.empty())\n+                        table_function_ptr->setStructureHint(structure_hint);\n+\n+                } else if (use_structure_from_insertion_table_in_table_functions == 1)\n+                    throw Exception(ErrorCodes::NUMBER_OF_COLUMNS_DOESNT_MATCH, \"Number of columns in insert table less than required by SELECT expression.\");\n+            }\n         }\n     }\n \ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 96354443b1fb..8af09217b633 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -172,6 +172,8 @@ namespace ErrorCodes\n     extern const int UNKNOWN_READ_METHOD;\n     extern const int NOT_IMPLEMENTED;\n     extern const int UNKNOWN_FUNCTION;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int NUMBER_OF_COLUMNS_DOESNT_MATCH;\n }\n \n \n@@ -1395,6 +1397,22 @@ void Context::addQueryFactoriesInfo(QueryLogFactories factory_type, const String\n     }\n }\n \n+static bool findIdentifier(const ASTFunction * function)\n+{\n+    if (!function || !function->arguments)\n+        return false;\n+    if (const auto * arguments = function->arguments->as<ASTExpressionList>())\n+    {\n+        for (const auto & argument : arguments->children)\n+        {\n+            if (argument->as<ASTIdentifier>())\n+                return true;\n+            if (const auto * f = argument->as<ASTFunction>(); f && findIdentifier(f))\n+                return true;\n+        }\n+    }\n+    return false;\n+}\n \n StoragePtr Context::executeTableFunction(const ASTPtr & table_expression, const ASTSelectQuery * select_query_hint)\n {\n@@ -1441,62 +1459,125 @@ StoragePtr Context::executeTableFunction(const ASTPtr & table_expression, const\n             }\n             throw;\n         }\n-        if (getSettingsRef().use_structure_from_insertion_table_in_table_functions && table_function_ptr->needStructureHint() && hasInsertionTable())\n+\n+        uint64_t use_structure_from_insertion_table_in_table_functions = getSettingsRef().use_structure_from_insertion_table_in_table_functions;\n+        if (use_structure_from_insertion_table_in_table_functions && table_function_ptr->needStructureHint() && hasInsertionTable())\n         {\n-            const auto & structure_hint = DatabaseCatalog::instance().getTable(getInsertionTable(), shared_from_this())->getInMemoryMetadataPtr()->getColumns();\n+            const auto & insert_structure = DatabaseCatalog::instance().getTable(getInsertionTable(), shared_from_this())->getInMemoryMetadataPtr()->getColumns();\n+            DB::ColumnsDescription structure_hint;\n+\n             bool use_columns_from_insert_query = true;\n \n-            /// use_structure_from_insertion_table_in_table_functions=2 means `auto`\n-            if (select_query_hint && getSettingsRef().use_structure_from_insertion_table_in_table_functions == 2)\n+            /// Insert table matches columns against SELECT expression by position, so we want to map\n+            /// insert table columns to table function columns through names from SELECT expression.\n+\n+            auto insert_column = insert_structure.begin();\n+            auto insert_structure_end = insert_structure.end();  /// end iterator of the range covered by possible asterisk\n+            auto virtual_column_names = table_function_ptr->getVirtualsToCheckBeforeUsingStructureHint();\n+            bool asterisk = false;\n+            const auto & expression_list = select_query_hint->select()->as<ASTExpressionList>()->children;\n+            const auto * expression = expression_list.begin();\n+\n+            /// We want to go through SELECT expression list and correspond each expression to column in insert table\n+            /// which type will be used as a hint for the file structure inference.\n+            for (; expression != expression_list.end() && insert_column != insert_structure_end; ++expression)\n             {\n-                const auto * expression_list = select_query_hint->select()->as<ASTExpressionList>();\n-                std::unordered_set<String> virtual_column_names = table_function_ptr->getVirtualsToCheckBeforeUsingStructureHint();\n-                Names columns_names;\n-                bool have_asterisk = false;\n-                /// First, check if we have only identifiers, asterisk and literals in select expression,\n-                /// and if no, we cannot use the structure from insertion table.\n-                for (const auto & expression : expression_list->children)\n+                if (auto * identifier = (*expression)->as<ASTIdentifier>())\n                 {\n-                    if (auto * identifier = expression->as<ASTIdentifier>())\n+                    if (!virtual_column_names.contains(identifier->name()))\n                     {\n-                        columns_names.push_back(identifier->name());\n+                        if (asterisk)\n+                        {\n+                            if (use_structure_from_insertion_table_in_table_functions == 1)\n+                                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Asterisk cannot be mixed with column list in INSERT SELECT query.\");\n+\n+                            use_columns_from_insert_query = false;\n+                            break;\n+                        }\n+\n+                        structure_hint.add({ identifier->name(), insert_column->type });\n                     }\n-                    else if (expression->as<ASTAsterisk>())\n+\n+                    /// Once we hit asterisk we want to find end of the range covered by asterisk\n+                    /// contributing every further SELECT expression to the tail of insert structure\n+                    if (asterisk)\n+                        --insert_structure_end;\n+                    else\n+                        ++insert_column;\n+                }\n+                else if ((*expression)->as<ASTAsterisk>())\n+                {\n+                    if (asterisk)\n                     {\n-                        have_asterisk = true;\n+                        if (use_structure_from_insertion_table_in_table_functions == 1)\n+                            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Only one asterisk can be used in INSERT SELECT query.\");\n+\n+                        use_columns_from_insert_query = false;\n+                        break;\n                     }\n-                    else if (!expression->as<ASTLiteral>())\n+                    if (!structure_hint.empty())\n                     {\n+                        if (use_structure_from_insertion_table_in_table_functions == 1)\n+                            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Asterisk cannot be mixed with column list in INSERT SELECT query.\");\n+\n                         use_columns_from_insert_query = false;\n                         break;\n                     }\n-                }\n \n-                /// Check that all identifiers are column names from insertion table and not virtual column names from storage.\n-                for (const auto & column_name : columns_names)\n+                    asterisk = true;\n+                }\n+                else if (auto * function = (*expression)->as<ASTFunction>())\n                 {\n-                    if (!structure_hint.has(column_name) || virtual_column_names.contains(column_name))\n+                    if (use_structure_from_insertion_table_in_table_functions == 2 && findIdentifier(function))\n                     {\n                         use_columns_from_insert_query = false;\n                         break;\n                     }\n-                }\n \n-                /// If we don't have asterisk but only subset of columns, we should use\n-                /// structure from insertion table only in case when table function\n-                /// supports reading subset of columns from data.\n-                if (use_columns_from_insert_query && !have_asterisk && !columns_names.empty())\n+                    /// Once we hit asterisk we want to find end of the range covered by asterisk\n+                    /// contributing every further SELECT expression to the tail of insert structure\n+                    if (asterisk)\n+                        --insert_structure_end;\n+                    else\n+                        ++insert_column;\n+                }\n+                else\n                 {\n-                    /// For input function we should check if input format supports reading subset of columns.\n-                    if (table_function_ptr->getName() == \"input\")\n-                        use_columns_from_insert_query = FormatFactory::instance().checkIfFormatSupportsSubsetOfColumns(getInsertFormat());\n+                    /// Once we hit asterisk we want to find end of the range covered by asterisk\n+                    /// contributing every further SELECT expression to the tail of insert structure\n+                    if (asterisk)\n+                        --insert_structure_end;\n                     else\n-                        use_columns_from_insert_query = table_function_ptr->supportsReadingSubsetOfColumns();\n+                        ++insert_column;\n                 }\n             }\n \n+            if (use_structure_from_insertion_table_in_table_functions == 2 && !asterisk)\n+            {\n+                /// For input function we should check if input format supports reading subset of columns.\n+                if (table_function_ptr->getName() == \"input\")\n+                    use_columns_from_insert_query = FormatFactory::instance().checkIfFormatSupportsSubsetOfColumns(getInsertFormat());\n+                else\n+                    use_columns_from_insert_query = table_function_ptr->supportsReadingSubsetOfColumns();\n+            }\n+\n             if (use_columns_from_insert_query)\n-                table_function_ptr->setStructureHint(structure_hint);\n+            {\n+                if (expression == expression_list.end())\n+                {\n+                    /// Append tail of insert structure to the hint\n+                    if (asterisk)\n+                    {\n+                        for (; insert_column != insert_structure_end; ++insert_column)\n+                            structure_hint.add({ insert_column->name, insert_column->type });\n+                    }\n+\n+                    if (!structure_hint.empty())\n+                        table_function_ptr->setStructureHint(structure_hint);\n+\n+                } else if (use_structure_from_insertion_table_in_table_functions == 1)\n+                    throw Exception(ErrorCodes::NUMBER_OF_COLUMNS_DOESNT_MATCH, \"Number of columns in insert table less than required by SELECT expression.\");\n+            }\n         }\n \n         res = table_function_ptr->execute(table_expression, shared_from_this(), table_function_ptr->getName());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02458_use_structure_from_insertion_table.reference b/tests/queries/0_stateless/02458_use_structure_from_insertion_table.reference\nindex 0ca286402706..53abb49c4e1c 100644\n--- a/tests/queries/0_stateless/02458_use_structure_from_insertion_table.reference\n+++ b/tests/queries/0_stateless/02458_use_structure_from_insertion_table.reference\n@@ -1,9 +1,12 @@\n+\\N\t0\n \\N\t1\n 1\t2\n \\N\t42\n \\N\t42\n \\N\t42\n \\N\t42\n+42\n+42\n \\N\n \\N\n \\N\ndiff --git a/tests/queries/0_stateless/02458_use_structure_from_insertion_table.sql b/tests/queries/0_stateless/02458_use_structure_from_insertion_table.sql\nindex a609dc361fe1..97d493fa031e 100644\n--- a/tests/queries/0_stateless/02458_use_structure_from_insertion_table.sql\n+++ b/tests/queries/0_stateless/02458_use_structure_from_insertion_table.sql\n@@ -10,7 +10,7 @@ insert into test select * from file(02458_data.jsonl);\n insert into test select x, 1 from file(02458_data.jsonl);\n insert into test select x, y from file(02458_data.jsonl);\n insert into test select x + 1, y from file(02458_data.jsonl); -- {serverError ONLY_NULLS_WHILE_READING_SCHEMA}\n-insert into test select x, z from file(02458_data.jsonl); -- {serverError ONLY_NULLS_WHILE_READING_SCHEMA}\n+insert into test select x, z from file(02458_data.jsonl);\n \n insert into test select * from file(02458_data.jsoncompacteachrow);\n insert into test select x, 1 from file(02458_data.jsoncompacteachrow); -- {serverError ONLY_NULLS_WHILE_READING_SCHEMA}\n@@ -28,8 +28,8 @@ drop table test;\n create table test (x Nullable(UInt32)) engine=Memory();\n insert into test select * from file(02458_data.jsonl);\n insert into test select x from file(02458_data.jsonl);\n-insert into test select y from file(02458_data.jsonl); -- {serverError ONLY_NULLS_WHILE_READING_SCHEMA}\n-insert into test select y as x from file(02458_data.jsonl); -- {serverError ONLY_NULLS_WHILE_READING_SCHEMA}\n+insert into test select y from file(02458_data.jsonl);\n+insert into test select y as x from file(02458_data.jsonl);\n \n insert into test select c1 from input() format CSV 1,2; -- {serverError CANNOT_EXTRACT_TABLE_STRUCTURE}\n insert into test select x from input() format JSONEachRow {\"x\" : null, \"y\" : 42}\n",
  "problem_statement": "Setting use_structure_from_insertion_table_in_table_functions doesn't work properly with virtual columns.\n**Describe what's wrong**\r\nThe setting `set use_structure_from_insertion_table_in_table_functions=1` doesn't work properly\r\n\r\nsetting:\r\n```\r\nset use_structure_from_insertion_table_in_table_functions=1;\r\ninsert into function file(data.LineAsString) select 'Hello';\r\n```\r\n\r\ntable with the same column name:\r\n```\r\ncreate table test (_path String) engine=Memory;\r\ninsert into test select _path from file(data.LineAsString);\r\n\r\nReceived exception:\r\nCode: 352. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different types:\r\n_path String String(size = 0)\r\n_path LowCardinality(String) ColumnLowCardinality(size = 0, UInt8(size = 0), ColumnUnique(size = 1, String(size = 1))). (AMBIGUOUS_COLUMN_NAME)\r\n```\r\nhere error makes perfect sense, since virtual column `_path` is a LowCardinality(String) but table column is `String`, however, the cause of error shows that something wrong is going on here - apparently the columns matched by name and not by position which is stated in manual. And seemingly due to this we have some wrong behavior here:\r\n```\r\ninsert into test select CAST(_path as String) from file(data.LineAsString);\r\n\r\nReceived exception:\r\nCode: 352. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different types:\r\n_path String String(size = 0)\r\n_path LowCardinality(String) ColumnLowCardinality(size = 0, UInt8(size = 0), ColumnUnique(size = 1, String(size = 1))). (AMBIGUOUS_COLUMN_NAME)\r\n```\r\nand even more strange here:\r\n```\r\ndrop table test;\r\ncreate table test (_path LowCardinality(String)) engine=Memory;\r\ninsert into test select _path from file(data.LineAsString);\r\n\r\nReceived exception:\r\nCode: 80. DB::Exception: This input format is only suitable for tables with a single column of type String.: While executing File. (INCORRECT_QUERY)\r\n```\r\nnot sure about this one - probably this is because `file()` table function produce single `String` column, and virtual columns were not taken into account.\r\n\r\nHowever for table with different than `_path` column name there is no issue:\r\n```\r\ndrop table test;\r\ncreate table test (aaa String) engine=Memory;\r\ninsert into test select _path from file(data.LineAsString);\r\n```\r\nbut from code it's seems that in this case the setting `use_structure_from_insertion_table_in_table_functions` is ignored and CAST is added.\r\n\r\n**Does it reproduce on recent release?**\r\nreproduces on current master\r\n\n",
  "hints_text": "This is all is expected and not a problem with `use_structure_from_insertion_table_in_table_functions` setting. Using `use_structure_from_insertion_table_in_table_functions=1` means that we force ClickHosue to use structure from table in talbe function without any checks. So, if `use_structure_from_insertion_table_in_table_functions=1` these two queries are identical:\r\n```\r\ncreate table test (_path String) engine=Memory;\r\ninsert into test select _path from file(data.LineAsString) settings use_structure_from_insertion_table_in_table_functions=1;\r\n```\r\n```\r\ncreate table test (_path String) engine=Memory;\r\ninsert into test select _path from file(data.LineAsString, auto, '_path String');\r\n```\r\nAnd the second query will procude the same error (it doesn't depend on `use_structure_from_insertion_table_in_table_functions` setting).\r\n\r\nFor these cases we have `use_structure_from_insertion_table_in_table_functions=2 (auto)` when structure from insertion table is ignored when query contains virtual columns.\nSo, it's the same as:\r\n```\r\navogar-dev :) select _path from file(data.LineAsString, auto, '_path LowCardinality(String)');\r\n\r\nSELECT _path\r\nFROM file(data.LineAsString, auto, '_path LowCardinality(String)')\r\n\r\nQuery id: be742aac-f670-4f8f-9203-63c95b36850e\r\n\r\n\r\n0 rows in set. Elapsed: 0.010 sec.\r\n\r\nReceived exception:\r\nCode: 80. DB::Exception: This input format is only suitable for tables with a single column of type String.: While executing ParallelParsingBlockInputFormat: While executing File. (INCORRECT_QUERY)\r\n\r\navogar-dev :) select _path from file(data.LineAsString, auto, '_path String')\r\n\r\nSELECT _path\r\nFROM file(data.LineAsString, auto, '_path String')\r\n\r\nQuery id: aa80686f-7ec2-4bc0-8040-9562f1ef5025\r\n\r\n\r\n0 rows in set. Elapsed: 0.006 sec.\r\n\r\nReceived exception:\r\nCode: 352. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different types:\r\n_path String String(size = 0)\r\n_path LowCardinality(String) ColumnLowCardinality(size = 0, UInt8(size = 0), ColumnUnique(size = 1, String(size = 1))). (AMBIGUOUS_COLUMN_NAME)\r\n\r\navogar-dev :) select CAST(_path as String)  from file(data.LineAsString, auto, '_path String')\r\n\r\nSELECT CAST(_path, 'String')\r\nFROM file(data.LineAsString, auto, '_path String')\r\n\r\nQuery id: b938be3c-b126-4603-9291-3a1bf5cfd61d\r\n\r\n\r\n0 rows in set. Elapsed: 0.006 sec.\r\n\r\nReceived exception:\r\nCode: 352. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different types:\r\n_path String String(size = 0)\r\n_path LowCardinality(String) ColumnLowCardinality(size = 0, UInt8(size = 0), ColumnUnique(size = 1, String(size = 1))). (AMBIGUOUS_COLUMN_NAME)\r\n\r\n```\r\n\r\nIf it's not expected, I guess it's a problem with `file` table engine and how it handles structure with `_path` name in it\n...though we still have a strange case when name in the insertion table is not matching with select name and it works, while for matching names it doesn't with exception 352. But it also is not dependent on `use_structure_from_insertion_table_in_table_functions` setting. Apparently the error 352 is indicative of using name matching instead of position.\r\n\nFor `file` table engine (and I guess for `s3/url/hdfs`) it makes sense to not use virtual columns and don't add them to block when structure contains column with same name.\nWe specifically state in docs that matching is by position and imply that using same names is ok:\r\n```\r\nColumns are mapped according to their position in the SELECT clause.\r\nHowever, their names in the SELECT expression and the table for INSERT may differ.\r\nIf necessary, type casting is performed.\r\n```\r\nhttps://clickhouse.com/docs/en/sql-reference/statements/insert-into#inserting-the-results-of-select\r\n\nMy point is that when we are creating block we initially fill it with suggested structure either from insert table or from table function parameter, and then we are trying to add columns from actual structure of table function - on this stage we are having two issues - we are checking columns by name to confirm they have same structure and we are ignoring all the functions applied in select - it seems very strange...\n> We specifically state in docs that matching is by position and imply that using same names is ok:\r\n\r\nBut here we don't have any problems with `insert ... select ...`, all these 356 errors are from select part of a query. And it happens because in `StorageFile` we add column `_path LowCardinality(String)` when we have `_path` column in select statement (it can also be inside any functions):\r\nhttps://github.com/ClickHouse/ClickHouse/blob/cb0065fba2366e30b1479857cc5566233635dfd8/src/Storages/StorageFile.cpp#L724-L730\r\n\r\nSo, we just don't check if we already have column `_path` in the block:\r\nhttps://github.com/ClickHouse/ClickHouse/blob/cb0065fba2366e30b1479857cc5566233635dfd8/src/Storages/StorageFile.cpp#L529-L547\r\n\r\nAnd as a result, we have two columns with identical name `_path` in the block.\r\nOr I missed what you are saying.\n> And as a result, we have two columns with identical name `_path` in the block.\r\n\r\nthis is effectively matching by name - the initial column in this block seems to be from insert table structure\nI still don't see a problem. It's from insertion table structure when we use `use_structure_from_insertion_table_in_table_functions=1` but it's the same as\r\n```\r\ninsert into test select _path from file(data.LineAsString, auto, '_path String');\r\n```\r\n\r\nAnd matching by position works here, we can write smth like\r\n```\r\ninsert into test select _path as a from file(data.LineAsString, auto, '_path String');\r\n```\r\n\r\nAnd this matching is performed during insert, but here we fail on select stage. It's a bit different",
  "created_at": "2023-03-24T00:34:36Z",
  "modified_files": [
    "src/Analyzer/Passes/QueryAnalysisPass.cpp",
    "src/Interpreters/Context.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02458_use_structure_from_insertion_table.reference",
    "tests/queries/0_stateless/02458_use_structure_from_insertion_table.sql"
  ]
}