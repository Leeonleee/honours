{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25909,
  "instance_id": "ClickHouse__ClickHouse-25909",
  "issue_numbers": [
    "6481"
  ],
  "base_commit": "7a993404b4d222884bedf4a933f999213be48b5c",
  "patch": "diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex 8e9a14a20fb6..2a5594a68665 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -765,7 +765,7 @@ ReturnType readDateTextFallback(LocalDate & date, ReadBuffer & buf)\n \n     auto ignore_delimiter = [&]\n     {\n-        if (!buf.eof())\n+        if (!buf.eof() && !isNumericASCII(*buf.position()))\n         {\n             ++buf.position();\n             return true;\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex d4e2db0b553f..4e101aaaf63d 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -572,27 +572,43 @@ inline ReturnType readDateTextImpl(LocalDate & date, ReadBuffer & buf)\n     /// Optimistic path, when whole value is in buffer.\n     if (!buf.eof() && buf.position() + 10 <= buf.buffer().end())\n     {\n-        UInt16 year = (buf.position()[0] - '0') * 1000 + (buf.position()[1] - '0') * 100 + (buf.position()[2] - '0') * 10 + (buf.position()[3] - '0');\n-        buf.position() += 5;\n+        char * pos = buf.position();\n \n-        UInt8 month = buf.position()[0] - '0';\n-        if (isNumericASCII(buf.position()[1]))\n+        /// YYYY-MM-DD\n+        /// YYYY-MM-D\n+        /// YYYY-M-DD\n+        /// YYYY-M-D\n+\n+        /// The delimiters can be arbitrary characters, like YYYY/MM!DD, but obviously not digits.\n+\n+        UInt16 year = (pos[0] - '0') * 1000 + (pos[1] - '0') * 100 + (pos[2] - '0') * 10 + (pos[3] - '0');\n+        pos += 5;\n+\n+        if (isNumericASCII(pos[-1]))\n+            return ReturnType(false);\n+\n+        UInt8 month = pos[0] - '0';\n+        if (isNumericASCII(pos[1]))\n         {\n-            month = month * 10 + buf.position()[1] - '0';\n-            buf.position() += 3;\n+            month = month * 10 + pos[1] - '0';\n+            pos += 3;\n         }\n         else\n-            buf.position() += 2;\n+            pos += 2;\n+\n+        if (isNumericASCII(pos[-1]))\n+            return ReturnType(false);\n \n-        UInt8 day = buf.position()[0] - '0';\n-        if (isNumericASCII(buf.position()[1]))\n+        UInt8 day = pos[0] - '0';\n+        if (isNumericASCII(pos[1]))\n         {\n-            day = day * 10 + buf.position()[1] - '0';\n-            buf.position() += 2;\n+            day = day * 10 + pos[1] - '0';\n+            pos += 2;\n         }\n         else\n-            buf.position() += 1;\n+            pos += 1;\n \n+        buf.position() = pos;\n         date = LocalDate(year, month, day);\n         return ReturnType(true);\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01933_invalid_date.reference b/tests/queries/0_stateless/01933_invalid_date.reference\nnew file mode 100644\nindex 000000000000..829e7e8c420d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01933_invalid_date.reference\n@@ -0,0 +1,1 @@\n+2019-07-08\ndiff --git a/tests/queries/0_stateless/01933_invalid_date.sql b/tests/queries/0_stateless/01933_invalid_date.sql\nnew file mode 100644\nindex 000000000000..aac09c99e60f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01933_invalid_date.sql\n@@ -0,0 +1,10 @@\n+SELECT toDate('07-08-2019'); -- { serverError 6 }\n+SELECT toDate('2019-0708'); -- { serverError 38 }\n+SELECT toDate('201907-08'); -- { serverError 38 }\n+SELECT toDate('2019^7^8');\n+\n+CREATE TEMPORARY TABLE test (d Date);\n+INSERT INTO test VALUES ('2018-01-01');\n+\n+SELECT * FROM test WHERE d >= '07-08-2019'; -- { serverError 53 }\n+SELECT * FROM test WHERE d >= '2019-07-08';\n",
  "problem_statement": "Incorrect date format can be incorrectly parsed in comparison condition.\nExample: \r\n```\r\nSELECT count() FROM merge.hits_v2 WHERE EventDate > '07-08-2019'\r\n```\r\n\r\nThis query attempts to process all records in a table.\n",
  "hints_text": "This is very dangerous. I just did an `ALTER TABLE table DELETE WHERE a = 'b' AND date >= '18-08-2020';` which delete much more data than expected. I know that for parsing speed wrong dates don't throw errors but it would be so much better if for constants in queries it did throw an error. Here speed doesn't matter as a query doesn't contain millions of constants. Especially for `ALTER TABLE` queries a wrongly formatted date should really throw an error!",
  "created_at": "2021-07-02T00:08:37Z",
  "modified_files": [
    "src/IO/ReadHelpers.cpp",
    "src/IO/ReadHelpers.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01933_invalid_date.reference",
    "b/tests/queries/0_stateless/01933_invalid_date.sql"
  ]
}