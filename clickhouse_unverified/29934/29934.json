{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 29934,
  "instance_id": "ClickHouse__ClickHouse-29934",
  "issue_numbers": [
    "26233"
  ],
  "base_commit": "341eb1f9bfb1a60e19f1159b9e7f1822ed7010c4",
  "patch": "diff --git a/src/Functions/registerFunctions.cpp b/src/Functions/registerFunctions.cpp\nindex 35193e9be8d0..b2f038240aa0 100644\n--- a/src/Functions/registerFunctions.cpp\n+++ b/src/Functions/registerFunctions.cpp\n@@ -54,9 +54,6 @@ void registerFunctionTupleHammingDistance(FunctionFactory & factory);\n void registerFunctionsStringHash(FunctionFactory & factory);\n void registerFunctionValidateNestedArraySizes(FunctionFactory & factory);\n void registerFunctionsSnowflake(FunctionFactory & factory);\n-#if !defined(ARCADIA_BUILD)\n-void registerFunctionBayesAB(FunctionFactory &);\n-#endif\n void registerFunctionTid(FunctionFactory & factory);\n void registerFunctionLogTrace(FunctionFactory & factory);\n \n@@ -122,10 +119,6 @@ void registerFunctions()\n     registerFunctionValidateNestedArraySizes(factory);\n     registerFunctionsSnowflake(factory);\n \n-#if !defined(ARCADIA_BUILD)\n-    registerFunctionBayesAB(factory);\n-#endif\n-\n #if USE_SSL\n     registerFunctionEncrypt(factory);\n     registerFunctionDecrypt(factory);\n",
  "test_patch": "diff --git a/src/Functions/abtesting.cpp b/src/Functions/abtesting.cpp\ndeleted file mode 100644\nindex 312fdf6fb487..000000000000\n--- a/src/Functions/abtesting.cpp\n+++ /dev/null\n@@ -1,315 +0,0 @@\n-#include <Functions/abtesting.h>\n-\n-#if !defined(ARCADIA_BUILD) && USE_STATS\n-\n-#include <math.h>\n-\n-#include <DataTypes/DataTypeString.h>\n-#include <Columns/ColumnString.h>\n-#include <Columns/ColumnConst.h>\n-#include <Columns/ColumnsNumber.h>\n-#include <Functions/FunctionFactory.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <IO/WriteHelpers.h>\n-#include <IO/WriteBufferFromString.h>\n-\n-#define STATS_ENABLE_STDVEC_WRAPPERS\n-#include <stats.hpp>\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n-static const String BETA = \"beta\";\n-static const String GAMMA = \"gamma\";\n-\n-template <bool higher_is_better>\n-Variants bayesian_ab_test(String distribution, PODArray<Float64> & xs, PODArray<Float64> & ys)\n-{\n-    const size_t r = 1000, c = 100;\n-\n-    Variants variants(xs.size(), {0.0, 0.0, 0.0, 0.0});\n-    std::vector<std::vector<Float64>> samples_matrix;\n-\n-    for (size_t i = 0; i < xs.size(); ++i)\n-    {\n-        variants[i].x = xs[i];\n-        variants[i].y = ys[i];\n-    }\n-\n-    if (distribution == BETA)\n-    {\n-        Float64 alpha, beta;\n-\n-        for (size_t i = 0; i < xs.size(); ++i)\n-            if (xs[i] < ys[i])\n-                throw Exception(\"Conversions cannot be larger than trials\", ErrorCodes::BAD_ARGUMENTS);\n-\n-        for (size_t i = 0; i < xs.size(); ++i)\n-        {\n-            alpha = 1.0 + ys[i];\n-            beta = 1.0 + xs[i] - ys[i];\n-\n-            samples_matrix.emplace_back(stats::rbeta<std::vector<Float64>>(r, c, alpha, beta));\n-        }\n-    }\n-    else if (distribution == GAMMA)\n-    {\n-        Float64 shape, scale;\n-\n-        for (size_t i = 0; i < xs.size(); ++i)\n-        {\n-            shape = 1.0 + xs[i];\n-            scale = 250.0 / (1 + 250.0 * ys[i]);\n-\n-            std::vector<Float64> samples = stats::rgamma<std::vector<Float64>>(r, c, shape, scale);\n-            for (auto & sample : samples)\n-                sample = 1 / sample;\n-            samples_matrix.emplace_back(std::move(samples));\n-        }\n-    }\n-\n-    PODArray<Float64> means;\n-    for (auto & samples : samples_matrix)\n-    {\n-        Float64 total = 0.0;\n-        for (auto sample : samples)\n-            total += sample;\n-        means.push_back(total / samples.size());\n-    }\n-\n-    // Beats control\n-    for (size_t i = 1; i < xs.size(); ++i)\n-    {\n-        for (size_t n = 0; n < r * c; ++n)\n-        {\n-            if (higher_is_better)\n-            {\n-                if (samples_matrix[i][n] > samples_matrix[0][n])\n-                    ++variants[i].beats_control;\n-            }\n-            else\n-            {\n-                if (samples_matrix[i][n] < samples_matrix[0][n])\n-                    ++variants[i].beats_control;\n-            }\n-        }\n-    }\n-\n-    for (auto & variant : variants)\n-        variant.beats_control = static_cast<Float64>(variant.beats_control) / r / c;\n-\n-    // To be best\n-    PODArray<size_t> count_m(xs.size(), 0);\n-    PODArray<Float64> row(xs.size(), 0);\n-\n-    for (size_t n = 0; n < r * c; ++n)\n-    {\n-        for (size_t i = 0; i < xs.size(); ++i)\n-            row[i] = samples_matrix[i][n];\n-\n-        Float64 m;\n-        if (higher_is_better)\n-            m = *std::max_element(row.begin(), row.end());\n-        else\n-            m = *std::min_element(row.begin(), row.end());\n-\n-        for (size_t i = 0; i < xs.size(); ++i)\n-        {\n-            if (m == samples_matrix[i][n])\n-            {\n-                ++variants[i].best;\n-                break;\n-            }\n-        }\n-    }\n-\n-    for (auto & variant : variants)\n-        variant.best = static_cast<Float64>(variant.best) / r / c;\n-\n-    return variants;\n-}\n-\n-String convertToJson(const PODArray<String> & variant_names, const Variants & variants)\n-{\n-    FormatSettings settings;\n-\n-    WriteBufferFromOwnString buf;\n-\n-    writeCString(\"{\\\"data\\\":[\", buf);\n-    for (size_t i = 0; i < variants.size(); ++i)\n-    {\n-        writeCString(\"{\\\"variant_name\\\":\", buf);\n-        writeJSONString(variant_names[i], buf, settings);\n-        writeCString(\",\\\"x\\\":\", buf);\n-        writeText(variants[i].x, buf);\n-        writeCString(\",\\\"y\\\":\", buf);\n-        writeText(variants[i].y, buf);\n-        writeCString(\",\\\"beats_control\\\":\", buf);\n-        writeText(variants[i].beats_control, buf);\n-        writeCString(\",\\\"to_be_best\\\":\", buf);\n-        writeText(variants[i].best, buf);\n-        writeCString(\"}\", buf);\n-        if (i != variant_names.size() -1)\n-            writeCString(\",\", buf);\n-    }\n-    writeCString(\"]}\", buf);\n-\n-    return buf.str();\n-}\n-\n-class FunctionBayesAB : public IFunction\n-{\n-public:\n-    static constexpr auto name = \"bayesAB\";\n-\n-    static FunctionPtr create(ContextPtr)\n-    {\n-        return std::make_shared<FunctionBayesAB>();\n-    }\n-\n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    bool isDeterministic() const override { return false; }\n-    bool isDeterministicInScopeOfQuery() const override { return false; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-\n-    size_t getNumberOfArguments() const override { return 5; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes &) const override\n-    {\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    static bool toFloat64(const ColumnConst * col_const_arr, PODArray<Float64> & output)\n-    {\n-        Array src_arr = col_const_arr->getValue<Array>();\n-\n-        for (size_t i = 0, size = src_arr.size(); i < size; ++i)\n-        {\n-            switch (src_arr[i].getType())\n-            {\n-                case Field::Types::Int64:\n-                    output.push_back(static_cast<Float64>(src_arr[i].get<const Int64 &>()));\n-                    break;\n-                case Field::Types::UInt64:\n-                    output.push_back(static_cast<Float64>(src_arr[i].get<const UInt64 &>()));\n-                    break;\n-                case Field::Types::Float64:\n-                    output.push_back(src_arr[i].get<const Float64 &>());\n-                    break;\n-                default:\n-                    return false;\n-            }\n-        }\n-\n-        return true;\n-    }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n-    {\n-        if (input_rows_count == 0)\n-            return ColumnString::create();\n-\n-        PODArray<Float64> xs, ys;\n-        PODArray<String> variant_names;\n-        String dist;\n-        bool higher_is_better;\n-\n-        if (const ColumnConst * col_dist = checkAndGetColumnConst<ColumnString>(arguments[0].column.get()))\n-        {\n-            dist = col_dist->getDataAt(0).data;\n-            dist = Poco::toLower(dist);\n-            if (dist != BETA && dist != GAMMA)\n-                throw Exception(\"First argument for function \" + getName() + \" cannot be \" + dist, ErrorCodes::BAD_ARGUMENTS);\n-        }\n-        else\n-            throw Exception(\"First argument for function \" + getName() + \" must be Constant string\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        if (const ColumnConst * col_higher_is_better = checkAndGetColumnConst<ColumnUInt8>(arguments[1].column.get()))\n-            higher_is_better = col_higher_is_better->getBool(0);\n-        else\n-            throw Exception(\"Second argument for function \" + getName() + \" must be Constant boolean\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        if (const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arguments[2].column.get()))\n-        {\n-            Array src_arr = col_const_arr->getValue<Array>();\n-\n-            for (size_t i = 0; i < src_arr.size(); ++i)\n-            {\n-                if (src_arr[i].getType() != Field::Types::String)\n-                    throw Exception(\"Third argument for function \" + getName() + \" must be Array of constant strings\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-                variant_names.push_back(src_arr[i].get<const String &>());\n-            }\n-        }\n-        else\n-            throw Exception(\"Third argument for function \" + getName() + \" must be Array of constant strings\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        if (const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arguments[3].column.get()))\n-        {\n-            if (!toFloat64(col_const_arr, xs))\n-                throw Exception(\"Forth and fifth Argument for function \" + getName() + \" must be Array of constant Numbers\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else\n-            throw Exception(\"Forth argument for function \" + getName() + \" must be Array of constant numbers\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        if (const ColumnConst * col_const_arr = checkAndGetColumnConst<ColumnArray>(arguments[4].column.get()))\n-        {\n-            if (!toFloat64(col_const_arr, ys))\n-                throw Exception(\"Fifth Argument for function \" + getName() + \" must be Array of constant Numbers\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        }\n-        else\n-            throw Exception(\"Fifth argument for function \" + getName() + \" must be Array of constant numbers\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-\n-        if (variant_names.size() != xs.size() || xs.size() != ys.size())\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Sizes of arguments doesn't match: variant_names: {}, xs: {}, ys: {}\", variant_names.size(), xs.size(), ys.size());\n-\n-        if (variant_names.size() < 2)\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Sizes of arguments must be larger than 1. variant_names: {}, xs: {}, ys: {}\", variant_names.size(), xs.size(), ys.size());\n-\n-        if (std::count_if(xs.begin(), xs.end(), [](Float64 v) { return v < 0; }) > 0 ||\n-            std::count_if(ys.begin(), ys.end(), [](Float64 v) { return v < 0; }) > 0)\n-            throw Exception(\"Negative values don't allowed\", ErrorCodes::BAD_ARGUMENTS);\n-\n-        Variants variants;\n-        if (higher_is_better)\n-            variants = bayesian_ab_test<true>(dist, xs, ys);\n-        else\n-            variants = bayesian_ab_test<false>(dist, xs, ys);\n-\n-        auto dst = ColumnString::create();\n-        std::string result_str = convertToJson(variant_names, variants);\n-        dst->insertData(result_str.c_str(), result_str.length());\n-        return dst;\n-    }\n-};\n-\n-void registerFunctionBayesAB(FunctionFactory & factory)\n-{\n-    factory.registerFunction<FunctionBayesAB>();\n-}\n-\n-}\n-\n-#else\n-\n-namespace DB\n-{\n-\n-class FunctionFactory;\n-\n-void registerFunctionBayesAB(FunctionFactory & /* factory */)\n-{\n-}\n-\n-}\n-\n-#endif\ndiff --git a/src/Functions/abtesting.h b/src/Functions/abtesting.h\ndeleted file mode 100644\nindex b1f12e794378..000000000000\n--- a/src/Functions/abtesting.h\n+++ /dev/null\n@@ -1,35 +0,0 @@\n-#pragma once\n-\n-#include <Common/config.h>\n-\n-#if !defined(ARCADIA_BUILD) && USE_STATS\n-\n-#    include <base/types.h>\n-#    include <Common/PODArray.h>\n-\n-#    include <algorithm>\n-#    include <iostream>\n-#    include <vector>\n-\n-\n-namespace DB\n-{\n-\n-struct Variant\n-{\n-    Float64 x;\n-    Float64 y;\n-    Float64 beats_control;\n-    Float64 best;\n-};\n-\n-using Variants = PODArray<Variant>;\n-\n-template <bool higher_is_better>\n-Variants bayesian_ab_test(String distribution, PODArray<Float64> & xs, PODArray<Float64> & ys);\n-\n-String convertToJson(const PODArray<String> & variant_names, const Variants & variants);\n-\n-}\n-\n-#endif\ndiff --git a/src/Functions/tests/gtest_abtesting.cpp b/src/Functions/tests/gtest_abtesting.cpp\ndeleted file mode 100644\nindex e7ef5b5c3cf9..000000000000\n--- a/src/Functions/tests/gtest_abtesting.cpp\n+++ /dev/null\n@@ -1,105 +0,0 @@\n-#include <Functions/abtesting.h>\n-\n-#if !defined(ARCADIA_BUILD) && USE_STATS\n-\n-#    include <gtest/gtest.h>\n-\n-using namespace DB;\n-\n-Variants test_bayesab(std::string dist, PODArray<Float64> xs, PODArray<Float64> ys, size_t & max, size_t & min)\n-{\n-    Variants variants;\n-\n-    //std::cout << std::fixed;\n-    if (dist == \"beta\")\n-    {\n-/*        std::cout << dist << \"\\nclicks: \";\n-        for (auto x : xs)\n-            std::cout << x << \" \";\n-\n-        std::cout <<\"\\tconversions: \";\n-        for (auto y : ys)\n-            std::cout << y << \" \";\n-\n-        std::cout << \"\\n\";*/\n-\n-        variants = bayesian_ab_test<true>(dist, xs, ys);\n-    }\n-    else if (dist == \"gamma\")\n-    {\n-/*        std::cout << dist << \"\\nclicks: \";\n-        for (auto x : xs)\n-            std::cout << x << \" \";\n-\n-        std::cout <<\"\\tcost: \";\n-        for (auto y : ys)\n-            std::cout << y << \" \";\n-\n-        std::cout << \"\\n\";*/\n-\n-        variants = bayesian_ab_test<true>(dist, xs, ys);\n-    }\n-\n-/*    for (size_t i = 0; i < variants.size(); ++i)\n-        std::cout << i << \" beats 0: \" << variants[i].beats_control << std::endl;\n-\n-    for (size_t i = 0; i < variants.size(); ++i)\n-        std::cout << i << \" to be best: \" << variants[i].best << std::endl;\n-\n-    std::cout << convertToJson({\"0\", \"1\", \"2\"}, variants) << std::endl;\n-*/\n-    Float64 max_val = 0.0, min_val = 2.0;\n-    for (size_t i = 0; i < variants.size(); ++i)\n-    {\n-        if (variants[i].best > max_val)\n-        {\n-            max_val = variants[i].best;\n-            max = i;\n-        }\n-\n-        if (variants[i].best < min_val)\n-        {\n-            min_val = variants[i].best;\n-            min = i;\n-        }\n-    }\n-\n-    return variants;\n-}\n-\n-\n-TEST(BayesAB, beta)\n-{\n-    size_t max = 0, min = 0;\n-\n-    auto variants = test_bayesab(\"beta\", {10000, 1000, 900}, {600, 110, 90}, max, min);\n-    ASSERT_EQ(1, max);\n-\n-    variants = test_bayesab(\"beta\", {3000, 3000, 3000}, {600, 100, 90}, max, min);\n-    ASSERT_EQ(0, max);\n-\n-    variants = test_bayesab(\"beta\", {3000, 3000, 3000}, {100, 90, 110}, max, min);\n-    ASSERT_EQ(2, max);\n-\n-    variants = test_bayesab(\"beta\", {3000, 3000, 3000}, {110, 90, 100}, max, min);\n-    ASSERT_EQ(0, max);\n-}\n-\n-\n-TEST(BayesAB, gamma)\n-{\n-    size_t max = 0, min = 0;\n-    auto variants = test_bayesab(\"gamma\", {10000, 1000, 900}, {600, 110, 90}, max, min);\n-    ASSERT_EQ(1, max);\n-\n-    variants = test_bayesab(\"gamma\", {3000, 3000, 3000}, {600, 100, 90}, max, min);\n-    ASSERT_EQ(0, max);\n-\n-    variants = test_bayesab(\"gamma\", {3000, 3000, 3000}, {100, 90, 110}, max, min);\n-    ASSERT_EQ(2, max);\n-\n-    variants = test_bayesab(\"gamma\", {3000, 3000, 3000}, {110, 90, 100}, max, min);\n-    ASSERT_EQ(0, max);\n-}\n-\n-#endif\ndiff --git a/tests/queries/0_stateless/01411_bayesian_ab_testing.reference b/tests/queries/0_stateless/01411_bayesian_ab_testing.reference\ndeleted file mode 100644\nindex 98fb6a686563..000000000000\n--- a/tests/queries/0_stateless/01411_bayesian_ab_testing.reference\n+++ /dev/null\n@@ -1,4 +0,0 @@\n-1\n-1\n-1\n-1\ndiff --git a/tests/queries/0_stateless/01411_bayesian_ab_testing.sql b/tests/queries/0_stateless/01411_bayesian_ab_testing.sql\ndeleted file mode 100644\nindex a4b03d76c51f..000000000000\n--- a/tests/queries/0_stateless/01411_bayesian_ab_testing.sql\n+++ /dev/null\n@@ -1,6 +0,0 @@\n--- Tags: no-fasttest\n-\n-SELECT count() FROM (SELECT bayesAB('beta', 1, ['Control', 'A', 'B'], [3000.0, 3000.0, 2000.0], [1000.0, 1100.0, 800.0]));\n-SELECT count() FROM (SELECT bayesAB('gamma', 1, ['Control', 'A', 'B'], [3000.0, 3000.0, 2000.0], [1000.0, 1100.0, 800.0]));\n-SELECT count() FROM (SELECT bayesAB('beta', 0, ['Control', 'A', 'B'], [3000.0, 3000.0, 2000.0], [1000.0, 1100.0, 800.0]));\n-SELECT count() FROM (SELECT bayesAB('gamma', 0, ['Control', 'A', 'B'], [3000.0, 3000.0, 2000.0], [1000.0, 1100.0, 800.0]));\n",
  "problem_statement": "Remove function `bayesAB` or break it in backward incompatible way.\nThis function is strange. Looks like the implementation is of low quality.\r\n\r\n```\r\nbool isDeterministic() const override { return false; }\r\nbool isDeterministicInScopeOfQuery() const override { return false; }\r\n```\r\nWhy it is not deterministic? Missing a comment.\r\n\r\n```\r\nString convertToJson(const PODArray<String> & variant_names, const Variants & variants)\r\n{\r\n    FormatSettings settings;\r\n\r\n    WriteBufferFromOwnString buf;\r\n\r\n    writeCString(\"{\\\"data\\\":[\", buf);\r\n    for (size_t i = 0; i < variants.size(); ++i)\r\n    {\r\n        writeCString(\"{\\\"variant_name\\\":\", buf);\r\n        writeJSONString(variant_names[i], buf, settings);\r\n        writeCString(\",\\\"x\\\":\", buf);\r\n        writeText(variants[i].x, buf);\r\n        writeCString(\",\\\"y\\\":\", buf);\r\n        writeText(variants[i].y, buf);\r\n        writeCString(\",\\\"beats_control\\\":\", buf);\r\n        writeText(variants[i].beats_control, buf);\r\n        writeCString(\",\\\"to_be_best\\\":\", buf);\r\n        writeText(variants[i].best, buf);\r\n        writeCString(\"}\", buf);\r\n        if (i != variant_names.size() -1)\r\n            writeCString(\",\", buf);\r\n    }\r\n    writeCString(\"]}\", buf);\r\n\r\n    return buf.str();\r\n}\r\n```\r\nIt returns unstructured data? :scream: \r\n\r\nAs first step we can remove documentation for this function.\r\nCC @nikitamikhaylov \n",
  "hints_text": "",
  "created_at": "2021-10-10T01:17:12Z"
}