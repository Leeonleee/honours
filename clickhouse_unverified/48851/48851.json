{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48851,
  "instance_id": "ClickHouse__ClickHouse-48851",
  "issue_numbers": [
    "28381"
  ],
  "base_commit": "8465b6cdf0f1cc563fd70f299d7bb91a6dab86c3",
  "patch": "diff --git a/src/Functions/date_trunc.cpp b/src/Functions/date_trunc.cpp\nindex 016b8f4da5e7..87fff0b7f3cb 100644\n--- a/src/Functions/date_trunc.cpp\n+++ b/src/Functions/date_trunc.cpp\n@@ -1,6 +1,6 @@\n #include <Columns/ColumnConst.h>\n-#include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnsNumber.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeInterval.h>\n@@ -25,7 +25,7 @@ class FunctionDateTrunc : public IFunction\n public:\n     static constexpr auto name = \"dateTrunc\";\n \n-    explicit FunctionDateTrunc(ContextPtr context_) : context(context_) {}\n+    explicit FunctionDateTrunc(ContextPtr context_) : context(context_) { }\n \n     static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionDateTrunc>(context); }\n \n@@ -39,51 +39,58 @@ class FunctionDateTrunc : public IFunction\n     {\n         /// The first argument is a constant string with the name of datepart.\n \n-        auto result_type_is_date = false;\n+        intermediate_type_is_date = false;\n         String datepart_param;\n-        auto check_first_argument = [&] {\n+        auto check_first_argument = [&]\n+        {\n             const ColumnConst * datepart_column = checkAndGetColumnConst<ColumnString>(arguments[0].column.get());\n             if (!datepart_column)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be constant string: \"\n-                    \"name of datepart\", getName());\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"First argument for function {} must be constant string: \"\n+                    \"name of datepart\",\n+                    getName());\n \n             datepart_param = datepart_column->getValue<String>();\n             if (datepart_param.empty())\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"First argument (name of datepart) for function {} cannot be empty\",\n-                    getName());\n+                throw Exception(\n+                    ErrorCodes::BAD_ARGUMENTS, \"First argument (name of datepart) for function {} cannot be empty\", getName());\n \n             if (!IntervalKind::tryParseString(datepart_param, datepart_kind))\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{} doesn't look like datepart name in {}\", datepart_param, getName());\n \n-            result_type_is_date = (datepart_kind == IntervalKind::Year)\n-                || (datepart_kind == IntervalKind::Quarter) || (datepart_kind == IntervalKind::Month)\n-                || (datepart_kind == IntervalKind::Week);\n+            intermediate_type_is_date = (datepart_kind == IntervalKind::Year) || (datepart_kind == IntervalKind::Quarter)\n+                || (datepart_kind == IntervalKind::Month) || (datepart_kind == IntervalKind::Week);\n         };\n \n         bool second_argument_is_date = false;\n-        auto check_second_argument = [&] {\n+        auto check_second_argument = [&]\n+        {\n             if (!isDate(arguments[1].type) && !isDateTime(arguments[1].type) && !isDateTime64(arguments[1].type))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of 2nd argument of function {}. \"\n-                    \"Should be a date or a date with time\", arguments[1].type->getName(), getName());\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type {} of 2nd argument of function {}. \"\n+                    \"Should be a date or a date with time\",\n+                    arguments[1].type->getName(),\n+                    getName());\n \n             second_argument_is_date = isDate(arguments[1].type);\n \n-            if (second_argument_is_date && ((datepart_kind == IntervalKind::Hour)\n-                || (datepart_kind == IntervalKind::Minute) || (datepart_kind == IntervalKind::Second)))\n+            if (second_argument_is_date\n+                && ((datepart_kind == IntervalKind::Hour) || (datepart_kind == IntervalKind::Minute)\n+                    || (datepart_kind == IntervalKind::Second)))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type Date of argument for function {}\", getName());\n         };\n \n-        auto check_timezone_argument = [&] {\n+        auto check_timezone_argument = [&]\n+        {\n             if (!WhichDataType(arguments[2].type).isString())\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}. \"\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type {} of argument of function {}. \"\n                     \"This argument is optional and must be a constant string with timezone name\",\n-                    arguments[2].type->getName(), getName());\n-\n-            if (second_argument_is_date && result_type_is_date)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                                \"The timezone argument of function {} with datepart '{}' \"\n-                                \"is allowed only when the 2nd argument has the type DateTime\",\n-                                getName(), datepart_param);\n+                    arguments[2].type->getName(),\n+                    getName());\n         };\n \n         if (arguments.size() == 2)\n@@ -99,15 +106,14 @@ class FunctionDateTrunc : public IFunction\n         }\n         else\n         {\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n                 \"Number of arguments for function {} doesn't match: passed {}, should be 2 or 3\",\n-                getName(), arguments.size());\n+                getName(),\n+                arguments.size());\n         }\n \n-        if (result_type_is_date)\n-            return std::make_shared<DataTypeDate>();\n-        else\n-            return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 2, 1));\n+        return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 2, 1));\n     }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n@@ -124,26 +130,40 @@ class FunctionDateTrunc : public IFunction\n \n         auto to_start_of_interval = FunctionFactory::instance().get(\"toStartOfInterval\", context);\n \n+        ColumnPtr truncated_column;\n+        auto date_type = std::make_shared<DataTypeDate>();\n+\n         if (arguments.size() == 2)\n-            return to_start_of_interval->build(temp_columns)->execute(temp_columns, result_type, input_rows_count);\n+            truncated_column = to_start_of_interval->build(temp_columns)\n+                                    ->execute(temp_columns, intermediate_type_is_date ? date_type : result_type, input_rows_count);\n+        else\n+        {\n+            temp_columns[2] = arguments[2];\n+            truncated_column = to_start_of_interval->build(temp_columns)\n+                                    ->execute(temp_columns, intermediate_type_is_date ? date_type : result_type, input_rows_count);\n+        }\n \n-        temp_columns[2] = arguments[2];\n-        return to_start_of_interval->build(temp_columns)->execute(temp_columns, result_type, input_rows_count);\n-    }\n+        if (!intermediate_type_is_date)\n+            return truncated_column;\n \n-    bool hasInformationAboutMonotonicity() const override\n-    {\n-        return true;\n+        ColumnsWithTypeAndName temp_truncated_column(1);\n+        temp_truncated_column[0] = {truncated_column, date_type, \"\"};\n+\n+        auto to_date_time_or_default = FunctionFactory::instance().get(\"toDateTime\", context);\n+        return to_date_time_or_default->build(temp_truncated_column)->execute(temp_truncated_column, result_type, input_rows_count);\n     }\n \n+    bool hasInformationAboutMonotonicity() const override { return true; }\n+\n     Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override\n     {\n-        return { .is_monotonic = true, .is_always_monotonic = true };\n+        return {.is_monotonic = true, .is_always_monotonic = true};\n     }\n \n private:\n     ContextPtr context;\n     mutable IntervalKind::Kind datepart_kind = IntervalKind::Kind::Second;\n+    mutable bool intermediate_type_is_date = false;\n };\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00189_time_zones_long.reference b/tests/queries/0_stateless/00189_time_zones_long.reference\nindex 8717a662771c..d41c925bbe55 100644\n--- a/tests/queries/0_stateless/00189_time_zones_long.reference\n+++ b/tests/queries/0_stateless/00189_time_zones_long.reference\n@@ -246,18 +246,18 @@ toUnixTimestamp\n 1426415400\n 1426415400\n date_trunc\n-2019-01-01\n-2020-01-01\n-2020-01-01\n-2019-10-01\n-2020-01-01\n-2020-01-01\n-2019-12-01\n-2020-01-01\n-2020-01-01\n-2019-12-30\n-2019-12-30\n-2019-12-30\n+2019-01-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-10-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-12-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-12-30 00:00:00\n+2019-12-30 00:00:00\n+2019-12-30 00:00:00\n 2019-12-31 00:00:00\n 2020-01-01 00:00:00\n 2020-01-02 00:00:00\n@@ -270,18 +270,18 @@ date_trunc\n 2019-12-31 20:11:22\n 2020-01-01 12:11:22\n 2020-01-02 05:11:22\n-2019-01-01\n-2020-01-01\n-2020-01-01\n-2019-10-01\n-2020-01-01\n-2020-01-01\n-2019-12-01\n-2020-01-01\n-2020-01-01\n-2019-12-30\n-2019-12-30\n-2019-12-30\n+2019-01-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-10-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-12-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-12-30 00:00:00\n+2019-12-30 00:00:00\n+2019-12-30 00:00:00\n 2019-12-31 00:00:00\n 2020-01-01 00:00:00\n 2020-01-02 00:00:00\n@@ -294,8 +294,8 @@ date_trunc\n 2019-12-31 20:11:22\n 2020-01-01 12:11:22\n 2020-01-02 05:11:22\n-2020-01-01\n-2020-01-01\n-2020-01-01\n-2019-12-30\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2020-01-01 00:00:00\n+2019-12-30 00:00:00\n 2020-01-01 00:00:00\ndiff --git a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\nindex 62de3a149a75..4f964f2478f7 100644\n--- a/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n+++ b/tests/queries/0_stateless/00921_datetime64_compatibility_long.reference\n@@ -135,13 +135,13 @@ Code: 43\n ------------------------------------------\n SELECT date_trunc(\\'year\\', N, \\'Asia/Istanbul\\')\n Code: 43\n-\"Date\",\"2019-01-01\"\n-\"Date\",\"2019-01-01\"\n+\"DateTime('Asia/Istanbul')\",\"2019-01-01 00:00:00\"\n+\"DateTime('Asia/Istanbul')\",\"2019-01-01 00:00:00\"\n ------------------------------------------\n SELECT date_trunc(\\'month\\', N, \\'Asia/Istanbul\\')\n Code: 43\n-\"Date\",\"2019-09-01\"\n-\"Date\",\"2019-09-01\"\n+\"DateTime('Asia/Istanbul')\",\"2019-09-01 00:00:00\"\n+\"DateTime('Asia/Istanbul')\",\"2019-09-01 00:00:00\"\n ------------------------------------------\n SELECT date_trunc(\\'day\\', N, \\'Asia/Istanbul\\')\n \"DateTime('Asia/Istanbul')\",\"2019-09-16 00:00:00\"\n",
  "problem_statement": "date_trunc with 'month' as first parameter returns Date instead of DateTime\nReading the related issue, I understand that ClickHouse's `date_trunc()` was modelled after Postgres's `DATE_TRUNC()`. However, while Postgres returns `DateTime` for every unit, ClickHouse returns `Date` for any unit larger than `day`. The documentation doesn't include this behavior, but says that the only return type is `DateTime`\r\n\r\nI pass the result of `date_trunc()` into `toUnixTimestamp()` so it's essential that the function returns `DateTime` for every unit.\n",
  "hints_text": "I found out about this while trying to make a `order by with fill from datetime to datetime interval 1 day`. \r\nBasically when there is date instead of datetime passed in from start, it just goes nuts and range starts from `1970-01-01 05:16:33` and I got thousands of rows back instead of 7 day range.\r\n",
  "created_at": "2023-04-17T14:37:22Z"
}