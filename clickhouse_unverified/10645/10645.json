{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10645,
  "instance_id": "ClickHouse__ClickHouse-10645",
  "issue_numbers": [
    "4966"
  ],
  "base_commit": "884c2aa63158e32385c41c562dbe238e71a1a584",
  "patch": "diff --git a/programs/compressor/Compressor.cpp b/programs/compressor/Compressor.cpp\nindex fecdad9bcead..701e8ea2d1ce 100644\n--- a/programs/compressor/Compressor.cpp\n+++ b/programs/compressor/Compressor.cpp\n@@ -63,6 +63,8 @@ void checkAndWriteHeader(DB::ReadBuffer & in, DB::WriteBuffer & out)\n \n int mainEntryClickHouseCompressor(int argc, char ** argv)\n {\n+    using namespace DB;\n+\n     boost::program_options::options_description desc = createOptionsDescription(\"Allowed options\", getTerminalWidth());\n     desc.add_options()\n         (\"help,h\", \"produce help message\")\n@@ -99,10 +101,10 @@ int mainEntryClickHouseCompressor(int argc, char ** argv)\n             codecs = options[\"codec\"].as<std::vector<std::string>>();\n \n         if ((use_lz4hc || use_zstd || use_none) && !codecs.empty())\n-            throw DB::Exception(\"Wrong options, codec flags like --zstd and --codec options are mutually exclusive\", DB::ErrorCodes::BAD_ARGUMENTS);\n+            throw Exception(\"Wrong options, codec flags like --zstd and --codec options are mutually exclusive\", ErrorCodes::BAD_ARGUMENTS);\n \n         if (!codecs.empty() && options.count(\"level\"))\n-            throw DB::Exception(\"Wrong options, --level is not compatible with --codec list\", DB::ErrorCodes::BAD_ARGUMENTS);\n+            throw Exception(\"Wrong options, --level is not compatible with --codec list\", ErrorCodes::BAD_ARGUMENTS);\n \n         std::string method_family = \"LZ4\";\n \n@@ -117,22 +119,21 @@ int mainEntryClickHouseCompressor(int argc, char ** argv)\n         if (options.count(\"level\"))\n             level = options[\"level\"].as<int>();\n \n-\n-        DB::CompressionCodecPtr codec;\n+        CompressionCodecPtr codec;\n         if (!codecs.empty())\n         {\n-            DB::ParserCodec codec_parser;\n+            ParserCodec codec_parser;\n \n             std::string codecs_line = boost::algorithm::join(codecs, \",\");\n-            auto ast = DB::parseQuery(codec_parser, \"(\" + codecs_line + \")\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n-            codec = DB::CompressionCodecFactory::instance().get(ast, nullptr);\n+            auto ast = parseQuery(codec_parser, \"(\" + codecs_line + \")\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n+            codec = CompressionCodecFactory::instance().get(ast, nullptr, false);\n         }\n         else\n-            codec = DB::CompressionCodecFactory::instance().get(method_family, level);\n+            codec = CompressionCodecFactory::instance().get(method_family, level, false);\n \n \n-        DB::ReadBufferFromFileDescriptor rb(STDIN_FILENO);\n-        DB::WriteBufferFromFileDescriptor wb(STDOUT_FILENO);\n+        ReadBufferFromFileDescriptor rb(STDIN_FILENO);\n+        WriteBufferFromFileDescriptor wb(STDOUT_FILENO);\n \n         if (stat_mode)\n         {\n@@ -142,20 +143,20 @@ int mainEntryClickHouseCompressor(int argc, char ** argv)\n         else if (decompress)\n         {\n             /// Decompression\n-            DB::CompressedReadBuffer from(rb);\n-            DB::copyData(from, wb);\n+            CompressedReadBuffer from(rb);\n+            copyData(from, wb);\n         }\n         else\n         {\n             /// Compression\n-            DB::CompressedWriteBuffer to(wb, codec, block_size);\n-            DB::copyData(rb, to);\n+            CompressedWriteBuffer to(wb, codec, block_size);\n+            copyData(rb, to);\n         }\n     }\n     catch (...)\n     {\n-        std::cerr << DB::getCurrentExceptionMessage(true);\n-        return DB::getCurrentExceptionCode();\n+        std::cerr << getCurrentExceptionMessage(true);\n+        return getCurrentExceptionCode();\n     }\n \n     return 0;\ndiff --git a/programs/server/TCPHandler.cpp b/programs/server/TCPHandler.cpp\nindex 70825cb4f7e8..f6903f0820f2 100644\n--- a/programs/server/TCPHandler.cpp\n+++ b/programs/server/TCPHandler.cpp\n@@ -1066,14 +1066,16 @@ void TCPHandler::initBlockOutput(const Block & block)\n     {\n         if (!state.maybe_compressed_out)\n         {\n-            std::string method = Poco::toUpper(query_context->getSettingsRef().network_compression_method.toString());\n+            const Settings & query_settings = query_context->getSettingsRef();\n+\n+            std::string method = Poco::toUpper(query_settings.network_compression_method.toString());\n             std::optional<int> level;\n             if (method == \"ZSTD\")\n-                level = query_context->getSettingsRef().network_zstd_compression_level;\n+                level = query_settings.network_zstd_compression_level;\n \n             if (state.compression == Protocol::Compression::Enable)\n                 state.maybe_compressed_out = std::make_shared<CompressedWriteBuffer>(\n-                    *out, CompressionCodecFactory::instance().get(method, level));\n+                    *out, CompressionCodecFactory::instance().get(method, level, !query_settings.allow_suspicious_codecs));\n             else\n                 state.maybe_compressed_out = out;\n         }\ndiff --git a/src/Client/Connection.cpp b/src/Client/Connection.cpp\nindex cc79e3ec2c89..7c46c82d8103 100644\n--- a/src/Client/Connection.cpp\n+++ b/src/Client/Connection.cpp\n@@ -379,7 +379,7 @@ void Connection::sendQuery(\n         if (method == \"ZSTD\")\n             level = settings->network_zstd_compression_level;\n \n-        compression_codec = CompressionCodecFactory::instance().get(method, level);\n+        compression_codec = CompressionCodecFactory::instance().get(method, level, !settings->allow_suspicious_codecs);\n     }\n     else\n         compression_codec = CompressionCodecFactory::instance().getDefaultCodec();\ndiff --git a/src/Compression/CompressionCodecDelta.h b/src/Compression/CompressionCodecDelta.h\nindex 6a5ad9330e24..1077a7915351 100644\n--- a/src/Compression/CompressionCodecDelta.h\n+++ b/src/Compression/CompressionCodecDelta.h\n@@ -23,6 +23,8 @@ class CompressionCodecDelta : public ICompressionCodec\n \n     UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override { return uncompressed_size + 2; }\n \n+    bool isCompression() const override { return false; }\n+    bool isGenericCompression() const override { return false; }\n \n private:\n     UInt8 delta_bytes_size;\ndiff --git a/src/Compression/CompressionCodecDoubleDelta.h b/src/Compression/CompressionCodecDoubleDelta.h\nindex 04bc112360ef..d0a7f4df8f93 100644\n--- a/src/Compression/CompressionCodecDoubleDelta.h\n+++ b/src/Compression/CompressionCodecDoubleDelta.h\n@@ -109,6 +109,9 @@ class CompressionCodecDoubleDelta : public ICompressionCodec\n \n     UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;\n \n+    bool isCompression() const override { return true; }\n+    bool isGenericCompression() const override { return false; }\n+\n private:\n     UInt8 data_bytes_size;\n };\ndiff --git a/src/Compression/CompressionCodecGorilla.h b/src/Compression/CompressionCodecGorilla.h\nindex e95de81afb0e..d11aeed6056e 100644\n--- a/src/Compression/CompressionCodecGorilla.h\n+++ b/src/Compression/CompressionCodecGorilla.h\n@@ -106,6 +106,9 @@ class CompressionCodecGorilla : public ICompressionCodec\n \n     UInt32 getMaxCompressedDataSize(UInt32 uncompressed_size) const override;\n \n+    bool isCompression() const override { return true; }\n+    bool isGenericCompression() const override { return false; }\n+\n private:\n     UInt8 data_bytes_size;\n };\ndiff --git a/src/Compression/CompressionCodecLZ4.h b/src/Compression/CompressionCodecLZ4.h\nindex d53fced36817..a73dd48a36ca 100644\n--- a/src/Compression/CompressionCodecLZ4.h\n+++ b/src/Compression/CompressionCodecLZ4.h\n@@ -21,6 +21,9 @@ class CompressionCodecLZ4 : public ICompressionCodec\n protected:\n     UInt32 doCompressData(const char * source, UInt32 source_size, char * dest) const override;\n \n+    bool isCompression() const override { return true; }\n+    bool isGenericCompression() const override { return true; }\n+\n private:\n     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n \ndiff --git a/src/Compression/CompressionCodecMultiple.cpp b/src/Compression/CompressionCodecMultiple.cpp\nindex 294a8c7629b2..d9a8c3cf8df1 100644\n--- a/src/Compression/CompressionCodecMultiple.cpp\n+++ b/src/Compression/CompressionCodecMultiple.cpp\n@@ -17,12 +17,34 @@ namespace DB\n \n namespace ErrorCodes\n {\n-extern const int CORRUPTED_DATA;\n+    extern const int CORRUPTED_DATA;\n+    extern const int BAD_ARGUMENTS;\n }\n \n-CompressionCodecMultiple::CompressionCodecMultiple(Codecs codecs_)\n+CompressionCodecMultiple::CompressionCodecMultiple(Codecs codecs_, bool sanity_check)\n     : codecs(codecs_)\n {\n+    if (sanity_check)\n+    {\n+        /// It does not make sense to apply any transformations after generic compression algorithm\n+        /// So, generic compression can be only one and only at the end.\n+        bool has_generic_compression = false;\n+        for (const auto & codec : codecs)\n+        {\n+            if (codec->isNone())\n+                throw Exception(\"It does not make sense to have codec NONE along with other compression codecs: \" + getCodecDescImpl()\n+                    + \". (Note: you can enable setting 'allow_suspicious_codecs' to skip this check).\",\n+                    ErrorCodes::BAD_ARGUMENTS);\n+\n+            if (has_generic_compression)\n+                throw Exception(\"The combination of compression codecs \" + getCodecDescImpl() + \" is meaningless,\"\n+                    \" because it does not make sense to apply any transformations after generic compression algorithm.\"\n+                    \" (Note: you can enable setting 'allow_suspicious_codecs' to skip this check).\", ErrorCodes::BAD_ARGUMENTS);\n+\n+            if (codec->isGenericCompression())\n+                has_generic_compression = true;\n+        }\n+    }\n }\n \n uint8_t CompressionCodecMultiple::getMethodByte() const\n@@ -31,6 +53,11 @@ uint8_t CompressionCodecMultiple::getMethodByte() const\n }\n \n String CompressionCodecMultiple::getCodecDesc() const\n+{\n+    return getCodecDescImpl();\n+}\n+\n+String CompressionCodecMultiple::getCodecDescImpl() const\n {\n     WriteBufferFromOwnString out;\n     for (size_t idx = 0; idx < codecs.size(); ++idx)\n@@ -120,6 +147,14 @@ void CompressionCodecMultiple::doDecompressData(const char * source, UInt32 sour\n     memcpy(dest, compressed_buf.data(), decompressed_size);\n }\n \n+bool CompressionCodecMultiple::isCompression() const\n+{\n+    for (const auto & codec : codecs)\n+        if (codec->isCompression())\n+            return true;\n+    return false;\n+}\n+\n void registerCodecMultiple(CompressionCodecFactory & factory)\n {\n     factory.registerSimpleCompressionCodec(\"Multiple\", static_cast<UInt8>(CompressionMethodByte::Multiple), [&] ()\ndiff --git a/src/Compression/CompressionCodecMultiple.h b/src/Compression/CompressionCodecMultiple.h\nindex 68d2c934fa3d..ff208d619cbf 100644\n--- a/src/Compression/CompressionCodecMultiple.h\n+++ b/src/Compression/CompressionCodecMultiple.h\n@@ -9,7 +9,7 @@ class CompressionCodecMultiple final : public ICompressionCodec\n {\n public:\n     CompressionCodecMultiple() = default;\n-    explicit CompressionCodecMultiple(Codecs codecs_);\n+    CompressionCodecMultiple(Codecs codecs_, bool sanity_check);\n \n     uint8_t getMethodByte() const override;\n \n@@ -24,9 +24,13 @@ class CompressionCodecMultiple final : public ICompressionCodec\n \n     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 decompressed_size) const override;\n \n+    bool isCompression() const override;\n+    bool isGenericCompression() const override { return false; }\n+\n private:\n     Codecs codecs;\n \n+    String getCodecDescImpl() const;\n };\n \n \ndiff --git a/src/Compression/CompressionCodecNone.h b/src/Compression/CompressionCodecNone.h\nindex 168a15bec2f4..ef7029e244b5 100644\n--- a/src/Compression/CompressionCodecNone.h\n+++ b/src/Compression/CompressionCodecNone.h\n@@ -20,6 +20,9 @@ class CompressionCodecNone : public ICompressionCodec\n \n     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n \n+    bool isCompression() const override { return false; }\n+    bool isGenericCompression() const override { return false; }\n+    bool isNone() const override { return true; }\n };\n \n class CompressionCodecFactory;\ndiff --git a/src/Compression/CompressionCodecT64.h b/src/Compression/CompressionCodecT64.h\nindex c95e14e860d3..cafc9959a9d9 100644\n--- a/src/Compression/CompressionCodecT64.h\n+++ b/src/Compression/CompressionCodecT64.h\n@@ -48,6 +48,9 @@ class CompressionCodecT64 : public ICompressionCodec\n         return uncompressed_size + MAX_COMPRESSED_BLOCK_SIZE + HEADER_SIZE;\n     }\n \n+    bool isCompression() const override { return true; }\n+    bool isGenericCompression() const override { return false; }\n+\n private:\n     TypeIndex type_idx;\n     Variant variant;\ndiff --git a/src/Compression/CompressionCodecZSTD.h b/src/Compression/CompressionCodecZSTD.h\nindex 045602c66eab..234f49b279be 100644\n--- a/src/Compression/CompressionCodecZSTD.h\n+++ b/src/Compression/CompressionCodecZSTD.h\n@@ -26,6 +26,9 @@ class CompressionCodecZSTD : public ICompressionCodec\n \n     void doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const override;\n \n+    bool isCompression() const override { return true; }\n+    bool isGenericCompression() const override { return true; }\n+\n private:\n     const int level;\n };\ndiff --git a/src/Compression/CompressionFactory.cpp b/src/Compression/CompressionFactory.cpp\nindex d58a42423c5f..5d5c5c14de69 100644\n--- a/src/Compression/CompressionFactory.cpp\n+++ b/src/Compression/CompressionFactory.cpp\n@@ -19,6 +19,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int UNKNOWN_CODEC;\n+    extern const int BAD_ARGUMENTS;\n     extern const int UNEXPECTED_AST_STRUCTURE;\n     extern const int DATA_TYPE_CANNOT_HAVE_ARGUMENTS;\n }\n@@ -29,22 +30,22 @@ CompressionCodecPtr CompressionCodecFactory::getDefaultCodec() const\n }\n \n \n-CompressionCodecPtr CompressionCodecFactory::get(const String & family_name, std::optional<int> level) const\n+CompressionCodecPtr CompressionCodecFactory::get(const String & family_name, std::optional<int> level, bool sanity_check) const\n {\n     if (level)\n     {\n         auto literal = std::make_shared<ASTLiteral>(static_cast<UInt64>(*level));\n-        return get(makeASTFunction(\"CODEC\", makeASTFunction(Poco::toUpper(family_name), literal)));\n+        return get(makeASTFunction(\"CODEC\", makeASTFunction(Poco::toUpper(family_name), literal)), {}, sanity_check);\n     }\n     else\n     {\n         auto identifier = std::make_shared<ASTIdentifier>(Poco::toUpper(family_name));\n-        return get(makeASTFunction(\"CODEC\", identifier));\n+        return get(makeASTFunction(\"CODEC\", identifier), {}, sanity_check);\n     }\n }\n \n \n-CompressionCodecPtr CompressionCodecFactory::get(const ASTPtr & ast, DataTypePtr column_type) const\n+CompressionCodecPtr CompressionCodecFactory::get(const ASTPtr & ast, DataTypePtr column_type, bool sanity_check) const\n {\n     if (const auto * func = ast->as<ASTFunction>())\n     {\n@@ -60,10 +61,22 @@ CompressionCodecPtr CompressionCodecFactory::get(const ASTPtr & ast, DataTypePtr\n                 throw Exception(\"Unexpected AST element for compression codec\", ErrorCodes::UNEXPECTED_AST_STRUCTURE);\n         }\n \n+        CompressionCodecPtr res;\n+\n         if (codecs.size() == 1)\n-            return codecs.back();\n+            res = codecs.back();\n         else if (codecs.size() > 1)\n-            return std::make_shared<CompressionCodecMultiple>(codecs);\n+            res = std::make_shared<CompressionCodecMultiple>(codecs, sanity_check);\n+\n+        /// Allow to explicitly specify single NONE codec if user don't want any compression.\n+        /// But applying other transformations solely without compression (e.g. Delta) does not make sense.\n+        if (sanity_check && !res->isCompression() && !res->isNone())\n+            throw Exception(\"Compression codec \" + res->getCodecDesc() + \" does not compress anything.\"\n+                \" You may want to add generic compression algorithm after other transformations, like: \" + res->getCodecDesc() + \", LZ4.\"\n+                \" (Note: you can enable setting 'allow_suspicious_codecs' to skip this check).\",\n+                ErrorCodes::BAD_ARGUMENTS);\n+\n+        return res;\n     }\n \n     throw Exception(\"Unknown codec family: \" + queryToString(ast), ErrorCodes::UNKNOWN_CODEC);\ndiff --git a/src/Compression/CompressionFactory.h b/src/Compression/CompressionFactory.h\nindex 926929abd186..58799538f8c2 100644\n--- a/src/Compression/CompressionFactory.h\n+++ b/src/Compression/CompressionFactory.h\n@@ -40,13 +40,13 @@ class CompressionCodecFactory final : private boost::noncopyable\n     /// Get codec by AST and possible column_type\n     /// some codecs can use information about type to improve inner settings\n     /// but every codec should be able to work without information about type\n-    CompressionCodecPtr get(const ASTPtr & ast, DataTypePtr column_type = nullptr) const;\n+    CompressionCodecPtr get(const ASTPtr & ast, DataTypePtr column_type, bool sanity_check) const;\n \n     /// Get codec by method byte (no params available)\n     CompressionCodecPtr get(const uint8_t byte_code) const;\n \n     /// For backward compatibility with config settings\n-    CompressionCodecPtr get(const String & family_name, std::optional<int> level) const;\n+    CompressionCodecPtr get(const String & family_name, std::optional<int> level, bool sanity_check) const;\n \n     /// Register codec with parameters and column type\n     void registerCompressionCodecWithType(const String & family_name, std::optional<uint8_t> byte_code, CreatorWithType creator);\ndiff --git a/src/Compression/ICompressionCodec.h b/src/Compression/ICompressionCodec.h\nindex 083824cf0ca7..cac42ee61f48 100644\n--- a/src/Compression/ICompressionCodec.h\n+++ b/src/Compression/ICompressionCodec.h\n@@ -57,7 +57,16 @@ class ICompressionCodec : private boost::noncopyable\n     static uint8_t readMethod(const char * source);\n \n     /// Some codecs may use information about column type which appears after codec creation\n-    virtual void useInfoAboutType(DataTypePtr /* data_type */) { }\n+    virtual void useInfoAboutType(DataTypePtr /* data_type */) {}\n+\n+    /// Return true if this codec actually compressing something. Otherwise it can be just transformation that helps compression (e.g. Delta).\n+    virtual bool isCompression() const = 0;\n+\n+    /// Is it a generic compression algorithm like lz4, zstd. Usually it does not make sense to apply generic compression more than single time.\n+    virtual bool isGenericCompression() const = 0;\n+\n+    /// If it does nothing.\n+    virtual bool isNone() const { return false; }\n \n protected:\n \ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 88b83be5add2..d1a51d7a10c7 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -265,6 +265,7 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, joined_subquery_requires_alias, true, \"Force joined subqueries and table functions to have aliases for correct name qualification.\", 0) \\\n     M(SettingBool, empty_result_for_aggregation_by_empty_set, false, \"Return empty result when aggregating without keys on empty set.\", 0) \\\n     M(SettingBool, allow_distributed_ddl, true, \"If it is set to true, then a user is allowed to executed distributed DDL queries.\", 0) \\\n+    M(SettingBool, allow_suspicious_codecs, false, \"If it is set to true, allow to specify meaningless compression codecs.\", 0) \\\n     M(SettingUInt64, odbc_max_field_size, 1024, \"Max size of filed can be read from ODBC dictionary. Long strings are truncated.\", 0) \\\n     M(SettingUInt64, query_profiler_real_time_period_ns, 1000000000, \"Period for real clock timer of query profiler (in nanoseconds). Set 0 value to turn off the real clock query profiler. Recommended value is at least 10000000 (100 times a second) for single queries or 1000000000 (once a second) for cluster-wide profiling.\", 0) \\\n     M(SettingUInt64, query_profiler_cpu_time_period_ns, 1000000000, \"Period for CPU clock timer of query profiler (in nanoseconds). Set 0 value to turn off the CPU clock query profiler. Recommended value is at least 10000000 (100 times a second) for single queries or 1000000000 (once a second) for cluster-wide profiling.\", 0) \\\ndiff --git a/src/DataStreams/TemporaryFileStream.h b/src/DataStreams/TemporaryFileStream.h\nindex 6871800a5401..ddb2190f1756 100644\n--- a/src/DataStreams/TemporaryFileStream.h\n+++ b/src/DataStreams/TemporaryFileStream.h\n@@ -37,7 +37,7 @@ struct TemporaryFileStream\n                       std::atomic<bool> * is_cancelled, const std::string & codec)\n     {\n         WriteBufferFromFile file_buf(path);\n-        CompressedWriteBuffer compressed_buf(file_buf, CompressionCodecFactory::instance().get(codec, {}));\n+        CompressedWriteBuffer compressed_buf(file_buf, CompressionCodecFactory::instance().get(codec, {}, false));\n         NativeBlockOutputStream output(compressed_buf, 0, header);\n         copyData(input, output, is_cancelled);\n     }\ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex da38dc3b8f73..aed9f38c2eaa 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -65,7 +65,7 @@ std::pair<String, StoragePtr> createTableFromAST(\n     if (!ast_create_query.columns_list || !ast_create_query.columns_list->columns)\n         throw Exception(\"Missing definition of columns.\", ErrorCodes::EMPTY_LIST_OF_COLUMNS_PASSED);\n \n-    ColumnsDescription columns = InterpreterCreateQuery::getColumnsDescription(*ast_create_query.columns_list->columns, context);\n+    ColumnsDescription columns = InterpreterCreateQuery::getColumnsDescription(*ast_create_query.columns_list->columns, context, false);\n     ConstraintsDescription constraints = InterpreterCreateQuery::getConstraintsDescription(ast_create_query.columns_list->constraints);\n \n     return\ndiff --git a/src/Interpreters/InterpreterAlterQuery.cpp b/src/Interpreters/InterpreterAlterQuery.cpp\nindex c8517defdb7b..c2ab8776c253 100644\n--- a/src/Interpreters/InterpreterAlterQuery.cpp\n+++ b/src/Interpreters/InterpreterAlterQuery.cpp\n@@ -56,7 +56,7 @@ BlockIO InterpreterAlterQuery::execute()\n     LiveViewCommands live_view_commands;\n     for (ASTAlterCommand * command_ast : alter.command_list->commands)\n     {\n-        if (auto alter_command = AlterCommand::parse(command_ast))\n+        if (auto alter_command = AlterCommand::parse(command_ast, !context.getSettingsRef().allow_suspicious_codecs))\n             alter_commands.emplace_back(std::move(*alter_command));\n         else if (auto partition_command = PartitionCommand::parse(command_ast))\n         {\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 43a0a7f608e5..147ef7d739b3 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -267,7 +267,8 @@ ASTPtr InterpreterCreateQuery::formatConstraints(const ConstraintsDescription &\n     return res;\n }\n \n-ColumnsDescription InterpreterCreateQuery::getColumnsDescription(const ASTExpressionList & columns_ast, const Context & context)\n+ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n+    const ASTExpressionList & columns_ast, const Context & context, bool sanity_check_compression_codecs)\n {\n     /// First, deduce implicit types.\n \n@@ -355,7 +356,7 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(const ASTExpres\n             column.comment = col_decl.comment->as<ASTLiteral &>().value.get<String>();\n \n         if (col_decl.codec)\n-            column.codec = CompressionCodecFactory::instance().get(col_decl.codec, column.type);\n+            column.codec = CompressionCodecFactory::instance().get(col_decl.codec, column.type, sanity_check_compression_codecs);\n \n         if (col_decl.ttl)\n             column.ttl = col_decl.ttl;\n@@ -390,7 +391,10 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::setProperties(AS\n     if (create.columns_list)\n     {\n         if (create.columns_list->columns)\n-            properties.columns = getColumnsDescription(*create.columns_list->columns, context);\n+        {\n+            bool sanity_check_compression_codecs = !create.attach && !context.getSettingsRef().allow_suspicious_codecs;\n+            properties.columns = getColumnsDescription(*create.columns_list->columns, context, sanity_check_compression_codecs);\n+        }\n \n         if (create.columns_list->indices)\n             for (const auto & index : create.columns_list->indices->children)\ndiff --git a/src/Interpreters/InterpreterCreateQuery.h b/src/Interpreters/InterpreterCreateQuery.h\nindex c52c12b2e4b5..2ce98b7b2c29 100644\n--- a/src/Interpreters/InterpreterCreateQuery.h\n+++ b/src/Interpreters/InterpreterCreateQuery.h\n@@ -46,7 +46,7 @@ class InterpreterCreateQuery : public IInterpreter\n     }\n \n     /// Obtain information about columns, their types, default values and column comments, for case when columns in CREATE query is specified explicitly.\n-    static ColumnsDescription getColumnsDescription(const ASTExpressionList & columns, const Context & context);\n+    static ColumnsDescription getColumnsDescription(const ASTExpressionList & columns, const Context & context, bool sanity_check_compression_codecs);\n     static ConstraintsDescription getConstraintsDescription(const ASTExpressionList * constraints);\n \n private:\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex ebf4875b4351..caa7dfb69d5e 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -343,7 +343,7 @@ StoragePtr InterpreterSystemQuery::tryRestartReplica(const StorageID & replica,\n     auto & create = create_ast->as<ASTCreateQuery &>();\n     create.attach = true;\n \n-    auto columns = InterpreterCreateQuery::getColumnsDescription(*create.columns_list->columns, system_context);\n+    auto columns = InterpreterCreateQuery::getColumnsDescription(*create.columns_list->columns, system_context, false);\n     auto constraints = InterpreterCreateQuery::getConstraintsDescription(create.columns_list->constraints);\n     auto data_path = database->getTableDataPath(create);\n \ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex 04639ea0e3d1..121974c8b82d 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -44,7 +44,7 @@ namespace ErrorCodes\n }\n \n \n-std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_ast)\n+std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_ast, bool sanity_check_compression_codecs)\n {\n     const DataTypeFactory & data_type_factory = DataTypeFactory::instance();\n     const CompressionCodecFactory & compression_codec_factory = CompressionCodecFactory::instance();\n@@ -75,7 +75,7 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n         }\n \n         if (ast_col_decl.codec)\n-            command.codec = compression_codec_factory.get(ast_col_decl.codec, command.data_type);\n+            command.codec = compression_codec_factory.get(ast_col_decl.codec, command.data_type, sanity_check_compression_codecs);\n \n         if (command_ast->column)\n             command.after_column = getIdentifierName(command_ast->column);\n@@ -131,7 +131,7 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n             command.ttl = ast_col_decl.ttl;\n \n         if (ast_col_decl.codec)\n-            command.codec = compression_codec_factory.get(ast_col_decl.codec, command.data_type);\n+            command.codec = compression_codec_factory.get(ast_col_decl.codec, command.data_type, sanity_check_compression_codecs);\n \n         command.if_exists = command_ast->if_exists;\n \ndiff --git a/src/Storages/AlterCommands.h b/src/Storages/AlterCommands.h\nindex 4e40c1ee190d..c1c913dad73a 100644\n--- a/src/Storages/AlterCommands.h\n+++ b/src/Storages/AlterCommands.h\n@@ -100,7 +100,7 @@ struct AlterCommand\n     /// Target column name\n     String rename_to;\n \n-    static std::optional<AlterCommand> parse(const ASTAlterCommand * command);\n+    static std::optional<AlterCommand> parse(const ASTAlterCommand * command, bool sanity_check_compression_codecs);\n \n     void apply(StorageInMemoryMetadata & metadata) const;\n \ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex 14c0da01a732..8c92307dcb7d 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -120,7 +120,7 @@ void ColumnDescription::readText(ReadBuffer & buf)\n             comment = col_ast->comment->as<ASTLiteral &>().value.get<String>();\n \n         if (col_ast->codec)\n-            codec = CompressionCodecFactory::instance().get(col_ast->codec, type);\n+            codec = CompressionCodecFactory::instance().get(col_ast->codec, type, false);\n \n         if (col_ast->ttl)\n             ttl = col_ast->ttl;\ndiff --git a/src/Storages/CompressionCodecSelector.h b/src/Storages/CompressionCodecSelector.h\nindex d194adc93177..0924550fceaf 100644\n--- a/src/Storages/CompressionCodecSelector.h\n+++ b/src/Storages/CompressionCodecSelector.h\n@@ -91,7 +91,7 @@ class CompressionCodecSelector\n \n         for (const auto & element : elements)\n             if (element.check(part_size, part_size_ratio))\n-                res = factory.get(element.family_name, element.level);\n+                res = factory.get(element.family_name, element.level, false);\n \n         return res;\n     }\ndiff --git a/src/TableFunctions/parseColumnsListForTableFunction.cpp b/src/TableFunctions/parseColumnsListForTableFunction.cpp\nindex c419164ac38f..8eea3edf9bd5 100644\n--- a/src/TableFunctions/parseColumnsListForTableFunction.cpp\n+++ b/src/TableFunctions/parseColumnsListForTableFunction.cpp\n@@ -31,7 +31,7 @@ ColumnsDescription parseColumnsListFromString(const std::string & structure, con\n     if (!columns_list)\n         throw Exception(\"Could not cast AST to ASTExpressionList\", ErrorCodes::LOGICAL_ERROR);\n \n-    return InterpreterCreateQuery::getColumnsDescription(*columns_list, context);\n+    return InterpreterCreateQuery::getColumnsDescription(*columns_list, context, !context.getSettingsRef().allow_suspicious_codecs);\n }\n \n }\n",
  "test_patch": "diff --git a/src/Compression/tests/gtest_compressionCodec.cpp b/src/Compression/tests/gtest_compressionCodec.cpp\nindex f3652366a24f..eca1c3c0a8f2 100644\n--- a/src/Compression/tests/gtest_compressionCodec.cpp\n+++ b/src/Compression/tests/gtest_compressionCodec.cpp\n@@ -470,7 +470,7 @@ CompressionCodecPtr makeCodec(const std::string & codec_string, const DataTypePt\n \n     parser.parse(token_iterator, codec_ast, expected);\n \n-    return CompressionCodecFactory::instance().get(codec_ast, data_type);\n+    return CompressionCodecFactory::instance().get(codec_ast, data_type, false);\n }\n \n template <typename Timer>\ndiff --git a/tests/integration/test_non_default_compression/configs/allow_suspicious_codecs.xml b/tests/integration/test_non_default_compression/configs/allow_suspicious_codecs.xml\nnew file mode 100644\nindex 000000000000..eb75c339e510\n--- /dev/null\n+++ b/tests/integration/test_non_default_compression/configs/allow_suspicious_codecs.xml\n@@ -0,0 +1,7 @@\n+<yandex>\n+    <profiles>\n+        <default>\n+            <allow_suspicious_codecs>1</allow_suspicious_codecs>\n+        </default>\n+    </profiles>\n+</yandex>\ndiff --git a/tests/integration/test_non_default_compression/configs/enable_uncompressed_cache.xml b/tests/integration/test_non_default_compression/configs/enable_uncompressed_cache.xml\nindex c899b1225195..15ebf6a74ded 100644\n--- a/tests/integration/test_non_default_compression/configs/enable_uncompressed_cache.xml\n+++ b/tests/integration/test_non_default_compression/configs/enable_uncompressed_cache.xml\n@@ -1,24 +1,7 @@\n-<?xml version=\"1.0\"?>\n <yandex>\n     <profiles>\n         <default>\n             <use_uncompressed_cache>1</use_uncompressed_cache>\n         </default>\n     </profiles>\n-    <users>\n-        <default>\n-            <password></password>\n-            <networks incl=\"networks\" replace=\"replace\">\n-                <ip>::/0</ip>\n-            </networks>\n-            <profile>default</profile>\n-            <quota>default</quota>\n-        </default>\n-    </users>\n-\n-    <quotas>\n-        <default>\n-        </default>\n-    </quotas>\n-\n </yandex>\ndiff --git a/tests/integration/test_non_default_compression/test.py b/tests/integration/test_non_default_compression/test.py\nindex f5fe349a929a..2c099e84e89b 100644\n--- a/tests/integration/test_non_default_compression/test.py\n+++ b/tests/integration/test_non_default_compression/test.py\n@@ -7,11 +7,11 @@\n \n cluster = ClickHouseCluster(__file__)\n \n-node1 = cluster.add_instance('node1', main_configs=['configs/zstd_compression_by_default.xml'])\n-node2 = cluster.add_instance('node2', main_configs=['configs/lz4hc_compression_by_default.xml'])\n-node3 = cluster.add_instance('node3', main_configs=['configs/custom_compression_by_default.xml'])\n-node4 = cluster.add_instance('node4', user_configs=['configs/enable_uncompressed_cache.xml'])\n-node5 = cluster.add_instance('node5', main_configs=['configs/zstd_compression_by_default.xml'], user_configs=['configs/enable_uncompressed_cache.xml'])\n+node1 = cluster.add_instance('node1', main_configs=['configs/zstd_compression_by_default.xml'], user_configs=['configs/allow_suspicious_codecs.xml'])\n+node2 = cluster.add_instance('node2', main_configs=['configs/lz4hc_compression_by_default.xml'], user_configs=['configs/allow_suspicious_codecs.xml'])\n+node3 = cluster.add_instance('node3', main_configs=['configs/custom_compression_by_default.xml'], user_configs=['configs/allow_suspicious_codecs.xml'])\n+node4 = cluster.add_instance('node4', user_configs=['configs/enable_uncompressed_cache.xml', 'configs/allow_suspicious_codecs.xml'])\n+node5 = cluster.add_instance('node5', main_configs=['configs/zstd_compression_by_default.xml'], user_configs=['configs/enable_uncompressed_cache.xml', 'configs/allow_suspicious_codecs.xml'])\n \n @pytest.fixture(scope=\"module\")\n def start_cluster():\ndiff --git a/tests/queries/0_stateless/00804_test_alter_compression_codecs.sql b/tests/queries/0_stateless/00804_test_alter_compression_codecs.sql\nindex d071fc1831a0..8a4cb9f81d7f 100644\n--- a/tests/queries/0_stateless/00804_test_alter_compression_codecs.sql\n+++ b/tests/queries/0_stateless/00804_test_alter_compression_codecs.sql\n@@ -28,6 +28,7 @@ SELECT * FROM alter_compression_codec ORDER BY id;\n OPTIMIZE TABLE alter_compression_codec FINAL;\n SELECT * FROM alter_compression_codec ORDER BY id;\n \n+SET allow_suspicious_codecs = 1;\n ALTER TABLE alter_compression_codec MODIFY COLUMN alter_column CODEC(ZSTD, LZ4HC, LZ4, LZ4, NONE);\n SELECT compression_codec FROM system.columns WHERE database = currentDatabase() AND table = 'alter_compression_codec' AND name = 'alter_column';\n \ndiff --git a/tests/queries/0_stateless/00804_test_custom_compression_codecs.sql b/tests/queries/0_stateless/00804_test_custom_compression_codecs.sql\nindex 973230be60ef..2c7b3b39469a 100644\n--- a/tests/queries/0_stateless/00804_test_custom_compression_codecs.sql\n+++ b/tests/queries/0_stateless/00804_test_custom_compression_codecs.sql\n@@ -1,4 +1,5 @@\n SET send_logs_level = 'none';\n+SET allow_suspicious_codecs = 1;\n \n DROP TABLE IF EXISTS compression_codec;\n \ndiff --git a/tests/queries/0_stateless/00804_test_custom_compression_codes_log_storages.sql b/tests/queries/0_stateless/00804_test_custom_compression_codes_log_storages.sql\nindex 5210b1d7706e..f61adccefd57 100644\n--- a/tests/queries/0_stateless/00804_test_custom_compression_codes_log_storages.sql\n+++ b/tests/queries/0_stateless/00804_test_custom_compression_codes_log_storages.sql\n@@ -1,4 +1,5 @@\n SET send_logs_level = 'none';\n+SET allow_suspicious_codecs = 1;\n \n -- copy-paste for storage log\n \ndiff --git a/tests/queries/0_stateless/00804_test_delta_codec_no_type_alter.sql b/tests/queries/0_stateless/00804_test_delta_codec_no_type_alter.sql\nindex 69afc2d4915d..f49b8b2ee32d 100644\n--- a/tests/queries/0_stateless/00804_test_delta_codec_no_type_alter.sql\n+++ b/tests/queries/0_stateless/00804_test_delta_codec_no_type_alter.sql\n@@ -1,4 +1,5 @@\n SET send_logs_level = 'none';\n+SET allow_suspicious_codecs = 1;\n \n DROP TABLE IF EXISTS delta_codec_for_alter;\n CREATE TABLE delta_codec_for_alter (date Date, x UInt32 Codec(Delta), s FixedString(128)) ENGINE = MergeTree ORDER BY tuple();\ndiff --git a/tests/queries/0_stateless/00910_zookeeper_custom_compression_codecs_replicated.sql b/tests/queries/0_stateless/00910_zookeeper_custom_compression_codecs_replicated.sql\nindex d3bbbacd2a6c..be83f040e044 100644\n--- a/tests/queries/0_stateless/00910_zookeeper_custom_compression_codecs_replicated.sql\n+++ b/tests/queries/0_stateless/00910_zookeeper_custom_compression_codecs_replicated.sql\n@@ -1,4 +1,5 @@\n SET send_logs_level = 'none';\n+SET allow_suspicious_codecs = 1;\n \n DROP TABLE IF EXISTS test.compression_codec_replicated1;\n DROP TABLE IF EXISTS test.compression_codec_replicated2;\ndiff --git a/tests/queries/0_stateless/00910_zookeeper_test_alter_compression_codecs.sql b/tests/queries/0_stateless/00910_zookeeper_test_alter_compression_codecs.sql\nindex d9ca0595fa53..cec9ff86cd0c 100644\n--- a/tests/queries/0_stateless/00910_zookeeper_test_alter_compression_codecs.sql\n+++ b/tests/queries/0_stateless/00910_zookeeper_test_alter_compression_codecs.sql\n@@ -46,6 +46,7 @@ SYSTEM SYNC REPLICA alter_compression_codec1;\n SELECT * FROM alter_compression_codec1 ORDER BY id;\n SELECT * FROM alter_compression_codec2 ORDER BY id;\n \n+SET allow_suspicious_codecs = 1;\n ALTER TABLE alter_compression_codec1 MODIFY COLUMN alter_column CODEC(ZSTD, LZ4HC, LZ4, LZ4, NONE);\n SYSTEM SYNC REPLICA alter_compression_codec1;\n SYSTEM SYNC REPLICA alter_compression_codec2;\ndiff --git a/tests/queries/0_stateless/00926_adaptive_index_granularity_pk.sql b/tests/queries/0_stateless/00926_adaptive_index_granularity_pk.sql\nindex e79731edad73..53e640a40327 100644\n--- a/tests/queries/0_stateless/00926_adaptive_index_granularity_pk.sql\n+++ b/tests/queries/0_stateless/00926_adaptive_index_granularity_pk.sql\n@@ -57,6 +57,7 @@ SET force_primary_key = 0;\n DROP TABLE IF EXISTS large_alter_table_00926;\n DROP TABLE IF EXISTS store_of_hash_00926;\n \n+SET allow_suspicious_codecs = 1;\n CREATE TABLE large_alter_table_00926 (\n     somedate Date CODEC(ZSTD, ZSTD, ZSTD(12), LZ4HC(12)),\n     id UInt64 CODEC(LZ4, ZSTD, NONE, LZ4HC),\ndiff --git a/tests/queries/0_stateless/00957_delta_diff_bug.sql b/tests/queries/0_stateless/00957_delta_diff_bug.sql\nindex 0c5fb6ce7e1a..86584d3cdf35 100644\n--- a/tests/queries/0_stateless/00957_delta_diff_bug.sql\n+++ b/tests/queries/0_stateless/00957_delta_diff_bug.sql\n@@ -1,3 +1,5 @@\n+SET allow_suspicious_codecs = 1;\n+\n DROP TABLE IF EXISTS segfault_table;\n \n CREATE TABLE segfault_table (id UInt16 CODEC(Delta(2))) ENGINE MergeTree() order by tuple();\ndiff --git a/tests/queries/0_stateless/01272_suspicious_codecs.reference b/tests/queries/0_stateless/01272_suspicious_codecs.reference\nnew file mode 100644\nindex 000000000000..559b6df2693e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01272_suspicious_codecs.reference\n@@ -0,0 +1,16 @@\n+CREATE TABLE default.codecs1\\n(\\n    `a` UInt8 CODEC(NONE, NONE)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs2\\n(\\n    `a` UInt8 CODEC(NONE, LZ4)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs3\\n(\\n    `a` UInt8 CODEC(LZ4, NONE)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs4\\n(\\n    `a` UInt8 CODEC(LZ4, LZ4)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs5\\n(\\n    `a` UInt8 CODEC(LZ4, ZSTD(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs6\\n(\\n    `a` UInt8 CODEC(Delta(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs7\\n(\\n    `a` UInt8 CODEC(Delta(1), Delta(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs8\\n(\\n    `a` UInt8 CODEC(LZ4, Delta(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs1\\n(\\n    `a` UInt8 CODEC(NONE, NONE)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs2\\n(\\n    `a` UInt8 CODEC(NONE, LZ4)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs3\\n(\\n    `a` UInt8 CODEC(LZ4, NONE)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs4\\n(\\n    `a` UInt8 CODEC(LZ4, LZ4)\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs5\\n(\\n    `a` UInt8 CODEC(LZ4, ZSTD(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs6\\n(\\n    `a` UInt8 CODEC(Delta(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs7\\n(\\n    `a` UInt8 CODEC(Delta(1), Delta(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.codecs8\\n(\\n    `a` UInt8 CODEC(LZ4, Delta(1))\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\ndiff --git a/tests/queries/0_stateless/01272_suspicious_codecs.sql b/tests/queries/0_stateless/01272_suspicious_codecs.sql\nnew file mode 100644\nindex 000000000000..3ec3e480da40\n--- /dev/null\n+++ b/tests/queries/0_stateless/01272_suspicious_codecs.sql\n@@ -0,0 +1,107 @@\n+DROP TABLE IF EXISTS codecs;\n+\n+-- test what should work\n+\n+CREATE TABLE codecs\n+(\n+    a UInt8 CODEC(LZ4),\n+    b UInt16 CODEC(ZSTD),\n+    c Float32 CODEC(Gorilla),\n+    d UInt8 CODEC(Delta, LZ4),\n+    e Float64 CODEC(Gorilla, ZSTD),\n+    f UInt32 CODEC(Delta, Delta, Gorilla),\n+    g DateTime CODEC(DoubleDelta),\n+    h DateTime64 CODEC(DoubleDelta, LZ4),\n+    i String CODEC(NONE)\n+) ENGINE = MergeTree ORDER BY tuple();\n+\n+DROP TABLE codecs;\n+\n+-- test what should not work\n+\n+CREATE TABLE codecs (a UInt8 CODEC(NONE, NONE)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(NONE, LZ4)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(LZ4, NONE)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(LZ4, LZ4)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(LZ4, ZSTD)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(Delta)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(Delta, Delta)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+CREATE TABLE codecs (a UInt8 CODEC(LZ4, Delta)) ENGINE = MergeTree ORDER BY tuple(); -- { serverError 36 }\n+\n+-- test that sanity check is not performed in ATTACH query\n+\n+DROP TABLE IF EXISTS codecs1;\n+DROP TABLE IF EXISTS codecs2;\n+DROP TABLE IF EXISTS codecs3;\n+DROP TABLE IF EXISTS codecs4;\n+DROP TABLE IF EXISTS codecs5;\n+DROP TABLE IF EXISTS codecs6;\n+DROP TABLE IF EXISTS codecs7;\n+DROP TABLE IF EXISTS codecs8;\n+\n+SET allow_suspicious_codecs = 1;\n+\n+CREATE TABLE codecs1 (a UInt8 CODEC(NONE, NONE)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs2 (a UInt8 CODEC(NONE, LZ4)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs3 (a UInt8 CODEC(LZ4, NONE)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs4 (a UInt8 CODEC(LZ4, LZ4)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs5 (a UInt8 CODEC(LZ4, ZSTD)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs6 (a UInt8 CODEC(Delta)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs7 (a UInt8 CODEC(Delta, Delta)) ENGINE = MergeTree ORDER BY tuple();\n+CREATE TABLE codecs8 (a UInt8 CODEC(LZ4, Delta)) ENGINE = MergeTree ORDER BY tuple();\n+\n+SET allow_suspicious_codecs = 0;\n+\n+SHOW CREATE TABLE codecs1;\n+SHOW CREATE TABLE codecs2;\n+SHOW CREATE TABLE codecs3;\n+SHOW CREATE TABLE codecs4;\n+SHOW CREATE TABLE codecs5;\n+SHOW CREATE TABLE codecs6;\n+SHOW CREATE TABLE codecs7;\n+SHOW CREATE TABLE codecs8;\n+\n+DETACH TABLE codecs1;\n+DETACH TABLE codecs2;\n+DETACH TABLE codecs3;\n+DETACH TABLE codecs4;\n+DETACH TABLE codecs5;\n+DETACH TABLE codecs6;\n+DETACH TABLE codecs7;\n+DETACH TABLE codecs8;\n+\n+ATTACH TABLE codecs1;\n+ATTACH TABLE codecs2;\n+ATTACH TABLE codecs3;\n+ATTACH TABLE codecs4;\n+ATTACH TABLE codecs5;\n+ATTACH TABLE codecs6;\n+ATTACH TABLE codecs7;\n+ATTACH TABLE codecs8;\n+\n+SHOW CREATE TABLE codecs1;\n+SHOW CREATE TABLE codecs2;\n+SHOW CREATE TABLE codecs3;\n+SHOW CREATE TABLE codecs4;\n+SHOW CREATE TABLE codecs5;\n+SHOW CREATE TABLE codecs6;\n+SHOW CREATE TABLE codecs7;\n+SHOW CREATE TABLE codecs8;\n+\n+SELECT * FROM codecs1;\n+SELECT * FROM codecs2;\n+SELECT * FROM codecs3;\n+SELECT * FROM codecs4;\n+SELECT * FROM codecs5;\n+SELECT * FROM codecs6;\n+SELECT * FROM codecs7;\n+SELECT * FROM codecs8;\n+\n+DROP TABLE codecs1;\n+DROP TABLE codecs2;\n+DROP TABLE codecs3;\n+DROP TABLE codecs4;\n+DROP TABLE codecs5;\n+DROP TABLE codecs6;\n+DROP TABLE codecs7;\n+DROP TABLE codecs8;\n",
  "problem_statement": "Add settings `allow_suspicious_codecs`.\nIf this setting is turned off (default), don't allow to create a table with nonsense codec declarations:\r\n- a codec that does some transformations but does not compress data without compressing codec later in the list (example: `CODEC(Delta)`);\r\n- more than one generic compression codec (example: `CODEC(LZ4, ZSTD)`);\r\n- type-dependent transformation after generic compression codec (example: `CODEC(LZ4, Delta)`).\r\n\r\nAlways allow to attach a table.\r\nThese combinations of codecs are still available for tests (under this setting).\n",
  "hints_text": "",
  "created_at": "2020-05-04T00:12:52Z"
}