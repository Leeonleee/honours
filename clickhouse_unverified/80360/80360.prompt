You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Exception: Not found column toDate(__table3.dt)
### Company or project name

_No response_

### Describe what's wrong

An error occurs when using a view that connects tables with DateTime and Date type fields for JOIN without toDate function around Date type field and using this field in WHERE clause.

CREATE VIEW v AS
SELECT 
  t.id td_id, t.d td_d, uniqExact(tdt.id) as cnt 
FROM 
  td as t
  LEFT JOIN tdt ON toDate(tdt.dt) = t.d
GROUP BY td_id, td_d;

SELECT td_d FROM v
WHERE td_d = '2025-04-01';

### Does it reproduce on the most recent release?

Yes

### How to reproduce

versions: 25.4.1 and 25.3.3

https://fiddle.clickhouse.com/6c74e1a3-e961-4527-b3a8-419615db9e9d

### Expected behavior

_No response_

### Error message and/or stacktrace

Received exception from server (version 25.4.1):
Code: 10. DB::Exception: Received from localhost:9000. DB::Exception: Not found column toDate(__table3.dt): in block __table3.dt DateTime UInt32(size = 0). (NOT_FOUND_COLUMN_IN_BLOCK)
(query: SELECT td_d FROM v
WHERE td_d = '2025-04-01';)

### Additional context

_No response_
Using 'equals' on Uint128 column causes 'Unknown identifier' or segfault
### Company or project name

TensorZero

### Describe what's wrong

When using the following table schema:
```
CREATE TABLE IF NOT EXISTS BadTable (id_uint UInt128) ENGINE = MergeTree() ORDER BY id_uint;
CREATE TABLE IF NOT EXISTS BadJoin (id UUID, name LowCardinality(String)) ENGINE = MergeTree() ORDER BY (name);
```

The following query produces an 'Unknown identifier' error (https://fiddle.clickhouse.com/db9748e5-2a36-4799-a469-36356e9890ed):
```
SELECT 1 FROM BadTable i LEFT JOIN BadJoin c ON i.id_uint = toUInt128(c.id) WHERE equals(i.id_uint, 12);
```

```
Received exception from server (version 25.2.2):
Code: 47. DB::Exception: Received from localhost:9000. DB::Exception: Unknown identifier: 'equals(__table1.id_uint, 12_UInt8)'. (UNKNOWN_IDENTIFIER)
(query: SELECT 1 FROM BadTable i LEFT JOIN BadJoin c ON i.id_uint = toUInt128(c.id) WHERE equals(i.id_uint, 12);)
```

If this query is modified slightly to use the 'equals' expression with 'SELECT', then ClickHouse segfaults (https://fiddle.clickhouse.com/249e450e-c002-413a-8c0c-f09c4f7a327f):

```
SELECT equals(i.id_uint, 12) FROM BadTable i LEFT JOIN BadJoin c ON i.id_uint = toUInt128(c.id) WHERE equals(i.id_uint, 12);
```

```

[6c380d833e86] 2025.03.18 15:49:00.391517 [ 760 ] <Fatal> BaseDaemon: ########################################
[6c380d833e86] 2025.03.18 15:49:00.391590 [ 760 ] <Fatal> BaseDaemon: (version 25.2.2.39 (official build), build id: 81BBAA4141094E1995BF244BFE32288EE7EE9049, git hash: a1200cff50a7ceb17f5fff71e47f5d20d9ada287) (from thread 83) (query_id: 1891cbce-16f4-4e67-9b39-5d27351859a9) (query: SELECT equals(i.id_uint, 12) FROM BadTable i LEFT JOIN BadJoin c ON i.id_uint = toUInt128(c.id) WHERE equals(i.id_uint, 12);) Received signal Segmentation fault (11)
[6c380d833e86] 2025.03.18 15:49:00.391638 [ 760 ] <Fatal> BaseDaemon: Address: NULL pointer. Access: read. Address not mapped to object.
[6c380d833e86] 2025.03.18 15:49:00.391689 [ 760 ] <Fatal> BaseDaemon: Stack trace: 0x000000000f235a57 0x00007ca835368520 0x0000000014b4d172 0x00000000126360e7 0x0000000014b4a7d7 0x0000000014b4974e 0x0000000012f6851d 0x0000000012f67dfe 0x0000000013316a62 0x0000000013311c24 0x0000000014647a2c 0x0000000014665eb9 0x0000000017d1a4a7 0x0000000017d1a8f9 0x0000000017ce6c7b 0x0000000017ce515d 0x00007ca8353baac3 0x00007ca83544ba04
[6c380d833e86] 2025.03.18 15:49:00.391788 [ 760 ] <Fatal> BaseDaemon: 0. signalHandler(int, siginfo_t*, void*) @ 0x000000000f235a57
[6c380d833e86] 2025.03.18 15:49:00.391841 [ 760 ] <Fatal> BaseDaemon: 1. ? @ 0x00007ca835368520
[6c380d833e86] 2025.03.18 15:49:00.391904 [ 760 ] <Fatal> BaseDaemon: 2. DB::QueryPlan::explainPlan(DB::WriteBuffer&, DB::ExplainPlanOptions const&, unsigned long) const @ 0x0000000014b4d172
[6c380d833e86] 2025.03.18 15:49:00.391964 [ 760 ] <Fatal> BaseDaemon: 3. DB::dumpQueryPlan(DB::QueryPlan const&) @ 0x00000000126360e7
[6c380d833e86] 2025.03.18 15:49:00.392020 [ 760 ] <Fatal> BaseDaemon: 4. DB::QueryPlan::optimize(DB::QueryPlanOptimizationSettings const&) @ 0x0000000014b4a7d7
[6c380d833e86] 2025.03.18 15:49:00.392074 [ 760 ] <Fatal> BaseDaemon: 5. DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&) @ 0x0000000014b4974e
[6c380d833e86] 2025.03.18 15:49:00.392133 [ 760 ] <Fatal> BaseDaemon: 6. DB::InterpreterSelectQueryAnalyzer::buildQueryPipeline() @ 0x0000000012f6851d
[6c380d833e86] 2025.03.18 15:49:00.392185 [ 760 ] <Fatal> BaseDaemon: 7. DB::InterpreterSelectQueryAnalyzer::execute() @ 0x0000000012f67dfe
[6c380d833e86] 2025.03.18 15:49:00.392249 [ 760 ] <Fatal> BaseDaemon: 8. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*, std::shared_ptr<DB::IAST>&) @ 0x0000000013316a62
[6c380d833e86] 2025.03.18 15:49:00.392314 [ 760 ] <Fatal> BaseDaemon: 9. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x0000000013311c24
[6c380d833e86] 2025.03.18 15:49:00.392393 [ 760 ] <Fatal> BaseDaemon: 10. DB::TCPHandler::runImpl() @ 0x0000000014647a2c
[6c380d833e86] 2025.03.18 15:49:00.392450 [ 760 ] <Fatal> BaseDaemon: 11. DB::TCPHandler::run() @ 0x0000000014665eb9
[6c380d833e86] 2025.03.18 15:49:00.392525 [ 760 ] <Fatal> BaseDaemon: 12. Poco::Net::TCPServerConnection::start() @ 0x0000000017d1a4a7
[6c380d833e86] 2025.03.18 15:49:00.392581 [ 760 ] <Fatal> BaseDaemon: 13. Poco::Net::TCPServerDispatcher::run() @ 0x0000000017d1a8f9
[6c380d833e86] 2025.03.18 15:49:00.392616 [ 760 ] <Fatal> BaseDaemon: 14. Poco::PooledThread::run() @ 0x0000000017ce6c7b
[6c380d833e86] 2025.03.18 15:49:00.392648 [ 760 ] <Fatal> BaseDaemon: 15. Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000017ce515d
[6c380d833e86] 2025.03.18 15:49:00.392676 [ 760 ] <Fatal> BaseDaemon: 16. ? @ 0x00007ca8353baac3
[6c380d833e86] 2025.03.18 15:49:00.392701 [ 760 ] <Fatal> BaseDaemon: 17. ? @ 0x00007ca83544ba04
[6c380d833e86] 2025.03.18 15:49:00.535918 [ 760 ] <Fatal> BaseDaemon: Integrity check of the executable successfully passed (checksum: 4A7AC8F994A8E395EF3B3AAC3B417E0C)
[6c380d833e86] 2025.03.18 15:49:00.536164 [ 760 ] <Fatal> BaseDaemon: Report this error to https://github.com/ClickHouse/ClickHouse/issues
[6c380d833e86] 2025.03.18 15:49:00.536343 [ 760 ] <Fatal> BaseDaemon: Changed settings: output_format_pretty_color = 0, output_format_pretty_grid_charset = 'ASCII'
```

Without a join, the query succeeds:
```
SELECT 1 FROM BadTable i WHERE equals(i.id_uint, 12);
```

### Does it reproduce on the most recent release?

Yes

### How to reproduce

This was reproduced on ClickHouse 25.2.2. It occurs on ClickHouse fiddle without any data needed in any of the tables.

### Expected behavior

The two 'JOIN' queries should succeed, instead of giving an 'Unknown Identifier' error or segfaulting

### Error message and/or stacktrace

_No response_

### Additional context

_No response_
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
