{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9593,
  "instance_id": "ClickHouse__ClickHouse-9593",
  "issue_numbers": [
    "6604"
  ],
  "base_commit": "310e0cc144f9472348570ecc6d3e964c4e46e852",
  "patch": "diff --git a/dbms/src/Access/AccessFlags.h b/dbms/src/Access/AccessFlags.h\nindex f35c88f98317..5af804ddc48b 100644\n--- a/dbms/src/Access/AccessFlags.h\n+++ b/dbms/src/Access/AccessFlags.h\n@@ -401,6 +401,7 @@ class AccessFlags::Impl\n         auto input = std::make_unique<Node>(\"input()\", next_flag++, GLOBAL_LEVEL);\n         auto values = std::make_unique<Node>(\"values()\", next_flag++, GLOBAL_LEVEL);\n         auto numbers = std::make_unique<Node>(\"numbers()\", next_flag++, GLOBAL_LEVEL);\n+        auto zeros = std::make_unique<Node>(\"zeros()\", next_flag++, GLOBAL_LEVEL);\n         auto merge = std::make_unique<Node>(\"merge()\", next_flag++, DATABASE_LEVEL);\n         auto remote = std::make_unique<Node>(\"remote()\", next_flag++, GLOBAL_LEVEL);\n         ext::push_back(remote->aliases, \"remoteSecure()\", \"cluster()\");\n@@ -409,7 +410,7 @@ class AccessFlags::Impl\n         auto jdbc = std::make_unique<Node>(\"jdbc()\", next_flag++, GLOBAL_LEVEL);\n         auto hdfs = std::make_unique<Node>(\"hdfs()\", next_flag++, GLOBAL_LEVEL);\n         auto s3 = std::make_unique<Node>(\"s3()\", next_flag++, GLOBAL_LEVEL);\n-        auto table_functions = std::make_unique<Node>(\"TABLE FUNCTIONS\", std::move(file), std::move(url), std::move(input), std::move(values), std::move(numbers), std::move(merge), std::move(remote), std::move(mysql), std::move(odbc), std::move(jdbc), std::move(hdfs), std::move(s3));\n+        auto table_functions = std::make_unique<Node>(\"TABLE FUNCTIONS\", std::move(file), std::move(url), std::move(input), std::move(values), std::move(numbers), std::move(zeros), std::move(merge), std::move(remote), std::move(mysql), std::move(odbc), std::move(jdbc), std::move(hdfs), std::move(s3));\n         ext::push_back(all, std::move(table_functions));\n \n         flags_to_keyword_tree_ = std::make_unique<Node>(\"ALL\", std::move(all));\ndiff --git a/dbms/src/Access/AccessType.h b/dbms/src/Access/AccessType.h\nindex 4b65f9498858..205840eecdfc 100644\n--- a/dbms/src/Access/AccessType.h\n+++ b/dbms/src/Access/AccessType.h\n@@ -129,6 +129,7 @@ enum class AccessType\n     input,\n     values,\n     numbers,\n+    zeros,\n     merge,\n     remote,\n     mysql,\n@@ -288,6 +289,7 @@ namespace impl\n             ACCESS_TYPE_TO_KEYWORD_CASE(input);\n             ACCESS_TYPE_TO_KEYWORD_CASE(values);\n             ACCESS_TYPE_TO_KEYWORD_CASE(numbers);\n+            ACCESS_TYPE_TO_KEYWORD_CASE(zeros);\n             ACCESS_TYPE_TO_KEYWORD_CASE(merge);\n             ACCESS_TYPE_TO_KEYWORD_CASE(remote);\n             ACCESS_TYPE_TO_KEYWORD_CASE(mysql);\ndiff --git a/dbms/src/Storages/System/StorageSystemZeros.cpp b/dbms/src/Storages/System/StorageSystemZeros.cpp\nnew file mode 100644\nindex 000000000000..ae9bf3d09029\n--- /dev/null\n+++ b/dbms/src/Storages/System/StorageSystemZeros.cpp\n@@ -0,0 +1,132 @@\n+#include <Storages/System/StorageSystemZeros.h>\n+\n+#include <Processors/Sources/SourceWithProgress.h>\n+#include <Processors/Pipe.h>\n+\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Columns/ColumnsNumber.h>\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+struct ZerosState\n+{\n+    std::atomic<UInt64> num_generated_rows = 0;\n+};\n+\n+using ZerosStatePtr = std::shared_ptr<ZerosState>;\n+\n+\n+/// Source which generates zeros.\n+/// Uses state to share the number of generated rows between threads.\n+/// If state is nullptr, then limit is ignored.\n+class ZerosSource : public SourceWithProgress\n+{\n+public:\n+    ZerosSource(UInt64 block_size, UInt64 limit_, ZerosStatePtr state_)\n+            : SourceWithProgress(createHeader()), limit(limit_), state(std::move(state_))\n+    {\n+        column = createColumn(block_size);\n+    }\n+\n+    String getName() const override { return \"Zeros\"; }\n+\n+protected:\n+    Chunk generate() override\n+    {\n+        auto column_ptr = column;\n+        size_t column_size = column_ptr->size();\n+\n+        if (state)\n+        {\n+            auto generated_rows = state->num_generated_rows.fetch_add(column_size, std::memory_order_acquire);\n+\n+            if (generated_rows >= limit)\n+                return {};\n+\n+            if (generated_rows + column_size > limit)\n+            {\n+                column_size = limit - generated_rows;\n+                column_ptr = createColumn(column_size);\n+            }\n+        }\n+\n+        progress({column->size(), column->byteSize()});\n+\n+        return { Columns {std::move(column_ptr)}, column_size };\n+    }\n+\n+private:\n+    UInt64 limit;\n+    ZerosStatePtr state;\n+    ColumnPtr column;\n+\n+    static Block createHeader()\n+    {\n+        return { ColumnWithTypeAndName(ColumnUInt8::create(), std::make_shared<DataTypeUInt8>(), \"zero\") };\n+    }\n+\n+    static ColumnPtr createColumn(size_t size)\n+    {\n+        auto column_ptr = ColumnUInt8::create();\n+        /// It is probably the fastest method to create zero column, cause resize_fill uses memset internally.\n+        column_ptr->getData().resize_fill(size);\n+\n+        return column_ptr;\n+    }\n+};\n+\n+}\n+\n+StorageSystemZeros::StorageSystemZeros(const std::string & name_, bool multithreaded_, std::optional<UInt64> limit_)\n+    : IStorage({\"system\", name_}), multithreaded(multithreaded_), limit(limit_)\n+{\n+    setColumns(ColumnsDescription({{\"zero\", std::make_shared<DataTypeUInt8>()}}));\n+}\n+\n+Pipes StorageSystemZeros::read(\n+        const Names & column_names,\n+        const SelectQueryInfo &,\n+        const Context & /*context*/,\n+        QueryProcessingStage::Enum /*processed_stage*/,\n+        size_t max_block_size,\n+        unsigned num_streams)\n+{\n+    check(column_names);\n+\n+    bool use_multiple_streams = multithreaded;\n+\n+    if (limit && *limit < max_block_size)\n+    {\n+        max_block_size = static_cast<size_t>(*limit);\n+        use_multiple_streams = false;\n+    }\n+\n+    if (!use_multiple_streams)\n+        num_streams = 1;\n+\n+    Pipes res;\n+    res.reserve(num_streams);\n+\n+    ZerosStatePtr state;\n+\n+    if (limit)\n+        state = std::make_shared<ZerosState>();\n+\n+    for (size_t i = 0; i < num_streams; ++i)\n+    {\n+        auto source = std::make_shared<ZerosSource>(max_block_size, *limit, state);\n+\n+        if (limit && i == 0)\n+            source->addTotalRowsApprox(*limit);\n+\n+        res.emplace_back(std::move(source));\n+    }\n+\n+    return res;\n+}\n+\n+}\ndiff --git a/dbms/src/Storages/System/StorageSystemZeros.h b/dbms/src/Storages/System/StorageSystemZeros.h\nnew file mode 100644\nindex 000000000000..36032608637f\n--- /dev/null\n+++ b/dbms/src/Storages/System/StorageSystemZeros.h\n@@ -0,0 +1,43 @@\n+#pragma once\n+\n+#include <ext/shared_ptr_helper.h>\n+#include <optional>\n+#include <Storages/IStorage.h>\n+\n+namespace DB\n+{\n+\n+/** Implements a table engine for the system table \"zeros\".\n+  * The table contains the only column zero UInt8.\n+  * From this table, you can read non-materialized zeros.\n+  *\n+  * You could also specify a limit (how many zeros to give).\n+  * If multithreaded is specified, zeros will be generated in several streams.\n+  */\n+class StorageSystemZeros : public ext::shared_ptr_helper<StorageSystemZeros>, public IStorage\n+{\n+    friend struct ext::shared_ptr_helper<StorageSystemZeros>;\n+public:\n+    std::string getName() const override { return \"SystemZeros\"; }\n+\n+    Pipes read(\n+            const Names & column_names,\n+            const SelectQueryInfo & query_info,\n+            const Context & context,\n+            QueryProcessingStage::Enum processed_stage,\n+            size_t max_block_size,\n+            unsigned num_streams) override;\n+\n+    bool hasEvenlyDistributedRead() const override { return true; }\n+\n+private:\n+    bool multithreaded;\n+    std::optional<UInt64> limit;\n+\n+protected:\n+    /// If even_distribution is true, numbers are distributed evenly between streams.\n+    /// Otherwise, streams concurrently increment atomic.\n+    StorageSystemZeros(const std::string & name_, bool multithreaded_, std::optional<UInt64> limit_ = std::nullopt);\n+};\n+\n+}\ndiff --git a/dbms/src/Storages/System/attachSystemTables.cpp b/dbms/src/Storages/System/attachSystemTables.cpp\nindex 06f00783384a..db76d68f091c 100644\n--- a/dbms/src/Storages/System/attachSystemTables.cpp\n+++ b/dbms/src/Storages/System/attachSystemTables.cpp\n@@ -39,6 +39,7 @@\n #include <Storages/System/StorageSystemContributors.h>\n #include <Storages/System/StorageSystemDisks.h>\n #include <Storages/System/StorageSystemStoragePolicies.h>\n+#include <Storages/System/StorageSystemZeros.h>\n \n #ifdef OS_LINUX\n #include <Storages/System/StorageSystemStackTrace.h>\n@@ -53,6 +54,8 @@ void attachSystemTablesLocal(IDatabase & system_database)\n     system_database.attachTable(\"one\", StorageSystemOne::create(\"one\"));\n     system_database.attachTable(\"numbers\", StorageSystemNumbers::create(\"numbers\", false));\n     system_database.attachTable(\"numbers_mt\", StorageSystemNumbers::create(\"numbers_mt\", true));\n+    system_database.attachTable(\"zeros\", StorageSystemZeros::create(\"zeros\", false));\n+    system_database.attachTable(\"zeros_mt\", StorageSystemZeros::create(\"zeros_mt\", true));\n     system_database.attachTable(\"databases\", StorageSystemDatabases::create(\"databases\"));\n     system_database.attachTable(\"tables\", StorageSystemTables::create(\"tables\"));\n     system_database.attachTable(\"columns\", StorageSystemColumns::create(\"columns\"));\ndiff --git a/dbms/src/TableFunctions/TableFunctionZeros.cpp b/dbms/src/TableFunctions/TableFunctionZeros.cpp\nnew file mode 100644\nindex 000000000000..79f49dc5d284\n--- /dev/null\n+++ b/dbms/src/TableFunctions/TableFunctionZeros.cpp\n@@ -0,0 +1,56 @@\n+#include <TableFunctions/ITableFunction.h>\n+#include <TableFunctions/TableFunctionZeros.h>\n+#include <TableFunctions/TableFunctionFactory.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Common/typeid_cast.h>\n+#include <Storages/System/StorageSystemZeros.h>\n+#include <Access/AccessFlags.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+#include <Interpreters/Context.h>\n+#include \"registerTableFunctions.h\"\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+template <bool multithreaded>\n+StoragePtr TableFunctionZeros<multithreaded>::executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const\n+{\n+    if (const auto * function = ast_function->as<ASTFunction>())\n+    {\n+        auto arguments = function->arguments->children;\n+\n+        if (arguments.size() != 1)\n+            throw Exception(\"Table function '\" + getName() + \"' requires 'length'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+\n+        UInt64 length = evaluateArgument(context, arguments[0]);\n+\n+        context.checkAccess(AccessType::zeros);\n+\n+        auto res = StorageSystemZeros::create(table_name, multithreaded, length);\n+        res->startup();\n+        return res;\n+    }\n+    throw Exception(\"Table function '\" + getName() + \"' requires 'limit'.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+}\n+\n+void registerTableFunctionZeros(TableFunctionFactory & factory)\n+{\n+    factory.registerFunction<TableFunctionZeros<true>>();\n+    factory.registerFunction<TableFunctionZeros<false>>();\n+}\n+\n+template <bool multithreaded>\n+UInt64 TableFunctionZeros<multithreaded>::evaluateArgument(const Context & context, ASTPtr & argument) const\n+{\n+    return evaluateConstantExpressionOrIdentifierAsLiteral(argument, context)->as<ASTLiteral &>().value.safeGet<UInt64>();\n+}\n+\n+}\ndiff --git a/dbms/src/TableFunctions/TableFunctionZeros.h b/dbms/src/TableFunctions/TableFunctionZeros.h\nnew file mode 100644\nindex 000000000000..c8f3cbabc0e0\n--- /dev/null\n+++ b/dbms/src/TableFunctions/TableFunctionZeros.h\n@@ -0,0 +1,27 @@\n+#pragma once\n+\n+#include <TableFunctions/ITableFunction.h>\n+#include <Core/Types.h>\n+\n+\n+namespace DB\n+{\n+\n+/* zeros(limit), zeros_mt(limit)\n+ * - the same as SELECT zero FROM system.zeros LIMIT limit.\n+ * Used for testing purposes, as a simple example of table function.\n+ */\n+template <bool multithreaded>\n+class TableFunctionZeros : public ITableFunction\n+{\n+public:\n+    static constexpr auto name = multithreaded ? \"zeros_mt\" : \"zeros\";\n+    std::string getName() const override { return name; }\n+private:\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name) const override;\n+\n+    UInt64 evaluateArgument(const Context & context, ASTPtr & argument) const;\n+};\n+\n+\n+}\ndiff --git a/dbms/src/TableFunctions/registerTableFunctions.cpp b/dbms/src/TableFunctions/registerTableFunctions.cpp\nindex b9a96532b13b..662f7b58d487 100644\n--- a/dbms/src/TableFunctions/registerTableFunctions.cpp\n+++ b/dbms/src/TableFunctions/registerTableFunctions.cpp\n@@ -11,6 +11,7 @@ void registerTableFunctions()\n     registerTableFunctionMerge(factory);\n     registerTableFunctionRemote(factory);\n     registerTableFunctionNumbers(factory);\n+    registerTableFunctionZeros(factory);\n     registerTableFunctionFile(factory);\n     registerTableFunctionURL(factory);\n     registerTableFunctionValues(factory);\ndiff --git a/dbms/src/TableFunctions/registerTableFunctions.h b/dbms/src/TableFunctions/registerTableFunctions.h\nindex e1be5477c252..3cde28685cc9 100644\n--- a/dbms/src/TableFunctions/registerTableFunctions.h\n+++ b/dbms/src/TableFunctions/registerTableFunctions.h\n@@ -8,6 +8,7 @@ class TableFunctionFactory;\n void registerTableFunctionMerge(TableFunctionFactory & factory);\n void registerTableFunctionRemote(TableFunctionFactory & factory);\n void registerTableFunctionNumbers(TableFunctionFactory & factory);\n+void registerTableFunctionZeros(TableFunctionFactory & factory);\n void registerTableFunctionFile(TableFunctionFactory & factory);\n void registerTableFunctionURL(TableFunctionFactory & factory);\n void registerTableFunctionValues(TableFunctionFactory & factory);\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01096_zeros.reference b/dbms/tests/queries/0_stateless/01096_zeros.reference\nnew file mode 100644\nindex 000000000000..83e503406bcf\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01096_zeros.reference\n@@ -0,0 +1,48 @@\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+-\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+-\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+-\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+-\n+0\t1000000000\n+0\t1000000000\n+0\t1000000000\n+0\t1000000000\ndiff --git a/dbms/tests/queries/0_stateless/01096_zeros.sql b/dbms/tests/queries/0_stateless/01096_zeros.sql\nnew file mode 100644\nindex 000000000000..a6552b9229b2\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01096_zeros.sql\n@@ -0,0 +1,12 @@\n+select zero from system.zeros limit 10 settings max_block_size = 3;\n+select '-';\n+select zero from system.zeros_mt limit 10 settings max_block_size = 3, max_threads = 2;\n+select '-';\n+select zero from zeros(10) settings max_block_size = 3;\n+select '-';\n+select zero from zeros_mt(10) settings max_block_size = 3, max_threads=3;\n+select '-';\n+select sum(zero), count() from (select * from system.zeros limit 1000000000);\n+select sum(zero), count() from (select * from system.zeros_mt limit 1000000000);\n+select sum(zero), count() from zeros(1000000000);\n+select sum(zero), count() from zeros_mt(1000000000);\n",
  "problem_statement": "Table function 'zeros' and 'zeros_mt'.\nYields infinite stream of zeros of type UInt8.\r\n\r\n**Use case**\r\nFor performance tests to use instead of `numbers`.\n",
  "hints_text": "@KochetovNicolai decided to implement this feature.",
  "created_at": "2020-03-10T18:15:31Z"
}