{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 44818,
  "instance_id": "ClickHouse__ClickHouse-44818",
  "issue_numbers": [
    "44814"
  ],
  "base_commit": "d4d0647ccdc98d42ef3a7b55e7ca49e86b3d0a71",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex c9638ab95afd..b3f892ffc0d2 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -2147,14 +2147,18 @@ struct ToNumberMonotonicity\n         if constexpr (std::is_floating_point_v<T>)\n             return { .is_monotonic = true, .is_always_monotonic = true };\n \n-        /// If converting from Float, for monotonicity, arguments must fit in range of result type.\n-        bool is_type_float = false;\n-        if (const auto * low_cardinality = typeid_cast<const DataTypeLowCardinality *>(&type))\n-            is_type_float = WhichDataType(low_cardinality->getDictionaryType()).isFloat();\n-        else\n-            is_type_float = WhichDataType(type).isFloat();\n+        const auto * low_cardinality = typeid_cast<const DataTypeLowCardinality *>(&type);\n+        const IDataType * low_cardinality_dictionary_type = nullptr;\n+        if (low_cardinality)\n+            low_cardinality_dictionary_type = low_cardinality->getDictionaryType().get();\n \n-        if (is_type_float)\n+        WhichDataType which_type(type);\n+        WhichDataType which_inner_type = low_cardinality\n+            ? WhichDataType(low_cardinality_dictionary_type)\n+            : WhichDataType(type);\n+\n+        /// If converting from Float, for monotonicity, arguments must fit in range of result type.\n+        if (which_inner_type.isFloat())\n         {\n             if (left.isNull() || right.isNull())\n                 return {};\n@@ -2180,7 +2184,7 @@ struct ToNumberMonotonicity\n         const size_t size_of_to = sizeof(T);\n \n         /// Do not support 128 bit integers and decimals for now.\n-        if (size_of_from > sizeof(Int64))\n+        if (size_of_from > sizeof(Int64) || which_inner_type.isDecimal())\n             return {};\n \n         const bool left_in_first_half = left.isNull()\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02519_monotonicity_fuzz.reference b/tests/queries/0_stateless/02519_monotonicity_fuzz.reference\nnew file mode 100644\nindex 000000000000..9459d4ba2a0d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02519_monotonicity_fuzz.reference\n@@ -0,0 +1,1 @@\n+1.1\ndiff --git a/tests/queries/0_stateless/02519_monotonicity_fuzz.sql b/tests/queries/0_stateless/02519_monotonicity_fuzz.sql\nnew file mode 100644\nindex 000000000000..4a0860702bb7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02519_monotonicity_fuzz.sql\n@@ -0,0 +1,5 @@\n+DROP TABLE IF EXISTS t;\n+CREATE TABLE t (x Decimal(18, 3)) ENGINE = MergeTree ORDER BY x;\n+INSERT INTO t VALUES (1.1);\n+SELECT * FROM t WHERE toUInt64(x) = 1;\n+DROP TABLE t;\n",
  "problem_statement": "Logical error: 'Invalid Field get from type Decimal64 to type Int64'\nDebug build:\r\n```\r\nCREATE TABLE table_float__fuzz_44 (`f` Decimal(18, 3), `u` Int8) ENGINE = MergeTree ORDER BY (f, u);\r\nINSERT INTO table_float VALUES (1.2, 1) (1.3, 2) (1.4, 3) (1.5, 4);\r\nSELECT count() FROM table_float__fuzz_44 WHERE (toUInt64(f) = 1) AND (f >= 1.3) AND (f <= 1.4) AND (u > 0) GROUP BY (toUInt64(f) = 1) AND (f >= 1.3) AND (f <= 100.0001) AND (u > 0);\r\n```\r\n\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/44812/ea04181d11827fd552a86ca4d9c07e1d531e6ca3/fuzzer_astfuzzerdebug/report.html\n",
  "hints_text": "```\r\nDROP TABLE IF EXISTS t;\r\nCREATE TABLE t (x Decimal(18, 3)) ENGINE = MergeTree ORDER BY x;\r\nINSERT INTO t VALUES (1.1);\r\nSELECT * FROM t WHERE toUInt64(x) = 0;\r\nDROP TABLE t;\r\n```",
  "created_at": "2023-01-01T19:42:25Z"
}