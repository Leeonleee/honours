{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11647,
  "instance_id": "ClickHouse__ClickHouse-11647",
  "issue_numbers": [
    "11630"
  ],
  "base_commit": "f53da4d36b8c3a214567c935caed478edce08363",
  "patch": "diff --git a/src/DataTypes/DataTypeDateTime64.h b/src/DataTypes/DataTypeDateTime64.h\nindex b575e9d81c13..249da255eb0f 100644\n--- a/src/DataTypes/DataTypeDateTime64.h\n+++ b/src/DataTypes/DataTypeDateTime64.h\n@@ -45,6 +45,8 @@ class DataTypeDateTime64 final : public DataTypeDecimalBase<DateTime64>, public\n     void deserializeProtobuf(IColumn & column, ProtobufReader & protobuf, bool allow_add_row, bool & row_added) const override;\n \n     bool equals(const IDataType & rhs) const override;\n+\n+    bool canBePromoted() const override { return false; }\n };\n \n /** Tansform-type wrapper for DateTime64, applies given Transform to DateTime64 value or only to a whole part of it.\ndiff --git a/src/DataTypes/DataTypeUUID.cpp b/src/DataTypes/DataTypeUUID.cpp\nindex 87e306cf4772..94a043eb4724 100644\n--- a/src/DataTypes/DataTypeUUID.cpp\n+++ b/src/DataTypes/DataTypeUUID.cpp\n@@ -16,13 +16,18 @@ void DataTypeUUID::serializeText(const IColumn & column, size_t row_num, WriteBu\n     writeText(UUID(assert_cast<const ColumnUInt128 &>(column).getData()[row_num]), ostr);\n }\n \n-void DataTypeUUID::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n+void DataTypeUUID::deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n     UUID x;\n     readText(x, istr);\n     assert_cast<ColumnUInt128 &>(column).getData().push_back(x);\n }\n \n+void DataTypeUUID::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n+{\n+    deserializeText(column, istr, settings);\n+}\n+\n void DataTypeUUID::serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n {\n     serializeText(column, row_num, ostr, settings);\ndiff --git a/src/DataTypes/DataTypeUUID.h b/src/DataTypes/DataTypeUUID.h\nindex 75e634bc625f..e9f1d22325bd 100644\n--- a/src/DataTypes/DataTypeUUID.h\n+++ b/src/DataTypes/DataTypeUUID.h\n@@ -17,6 +17,7 @@ class DataTypeUUID final : public DataTypeNumberBase<UInt128>\n     bool equals(const IDataType & rhs) const override;\n \n     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n+    void deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextQuoted(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n@@ -30,6 +31,8 @@ class DataTypeUUID final : public DataTypeNumberBase<UInt128>\n \n     bool canBeUsedInBitOperations() const override { return true; }\n     bool canBeInsideNullable() const override { return true; }\n+\n+    bool canBePromoted() const override { return false; }\n };\n \n }\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 642995974b5d..91525f84c14a 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -22,6 +22,7 @@\n #include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/getLeastSupertype.h>\n \n+#include <Interpreters/convertFieldToType.h>\n #include <Interpreters/castColumn.h>\n \n #include <Functions/IFunctionAdaptors.h>\n@@ -51,7 +52,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int TOO_LARGE_STRING_SIZE;\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int LOGICAL_ERROR;\n@@ -812,92 +812,49 @@ class FunctionComparison : public IFunction\n         }\n     }\n \n-    bool executeDateOrDateTimeOrEnumOrUUIDWithConstString(\n+    bool executeWithConstString(\n         Block & block, size_t result, const IColumn * col_left_untyped, const IColumn * col_right_untyped,\n-        const DataTypePtr & left_type, const DataTypePtr & right_type, bool left_is_num, size_t input_rows_count)\n+        const DataTypePtr & left_type, const DataTypePtr & right_type, size_t input_rows_count)\n     {\n-        /// This is no longer very special case - comparing dates, datetimes, and enumerations with a string constant.\n-        const IColumn * column_string_untyped = !left_is_num ? col_left_untyped : col_right_untyped;\n-        const IColumn * column_number = left_is_num ? col_left_untyped : col_right_untyped;\n-        const IDataType * number_type = left_is_num ? left_type.get() : right_type.get();\n+        /// To compare something with const string, we cast constant to appropriate type and compare as usual.\n+        /// It is ok to throw exception if value is not convertible.\n+        /// We should deal with possible overflows, e.g. toUInt8(1) = '257' should return false.\n \n-        WhichDataType which(number_type);\n+        const ColumnConst * left_const = checkAndGetColumnConstStringOrFixedString(col_left_untyped);\n+        const ColumnConst * right_const = checkAndGetColumnConstStringOrFixedString(col_right_untyped);\n \n-        const bool legal_types = which.isDateOrDateTime() || which.isEnum() || which.isUUID();\n-\n-        const auto column_string = checkAndGetColumnConst<ColumnString>(column_string_untyped);\n-        if (!column_string || !legal_types)\n+        if (!left_const && !right_const)\n             return false;\n \n-        StringRef string_value = column_string->getDataAt(0);\n+        const IDataType * type_string = left_const ? left_type.get() : right_type.get();\n+        const DataTypePtr & type_to_compare = !left_const ? left_type : right_type;\n \n-        if (which.isDate())\n-        {\n-            DayNum date;\n-            ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readDateText(date, in);\n-            if (!in.eof())\n-                throw Exception(\"String is too long for Date: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-            ColumnPtr parsed_const_date_holder = DataTypeDate().createColumnConst(input_rows_count, date);\n-            const ColumnConst * parsed_const_date = assert_cast<const ColumnConst *>(parsed_const_date_holder.get());\n-            executeNumLeftType<DataTypeDate::FieldType>(block, result,\n-                left_is_num ? col_left_untyped : parsed_const_date,\n-                left_is_num ? parsed_const_date : col_right_untyped);\n-        }\n-        else if (which.isDateTime())\n+        Field string_value = left_const ? left_const->getField() : right_const->getField();\n+        Field converted = convertFieldToType(string_value, *type_to_compare, type_string);\n+\n+        /// If not possible to convert, comparison with =, <, >, <=, >= yields to false and comparison with != yields to true.\n+        if (converted.isNull())\n         {\n-            time_t date_time;\n-            ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readDateTimeText(date_time, in, dynamic_cast<const DataTypeDateTime &>(*number_type).getTimeZone());\n-            if (!in.eof())\n-                throw Exception(\"String is too long for DateTime: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-            ColumnPtr parsed_const_date_time_holder = DataTypeDateTime().createColumnConst(input_rows_count, UInt64(date_time));\n-            const ColumnConst * parsed_const_date_time = assert_cast<const ColumnConst *>(parsed_const_date_time_holder.get());\n-            executeNumLeftType<DataTypeDateTime::FieldType>(block, result,\n-                left_is_num ? col_left_untyped : parsed_const_date_time,\n-                left_is_num ? parsed_const_date_time : col_right_untyped);\n+            block.getByPosition(result).column = DataTypeUInt8().createColumnConst(input_rows_count,\n+                std::is_same_v<Op<int, int>, NotEqualsOp<int, int>>);\n         }\n-        else if (which.isUUID())\n+        else\n         {\n-            UUID uuid;\n-            ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readText(uuid, in);\n-            if (!in.eof())\n-                throw Exception(\"String is too long for UUID: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-            ColumnPtr parsed_const_uuid_holder = DataTypeUUID().createColumnConst(input_rows_count, uuid);\n-            const ColumnConst * parsed_const_uuid = assert_cast<const ColumnConst *>(parsed_const_uuid_holder.get());\n-            executeNumLeftType<DataTypeUUID::FieldType>(block, result,\n-                left_is_num ? col_left_untyped : parsed_const_uuid,\n-                left_is_num ? parsed_const_uuid : col_right_untyped);\n-        }\n-\n-        else if (which.isEnum8())\n-            executeEnumWithConstString<DataTypeEnum8>(block, result, column_number, column_string,\n-                number_type, left_is_num, input_rows_count);\n-        else if (which.isEnum16())\n-            executeEnumWithConstString<DataTypeEnum16>(block, result, column_number, column_string,\n-                number_type, left_is_num, input_rows_count);\n+            auto column_converted = type_to_compare->createColumnConst(input_rows_count, converted);\n \n-        return true;\n-    }\n+            Block tmp_block\n+            {\n+                { left_const ? column_converted : col_left_untyped->getPtr(), type_to_compare, \"\" },\n+                { !left_const ? column_converted : col_right_untyped->getPtr(), type_to_compare, \"\" },\n+                block.getByPosition(result)\n+            };\n \n-    /// Comparison between DataTypeEnum<T> and string constant containing the name of an enum element\n-    template <typename EnumType>\n-    void executeEnumWithConstString(\n-        Block & block, const size_t result, const IColumn * column_number, const ColumnConst * column_string,\n-        const IDataType * type_untyped, const bool left_is_num, size_t input_rows_count)\n-    {\n-        const auto type = static_cast<const EnumType *>(type_untyped);\n+            executeImpl(tmp_block, {0, 1}, 2, input_rows_count);\n \n-        const Field x = castToNearestFieldType(type->getValue(column_string->getValue<String>()));\n-        const auto enum_col = type->createColumnConst(input_rows_count, x);\n+            block.getByPosition(result).column = std::move(tmp_block.getByPosition(2).column);\n+        }\n \n-        executeNumLeftType<typename EnumType::FieldType>(block, result,\n-            left_is_num ? column_number : enum_col.get(),\n-            left_is_num ? enum_col.get() : column_number);\n+        return true;\n     }\n \n     void executeTuple(Block & block, size_t result, const ColumnWithTypeAndName & c0, const ColumnWithTypeAndName & c1,\n@@ -1124,17 +1081,11 @@ class FunctionComparison : public IFunction\n         bool has_date = left.isDate() || right.isDate();\n \n         if (!((both_represented_by_number && !has_date)   /// Do not allow compare date and number.\n-            || (left.isStringOrFixedString() && right.isStringOrFixedString())\n+            || (left.isStringOrFixedString() || right.isStringOrFixedString())  /// Everything can be compared with string by conversion.\n             /// You can compare the date, datetime, or datatime64 and an enumeration with a constant string.\n-            || (left.isString() && right.isDateOrDateTime())\n-            || (left.isDateOrDateTime() && right.isString())\n             || (left.isDateOrDateTime() && right.isDateOrDateTime() && left.idx == right.idx) /// only date vs date, or datetime vs datetime\n             || (left.isUUID() && right.isUUID())\n-            || (left.isUUID() && right.isString())\n-            || (left.isString() && right.isUUID())\n             || (left.isEnum() && right.isEnum() && arguments[0]->getName() == arguments[1]->getName()) /// only equivalent enum type values can be compared against\n-            || (left.isEnum() && right.isString())\n-            || (left.isString() && right.isEnum())\n             || (left_tuple && right_tuple && left_tuple->getElements().size() == right_tuple->getElements().size())\n             || (arguments[0]->equals(*arguments[1]))))\n         {\n@@ -1151,7 +1102,8 @@ class FunctionComparison : public IFunction\n \n         if (left_tuple && right_tuple)\n         {\n-            auto adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(FunctionComparison<Op, Name>::create(context)));\n+            auto adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(\n+                FunctionComparison<Op, Name>::create(context)));\n \n             size_t size = left_tuple->getElements().size();\n             for (size_t i = 0; i < size; ++i)\n@@ -1201,6 +1153,9 @@ class FunctionComparison : public IFunction\n         const bool left_is_num = col_left_untyped->isNumeric();\n         const bool right_is_num = col_right_untyped->isNumeric();\n \n+        const bool left_is_string = isStringOrFixedString(which_left);\n+        const bool right_is_string = isStringOrFixedString(which_right);\n+\n         bool date_and_datetime = (left_type != right_type) &&\n             which_left.isDateOrDateTime() && which_right.isDateOrDateTime();\n \n@@ -1226,64 +1181,14 @@ class FunctionComparison : public IFunction\n         {\n             executeTuple(block, result, col_with_type_and_name_left, col_with_type_and_name_right, input_rows_count);\n         }\n-        else if (which_left.idx != which_right.idx\n-                 && (which_left.isDateTime64() || which_right.isDateTime64())\n-                 && (which_left.isStringOrFixedString() || which_right.isStringOrFixedString()))\n+        else if (left_is_string && right_is_string && executeString(block, result, col_left_untyped, col_right_untyped))\n+        {\n+        }\n+        else if (executeWithConstString(\n+                block, result, col_left_untyped, col_right_untyped,\n+                left_type, right_type,\n+                input_rows_count))\n         {\n-            /** Special case of comparing DateTime64 against a string.\n-             *\n-             * Can't be moved to executeDateOrDateTimeOrEnumOrUUIDWithConstString()\n-             * since DateTime64 is basically a Decimal, but we do similar things, except type inference.\n-             * Outline:\n-             * - Extract string content\n-             * - Parse it as a ColumnDateTime64 value (same type as DateTime64, means same precision)\n-             * - Fabricate a column with type and name\n-             * - Compare left and right comlumns as DateTime64 columns.\n-             */\n-\n-            const size_t datetime64_col_index = which_left.isDateTime64() ? 0 : 1;\n-            const size_t string_col_index = which_left.isStringOrFixedString() ? 0 : 1;\n-\n-            const auto & datetime64_col_with_type_and_name = block.getByPosition(arguments[datetime64_col_index]);\n-            const auto & string_col_with_type_and_name = block.getByPosition(arguments[string_col_index]);\n-\n-            if (!isColumnConst(*string_col_with_type_and_name.column))\n-                throw Exception(getName() + \", illegal column type of argument #\" + std::to_string(string_col_index)\n-                        + \" '\" + string_col_with_type_and_name.name + \"'\"\n-                        \" expected const String or const FixedString,\"\n-                        \" got \" + string_col_with_type_and_name.type->getName(),\n-                        ErrorCodes::ILLEGAL_COLUMN);\n-\n-            if (datetime64_col_with_type_and_name.column->size() == 0 || string_col_with_type_and_name.column->size() == 0)\n-            {\n-                // For some reason, when both left and right columns are empty (dry run while building a header block)\n-                // executeDecimal() fills result column with bogus value.\n-                block.getByPosition(result).column = ColumnUInt8::create();\n-                return;\n-            }\n-\n-            auto parsed_tmp_column_holder = datetime64_col_with_type_and_name.type->createColumn();\n-\n-            {\n-                const StringRef string_value = string_col_with_type_and_name.column->getDataAt(0);\n-                ReadBufferFromMemory in(string_value.data, string_value.size);\n-                datetime64_col_with_type_and_name.type->deserializeAsWholeText(*parsed_tmp_column_holder, in, FormatSettings{});\n-\n-                if (!in.eof())\n-                    throw Exception(getName() + \": String is too long for \" + datetime64_col_with_type_and_name.type->getName() + \" : \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-            }\n-\n-            // It is necessary to wrap tmp column in ColumnConst to avoid overflow when comparing.\n-            // (non-const columns are expected to have same number of rows as every other column in block).\n-            const ColumnWithTypeAndName parsed_tmp_col_with_type_and_name{\n-                    ColumnConst::create(std::move(parsed_tmp_column_holder), 1),\n-                    datetime64_col_with_type_and_name.type,\n-                    string_col_with_type_and_name.name};\n-\n-            executeDecimal(block, result,\n-                which_left.isDateTime64() ? datetime64_col_with_type_and_name : parsed_tmp_col_with_type_and_name,\n-                which_right.isDateTime64() ? datetime64_col_with_type_and_name : parsed_tmp_col_with_type_and_name);\n-\n         }\n         else if (isColumnedAsDecimal(left_type) || isColumnedAsDecimal(right_type))\n         {\n@@ -1294,19 +1199,10 @@ class FunctionComparison : public IFunction\n \n             executeDecimal(block, result, col_with_type_and_name_left, col_with_type_and_name_right);\n         }\n-        else if (!left_is_num && !right_is_num && executeString(block, result, col_left_untyped, col_right_untyped))\n-        {\n-        }\n         else if (left_type->equals(*right_type))\n         {\n             executeGenericIdenticalTypes(block, result, col_left_untyped, col_right_untyped);\n         }\n-        else if (executeDateOrDateTimeOrEnumOrUUIDWithConstString(\n-                block, result, col_left_untyped, col_right_untyped,\n-                left_type, right_type,\n-                left_is_num, input_rows_count))\n-        {\n-        }\n         else\n         {\n             executeGeneric(block, result, col_with_type_and_name_left, col_with_type_and_name_right);\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex 3cb774596c02..d46573d04614 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -33,8 +33,6 @@ namespace ErrorCodes\n {\n     extern const int ARGUMENT_OUT_OF_BOUND;\n     extern const int TYPE_MISMATCH;\n-    extern const int TOO_LARGE_STRING_SIZE;\n-    extern const int CANNOT_CONVERT_TYPE;\n }\n \n \n@@ -124,42 +122,6 @@ static Field convertDecimalType(const Field & from, const To & type)\n }\n \n \n-DayNum stringToDate(const String & s)\n-{\n-    ReadBufferFromString in(s);\n-    DayNum date{};\n-\n-    readDateText(date, in);\n-    if (!in.eof())\n-        throw Exception(\"String is too long for Date: \" + s, ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-    return date;\n-}\n-\n-UInt64 stringToDateTime(const String & s)\n-{\n-    ReadBufferFromString in(s);\n-    time_t date_time{};\n-\n-    readDateTimeText(date_time, in);\n-    if (!in.eof())\n-        throw Exception(\"String is too long for DateTime: \" + s, ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-    return UInt64(date_time);\n-}\n-\n-DateTime64::NativeType stringToDateTime64(const String & s, UInt32 scale)\n-{\n-    ReadBufferFromString in(s);\n-    DateTime64 datetime64 {0};\n-\n-    readDateTime64Text(datetime64, scale, in);\n-    if (!in.eof())\n-        throw Exception(\"String is too long for DateTime64: \" + s, ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-    return datetime64.value;\n-}\n-\n Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const IDataType * from_type_hint)\n {\n     WhichDataType which_type(type);\n@@ -184,7 +146,7 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n     {\n         return static_cast<const DataTypeDateTime &>(type).getTimeZone().fromDayNum(DayNum(src.get<UInt64>()));\n     }\n-    else if (type.isValueRepresentedByNumber())\n+    else if (type.isValueRepresentedByNumber() && src.getType() != Field::Types::String)\n     {\n         if (which_type.isUInt8()) return convertNumericType<UInt8>(src, type);\n         if (which_type.isUInt16()) return convertNumericType<UInt16>(src, type);\n@@ -200,9 +162,6 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n         if (const auto * ptype = typeid_cast<const DataTypeDecimal<Decimal64> *>(&type)) return convertDecimalType(src, *ptype);\n         if (const auto * ptype = typeid_cast<const DataTypeDecimal<Decimal128> *>(&type)) return convertDecimalType(src, *ptype);\n \n-        if (!which_type.isDateOrDateTime() && !which_type.isUUID() && !which_type.isEnum())\n-            throw Exception{\"Cannot convert field to type \" + type.getName(), ErrorCodes::CANNOT_CONVERT_TYPE};\n-\n         if (which_type.isEnum() && (src.getType() == Field::Types::UInt64 || src.getType() == Field::Types::Int64))\n         {\n             /// Convert UInt64 or Int64 to Enum's value\n@@ -214,36 +173,20 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n             /// We don't need any conversion UInt64 is under type of Date and DateTime\n             return src;\n         }\n-        // TODO (vnemkov): extra cases for DateTime64: converting from integer, converting from Decimal\n \n-        if (src.getType() == Field::Types::String)\n+        if (which_type.isUUID() && src.getType() == Field::Types::UInt128)\n         {\n-            if (which_type.isDate())\n-            {\n-                /// Convert 'YYYY-MM-DD' Strings to Date\n-                return stringToDate(src.get<const String &>());\n-            }\n-            else if (which_type.isDateTime())\n-            {\n-                /// Convert 'YYYY-MM-DD hh:mm:ss' Strings to DateTime\n-                return stringToDateTime(src.get<const String &>());\n-            }\n-            else if (which_type.isDateTime64())\n-            {\n-                const auto * date_time64 = typeid_cast<const DataTypeDateTime64 *>(&type);\n-                /// Convert 'YYYY-MM-DD hh:mm:ss.NNNNNNNNN' Strings to DateTime\n-                return stringToDateTime64(src.get<const String &>(), date_time64->getScale());\n-            }\n-            else if (which_type.isUUID())\n-            {\n-                return stringToUUID(src.get<const String &>());\n-            }\n-            else if (which_type.isEnum())\n-            {\n-                /// Convert String to Enum's value\n-                return dynamic_cast<const IDataTypeEnum &>(type).castToValue(src);\n-            }\n+            /// Already in needed type.\n+            return src;\n+        }\n+\n+        if (which_type.isDateTime64() && src.getType() == Field::Types::Decimal64)\n+        {\n+            /// Already in needed type.\n+            return src;\n         }\n+\n+        /// TODO Conversion from integers to DateTime64\n     }\n     else if (which_type.isStringOrFixedString())\n     {\n@@ -328,17 +271,37 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n         return src;\n     }\n \n+    /// Conversion from string by parsing.\n     if (src.getType() == Field::Types::String)\n     {\n-        const auto col = type.createColumn();\n-        ReadBufferFromString buffer(src.get<String>());\n-        type.deserializeAsTextEscaped(*col, buffer, FormatSettings{});\n+        /// Promote data type to avoid overflows. Note that overflows in the largest data type are still possible.\n+        const IDataType * type_to_parse = &type;\n+        DataTypePtr holder;\n \n-        return (*col)[0];\n-    }\n+        if (type.canBePromoted())\n+        {\n+            holder = type.promoteNumericType();\n+            type_to_parse = holder.get();\n+        }\n+\n+        const auto col = type_to_parse->createColumn();\n+        ReadBufferFromString in_buffer(src.get<String>());\n+        try\n+        {\n+            type_to_parse->deserializeAsWholeText(*col, in_buffer, FormatSettings{});\n+        }\n+        catch (Exception & e)\n+        {\n+            e.addMessage(fmt::format(\"while converting '{}' to {}\", src.get<String>(), type.getName()));\n+            throw;\n+        }\n+        if (!in_buffer.eof())\n+            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot convert string {} to type {}\", src.get<String>(), type.getName());\n \n+        Field parsed = (*col)[0];\n+        return convertFieldToType(parsed, type, from_type_hint);\n+    }\n \n-    // TODO (nemkov): should we attempt to parse value using or `type.deserializeAsTextEscaped()` type.deserializeAsTextEscaped() ?\n     throw Exception(\"Type mismatch in IN or VALUES section. Expected: \" + type.getName() + \". Got: \"\n         + Field::Types::toString(src.getType()), ErrorCodes::TYPE_MISMATCH);\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql b/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql\nindex 3071e3075178..e729bfdf188c 100644\n--- a/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql\n+++ b/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql\n@@ -4,7 +4,7 @@ DROP TABLE IF EXISTS numbers2;\n CREATE TABLE numbers1 ENGINE = Memory AS SELECT number as _table FROM numbers(1000);\n CREATE TABLE numbers2 ENGINE = Memory AS SELECT number as _table FROM numbers(1000);\n \n-SELECT count() FROM merge(currentDatabase(), '^numbers\\\\d+$') WHERE _table='numbers1'; -- { serverError 43 }\n+SELECT count() FROM merge(currentDatabase(), '^numbers\\\\d+$') WHERE _table='numbers1'; -- { serverError 53 }\n SELECT count() FROM merge(currentDatabase(), '^numbers\\\\d+$') WHERE _table=1;\n \n DROP TABLE numbers1;\ndiff --git a/tests/queries/0_stateless/00700_decimal_compare.reference b/tests/queries/0_stateless/00700_decimal_compare.reference\nindex 32f0b0a6dea1..2325847045f5 100644\n--- a/tests/queries/0_stateless/00700_decimal_compare.reference\n+++ b/tests/queries/0_stateless/00700_decimal_compare.reference\n@@ -1,3 +1,5 @@\n+0\n+1\n -42\t-42\t1\t0\t0\t0\t1\t1\n 42\t42\t1\t0\t0\t0\t1\t1\n -42\t-42.42000\t0\t0\t1\t1\t0\t1\ndiff --git a/tests/queries/0_stateless/00700_decimal_compare.sql b/tests/queries/0_stateless/00700_decimal_compare.sql\nindex 24b4ce588e57..ae2f5790570f 100644\n--- a/tests/queries/0_stateless/00700_decimal_compare.sql\n+++ b/tests/queries/0_stateless/00700_decimal_compare.sql\n@@ -19,7 +19,7 @@ INSERT INTO decimal (a, b, c, d, e, f, g, h, i, j) VALUES (-42, -42, -42, -0.42,\n \n SELECT a > toFloat64(0) FROM decimal; -- { serverError 43 }\n SELECT g > toFloat32(0) FROM decimal; -- { serverError 43 }\n-SELECT a > '0.0' FROM decimal; -- { serverError 43 }\n+SELECT a > '0.0' FROM decimal ORDER BY a;\n \n SELECT a, b, a = b, a < b, a > b, a != b, a <= b, a >= b FROM decimal ORDER BY a;\n SELECT a, g, a = g, a < g, a > g, a != g, a <= g, a >= g FROM decimal ORDER BY a;\ndiff --git a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\nindex c65bf668d717..4ffcf3be3c99 100644\n--- a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n+++ b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n@@ -1,12 +1,12 @@\n -- Error cases:\n -- non-const string column\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = materialize(S); -- {serverError 44}\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materialize(S) = toDateTime64(S, 3); -- {serverError 44}\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = materialize(S); -- {serverError 44}\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 44}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = materialize(S); -- {serverError 43}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materialize(S) = toDateTime64(S, 3); -- {serverError 43}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = materialize(S); -- {serverError 43}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 43}\n \n-SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 131} -- invalid DateTime64 string\n-SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333'; -- {serverError 131} -- invalid string length\n+SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 53} -- invalid DateTime64 string\n+SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333'; -- {serverError 53} -- invalid string length\n \n SELECT 'in SELECT';\n WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = S;\ndiff --git a/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql b/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql\nindex 05295575cf14..4712c1242370 100644\n--- a/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql\n+++ b/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql\n@@ -1,1 +1,1 @@\n-SELECT -2487, globalNullIn(toIntervalMinute(-88074), 'qEkek..'), [-27.537293]; -- { serverError 70 }\n+SELECT -2487, globalNullIn(toIntervalMinute(-88074), 'qEkek..'), [-27.537293]; -- { serverError 53 }\ndiff --git a/tests/queries/0_stateless/01310_enum_comparison.reference b/tests/queries/0_stateless/01310_enum_comparison.reference\nnew file mode 100644\nindex 000000000000..b261da18d51a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01310_enum_comparison.reference\n@@ -0,0 +1,2 @@\n+1\n+0\ndiff --git a/tests/queries/0_stateless/01310_enum_comparison.sql b/tests/queries/0_stateless/01310_enum_comparison.sql\nnew file mode 100644\nindex 000000000000..26901a61b2b2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01310_enum_comparison.sql\n@@ -0,0 +1,6 @@\n+CREATE TEMPORARY TABLE enum (x Enum('hello' = 1, 'world' = 2));\n+INSERT INTO enum VALUES ('hello');\n+\n+SELECT count() FROM enum WHERE x = 'hello';\n+SELECT count() FROM enum WHERE x = 'world';\n+SELECT count() FROM enum WHERE x = 'xyz'; -- { serverError 36 }\ndiff --git a/tests/queries/0_stateless/01311_comparison_with_constant_string.reference b/tests/queries/0_stateless/01311_comparison_with_constant_string.reference\nnew file mode 100644\nindex 000000000000..7865f42932d1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01311_comparison_with_constant_string.reference\n@@ -0,0 +1,32 @@\n+0\n+1\n+0\n+---\n+1\n+0\n+1\n+---\n+1\n+0\n+0\n+---\n+0\n+---\n+1\n+0\n+---\n+---\n+0\n+---\n+1\n+---\n+0\n+---\n+0\n+---\n+0\n+---\n+0\n+---\n+1\n+---\ndiff --git a/tests/queries/0_stateless/01311_comparison_with_constant_string.sql b/tests/queries/0_stateless/01311_comparison_with_constant_string.sql\nnew file mode 100644\nindex 000000000000..d6641a50c45f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01311_comparison_with_constant_string.sql\n@@ -0,0 +1,33 @@\n+SELECT number = '1' FROM numbers(3);\n+SELECT '---';\n+SELECT '1' != number FROM numbers(3);\n+SELECT '---';\n+SELECT '1' > number FROM numbers(3);\n+SELECT '---';\n+SELECT 1 = '257';\n+SELECT '---';\n+SELECT 1 IN (1.23, '1', 2);\n+SELECT 1 IN (1.23, '2', 2);\n+SELECT '---';\n+\n+-- it should work but it doesn't.\n+SELECT 1 = '1.0'; -- { serverError 53 }\n+SELECT '---';\n+\n+SELECT 1 = '257';\n+SELECT '---';\n+SELECT 1 != '257';\n+SELECT '---';\n+SELECT 1 < '257'; -- this is wrong for now\n+SELECT '---';\n+SELECT 1 > '257';\n+SELECT '---';\n+SELECT 1 <= '257'; -- this is wrong for now\n+SELECT '---';\n+SELECT 1 >= '257';\n+SELECT '---';\n+\n+SELECT toDateTime('2020-06-13 01:02:03') = '2020-06-13T01:02:03';\n+SELECT '---';\n+\n+SELECT 0 = ''; -- { serverError 32 }\n",
  "problem_statement": "RFC: automatic type cast of literals in obvious cases\n```\r\nselect * from numbers(100) where number = '1';\r\n```\r\nliterals can be casted to the column type. \r\n\r\nIn general case there are too many side effects.\n",
  "hints_text": "Usual issue with other databases: in case col_string = 1 need to cast col_string to Int and this breaks index access.\nYep, that why I'm saying only of allowing cast of literal (i.e. constants used in the query) to column type, and never opposite (that sounds relatively safe, but maybe there are some other issues). \nWe have to implement it for SQL compatibility.\r\nBut it is not in development.\r\n\r\nIt will be more handy if we can postpone it after implementation of #3775 but that task is abandoned, and we should find simpler solution.\r\n\r\nExample: a setting to enable cast of constants in comparison operators.\r\nNote that it was already implemented for date and datetime: you can write `d = '2000-01-01'`.",
  "created_at": "2020-06-13T23:29:19Z"
}