diff --git a/docs/en/sql-reference/data-types/enum.md b/docs/en/sql-reference/data-types/enum.md
index ae22e60a5f39..0f6e1e1f001c 100644
--- a/docs/en/sql-reference/data-types/enum.md
+++ b/docs/en/sql-reference/data-types/enum.md
@@ -7,7 +7,7 @@ toc_title: Enum
 
 Enumerated type consisting of named values.
 
-Named values must be declared as `'string' = integer` pairs. ClickHouse stores only numbers, but supports operations with the values through their names.
+Named values can be declared as `'string' = integer` pairs or `'string'` names . ClickHouse stores only numbers, but supports operations with the values through their names.
 
 ClickHouse supports:
 
@@ -28,6 +28,39 @@ CREATE TABLE t_enum
 ENGINE = TinyLog
 ```
 
+Similarly, you could omit numbers. ClickHouse will assign consecutive numbers automatically. Numbers are assigned starting from 1 by default.
+
+``` sql
+CREATE TABLE t_enum
+(
+    x Enum('hello', 'world')
+)
+ENGINE = TinyLog
+```
+
+You can also specify legal starting number for the first name.
+
+``` sql
+CREATE TABLE t_enum
+(
+    x Enum('hello' = 1, 'world')
+)
+ENGINE = TinyLog
+```
+
+``` sql
+CREATE TABLE t_enum
+(
+    x Enum8('hello' = -129, 'world')
+)
+ENGINE = TinyLog
+```
+
+``` text
+Exception on server:
+Code: 69. DB::Exception: Value -129 for element 'hello' exceeds range of Enum8.
+```
+
 Column `x` can only store values that are listed in the type definition: `'hello'` or `'world'`. If you try to save any other value, ClickHouse will raise an exception. 8-bit size for this `Enum` is chosen automatically.
 
 ``` sql
diff --git a/docs/ru/sql-reference/data-types/enum.md b/docs/ru/sql-reference/data-types/enum.md
index 95c053bed2cb..1262c9e1cd59 100644
--- a/docs/ru/sql-reference/data-types/enum.md
+++ b/docs/ru/sql-reference/data-types/enum.md
@@ -7,7 +7,7 @@ toc_title: Enum
 
 Перечисляемый тип данных, содержащий именованные значения.
 
-Именованные значения задаются парами `'string' = integer`. ClickHouse хранит только числа, но допускает операции над ними с помощью заданных имён.
+Именованные значения задаются либо парами `'string' = integer`, либо именами `'string'`. ClickHouse хранит только числа, но допускает операции над ними с помощью заданных имён.
 
 ClickHouse поддерживает:
 
@@ -28,6 +28,39 @@ CREATE TABLE t_enum
 ENGINE = TinyLog
 ```
 
+Номера могут быть опущены - в этом случае ClickHouse автоматически присвоит последовательные номера, начиная с 1.
+
+``` sql
+CREATE TABLE t_enum
+(
+    x Enum('hello', 'world')
+)
+ENGINE = TinyLog
+```
+
+Можно также указать допустимый стартовый номер для первого имени.
+
+``` sql
+CREATE TABLE t_enum
+(
+    x Enum('hello' = 1, 'world')
+)
+ENGINE = TinyLog
+```
+
+``` sql
+CREATE TABLE t_enum
+(
+    x Enum8('hello' = -129, 'world')
+)
+ENGINE = TinyLog
+```
+
+``` text
+Exception on server:
+Code: 69. DB::Exception: Value -129 for element 'hello' exceeds range of Enum8.
+```
+
 В столбец `x` можно сохранять только значения, перечисленные при определении типа, т.е. `'hello'` или `'world'`. Если вы попытаетесь сохранить любое другое значение, ClickHouse сгенерирует исключение. ClickHouse автоматически выберет размерность 8-bit для этого `Enum`.
 
 ``` sql
diff --git a/src/DataTypes/DataTypeEnum.cpp b/src/DataTypes/DataTypeEnum.cpp
index 9d1424d862b5..c58e186b980a 100644
--- a/src/DataTypes/DataTypeEnum.cpp
+++ b/src/DataTypes/DataTypeEnum.cpp
@@ -193,26 +193,46 @@ static void checkASTStructure(const ASTPtr & child)
 
 static void autoAssignNumberForEnum(const ASTPtr & arguments)
 {
-    UInt64 literal_child_count = 0;
-    UInt64 func_child_count = 0;
+    Int64 literal_child_assign_num = 1;
     ASTs assign_number_child;
     assign_number_child.reserve(arguments->children.size());
+    bool is_first_child = true;
+    size_t assign_count= 0;
+
     for (const ASTPtr & child : arguments->children)
     {
         if (child->as<ASTLiteral>())
         {
-            ASTPtr func = makeASTFunction("equals", child, std::make_shared<ASTLiteral>(++literal_child_count));
+            assign_count += !is_first_child;
+            ASTPtr func = makeASTFunction("equals", child, std::make_shared<ASTLiteral>(literal_child_assign_num + assign_count));
             assign_number_child.emplace_back(func);
         }
-        else
+        else if (child->as<ASTFunction>())
         {
-            ++func_child_count;
+            if (is_first_child)
+            {
+                checkASTStructure(child);
+                const auto * func = child->as<ASTFunction>();
+                const auto * value_literal = func->arguments->children[1]->as<ASTLiteral>();
+
+                if (!value_literal
+                    || (value_literal->value.getType() != Field::Types::UInt64 && value_literal->value.getType() != Field::Types::Int64))
+                    throw Exception("Elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer",
+                                    ErrorCodes::UNEXPECTED_AST_STRUCTURE);
+
+                literal_child_assign_num = value_literal->value.get<Int64>();
+            }
             assign_number_child.emplace_back(child);
         }
+        else
+            throw Exception("Elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer",
+                            ErrorCodes::UNEXPECTED_AST_STRUCTURE);
+
+        is_first_child = false;
     }
 
-    if (func_child_count > 0 && literal_child_count > 0)
-        throw Exception("ALL Elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer",
+    if (assign_count != 0 && assign_count != arguments->children.size() - 1)
+        throw Exception("All elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer",
                         ErrorCodes::UNEXPECTED_AST_STRUCTURE);
 
     arguments->children = assign_number_child;
@@ -243,7 +263,7 @@ static DataTypePtr createExact(const ASTPtr & arguments)
             || !value_literal
             || name_literal->value.getType() != Field::Types::String
             || (value_literal->value.getType() != Field::Types::UInt64 && value_literal->value.getType() != Field::Types::Int64))
-            throw Exception("Elements of Enum data type must be of form: 'name' = number, where name is string literal and number is an integer",
+            throw Exception("Elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer",
                 ErrorCodes::UNEXPECTED_AST_STRUCTURE);
 
         const String & field_name = name_literal->value.get<String>();
@@ -275,7 +295,7 @@ static DataTypePtr create(const ASTPtr & arguments)
 
         if (!value_literal
             || (value_literal->value.getType() != Field::Types::UInt64 && value_literal->value.getType() != Field::Types::Int64))
-            throw Exception("Elements of Enum data type must be of form: 'name' = number, where name is string literal and number is an integer",
+            throw Exception("Elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer",
                     ErrorCodes::UNEXPECTED_AST_STRUCTURE);
 
         Int64 value = value_literal->value.get<Int64>();
