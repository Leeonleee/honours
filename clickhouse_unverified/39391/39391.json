{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39391,
  "instance_id": "ClickHouse__ClickHouse-39391",
  "issue_numbers": [
    "38930"
  ],
  "base_commit": "499818751ef56e7b53bd36ad33fea884b7eb6cea",
  "patch": "diff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h\nindex 00b5e2b9e376..7bcc65934358 100644\n--- a/src/DataTypes/DataTypesDecimal.h\n+++ b/src/DataTypes/DataTypesDecimal.h\n@@ -5,6 +5,7 @@\n #include <Common/typeid_cast.h>\n #include <DataTypes/IDataType.h>\n #include <DataTypes/DataTypeDecimalBase.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n \n \n namespace DB\n@@ -13,6 +14,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int DECIMAL_OVERFLOW;\n+    extern const int LOGICAL_ERROR;\n }\n \n /// Implements Decimal(P, S), where P is precision, S is scale.\n@@ -58,7 +60,7 @@ inline const DataTypeDecimal<T> * checkDecimal(const IDataType & data_type)\n     return typeid_cast<const DataTypeDecimal<T> *>(&data_type);\n }\n \n-inline UInt32 getDecimalScale(const IDataType & data_type, UInt32 default_value = std::numeric_limits<UInt32>::max())\n+inline UInt32 getDecimalScale(const IDataType & data_type)\n {\n     if (const auto * decimal_type = checkDecimal<Decimal32>(data_type))\n         return decimal_type->getScale();\n@@ -68,7 +70,10 @@ inline UInt32 getDecimalScale(const IDataType & data_type, UInt32 default_value\n         return decimal_type->getScale();\n     if (const auto * decimal_type = checkDecimal<Decimal256>(data_type))\n         return decimal_type->getScale();\n-    return default_value;\n+    if (const auto * date_time_type = typeid_cast<const DataTypeDateTime64 *>(&data_type))\n+        return date_time_type->getScale();\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot get decimal scale from type {}\", data_type.getName());\n }\n \n inline UInt32 getDecimalPrecision(const IDataType & data_type)\n@@ -81,7 +86,10 @@ inline UInt32 getDecimalPrecision(const IDataType & data_type)\n         return decimal_type->getPrecision();\n     if (const auto * decimal_type = checkDecimal<Decimal256>(data_type))\n         return decimal_type->getPrecision();\n-    return 0;\n+    if (const auto * date_time_type = typeid_cast<const DataTypeDateTime64 *>(&data_type))\n+        return date_time_type->getPrecision();\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot get decimal precision from type {}\", data_type.getName());\n }\n \n template <typename T>\ndiff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp\nindex 65ed37f1dcf5..fee3cf1553e0 100644\n--- a/src/DataTypes/getLeastSupertype.cpp\n+++ b/src/DataTypes/getLeastSupertype.cpp\n@@ -554,7 +554,11 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n             UInt32 max_scale = 0;\n             for (const auto & type : types)\n             {\n-                UInt32 scale = getDecimalScale(*type, 0);\n+                auto type_id = type->getTypeId();\n+                if (type_id != TypeIndex::Decimal32 && type_id != TypeIndex::Decimal64 && type_id != TypeIndex::Decimal128)\n+                    continue;\n+\n+                UInt32 scale = getDecimalScale(*type);\n                 if (scale > max_scale)\n                     max_scale = scale;\n             }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02364_dictionary_datetime_64_attribute_crash.reference b/tests/queries/0_stateless/02364_dictionary_datetime_64_attribute_crash.reference\nnew file mode 100644\nindex 000000000000..cd97db4debdf\n--- /dev/null\n+++ b/tests/queries/0_stateless/02364_dictionary_datetime_64_attribute_crash.reference\n@@ -0,0 +1,2 @@\n+2022-01-24 02:30:00.008122000\n+1\ndiff --git a/tests/queries/0_stateless/02364_dictionary_datetime_64_attribute_crash.sql b/tests/queries/0_stateless/02364_dictionary_datetime_64_attribute_crash.sql\nnew file mode 100644\nindex 000000000000..77fc9e1183bf\n--- /dev/null\n+++ b/tests/queries/0_stateless/02364_dictionary_datetime_64_attribute_crash.sql\n@@ -0,0 +1,15 @@\n+create table dat (blockNum Decimal(10,0), eventTimestamp DateTime64(9)) Engine=MergeTree() primary key eventTimestamp;\n+insert into dat values (1, '2022-01-24 02:30:00.008122000');\n+\n+CREATE DICTIONARY datDictionary\n+(\n+    `blockNum` Decimal(10, 0),\n+    `eventTimestamp` DateTime64(9)\n+)\n+PRIMARY KEY blockNum\n+SOURCE(CLICKHOUSE(TABLE 'dat'))\n+LIFETIME(MIN 0 MAX 1000)\n+LAYOUT(FLAT());\n+\n+select (select eventTimestamp from datDictionary);\n+select count(*) from dat where eventTimestamp >= (select eventTimestamp from datDictionary);\n",
  "problem_statement": "Segfault with Dictionary with DateTime64(9) attribute\n```sql\r\ncreate table dat (blockNum Decimal(10,0), eventTimestamp DateTime64(9) ) \r\nEngine=MergeTree() primary key eventTimestamp;\r\ninsert into dat values (1, '2022-01-24 02:30:00.008122000');\r\n\r\nCREATE DICTIONARY datDictionary\r\n(\r\n    `blockNum` Decimal(10, 0),\r\n    `eventTimestamp` DateTime64(9)\r\n)\r\nPRIMARY KEY blockNum\r\nSOURCE(CLICKHOUSE(TABLE 'dat'))\r\nLIFETIME(MIN 0 MAX 1000)\r\nLAYOUT(FLAT());\r\n\r\nselect * from datDictionary;\r\n\u250c\u2500blockNum\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500eventTimestamp\u2500\u2510\r\n\u2502        1 \u2502 2022-01-24 02:30:00.008122000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect count(*) from dat where eventTimestamp >= (select eventTimestamp from datDictionary);\r\n\r\nException on client:\r\nCode: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000. (ATTEMPT_TO_READ_AFTER_EOF)\r\n\r\nConnecting to localhost:9000 as user default.\r\nCode: 210. DB::NetException: Connection refused (localhost:9000). (NETWORK_ERROR)\r\n```\r\n\r\n```sql\r\ndrop dictionary datDictionary;\r\n\r\nCREATE DICTIONARY datDictionary\r\n(\r\n    `blockNum` Decimal(10, 0),\r\n    `eventTimestamp` DateTime64(9)\r\n)\r\nPRIMARY KEY blockNum\r\nSOURCE(CLICKHOUSE(TABLE 'dat'))\r\nLIFETIME(MIN 0 MAX 1000)\r\nLAYOUT(complex_key_hashed());\r\n\r\nselect count(*) from dat where eventTimestamp >= (select eventTimestamp from datDictionary);\r\n\r\nError on processing query: Code: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000. (ATTEMPT_TO_READ_AFTER_EOF) (version 22.7.1.1054)\r\n\r\nConnecting to localhost:9000 as user default.\r\nCode: 210. DB::NetException: Connection refused (localhost:9000). (NETWORK_ERROR)\r\n```\r\n\r\n```sql\r\nselect * from datDictionary;\r\n\u250c\u2500blockNum\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500eventTimestamp\u2500\u2510\r\n\u2502        1 \u2502 2022-01-24 02:30:00.008122000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect dictGet('datDictionary', 'eventTimestamp', tuple(cast('1','Decimal(10,0)')));\r\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Bad scale of decimal field. (DECIMAL_OVERFLOW)\r\n```\r\n\n",
  "hints_text": "The same test with UInt64 instead of Decimal(10, 0) still crashes for me.\r\n\r\nBut change the DateTime64 to just DateTime and it succeeds.",
  "created_at": "2022-07-19T16:52:08Z"
}