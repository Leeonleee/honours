{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57549,
  "instance_id": "ClickHouse__ClickHouse-57549",
  "issue_numbers": [
    "57516"
  ],
  "base_commit": "0159a4d4a2e047f02d38ac684b4cec855041094b",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex 1940993ce0b1..0f85b81278d5 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -393,40 +393,6 @@ Reverses the sequence of bytes in a string.\n \n Reverses a sequence of Unicode code points in a string. Assumes that the string contains valid UTF-8 encoded text. If this assumption is violated, no exception is thrown and the result is undefined.\n \n-## format\n-\n-Format the `pattern` string with the strings listed in the arguments, similar to formatting in Python. The pattern string can contain replacement fields surrounded by curly braces `{}`. Anything not contained in braces is considered literal text and copied verbatim into the output. Literal brace character can be escaped by two braces: `{{ '{{' }}` and `{{ '}}' }}`. Field names can be numbers (starting from zero) or empty (then they are implicitly given monotonically increasing numbers).\n-\n-**Syntax**\n-\n-```sql\n-format(pattern, s0, s1, \u2026)\n-```\n-\n-**Example**\n-\n-``` sql\n-SELECT format('{1} {0} {1}', 'World', 'Hello')\n-```\n-\n-```result\n-\u250c\u2500format('{1} {0} {1}', 'World', 'Hello')\u2500\u2510\n-\u2502 Hello World Hello                       \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n-With implicit numbers:\n-\n-``` sql\n-SELECT format('{} {}', 'Hello', 'World')\n-```\n-\n-```result\n-\u250c\u2500format('{} {}', 'Hello', 'World')\u2500\u2510\n-\u2502 Hello World                       \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n ## concat\n \n Concatenates the given arguments.\ndiff --git a/docs/en/sql-reference/functions/string-replace-functions.md b/docs/en/sql-reference/functions/string-replace-functions.md\nindex 74d5d7471938..c7bd16cad4aa 100644\n--- a/docs/en/sql-reference/functions/string-replace-functions.md\n+++ b/docs/en/sql-reference/functions/string-replace-functions.md\n@@ -132,6 +132,40 @@ For more information, see [RE2](https://github.com/google/re2/blob/master/re2/re\n regexpQuoteMeta(s)\n ```\n \n+## format\n+\n+Format the `pattern` string with the values (strings, integers, etc.) listed in the arguments, similar to formatting in Python. The pattern string can contain replacement fields surrounded by curly braces `{}`. Anything not contained in braces is considered literal text and copied verbatim into the output. Literal brace character can be escaped by two braces: `{{ '{{' }}` and `{{ '}}' }}`. Field names can be numbers (starting from zero) or empty (then they are implicitly given monotonically increasing numbers).\n+\n+**Syntax**\n+\n+```sql\n+format(pattern, s0, s1, \u2026)\n+```\n+\n+**Example**\n+\n+``` sql\n+SELECT format('{1} {0} {1}', 'World', 'Hello')\n+```\n+\n+```result\n+\u250c\u2500format('{1} {0} {1}', 'World', 'Hello')\u2500\u2510\n+\u2502 Hello World Hello                       \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+With implicit numbers:\n+\n+``` sql\n+SELECT format('{} {}', 'Hello', 'World')\n+```\n+\n+```result\n+\u250c\u2500format('{} {}', 'Hello', 'World')\u2500\u2510\n+\u2502 Hello World                       \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## translate\n \n Replaces characters in the string `s` using a one-to-one character mapping defined by `from` and `to` strings. `from` and `to` must be constant ASCII strings of the same size. Non-ASCII characters in the original string are not modified.\ndiff --git a/src/Functions/concat.cpp b/src/Functions/concat.cpp\nindex 6403c4b8416a..4d7d9ffb56c4 100644\n--- a/src/Functions/concat.cpp\n+++ b/src/Functions/concat.cpp\n@@ -7,10 +7,10 @@\n #include <Functions/GatherUtils/Sinks.h>\n #include <Functions/GatherUtils/Sources.h>\n #include <Functions/IFunction.h>\n+#include <Functions/formatString.h>\n #include <IO/WriteHelpers.h>\n #include <base/map.h>\n \n-#include \"formatString.h\"\n \n namespace DB\n {\ndiff --git a/src/Functions/concatWithSeparator.cpp b/src/Functions/concatWithSeparator.cpp\nindex f295d86943f9..b4f3732710fd 100644\n--- a/src/Functions/concatWithSeparator.cpp\n+++ b/src/Functions/concatWithSeparator.cpp\n@@ -4,11 +4,11 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunction.h>\n+#include <Functions/formatString.h>\n #include <IO/WriteHelpers.h>\n #include <base/map.h>\n #include <base/range.h>\n \n-#include \"formatString.h\"\n \n namespace DB\n {\ndiff --git a/src/Functions/formatString.cpp b/src/Functions/format.cpp\nsimilarity index 72%\nrename from src/Functions/formatString.cpp\nrename to src/Functions/format.cpp\nindex 8e0b3a238cb2..f1f73cfe4387 100644\n--- a/src/Functions/formatString.cpp\n+++ b/src/Functions/format.cpp\n@@ -1,35 +1,33 @@\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnStringHelpers.h>\n #include <DataTypes/DataTypeString.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunction.h>\n+#include <Functions/formatString.h>\n #include <IO/WriteHelpers.h>\n-#include <base/range.h>\n \n #include <memory>\n #include <string>\n #include <vector>\n \n-#include \"formatString.h\"\n \n namespace DB\n {\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n namespace\n {\n \n-template <typename Name>\n class FormatFunction : public IFunction\n {\n public:\n-    static constexpr auto name = Name::name;\n+    static constexpr auto name = \"format\";\n \n     static FunctionPtr create(ContextPtr) { return std::make_shared<FormatFunction>(); }\n \n@@ -52,18 +50,6 @@ class FormatFunction : public IFunction\n                 getName(),\n                 arguments.size());\n \n-        for (const auto arg_idx : collections::range(0, arguments.size()))\n-        {\n-            const auto * arg = arguments[arg_idx].get();\n-            if (!isStringOrFixedString(arg))\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type {} of argument {} of function {}\",\n-                    arg->getName(),\n-                    arg_idx + 1,\n-                    getName());\n-        }\n-\n         return std::make_shared<DataTypeString>();\n     }\n \n@@ -83,6 +69,7 @@ class FormatFunction : public IFunction\n         std::vector<const ColumnString::Offsets *> offsets(arguments.size() - 1);\n         std::vector<size_t> fixed_string_sizes(arguments.size() - 1);\n         std::vector<std::optional<String>> constant_strings(arguments.size() - 1);\n+        std::vector<ColumnString::MutablePtr> converted_col_ptrs(arguments.size() - 1);\n \n         bool has_column_string = false;\n         bool has_column_fixed_string = false;\n@@ -106,8 +93,29 @@ class FormatFunction : public IFunction\n                 constant_strings[i - 1] = const_col->getValue<String>();\n             }\n             else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n-                    column->getName(), getName());\n+            {\n+                /// A non-String/non-FixedString-type argument: use the default serialization to convert it to String\n+                auto full_column = column->convertToFullIfNeeded();\n+                auto serialization = arguments[i].type->getDefaultSerialization();\n+                auto converted_col_str = ColumnString::create();\n+                ColumnStringHelpers::WriteHelper write_helper(*converted_col_str, column->size());\n+                auto & write_buffer = write_helper.getWriteBuffer();\n+                FormatSettings format_settings;\n+                for (size_t row = 0; row < column->size(); ++row)\n+                {\n+                    serialization->serializeText(*full_column, row, write_buffer, format_settings);\n+                    write_helper.rowWritten();\n+                }\n+                write_helper.finalize();\n+\n+                /// Same as the normal `ColumnString` branch\n+                has_column_string = true;\n+                data[i - 1] = &converted_col_str->getChars();\n+                offsets[i - 1] = &converted_col_str->getOffsets();\n+\n+                /// Keep the pointer alive\n+                converted_col_ptrs[i - 1] = std::move(converted_col_str);\n+            }\n         }\n \n         FormatStringImpl::formatExecute(\n@@ -127,11 +135,7 @@ class FormatFunction : public IFunction\n };\n \n \n-struct NameFormat\n-{\n-    static constexpr auto name = \"format\";\n-};\n-using FunctionFormat = FormatFunction<NameFormat>;\n+using FunctionFormat = FormatFunction;\n \n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02935_format_with_arbitrary_types.reference b/tests/queries/0_stateless/02935_format_with_arbitrary_types.reference\nnew file mode 100644\nindex 000000000000..3455adc8723e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02935_format_with_arbitrary_types.reference\n@@ -0,0 +1,70 @@\n+-- Const string + non-const arbitrary type\n+The answer to all questions is 42.\n+The answer to all questions is 43.\n+The answer to all questions is 44.\n+The answer to all questions is 45.\n+The answer to all questions is 46.\n+The answer to all questions is 47.\n+The answer to all questions is 48.\n+The answer to all questions is 49.\n+The answer to all questions is 50.\n+The answer to all questions is 51.\n+The answer to all questions is 52.\n+The answer to all questions is 53.\n+The answer to all questions is 42.42.\n+The answer to all questions is 43.43.\n+The answer to all questions is 44.\n+The answer to all questions is true.\n+The answer to all questions is false.\n+The answer to all questions is foo.\n+The answer to all questions is bar.\n+The answer to all questions is foo.\n+The answer to all questions is bar.\n+The answer to all questions is foo.\n+The answer to all questions is bar.\n+The answer to all questions is foo.\n+The answer to all questions is bar.\n+The answer to all questions is 42.\n+The answer to all questions is 42.\n+The answer to all questions is fae310ca-d52a-4923-9e9b-02bf67f4b009.\n+The answer to all questions is 2023-11-14.\n+The answer to all questions is 2123-11-14.\n+The answer to all questions is 2023-11-14 05:50:12.\n+The answer to all questions is 2023-11-14 05:50:12.123.\n+The answer to all questions is hallo.\n+The answer to all questions is [\\'foo\\',\\'bar\\'].\n+The answer to all questions is {\"foo\":\"bar\"}.\n+The answer to all questions is (42,\\'foo\\').\n+The answer to all questions is {42:\\'foo\\'}.\n+The answer to all questions is 122.233.64.201.\n+The answer to all questions is 2001:1:130f:2:3:9c0:876a:130b.\n+The answer to all questions is (42,43).\n+The answer to all questions is [(0,0),(10,0),(10,10),(0,10)].\n+The answer to all questions is [[(20,20),(50,20),(50,50),(20,50)],[(30,30),(50,50),(50,30)]].\n+The answer to all questions is [[[(0,0),(10,0),(10,10),(0,10)]],[[(20,20),(50,20),(50,50),(20,50)],[(30,30),(50,50),(50,30)]]].\n+-- Nested\n+The [\\'foo\\',\\'bar\\'] to all questions is [\\'qaz\\',\\'qux\\'].\n+-- NULL arguments\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+-- Various arguments tests\n+The Non-const to all questions is  strings\n+The Two arguments  to all questions is test\n+The Three  to all questions is arguments and  test\n+The 3 to all questions is  arguments test and  with int type\n+The 42 to all questions is 144\n+The 42 to all questions is 144 and 255\n+The 42 to all questions is 144\n+The 42 to all questions is 144 and 255\n+-- Single argument tests\n+The answer to all questions is 42.\n+The answer to all questions is 42.\n+The answer to all questions is foo.\n+The answer to all questions is foo.\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/02935_format_with_arbitrary_types.sql b/tests/queries/0_stateless/02935_format_with_arbitrary_types.sql\nnew file mode 100644\nindex 000000000000..ad1de2bec6d2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02935_format_with_arbitrary_types.sql\n@@ -0,0 +1,85 @@\n+\n+-- Tags: no-fasttest\n+-- no-fasttest: json type needs rapidjson library, geo types need s2 geometry\n+\n+SET allow_experimental_object_type = 1;\n+SET allow_suspicious_low_cardinality_types=1;\n+\n+SELECT '-- Const string + non-const arbitrary type';\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(42 :: Int8));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(43 :: Int16));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(44 :: Int32));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(45 :: Int64));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(46 :: Int128));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(47 :: Int256));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(48 :: UInt8));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(49 :: UInt16));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(50 :: UInt32));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(51 :: UInt64));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(52 :: UInt128));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(53 :: UInt256));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(42.42 :: Float32));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(43.43 :: Float64));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(44.44 :: Decimal(2)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(true :: Bool));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(false :: Bool));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('foo' :: String));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('bar' :: FixedString(3)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('foo' :: Nullable(String)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('bar' :: Nullable(FixedString(3))));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('foo' :: LowCardinality(String)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('bar' :: LowCardinality(FixedString(3))));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('foo' :: LowCardinality(Nullable(String))));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('bar' :: LowCardinality(Nullable(FixedString(3)))));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(42 :: LowCardinality(Nullable(UInt32))));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(42 :: LowCardinality(UInt32)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('fae310ca-d52a-4923-9e9b-02bf67f4b009' :: UUID));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('2023-11-14' :: Date));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('2123-11-14' :: Date32));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('2023-11-14 05:50:12' :: DateTime('Europe/Amsterdam')));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('2023-11-14 05:50:12.123' :: DateTime64(3, 'Europe/Amsterdam')));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('hallo' :: Enum('hallo' = 1)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(['foo', 'bar'] :: Array(String)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('{\"foo\": \"bar\"}' :: JSON));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize((42, 'foo') :: Tuple(Int32, String)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize(map(42, 'foo') :: Map(Int32, String)));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('122.233.64.201' :: IPv4));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize('2001:0001:130F:0002:0003:09C0:876A:130B' :: IPv6));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize((42, 43) :: Point));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize([(0,0),(10,0),(10,10),(0,10)] :: Ring));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize([[(20, 20), (50, 20), (50, 50), (20, 50)], [(30, 30), (50, 50), (50, 30)]] :: Polygon));\n+SELECT format('The {0} to all questions is {1}.', 'answer', materialize([[[(0, 0), (10, 0), (10, 10), (0, 10)]], [[(20, 20), (50, 20), (50, 50), (20, 50)],[(30, 30), (50, 50), (50, 30)]]] :: MultiPolygon));\n+\n+SELECT '-- Nested';\n+DROP TABLE IF EXISTS format_nested;\n+CREATE TABLE format_nested(attrs Nested(k String, v String)) ENGINE = MergeTree ORDER BY tuple();\n+INSERT INTO format_nested VALUES (['foo', 'bar'], ['qaz', 'qux']);\n+SELECT format('The {0} to all questions is {1}.', attrs.k, attrs.v) FROM format_nested;\n+DROP TABLE format_nested;\n+\n+SELECT '-- NULL arguments';\n+SELECT format('The {0} to all questions is {1}', NULL, NULL);\n+SELECT format('The {0} to all questions is {1}', NULL, materialize(NULL :: Nullable(UInt64)));\n+SELECT format('The {0} to all questions is {1}', materialize(NULL :: Nullable(UInt64)), materialize(NULL :: Nullable(UInt64)));\n+SELECT format('The {0} to all questions is {1}', 42, materialize(NULL :: Nullable(UInt64)));\n+SELECT format('The {0} to all questions is {1}', '42', materialize(NULL :: Nullable(UInt64)));\n+SELECT format('The {0} to all questions is {1}', 42, materialize(NULL :: Nullable(UInt64)), materialize(NULL :: Nullable(UInt64)));\n+SELECT format('The {0} to all questions is {1}', '42', materialize(NULL :: Nullable(UInt64)), materialize(NULL :: Nullable(UInt64)));\n+\n+SELECT '-- Various arguments tests';\n+SELECT format('The {0} to all questions is {1}', materialize('Non-const'), materialize(' strings'));\n+SELECT format('The {0} to all questions is {1}', 'Two arguments ', 'test');\n+SELECT format('The {0} to all questions is {1} and {2}', 'Three ', 'arguments', ' test');\n+SELECT format('The {0} to all questions is {1} and {2}', materialize(3 :: Int64), ' arguments test', ' with int type');\n+SELECT format('The {0} to all questions is {1}', materialize(42 :: Int32), materialize(144 :: UInt64));\n+SELECT format('The {0} to all questions is {1} and {2}', materialize(42 :: Int32), materialize(144 :: UInt64), materialize(255 :: UInt32));\n+SELECT format('The {0} to all questions is {1}', 42, 144);\n+SELECT format('The {0} to all questions is {1} and {2}', 42, 144, 255);\n+\n+SELECT '-- Single argument tests';\n+SELECT format('The answer to all questions is {0}.', 42);\n+SELECT format('The answer to all questions is {0}.', materialize(42));\n+SELECT format('The answer to all questions is {0}.', 'foo');\n+SELECT format('The answer to all questions is {0}.', materialize('foo'));\n+SELECT format('The answer to all questions is {0}.', NULL);\n+SELECT format('The answer to all questions is {0}.', materialize(NULL :: Nullable(UInt64)));\n",
  "problem_statement": "Support arbitrary arguments in function `format()`\nIn the spirit of PR #56540, function [format()](https://clickhouse.com/docs/en/sql-reference/functions/string-functions#format) should support arguments of arbitrary type.\r\n\r\nBasically make this work:\r\n\r\n```sql\r\nSELECT format('The {0} to all questions is {1}', 'answer', 42);\r\n```\n",
  "hints_text": "",
  "created_at": "2023-12-05T22:51:52Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-functions.md",
    "docs/en/sql-reference/functions/string-replace-functions.md",
    "src/Functions/concat.cpp",
    "src/Functions/concatWithSeparator.cpp",
    "b/src/Functions/format.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02935_format_with_arbitrary_types.reference",
    "b/tests/queries/0_stateless/02935_format_with_arbitrary_types.sql"
  ]
}