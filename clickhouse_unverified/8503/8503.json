{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8503,
  "instance_id": "ClickHouse__ClickHouse-8503",
  "issue_numbers": [
    "3885"
  ],
  "base_commit": "8f0d4995b8e3e1b3fd9842ee4012a6ae6f2a6316",
  "patch": "diff --git a/dbms/src/Functions/neighbor.cpp b/dbms/src/Functions/neighbor.cpp\nindex 0253aed65d3f..c37a3313a806 100644\n--- a/dbms/src/Functions/neighbor.cpp\n+++ b/dbms/src/Functions/neighbor.cpp\n@@ -40,6 +40,8 @@ class FunctionNeighbor : public IFunction\n \n     bool isVariadic() const override { return true; }\n \n+    bool isStateful() const override { return true; }\n+\n     bool isDeterministic() const override { return false; }\n \n     bool isDeterministicInScopeOfQuery() const override { return false; }\ndiff --git a/dbms/src/Interpreters/DatabaseAndTableWithAlias.h b/dbms/src/Interpreters/DatabaseAndTableWithAlias.h\nindex 3567a351b14c..ad1f747b6fd1 100644\n--- a/dbms/src/Interpreters/DatabaseAndTableWithAlias.h\n+++ b/dbms/src/Interpreters/DatabaseAndTableWithAlias.h\n@@ -72,4 +72,6 @@ struct TableWithColumnNames\n std::vector<DatabaseAndTableWithAlias> getDatabaseAndTables(const ASTSelectQuery & select_query, const String & current_database);\n std::optional<DatabaseAndTableWithAlias> getDatabaseAndTable(const ASTSelectQuery & select, size_t table_number);\n \n+using TablesWithColumnNames = std::vector<TableWithColumnNames>;\n+\n }\ndiff --git a/dbms/src/Interpreters/ExpressionAnalyzer.cpp b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\nindex 59dff858cf0c..fa199f94efcf 100644\n--- a/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/dbms/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -26,7 +26,6 @@\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/InJoinSubqueriesPreprocessor.h>\n #include <Interpreters/LogicalExpressionsOptimizer.h>\n-#include <Interpreters/PredicateExpressionsOptimizer.h>\n #include <Interpreters/ExternalDictionariesLoader.h>\n #include <Interpreters/Set.h>\n #include <Interpreters/AnalyzedJoin.h>\ndiff --git a/dbms/src/Interpreters/ExtractExpressionInfoVisitor.cpp b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.cpp\nnew file mode 100644\nindex 000000000000..1240b6a09d65\n--- /dev/null\n+++ b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.cpp\n@@ -0,0 +1,79 @@\n+#include <Interpreters/ExtractExpressionInfoVisitor.h>\n+#include <Functions/FunctionFactory.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <Interpreters/IdentifierSemantic.h>\n+#include <Parsers/ASTSubquery.h>\n+\n+\n+namespace DB\n+{\n+\n+void ExpressionInfoMatcher::visit(const ASTPtr & ast, Data & data)\n+{\n+    if (const auto * function = ast->as<ASTFunction>())\n+        visit(*function, ast, data);\n+    else if (const auto * identifier = ast->as<ASTIdentifier>())\n+        visit(*identifier, ast, data);\n+}\n+\n+void ExpressionInfoMatcher::visit(const ASTFunction & ast_function, const ASTPtr &, Data & data)\n+{\n+    if (ast_function.name == \"arrayJoin\")\n+        data.is_array_join = true;\n+    else if (AggregateFunctionFactory::instance().isAggregateFunctionName(ast_function.name))\n+        data.is_aggregate_function = true;\n+    else\n+    {\n+        const auto & function = FunctionFactory::instance().tryGet(ast_function.name, data.context);\n+\n+        /// Skip lambda, tuple and other special functions\n+        if (function && function->isStateful())\n+            data.is_stateful_function = true;\n+    }\n+}\n+\n+void ExpressionInfoMatcher::visit(const ASTIdentifier & identifier, const ASTPtr &, Data & data)\n+{\n+    if (!identifier.compound())\n+    {\n+        for (size_t index = 0; index < data.tables.size(); ++index)\n+        {\n+            const auto & columns = data.tables[index].columns;\n+\n+            // TODO: make sure no collision ever happens\n+            if (std::find(columns.begin(), columns.end(), identifier.name) != columns.end())\n+            {\n+                data.unique_reference_tables_pos.emplace(index);\n+                break;\n+            }\n+        }\n+    }\n+    else\n+    {\n+        size_t best_table_pos = 0;\n+        if (IdentifierSemantic::chooseTable(identifier, data.tables, best_table_pos))\n+            data.unique_reference_tables_pos.emplace(best_table_pos);\n+    }\n+}\n+\n+bool ExpressionInfoMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)\n+{\n+    return !node->as<ASTSubquery>();\n+}\n+\n+bool hasStatefulFunction(const ASTPtr & node, const Context & context)\n+{\n+    for (const auto & select_expression : node->children)\n+    {\n+        ExpressionInfoVisitor::Data expression_info{.context = context, .tables = {}};\n+        ExpressionInfoVisitor(expression_info).visit(select_expression);\n+\n+        if (expression_info.is_stateful_function)\n+            return true;\n+    }\n+\n+    return false;\n+}\n+\n+}\n+\ndiff --git a/dbms/src/Interpreters/ExtractExpressionInfoVisitor.h b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.h\nnew file mode 100644\nindex 000000000000..65d23057e526\n--- /dev/null\n+++ b/dbms/src/Interpreters/ExtractExpressionInfoVisitor.h\n@@ -0,0 +1,40 @@\n+#pragma once\n+\n+#include <Parsers/IAST_fwd.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include <Interpreters/DatabaseAndTableWithAlias.h>\n+\n+namespace DB\n+{\n+\n+class Context;\n+\n+struct ExpressionInfoMatcher\n+{\n+    struct Data\n+    {\n+        const Context & context;\n+        const std::vector<TableWithColumnNames> & tables;\n+\n+        bool is_array_join = false;\n+        bool is_stateful_function = false;\n+        bool is_aggregate_function = false;\n+        std::unordered_set<size_t> unique_reference_tables_pos = {};\n+    };\n+\n+    static void visit(const ASTPtr & ast, Data & data);\n+\n+    static bool needChildVisit(const ASTPtr & node, const ASTPtr &);\n+\n+    static void visit(const ASTFunction & ast_function, const ASTPtr &, Data & data);\n+\n+    static void visit(const ASTIdentifier & identifier, const ASTPtr &, Data & data);\n+};\n+\n+using ExpressionInfoVisitor = ConstInDepthNodeVisitor<ExpressionInfoMatcher, true>;\n+\n+bool hasStatefulFunction(const ASTPtr & node, const Context & context);\n+\n+}\ndiff --git a/dbms/src/Interpreters/ExtractFunctionDataVisitor.cpp b/dbms/src/Interpreters/ExtractFunctionDataVisitor.cpp\ndeleted file mode 100644\nindex d7a0d9001d53..000000000000\n--- a/dbms/src/Interpreters/ExtractFunctionDataVisitor.cpp\n+++ /dev/null\n@@ -1,16 +0,0 @@\n-#include <Interpreters/ExtractFunctionDataVisitor.h>\n-#include <AggregateFunctions/AggregateFunctionFactory.h>\n-\n-\n-namespace DB\n-{\n-\n-void ExtractFunctionData::visit(ASTFunction & function, ASTPtr &)\n-{\n-    if (AggregateFunctionFactory::instance().isAggregateFunctionName(function.name))\n-        aggregate_functions.emplace_back(&function);\n-    else\n-        functions.emplace_back(&function);\n-}\n-\n-}\ndiff --git a/dbms/src/Interpreters/ExtractFunctionDataVisitor.h b/dbms/src/Interpreters/ExtractFunctionDataVisitor.h\ndeleted file mode 100644\nindex ed3dbb868c4e..000000000000\n--- a/dbms/src/Interpreters/ExtractFunctionDataVisitor.h\n+++ /dev/null\n@@ -1,25 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/IAST.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ASTSelectWithUnionQuery.h>\n-#include <Interpreters/InDepthNodeVisitor.h>\n-\n-namespace DB\n-{\n-\n-struct ExtractFunctionData\n-{\n-    using TypeToVisit = ASTFunction;\n-\n-    std::vector<ASTFunction *> functions;\n-    std::vector<ASTFunction *> aggregate_functions;\n-\n-    void visit(ASTFunction & identifier, ASTPtr &);\n-};\n-\n-using ExtractFunctionMatcher = OneTypeMatcher<ExtractFunctionData>;\n-using ExtractFunctionVisitor = InDepthNodeVisitor<ExtractFunctionMatcher, true>;\n-\n-}\ndiff --git a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.cpp b/dbms/src/Interpreters/FindIdentifierBestTableVisitor.cpp\ndeleted file mode 100644\nindex 56897ec15c72..000000000000\n--- a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.cpp\n+++ /dev/null\n@@ -1,40 +0,0 @@\n-#include <Interpreters/FindIdentifierBestTableVisitor.h>\n-#include <Interpreters/IdentifierSemantic.h>\n-\n-\n-namespace DB\n-{\n-\n-FindIdentifierBestTableData::FindIdentifierBestTableData(const std::vector<TableWithColumnNames> & tables_)\n-    : tables(tables_)\n-{\n-}\n-\n-void FindIdentifierBestTableData::visit(ASTIdentifier & identifier, ASTPtr &)\n-{\n-    const DatabaseAndTableWithAlias * best_table = nullptr;\n-\n-    if (!identifier.compound())\n-    {\n-        for (const auto & table_names : tables)\n-        {\n-            auto & columns = table_names.columns;\n-            if (std::find(columns.begin(), columns.end(), identifier.name) != columns.end())\n-            {\n-                // TODO: make sure no collision ever happens\n-                if (!best_table)\n-                    best_table = &table_names.table;\n-            }\n-        }\n-    }\n-    else\n-    {\n-        size_t best_table_pos = 0;\n-        if (IdentifierSemantic::chooseTable(identifier, tables, best_table_pos))\n-            best_table = &tables[best_table_pos].table;\n-    }\n-\n-    identifier_table.emplace_back(&identifier, best_table);\n-}\n-\n-}\ndiff --git a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.h b/dbms/src/Interpreters/FindIdentifierBestTableVisitor.h\ndeleted file mode 100644\nindex 498ee60ab0bd..000000000000\n--- a/dbms/src/Interpreters/FindIdentifierBestTableVisitor.h\n+++ /dev/null\n@@ -1,27 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/IAST.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Interpreters/InDepthNodeVisitor.h>\n-#include <Interpreters/DatabaseAndTableWithAlias.h>\n-\n-namespace DB\n-{\n-\n-struct FindIdentifierBestTableData\n-{\n-    using TypeToVisit = ASTIdentifier;\n-    using IdentifierWithTable = std::pair<ASTIdentifier *, const DatabaseAndTableWithAlias *>;\n-\n-    const std::vector<TableWithColumnNames> & tables;\n-    std::vector<IdentifierWithTable> identifier_table;\n-\n-    FindIdentifierBestTableData(const std::vector<TableWithColumnNames> & tables_);\n-\n-    void visit(ASTIdentifier & identifier, ASTPtr &);\n-};\n-\n-using FindIdentifierBestTableMatcher = OneTypeMatcher<FindIdentifierBestTableData>;\n-using FindIdentifierBestTableVisitor = InDepthNodeVisitor<FindIdentifierBestTableMatcher, true>;\n-\n-}\ndiff --git a/dbms/src/Interpreters/InDepthNodeVisitor.h b/dbms/src/Interpreters/InDepthNodeVisitor.h\nindex 18b84b11b242..7bb4f5e4d549 100644\n--- a/dbms/src/Interpreters/InDepthNodeVisitor.h\n+++ b/dbms/src/Interpreters/InDepthNodeVisitor.h\n@@ -59,7 +59,13 @@ class OneTypeMatcher\n     using Data = Data_;\n     using TypeToVisit = typename Data::TypeToVisit;\n \n-    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return visit_children; }\n+    static bool needChildVisit(const ASTPtr & node, const ASTPtr &)\n+    {\n+        if (node && node->as<TypeToVisit>())\n+            return visit_children;\n+\n+        return true;\n+    }\n \n     static void visit(T & ast, Data & data)\n     {\ndiff --git a/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp b/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp\nindex 050ee637d185..9927091874c1 100644\n--- a/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp\n+++ b/dbms/src/Interpreters/PredicateExpressionsOptimizer.cpp\n@@ -1,32 +1,13 @@\n-#include <iostream>\n-\n-#include <Common/typeid_cast.h>\n-#include <Storages/IStorage.h>\n #include <Interpreters/PredicateExpressionsOptimizer.h>\n-#include <Interpreters/InterpreterSelectQuery.h>\n-#include <Interpreters/IdentifierSemantic.h>\n-#include <AggregateFunctions/AggregateFunctionFactory.h>\n+\n #include <Parsers/IAST.h>\n #include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ASTSelectWithUnionQuery.h>\n-#include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/ASTAsterisk.h>\n-#include <Parsers/ASTQualifiedAsterisk.h>\n-#include <Parsers/ASTColumnsMatcher.h>\n-#include <Parsers/queryToString.h>\n #include <Interpreters/Context.h>\n-#include <Interpreters/ExpressionActions.h>\n-#include <Interpreters/QueryNormalizer.h>\n-#include <Interpreters/QueryAliasesVisitor.h>\n-#include <Interpreters/MarkTableIdentifiersVisitor.h>\n-#include <Interpreters/TranslateQualifiedNamesVisitor.h>\n-#include <Interpreters/FindIdentifierBestTableVisitor.h>\n-#include <Interpreters/ExtractFunctionDataVisitor.h>\n #include <Interpreters/getTableExpressions.h>\n-#include <Functions/FunctionFactory.h>\n+#include <Interpreters/PredicateRewriteVisitor.h>\n+#include <Interpreters/ExtractExpressionInfoVisitor.h>\n \n \n namespace DB\n@@ -38,155 +19,105 @@ namespace ErrorCodes\n     extern const int UNKNOWN_ELEMENT_IN_AST;\n }\n \n-namespace\n-{\n-\n-constexpr auto and_function_name = \"and\";\n-\n-String qualifiedName(ASTIdentifier * identifier, const String & prefix)\n-{\n-    if (identifier->isShort())\n-        return prefix + identifier->getAliasOrColumnName();\n-    return identifier->getAliasOrColumnName();\n-}\n-\n-}\n-\n PredicateExpressionsOptimizer::PredicateExpressionsOptimizer(\n-    ASTSelectQuery * ast_select_, ExtractedSettings && settings_, const Context & context_)\n-    : ast_select(ast_select_), settings(settings_), context(context_)\n+    const Context & context_, const TablesWithColumnNames & tables_with_columns_, const Settings & settings_)\n+    : context(context_), tables_with_columns(tables_with_columns_), settings(settings_)\n {\n }\n \n-bool PredicateExpressionsOptimizer::optimize()\n+bool PredicateExpressionsOptimizer::optimize(ASTSelectQuery & select_query)\n {\n-    if (!settings.enable_optimize_predicate_expression || !ast_select || !ast_select->tables() || ast_select->tables()->children.empty())\n+    if (!settings.enable_optimize_predicate_expression)\n         return false;\n \n-    if (!ast_select->where() && !ast_select->prewhere())\n+    if (select_query.having() && (!select_query.group_by_with_cube && !select_query.group_by_with_rollup && !select_query.group_by_with_totals))\n+        tryMovePredicatesFromHavingToWhere(select_query);\n+\n+    if (!select_query.tables() || select_query.tables()->children.empty())\n         return false;\n \n-    if (ast_select->array_join_expression_list())\n+    if ((!select_query.where() && !select_query.prewhere()) || select_query.array_join_expression_list())\n         return false;\n \n-    SubqueriesProjectionColumns all_subquery_projection_columns = getAllSubqueryProjectionColumns();\n+    const auto & tables_predicates = extractTablesPredicates(select_query.where(), select_query.prewhere());\n \n-    bool is_rewrite_subqueries = false;\n-    if (!all_subquery_projection_columns.empty())\n-    {\n-        is_rewrite_subqueries |= optimizeImpl(ast_select->where(), all_subquery_projection_columns, OptimizeKind::PUSH_TO_WHERE);\n-        is_rewrite_subqueries |= optimizeImpl(ast_select->prewhere(), all_subquery_projection_columns, OptimizeKind::PUSH_TO_PREWHERE);\n-    }\n+    if (!tables_predicates.empty())\n+        return tryRewritePredicatesToTables(select_query.refTables()->children, tables_predicates);\n \n-    return is_rewrite_subqueries;\n+    return false;\n }\n \n-bool PredicateExpressionsOptimizer::optimizeImpl(\n-    const ASTPtr & outer_expression, const SubqueriesProjectionColumns & subqueries_projection_columns, OptimizeKind expression_kind)\n+static ASTs splitConjunctionPredicate(const std::initializer_list<const ASTPtr> & predicates)\n {\n-    /// split predicate with `and`\n-    std::vector<ASTPtr> outer_predicate_expressions = splitConjunctionPredicate(outer_expression);\n+    std::vector<ASTPtr> res;\n \n-    std::vector<const ASTTableExpression *> table_expressions = getTableExpressions(*ast_select);\n-    std::vector<TableWithColumnNames> tables_with_columns = getDatabaseAndTablesWithColumnNames(table_expressions, context);\n+    auto remove_expression_at_index = [&res] (const size_t index)\n+    {\n+        if (index < res.size() - 1)\n+            std::swap(res[index], res.back());\n+        res.pop_back();\n+    };\n \n-    bool is_rewrite_subquery = false;\n-    for (auto & outer_predicate : outer_predicate_expressions)\n+    for (const auto & predicate : predicates)\n     {\n-        if (isArrayJoinFunction(outer_predicate))\n+        if (!predicate)\n             continue;\n \n-        auto outer_predicate_dependencies = getDependenciesAndQualifiers(outer_predicate, tables_with_columns);\n+        res.emplace_back(predicate);\n \n-        /// TODO: remove origin expression\n-        for (const auto & [subquery, projection_columns] : subqueries_projection_columns)\n+        for (size_t idx = 0; idx < res.size();)\n         {\n-            OptimizeKind optimize_kind = OptimizeKind::NONE;\n-            if (allowPushDown(subquery, outer_predicate, projection_columns, outer_predicate_dependencies, optimize_kind))\n+            const auto & expression = res.at(idx);\n+\n+            if (const auto * function = expression->as<ASTFunction>(); function && function->name == \"and\")\n             {\n-                if (optimize_kind == OptimizeKind::NONE)\n-                    optimize_kind = expression_kind;\n-\n-                ASTPtr inner_predicate = outer_predicate->clone();\n-                cleanExpressionAlias(inner_predicate); /// clears the alias name contained in the outer predicate\n-\n-                std::vector<IdentifierWithQualifier> inner_predicate_dependencies =\n-                    getDependenciesAndQualifiers(inner_predicate, tables_with_columns);\n-\n-                setNewAliasesForInnerPredicate(projection_columns, inner_predicate_dependencies);\n-\n-                switch (optimize_kind)\n-                {\n-                    case OptimizeKind::NONE: continue;\n-                    case OptimizeKind::PUSH_TO_WHERE:\n-                        is_rewrite_subquery |= optimizeExpression(inner_predicate, subquery, ASTSelectQuery::Expression::WHERE);\n-                        continue;\n-                    case OptimizeKind::PUSH_TO_HAVING:\n-                        is_rewrite_subquery |= optimizeExpression(inner_predicate, subquery, ASTSelectQuery::Expression::HAVING);\n-                        continue;\n-                    case OptimizeKind::PUSH_TO_PREWHERE:\n-                        is_rewrite_subquery |= optimizeExpression(inner_predicate, subquery, ASTSelectQuery::Expression::PREWHERE);\n-                        continue;\n-                }\n+                for (auto & child : function->arguments->children)\n+                    res.emplace_back(child);\n+\n+                remove_expression_at_index(idx);\n+                continue;\n             }\n+            ++idx;\n         }\n     }\n-    return is_rewrite_subquery;\n+\n+    return res;\n }\n \n-bool PredicateExpressionsOptimizer::allowPushDown(\n-    const ASTSelectQuery * subquery,\n-    const ASTPtr &,\n-    const std::vector<ProjectionWithAlias> & projection_columns,\n-    const std::vector<IdentifierWithQualifier> & dependencies,\n-    OptimizeKind & optimize_kind)\n+std::vector<ASTs> PredicateExpressionsOptimizer::extractTablesPredicates(const ASTPtr & where, const ASTPtr & prewhere)\n {\n-    if (!subquery\n-        || (!settings.enable_optimize_predicate_expression_to_final_subquery && subquery->final())\n-        || subquery->limitBy() || subquery->limitLength()\n-        || subquery->with() || subquery->withFill())\n-        return false;\n-    else\n+    std::vector<ASTs> tables_predicates(tables_with_columns.size());\n+\n+    for (const auto & predicate_expression : splitConjunctionPredicate({where, prewhere}))\n     {\n-        ASTPtr expr_list = ast_select->select();\n-        ExtractFunctionVisitor::Data extract_data;\n-        ExtractFunctionVisitor(extract_data).visit(expr_list);\n+        ExpressionInfoVisitor::Data expression_info{.context = context, .tables = tables_with_columns};\n+        ExpressionInfoVisitor(expression_info).visit(predicate_expression);\n \n-        for (const auto & subquery_function : extract_data.functions)\n-        {\n-            const auto & function = FunctionFactory::instance().tryGet(subquery_function->name, context);\n+        if (expression_info.is_stateful_function)\n+            return {};   /// give up the optimization when the predicate contains stateful function\n \n-            /// Skip lambda, tuple and other special functions\n-            if (function && function->isStateful())\n-                return false;\n+        if (!expression_info.is_array_join)\n+        {\n+            if (expression_info.unique_reference_tables_pos.size() == 1)\n+                tables_predicates[*expression_info.unique_reference_tables_pos.begin()].emplace_back(predicate_expression);\n+            else if (expression_info.unique_reference_tables_pos.size() == 0)\n+            {\n+                for (size_t index = 0; index < tables_predicates.size(); ++index)\n+                    tables_predicates[index].emplace_back(predicate_expression);\n+            }\n         }\n     }\n \n-    const auto * ast_join = ast_select->join();\n-    const ASTTableExpression * left_table_expr = nullptr;\n-    const ASTTableExpression * right_table_expr = nullptr;\n-    const ASTSelectQuery * left_subquery = nullptr;\n-    const ASTSelectQuery * right_subquery = nullptr;\n+    return tables_predicates;    /// everything is OK, it can be optimized\n+}\n+\n+bool PredicateExpressionsOptimizer::tryRewritePredicatesToTables(ASTs & tables_element, const std::vector<ASTs> & tables_predicates)\n+{\n+    bool is_rewrite_tables = false;\n \n-    if (ast_join)\n+    for (size_t index = tables_element.size(); index > 0; --index)\n     {\n-        left_table_expr = ast_select\n-                                ->tables()->as<ASTTablesInSelectQuery>()\n-                                ->children[0]->as<ASTTablesInSelectQueryElement>()\n-                                ->table_expression->as<ASTTableExpression>();\n-        right_table_expr = ast_select\n-                                ->tables()->as<ASTTablesInSelectQuery>()\n-                                ->children[1]->as<ASTTablesInSelectQueryElement>()\n-                                ->table_expression->as<ASTTableExpression>();\n-\n-        if (left_table_expr && left_table_expr->subquery)\n-            left_subquery = left_table_expr->subquery\n-                                ->children[0]->as<ASTSelectWithUnionQuery>()\n-                                ->list_of_selects->children[0]->as<ASTSelectQuery>();\n-        if (right_table_expr && right_table_expr->subquery)\n-            right_subquery = right_table_expr->subquery\n-                                ->children[0]->as<ASTSelectWithUnionQuery>()\n-                                ->list_of_selects->children[0]->as<ASTSelectQuery>();\n+        size_t table_pos = index - 1;\n \n         /// NOTE: the syntactic way of pushdown has limitations and should be partially disabled in case of JOINs.\n         ///       Let's take a look at the query:\n@@ -201,326 +132,84 @@ bool PredicateExpressionsOptimizer::allowPushDown(\n         ///       It happens because the not-matching columns are replaced with a global default values on JOIN.\n         ///       Same is true for RIGHT JOIN and FULL JOIN.\n \n-        /// Check right side for LEFT'o'FULL JOIN\n-        if (isLeftOrFull(ast_join->table_join->as<ASTTableJoin>()->kind) && right_subquery == subquery)\n-            return false;\n-\n-        /// Check left side for RIGHT'o'FULL JOIN\n-        if (isRightOrFull(ast_join->table_join->as<ASTTableJoin>()->kind) && left_subquery == subquery)\n-            return false;\n-    }\n-\n-    return checkDependencies(projection_columns, dependencies, optimize_kind);\n-}\n-\n-bool PredicateExpressionsOptimizer::checkDependencies(\n-    const std::vector<ProjectionWithAlias> & projection_columns,\n-    const std::vector<IdentifierWithQualifier> & dependencies,\n-    OptimizeKind & optimize_kind)\n-{\n-    for (const auto & [identifier, prefix] : dependencies)\n-    {\n-        bool is_found = false;\n-        String qualified_name = qualifiedName(identifier, prefix);\n-\n-        for (const auto & [ast, alias] : projection_columns)\n+        if (const auto & table_element = tables_element[table_pos]->as<ASTTablesInSelectQueryElement>())\n         {\n-            if (alias == qualified_name)\n-            {\n-                is_found = true;\n-                ASTPtr projection_column = ast;\n-                ExtractFunctionVisitor::Data extract_data;\n-                ExtractFunctionVisitor(extract_data).visit(projection_column);\n-\n-                if (!extract_data.aggregate_functions.empty())\n-                    optimize_kind = OptimizeKind::PUSH_TO_HAVING;\n-            }\n-        }\n-\n-        if (!is_found)\n-            return false;\n-    }\n-\n-    return true;\n-}\n-\n-std::vector<ASTPtr> PredicateExpressionsOptimizer::splitConjunctionPredicate(const ASTPtr & predicate_expression)\n-{\n-    std::vector<ASTPtr> predicate_expressions;\n+            if (table_element->table_join && isLeft(table_element->table_join->as<ASTTableJoin>()->kind))\n+                continue;  /// Skip right table optimization\n \n-    if (predicate_expression)\n-    {\n-        predicate_expressions.emplace_back(predicate_expression);\n+            if (table_element->table_join && isFull(table_element->table_join->as<ASTTableJoin>()->kind))\n+                break;  /// Skip left and right table optimization\n \n-        auto remove_expression_at_index = [&predicate_expressions] (const size_t index)\n-        {\n-            if (index < predicate_expressions.size() - 1)\n-                std::swap(predicate_expressions[index], predicate_expressions.back());\n-            predicate_expressions.pop_back();\n-        };\n+            is_rewrite_tables |= tryRewritePredicatesToTable(tables_element[table_pos], tables_predicates[table_pos],\n+                tables_with_columns[table_pos].columns);\n \n-        for (size_t idx = 0; idx < predicate_expressions.size();)\n-        {\n-            const auto expression = predicate_expressions.at(idx);\n-\n-            if (const auto * function = expression->as<ASTFunction>())\n-            {\n-                if (function->name == and_function_name)\n-                {\n-                    for (auto & child : function->arguments->children)\n-                        predicate_expressions.emplace_back(child);\n-\n-                    remove_expression_at_index(idx);\n-                    continue;\n-                }\n-            }\n-            ++idx;\n+            if (table_element->table_join && isRight(table_element->table_join->as<ASTTableJoin>()->kind))\n+                break;  /// Skip left table optimization\n         }\n     }\n-    return predicate_expressions;\n-}\n \n-std::vector<PredicateExpressionsOptimizer::IdentifierWithQualifier>\n-PredicateExpressionsOptimizer::getDependenciesAndQualifiers(ASTPtr & expression, std::vector<TableWithColumnNames> & tables)\n-{\n-    FindIdentifierBestTableVisitor::Data find_data(tables);\n-    FindIdentifierBestTableVisitor(find_data).visit(expression);\n-\n-    std::vector<IdentifierWithQualifier> dependencies;\n-\n-    for (const auto & [identifier, table] : find_data.identifier_table)\n-    {\n-        String table_alias;\n-        if (table)\n-            table_alias = table->getQualifiedNamePrefix();\n-\n-        dependencies.emplace_back(identifier, table_alias);\n-    }\n-\n-    return dependencies;\n+    return is_rewrite_tables;\n }\n \n-void PredicateExpressionsOptimizer::setNewAliasesForInnerPredicate(\n-    const std::vector<ProjectionWithAlias> & projection_columns,\n-    const std::vector<IdentifierWithQualifier> & dependencies)\n+bool PredicateExpressionsOptimizer::tryRewritePredicatesToTable(ASTPtr & table_element, const ASTs & table_predicates, const Names & table_column) const\n {\n-    for (auto & [identifier, prefix] : dependencies)\n+    if (!table_predicates.empty())\n     {\n-        String qualified_name = qualifiedName(identifier, prefix);\n-\n-        for (auto & [ast, alias] : projection_columns)\n-        {\n-            if (alias == qualified_name)\n-            {\n-                String name;\n-                if (auto * id = ast->as<ASTIdentifier>())\n-                {\n-                    name = id->tryGetAlias();\n-                    if (name.empty())\n-                        name = id->shortName();\n-                }\n-                else\n-                {\n-                    if (ast->tryGetAlias().empty())\n-                        ast->setAlias(ast->getColumnName());\n-                    name = ast->getAliasOrColumnName();\n-                }\n-\n-                identifier->setShortName(name);\n-            }\n-        }\n-    }\n-}\n+        auto optimize_final = settings.enable_optimize_predicate_expression_to_final_subquery;\n+        PredicateRewriteVisitor::Data data(context, table_predicates, table_column, optimize_final);\n \n-bool PredicateExpressionsOptimizer::isArrayJoinFunction(const ASTPtr & node)\n-{\n-    if (const auto * function = node->as<ASTFunction>())\n-    {\n-        if (function->name == \"arrayJoin\")\n-            return true;\n+        PredicateRewriteVisitor(data).visit(table_element);\n+        return data.is_rewrite;\n     }\n \n-    for (auto & child : node->children)\n-        if (isArrayJoinFunction(child))\n-            return true;\n-\n     return false;\n }\n \n-bool PredicateExpressionsOptimizer::optimizeExpression(const ASTPtr & outer_expression, ASTSelectQuery * subquery,\n-                                                       ASTSelectQuery::Expression expr)\n-{\n-    ASTPtr subquery_expression = subquery->getExpression(expr, false);\n-    subquery_expression = subquery_expression ? makeASTFunction(and_function_name, outer_expression, subquery_expression) : outer_expression;\n-\n-    subquery->setExpression(expr, std::move(subquery_expression));\n-    return true;\n-}\n-\n-PredicateExpressionsOptimizer::SubqueriesProjectionColumns PredicateExpressionsOptimizer::getAllSubqueryProjectionColumns()\n-{\n-    SubqueriesProjectionColumns projection_columns;\n-\n-    for (const auto & table_expression : getTableExpressions(*ast_select))\n-        if (table_expression->subquery)\n-            getSubqueryProjectionColumns(table_expression->subquery, projection_columns);\n-\n-    return projection_columns;\n-}\n-\n-void PredicateExpressionsOptimizer::getSubqueryProjectionColumns(const ASTPtr & subquery, SubqueriesProjectionColumns & projection_columns)\n+bool PredicateExpressionsOptimizer::tryMovePredicatesFromHavingToWhere(ASTSelectQuery & select_query)\n {\n-    String qualified_name_prefix = subquery->tryGetAlias();\n-    if (!qualified_name_prefix.empty())\n-        qualified_name_prefix += '.';\n-\n-    const ASTPtr & subselect = subquery->children[0];\n-\n-    ASTs select_with_union_projections;\n-    const auto * select_with_union_query = subselect->as<ASTSelectWithUnionQuery>();\n+    ASTs where_predicates;\n+    ASTs having_predicates;\n \n-    for (auto & select : select_with_union_query->list_of_selects->children)\n+    const auto & reduce_predicates = [&](const ASTs & predicates)\n     {\n-        std::vector<ProjectionWithAlias> subquery_projections;\n-        auto select_projection_columns = getSelectQueryProjectionColumns(select);\n-\n-        if (!select_projection_columns.empty())\n-        {\n-            if (select_with_union_projections.empty())\n-                select_with_union_projections = select_projection_columns;\n+        ASTPtr res = predicates[0];\n+        for (size_t index = 1; index < predicates.size(); ++index)\n+            res = makeASTFunction(\"and\", res, predicates[index]);\n \n-            for (size_t i = 0; i < select_projection_columns.size(); i++)\n-                subquery_projections.emplace_back(std::pair(select_projection_columns[i],\n-                                                            qualified_name_prefix + select_with_union_projections[i]->getAliasOrColumnName()));\n-\n-            projection_columns.insert(std::pair(select->as<ASTSelectQuery>(), subquery_projections));\n-        }\n-    }\n-}\n+        return res;\n+    };\n \n-ASTs PredicateExpressionsOptimizer::getSelectQueryProjectionColumns(ASTPtr & ast)\n-{\n-    ASTs projection_columns;\n-    auto * select_query = ast->as<ASTSelectQuery>();\n-\n-    /// first should normalize query tree.\n-    std::unordered_map<String, ASTPtr> aliases;\n-    std::vector<DatabaseAndTableWithAlias> tables = getDatabaseAndTables(*select_query, context.getCurrentDatabase());\n-\n-    /// TODO: get tables from evaluateAsterisk instead of tablesOnly() to extract asterisks in general way\n-    std::vector<TableWithColumnNames> tables_with_columns = TranslateQualifiedNamesVisitor::Data::tablesOnly(tables);\n-    TranslateQualifiedNamesVisitor::Data qn_visitor_data({}, std::move(tables_with_columns), false);\n-    TranslateQualifiedNamesVisitor(qn_visitor_data).visit(ast);\n-\n-    QueryAliasesVisitor::Data query_aliases_data{aliases};\n-    QueryAliasesVisitor(query_aliases_data).visit(ast);\n-\n-    MarkTableIdentifiersVisitor::Data mark_tables_data{aliases};\n-    MarkTableIdentifiersVisitor(mark_tables_data).visit(ast);\n-\n-    QueryNormalizer::Data normalizer_data(aliases, settings);\n-    QueryNormalizer(normalizer_data).visit(ast);\n-\n-    for (const auto & projection_column : select_query->select()->children)\n+    for (const auto & moving_predicate: splitConjunctionPredicate({select_query.having()}))\n     {\n-        if (projection_column->as<ASTAsterisk>() || projection_column->as<ASTQualifiedAsterisk>() || projection_column->as<ASTColumnsMatcher>())\n-        {\n-            ASTs evaluated_columns = evaluateAsterisk(select_query, projection_column);\n+        ExpressionInfoVisitor::Data expression_info{.context = context, .tables = {}};\n+        ExpressionInfoVisitor(expression_info).visit(moving_predicate);\n \n-            for (const auto & column : evaluated_columns)\n-                projection_columns.emplace_back(column);\n-\n-            continue;\n-        }\n+        /// TODO: If there is no group by, where, and prewhere expression, we can push down the stateful function\n+        if (expression_info.is_stateful_function)\n+            return false;\n \n-        projection_columns.emplace_back(projection_column);\n+        if (expression_info.is_aggregate_function)\n+            having_predicates.emplace_back(moving_predicate);\n+        else\n+            where_predicates.emplace_back(moving_predicate);\n     }\n-    return projection_columns;\n-}\n-\n-ASTs PredicateExpressionsOptimizer::evaluateAsterisk(ASTSelectQuery * select_query, const ASTPtr & asterisk)\n-{\n-    /// SELECT *, SELECT dummy, SELECT 1 AS id\n-    if (!select_query->tables() || select_query->tables()->children.empty())\n-        return {};\n-\n-    std::vector<const ASTTableExpression *> tables_expression = getTableExpressions(*select_query);\n \n-    if (const auto * qualified_asterisk = asterisk->as<ASTQualifiedAsterisk>())\n+    if (having_predicates.empty())\n+        select_query.setExpression(ASTSelectQuery::Expression::HAVING, {});\n+    else\n     {\n-        if (qualified_asterisk->children.size() != 1)\n-            throw Exception(\"Logical error: qualified asterisk must have exactly one child\", ErrorCodes::LOGICAL_ERROR);\n-\n-        DatabaseAndTableWithAlias ident_db_and_name(qualified_asterisk->children[0]);\n-\n-        for (auto it = tables_expression.begin(); it != tables_expression.end();)\n-        {\n-            const ASTTableExpression * table_expression = *it;\n-            DatabaseAndTableWithAlias database_and_table_with_alias(*table_expression, context.getCurrentDatabase());\n-\n-            if (ident_db_and_name.satisfies(database_and_table_with_alias, true))\n-                ++it;\n-            else\n-                it = tables_expression.erase(it); /// It's not a required table\n-        }\n+        auto having_predicate = reduce_predicates(having_predicates);\n+        select_query.setExpression(ASTSelectQuery::Expression::HAVING, std::move(having_predicate));\n     }\n \n-    ASTs projection_columns;\n-    for (auto & table_expression : tables_expression)\n+    if (!where_predicates.empty())\n     {\n-        if (table_expression->subquery)\n-        {\n-            const auto * subquery = table_expression->subquery->as<ASTSubquery>();\n-            const auto * select_with_union_query = subquery->children[0]->as<ASTSelectWithUnionQuery>();\n-            const auto subquery_projections = getSelectQueryProjectionColumns(select_with_union_query->list_of_selects->children[0]);\n-            projection_columns.insert(projection_columns.end(), subquery_projections.begin(), subquery_projections.end());\n-        }\n-        else\n-        {\n-            StoragePtr storage;\n-\n-            if (table_expression->table_function)\n-            {\n-                auto query_context = const_cast<Context *>(&context.getQueryContext());\n-                storage = query_context->executeTableFunction(table_expression->table_function);\n-            }\n-            else if (table_expression->database_and_table_name)\n-            {\n-                const auto * database_and_table_ast = table_expression->database_and_table_name->as<ASTIdentifier>();\n-                DatabaseAndTableWithAlias database_and_table_name(*database_and_table_ast);\n-                storage = context.getTable(database_and_table_name.database, database_and_table_name.table);\n-            }\n-            else\n-                throw Exception(\"Logical error: unexpected table expression\", ErrorCodes::LOGICAL_ERROR);\n-\n-            const auto block = storage->getSampleBlock();\n-            if (const auto * asterisk_pattern = asterisk->as<ASTColumnsMatcher>())\n-            {\n-                for (size_t idx = 0; idx < block.columns(); ++idx)\n-                {\n-                    auto & col = block.getByPosition(idx);\n-                    if (asterisk_pattern->isColumnMatching(col.name))\n-                        projection_columns.emplace_back(std::make_shared<ASTIdentifier>(col.name));\n-                }\n-            }\n-            else\n-            {\n-                for (size_t idx = 0; idx < block.columns(); ++idx)\n-                    projection_columns.emplace_back(std::make_shared<ASTIdentifier>(block.getByPosition(idx).name));\n-            }\n-        }\n+        auto moved_predicate = reduce_predicates(where_predicates);\n+        moved_predicate = select_query.where() ? makeASTFunction(\"and\", select_query.where(), moved_predicate) : moved_predicate;\n+        select_query.setExpression(ASTSelectQuery::Expression::WHERE, std::move(moved_predicate));\n     }\n-    return projection_columns;\n-}\n-\n-void PredicateExpressionsOptimizer::cleanExpressionAlias(ASTPtr & expression)\n-{\n-    const auto my_alias = expression->tryGetAlias();\n-    if (!my_alias.empty())\n-        expression->setAlias(\"\");\n \n-    for (auto & child : expression->children)\n-        cleanExpressionAlias(child);\n+    return true;\n }\n \n }\ndiff --git a/dbms/src/Interpreters/PredicateExpressionsOptimizer.h b/dbms/src/Interpreters/PredicateExpressionsOptimizer.h\nindex ca2c8b8766d4..da6b98987a64 100644\n--- a/dbms/src/Interpreters/PredicateExpressionsOptimizer.h\n+++ b/dbms/src/Interpreters/PredicateExpressionsOptimizer.h\n@@ -1,110 +1,53 @@\n #pragma once\n \n-#include \"DatabaseAndTableWithAlias.h\"\n #include <Parsers/ASTSelectQuery.h>\n-#include <map>\n+#include <Interpreters/DatabaseAndTableWithAlias.h>\n \n namespace DB\n {\n \n-class ASTIdentifier;\n-class ASTSubquery;\n class Context;\n+struct Settings;\n \n-/** This class provides functions for Push-Down predicate expressions\n- *\n- *  The Example:\n- *      - Query before optimization :\n- *          SELECT id_1, name_1 FROM (SELECT id_1, name_1 FROM table_a UNION ALL SELECT id_2, name_2 FROM table_b)\n- *              WHERE id_1 = 1\n- *      - Query after optimization :\n- *          SELECT id_1, name_1 FROM (SELECT id_1, name_1 FROM table_a WHERE id_1 = 1 UNION ALL SELECT id_2, name_2 FROM table_b WHERE id_2 = 1)\n- *              WHERE id_1 = 1\n+/** Predicate optimization based on rewriting ast rules\n  *  For more details : https://github.com/ClickHouse/ClickHouse/pull/2015#issuecomment-374283452\n+ *  The optimizer does two different optimizations\n+ *      - Move predicates from having to where\n+ *      - Push the predicate down from the current query to the having of the subquery\n  */\n class PredicateExpressionsOptimizer\n {\n-    using ProjectionWithAlias = std::pair<ASTPtr, String>;\n-    using SubqueriesProjectionColumns = std::map<ASTSelectQuery *, std::vector<ProjectionWithAlias>>;\n-    using IdentifierWithQualifier = std::pair<ASTIdentifier *, String>;\n+public:\n+    PredicateExpressionsOptimizer(const Context & context_, const TablesWithColumnNames & tables_with_columns_, const Settings & settings_);\n+\n+    bool optimize(ASTSelectQuery & select_query);\n \n+private:\n     /// Extracts settings, mostly to show which are used and which are not.\n     struct ExtractedSettings\n     {\n-        /// QueryNormalizer settings\n-        const UInt64 max_ast_depth;\n-        const UInt64 max_expanded_ast_elements;\n-        const String count_distinct_implementation;\n-\n-        /// for PredicateExpressionsOptimizer\n         const bool enable_optimize_predicate_expression;\n         const bool enable_optimize_predicate_expression_to_final_subquery;\n-        const bool join_use_nulls;\n \n         template<typename T>\n         ExtractedSettings(const T & settings_)\n-        :   max_ast_depth(settings_.max_ast_depth),\n-            max_expanded_ast_elements(settings_.max_expanded_ast_elements),\n-            count_distinct_implementation(settings_.count_distinct_implementation),\n-            enable_optimize_predicate_expression(settings_.enable_optimize_predicate_expression),\n-            enable_optimize_predicate_expression_to_final_subquery(settings_.enable_optimize_predicate_expression_to_final_subquery),\n-            join_use_nulls(settings_.join_use_nulls)\n+            :   enable_optimize_predicate_expression(settings_.enable_optimize_predicate_expression),\n+                enable_optimize_predicate_expression_to_final_subquery(settings_.enable_optimize_predicate_expression_to_final_subquery)\n         {}\n     };\n \n-public:\n-    PredicateExpressionsOptimizer(ASTSelectQuery * ast_select_, ExtractedSettings && settings_, const Context & context_);\n-\n-    bool optimize();\n-\n-private:\n-    ASTSelectQuery * ast_select;\n-    const ExtractedSettings settings;\n     const Context & context;\n+    const std::vector<TableWithColumnNames> & tables_with_columns;\n \n-    enum OptimizeKind\n-    {\n-        NONE,\n-        PUSH_TO_PREWHERE,\n-        PUSH_TO_WHERE,\n-        PUSH_TO_HAVING,\n-    };\n-\n-    bool isArrayJoinFunction(const ASTPtr & node);\n-\n-    std::vector<ASTPtr> splitConjunctionPredicate(const ASTPtr & predicate_expression);\n-\n-    std::vector<IdentifierWithQualifier> getDependenciesAndQualifiers(ASTPtr & expression,\n-                                                                      std::vector<TableWithColumnNames> & tables_with_aliases);\n-\n-    bool optimizeExpression(const ASTPtr & outer_expression, ASTSelectQuery * subquery, ASTSelectQuery::Expression expr);\n-\n-    bool optimizeImpl(const ASTPtr & outer_expression, const SubqueriesProjectionColumns & subqueries_projection_columns, OptimizeKind optimize_kind);\n-\n-    bool allowPushDown(\n-        const ASTSelectQuery * subquery,\n-        const ASTPtr & outer_predicate,\n-        const std::vector<ProjectionWithAlias> & subquery_projection_columns,\n-        const std::vector<IdentifierWithQualifier> & outer_predicate_dependencies,\n-        OptimizeKind & optimize_kind);\n-\n-    bool checkDependencies(\n-        const std::vector<ProjectionWithAlias> & projection_columns,\n-        const std::vector<IdentifierWithQualifier> & dependencies,\n-        OptimizeKind & optimize_kind);\n-\n-    void setNewAliasesForInnerPredicate(const std::vector<ProjectionWithAlias> & projection_columns,\n-                                        const std::vector<IdentifierWithQualifier> & inner_predicate_dependencies);\n-\n-    SubqueriesProjectionColumns getAllSubqueryProjectionColumns();\n+    const ExtractedSettings settings;\n \n-    void getSubqueryProjectionColumns(const ASTPtr & subquery, SubqueriesProjectionColumns & all_subquery_projection_columns);\n+    std::vector<ASTs> extractTablesPredicates(const ASTPtr & where, const ASTPtr & prewhere);\n \n-    ASTs getSelectQueryProjectionColumns(ASTPtr & ast);\n+    bool tryRewritePredicatesToTables(ASTs & tables_element, const std::vector<ASTs> & tables_predicates);\n \n-    ASTs evaluateAsterisk(ASTSelectQuery * select_query, const ASTPtr & asterisk);\n+    bool tryRewritePredicatesToTable(ASTPtr & table_element, const ASTs & table_predicates, const Names & table_column) const;\n \n-    void cleanExpressionAlias(ASTPtr & expression);\n+    bool tryMovePredicatesFromHavingToWhere(ASTSelectQuery & select_query);\n };\n \n }\ndiff --git a/dbms/src/Interpreters/PredicateRewriteVisitor.cpp b/dbms/src/Interpreters/PredicateRewriteVisitor.cpp\nnew file mode 100644\nindex 000000000000..6bd16ddc0668\n--- /dev/null\n+++ b/dbms/src/Interpreters/PredicateRewriteVisitor.cpp\n@@ -0,0 +1,119 @@\n+#include <Interpreters/PredicateRewriteVisitor.h>\n+\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTAsterisk.h>\n+#include <Parsers/ASTSubquery.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTColumnsMatcher.h>\n+#include <Parsers/ASTQualifiedAsterisk.h>\n+#include <Interpreters/IdentifierSemantic.h>\n+#include <Interpreters/getTableExpressions.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/ExtractExpressionInfoVisitor.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+\n+\n+namespace DB\n+{\n+\n+PredicateRewriteVisitorData::PredicateRewriteVisitorData(\n+    const Context & context_, const ASTs & predicates_, const Names & column_names_, bool optimize_final_)\n+    : context(context_), predicates(predicates_), column_names(column_names_), optimize_final(optimize_final_)\n+{\n+}\n+\n+void PredicateRewriteVisitorData::visit(ASTSelectWithUnionQuery & union_select_query, ASTPtr &)\n+{\n+    auto & internal_select_list = union_select_query.list_of_selects->children;\n+\n+    if (internal_select_list.size() > 0)\n+        visitFirstInternalSelect(*internal_select_list[0]->as<ASTSelectQuery>(), internal_select_list[0]);\n+\n+    for (size_t index = 1; index < internal_select_list.size(); ++index)\n+        visitOtherInternalSelect(*internal_select_list[index]->as<ASTSelectQuery>(), internal_select_list[index]);\n+}\n+\n+void PredicateRewriteVisitorData::visitFirstInternalSelect(ASTSelectQuery & select_query, ASTPtr &)\n+{\n+    is_rewrite |= rewriteSubquery(select_query, column_names, column_names);\n+}\n+\n+void PredicateRewriteVisitorData::visitOtherInternalSelect(ASTSelectQuery & select_query, ASTPtr &)\n+{\n+    /// For non first select, its alias has no more significance, so we can set a temporary alias for them\n+    ASTPtr temp_internal_select = select_query.clone();\n+    ASTSelectQuery * temp_select_query = temp_internal_select->as<ASTSelectQuery>();\n+\n+    size_t alias_index = 0;\n+    for (auto & ref_select : temp_select_query->refSelect()->children)\n+    {\n+        if (!ref_select->as<ASTAsterisk>() && !ref_select->as<ASTQualifiedAsterisk>() && !ref_select->as<ASTColumnsMatcher>() &&\n+            !ref_select->as<ASTIdentifier>())\n+        {\n+            if (const auto & alias = ref_select->tryGetAlias(); alias.empty())\n+                ref_select->setAlias(\"--predicate_optimizer_\" + toString(alias_index++));\n+        }\n+    }\n+\n+    const Names & internal_columns = InterpreterSelectQuery(\n+        temp_internal_select, context, SelectQueryOptions().analyze()).getSampleBlock().getNames();\n+\n+    if (rewriteSubquery(*temp_select_query, column_names, internal_columns))\n+    {\n+        is_rewrite |= true;\n+        select_query.setExpression(ASTSelectQuery::Expression::SELECT, std::move(temp_select_query->refSelect()));\n+        select_query.setExpression(ASTSelectQuery::Expression::HAVING, std::move(temp_select_query->refHaving()));\n+    }\n+}\n+\n+static void cleanAliasAndCollectIdentifiers(ASTPtr & predicate, std::vector<ASTIdentifier *> & identifiers)\n+{\n+    /// Skip WHERE x in (SELECT ...)\n+    if (!predicate->as<ASTSubquery>())\n+    {\n+        for (auto & children : predicate->children)\n+            cleanAliasAndCollectIdentifiers(children, identifiers);\n+    }\n+\n+    if (const auto alias = predicate->tryGetAlias(); !alias.empty())\n+        predicate->setAlias(\"\");\n+\n+    if (ASTIdentifier * identifier = predicate->as<ASTIdentifier>())\n+        identifiers.emplace_back(identifier);\n+}\n+\n+bool PredicateRewriteVisitorData::rewriteSubquery(ASTSelectQuery & subquery, const Names & outer_columns, const Names & inner_columns)\n+{\n+    if ((!optimize_final && subquery.final())\n+        || subquery.with() || subquery.withFill()\n+        || subquery.limitBy() || subquery.limitLength()\n+        || hasStatefulFunction(subquery.select(), context))\n+        return false;\n+\n+    for (const auto & predicate : predicates)\n+    {\n+        std::vector<ASTIdentifier *> identifiers;\n+        ASTPtr optimize_predicate = predicate->clone();\n+        cleanAliasAndCollectIdentifiers(optimize_predicate, identifiers);\n+\n+        for (size_t index = 0; index < identifiers.size(); ++index)\n+        {\n+            const auto & column_name = identifiers[index]->shortName();\n+            const auto & outer_column_iterator = std::find(outer_columns.begin(), outer_columns.end(), column_name);\n+\n+            /// For lambda functions, we can't always find them in the list of columns\n+            /// For example: SELECT * FROM system.one WHERE arrayMap(x -> x, [dummy]) = [0]\n+            if (outer_column_iterator != outer_columns.end())\n+                identifiers[index]->setShortName(inner_columns[outer_column_iterator - outer_columns.begin()]);\n+        }\n+\n+        /// We only need to push all the predicates to subquery having\n+        /// The subquery optimizer will move the appropriate predicates from having to where\n+        subquery.setExpression(ASTSelectQuery::Expression::HAVING,\n+            subquery.having() ? makeASTFunction(\"and\", optimize_predicate, subquery.having()) : optimize_predicate);\n+    }\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/dbms/src/Interpreters/PredicateRewriteVisitor.h b/dbms/src/Interpreters/PredicateRewriteVisitor.h\nnew file mode 100644\nindex 000000000000..e07df922c155\n--- /dev/null\n+++ b/dbms/src/Interpreters/PredicateRewriteVisitor.h\n@@ -0,0 +1,36 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+\n+namespace DB\n+{\n+\n+class PredicateRewriteVisitorData\n+{\n+public:\n+    bool is_rewrite = false;\n+    using TypeToVisit = ASTSelectWithUnionQuery;\n+\n+    void visit(ASTSelectWithUnionQuery & union_select_query, ASTPtr &);\n+\n+    PredicateRewriteVisitorData(const Context & context_, const ASTs & predicates_, const Names & column_names_, bool optimize_final_);\n+\n+private:\n+    const Context & context;\n+    const ASTs & predicates;\n+    const Names & column_names;\n+    bool optimize_final;\n+\n+    void visitFirstInternalSelect(ASTSelectQuery & select_query, ASTPtr &);\n+\n+    void visitOtherInternalSelect(ASTSelectQuery & select_query, ASTPtr &);\n+\n+    bool rewriteSubquery(ASTSelectQuery & subquery, const Names & outer_columns, const Names & inner_columns);\n+};\n+\n+using PredicateRewriteMatcher = OneTypeMatcher<PredicateRewriteVisitorData, false>;\n+using PredicateRewriteVisitor = InDepthNodeVisitor<PredicateRewriteMatcher, true>;\n+}\ndiff --git a/dbms/src/Interpreters/SyntaxAnalyzer.cpp b/dbms/src/Interpreters/SyntaxAnalyzer.cpp\nindex 85135c71c6ff..3680947c8f1a 100644\n--- a/dbms/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/dbms/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -920,6 +920,9 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(\n \n     if (select_query)\n     {\n+        /// Push the predicate expression down to the subqueries.\n+        result.rewrite_subqueries = PredicateExpressionsOptimizer(context, tables_with_columns, settings).optimize(*select_query);\n+\n         /// GROUP BY injective function elimination.\n         optimizeGroupBy(select_query, source_columns_set, context);\n \n@@ -935,9 +938,6 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyze(\n         /// array_join_alias_to_name, array_join_result_to_source.\n         getArrayJoinedColumns(query, result, select_query, result.source_columns, source_columns_set);\n \n-        /// Push the predicate expression down to the subqueries.\n-        result.rewrite_subqueries = PredicateExpressionsOptimizer(select_query, settings, context).optimize();\n-\n         setJoinStrictness(*select_query, settings.join_default_strictness, settings.any_join_distinct_right_table_keys,\n                           result.analyzed_join->table_join);\n         collectJoinedColumns(*result.analyzed_join, *select_query, tables_with_columns, result.aliases);\ndiff --git a/dbms/src/Storages/StorageView.cpp b/dbms/src/Storages/StorageView.cpp\nindex 824856dfc4e3..5c8543bbb337 100644\n--- a/dbms/src/Storages/StorageView.cpp\n+++ b/dbms/src/Storages/StorageView.cpp\n@@ -1,6 +1,7 @@\n #include <Interpreters/InterpreterSelectQuery.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n #include <Interpreters/PredicateExpressionsOptimizer.h>\n+#include <Interpreters/getTableExpressions.h>\n \n #include <Parsers/ASTCreateQuery.h>\n #include <Parsers/ASTSubquery.h>\n@@ -23,6 +24,7 @@ namespace ErrorCodes\n {\n     extern const int INCORRECT_QUERY;\n     extern const int LOGICAL_ERROR;\n+    extern const int ALIAS_REQUIRED;\n }\n \n \n@@ -62,8 +64,23 @@ BlockInputStreams StorageView::read(\n \n         replaceTableNameWithSubquery(new_outer_select, new_inner_query);\n \n-        if (PredicateExpressionsOptimizer(new_outer_select, context.getSettings(), context).optimize())\n-            current_inner_query = new_inner_query;\n+        /// TODO: remove getTableExpressions and getTablesWithColumns\n+        {\n+            const auto & table_expressions = getTableExpressions(*new_outer_select);\n+            const auto & tables_with_columns = getDatabaseAndTablesWithColumnNames(table_expressions, context);\n+\n+            auto & settings = context.getSettingsRef();\n+            if (settings.joined_subquery_requires_alias && tables_with_columns.size() > 1)\n+            {\n+                for (auto & pr : tables_with_columns)\n+                    if (pr.table.table.empty() && pr.table.alias.empty())\n+                        throw Exception(\"Not unique subquery in FROM requires an alias (or joined_subquery_requires_alias=0 to disable restriction).\",\n+                            ErrorCodes::ALIAS_REQUIRED);\n+            }\n+\n+            if (PredicateExpressionsOptimizer(context, tables_with_columns, context.getSettings()).optimize(*new_outer_select))\n+                current_inner_query = new_inner_query;\n+        }\n     }\n \n     QueryPipeline pipeline;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00597_push_down_predicate.reference b/dbms/tests/queries/0_stateless/00597_push_down_predicate.reference\nindex f64243e9be77..9fde80689f13 100644\n--- a/dbms/tests/queries/0_stateless/00597_push_down_predicate.reference\n+++ b/dbms/tests/queries/0_stateless/00597_push_down_predicate.reference\n@@ -13,7 +13,7 @@ SELECT \\n    a, \\n    b\\nFROM \\n(\\n    SELECT \\n        1 AS a, \\n        1 AS b\n -------Need push down-------\n SELECT toString(value) AS value\\nFROM \\n(\\n    SELECT 1 AS value\\n)\n 1\n-SELECT id\\nFROM \\n(\\n    SELECT 1 AS id\\n    UNION ALL\\n    SELECT 2 AS `2`\\n    WHERE 0\\n)\\nWHERE id = 1\n+SELECT id\\nFROM \\n(\\n    SELECT 1 AS id\\n    UNION ALL\\n    SELECT 2 AS `--predicate_optimizer_0`\\n    WHERE 0\\n)\\nWHERE id = 1\n 1\n SELECT id\\nFROM \\n(\\n    SELECT arrayJoin([1, 2, 3]) AS id\\n    WHERE id = 1\\n)\\nWHERE id = 1\n 1\ndiff --git a/dbms/tests/queries/0_stateless/01056_predicate_optimizer_bugs.reference b/dbms/tests/queries/0_stateless/01056_predicate_optimizer_bugs.reference\nnew file mode 100644\nindex 000000000000..019e95cb359b\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01056_predicate_optimizer_bugs.reference\n@@ -0,0 +1,28 @@\n+SELECT \\n    k, \\n    v, \\n    d, \\n    i\\nFROM \\n(\\n    SELECT \\n        t.1 AS k, \\n        t.2 AS v, \\n        runningDifference(v) AS d, \\n        runningDifference(cityHash64(t.1)) AS i\\n    FROM \\n    (\\n        SELECT arrayJoin([(\\'a\\', 1), (\\'a\\', 2), (\\'a\\', 3), (\\'b\\', 11), (\\'b\\', 13), (\\'b\\', 15)]) AS t\\n    )\\n)\\nWHERE i = 0\n+a\t1\t0\t0\n+a\t2\t1\t0\n+a\t3\t1\t0\n+b\t13\t2\t0\n+b\t15\t2\t0\n+SELECT \\n    co, \\n    co2, \\n    co3, \\n    num\\nFROM \\n(\\n    SELECT \\n        co, \\n        co2, \\n        co3, \\n        count() AS num\\n    FROM \\n    (\\n        SELECT \\n            1 AS co, \\n            2 AS co2, \\n            3 AS co3\\n    )\\n    GROUP BY \\n        co, \\n        co2, \\n        co3\\n        WITH CUBE\\n    HAVING (co != 0) AND (co2 != 2)\\n)\\nWHERE (co != 0) AND (co2 != 2)\n+1\t0\t3\t1\n+1\t0\t0\t1\n+SELECT alias AS name\\nFROM \\n(\\n    SELECT name AS alias\\n    FROM system.settings\\n    WHERE alias = \\'enable_optimize_predicate_expression\\'\\n)\\nANY INNER JOIN \\n(\\n    SELECT name\\n    FROM system.settings\\n) USING (name)\\nWHERE name = \\'enable_optimize_predicate_expression\\'\n+enable_optimize_predicate_expression\n+1\tval11\tval21\tval31\n+SELECT ccc\\nFROM \\n(\\n    SELECT 1 AS ccc\\n    WHERE 0\\n    UNION ALL\\n    SELECT ccc\\n    FROM \\n    (\\n        SELECT 2 AS ccc\\n    )\\n    ANY INNER JOIN \\n    (\\n        SELECT 2 AS ccc\\n    ) USING (ccc)\\n    WHERE ccc > 1\\n)\\nWHERE ccc > 1\n+2\n+SELECT \\n    ts, \\n    id, \\n    id_b, \\n    b.ts, \\n    b.id, \\n    id_c\\nFROM \\n(\\n    SELECT \\n        ts, \\n        id, \\n        id_b\\n    FROM A\\n    WHERE ts <= toDateTime(\\'1970-01-01 03:00:00\\')\\n) AS a\\nALL LEFT JOIN B AS b ON b.id = id_b\\nWHERE ts <= toDateTime(\\'1970-01-01 03:00:00\\')\n+SELECT \\n    ts AS `--a.ts`, \\n    id AS `--a.id`, \\n    id_b AS `--a.id_b`, \\n    b.ts AS `--b.ts`, \\n    b.id AS `--b.id`, \\n    id_c AS `--b.id_c`\\nFROM \\n(\\n    SELECT \\n        ts, \\n        id, \\n        id_b\\n    FROM A\\n    WHERE ts <= toDateTime(\\'1970-01-01 03:00:00\\')\\n) AS a\\nALL LEFT JOIN B AS b ON `--b.id` = `--a.id_b`\\nWHERE `--a.ts` <= toDateTime(\\'1970-01-01 03:00:00\\')\n+2\t3\n+3\t4\n+4\t5\n+5\t0\n+2\t4\n+4\t0\n+2\t3\n+4\t5\n+SELECT dummy\\nFROM \\n(\\n    SELECT dummy\\n    FROM system.one\\n    WHERE arrayMap(x -> (x + 1), [dummy]) = [1]\\n)\\nWHERE arrayMap(x -> (x + 1), [dummy]) = [1]\n+0\n+SELECT \\n    id, \\n    value, \\n    value_1\\nFROM \\n(\\n    SELECT \\n        1 AS id, \\n        2 AS value\\n)\\nALL INNER JOIN \\n(\\n    SELECT \\n        1 AS id, \\n        3 AS value_1\\n) USING (id)\\nWHERE arrayMap(x -> ((x + value) + value_1), [1]) = [6]\n+1\t2\t3\ndiff --git a/dbms/tests/queries/0_stateless/01056_predicate_optimizer_bugs.sql b/dbms/tests/queries/0_stateless/01056_predicate_optimizer_bugs.sql\nnew file mode 100644\nindex 000000000000..e1e185be0769\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01056_predicate_optimizer_bugs.sql\n@@ -0,0 +1,75 @@\n+SET enable_debug_queries = 1;\n+SET enable_optimize_predicate_expression = 1;\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/3885\n+-- https://github.com/ClickHouse/ClickHouse/issues/5485\n+ANALYZE SELECT k, v, d, i FROM (SELECT t.1 AS k, t.2 AS v, runningDifference(v) AS d, runningDifference(cityHash64(t.1)) AS i FROM (   SELECT arrayJoin([('a', 1), ('a', 2), ('a', 3), ('b', 11), ('b', 13), ('b', 15)]) AS t)) WHERE i = 0;\n+SELECT k, v, d, i FROM (SELECT t.1 AS k, t.2 AS v, runningDifference(v) AS d, runningDifference(cityHash64(t.1)) AS i FROM (   SELECT arrayJoin([('a', 1), ('a', 2), ('a', 3), ('b', 11), ('b', 13), ('b', 15)]) AS t)) WHERE i = 0;\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/5682\n+ANALYZE SELECT co,co2,co3,num FROM ( SELECT co,co2,co3,count() AS num FROM ( SELECT 1 AS co,2 AS co2 ,3 AS co3 ) GROUP BY cube (co,co2,co3) ) WHERE co!=0 AND co2 !=2;\n+SELECT co,co2,co3,num FROM ( SELECT co,co2,co3,count() AS num FROM ( SELECT 1 AS co,2 AS co2 ,3 AS co3 ) GROUP BY cube (co,co2,co3) ) WHERE co!=0 AND co2 !=2;\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/6734\n+ANALYZE SELECT alias AS name FROM ( SELECT name AS alias FROM system.settings ) ANY INNER JOIN ( SELECT name FROM system.settings ) USING (name) WHERE name = 'enable_optimize_predicate_expression';\n+SELECT alias AS name FROM ( SELECT name AS alias FROM system.settings ) ANY INNER JOIN ( SELECT name FROM system.settings ) USING (name) WHERE name = 'enable_optimize_predicate_expression';\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/6767\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+DROP TABLE IF EXISTS t3;\n+DROP TABLE IF EXISTS view1;\n+\n+CREATE TABLE t1 (id UInt32, value1 String ) ENGINE ReplacingMergeTree() ORDER BY id;\n+CREATE TABLE t2 (id UInt32, value2 String ) ENGINE ReplacingMergeTree() ORDER BY id;\n+CREATE TABLE t3 (id UInt32, value3 String ) ENGINE ReplacingMergeTree() ORDER BY id;\n+\n+INSERT INTO t1 (id, value1) VALUES (1, 'val11');\n+INSERT INTO t2 (id, value2) VALUES (1, 'val21');\n+INSERT INTO t3 (id, value3) VALUES (1, 'val31');\n+\n+CREATE VIEW IF NOT EXISTS view1 AS SELECT t1.id AS id, t1.value1 AS value1, t2.value2 AS value2, t3.value3 AS value3 FROM t1 LEFT JOIN t2 ON t1.id = t2.id LEFT JOIN t3 ON t1.id = t3.id WHERE t1.id > 0;\n+SELECT * FROM view1 WHERE id = 1;\n+\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+DROP TABLE IF EXISTS t3;\n+DROP TABLE IF EXISTS view1;\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/7136\n+ANALYZE SELECT ccc FROM ( SELECT 1 AS ccc UNION ALL SELECT * FROM ( SELECT 2 AS ccc ) ANY INNER JOIN ( SELECT 2 AS ccc ) USING (ccc) ) WHERE ccc > 1;\n+SELECT ccc FROM ( SELECT 1 AS ccc UNION ALL SELECT * FROM ( SELECT 2 AS ccc ) ANY INNER JOIN ( SELECT 2 AS ccc ) USING (ccc) ) WHERE ccc > 1;\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/5674\n+-- https://github.com/ClickHouse/ClickHouse/issues/4731\n+-- https://github.com/ClickHouse/ClickHouse/issues/4904\n+DROP TABLE IF EXISTS A;\n+DROP TABLE IF EXISTS B;\n+\n+CREATE TABLE A (ts DateTime, id String, id_b String) ENGINE = MergeTree PARTITION BY toStartOfHour(ts) ORDER BY (ts,id);\n+CREATE TABLE B (ts DateTime, id String, id_c String) ENGINE = MergeTree PARTITION BY toStartOfHour(ts) ORDER BY (ts,id);\n+\n+ANALYZE SELECT ts, id, id_b, b.ts, b.id, id_c FROM (SELECT ts, id, id_b FROM A) AS a ALL LEFT JOIN B AS b ON b.id = a.id_b WHERE a.ts <= toDateTime('1970-01-01 03:00:00');\n+ANALYZE SELECT ts AS `--a.ts`, id AS `--a.id`, id_b AS `--a.id_b`, b.ts AS `--b.ts`, b.id AS `--b.id`, id_c AS `--b.id_c` FROM (SELECT ts, id, id_b FROM A) AS a ALL LEFT JOIN B AS b ON `--b.id` = `--a.id_b` WHERE `--a.ts` <= toDateTime('1970-01-01 03:00:00');\n+\n+DROP TABLE IF EXISTS A;\n+DROP TABLE IF EXISTS B;\n+\n+-- https://github.com/ClickHouse/ClickHouse/issues/7802\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test ( A Int32, B Int32 ) ENGINE = Memory();\n+\n+INSERT INTO test VALUES(1, 2)(0, 3)(1, 4)(0, 5);\n+\n+SELECT B, neighbor(B, 1) AS next_B FROM (SELECT * FROM test ORDER BY B);\n+SELECT B, neighbor(B, 1) AS next_B FROM (SELECT * FROM test ORDER BY B) WHERE A == 1;\n+SELECT B, next_B FROM (SELECT A, B, neighbor(B, 1) AS next_B FROM (SELECT * FROM test ORDER BY B)) WHERE A == 1;\n+\n+DROP TABLE IF EXISTS test;\n+\n+ANALYZE SELECT * FROM (SELECT * FROM system.one) WHERE arrayMap(x -> x + 1, [dummy]) = [1];\n+SELECT * FROM (SELECT * FROM system.one) WHERE arrayMap(x -> x + 1, [dummy]) = [1];\n+\n+ANALYZE SELECT *  FROM (SELECT 1 AS id, 2 AS value) INNER JOIN (SELECT 1 AS id, 3 AS value_1) USING id WHERE arrayMap(x -> x + value + value_1, [1]) = [6];\n+SELECT *  FROM (SELECT 1 AS id, 2 AS value) INNER JOIN (SELECT 1 AS id, 3 AS value_1) USING id WHERE arrayMap(x -> x + value + value_1, [1]) = [6];\n",
  "problem_statement": "runningDifference WRONG RESULT with enable_optimize_predicate_expression\nConnected to ClickHouse server version 18.16.0 revision 54412.\r\n\r\nset enable_optimize_predicate_expression = 1\r\n\r\n```\r\nselect n, z, changed from (\r\n   select n, z, runningDifferenceStartingWithFirstValue(n) as changed from (\r\n       select ts, n,z from system.one array join [1,3,4,5,6] as ts, \r\n          [1,2,2,2,1] as n, ['a', 'a', 'b', 'a', 'b'] as z \r\n    order by n, ts DESC)\r\n) where changed = 0\r\n\r\n\u250c\u2500n\u2500\u252c\u2500z\u2500\u252c\u2500changed\u2500\u2510\r\n\u2502 2 \u2502 b \u2502       0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\nset enable_optimize_predicate_expression = 0\r\nThe same query\r\n\r\n```\r\n\u250c\u2500n\u2500\u252c\u2500z\u2500\u252c\u2500changed\u2500\u2510\r\n\u2502 1 \u2502 a \u2502       0 \u2502\r\n\u2502 2 \u2502 b \u2502       0 \u2502\r\n\u2502 2 \u2502 a \u2502       0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n",
  "hints_text": "@zhang2014\n@den-crane Because the calculation of the function depends on the order of the data. \r\n\r\n @alexey-milovidov  Maybe we don't push down in this case? or , do you have any good suggestions ? : )\n> Maybe we don't push down in this case? or , do you have any good suggestions ? : \r\n\r\nOf course you should not. The same as with order by limit ... and so on.\nUnfortunately this fix in 19.3.3 has broken some key features we've been using where we calculate deltas on 30-40 million series of realtime data (billions of rows per day). We had some very complex logic we were able to encapsulate in views with predicate push down. In our case we are not dependent on the result of the stateful function in a where clause so don't get an incorrect result as per den-crane's original report. I've tried using plain arrayMap calculations with enable_optimize_predicate_expression.. and this doesn't work either - \"DB::Exception: Unknown function lambda.\"\r\n\r\nExample query:\r\n\r\n```\r\nSET enable_optimize_predicate_expression = 1\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nWITH arrayJoin(arrayMap(x -> x, arraySort(groupArray((ts, n))))) AS k\r\nSELECT \r\n    z, \r\n    k\r\nFROM \r\n(\r\n    SELECT \r\n        ts, \r\n        n, \r\n        z\r\n    FROM system.one \r\n    ARRAY JOIN \r\n        [1, 3, 4, 5, 6] AS ts, \r\n        [1, 2, 2, 2, 1] AS n, \r\n        ['a', 'a', 'b', 'a', 'b'] AS z\r\n    ORDER BY \r\n        n ASC, \r\n        ts DESC\r\n) \r\nWHERE z = 'a'\r\nGROUP BY z\r\n\r\nReceived exception from server (version 19.3.3):\r\nCode: 46. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: Unknown function lambda. \r\n\r\n0 rows in set. Elapsed: 0.003 sec.\r\n```\r\n\r\nI should add that using higher order functions for complex cases is perfect for us (nested joins or subqueries with lagging series are not always appropriate).\nI actually think this may be justification for parameterized views instead. That would be a very powerful feature.\nhttps://github.com/yandex/ClickHouse/issues/4389\n@abyss7 \r\n\r\nclickhouse-client --enable_optimize_predicate_expression=1\r\n\r\n```\r\nselect count() \r\nfrom (\r\n  select a, runningDifference(a) rd\r\n  from \r\n  (   select * \r\n    from (\r\n      select 1 a\r\n      union all \r\n      select 2 a\r\n    )\r\n    order by a desc\r\n  )\r\n  Where rd=-1\r\n)\r\n\r\n0 rows in set.\r\n```\r\n\r\nclickhouse-client --enable_optimize_predicate_expression=0\r\n```\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set.\r\n```\r\n\r\n19.8.1.562\n```\r\nSELECT k, v, d, i FROM\r\n(    SELECT t.1 AS k, t.2 AS v,\r\n        runningDifference(v) AS d,\r\n        runningDifference(xxHash32(t.1)) AS i\r\n    FROM\r\n    (   SELECT arrayJoin([('a', 1), ('a', 2), ('a', 3), ('b', 11), ('b', 13), ('b', 15)]) AS t))\r\nWHERE i = 0\r\n\r\nWRONG RESULT \r\nenable_optimize_predicate_expression=1\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500\u2500d\u2500\u252c\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502  0 \u2502 0 \u2502\r\n\u2502 a \u2502  2 \u2502  1 \u2502 0 \u2502\r\n\u2502 a \u2502  3 \u2502  1 \u2502 0 \u2502\r\n\u2502 b \u2502 13 \u2502 10 \u2502 0 \u2502\r\n\u2502 b \u2502 15 \u2502  2 \u2502 0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n\r\nRight Result\r\nenable_optimize_predicate_expression=0\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500d\u2500\u252c\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502 0 \u2502 0 \u2502\r\n\u2502 a \u2502  2 \u2502 1 \u2502 0 \u2502\r\n\u2502 a \u2502  3 \u2502 1 \u2502 0 \u2502\r\n\u2502 b \u2502 13 \u2502 2 \u2502 0 \u2502\r\n\u2502 b \u2502 15 \u2502 2 \u2502 0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n19.10.1.669\n.",
  "created_at": "2020-01-02T13:21:13Z"
}