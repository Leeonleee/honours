{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11301,
  "instance_id": "ClickHouse__ClickHouse-11301",
  "issue_numbers": [
    "7896"
  ],
  "base_commit": "94887f0c7436718ba96b8dcc315106f4044b4226",
  "patch": "diff --git a/src/Columns/ColumnDecimal.cpp b/src/Columns/ColumnDecimal.cpp\nindex 3e6fb833b56b..1c238cc64581 100644\n--- a/src/Columns/ColumnDecimal.cpp\n+++ b/src/Columns/ColumnDecimal.cpp\n@@ -333,6 +333,17 @@ void ColumnDecimal<T>::getExtremes(Field & min, Field & max) const\n     max = NearestFieldType<T>(cur_max, scale);\n }\n \n+TypeIndex columnDecimalDataType(const IColumn * column)\n+{\n+    if (checkColumn<ColumnDecimal<Decimal32>>(column))\n+        return TypeIndex::Decimal32;\n+    else if (checkColumn<ColumnDecimal<Decimal64>>(column))\n+        return TypeIndex::Decimal64;\n+    else if (checkColumn<ColumnDecimal<Decimal128>>(column))\n+        return TypeIndex::Decimal128;\n+    return TypeIndex::Nothing;\n+}\n+\n template class ColumnDecimal<Decimal32>;\n template class ColumnDecimal<Decimal64>;\n template class ColumnDecimal<Decimal128>;\ndiff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h\nindex 86357dc8be7c..16c6a47c30af 100644\n--- a/src/Columns/ColumnDecimal.h\n+++ b/src/Columns/ColumnDecimal.h\n@@ -197,4 +197,6 @@ ColumnPtr ColumnDecimal<T>::indexImpl(const PaddedPODArray<Type> & indexes, size\n     return res;\n }\n \n+TypeIndex columnDecimalDataType(const IColumn * column);\n+\n }\ndiff --git a/src/Columns/ColumnVector.cpp b/src/Columns/ColumnVector.cpp\nindex c4f2c6d87050..95efd0dedad3 100644\n--- a/src/Columns/ColumnVector.cpp\n+++ b/src/Columns/ColumnVector.cpp\n@@ -517,6 +517,33 @@ void ColumnVector<T>::getExtremes(Field & min, Field & max) const\n     max = NearestFieldType<T>(cur_max);\n }\n \n+TypeIndex columnVectorDataType(const IColumn * column)\n+{\n+    if (checkColumn<ColumnVector<UInt8>>(column))\n+        return TypeIndex::UInt8;\n+    else if (checkColumn<ColumnVector<UInt16>>(column))\n+        return TypeIndex::UInt16;\n+    else if (checkColumn<ColumnVector<UInt32>>(column))\n+        return TypeIndex::UInt32;\n+    else if (checkColumn<ColumnVector<UInt64>>(column))\n+        return TypeIndex::UInt64;\n+    else if (checkColumn<ColumnVector<Int8>>(column))\n+        return TypeIndex::Int8;\n+    else if (checkColumn<ColumnVector<Int16>>(column))\n+        return TypeIndex::Int16;\n+    else if (checkColumn<ColumnVector<Int32>>(column))\n+        return TypeIndex::Int32;\n+    else if (checkColumn<ColumnVector<Int64>>(column))\n+        return TypeIndex::Int64;\n+    else if (checkColumn<ColumnVector<Int128>>(column))\n+        return TypeIndex::Int128;\n+    else if (checkColumn<ColumnVector<Float32>>(column))\n+        return TypeIndex::Float32;\n+    else if (checkColumn<ColumnVector<Float64>>(column))\n+        return TypeIndex::Float64;\n+    return TypeIndex::Nothing;\n+}\n+\n /// Explicit template instantiations - to avoid code bloat in headers.\n template class ColumnVector<UInt8>;\n template class ColumnVector<UInt16>;\ndiff --git a/src/Columns/ColumnVector.h b/src/Columns/ColumnVector.h\nindex a6105034f1a4..5e934b42df02 100644\n--- a/src/Columns/ColumnVector.h\n+++ b/src/Columns/ColumnVector.h\n@@ -320,4 +320,6 @@ ColumnPtr ColumnVector<T>::indexImpl(const PaddedPODArray<Type> & indexes, size_\n     return res;\n }\n \n+TypeIndex columnVectorDataType(const IColumn * column);\n+\n }\ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex 9d4e0907f660..7c06ec13f02e 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -192,7 +192,7 @@ class HashJoin : public IJoin\n \n     ASTTableJoin::Kind getKind() const { return kind; }\n     ASTTableJoin::Strictness getStrictness() const { return strictness; }\n-    AsofRowRefs::Type getAsofType() const { return *asof_type; }\n+    TypeIndex getAsofType() const { return *asof_type; }\n     ASOF::Inequality getAsofInequality() const { return asof_inequality; }\n     bool anyTakeLastRow() const { return any_take_last_row; }\n \n@@ -344,7 +344,7 @@ class HashJoin : public IJoin\n     bool nullable_right_side; /// In case of LEFT and FULL joins, if use_nulls, convert right-side columns to Nullable.\n     bool nullable_left_side; /// In case of RIGHT and FULL joins, if use_nulls, convert left-side columns to Nullable.\n     bool any_take_last_row; /// Overwrite existing values when encountering the same key again\n-    std::optional<AsofRowRefs::Type> asof_type;\n+    std::optional<TypeIndex> asof_type;\n     ASOF::Inequality asof_inequality;\n \n     /// Right table data. StorageJoin shares it between many Join objects.\ndiff --git a/src/Interpreters/RowRefs.cpp b/src/Interpreters/RowRefs.cpp\nindex 5d1f1217241e..e10f8bb2ea74 100644\n--- a/src/Interpreters/RowRefs.cpp\n+++ b/src/Interpreters/RowRefs.cpp\n@@ -17,19 +17,25 @@ namespace\n \n /// maps enum values to types\n template <typename F>\n-void callWithType(AsofRowRefs::Type which, F && f)\n+void callWithType(TypeIndex which, F && f)\n {\n     switch (which)\n     {\n-        case AsofRowRefs::Type::keyu32:  return f(UInt32());\n-        case AsofRowRefs::Type::keyu64:  return f(UInt64());\n-        case AsofRowRefs::Type::keyi32:  return f(Int32());\n-        case AsofRowRefs::Type::keyi64:  return f(Int64());\n-        case AsofRowRefs::Type::keyf32: return f(Float32());\n-        case AsofRowRefs::Type::keyf64: return f(Float64());\n-        case AsofRowRefs::Type::keyDecimal32: return f(Decimal32());\n-        case AsofRowRefs::Type::keyDecimal64: return f(Decimal64());\n-        case AsofRowRefs::Type::keyDecimal128: return f(Decimal128());\n+        case TypeIndex::UInt8:  return f(UInt8());\n+        case TypeIndex::UInt16: return f(UInt16());\n+        case TypeIndex::UInt32: return f(UInt32());\n+        case TypeIndex::UInt64: return f(UInt64());\n+        case TypeIndex::Int8:   return f(Int8());\n+        case TypeIndex::Int16:  return f(Int16());\n+        case TypeIndex::Int32:  return f(Int32());\n+        case TypeIndex::Int64:  return f(Int64());\n+        case TypeIndex::Float32: return f(Float32());\n+        case TypeIndex::Float64: return f(Float64());\n+        case TypeIndex::Decimal32: return f(Decimal32());\n+        case TypeIndex::Decimal64: return f(Decimal64());\n+        case TypeIndex::Decimal128: return f(Decimal128());\n+        default:\n+            break;\n     }\n \n     __builtin_unreachable();\n@@ -38,7 +44,7 @@ void callWithType(AsofRowRefs::Type which, F && f)\n }\n \n \n-AsofRowRefs::AsofRowRefs(Type type)\n+AsofRowRefs::AsofRowRefs(TypeIndex type)\n {\n     auto call = [&](const auto & t)\n     {\n@@ -50,7 +56,7 @@ AsofRowRefs::AsofRowRefs(Type type)\n     callWithType(type, call);\n }\n \n-void AsofRowRefs::insert(Type type, const IColumn * asof_column, const Block * block, size_t row_num)\n+void AsofRowRefs::insert(TypeIndex type, const IColumn * asof_column, const Block * block, size_t row_num)\n {\n     auto call = [&](const auto & t)\n     {\n@@ -68,7 +74,7 @@ void AsofRowRefs::insert(Type type, const IColumn * asof_column, const Block * b\n     callWithType(type, call);\n }\n \n-const RowRef * AsofRowRefs::findAsof(Type type, ASOF::Inequality inequality, const IColumn * asof_column, size_t row_num) const\n+const RowRef * AsofRowRefs::findAsof(TypeIndex type, ASOF::Inequality inequality, const IColumn * asof_column, size_t row_num) const\n {\n     const RowRef * out = nullptr;\n \n@@ -96,52 +102,56 @@ const RowRef * AsofRowRefs::findAsof(Type type, ASOF::Inequality inequality, con\n     return out;\n }\n \n-std::optional<AsofRowRefs::Type> AsofRowRefs::getTypeSize(const IColumn * asof_column, size_t & size)\n+std::optional<TypeIndex> AsofRowRefs::getTypeSize(const IColumn * asof_column, size_t & size)\n {\n-    if (typeid_cast<const ColumnVector<UInt32> *>(asof_column))\n-    {\n-        size = sizeof(UInt32);\n-        return Type::keyu32;\n-    }\n-    else if (typeid_cast<const ColumnVector<UInt64> *>(asof_column))\n-    {\n-        size = sizeof(UInt64);\n-        return Type::keyu64;\n-    }\n-    else if (typeid_cast<const ColumnVector<Int32> *>(asof_column))\n-    {\n-        size = sizeof(Int32);\n-        return Type::keyi32;\n-    }\n-    else if (typeid_cast<const ColumnVector<Int64> *>(asof_column))\n-    {\n-        size = sizeof(Int64);\n-        return Type::keyi64;\n-    }\n-    else if (typeid_cast<const ColumnVector<Float32> *>(asof_column))\n-    {\n-        size = sizeof(Float32);\n-        return Type::keyf32;\n-    }\n-    else if (typeid_cast<const ColumnVector<Float64> *>(asof_column))\n-    {\n-        size = sizeof(Float64);\n-        return Type::keyf64;\n-    }\n-    else if (typeid_cast<const ColumnDecimal<Decimal32> *>(asof_column))\n-    {\n-        size = sizeof(Decimal32);\n-        return Type::keyDecimal32;\n-    }\n-    else if (typeid_cast<const ColumnDecimal<Decimal64> *>(asof_column))\n-    {\n-        size = sizeof(Decimal64);\n-        return Type::keyDecimal64;\n-    }\n-    else if (typeid_cast<const ColumnDecimal<Decimal128> *>(asof_column))\n+    TypeIndex idx = columnVectorDataType(asof_column);\n+    if (idx == TypeIndex::Nothing)\n+        idx = columnDecimalDataType(asof_column);\n+\n+    switch (idx)\n     {\n-        size = sizeof(Decimal128);\n-        return Type::keyDecimal128;\n+        case TypeIndex::UInt8:\n+            size = sizeof(UInt8);\n+            return idx;\n+        case TypeIndex::UInt16:\n+            size = sizeof(UInt16);\n+            return idx;\n+        case TypeIndex::UInt32:\n+            size = sizeof(UInt32);\n+            return idx;\n+        case TypeIndex::UInt64:\n+            size = sizeof(UInt64);\n+            return idx;\n+        case TypeIndex::Int8:\n+            size = sizeof(Int8);\n+            return idx;\n+        case TypeIndex::Int16:\n+            size = sizeof(Int16);\n+            return idx;\n+        case TypeIndex::Int32:\n+            size = sizeof(Int32);\n+            return idx;\n+        case TypeIndex::Int64:\n+            size = sizeof(Int64);\n+            return idx;\n+        //case TypeIndex::Int128:\n+        case TypeIndex::Float32:\n+            size = sizeof(Float32);\n+            return idx;\n+        case TypeIndex::Float64:\n+            size = sizeof(Float64);\n+            return idx;\n+        case TypeIndex::Decimal32:\n+            size = sizeof(Decimal32);\n+            return idx;\n+        case TypeIndex::Decimal64:\n+            size = sizeof(Decimal64);\n+            return idx;\n+        case TypeIndex::Decimal128:\n+            size = sizeof(Decimal128);\n+            return idx;\n+        default:\n+            break;\n     }\n \n     size = 0;\ndiff --git a/src/Interpreters/RowRefs.h b/src/Interpreters/RowRefs.h\nindex 65ae16e2b496..e8231b1c233f 100644\n--- a/src/Interpreters/RowRefs.h\n+++ b/src/Interpreters/RowRefs.h\n@@ -216,8 +216,12 @@ class AsofRowRefs\n     };\n \n     using Lookups = std::variant<\n+        Entry<UInt8>::LookupPtr,\n+        Entry<UInt16>::LookupPtr,\n         Entry<UInt32>::LookupPtr,\n         Entry<UInt64>::LookupPtr,\n+        Entry<Int8>::LookupPtr,\n+        Entry<Int16>::LookupPtr,\n         Entry<Int32>::LookupPtr,\n         Entry<Int64>::LookupPtr,\n         Entry<Float32>::LookupPtr,\n@@ -226,29 +230,16 @@ class AsofRowRefs\n         Entry<Decimal64>::LookupPtr,\n         Entry<Decimal128>::LookupPtr>;\n \n-    enum class Type\n-    {\n-        keyu32,\n-        keyu64,\n-        keyi32,\n-        keyi64,\n-        keyf32,\n-        keyf64,\n-        keyDecimal32,\n-        keyDecimal64,\n-        keyDecimal128,\n-    };\n-\n     AsofRowRefs() {}\n-    AsofRowRefs(Type t);\n+    AsofRowRefs(TypeIndex t);\n \n-    static std::optional<Type> getTypeSize(const IColumn * asof_column, size_t & type_size);\n+    static std::optional<TypeIndex> getTypeSize(const IColumn * asof_column, size_t & type_size);\n \n     // This will be synchronized by the rwlock mutex in Join.h\n-    void insert(Type type, const IColumn * asof_column, const Block * block, size_t row_num);\n+    void insert(TypeIndex type, const IColumn * asof_column, const Block * block, size_t row_num);\n \n     // This will internally synchronize\n-    const RowRef * findAsof(Type type, ASOF::Inequality inequality, const IColumn * asof_column, size_t row_num) const;\n+    const RowRef * findAsof(TypeIndex type, ASOF::Inequality inequality, const IColumn * asof_column, size_t row_num) const;\n \n private:\n     // Lookups can be stored in a HashTable because it is memmovable\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01139_asof_join_types.reference b/tests/queries/0_stateless/01139_asof_join_types.reference\nnew file mode 100644\nindex 000000000000..102064ce772d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01139_asof_join_types.reference\n@@ -0,0 +1,13 @@\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t1\n+0\t0000-00-00\n+0\t0000-00-00 00:00:00\ndiff --git a/tests/queries/0_stateless/01139_asof_join_types.sql b/tests/queries/0_stateless/01139_asof_join_types.sql\nnew file mode 100644\nindex 000000000000..45edf8ff06b1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01139_asof_join_types.sql\n@@ -0,0 +1,18 @@\n+select * from (select 0 as k, toInt8(1) as v) t1 asof join (select 0 as k, toInt8(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toInt16(1) as v) t1 asof join (select 0 as k, toInt16(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toInt32(1) as v) t1 asof join (select 0 as k, toInt32(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toInt64(1) as v) t1 asof join (select 0 as k, toInt64(0) as v) t2 using(k, v);\n+\n+select * from (select 0 as k, toUInt8(1) as v) t1 asof join (select 0 as k, toUInt8(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toUInt16(1) as v) t1 asof join (select 0 as k, toUInt16(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toUInt32(1) as v) t1 asof join (select 0 as k, toUInt32(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toUInt64(1) as v) t1 asof join (select 0 as k, toUInt64(0) as v) t2 using(k, v);\n+\n+select * from (select 0 as k, toDecimal32(1, 0) as v) t1 asof join (select 0 as k, toDecimal32(0, 0) as v) t2 using(k, v);\n+select * from (select 0 as k, toDecimal64(1, 0) as v) t1 asof join (select 0 as k, toDecimal64(0, 0) as v) t2 using(k, v);\n+select * from (select 0 as k, toDecimal128(1, 0) as v) t1 asof join (select 0 as k, toDecimal128(0, 0) as v) t2 using(k, v);\n+\n+select * from (select 0 as k, toDate(0) as v) t1 asof join (select 0 as k, toDate(0) as v) t2 using(k, v);\n+select * from (select 0 as k, toDateTime(0) as v) t1 asof join (select 0 as k, toDateTime(0) as v) t2 using(k, v);\n+\n+select * from (select 0 as k, 'x' as v) t1 asof join (select 0 as k, 'x' as v) t2 using(k, v); -- { serverError 169 }\n",
  "problem_statement": "ASOF join Date type is not supported.\n> should be one of the data types: UInt32, UInt64, Float32, Float64, Date, and DateTime\r\n\r\n`Code: 169. DB::Exception: Received from 192.168.99.100:9091. DB::Exception: ASOF join not supported for typeUInt16`\r\n\r\nWhen I changed my field for `asof_condition` to `Datetime` my query worked.\r\n\r\nIn the code, I found no mentioning of the Date type. Lokes like the documentation goes a bit ahead or the type was forgotten.\r\n\r\n```\r\n        asof_type = AsofRowRefs::getTypeSize(asof_column, asof_size);\r\n        if (!asof_type)\r\n        {\r\n            std::string msg = \"ASOF join not supported for type\";\r\n            msg += asof_column->getFamilyName();\r\n            throw Exception(msg, ErrorCodes::BAD_TYPE_OF_FIELD);\r\n        }\r\n```\r\n\r\n[RowRefs.cpp](https://github.com/ClickHouse/ClickHouse/blob/3ceeb95145430ce24302b94a03004c5b37e9a1c7/dbms/src/Interpreters/RowRefs.cpp#L17)\r\n\r\n```\r\nvoid callWithType(AsofRowRefs::Type which, F && f)\r\n{\r\n    switch (which)\r\n    {\r\n        case AsofRowRefs::Type::key32:  return f(UInt32());\r\n        case AsofRowRefs::Type::key64:  return f(UInt64());\r\n        case AsofRowRefs::Type::keyf32: return f(Float32());\r\n        case AsofRowRefs::Type::keyf64: return f(Float64());\r\n    }\r\n\r\n    __builtin_unreachable();\r\n}\r\n\r\n}\r\n\r\n\r\nAsofRowRefs::AsofRowRefs(Type type)\r\n{\r\n    auto call = [&](const auto & t)\r\n    {\r\n      using T = std::decay_t<decltype(t)>;\r\n      using LookupType = typename Entry<T>::LookupType;\r\n      lookups = std::make_unique<LookupType>();\r\n    };\r\n\r\n    callWithType(type, call);\r\n}\r\n```\r\n\r\n\r\nSorry for the poorly written issue report. \n",
  "hints_text": "",
  "created_at": "2020-05-29T20:55:29Z"
}