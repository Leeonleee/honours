You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Support Decimal multiplication saving result scale
В decimal есть довольно неудобный подвох - если хочешь произвести умножение 2 чисел, то невозможно это сделать не увеличивая precision (хочется умножение с округлением). 

В абсолютно типичном сценарии amount Decimal64(2), exchange_rate Decimal64(6) сейчас происходят переполнения, это неудобно, и такое расширение точности там совсем не нужно. МБ просто нужно добавить вариант умножения с округлением?

```sql
SELECT round(toDecimal64(1, 8) * toDecimal64(1000, 8), 8)

Received exception from server (version 19.18.1):
Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow. 

SET decimal_check_overflow = 0;

SELECT round(toDecimal64(1, 8) * toDecimal64(1000, 8), 8);

┌─round(multiply(toDecimal64(1, 8), toDecimal64(1000, 8)), 8)─┐
│                                       -844.6744073700000000 │
└─────────────────────────────────────────────────────────────┘

1 rows in set. Elapsed: 0.047 sec.

SELECT toTypeName(toDecimal64(1, 3) * toDecimal64(1, 4)) AS x

Row 1:
──────
x: Decimal(18, 7)
```
мб ему в таких случаях стоит разрешить расширять тип самостоятельно - до Decimal128?

> МБ просто нужно добавить вариант умножения с округлением?

Да, и это будет самым логичным и ожидаемым поведением. Но не ясно, насколько сложно сделать. Хотя если мы умеем определять overflow, значит можно сделать в slow path, и тогда скорость работы обычных случаев не изменится.

> Как вариант - менять поведение обычного умножения на это умножение с округлением настройкой по умолнчанию?

Лучше без настроек.

> При делении он остаётся с типом левого аргумента

А здесь всё правильно, это самое логичное поведение.

> По-другому технически нерационально

По моему, можно сделать даже без компромиссов по производительности.


Add precise Decimal division
Right now, `Decimal` devision (#30341, #38054) can cause some pain. 
It works fine, but with strict limitations -- e.g. we cannot divide Decimals that have scale more than half of max scale (#39600).

Currently used division has good speed -- in fact, we just make 1 division (expensive) and multiplication (not so expensive), but precision is poor. 

I suggest adding separate function (smth like `preciseDecimalDiv(a: Decimal, b: Decimal, prcsn: UInt8)` with user-defined result precision) for decimal division (alongside "usual" one).
Maybe even we can replace currently existing division by this more precise version, but it will be like 10 times slower (more division operations are to be made), and it may be unacceptable if you don't need high precision.
That's why I suggest having 2 separate functions.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
