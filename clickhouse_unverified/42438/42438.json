{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42438,
  "instance_id": "ClickHouse__ClickHouse-42438",
  "issue_numbers": [
    "8049",
    "40573"
  ],
  "base_commit": "58557c87c23535e9831695b39bf038cf68524d1d",
  "patch": "diff --git a/docs/en/sql-reference/functions/arithmetic-functions.md b/docs/en/sql-reference/functions/arithmetic-functions.md\nindex ece50591ef99..56f3a88b28bd 100644\n--- a/docs/en/sql-reference/functions/arithmetic-functions.md\n+++ b/docs/en/sql-reference/functions/arithmetic-functions.md\n@@ -161,3 +161,140 @@ Result:\n \u2502          -1 \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n+\n+## multiplyDecimal(a, b[, result_scale])\n+\n+Performs multiplication on two decimals. Result value will be of type [Decimal256](../../sql-reference/data-types/decimal.md).\n+Result scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.\n+\n+:::note    \n+These functions work significantly slower than usual `multiply`.\n+In case you don't really need controlled precision and/or need fast computation, consider using [multiply](#multiply)\n+:::\n+\n+**Syntax**\n+\n+```sql\n+multiplyDecimal(a, b[, result_scale])\n+```\n+\n+**Arguments**\n+\n+-   `a` \u2014 First value: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `b` \u2014 Second value: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `result_scale` \u2014 Scale of result: [Int/UInt](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+-   The result of multiplication with given scale.\n+\n+Type: [Decimal256](../../sql-reference/data-types/decimal.md).\n+\n+**Example**\n+\n+```text\n+\u250c\u2500multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)\u2500\u2510\n+\u2502                                                           25.2 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Difference from regular multiplication:**\n+```sql\n+SELECT toDecimal64(-12.647, 3) * toDecimal32(2.1239, 4);\n+SELECT toDecimal64(-12.647, 3) as a, toDecimal32(2.1239, 4) as b, multiplyDecimal(a, b);\n+```\n+\n+```text\n+\u250c\u2500multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))\u2500\u2510\n+\u2502                                               -26.8609633 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))\u2500\u2510\n+\u2502                                                         -26.8609 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+```sql\n+SELECT\n+    toDecimal64(-12.647987876, 9) AS a,\n+    toDecimal64(123.967645643, 9) AS b,\n+    multiplyDecimal(a, b);\n+\n+SELECT\n+    toDecimal64(-12.647987876, 9) AS a,\n+    toDecimal64(123.967645643, 9) AS b,\n+    a * b;\n+```\n+\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500b\u2500\u252c\u2500multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))\u2500\u2510\n+\u2502 -12.647987876 \u2502 123.967645643 \u2502                                                               -1567.941279108 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Received exception from server (version 22.11.1):\n+Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow: While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)\n+```\n+\n+## divideDecimal(a, b[, result_scale])\n+\n+Performs division on two decimals. Result value will be of type [Decimal256](../../sql-reference/data-types/decimal.md).\n+Result scale can be explicitly specified by `result_scale` argument (const Integer in range `[0, 76]`). If not specified, the result scale is the max scale of given arguments.\n+\n+:::note    \n+These function work significantly slower than usual `divide`.\n+In case you don't really need controlled precision and/or need fast computation, consider using [divide](#divide).\n+:::\n+\n+**Syntax**\n+\n+```sql\n+divideDecimal(a, b[, result_scale])\n+```\n+\n+**Arguments**\n+\n+-   `a` \u2014 First value: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `b` \u2014 Second value: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `result_scale` \u2014 Scale of result: [Int/UInt](../../sql-reference/data-types/int-uint.md).\n+\n+**Returned value**\n+\n+-   The result of division with given scale.\n+\n+Type: [Decimal256](../../sql-reference/data-types/decimal.md).\n+\n+**Example**\n+\n+```text\n+\u250c\u2500divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)\u2500\u2510\n+\u2502                                                -5.7142857142 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Difference from regular division:**\n+```sql\n+SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);\n+SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);\n+```\n+\n+```text\n+\u250c\u2500divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))\u2500\u2510\n+\u2502                                             -5.7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\u250c\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500b\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)\u2500\u2510\n+\u2502 -12 \u2502 2.1 \u2502                                                       -5.7 \u2502                                                   -5.71428 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+```sql\n+SELECT toDecimal64(-12, 0) / toDecimal32(2.1, 1);\n+SELECT toDecimal64(-12, 0) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);\n+```\n+\n+```text\n+DB::Exception: Decimal result's scale is less than argument's one: While processing toDecimal64(-12, 0) / toDecimal32(2.1, 1). (ARGUMENT_OUT_OF_BOUND)\n+\n+\u250c\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500b\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 0), toDecimal32(2.1, 1), 1)\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 0), toDecimal32(2.1, 1), 5)\u2500\u2510\n+\u2502 -12 \u2502 2.1 \u2502                                                       -5.7 \u2502                                                   -5.71428 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\ndiff --git a/docs/ru/sql-reference/functions/arithmetic-functions.md b/docs/ru/sql-reference/functions/arithmetic-functions.md\nindex bc1d0a55128c..4e040edcc70c 100644\n--- a/docs/ru/sql-reference/functions/arithmetic-functions.md\n+++ b/docs/ru/sql-reference/functions/arithmetic-functions.md\n@@ -159,3 +159,150 @@ SELECT min2(-1, 2);\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## multiplyDecimal(a, b[, result_scale])\n+\n+\u0421\u043e\u0432\u0435\u0440\u0448\u0430\u0435\u0442 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u0434\u0432\u0443\u0445 Decimal. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0431\u0443\u0434\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u0442\u0438\u043f [Decimal256](../../sql-reference/data-types/decimal.md).\n+Scale (\u0440\u0430\u0437\u043c\u0435\u0440 \u0434\u0440\u043e\u0431\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u0438) \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043c\u043e\u0436\u043d\u043e \u044f\u0432\u043d\u043e \u0437\u0430\u0434\u0430\u0442\u044c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c `result_scale`  (\u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u0430\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430 \u0438\u0437 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0430 `[0, 76]`).\n+\u0415\u0441\u043b\u0438 \u044d\u0442\u043e\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u0437\u0430\u0434\u0430\u043d, \u0442\u043e scale \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0431\u0443\u0434\u0435\u0442 \u0440\u0430\u0432\u0435\u043d \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0435\u043c\u0443 \u0438\u0437 scale \u043e\u0431\u043e\u0438\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432.\n+\n+**\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n+\n+```sql\n+multiplyDecimal(a, b[, result_scale])\n+```\n+\n+:::note    \n+\u042d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u0430\u044e\u0442 \u0433\u043e\u0440\u0430\u0437\u0434\u043e \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u0435\u0435 \u043e\u0431\u044b\u0447\u043d\u043e\u0439 `multiply`.\n+\u0412 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0438\u043c\u0435\u0442\u044c \u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0443\u044e \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438/\u0438\u043b\u0438 \u043d\u0443\u0436\u043d\u044b \u0431\u044b\u0441\u0442\u0440\u044b\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f, \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c [multiply](#multiply).\n+:::\n+\n+**\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n+\n+-   `a` \u2014 \u041f\u0435\u0440\u0432\u044b\u0439 \u0441\u043e\u043c\u043d\u043e\u0436\u0438\u0442\u0435\u043b\u044c/\u0434\u0435\u043b\u0438\u043c\u043e\u0435: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `b` \u2014 \u0412\u0442\u043e\u0440\u043e\u0439 \u0441\u043e\u043c\u043d\u043e\u0436\u0438\u0442\u0435\u043b\u044c/\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044c: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `result_scale` \u2014 Scale \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430: [Int/UInt](../../sql-reference/data-types/int-uint.md).\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n+\n+-   \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c scale.\n+\n+\u0422\u0438\u043f: [Decimal256](../../sql-reference/data-types/decimal.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440\u044b**\n+\n+```sql\n+SELECT multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1);\n+```\n+\n+```text\n+\u250c\u2500multiplyDecimal(toDecimal256(-12, 0), toDecimal32(-2.1, 1), 1)\u2500\u2510\n+\u2502                                                           25.2 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**\u041e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439**\n+```sql\n+SELECT toDecimal64(-12.647, 3) * toDecimal32(2.1239, 4);\n+SELECT toDecimal64(-12.647, 3) as a, toDecimal32(2.1239, 4) as b, multiplyDecimal(a, b);\n+```\n+\n+```text\n+\u250c\u2500multiply(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))\u2500\u2510\n+\u2502                                               -26.8609633 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500multiplyDecimal(toDecimal64(-12.647, 3), toDecimal32(2.1239, 4))\u2500\u2510\n+\u2502                                                         -26.8609 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+```sql\n+SELECT\n+    toDecimal64(-12.647987876, 9) AS a,\n+    toDecimal64(123.967645643, 9) AS b,\n+    multiplyDecimal(a, b);\n+\n+SELECT\n+    toDecimal64(-12.647987876, 9) AS a,\n+    toDecimal64(123.967645643, 9) AS b,\n+    a * b;\n+```\n+\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500b\u2500\u252c\u2500multiplyDecimal(toDecimal64(-12.647987876, 9), toDecimal64(123.967645643, 9))\u2500\u2510\n+\u2502 -12.647987876 \u2502 123.967645643 \u2502                                                               -1567.941279108 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+Received exception from server (version 22.11.1):\n+Code: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow: While processing toDecimal64(-12.647987876, 9) AS a, toDecimal64(123.967645643, 9) AS b, a * b. (DECIMAL_OVERFLOW)\n+```\n+\n+## divideDecimal(a, b[, result_scale])\n+\n+\u0421\u043e\u0432\u0435\u0440\u0448\u0430\u0435\u0442 \u0434\u0435\u043b\u0435\u043d\u0438\u0435 \u0434\u0432\u0443\u0445 Decimal. \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0431\u0443\u0434\u0435\u0442 \u0438\u043c\u0435\u0442\u044c \u0442\u0438\u043f [Decimal256](../../sql-reference/data-types/decimal.md).\n+Scale (\u0440\u0430\u0437\u043c\u0435\u0440 \u0434\u0440\u043e\u0431\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u0438) \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u043c\u043e\u0436\u043d\u043e \u044f\u0432\u043d\u043e \u0437\u0430\u0434\u0430\u0442\u044c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c `result_scale`  (\u0446\u0435\u043b\u043e\u0447\u0438\u0441\u043b\u0435\u043d\u043d\u0430\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430 \u0438\u0437 \u0438\u043d\u0442\u0435\u0440\u0432\u0430\u043b\u0430 `[0, 76]`).\n+\u0415\u0441\u043b\u0438 \u044d\u0442\u043e\u0442 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442 \u043d\u0435 \u0437\u0430\u0434\u0430\u043d, \u0442\u043e scale \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430 \u0431\u0443\u0434\u0435\u0442 \u0440\u0430\u0432\u0435\u043d \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0435\u043c\u0443 \u0438\u0437 scale \u043e\u0431\u043e\u0438\u0445 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u0432.\n+\n+**\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n+\n+```sql\n+divideDecimal(a, b[, result_scale])\n+```\n+\n+:::note    \n+\u042d\u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0440\u0430\u0431\u043e\u0442\u0430\u0435\u0442 \u0433\u043e\u0440\u0430\u0437\u0434\u043e \u043c\u0435\u0434\u043b\u0435\u043d\u043d\u0435\u0435 \u043e\u0431\u044b\u0447\u043d\u043e\u0439 `divide`.\n+\u0412 \u0441\u043b\u0443\u0447\u0430\u0435, \u0435\u0441\u043b\u0438 \u043d\u0435\u0442 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0438\u043c\u0435\u0442\u044c \u0444\u0438\u043a\u0441\u0438\u0440\u043e\u0432\u0430\u043d\u043d\u0443\u044e \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u0438/\u0438\u043b\u0438 \u043d\u0443\u0436\u043d\u044b \u0431\u044b\u0441\u0442\u0440\u044b\u0435 \u0432\u044b\u0447\u0438\u0441\u043b\u0435\u043d\u0438\u044f, \u0441\u043b\u0435\u0434\u0443\u0435\u0442 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u0442\u044c [divide](#divide).\n+:::\n+\n+**\u0410\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u044b**\n+\n+-   `a` \u2014 \u041f\u0435\u0440\u0432\u044b\u0439 \u0441\u043e\u043c\u043d\u043e\u0436\u0438\u0442\u0435\u043b\u044c/\u0434\u0435\u043b\u0438\u043c\u043e\u0435: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `b` \u2014 \u0412\u0442\u043e\u0440\u043e\u0439 \u0441\u043e\u043c\u043d\u043e\u0436\u0438\u0442\u0435\u043b\u044c/\u0434\u0435\u043b\u0438\u0442\u0435\u043b\u044c: [Decimal](../../sql-reference/data-types/decimal.md).\n+-   `result_scale` \u2014 Scale \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442\u0430: [Int/UInt](../../sql-reference/data-types/int-uint.md).\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n+\n+-   \u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442 \u0434\u0435\u043b\u0435\u043d\u0438\u044f \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c scale.\n+\n+\u0422\u0438\u043f: [Decimal256](../../sql-reference/data-types/decimal.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440\u044b**\n+\n+```sql\n+SELECT divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10);\n+```\n+\n+```text\n+\u250c\u2500divideDecimal(toDecimal256(-12, 0), toDecimal32(2.1, 1), 10)\u2500\u2510\n+\u2502                                                -5.7142857142 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**\u041e\u0442\u043b\u0438\u0447\u0438\u0435 \u043e\u0442 \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439**\n+```sql\n+SELECT toDecimal64(-12, 1) / toDecimal32(2.1, 1);\n+SELECT toDecimal64(-12, 1) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);\n+```\n+\n+```text\n+\u250c\u2500divide(toDecimal64(-12, 1), toDecimal32(2.1, 1))\u2500\u2510\n+\u2502                                             -5.7 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\n+\u250c\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500b\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 1)\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 1), toDecimal32(2.1, 1), 5)\u2500\u2510\n+\u2502 -12 \u2502 2.1 \u2502                                                       -5.7 \u2502                                                   -5.71428 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+```sql\n+SELECT toDecimal64(-12, 0) / toDecimal32(2.1, 1);\n+SELECT toDecimal64(-12, 0) as a, toDecimal32(2.1, 1) as b, divideDecimal(a, b, 1), divideDecimal(a, b, 5);\n+```\n+\n+```text\n+DB::Exception: Decimal result's scale is less than argument's one: While processing toDecimal64(-12, 0) / toDecimal32(2.1, 1). (ARGUMENT_OUT_OF_BOUND)\n+\n+\u250c\u2500\u2500\u2500a\u2500\u252c\u2500\u2500\u2500b\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 0), toDecimal32(2.1, 1), 1)\u2500\u252c\u2500divideDecimal(toDecimal64(-12, 0), toDecimal32(2.1, 1), 5)\u2500\u2510\n+\u2502 -12 \u2502 2.1 \u2502                                                       -5.7 \u2502                                                   -5.71428 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\ndiff --git a/src/Functions/FunctionsDecimalArithmetics.cpp b/src/Functions/FunctionsDecimalArithmetics.cpp\nnew file mode 100644\nindex 000000000000..f275f169914b\n--- /dev/null\n+++ b/src/Functions/FunctionsDecimalArithmetics.cpp\n@@ -0,0 +1,17 @@\n+#include <Functions/FunctionsDecimalArithmetics.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+REGISTER_FUNCTION(DivideDecimals)\n+{\n+    factory.registerFunction<FunctionsDecimalArithmetics<DivideDecimalsImpl>>(Documentation(\n+        \"Decimal division with given precision. Slower than simple `divide`, but has controlled precision and no sound overflows\"));\n+}\n+\n+REGISTER_FUNCTION(MultiplyDecimals)\n+{\n+    factory.registerFunction<FunctionsDecimalArithmetics<MultiplyDecimalsImpl>>(Documentation(\n+        \"Decimal multiplication with given precision. Slower than simple `divide`, but has controlled precision and no sound overflows\"));\n+}\n+}\ndiff --git a/src/Functions/FunctionsDecimalArithmetics.h b/src/Functions/FunctionsDecimalArithmetics.h\nnew file mode 100644\nindex 000000000000..9806d13ed305\n--- /dev/null\n+++ b/src/Functions/FunctionsDecimalArithmetics.h\n@@ -0,0 +1,457 @@\n+#pragma once\n+#include <type_traits>\n+#include <Core/AccurateComparison.h>\n+\n+#include <DataTypes/DataTypesDecimal.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/castTypeToEither.h>\n+#include <IO/WriteHelpers.h>\n+\n+#include <Common/logger_useful.h>\n+#include <Poco/Logger.h>\n+#include <Loggers/Loggers.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int DECIMAL_OVERFLOW;\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ILLEGAL_DIVISION;\n+}\n+\n+\n+struct DecimalOpHelpers\n+{\n+    /* These functions perform main arithmetic logic.\n+     * As soon as intermediate results may not fit Decimal256 (e.g. 1e36, scale 10),\n+     * we may not operate with Decimals. Later on this big number may be shrunk (e.g. result scale is 0 in the case above).\n+     * That's why we need to store intermediate results in a flexible extendable storage (here we use std::vector)\n+     * Here we operate on numbers using simple digit arithmetic.\n+     * This is the reason these functions are slower than traditional ones.\n+     *\n+     * Here and below we use UInt8 for storing digits (0-9 range with maximum carry of 9 will definitely fit this)\n+     */\n+    static std::vector<UInt8> multiply(const std::vector<UInt8> & num1, const std::vector<UInt8> & num2)\n+    {\n+        UInt16 const len1 = num1.size();\n+        UInt16 const len2 = num2.size();\n+        if (len1 == 0 || len2 == 0)\n+            return {0};\n+\n+        std::vector<UInt8> result(len1 + len2, 0);\n+        UInt16 i_n1 = 0;\n+        UInt16 i_n2;\n+\n+        for (Int32 i = len1 - 1; i >= 0; --i)\n+        {\n+            UInt16 carry = 0;\n+            i_n2 = 0;\n+            for (Int32 j = len2 - 1; j >= 0; --j)\n+            {\n+                if (unlikely(i_n1 + i_n2 >= len1 + len2))\n+                    throw DB::Exception(\"Numeric overflow: result bigger that Decimal256\", ErrorCodes::DECIMAL_OVERFLOW);\n+                UInt16 sum = num1[i] * num2[j] + result[i_n1 + i_n2] + carry;\n+                carry = sum / 10;\n+                result[i_n1 + i_n2] = sum % 10;\n+                ++i_n2;\n+            }\n+\n+            if (carry > 0)\n+            {\n+                if (unlikely(i_n1 + i_n2 >= len1 + len2))\n+                    throw DB::Exception(\"Numeric overflow: result bigger that Decimal256\", ErrorCodes::DECIMAL_OVERFLOW);\n+                result[i_n1 + i_n2] += carry;\n+            }\n+\n+            ++i_n1;\n+        }\n+\n+        // Maximum Int32 value exceeds 2 billion, we can safely use it for array length storing\n+        Int32 i = static_cast<Int32>(result.size() - 1);\n+\n+        while (i >= 0 && result[i] == 0)\n+        {\n+            result.pop_back();\n+            --i;\n+        }\n+        if (i == -1)\n+            return {0};\n+\n+        std::reverse(result.begin(), result.end());\n+        return result;\n+    }\n+\n+    static std::vector<UInt8> divide(const std::vector<UInt8> & number, const Int256 & divisor)\n+    {\n+        std::vector<UInt8> result;\n+        const auto max_index = number.size() - 1;\n+\n+        UInt16 idx = 0;\n+        Int256 temp = 0;\n+\n+        while (temp < divisor && max_index > idx)\n+        {\n+            temp = temp * 10 + number[idx];\n+            ++idx;\n+        }\n+\n+        if (unlikely(temp == 0))\n+            return {0};\n+\n+        while (max_index >= idx)\n+        {\n+            result.push_back(temp / divisor);\n+            temp = (temp % divisor) * 10 + number[idx];\n+            ++idx;\n+        }\n+        result.push_back(temp / divisor);\n+\n+        return result;\n+    }\n+\n+    static std::vector<UInt8> toDigits(Int256 x)\n+    {\n+        std::vector<UInt8> result;\n+        if (x >= 10)\n+            result = toDigits(x / 10);\n+\n+        result.push_back(x % 10);\n+        return result;\n+    }\n+\n+    static UInt256 fromDigits(const std::vector<UInt8> & digits)\n+    {\n+        Int256 result = 0;\n+        Int256 scale = 0;\n+        for (auto i = digits.rbegin(); i != digits.rend(); ++i)\n+        {\n+            result += DecimalUtils::scaleMultiplier<Decimal256>(scale) * (*i);\n+            ++scale;\n+        }\n+        return result;\n+    }\n+};\n+\n+\n+struct DivideDecimalsImpl\n+{\n+    static constexpr auto name = \"divideDecimal\";\n+\n+    template <typename FirstType, typename SecondType>\n+    static inline Decimal256\n+    execute(FirstType a, SecondType b, UInt16 scale_a, UInt16 scale_b, UInt16 result_scale)\n+    {\n+        if (b.value == 0)\n+            throw DB::Exception(\"Division by zero\", ErrorCodes::ILLEGAL_DIVISION);\n+        if (a.value == 0)\n+            return Decimal256(0);\n+\n+        Int256 sign_a = a.value < 0 ? -1 : 1;\n+        Int256 sign_b = b.value < 0 ? -1 : 1;\n+\n+        std::vector<UInt8> a_digits = DecimalOpHelpers::toDigits(a.value * sign_a);\n+\n+        while (scale_a < scale_b + result_scale)\n+        {\n+            a_digits.push_back(0);\n+            ++scale_a;\n+        }\n+\n+        while (scale_a > scale_b + result_scale && !a_digits.empty())\n+        {\n+            a_digits.pop_back();\n+            --scale_a;\n+        }\n+\n+        if (a_digits.empty())\n+            return Decimal256(0);\n+\n+        std::vector<UInt8> divided = DecimalOpHelpers::divide(a_digits, b.value * sign_b);\n+\n+        if (divided.size() > DecimalUtils::max_precision<Decimal256>)\n+            throw DB::Exception(\"Numeric overflow: result bigger that Decimal256\", ErrorCodes::DECIMAL_OVERFLOW);\n+        return Decimal256(sign_a * sign_b * DecimalOpHelpers::fromDigits(divided));\n+    }\n+};\n+\n+\n+struct MultiplyDecimalsImpl\n+{\n+    static constexpr auto name = \"multiplyDecimal\";\n+\n+    template <typename FirstType, typename SecondType>\n+    static inline Decimal256\n+    execute(FirstType a, SecondType b, UInt16 scale_a, UInt16 scale_b, UInt16 result_scale)\n+    {\n+        if (a.value == 0 || b.value == 0)\n+            return Decimal256(0);\n+\n+        Int256 sign_a = a.value < 0 ? -1 : 1;\n+        Int256 sign_b = b.value < 0 ? -1 : 1;\n+\n+        std::vector<UInt8> a_digits = DecimalOpHelpers::toDigits(a.value * sign_a);\n+        std::vector<UInt8> b_digits = DecimalOpHelpers::toDigits(b.value * sign_b);\n+\n+        std::vector<UInt8> multiplied = DecimalOpHelpers::multiply(a_digits, b_digits);\n+\n+        UInt16 product_scale = scale_a + scale_b;\n+        while (product_scale < result_scale)\n+        {\n+            multiplied.push_back(0);\n+            ++product_scale;\n+        }\n+\n+        while (product_scale > result_scale&& !multiplied.empty())\n+        {\n+            multiplied.pop_back();\n+            --product_scale;\n+        }\n+\n+        if (multiplied.empty())\n+            return Decimal256(0);\n+\n+        if (multiplied.size() > DecimalUtils::max_precision<Decimal256>)\n+            throw DB::Exception(\"Numeric overflow: result bigger that Decimal256\", ErrorCodes::DECIMAL_OVERFLOW);\n+\n+        return Decimal256(sign_a * sign_b * DecimalOpHelpers::fromDigits(multiplied));\n+    }\n+};\n+\n+\n+template <typename ResultType, typename Transform>\n+struct Processor\n+{\n+    const Transform transform;\n+\n+    explicit Processor(Transform transform_)\n+        : transform(std::move(transform_))\n+    {}\n+\n+    template <typename FirstArgVectorType, typename SecondArgType>\n+    void NO_INLINE\n+    vectorConstant(const FirstArgVectorType & vec_first, const SecondArgType second_value,\n+                   PaddedPODArray<typename ResultType::FieldType> & vec_to, UInt16 scale_a, UInt16 scale_b, UInt16 result_scale) const\n+    {\n+        size_t size = vec_first.size();\n+        vec_to.resize(size);\n+\n+        for (size_t i = 0; i < size; ++i)\n+            vec_to[i] = transform.execute(vec_first[i], second_value, scale_a, scale_b, result_scale);\n+    }\n+\n+    template <typename FirstArgVectorType, typename SecondArgVectorType>\n+    void NO_INLINE\n+    vectorVector(const FirstArgVectorType & vec_first, const SecondArgVectorType & vec_second,\n+                 PaddedPODArray<typename ResultType::FieldType> & vec_to, UInt16 scale_a, UInt16 scale_b, UInt16 result_scale) const\n+    {\n+        size_t size = vec_first.size();\n+        vec_to.resize(size);\n+\n+        for (size_t i = 0; i < size; ++i)\n+            vec_to[i] = transform.execute(vec_first[i], vec_second[i], scale_a, scale_b, result_scale);\n+    }\n+\n+    template <typename FirstArgType, typename SecondArgVectorType>\n+    void NO_INLINE\n+    constantVector(const FirstArgType & first_value, const SecondArgVectorType & vec_second,\n+                   PaddedPODArray<typename ResultType::FieldType> & vec_to, UInt16 scale_a, UInt16 scale_b, UInt16 result_scale) const\n+    {\n+        size_t size = vec_second.size();\n+        vec_to.resize(size);\n+\n+        for (size_t i = 0; i < size; ++i)\n+            vec_to[i] = transform.execute(first_value, vec_second[i], scale_a, scale_b, result_scale);\n+    }\n+};\n+\n+\n+template <typename FirstArgType, typename SecondArgType, typename ResultType, typename Transform>\n+struct DecimalArithmeticsImpl\n+{\n+    static ColumnPtr execute(Transform transform, const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type)\n+    {\n+        using FirstArgValueType = typename FirstArgType::FieldType;\n+        using FirstArgColumnType = typename FirstArgType::ColumnType;\n+        using SecondArgValueType = typename SecondArgType::FieldType;\n+        using SecondArgColumnType = typename SecondArgType::ColumnType;\n+        using ResultColumnType = typename ResultType::ColumnType;\n+\n+        UInt16 scale_a = getDecimalScale(*arguments[0].type);\n+        UInt16 scale_b = getDecimalScale(*arguments[1].type);\n+        UInt16 result_scale = getDecimalScale(*result_type->getPtr());\n+\n+        auto op = Processor<ResultType, Transform>{std::move(transform)};\n+\n+        auto result_col = result_type->createColumn();\n+        auto col_to = assert_cast<ResultColumnType *>(result_col.get());\n+\n+        const auto * first_col = checkAndGetColumn<FirstArgColumnType>(arguments[0].column.get());\n+        const auto * second_col = checkAndGetColumn<SecondArgColumnType>(arguments[1].column.get());\n+        const auto * first_col_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n+        const auto * second_col_const = typeid_cast<const ColumnConst *>(arguments[1].column.get());\n+\n+        if (first_col)\n+        {\n+            if (second_col_const)\n+                op.vectorConstant(first_col->getData(), second_col_const->template getValue<SecondArgValueType>(), col_to->getData(), scale_a, scale_b, result_scale);\n+            else\n+                op.vectorVector(first_col->getData(), second_col->getData(), col_to->getData(), scale_a, scale_b, result_scale);\n+        }\n+        else if (first_col_const)\n+        {\n+            op.constantVector(first_col_const->template getValue<FirstArgValueType>(), second_col->getData(), col_to->getData(), scale_a, scale_b, result_scale);\n+        }\n+        else\n+        {\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n+                            arguments[0].column->getName(), Transform::name);\n+        }\n+\n+        return result_col;\n+    }\n+};\n+\n+\n+template <typename Transform>\n+class FunctionsDecimalArithmetics : public IFunction\n+{\n+public:\n+    static constexpr auto name = Transform::name;\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionsDecimalArithmetics>(); }\n+\n+    String getName() const override\n+    {\n+        return name;\n+    }\n+\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() != 2 && arguments.size() != 3)\n+            throw Exception(\"Number of arguments for function \" + getName() + \" does not match: 2 or 3 expected\",\n+                            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        if (!isDecimal(arguments[0].type) || !isDecimal(arguments[1].type))\n+            throw Exception(\"Arguments for \" + getName() + \" function must be Decimal\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        UInt8 scale = std::max(getDecimalScale(*arguments[0].type->getPtr()), getDecimalScale(*arguments[1].type->getPtr()));\n+\n+        if (arguments.size() == 3)\n+        {\n+            WhichDataType which_scale(arguments[2].type.get());\n+\n+            if (!which_scale.isUInt8())\n+                throw Exception(\n+                    \"Illegal type \" + arguments[2].type->getName() + \" of third argument of function \" + getName()\n+                        + \". Should be constant UInt8 from range[0, 76]\",\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+            const ColumnConst * scale_column = checkAndGetColumnConst<ColumnUInt8>(arguments[2].column.get());\n+\n+            if (!scale_column)\n+                throw Exception(\n+                    \"Illegal column of third argument of function \" + getName() + \". Should be constant UInt8\",\n+                        ErrorCodes::ILLEGAL_COLUMN);\n+\n+            scale = scale_column->getValue<UInt8>();\n+        }\n+\n+        /**\n+        At compile time, result is unknown. We only know the Scale (number of fractional digits) at runtime.\n+        Also nothing is known about size of whole part.\n+        As in simple division/multiplication for decimals, we scale the result up, but is is explicit here and no downscale is performed.\n+        It guarantees that result will have given scale and it can also be MANUALLY converted to other decimal types later.\n+        **/\n+        if (scale > DecimalUtils::max_precision<Decimal256>)\n+            throw Exception(\"Illegal value of third argument of function \" + this->getName() + \": must be integer in range [0, 76]\",\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeDecimal256>(DecimalUtils::max_precision<Decimal256>, scale);\n+    }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {2}; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n+    {\n+        return resolveOverload(arguments, result_type);\n+    }\n+\n+private:\n+    //long resolver to call proper templated func\n+    ColumnPtr resolveOverload(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const\n+    {\n+        WhichDataType which_dividend(arguments[0].type.get());\n+        WhichDataType which_divisor(arguments[1].type.get());\n+        if (which_dividend.isDecimal32())\n+        {\n+            using DividendType = DataTypeDecimal32;\n+            if (which_divisor.isDecimal32())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal32, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal64())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal64, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal128())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal128, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal256())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal256, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+        }\n+\n+        else if (which_dividend.isDecimal64())\n+        {\n+            using DividendType = DataTypeDecimal64;\n+            if (which_divisor.isDecimal32())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal32, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal64())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal64, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal128())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal128, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal256())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal256, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+\n+        }\n+\n+        else if (which_dividend.isDecimal128())\n+        {\n+            using DividendType = DataTypeDecimal128;\n+            if (which_divisor.isDecimal32())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal32, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal64())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal64, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal128())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal128, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal256())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal256, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+\n+        }\n+\n+        else if (which_dividend.isDecimal256())\n+        {\n+            using DividendType = DataTypeDecimal256;\n+            if (which_divisor.isDecimal32())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal32, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal64())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal64, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal128())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal128, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+            else if (which_divisor.isDecimal256())\n+                return DecimalArithmeticsImpl<DividendType, DataTypeDecimal256, DataTypeDecimal256, Transform>::execute(Transform{}, arguments, result_type);\n+\n+        }\n+\n+        // the compiler is happy now\n+        return nullptr;\n+    }\n+};\n+\n+}\n+\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02475_precise_decimal_arithmetics.reference b/tests/queries/0_stateless/02475_precise_decimal_arithmetics.reference\nnew file mode 100644\nindex 000000000000..6ffc86026401\n--- /dev/null\n+++ b/tests/queries/0_stateless/02475_precise_decimal_arithmetics.reference\n@@ -0,0 +1,23 @@\n+0\n+0\n+0\n+9999999999999999550522436926092261716351992671467843175339166479588690755584\n+9999999999999999451597035424131548206707486713696660676795842648250000000000\n+11.126038\n+10.8\n+-11.126038\n+-10.8\n+10.8\n+1376.638914\n+1403.6\n+-1376.638914\n+-1403.6\n+1403.6\n+332833500\n+999\n+1000\n+1000\n+1000\n+0.1\n+0.1\n+0.1\ndiff --git a/tests/queries/0_stateless/02475_precise_decimal_arithmetics.sql b/tests/queries/0_stateless/02475_precise_decimal_arithmetics.sql\nnew file mode 100644\nindex 000000000000..3bd7906c7d86\n--- /dev/null\n+++ b/tests/queries/0_stateless/02475_precise_decimal_arithmetics.sql\n@@ -0,0 +1,45 @@\n+-- Tags: no-fasttest\n+\n+-- check cases when one of operands is zero\n+SELECT divideDecimal(toDecimal32(0, 2), toDecimal128(11.123456, 6));\n+SELECT divideDecimal(toDecimal64(123.123, 3), toDecimal64(0, 1)); -- { serverError 153 }\n+SELECT multiplyDecimal(toDecimal32(0, 2), toDecimal128(11.123456, 6));\n+SELECT multiplyDecimal(toDecimal32(123.123, 3), toDecimal128(0, 1));\n+\n+-- don't look at strange query result -- it happens due to bad float precision: toUInt256(1e38) == 99999999999999997752612184630461283328\n+SELECT multiplyDecimal(toDecimal256(1e38, 0), toDecimal256(1e38, 0));\n+SELECT divideDecimal(toDecimal256(1e66, 0), toDecimal256(1e-10, 10), 0);\n+\n+-- fits Decimal256, but scale is too big to fit\n+SELECT multiplyDecimal(toDecimal256(1e38, 0), toDecimal256(1e38, 0), 2); -- { serverError 407 }\n+SELECT divideDecimal(toDecimal256(1e72, 0), toDecimal256(1e-5, 5), 2); -- { serverError 407 }\n+\n+-- does not fit Decimal256\n+SELECT multiplyDecimal(toDecimal256('1e38', 0), toDecimal256('1e38', 0)); -- { serverError 407 }\n+SELECT multiplyDecimal(toDecimal256(1e39, 0), toDecimal256(1e39, 0), 0); -- { serverError 407 }\n+SELECT divideDecimal(toDecimal256(1e39, 0), toDecimal256(1e-38, 39)); -- { serverError 407 }\n+\n+-- test different signs\n+SELECT divideDecimal(toDecimal128(123.76, 2), toDecimal128(11.123456, 6));\n+SELECT divideDecimal(toDecimal32(123.123, 3), toDecimal128(11.4, 1), 2);\n+SELECT divideDecimal(toDecimal128(-123.76, 2), toDecimal128(11.123456, 6));\n+SELECT divideDecimal(toDecimal32(123.123, 3), toDecimal128(-11.4, 1), 2);\n+SELECT divideDecimal(toDecimal32(-123.123, 3), toDecimal128(-11.4, 1), 2);\n+\n+SELECT multiplyDecimal(toDecimal64(123.76, 2), toDecimal128(11.123456, 6));\n+SELECT multiplyDecimal(toDecimal32(123.123, 3), toDecimal128(11.4, 1), 2);\n+SELECT multiplyDecimal(toDecimal64(-123.76, 2), toDecimal128(11.123456, 6));\n+SELECT multiplyDecimal(toDecimal32(123.123, 3), toDecimal128(-11.4, 1), 2);\n+SELECT multiplyDecimal(toDecimal32(-123.123, 3), toDecimal128(-11.4, 1), 2);\n+\n+-- check against non-const columns\n+SELECT sum(multiplyDecimal(toDecimal64(number, 1), toDecimal64(number, 5))) FROM numbers(1000);\n+SELECT sum(divideDecimal(toDecimal64(number, 1), toDecimal64(number, 5))) FROM (select * from numbers(1000) OFFSET 1);\n+\n+-- check against Nullable type\n+SELECT multiplyDecimal(toNullable(toDecimal64(10, 1)), toDecimal64(100, 5));\n+SELECT multiplyDecimal(toDecimal64(10, 1), toNullable(toDecimal64(100, 5)));\n+SELECT multiplyDecimal(toNullable(toDecimal64(10, 1)), toNullable(toDecimal64(100, 5)));\n+SELECT divideDecimal(toNullable(toDecimal64(10, 1)), toDecimal64(100, 5));\n+SELECT divideDecimal(toDecimal64(10, 1), toNullable(toDecimal64(100, 5)));\n+SELECT divideDecimal(toNullable(toDecimal64(10, 1)), toNullable(toDecimal64(100, 5)));\n",
  "problem_statement": "Support Decimal multiplication saving result scale\n\u0412 decimal \u0435\u0441\u0442\u044c \u0434\u043e\u0432\u043e\u043b\u044c\u043d\u043e \u043d\u0435\u0443\u0434\u043e\u0431\u043d\u044b\u0439 \u043f\u043e\u0434\u0432\u043e\u0445 - \u0435\u0441\u043b\u0438 \u0445\u043e\u0447\u0435\u0448\u044c \u043f\u0440\u043e\u0438\u0437\u0432\u0435\u0441\u0442\u0438 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 2 \u0447\u0438\u0441\u0435\u043b, \u0442\u043e \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e \u044d\u0442\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u043d\u0435 \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u044f precision (\u0445\u043e\u0447\u0435\u0442\u0441\u044f \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u043e\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435\u043c). \r\n\r\n\u0412 \u0430\u0431\u0441\u043e\u043b\u044e\u0442\u043d\u043e \u0442\u0438\u043f\u0438\u0447\u043d\u043e\u043c \u0441\u0446\u0435\u043d\u0430\u0440\u0438\u0438 amount Decimal64(2), exchange_rate Decimal64(6) \u0441\u0435\u0439\u0447\u0430\u0441 \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u044f\u0442 \u043f\u0435\u0440\u0435\u043f\u043e\u043b\u043d\u0435\u043d\u0438\u044f, \u044d\u0442\u043e \u043d\u0435\u0443\u0434\u043e\u0431\u043d\u043e, \u0438 \u0442\u0430\u043a\u043e\u0435 \u0440\u0430\u0441\u0448\u0438\u0440\u0435\u043d\u0438\u0435 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u0438 \u0442\u0430\u043c \u0441\u043e\u0432\u0441\u0435\u043c \u043d\u0435 \u043d\u0443\u0436\u043d\u043e. \u041c\u0411 \u043f\u0440\u043e\u0441\u0442\u043e \u043d\u0443\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f \u0441 \u043e\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435\u043c?\r\n\r\n```sql\r\nSELECT round(toDecimal64(1, 8) * toDecimal64(1000, 8), 8)\r\n\r\nReceived exception from server (version 19.18.1):\r\nCode: 407. DB::Exception: Received from localhost:9000. DB::Exception: Decimal math overflow. \r\n\r\nSET decimal_check_overflow = 0;\r\n\r\nSELECT round(toDecimal64(1, 8) * toDecimal64(1000, 8), 8);\r\n\r\n\u250c\u2500round(multiply(toDecimal64(1, 8), toDecimal64(1000, 8)), 8)\u2500\u2510\r\n\u2502                                       -844.6744073700000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.047 sec.\r\n\r\nSELECT toTypeName(toDecimal64(1, 3) * toDecimal64(1, 4)) AS x\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nx: Decimal(18, 7)\r\n```\r\n\u043c\u0431 \u0435\u043c\u0443 \u0432 \u0442\u0430\u043a\u0438\u0445 \u0441\u043b\u0443\u0447\u0430\u044f\u0445 \u0441\u0442\u043e\u0438\u0442 \u0440\u0430\u0437\u0440\u0435\u0448\u0438\u0442\u044c \u0440\u0430\u0441\u0448\u0438\u0440\u044f\u0442\u044c \u0442\u0438\u043f \u0441\u0430\u043c\u043e\u0441\u0442\u043e\u044f\u0442\u0435\u043b\u044c\u043d\u043e - \u0434\u043e Decimal128?\r\n\r\n> \u041c\u0411 \u043f\u0440\u043e\u0441\u0442\u043e \u043d\u0443\u0436\u043d\u043e \u0434\u043e\u0431\u0430\u0432\u0438\u0442\u044c \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f \u0441 \u043e\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435\u043c?\r\n\r\n\u0414\u0430, \u0438 \u044d\u0442\u043e \u0431\u0443\u0434\u0435\u0442 \u0441\u0430\u043c\u044b\u043c \u043b\u043e\u0433\u0438\u0447\u043d\u044b\u043c \u0438 \u043e\u0436\u0438\u0434\u0430\u0435\u043c\u044b\u043c \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435\u043c. \u041d\u043e \u043d\u0435 \u044f\u0441\u043d\u043e, \u043d\u0430\u0441\u043a\u043e\u043b\u044c\u043a\u043e \u0441\u043b\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c. \u0425\u043e\u0442\u044f \u0435\u0441\u043b\u0438 \u043c\u044b \u0443\u043c\u0435\u0435\u043c \u043e\u043f\u0440\u0435\u0434\u0435\u043b\u044f\u0442\u044c overflow, \u0437\u043d\u0430\u0447\u0438\u0442 \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0432 slow path, \u0438 \u0442\u043e\u0433\u0434\u0430 \u0441\u043a\u043e\u0440\u043e\u0441\u0442\u044c \u0440\u0430\u0431\u043e\u0442\u044b \u043e\u0431\u044b\u0447\u043d\u044b\u0445 \u0441\u043b\u0443\u0447\u0430\u0435\u0432 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u0438\u0442\u0441\u044f.\r\n\r\n> \u041a\u0430\u043a \u0432\u0430\u0440\u0438\u0430\u043d\u0442 - \u043c\u0435\u043d\u044f\u0442\u044c \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435 \u043e\u0431\u044b\u0447\u043d\u043e\u0433\u043e \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u044f \u043d\u0430 \u044d\u0442\u043e \u0443\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0435 \u0441 \u043e\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435\u043c \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u043e\u0439 \u043f\u043e \u0443\u043c\u043e\u043b\u043d\u0447\u0430\u043d\u0438\u044e?\r\n\r\n\u041b\u0443\u0447\u0448\u0435 \u0431\u0435\u0437 \u043d\u0430\u0441\u0442\u0440\u043e\u0435\u043a.\r\n\r\n> \u041f\u0440\u0438 \u0434\u0435\u043b\u0435\u043d\u0438\u0438 \u043e\u043d \u043e\u0441\u0442\u0430\u0451\u0442\u0441\u044f \u0441 \u0442\u0438\u043f\u043e\u043c \u043b\u0435\u0432\u043e\u0433\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430\r\n\r\n\u0410 \u0437\u0434\u0435\u0441\u044c \u0432\u0441\u0451 \u043f\u0440\u0430\u0432\u0438\u043b\u044c\u043d\u043e, \u044d\u0442\u043e \u0441\u0430\u043c\u043e\u0435 \u043b\u043e\u0433\u0438\u0447\u043d\u043e\u0435 \u043f\u043e\u0432\u0435\u0434\u0435\u043d\u0438\u0435.\r\n\r\n> \u041f\u043e-\u0434\u0440\u0443\u0433\u043e\u043c\u0443 \u0442\u0435\u0445\u043d\u0438\u0447\u0435\u0441\u043a\u0438 \u043d\u0435\u0440\u0430\u0446\u0438\u043e\u043d\u0430\u043b\u044c\u043d\u043e\r\n\r\n\u041f\u043e \u043c\u043e\u0435\u043c\u0443, \u043c\u043e\u0436\u043d\u043e \u0441\u0434\u0435\u043b\u0430\u0442\u044c \u0434\u0430\u0436\u0435 \u0431\u0435\u0437 \u043a\u043e\u043c\u043f\u0440\u043e\u043c\u0438\u0441\u0441\u043e\u0432 \u043f\u043e \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442\u0435\u043b\u044c\u043d\u043e\u0441\u0442\u0438.\r\n\r\n\nAdd precise Decimal division\nRight now, `Decimal` devision (#30341, #38054) can cause some pain. \r\nIt works fine, but with strict limitations -- e.g. we cannot divide Decimals that have scale more than half of max scale (#39600).\r\n\r\nCurrently used division has good speed -- in fact, we just make 1 division (expensive) and multiplication (not so expensive), but precision is poor. \r\n\r\nI suggest adding separate function (smth like `preciseDecimalDiv(a: Decimal, b: Decimal, prcsn: UInt8)` with user-defined result precision) for decimal division (alongside \"usual\" one).\r\nMaybe even we can replace currently existing division by this more precise version, but it will be like 10 times slower (more division operations are to be made), and it may be unacceptable if you don't need high precision.\r\nThat's why I suggest having 2 separate functions. \n",
  "hints_text": "\u042f \u0432\u0438\u0436\u0443 \u044d\u0442\u043e \u043a\u0430\u043a \u043e\u0442\u0434\u0435\u043b\u044c\u043d\u0443\u044e \u0444\u0443\u043d\u043a\u0446\u0438\u044e `scaledMultiply(a, b, result_scale)`. \u0415\u0441\u043b\u0438 \u043c\u044b \u043e\u0431\u0440\u0435\u0437\u0430\u0435\u043c \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c \u043e\u043f\u0435\u0440\u0430\u0446\u0438\u0438, \u0441\u0442\u043e\u0438\u0442 \u0437\u0430\u0434\u0430\u0432\u0430\u0442\u044c \u0435\u0435 \u044f\u0432\u043d\u043e. \u0424\u0443\u043d\u043a\u0446\u0438\u044f \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0442\u044c 2 \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430, \u0442\u043e\u0433\u0434\u0430 result_scale \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442\u0441\u044f scale-\u043e\u043c \u043f\u0435\u0440\u0432\u043e\u0433\u043e \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u0430.\n\u041c\u043d\u0435 \u043a\u0430\u0436\u0435\u0442\u0441\u044f \u0447\u0442\u043e \u0441\u043a\u043e\u0440\u0435\u0435 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0441 \u043e\u0433\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435\u043c \u0434\u043e\u043b\u0436\u0435\u043d \u0431\u044b\u0442\u044c \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0430 \u0432\u0430\u0440\u0438\u0430\u043d\u0442 \u0443\u0432\u0435\u043b\u0438\u0447\u0438\u0432\u0430\u044e\u0449\u0438\u0439 \u043a\u043e\u043b-\u0432\u043e \u0437\u043d\u0430\u043a\u043e\u0432 \u043f\u043e\u0441\u043b\u0435 \u0437\u0430\u043f\u044f\u0442\u043e\u0439 \u043a\u0430\u043a-\u0442\u043e \u0442\u0438\u043f\u0430 accurateMultiply( ... ). \u041d\u043e \u043d\u0430\u0432\u0435\u0440\u043d\u043e\u0435 \u043c\u043e\u0436\u043d\u043e \u0438 \u043d\u0430\u043e\u0431\u043e\u0440\u043e\u0442. \r\n\r\n\u041d\u0430\u0434\u043e \u043f\u0435\u0440\u0435\u043f\u0440\u043e\u0432\u0435\u0440\u0438\u0442\u044c \u043a\u0430\u043a \u044d\u0442\u043e \u0432\u044b\u0433\u043b\u044f\u0434\u0438\u0442 \u0432 \u0434\u0440\u0443\u0433\u0438\u0445 \u0431\u0430\u0437\u0430\u0445, \u0438 \u0432 \u0447\u0430\u0441\u0442\u043d\u043e\u0441\u0442\u0438 \u043a\u0430\u043a\u043e\u0435 \u0438\u043c\u0435\u043d\u043d\u043e \u043e\u0433\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u0435 \u0442\u0430\u043c \u043e\u0431\u044b\u0447\u043d\u043e \u043f\u0440\u0438\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f (\u0442\u0438\u043f\u0438\u0447\u043d\u044b\u0439 usecase \u0434\u043b\u044f Decimal  - \u0445\u0440\u0430\u043d\u0435\u043d\u0438\u0435 \u0434\u0435\u043d\u0435\u0433, \u0442\u0430\u043c \u0441 \u043e\u043a\u0440\u0443\u0433\u043b\u0435\u043d\u0438\u044f\u043c\u0438 \u043d\u0430\u0434\u043e \u043e\u0441\u0442\u043e\u0440\u043e\u0436\u043d\u043e).\n\u041f\u0440\u0438\u0432\u0435\u0442.  \u0415\u0441\u0442\u044c \u043b\u0438 \u043f\u0440\u043e\u0433\u0440\u0435\u0441\u0441 \u0432 \u043f\u0435\u0440\u0435\u043c\u043d\u043e\u0436\u0435\u043d\u0438\u0438 Decimal? \nHello, can someone give a status update regarding this? Is this being considered?\r\nWe need this for all of our multiplications.\nRelated: https://github.com/ClickHouse/ClickHouse/issues/40573\n> but it will be like 10 times slower (more division operations are to be made)\r\n\r\nShould it be?\r\n\r\nSQL Server: \r\n\r\nhttps://docs.microsoft.com/en-us/previous-versions/sql/sql-server-2005/ms190476(v=sql.90)?redirectedfrom=MSDN \r\nhttps://www.sqlservercentral.com/forums/topic/decimal-truncation-in-division\r\n\r\nPython\r\nhttps://www.digitalocean.com/community/tutorials/python-decimal-division-round-precision\r\n\r\n\r\nhttp://sqlfiddle.com/#!9/3d854a/1\r\nhttp://sqlfiddle.com/#!18/57020a/1\n@filimonov \r\nDecimal division with controlled scale implicitly involves multple divisions (see \"Controllling Precision for single operation\" in [link you provided](https://www.digitalocean.com/community/tutorials/python-decimal-division-round-precision)). We can't get required precision operation w/o either using multiple division operands or moving to wider data types (e.g. Int128 -> Int256, which itself can be pain)\nCurrently working on this and #8049",
  "created_at": "2022-10-18T12:40:44Z"
}