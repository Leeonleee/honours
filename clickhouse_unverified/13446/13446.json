{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13446,
  "instance_id": "ClickHouse__ClickHouse-13446",
  "issue_numbers": [
    "13335"
  ],
  "base_commit": "7786fd411977adf50ae11657627f0377a17207d4",
  "patch": "diff --git a/base/common/StringRef.h b/base/common/StringRef.h\nindex df659f501230..2247f0de2ed5 100644\n--- a/base/common/StringRef.h\n+++ b/base/common/StringRef.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <cassert>\n #include <string>\n #include <vector>\n #include <functional>\n@@ -27,7 +28,11 @@ struct StringRef\n     size_t size = 0;\n \n     template <typename CharT, typename = std::enable_if_t<sizeof(CharT) == 1>>\n-    constexpr StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_) {}\n+    constexpr StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_)\n+    {\n+        /// Sanity check for overflowed values.\n+        assert(size < 0x8000000000000000ULL);\n+    }\n \n     StringRef(const std::string & s) : data(s.data()), size(s.size()) {}\n     constexpr explicit StringRef(const std::string_view & s) : data(s.data()), size(s.size()) {}\ndiff --git a/src/Functions/URL/netloc.cpp b/src/Functions/URL/netloc.cpp\nindex d8858c3364a2..cb28083f4c7f 100644\n--- a/src/Functions/URL/netloc.cpp\n+++ b/src/Functions/URL/netloc.cpp\n@@ -1,10 +1,134 @@\n+#include <Common/StringUtils/StringUtils.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionStringToString.h>\n-#include \"netloc.h\"\n+#include <Functions/URL/FunctionsURL.h>\n+\n \n namespace DB\n {\n \n+struct ExtractNetloc\n+{\n+    /// We use the same as domain function\n+    static size_t getReserveLengthForElement() { return 15; }\n+\n+    static inline StringRef getNetworkLocation(const char * data, size_t size)\n+    {\n+        Pos pos = data;\n+        Pos end = data + size;\n+\n+        /// Skip scheme.\n+        if (pos + 2 < end && pos[0] == '/' && pos[1] == '/')\n+        {\n+            pos += 2;\n+        }\n+        else\n+        {\n+            Pos scheme_end = data + std::min(size, 16UL);\n+            for (++pos; pos < scheme_end; ++pos)\n+            {\n+                if (!isAlphaNumericASCII(*pos))\n+                {\n+                    switch (*pos)\n+                    {\n+                        case '.':\n+                        case '-':\n+                        case '+':\n+                            break;\n+                        case ' ': /// restricted symbols\n+                        case '\\t':\n+                        case '<':\n+                        case '>':\n+                        case '%':\n+                        case '{':\n+                        case '}':\n+                        case '|':\n+                        case '\\\\':\n+                        case '^':\n+                        case '~':\n+                        case '[':\n+                        case ']':\n+                        case ';':\n+                        case '=':\n+                        case '&':\n+                            return StringRef{};\n+                        default:\n+                            goto exloop;\n+                    }\n+                }\n+            }\n+            exloop:\n+            if (pos + 2 < scheme_end && pos[0] == ':' && pos[1] == '/' && pos[2] == '/')\n+                pos += 3;\n+            else\n+                pos = data;\n+        }\n+\n+        /// Now pos points to the first byte after scheme (if there is).\n+\n+        bool has_identification = false;\n+        Pos question_mark_pos = end;\n+        Pos slash_pos = end;\n+        Pos start_of_host = pos;\n+        for (; pos < end; ++pos)\n+        {\n+            switch (*pos)\n+            {\n+                case '/':\n+                    if (has_identification)\n+                        return StringRef(start_of_host, pos - start_of_host);\n+                    else\n+                        slash_pos = pos;\n+                    break;\n+                case '?':\n+                    if (has_identification)\n+                        return StringRef(start_of_host, pos - start_of_host);\n+                    else\n+                        question_mark_pos = pos;\n+                    break;\n+                case '#':\n+                    return StringRef(start_of_host, pos - start_of_host);\n+                case '@': /// foo:bar@example.ru\n+                    has_identification = true;\n+                    break;\n+                case ' ': /// restricted symbols in whole URL\n+                case '\\t':\n+                case '<':\n+                case '>':\n+                case '%':\n+                case '{':\n+                case '}':\n+                case '|':\n+                case '\\\\':\n+                case '^':\n+                case '~':\n+                case '[':\n+                case ']':\n+                case ';':\n+                case '=':\n+                case '&':\n+                    return pos > start_of_host\n+                        ? StringRef(start_of_host, std::min(std::min(pos - 1, question_mark_pos), slash_pos) - start_of_host)\n+                        : StringRef{};\n+            }\n+        }\n+\n+        if (has_identification)\n+            return StringRef(start_of_host, pos - start_of_host);\n+        else\n+            return StringRef(start_of_host, std::min(std::min(pos, question_mark_pos), slash_pos) - start_of_host);\n+    }\n+\n+    static void execute(Pos data, size_t size, Pos & res_data, size_t & res_size)\n+    {\n+        StringRef host = getNetworkLocation(data, size);\n+\n+        res_data = host.data;\n+        res_size = host.size;\n+    }\n+};\n+\n+\n struct NameNetloc { static constexpr auto name = \"netloc\"; };\n using FunctionNetloc = FunctionStringToString<ExtractSubstringImpl<ExtractNetloc>, NameNetloc>;\n \ndiff --git a/src/Functions/URL/netloc.h b/src/Functions/URL/netloc.h\ndeleted file mode 100644\nindex 443ef7f9003e..000000000000\n--- a/src/Functions/URL/netloc.h\n+++ /dev/null\n@@ -1,129 +0,0 @@\n-#pragma once\n-\n-#include \"FunctionsURL.h\"\n-#include <common/find_symbols.h>\n-#include \"protocol.h\"\n-#include <cstring>\n-#include <Common/StringUtils/StringUtils.h>\n-\n-\n-namespace DB\n-{\n-\n-struct ExtractNetloc\n-{\n-    /// We use the same as domain function\n-    static size_t getReserveLengthForElement() { return 15; }\n-\n-    static inline StringRef getNetworkLocation(const char * data, size_t size)\n-    {\n-        Pos pos = data;\n-        Pos end = data + size;\n-\n-        if (*pos == '/' && *(pos + 1) == '/')\n-        {\n-            pos += 2;\n-        }\n-        else\n-        {\n-            Pos scheme_end = data + std::min(size, 16UL);\n-            for (++pos; pos < scheme_end; ++pos)\n-            {\n-                if (!isAlphaNumericASCII(*pos))\n-                {\n-                    switch (*pos)\n-                    {\n-                        case '.':\n-                        case '-':\n-                        case '+':\n-                            break;\n-                        case ' ': /// restricted symbols\n-                        case '\\t':\n-                        case '<':\n-                        case '>':\n-                        case '%':\n-                        case '{':\n-                        case '}':\n-                        case '|':\n-                        case '\\\\':\n-                        case '^':\n-                        case '~':\n-                        case '[':\n-                        case ']':\n-                        case ';':\n-                        case '=':\n-                        case '&':\n-                            return StringRef{};\n-                        default:\n-                            goto exloop;\n-                    }\n-                }\n-            }\n-exloop: if ((scheme_end - pos) > 2 && *pos == ':' && *(pos + 1) == '/' && *(pos + 2) == '/')\n-            pos += 3;\n-        else\n-            pos = data;\n-        }\n-\n-        bool has_identification = false;\n-        Pos question_mark_pos = end;\n-        Pos slash_pos = end;\n-        auto start_of_host = pos;\n-        for (; pos < end; ++pos)\n-        {\n-            switch (*pos)\n-            {\n-                case '/':\n-                    if (has_identification)\n-                        return StringRef(start_of_host, pos - start_of_host);\n-                    else\n-                        slash_pos = pos;\n-                    break;\n-                case '?':\n-                    if (has_identification)\n-                        return StringRef(start_of_host, pos - start_of_host);\n-                    else\n-                        question_mark_pos = pos;\n-                    break;\n-                case '#':\n-                    return StringRef(start_of_host, pos - start_of_host);\n-                case '@': /// foo:bar@example.ru\n-                    has_identification = true;\n-                    break;\n-                case ' ': /// restricted symbols in whole URL\n-                case '\\t':\n-                case '<':\n-                case '>':\n-                case '%':\n-                case '{':\n-                case '}':\n-                case '|':\n-                case '\\\\':\n-                case '^':\n-                case '~':\n-                case '[':\n-                case ']':\n-                case ';':\n-                case '=':\n-                case '&':\n-                    return StringRef(start_of_host, std::min(std::min(pos - 1, question_mark_pos), slash_pos) - start_of_host);\n-            }\n-        }\n-\n-        if (has_identification)\n-            return StringRef(start_of_host, pos - start_of_host);\n-        else\n-            return StringRef(start_of_host, std::min(std::min(pos, question_mark_pos), slash_pos) - start_of_host);\n-    }\n-\n-    static void execute(Pos data, size_t size, Pos & res_data, size_t & res_size)\n-    {\n-        StringRef host = getNetworkLocation(data, size);\n-\n-        res_data = host.data;\n-        res_size = host.size;\n-    }\n-};\n-\n-}\n-\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01434_netloc_fuzz.reference b/tests/queries/0_stateless/01434_netloc_fuzz.reference\nnew file mode 100644\nindex 000000000000..8b137891791f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01434_netloc_fuzz.reference\n@@ -0,0 +1,1 @@\n+\ndiff --git a/tests/queries/0_stateless/01434_netloc_fuzz.sql b/tests/queries/0_stateless/01434_netloc_fuzz.sql\nnew file mode 100644\nindex 000000000000..a409add313f0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01434_netloc_fuzz.sql\n@@ -0,0 +1,1 @@\n+SELECT netloc('<\\'[%UzO');\n",
  "problem_statement": "netloc: std::length_error\nFound by `sql-fuzzy` test:\r\n\r\n```\r\nSELECT netloc('<\\'[%UzO'); \r\n\r\n\r\n\r\n2020.08.03 22:00:49.106572 [ 27424 ] {e3706a47-572b-4e9b-a5f7-2707a822520e} <Error> executeQuery: std::exception. Code: 1001, type: std::length_error, e.what() = basic_string (version 20.7.1.4266) (from [::1]:58798) (in query: SELECT netloc('<\\'[%UzO'); ), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/exception:129: std::exception::capture() @ 0x17a5a258 in /usr/bin/clickhouse\r\n1. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/exception:109: std::exception::exception() @ 0x17a5a225 in /usr/bin/clickhouse\r\n2. /build/obj-x86_64-linux-gnu/../contrib/libcxx/src/support/runtime/stdexcept_default.ipp:24: std::logic_error::logic_error(char const*) @ 0x251f01a0 in /usr/bin/clickhouse\r\n3. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/stdexcept:153: std::length_error::length_error(char const*) @ 0x17a32137 in /usr/bin/clickhouse\r\n4. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/stdexcept:251: std::__1::__throw_length_error(char const*) @ 0x17a320c9 in /usr/bin/clickhouse\r\n5. ? @ 0x17a31d9b in /usr/bin/clickhouse\r\n6. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/string:1783: std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::__init(char const*, unsigned long) @ 0x17a34445 in /usr/bin/clickhouse\r\n7. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/string:1822: std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >::basic_string(char const*, unsigned long) @ 0x17a6e69c in /usr/bin/clickhouse\r\n8. /build/obj-x86_64-linux-gnu/../src/Core/Field.h:643: std::__1::enable_if<(sizeof (char8_t)) == (1), void>::type DB::Field::create<char8_t>(char8_t const*, unsigned long) @ 0x1f4f033f in /usr/bin/clickhouse\r\n9. /build/obj-x86_64-linux-gnu/../src/Core/Field.h:312: DB::Field::Field<char8_t>(char8_t const*, unsigned long) @ 0x1f4f0305 in /usr/bin/clickhouse\r\n10. /build/obj-x86_64-linux-gnu/../src/Columns/ColumnString.h:83: DB::ColumnString::operator[](unsigned long) const @ 0x1f52018f in /usr/bin/clickhouse\r\n11. /build/obj-x86_64-linux-gnu/../src/Columns/ColumnConst.h:246: DB::ColumnConst::getField() const @ 0x18a30099 in /usr/bin/clickhouse\r\n12. /build/obj-x86_64-linux-gnu/../src/Core/Block.cpp:502: bool DB::checkBlockStructure<bool>(DB::Block const&, DB::Block const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&) @ 0x1e798776 in /usr/bin/clickhouse\r\n13. /build/obj-x86_64-linux-gnu/../src/Core/Block.cpp:517: DB::blocksHaveEqualStructure(DB::Block const&, DB::Block const&) @ 0x1e797ca1 in /usr/bin/clickhouse\r\n14. /build/obj-x86_64-linux-gnu/../src/Processors/QueryPlan/QueryPlan.cpp:118: DB::QueryPlan::addStep(std::__1::unique_ptr<DB::IQueryPlanStep, std::__1::default_delete<DB::IQueryPlanStep> >) @ 0x2015d727 in /usr/bin/clickhouse\r\n15. /build/obj-x86_64-linux-gnu/../src/Interpreters/InterpreterSelectQuery.cpp:1641: DB::InterpreterSelectQuery::executeProjection(DB::QueryPlan&, std::__1::shared_ptr<DB::ExpressionActions> const&) @ 0x1effe7df in /usr/bin/clickhouse\r\n16. /build/obj-x86_64-linux-gnu/../src/Interpreters/InterpreterSelectQuery.cpp:1012: DB::InterpreterSelectQuery::executeImpl(DB::QueryPlan&, std::__1::shared_ptr<DB::IBlockInputStream> const&, std::__1::optional<DB::Pipe>) @ 0x1eff6485 in /usr/bin/clickhouse\r\n17. /build/obj-x86_64-linux-gnu/../src/Interpreters/InterpreterSelectQuery.cpp:472: DB::InterpreterSelectQuery::buildQueryPlan(DB::QueryPlan&) @ 0x1eff3d96 in /usr/bin/clickhouse\r\n18. /build/obj-x86_64-linux-gnu/../src/Interpreters/InterpreterSelectWithUnionQuery.cpp:183: DB::InterpreterSelectWithUnionQuery::buildQueryPlan(DB::QueryPlan&) @ 0x1f2c0ab8 in /usr/bin/clickhouse\r\n19. /build/obj-x86_64-linux-gnu/../src/Interpreters/InterpreterSelectWithUnionQuery.cpp:206: DB::InterpreterSelectWithUnionQuery::execute() @ 0x1f2c0d86 in /usr/bin/clickhouse\r\n20. /build/obj-x86_64-linux-gnu/../src/Interpreters/executeQuery.cpp:386: DB::executeQueryImpl(char const*, char const*, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, DB::ReadBuffer*) @ 0x1f47ccd7 in /usr/bin/clickhouse\r\n21. /build/obj-x86_64-linux-gnu/../src/Interpreters/executeQuery.cpp:655: DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) @ 0x1f47bcca in /usr/bin/clickhouse\r\n22. /build/obj-x86_64-linux-gnu/../src/Server/TCPHandler.cpp:253: DB::TCPHandler::runImpl() @ 0x1fd69bd6 in /usr/bin/clickhouse\r\n23. /build/obj-x86_64-linux-gnu/../src/Server/TCPHandler.cpp:1213: DB::TCPHandler::run() @ 0x1fd71068 in /usr/bin/clickhouse\r\n24. /build/obj-x86_64-linux-gnu/../contrib/poco/Net/src/TCPServerConnection.cpp:43: Poco::Net::TCPServerConnection::start() @ 0x23934d7c in /usr/bin/clickhouse\r\n25. /build/obj-x86_64-linux-gnu/../contrib/poco/Net/src/TCPServerDispatcher.cpp:114: Poco::Net::TCPServerDispatcher::run() @ 0x2393558c in /usr/bin/clickhouse\r\n26. /build/obj-x86_64-linux-gnu/../contrib/poco/Foundation/src/ThreadPool.cpp:199: Poco::PooledThread::run() @ 0x23a77393 in /usr/bin/clickhouse\r\n27. /build/obj-x86_64-linux-gnu/../contrib/poco/Foundation/src/Thread.cpp:56: Poco::(anonymous namespace)::RunnableHolder::run() @ 0x23a742cd in /usr/bin/clickhouse\r\n28. /build/obj-x86_64-linux-gnu/../contrib/poco/Foundation/src/Thread_POSIX.cpp:345: Poco::ThreadImpl::runnableEntry(void*) @ 0x23a73158 in /usr/bin/clickhouse\r\n29. start_thread @ 0x9669 in /usr/lib/x86_64-linux-gnu/libpthread-2.30.so\r\n30. __clone @ 0x1222b3 in /usr/lib/x86_64-linux-gnu/libc-2.30.so\r\n```\n",
  "hints_text": "Even a simple use case does not work:\r\n\r\n```\r\nSELECT netloc('<');\r\n```",
  "created_at": "2020-08-07T01:05:25Z"
}