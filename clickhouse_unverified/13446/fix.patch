diff --git a/base/common/StringRef.h b/base/common/StringRef.h
index df659f501230..2247f0de2ed5 100644
--- a/base/common/StringRef.h
+++ b/base/common/StringRef.h
@@ -1,5 +1,6 @@
 #pragma once
 
+#include <cassert>
 #include <string>
 #include <vector>
 #include <functional>
@@ -27,7 +28,11 @@ struct StringRef
     size_t size = 0;
 
     template <typename CharT, typename = std::enable_if_t<sizeof(CharT) == 1>>
-    constexpr StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_) {}
+    constexpr StringRef(const CharT * data_, size_t size_) : data(reinterpret_cast<const char *>(data_)), size(size_)
+    {
+        /// Sanity check for overflowed values.
+        assert(size < 0x8000000000000000ULL);
+    }
 
     StringRef(const std::string & s) : data(s.data()), size(s.size()) {}
     constexpr explicit StringRef(const std::string_view & s) : data(s.data()), size(s.size()) {}
diff --git a/src/Functions/URL/netloc.cpp b/src/Functions/URL/netloc.cpp
index d8858c3364a2..cb28083f4c7f 100644
--- a/src/Functions/URL/netloc.cpp
+++ b/src/Functions/URL/netloc.cpp
@@ -1,10 +1,134 @@
+#include <Common/StringUtils/StringUtils.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionStringToString.h>
-#include "netloc.h"
+#include <Functions/URL/FunctionsURL.h>
+
 
 namespace DB
 {
 
+struct ExtractNetloc
+{
+    /// We use the same as domain function
+    static size_t getReserveLengthForElement() { return 15; }
+
+    static inline StringRef getNetworkLocation(const char * data, size_t size)
+    {
+        Pos pos = data;
+        Pos end = data + size;
+
+        /// Skip scheme.
+        if (pos + 2 < end && pos[0] == '/' && pos[1] == '/')
+        {
+            pos += 2;
+        }
+        else
+        {
+            Pos scheme_end = data + std::min(size, 16UL);
+            for (++pos; pos < scheme_end; ++pos)
+            {
+                if (!isAlphaNumericASCII(*pos))
+                {
+                    switch (*pos)
+                    {
+                        case '.':
+                        case '-':
+                        case '+':
+                            break;
+                        case ' ': /// restricted symbols
+                        case '\t':
+                        case '<':
+                        case '>':
+                        case '%':
+                        case '{':
+                        case '}':
+                        case '|':
+                        case '\\':
+                        case '^':
+                        case '~':
+                        case '[':
+                        case ']':
+                        case ';':
+                        case '=':
+                        case '&':
+                            return StringRef{};
+                        default:
+                            goto exloop;
+                    }
+                }
+            }
+            exloop:
+            if (pos + 2 < scheme_end && pos[0] == ':' && pos[1] == '/' && pos[2] == '/')
+                pos += 3;
+            else
+                pos = data;
+        }
+
+        /// Now pos points to the first byte after scheme (if there is).
+
+        bool has_identification = false;
+        Pos question_mark_pos = end;
+        Pos slash_pos = end;
+        Pos start_of_host = pos;
+        for (; pos < end; ++pos)
+        {
+            switch (*pos)
+            {
+                case '/':
+                    if (has_identification)
+                        return StringRef(start_of_host, pos - start_of_host);
+                    else
+                        slash_pos = pos;
+                    break;
+                case '?':
+                    if (has_identification)
+                        return StringRef(start_of_host, pos - start_of_host);
+                    else
+                        question_mark_pos = pos;
+                    break;
+                case '#':
+                    return StringRef(start_of_host, pos - start_of_host);
+                case '@': /// foo:bar@example.ru
+                    has_identification = true;
+                    break;
+                case ' ': /// restricted symbols in whole URL
+                case '\t':
+                case '<':
+                case '>':
+                case '%':
+                case '{':
+                case '}':
+                case '|':
+                case '\\':
+                case '^':
+                case '~':
+                case '[':
+                case ']':
+                case ';':
+                case '=':
+                case '&':
+                    return pos > start_of_host
+                        ? StringRef(start_of_host, std::min(std::min(pos - 1, question_mark_pos), slash_pos) - start_of_host)
+                        : StringRef{};
+            }
+        }
+
+        if (has_identification)
+            return StringRef(start_of_host, pos - start_of_host);
+        else
+            return StringRef(start_of_host, std::min(std::min(pos, question_mark_pos), slash_pos) - start_of_host);
+    }
+
+    static void execute(Pos data, size_t size, Pos & res_data, size_t & res_size)
+    {
+        StringRef host = getNetworkLocation(data, size);
+
+        res_data = host.data;
+        res_size = host.size;
+    }
+};
+
+
 struct NameNetloc { static constexpr auto name = "netloc"; };
 using FunctionNetloc = FunctionStringToString<ExtractSubstringImpl<ExtractNetloc>, NameNetloc>;
 
diff --git a/src/Functions/URL/netloc.h b/src/Functions/URL/netloc.h
deleted file mode 100644
index 443ef7f9003e..000000000000
--- a/src/Functions/URL/netloc.h
+++ /dev/null
@@ -1,129 +0,0 @@
-#pragma once
-
-#include "FunctionsURL.h"
-#include <common/find_symbols.h>
-#include "protocol.h"
-#include <cstring>
-#include <Common/StringUtils/StringUtils.h>
-
-
-namespace DB
-{
-
-struct ExtractNetloc
-{
-    /// We use the same as domain function
-    static size_t getReserveLengthForElement() { return 15; }
-
-    static inline StringRef getNetworkLocation(const char * data, size_t size)
-    {
-        Pos pos = data;
-        Pos end = data + size;
-
-        if (*pos == '/' && *(pos + 1) == '/')
-        {
-            pos += 2;
-        }
-        else
-        {
-            Pos scheme_end = data + std::min(size, 16UL);
-            for (++pos; pos < scheme_end; ++pos)
-            {
-                if (!isAlphaNumericASCII(*pos))
-                {
-                    switch (*pos)
-                    {
-                        case '.':
-                        case '-':
-                        case '+':
-                            break;
-                        case ' ': /// restricted symbols
-                        case '\t':
-                        case '<':
-                        case '>':
-                        case '%':
-                        case '{':
-                        case '}':
-                        case '|':
-                        case '\\':
-                        case '^':
-                        case '~':
-                        case '[':
-                        case ']':
-                        case ';':
-                        case '=':
-                        case '&':
-                            return StringRef{};
-                        default:
-                            goto exloop;
-                    }
-                }
-            }
-exloop: if ((scheme_end - pos) > 2 && *pos == ':' && *(pos + 1) == '/' && *(pos + 2) == '/')
-            pos += 3;
-        else
-            pos = data;
-        }
-
-        bool has_identification = false;
-        Pos question_mark_pos = end;
-        Pos slash_pos = end;
-        auto start_of_host = pos;
-        for (; pos < end; ++pos)
-        {
-            switch (*pos)
-            {
-                case '/':
-                    if (has_identification)
-                        return StringRef(start_of_host, pos - start_of_host);
-                    else
-                        slash_pos = pos;
-                    break;
-                case '?':
-                    if (has_identification)
-                        return StringRef(start_of_host, pos - start_of_host);
-                    else
-                        question_mark_pos = pos;
-                    break;
-                case '#':
-                    return StringRef(start_of_host, pos - start_of_host);
-                case '@': /// foo:bar@example.ru
-                    has_identification = true;
-                    break;
-                case ' ': /// restricted symbols in whole URL
-                case '\t':
-                case '<':
-                case '>':
-                case '%':
-                case '{':
-                case '}':
-                case '|':
-                case '\\':
-                case '^':
-                case '~':
-                case '[':
-                case ']':
-                case ';':
-                case '=':
-                case '&':
-                    return StringRef(start_of_host, std::min(std::min(pos - 1, question_mark_pos), slash_pos) - start_of_host);
-            }
-        }
-
-        if (has_identification)
-            return StringRef(start_of_host, pos - start_of_host);
-        else
-            return StringRef(start_of_host, std::min(std::min(pos, question_mark_pos), slash_pos) - start_of_host);
-    }
-
-    static void execute(Pos data, size_t size, Pos & res_data, size_t & res_size)
-    {
-        StringRef host = getNetworkLocation(data, size);
-
-        res_data = host.data;
-        res_size = host.size;
-    }
-};
-
-}
-
