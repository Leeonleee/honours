{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52625,
  "instance_id": "ClickHouse__ClickHouse-52625",
  "issue_numbers": [
    "49939"
  ],
  "base_commit": "3f915491f029ef030dc3d4777e5f60a3abf52822",
  "patch": "diff --git a/src/DataTypes/DataTypeArray.cpp b/src/DataTypes/DataTypeArray.cpp\nindex b2c712b2f368..e31f10046b74 100644\n--- a/src/DataTypes/DataTypeArray.cpp\n+++ b/src/DataTypes/DataTypeArray.cpp\n@@ -11,6 +11,7 @@\n #include <Common/assert_cast.h>\n \n #include <Core/NamesAndTypes.h>\n+#include <Columns/ColumnConst.h>\n \n \n namespace DB\n@@ -20,6 +21,7 @@ namespace ErrorCodes\n {\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n+using FieldType = Array;\n \n \n DataTypeArray::DataTypeArray(const DataTypePtr & nested_)\n@@ -33,7 +35,6 @@ MutableColumnPtr DataTypeArray::createColumn() const\n     return ColumnArray::create(nested->createColumn(), ColumnArray::ColumnOffsets::create());\n }\n \n-\n Field DataTypeArray::getDefault() const\n {\n     return Array();\ndiff --git a/src/DataTypes/DataTypeArray.h b/src/DataTypes/DataTypeArray.h\nindex 2714ca1d023d..68b574b8ded8 100644\n--- a/src/DataTypes/DataTypeArray.h\n+++ b/src/DataTypes/DataTypeArray.h\n@@ -2,6 +2,7 @@\n \n #include <DataTypes/IDataType.h>\n #include <DataTypes/Serializations/SerializationArray.h>\n+#include <Columns/ColumnArray.h>\n \n \n namespace DB\n@@ -15,6 +16,8 @@ class DataTypeArray final : public IDataType\n     DataTypePtr nested;\n \n public:\n+    using FieldType = Array;\n+    using ColumnType = ColumnArray;\n     static constexpr bool is_parametric = true;\n \n     explicit DataTypeArray(const DataTypePtr & nested_);\n@@ -42,6 +45,7 @@ class DataTypeArray final : public IDataType\n \n     MutableColumnPtr createColumn() const override;\n \n+\n     Field getDefault() const override;\n \n     bool equals(const IDataType & rhs) const override;\ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex bf3b33d13ffc..723abc7c308c 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -42,6 +42,15 @@\n #include <Common/assert_cast.h>\n #include <Common/typeid_cast.h>\n #include <Common/Arena.h>\n+#include <Core/ColumnWithTypeAndName.h>\n+#include <base/types.h>\n+#include <Columns/ColumnArray.h>\n+#include <Columns/IColumn.h>\n+#include <Core/ColumnsWithTypeAndName.h>\n+#include <DataTypes/IDataType.h>\n+#include <DataTypes/getMostSubtype.h>\n+#include <base/TypeLists.h>\n+#include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <Interpreters/Context.h>\n \n@@ -62,6 +71,7 @@ namespace ErrorCodes\n     extern const int DECIMAL_OVERFLOW;\n     extern const int CANNOT_ADD_DIFFERENT_AGGREGATE_STATES;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int SIZES_OF_ARRAYS_DONT_MATCH;\n }\n \n namespace traits_\n@@ -102,6 +112,9 @@ template <typename DataType> constexpr bool IsFloatingPoint = false;\n template <> inline constexpr bool IsFloatingPoint<DataTypeFloat32> = true;\n template <> inline constexpr bool IsFloatingPoint<DataTypeFloat64> = true;\n \n+template <typename DataType> constexpr bool IsArray = false;\n+template <> inline constexpr bool IsArray<DataTypeArray> = true;\n+\n template <typename DataType> constexpr bool IsDateOrDateTime = false;\n template <> inline constexpr bool IsDateOrDateTime<DataTypeDate> = true;\n template <> inline constexpr bool IsDateOrDateTime<DataTypeDateTime> = true;\n@@ -1125,6 +1138,73 @@ class FunctionBinaryArithmetic : public IFunction\n         return function->execute(arguments, result_type, input_rows_count);\n     }\n \n+    ColumnPtr executeArrayImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const\n+    {\n+        const auto * return_type_array = checkAndGetDataType<DataTypeArray>(result_type.get());\n+\n+        if (!return_type_array)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Return type for function {} must be array.\", getName());\n+\n+        auto num_args = arguments.size();\n+        DataTypes data_types;\n+\n+        ColumnsWithTypeAndName new_arguments {num_args};\n+        DataTypePtr result_array_type;\n+\n+        const auto * left_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n+        const auto * right_const = typeid_cast<const ColumnConst *>(arguments[1].column.get());\n+\n+        /// Unpacking arrays if both are constants.\n+        if (left_const && right_const)\n+        {\n+            new_arguments[0] = {left_const->getDataColumnPtr(), arguments[0].type, arguments[0].name};\n+            new_arguments[1] = {right_const->getDataColumnPtr(), arguments[1].type, arguments[1].name};\n+            auto col = executeImpl(new_arguments, result_type, 1);\n+            return ColumnConst::create(std::move(col), input_rows_count);\n+        }\n+\n+        /// Unpacking arrays if at least one column is constant.\n+        if (left_const || right_const)\n+        {\n+            new_arguments[0] = {arguments[0].column->convertToFullColumnIfConst(), arguments[0].type, arguments[0].name};\n+            new_arguments[1] = {arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};\n+            return executeImpl(new_arguments, result_type, input_rows_count);\n+        }\n+\n+        const auto * left_array_col = typeid_cast<const ColumnArray *>(arguments[0].column.get());\n+        const auto * right_array_col = typeid_cast<const ColumnArray *>(arguments[1].column.get());\n+        const auto & left_offsets = left_array_col->getOffsets();\n+        const auto & right_offsets = right_array_col->getOffsets();\n+\n+        chassert(left_offsets.size() == right_offsets.size() && \"Unexpected difference in number of offsets\");\n+        /// Unpacking non-const arrays and checking sizes of them.\n+        for (auto offset_index = 0U; offset_index < left_offsets.size(); ++offset_index)\n+        {\n+            if (left_offsets[offset_index] != right_offsets[offset_index])\n+            {\n+                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,\n+                \"Cannot apply operation for arrays of different sizes. Size of the first argument: {}, size of the second argument: {}\",\n+                *left_array_col->getOffsets().data(),\n+                *right_array_col ->getOffsets().data());\n+            }\n+        }\n+\n+        const auto & left_array_type = typeid_cast<const DataTypeArray *>(arguments[0].type.get())->getNestedType();\n+        new_arguments[0] = {left_array_col->getDataPtr(), left_array_type, arguments[0].name};\n+\n+        const auto & right_array_type = typeid_cast<const DataTypeArray *>(arguments[1].type.get())->getNestedType();\n+        new_arguments[1] = {right_array_col->getDataPtr(), right_array_type, arguments[1].name};\n+\n+        result_array_type = typeid_cast<const DataTypeArray *>(result_type.get())->getNestedType();\n+\n+        size_t rows_count = 0;\n+        if (!left_offsets.empty())\n+            rows_count = left_offsets.back();\n+        auto res = executeImpl(new_arguments, result_array_type, rows_count);\n+\n+        return ColumnArray::create(res, typeid_cast<const ColumnArray *>(arguments[0].column.get())->getOffsetsPtr());\n+    }\n+\n     ColumnPtr executeTupleNumberOperator(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,\n                                                size_t input_rows_count, const FunctionOverloadResolverPtr & function_builder) const\n     {\n@@ -1326,6 +1406,20 @@ class FunctionBinaryArithmetic : public IFunction\n             return getReturnTypeImplStatic(new_arguments, context);\n         }\n \n+\n+        if constexpr (is_plus || is_minus)\n+        {\n+            if (isArray(arguments[0]) && isArray(arguments[1]))\n+            {\n+                DataTypes new_arguments {\n+                        static_cast<const DataTypeArray &>(*arguments[0]).getNestedType(),\n+                        static_cast<const DataTypeArray &>(*arguments[1]).getNestedType(),\n+                };\n+                return std::make_shared<DataTypeArray>(getReturnTypeImplStatic(new_arguments, context));\n+            }\n+        }\n+\n+\n         /// Special case when the function is plus or minus, one of arguments is Date/DateTime and another is Interval.\n         if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0], arguments[1], context))\n         {\n@@ -2031,6 +2125,9 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n                 return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;\n         });\n \n+        if (isArray(result_type))\n+            return executeArrayImpl(arguments, result_type, input_rows_count);\n+\n         if (!valid)\n         {\n             // This is a logical error, because the types should have been checked\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02812_pointwise_array_operations.reference b/tests/queries/0_stateless/02812_pointwise_array_operations.reference\nnew file mode 100644\nindex 000000000000..3b1b973fd3f4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02812_pointwise_array_operations.reference\n@@ -0,0 +1,23 @@\n+[2,5]\n+[2,6]\n+[4.5,5,12,10.1]\n+[(11.1,5.4),(6,21)]\n+[[13,2],[3]]\n+[2,2]\n+[2,3]\n+[2,4]\n+[2,5]\n+[2,6]\n+[2,2]\n+[2,3]\n+[2,4]\n+[2,5]\n+[2,6]\n+[0,0,0]\n+[(NULL,100000000000000000000),(NULL,1048833)]\n+[2,2]\n+[2,3]\n+[2,4]\n+[2,5]\n+[2,6]\n+[11,1,-2]\ndiff --git a/tests/queries/0_stateless/02812_pointwise_array_operations.sql b/tests/queries/0_stateless/02812_pointwise_array_operations.sql\nnew file mode 100644\nindex 000000000000..e28c4bda347e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02812_pointwise_array_operations.sql\n@@ -0,0 +1,18 @@\n+SELECT (materialize([1,1]) + materialize([1,4]));\n+SELECT ([1,2] + [1,4]);\n+SELECT ([2.5, 1, 3, 10.1] + [2, 4, 9, 0]);\n+SELECT ([(1,3), (2,9)] + [(10.1, 2.4), (4,12)]);\n+SELECT ([[1,1],[2]]+[[12,1],[1]]);\n+SELECT ([1,2]+[1,number]) from numbers(5);\n+SELECT ([1,2::UInt64]+[1,number]) from numbers(5);\n+SELECT ([materialize(1),materialize(2),materialize(3)]-[1,2,3]);\n+SELECT [(NULL, 256), (NULL, 256)] + [(1., 100000000000000000000.), (NULL, 1048577)];\n+SELECT ([1,2::UInt64]+[1,number]) from numbers(5);\n+CREATE TABLE my_table (values Array(Int32)) ENGINE = MergeTree() ORDER BY values;\n+INSERT INTO my_table (values) VALUES ([12, 3, 1]);\n+SELECT values - [1,2,3] FROM my_table WHERE arrayExists(x -> x > 5, values);\n+SELECT ([12,13] % [5,6]); -- { serverError 43 }\n+SELECT ([2,3,4]-[1,-2,10,29]); -- { serverError 190 }\n+CREATE TABLE a ( x Array(UInt64), y Array(UInt64)) ENGINE = Memory;\n+INSERT INTO a VALUES ([2,3],[4,5]),([1,2,3], [4,5]),([6,7],[8,9,10]);\n+SELECT x, y, x+y FROM a; -- { serverError 190 }\n",
  "problem_statement": "Support pointwise operations on arrays\nCurrently to do pointwise operations on arrays we have to use ArrayMap. This is unnecessarily verbose e.g.\r\n\r\n```\r\nSELECT url, caption, \r\nL2Distance(array_column, \r\n    arrayMap((x,y) -> x+y,\r\n        arrayMap((x,y) -> x-y, [1,2,3,4], [1,2,3,4]), \r\n        arrayMap((x,y) -> x+y, [5,6,7,4], [1,2,3,4])\r\n    )\r\n) AS score FROM laion_10m ORDER BY score ASC LIMIT 10\r\n```\r\n\r\nPropose that + and - on arrays perform pointwise operations. Currently not supported.\r\n\r\n\r\n```\r\nclickhouse-cloud :) select [1,2]+[3,4]\r\n\r\nSELECT [1, 2] + [3, 4]\r\n\r\nQuery id: dbf44020-0866-4a29-ad58-7a8b8221fa2a\r\n\r\n0 rows in set. Elapsed: 0.220 sec.\r\n\r\nReceived exception from server (version 23.3.1):\r\nCode: 43. DB::Exception: Received from cbupclfpbv.us-east-2.aws.clickhouse-staging.com:9440. DB::Exception: Illegal types Array(UInt8) and Array(UInt8) of arguments of function plus: While processing [1, 2] + [3, 4]. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\nUsecase is ClickHouse for vector operations.\n",
  "hints_text": "I think '+' and '-' on array is a little ambiguous. Better to have explicits function like `arrayAdd(numeric_arr, arg)` and `arraySubtract(numeric_arr, arg)` where `arg` can be a scalar or an array of numeric type with same length.\nThere are the following caveats:\r\n\r\n1. `+` on arrays can be confused with concatenation.\r\n\r\nBut we have a dedicated operator for concatenation: `||` that applies to strings and arrays. It is ANSI SQL standard.\r\nAlthough MS SQL Server uses `+` for concatenation. \r\n\r\nMany scripting languages use `+` for array concatenation. Update: I tried to check this statement, and failed multiple times:\r\n```\r\n$ node -e 'console.log([1, 2, 3] + [4, 5])'\r\n1,2,34,5\r\n```\r\nWAT?\r\n\r\n```\r\n$ perl -e 'print [1, 2, 3] + [4, 5]'\r\n187896031848960\r\n```\r\nWTF??\r\n\r\n```\r\n$ php -r 'print_r([1, 2, 3] + [4, 5]);'\r\nArray\r\n(\r\n    [0] => 1\r\n    [1] => 2\r\n    [2] => 3\r\n)\r\n```\r\nShit.\r\n\r\n```\r\n$ python -c 'print([1, 2, 3] + [4, 5])'\r\n[1, 2, 3, 4, 5]\r\n```\r\n:+1: \n2. If you overload `+` and `-` for arrays, the users might expect that the other arithmetic operations, like `*`, `/` also have meaning for arrays. But for multiplication, it's unclear - should it be pointwise multiplication (that does not have obvious geometric sense), or scalar product (that differs in the return type from `+` and `-`), or only apply to vector and scalar (at least it makes sense).\nLet's overload `+` and `-` for arrays. It is easy to implement, improves usability, and does not introduce much confusion.",
  "created_at": "2023-07-26T15:04:42Z",
  "modified_files": [
    "src/DataTypes/DataTypeArray.cpp",
    "src/DataTypes/DataTypeArray.h",
    "src/Functions/FunctionBinaryArithmetic.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02812_pointwise_array_operations.reference",
    "b/tests/queries/0_stateless/02812_pointwise_array_operations.sql"
  ]
}