diff --git a/src/DataTypes/DataTypeArray.cpp b/src/DataTypes/DataTypeArray.cpp
index b2c712b2f368..e31f10046b74 100644
--- a/src/DataTypes/DataTypeArray.cpp
+++ b/src/DataTypes/DataTypeArray.cpp
@@ -11,6 +11,7 @@
 #include <Common/assert_cast.h>
 
 #include <Core/NamesAndTypes.h>
+#include <Columns/ColumnConst.h>
 
 
 namespace DB
@@ -20,6 +21,7 @@ namespace ErrorCodes
 {
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
 }
+using FieldType = Array;
 
 
 DataTypeArray::DataTypeArray(const DataTypePtr & nested_)
@@ -33,7 +35,6 @@ MutableColumnPtr DataTypeArray::createColumn() const
     return ColumnArray::create(nested->createColumn(), ColumnArray::ColumnOffsets::create());
 }
 
-
 Field DataTypeArray::getDefault() const
 {
     return Array();
diff --git a/src/DataTypes/DataTypeArray.h b/src/DataTypes/DataTypeArray.h
index 2714ca1d023d..68b574b8ded8 100644
--- a/src/DataTypes/DataTypeArray.h
+++ b/src/DataTypes/DataTypeArray.h
@@ -2,6 +2,7 @@
 
 #include <DataTypes/IDataType.h>
 #include <DataTypes/Serializations/SerializationArray.h>
+#include <Columns/ColumnArray.h>
 
 
 namespace DB
@@ -15,6 +16,8 @@ class DataTypeArray final : public IDataType
     DataTypePtr nested;
 
 public:
+    using FieldType = Array;
+    using ColumnType = ColumnArray;
     static constexpr bool is_parametric = true;
 
     explicit DataTypeArray(const DataTypePtr & nested_);
@@ -42,6 +45,7 @@ class DataTypeArray final : public IDataType
 
     MutableColumnPtr createColumn() const override;
 
+
     Field getDefault() const override;
 
     bool equals(const IDataType & rhs) const override;
diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h
index bf3b33d13ffc..723abc7c308c 100644
--- a/src/Functions/FunctionBinaryArithmetic.h
+++ b/src/Functions/FunctionBinaryArithmetic.h
@@ -42,6 +42,15 @@
 #include <Common/assert_cast.h>
 #include <Common/typeid_cast.h>
 #include <Common/Arena.h>
+#include <Core/ColumnWithTypeAndName.h>
+#include <base/types.h>
+#include <Columns/ColumnArray.h>
+#include <Columns/IColumn.h>
+#include <Core/ColumnsWithTypeAndName.h>
+#include <DataTypes/IDataType.h>
+#include <DataTypes/getMostSubtype.h>
+#include <base/TypeLists.h>
+#include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeLowCardinality.h>
 #include <Interpreters/Context.h>
 
@@ -62,6 +71,7 @@ namespace ErrorCodes
     extern const int DECIMAL_OVERFLOW;
     extern const int CANNOT_ADD_DIFFERENT_AGGREGATE_STATES;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+    extern const int SIZES_OF_ARRAYS_DONT_MATCH;
 }
 
 namespace traits_
@@ -102,6 +112,9 @@ template <typename DataType> constexpr bool IsFloatingPoint = false;
 template <> inline constexpr bool IsFloatingPoint<DataTypeFloat32> = true;
 template <> inline constexpr bool IsFloatingPoint<DataTypeFloat64> = true;
 
+template <typename DataType> constexpr bool IsArray = false;
+template <> inline constexpr bool IsArray<DataTypeArray> = true;
+
 template <typename DataType> constexpr bool IsDateOrDateTime = false;
 template <> inline constexpr bool IsDateOrDateTime<DataTypeDate> = true;
 template <> inline constexpr bool IsDateOrDateTime<DataTypeDateTime> = true;
@@ -1125,6 +1138,73 @@ class FunctionBinaryArithmetic : public IFunction
         return function->execute(arguments, result_type, input_rows_count);
     }
 
+    ColumnPtr executeArrayImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const
+    {
+        const auto * return_type_array = checkAndGetDataType<DataTypeArray>(result_type.get());
+
+        if (!return_type_array)
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Return type for function {} must be array.", getName());
+
+        auto num_args = arguments.size();
+        DataTypes data_types;
+
+        ColumnsWithTypeAndName new_arguments {num_args};
+        DataTypePtr result_array_type;
+
+        const auto * left_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());
+        const auto * right_const = typeid_cast<const ColumnConst *>(arguments[1].column.get());
+
+        /// Unpacking arrays if both are constants.
+        if (left_const && right_const)
+        {
+            new_arguments[0] = {left_const->getDataColumnPtr(), arguments[0].type, arguments[0].name};
+            new_arguments[1] = {right_const->getDataColumnPtr(), arguments[1].type, arguments[1].name};
+            auto col = executeImpl(new_arguments, result_type, 1);
+            return ColumnConst::create(std::move(col), input_rows_count);
+        }
+
+        /// Unpacking arrays if at least one column is constant.
+        if (left_const || right_const)
+        {
+            new_arguments[0] = {arguments[0].column->convertToFullColumnIfConst(), arguments[0].type, arguments[0].name};
+            new_arguments[1] = {arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};
+            return executeImpl(new_arguments, result_type, input_rows_count);
+        }
+
+        const auto * left_array_col = typeid_cast<const ColumnArray *>(arguments[0].column.get());
+        const auto * right_array_col = typeid_cast<const ColumnArray *>(arguments[1].column.get());
+        const auto & left_offsets = left_array_col->getOffsets();
+        const auto & right_offsets = right_array_col->getOffsets();
+
+        chassert(left_offsets.size() == right_offsets.size() && "Unexpected difference in number of offsets");
+        /// Unpacking non-const arrays and checking sizes of them.
+        for (auto offset_index = 0U; offset_index < left_offsets.size(); ++offset_index)
+        {
+            if (left_offsets[offset_index] != right_offsets[offset_index])
+            {
+                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,
+                "Cannot apply operation for arrays of different sizes. Size of the first argument: {}, size of the second argument: {}",
+                *left_array_col->getOffsets().data(),
+                *right_array_col ->getOffsets().data());
+            }
+        }
+
+        const auto & left_array_type = typeid_cast<const DataTypeArray *>(arguments[0].type.get())->getNestedType();
+        new_arguments[0] = {left_array_col->getDataPtr(), left_array_type, arguments[0].name};
+
+        const auto & right_array_type = typeid_cast<const DataTypeArray *>(arguments[1].type.get())->getNestedType();
+        new_arguments[1] = {right_array_col->getDataPtr(), right_array_type, arguments[1].name};
+
+        result_array_type = typeid_cast<const DataTypeArray *>(result_type.get())->getNestedType();
+
+        size_t rows_count = 0;
+        if (!left_offsets.empty())
+            rows_count = left_offsets.back();
+        auto res = executeImpl(new_arguments, result_array_type, rows_count);
+
+        return ColumnArray::create(res, typeid_cast<const ColumnArray *>(arguments[0].column.get())->getOffsetsPtr());
+    }
+
     ColumnPtr executeTupleNumberOperator(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,
                                                size_t input_rows_count, const FunctionOverloadResolverPtr & function_builder) const
     {
@@ -1326,6 +1406,20 @@ class FunctionBinaryArithmetic : public IFunction
             return getReturnTypeImplStatic(new_arguments, context);
         }
 
+
+        if constexpr (is_plus || is_minus)
+        {
+            if (isArray(arguments[0]) && isArray(arguments[1]))
+            {
+                DataTypes new_arguments {
+                        static_cast<const DataTypeArray &>(*arguments[0]).getNestedType(),
+                        static_cast<const DataTypeArray &>(*arguments[1]).getNestedType(),
+                };
+                return std::make_shared<DataTypeArray>(getReturnTypeImplStatic(new_arguments, context));
+            }
+        }
+
+
         /// Special case when the function is plus or minus, one of arguments is Date/DateTime and another is Interval.
         if (auto function_builder = getFunctionForIntervalArithmetic(arguments[0], arguments[1], context))
         {
@@ -2031,6 +2125,9 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A
                 return (res = executeNumeric(arguments, left, right, right_nullmap)) != nullptr;
         });
 
+        if (isArray(result_type))
+            return executeArrayImpl(arguments, result_type, input_rows_count);
+
         if (!valid)
         {
             // This is a logical error, because the types should have been checked
