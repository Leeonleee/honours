{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12018,
  "instance_id": "ClickHouse__ClickHouse-12018",
  "issue_numbers": [
    "11377"
  ],
  "base_commit": "aaadc8addb173a27249ee3ce2161aedf000e4b15",
  "patch": "diff --git a/src/Functions/FunctionDateOrDateTimeAddInterval.h b/src/Functions/FunctionDateOrDateTimeAddInterval.h\nindex d63c4c2db55c..eaed159c17b6 100644\n--- a/src/Functions/FunctionDateOrDateTimeAddInterval.h\n+++ b/src/Functions/FunctionDateOrDateTimeAddInterval.h\n@@ -324,13 +324,16 @@ struct DateTimeAddIntervalImpl\n             const IColumn & delta_column = *block.getByPosition(arguments[1]).column;\n \n             if (const auto * delta_const_column = typeid_cast<const ColumnConst *>(&delta_column))\n-                op.vectorConstant(sources->getData(), col_to->getData(), delta_const_column->getField().get<Int64>(), time_zone);\n+                op.vectorConstant(sources->getData(), col_to->getData(), delta_const_column->getInt(0), time_zone);\n             else\n                 op.vectorVector(sources->getData(), col_to->getData(), delta_column, time_zone);\n         }\n         else if (const auto * sources_const = checkAndGetColumnConst<FromColumnType>(source_col.get()))\n         {\n-            op.constantVector(sources_const->template getValue<FromValueType>(), col_to->getData(), *block.getByPosition(arguments[1]).column, time_zone);\n+            op.constantVector(\n+                sources_const->template getValue<FromValueType>(),\n+                col_to->getData(),\n+                *block.getByPosition(arguments[1]).column, time_zone);\n         }\n         else\n         {\n@@ -390,6 +393,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction\n         {\n             if (!WhichDataType(arguments[0].type).isDateTime()\n                 || !WhichDataType(arguments[2].type).isString())\n+            {\n                 throw Exception(\n                     \"Function \" + getName() + \" supports 2 or 3 arguments. The 1st argument \"\n                     \"must be of type Date or DateTime. The 2nd argument must be number. \"\n@@ -397,6 +401,7 @@ class FunctionDateOrDateTimeAddInterval : public IFunction\n                     \"a constant string with timezone name. The timezone argument is allowed \"\n                     \"only when the 1st argument has the type DateTime\",\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            }\n         }\n \n         switch (arguments[0].type->getTypeId())\n@@ -416,7 +421,8 @@ class FunctionDateOrDateTimeAddInterval : public IFunction\n         }\n     }\n \n-    // Helper templates to deduce return type based on argument type, since some overloads may promote or denote types, e.g. addSeconds(Date, 1) => DateTime\n+    /// Helper templates to deduce return type based on argument type, since some overloads may promote or denote types,\n+    /// e.g. addSeconds(Date, 1) => DateTime\n     template <typename FieldType>\n     using TransformExecuteReturnType = decltype(std::declval<Transform>().execute(FieldType(), 0, std::declval<DateLUTImpl>()));\n \n@@ -463,15 +469,18 @@ class FunctionDateOrDateTimeAddInterval : public IFunction\n \n         if (which.isDate())\n         {\n-            DateTimeAddIntervalImpl<DataTypeDate, TransformResultDataType<DataTypeDate>, Transform>::execute(Transform{}, block, arguments, result);\n+            DateTimeAddIntervalImpl<DataTypeDate, TransformResultDataType<DataTypeDate>, Transform>::execute(\n+                Transform{}, block, arguments, result);\n         }\n         else if (which.isDateTime())\n         {\n-            DateTimeAddIntervalImpl<DataTypeDateTime, TransformResultDataType<DataTypeDateTime>, Transform>::execute(Transform{}, block, arguments, result);\n+            DateTimeAddIntervalImpl<DataTypeDateTime, TransformResultDataType<DataTypeDateTime>, Transform>::execute(\n+                Transform{}, block, arguments, result);\n         }\n         else if (const auto * datetime64_type = assert_cast<const DataTypeDateTime64 *>(from_type))\n         {\n-            DateTimeAddIntervalImpl<DataTypeDateTime64, TransformResultDataType<DataTypeDateTime64>, Transform>::execute(Transform{datetime64_type->getScale()}, block, arguments, result);\n+            DateTimeAddIntervalImpl<DataTypeDateTime64, TransformResultDataType<DataTypeDateTime64>, Transform>::execute(\n+                Transform{datetime64_type->getScale()}, block, arguments, result);\n         }\n         else\n             throw Exception(\"Illegal type \" + block.getByPosition(arguments[0]).type->getName() + \" of first argument of function \" + getName(),\ndiff --git a/src/Functions/FunctionsJSON.h b/src/Functions/FunctionsJSON.h\nindex 7bd69ea770dc..e574149f2e93 100644\n--- a/src/Functions/FunctionsJSON.h\n+++ b/src/Functions/FunctionsJSON.h\n@@ -221,9 +221,9 @@ class FunctionJSON : public IFunction\n                 {\n                     const auto & column_const = assert_cast<const ColumnConst &>(*column.column);\n                     if (isString(column.type))\n-                        moves.emplace_back(MoveType::ConstKey, column_const.getField().get<String>());\n+                        moves.emplace_back(MoveType::ConstKey, column_const.getValue<String>());\n                     else\n-                        moves.emplace_back(MoveType::ConstIndex, column_const.getField().get<Int64>());\n+                        moves.emplace_back(MoveType::ConstIndex, column_const.getInt(0));\n                 }\n                 else\n                 {\ndiff --git a/src/Functions/extractTimeZoneFromFunctionArguments.h b/src/Functions/extractTimeZoneFromFunctionArguments.h\nindex dea740f0ae52..74539939fa0d 100644\n--- a/src/Functions/extractTimeZoneFromFunctionArguments.h\n+++ b/src/Functions/extractTimeZoneFromFunctionArguments.h\n@@ -13,7 +13,10 @@ namespace DB\n class Block;\n \n /// Determine working timezone either from optional argument with time zone name or from time zone in DateTime type of argument.\n-std::string extractTimeZoneNameFromFunctionArguments(const ColumnsWithTypeAndName & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);\n-const DateLUTImpl & extractTimeZoneFromFunctionArguments(Block & block, const ColumnNumbers & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);\n+std::string extractTimeZoneNameFromFunctionArguments(\n+    const ColumnsWithTypeAndName & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);\n+\n+const DateLUTImpl & extractTimeZoneFromFunctionArguments(\n+    Block & block, const ColumnNumbers & arguments, size_t time_zone_arg_num, size_t datetime_arg_num);\n \n }\ndiff --git a/src/Functions/getScalar.cpp b/src/Functions/getScalar.cpp\nindex a6e9d00148ee..ef5e7e050298 100644\n--- a/src/Functions/getScalar.cpp\n+++ b/src/Functions/getScalar.cpp\n@@ -43,7 +43,7 @@ class FunctionGetScalar : public IFunction\n     {\n         if (arguments.size() != 1 || !isString(arguments[0].type) || !arguments[0].column || !isColumnConst(*arguments[0].column))\n             throw Exception(\"Function \" + getName() + \" accepts one const string argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        auto scalar_name = assert_cast<const ColumnConst &>(*arguments[0].column).getField().get<String>();\n+        auto scalar_name = assert_cast<const ColumnConst &>(*arguments[0].column).getValue<String>();\n         scalar = context.getScalar(scalar_name).getByPosition(0);\n         return scalar.type;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01352_add_datetime_bad_get.reference b/tests/queries/0_stateless/01352_add_datetime_bad_get.reference\nnew file mode 100644\nindex 000000000000..73944ca9ab62\n--- /dev/null\n+++ b/tests/queries/0_stateless/01352_add_datetime_bad_get.reference\n@@ -0,0 +1,1 @@\n+2017-12-05 08:07:47\ndiff --git a/tests/queries/0_stateless/01352_add_datetime_bad_get.sql b/tests/queries/0_stateless/01352_add_datetime_bad_get.sql\nnew file mode 100644\nindex 000000000000..31fb2b96b463\n--- /dev/null\n+++ b/tests/queries/0_stateless/01352_add_datetime_bad_get.sql\n@@ -0,0 +1,1 @@\n+SELECT addMonths(materialize(toDateTime('2017-11-05 08:07:47')), 1.);\n",
  "problem_statement": "addMonths: Field::get: assertion failed\n```\r\nSELECT addMonths(materialize(toDateTime('2017-11-05 08:07:47')), 1.)\r\n```\n",
  "hints_text": "",
  "created_at": "2020-06-28T20:24:35Z"
}