{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53046,
  "instance_id": "ClickHouse__ClickHouse-53046",
  "issue_numbers": [
    "52968"
  ],
  "base_commit": "469625488720b16511e1cf70b0acce8fd89732a7",
  "patch": "diff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 9aee61eb8f07..acedede579b4 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -1130,9 +1130,17 @@ JoinPtr SelectQueryExpressionAnalyzer::makeJoin(\n \n     if (auto storage = analyzed_join->getStorageJoin())\n     {\n+        auto joined_block_actions = analyzed_join->createJoinedBlockActions(getContext());\n+        NamesWithAliases required_columns_with_aliases = analyzed_join->getRequiredColumns(\n+            Block(joined_block_actions->getResultColumns()), joined_block_actions->getRequiredColumns().getNames());\n+\n+        Names original_right_column_names;\n+        for (auto & pr : required_columns_with_aliases)\n+            original_right_column_names.push_back(pr.first);\n+\n         auto right_columns = storage->getRightSampleBlock().getColumnsWithTypeAndName();\n         std::tie(left_convert_actions, right_convert_actions) = analyzed_join->createConvertingActions(left_columns, right_columns);\n-        return storage->getJoinLocked(analyzed_join, getContext());\n+        return storage->getJoinLocked(analyzed_join, getContext(), original_right_column_names);\n     }\n \n     joined_plan = buildJoinedPlan(getContext(), join_element, *analyzed_join, query_options);\ndiff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h\nindex 5d14a57759f6..16e641b27180 100644\n--- a/src/Interpreters/TableJoin.h\n+++ b/src/Interpreters/TableJoin.h\n@@ -189,7 +189,6 @@ class TableJoin\n     template <typename LeftNamesAndTypes, typename RightNamesAndTypes>\n     void inferJoinKeyCommonType(const LeftNamesAndTypes & left, const RightNamesAndTypes & right, bool allow_right, bool strict);\n \n-    NamesAndTypesList correctedColumnsAddedByJoin() const;\n \n     void deduplicateAndQualifyColumnNames(const NameSet & left_table_columns, const String & right_table_prefix);\n \n@@ -371,6 +370,8 @@ class TableJoin\n     bool isSpecialStorage() const { return !right_storage_name.empty() || right_storage_join || right_kv_storage; }\n \n     std::shared_ptr<const IKeyValueEntity> getStorageKeyValue() { return right_kv_storage; }\n+\n+    NamesAndTypesList correctedColumnsAddedByJoin() const;\n };\n \n }\ndiff --git a/src/Planner/PlannerJoins.cpp b/src/Planner/PlannerJoins.cpp\nindex e495b0967e99..e87930a4d6bc 100644\n--- a/src/Planner/PlannerJoins.cpp\n+++ b/src/Planner/PlannerJoins.cpp\n@@ -635,6 +635,7 @@ std::shared_ptr<IJoin> chooseJoinAlgorithm(std::shared_ptr<TableJoin> & table_jo\n     /// JOIN with JOIN engine.\n     if (auto storage = table_join->getStorageJoin())\n     {\n+        Names required_column_names;\n         for (const auto & result_column : right_table_expression_header)\n         {\n             const auto * source_column_name = right_table_expression_data.getColumnNameOrNull(result_column.name);\n@@ -644,8 +645,9 @@ std::shared_ptr<IJoin> chooseJoinAlgorithm(std::shared_ptr<TableJoin> & table_jo\n                     fmt::join(storage->getKeyNames(), \", \"), result_column.name);\n \n             table_join->setRename(*source_column_name, result_column.name);\n+            required_column_names.push_back(*source_column_name);\n         }\n-        return storage->getJoinLocked(table_join, planner_context->getQueryContext());\n+        return storage->getJoinLocked(table_join, planner_context->getQueryContext(), required_column_names);\n     }\n \n     /** JOIN with constant.\ndiff --git a/src/Storages/StorageJoin.cpp b/src/Storages/StorageJoin.cpp\nindex 640706aae171..121d859a3f23 100644\n--- a/src/Storages/StorageJoin.cpp\n+++ b/src/Storages/StorageJoin.cpp\n@@ -14,6 +14,7 @@\n #include <Interpreters/castColumn.h>\n #include <Common/quoteString.h>\n #include <Common/Exception.h>\n+#include <Core/ColumnsWithTypeAndName.h>\n #include <Interpreters/JoinUtils.h>\n \n #include <Compression/CompressedWriteBuffer.h>\n@@ -177,7 +178,7 @@ void StorageJoin::mutate(const MutationCommands & commands, ContextPtr context)\n     }\n }\n \n-HashJoinPtr StorageJoin::getJoinLocked(std::shared_ptr<TableJoin> analyzed_join, ContextPtr context) const\n+HashJoinPtr StorageJoin::getJoinLocked(std::shared_ptr<TableJoin> analyzed_join, ContextPtr context, const Names & required_columns_names) const\n {\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n     if (!analyzed_join->sameStrictnessAndKind(strictness, kind))\n@@ -237,8 +238,10 @@ HashJoinPtr StorageJoin::getJoinLocked(std::shared_ptr<TableJoin> analyzed_join,\n     /// Qualifies will be added by join implementation (TableJoin contains a rename mapping).\n     analyzed_join->setRightKeys(key_names);\n     analyzed_join->setLeftKeys(left_key_names_resorted);\n-\n-    HashJoinPtr join_clone = std::make_shared<HashJoin>(analyzed_join, getRightSampleBlock());\n+    Block right_sample_block;\n+    for (const auto & name : required_columns_names)\n+        right_sample_block.insert(getRightSampleBlock().getByName(name));\n+    HashJoinPtr join_clone = std::make_shared<HashJoin>(analyzed_join, right_sample_block);\n \n     RWLockImpl::LockHolder holder = tryLockTimedWithContext(rwlock, RWLockImpl::Read, context);\n     join_clone->setLock(holder);\ndiff --git a/src/Storages/StorageJoin.h b/src/Storages/StorageJoin.h\nindex 5559b5d1ec89..4626d744a380 100644\n--- a/src/Storages/StorageJoin.h\n+++ b/src/Storages/StorageJoin.h\n@@ -49,7 +49,7 @@ class StorageJoin final : public StorageSetOrJoinBase\n \n     /// Return instance of HashJoin holding lock that protects from insertions to StorageJoin.\n     /// HashJoin relies on structure of hash table that's why we need to return it with locked mutex.\n-    HashJoinPtr getJoinLocked(std::shared_ptr<TableJoin> analyzed_join, ContextPtr context) const;\n+    HashJoinPtr getJoinLocked(std::shared_ptr<TableJoin> analyzed_join, ContextPtr context, const Names & required_columns_names) const;\n \n     /// Get result type for function \"joinGet(OrNull)\"\n     DataTypePtr joinGetCheckAndGetReturnType(const DataTypes & data_types, const String & column_name, bool or_null) const;\n",
  "test_patch": "diff --git a/tests/performance/storage_join_direct_join.xml b/tests/performance/storage_join_direct_join.xml\nnew file mode 100644\nindex 000000000000..2fc63c2c9265\n--- /dev/null\n+++ b/tests/performance/storage_join_direct_join.xml\n@@ -0,0 +1,19 @@\n+<test>\n+    <settings>\n+        <max_threads>1</max_threads>\n+    </settings>\n+\n+    <create_query>CREATE TABLE keys (key UInt64) ENGINE = MergeTree ORDER BY key;</create_query>\n+    <create_query>CREATE TABLE dict (key UInt64, value1 UInt64, value2 Float64, value3 String,\n+        value4 String, value5 String, value6 String, value7 String, value8 String, value9 String,\n+        value10 String) ENGINE = Join(ANY, LEFT, key);</create_query>\n+\n+    <fill_query>INSERT INTO keys SELECT rand() FROM numbers(10000000);</fill_query>\n+    <fill_query>INSERT INTO dict SELECT rand(), rand()%1000, rand()*0.0001, toString(number),\n+        toString(number), toString(number), toString(number), toString(number), toString(number),\n+        toString(number), toString(number) FROM numbers(1000000);</fill_query>\n+\n+    <query>SELECT keys.key, value1 FROM keys ANY LEFT JOIN dict AS d ON (keys.key = d.key) FORMAT Null;</query>\n+    <query>SELECT keys.key, value1 FROM keys ANY LEFT JOIN dict AS d ON (keys.key = d.key) FORMAT Null SETTINGS\n+        allow_experimental_analyzer=1</query>\n+</test>\n\\ No newline at end of file\n",
  "problem_statement": "Direct Join has worse performance than joinGet\nThere's two ways to query multiple columns from a storage join:\r\n\r\n- Use multiple `joinGet`, e.g. `SELECT key, joinGet('table_join', 'value1', key), joinGet('table_join',  'value2', key) ... FROM keys`\r\n- Use direct join, .e.g `SELECT key, value1, value2 ... FROM keys LEFT ANY JOIN table_join AS rhs ON key = rhs.key\r\n\r\nTheoretically, the first approach will look up hash table multiple times, so it should have worse performance. Some quick test also show that: https://fiddle.clickhouse.com/f169c0ea-c966-40f8-aefa-cd341734ad9b\r\n\r\n```sql\r\nSELECT key, joinGet('dict', 'value1', key) AS value1, joinGet('dict', 'value2', key) AS value2 FROM keys FORMAT Null SETTINGS send_logs_level='debug';\r\n\r\n<Debug> executeQuery: Read 10000000 rows, 76.29 MiB in 0.246209 sec., 40615899.500018276 rows/sec., 309.87 MiB/sec.\r\n<Debug> MemoryTracker: Peak memory usage (for query): 28.13 MiB.\r\n\r\nSELECT keys.key, value1, value2 FROM keys ANY LEFT JOIN dict AS d ON (keys.key = d.key) FORMAT Null SETTINGS send_logs_level='debug';\r\n\r\n<Debug> executeQuery: Read 10000000 rows, 76.29 MiB in 0.122637 sec., 81541459.75521255 rows/sec., 622.11 MiB/sec.\r\n<Debug> MemoryTracker: Peak memory usage (for query): 31.05 MiB.\r\n```\r\n\r\nBut with real queries on big tables on prod, using direct join is actually worse than `joinGet`. I've tested many times and get the same result, so it's not a env fluctuation.\r\n\r\nAny possible reason can lead to this?\n",
  "hints_text": "@vdimir do you have any idea why?\nHave `direct` join actually been used and haven't felt back to hash? You may try with to force `join_algorithm = 'direct'` or check logs for `HashJoin` lines\n> Have `direct` join actually been used and haven't felt back to hash? You may try with to force `join_algorithm = 'direct'` or check logs for `HashJoin` lines\r\n\r\nIt's using direct join.\r\n\r\nI upload the diff flamegraph here.\r\n\r\nhttps://www.dropbox.com/scl/fi/xjfqhnh3s7p289bdausdu/diff.svg?rlkey=ymnw1g8cowbjut56cr0ipmb9l&dl=0\r\n\r\n\n<img width=\"1193\" alt=\"image\" src=\"https://github.com/ClickHouse/ClickHouse/assets/22796953/b1a8d0a2-6e42-4b75-ae84-d76e775cbc18\">\r\n\n@vdimir I think I found the issue here.. When getting the `HashJoin` object from `StorageJoin`, it will construct the cloned `HashJoin` object with `getRightSampleBlock()`, which basically include every columns in the storage join ~except for the key~.\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/blob/e71f20891f37e0462f6832c440a63ff70495bbd3/src/Storages/StorageJoin.cpp#L241\r\n\r\nSo even if we only select 1 columns in the storage join with direct join, the hash join will try to join all columns, which make the cost of `joinRightColumns` much bigger than `joinGet` if we have many columns in the storage join (yes, it's our case...)\r\n\r\nWill create a fix PR.",
  "created_at": "2023-08-04T11:09:38Z"
}