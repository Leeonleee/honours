{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12664,
  "instance_id": "ClickHouse__ClickHouse-12664",
  "issue_numbers": [
    "12621"
  ],
  "base_commit": "2afd123eda8696d297d39abd77ef58e36a19a2a0",
  "patch": "diff --git a/src/Interpreters/AnyInputOptimize.cpp b/src/Interpreters/AnyInputOptimize.cpp\ndeleted file mode 100644\nindex 1b31ea4024ba..000000000000\n--- a/src/Interpreters/AnyInputOptimize.cpp\n+++ /dev/null\n@@ -1,98 +0,0 @@\n-#include <Common/typeid_cast.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Interpreters/AnyInputOptimize.h>\n-#include <AggregateFunctions/AggregateFunctionFactory.h>\n-#include <IO/WriteHelpers.h>\n-#include <Parsers/ASTTablesInSelectQuery.h>\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int LOGICAL_ERROR;\n-    extern const int ILLEGAL_AGGREGATION;\n-}\n-\n-namespace\n-{\n-    constexpr auto * any = \"any\";\n-    constexpr auto * anyLast = \"anyLast\";\n-}\n-\n-ASTPtr * getExactChild(const ASTPtr & ast, const size_t ind)\n-{\n-    if (ast && ast->as<ASTFunction>()->arguments->children[ind])\n-        return &ast->as<ASTFunction>()->arguments->children[ind];\n-    return nullptr;\n-}\n-\n-///recursive searching of identifiers\n-void changeAllIdentifiers(ASTPtr & ast, size_t ind, const std::string & name)\n-{\n-    ASTPtr * exact_child = getExactChild(ast, ind);\n-    if (!exact_child)\n-        return;\n-\n-    if ((*exact_child)->as<ASTIdentifier>())\n-    {\n-        ///put new any\n-        ASTPtr old_ast = *exact_child;\n-        *exact_child = makeASTFunction(name);\n-        (*exact_child)->as<ASTFunction>()->arguments->children.push_back(old_ast);\n-    }\n-    else if ((*exact_child)->as<ASTFunction>())\n-    {\n-        if (AggregateFunctionFactory::instance().isAggregateFunctionName((*exact_child)->as<ASTFunction>()->name))\n-            throw Exception(\"Aggregate function \" + (*exact_child)->as<ASTFunction>()->name +\n-                \" is found inside aggregate function \" + name + \" in query\", ErrorCodes::ILLEGAL_AGGREGATION);\n-\n-        for (size_t i = 0; i < (*exact_child)->as<ASTFunction>()->arguments->children.size(); i++)\n-            changeAllIdentifiers(*exact_child, i, name);\n-    }\n-}\n-\n-\n-///cut old any, put any to identifiers. any(functions(x)) -> functions(any(x))\n-void AnyInputMatcher::visit(ASTPtr & current_ast, Data data)\n-{\n-    data = {};\n-    if (!current_ast)\n-        return;\n-\n-    auto * function_node = current_ast->as<ASTFunction>();\n-    if (!function_node || function_node->arguments->children.empty())\n-        return;\n-\n-    const auto & function_argument = function_node->arguments->children[0];\n-    if ((function_node->name == any || function_node->name == anyLast)\n-        && function_argument && function_argument->as<ASTFunction>())\n-    {\n-        auto name = function_node->name;\n-        auto alias = function_node->alias;\n-\n-        ///cut any or anyLast\n-        if (!function_argument->as<ASTFunction>()->arguments->children.empty())\n-        {\n-            current_ast = function_argument->clone();\n-            current_ast->setAlias(alias);\n-            for (size_t i = 0; i < current_ast->as<ASTFunction>()->arguments->children.size(); ++i)\n-                changeAllIdentifiers(current_ast, i, name);\n-        }\n-    }\n-}\n-\n-bool AnyInputMatcher::needChildVisit(const ASTPtr & node, const ASTPtr & child)\n-{\n-    if (!child)\n-        throw Exception(\"AST item should not have nullptr in children\", ErrorCodes::LOGICAL_ERROR);\n-\n-    if (node->as<ASTTableExpression>() || node->as<ASTArrayJoin>())\n-        return false; // NOLINT\n-\n-    return true;\n-}\n-\n-}\ndiff --git a/src/Interpreters/AnyInputOptimize.h b/src/Interpreters/AnyInputOptimize.h\ndeleted file mode 100644\nindex 6e782578e351..000000000000\n--- a/src/Interpreters/AnyInputOptimize.h\n+++ /dev/null\n@@ -1,19 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/IAST.h>\n-#include <Interpreters/InDepthNodeVisitor.h>\n-\n-namespace DB\n-{\n-\n-///This optimiser is similar to ArithmeticOperationsInAgrFunc optimizer, but for function any we can extract any functions.\n-class AnyInputMatcher\n-{\n-public:\n-    struct Data {};\n-\n-    static void visit(ASTPtr & ast, Data data);\n-    static bool needChildVisit(const ASTPtr & node, const ASTPtr & child);\n-};\n-using AnyInputVisitor = InDepthNodeVisitor<AnyInputMatcher, true>;\n-}\ndiff --git a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\nindex c67986d97c02..3ee7b59197a7 100644\n--- a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\n+++ b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp\n@@ -153,7 +153,9 @@ void ArithmeticOperationsInAgrFuncMatcher::visit(ASTPtr & ast, Data & data)\n \n bool ArithmeticOperationsInAgrFuncMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)\n {\n-    return !node->as<ASTSubquery>() && !node->as<ASTTableExpression>();\n+    return !node->as<ASTSubquery>() &&\n+        !node->as<ASTTableExpression>() &&\n+        !node->as<ASTArrayJoin>();\n }\n \n }\ndiff --git a/src/Interpreters/RewriteAnyFunctionVisitor.cpp b/src/Interpreters/RewriteAnyFunctionVisitor.cpp\nnew file mode 100644\nindex 000000000000..7d5d204499ed\n--- /dev/null\n+++ b/src/Interpreters/RewriteAnyFunctionVisitor.cpp\n@@ -0,0 +1,96 @@\n+#include <Common/typeid_cast.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTSubquery.h>\n+#include <Interpreters/RewriteAnyFunctionVisitor.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <IO/WriteHelpers.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+bool extractIdentifiers(const ASTFunction & func, std::vector<ASTPtr *> & identifiers)\n+{\n+    for (auto & arg : func.arguments->children)\n+    {\n+        if (const auto * arg_func = arg->as<ASTFunction>())\n+        {\n+            if (arg_func->name == \"lambda\")\n+                return false;\n+\n+            if (AggregateFunctionFactory::instance().isAggregateFunctionName(arg_func->name))\n+                return false;\n+\n+            if (!extractIdentifiers(*arg_func, identifiers))\n+                return false;\n+        }\n+        else if (arg->as<ASTIdentifier>())\n+            identifiers.emplace_back(&arg);\n+    }\n+\n+    return true;\n+}\n+\n+}\n+\n+\n+void RewriteAnyFunctionMatcher::visit(ASTPtr & ast, Data & data)\n+{\n+    if (auto * func = ast->as<ASTFunction>())\n+        visit(*func, ast, data);\n+}\n+\n+void RewriteAnyFunctionMatcher::visit(const ASTFunction & func, ASTPtr & ast, Data & data)\n+{\n+    if (func.arguments->children.empty() || !func.arguments->children[0])\n+        return;\n+\n+    if (func.name != \"any\" && func.name != \"anyLast\")\n+        return;\n+\n+    auto & func_arguments = func.arguments->children;\n+\n+    const auto * first_arg_func = func_arguments[0]->as<ASTFunction>();\n+    if (!first_arg_func || first_arg_func->arguments->children.empty())\n+        return;\n+\n+    /// We have rewritten this function. Just unwrap its argument.\n+    if (data.rewritten.count(ast.get()))\n+    {\n+        func_arguments[0]->setAlias(func.alias);\n+        ast = func_arguments[0];\n+        return;\n+    }\n+\n+    std::vector<ASTPtr *> identifiers;\n+    if (!extractIdentifiers(func, identifiers))\n+        return;\n+\n+    /// Wrap identifiers: any(f(x, y, g(z))) -> any(f(any(x), any(y), g(any(z))))\n+    for (auto * ast_to_change : identifiers)\n+    {\n+        ASTPtr identifier_ast = *ast_to_change;\n+        *ast_to_change = makeASTFunction(func.name);\n+        (*ast_to_change)->as<ASTFunction>()->arguments->children.emplace_back(identifier_ast);\n+    }\n+\n+    data.rewritten.insert(ast.get());\n+\n+    /// Unwrap function: any(f(any(x), any(y), g(any(z)))) -> f(any(x), any(y), g(any(z)))\n+    func_arguments[0]->setAlias(func.alias);\n+    ast = func_arguments[0];\n+}\n+\n+bool RewriteAnyFunctionMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)\n+{\n+    return !node->as<ASTSubquery>() &&\n+        !node->as<ASTTableExpression>() &&\n+        !node->as<ASTArrayJoin>();\n+}\n+\n+}\ndiff --git a/src/Interpreters/RewriteAnyFunctionVisitor.h b/src/Interpreters/RewriteAnyFunctionVisitor.h\nnew file mode 100644\nindex 000000000000..d29af322711d\n--- /dev/null\n+++ b/src/Interpreters/RewriteAnyFunctionVisitor.h\n@@ -0,0 +1,29 @@\n+#pragma once\n+\n+#include <unordered_set>\n+\n+#include <Parsers/IAST.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+\n+namespace DB\n+{\n+\n+class ASTFunction;\n+\n+/// Rewrite 'any' and 'anyLast' functions pushing them inside original function.\n+/// any(f(x, y, g(z))) -> f(any(x), any(y), g(any(z)))\n+class RewriteAnyFunctionMatcher\n+{\n+public:\n+    struct Data\n+    {\n+        std::unordered_set<IAST *> rewritten;\n+    };\n+\n+    static void visit(ASTPtr & ast, Data & data);\n+    static void visit(const ASTFunction &, ASTPtr & ast, Data & data);\n+    static bool needChildVisit(const ASTPtr & node, const ASTPtr & child);\n+};\n+using RewriteAnyFunctionVisitor = InDepthNodeVisitor<RewriteAnyFunctionMatcher, false>;\n+\n+}\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 97922aba3f06..99eaf6e67368 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -8,7 +8,7 @@\n #include <Interpreters/DuplicateOrderByVisitor.h>\n #include <Interpreters/GroupByFunctionKeysVisitor.h>\n #include <Interpreters/AggregateFunctionOfGroupByKeysVisitor.h>\n-#include <Interpreters/AnyInputOptimize.h>\n+#include <Interpreters/RewriteAnyFunctionVisitor.h>\n #include <Interpreters/RemoveInjectiveFunctionsVisitor.h>\n #include <Interpreters/RedundantFunctionsInOrderByVisitor.h>\n #include <Interpreters/MonotonicityCheckVisitor.h>\n@@ -458,11 +458,10 @@ void optimizeAggregationFunctions(ASTPtr & query)\n     ArithmeticOperationsInAgrFuncVisitor(data).visit(query);\n }\n \n-void optimizeAnyInput(ASTPtr & query)\n+void optimizeAnyFunctions(ASTPtr & query)\n {\n-    /// Removing arithmetic operations from functions\n-    AnyInputVisitor::Data data = {};\n-    AnyInputVisitor(data).visit(query);\n+    RewriteAnyFunctionVisitor::Data data = {};\n+    RewriteAnyFunctionVisitor(data).visit(query);\n }\n \n void optimizeInjectiveFunctionsInsideUniq(ASTPtr & query, const Context & context)\n@@ -520,9 +519,9 @@ void TreeOptimizer::apply(ASTPtr & query, Aliases & aliases, const NameSet & sou\n     if (settings.optimize_group_by_function_keys)\n         optimizeGroupByFunctionKeys(select_query);\n \n-    ///Move all operations out of any function\n+    /// Move all operations out of any function\n     if (settings.optimize_move_functions_out_of_any)\n-        optimizeAnyInput(query);\n+        optimizeAnyFunctions(query);\n \n     /// Remove injective functions inside uniq\n     if (settings.optimize_injective_functions_inside_uniq)\ndiff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make\nindex 48be2fae1b9b..c571b857365f 100644\n--- a/src/Interpreters/ya.make\n+++ b/src/Interpreters/ya.make\n@@ -20,7 +20,6 @@ SRCS(\n     addTypeConversionToAST.cpp\n     AggregateDescription.cpp\n     Aggregator.cpp\n-    AnyInputOptimize.cpp\n     ArithmeticOperationsInAgrFuncOptimize.cpp\n     ArithmeticOperationsInAgrFuncOptimize.h\n     ArrayJoinAction.cpp\n@@ -127,6 +126,7 @@ SRCS(\n     ReplaceQueryParameterVisitor.cpp\n     RequiredSourceColumnsData.cpp\n     RequiredSourceColumnsVisitor.cpp\n+    RewriteAnyFunctionVisitor.cpp\n     RowRefs.cpp\n     Set.cpp\n     SetVariants.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01322_any_input_optimize.reference b/tests/queries/0_stateless/01322_any_input_optimize.reference\nindex 209a4afb3a2b..4b6fbfd32c03 100644\n--- a/tests/queries/0_stateless/01322_any_input_optimize.reference\n+++ b/tests/queries/0_stateless/01322_any_input_optimize.reference\n@@ -1,3 +1,30 @@\n-9\n SELECT any(number) + (any(number) * 2)\n-FROM numbers(3, 10)\n+FROM numbers(1, 2)\n+3\n+SELECT anyLast(number) + (anyLast(number) * 2)\n+FROM numbers(1, 2)\n+6\n+WITH any(number) * 3 AS x\n+SELECT x\n+FROM numbers(1, 2)\n+3\n+SELECT \n+    anyLast(number) * 3 AS x,\n+    x\n+FROM numbers(1, 2)\n+6\t6\n+SELECT any(number + (number * 2))\n+FROM numbers(1, 2)\n+3\n+SELECT anyLast(number + (number * 2))\n+FROM numbers(1, 2)\n+6\n+WITH any(number * 3) AS x\n+SELECT x\n+FROM numbers(1, 2)\n+3\n+SELECT \n+    anyLast(number * 3) AS x,\n+    x\n+FROM numbers(1, 2)\n+6\t6\ndiff --git a/tests/queries/0_stateless/01322_any_input_optimize.sql b/tests/queries/0_stateless/01322_any_input_optimize.sql\nindex 65f09d65738d..4b8a55d4c7bc 100644\n--- a/tests/queries/0_stateless/01322_any_input_optimize.sql\n+++ b/tests/queries/0_stateless/01322_any_input_optimize.sql\n@@ -1,4 +1,32 @@\n-SET optimize_move_functions_out_of_any=1;\n-SET enable_debug_queries=1;\n-SELECT any(number + number * 2) FROM  numbers(3, 10);\n-ANALYZE SELECT any(number + number * 2) FROM  numbers(3, 10);\n+SET enable_debug_queries = 1;\n+SET optimize_move_functions_out_of_any = 1;\n+\n+ANALYZE SELECT any(number + number * 2) FROM numbers(1, 2);\n+SELECT any(number + number * 2) FROM numbers(1, 2);\n+\n+ANALYZE SELECT anyLast(number + number * 2) FROM numbers(1, 2);\n+SELECT anyLast(number + number * 2) FROM numbers(1, 2);\n+\n+ANALYZE WITH any(number * 3) AS x SELECT x FROM numbers(1, 2);\n+WITH any(number * 3) AS x SELECT x FROM numbers(1, 2);\n+\n+ANALYZE SELECT anyLast(number * 3) AS x, x FROM numbers(1, 2);\n+SELECT anyLast(number * 3) AS x, x FROM numbers(1, 2);\n+\n+SELECT any(anyLast(number)) FROM numbers(1); -- { serverError 184 }\n+\n+SET optimize_move_functions_out_of_any = 0;\n+\n+ANALYZE SELECT any(number + number * 2) FROM numbers(1, 2);\n+SELECT any(number + number * 2) FROM numbers(1, 2);\n+\n+ANALYZE SELECT anyLast(number + number * 2) FROM numbers(1, 2);\n+SELECT anyLast(number + number * 2) FROM numbers(1, 2);\n+\n+ANALYZE WITH any(number * 3) AS x SELECT x FROM numbers(1, 2);\n+WITH any(number * 3) AS x SELECT x FROM numbers(1, 2);\n+\n+ANALYZE SELECT anyLast(number * 3) AS x, x FROM numbers(1, 2);\n+SELECT anyLast(number * 3) AS x, x FROM numbers(1, 2);\n+\n+SELECT any(anyLast(number)) FROM numbers(1); -- { serverError 184 }\ndiff --git a/tests/queries/0_stateless/01414_optimize_any_bug.reference b/tests/queries/0_stateless/01414_optimize_any_bug.reference\nnew file mode 100644\nindex 000000000000..573541ac9702\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_optimize_any_bug.reference\n@@ -0,0 +1,1 @@\n+0\ndiff --git a/tests/queries/0_stateless/01414_optimize_any_bug.sql b/tests/queries/0_stateless/01414_optimize_any_bug.sql\nnew file mode 100644\nindex 000000000000..6f6f291c504e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01414_optimize_any_bug.sql\n@@ -0,0 +1,18 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test\n+(\n+    `Source.C1` Array(UInt64),\n+    `Source.C2` Array(UInt64)\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+SET optimize_move_functions_out_of_any = 1;\n+\n+SELECT any(arrayFilter((c, d) -> (4 = d), `Source.C1`, `Source.C2`)[1]) AS x\n+FROM test\n+WHERE 0\n+GROUP BY 42;\n+\n+DROP TABLE test;\n",
  "problem_statement": "DB::Exception: lambda argument declarations must be identifiers. \n```\r\n:) CREATE TABLE test\r\n(\r\n    `Source.C1` Array(UInt64),\r\n    `Source.C2` Array(UInt64)\r\n)\r\nENGINE = MergeTree()\r\nORDER BY tuple()\r\n\r\n:) SELECT any(arrayFilter((c, d) -> (4 = d), `Source.C1`, `Source.C2`)[1]) AS x\r\nFROM test\r\nWHERE 0\r\nGROUP BY 42\r\n\r\nCode: 53. DB::Exception: Received from localhost:9000. DB::Exception: lambda argument declarations must be identifiers. \r\n\r\n```\n",
  "hints_text": "It's an error leaded from optimisation. `SET optimize_move_functions_out_of_any = 0` to disable.",
  "created_at": "2020-07-22T12:02:07Z",
  "modified_files": [
    "src/Interpreters/AnyInputOptimize.cpp",
    "src/Interpreters/AnyInputOptimize.h",
    "src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp",
    "b/src/Interpreters/RewriteAnyFunctionVisitor.cpp",
    "b/src/Interpreters/RewriteAnyFunctionVisitor.h",
    "src/Interpreters/TreeOptimizer.cpp",
    "src/Interpreters/ya.make"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01322_any_input_optimize.reference",
    "tests/queries/0_stateless/01322_any_input_optimize.sql",
    "b/tests/queries/0_stateless/01414_optimize_any_bug.reference",
    "b/tests/queries/0_stateless/01414_optimize_any_bug.sql"
  ]
}