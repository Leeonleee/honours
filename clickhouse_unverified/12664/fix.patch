diff --git a/src/Interpreters/AnyInputOptimize.cpp b/src/Interpreters/AnyInputOptimize.cpp
deleted file mode 100644
index 1b31ea4024ba..000000000000
--- a/src/Interpreters/AnyInputOptimize.cpp
+++ /dev/null
@@ -1,98 +0,0 @@
-#include <Common/typeid_cast.h>
-#include <Parsers/ASTLiteral.h>
-#include <Parsers/ASTFunction.h>
-#include <Parsers/ASTIdentifier.h>
-#include <Interpreters/AnyInputOptimize.h>
-#include <AggregateFunctions/AggregateFunctionFactory.h>
-#include <IO/WriteHelpers.h>
-#include <Parsers/ASTTablesInSelectQuery.h>
-
-namespace DB
-{
-
-namespace ErrorCodes
-{
-    extern const int LOGICAL_ERROR;
-    extern const int ILLEGAL_AGGREGATION;
-}
-
-namespace
-{
-    constexpr auto * any = "any";
-    constexpr auto * anyLast = "anyLast";
-}
-
-ASTPtr * getExactChild(const ASTPtr & ast, const size_t ind)
-{
-    if (ast && ast->as<ASTFunction>()->arguments->children[ind])
-        return &ast->as<ASTFunction>()->arguments->children[ind];
-    return nullptr;
-}
-
-///recursive searching of identifiers
-void changeAllIdentifiers(ASTPtr & ast, size_t ind, const std::string & name)
-{
-    ASTPtr * exact_child = getExactChild(ast, ind);
-    if (!exact_child)
-        return;
-
-    if ((*exact_child)->as<ASTIdentifier>())
-    {
-        ///put new any
-        ASTPtr old_ast = *exact_child;
-        *exact_child = makeASTFunction(name);
-        (*exact_child)->as<ASTFunction>()->arguments->children.push_back(old_ast);
-    }
-    else if ((*exact_child)->as<ASTFunction>())
-    {
-        if (AggregateFunctionFactory::instance().isAggregateFunctionName((*exact_child)->as<ASTFunction>()->name))
-            throw Exception("Aggregate function " + (*exact_child)->as<ASTFunction>()->name +
-                " is found inside aggregate function " + name + " in query", ErrorCodes::ILLEGAL_AGGREGATION);
-
-        for (size_t i = 0; i < (*exact_child)->as<ASTFunction>()->arguments->children.size(); i++)
-            changeAllIdentifiers(*exact_child, i, name);
-    }
-}
-
-
-///cut old any, put any to identifiers. any(functions(x)) -> functions(any(x))
-void AnyInputMatcher::visit(ASTPtr & current_ast, Data data)
-{
-    data = {};
-    if (!current_ast)
-        return;
-
-    auto * function_node = current_ast->as<ASTFunction>();
-    if (!function_node || function_node->arguments->children.empty())
-        return;
-
-    const auto & function_argument = function_node->arguments->children[0];
-    if ((function_node->name == any || function_node->name == anyLast)
-        && function_argument && function_argument->as<ASTFunction>())
-    {
-        auto name = function_node->name;
-        auto alias = function_node->alias;
-
-        ///cut any or anyLast
-        if (!function_argument->as<ASTFunction>()->arguments->children.empty())
-        {
-            current_ast = function_argument->clone();
-            current_ast->setAlias(alias);
-            for (size_t i = 0; i < current_ast->as<ASTFunction>()->arguments->children.size(); ++i)
-                changeAllIdentifiers(current_ast, i, name);
-        }
-    }
-}
-
-bool AnyInputMatcher::needChildVisit(const ASTPtr & node, const ASTPtr & child)
-{
-    if (!child)
-        throw Exception("AST item should not have nullptr in children", ErrorCodes::LOGICAL_ERROR);
-
-    if (node->as<ASTTableExpression>() || node->as<ASTArrayJoin>())
-        return false; // NOLINT
-
-    return true;
-}
-
-}
diff --git a/src/Interpreters/AnyInputOptimize.h b/src/Interpreters/AnyInputOptimize.h
deleted file mode 100644
index 6e782578e351..000000000000
--- a/src/Interpreters/AnyInputOptimize.h
+++ /dev/null
@@ -1,19 +0,0 @@
-#pragma once
-
-#include <Parsers/IAST.h>
-#include <Interpreters/InDepthNodeVisitor.h>
-
-namespace DB
-{
-
-///This optimiser is similar to ArithmeticOperationsInAgrFunc optimizer, but for function any we can extract any functions.
-class AnyInputMatcher
-{
-public:
-    struct Data {};
-
-    static void visit(ASTPtr & ast, Data data);
-    static bool needChildVisit(const ASTPtr & node, const ASTPtr & child);
-};
-using AnyInputVisitor = InDepthNodeVisitor<AnyInputMatcher, true>;
-}
diff --git a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
index c67986d97c02..3ee7b59197a7 100644
--- a/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
+++ b/src/Interpreters/ArithmeticOperationsInAgrFuncOptimize.cpp
@@ -153,7 +153,9 @@ void ArithmeticOperationsInAgrFuncMatcher::visit(ASTPtr & ast, Data & data)
 
 bool ArithmeticOperationsInAgrFuncMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)
 {
-    return !node->as<ASTSubquery>() && !node->as<ASTTableExpression>();
+    return !node->as<ASTSubquery>() &&
+        !node->as<ASTTableExpression>() &&
+        !node->as<ASTArrayJoin>();
 }
 
 }
diff --git a/src/Interpreters/RewriteAnyFunctionVisitor.cpp b/src/Interpreters/RewriteAnyFunctionVisitor.cpp
new file mode 100644
index 000000000000..7d5d204499ed
--- /dev/null
+++ b/src/Interpreters/RewriteAnyFunctionVisitor.cpp
@@ -0,0 +1,96 @@
+#include <Common/typeid_cast.h>
+#include <Parsers/ASTLiteral.h>
+#include <Parsers/ASTFunction.h>
+#include <Parsers/ASTIdentifier.h>
+#include <Parsers/ASTSubquery.h>
+#include <Interpreters/RewriteAnyFunctionVisitor.h>
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+#include <IO/WriteHelpers.h>
+#include <Parsers/ASTTablesInSelectQuery.h>
+
+namespace DB
+{
+
+namespace
+{
+
+bool extractIdentifiers(const ASTFunction & func, std::vector<ASTPtr *> & identifiers)
+{
+    for (auto & arg : func.arguments->children)
+    {
+        if (const auto * arg_func = arg->as<ASTFunction>())
+        {
+            if (arg_func->name == "lambda")
+                return false;
+
+            if (AggregateFunctionFactory::instance().isAggregateFunctionName(arg_func->name))
+                return false;
+
+            if (!extractIdentifiers(*arg_func, identifiers))
+                return false;
+        }
+        else if (arg->as<ASTIdentifier>())
+            identifiers.emplace_back(&arg);
+    }
+
+    return true;
+}
+
+}
+
+
+void RewriteAnyFunctionMatcher::visit(ASTPtr & ast, Data & data)
+{
+    if (auto * func = ast->as<ASTFunction>())
+        visit(*func, ast, data);
+}
+
+void RewriteAnyFunctionMatcher::visit(const ASTFunction & func, ASTPtr & ast, Data & data)
+{
+    if (func.arguments->children.empty() || !func.arguments->children[0])
+        return;
+
+    if (func.name != "any" && func.name != "anyLast")
+        return;
+
+    auto & func_arguments = func.arguments->children;
+
+    const auto * first_arg_func = func_arguments[0]->as<ASTFunction>();
+    if (!first_arg_func || first_arg_func->arguments->children.empty())
+        return;
+
+    /// We have rewritten this function. Just unwrap its argument.
+    if (data.rewritten.count(ast.get()))
+    {
+        func_arguments[0]->setAlias(func.alias);
+        ast = func_arguments[0];
+        return;
+    }
+
+    std::vector<ASTPtr *> identifiers;
+    if (!extractIdentifiers(func, identifiers))
+        return;
+
+    /// Wrap identifiers: any(f(x, y, g(z))) -> any(f(any(x), any(y), g(any(z))))
+    for (auto * ast_to_change : identifiers)
+    {
+        ASTPtr identifier_ast = *ast_to_change;
+        *ast_to_change = makeASTFunction(func.name);
+        (*ast_to_change)->as<ASTFunction>()->arguments->children.emplace_back(identifier_ast);
+    }
+
+    data.rewritten.insert(ast.get());
+
+    /// Unwrap function: any(f(any(x), any(y), g(any(z)))) -> f(any(x), any(y), g(any(z)))
+    func_arguments[0]->setAlias(func.alias);
+    ast = func_arguments[0];
+}
+
+bool RewriteAnyFunctionMatcher::needChildVisit(const ASTPtr & node, const ASTPtr &)
+{
+    return !node->as<ASTSubquery>() &&
+        !node->as<ASTTableExpression>() &&
+        !node->as<ASTArrayJoin>();
+}
+
+}
diff --git a/src/Interpreters/RewriteAnyFunctionVisitor.h b/src/Interpreters/RewriteAnyFunctionVisitor.h
new file mode 100644
index 000000000000..d29af322711d
--- /dev/null
+++ b/src/Interpreters/RewriteAnyFunctionVisitor.h
@@ -0,0 +1,29 @@
+#pragma once
+
+#include <unordered_set>
+
+#include <Parsers/IAST.h>
+#include <Interpreters/InDepthNodeVisitor.h>
+
+namespace DB
+{
+
+class ASTFunction;
+
+/// Rewrite 'any' and 'anyLast' functions pushing them inside original function.
+/// any(f(x, y, g(z))) -> f(any(x), any(y), g(any(z)))
+class RewriteAnyFunctionMatcher
+{
+public:
+    struct Data
+    {
+        std::unordered_set<IAST *> rewritten;
+    };
+
+    static void visit(ASTPtr & ast, Data & data);
+    static void visit(const ASTFunction &, ASTPtr & ast, Data & data);
+    static bool needChildVisit(const ASTPtr & node, const ASTPtr & child);
+};
+using RewriteAnyFunctionVisitor = InDepthNodeVisitor<RewriteAnyFunctionMatcher, false>;
+
+}
diff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp
index 97922aba3f06..99eaf6e67368 100644
--- a/src/Interpreters/TreeOptimizer.cpp
+++ b/src/Interpreters/TreeOptimizer.cpp
@@ -8,7 +8,7 @@
 #include <Interpreters/DuplicateOrderByVisitor.h>
 #include <Interpreters/GroupByFunctionKeysVisitor.h>
 #include <Interpreters/AggregateFunctionOfGroupByKeysVisitor.h>
-#include <Interpreters/AnyInputOptimize.h>
+#include <Interpreters/RewriteAnyFunctionVisitor.h>
 #include <Interpreters/RemoveInjectiveFunctionsVisitor.h>
 #include <Interpreters/RedundantFunctionsInOrderByVisitor.h>
 #include <Interpreters/MonotonicityCheckVisitor.h>
@@ -458,11 +458,10 @@ void optimizeAggregationFunctions(ASTPtr & query)
     ArithmeticOperationsInAgrFuncVisitor(data).visit(query);
 }
 
-void optimizeAnyInput(ASTPtr & query)
+void optimizeAnyFunctions(ASTPtr & query)
 {
-    /// Removing arithmetic operations from functions
-    AnyInputVisitor::Data data = {};
-    AnyInputVisitor(data).visit(query);
+    RewriteAnyFunctionVisitor::Data data = {};
+    RewriteAnyFunctionVisitor(data).visit(query);
 }
 
 void optimizeInjectiveFunctionsInsideUniq(ASTPtr & query, const Context & context)
@@ -520,9 +519,9 @@ void TreeOptimizer::apply(ASTPtr & query, Aliases & aliases, const NameSet & sou
     if (settings.optimize_group_by_function_keys)
         optimizeGroupByFunctionKeys(select_query);
 
-    ///Move all operations out of any function
+    /// Move all operations out of any function
     if (settings.optimize_move_functions_out_of_any)
-        optimizeAnyInput(query);
+        optimizeAnyFunctions(query);
 
     /// Remove injective functions inside uniq
     if (settings.optimize_injective_functions_inside_uniq)
diff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make
index 48be2fae1b9b..c571b857365f 100644
--- a/src/Interpreters/ya.make
+++ b/src/Interpreters/ya.make
@@ -20,7 +20,6 @@ SRCS(
     addTypeConversionToAST.cpp
     AggregateDescription.cpp
     Aggregator.cpp
-    AnyInputOptimize.cpp
     ArithmeticOperationsInAgrFuncOptimize.cpp
     ArithmeticOperationsInAgrFuncOptimize.h
     ArrayJoinAction.cpp
@@ -127,6 +126,7 @@ SRCS(
     ReplaceQueryParameterVisitor.cpp
     RequiredSourceColumnsData.cpp
     RequiredSourceColumnsVisitor.cpp
+    RewriteAnyFunctionVisitor.cpp
     RowRefs.cpp
     Set.cpp
     SetVariants.cpp
