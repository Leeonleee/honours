{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 69292,
  "instance_id": "ClickHouse__ClickHouse-69292",
  "issue_numbers": [
    "67547"
  ],
  "base_commit": "414066ee573cdf0e76af27da28cf661f86937258",
  "patch": "diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 3f88106e8fa9..8d71abc0f02e 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -218,6 +218,28 @@ void QueryAnalyzer::resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & ta\n     }\n }\n \n+void QueryAnalyzer::resolveConstantExpression(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context)\n+{\n+    IdentifierResolveScope scope(node, nullptr /*parent_scope*/);\n+\n+    if (!scope.context)\n+        scope.context = context;\n+\n+    auto node_type = node->getNodeType();\n+\n+    if (table_expression && node_type != QueryTreeNodeType::QUERY && node_type != QueryTreeNodeType::UNION)\n+    {\n+        scope.expression_join_tree_node = table_expression;\n+        validateTableExpressionModifiers(scope.expression_join_tree_node, scope);\n+        initializeTableExpressionData(scope.expression_join_tree_node, scope);\n+    }\n+\n+    if (node_type == QueryTreeNodeType::LIST)\n+        resolveExpressionNodeList(node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+    else\n+        resolveExpressionNode(node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+}\n+\n std::optional<JoinTableSide> QueryAnalyzer::getColumnSideFromJoinTree(const QueryTreeNodePtr & resolved_identifier, const JoinNode & join_node)\n {\n     if (resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.h b/src/Analyzer/Resolve/QueryAnalyzer.h\nindex 7f9088b35e5f..0d4309843e6f 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.h\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.h\n@@ -119,6 +119,8 @@ class QueryAnalyzer\n \n     void resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context);\n \n+    void resolveConstantExpression(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context);\n+\n private:\n     /// Utility functions\n \ndiff --git a/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp b/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp\nindex 1bb60a4cf960..602c79ee3325 100644\n--- a/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp\n+++ b/src/Interpreters/IInterpreterUnionOrSelectQuery.cpp\n@@ -12,12 +12,14 @@\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/TreeRewriter.h>\n #include <Processors/QueryPlan/FilterStep.h>\n+#include <Common/Logger.h>\n \n \n namespace DB\n {\n namespace Setting\n {\n+    extern const SettingsBool allow_experimental_analyzer;\n     extern const SettingsString additional_result_filter;\n     extern const SettingsUInt64 max_bytes_to_read;\n     extern const SettingsUInt64 max_bytes_to_read_leaf;\n@@ -47,7 +49,13 @@ IInterpreterUnionOrSelectQuery::IInterpreterUnionOrSelectQuery(\n     /// it's possible that new analyzer will be enabled in ::getQueryProcessingStage method\n     /// of the underlying storage when all other parts of infrastructure are not ready for it\n     /// (built with old analyzer).\n-    context->setSetting(\"allow_experimental_analyzer\", false);\n+    if (context->getSettingsRef()[Setting::allow_experimental_analyzer])\n+    {\n+        LOG_TRACE(getLogger(\"IInterpreterUnionOrSelectQuery\"),\n+            \"The new analyzer is enabled, but the old interpreter is used. It can be a bug, please report it. Will disable 'allow_experimental_analyzer' setting (for query: {})\",\n+            query_ptr->formatForLogging());\n+        context->setSetting(\"allow_experimental_analyzer\", false);\n+    }\n \n     if (options.shard_num)\n         context->addSpecialScalar(\ndiff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex 4301ded40e17..4e2d68ad6faa 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -4,6 +4,9 @@\n #include <Columns/ColumnSet.h>\n #include <Columns/ColumnTuple.h>\n #include <Common/typeid_cast.h>\n+#include <Analyzer/Resolve/QueryAnalyzer.h>\n+#include <Analyzer/QueryTreeBuilder.h>\n+#include <Analyzer/TableNode.h>\n #include <Core/Block.h>\n #include <Core/Settings.h>\n #include <DataTypes/DataTypesNumber.h>\n@@ -15,18 +18,30 @@\n #include <Interpreters/Context.h>\n #include <Interpreters/castColumn.h>\n #include <Interpreters/convertFieldToType.h>\n+#include <Interpreters/InterpreterSelectQueryAnalyzer.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n #include <Interpreters/FunctionNameNormalizer.h>\n #include <Interpreters/ReplaceQueryParameterVisitor.h>\n+#include <Interpreters/SelectQueryOptions.h>\n #include <Interpreters/TreeRewriter.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSubquery.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Planner/CollectSets.h>\n+#include <Planner/CollectTableExpressionData.h>\n+#include <Planner/PlannerActionsVisitor.h>\n+#include <Planner/PlannerContext.h>\n+#include <Planner/Utils.h>\n #include <Processors/QueryPlan/Optimizations/actionsDAGUtils.h>\n+#include <Processors/Executors/PullingPipelineExecutor.h>\n #include <Storages/MergeTree/KeyCondition.h>\n+#include <Storages/ColumnsDescription.h>\n+#include <Storages/StorageDummy.h>\n #include <TableFunctions/TableFunctionFactory.h>\n \n+#include <optional>\n #include <unordered_map>\n \n \n@@ -35,6 +50,7 @@ namespace DB\n namespace Setting\n {\n     extern const SettingsBool normalize_function_names;\n+    extern const SettingsBool allow_experimental_analyzer;\n }\n \n namespace ErrorCodes\n@@ -76,34 +92,74 @@ std::optional<EvaluateConstantExpressionResult> evaluateConstantExpressionImpl(c\n     ReplaceQueryParameterVisitor param_visitor(context->getQueryParameters());\n     param_visitor.visit(ast);\n \n-    /// Notice: function name normalization is disabled when it's a secondary query, because queries are either\n-    /// already normalized on initiator node, or not normalized and should remain unnormalized for\n-    /// compatibility.\n-    if (context->getClientInfo().query_kind != ClientInfo::QueryKind::SECONDARY_QUERY\n-        && context->getSettingsRef()[Setting::normalize_function_names])\n-        FunctionNameNormalizer::visit(ast.get());\n+    String result_name;\n \n-    auto syntax_result = TreeRewriter(context, no_throw).analyze(ast, source_columns);\n-    if (!syntax_result)\n-        return {};\n+    ColumnPtr result_column;\n+    DataTypePtr result_type;\n+    if (context->getSettingsRef()[Setting::allow_experimental_analyzer])\n+    {\n+        result_name = ast->getColumnName();\n \n-    /// AST potentially could be transformed to literal during TreeRewriter analyze.\n-    /// For example if we have SQL user defined function that return literal AS subquery.\n-    if (ASTLiteral * literal = ast->as<ASTLiteral>())\n-        return getFieldAndDataTypeFromLiteral(literal);\n+        auto execution_context = Context::createCopy(context);\n+        auto expression = buildQueryTree(ast, execution_context);\n \n-    auto actions = ExpressionAnalyzer(ast, syntax_result, context).getConstActionsDAG();\n+        ColumnsDescription fake_column_descriptions(source_columns);\n+        auto storage = std::make_shared<StorageDummy>(StorageID{\"dummy\", \"dummy\"}, fake_column_descriptions);\n+        QueryTreeNodePtr fake_table_expression = std::make_shared<TableNode>(storage, execution_context);\n \n-    ColumnPtr result_column;\n-    DataTypePtr result_type;\n-    String result_name = ast->getColumnName();\n-    for (const auto & action_node : actions.getOutputs())\n+        QueryAnalyzer analyzer(false);\n+        analyzer.resolveConstantExpression(expression, fake_table_expression, execution_context);\n+\n+        GlobalPlannerContextPtr global_planner_context = std::make_shared<GlobalPlannerContext>(nullptr, nullptr, FiltersForTableExpressionMap{});\n+        auto planner_context = std::make_shared<PlannerContext>(execution_context, global_planner_context, SelectQueryOptions{});\n+\n+        collectSourceColumns(expression, planner_context, false /*keep_alias_columns*/);\n+        collectSets(expression, *planner_context);\n+\n+        auto actions = buildActionsDAGFromExpressionNode(expression, {}, planner_context);\n+\n+        if (actions.getOutputs().size() != 1)\n+        {\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"ActionsDAG contains more than 1 output for expression: {}\", ast->formatForLogging());\n+        }\n+\n+        const auto & output = actions.getOutputs()[0];\n+        if (output->column)\n+        {\n+            result_column = output->column;\n+            result_type = output->result_type;\n+        }\n+    }\n+    else\n     {\n-        if ((action_node->result_name == result_name) && action_node->column)\n+        /// Notice: function name normalization is disabled when it's a secondary query, because queries are either\n+        /// already normalized on initiator node, or not normalized and should remain unnormalized for\n+        /// compatibility.\n+        if (context->getClientInfo().query_kind != ClientInfo::QueryKind::SECONDARY_QUERY\n+            && context->getSettingsRef()[Setting::normalize_function_names])\n+            FunctionNameNormalizer::visit(ast.get());\n+\n+        result_name = ast->getColumnName();\n+\n+        auto syntax_result = TreeRewriter(context, no_throw).analyze(ast, source_columns);\n+        if (!syntax_result)\n+            return {};\n+\n+        /// AST potentially could be transformed to literal during TreeRewriter analyze.\n+        /// For example if we have SQL user defined function that return literal AS subquery.\n+        if (ASTLiteral * literal = ast->as<ASTLiteral>())\n+            return getFieldAndDataTypeFromLiteral(literal);\n+\n+        auto actions = ExpressionAnalyzer(ast, syntax_result, context).getConstActionsDAG();\n+\n+        for (const auto & action_node : actions.getOutputs())\n         {\n-            result_column = action_node->column;\n-            result_type = action_node->result_type;\n-            break;\n+            if ((action_node->result_name == result_name) && action_node->column)\n+            {\n+                result_column = action_node->column;\n+                result_type = action_node->result_type;\n+                break;\n+            }\n         }\n     }\n \ndiff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp\nindex 24d885d9fff0..5da4c83f77b4 100644\n--- a/src/Storages/StorageDistributed.cpp\n+++ b/src/Storages/StorageDistributed.cpp\n@@ -489,7 +489,7 @@ QueryProcessingStage::Enum StorageDistributed::getQueryProcessingStage(\n     }\n \n     std::optional<QueryProcessingStage::Enum> optimized_stage;\n-    if (query_info.query_tree)\n+    if (settings[Setting::allow_experimental_analyzer])\n         optimized_stage = getOptimizedQueryProcessingStageAnalyzer(query_info, settings);\n     else\n         optimized_stage = getOptimizedQueryProcessingStage(query_info, settings);\ndiff --git a/src/TableFunctions/TableFunctionExecutable.cpp b/src/TableFunctions/TableFunctionExecutable.cpp\nindex cccd3587bc74..12371f6ff822 100644\n--- a/src/TableFunctions/TableFunctionExecutable.cpp\n+++ b/src/TableFunctions/TableFunctionExecutable.cpp\n@@ -71,12 +71,12 @@ std::vector<size_t> TableFunctionExecutable::skipAnalysisForArguments(const Quer\n     const auto & table_function_node_arguments = table_function_node.getArguments().getNodes();\n     size_t table_function_node_arguments_size = table_function_node_arguments.size();\n \n-    if (table_function_node_arguments_size <= 2)\n+    if (table_function_node_arguments_size <= 3)\n         return {};\n \n     std::vector<size_t> result_indexes;\n-    result_indexes.reserve(table_function_node_arguments_size - 2);\n-    for (size_t i = 2; i < table_function_node_arguments_size; ++i)\n+    result_indexes.reserve(table_function_node_arguments_size - 3);\n+    for (size_t i = 3; i < table_function_node_arguments_size; ++i)\n         result_indexes.push_back(i);\n \n     return result_indexes;\n@@ -103,10 +103,11 @@ void TableFunctionExecutable::parseArguments(const ASTPtr & ast_function, Contex\n         if (!args[i]->as<ASTIdentifier>() &&\n             !args[i]->as<ASTLiteral>() &&\n             !args[i]->as<ASTQueryParameter>() &&\n-            !args[i]->as<ASTSubquery>())\n+            !args[i]->as<ASTSubquery>() &&\n+            !args[i]->as<ASTFunction>())\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of argument '{}' for table function '{}': must be an identifier or string literal\",\n-                argument_name, getName());\n+                \"Illegal type of argument '{}' for table function '{}': must be an identifier or string literal, but got: {}\",\n+                argument_name, getName(), args[i]->formatForErrorMessage());\n     };\n \n     check_argument(0, \"script_name\");\n",
  "test_patch": "diff --git a/tests/integration/test_executable_table_function/test.py b/tests/integration/test_executable_table_function/test.py\nindex 801a3c7c14af..ad784494bccd 100644\n--- a/tests/integration/test_executable_table_function/test.py\n+++ b/tests/integration/test_executable_table_function/test.py\n@@ -109,6 +109,30 @@ def test_executable_function_input_python(started_cluster):\n     node.query(\"DROP FUNCTION test_function;\")\n \n \n+def test_executable_function_arg_eval_input_python(started_cluster):\n+    skip_test_msan(node)\n+\n+    query = (\n+        \"SELECT * FROM executable('input.py', 'TabSeparated', 'value String', {source})\"\n+    )\n+    assert node.query(query.format(source=\"(SELECT 1)\")) == \"Key 1\\n\"\n+    assert (\n+        node.query(query.format(source=\"(SELECT id FROM test_data_table)\"))\n+        == \"Key 0\\nKey 1\\nKey 2\\n\"\n+    )\n+\n+    node.query(\"CREATE FUNCTION test_function AS () -> 'input.py';\")\n+\n+    query = \"SELECT * FROM executable(test_function(), 'TabSeparated', 'value String', {source})\"\n+    assert node.query(query.format(source=\"(SELECT 1)\")) == \"Key 1\\n\"\n+    assert (\n+        node.query(query.format(source=\"(SELECT id FROM test_data_table)\"))\n+        == \"Key 0\\nKey 1\\nKey 2\\n\"\n+    )\n+\n+    node.query(\"DROP FUNCTION test_function;\")\n+\n+\n def test_executable_function_input_sum_python(started_cluster):\n     skip_test_msan(node)\n \ndiff --git a/tests/queries/0_stateless/02002_global_subqueries_subquery_or_table_name.sql b/tests/queries/0_stateless/02002_global_subqueries_subquery_or_table_name.sql\nindex 525021785c10..e752e8714604 100644\n--- a/tests/queries/0_stateless/02002_global_subqueries_subquery_or_table_name.sql\n+++ b/tests/queries/0_stateless/02002_global_subqueries_subquery_or_table_name.sql\n@@ -4,4 +4,4 @@ SELECT\n     cityHash64(number GLOBAL IN (NULL, -2147483648, -9223372036854775808), nan, 1024, NULL, NULL, 1.000100016593933, NULL),\n     (NULL, cityHash64(inf, -2147483648, NULL, NULL, 10.000100135803223), cityHash64(1.1754943508222875e-38, NULL, NULL, NULL), 2147483647)\n FROM cluster(test_cluster_two_shards_localhost, numbers((NULL, cityHash64(0., 65536, NULL, NULL, 10000000000., NULL), 0) GLOBAL IN (some_identifier), 65536))\n-WHERE number GLOBAL IN [1025] --{serverError BAD_ARGUMENTS, 284}\n+WHERE number GLOBAL IN [1025] --{ serverError BAD_ARGUMENTS, WRONG_GLOBAL_SUBQUERY, UNKNOWN_IDENTIFIER }\ndiff --git a/tests/queries/0_stateless/02815_logical_error_cannot_get_column_name_of_set.sql b/tests/queries/0_stateless/02815_logical_error_cannot_get_column_name_of_set.sql\nindex aa6591659400..cd3ce3c9d1c9 100644\n--- a/tests/queries/0_stateless/02815_logical_error_cannot_get_column_name_of_set.sql\n+++ b/tests/queries/0_stateless/02815_logical_error_cannot_get_column_name_of_set.sql\n@@ -1,3 +1,3 @@\n-SELECT * FROM numbers(SETTINGS x = 1); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM numbers(SETTINGS x = 1); -- { serverError BAD_ARGUMENTS, UNSUPPORTED_METHOD }\n SELECT * FROM numbers(numbers(SETTINGS x = 1)); -- { serverError UNKNOWN_FUNCTION, UNSUPPORTED_METHOD }\n SELECT * FROM numbers(numbers(SETTINGS x = 1), SETTINGS x = 1); -- { serverError UNKNOWN_FUNCTION, UNSUPPORTED_METHOD }\ndiff --git a/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.reference b/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.reference\nindex 251d054748a5..2c5226d79243 100644\n--- a/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.reference\n+++ b/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.reference\n@@ -1,1 +1,1 @@\n-Unknown function\n+UNKNOWN_FUNCTION\ndiff --git a/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.sh b/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.sh\nindex e0a145d84566..906cea744db6 100755\n--- a/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.sh\n+++ b/tests/queries/0_stateless/03036_udf_user_defined_directory_in_client.sh\n@@ -8,7 +8,7 @@ ${CLICKHOUSE_CLIENT} --query \"DROP TABLE IF EXISTS test\"\n ${CLICKHOUSE_CLIENT} --query \"CREATE TABLE test (s String) ENGINE = Memory\"\n \n # Calling an unknown function should not lead to creation of a 'user_defined' directory in the current directory\n-${CLICKHOUSE_CLIENT} --query \"INSERT INTO test VALUES (xyz('abc'))\" 2>&1 | grep -o -F 'Unknown function'\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO test VALUES (xyz('abc'))\" 2>&1 | grep -o -F 'UNKNOWN_FUNCTION'\n \n ls -ld user_defined 2> /dev/null\n \ndiff --git a/tests/queries/0_stateless/03234_evaluate_constant_analyzer.reference b/tests/queries/0_stateless/03234_evaluate_constant_analyzer.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03234_evaluate_constant_analyzer.sql b/tests/queries/0_stateless/03234_evaluate_constant_analyzer.sql\nnew file mode 100644\nindex 000000000000..8ddd4baaf641\n--- /dev/null\n+++ b/tests/queries/0_stateless/03234_evaluate_constant_analyzer.sql\n@@ -0,0 +1,1 @@\n+SELECT count() FROM numbers(cityHash64(materialize(toLowCardinality(toNullable(0))) GLOBAL IN (NULL, -2147483648, -9223372036854775808), nan, 1024, NULL, materialize(1.000100016593933), 0, NULL), 4) AS n1, numbers(3) AS n2, numbers(6) AS n3 GROUP BY (NULL, cityHash64(inf, -2147483648, toLowCardinality(16), NULL, 10.000100135803223), cityHash64(1.1754943508222875e-38, NULL, NULL, NULL), 2147483647), cityHash64(0., 3, NULL, NULL, 10000000000., NULL, NULL) SETTINGS enable_analyzer = 1; -- { serverError BAD_ARGUMENTS }\n",
  "problem_statement": "Regression in `executable` table function using new analyzer\n**Describe the issue**\r\nThe `executable` can receive an argument that depends on a subquery without using the new analyzer. With the new analyzer it throws an error.\r\n\r\n```\r\nCREATE TABLE t (args String) ENGINE=MergeTree() ORDER BY args;\r\nINSERT INTO t VALUES ('aaa'), ('bbb');\r\n\r\n\r\nSELECT * FROM executable( (select 'bash '|| args FROM t LIMIT 1 ), TabSeparated, 't text' ) SETTINGS allow_experimental_analyzer = 1;\r\n``` \r\n[Reproduction](https://fiddle.clickhouse.com/a0790efa-747d-4640-ab7a-5a820f5a63ee). Fiddle complains about `bash` doesn't exist inside user files, but that is kind of expected on fiddle. I assume if it existed, it would execute it.\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\nReceived exception from server (version 24.6.2):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Illegal type of argument 'script_name' for table function 'executable': must be an identifier or string literal. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n(query: SELECT * FROM executable( (select 'bash '|| args FROM t LIMIT 1 ), TabSeparated, 't text' ) SETTINGS allow_experimental_analyzer = 1;)\r\n```\r\n\r\n**Additional context**\r\nThe issue was [raised](https://clickhousedb.slack.com/archives/CU478UEQZ/p1722434524104699) in community slack the reasoning behind the neccesity of this is the following:\r\n\r\n> Since the \u201cscript_name\u201d field does support passing arguments to a script, it is vitally important that functions and subqueries are made to work again for that argument.\r\n\n",
  "hints_text": "",
  "created_at": "2024-09-05T13:38:39Z"
}