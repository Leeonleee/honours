{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55642,
  "instance_id": "ClickHouse__ClickHouse-55642",
  "issue_numbers": [
    "41195"
  ],
  "base_commit": "713dba82b32a9d99b972e6fbabe88f260807d7a0",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex ccf290c8e20c..d1e94b38962d 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -4780,6 +4780,10 @@ a\tTuple(\n )\n ```\n \n+## analyze_index_with_space_filling_curves\n+\n+If a table has a space-filling curve in its index, e.g. `ORDER BY mortonEncode(x, y)`, and the query has conditions on its arguments, e.g. `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, use the space-filling curve for index analysis.\n+\n ## dictionary_use_async_executor {#dictionary_use_async_executor}\n \n Execute a pipeline for reading dictionary source in several threads. It's supported only by dictionaries with local CLICKHOUSE source.\ndiff --git a/src/Common/MortonUtils.h b/src/Common/MortonUtils.h\nnew file mode 100644\nindex 000000000000..591621f7a47e\n--- /dev/null\n+++ b/src/Common/MortonUtils.h\n@@ -0,0 +1,217 @@\n+#pragma once\n+\n+#include <Core/Types.h>\n+#include <Common/BitHelpers.h>\n+#include <base/defines.h>\n+#include <array>\n+#include <set>\n+\n+\n+/** Functions to analyze the Morton space-filling curve on ranges.\n+  * There are two operations:\n+  *\n+  * 1. Inverting the Morton curve on a range.\n+  * Given a range of values of Morton curve,\n+  *   mortonEncode(x, y) in [a, b]\n+  * get possible set of values of its arguments.\n+  * This set is represented by a set of hyperrectangles in (x, y) space.\n+  *\n+  * 2. Calculating the Morton curve on a hyperrectangle.\n+  * Given a hyperrectangle in (x, y) space\n+  *   (x, y) in [x_min, x_max] \u00d7 [y_min, y_max]\n+  * get possible intervals of the mortonEncode(x, y).\n+  *\n+  * These operations could be used for index analysis.\n+  *\n+  * Note: currently it is only tested in 2d.\n+  */\n+\n+\n+namespace\n+{\n+    /// After the most significant bit 1, set all subsequent less significant bits to 1 as well.\n+    inline UInt64 toMask(UInt64 n)\n+    {\n+        n |= n >> 1;\n+        n |= n >> 2;\n+        n |= n >> 4;\n+        n |= n >> 8;\n+        n |= n >> 16;\n+        n |= n >> 32;\n+        return n;\n+    }\n+}\n+\n+\n+/** Splits the interval [first, last] to a set of intervals [first_i, last_i],\n+  * each of them determined by a bit prefix: [xxxxxx0000, xxxxxx1111],\n+  *\n+  * For example, the interval [6, 13] = {5, 7, 8, 9, 10, 11, 12, 13}\n+  * will be represented by the set of intervals:\n+  * - [6,  7]   0000011*\n+  * - [8,  11]  000010**\n+  * - [12, 13]  0000110*\n+  *\n+  * It means that if you have a binary space partition by powers of two,\n+  * every of the resulting intervals will fully occupy one of the levels of this partition.\n+  */\n+template <typename F>\n+void intervalBinaryPartition(UInt64 first, UInt64 last, F && callback)\n+{\n+    /// first = 6:    00000110\n+    /// last = 13:    00001101\n+    /// first ^ last: 00001011\n+    /// mask:         00000111\n+    /// split = 7:    00000111\n+\n+    /// first = 8:    00001000\n+    /// last = 13:    00001101\n+    /// first ^ last: 00000101\n+    /// mask:         00000011\n+    /// split = 11:   00001011\n+\n+    /// first = 8:    00001000\n+    /// last = 11:    00001011\n+    /// first ^ last: 00000011\n+    /// mask:         00000001\n+    /// split = 9:    00001001\n+\n+    /// Another example:\n+\n+    /// first = 15:   00001111\n+    /// last = 31:    00011111\n+    /// first ^ last: 00010000\n+    /// mask:         00001111\n+    /// split = 15:   00001111\n+\n+    UInt64 diff = first ^ last;\n+    UInt64 mask = toMask(diff) >> 1;\n+\n+    /// The current interval represents a whole range with fixed prefix.\n+    if ((first & mask) == 0 && (last & mask) == mask)\n+    {\n+        chassert(((last - first + 1) & (last - first)) == 0); /// The interval length is one less than a power of two.\n+        callback(first, last);\n+        return;\n+    }\n+\n+    UInt64 split = first | mask;\n+\n+    chassert(split >= first);\n+    chassert(split <= last);\n+\n+    intervalBinaryPartition(first, split, std::forward<F>(callback));\n+    if (split < last)\n+        intervalBinaryPartition(split + 1, last, std::forward<F>(callback));\n+}\n+\n+\n+/** Multidimensional version of binary space partitioning.\n+  * It takes a hyperrectangle - a direct product of intervals (in each dimension),\n+  * and splits it into smaller hyperrectangles - a direct product of partitions across each dimension.\n+  */\n+template <size_t N, size_t start_idx, typename F>\n+void hyperrectangleBinaryPartitionImpl(\n+    std::array<std::pair<UInt64, UInt64>, N> hyperrectangle,\n+    F && callback)\n+{\n+    intervalBinaryPartition(hyperrectangle[start_idx].first, hyperrectangle[start_idx].second,\n+        [&](UInt64 a, UInt64 b) mutable\n+        {\n+            auto new_hyperrectangle = hyperrectangle;\n+            new_hyperrectangle[start_idx].first = a;\n+            new_hyperrectangle[start_idx].second = b;\n+\n+            if constexpr (start_idx + 1 < N)\n+                hyperrectangleBinaryPartitionImpl<N, start_idx + 1>(new_hyperrectangle, std::forward<F>(callback));\n+            else\n+                callback(new_hyperrectangle);\n+        });\n+}\n+\n+\n+template <size_t N, typename F>\n+void hyperrectangleBinaryPartition(\n+    std::array<std::pair<UInt64, UInt64>, N> hyperrectangle,\n+    F && callback)\n+{\n+    hyperrectangleBinaryPartitionImpl<N, 0>(hyperrectangle, std::forward<F>(callback));\n+}\n+\n+\n+/** Unpack an interval of Morton curve to hyperrectangles covered by it across N dimensions.\n+  */\n+template <size_t N, typename F>\n+void mortonIntervalToHyperrectangles(UInt64 first, UInt64 last, F && callback)\n+{\n+    intervalBinaryPartition(first, last, [&](UInt64 a, UInt64 b)\n+    {\n+        std::array<std::pair<UInt64, UInt64>, N> unpacked{};\n+\n+        for (size_t bit_idx = 0; bit_idx < 64; ++bit_idx)\n+        {\n+            size_t source_bit = 63 - bit_idx;\n+            size_t result_bit = (63 - bit_idx) / N;\n+\n+            unpacked[source_bit % N].first |= ((a >> source_bit) & 1) << result_bit;\n+            unpacked[source_bit % N].second |= ((b >> source_bit) & 1) << result_bit;\n+        }\n+\n+        callback(unpacked);\n+    });\n+}\n+\n+\n+/** Given a hyperrectangle, find intervals of Morton curve that cover this hyperrectangle.\n+  * Note: to avoid returning too many intervals, the intervals can be returned larger than exactly needed\n+  * (covering some other points, not belonging to the hyperrectangle).\n+  * We do it by extending hyperrectangles to hypercubes.\n+  */\n+template <size_t N, typename F>\n+void hyperrectangleToPossibleMortonIntervals(\n+    std::array<std::pair<UInt64, UInt64>, N> hyperrectangle,\n+    F && callback)\n+{\n+    /// Due to extension to cubes, there could be duplicates. Filter them.\n+    std::set<std::pair<UInt64, UInt64>> found_intervals;\n+\n+    hyperrectangleBinaryPartition<N>(hyperrectangle, [&](auto part)\n+    {\n+        size_t suffix_size = 0;\n+        for (size_t i = 0; i < N; ++i)\n+            if (part[i].second != part[i].first)\n+                suffix_size = std::max<size_t>(suffix_size,\n+                    1 + bitScanReverse(part[i].second ^ part[i].first));\n+\n+        UInt64 first = 0;\n+        UInt64 last = 0;\n+\n+        size_t source_bit_idx = 0;\n+        size_t result_bit_idx = 0;\n+\n+        while (result_bit_idx < 64)\n+        {\n+            for (size_t i = 0; i < N; ++i)\n+            {\n+                if (source_bit_idx < suffix_size)\n+                {\n+                    last |= (1 << result_bit_idx);\n+                }\n+                else\n+                {\n+                    UInt64 bit = (((part[i].first >> source_bit_idx) & 1) << result_bit_idx);\n+                    first |= bit;\n+                    last |= bit;\n+                }\n+\n+                ++result_bit_idx;\n+                if (!(result_bit_idx < 64))\n+                    break;\n+            }\n+            ++source_bit_idx;\n+        }\n+\n+        if (found_intervals.insert({first, last}).second)\n+            callback(first, last);\n+    });\n+}\ndiff --git a/src/Core/Range.cpp b/src/Core/Range.cpp\nindex de88313b9f36..441c6b5cafe7 100644\n--- a/src/Core/Range.cpp\n+++ b/src/Core/Range.cpp\n@@ -7,7 +7,6 @@\n namespace DB\n {\n \n-\n Range::Range(const FieldRef & point) /// NOLINT\n     : left(point), right(point), left_included(true), right_included(true) {}\n \n@@ -160,6 +159,52 @@ void Range::invert()\n     std::swap(left_included, right_included);\n }\n \n+Range intersect(const Range & a, const Range & b)\n+{\n+    Range res = Range::createWholeUniverse();\n+\n+    if (Range::less(a.left, b.left))\n+    {\n+        res.left = b.left;\n+        res.left_included = b.left_included;\n+    }\n+    else if (Range::equals(a.left, b.left))\n+    {\n+        res.left = a.left;\n+        res.left_included = a.left_included && b.left_included;\n+    }\n+    else\n+    {\n+        res.left = a.left;\n+        res.left_included = a.left_included;\n+    }\n+\n+    if (Range::less(a.right, b.right))\n+    {\n+        res.right = a.right;\n+        res.right_included = a.right_included;\n+    }\n+    else if (Range::equals(a.right, b.right))\n+    {\n+        res.right = a.right;\n+        res.right_included = a.right_included && b.right_included;\n+    }\n+    else\n+    {\n+        res.right = b.right;\n+        res.right_included = b.right_included;\n+    }\n+\n+    if (res.empty())\n+    {\n+        res.right = res.left;\n+        res.right_included = false;\n+        res.left_included = false;\n+    }\n+\n+    return res;\n+}\n+\n String Range::toString() const\n {\n     WriteBufferFromOwnString str;\n@@ -170,4 +215,33 @@ String Range::toString() const\n     return str.str();\n }\n \n+Hyperrectangle intersect(const Hyperrectangle & a, const Hyperrectangle & b)\n+{\n+    size_t result_size = std::min(a.size(), b.size());\n+\n+    Hyperrectangle res;\n+    res.reserve(result_size);\n+\n+    for (size_t i = 0; i < result_size; ++i)\n+        res.push_back(intersect(a[i], b[i]));\n+\n+    return res;\n+}\n+\n+String toString(const Hyperrectangle & x)\n+{\n+    WriteBufferFromOwnString str;\n+\n+    bool first = true;\n+    for (const auto & range : x)\n+    {\n+        if (!first)\n+            str << \" \u00d7 \";\n+        str << range.toString();\n+        first = false;\n+    }\n+\n+    return str.str();\n+}\n+\n }\ndiff --git a/src/Core/Range.h b/src/Core/Range.h\nindex 9680107cd51d..63bb895e6b78 100644\n--- a/src/Core/Range.h\n+++ b/src/Core/Range.h\n@@ -59,8 +59,8 @@ struct Range\n     static Range createRightBounded(const FieldRef & right_point, bool right_included, bool with_null = false);\n     static Range createLeftBounded(const FieldRef & left_point, bool left_included, bool with_null = false);\n \n-    static ALWAYS_INLINE bool equals(const Field & lhs, const Field & rhs);\n-    static ALWAYS_INLINE bool less(const Field & lhs, const Field & rhs);\n+    static bool equals(const Field & lhs, const Field & rhs);\n+    static bool less(const Field & lhs, const Field & rhs);\n \n     /** Optimize the range. If it has an open boundary and the Field type is \"loose\"\n       * - then convert it to closed, narrowing by one.\n@@ -88,8 +88,13 @@ struct Range\n     String toString() const;\n };\n \n+Range intersect(const Range & a, const Range & b);\n+\n /** Hyperrectangle is a product of ranges: each range across each coordinate.\n   */\n using Hyperrectangle = std::vector<Range>;\n \n+Hyperrectangle intersect(const Hyperrectangle & a, const Hyperrectangle & b);\n+String toString(const Hyperrectangle & x);\n+\n }\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 733cebe44114..d3572d39ccdc 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -335,6 +335,7 @@ class IColumn;\n     M(Bool, optimize_throw_if_noop, false, \"If setting is enabled and OPTIMIZE query didn't actually assign a merge then an explanatory exception is thrown\", 0) \\\n     M(Bool, use_index_for_in_with_subqueries, true, \"Try using an index if there is a subquery or a table expression on the right side of the IN operator.\", 0) \\\n     M(UInt64, use_index_for_in_with_subqueries_max_values, 0, \"The maximum size of set in the right hand side of the IN operator to use table index for filtering. It allows to avoid performance degradation and higher memory usage due to preparation of additional data structures for large queries. Zero means no limit.\", 0) \\\n+    M(Bool, analyze_index_with_space_filling_curves, true, \"If a table has a space-filling curve in its index, e.g. `ORDER BY mortonEncode(x, y)`, and the query has conditions on its arguments, e.g. `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, use the space-filling curve for index analysis.\", 0) \\\n     M(Bool, joined_subquery_requires_alias, true, \"Force joined subqueries and table functions to have aliases for correct name qualification.\", 0) \\\n     M(Bool, empty_result_for_aggregation_by_empty_set, false, \"Return empty result when aggregating without keys on empty set.\", 0) \\\n     M(Bool, empty_result_for_aggregation_by_constant_keys_on_empty_set, true, \"Return empty result when aggregating by constant keys on empty set.\", 0) \\\ndiff --git a/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp b/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp\nindex b346ef3d2325..01e8e04a3d7b 100644\n--- a/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp\n@@ -431,7 +431,8 @@ static void buildORCSearchArgumentImpl(\n         case KeyCondition::RPNElement::FUNCTION_IN_SET:\n         case KeyCondition::RPNElement::FUNCTION_NOT_IN_SET:\n         case KeyCondition::RPNElement::FUNCTION_IS_NULL:\n-        case KeyCondition::RPNElement::FUNCTION_IS_NOT_NULL: {\n+        case KeyCondition::RPNElement::FUNCTION_IS_NOT_NULL:\n+        {\n             const bool need_wrap_not = curr.function == KeyCondition::RPNElement::FUNCTION_IS_NOT_NULL\n                 || curr.function == KeyCondition::RPNElement::FUNCTION_NOT_IN_RANGE\n                 || curr.function == KeyCondition::RPNElement::FUNCTION_NOT_IN_SET;\n@@ -625,19 +626,24 @@ static void buildORCSearchArgumentImpl(\n \n             break;\n         }\n-        case KeyCondition::RPNElement::FUNCTION_UNKNOWN: {\n+        /// There is no optimization with space-filling curves for ORC.\n+        case KeyCondition::RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE:\n+        case KeyCondition::RPNElement::FUNCTION_UNKNOWN:\n+        {\n             builder.literal(orc::TruthValue::YES_NO_NULL);\n             rpn_stack.pop_back();\n             break;\n         }\n-        case KeyCondition::RPNElement::FUNCTION_NOT: {\n+        case KeyCondition::RPNElement::FUNCTION_NOT:\n+        {\n             builder.startNot();\n             rpn_stack.pop_back();\n             buildORCSearchArgumentImpl(key_condition, header, schema, rpn_stack, builder, format_settings);\n             builder.end();\n             break;\n         }\n-        case KeyCondition::RPNElement::FUNCTION_AND: {\n+        case KeyCondition::RPNElement::FUNCTION_AND:\n+        {\n             builder.startAnd();\n             rpn_stack.pop_back();\n             buildORCSearchArgumentImpl(key_condition, header, schema, rpn_stack, builder, format_settings);\n@@ -645,7 +651,8 @@ static void buildORCSearchArgumentImpl(\n             builder.end();\n             break;\n         }\n-        case KeyCondition::RPNElement::FUNCTION_OR: {\n+        case KeyCondition::RPNElement::FUNCTION_OR:\n+        {\n             builder.startOr();\n             rpn_stack.pop_back();\n             buildORCSearchArgumentImpl(key_condition, header, schema, rpn_stack, builder, format_settings);\n@@ -653,12 +660,14 @@ static void buildORCSearchArgumentImpl(\n             builder.end();\n             break;\n         }\n-        case KeyCondition::RPNElement::ALWAYS_FALSE: {\n+        case KeyCondition::RPNElement::ALWAYS_FALSE:\n+        {\n             builder.literal(orc::TruthValue::NO);\n             rpn_stack.pop_back();\n             break;\n         }\n-        case KeyCondition::RPNElement::ALWAYS_TRUE: {\n+        case KeyCondition::RPNElement::ALWAYS_TRUE:\n+        {\n             builder.literal(orc::TruthValue::YES);\n             rpn_stack.pop_back();\n             break;\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 666d9d3815d5..3bee0a235e84 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -15,6 +15,7 @@\n #include <Functions/CastOverloadResolver.h>\n #include <Functions/IFunction.h>\n #include <Common/FieldVisitorToString.h>\n+#include <Common/MortonUtils.h>\n #include <Common/typeid_cast.h>\n #include <Columns/ColumnSet.h>\n #include <Interpreters/convertFieldToType.h>\n@@ -26,7 +27,6 @@\n #include <IO/WriteBufferFromString.h>\n #include <IO/Operators.h>\n #include <Storages/MergeTree/MergeTreeIndexUtils.h>\n-#include <base/defines.h>\n \n #include <algorithm>\n #include <cassert>\n@@ -453,26 +453,28 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n \n static const std::map<std::string, std::string> inverse_relations =\n {\n-        {\"equals\", \"notEquals\"},\n-        {\"notEquals\", \"equals\"},\n-        {\"less\", \"greaterOrEquals\"},\n-        {\"greaterOrEquals\", \"less\"},\n-        {\"greater\", \"lessOrEquals\"},\n-        {\"lessOrEquals\", \"greater\"},\n-        {\"in\", \"notIn\"},\n-        {\"notIn\", \"in\"},\n-        {\"globalIn\", \"globalNotIn\"},\n-        {\"globalNotIn\", \"globalIn\"},\n-        {\"nullIn\", \"notNullIn\"},\n-        {\"notNullIn\", \"nullIn\"},\n-        {\"globalNullIn\", \"globalNotNullIn\"},\n-        {\"globalNullNotIn\", \"globalNullIn\"},\n-        {\"isNull\", \"isNotNull\"},\n-        {\"isNotNull\", \"isNull\"},\n-        {\"like\", \"notLike\"},\n-        {\"notLike\", \"like\"},\n-        {\"empty\", \"notEmpty\"},\n-        {\"notEmpty\", \"empty\"},\n+    {\"equals\", \"notEquals\"},\n+    {\"notEquals\", \"equals\"},\n+    {\"less\", \"greaterOrEquals\"},\n+    {\"greaterOrEquals\", \"less\"},\n+    {\"greater\", \"lessOrEquals\"},\n+    {\"lessOrEquals\", \"greater\"},\n+    {\"in\", \"notIn\"},\n+    {\"notIn\", \"in\"},\n+    {\"globalIn\", \"globalNotIn\"},\n+    {\"globalNotIn\", \"globalIn\"},\n+    {\"nullIn\", \"notNullIn\"},\n+    {\"notNullIn\", \"nullIn\"},\n+    {\"globalNullIn\", \"globalNotNullIn\"},\n+    {\"globalNullNotIn\", \"globalNullIn\"},\n+    {\"isNull\", \"isNotNull\"},\n+    {\"isNotNull\", \"isNull\"},\n+    {\"like\", \"notLike\"},\n+    {\"notLike\", \"like\"},\n+    {\"ilike\", \"notILike\"},\n+    {\"notILike\", \"ilike\"},\n+    {\"empty\", \"notEmpty\"},\n+    {\"notEmpty\", \"empty\"},\n };\n \n \n@@ -723,6 +725,40 @@ static NameSet getAllSubexpressionNames(const ExpressionActions & key_expr)\n     return names;\n }\n \n+void KeyCondition::getAllSpaceFillingCurves()\n+{\n+    /// So far the only supported function is mortonEncode (Morton curve).\n+\n+    for (const auto & action : key_expr->getActions())\n+    {\n+        if (action.node->type == ActionsDAG::ActionType::FUNCTION\n+            && action.node->children.size() >= 2\n+            && action.node->function_base->getName() == \"mortonEncode\")\n+        {\n+            SpaceFillingCurveDescription curve;\n+            curve.function_name = action.node->function_base->getName();\n+            curve.key_column_pos = key_columns.at(action.node->result_name);\n+            for (const auto & child : action.node->children)\n+            {\n+                /// All arguments should be regular input columns.\n+                if (child->type == ActionsDAG::ActionType::INPUT)\n+                {\n+                    curve.arguments.push_back(child->result_name);\n+                }\n+                else\n+                {\n+                    curve.arguments.clear();\n+                    break;\n+                }\n+            }\n+\n+            /// So far we only support the case of two arguments.\n+            if (2 == curve.arguments.size())\n+                key_space_filling_curves.push_back(std::move(curve));\n+        }\n+    }\n+}\n+\n KeyCondition::KeyCondition(\n     const ASTPtr & query,\n     const ASTs & additional_filter_asts,\n@@ -751,6 +787,9 @@ KeyCondition::KeyCondition(\n         ++key_index;\n     }\n \n+    if (context->getSettingsRef().analyze_index_with_space_filling_curves)\n+        getAllSpaceFillingCurves();\n+\n     ASTPtr filter_node;\n     if (query)\n         filter_node = buildFilterNode(query, additional_filter_asts);\n@@ -776,7 +815,10 @@ KeyCondition::KeyCondition(\n         std::move(block_with_constants),\n         std::move(prepared_sets),\n         [&](const RPNBuilderTreeNode & node, RPNElement & out) { return extractAtomFromTree(node, out); });\n+\n     rpn = std::move(builder).extractRPN();\n+\n+    findHyperrectanglesForArgumentsOfSpaceFillingCurves();\n }\n \n KeyCondition::KeyCondition(\n@@ -825,6 +867,9 @@ KeyCondition::KeyCondition(\n         ++key_index;\n     }\n \n+    if (context->getSettingsRef().analyze_index_with_space_filling_curves)\n+        getAllSpaceFillingCurves();\n+\n     if (!filter_dag)\n     {\n         rpn.emplace_back(RPNElement::FUNCTION_UNKNOWN);\n@@ -842,6 +887,8 @@ KeyCondition::KeyCondition(\n     });\n \n     rpn = std::move(builder).extractRPN();\n+\n+    findHyperrectanglesForArgumentsOfSpaceFillingCurves();\n }\n \n bool KeyCondition::addCondition(const String & column, const Range & range)\n@@ -1204,7 +1251,9 @@ bool KeyCondition::tryPrepareSetIndex(\n         MergeTreeSetIndex::KeyTuplePositionMapping index_mapping;\n         index_mapping.tuple_index = tuple_index;\n         DataTypePtr data_type;\n-        if (isKeyPossiblyWrappedByMonotonicFunctions(node, index_mapping.key_index, data_type, index_mapping.functions))\n+        std::optional<size_t> key_space_filling_curve_argument_pos;\n+        if (isKeyPossiblyWrappedByMonotonicFunctions(node, index_mapping.key_index, key_space_filling_curve_argument_pos, data_type, index_mapping.functions)\n+            && !key_space_filling_curve_argument_pos) /// We don't support the analysis of space-filling curves and IN set.\n         {\n             indexes_mapping.push_back(index_mapping);\n             data_types.push_back(data_type);\n@@ -1412,13 +1461,15 @@ class FunctionWithOptionalConstArg : public IFunctionBase\n bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctions(\n     const RPNBuilderTreeNode & node,\n     size_t & out_key_column_num,\n+    std::optional<size_t> & out_argument_num_of_space_filling_curve,\n     DataTypePtr & out_key_res_column_type,\n     MonotonicFunctionsChain & out_functions_chain)\n {\n     std::vector<RPNBuilderFunctionTreeNode> chain_not_tested_for_monotonicity;\n     DataTypePtr key_column_type;\n \n-    if (!isKeyPossiblyWrappedByMonotonicFunctionsImpl(node, out_key_column_num, key_column_type, chain_not_tested_for_monotonicity))\n+    if (!isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n+        node, out_key_column_num, out_argument_num_of_space_filling_curve, key_column_type, chain_not_tested_for_monotonicity))\n         return false;\n \n     for (auto it = chain_not_tested_for_monotonicity.rbegin(); it != chain_not_tested_for_monotonicity.rend(); ++it)\n@@ -1474,6 +1525,7 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctions(\n bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n     const RPNBuilderTreeNode & node,\n     size_t & out_key_column_num,\n+    std::optional<size_t> & out_argument_num_of_space_filling_curve,\n     DataTypePtr & out_key_column_type,\n     std::vector<RPNBuilderFunctionTreeNode> & out_functions_chain)\n {\n@@ -1492,10 +1544,31 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n     if (key_columns.end() != it)\n     {\n         out_key_column_num = it->second;\n-        out_key_column_type = sample_block.getByName(it->first).type;\n+        out_key_column_type = sample_block.getByName(name).type;\n         return true;\n     }\n \n+    /** The case of space-filling curves.\n+      * When the node is not a key column (e.g. mortonEncode(x, y))\n+      * but one of the arguments of a key column (e.g. x or y).\n+      *\n+      * For example, the table has ORDER BY mortonEncode(x, y)\n+      * and query has WHERE x >= 10 AND x < 15 AND y > 20 AND y <= 25\n+      */\n+    for (const auto & curve : key_space_filling_curves)\n+    {\n+        for (size_t i = 0, size = curve.arguments.size(); i < size; ++i)\n+        {\n+            if (curve.arguments[i] == name)\n+            {\n+                out_key_column_num = curve.key_column_pos;\n+                out_argument_num_of_space_filling_curve = i;\n+                out_key_column_type = sample_block.getByName(name).type;\n+                return true;\n+            }\n+        }\n+    }\n+\n     if (node.isFunction())\n     {\n         auto function_node = node.toFunctionNode();\n@@ -1511,16 +1584,31 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n         {\n             if (function_node.getArgumentAt(0).isConstant())\n             {\n-                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(function_node.getArgumentAt(1), out_key_column_num, out_key_column_type, out_functions_chain);\n+                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n+                    function_node.getArgumentAt(1),\n+                    out_key_column_num,\n+                    out_argument_num_of_space_filling_curve,\n+                    out_key_column_type,\n+                    out_functions_chain);\n             }\n             else if (function_node.getArgumentAt(1).isConstant())\n             {\n-                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(function_node.getArgumentAt(0), out_key_column_num, out_key_column_type, out_functions_chain);\n+                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n+                    function_node.getArgumentAt(0),\n+                    out_key_column_num,\n+                    out_argument_num_of_space_filling_curve,\n+                    out_key_column_type,\n+                    out_functions_chain);\n             }\n         }\n         else\n         {\n-            result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(function_node.getArgumentAt(0), out_key_column_num, out_key_column_type, out_functions_chain);\n+            result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n+                function_node.getArgumentAt(0),\n+                out_key_column_num,\n+                out_argument_num_of_space_filling_curve,\n+                out_key_column_type,\n+                out_functions_chain);\n         }\n \n         return result;\n@@ -1548,7 +1636,12 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n {\n     /** Functions < > = != <= >= in `notIn` isNull isNotNull, where one argument is a constant, and the other is one of columns of key,\n       *  or itself, wrapped in a chain of possibly-monotonic functions,\n-      *  or constant expression - number.\n+      *  (for example, if the table has ORDER BY time, we will check the conditions like\n+      *   toDate(time) = '2023-10-14', toMonth(time) = 12, etc)\n+      *  or any of arguments of a space-filling curve function if it is in the key,\n+      *  (for example, if the table has ORDER BY mortonEncode(x, y), we will check the conditions like x > c, y <= c, etc.)\n+      *  or constant expression - number\n+      *  (for example x AND 0)\n       */\n     Field const_value;\n     DataTypePtr const_type;\n@@ -1557,8 +1650,15 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n         auto func = node.toFunctionNode();\n         size_t num_args = func.getArgumentsSize();\n \n-        DataTypePtr key_expr_type;    /// Type of expression containing key column\n-        size_t key_column_num = -1;   /// Number of a key column (inside key_column_names array)\n+        /// Type of expression containing key column\n+        DataTypePtr key_expr_type;\n+\n+        /// Number of a key column (inside key_column_names array)\n+        size_t key_column_num = -1;\n+\n+        /// For example, if the key is mortonEncode(x, y), and the atom is x, then the argument num is 0.\n+        std::optional<size_t> argument_num_of_space_filling_curve;\n+\n         MonotonicFunctionsChain chain;\n         std::string func_name = func.getFunctionName();\n \n@@ -1567,7 +1667,8 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n \n         if (num_args == 1)\n         {\n-            if (!(isKeyPossiblyWrappedByMonotonicFunctions(func.getArgumentAt(0), key_column_num, key_expr_type, chain)))\n+            if (!(isKeyPossiblyWrappedByMonotonicFunctions(\n+                func.getArgumentAt(0), key_column_num, argument_num_of_space_filling_curve, key_expr_type, chain)))\n                 return false;\n \n             if (key_column_num == static_cast<size_t>(-1))\n@@ -1615,7 +1716,8 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n                     return true;\n                 }\n \n-                if (isKeyPossiblyWrappedByMonotonicFunctions(func.getArgumentAt(0), key_column_num, key_expr_type, chain))\n+                if (isKeyPossiblyWrappedByMonotonicFunctions(\n+                    func.getArgumentAt(0), key_column_num, argument_num_of_space_filling_curve, key_expr_type, chain))\n                 {\n                     key_arg_pos = 0;\n                 }\n@@ -1645,7 +1747,8 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n                     return true;\n                 }\n \n-                if (isKeyPossiblyWrappedByMonotonicFunctions(func.getArgumentAt(1), key_column_num, key_expr_type, chain))\n+                if (isKeyPossiblyWrappedByMonotonicFunctions(\n+                    func.getArgumentAt(1), key_column_num, argument_num_of_space_filling_curve, key_expr_type, chain))\n                 {\n                     key_arg_pos = 1;\n                 }\n@@ -1767,6 +1870,7 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n \n         out.key_column = key_column_num;\n         out.monotonic_functions_chain = std::move(chain);\n+        out.argument_num_of_space_filling_curve = argument_num_of_space_filling_curve;\n \n         return atom_it->second(out, const_value);\n     }\n@@ -1793,6 +1897,95 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n     return false;\n }\n \n+\n+void KeyCondition::findHyperrectanglesForArgumentsOfSpaceFillingCurves()\n+{\n+    /// Traverse chains of AND with conditions on arguments of a space filling curve, and construct hyperrectangles from them.\n+    /// For example, a chain:\n+    ///   x >= 10 AND x <= 20 AND y >= 20 AND y <= 30\n+    /// will be transformed to a single atom:\n+    ///   args in [10, 20] \u00d7 [20, 30]\n+\n+    RPN new_rpn;\n+    new_rpn.reserve(rpn.size());\n+\n+    auto num_arguments_of_a_curve = [&](size_t key_column_pos)\n+    {\n+        for (const auto & curve : key_space_filling_curves)\n+            if (curve.key_column_pos == key_column_pos)\n+                return curve.arguments.size();\n+        return 0uz;\n+    };\n+\n+    for (const auto & elem : rpn)\n+    {\n+        if (elem.function == RPNElement::FUNCTION_IN_RANGE && elem.argument_num_of_space_filling_curve.has_value())\n+        {\n+            /// A range of an argument of a space-filling curve\n+\n+            size_t arg_num = *elem.argument_num_of_space_filling_curve;\n+            size_t curve_total_args = num_arguments_of_a_curve(elem.key_column);\n+\n+            if (!curve_total_args)\n+            {\n+                /// If we didn't find a space-filling curve - replace the condition to unknown.\n+                new_rpn.emplace_back();\n+                continue;\n+            }\n+\n+            chassert(arg_num < curve_total_args);\n+\n+            /// Replace the condition to a hyperrectangle\n+\n+            Hyperrectangle hyperrectangle(curve_total_args, Range::createWholeUniverseWithoutNull());\n+            hyperrectangle[arg_num] = elem.range;\n+\n+            RPNElement collapsed_elem;\n+            collapsed_elem.function = RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE;\n+            collapsed_elem.key_column = elem.key_column;\n+            collapsed_elem.space_filling_curve_args_hyperrectangle = std::move(hyperrectangle);\n+\n+            new_rpn.push_back(std::move(collapsed_elem));\n+            continue;\n+        }\n+        else if (elem.function == RPNElement::FUNCTION_AND && new_rpn.size() >= 2)\n+        {\n+            /// AND of two conditions\n+\n+            const auto & cond1 = new_rpn[new_rpn.size() - 2];\n+            const auto & cond2 = new_rpn[new_rpn.size() - 1];\n+\n+            /// Related to the same column of the key, represented by a space-filling curve\n+\n+            if (cond1.key_column == cond2.key_column\n+                && cond1.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE\n+                && cond2.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE)\n+            {\n+                 /// Intersect these two conditions (applying AND)\n+\n+                RPNElement collapsed_elem;\n+                collapsed_elem.function = RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE;\n+                collapsed_elem.key_column = cond1.key_column;\n+                collapsed_elem.space_filling_curve_args_hyperrectangle = intersect(\n+                    cond1.space_filling_curve_args_hyperrectangle,\n+                    cond2.space_filling_curve_args_hyperrectangle);\n+\n+                /// Replace the AND operation with its arguments to the collapsed condition\n+\n+                new_rpn.pop_back();\n+                new_rpn.pop_back();\n+                new_rpn.push_back(std::move(collapsed_elem));\n+                continue;\n+            }\n+        }\n+\n+        new_rpn.push_back(elem);\n+    }\n+\n+    rpn = std::move(new_rpn);\n+}\n+\n+\n String KeyCondition::toString() const\n {\n     String res;\n@@ -1912,7 +2105,8 @@ KeyCondition::Description KeyCondition::getDescription() const\n             || element.function == RPNElement::FUNCTION_IS_NULL\n             || element.function == RPNElement::FUNCTION_IS_NOT_NULL\n             || element.function == RPNElement::FUNCTION_IN_SET\n-            || element.function == RPNElement::FUNCTION_NOT_IN_SET)\n+            || element.function == RPNElement::FUNCTION_NOT_IN_SET\n+            || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE)\n         {\n             auto can_be_true = std::make_unique<Node>(Node{.type = Node::Type::Leaf, .element = &element, .negate = false});\n             auto can_be_false = std::make_unique<Node>(Node{.type = Node::Type::Leaf, .element = &element, .negate = true});\n@@ -1974,9 +2168,9 @@ KeyCondition::Description KeyCondition::getDescription() const\n     }\n \n     if (rpn_stack.size() != 1)\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected stack size in KeyCondition::checkInRange\");\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected stack size in KeyCondition::getDescription\");\n \n-    std::vector<std::string_view> key_names(key_columns.size());\n+    std::vector<String> key_names(key_columns.size());\n     std::vector<bool> is_key_used(key_columns.size(), false);\n \n     for (const auto & key : key_columns)\n@@ -2061,13 +2255,13 @@ KeyCondition::Description KeyCondition::getDescription() const\n   *\n   * The range of tuples can always be represented as a combination (union) of hyperrectangles.\n   * For example, the range [ x1 y1 .. x2 y2 ] given x1 != x2 is equal to the union of the following three hyperrectangles:\n-  * [x1]       x [y1 .. +inf)\n-  * (x1 .. x2) x (-inf .. +inf)\n-  * [x2]       x (-inf .. y2]\n+  * [x1]       \u00d7 [y1 .. +inf)\n+  * (x1 .. x2) \u00d7 (-inf .. +inf)\n+  * [x2]       \u00d7 (-inf .. y2]\n   *\n   * Or, for example, the range [ x1 y1 .. +inf ] is equal to the union of the following two hyperrectangles:\n-  * [x1]         x [y1 .. +inf)\n-  * (x1 .. +inf) x (-inf .. +inf)\n+  * [x1]         \u00d7 [y1 .. +inf)\n+  * (x1 .. +inf) \u00d7 (-inf .. +inf)\n   * It's easy to see that this is a special case of the variant above.\n   *\n   * This is important because it is easy for us to check the feasibility of the condition over the hyperrectangle,\n@@ -2075,6 +2269,10 @@ KeyCondition::Description KeyCondition::getDescription() const\n   *  over at least one hyperrectangle from which this range consists.\n   */\n \n+/** For the range between tuples, determined by left_keys, left_bounded, right_keys, right_bounded,\n+  * invoke the callback on every parallelogram composing this range (see the description above),\n+  * and returns the OR of the callback results (meaning if callback returned true on any part of the range).\n+  */\n template <typename F>\n static BoolMask forAnyHyperrectangle(\n     size_t key_size,\n@@ -2082,7 +2280,7 @@ static BoolMask forAnyHyperrectangle(\n     const FieldRef * right_keys,\n     bool left_bounded,\n     bool right_bounded,\n-    Hyperrectangle & hyperrectangle,\n+    Hyperrectangle & hyperrectangle, /// This argument is modified in-place for the callback\n     const DataTypes & data_types,\n     size_t prefix_size,\n     BoolMask initial_mask,\n@@ -2122,7 +2320,7 @@ static BoolMask forAnyHyperrectangle(\n         return callback(hyperrectangle);\n     }\n \n-    /// (x1 .. x2) x (-inf .. +inf)\n+    /// (x1 .. x2) \u00d7 (-inf .. +inf)\n \n     if (left_bounded && right_bounded)\n         hyperrectangle[prefix_size] = Range(left_keys[prefix_size], false, right_keys[prefix_size], false);\n@@ -2139,7 +2337,6 @@ static BoolMask forAnyHyperrectangle(\n             hyperrectangle[i] = Range::createWholeUniverseWithoutNull();\n     }\n \n-\n     BoolMask result = initial_mask;\n     result = result | callback(hyperrectangle);\n \n@@ -2150,26 +2347,26 @@ static BoolMask forAnyHyperrectangle(\n     if (result.isComplete())\n         return result;\n \n-    /// [x1]       x [y1 .. +inf)\n+    /// [x1]       \u00d7 [y1 .. +inf)\n \n     if (left_bounded)\n     {\n         hyperrectangle[prefix_size] = Range(left_keys[prefix_size]);\n         result = result\n             | forAnyHyperrectangle(\n-                     key_size, left_keys, right_keys, true, false, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);\n+                key_size, left_keys, right_keys, true, false, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);\n         if (result.isComplete())\n             return result;\n     }\n \n-    /// [x2]       x (-inf .. y2]\n+    /// [x2]       \u00d7 (-inf .. y2]\n \n     if (right_bounded)\n     {\n         hyperrectangle[prefix_size] = Range(right_keys[prefix_size]);\n         result = result\n             | forAnyHyperrectangle(\n-                     key_size, left_keys, right_keys, false, true, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);\n+                key_size, left_keys, right_keys, false, true, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);\n         if (result.isComplete())\n             return result;\n     }\n@@ -2196,14 +2393,14 @@ BoolMask KeyCondition::checkInRange(\n             key_ranges.push_back(Range::createWholeUniverseWithoutNull());\n     }\n \n-    // std::cerr << \"Checking for: [\";\n-    // for (size_t i = 0; i != used_key_size; ++i)\n-    //     std::cerr << (i != 0 ? \", \" : \"\") << applyVisitor(FieldVisitorToString(), left_keys[i]);\n-    // std::cerr << \" ... \";\n+/*    std::cerr << \"Checking for: [\";\n+    for (size_t i = 0; i != used_key_size; ++i)\n+        std::cerr << (i != 0 ? \", \" : \"\") << applyVisitor(FieldVisitorToString(), left_keys[i]);\n+    std::cerr << \" ... \";\n \n-    // for (size_t i = 0; i != used_key_size; ++i)\n-    //     std::cerr << (i != 0 ? \", \" : \"\") << applyVisitor(FieldVisitorToString(), right_keys[i]);\n-    // std::cerr << \"]\\n\";\n+    for (size_t i = 0; i != used_key_size; ++i)\n+        std::cerr << (i != 0 ? \", \" : \"\") << applyVisitor(FieldVisitorToString(), right_keys[i]);\n+    std::cerr << \"]\\n\";*/\n \n     return forAnyHyperrectangle(used_key_size, left_keys, right_keys, true, true, key_ranges, data_types, 0, initial_mask,\n         [&] (const Hyperrectangle & key_ranges_hyperrectangle)\n@@ -2212,7 +2409,7 @@ BoolMask KeyCondition::checkInRange(\n \n         // std::cerr << \"Hyperrectangle: \";\n         // for (size_t i = 0, size = key_ranges.size(); i != size; ++i)\n-        //     std::cerr << (i != 0 ? \" x \" : \"\") << key_ranges[i].toString();\n+        //     std::cerr << (i != 0 ? \" \u00d7 \" : \"\") << key_ranges[i].toString();\n         // std::cerr << \": \" << res.can_be_true << \"\\n\";\n \n         return res;\n@@ -2347,7 +2544,13 @@ BoolMask KeyCondition::checkInHyperrectangle(\n     std::vector<BoolMask> rpn_stack;\n     for (const auto & element : rpn)\n     {\n-        if (element.function == RPNElement::FUNCTION_UNKNOWN)\n+        if (element.argument_num_of_space_filling_curve.has_value())\n+        {\n+            /// If a condition on argument of a space filling curve wasn't collapsed into FUNCTION_ARGS_IN_HYPERRECTANGLE,\n+            /// we cannot process it.\n+            rpn_stack.emplace_back(true, true);\n+        }\n+        else if (element.function == RPNElement::FUNCTION_UNKNOWN)\n         {\n             rpn_stack.emplace_back(true, true);\n         }\n@@ -2383,6 +2586,97 @@ BoolMask KeyCondition::checkInHyperrectangle(\n             if (element.function == RPNElement::FUNCTION_NOT_IN_RANGE)\n                 rpn_stack.back() = !rpn_stack.back();\n         }\n+        else if (element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE)\n+        {\n+            /** The case of space-filling curves.\n+              * We unpack the range of a space filling curve into hyperrectangles of their arguments,\n+              * and then check the intersection of them with the given hyperrectangle from the key condition.\n+              *\n+              * Note: you might find this code hard to understand,\n+              * because there are three different hyperrectangles involved:\n+              *\n+              * 1. A hyperrectangle derived from the range of the table's sparse index (marks granule): `hyperrectangle`\n+              *    We analyze its dimension `key_range`, corresponding to the `key_column`.\n+              *    For example, the table's key is a single column `mortonEncode(x, y)`,\n+              *    the current granule is [500, 600], and it means that\n+              *    mortonEncode(x, y) in [500, 600]\n+              *\n+              * 2. A hyperrectangle derived from the key condition, e.g.\n+              *    `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30` defines: (x, y) in [10, 20] \u00d7 [20, 30]\n+              *\n+              * 3. A set of hyperrectangles that we obtain by inverting the space-filling curve on the range:\n+              *    From mortonEncode(x, y) in [500, 600]\n+              *    We get (x, y) in [30, 31] \u00d7 [12, 13]\n+              *        or (x, y) in [28, 31] \u00d7 [14, 15];\n+              *        or (x, y) in [0, 7] \u00d7 [16, 23];\n+              *        or (x, y) in [8, 11] \u00d7 [16, 19];\n+              *        or (x, y) in [12, 15] \u00d7 [16, 17];\n+              *        or (x, y) in [12, 12] \u00d7 [18, 18];\n+              *\n+              *  And we analyze the intersection of (2) and (3).\n+              */\n+\n+            Range key_range = hyperrectangle[element.key_column];\n+\n+            /// The only possible result type of a space filling curve is UInt64.\n+            /// We also only check bounded ranges.\n+            if (key_range.left.getType() == Field::Types::UInt64\n+                && key_range.right.getType() == Field::Types::UInt64)\n+            {\n+                key_range.shrinkToIncludedIfPossible();\n+\n+                size_t num_dimensions = element.space_filling_curve_args_hyperrectangle.size();\n+\n+                /// Let's support only the case of 2d, because I'm not confident in other cases.\n+                if (num_dimensions == 2)\n+                {\n+                    UInt64 left = key_range.left.get<UInt64>();\n+                    UInt64 right = key_range.right.get<UInt64>();\n+\n+                    BoolMask mask(false, true);\n+                    mortonIntervalToHyperrectangles<2>(left, right,\n+                        [&](std::array<std::pair<UInt64, UInt64>, 2> morton_hyperrectangle)\n+                        {\n+                            BoolMask current_intersection(true, false);\n+                            for (size_t dim = 0; dim < num_dimensions; ++dim)\n+                            {\n+                                const Range & condition_arg_range = element.space_filling_curve_args_hyperrectangle[dim];\n+\n+                                const Range morton_arg_range(\n+                                    morton_hyperrectangle[dim].first, true,\n+                                    morton_hyperrectangle[dim].second, true);\n+\n+                                bool intersects = condition_arg_range.intersectsRange(morton_arg_range);\n+                                bool contains = condition_arg_range.containsRange(morton_arg_range);\n+\n+                                current_intersection = current_intersection & BoolMask(intersects, !contains);\n+                            }\n+\n+                            mask = mask | current_intersection;\n+                        });\n+\n+                    rpn_stack.emplace_back(mask);\n+                }\n+                else\n+                    rpn_stack.emplace_back(true, true);\n+            }\n+            else\n+                rpn_stack.emplace_back(true, true);\n+\n+            /** Note: we can consider implementing a simpler solution, based on \"hidden keys\".\n+              * It means, when we have a table's key like (a, b, mortonCurve(x, y))\n+              * we extract the arguments from the curves, and append them to the key,\n+              * imagining that we have the key (a, b, mortonCurve(x, y), x, y)\n+              *\n+              * Then while we analyze the granule's range between (a, b, mortonCurve(x, y))\n+              * and decompose it to the series of hyperrectangles,\n+              * we can construct a series of hyperrectangles of the extended key (a, b, mortonCurve(x, y), x, y),\n+              * and then do everything as usual.\n+              *\n+              * This approach is generalizable to any functions, that have preimage of interval\n+              * represented by a set of hyperrectangles.\n+              */\n+        }\n         else if (\n             element.function == RPNElement::FUNCTION_IS_NULL\n             || element.function == RPNElement::FUNCTION_IS_NOT_NULL)\n@@ -2445,7 +2739,7 @@ BoolMask KeyCondition::checkInHyperrectangle(\n     }\n \n     if (rpn_stack.size() != 1)\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected stack size in KeyCondition::checkInRange\");\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected stack size in KeyCondition::checkInHyperrectangle\");\n \n     return rpn_stack[0];\n }\n@@ -2459,11 +2753,17 @@ bool KeyCondition::mayBeTrueInRange(\n     return checkInRange(used_key_size, left_keys, right_keys, data_types, BoolMask::consider_only_can_be_true).can_be_true;\n }\n \n-String KeyCondition::RPNElement::toString() const { return toString(\"column \" + std::to_string(key_column), false); }\n+String KeyCondition::RPNElement::toString() const\n+{\n+    if (argument_num_of_space_filling_curve)\n+        return toString(fmt::format(\"argument {} of column {}\", *argument_num_of_space_filling_curve, key_column), false);\n+    else\n+        return toString(fmt::format(\"column {}\", key_column), false);\n+}\n \n String KeyCondition::RPNElement::toString(std::string_view column_name, bool print_constants) const\n {\n-    auto print_wrapped_column = [this, &column_name, print_constants](WriteBuffer & buf)\n+    auto print_wrapped_column = [this, column_name, print_constants](WriteBuffer & buf)\n     {\n         for (auto it = monotonic_functions_chain.rbegin(); it != monotonic_functions_chain.rend(); ++it)\n         {\n@@ -2527,6 +2827,15 @@ String KeyCondition::RPNElement::toString(std::string_view column_name, bool pri\n             buf << \")\";\n             return buf.str();\n         }\n+        case FUNCTION_ARGS_IN_HYPERRECTANGLE:\n+        {\n+            buf << \"(\";\n+            print_wrapped_column(buf);\n+            buf << \" has args in \";\n+            buf << DB::toString(space_filling_curve_args_hyperrectangle);\n+            buf << \")\";\n+            return buf.str();\n+        }\n         case FUNCTION_IS_NULL:\n         case FUNCTION_IS_NOT_NULL:\n         {\n@@ -2579,6 +2888,7 @@ bool KeyCondition::unknownOrAlwaysTrue(bool unknown_any) const\n             || element.function == RPNElement::FUNCTION_IN_RANGE\n             || element.function == RPNElement::FUNCTION_IN_SET\n             || element.function == RPNElement::FUNCTION_NOT_IN_SET\n+            || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE\n             || element.function == RPNElement::FUNCTION_IS_NULL\n             || element.function == RPNElement::FUNCTION_IS_NOT_NULL\n             || element.function == RPNElement::ALWAYS_FALSE)\n@@ -2635,6 +2945,7 @@ bool KeyCondition::alwaysFalse() const\n             || element.function == RPNElement::FUNCTION_IN_RANGE\n             || element.function == RPNElement::FUNCTION_IN_SET\n             || element.function == RPNElement::FUNCTION_NOT_IN_SET\n+            || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE\n             || element.function == RPNElement::FUNCTION_IS_NULL\n             || element.function == RPNElement::FUNCTION_IS_NOT_NULL\n             || element.function == RPNElement::FUNCTION_UNKNOWN)\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex 6bc044c4dd43..fa5573e5d61b 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -172,7 +172,15 @@ class KeyCondition\n             FUNCTION_NOT_IN_SET,\n             FUNCTION_IS_NULL,\n             FUNCTION_IS_NOT_NULL,\n-            FUNCTION_UNKNOWN, /// Can take any value.\n+            /// Special for space-filling curves.\n+            /// For example, if key is mortonEncode(x, y),\n+            /// and the condition contains its arguments, e.g.:\n+            ///   x >= 10 AND x <= 20 AND y >= 20 AND y <= 30,\n+            /// this expression will be analyzed and then represented by following:\n+            ///   args in hyperrectangle [10, 20] \u00d7 [20, 30].\n+            FUNCTION_ARGS_IN_HYPERRECTANGLE,\n+            /// Can take any value.\n+            FUNCTION_UNKNOWN,\n             /// Operators of the logical expression.\n             FUNCTION_NOT,\n             FUNCTION_AND,\n@@ -196,10 +204,19 @@ class KeyCondition\n         /// For FUNCTION_IN_RANGE and FUNCTION_NOT_IN_RANGE.\n         Range range = Range::createWholeUniverse();\n         size_t key_column = 0;\n+\n+        /// If the key_column is a space filling curve, e.g. mortonEncode(x, y),\n+        /// we will analyze expressions of its arguments (x and y) similarly how we do for a normal key columns,\n+        /// and this designates the argument number (0 for x, 1 for y):\n+        std::optional<size_t> argument_num_of_space_filling_curve;\n+\n         /// For FUNCTION_IN_SET, FUNCTION_NOT_IN_SET\n         using MergeTreeSetIndexPtr = std::shared_ptr<const MergeTreeSetIndex>;\n         MergeTreeSetIndexPtr set_index;\n \n+        /// For FUNCTION_ARGS_IN_HYPERRECTANGLE\n+        Hyperrectangle space_filling_curve_args_hyperrectangle;\n+\n         MonotonicFunctionsChain monotonic_functions_chain;\n     };\n \n@@ -223,21 +240,25 @@ class KeyCondition\n \n     bool extractAtomFromTree(const RPNBuilderTreeNode & node, RPNElement & out);\n \n-    /** Is node the key column\n-      *  or expression in which column of key is wrapped by chain of functions,\n+    /** Is node the key column, or an argument of a space-filling curve that is a key column,\n+      *  or expression in which that column is wrapped by a chain of functions,\n       *  that can be monotonic on certain ranges?\n-      * If these conditions are true, then returns number of column in key, type of resulting expression\n+      * If these conditions are true, then returns number of column in key,\n+      *  optionally the argument position of a space-filling curve,\n+      *  type of resulting expression\n       *  and fills chain of possibly-monotonic functions.\n       */\n     bool isKeyPossiblyWrappedByMonotonicFunctions(\n         const RPNBuilderTreeNode & node,\n         size_t & out_key_column_num,\n+        std::optional<size_t> & out_argument_num_of_space_filling_curve,\n         DataTypePtr & out_key_res_column_type,\n         MonotonicFunctionsChain & out_functions_chain);\n \n     bool isKeyPossiblyWrappedByMonotonicFunctionsImpl(\n         const RPNBuilderTreeNode & node,\n         size_t & out_key_column_num,\n+        std::optional<size_t> & out_argument_num_of_space_filling_curve,\n         DataTypePtr & out_key_column_type,\n         std::vector<RPNBuilderFunctionTreeNode> & out_functions_chain);\n \n@@ -296,6 +317,11 @@ class KeyCondition\n     ///   and all, two, partitions will be scanned, but due to filtering later none of rows will be matched.\n     bool unknownOrAlwaysTrue(bool unknown_any) const;\n \n+    /** Iterates over RPN and collapses FUNCTION_IN_RANGE over the arguments of space-filling curve function\n+      * into atom of type FUNCTION_ARGS_IN_HYPERRECTANGLE.\n+      */\n+    void findHyperrectanglesForArgumentsOfSpaceFillingCurves();\n+\n     RPN rpn;\n \n     ColumnIndices key_columns;\n@@ -306,6 +332,17 @@ class KeyCondition\n     /// All intermediate columns are used to calculate key_expr.\n     const NameSet key_subexpr_names;\n \n+    /// Space-filling curves in the key\n+    struct SpaceFillingCurveDescription\n+    {\n+        size_t key_column_pos;\n+        String function_name;\n+        std::vector<String> arguments;\n+    };\n+    using SpaceFillingCurveDescriptions = std::vector<SpaceFillingCurveDescription>;\n+    SpaceFillingCurveDescriptions key_space_filling_curves;\n+    void getAllSpaceFillingCurves();\n+\n     /// Array joined column names\n     NameSet array_joined_column_names;\n \n",
  "test_patch": "diff --git a/src/Common/tests/gtest_morton_utils.cpp b/src/Common/tests/gtest_morton_utils.cpp\nnew file mode 100644\nindex 000000000000..c2cbce2c3e15\n--- /dev/null\n+++ b/src/Common/tests/gtest_morton_utils.cpp\n@@ -0,0 +1,131 @@\n+#include <gtest/gtest.h>\n+#include <iostream>\n+#include <Common/MortonUtils.h>\n+\n+\n+GTEST_TEST(MortonUtils, Intervals)\n+{\n+    {\n+        std::stringstream res;\n+        intervalBinaryPartition(6, 13, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+        ASSERT_EQ(res.str(), \"6, 7; 8, 11; 12, 13; \");\n+    }\n+\n+    {\n+        std::stringstream res;\n+        intervalBinaryPartition(15, 31, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+        ASSERT_EQ(res.str(), \"15, 15; 16, 31; \");\n+    }\n+\n+    {\n+        std::stringstream res;\n+        intervalBinaryPartition(15, 16, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+        ASSERT_EQ(res.str(), \"15, 15; 16, 16; \");\n+    }\n+\n+    {\n+        std::stringstream res;\n+        intervalBinaryPartition(191, 769, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+        ASSERT_EQ(res.str(), \"191, 191; 192, 255; 256, 511; 512, 767; 768, 769; \");\n+    }\n+\n+    {\n+        std::array<std::pair<UInt64, UInt64>, 2> input = {std::pair{6, 13}, std::pair{15, 31}};\n+\n+        std::stringstream res;\n+        hyperrectangleBinaryPartition<2>(input, [&](auto hyperrectangle)\n+        {\n+            res << \"[\" << hyperrectangle[0].first << \", \" << hyperrectangle[0].second\n+                << \"] x [\" << hyperrectangle[1].first << \", \" << hyperrectangle[1].second\n+                << \"]; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"[6, 7] x [15, 15]; [6, 7] x [16, 31]; [8, 11] x [15, 15]; [8, 11] x [16, 31]; [12, 13] x [15, 15]; [12, 13] x [16, 31]; \");\n+    }\n+\n+    {\n+        std::array<std::pair<UInt64, UInt64>, 2> input = {std::pair{23, 24}, std::pair{15, 16}};\n+\n+        std::stringstream res;\n+        hyperrectangleBinaryPartition<2>(input, [&](auto hyperrectangle)\n+        {\n+            res << \"[\" << hyperrectangle[0].first << \", \" << hyperrectangle[0].second\n+                << \"] x [\" << hyperrectangle[1].first << \", \" << hyperrectangle[1].second\n+                << \"]; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"[23, 23] x [15, 15]; [23, 23] x [16, 16]; [24, 24] x [15, 15]; [24, 24] x [16, 16]; \");\n+    }\n+\n+    {\n+        std::stringstream res;\n+        mortonIntervalToHyperrectangles<2>(191, 769, [&](auto hyperrectangle)\n+        {\n+            res << \"[\" << hyperrectangle[0].first << \", \" << hyperrectangle[0].second\n+                << \"] x [\" << hyperrectangle[1].first << \", \" << hyperrectangle[1].second\n+                << \"]; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"[7, 7] x [15, 15]; [8, 15] x [8, 15]; [16, 31] x [0, 15]; [0, 15] x [16, 31]; [16, 17] x [16, 16]; \");\n+    }\n+\n+    {\n+        std::stringstream res;\n+        mortonIntervalToHyperrectangles<2>(500, 600, [&](auto hyperrectangle)\n+        {\n+            res << \"[\" << hyperrectangle[0].first << \", \" << hyperrectangle[0].second\n+                << \"] x [\" << hyperrectangle[1].first << \", \" << hyperrectangle[1].second\n+                << \"]; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"[30, 31] x [12, 13]; [28, 31] x [14, 15]; [0, 7] x [16, 23]; [8, 11] x [16, 19]; [12, 15] x [16, 17]; [12, 12] x [18, 18]; \");\n+    }\n+\n+    {\n+        std::array<std::pair<UInt64, UInt64>, 2> input = {std::pair{23, 24}, std::pair{15, 16}};\n+\n+        std::stringstream res;\n+        hyperrectangleToPossibleMortonIntervals<2>(input, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"447, 447; 789, 789; 490, 490; 832, 832; \");\n+    }\n+\n+    {\n+        std::array<std::pair<UInt64, UInt64>, 2> input = {std::pair{6, 7}, std::pair{16, 31}};\n+\n+        std::stringstream res;\n+        hyperrectangleToPossibleMortonIntervals<2>(input, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"512, 767; \");\n+    }\n+\n+    {\n+        std::array<std::pair<UInt64, UInt64>, 2> input = {std::pair{6, 13}, std::pair{15, 31}};\n+\n+        std::stringstream res;\n+        hyperrectangleToPossibleMortonIntervals<2>(input, [&](UInt64 first, UInt64 last)\n+        {\n+            res << first << \", \" << last << \"; \";\n+        });\n+\n+        ASSERT_EQ(res.str(), \"188, 191; 512, 767; 224, 239; 248, 251; \");\n+    }\n+}\ndiff --git a/tests/queries/0_stateless/02899_indexing_by_space_filling_curves.reference b/tests/queries/0_stateless/02899_indexing_by_space_filling_curves.reference\nnew file mode 100644\nindex 000000000000..6e8a5df9145f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02899_indexing_by_space_filling_curves.reference\n@@ -0,0 +1,9 @@\n+121\n+121\n+32\n+21\n+10\n+32\n+22\n+11\n+1\ndiff --git a/tests/queries/0_stateless/02899_indexing_by_space_filling_curves.sql b/tests/queries/0_stateless/02899_indexing_by_space_filling_curves.sql\nnew file mode 100644\nindex 000000000000..c7325b2478dc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02899_indexing_by_space_filling_curves.sql\n@@ -0,0 +1,35 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test (x UInt32, y UInt32) ENGINE = MergeTree ORDER BY mortonEncode(x, y) SETTINGS index_granularity = 8192, index_granularity_bytes = '1Mi';\n+INSERT INTO test SELECT number DIV 1024, number % 1024 FROM numbers(1048576);\n+\n+SET max_rows_to_read = 8192, force_primary_key = 1, analyze_index_with_space_filling_curves = 1;\n+SELECT count() FROM test WHERE x >= 10 AND x <= 20 AND y >= 20 AND y <= 30;\n+\n+SET max_rows_to_read = 8192, force_primary_key = 1, analyze_index_with_space_filling_curves = 0;\n+SELECT count() FROM test WHERE x >= 10 AND x <= 20 AND y >= 20 AND y <= 30;  -- { serverError 277 }\n+\n+DROP TABLE test;\n+\n+-- The same, but with more precise index\n+\n+CREATE TABLE test (x UInt32, y UInt32) ENGINE = MergeTree ORDER BY mortonEncode(x, y) SETTINGS index_granularity = 1;\n+SET max_rows_to_read = 0;\n+INSERT INTO test SELECT number DIV 32, number % 32 FROM numbers(1024);\n+\n+SET max_rows_to_read = 200, force_primary_key = 1, analyze_index_with_space_filling_curves = 1;\n+SELECT count() FROM test WHERE x >= 10 AND x <= 20 AND y >= 20 AND y <= 30;\n+\n+-- Various other conditions\n+\n+SELECT count() FROM test WHERE x = 10 SETTINGS max_rows_to_read = 64;\n+SELECT count() FROM test WHERE x = 10 AND y > 10 SETTINGS max_rows_to_read = 42;\n+SELECT count() FROM test WHERE x = 10 AND y < 10 SETTINGS max_rows_to_read = 20;\n+\n+SELECT count() FROM test WHERE y = 10 SETTINGS max_rows_to_read = 48;\n+SELECT count() FROM test WHERE x >= 10 AND y = 10 SETTINGS max_rows_to_read = 33;\n+SELECT count() FROM test WHERE y = 10 AND x <= 10 SETTINGS max_rows_to_read = 17;\n+\n+SELECT count() FROM test PREWHERE x >= 10 WHERE x < 11 AND y = 10 SETTINGS max_rows_to_read = 3;\n+\n+DROP TABLE test;\n",
  "problem_statement": "Indexing by space-filling curves.\nThis task consists of two parts:\r\n\r\n## 1. Implement one or a few functions for space-filling curves in SQL.\r\n\r\n`zCurve` or `mortonCode` (choose the name more pleasant for you).\r\n\r\nIt takes an arbitrary number of integer arguments of arbitrary size, and returns UInt64 using the following algorithm:\r\n\r\nIf the argument is a signed number, convert it to unsigned number of the same width, using zigzag encoding.\r\n\r\nIf the argument width is less than 32 bits, convert it to UInt32 and shift left, so it will be aligned to the most significant bit.\r\n\r\nIterate over bits of the arguments, starting with the most significant bit. For every bit position, iterate over the arguments, extract the corresponding bit and put it as the bit of the result, starting with the most significant bit of the result.\r\n\r\nIf all 64 bits of the results were filled, finish the operation.\r\n\r\n\r\n### Example 1:\r\n\r\nTwo UInt32 numbers:\r\n\r\n```\r\n           bits, <-- most significant -------------- least significant -->\r\nx, UInt32: a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f\r\ny, UInt32: A B C D E F G H I J K L M N O P Q R S T U V W X Y Z A B C D E F\r\n\r\nResult:\r\nr, UInt64: a A b B c C d D e E f F g G h H i I j J k K l L m M n N o O p P q Q r R s S t T u U v V w W x X y Y z Z a A b B c C d D e E f F\r\n```\r\n\r\n### Example 2: numbers of different width:\r\n\r\n```\r\nx, UInt32: a b c d e f g h i j k l m n o p q r s t u v w x y z a b c d e f\r\ny, UInt8:  A B C D E F G H\r\n\r\nResult:\r\nr, UInt64: a A b B c C d D e E f F g G h H i 0 j 0 k 0 l 0 m 0 n 0 o 0 p 0 q 0 r 0 s 0 t 0 u 0 v 0 w 0 x 0 y 0 z 0 a 0 b 0 c 0 d 0 e 0 f 0\r\n```\r\n\r\n### Example 3: more than two arguments:\r\n\r\n```\r\nx, UInt16: a b c d e f g h i j k l m n o p\r\ny, UInt16: q r s t u v w x y z a b c d e f\r\nz, UInt16: g h i j k l m n o p q r s t u v\r\n\r\nr, UInt64: a q g b r h c s i d t j e u k f v l g w m h x n i y o j z p k a q l b r m c s n d t o e u p v f 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0 0\r\n```\r\n\r\nThe special case of two numbers can be additionally optimized.\r\nNote that Geo Hash is a special case of Z-order curve, and it can be reviewed as well.\r\n\r\nYou can also implement Hilbert Curve and Peano Curve if needed.\r\n\r\n\r\n## 2. Implement index analysis to support ordering by space filling curves.\r\n\r\nLet's suppose the user has created a table ordered by some function of multiple arguments:\r\n\r\n```\r\nCREATE TABLE t ... ORDER BY f(x1, x2, ...)\r\n```\r\n\r\nLet's suppose the function `f` allows to obtain a *preimage of a result range as a union of hyperrectangles in the space of its arguments*.\r\n\r\nSo, for example, \r\nif `a <= f(x, y) <= b` (this represents a granule in MergeTree)\r\nthen an expression of form `(xa1 <= x <= xb1 AND ya1 <= y <= yb1) OR (xa2 <= x <= xb2 AND ya2 <= y <= yb2) OR ...` can be derived.\r\n\r\n(The boundaries can be infinities; the comparison can be strict or non-strict, see `forAnyHyperrectangle` in `KeyCondition.cpp`)\r\n\r\nZ-order curve is an example of a function of this kind.\r\nSee the picture: https://en.wikipedia.org/wiki/Z-order_curve#/media/File:BIGMIN_search_in_a_Z-order_curve.svg\r\n\r\nAdd a method to `IFunction` to obtain this preimage. \r\nAdd a method to `IFunction` to check if the function allows to obtain this preimage.\r\n\r\nThen simply use these methods in KeyCondition.\r\nSee `forAnyHyperrectangle` in `KeyCondition.cpp`\r\n\r\nNote: when this index analysis will work, the user will not have to use `zCurve` function in the SELECT query. The user will write a query with conditions on the arguments (x, y) as usual, and the analysis of the space-filling curve will happen under the hood, and automatically skip the granules; while the granules determine the boundaries of the values of `zCurve` on the arguments.\r\n\r\nNote: it may sound complicated but it isn't. In fact, we already do this \"range preimage\" operation on the `tuple` function, by reversing the range of tuple values in lexicographic order.\n",
  "hints_text": "I can implement it using a pretty efficient https://github.com/morton-nd/morton-nd\r\nBut it uses `constexpr` and friends to do compile-time specifications. Which means there would be a hard limit on number of dimensions. Is it ok? If ok, then what's the limit? (I would say 8 is a good number, leaves 8 bit per dimension)\r\n\n@pkit This is ok.\r\nYes, 8 is reasonable.\nLooks like a good library :+1: Although I didn't find functions for range preimages, there is no requirement on their speed, we can implement them ad-hoc.\nLet's name the functions `mortonEncode`, `mortonDecode` (returning tuple).\nOk, I think I don't have more questions for now. Will start it.\nRecently I've been talking with a colleague about this and came up with a little different solution for Z index analysis as follow:\r\nAssume that we have the table:\r\n```\r\nCREATE TABLE t ... ORDER BY zCurve(x1, x2, x3);\r\n```\r\nNormally, MergeTree engines will create primary index on `zCurve(x1, x2, x3)`. Instead of that, we think we can create **minmax index for each column `x1`, `x2`, `x3`** (data is still sorted by `zCurve(x1, x2, x3)`). So when queries come with any kind of condition on `x1`, `x2`, `x3`, we can use the minmax index to filter marks (no primary index needed).\r\nWe think that the approach naturally works, and it's simpler than deriving `x1`, `x2`, `x3` ranges from  `zCurve(x1, x2, x3)` ranges. However, the  drawbacks are:\r\n- We cannot mix `zCurve` with normal ordering keys\r\n- We cannot use the same primary index analysis for Z ordering and normal ordering\r\n- Mark ranges filtering from key conditions for Z index is always O(num_marks_in_part)\r\n\r\n@alexey-milovidov @pkit how do you think about this approach? Thanks!\nShare another interesting finding that the approach we mentioned above can be simulated w/o any code changes. We did an experiment as follow:\r\n\r\nTL;DR: the example in this comment is not good, see more comprehensive experiments in https://github.com/ClickHouse/ClickHouse/issues/41195#issuecomment-1319700856\r\n---\r\nPrepare tables:\r\n```sql\r\n-- Create a normal lexical order table\r\nCREATE TABLE test_pk_lexical\r\n(\r\n    `x` UInt64,\r\n    `y` UInt64,\r\n    `z` UInt64,\r\n    `t` UInt64\r\n)\r\nENGINE = MergeTree\r\nORDER BY (x, y, z, t);\r\n-- Create a zorder table w. minmax index on each order key and w/o primary keys\r\nCREATE TABLE test_pk_zorder\r\n(\r\n    `x` UInt64,\r\n    `y` UInt64,\r\n    `z` UInt64,\r\n    `t` UInt64,\r\n    INDEX z_x x TYPE minmax GRANULARITY 1,\r\n    INDEX z_y y TYPE minmax GRANULARITY 1,\r\n    INDEX z_z z TYPE minmax GRANULARITY 1,\r\n    INDEX z_t t TYPE minmax GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPRIMARY KEY tuple()\r\nORDER BY mortonEncode(x, y, z, t);\r\n-- Make sure 2 tables have same data\r\nINSERT INTO test_pk_lexical SELECT rand(), rand(), rand(), rand() FROM numbers(100000000);\r\nINSERT INTO test_pk_zorder SELECT * FROM test_pk_lexical ORDER BY x, y, z, y;\r\n```\r\nNow let try a select query:\r\n```sql\r\n-- lexical table\r\nlocalhost :) SELECT * FROM test_pk_lexical where y in (43242, 545) and t in (747348, 3149823) FORMAT Null\r\n\r\nSELECT *\r\nFROM test_pk_lexical\r\nWHERE (y IN (43242, 545)) AND (t IN (747348, 3149823))\r\nFORMAT `Null`\r\n\r\nQuery id: 79b7cd0d-58d6-49d0-b3e0-e6c0f367dd56\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.090 sec. Processed 100.00 million rows, 800.00 MB (1.11 billion rows/s., 8.84 GB/s.)\r\n--- zorder table\r\nlocalhost :) SELECT * FROM test_pk_zorder where y in (43242, 545) and t in (747348, 3149823) FORMAT Null\r\n\r\nSELECT *\r\nFROM test_pk_zorder\r\nWHERE (y IN (43242, 545)) AND (t IN (747348, 3149823))\r\nFORMAT `Null`\r\n\r\nQuery id: 8820e49e-c5fd-4869-8ea5-9721c6f7eba5\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.027 sec. Processed 6.96 million rows, 55.81 MB (259.18 million rows/s., 2.08 GB/s.)\r\n```\r\nWith Z index, we got much smaller data to read when having predicate on 2nd sorting column (though this is just a simple PoC). Somehow, we can say that ClickHouse users are able use Z Index now...\n> Somehow, we can say that ClickHouse users are able use Z Index now...\r\n\r\nI think the idea is to not use any index. As indexes interfere with ingestion.\r\nWith pre-image support a scanner can reject blocks which do not match the hyperrectangle easily.\nHi @pkit, thanks for your answer, my opinion as below:\r\n\r\n> As indexes interfere with ingestion\r\n\r\nYes, there's a trade-off here, we don't need to write primary key, but need to write minmax index for sorting columns.\r\n\r\n> I think the idea is to not use any index\r\n\r\nI think no matter which index we use, the most important thing is how much data can we skip. In ClickHouse, we have primary index and skip indices, however, primary index can be seen as an minmax index with granule 1 on sorting column(s). Primary index is special because data is sorted **lexicographically** by primary keys, so ClickHouse has a special way to treat them (can evaluate the key condition on a range of marks instead of a single mark). Now moving to z-order, we **change the sorting pattern** , so it's understandable that primary key may not be as special as when using lexical-order.\r\n\r\n> With pre-image support a scanner can reject blocks which do not match the hyperrectangle easily\r\n\r\nI believe that the minmax index on each sorting column with granule 1 gives us more optimal hyperrectangles than any other index.\r\n\r\nThanks.\r\n\nJust found out that the example I gave in the above comment was not good, because `rand()` will be evaluated only once, for each row all columns have the same value. So I experimented again, this time, more comprehensively. The main objective of the experiment is:\r\n- Provide a PoC of our idea that we can use the min-max index when data is sorted in z-order instead of the primary key\r\n- Try to give a basic comparison between z-ordering and lexical ordering, and in which case should we use z-ordering\r\n\r\n## Create tables\r\nCreate a normal table with lexical order\r\n```sql\r\nCREATE TABLE test_pk_lexical\r\n(\r\n    `x` UInt64,\r\n    `y` UInt64,\r\n    `z` UInt64,\r\n    `t` UInt64\r\n)\r\nENGINE = MergeTree\r\nORDER BY (x, y, z, t);\r\n```\r\nCreate the same table with z-order. For this table, we don't build the primary index, instead, create a min-max index on each sorting column with granularity 1.\r\n```sql\r\nCREATE TABLE test_pk_zorder\r\n(\r\n    `x` UInt64,\r\n    `y` UInt64,\r\n    `z` UInt64,\r\n    `t` UInt64,\r\n    INDEX z_x x TYPE minmax GRANULARITY 1,\r\n    INDEX z_y y TYPE minmax GRANULARITY 1,\r\n    INDEX z_z z TYPE minmax GRANULARITY 1,\r\n    INDEX z_t t TYPE minmax GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPRIMARY KEY tuple()\r\nORDER BY mortonEncode(x, y, z, t);\r\n```\r\nCreate another table that data is sorted in lexical order, but don't build the primary index and create a min-max index on each sorting column.\r\n\r\nThe main objective of this table is to confirm that z-order can *organize* (or *cluster*) data in a more efficient way to filter conditions on the 2nd, 3rd, and 4th columns.\r\n\r\n```sql\r\nCREATE TABLE test_pk_lexical_minmax\r\n(\r\n    `x` UInt64,\r\n    `y` UInt64,\r\n    `z` UInt64,\r\n    `t` UInt64,\r\n    INDEX z_x x TYPE minmax GRANULARITY 1,\r\n    INDEX z_y y TYPE minmax GRANULARITY 1,\r\n    INDEX z_z z TYPE minmax GRANULARITY 1,\r\n    INDEX z_t t TYPE minmax GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPRIMARY KEY tuple()\r\nORDER BY (x, y, z, t);\r\n```\r\n\r\n## Performance test: high cardinality data\r\nInsert 200M rows into each table, each column has a cardinality of 100M\r\n```sql\r\nINSERT INTO test_pk_lexical SELECT rand() % 100000000, rand(1) % 100000000, rand(2) % 100000000, rand(3) % 100000000 FROM numbers(200000000);\r\n-- 0 rows in set. Elapsed: 44.074 sec. Processed 200.25 million rows, 1.60 GB (4.54 million rows/s., 36.35 MB/s.)\r\nINSERT INTO test_pk_zorder SELECT * FROM test_pk_lexical ORDER BY x, y, z, y;\r\n-- 0 rows in set. Elapsed: 58.391 sec. Processed 200.00 million rows, 6.40 GB (3.43 million rows/s., 109.61 MB/s.)\r\nINSERT INTO test_pk_lexical_minmax SELECT * FROM test_pk_lexical ORDER BY x, y, z, y;\r\n-- 0 rows in set. Elapsed: 32.539 sec. Processed 200.00 million rows, 6.40 GB (6.15 million rows/s., 196.69 MB/s.)\r\n```\r\nWe generate a couple of queries with the following pattern (which is very typical in our business):\r\n```sql\r\nSELECT * FROM test_pk_* WHERE x IN ({}, {}) AND y IN ({}, {}) AND z IN ({}, {}) AND  t in ({}, {}) FORMAT Null;\r\n```\r\nWe try to measure the total rows read for each query (not the total amount of data to exclude the `PREWHERE` 's effect). One example below shows that z-order performs worse compared to lexical order:\r\n\r\n```sql\r\nSELECT * FROM test_pk_lexical WHERE x IN (77171087, 56426808) AND y IN (45117276, 89947178) AND z IN (80695788, 9393584) AND  t in (91705403, 18502651) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.006 sec. Processed 16.38 thousand rows, 131.07 KB (2.90 million rows/s., 23.21 MB/s.)\r\nSELECT * FROM test_pk_zorder WHERE x IN (77171087, 56426808) AND y IN (45117276, 89947178) AND z IN (80695788, 9393584) AND  t in (91705403, 18502651) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.080 sec. Processed 63.93 million rows, 511.74 MB (802.12 million rows/s., 6.42 GB/s.)\r\nSELECT * FROM test_pk_lexical_minmax WHERE x IN (77171087, 56426808) AND y IN (45117276, 89947178) AND z IN (80695788, 9393584) AND  t in (91705403, 18502651) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.040 sec. Processed 16.38 thousand rows, 319.71 KB (408.61 thousand rows/s., 7.97 MB/s.)\r\n```\r\nI haven't aggregated the result of all queries yet, but overall what I observed was that lexical_minmax performs best, then lexical, and the worst is zorder. Note that z-order performs much worse than lexical ( 63.93 million rows vs 16.38 thousand rows).\r\n\r\nWhat if the condition on the 1st column is not useful? Let's add `NOT` to the first condition:\r\n```sql\r\nSELECT * FROM test_pk_lexical WHERE x NOT IN (77171087, 56426808) AND y IN (45117276, 89947178) AND z IN (80695788, 9393584) AND  t in (91705403, 18502651) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.169 sec. Processed 200.00 million rows, 1.60 GB (1.18 billion rows/s., 9.46 GB/s.)\r\nSELECT * FROM test_pk_zorder WHERE x NOT IN (77171087, 56426808) AND y IN (45117276, 89947178) AND z IN (80695788, 9393584) AND  t in (91705403, 18502651) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.524 sec. Processed 200.00 million rows, 6.40 GB (381.61 million rows/s., 12.21 GB/s.)\r\nSELECT * FROM test_pk_lexical_minmax WHERE x NOT IN (77171087, 56426808) AND y IN (45117276, 89947178) AND z IN (80695788, 9393584) AND  t in (91705403, 18502651) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.580 sec. Processed 200.00 million rows, 6.40 GB (344.78 million rows/s., 11.03 GB/s.)\r\n```\r\nNow both lexical and z-order cannot filter any marks. We test with many queries, and the results are the same.\r\nSo our conclusion is: **if sorting keys have high cardinality and most queries are points-based, we shouldn't use z-order at all.**\r\n\r\n## Performance test: low cardinality data\r\nThe main motivation we study z-order is to improve the query performance in an important business scenario. We examine their table and found that their sorting keys usually have very low cardinality, ranging from 100 to 1000. I think this is a typical scenario, for example, if we want to track the traffic between apps, the table typically will have sorting key `(src_app_id, dst_app_id)`, with both `src_app_id` and `dst_app_id` have cardinality less than 100. So let's make a test with low cardinality.\r\n\r\nInsert 200M rows into each table, each column has a cardinality of 200:\r\n```sql\r\nINSERT INTO test_pk_lexical SELECT rand() % 200, rand(1) % 200, rand(2) % 200, rand(3) % 200 FROM numbers(200000000);\r\n-- 0 rows in set. Elapsed: 41.938 sec. Processed 200.25 million rows, 1.60 GB (4.77 million rows/s., 38.20 MB/s.)\r\nINSERT INTO test_pk_zorder SELECT * FROM test_pk_lexical ORDER BY x, y, z, y;\r\n-- 0 rows in set. Elapsed: 40.643 sec. Processed 200.00 million rows, 6.40 GB (4.92 million rows/s., 157.47 MB/s.)\r\nINSERT INTO test_pk_lexical_minmax SELECT * FROM test_pk_lexical ORDER BY x, y, z, y;\r\n-- 0 rows in set. Elapsed: 46.916 sec. Processed 200.00 million rows, 6.40 GB (4.26 million rows/s., 136.41 MB/s.)\r\n```\r\n\r\nWe run the same query pattern `SELECT * FROM test_pk_* WHERE x IN ({}, {}) AND y IN ({}, {}) AND z IN ({}, {}) AND  t in ({}, {}) FORMAT Null;`. Below is an example:\r\n\r\n```sql\r\nSELECT * FROM test_pk_lexical WHERE x IN (62, 170) AND y IN (196, 81) AND z IN (105, 125) AND  t in (84, 127) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.008 sec. Processed 229.38 thousand rows, 5.34 MB (30.48 million rows/s., 710.11 MB/s.)\r\nSELECT * FROM test_pk_zorder WHERE x IN (62, 170) AND y IN (196, 81) AND z IN (105, 125) AND  t in (84, 127) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.062 sec. Processed 450.56 thousand rows, 12.28 MB (7.28 million rows/s., 198.62 MB/s.)\r\nSELECT * FROM test_pk_lexical_minmax WHERE x IN (62, 170) AND y IN (196, 81) AND z IN (105, 125) AND  t in (84, 127) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.034 sec. Processed 90.11 thousand rows, 2.62 MB (2.63 million rows/s., 76.67 MB/s.)\r\n```\r\n\r\nZ-order still performs worse than lexical, but this time the gap is not too big as when cardinality is high (450.56 thousand rows vs 229.38 thousand rows,). Lexical sorting with a min-max index on each sorting key gives the best performance.\r\n\r\nNow let's add `NOT` to the first condition to make it not useful:\r\n\r\n```sql\r\nSELECT * FROM test_pk_lexical WHERE x NOT IN (62, 170) AND y IN (196, 81) AND z IN (105, 125) AND  t in (84, 127) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.129 sec. Processed 22.28 million rows, 526.23 MB (172.25 million rows/s., 4.07 GB/s.)\r\nSELECT * FROM test_pk_zorder WHERE x NOT IN (62, 170) AND y IN (196, 81) AND z IN (105, 125) AND  t in (84, 127) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.076 sec. Processed 1.27 million rows, 38.49 MB (16.79 million rows/s., 508.77 MB/s.)\r\nSELECT * FROM test_pk_lexical_minmax WHERE x NOT IN (62, 170) AND y IN (196, 81) AND z IN (105, 125) AND  t in (84, 127) FORMAT Null;\r\n-- 0 rows in set. Elapsed: 0.084 sec. Processed 6.91 million rows, 191.13 MB (81.90 million rows/s., 2.27 GB/s.)\r\n```\r\n\r\nFinally, we can see the good side of the z-order. When the condition on the 1st sorting key is not useful, z-order still effectively filters more than 99% of data, while lexical order only filters about 90% of data. Lexical sorting with a min-max index on each key is better than normal lexical but still worse than z-order.\r\n\r\nOur conclusion is:\r\n\r\n- When sorting keys have low cardinality, z-order can be beneficial **if a considerable number of queries doesn't have a predicate on the 1st sorting key**\r\n- There's no free lunch. **With z-order, we increase the skipping effectiveness on 2st, 3rd, and 4nd column, but the skipping effectiveness on the 1st column will be lower than lexical order**. That is, if a query has an effective condition on the 1st column, z-order performs worse than lexical order.\r\n\r\n## Conclusion\r\n\r\nAs I mentioned in a previous comment, no matter which index we use, the most important thing is how much data can we skip. If we can effectively use the min-max index to skip data then we can just use it and bypass the primary index.\r\n\r\nNote that even with pre-image support, the experiments and conclusions above are still valid.\n@canhld94 \r\n\r\nLet's compare the cases when you have a table with:\r\n1. `... INDEX i_x (x) TYPE minmax GRANULARITY 1, INDEX i_y (y) TYPE minmax GRANULARITY 1) ORDER BY (x, y)`\r\n2. `ORDER BY mortonEncode(x, y)`\r\n\r\nIn the first case, the data is sorted lexicographically by (x, y).\r\nThe data for nearby values of `x` is close to each other. You cannot say the same for the data for nearby values of `y`. They might be close to each other if there are long ranges with constant `x`, or randomly distributed if every value of `x` does not repeat. In the latter case, the minmax index by y does not work at all.\r\n\r\nIn the second case, the data is ordered by a mix of `x` and `y`, almost symmetrical, without a preference of `x` or `y`.\r\nThe index analysis will be able to limit the search space if a range of `x` or `y` is provided - in both cases.\r\n\r\nThat's why we need index analysis for `mortonEncode` - it can work even if minmax index cannot.\r\nI hope @pkit will implement it as a Christmas gift :)\r\n\n@alexey-milovidov I hope too, but I have a lot of other stuff rn. And the current \"monotonic\" stuff needs some refactoring to implement pre-image.\r\nWill try to meet the Dec 25 deadline, though.\n@pkit Interesting to know about the experiments...\n@alexey-milovidov nothing much, unfortunately. As you know, we are kinda in turmoil right now. I will update you as soon as I have time. But it's not abandoned in any way.",
  "created_at": "2023-10-15T04:26:07Z"
}