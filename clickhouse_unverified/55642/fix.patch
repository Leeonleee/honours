diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index ccf290c8e20c..d1e94b38962d 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -4780,6 +4780,10 @@ a	Tuple(
 )
 ```
 
+## analyze_index_with_space_filling_curves
+
+If a table has a space-filling curve in its index, e.g. `ORDER BY mortonEncode(x, y)`, and the query has conditions on its arguments, e.g. `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, use the space-filling curve for index analysis.
+
 ## dictionary_use_async_executor {#dictionary_use_async_executor}
 
 Execute a pipeline for reading dictionary source in several threads. It's supported only by dictionaries with local CLICKHOUSE source.
diff --git a/src/Common/MortonUtils.h b/src/Common/MortonUtils.h
new file mode 100644
index 000000000000..591621f7a47e
--- /dev/null
+++ b/src/Common/MortonUtils.h
@@ -0,0 +1,217 @@
+#pragma once
+
+#include <Core/Types.h>
+#include <Common/BitHelpers.h>
+#include <base/defines.h>
+#include <array>
+#include <set>
+
+
+/** Functions to analyze the Morton space-filling curve on ranges.
+  * There are two operations:
+  *
+  * 1. Inverting the Morton curve on a range.
+  * Given a range of values of Morton curve,
+  *   mortonEncode(x, y) in [a, b]
+  * get possible set of values of its arguments.
+  * This set is represented by a set of hyperrectangles in (x, y) space.
+  *
+  * 2. Calculating the Morton curve on a hyperrectangle.
+  * Given a hyperrectangle in (x, y) space
+  *   (x, y) in [x_min, x_max] × [y_min, y_max]
+  * get possible intervals of the mortonEncode(x, y).
+  *
+  * These operations could be used for index analysis.
+  *
+  * Note: currently it is only tested in 2d.
+  */
+
+
+namespace
+{
+    /// After the most significant bit 1, set all subsequent less significant bits to 1 as well.
+    inline UInt64 toMask(UInt64 n)
+    {
+        n |= n >> 1;
+        n |= n >> 2;
+        n |= n >> 4;
+        n |= n >> 8;
+        n |= n >> 16;
+        n |= n >> 32;
+        return n;
+    }
+}
+
+
+/** Splits the interval [first, last] to a set of intervals [first_i, last_i],
+  * each of them determined by a bit prefix: [xxxxxx0000, xxxxxx1111],
+  *
+  * For example, the interval [6, 13] = {5, 7, 8, 9, 10, 11, 12, 13}
+  * will be represented by the set of intervals:
+  * - [6,  7]   0000011*
+  * - [8,  11]  000010**
+  * - [12, 13]  0000110*
+  *
+  * It means that if you have a binary space partition by powers of two,
+  * every of the resulting intervals will fully occupy one of the levels of this partition.
+  */
+template <typename F>
+void intervalBinaryPartition(UInt64 first, UInt64 last, F && callback)
+{
+    /// first = 6:    00000110
+    /// last = 13:    00001101
+    /// first ^ last: 00001011
+    /// mask:         00000111
+    /// split = 7:    00000111
+
+    /// first = 8:    00001000
+    /// last = 13:    00001101
+    /// first ^ last: 00000101
+    /// mask:         00000011
+    /// split = 11:   00001011
+
+    /// first = 8:    00001000
+    /// last = 11:    00001011
+    /// first ^ last: 00000011
+    /// mask:         00000001
+    /// split = 9:    00001001
+
+    /// Another example:
+
+    /// first = 15:   00001111
+    /// last = 31:    00011111
+    /// first ^ last: 00010000
+    /// mask:         00001111
+    /// split = 15:   00001111
+
+    UInt64 diff = first ^ last;
+    UInt64 mask = toMask(diff) >> 1;
+
+    /// The current interval represents a whole range with fixed prefix.
+    if ((first & mask) == 0 && (last & mask) == mask)
+    {
+        chassert(((last - first + 1) & (last - first)) == 0); /// The interval length is one less than a power of two.
+        callback(first, last);
+        return;
+    }
+
+    UInt64 split = first | mask;
+
+    chassert(split >= first);
+    chassert(split <= last);
+
+    intervalBinaryPartition(first, split, std::forward<F>(callback));
+    if (split < last)
+        intervalBinaryPartition(split + 1, last, std::forward<F>(callback));
+}
+
+
+/** Multidimensional version of binary space partitioning.
+  * It takes a hyperrectangle - a direct product of intervals (in each dimension),
+  * and splits it into smaller hyperrectangles - a direct product of partitions across each dimension.
+  */
+template <size_t N, size_t start_idx, typename F>
+void hyperrectangleBinaryPartitionImpl(
+    std::array<std::pair<UInt64, UInt64>, N> hyperrectangle,
+    F && callback)
+{
+    intervalBinaryPartition(hyperrectangle[start_idx].first, hyperrectangle[start_idx].second,
+        [&](UInt64 a, UInt64 b) mutable
+        {
+            auto new_hyperrectangle = hyperrectangle;
+            new_hyperrectangle[start_idx].first = a;
+            new_hyperrectangle[start_idx].second = b;
+
+            if constexpr (start_idx + 1 < N)
+                hyperrectangleBinaryPartitionImpl<N, start_idx + 1>(new_hyperrectangle, std::forward<F>(callback));
+            else
+                callback(new_hyperrectangle);
+        });
+}
+
+
+template <size_t N, typename F>
+void hyperrectangleBinaryPartition(
+    std::array<std::pair<UInt64, UInt64>, N> hyperrectangle,
+    F && callback)
+{
+    hyperrectangleBinaryPartitionImpl<N, 0>(hyperrectangle, std::forward<F>(callback));
+}
+
+
+/** Unpack an interval of Morton curve to hyperrectangles covered by it across N dimensions.
+  */
+template <size_t N, typename F>
+void mortonIntervalToHyperrectangles(UInt64 first, UInt64 last, F && callback)
+{
+    intervalBinaryPartition(first, last, [&](UInt64 a, UInt64 b)
+    {
+        std::array<std::pair<UInt64, UInt64>, N> unpacked{};
+
+        for (size_t bit_idx = 0; bit_idx < 64; ++bit_idx)
+        {
+            size_t source_bit = 63 - bit_idx;
+            size_t result_bit = (63 - bit_idx) / N;
+
+            unpacked[source_bit % N].first |= ((a >> source_bit) & 1) << result_bit;
+            unpacked[source_bit % N].second |= ((b >> source_bit) & 1) << result_bit;
+        }
+
+        callback(unpacked);
+    });
+}
+
+
+/** Given a hyperrectangle, find intervals of Morton curve that cover this hyperrectangle.
+  * Note: to avoid returning too many intervals, the intervals can be returned larger than exactly needed
+  * (covering some other points, not belonging to the hyperrectangle).
+  * We do it by extending hyperrectangles to hypercubes.
+  */
+template <size_t N, typename F>
+void hyperrectangleToPossibleMortonIntervals(
+    std::array<std::pair<UInt64, UInt64>, N> hyperrectangle,
+    F && callback)
+{
+    /// Due to extension to cubes, there could be duplicates. Filter them.
+    std::set<std::pair<UInt64, UInt64>> found_intervals;
+
+    hyperrectangleBinaryPartition<N>(hyperrectangle, [&](auto part)
+    {
+        size_t suffix_size = 0;
+        for (size_t i = 0; i < N; ++i)
+            if (part[i].second != part[i].first)
+                suffix_size = std::max<size_t>(suffix_size,
+                    1 + bitScanReverse(part[i].second ^ part[i].first));
+
+        UInt64 first = 0;
+        UInt64 last = 0;
+
+        size_t source_bit_idx = 0;
+        size_t result_bit_idx = 0;
+
+        while (result_bit_idx < 64)
+        {
+            for (size_t i = 0; i < N; ++i)
+            {
+                if (source_bit_idx < suffix_size)
+                {
+                    last |= (1 << result_bit_idx);
+                }
+                else
+                {
+                    UInt64 bit = (((part[i].first >> source_bit_idx) & 1) << result_bit_idx);
+                    first |= bit;
+                    last |= bit;
+                }
+
+                ++result_bit_idx;
+                if (!(result_bit_idx < 64))
+                    break;
+            }
+            ++source_bit_idx;
+        }
+
+        if (found_intervals.insert({first, last}).second)
+            callback(first, last);
+    });
+}
diff --git a/src/Core/Range.cpp b/src/Core/Range.cpp
index de88313b9f36..441c6b5cafe7 100644
--- a/src/Core/Range.cpp
+++ b/src/Core/Range.cpp
@@ -7,7 +7,6 @@
 namespace DB
 {
 
-
 Range::Range(const FieldRef & point) /// NOLINT
     : left(point), right(point), left_included(true), right_included(true) {}
 
@@ -160,6 +159,52 @@ void Range::invert()
     std::swap(left_included, right_included);
 }
 
+Range intersect(const Range & a, const Range & b)
+{
+    Range res = Range::createWholeUniverse();
+
+    if (Range::less(a.left, b.left))
+    {
+        res.left = b.left;
+        res.left_included = b.left_included;
+    }
+    else if (Range::equals(a.left, b.left))
+    {
+        res.left = a.left;
+        res.left_included = a.left_included && b.left_included;
+    }
+    else
+    {
+        res.left = a.left;
+        res.left_included = a.left_included;
+    }
+
+    if (Range::less(a.right, b.right))
+    {
+        res.right = a.right;
+        res.right_included = a.right_included;
+    }
+    else if (Range::equals(a.right, b.right))
+    {
+        res.right = a.right;
+        res.right_included = a.right_included && b.right_included;
+    }
+    else
+    {
+        res.right = b.right;
+        res.right_included = b.right_included;
+    }
+
+    if (res.empty())
+    {
+        res.right = res.left;
+        res.right_included = false;
+        res.left_included = false;
+    }
+
+    return res;
+}
+
 String Range::toString() const
 {
     WriteBufferFromOwnString str;
@@ -170,4 +215,33 @@ String Range::toString() const
     return str.str();
 }
 
+Hyperrectangle intersect(const Hyperrectangle & a, const Hyperrectangle & b)
+{
+    size_t result_size = std::min(a.size(), b.size());
+
+    Hyperrectangle res;
+    res.reserve(result_size);
+
+    for (size_t i = 0; i < result_size; ++i)
+        res.push_back(intersect(a[i], b[i]));
+
+    return res;
+}
+
+String toString(const Hyperrectangle & x)
+{
+    WriteBufferFromOwnString str;
+
+    bool first = true;
+    for (const auto & range : x)
+    {
+        if (!first)
+            str << " × ";
+        str << range.toString();
+        first = false;
+    }
+
+    return str.str();
+}
+
 }
diff --git a/src/Core/Range.h b/src/Core/Range.h
index 9680107cd51d..63bb895e6b78 100644
--- a/src/Core/Range.h
+++ b/src/Core/Range.h
@@ -59,8 +59,8 @@ struct Range
     static Range createRightBounded(const FieldRef & right_point, bool right_included, bool with_null = false);
     static Range createLeftBounded(const FieldRef & left_point, bool left_included, bool with_null = false);
 
-    static ALWAYS_INLINE bool equals(const Field & lhs, const Field & rhs);
-    static ALWAYS_INLINE bool less(const Field & lhs, const Field & rhs);
+    static bool equals(const Field & lhs, const Field & rhs);
+    static bool less(const Field & lhs, const Field & rhs);
 
     /** Optimize the range. If it has an open boundary and the Field type is "loose"
       * - then convert it to closed, narrowing by one.
@@ -88,8 +88,13 @@ struct Range
     String toString() const;
 };
 
+Range intersect(const Range & a, const Range & b);
+
 /** Hyperrectangle is a product of ranges: each range across each coordinate.
   */
 using Hyperrectangle = std::vector<Range>;
 
+Hyperrectangle intersect(const Hyperrectangle & a, const Hyperrectangle & b);
+String toString(const Hyperrectangle & x);
+
 }
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 733cebe44114..d3572d39ccdc 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -335,6 +335,7 @@ class IColumn;
     M(Bool, optimize_throw_if_noop, false, "If setting is enabled and OPTIMIZE query didn't actually assign a merge then an explanatory exception is thrown", 0) \
     M(Bool, use_index_for_in_with_subqueries, true, "Try using an index if there is a subquery or a table expression on the right side of the IN operator.", 0) \
     M(UInt64, use_index_for_in_with_subqueries_max_values, 0, "The maximum size of set in the right hand side of the IN operator to use table index for filtering. It allows to avoid performance degradation and higher memory usage due to preparation of additional data structures for large queries. Zero means no limit.", 0) \
+    M(Bool, analyze_index_with_space_filling_curves, true, "If a table has a space-filling curve in its index, e.g. `ORDER BY mortonEncode(x, y)`, and the query has conditions on its arguments, e.g. `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30`, use the space-filling curve for index analysis.", 0) \
     M(Bool, joined_subquery_requires_alias, true, "Force joined subqueries and table functions to have aliases for correct name qualification.", 0) \
     M(Bool, empty_result_for_aggregation_by_empty_set, false, "Return empty result when aggregating without keys on empty set.", 0) \
     M(Bool, empty_result_for_aggregation_by_constant_keys_on_empty_set, true, "Return empty result when aggregating by constant keys on empty set.", 0) \
diff --git a/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp b/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp
index b346ef3d2325..01e8e04a3d7b 100644
--- a/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp
+++ b/src/Processors/Formats/Impl/NativeORCBlockInputFormat.cpp
@@ -431,7 +431,8 @@ static void buildORCSearchArgumentImpl(
         case KeyCondition::RPNElement::FUNCTION_IN_SET:
         case KeyCondition::RPNElement::FUNCTION_NOT_IN_SET:
         case KeyCondition::RPNElement::FUNCTION_IS_NULL:
-        case KeyCondition::RPNElement::FUNCTION_IS_NOT_NULL: {
+        case KeyCondition::RPNElement::FUNCTION_IS_NOT_NULL:
+        {
             const bool need_wrap_not = curr.function == KeyCondition::RPNElement::FUNCTION_IS_NOT_NULL
                 || curr.function == KeyCondition::RPNElement::FUNCTION_NOT_IN_RANGE
                 || curr.function == KeyCondition::RPNElement::FUNCTION_NOT_IN_SET;
@@ -625,19 +626,24 @@ static void buildORCSearchArgumentImpl(
 
             break;
         }
-        case KeyCondition::RPNElement::FUNCTION_UNKNOWN: {
+        /// There is no optimization with space-filling curves for ORC.
+        case KeyCondition::RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE:
+        case KeyCondition::RPNElement::FUNCTION_UNKNOWN:
+        {
             builder.literal(orc::TruthValue::YES_NO_NULL);
             rpn_stack.pop_back();
             break;
         }
-        case KeyCondition::RPNElement::FUNCTION_NOT: {
+        case KeyCondition::RPNElement::FUNCTION_NOT:
+        {
             builder.startNot();
             rpn_stack.pop_back();
             buildORCSearchArgumentImpl(key_condition, header, schema, rpn_stack, builder, format_settings);
             builder.end();
             break;
         }
-        case KeyCondition::RPNElement::FUNCTION_AND: {
+        case KeyCondition::RPNElement::FUNCTION_AND:
+        {
             builder.startAnd();
             rpn_stack.pop_back();
             buildORCSearchArgumentImpl(key_condition, header, schema, rpn_stack, builder, format_settings);
@@ -645,7 +651,8 @@ static void buildORCSearchArgumentImpl(
             builder.end();
             break;
         }
-        case KeyCondition::RPNElement::FUNCTION_OR: {
+        case KeyCondition::RPNElement::FUNCTION_OR:
+        {
             builder.startOr();
             rpn_stack.pop_back();
             buildORCSearchArgumentImpl(key_condition, header, schema, rpn_stack, builder, format_settings);
@@ -653,12 +660,14 @@ static void buildORCSearchArgumentImpl(
             builder.end();
             break;
         }
-        case KeyCondition::RPNElement::ALWAYS_FALSE: {
+        case KeyCondition::RPNElement::ALWAYS_FALSE:
+        {
             builder.literal(orc::TruthValue::NO);
             rpn_stack.pop_back();
             break;
         }
-        case KeyCondition::RPNElement::ALWAYS_TRUE: {
+        case KeyCondition::RPNElement::ALWAYS_TRUE:
+        {
             builder.literal(orc::TruthValue::YES);
             rpn_stack.pop_back();
             break;
diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp
index 666d9d3815d5..3bee0a235e84 100644
--- a/src/Storages/MergeTree/KeyCondition.cpp
+++ b/src/Storages/MergeTree/KeyCondition.cpp
@@ -15,6 +15,7 @@
 #include <Functions/CastOverloadResolver.h>
 #include <Functions/IFunction.h>
 #include <Common/FieldVisitorToString.h>
+#include <Common/MortonUtils.h>
 #include <Common/typeid_cast.h>
 #include <Columns/ColumnSet.h>
 #include <Interpreters/convertFieldToType.h>
@@ -26,7 +27,6 @@
 #include <IO/WriteBufferFromString.h>
 #include <IO/Operators.h>
 #include <Storages/MergeTree/MergeTreeIndexUtils.h>
-#include <base/defines.h>
 
 #include <algorithm>
 #include <cassert>
@@ -453,26 +453,28 @@ const KeyCondition::AtomMap KeyCondition::atom_map
 
 static const std::map<std::string, std::string> inverse_relations =
 {
-        {"equals", "notEquals"},
-        {"notEquals", "equals"},
-        {"less", "greaterOrEquals"},
-        {"greaterOrEquals", "less"},
-        {"greater", "lessOrEquals"},
-        {"lessOrEquals", "greater"},
-        {"in", "notIn"},
-        {"notIn", "in"},
-        {"globalIn", "globalNotIn"},
-        {"globalNotIn", "globalIn"},
-        {"nullIn", "notNullIn"},
-        {"notNullIn", "nullIn"},
-        {"globalNullIn", "globalNotNullIn"},
-        {"globalNullNotIn", "globalNullIn"},
-        {"isNull", "isNotNull"},
-        {"isNotNull", "isNull"},
-        {"like", "notLike"},
-        {"notLike", "like"},
-        {"empty", "notEmpty"},
-        {"notEmpty", "empty"},
+    {"equals", "notEquals"},
+    {"notEquals", "equals"},
+    {"less", "greaterOrEquals"},
+    {"greaterOrEquals", "less"},
+    {"greater", "lessOrEquals"},
+    {"lessOrEquals", "greater"},
+    {"in", "notIn"},
+    {"notIn", "in"},
+    {"globalIn", "globalNotIn"},
+    {"globalNotIn", "globalIn"},
+    {"nullIn", "notNullIn"},
+    {"notNullIn", "nullIn"},
+    {"globalNullIn", "globalNotNullIn"},
+    {"globalNullNotIn", "globalNullIn"},
+    {"isNull", "isNotNull"},
+    {"isNotNull", "isNull"},
+    {"like", "notLike"},
+    {"notLike", "like"},
+    {"ilike", "notILike"},
+    {"notILike", "ilike"},
+    {"empty", "notEmpty"},
+    {"notEmpty", "empty"},
 };
 
 
@@ -723,6 +725,40 @@ static NameSet getAllSubexpressionNames(const ExpressionActions & key_expr)
     return names;
 }
 
+void KeyCondition::getAllSpaceFillingCurves()
+{
+    /// So far the only supported function is mortonEncode (Morton curve).
+
+    for (const auto & action : key_expr->getActions())
+    {
+        if (action.node->type == ActionsDAG::ActionType::FUNCTION
+            && action.node->children.size() >= 2
+            && action.node->function_base->getName() == "mortonEncode")
+        {
+            SpaceFillingCurveDescription curve;
+            curve.function_name = action.node->function_base->getName();
+            curve.key_column_pos = key_columns.at(action.node->result_name);
+            for (const auto & child : action.node->children)
+            {
+                /// All arguments should be regular input columns.
+                if (child->type == ActionsDAG::ActionType::INPUT)
+                {
+                    curve.arguments.push_back(child->result_name);
+                }
+                else
+                {
+                    curve.arguments.clear();
+                    break;
+                }
+            }
+
+            /// So far we only support the case of two arguments.
+            if (2 == curve.arguments.size())
+                key_space_filling_curves.push_back(std::move(curve));
+        }
+    }
+}
+
 KeyCondition::KeyCondition(
     const ASTPtr & query,
     const ASTs & additional_filter_asts,
@@ -751,6 +787,9 @@ KeyCondition::KeyCondition(
         ++key_index;
     }
 
+    if (context->getSettingsRef().analyze_index_with_space_filling_curves)
+        getAllSpaceFillingCurves();
+
     ASTPtr filter_node;
     if (query)
         filter_node = buildFilterNode(query, additional_filter_asts);
@@ -776,7 +815,10 @@ KeyCondition::KeyCondition(
         std::move(block_with_constants),
         std::move(prepared_sets),
         [&](const RPNBuilderTreeNode & node, RPNElement & out) { return extractAtomFromTree(node, out); });
+
     rpn = std::move(builder).extractRPN();
+
+    findHyperrectanglesForArgumentsOfSpaceFillingCurves();
 }
 
 KeyCondition::KeyCondition(
@@ -825,6 +867,9 @@ KeyCondition::KeyCondition(
         ++key_index;
     }
 
+    if (context->getSettingsRef().analyze_index_with_space_filling_curves)
+        getAllSpaceFillingCurves();
+
     if (!filter_dag)
     {
         rpn.emplace_back(RPNElement::FUNCTION_UNKNOWN);
@@ -842,6 +887,8 @@ KeyCondition::KeyCondition(
     });
 
     rpn = std::move(builder).extractRPN();
+
+    findHyperrectanglesForArgumentsOfSpaceFillingCurves();
 }
 
 bool KeyCondition::addCondition(const String & column, const Range & range)
@@ -1204,7 +1251,9 @@ bool KeyCondition::tryPrepareSetIndex(
         MergeTreeSetIndex::KeyTuplePositionMapping index_mapping;
         index_mapping.tuple_index = tuple_index;
         DataTypePtr data_type;
-        if (isKeyPossiblyWrappedByMonotonicFunctions(node, index_mapping.key_index, data_type, index_mapping.functions))
+        std::optional<size_t> key_space_filling_curve_argument_pos;
+        if (isKeyPossiblyWrappedByMonotonicFunctions(node, index_mapping.key_index, key_space_filling_curve_argument_pos, data_type, index_mapping.functions)
+            && !key_space_filling_curve_argument_pos) /// We don't support the analysis of space-filling curves and IN set.
         {
             indexes_mapping.push_back(index_mapping);
             data_types.push_back(data_type);
@@ -1412,13 +1461,15 @@ class FunctionWithOptionalConstArg : public IFunctionBase
 bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctions(
     const RPNBuilderTreeNode & node,
     size_t & out_key_column_num,
+    std::optional<size_t> & out_argument_num_of_space_filling_curve,
     DataTypePtr & out_key_res_column_type,
     MonotonicFunctionsChain & out_functions_chain)
 {
     std::vector<RPNBuilderFunctionTreeNode> chain_not_tested_for_monotonicity;
     DataTypePtr key_column_type;
 
-    if (!isKeyPossiblyWrappedByMonotonicFunctionsImpl(node, out_key_column_num, key_column_type, chain_not_tested_for_monotonicity))
+    if (!isKeyPossiblyWrappedByMonotonicFunctionsImpl(
+        node, out_key_column_num, out_argument_num_of_space_filling_curve, key_column_type, chain_not_tested_for_monotonicity))
         return false;
 
     for (auto it = chain_not_tested_for_monotonicity.rbegin(); it != chain_not_tested_for_monotonicity.rend(); ++it)
@@ -1474,6 +1525,7 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctions(
 bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(
     const RPNBuilderTreeNode & node,
     size_t & out_key_column_num,
+    std::optional<size_t> & out_argument_num_of_space_filling_curve,
     DataTypePtr & out_key_column_type,
     std::vector<RPNBuilderFunctionTreeNode> & out_functions_chain)
 {
@@ -1492,10 +1544,31 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(
     if (key_columns.end() != it)
     {
         out_key_column_num = it->second;
-        out_key_column_type = sample_block.getByName(it->first).type;
+        out_key_column_type = sample_block.getByName(name).type;
         return true;
     }
 
+    /** The case of space-filling curves.
+      * When the node is not a key column (e.g. mortonEncode(x, y))
+      * but one of the arguments of a key column (e.g. x or y).
+      *
+      * For example, the table has ORDER BY mortonEncode(x, y)
+      * and query has WHERE x >= 10 AND x < 15 AND y > 20 AND y <= 25
+      */
+    for (const auto & curve : key_space_filling_curves)
+    {
+        for (size_t i = 0, size = curve.arguments.size(); i < size; ++i)
+        {
+            if (curve.arguments[i] == name)
+            {
+                out_key_column_num = curve.key_column_pos;
+                out_argument_num_of_space_filling_curve = i;
+                out_key_column_type = sample_block.getByName(name).type;
+                return true;
+            }
+        }
+    }
+
     if (node.isFunction())
     {
         auto function_node = node.toFunctionNode();
@@ -1511,16 +1584,31 @@ bool KeyCondition::isKeyPossiblyWrappedByMonotonicFunctionsImpl(
         {
             if (function_node.getArgumentAt(0).isConstant())
             {
-                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(function_node.getArgumentAt(1), out_key_column_num, out_key_column_type, out_functions_chain);
+                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(
+                    function_node.getArgumentAt(1),
+                    out_key_column_num,
+                    out_argument_num_of_space_filling_curve,
+                    out_key_column_type,
+                    out_functions_chain);
             }
             else if (function_node.getArgumentAt(1).isConstant())
             {
-                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(function_node.getArgumentAt(0), out_key_column_num, out_key_column_type, out_functions_chain);
+                result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(
+                    function_node.getArgumentAt(0),
+                    out_key_column_num,
+                    out_argument_num_of_space_filling_curve,
+                    out_key_column_type,
+                    out_functions_chain);
             }
         }
         else
         {
-            result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(function_node.getArgumentAt(0), out_key_column_num, out_key_column_type, out_functions_chain);
+            result = isKeyPossiblyWrappedByMonotonicFunctionsImpl(
+                function_node.getArgumentAt(0),
+                out_key_column_num,
+                out_argument_num_of_space_filling_curve,
+                out_key_column_type,
+                out_functions_chain);
         }
 
         return result;
@@ -1548,7 +1636,12 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
 {
     /** Functions < > = != <= >= in `notIn` isNull isNotNull, where one argument is a constant, and the other is one of columns of key,
       *  or itself, wrapped in a chain of possibly-monotonic functions,
-      *  or constant expression - number.
+      *  (for example, if the table has ORDER BY time, we will check the conditions like
+      *   toDate(time) = '2023-10-14', toMonth(time) = 12, etc)
+      *  or any of arguments of a space-filling curve function if it is in the key,
+      *  (for example, if the table has ORDER BY mortonEncode(x, y), we will check the conditions like x > c, y <= c, etc.)
+      *  or constant expression - number
+      *  (for example x AND 0)
       */
     Field const_value;
     DataTypePtr const_type;
@@ -1557,8 +1650,15 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
         auto func = node.toFunctionNode();
         size_t num_args = func.getArgumentsSize();
 
-        DataTypePtr key_expr_type;    /// Type of expression containing key column
-        size_t key_column_num = -1;   /// Number of a key column (inside key_column_names array)
+        /// Type of expression containing key column
+        DataTypePtr key_expr_type;
+
+        /// Number of a key column (inside key_column_names array)
+        size_t key_column_num = -1;
+
+        /// For example, if the key is mortonEncode(x, y), and the atom is x, then the argument num is 0.
+        std::optional<size_t> argument_num_of_space_filling_curve;
+
         MonotonicFunctionsChain chain;
         std::string func_name = func.getFunctionName();
 
@@ -1567,7 +1667,8 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
 
         if (num_args == 1)
         {
-            if (!(isKeyPossiblyWrappedByMonotonicFunctions(func.getArgumentAt(0), key_column_num, key_expr_type, chain)))
+            if (!(isKeyPossiblyWrappedByMonotonicFunctions(
+                func.getArgumentAt(0), key_column_num, argument_num_of_space_filling_curve, key_expr_type, chain)))
                 return false;
 
             if (key_column_num == static_cast<size_t>(-1))
@@ -1615,7 +1716,8 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
                     return true;
                 }
 
-                if (isKeyPossiblyWrappedByMonotonicFunctions(func.getArgumentAt(0), key_column_num, key_expr_type, chain))
+                if (isKeyPossiblyWrappedByMonotonicFunctions(
+                    func.getArgumentAt(0), key_column_num, argument_num_of_space_filling_curve, key_expr_type, chain))
                 {
                     key_arg_pos = 0;
                 }
@@ -1645,7 +1747,8 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
                     return true;
                 }
 
-                if (isKeyPossiblyWrappedByMonotonicFunctions(func.getArgumentAt(1), key_column_num, key_expr_type, chain))
+                if (isKeyPossiblyWrappedByMonotonicFunctions(
+                    func.getArgumentAt(1), key_column_num, argument_num_of_space_filling_curve, key_expr_type, chain))
                 {
                     key_arg_pos = 1;
                 }
@@ -1767,6 +1870,7 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
 
         out.key_column = key_column_num;
         out.monotonic_functions_chain = std::move(chain);
+        out.argument_num_of_space_filling_curve = argument_num_of_space_filling_curve;
 
         return atom_it->second(out, const_value);
     }
@@ -1793,6 +1897,95 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme
     return false;
 }
 
+
+void KeyCondition::findHyperrectanglesForArgumentsOfSpaceFillingCurves()
+{
+    /// Traverse chains of AND with conditions on arguments of a space filling curve, and construct hyperrectangles from them.
+    /// For example, a chain:
+    ///   x >= 10 AND x <= 20 AND y >= 20 AND y <= 30
+    /// will be transformed to a single atom:
+    ///   args in [10, 20] × [20, 30]
+
+    RPN new_rpn;
+    new_rpn.reserve(rpn.size());
+
+    auto num_arguments_of_a_curve = [&](size_t key_column_pos)
+    {
+        for (const auto & curve : key_space_filling_curves)
+            if (curve.key_column_pos == key_column_pos)
+                return curve.arguments.size();
+        return 0uz;
+    };
+
+    for (const auto & elem : rpn)
+    {
+        if (elem.function == RPNElement::FUNCTION_IN_RANGE && elem.argument_num_of_space_filling_curve.has_value())
+        {
+            /// A range of an argument of a space-filling curve
+
+            size_t arg_num = *elem.argument_num_of_space_filling_curve;
+            size_t curve_total_args = num_arguments_of_a_curve(elem.key_column);
+
+            if (!curve_total_args)
+            {
+                /// If we didn't find a space-filling curve - replace the condition to unknown.
+                new_rpn.emplace_back();
+                continue;
+            }
+
+            chassert(arg_num < curve_total_args);
+
+            /// Replace the condition to a hyperrectangle
+
+            Hyperrectangle hyperrectangle(curve_total_args, Range::createWholeUniverseWithoutNull());
+            hyperrectangle[arg_num] = elem.range;
+
+            RPNElement collapsed_elem;
+            collapsed_elem.function = RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE;
+            collapsed_elem.key_column = elem.key_column;
+            collapsed_elem.space_filling_curve_args_hyperrectangle = std::move(hyperrectangle);
+
+            new_rpn.push_back(std::move(collapsed_elem));
+            continue;
+        }
+        else if (elem.function == RPNElement::FUNCTION_AND && new_rpn.size() >= 2)
+        {
+            /// AND of two conditions
+
+            const auto & cond1 = new_rpn[new_rpn.size() - 2];
+            const auto & cond2 = new_rpn[new_rpn.size() - 1];
+
+            /// Related to the same column of the key, represented by a space-filling curve
+
+            if (cond1.key_column == cond2.key_column
+                && cond1.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE
+                && cond2.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE)
+            {
+                 /// Intersect these two conditions (applying AND)
+
+                RPNElement collapsed_elem;
+                collapsed_elem.function = RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE;
+                collapsed_elem.key_column = cond1.key_column;
+                collapsed_elem.space_filling_curve_args_hyperrectangle = intersect(
+                    cond1.space_filling_curve_args_hyperrectangle,
+                    cond2.space_filling_curve_args_hyperrectangle);
+
+                /// Replace the AND operation with its arguments to the collapsed condition
+
+                new_rpn.pop_back();
+                new_rpn.pop_back();
+                new_rpn.push_back(std::move(collapsed_elem));
+                continue;
+            }
+        }
+
+        new_rpn.push_back(elem);
+    }
+
+    rpn = std::move(new_rpn);
+}
+
+
 String KeyCondition::toString() const
 {
     String res;
@@ -1912,7 +2105,8 @@ KeyCondition::Description KeyCondition::getDescription() const
             || element.function == RPNElement::FUNCTION_IS_NULL
             || element.function == RPNElement::FUNCTION_IS_NOT_NULL
             || element.function == RPNElement::FUNCTION_IN_SET
-            || element.function == RPNElement::FUNCTION_NOT_IN_SET)
+            || element.function == RPNElement::FUNCTION_NOT_IN_SET
+            || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE)
         {
             auto can_be_true = std::make_unique<Node>(Node{.type = Node::Type::Leaf, .element = &element, .negate = false});
             auto can_be_false = std::make_unique<Node>(Node{.type = Node::Type::Leaf, .element = &element, .negate = true});
@@ -1974,9 +2168,9 @@ KeyCondition::Description KeyCondition::getDescription() const
     }
 
     if (rpn_stack.size() != 1)
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected stack size in KeyCondition::checkInRange");
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected stack size in KeyCondition::getDescription");
 
-    std::vector<std::string_view> key_names(key_columns.size());
+    std::vector<String> key_names(key_columns.size());
     std::vector<bool> is_key_used(key_columns.size(), false);
 
     for (const auto & key : key_columns)
@@ -2061,13 +2255,13 @@ KeyCondition::Description KeyCondition::getDescription() const
   *
   * The range of tuples can always be represented as a combination (union) of hyperrectangles.
   * For example, the range [ x1 y1 .. x2 y2 ] given x1 != x2 is equal to the union of the following three hyperrectangles:
-  * [x1]       x [y1 .. +inf)
-  * (x1 .. x2) x (-inf .. +inf)
-  * [x2]       x (-inf .. y2]
+  * [x1]       × [y1 .. +inf)
+  * (x1 .. x2) × (-inf .. +inf)
+  * [x2]       × (-inf .. y2]
   *
   * Or, for example, the range [ x1 y1 .. +inf ] is equal to the union of the following two hyperrectangles:
-  * [x1]         x [y1 .. +inf)
-  * (x1 .. +inf) x (-inf .. +inf)
+  * [x1]         × [y1 .. +inf)
+  * (x1 .. +inf) × (-inf .. +inf)
   * It's easy to see that this is a special case of the variant above.
   *
   * This is important because it is easy for us to check the feasibility of the condition over the hyperrectangle,
@@ -2075,6 +2269,10 @@ KeyCondition::Description KeyCondition::getDescription() const
   *  over at least one hyperrectangle from which this range consists.
   */
 
+/** For the range between tuples, determined by left_keys, left_bounded, right_keys, right_bounded,
+  * invoke the callback on every parallelogram composing this range (see the description above),
+  * and returns the OR of the callback results (meaning if callback returned true on any part of the range).
+  */
 template <typename F>
 static BoolMask forAnyHyperrectangle(
     size_t key_size,
@@ -2082,7 +2280,7 @@ static BoolMask forAnyHyperrectangle(
     const FieldRef * right_keys,
     bool left_bounded,
     bool right_bounded,
-    Hyperrectangle & hyperrectangle,
+    Hyperrectangle & hyperrectangle, /// This argument is modified in-place for the callback
     const DataTypes & data_types,
     size_t prefix_size,
     BoolMask initial_mask,
@@ -2122,7 +2320,7 @@ static BoolMask forAnyHyperrectangle(
         return callback(hyperrectangle);
     }
 
-    /// (x1 .. x2) x (-inf .. +inf)
+    /// (x1 .. x2) × (-inf .. +inf)
 
     if (left_bounded && right_bounded)
         hyperrectangle[prefix_size] = Range(left_keys[prefix_size], false, right_keys[prefix_size], false);
@@ -2139,7 +2337,6 @@ static BoolMask forAnyHyperrectangle(
             hyperrectangle[i] = Range::createWholeUniverseWithoutNull();
     }
 
-
     BoolMask result = initial_mask;
     result = result | callback(hyperrectangle);
 
@@ -2150,26 +2347,26 @@ static BoolMask forAnyHyperrectangle(
     if (result.isComplete())
         return result;
 
-    /// [x1]       x [y1 .. +inf)
+    /// [x1]       × [y1 .. +inf)
 
     if (left_bounded)
     {
         hyperrectangle[prefix_size] = Range(left_keys[prefix_size]);
         result = result
             | forAnyHyperrectangle(
-                     key_size, left_keys, right_keys, true, false, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);
+                key_size, left_keys, right_keys, true, false, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);
         if (result.isComplete())
             return result;
     }
 
-    /// [x2]       x (-inf .. y2]
+    /// [x2]       × (-inf .. y2]
 
     if (right_bounded)
     {
         hyperrectangle[prefix_size] = Range(right_keys[prefix_size]);
         result = result
             | forAnyHyperrectangle(
-                     key_size, left_keys, right_keys, false, true, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);
+                key_size, left_keys, right_keys, false, true, hyperrectangle, data_types, prefix_size + 1, initial_mask, callback);
         if (result.isComplete())
             return result;
     }
@@ -2196,14 +2393,14 @@ BoolMask KeyCondition::checkInRange(
             key_ranges.push_back(Range::createWholeUniverseWithoutNull());
     }
 
-    // std::cerr << "Checking for: [";
-    // for (size_t i = 0; i != used_key_size; ++i)
-    //     std::cerr << (i != 0 ? ", " : "") << applyVisitor(FieldVisitorToString(), left_keys[i]);
-    // std::cerr << " ... ";
+/*    std::cerr << "Checking for: [";
+    for (size_t i = 0; i != used_key_size; ++i)
+        std::cerr << (i != 0 ? ", " : "") << applyVisitor(FieldVisitorToString(), left_keys[i]);
+    std::cerr << " ... ";
 
-    // for (size_t i = 0; i != used_key_size; ++i)
-    //     std::cerr << (i != 0 ? ", " : "") << applyVisitor(FieldVisitorToString(), right_keys[i]);
-    // std::cerr << "]
";
+    for (size_t i = 0; i != used_key_size; ++i)
+        std::cerr << (i != 0 ? ", " : "") << applyVisitor(FieldVisitorToString(), right_keys[i]);
+    std::cerr << "]
";*/
 
     return forAnyHyperrectangle(used_key_size, left_keys, right_keys, true, true, key_ranges, data_types, 0, initial_mask,
         [&] (const Hyperrectangle & key_ranges_hyperrectangle)
@@ -2212,7 +2409,7 @@ BoolMask KeyCondition::checkInRange(
 
         // std::cerr << "Hyperrectangle: ";
         // for (size_t i = 0, size = key_ranges.size(); i != size; ++i)
-        //     std::cerr << (i != 0 ? " x " : "") << key_ranges[i].toString();
+        //     std::cerr << (i != 0 ? " × " : "") << key_ranges[i].toString();
         // std::cerr << ": " << res.can_be_true << "
";
 
         return res;
@@ -2347,7 +2544,13 @@ BoolMask KeyCondition::checkInHyperrectangle(
     std::vector<BoolMask> rpn_stack;
     for (const auto & element : rpn)
     {
-        if (element.function == RPNElement::FUNCTION_UNKNOWN)
+        if (element.argument_num_of_space_filling_curve.has_value())
+        {
+            /// If a condition on argument of a space filling curve wasn't collapsed into FUNCTION_ARGS_IN_HYPERRECTANGLE,
+            /// we cannot process it.
+            rpn_stack.emplace_back(true, true);
+        }
+        else if (element.function == RPNElement::FUNCTION_UNKNOWN)
         {
             rpn_stack.emplace_back(true, true);
         }
@@ -2383,6 +2586,97 @@ BoolMask KeyCondition::checkInHyperrectangle(
             if (element.function == RPNElement::FUNCTION_NOT_IN_RANGE)
                 rpn_stack.back() = !rpn_stack.back();
         }
+        else if (element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE)
+        {
+            /** The case of space-filling curves.
+              * We unpack the range of a space filling curve into hyperrectangles of their arguments,
+              * and then check the intersection of them with the given hyperrectangle from the key condition.
+              *
+              * Note: you might find this code hard to understand,
+              * because there are three different hyperrectangles involved:
+              *
+              * 1. A hyperrectangle derived from the range of the table's sparse index (marks granule): `hyperrectangle`
+              *    We analyze its dimension `key_range`, corresponding to the `key_column`.
+              *    For example, the table's key is a single column `mortonEncode(x, y)`,
+              *    the current granule is [500, 600], and it means that
+              *    mortonEncode(x, y) in [500, 600]
+              *
+              * 2. A hyperrectangle derived from the key condition, e.g.
+              *    `x >= 10 AND x <= 20 AND y >= 20 AND y <= 30` defines: (x, y) in [10, 20] × [20, 30]
+              *
+              * 3. A set of hyperrectangles that we obtain by inverting the space-filling curve on the range:
+              *    From mortonEncode(x, y) in [500, 600]
+              *    We get (x, y) in [30, 31] × [12, 13]
+              *        or (x, y) in [28, 31] × [14, 15];
+              *        or (x, y) in [0, 7] × [16, 23];
+              *        or (x, y) in [8, 11] × [16, 19];
+              *        or (x, y) in [12, 15] × [16, 17];
+              *        or (x, y) in [12, 12] × [18, 18];
+              *
+              *  And we analyze the intersection of (2) and (3).
+              */
+
+            Range key_range = hyperrectangle[element.key_column];
+
+            /// The only possible result type of a space filling curve is UInt64.
+            /// We also only check bounded ranges.
+            if (key_range.left.getType() == Field::Types::UInt64
+                && key_range.right.getType() == Field::Types::UInt64)
+            {
+                key_range.shrinkToIncludedIfPossible();
+
+                size_t num_dimensions = element.space_filling_curve_args_hyperrectangle.size();
+
+                /// Let's support only the case of 2d, because I'm not confident in other cases.
+                if (num_dimensions == 2)
+                {
+                    UInt64 left = key_range.left.get<UInt64>();
+                    UInt64 right = key_range.right.get<UInt64>();
+
+                    BoolMask mask(false, true);
+                    mortonIntervalToHyperrectangles<2>(left, right,
+                        [&](std::array<std::pair<UInt64, UInt64>, 2> morton_hyperrectangle)
+                        {
+                            BoolMask current_intersection(true, false);
+                            for (size_t dim = 0; dim < num_dimensions; ++dim)
+                            {
+                                const Range & condition_arg_range = element.space_filling_curve_args_hyperrectangle[dim];
+
+                                const Range morton_arg_range(
+                                    morton_hyperrectangle[dim].first, true,
+                                    morton_hyperrectangle[dim].second, true);
+
+                                bool intersects = condition_arg_range.intersectsRange(morton_arg_range);
+                                bool contains = condition_arg_range.containsRange(morton_arg_range);
+
+                                current_intersection = current_intersection & BoolMask(intersects, !contains);
+                            }
+
+                            mask = mask | current_intersection;
+                        });
+
+                    rpn_stack.emplace_back(mask);
+                }
+                else
+                    rpn_stack.emplace_back(true, true);
+            }
+            else
+                rpn_stack.emplace_back(true, true);
+
+            /** Note: we can consider implementing a simpler solution, based on "hidden keys".
+              * It means, when we have a table's key like (a, b, mortonCurve(x, y))
+              * we extract the arguments from the curves, and append them to the key,
+              * imagining that we have the key (a, b, mortonCurve(x, y), x, y)
+              *
+              * Then while we analyze the granule's range between (a, b, mortonCurve(x, y))
+              * and decompose it to the series of hyperrectangles,
+              * we can construct a series of hyperrectangles of the extended key (a, b, mortonCurve(x, y), x, y),
+              * and then do everything as usual.
+              *
+              * This approach is generalizable to any functions, that have preimage of interval
+              * represented by a set of hyperrectangles.
+              */
+        }
         else if (
             element.function == RPNElement::FUNCTION_IS_NULL
             || element.function == RPNElement::FUNCTION_IS_NOT_NULL)
@@ -2445,7 +2739,7 @@ BoolMask KeyCondition::checkInHyperrectangle(
     }
 
     if (rpn_stack.size() != 1)
-        throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected stack size in KeyCondition::checkInRange");
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Unexpected stack size in KeyCondition::checkInHyperrectangle");
 
     return rpn_stack[0];
 }
@@ -2459,11 +2753,17 @@ bool KeyCondition::mayBeTrueInRange(
     return checkInRange(used_key_size, left_keys, right_keys, data_types, BoolMask::consider_only_can_be_true).can_be_true;
 }
 
-String KeyCondition::RPNElement::toString() const { return toString("column " + std::to_string(key_column), false); }
+String KeyCondition::RPNElement::toString() const
+{
+    if (argument_num_of_space_filling_curve)
+        return toString(fmt::format("argument {} of column {}", *argument_num_of_space_filling_curve, key_column), false);
+    else
+        return toString(fmt::format("column {}", key_column), false);
+}
 
 String KeyCondition::RPNElement::toString(std::string_view column_name, bool print_constants) const
 {
-    auto print_wrapped_column = [this, &column_name, print_constants](WriteBuffer & buf)
+    auto print_wrapped_column = [this, column_name, print_constants](WriteBuffer & buf)
     {
         for (auto it = monotonic_functions_chain.rbegin(); it != monotonic_functions_chain.rend(); ++it)
         {
@@ -2527,6 +2827,15 @@ String KeyCondition::RPNElement::toString(std::string_view column_name, bool pri
             buf << ")";
             return buf.str();
         }
+        case FUNCTION_ARGS_IN_HYPERRECTANGLE:
+        {
+            buf << "(";
+            print_wrapped_column(buf);
+            buf << " has args in ";
+            buf << DB::toString(space_filling_curve_args_hyperrectangle);
+            buf << ")";
+            return buf.str();
+        }
         case FUNCTION_IS_NULL:
         case FUNCTION_IS_NOT_NULL:
         {
@@ -2579,6 +2888,7 @@ bool KeyCondition::unknownOrAlwaysTrue(bool unknown_any) const
             || element.function == RPNElement::FUNCTION_IN_RANGE
             || element.function == RPNElement::FUNCTION_IN_SET
             || element.function == RPNElement::FUNCTION_NOT_IN_SET
+            || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE
             || element.function == RPNElement::FUNCTION_IS_NULL
             || element.function == RPNElement::FUNCTION_IS_NOT_NULL
             || element.function == RPNElement::ALWAYS_FALSE)
@@ -2635,6 +2945,7 @@ bool KeyCondition::alwaysFalse() const
             || element.function == RPNElement::FUNCTION_IN_RANGE
             || element.function == RPNElement::FUNCTION_IN_SET
             || element.function == RPNElement::FUNCTION_NOT_IN_SET
+            || element.function == RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE
             || element.function == RPNElement::FUNCTION_IS_NULL
             || element.function == RPNElement::FUNCTION_IS_NOT_NULL
             || element.function == RPNElement::FUNCTION_UNKNOWN)
diff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h
index 6bc044c4dd43..fa5573e5d61b 100644
--- a/src/Storages/MergeTree/KeyCondition.h
+++ b/src/Storages/MergeTree/KeyCondition.h
@@ -172,7 +172,15 @@ class KeyCondition
             FUNCTION_NOT_IN_SET,
             FUNCTION_IS_NULL,
             FUNCTION_IS_NOT_NULL,
-            FUNCTION_UNKNOWN, /// Can take any value.
+            /// Special for space-filling curves.
+            /// For example, if key is mortonEncode(x, y),
+            /// and the condition contains its arguments, e.g.:
+            ///   x >= 10 AND x <= 20 AND y >= 20 AND y <= 30,
+            /// this expression will be analyzed and then represented by following:
+            ///   args in hyperrectangle [10, 20] × [20, 30].
+            FUNCTION_ARGS_IN_HYPERRECTANGLE,
+            /// Can take any value.
+            FUNCTION_UNKNOWN,
             /// Operators of the logical expression.
             FUNCTION_NOT,
             FUNCTION_AND,
@@ -196,10 +204,19 @@ class KeyCondition
         /// For FUNCTION_IN_RANGE and FUNCTION_NOT_IN_RANGE.
         Range range = Range::createWholeUniverse();
         size_t key_column = 0;
+
+        /// If the key_column is a space filling curve, e.g. mortonEncode(x, y),
+        /// we will analyze expressions of its arguments (x and y) similarly how we do for a normal key columns,
+        /// and this designates the argument number (0 for x, 1 for y):
+        std::optional<size_t> argument_num_of_space_filling_curve;
+
         /// For FUNCTION_IN_SET, FUNCTION_NOT_IN_SET
         using MergeTreeSetIndexPtr = std::shared_ptr<const MergeTreeSetIndex>;
         MergeTreeSetIndexPtr set_index;
 
+        /// For FUNCTION_ARGS_IN_HYPERRECTANGLE
+        Hyperrectangle space_filling_curve_args_hyperrectangle;
+
         MonotonicFunctionsChain monotonic_functions_chain;
     };
 
@@ -223,21 +240,25 @@ class KeyCondition
 
     bool extractAtomFromTree(const RPNBuilderTreeNode & node, RPNElement & out);
 
-    /** Is node the key column
-      *  or expression in which column of key is wrapped by chain of functions,
+    /** Is node the key column, or an argument of a space-filling curve that is a key column,
+      *  or expression in which that column is wrapped by a chain of functions,
       *  that can be monotonic on certain ranges?
-      * If these conditions are true, then returns number of column in key, type of resulting expression
+      * If these conditions are true, then returns number of column in key,
+      *  optionally the argument position of a space-filling curve,
+      *  type of resulting expression
       *  and fills chain of possibly-monotonic functions.
       */
     bool isKeyPossiblyWrappedByMonotonicFunctions(
         const RPNBuilderTreeNode & node,
         size_t & out_key_column_num,
+        std::optional<size_t> & out_argument_num_of_space_filling_curve,
         DataTypePtr & out_key_res_column_type,
         MonotonicFunctionsChain & out_functions_chain);
 
     bool isKeyPossiblyWrappedByMonotonicFunctionsImpl(
         const RPNBuilderTreeNode & node,
         size_t & out_key_column_num,
+        std::optional<size_t> & out_argument_num_of_space_filling_curve,
         DataTypePtr & out_key_column_type,
         std::vector<RPNBuilderFunctionTreeNode> & out_functions_chain);
 
@@ -296,6 +317,11 @@ class KeyCondition
     ///   and all, two, partitions will be scanned, but due to filtering later none of rows will be matched.
     bool unknownOrAlwaysTrue(bool unknown_any) const;
 
+    /** Iterates over RPN and collapses FUNCTION_IN_RANGE over the arguments of space-filling curve function
+      * into atom of type FUNCTION_ARGS_IN_HYPERRECTANGLE.
+      */
+    void findHyperrectanglesForArgumentsOfSpaceFillingCurves();
+
     RPN rpn;
 
     ColumnIndices key_columns;
@@ -306,6 +332,17 @@ class KeyCondition
     /// All intermediate columns are used to calculate key_expr.
     const NameSet key_subexpr_names;
 
+    /// Space-filling curves in the key
+    struct SpaceFillingCurveDescription
+    {
+        size_t key_column_pos;
+        String function_name;
+        std::vector<String> arguments;
+    };
+    using SpaceFillingCurveDescriptions = std::vector<SpaceFillingCurveDescription>;
+    SpaceFillingCurveDescriptions key_space_filling_curves;
+    void getAllSpaceFillingCurves();
+
     /// Array joined column names
     NameSet array_joined_column_names;
 
