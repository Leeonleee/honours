{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11934,
  "instance_id": "ClickHouse__ClickHouse-11934",
  "issue_numbers": [
    "11370",
    "11361"
  ],
  "base_commit": "cd7382abf2d9065144bee5fbb3ea653fe850c710",
  "patch": "diff --git a/src/Functions/hasColumnInTable.cpp b/src/Functions/hasColumnInTable.cpp\nindex ef447070e7a9..910a290fb880 100644\n--- a/src/Functions/hasColumnInTable.cpp\n+++ b/src/Functions/hasColumnInTable.cpp\n@@ -17,6 +17,7 @@ namespace ErrorCodes\n {\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int UNKNOWN_TABLE;\n }\n \n \n@@ -110,6 +111,9 @@ void FunctionHasColumnInTable::executeImpl(Block & block, const ColumnNumbers &\n     String table_name = get_string_from_block(arguments[arg++]);\n     String column_name = get_string_from_block(arguments[arg++]);\n \n+    if (table_name.empty())\n+        throw Exception(\"Table name is empty\", ErrorCodes::UNKNOWN_TABLE);\n+\n     bool has_column;\n     if (host_name.empty())\n     {\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex d46573d04614..2d624922d2a3 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -329,5 +329,16 @@ Field convertFieldToType(const Field & from_value, const IDataType & to_type, co\n         return convertFieldToTypeImpl(from_value, to_type, from_type_hint);\n }\n \n+Field convertFieldToTypeOrThrow(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint)\n+{\n+    bool is_null = from_value.isNull();\n+    if (is_null && !to_type.isNullable())\n+        throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot convert NULL to {}\", to_type.getName());\n+    Field converted = convertFieldToType(from_value, to_type, from_type_hint);\n+    if (!is_null && converted.isNull())\n+        throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"Cannot convert value{}: it cannot be represented as {}\",\n+                        from_type_hint ? \" from \" + from_type_hint->getName() : \"\", to_type.getName());\n+    return converted;\n+}\n \n }\ndiff --git a/src/Interpreters/convertFieldToType.h b/src/Interpreters/convertFieldToType.h\nindex 801beddd876e..91b631d0e128 100644\n--- a/src/Interpreters/convertFieldToType.h\n+++ b/src/Interpreters/convertFieldToType.h\n@@ -17,4 +17,7 @@ class IDataType;\n   */\n Field convertFieldToType(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint = nullptr);\n \n+/// Does the same, but throws ARGUMENT_OUT_OF_BOUND if value does not fall into the range.\n+Field convertFieldToTypeOrThrow(const Field & from_value, const IDataType & to_type, const IDataType * from_type_hint = nullptr);\n+\n }\ndiff --git a/src/TableFunctions/TableFunctionValues.cpp b/src/TableFunctions/TableFunctionValues.cpp\nindex 5ecd978146c4..b4b243416f2f 100644\n--- a/src/TableFunctions/TableFunctionValues.cpp\n+++ b/src/TableFunctions/TableFunctionValues.cpp\n@@ -38,7 +38,7 @@ static void parseAndInsertValues(MutableColumns & res_columns, const ASTs & args\n         {\n             const auto & [value_field, value_type_ptr] = evaluateConstantExpression(args[i], context);\n \n-            Field value = convertFieldToType(value_field, *sample_block.getByPosition(0).type, value_type_ptr.get());\n+            Field value = convertFieldToTypeOrThrow(value_field, *sample_block.getByPosition(0).type, value_type_ptr.get());\n             res_columns[0]->insert(value);\n         }\n     }\n@@ -51,11 +51,11 @@ static void parseAndInsertValues(MutableColumns & res_columns, const ASTs & args\n             const Tuple & value_tuple = value_field.safeGet<Tuple>();\n \n             if (value_tuple.size() != sample_block.columns())\n-                throw Exception(\"Values size should match with number of columns\", ErrorCodes::LOGICAL_ERROR);\n+                throw Exception(\"Values size should match with number of columns\", ErrorCodes::BAD_ARGUMENTS);\n \n             for (size_t j = 0; j < value_tuple.size(); ++j)\n             {\n-                Field value = convertFieldToType(value_tuple[j], *sample_block.getByPosition(j).type, value_types_tuple[j].get());\n+                Field value = convertFieldToTypeOrThrow(value_tuple[j], *sample_block.getByPosition(j).type, value_types_tuple[j].get());\n                 res_columns[j]->insert(value);\n             }\n         }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00386_has_column_in_table.reference b/tests/queries/0_stateless/00386_has_column_in_table.reference\nindex feb61b437517..5b80b696edab 100644\n--- a/tests/queries/0_stateless/00386_has_column_in_table.reference\n+++ b/tests/queries/0_stateless/00386_has_column_in_table.reference\n@@ -12,3 +12,4 @@\n 0\n 0\n 0\n+0\ndiff --git a/tests/queries/0_stateless/00386_has_column_in_table.sql b/tests/queries/0_stateless/00386_has_column_in_table.sql\nindex 42643dd73e6d..d543bb42ca7d 100644\n--- a/tests/queries/0_stateless/00386_has_column_in_table.sql\n+++ b/tests/queries/0_stateless/00386_has_column_in_table.sql\n@@ -18,5 +18,14 @@ SELECT hasColumnInTable(currentDatabase(), 'has_column_in_table', 'nest.not_exis\n SELECT hasColumnInTable('localhost', currentDatabase(), 'has_column_in_table', 'nest.not_existing');\n SELECT hasColumnInTable(currentDatabase(), 'has_column_in_table', 'not_existing');\n SELECT hasColumnInTable('localhost', currentDatabase(), 'has_column_in_table', 'not_existing');\n+SELECT hasColumnInTable('system', 'one', '');\n+\n+/* bad queries */\n+SELECT hasColumnInTable('', '', '');  -- { serverError 60; }\n+SELECT hasColumnInTable('', 't', 'c');  -- { serverError 81; }\n+SELECT hasColumnInTable(currentDatabase(), '', 'c'); -- { serverError 60; }\n+SELECT hasColumnInTable('d', 't', 's');  -- { serverError 81; }\n+SELECT hasColumnInTable(currentDatabase(), 't', 's');  -- { serverError 60; }\n+\n \n DROP TABLE has_column_in_table;\ndiff --git a/tests/queries/0_stateless/00975_values_list.reference b/tests/queries/0_stateless/00975_values_list.reference\nindex eee9e0a0ca56..f8ada08d1302 100644\n--- a/tests/queries/0_stateless/00975_values_list.reference\n+++ b/tests/queries/0_stateless/00975_values_list.reference\n@@ -11,3 +11,4 @@ abracadabra\n 23\t23\t23\n 24\t24\t24\n 1.6660\ta\tb\n+\\N\ndiff --git a/tests/queries/0_stateless/00975_values_list.sql b/tests/queries/0_stateless/00975_values_list.sql\nindex ad30cec21e98..40c868989669 100644\n--- a/tests/queries/0_stateless/00975_values_list.sql\n+++ b/tests/queries/0_stateless/00975_values_list.sql\n@@ -11,4 +11,9 @@ SELECT * FROM VALUES('s String', ('abra'), ('cadabra'), ('abracadabra'));\n SELECT * FROM VALUES('n UInt64, s String, ss String', (1 + 22, '23', toString(23)), (toUInt64('24'), '24', concat('2', '4')));\n \n SELECT * FROM VALUES('a Decimal(4, 4), b String, c String', (divide(toDecimal32(5, 3), 3), 'a', 'b'));\n+\n+SELECT * FROM VALUES('x Float64', toUInt64(-1)); -- { serverError 69; }\n+SELECT * FROM VALUES('x Float64', NULL); -- { serverError 53; }\n+SELECT * FROM VALUES('x Nullable(Float64)', NULL);\n+\n DROP TABLE values_list;\n",
  "problem_statement": "select from values: Field::get(): Assertion failed.\n```\r\n/4/ :) SELECT * FROM VALUES('x Float64', toUInt64(-1))\r\n```\r\n\r\n@tavplubix FYI\n Logical error: 'Both table name and UUID are empty'.\n```\r\nSELECT hasColumnInTable(currentDatabase(), '', 's')\r\n```\r\n\r\nShould be user error, not internal error.\r\n\r\nFYI @tavplubix \n",
  "hints_text": "```\r\nSELECT groupUniqArray(v) FROM values('id int, v Array(int)', tuple(1048577)) GROUP BY id\r\n```\r\nAnother variant of probably the same bug.\n```\r\n      1 SELECT * FROM VALUES('a UInt64, s String', (100, ''), (257, 'three'), (1.000100016593933, 'three'))\r\n```\r\n\r\nAnother one.\n",
  "created_at": "2020-06-24T20:53:26Z"
}