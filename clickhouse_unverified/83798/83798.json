{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 83798,
  "instance_id": "ClickHouse__ClickHouse-83798",
  "issue_numbers": [
    "75381"
  ],
  "base_commit": "e83ae279b7ce7fa406179fd62c84532d82ef0ead",
  "patch": "diff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex 46b8927c7d07..15144f47f637 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1849,7 +1849,11 @@ static void buildIndexes(\n         bool l_is_minmax = typeid_cast<const MergeTreeIndexMinMax *>(l.index.get());\n         bool r_is_minmax = typeid_cast<const MergeTreeIndexMinMax *>(r.index.get());\n         if (l_is_minmax == r_is_minmax)\n-            return false;\n+        {\n+            const auto l_granularity = l.index->getGranularity();\n+            const auto r_granularity = r.index->getGranularity();\n+            return l_granularity > r_granularity;\n+        }\n \n #if USE_USEARCH\n         // A vector similarity index (if present) is the most selective, hence move it to front\n",
  "test_patch": "diff --git a/tests/parallel_replicas_blacklist.txt b/tests/parallel_replicas_blacklist.txt\nindex 3e6275fd551e..125109b38160 100644\n--- a/tests/parallel_replicas_blacklist.txt\n+++ b/tests/parallel_replicas_blacklist.txt\n@@ -358,6 +358,7 @@\n 02346_aggregation_in_order_fixed_prefix\n 02377_optimize_sorting_by_input_stream_properties_explain\n 03000_minmax_index_first\n+03563_coarser_minmax_indexes_first\n 00940_order_by_read_in_order_query_plan\n 02493_max_streams_for_merge_tree_reading\n 02675_predicate_push_down_filled_join_fix\ndiff --git a/tests/queries/0_stateless/03563_coarser_minmax_indexes_first.reference b/tests/queries/0_stateless/03563_coarser_minmax_indexes_first.reference\nnew file mode 100644\nindex 000000000000..edb29d78fbd7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03563_coarser_minmax_indexes_first.reference\n@@ -0,0 +1,2 @@\n+Name: mm_coarse\n+Name: mm_fine\ndiff --git a/tests/queries/0_stateless/03563_coarser_minmax_indexes_first.sql b/tests/queries/0_stateless/03563_coarser_minmax_indexes_first.sql\nnew file mode 100644\nindex 000000000000..731c1e46f5b9\n--- /dev/null\n+++ b/tests/queries/0_stateless/03563_coarser_minmax_indexes_first.sql\n@@ -0,0 +1,18 @@\n+DROP TABLE IF EXISTS skip_table;\n+\n+CREATE TABLE skip_table\n+(\n+    k UInt64,\n+    v UInt64,\n+    INDEX mm_fine v TYPE minmax GRANULARITY 1, -- fine-grained mm-index first\n+    INDEX mm_coarse v TYPE minmax GRANULARITY 1024\n+)\n+ENGINE = MergeTree\n+PRIMARY KEY k\n+SETTINGS index_granularity = 8192;\n+\n+INSERT INTO skip_table SELECT number, intDiv(number, 4096) FROM numbers(100000);\n+\n+SELECT trim(explain) FROM ( EXPLAIN indexes = 1 SELECT * FROM skip_table WHERE v = 125) WHERE explain like '%Name%';\n+\n+DROP TABLE skip_table;\n",
  "problem_statement": "Order of index evaluation\n### Company or project name\n\nAn in-house BI platform.\n\n### Use case\n\nSkipping indices on big tables can be done using 2 approaches:\n- granularity 1 - slow planner, less data overhead\n- granularity X>1 - faster planner, more data overhead\n\nToday I've had the idea to create big chunks indices (low number of marks) on a big table (~90b rows) and then another granularity 1 index to reduce the overhead. The granularity 1 index has ~11b marks.\nThis worked beautifully getting both fast planner execution and nominal (8192) data overhead with the following caveat: the order in which the indices are created matters because they are evaluated in the order of creation.\n\n### Describe the solution you'd like\n\nWhat if the planner, finding indices on the same column(s) picks them in the descending order of granularity by design? This way we can do a chain of increased precision wasting few quick-ish lookup instead of either pulling tons of extra-data at query execution or wasting lots of time in planning phase.\n\n### Describe alternatives you've considered\n\nTest more to find the sweet spot for granularity (that will not be the sweet spot anymore in the future when the table grows).\n\n### Additional context\n\nSee below that the planner works more than 10 times less with the reduction approach.\n\n```\ncreate table n1(n Int64, x Int64) engine=MergeTree order by n;\ncreate table n2(n Int64, x Int64) engine=MergeTree order by n;\n\ninsert into n1 (n,x) select number,number from numbers(1000000000);\n\nalter table n1 add index idx_x(x) type minmax granularity 1;\nalter table n1 add index idx_x32(x) type minmax granularity 32;\n\nalter table n1 materialize index idx_x;\nalter table n1 materialize index idx_x32;\n\ninsert into n2 (n,x) select number,number from numbers_mt(1000000000);\n\nalter table n2 add index idx_x32(x) type minmax granularity 32;\nalter table n2 add index idx_x(x) type minmax granularity 1;\n\nalter table n2 materialize index idx_x;\nalter table n2 materialize index idx_x32;\n\n```\n\n\n```\nexplain indexes=1 select * from n1 where x between 1000000 and 1001000;\n\nEXPLAIN indexes = 1\nSELECT *\nFROM n1\nWHERE (x >= 1000000) AND (x <= 1001000)\n\nQuery id: b60406d1-9ce8-41e6-a1f7-4ef23ada27ce\n\n    \u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n 1. \u2502 Expression ((Project names + Projection))  \u2502\n 2. \u2502   Expression                               \u2502\n 3. \u2502     ReadFromMergeTree (test.n1)            \u2502\n 4. \u2502     Indexes:                               \u2502\n 5. \u2502       PrimaryKey                           \u2502\n 6. \u2502         Condition: true                    \u2502\n 7. \u2502         Parts: 13/13                       \u2502\n 8. \u2502         Granules: 122076/122076            \u2502\n 9. \u2502       Skip                                 \u2502\n10. \u2502         Name: idx_x                        \u2502\n11. \u2502         Description: minmax GRANULARITY 1  \u2502\n12. \u2502         Parts: 1/13                        \u2502\n13. \u2502         Granules: 1/122076                 \u2502\n14. \u2502       Skip                                 \u2502\n15. \u2502         Name: idx_x32                      \u2502\n16. \u2502         Description: minmax GRANULARITY 32 \u2502\n17. \u2502         Parts: 1/1                         \u2502\n18. \u2502         Granules: 1/1                      \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n18 rows in set. Elapsed: 0.186 sec.\n```\n\n```\nclickhouse-7699488d5b-b252x :) explain indexes=1 select * from n2 where x between 1000000 and 1001000;\n\nEXPLAIN indexes = 1\nSELECT *\nFROM n2\nWHERE (x >= 1000000) AND (x <= 1001000)\n\nQuery id: f209452c-a725-473f-882e-cbb14465c264\n\n    \u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n 1. \u2502 Expression ((Project names + Projection))  \u2502\n 2. \u2502   Expression                               \u2502\n 3. \u2502     ReadFromMergeTree (test.n2)            \u2502\n 4. \u2502     Indexes:                               \u2502\n 5. \u2502       PrimaryKey                           \u2502\n 6. \u2502         Condition: true                    \u2502\n 7. \u2502         Parts: 3/3                         \u2502\n 8. \u2502         Granules: 122072/122072            \u2502\n 9. \u2502       Skip                                 \u2502\n10. \u2502         Name: idx_x32                      \u2502\n11. \u2502         Description: minmax GRANULARITY 32 \u2502\n12. \u2502         Parts: 1/3                         \u2502\n13. \u2502         Granules: 32/122072                \u2502\n14. \u2502       Skip                                 \u2502\n15. \u2502         Name: idx_x                        \u2502\n16. \u2502         Description: minmax GRANULARITY 1  \u2502\n17. \u2502         Parts: 1/1                         \u2502\n18. \u2502         Granules: 1/32                     \u2502\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n\n18 rows in set. Elapsed: 0.014 sec.\n```\n",
  "hints_text": "Related https://github.com/ClickHouse/ClickHouse/issues/33583",
  "created_at": "2025-07-15T17:01:04Z"
}