You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Order of index evaluation
### Company or project name

An in-house BI platform.

### Use case

Skipping indices on big tables can be done using 2 approaches:
- granularity 1 - slow planner, less data overhead
- granularity X>1 - faster planner, more data overhead

Today I've had the idea to create big chunks indices (low number of marks) on a big table (~90b rows) and then another granularity 1 index to reduce the overhead. The granularity 1 index has ~11b marks.
This worked beautifully getting both fast planner execution and nominal (8192) data overhead with the following caveat: the order in which the indices are created matters because they are evaluated in the order of creation.

### Describe the solution you'd like

What if the planner, finding indices on the same column(s) picks them in the descending order of granularity by design? This way we can do a chain of increased precision wasting few quick-ish lookup instead of either pulling tons of extra-data at query execution or wasting lots of time in planning phase.

### Describe alternatives you've considered

Test more to find the sweet spot for granularity (that will not be the sweet spot anymore in the future when the table grows).

### Additional context

See below that the planner works more than 10 times less with the reduction approach.

```
create table n1(n Int64, x Int64) engine=MergeTree order by n;
create table n2(n Int64, x Int64) engine=MergeTree order by n;

insert into n1 (n,x) select number,number from numbers(1000000000);

alter table n1 add index idx_x(x) type minmax granularity 1;
alter table n1 add index idx_x32(x) type minmax granularity 32;

alter table n1 materialize index idx_x;
alter table n1 materialize index idx_x32;

insert into n2 (n,x) select number,number from numbers_mt(1000000000);

alter table n2 add index idx_x32(x) type minmax granularity 32;
alter table n2 add index idx_x(x) type minmax granularity 1;

alter table n2 materialize index idx_x;
alter table n2 materialize index idx_x32;

```


```
explain indexes=1 select * from n1 where x between 1000000 and 1001000;

EXPLAIN indexes = 1
SELECT *
FROM n1
WHERE (x >= 1000000) AND (x <= 1001000)

Query id: b60406d1-9ce8-41e6-a1f7-4ef23ada27ce

    ┌─explain────────────────────────────────────┐
 1. │ Expression ((Project names + Projection))  │
 2. │   Expression                               │
 3. │     ReadFromMergeTree (test.n1)            │
 4. │     Indexes:                               │
 5. │       PrimaryKey                           │
 6. │         Condition: true                    │
 7. │         Parts: 13/13                       │
 8. │         Granules: 122076/122076            │
 9. │       Skip                                 │
10. │         Name: idx_x                        │
11. │         Description: minmax GRANULARITY 1  │
12. │         Parts: 1/13                        │
13. │         Granules: 1/122076                 │
14. │       Skip                                 │
15. │         Name: idx_x32                      │
16. │         Description: minmax GRANULARITY 32 │
17. │         Parts: 1/1                         │
18. │         Granules: 1/1                      │
    └────────────────────────────────────────────┘

18 rows in set. Elapsed: 0.186 sec.
```

```
clickhouse-7699488d5b-b252x :) explain indexes=1 select * from n2 where x between 1000000 and 1001000;

EXPLAIN indexes = 1
SELECT *
FROM n2
WHERE (x >= 1000000) AND (x <= 1001000)

Query id: f209452c-a725-473f-882e-cbb14465c264

    ┌─explain────────────────────────────────────┐
 1. │ Expression ((Project names + Projection))  │
 2. │   Expression                               │
 3. │     ReadFromMergeTree (test.n2)            │
 4. │     Indexes:                               │
 5. │       PrimaryKey                           │
 6. │         Condition: true                    │
 7. │         Parts: 3/3                         │
 8. │         Granules: 122072/122072            │
 9. │       Skip                                 │
10. │         Name: idx_x32                      │
11. │         Description: minmax GRANULARITY 32 │
12. │         Parts: 1/3                         │
13. │         Granules: 32/122072                │
14. │       Skip                                 │
15. │         Name: idx_x                        │
16. │         Description: minmax GRANULARITY 1  │
17. │         Parts: 1/1                         │
18. │         Granules: 1/32                     │
    └────────────────────────────────────────────┘

18 rows in set. Elapsed: 0.014 sec.
```
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
