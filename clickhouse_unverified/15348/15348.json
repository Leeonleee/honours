{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 15348,
  "instance_id": "ClickHouse__ClickHouse-15348",
  "issue_numbers": [
    "6917"
  ],
  "base_commit": "bbbe51033dfd5b8c3d54e168475ca707ac7ec0b4",
  "patch": "diff --git a/programs/local/LocalServer.cpp b/programs/local/LocalServer.cpp\nindex 5cdf5766a44e..41da477152c6 100644\n--- a/programs/local/LocalServer.cpp\n+++ b/programs/local/LocalServer.cpp\n@@ -210,7 +210,7 @@ try\n \n     /// Maybe useless\n     if (config().has(\"macros\"))\n-        context->setMacros(std::make_unique<Macros>(config(), \"macros\"));\n+        context->setMacros(std::make_unique<Macros>(config(), \"macros\", log));\n \n     /// Skip networking\n \ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex b703d0ac6a75..84945eeed4d2 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -534,7 +534,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n     }\n \n     if (config().has(\"macros\"))\n-        global_context->setMacros(std::make_unique<Macros>(config(), \"macros\"));\n+        global_context->setMacros(std::make_unique<Macros>(config(), \"macros\", log));\n \n     /// Initialize main config reloader.\n     std::string include_from_path = config().getString(\"include_from\", \"/etc/metrika.xml\");\n@@ -559,7 +559,7 @@ int Server::main(const std::vector<std::string> & /*args*/)\n             //setTextLog(global_context->getTextLog());\n             //buildLoggers(*config, logger());\n             global_context->setClustersConfig(config);\n-            global_context->setMacros(std::make_unique<Macros>(*config, \"macros\"));\n+            global_context->setMacros(std::make_unique<Macros>(*config, \"macros\", log));\n             global_context->setExternalAuthenticatorsConfig(*config);\n \n             /// Setup protection to avoid accidental DROP for big tables (that are greater than 50 GB by default)\ndiff --git a/src/Common/Macros.cpp b/src/Common/Macros.cpp\nindex e3735c443594..b8e25499c0ba 100644\n--- a/src/Common/Macros.cpp\n+++ b/src/Common/Macros.cpp\n@@ -2,6 +2,7 @@\n #include <Common/Macros.h>\n #include <Common/Exception.h>\n #include <IO/WriteHelpers.h>\n+#include <common/logger_useful.h>\n \n \n namespace DB\n@@ -12,19 +13,32 @@ namespace ErrorCodes\n     extern const int SYNTAX_ERROR;\n }\n \n-Macros::Macros(const Poco::Util::AbstractConfiguration & config, const String & root_key)\n+Macros::Macros(const Poco::Util::AbstractConfiguration & config, const String & root_key, Poco::Logger * log)\n {\n     Poco::Util::AbstractConfiguration::Keys keys;\n     config.keys(root_key, keys);\n     for (const String & key : keys)\n     {\n         macros[key] = config.getString(root_key + \".\" + key);\n+        if (key == \"database\" || key == \"table\" || key == \"uuid\")\n+        {\n+            if (log)\n+                LOG_WARNING(log,\n+                    \"Config file contains '{}' macro. This macro has special meaning \"\n+                    \"and it's explicit definition is not recommended. Implicit unfolding for \"\n+                    \"'database', 'table' and 'uuid' macros will be disabled.\",\n+                    key);\n+            enable_special_macros = false;\n+        }\n     }\n }\n \n String Macros::expand(const String & s,\n                       MacroExpansionInfo & info) const\n {\n+    /// Do not allow recursion if we expand only special macros, because it will be infinite recursion\n+    assert(info.level == 0 || !info.expand_special_macros_only);\n+\n     if (s.find('{') == String::npos)\n         return s;\n \n@@ -34,6 +48,10 @@ String Macros::expand(const String & s,\n     if (info.level >= 10)\n         throw Exception(\"Too deep recursion while expanding macros: '\" + s + \"'\", ErrorCodes::SYNTAX_ERROR);\n \n+    /// If config file contains explicit special macro, then we do not expand it in this mode.\n+    if (!enable_special_macros && info.expand_special_macros_only)\n+        return s;\n+\n     String res;\n     size_t pos = 0;\n     while (true)\n@@ -59,15 +77,21 @@ String Macros::expand(const String & s,\n         auto it = macros.find(macro_name);\n \n         /// Prefer explicit macros over implicit.\n-        if (it != macros.end())\n+        if (it != macros.end() && !info.expand_special_macros_only)\n             res += it->second;\n-        else if (macro_name == \"database\" && !info.database_name.empty())\n-            res += info.database_name;\n-        else if (macro_name == \"table\" && !info.table_name.empty())\n-            res += info.table_name;\n+        else if (macro_name == \"database\" && !info.table_id.database_name.empty())\n+        {\n+            res += info.table_id.database_name;\n+            info.expanded_database = true;\n+        }\n+        else if (macro_name == \"table\" && !info.table_id.table_name.empty())\n+        {\n+            res += info.table_id.table_name;\n+            info.expanded_table = true;\n+        }\n         else if (macro_name == \"uuid\")\n         {\n-            if (info.uuid == UUIDHelpers::Nil)\n+            if (info.table_id.uuid == UUIDHelpers::Nil)\n                 throw Exception(\"Macro 'uuid' and empty arguments of ReplicatedMergeTree \"\n                                 \"are supported only for ON CLUSTER queries with Atomic database engine\",\n                                 ErrorCodes::SYNTAX_ERROR);\n@@ -76,12 +100,16 @@ String Macros::expand(const String & s,\n             /// It becomes impossible to check if {uuid} is contained inside some unknown macro.\n             if (info.level)\n                 throw Exception(\"Macro 'uuid' should not be inside another macro\", ErrorCodes::SYNTAX_ERROR);\n-            res += toString(info.uuid);\n+            res += toString(info.table_id.uuid);\n             info.expanded_uuid = true;\n         }\n-        else if (info.ignore_unknown)\n+        else if (info.ignore_unknown || info.expand_special_macros_only)\n         {\n+            if (info.expand_special_macros_only)\n+                res += '{';\n             res += macro_name;\n+            if (info.expand_special_macros_only)\n+                res += '}';\n             info.has_unknown = true;\n         }\n         else\n@@ -93,6 +121,9 @@ String Macros::expand(const String & s,\n     }\n \n     ++info.level;\n+    if (info.expand_special_macros_only)\n+        return res;\n+\n     return expand(res, info);\n }\n \n@@ -113,9 +144,9 @@ String Macros::expand(const String & s) const\n String Macros::expand(const String & s, const StorageID & table_id, bool allow_uuid) const\n {\n     MacroExpansionInfo info;\n-    info.database_name = table_id.database_name;\n-    info.table_name = table_id.table_name;\n-    info.uuid = allow_uuid ? table_id.uuid : UUIDHelpers::Nil;\n+    info.table_id = table_id;\n+    if (!allow_uuid)\n+        info.table_id.uuid = UUIDHelpers::Nil;\n     return expand(s, info);\n }\n \ndiff --git a/src/Common/Macros.h b/src/Common/Macros.h\nindex 6e4f25d55efc..3082452e2972 100644\n--- a/src/Common/Macros.h\n+++ b/src/Common/Macros.h\n@@ -13,6 +13,7 @@ namespace Poco\n     {\n         class AbstractConfiguration;\n     }\n+    class Logger;\n }\n \n \n@@ -25,18 +26,19 @@ class Macros\n {\n public:\n     Macros() = default;\n-    Macros(const Poco::Util::AbstractConfiguration & config, const String & key);\n+    Macros(const Poco::Util::AbstractConfiguration & config, const String & key, Poco::Logger * log = nullptr);\n \n     struct MacroExpansionInfo\n     {\n         /// Settings\n-        String database_name;\n-        String table_name;\n-        UUID uuid = UUIDHelpers::Nil;\n+        StorageID table_id = StorageID::createEmpty();\n         bool ignore_unknown = false;\n+        bool expand_special_macros_only = false;\n \n         /// Information about macro expansion\n         size_t level = 0;\n+        bool expanded_database = false;\n+        bool expanded_table = false;\n         bool expanded_uuid = false;\n         bool has_unknown = false;\n     };\n@@ -64,6 +66,7 @@ class Macros\n \n private:\n     MacroMap macros;\n+    bool enable_special_macros = true;\n };\n \n \ndiff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex ed17a8eccb1f..6ad547898e2f 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -207,11 +207,13 @@ void DatabaseAtomic::renameTable(const Context & context, const String & table_n\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot move dictionary to other database\");\n \n     StoragePtr table = getTableUnlocked(table_name, db_lock);\n+    table->checkTableCanBeRenamed();\n     assert_can_move_mat_view(table);\n     StoragePtr other_table;\n     if (exchange)\n     {\n         other_table = other_db.getTableUnlocked(to_table_name, other_db_lock);\n+        other_table->checkTableCanBeRenamed();\n         assert_can_move_mat_view(other_table);\n     }\n \ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 6f318b3658a7..1b9c2ca34313 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -888,7 +888,7 @@ void InterpreterCreateQuery::prepareOnClusterQuery(ASTCreateQuery & create, cons\n         {\n             String zk_path = create.storage->engine->arguments->children[0]->as<ASTLiteral>()->value.get<String>();\n             Macros::MacroExpansionInfo info;\n-            info.uuid = create.uuid;\n+            info.table_id.uuid = create.uuid;\n             info.ignore_unknown = true;\n             context.getMacros()->expand(zk_path, info);\n             if (!info.expanded_uuid)\ndiff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 40500e78de1d..4a2e70aa84b4 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -337,6 +337,8 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n         throw Exception(\"Truncate is not supported by storage \" + getName(), ErrorCodes::NOT_IMPLEMENTED);\n     }\n \n+    virtual void checkTableCanBeRenamed() const {}\n+\n     /** Rename the table.\n       * Renaming a name in a file with metadata, the name in the list of tables in the RAM, is done separately.\n       * In this function, you need to rename the directory with the data, if any.\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 1188fd2edd33..2b0d1a606570 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -412,26 +412,31 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n     /// For Replicated.\n     String zookeeper_path;\n     String replica_name;\n+    bool allow_renaming = true;\n \n     if (replicated)\n     {\n         bool has_arguments = arg_num + 2 <= arg_cnt;\n         bool has_valid_arguments = has_arguments && engine_args[arg_num]->as<ASTLiteral>() && engine_args[arg_num + 1]->as<ASTLiteral>();\n \n+        ASTLiteral * ast_zk_path;\n+        ASTLiteral * ast_replica_name;\n+\n         if (has_valid_arguments)\n         {\n-            const auto * ast = engine_args[arg_num]->as<ASTLiteral>();\n-            if (ast && ast->value.getType() == Field::Types::String)\n-                zookeeper_path = safeGet<String>(ast->value);\n+            /// Get path and name from engine arguments\n+            ast_zk_path = engine_args[arg_num]->as<ASTLiteral>();\n+            if (ast_zk_path && ast_zk_path->value.getType() == Field::Types::String)\n+                zookeeper_path = safeGet<String>(ast_zk_path->value);\n             else\n                 throw Exception(\n                     \"Path in ZooKeeper must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n             ++arg_num;\n \n-            ast = engine_args[arg_num]->as<ASTLiteral>();\n-            if (ast && ast->value.getType() == Field::Types::String)\n-                replica_name = safeGet<String>(ast->value);\n+            ast_replica_name = engine_args[arg_num]->as<ASTLiteral>();\n+            if (ast_replica_name && ast_replica_name->value.getType() == Field::Types::String)\n+                replica_name = safeGet<String>(ast_replica_name->value);\n             else\n                 throw Exception(\n                     \"Replica name must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def), ErrorCodes::BAD_ARGUMENTS);\n@@ -444,9 +449,24 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         else if (is_extended_storage_def && !has_arguments)\n         {\n             /// Try use default values if arguments are not specified.\n-            /// It works for ON CLUSTER queries when database engine is Atomic and there are {shard} and {replica} in config.\n-            zookeeper_path = \"/clickhouse/tables/{uuid}/{shard}\";\n-            replica_name = \"{replica}\"; /// TODO maybe use hostname if {replica} is not defined?\n+            /// Note: {uuid} macro works for ON CLUSTER queries when database engine is Atomic.\n+            zookeeper_path = args.context.getConfigRef().getString(\"default_replica_path\", \"/clickhouse/tables/{uuid}/{shard}\");\n+            /// TODO maybe use hostname if {replica} is not defined?\n+            replica_name = args.context.getConfigRef().getString(\"default_replica_name\", \"{replica}\");\n+\n+            /// Modify query, so default values will be written to metadata\n+            assert(arg_num == 0);\n+            ASTs old_args;\n+            std::swap(engine_args, old_args);\n+            auto path_arg = std::make_shared<ASTLiteral>(zookeeper_path);\n+            auto name_arg = std::make_shared<ASTLiteral>(replica_name);\n+            ast_zk_path = path_arg.get();\n+            ast_replica_name = name_arg.get();\n+            engine_args.emplace_back(std::move(path_arg));\n+            engine_args.emplace_back(std::move(name_arg));\n+            std::move(std::begin(old_args), std::end(old_args), std::back_inserter(engine_args));\n+            arg_num = 2;\n+            arg_cnt += 2;\n         }\n         else\n             throw Exception(\"Expected two string literal arguments: zookeper_path and replica_name\", ErrorCodes::BAD_ARGUMENTS);\n@@ -454,8 +474,44 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         /// Allow implicit {uuid} macros only for zookeeper_path in ON CLUSTER queries\n         bool is_on_cluster = args.local_context.getClientInfo().query_kind == ClientInfo::QueryKind::SECONDARY_QUERY;\n         bool allow_uuid_macro = is_on_cluster || args.query.attach;\n-        zookeeper_path = args.context.getMacros()->expand(zookeeper_path, args.table_id, allow_uuid_macro);\n-        replica_name = args.context.getMacros()->expand(replica_name, args.table_id, false);\n+\n+        /// Unfold {database} and {table} macro on table creation, so table can be renamed.\n+        /// We also unfold {uuid} macro, so path will not be broken after moving table from Atomic to Ordinary database.\n+        if (!args.attach)\n+        {\n+            Macros::MacroExpansionInfo info;\n+            /// NOTE: it's not recursive\n+            info.expand_special_macros_only = true;\n+            info.table_id = args.table_id;\n+            if (!allow_uuid_macro)\n+                info.table_id.uuid = UUIDHelpers::Nil;\n+            zookeeper_path = args.context.getMacros()->expand(zookeeper_path, info);\n+\n+            info.level = 0;\n+            info.table_id.uuid = UUIDHelpers::Nil;\n+            replica_name = args.context.getMacros()->expand(replica_name, info);\n+        }\n+\n+        ast_zk_path->value = zookeeper_path;\n+        ast_replica_name->value = replica_name;\n+\n+        /// Expand other macros (such as {shard} and {replica}). We do not expand them on previous step\n+        /// to make possible copying metadata files between replicas.\n+        Macros::MacroExpansionInfo info;\n+        info.table_id = args.table_id;\n+        if (!allow_uuid_macro)\n+            info.table_id.uuid = UUIDHelpers::Nil;\n+        zookeeper_path = args.context.getMacros()->expand(zookeeper_path, info);\n+\n+        info.level = 0;\n+        info.table_id.uuid = UUIDHelpers::Nil;\n+        replica_name = args.context.getMacros()->expand(replica_name, info);\n+\n+        /// We do not allow renaming table with these macros in metadata, because zookeeper_path will be broken after RENAME TABLE.\n+        /// NOTE: it may happen if table was created by older version of ClickHouse (< 20.10) and macros was not unfolded on table creation\n+        /// or if one of these macros is recursively expanded from some other macro.\n+        if (info.expanded_database || info.expanded_table)\n+            allow_renaming = false;\n     }\n \n     /// This merging param maybe used as part of sorting key\n@@ -706,7 +762,8 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n             date_column_name,\n             merging_params,\n             std::move(storage_settings),\n-            args.has_force_restore_data_flag);\n+            args.has_force_restore_data_flag,\n+            allow_renaming);\n     else\n         return StorageMergeTree::create(\n             args.table_id,\ndiff --git a/src/Storages/StorageFactory.cpp b/src/Storages/StorageFactory.cpp\nindex 0a8ceb4b8e58..eda9f36010f6 100644\n--- a/src/Storages/StorageFactory.cpp\n+++ b/src/Storages/StorageFactory.cpp\n@@ -180,7 +180,16 @@ StoragePtr StorageFactory::get(\n         .has_force_restore_data_flag = has_force_restore_data_flag\n     };\n \n-    return storages.at(name).creator_fn(arguments);\n+    auto res = storages.at(name).creator_fn(arguments);\n+    if (!empty_engine_args.empty())\n+    {\n+        /// Storage creator modified empty arguments list, so we should modify the query\n+        assert(storage_def && storage_def->engine && !storage_def->engine->arguments);\n+        storage_def->engine->arguments = std::make_shared<ASTExpressionList>();\n+        storage_def->engine->children.push_back(storage_def->engine->arguments);\n+        storage_def->engine->arguments->children = empty_engine_args;\n+    }\n+    return res;\n }\n \n StorageFactory & StorageFactory::instance()\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex 65c0c5ac3137..9613bd5111da 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -178,7 +178,8 @@ StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n     const String & date_column_name,\n     const MergingParams & merging_params_,\n     std::unique_ptr<MergeTreeSettings> settings_,\n-    bool has_force_restore_data_flag)\n+    bool has_force_restore_data_flag,\n+    bool allow_renaming_)\n     : MergeTreeData(table_id_,\n                     relative_data_path_,\n                     metadata_,\n@@ -200,6 +201,7 @@ StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n     , cleanup_thread(*this)\n     , part_check_thread(*this)\n     , restarting_thread(*this)\n+    , allow_renaming(allow_renaming_)\n {\n     queue_updating_task = global_context.getSchedulePool().createTask(\n         getStorageID().getFullTableName() + \" (StorageReplicatedMergeTree::queueUpdatingTask)\", [this]{ queueUpdatingTask(); });\n@@ -4187,8 +4189,17 @@ void StorageReplicatedMergeTree::checkTableCanBeDropped() const\n     global_context.checkTableCanBeDropped(table_id.database_name, table_id.table_name, getTotalActiveSizeInBytes());\n }\n \n+void StorageReplicatedMergeTree::checkTableCanBeRenamed() const\n+{\n+    if (!allow_renaming)\n+        throw Exception(\"Cannot rename Replicated table, because zookeeper_path contains implicit 'database' or 'table' macro. \"\n+                        \"We cannot rename path in ZooKeeper, so path may become inconsistent with table name. If you really want to rename table, \"\n+                        \"you should edit metadata file first and restart server or reattach the table.\", ErrorCodes::NOT_IMPLEMENTED);\n+}\n+\n void StorageReplicatedMergeTree::rename(const String & new_path_to_table_data, const StorageID & new_table_id)\n {\n+    checkTableCanBeRenamed();\n     MergeTreeData::rename(new_path_to_table_data, new_table_id);\n \n     /// Update table name in zookeeper\ndiff --git a/src/Storages/StorageReplicatedMergeTree.h b/src/Storages/StorageReplicatedMergeTree.h\nindex 2bc9265331d2..d851082d5c2b 100644\n--- a/src/Storages/StorageReplicatedMergeTree.h\n+++ b/src/Storages/StorageReplicatedMergeTree.h\n@@ -128,6 +128,8 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n \n     void truncate(const ASTPtr &, const StorageMetadataPtr &, const Context &, TableExclusiveLockHolder &) override;\n \n+    void checkTableCanBeRenamed() const override;\n+\n     void rename(const String & new_path_to_table_data, const StorageID & new_table_id) override;\n \n     bool supportsIndexForIn() const override { return true; }\n@@ -304,6 +306,9 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n     /// True if replica was created for existing table with fixed granularity\n     bool other_replicas_fixed_granularity = false;\n \n+    /// Do not allow RENAME TABLE if zookeeper_path contains {database} or {table} macro\n+    const bool allow_renaming;\n+\n     template <class Func>\n     void foreachCommittedParts(const Func & func) const;\n \n@@ -571,7 +576,8 @@ class StorageReplicatedMergeTree final : public ext::shared_ptr_helper<StorageRe\n         const String & date_column_name,\n         const MergingParams & merging_params_,\n         std::unique_ptr<MergeTreeSettings> settings_,\n-        bool has_force_restore_data_flag);\n+        bool has_force_restore_data_flag,\n+        bool allow_renaming_);\n };\n \n \n",
  "test_patch": "diff --git a/tests/config/config.d/macros.xml b/tests/config/config.d/macros.xml\nindex 97c3065471f7..4902b12bc819 100644\n--- a/tests/config/config.d/macros.xml\n+++ b/tests/config/config.d/macros.xml\n@@ -3,5 +3,7 @@\n         <test>Hello, world!</test>\n         <shard>s1</shard>\n         <replica>r1</replica>\n+        <default_path_test>/clickhouse/tables/{database}/{shard}/</default_path_test>\n+        <default_name_test>table_{table}</default_name_test>\n     </macros>\n </yandex>\ndiff --git a/tests/integration/test_distributed_ddl/test.py b/tests/integration/test_distributed_ddl/test.py\nindex b788dafe167d..9f01fa7ed5b1 100755\n--- a/tests/integration/test_distributed_ddl/test.py\n+++ b/tests/integration/test_distributed_ddl/test.py\n@@ -330,10 +330,12 @@ def test_replicated_without_arguments(test_cluster):\n     assert \"are supported only for ON CLUSTER queries with Atomic database engine\" in \\\n            instance.query_and_get_error(\"CREATE TABLE test_atomic.rmt (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\")\n     test_cluster.ddl_check_query(instance,\n-                                 \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\")\n+                                 \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree() ORDER BY n\")\n     test_cluster.ddl_check_query(instance, \"DROP TABLE test_atomic.rmt ON CLUSTER cluster\")\n     test_cluster.ddl_check_query(instance,\n-                                 \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\")\n+                                 \"CREATE TABLE test_atomic.rmt UUID '12345678-0000-4000-8000-000000000001' ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree ORDER BY n\")\n+    assert instance.query(\"SHOW CREATE test_atomic.rmt FORMAT TSVRaw\") == \\\n+           \"CREATE TABLE test_atomic.rmt\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = ReplicatedMergeTree('/clickhouse/tables/12345678-0000-4000-8000-000000000001/{shard}', '{replica}')\\nORDER BY n\\nSETTINGS index_granularity = 8192\\n\"\n     test_cluster.ddl_check_query(instance, \"RENAME TABLE test_atomic.rmt TO test_atomic.rmt_renamed ON CLUSTER cluster\")\n     test_cluster.ddl_check_query(instance,\n                                  \"CREATE TABLE test_atomic.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree('/clickhouse/tables/{uuid}/{shard}', '{replica}') ORDER BY n\")\n@@ -349,6 +351,8 @@ def test_replicated_without_arguments(test_cluster):\n     assert \"are supported only for ON CLUSTER queries with Atomic database engine\" in \\\n            instance.query_and_get_error(\"CREATE TABLE test_ordinary.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree('/{shard}/{uuid}/', '{replica}') ORDER BY n\")\n     test_cluster.ddl_check_query(instance, \"CREATE TABLE test_ordinary.rmt ON CLUSTER cluster (n UInt64, s String) ENGINE=ReplicatedMergeTree('/{shard}/{table}/', '{replica}') ORDER BY n\")\n+    assert instance.query(\"SHOW CREATE test_ordinary.rmt FORMAT TSVRaw\") == \\\n+           \"CREATE TABLE test_ordinary.rmt\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = ReplicatedMergeTree('/{shard}/rmt/', '{replica}')\\nORDER BY n\\nSETTINGS index_granularity = 8192\\n\"\n     test_cluster.ddl_check_query(instance, \"DROP DATABASE test_ordinary ON CLUSTER cluster\")\n     test_cluster.pm_random_drops.push_rules(rules)\n \ndiff --git a/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.reference b/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.reference\nnew file mode 100644\nindex 000000000000..d217855586be\n--- /dev/null\n+++ b/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.reference\n@@ -0,0 +1,4 @@\n+CREATE TABLE default.rmt\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/test_01148/{shard}/default/rmt\\', \\'{replica}\\')\\nORDER BY n\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.rmt1\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/test_01148/{shard}/default/rmt\\', \\'{replica}\\')\\nORDER BY n\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.rmt\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = ReplicatedMergeTree(\\'{default_path_test}test_01148\\', \\'{default_name_test}\\')\\nORDER BY n\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.rmt\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = ReplicatedMergeTree(\\'{default_path_test}test_01148\\', \\'{default_name_test}\\')\\nORDER BY n\\nSETTINGS index_granularity = 8192\ndiff --git a/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.sql b/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.sql\nnew file mode 100644\nindex 000000000000..e13b25d1706b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.sql\n@@ -0,0 +1,19 @@\n+DROP TABLE IF EXISTS rmt;\n+\n+CREATE TABLE rmt (n UInt64, s String) ENGINE = ReplicatedMergeTree('/clickhouse/test_01148/{shard}/{database}/{table}', '{replica}') ORDER BY n;\n+SHOW CREATE TABLE rmt;\n+RENAME TABLE rmt TO rmt1;\n+DETACH TABLE rmt1;\n+ATTACH TABLE rmt1;\n+SHOW CREATE TABLE rmt1;\n+\n+CREATE TABLE rmt (n UInt64, s String) ENGINE = ReplicatedMergeTree('{default_path_test}{uuid}', '{default_name_test}') ORDER BY n;    -- { serverError 62 }\n+CREATE TABLE rmt (n UInt64, s String) ENGINE = ReplicatedMergeTree('{default_path_test}test_01148', '{default_name_test}') ORDER BY n;\n+SHOW CREATE TABLE rmt;\n+RENAME TABLE rmt TO rmt2;   -- { serverError 48 }\n+DETACH TABLE rmt;\n+ATTACH TABLE rmt;\n+SHOW CREATE TABLE rmt;\n+\n+DROP TABLE rmt;\n+DROP TABLE rmt1;\n",
  "problem_statement": "{table} and {database} macro in ReplicatedMergeTree vs RENAME TABLE \nIf table was created with {database} and {table} macros in zookeeper path, then RENAME operation makes it stop working. \r\n\r\nProbably those macros should be unfold at the moment of table creation. \n",
  "hints_text": "Related https://github.com/yandex/ClickHouse/pull/3251 \nSimilar https://github.com/yandex/ClickHouse/issues/6104\nWe can unfold these macros at the table creation\r\nbut we should not unfold all other macros (shard, layer, etc.)\r\nbecause there is typical scenario when table metadata (`.sql`) is copied between shards.\r\n\r\nAnd the proposed logic of unfolding some macros and not unfolding other macros looks questionable.\nRelated #12135",
  "created_at": "2020-09-26T19:23:33Z",
  "modified_files": [
    "programs/local/LocalServer.cpp",
    "programs/server/Server.cpp",
    "src/Common/Macros.cpp",
    "src/Common/Macros.h",
    "src/Databases/DatabaseAtomic.cpp",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Storages/IStorage.h",
    "src/Storages/MergeTree/registerStorageMergeTree.cpp",
    "src/Storages/StorageFactory.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.h"
  ],
  "modified_test_files": [
    "tests/config/config.d/macros.xml",
    "tests/integration/test_distributed_ddl/test.py",
    "b/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.reference",
    "b/tests/queries/0_stateless/01148_zookeeper_path_macros_unfolding.sql"
  ]
}