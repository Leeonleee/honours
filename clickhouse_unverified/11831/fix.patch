diff --git a/src/Common/intExp.h b/src/Common/intExp.h
index 0212eb4c084d..a021d9660ffd 100644
--- a/src/Common/intExp.h
+++ b/src/Common/intExp.h
@@ -134,3 +134,14 @@ inline __int128 exp10_i128(int x)
 }
 
 }
+
+
+/// intExp10 returning the type T.
+template <typename T>
+inline T intExp10OfSize(int x)
+{
+    if constexpr (sizeof(T) <= 8)
+        return intExp10(x);
+    else
+        return common::exp10_i128(x);
+}
diff --git a/src/Functions/intExp10.cpp b/src/Functions/intExp10.cpp
index 112e21a51b4e..3192c9e2f795 100644
--- a/src/Functions/intExp10.cpp
+++ b/src/Functions/intExp10.cpp
@@ -31,8 +31,13 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameIntExp10>
     static bool has() { return true; }
     static IFunction::Monotonicity get(const Field & left, const Field & right)
     {
-        Float64 left_float = left.isNull() ? -std::numeric_limits<Float64>::infinity() : applyVisitor(FieldVisitorConvertToNumber<Float64>(), left);
-        Float64 right_float = right.isNull() ? std::numeric_limits<Float64>::infinity() : applyVisitor(FieldVisitorConvertToNumber<Float64>(), right);
+        Float64 left_float = left.isNull()
+            ? -std::numeric_limits<Float64>::infinity()
+            : applyVisitor(FieldVisitorConvertToNumber<Float64>(), left);
+
+        Float64 right_float = right.isNull()
+            ? std::numeric_limits<Float64>::infinity()
+            : applyVisitor(FieldVisitorConvertToNumber<Float64>(), right);
 
         if (left_float < 0 || right_float > 19)
             return {};
diff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h
index 5a6a63529e21..44405357a107 100644
--- a/src/IO/readDecimalText.h
+++ b/src/IO/readDecimalText.h
@@ -1,4 +1,7 @@
+#pragma once
+
 #include <IO/ReadHelpers.h>
+#include <Common/intExp.h>
 
 
 namespace DB
@@ -80,21 +83,33 @@ inline bool readDigits(ReadBuffer & buf, T & x, uint32_t & digits, int32_t & exp
                 ++places; // num zeroes before + current digit
                 if (digits + places > max_digits)
                 {
-                    if constexpr (_throw_on_error)
-                        throw Exception("Too many digits (" + std::to_string(digits + places) + " > " + std::to_string(max_digits)
-                            + ") in decimal value", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
-                    return false;
+                    if (after_point)
+                    {
+                        /// Simply cut excessive digits.
+                        break;
+                    }
+                    else
+                    {
+                        if constexpr (_throw_on_error)
+                            throw Exception("Too many digits (" + std::to_string(digits + places) + " > " + std::to_string(max_digits)
+                                + ") in decimal value", ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+
+                        return false;
+                    }
                 }
+                else
+                {
+                    digits += places;
+                    if (after_point)
+                        exponent -= places;
 
-                digits += places;
-                if (after_point)
-                    exponent -= places;
+                    // TODO: accurate shift10 for big integers
+                    x *= intExp10OfSize<T>(places);
+                    places = 0;
 
-                // TODO: accurate shift10 for big integers
-                for (; places; --places)
-                    x *= 10;
-                x += (byte - '0');
-                break;
+                    x += (byte - '0');
+                    break;
+                }
             }
             case 'e': [[fallthrough]];
             case 'E':
@@ -144,10 +159,14 @@ inline void readDecimalText(ReadBuffer & buf, T & x, uint32_t precision, uint32_
             digits, x, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
 
     if (static_cast<int32_t>(scale) + exponent < 0)
-        throw Exception(fmt::format(
-            "Decimal value has too large number of digits after point: {} digits were read: {}e{}."
-            " Expected to read decimal with scale {} and precision {}",
-            digits, x, exponent, scale, precision), ErrorCodes::ARGUMENT_OUT_OF_BOUND);
+    {
+        /// Too many digits after point. Just cut off excessive digits.
+        auto divisor = intExp10OfSize<T>(-exponent - static_cast<int32_t>(scale));
+        assert(divisor > 0);    /// This is for Clang Static Analyzer. It is not smart enough to infer it automatically.
+        x.value /= divisor;
+        scale = 0;
+        return;
+    }
 
     scale += exponent;
 }
