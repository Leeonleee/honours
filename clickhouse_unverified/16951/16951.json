{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16951,
  "instance_id": "ClickHouse__ClickHouse-16951",
  "issue_numbers": [
    "12604"
  ],
  "base_commit": "6787f984761f8ed6b010f711c3ce76acf60bc56e",
  "patch": "diff --git a/src/Interpreters/AggregateFunctionOfGroupByKeysVisitor.h b/src/Interpreters/AggregateFunctionOfGroupByKeysVisitor.h\nindex 3a7efe3d6b9d..327e422e7767 100644\n--- a/src/Interpreters/AggregateFunctionOfGroupByKeysVisitor.h\n+++ b/src/Interpreters/AggregateFunctionOfGroupByKeysVisitor.h\n@@ -20,8 +20,8 @@ struct KeepAggregateFunctionMatcher\n {\n     struct Data\n     {\n-        std::unordered_set<String> & group_by_keys;\n-        bool & keep_aggregator;\n+        const NameSet & group_by_keys;\n+        bool keep_aggregator;\n     };\n \n     using Visitor = InDepthNodeVisitor<KeepAggregateFunctionMatcher, true>;\n@@ -33,7 +33,7 @@ struct KeepAggregateFunctionMatcher\n \n     static void visit(ASTFunction & function_node, Data & data)\n     {\n-        if ((function_node.arguments->children).empty())\n+        if (function_node.arguments->children.empty())\n         {\n             data.keep_aggregator = true;\n             return;\n@@ -47,12 +47,9 @@ struct KeepAggregateFunctionMatcher\n \n     static void visit(ASTIdentifier & ident, Data & data)\n     {\n-        if (!data.group_by_keys.count(ident.shortName()))\n-        {\n-            /// if variable of a function is not in GROUP BY keys, this function should not be deleted\n+        /// if variable of a function is not in GROUP BY keys, this function should not be deleted\n+        if (!data.group_by_keys.count(ident.getColumnName()))\n             data.keep_aggregator = true;\n-            return;\n-        }\n     }\n \n     static void visit(const ASTPtr & ast, Data & data)\n@@ -75,21 +72,21 @@ struct KeepAggregateFunctionMatcher\n     }\n };\n \n-using KeepAggregateFunctionVisitor = InDepthNodeVisitor<KeepAggregateFunctionMatcher, true>;\n+using KeepAggregateFunctionVisitor = KeepAggregateFunctionMatcher::Visitor;\n \n class SelectAggregateFunctionOfGroupByKeysMatcher\n {\n public:\n     struct Data\n     {\n-        std::unordered_set<String> & group_by_keys;\n+        const NameSet & group_by_keys;\n     };\n \n     static bool needChildVisit(const ASTPtr & node, const ASTPtr &)\n     {\n         /// Don't descent into table functions and subqueries and special case for ArrayJoin.\n-        return !node->as<ASTSubquery>() &&\n-               !(node->as<ASTTableExpression>() || node->as<ASTSelectWithUnionQuery>() || node->as<ASTArrayJoin>());\n+        return !node->as<ASTSubquery>() && !node->as<ASTTableExpression>()\n+            && !node->as<ASTSelectWithUnionQuery>() && !node->as<ASTArrayJoin>();\n     }\n \n     static void visit(ASTPtr & ast, Data & data)\n@@ -99,12 +96,11 @@ class SelectAggregateFunctionOfGroupByKeysMatcher\n         if (function_node && (function_node->name == \"min\" || function_node->name == \"max\" ||\n                               function_node->name == \"any\" || function_node->name == \"anyLast\"))\n         {\n-            bool keep_aggregator = false;\n-            KeepAggregateFunctionVisitor::Data keep_data{data.group_by_keys, keep_aggregator};\n+            KeepAggregateFunctionVisitor::Data keep_data{data.group_by_keys, false};\n             KeepAggregateFunctionVisitor(keep_data).visit(function_node->arguments);\n \n             /// Place argument of an aggregate function instead of function\n-            if (!keep_aggregator && !function_node->arguments->children.empty())\n+            if (!keep_data.keep_aggregator && !function_node->arguments->children.empty())\n             {\n                 String alias = function_node->alias;\n                 ast = (function_node->arguments->children[0])->clone();\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 61ca933dd535..4350ebdbe343 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -177,43 +177,21 @@ void optimizeGroupBy(ASTSelectQuery * select_query, const NameSet & source_colum\n \n struct GroupByKeysInfo\n {\n-    std::unordered_set<String> key_names; ///set of keys' short names\n-    bool has_identifier = false;\n+    NameSet key_names; ///set of keys' short names\n     bool has_function = false;\n-    bool has_possible_collision = false;\n };\n \n-GroupByKeysInfo getGroupByKeysInfo(ASTs & group_keys)\n+GroupByKeysInfo getGroupByKeysInfo(const ASTs & group_by_keys)\n {\n     GroupByKeysInfo data;\n \n-    ///filling set with short names of keys\n-    for (auto & group_key : group_keys)\n+    /// filling set with short names of keys\n+    for (const auto & group_key : group_by_keys)\n     {\n         if (group_key->as<ASTFunction>())\n             data.has_function = true;\n \n-        if (auto * group_key_ident = group_key->as<ASTIdentifier>())\n-        {\n-            data.has_identifier = true;\n-            if (data.key_names.count(group_key_ident->shortName()))\n-            {\n-                ///There may be a collision between different tables having similar variables.\n-                ///Due to the fact that we can't track these conflicts yet,\n-                ///it's better to disable some optimizations to avoid elimination necessary keys.\n-                data.has_possible_collision = true;\n-            }\n-\n-            data.key_names.insert(group_key_ident->shortName());\n-        }\n-        else if (auto * group_key_func = group_key->as<ASTFunction>())\n-        {\n-            data.key_names.insert(group_key_func->getColumnName());\n-        }\n-        else\n-        {\n-            data.key_names.insert(group_key->getColumnName());\n-        }\n+        data.key_names.insert(group_key->getColumnName());\n     }\n \n     return data;\n@@ -225,47 +203,28 @@ void optimizeGroupByFunctionKeys(ASTSelectQuery * select_query)\n     if (!select_query->groupBy())\n         return;\n \n-    auto grp_by = select_query->groupBy();\n-    auto & group_keys = grp_by->children;\n+    auto group_by = select_query->groupBy();\n+    const auto & group_by_keys = group_by->children;\n \n     ASTs modified; ///result\n \n-    GroupByKeysInfo group_by_keys_data = getGroupByKeysInfo(group_keys);\n+    GroupByKeysInfo group_by_keys_data = getGroupByKeysInfo(group_by_keys);\n \n-    if (!group_by_keys_data.has_function || group_by_keys_data.has_possible_collision)\n+    if (!group_by_keys_data.has_function)\n         return;\n \n     GroupByFunctionKeysVisitor::Data visitor_data{group_by_keys_data.key_names};\n-    GroupByFunctionKeysVisitor(visitor_data).visit(grp_by);\n-\n-    modified.reserve(group_keys.size());\n-\n-    ///filling the result\n-    for (auto & group_key : group_keys)\n-    {\n-        if (auto * group_key_func = group_key->as<ASTFunction>())\n-        {\n-            if (group_by_keys_data.key_names.count(group_key_func->getColumnName()))\n-                modified.push_back(group_key);\n+    GroupByFunctionKeysVisitor(visitor_data).visit(group_by);\n \n-            continue;\n-        }\n-        if (auto * group_key_ident = group_key->as<ASTIdentifier>())\n-        {\n-            if (group_by_keys_data.key_names.count(group_key_ident->shortName()))\n-                modified.push_back(group_key);\n+    modified.reserve(group_by_keys.size());\n \n-            continue;\n-        }\n-        else\n-        {\n-            if (group_by_keys_data.key_names.count(group_key->getColumnName()))\n-                modified.push_back(group_key);\n-        }\n-    }\n+    /// filling the result\n+    for (const auto & group_key : group_by_keys)\n+        if (group_by_keys_data.key_names.count(group_key->getColumnName()))\n+            modified.push_back(group_key);\n \n-    ///modifying the input\n-    grp_by->children = modified;\n+    /// modifying the input\n+    group_by->children = modified;\n }\n \n /// Eliminates min/max/any-aggregators of functions of GROUP BY keys\n@@ -274,10 +233,8 @@ void optimizeAggregateFunctionsOfGroupByKeys(ASTSelectQuery * select_query, ASTP\n     if (!select_query->groupBy())\n         return;\n \n-    auto grp_by = select_query->groupBy();\n-    auto & group_keys = grp_by->children;\n-\n-    GroupByKeysInfo group_by_keys_data = getGroupByKeysInfo(group_keys);\n+    const auto & group_by_keys = select_query->groupBy()->children;\n+    GroupByKeysInfo group_by_keys_data = getGroupByKeysInfo(group_by_keys);\n \n     SelectAggregateFunctionOfGroupByKeysVisitor::Data visitor_data{group_by_keys_data.key_names};\n     SelectAggregateFunctionOfGroupByKeysVisitor(visitor_data).visit(node);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01561_aggregate_functions_of_key_with_join.reference b/tests/queries/0_stateless/01561_aggregate_functions_of_key_with_join.reference\nnew file mode 100644\nindex 000000000000..9874d6464ab7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01561_aggregate_functions_of_key_with_join.reference\n@@ -0,0 +1,1 @@\n+1\t2\ndiff --git a/tests/queries/0_stateless/01561_aggregate_functions_of_key_with_join.sql b/tests/queries/0_stateless/01561_aggregate_functions_of_key_with_join.sql\nnew file mode 100644\nindex 000000000000..66047fcc1a6a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01561_aggregate_functions_of_key_with_join.sql\n@@ -0,0 +1,5 @@\n+SET optimize_aggregators_of_group_by_keys = 1;\n+SELECT source.key, max(target.key) FROM (SELECT 1 key, 'x' name) source\n+INNER JOIN (SELECT 2 key, 'x' name) target\n+ON source.name = target.name\n+GROUP BY source.key;\n",
  "problem_statement": "\"Not found column\" when using two columns with the same name and GROUP BY\n**Describe the bug**\r\nClickhouse seems to be unable to find the source for a column for the aggregation function for a column where the name is ambigious but specified with alias.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: 20.5.2.7\r\n* Which interface to use, if matters: HTTP (but should not matter)\r\n* Non-default settings, if any: None that I am aware of\r\n\r\n```sql\r\nCREATE TABLE `source` (\r\n\t`key` FixedString(15),\r\n\t`name` Int8,\r\n\t`value` Int8\r\n) ENGINE = Log();\r\n\r\nCREATE TABLE `target` (\r\n\t`key` FixedString(15),\r\n\t`name` Int8,\r\n\t`flower` Int8\r\n) ENGINE = Log();\r\n\r\n-- Query 1: Exception\r\nSELECT \r\n\t`source`.`key`,\r\n\tmax(dummy.`key`)\r\nFROM `source`\r\nINNER JOIN (\r\n\tSELECT `key`, name, flower FROM `target`\r\n) AS dummy ON `source`.name = dummy.name\r\nGROUP BY `source`.`key`;\r\n\r\n-- Query 2: Working\r\nSELECT \r\n\t`source`.`key`,\r\n\tmax(dummy.`key2`)\r\nFROM `source`\r\nINNER JOIN (\r\n\tSELECT `key` as `key2`, name, flower FROM `target`\r\n) AS dummy ON `source`.name = dummy.name\r\nGROUP BY `source`.`key`\r\n```\r\n\r\n**Expected behavior**\r\nClickhouse should be able to distinguish between the the column `source.key` that is used in the `GROUP BY` statement and the column `dummy.key` (or `target.key`).\r\n\r\n**Error message and/or stacktrace**\r\nWhen running the first query, the following exception is returned from the database:\r\n```\r\nClickHouse exception, code: 10, host: my.clickhouse.host, port: 8080; Code: 10, e.displayText() = DB::Exception: Not found column dummy.key in block. There are only columns: key (version 20.5.2.7 (official build))\r\n```\r\n\r\n**Additional context**\r\nAs you can see in the second query, if you remove any ambigious columns from the `SELECT` part, the problem seems to be gone.\r\nThis may be related to https://github.com/ClickHouse/ClickHouse/issues/12601\r\n\n",
  "hints_text": "Reproduced. `GROUP BY` eats column.\r\n\r\n```\r\nSELECT source.key, target.key FROM (SELECT 1 key, 'x' name) source\r\nINNER JOIN (SELECT 2 key, 'x' name) target\r\nON source.name = target.name\r\nORDER BY source.key; -- OK\r\n```\r\n```\r\nSELECT source.key, max(target.key) FROM (SELECT 1 key, 'x' name) source\r\nINNER JOIN (SELECT 2 key, 'x' name) target\r\nON source.name = target.name\r\nGROUP BY source.key; -- FAIL\r\n```\nas a workaround, you can temporary disable this setting:\r\nset optimize_aggregators_of_group_by_keys = 1;\nUnfortunately this issue still appears with the latest stable version 20.10.3.30 and hinders us upgrading our production instances.\r\nIs this an intended behaviour, so we need to check and modify all of our queries, which are affected?",
  "created_at": "2020-11-12T19:53:37Z"
}