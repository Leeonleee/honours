{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25203,
  "instance_id": "ClickHouse__ClickHouse-25203",
  "issue_numbers": [
    "4910"
  ],
  "base_commit": "494107e43709ad509cb045088d6f6327f3cd4703",
  "patch": "diff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h\nindex 55027aa88538..1478518dee4c 100644\n--- a/src/Dictionaries/DictionaryHelpers.h\n+++ b/src/Dictionaries/DictionaryHelpers.h\n@@ -7,6 +7,8 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnVector.h>\n #include <Columns/ColumnArray.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnNullable.h>\n #include <DataStreams/IBlockInputStream.h>\n #include <DataTypes/DataTypesDecimal.h>\n #include <DataTypes/DataTypeArray.h>\n@@ -284,6 +286,8 @@ class DictionaryAttributeColumnProvider\n   *\n   * If default_values_column is null then attribute_default_value will be used.\n   * If default_values_column is not null in constructor than this column values will be used as default values.\n+  *\n+  * For nullable dictionary attribute isNullAt method is provided.\n  */\n template <typename DictionaryAttributeType>\n class DictionaryDefaultValueExtractor\n@@ -293,22 +297,40 @@ class DictionaryDefaultValueExtractor\n public:\n     using DefaultValueType = DictionaryValueType<DictionaryAttributeType>;\n \n-    explicit DictionaryDefaultValueExtractor(DictionaryAttributeType attribute_default_value, ColumnPtr default_values_column_ = nullptr)\n-        : default_value(std::move(attribute_default_value))\n+    explicit DictionaryDefaultValueExtractor(\n+        Field attribute_default_value,\n+        ColumnPtr default_values_column_)\n     {\n+        if (default_values_column_ != nullptr &&\n+            isColumnConst(*default_values_column_))\n+        {\n+            attribute_default_value = (*default_values_column_)[0];\n+            default_values_column_ = nullptr;\n+        }\n+\n         if (default_values_column_ == nullptr)\n+        {\n             use_attribute_default_value = true;\n+\n+            if (attribute_default_value.isNull())\n+                default_value_is_null = true;\n+            else\n+                default_value = attribute_default_value.get<NearestFieldType<DictionaryAttributeType>>();\n+        }\n         else\n         {\n-            if (const auto * const default_col = checkAndGetColumn<DefaultColumnType>(*default_values_column_))\n+            const IColumn * default_values_column_ptr = default_values_column_.get();\n+\n+            if (const ColumnNullable * nullable_column = typeid_cast<const ColumnNullable *>(default_values_column_.get()))\n             {\n-                default_values_column = default_col;\n-                use_attribute_default_value = false;\n+                default_values_column_ptr = nullable_column->getNestedColumnPtr().get();\n+                is_null_map = &nullable_column->getNullMapColumn();\n             }\n-            else if (const auto * const default_col_const = checkAndGetColumnConst<DefaultColumnType>(default_values_column_.get()))\n+\n+            if (const auto * const default_col = checkAndGetColumn<DefaultColumnType>(default_values_column_ptr))\n             {\n-                default_value = default_col_const->template getValue<DictionaryAttributeType>();\n-                use_attribute_default_value = true;\n+                default_values_column = default_col;\n+                use_attribute_default_value = false;\n             }\n             else\n                 throw Exception(ErrorCodes::TYPE_MISMATCH, \"Type of default column is not the same as dictionary attribute type.\");\n@@ -332,10 +354,24 @@ class DictionaryDefaultValueExtractor\n         else\n             return default_values_column->getData()[row];\n     }\n+\n+    bool isNullAt(size_t row)\n+    {\n+        if (default_value_is_null)\n+            return true;\n+\n+        if (is_null_map)\n+            return is_null_map->getData()[row];\n+\n+        return false;\n+    }\n+\n private:\n-    DictionaryAttributeType default_value;\n+    DictionaryAttributeType default_value {};\n     const DefaultColumnType * default_values_column = nullptr;\n+    const ColumnUInt8 * is_null_map = nullptr;\n     bool use_attribute_default_value = false;\n+    bool default_value_is_null = false;\n };\n \n template <DictionaryKeyType key_type>\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex a6de85f83f54..c280a2b94de6 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -373,6 +373,7 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n \n         const auto type_string = config.getString(prefix + \"type\");\n         const auto initial_type = DataTypeFactory::instance().get(type_string);\n+        const auto initial_type_serialization = initial_type->getDefaultSerialization();\n         bool is_nullable = initial_type->isNullable();\n \n         auto non_nullable_type = removeNullable(initial_type);\n@@ -385,20 +386,19 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n         Field null_value;\n         if (allow_null_values)\n         {\n-            /// TODO: Fix serialization for nullable type.\n             const auto null_value_string = config.getString(prefix + \"null_value\");\n \n             try\n             {\n                 if (null_value_string.empty())\n                 {\n-                    null_value = non_nullable_type->getDefault();\n+                    null_value = initial_type->getDefault();\n                 }\n                 else\n                 {\n                     ReadBufferFromString null_value_buffer{null_value_string};\n-                    auto column_with_null_value = non_nullable_type->createColumn();\n-                    non_nullable_type->getDefaultSerialization()->deserializeTextEscaped(*column_with_null_value, null_value_buffer, format_settings);\n+                    auto column_with_null_value = initial_type->createColumn();\n+                    initial_type_serialization->deserializeWholeText(*column_with_null_value, null_value_buffer, format_settings);\n                     null_value = (*column_with_null_value)[0];\n                 }\n             }\n@@ -428,6 +428,7 @@ std::vector<DictionaryAttribute> DictionaryStructure::getAttributes(\n             name,\n             underlying_type,\n             initial_type,\n+            initial_type_serialization,\n             expression,\n             null_value,\n             hierarchical,\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 9509aa97ce04..3ea640d77e8c 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -75,6 +75,7 @@ struct DictionaryAttribute final\n     const std::string name;\n     const AttributeUnderlyingType underlying_type;\n     const DataTypePtr type;\n+    const SerializationPtr type_serialization;\n     const std::string expression;\n     const Field null_value;\n     const bool hierarchical;\ndiff --git a/src/Dictionaries/ExternalQueryBuilder.cpp b/src/Dictionaries/ExternalQueryBuilder.cpp\nindex 1fc5d160bb0f..0c1dced2cdda 100644\n--- a/src/Dictionaries/ExternalQueryBuilder.cpp\n+++ b/src/Dictionaries/ExternalQueryBuilder.cpp\n@@ -358,8 +358,7 @@ void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, cons\n         /// key_i=value_i\n         writeQuoted(key_description.name, out);\n         writeString(\"=\", out);\n-        auto serialization = key_description.type->getDefaultSerialization();\n-        serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n+        key_description.type_serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n     }\n }\n \n@@ -416,7 +415,7 @@ void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const si\n             writeString(\", \", out);\n \n         first = false;\n-        auto serialization = (*dict_struct.key)[i].type->getDefaultSerialization();\n+        auto serialization = (*dict_struct.key)[i].type_serialization;\n         serialization->serializeTextQuoted(*key_columns[i], row, out, format_settings);\n     }\n \ndiff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex 0a95165de4e6..5f359846c8a6 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -63,6 +63,16 @@ ColumnPtr FlatDictionary::getColumn(\n     size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n     const auto & attribute = attributes[attribute_index];\n \n+    bool is_attribute_nullable = attribute.is_nullable_set.has_value();\n+    ColumnUInt8::MutablePtr col_null_map_to;\n+    ColumnUInt8::Container * vec_null_map_to = nullptr;\n+\n+    if (is_attribute_nullable)\n+    {\n+        col_null_map_to = ColumnUInt8::create(size, false);\n+        vec_null_map_to = &col_null_map_to->getData();\n+    }\n+\n     auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n@@ -70,9 +80,7 @@ ColumnPtr FlatDictionary::getColumn(\n         using ValueType = DictionaryValueType<AttributeType>;\n         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n \n-        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);\n-        AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n-        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n+        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(dictionary_attribute.null_value, default_values_column);\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n \n@@ -80,31 +88,53 @@ ColumnPtr FlatDictionary::getColumn(\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType>(\n+            getItemsImpl<ValueType, false>(\n                 attribute,\n                 ids,\n-                [&](const size_t, const Array & value) { out->insert(value); },\n+                [&](size_t, const Array & value, bool) { out->insert(value); },\n                 default_value_extractor);\n         }\n         else if constexpr (std::is_same_v<ValueType, StringRef>)\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType>(\n-                attribute,\n-                ids,\n-                [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },\n-                default_value_extractor);\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    ids,\n+                    [&](size_t row, const StringRef value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out->insertData(value.data, value.size);\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    ids,\n+                    [&](size_t, const StringRef value, bool) { out->insertData(value.data, value.size); },\n+                    default_value_extractor);\n         }\n         else\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<ValueType>(\n-                attribute,\n-                ids,\n-                [&](const size_t row, const auto value) { out[row] = value; },\n-                default_value_extractor);\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    ids,\n+                    [&](size_t row, const auto value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out[row] = value;\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    ids,\n+                    [&](size_t row, const auto value, bool) { out[row] = value; },\n+                    default_value_extractor);\n         }\n \n         result = std::move(column);\n@@ -112,21 +142,8 @@ ColumnPtr FlatDictionary::getColumn(\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n \n-    if (attribute.nullable_set)\n-    {\n-        ColumnUInt8::MutablePtr col_null_map_to = ColumnUInt8::create(size, false);\n-        ColumnUInt8::Container & vec_null_map_to = col_null_map_to->getData();\n-\n-        for (size_t row = 0; row < ids.size(); ++row)\n-        {\n-            auto id = ids[row];\n-\n-            if (attribute.nullable_set->find(id) != nullptr)\n-                vec_null_map_to[row] = true;\n-        }\n-\n-        result = ColumnNullable::create(result, std::move(col_null_map_to));\n-    }\n+    if (attribute.is_nullable_set)\n+        result = ColumnNullable::create(std::move(result), std::move(col_null_map_to));\n \n     return result;\n }\n@@ -161,9 +178,10 @@ ColumnPtr FlatDictionary::getHierarchy(ColumnPtr key_column, const DataTypePtr &\n     const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n \n     size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+    const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n     const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-    const UInt64 null_value = std::get<UInt64>(hierarchical_attribute.null_values);\n+    const UInt64 null_value = dictionary_attribute.null_value.get<UInt64>();\n     const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.container);\n \n     auto is_key_valid_func = [&, this](auto & key) { return key < loaded_keys.size() && loaded_keys[key]; };\n@@ -198,9 +216,10 @@ ColumnUInt8::Ptr FlatDictionary::isInHierarchy(\n     const auto & keys_in = getColumnVectorData(this, in_key_column, keys_in_backup_storage);\n \n     size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+    const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n     const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-    const UInt64 null_value = std::get<UInt64>(hierarchical_attribute.null_values);\n+    const UInt64 null_value = dictionary_attribute.null_value.get<UInt64>();\n     const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.container);\n \n     auto is_key_valid_func = [&, this](auto & key) { return key < loaded_keys.size() && loaded_keys[key]; };\n@@ -260,7 +279,7 @@ void FlatDictionary::createAttributes()\n     attributes.reserve(size);\n \n     for (const auto & attribute : dict_struct.attributes)\n-        attributes.push_back(createAttribute(attribute, attribute.null_value));\n+        attributes.push_back(createAttribute(attribute));\n }\n \n void FlatDictionary::blockToAttributes(const Block & block)\n@@ -388,10 +407,10 @@ void FlatDictionary::calculateBytesAllocated()\n         bytes_allocated += update_field_loaded_block->allocatedBytes();\n }\n \n-FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttribute & dictionary_attribute, const Field & null_value)\n+FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttribute & dictionary_attribute)\n {\n-    auto nullable_set = dictionary_attribute.is_nullable ? std::make_optional<NullableSet>() : std::optional<NullableSet>{};\n-    Attribute attribute{dictionary_attribute.underlying_type, std::move(nullable_set), {}, {}, {}};\n+    auto is_nullable_set = dictionary_attribute.is_nullable ? std::make_optional<NullableSet>() : std::optional<NullableSet>{};\n+    Attribute attribute{dictionary_attribute.underlying_type, std::move(is_nullable_set), {}, {}};\n \n     auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n@@ -400,17 +419,9 @@ FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttrib\n         using ValueType = DictionaryValueType<AttributeType>;\n \n         if constexpr (std::is_same_v<ValueType, StringRef>)\n-        {\n             attribute.string_arena = std::make_unique<Arena>();\n-            const String & string = null_value.get<String>();\n-            const char * string_in_arena = attribute.string_arena->insert(string.data(), string.size());\n-            attribute.null_values.emplace<StringRef>(string_in_arena, string.size());\n-        }\n-        else\n-            attribute.null_values = ValueType(null_value.get<NearestFieldType<ValueType>>());\n \n-        const auto & null_value_ref = std::get<ValueType>(attribute.null_values);\n-        attribute.container.emplace<ContainerType<ValueType>>(configuration.initial_array_size, null_value_ref);\n+        attribute.container.emplace<ContainerType<ValueType>>(configuration.initial_array_size, ValueType());\n     };\n \n     callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);\n@@ -418,7 +429,7 @@ FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttrib\n     return attribute;\n }\n \n-template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n void FlatDictionary::getItemsImpl(\n     const Attribute & attribute,\n     const PaddedPODArray<UInt64> & keys,\n@@ -436,11 +447,20 @@ void FlatDictionary::getItemsImpl(\n \n         if (key < loaded_keys.size() && loaded_keys[key])\n         {\n-            set_value(row, container[key]);\n+            if constexpr (is_nullable)\n+                set_value(row, container[key], attribute.is_nullable_set->find(key) != nullptr);\n+            else\n+                set_value(row, container[key], false);\n+\n             ++keys_found;\n         }\n         else\n-            set_value(row, default_value_extractor[row]);\n+        {\n+            if constexpr (is_nullable)\n+                set_value(row, default_value_extractor[row], default_value_extractor.isNullAt(row));\n+            else\n+                set_value(row, default_value_extractor[row], false);\n+        }\n     }\n \n     query_count.fetch_add(rows, std::memory_order_relaxed);\n@@ -464,9 +484,9 @@ void FlatDictionary::resize(Attribute & attribute, UInt64 key)\n         loaded_keys.resize(elements_count, false);\n \n         if constexpr (std::is_same_v<T, Array>)\n-            container.resize(elements_count, std::get<T>(attribute.null_values));\n+            container.resize(elements_count, T{});\n         else\n-            container.resize_fill(elements_count, std::get<T>(attribute.null_values));\n+            container.resize_fill(elements_count, T{});\n     }\n }\n \n@@ -495,11 +515,11 @@ void FlatDictionary::setAttributeValue(Attribute & attribute, const UInt64 key,\n \n         resize<ValueType>(attribute, key);\n \n-        if (attribute.nullable_set)\n+        if (attribute.is_nullable_set)\n         {\n             if (value.isNull())\n             {\n-                attribute.nullable_set->insert(key);\n+                attribute.is_nullable_set->insert(key);\n                 loaded_keys[key] = true;\n                 return;\n             }\ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex ec725bcdda2d..053eda72b37b 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -5,15 +5,13 @@\n #include <vector>\n #include <optional>\n \n+#include <ext/range.h>\n+#include <ext/size.h>\n+\n #include <Common/HashTable/HashSet.h>\n #include <Common/Arena.h>\n-#include <Columns/ColumnDecimal.h>\n-#include <Columns/ColumnString.h>\n-#include <Columns/ColumnArray.h>\n #include <DataTypes/IDataType.h>\n #include <Core/Block.h>\n-#include <ext/range.h>\n-#include <ext/size.h>\n \n #include \"DictionaryStructure.h\"\n #include \"IDictionary.h\"\n@@ -113,31 +111,7 @@ class FlatDictionary final : public IDictionary\n     struct Attribute final\n     {\n         AttributeUnderlyingType type;\n-        std::optional<NullableSet> nullable_set;\n-\n-        std::variant<\n-            UInt8,\n-            UInt16,\n-            UInt32,\n-            UInt64,\n-            UInt128,\n-            UInt256,\n-            Int8,\n-            Int16,\n-            Int32,\n-            Int64,\n-            Int128,\n-            Int256,\n-            Decimal32,\n-            Decimal64,\n-            Decimal128,\n-            Decimal256,\n-            Float32,\n-            Float64,\n-            UUID,\n-            StringRef,\n-            Array>\n-            null_values;\n+        std::optional<NullableSet> is_nullable_set;\n \n         std::variant<\n             ContainerType<UInt8>,\n@@ -173,9 +147,9 @@ class FlatDictionary final : public IDictionary\n \n     void calculateBytesAllocated();\n \n-    Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);\n+    Attribute createAttribute(const DictionaryAttribute & attribute);\n \n-    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n         const PaddedPODArray<UInt64> & keys,\ndiff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp\nindex fd070c4df33c..f8ca71a9dcba 100644\n--- a/src/Dictionaries/HashedDictionary.cpp\n+++ b/src/Dictionaries/HashedDictionary.cpp\n@@ -75,6 +75,8 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(\n     const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n     auto & attribute = attributes[attribute_index];\n \n+    bool is_attribute_nullable = attribute.is_nullable_set.has_value();\n+\n     ColumnUInt8::MutablePtr col_null_map_to;\n     ColumnUInt8::Container * vec_null_map_to = nullptr;\n     if (attribute.is_nullable_set)\n@@ -90,9 +92,7 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(\n         using ValueType = DictionaryValueType<AttributeType>;\n         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n \n-        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);\n-        AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n-        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n+        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(dictionary_attribute.null_value, default_values_column);\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n \n@@ -100,44 +100,53 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType>(\n+            getItemsImpl<ValueType, false>(\n                 attribute,\n                 extractor,\n-                [&](const size_t, const Array & value) { out->insert(value); },\n-                [&](const size_t)\n-                {\n-                },\n+                [&](const size_t, const Array & value, bool) { out->insert(value); },\n                 default_value_extractor);\n         }\n         else if constexpr (std::is_same_v<ValueType, StringRef>)\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType>(\n-                attribute,\n-                extractor,\n-                [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },\n-                [&](const size_t row)\n-                {\n-                    out->insertDefault();\n-                    (*vec_null_map_to)[row] = true;\n-                },\n-                default_value_extractor);\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t row, const StringRef value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out->insertData(value.data, value.size);\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t, const StringRef value, bool) { out->insertData(value.data, value.size); },\n+                    default_value_extractor);\n         }\n         else\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<ValueType>(\n-                attribute,\n-                extractor,\n-                [&](const size_t row, const auto value) { return out[row] = value; },\n-                [&](const size_t row)\n-                {\n-                    out[row] = ValueType();\n-                    (*vec_null_map_to)[row] = true;\n-                },\n-                default_value_extractor);\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t row, const auto value, bool is_null)\n+                    {\n+                        (*vec_null_map_to)[row] = is_null;\n+                        out[row] = value;\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    extractor,\n+                    [&](size_t row, const auto value, bool) { out[row] = value; },\n+                    default_value_extractor);\n         }\n \n         result = std::move(column);\n@@ -145,8 +154,8 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n \n-    if (attribute.is_nullable_set)\n-        result = ColumnNullable::create(result, std::move(col_null_map_to));\n+    if (is_attribute_nullable)\n+        result = ColumnNullable::create(std::move(result), std::move(col_null_map_to));\n \n     return result;\n }\n@@ -343,23 +352,7 @@ void HashedDictionary<dictionary_key_type, sparse>::createAttributes()\n \n             auto is_nullable_set = dictionary_attribute.is_nullable ? std::make_optional<NullableSet>() : std::optional<NullableSet>{};\n             std::unique_ptr<Arena> string_arena = std::is_same_v<AttributeType, String> ? std::make_unique<Arena>() : nullptr;\n-\n-            ValueType default_value;\n-\n-            if constexpr (std::is_same_v<ValueType, StringRef>)\n-            {\n-                string_arena = std::make_unique<Arena>();\n-\n-                const auto & string_null_value = dictionary_attribute.null_value.template get<String>();\n-                const size_t string_null_value_size = string_null_value.size();\n-\n-                const char * string_in_arena = string_arena->insert(string_null_value.data(), string_null_value_size);\n-                default_value = {string_in_arena, string_null_value_size};\n-            }\n-            else\n-                default_value = dictionary_attribute.null_value.template get<NearestFieldType<ValueType>>();\n-\n-            Attribute attribute{dictionary_attribute.underlying_type, std::move(is_nullable_set), default_value, CollectionType<ValueType>(), std::move(string_arena)};\n+            Attribute attribute{dictionary_attribute.underlying_type, std::move(is_nullable_set), CollectionType<ValueType>(), std::move(string_arena)};\n             attributes.emplace_back(std::move(attribute));\n         };\n \n@@ -509,19 +502,16 @@ void HashedDictionary<dictionary_key_type, sparse>::resize(size_t added_rows)\n }\n \n template <DictionaryKeyType dictionary_key_type, bool sparse>\n-template <typename AttributeType, typename ValueSetter, typename NullableValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n void HashedDictionary<dictionary_key_type, sparse>::getItemsImpl(\n     const Attribute & attribute,\n     DictionaryKeysExtractor<dictionary_key_type> & keys_extractor,\n     ValueSetter && set_value [[maybe_unused]],\n-    NullableValueSetter && set_nullable_value [[maybe_unused]],\n     DefaultValueExtractor & default_value_extractor) const\n {\n     const auto & attribute_container = std::get<CollectionType<AttributeType>>(attribute.container);\n     const size_t keys_size = keys_extractor.getKeysSize();\n \n-    bool is_attribute_nullable = attribute.is_nullable_set.has_value();\n-\n     size_t keys_found = 0;\n \n     for (size_t key_index = 0; key_index < keys_size; ++key_index)\n@@ -532,15 +522,18 @@ void HashedDictionary<dictionary_key_type, sparse>::getItemsImpl(\n \n         if (it != attribute_container.end())\n         {\n-            set_value(key_index, getValueFromCell(it));\n+            set_value(key_index, getValueFromCell(it), false);\n             ++keys_found;\n         }\n         else\n         {\n-            if (is_attribute_nullable && attribute.is_nullable_set->find(key) != nullptr)\n-                set_nullable_value(key_index);\n+            if constexpr (is_nullable)\n+            {\n+                bool is_value_nullable = (attribute.is_nullable_set->find(key) != nullptr) || default_value_extractor.isNullAt(key_index);\n+                set_value(key_index, default_value_extractor[key_index], is_value_nullable);\n+            }\n             else\n-                set_value(key_index, default_value_extractor[key_index]);\n+                set_value(key_index, default_value_extractor[key_index], false);\n         }\n \n         keys_extractor.rollbackCurrentKey();\ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex 9a67c9d39012..7213eb616c8b 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -12,9 +12,6 @@\n #include <Common/HashTable/HashSet.h>\n #include <Core/Block.h>\n \n-#include <Columns/ColumnDecimal.h>\n-#include <Columns/ColumnString.h>\n-\n #include <Dictionaries/DictionaryStructure.h>\n #include <Dictionaries/IDictionary.h>\n #include <Dictionaries/IDictionarySource.h>\n@@ -56,7 +53,7 @@ class HashedDictionary final : public IDictionary\n         else if constexpr (dictionary_key_type == DictionaryKeyType::simple && !sparse)\n             return \"Hashed\";\n         else if constexpr (dictionary_key_type == DictionaryKeyType::complex && sparse)\n-            return \"ComplexKeySpareseHashed\";\n+            return \"ComplexKeySparseHashed\";\n         else\n             return \"ComplexKeyHashed\";\n     }\n@@ -153,30 +150,6 @@ class HashedDictionary final : public IDictionary\n         AttributeUnderlyingType type;\n         std::optional<NullableSet> is_nullable_set;\n \n-        std::variant<\n-            UInt8,\n-            UInt16,\n-            UInt32,\n-            UInt64,\n-            UInt128,\n-            UInt256,\n-            Int8,\n-            Int16,\n-            Int32,\n-            Int64,\n-            Int128,\n-            Int256,\n-            Decimal32,\n-            Decimal64,\n-            Decimal128,\n-            Decimal256,\n-            Float32,\n-            Float64,\n-            UUID,\n-            StringRef,\n-            Array>\n-            null_values;\n-\n         std::variant<\n             CollectionType<UInt8>,\n             CollectionType<UInt16>,\n@@ -214,12 +187,11 @@ class HashedDictionary final : public IDictionary\n \n     void calculateBytesAllocated();\n \n-    template <typename AttributeType, typename ValueSetter, typename NullableValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n         DictionaryKeysExtractor<dictionary_key_type> & keys_extractor,\n         ValueSetter && set_value,\n-        NullableValueSetter && set_nullable_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n     template <typename GetContainerFunc>\ndiff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp\nindex 222664615384..946ba6866f0e 100644\n--- a/src/Dictionaries/IPAddressDictionary.cpp\n+++ b/src/Dictionaries/IPAddressDictionary.cpp\n@@ -205,7 +205,6 @@ IPAddressDictionary::IPAddressDictionary(\n     , logger(&Poco::Logger::get(\"IPAddressDictionary\"))\n {\n     createAttributes();\n-\n     loadData();\n     calculateBytesAllocated();\n }\ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex 584fba5ee8de..5d1603f4c520 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -110,9 +110,11 @@ ColumnPtr RangeHashedDictionary::getColumn(\n     auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n     modified_key_columns[1] = castColumnAccurate(column_to_cast, range_column_storage_type);\n \n+    bool is_attribute_nullable = attribute.is_nullable;\n+\n     ColumnUInt8::MutablePtr col_null_map_to;\n     ColumnUInt8::Container * vec_null_map_to = nullptr;\n-    if (attribute.is_nullable)\n+    if (is_attribute_nullable)\n     {\n         col_null_map_to = ColumnUInt8::create(keys_size, false);\n         vec_null_map_to = &col_null_map_to->getData();\n@@ -125,9 +127,7 @@ ColumnPtr RangeHashedDictionary::getColumn(\n         using ValueType = DictionaryValueType<AttributeType>;\n         using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n \n-        const auto & attribute_null_value = std::get<ValueType>(attribute.null_values);\n-        AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n-        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n+        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(dictionary_attribute.null_value, default_values_column);\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);\n \n@@ -135,10 +135,10 @@ ColumnPtr RangeHashedDictionary::getColumn(\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType>(\n+            getItemsImpl<ValueType, false>(\n                 attribute,\n                 modified_key_columns,\n-                [&](const size_t, const Array & value, bool)\n+                [&](size_t, const Array & value, bool)\n                 {\n                     out->insert(value);\n                 },\n@@ -148,33 +148,49 @@ ColumnPtr RangeHashedDictionary::getColumn(\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<ValueType>(\n-                attribute,\n-                modified_key_columns,\n-                [&](const size_t row, const StringRef value, bool is_null)\n-                {\n-                    if (attribute.is_nullable)\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    modified_key_columns,\n+                    [&](size_t row, const StringRef value, bool is_null)\n+                    {\n                         (*vec_null_map_to)[row] = is_null;\n-\n-                    out->insertData(value.data, value.size);\n-                },\n-                default_value_extractor);\n+                        out->insertData(value.data, value.size);\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    modified_key_columns,\n+                    [&](size_t, const StringRef value, bool)\n+                    {\n+                        out->insertData(value.data, value.size);\n+                    },\n+                    default_value_extractor);\n         }\n         else\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<ValueType>(\n-                attribute,\n-                modified_key_columns,\n-                [&](const size_t row, const auto value, bool is_null)\n-                {\n-                    if (attribute.is_nullable)\n+            if (is_attribute_nullable)\n+                getItemsImpl<ValueType, true>(\n+                    attribute,\n+                    modified_key_columns,\n+                    [&](size_t row, const auto value, bool is_null)\n+                    {\n                         (*vec_null_map_to)[row] = is_null;\n-\n-                    out[row] = value;\n-                },\n-                default_value_extractor);\n+                        out[row] = value;\n+                    },\n+                    default_value_extractor);\n+            else\n+                getItemsImpl<ValueType, false>(\n+                    attribute,\n+                    modified_key_columns,\n+                    [&](size_t row, const auto value, bool)\n+                    {\n+                        out[row] = value;\n+                    },\n+                    default_value_extractor);\n         }\n \n         result = std::move(column);\n@@ -182,10 +198,8 @@ ColumnPtr RangeHashedDictionary::getColumn(\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n \n-    if (attribute.is_nullable)\n-    {\n-        result = ColumnNullable::create(result, std::move(col_null_map_to));\n-    }\n+    if (is_attribute_nullable)\n+        result = ColumnNullable::create(std::move(result), std::move(col_null_map_to));\n \n     return result;\n }\n@@ -274,7 +288,7 @@ void RangeHashedDictionary::createAttributes()\n     for (const auto & attribute : dict_struct.attributes)\n     {\n         attribute_index_by_name.emplace(attribute.name, attributes.size());\n-        attributes.push_back(createAttribute(attribute, attribute.null_value));\n+        attributes.push_back(createAttribute(attribute));\n \n         if (attribute.hierarchical)\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Hierarchical attributes not supported by {} dictionary.\",\n@@ -364,41 +378,28 @@ void RangeHashedDictionary::calculateBytesAllocated()\n     }\n }\n \n-template <typename T>\n-void RangeHashedDictionary::createAttributeImpl(Attribute & attribute, const Field & null_value)\n-{\n-    attribute.null_values = T(null_value.get<T>());\n-    attribute.maps = std::make_unique<Collection<T>>();\n-}\n-\n-template <>\n-void RangeHashedDictionary::createAttributeImpl<String>(Attribute & attribute, const Field & null_value)\n-{\n-    attribute.string_arena = std::make_unique<Arena>();\n-    const String & string = null_value.get<String>();\n-    const char * string_in_arena = attribute.string_arena->insert(string.data(), string.size());\n-    attribute.null_values.emplace<StringRef>(string_in_arena, string.size());\n-    attribute.maps = std::make_unique<Collection<StringRef>>();\n-}\n-\n-RangeHashedDictionary::Attribute\n-RangeHashedDictionary::createAttribute(const DictionaryAttribute & attribute, const Field & null_value)\n+RangeHashedDictionary::Attribute RangeHashedDictionary::createAttribute(const DictionaryAttribute & dictionary_attribute)\n {\n-    Attribute attr{attribute.underlying_type, attribute.is_nullable, {}, {}, {}};\n+    Attribute attribute{dictionary_attribute.underlying_type, dictionary_attribute.is_nullable, {}, {}};\n \n     auto type_call = [&](const auto &dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n-        createAttributeImpl<AttributeType>(attr, null_value);\n+        using ValueType = DictionaryValueType<AttributeType>;\n+\n+        if constexpr (std::is_same_v<AttributeType, String>)\n+            attribute.string_arena = std::make_unique<Arena>();\n+\n+        attribute.maps = std::make_unique<Collection<ValueType>>();\n     };\n \n-    callOnDictionaryAttributeType(attribute.underlying_type, type_call);\n+    callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);\n \n-    return attr;\n+    return attribute;\n }\n \n-template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n+template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n void RangeHashedDictionary::getItemsImpl(\n     const Attribute & attribute,\n     const Columns & key_columns,\n@@ -435,20 +436,26 @@ void RangeHashedDictionary::getItemsImpl(\n                 ++keys_found;\n                 auto & value = val_it->value;\n \n-                if (value.has_value())\n-                    set_value(row, *value, false);\n+                if constexpr (is_nullable)\n+                {\n+                    if (value.has_value())\n+                        set_value(row, *value, false);\n+                    else\n+                        set_value(row, default_value_extractor[row], true);\n+                }\n                 else\n-                    set_value(row, default_value_extractor[row], true);\n-            }\n-            else\n-            {\n-                set_value(row, default_value_extractor[row], false);\n+                {\n+                    set_value(row, *value, false);\n+                }\n+\n+                continue;\n             }\n         }\n+\n+        if constexpr (is_nullable)\n+            set_value(row, default_value_extractor[row], default_value_extractor.isNullAt(row));\n         else\n-        {\n             set_value(row, default_value_extractor[row], false);\n-        }\n     }\n \n     query_count.fetch_add(ids.size(), std::memory_order_relaxed);\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex 50888873c3cf..0dd9c41fd71a 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -107,29 +107,6 @@ class RangeHashedDictionary final : public IDictionary\n         AttributeUnderlyingType type;\n         bool is_nullable;\n \n-        std::variant<\n-            UInt8,\n-            UInt16,\n-            UInt32,\n-            UInt64,\n-            UInt128,\n-            UInt256,\n-            Int8,\n-            Int16,\n-            Int32,\n-            Int64,\n-            Int128,\n-            Int256,\n-            Decimal32,\n-            Decimal64,\n-            Decimal128,\n-            Decimal256,\n-            Float32,\n-            Float64,\n-            UUID,\n-            StringRef,\n-            Array>\n-            null_values;\n         std::variant<\n             Ptr<UInt8>,\n             Ptr<UInt16>,\n@@ -165,12 +142,9 @@ class RangeHashedDictionary final : public IDictionary\n \n     void calculateBytesAllocated();\n \n-    template <typename T>\n-    static void createAttributeImpl(Attribute & attribute, const Field & null_value);\n-\n-    static Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);\n+    static Attribute createAttribute(const DictionaryAttribute & dictionary_attribute);\n \n-    template <typename AttributeType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, bool is_nullable, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n         const Columns & key_columns,\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 89c76f930614..1c07de7808c4 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -283,6 +283,7 @@ class FunctionDictGetNoType final : public IFunction\n     size_t getNumberOfArguments() const override { return 0; }\n \n     bool useDefaultImplementationForConstants() const final { return true; }\n+    bool useDefaultImplementationForNulls() const final { return false; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0, 1}; }\n \n     bool isDeterministic() const override { return false; }\n@@ -392,27 +393,9 @@ class FunctionDictGetNoType final : public IFunction\n                     arguments.size() + 1);\n \n             const auto & column_before_cast = arguments[current_arguments_index];\n-\n-            if (const DataTypeTuple * type_tuple = typeid_cast<const DataTypeTuple *>(column_before_cast.type.get()))\n-            {\n-                const DataTypes & nested_types = type_tuple->getElements();\n-\n-                for (const auto & nested_type : nested_types)\n-                    if (nested_type->isNullable())\n-                        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"Wrong argument for function {} default values column nullable is not supported\",\n-                            getName());\n-            }\n-            else if (column_before_cast.type->isNullable())\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Wrong argument for function {} default values column nullable is not supported\",\n-                    getName());\n-\n-            auto result_type_no_nullable = removeNullable(result_type);\n-\n             ColumnWithTypeAndName column_to_cast = {column_before_cast.column->convertToFullColumnIfConst(), column_before_cast.type, column_before_cast.name};\n \n-            auto result = castColumnAccurate(column_to_cast, result_type_no_nullable);\n+            auto result = castColumnAccurate(column_to_cast, result_type);\n \n             if (attribute_names.size() > 1)\n             {\n@@ -453,26 +436,13 @@ class FunctionDictGetNoType final : public IFunction\n                      getName(),\n                      key_col_with_type.type->getName());\n \n-            if (attribute_names.size() > 1)\n-            {\n-                const auto & result_tuple_type = assert_cast<const DataTypeTuple &>(*result_type);\n-\n-                Columns result_columns = dictionary->getColumns(\n-                    attribute_names,\n-                    result_tuple_type.getElements(),\n-                    {key_column},\n-                    {std::make_shared<DataTypeUInt64>()},\n-                    default_cols);\n-\n-                result = ColumnTuple::create(std::move(result_columns));\n-            }\n-            else\n-                result = dictionary->getColumn(\n-                    attribute_names[0],\n-                    result_type,\n-                    {key_column},\n-                    {std::make_shared<DataTypeUInt64>()},\n-                    default_cols.front());\n+            result = executeDictionaryRequest(\n+                dictionary,\n+                attribute_names,\n+                {key_column},\n+                {std::make_shared<DataTypeUInt64>()},\n+                result_type,\n+                default_cols);\n         }\n         else if (dictionary_key_type == DictionaryKeyType::complex)\n         {\n@@ -486,36 +456,16 @@ class FunctionDictGetNoType final : public IFunction\n             /// Functions in external dictionaries_loader only support full-value (not constant) columns with keys.\n             ColumnPtr key_column_full = key_col_with_type.column->convertToFullColumnIfConst();\n \n-            if (!isTuple(key_col_with_type.type))\n-                throw Exception(\n-                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Third argument of function {} must be tuple when dictionary is complex. Actual type {}.\",\n-                    getName(),\n-                    key_col_with_type.type->getName());\n-\n             const auto & key_columns = typeid_cast<const ColumnTuple &>(*key_column_full).getColumnsCopy();\n             const auto & key_types = static_cast<const DataTypeTuple &>(*key_col_with_type.type).getElements();\n \n-            if (attribute_names.size() > 1)\n-            {\n-                const auto & result_tuple_type = assert_cast<const DataTypeTuple &>(*result_type);\n-\n-                Columns result_columns = dictionary->getColumns(\n-                    attribute_names,\n-                    result_tuple_type.getElements(),\n-                    key_columns,\n-                    key_types,\n-                    default_cols);\n-\n-                result = ColumnTuple::create(std::move(result_columns));\n-            }\n-            else\n-                result = dictionary->getColumn(\n-                    attribute_names[0],\n-                    result_type,\n-                    key_columns,\n-                    key_types,\n-                    default_cols.front());\n+            result = executeDictionaryRequest(\n+                dictionary,\n+                attribute_names,\n+                key_columns,\n+                key_types,\n+                result_type,\n+                default_cols);\n         }\n         else if (dictionary_key_type == DictionaryKeyType::range)\n         {\n@@ -526,26 +476,13 @@ class FunctionDictGetNoType final : public IFunction\n                      getName(),\n                      key_col_with_type.type->getName());\n \n-            if (attribute_names.size() > 1)\n-            {\n-                const auto & result_tuple_type = assert_cast<const DataTypeTuple &>(*result_type);\n-\n-                Columns result_columns = dictionary->getColumns(\n-                    attribute_names,\n-                    result_tuple_type.getElements(),\n-                    {key_column, range_col},\n-                    {std::make_shared<DataTypeUInt64>(), range_col_type},\n-                    default_cols);\n-\n-                result = ColumnTuple::create(std::move(result_columns));\n-            }\n-            else\n-                result = dictionary->getColumn(\n-                    attribute_names[0],\n-                    result_type,\n-                    {key_column, range_col},\n-                    {std::make_shared<DataTypeUInt64>(), range_col_type},\n-                    default_cols.front());\n+            result = executeDictionaryRequest(\n+                dictionary,\n+                attribute_names,\n+                {key_column, range_col},\n+                {std::make_shared<DataTypeUInt64>(), range_col_type},\n+                result_type,\n+                default_cols);\n         }\n         else\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Unknown dictionary identifier type\");\n@@ -555,6 +492,40 @@ class FunctionDictGetNoType final : public IFunction\n \n private:\n \n+    ColumnPtr executeDictionaryRequest(\n+        std::shared_ptr<const IDictionary> & dictionary,\n+        const Strings & attribute_names,\n+        const Columns & key_columns,\n+        const DataTypes & key_types,\n+        const DataTypePtr & result_type,\n+        const Columns & default_cols) const\n+    {\n+        ColumnPtr result;\n+\n+        if (attribute_names.size() > 1)\n+        {\n+            const auto & result_tuple_type = assert_cast<const DataTypeTuple &>(*result_type);\n+\n+            Columns result_columns = dictionary->getColumns(\n+                attribute_names,\n+                result_tuple_type.getElements(),\n+                key_columns,\n+                key_types,\n+                default_cols);\n+\n+            result = ColumnTuple::create(std::move(result_columns));\n+        }\n+        else\n+            result = dictionary->getColumn(\n+                attribute_names[0],\n+                result_type,\n+                key_columns,\n+                key_types,\n+                default_cols.front());\n+\n+        return result;\n+    }\n+\n     Strings getAttributeNamesFromColumn(const ColumnPtr & column, const DataTypePtr & type) const\n     {\n         Strings attribute_names;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01902_dictionary_array_type.sql b/tests/queries/0_stateless/01902_dictionary_array_type.sql\nindex fcd41c77819d..700f26e915db 100644\n--- a/tests/queries/0_stateless/01902_dictionary_array_type.sql\n+++ b/tests/queries/0_stateless/01902_dictionary_array_type.sql\n@@ -132,6 +132,7 @@ SELECT dictGetOrDefault('polygon_dictionary', 'array_value', tuple(1.5, 1.5), [2\n DROP DICTIONARY polygon_dictionary;\n DROP TABLE polygon_dictionary_array_source_table;\n \n+DROP TABLE IF EXISTS range_dictionary_array_source_table;\n CREATE TABLE range_dictionary_array_source_table\n (\n   key UInt64,\ndiff --git a/tests/queries/0_stateless/01904_dictionary_default_nullable_type.reference b/tests/queries/0_stateless/01904_dictionary_default_nullable_type.reference\nnew file mode 100644\nindex 000000000000..eaee870d0a90\n--- /dev/null\n+++ b/tests/queries/0_stateless/01904_dictionary_default_nullable_type.reference\n@@ -0,0 +1,49 @@\n+Flat dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\n+Hashed dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\n+Cache dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\n+Direct dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\n+IPTrie dictionary\n+Polygon dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\n+Range dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\ndiff --git a/tests/queries/0_stateless/01904_dictionary_default_nullable_type.sql b/tests/queries/0_stateless/01904_dictionary_default_nullable_type.sql\nnew file mode 100644\nindex 000000000000..0d4f7119fa3b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01904_dictionary_default_nullable_type.sql\n@@ -0,0 +1,200 @@\n+DROP TABLE IF EXISTS dictionary_nullable_source_table;\n+CREATE TABLE dictionary_nullable_source_table\n+(\n+    id UInt64,\n+    value Nullable(Int64)\n+) ENGINE=TinyLog;\n+\n+DROP TABLE IF EXISTS dictionary_nullable_default_source_table;\n+CREATE TABLE dictionary_nullable_default_source_table\n+(\n+    id UInt64,\n+    value Nullable(UInt64)\n+) ENGINE=TinyLog;\n+\n+INSERT INTO dictionary_nullable_source_table VALUES (0, 0), (1, NULL);\n+INSERT INTO dictionary_nullable_default_source_table VALUES (2, 2), (3, NULL);\n+\n+DROP DICTIONARY IF EXISTS flat_dictionary;\n+CREATE DICTIONARY flat_dictionary\n+(\n+    id UInt64,\n+    value Nullable(Int64) DEFAULT NULL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_nullable_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(FLAT());\n+\n+SELECT 'Flat dictionary';\n+SELECT dictGet('flat_dictionary', 'value', toUInt64(0));\n+SELECT dictGet('flat_dictionary', 'value', toUInt64(1));\n+SELECT dictGet('flat_dictionary', 'value', toUInt64(2));\n+SELECT dictGetOrDefault('flat_dictionary', 'value', toUInt64(2), 2);\n+SELECT dictGetOrDefault('flat_dictionary', 'value', toUInt64(2), NULL);\n+SELECT dictGetOrDefault('flat_dictionary', 'value', id, value) FROM dictionary_nullable_default_source_table;\n+DROP DICTIONARY flat_dictionary;\n+\n+DROP DICTIONARY IF EXISTS hashed_dictionary;\n+CREATE DICTIONARY hashed_dictionary\n+(\n+    id UInt64,\n+    value Nullable(Int64) DEFAULT NULL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_nullable_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Hashed dictionary';\n+SELECT dictGet('hashed_dictionary', 'value', toUInt64(0));\n+SELECT dictGet('hashed_dictionary', 'value', toUInt64(1));\n+SELECT dictGet('hashed_dictionary', 'value', toUInt64(2));\n+SELECT dictGetOrDefault('hashed_dictionary', 'value', toUInt64(2), 2);\n+SELECT dictGetOrDefault('hashed_dictionary', 'value', toUInt64(2), NULL);\n+SELECT dictGetOrDefault('hashed_dictionary', 'value', id, value) FROM dictionary_nullable_default_source_table;\n+DROP DICTIONARY hashed_dictionary;\n+\n+DROP DICTIONARY IF EXISTS cache_dictionary;\n+CREATE DICTIONARY cache_dictionary\n+(\n+    id UInt64,\n+    value Nullable(Int64) DEFAULT NULL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_nullable_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(CACHE(SIZE_IN_CELLS 10));\n+\n+SELECT 'Cache dictionary';\n+SELECT dictGet('cache_dictionary', 'value', toUInt64(0));\n+SELECT dictGet('cache_dictionary', 'value', toUInt64(1));\n+SELECT dictGet('cache_dictionary', 'value', toUInt64(2));\n+SELECT dictGetOrDefault('cache_dictionary', 'value', toUInt64(2), 2);\n+SELECT dictGetOrDefault('cache_dictionary', 'value', toUInt64(2), NULL);\n+SELECT dictGetOrDefault('cache_dictionary', 'value', id, value) FROM dictionary_nullable_default_source_table;\n+DROP DICTIONARY cache_dictionary;\n+\n+DROP DICTIONARY IF EXISTS direct_dictionary;\n+CREATE DICTIONARY direct_dictionary\n+(\n+    id UInt64,\n+    value Nullable(Int64) DEFAULT NULL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_nullable_source_table'))\n+LAYOUT(DIRECT());\n+\n+SELECT 'Direct dictionary';\n+SELECT dictGet('direct_dictionary', 'value', toUInt64(0));\n+SELECT dictGet('direct_dictionary', 'value', toUInt64(1));\n+SELECT dictGet('direct_dictionary', 'value', toUInt64(2));\n+SELECT dictGetOrDefault('direct_dictionary', 'value', toUInt64(2), 2);\n+SELECT dictGetOrDefault('direct_dictionary', 'value', toUInt64(2), NULL);\n+SELECT dictGetOrDefault('direct_dictionary', 'value', id, value) FROM dictionary_nullable_default_source_table;\n+DROP DICTIONARY direct_dictionary;\n+\n+DROP DICTIONARY IF EXISTS ip_trie_dictionary;\n+CREATE DICTIONARY ip_trie_dictionary\n+(\n+    prefix String,\n+    value Nullable(Int64) DEFAULT NULL\n+)\n+PRIMARY KEY prefix\n+SOURCE(CLICKHOUSE(HOST 'localhost' port tcpPort() TABLE 'dictionary_nullable_source_table'))\n+LIFETIME(MIN 10 MAX 1000)\n+LAYOUT(IP_TRIE());\n+\n+-- Nullable type is not supported by IPTrie dictionary\n+SELECT 'IPTrie dictionary';\n+SELECT dictGet('ip_trie_dictionary', 'value', tuple(IPv4StringToNum('127.0.0.0'))); --{serverError 1}\n+\n+DROP TABLE dictionary_nullable_source_table;\n+DROP TABLE dictionary_nullable_default_source_table;\n+\n+DROP TABLE IF EXISTS polygon_dictionary_nullable_source_table;\n+CREATE TABLE polygon_dictionary_nullable_source_table\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    value Nullable(Int64)\n+) ENGINE = TinyLog;\n+\n+DROP TABLE IF EXISTS polygon_dictionary_nullable_default_source_table;\n+CREATE TABLE polygon_dictionary_nullable_default_source_table\n+(\n+    key Tuple(Float64, Float64),\n+    value Nullable(UInt64)\n+) ENGINE=TinyLog;\n+\n+INSERT INTO polygon_dictionary_nullable_source_table VALUES ([[[(0, 0), (0, 1), (1, 1), (1, 0)]]], 0), ([[[(0, 0), (0, 1.5), (1.5, 1.5), (1.5, 0)]]], NULL);\n+INSERT INTO polygon_dictionary_nullable_default_source_table VALUES ((2.0, 2.0), 2), ((4, 4), NULL);\n+\n+\n+DROP DICTIONARY IF EXISTS polygon_dictionary;\n+CREATE DICTIONARY polygon_dictionary\n+(\n+    key Array(Array(Array(Tuple(Float64, Float64)))),\n+    value Nullable(UInt64) DEFAULT NULL\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'polygon_dictionary_nullable_source_table'))\n+LIFETIME(MIN 0 MAX 1000)\n+LAYOUT(POLYGON());\n+\n+SELECT 'Polygon dictionary';\n+SELECT dictGet('polygon_dictionary', 'value', tuple(0.5, 0.5));\n+SELECT dictGet('polygon_dictionary', 'value', tuple(1.5, 1.5));\n+SELECT dictGet('polygon_dictionary', 'value', tuple(2.0, 2.0));\n+SELECT dictGetOrDefault('polygon_dictionary', 'value', tuple(2.0, 2.0), 2);\n+SELECT dictGetOrDefault('polygon_dictionary', 'value', tuple(2.0, 2.0), NULL);\n+SELECT dictGetOrDefault('polygon_dictionary', 'value', key, value) FROM polygon_dictionary_nullable_default_source_table;\n+\n+DROP DICTIONARY polygon_dictionary;\n+DROP TABLE polygon_dictionary_nullable_source_table;\n+DROP TABLE polygon_dictionary_nullable_default_source_table;\n+\n+DROP TABLE IF EXISTS range_dictionary_nullable_source_table;\n+CREATE TABLE range_dictionary_nullable_source_table\n+(\n+  key UInt64,\n+  start_date Date,\n+  end_date Date,\n+  value Nullable(UInt64)\n+)\n+ENGINE = TinyLog;\n+\n+DROP TABLE IF EXISTS range_dictionary_nullable_default_source_table;\n+CREATE TABLE range_dictionary_nullable_default_source_table\n+(\n+    key UInt64,\n+    value Nullable(UInt64)\n+) ENGINE=TinyLog;\n+\n+INSERT INTO range_dictionary_nullable_source_table VALUES (0, toDate('2019-05-05'), toDate('2019-05-20'), 0), (1, toDate('2019-05-05'), toDate('2019-05-20'), NULL);\n+INSERT INTO range_dictionary_nullable_default_source_table VALUES (2, 2), (3, NULL);\n+\n+DROP DICTIONARY IF EXISTS range_dictionary;\n+CREATE DICTIONARY range_dictionary\n+(\n+  key UInt64,\n+  start_date Date,\n+  end_date Date,\n+  value Nullable(UInt64) DEFAULT NULL\n+)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'range_dictionary_nullable_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(RANGE_HASHED())\n+RANGE(MIN start_date MAX end_date);\n+\n+SELECT 'Range dictionary';\n+SELECT dictGet('range_dictionary', 'value',  toUInt64(0), toDate('2019-05-15'));\n+SELECT dictGet('range_dictionary', 'value', toUInt64(1), toDate('2019-05-15'));\n+SELECT dictGet('range_dictionary', 'value', toUInt64(2), toDate('2019-05-15'));\n+SELECT dictGetOrDefault('range_dictionary', 'value', toUInt64(2), toDate('2019-05-15'), 2);\n+SELECT dictGetOrDefault('range_dictionary', 'value', toUInt64(2), toDate('2019-05-15'), NULL);\n+SELECT dictGetOrDefault('range_dictionary', 'value', key, toDate('2019-05-15'), value) FROM range_dictionary_nullable_default_source_table;\n+\n+DROP DICTIONARY range_dictionary;\n+DROP TABLE range_dictionary_nullable_source_table;\n+DROP TABLE range_dictionary_nullable_default_source_table;\ndiff --git a/tests/queries/0_stateless/01904_ssd_cache_dictionary_default_nullable_type.reference b/tests/queries/0_stateless/01904_ssd_cache_dictionary_default_nullable_type.reference\nnew file mode 100644\nindex 000000000000..5e14e321f706\n--- /dev/null\n+++ b/tests/queries/0_stateless/01904_ssd_cache_dictionary_default_nullable_type.reference\n@@ -0,0 +1,8 @@\n+SSDCache dictionary\n+0\n+\\N\n+\\N\n+2\n+\\N\n+2\n+\\N\ndiff --git a/tests/queries/0_stateless/01904_ssd_cache_dictionary_default_nullable_type.sh b/tests/queries/0_stateless/01904_ssd_cache_dictionary_default_nullable_type.sh\nnew file mode 100755\nindex 000000000000..d3a4389e6d54\n--- /dev/null\n+++ b/tests/queries/0_stateless/01904_ssd_cache_dictionary_default_nullable_type.sh\n@@ -0,0 +1,48 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+USER_FILES_PATH=$(clickhouse-client --query \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+\n+$CLICKHOUSE_CLIENT -n --query=\"\n+    DROP TABLE IF EXISTS dictionary_nullable_source_table;\n+    CREATE TABLE dictionary_nullable_source_table\n+    (\n+        id UInt64,\n+        value Nullable(Int64)\n+    ) ENGINE=TinyLog;\n+\n+    DROP TABLE IF EXISTS dictionary_nullable_default_source_table;\n+    CREATE TABLE dictionary_nullable_default_source_table\n+    (\n+        id UInt64,\n+        value Nullable(UInt64)\n+    ) ENGINE=TinyLog;\n+\n+    INSERT INTO dictionary_nullable_source_table VALUES (0, 0), (1, NULL);\n+    INSERT INTO dictionary_nullable_default_source_table VALUES (2, 2), (3, NULL);\n+\n+    DROP DICTIONARY IF EXISTS ssd_cache_dictionary;\n+    CREATE DICTIONARY ssd_cache_dictionary\n+    (\n+        id UInt64,\n+        value Nullable(UInt64) DEFAULT NULL\n+    )\n+    PRIMARY KEY id\n+    SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() TABLE 'dictionary_nullable_source_table'))\n+    LIFETIME(MIN 1 MAX 1000)\n+    LAYOUT(SSD_CACHE(BLOCK_SIZE 4096 FILE_SIZE 8192 PATH '$USER_FILES_PATH/0d'));\n+\n+    SELECT 'SSDCache dictionary';\n+    SELECT dictGet('ssd_cache_dictionary', 'value', toUInt64(0));\n+    SELECT dictGet('ssd_cache_dictionary', 'value', toUInt64(1));\n+    SELECT dictGet('ssd_cache_dictionary', 'value', toUInt64(2));\n+    SELECT dictGetOrDefault('ssd_cache_dictionary', 'value', toUInt64(2), 2);\n+    SELECT dictGetOrDefault('ssd_cache_dictionary', 'value', toUInt64(2), NULL);\n+    SELECT dictGetOrDefault('ssd_cache_dictionary', 'value', id, value) FROM dictionary_nullable_default_source_table;\n+\n+    DROP DICTIONARY ssd_cache_dictionary;\n+    DROP TABLE dictionary_nullable_source_table;\n+    DROP TABLE dictionary_nullable_default_source_table;\"\n",
  "problem_statement": "Support nullable values in external dictionary\nrelated to #2351\r\n\r\nBecause we have a use case where some values of a dictionary can be Nullable. It's could be nice to have this feature.\r\n\r\n\r\n\n",
  "hints_text": "We too have a use case where we need null values in a dictionary and is stopping us from migrating our data to CH. Any update on when we could use this?\n\r\nOur existing case requires that the external dictionary field can be NULL.\nThis is really neccessary\nthis was working fine in 19.16.x and doesn't work anymore in 20.3.x blocking updating.\n@Slind14 I don't understand what was working fine? There support for NULL values in external dictionaries never existed.\nThe implementation is being developed by @kitaisreal in #18236.\n> @Slind14 I don't understand what was working fine? There support for NULL values in external dictionaries never existed.\r\n\r\nA dict with a table as source that contains nullable works in 19.x\n@kitaisreal fixed?\n@filimonov currently supported for Flat, Hashed, ComplexKeyHashed, Direct, ComplexKeyDirect, RangeHashed.\r\nCache, ComplexKeyCache, SSDCache, SSDComplexKeyCache, Polygon, IPTrie are not yet supported.",
  "created_at": "2021-06-11T11:07:42Z"
}