{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 76231,
  "instance_id": "ClickHouse__ClickHouse-76231",
  "issue_numbers": [
    "61673"
  ],
  "base_commit": "746bb5b8e27c50ffc3579182249c8f79100afa32",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 8730e9afbb61..e7d01320a215 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1753,18 +1753,38 @@ Query:\n ``` sql\n SELECT arrayEnumerateDenseRanked(2,[[10,10,30,20],[40,50,10,30]],2);\n ```\n-\n Result:\n \n ``` text\n [[1,1,2,3],[1,2,3,4]]\n ```\n \n-## arrayUnion(arr)\n+## arrayUnion\n \n-Takes multiple arrays, returns an array that contains all elements that are present in any of the source arrays.\n+Takes multiple arrays and returns an array which contains all elements that are present in one of the source arrays.\n+The result contains only unique values.\n+\n+**Syntax**\n+\n+``` sql\n+arrayUnion(arr1, arr2, ..., arrN)\n+```\n+\n+**Arguments**\n+\n+- `arrN` \u2014 [Array](../data-types/array.md).\n+\n+The function can take any number of arrays of different types.\n+\n+**Returned value**\n+\n+- [Array](../data-types/array.md) with distinct elements from the source arrays.\n+\n+\n+**Example**\n+\n+Query:\n \n-Example:\n ```sql\n SELECT\n     arrayUnion([-2, 1], [10, 1], [-2], []) as num_example,\n@@ -1772,28 +1792,95 @@ SELECT\n     arrayUnion([1, 3, NULL], [2, 3, NULL]) as null_example\n ```\n \n+Result:\n+\n ```text\n \u250c\u2500num_example\u2500\u252c\u2500str_example\u2500\u2500\u2500\u2500\u252c\u2500null_example\u2500\u2510\n \u2502 [10,-2,1]   \u2502 ['hello','hi'] \u2502 [3,2,1,NULL] \u2502\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## arrayIntersect(arr)\n+## arrayIntersect\n \n-Takes multiple arrays, returns an array with elements that are present in all source arrays.\n+Takes multiple arrays and returns an array with elements which are present in all source arrays.\n+The result contains only unique values.\n \n-Example:\n+**Syntax**\n+\n+``` sql\n+arrayIntersect(arr1, arr2, ..., arrN)\n+```\n+\n+**Arguments**\n+\n+- `arrN` \u2014 [Array](../data-types/array.md).\n+\n+The function can take any number of arrays of different types.\n+\n+**Returned value**\n+\n+- [Array](../data-types/array.md) with distinct elements present in all source arrays.\n+\n+**Example**\n+\n+Query:\n \n ``` sql\n SELECT\n-    arrayIntersect([1, 2], [1, 3], [2, 3]) AS no_intersect,\n-    arrayIntersect([1, 2], [1, 3], [1, 4]) AS intersect\n+    arrayIntersect([1, 2], [1, 3], [2, 3]) AS empty_intersection,\n+    arrayIntersect([1, 2], [1, 3], [1, 4]) AS non_empty_intersection\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500non_empty_intersection\u2500\u252c\u2500empty_intersection\u2500\u2510\n+\u2502 []                     \u2502 [1]                \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## arraySymmetricDifference\n+\n+Takes multiple arrays and returns an array with elements that are not present in all source arrays.\n+The result contains only unique values.\n+\n+:::note\n+The symmetric difference of _more than two sets_ is [mathematically defined](https://en.wikipedia.org/wiki/Symmetric_difference#n-ary_symmetric_difference) as the set of all input elements which occur in an odd number of input sets.\n+In contrast, function `arraySymmetricDifference` simply returns the set of input elements which do not occur in all input sets.\n+:::\n+\n+**Syntax**\n+\n+``` sql\n+arraySymmetricDifference(arr1, arr2, ..., arrN)\n+```\n+\n+**Arguments**\n+\n+- `arrN` \u2014 [Array](../data-types/array.md).\n+\n+The function can take any number of arrays of different types.\n+\n+**Returned value**\n+\n+- [Array](../data-types/array.md) with distinct elements not present in all source arrays.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT\n+    arraySymmetricDifference([1, 2], [1, 2], [1, 2]) AS empty_symmetric_difference\n+    arraySymmetricDifference([1, 2], [1, 2], [1, 3]) AS non_empty_symmetric_difference,\n+```\n+\n+Result:\n+\n ``` text\n-\u250c\u2500no_intersect\u2500\u252c\u2500intersect\u2500\u2510\n-\u2502 []           \u2502 [1]       \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500empty_symmetric_difference\u2500\u252c\u2500non_empty_symmetric_difference\u2500\u2510\n+\u2502 []                         \u2502 [3]                            \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n ## arrayJaccardIndex\ndiff --git a/src/Functions/array/arrayIntersect.cpp b/src/Functions/array/arrayIntersect.cpp\nindex 98a230606961..bf4e5412fd44 100644\n--- a/src/Functions/array/arrayIntersect.cpp\n+++ b/src/Functions/array/arrayIntersect.cpp\n@@ -47,6 +47,11 @@ struct ArrayModeUnion\n     static constexpr auto name = \"arrayUnion\";\n };\n \n+struct ArrayModeSymmetricDifference\n+{\n+    static constexpr auto name = \"arraySymmetricDifference\";\n+};\n+\n template <typename Mode>\n class FunctionArrayIntersect : public IFunction\n {\n@@ -577,8 +582,8 @@ ColumnPtr FunctionArrayIntersect<Mode>::execute(const UnpackedArrays & arrays, M\n         map.clear();\n \n         bool all_has_nullable = all_nullable;\n-        bool has_a_null = false;\n         bool current_has_nullable = false;\n+        size_t null_count = 0;\n \n         for (size_t arg_num = 0; arg_num < args; ++arg_num)\n         {\n@@ -629,7 +634,8 @@ ColumnPtr FunctionArrayIntersect<Mode>::execute(const UnpackedArrays & arrays, M\n             if (!current_has_nullable)\n                 all_has_nullable = false;\n             else\n-                has_a_null = true;\n+                null_count++;\n+\n         }\n \n         // We have NULL in output only once if it should be there\n@@ -643,11 +649,26 @@ ColumnPtr FunctionArrayIntersect<Mode>::execute(const UnpackedArrays & arrays, M\n             {\n                 typename Map::LookupResult pair = map.find(p.getKey());\n                 if (pair && pair->getMapped() >= 1)\n-                {\n                     insertElement<Map, ColumnType, is_numeric_column>(pair, result_offset, result_data, null_map, use_null_map);\n-                }\n             }\n-            if (has_a_null && !null_added)\n+            if (null_count > 0 && !null_added)\n+            {\n+                ++result_offset;\n+                result_data.insertDefault();\n+                null_map.push_back(1);\n+                null_added = true;\n+            }\n+        }\n+        else if constexpr (std::is_same_v<Mode, ArrayModeSymmetricDifference>)\n+        {\n+            use_null_map = has_nullable;\n+            for (auto & p : map)\n+            {\n+                typename Map::LookupResult pair = map.find(p.getKey());\n+                if (pair && pair->getMapped() >= 1 && pair->getMapped() < args)\n+                    insertElement<Map, ColumnType, is_numeric_column>(pair, result_offset, result_data, null_map, use_null_map);\n+            }\n+            if (null_count > 0 && null_count < args && !null_added)\n             {\n                 ++result_offset;\n                 result_data.insertDefault();\n@@ -685,9 +706,7 @@ ColumnPtr FunctionArrayIntersect<Mode>::execute(const UnpackedArrays & arrays, M\n                         continue;\n                 }\n                 else if constexpr (is_numeric_column)\n-                {\n                     pair = map.find(columns[0]->getElement(i));\n-                }\n                 else if constexpr (std::is_same_v<ColumnType, ColumnString> || std::is_same_v<ColumnType, ColumnFixedString>)\n                     pair = map.find(columns[0]->getDataAt(i));\n                 else\n@@ -705,9 +724,7 @@ ColumnPtr FunctionArrayIntersect<Mode>::execute(const UnpackedArrays & arrays, M\n                 // Add the value if all arrays have the value for intersect\n                 // or if there was at least one occurrence in all of the arrays for union\n                 if (pair && pair->getMapped() == args)\n-                {\n                     insertElement<Map, ColumnType, is_numeric_column>(pair, result_offset, result_data, null_map, use_null_map);\n-                }\n             }\n         }\n \n@@ -745,11 +762,13 @@ void FunctionArrayIntersect<Mode>::insertElement(typename Map::LookupResult & pa\n \n using ArrayIntersect = FunctionArrayIntersect<ArrayModeIntersect>;\n using ArrayUnion = FunctionArrayIntersect<ArrayModeUnion>;\n+using ArraySymmetricDifference = FunctionArrayIntersect<ArrayModeSymmetricDifference>;\n \n REGISTER_FUNCTION(ArrayIntersect)\n {\n     factory.registerFunction<ArrayIntersect>();\n     factory.registerFunction<ArrayUnion>();\n+    factory.registerFunction<ArraySymmetricDifference>();\n }\n \n }\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 4dacdc604bd2..a5a9ea794906 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1324,6 +1324,7 @@ arraySort\n arraySplit\n arrayStringConcat\n arraySum\n+arraySymmetricDifference\n arrayUnion\n arrayUniq\n arrayWithConstant\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 5b131307bcfc..e69032d49ebb 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -141,6 +141,7 @@ arraySort\n arraySplit\n arrayStringConcat\n arraySum\n+arraySymmetricDifference\n arrayUnion\n arrayUniq\n arrayWithConstant\ndiff --git a/tests/queries/0_stateless/03357_arraySymmetricDifference.reference b/tests/queries/0_stateless/03357_arraySymmetricDifference.reference\nnew file mode 100644\nindex 000000000000..c4885144c573\n--- /dev/null\n+++ b/tests/queries/0_stateless/03357_arraySymmetricDifference.reference\n@@ -0,0 +1,16 @@\n+Negative tests\n+Const arguments\n+[]\n+[]\n+[2,3]\n+['b','c']\n+[3,NULL]\n+[1,3]\n+[]\n+[]\n+[]\n+[2,3]\n+Array(Tuple(Nullable(UInt8), Array(Nullable(String))))\n+Non-const arguments\n+[(NULL,['c']),(2,['c',NULL])]\n+[(NULL,['c']),(2,['c',NULL])]\ndiff --git a/tests/queries/0_stateless/03357_arraySymmetricDifference.sql b/tests/queries/0_stateless/03357_arraySymmetricDifference.sql\nnew file mode 100644\nindex 000000000000..ef4c13bcfa30\n--- /dev/null\n+++ b/tests/queries/0_stateless/03357_arraySymmetricDifference.sql\n@@ -0,0 +1,30 @@\n+SELECT 'Negative tests';\n+SELECT arraySymmetricDifference(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arraySymmetricDifference(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arraySymmetricDifference(1, 2); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arraySymmetricDifference(1, [1, 2]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arraySymmetricDifference([1, 2], 1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT 'Const arguments';\n+SELECT arraySort(arraySymmetricDifference([]));\n+SELECT arraySort(arraySymmetricDifference([1, 2]));\n+SELECT arraySort(arraySymmetricDifference([1, 2], [1, 3]));\n+SELECT arraySort(arraySymmetricDifference(['a', 'b'], ['a', 'c']));\n+SELECT arraySort(arraySymmetricDifference([1, NULL], [1, 3]));\n+SELECT arraySort(arraySymmetricDifference([1, NULL], [NULL, 3]));\n+SELECT arraySort(arraySymmetricDifference([1, 1], [1, 1]));\n+SELECT arraySort(arraySymmetricDifference([1, 2], [1, 2]));\n+SELECT arraySort(arraySymmetricDifference([1, 2], [1, 2], [1, 2]));\n+SELECT arraySort(arraySymmetricDifference([1, 2], [1, 2], [1, 3]));\n+\n+SELECT toTypeName(arraySymmetricDifference([(1, ['a', 'b']), (Null, ['c'])], [(2, ['c', Null]), (1, ['a', 'b'])]));\n+\n+SELECT 'Non-const arguments';\n+WITH\n+    materialize([(1, ['a', 'b']), (NULL, ['c'])]) AS f,\n+    materialize([(2, ['c', NULL]), (1, ['a', 'b'])]) AS s\n+SELECT arraySymmetricDifference(f, s);\n+WITH\n+    materialize([(1, ['a', 'b']::Array(LowCardinality(String))), (NULL, ['c']::Array(LowCardinality(String)))]) AS f,\n+    materialize([(2, ['c', NULL]::Array(LowCardinality(Nullable(String)))), (1, ['a', 'b']::Array(LowCardinality(String)))]) AS s\n+SELECT arraySymmetricDifference(f, s)\n\\ No newline at end of file\n",
  "problem_statement": "Implement `arraySymmetricDifference` function\n**Use case**\r\n\r\nWould be nice addition to `arrayIntersect` or `arrayUnion` https://github.com/ClickHouse/ClickHouse/issues/61553\r\n\r\n**Additional context**\r\n\r\nClickHouse already has `arrayDifference`, but this it does a completely other thing. \r\n\n",
  "hints_text": "assign this task to me please, i will try to make my first contribution\r\n\n@pheepa Thank you!\r\n\nHi, I am working on this issue\r\nI already implemented first version of function, but not sure if I am doing this right\r\nIt's better to discuss it before review of my PR\r\n\r\narrayIntersect implementation is really optimized and I think it is a right way to reuse some logic\r\nWhole logic can be done in execute method, is it okay to copy paste NumberExecutor::operator(),  prepareArrays, executeImpl methods from arrayIntersect class but change it to arraySymmetricDifference::executeImpl etc.? \r\n\r\nI believe that it can be done with simple import/inheritance of this methods with just templating the way I need, I would appreciate if you share some examples of this approach.\r\n\nSome additional thoughs: if inheritance of arrayIntersectionFunction is not a good idea, maybe I should create some arrayCommonFunction class and inherit both arrayIntersectionFunction and arraySymmetricDifferenceFunction?\n@tinfoil-knight\r\nI see you working on the similar issue, may be you can share your vision of it?\r\n\n@pheepa my plan is mentioned here: https://github.com/ClickHouse/ClickHouse/issues/61553#issuecomment-2016499363. You can see the comment in reply to get an idea about re-using logic.\npr - https://github.com/ClickHouse/ClickHouse/pull/62262\r\nI am not sure how to link it, seems like I dont have rights to do it\nIn case someone wants to continue, @pheepa 's PR is 95% done.",
  "created_at": "2025-02-16T13:01:02Z"
}