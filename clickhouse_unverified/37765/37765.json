{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37765,
  "instance_id": "ClickHouse__ClickHouse-37765",
  "issue_numbers": [
    "37662"
  ],
  "base_commit": "663261673381d392a6a00753c165de84f5629827",
  "patch": "diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 822bdf8d72af..045f6aad2b50 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -1683,20 +1683,40 @@ bool ParserNumber::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n     char buf[MAX_LENGTH_OF_NUMBER + 1];\n \n-    memcpy(buf, pos->begin, pos->size());\n-    buf[pos->size()] = 0;\n+    size_t size = pos->size();\n+    memcpy(buf, pos->begin, size);\n+    buf[size] = 0;\n+    char * start_pos = buf;\n \n-    char * pos_double = buf;\n-    errno = 0;    /// Functions strto* don't clear errno.\n-    Float64 float_value = std::strtod(buf, &pos_double);\n-    if (pos_double != buf + pos->size() || errno == ERANGE)\n+    if (*start_pos == '0')\n     {\n-        /// Try to parse number as binary literal representation. Example: 0b0001.\n-        if (pos->size() > 2 && buf[0] == '0' && buf[1] == 'b')\n+        ++start_pos;\n+        --size;\n+\n+        /// binary\n+        if (*start_pos == 'b')\n         {\n-            char * buf_skip_prefix = buf + 2;\n+            ++start_pos;\n+            --size;\n+            if (parseNumber(start_pos, size, negative, 2, res))\n+            {\n+                auto literal = std::make_shared<ASTLiteral>(res);\n+                literal->begin = literal_begin;\n+                literal->end = ++pos;\n+                node = literal;\n \n-            if (parseNumber(buf_skip_prefix, pos->size() - 2, negative, 2, res))\n+                return true;\n+            }\n+            else\n+                return false;\n+        }\n+\n+        /// hexadecimal\n+        if (*start_pos == 'x' || *start_pos == 'X')\n+        {\n+            ++start_pos;\n+            --size;\n+            if (parseNumber(start_pos, size, negative, 16, res))\n             {\n                 auto literal = std::make_shared<ASTLiteral>(res);\n                 literal->begin = literal_begin;\n@@ -1706,29 +1726,58 @@ bool ParserNumber::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n                 return true;\n             }\n         }\n+        else\n+        {\n+            /// possible leading zeroes in integer\n+            while (*start_pos == '0')\n+            {\n+                ++start_pos;\n+                --size;\n+            }\n+            if (parseNumber(start_pos, size, negative, 10, res))\n+            {\n+                auto literal = std::make_shared<ASTLiteral>(res);\n+                literal->begin = literal_begin;\n+                literal->end = ++pos;\n+                node = literal;\n \n-        expected.add(pos, \"number\");\n-        return false;\n+                return true;\n+            }\n+        }\n     }\n+    else if (parseNumber(start_pos, size, negative, 10, res))\n+    {\n+        auto literal = std::make_shared<ASTLiteral>(res);\n+        literal->begin = literal_begin;\n+        literal->end = ++pos;\n+        node = literal;\n \n-    if (float_value < 0)\n-        throw Exception(\"Logical error: token number cannot begin with minus, but parsed float number is less than zero.\", ErrorCodes::LOGICAL_ERROR);\n+        return true;\n+    }\n \n-    if (negative)\n-        float_value = -float_value;\n+    char * pos_double = buf;\n+    errno = 0;    /// Functions strto* don't clear errno.\n+    Float64 float_value = std::strtod(buf, &pos_double);\n+    if (pos_double == buf + pos->size() && errno != ERANGE)\n+    {\n+        if (float_value < 0)\n+            throw Exception(\"Logical error: token number cannot begin with minus, but parsed float number is less than zero.\", ErrorCodes::LOGICAL_ERROR);\n \n-    res = float_value;\n+        if (negative)\n+            float_value = -float_value;\n \n-    /// try to use more exact type: UInt64\n+        res = float_value;\n \n-    parseNumber(buf, pos->size(), negative, 0, res);\n+        auto literal = std::make_shared<ASTLiteral>(res);\n+        literal->begin = literal_begin;\n+        literal->end = ++pos;\n+        node = literal;\n \n-    auto literal = std::make_shared<ASTLiteral>(res);\n-    literal->begin = literal_begin;\n-    literal->end = ++pos;\n-    node = literal;\n+        return true;\n+    }\n \n-    return true;\n+    expected.add(pos, \"number\");\n+    return false;\n }\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00031_parser_number.reference b/tests/queries/0_stateless/00031_parser_number.reference\nindex b8d9617f5c8a..0f71cab1f46c 100644\n--- a/tests/queries/0_stateless/00031_parser_number.reference\n+++ b/tests/queries/0_stateless/00031_parser_number.reference\n@@ -1,3 +1,3 @@\n-0\t1\t-1\t128\t-127\t-128\t255\t-128\t255\t-127\t65535\t4294967295\t12300\t4656\t-0\t-0\t0\t18446744073709551615\t20988295479420645000\t-18446744073709552000\t-9223372036854775807\t-8.98846567431158e307\t-2.2250738585072014e-308\tinf\t-inf\tnan\tnan\t1e-302\tUInt8\tUInt8\tInt8\tUInt8\tInt8\tInt8\tUInt8\tInt8\tUInt8\tInt8\tUInt16\tUInt32\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\tUInt64\tFloat64\tFloat64\tInt64\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\n+0\t1\t-1\t128\t-127\t-128\t255\t-128\t377\t-177\t65535\t4294967295\t12300\t4656\t-0\t-0\t0\t18446744073709551615\t20988295479420645000\t-18446744073709552000\t-9223372036854775807\t-8.98846567431158e307\t-2.2250738585072014e-308\tinf\t-inf\tnan\tnan\t1e-302\tUInt8\tUInt8\tInt8\tUInt8\tInt8\tInt8\tUInt8\tInt8\tUInt16\tInt16\tUInt16\tUInt32\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\tUInt64\tFloat64\tFloat64\tInt64\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\tFloat64\n 1e308\n -1e-307\ndiff --git a/tests/queries/0_stateless/00948_values_interpreter_template.reference b/tests/queries/0_stateless/00948_values_interpreter_template.reference\nindex e6888e214330..f5d1cd48802b 100644\n--- a/tests/queries/0_stateless/00948_values_interpreter_template.reference\n+++ b/tests/queries/0_stateless/00948_values_interpreter_template.reference\n@@ -15,6 +15,6 @@\n 3\n 7\n 11\n-16\n-24\n-32\n+20\n+30\n+40\ndiff --git a/tests/queries/0_stateless/02316_literal_no_octal.reference b/tests/queries/0_stateless/02316_literal_no_octal.reference\nnew file mode 100644\nindex 000000000000..ae1800e8c754\n--- /dev/null\n+++ b/tests/queries/0_stateless/02316_literal_no_octal.reference\n@@ -0,0 +1,1 @@\n+77\t78\ndiff --git a/tests/queries/0_stateless/02316_literal_no_octal.sql b/tests/queries/0_stateless/02316_literal_no_octal.sql\nnew file mode 100644\nindex 000000000000..a75335078a80\n--- /dev/null\n+++ b/tests/queries/0_stateless/02316_literal_no_octal.sql\n@@ -0,0 +1,1 @@\n+SELECT 077, 078;\n",
  "problem_statement": "Error in parsing ENUM Literal Values.\n\r\n**Describe the unexpected behaviour**\r\nClickhouse parses enum object unexpectedly when enum object literal value is 08 or 09. I tried to debug the problem and it seems that  Which::type is returning Float64 and hence ENUMparser is throwing error.\r\n\r\n**Notice  dot symbol after 8 literal value in generated SQL .  This is not happening for values 07,01,03... so on . This is failing for only ( = 08 and =09)**\r\n\r\n**How to reproduce**\r\n````\r\n :) CREATE TABLE t1 (`Road_Surface_Condition` Enum8('00 - Unkown' = 0,'07 - Others' = 07,'08 - Loose sand and gravel' = 8, '09 - Spilled liquid' = 9),objectId UInt32)Engine=MergeTree ORDER BY objectId\r\n\r\nCREATE TABLE t1\r\n(\r\n    `Road_Surface_Condition` Enum8('00 - Unkown' = 0, '07 - Others' = 7, '08 - Loose sand and gravel' = 8, '09 - Spilled liquid' = 9),\r\n    `objectId` UInt32\r\n)\r\nENGINE = MergeTree\r\nORDER BY objectId\r\n\r\nQuery id: fc946666-baeb-49af-bda2-72df3fd5d6ea\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.028 sec. \r\n\r\n:) CREATE TABLE t1 (`Road_Surface_Condition` Enum8('00 - Unkown' = 0,'07 - Others' = 07),objectId UInt32)Engine=MergeTree ORDER BY objectId\r\n\r\nCREATE TABLE t1\r\n(\r\n    `Road_Surface_Condition` Enum8('00 - Unkown' = 0, '07 - Others' = 7),\r\n    `objectId` UInt32\r\n)\r\nENGINE = MergeTree\r\nORDER BY objectId\r\n\r\nQuery id: ee00d448-d038-4876-85c3-a607b0a85d4c\r\n\r\n\r\n0 rows in set. Elapsed: 0.003 sec. \r\n\r\nReceived exception from server (version 22.3.6):\r\nCode: 57. DB::Exception: Received from localhost:9000. DB::Exception: Table default.t1 already exists. (TABLE_ALREADY_EXISTS)\r\n\r\n :) CREATE TABLE t2 (`Road_Surface_Condition` Enum8('00 - Unkown' = 0,'07 - Others' = 07),objectId UInt32)Engine=MergeTree ORDER BY objectId\r\n\r\nCREATE TABLE t2\r\n(\r\n    `Road_Surface_Condition` Enum8('00 - Unkown' = 0, '07 - Others' = 7),\r\n    `objectId` UInt32\r\n)\r\nENGINE = MergeTree\r\nORDER BY objectId\r\n\r\nQuery id: f6eb283f-0480-43ad-8fc0-08925a6a13e5\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.027 sec. \r\n :) `\r\n```\r\n\r\n* Which ClickHouse server version to use\r\n v22.6\r\n\r\n* Which interface to use, if matters\r\ncommand line client. \r\n\r\n**Expected behavior**\r\nTable should be created successfully with specified Enum column .\r\n\r\n**Error message and/or stacktrace**\r\n```\r\nReceived exception from server (version 22.3.6):\r\nCode: 223. DB::exception: Received from localhost:9000. DB::exception: Elements of Enum data type must be of form: 'name' = number, where name is string literal and number is an integer. (UNEXPECTED_AST_STRUCTURE)\r\n```\r\n\r\n**Additional context**\r\n\n",
  "hints_text": "I guess it happens because, in this context, number starting with 0 interpreted as an octal - and octal has 8 digits - 0..7, so 08 and 09 are not allowed in this context...\nPlease notice in CREATE `'08' = 010, '09' = 011`\r\n```\r\nClickHouse-ubuntu :) CREATE TABLE t1 (oct_col Enum8('00' = 0,'07' = 07,'08' = 010, '09' = 011)) Engine=MergeTree ORDER BY oct_col\r\n\r\nOk.\r\n\r\nClickHouse-ubuntu :) insert into t1 values ('00'),('07'),('08'),('09')\r\n\r\nOk.\r\n\r\nClickHouse-ubuntu :) select oct_col, toInt32(oct_col) from t1\r\n\r\n\u250c\u2500oct_col\u2500\u252c\u2500toInt32(oct_col)\u2500\u2510\r\n\u2502 00      \u2502                0 \u2502\r\n\u2502 07      \u2502                7 \u2502\r\n\u2502 08      \u2502                8 \u2502\r\n\u2502 09      \u2502                9 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n4 rows in set. Elapsed: 0.014 sec.\r\n\n> I guess it happens because, in this context, number starting with 0 interpreted as an octal - and octal has 8 digits - 0..7, so 08 and 09 are not allowed in this context...\r\n\r\n\r\n\r\n> I guess it happens because, in this context, number starting with 0 interpreted as an octal - and octal has 8 digits - 0..7, so 08 and 09 are not allowed in this context...\r\n\r\nThanks @yakov-olkhovskiy for prompt reply. I agree , if I am explicitly defining oct_col  ,CH should interpret these values as Octal and works was expected. However , if in the first case , if CH considered values as Octal , it should not append decimal(dot) when value = 08 and 09. The which  value_literal type  for =08 is  Float64. The same has been confirmed with debug statements on the code and debugging with GDB.\r\n\r\nCode snippet which is throwing exception based on the type \r\n\r\n```\r\n else if (child->as<ASTFunction>())\r\n        {\r\n            if (is_first_child)\r\n            {\r\n                checkASTStructure(child);\r\n                const auto * func = child->as<ASTFunction>();\r\n                const auto * value_literal = func->arguments->children[1]->as<ASTLiteral>();\r\n\r\n                if (!value_literal\r\n                    || (value_literal->value.getType() != Field::Types::UInt64 && value_literal->value.getType() != Field::Types::Int64))\r\n                    throw Exception(\"Elements of Enum data type must be of form: 'name' = number or 'name', where name is string literal and number is an integer\",\r\n                                    ErrorCodes::UNEXPECTED_AST_STRUCTURE);\r\n\r\n                .....\r\n```\r\n\r\n\r\n\r\n\nProblematic code is here:\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Parsers/ExpressionElementParsers.cpp#L1689-L1725\r\nit successfully parses as float and further attempt to parse it as possible octal fails so it sticks as float.\r\n\r\n```\r\n    char * pos_double = buf;\r\n    errno = 0;    /// Functions strto* don't clear errno.\r\n    Float64 float_value = std::strtod(buf, &pos_double);\r\n    if (pos_double != buf + pos->size() || errno == ERANGE)\r\n    {\r\n        /// Try to parse number as binary literal representation. Example: 0b0001.\r\n        if (pos->size() > 2 && buf[0] == '0' && buf[1] == 'b')\r\n        {\r\n            char * buf_skip_prefix = buf + 2;\r\n\r\n            if (parseNumber(buf_skip_prefix, pos->size() - 2, negative, 2, res))\r\n            {\r\n                auto literal = std::make_shared<ASTLiteral>(res);\r\n                literal->begin = literal_begin;\r\n                literal->end = ++pos;\r\n                node = literal;\r\n\r\n                return true;\r\n            }\r\n        }\r\n\r\n        expected.add(pos, \"number\");\r\n        return false;\r\n    }\r\n\r\n    if (float_value < 0)\r\n        throw Exception(\"Logical error: token number cannot begin with minus, but parsed float number is less than zero.\", ErrorCodes::LOGICAL_ERROR);\r\n\r\n    if (negative)\r\n        float_value = -float_value;\r\n\r\n    res = float_value;\r\n\r\n    /// try to use more exact type: UInt64\r\n\r\n    parseNumber(buf, pos->size(), negative, 0, res);\r\n```\r\n\r\n\nThanks @yakov-olkhovskiy. I appreciate your prompt efforts and fix.",
  "created_at": "2022-06-01T20:59:03Z"
}