{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57277,
  "instance_id": "ClickHouse__ClickHouse-57277",
  "issue_numbers": [
    "57151"
  ],
  "base_commit": "0e548a4caf3a67f6391d7243e70e40f5456b3871",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex 0f85b81278d5..fffbea31d0d5 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -543,26 +543,52 @@ Like `concatWithSeparator` but assumes that `concatWithSeparator(sep, expr1, exp\n \n A function is called injective if it returns for different arguments different results. In other words: different arguments never produce identical result.\n \n-## substring(s, offset, length)\n+## substring\n \n-Returns a substring with `length` many bytes, starting at the byte at index `offset`. Character indexing starts from 1.\n+Returns the substring of a string `s` which starts at the specified byte index `offset`. Byte counting starts from 1. If `offset` is 0, an empty string is returned. If `offset` is negative, the substring starts `pos` characters from the end of the string, rather than from the beginning. An optional argument `length` specifies the maximum number of bytes the returned substring may have.\n \n **Syntax**\n \n ```sql\n-substring(s, offset, length)\n+substring(s, offset[, length])\n ```\n \n Alias:\n - `substr`\n - `mid`\n \n+**Arguments**\n+\n+- `s` \u2014 The string to calculate a substring from. [String](../../sql-reference/data-types/string.md), [FixedString](../../sql-reference/data-types/fixedstring.md) or [Enum](../../sql-reference/data-types/enum.md)\n+- `offset` \u2014 The starting position of the substring in `s` . [(U)Int*](../../sql-reference/data-types/int-uint.md).\n+- `length` \u2014 The maximum length of the substring. [(U)Int*](../../sql-reference/data-types/int-uint.md). Optional.\n+\n+**Returned value**\n+\n+A substring of `s` with `length` many bytes, starting at index `offset`.\n+\n+Type: `String`.\n+\n+**Example**\n+\n+``` sql\n+SELECT 'database' AS db, substr(db, 5), substr(db, 5, 1)\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500db\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500substring('database', 5)\u2500\u252c\u2500substring('database', 5, 1)\u2500\u2510\n+\u2502 database \u2502 base                     \u2502 b                           \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## substringUTF8\n \n Like `substring` but for Unicode code points. Assumes that the string contains valid UTF-8 encoded text. If this assumption is violated, no exception is thrown and the result is undefined.\n \n \n-## substringIndex(s, delim, count)\n+## substringIndex\n \n Returns the substring of `s` before `count` occurrences of the delimiter `delim`, as in Spark or MySQL.\n \n@@ -593,7 +619,7 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## substringIndexUTF8(s, delim, count)\n+## substringIndexUTF8\n \n Like `substringIndex` but for Unicode code points. Assumes that the string contains valid UTF-8 encoded text. If this assumption is violated, no exception is thrown and the result is undefined.\n \ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex a1de6ea18a96..eabf066bc3d5 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -440,6 +440,8 @@ template <typename T> inline bool isFloat(const T & data_type) { return WhichDat\n template <typename T> inline bool isNativeNumber(const T & data_type) { return WhichDataType(data_type).isNativeNumber(); }\n template <typename T> inline bool isNumber(const T & data_type) { return WhichDataType(data_type).isNumber(); }\n \n+template <typename T> inline bool isEnum8(const T & data_type) { return WhichDataType(data_type).isEnum8(); }\n+template <typename T> inline bool isEnum16(const T & data_type) { return WhichDataType(data_type).isEnum16(); }\n template <typename T> inline bool isEnum(const T & data_type) { return WhichDataType(data_type).isEnum(); }\n \n template <typename T> inline bool isDate(const T & data_type) { return WhichDataType(data_type).isDate(); }\ndiff --git a/src/Functions/GatherUtils/Sources.h b/src/Functions/GatherUtils/Sources.h\nindex fad2be1f622e..222f9f19168e 100644\n--- a/src/Functions/GatherUtils/Sources.h\n+++ b/src/Functions/GatherUtils/Sources.h\n@@ -11,6 +11,8 @@\n #include <Common/typeid_cast.h>\n #include <Common/UTF8Helpers.h>\n \n+#include <DataTypes/EnumValues.h>\n+\n #include \"IArraySource.h\"\n #include \"IValueSource.h\"\n #include \"Slices.h\"\n@@ -56,8 +58,8 @@ struct NumericArraySource : public ArraySourceImpl<NumericArraySource<T>>\n     }\n \n     explicit NumericArraySource(const ColumnArray & arr)\n-            : column(typeid_cast<const ColVecType &>(arr.getData()))\n-            , elements(typeid_cast<const ColVecType &>(arr.getData()).getData()), offsets(arr.getOffsets())\n+        : column(typeid_cast<const ColVecType &>(arr.getData()))\n+        , elements(typeid_cast<const ColVecType &>(arr.getData()).getData()), offsets(arr.getOffsets())\n     {\n     }\n \n@@ -154,17 +156,22 @@ struct ConstSource : public Base\n     size_t row_num = 0;\n \n     explicit ConstSource(const ColumnConst & col_)\n-            : Base(static_cast<const typename Base::Column &>(col_.getDataColumn())), total_rows(col_.size())\n+        : Base(static_cast<const typename Base::Column &>(col_.getDataColumn()))\n+        , total_rows(col_.size())\n     {\n     }\n \n     template <typename ColumnType>\n-    ConstSource(const ColumnType & col_, size_t total_rows_) : Base(col_), total_rows(total_rows_)\n+    ConstSource(const ColumnType & col_, size_t total_rows_)\n+        : Base(col_)\n+        , total_rows(total_rows_)\n     {\n     }\n \n     template <typename ColumnType>\n-    ConstSource(const ColumnType & col_, const NullMap & null_map_, size_t total_rows_) : Base(col_, null_map_), total_rows(total_rows_)\n+    ConstSource(const ColumnType & col_, const NullMap & null_map_, size_t total_rows_)\n+        : Base(col_, null_map_)\n+        , total_rows(total_rows_)\n     {\n     }\n \n@@ -240,7 +247,8 @@ struct StringSource\n     ColumnString::Offset prev_offset = 0;\n \n     explicit StringSource(const ColumnString & col)\n-            : elements(col.getChars()), offsets(col.getOffsets())\n+        : elements(col.getChars())\n+        , offsets(col.getOffsets())\n     {\n     }\n \n@@ -313,6 +321,96 @@ struct StringSource\n     }\n };\n \n+/// Treats Enum values as Strings, modeled after StringSource\n+template <typename EnumDataType>\n+struct EnumSource\n+{\n+    using Column = typename EnumDataType::ColumnType;\n+    using Slice = NumericArraySlice<UInt8>;\n+\n+    using SinkType = StringSink;\n+\n+    const typename Column::Container & data;\n+    const EnumDataType & data_type;\n+\n+    size_t row_num = 0;\n+\n+    EnumSource(const Column & col, const EnumDataType & data_type_)\n+        : data(col.getData())\n+        , data_type(data_type_)\n+    {\n+    }\n+\n+    void next()\n+    {\n+        ++row_num;\n+    }\n+\n+    bool isEnd() const\n+    {\n+        return row_num == data.size();\n+    }\n+\n+    size_t rowNum() const\n+    {\n+        return row_num;\n+    }\n+\n+    size_t getSizeForReserve() const\n+    {\n+        return data.size();\n+    }\n+\n+    size_t getElementSize() const\n+    {\n+        std::string_view name = data_type.getNameForValue(data[row_num]).toView();\n+        return name.size();\n+    }\n+\n+    size_t getColumnSize() const\n+    {\n+        return data.size();\n+    }\n+\n+    Slice getWhole() const\n+    {\n+        std::string_view name = data_type.getNameForValue(data[row_num]).toView();\n+        return {reinterpret_cast<const UInt8 *>(name.data()), name.size()};\n+    }\n+\n+    Slice getSliceFromLeft(size_t offset) const\n+    {\n+        std::string_view name = data_type.getNameForValue(data[row_num]).toView();\n+        if (offset >= name.size())\n+            return {reinterpret_cast<const UInt8 *>(name.data()), 0};\n+        return {reinterpret_cast<const UInt8 *>(name.data()) + offset, name.size() - offset};\n+    }\n+\n+    Slice getSliceFromLeft(size_t offset, size_t length) const\n+    {\n+        std::string_view name = data_type.getNameForValue(data[row_num]).toView();\n+        if (offset >= name.size())\n+            return {reinterpret_cast<const UInt8 *>(name.data()), 0};\n+        return {reinterpret_cast<const UInt8 *>(name.data()) + offset, std::min(length, name.size() - offset)};\n+    }\n+\n+    Slice getSliceFromRight(size_t offset) const\n+    {\n+        std::string_view name = data_type.getNameForValue(data[row_num]).toView();\n+        if (offset > name.size())\n+            return {reinterpret_cast<const UInt8 *>(name.data()), name.size()};\n+        return {reinterpret_cast<const UInt8 *>(name.data()) + name.size() - offset, offset};\n+    }\n+\n+    Slice getSliceFromRight(size_t offset, size_t length) const\n+    {\n+        std::string_view name = data_type.getNameForValue(data[row_num]).toView();\n+        if (offset > name.size())\n+            return {reinterpret_cast<const UInt8 *>(name.data()), length + name.size() > offset ? std::min(name.size(), length + name.size() - offset) : 0};\n+        return {reinterpret_cast<const UInt8 *>(name.data()) + name.size() - offset, std::min(length, offset)};\n+    }\n+};\n+\n \n /// Differs to StringSource by having 'offset' and 'length' in code points instead of bytes in getSlice* methods.\n /** NOTE: The behaviour of substring and substringUTF8 is inconsistent when negative offset is greater than string size:\n@@ -419,7 +517,7 @@ struct FixedStringSource\n     size_t column_size = 0;\n \n     explicit FixedStringSource(const ColumnFixedString & col)\n-            : string_size(col.getN())\n+        : string_size(col.getN())\n     {\n         const auto & chars = col.getChars();\n         pos = chars.data();\n@@ -553,7 +651,8 @@ struct GenericArraySource : public ArraySourceImpl<GenericArraySource>\n     }\n \n     explicit GenericArraySource(const ColumnArray & arr)\n-            : elements(arr.getData()), offsets(arr.getOffsets())\n+        : elements(arr.getData())\n+        , offsets(arr.getOffsets())\n     {\n     }\n \n@@ -813,7 +912,10 @@ struct NullableValueSource : public ValueSource\n     const NullMap & null_map;\n \n     template <typename Column>\n-    explicit NullableValueSource(const Column & col, const NullMap & null_map_) : ValueSource(col), null_map(null_map_) {}\n+    NullableValueSource(const Column & col, const NullMap & null_map_)\n+        : ValueSource(col)\n+        , null_map(null_map_)\n+    {}\n \n     void accept(ValueSourceVisitor & visitor) override { visitor.visit(*this); }\n \ndiff --git a/src/Functions/substring.cpp b/src/Functions/substring.cpp\nindex 7678692f6124..ac6a24fbc117 100644\n--- a/src/Functions/substring.cpp\n+++ b/src/Functions/substring.cpp\n@@ -1,15 +1,16 @@\n-#include <DataTypes/DataTypeString.h>\n-#include <Columns/ColumnString.h>\n-#include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnConst.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnString.h>\n+#include <DataTypes/DataTypeEnum.h>\n+#include <DataTypes/DataTypeString.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n-#include <Functions/IFunction.h>\n+#include <Functions/GatherUtils/Algorithms.h>\n #include <Functions/GatherUtils/GatherUtils.h>\n-#include <Functions/GatherUtils/Sources.h>\n #include <Functions/GatherUtils/Sinks.h>\n #include <Functions/GatherUtils/Slices.h>\n-#include <Functions/GatherUtils/Algorithms.h>\n+#include <Functions/GatherUtils/Sources.h>\n+#include <Functions/IFunction.h>\n #include <IO/WriteHelpers.h>\n \n \n@@ -20,50 +21,50 @@ using namespace GatherUtils;\n \n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int ZERO_ARRAY_OR_TUPLE_INDEX;\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+extern const int ILLEGAL_COLUMN;\n+extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+extern const int ZERO_ARRAY_OR_TUPLE_INDEX;\n }\n \n namespace\n {\n \n /// If 'is_utf8' - measure offset and length in code points instead of bytes.\n-/// UTF8 variant is not available for FixedString arguments.\n template <bool is_utf8>\n class FunctionSubstring : public IFunction\n {\n public:\n     static constexpr auto name = is_utf8 ? \"substringUTF8\" : \"substring\";\n-    static FunctionPtr create(ContextPtr)\n-    {\n-        return std::make_shared<FunctionSubstring>();\n-    }\n-\n-    String getName() const override\n-    {\n-        return name;\n-    }\n \n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionSubstring>(); }\n+    String getName() const override { return name; }\n     bool isVariadic() const override { return true; }\n     size_t getNumberOfArguments() const override { return 0; }\n-\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-\n     bool useDefaultImplementationForConstants() const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        size_t number_of_arguments = arguments.size();\n+        const size_t number_of_arguments = arguments.size();\n \n         if (number_of_arguments < 2 || number_of_arguments > 3)\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Number of arguments for function {} doesn't match: \"\n                             \"passed {}, should be 2 or 3\", getName(), number_of_arguments);\n \n-        if ((is_utf8 && !isString(arguments[0])) || !isStringOrFixedString(arguments[0]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\",\n-                            arguments[0]->getName(), getName());\n+        if constexpr (is_utf8)\n+        {\n+            /// UTF8 variant is not available for FixedString and Enum arguments.\n+            if (!isString(arguments[0]))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of first argument of function {}\",\n+                                arguments[0]->getName(), getName());\n+        }\n+        else\n+        {\n+            if (!isStringOrFixedString(arguments[0]) && !isEnum(arguments[0]))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of first argument of function {}\",\n+                                arguments[0]->getName(), getName());\n+        }\n \n         if (!isNativeNumber(arguments[1]))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of second argument of function {}\",\n@@ -77,44 +78,40 @@ class FunctionSubstring : public IFunction\n     }\n \n     template <typename Source>\n-    ColumnPtr executeForSource(const ColumnPtr & column_start, const ColumnPtr & column_length,\n-                          const ColumnConst * column_start_const, const ColumnConst * column_length_const,\n-                          Int64 start_value, Int64 length_value, Source && source,\n-                          size_t input_rows_count) const\n+    ColumnPtr executeForSource(const ColumnPtr & column_offset, const ColumnPtr & column_length,\n+                          bool column_offset_const, bool column_length_const,\n+                          Int64 offset, Int64 length,\n+                          Source && source, size_t input_rows_count) const\n     {\n         auto col_res = ColumnString::create();\n \n         if (!column_length)\n         {\n-            if (column_start_const)\n+            if (column_offset_const)\n             {\n-                if (start_value > 0)\n-                    sliceFromLeftConstantOffsetUnbounded(\n-                        source, StringSink(*col_res, input_rows_count), static_cast<size_t>(start_value - 1));\n-                else if (start_value < 0)\n-                    sliceFromRightConstantOffsetUnbounded(\n-                        source, StringSink(*col_res, input_rows_count), -static_cast<size_t>(start_value));\n+                if (offset > 0)\n+                    sliceFromLeftConstantOffsetUnbounded(source, StringSink(*col_res, input_rows_count), static_cast<size_t>(offset - 1));\n+                else if (offset < 0)\n+                    sliceFromRightConstantOffsetUnbounded(source, StringSink(*col_res, input_rows_count), -static_cast<size_t>(offset));\n                 else\n                     throw Exception(ErrorCodes::ZERO_ARRAY_OR_TUPLE_INDEX, \"Indices in strings are 1-based\");\n             }\n             else\n-                sliceDynamicOffsetUnbounded(source, StringSink(*col_res, input_rows_count), *column_start);\n+                sliceDynamicOffsetUnbounded(source, StringSink(*col_res, input_rows_count), *column_offset);\n         }\n         else\n         {\n-            if (column_start_const && column_length_const)\n+            if (column_offset_const && column_length_const)\n             {\n-                if (start_value > 0)\n-                    sliceFromLeftConstantOffsetBounded(\n-                        source, StringSink(*col_res, input_rows_count), static_cast<size_t>(start_value - 1), length_value);\n-                else if (start_value < 0)\n-                    sliceFromRightConstantOffsetBounded(\n-                        source, StringSink(*col_res, input_rows_count), -static_cast<size_t>(start_value), length_value);\n+                if (offset > 0)\n+                    sliceFromLeftConstantOffsetBounded(source, StringSink(*col_res, input_rows_count), static_cast<size_t>(offset - 1), length);\n+                else if (offset < 0)\n+                    sliceFromRightConstantOffsetBounded(source, StringSink(*col_res, input_rows_count), -static_cast<size_t>(offset), length);\n                 else\n                     throw Exception(ErrorCodes::ZERO_ARRAY_OR_TUPLE_INDEX, \"Indices in strings are 1-based\");\n             }\n             else\n-                sliceDynamicOffsetBounded(source, StringSink(*col_res, input_rows_count), *column_start, *column_length);\n+                sliceDynamicOffsetBounded(source, StringSink(*col_res, input_rows_count), *column_offset, *column_length);\n         }\n \n         return col_res;\n@@ -122,58 +119,60 @@ class FunctionSubstring : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        size_t number_of_arguments = arguments.size();\n+        const size_t number_of_arguments = arguments.size();\n \n         ColumnPtr column_string = arguments[0].column;\n-        ColumnPtr column_start = arguments[1].column;\n+        ColumnPtr column_offset = arguments[1].column;\n         ColumnPtr column_length;\n-\n         if (number_of_arguments == 3)\n             column_length = arguments[2].column;\n \n-        const ColumnConst * column_start_const = checkAndGetColumn<ColumnConst>(column_start.get());\n+        const ColumnConst * column_offset_const = checkAndGetColumn<ColumnConst>(column_offset.get());\n         const ColumnConst * column_length_const = nullptr;\n-\n         if (number_of_arguments == 3)\n             column_length_const = checkAndGetColumn<ColumnConst>(column_length.get());\n \n-        Int64 start_value = 0;\n-        Int64 length_value = 0;\n+        Int64 offset = 0;\n+        Int64 length = 0;\n \n-        if (column_start_const)\n-            start_value = column_start_const->getInt(0);\n+        if (column_offset_const)\n+            offset = column_offset_const->getInt(0);\n         if (column_length_const)\n-            length_value = column_length_const->getInt(0);\n+            length = column_length_const->getInt(0);\n \n         if constexpr (is_utf8)\n         {\n             if (const ColumnString * col = checkAndGetColumn<ColumnString>(column_string.get()))\n-                return executeForSource(column_start, column_length, column_start_const, column_length_const, start_value,\n-                                length_value, UTF8StringSource(*col), input_rows_count);\n-            else if (const ColumnConst * col_const = checkAndGetColumnConst<ColumnString>(column_string.get()))\n-                return executeForSource(column_start, column_length, column_start_const, column_length_const, start_value,\n-                                length_value, ConstSource<UTF8StringSource>(*col_const), input_rows_count);\n-            else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n-                    arguments[0].column->getName(), getName());\n+                return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, UTF8StringSource(*col), input_rows_count);\n+            if (const ColumnConst * col_const = checkAndGetColumnConst<ColumnString>(column_string.get()))\n+                return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, ConstSource<UTF8StringSource>(*col_const), input_rows_count);\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", arguments[0].column->getName(), getName());\n         }\n         else\n         {\n             if (const ColumnString * col = checkAndGetColumn<ColumnString>(column_string.get()))\n-                return executeForSource(column_start, column_length, column_start_const, column_length_const, start_value,\n-                                length_value, StringSource(*col), input_rows_count);\n-            else if (const ColumnFixedString * col_fixed = checkAndGetColumn<ColumnFixedString>(column_string.get()))\n-                return executeForSource(column_start, column_length, column_start_const, column_length_const, start_value,\n-                                length_value, FixedStringSource(*col_fixed), input_rows_count);\n-            else if (const ColumnConst * col_const = checkAndGetColumnConst<ColumnString>(column_string.get()))\n-                return executeForSource(column_start, column_length, column_start_const, column_length_const, start_value,\n-                                length_value, ConstSource<StringSource>(*col_const), input_rows_count);\n-            else if (const ColumnConst * col_const_fixed = checkAndGetColumnConst<ColumnFixedString>(column_string.get()))\n-                return executeForSource(column_start, column_length, column_start_const, column_length_const, start_value,\n-                                length_value, ConstSource<FixedStringSource>(*col_const_fixed), input_rows_count);\n-            else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n-                    arguments[0].column->getName(), getName());\n+                return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, StringSource(*col), input_rows_count);\n+            if (const ColumnFixedString * col_fixed = checkAndGetColumn<ColumnFixedString>(column_string.get()))\n+                return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, FixedStringSource(*col_fixed), input_rows_count);\n+            if (const ColumnConst * col_const = checkAndGetColumnConst<ColumnString>(column_string.get()))\n+                return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, ConstSource<StringSource>(*col_const), input_rows_count);\n+            if (const ColumnConst * col_const_fixed = checkAndGetColumnConst<ColumnFixedString>(column_string.get()))\n+                return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, ConstSource<FixedStringSource>(*col_const_fixed), input_rows_count);\n+            if (isEnum(arguments[0].type))\n+            {\n+                if (const typename DataTypeEnum8::ColumnType * col_enum8 = checkAndGetColumn<typename DataTypeEnum8::ColumnType>(column_string.get()))\n+                {\n+                    const auto * type_enum8 = assert_cast<const DataTypeEnum8 *>(arguments[0].type.get());\n+                    return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, EnumSource<DataTypeEnum8>(*col_enum8, *type_enum8), input_rows_count);\n+                }\n+                if (const typename DataTypeEnum16::ColumnType * col_enum16 = checkAndGetColumn<typename DataTypeEnum16::ColumnType>(column_string.get()))\n+                {\n+                    const auto * type_enum16 = assert_cast<const DataTypeEnum16 *>(arguments[0].type.get());\n+                    return executeForSource(column_offset, column_length, column_offset_const, column_length_const, offset, length, EnumSource<DataTypeEnum16>(*col_enum16, *type_enum16), input_rows_count);\n+                }\n+            }\n+\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\", arguments[0].column->getName(), getName());\n         }\n     }\n };\n@@ -183,8 +182,8 @@ class FunctionSubstring : public IFunction\n REGISTER_FUNCTION(Substring)\n {\n     factory.registerFunction<FunctionSubstring<false>>({}, FunctionFactory::CaseInsensitive);\n-    factory.registerAlias(\"substr\", \"substring\", FunctionFactory::CaseInsensitive);\n-    factory.registerAlias(\"mid\", \"substring\", FunctionFactory::CaseInsensitive); /// from MySQL dialect\n+    factory.registerAlias(\"substr\", \"substring\", FunctionFactory::CaseInsensitive); // MySQL alias\n+    factory.registerAlias(\"mid\", \"substring\", FunctionFactory::CaseInsensitive); /// MySQL alias\n \n     factory.registerFunction<FunctionSubstring<true>>({}, FunctionFactory::CaseSensitive);\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00493_substring_of_enum.reference b/tests/queries/0_stateless/00493_substring_of_enum.reference\nnew file mode 100644\nindex 000000000000..17bc960b3182\n--- /dev/null\n+++ b/tests/queries/0_stateless/00493_substring_of_enum.reference\n@@ -0,0 +1,155 @@\n+-- Positive offsets (slice from left)\n+Offset: \t1\tLength: \t1\thello\tshark\th\ts\n+Offset: \t1\tLength: \t2\thello\tshark\the\tsh\n+Offset: \t1\tLength: \t3\thello\tshark\thel\tsha\n+Offset: \t1\tLength: \t4\thello\tshark\thell\tshar\n+Offset: \t1\tLength: \t5\thello\tshark\thello\tshark\n+Offset: \t1\tLength: \t6\thello\tshark\thello\tshark\n+Offset: \t2\tLength: \t1\tello\thark\te\th\n+Offset: \t2\tLength: \t2\tello\thark\tel\tha\n+Offset: \t2\tLength: \t3\tello\thark\tell\thar\n+Offset: \t2\tLength: \t4\tello\thark\tello\thark\n+Offset: \t2\tLength: \t5\tello\thark\tello\thark\n+Offset: \t2\tLength: \t6\tello\thark\tello\thark\n+Offset: \t3\tLength: \t1\tllo\tark\tl\ta\n+Offset: \t3\tLength: \t2\tllo\tark\tll\tar\n+Offset: \t3\tLength: \t3\tllo\tark\tllo\tark\n+Offset: \t3\tLength: \t4\tllo\tark\tllo\tark\n+Offset: \t3\tLength: \t5\tllo\tark\tllo\tark\n+Offset: \t3\tLength: \t6\tllo\tark\tllo\tark\n+Offset: \t4\tLength: \t1\tlo\trk\tl\tr\n+Offset: \t4\tLength: \t2\tlo\trk\tlo\trk\n+Offset: \t4\tLength: \t3\tlo\trk\tlo\trk\n+Offset: \t4\tLength: \t4\tlo\trk\tlo\trk\n+Offset: \t4\tLength: \t5\tlo\trk\tlo\trk\n+Offset: \t4\tLength: \t6\tlo\trk\tlo\trk\n+Offset: \t5\tLength: \t1\to\tk\to\tk\n+Offset: \t5\tLength: \t2\to\tk\to\tk\n+Offset: \t5\tLength: \t3\to\tk\to\tk\n+Offset: \t5\tLength: \t4\to\tk\to\tk\n+Offset: \t5\tLength: \t5\to\tk\to\tk\n+Offset: \t5\tLength: \t6\to\tk\to\tk\n+Offset: \t6\tLength: \t1\t\t\t\t\n+Offset: \t6\tLength: \t2\t\t\t\t\n+Offset: \t6\tLength: \t3\t\t\t\t\n+Offset: \t6\tLength: \t4\t\t\t\t\n+Offset: \t6\tLength: \t5\t\t\t\t\n+Offset: \t6\tLength: \t6\t\t\t\t\n+Offset: \t1\tLength: \t1\tworld\teagle\tw\te\n+Offset: \t1\tLength: \t2\tworld\teagle\two\tea\n+Offset: \t1\tLength: \t3\tworld\teagle\twor\teag\n+Offset: \t1\tLength: \t4\tworld\teagle\tworl\teagl\n+Offset: \t1\tLength: \t5\tworld\teagle\tworld\teagle\n+Offset: \t1\tLength: \t6\tworld\teagle\tworld\teagle\n+Offset: \t2\tLength: \t1\torld\tagle\to\ta\n+Offset: \t2\tLength: \t2\torld\tagle\tor\tag\n+Offset: \t2\tLength: \t3\torld\tagle\torl\tagl\n+Offset: \t2\tLength: \t4\torld\tagle\torld\tagle\n+Offset: \t2\tLength: \t5\torld\tagle\torld\tagle\n+Offset: \t2\tLength: \t6\torld\tagle\torld\tagle\n+Offset: \t3\tLength: \t1\trld\tgle\tr\tg\n+Offset: \t3\tLength: \t2\trld\tgle\trl\tgl\n+Offset: \t3\tLength: \t3\trld\tgle\trld\tgle\n+Offset: \t3\tLength: \t4\trld\tgle\trld\tgle\n+Offset: \t3\tLength: \t5\trld\tgle\trld\tgle\n+Offset: \t3\tLength: \t6\trld\tgle\trld\tgle\n+Offset: \t4\tLength: \t1\tld\tle\tl\tl\n+Offset: \t4\tLength: \t2\tld\tle\tld\tle\n+Offset: \t4\tLength: \t3\tld\tle\tld\tle\n+Offset: \t4\tLength: \t4\tld\tle\tld\tle\n+Offset: \t4\tLength: \t5\tld\tle\tld\tle\n+Offset: \t4\tLength: \t6\tld\tle\tld\tle\n+Offset: \t5\tLength: \t1\td\te\td\te\n+Offset: \t5\tLength: \t2\td\te\td\te\n+Offset: \t5\tLength: \t3\td\te\td\te\n+Offset: \t5\tLength: \t4\td\te\td\te\n+Offset: \t5\tLength: \t5\td\te\td\te\n+Offset: \t5\tLength: \t6\td\te\td\te\n+Offset: \t6\tLength: \t1\t\t\t\t\n+Offset: \t6\tLength: \t2\t\t\t\t\n+Offset: \t6\tLength: \t3\t\t\t\t\n+Offset: \t6\tLength: \t4\t\t\t\t\n+Offset: \t6\tLength: \t5\t\t\t\t\n+Offset: \t6\tLength: \t6\t\t\t\t\n+-- Negative offsets (slice from right)\n+Offset: \t-1\tLength: \t1\to\tk\to\tk\n+Offset: \t-1\tLength: \t2\to\tk\to\tk\n+Offset: \t-1\tLength: \t3\to\tk\to\tk\n+Offset: \t-1\tLength: \t4\to\tk\to\tk\n+Offset: \t-1\tLength: \t5\to\tk\to\tk\n+Offset: \t-1\tLength: \t6\to\tk\to\tk\n+Offset: \t-2\tLength: \t1\tlo\trk\tl\tr\n+Offset: \t-2\tLength: \t2\tlo\trk\tlo\trk\n+Offset: \t-2\tLength: \t3\tlo\trk\tlo\trk\n+Offset: \t-2\tLength: \t4\tlo\trk\tlo\trk\n+Offset: \t-2\tLength: \t5\tlo\trk\tlo\trk\n+Offset: \t-2\tLength: \t6\tlo\trk\tlo\trk\n+Offset: \t-3\tLength: \t1\tllo\tark\tl\ta\n+Offset: \t-3\tLength: \t2\tllo\tark\tll\tar\n+Offset: \t-3\tLength: \t3\tllo\tark\tllo\tark\n+Offset: \t-3\tLength: \t4\tllo\tark\tllo\tark\n+Offset: \t-3\tLength: \t5\tllo\tark\tllo\tark\n+Offset: \t-3\tLength: \t6\tllo\tark\tllo\tark\n+Offset: \t-4\tLength: \t1\tello\thark\te\th\n+Offset: \t-4\tLength: \t2\tello\thark\tel\tha\n+Offset: \t-4\tLength: \t3\tello\thark\tell\thar\n+Offset: \t-4\tLength: \t4\tello\thark\tello\thark\n+Offset: \t-4\tLength: \t5\tello\thark\tello\thark\n+Offset: \t-4\tLength: \t6\tello\thark\tello\thark\n+Offset: \t-5\tLength: \t1\thello\tshark\th\ts\n+Offset: \t-5\tLength: \t2\thello\tshark\the\tsh\n+Offset: \t-5\tLength: \t3\thello\tshark\thel\tsha\n+Offset: \t-5\tLength: \t4\thello\tshark\thell\tshar\n+Offset: \t-5\tLength: \t5\thello\tshark\thello\tshark\n+Offset: \t-5\tLength: \t6\thello\tshark\thello\tshark\n+Offset: \t-6\tLength: \t1\thello\tshark\t\t\n+Offset: \t-6\tLength: \t2\thello\tshark\th\ts\n+Offset: \t-6\tLength: \t3\thello\tshark\the\tsh\n+Offset: \t-6\tLength: \t4\thello\tshark\thel\tsha\n+Offset: \t-6\tLength: \t5\thello\tshark\thell\tshar\n+Offset: \t-6\tLength: \t6\thello\tshark\thello\tshark\n+Offset: \t-1\tLength: \t1\td\te\td\te\n+Offset: \t-1\tLength: \t2\td\te\td\te\n+Offset: \t-1\tLength: \t3\td\te\td\te\n+Offset: \t-1\tLength: \t4\td\te\td\te\n+Offset: \t-1\tLength: \t5\td\te\td\te\n+Offset: \t-1\tLength: \t6\td\te\td\te\n+Offset: \t-2\tLength: \t1\tld\tle\tl\tl\n+Offset: \t-2\tLength: \t2\tld\tle\tld\tle\n+Offset: \t-2\tLength: \t3\tld\tle\tld\tle\n+Offset: \t-2\tLength: \t4\tld\tle\tld\tle\n+Offset: \t-2\tLength: \t5\tld\tle\tld\tle\n+Offset: \t-2\tLength: \t6\tld\tle\tld\tle\n+Offset: \t-3\tLength: \t1\trld\tgle\tr\tg\n+Offset: \t-3\tLength: \t2\trld\tgle\trl\tgl\n+Offset: \t-3\tLength: \t3\trld\tgle\trld\tgle\n+Offset: \t-3\tLength: \t4\trld\tgle\trld\tgle\n+Offset: \t-3\tLength: \t5\trld\tgle\trld\tgle\n+Offset: \t-3\tLength: \t6\trld\tgle\trld\tgle\n+Offset: \t-4\tLength: \t1\torld\tagle\to\ta\n+Offset: \t-4\tLength: \t2\torld\tagle\tor\tag\n+Offset: \t-4\tLength: \t3\torld\tagle\torl\tagl\n+Offset: \t-4\tLength: \t4\torld\tagle\torld\tagle\n+Offset: \t-4\tLength: \t5\torld\tagle\torld\tagle\n+Offset: \t-4\tLength: \t6\torld\tagle\torld\tagle\n+Offset: \t-5\tLength: \t1\tworld\teagle\tw\te\n+Offset: \t-5\tLength: \t2\tworld\teagle\two\tea\n+Offset: \t-5\tLength: \t3\tworld\teagle\twor\teag\n+Offset: \t-5\tLength: \t4\tworld\teagle\tworl\teagl\n+Offset: \t-5\tLength: \t5\tworld\teagle\tworld\teagle\n+Offset: \t-5\tLength: \t6\tworld\teagle\tworld\teagle\n+Offset: \t-6\tLength: \t1\tworld\teagle\t\t\n+Offset: \t-6\tLength: \t2\tworld\teagle\tw\te\n+Offset: \t-6\tLength: \t3\tworld\teagle\two\tea\n+Offset: \t-6\tLength: \t4\tworld\teagle\twor\teag\n+Offset: \t-6\tLength: \t5\tworld\teagle\tworl\teagl\n+Offset: \t-6\tLength: \t6\tworld\teagle\tworld\teagle\n+-- Zero offset/length\n+Offset: \t0\tLength: \t0\t\t\t\t\n+Offset: \t0\tLength: \t1\t\t\t\t\n+Offset: \t1\tLength: \t0\thello\tshark\t\t\n+Offset: \t0\tLength: \t0\t\t\t\t\n+Offset: \t0\tLength: \t1\t\t\t\t\n+Offset: \t1\tLength: \t0\tworld\teagle\t\t\n+-- Constant enums\n+f\tfo\ndiff --git a/tests/queries/0_stateless/00493_substring_of_enum.sql b/tests/queries/0_stateless/00493_substring_of_enum.sql\nnew file mode 100644\nindex 000000000000..cdda76e88a7f\n--- /dev/null\n+++ b/tests/queries/0_stateless/00493_substring_of_enum.sql\n@@ -0,0 +1,32 @@\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab(e8 Enum8('hello' = -5, 'world' = 15), e16 Enum16('shark' = -999, 'eagle' = 9999)) ENGINE MergeTree ORDER BY tuple();\n+INSERT INTO TABLE tab VALUES ('hello', 'shark'), ('world', 'eagle');\n+\n+SELECT '-- Positive offsets (slice from left)';\n+WITH cte AS (SELECT number + 1 AS n FROM system.numbers LIMIT 6),\n+     permutations AS (SELECT c1.n AS offset, c2.n AS length FROM cte AS c1 CROSS JOIN cte AS c2)\n+SELECT 'Offset: ', p.offset, 'Length: ', p.length,\n+       substring(e8, p.offset) AS s1, substring(e16, p.offset) AS s2,\n+       substring(e8, p.offset, p.length) AS s3, substring(e16, p.offset, p.length) AS s4\n+FROM tab LEFT JOIN permutations AS p ON true;\n+\n+SELECT '-- Negative offsets (slice from right)';\n+WITH cte AS (SELECT number + 1 AS n FROM system.numbers LIMIT 6),\n+     permutations AS (SELECT -c1.n AS offset, c2.n AS length FROM cte AS c1 CROSS JOIN cte AS c2)\n+SELECT 'Offset: ', p.offset, 'Length: ', p.length,\n+       substring(e8, p.offset) AS s1, substring(e16, p.offset) AS s2,\n+       substring(e8, p.offset, p.length) AS s3, substring(e16, p.offset, p.length) AS s4\n+FROM tab LEFT JOIN permutations AS p ON true;\n+\n+SELECT '-- Zero offset/length';\n+WITH cte AS (SELECT number AS n FROM system.numbers LIMIT 2),\n+     permutations AS (SELECT c1.n AS offset, c2.n AS length FROM cte AS c1 CROSS JOIN cte AS c2 LIMIT 3)\n+SELECT 'Offset: ', p.offset, 'Length: ', p.length,\n+       substring(e8, p.offset) AS s1, substring(e16, p.offset) AS s2,\n+       substring(e8, p.offset, p.length) AS s3, substring(e16, p.offset, p.length) AS s4\n+FROM tab LEFT JOIN permutations AS p ON true;\n+\n+SELECT '-- Constant enums';\n+SELECT substring(CAST('foo', 'Enum8(\\'foo\\' = 1)'), 1, 1), substring(CAST('foo', 'Enum16(\\'foo\\' = 1111)'), 1, 2);\n+\n+DROP TABLE tab;\n",
  "problem_statement": "MySQL compatibility: substring with enums\nRequired by Tableau via MySQL interface.\r\n\r\nSample generated query:\r\n\r\n```sql\r\nSELECT \r\n  CONCAT(\r\n    SUBSTRING(`cell_towers`.`radio`, 1, 1024), \r\n    SUBSTRING(`cell_towers`.`radio`, 1, 1024)\r\n  ) AS `Calculation_3276650229452562433`\r\nFROM `cell_towers`\r\nGROUP BY 1\r\n```\r\n\r\nSimplified:\r\n\r\n```sql\r\nSELECT substring(CAST('foo', 'Enum(\\'foo\\' = 1)'), 1, 1000)\r\n```\r\n\r\nfails with \r\n\r\n```\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Illegal type Enum8('foo' = 1) of argument of function substring: While processing substring(CAST('foo', 'Enum(\\'foo\\' = 1)'), 1, 1000). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\n**Expected behavior**\r\n\r\nTreat enums as strings when calling the `substring` function.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: latest\n",
  "hints_text": "",
  "created_at": "2023-11-27T23:09:54Z",
  "modified_files": [
    "docs/en/sql-reference/functions/string-functions.md",
    "src/DataTypes/IDataType.h",
    "src/Functions/GatherUtils/Sources.h",
    "src/Functions/substring.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/00493_substring_of_enum.reference",
    "b/tests/queries/0_stateless/00493_substring_of_enum.sql"
  ]
}