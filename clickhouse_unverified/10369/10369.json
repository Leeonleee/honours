{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10369,
  "instance_id": "ClickHouse__ClickHouse-10369",
  "issue_numbers": [
    "7202"
  ],
  "base_commit": "c7d0625d0215971359a430d2a48a90db62378e0f",
  "patch": "diff --git a/base/common/DateLUTImpl.h b/base/common/DateLUTImpl.h\nindex ec32d62bcadd..cb41d2ef1c1e 100644\n--- a/base/common/DateLUTImpl.h\n+++ b/base/common/DateLUTImpl.h\n@@ -99,7 +99,7 @@ class DateLUTImpl\n             return guess;\n \n         /// Time zones that have offset 0 from UTC do daylight saving time change (if any) towards increasing UTC offset (example: British Standard Time).\n-        if (offset_at_start_of_epoch >= 0)\n+        if (t >= lut[DayNum(guess + 1)].date)\n             return DayNum(guess + 1);\n \n         return DayNum(guess - 1);\n@@ -579,7 +579,7 @@ class DateLUTImpl\n             return t / 3600;\n \n         /// Assume that if offset was fractional, then the fraction is the same as at the beginning of epoch.\n-        /// NOTE This assumption is false for \"Pacific/Pitcairn\" time zone.\n+        /// NOTE This assumption is false for \"Pacific/Pitcairn\" and \"Pacific/Kiritimati\" time zones.\n         return (t + 86400 - offset_at_start_of_epoch) / 3600;\n     }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01252_weird_time_zone.reference b/tests/queries/0_stateless/01252_weird_time_zone.reference\nnew file mode 100644\nindex 000000000000..f2968d4efa60\n--- /dev/null\n+++ b/tests/queries/0_stateless/01252_weird_time_zone.reference\n@@ -0,0 +1,7 @@\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\n+2020-01-02 03:04:05\t2020-01-02 00:00:00\t3\ndiff --git a/tests/queries/0_stateless/01252_weird_time_zone.sql b/tests/queries/0_stateless/01252_weird_time_zone.sql\nnew file mode 100644\nindex 000000000000..68ea903a7975\n--- /dev/null\n+++ b/tests/queries/0_stateless/01252_weird_time_zone.sql\n@@ -0,0 +1,15 @@\n+SELECT toDateTime('2020-01-02 03:04:05', 'Pacific/Kiritimati') AS x, toStartOfDay(x), toHour(x);\n+SELECT toDateTime('2020-01-02 03:04:05', 'Africa/El_Aaiun') AS x, toStartOfDay(x), toHour(x);\n+SELECT toDateTime('2020-01-02 03:04:05', 'Asia/Pyongyang') AS x, toStartOfDay(x), toHour(x);\n+SELECT toDateTime('2020-01-02 03:04:05', 'Pacific/Kwajalein') AS x, toStartOfDay(x), toHour(x);\n+SELECT toDateTime('2020-01-02 03:04:05', 'Pacific/Apia') AS x, toStartOfDay(x), toHour(x);\n+SELECT toDateTime('2020-01-02 03:04:05', 'Pacific/Enderbury') AS x, toStartOfDay(x), toHour(x);\n+SELECT toDateTime('2020-01-02 03:04:05', 'Pacific/Fakaofo') AS x, toStartOfDay(x), toHour(x);\n+\n+SELECT toHour(toDateTime(rand(), 'Pacific/Kiritimati') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n+SELECT toHour(toDateTime(rand(), 'Africa/El_Aaiun') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n+SELECT toHour(toDateTime(rand(), 'Asia/Pyongyang') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n+SELECT toHour(toDateTime(rand(), 'Pacific/Kwajalein') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n+SELECT toHour(toDateTime(rand(), 'Pacific/Apia') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n+SELECT toHour(toDateTime(rand(), 'Pacific/Enderbury') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n+SELECT toHour(toDateTime(rand(), 'Pacific/Fakaofo') AS t) AS h, t FROM numbers(1000000) WHERE h < 0 OR h > 23 ORDER BY h LIMIT 1 BY h;\n",
  "problem_statement": "TimeZone Coversion Faulty\nTimeZone Conversion is returning wrong time zone for many timezones.\r\nExample : This works fine \r\n\r\n`SELECT    now() AS now_local,    toDateTime(now(), 'Asia/Yekaterinburg') AS new_time;\r\n\r\n```\r\n\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now_local\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500new_time\u2500\u2510\r\n\u2502 2019-10-05 15:58:15 \u2502 2019-10-05 20:58:15 \u2502\r\n```\r\n\r\nBut if i use other timezones like Pacific/Kiritimati , Pacific/Fakaofo gives completely wrong result\r\n\r\n```\r\nSELECT    now() AS now_local,    toDateTime(now(), 'Pacific/Kiritimati') AS new_time;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now_local\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500new_time\u2500\u2510\r\n\u2502 2019-10-05 15:59:58 \u2502 2019-10-04 53:59:58 \u2502\r\n\r\n`\r\n```\r\nthe above query converted Hour to 53 lol\r\n\r\nI am using click house version - 19.9.5\n",
  "hints_text": "On further experiment i found the following timezones fails to provide expected result\r\n\r\n```\r\nAfrica/El_Aaiun\r\nAsia/Pyongyang\r\nPacific/Kwajalein\r\nPacific/Apia\r\nPacific/Enderbury\r\nPacific/Fakaofo\r\nPacific/Kiritimati\r\n```\r\n\r\n  on the queries like these : \r\n\r\n`select toStartOfDay(createdtimestr , 'Africa/El_Aaiun' ) AS timestring,count() AS clicks from clicks final where like(lower(nid),lower('210'))!= 0 and ( createdtimestr between '2019-10-05 00:00:00' and '2019-10-08 23:59:59' ) group by timestring order by timestring asc`\r\n\nTemporary solution:\r\n`addHours(now(), 14)`\nIt happens for time zones that have offset changed between positive and negative.",
  "created_at": "2020-04-20T07:11:57Z",
  "modified_files": [
    "base/common/DateLUTImpl.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01252_weird_time_zone.reference",
    "b/tests/queries/0_stateless/01252_weird_time_zone.sql"
  ]
}