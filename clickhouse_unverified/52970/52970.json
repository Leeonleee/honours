{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52970,
  "instance_id": "ClickHouse__ClickHouse-52970",
  "issue_numbers": [
    "49304"
  ],
  "base_commit": "376eeeb8422c8e356c2f0d9fb894cb7c492dba99",
  "patch": "diff --git a/docs/en/operations/backup.md b/docs/en/operations/backup.md\nindex 63bf3cfeb5c8..c3545a778b76 100644\n--- a/docs/en/operations/backup.md\n+++ b/docs/en/operations/backup.md\n@@ -84,6 +84,7 @@ The BACKUP and RESTORE statements take a list of DATABASE and TABLE names, a des\n     - `password` for the file on disk\n     - `base_backup`: the destination of the previous backup of this source.  For example, `Disk('backups', '1.zip')`\n     - `structure_only`: if enabled, allows to only backup or restore the CREATE statements without the data of tables\n+    - `storage_policy`: storage policy for the tables being restored. See [Using Multiple Block Devices for Data Storage](../engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-multiple-volumes). This setting is only applicable to the `RESTORE` command. The specified storage policy applies only to tables with an engine from the `MergeTree` family.\n     - `s3_storage_class`: the storage class used for S3 backup. For example, `STANDARD`\n \n ### Usage examples\ndiff --git a/src/Backups/RestoreSettings.cpp b/src/Backups/RestoreSettings.cpp\nindex 2009ca4c1ffa..3290e5112c00 100644\n--- a/src/Backups/RestoreSettings.cpp\n+++ b/src/Backups/RestoreSettings.cpp\n@@ -8,6 +8,7 @@\n #include <boost/algorithm/string/predicate.hpp>\n #include <Common/FieldVisitorConvertToNumber.h>\n #include <Backups/SettingsFieldOptionalUUID.h>\n+#include <Backups/SettingsFieldOptionalString.h>\n \n \n namespace DB\n@@ -164,6 +165,7 @@ namespace\n     M(Bool, allow_s3_native_copy) \\\n     M(Bool, internal) \\\n     M(String, host_id) \\\n+    M(OptionalString, storage_policy) \\\n     M(OptionalUUID, restore_uuid)\n \n \ndiff --git a/src/Backups/RestoreSettings.h b/src/Backups/RestoreSettings.h\nindex 1861e219dba9..788dcdb28d33 100644\n--- a/src/Backups/RestoreSettings.h\n+++ b/src/Backups/RestoreSettings.h\n@@ -117,6 +117,9 @@ struct RestoreSettings\n     /// The current host's ID in the format 'escaped_host_name:port'.\n     String host_id;\n \n+    /// Alternative storage policy that may be specified in the SETTINGS clause of RESTORE queries\n+    std::optional<String> storage_policy;\n+\n     /// Internal, should not be specified by user.\n     /// Cluster's hosts' IDs in the format 'escaped_host_name:port' for all shards and replicas in a cluster specified in BACKUP ON CLUSTER.\n     std::vector<Strings> cluster_host_ids;\ndiff --git a/src/Backups/RestorerFromBackup.cpp b/src/Backups/RestorerFromBackup.cpp\nindex 7981cc2f19f5..8a0908c6b679 100644\n--- a/src/Backups/RestorerFromBackup.cpp\n+++ b/src/Backups/RestorerFromBackup.cpp\n@@ -322,6 +322,7 @@ void RestorerFromBackup::findTableInBackup(const QualifiedTableName & table_name\n     read_buffer.reset();\n     ParserCreateQuery create_parser;\n     ASTPtr create_table_query = parseQuery(create_parser, create_query_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n+    applyCustomStoragePolicy(create_table_query);\n     renameDatabaseAndTableNameInCreateQuery(create_table_query, renaming_map, context->getGlobalContext());\n \n     QualifiedTableName table_name = renaming_map.getNewTableName(table_name_in_backup);\n@@ -625,6 +626,24 @@ void RestorerFromBackup::checkDatabase(const String & database_name)\n     }\n }\n \n+void RestorerFromBackup::applyCustomStoragePolicy(ASTPtr query_ptr)\n+{\n+    constexpr auto setting_name = \"storage_policy\";\n+    if (query_ptr && restore_settings.storage_policy.has_value())\n+    {\n+        ASTStorage * storage = query_ptr->as<ASTCreateQuery &>().storage;\n+        if (storage && storage->settings)\n+        {\n+            if (restore_settings.storage_policy.value().empty())\n+                /// it has been set to \"\" deliberately, so the source storage policy is erased\n+                storage->settings->changes.removeSetting(setting_name);\n+            else\n+                /// it has been set to a custom value, so it either overwrites the existing value or is added as a new one\n+                storage->settings->changes.setSetting(setting_name, restore_settings.storage_policy.value());\n+        }\n+    }\n+}\n+\n void RestorerFromBackup::removeUnresolvedDependencies()\n {\n     auto need_exclude_dependency = [this](const StorageID & table_id)\ndiff --git a/src/Backups/RestorerFromBackup.h b/src/Backups/RestorerFromBackup.h\nindex 93b5a6c76940..194478bd8b4a 100644\n--- a/src/Backups/RestorerFromBackup.h\n+++ b/src/Backups/RestorerFromBackup.h\n@@ -95,6 +95,8 @@ class RestorerFromBackup : private boost::noncopyable\n     void createDatabase(const String & database_name) const;\n     void checkDatabase(const String & database_name);\n \n+    void applyCustomStoragePolicy(ASTPtr query_ptr);\n+\n     void removeUnresolvedDependencies();\n     void createTables();\n     void createTable(const QualifiedTableName & table_name);\ndiff --git a/src/Backups/SettingsFieldOptionalString.cpp b/src/Backups/SettingsFieldOptionalString.cpp\nnew file mode 100644\nindex 000000000000..573fd1e052c0\n--- /dev/null\n+++ b/src/Backups/SettingsFieldOptionalString.cpp\n@@ -0,0 +1,29 @@\n+#include <Backups/SettingsFieldOptionalString.h>\n+#include <Common/ErrorCodes.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_PARSE_BACKUP_SETTINGS;\n+}\n+\n+SettingFieldOptionalString::SettingFieldOptionalString(const Field & field)\n+{\n+    if (field.getType() == Field::Types::Null)\n+    {\n+        value = std::nullopt;\n+        return;\n+    }\n+\n+    if (field.getType() == Field::Types::String)\n+    {\n+        value = field.get<const String &>();\n+        return;\n+    }\n+\n+    throw Exception(ErrorCodes::CANNOT_PARSE_BACKUP_SETTINGS, \"Cannot get string from {}\", field);\n+}\n+\n+}\ndiff --git a/src/Backups/SettingsFieldOptionalString.h b/src/Backups/SettingsFieldOptionalString.h\nnew file mode 100644\nindex 000000000000..e76c979e4ad7\n--- /dev/null\n+++ b/src/Backups/SettingsFieldOptionalString.h\n@@ -0,0 +1,20 @@\n+#pragma once\n+\n+#include <optional>\n+#include <Core/SettingsFields.h>\n+\n+namespace DB\n+{\n+\n+struct SettingFieldOptionalString\n+{\n+    std::optional<String> value;\n+\n+    explicit SettingFieldOptionalString(const std::optional<String> & value_) : value(value_) {}\n+\n+    explicit SettingFieldOptionalString(const Field & field);\n+\n+    explicit operator Field() const { return Field(value ? toString(*value) : \"\"); }\n+};\n+\n+}\n",
  "test_patch": "diff --git a/tests/integration/test_backup_restore_storage_policy/__init__.py b/tests/integration/test_backup_restore_storage_policy/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_backup_restore_storage_policy/configs/storage_config.xml b/tests/integration/test_backup_restore_storage_policy/configs/storage_config.xml\nnew file mode 100644\nindex 000000000000..de9f68cbe870\n--- /dev/null\n+++ b/tests/integration/test_backup_restore_storage_policy/configs/storage_config.xml\n@@ -0,0 +1,33 @@\n+<clickhouse>\n+    <storage_configuration>\n+        <disks>\n+            <one>\n+                <type>local</type>\n+                <path>/var/lib/disks/one/</path>\n+            </one>\n+            <two>\n+                <type>local</type>\n+                <path>/var/lib/disks/two/</path>\n+            </two>\n+        </disks>\n+        <policies>\n+            <policy1>\n+                <volumes>\n+                    <single>\n+                        <disk>one</disk>\n+                    </single>\n+                </volumes>\n+            </policy1>\n+            <policy2>\n+                <volumes>\n+                    <single>\n+                        <disk>two</disk>\n+                    </single>\n+                </volumes>\n+            </policy2>\n+        </policies>\n+    </storage_configuration>\n+    <backups>\n+        <allowed_path>/backups</allowed_path>\n+    </backups>\n+</clickhouse>\ndiff --git a/tests/integration/test_backup_restore_storage_policy/test.py b/tests/integration/test_backup_restore_storage_policy/test.py\nnew file mode 100644\nindex 000000000000..4e9d309a2205\n--- /dev/null\n+++ b/tests/integration/test_backup_restore_storage_policy/test.py\n@@ -0,0 +1,76 @@\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+\n+\n+backup_id_counter = 0\n+\n+cluster = ClickHouseCluster(__file__)\n+\n+instance = cluster.add_instance(\n+    \"instance\",\n+    main_configs=[\"configs/storage_config.xml\"],\n+)\n+\n+\n+@pytest.fixture(scope=\"module\", autouse=True)\n+def start_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+@pytest.fixture(autouse=True)\n+def cleanup_after_test():\n+    try:\n+        yield\n+    finally:\n+        instance.query(\"DROP DATABASE IF EXISTS test\")\n+\n+\n+def new_backup_name():\n+    global backup_id_counter\n+    backup_id_counter += 1\n+    return f\"File('/backups/{backup_id_counter}/')\"\n+\n+\n+def create_table_backup(backup_name, storage_policy=None):\n+    instance.query(\"CREATE DATABASE test\")\n+    create_query = \"CREATE TABLE test.table(x UInt32) ENGINE=MergeTree ORDER BY x\"\n+    if storage_policy is not None:\n+        create_query += f\" SETTINGS storage_policy = '{storage_policy}'\"\n+    instance.query(create_query)\n+    instance.query(f\"INSERT INTO test.table SELECT number FROM numbers(10)\")\n+    instance.query(f\"BACKUP TABLE test.table TO {backup_name}\")\n+    instance.query(\"DROP TABLE test.table SYNC\")\n+\n+\n+def restore_table(backup_name, storage_policy=None):\n+    restore_query = f\"RESTORE TABLE test.table FROM {backup_name}\"\n+    if storage_policy is not None:\n+        restore_query += f\" SETTINGS storage_policy = '{storage_policy}'\"\n+    instance.query(restore_query)\n+\n+\n+@pytest.mark.parametrize(\n+    \"origin_policy, restore_policy, expected_policy\",\n+    [\n+        (None, \"\", \"default\"),\n+        (None, None, \"default\"),\n+        (None, \"policy1\", \"policy1\"),\n+        (\"policy1\", \"policy1\", \"policy1\"),\n+        (\"policy1\", \"policy2\", \"policy2\"),\n+        (\"policy1\", \"\", \"default\"),\n+        (\"policy1\", None, \"policy1\"),\n+    ],\n+)\n+def test_storage_policies(origin_policy, restore_policy, expected_policy):\n+    backup_name = new_backup_name()\n+    create_table_backup(backup_name, origin_policy)\n+    restore_table(backup_name, restore_policy)\n+\n+    assert (\n+        instance.query(\"SELECT storage_policy FROM system.tables WHERE name='table'\")\n+        == f\"{expected_policy}\\n\"\n+    )\n",
  "problem_statement": "RESTORE TABLE db.table SETTINGS ... (use different storage policy for restore of backup)\n**Use case**\r\n\r\nCurrently during backup restore, it's allow you to restore table as is, with source storage policy.\r\nBut it's not always desired behavior, for example if you have tiered storage, during RESTORE TABLE, ClickHouse tries to reserve space in storage policy according to volume order only, and not TTL policy. So old parts can land on local disk instead of s3.\r\n\r\nIn order to avoid pollution of local disk with old data, it would be good to have ability to restore data to another storage policy.\r\nFor example, one which will have only s3 disk. (It also make restore much more faster, ie data needs to be copied from s3 to s3)\r\n\r\n**Describe the solution you'd like**\r\n\r\nRESTORE TABLE db.table SETTINGS storage_policy='s3'; FROM Backup ....\r\n\r\n\n",
  "hints_text": "Related https://github.com/ClickHouse/ClickHouse/issues/39199\nPlease assign me to this task, I'm starting to work on it.",
  "created_at": "2023-08-03T09:00:59Z"
}