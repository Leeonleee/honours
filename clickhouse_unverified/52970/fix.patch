diff --git a/docs/en/operations/backup.md b/docs/en/operations/backup.md
index 63bf3cfeb5c8..c3545a778b76 100644
--- a/docs/en/operations/backup.md
+++ b/docs/en/operations/backup.md
@@ -84,6 +84,7 @@ The BACKUP and RESTORE statements take a list of DATABASE and TABLE names, a des
     - `password` for the file on disk
     - `base_backup`: the destination of the previous backup of this source.  For example, `Disk('backups', '1.zip')`
     - `structure_only`: if enabled, allows to only backup or restore the CREATE statements without the data of tables
+    - `storage_policy`: storage policy for the tables being restored. See [Using Multiple Block Devices for Data Storage](../engines/table-engines/mergetree-family/mergetree.md#table_engine-mergetree-multiple-volumes). This setting is only applicable to the `RESTORE` command. The specified storage policy applies only to tables with an engine from the `MergeTree` family.
     - `s3_storage_class`: the storage class used for S3 backup. For example, `STANDARD`
 
 ### Usage examples
diff --git a/src/Backups/RestoreSettings.cpp b/src/Backups/RestoreSettings.cpp
index 2009ca4c1ffa..3290e5112c00 100644
--- a/src/Backups/RestoreSettings.cpp
+++ b/src/Backups/RestoreSettings.cpp
@@ -8,6 +8,7 @@
 #include <boost/algorithm/string/predicate.hpp>
 #include <Common/FieldVisitorConvertToNumber.h>
 #include <Backups/SettingsFieldOptionalUUID.h>
+#include <Backups/SettingsFieldOptionalString.h>
 
 
 namespace DB
@@ -164,6 +165,7 @@ namespace
     M(Bool, allow_s3_native_copy) \
     M(Bool, internal) \
     M(String, host_id) \
+    M(OptionalString, storage_policy) \
     M(OptionalUUID, restore_uuid)
 
 
diff --git a/src/Backups/RestoreSettings.h b/src/Backups/RestoreSettings.h
index 1861e219dba9..788dcdb28d33 100644
--- a/src/Backups/RestoreSettings.h
+++ b/src/Backups/RestoreSettings.h
@@ -117,6 +117,9 @@ struct RestoreSettings
     /// The current host's ID in the format 'escaped_host_name:port'.
     String host_id;
 
+    /// Alternative storage policy that may be specified in the SETTINGS clause of RESTORE queries
+    std::optional<String> storage_policy;
+
     /// Internal, should not be specified by user.
     /// Cluster's hosts' IDs in the format 'escaped_host_name:port' for all shards and replicas in a cluster specified in BACKUP ON CLUSTER.
     std::vector<Strings> cluster_host_ids;
diff --git a/src/Backups/RestorerFromBackup.cpp b/src/Backups/RestorerFromBackup.cpp
index 7981cc2f19f5..8a0908c6b679 100644
--- a/src/Backups/RestorerFromBackup.cpp
+++ b/src/Backups/RestorerFromBackup.cpp
@@ -322,6 +322,7 @@ void RestorerFromBackup::findTableInBackup(const QualifiedTableName & table_name
     read_buffer.reset();
     ParserCreateQuery create_parser;
     ASTPtr create_table_query = parseQuery(create_parser, create_query_str, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);
+    applyCustomStoragePolicy(create_table_query);
     renameDatabaseAndTableNameInCreateQuery(create_table_query, renaming_map, context->getGlobalContext());
 
     QualifiedTableName table_name = renaming_map.getNewTableName(table_name_in_backup);
@@ -625,6 +626,24 @@ void RestorerFromBackup::checkDatabase(const String & database_name)
     }
 }
 
+void RestorerFromBackup::applyCustomStoragePolicy(ASTPtr query_ptr)
+{
+    constexpr auto setting_name = "storage_policy";
+    if (query_ptr && restore_settings.storage_policy.has_value())
+    {
+        ASTStorage * storage = query_ptr->as<ASTCreateQuery &>().storage;
+        if (storage && storage->settings)
+        {
+            if (restore_settings.storage_policy.value().empty())
+                /// it has been set to "" deliberately, so the source storage policy is erased
+                storage->settings->changes.removeSetting(setting_name);
+            else
+                /// it has been set to a custom value, so it either overwrites the existing value or is added as a new one
+                storage->settings->changes.setSetting(setting_name, restore_settings.storage_policy.value());
+        }
+    }
+}
+
 void RestorerFromBackup::removeUnresolvedDependencies()
 {
     auto need_exclude_dependency = [this](const StorageID & table_id)
diff --git a/src/Backups/RestorerFromBackup.h b/src/Backups/RestorerFromBackup.h
index 93b5a6c76940..194478bd8b4a 100644
--- a/src/Backups/RestorerFromBackup.h
+++ b/src/Backups/RestorerFromBackup.h
@@ -95,6 +95,8 @@ class RestorerFromBackup : private boost::noncopyable
     void createDatabase(const String & database_name) const;
     void checkDatabase(const String & database_name);
 
+    void applyCustomStoragePolicy(ASTPtr query_ptr);
+
     void removeUnresolvedDependencies();
     void createTables();
     void createTable(const QualifiedTableName & table_name);
diff --git a/src/Backups/SettingsFieldOptionalString.cpp b/src/Backups/SettingsFieldOptionalString.cpp
new file mode 100644
index 000000000000..573fd1e052c0
--- /dev/null
+++ b/src/Backups/SettingsFieldOptionalString.cpp
@@ -0,0 +1,29 @@
+#include <Backups/SettingsFieldOptionalString.h>
+#include <Common/ErrorCodes.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int CANNOT_PARSE_BACKUP_SETTINGS;
+}
+
+SettingFieldOptionalString::SettingFieldOptionalString(const Field & field)
+{
+    if (field.getType() == Field::Types::Null)
+    {
+        value = std::nullopt;
+        return;
+    }
+
+    if (field.getType() == Field::Types::String)
+    {
+        value = field.get<const String &>();
+        return;
+    }
+
+    throw Exception(ErrorCodes::CANNOT_PARSE_BACKUP_SETTINGS, "Cannot get string from {}", field);
+}
+
+}
diff --git a/src/Backups/SettingsFieldOptionalString.h b/src/Backups/SettingsFieldOptionalString.h
new file mode 100644
index 000000000000..e76c979e4ad7
--- /dev/null
+++ b/src/Backups/SettingsFieldOptionalString.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <optional>
+#include <Core/SettingsFields.h>
+
+namespace DB
+{
+
+struct SettingFieldOptionalString
+{
+    std::optional<String> value;
+
+    explicit SettingFieldOptionalString(const std::optional<String> & value_) : value(value_) {}
+
+    explicit SettingFieldOptionalString(const Field & field);
+
+    explicit operator Field() const { return Field(value ? toString(*value) : ""); }
+};
+
+}
