{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37849,
  "instance_id": "ClickHouse__ClickHouse-37849",
  "issue_numbers": [
    "37651"
  ],
  "base_commit": "a09422de7b8072454ac4f6f951ea13debc7b90b1",
  "patch": "diff --git a/src/Core/SortDescription.h b/src/Core/SortDescription.h\nindex 730a64b77ad8..6c19ce361157 100644\n--- a/src/Core/SortDescription.h\n+++ b/src/Core/SortDescription.h\n@@ -28,7 +28,9 @@ struct FillColumnDescription\n     /// All missed values in range [FROM, TO) will be filled\n     /// Range [FROM, TO) respects sorting direction\n     Field fill_from;        /// Fill value >= FILL_FROM\n+    DataTypePtr fill_from_type;\n     Field fill_to;          /// Fill value + STEP < FILL_TO\n+    DataTypePtr fill_to_type;\n     Field fill_step;        /// Default = +1 or -1 according to direction\n     std::optional<IntervalKind> step_kind;\n \ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex a05d353ac733..9faf91f7a43a 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -825,14 +825,15 @@ Block InterpreterSelectQuery::getSampleBlockImpl()\n     return analysis_result.final_projection->getResultColumns();\n }\n \n-static Field getWithFillFieldValue(const ASTPtr & node, const ContextPtr & context)\n+\n+static std::pair<Field, DataTypePtr> getWithFillFieldValue(const ASTPtr & node, ContextPtr context)\n {\n-    auto [field, type] = evaluateConstantExpression(node, context);\n+    auto field_type = evaluateConstantExpression(node, context);\n \n-    if (!isColumnedAsNumber(type))\n-        throw Exception(\"Illegal type \" + type->getName() + \" of WITH FILL expression, must be numeric type\", ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n+    if (!isColumnedAsNumber(field_type.second))\n+        throw Exception(\"Illegal type \" + field_type.second->getName() + \" of WITH FILL expression, must be numeric type\", ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n \n-    return field;\n+    return field_type;\n }\n \n static std::pair<Field, std::optional<IntervalKind>> getWithFillStep(const ASTPtr & node, const ContextPtr & context)\n@@ -853,9 +854,9 @@ static FillColumnDescription getWithFillDescription(const ASTOrderByElement & or\n     FillColumnDescription descr;\n \n     if (order_by_elem.fill_from)\n-        descr.fill_from = getWithFillFieldValue(order_by_elem.fill_from, context);\n+        std::tie(descr.fill_from, descr.fill_from_type) = getWithFillFieldValue(order_by_elem.fill_from, context);\n     if (order_by_elem.fill_to)\n-        descr.fill_to = getWithFillFieldValue(order_by_elem.fill_to, context);\n+        std::tie(descr.fill_to, descr.fill_to_type) = getWithFillFieldValue(order_by_elem.fill_to, context);\n \n     if (order_by_elem.fill_step)\n         std::tie(descr.fill_step, descr.step_kind) = getWithFillStep(order_by_elem.fill_step, context);\ndiff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp\nindex b63e1dda084e..311c88e46e8d 100644\n--- a/src/Processors/Transforms/FillingTransform.cpp\n+++ b/src/Processors/Transforms/FillingTransform.cpp\n@@ -54,6 +54,23 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &\n     WhichDataType which(type);\n     DataTypePtr to_type;\n \n+    /// For Date/DateTime types TO/FROM type should match column type\n+    if (descr.fill_from_type)\n+    {\n+        WhichDataType which_from(descr.fill_from_type);\n+        if ((which_from.isDateOrDate32() || which_from.isDateTime() || which_from.isDateTime64()) &&\n+            !descr.fill_from_type->equals(*type))\n+                return false;\n+    }\n+\n+    if (descr.fill_to_type)\n+    {\n+        WhichDataType which_to(descr.fill_to_type);\n+        if ((which_to.isDateOrDate32() || which_to.isDateTime() || which_to.isDateTime64()) &&\n+            !descr.fill_to_type->equals(*type))\n+                return false;\n+    }\n+\n     /// TODO Wrong results for big integers.\n     if (isInteger(type) || which.isDate() || which.isDate32() || which.isDateTime())\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02366_with_fill_date.reference b/tests/queries/0_stateless/02366_with_fill_date.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02366_with_fill_date.sql b/tests/queries/0_stateless/02366_with_fill_date.sql\nnew file mode 100644\nindex 000000000000..64e23b845f8d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_with_fill_date.sql\n@@ -0,0 +1,6 @@\n+-- Tags: no-backward-compatibility-check\n+\n+SELECT toDate('2022-02-01') AS d1\n+FROM numbers(18) AS number\n+ORDER BY d1 ASC WITH FILL FROM toDateTime('2022-02-01') TO toDateTime('2022-07-01') STEP toIntervalMonth(1); -- { serverError 475 }\n+\n",
  "problem_statement": "Timeout exception for query with ORDER BY WITH FILL\nHi there, it seems that the combination of `ORDER BY WITH FILL`, `FROM TO` and `STEP INTERVAL` is causing the query to hang and eventually to timeout (ignoring session timeout limit). \r\n\r\nSometimes the server hangs after few such queries and don't respond to KILL signal (had to restart the VM).\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nSELECT \r\n    count() AS value,\r\n    toStartOfMonth(d1) AS date\r\nFROM (\r\n    SELECT\r\n        timestamp_add(toDateTime('2022-02-01'), INTERVAL number WEEK) AS d1\r\n    FROM numbers(18) AS number\r\n)\r\nGROUP BY date\r\nORDER BY\r\n    date\r\n        WITH FILL \r\n        FROM toDateTime('2022-02-01')\r\n        TO toDateTime('2022-06-01')\r\n        STEP INTERVAL 1 MONTH\r\n```\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\n2022.05.30 12:24:11.784134 [ 45 ] {c3091464-f1ce-4657-8498-ba67743dac1c} <Error> executeQuery: Code: 159. DB::Exception: Timeout exceeded: elapsed 38.329806547 seconds, maximum: 5. (TIMEOUT_EXCEEDED) (version 22.5.1.2079 (official build)) (from 172.17.0.1:61118) (in query:  SELECT count() AS value, toStartOfMonth(d1) AS date FROM ( SELECT timestamp_add(toDateTime('2022-02-01'), INTERVAL number WEEK) AS d1 FROM numbers(18) AS number ) GROUP BY date ORDER BY date WITH FILL FROM toDateTime('2022-02-01') TO toDateTime('2022-06-01') STEP INTERVAL 1 MONTH FORMAT JSON ), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xb4903fa in /usr/bin/clickhouse\r\n1. DB::Exception::Exception<double, double>(int, fmt::v8::basic_format_string<char, fmt::v8::type_identity<double>::type, fmt::v8::type_identity<double>::type>, double&&, double&&) @ 0x15e7ebec in /usr/bin/clickhouse\r\n2. DB::ExecutionSpeedLimits::checkTimeLimit(Stopwatch const&, DB::OverflowMode) const @ 0x15e7eacc in /usr/bin/clickhouse\r\n3. DB::PipelineExecutor::finalizeExecution() @ 0x16d0c2a2 in /usr/bin/clickhouse\r\n4. DB::CompletedPipelineExecutor::execute() @ 0x16d0a204 in /usr/bin/clickhouse\r\n5. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x160dbc33 in /usr/bin/clickhouse\r\n6. DB::HTTPHandler::processQuery(DB::HTTPServerRequest&, DB::HTMLForm&, DB::HTTPServerResponse&, DB::HTTPHandler::Output&, std::__1::optional<DB::CurrentThread::QueryScope>&) @ 0x16a42871 in /usr/bin/clickhouse\r\n7. DB::HTTPHandler::handleRequest(DB::HTTPServerRequest&, DB::HTTPServerResponse&) @ 0x16a46f22 in /usr/bin/clickhouse\r\n8. DB::HTTPServerConnection::run() @ 0x16ccddf3 in /usr/bin/clickhouse\r\n9. Poco::Net::TCPServerConnection::start() @ 0x1b0bbc2f in /usr/bin/clickhouse\r\n10. Poco::Net::TCPServerDispatcher::run() @ 0x1b0be081 in /usr/bin/clickhouse\r\n11. Poco::PooledThread::run() @ 0x1b284169 in /usr/bin/clickhouse\r\n12. Poco::ThreadImpl::runnableEntry(void*) @ 0x1b2814c0 in /usr/bin/clickhouse\r\n13. ? @ 0x7f4927458609 in ?\r\n14. __clone @ 0x7f492737d133 in ?\r\n\r\n2022.05.30 12:24:11.784437 [ 45 ] {c3091464-f1ce-4657-8498-ba67743dac1c} <Error> DynamicQueryHandler: Code: 159. DB::Exception: Timeout exceeded: elapsed 38.329806547 seconds, maximum: 5. (TIMEOUT_EXCEEDED), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xb4903fa in /usr/bin/clickhouse\r\n1. DB::Exception::Exception<double, double>(int, fmt::v8::basic_format_string<char, fmt::v8::type_identity<double>::type, fmt::v8::type_identity<double>::type>, double&&, double&&) @ 0x15e7ebec in /usr/bin/clickhouse\r\n2. DB::ExecutionSpeedLimits::checkTimeLimit(Stopwatch const&, DB::OverflowMode) const @ 0x15e7eacc in /usr/bin/clickhouse\r\n3. DB::PipelineExecutor::finalizeExecution() @ 0x16d0c2a2 in /usr/bin/clickhouse\r\n4. DB::CompletedPipelineExecutor::execute() @ 0x16d0a204 in /usr/bin/clickhouse\r\n5. DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&)>, std::__1::optional<DB::FormatSettings> const&) @ 0x160dbc33 in /usr/bin/clickhouse\r\n6. DB::HTTPHandler::processQuery(DB::HTTPServerRequest&, DB::HTMLForm&, DB::HTTPServerResponse&, DB::HTTPHandler::Output&, std::__1::optional<DB::CurrentThread::QueryScope>&) @ 0x16a42871 in /usr/bin/clickhouse\r\n7. DB::HTTPHandler::handleRequest(DB::HTTPServerRequest&, DB::HTTPServerResponse&) @ 0x16a46f22 in /usr/bin/clickhouse\r\n8. DB::HTTPServerConnection::run() @ 0x16ccddf3 in /usr/bin/clickhouse\r\n9. Poco::Net::TCPServerConnection::start() @ 0x1b0bbc2f in /usr/bin/clickhouse\r\n10. Poco::Net::TCPServerDispatcher::run() @ 0x1b0be081 in /usr/bin/clickhouse\r\n11. Poco::PooledThread::run() @ 0x1b284169 in /usr/bin/clickhouse\r\n12. Poco::ThreadImpl::runnableEntry(void*) @ 0x1b2814c0 in /usr/bin/clickhouse\r\n13. ? @ 0x7f4927458609 in ?\r\n14. __clone @ 0x7f492737d133 in ?\r\n (version 22.5.1.2079 (official build))\r\n```\r\n\r\n**Additional context**\r\n\r\nI'm running latest stable version (22.5.1.2079) as a docker container on my laptop with default settings. but was able to reproduce it in play.clickhouse.com as well (sorry if it crashed anything \ud83d\ude48)\n",
  "hints_text": "It seems that the `toStartOfMonth` function  (or any function that is working on this date) also has something to do with the issue, moving `WITH FILL` to subquery doesn't result with timeout:\r\n\r\n```sql\r\nSELECT \r\n    count() AS value,\r\n    toStartOfMonth(d1) AS date\r\nFROM (\r\n    SELECT\r\n        timestamp_add(toDateTime('2022-02-01'), INTERVAL number WEEK) AS d1\r\n    FROM numbers(18) AS number\r\n    ORDER BY d1\r\n        WITH FILL \r\n        FROM toDateTime('2022-02-01')\r\n        TO toDateTime('2022-07-01')\r\n        STEP INTERVAL 1 MONTH\r\n)\r\nGROUP BY date\r\n```\nThis bug is due to types inconsistency between selected column and filling values - toStartOfMonth returns Date, but WITH FILL operates on DateTime - it should work in this case if toDate is used in WITH FILL.\r\nAlso, I found that inside WITH FILL expression such inconsistency also exists and can results in some strange behavior.\nThanks for the reply! That makes a lot of sense now, so simple cast `toDateTime` of `toStartOfMonth` will fix it eg \r\n\r\n```diff\r\nSELECT \r\n    count() AS value,\r\n-   toStartOfMonth(d1) AS date\r\n+   toDateTime(toStartOfMonth(d1)) AS date\r\nFROM (\r\n    SELECT\r\n        timestamp_add(toDateTime('2022-02-01'), INTERVAL number WEEK) AS d1\r\n    FROM numbers(18) AS number\r\n)\r\nGROUP BY date\r\nORDER BY\r\n    date\r\n        WITH FILL \r\n        FROM toDateTime('2022-02-01')\r\n        TO toDateTime('2022-06-01')\r\n        STEP INTERVAL 1 MONTH\r\n```\nby the same means you can use this instead:\r\n```\r\nWITH FILL \r\n        FROM toDate('2022-02-01')\r\n        TO toDate('2022-06-01')\r\n        STEP INTERVAL 1 MONTH\r\n```\r\nI think this is simpler - you don't need time precision here\nYou are right, but im my use case I need the time as well for consistency as this query is bit more generic so it uses MONTH/DAY/HOUR interval. But thanks for the tip anyway!",
  "created_at": "2022-06-04T05:42:11Z",
  "modified_files": [
    "src/Core/SortDescription.h",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Processors/Transforms/FillingTransform.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02366_with_fill_date.sql"
  ]
}