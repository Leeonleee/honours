{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25693,
  "instance_id": "ClickHouse__ClickHouse-25693",
  "issue_numbers": [
    "7659"
  ],
  "base_commit": "ebc2fbfd63471c62f26bb83784cfa21d8243aba4",
  "patch": "diff --git a/docs/en/operations/system-tables/data_skipping_indices.md b/docs/en/operations/system-tables/data_skipping_indices.md\nnew file mode 100644\nindex 000000000000..515f704797af\n--- /dev/null\n+++ b/docs/en/operations/system-tables/data_skipping_indices.md\n@@ -0,0 +1,39 @@\n+# system.data_skipping_indices {#system-data-skipping-indices}\n+\n+Contains information about existing data skipping indices in all the tables.\n+\n+Columns:\n+\n+-   `database` ([String](../../sql-reference/data-types/string.md)) \u2014 Database name.\n+-   `table` ([String](../../sql-reference/data-types/string.md)) \u2014 Table name.\n+-   `name` ([String](../../sql-reference/data-types/string.md)) \u2014 Index name.\n+-   `type` ([String](../../sql-reference/data-types/string.md)) \u2014 Index type.\n+-   `expr` ([String](../../sql-reference/data-types/string.md)) \u2014 Expression used to calculate the index.\n+-   `granularity` ([UInt64](../../sql-reference/data-types/int-uint.md)) \u2014 Number of granules in the block.\n+\n+**Example**\n+\n+\n+```sql\n+SELECT * FROM system.data_skipping_indices LIMIT 2 FORMAT Vertical;\n+```\n+\n+```text\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+database:    default\n+table:       user_actions\n+name:        clicks_idx\n+type:        minmax\n+expr:        clicks\n+granularity: 1\n+\n+Row 2:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+database:    default\n+table:       users\n+name:        contacts_null_idx\n+type:        minmax\n+expr:        assumeNotNull(contacts_null)\n+granularity: 1\n+```\ndiff --git a/src/Storages/System/StorageSystemDataSkippingIndices.cpp b/src/Storages/System/StorageSystemDataSkippingIndices.cpp\nnew file mode 100644\nindex 000000000000..7a6ce4ec5198\n--- /dev/null\n+++ b/src/Storages/System/StorageSystemDataSkippingIndices.cpp\n@@ -0,0 +1,197 @@\n+#include <Storages/System/StorageSystemDataSkippingIndices.h>\n+#include <Access/ContextAccess.h>\n+#include <Columns/ColumnString.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Databases/IDatabase.h>\n+#include <Storages/VirtualColumnUtils.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/DatabaseCatalog.h>\n+#include <Parsers/queryToString.h>\n+#include <Processors/Sources/SourceWithProgress.h>\n+\n+\n+namespace DB\n+{\n+StorageSystemDataSkippingIndices::StorageSystemDataSkippingIndices(const StorageID & table_id_)\n+    : IStorage(table_id_)\n+{\n+    StorageInMemoryMetadata storage_metadata;\n+    storage_metadata.setColumns(ColumnsDescription(\n+        {\n+            { \"database\", std::make_shared<DataTypeString>() },\n+            { \"table\", std::make_shared<DataTypeString>() },\n+            { \"name\", std::make_shared<DataTypeString>() },\n+            { \"type\", std::make_shared<DataTypeString>() },\n+            { \"expr\", std::make_shared<DataTypeString>() },\n+            { \"granularity\", std::make_shared<DataTypeUInt64>() },\n+        }));\n+    setInMemoryMetadata(storage_metadata);\n+}\n+\n+class DataSkippingIndicesSource : public SourceWithProgress\n+{\n+public:\n+    DataSkippingIndicesSource(\n+        std::vector<UInt8> columns_mask_,\n+        Block header,\n+        UInt64 max_block_size_,\n+        ColumnPtr databases_,\n+        ContextPtr context_)\n+        : SourceWithProgress(header)\n+        , column_mask(std::move(columns_mask_))\n+        , max_block_size(max_block_size_)\n+        , databases(std::move(databases_))\n+        , context(Context::createCopy(context_))\n+        , database_idx(0)\n+    {}\n+\n+    String getName() const override { return \"DataSkippingIndices\"; }\n+\n+protected:\n+    Chunk generate() override\n+    {\n+        if (database_idx >= databases->size())\n+            return {};\n+\n+        MutableColumns res_columns = getPort().getHeader().cloneEmptyColumns();\n+\n+        const auto access = context->getAccess();\n+        const bool check_access_for_databases = !access->isGranted(AccessType::SHOW_TABLES);\n+\n+        size_t rows_count = 0;\n+        while (rows_count < max_block_size)\n+        {\n+            if (tables_it && !tables_it->isValid())\n+                ++database_idx;\n+\n+            while (database_idx < databases->size() && (!tables_it || !tables_it->isValid()))\n+            {\n+                database_name = databases->getDataAt(database_idx).toString();\n+                database = DatabaseCatalog::instance().tryGetDatabase(database_name);\n+\n+                if (database)\n+                    break;\n+                ++database_idx;\n+            }\n+\n+            if (database_idx >= databases->size())\n+                break;\n+\n+            if (!tables_it || !tables_it->isValid())\n+                tables_it = database->getTablesIterator(context);\n+\n+            const bool check_access_for_tables = check_access_for_databases && !access->isGranted(AccessType::SHOW_TABLES, database_name);\n+\n+            for (; rows_count < max_block_size && tables_it->isValid(); tables_it->next())\n+            {\n+                auto table_name = tables_it->name();\n+                if (check_access_for_tables && !access->isGranted(AccessType::SHOW_TABLES, database_name, table_name))\n+                    continue;\n+\n+                const auto table = tables_it->table();\n+                if (!table)\n+                    continue;\n+                StorageMetadataPtr metadata_snapshot = table->getInMemoryMetadataPtr();\n+                if (!metadata_snapshot)\n+                    continue;\n+                const auto indices = metadata_snapshot->getSecondaryIndices();\n+\n+                for (const auto & index : indices)\n+                {\n+                    ++rows_count;\n+\n+                    size_t src_index = 0;\n+                    size_t res_index = 0;\n+\n+                    // 'database' column\n+                    if (column_mask[src_index++])\n+                        res_columns[res_index++]->insert(database_name);\n+                    // 'table' column\n+                    if (column_mask[src_index++])\n+                        res_columns[res_index++]->insert(table_name);\n+                    // 'name' column\n+                    if (column_mask[src_index++])\n+                        res_columns[res_index++]->insert(index.name);\n+                    // 'type' column\n+                    if (column_mask[src_index++])\n+                        res_columns[res_index++]->insert(index.type);\n+                    // 'expr' column\n+                    if (column_mask[src_index++])\n+                    {\n+                        if (auto expression = index.expression_list_ast)\n+                            res_columns[res_index++]->insert(queryToString(expression));\n+                        else\n+                            res_columns[res_index++]->insertDefault();\n+                    }\n+                    // 'granularity' column\n+                    if (column_mask[src_index++])\n+                        res_columns[res_index++]->insert(index.granularity);\n+                }\n+            }\n+        }\n+        return Chunk(std::move(res_columns), rows_count);\n+    }\n+\n+private:\n+    std::vector<UInt8> column_mask;\n+    UInt64 max_block_size;\n+    ColumnPtr databases;\n+    ContextPtr context;\n+    size_t database_idx;\n+    DatabasePtr database;\n+    std::string database_name;\n+    DatabaseTablesIteratorPtr tables_it;\n+};\n+\n+Pipe StorageSystemDataSkippingIndices::read(\n+    const Names & column_names,\n+    const StorageMetadataPtr & metadata_snapshot,\n+    SelectQueryInfo & query_info,\n+    ContextPtr context,\n+    QueryProcessingStage::Enum /* processed_stage */,\n+    size_t max_block_size,\n+    unsigned int /* num_streams */)\n+{\n+    metadata_snapshot->check(column_names, getVirtuals(), getStorageID());\n+\n+    NameSet names_set(column_names.begin(), column_names.end());\n+\n+    Block sample_block = metadata_snapshot->getSampleBlock();\n+    Block header;\n+\n+    std::vector<UInt8> columns_mask(sample_block.columns());\n+    for (size_t i = 0, size = columns_mask.size(); i < size; ++i)\n+    {\n+        if (names_set.count(sample_block.getByPosition(i).name))\n+        {\n+            columns_mask[i] = 1;\n+            header.insert(sample_block.getByPosition(i));\n+        }\n+    }\n+\n+    MutableColumnPtr column = ColumnString::create();\n+\n+    const auto databases = DatabaseCatalog::instance().getDatabases();\n+    for (const auto & [database_name, database] : databases)\n+    {\n+        if (database_name == DatabaseCatalog::TEMPORARY_DATABASE)\n+            continue;\n+\n+        /// Lazy database can contain only very primitive tables,\n+        /// it cannot contain tables with data skipping indices.\n+        /// Skip it to avoid unnecessary tables loading in the Lazy database.\n+        if (database->getEngineName() != \"Lazy\")\n+            column->insert(database_name);\n+    }\n+\n+    /// Condition on \"database\" in a query acts like an index.\n+    Block block { ColumnWithTypeAndName(std::move(column), std::make_shared<DataTypeString>(), \"database\") };\n+    VirtualColumnUtils::filterBlockWithQuery(query_info.query, block, context);\n+\n+    ColumnPtr & filtered_databases = block.getByPosition(0).column;\n+    return Pipe(std::make_shared<DataSkippingIndicesSource>(\n+        std::move(columns_mask), std::move(header), max_block_size, std::move(filtered_databases), context));\n+}\n+\n+}\ndiff --git a/src/Storages/System/StorageSystemDataSkippingIndices.h b/src/Storages/System/StorageSystemDataSkippingIndices.h\nnew file mode 100644\nindex 000000000000..8497f16606f1\n--- /dev/null\n+++ b/src/Storages/System/StorageSystemDataSkippingIndices.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <common/shared_ptr_helper.h>\n+#include <Storages/IStorage.h>\n+\n+\n+namespace DB\n+{\n+\n+/// For system.data_skipping_indices table - describes the data skipping indices in tables, similar to system.columns.\n+class StorageSystemDataSkippingIndices : public shared_ptr_helper<StorageSystemDataSkippingIndices>, public IStorage\n+{\n+    friend struct shared_ptr_helper<StorageSystemDataSkippingIndices>;\n+public:\n+    std::string getName() const override { return \"SystemDataSkippingIndices\"; }\n+\n+    Pipe read(\n+        const Names & column_names,\n+        const StorageMetadataPtr & /*metadata_snapshot*/,\n+        SelectQueryInfo & query_info,\n+        ContextPtr context,\n+        QueryProcessingStage::Enum processed_stage,\n+        size_t max_block_size,\n+        unsigned num_streams) override;\n+\n+protected:\n+    StorageSystemDataSkippingIndices(const StorageID & table_id_);\n+};\n+\n+}\ndiff --git a/src/Storages/System/attachSystemTables.cpp b/src/Storages/System/attachSystemTables.cpp\nindex 830a6c4fcd38..7da65b09d6d7 100644\n--- a/src/Storages/System/attachSystemTables.cpp\n+++ b/src/Storages/System/attachSystemTables.cpp\n@@ -9,6 +9,7 @@\n #include <Storages/System/StorageSystemClusters.h>\n #include <Storages/System/StorageSystemColumns.h>\n #include <Storages/System/StorageSystemDatabases.h>\n+#include <Storages/System/StorageSystemDataSkippingIndices.h>\n #include <Storages/System/StorageSystemDataTypeFamilies.h>\n #include <Storages/System/StorageSystemDetachedParts.h>\n #include <Storages/System/StorageSystemDictionaries.h>\n@@ -115,6 +116,7 @@ void attachSystemTablesLocal(IDatabase & system_database)\n     attach<StorageSystemUserDirectories>(system_database, \"user_directories\");\n     attach<StorageSystemPrivileges>(system_database, \"privileges\");\n     attach<StorageSystemErrors>(system_database, \"errors\");\n+    attach<StorageSystemDataSkippingIndices>(system_database, \"data_skipping_indices\");\n #if !defined(ARCADIA_BUILD)\n     attach<StorageSystemLicenses>(system_database, \"licenses\");\n     attach<StorageSystemTimeZones>(system_database, \"time_zones\");\ndiff --git a/src/Storages/ya.make b/src/Storages/ya.make\nindex d86925242103..6e412cddba7e 100644\n--- a/src/Storages/ya.make\n+++ b/src/Storages/ya.make\n@@ -158,6 +158,7 @@ SRCS(\n     System/StorageSystemContributors.generated.cpp\n     System/StorageSystemCurrentRoles.cpp\n     System/StorageSystemDDLWorkerQueue.cpp\n+    System/StorageSystemDataSkippingIndices.cpp\n     System/StorageSystemDataTypeFamilies.cpp\n     System/StorageSystemDatabases.cpp\n     System/StorageSystemDetachedParts.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01917_system_data_skipping_indices.reference b/tests/queries/0_stateless/01917_system_data_skipping_indices.reference\nnew file mode 100644\nindex 000000000000..b5a4b596a97e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01917_system_data_skipping_indices.reference\n@@ -0,0 +1,10 @@\n+default\tdata_01917\td1_idx\tminmax\td1\t1\n+default\tdata_01917\td1_null_idx\tminmax\tassumeNotNull(d1_null)\t1\n+default\tdata_01917_2\tmemory\tset\tfrequency * length(name)\t5\n+default\tdata_01917_2\tsample_index1\tminmax\tlength(name), name\t4\n+default\tdata_01917_2\tsample_index2\tngrambf_v1\tlower(name), name\t4\n+2\n+3\n+d1_idx\n+d1_null_idx\n+sample_index1\ndiff --git a/tests/queries/0_stateless/01917_system_data_skipping_indices.sql b/tests/queries/0_stateless/01917_system_data_skipping_indices.sql\nnew file mode 100644\nindex 000000000000..bfe9d6398b30\n--- /dev/null\n+++ b/tests/queries/0_stateless/01917_system_data_skipping_indices.sql\n@@ -0,0 +1,35 @@\n+DROP TABLE IF EXISTS data_01917;\n+DROP TABLE IF EXISTS data_01917_2;\n+\n+CREATE TABLE data_01917\n+(\n+    key Int,\n+    d1 Int,\n+    d1_null Nullable(Int),\n+    INDEX d1_idx d1 TYPE minmax GRANULARITY 1,\n+    INDEX d1_null_idx assumeNotNull(d1_null) TYPE minmax GRANULARITY 1\n+)\n+Engine=MergeTree()\n+ORDER BY key;\n+\n+CREATE TABLE data_01917_2\n+(\n+    name String,\n+    frequency UInt64,\n+    INDEX memory (frequency * length(name)) TYPE set(1000) GRANULARITY 5,\n+    INDEX sample_index1 (length(name), name) TYPE minmax GRANULARITY 4,\n+    INDEX sample_index2 (lower(name), name) TYPE ngrambf_v1(3, 256, 2, 0) GRANULARITY 4\n+)\n+Engine=MergeTree()\n+ORDER BY name;\n+\n+SELECT * FROM system.data_skipping_indices WHERE database = currentDatabase();\n+\n+SELECT count(*) FROM system.data_skipping_indices WHERE table = 'data_01917' AND database = currentDatabase();\n+SELECT count(*) FROM system.data_skipping_indices WHERE table = 'data_01917_2' AND database = currentDatabase();\n+\n+SELECT name FROM system.data_skipping_indices WHERE type = 'minmax' AND database = currentDatabase();\n+\n+DROP TABLE data_01917;\n+DROP TABLE data_01917_2;\n+\n",
  "problem_statement": "system.data_skipping_indices table for data skipping indices\nCurrently the only way to get information about existing data skipping indices is via the `create_table_query` field of the `system.tables` table (or from the `metadata/` directory on the filesystem). Both of them are not easy to parse and are therefore not useful for automated processing.\r\n\r\nI'd like to propose a system.* table dedicated to data skipping indices, similar to `system.columns`.\r\n\r\nI would like to see at least the following information in the table:\r\n\r\n```\r\nselect * from system.data_skipping_indices\r\n\r\n\u250c\u2500database\u2500\u252c\u2500table\u2500\u2500\u2500\u252c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u252c\u2500expr\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500granularity\u2500\u2510\r\n\u2502 default  \u2502 metrics \u2502 idx_skip_tags \u2502 SET(100) \u2502 tags_field \u2502           4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nAdditionally, any type of statistics/metrics might be useful, but i don't know the internals of data skipping indices enough to give any meaningful input here.\r\n\r\n\n",
  "hints_text": "May be we can just list them inside columns? With a special column type? In that case we will also hale parts_columns 'for free'.\n@filimonov In this case we will have to always keep in mind that system.columns is not only for columns. It will break 3rd party tools.\r\n\r\nBetter to introduce a separate table.",
  "created_at": "2021-06-24T23:20:09Z",
  "modified_files": [
    "b/docs/en/operations/system-tables/data_skipping_indices.md",
    "b/src/Storages/System/StorageSystemDataSkippingIndices.cpp",
    "b/src/Storages/System/StorageSystemDataSkippingIndices.h",
    "src/Storages/System/attachSystemTables.cpp",
    "src/Storages/ya.make"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01917_system_data_skipping_indices.reference",
    "b/tests/queries/0_stateless/01917_system_data_skipping_indices.sql"
  ]
}