diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 0e899045c7c8..599b64ef43f1 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -26,19 +26,27 @@ SELECT
 
 ## makeDate
 
-Creates a [Date](../../sql-reference/data-types/date.md) from a year, month and day argument.
+Creates a [Date](../../sql-reference/data-types/date.md)
+- from a year, month and day argument, or
+- from a year and day of year argument.
 
 **Syntax**
 
 ``` sql
-makeDate(year, month, day)
+makeDate(year, month, day);
+makeDate(year, day_of_year);
 ```
 
+Alias:
+- `MAKEDATE(year, month, day);`
+- `MAKEDATE(year, day_of_year);`
+
 **Arguments**
 
 - `year` — Year. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).
 - `month` — Month. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).
 - `day` — Day. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).
+- `day_of_year` — Day of the year. [Integer](../../sql-reference/data-types/int-uint.md), [Float](../../sql-reference/data-types/float.md) or [Decimal](../../sql-reference/data-types/decimal.md).
 
 **Returned value**
 
@@ -48,6 +56,8 @@ Type: [Date](../../sql-reference/data-types/date.md).
 
 **Example**
 
+Create a Date from a year, month and day:
+
 ``` sql
 SELECT makeDate(2023, 2, 28) AS Date;
 ```
@@ -60,6 +70,19 @@ Result:
 └────────────┘
 ```
 
+Create a Date from a year and day of year argument:
+
+``` sql
+SELECT makeDate(2023, 42) AS Date;
+```
+
+Result:
+
+``` text
+┌───────date─┐
+│ 2023-02-11 │
+└────────────┘
+```
 ## makeDate32
 
 Like [makeDate](#makeDate) but produces a [Date32](../../sql-reference/data-types/date32.md).
@@ -108,6 +131,12 @@ Result:
 
 Like [makeDateTime](#makedatetime) but produces a [DateTime64](../../sql-reference/data-types/datetime64.md).
 
+**Syntax**
+
+``` sql
+makeDateTime32(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])
+```
+
 ## timeZone
 
 Returns the timezone of the server.
diff --git a/src/Functions/makeDate.cpp b/src/Functions/makeDate.cpp
index 97271386286b..1e4f3604c944 100644
--- a/src/Functions/makeDate.cpp
+++ b/src/Functions/makeDate.cpp
@@ -1,5 +1,6 @@
 #include <Functions/IFunction.h>
 #include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
 #include <DataTypes/DataTypeDate.h>
 #include <DataTypes/DataTypeDate32.h>
 #include <DataTypes/DataTypeDateTime.h>
@@ -20,7 +21,6 @@ namespace DB
 {
 namespace ErrorCodes
 {
-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
     extern const int ARGUMENT_OUT_OF_BOUND;
 }
@@ -28,13 +28,7 @@ namespace ErrorCodes
 namespace
 {
 
-/// A helper function to simplify comparisons of valid YYYY-MM-DD values for <,>,=
-inline constexpr Int64 YearMonthDayToSingleInt(Int64 year, Int64 month, Int64 day)
-{
-    return year * 512 + month * 32 + day;
-}
-
-/// Common logic to handle numeric arguments like year, month, day, hour, minute, second
+/// Functions common to makeDate, makeDate32, makeDateTime, makeDateTime64
 class FunctionWithNumericParamsBase : public IFunction
 {
 public:
@@ -49,36 +43,23 @@ class FunctionWithNumericParamsBase : public IFunction
 
     bool useDefaultImplementationForConstants() const override { return true; }
 
-protected:
-    template <class ArgumentNames>
-    void checkRequiredArguments(const ColumnsWithTypeAndName & arguments, const ArgumentNames & argument_names, const size_t optional_argument_count) const
-    {
-        if (arguments.size() < argument_names.size() || arguments.size() > argument_names.size() + optional_argument_count)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                "Function {} requires {} to {} arguments, but {} given",
-                getName(), argument_names.size(), argument_names.size() + optional_argument_count, arguments.size());
+    bool isVariadic() const override { return true; }
 
-        for (size_t i = 0; i < argument_names.size(); ++i)
-        {
-            DataTypePtr argument_type = arguments[i].type;
-            if (!isNumber(argument_type))
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                    "Argument '{}' for function {} must be a number", std::string(argument_names[i]), getName());
-        }
-    }
+    size_t getNumberOfArguments() const override { return 0; }
 
+protected:
     template <class ArgumentNames>
-    void convertRequiredArguments(const ColumnsWithTypeAndName & arguments, const ArgumentNames & argument_names, Columns & converted_arguments) const
+    Columns convertMandatoryArguments(const ColumnsWithTypeAndName & arguments, const ArgumentNames & argument_names) const
     {
+        Columns converted_arguments;
         const DataTypePtr converted_argument_type = std::make_shared<DataTypeFloat32>();
-        converted_arguments.clear();
-        converted_arguments.reserve(arguments.size());
         for (size_t i = 0; i < argument_names.size(); ++i)
         {
             ColumnPtr argument_column = castColumn(arguments[i], converted_argument_type);
             argument_column = argument_column->convertToFullColumnIfConst();
             converted_arguments.push_back(argument_column);
         }
+        return converted_arguments;
     }
 };
 
@@ -87,7 +68,8 @@ template <typename Traits>
 class FunctionMakeDate : public FunctionWithNumericParamsBase
 {
 private:
-    static constexpr std::array argument_names = {"year", "month", "day"};
+    static constexpr std::array mandatory_argument_names_year_month_day = {"year", "month", "day"};
+    static constexpr std::array mandatory_argument_names_year_dayofyear = {"year", "dayofyear"};
 
 public:
     static constexpr auto name = Traits::name;
@@ -96,56 +78,103 @@ class FunctionMakeDate : public FunctionWithNumericParamsBase
 
     String getName() const override { return name; }
 
-    bool isVariadic() const override { return false; }
-
-    size_t getNumberOfArguments() const override { return argument_names.size(); }
-
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        checkRequiredArguments(arguments, argument_names, 0);
+        const bool isYearMonthDayVariant = (arguments.size() == 3);
+
+        if (isYearMonthDayVariant)
+        {
+            FunctionArgumentDescriptors args{
+                {mandatory_argument_names_year_month_day[0], &isNumber<IDataType>, nullptr, "Number"},
+                {mandatory_argument_names_year_month_day[1], &isNumber<IDataType>, nullptr, "Number"},
+                {mandatory_argument_names_year_month_day[2], &isNumber<IDataType>, nullptr, "Number"}
+            };
+            validateFunctionArgumentTypes(*this, arguments, args);
+        }
+        else
+        {
+            FunctionArgumentDescriptors args{
+                {mandatory_argument_names_year_dayofyear[0], &isNumber<IDataType>, nullptr, "Number"},
+                {mandatory_argument_names_year_dayofyear[1], &isNumber<IDataType>, nullptr, "Number"}
+            };
+            validateFunctionArgumentTypes(*this, arguments, args);
+        }
 
         return std::make_shared<typename Traits::ReturnDataType>();
     }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
     {
+        const bool isYearMonthDayVariant = (arguments.size() == 3);
+
         Columns converted_arguments;
-        convertRequiredArguments(arguments, argument_names, converted_arguments);
+        if (isYearMonthDayVariant)
+            converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names_year_month_day);
+        else
+            converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names_year_dayofyear);
 
         auto res_column = Traits::ReturnDataType::ColumnType::create(input_rows_count);
         auto & result_data = res_column->getData();
 
-        const auto & year_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[0]).getData();
-        const auto & month_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[1]).getData();
-        const auto & day_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[2]).getData();
-
         const auto & date_lut = DateLUT::instance();
+        const Int32 max_days_since_epoch = date_lut.makeDayNum(Traits::MAX_DATE[0], Traits::MAX_DATE[1], Traits::MAX_DATE[2]);
 
-        for (size_t i = 0; i < input_rows_count; ++i)
+        if (isYearMonthDayVariant)
         {
-            const auto year = year_data[i];
-            const auto month = month_data[i];
-            const auto day = day_data[i];
-
-            Int32 day_num = 0;
+            const auto & year_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[0]).getData();
+            const auto & month_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[1]).getData();
+            const auto & day_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[2]).getData();
 
-            if (year >= Traits::MIN_YEAR &&
-                year <= Traits::MAX_YEAR &&
-                month >= 1 && month <= 12 &&
-                day >= 1 && day <= 31 &&
-                YearMonthDayToSingleInt(static_cast<Int64>(year), static_cast<Int64>(month), static_cast<Int64>(day)) <= Traits::MAX_DATE)
+            for (size_t i = 0; i < input_rows_count; ++i)
             {
-                day_num = date_lut.makeDayNum(static_cast<Int16>(year), static_cast<UInt8>(month), static_cast<UInt8>(day));
+                const auto year = year_data[i];
+                const auto month = month_data[i];
+                const auto day = day_data[i];
+
+                Int32 day_num = 0;
+
+                if (year >= Traits::MIN_YEAR &&
+                    year <= Traits::MAX_YEAR &&
+                    month >= 1 && month <= 12 &&
+                    day >= 1 && day <= 31)
+                {
+                    Int32 days_since_epoch = date_lut.makeDayNum(static_cast<Int16>(year), static_cast<UInt8>(month), static_cast<UInt8>(day));
+                    if (days_since_epoch <= max_days_since_epoch)
+                        day_num = days_since_epoch;
+                }
+
+                result_data[i] = day_num;
             }
+        }
+        else
+        {
+            const auto & year_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[0]).getData();
+            const auto & dayofyear_data = typeid_cast<const ColumnFloat32 &>(*converted_arguments[1]).getData();
+
+            for (size_t i = 0; i < input_rows_count; ++i)
+            {
+                const auto year = year_data[i];
+                const auto dayofyear = dayofyear_data[i];
+
+                Int32 day_num = 0;
+
+                if (year >= Traits::MIN_YEAR &&
+                    year <= Traits::MAX_YEAR &&
+                    dayofyear >= 1 && dayofyear <= 365)
+                {
+                    Int32 days_since_epoch = date_lut.makeDayNum(static_cast<Int16>(year), 1, 1) + static_cast<Int32>(dayofyear) - 1;
+                    if (days_since_epoch <= max_days_since_epoch)
+                        day_num = days_since_epoch;
+                }
 
-            result_data[i] = day_num;
+                result_data[i] = day_num;
+            }
         }
 
         return res_column;
     }
 };
 
-/// makeDate(year, month, day)
 struct MakeDateTraits
 {
     static constexpr auto name = "makeDate";
@@ -154,10 +183,9 @@ struct MakeDateTraits
     static constexpr auto MIN_YEAR = 1970;
     static constexpr auto MAX_YEAR = 2149;
     /// This date has the maximum day number that fits in 16-bit uint
-    static constexpr auto MAX_DATE = YearMonthDayToSingleInt(MAX_YEAR, 6, 6);
+    static constexpr std::array MAX_DATE = {MAX_YEAR, 6, 6};
 };
 
-/// makeDate32(year, month, day)
 struct MakeDate32Traits
 {
     static constexpr auto name = "makeDate32";
@@ -165,30 +193,14 @@ struct MakeDate32Traits
 
     static constexpr auto MIN_YEAR = 1900;
     static constexpr auto MAX_YEAR = 2299;
-    static constexpr auto MAX_DATE = YearMonthDayToSingleInt(MAX_YEAR, 12, 31);
+    static constexpr std::array MAX_DATE = {MAX_YEAR, 12, 31};
 };
 
 /// Common implementation for makeDateTime, makeDateTime64
 class FunctionMakeDateTimeBase : public FunctionWithNumericParamsBase
 {
 protected:
-    static constexpr std::array argument_names = {"year", "month", "day", "hour", "minute", "second"};
-
-public:
-    bool isVariadic() const override { return true; }
-
-    size_t getNumberOfArguments() const override { return 0; }
-
-protected:
-    void checkRequiredArguments(const ColumnsWithTypeAndName & arguments, const size_t optional_argument_count) const
-    {
-        FunctionWithNumericParamsBase::checkRequiredArguments(arguments, argument_names, optional_argument_count);
-    }
-
-    void convertRequiredArguments(const ColumnsWithTypeAndName & arguments, Columns & converted_arguments) const
-    {
-        FunctionWithNumericParamsBase::convertRequiredArguments(arguments, argument_names, converted_arguments);
-    }
+    static constexpr std::array mandatory_argument_names = {"year", "month", "day", "hour", "minute", "second"};
 
     template <typename T>
     static Int64 dateTime(T year, T month, T day_of_month, T hour, T minute, T second, const DateLUTImpl & lut)
@@ -235,7 +247,7 @@ class FunctionMakeDateTimeBase : public FunctionWithNumericParamsBase
 class FunctionMakeDateTime : public FunctionMakeDateTimeBase
 {
 private:
-    static constexpr std::array<const char*, 1> optional_argument_names = {"timezone"};
+    static constexpr std::array optional_argument_names = {"timezone"};
 
 public:
     static constexpr auto name = "makeDateTime";
@@ -246,11 +258,24 @@ class FunctionMakeDateTime : public FunctionMakeDateTimeBase
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        checkRequiredArguments(arguments, optional_argument_names.size());
+        FunctionArgumentDescriptors mandatory_args{
+            {mandatory_argument_names[0], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[1], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[2], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[3], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[4], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[5], &isNumber<IDataType>, nullptr, "Number"}
+        };
+
+        FunctionArgumentDescriptors optional_args{
+            {optional_argument_names[0], &isString<IDataType>, nullptr, "String"}
+        };
+
+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);
 
         /// Optional timezone argument
         std::string timezone;
-        if (arguments.size() == argument_names.size() + 1)
+        if (arguments.size() == mandatory_argument_names.size() + 1)
             timezone = extractTimezone(arguments.back());
 
         return std::make_shared<DataTypeDateTime>(timezone);
@@ -260,11 +285,10 @@ class FunctionMakeDateTime : public FunctionMakeDateTimeBase
     {
         /// Optional timezone argument
         std::string timezone;
-        if (arguments.size() == argument_names.size() + 1)
+        if (arguments.size() == mandatory_argument_names.size() + 1)
             timezone = extractTimezone(arguments.back());
 
-        Columns converted_arguments;
-        convertRequiredArguments(arguments, converted_arguments);
+        Columns converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names);
 
         auto res_column = ColumnDateTime::create(input_rows_count);
         auto & result_data = res_column->getData();
@@ -300,11 +324,11 @@ class FunctionMakeDateTime : public FunctionMakeDateTimeBase
     }
 };
 
-/// makeDateTime64(year, month, day, hour, minute, second, [fraction], [precision], [timezone])
+/// makeDateTime64(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])
 class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase
 {
 private:
-    static constexpr std::array<const char*, 3> optional_argument_names = {"fraction", "precision", "timezone"};
+    static constexpr std::array optional_argument_names = {"fraction", "precision", "timezone"};
     static constexpr UInt8 DEFAULT_PRECISION = 3;
 
 public:
@@ -316,11 +340,26 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        checkRequiredArguments(arguments, optional_argument_names.size());
-
-        if (arguments.size() >= argument_names.size() + 1)
+        FunctionArgumentDescriptors mandatory_args{
+            {mandatory_argument_names[0], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[1], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[2], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[3], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[4], &isNumber<IDataType>, nullptr, "Number"},
+            {mandatory_argument_names[5], &isNumber<IDataType>, nullptr, "Number"}
+        };
+
+        FunctionArgumentDescriptors optional_args{
+            {optional_argument_names[0], &isNumber<IDataType>, nullptr, "Number"},
+            {optional_argument_names[1], &isNumber<IDataType>, nullptr, "Number"},
+            {optional_argument_names[2], &isString<IDataType>, nullptr, "String"}
+        };
+
+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);
+
+        if (arguments.size() >= mandatory_argument_names.size() + 1)
         {
-            const auto& fraction_argument = arguments[argument_names.size()];
+            const auto& fraction_argument = arguments[mandatory_argument_names.size()];
             if (!isNumber(fraction_argument.type))
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "Argument 'fraction' for function {} must be a number", getName());
@@ -328,12 +367,12 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase
 
         /// Optional precision argument
         Int64 precision = DEFAULT_PRECISION;
-        if (arguments.size() >= argument_names.size() + 2)
-            precision = extractPrecision(arguments[argument_names.size() + 1]);
+        if (arguments.size() >= mandatory_argument_names.size() + 2)
+            precision = extractPrecision(arguments[mandatory_argument_names.size() + 1]);
 
         /// Optional timezone argument
         std::string timezone;
-        if (arguments.size() == argument_names.size() + 3)
+        if (arguments.size() == mandatory_argument_names.size() + 3)
             timezone = extractTimezone(arguments.back());
 
         return std::make_shared<DataTypeDateTime64>(precision, timezone);
@@ -343,22 +382,21 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase
     {
         /// Optional precision argument
         Int64 precision = DEFAULT_PRECISION;
-        if (arguments.size() >= argument_names.size() + 2)
-            precision = extractPrecision(arguments[argument_names.size() + 1]);
+        if (arguments.size() >= mandatory_argument_names.size() + 2)
+            precision = extractPrecision(arguments[mandatory_argument_names.size() + 1]);
 
         /// Optional timezone argument
         std::string timezone;
-        if (arguments.size() == argument_names.size() + 3)
+        if (arguments.size() == mandatory_argument_names.size() + 3)
             timezone = extractTimezone(arguments.back());
 
-        Columns converted_arguments;
-        convertRequiredArguments(arguments, converted_arguments);
+        Columns converted_arguments = convertMandatoryArguments(arguments, mandatory_argument_names);
 
         /// Optional fraction argument
         const ColumnVector<Float64>::Container * fraction_data = nullptr;
-        if (arguments.size() >= argument_names.size() + 1)
+        if (arguments.size() >= mandatory_argument_names.size() + 1)
         {
-            ColumnPtr fraction_column = castColumn(arguments[argument_names.size()], std::make_shared<DataTypeFloat64>());
+            ColumnPtr fraction_column = castColumn(arguments[mandatory_argument_names.size()], std::make_shared<DataTypeFloat64>());
             fraction_column = fraction_column->convertToFullColumnIfConst();
             converted_arguments.push_back(fraction_column);
             fraction_data = &typeid_cast<const ColumnFloat64 &>(*converted_arguments[6]).getData();
@@ -439,7 +477,7 @@ class FunctionMakeDateTime64 : public FunctionMakeDateTimeBase
 
 REGISTER_FUNCTION(MakeDate)
 {
-    factory.registerFunction<FunctionMakeDate<MakeDateTraits>>();
+    factory.registerFunction<FunctionMakeDate<MakeDateTraits>>({}, FunctionFactory::CaseInsensitive);
     factory.registerFunction<FunctionMakeDate<MakeDate32Traits>>();
     factory.registerFunction<FunctionMakeDateTime>();
     factory.registerFunction<FunctionMakeDateTime64>();
