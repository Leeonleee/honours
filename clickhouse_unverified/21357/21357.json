{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21357,
  "instance_id": "ClickHouse__ClickHouse-21357",
  "issue_numbers": [
    "21140"
  ],
  "base_commit": "15b3f379a56c8f648cff38695ec2aa617c13fe58",
  "patch": "diff --git a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\nindex 4aed9979ab29..f599b7c87e99 100644\n--- a/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n+++ b/src/Processors/Formats/Impl/ConstantExpressionTemplate.cpp\n@@ -17,6 +17,7 @@\n #include <Interpreters/Context.h>\n #include <Interpreters/convertFieldToType.h>\n #include <Interpreters/ExpressionActions.h>\n+#include <Interpreters/castColumn.h>\n #include <IO/ReadHelpers.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTFunction.h>\n@@ -589,7 +590,7 @@ bool ConstantExpressionTemplate::parseLiteralAndAssertType(ReadBuffer & istr, co\n     }\n }\n \n-ColumnPtr ConstantExpressionTemplate::evaluateAll(BlockMissingValues & nulls, size_t column_idx, size_t offset)\n+ColumnPtr ConstantExpressionTemplate::evaluateAll(BlockMissingValues & nulls, size_t column_idx, const DataTypePtr & expected_type, size_t offset)\n {\n     Block evaluated = structure->literals.cloneWithColumns(std::move(columns));\n     columns = structure->literals.cloneEmptyColumns();\n@@ -607,12 +608,13 @@ ColumnPtr ConstantExpressionTemplate::evaluateAll(BlockMissingValues & nulls, si\n                         ErrorCodes::LOGICAL_ERROR);\n \n     rows_count = 0;\n-    ColumnPtr res = evaluated.getByName(structure->result_column_name).column->convertToFullColumnIfConst();\n+    auto res = evaluated.getByName(structure->result_column_name);\n+    res.column = res.column->convertToFullColumnIfConst();\n     if (!structure->null_as_default)\n-        return res;\n+        return castColumn(res, expected_type);\n \n     /// Extract column with evaluated expression and mask for NULLs\n-    const auto & tuple = assert_cast<const ColumnTuple &>(*res);\n+    const auto & tuple = assert_cast<const ColumnTuple &>(*res.column);\n     if (tuple.tupleSize() != 2)\n         throw Exception(\"Invalid tuple size, it'a a bug\", ErrorCodes::LOGICAL_ERROR);\n     const auto & is_null = assert_cast<const ColumnUInt8 &>(tuple.getColumn(1));\n@@ -621,7 +623,9 @@ ColumnPtr ConstantExpressionTemplate::evaluateAll(BlockMissingValues & nulls, si\n         if (is_null.getUInt(i))\n             nulls.setBit(column_idx, offset + i);\n \n-    return tuple.getColumnPtr(0);\n+    res.column = tuple.getColumnPtr(0);\n+    res.type = assert_cast<const DataTypeTuple &>(*res.type).getElements()[0];\n+    return castColumn(res, expected_type);\n }\n \n void ConstantExpressionTemplate::TemplateStructure::addNodesToCastResult(const IDataType & result_column_type, ASTPtr & expr, bool null_as_default)\ndiff --git a/src/Processors/Formats/Impl/ConstantExpressionTemplate.h b/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\nindex 931b05673c6b..299ce4c9925e 100644\n--- a/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\n+++ b/src/Processors/Formats/Impl/ConstantExpressionTemplate.h\n@@ -72,7 +72,7 @@ class ConstantExpressionTemplate : boost::noncopyable\n \n     /// Evaluate batch of expressions were parsed using template.\n     /// If template was deduced with null_as_default == true, set bits in nulls for NULL values in column_idx, starting from offset.\n-    ColumnPtr evaluateAll(BlockMissingValues & nulls, size_t column_idx, size_t offset = 0);\n+    ColumnPtr evaluateAll(BlockMissingValues & nulls, size_t column_idx, const DataTypePtr & expected_type, size_t offset = 0);\n \n     size_t rowsCount() const { return rows_count; }\n \ndiff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\nindex 3fde84a40909..1455b8f67402 100644\n--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp\n@@ -73,11 +73,13 @@ Chunk ValuesBlockInputFormat::generate()\n     {\n         if (!templates[i] || !templates[i]->rowsCount())\n             continue;\n+\n+        const auto & expected_type = header.getByPosition(i).type;\n         if (columns[i]->empty())\n-            columns[i] = IColumn::mutate(templates[i]->evaluateAll(block_missing_values, i));\n+            columns[i] = IColumn::mutate(templates[i]->evaluateAll(block_missing_values, i, expected_type));\n         else\n         {\n-            ColumnPtr evaluated = templates[i]->evaluateAll(block_missing_values, i, columns[i]->size());\n+            ColumnPtr evaluated = templates[i]->evaluateAll(block_missing_values, i, expected_type, columns[i]->size());\n             columns[i]->insertRangeFrom(*evaluated, 0, evaluated->size());\n         }\n     }\n@@ -135,13 +137,16 @@ bool ValuesBlockInputFormat::tryParseExpressionUsingTemplate(MutableColumnPtr &\n         return true;\n     }\n \n+    const auto & header = getPort().getHeader();\n+    const auto & expected_type = header.getByPosition(column_idx).type;\n+\n     /// Expression in the current row is not match template deduced on the first row.\n     /// Evaluate expressions, which were parsed using this template.\n     if (column->empty())\n-        column = IColumn::mutate(templates[column_idx]->evaluateAll(block_missing_values, column_idx));\n+        column = IColumn::mutate(templates[column_idx]->evaluateAll(block_missing_values, column_idx, expected_type));\n     else\n     {\n-        ColumnPtr evaluated = templates[column_idx]->evaluateAll(block_missing_values, column_idx, column->size());\n+        ColumnPtr evaluated = templates[column_idx]->evaluateAll(block_missing_values, column_idx, expected_type, column->size());\n         column->insertRangeFrom(*evaluated, 0, evaluated->size());\n     }\n     /// Do not use this template anymore\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01746_lc_values_format_bug.reference b/tests/queries/0_stateless/01746_lc_values_format_bug.reference\nnew file mode 100644\nindex 000000000000..78981922613b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01746_lc_values_format_bug.reference\n@@ -0,0 +1,1 @@\n+a\ndiff --git a/tests/queries/0_stateless/01746_lc_values_format_bug.sql b/tests/queries/0_stateless/01746_lc_values_format_bug.sql\nnew file mode 100644\nindex 000000000000..6717b9ae5e36\n--- /dev/null\n+++ b/tests/queries/0_stateless/01746_lc_values_format_bug.sql\n@@ -0,0 +1,14 @@\n+drop table if exists lc_test;\n+\n+CREATE TABLE lc_test\n+(\n+    `id` LowCardinality(String)\n+)\n+ENGINE = MergeTree\n+PARTITION BY tuple()\n+ORDER BY id;\n+\n+insert into lc_test values (toString('a'));\n+\n+select id from lc_test;\n+drop table if exists lc_test;\n",
  "problem_statement": "Version 21.1 Code: 49. DB::Exception: Bad cast from type DB::ColumnString to DB::ColumnLowCardinality:\n**Describe the issue**\r\nCan't insert `String` data to column with `LowCardinality` type.\r\n\r\nStarting from 21.1 this query fails\r\n\r\n**How to reproduce**\r\n```sql\r\nCREATE TABLE default.lc_test\r\n(   \r\n    `id` LowCardinality(String)\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY tuple()\r\nORDER BY id;\r\n\r\nOk.\r\n0 rows in set. Elapsed: 0.003 sec.\r\n\r\n\r\ninsert into lc_test values (toString('a'));\r\nException on client:\r\nCode: 49. DB::Exception: Bad cast from type DB::ColumnString to DB::ColumnLowCardinality: data for INSERT was parsed from query\r\n\r\n```\r\n\r\n**Additional context**\r\nrelated to issue https://github.com/DarkWanderer/ClickHouse.Client/issues/66\r\n\r\nversion 20.12 ok\n",
  "hints_text": "It happens with external params:\r\n```\r\nclickhouse-client -q'insert into default.lc_test values ( {x:String} )' --param_x=123\r\n```\r\n\r\nand it may affect different drivers (for ex. ODBC).",
  "created_at": "2021-03-01T20:12:52Z"
}