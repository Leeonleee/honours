{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35534,
  "instance_id": "ClickHouse__ClickHouse-35534",
  "issue_numbers": [
    "35528"
  ],
  "base_commit": "da235f9cda6eca4081658032ba62fc4c8aced11a",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex d1564008dfed..1ed9d6c5dd06 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -2703,13 +2703,10 @@ class FunctionCast final : public FunctionCastBase\n         return createWrapper<ToDataType>(from_type, to_type, requested_result_is_nullable);\n     }\n \n-    WrapperType createUInt8ToUInt8Wrapper(const DataTypePtr from_type, const DataTypePtr to_type) const\n+    WrapperType createUInt8ToBoolWrapper(const DataTypePtr from_type, const DataTypePtr to_type) const\n     {\n         return [from_type, to_type] (ColumnsWithTypeAndName & arguments, const DataTypePtr &, const ColumnNullable *, size_t /*input_rows_count*/) -> ColumnPtr\n         {\n-            if (isBool(from_type) || !isBool(to_type))\n-                return arguments.front().column;\n-\n             /// Special case when we convert UInt8 column to Bool column.\n             /// both columns have type UInt8, but we shouldn't use identity wrapper,\n             /// because Bool column can contain only 0 and 1.\n@@ -3506,15 +3503,19 @@ class FunctionCast final : public FunctionCastBase\n     /// 'requested_result_is_nullable' is true if CAST to Nullable type is requested.\n     WrapperType prepareImpl(const DataTypePtr & from_type, const DataTypePtr & to_type, bool requested_result_is_nullable) const\n     {\n-        bool convert_to_ipv6 = to_type->getCustomName() && to_type->getCustomName()->getName() == \"IPv6\";\n+        if (isUInt8(from_type) && isBool(to_type))\n+            return createUInt8ToBoolWrapper(from_type, to_type);\n \n-        if (from_type->equals(*to_type) && !convert_to_ipv6)\n-        {\n-            if (isUInt8(from_type))\n-                return createUInt8ToUInt8Wrapper(from_type, to_type);\n+        /// We can cast IPv6 into IPv6, IPv4 into IPv4, but we should not allow to cast FixedString(16) into IPv6 as part of identity cast\n+        bool safe_convert_custom_types = true;\n \n+        if (const auto * to_type_custom_name = to_type->getCustomName())\n+            safe_convert_custom_types = from_type->getCustomName() && from_type->getCustomName()->getName() == to_type_custom_name->getName();\n+        else if (const auto * from_type_custom_name = from_type->getCustomName())\n+            safe_convert_custom_types = to_type->getCustomName() && from_type_custom_name->getName() == to_type->getCustomName()->getName();\n+\n+        if (from_type->equals(*to_type) && safe_convert_custom_types)\n             return createIdentityWrapper(from_type);\n-        }\n         else if (WhichDataType(from_type).isNothing())\n             return createNothingWrapper(to_type.get());\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02243_in_ip_address.reference b/tests/queries/0_stateless/02243_in_ip_address.reference\nnew file mode 100644\nindex 000000000000..aa47d0d46d47\n--- /dev/null\n+++ b/tests/queries/0_stateless/02243_in_ip_address.reference\n@@ -0,0 +1,2 @@\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02243_in_ip_address.sql b/tests/queries/0_stateless/02243_in_ip_address.sql\nnew file mode 100644\nindex 000000000000..a2c8c37e585f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02243_in_ip_address.sql\n@@ -0,0 +1,9 @@\n+DROP TABLE IF EXISTS test_table;\n+CREATE TABLE test_table (id UInt64, value_ipv4 IPv4, value_ipv6 IPv6) ENGINE=MergeTree ORDER BY id;\n+\n+INSERT INTO test_table VALUES (0, '127.0.0.1', '127.0.0.1');\n+\n+SELECT id FROM test_table WHERE value_ipv4 IN (SELECT value_ipv4 FROM test_table);\n+SELECT id FROM test_table WHERE value_ipv6 IN (SELECT value_ipv6 FROM test_table);\n+\n+DROP TABLE test_table;\n",
  "problem_statement": "Invalid IPv6 value (CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING) with subquery\nInclusion (`IN`/`NOT IN`) test does not work when the subquery returns IPv6 values.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes, on version `22.3.2`.\r\n\r\n**How to reproduce**\r\n\r\nOn a stock Docker container (`clickhouse/clickhouse-server:22`):\r\n```sql\r\nCREATE TABLE IF NOT EXISTS test_ipv6 (a IPv6) ENGINE = MergeTree ORDER BY a;\r\nINSERT INTO test_ipv6 VALUES ('::ffff:1.1.1.1'),('::ffff:2.2.2.2');\r\n```\r\n\r\n```sql\r\nSELECT a FROM test_ipv6 FORMAT TabSeparated;\r\n-- ::ffff:1.1.1.1\r\n-- ::ffff:2.2.2.2\r\n-- OK!\r\n\r\nSELECT a FROM test_ipv6 WHERE a <= toIPv6('::ffff:1.1.1.1') FORMAT TabSeparated;\r\n-- ::ffff:1.1.1.1\r\n-- OK!\r\n\r\nSELECT a\r\nFROM test_ipv6\r\nWHERE a IN (\r\n    SELECT a\r\n    FROM test_ipv6\r\n    WHERE a <= toIPv6('::ffff:1.1.1.1')\r\n);\r\n-- Received exception from server (version 22.3.2):\r\n-- Code: 441. DB::Exception: Received from localhost:9000. DB::Exception: Invalid IPv6 value: while executing 'FUNCTION in(a : 0, __set :: 1) -> in(a, _subquery9) UInt8 : 2'. (CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING)\r\n```\r\n\r\n**Expected behavior**\r\n\r\nThe last query should work and return `::ffff:1.1.1.1`.\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\nReceived exception from server (version 22.3.2):\r\nCode: 441. DB::Exception: Received from localhost:9000. DB::Exception: Invalid IPv6 value: while executing 'FUNCTION in(a : 0, __set :: 1) -> in(a, _subquery9) UInt8 : 2'. (CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING)\r\n```\r\n\r\n**Additional context**\r\n\r\n- Same issue with two different tables (e.g. `test_ipv6_1` and `test_ipv6_2`).\r\n- Works on ClickHouse 21.\r\n  \n",
  "hints_text": "```sql\r\nSELECT 1 FROM test_ipv6 WHERE a IN (SELECT a FROM test_ipv6);\r\nDB::Exception: Invalid IPv6 value: while executin\r\n```",
  "created_at": "2022-03-23T14:22:55Z"
}