diff --git a/libs/libcommon/CMakeLists.txt b/libs/libcommon/CMakeLists.txt
index 6b7ff423d4a5..d35c70d05eed 100644
--- a/libs/libcommon/CMakeLists.txt
+++ b/libs/libcommon/CMakeLists.txt
@@ -20,7 +20,7 @@ endif ()
 add_library (common
     src/DateLUT.cpp
     src/DateLUTImpl.cpp
-    src/exp10.cpp
+    src/exp10.c
     src/mremap.cpp
     src/JSON.cpp
     src/getMemoryAmount.cpp
diff --git a/libs/libcommon/include/common/exp10.h b/libs/libcommon/include/common/exp10.h
index 5f053f71a205..5e5f47db3f0b 100644
--- a/libs/libcommon/include/common/exp10.h
+++ b/libs/libcommon/include/common/exp10.h
@@ -1,13 +1,19 @@
 #pragma once
 
-#include <cmath>
+/** exp10 from GNU libm fails to give precise result for integer arguments.
+  * For example, exp10(3) gives 1000.0000000000001
+  *  despite the fact that 1000 is exactly representable in double and float.
+  * Better to always use implementation from MUSL.
+  */
 
-double musl_exp10(double x);
+#include <stdlib.h> /// for __THROW
 
-#if defined(__FreeBSD__)
-#define exp10 musl_exp10
-#endif
+extern "C"
+{
 
-#ifdef __APPLE__
-#define exp10 __exp10
-#endif
+double exp10(double x) __THROW;
+double pow10(double x) __THROW;
+float exp10f(float x) __THROW;
+float pow10f(float x) __THROW;
+
+}
diff --git a/libs/libcommon/src/exp10.cpp b/libs/libcommon/src/exp10.c
similarity index 91%
rename from libs/libcommon/src/exp10.cpp
rename to libs/libcommon/src/exp10.c
index 3c58428034f3..887d543bddaa 100644
--- a/libs/libcommon/src/exp10.cpp
+++ b/libs/libcommon/src/exp10.c
@@ -169,12 +169,10 @@ obstacle to adoption, that text has been removed.
 
 */
 
-//#define _GNU_SOURCE
 #include <math.h>
 #include <stdint.h>
-//#include "libc.h"
 
-double musl_exp10(double x)
+double exp10(double x)
 {
     static const double p10[] = {
         1e-15, 1e-14, 1e-13, 1e-12, 1e-11, 1e-10,
@@ -193,5 +191,29 @@ double musl_exp10(double x)
     return pow(10.0, x);
 }
 
-//weak_alias(exp10, pow10);
+float exp10f(float x)
+{
+    static const float p10[] = {
+        1e-7f, 1e-6f, 1e-5f, 1e-4f, 1e-3f, 1e-2f, 1e-1f,
+        1, 1e1, 1e2, 1e3, 1e4, 1e5, 1e6, 1e7
+    };
+    float n, y = modff(x, &n);
+    union {float f; uint32_t i;} u = {n};
+    /* fabsf(n) < 8 without raising invalid on nan */
+    if ((u.i>>23 & 0xff) < 0x7f+3) {
+        if (!y) return p10[(int)n+7];
+        y = exp2f(3.32192809488736234787031942948939f * y);
+        return y * p10[(int)n+7];
+    }
+    return exp2(3.32192809488736234787031942948939 * x);
+}
 
+double pow10(double x)
+{
+    return exp10(x);
+}
+
+float pow10f(float x)
+{
+    return exp10f(x);
+}
