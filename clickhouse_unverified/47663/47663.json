{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47663,
  "instance_id": "ClickHouse__ClickHouse-47663",
  "issue_numbers": [
    "47393"
  ],
  "base_commit": "1656be3288cb95f38e545603dc4d4c6917ccbac8",
  "patch": "diff --git a/src/Storages/MergeTree/MutateTask.cpp b/src/Storages/MergeTree/MutateTask.cpp\nindex 9f7a12745c6f..e939e6dc39ce 100644\n--- a/src/Storages/MergeTree/MutateTask.cpp\n+++ b/src/Storages/MergeTree/MutateTask.cpp\n@@ -19,6 +19,7 @@\n #include <Storages/MergeTree/MergeTreeDataWriter.h>\n #include <Storages/MutationCommands.h>\n #include <Storages/MergeTree/MergeTreeDataMergerMutator.h>\n+#include <Storages/MergeTree/MergeTreeIndexInverted.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <boost/algorithm/string/replace.hpp>\n #include <Common/ProfileEventsScope.h>\n@@ -551,6 +552,16 @@ static NameSet collectFilesToSkip(\n         /// Since MinMax index has .idx2 extension, we need to add correct extension.\n         files_to_skip.insert(index->getFileName() + index->getSerializedFileExtension());\n         files_to_skip.insert(index->getFileName() + mrk_extension);\n+\n+        // Skip all inverted index files, for they will be rebuilt\n+        if (dynamic_cast<const MergeTreeIndexInverted *>(index.get()))\n+        {\n+            auto index_filename = index->getFileName();\n+            files_to_skip.insert(index_filename + \".gin_dict\");\n+            files_to_skip.insert(index_filename + \".gin_post\");\n+            files_to_skip.insert(index_filename + \".gin_sed\");\n+            files_to_skip.insert(index_filename + \".gin_sid\");\n+        }\n     }\n \n     for (const auto & projection : projections_to_recalc)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02346_inverted_index_mutation.reference b/tests/queries/0_stateless/02346_inverted_index_mutation.reference\nnew file mode 100644\nindex 000000000000..b80f66e4c05d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_inverted_index_mutation.reference\n@@ -0,0 +1,3 @@\n+1\n+2\n+I am not inverted\ndiff --git a/tests/queries/0_stateless/02346_inverted_index_mutation.sql b/tests/queries/0_stateless/02346_inverted_index_mutation.sql\nnew file mode 100644\nindex 000000000000..83b73807cd7f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_inverted_index_mutation.sql\n@@ -0,0 +1,25 @@\n+SET allow_experimental_inverted_index=1;\n+\n+DROP TABLE IF EXISTS t;\n+CREATE TABLE t\n+(\n+    `timestamp` UInt64,\n+    `s` String,\n+    INDEX idx s TYPE inverted(3) GRANULARITY 1\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple()\n+SETTINGS min_rows_for_wide_part = 1, min_bytes_for_wide_part = 1;\n+\n+INSERT INTO t (s) VALUES ('I am inverted');\n+\n+SELECT data_version FROM system.parts WHERE database=currentDatabase() AND table='t' AND active=1;\n+\n+-- do update column synchronously\n+ALTER TABLE t UPDATE s='I am not inverted' WHERE 1 SETTINGS mutations_sync=1;\n+\n+SELECT data_version FROM system.parts WHERE database=currentDatabase() AND table='t' AND active=1;\n+\n+SELECT s FROM t WHERE s LIKE '%inverted%' SETTINGS force_data_skipping_indices='idx';\n+\n+DROP TABLE t;\n",
  "problem_statement": "inverted index bug on segment id\n**Describe what's wrong**\r\nAs in title.\r\n\r\n**Does it reproduce on recent release?**\r\nYes.\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nset allow_experimental_inverted_index=1;\r\nCREATE TABLE t\r\n(\r\n    `timestamp` UInt64,\r\n    `s` String,\r\n    INDEX idx lower(s) TYPE inverted(3) GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toDate(timestamp) -- partitioning may be necessary\r\nORDER BY toDate(timestamp)\r\nSETTINGS min_rows_for_wide_part = 1, min_bytes_for_wide_part = 1; -- these settings are necessary\r\n\r\nINSERT INTO t (s) SELECT * FROM generateRandom('s String') LIMIT 100;\r\n\r\n-- do update column\r\nALTER TABLE t UPDATE flag=1 WHERE 1;\r\n-- wait for mutation to finish on at least 1 part\r\nSELECT sleepEachRow(1) FROM t LIMIT 3;\r\n\r\nSELECT * FROM t WHERE lower(s) LIKE '%iamok%';\r\n```\r\nsee [ClickFiddle](https://fiddle.clickhouse.com/8eb0e0ed-8ec2-4326-8880-3ecb0bec1747)\r\n\r\nresult:\r\n```\r\n[chi-datalake-ck-cluster-2-0-0] 2023.03.09 16:34:23.859618 [ 388 ] {f78d765e-4cec-4cfd-a49c-6379667f915b} <Error> executeQuery: Code: 49. DB::Exception: Invalid segment id 1. (LOGICAL_ERROR) (version 23.2.3.17 (official build)) (from 127.0.0.1:43318) (in query: SELECT * FROM t WHERE lower(s) LIKE '%iamnotok%'), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0xe0c67d5 in /usr/bin/clickhouse\r\n1. ? @ 0xee7502f in /usr/bin/clickhouse\r\n2. DB::GinIndexStoreDeserializer::readSegmentDictionary(unsigned int) @ 0x141f106a in /usr/bin/clickhouse\r\n3. DB::GinIndexStoreFactory::get(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::shared_ptr<DB::IDataPartStorage const>) @ 0x141f2e36 in /usr/bin/clickhouse\r\n4. DB::MergeTreeDataSelectExecutor::filterMarksUsingIndex(std::__1::shared_ptr<DB::IMergeTreeIndex const>, std::__1::shared_ptr<DB::IMergeTreeIndexCondition>, std::__1::shared_ptr<DB::IMergeTreeDataPart const>, DB::MarkRanges const&, DB::Settings const&, DB::MergeTreeReaderSettings const&, unsigned long&, unsigned long&, DB::MarkCache*, DB::UncompressedCache*, Poco::Logger*) @ 0x14330bcc in /usr/bin/clickhouse\r\n5. ? @ 0x1432d83d in /usr/bin/clickhouse\r\n6. DB::MergeTreeDataSelectExecutor::filterPartsByPrimaryKeyAndSkipIndexes(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const>>>&&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const>, DB::SelectQueryInfo const&, std::__1::shared_ptr<DB::Context const> const&, DB::KeyCondition const&, DB::MergeTreeReaderSettings const&, Poco::Logger*, unsigned long, std::__1::vector<DB::ReadFromMergeTree::IndexStat, std::__1::allocator<DB::ReadFromMergeTree::IndexStat>>&, bool) @ 0x1432b1bb in /usr/bin/clickhouse\r\n7. DB::ReadFromMergeTree::selectRangesToReadImpl(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const>>>, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, DB::SelectQueryInfo const&, std::__1::shared_ptr<DB::Context const>, unsigned long, std::__1::shared_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, long, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, long>>>>, DB::MergeTreeData const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, bool, Poco::Logger*) @ 0x14aea48e in /usr/bin/clickhouse\r\n8. DB::ReadFromMergeTree::selectRangesToRead(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const>>>, std::__1::shared_ptr<DB::PrewhereInfo> const&, DB::ActionDAGNodes const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::__1::shared_ptr<DB::StorageInMemoryMetadata const> const&, DB::SelectQueryInfo const&, std::__1::shared_ptr<DB::Context const>, unsigned long, std::__1::shared_ptr<std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, long, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const, long>>>>, DB::MergeTreeData const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&, bool, Poco::Logger*) @ 0x14ae875f in /usr/bin/clickhouse\r\n9. DB::ReadFromMergeTree::selectRangesToRead(std::__1::vector<std::__1::shared_ptr<DB::IMergeTreeDataPart const>, std::__1::allocator<std::__1::shared_ptr<DB::IMergeTreeDataPart const>>>) const @ 0x14ae7366 in /usr/bin/clickhouse\r\n10. DB::ReadFromMergeTree::getAnalysisResult() const @ 0x14aed196 in /usr/bin/clickhouse\r\n11. DB::ReadFromMergeTree::initializePipeline(DB::QueryPipelineBuilder&, DB::BuildQueryPipelineSettings const&) @ 0x14aef2a9 in /usr/bin/clickhouse\r\n12. DB::ISourceStep::updatePipeline(std::__1::vector<std::__1::unique_ptr<DB::QueryPipelineBuilder, std::__1::default_delete<DB::QueryPipelineBuilder>>, std::__1::allocator<std::__1::unique_ptr<DB::QueryPipelineBuilder, std::__1::default_delete<DB::QueryPipelineBuilder>>>>, DB::BuildQueryPipelineSettings const&) @ 0x14ab4814 in /usr/bin/clickhouse\r\n13. DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&) @ 0x14ace149 in /usr/bin/clickhouse\r\n14. DB::InterpreterSelectWithUnionQuery::execute() @ 0x1365c72d in /usr/bin/clickhouse\r\n15. ? @ 0x1397b559 in /usr/bin/clickhouse\r\n16. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x1397862d in /usr/bin/clickhouse\r\n17. DB::TCPHandler::runImpl() @ 0x146ff144 in /usr/bin/clickhouse\r\n18. DB::TCPHandler::run() @ 0x14713979 in /usr/bin/clickhouse\r\n19. Poco::Net::TCPServerConnection::start() @ 0x17614454 in /usr/bin/clickhouse\r\n20. Poco::Net::TCPServerDispatcher::run() @ 0x1761567b in /usr/bin/clickhouse\r\n21. Poco::PooledThread::run() @ 0x1779ca07 in /usr/bin/clickhouse\r\n22. Poco::ThreadImpl::runnableEntry(void*) @ 0x1779a43d in /usr/bin/clickhouse\r\n23. ? @ 0x7f8809b7d609 in ?\r\n24. clone @ 0x7f8809aa2133 in ?\r\n\r\n\r\n0 rows in set. Elapsed: 0.004 sec.\r\n\r\nReceived exception from server (version 23.2.3):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Invalid segment id 1. (LOGICAL_ERROR)\r\n```\r\n\n",
  "hints_text": "inspecting the `gin_sid` file, we can find that the id increases on each `ALTER TABLE UPDATE` mutation.\r\n\r\n```sh\r\n# execute this command in table directory `/var/lib/default/t/`, to check gin_sid\r\nfor d in $(ls | grep 197); do echo -en \"$d \\t\"; cat $d/skp_idx_idx.gin_sid | od -An; done\r\n```\r\nwhile the gin_sid files are expected to not change their content (if number of segments not changed).\r\n\r\nthe bug may result from:\r\nhttps://github.com/ClickHouse/ClickHouse/blob/65d671b7c72c7b1da23f831faa877565cf34f92c/src/Storages/MergeTree/GinIndexStore.cpp#L171-L191\r\n\r\nwhere the id is read and simply incremented out of boundary.\n@larryluogit maybe we need your help.",
  "created_at": "2023-03-17T02:08:11Z",
  "modified_files": [
    "src/Storages/MergeTree/MutateTask.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02346_inverted_index_mutation.reference",
    "b/tests/queries/0_stateless/02346_inverted_index_mutation.sql"
  ]
}