{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36562,
  "instance_id": "ClickHouse__ClickHouse-36562",
  "issue_numbers": [
    "36354"
  ],
  "base_commit": "11f40376aec4cfacd94d5e8c038f640167ee98bd",
  "patch": "diff --git a/src/TableFunctions/ITableFunctionFileLike.cpp b/src/TableFunctions/ITableFunctionFileLike.cpp\nindex cf4a62a30f47..7fa3ccda195e 100644\n--- a/src/TableFunctions/ITableFunctionFileLike.cpp\n+++ b/src/TableFunctions/ITableFunctionFileLike.cpp\n@@ -25,6 +25,17 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+void ITableFunctionFileLike::parseFirstArguments(const ASTPtr & arg, ContextPtr context)\n+{\n+    auto ast = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n+    filename = ast->as<ASTLiteral &>().value.safeGet<String>();\n+}\n+\n+String ITableFunctionFileLike::getFormatFromFirstArgument()\n+{\n+    return FormatFactory::instance().getFormatFromFileName(filename, true);\n+}\n+\n void ITableFunctionFileLike::parseArguments(const ASTPtr & ast_function, ContextPtr context)\n {\n     /// Parse args\n@@ -38,16 +49,16 @@ void ITableFunctionFileLike::parseArguments(const ASTPtr & ast_function, Context\n     if (args.empty())\n         throw Exception(\"Table function '\" + getName() + \"' requires at least 1 argument\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-    for (auto & arg : args)\n-        arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n+    parseFirstArguments(args[0], context);\n \n-    filename = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+    for (size_t i = 1; i < args.size(); ++i)\n+        args[i] = evaluateConstantExpressionOrIdentifierAsLiteral(args[i], context);\n \n     if (args.size() > 1)\n         format = args[1]->as<ASTLiteral &>().value.safeGet<String>();\n \n     if (format == \"auto\")\n-        format = FormatFactory::instance().getFormatFromFileName(filename, true);\n+        format = getFormatFromFirstArgument();\n \n     if (args.size() <= 2)\n         return;\ndiff --git a/src/TableFunctions/ITableFunctionFileLike.h b/src/TableFunctions/ITableFunctionFileLike.h\nindex cd85f20fdc00..88ad75b10180 100644\n--- a/src/TableFunctions/ITableFunctionFileLike.h\n+++ b/src/TableFunctions/ITableFunctionFileLike.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <TableFunctions/ITableFunction.h>\n+#include \"Parsers/IAST_fwd.h\"\n \n namespace DB\n {\n@@ -19,6 +20,8 @@ class ITableFunctionFileLike : public ITableFunction\n \n protected:\n     void parseArguments(const ASTPtr & ast_function, ContextPtr context) override;\n+    virtual void parseFirstArguments(const ASTPtr & arg, ContextPtr context);\n+    virtual String getFormatFromFirstArgument();\n \n     String filename;\n     String format = \"auto\";\ndiff --git a/src/TableFunctions/TableFunctionFile.cpp b/src/TableFunctions/TableFunctionFile.cpp\nindex b09bb8b6ae1c..146e59a82650 100644\n--- a/src/TableFunctions/TableFunctionFile.cpp\n+++ b/src/TableFunctions/TableFunctionFile.cpp\n@@ -1,16 +1,74 @@\n #include <TableFunctions/TableFunctionFile.h>\n #include <TableFunctions/parseColumnsListForTableFunction.h>\n \n+#include \"Parsers/IAST_fwd.h\"\n #include \"registerTableFunctions.h\"\n #include <Access/Common/AccessFlags.h>\n #include <Interpreters/Context.h>\n #include <Storages/ColumnsDescription.h>\n #include <Storages/StorageFile.h>\n #include <TableFunctions/TableFunctionFactory.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+#include <Formats/FormatFactory.h>\n+#include <Parsers/ASTIdentifier_fwd.h>\n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+void TableFunctionFile::parseFirstArguments(const ASTPtr & arg, ContextPtr context)\n+{\n+    if (context->getApplicationType() != Context::ApplicationType::LOCAL)\n+    {\n+        ITableFunctionFileLike::parseFirstArguments(arg, context);\n+        return;\n+    }\n+\n+    if (auto opt_name = tryGetIdentifierName(arg))\n+    {\n+        if (*opt_name == \"stdin\")\n+            fd = STDIN_FILENO;\n+        else if (*opt_name == \"stdout\")\n+            fd = STDOUT_FILENO;\n+        else if (*opt_name == \"stderr\")\n+            fd = STDERR_FILENO;\n+        else\n+            filename = *opt_name;\n+    }\n+    else if (const auto * literal = arg->as<ASTLiteral>())\n+    {\n+        auto type = literal->value.getType();\n+        if (type == Field::Types::Int64 || type == Field::Types::UInt64)\n+        {\n+            fd = (type == Field::Types::Int64) ? static_cast<int>(literal->value.get<Int64>()) : static_cast<int>(literal->value.get<UInt64>());\n+            if (fd < 0)\n+                throw Exception(\"File descriptor must be non-negative\", ErrorCodes::BAD_ARGUMENTS);\n+        }\n+        else if (type == Field::Types::String)\n+        {\n+            filename = literal->value.get<String>();\n+            if (filename == \"-\")\n+                fd = STDIN_FILENO;\n+        }\n+        else\n+            throw Exception(\n+                \"The first argument of table function '\" + getName() + \"' mush be path or file descriptor\", ErrorCodes::BAD_ARGUMENTS);\n+    }\n+}\n+\n+String TableFunctionFile::getFormatFromFirstArgument()\n+{\n+    if (fd >= 0)\n+        return FormatFactory::instance().getFormatFromFileDescriptor(fd);\n+    else\n+        return FormatFactory::instance().getFormatFromFileName(filename, true);\n+}\n+\n StoragePtr TableFunctionFile::getStorage(const String & source,\n     const String & format_, const ColumnsDescription & columns,\n     ContextPtr global_context, const std::string & table_name,\n@@ -28,6 +86,8 @@ StoragePtr TableFunctionFile::getStorage(const String & source,\n         ConstraintsDescription{},\n         String{},\n     };\n+    if (fd >= 0)\n+        return StorageFile::create(fd, args);\n \n     return StorageFile::create(source, global_context->getUserFilesPath(), args);\n }\n@@ -36,6 +96,9 @@ ColumnsDescription TableFunctionFile::getActualTableStructure(ContextPtr context\n {\n     if (structure == \"auto\")\n     {\n+        if (fd >= 0)\n+            throw Exception(\n+                \"Schema inference is not supported for table function '\" + getName() + \"' with file descriptor\", ErrorCodes::LOGICAL_ERROR);\n         size_t total_bytes_to_read = 0;\n         Strings paths = StorageFile::getPathsList(filename, context->getUserFilesPath(), context, total_bytes_to_read);\n         return StorageFile::getTableStructureFromFile(format, paths, compression_method, std::nullopt, context);\ndiff --git a/src/TableFunctions/TableFunctionFile.h b/src/TableFunctions/TableFunctionFile.h\nindex f26e4a9c06d3..f956043e69a1 100644\n--- a/src/TableFunctions/TableFunctionFile.h\n+++ b/src/TableFunctions/TableFunctionFile.h\n@@ -22,6 +22,11 @@ class TableFunctionFile : public ITableFunctionFileLike\n \n     ColumnsDescription getActualTableStructure(ContextPtr context) const override;\n \n+protected:\n+    int fd = -1;\n+    void parseFirstArguments(const ASTPtr & arg, ContextPtr context) override;\n+    String getFormatFromFirstArgument() override;\n+\n private:\n     StoragePtr getStorage(\n         const String & source, const String & format_, const ColumnsDescription & columns, ContextPtr global_context,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02286_use_file_descriptor_in_table_function_file.reference b/tests/queries/0_stateless/02286_use_file_descriptor_in_table_function_file.reference\nnew file mode 100644\nindex 000000000000..b4f55f2fac4c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02286_use_file_descriptor_in_table_function_file.reference\n@@ -0,0 +1,8 @@\n+1\t2\n+3\t4\n+1\t2\n+3\t4\n+1\t2\n+3\t4\n+1\t2\n+3\t4\ndiff --git a/tests/queries/0_stateless/02286_use_file_descriptor_in_table_function_file.sh b/tests/queries/0_stateless/02286_use_file_descriptor_in_table_function_file.sh\nnew file mode 100755\nindex 000000000000..71067d867292\n--- /dev/null\n+++ b/tests/queries/0_stateless/02286_use_file_descriptor_in_table_function_file.sh\n@@ -0,0 +1,15 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+echo -e \"1,2\\n3,4\" > 02286_data.csv\n+\n+$CLICKHOUSE_LOCAL --query \"SELECT * FROM file(0, CSV)\" < 02286_data.csv\n+$CLICKHOUSE_LOCAL --query \"SELECT * FROM file(stdin, CSV)\" < 02286_data.csv\n+$CLICKHOUSE_LOCAL --query \"SELECT * FROM file('-', CSV)\" < 02286_data.csv\n+$CLICKHOUSE_LOCAL --query \"SELECT * FROM file(5, CSV)\" 5< 02286_data.csv\n+\n+rm 02286_data.csv\n",
  "problem_statement": "Allow file descriptors in table function `file` if it is run in `clickhouse-local`\n**Use case**\r\n\r\n```\r\nclickhouse-local --query \"SELECT * FROM file(0, JSONEachRow)\" < something\r\n```\r\n\r\n**Additional context**\r\n\r\nI also tried other intuitive options:\r\n```\r\nclickhouse-local --query \"SELECT * FROM file(stdin, JSONEachRow)\" < something\r\nclickhouse-local --query \"SELECT * FROM file('-', JSONEachRow)\" < something\r\n```\r\n\r\nAlthough this works:\r\n```\r\nclickhouse-local --query \"SELECT * FROM file('/dev/stdin', JSONEachRow)\"\r\n```\r\n\r\nI think, solution with numeric file descriptors should be supported, as we already support it for `File` table engine,\r\nand it is also useful if a script is opening file descriptors with higher numbers like\r\n\r\n```\r\nclickhouse-local --query \"SELECT * FROM file(5, JSONEachRow)\" 5<test\r\n```\r\n\r\nNote: it is already possible to process stdin in clickhouse-local and it is also intuitive and convenient:\r\n\r\n```\r\nclickhouse-local --query \"SELECT * table\" < something\r\n```\r\n\r\nI just want other ways to work consistently.\n",
  "hints_text": "Hello, I'd like to take this task, can you assign the issue to me ?\n@wuxiaobai24 \r\nIt will be amazing!",
  "created_at": "2022-04-23T03:04:18Z"
}