diff --git a/base/base/DecomposedFloat.h b/base/base/DecomposedFloat.h
index fef91adefb0a..b7b57278a5a1 100644
--- a/base/base/DecomposedFloat.h
+++ b/base/base/DecomposedFloat.h
@@ -10,6 +10,17 @@
 
 template <typename T> struct FloatTraits;
 
+struct Float16Tag;
+
+template <>
+struct FloatTraits<Float16Tag>
+{
+    using UInt = uint16_t;
+    static constexpr size_t bits = 16;
+    static constexpr size_t exponent_bits = 5;
+    static constexpr size_t mantissa_bits = bits - exponent_bits - 1;
+};
+
 template <>
 struct FloatTraits<BFloat16>
 {
@@ -50,6 +61,10 @@ struct DecomposedFloat
         memcpy(&x_uint, &x, sizeof(x));
     }
 
+    explicit DecomposedFloat(typename Traits::UInt x) : x_uint(x)
+    {
+    }
+
     typename Traits::UInt x_uint;
 
     bool isNegative() const
@@ -67,7 +82,7 @@ struct DecomposedFloat
 
     uint16_t exponent() const
     {
-        return (x_uint >> (Traits::mantissa_bits)) & (((1ull << (Traits::exponent_bits + 1)) - 1) >> 1);
+        return (x_uint >> (Traits::mantissa_bits)) & ((1ull << Traits::exponent_bits) - 1);
     }
 
     int16_t normalizedExponent() const
@@ -230,4 +245,3 @@ struct DecomposedFloat
 
 using DecomposedFloat64 = DecomposedFloat<double>;
 using DecomposedFloat32 = DecomposedFloat<float>;
-using DecomposedFloat16 = DecomposedFloat<BFloat16>;
diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md
index b8d16debbacc..116cf482b0f8 100644
--- a/docs/en/interfaces/formats.md
+++ b/docs/en/interfaces/formats.md
@@ -2449,6 +2449,8 @@ Unsupported Arrow data types: `FIXED_SIZE_BINARY`, `JSON`, `UUID`, `ENUM`.
 
 The data types of ClickHouse table columns do not have to match the corresponding Arrow data fields. When inserting data, ClickHouse interprets data types according to the table above and then [casts](/docs/en/sql-reference/functions/type-conversion-functions.md/#type_conversion_function-cast) the data to the data type set for the ClickHouse table column.
 
+Keep in mind that the HALF_FLOAT data type is converted to Float32 while reading. This is needed, because it represents the IEEE-754 16-bit floating point value, not the BFloat16 format (more popular in AI and ML applications) which ClickHouse supports. 
+
 ### Inserting Data {#inserting-data-arrow}
 
 You can insert Arrow data from a file into ClickHouse table by the following command:
diff --git a/src/Common/FloatUtils.h b/src/Common/FloatUtils.h
new file mode 100644
index 000000000000..03ec55079c0f
--- /dev/null
+++ b/src/Common/FloatUtils.h
@@ -0,0 +1,48 @@
+#pragma once
+
+#include <cstdint>
+#include <bit>
+
+
+inline float convertFloat16ToFloat32(uint16_t float16_value)
+{
+    uint32_t old_sign = (float16_value & 0b10000000'00000000);
+    uint32_t old_exponent = (float16_value & 0b01111100'00000000) >> 10;
+    uint32_t old_mantissa = float16_value & 0b00000011'11111111;
+
+    uint32_t new_exponent;
+    uint32_t new_mantissa;
+    uint32_t new_sign = old_sign << 16;
+
+    if (unlikely(old_exponent == 0x1F))
+    {
+        /// Inf, NaN
+        new_exponent = 0xFFu << 23;
+        new_mantissa = old_mantissa << 13;
+    }
+    else if (old_exponent == 0)
+    {
+        if (likely(old_mantissa == 0))
+        {
+            /// Zeros
+            new_exponent = 0;
+            new_mantissa = 0;
+        }
+        else
+        {
+            /// Subnormals
+            uint32_t adjustment = __builtin_clz(old_mantissa) - 22;
+            new_exponent = (112 - adjustment) << 23;
+            new_mantissa = (old_mantissa ^ (1 << (9 - adjustment))) << 13 << adjustment;
+        }
+    }
+    else
+    {
+        /// Normals
+        new_exponent = (old_exponent + 112) << 23;
+        new_mantissa = old_mantissa << 13;
+    }
+
+    uint32_t float32_value = new_sign | new_exponent | new_mantissa;
+    return std::bit_cast<float>(float32_value);
+}
diff --git a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp
index 034a778c9b24..6a955e4ff59e 100644
--- a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp
+++ b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp
@@ -30,7 +30,7 @@
 #include <Columns/ColumnLowCardinality.h>
 #include <Columns/ColumnUnique.h>
 #include <Columns/ColumnMap.h>
-#include <Columns/ColumnsNumber.h>
+#include <Common/FloatUtils.h>
 #include <Columns/ColumnNothing.h>
 #include <Interpreters/castColumn.h>
 #include <Common/quoteString.h>
@@ -38,9 +38,9 @@
 #include <algorithm>
 #include <arrow/builder.h>
 #include <arrow/array.h>
-#include <boost/algorithm/string.hpp>
 #include <boost/algorithm/string/case_conv.hpp>
 
+
 /// UINT16 and UINT32 are processed separately, see comments in readColumnFromArrowColumn.
 #define FOR_ARROW_NUMERIC_TYPES(M) \
         M(arrow::Type::UINT8, UInt8) \
@@ -49,7 +49,6 @@
         M(arrow::Type::UINT64, UInt64) \
         M(arrow::Type::INT64, Int64) \
         M(arrow::Type::DURATION, Int64) \
-        M(arrow::Type::HALF_FLOAT, Float32) \
         M(arrow::Type::FLOAT, Float32) \
         M(arrow::Type::DOUBLE, Float64)
 
@@ -418,6 +417,21 @@ static ColumnWithTypeAndName readColumnWithDecimalDataImpl(const std::shared_ptr
     return {std::move(internal_column), internal_type, column_name};
 }
 
+static ColumnWithTypeAndName readColumnWithFloat16Data(const std::shared_ptr<arrow::ChunkedArray> & arrow_column, const String & column_name)
+{
+    auto column = ColumnFloat32::create();
+    auto & column_data = column->getData();
+    column_data.reserve(arrow_column->length());
+
+    for (int chunk_i = 0, num_chunks = arrow_column->num_chunks(); chunk_i < num_chunks; ++chunk_i)
+    {
+        auto & chunk = dynamic_cast<arrow::HalfFloatArray &>(*(arrow_column->chunk(chunk_i)));
+        for (size_t value_i = 0, length = static_cast<size_t>(chunk.length()); value_i < length; ++value_i)
+            column_data.emplace_back(chunk.IsNull(value_i) ? 0 : convertFloat16ToFloat32(chunk.Value(value_i)));
+    }
+    return {std::move(column), std::make_shared<DataTypeFloat32>(), column_name};
+}
+
 template <typename DecimalArray>
 static ColumnWithTypeAndName readColumnWithDecimalData(const std::shared_ptr<arrow::ChunkedArray> & arrow_column, const String & column_name)
 {
@@ -1062,6 +1076,10 @@ static ColumnWithTypeAndName readNonNullableColumnFromArrowColumn(
             return readColumnWithNumericData<CPP_NUMERIC_TYPE>(arrow_column, column_name);
         FOR_ARROW_NUMERIC_TYPES(DISPATCH)
 #    undef DISPATCH
+        case arrow::Type::HALF_FLOAT:
+        {
+            return readColumnWithFloat16Data(arrow_column, column_name);
+        }
         case arrow::Type::TIME32:
         {
             return readColumnWithTime32Data(arrow_column, column_name);
diff --git a/src/Processors/Formats/Impl/NpyRowInputFormat.cpp b/src/Processors/Formats/Impl/NpyRowInputFormat.cpp
index acff1b4f38f9..6a6afc645139 100644
--- a/src/Processors/Formats/Impl/NpyRowInputFormat.cpp
+++ b/src/Processors/Formats/Impl/NpyRowInputFormat.cpp
@@ -8,7 +8,7 @@
 #include <Columns/ColumnFixedString.h>
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnArray.h>
-#include <Columns/ColumnsNumber.h>
+#include <Common/FloatUtils.h>
 #include <DataTypes/IDataType.h>
 #include <IO/ReadBuffer.h>
 #include <boost/algorithm/string/split.hpp>
@@ -30,46 +30,6 @@ namespace ErrorCodes
 namespace
 {
 
-float convertFloat16ToFloat32(uint16_t float16_value)
-{
-    uint16_t sign = (float16_value >> 15) & 0x1;
-    uint16_t exponent = (float16_value >> 10) & 0x1F;
-    uint16_t fraction = float16_value & 0x3FF;
-
-    if (exponent == 0 && fraction == 0)
-    {
-        uint32_t float32_value = sign << 31;
-        return std::bit_cast<float>(float32_value);
-    }
-
-    // Handling special cases for exponent
-    if (exponent == 0x1F)
-    {
-        // NaN or Infinity in float16
-        return (fraction == 0) ? std::numeric_limits<float>::infinity() : std::numeric_limits<float>::quiet_NaN();
-    }
-
-    // Convert exponent from float16 to float32 format
-    int32_t new_exponent = static_cast<int32_t>(exponent) - 15 + 127;
-
-    // Constructing the float32 representation
-    uint32_t float32_value = (static_cast<uint32_t>(sign) << 31) |
-                             (static_cast<uint32_t>(new_exponent) << 23) |
-                             (static_cast<uint32_t>(fraction) << 13);
-
-    // Interpret the binary representation as a float
-    float result;
-    std::memcpy(&result, &float32_value, sizeof(float));
-
-    // Determine decimal places dynamically based on the magnitude of the number
-    int decimal_places = std::max(0, 6 - static_cast<int>(std::log10(std::abs(result))));
-    // Truncate the decimal part to the determined number of decimal places
-    float multiplier = static_cast<float>(std::pow(10.0f, decimal_places));
-    result = std::round(result * multiplier) / multiplier;
-
-    return result;
-}
-
 DataTypePtr getDataTypeFromNumpyType(const std::shared_ptr<NumpyDataType> & numpy_type)
 {
     switch (numpy_type->getTypeIndex())
