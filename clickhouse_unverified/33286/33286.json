{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33286,
  "instance_id": "ClickHouse__ClickHouse-33286",
  "issue_numbers": [
    "31979"
  ],
  "base_commit": "9e83e5f7f4f1f611b1f6e8289a0bab5f1a42dc14",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 8018fa8e7260..62e62b5f5dcb 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1835,6 +1835,8 @@ class FunctionConvertFromString : public IFunction\n     size_t getNumberOfArguments() const override { return 0; }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n+    bool canBeExecutedOnDefaultArguments() const override { return false; }\n+\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02155_parse_date_lowcard_default_throw.reference b/tests/queries/0_stateless/02155_parse_date_lowcard_default_throw.reference\nnew file mode 100644\nindex 000000000000..e599dcc71e56\n--- /dev/null\n+++ b/tests/queries/0_stateless/02155_parse_date_lowcard_default_throw.reference\n@@ -0,0 +1,1 @@\n+2016-07-15 00:00:00\ndiff --git a/tests/queries/0_stateless/02155_parse_date_lowcard_default_throw.sql b/tests/queries/0_stateless/02155_parse_date_lowcard_default_throw.sql\nnew file mode 100644\nindex 000000000000..703cf1fed7a4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02155_parse_date_lowcard_default_throw.sql\n@@ -0,0 +1,1 @@\n+SELECT parseDateTimeBestEffort(toLowCardinality(materialize('15-JUL-16')));\n",
  "problem_statement": "Error when parseDateTimeBestEffort is invoked on LowCardinality column from the joined subquery\n**Describe what's wrong**\r\nparseDateTimeBestEffort  does not work when invoked on a LowCardinality column from the joined subquery\r\n\r\n**Does it reproduce on recent release?**\r\nHave not tried\r\n\r\n**How to reproduce**\r\nFollowing sql query does not work:\r\n```sql\r\nSELECT parseDateTimeBestEffort(q0.date_field) as parsed_date\r\nFROM (SELECT 1 as pk1) t1\r\ninner join (\r\nSELECT 1 as pk1, toLowCardinality('15-JUL-16') as date_field\r\n) q0 on q0.pk1 = t1.pk1;\r\n```\r\n\r\n> e.displayText() = DB::ParsingException: Cannot read DateTime: neither Date nor Time was parsed successfully: while executing 'FUNCTION parseDateTimeBestEffort(date_field :: 0) -> parseDateTimeBestEffort(date_field) LowCardinality(DateTime) : 1' (version 21.3.12.2 (official build))\r\n\r\n**Expected behavior**\r\nShould work the same way as for following queries:\r\n```sql\r\nSELECT parseDateTimeBestEffort('12-JUL-16') as parsed_date;\r\n-- |parsed_date|\r\n-- |2016-07-12 00:00:00|\r\n\r\nSELECT parseDateTimeBestEffort(toLowCardinality('13-JUL-16')) as parsed_date;\r\n-- |parsed_date|\r\n-- |2016-07-13 00:00:00|\r\n\r\nSELECT parseDateTimeBestEffort(date_field) as parsed_date\r\nFROM (\r\nSELECT toInt64(330733) as pk1, toLowCardinality('14-JUL-16') as date_field\r\n);\r\n-- |parsed_date|\r\n-- |2016-07-14 00:00:00|\r\n```\n",
  "hints_text": "Actually there is a workaround:\r\n```sql\r\nSELECT\r\n\tparseDateTimeBestEffort(CAST(q0.date_field as String)) as parsed_date\r\nFROM (SELECT 1 as pk1) t1\r\ninner join (\r\n\tSELECT 1 as pk1, toLowCardinality('15-JUL-16') as date_field\r\n) q0 on q0.pk1 = t1.pk1;\r\n```",
  "created_at": "2021-12-29T10:41:55Z"
}