diff --git a/programs/server/config.xml b/programs/server/config.xml
index dcb8ac0804c9..7f3a749b629e 100644
--- a/programs/server/config.xml
+++ b/programs/server/config.xml
@@ -1173,6 +1173,18 @@
         <flush_interval_milliseconds>7500</flush_interval_milliseconds>
     </processors_profile_log>
 
+    <!-- Log of asynchronous inserts. It allows to check status
+         of insert query in fire-and-forget mode.
+    -->
+    <asynchronous_insert_log>
+        <database>system</database>
+        <table>asynchronous_insert_log</table>
+
+        <flush_interval_milliseconds>7500</flush_interval_milliseconds>
+        <partition_by>event_date</partition_by>
+        <ttl>event_date + INTERVAL 3 DAY</ttl>
+    </asynchronous_insert_log>
+
     <!-- <top_level_domains_path>/var/lib/clickhouse/top_level_domains/</top_level_domains_path> -->
     <!-- Custom TLD lists.
          Format: <name>/path/to/file</name>
diff --git a/src/Common/DateLUT.h b/src/Common/DateLUT.h
index edf09250e6ac..b7ba37c2becc 100644
--- a/src/Common/DateLUT.h
+++ b/src/Common/DateLUT.h
@@ -55,3 +55,23 @@ class DateLUT : private boost::noncopyable
 
     std::atomic<const DateLUTImpl *> default_impl;
 };
+
+inline UInt64 timeInMilliseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
+{
+    return std::chrono::duration_cast<std::chrono::milliseconds>(timepoint.time_since_epoch()).count();
+}
+
+inline UInt64 timeInMicroseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
+{
+    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
+}
+
+inline UInt64 timeInSeconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
+{
+    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
+}
+
+inline UInt64 timeInNanoseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
+{
+    return std::chrono::duration_cast<std::chrono::nanoseconds>(timepoint.time_since_epoch()).count();
+}
diff --git a/src/Common/SystemLogBase.cpp b/src/Common/SystemLogBase.cpp
index 791f976d5e0d..3e570ac482aa 100644
--- a/src/Common/SystemLogBase.cpp
+++ b/src/Common/SystemLogBase.cpp
@@ -13,6 +13,7 @@
 #include <Interpreters/ProcessorsProfileLog.h>
 #include <Interpreters/ZooKeeperLog.h>
 #include <Interpreters/TransactionsInfoLog.h>
+#include <Interpreters/AsynchronousInsertLog.h>
 
 #include <Common/MemoryTrackerBlockerInThread.h>
 #include <Common/SystemLogBase.h>
diff --git a/src/Common/SystemLogBase.h b/src/Common/SystemLogBase.h
index 2f9d58770e6b..8813e5180b06 100644
--- a/src/Common/SystemLogBase.h
+++ b/src/Common/SystemLogBase.h
@@ -27,7 +27,8 @@
     M(ZooKeeperLogElement) \
     M(ProcessorProfileLogElement) \
     M(TextLogElement) \
-    M(FilesystemCacheLogElement)
+    M(FilesystemCacheLogElement) \
+    M(AsynchronousInsertLogElement)
 
 namespace Poco
 {
diff --git a/src/Interpreters/AsynchronousInsertLog.cpp b/src/Interpreters/AsynchronousInsertLog.cpp
new file mode 100644
index 000000000000..916ec8f3d567
--- /dev/null
+++ b/src/Interpreters/AsynchronousInsertLog.cpp
@@ -0,0 +1,82 @@
+#include <Interpreters/AsynchronousInsertLog.h>
+
+#include <DataTypes/DataTypeDate.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <DataTypes/DataTypeDateTime64.h>
+#include <DataTypes/DataTypeLowCardinality.h>
+#include <DataTypes/DataTypeString.h>
+#include <DataTypes/DataTypesNumber.h>
+#include <DataTypes/DataTypeEnum.h>
+#include <Parsers/ASTInsertQuery.h>
+#include <Parsers/queryToString.h>
+
+
+namespace DB
+{
+
+NamesAndTypesList AsynchronousInsertLogElement::getNamesAndTypes()
+{
+    auto type_status = std::make_shared<DataTypeEnum8>(
+        DataTypeEnum8::Values
+        {
+            {"Ok",           static_cast<Int8>(Status::Ok)},
+            {"ParsingError", static_cast<Int8>(Status::ParsingError)},
+            {"FlushError",   static_cast<Int8>(Status::FlushError)},
+        });
+
+    return
+    {
+        {"event_date", std::make_shared<DataTypeDate>()},
+        {"event_time", std::make_shared<DataTypeDateTime>()},
+        {"event_time_microseconds", std::make_shared<DataTypeDateTime64>(6)},
+
+        {"query", std::make_shared<DataTypeString>()},
+        {"database", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},
+        {"table", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},
+        {"format", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},
+        {"query_id", std::make_shared<DataTypeString>()},
+        {"bytes", std::make_shared<DataTypeUInt64>()},
+        {"exception", std::make_shared<DataTypeString>()},
+        {"status", type_status},
+
+        {"flush_time", std::make_shared<DataTypeDateTime>()},
+        {"flush_time_microseconds", std::make_shared<DataTypeDateTime64>(6)},
+        {"flush_query_id", std::make_shared<DataTypeString>()},
+    };
+}
+
+void AsynchronousInsertLogElement::appendToBlock(MutableColumns & columns) const
+{
+    size_t i = 0;
+
+    auto event_date = DateLUT::instance().toDayNum(event_time).toUnderType();
+    columns[i++]->insert(event_date);
+    columns[i++]->insert(event_time);
+    columns[i++]->insert(event_time_microseconds);
+
+    const auto & insert_query = assert_cast<const ASTInsertQuery &>(*query);
+    columns[i++]->insert(queryToString(insert_query));
+
+    if (insert_query.table_id)
+    {
+        columns[i++]->insert(insert_query.table_id.getDatabaseName());
+        columns[i++]->insert(insert_query.table_id.getTableName());
+    }
+    else
+    {
+        columns[i++]->insertDefault();
+        columns[i++]->insertDefault();
+    }
+
+    columns[i++]->insert(insert_query.format);
+    columns[i++]->insert(query_id);
+    columns[i++]->insert(bytes);
+    columns[i++]->insert(exception);
+    columns[i++]->insert(status);
+
+    columns[i++]->insert(flush_time);
+    columns[i++]->insert(flush_time_microseconds);
+    columns[i++]->insert(flush_query_id);
+}
+
+}
diff --git a/src/Interpreters/AsynchronousInsertLog.h b/src/Interpreters/AsynchronousInsertLog.h
new file mode 100644
index 000000000000..e2fdd4c90a05
--- /dev/null
+++ b/src/Interpreters/AsynchronousInsertLog.h
@@ -0,0 +1,50 @@
+#pragma once
+
+#include "Common/Exception.h"
+#include <Interpreters/SystemLog.h>
+#include <Core/NamesAndTypes.h>
+#include <Core/NamesAndAliases.h>
+#include <Parsers/IAST_fwd.h>
+
+namespace DB
+{
+
+struct AsynchronousInsertLogElement
+{
+    enum Status : Int8
+    {
+        Ok = 0,
+        ParsingError = 1,
+        FlushError = 2,
+    };
+
+    time_t event_time{};
+    Decimal64 event_time_microseconds{};
+
+    ASTPtr query;
+    String query_id;
+    UInt64 bytes{};
+    String exception;
+    Status status{};
+
+    time_t flush_time{};
+    Decimal64 flush_time_microseconds{};
+    String flush_query_id;
+
+    static std::string name() { return "AsynchronousInsertLog"; }
+    static NamesAndTypesList getNamesAndTypes();
+    static NamesAndAliases getNamesAndAliases() { return {}; }
+    void appendToBlock(MutableColumns & columns) const;
+    static const char * getCustomColumnList() { return nullptr; }
+};
+
+class AsynchronousInsertLog : public SystemLog<AsynchronousInsertLogElement>
+{
+public:
+    using SystemLog<AsynchronousInsertLogElement>::SystemLog;
+
+    /// This table is usually queried for fixed table name.
+    static const char * getDefaultOrderBy() { return "(database, table, event_date, event_time)"; }
+};
+
+}
diff --git a/src/Interpreters/AsynchronousInsertQueue.cpp b/src/Interpreters/AsynchronousInsertQueue.cpp
index 7f03bc25b62b..3aadea918fba 100644
--- a/src/Interpreters/AsynchronousInsertQueue.cpp
+++ b/src/Interpreters/AsynchronousInsertQueue.cpp
@@ -4,6 +4,7 @@
 #include <QueryPipeline/BlockIO.h>
 #include <Interpreters/InterpreterInsertQuery.h>
 #include <Interpreters/Context.h>
+#include <Interpreters/AsynchronousInsertLog.h>
 #include <Processors/Transforms/getSourceFromASTInsertQuery.h>
 #include <Processors/Sources/SourceFromSingleChunk.h>
 #include <Processors/Executors/StreamingFormatExecutor.h>
@@ -18,6 +19,7 @@
 #include <Storages/IStorage.h>
 #include <Common/SipHash.h>
 #include <Common/FieldVisitorHash.h>
+#include <Common/DateLUT.h>
 #include <Access/Common/AccessFlags.h>
 #include <Access/EnabledQuota.h>
 #include <Formats/FormatFactory.h>
@@ -89,7 +91,9 @@ bool AsynchronousInsertQueue::InsertQuery::operator==(const InsertQuery & other)
 }
 
 AsynchronousInsertQueue::InsertData::Entry::Entry(String && bytes_, String && query_id_)
-    : bytes(std::move(bytes_)), query_id(std::move(query_id_))
+    : bytes(std::move(bytes_))
+    , query_id(std::move(query_id_))
+    , create_time(std::chrono::system_clock::now())
 {
 }
 
@@ -395,6 +399,31 @@ void AsynchronousInsertQueue::cleanup()
 }
 
 
+static void appendElementsToLogSafe(
+    AsynchronousInsertLog & log,
+    std::vector<AsynchronousInsertLogElement> elements,
+    std::chrono::time_point<std::chrono::system_clock> flush_time,
+    const String & flush_query_id,
+    const String & flush_exception)
+try
+{
+    using Status = AsynchronousInsertLogElement::Status;
+
+    for (auto & elem : elements)
+    {
+        elem.flush_time = timeInSeconds(flush_time);
+        elem.flush_time_microseconds = timeInMicroseconds(flush_time);
+        elem.flush_query_id = flush_query_id;
+        elem.exception = flush_exception;
+        elem.status = flush_exception.empty() ? Status::Ok : Status::FlushError;
+        log.add(elem);
+    }
+}
+catch (...)
+{
+    tryLogCurrentException("AsynchronousInsertQueue", "Failed to add elements to AsynchronousInsertLog");
+}
+
 // static
 void AsynchronousInsertQueue::processData(InsertQuery key, InsertDataPtr data, ContextPtr global_context)
 try
@@ -402,6 +431,8 @@ try
     if (!data)
         return;
 
+    SCOPE_EXIT(CurrentMetrics::sub(CurrentMetrics::PendingAsyncInsert, data->entries.size()));
+
     const auto * log = &Poco::Logger::get("AsynchronousInsertQueue");
     const auto & insert_query = assert_cast<const ASTInsertQuery &>(*key.query);
     auto insert_context = Context::createCopy(global_context);
@@ -424,11 +455,13 @@ try
 
     size_t total_rows = 0;
     InsertData::EntryPtr current_entry;
+    String current_exception;
 
     auto on_error = [&](const MutableColumns & result_columns, Exception & e)
     {
+        current_exception = e.displayText();
         LOG_ERROR(log, "Failed parsing for query '{}' with query id {}. {}",
-            queryToString(key.query), current_entry->query_id, e.displayText());
+            queryToString(key.query), current_entry->query_id, current_exception);
 
         for (const auto & column : result_columns)
             if (column->size() > total_rows)
@@ -448,6 +481,12 @@ try
             adding_defaults_transform = std::make_shared<AddingDefaultsTransform>(header, columns, *format, insert_context);
     }
 
+    auto insert_log = global_context->getAsynchronousInsertLog();
+    std::vector<AsynchronousInsertLogElement> log_elements;
+
+    if (insert_log)
+        log_elements.reserve(data->entries.size());
+
     StreamingFormatExecutor executor(header, format, std::move(on_error), std::move(adding_defaults_transform));
     std::unique_ptr<ReadBuffer> last_buffer;
     for (const auto & entry : data->entries)
@@ -459,11 +498,40 @@ try
         /// Keep buffer, because it still can be used
         /// in destructor, while resetting buffer at next iteration.
         last_buffer = std::move(buffer);
+
+        if (insert_log)
+        {
+            AsynchronousInsertLogElement elem;
+            elem.event_time = timeInSeconds(entry->create_time);
+            elem.event_time_microseconds = timeInMicroseconds(entry->create_time);
+            elem.query = key.query;
+            elem.query_id = entry->query_id;
+            elem.bytes = entry->bytes.size();
+            elem.exception = current_exception;
+            current_exception.clear();
+
+            /// If there was a parsing error,
+            /// the entry won't be flushed anyway,
+            /// so add the log element immediately.
+            if (!elem.exception.empty())
+            {
+                elem.status = AsynchronousInsertLogElement::ParsingError;
+                insert_log->add(elem);
+            }
+            else
+            {
+                log_elements.push_back(elem);
+            }
+        }
     }
 
     format->addBuffer(std::move(last_buffer));
+    auto insert_query_id = insert_context->getCurrentQueryId();
 
-    if (total_rows)
+    if (total_rows == 0)
+        return;
+
+    try
     {
         auto chunk = Chunk(executor.getResultColumns(), total_rows);
         size_t total_bytes = chunk.bytes();
@@ -477,12 +545,28 @@ try
         LOG_INFO(log, "Flushed {} rows, {} bytes for query '{}'",
             total_rows, total_bytes, queryToString(key.query));
     }
+    catch (...)
+    {
+        if (!log_elements.empty())
+        {
+            auto exception = getCurrentExceptionMessage(false);
+            auto flush_time = std::chrono::system_clock::now();
+            appendElementsToLogSafe(*insert_log, std::move(log_elements), flush_time, insert_query_id, exception);
+        }
+        throw;
+    }
 
     for (const auto & entry : data->entries)
+    {
         if (!entry->isFinished())
             entry->finish();
+    }
 
-    CurrentMetrics::sub(CurrentMetrics::PendingAsyncInsert, data->entries.size());
+    if (!log_elements.empty())
+    {
+        auto flush_time = std::chrono::system_clock::now();
+        appendElementsToLogSafe(*insert_log, std::move(log_elements), flush_time, insert_query_id, "");
+    }
 }
 catch (const Exception & e)
 {
@@ -516,8 +600,6 @@ void AsynchronousInsertQueue::finishWithException(
             entry->finish(std::make_exception_ptr(exception));
         }
     }
-
-    CurrentMetrics::sub(CurrentMetrics::PendingAsyncInsert, entries.size());
 }
 
 }
diff --git a/src/Interpreters/AsynchronousInsertQueue.h b/src/Interpreters/AsynchronousInsertQueue.h
index 93483301ee6a..fcf4e3d98d23 100644
--- a/src/Interpreters/AsynchronousInsertQueue.h
+++ b/src/Interpreters/AsynchronousInsertQueue.h
@@ -47,6 +47,7 @@ class AsynchronousInsertQueue : public WithContext
         public:
             const String bytes;
             const String query_id;
+            std::chrono::time_point<std::chrono::system_clock> create_time;
 
             Entry(String && bytes_, String && query_id_);
 
diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp
index 9604d1796e99..3c406058cb50 100644
--- a/src/Interpreters/Context.cpp
+++ b/src/Interpreters/Context.cpp
@@ -2665,6 +2665,16 @@ std::shared_ptr<FilesystemCacheLog> Context::getFilesystemCacheLog() const
     return shared->system_logs->cache_log;
 }
 
+std::shared_ptr<AsynchronousInsertLog> Context::getAsynchronousInsertLog() const
+{
+    auto lock = getLock();
+
+    if (!shared->system_logs)
+        return {};
+
+    return shared->system_logs->asynchronous_insert_log;
+}
+
 CompressionCodecPtr Context::chooseCompressionCodec(size_t part_size, double part_size_ratio) const
 {
     auto lock = getLock();
diff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h
index 635c571b173f..d9a59cb08ae7 100644
--- a/src/Interpreters/Context.h
+++ b/src/Interpreters/Context.h
@@ -86,6 +86,7 @@ class BackupsWorker;
 class TransactionsInfoLog;
 class ProcessorsProfileLog;
 class FilesystemCacheLog;
+class AsynchronousInsertLog;
 struct MergeTreeSettings;
 class StorageS3Settings;
 class IDatabase;
@@ -891,8 +892,8 @@ class Context: public std::enable_shared_from_this<Context>
     std::shared_ptr<SessionLog> getSessionLog() const;
     std::shared_ptr<TransactionsInfoLog> getTransactionsInfoLog() const;
     std::shared_ptr<ProcessorsProfileLog> getProcessorsProfileLog() const;
-
     std::shared_ptr<FilesystemCacheLog> getFilesystemCacheLog() const;
+    std::shared_ptr<AsynchronousInsertLog> getAsynchronousInsertLog() const;
 
     /// Returns an object used to log operations with parts if it possible.
     /// Provide table name to make required checks.
diff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp
index 56e87d6a4fb9..27d6de6a8df6 100644
--- a/src/Interpreters/InterpreterSystemQuery.cpp
+++ b/src/Interpreters/InterpreterSystemQuery.cpp
@@ -33,6 +33,7 @@
 #include <Interpreters/FilesystemCacheLog.h>
 #include <Interpreters/TransactionsInfoLog.h>
 #include <Interpreters/ProcessorsProfileLog.h>
+#include <Interpreters/AsynchronousInsertLog.h>
 #include <Interpreters/JIT/CompiledExpressionCache.h>
 #include <Interpreters/TransactionLog.h>
 #include <BridgeHelper/CatBoostLibraryBridgeHelper.h>
@@ -523,7 +524,8 @@ BlockIO InterpreterSystemQuery::execute()
                 [&] { if (auto session_log = getContext()->getSessionLog()) session_log->flush(true); },
                 [&] { if (auto transactions_info_log = getContext()->getTransactionsInfoLog()) transactions_info_log->flush(true); },
                 [&] { if (auto processors_profile_log = getContext()->getProcessorsProfileLog()) processors_profile_log->flush(true); },
-                [&] { if (auto cache_log = getContext()->getFilesystemCacheLog()) cache_log->flush(true); }
+                [&] { if (auto cache_log = getContext()->getFilesystemCacheLog()) cache_log->flush(true); },
+                [&] { if (auto asynchronous_insert_log = getContext()->getAsynchronousInsertLog()) asynchronous_insert_log->flush(true); }
             );
             break;
         }
diff --git a/src/Interpreters/MetricLog.cpp b/src/Interpreters/MetricLog.cpp
index 8b28717ff07c..6e98f84bc82f 100644
--- a/src/Interpreters/MetricLog.cpp
+++ b/src/Interpreters/MetricLog.cpp
@@ -78,22 +78,6 @@ void MetricLog::shutdown()
 }
 
 
-static inline UInt64 time_in_milliseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::milliseconds>(timepoint.time_since_epoch()).count();
-}
-
-static inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
-}
-
-static inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
-}
-
-
 void MetricLog::metricThreadFunction()
 {
     auto desired_timepoint = std::chrono::system_clock::now();
@@ -109,8 +93,8 @@ void MetricLog::metricThreadFunction()
 
             MetricLogElement elem;
             elem.event_time = std::chrono::system_clock::to_time_t(current_time);
-            elem.event_time_microseconds = time_in_microseconds(current_time);
-            elem.milliseconds = time_in_milliseconds(current_time) - time_in_seconds(current_time) * 1000;
+            elem.event_time_microseconds = timeInMicroseconds(current_time);
+            elem.milliseconds = timeInMilliseconds(current_time) - timeInSeconds(current_time) * 1000;
 
             elem.profile_events.resize(ProfileEvents::end());
             for (size_t i = 0, end = ProfileEvents::end(); i < end; ++i)
diff --git a/src/Interpreters/PartLog.cpp b/src/Interpreters/PartLog.cpp
index d12eca407d93..75e6d02d6e18 100644
--- a/src/Interpreters/PartLog.cpp
+++ b/src/Interpreters/PartLog.cpp
@@ -169,16 +169,6 @@ bool PartLog::addNewPart(
     return addNewParts(current_context, {part}, elapsed_ns, execution_status);
 }
 
-static inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
-}
-
-
-static inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
-}
 
 bool PartLog::addNewParts(
     ContextPtr current_context, const PartLog::MutableDataPartsVector & parts, UInt64 elapsed_ns, const ExecutionStatus & execution_status)
@@ -209,8 +199,8 @@ bool PartLog::addNewParts(
             // construct event_time and event_time_microseconds using the same time point
             // so that the two times will always be equal up to a precision of a second.
             const auto time_now = std::chrono::system_clock::now();
-            elem.event_time = time_in_seconds(time_now);
-            elem.event_time_microseconds = time_in_microseconds(time_now);
+            elem.event_time = timeInSeconds(time_now);
+            elem.event_time_microseconds = timeInMicroseconds(time_now);
             elem.duration_ms = elapsed_ns / 1000000;
 
             elem.database_name = table_id.database_name;
diff --git a/src/Interpreters/SessionLog.cpp b/src/Interpreters/SessionLog.cpp
index 29357875488e..3edb84c046d8 100644
--- a/src/Interpreters/SessionLog.cpp
+++ b/src/Interpreters/SessionLog.cpp
@@ -30,21 +30,11 @@ namespace
 {
 using namespace DB;
 
-inline DateTime64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
-}
-
-inline time_t time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
-}
-
 auto eventTime()
 {
     const auto finish_time = std::chrono::system_clock::now();
 
-    return std::make_pair(time_in_seconds(finish_time), time_in_microseconds(finish_time));
+    return std::make_pair(timeInSeconds(finish_time), timeInMicroseconds(finish_time));
 }
 
 using AuthType = AuthenticationType;
diff --git a/src/Interpreters/SystemLog.cpp b/src/Interpreters/SystemLog.cpp
index 3fc5dda06723..b5e4a0e81c77 100644
--- a/src/Interpreters/SystemLog.cpp
+++ b/src/Interpreters/SystemLog.cpp
@@ -13,6 +13,7 @@
 #include <Interpreters/ZooKeeperLog.h>
 #include <Interpreters/TransactionsInfoLog.h>
 #include <Interpreters/FilesystemCacheLog.h>
+#include <Interpreters/AsynchronousInsertLog.h>
 #include <Interpreters/InterpreterCreateQuery.h>
 #include <Interpreters/InterpreterRenameQuery.h>
 #include <Interpreters/InterpreterInsertQuery.h>
@@ -208,6 +209,7 @@ SystemLogs::SystemLogs(ContextPtr global_context, const Poco::Util::AbstractConf
     transactions_info_log = createSystemLog<TransactionsInfoLog>(
         global_context, "system", "transactions_info_log", config, "transactions_info_log");
     processors_profile_log = createSystemLog<ProcessorsProfileLog>(global_context, "system", "processors_profile_log", config, "processors_profile_log");
+    asynchronous_insert_log = createSystemLog<AsynchronousInsertLog>(global_context, "system", "asynchronous_insert_log", config, "asynchronous_insert_log");
 
     if (query_log)
         logs.emplace_back(query_log.get());
@@ -242,6 +244,8 @@ SystemLogs::SystemLogs(ContextPtr global_context, const Poco::Util::AbstractConf
         logs.emplace_back(processors_profile_log.get());
     if (cache_log)
         logs.emplace_back(cache_log.get());
+    if (asynchronous_insert_log)
+        logs.emplace_back(asynchronous_insert_log.get());
 
     try
     {
diff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h
index 911e316685e4..95292a2b7ced 100644
--- a/src/Interpreters/SystemLog.h
+++ b/src/Interpreters/SystemLog.h
@@ -47,6 +47,7 @@ class SessionLog;
 class TransactionsInfoLog;
 class ProcessorsProfileLog;
 class FilesystemCacheLog;
+class AsynchronousInsertLog;
 
 /// System logs should be destroyed in destructor of the last Context and before tables,
 ///  because SystemLog destruction makes insert query while flushing data into underlying tables
@@ -79,6 +80,7 @@ struct SystemLogs
     std::shared_ptr<TransactionsInfoLog> transactions_info_log;
     /// Used to log processors profiling
     std::shared_ptr<ProcessorsProfileLog> processors_profile_log;
+    std::shared_ptr<AsynchronousInsertLog> asynchronous_insert_log;
 
     std::vector<ISystemLog *> logs;
 };
diff --git a/src/Interpreters/ThreadStatusExt.cpp b/src/Interpreters/ThreadStatusExt.cpp
index 9a4152415aff..3e7f08e9d9a3 100644
--- a/src/Interpreters/ThreadStatusExt.cpp
+++ b/src/Interpreters/ThreadStatusExt.cpp
@@ -17,6 +17,7 @@
 #include <Common/ThreadProfileEvents.h>
 #include <Common/setThreadName.h>
 #include <Common/noexcept_scope.h>
+#include <Common/DateLUT.h>
 #include <base/errnoToString.h>
 
 #if defined(OS_LINUX)
@@ -154,22 +155,6 @@ void ThreadStatus::attachQuery(const ThreadGroupStatusPtr & thread_group_, bool
     setupState(thread_group_);
 }
 
-inline UInt64 time_in_nanoseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::nanoseconds>(timepoint.time_since_epoch()).count();
-}
-
-inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
-}
-
-
-inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
-}
-
 void ThreadStatus::initPerformanceCounters()
 {
     performance_counters_finalized = false;
@@ -184,9 +169,9 @@ void ThreadStatus::initPerformanceCounters()
     // to ensure that they are all equal up to the precision of a second.
     const auto now = std::chrono::system_clock::now();
 
-    query_start_time_nanoseconds = time_in_nanoseconds(now);
-    query_start_time = time_in_seconds(now);
-    query_start_time_microseconds = time_in_microseconds(now);
+    query_start_time_nanoseconds = timeInNanoseconds(now);
+    query_start_time = timeInSeconds(now);
+    query_start_time_microseconds = timeInMicroseconds(now);
     ++queries_started;
 
     // query_start_time_nanoseconds cannot be used here since RUsageCounters expect CLOCK_MONOTONIC
@@ -261,7 +246,7 @@ void ThreadStatus::finalizePerformanceCounters()
             if (settings.log_queries && settings.log_query_threads)
             {
                 const auto now = std::chrono::system_clock::now();
-                Int64 query_duration_ms = (time_in_microseconds(now) - query_start_time_microseconds) / 1000;
+                Int64 query_duration_ms = (timeInMicroseconds(now) - query_start_time_microseconds) / 1000;
                 if (query_duration_ms >= settings.log_queries_min_query_duration_ms.totalMilliseconds())
                 {
                     if (auto thread_log = global_context_ptr->getQueryThreadLog())
@@ -378,14 +363,14 @@ void ThreadStatus::logToQueryThreadLog(QueryThreadLog & thread_log, const String
 
     // construct current_time and current_time_microseconds using the same time point
     // so that the two times will always be equal up to a precision of a second.
-    auto current_time = time_in_seconds(now);
-    auto current_time_microseconds = time_in_microseconds(now);
+    auto current_time = timeInSeconds(now);
+    auto current_time_microseconds = timeInMicroseconds(now);
 
     elem.event_time = current_time;
     elem.event_time_microseconds = current_time_microseconds;
     elem.query_start_time = query_start_time;
     elem.query_start_time_microseconds = query_start_time_microseconds;
-    elem.query_duration_ms = (time_in_nanoseconds(now) - query_start_time_nanoseconds) / 1000000U;
+    elem.query_duration_ms = (timeInNanoseconds(now) - query_start_time_nanoseconds) / 1000000U;
 
     elem.read_rows = progress_in.read_rows.load(std::memory_order_relaxed);
     elem.read_bytes = progress_in.read_bytes.load(std::memory_order_relaxed);
@@ -447,8 +432,8 @@ void ThreadStatus::logToQueryViewsLog(const ViewRuntimeData & vinfo)
 
     QueryViewsLogElement element;
 
-    element.event_time = time_in_seconds(vinfo.runtime_stats->event_time);
-    element.event_time_microseconds = time_in_microseconds(vinfo.runtime_stats->event_time);
+    element.event_time = timeInSeconds(vinfo.runtime_stats->event_time);
+    element.event_time_microseconds = timeInMicroseconds(vinfo.runtime_stats->event_time);
     element.view_duration_ms = vinfo.runtime_stats->elapsed_ms;
 
     element.initial_query_id = query_id;
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index 6e17e05a7548..35edebb11610 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -234,17 +234,6 @@ static void logException(ContextPtr context, QueryLogElement & elem)
             elem.stack_trace);
 }
 
-inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
-}
-
-
-inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
-}
-
 static void onExceptionBeforeStart(const String & query_for_logging, ContextPtr context, UInt64 current_time_us, ASTPtr ast, const std::shared_ptr<OpenTelemetry::SpanHolder> & query_span)
 {
     /// Exception before the query execution.
@@ -379,8 +368,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
     // example, the query is from an initiator that is running an old version of clickhouse.
     if (!internal && client_info.initial_query_start_time == 0)
     {
-        client_info.initial_query_start_time = time_in_seconds(current_time);
-        client_info.initial_query_start_time_microseconds = time_in_microseconds(current_time);
+        client_info.initial_query_start_time = timeInSeconds(current_time);
+        client_info.initial_query_start_time_microseconds = timeInMicroseconds(current_time);
     }
 
     assert(internal || CurrentThread::get().getQueryContext());
@@ -448,7 +437,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
         logQuery(query_for_logging, context, internal, stage);
 
         if (!internal)
-            onExceptionBeforeStart(query_for_logging, context, time_in_microseconds(current_time), ast, query_span);
+            onExceptionBeforeStart(query_for_logging, context, timeInMicroseconds(current_time), ast, query_span);
         throw;
     }
 
@@ -742,10 +731,10 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
 
             elem.type = QueryLogElementType::QUERY_START; //-V1048
 
-            elem.event_time = time_in_seconds(current_time);
-            elem.event_time_microseconds = time_in_microseconds(current_time);
-            elem.query_start_time = time_in_seconds(current_time);
-            elem.query_start_time_microseconds = time_in_microseconds(current_time);
+            elem.event_time = timeInSeconds(current_time);
+            elem.event_time_microseconds = timeInMicroseconds(current_time);
+            elem.query_start_time = timeInSeconds(current_time);
+            elem.query_start_time_microseconds = timeInMicroseconds(current_time);
 
             elem.current_database = context->getCurrentDatabase();
             elem.query = query_for_logging;
@@ -874,8 +863,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                     // construct event_time and event_time_microseconds using the same time point
                     // so that the two times will always be equal up to a precision of a second.
                     const auto finish_time = std::chrono::system_clock::now();
-                    elem.event_time = time_in_seconds(finish_time);
-                    elem.event_time_microseconds = time_in_microseconds(finish_time);
+                    elem.event_time = timeInSeconds(finish_time);
+                    elem.event_time_microseconds = timeInMicroseconds(finish_time);
                     status_info_to_query_log(elem, info, ast, context);
 
                     if (pulling_pipeline)
@@ -915,8 +904,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                         if (auto processors_profile_log = context->getProcessorsProfileLog())
                         {
                             ProcessorProfileLogElement processor_elem;
-                            processor_elem.event_time = time_in_seconds(finish_time);
-                            processor_elem.event_time_microseconds = time_in_microseconds(finish_time);
+                            processor_elem.event_time = timeInSeconds(finish_time);
+                            processor_elem.event_time_microseconds = timeInMicroseconds(finish_time);
                             processor_elem.query_id = elem.client_info.current_query_id;
 
                             auto get_proc_id = [](const IProcessor & proc) -> UInt64
@@ -1018,8 +1007,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
                 // to ensure that both the times will be equal up to the precision of a second.
                 const auto time_now = std::chrono::system_clock::now();
 
-                elem.event_time = time_in_seconds(time_now);
-                elem.event_time_microseconds = time_in_microseconds(time_now);
+                elem.event_time = timeInSeconds(time_now);
+                elem.event_time_microseconds = timeInMicroseconds(time_now);
                 elem.query_duration_ms = 1000 * (elem.event_time - elem.query_start_time);
                 elem.exception_code = getCurrentExceptionCode();
                 elem.exception = getCurrentExceptionMessage(false);
@@ -1084,7 +1073,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
         }
 
         if (!internal)
-            onExceptionBeforeStart(query_for_logging, context, time_in_microseconds(current_time), ast, query_span);
+            onExceptionBeforeStart(query_for_logging, context, timeInMicroseconds(current_time), ast, query_span);
 
         throw;
     }
diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp
index ea7b87a5a582..f519fd75ecb8 100644
--- a/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/src/Storages/MergeTree/MergeTreeData.cpp
@@ -193,16 +193,6 @@ static void checkSampleExpression(const StorageInMemoryMetadata & metadata, bool
             ErrorCodes::ILLEGAL_TYPE_OF_COLUMN_FOR_FILTER);
 }
 
-inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();
-}
-
-inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)
-{
-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();
-}
-
 MergeTreeData::MergeTreeData(
     const StorageID & table_id_,
     const String & relative_data_path_,
@@ -1817,8 +1807,8 @@ void MergeTreeData::removePartsFinally(const MergeTreeData::DataPartsVector & pa
         part_log_elem.event_type = PartLogElement::REMOVE_PART;
 
         const auto time_now = std::chrono::system_clock::now();
-        part_log_elem.event_time = time_in_seconds(time_now);
-        part_log_elem.event_time_microseconds = time_in_microseconds(time_now);
+        part_log_elem.event_time = timeInSeconds(time_now);
+        part_log_elem.event_time_microseconds = timeInMicroseconds(time_now);
 
         part_log_elem.duration_ms = 0; //-V1048
 
@@ -6516,8 +6506,8 @@ try
     // construct event_time and event_time_microseconds using the same time point
     // so that the two times will always be equal up to a precision of a second.
     const auto time_now = std::chrono::system_clock::now();
-    part_log_elem.event_time = time_in_seconds(time_now);
-    part_log_elem.event_time_microseconds = time_in_microseconds(time_now);
+    part_log_elem.event_time = timeInSeconds(time_now);
+    part_log_elem.event_time_microseconds = timeInMicroseconds(time_now);
 
     /// TODO: Stop stopwatch in outer code to exclude ZK timings and so on
     part_log_elem.duration_ms = elapsed_ns / 1000000;
