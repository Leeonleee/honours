{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38774,
  "instance_id": "ClickHouse__ClickHouse-38774",
  "issue_numbers": [
    "38532"
  ],
  "base_commit": "a26643a7a687c4c6bd2f088b30b213bf6e6dcb91",
  "patch": "diff --git a/src/Columns/ColumnDecimal.h b/src/Columns/ColumnDecimal.h\nindex 1383f5834276..038751216376 100644\n--- a/src/Columns/ColumnDecimal.h\n+++ b/src/Columns/ColumnDecimal.h\n@@ -104,7 +104,7 @@ class ColumnDecimal final : public COWHelper<ColumnVectorHelper, ColumnDecimal<T\n     Field operator[](size_t n) const override { return DecimalField(data[n], scale); }\n     void get(size_t n, Field & res) const override { res = (*this)[n]; }\n     bool getBool(size_t n) const override { return bool(data[n].value); }\n-    Int64 getInt(size_t n) const override { return Int64(data[n].value) * scale; }\n+    Int64 getInt(size_t n) const override { return Int64(data[n].value); }\n     UInt64 get64(size_t n) const override;\n     bool isDefaultAt(size_t n) const override { return data[n].value == 0; }\n \ndiff --git a/src/Common/IntervalKind.cpp b/src/Common/IntervalKind.cpp\nindex d3cd4eeff8fe..4e923fdba554 100644\n--- a/src/Common/IntervalKind.cpp\n+++ b/src/Common/IntervalKind.cpp\n@@ -7,6 +7,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int SYNTAX_ERROR;\n+    extern const int BAD_ARGUMENTS;\n }\n \n Int32 IntervalKind::toAvgSeconds() const\n@@ -15,7 +16,7 @@ Int32 IntervalKind::toAvgSeconds() const\n     {\n         case IntervalKind::Nanosecond:\n         case IntervalKind::Microsecond:\n-        case IntervalKind::Millisecond: return 0; /// fractional parts of seconds have 0 seconds\n+        case IntervalKind::Millisecond: return 0;\n         case IntervalKind::Second: return 1;\n         case IntervalKind::Minute: return 60;\n         case IntervalKind::Hour: return 3600;\n@@ -28,6 +29,51 @@ Int32 IntervalKind::toAvgSeconds() const\n     __builtin_unreachable();\n }\n \n+Float64 IntervalKind::toSeconds() const\n+{\n+    switch (kind)\n+    {\n+        case IntervalKind::Nanosecond:\n+            return 0.000000001;\n+        case IntervalKind::Microsecond:\n+            return 0.000001;\n+        case IntervalKind::Millisecond:\n+            return 0.001;\n+        case IntervalKind::Second:\n+            return 1;\n+        case IntervalKind::Minute:\n+            return 60;\n+        case IntervalKind::Hour:\n+            return 3600;\n+        case IntervalKind::Day:\n+            return 86400;\n+        case IntervalKind::Week:\n+            return 604800;\n+        default:\n+            throw Exception(\"Not possible to get precise number of seconds in non-precise interval\", ErrorCodes::BAD_ARGUMENTS);\n+    }\n+    __builtin_unreachable();\n+}\n+\n+bool IntervalKind::isFixedLength() const\n+{\n+    switch (kind)\n+    {\n+        case IntervalKind::Nanosecond:\n+        case IntervalKind::Microsecond:\n+        case IntervalKind::Millisecond:\n+        case IntervalKind::Second:\n+        case IntervalKind::Minute:\n+        case IntervalKind::Hour:\n+        case IntervalKind::Day:\n+        case IntervalKind::Week: return true;\n+        case IntervalKind::Month:\n+        case IntervalKind::Quarter:\n+        case IntervalKind::Year: return false;\n+    }\n+    __builtin_unreachable();\n+}\n+\n IntervalKind IntervalKind::fromAvgSeconds(Int64 num_seconds)\n {\n     if (num_seconds)\ndiff --git a/src/Common/IntervalKind.h b/src/Common/IntervalKind.h\nindex d5f2b5672cdd..59e8d32f3e71 100644\n--- a/src/Common/IntervalKind.h\n+++ b/src/Common/IntervalKind.h\n@@ -33,10 +33,17 @@ struct IntervalKind\n     /// For `Month`, `Quarter` and `Year` the function returns an average number of seconds.\n     Int32 toAvgSeconds() const;\n \n+    /// Returns exact number of seconds in one interval.\n+    /// For `Month`, `Quarter` and `Year` the function raises an error.\n+    Float64 toSeconds() const;\n+\n     /// Chooses an interval kind based on number of seconds.\n     /// For example, `IntervalKind::fromAvgSeconds(3600)` returns `IntervalKind::Hour`.\n     static IntervalKind fromAvgSeconds(Int64 num_seconds);\n \n+    /// Returns whether IntervalKind has a fixed number of seconds (e.g. Day) or non-fixed(e.g. Month)\n+    bool isFixedLength() const;\n+\n     /// Returns an uppercased version of what `toString()` returns.\n     const char * toKeyword() const;\n \ndiff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp\nindex 3eb0f62cb017..5c833cf8f69c 100644\n--- a/src/Processors/Transforms/WindowTransform.cpp\n+++ b/src/Processors/Transforms/WindowTransform.cpp\n@@ -13,8 +13,10 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/getLeastSupertype.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypeInterval.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/convertFieldToType.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n \n \n namespace DB\n@@ -27,6 +29,7 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n     extern const int NOT_IMPLEMENTED;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n // Interface for true window functions. It's not much of an interface, they just\n@@ -2200,6 +2203,128 @@ struct WindowFunctionNthValue final : public WindowFunction\n     }\n };\n \n+struct NonNegativeDerivativeState\n+{\n+    Float64 previous_metric = 0;\n+    Float64 previous_timestamp = 0;\n+};\n+\n+// nonNegativeDerivative(metric_column, timestamp_column[, INTERVAL 1 SECOND])\n+struct WindowFunctionNonNegativeDerivative final : public StatefulWindowFunction<NonNegativeDerivativeState>\n+{\n+    static constexpr size_t ARGUMENT_METRIC = 0;\n+    static constexpr size_t ARGUMENT_TIMESTAMP = 1;\n+    static constexpr size_t ARGUMENT_INTERVAL = 2;\n+\n+    WindowFunctionNonNegativeDerivative(const std::string & name_,\n+                                            const DataTypes & argument_types_, const Array & parameters_)\n+        : StatefulWindowFunction(name_, argument_types_, parameters_)\n+    {\n+        if (!parameters.empty())\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                            \"Function {} cannot be parameterized\", name_);\n+        }\n+\n+        if (argument_types.size() != 2 && argument_types.size() != 3)\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                            \"Function {} takes 2 or 3 arguments\", name_);\n+        }\n+\n+        if (!isNumber(argument_types[ARGUMENT_METRIC]))\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                            \"Argument {} must be a number, '{}' given\",\n+                            ARGUMENT_METRIC,\n+                            argument_types[ARGUMENT_METRIC]->getName());\n+        }\n+\n+        if (!isDateTime(argument_types[ARGUMENT_TIMESTAMP]) && !isDateTime64(argument_types[ARGUMENT_TIMESTAMP]))\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                            \"Argument {} must be DateTime or DateTime64, '{}' given\",\n+                            ARGUMENT_TIMESTAMP,\n+                            argument_types[ARGUMENT_TIMESTAMP]->getName());\n+        }\n+\n+        if (isDateTime64(argument_types[ARGUMENT_TIMESTAMP]))\n+        {\n+            const auto & datetime64_type = assert_cast<const DataTypeDateTime64 &>(*argument_types[ARGUMENT_TIMESTAMP]);\n+            ts_scale_multiplier = DecimalUtils::scaleMultiplier<DateTime64>(datetime64_type.getScale());\n+        }\n+\n+        if (argument_types.size() == 3)\n+        {\n+            const DataTypeInterval * interval_datatype = checkAndGetDataType<DataTypeInterval>(argument_types[ARGUMENT_INTERVAL].get());\n+            if (!interval_datatype)\n+            {\n+                throw Exception(\n+                    ErrorCodes::BAD_ARGUMENTS,\n+                    \"Argument {} must be an INTERVAL, '{}' given\",\n+                    ARGUMENT_INTERVAL,\n+                    argument_types[ARGUMENT_INTERVAL]->getName());\n+            }\n+            if (!interval_datatype->getKind().isFixedLength())\n+            {\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"The INTERVAL must be a week or shorter, '{}' given\",\n+                    argument_types[ARGUMENT_INTERVAL]->getName());\n+            }\n+            interval_length = interval_datatype->getKind().toSeconds();\n+            interval_specified = true;\n+        }\n+    }\n+\n+\n+    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeFloat64>(); }\n+\n+    bool allocatesMemoryInArena() const override { return false; }\n+\n+    void windowInsertResultInto(const WindowTransform * transform,\n+                                size_t function_index) override\n+    {\n+        const auto & current_block = transform->blockAt(transform->current_row);\n+        const auto & workspace = transform->workspaces[function_index];\n+        auto & state = getState(workspace);\n+\n+        auto interval_duration = interval_specified ? interval_length *\n+            (*current_block.input_columns[workspace.argument_column_indices[ARGUMENT_INTERVAL]]).getFloat64(0) : 1;\n+\n+        Float64 curr_metric = WindowFunctionHelpers::getValue<Float64>(transform, function_index, ARGUMENT_METRIC, transform->current_row);\n+        Float64 metric_diff = curr_metric - state.previous_metric;\n+        Float64 result;\n+\n+        if (ts_scale_multiplier)\n+        {\n+            const auto & column = transform->blockAt(transform->current_row.block).input_columns[workspace.argument_column_indices[ARGUMENT_TIMESTAMP]];\n+            const auto & curr_timestamp = checkAndGetColumn<DataTypeDateTime64::ColumnType>(column.get())->getInt(transform->current_row.row);\n+\n+            Float64 time_elapsed = curr_timestamp - state.previous_timestamp;\n+            result = (time_elapsed > 0) ? (metric_diff * ts_scale_multiplier / time_elapsed  * interval_duration) : 0;\n+            state.previous_timestamp = curr_timestamp;\n+        }\n+        else\n+        {\n+            Float64 curr_timestamp = WindowFunctionHelpers::getValue<Float64>(transform, function_index, ARGUMENT_TIMESTAMP, transform->current_row);\n+            Float64 time_elapsed = curr_timestamp - state.previous_timestamp;\n+            result = (time_elapsed > 0) ? (metric_diff / time_elapsed * interval_duration) : 0;\n+            state.previous_timestamp = curr_timestamp;\n+        }\n+        state.previous_metric = curr_metric;\n+\n+        if (unlikely(!transform->current_row.row))\n+            result = 0;\n+\n+        WindowFunctionHelpers::setValueToOutputColumn<Float64>(transform, function_index, result >= 0 ? result : 0);\n+    }\n+private:\n+    Float64 interval_length = 1;\n+    bool interval_specified = false;\n+    Int64 ts_scale_multiplier = 0;\n+};\n+\n \n void registerWindowFunctions(AggregateFunctionFactory & factory)\n {\n@@ -2299,6 +2424,13 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)\n             return std::make_shared<WindowFunctionExponentialTimeDecayedAvg>(\n                 name, argument_types, parameters);\n         }, properties});\n+\n+    factory.registerFunction(\"nonNegativeDerivative\", {[](const std::string & name,\n+           const DataTypes & argument_types, const Array & parameters, const Settings *)\n+        {\n+            return std::make_shared<WindowFunctionNonNegativeDerivative>(\n+                name, argument_types, parameters);\n+        }, properties});\n }\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02346_non_negative_derivative.reference b/tests/queries/0_stateless/02346_non_negative_derivative.reference\nnew file mode 100644\nindex 000000000000..51fe2359bd01\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_non_negative_derivative.reference\n@@ -0,0 +1,64 @@\n+1\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t0.20550000000000002\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t6.165000000000001e-10\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t8.22e-7\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t0.0010275000000000002\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t1.233\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t86.31\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t5918.400000000001\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t159796.80000000002\n+1979-12-12 21:21:23.000\t1.54\t0\n+1979-12-12 21:21:21.127\t3.7\t0\n+2283-11-11 23:37:36.788\t1.1\t0\n+2283-11-11 23:37:36.789\t2.34\t0\n+1979-12-12 21:21:21.129\t2.1\t0\n+1979-12-12 21:21:22.000\t1.3345\t0\n+1979-12-12 21:21:23.000\t1.54\t1242864\n+1979-12-12 21:21:23.000\t1.54\t0\ndiff --git a/tests/queries/0_stateless/02346_non_negative_derivative.sql b/tests/queries/0_stateless/02346_non_negative_derivative.sql\nnew file mode 100644\nindex 000000000000..265a8afb2cb8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_non_negative_derivative.sql\n@@ -0,0 +1,65 @@\n+DROP TABLE IF EXISTS nnd;\n+\n+CREATE TABLE nnd\n+(\n+    id Int8, ts DateTime64(3, 'UTC'), metric Float64\n+)\n+ENGINE=MergeTree()\n+ORDER BY id;\n+\n+INSERT INTO nnd VALUES (1, toDateTime64('1979-12-12 21:21:21.123456788', 9, 'UTC'), 1.1), (2, toDateTime64('1979-12-12 21:21:21.123456789', 9, 'UTC'), 2.34), (3, toDateTime64('1979-12-12 21:21:21.127', 3, 'UTC'), 3.7);\n+INSERT INTO nnd VALUES (4, toDateTime64('1979-12-12 21:21:21.129', 3, 'UTC'), 2.1), (5, toDateTime('1979-12-12 21:21:22', 'UTC'), 1.3345), (6, toDateTime('1979-12-12 21:21:23', 'UTC'), 1.54), (7, toDateTime('1979-12-12 21:21:23', 'UTC'), 1.54);\n+\n+OPTIMIZE TABLE nnd;\n+\n+-- shall work for precise intervals\n+-- INTERVAL 1 SECOND shall be default\n+SELECT (\n+           SELECT\n+               ts,\n+               metric,\n+               nonNegativeDerivative(metric, ts) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv\n+           FROM nnd\n+           LIMIT 5, 1\n+       ) = (\n+           SELECT\n+               ts,\n+               metric,\n+               nonNegativeDerivative(metric, ts, toIntervalSecond(1)) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv\n+           FROM nnd\n+           LIMIT 5, 1\n+       );\n+SELECT ts, metric, nonNegativeDerivative(metric, ts) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS deriv FROM nnd;\n+-- Nanosecond\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 3 NANOSECOND) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 2 PRECEDING AND 2 FOLLOWING) AS deriv FROM nnd;\n+-- Microsecond\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 4 MICROSECOND) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS deriv FROM nnd;\n+-- Millisecond\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 5 MILLISECOND) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 1 PRECEDING AND 1 FOLLOWING) AS deriv FROM nnd;\n+-- Second\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 6 SECOND) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd;\n+-- Minute\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 7 MINUTE) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND 2 FOLLOWING) AS deriv FROM nnd;\n+-- Hour\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 8 HOUR) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd;\n+-- Day\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 9 DAY) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 3 PRECEDING AND 3 FOLLOWING) AS deriv FROM nnd;\n+-- Week\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 10 WEEK) OVER (PARTITION BY id>3 ORDER BY ts ASC Rows BETWEEN 1 PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd;\n+\n+-- shall not work for month, quarter, year (intervals with floating number of seconds)\n+-- Month\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 11 MONTH) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+-- Quarter\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 12 QUARTER) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+-- Year\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 13 YEAR) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+-- test against wrong arguments/types\n+SELECT ts, metric, nonNegativeDerivative(metric, 1, INTERVAL 3 NANOSECOND) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError BAD_ARGUMENTS }\n+SELECT ts, metric, nonNegativeDerivative('string not datetime', ts, INTERVAL 3 NANOSECOND) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError BAD_ARGUMENTS }\n+SELECT ts, metric, nonNegativeDerivative(metric, ts, INTERVAL 3 NANOSECOND, id) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError BAD_ARGUMENTS }\n+SELECT ts, metric, nonNegativeDerivative(metric) OVER (PARTITION BY metric ORDER BY ts ASC Rows BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING) AS deriv FROM nnd; -- { serverError BAD_ARGUMENTS }\n+\n+-- cleanup\n+DROP TABLE IF EXISTS nnd;\n",
  "problem_statement": "nonNegativeDerivative window function fails with LOGICAL_ERROR\n**Describe the unexpected behaviour**\r\nNew `nonNegativeDerivative` window function fails with LOGICAL_ERROR.\r\n\r\n**How to reproduce**\r\n\r\n```\r\nroot@clickhouse1:/# clickhouse client\r\nClickHouse client version 22.6.1.1985 (official build).\r\nConnecting to localhost:9000 as user default.\r\nConnected to ClickHouse server version 22.6.1 revision 54455.\r\n\r\nclickhouse1 :) Bye.\r\nroot@clickhouse1:/# echo -e \"SELECT id, metric, ts, nonNegativeDerivative(metric, ts) OVER (ORDER BY id ASC) AS nnd FROM values('id Int8, metric Float32, ts DateTime64(0)', (1,1,'2022-12-12 00:00:00'), (2,2,'2022-12-12 00:00:01'),(3,3,'2022-12-12 00:00:02')) FORMAT TabSeparatedWithNames\" | clickhouse client -n 2>&1\r\nReceived exception from server (version 22.6.1):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Invalid number of rows in Chunk column Float32 position 3: expected 3, got 6. (LOGICAL_ERROR)\r\n(query: SELECT id, metric, ts, nonNegativeDerivative(metric, ts) OVER (ORDER BY id ASC) AS nnd FROM values('id Int8, metric Float32, ts DateTime64(0)', (1,1,'2022-12-12 00:00:00'), (2,2,'2022-12-12 00:00:01'),(3,3,'2022-12-12 00:00:02')) FORMAT TabSeparatedWithNames\r\n)\r\nroot@clickhouse1:/# \r\n```\r\n\r\n**Which ClickHouse server version to use**\r\n22.6.1.1985 (official build).\r\n\r\n**Error message and/or stacktrace**\r\n```\r\n2022.06.28 15:45:36.627221 [ 9 ] {5552a5a1-7727-4ee2-a7ad-f06064384257} <Error> TCPHandler: Code: 49. DB::Exception: Invalid number of rows in Chunk column Float32 position 3: expected 3, got 6. (LOGICAL_ERROR), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xb8a147a in /usr/bin/clickhouse\r\n1. DB::Chunk::checkNumRowsIsConsistent() @ 0x1718194e in /usr/bin/clickhouse\r\n2. DB::WindowTransform::prepare() @ 0x173d497f in /usr/bin/clickhouse\r\n3. DB::ExecutingGraph::updateNode(unsigned long, std::__1::queue<DB::ExecutingGraph::Node*, std::__1::deque<DB::ExecutingGraph::Node*, std::__1::allocator<DB::ExecutingGraph::Node*> > >&, std::__1::queue<DB::ExecutingGraph::Node*, std::__1::deque<DB::ExecutingGraph::Node*, std::__1::allocator<DB::ExecutingGraph::Node*> > >&) @ 0x171a9b59 in /usr/bin/clickhouse\r\n4. DB::PipelineExecutor::executeStepImpl(unsigned long, std::__1::atomic<bool>*) @ 0x171a440b in /usr/bin/clickhouse\r\n5. DB::PipelineExecutor::executeImpl(unsigned long) @ 0x171a3921 in /usr/bin/clickhouse\r\n6. DB::PipelineExecutor::execute(unsigned long) @ 0x171a36b8 in /usr/bin/clickhouse\r\n7. ? @ 0x171b38ce in /usr/bin/clickhouse\r\n8. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0xb94d0b7 in /usr/bin/clickhouse\r\n9. ? @ 0xb9504dd in /usr/bin/clickhouse\r\n10. ? @ 0x7f7cd5e02609 in ?\r\n11. clone @ 0x7f7cd5d29293 in ?\r\n```\r\n\n",
  "hints_text": "@zvonand, could you please take a look? \r\n\r\nIf I change window function to `count()` no LOGICAL_ERROR is produced.\r\n\r\n```\r\nroot@clickhouse1:/# echo -e \"SELECT id, metric, ts, count() OVER (ORDER BY id ASC) AS nnd FROM values('id Int8, metric Float32, ts DateTime64(0)', (1,1,'2022-12-12 00:00:00'), (2,2,'2022-12-12 00:00:01'),(3,3,'2022-12-12 00:00:02')) FORMAT TabSeparatedWithNames\" | clickhouse client -n 2>&1\r\nid\tmetric\tts\tnnd\r\n1\t1\t2022-12-12 00:00:00\t1\r\n2\t2\t2022-12-12 00:00:01\t2\r\n3\t3\t2022-12-12 00:00:02\t3\r\n```\nFixed by #38551.\n@zvonand It should to be fixed & reintroduced. \nWhoa, I didn't expect it to be reverted :( @filimonov You mean I re-do the initial PR from scratch once again?\r\n",
  "created_at": "2022-07-03T22:31:29Z"
}