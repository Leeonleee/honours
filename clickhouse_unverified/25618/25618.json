{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25618,
  "instance_id": "ClickHouse__ClickHouse-25618",
  "issue_numbers": [
    "24209"
  ],
  "base_commit": "db2285b78111d730046863a563b2c335a787ab0f",
  "patch": "diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex fcdf6305a681..6e5f7df99bd0 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -204,6 +204,7 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n \n     if (table_join->dictionary_reader)\n     {\n+        LOG_DEBUG(log, \"Performing join over dict\");\n         data->type = Type::DICT;\n         std::get<MapsOne>(data->maps).create(Type::DICT);\n         chooseMethod(key_columns, key_sizes); /// init key_sizes\n@@ -319,30 +320,23 @@ class KeyGetterForDict\n     using Mapped = RowRef;\n     using FindResult = ColumnsHashing::columns_hashing_impl::FindResultImpl<Mapped, true>;\n \n-    KeyGetterForDict(const ColumnRawPtrs & key_columns_, const Sizes &, void *)\n-        : key_columns(key_columns_)\n-    {}\n-\n-    FindResult findKey(const TableJoin & table_join, size_t row, const Arena &)\n+    KeyGetterForDict(const TableJoin & table_join, const ColumnRawPtrs & key_columns)\n     {\n-        const DictionaryReader & reader = *table_join.dictionary_reader;\n-        if (!read_result)\n-        {\n-            reader.readKeys(*key_columns[0], read_result, found, positions);\n-            result.block = &read_result;\n+        table_join.dictionary_reader->readKeys(*key_columns[0], read_result, found, positions);\n \n-            if (table_join.forceNullableRight())\n-                for (auto & column : read_result)\n-                    if (table_join.rightBecomeNullable(column.type))\n-                        JoinCommon::convertColumnToNullable(column);\n-        }\n+        for (ColumnWithTypeAndName & column : read_result)\n+            if (table_join.rightBecomeNullable(column.type))\n+                JoinCommon::convertColumnToNullable(column);\n+    }\n \n+    FindResult findKey(void *, size_t row, const Arena &)\n+    {\n+        result.block = &read_result;\n         result.row_num = positions[row];\n         return FindResult(&result, found[row], 0);\n     }\n \n private:\n-    const ColumnRawPtrs & key_columns;\n     Block read_result;\n     Mapped result;\n     ColumnVector<UInt8>::Container found;\n@@ -851,6 +845,7 @@ void setUsed(IColumn::Filter & filter [[maybe_unused]], size_t pos [[maybe_unuse\n /// Makes filter (1 if row presented in right table) and returns offsets to replicate (for ALL JOINS).\n template <ASTTableJoin::Kind KIND, ASTTableJoin::Strictness STRICTNESS, typename KeyGetter, typename Map, bool need_filter, bool has_null_map>\n NO_INLINE IColumn::Filter joinRightColumns(\n+    KeyGetter && key_getter,\n     const Map & map,\n     AddedColumns & added_columns,\n     const ConstNullMapPtr & null_map [[maybe_unused]],\n@@ -880,8 +875,6 @@ NO_INLINE IColumn::Filter joinRightColumns(\n     if constexpr (need_replication)\n         added_columns.offsets_to_replicate = std::make_unique<IColumn::Offsets>(rows);\n \n-    auto key_getter = createKeyGetter<KeyGetter, is_asof_join>(added_columns.key_columns, added_columns.key_sizes);\n-\n     IColumn::Offset current_offset = 0;\n \n     for (size_t i = 0; i < rows; ++i)\n@@ -980,35 +973,51 @@ NO_INLINE IColumn::Filter joinRightColumns(\n \n template <ASTTableJoin::Kind KIND, ASTTableJoin::Strictness STRICTNESS, typename KeyGetter, typename Map>\n IColumn::Filter joinRightColumnsSwitchNullability(\n-    const Map & map, AddedColumns & added_columns, const ConstNullMapPtr & null_map, JoinStuff::JoinUsedFlags & used_flags)\n+        KeyGetter && key_getter,\n+        const Map & map,\n+        AddedColumns & added_columns,\n+        const ConstNullMapPtr & null_map,\n+        JoinStuff::JoinUsedFlags & used_flags)\n {\n     if (added_columns.need_filter)\n     {\n         if (null_map)\n-            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, true, true>(map, added_columns, null_map, used_flags);\n+            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, true, true>(\n+                    std::forward<KeyGetter>(key_getter), map, added_columns, null_map, used_flags);\n         else\n-            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, true, false>(map, added_columns, nullptr, used_flags);\n+            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, true, false>(\n+                    std::forward<KeyGetter>(key_getter), map, added_columns, nullptr, used_flags);\n     }\n     else\n     {\n         if (null_map)\n-            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, false, true>(map, added_columns, null_map, used_flags);\n+            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, false, true>(\n+                    std::forward<KeyGetter>(key_getter), map, added_columns, null_map, used_flags);\n         else\n-            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, false, false>(map, added_columns, nullptr, used_flags);\n+            return joinRightColumns<KIND, STRICTNESS, KeyGetter, Map, false, false>(\n+                    std::forward<KeyGetter>(key_getter), map, added_columns, nullptr, used_flags);\n     }\n }\n \n template <ASTTableJoin::Kind KIND, ASTTableJoin::Strictness STRICTNESS, typename Maps>\n IColumn::Filter switchJoinRightColumns(\n-    const Maps & maps_, AddedColumns & added_columns, HashJoin::Type type, const ConstNullMapPtr & null_map, JoinStuff::JoinUsedFlags & used_flags)\n+    const Maps & maps_,\n+    AddedColumns & added_columns,\n+    HashJoin::Type type,\n+    const ConstNullMapPtr & null_map,\n+    JoinStuff::JoinUsedFlags & used_flags)\n {\n+    constexpr bool is_asof_join = STRICTNESS == ASTTableJoin::Strictness::Asof;\n     switch (type)\n     {\n     #define M(TYPE) \\\n         case HashJoin::Type::TYPE: \\\n-            return joinRightColumnsSwitchNullability<KIND, STRICTNESS,\\\n-                typename KeyGetterForType<HashJoin::Type::TYPE, const std::remove_reference_t<decltype(*maps_.TYPE)>>::Type>(\\\n-                *maps_.TYPE, added_columns, null_map, used_flags);\n+        { \\\n+            using KeyGetter = typename KeyGetterForType<HashJoin::Type::TYPE, const std::remove_reference_t<decltype(*maps_.TYPE)>>::Type; \\\n+            auto key_getter = createKeyGetter<KeyGetter, is_asof_join>(added_columns.key_columns, added_columns.key_sizes); \\\n+            return joinRightColumnsSwitchNullability<KIND, STRICTNESS, KeyGetter>( \\\n+                std::move(key_getter), *maps_.TYPE, added_columns, null_map, used_flags); \\\n+        }\n         APPLY_FOR_JOIN_VARIANTS(M)\n     #undef M\n \n@@ -1025,8 +1034,12 @@ IColumn::Filter dictionaryJoinRightColumns(const TableJoin & table_join, AddedCo\n         STRICTNESS == ASTTableJoin::Strictness::Semi ||\n         STRICTNESS == ASTTableJoin::Strictness::Anti))\n     {\n+        assert(added_columns.key_columns.size() == 1);\n+\n         JoinStuff::JoinUsedFlags flags;\n-        return joinRightColumnsSwitchNullability<KIND, STRICTNESS, KeyGetterForDict>(table_join, added_columns, null_map, flags);\n+        KeyGetterForDict key_getter(table_join, added_columns.key_columns);\n+        return joinRightColumnsSwitchNullability<KIND, STRICTNESS, KeyGetterForDict>(\n+                std::move(key_getter), nullptr, added_columns, null_map, flags);\n     }\n \n     throw Exception(\"Logical error: wrong JOIN combination\", ErrorCodes::LOGICAL_ERROR);\n",
  "test_patch": "diff --git a/tests/performance/dict_join.xml b/tests/performance/dict_join.xml\nnew file mode 100644\nindex 000000000000..1fa5ce1726c2\n--- /dev/null\n+++ b/tests/performance/dict_join.xml\n@@ -0,0 +1,37 @@\n+<test>\n+    <create_query>\n+        CREATE TABLE join_dictionary_source_table (key UInt64, value String)\n+        ENGINE = MergeTree ORDER BY key;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY join_hashed_dictionary (key UInt64, value String)\n+        PRIMARY KEY key \n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'join_dictionary_source_table'))\n+        LIFETIME(MIN 0 MAX 1000)\n+        LAYOUT(HASHED());\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO join_dictionary_source_table\n+        SELECT number, toString(number)\n+        FROM numbers(1000000);\n+    </fill_query>\n+    \n+    <query>\n+        SELECT COUNT() \n+        FROM join_dictionary_source_table\n+        JOIN join_hashed_dictionary\n+        ON join_dictionary_source_table.key = join_hashed_dictionary.key;\n+    </query>\n+\n+    <query>\n+        SELECT COUNT() \n+        FROM join_dictionary_source_table\n+        JOIN join_hashed_dictionary\n+        ON join_dictionary_source_table.key = toUInt64(join_hashed_dictionary.key);\n+    </query>\n+\n+    <drop_query>DROP DICTIONARY IF EXISTS join_hashed_dictionary;</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS join_dictionary_source_table;</drop_query>\n+</test>\n",
  "problem_statement": "Join on external dictionary works slow with grouping\nSelect query with aggregation and join on external dictionary works slow when no cast in join expression provided. Table and the dictionary both have UInt64 id's. When using explicit cast like `table.dict_id = toUInt64(dict.id)` the query works fast.\r\n\r\n**Does it reproduce on recent release?**\r\nYes\r\n\r\n**How to reproduce**\r\n* ClickHouse server version to use: 21.4.6.55\r\n\r\n```\r\ncreate table test (key UInt64, value String) engine=MergeTree order by key;\r\ninsert into test select number, '' from numbers(1000000);\r\n\r\ncreate dictionary test_dict (key UInt64, value String)\r\nprimary key key source(clickhouse(table test db 'default' user 'default'))\r\nlifetime(min 0 max 0) layout(hashed());\r\n\r\n-- Select without GROUP BY\r\n-- 1.1\r\nselect test.key, test_dict.value from test join test_dict on test.key = test_dict.key limit 1;\r\n-- Elapsed: 0.038 sec.\r\n\r\n-- 1.2\r\nselect test.key, test_dict.value from test join test_dict on test.key = toUInt64(test_dict.key) limit 1;\r\n-- Elapsed: 0.316 sec. Processed 1.00 million rows, 17.00 MB (3.17 million rows/s., 53.86 MB/s.)\r\n\r\n-- 1.3\r\nselect test.key, dictGetString('test_dict', 'value', test.key) from test limit 1;\r\n-- Elapsed: 0.007 sec.\r\n\r\n-- Select with GROUP BY\r\n\r\n-- 2.1\r\nselect test.key from test join test_dict on test.key = test_dict.key group by test.key limit 1;\r\n-- Elapsed: 1286.466 sec. Processed 1.00 million rows, 8.00 MB (777.32 rows/s., 6.22 KB/s.)\r\n\r\n-- 2.2\r\nselect test.key from test join test_dict on test.key = toUInt64(test_dict.key) group by test.key limit 1;\r\n-- Elapsed: 0.169 sec. Processed 2.00 million rows, 16.00 MB (11.81 million rows/s., 94.49 MB/s.)\r\n\r\n-- 2.3\r\nselect test.key, dictGetString('test_dict', 'value', test.key) from test group by test.key limit 1;\r\n--  Elapsed: 0.056 sec. Processed 1.00 million rows, 8.00 MB (17.91 million rows/s., 143.32 MB/s.)\r\n\r\n```\r\n\r\n**Expected behavior**\r\nBoth queries with explicit cast in join and without it expected to work fast.\r\n\n",
  "hints_text": "@vkosh You have `LIMIT 1` in queries without GROUP BY, they return first record as soon as it has been read.\r\nIn contrast, the queries with GROUP BY have to finish reading and aggregating all data before returning result.\r\n\r\nWorkaround: remove GROUP BY and replace it with DISTINCT.\n@alexey-milovidov,\r\nIn real queries I use GROUP BY to aggregate some data from MergeTree table, grouped by dictionary key field, e.g.:\r\n```\r\nselect count(), user_dict.email\r\nfrom click join user_dict on click.user_id = user_dict.id\r\ngroup by click.user_id;\r\n```\r\nSo I actually use workaround from 2.2 case.\r\nAnyway thanks for the suggestion.\r\n\nI cannot explain the difference between 2.1 and 2.2, it is strange indeed.\nI checked the code and can qualify it as a bug.\r\n\r\n`KeyGetterForDict::findKey` is reading the whole dictionary for every record.\r\nThis code simply should not exist.",
  "created_at": "2021-06-23T09:13:19Z"
}