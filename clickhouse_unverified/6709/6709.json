{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 6709,
  "instance_id": "ClickHouse__ClickHouse-6709",
  "issue_numbers": [
    "6666"
  ],
  "base_commit": "457bc541eede10efed161b4c5ba1c291a2aabd82",
  "patch": "diff --git a/dbms/programs/main.cpp b/dbms/programs/main.cpp\nindex 3fbbcee0f159..760eae4298b6 100644\n--- a/dbms/programs/main.cpp\n+++ b/dbms/programs/main.cpp\n@@ -21,6 +21,7 @@\n #include <Common/StringUtils/StringUtils.h>\n \n #include <common/phdr_cache.h>\n+#include <ext/scope_guard.h>\n \n \n /// Universal executable for various clickhouse applications\n@@ -130,8 +131,19 @@ bool isClickhouseApp(const std::string & app_suffix, std::vector<char *> & argv)\n }\n \n \n+/// This allows to implement assert to forbid initialization of a class in static constructors.\n+/// Usage:\n+///\n+/// extern bool inside_main;\n+/// class C { C() { assert(inside_main); } };\n+bool inside_main = false;\n+\n+\n int main(int argc_, char ** argv_)\n {\n+    inside_main = true;\n+    SCOPE_EXIT({ inside_main = false; });\n+\n     /// Reset new handler to default (that throws std::bad_alloc)\n     /// It is needed because LLVM library clobbers it.\n     std::set_new_handler(nullptr);\ndiff --git a/dbms/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp b/dbms/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\nindex 8fb6ab5a359c..0cd5ffb03e0f 100644\n--- a/dbms/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\n+++ b/dbms/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\n@@ -13,6 +13,8 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnNullable.h>\n #include <Interpreters/castColumn.h>\n+#include <algorithm>\n+\n \n namespace DB\n {\n@@ -27,34 +29,28 @@ namespace DB\n         extern const int CANNOT_INSERT_NULL_IN_ORDINARY_COLUMN;\n         extern const int THERE_IS_NO_COLUMN;\n     }\n-    const std::unordered_map<arrow::Type::type, std::shared_ptr<IDataType>> arrow_type_to_internal_type = {\n-            //{arrow::Type::DECIMAL, std::make_shared<DataTypeDecimal>()},\n-            {arrow::Type::UINT8, std::make_shared<DataTypeUInt8>()},\n-            {arrow::Type::INT8, std::make_shared<DataTypeInt8>()},\n-            {arrow::Type::UINT16, std::make_shared<DataTypeUInt16>()},\n-            {arrow::Type::INT16, std::make_shared<DataTypeInt16>()},\n-            {arrow::Type::UINT32, std::make_shared<DataTypeUInt32>()},\n-            {arrow::Type::INT32, std::make_shared<DataTypeInt32>()},\n-            {arrow::Type::UINT64, std::make_shared<DataTypeUInt64>()},\n-            {arrow::Type::INT64, std::make_shared<DataTypeInt64>()},\n-            {arrow::Type::HALF_FLOAT, std::make_shared<DataTypeFloat32>()},\n-            {arrow::Type::FLOAT, std::make_shared<DataTypeFloat32>()},\n-            {arrow::Type::DOUBLE, std::make_shared<DataTypeFloat64>()},\n-\n-            {arrow::Type::BOOL, std::make_shared<DataTypeUInt8>()},\n-            //{arrow::Type::DATE32, std::make_shared<DataTypeDate>()},\n-            {arrow::Type::DATE32, std::make_shared<DataTypeDate>()},\n-            //{arrow::Type::DATE32, std::make_shared<DataTypeDateTime>()},\n-            {arrow::Type::DATE64, std::make_shared<DataTypeDateTime>()},\n-            {arrow::Type::TIMESTAMP, std::make_shared<DataTypeDateTime>()},\n-            //{arrow::Type::TIME32, std::make_shared<DataTypeDateTime>()},\n-\n-\n-            {arrow::Type::STRING, std::make_shared<DataTypeString>()},\n-            {arrow::Type::BINARY, std::make_shared<DataTypeString>()},\n-            //{arrow::Type::FIXED_SIZE_BINARY, std::make_shared<DataTypeString>()},\n-            //{arrow::Type::UUID, std::make_shared<DataTypeString>()},\n \n+    static const std::initializer_list<std::pair<arrow::Type::type, const char *>> arrow_type_to_internal_type =\n+    {\n+            {arrow::Type::UINT8, \"UInt8\"},\n+            {arrow::Type::INT8, \"Int8\"},\n+            {arrow::Type::UINT16, \"UInt16\"},\n+            {arrow::Type::INT16, \"Int16\"},\n+            {arrow::Type::UINT32, \"UInt32\"},\n+            {arrow::Type::INT32, \"Int32\"},\n+            {arrow::Type::UINT64, \"UInt64\"},\n+            {arrow::Type::INT64, \"Int64\"},\n+            {arrow::Type::HALF_FLOAT, \"Float32\"},\n+            {arrow::Type::FLOAT, \"Float32\"},\n+            {arrow::Type::DOUBLE, \"Float64\"},\n+\n+            {arrow::Type::BOOL, \"UInt8\"},\n+            {arrow::Type::DATE32, \"Date\"},\n+            {arrow::Type::DATE64, \"DateTime\"},\n+            {arrow::Type::TIMESTAMP, \"DateTime\"},\n+\n+            {arrow::Type::STRING, \"String\"},\n+            {arrow::Type::BINARY, \"String\"},\n \n             // TODO: add other types that are convertable to internal ones:\n             // 0. ENUM?\n@@ -253,7 +249,7 @@ namespace DB\n     void ArrowColumnToCHColumn::arrowTableToCHChunk(Chunk &res, std::shared_ptr<arrow::Table> &table,\n                                                     arrow::Status &read_status, const Block &header,\n                                                     int &row_group_current, const Context &context, std::string format_name)\n-                                                    {\n+    {\n         Columns columns_list;\n         UInt64 num_rows = 0;\n \n@@ -308,15 +304,16 @@ namespace DB\n                 const auto decimal_type = static_cast<arrow::DecimalType *>(arrow_column->type().get());\n                 internal_nested_type = std::make_shared<DataTypeDecimal<Decimal128>>(decimal_type->precision(),\n                                                                                      decimal_type->scale());\n-            } else if (arrow_type_to_internal_type.find(arrow_type) != arrow_type_to_internal_type.end())\n+            }\n+            else if (auto internal_type_it = std::find_if(arrow_type_to_internal_type.begin(), arrow_type_to_internal_type.end(),\n+                [=](auto && elem) { return elem.first == arrow_type; });\n+                internal_type_it != arrow_type_to_internal_type.end())\n             {\n-                internal_nested_type = arrow_type_to_internal_type.at(arrow_type);\n+                internal_nested_type = DataTypeFactory::instance().get(internal_type_it->second);\n             }\n             else\n             {\n-                throw Exception\n-                {\n-                        \"The type \\\"\" + arrow_column->type()->name() + \"\\\" of an input column \\\"\" + arrow_column->name()\n+                throw Exception{\"The type \\\"\" + arrow_column->type()->name() + \"\\\" of an input column \\\"\" + arrow_column->name()\n                         + \"\\\" is not supported for conversion from a \" + format_name + \" data format\",\n                         ErrorCodes::CANNOT_CONVERT_TYPE};\n             }\ndiff --git a/libs/libcommon/src/DateLUTImpl.cpp b/libs/libcommon/src/DateLUTImpl.cpp\nindex 3f812accb489..51f5ceb759cc 100644\n--- a/libs/libcommon/src/DateLUTImpl.cpp\n+++ b/libs/libcommon/src/DateLUTImpl.cpp\n@@ -16,6 +16,7 @@\n #include <memory>\n #include <chrono>\n #include <cstring>\n+#include <cassert>\n #include <iostream>\n \n #define DATE_LUT_MIN 0\n@@ -44,9 +45,16 @@ UInt8 getDayOfWeek(const cctz::civil_day & date)\n }\n \n \n+__attribute__((__weak__)) extern bool inside_main;\n+\n DateLUTImpl::DateLUTImpl(const std::string & time_zone_)\n     : time_zone(time_zone_)\n {\n+    /// DateLUT should not be initialized in global constructors for the following reasons:\n+    /// 1. It is too heavy.\n+    if (&inside_main)\n+        assert(inside_main);\n+\n     size_t i = 0;\n     time_t start_of_day = DATE_LUT_MIN;\n \ndiff --git a/libs/libdaemon/src/BaseDaemon.cpp b/libs/libdaemon/src/BaseDaemon.cpp\nindex 5c51b357f8aa..807506775aee 100644\n--- a/libs/libdaemon/src/BaseDaemon.cpp\n+++ b/libs/libdaemon/src/BaseDaemon.cpp\n@@ -597,10 +597,12 @@ void BaseDaemon::initialize(Application & self)\n     /// This must be done before any usage of DateLUT. In particular, before any logging.\n     if (config().has(\"timezone\"))\n     {\n-        if (0 != setenv(\"TZ\", config().getString(\"timezone\").data(), 1))\n+        const std::string timezone = config().getString(\"timezone\");\n+        if (0 != setenv(\"TZ\", timezone.data(), 1))\n             throw Poco::Exception(\"Cannot setenv TZ variable\");\n \n         tzset();\n+        DateLUT::setDefaultTimezone(timezone);\n     }\n \n     std::string log_path = config().getString(\"logger.log\", \"\");\n",
  "test_patch": "diff --git a/dbms/tests/integration/README.md b/dbms/tests/integration/README.md\nindex 06819af76683..a0a5322e5a6c 100644\n--- a/dbms/tests/integration/README.md\n+++ b/dbms/tests/integration/README.md\n@@ -34,7 +34,8 @@ set the following environment variables:\n \n ### Running with runner script\n \n-The only requirement is fresh docker configured docker.\n+The only requirement is fresh configured docker and\n+docker pull yandex/clickhouse-integration-tests-runner\n \n Notes:\n * If you want to run integration tests without `sudo` you have to add your user to docker group `sudo usermod -aG docker $USER`. [More information](https://docs.docker.com/install/linux/linux-postinstall/) about docker configuration.\ndiff --git a/dbms/tests/integration/helpers/common_instance_config.xml b/dbms/tests/integration/helpers/0_common_instance_config.xml\nsimilarity index 100%\nrename from dbms/tests/integration/helpers/common_instance_config.xml\nrename to dbms/tests/integration/helpers/0_common_instance_config.xml\ndiff --git a/dbms/tests/integration/helpers/cluster.py b/dbms/tests/integration/helpers/cluster.py\nindex 1288aaa23f27..aadd2e70a529 100644\n--- a/dbms/tests/integration/helpers/cluster.py\n+++ b/dbms/tests/integration/helpers/cluster.py\n@@ -723,7 +723,8 @@ def create_dir(self, destroy_dir=True):\n         os.mkdir(config_d_dir)\n         os.mkdir(users_d_dir)\n \n-        shutil.copy(p.join(HELPERS_DIR, 'common_instance_config.xml'), config_d_dir)\n+        # The file is named with 0_ prefix to be processed before other configuration overloads.\n+        shutil.copy(p.join(HELPERS_DIR, '0_common_instance_config.xml'), config_d_dir)\n \n         # Generate and write macros file\n         macros = self.macros.copy()\ndiff --git a/dbms/tests/integration/test_timezone_config/__init__.py b/dbms/tests/integration/test_timezone_config/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/integration/test_timezone_config/configs/config.xml b/dbms/tests/integration/test_timezone_config/configs/config.xml\nnew file mode 100644\nindex 000000000000..c601a1d09efb\n--- /dev/null\n+++ b/dbms/tests/integration/test_timezone_config/configs/config.xml\n@@ -0,0 +1,4 @@\n+<?xml version=\"1.0\"?>\n+<yandex>\n+    <timezone>America/Los_Angeles</timezone>\n+</yandex>\ndiff --git a/dbms/tests/integration/test_timezone_config/test.py b/dbms/tests/integration/test_timezone_config/test.py\nnew file mode 100644\nindex 000000000000..22e11daa72e8\n--- /dev/null\n+++ b/dbms/tests/integration/test_timezone_config/test.py\n@@ -0,0 +1,17 @@\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+node = cluster.add_instance('node', main_configs=['configs/config.xml'])\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+def test_check_timezone_config(start_cluster):\n+    assert node.query(\"SELECT toDateTime(1111111111)\") == \"2005-03-17 17:58:31\\n\"\n",
  "problem_statement": "timezone provided in config is ignored in 19.13\nAll 19.13 versions are affected:\r\n\r\n```bash\r\ncat tz.xml \r\n<yandex>\r\n  <timezone>America/Chicago</timezone>\r\n</yandex>\r\n \r\ndocker run --name tz -v=$(pwd)/tz.xml:/etc/clickhouse-server/config.d/tz.xml  -d yandex/clickhouse-server:19.13.1.11\r\n\r\ndocker exec -it tz clickhouse-client --query='SELECT timezone();'\r\nEtc/UTC\r\n\r\ndocker exec -it tz cat /etc/clickhouse-server/preprocessed/config.xml | grep timezone \r\n    <!-- <timezone>Europe/Moscow</timezone> -->\r\n  <timezone>America/Chicago</timezone>\r\n```\r\n\r\nOn 19.11 it works properly:\r\n\r\n```bash\r\ndocker rm -f tz\r\ndocker run --name tz -v=$(pwd)/tz.xml:/etc/clickhouse-server/config.d/tz.xml  -d yandex/clickhouse-server:19.11.8.46\r\ndocker exec -it tz clickhouse-client --query='SELECT timezone();'\r\nAmerica/Chicago\r\n```\n",
  "hints_text": "",
  "created_at": "2019-08-28T17:19:00Z"
}