{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33443,
  "instance_id": "ClickHouse__ClickHouse-33443",
  "issue_numbers": [
    "30918"
  ],
  "base_commit": "6eee1fda56675fd1bbc90ac45bd18cee54a54b63",
  "patch": "diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex 0938a9cfee59..747603d0e6db 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -463,12 +463,13 @@ void ClientBase::initBlockOutputStream(const Block & block, ASTPtr parsed_query)\n         /// The query can specify output format or output file.\n         if (const auto * query_with_output = dynamic_cast<const ASTQueryWithOutput *>(parsed_query.get()))\n         {\n+            String out_file;\n             if (query_with_output->out_file)\n             {\n                 select_into_file = true;\n \n                 const auto & out_file_node = query_with_output->out_file->as<ASTLiteral &>();\n-                const auto & out_file = out_file_node.value.safeGet<std::string>();\n+                out_file = out_file_node.value.safeGet<std::string>();\n \n                 std::string compression_method;\n                 if (query_with_output->compression)\n@@ -494,6 +495,12 @@ void ClientBase::initBlockOutputStream(const Block & block, ASTPtr parsed_query)\n                 const auto & id = query_with_output->format->as<ASTIdentifier &>();\n                 current_format = id.name();\n             }\n+            else if (query_with_output->out_file)\n+            {\n+                const auto & format_name = FormatFactory::instance().getFormatFromFileName(out_file);\n+                if (!format_name.empty())\n+                    current_format = format_name;\n+            }\n         }\n \n         if (has_vertical_output_suffix)\n@@ -1008,11 +1015,15 @@ void ClientBase::sendData(Block & sample, const ColumnsDescription & columns_des\n             compression_method = compression_method_node.value.safeGet<std::string>();\n         }\n \n+        String current_format = parsed_insert_query->format;\n+        if (current_format.empty())\n+            current_format = FormatFactory::instance().getFormatFromFileName(in_file);\n+\n         /// Create temporary storage file, to support globs and parallel reading\n         StorageFile::CommonArguments args{\n             WithContext(global_context),\n             parsed_insert_query->table_id,\n-            parsed_insert_query->format,\n+            current_format,\n             getFormatSettings(global_context),\n             compression_method,\n             columns_description_for_query,\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 2068de0d01cd..ae554e62651a 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -14,6 +14,8 @@\n #include <Poco/URI.h>\n #include <Common/Exception.h>\n \n+#include <boost/algorithm/string/case_conv.hpp>\n+\n namespace DB\n {\n \n@@ -391,6 +393,30 @@ void FormatFactory::registerOutputFormat(const String & name, OutputCreator outp\n     target = std::move(output_creator);\n }\n \n+void FormatFactory::registerFileExtension(const String & extension, const String & format_name)\n+{\n+    file_extension_formats[extension] = format_name;\n+}\n+\n+String FormatFactory::getFormatFromFileName(String file_name)\n+{\n+    CompressionMethod compression_method = chooseCompressionMethod(file_name, \"\");\n+    if (CompressionMethod::None != compression_method)\n+    {\n+        auto pos = file_name.find_last_of('.');\n+        if (pos != String::npos)\n+            file_name = file_name.substr(0, pos);\n+    }\n+\n+    auto pos = file_name.find_last_of('.');\n+    if (pos == String::npos)\n+        return \"\";\n+\n+    String file_extension = file_name.substr(pos + 1, String::npos);\n+    boost::algorithm::to_lower(file_extension);\n+    return file_extension_formats[file_extension];\n+}\n+\n void FormatFactory::registerFileSegmentationEngine(const String & name, FileSegmentationEngine file_segmentation_engine)\n {\n     auto & target = dict[name].file_segmentation_engine;\ndiff --git a/src/Formats/FormatFactory.h b/src/Formats/FormatFactory.h\nindex a62b32da0cc0..229adbbb2631 100644\n--- a/src/Formats/FormatFactory.h\n+++ b/src/Formats/FormatFactory.h\n@@ -5,6 +5,7 @@\n #include <Formats/FormatSettings.h>\n #include <Interpreters/Context_fwd.h>\n #include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressionMethod.h>\n #include <base/types.h>\n #include <Core/NamesAndTypes.h>\n \n@@ -108,6 +109,7 @@ class FormatFactory final : private boost::noncopyable\n     };\n \n     using FormatsDictionary = std::unordered_map<String, Creators>;\n+    using FileExtensionFormats = std::unordered_map<String, String>;\n \n public:\n     static FormatFactory & instance();\n@@ -169,6 +171,10 @@ class FormatFactory final : private boost::noncopyable\n     void registerInputFormat(const String & name, InputCreator input_creator);\n     void registerOutputFormat(const String & name, OutputCreator output_creator);\n \n+    /// Register file extension for format\n+    void registerFileExtension(const String & extension, const String & format_name);\n+    String getFormatFromFileName(String file_name);\n+\n     /// Register schema readers for format its name.\n     void registerSchemaReader(const String & name, SchemaReaderCreator schema_reader_creator);\n     void registerExternalSchemaReader(const String & name, ExternalSchemaReaderCreator external_schema_reader_creator);\n@@ -192,6 +198,7 @@ class FormatFactory final : private boost::noncopyable\n \n private:\n     FormatsDictionary dict;\n+    FileExtensionFormats file_extension_formats;\n \n     const Creators & getCreators(const String & name) const;\n \ndiff --git a/src/Formats/registerFormats.cpp b/src/Formats/registerFormats.cpp\nindex 1349c9e33238..289b59654555 100644\n--- a/src/Formats/registerFormats.cpp\n+++ b/src/Formats/registerFormats.cpp\n@@ -196,6 +196,16 @@ void registerFormats()\n     registerTSKVSchemaReader(factory);\n     registerValuesSchemaReader(factory);\n     registerTemplateSchemaReader(factory);\n+\n+    factory.registerFileExtension(\"csv\", \"CSV\");\n+    factory.registerFileExtension(\"tsv\", \"TSV\");\n+    factory.registerFileExtension(\"parquet\", \"Parquet\");\n+    factory.registerFileExtension(\"orc\", \"ORC\");\n+    factory.registerFileExtension(\"native\", \"Native\");\n+    factory.registerFileExtension(\"json\", \"JSON\");\n+    factory.registerFileExtension(\"ndjson\", \"JSONEachRow\");\n+    factory.registerFileExtension(\"xml\", \"XML\");\n+    factory.registerFileExtension(\"avro\", \"Avro\");\n }\n \n }\ndiff --git a/src/Parsers/ParserInsertQuery.cpp b/src/Parsers/ParserInsertQuery.cpp\nindex a968e159a5e6..fc606b15e9f2 100644\n--- a/src/Parsers/ParserInsertQuery.cpp\n+++ b/src/Parsers/ParserInsertQuery.cpp\n@@ -132,11 +132,14 @@ bool ParserInsertQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n                 return false;\n         }\n \n-        /// Read format name\n-        if (!s_format.ignore(pos, expected) || !name_p.parse(pos, format, expected))\n-            return false;\n+        /// Check if we have FORMAT statement\n+        if (s_format.ignore(pos, expected))\n+        {\n+            if (!name_p.parse(pos, format, expected))\n+                return false;\n \n-        tryGetIdentifierNameInto(format, format_str);\n+            tryGetIdentifierNameInto(format, format_str);\n+        }\n     }\n     else if (s_values.ignore(pos, expected))\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02165_auto_format_by_file_extension.reference b/tests/queries/0_stateless/02165_auto_format_by_file_extension.reference\nnew file mode 100644\nindex 000000000000..ca3d2dd1d805\n--- /dev/null\n+++ b/tests/queries/0_stateless/02165_auto_format_by_file_extension.reference\n@@ -0,0 +1,40 @@\n+1\tone\n+2\ttow\n+1\tone\n+2\ttow\n+1\tone\n+2\ttow\n+1\tone\n+2\ttow\n+1\tone\n+2\ttow\n+1\tone\n+2\ttow\n+1\tone\n+2\ttow\n+{\n+\t\"meta\":\n+\t[\n+\t\t{\n+\t\t\t\"name\": \"id\",\n+\t\t\t\"type\": \"UInt64\"\n+\t\t},\n+\t\t{\n+\t\t\t\"name\": \"name\",\n+\t\t\t\"type\": \"String\"\n+\t\t}\n+\t],\n+\n+\t\"data\":\n+\t[\n+\t\t{\n+\t\t\t\"id\": \"1\",\n+\t\t\t\"name\": \"one\"\n+\t\t},\n+\t\t{\n+\t\t\t\"id\": \"2\",\n+\t\t\t\"name\": \"tow\"\n+\t\t}\n+\t],\n+\n+\t\"rows\": 2,\ndiff --git a/tests/queries/0_stateless/02165_auto_format_by_file_extension.sh b/tests/queries/0_stateless/02165_auto_format_by_file_extension.sh\nnew file mode 100755\nindex 000000000000..d2e16d9ec0b6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02165_auto_format_by_file_extension.sh\n@@ -0,0 +1,72 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+set -e\n+\n+[ -e \"${CLICKHOUSE_TMP}\"/hello.csv ] && rm \"${CLICKHOUSE_TMP}\"/hello.csv\n+[ -e \"${CLICKHOUSE_TMP}\"/world.csv.gz ] && rm \"${CLICKHOUSE_TMP}\"/world.csv.gz\n+[ -e \"${CLICKHOUSE_TMP}\"/hello.world.csv ] && rm \"${CLICKHOUSE_TMP}\"/hello.world.csv\n+[ -e \"${CLICKHOUSE_TMP}\"/hello.world.csv.xz ] && rm \"${CLICKHOUSE_TMP}\"/hello.world.csv.xz\n+[ -e \"${CLICKHOUSE_TMP}\"/.htaccess.json ] && rm \"${CLICKHOUSE_TMP}\"/.htaccess.json\n+[ -e \"${CLICKHOUSE_TMP}\"/example.com. ] && rm \"${CLICKHOUSE_TMP}\"/example.com.\n+[ -e \"${CLICKHOUSE_TMP}\"/museum...protobuf ] && rm \"${CLICKHOUSE_TMP}\"/museum...protobuf\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP TABLE IF EXISTS 02165_out_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"CREATE TABLE 02165_out_tb (id UInt64, name String) Engine=Memory;\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO 02165_out_tb Values(1, 'one'), (2, 'tow');\"\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP TABLE IF EXISTS 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"CREATE TABLE 02165_in_tb (id UInt64, name String) Engine=Memory;\"\n+\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/hello.csv';\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/hello.csv' FORMAT CSV;\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/world.csv.gz';\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/world.csv.gz' COMPRESSION 'gz' FORMAT CSV;\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/hello.world.csv';\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/hello.world.csv' FORMAT CSV;\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/hello.world.csv.xz';\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/hello.world.csv.xz' COMPRESSION 'xz' FORMAT CSV;\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/example.com.';\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/example.com.' FORMAT TabSeparated;\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/museum...protobuf';\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/museum...protobuf' FORMAT TabSeparated;\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE 02165_in_tb FROM INFILE '${CLICKHOUSE_TMP}/world.csv.gz';\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_in_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"TRUNCATE TABLE 02165_in_tb;\"\n+\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM 02165_out_tb INTO OUTFILE '${CLICKHOUSE_TMP}/.htaccess.json';\"\n+head -n 26 ${CLICKHOUSE_TMP}/.htaccess.json\n+\n+${CLICKHOUSE_CLIENT} --query \"DROP TABLE IF EXISTS 02165_out_tb;\"\n+${CLICKHOUSE_CLIENT} --query \"DROP TABLE IF EXISTS 02165_in_tb;\"\n+\n+rm \"${CLICKHOUSE_TMP}\"/hello.csv\n+rm \"${CLICKHOUSE_TMP}\"/world.csv.gz\n+rm \"${CLICKHOUSE_TMP}\"/hello.world.csv\n+rm \"${CLICKHOUSE_TMP}\"/hello.world.csv.xz\n+rm \"${CLICKHOUSE_TMP}\"/.htaccess.json\n+rm \"${CLICKHOUSE_TMP}\"/example.com.\n+rm \"${CLICKHOUSE_TMP}\"/museum...protobuf\n",
  "problem_statement": "INTO OUTFILE / FROM INFILE: autodetect FORMAT by file extension\n**Use case**\r\n\r\nThis works:\r\n\r\n```\r\nSELECT * FROM hits_100m_obfuscated INTO OUTFILE 'hits.csv' FORMAT CSV\r\n```\r\n\r\nBut I want this:\r\n\r\n```\r\nSELECT * FROM hits_100m_obfuscated INTO OUTFILE 'hits.csv'\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nEvery format can register file extension(s) in format factory.\r\nIf format is not specified explicitly, we can detect it automatically by file extension.\r\nIt should work for compressed files `hits.csv.gz` as well.\r\n\r\nThe following extensions should be supported at least:\r\ncsv, tsv, parquet, orc, native, json, ndjson, xml, md, avro\r\n\r\n**Addition details**\r\n\r\nLet's also support omitting the format argument for `file`, `url`, `s3`, `hdfs` table functions. \n",
  "hints_text": "I want to try it! @alexey-milovidov \nThank you! Let's do it.\nHi, I have tried for some days, but I still haven\u2019t found a clear solution. I have read a lot of details of parsing. I think I\u2019m lost in the details of parse. Reading widely does not help to solve this problem. Can you give me some hints? Which files should I focus on, and even introduce some related articles about clickhouse parse.I think this will make me more motivated to solve the problem. Thanks! @alexey-milovidov\nFormatFactory.h/cpp - add a method to get the format name from file extension. Like\r\n`String getFormatFromFileExtension(const String & extension)`\r\nIt will return empty string if file extension is unrecognized.\r\n\r\nAllow to register file extensions like\r\n`void registerFileExtension(const String & extension, const String & format_name)`\r\n\r\nVarious formats can register file extensions for theirself.\r\n\nThen find places where FORMAT from query and FROM INFILE, INTO OUTFILE is interpreted.\r\nSomewhere around Client.cpp or ClientBase.cpp.\nIf there is no FORMAT but there is FROM INFILE / INTO OUTFILE, parse file name (after extracting optional compression method).\n@cccgp How is it?\n> @cccgp How is it?\r\n\r\nSorry, I'm busy with work",
  "created_at": "2022-01-07T05:20:59Z"
}