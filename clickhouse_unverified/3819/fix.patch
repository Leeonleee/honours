diff --git a/libs/libcommon/include/common/DateLUTImpl.h b/libs/libcommon/include/common/DateLUTImpl.h
index f506e7a82f68..56d9cc04dd1c 100644
--- a/libs/libcommon/include/common/DateLUTImpl.h
+++ b/libs/libcommon/include/common/DateLUTImpl.h
@@ -24,6 +24,7 @@ class DateLUTImpl
     DateLUTImpl(const std::string & time_zone);
 
 public:
+    /// The order of fields matters for alignment and sizeof.
     struct Values
     {
         /// Least significat 32 bits from time_t at beginning of the day.
@@ -42,10 +43,12 @@ class DateLUTImpl
         UInt8 days_in_month;
 
         /// For days, when offset from UTC was changed due to daylight saving time or permanent change, following values could be non zero.
-        UInt16 time_at_offset_change; /// In seconds from beginning of the day. Assuming offset never changed close to the end of day (so, value < 65536).
         Int16 amount_of_offset_change; /// Usually -3600 or 3600, but look at Lord Howe Island.
+        UInt32 time_at_offset_change; /// In seconds from beginning of the day.
     };
 
+    static_assert(sizeof(Values) == 16);
+
 private:
     /// Lookup table is indexed by DayNum.
     /// Day nums are the same in all time zones. 1970-01-01 is 0 and so on.
@@ -247,8 +250,7 @@ class DateLUTImpl
 
         time_t res = t - lut[index].date;
 
-        /// NOTE We doesn't support cases when time change result in switching to previous day.
-        /// Data is cleaned to avoid these cases, so no underflow occurs here.
+        /// Data is cleaned to avoid possibility of underflow.
         if (res >= lut[index].time_at_offset_change)
             res += lut[index].amount_of_offset_change;
 
diff --git a/libs/libcommon/src/DateLUTImpl.cpp b/libs/libcommon/src/DateLUTImpl.cpp
index 95e5454f90de..76afcd548c20 100644
--- a/libs/libcommon/src/DateLUTImpl.cpp
+++ b/libs/libcommon/src/DateLUTImpl.cpp
@@ -101,7 +101,7 @@ DateLUTImpl::DateLUTImpl(const std::string & time_zone_)
                 ///  when UTC offset was changed. Search is performed with 15-minute granularity, assuming it is enough.
 
                 time_t time_at_offset_change = 900;
-                while (time_at_offset_change < 65536)
+                while (time_at_offset_change < 86400)
                 {
                     auto utc_offset_at_current_time = cctz_time_zone.lookup(std::chrono::system_clock::from_time_t(
                         lut[i - 1].date + time_at_offset_change)).offset;
@@ -112,17 +112,9 @@ DateLUTImpl::DateLUTImpl(const std::string & time_zone_)
                     time_at_offset_change += 900;
                 }
 
-                lut[i - 1].time_at_offset_change = time_at_offset_change >= 65536 ? 0 : time_at_offset_change;
+                lut[i - 1].time_at_offset_change = time_at_offset_change;
 
-/*                std::cerr << lut[i - 1].year << "-" << int(lut[i - 1].month) << "-" << int(lut[i - 1].day_of_month)
-                    << " offset was changed at " << lut[i - 1].time_at_offset_change << " for " << lut[i - 1].amount_of_offset_change << " seconds.
";*/
-
-                /** We doesn't support cases when time change results in switching to previous day.
-                  * As an example, it was a case in Moscow at years 1981..1983 on October 1:
-                  *  clock was adjusted one hour backwards exactly at midnight (that was lead to extra hour 23 of Sep 30th).
-                  * We must clean data (and we will make it slightly incorrect) to avoid these cases.
-                  * (In previous example, it will lead to extra hour 0 of Sep 30 instead.)
-                  */
+                /// We doesn't support cases when time change results in switching to previous day.
                 if (static_cast<int>(lut[i - 1].time_at_offset_change) + static_cast<int>(lut[i - 1].amount_of_offset_change) < 0)
                     lut[i - 1].time_at_offset_change = -lut[i - 1].amount_of_offset_change;
             }
