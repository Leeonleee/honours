diff --git a/base/base/StringRef.h b/base/base/StringRef.h
index f300a2d63df5..1ff6fbd3ee79 100644
--- a/base/base/StringRef.h
+++ b/base/base/StringRef.h
@@ -51,6 +51,8 @@ struct StringRef
     constexpr StringRef(const char * data_) : StringRef(std::string_view{data_}) {} /// NOLINT
     constexpr StringRef() = default;
 
+    bool empty() const { return size == 0; }
+
     std::string toString() const { return std::string(data, size); }
 
     explicit operator std::string() const { return toString(); }
diff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp
index 64c7a84c263f..2152f446b52a 100644
--- a/src/Columns/ColumnObject.cpp
+++ b/src/Columns/ColumnObject.cpp
@@ -58,9 +58,7 @@ class FieldVisitorReplaceNull : public StaticVisitor<Field>
 
     Field operator()(const Null &) const
     {
-        return num_dimensions
-            ? createEmptyArrayField(num_dimensions)
-            : replacement;
+        return num_dimensions ? Array() : replacement;
     }
 
     Field operator()(const Array & x) const
@@ -81,38 +79,6 @@ class FieldVisitorReplaceNull : public StaticVisitor<Field>
     size_t num_dimensions;
 };
 
-/// Calculates number of dimensions in array field.
-/// Returns 0 for scalar fields.
-class FieldVisitorToNumberOfDimensions : public StaticVisitor<size_t>
-{
-public:
-    size_t operator()(const Array & x) const
-    {
-        const size_t size = x.size();
-        std::optional<size_t> dimensions;
-
-        for (size_t i = 0; i < size; ++i)
-        {
-            /// Do not count Nulls, because they will be replaced by default
-            /// values with proper number of dimensions.
-            if (x[i].isNull())
-                continue;
-
-            size_t current_dimensions = applyVisitor(*this, x[i]);
-            if (!dimensions)
-                dimensions = current_dimensions;
-            else if (current_dimensions != *dimensions)
-                throw Exception(ErrorCodes::NUMBER_OF_DIMENSIONS_MISMATHED,
-                    "Number of dimensions mismatched among array elements");
-        }
-
-        return 1 + dimensions.value_or(0);
-    }
-
-    template <typename T>
-    size_t operator()(const T &) const { return 0; }
-};
-
 /// Visitor that allows to get type of scalar field
 /// or least common type of scalars in array.
 /// More optimized version of FieldToDataType.
@@ -292,7 +258,7 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
     if (isNothing(least_common_type.get()))
         column_dim = value_dim;
 
-    if (field.isNull())
+    if (isNothing(base_type))
         value_dim = column_dim;
 
     if (value_dim != column_dim)
diff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp
index 044e03afd104..ab4ac847a1ce 100644
--- a/src/DataTypes/ObjectUtils.cpp
+++ b/src/DataTypes/ObjectUtils.cpp
@@ -693,4 +693,26 @@ void finalizeObjectColumns(MutableColumns & columns)
             column_object->finalize();
 }
 
+Field FieldVisitorReplaceScalars::operator()(const Array & x) const
+{
+    if (num_dimensions_to_keep == 0)
+        return replacement;
+
+    const size_t size = x.size();
+    Array res(size);
+    for (size_t i = 0; i < size; ++i)
+        res[i] = applyVisitor(FieldVisitorReplaceScalars(replacement, num_dimensions_to_keep - 1), x[i]);
+    return res;
+}
+
+size_t FieldVisitorToNumberOfDimensions::operator()(const Array & x) const
+{
+    const size_t size = x.size();
+    size_t dimensions = 0;
+    for (size_t i = 0; i < size; ++i)
+        dimensions = std::max(dimensions, applyVisitor(*this, x[i]));
+
+    return 1 + dimensions;
+}
+
 }
diff --git a/src/DataTypes/ObjectUtils.h b/src/DataTypes/ObjectUtils.h
index 1dbeac2b2443..8dc46ceecf5d 100644
--- a/src/DataTypes/ObjectUtils.h
+++ b/src/DataTypes/ObjectUtils.h
@@ -5,7 +5,6 @@
 #include <Common/FieldVisitors.h>
 #include <Storages/ColumnsDescription.h>
 #include <DataTypes/DataTypeTuple.h>
-#include <DataTypes/Serializations/JSONDataParser.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <Columns/ColumnObject.h>
 
@@ -87,6 +86,37 @@ void replaceMissedSubcolumnsByConstants(
     const ColumnsDescription & available_columns,
     ASTPtr query);
 
+/// Visitor that keeps @num_dimensions_to_keep dimensions in arrays
+/// and replaces all scalars or nested arrays to @replacement at that level.
+class FieldVisitorReplaceScalars : public StaticVisitor<Field>
+{
+public:
+    FieldVisitorReplaceScalars(const Field & replacement_, size_t num_dimensions_to_keep_)
+        : replacement(replacement_), num_dimensions_to_keep(num_dimensions_to_keep_)
+    {
+    }
+
+    Field operator()(const Array & x) const;
+
+    template <typename T>
+    Field operator()(const T &) const { return replacement; }
+
+private:
+    const Field & replacement;
+    size_t num_dimensions_to_keep;
+};
+
+/// Calculates number of dimensions in array field.
+/// Returns 0 for scalar fields.
+class FieldVisitorToNumberOfDimensions : public StaticVisitor<size_t>
+{
+public:
+    size_t operator()(const Array & x) const;
+
+    template <typename T>
+    size_t operator()(const T &) const { return 0; }
+};
+
 /// Receives range of objects, which contains collections
 /// of columns-like objects (e.g. ColumnsDescription or NamesAndTypesList)
 /// and deduces the common types of object columns for all entries.
diff --git a/src/DataTypes/Serializations/JSONDataParser.cpp b/src/DataTypes/Serializations/JSONDataParser.cpp
new file mode 100644
index 000000000000..c3eefb4ab63f
--- /dev/null
+++ b/src/DataTypes/Serializations/JSONDataParser.cpp
@@ -0,0 +1,267 @@
+#include <DataTypes/Serializations/JSONDataParser.h>
+#include <Common/JSONParsers/SimdJSONParser.h>
+#include <Common/JSONParsers/RapidJSONParser.h>
+#include <Common/checkStackSize.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int LOGICAL_ERROR;
+}
+
+template <typename ParserImpl>
+std::optional<ParseResult> JSONDataParser<ParserImpl>::parse(const char * begin, size_t length)
+{
+    std::string_view json{begin, length};
+    Element document;
+    if (!parser.parse(json, document))
+        return {};
+
+    ParseContext context;
+    traverse(document, context);
+
+    ParseResult result;
+    result.values = std::move(context.values);
+    result.paths.reserve(context.paths.size());
+
+    for (auto && path : context.paths)
+        result.paths.emplace_back(std::move(path));
+
+    return result;
+}
+
+template <typename ParserImpl>
+void JSONDataParser<ParserImpl>::traverse(const Element & element, ParseContext & ctx)
+{
+    checkStackSize();
+
+    if (element.isObject())
+    {
+        traverseObject(element.getObject(), ctx);
+    }
+    else if (element.isArray())
+    {
+        traverseArray(element.getArray(), ctx);
+    }
+    else
+    {
+        ctx.paths.push_back(ctx.builder.getParts());
+        ctx.values.push_back(getValueAsField(element));
+    }
+}
+
+template <typename ParserImpl>
+void JSONDataParser<ParserImpl>::traverseObject(const JSONObject & object, ParseContext & ctx)
+{
+    ctx.paths.reserve(ctx.paths.size() + object.size());
+    ctx.values.reserve(ctx.values.size() + object.size());
+
+    for (auto it = object.begin(); it != object.end(); ++it)
+    {
+        const auto & [key, value] = *it;
+        ctx.builder.append(key, false);
+        traverse(value, ctx);
+        ctx.builder.popBack();
+    }
+}
+
+template <typename ParserImpl>
+void JSONDataParser<ParserImpl>::traverseArray(const JSONArray & array, ParseContext & ctx)
+{
+    /// Traverse elements of array and collect an array of fields by each path.
+    ParseArrayContext array_ctx;
+    array_ctx.total_size = array.size();
+
+    for (auto it = array.begin(); it != array.end(); ++it)
+    {
+        traverseArrayElement(*it, array_ctx);
+        ++array_ctx.current_size;
+    }
+
+    auto && arrays_by_path = array_ctx.arrays_by_path;
+
+    if (arrays_by_path.empty())
+    {
+        ctx.paths.push_back(ctx.builder.getParts());
+        ctx.values.push_back(Array());
+    }
+    else
+    {
+        ctx.paths.reserve(ctx.paths.size() + arrays_by_path.size());
+        ctx.values.reserve(ctx.values.size() + arrays_by_path.size());
+
+        for (auto && [_, value] : arrays_by_path)
+        {
+            auto && [path, path_array] = value;
+
+            /// Merge prefix path and path of array element.
+            ctx.paths.push_back(ctx.builder.append(path, true).getParts());
+            ctx.values.push_back(std::move(path_array));
+            ctx.builder.popBack(path.size());
+        }
+    }
+}
+
+template <typename ParserImpl>
+void JSONDataParser<ParserImpl>::traverseArrayElement(const Element & element, ParseArrayContext & ctx)
+{
+    ParseContext element_ctx;
+    traverse(element, element_ctx);
+
+    auto & [_, paths, values] = element_ctx;
+    size_t size = paths.size();
+    size_t keys_to_update = ctx.arrays_by_path.size();
+
+    for (size_t i = 0; i < size; ++i)
+    {
+        if (values[i].isNull())
+            continue;
+
+        UInt128 hash = PathInData::getPartsHash(paths[i]);
+        if (auto * found = ctx.arrays_by_path.find(hash))
+        {
+            auto & path_array = found->getMapped().second;
+            assert(path_array.size() == ctx.current_size);
+
+            /// If current element of array is part of Nested,
+            /// collect its size or check it if the size of
+            /// the Nested has been already collected.
+            auto nested_key = getNameOfNested(paths[i], values[i]);
+            if (!nested_key.empty())
+            {
+                size_t array_size = get<const Array &>(values[i]).size();
+                auto & current_nested_sizes = ctx.nested_sizes_by_key[nested_key];
+
+                if (current_nested_sizes.size() == ctx.current_size)
+                    current_nested_sizes.push_back(array_size);
+                else if (array_size != current_nested_sizes.back())
+                    throw Exception(ErrorCodes::LOGICAL_ERROR,
+                        "Array sizes mismatched ({} and {})", array_size, current_nested_sizes.back());
+            }
+
+            path_array.push_back(std::move(values[i]));
+            --keys_to_update;
+        }
+        else
+        {
+            /// We found a new key. Add and empty array with current size.
+            Array path_array;
+            path_array.reserve(ctx.total_size);
+            path_array.resize(ctx.current_size);
+
+            auto nested_key = getNameOfNested(paths[i], values[i]);
+            if (!nested_key.empty())
+            {
+                size_t array_size = get<const Array &>(values[i]).size();
+                auto & current_nested_sizes = ctx.nested_sizes_by_key[nested_key];
+
+                if (current_nested_sizes.empty())
+                {
+                    current_nested_sizes.resize(ctx.current_size);
+                }
+                else
+                {
+                    /// If newly added element is part of the Nested then
+                    /// resize its elements to keep correct sizes of Nested arrays.
+                    for (size_t j = 0; j < ctx.current_size; ++j)
+                        path_array[j] = Array(current_nested_sizes[j]);
+                }
+
+                if (current_nested_sizes.size() == ctx.current_size)
+                    current_nested_sizes.push_back(array_size);
+                else if (array_size != current_nested_sizes.back())
+                    throw Exception(ErrorCodes::LOGICAL_ERROR,
+                        "Array sizes mismatched ({} and {})", array_size, current_nested_sizes.back());
+            }
+
+            path_array.push_back(std::move(values[i]));
+
+            auto & elem = ctx.arrays_by_path[hash];
+            elem.first = std::move(paths[i]);
+            elem.second = std::move(path_array);
+        }
+    }
+
+    /// If some of the keys are missed in current element,
+    /// add default values for them.
+    if (keys_to_update)
+        fillMissedValuesInArrays(ctx);
+}
+
+template <typename ParserImpl>
+void JSONDataParser<ParserImpl>::fillMissedValuesInArrays(ParseArrayContext & ctx)
+{
+    for (auto & [_, value] : ctx.arrays_by_path)
+    {
+        auto & [path, path_array] = value;
+        assert(path_array.size() == ctx.current_size || path_array.size() == ctx.current_size + 1);
+
+        if (path_array.size() == ctx.current_size)
+        {
+            bool inserted = tryInsertDefaultFromNested(ctx, path, path_array);
+            if (!inserted)
+                path_array.emplace_back();
+        }
+    }
+}
+
+template <typename ParserImpl>
+bool JSONDataParser<ParserImpl>::tryInsertDefaultFromNested(
+    ParseArrayContext & ctx, const PathInData::Parts & path, Array & array)
+{
+    /// If there is a collected size of current Nested
+    /// then insert array of this size as a default value.
+
+    if (path.empty())
+        return false;
+
+    StringRef nested_key{path[0].key};
+    auto * mapped = ctx.nested_sizes_by_key.find(nested_key);
+    if (!mapped)
+        return false;
+
+    auto & current_nested_sizes = mapped->getMapped();
+    assert(current_nested_sizes.size() == ctx.current_size || current_nested_sizes.size() == ctx.current_size + 1);
+
+    /// If all keys of Nested were missed then add a zero length.
+    if (current_nested_sizes.size() == ctx.current_size)
+        current_nested_sizes.push_back(0);
+
+    size_t array_size = current_nested_sizes.back();
+    array.push_back(Array(array_size));
+    return true;
+}
+
+template <typename ParserImpl>
+Field JSONDataParser<ParserImpl>::getValueAsField(const Element & element)
+{
+    if (element.isBool())   return element.getBool();
+    if (element.isInt64())  return element.getInt64();
+    if (element.isUInt64()) return element.getUInt64();
+    if (element.isDouble()) return element.getDouble();
+    if (element.isString()) return element.getString();
+    if (element.isNull())   return Field();
+
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Unsupported type of JSON field");
+}
+
+template <typename ParserImpl>
+StringRef JSONDataParser<ParserImpl>::getNameOfNested(const PathInData::Parts & path, const Field & value)
+{
+    if (value.getType() != Field::Types::Array || path.empty())
+        return {};
+
+    return StringRef{path[0].key};
+}
+
+#if USE_SIMDJSON
+    template class JSONDataParser<SimdJSONParser>;
+#endif
+
+#if USE_RAPIDJSON
+    template class JSONDataParser<RapidJSONParser>;
+#endif
+
+}
diff --git a/src/DataTypes/Serializations/JSONDataParser.h b/src/DataTypes/Serializations/JSONDataParser.h
index 36abc9278d14..d956bfc612b1 100644
--- a/src/DataTypes/Serializations/JSONDataParser.h
+++ b/src/DataTypes/Serializations/JSONDataParser.h
@@ -2,180 +2,61 @@
 
 #include <IO/ReadHelpers.h>
 #include <Common/HashTable/HashMap.h>
-#include <Common/checkStackSize.h>
 #include <DataTypes/Serializations/PathInData.h>
 
 namespace DB
 {
 
-namespace ErrorCodes
-{
-    extern const int LOGICAL_ERROR;
-}
-
 class ReadBuffer;
-class WriteBuffer;
-
-template <typename Element>
-static Field getValueAsField(const Element & element)
-{
-    if (element.isBool())   return element.getBool();
-    if (element.isInt64())  return element.getInt64();
-    if (element.isUInt64()) return element.getUInt64();
-    if (element.isDouble()) return element.getDouble();
-    if (element.isString()) return element.getString();
-    if (element.isNull())   return Field();
-
-    throw Exception(ErrorCodes::LOGICAL_ERROR, "Unsupported type of JSON field");
-}
 
 template <typename ParserImpl>
 class JSONDataParser
 {
 public:
-    using Element = typename ParserImpl::Element;
-
     static void readJSON(String & s, ReadBuffer & buf)
     {
         readJSONObjectPossiblyInvalid(s, buf);
     }
 
-    std::optional<ParseResult> parse(const char * begin, size_t length)
-    {
-        std::string_view json{begin, length};
-        Element document;
-        if (!parser.parse(json, document))
-            return {};
+    std::optional<ParseResult> parse(const char * begin, size_t length);
+
+private:
+    using Element = typename ParserImpl::Element;
+    using JSONObject = typename ParserImpl::Object;
+    using JSONArray = typename ParserImpl::Array;
 
-        ParseResult result;
+    struct ParseContext
+    {
         PathInDataBuilder builder;
         std::vector<PathInData::Parts> paths;
+        std::vector<Field> values;
+    };
 
-        traverse(document, builder, paths, result.values);
-
-        result.paths.reserve(paths.size());
-        for (auto && path : paths)
-            result.paths.emplace_back(std::move(path));
-
-        return result;
-    }
+    using PathPartsWithArray = std::pair<PathInData::Parts, Array>;
+    using PathToArray = HashMapWithStackMemory<UInt128, PathPartsWithArray, UInt128TrivialHash, 5>;
+    using KeyToSizes = HashMapWithStackMemory<StringRef, std::vector<size_t>, StringRefHash, 5>;
 
-private:
-    void traverse(
-        const Element & element,
-        PathInDataBuilder & builder,
-        std::vector<PathInData::Parts> & paths,
-        std::vector<Field> & values)
+    struct ParseArrayContext
     {
-        checkStackSize();
-
-        if (element.isObject())
-        {
-            auto object = element.getObject();
-
-            paths.reserve(paths.size() + object.size());
-            values.reserve(values.size() + object.size());
-
-            for (auto it = object.begin(); it != object.end(); ++it)
-            {
-                const auto & [key, value] = *it;
-                traverse(value, builder.append(key, false), paths, values);
-                builder.popBack();
-            }
-        }
-        else if (element.isArray())
-        {
-            auto array = element.getArray();
-
-            using PathPartsWithArray = std::pair<PathInData::Parts, Array>;
-            using PathToArray = HashMapWithStackMemory<UInt128, PathPartsWithArray, UInt128TrivialHash, 5>;
-
-            /// Traverse elements of array and collect an array
-            /// of fields by each path.
-
-            PathToArray arrays_by_path;
-            Arena strings_pool;
+        size_t current_size = 0;
+        size_t total_size = 0;
 
-            size_t current_size = 0;
-            for (auto it = array.begin(); it != array.end(); ++it)
-            {
-                std::vector<PathInData::Parts> element_paths;
-                std::vector<Field> element_values;
-                PathInDataBuilder element_builder;
+        PathToArray arrays_by_path;
+        KeyToSizes nested_sizes_by_key;
+        Arena strings_pool;
+    };
 
-                traverse(*it, element_builder, element_paths, element_values);
-                size_t size = element_paths.size();
-                size_t keys_to_update = arrays_by_path.size();
+    void traverse(const Element & element, ParseContext & ctx);
+    void traverseObject(const JSONObject & object, ParseContext & ctx);
+    void traverseArray(const JSONArray & array, ParseContext & ctx);
+    void traverseArrayElement(const Element & element, ParseArrayContext & ctx);
 
-                for (size_t i = 0; i < size; ++i)
-                {
-                    UInt128 hash = PathInData::getPartsHash(element_paths[i]);
-                    if (auto * found = arrays_by_path.find(hash))
-                    {
-                        auto & path_array = found->getMapped().second;
+    static void fillMissedValuesInArrays(ParseArrayContext & ctx);
+    static bool tryInsertDefaultFromNested(
+        ParseArrayContext & ctx, const PathInData::Parts & path, Array & array);
 
-                        assert(path_array.size() == current_size);
-                        path_array.push_back(std::move(element_values[i]));
-                        --keys_to_update;
-                    }
-                    else
-                    {
-                        /// We found a new key. Add and empty array with current size.
-                        Array path_array;
-                        path_array.reserve(array.size());
-                        path_array.resize(current_size);
-                        path_array.push_back(std::move(element_values[i]));
-
-                        auto & elem = arrays_by_path[hash];
-                        elem.first = std::move(element_paths[i]);
-                        elem.second = std::move(path_array);
-                    }
-                }
-
-                /// If some of the keys are missed in current element,
-                /// add default values for them.
-                if (keys_to_update)
-                {
-                    for (auto & [_, value] : arrays_by_path)
-                    {
-                        auto & path_array = value.second;
-                        assert(path_array.size() == current_size || path_array.size() == current_size + 1);
-                        if (path_array.size() == current_size)
-                            path_array.push_back(Field());
-                    }
-                }
-
-                ++current_size;
-            }
-
-            if (arrays_by_path.empty())
-            {
-                paths.push_back(builder.getParts());
-                values.push_back(Array());
-            }
-            else
-            {
-                paths.reserve(paths.size() + arrays_by_path.size());
-                values.reserve(values.size() + arrays_by_path.size());
-
-                for (auto && [_, value] : arrays_by_path)
-                {
-                    auto && [path, path_array] = value;
-
-                    /// Merge prefix path and path of array element.
-                    paths.push_back(builder.append(path, true).getParts());
-                    values.push_back(std::move(path_array));
-
-                    builder.popBack(path.size());
-                }
-            }
-        }
-        else
-        {
-            paths.push_back(builder.getParts());
-            values.push_back(getValueAsField(element));
-        }
-    }
+    static Field getValueAsField(const Element & element);
+    static StringRef getNameOfNested(const PathInData::Parts & path, const Field & value);
 
     ParserImpl parser;
 };
diff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp
index 82f9552fb862..2d6555dcb43a 100644
--- a/src/DataTypes/Serializations/SerializationObject.cpp
+++ b/src/DataTypes/Serializations/SerializationObject.cpp
@@ -30,39 +30,6 @@ namespace ErrorCodes
 namespace
 {
 
-/// Visitor that keeps @num_dimensions_to_keep dimensions in arrays
-/// and replaces all scalars or nested arrays to @replacement at that level.
-class FieldVisitorReplaceScalars : public StaticVisitor<Field>
-{
-public:
-    FieldVisitorReplaceScalars(const Field & replacement_, size_t num_dimensions_to_keep_)
-        : replacement(replacement_), num_dimensions_to_keep(num_dimensions_to_keep_)
-    {
-    }
-
-    template <typename T>
-    Field operator()(const T & x) const
-    {
-        if constexpr (std::is_same_v<T, Array>)
-        {
-            if (num_dimensions_to_keep == 0)
-                return replacement;
-
-            const size_t size = x.size();
-            Array res(size);
-            for (size_t i = 0; i < size; ++i)
-                res[i] = applyVisitor(FieldVisitorReplaceScalars(replacement, num_dimensions_to_keep - 1), x[i]);
-            return res;
-        }
-        else
-            return replacement;
-    }
-
-private:
-    const Field & replacement;
-    size_t num_dimensions_to_keep;
-};
-
 using Node = typename ColumnObject::Subcolumns::Node;
 
 /// Finds a subcolumn from the same Nested type as @entry and inserts
@@ -120,7 +87,6 @@ bool tryInsertDefaultFromNested(
 
     auto default_field = applyVisitor(FieldVisitorReplaceScalars(default_scalar, num_dimensions_to_keep), last_field);
     entry->data.insert(std::move(default_field));
-
     return true;
 }
 
