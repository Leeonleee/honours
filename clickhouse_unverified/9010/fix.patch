diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h
index e68eb45d6646..0b4b5adda40a 100644
--- a/dbms/src/Core/Settings.h
+++ b/dbms/src/Core/Settings.h
@@ -391,6 +391,7 @@ struct Settings : public SettingsCollection<Settings>
     M(SettingUInt64, mutations_sync, 0, "Wait for synchronous execution of ALTER TABLE UPDATE/DELETE queries (mutations). 0 - execute asynchronously. 1 - wait current server. 2 - wait all replicas if they exist.", 0) \
     M(SettingBool, optimize_if_chain_to_miltiif, false, "Replace if(cond1, then1, if(cond2, ...)) chains to multiIf. Currently it's not beneficial for numeric types.", 0) \
     M(SettingBool, allow_experimental_alter_materialized_view_structure, false, "Allow atomic alter on Materialized views. Work in progress.", 0) \
+    M(SettingBool, enable_early_constant_folding, true, "Enable query optimization where we analyze function and subqueries results and rewrite query if there're constants there", 0) \
     \
     /** Obsolete settings that do nothing but left for compatibility reasons. Remove each one after half a year of obsolescence. */ \
     \
diff --git a/dbms/src/DataTypes/IDataType.h b/dbms/src/DataTypes/IDataType.h
index 92d0c1057c5f..2f9f113b9552 100644
--- a/dbms/src/DataTypes/IDataType.h
+++ b/dbms/src/DataTypes/IDataType.h
@@ -621,6 +621,12 @@ inline bool isStringOrFixedString(const T & data_type)
     return WhichDataType(data_type).isStringOrFixedString();
 }
 
+template <typename T>
+inline bool isNotCreatable(const T & data_type)
+{
+    WhichDataType which(data_type);
+    return which.isNothing() || which.isFunction() || which.isSet();
+}
 
 inline bool isNotDecimalButComparableToDecimal(const DataTypePtr & data_type)
 {
diff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp
index b76317e8cd23..ac7ea12d898b 100644
--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp
+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp
@@ -212,15 +212,20 @@ static Context getSubqueryContext(const Context & context)
     return subquery_context;
 }
 
-static void sanitizeBlock(Block & block)
+static bool sanitizeBlock(Block & block)
 {
     for (auto & col : block)
     {
         if (!col.column)
+        {
+            if (isNotCreatable(col.type->getTypeId()))
+                return false;
             col.column = col.type->createColumn();
+        }
         else if (isColumnConst(*col.column) && !col.column->empty())
             col.column = col.column->cloneEmpty();
     }
+    return true;
 }
 
 InterpreterSelectQuery::InterpreterSelectQuery(
@@ -613,18 +618,21 @@ Block InterpreterSelectQuery::getSampleBlockImpl(bool try_move_to_prewhere)
 
 /// Check if there is an ignore function. It's used for disabling constant folding in query
 ///  predicates because some performance tests use ignore function as a non-optimize guard.
-static bool hasIgnore(const ExpressionActions & actions)
+static bool allowEarlyConstantFolding(const ExpressionActions & actions, const Context & context)
 {
+    if (!context.getSettingsRef().enable_early_constant_folding)
+        return false;
+
     for (auto & action : actions.getActions())
     {
         if (action.type == action.APPLY_FUNCTION && action.function_base)
         {
             auto name = action.function_base->getName();
             if (name == "ignore")
-                return true;
+                return false;
         }
     }
-    return false;
+    return true;
 }
 
 InterpreterSelectQuery::AnalysisResult
@@ -731,15 +739,17 @@ InterpreterSelectQuery::analyzeExpressions(
             res.prewhere_info = std::make_shared<PrewhereInfo>(
                     chain.steps.front().actions, query.prewhere()->getColumnName());
 
-            if (!hasIgnore(*res.prewhere_info->prewhere_actions))
+            if (allowEarlyConstantFolding(*res.prewhere_info->prewhere_actions, context))
             {
                 Block before_prewhere_sample = source_header;
-                sanitizeBlock(before_prewhere_sample);
-                res.prewhere_info->prewhere_actions->execute(before_prewhere_sample);
-                auto & column_elem = before_prewhere_sample.getByName(query.prewhere()->getColumnName());
-                /// If the filter column is a constant, record it.
-                if (column_elem.column)
-                    res.prewhere_constant_filter_description = ConstantFilterDescription(*column_elem.column);
+                if (sanitizeBlock(before_prewhere_sample))
+                {
+                    res.prewhere_info->prewhere_actions->execute(before_prewhere_sample);
+                    auto & column_elem = before_prewhere_sample.getByName(query.prewhere()->getColumnName());
+                    /// If the filter column is a constant, record it.
+                    if (column_elem.column)
+                        res.prewhere_constant_filter_description = ConstantFilterDescription(*column_elem.column);
+                }
             }
             chain.addStep();
         }
@@ -761,19 +771,21 @@ InterpreterSelectQuery::analyzeExpressions(
             where_step_num = chain.steps.size() - 1;
             has_where = res.has_where = true;
             res.before_where = chain.getLastActions();
-            if (!hasIgnore(*res.before_where))
+            if (allowEarlyConstantFolding(*res.before_where, context))
             {
                 Block before_where_sample;
                 if (chain.steps.size() > 1)
                     before_where_sample = chain.steps[chain.steps.size() - 2].actions->getSampleBlock();
                 else
                     before_where_sample = source_header;
-                sanitizeBlock(before_where_sample);
-                res.before_where->execute(before_where_sample);
-                auto & column_elem = before_where_sample.getByName(query.where()->getColumnName());
-                /// If the filter column is a constant, record it.
-                if (column_elem.column)
-                    res.where_constant_filter_description = ConstantFilterDescription(*column_elem.column);
+                if (sanitizeBlock(before_where_sample))
+                {
+                    res.before_where->execute(before_where_sample);
+                    auto & column_elem = before_where_sample.getByName(query.where()->getColumnName());
+                    /// If the filter column is a constant, record it.
+                    if (column_elem.column)
+                        res.where_constant_filter_description = ConstantFilterDescription(*column_elem.column);
+                }
             }
             chain.addStep();
         }
