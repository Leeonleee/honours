{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9010,
  "instance_id": "ClickHouse__ClickHouse-9010",
  "issue_numbers": [
    "8689"
  ],
  "base_commit": "7f9bab3fc5a7e1947ae0b7e49914e4de02978a10",
  "patch": "diff --git a/dbms/src/Core/Settings.h b/dbms/src/Core/Settings.h\nindex e68eb45d6646..0b4b5adda40a 100644\n--- a/dbms/src/Core/Settings.h\n+++ b/dbms/src/Core/Settings.h\n@@ -391,6 +391,7 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingUInt64, mutations_sync, 0, \"Wait for synchronous execution of ALTER TABLE UPDATE/DELETE queries (mutations). 0 - execute asynchronously. 1 - wait current server. 2 - wait all replicas if they exist.\", 0) \\\n     M(SettingBool, optimize_if_chain_to_miltiif, false, \"Replace if(cond1, then1, if(cond2, ...)) chains to multiIf. Currently it's not beneficial for numeric types.\", 0) \\\n     M(SettingBool, allow_experimental_alter_materialized_view_structure, false, \"Allow atomic alter on Materialized views. Work in progress.\", 0) \\\n+    M(SettingBool, enable_early_constant_folding, true, \"Enable query optimization where we analyze function and subqueries results and rewrite query if there're constants there\", 0) \\\n     \\\n     /** Obsolete settings that do nothing but left for compatibility reasons. Remove each one after half a year of obsolescence. */ \\\n     \\\ndiff --git a/dbms/src/DataTypes/IDataType.h b/dbms/src/DataTypes/IDataType.h\nindex 92d0c1057c5f..2f9f113b9552 100644\n--- a/dbms/src/DataTypes/IDataType.h\n+++ b/dbms/src/DataTypes/IDataType.h\n@@ -621,6 +621,12 @@ inline bool isStringOrFixedString(const T & data_type)\n     return WhichDataType(data_type).isStringOrFixedString();\n }\n \n+template <typename T>\n+inline bool isNotCreatable(const T & data_type)\n+{\n+    WhichDataType which(data_type);\n+    return which.isNothing() || which.isFunction() || which.isSet();\n+}\n \n inline bool isNotDecimalButComparableToDecimal(const DataTypePtr & data_type)\n {\ndiff --git a/dbms/src/Interpreters/InterpreterSelectQuery.cpp b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\nindex b76317e8cd23..ac7ea12d898b 100644\n--- a/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -212,15 +212,20 @@ static Context getSubqueryContext(const Context & context)\n     return subquery_context;\n }\n \n-static void sanitizeBlock(Block & block)\n+static bool sanitizeBlock(Block & block)\n {\n     for (auto & col : block)\n     {\n         if (!col.column)\n+        {\n+            if (isNotCreatable(col.type->getTypeId()))\n+                return false;\n             col.column = col.type->createColumn();\n+        }\n         else if (isColumnConst(*col.column) && !col.column->empty())\n             col.column = col.column->cloneEmpty();\n     }\n+    return true;\n }\n \n InterpreterSelectQuery::InterpreterSelectQuery(\n@@ -613,18 +618,21 @@ Block InterpreterSelectQuery::getSampleBlockImpl(bool try_move_to_prewhere)\n \n /// Check if there is an ignore function. It's used for disabling constant folding in query\n ///  predicates because some performance tests use ignore function as a non-optimize guard.\n-static bool hasIgnore(const ExpressionActions & actions)\n+static bool allowEarlyConstantFolding(const ExpressionActions & actions, const Context & context)\n {\n+    if (!context.getSettingsRef().enable_early_constant_folding)\n+        return false;\n+\n     for (auto & action : actions.getActions())\n     {\n         if (action.type == action.APPLY_FUNCTION && action.function_base)\n         {\n             auto name = action.function_base->getName();\n             if (name == \"ignore\")\n-                return true;\n+                return false;\n         }\n     }\n-    return false;\n+    return true;\n }\n \n InterpreterSelectQuery::AnalysisResult\n@@ -731,15 +739,17 @@ InterpreterSelectQuery::analyzeExpressions(\n             res.prewhere_info = std::make_shared<PrewhereInfo>(\n                     chain.steps.front().actions, query.prewhere()->getColumnName());\n \n-            if (!hasIgnore(*res.prewhere_info->prewhere_actions))\n+            if (allowEarlyConstantFolding(*res.prewhere_info->prewhere_actions, context))\n             {\n                 Block before_prewhere_sample = source_header;\n-                sanitizeBlock(before_prewhere_sample);\n-                res.prewhere_info->prewhere_actions->execute(before_prewhere_sample);\n-                auto & column_elem = before_prewhere_sample.getByName(query.prewhere()->getColumnName());\n-                /// If the filter column is a constant, record it.\n-                if (column_elem.column)\n-                    res.prewhere_constant_filter_description = ConstantFilterDescription(*column_elem.column);\n+                if (sanitizeBlock(before_prewhere_sample))\n+                {\n+                    res.prewhere_info->prewhere_actions->execute(before_prewhere_sample);\n+                    auto & column_elem = before_prewhere_sample.getByName(query.prewhere()->getColumnName());\n+                    /// If the filter column is a constant, record it.\n+                    if (column_elem.column)\n+                        res.prewhere_constant_filter_description = ConstantFilterDescription(*column_elem.column);\n+                }\n             }\n             chain.addStep();\n         }\n@@ -761,19 +771,21 @@ InterpreterSelectQuery::analyzeExpressions(\n             where_step_num = chain.steps.size() - 1;\n             has_where = res.has_where = true;\n             res.before_where = chain.getLastActions();\n-            if (!hasIgnore(*res.before_where))\n+            if (allowEarlyConstantFolding(*res.before_where, context))\n             {\n                 Block before_where_sample;\n                 if (chain.steps.size() > 1)\n                     before_where_sample = chain.steps[chain.steps.size() - 2].actions->getSampleBlock();\n                 else\n                     before_where_sample = source_header;\n-                sanitizeBlock(before_where_sample);\n-                res.before_where->execute(before_where_sample);\n-                auto & column_elem = before_where_sample.getByName(query.where()->getColumnName());\n-                /// If the filter column is a constant, record it.\n-                if (column_elem.column)\n-                    res.where_constant_filter_description = ConstantFilterDescription(*column_elem.column);\n+                if (sanitizeBlock(before_where_sample))\n+                {\n+                    res.before_where->execute(before_where_sample);\n+                    auto & column_elem = before_where_sample.getByName(query.where()->getColumnName());\n+                    /// If the filter column is a constant, record it.\n+                    if (column_elem.column)\n+                        res.where_constant_filter_description = ConstantFilterDescription(*column_elem.column);\n+                }\n             }\n             chain.addStep();\n         }\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01076_array_join_prewhere_const_folding.reference b/dbms/tests/queries/0_stateless/01076_array_join_prewhere_const_folding.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/dbms/tests/queries/0_stateless/01076_array_join_prewhere_const_folding.sql b/dbms/tests/queries/0_stateless/01076_array_join_prewhere_const_folding.sql\nnew file mode 100644\nindex 000000000000..7b80004864d3\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01076_array_join_prewhere_const_folding.sql\n@@ -0,0 +1,10 @@\n+SET log_queries = 1;\n+SELECT 1 LIMIT 0;\n+SYSTEM FLUSH LOGS;\n+\n+SELECT arrayJoin AS kv_key\n+FROM system.query_log\n+ARRAY JOIN ProfileEvents.Names AS arrayJoin\n+PREWHERE has(arrayMap(key -> key, ProfileEvents.Names), 'Query')\n+WHERE arrayJoin = 'Query'\n+LIMIT 0;\n",
  "problem_statement": "Method createColumn() is not implemented for data type Function((String, String) -> String)\ntest case:\r\n```\r\nSELECT\r\n    arrayJoin AS kv_key\r\nFROM system.query_log\r\nARRAY JOIN ProfileEvents.Names AS arrayJoin\r\nPREWHERE has(arrayMap(key -> key, ProfileEvents.Names), 'Query')\r\nWHERE arrayJoin = 'Query'\r\nLIMIT 1\r\n```\r\n\r\nproblem in PREWHERE section\r\n```\r\nMethod createColumn() is not implemented for data type Function((String, String) -> String)\r\n```\r\nClickHouse server version 19.17.4 revision 54428\r\n\r\nproblem similar with https://github.com/ClickHouse/ClickHouse/issues/7799\n",
  "hints_text": "It's most probably related to #7497\r\nThere's some strange expectation about previous chain steps here:\r\nhttps://github.com/ClickHouse/ClickHouse/pull/7497/files#diff-22f780c9dde88bec19a9dac8ce578f1cR719\r\n",
  "created_at": "2020-02-05T10:52:20Z"
}