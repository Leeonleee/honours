{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35027,
  "instance_id": "ClickHouse__ClickHouse-35027",
  "issue_numbers": [
    "34970"
  ],
  "base_commit": "ec5148d5a5d28cd7bd4c5ec701beb25b3dae7f1d",
  "patch": "diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex fb0dbdfff5cb..7e26de574aa7 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -90,6 +90,22 @@ class FunctionDictHelper : WithContext\n         return getDictionary(dict_name_col->getValue<String>());\n     }\n \n+    static const DictionaryAttribute & getDictionaryHierarchicalAttribute(const std::shared_ptr<const IDictionary> & dictionary)\n+    {\n+        const auto & dictionary_structure = dictionary->getStructure();\n+        auto hierarchical_attribute_index_optional = dictionary_structure.hierarchical_attribute_index;\n+\n+        if (!dictionary->hasHierarchy() || !hierarchical_attribute_index_optional.has_value())\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                \"Dictionary {} does not support hierarchy\",\n+                dictionary->getFullName());\n+\n+        size_t hierarchical_attribute_index = *hierarchical_attribute_index_optional;\n+        const auto & hierarchical_attribute = dictionary_structure.attributes[hierarchical_attribute_index];\n+\n+        return hierarchical_attribute;\n+    }\n+\n     bool isDictGetFunctionInjective(const Block & sample_columns)\n     {\n         /// Assume non-injective by default\n@@ -939,39 +955,38 @@ class FunctionDictGetHierarchy final : public IFunction\n \n     bool useDefaultImplementationForConstants() const final { return true; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n+    bool isDeterministic() const override { return false; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (!isString(arguments[0]))\n+        String dictionary_name;\n+        if (const auto * name_col = checkAndGetColumnConst<ColumnString>(arguments[0].column.get()))\n+            dictionary_name = name_col->getValue<String>();\n+        else\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of first argument of function {}. Expected String. Actual type {}\",\n-                getName(),\n-                arguments[0]->getName());\n+                \"Illegal type {} of first argument of function {}, expected a const string.\",\n+                arguments[0].type->getName(),\n+                getName());\n \n-        if (!WhichDataType(arguments[1]).isUInt64())\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of second argument of function {}. Expected UInt64. Actual type {}\",\n-                getName(),\n-                arguments[1]->getName());\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n-        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+        return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n     }\n \n-    bool isDeterministic() const override { return false; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         if (input_rows_count == 0)\n             return result_type->createColumn();\n \n         auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n-        if (!dictionary->hasHierarchy())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                \"Dictionary {} does not support hierarchy\",\n-                dictionary->getFullName());\n+        auto key_column = ColumnWithTypeAndName{arguments[1].column, arguments[1].type, arguments[1].name};\n+        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n+\n+        ColumnPtr result = dictionary->getHierarchy(key_column_casted, hierarchical_attribute.type);\n \n-        ColumnPtr result = dictionary->getHierarchy(arguments[1].column, std::make_shared<DataTypeUInt64>());\n         return result;\n     }\n \n@@ -1009,18 +1024,6 @@ class FunctionDictIsIn final : public IFunction\n                 getName(),\n                 arguments[0]->getName());\n \n-        if (!WhichDataType(arguments[1]).isUInt64())\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of second argument of function {}. Expected UInt64. Actual type {}\",\n-                getName(),\n-                arguments[1]->getName());\n-\n-        if (!WhichDataType(arguments[2]).isUInt64())\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of third argument of function {}. Expected UInt64. Actual type {}\",\n-                getName(),\n-                arguments[2]->getName());\n-\n         return std::make_shared<DataTypeUInt8>();\n     }\n \n@@ -1031,16 +1034,18 @@ class FunctionDictIsIn final : public IFunction\n         if (input_rows_count == 0)\n             return result_type->createColumn();\n \n-        auto dict = helper.getDictionary(arguments[0].column);\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n-        if (!dict->hasHierarchy())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                \"Dictionary {} does not support hierarchy\",\n-                dict->getFullName());\n+        auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[2].name};\n+        auto in_key_column = ColumnWithTypeAndName{arguments[2].column->convertToFullColumnIfConst(), arguments[2].type, arguments[2].name};\n \n-        ColumnPtr res = dict->isInHierarchy(arguments[1].column, arguments[2].column, std::make_shared<DataTypeUInt64>());\n+        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n+        auto in_key_column_casted = castColumnAccurate(in_key_column, hierarchical_attribute.type);\n \n-        return res;\n+        ColumnPtr result = dictionary->isInHierarchy(key_column_casted, in_key_column_casted, hierarchical_attribute.type);\n+\n+        return result;\n     }\n \n     mutable FunctionDictHelper helper;\n@@ -1069,21 +1074,18 @@ class FunctionDictGetChildren final : public IFunction\n     bool isDeterministic() const override { return false; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (!isString(arguments[0]))\n+        if (!isString(arguments[0].type))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type of first argument of function {}. Expected String. Actual type {}\",\n                 getName(),\n-                arguments[0]->getName());\n+                arguments[0].type->getName());\n \n-        if (!WhichDataType(arguments[1]).isUInt64())\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of second argument of function {}. Expected UInt64. Actual type {}\",\n-                getName(),\n-                arguments[1]->getName());\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n-        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+        return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n@@ -1092,13 +1094,12 @@ class FunctionDictGetChildren final : public IFunction\n             return result_type->createColumn();\n \n         auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n-        if (!dictionary->hasHierarchy())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                \"Dictionary {} does not support hierarchy\",\n-                dictionary->getFullName());\n+        auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};\n+        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n \n-        ColumnPtr result = dictionary->getDescendants(arguments[1].column, std::make_shared<DataTypeUInt64>(), 1);\n+        ColumnPtr result = dictionary->getDescendants(key_column_casted, hierarchical_attribute.type, 1);\n \n         return result;\n     }\n@@ -1126,12 +1127,11 @@ class FunctionDictGetDescendants final : public IFunction\n     bool isVariadic() const override { return true; }\n \n     bool useDefaultImplementationForConstants() const final { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0, 2}; }\n     bool isDeterministic() const override { return false; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n \n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         size_t arguments_size = arguments.size();\n         if (arguments_size < 2 || arguments_size > 3)\n@@ -1142,27 +1142,24 @@ class FunctionDictGetDescendants final : public IFunction\n                 arguments_size);\n         }\n \n-        if (!isString(arguments[0]))\n+        if (!isString(arguments[0].type))\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type of first argument of function {}. Expected const String. Actual type {}\",\n                 getName(),\n-                arguments[0]->getName());\n+                arguments[0].type->getName());\n \n-        if (!WhichDataType(arguments[1]).isUInt64())\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Illegal type of second argument of function {}. Expected UInt64. Actual type {}\",\n-                getName(),\n-                arguments[1]->getName());\n-\n-        if (arguments.size() == 3 && !isUnsignedInteger(arguments[2]))\n+        if (arguments.size() == 3 && !isInteger(arguments[2].type))\n         {\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type of third argument of function {}. Expected const unsigned integer. Actual type {}\",\n                 getName(),\n-                arguments[2]->getName());\n+                arguments[2].type->getName());\n         }\n \n-        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n+\n+        return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n@@ -1171,6 +1168,7 @@ class FunctionDictGetDescendants final : public IFunction\n             return result_type->createColumn();\n \n         auto dictionary = helper.getDictionary(arguments[0].column);\n+        const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n         size_t level = 0;\n \n@@ -1181,17 +1179,21 @@ class FunctionDictGetDescendants final : public IFunction\n                     \"Illegal type of third argument of function {}. Expected const unsigned integer.\",\n                     getName());\n \n-            level = static_cast<size_t>(arguments[2].column->get64(0));\n+            auto value = static_cast<Int64>(arguments[2].column->getInt(0));\n+            if (value < 0)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type of third argument of function {}. Expected const unsigned integer.\",\n+                    getName());\n+\n+            level = static_cast<size_t>(value);\n         }\n \n-        if (!dictionary->hasHierarchy())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                \"Dictionary {} does not support hierarchy\",\n-                dictionary->getFullName());\n+        auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};\n+        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n \n-        ColumnPtr res = dictionary->getDescendants(arguments[1].column, std::make_shared<DataTypeUInt64>(), level);\n+        ColumnPtr result = dictionary->getDescendants(key_column_casted, hierarchical_attribute.type, level);\n \n-        return res;\n+        return result;\n     }\n \n     mutable FunctionDictHelper helper;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02231_hierarchical_dictionaries_constant.reference b/tests/queries/0_stateless/02231_hierarchical_dictionaries_constant.reference\nnew file mode 100644\nindex 000000000000..bccd9864b30e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02231_hierarchical_dictionaries_constant.reference\n@@ -0,0 +1,32 @@\n+Get hierarchy\n+[]\n+[1]\n+[2,1]\n+[3,1]\n+[4,2,1]\n+[]\n+Get is in hierarchy\n+1\n+1\n+0\n+Get children\n+[1]\n+[2,3]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,2,3,4]\n+[2,3,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[2,3]\n+[4]\n+[]\n+[]\n+[]\ndiff --git a/tests/queries/0_stateless/02231_hierarchical_dictionaries_constant.sql b/tests/queries/0_stateless/02231_hierarchical_dictionaries_constant.sql\nnew file mode 100644\nindex 000000000000..bc01b447338e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02231_hierarchical_dictionaries_constant.sql\n@@ -0,0 +1,54 @@\n+DROP TABLE IF EXISTS hierarchy_source_table;\n+CREATE TABLE hierarchy_source_table (id UInt64, parent_id UInt64) ENGINE = TinyLog;\n+INSERT INTO hierarchy_source_table VALUES (1, 0), (2, 1), (3, 1), (4, 2);\n+\n+DROP DICTIONARY IF EXISTS hierarchy_flat_dictionary;\n+CREATE DICTIONARY hierarchy_flat_dictionary\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'hierarchy_source_table'))\n+LAYOUT(FLAT())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierarchy_flat_dictionary', 0);\n+SELECT dictGetHierarchy('hierarchy_flat_dictionary', 1);\n+SELECT dictGetHierarchy('hierarchy_flat_dictionary', 2);\n+SELECT dictGetHierarchy('hierarchy_flat_dictionary', 3);\n+SELECT dictGetHierarchy('hierarchy_flat_dictionary', 4);\n+SELECT dictGetHierarchy('hierarchy_flat_dictionary', 5);\n+\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierarchy_flat_dictionary', 1, 1);\n+SELECT dictIsIn('hierarchy_flat_dictionary', 2, 1);\n+SELECT dictIsIn('hierarchy_flat_dictionary', 2, 0);\n+\n+SELECT 'Get children';\n+SELECT dictGetChildren('hierarchy_flat_dictionary', 0);\n+SELECT dictGetChildren('hierarchy_flat_dictionary', 1);\n+SELECT dictGetChildren('hierarchy_flat_dictionary', 2);\n+SELECT dictGetChildren('hierarchy_flat_dictionary', 3);\n+SELECT dictGetChildren('hierarchy_flat_dictionary', 4);\n+SELECT dictGetChildren('hierarchy_flat_dictionary', 5);\n+\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 0);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 1);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 2);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 3);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 4);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 5);\n+\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 0, 1);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 1, 1);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 2, 1);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 3, 1);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 4, 1);\n+SELECT dictGetDescendants('hierarchy_flat_dictionary', 5, 1);\n+\n+DROP DICTIONARY hierarchy_flat_dictionary;\n+DROP TABLE hierarchy_source_table;\n",
  "problem_statement": "HIERARCHICAL dictionary does not support constant keys.\n22.2.2\r\n\r\n```sql\r\ncreate table source (a UInt64, b UInt64, c String) Engine= Memory;\r\n\r\ninsert into source select number, number, 'attr-'||toString(number) from numbers(10);\r\n\r\nCREATE DICTIONARY dict1\r\n( a UInt64 , b UInt64  HIERARCHICAL, c String\r\n) PRIMARY KEY a\r\nSOURCE(clickhouse(DB 'default' TABLE 'source'))\r\nLIFETIME(300) LAYOUT(flat());\r\n\r\nSELECT dictGetDescendants('dict1', toUInt64(2), 0)\r\nDB::Exception: Illegal type of third argument of function dictGetDescendants\r\nExpected const unsigned integer.: While processing dictGetDescendants('dict1', toUInt64(2), 0). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n\r\n-- but !\r\n\r\nSELECT dictGetDescendants('dict1', materialize(toUInt64(2)), 0)\r\n\u250c\u2500dictGetDescendants('dict1', materialize(toUInt64(2)), 0)\u2500\u2510\r\n\u2502 [2]                                                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT dictGetDescendants('dict1', number, 0)\r\nFROM numbers(3)\r\n\u250c\u2500dictGetDescendants('dict1', number, 0)\u2500\u2510\r\n\u2502 [0]                                    \u2502\r\n\u2502 [1]                                    \u2502\r\n\u2502 [2]                                    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n> \"DB::Exception: Illegal type of third argument of function dictGetDescendants\"\r\n\r\nAlso the message is incorrect, the problem is in the second argument,  not the third argument \n",
  "hints_text": "",
  "created_at": "2022-03-03T16:16:33Z"
}