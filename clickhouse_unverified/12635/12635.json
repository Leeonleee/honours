{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12635,
  "instance_id": "ClickHouse__ClickHouse-12635",
  "issue_numbers": [
    "11547"
  ],
  "base_commit": "b26de8d2d15484ceed332573638d1fe01501aebd",
  "patch": "diff --git a/programs/client/TestHint.h b/programs/client/TestHint.h\nindex 81937435b2e3..641c3e0ccf09 100644\n--- a/programs/client/TestHint.h\n+++ b/programs/client/TestHint.h\n@@ -22,8 +22,9 @@ namespace ErrorCodes\n class TestHint\n {\n public:\n-    TestHint(bool enabled_, const String & query)\n-    :   enabled(enabled_)\n+    TestHint(bool enabled_, const String & query_)\n+    : enabled(enabled_)\n+    , query(query_)\n     {\n         if (!enabled_)\n             return;\n@@ -71,7 +72,7 @@ class TestHint\n \n         if (lostExpectedError(actual_server_error, actual_client_error))\n         {\n-            std::cerr << \"Success when error expected. It expects server error \"\n+            std::cerr << \"Success when error expected in query: \" << query << \"It expects server error \"\n                 << server_error << \", client error \" << client_error << \".\" << std::endl;\n             got_exception = true;\n             last_exception = std::make_unique<Exception>(\"Success when error expected\", ErrorCodes::UNEXPECTED_ERROR_CODE); /// return error to OS\n@@ -86,6 +87,7 @@ class TestHint\n \n private:\n     bool enabled = false;\n+    const String & query;\n     int server_error = 0;\n     int client_error = 0;\n \ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 3cd72b7825da..3eb98ef212c5 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -469,7 +469,8 @@ struct Settings : public SettingsCollection<Settings>\n     M(SettingBool, format_regexp_skip_unmatched, false, \"Skip lines unmatched by regular expression (for Regexp format\", 0) \\\n     \\\n     M(SettingBool, output_format_enable_streaming, false, \"Enable streaming in output formats that support it.\", 0) \\\n-    M(SettingBool, output_format_write_statistics, true, \"Write statistics about read rows, bytes, time elapsed in suitable output formats.\", 0)\n+    M(SettingBool, output_format_write_statistics, true, \"Write statistics about read rows, bytes, time elapsed in suitable output formats.\", 0) \\\n+    M(SettingBool, allow_non_metadata_alters, true, \"Allow to execute alters which affects not only tables metadata, but also data on disk\", 0) \\\n \n     #define LIST_OF_SETTINGS(M)    \\\n         COMMON_SETTINGS(M)         \\\ndiff --git a/src/DataTypes/DataTypeEnum.cpp b/src/DataTypes/DataTypeEnum.cpp\nindex 8fcd19bce7d5..9ad6a9cb6909 100644\n--- a/src/DataTypes/DataTypeEnum.cpp\n+++ b/src/DataTypes/DataTypeEnum.cpp\n@@ -354,8 +354,12 @@ bool DataTypeEnum<Type>::contains(const IDataType & rhs) const\n     auto check = [&](const auto & value)\n     {\n         auto it = name_to_value_map.find(value.first);\n+        /// If we don't have this name, than we have to be sure,\n+        /// that this value exists in enum\n         if (it == name_to_value_map.end())\n-            return false;\n+            return value_to_name_map.count(value.second) > 0;\n+\n+        /// If we have this name, than it should have the same value\n         return it->value.second == value.second;\n     };\n \ndiff --git a/src/DataTypes/DataTypeEnum.h b/src/DataTypes/DataTypeEnum.h\nindex dd41ee3fcc76..80b41692cdde 100644\n--- a/src/DataTypes/DataTypeEnum.h\n+++ b/src/DataTypes/DataTypeEnum.h\n@@ -120,7 +120,10 @@ class DataTypeEnum final : public IDataTypeEnum\n     bool textCanContainOnlyValidUTF8() const override;\n     size_t getSizeOfValueInMemory() const override { return sizeof(FieldType); }\n \n-    /// Check current Enum type extends another Enum type (contains all fields with same values).\n+    /// Check current Enum type extends another Enum type (contains all the same values and doesn't override name's with other values)\n+    /// Example:\n+    /// Enum('a' = 1, 'b' = 2) -> Enum('c' = 1, 'b' = 2, 'd' = 3) OK\n+    /// Enum('a' = 1, 'b' = 2) -> Enum('a' = 2, 'b' = 1) NOT OK\n     bool contains(const IDataType & rhs) const;\n };\n \ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex ca2a0aed108f..8e0cd40f6056 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -501,32 +501,6 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, const Context & con\n         throw Exception(\"Wrong parameter type in ALTER query\", ErrorCodes::LOGICAL_ERROR);\n }\n \n-bool AlterCommand::isModifyingData(const StorageInMemoryMetadata & metadata) const\n-{\n-    /// Possible change data representation on disk\n-    if (type == MODIFY_COLUMN)\n-    {\n-        if (data_type == nullptr)\n-            return false;\n-\n-        /// It is allowed to ALTER data type to the same type as before.\n-        for (const auto & column : metadata.columns.getAllPhysical())\n-            if (column.name == column_name)\n-                return !column.type->equals(*data_type);\n-\n-        return true;\n-    }\n-\n-    return type == ADD_COLUMN  /// We need to change columns.txt in each part for MergeTree\n-        || type == DROP_COLUMN /// We need to change columns.txt in each part for MergeTree\n-        || type == DROP_INDEX; /// We need to remove file from filesystem for MergeTree\n-}\n-\n-bool AlterCommand::isSettingsAlter() const\n-{\n-    return type == MODIFY_SETTING;\n-}\n-\n namespace\n {\n \n@@ -538,11 +512,21 @@ bool isMetadataOnlyConversion(const IDataType * from, const IDataType * to)\n     if (from->equals(*to))\n         return true;\n \n+    if (const auto * from_enum8 = typeid_cast<const DataTypeEnum8 *>(from))\n+    {\n+        if (const auto * to_enum8 = typeid_cast<const DataTypeEnum8 *>(to))\n+            return to_enum8->contains(*from_enum8);\n+    }\n+\n+    if (const auto * from_enum16 = typeid_cast<const DataTypeEnum16 *>(from))\n+    {\n+        if (const auto * to_enum16 = typeid_cast<const DataTypeEnum16 *>(to))\n+            return to_enum16->contains(*from_enum16);\n+    }\n+\n     static const std::unordered_multimap<std::type_index, const std::type_info &> ALLOWED_CONVERSIONS =\n         {\n-            { typeid(DataTypeEnum8),    typeid(DataTypeEnum8)    },\n             { typeid(DataTypeEnum8),    typeid(DataTypeInt8)     },\n-            { typeid(DataTypeEnum16),   typeid(DataTypeEnum16)   },\n             { typeid(DataTypeEnum16),   typeid(DataTypeInt16)    },\n             { typeid(DataTypeDateTime), typeid(DataTypeUInt32)   },\n             { typeid(DataTypeUInt32),   typeid(DataTypeDateTime) },\n@@ -583,6 +567,10 @@ bool isMetadataOnlyConversion(const IDataType * from, const IDataType * to)\n \n }\n \n+bool AlterCommand::isSettingsAlter() const\n+{\n+    return type == MODIFY_SETTING;\n+}\n \n bool AlterCommand::isRequireMutationStage(const StorageInMemoryMetadata & metadata) const\n {\n@@ -1009,17 +997,6 @@ void AlterCommands::validate(const StorageInMemoryMetadata & metadata, const Con\n     validateColumnsDefaultsAndGetSampleBlock(default_expr_list, all_columns.getAll(), context);\n }\n \n-bool AlterCommands::isModifyingData(const StorageInMemoryMetadata & metadata) const\n-{\n-    for (const auto & param : *this)\n-    {\n-        if (param.isModifyingData(metadata))\n-            return true;\n-    }\n-\n-    return false;\n-}\n-\n bool AlterCommands::isSettingsAlter() const\n {\n     return std::all_of(begin(), end(), [](const AlterCommand & c) { return c.isSettingsAlter(); });\ndiff --git a/src/Storages/AlterCommands.h b/src/Storages/AlterCommands.h\nindex 1a80957e875e..6dfe796341f0 100644\n--- a/src/Storages/AlterCommands.h\n+++ b/src/Storages/AlterCommands.h\n@@ -113,6 +113,10 @@ struct AlterCommand\n     /// in each part on disk (it's not lightweight alter).\n     bool isModifyingData(const StorageInMemoryMetadata & metadata) const;\n \n+    /// Check that alter command require data modification (mutation) to be\n+    /// executed. For example, cast from Date to UInt16 type can be executed\n+    /// without any data modifications. But column drop or modify from UInt16 to\n+    /// UInt32 require data modification.\n     bool isRequireMutationStage(const StorageInMemoryMetadata & metadata) const;\n \n     /// Checks that only settings changed by alter\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 0501f127b702..49b010de3ba5 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -1275,57 +1275,6 @@ void MergeTreeData::dropIfEmpty()\n namespace\n {\n \n-/// If true, then in order to ALTER the type of the column from the type from to the type to\n-/// we don't need to rewrite the data, we only need to update metadata and columns.txt in part directories.\n-/// The function works for Arrays and Nullables of the same structure.\n-bool isMetadataOnlyConversion(const IDataType * from, const IDataType * to)\n-{\n-    if (from->getName() == to->getName())\n-        return true;\n-\n-    static const std::unordered_multimap<std::type_index, const std::type_info &> ALLOWED_CONVERSIONS =\n-        {\n-            { typeid(DataTypeEnum8),    typeid(DataTypeEnum8)    },\n-            { typeid(DataTypeEnum8),    typeid(DataTypeInt8)     },\n-            { typeid(DataTypeEnum16),   typeid(DataTypeEnum16)   },\n-            { typeid(DataTypeEnum16),   typeid(DataTypeInt16)    },\n-            { typeid(DataTypeDateTime), typeid(DataTypeUInt32)   },\n-            { typeid(DataTypeUInt32),   typeid(DataTypeDateTime) },\n-            { typeid(DataTypeDate),     typeid(DataTypeUInt16)   },\n-            { typeid(DataTypeUInt16),   typeid(DataTypeDate)     },\n-        };\n-\n-    while (true)\n-    {\n-        auto it_range = ALLOWED_CONVERSIONS.equal_range(typeid(*from));\n-        for (auto it = it_range.first; it != it_range.second; ++it)\n-        {\n-            if (it->second == typeid(*to))\n-                return true;\n-        }\n-\n-        const auto * arr_from = typeid_cast<const DataTypeArray *>(from);\n-        const auto * arr_to = typeid_cast<const DataTypeArray *>(to);\n-        if (arr_from && arr_to)\n-        {\n-            from = arr_from->getNestedType().get();\n-            to = arr_to->getNestedType().get();\n-            continue;\n-        }\n-\n-        const auto * nullable_from = typeid_cast<const DataTypeNullable *>(from);\n-        const auto * nullable_to = typeid_cast<const DataTypeNullable *>(to);\n-        if (nullable_from && nullable_to)\n-        {\n-            from = nullable_from->getNestedType().get();\n-            to = nullable_to->getNestedType().get();\n-            continue;\n-        }\n-\n-        return false;\n-    }\n-}\n-\n /// Conversion that is allowed for partition key.\n /// Partition key should be serialized in the same way after conversion.\n /// NOTE: The list is not complete.\n@@ -1361,11 +1310,20 @@ bool isSafeForPartitionKeyConversion(const IDataType * from, const IDataType * t\n \n }\n \n-void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const Settings &) const\n+void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const Settings & settings) const\n {\n     /// Check that needed transformations can be applied to the list of columns without considering type conversions.\n     StorageInMemoryMetadata new_metadata = getInMemoryMetadata();\n     StorageInMemoryMetadata old_metadata = getInMemoryMetadata();\n+\n+    if (!settings.allow_non_metadata_alters)\n+    {\n+\n+        auto mutation_commands = commands.getMutationCommands(new_metadata, settings.materialize_ttl_after_modify, global_context);\n+\n+        if (!mutation_commands.empty())\n+            throw Exception(ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN, \"The following alter commands: '{}' will modify data on disk, but setting `allow_non_metadata_alters` is disabled\", queryToString(mutation_commands.ast()));\n+    }\n     commands.apply(new_metadata, global_context);\n \n     /// Set of columns that shouldn't be altered.\n@@ -1467,8 +1425,10 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n             }\n             dropped_columns.emplace(command.column_name);\n         }\n-        else if (command.isModifyingData(getInMemoryMetadata()))\n+        else if (command.isRequireMutationStage(getInMemoryMetadata()))\n         {\n+            /// This alter will override data on disk. Let's check that it doesn't\n+            /// modify immutable column.\n             if (columns_alter_type_forbidden.count(command.column_name))\n                 throw Exception(\"ALTER of key column \" + backQuoteIfNeed(command.column_name) + \" is forbidden\",\n                     ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n@@ -1478,7 +1438,9 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n                 if (command.type == AlterCommand::MODIFY_COLUMN)\n                 {\n                     auto it = old_types.find(command.column_name);\n-                    if (it == old_types.end() || !isSafeForPartitionKeyConversion(it->second, command.data_type.get()))\n+\n+                    assert(it != old_types.end());\n+                    if (!isSafeForPartitionKeyConversion(it->second, command.data_type.get()))\n                         throw Exception(\"ALTER of partition key column \" + backQuoteIfNeed(command.column_name) + \" from type \"\n                                 + it->second->getName() + \" to type \" + command.data_type->getName()\n                                 + \" is not safe because it can change the representation of partition key\",\n@@ -1491,10 +1453,10 @@ void MergeTreeData::checkAlterIsPossible(const AlterCommands & commands, const S\n                 if (command.type == AlterCommand::MODIFY_COLUMN)\n                 {\n                     auto it = old_types.find(command.column_name);\n-                    if (it == old_types.end() || !isMetadataOnlyConversion(it->second, command.data_type.get()))\n-                        throw Exception(\"ALTER of key column \" + backQuoteIfNeed(command.column_name) + \" from type \"\n-                            + it->second->getName() + \" to type \" + command.data_type->getName() + \" must be metadata-only\",\n-                            ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n+                    assert(it != old_types.end());\n+                    throw Exception(\"ALTER of key column \" + backQuoteIfNeed(command.column_name) + \" from type \"\n+                        + it->second->getName() + \" to type \" + command.data_type->getName() + \" must be metadata-only\",\n+                        ErrorCodes::ALTER_OF_COLUMN_IS_FORBIDDEN);\n                 }\n             }\n         }\ndiff --git a/src/Storages/MutationCommands.h b/src/Storages/MutationCommands.h\nindex 6fa4f7fb6414..50541d5c58a4 100644\n--- a/src/Storages/MutationCommands.h\n+++ b/src/Storages/MutationCommands.h\n@@ -28,7 +28,7 @@ struct MutationCommand\n         DELETE,\n         UPDATE,\n         MATERIALIZE_INDEX,\n-        READ_COLUMN,\n+        READ_COLUMN, /// Read column and apply conversions (MODIFY COLUMN alter query).\n         DROP_COLUMN,\n         DROP_INDEX,\n         MATERIALIZE_TTL,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01344_alter_enum_partition_key.sql b/tests/queries/0_stateless/01344_alter_enum_partition_key.sql\nindex be6b48918eed..ce9d544f3118 100644\n--- a/tests/queries/0_stateless/01344_alter_enum_partition_key.sql\n+++ b/tests/queries/0_stateless/01344_alter_enum_partition_key.sql\n@@ -12,7 +12,7 @@ SELECT * FROM test ORDER BY x;\n SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test' AND active ORDER BY partition;\n \n ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2); -- { serverError 524 }\n-ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'test' = 3); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'test' = 3);\n ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'goodbye' = 4); -- { serverError 524 }\n \n ALTER TABLE test MODIFY COLUMN x Int8;\ndiff --git a/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql\nindex 35faf6f43ec3..1a6c30d95719 100644\n--- a/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql\n+++ b/tests/queries/0_stateless/01346_alter_enum_partition_key_replicated.sql\n@@ -21,7 +21,8 @@ SELECT name, partition, partition_id FROM system.parts WHERE database = currentD\n SELECT name, partition, partition_id FROM system.parts WHERE database = currentDatabase() AND table = 'test2' AND active ORDER BY partition;\n \n ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2); -- { serverError 524 }\n-ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'test' = 3); -- { serverError 524 }\n+ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'test' = 3);\n+\n ALTER TABLE test MODIFY COLUMN x Enum('hello' = 1, 'world' = 2, 'goodbye' = 4); -- { serverError 524 }\n \n ALTER TABLE test MODIFY COLUMN x Int8;\ndiff --git a/tests/queries/0_stateless/01413_allow_non_metadata_alters.reference b/tests/queries/0_stateless/01413_allow_non_metadata_alters.reference\nnew file mode 100644\nindex 000000000000..bd7e2daeb05f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01413_allow_non_metadata_alters.reference\n@@ -0,0 +1,2 @@\n+CREATE TABLE default.non_metadata_alters\\n(\\n    `key` UInt64,\\n    `value1` String,\\n    `value2` Enum8(\\'Hello\\' = 1, \\'World\\' = 2),\\n    `value3` UInt16 TTL value5 + toIntervalDay(5),\\n    `value4` DateTime,\\n    `value5` Date\\n)\\nENGINE = MergeTree()\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\n+CREATE TABLE default.non_metadata_alters\\n(\\n    `key` UInt64,\\n    `value1` String DEFAULT \\'X\\',\\n    `value2` Enum8(\\'Hello\\' = 1, \\'World\\' = 2, \\'!\\' = 3),\\n    `value3` Date TTL value5 + toIntervalDay(5),\\n    `value4` UInt32,\\n    `value5` Date,\\n    `value6` Decimal(3, 3)\\n)\\nENGINE = MergeTree()\\nORDER BY tuple()\\nSETTINGS index_granularity = 8192\ndiff --git a/tests/queries/0_stateless/01413_allow_non_metadata_alters.sql b/tests/queries/0_stateless/01413_allow_non_metadata_alters.sql\nnew file mode 100644\nindex 000000000000..6e876af0e330\n--- /dev/null\n+++ b/tests/queries/0_stateless/01413_allow_non_metadata_alters.sql\n@@ -0,0 +1,49 @@\n+DROP TABLE IF EXISTS non_metadata_alters;\n+\n+CREATE TABLE non_metadata_alters (\n+  key UInt64,\n+  value1 String,\n+  value2 Enum8('Hello' = 1, 'World' = 2),\n+  value3 UInt16,\n+  value4 DateTime,\n+  value5 Date\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+\n+SET allow_non_metadata_alters = 0;\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value3 UInt64; --{serverError 524}\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value1 UInt32; --{serverError 524}\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value4 Date; --{serverError 524}\n+\n+ALTER TABLE non_metadata_alters DROP COLUMN value4; --{serverError 524}\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value2 Enum8('x' = 5, 'y' = 6); --{serverError 524}\n+\n+ALTER TABLE non_metadata_alters RENAME COLUMN value4 TO renamed_value4; --{serverError 524}\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value3 UInt16 TTL value5 + INTERVAL 5 DAY; --{serverError 524}\n+\n+SET materialize_ttl_after_modify = 0;\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value3 UInt16 TTL value5 + INTERVAL 5 DAY;\n+\n+SHOW CREATE TABLE non_metadata_alters;\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value1 String DEFAULT 'X';\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value2 Enum8('Hello' = 1, 'World' = 2, '!' = 3);\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value3 Date;\n+\n+ALTER TABLE non_metadata_alters MODIFY COLUMN value4 UInt32;\n+\n+ALTER TABLE non_metadata_alters ADD COLUMN value6 Decimal(3, 3);\n+\n+SHOW CREATE TABLE non_metadata_alters;\n+\n+DROP TABLE IF EXISTS non_metadata_alters;\n",
  "problem_statement": "Setting to prevent non-metadata alters\nWant to avoid expensive accidental alters, but allow metadata changes (like changing defaults).\r\nSometing like `allow_non_metadata_alters = 0`.\n",
  "hints_text": "",
  "created_at": "2020-07-21T14:10:18Z"
}