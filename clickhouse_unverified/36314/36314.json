{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36314,
  "instance_id": "ClickHouse__ClickHouse-36314",
  "issue_numbers": [
    "34198"
  ],
  "base_commit": "fac600830ea29223184e309dfdbcad2a371454d1",
  "patch": "diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex d923ff0ba03a..e39bc8635e46 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -1462,7 +1462,7 @@ void ClientBase::processParsedSingleQuery(const String & full_query, const Strin\n MultiQueryProcessingStage ClientBase::analyzeMultiQueryText(\n     const char *& this_query_begin, const char *& this_query_end, const char * all_queries_end,\n     String & query_to_execute, ASTPtr & parsed_query, const String & all_queries_text,\n-    std::optional<Exception> & current_exception)\n+    std::unique_ptr<Exception> & current_exception)\n {\n     if (!is_interactive && cancelled)\n         return MultiQueryProcessingStage::QUERIES_END;\n@@ -1500,7 +1500,7 @@ MultiQueryProcessingStage ClientBase::analyzeMultiQueryText(\n     }\n     catch (Exception & e)\n     {\n-        current_exception.emplace(e);\n+        current_exception.reset(e.clone());\n         return MultiQueryProcessingStage::PARSING_EXCEPTION;\n     }\n \n@@ -1581,7 +1581,7 @@ bool ClientBase::executeMultiQuery(const String & all_queries_text)\n     String full_query; // full_query is the query + inline INSERT data + trailing comments (the latter is our best guess for now).\n     String query_to_execute;\n     ASTPtr parsed_query;\n-    std::optional<Exception> current_exception;\n+    std::unique_ptr<Exception> current_exception;\n \n     while (true)\n     {\n@@ -1925,7 +1925,7 @@ void ClientBase::runInteractive()\n         {\n             /// We don't need to handle the test hints in the interactive mode.\n             std::cerr << \"Exception on client:\" << std::endl << getExceptionMessage(e, print_stack_trace, true) << std::endl << std::endl;\n-            client_exception = std::make_unique<Exception>(e);\n+            client_exception.reset(e.clone());\n         }\n \n         if (client_exception)\ndiff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h\nindex 6846fa247e87..f9b30c33d20e 100644\n--- a/src/Client/ClientBase.h\n+++ b/src/Client/ClientBase.h\n@@ -80,7 +80,7 @@ class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>\n     MultiQueryProcessingStage analyzeMultiQueryText(\n         const char *& this_query_begin, const char *& this_query_end, const char * all_queries_end,\n         String & query_to_execute, ASTPtr & parsed_query, const String & all_queries_text,\n-        std::optional<Exception> & current_exception);\n+        std::unique_ptr<Exception> & current_exception);\n \n     static void clearTerminal();\n     void showClientVersion();\ndiff --git a/src/Client/LocalConnection.cpp b/src/Client/LocalConnection.cpp\nindex b1dacedb0422..f7a4fdb50d92 100644\n--- a/src/Client/LocalConnection.cpp\n+++ b/src/Client/LocalConnection.cpp\n@@ -154,17 +154,17 @@ void LocalConnection::sendQuery(\n     catch (const Exception & e)\n     {\n         state->io.onException();\n-        state->exception.emplace(e);\n+        state->exception.reset(e.clone());\n     }\n     catch (const std::exception & e)\n     {\n         state->io.onException();\n-        state->exception.emplace(Exception::CreateFromSTDTag{}, e);\n+        state->exception = std::make_unique<Exception>(Exception::CreateFromSTDTag{}, e);\n     }\n     catch (...)\n     {\n         state->io.onException();\n-        state->exception.emplace(\"Unknown exception\", ErrorCodes::UNKNOWN_EXCEPTION);\n+        state->exception = std::make_unique<Exception>(\"Unknown exception\", ErrorCodes::UNKNOWN_EXCEPTION);\n     }\n }\n \n@@ -260,17 +260,17 @@ bool LocalConnection::poll(size_t)\n         catch (const Exception & e)\n         {\n             state->io.onException();\n-            state->exception.emplace(e);\n+            state->exception.reset(e.clone());\n         }\n         catch (const std::exception & e)\n         {\n             state->io.onException();\n-            state->exception.emplace(Exception::CreateFromSTDTag{}, e);\n+            state->exception = std::make_unique<Exception>(Exception::CreateFromSTDTag{}, e);\n         }\n         catch (...)\n         {\n             state->io.onException();\n-            state->exception.emplace(\"Unknown exception\", ErrorCodes::UNKNOWN_EXCEPTION);\n+            state->exception = std::make_unique<Exception>(\"Unknown exception\", ErrorCodes::UNKNOWN_EXCEPTION);\n         }\n     }\n \n@@ -434,7 +434,7 @@ Packet LocalConnection::receivePacket()\n         }\n         case Protocol::Server::Exception:\n         {\n-            packet.exception = std::make_unique<Exception>(*state->exception);\n+            packet.exception.reset(state->exception->clone());\n             next_packet_type.reset();\n             break;\n         }\ndiff --git a/src/Client/LocalConnection.h b/src/Client/LocalConnection.h\nindex 32af8a4cfa1e..ad6f94122cc5 100644\n--- a/src/Client/LocalConnection.h\n+++ b/src/Client/LocalConnection.h\n@@ -32,7 +32,7 @@ struct LocalQueryState\n     std::unique_ptr<PushingAsyncPipelineExecutor> pushing_async_executor;\n     InternalProfileEventsQueuePtr profile_queue;\n \n-    std::optional<Exception> exception;\n+    std::unique_ptr<Exception> exception;\n \n     /// Current block to be sent next.\n     std::optional<Block> block;\ndiff --git a/src/Common/Exception.cpp b/src/Common/Exception.cpp\nindex 8ba9ac782cab..ddea4af15037 100644\n--- a/src/Common/Exception.cpp\n+++ b/src/Common/Exception.cpp\n@@ -555,13 +555,24 @@ std::string ParsingException::displayText() const\n {\n     try\n     {\n-        if (line_number == -1)\n-            formatted_message = message();\n-        else\n-            formatted_message = message() + fmt::format(\": (at row {})\\n\", line_number);\n+        formatted_message = message();\n+        bool need_newline = false;\n+        if (!file_name.empty())\n+        {\n+            formatted_message += fmt::format(\": (in file/uri {})\", file_name);\n+            need_newline = true;\n+        }\n+\n+        if (line_number != -1)\n+        {\n+            formatted_message += fmt::format(\": (at row {})\", line_number);\n+            need_newline = true;\n+        }\n+\n+        if (need_newline)\n+            formatted_message += \"\\n\";\n     }\n-    catch (...)\n-    {}\n+    catch (...) {}\n \n     if (!formatted_message.empty())\n     {\ndiff --git a/src/Common/Exception.h b/src/Common/Exception.h\nindex c9bb8cc9f122..03f8852613fa 100644\n--- a/src/Common/Exception.h\n+++ b/src/Common/Exception.h\n@@ -132,8 +132,15 @@ class ParsingException : public Exception\n     int getLineNumber() const { return line_number; }\n     void setLineNumber(int line_number_) { line_number = line_number_;}\n \n+    const String getFileName() const { return file_name; }\n+    void setFileName(const String & file_name_) { file_name = file_name_; }\n+\n+    Exception * clone() const override { return new ParsingException(*this); }\n+    void rethrow() const override { throw *this; }\n+\n private:\n     ssize_t line_number{-1};\n+    String file_name;\n     mutable std::string formatted_message;\n \n     const char * name() const throw() override { return \"DB::ParsingException\"; }\ndiff --git a/src/IO/BrotliReadBuffer.cpp b/src/IO/BrotliReadBuffer.cpp\nindex d2e954173a48..c93dfbb5cac9 100644\n--- a/src/IO/BrotliReadBuffer.cpp\n+++ b/src/IO/BrotliReadBuffer.cpp\n@@ -32,14 +32,13 @@ class BrotliReadBuffer::BrotliStateWrapper\n };\n \n BrotliReadBuffer::BrotliReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char *existing_memory, size_t alignment)\n-        : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n-        , in(std::move(in_))\n-        , brotli(std::make_unique<BrotliStateWrapper>())\n-        , in_available(0)\n-        , in_data(nullptr)\n-        , out_capacity(0)\n-        , out_data(nullptr)\n-        , eof_flag(false)\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n+    , brotli(std::make_unique<BrotliStateWrapper>())\n+    , in_available(0)\n+    , in_data(nullptr)\n+    , out_capacity(0)\n+    , out_data(nullptr)\n+    , eof_flag(false)\n {\n }\n \ndiff --git a/src/IO/BrotliReadBuffer.h b/src/IO/BrotliReadBuffer.h\nindex cbb919e15aef..8583d6892eee 100644\n--- a/src/IO/BrotliReadBuffer.h\n+++ b/src/IO/BrotliReadBuffer.h\n@@ -1,13 +1,13 @@\n #pragma once\n \n #include <IO/ReadBuffer.h>\n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n \n \n namespace DB\n {\n \n-class BrotliReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class BrotliReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     explicit BrotliReadBuffer(\n@@ -21,8 +21,6 @@ class BrotliReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n-\n     class BrotliStateWrapper;\n     std::unique_ptr<BrotliStateWrapper> brotli;\n \ndiff --git a/src/IO/Bzip2ReadBuffer.cpp b/src/IO/Bzip2ReadBuffer.cpp\nindex 1f35ad08216f..4bffdbe41dc3 100644\n--- a/src/IO/Bzip2ReadBuffer.cpp\n+++ b/src/IO/Bzip2ReadBuffer.cpp\n@@ -39,10 +39,9 @@ class Bzip2ReadBuffer::Bzip2StateWrapper\n };\n \n Bzip2ReadBuffer::Bzip2ReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char *existing_memory, size_t alignment)\n-        : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n-        , in(std::move(in_))\n-        , bz(std::make_unique<Bzip2StateWrapper>())\n-        , eof_flag(false)\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n+    , bz(std::make_unique<Bzip2StateWrapper>())\n+    , eof_flag(false)\n {\n }\n \ndiff --git a/src/IO/Bzip2ReadBuffer.h b/src/IO/Bzip2ReadBuffer.h\nindex cd5fadf9c82b..9131bf780b9b 100644\n--- a/src/IO/Bzip2ReadBuffer.h\n+++ b/src/IO/Bzip2ReadBuffer.h\n@@ -1,13 +1,13 @@\n #pragma once\n \n #include <IO/ReadBuffer.h>\n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n \n \n namespace DB\n {\n \n-class Bzip2ReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class Bzip2ReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     explicit Bzip2ReadBuffer(\n@@ -21,8 +21,6 @@ class Bzip2ReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n-\n     class Bzip2StateWrapper;\n     std::unique_ptr<Bzip2StateWrapper> bz;\n \ndiff --git a/src/IO/CompressedReadBufferWrapper.h b/src/IO/CompressedReadBufferWrapper.h\nnew file mode 100644\nindex 000000000000..0e23357f625f\n--- /dev/null\n+++ b/src/IO/CompressedReadBufferWrapper.h\n@@ -0,0 +1,25 @@\n+#pragma once\n+#include <IO/BufferWithOwnMemory.h>\n+#include <IO/ReadBuffer.h>\n+\n+namespace DB\n+{\n+\n+class CompressedReadBufferWrapper : public BufferWithOwnMemory<ReadBuffer>\n+{\n+public:\n+    CompressedReadBufferWrapper(\n+      std::unique_ptr<ReadBuffer> in_,\n+      size_t buf_size,\n+      char * existing_memory,\n+      size_t alignment)\n+    : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n+    , in(std::move(in_)) {}\n+\n+    const ReadBuffer & getWrappedReadBuffer() const { return *in; }\n+\n+protected:\n+    std::unique_ptr<ReadBuffer> in;\n+};\n+\n+}\ndiff --git a/src/IO/CompressionMethod.cpp b/src/IO/CompressionMethod.cpp\nindex f6daec78170b..fe4772948ad4 100644\n--- a/src/IO/CompressionMethod.cpp\n+++ b/src/IO/CompressionMethod.cpp\n@@ -98,8 +98,7 @@ CompressionMethod chooseCompressionMethod(const std::string & path, const std::s\n         ErrorCodes::NOT_IMPLEMENTED);\n }\n \n-\n-std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n+static std::unique_ptr<CompressedReadBufferWrapper> createCompressedWrapper(\n     std::unique_ptr<ReadBuffer> nested, CompressionMethod method, size_t buf_size, char * existing_memory, size_t alignment)\n {\n     if (method == CompressionMethod::Gzip || method == CompressionMethod::Zlib)\n@@ -123,10 +122,15 @@ std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n         return std::make_unique<HadoopSnappyReadBuffer>(std::move(nested), buf_size, existing_memory, alignment);\n #endif\n \n+    throw Exception(\"Unsupported compression method\", ErrorCodes::NOT_IMPLEMENTED);\n+}\n+\n+std::unique_ptr<ReadBuffer> wrapReadBufferWithCompressionMethod(\n+    std::unique_ptr<ReadBuffer> nested, CompressionMethod method, size_t buf_size, char * existing_memory, size_t alignment)\n+{\n     if (method == CompressionMethod::None)\n         return nested;\n-\n-    throw Exception(\"Unsupported compression method\", ErrorCodes::NOT_IMPLEMENTED);\n+    return createCompressedWrapper(std::move(nested), method, buf_size, existing_memory, alignment);\n }\n \n \ndiff --git a/src/IO/HadoopSnappyReadBuffer.cpp b/src/IO/HadoopSnappyReadBuffer.cpp\nindex cac05b4827b9..bbda0698b960 100644\n--- a/src/IO/HadoopSnappyReadBuffer.cpp\n+++ b/src/IO/HadoopSnappyReadBuffer.cpp\n@@ -166,8 +166,7 @@ HadoopSnappyDecoder::Status HadoopSnappyDecoder::readBlock(size_t * avail_in, co\n }\n \n HadoopSnappyReadBuffer::HadoopSnappyReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char * existing_memory, size_t alignment)\n-    : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n-    , in(std::move(in_))\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n     , decoder(std::make_unique<HadoopSnappyDecoder>())\n     , in_available(0)\n     , in_data(nullptr)\ndiff --git a/src/IO/HadoopSnappyReadBuffer.h b/src/IO/HadoopSnappyReadBuffer.h\nindex b1b67399e56d..4536039505a4 100644\n--- a/src/IO/HadoopSnappyReadBuffer.h\n+++ b/src/IO/HadoopSnappyReadBuffer.h\n@@ -6,7 +6,7 @@\n \n #include <memory>\n #include <IO/ReadBuffer.h>\n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n \n namespace DB\n {\n@@ -67,7 +67,7 @@ class HadoopSnappyDecoder\n };\n \n /// HadoopSnappyReadBuffer implements read buffer for data compressed with hadoop-snappy format.\n-class HadoopSnappyReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class HadoopSnappyReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     using Status = HadoopSnappyDecoder::Status;\n@@ -99,7 +99,6 @@ class HadoopSnappyReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n     std::unique_ptr<HadoopSnappyDecoder> decoder;\n \n     size_t in_available;\ndiff --git a/src/IO/LZMAInflatingReadBuffer.cpp b/src/IO/LZMAInflatingReadBuffer.cpp\nindex 19c0da5a808a..6d40dafd517a 100644\n--- a/src/IO/LZMAInflatingReadBuffer.cpp\n+++ b/src/IO/LZMAInflatingReadBuffer.cpp\n@@ -8,7 +8,7 @@ namespace ErrorCodes\n }\n \n LZMAInflatingReadBuffer::LZMAInflatingReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char * existing_memory, size_t alignment)\n-    : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment), in(std::move(in_)), eof_flag(false)\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment), eof_flag(false)\n {\n     lstr = LZMA_STREAM_INIT;\n     lstr.allocator = nullptr;\ndiff --git a/src/IO/LZMAInflatingReadBuffer.h b/src/IO/LZMAInflatingReadBuffer.h\nindex 920345ee09c5..5fd29d6f7d31 100644\n--- a/src/IO/LZMAInflatingReadBuffer.h\n+++ b/src/IO/LZMAInflatingReadBuffer.h\n@@ -1,6 +1,6 @@\n #pragma once\n \n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n #include <IO/ReadBuffer.h>\n \n #include <lzma.h>\n@@ -8,7 +8,7 @@\n namespace DB\n {\n \n-class LZMAInflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class LZMAInflatingReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     explicit LZMAInflatingReadBuffer(\n@@ -22,9 +22,7 @@ class LZMAInflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n     lzma_stream lstr;\n-\n     bool eof_flag;\n };\n \ndiff --git a/src/IO/Lz4InflatingReadBuffer.cpp b/src/IO/Lz4InflatingReadBuffer.cpp\nindex 0cdde54497c9..049f3a4d15a6 100644\n--- a/src/IO/Lz4InflatingReadBuffer.cpp\n+++ b/src/IO/Lz4InflatingReadBuffer.cpp\n@@ -8,8 +8,7 @@ namespace ErrorCodes\n }\n \n Lz4InflatingReadBuffer::Lz4InflatingReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char * existing_memory, size_t alignment)\n-    : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n-    , in(std::move(in_))\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n     , in_data(nullptr)\n     , out_data(nullptr)\n     , in_available(0)\ndiff --git a/src/IO/Lz4InflatingReadBuffer.h b/src/IO/Lz4InflatingReadBuffer.h\nindex 9921939d4535..46bdc406709c 100644\n--- a/src/IO/Lz4InflatingReadBuffer.h\n+++ b/src/IO/Lz4InflatingReadBuffer.h\n@@ -1,6 +1,6 @@\n #pragma once\n \n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n #include <IO/CompressionMethod.h>\n #include <IO/ReadBuffer.h>\n \n@@ -11,7 +11,7 @@\n namespace DB\n {\n \n-class Lz4InflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class Lz4InflatingReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     explicit Lz4InflatingReadBuffer(\n@@ -25,8 +25,6 @@ class Lz4InflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n-\n     LZ4F_dctx* dctx;\n \n     void * in_data;\ndiff --git a/src/IO/ParallelReadBuffer.h b/src/IO/ParallelReadBuffer.h\nindex 50bec6663ced..7b706b5111e3 100644\n--- a/src/IO/ParallelReadBuffer.h\n+++ b/src/IO/ParallelReadBuffer.h\n@@ -85,6 +85,8 @@ class ParallelReadBuffer : public SeekableReadBufferWithSize\n     std::optional<size_t> getTotalSize() override;\n     off_t getPosition() override;\n \n+    const ReadBufferFactory & getReadBufferFactory() const { return *reader_factory; }\n+\n private:\n     /// Reader in progress with a list of read segments\n     struct ReadWorker\ndiff --git a/src/IO/ReadBufferFromAzureBlobStorage.h b/src/IO/ReadBufferFromAzureBlobStorage.h\nindex d743e725bda4..80078afd6d0d 100644\n--- a/src/IO/ReadBufferFromAzureBlobStorage.h\n+++ b/src/IO/ReadBufferFromAzureBlobStorage.h\n@@ -7,12 +7,13 @@\n #include <IO/HTTPCommon.h>\n #include <IO/SeekableReadBuffer.h>\n #include <IO/ReadSettings.h>\n+#include <IO/WithFileName.h>\n #include <azure/storage/blobs.hpp>\n \n namespace DB\n {\n \n-class ReadBufferFromAzureBlobStorage : public SeekableReadBuffer\n+class ReadBufferFromAzureBlobStorage : public SeekableReadBuffer, public WithFileName\n {\n public:\n \n@@ -33,6 +34,8 @@ class ReadBufferFromAzureBlobStorage : public SeekableReadBuffer\n \n     size_t getFileOffsetOfBufferEnd() const override { return offset; }\n \n+    String getFileName() const override { return path; }\n+\n private:\n \n     void initialize();\ndiff --git a/src/IO/ReadBufferFromFileBase.h b/src/IO/ReadBufferFromFileBase.h\nindex a051283b2bb1..b076510a0d53 100644\n--- a/src/IO/ReadBufferFromFileBase.h\n+++ b/src/IO/ReadBufferFromFileBase.h\n@@ -2,6 +2,7 @@\n \n #include <IO/BufferWithOwnMemory.h>\n #include <IO/SeekableReadBuffer.h>\n+#include <IO/WithFileName.h>\n #include <base/time.h>\n \n #include <functional>\n@@ -19,7 +20,7 @@\n \n namespace DB\n {\n-class ReadBufferFromFileBase : public BufferWithOwnMemory<SeekableReadBuffer>\n+class ReadBufferFromFileBase : public BufferWithOwnMemory<SeekableReadBuffer>, public WithFileName\n {\n public:\n     ReadBufferFromFileBase();\n@@ -29,7 +30,6 @@ class ReadBufferFromFileBase : public BufferWithOwnMemory<SeekableReadBuffer>\n         size_t alignment,\n         std::optional<size_t> file_size_ = std::nullopt);\n     ~ReadBufferFromFileBase() override;\n-    virtual std::string getFileName() const = 0;\n \n     /// It is possible to get information about the time of each reading.\n     struct ProfileInfo\ndiff --git a/src/IO/ReadBufferFromS3.h b/src/IO/ReadBufferFromS3.h\nindex 5282d9ad4823..2a94d286da6f 100644\n--- a/src/IO/ReadBufferFromS3.h\n+++ b/src/IO/ReadBufferFromS3.h\n@@ -12,6 +12,7 @@\n #include <IO/ReadBuffer.h>\n #include <IO/ReadSettings.h>\n #include <IO/SeekableReadBuffer.h>\n+#include <IO/WithFileName.h>\n \n #include <aws/s3/model/GetObjectResult.h>\n \n@@ -25,7 +26,7 @@ namespace DB\n /**\n  * Perform S3 HTTP GET request and provide response to read.\n  */\n-class ReadBufferFromS3 : public SeekableReadBufferWithSize\n+class ReadBufferFromS3 : public SeekableReadBufferWithSize, public WithFileName\n {\n private:\n     std::shared_ptr<Aws::S3::S3Client> client_ptr;\n@@ -70,6 +71,8 @@ class ReadBufferFromS3 : public SeekableReadBufferWithSize\n \n     size_t getFileOffsetOfBufferEnd() const override { return offset; }\n \n+    String getFileName() const override { return bucket + \"/\" + key; }\n+\n private:\n     std::unique_ptr<ReadBuffer> initialize();\n \n@@ -83,7 +86,7 @@ class ReadBufferFromS3 : public SeekableReadBufferWithSize\n };\n \n /// Creates separate ReadBufferFromS3 for sequence of ranges of particular object\n-class ReadBufferS3Factory : public ParallelReadBuffer::ReadBufferFactory\n+class ReadBufferS3Factory : public ParallelReadBuffer::ReadBufferFactory, public WithFileName\n {\n public:\n     explicit ReadBufferS3Factory(\n@@ -113,6 +116,8 @@ class ReadBufferS3Factory : public ParallelReadBuffer::ReadBufferFactory\n \n     std::optional<size_t> getTotalSize() override;\n \n+    String getFileName() const override { return bucket + \"/\" + key; }\n+\n private:\n     std::shared_ptr<Aws::S3::S3Client> client_ptr;\n     const String bucket;\ndiff --git a/src/IO/ReadWriteBufferFromHTTP.h b/src/IO/ReadWriteBufferFromHTTP.h\nindex f0c107591422..02a214e87d7e 100644\n--- a/src/IO/ReadWriteBufferFromHTTP.h\n+++ b/src/IO/ReadWriteBufferFromHTTP.h\n@@ -9,6 +9,7 @@\n #include <IO/ReadBufferFromIStream.h>\n #include <IO/ReadHelpers.h>\n #include <IO/ReadSettings.h>\n+#include <IO/WithFileName.h>\n #include <base/logger_useful.h>\n #include <base/sleep.h>\n #include <base/types.h>\n@@ -85,7 +86,7 @@ class UpdatableSessionBase\n namespace detail\n {\n     template <typename UpdatableSessionPtr>\n-    class ReadWriteBufferFromHTTPBase : public SeekableReadBufferWithSize\n+    class ReadWriteBufferFromHTTPBase : public SeekableReadBufferWithSize, public WithFileName\n     {\n     public:\n         using HTTPHeaderEntry = std::tuple<std::string, std::string>;\n@@ -223,6 +224,8 @@ namespace detail\n             return read_range.end;\n         }\n \n+        String getFileName() const override { return uri.toString(); }\n+\n         enum class InitializeError\n         {\n             /// If error is not retriable, `exception` variable must be set.\n@@ -674,7 +677,7 @@ class ReadWriteBufferFromHTTP : public detail::ReadWriteBufferFromHTTPBase<std::\n     }\n };\n \n-class RangedReadWriteBufferFromHTTPFactory : public ParallelReadBuffer::ReadBufferFactory\n+class RangedReadWriteBufferFromHTTPFactory : public ParallelReadBuffer::ReadBufferFactory, public WithFileName\n {\n     using OutStreamCallback = ReadWriteBufferFromHTTP::OutStreamCallback;\n \n@@ -748,6 +751,8 @@ class RangedReadWriteBufferFromHTTPFactory : public ParallelReadBuffer::ReadBuff\n \n     std::optional<size_t> getTotalSize() override { return total_object_size; }\n \n+    String getFileName() const override { return uri.toString(); }\n+\n private:\n     RangeGenerator range_generator;\n     size_t total_object_size;\ndiff --git a/src/IO/WithFileName.cpp b/src/IO/WithFileName.cpp\nnew file mode 100644\nindex 000000000000..f470d9f7f971\n--- /dev/null\n+++ b/src/IO/WithFileName.cpp\n@@ -0,0 +1,26 @@\n+#include <IO/WithFileName.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n+#include <IO/ParallelReadBuffer.h>\n+\n+namespace DB\n+{\n+\n+template <typename T>\n+static String getFileName(const T & entry)\n+{\n+    if (const auto * with_file_name = dynamic_cast<const WithFileName *>(&entry))\n+        return with_file_name->getFileName();\n+    return \"\";\n+}\n+\n+String getFileNameFromReadBuffer(const ReadBuffer & in)\n+{\n+    if (const auto * compressed = dynamic_cast<const CompressedReadBufferWrapper *>(&in))\n+        return getFileName(compressed->getWrappedReadBuffer());\n+    else if (const auto * parallel = dynamic_cast<const ParallelReadBuffer *>(&in))\n+        return getFileName(parallel->getReadBufferFactory());\n+    else\n+        return getFileName(in);\n+}\n+\n+}\ndiff --git a/src/IO/WithFileName.h b/src/IO/WithFileName.h\nnew file mode 100644\nindex 000000000000..d770634e7388\n--- /dev/null\n+++ b/src/IO/WithFileName.h\n@@ -0,0 +1,18 @@\n+#pragma once\n+#include <base/types.h>\n+\n+namespace DB\n+{\n+\n+class ReadBuffer;\n+\n+class WithFileName\n+{\n+public:\n+    virtual String getFileName() const = 0;\n+    virtual ~WithFileName() = default;\n+};\n+\n+String getFileNameFromReadBuffer(const ReadBuffer & in);\n+\n+}\ndiff --git a/src/IO/ZlibInflatingReadBuffer.cpp b/src/IO/ZlibInflatingReadBuffer.cpp\nindex 28426e920eff..4cb56bef6b1f 100644\n--- a/src/IO/ZlibInflatingReadBuffer.cpp\n+++ b/src/IO/ZlibInflatingReadBuffer.cpp\n@@ -14,8 +14,7 @@ ZlibInflatingReadBuffer::ZlibInflatingReadBuffer(\n         size_t buf_size,\n         char * existing_memory,\n         size_t alignment)\n-    : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment)\n-    , in(std::move(in_))\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n     , eof_flag(false)\n {\n     zstr.zalloc = nullptr;\ndiff --git a/src/IO/ZlibInflatingReadBuffer.h b/src/IO/ZlibInflatingReadBuffer.h\nindex 905ab0cd3fc1..b534b7cb5c42 100644\n--- a/src/IO/ZlibInflatingReadBuffer.h\n+++ b/src/IO/ZlibInflatingReadBuffer.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n #include <IO/ReadBuffer.h>\n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n #include <IO/CompressionMethod.h>\n \n #include <zlib.h>\n@@ -16,7 +16,7 @@ namespace ErrorCodes\n \n /// Reads compressed data from ReadBuffer in_ and performs decompression using zlib library.\n /// This buffer is able to seamlessly decompress multiple concatenated zlib streams.\n-class ZlibInflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class ZlibInflatingReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     ZlibInflatingReadBuffer(\n@@ -31,7 +31,6 @@ class ZlibInflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n     z_stream zstr;\n     bool eof_flag;\n };\ndiff --git a/src/IO/ZstdInflatingReadBuffer.cpp b/src/IO/ZstdInflatingReadBuffer.cpp\nindex 6f244dc5a750..712ea6960ef0 100644\n--- a/src/IO/ZstdInflatingReadBuffer.cpp\n+++ b/src/IO/ZstdInflatingReadBuffer.cpp\n@@ -9,7 +9,7 @@ namespace ErrorCodes\n }\n \n ZstdInflatingReadBuffer::ZstdInflatingReadBuffer(std::unique_ptr<ReadBuffer> in_, size_t buf_size, char * existing_memory, size_t alignment)\n-    : BufferWithOwnMemory<ReadBuffer>(buf_size, existing_memory, alignment), in(std::move(in_))\n+    : CompressedReadBufferWrapper(std::move(in_), buf_size, existing_memory, alignment)\n {\n     dctx = ZSTD_createDCtx();\n     input = {nullptr, 0, 0};\ndiff --git a/src/IO/ZstdInflatingReadBuffer.h b/src/IO/ZstdInflatingReadBuffer.h\nindex 7f246b021277..a0c20b79d807 100644\n--- a/src/IO/ZstdInflatingReadBuffer.h\n+++ b/src/IO/ZstdInflatingReadBuffer.h\n@@ -1,6 +1,6 @@\n #pragma once\n \n-#include <IO/BufferWithOwnMemory.h>\n+#include <IO/CompressedReadBufferWrapper.h>\n #include <IO/CompressionMethod.h>\n #include <IO/ReadBuffer.h>\n \n@@ -13,7 +13,7 @@ namespace ErrorCodes\n {\n }\n \n-class ZstdInflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n+class ZstdInflatingReadBuffer : public CompressedReadBufferWrapper\n {\n public:\n     explicit ZstdInflatingReadBuffer(\n@@ -27,7 +27,6 @@ class ZstdInflatingReadBuffer : public BufferWithOwnMemory<ReadBuffer>\n private:\n     bool nextImpl() override;\n \n-    std::unique_ptr<ReadBuffer> in;\n     ZSTD_DCtx * dctx;\n     ZSTD_inBuffer input;\n     ZSTD_outBuffer output;\ndiff --git a/src/Processors/Formats/IInputFormat.h b/src/Processors/Formats/IInputFormat.h\nindex d060ce4155e0..78cfd413abc3 100644\n--- a/src/Processors/Formats/IInputFormat.h\n+++ b/src/Processors/Formats/IInputFormat.h\n@@ -51,6 +51,7 @@ class IInputFormat : public ISource\n     virtual void resetParser();\n \n     virtual void setReadBuffer(ReadBuffer & in_);\n+    const ReadBuffer & getReadBuffer() const { return *in; }\n \n     virtual const BlockMissingValues & getMissingValues() const\n     {\ndiff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp\nindex 645100dad19f..040912b4c3ce 100644\n--- a/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/src/Processors/Formats/IRowInputFormat.cpp\n@@ -1,6 +1,7 @@\n #include <Processors/Formats/IRowInputFormat.h>\n #include <DataTypes/ObjectUtils.h>\n #include <IO/WriteHelpers.h>    // toString\n+#include <IO/WithFileName.h>\n #include <base/logger_useful.h>\n \n \n@@ -161,6 +162,7 @@ Chunk IRowInputFormat::generate()\n             /// Error while trying to obtain verbose diagnostic. Ok to ignore.\n         }\n \n+        e.setFileName(getFileNameFromReadBuffer(getReadBuffer()));\n         e.setLineNumber(total_rows);\n         e.addMessage(verbose_diagnostic);\n         throw;\n@@ -184,7 +186,12 @@ Chunk IRowInputFormat::generate()\n             /// Error while trying to obtain verbose diagnostic. Ok to ignore.\n         }\n \n-        e.addMessage(\"(at row \" + toString(total_rows) + \")\\n\" + verbose_diagnostic);\n+        auto file_name = getFileNameFromReadBuffer(getReadBuffer());\n+        if (!file_name.empty())\n+            e.addMessage(fmt::format(\"(in file/uri {})\", file_name));\n+\n+        e.addMessage(fmt::format(\"(at row {})\\n\", total_rows));\n+        e.addMessage(verbose_diagnostic);\n         throw;\n     }\n \ndiff --git a/src/Processors/Formats/Impl/ParallelParsingInputFormat.cpp b/src/Processors/Formats/Impl/ParallelParsingInputFormat.cpp\nindex bfdb9de7d262..27192829dde9 100644\n--- a/src/Processors/Formats/Impl/ParallelParsingInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ParallelParsingInputFormat.cpp\n@@ -1,5 +1,6 @@\n #include <Processors/Formats/Impl/ParallelParsingInputFormat.h>\n #include <IO/ReadHelpers.h>\n+#include <IO/WithFileName.h>\n #include <Common/CurrentThread.h>\n #include <Common/setThreadName.h>\n \n@@ -125,11 +126,19 @@ void ParallelParsingInputFormat::onBackgroundException(size_t offset)\n     {\n         background_exception = std::current_exception();\n         if (ParsingException * e = exception_cast<ParsingException *>(background_exception))\n+        {\n             if (e->getLineNumber() != -1)\n                 e->setLineNumber(e->getLineNumber() + offset);\n+\n+            auto file_name = getFileNameFromReadBuffer(getReadBuffer());\n+            if (!file_name.empty())\n+                e->setFileName(file_name);\n+        }\n     }\n+\n     if (is_server)\n         tryLogCurrentException(__PRETTY_FUNCTION__);\n+\n     parsing_finished = true;\n     first_parser_finished.set();\n     reader_condvar.notify_all();\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex 267eb978683a..b6c4b068d328 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -202,7 +202,7 @@ void TCPHandler::runImpl()\n         /** An exception during the execution of request (it must be sent over the network to the client).\n          *  The client will be able to accept it, if it did not happen while sending another packet and the client has not disconnected yet.\n          */\n-        std::optional<DB::Exception> exception;\n+        std::unique_ptr<DB::Exception> exception;\n         bool network_error = false;\n \n         try\n@@ -396,7 +396,7 @@ void TCPHandler::runImpl()\n         catch (const Exception & e)\n         {\n             state.io.onException();\n-            exception.emplace(e);\n+            exception.reset(e.clone());\n \n             if (e.code() == ErrorCodes::UNKNOWN_PACKET_FROM_CLIENT)\n                 throw;\n@@ -420,12 +420,12 @@ void TCPHandler::runImpl()\n              *  We will try to send exception to the client in any case - see below.\n              */\n             state.io.onException();\n-            exception.emplace(Exception::CreateFromPocoTag{}, e);\n+            exception = std::make_unique<DB::Exception>(Exception::CreateFromPocoTag{}, e);\n         }\n         catch (const Poco::Exception & e)\n         {\n             state.io.onException();\n-            exception.emplace(Exception::CreateFromPocoTag{}, e);\n+            exception = std::make_unique<DB::Exception>(Exception::CreateFromPocoTag{}, e);\n         }\n // Server should die on std logic errors in debug, like with assert()\n // or ErrorCodes::LOGICAL_ERROR. This helps catch these errors in\n@@ -434,7 +434,7 @@ void TCPHandler::runImpl()\n         catch (const std::logic_error & e)\n         {\n             state.io.onException();\n-            exception.emplace(Exception::CreateFromSTDTag{}, e);\n+            exception = std::make_unique<DB::Exception>(Exception::CreateFromSTDTag{}, e);\n             sendException(*exception, send_exception_with_stack_trace);\n             std::abort();\n         }\n@@ -442,12 +442,12 @@ void TCPHandler::runImpl()\n         catch (const std::exception & e)\n         {\n             state.io.onException();\n-            exception.emplace(Exception::CreateFromSTDTag{}, e);\n+            exception = std::make_unique<DB::Exception>(Exception::CreateFromSTDTag{}, e);\n         }\n         catch (...)\n         {\n             state.io.onException();\n-            exception.emplace(\"Unknown exception\", ErrorCodes::UNKNOWN_EXCEPTION);\n+            exception = std::make_unique<DB::Exception>(\"Unknown exception\", ErrorCodes::UNKNOWN_EXCEPTION);\n         }\n \n         try\ndiff --git a/src/Storages/HDFS/ReadBufferFromHDFS.cpp b/src/Storages/HDFS/ReadBufferFromHDFS.cpp\nindex 0ca13eac2646..42961061de4b 100644\n--- a/src/Storages/HDFS/ReadBufferFromHDFS.cpp\n+++ b/src/Storages/HDFS/ReadBufferFromHDFS.cpp\n@@ -182,6 +182,11 @@ size_t ReadBufferFromHDFS::getFileOffsetOfBufferEnd() const\n     return impl->getPosition();\n }\n \n+String ReadBufferFromHDFS::getFileName() const\n+{\n+    return impl->hdfs_file_path;\n+}\n+\n }\n \n #endif\ndiff --git a/src/Storages/HDFS/ReadBufferFromHDFS.h b/src/Storages/HDFS/ReadBufferFromHDFS.h\nindex e8cdcb273600..0587f4d1d3d8 100644\n--- a/src/Storages/HDFS/ReadBufferFromHDFS.h\n+++ b/src/Storages/HDFS/ReadBufferFromHDFS.h\n@@ -11,6 +11,7 @@\n #include <base/types.h>\n #include <Interpreters/Context.h>\n #include <IO/SeekableReadBuffer.h>\n+#include <IO/WithFileName.h>\n \n \n namespace DB\n@@ -19,7 +20,7 @@ namespace DB\n /** Accepts HDFS path to file and opens it.\n  * Closes file by himself (thus \"owns\" a file descriptor).\n  */\n-class ReadBufferFromHDFS : public SeekableReadBufferWithSize\n+class ReadBufferFromHDFS : public SeekableReadBufferWithSize, public WithFileName\n {\n struct ReadBufferFromHDFSImpl;\n \n@@ -41,6 +42,8 @@ struct ReadBufferFromHDFSImpl;\n \n     size_t getFileOffsetOfBufferEnd() const override;\n \n+    String getFileName() const override;\n+\n private:\n     std::unique_ptr<ReadBufferFromHDFSImpl> impl;\n };\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 761b4ecdeb17..71006d236f84 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -544,7 +544,6 @@ class StorageFileSource : public SourceWithProgress\n             Chunk chunk;\n             if (reader->pull(chunk))\n             {\n-                //Columns columns = res.getColumns();\n                 UInt64 num_rows = chunk.getNumRows();\n \n                 /// Enrich with virtual columns.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02270_errors_in_files.reference b/tests/queries/0_stateless/02270_errors_in_files.reference\nnew file mode 100644\nindex 000000000000..eabca907972c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02270_errors_in_files.reference\n@@ -0,0 +1,6 @@\n+test_02270_2.csv\n+test_02270_2.csv\n+test_02270_2.csv\n+test_02270_2.csv\n+test_02270_2.csv.gz\n+test_02270_2.csv.gz\ndiff --git a/tests/queries/0_stateless/02270_errors_in_files.sh b/tests/queries/0_stateless/02270_errors_in_files.sh\nnew file mode 100755\nindex 000000000000..517547c6ef8a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02270_errors_in_files.sh\n@@ -0,0 +1,35 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+[ -e \"${CLICKHOUSE_TMP}\"/test_02270_1.csv ] && rm \"${CLICKHOUSE_TMP}\"/test_02270_1.csv\n+[ -e \"${CLICKHOUSE_TMP}\"/test_02270_2.csv ] && rm \"${CLICKHOUSE_TMP}\"/test_02270_2.csv\n+\n+echo \"Hello,World\" > \"${CLICKHOUSE_TMP}\"/test_02270_1.csv\n+echo \"Error\" > \"${CLICKHOUSE_TMP}\"/test_02270_2.csv\n+\n+${CLICKHOUSE_LOCAL} --query \"SELECT * FROM file('${CLICKHOUSE_TMP}/test_02270*.csv', CSV, 'a String, b String')\" 2>&1 | grep -o \"test_02270_2.csv\"\n+${CLICKHOUSE_LOCAL} --query \"SELECT * FROM file('${CLICKHOUSE_TMP}/test_02270*.csv', CSV, 'a String, b String')\" --input_format_parallel_parsing 0 2>&1 | grep -o \"test_02270_2.csv\"\n+\n+user_files_path=$($CLICKHOUSE_CLIENT --query \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep -E '^Code: 107.*FILE_DOESNT_EXIST' | head -1 | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE FUNCTION file('test_02270_1.csv') SELECT 'Hello', 'World'\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE FUNCTION file('test_02270_2.csv') SELECT 'Error'\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM file('test_02270*.csv', 'CSV', 'a String, b String')\" 2>&1 | grep -o -m1 \"test_02270_2.csv\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM file('test_02270*.csv', 'CSV', 'a String, b String')\" --input_format_parallel_parsing 0 2>&1 | grep -o -m1 \"test_02270_2.csv\"\n+\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE FUNCTION file('test_02270_1.csv.gz') SELECT 'Hello', 'World'\"\n+${CLICKHOUSE_CLIENT} --query \"INSERT INTO TABLE FUNCTION file('test_02270_2.csv.gz') SELECT 'Error'\"\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM file('test_02270*.csv.gz', 'CSV', 'a String, b String')\" 2>&1 | grep -o -m1 \"test_02270_2.csv.gz\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM file('test_02270*.csv.gz', 'CSV', 'a String, b String')\" --input_format_parallel_parsing 0 2>&1 | grep -o -m1 \"test_02270_2.csv.gz\"\n+\n+rm \"${CLICKHOUSE_TMP}\"/test_02270_1.csv\n+rm \"${CLICKHOUSE_TMP}\"/test_02270_2.csv\n+rm \"${user_files_path}\"/test_02270_1.csv\n+rm \"${user_files_path}\"/test_02270_2.csv\n+rm \"${user_files_path}\"/test_02270_1.csv.gz\n+rm \"${user_files_path}\"/test_02270_2.csv.gz\ndiff --git a/tests/queries/0_stateless/02270_errors_in_files_s3.reference b/tests/queries/0_stateless/02270_errors_in_files_s3.reference\nnew file mode 100644\nindex 000000000000..bf106b8562b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02270_errors_in_files_s3.reference\n@@ -0,0 +1,2 @@\n+http://localhost:11111/test/tsv_with_header.tsv\n+test/tsv_with_header.tsv\ndiff --git a/tests/queries/0_stateless/02270_errors_in_files_s3.sh b/tests/queries/0_stateless/02270_errors_in_files_s3.sh\nnew file mode 100755\nindex 000000000000..8d8c6ba56efb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02270_errors_in_files_s3.sh\n@@ -0,0 +1,9 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM url('http://localhost:11111/test/{a,tsv_with_header}.tsv', 'TSV', 'c1 UInt64, c2 UInt64, c3 UInt64')\" 2>&1 | grep -o -m1 \"http://localhost:11111/test/tsv_with_header.tsv\"\n+${CLICKHOUSE_CLIENT} --query \"SELECT * FROM s3('http://localhost:11111/test/{a,tsv_with_header}.tsv', 'TSV', 'c1 UInt64, c2 UInt64, c3 UInt64')\" 2>&1 | grep -o -m1 \"test/tsv_with_header.tsv\"\n",
  "problem_statement": "`file` table function should print the name of erroneous file in case of error\n**Describe the issue**\r\n\r\n```\r\n$ echo \"Hello,World\" > test1.csv\r\n$ echo \"Error\" > test2.csv\r\n\r\n$ clickhouse-local --query \"SELECT * FROM file('test*.csv', CSV, 'a String, b String')\"\r\n\r\nHello   World\r\nCode: 27. DB::Exception: Cannot parse input: expected ',' before: '\\n': \r\nRow 1:\r\nColumn 0,   name: a, type: String, parsed text: \"Error\"\r\nERROR: Line feed found where delimiter (,) is expected. It's like your file has less columns than expected.\r\nAnd if your file has the right number of columns, maybe it has unescaped quotes in values.\r\n\r\n: While executing ParallelParsingBlockInputFormat: While executing File. (CANNOT_PARSE_INPUT_ASSERTION_FAILED)\r\n```\r\n\r\nThere is no information that the error is related to `test2.csv`.\n",
  "hints_text": "@CurtizJ We can add `getReadBuffer` method for formats, and try to extract the filename in case of error.\n@CurtizJ I need this so much:\r\n\r\n```\r\nplay-eu :) INSERT INTO repos_json SELECT * FROM file('repos/*.json', JSONAsObject)\r\n\r\nINSERT INTO repos_json SELECT *\r\nFROM file('repos/*.json', JSONAsObject)\r\n\r\nQuery id: d811cebf-15e7-4cbf-9ffe-d53f98042489\r\n\r\n\u2199 Progress: 1.11 million rows, 4.84 GB (14.83 thousand rows/s., 64.98 MB/s.)                                                                                                      (12.5 CPU, 496.11 MB RAM)\r\n0 rows in set. Elapsed: 74.593 sec. Processed 1.11 million rows, 4.84 GB (14.82 thousand rows/s., 64.90 MB/s.)\r\n\r\nReceived exception from server (version 22.4.1):\r\nCode: 117. DB::Exception: Received from localhost:9000. DB::Exception: JSON should start from opening curly bracket: While executing ParallelParsingBlockInputFormat: While executing File. (INCORRECT_DATA)\r\n```\r\n\r\n(I have 1.5 million files)",
  "created_at": "2022-04-16T00:11:45Z",
  "modified_files": [
    "src/Client/ClientBase.cpp",
    "src/Client/ClientBase.h",
    "src/Client/LocalConnection.cpp",
    "src/Client/LocalConnection.h",
    "src/Common/Exception.cpp",
    "src/Common/Exception.h",
    "src/IO/BrotliReadBuffer.cpp",
    "src/IO/BrotliReadBuffer.h",
    "src/IO/Bzip2ReadBuffer.cpp",
    "src/IO/Bzip2ReadBuffer.h",
    "b/src/IO/CompressedReadBufferWrapper.h",
    "src/IO/CompressionMethod.cpp",
    "src/IO/HadoopSnappyReadBuffer.cpp",
    "src/IO/HadoopSnappyReadBuffer.h",
    "src/IO/LZMAInflatingReadBuffer.cpp",
    "src/IO/LZMAInflatingReadBuffer.h",
    "src/IO/Lz4InflatingReadBuffer.cpp",
    "src/IO/Lz4InflatingReadBuffer.h",
    "src/IO/ParallelReadBuffer.h",
    "src/IO/ReadBufferFromAzureBlobStorage.h",
    "src/IO/ReadBufferFromFileBase.h",
    "src/IO/ReadBufferFromS3.h",
    "src/IO/ReadWriteBufferFromHTTP.h",
    "b/src/IO/WithFileName.cpp",
    "b/src/IO/WithFileName.h",
    "src/IO/ZlibInflatingReadBuffer.cpp",
    "src/IO/ZlibInflatingReadBuffer.h",
    "src/IO/ZstdInflatingReadBuffer.cpp",
    "src/IO/ZstdInflatingReadBuffer.h",
    "src/Processors/Formats/IInputFormat.h",
    "src/Processors/Formats/IRowInputFormat.cpp",
    "src/Processors/Formats/Impl/ParallelParsingInputFormat.cpp",
    "src/Server/TCPHandler.cpp",
    "src/Storages/HDFS/ReadBufferFromHDFS.cpp",
    "src/Storages/HDFS/ReadBufferFromHDFS.h",
    "src/Storages/StorageFile.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02270_errors_in_files.reference",
    "b/tests/queries/0_stateless/02270_errors_in_files.sh",
    "b/tests/queries/0_stateless/02270_errors_in_files_s3.reference",
    "b/tests/queries/0_stateless/02270_errors_in_files_s3.sh"
  ]
}