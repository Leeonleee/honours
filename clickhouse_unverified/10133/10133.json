{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10133,
  "instance_id": "ClickHouse__ClickHouse-10133",
  "issue_numbers": [
    "7688"
  ],
  "base_commit": "fa8e4e4735b932f08b6beffcb2d069b72de34401",
  "patch": "diff --git a/src/Interpreters/DictionaryReader.cpp b/src/Interpreters/DictionaryReader.cpp\nnew file mode 100644\nindex 000000000000..301fe9d57c67\n--- /dev/null\n+++ b/src/Interpreters/DictionaryReader.cpp\n@@ -0,0 +1,167 @@\n+#include <Interpreters/DictionaryReader.h>\n+#include <Interpreters/Context.h>\n+#include <Common/typeid_cast.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnConst.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_COLUMNS_DOESNT_MATCH;\n+    extern const int TYPE_MISMATCH;\n+}\n+\n+\n+DictionaryReader::FunctionWrapper::FunctionWrapper(FunctionOverloadResolverPtr resolver, const ColumnsWithTypeAndName & arguments,\n+                                                   Block & block, const ColumnNumbers & arg_positions_, const String & column_name,\n+                                                   TypeIndex expected_type)\n+    : arg_positions(arg_positions_)\n+    , result_pos(block.columns())\n+{\n+    FunctionBasePtr prepared_function = resolver->build(arguments);\n+\n+    ColumnWithTypeAndName result;\n+    result.name = \"get_\" + column_name;\n+    result.type = prepared_function->getReturnType();\n+    if (result.type->getTypeId() != expected_type)\n+        throw Exception(\"Type mismatch in dictionary reader for: \" + column_name, ErrorCodes::TYPE_MISMATCH);\n+    block.insert(result);\n+\n+    function = prepared_function->prepare(block, arg_positions, result_pos);\n+}\n+\n+static constexpr const size_t key_size = 1;\n+\n+DictionaryReader::DictionaryReader(const String & dictionary_name, const Names & src_column_names, const NamesAndTypesList & result_columns,\n+                                   const Context & context)\n+    : result_header(makeResultBlock(result_columns))\n+    , key_position(key_size + result_header.columns())\n+{\n+    if (src_column_names.size() != result_columns.size())\n+        throw Exception(\"Columns number mismatch in dictionary reader\", ErrorCodes::NUMBER_OF_COLUMNS_DOESNT_MATCH);\n+\n+    ColumnWithTypeAndName dict_name;\n+    ColumnWithTypeAndName key;\n+    ColumnWithTypeAndName column_name;\n+\n+    {\n+        dict_name.name = \"dict\";\n+        dict_name.type = std::make_shared<DataTypeString>();\n+        dict_name.column = dict_name.type->createColumnConst(1, dictionary_name);\n+\n+        /// TODO: composite key (key_size > 1)\n+        key.name = \"key\";\n+        key.type = std::make_shared<DataTypeUInt64>();\n+\n+        column_name.name = \"column\";\n+        column_name.type = std::make_shared<DataTypeString>();\n+    }\n+\n+    /// dictHas('dict_name', id)\n+    ColumnsWithTypeAndName arguments_has;\n+    arguments_has.push_back(dict_name);\n+    arguments_has.push_back(key);\n+\n+    /// dictGet('dict_name', 'attr_name', id)\n+    ColumnsWithTypeAndName arguments_get;\n+    arguments_get.push_back(dict_name);\n+    arguments_get.push_back(column_name);\n+    arguments_get.push_back(key);\n+\n+    sample_block.insert(dict_name);\n+\n+    for (auto & columns_name : src_column_names)\n+    {\n+        ColumnWithTypeAndName name;\n+        name.name = \"col_\" + columns_name;\n+        name.type = std::make_shared<DataTypeString>();\n+        name.column = name.type->createColumnConst(1, columns_name);\n+\n+        sample_block.insert(name);\n+    }\n+\n+    sample_block.insert(key);\n+\n+    ColumnNumbers positions_has{0, key_position};\n+    function_has = std::make_unique<FunctionWrapper>(FunctionFactory::instance().get(\"dictHas\", context),\n+                                                        arguments_has, sample_block, positions_has, \"has\", DataTypeUInt8().getTypeId());\n+    functions_get.reserve(result_header.columns());\n+\n+    for (size_t i = 0; i < result_header.columns(); ++i)\n+    {\n+        size_t column_name_pos = key_size + i;\n+        auto & column = result_header.getByPosition(i);\n+        arguments_get[1].column = DataTypeString().createColumnConst(1, src_column_names[i]);\n+        ColumnNumbers positions_get{0, column_name_pos, key_position};\n+        functions_get.emplace_back(\n+            FunctionWrapper(FunctionFactory::instance().get(\"dictGet\", context),\n+                            arguments_get, sample_block, positions_get, column.name, column.type->getTypeId()));\n+    }\n+}\n+\n+void DictionaryReader::readKeys(const IColumn & keys, Block & out_block, ColumnVector<UInt8>::Container & found,\n+                                std::vector<size_t> & positions) const\n+{\n+    Block working_block = sample_block;\n+    size_t has_position = key_position + 1;\n+    size_t size = keys.size();\n+\n+    /// set keys for dictHas()\n+    ColumnWithTypeAndName & key_column = working_block.getByPosition(key_position);\n+    key_column.column = keys.cloneResized(size); /// just a copy we cannot avoid\n+\n+    /// calculate and extract dictHas()\n+    function_has->execute(working_block, size);\n+    ColumnWithTypeAndName & has_column = working_block.getByPosition(has_position);\n+    auto mutable_has = (*std::move(has_column.column)).mutate();\n+    found.swap(typeid_cast<ColumnVector<UInt8> &>(*mutable_has).getData());\n+    has_column.column = nullptr;\n+\n+    /// set mapping form source keys to resulting rows in output block\n+    positions.clear();\n+    positions.resize(size, 0);\n+    size_t pos = 0;\n+    for (size_t i = 0; i < size; ++i)\n+        if (found[i])\n+            positions[i] = pos++;\n+\n+    /// set keys for dictGet(): remove not found keys\n+    key_column.column = key_column.column->filter(found, -1);\n+    size_t rows = key_column.column->size();\n+\n+    /// calculate dictGet()\n+    for (auto & func : functions_get)\n+        func.execute(working_block, rows);\n+\n+    /// make result: copy header block with correct names and move data columns\n+    out_block = result_header.cloneEmpty();\n+    size_t first_get_position = has_position + 1;\n+    for (size_t i = 0; i < out_block.columns(); ++i)\n+    {\n+        auto & src_column = working_block.getByPosition(first_get_position + i);\n+        auto & dst_column = out_block.getByPosition(i);\n+        dst_column.column = src_column.column;\n+        src_column.column = nullptr;\n+    }\n+}\n+\n+Block DictionaryReader::makeResultBlock(const NamesAndTypesList & names)\n+{\n+    Block block;\n+    for (auto & nm : names)\n+    {\n+        ColumnWithTypeAndName column{nullptr, nm.type, nm.name};\n+        if (column.type->isNullable())\n+            column.type = typeid_cast<const DataTypeNullable &>(*column.type).getNestedType();\n+        block.insert(std::move(column));\n+    }\n+    return block;\n+}\n+\n+}\ndiff --git a/src/Interpreters/DictionaryReader.h b/src/Interpreters/DictionaryReader.h\nnew file mode 100644\nindex 000000000000..92e4924ae801\n--- /dev/null\n+++ b/src/Interpreters/DictionaryReader.h\n@@ -0,0 +1,46 @@\n+#pragma once\n+\n+#include <Core/Block.h>\n+#include <Columns/ColumnVector.h>\n+#include <Functions/IFunctionAdaptors.h>\n+\n+namespace DB\n+{\n+\n+class Context;\n+\n+/// Read block of required columns from Dictionary by UInt64 key column. Rename columns if needed.\n+/// Current implementation uses dictHas() + N * dictGet() functions.\n+class DictionaryReader\n+{\n+public:\n+    struct FunctionWrapper\n+    {\n+        ExecutableFunctionPtr function;\n+        ColumnNumbers arg_positions;\n+        size_t result_pos = 0;\n+\n+        FunctionWrapper(FunctionOverloadResolverPtr resolver, const ColumnsWithTypeAndName & arguments, Block & block,\n+                        const ColumnNumbers & arg_positions_, const String & column_name, TypeIndex expected_type);\n+\n+        void execute(Block & block, size_t rows) const\n+        {\n+            function->execute(block, arg_positions, result_pos, rows, false);\n+        }\n+    };\n+\n+    DictionaryReader(const String & dictionary_name, const Names & src_column_names, const NamesAndTypesList & result_columns,\n+                     const Context & context);\n+    void readKeys(const IColumn & keys, Block & out_block, ColumnVector<UInt8>::Container & found, std::vector<size_t> & positions) const;\n+\n+private:\n+    Block result_header;\n+    Block sample_block; /// dictionary name, column names, key, dictHas() result, dictGet() results\n+    size_t key_position;\n+    std::unique_ptr<FunctionWrapper> function_has;\n+    std::vector<FunctionWrapper> functions_get;\n+\n+    static Block makeResultBlock(const NamesAndTypesList & names);\n+};\n+\n+}\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 9ec32737fdcb..e8ec2a1d8b78 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -31,17 +31,20 @@\n #include <Interpreters/JoinSwitcher.h>\n #include <Interpreters/HashJoin.h>\n #include <Interpreters/MergeJoin.h>\n+#include <Interpreters/DictionaryReader.h>\n \n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <AggregateFunctions/parseAggregateFunctionParameters.h>\n \n #include <Storages/StorageDistributed.h>\n+#include <Storages/StorageDictionary.h>\n #include <Storages/StorageJoin.h>\n \n #include <DataStreams/copyData.h>\n #include <DataStreams/IBlockInputStream.h>\n \n #include <Dictionaries/IDictionary.h>\n+#include <Dictionaries/DictionaryStructure.h>\n \n #include <Common/typeid_cast.h>\n #include <Common/StringUtils/StringUtils.h>\n@@ -502,25 +505,11 @@ bool SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain, b\n     return true;\n }\n \n-static JoinPtr tryGetStorageJoin(const ASTTablesInSelectQueryElement & join_element, std::shared_ptr<TableJoin> analyzed_join,\n-                                 const Context & context)\n+static JoinPtr tryGetStorageJoin(std::shared_ptr<TableJoin> analyzed_join)\n {\n-    const auto & table_to_join = join_element.table_expression->as<ASTTableExpression &>();\n-\n-    /// TODO This syntax does not support specifying a database name.\n-    if (table_to_join.database_and_table_name)\n-    {\n-        auto table_id = context.resolveStorageID(table_to_join.database_and_table_name);\n-        StoragePtr table = DatabaseCatalog::instance().tryGetTable(table_id);\n-\n-        if (table)\n-        {\n-            auto * storage_join = dynamic_cast<StorageJoin *>(table.get());\n-            if (storage_join)\n-                return storage_join->getJoin(analyzed_join);\n-        }\n-    }\n-\n+    if (auto * table = analyzed_join->joined_storage.get())\n+        if (auto * storage_join = dynamic_cast<StorageJoin *>(table))\n+            return storage_join->getJoin(analyzed_join);\n     return {};\n }\n \n@@ -531,10 +520,44 @@ static ExpressionActionsPtr createJoinedBlockActions(const Context & context, co\n     return ExpressionAnalyzer(expression_list, syntax_result, context).getActions(true, false);\n }\n \n-static std::shared_ptr<IJoin> makeJoin(std::shared_ptr<TableJoin> analyzed_join, const Block & sample_block)\n+static bool allowDictJoin(StoragePtr joined_storage, const Context & context, String & dict_name, String & key_name)\n+{\n+    auto * dict = dynamic_cast<const StorageDictionary *>(joined_storage.get());\n+    if (!dict)\n+        return false;\n+\n+    dict_name = dict->dictionaryName();\n+    auto dictionary = context.getExternalDictionariesLoader().getDictionary(dict_name);\n+    if (!dictionary)\n+        return false;\n+\n+    const DictionaryStructure & structure = dictionary->getStructure();\n+    if (structure.id)\n+    {\n+        key_name = structure.id->name;\n+        return true;\n+    }\n+    return false;\n+}\n+\n+static std::shared_ptr<IJoin> makeJoin(std::shared_ptr<TableJoin> analyzed_join, const Block & sample_block, const Context & context)\n {\n     bool allow_merge_join = analyzed_join->allowMergeJoin();\n \n+    /// HashJoin with Dictionary optimisation\n+    String dict_name;\n+    String key_name;\n+    if (analyzed_join->joined_storage && allowDictJoin(analyzed_join->joined_storage, context, dict_name, key_name))\n+    {\n+        Names original_names;\n+        NamesAndTypesList result_columns;\n+        if (analyzed_join->allowDictJoin(key_name, sample_block, original_names, result_columns))\n+        {\n+            analyzed_join->dictionary_reader = std::make_shared<DictionaryReader>(dict_name, original_names, result_columns, context);\n+            return std::make_shared<HashJoin>(analyzed_join, sample_block);\n+        }\n+    }\n+\n     if (analyzed_join->forceHashJoin() || (analyzed_join->preferMergeJoin() && !allow_merge_join))\n         return std::make_shared<HashJoin>(analyzed_join, sample_block);\n     else if (analyzed_join->forceMergeJoin() || (analyzed_join->preferMergeJoin() && allow_merge_join))\n@@ -550,48 +573,49 @@ JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(const ASTTablesInSelectQuer\n \n     SubqueryForSet & subquery_for_join = subqueries_for_sets[join_subquery_id];\n \n-    /// Special case - if table name is specified on the right of JOIN, then the table has the type Join (the previously prepared mapping).\n+    /// Use StorageJoin if any.\n     if (!subquery_for_join.join)\n-        subquery_for_join.join = tryGetStorageJoin(join_element, syntax->analyzed_join, context);\n+        subquery_for_join.join = tryGetStorageJoin(syntax->analyzed_join);\n \n     if (!subquery_for_join.join)\n     {\n         /// Actions which need to be calculated on joined block.\n         ExpressionActionsPtr joined_block_actions = createJoinedBlockActions(context, analyzedJoin());\n \n+        Names original_right_columns;\n         if (!subquery_for_join.source)\n         {\n-            NamesWithAliases required_columns_with_aliases =\n-                analyzedJoin().getRequiredColumns(joined_block_actions->getSampleBlock(), joined_block_actions->getRequiredColumns());\n-            makeSubqueryForJoin(join_element, std::move(required_columns_with_aliases), subquery_for_join);\n+            NamesWithAliases required_columns_with_aliases = analyzedJoin().getRequiredColumns(\n+                joined_block_actions->getSampleBlock(), joined_block_actions->getRequiredColumns());\n+            for (auto & pr : required_columns_with_aliases)\n+                original_right_columns.push_back(pr.first);\n+\n+            /** For GLOBAL JOINs (in the case, for example, of the push method for executing GLOBAL subqueries), the following occurs\n+                * - in the addExternalStorage function, the JOIN (SELECT ...) subquery is replaced with JOIN _data1,\n+                *   in the subquery_for_set object this subquery is exposed as source and the temporary table _data1 as the `table`.\n+                * - this function shows the expression JOIN _data1.\n+                */\n+            auto interpreter = interpretSubquery(join_element.table_expression, context, original_right_columns, query_options);\n+\n+            subquery_for_join.makeSource(interpreter, std::move(required_columns_with_aliases));\n         }\n \n         /// TODO You do not need to set this up when JOIN is only needed on remote servers.\n         subquery_for_join.setJoinActions(joined_block_actions); /// changes subquery_for_join.sample_block inside\n-        subquery_for_join.join = makeJoin(syntax->analyzed_join, subquery_for_join.sample_block);\n+        subquery_for_join.join = makeJoin(syntax->analyzed_join, subquery_for_join.sample_block, context);\n+\n+        /// Do not make subquery for join over dictionary.\n+        if (syntax->analyzed_join->dictionary_reader)\n+        {\n+            JoinPtr join = subquery_for_join.join;\n+            subqueries_for_sets.erase(join_subquery_id);\n+            return join;\n+        }\n     }\n \n     return subquery_for_join.join;\n }\n \n-void SelectQueryExpressionAnalyzer::makeSubqueryForJoin(const ASTTablesInSelectQueryElement & join_element,\n-                                                        NamesWithAliases && required_columns_with_aliases,\n-                                                        SubqueryForSet & subquery_for_set) const\n-{\n-    /** For GLOBAL JOINs (in the case, for example, of the push method for executing GLOBAL subqueries), the following occurs\n-        * - in the addExternalStorage function, the JOIN (SELECT ...) subquery is replaced with JOIN _data1,\n-        *   in the subquery_for_set object this subquery is exposed as source and the temporary table _data1 as the `table`.\n-        * - this function shows the expression JOIN _data1.\n-        */\n-    Names original_columns;\n-    for (auto & pr : required_columns_with_aliases)\n-        original_columns.push_back(pr.first);\n-\n-    auto interpreter = interpretSubquery(join_element.table_expression, context, original_columns, query_options);\n-\n-    subquery_for_set.makeSource(interpreter, std::move(required_columns_with_aliases));\n-}\n-\n bool SelectQueryExpressionAnalyzer::appendPrewhere(\n     ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns)\n {\ndiff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex 4322a8973781..b7fda92e33f1 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -276,8 +276,6 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n     SetPtr isPlainStorageSetInSubquery(const ASTPtr & subquery_or_table_name);\n \n     JoinPtr makeTableJoin(const ASTTablesInSelectQueryElement & join_element);\n-    void makeSubqueryForJoin(const ASTTablesInSelectQueryElement & join_element, NamesWithAliases && required_columns_with_aliases,\n-                             SubqueryForSet & subquery_for_set) const;\n \n     const ASTSelectQuery * getAggregatingQuery() const;\n \ndiff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex b8da03acb8bd..456573c6c8e5 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -4,16 +4,21 @@\n \n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnString.h>\n+#include <Columns/ColumnVector.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnNullable.h>\n \n #include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n \n #include <Interpreters/HashJoin.h>\n #include <Interpreters/join_common.h>\n #include <Interpreters/TableJoin.h>\n #include <Interpreters/joinDispatch.h>\n #include <Interpreters/NullableUtils.h>\n+#include <Interpreters/DictionaryReader.h>\n+\n+#include <Storages/StorageDictionary.h>\n \n #include <DataStreams/IBlockInputStream.h>\n #include <DataStreams/materializeBlock.h>\n@@ -21,8 +26,6 @@\n #include <Core/ColumnNumbers.h>\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\n-#include <DataTypes/DataTypeLowCardinality.h>\n-\n \n namespace DB\n {\n@@ -282,6 +285,42 @@ static KeyGetter createKeyGetter(const ColumnRawPtrs & key_columns, const Sizes\n         return KeyGetter(key_columns, key_sizes, nullptr);\n }\n \n+class KeyGetterForDict\n+{\n+public:\n+    using Mapped = JoinStuff::MappedOne;\n+    using FindResult = ColumnsHashing::columns_hashing_impl::FindResultImpl<Mapped>;\n+\n+    KeyGetterForDict(const ColumnRawPtrs & key_columns_, const Sizes &, void *)\n+        : key_columns(key_columns_)\n+    {}\n+\n+    FindResult findKey(const TableJoin & table_join, size_t row, const Arena &)\n+    {\n+        const DictionaryReader & reader = *table_join.dictionary_reader;\n+        if (!read_result)\n+        {\n+            reader.readKeys(*key_columns[0], read_result, found, positions);\n+            result.block = &read_result;\n+\n+            if (table_join.forceNullableRight())\n+                for (auto & column : read_result)\n+                    if (table_join.rightBecomeNullable(column.type))\n+                        JoinCommon::convertColumnToNullable(column);\n+        }\n+\n+        result.row_num = positions[row];\n+        return FindResult(&result, found[row]);\n+    }\n+\n+private:\n+    const ColumnRawPtrs & key_columns;\n+    Block read_result;\n+    Mapped result;\n+    ColumnVector<UInt8>::Container found;\n+    std::vector<size_t> positions;\n+};\n+\n template <HashJoin::Type type, typename Value, typename Mapped>\n struct KeyGetterForTypeImpl;\n \n@@ -351,7 +390,7 @@ size_t HashJoin::getTotalRowCount() const\n         for (const auto & block : data->blocks)\n             res += block.rows();\n     }\n-    else\n+    else if (data->type != Type::DICT)\n     {\n         joinDispatch(kind, strictness, data->maps, [&](auto, auto, auto & map) { res += map.getTotalRowCount(data->type); });\n     }\n@@ -368,7 +407,7 @@ size_t HashJoin::getTotalByteCount() const\n         for (const auto & block : data->blocks)\n             res += block.bytes();\n     }\n-    else\n+    else if (data->type != Type::DICT)\n     {\n         joinDispatch(kind, strictness, data->maps, [&](auto, auto, auto & map) { res += map.getTotalByteCountImpl(data->type); });\n         res += data->pool.size();\n@@ -400,7 +439,13 @@ void HashJoin::setSampleBlock(const Block & block)\n     if (nullable_right_side)\n         JoinCommon::convertColumnsToNullable(sample_block_with_columns_to_add);\n \n-    if (strictness == ASTTableJoin::Strictness::Asof)\n+    if (table_join->dictionary_reader)\n+    {\n+        data->type = Type::DICT;\n+        std::get<MapsOne>(data->maps).create(Type::DICT);\n+        chooseMethod(key_columns, key_sizes); /// init key_sizes\n+    }\n+    else if (strictness == ASTTableJoin::Strictness::Asof)\n     {\n         if (kind != ASTTableJoin::Kind::Left and kind != ASTTableJoin::Kind::Inner)\n             throw Exception(\"ASOF only supports LEFT and INNER as base joins\", ErrorCodes::NOT_IMPLEMENTED);\n@@ -526,7 +571,8 @@ namespace\n         switch (type)\n         {\n             case HashJoin::Type::EMPTY: break;\n-            case HashJoin::Type::CROSS: break;    /// Do nothing. We have already saved block, and it is enough.\n+            case HashJoin::Type::CROSS: break; /// Do nothing. We have already saved block, and it is enough.\n+            case HashJoin::Type::DICT:  break; /// Noone should call it with Type::DICT.\n \n         #define M(TYPE) \\\n             case HashJoin::Type::TYPE: \\\n@@ -598,6 +644,8 @@ bool HashJoin::addJoinedBlock(const Block & source_block, bool check_limits)\n {\n     if (empty())\n         throw Exception(\"Logical error: HashJoin was not initialized\", ErrorCodes::LOGICAL_ERROR);\n+    if (overDictionary())\n+        throw Exception(\"Logical error: insert into hash-map in HashJoin over dictionary\", ErrorCodes::LOGICAL_ERROR);\n \n     /// There's no optimization for right side const columns. Remove constness if any.\n     Block block = materializeBlock(source_block);\n@@ -930,8 +978,7 @@ IColumn::Filter switchJoinRightColumns(const Maps & maps_, AddedColumns & added_\n         case HashJoin::Type::TYPE: \\\n             return joinRightColumnsSwitchNullability<KIND, STRICTNESS,\\\n                 typename KeyGetterForType<HashJoin::Type::TYPE, const std::remove_reference_t<decltype(*maps_.TYPE)>>::Type>(\\\n-                *maps_.TYPE, added_columns, null_map);\\\n-            break;\n+                *maps_.TYPE, added_columns, null_map);\n         APPLY_FOR_JOIN_VARIANTS(M)\n     #undef M\n \n@@ -940,6 +987,20 @@ IColumn::Filter switchJoinRightColumns(const Maps & maps_, AddedColumns & added_\n     }\n }\n \n+template <ASTTableJoin::Kind KIND, ASTTableJoin::Strictness STRICTNESS>\n+IColumn::Filter dictionaryJoinRightColumns(const TableJoin & table_join, AddedColumns & added_columns, const ConstNullMapPtr & null_map)\n+{\n+    if constexpr (KIND == ASTTableJoin::Kind::Left &&\n+        (STRICTNESS == ASTTableJoin::Strictness::Any ||\n+        STRICTNESS == ASTTableJoin::Strictness::Semi ||\n+        STRICTNESS == ASTTableJoin::Strictness::Anti))\n+    {\n+        return joinRightColumnsSwitchNullability<KIND, STRICTNESS, KeyGetterForDict>(table_join, added_columns, null_map);\n+    }\n+\n+    throw Exception(\"Logical error: wrong JOIN combination\", ErrorCodes::LOGICAL_ERROR);\n+}\n+\n } /// nameless\n \n \n@@ -1000,7 +1061,9 @@ void HashJoin::joinBlockImpl(\n     bool has_required_right_keys = (required_right_keys.columns() != 0);\n     added_columns.need_filter = need_filter || has_required_right_keys;\n \n-    IColumn::Filter row_filter = switchJoinRightColumns<KIND, STRICTNESS>(maps_, added_columns, data->type, null_map);\n+    IColumn::Filter row_filter = overDictionary() ?\n+        dictionaryJoinRightColumns<KIND, STRICTNESS>(*table_join, added_columns, null_map) :\n+        switchJoinRightColumns<KIND, STRICTNESS>(maps_, added_columns, data->type, null_map);\n \n     for (size_t i = 0; i < added_columns.size(); ++i)\n         block.insert(added_columns.moveColumn(i));\n@@ -1211,7 +1274,36 @@ void HashJoin::joinBlock(Block & block, ExtraBlockPtr & not_processed)\n     const Names & key_names_left = table_join->keyNamesLeft();\n     JoinCommon::checkTypesOfKeys(block, key_names_left, right_table_keys, key_names_right);\n \n-    if (joinDispatch(kind, strictness, data->maps, [&](auto kind_, auto strictness_, auto & map)\n+    if (overDictionary())\n+    {\n+        using Kind = ASTTableJoin::Kind;\n+        using Strictness = ASTTableJoin::Strictness;\n+\n+        auto & map = std::get<MapsOne>(data->maps);\n+        if (kind == Kind::Left)\n+        {\n+            switch (strictness)\n+            {\n+                case Strictness::Any:\n+                case Strictness::All:\n+                    joinBlockImpl<Kind::Left, Strictness::Any>(block, key_names_left, sample_block_with_columns_to_add, map);\n+                    break;\n+                case Strictness::Semi:\n+                    joinBlockImpl<Kind::Left, Strictness::Semi>(block, key_names_left, sample_block_with_columns_to_add, map);\n+                    break;\n+                case Strictness::Anti:\n+                    joinBlockImpl<Kind::Left, Strictness::Anti>(block, key_names_left, sample_block_with_columns_to_add, map);\n+                    break;\n+                default:\n+                    throw Exception(\"Logical error: wrong JOIN combination\", ErrorCodes::LOGICAL_ERROR);\n+            }\n+        }\n+        else if (kind == Kind::Inner && strictness == Strictness::All)\n+            joinBlockImpl<Kind::Left, Strictness::Semi>(block, key_names_left, sample_block_with_columns_to_add, map);\n+        else\n+            throw Exception(\"Logical error: wrong JOIN combination\", ErrorCodes::LOGICAL_ERROR);\n+    }\n+    else if (joinDispatch(kind, strictness, data->maps, [&](auto kind_, auto strictness_, auto & map)\n         {\n             joinBlockImpl<kind_, strictness_>(block, key_names_left, sample_block_with_columns_to_add, map);\n         }))\ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex b769cfc61c5a..9d4e0907f660 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -27,6 +27,7 @@ namespace DB\n {\n \n class TableJoin;\n+class DictionaryReader;\n \n namespace JoinStuff\n {\n@@ -148,7 +149,8 @@ class HashJoin : public IJoin\n public:\n     HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_sample_block, bool any_take_last_row_ = false);\n \n-    bool empty() { return data->type == Type::EMPTY; }\n+    bool empty() const { return data->type == Type::EMPTY; }\n+    bool overDictionary() const { return data->type == Type::DICT; }\n \n     /** Add block of data from right hand of JOIN to the map.\n       * Returns false, if some limit was exceeded and you should not insert more data.\n@@ -186,7 +188,7 @@ class HashJoin : public IJoin\n     /// Sum size in bytes of all buffers, used for JOIN maps and for all memory pools.\n     size_t getTotalByteCount() const final;\n \n-    bool alwaysReturnsEmptySet() const final { return isInnerOrRight(getKind()) && data->empty; }\n+    bool alwaysReturnsEmptySet() const final { return isInnerOrRight(getKind()) && data->empty && !overDictionary(); }\n \n     ASTTableJoin::Kind getKind() const { return kind; }\n     ASTTableJoin::Strictness getStrictness() const { return strictness; }\n@@ -220,12 +222,12 @@ class HashJoin : public IJoin\n     {\n         EMPTY,\n         CROSS,\n+        DICT,\n         #define M(NAME) NAME,\n             APPLY_FOR_JOIN_VARIANTS(M)\n         #undef M\n     };\n \n-\n     /** Different data structures, that are used to perform JOIN.\n       */\n     template <typename Mapped>\n@@ -247,6 +249,7 @@ class HashJoin : public IJoin\n             {\n                 case Type::EMPTY:            break;\n                 case Type::CROSS:            break;\n+                case Type::DICT:             break;\n \n             #define M(NAME) \\\n                 case Type::NAME: NAME = std::make_unique<typename decltype(NAME)::element_type>(); break;\n@@ -261,6 +264,7 @@ class HashJoin : public IJoin\n             {\n                 case Type::EMPTY:            return 0;\n                 case Type::CROSS:            return 0;\n+                case Type::DICT:             return 0;\n \n             #define M(NAME) \\\n                 case Type::NAME: return NAME ? NAME->size() : 0;\n@@ -277,6 +281,7 @@ class HashJoin : public IJoin\n             {\n                 case Type::EMPTY:            return 0;\n                 case Type::CROSS:            return 0;\n+                case Type::DICT:             return 0;\n \n             #define M(NAME) \\\n                 case Type::NAME: return NAME ? NAME->getBufferSizeInBytes() : 0;\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 691b3c1045b5..48ae00ffe1fa 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -305,12 +305,13 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n \n     max_streams = settings.max_threads;\n     ASTSelectQuery & query = getSelectQuery();\n+    std::shared_ptr<TableJoin> table_join = joined_tables.makeTableJoin(query);\n \n     auto analyze = [&] (bool try_move_to_prewhere = true)\n     {\n         syntax_analyzer_result = SyntaxAnalyzer(*context).analyzeSelect(\n                 query_ptr, SyntaxAnalyzerResult(source_header.getNamesAndTypesList(), storage),\n-                options, joined_tables.tablesWithColumns(), required_result_column_names);\n+                options, joined_tables.tablesWithColumns(), required_result_column_names, table_join);\n \n         /// Save scalar sub queries's results in the query context\n         if (context->hasQueryContext())\ndiff --git a/src/Interpreters/JoinedTables.cpp b/src/Interpreters/JoinedTables.cpp\nindex cedf95bea068..44bd83458c4c 100644\n--- a/src/Interpreters/JoinedTables.cpp\n+++ b/src/Interpreters/JoinedTables.cpp\n@@ -1,18 +1,26 @@\n #include <Interpreters/JoinedTables.h>\n+#include <Interpreters/TableJoin.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/getTableExpressions.h>\n #include <Interpreters/InJoinSubqueriesPreprocessor.h>\n #include <Interpreters/IdentifierSemantic.h>\n #include <Interpreters/InDepthNodeVisitor.h>\n+\n #include <Storages/IStorage.h>\n #include <Storages/ColumnsDescription.h>\n #include <Storages/StorageValues.h>\n+#include <Storages/StorageJoin.h>\n+#include <Storages/StorageDictionary.h>\n+\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTQualifiedAsterisk.h>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n+#include <Parsers/parseQuery.h>\n \n namespace DB\n {\n@@ -26,6 +34,34 @@ namespace ErrorCodes\n namespace\n {\n \n+void replaceJoinedTable(const ASTSelectQuery & select_query)\n+{\n+    const ASTTablesInSelectQueryElement * join = select_query.join();\n+    if (!join || !join->table_expression)\n+        return;\n+\n+    /// TODO: Push down for CROSS JOIN is not OK [disabled]\n+    const auto & table_join = join->table_join->as<ASTTableJoin &>();\n+    if (table_join.kind == ASTTableJoin::Kind::Cross)\n+        return;\n+\n+    auto & table_expr = join->table_expression->as<ASTTableExpression &>();\n+    if (table_expr.database_and_table_name)\n+    {\n+        const auto & table_id = table_expr.database_and_table_name->as<ASTIdentifier &>();\n+        String expr = \"(select * from \" + table_id.name + \") as \" + table_id.shortName();\n+\n+        // FIXME: since the expression \"a as b\" exposes both \"a\" and \"b\" names, which is not equivalent to \"(select * from a) as b\",\n+        //        we can't replace aliased tables.\n+        // FIXME: long table names include database name, which we can't save within alias.\n+        if (table_id.alias.empty() && table_id.isShort())\n+        {\n+            ParserTableExpression parser;\n+            table_expr = parseQuery(parser, expr, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH)->as<ASTTableExpression &>();\n+        }\n+    }\n+}\n+\n template <typename T>\n void checkTablesWithColumns(const std::vector<T> & tables_with_columns, const Context & context)\n {\n@@ -209,4 +245,35 @@ void JoinedTables::rewriteDistributedInAndJoins(ASTPtr & query)\n     }\n }\n \n+std::shared_ptr<TableJoin> JoinedTables::makeTableJoin(const ASTSelectQuery & select_query)\n+{\n+    if (tables_with_columns.size() < 2)\n+        return {};\n+\n+    auto settings = context.getSettingsRef();\n+    auto table_join = std::make_shared<TableJoin>(settings, context.getTemporaryVolume());\n+\n+    const ASTTablesInSelectQueryElement * ast_join = select_query.join();\n+    const auto & table_to_join = ast_join->table_expression->as<ASTTableExpression &>();\n+\n+    /// TODO This syntax does not support specifying a database name.\n+    if (table_to_join.database_and_table_name)\n+    {\n+        auto joined_table_id = context.resolveStorageID(table_to_join.database_and_table_name);\n+        StoragePtr table = DatabaseCatalog::instance().tryGetTable(joined_table_id);\n+        if (table)\n+        {\n+            if (dynamic_cast<StorageJoin *>(table.get()) ||\n+                dynamic_cast<StorageDictionary *>(table.get()))\n+                table_join->joined_storage = table;\n+        }\n+    }\n+\n+    if (!table_join->joined_storage &&\n+        settings.enable_optimize_predicate_expression)\n+        replaceJoinedTable(select_query);\n+\n+    return table_join;\n+}\n+\n }\ndiff --git a/src/Interpreters/JoinedTables.h b/src/Interpreters/JoinedTables.h\nindex 3bcec883f307..399acdc0768e 100644\n--- a/src/Interpreters/JoinedTables.h\n+++ b/src/Interpreters/JoinedTables.h\n@@ -10,6 +10,7 @@ namespace DB\n \n class ASTSelectQuery;\n class Context;\n+class TableJoin;\n struct SelectQueryOptions;\n \n /// Joined tables' columns resolver.\n@@ -30,6 +31,7 @@ class JoinedTables\n \n     /// Make fake tables_with_columns[0] in case we have predefined input in InterpreterSelectQuery\n     void makeFakeTable(StoragePtr storage, const Block & source_header);\n+    std::shared_ptr<TableJoin> makeTableJoin(const ASTSelectQuery & select_query);\n \n     const std::vector<TableWithColumnNamesAndTypes> & tablesWithColumns() const { return tables_with_columns; }\n \ndiff --git a/src/Interpreters/SyntaxAnalyzer.cpp b/src/Interpreters/SyntaxAnalyzer.cpp\nindex e19961e7a7c2..924b4d7444e6 100644\n--- a/src/Interpreters/SyntaxAnalyzer.cpp\n+++ b/src/Interpreters/SyntaxAnalyzer.cpp\n@@ -29,8 +29,6 @@\n #include <Parsers/ASTOrderByElement.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/ParserTablesInSelectQuery.h>\n-#include <Parsers/parseQuery.h>\n #include <Parsers/queryToString.h>\n \n #include <DataTypes/NestedUtils.h>\n@@ -565,34 +563,6 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTSelectQuery & sele\n     }\n }\n \n-void replaceJoinedTable(const ASTSelectQuery & select_query)\n-{\n-    const ASTTablesInSelectQueryElement * join = select_query.join();\n-    if (!join || !join->table_expression)\n-        return;\n-\n-    /// TODO: Push down for CROSS JOIN is not OK [disabled]\n-    const auto & table_join = join->table_join->as<ASTTableJoin &>();\n-    if (table_join.kind == ASTTableJoin::Kind::Cross)\n-        return;\n-\n-    auto & table_expr = join->table_expression->as<ASTTableExpression &>();\n-    if (table_expr.database_and_table_name)\n-    {\n-        const auto & table_id = table_expr.database_and_table_name->as<ASTIdentifier &>();\n-        String expr = \"(select * from \" + table_id.name + \") as \" + table_id.shortName();\n-\n-        // FIXME: since the expression \"a as b\" exposes both \"a\" and \"b\" names, which is not equivalent to \"(select * from a) as b\",\n-        //        we can't replace aliased tables.\n-        // FIXME: long table names include database name, which we can't save within alias.\n-        if (table_id.alias.empty() && table_id.isShort())\n-        {\n-            ParserTableExpression parser;\n-            table_expr = parseQuery(parser, expr, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH)->as<ASTTableExpression &>();\n-        }\n-    }\n-}\n-\n std::vector<const ASTFunction *> getAggregates(ASTPtr & query, const ASTSelectQuery & select_query)\n {\n     /// There can not be aggregate functions inside the WHERE and PREWHERE.\n@@ -799,7 +769,8 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyzeSelect(\n     SyntaxAnalyzerResult && result,\n     const SelectQueryOptions & select_options,\n     const std::vector<TableWithColumnNamesAndTypes> & tables_with_columns,\n-    const Names & required_result_columns) const\n+    const Names & required_result_columns,\n+    std::shared_ptr<TableJoin> table_join) const\n {\n     auto * select_query = query->as<ASTSelectQuery>();\n     if (!select_query)\n@@ -811,14 +782,13 @@ SyntaxAnalyzerResultPtr SyntaxAnalyzer::analyzeSelect(\n     const auto & settings = context.getSettingsRef();\n \n     const NameSet & source_columns_set = result.source_columns_set;\n-    result.analyzed_join = std::make_shared<TableJoin>(settings, context.getTemporaryVolume());\n+    result.analyzed_join = table_join;\n+    if (!result.analyzed_join) /// ExpressionAnalyzer expects some not empty object here\n+        result.analyzed_join = std::make_shared<TableJoin>();\n \n     if (remove_duplicates)\n         renameDuplicatedColumns(select_query);\n \n-    if (settings.enable_optimize_predicate_expression)\n-        replaceJoinedTable(*select_query);\n-\n     /// TODO: Remove unneeded conversion\n     std::vector<TableWithColumnNames> tables_with_column_names;\n     tables_with_column_names.reserve(tables_with_columns.size());\ndiff --git a/src/Interpreters/SyntaxAnalyzer.h b/src/Interpreters/SyntaxAnalyzer.h\nindex 23e8a4b79aa1..08afd14b83c1 100644\n--- a/src/Interpreters/SyntaxAnalyzer.h\n+++ b/src/Interpreters/SyntaxAnalyzer.h\n@@ -94,7 +94,8 @@ class SyntaxAnalyzer\n         SyntaxAnalyzerResult && result,\n         const SelectQueryOptions & select_options = {},\n         const std::vector<TableWithColumnNamesAndTypes> & tables_with_columns = {},\n-        const Names & required_result_columns = {}) const;\n+        const Names & required_result_columns = {},\n+        std::shared_ptr<TableJoin> table_join = {}) const;\n \n private:\n     const Context & context;\ndiff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp\nindex 339fe2dceb3a..246c21292976 100644\n--- a/src/Interpreters/TableJoin.cpp\n+++ b/src/Interpreters/TableJoin.cpp\n@@ -159,22 +159,26 @@ NamesWithAliases TableJoin::getRequiredColumns(const Block & sample, const Names\n     return getNamesWithAliases(required_columns);\n }\n \n+bool TableJoin::leftBecomeNullable(const DataTypePtr & column_type) const\n+{\n+    return forceNullableLeft() && column_type->canBeInsideNullable();\n+}\n+\n+bool TableJoin::rightBecomeNullable(const DataTypePtr & column_type) const\n+{\n+    return forceNullableRight() && column_type->canBeInsideNullable();\n+}\n+\n void TableJoin::addJoinedColumn(const NameAndTypePair & joined_column)\n {\n-    if (join_use_nulls && isLeftOrFull(table_join.kind))\n-    {\n-        auto type = joined_column.type->canBeInsideNullable() ? makeNullable(joined_column.type) : joined_column.type;\n-        columns_added_by_join.emplace_back(NameAndTypePair(joined_column.name, std::move(type)));\n-    }\n+    if (rightBecomeNullable(joined_column.type))\n+        columns_added_by_join.emplace_back(NameAndTypePair(joined_column.name, makeNullable(joined_column.type)));\n     else\n         columns_added_by_join.push_back(joined_column);\n }\n \n void TableJoin::addJoinedColumnsAndCorrectNullability(Block & sample_block) const\n {\n-    bool right_or_full_join = isRightOrFull(table_join.kind);\n-    bool left_or_full_join = isLeftOrFull(table_join.kind);\n-\n     for (auto & col : sample_block)\n     {\n         /// Materialize column.\n@@ -183,9 +187,7 @@ void TableJoin::addJoinedColumnsAndCorrectNullability(Block & sample_block) cons\n         if (col.column)\n             col.column = nullptr;\n \n-        bool make_nullable = join_use_nulls && right_or_full_join;\n-\n-        if (make_nullable && col.type->canBeInsideNullable())\n+        if (leftBecomeNullable(col.type))\n             col.type = makeNullable(col.type);\n     }\n \n@@ -193,9 +195,7 @@ void TableJoin::addJoinedColumnsAndCorrectNullability(Block & sample_block) cons\n     {\n         auto res_type = col.type;\n \n-        bool make_nullable = join_use_nulls && left_or_full_join;\n-\n-        if (make_nullable && res_type->canBeInsideNullable())\n+        if (rightBecomeNullable(res_type))\n             res_type = makeNullable(res_type);\n \n         sample_block.insert(ColumnWithTypeAndName(nullptr, res_type, col.name));\n@@ -242,4 +242,31 @@ bool TableJoin::allowMergeJoin() const\n     return allow_merge_join;\n }\n \n+bool TableJoin::allowDictJoin(const String & dict_key, const Block & sample_block, Names & names, NamesAndTypesList & result_columns) const\n+{\n+    /// Support ALL INNER, [ANY | ALL | SEMI | ANTI] LEFT\n+    if (!isLeft(kind()) && !(isInner(kind()) && strictness() == ASTTableJoin::Strictness::All))\n+        return false;\n+\n+    const Names & right_keys = keyNamesRight();\n+    if (right_keys.size() != 1)\n+        return false;\n+\n+    for (auto & col : sample_block)\n+    {\n+        String original = original_names.find(col.name)->second;\n+        if (col.name == right_keys[0])\n+        {\n+            if (original != dict_key)\n+                return false; /// JOIN key != Dictionary key\n+            continue; /// do not extract key column\n+        }\n+\n+        names.push_back(original);\n+        result_columns.push_back({col.name, col.type});\n+    }\n+\n+    return true;\n+}\n+\n }\ndiff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h\nindex 0b5ed82411a6..2047f9359662 100644\n--- a/src/Interpreters/TableJoin.h\n+++ b/src/Interpreters/TableJoin.h\n@@ -8,6 +8,7 @@\n #include <Interpreters/asof.h>\n #include <DataStreams/IBlockStream_fwd.h>\n #include <DataStreams/SizeLimits.h>\n+#include <Storages/IStorage_fwd.h>\n \n #include <utility>\n #include <memory>\n@@ -19,6 +20,7 @@ class Context;\n class ASTSelectQuery;\n struct DatabaseAndTableWithAlias;\n class Block;\n+class DictionaryReader;\n \n struct Settings;\n \n@@ -42,10 +44,10 @@ class TableJoin\n     friend class SyntaxAnalyzer;\n \n     const SizeLimits size_limits;\n-    const size_t default_max_bytes;\n-    const bool join_use_nulls;\n+    const size_t default_max_bytes = 0;\n+    const bool join_use_nulls = false;\n     const size_t max_joined_block_rows = 0;\n-    JoinAlgorithm join_algorithm;\n+    JoinAlgorithm join_algorithm = JoinAlgorithm::AUTO;\n     const bool partial_merge_join_optimizations = false;\n     const size_t partial_merge_join_rows_in_right_blocks = 0;\n \n@@ -69,6 +71,7 @@ class TableJoin\n     VolumePtr tmp_volume;\n \n public:\n+    TableJoin() = default;\n     TableJoin(const Settings &, VolumePtr tmp_volume);\n \n     /// for StorageJoin\n@@ -84,12 +87,16 @@ class TableJoin\n         table_join.strictness = strictness;\n     }\n \n+    StoragePtr joined_storage;\n+    std::shared_ptr<DictionaryReader> dictionary_reader;\n+\n     ASTTableJoin::Kind kind() const { return table_join.kind; }\n     ASTTableJoin::Strictness strictness() const { return table_join.strictness; }\n     bool sameStrictnessAndKind(ASTTableJoin::Strictness, ASTTableJoin::Kind) const;\n     const SizeLimits & sizeLimits() const { return size_limits; }\n     VolumePtr getTemporaryVolume() { return tmp_volume; }\n     bool allowMergeJoin() const;\n+    bool allowDictJoin(const String & dict_key, const Block & sample_block, Names &, NamesAndTypesList &) const;\n     bool preferMergeJoin() const { return join_algorithm == JoinAlgorithm::PREFER_PARTIAL_MERGE; }\n     bool forceMergeJoin() const { return join_algorithm == JoinAlgorithm::PARTIAL_MERGE; }\n     bool forceHashJoin() const { return join_algorithm == JoinAlgorithm::HASH; }\n@@ -115,6 +122,8 @@ class TableJoin\n     size_t rightKeyInclusion(const String & name) const;\n     NameSet requiredRightKeys() const;\n \n+    bool leftBecomeNullable(const DataTypePtr & column_type) const;\n+    bool rightBecomeNullable(const DataTypePtr & column_type) const;\n     void addJoinedColumn(const NameAndTypePair & joined_column);\n     void addJoinedColumnsAndCorrectNullability(Block & sample_block) const;\n \ndiff --git a/src/Storages/StorageDictionary.h b/src/Storages/StorageDictionary.h\nindex 87826304166c..7036c78eb7ea 100644\n--- a/src/Storages/StorageDictionary.h\n+++ b/src/Storages/StorageDictionary.h\n@@ -56,6 +56,8 @@ class StorageDictionary final : public ext::shared_ptr_helper<StorageDictionary>\n         return description;\n     }\n \n+    const String & dictionaryName() const { return dictionary_name; }\n+\n private:\n     using Ptr = MultiVersion<IDictionaryBase>::Version;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00561_storage_join.sql b/tests/queries/0_stateless/00561_storage_join.sql\nindex 08f768157029..62ca80d31fe2 100644\n--- a/tests/queries/0_stateless/00561_storage_join.sql\n+++ b/tests/queries/0_stateless/00561_storage_join.sql\n@@ -1,5 +1,3 @@\n-SET any_join_distinct_right_table_keys = 1;\n-\n drop table IF EXISTS joinbug;\n \n CREATE TABLE joinbug (\n@@ -21,7 +19,7 @@ CREATE TABLE joinbug_join (\n   val UInt64,\n   val2 Int32,\n   created UInt64\n-) ENGINE = Join(ANY, INNER, id2);\n+) ENGINE = Join(SEMI, LEFT, id2);\n \n insert into joinbug_join (id, id2, val, val2, created)\n select id, id2, val, val2, created\n@@ -36,7 +34,7 @@ select id, id2, val, val2, created\n from (\n    SELECT toUInt64(arrayJoin(range(50))) AS id2\n ) js1\n-ANY INNER JOIN joinbug_join using id2;\n+SEMI LEFT JOIN joinbug_join using id2;\n \n DROP TABLE joinbug;\n DROP TABLE joinbug_join;\ndiff --git a/tests/queries/0_stateless/01115_join_with_dictionary.reference b/tests/queries/0_stateless/01115_join_with_dictionary.reference\nnew file mode 100644\nindex 000000000000..f909a3d61f52\n--- /dev/null\n+++ b/tests/queries/0_stateless/01115_join_with_dictionary.reference\n@@ -0,0 +1,103 @@\n+flat: left on\n+0\t0\t0\t0\t0\n+1\t1\t1\t1\t1\n+2\t2\t2\t2\t2\n+3\t3\t3\t3\t3\n+4\t0\t0\t\t0\n+flat: left\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t0\t\t0\n+flat: any left\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t0\t\t0\n+flat: semi left\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+flat: anti left\n+4\t0\t\t0\n+flat: inner\n+0\t0\t0\t0\n+1\t1\t1\t1\n+flat: inner on\n+0\t0\t0\t0\t0\n+1\t1\t1\t1\t1\n+2\t2\t2\t2\t2\n+3\t3\t3\t3\t3\n+hashed: left on\n+0\t0\t0\t0\t0\n+1\t1\t1\t1\t1\n+2\t2\t2\t2\t2\n+3\t3\t3\t3\t3\n+4\t\\N\t\\N\t\\N\t\\N\n+hashed: left\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t\\N\t\\N\t\\N\n+hashed: any left\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t\\N\t\\N\t\\N\n+hashed: semi left\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+hashed: anti left\n+4\t\\N\t\\N\t\\N\n+hashed: inner\n+0\t0\t0\t0\n+1\t1\t1\t1\n+hashed: inner on\n+0\t0\t0\t0\t0\n+1\t1\t1\t1\t1\n+2\t2\t2\t2\t2\n+3\t3\t3\t3\t3\n+complex_cache (smoke)\n+0\t\\N\t\\N\t\\N\t\\N\n+1\t\\N\t\\N\t\\N\t\\N\n+2\t\\N\t\\N\t\\N\t\\N\n+3\t\\N\t\\N\t\\N\t\\N\n+4\t\\N\t\\N\t\\N\t\\N\n+not optimized (smoke)\n+0\t0\t0\t0\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+-\n+0\t0\t0\t0\t0\n+1\t1\t1\t1\t1\n+\\N\t2\t2\t2\t2\n+\\N\t3\t3\t3\t3\n+-\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t\\N\t\\N\t\\N\n+5\t\\N\t\\N\t\\N\n+\\N\t0\t0\t0\n+\\N\t1\t1\t1\n+-\n+0\t0\t0\t0\n+1\t1\t1\t1\n+-\n+0\t0\t0\t0\n+1\t1\t1\t1\n+3\t3\t3\t3\n+2\t2\t2\t2\n+-\n+0\t0\t0\t0\n+1\t1\t1\t1\n+-\n+3\t3\t3\t3\n+2\t2\t2\t2\ndiff --git a/tests/queries/0_stateless/01115_join_with_dictionary.sql b/tests/queries/0_stateless/01115_join_with_dictionary.sql\nnew file mode 100644\nindex 000000000000..65704f2b3eba\n--- /dev/null\n+++ b/tests/queries/0_stateless/01115_join_with_dictionary.sql\n@@ -0,0 +1,90 @@\n+SET send_logs_level = 'none';\n+\n+DROP DATABASE IF EXISTS db_01115;\n+CREATE DATABASE db_01115 Engine = Ordinary;\n+\n+USE db_01115;\n+\n+DROP DICTIONARY IF EXISTS dict_flat;\n+DROP DICTIONARY IF EXISTS dict_hashed;\n+DROP DICTIONARY IF EXISTS dict_complex_cache;\n+\n+CREATE TABLE t1 (key UInt64, a UInt8, b String, c Float64) ENGINE = MergeTree() ORDER BY key;\n+INSERT INTO t1 SELECT number, number, toString(number), number from numbers(4);\n+\n+CREATE DICTIONARY dict_flat (key UInt64 DEFAULT 0, a UInt8 DEFAULT 42, b String DEFAULT 'x', c Float64 DEFAULT 42.0)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 't1' PASSWORD '' DB 'db_01115'))\n+LIFETIME(MIN 1 MAX 10)\n+LAYOUT(FLAT());\n+\n+CREATE DICTIONARY db_01115.dict_hashed (key UInt64 DEFAULT 0, a UInt8 DEFAULT 42, b String DEFAULT 'x', c Float64 DEFAULT 42.0)\n+PRIMARY KEY key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 't1' DB 'db_01115'))\n+LIFETIME(MIN 1 MAX 10)\n+LAYOUT(HASHED());\n+\n+CREATE DICTIONARY dict_complex_cache (key UInt64 DEFAULT 0, a UInt8 DEFAULT 42, b String DEFAULT 'x', c Float64 DEFAULT 42.0)\n+PRIMARY KEY key, b\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9000 USER 'default' TABLE 't1' DB 'db_01115'))\n+LIFETIME(MIN 1 MAX 10)\n+LAYOUT(COMPLEX_KEY_CACHE(SIZE_IN_CELLS 1));\n+\n+SET join_use_nulls = 0;\n+\n+SELECT 'flat: left on';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 LEFT JOIN dict_flat d ON s1.key = d.key ORDER BY s1.key;\n+SELECT 'flat: left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 LEFT JOIN dict_flat d USING(key) ORDER BY key;\n+SELECT 'flat: any left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 ANY LEFT JOIN dict_flat d USING(key) ORDER BY key;\n+SELECT 'flat: semi left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 SEMI JOIN dict_flat d USING(key) ORDER BY key;\n+SELECT 'flat: anti left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 ANTI JOIN dict_flat d USING(key) ORDER BY key;\n+SELECT 'flat: inner';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 JOIN dict_flat d USING(key);\n+SELECT 'flat: inner on';\n+SELECT * FROM (SELECT number AS k FROM numbers(100)) s1 JOIN dict_flat d ON k = key ORDER BY k;\n+\n+SET join_use_nulls = 1;\n+\n+SELECT 'hashed: left on';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 LEFT JOIN dict_hashed d ON s1.key = d.key ORDER BY s1.key;\n+SELECT 'hashed: left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 LEFT JOIN dict_hashed d USING(key) ORDER BY key;\n+SELECT 'hashed: any left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 ANY LEFT JOIN dict_hashed d USING(key) ORDER BY key;\n+SELECT 'hashed: semi left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 SEMI JOIN dict_hashed d USING(key) ORDER BY key;\n+SELECT 'hashed: anti left';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 ANTI JOIN dict_hashed d USING(key) ORDER BY key;\n+SELECT 'hashed: inner';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 JOIN dict_hashed d USING(key);\n+SELECT 'hashed: inner on';\n+SELECT * FROM (SELECT number AS k FROM numbers(100)) s1 JOIN dict_hashed d ON k = key ORDER BY k;\n+\n+SELECT 'complex_cache (smoke)';\n+SELECT * FROM (SELECT number AS key FROM numbers(5)) s1 LEFT JOIN dict_complex_cache d ON s1.key = d.key ORDER BY s1.key;\n+\n+SELECT 'not optimized (smoke)';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 RIGHT JOIN dict_flat d USING(key) ORDER BY key;\n+SELECT '-';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 RIGHT JOIN dict_flat d ON s1.key = d.key ORDER BY d.key;\n+SELECT '-';\n+SELECT * FROM (SELECT number + 2 AS key FROM numbers(4)) s1 FULL JOIN dict_flat d USING(key) ORDER BY s1.key, d.key;\n+SELECT '-';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 ANY INNER JOIN dict_flat d USING(key);\n+SELECT '-';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 ANY RIGHT JOIN dict_flat d USING(key);\n+SELECT '-';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 SEMI RIGHT JOIN dict_flat d USING(key);\n+SELECT '-';\n+SELECT * FROM (SELECT number AS key FROM numbers(2)) s1 ANTI RIGHT JOIN dict_flat d USING(key);\n+\n+DROP DICTIONARY dict_flat;\n+DROP DICTIONARY dict_hashed;\n+DROP DICTIONARY dict_complex_cache;\n+\n+DROP TABLE t1;\n+DROP DATABASE IF EXISTS db_01115;\ndiff --git a/tests/queries/1_stateful/00065_loyalty_with_storage_join.sql b/tests/queries/1_stateful/00065_loyalty_with_storage_join.sql\nindex d3e73faa7bea..15a2a75cf589 100644\n--- a/tests/queries/1_stateful/00065_loyalty_with_storage_join.sql\n+++ b/tests/queries/1_stateful/00065_loyalty_with_storage_join.sql\n@@ -1,16 +1,14 @@\n-SET any_join_distinct_right_table_keys = 1;\n-\n USE test;\n \n DROP TABLE IF EXISTS join;\n-CREATE TABLE join (UserID UInt64, loyalty Int8) ENGINE = Join(ANY, INNER, UserID);\n+CREATE TABLE join (UserID UInt64, loyalty Int8) ENGINE = Join(SEMI, LEFT, UserID);\n \n INSERT INTO join\n SELECT\n     UserID,\n     toInt8(if((sum(SearchEngineID = 2) AS yandex) > (sum(SearchEngineID = 3) AS google),\n-\tyandex / (yandex + google), \n-\t-google / (yandex + google)) * 10) AS loyalty\n+    yandex / (yandex + google), \n+    -google / (yandex + google)) * 10) AS loyalty\n FROM hits\n WHERE (SearchEngineID = 2) OR (SearchEngineID = 3)\n GROUP BY UserID\n@@ -19,17 +17,17 @@ HAVING (yandex + google) > 10;\n SELECT\n     loyalty,\n     count()\n-FROM hits ANY INNER JOIN join USING UserID\n+FROM hits SEMI LEFT JOIN join USING UserID\n GROUP BY loyalty\n ORDER BY loyalty ASC;\n \n DETACH TABLE join;\n-ATTACH TABLE join (UserID UInt64, loyalty Int8) ENGINE = Join(ANY, INNER, UserID);\n+ATTACH TABLE join (UserID UInt64, loyalty Int8) ENGINE = Join(SEMI, LEFT, UserID);\n \n SELECT\n     loyalty,\n     count()\n-FROM hits ANY INNER JOIN join USING UserID\n+FROM hits SEMI LEFT JOIN join USING UserID\n GROUP BY loyalty\n ORDER BY loyalty ASC;\n \n",
  "problem_statement": "JOIN with Dictionary (lookup join)\nIt's quite easy to implement LEFT|INNER JOIN over Dictionaty with better perfomace than we have with general JOINs. We could make fake HashMap wrapper over the Dictionary and use it in HashJoin algorithm instead of real HashMaps it uses. So we need no insertion phase of JOIN there. Selects are not limited by memory. Memory usage is managed by Dictionary itsefls.\r\n\r\nIn fact it's just a lookup join strategy with some cache managed by Dictionary type.\r\n\n",
  "hints_text": "+1.\r\n\r\nAfter \"DDL Dictionaries\" feature is implemented, the user will have a table for every dictionary. And it will be very likely that the user will JOIN with this table instead of using dictGet.",
  "created_at": "2020-04-08T19:06:09Z"
}