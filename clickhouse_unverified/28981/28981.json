{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28981,
  "instance_id": "ClickHouse__ClickHouse-28981",
  "issue_numbers": [
    "28649"
  ],
  "base_commit": "ef6079633dc5237b6affbee87553b961e4b39ef1",
  "patch": "diff --git a/docs/en/operations/clickhouse-keeper.md b/docs/en/operations/clickhouse-keeper.md\nindex 81516140f84f..b1c53b61b125 100644\n--- a/docs/en/operations/clickhouse-keeper.md\n+++ b/docs/en/operations/clickhouse-keeper.md\n@@ -49,6 +49,7 @@ Internal coordination settings are located in `<keeper_server>.<coordination_set\n -    `auto_forwarding` \u2014 Allow to forward write requests from followers to the leader (default: true).\n -    `shutdown_timeout` \u2014 Wait to finish internal connections and shutdown (ms) (default: 5000).\n -    `startup_timeout` \u2014 If the server doesn't connect to other quorum participants in the specified timeout it will terminate (ms) (default: 30000).\n+-    `four_letter_word_white_list` \u2014 White list of 4lw commands (default: \"conf,cons,crst,envi,ruok,srst,srvr,stat,wchc,wchs,dirs,mntr,isro\").\n \n Quorum configuration is located in `<keeper_server>.<raft_configuration>` section and contain servers description.\n \n@@ -104,6 +105,196 @@ ClickHouse Keeper is bundled into the ClickHouse server package, just add config\n clickhouse-keeper --config /etc/your_path_to_config/config.xml --daemon\n ```\n \n+## Four Latter Word Commands\n+\n+ClickHouse Keeper also provides 4lw commands which are almost the same with Zookeeper. Each command is composed of four letters such as `mntr`, `stat` etc. There are some more interesting commands: `stat` gives some general information about the server and connected clients, while `srvr` and `cons` give extended details on server and connections respectively.  \n+\n+The 4lw commands has a white list configuration `four_letter_word_white_list` which has default value \"conf,cons,crst,envi,ruok,srst,srvr,stat,wchc,wchs,dirs,mntr,isro\".\n+\n+You can issue the commands to ClickHouse Keeper via telnet or nc, at the client port.\n+```\n+echo mntr | nc localhost 9181\n+```\n+\n+Bellow is the detailed 4lw commands:\n+\n+- ruok : Tests if server is running in a non-error state. The server will respond with imok if it is running. Otherwise it will not respond at all. A response of \"imok\" does not necessarily indicate that the server has joined the quorum, just that the server process is active and bound to the specified client port. Use \"stat\" for details on state wrt quorum and client connection information.\n+\n+```\n+imok\n+```\n+\n+- mntr : Outputs a list of variables that could be used for monitoring the health of the cluster.\n+\n+```\n+zk_version      v21.11.1.1-prestable-7a4a0b0edef0ad6e0aa662cd3b90c3f4acf796e7\n+zk_avg_latency  0\n+zk_max_latency  0\n+zk_min_latency  0\n+zk_packets_received     68\n+zk_packets_sent 68\n+zk_num_alive_connections        1\n+zk_outstanding_requests 0\n+zk_server_state leader\n+zk_znode_count  4\n+zk_watch_count  1\n+zk_ephemerals_count     0\n+zk_approximate_data_size        723\n+zk_open_file_descriptor_count   310\n+zk_max_file_descriptor_count    10240\n+zk_followers    0\n+zk_synced_followers     0\n+```\n+\n+- srvr : Lists full details for the server.\n+\n+```\n+ClickHouse Keeper version: v21.11.1.1-prestable-7a4a0b0edef0ad6e0aa662cd3b90c3f4acf796e7\n+Latency min/avg/max: 0/0/0\n+\n+Received: 2\n+Sent : 2\n+Connections: 1\n+Outstanding: 0\n+Zxid: 34\n+Mode: leader\n+Node count: 4\n+```\n+\n+- stat : Lists brief details for the server and connected clients.\n+\n+```\n+ClickHouse Keeper version: v21.11.1.1-prestable-7a4a0b0edef0ad6e0aa662cd3b90c3f4acf796e7\n+Clients:\n+ 192.168.1.1:52852(recved=0,sent=0)\n+ 192.168.1.1:52042(recved=24,sent=48)\n+\n+Latency min/avg/max: 0/0/0\n+\n+Received: 4\n+Sent : 4\n+Connections: 1\n+Outstanding: 0\n+Zxid: 36\n+Mode: leader\n+Node count: 4\n+\n+```\n+\n+- srst : Reset server statistics. The command will affect the result of `srvr`, `mntr` and `stat`.\n+\n+```\n+Server stats reset.\n+```\n+\n+- conf : Print details about serving configuration.\n+\n+```\n+server_id=1\n+tcp_port=2181\n+four_letter_word_white_list=*\n+log_storage_path=./coordination/logs\n+snapshot_storage_path=./coordination/snapshots\n+max_requests_batch_size=100\n+session_timeout_ms=30000\n+operation_timeout_ms=10000\n+dead_session_check_period_ms=500\n+heart_beat_interval_ms=500\n+election_timeout_lower_bound_ms=1000\n+election_timeout_upper_bound_ms=2000\n+reserved_log_items=1000000000000000\n+snapshot_distance=10000\n+auto_forwarding=true\n+shutdown_timeout=5000\n+startup_timeout=240000\n+raft_logs_level=information\n+snapshots_to_keep=3\n+rotate_log_storage_interval=100000\n+stale_log_gap=10000\n+fresh_log_gap=200\n+max_requests_batch_size=100\n+quorum_reads=false\n+force_sync=false\n+compress_logs=true\n+compress_snapshots_with_zstd_format=true\n+configuration_change_tries_count=20\n+```\n+\n+- cons : List full connection/session details for all clients connected to this server. Includes information on numbers of packets received/sent, session id, operation latencies, last operation performed, etc...\n+\n+```\n+ 192.168.1.1:52163(recved=0,sent=0,sid=0xffffffffffffffff,lop=NA,est=1636454787393,to=30000,lzxid=0xffffffffffffffff,lresp=0,llat=0,minlat=0,avglat=0,maxlat=0)\n+ 192.168.1.1:52042(recved=9,sent=18,sid=0x0000000000000001,lop=List,est=1636454739887,to=30000,lcxid=0x0000000000000005,lzxid=0x0000000000000005,lresp=1636454739892,llat=0,minlat=0,avglat=0,maxlat=0)\n+```\n+\n+- crst : Reset connection/session statistics for all connections.\n+\n+```\n+Connection stats reset.\n+```\n+\n+- envi : Print details about serving environment\n+\n+```\n+Environment:\n+clickhouse.keeper.version=v21.11.1.1-prestable-7a4a0b0edef0ad6e0aa662cd3b90c3f4acf796e7\n+host.name=ZBMAC-C02D4054M.local\n+os.name=Darwin\n+os.arch=x86_64\n+os.version=19.6.0\n+cpu.count=12\n+user.name=root\n+user.home=/Users/JackyWoo/\n+user.dir=/Users/JackyWoo/project/jd/clickhouse/cmake-build-debug/programs/\n+user.tmp=/var/folders/b4/smbq5mfj7578f2jzwn602tt40000gn/T/\n+```\n+\n+\n+- dirs : Shows the total size of snapshot and log files in bytes\n+\n+```\n+snapshot_dir_size: 0\n+log_dir_size: 3875\n+```\n+\n+- isro: Tests if server is running in read-only mode. The server will respond with \"ro\" if in read-only mode or \"rw\" if not in read-only mode.\n+\n+```\n+rw\n+```\n+\n+- wchs : Lists brief information on watches for the server.\n+\n+```\n+1 connections watching 1 paths\n+Total watches:1\n+```\n+\n+- wchc : Lists detailed information on watches for the server, by session. This outputs a list of sessions(connections) with associated watches (paths). Note, depending on the number of watches this operation may be expensive (ie impact server performance), use it carefully.\n+\n+```\n+0x0000000000000001\n+    /clickhouse/task_queue/ddl\n+```\n+\n+- wchp : Lists detailed information on watches for the server, by path. This outputs a list of paths (znodes) with associated sessions. Note, depending on the number of watches this operation may be expensive (ie impact server performance), use it carefully.\n+\n+```\n+/clickhouse/task_queue/ddl\n+    0x0000000000000001\n+```\n+\n+- dump : Lists the outstanding sessions and ephemeral nodes. This only works on the leader.\n+\n+```\n+Sessions dump (2):\n+0x0000000000000001\n+0x0000000000000002\n+Sessions with Ephemerals (1):\n+0x0000000000000001\n+ /clickhouse/task_queue/ddl\n+```\n+\n ## [experimental] Migration from ZooKeeper\n \n Seamlessly migration from ZooKeeper to ClickHouse Keeper is impossible you have to stop your ZooKeeper cluster, convert data and start ClickHouse Keeper. `clickhouse-keeper-converter` tool allows converting ZooKeeper logs and snapshots to ClickHouse Keeper snapshot. It works only with ZooKeeper > 3.4. Steps for migration:\ndiff --git a/programs/keeper/Keeper.cpp b/programs/keeper/Keeper.cpp\nindex e45cd25ee8a3..4dadef911d7a 100644\n--- a/programs/keeper/Keeper.cpp\n+++ b/programs/keeper/Keeper.cpp\n@@ -20,6 +20,7 @@\n #include <Poco/Environment.h>\n #include <sys/stat.h>\n #include <pwd.h>\n+#include <Coordination/FourLetterCommand.h>\n \n #if !defined(ARCADIA_BUILD)\n #   include \"config_core.h\"\n@@ -367,6 +368,8 @@ int Keeper::main(const std::vector<std::string> & /*args*/)\n \n     /// Initialize keeper RAFT. Do nothing if no keeper_server in config.\n     global_context->initializeKeeperDispatcher(/* start_async = */false);\n+    FourLetterCommandFactory::registerCommands(*global_context->getKeeperDispatcher());\n+\n     for (const auto & listen_host : listen_hosts)\n     {\n         /// TCP Keeper\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex 27240c2341f1..e62c02995748 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -111,7 +111,8 @@\n #endif\n \n #if USE_NURAFT\n-#   include <Server/KeeperTCPHandlerFactory.h>\n+#    include <Coordination/FourLetterCommand.h>\n+#    include <Server/KeeperTCPHandlerFactory.h>\n #endif\n \n #if USE_BASE64\n@@ -1025,6 +1026,7 @@ if (ThreadFuzzer::instance().isEffective())\n         }\n         /// Initialize keeper RAFT.\n         global_context->initializeKeeperDispatcher(can_initialize_keeper_async);\n+        FourLetterCommandFactory::registerCommands(*global_context->getKeeperDispatcher());\n \n         for (const auto & listen_host : listen_hosts)\n         {\ndiff --git a/src/Common/getCurrentProcessFDCount.cpp b/src/Common/getCurrentProcessFDCount.cpp\nnew file mode 100644\nindex 000000000000..6471324b311c\n--- /dev/null\n+++ b/src/Common/getCurrentProcessFDCount.cpp\n@@ -0,0 +1,46 @@\n+#include <Common/getCurrentProcessFDCount.h>\n+#include <Common/ShellCommand.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <unistd.h>\n+#include <fmt/format.h>\n+#include <IO/ReadHelpers.h>\n+#include <filesystem>\n+\n+\n+int getCurrentProcessFDCount()\n+{\n+    namespace fs = std::filesystem;\n+    int result = -1;\n+#if defined(__linux__)  || defined(__APPLE__)\n+    using namespace DB;\n+\n+    Int32 pid = getpid();\n+\n+    auto proc_fs_path = fmt::format(\"/proc/{}/fd\", pid);\n+    if (fs::exists(proc_fs_path))\n+    {\n+        result = std::distance(fs::directory_iterator(proc_fs_path), fs::directory_iterator{});\n+    }\n+    else if (fs::exists(\"/dev/fd\"))\n+    {\n+        result = std::distance(fs::directory_iterator(\"/dev/fd\"), fs::directory_iterator{});\n+    }\n+    else\n+    {\n+        /// Then try lsof command\n+        String by_lsof = fmt::format(\"lsof -p {} | wc -l\", pid);\n+        auto command = ShellCommand::execute(by_lsof);\n+\n+        try\n+        {\n+            readIntText(result, command->out);\n+            command->wait();\n+        }\n+        catch (...)\n+        {\n+        }\n+    }\n+\n+#endif\n+    return result;\n+}\ndiff --git a/src/Common/getCurrentProcessFDCount.h b/src/Common/getCurrentProcessFDCount.h\nnew file mode 100644\nindex 000000000000..583b99f6c136\n--- /dev/null\n+++ b/src/Common/getCurrentProcessFDCount.h\n@@ -0,0 +1,5 @@\n+#pragma once\n+\n+/// Get current process file descriptor count\n+/// @return -1 os doesn't support \"lsof\" command or some error occurs.\n+int getCurrentProcessFDCount();\ndiff --git a/src/Common/getMaxFileDescriptorCount.cpp b/src/Common/getMaxFileDescriptorCount.cpp\nnew file mode 100644\nindex 000000000000..b8a2e4a09177\n--- /dev/null\n+++ b/src/Common/getMaxFileDescriptorCount.cpp\n@@ -0,0 +1,36 @@\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <IO/ReadBufferFromFile.h>\n+#include <Common/ShellCommand.h>\n+#include <Common/getMaxFileDescriptorCount.h>\n+#include <filesystem>\n+\n+int getMaxFileDescriptorCount()\n+{\n+    namespace fs = std::filesystem;\n+    int result = -1;\n+#if defined(__linux__) || defined(__APPLE__)\n+    using namespace DB;\n+\n+    if (fs::exists(\"/proc/sys/fs/file-max\"))\n+    {\n+        ReadBufferFromFile reader(\"/proc/sys/fs/file-max\");\n+        readIntText(result, reader);\n+    }\n+    else\n+    {\n+        auto command = ShellCommand::execute(\"ulimit -n\");\n+        try\n+        {\n+            readIntText(result, command->out);\n+            command->wait();\n+        }\n+        catch (...)\n+        {\n+        }\n+    }\n+\n+#endif\n+\n+    return result;\n+}\ndiff --git a/src/Common/getMaxFileDescriptorCount.h b/src/Common/getMaxFileDescriptorCount.h\nnew file mode 100644\nindex 000000000000..6cc5df0d14c4\n--- /dev/null\n+++ b/src/Common/getMaxFileDescriptorCount.h\n@@ -0,0 +1,6 @@\n+#pragma once\n+\n+/// Get process max file descriptor count\n+/// @return -1 if os does not support ulimit command or some error occurs\n+int getMaxFileDescriptorCount();\n+\ndiff --git a/src/Coordination/Changelog.h b/src/Coordination/Changelog.h\nindex edca61a883c6..e343b560aae7 100644\n--- a/src/Coordination/Changelog.h\n+++ b/src/Coordination/Changelog.h\n@@ -11,7 +11,7 @@\n namespace DB\n {\n \n-using Checksum = UInt64;\n+using Checksum = uint64_t;\n \n using LogEntryPtr = nuraft::ptr<nuraft::log_entry>;\n using LogEntries = std::vector<LogEntryPtr>;\ndiff --git a/src/Coordination/CoordinationSettings.cpp b/src/Coordination/CoordinationSettings.cpp\nindex 6201834d17d1..bb160c984021 100644\n--- a/src/Coordination/CoordinationSettings.cpp\n+++ b/src/Coordination/CoordinationSettings.cpp\n@@ -1,6 +1,10 @@\n #include <Coordination/CoordinationSettings.h>\n #include <Core/Settings.h>\n #include <base/logger_useful.h>\n+#include <filesystem>\n+#include <Coordination/Defines.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/WriteIntText.h>\n \n namespace DB\n {\n@@ -32,4 +36,177 @@ void CoordinationSettings::loadFromConfig(const String & config_elem, const Poco\n     }\n }\n \n+\n+const String KeeperConfigurationAndSettings::DEFAULT_FOUR_LETTER_WORD_CMD = \"conf,cons,crst,envi,ruok,srst,srvr,stat,wchc,wchs,dirs,mntr,isro\";\n+\n+KeeperConfigurationAndSettings::KeeperConfigurationAndSettings()\n+    : server_id(NOT_EXIST)\n+    , tcp_port(NOT_EXIST)\n+    , tcp_port_secure(NOT_EXIST)\n+    , standalone_keeper(false)\n+    , coordination_settings(std::make_shared<CoordinationSettings>())\n+{\n+}\n+\n+\n+void KeeperConfigurationAndSettings::dump(WriteBufferFromOwnString & buf) const\n+{\n+    auto write_int = [&buf](int64_t value)\n+    {\n+        writeIntText(value, buf);\n+        buf.write('\\n');\n+    };\n+\n+    auto write_bool = [&buf](bool value)\n+    {\n+        String str_val = value ? \"true\" : \"false\";\n+        writeText(str_val, buf);\n+        buf.write('\\n');\n+    };\n+\n+    writeText(\"server_id=\", buf);\n+    write_int(server_id);\n+\n+    if (tcp_port != NOT_EXIST)\n+    {\n+        writeText(\"tcp_port=\", buf);\n+        write_int(tcp_port);\n+    }\n+    if (tcp_port_secure != NOT_EXIST)\n+    {\n+        writeText(\"tcp_port_secure=\", buf);\n+        write_int(tcp_port_secure);\n+    }\n+\n+    writeText(\"four_letter_word_white_list=\", buf);\n+    writeText(four_letter_word_white_list, buf);\n+    buf.write('\\n');\n+\n+    writeText(\"log_storage_path=\", buf);\n+    writeText(log_storage_path, buf);\n+    buf.write('\\n');\n+\n+    writeText(\"snapshot_storage_path=\", buf);\n+    writeText(snapshot_storage_path, buf);\n+    buf.write('\\n');\n+\n+    /// coordination_settings\n+\n+    writeText(\"max_requests_batch_size=\", buf);\n+    write_int(coordination_settings->max_requests_batch_size);\n+    writeText(\"session_timeout_ms=\", buf);\n+    write_int(uint64_t(coordination_settings->session_timeout_ms));\n+    writeText(\"operation_timeout_ms=\", buf);\n+    write_int(uint64_t(coordination_settings->operation_timeout_ms));\n+    writeText(\"dead_session_check_period_ms=\", buf);\n+    write_int(uint64_t(coordination_settings->dead_session_check_period_ms));\n+\n+    writeText(\"heart_beat_interval_ms=\", buf);\n+    write_int(uint64_t(coordination_settings->heart_beat_interval_ms));\n+    writeText(\"election_timeout_lower_bound_ms=\", buf);\n+    write_int(uint64_t(coordination_settings->election_timeout_lower_bound_ms));\n+    writeText(\"election_timeout_upper_bound_ms=\", buf);\n+    write_int(uint64_t(coordination_settings->election_timeout_upper_bound_ms));\n+\n+    writeText(\"reserved_log_items=\", buf);\n+    write_int(coordination_settings->reserved_log_items);\n+    writeText(\"snapshot_distance=\", buf);\n+    write_int(coordination_settings->snapshot_distance);\n+\n+    writeText(\"auto_forwarding=\", buf);\n+    write_bool(coordination_settings->auto_forwarding);\n+    writeText(\"shutdown_timeout=\", buf);\n+    write_int(uint64_t(coordination_settings->shutdown_timeout));\n+    writeText(\"startup_timeout=\", buf);\n+    write_int(uint64_t(coordination_settings->startup_timeout));\n+\n+    writeText(\"raft_logs_level=\", buf);\n+    writeText(coordination_settings->raft_logs_level.toString(), buf);\n+    buf.write('\\n');\n+\n+    writeText(\"snapshots_to_keep=\", buf);\n+    write_int(coordination_settings->snapshots_to_keep);\n+    writeText(\"rotate_log_storage_interval=\", buf);\n+    write_int(coordination_settings->rotate_log_storage_interval);\n+    writeText(\"stale_log_gap=\", buf);\n+    write_int(coordination_settings->stale_log_gap);\n+    writeText(\"fresh_log_gap=\", buf);\n+    write_int(coordination_settings->fresh_log_gap);\n+\n+    writeText(\"max_requests_batch_size=\", buf);\n+    write_int(coordination_settings->max_requests_batch_size);\n+    writeText(\"quorum_reads=\", buf);\n+    write_bool(coordination_settings->quorum_reads);\n+    writeText(\"force_sync=\", buf);\n+    write_bool(coordination_settings->force_sync);\n+\n+    writeText(\"compress_logs=\", buf);\n+    write_bool(coordination_settings->compress_logs);\n+    writeText(\"compress_snapshots_with_zstd_format=\", buf);\n+    write_bool(coordination_settings->compress_snapshots_with_zstd_format);\n+    writeText(\"configuration_change_tries_count=\", buf);\n+    write_int(coordination_settings->configuration_change_tries_count);\n+}\n+\n+KeeperConfigurationAndSettingsPtr\n+KeeperConfigurationAndSettings::loadFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper_)\n+{\n+    std::shared_ptr<KeeperConfigurationAndSettings> ret = std::make_shared<KeeperConfigurationAndSettings>();\n+\n+    ret->server_id = config.getInt(\"keeper_server.server_id\");\n+    ret->standalone_keeper = standalone_keeper_;\n+\n+    if (config.has(\"keeper_server.tcp_port\"))\n+    {\n+        ret->tcp_port = config.getInt(\"keeper_server.tcp_port\");\n+    }\n+    if (config.has(\"keeper_server.tcp_port_secure\"))\n+    {\n+        ret->tcp_port_secure = config.getInt(\"keeper_server.tcp_port_secure\");\n+    }\n+    if (config.has(\"keeper_server.superdigest\"))\n+    {\n+        ret->super_digest = config.getString(\"keeper_server.superdigest\");\n+    }\n+\n+    ret->four_letter_word_white_list = config.getString(\"keeper_server.four_letter_word_white_list\", DEFAULT_FOUR_LETTER_WORD_CMD);\n+\n+    ret->log_storage_path = getLogsPathFromConfig(config, standalone_keeper_);\n+    ret->snapshot_storage_path = getSnapshotsPathFromConfig(config, standalone_keeper_);\n+\n+    ret->coordination_settings->loadFromConfig(\"keeper_server.coordination_settings\", config);\n+\n+    return ret;\n+}\n+\n+String KeeperConfigurationAndSettings::getLogsPathFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper_)\n+{\n+    /// the most specialized path\n+    if (config.has(\"keeper_server.log_storage_path\"))\n+        return config.getString(\"keeper_server.log_storage_path\");\n+\n+    if (config.has(\"keeper_server.storage_path\"))\n+        return std::filesystem::path{config.getString(\"keeper_server.storage_path\")} / \"logs\";\n+\n+    if (standalone_keeper_)\n+        return std::filesystem::path{config.getString(\"path\", KEEPER_DEFAULT_PATH)} / \"logs\";\n+    else\n+        return std::filesystem::path{config.getString(\"path\", DBMS_DEFAULT_PATH)} / \"coordination/logs\";\n+}\n+\n+String KeeperConfigurationAndSettings::getSnapshotsPathFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper_)\n+{\n+    /// the most specialized path\n+    if (config.has(\"keeper_server.snapshot_storage_path\"))\n+        return config.getString(\"keeper_server.snapshot_storage_path\");\n+\n+    if (config.has(\"keeper_server.storage_path\"))\n+        return std::filesystem::path{config.getString(\"keeper_server.storage_path\")} / \"snapshots\";\n+\n+    if (standalone_keeper_)\n+        return std::filesystem::path{config.getString(\"path\", KEEPER_DEFAULT_PATH)} / \"snapshots\";\n+    else\n+        return std::filesystem::path{config.getString(\"path\", DBMS_DEFAULT_PATH)} / \"coordination/snapshots\";\n+}\n+\n }\ndiff --git a/src/Coordination/CoordinationSettings.h b/src/Coordination/CoordinationSettings.h\nindex bec5e7f1f7a6..9cf566f95df5 100644\n--- a/src/Coordination/CoordinationSettings.h\n+++ b/src/Coordination/CoordinationSettings.h\n@@ -5,6 +5,7 @@\n #include <Core/SettingsEnums.h>\n #include <Common/ZooKeeper/ZooKeeperConstants.h>\n #include <Poco/Util/AbstractConfiguration.h>\n+#include <IO/WriteBufferFromString.h>\n \n namespace DB\n {\n@@ -51,4 +52,38 @@ struct CoordinationSettings : public BaseSettings<CoordinationSettingsTraits>\n \n using CoordinationSettingsPtr = std::shared_ptr<CoordinationSettings>;\n \n+/// Coordination settings + some other parts of keeper configuration\n+/// which are not stored in settings. Allows to dump configuration\n+/// with 4lw commands.\n+struct KeeperConfigurationAndSettings\n+{\n+    static constexpr int NOT_EXIST = -1;\n+    static const String DEFAULT_FOUR_LETTER_WORD_CMD;\n+\n+    KeeperConfigurationAndSettings();\n+    int server_id;\n+\n+    int tcp_port;\n+    int tcp_port_secure;\n+\n+    String four_letter_word_white_list;\n+\n+    String super_digest;\n+\n+    bool standalone_keeper;\n+    CoordinationSettingsPtr coordination_settings;\n+\n+    String log_storage_path;\n+    String snapshot_storage_path;\n+\n+    void dump(WriteBufferFromOwnString & buf) const;\n+    static std::shared_ptr<KeeperConfigurationAndSettings> loadFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper_);\n+\n+private:\n+    static String getLogsPathFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper_);\n+    static String getSnapshotsPathFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper_);\n+};\n+\n+using KeeperConfigurationAndSettingsPtr = std::shared_ptr<KeeperConfigurationAndSettings>;\n+\n }\ndiff --git a/src/Coordination/FourLetterCommand.cpp b/src/Coordination/FourLetterCommand.cpp\nnew file mode 100644\nindex 000000000000..294e623d8036\n--- /dev/null\n+++ b/src/Coordination/FourLetterCommand.cpp\n@@ -0,0 +1,418 @@\n+#include <Coordination/FourLetterCommand.h>\n+\n+#include <Coordination/KeeperDispatcher.h>\n+#include <Server/KeeperTCPHandler.h>\n+#include <base/logger_useful.h>\n+#include <Poco/Environment.h>\n+#include <Poco/Path.h>\n+#include <Common/getCurrentProcessFDCount.h>\n+#include <Common/getMaxFileDescriptorCount.h>\n+#include <Common/StringUtils/StringUtils.h>\n+#include <Coordination/Keeper4LWInfo.h>\n+\n+#include <unistd.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+IFourLetterCommand::IFourLetterCommand(KeeperDispatcher & keeper_dispatcher_)\n+    : keeper_dispatcher(keeper_dispatcher_)\n+{\n+}\n+\n+int32_t IFourLetterCommand::code()\n+{\n+    return toCode(name());\n+}\n+\n+String IFourLetterCommand::toName(int32_t code)\n+{\n+    int reverted_code = __builtin_bswap32(code);\n+    return String(reinterpret_cast<char *>(&reverted_code), 4);\n+}\n+\n+int32_t IFourLetterCommand::toCode(const String & name)\n+{\n+    int32_t res = *reinterpret_cast<const int32_t *>(name.data());\n+    /// keep consistent with Coordination::read method by changing big endian to little endian.\n+    return __builtin_bswap32(res);\n+}\n+\n+IFourLetterCommand::~IFourLetterCommand() = default;\n+\n+FourLetterCommandFactory & FourLetterCommandFactory::instance()\n+{\n+    static FourLetterCommandFactory factory;\n+    return factory;\n+}\n+\n+void FourLetterCommandFactory::checkInitialization() const\n+{\n+    if (!initialized)\n+        throw Exception(\"Four letter command  not initialized\", ErrorCodes::LOGICAL_ERROR);\n+}\n+\n+bool FourLetterCommandFactory::isKnown(int32_t code)\n+{\n+    checkInitialization();\n+    return commands.contains(code);\n+}\n+\n+FourLetterCommandPtr FourLetterCommandFactory::get(int32_t code)\n+{\n+    checkInitialization();\n+    return commands.at(code);\n+}\n+\n+void FourLetterCommandFactory::registerCommand(FourLetterCommandPtr & command)\n+{\n+    if (commands.contains(command->code()))\n+        throw Exception(\"Four letter command \" + command->name() + \" already registered\", ErrorCodes::LOGICAL_ERROR);\n+\n+    commands.emplace(command->code(), std::move(command));\n+}\n+\n+void FourLetterCommandFactory::registerCommands(KeeperDispatcher & keeper_dispatcher)\n+{\n+    FourLetterCommandFactory & factory = FourLetterCommandFactory::instance();\n+\n+    if (!factory.isInitialized())\n+    {\n+        FourLetterCommandPtr ruok_command = std::make_shared<RuokCommand>(keeper_dispatcher);\n+        factory.registerCommand(ruok_command);\n+\n+        FourLetterCommandPtr mntr_command = std::make_shared<MonitorCommand>(keeper_dispatcher);\n+        factory.registerCommand(mntr_command);\n+\n+        FourLetterCommandPtr conf_command = std::make_shared<ConfCommand>(keeper_dispatcher);\n+        factory.registerCommand(conf_command);\n+\n+        FourLetterCommandPtr cons_command = std::make_shared<ConsCommand>(keeper_dispatcher);\n+        factory.registerCommand(cons_command);\n+\n+        FourLetterCommandPtr brief_watch_command = std::make_shared<BriefWatchCommand>(keeper_dispatcher);\n+        factory.registerCommand(brief_watch_command);\n+\n+        FourLetterCommandPtr data_size_command = std::make_shared<DataSizeCommand>(keeper_dispatcher);\n+        factory.registerCommand(data_size_command);\n+\n+        FourLetterCommandPtr dump_command = std::make_shared<DumpCommand>(keeper_dispatcher);\n+        factory.registerCommand(dump_command);\n+\n+        FourLetterCommandPtr envi_command = std::make_shared<EnviCommand>(keeper_dispatcher);\n+        factory.registerCommand(envi_command);\n+\n+        FourLetterCommandPtr is_rad_only_command = std::make_shared<IsReadOnlyCommand>(keeper_dispatcher);\n+        factory.registerCommand(is_rad_only_command);\n+\n+        FourLetterCommandPtr rest_conn_stats_command = std::make_shared<RestConnStatsCommand>(keeper_dispatcher);\n+        factory.registerCommand(rest_conn_stats_command);\n+\n+        FourLetterCommandPtr server_stat_command = std::make_shared<ServerStatCommand>(keeper_dispatcher);\n+        factory.registerCommand(server_stat_command);\n+\n+        FourLetterCommandPtr stat_command = std::make_shared<StatCommand>(keeper_dispatcher);\n+        factory.registerCommand(stat_command);\n+\n+        FourLetterCommandPtr stat_reset_command = std::make_shared<StatResetCommand>(keeper_dispatcher);\n+        factory.registerCommand(stat_reset_command);\n+\n+        FourLetterCommandPtr watch_by_path_command = std::make_shared<WatchByPathCommand>(keeper_dispatcher);\n+        factory.registerCommand(watch_by_path_command);\n+\n+        FourLetterCommandPtr watch_command = std::make_shared<WatchCommand>(keeper_dispatcher);\n+        factory.registerCommand(watch_command);\n+\n+        factory.initializeWhiteList(keeper_dispatcher);\n+        factory.setInitialize(true);\n+    }\n+}\n+\n+bool FourLetterCommandFactory::isEnabled(int32_t code)\n+{\n+    checkInitialization();\n+    if (!white_list.empty() && *white_list.cbegin() == WHITE_LIST_ALL)\n+        return true;\n+\n+    return std::find(white_list.begin(), white_list.end(), code) != white_list.end();\n+}\n+\n+void FourLetterCommandFactory::initializeWhiteList(KeeperDispatcher & keeper_dispatcher)\n+{\n+    const auto & keeper_settings = keeper_dispatcher.getKeeperConfigurationAndSettings();\n+\n+    String list_str = keeper_settings->four_letter_word_white_list;\n+    Strings tokens;\n+    splitInto<','>(tokens, list_str);\n+\n+    for (String token: tokens)\n+    {\n+        trim(token);\n+\n+        if (token == \"*\")\n+        {\n+            white_list.clear();\n+            white_list.push_back(WHITE_LIST_ALL);\n+            return;\n+        }\n+        else\n+        {\n+            if (commands.contains(IFourLetterCommand::toCode(token)))\n+            {\n+                white_list.push_back(IFourLetterCommand::toCode(token));\n+            }\n+            else\n+            {\n+                auto * log = &Poco::Logger::get(\"FourLetterCommandFactory\");\n+                LOG_WARNING(log, \"Find invalid keeper 4lw command {} when initializing, ignore it.\", token);\n+            }\n+        }\n+    }\n+}\n+\n+String RuokCommand::run()\n+{\n+    return \"imok\";\n+}\n+\n+namespace\n+{\n+\n+void print(IFourLetterCommand::StringBuffer & buf, const String & key, const String & value)\n+{\n+    writeText(\"zk_\", buf);\n+    writeText(key, buf);\n+    writeText('\\t', buf);\n+    writeText(value, buf);\n+    writeText('\\n', buf);\n+}\n+\n+void print(IFourLetterCommand::StringBuffer & buf, const String & key, uint64_t value)\n+{\n+    print(buf, key, toString(value));\n+}\n+\n+}\n+\n+String MonitorCommand::run()\n+{\n+    KeeperConnectionStats stats = keeper_dispatcher.getKeeperConnectionStats();\n+    Keeper4LWInfo keeper_info = keeper_dispatcher.getKeeper4LWInfo();\n+\n+    if (!keeper_info.has_leader)\n+        return \"This instance is not currently serving requests\";\n+\n+    const auto & state_machine = keeper_dispatcher.getStateMachine();\n+\n+    StringBuffer ret;\n+    print(ret, \"version\", String(VERSION_DESCRIBE) + \"-\" + VERSION_GITHASH);\n+\n+    print(ret, \"avg_latency\", stats.getAvgLatency());\n+    print(ret, \"max_latency\", stats.getMaxLatency());\n+    print(ret, \"min_latency\", stats.getMinLatency());\n+    print(ret, \"packets_received\", stats.getPacketsReceived());\n+    print(ret, \"packets_sent\", stats.getPacketsSent());\n+\n+    print(ret, \"num_alive_connections\", keeper_info.alive_connections_count);\n+    print(ret, \"outstanding_requests\", keeper_info.outstanding_requests_count);\n+\n+    print(ret, \"server_state\", keeper_info.getRole());\n+\n+    print(ret, \"znode_count\", state_machine.getNodesCount());\n+    print(ret, \"watch_count\", state_machine.getTotalWatchesCount());\n+    print(ret, \"ephemerals_count\", state_machine.getTotalEphemeralNodesCount());\n+    print(ret, \"approximate_data_size\", state_machine.getApproximateDataSize());\n+\n+#if defined(__linux__) || defined(__APPLE__)\n+    print(ret, \"open_file_descriptor_count\", getCurrentProcessFDCount());\n+    print(ret, \"max_file_descriptor_count\", getMaxFileDescriptorCount());\n+#endif\n+\n+    if (keeper_info.is_leader)\n+    {\n+        print(ret, \"followers\", keeper_info.follower_count);\n+        print(ret, \"synced_followers\", keeper_info.synced_follower_count);\n+    }\n+\n+    return ret.str();\n+}\n+\n+String StatResetCommand::run()\n+{\n+    keeper_dispatcher.resetConnectionStats();\n+    return \"Server stats reset.\\n\";\n+}\n+\n+String NopCommand::run()\n+{\n+    return \"\";\n+}\n+\n+String ConfCommand::run()\n+{\n+    StringBuffer buf;\n+    keeper_dispatcher.getKeeperConfigurationAndSettings()->dump(buf);\n+    return buf.str();\n+}\n+\n+String ConsCommand::run()\n+{\n+    StringBuffer buf;\n+    KeeperTCPHandler::dumpConnections(buf, false);\n+    return buf.str();\n+}\n+\n+String RestConnStatsCommand::run()\n+{\n+    KeeperTCPHandler::resetConnsStats();\n+    return \"Connection stats reset.\\n\";\n+}\n+\n+String ServerStatCommand::run()\n+{\n+    StringBuffer buf;\n+\n+    auto write = [&buf](const String & key, const String & value)\n+    {\n+        writeText(key, buf);\n+        writeText(\": \", buf);\n+        writeText(value, buf);\n+        writeText('\\n', buf);\n+    };\n+\n+    KeeperConnectionStats stats = keeper_dispatcher.getKeeperConnectionStats();\n+    Keeper4LWInfo keeper_info = keeper_dispatcher.getKeeper4LWInfo();\n+\n+    write(\"ClickHouse Keeper version\", String(VERSION_DESCRIBE) + \"-\" + VERSION_GITHASH);\n+\n+    StringBuffer latency;\n+    latency << stats.getMinLatency() << \"/\" << stats.getAvgLatency() << \"/\" << stats.getMaxLatency();\n+    write(\"Latency min/avg/max\", latency.str());\n+\n+    write(\"Received\", toString(stats.getPacketsReceived()));\n+    write(\"Sent \", toString(stats.getPacketsSent()));\n+    write(\"Connections\", toString(keeper_info.alive_connections_count));\n+    write(\"Outstanding\", toString(keeper_info.outstanding_requests_count));\n+    write(\"Zxid\", toString(keeper_info.last_zxid));\n+    write(\"Mode\", keeper_info.getRole());\n+    write(\"Node count\", toString(keeper_info.total_nodes_count));\n+\n+    return buf.str();\n+}\n+\n+String StatCommand::run()\n+{\n+    StringBuffer buf;\n+\n+    auto write = [&buf] (const String & key, const String & value) { buf << key << \": \" << value << '\\n'; };\n+\n+    KeeperConnectionStats stats = keeper_dispatcher.getKeeperConnectionStats();\n+    Keeper4LWInfo keeper_info = keeper_dispatcher.getKeeper4LWInfo();\n+\n+    write(\"ClickHouse Keeper version\", String(VERSION_DESCRIBE) + \"-\" + VERSION_GITHASH);\n+\n+    buf << \"Clients:\\n\";\n+    KeeperTCPHandler::dumpConnections(buf, true);\n+    buf << '\\n';\n+\n+    StringBuffer latency;\n+    latency << stats.getMinLatency() << \"/\" << stats.getAvgLatency() << \"/\" << stats.getMaxLatency();\n+    write(\"Latency min/avg/max\", latency.str());\n+\n+    write(\"Received\", toString(stats.getPacketsReceived()));\n+    write(\"Sent \", toString(stats.getPacketsSent()));\n+    write(\"Connections\", toString(keeper_info.alive_connections_count));\n+    write(\"Outstanding\", toString(keeper_info.outstanding_requests_count));\n+    write(\"Zxid\", toString(keeper_info.last_zxid));\n+    write(\"Mode\", keeper_info.getRole());\n+    write(\"Node count\", toString(keeper_info.total_nodes_count));\n+\n+    return buf.str();\n+}\n+\n+String BriefWatchCommand::run()\n+{\n+    StringBuffer buf;\n+    const auto & state_machine = keeper_dispatcher.getStateMachine();\n+    buf << state_machine.getSessionsWithWatchesCount() << \" connections watching \"\n+        << state_machine.getWatchedPathsCount() << \" paths\\n\";\n+    buf << \"Total watches:\" << state_machine.getTotalWatchesCount() << \"\\n\";\n+    return buf.str();\n+}\n+\n+String WatchCommand::run()\n+{\n+    StringBuffer buf;\n+    const auto & state_machine = keeper_dispatcher.getStateMachine();\n+    state_machine.dumpWatches(buf);\n+    return buf.str();\n+}\n+\n+String WatchByPathCommand::run()\n+{\n+    StringBuffer buf;\n+    const auto & state_machine = keeper_dispatcher.getStateMachine();\n+    state_machine.dumpWatchesByPath(buf);\n+    return buf.str();\n+}\n+\n+String DataSizeCommand::run()\n+{\n+    StringBuffer buf;\n+    buf << \"snapshot_dir_size: \" << keeper_dispatcher.getSnapDirSize() << '\\n';\n+    buf << \"log_dir_size: \" << keeper_dispatcher.getLogDirSize() << '\\n';\n+    return buf.str();\n+}\n+\n+String DumpCommand::run()\n+{\n+    StringBuffer buf;\n+    const auto & state_machine = keeper_dispatcher.getStateMachine();\n+    state_machine.dumpSessionsAndEphemerals(buf);\n+    return buf.str();\n+}\n+\n+String EnviCommand::run()\n+{\n+    using Poco::Environment;\n+    using Poco::Path;\n+\n+    StringBuffer buf;\n+    buf << \"Environment:\\n\";\n+    buf << \"clickhouse.keeper.version=\" << (String(VERSION_DESCRIBE) + \"-\" + VERSION_GITHASH) << '\\n';\n+\n+    buf << \"host.name=\" << Environment::nodeName() << '\\n';\n+    buf << \"os.name=\" << Environment::osDisplayName() << '\\n';\n+    buf << \"os.arch=\" << Environment::osArchitecture() << '\\n';\n+    buf << \"os.version=\" << Environment::osVersion() << '\\n';\n+    buf << \"cpu.count=\" << Environment::processorCount() << '\\n';\n+\n+    String os_user;\n+    os_user.resize(256, '\\0');\n+    if (0 == getlogin_r(os_user.data(), os_user.size() - 1))\n+        os_user.resize(strlen(os_user.c_str()));\n+    else\n+        os_user.clear();    /// Don't mind if we cannot determine user login.\n+\n+    buf << \"user.name=\" << os_user << '\\n';\n+\n+    buf << \"user.home=\" << Path::home() << '\\n';\n+    buf << \"user.dir=\" << Path::current() << '\\n';\n+    buf << \"user.tmp=\" << Path::temp() << '\\n';\n+\n+    return buf.str();\n+}\n+\n+String IsReadOnlyCommand::run()\n+{\n+    if (keeper_dispatcher.isObserver())\n+        return \"ro\";\n+    else\n+        return \"rw\";\n+}\n+\n+}\ndiff --git a/src/Coordination/FourLetterCommand.h b/src/Coordination/FourLetterCommand.h\nnew file mode 100644\nindex 000000000000..7f89bb1a33ef\n--- /dev/null\n+++ b/src/Coordination/FourLetterCommand.h\n@@ -0,0 +1,307 @@\n+#pragma once\n+\n+#include <sstream>\n+#include <string>\n+#include <unordered_map>\n+\n+#include <Coordination/KeeperDispatcher.h>\n+#include <IO/WriteBufferFromString.h>\n+\n+#include <Common/config_version.h>\n+\n+namespace DB\n+{\n+struct IFourLetterCommand;\n+using FourLetterCommandPtr = std::shared_ptr<DB::IFourLetterCommand>;\n+\n+/// Just like zookeeper Four Letter Words commands, CH Keeper responds to a small set of commands.\n+/// Each command is composed of four letters, these commands are useful to monitor and issue system problems.\n+/// The feature is based on Zookeeper 3.5.9, details is in https://zookeeper.apache.org/doc/r3.5.9/zookeeperAdmin.html#sc_zkCommands.\n+struct IFourLetterCommand\n+{\n+public:\n+    using StringBuffer = DB::WriteBufferFromOwnString;\n+    explicit IFourLetterCommand(KeeperDispatcher & keeper_dispatcher_);\n+\n+    virtual String name() = 0;\n+    virtual String run() = 0;\n+\n+    virtual ~IFourLetterCommand();\n+    int32_t code();\n+\n+    static String toName(int32_t code);\n+    static inline int32_t toCode(const String & name);\n+\n+protected:\n+    KeeperDispatcher & keeper_dispatcher;\n+};\n+\n+struct FourLetterCommandFactory : private boost::noncopyable\n+{\n+public:\n+    using Commands = std::unordered_map<int32_t, FourLetterCommandPtr>;\n+    using WhiteList = std::vector<int32_t>;\n+\n+    ///represent '*' which is used in white list\n+    static constexpr int32_t WHITE_LIST_ALL = 0;\n+\n+    bool isKnown(int32_t code);\n+    bool isEnabled(int32_t code);\n+\n+    FourLetterCommandPtr get(int32_t code);\n+\n+    /// There is no need to make it thread safe, because registration is no initialization and get is after startup.\n+    void registerCommand(FourLetterCommandPtr & command);\n+    void initializeWhiteList(KeeperDispatcher & keeper_dispatcher);\n+\n+    void checkInitialization() const;\n+    bool isInitialized() const { return initialized; }\n+    void setInitialize(bool flag) { initialized = flag; }\n+\n+    static FourLetterCommandFactory & instance();\n+    static void registerCommands(KeeperDispatcher & keeper_dispatcher);\n+\n+private:\n+    std::atomic<bool> initialized = false;\n+    Commands commands;\n+    WhiteList white_list;\n+};\n+\n+/**Tests if server is running in a non-error state. The server will respond with imok if it is running.\n+ * Otherwise it will not respond at all.\n+ *\n+ * A response of \"imok\" does not necessarily indicate that the server has joined the quorum,\n+ * just that the server process is active and bound to the specified client port.\n+ * Use \"stat\" for details on state wrt quorum and client connection information.\n+ */\n+struct RuokCommand : public IFourLetterCommand\n+{\n+    explicit RuokCommand(KeeperDispatcher & keeper_dispatcher_) : IFourLetterCommand(keeper_dispatcher_) { }\n+\n+    String name() override { return \"ruok\"; }\n+    String run() override;\n+    ~RuokCommand() override = default;\n+};\n+\n+/**\n+ * Outputs a list of variables that could be used for monitoring the health of the cluster.\n+ *\n+ * echo mntr | nc localhost 2181\n+ * zk_version  3.5.9\n+ * zk_avg_latency  0\n+ * zk_max_latency  0\n+ * zk_min_latency  0\n+ * zk_packets_received 70\n+ * zk_packets_sent 69\n+ * zk_outstanding_requests 0\n+ * zk_server_state leader\n+ * zk_znode_count   4\n+ * zk_watch_count  0\n+ * zk_ephemerals_count 0\n+ * zk_approximate_data_size    27\n+ * zk_open_file_descriptor_count 23    - only available on Unix platforms\n+ * zk_max_file_descriptor_count 1024   - only available on Unix platforms\n+ * zk_followers 2                      - only exposed by the Leader\n+ * zk_synced_followers  2              - only exposed by the Leader\n+ * zk_pending_syncs 0                  - only exposed by the Leader\n+ */\n+struct MonitorCommand : public IFourLetterCommand\n+{\n+    explicit MonitorCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"mntr\"; }\n+    String run() override;\n+    ~MonitorCommand() override = default;\n+};\n+\n+struct StatResetCommand : public IFourLetterCommand\n+{\n+    explicit StatResetCommand(KeeperDispatcher & keeper_dispatcher_) :\n+        IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"srst\"; }\n+    String run() override;\n+    ~StatResetCommand() override = default;\n+};\n+\n+/// A command that does not do anything except reply to client with predefined message.\n+///It is used to inform clients who execute none white listed four letter word commands.\n+struct NopCommand : public IFourLetterCommand\n+{\n+    explicit NopCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"nopc\"; }\n+    String run() override;\n+    ~NopCommand() override = default;\n+};\n+\n+struct ConfCommand : public IFourLetterCommand\n+{\n+    explicit ConfCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"conf\"; }\n+    String run() override;\n+    ~ConfCommand() override = default;\n+};\n+\n+/// List full connection/session details for all clients connected to this server.\n+/// Includes information on numbers of packets received/sent, session id, operation latencies, last operation performed, etc...\n+struct ConsCommand : public IFourLetterCommand\n+{\n+    explicit ConsCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"cons\"; }\n+    String run() override;\n+    ~ConsCommand() override = default;\n+};\n+\n+/// Reset connection/session statistics for all connections.\n+struct RestConnStatsCommand : public IFourLetterCommand\n+{\n+    explicit RestConnStatsCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"crst\"; }\n+    String run() override;\n+    ~RestConnStatsCommand() override = default;\n+};\n+\n+/// Lists full details for the server.\n+struct ServerStatCommand : public IFourLetterCommand\n+{\n+    explicit ServerStatCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"srvr\"; }\n+    String run() override;\n+    ~ServerStatCommand() override = default;\n+};\n+\n+/// Lists brief details for the server and connected clients.\n+struct StatCommand : public IFourLetterCommand\n+{\n+    explicit StatCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"stat\"; }\n+    String run() override;\n+    ~StatCommand() override = default;\n+};\n+\n+/// Lists brief information on watches for the server.\n+struct BriefWatchCommand : public IFourLetterCommand\n+{\n+    explicit BriefWatchCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"wchs\"; }\n+    String run() override;\n+    ~BriefWatchCommand() override = default;\n+};\n+\n+/// Lists detailed information on watches for the server, by session.\n+/// This outputs a list of sessions(connections) with associated watches (paths).\n+/// Note, depending on the number of watches this operation may be expensive (ie impact server performance), use it carefully.\n+struct WatchCommand : public IFourLetterCommand\n+{\n+    explicit WatchCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"wchc\"; }\n+    String run() override;\n+    ~WatchCommand() override = default;\n+};\n+\n+/// Lists detailed information on watches for the server, by path.\n+/// This outputs a list of paths (znodes) with associated sessions.\n+/// Note, depending on the number of watches this operation may be expensive (ie impact server performance), use it carefully.\n+struct WatchByPathCommand : public IFourLetterCommand\n+{\n+    explicit WatchByPathCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"wchp\"; }\n+    String run() override;\n+    ~WatchByPathCommand() override = default;\n+};\n+\n+/// Lists the outstanding sessions and ephemeral nodes. This only works on the leader.\n+struct DumpCommand : public IFourLetterCommand\n+{\n+    explicit DumpCommand(KeeperDispatcher & keeper_dispatcher_):\n+        IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"dump\"; }\n+    String run() override;\n+    ~DumpCommand() override = default;\n+};\n+\n+/// Print details about serving environment\n+struct EnviCommand : public IFourLetterCommand\n+{\n+    explicit EnviCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"envi\"; }\n+    String run() override;\n+    ~EnviCommand() override = default;\n+};\n+\n+/// Shows the total size of snapshot and log files in bytes\n+struct DataSizeCommand : public IFourLetterCommand\n+{\n+    explicit DataSizeCommand(KeeperDispatcher & keeper_dispatcher_):\n+        IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"dirs\"; }\n+    String run() override;\n+    ~DataSizeCommand() override = default;\n+};\n+\n+/// Tests if server is running in read-only mode.\n+/// The server will respond with \"ro\" if in read-only mode or \"rw\" if not in read-only mode.\n+struct IsReadOnlyCommand : public IFourLetterCommand\n+{\n+    explicit IsReadOnlyCommand(KeeperDispatcher & keeper_dispatcher_)\n+        : IFourLetterCommand(keeper_dispatcher_)\n+    {\n+    }\n+\n+    String name() override { return \"isro\"; }\n+    String run() override;\n+    ~IsReadOnlyCommand() override = default;\n+};\n+\n+}\ndiff --git a/src/Coordination/Keeper4LWInfo.h b/src/Coordination/Keeper4LWInfo.h\nnew file mode 100644\nindex 000000000000..1c461582a8ca\n--- /dev/null\n+++ b/src/Coordination/Keeper4LWInfo.h\n@@ -0,0 +1,47 @@\n+#pragma once\n+\n+#include <string>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+/// Keeper server related information for different 4lw commands\n+struct Keeper4LWInfo\n+{\n+    bool is_leader;\n+    bool is_observer;\n+    bool is_follower;\n+    bool is_standalone;\n+\n+    bool has_leader;\n+\n+    uint64_t alive_connections_count;\n+    uint64_t outstanding_requests_count;\n+\n+    uint64_t follower_count;\n+    uint64_t synced_follower_count;\n+\n+    uint64_t total_nodes_count;\n+    int64_t last_zxid;\n+\n+    String getRole() const\n+    {\n+        if (is_standalone)\n+            return \"standalone\";\n+        if (is_leader)\n+            return \"leader\";\n+        if (is_observer)\n+            return \"observer\";\n+        if (is_follower)\n+            return \"follower\";\n+\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"RAFT server has undefined state state, it's a bug\");\n+    }\n+};\n+\n+}\ndiff --git a/src/Coordination/KeeperConnectionStats.cpp b/src/Coordination/KeeperConnectionStats.cpp\nnew file mode 100644\nindex 000000000000..f3938b395b59\n--- /dev/null\n+++ b/src/Coordination/KeeperConnectionStats.cpp\n@@ -0,0 +1,85 @@\n+#include <Coordination/KeeperConnectionStats.h>\n+\n+namespace DB\n+{\n+\n+uint64_t KeeperConnectionStats::getMinLatency() const\n+{\n+    return min_latency;\n+}\n+\n+uint64_t KeeperConnectionStats::getMaxLatency() const\n+{\n+    return max_latency;\n+}\n+\n+uint64_t KeeperConnectionStats::getAvgLatency() const\n+{\n+    if (count != 0)\n+        return total_latency / count;\n+    return 0;\n+}\n+\n+uint64_t KeeperConnectionStats::getLastLatency() const\n+{\n+    return last_latency;\n+}\n+\n+uint64_t KeeperConnectionStats::getPacketsReceived() const\n+{\n+    return packets_received;\n+}\n+\n+uint64_t KeeperConnectionStats::getPacketsSent() const\n+{\n+    return packets_sent;\n+}\n+\n+void KeeperConnectionStats::incrementPacketsReceived()\n+{\n+    packets_received++;\n+}\n+\n+void KeeperConnectionStats::incrementPacketsSent()\n+{\n+    packets_sent++;\n+}\n+\n+void KeeperConnectionStats::updateLatency(uint64_t latency_ms)\n+{\n+    last_latency = latency_ms;\n+    total_latency += (latency_ms);\n+    count++;\n+\n+    if (latency_ms < min_latency)\n+    {\n+        min_latency = latency_ms;\n+    }\n+\n+    if (latency_ms > max_latency)\n+    {\n+        max_latency = latency_ms;\n+    }\n+}\n+\n+void KeeperConnectionStats::reset()\n+{\n+    resetLatency();\n+    resetRequestCounters();\n+}\n+\n+void KeeperConnectionStats::resetLatency()\n+{\n+    total_latency = 0;\n+    count = 0;\n+    max_latency = 0;\n+    min_latency = 0;\n+}\n+\n+void KeeperConnectionStats::resetRequestCounters()\n+{\n+    packets_received = 0;\n+    packets_sent = 0;\n+}\n+\n+}\ndiff --git a/src/Coordination/KeeperConnectionStats.h b/src/Coordination/KeeperConnectionStats.h\nnew file mode 100644\nindex 000000000000..3cd881d553b5\n--- /dev/null\n+++ b/src/Coordination/KeeperConnectionStats.h\n@@ -0,0 +1,52 @@\n+#pragma once\n+\n+#include <base/types.h>\n+#include <memory>\n+#include <cstdint>\n+\n+namespace DB\n+{\n+\n+/// Request statistics for connection or dispatcher\n+class KeeperConnectionStats\n+{\n+public:\n+    KeeperConnectionStats() = default;\n+\n+    uint64_t getMinLatency() const;\n+    uint64_t getMaxLatency() const;\n+\n+    uint64_t getAvgLatency() const;\n+    uint64_t getLastLatency() const;\n+\n+    uint64_t getPacketsReceived() const;\n+    uint64_t getPacketsSent() const;\n+\n+    void incrementPacketsReceived();\n+    void incrementPacketsSent();\n+\n+    void updateLatency(uint64_t latency_ms);\n+    void reset();\n+\n+private:\n+    void resetLatency();\n+    void resetRequestCounters();\n+\n+    /// all response with watch response included\n+    uint64_t packets_sent = 0;\n+    /// All user requests\n+    uint64_t packets_received = 0;\n+\n+    /// For consistent with zookeeper measured by millisecond,\n+    /// otherwise maybe microsecond is better\n+    uint64_t total_latency = 0;\n+    uint64_t max_latency = 0;\n+    uint64_t min_latency = 0;\n+\n+    /// last operation latency\n+    uint64_t last_latency = 0;\n+\n+    uint64_t count = 0;\n+};\n+\n+}\ndiff --git a/src/Coordination/KeeperDispatcher.cpp b/src/Coordination/KeeperDispatcher.cpp\nindex e6fe1a9834ae..438e337b64fa 100644\n--- a/src/Coordination/KeeperDispatcher.cpp\n+++ b/src/Coordination/KeeperDispatcher.cpp\n@@ -3,6 +3,12 @@\n #include <Common/ZooKeeper/KeeperException.h>\n #include <future>\n #include <chrono>\n+#include <Poco/Path.h>\n+#include <Common/hex.h>\n+#include <filesystem>\n+#include <Common/checkStackSize.h>\n+\n+namespace fs = std::filesystem;\n \n namespace DB\n {\n@@ -14,9 +20,10 @@ namespace ErrorCodes\n     extern const int SYSTEM_ERROR;\n }\n \n+\n KeeperDispatcher::KeeperDispatcher()\n-    : coordination_settings(std::make_shared<CoordinationSettings>())\n-    , responses_queue(std::numeric_limits<size_t>::max())\n+    : responses_queue(std::numeric_limits<size_t>::max())\n+    , configuration_and_settings(std::make_shared<KeeperConfigurationAndSettings>())\n     , log(&Poco::Logger::get(\"KeeperDispatcher\"))\n {\n }\n@@ -36,7 +43,8 @@ void KeeperDispatcher::requestThread()\n     {\n         KeeperStorage::RequestForSession request;\n \n-        UInt64 max_wait = UInt64(coordination_settings->operation_timeout_ms.totalMilliseconds());\n+        auto coordination_settings = configuration_and_settings->coordination_settings;\n+        uint64_t max_wait = coordination_settings->operation_timeout_ms.totalMilliseconds();\n         uint64_t max_batch_size = coordination_settings->max_requests_batch_size;\n \n         /// The code below do a very simple thing: batch all write (quorum) requests into vector until\n@@ -141,7 +149,7 @@ void KeeperDispatcher::responseThread()\n     {\n         KeeperStorage::ResponseForSession response_for_session;\n \n-        UInt64 max_wait = UInt64(coordination_settings->operation_timeout_ms.totalMilliseconds());\n+        uint64_t max_wait = configuration_and_settings->coordination_settings->operation_timeout_ms.totalMilliseconds();\n \n         if (responses_queue.tryPop(response_for_session, max_wait))\n         {\n@@ -245,28 +253,25 @@ bool KeeperDispatcher::putRequest(const Coordination::ZooKeeperRequestPtr & requ\n         if (!requests_queue->push(std::move(request_info)))\n             throw Exception(\"Cannot push request to queue\", ErrorCodes::SYSTEM_ERROR);\n     }\n-    else if (!requests_queue->tryPush(std::move(request_info), coordination_settings->operation_timeout_ms.totalMilliseconds()))\n+    else if (!requests_queue->tryPush(std::move(request_info), configuration_and_settings->coordination_settings->operation_timeout_ms.totalMilliseconds()))\n     {\n         throw Exception(\"Cannot push request to queue within operation timeout\", ErrorCodes::TIMEOUT_EXCEEDED);\n     }\n-\n     return true;\n }\n \n void KeeperDispatcher::initialize(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper, bool start_async)\n {\n     LOG_DEBUG(log, \"Initializing storage dispatcher\");\n-    int myid = config.getInt(\"keeper_server.server_id\");\n \n-    coordination_settings->loadFromConfig(\"keeper_server.coordination_settings\", config);\n-    requests_queue = std::make_unique<RequestsQueue>(coordination_settings->max_requests_batch_size);\n+    configuration_and_settings = KeeperConfigurationAndSettings::loadFromConfig(config, standalone_keeper);\n+    requests_queue = std::make_unique<RequestsQueue>(configuration_and_settings->coordination_settings->max_requests_batch_size);\n \n     request_thread = ThreadFromGlobalPool([this] { requestThread(); });\n     responses_thread = ThreadFromGlobalPool([this] { responseThread(); });\n     snapshot_thread = ThreadFromGlobalPool([this] { snapshotThread(); });\n \n-    server = std::make_unique<KeeperServer>(\n-        myid, coordination_settings, config, responses_queue, snapshots_queue, standalone_keeper);\n+    server = std::make_unique<KeeperServer>(configuration_and_settings, config, responses_queue, snapshots_queue);\n \n     try\n     {\n@@ -413,7 +418,8 @@ void KeeperDispatcher::sessionCleanerTask()\n             tryLogCurrentException(__PRETTY_FUNCTION__);\n         }\n \n-        std::this_thread::sleep_for(std::chrono::milliseconds(coordination_settings->dead_session_check_period_ms.totalMilliseconds()));\n+        auto time_to_sleep = configuration_and_settings->coordination_settings->dead_session_check_period_ms.totalMilliseconds();\n+        std::this_thread::sleep_for(std::chrono::milliseconds(time_to_sleep));\n     }\n }\n \n@@ -580,4 +586,67 @@ void KeeperDispatcher::updateConfiguration(const Poco::Util::AbstractConfigurati\n     }\n }\n \n+void KeeperDispatcher::updateKeeperStatLatency(uint64_t process_time_ms)\n+{\n+    std::lock_guard lock(keeper_stats_mutex);\n+    keeper_stats.updateLatency(process_time_ms);\n+}\n+\n+static uint64_t getDirSize(const fs::path & dir)\n+{\n+    checkStackSize();\n+    if (!fs::exists(dir))\n+        return 0;\n+\n+    fs::directory_iterator it(dir);\n+    fs::directory_iterator end;\n+\n+    uint64_t size{0};\n+    while (it != end)\n+    {\n+        if (it->is_regular_file())\n+            size += fs::file_size(*it);\n+        else\n+            size += getDirSize(it->path());\n+        ++it;\n+    }\n+    return size;\n+}\n+\n+uint64_t KeeperDispatcher::getLogDirSize() const\n+{\n+    return getDirSize(configuration_and_settings->log_storage_path);\n+}\n+\n+uint64_t KeeperDispatcher::getSnapDirSize() const\n+{\n+    return getDirSize(configuration_and_settings->snapshot_storage_path);\n+}\n+\n+Keeper4LWInfo KeeperDispatcher::getKeeper4LWInfo() const\n+{\n+    Keeper4LWInfo result;\n+    result.is_follower = server->isFollower();\n+    result.is_standalone = !result.is_follower && server->getFollowerCount() == 0;\n+    result.is_leader = isLeader();\n+    result.is_observer = server->isObserver();\n+    result.has_leader = hasLeader();\n+    {\n+        std::lock_guard lock(push_request_mutex);\n+        result.outstanding_requests_count = requests_queue->size();\n+    }\n+    {\n+        std::lock_guard lock(session_to_response_callback_mutex);\n+        result.alive_connections_count = session_to_response_callback.size();\n+    }\n+    if (result.is_leader)\n+    {\n+        result.follower_count = server->getFollowerCount();\n+        result.synced_follower_count = server->getSyncedFollowerCount();\n+    }\n+    result.total_nodes_count = server->getKeeperStateMachine()->getNodesCount();\n+    result.last_zxid = server->getKeeperStateMachine()->getLastProcessedZxid();\n+    return result;\n+}\n+\n }\ndiff --git a/src/Coordination/KeeperDispatcher.h b/src/Coordination/KeeperDispatcher.h\nindex 60f69cfae9f3..646fab5d80f6 100644\n--- a/src/Coordination/KeeperDispatcher.h\n+++ b/src/Coordination/KeeperDispatcher.h\n@@ -13,22 +13,20 @@\n #include <functional>\n #include <Coordination/KeeperServer.h>\n #include <Coordination/CoordinationSettings.h>\n-\n+#include <Coordination/Keeper4LWInfo.h>\n+#include <Coordination/KeeperConnectionStats.h>\n \n namespace DB\n {\n-\n using ZooKeeperResponseCallback = std::function<void(const Coordination::ZooKeeperResponsePtr & response)>;\n \n /// Highlevel wrapper for ClickHouse Keeper.\n /// Process user requests via consensus and return responses.\n class KeeperDispatcher\n {\n-\n private:\n-    std::mutex push_request_mutex;\n+    mutable std::mutex push_request_mutex;\n \n-    CoordinationSettingsPtr coordination_settings;\n     using RequestsQueue = ConcurrentBoundedQueue<KeeperStorage::RequestForSession>;\n     using SessionToResponseCallback = std::unordered_map<int64_t, ZooKeeperResponseCallback>;\n     using UpdateConfigurationQueue = ConcurrentBoundedQueue<ConfigUpdateAction>;\n@@ -43,7 +41,7 @@ class KeeperDispatcher\n \n     std::atomic<bool> shutdown_called{false};\n \n-    std::mutex session_to_response_callback_mutex;\n+    mutable std::mutex session_to_response_callback_mutex;\n     /// These two maps looks similar, but serves different purposes.\n     /// The first map is subscription map for normal responses like\n     /// (get, set, list, etc.). Dispatcher determines callback for each response\n@@ -70,6 +68,11 @@ class KeeperDispatcher\n     /// RAFT wrapper.\n     std::unique_ptr<KeeperServer> server;\n \n+    mutable std::mutex keeper_stats_mutex;\n+    KeeperConnectionStats keeper_stats;\n+\n+    KeeperConfigurationAndSettingsPtr configuration_and_settings;\n+\n     Poco::Logger * log;\n \n     /// Counter for new session_id requests.\n@@ -123,6 +126,18 @@ class KeeperDispatcher\n     /// Put request to ClickHouse Keeper\n     bool putRequest(const Coordination::ZooKeeperRequestPtr & request, int64_t session_id);\n \n+    /// Get new session ID\n+    int64_t getSessionID(int64_t session_timeout_ms);\n+\n+    /// Register session and subscribe for responses with callback\n+    void registerSession(int64_t session_id, ZooKeeperResponseCallback callback);\n+\n+    /// Call if we don't need any responses for this session no more (session was expired)\n+    void finishSession(int64_t session_id);\n+\n+    /// Invoked when a request completes.\n+    void updateKeeperStatLatency(uint64_t process_time_ms);\n+\n     /// Are we leader\n     bool isLeader() const\n     {\n@@ -134,14 +149,51 @@ class KeeperDispatcher\n         return server->isLeaderAlive();\n     }\n \n-    /// Get new session ID\n-    int64_t getSessionID(int64_t session_timeout_ms);\n+    bool isObserver() const\n+    {\n+        return server->isObserver();\n+    }\n \n-    /// Register session and subscribe for responses with callback\n-    void registerSession(int64_t session_id, ZooKeeperResponseCallback callback);\n+    uint64_t getLogDirSize() const;\n \n-    /// Call if we don't need any responses for this session no more (session was expired)\n-    void finishSession(int64_t session_id);\n+    uint64_t getSnapDirSize() const;\n+\n+    /// Request statistics such as qps, latency etc.\n+    KeeperConnectionStats getKeeperConnectionStats() const\n+    {\n+        std::lock_guard lock(keeper_stats_mutex);\n+        return keeper_stats;\n+    }\n+\n+    Keeper4LWInfo getKeeper4LWInfo() const;\n+\n+    const KeeperStateMachine & getStateMachine() const\n+    {\n+        return *server->getKeeperStateMachine();\n+    }\n+\n+    const KeeperConfigurationAndSettingsPtr & getKeeperConfigurationAndSettings() const\n+    {\n+        return configuration_and_settings;\n+    }\n+\n+    void incrementPacketsSent()\n+    {\n+        std::lock_guard lock(keeper_stats_mutex);\n+        keeper_stats.incrementPacketsSent();\n+    }\n+\n+    void incrementPacketsReceived()\n+    {\n+        std::lock_guard lock(keeper_stats_mutex);\n+        keeper_stats.incrementPacketsReceived();\n+    }\n+\n+    void resetConnectionStats()\n+    {\n+        std::lock_guard lock(keeper_stats_mutex);\n+        keeper_stats.reset();\n+    }\n };\n \n }\ndiff --git a/src/Coordination/KeeperServer.cpp b/src/Coordination/KeeperServer.cpp\nindex f4787a66d7d4..171fa2986eb4 100644\n--- a/src/Coordination/KeeperServer.cpp\n+++ b/src/Coordination/KeeperServer.cpp\n@@ -61,27 +61,12 @@ void setSSLParams(nuraft::asio_service::options & asio_opts)\n }\n #endif\n \n-std::string getSnapshotsPathFromConfig(const Poco::Util::AbstractConfiguration & config, bool standalone_keeper)\n-{\n-    /// the most specialized path\n-    if (config.has(\"keeper_server.snapshot_storage_path\"))\n-        return config.getString(\"keeper_server.snapshot_storage_path\");\n-\n-    if (config.has(\"keeper_server.storage_path\"))\n-        return std::filesystem::path{config.getString(\"keeper_server.storage_path\")} / \"snapshots\";\n-\n-    if (standalone_keeper)\n-        return std::filesystem::path{config.getString(\"path\", KEEPER_DEFAULT_PATH)} / \"snapshots\";\n-    else\n-        return std::filesystem::path{config.getString(\"path\", DBMS_DEFAULT_PATH)} / \"coordination/snapshots\";\n-}\n \n-std::string checkAndGetSuperdigest(const Poco::Util::AbstractConfiguration & config)\n+std::string checkAndGetSuperdigest(const String & user_and_digest)\n {\n-    if (!config.has(\"keeper_server.superdigest\"))\n+    if (user_and_digest.empty())\n         return \"\";\n \n-    auto user_and_digest = config.getString(\"keeper_server.superdigest\");\n     std::vector<std::string> scheme_and_id;\n     boost::split(scheme_and_id, user_and_digest, [](char c) { return c == ':'; });\n     if (scheme_and_id.size() != 2 || scheme_and_id[0] != \"super\")\n@@ -93,20 +78,18 @@ std::string checkAndGetSuperdigest(const Poco::Util::AbstractConfiguration & con\n }\n \n KeeperServer::KeeperServer(\n-    int server_id_,\n-    const CoordinationSettingsPtr & coordination_settings_,\n+    const KeeperConfigurationAndSettingsPtr & configuration_and_settings_,\n     const Poco::Util::AbstractConfiguration & config,\n     ResponsesQueue & responses_queue_,\n-    SnapshotsQueue & snapshots_queue_,\n-    bool standalone_keeper)\n-    : server_id(server_id_)\n-    , coordination_settings(coordination_settings_)\n+    SnapshotsQueue & snapshots_queue_)\n+    : server_id(configuration_and_settings_->server_id)\n+    , coordination_settings(configuration_and_settings_->coordination_settings)\n     , state_machine(nuraft::cs_new<KeeperStateMachine>(\n                         responses_queue_, snapshots_queue_,\n-                        getSnapshotsPathFromConfig(config, standalone_keeper),\n+                        configuration_and_settings_->snapshot_storage_path,\n                         coordination_settings,\n-                        checkAndGetSuperdigest(config)))\n-    , state_manager(nuraft::cs_new<KeeperStateManager>(server_id, \"keeper_server\", config, coordination_settings, standalone_keeper))\n+                        checkAndGetSuperdigest(configuration_and_settings_->super_digest)))\n+    , state_manager(nuraft::cs_new<KeeperStateManager>(server_id, \"keeper_server\", configuration_and_settings_->log_storage_path, config, coordination_settings))\n     , log(&Poco::Logger::get(\"KeeperServer\"))\n {\n     if (coordination_settings->quorum_reads)\n@@ -302,11 +285,46 @@ bool KeeperServer::isLeader() const\n     return raft_instance->is_leader();\n }\n \n+\n+bool KeeperServer::isObserver() const\n+{\n+    auto srv_config = state_manager->get_srv_config();\n+    return srv_config->is_learner();\n+}\n+\n+\n+bool KeeperServer::isFollower() const\n+{\n+    return !isLeader() && !isObserver();\n+}\n+\n bool KeeperServer::isLeaderAlive() const\n {\n     return raft_instance->is_leader_alive();\n }\n \n+/// TODO test whether taking failed peer in count\n+uint64_t KeeperServer::getFollowerCount() const\n+{\n+    return raft_instance->get_peer_info_all().size();\n+}\n+\n+uint64_t KeeperServer::getSyncedFollowerCount() const\n+{\n+    uint64_t last_log_idx = raft_instance->get_last_log_idx();\n+    const auto followers = raft_instance->get_peer_info_all();\n+\n+    uint64_t stale_followers = 0;\n+\n+    const uint64_t stale_follower_gap = raft_instance->get_current_params().stale_log_gap_;\n+    for (const auto & fl : followers)\n+    {\n+        if (last_log_idx > fl.last_log_idx_ + stale_follower_gap)\n+            stale_followers++;\n+    }\n+    return followers.size() - stale_followers;\n+}\n+\n nuraft::cb_func::ReturnCode KeeperServer::callbackFunc(nuraft::cb_func::Type type, nuraft::cb_func::Param * param)\n {\n     if (initialized_flag)\ndiff --git a/src/Coordination/KeeperServer.h b/src/Coordination/KeeperServer.h\nindex 1dc5282b2850..376fe111f15d 100644\n--- a/src/Coordination/KeeperServer.h\n+++ b/src/Coordination/KeeperServer.h\n@@ -6,7 +6,6 @@\n #include <Coordination/KeeperStateMachine.h>\n #include <Coordination/KeeperStorage.h>\n #include <Coordination/CoordinationSettings.h>\n-#include <unordered_map>\n #include <base/logger_useful.h>\n \n namespace DB\n@@ -52,12 +51,10 @@ class KeeperServer\n \n public:\n     KeeperServer(\n-        int server_id_,\n-        const CoordinationSettingsPtr & coordination_settings_,\n-        const Poco::Util::AbstractConfiguration & config,\n+        const KeeperConfigurationAndSettingsPtr & settings_,\n+        const Poco::Util::AbstractConfiguration & config_,\n         ResponsesQueue & responses_queue_,\n-        SnapshotsQueue & snapshots_queue_,\n-        bool standalone_keeper);\n+        SnapshotsQueue & snapshots_queue_);\n \n     /// Load state machine from the latest snapshot and load log storage. Start NuRaft with required settings.\n     void startup();\n@@ -73,10 +70,25 @@ class KeeperServer\n     /// Return set of the non-active sessions\n     std::vector<int64_t> getDeadSessions();\n \n+    nuraft::ptr<KeeperStateMachine> getKeeperStateMachine() const\n+    {\n+        return state_machine;\n+    }\n+\n     bool isLeader() const;\n \n+    bool isFollower() const;\n+\n+    bool isObserver() const;\n+\n     bool isLeaderAlive() const;\n \n+    /// @return follower count if node is not leader return 0\n+    uint64_t getFollowerCount() const;\n+\n+    /// @return synced follower count if node is not leader return 0\n+    uint64_t getSyncedFollowerCount() const;\n+\n     /// Wait server initialization (see callbackFunc)\n     void waitInit();\n \ndiff --git a/src/Coordination/KeeperStateMachine.cpp b/src/Coordination/KeeperStateMachine.cpp\nindex 62820b417311..1ac1a5844514 100644\n--- a/src/Coordination/KeeperStateMachine.cpp\n+++ b/src/Coordination/KeeperStateMachine.cpp\n@@ -326,16 +326,82 @@ void KeeperStateMachine::processReadRequest(const KeeperStorage::RequestForSessi\n             throw Exception(ErrorCodes::SYSTEM_ERROR, \"Could not push response with session id {} into responses queue\", response.session_id);\n }\n \n+void KeeperStateMachine::shutdownStorage()\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    storage->finalize();\n+}\n+\n std::vector<int64_t> KeeperStateMachine::getDeadSessions()\n {\n     std::lock_guard lock(storage_and_responses_lock);\n     return storage->getDeadSessions();\n }\n \n-void KeeperStateMachine::shutdownStorage()\n+uint64_t KeeperStateMachine::getLastProcessedZxid() const\n {\n     std::lock_guard lock(storage_and_responses_lock);\n-    storage->finalize();\n+    return storage->getZXID();\n+}\n+\n+uint64_t KeeperStateMachine::getNodesCount() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getNodesCount();\n+}\n+\n+uint64_t KeeperStateMachine::getTotalWatchesCount() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getTotalWatchesCount();\n+}\n+\n+uint64_t KeeperStateMachine::getWatchedPathsCount() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getWatchedPathsCount();\n+}\n+\n+uint64_t KeeperStateMachine::getSessionsWithWatchesCount() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getSessionsWithWatchesCount();\n+}\n+\n+uint64_t KeeperStateMachine::getTotalEphemeralNodesCount() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getTotalEphemeralNodesCount();\n+}\n+\n+uint64_t KeeperStateMachine::getSessionWithEphemeralNodesCount() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getSessionWithEphemeralNodesCount();\n+}\n+\n+void KeeperStateMachine::dumpWatches(WriteBufferFromOwnString & buf) const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    storage->dumpWatches(buf);\n+}\n+\n+void KeeperStateMachine::dumpWatchesByPath(WriteBufferFromOwnString & buf) const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    storage->dumpWatchesByPath(buf);\n+}\n+\n+void KeeperStateMachine::dumpSessionsAndEphemerals(WriteBufferFromOwnString & buf) const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    storage->dumpSessionsAndEphemerals(buf);\n+}\n+\n+uint64_t KeeperStateMachine::getApproximateDataSize() const\n+{\n+    std::lock_guard lock(storage_and_responses_lock);\n+    return storage->getApproximateDataSize();\n }\n \n ClusterConfigPtr KeeperStateMachine::getClusterConfig() const\ndiff --git a/src/Coordination/KeeperStateMachine.h b/src/Coordination/KeeperStateMachine.h\nindex 5af3dff73b5e..2803f4b90279 100644\n--- a/src/Coordination/KeeperStateMachine.h\n+++ b/src/Coordination/KeeperStateMachine.h\n@@ -67,19 +67,36 @@ class KeeperStateMachine : public nuraft::state_machine\n         nuraft::ptr<nuraft::buffer> & data_out,\n         bool & is_last_obj) override;\n \n+    /// just for test\n     KeeperStorage & getStorage()\n     {\n         return *storage;\n     }\n \n+    void shutdownStorage();\n+\n+    ClusterConfigPtr getClusterConfig() const;\n+\n     /// Process local read request\n     void processReadRequest(const KeeperStorage::RequestForSession & request_for_session);\n \n     std::vector<int64_t> getDeadSessions();\n \n-    void shutdownStorage();\n+    /// Introspection functions for 4lw commands\n+    uint64_t getLastProcessedZxid() const;\n \n-    ClusterConfigPtr getClusterConfig() const;\n+    uint64_t getNodesCount() const;\n+    uint64_t getTotalWatchesCount() const;\n+    uint64_t getWatchedPathsCount() const;\n+    uint64_t getSessionsWithWatchesCount() const;\n+\n+    void dumpWatches(WriteBufferFromOwnString & buf) const;\n+    void dumpWatchesByPath(WriteBufferFromOwnString & buf) const;\n+    void dumpSessionsAndEphemerals(WriteBufferFromOwnString & buf) const;\n+\n+    uint64_t getSessionWithEphemeralNodesCount() const;\n+    uint64_t getTotalEphemeralNodesCount() const;\n+    uint64_t getApproximateDataSize() const;\n \n private:\n \n@@ -110,7 +127,7 @@ class KeeperStateMachine : public nuraft::state_machine\n     /// we can get strange cases when, for example client send read request with\n     /// watch and after that receive watch response and only receive response\n     /// for request.\n-    std::mutex storage_and_responses_lock;\n+    mutable std::mutex storage_and_responses_lock;\n \n     /// Last committed Raft log number.\n     std::atomic<uint64_t> last_committed_idx;\ndiff --git a/src/Coordination/KeeperStateManager.cpp b/src/Coordination/KeeperStateManager.cpp\nindex 31b3a5f8b874..a40cd1608635 100644\n--- a/src/Coordination/KeeperStateManager.cpp\n+++ b/src/Coordination/KeeperStateManager.cpp\n@@ -1,4 +1,5 @@\n #include <Coordination/KeeperStateManager.h>\n+\n #include <Coordination/Defines.h>\n #include <Common/Exception.h>\n #include <filesystem>\n@@ -11,28 +12,7 @@ namespace ErrorCodes\n     extern const int RAFT_ERROR;\n }\n \n-namespace\n-{\n-    std::string getLogsPathFromConfig(\n-        const std::string & config_prefix, const Poco::Util::AbstractConfiguration & config, bool standalone_keeper)\n-{\n-    /// the most specialized path\n-    if (config.has(config_prefix + \".log_storage_path\"))\n-        return config.getString(config_prefix + \".log_storage_path\");\n-\n-    if (config.has(config_prefix + \".storage_path\"))\n-        return std::filesystem::path{config.getString(config_prefix + \".storage_path\")} / \"logs\";\n-\n-    if (standalone_keeper)\n-        return std::filesystem::path{config.getString(\"path\", KEEPER_DEFAULT_PATH)} / \"logs\";\n-    else\n-        return std::filesystem::path{config.getString(\"path\", DBMS_DEFAULT_PATH)} / \"coordination/logs\";\n-}\n-\n-}\n-\n-\n-KeeperConfigurationWrapper KeeperStateManager::parseServersConfiguration(const Poco::Util::AbstractConfiguration & config, bool allow_without_us) const\n+KeeperStateManager::KeeperConfigurationWrapper KeeperStateManager::parseServersConfiguration(const Poco::Util::AbstractConfiguration & config, bool allow_without_us) const\n {\n     KeeperConfigurationWrapper result;\n     result.cluster_config = std::make_shared<nuraft::cluster_config>();\n@@ -78,9 +58,9 @@ KeeperConfigurationWrapper KeeperStateManager::parseServersConfiguration(const P\n }\n \n KeeperStateManager::KeeperStateManager(int server_id_, const std::string & host, int port, const std::string & logs_path)\n-    : my_server_id(server_id_)\n-    , secure(false)\n-    , log_store(nuraft::cs_new<KeeperLogStore>(logs_path, 5000, false, false))\n+: my_server_id(server_id_)\n+, secure(false)\n+, log_store(nuraft::cs_new<KeeperLogStore>(logs_path, 5000, false, false))\n {\n     auto peer_config = nuraft::cs_new<nuraft::srv_config>(my_server_id, host + \":\" + std::to_string(port));\n     configuration_wrapper.cluster_config = nuraft::cs_new<nuraft::cluster_config>();\n@@ -90,18 +70,20 @@ KeeperStateManager::KeeperStateManager(int server_id_, const std::string & host,\n }\n \n KeeperStateManager::KeeperStateManager(\n-    int server_id_,\n+    int my_server_id_,\n     const std::string & config_prefix_,\n+    const std::string & log_storage_path,\n     const Poco::Util::AbstractConfiguration & config,\n-    const CoordinationSettingsPtr & coordination_settings,\n-    bool standalone_keeper)\n-    : my_server_id(server_id_)\n+    const CoordinationSettingsPtr & coordination_settings)\n+    : my_server_id(my_server_id_)\n     , secure(config.getBool(config_prefix_ + \".raft_configuration.secure\", false))\n     , config_prefix(config_prefix_)\n     , configuration_wrapper(parseServersConfiguration(config, false))\n     , log_store(nuraft::cs_new<KeeperLogStore>(\n-                    getLogsPathFromConfig(config_prefix_, config, standalone_keeper),\n-                    coordination_settings->rotate_log_storage_interval, coordination_settings->force_sync, coordination_settings->compress_logs))\n+                    log_storage_path,\n+                    coordination_settings->rotate_log_storage_interval,\n+                    coordination_settings->force_sync,\n+                    coordination_settings->compress_logs))\n {\n }\n \ndiff --git a/src/Coordination/KeeperStateManager.h b/src/Coordination/KeeperStateManager.h\nindex 96f0484c05a7..fad76c895039 100644\n--- a/src/Coordination/KeeperStateManager.h\n+++ b/src/Coordination/KeeperStateManager.h\n@@ -13,20 +13,6 @@ namespace DB\n \n using KeeperServerConfigPtr = nuraft::ptr<nuraft::srv_config>;\n \n-/// Wrapper struct for Keeper cluster config. We parse this\n-/// info from XML files.\n-struct KeeperConfigurationWrapper\n-{\n-    /// Our port\n-    int port;\n-    /// Our config\n-    KeeperServerConfigPtr config;\n-    /// Servers id's to start as followers\n-    std::unordered_set<int> servers_start_as_followers;\n-    /// Cluster config\n-    ClusterConfigPtr cluster_config;\n-};\n-\n /// When our configuration changes the following action types\n /// can happen\n enum class ConfigUpdateActionType\n@@ -52,9 +38,9 @@ class KeeperStateManager : public nuraft::state_mgr\n     KeeperStateManager(\n         int server_id_,\n         const std::string & config_prefix_,\n+        const std::string & log_storage_path,\n         const Poco::Util::AbstractConfiguration & config,\n-        const CoordinationSettingsPtr & coordination_settings,\n-        bool standalone_keeper);\n+        const CoordinationSettingsPtr & coordination_settings);\n \n     /// Constructor for tests\n     KeeperStateManager(\n@@ -121,6 +107,20 @@ class KeeperStateManager : public nuraft::state_mgr\n     ConfigUpdateActions getConfigurationDiff(const Poco::Util::AbstractConfiguration & config) const;\n \n private:\n+    /// Wrapper struct for Keeper cluster config. We parse this\n+    /// info from XML files.\n+    struct KeeperConfigurationWrapper\n+    {\n+        /// Our port\n+        int port;\n+        /// Our config\n+        KeeperServerConfigPtr config;\n+        /// Servers id's to start as followers\n+        std::unordered_set<int> servers_start_as_followers;\n+        /// Cluster config\n+        ClusterConfigPtr cluster_config;\n+    };\n+\n     int my_server_id;\n     bool secure;\n     std::string config_prefix;\ndiff --git a/src/Coordination/KeeperStorage.cpp b/src/Coordination/KeeperStorage.cpp\nindex b6938da958b5..81bb3d0dd7d5 100644\n--- a/src/Coordination/KeeperStorage.cpp\n+++ b/src/Coordination/KeeperStorage.cpp\n@@ -10,6 +10,7 @@\n #include <Poco/SHA1Engine.h>\n #include <Poco/Base64Encoder.h>\n #include <boost/algorithm/string.hpp>\n+#include <Common/hex.h>\n \n namespace DB\n {\n@@ -132,6 +133,21 @@ static bool fixupACL(\n     return valid_found;\n }\n \n+uint64_t KeeperStorage::Node::sizeInBytes() const\n+{\n+    uint64_t total_size{0};\n+    for (const auto & child : children)\n+        total_size += child.size();\n+\n+    total_size += data.size();\n+\n+    total_size += sizeof(acl_id);\n+    total_size += sizeof(is_sequental);\n+    total_size += sizeof(stat);\n+    total_size += sizeof(seq_num);\n+    return total_size;\n+}\n+\n static KeeperStorage::ResponsesForSessions processWatchesImpl(const String & path, KeeperStorage::Watches & watches, KeeperStorage::Watches & list_watches, Coordination::Event event_type)\n {\n     KeeperStorage::ResponsesForSessions result;\n@@ -1220,4 +1236,96 @@ void KeeperStorage::clearDeadWatches(int64_t session_id)\n     }\n }\n \n+void KeeperStorage::dumpWatches(WriteBufferFromOwnString & buf) const\n+{\n+    for (const auto & [session_id, watches_paths] : sessions_and_watchers)\n+    {\n+        buf << \"0x\" << getHexUIntLowercase(session_id) << \"\\n\";\n+        for (const String & path : watches_paths)\n+            buf << \"\\t\" << path << \"\\n\";\n+    }\n+}\n+\n+void KeeperStorage::dumpWatchesByPath(WriteBufferFromOwnString & buf) const\n+{\n+    auto write_int_vec = [&buf](const std::vector<int64_t> & session_ids)\n+    {\n+        for (int64_t session_id : session_ids)\n+        {\n+            buf << \"\\t0x\" << getHexUIntLowercase(session_id) << \"\\n\";\n+        }\n+    };\n+\n+    for (const auto & [watch_path, sessions] : watches)\n+    {\n+        buf << watch_path << \"\\n\";\n+        write_int_vec(sessions);\n+    }\n+\n+    for (const auto & [watch_path, sessions] : list_watches)\n+    {\n+        buf << watch_path << \"\\n\";\n+        write_int_vec(sessions);\n+    }\n+}\n+\n+void KeeperStorage::dumpSessionsAndEphemerals(WriteBufferFromOwnString & buf) const\n+{\n+    auto write_str_set = [&buf](const std::unordered_set<String> & ephemeral_paths)\n+    {\n+        for (const String & path : ephemeral_paths)\n+        {\n+            buf << \"\\t\" << path << \"\\n\";\n+        }\n+    };\n+\n+    buf << \"Sessions dump (\" << session_and_timeout.size() << \"):\\n\";\n+\n+    for (const auto & [session_id, _] : session_and_timeout)\n+    {\n+        buf << \"0x\" << getHexUIntLowercase(session_id) << \"\\n\";\n+    }\n+\n+    buf << \"Sessions with Ephemerals (\" << getSessionWithEphemeralNodesCount() << \"):\\n\";\n+    for (const auto & [session_id, ephemeral_paths] : ephemerals)\n+    {\n+        buf << \"0x\" << getHexUIntLowercase(session_id) << \"\\n\";\n+        write_str_set(ephemeral_paths);\n+    }\n+}\n+\n+uint64_t KeeperStorage::getTotalWatchesCount() const\n+{\n+    uint64_t ret = 0;\n+    for (const auto & [path, subscribed_sessions] : watches)\n+        ret += subscribed_sessions.size();\n+\n+    for (const auto & [path, subscribed_sessions] : list_watches)\n+        ret += subscribed_sessions.size();\n+\n+    return ret;\n+}\n+\n+uint64_t KeeperStorage::getSessionsWithWatchesCount() const\n+{\n+    std::unordered_set<int64_t> counter;\n+    for (const auto & [path, subscribed_sessions] : watches)\n+        counter.insert(subscribed_sessions.begin(), subscribed_sessions.end());\n+\n+    for (const auto & [path, subscribed_sessions] : list_watches)\n+        counter.insert(subscribed_sessions.begin(), subscribed_sessions.end());\n+\n+    return counter.size();\n+}\n+\n+uint64_t KeeperStorage::getTotalEphemeralNodesCount() const\n+{\n+    uint64_t ret = 0;\n+    for (const auto & [session_id, nodes] : ephemerals)\n+        ret += nodes.size();\n+\n+    return ret;\n+}\n+\n+\n }\ndiff --git a/src/Coordination/KeeperStorage.h b/src/Coordination/KeeperStorage.h\nindex bc9a81bc4841..44dc1b2b43b9 100644\n--- a/src/Coordination/KeeperStorage.h\n+++ b/src/Coordination/KeeperStorage.h\n@@ -1,6 +1,5 @@\n #pragma once\n \n-#include <Common/ThreadPool.h>\n #include <Common/ZooKeeper/IKeeper.h>\n #include <Common/ConcurrentBoundedQueue.h>\n #include <Common/ZooKeeper/ZooKeeperCommon.h>\n@@ -14,7 +13,6 @@\n namespace DB\n {\n \n-using namespace DB;\n struct KeeperStorageRequestProcessor;\n using KeeperStorageRequestProcessorPtr = std::shared_ptr<KeeperStorageRequestProcessor>;\n using ResponseCallback = std::function<void(const Coordination::ZooKeeperResponsePtr &)>;\n@@ -29,8 +27,6 @@ struct KeeperStorageSnapshot;\n class KeeperStorage\n {\n public:\n-    int64_t session_id_counter{1};\n-\n     struct Node\n     {\n         String data;\n@@ -39,6 +35,9 @@ class KeeperStorage\n         Coordination::Stat stat{};\n         int32_t seq_num = 0;\n         ChildrenSet children{};\n+\n+        /// Object memory size\n+        uint64_t sizeInBytes() const;\n     };\n \n     struct ResponseForSession\n@@ -46,7 +45,6 @@ class KeeperStorage\n         int64_t session_id;\n         Coordination::ZooKeeperResponsePtr response;\n     };\n-\n     using ResponsesForSessions = std::vector<ResponseForSession>;\n \n     struct RequestForSession\n@@ -76,10 +74,13 @@ class KeeperStorage\n     /// Just vector of SHA1 from user:password\n     using AuthIDs = std::vector<AuthID>;\n     using SessionAndAuth = std::unordered_map<int64_t, AuthIDs>;\n-    SessionAndAuth session_and_auth;\n-\n     using Watches = std::map<String /* path, relative of root_path */, SessionIDs>;\n \n+public:\n+    int64_t session_id_counter{1};\n+\n+    SessionAndAuth session_and_auth;\n+\n     /// Main hashtable with nodes. Contain all information about data.\n     /// All other structures expect session_and_timeout can be restored from\n     /// container.\n@@ -176,6 +177,36 @@ class KeeperStorage\n     {\n         return session_expiry_queue.getExpiredSessions();\n     }\n+\n+    /// Introspection functions mostly used in 4-letter commands\n+    uint64_t getNodesCount() const\n+    {\n+        return container.size();\n+    }\n+\n+    uint64_t getApproximateDataSize() const\n+    {\n+        return container.getApproximateDataSize();\n+    }\n+\n+    uint64_t getTotalWatchesCount() const;\n+\n+    uint64_t getWatchedPathsCount() const\n+    {\n+        return watches.size() + list_watches.size();\n+    }\n+\n+    uint64_t getSessionsWithWatchesCount() const;\n+\n+    uint64_t getSessionWithEphemeralNodesCount() const\n+    {\n+        return ephemerals.size();\n+    }\n+    uint64_t getTotalEphemeralNodesCount() const;\n+\n+    void dumpWatches(WriteBufferFromOwnString & buf) const;\n+    void dumpWatchesByPath(WriteBufferFromOwnString & buf) const;\n+    void dumpSessionsAndEphemerals(WriteBufferFromOwnString & buf) const;\n };\n \n using KeeperStoragePtr = std::unique_ptr<KeeperStorage>;\ndiff --git a/src/Coordination/SnapshotableHashTable.h b/src/Coordination/SnapshotableHashTable.h\nindex 454d11101963..7704825f8300 100644\n--- a/src/Coordination/SnapshotableHashTable.h\n+++ b/src/Coordination/SnapshotableHashTable.h\n@@ -15,6 +15,7 @@ struct ListNode\n     bool active_in_map;\n };\n \n+\n template <class V>\n class SnapshotableHashTable\n {\n@@ -28,6 +29,82 @@ class SnapshotableHashTable\n     IndexMap map;\n     bool snapshot_mode{false};\n \n+    uint64_t approximate_data_size{0};\n+\n+    enum OperationType\n+    {\n+        INSERT = 0,\n+        INSERT_OR_REPLACE = 1,\n+        ERASE = 2,\n+        UPDATE_VALUE = 3,\n+        GET_VALUE = 4,\n+        FIND = 5,\n+        CONTAINS = 6,\n+        CLEAR = 7,\n+        CLEAR_OUTDATED_NODES = 8\n+    };\n+\n+    /// Update hash table approximate data size\n+    ///    op_type: operation type\n+    ///    key_size: key size\n+    ///    value_size: size of value to add\n+    ///    old_value_size: size of value to minus\n+    /// old_value_size=0 means there is no old value with the same key.\n+    void updateDataSize(OperationType op_type, uint64_t key_size, uint64_t value_size, uint64_t old_value_size)\n+    {\n+        switch (op_type)\n+        {\n+            case INSERT:\n+                approximate_data_size += key_size;\n+                approximate_data_size += value_size;\n+                break;\n+            case INSERT_OR_REPLACE:\n+                /// replace\n+                if (old_value_size != 0)\n+                {\n+                    approximate_data_size += key_size;\n+                    approximate_data_size += value_size;\n+                    if (!snapshot_mode)\n+                    {\n+                        approximate_data_size += key_size;\n+                        approximate_data_size -= old_value_size;\n+                    }\n+                }\n+                /// insert\n+                else\n+                {\n+                    approximate_data_size += key_size;\n+                    approximate_data_size += value_size;\n+                }\n+                break;\n+            case UPDATE_VALUE:\n+                approximate_data_size += key_size;\n+                approximate_data_size += value_size;\n+                if (!snapshot_mode)\n+                {\n+                    approximate_data_size -= key_size;\n+                    approximate_data_size -= old_value_size;\n+                }\n+                break;\n+            case ERASE:\n+                if (!snapshot_mode)\n+                {\n+                    approximate_data_size -= key_size;\n+                    approximate_data_size -= old_value_size;\n+                }\n+                break;\n+            case CLEAR:\n+                approximate_data_size = 0;\n+                break;\n+            case CLEAR_OUTDATED_NODES:\n+                approximate_data_size -= key_size;\n+                approximate_data_size -= value_size;\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n public:\n \n     using iterator = typename List::iterator;\n@@ -44,6 +121,7 @@ class SnapshotableHashTable\n             ListElem elem{key, value, true};\n             auto itr = list.insert(list.end(), elem);\n             map.emplace(itr->key, itr);\n+            updateDataSize(INSERT, key.size(), value.sizeInBytes(), 0);\n             return true;\n         }\n \n@@ -54,6 +132,8 @@ class SnapshotableHashTable\n     void insertOrReplace(const std::string & key, const V & value)\n     {\n         auto it = map.find(key);\n+        uint64_t old_value_size = it == map.end() ? 0 : it->second->value.sizeInBytes();\n+\n         if (it == map.end())\n         {\n             ListElem elem{key, value, true};\n@@ -76,6 +156,7 @@ class SnapshotableHashTable\n                 list_itr->value = value;\n             }\n         }\n+        updateDataSize(INSERT_OR_REPLACE, key.size(), value.sizeInBytes(), old_value_size);\n     }\n \n     bool erase(const std::string & key)\n@@ -85,6 +166,7 @@ class SnapshotableHashTable\n             return false;\n \n         auto list_itr = it->second;\n+        uint64_t old_data_size = list_itr->value.sizeInBytes();\n         if (snapshot_mode)\n         {\n             list_itr->active_in_map = false;\n@@ -96,6 +178,7 @@ class SnapshotableHashTable\n             list.erase(list_itr);\n         }\n \n+        updateDataSize(ERASE, key.size(), 0, old_data_size);\n         return true;\n     }\n \n@@ -108,23 +191,29 @@ class SnapshotableHashTable\n     {\n         auto it = map.find(key);\n         assert(it != map.end());\n+\n+        auto list_itr = it->second;\n+        uint64_t old_value_size = list_itr->value.sizeInBytes();\n+\n+        const_iterator ret;\n+\n         if (snapshot_mode)\n         {\n-            auto list_itr = it->second;\n             auto elem_copy = *(list_itr);\n             list_itr->active_in_map = false;\n             map.erase(it);\n             updater(elem_copy.value);\n             auto itr = list.insert(list.end(), elem_copy);\n             map.emplace(itr->key, itr);\n-            return itr;\n+            ret = itr;\n         }\n         else\n         {\n-            auto list_itr = it->second;\n             updater(list_itr->value);\n-            return list_itr;\n+            ret = list_itr;\n         }\n+        updateDataSize(UPDATE_VALUE, key.size(), ret->value.sizeInBytes(), old_value_size);\n+        return ret;\n     }\n \n     const_iterator find(const std::string & key) const\n@@ -149,7 +238,10 @@ class SnapshotableHashTable\n         for (auto itr = start; itr != end;)\n         {\n             if (!itr->active_in_map)\n+            {\n+                updateDataSize(CLEAR_OUTDATED_NODES, itr->key.size(), itr->value.sizeInBytes(), 0);\n                 itr = list.erase(itr);\n+            }\n             else\n                 itr++;\n         }\n@@ -159,6 +251,7 @@ class SnapshotableHashTable\n     {\n         list.clear();\n         map.clear();\n+        updateDataSize(CLEAR, 0, 0, 0);\n     }\n \n     void enableSnapshotMode()\n@@ -181,6 +274,10 @@ class SnapshotableHashTable\n         return list.size();\n     }\n \n+    uint64_t getApproximateDataSize() const\n+    {\n+        return approximate_data_size;\n+    }\n \n     iterator begin() { return list.begin(); }\n     const_iterator begin() const { return list.cbegin(); }\ndiff --git a/src/Server/KeeperTCPHandler.cpp b/src/Server/KeeperTCPHandler.cpp\nindex afcf03b2574c..6478ece1536c 100644\n--- a/src/Server/KeeperTCPHandler.cpp\n+++ b/src/Server/KeeperTCPHandler.cpp\n@@ -18,6 +18,9 @@\n #include <IO/ReadBufferFromFileDescriptor.h>\n #include <queue>\n #include <mutex>\n+#include <Coordination/FourLetterCommand.h>\n+#include <Common/hex.h>\n+\n \n #ifdef POCO_HAVE_FD_EPOLL\n     #include <sys/epoll.h>\n@@ -29,6 +32,16 @@\n namespace DB\n {\n \n+struct LastOp\n+{\n+public:\n+    String name{\"NA\"};\n+    int64_t last_cxid{-1};\n+    int64_t last_zxid{-1};\n+    int64_t last_response_time{0};\n+};\n+\n+static const LastOp EMPTY_LAST_OP {\"NA\", -1, -1, 0};\n \n namespace ErrorCodes\n {\n@@ -199,7 +212,9 @@ KeeperTCPHandler::KeeperTCPHandler(IServer & server_, const Poco::Net::StreamSoc\n     , session_timeout(0, global_context->getConfigRef().getUInt(\"keeper_server.session_timeout_ms\", Coordination::DEFAULT_SESSION_TIMEOUT_MS) * 1000)\n     , poll_wrapper(std::make_unique<SocketInterruptablePollWrapper>(socket_))\n     , responses(std::make_unique<ThreadSafeResponseQueue>(std::numeric_limits<size_t>::max()))\n+    , last_op(std::make_unique<LastOp>(EMPTY_LAST_OP))\n {\n+    KeeperTCPHandler::registerConnection(this);\n }\n \n void KeeperTCPHandler::sendHandshake(bool has_leader)\n@@ -222,16 +237,15 @@ void KeeperTCPHandler::run()\n     runImpl();\n }\n \n-Poco::Timespan KeeperTCPHandler::receiveHandshake()\n+Poco::Timespan KeeperTCPHandler::receiveHandshake(int32_t handshake_length)\n {\n-    int32_t handshake_length;\n     int32_t protocol_version;\n     int64_t last_zxid_seen;\n     int32_t timeout_ms;\n     int64_t previous_session_id = 0;    /// We don't support session restore. So previous session_id is always zero.\n     std::array<char, Coordination::PASSWORD_LENGTH> passwd {};\n-    Coordination::read(handshake_length, *in);\n-    if (handshake_length != Coordination::CLIENT_HANDSHAKE_LENGTH && handshake_length != Coordination::CLIENT_HANDSHAKE_LENGTH_WITH_READONLY)\n+\n+    if (!isHandShake(handshake_length))\n         throw Exception(\"Unexpected handshake length received: \" + toString(handshake_length), ErrorCodes::UNEXPECTED_PACKET_FROM_CLIENT);\n \n     Coordination::read(protocol_version, *in);\n@@ -274,9 +288,32 @@ void KeeperTCPHandler::runImpl()\n         return;\n     }\n \n+    int32_t header;\n+    try\n+    {\n+        Coordination::read(header, *in);\n+    }\n+    catch (const Exception & e)\n+    {\n+        LOG_WARNING(log, \"Error while read connection header {}\", e.displayText());\n+        return;\n+    }\n+\n+    /// All four letter word command code is larger than 2^24 or lower than 0.\n+    /// Hand shake package length must be lower than 2^24 and larger than 0.\n+    /// So collision never happens.\n+    int32_t four_letter_cmd = header;\n+    if (!isHandShake(four_letter_cmd))\n+    {\n+        tryExecuteFourLetterWordCmd(four_letter_cmd);\n+        return;\n+    }\n+\n     try\n     {\n-        auto client_timeout = receiveHandshake();\n+        int32_t handshake_length = header;\n+        auto client_timeout = receiveHandshake(handshake_length);\n+\n         if (client_timeout != 0)\n             session_timeout = std::min(client_timeout, session_timeout);\n     }\n@@ -345,6 +382,7 @@ void KeeperTCPHandler::runImpl()\n \n     session_stopwatch.start();\n     bool close_received = false;\n+\n     try\n     {\n         while (true)\n@@ -356,6 +394,7 @@ void KeeperTCPHandler::runImpl()\n             if (result.has_requests && !close_received)\n             {\n                 auto [received_op, received_xid] = receiveRequest();\n+                packageReceived();\n                 log_long_operation(\"Receiving request\");\n \n                 if (received_op == Coordination::OpNum::Close)\n@@ -368,6 +407,8 @@ void KeeperTCPHandler::runImpl()\n                 {\n                     LOG_TRACE(log, \"Received heartbeat for session #{}\", session_id);\n                 }\n+                else\n+                    operations[received_xid] = Poco::Timestamp();\n \n                 /// Each request restarts session stopwatch\n                 session_stopwatch.restart();\n@@ -390,6 +431,9 @@ void KeeperTCPHandler::runImpl()\n                     return;\n                 }\n \n+                updateStats(response);\n+                packageSent();\n+\n                 response->write(*out);\n                 log_long_operation(\"Sending response\");\n                 if (response->error == Coordination::Error::ZSESSIONEXPIRED)\n@@ -422,6 +466,44 @@ void KeeperTCPHandler::runImpl()\n     }\n }\n \n+bool KeeperTCPHandler::isHandShake(int32_t handshake_length)\n+{\n+    return handshake_length == Coordination::CLIENT_HANDSHAKE_LENGTH\n+    || handshake_length == Coordination::CLIENT_HANDSHAKE_LENGTH_WITH_READONLY;\n+}\n+\n+bool KeeperTCPHandler::tryExecuteFourLetterWordCmd(int32_t command)\n+{\n+    if (!FourLetterCommandFactory::instance().isKnown(command))\n+    {\n+        LOG_WARNING(log, \"invalid four letter command {}\", IFourLetterCommand::toName(command));\n+        return false;\n+    }\n+    else if (!FourLetterCommandFactory::instance().isEnabled(command))\n+    {\n+        LOG_WARNING(log, \"Not enabled four letter command {}\", IFourLetterCommand::toName(command));\n+        return false;\n+    }\n+    else\n+    {\n+        auto command_ptr = FourLetterCommandFactory::instance().get(command);\n+        LOG_DEBUG(log, \"Receive four letter command {}\", command_ptr->name());\n+\n+        try\n+        {\n+            String res = command_ptr->run();\n+            out->write(res.data(), res.size());\n+            out->next();\n+        }\n+        catch (...)\n+        {\n+            tryLogCurrentException(log, \"Error when executing four letter command \" + command_ptr->name());\n+        }\n+\n+        return true;\n+    }\n+}\n+\n std::pair<Coordination::OpNum, Coordination::XID> KeeperTCPHandler::receiveRequest()\n {\n     int32_t length;\n@@ -441,6 +523,148 @@ std::pair<Coordination::OpNum, Coordination::XID> KeeperTCPHandler::receiveReque\n     return std::make_pair(opnum, xid);\n }\n \n+void KeeperTCPHandler::packageSent()\n+{\n+    {\n+        std::lock_guard lock(conn_stats_mutex);\n+        conn_stats.incrementPacketsSent();\n+    }\n+    keeper_dispatcher->incrementPacketsSent();\n+}\n+\n+void KeeperTCPHandler::packageReceived()\n+{\n+    {\n+        std::lock_guard lock(conn_stats_mutex);\n+        conn_stats.incrementPacketsReceived();\n+    }\n+    keeper_dispatcher->incrementPacketsReceived();\n+}\n+\n+void KeeperTCPHandler::updateStats(Coordination::ZooKeeperResponsePtr & response)\n+{\n+    /// update statistics ignoring watch response and heartbeat.\n+    if (response->xid != Coordination::WATCH_XID && response->getOpNum() != Coordination::OpNum::Heartbeat)\n+    {\n+        Int64 elapsed = (Poco::Timestamp() - operations[response->xid]) / 1000;\n+        {\n+            std::lock_guard lock(conn_stats_mutex);\n+            conn_stats.updateLatency(elapsed);\n+        }\n+        keeper_dispatcher->updateKeeperStatLatency(elapsed);\n+\n+        last_op.set(std::make_unique<LastOp>(LastOp{\n+            .name = Coordination::toString(response->getOpNum()),\n+            .last_cxid = response->xid,\n+            .last_zxid = response->zxid,\n+            .last_response_time = Poco::Timestamp().epochMicroseconds() / 1000,\n+        }));\n+    }\n+\n+}\n+\n+KeeperConnectionStats KeeperTCPHandler::getConnectionStats() const\n+{\n+    std::lock_guard lock(conn_stats_mutex);\n+    return conn_stats;\n+}\n+\n+void KeeperTCPHandler::dumpStats(WriteBufferFromOwnString & buf, bool brief)\n+{\n+    KeeperConnectionStats stats = getConnectionStats();\n+\n+    writeText(' ', buf);\n+    writeText(socket().peerAddress().toString(), buf);\n+    writeText(\"(recved=\", buf);\n+    writeIntText(stats.getPacketsReceived(), buf);\n+    writeText(\",sent=\", buf);\n+    writeIntText(stats.getPacketsSent(), buf);\n+    if (!brief)\n+    {\n+        if (session_id != 0)\n+        {\n+            writeText(\",sid=0x\", buf);\n+            writeText(getHexUIntLowercase(session_id), buf);\n+\n+            writeText(\",lop=\", buf);\n+            LastOpPtr op = last_op.get();\n+            writeText(op->name, buf);\n+            writeText(\",est=\", buf);\n+            writeIntText(established.epochMicroseconds() / 1000, buf);\n+            writeText(\",to=\", buf);\n+            writeIntText(session_timeout.totalMilliseconds(), buf);\n+            int64_t last_cxid = op->last_cxid;\n+            if (last_cxid >= 0)\n+            {\n+                writeText(\",lcxid=0x\", buf);\n+                writeText(getHexUIntLowercase(last_cxid), buf);\n+            }\n+            writeText(\",lzxid=0x\", buf);\n+            writeText(getHexUIntLowercase(op->last_zxid), buf);\n+            writeText(\",lresp=\", buf);\n+            writeIntText(op->last_response_time, buf);\n+\n+            writeText(\",llat=\", buf);\n+            writeIntText(stats.getLastLatency(), buf);\n+            writeText(\",minlat=\", buf);\n+            writeIntText(stats.getMinLatency(), buf);\n+            writeText(\",avglat=\", buf);\n+            writeIntText(stats.getAvgLatency(), buf);\n+            writeText(\",maxlat=\", buf);\n+            writeIntText(stats.getMaxLatency(), buf);\n+        }\n+    }\n+    writeText(')', buf);\n+    writeText('\\n', buf);\n+}\n+\n+void KeeperTCPHandler::resetStats()\n+{\n+    {\n+        std::lock_guard lock(conn_stats_mutex);\n+        conn_stats.reset();\n+    }\n+    last_op.set(std::make_unique<LastOp>(EMPTY_LAST_OP));\n+}\n+\n+KeeperTCPHandler::~KeeperTCPHandler()\n+{\n+    KeeperTCPHandler::unregisterConnection(this);\n+}\n+\n+std::mutex KeeperTCPHandler::conns_mutex;\n+std::unordered_set<KeeperTCPHandler *> KeeperTCPHandler::connections;\n+\n+void KeeperTCPHandler::registerConnection(KeeperTCPHandler * conn)\n+{\n+    std::lock_guard lock(conns_mutex);\n+    connections.insert(conn);\n+}\n+\n+void KeeperTCPHandler::unregisterConnection(KeeperTCPHandler * conn)\n+{\n+    std::lock_guard lock(conns_mutex);\n+    connections.erase(conn);\n+}\n+\n+void KeeperTCPHandler::dumpConnections(WriteBufferFromOwnString & buf, bool brief)\n+{\n+    std::lock_guard lock(conns_mutex);\n+    for (auto * conn : connections)\n+    {\n+        conn->dumpStats(buf, brief);\n+    }\n+}\n+\n+void KeeperTCPHandler::resetConnsStats()\n+{\n+    std::lock_guard lock(conns_mutex);\n+    for (auto * conn : connections)\n+    {\n+        conn->resetStats();\n+    }\n+}\n+\n }\n \n #endif\ndiff --git a/src/Server/KeeperTCPHandler.h b/src/Server/KeeperTCPHandler.h\nindex 9983749f1456..fb6541d1f537 100644\n--- a/src/Server/KeeperTCPHandler.h\n+++ b/src/Server/KeeperTCPHandler.h\n@@ -6,6 +6,7 @@\n #if USE_NURAFT\n \n #include <Poco/Net/TCPServerConnection.h>\n+#include <Common/MultiVersion.h>\n #include \"IServer.h\"\n #include <Common/Stopwatch.h>\n #include <Interpreters/Context.h>\n@@ -16,6 +17,8 @@\n #include <IO/WriteBufferFromPocoSocket.h>\n #include <IO/ReadBufferFromPocoSocket.h>\n #include <unordered_map>\n+#include <Coordination/KeeperConnectionStats.h>\n+#include <Poco/Timestamp.h>\n \n namespace DB\n {\n@@ -24,14 +27,36 @@ struct SocketInterruptablePollWrapper;\n using SocketInterruptablePollWrapperPtr = std::unique_ptr<SocketInterruptablePollWrapper>;\n \n using ThreadSafeResponseQueue = ConcurrentBoundedQueue<Coordination::ZooKeeperResponsePtr>;\n-\n using ThreadSafeResponseQueuePtr = std::unique_ptr<ThreadSafeResponseQueue>;\n \n+struct LastOp;\n+using LastOpMultiVersion = MultiVersion<LastOp>;\n+using LastOpPtr = LastOpMultiVersion::Version;\n+\n class KeeperTCPHandler : public Poco::Net::TCPServerConnection\n {\n+public:\n+    static void registerConnection(KeeperTCPHandler * conn);\n+    static void unregisterConnection(KeeperTCPHandler * conn);\n+    /// dump all connections statistics\n+    static void dumpConnections(WriteBufferFromOwnString & buf, bool brief);\n+    static void resetConnsStats();\n+\n+private:\n+    static std::mutex conns_mutex;\n+    /// all connections\n+    static std::unordered_set<KeeperTCPHandler *> connections;\n+\n public:\n     KeeperTCPHandler(IServer & server_, const Poco::Net::StreamSocket & socket_);\n     void run() override;\n+\n+    KeeperConnectionStats getConnectionStats() const;\n+    void dumpStats(WriteBufferFromOwnString & buf, bool brief);\n+    void resetStats();\n+\n+    ~KeeperTCPHandler() override;\n+\n private:\n     IServer & server;\n     Poco::Logger * log;\n@@ -54,9 +79,28 @@ class KeeperTCPHandler : public Poco::Net::TCPServerConnection\n     void runImpl();\n \n     void sendHandshake(bool has_leader);\n-    Poco::Timespan receiveHandshake();\n+    Poco::Timespan receiveHandshake(int32_t handshake_length);\n+\n+    static bool isHandShake(int32_t handshake_length);\n+    bool tryExecuteFourLetterWordCmd(int32_t command);\n \n     std::pair<Coordination::OpNum, Coordination::XID> receiveRequest();\n+\n+    void packageSent();\n+    void packageReceived();\n+\n+    void updateStats(Coordination::ZooKeeperResponsePtr & response);\n+\n+    Poco::Timestamp established;\n+\n+    using Operations = std::map<Coordination::XID, Poco::Timestamp>;\n+    Operations operations;\n+\n+    LastOpMultiVersion last_op;\n+\n+    mutable std::mutex conn_stats_mutex;\n+    KeeperConnectionStats conn_stats;\n+\n };\n \n }\ndiff --git a/src/Server/KeeperTCPHandlerFactory.h b/src/Server/KeeperTCPHandlerFactory.h\nindex 82ce56804d8b..67bb3dab2687 100644\n--- a/src/Server/KeeperTCPHandlerFactory.h\n+++ b/src/Server/KeeperTCPHandlerFactory.h\n@@ -21,6 +21,7 @@ class KeeperTCPHandlerFactory : public Poco::Net::TCPServerConnectionFactory\n         using Poco::Net::TCPServerConnection::TCPServerConnection;\n         void run() override {}\n     };\n+\n public:\n     KeeperTCPHandlerFactory(IServer & server_, bool secure)\n         : server(server_)\n@@ -41,6 +42,7 @@ class KeeperTCPHandlerFactory : public Poco::Net::TCPServerConnectionFactory\n             return new DummyTCPHandler(socket);\n         }\n     }\n+\n };\n \n }\n",
  "test_patch": "diff --git a/src/Coordination/tests/gtest_coordination.cpp b/src/Coordination/tests/gtest_coordination.cpp\nindex 01a6d577f574..d5498a1bc13a 100644\n--- a/src/Coordination/tests/gtest_coordination.cpp\n+++ b/src/Coordination/tests/gtest_coordination.cpp\n@@ -829,15 +829,29 @@ TEST_P(CoordinationTest, ChangelogTestLostFiles)\n     EXPECT_FALSE(fs::exists(\"./logs/changelog_21_40.bin\" + params.extension));\n }\n \n+struct IntNode\n+{\n+    int value;\n+    IntNode(int value_) : value(value_) { } // NOLINT(google-explicit-constructor)\n+    UInt64 sizeInBytes() const { return sizeof value; }\n+    IntNode & operator=(int rhs)\n+    {\n+        this->value = rhs;\n+        return *this;\n+    }\n+    bool operator==(const int & rhs) const { return value == rhs; }\n+    bool operator!=(const int & rhs) const { return rhs != this->value; }\n+};\n+\n TEST_P(CoordinationTest, SnapshotableHashMapSimple)\n {\n-    DB::SnapshotableHashTable<int> hello;\n+    DB::SnapshotableHashTable<IntNode> hello;\n     EXPECT_TRUE(hello.insert(\"hello\", 5));\n     EXPECT_TRUE(hello.contains(\"hello\"));\n     EXPECT_EQ(hello.getValue(\"hello\"), 5);\n     EXPECT_FALSE(hello.insert(\"hello\", 145));\n     EXPECT_EQ(hello.getValue(\"hello\"), 5);\n-    hello.updateValue(\"hello\", [](int & value) { value = 7; });\n+    hello.updateValue(\"hello\", [](IntNode & value) { value = 7; });\n     EXPECT_EQ(hello.getValue(\"hello\"), 7);\n     EXPECT_EQ(hello.size(), 1);\n     EXPECT_TRUE(hello.erase(\"hello\"));\n@@ -846,12 +860,12 @@ TEST_P(CoordinationTest, SnapshotableHashMapSimple)\n \n TEST_P(CoordinationTest, SnapshotableHashMapTrySnapshot)\n {\n-    DB::SnapshotableHashTable<int> map_snp;\n+    DB::SnapshotableHashTable<IntNode> map_snp;\n     EXPECT_TRUE(map_snp.insert(\"/hello\", 7));\n     EXPECT_FALSE(map_snp.insert(\"/hello\", 145));\n     map_snp.enableSnapshotMode();\n     EXPECT_FALSE(map_snp.insert(\"/hello\", 145));\n-    map_snp.updateValue(\"/hello\", [](int & value) { value = 554; });\n+    map_snp.updateValue(\"/hello\", [](IntNode & value) { value = 554; });\n     EXPECT_EQ(map_snp.getValue(\"/hello\"), 554);\n     EXPECT_EQ(map_snp.snapshotSize(), 2);\n     EXPECT_EQ(map_snp.size(), 1);\n@@ -921,6 +935,73 @@ TEST_P(CoordinationTest, SnapshotableHashMapTrySnapshot)\n     map_snp.disableSnapshotMode();\n }\n \n+TEST_P(CoordinationTest, SnapshotableHashMapDataSize)\n+{\n+    /// int\n+    DB::SnapshotableHashTable<IntNode> hello;\n+    hello.disableSnapshotMode();\n+    EXPECT_EQ(hello.getApproximateDataSize(), 0);\n+\n+    hello.insert(\"hello\", 1);\n+    EXPECT_EQ(hello.getApproximateDataSize(), 9);\n+    hello.updateValue(\"hello\", [](IntNode & value) { value = 2; });\n+    EXPECT_EQ(hello.getApproximateDataSize(), 9);\n+\n+    hello.erase(\"hello\");\n+    EXPECT_EQ(hello.getApproximateDataSize(), 0);\n+\n+    hello.clear();\n+    EXPECT_EQ(hello.getApproximateDataSize(), 0);\n+\n+    hello.enableSnapshotMode();\n+    hello.insert(\"hello\", 1);\n+    EXPECT_EQ(hello.getApproximateDataSize(), 9);\n+    hello.updateValue(\"hello\", [](IntNode & value) { value = 2; });\n+    EXPECT_EQ(hello.getApproximateDataSize(), 18);\n+\n+    hello.clearOutdatedNodes();\n+    EXPECT_EQ(hello.getApproximateDataSize(), 9);\n+\n+    hello.erase(\"hello\");\n+    EXPECT_EQ(hello.getApproximateDataSize(), 9);\n+\n+    hello.clearOutdatedNodes();\n+    EXPECT_EQ(hello.getApproximateDataSize(), 0);\n+\n+    /// Node\n+    using Node = DB::KeeperStorage::Node;\n+    DB::SnapshotableHashTable<Node> world;\n+    Node n1;\n+    n1.data = \"1234\";\n+    Node n2;\n+    n2.data = \"123456\";\n+    n2.children.insert(\"\");\n+\n+    world.disableSnapshotMode();\n+    world.insert(\"world\", n1);\n+    EXPECT_EQ(world.getApproximateDataSize(), 94);\n+    world.updateValue(\"world\", [&](Node & value) { value = n2; });\n+    EXPECT_EQ(world.getApproximateDataSize(), 96);\n+\n+    world.erase(\"world\");\n+    EXPECT_EQ(world.getApproximateDataSize(), 0);\n+\n+    world.enableSnapshotMode();\n+    world.insert(\"world\", n1);\n+    EXPECT_EQ(world.getApproximateDataSize(), 94);\n+    world.updateValue(\"world\", [&](Node & value) { value = n2; });\n+    EXPECT_EQ(world.getApproximateDataSize(), 190);\n+\n+    world.clearOutdatedNodes();\n+    EXPECT_EQ(world.getApproximateDataSize(), 96);\n+\n+    world.erase(\"world\");\n+    EXPECT_EQ(world.getApproximateDataSize(), 96);\n+\n+    world.clear();\n+    EXPECT_EQ(world.getApproximateDataSize(), 0);\n+}\n+\n void addNode(DB::KeeperStorage & storage, const std::string & path, const std::string & data, int64_t ephemeral_owner=0)\n {\n     using Node = DB::KeeperStorage::Node;\ndiff --git a/tests/integration/test_keeper_four_word_command/__init__.py b/tests/integration/test_keeper_four_word_command/__init__.py\nnew file mode 100644\nindex 000000000000..e5a0d9b4834e\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/__init__.py\n@@ -0,0 +1,1 @@\n+#!/usr/bin/env python3\ndiff --git a/tests/integration/test_keeper_four_word_command/configs/enable_keeper1.xml b/tests/integration/test_keeper_four_word_command/configs/enable_keeper1.xml\nnew file mode 100644\nindex 000000000000..258e58b558ef\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/configs/enable_keeper1.xml\n@@ -0,0 +1,42 @@\n+<yandex>\n+    <keeper_server>\n+        <tcp_port>9181</tcp_port>\n+        <server_id>1</server_id>\n+        <log_storage_path>/var/lib/clickhouse/coordination/log</log_storage_path>\n+        <snapshot_storage_path>/var/lib/clickhouse/coordination/snapshots</snapshot_storage_path>\n+        <four_letter_word_white_list>*</four_letter_word_white_list>\n+\n+        <coordination_settings>\n+            <operation_timeout_ms>5000</operation_timeout_ms>\n+            <session_timeout_ms>30000</session_timeout_ms>\n+            <snapshot_distance>75</snapshot_distance>\n+            <raft_logs_level>trace</raft_logs_level>\n+        </coordination_settings>\n+\n+        <raft_configuration>\n+            <server>\n+                <id>1</id>\n+                <hostname>node1</hostname>\n+                <port>44444</port>\n+                <can_become_leader>true</can_become_leader>\n+                <priority>3</priority>\n+            </server>\n+            <server>\n+                <id>2</id>\n+                <hostname>node2</hostname>\n+                <port>44444</port>\n+                <can_become_leader>false</can_become_leader>\n+                <start_as_follower>true</start_as_follower>\n+                <priority>2</priority>\n+            </server>\n+            <server>\n+                <id>3</id>\n+                <hostname>node3</hostname>\n+                <port>44444</port>\n+                <can_become_leader>false</can_become_leader>\n+                <start_as_follower>true</start_as_follower>\n+                <priority>1</priority>\n+            </server>\n+        </raft_configuration>\n+    </keeper_server>\n+</yandex>\ndiff --git a/tests/integration/test_keeper_four_word_command/configs/enable_keeper2.xml b/tests/integration/test_keeper_four_word_command/configs/enable_keeper2.xml\nnew file mode 100644\nindex 000000000000..f49fb8192562\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/configs/enable_keeper2.xml\n@@ -0,0 +1,42 @@\n+<yandex>\n+    <keeper_server>\n+        <tcp_port>9181</tcp_port>\n+        <server_id>2</server_id>\n+        <log_storage_path>/var/lib/clickhouse/coordination/log</log_storage_path>\n+        <snapshot_storage_path>/var/lib/clickhouse/coordination/snapshots</snapshot_storage_path>\n+        <four_letter_word_white_list>*</four_letter_word_white_list>\n+\n+        <coordination_settings>\n+            <operation_timeout_ms>5000</operation_timeout_ms>\n+            <session_timeout_ms>30000</session_timeout_ms>\n+            <snapshot_distance>75</snapshot_distance>\n+            <raft_logs_level>trace</raft_logs_level>\n+        </coordination_settings>\n+\n+        <raft_configuration>\n+            <server>\n+                <id>1</id>\n+                <hostname>node1</hostname>\n+                <port>44444</port>\n+                <can_become_leader>true</can_become_leader>\n+                <priority>3</priority>\n+            </server>\n+            <server>\n+                <id>2</id>\n+                <hostname>node2</hostname>\n+                <port>44444</port>\n+                <can_become_leader>false</can_become_leader>\n+                <start_as_follower>true</start_as_follower>\n+                <priority>2</priority>\n+            </server>\n+            <server>\n+                <id>3</id>\n+                <hostname>node3</hostname>\n+                <port>44444</port>\n+                <can_become_leader>false</can_become_leader>\n+                <start_as_follower>true</start_as_follower>\n+                <priority>1</priority>\n+            </server>\n+        </raft_configuration>\n+    </keeper_server>\n+</yandex>\ndiff --git a/tests/integration/test_keeper_four_word_command/configs/enable_keeper3.xml b/tests/integration/test_keeper_four_word_command/configs/enable_keeper3.xml\nnew file mode 100644\nindex 000000000000..4606dce367f8\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/configs/enable_keeper3.xml\n@@ -0,0 +1,42 @@\n+<yandex>\n+    <keeper_server>\n+        <tcp_port>9181</tcp_port>\n+        <server_id>3</server_id>\n+        <log_storage_path>/var/lib/clickhouse/coordination/log</log_storage_path>\n+        <snapshot_storage_path>/var/lib/clickhouse/coordination/snapshots</snapshot_storage_path>\n+        <four_letter_word_white_list>*</four_letter_word_white_list>\n+\n+        <coordination_settings>\n+            <operation_timeout_ms>5000</operation_timeout_ms>\n+            <session_timeout_ms>30000</session_timeout_ms>\n+            <snapshot_distance>75</snapshot_distance>\n+            <raft_logs_level>trace</raft_logs_level>\n+        </coordination_settings>\n+\n+        <raft_configuration>\n+            <server>\n+                <id>1</id>\n+                <hostname>node1</hostname>\n+                <port>44444</port>\n+                <can_become_leader>true</can_become_leader>\n+                <priority>3</priority>\n+            </server>\n+            <server>\n+                <id>2</id>\n+                <hostname>node2</hostname>\n+                <port>44444</port>\n+                <can_become_leader>false</can_become_leader>\n+                <start_as_follower>true</start_as_follower>\n+                <priority>2</priority>\n+            </server>\n+            <server>\n+                <id>3</id>\n+                <hostname>node3</hostname>\n+                <port>44444</port>\n+                <can_become_leader>false</can_become_leader>\n+                <start_as_follower>true</start_as_follower>\n+                <priority>1</priority>\n+            </server>\n+        </raft_configuration>\n+    </keeper_server>\n+</yandex>\ndiff --git a/tests/integration/test_keeper_four_word_command/configs/keeper_config_with_white_list.xml b/tests/integration/test_keeper_four_word_command/configs/keeper_config_with_white_list.xml\nnew file mode 100644\nindex 000000000000..4263cdb38c93\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/configs/keeper_config_with_white_list.xml\n@@ -0,0 +1,38 @@\n+<yandex>\n+    <keeper_server>\n+        <tcp_port>9181</tcp_port>\n+        <server_id>1</server_id>\n+        <four_letter_word_white_list>ruok, conf</four_letter_word_white_list>\n+        <raft_configuration>\n+            <server>\n+                <id>1</id>\n+                <hostname>node1</hostname>\n+                <port>44444</port>\n+            </server>\n+            <server>\n+                <id>2</id>\n+                <hostname>node2</hostname>\n+                <port>44444</port>\n+            </server>\n+            <server>\n+                <id>3</id>\n+                <hostname>node3</hostname>\n+                <port>44444</port>\n+            </server>\n+        </raft_configuration>\n+    </keeper_server>\n+    <zookeeper>\n+        <node index=\"1\">\n+            <host>node1</host>\n+            <port>9181</port>\n+        </node>\n+        <node index=\"2\">\n+            <host>node2</host>\n+            <port>9181</port>\n+        </node>\n+        <node index=\"3\">\n+            <host>node3</host>\n+            <port>9181</port>\n+        </node>\n+    </zookeeper>\n+</yandex>\ndiff --git a/tests/integration/test_keeper_four_word_command/configs/keeper_config_with_white_list_all.xml b/tests/integration/test_keeper_four_word_command/configs/keeper_config_with_white_list_all.xml\nnew file mode 100644\nindex 000000000000..635afa70b858\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/configs/keeper_config_with_white_list_all.xml\n@@ -0,0 +1,38 @@\n+<yandex>\n+    <keeper_server>\n+        <tcp_port>9181</tcp_port>\n+        <server_id>3</server_id>\n+        <four_letter_word_white_list>*</four_letter_word_white_list>\n+        <raft_configuration>\n+            <server>\n+                <id>1</id>\n+                <hostname>node1</hostname>\n+                <port>44444</port>\n+            </server>\n+            <server>\n+                <id>2</id>\n+                <hostname>node2</hostname>\n+                <port>44444</port>\n+            </server>\n+            <server>\n+                <id>3</id>\n+                <hostname>node3</hostname>\n+                <port>44444</port>\n+            </server>\n+        </raft_configuration>\n+    </keeper_server>\n+    <zookeeper>\n+        <node index=\"1\">\n+            <host>node1</host>\n+            <port>9181</port>\n+        </node>\n+        <node index=\"2\">\n+            <host>node2</host>\n+            <port>9181</port>\n+        </node>\n+        <node index=\"3\">\n+            <host>node3</host>\n+            <port>9181</port>\n+        </node>\n+    </zookeeper>\n+</yandex>\ndiff --git a/tests/integration/test_keeper_four_word_command/configs/keeper_config_without_white_list.xml b/tests/integration/test_keeper_four_word_command/configs/keeper_config_without_white_list.xml\nnew file mode 100644\nindex 000000000000..084b9a636542\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/configs/keeper_config_without_white_list.xml\n@@ -0,0 +1,37 @@\n+<yandex>\n+    <keeper_server>\n+        <tcp_port>9181</tcp_port>\n+        <server_id>2</server_id>\n+        <raft_configuration>\n+            <server>\n+                <id>1</id>\n+                <hostname>node1</hostname>\n+                <port>44444</port>\n+            </server>\n+            <server>\n+                <id>2</id>\n+                <hostname>node2</hostname>\n+                <port>44444</port>\n+            </server>\n+            <server>\n+                <id>3</id>\n+                <hostname>node3</hostname>\n+                <port>44444</port>\n+            </server>\n+        </raft_configuration>\n+    </keeper_server>\n+    <zookeeper>\n+        <node index=\"1\">\n+            <host>node1</host>\n+            <port>9181</port>\n+        </node>\n+        <node index=\"2\">\n+            <host>node2</host>\n+            <port>9181</port>\n+        </node>\n+        <node index=\"3\">\n+            <host>node3</host>\n+            <port>9181</port>\n+        </node>\n+    </zookeeper>\n+</yandex>\ndiff --git a/tests/integration/test_keeper_four_word_command/test.py b/tests/integration/test_keeper_four_word_command/test.py\nnew file mode 100644\nindex 000000000000..6ea123420449\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/test.py\n@@ -0,0 +1,611 @@\n+import socket\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+import random\n+import string\n+import os\n+import time\n+from multiprocessing.dummy import Pool\n+from helpers.network import PartitionManager\n+from helpers.test_tools import assert_eq_with_retry\n+from io import StringIO\n+import csv\n+import re\n+\n+cluster = ClickHouseCluster(__file__)\n+node1 = cluster.add_instance('node1', main_configs=['configs/enable_keeper1.xml'],\n+                             stay_alive=True)\n+node2 = cluster.add_instance('node2', main_configs=['configs/enable_keeper2.xml'],\n+                             stay_alive=True)\n+node3 = cluster.add_instance('node3', main_configs=['configs/enable_keeper3.xml'],\n+                             stay_alive=True)\n+\n+from kazoo.client import KazooClient, KazooState\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def destroy_zk_client(zk):\n+    try:\n+        if zk:\n+            zk.stop()\n+            zk.close()\n+    except:\n+        pass\n+\n+\n+def clear_znodes():\n+    zk = None\n+    try:\n+        zk = get_fake_zk(node3.name, timeout=30.0)\n+        nodes = zk.get_children('/')\n+        for node in [n for n in nodes if 'test_4lw_' in n]:\n+            zk.delete('/' + node)\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def wait_node(node):\n+    for _ in range(100):\n+        zk = None\n+        try:\n+            zk = get_fake_zk(node.name, timeout=30.0)\n+            # zk.create(\"/test\", sequence=True)\n+            print(\"node\", node.name, \"ready\")\n+            break\n+        except Exception as ex:\n+            time.sleep(0.2)\n+            print(\"Waiting until\", node.name, \"will be ready, exception\", ex)\n+        finally:\n+            destroy_zk_client(zk)\n+    else:\n+        raise Exception(\"Can't wait node\", node.name, \"to become ready\")\n+\n+\n+def wait_nodes():\n+    for n in [node1, node2, node3]:\n+        wait_node(n)\n+\n+\n+def get_fake_zk(nodename, timeout=30.0):\n+    _fake_zk_instance = KazooClient(hosts=cluster.get_instance_ip(nodename) + \":9181\", timeout=timeout)\n+    _fake_zk_instance.start()\n+    return _fake_zk_instance\n+\n+\n+def get_keeper_socket(node_name):\n+    hosts = cluster.get_instance_ip(node_name)\n+    client = socket.socket()\n+    client.settimeout(10)\n+    client.connect((hosts, 9181))\n+    return client\n+\n+\n+def close_keeper_socket(cli):\n+    if cli is not None:\n+        cli.close()\n+\n+\n+def reset_node_stats(node_name=node1.name):\n+    client = None\n+    try:\n+        client = get_keeper_socket(node_name)\n+        client.send(b'srst')\n+        client.recv(10)\n+    finally:\n+        if client is not None:\n+            client.close()\n+\n+\n+def send_4lw_cmd(node_name=node1.name, cmd='ruok'):\n+    client = None\n+    try:\n+        client = get_keeper_socket(node_name)\n+        client.send(cmd.encode())\n+        data = client.recv(100_000)\n+        data = data.decode()\n+        return data\n+    finally:\n+        if client is not None:\n+            client.close()\n+\n+\n+def reset_conn_stats(node_name=node1.name):\n+    client = None\n+    try:\n+        client = get_keeper_socket(node_name)\n+        client.send(b'crst')\n+        client.recv(10_000)\n+    finally:\n+        if client is not None:\n+            client.close()\n+\n+\n+def test_cmd_ruok(started_cluster):\n+    client = None\n+    try:\n+        wait_nodes()\n+        data = send_4lw_cmd(cmd='ruok')\n+        assert data == 'imok'\n+    finally:\n+        close_keeper_socket(client)\n+\n+\n+def do_some_action(zk, create_cnt=0, get_cnt=0, set_cnt=0, ephemeral_cnt=0, watch_cnt=0, delete_cnt=0):\n+    assert create_cnt >= get_cnt\n+    assert create_cnt >= set_cnt\n+    assert create_cnt >= watch_cnt\n+    assert create_cnt >= delete_cnt\n+    # ensure not delete watched node\n+    assert create_cnt >= (delete_cnt + watch_cnt)\n+\n+    for i in range(create_cnt):\n+        zk.create(\"/test_4lw_normal_node_\" + str(i), b\"\")\n+\n+    for i in range(get_cnt):\n+        zk.get(\"/test_4lw_normal_node_\" + str(i))\n+\n+    for i in range(set_cnt):\n+        zk.set(\"/test_4lw_normal_node_\" + str(i), b\"new-value\")\n+\n+    for i in range(ephemeral_cnt):\n+        zk.create(\"/test_4lw_ephemeral_node_\" + str(i), ephemeral=True)\n+\n+    fake_ephemeral_event = None\n+\n+    def fake_ephemeral_callback(event):\n+        print(\"Fake watch triggered\")\n+        nonlocal fake_ephemeral_event\n+        fake_ephemeral_event = event\n+\n+    for i in range(watch_cnt):\n+        zk.exists(\"/test_4lw_normal_node_\" + str(i), watch=fake_ephemeral_callback)\n+\n+    for i in range(create_cnt - delete_cnt, create_cnt):\n+        zk.delete(\"/test_4lw_normal_node_\" + str(i))\n+\n+\n+def test_cmd_mntr(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+\n+        # reset stat first\n+        reset_node_stats(node1.name)\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=10, get_cnt=10, set_cnt=5, ephemeral_cnt=2, watch_cnt=2, delete_cnt=2)\n+\n+        data = send_4lw_cmd(cmd='mntr')\n+\n+        # print(data.decode())\n+        reader = csv.reader(data.split('\\n'), delimiter='\\t')\n+        result = {}\n+\n+        for row in reader:\n+            if len(row) != 0:\n+                result[row[0]] = row[1]\n+\n+        assert len(result[\"zk_version\"]) != 0\n+\n+        assert int(result[\"zk_avg_latency\"]) >= 0\n+        assert int(result[\"zk_max_latency\"]) >= 0\n+        assert int(result[\"zk_min_latency\"]) >= 0\n+\n+        assert int(result[\"zk_min_latency\"]) <= int(result[\"zk_avg_latency\"])\n+        assert int(result[\"zk_max_latency\"]) >= int(result[\"zk_avg_latency\"])\n+\n+\n+        assert int(result[\"zk_num_alive_connections\"]) == 1\n+        assert int(result[\"zk_outstanding_requests\"]) == 0\n+\n+        assert result[\"zk_server_state\"] == \"leader\"\n+\n+        # contains:\n+        #   10 nodes created by test\n+        #   3 nodes created by clickhouse \"/clickhouse/task_queue/ddl\"\n+        #   1 root node\n+        assert int(result[\"zk_znode_count\"]) == 11\n+        assert int(result[\"zk_watch_count\"]) == 2\n+        assert int(result[\"zk_ephemerals_count\"]) == 2\n+        assert int(result[\"zk_approximate_data_size\"]) > 0\n+\n+        assert int(result[\"zk_open_file_descriptor_count\"]) > 0\n+        assert int(result[\"zk_max_file_descriptor_count\"]) > 0\n+\n+        assert int(result[\"zk_followers\"]) == 2\n+        assert int(result[\"zk_synced_followers\"]) == 2\n+\n+        # contains 31 user request response and some responses for server startup\n+        assert int(result[\"zk_packets_sent\"]) >= 31\n+        assert int(result[\"zk_packets_received\"]) >= 31\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_srst(started_cluster):\n+    client = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+\n+        data = send_4lw_cmd(cmd='srst')\n+        assert data.strip() == \"Server stats reset.\"\n+\n+        data = send_4lw_cmd(cmd='mntr')\n+        assert len(data) != 0\n+\n+        # print(data)\n+        reader = csv.reader(data.split('\\n'), delimiter='\\t')\n+        result = {}\n+\n+        for row in reader:\n+            if len(row) != 0:\n+                result[row[0]] = row[1]\n+\n+        assert int(result[\"zk_packets_received\"]) == 0\n+        assert int(result[\"zk_packets_sent\"]) == 0\n+\n+    finally:\n+        close_keeper_socket(client)\n+\n+\n+def test_cmd_conf(started_cluster):\n+    client = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+\n+        data = send_4lw_cmd(cmd='conf')\n+\n+        reader = csv.reader(data.split('\\n'), delimiter='=')\n+        result = {}\n+\n+        for row in reader:\n+            if len(row) != 0:\n+                print(row)\n+                result[row[0]] = row[1]\n+\n+        assert result[\"server_id\"] == \"1\"\n+        assert result[\"tcp_port\"] == \"9181\"\n+        assert \"tcp_port_secure\" not in result\n+        assert \"superdigest\" not in result\n+\n+        assert result[\"four_letter_word_white_list\"] == \"*\"\n+        assert result[\"log_storage_path\"] == \"/var/lib/clickhouse/coordination/log\"\n+        assert result[\"snapshot_storage_path\"] == \"/var/lib/clickhouse/coordination/snapshots\"\n+\n+        assert result[\"session_timeout_ms\"] == \"30000\"\n+        assert result[\"operation_timeout_ms\"] == \"5000\"\n+        assert result[\"dead_session_check_period_ms\"] == \"500\"\n+        assert result[\"heart_beat_interval_ms\"] == \"500\"\n+        assert result[\"election_timeout_lower_bound_ms\"] == \"1000\"\n+        assert result[\"election_timeout_upper_bound_ms\"] == \"2000\"\n+        assert result[\"reserved_log_items\"] == \"100000\"\n+\n+        assert result[\"snapshot_distance\"] == \"75\"\n+        assert result[\"auto_forwarding\"] == \"true\"\n+        assert result[\"shutdown_timeout\"] == \"5000\"\n+        assert result[\"startup_timeout\"] == \"180000\"\n+\n+        assert result[\"raft_logs_level\"] == \"trace\"\n+        assert result[\"rotate_log_storage_interval\"] == \"100000\"\n+        assert result[\"snapshots_to_keep\"] == \"3\"\n+        assert result[\"stale_log_gap\"] == \"10000\"\n+        assert result[\"fresh_log_gap\"] == \"200\"\n+\n+        assert result[\"max_requests_batch_size\"] == \"100\"\n+        assert result[\"quorum_reads\"] == \"false\"\n+        assert result[\"force_sync\"] == \"true\"\n+\n+        assert result[\"compress_logs\"] == \"true\"\n+        assert result[\"compress_snapshots_with_zstd_format\"] == \"true\"\n+        assert result[\"configuration_change_tries_count\"] == \"20\"\n+\n+    finally:\n+        close_keeper_socket(client)\n+\n+\n+def test_cmd_isro(started_cluster):\n+    wait_nodes()\n+    assert send_4lw_cmd(node1.name, 'isro') == 'rw'\n+    assert send_4lw_cmd(node2.name, 'isro') == 'ro'\n+\n+\n+def test_cmd_srvr(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+\n+        reset_node_stats(node1.name)\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=10)\n+\n+        data = send_4lw_cmd(cmd='srvr')\n+\n+        print(\"srvr output -------------------------------------\")\n+        print(data)\n+\n+        reader = csv.reader(data.split('\\n'), delimiter=':')\n+        result = {}\n+\n+        for row in reader:\n+            if len(row) != 0:\n+                result[row[0].strip()] = row[1].strip()\n+\n+        assert 'ClickHouse Keeper version' in result\n+        assert 'Latency min/avg/max' in result\n+        assert result['Received'] == '10'\n+        assert result['Sent'] == '10'\n+        assert int(result['Connections']) == 1\n+        assert int(result['Zxid']) > 14\n+        assert result['Mode'] == 'leader'\n+        assert result['Node count'] == '11'\n+\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_stat(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_node_stats(node1.name)\n+        reset_conn_stats(node1.name)\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=10)\n+\n+        data = send_4lw_cmd(cmd='stat')\n+\n+        print(\"stat output -------------------------------------\")\n+        print(data)\n+\n+        # keeper statistics\n+        stats = [n for n in data.split('\\n') if '=' not in n]\n+        reader = csv.reader(stats, delimiter=':')\n+        result = {}\n+\n+        for row in reader:\n+            if len(row) != 0:\n+                result[row[0].strip()] = row[1].strip()\n+\n+        assert 'ClickHouse Keeper version' in result\n+        assert 'Latency min/avg/max' in result\n+        assert result['Received'] == '10'\n+        assert result['Sent'] == '10'\n+        assert int(result['Connections']) == 1\n+        assert int(result['Zxid']) > 14\n+        assert result['Mode'] == 'leader'\n+        assert result['Node count'] == '11'\n+\n+        # filter connection statistics\n+        cons = [n for n in data.split('\\n') if '=' in n]\n+        # filter connection created by 'cons'\n+        cons = [n for n in cons if 'recved=0' not in n and len(n) > 0]\n+        assert len(cons) == 1\n+\n+        conn_stat = re.match(r'(.*?)[:].*[(](.*?)[)].*', cons[0].strip(), re.S).group(2)\n+        assert conn_stat is not None\n+\n+        result = {}\n+        for col in conn_stat.split(','):\n+            col = col.strip().split('=')\n+            result[col[0]] = col[1]\n+\n+        assert result['recved'] == '10'\n+        assert result['sent'] == '10'\n+\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_cons(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_conn_stats()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=10)\n+\n+        data = send_4lw_cmd(cmd='cons')\n+\n+        print(\"cons output -------------------------------------\")\n+        print(data)\n+\n+        # filter connection created by 'cons'\n+        cons = [n for n in data.split('\\n') if 'recved=0' not in n and len(n) > 0]\n+        assert len(cons) == 1\n+\n+        conn_stat = re.match(r'(.*?)[:].*[(](.*?)[)].*', cons[0].strip(), re.S).group(2)\n+        assert conn_stat is not None\n+\n+        result = {}\n+        for col in conn_stat.split(','):\n+            col = col.strip().split('=')\n+            result[col[0]] = col[1]\n+\n+        assert result['recved'] == '10'\n+        assert result['sent'] == '10'\n+        assert 'sid' in result\n+        assert result['lop'] == 'Create'\n+        assert 'est' in result\n+        assert result['to'] == '30000'\n+        assert result['lcxid'] == '0x000000000000000a'\n+        assert 'lzxid' in result\n+        assert 'lresp' in result\n+        assert int(result['llat']) >= 0\n+        assert int(result['minlat']) >= 0\n+        assert int(result['avglat']) >= 0\n+        assert int(result['maxlat']) >= 0\n+\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_crst(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_conn_stats()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=10)\n+\n+        data = send_4lw_cmd(cmd='crst')\n+\n+        print(\"crst output -------------------------------------\")\n+        print(data)\n+\n+        data = send_4lw_cmd(cmd='cons')\n+\n+        # 2 connections, 1 for 'cons' command, 1 for zk\n+        cons = [n for n in data.split('\\n') if len(n) > 0]\n+        assert len(cons) == 2\n+\n+        conn_stat = re.match(r'(.*?)[:].*[(](.*?)[)].*', cons[0].strip(), re.S).group(2)\n+        assert conn_stat is not None\n+\n+        result = {}\n+        for col in conn_stat.split(','):\n+            col = col.strip().split('=')\n+            result[col[0]] = col[1]\n+\n+        assert result['recved'] == '0'\n+        assert result['sent'] == '0'\n+        assert 'sid' in result\n+        assert result['lop'] == 'NA'\n+        assert 'est' in result\n+        assert result['to'] == '30000'\n+        assert 'lcxid' not in result\n+        assert result['lzxid'] == '0xffffffffffffffff'\n+        assert result['lresp'] == '0'\n+        assert int(result['llat']) == 0\n+        assert int(result['minlat']) == 0\n+        assert int(result['avglat']) == 0\n+        assert int(result['maxlat']) == 0\n+\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_dump(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_node_stats()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, ephemeral_cnt=2)\n+\n+        data = send_4lw_cmd(cmd='dump')\n+\n+        print(\"dump output -------------------------------------\")\n+        print(data)\n+\n+        list_data = data.split('\\n')\n+\n+        session_count = int(re.match(r'.*[(](.*?)[)].*', list_data[0], re.S).group(1))\n+        assert session_count == 1\n+\n+        assert '\\t' + '/test_4lw_ephemeral_node_0' in list_data\n+        assert '\\t' + '/test_4lw_ephemeral_node_1' in list_data\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_wchs(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_node_stats()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=2, watch_cnt=2)\n+\n+        data = send_4lw_cmd(cmd='wchs')\n+\n+        print(\"wchs output -------------------------------------\")\n+        print(data)\n+\n+        list_data = [n for n in data.split('\\n') if len(n.strip()) > 0]\n+\n+        # 37 connections watching 632141 paths\n+        # Total watches:632141\n+        matcher = re.match(r'([0-9].*) connections watching ([0-9].*) paths', list_data[0], re.S)\n+        conn_count = int(matcher.group(1))\n+        watch_path_count = int(matcher.group(2))\n+        watch_count = int(re.match(r'Total watches:([0-9].*)', list_data[1], re.S).group(1))\n+\n+        assert conn_count == 1\n+        assert watch_path_count == 2\n+        assert watch_count == 2\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_wchc(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_node_stats()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=2, watch_cnt=2)\n+\n+        data = send_4lw_cmd(cmd='wchc')\n+\n+        print(\"wchc output -------------------------------------\")\n+        print(data)\n+\n+        list_data = [n for n in data.split('\\n') if len(n.strip()) > 0]\n+\n+        assert len(list_data) == 3\n+        assert '\\t' + '/test_4lw_normal_node_0' in list_data\n+        assert '\\t' + '/test_4lw_normal_node_1' in list_data\n+    finally:\n+        destroy_zk_client(zk)\n+\n+\n+def test_cmd_wchp(started_cluster):\n+    zk = None\n+    try:\n+        wait_nodes()\n+        clear_znodes()\n+        reset_node_stats()\n+\n+        zk = get_fake_zk(node1.name, timeout=30.0)\n+        do_some_action(zk, create_cnt=2, watch_cnt=2)\n+\n+        data = send_4lw_cmd(cmd='wchp')\n+\n+        print(\"wchp output -------------------------------------\")\n+        print(data)\n+\n+        list_data = [n for n in data.split('\\n') if len(n.strip()) > 0]\n+\n+        assert len(list_data) == 4\n+        assert '/test_4lw_normal_node_0' in list_data\n+        assert '/test_4lw_normal_node_1' in list_data\n+    finally:\n+        destroy_zk_client(zk)\n+\ndiff --git a/tests/integration/test_keeper_four_word_command/test_white_list.py b/tests/integration/test_keeper_four_word_command/test_white_list.py\nnew file mode 100644\nindex 000000000000..edb30c257460\n--- /dev/null\n+++ b/tests/integration/test_keeper_four_word_command/test_white_list.py\n@@ -0,0 +1,98 @@\n+import socket\n+import pytest\n+from helpers.cluster import ClickHouseCluster\n+import time\n+\n+cluster = ClickHouseCluster(__file__)\n+node1 = cluster.add_instance('node1', main_configs=['configs/keeper_config_with_white_list.xml'], stay_alive=True)\n+node2 = cluster.add_instance('node2', main_configs=['configs/keeper_config_without_white_list.xml'], stay_alive=True)\n+node3 = cluster.add_instance('node3', main_configs=['configs/keeper_config_with_white_list_all.xml'], stay_alive=True)\n+\n+from kazoo.client import KazooClient, KazooState\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def destroy_zk_client(zk):\n+    try:\n+        if zk:\n+            zk.stop()\n+            zk.close()\n+    except:\n+        pass\n+\n+\n+def wait_node(node):\n+    for _ in range(100):\n+        zk = None\n+        try:\n+            node.query(\"SELECT * FROM system.zookeeper WHERE path = '/'\")\n+            zk = get_fake_zk(node.name, timeout=30.0)\n+            # zk.create(\"/test\", sequence=True)\n+            print(\"node\", node.name, \"ready\")\n+            break\n+        except Exception as ex:\n+            time.sleep(0.2)\n+            print(\"Waiting until\", node.name, \"will be ready, exception\", ex)\n+        finally:\n+            destroy_zk_client(zk)\n+    else:\n+        raise Exception(\"Can't wait node\", node.name, \"to become ready\")\n+\n+\n+def wait_nodes():\n+    for n in [node1, node2, node3]:\n+        wait_node(n)\n+\n+\n+def get_keeper_socket(nodename):\n+    hosts = cluster.get_instance_ip(nodename)\n+    client = socket.socket()\n+    client.settimeout(10)\n+    client.connect((hosts, 9181))\n+    return client\n+\n+\n+def get_fake_zk(nodename, timeout=30.0):\n+    _fake_zk_instance = KazooClient(hosts=cluster.get_instance_ip(nodename) + \":9181\", timeout=timeout)\n+    _fake_zk_instance.start()\n+    return _fake_zk_instance\n+\n+\n+def close_keeper_socket(cli):\n+    if cli is not None:\n+        print(\"close socket\")\n+        cli.close()\n+\n+\n+def send_cmd(node_name, command = \"ruok\"):\n+    client = None\n+    try:\n+        wait_nodes()\n+        client = get_keeper_socket(node_name)\n+        client.send(command.encode())\n+        data = client.recv(4)\n+        return data.decode()\n+    finally:\n+        close_keeper_socket(client)\n+\n+\n+def test_white_list(started_cluster):\n+    client = None\n+    try:\n+        wait_nodes()\n+        assert send_cmd(node1.name) == 'imok'\n+        assert send_cmd(node1.name, command = 'mntr') == ''\n+        assert send_cmd(node2.name) == 'imok'\n+        assert send_cmd(node3.name) == 'imok'\n+    finally:\n+        close_keeper_socket(client)\ndiff --git a/tests/queries/0_stateless/02122_4letter_words_stress_zookeeper.reference b/tests/queries/0_stateless/02122_4letter_words_stress_zookeeper.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02122_4letter_words_stress_zookeeper.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/02122_4letter_words_stress_zookeeper.sh b/tests/queries/0_stateless/02122_4letter_words_stress_zookeeper.sh\nnew file mode 100755\nindex 000000000000..4a94beddbba2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02122_4letter_words_stress_zookeeper.sh\n@@ -0,0 +1,47 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+\n+function four_letter_thread()\n+{\n+    declare -a FOUR_LETTER_COMMANDS=(\"conf\" \"cons\" \"crst\" \"envi\" \"ruok\" \"srst\" \"srvr\" \"stat\" \"wchc\" \"wchs\" \"dirs\" \"mntr\" \"isro\")\n+    while true; do\n+        command=${FOUR_LETTER_COMMANDS[$RANDOM % ${#FOUR_LETTER_COMMANDS[@]} ]}\n+        echo $command | nc ${CLICKHOUSE_HOST} ${CLICKHOUSE_PORT_KEEPER} 1>/dev/null\n+    done\n+\n+}\n+\n+function create_drop_thread()\n+{\n+    while true; do\n+        num=$RANDOM\n+        $CLICKHOUSE_CLIENT --query \"CREATE TABLE test_table$num (key UInt64, value1 UInt8, value2 UInt8) ENGINE = ReplicatedMergeTree('/clickhouse/tables/$CLICKHOUSE_TEST_ZOOKEEPER_PREFIX/test_table$num', '0') ORDER BY key\"\n+        sleep 0.$RANDOM\n+        $CLICKHOUSE_CLIENT --query \"DROP TABLE IF EXISTS test_table$num\"\n+    done\n+}\n+\n+export -f four_letter_thread;\n+export -f create_drop_thread;\n+\n+TIMEOUT=15\n+\n+timeout $TIMEOUT bash -c four_letter_thread 2> /dev/null &\n+timeout $TIMEOUT bash -c four_letter_thread 2> /dev/null &\n+timeout $TIMEOUT bash -c four_letter_thread 2> /dev/null &\n+timeout $TIMEOUT bash -c four_letter_thread 2> /dev/null &\n+\n+timeout $TIMEOUT bash -c create_drop_thread 2> /dev/null &\n+timeout $TIMEOUT bash -c create_drop_thread 2> /dev/null &\n+timeout $TIMEOUT bash -c create_drop_thread 2> /dev/null &\n+timeout $TIMEOUT bash -c create_drop_thread 2> /dev/null &\n+\n+\n+wait\n+\n+# still alive\n+$CLICKHOUSE_CLIENT --query \"SELECT 1\"\ndiff --git a/tests/queries/shell_config.sh b/tests/queries/shell_config.sh\nindex 1f802ddab7bb..e95f84336363 100644\n--- a/tests/queries/shell_config.sh\n+++ b/tests/queries/shell_config.sh\n@@ -73,6 +73,8 @@ export CLICKHOUSE_PORT_MYSQL=${CLICKHOUSE_PORT_MYSQL:=$(${CLICKHOUSE_EXTRACT_CON\n export CLICKHOUSE_PORT_MYSQL=${CLICKHOUSE_PORT_MYSQL:=\"9004\"}\n export CLICKHOUSE_PORT_POSTGRESQL=${CLICKHOUSE_PORT_POSTGRESQL:=$(${CLICKHOUSE_EXTRACT_CONFIG} --try --key=postgresql_port 2>/dev/null)} 2>/dev/null\n export CLICKHOUSE_PORT_POSTGRESQL=${CLICKHOUSE_PORT_POSTGRESQL:=\"9005\"}\n+export CLICKHOUSE_PORT_KEEPER=${CLICKHOUSE_PORT_KEEPER:=$(${CLICKHOUSE_EXTRACT_CONFIG} --try --key=keeper_server.tcp_port 2>/dev/null)} 2>/dev/null\n+export CLICKHOUSE_PORT_KEEPER=${CLICKHOUSE_PORT_KEEPER:=\"9181\"}\n \n export CLICKHOUSE_CLIENT_SECURE=${CLICKHOUSE_CLIENT_SECURE:=$(echo \"${CLICKHOUSE_CLIENT}\" | sed 's/'\"--port=${CLICKHOUSE_PORT_TCP}\"'//g; s/$/'\"--secure --port=${CLICKHOUSE_PORT_TCP_SECURE}\"'/g')}\n \n",
  "problem_statement": "Add 4 letters words to NuRaftKeeper\n**Use case**\r\n\r\nTo monitor NuRaftKeeper internal status such as server info, client info, watch info, ephemeral nodes info etc. Zookeeper provides 4 letters admin tool. You can check it [here](https://zookeeper.apache.org/doc/r3.4.8/zookeeperAdmin.html#sc_zkCommands).\r\n\r\n**Describe the solution you'd like**\r\n\r\n1. When startup register 4 letter word command with a <code, command_executor> map. The code is name reinterpreted int32.\r\n2. When new connection comes, first extract the first 4 characters and check whether it is 4lw command, if yes, run the command.\r\n3. add some methods to `KeeperStorageDispatcher` to   collect server info.\r\n\r\nBecause the first request of a connection is hand shake request whose first 4 characters is request length and the length is fixed 44 or 45.  All  4lw code is larger than 2^24 or lower than 0, so collision never happens. \r\n\r\nIn JD, we already added some 4lw commands to `SvsKeeper` which is a NuRaft based system like`NuRaftKeeper` . If the idea is ok, I'd like to add it to `NuRaftKeeper`\r\n\n",
  "hints_text": "https://github.com/ClickHouse/ClickHouse/issues/26976",
  "created_at": "2021-09-13T13:01:32Z"
}