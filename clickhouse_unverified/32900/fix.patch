diff --git a/base/mysqlxx/Row.cpp b/base/mysqlxx/Row.cpp
index aecec46e5194..861a04f8ecec 100644
--- a/base/mysqlxx/Row.cpp
+++ b/base/mysqlxx/Row.cpp
@@ -21,4 +21,12 @@ Value Row::operator[] (const char * name) const
     throw Exception(std::string("Unknown column ") + name);
 }
 
+enum enum_field_types Row::getFieldType(size_t i)
+{
+    if (i >= res->getNumFields())
+        throw Exception(std::string("Array Index Overflow"));
+    MYSQL_FIELDS fields = res->getFields();
+    return fields[i].type;
+}
+
 }
diff --git a/base/mysqlxx/Row.h b/base/mysqlxx/Row.h
index d668fdbd29ac..b11d7d628ef8 100644
--- a/base/mysqlxx/Row.h
+++ b/base/mysqlxx/Row.h
@@ -79,6 +79,8 @@ class Row
       */
     operator private_bool_type() const { return row == nullptr ? nullptr : &Row::row; }
 
+    enum enum_field_types getFieldType(size_t i);
+
 private:
     MYSQL_ROW row{};
     ResultBase * res{};
diff --git a/base/mysqlxx/Types.h b/base/mysqlxx/Types.h
index b5ed70916faf..5fd9aa8bbc88 100644
--- a/base/mysqlxx/Types.h
+++ b/base/mysqlxx/Types.h
@@ -16,6 +16,8 @@ using MYSQL_ROW = char**;
 struct st_mysql_field;
 using MYSQL_FIELD = st_mysql_field;
 
+enum struct enum_field_types;
+
 #endif
 
 namespace mysqlxx
diff --git a/docs/en/engines/database-engines/materialized-mysql.md b/docs/en/engines/database-engines/materialized-mysql.md
index 944264b68a35..b8b49634735e 100644
--- a/docs/en/engines/database-engines/materialized-mysql.md
+++ b/docs/en/engines/database-engines/materialized-mysql.md
@@ -83,6 +83,7 @@ When working with the `MaterializedMySQL` database engine, [ReplacingMergeTree](
 | VARCHAR, VAR_STRING     | [String](../../sql-reference/data-types/string.md)           |
 | BLOB                    | [String](../../sql-reference/data-types/string.md)           |
 | BINARY                  | [FixedString](../../sql-reference/data-types/fixedstring.md) |
+| BIT                     | [UInt64](../../sql-reference/data-types/int-uint.md)         |
 
 [Nullable](../../sql-reference/data-types/nullable.md) is supported.
 
diff --git a/src/Core/MySQL/MySQLReplication.cpp b/src/Core/MySQL/MySQLReplication.cpp
index f734154f4ba2..d6094b0b212e 100644
--- a/src/Core/MySQL/MySQLReplication.cpp
+++ b/src/Core/MySQL/MySQLReplication.cpp
@@ -230,6 +230,7 @@ namespace MySQLReplication
                     pos += 2;
                     break;
                 }
+                case MYSQL_TYPE_BIT:
                 case MYSQL_TYPE_VARCHAR:
                 case MYSQL_TYPE_VAR_STRING: {
                     /// Little-Endian
@@ -584,6 +585,15 @@ namespace MySQLReplication
                         }
                         break;
                     }
+                    case MYSQL_TYPE_BIT:
+                    {
+                        UInt32 bits = ((meta >> 8) * 8) + (meta & 0xff);
+                        UInt32 size = (bits + 7) / 8;
+                        UInt64 val = 0UL;
+                        readBigEndianStrict(payload, reinterpret_cast<char *>(&val), size);
+                        row.push_back(val);
+                        break;
+                    }
                     case MYSQL_TYPE_VARCHAR:
                     case MYSQL_TYPE_VAR_STRING:
                     {
diff --git a/src/DataTypes/DataTypesNumber.cpp b/src/DataTypes/DataTypesNumber.cpp
index fef4c34d8b05..0c9a410077fc 100644
--- a/src/DataTypes/DataTypesNumber.cpp
+++ b/src/DataTypes/DataTypesNumber.cpp
@@ -86,6 +86,7 @@ void registerDataTypeNumbers(DataTypeFactory & factory)
     factory.registerAlias("INT UNSIGNED", "UInt32", DataTypeFactory::CaseInsensitive);
     factory.registerAlias("INTEGER UNSIGNED", "UInt32", DataTypeFactory::CaseInsensitive);
     factory.registerAlias("BIGINT UNSIGNED", "UInt64", DataTypeFactory::CaseInsensitive);
+    factory.registerAlias("BIT", "UInt64", DataTypeFactory::CaseInsensitive);
 }
 
 }
diff --git a/src/DataTypes/convertMySQLDataType.cpp b/src/DataTypes/convertMySQLDataType.cpp
index 1b5e20bddce3..ee897de95979 100644
--- a/src/DataTypes/convertMySQLDataType.cpp
+++ b/src/DataTypes/convertMySQLDataType.cpp
@@ -91,6 +91,10 @@ DataTypePtr convertMySQLDataType(MultiEnum<MySQLDataTypesSupport> type_support,
             res = std::make_shared<DataTypeDateTime64>(scale);
         }
     }
+    else if (type_name == "bit")
+    {
+        res = std::make_shared<DataTypeUInt64>();
+    }
     else if (type_support.isSet(MySQLDataTypesSupport::DECIMAL) && (type_name == "numeric" || type_name == "decimal"))
     {
         if (precision <= DecimalUtils::max_precision<Decimal32>)
diff --git a/src/Processors/Sources/MySQLSource.cpp b/src/Processors/Sources/MySQLSource.cpp
index 8e9cdcfda48a..b0cb62340e90 100644
--- a/src/Processors/Sources/MySQLSource.cpp
+++ b/src/Processors/Sources/MySQLSource.cpp
@@ -2,6 +2,7 @@
 
 #if USE_MYSQL
 #include <vector>
+#include <Core/MySQL/MySQLReplication.h>
 #include <Columns/ColumnNullable.h>
 #include <Columns/ColumnString.h>
 #include <Columns/ColumnsNumber.h>
@@ -126,7 +127,7 @@ namespace
 {
     using ValueType = ExternalResultDescription::ValueType;
 
-    void insertValue(const IDataType & data_type, IColumn & column, const ValueType type, const mysqlxx::Value & value, size_t & read_bytes_size)
+    void insertValue(const IDataType & data_type, IColumn & column, const ValueType type, const mysqlxx::Value & value, size_t & read_bytes_size, enum enum_field_types mysql_type)
     {
         switch (type)
         {
@@ -143,9 +144,24 @@ namespace
                 read_bytes_size += 4;
                 break;
             case ValueType::vtUInt64:
-                assert_cast<ColumnUInt64 &>(column).insertValue(value.getUInt());
-                read_bytes_size += 8;
+            {
+                //we don't have enum enum_field_types definition in mysqlxx/Types.h, so we use literal values directly here.
+                if (static_cast<int>(mysql_type) == 16)
+                {
+                    size_t n = value.size();
+                    UInt64 val = 0UL;
+                    ReadBufferFromMemory payload(const_cast<char *>(value.data()), n);
+                    MySQLReplication::readBigEndianStrict(payload, reinterpret_cast<char *>(&val), n);
+                    assert_cast<ColumnUInt64 &>(column).insertValue(val);
+                    read_bytes_size += n;
+                }
+                else
+                {
+                    assert_cast<ColumnUInt64 &>(column).insertValue(value.getUInt());
+                    read_bytes_size += 8;
+                }
                 break;
+            }
             case ValueType::vtInt8:
                 assert_cast<ColumnInt8 &>(column).insertValue(value.getInt());
                 read_bytes_size += 1;
@@ -258,12 +274,12 @@ Chunk MySQLSource::generate()
                 {
                     ColumnNullable & column_nullable = assert_cast<ColumnNullable &>(*columns[index]);
                     const auto & data_type = assert_cast<const DataTypeNullable &>(*sample.type);
-                    insertValue(*data_type.getNestedType(), column_nullable.getNestedColumn(), description.types[index].first, value, read_bytes_size);
+                    insertValue(*data_type.getNestedType(), column_nullable.getNestedColumn(), description.types[index].first, value, read_bytes_size, row.getFieldType(position_mapping[index]));
                     column_nullable.getNullMapData().emplace_back(false);
                 }
                 else
                 {
-                    insertValue(*sample.type, *columns[index], description.types[index].first, value, read_bytes_size);
+                    insertValue(*sample.type, *columns[index], description.types[index].first, value, read_bytes_size, row.getFieldType(position_mapping[index]));
                 }
             }
             else
