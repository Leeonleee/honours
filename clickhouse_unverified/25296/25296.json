{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25296,
  "instance_id": "ClickHouse__ClickHouse-25296",
  "issue_numbers": [
    "25216"
  ],
  "base_commit": "d68338a7921f8e9bec667df6e35e679ac89c3774",
  "patch": "diff --git a/programs/library-bridge/Handlers.cpp b/programs/library-bridge/Handlers.cpp\nindex 6a1bfbbccb76..ec82d7d52f4e 100644\n--- a/programs/library-bridge/Handlers.cpp\n+++ b/programs/library-bridge/Handlers.cpp\n@@ -51,7 +51,7 @@ namespace\n void LibraryRequestHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n {\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n-    HTMLForm params(request);\n+    HTMLForm params(getContext()->getSettingsRef(), request);\n \n     if (!params.has(\"method\"))\n     {\ndiff --git a/programs/odbc-bridge/ColumnInfoHandler.cpp b/programs/odbc-bridge/ColumnInfoHandler.cpp\nindex f4f575bb33d0..4b503afb3b34 100644\n--- a/programs/odbc-bridge/ColumnInfoHandler.cpp\n+++ b/programs/odbc-bridge/ColumnInfoHandler.cpp\n@@ -69,7 +69,7 @@ namespace\n \n void ODBCColumnsInfoHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n {\n-    HTMLForm params(request, request.getStream());\n+    HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n \n     auto process_error = [&response, this](const std::string & message)\ndiff --git a/programs/odbc-bridge/IdentifierQuoteHandler.cpp b/programs/odbc-bridge/IdentifierQuoteHandler.cpp\nindex 124a5c420f85..356c2aadee18 100644\n--- a/programs/odbc-bridge/IdentifierQuoteHandler.cpp\n+++ b/programs/odbc-bridge/IdentifierQuoteHandler.cpp\n@@ -21,7 +21,7 @@ namespace DB\n {\n void IdentifierQuoteHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n {\n-    HTMLForm params(request, request.getStream());\n+    HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n \n     auto process_error = [&response, this](const std::string & message)\ndiff --git a/programs/odbc-bridge/MainHandler.cpp b/programs/odbc-bridge/MainHandler.cpp\nindex ffa636e8b491..edfd2be0decb 100644\n--- a/programs/odbc-bridge/MainHandler.cpp\n+++ b/programs/odbc-bridge/MainHandler.cpp\n@@ -50,7 +50,7 @@ void ODBCHandler::processError(HTTPServerResponse & response, const std::string\n \n void ODBCHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n {\n-    HTMLForm params(request);\n+    HTMLForm params(getContext()->getSettingsRef(), request);\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n \n     if (mode == \"read\")\ndiff --git a/programs/odbc-bridge/SchemaAllowedHandler.cpp b/programs/odbc-bridge/SchemaAllowedHandler.cpp\nindex 3a20148780d1..af10d8f50cd9 100644\n--- a/programs/odbc-bridge/SchemaAllowedHandler.cpp\n+++ b/programs/odbc-bridge/SchemaAllowedHandler.cpp\n@@ -28,7 +28,7 @@ namespace\n \n void SchemaAllowedHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n {\n-    HTMLForm params(request, request.getStream());\n+    HTMLForm params(getContext()->getSettingsRef(), request, request.getStream());\n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n \n     auto process_error = [&response, this](const std::string & message)\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 2aed174c0888..3b91e26cd4f9 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -234,6 +234,9 @@ class IColumn;\n     M(Seconds, http_send_timeout, DEFAULT_HTTP_READ_BUFFER_TIMEOUT, \"HTTP send timeout\", 0) \\\n     M(Seconds, http_receive_timeout, DEFAULT_HTTP_READ_BUFFER_TIMEOUT, \"HTTP receive timeout\", 0) \\\n     M(UInt64, http_max_uri_size, 1048576, \"Maximum URI length of HTTP request\", 0) \\\n+    M(UInt64, http_max_fields, 1000000, \"Maximum number of fields in HTTP header\", 0) \\\n+    M(UInt64, http_max_field_name_size, 1048576, \"Maximum length of field name in HTTP header\", 0) \\\n+    M(UInt64, http_max_field_value_size, 1048576, \"Maximum length of field value in HTTP header\", 0) \\\n     M(Bool, optimize_throw_if_noop, false, \"If setting is enabled and OPTIMIZE query didn't actually assign a merge then an explanatory exception is thrown\", 0) \\\n     M(Bool, use_index_for_in_with_subqueries, true, \"Try using an index if there is a subquery or a table expression on the right side of the IN operator.\", 0) \\\n     M(Bool, joined_subquery_requires_alias, true, \"Force joined subqueries and table functions to have aliases for correct name qualification.\", 0) \\\ndiff --git a/src/Server/HTTP/HTMLForm.cpp b/src/Server/HTTP/HTMLForm.cpp\nindex 9e0f74dcc331..86e08f3c8e70 100644\n--- a/src/Server/HTTP/HTMLForm.cpp\n+++ b/src/Server/HTTP/HTMLForm.cpp\n@@ -1,5 +1,6 @@\n #include <Server/HTTP/HTMLForm.h>\n \n+#include <Core/Settings.h>\n #include <IO/EmptyReadBuffer.h>\n #include <IO/ReadBufferFromString.h>\n #include <Server/HTTP/ReadHeaders.h>\n@@ -35,38 +36,41 @@ const std::string HTMLForm::ENCODING_MULTIPART = \"multipart/form-data\";\n const int HTMLForm::UNKNOWN_CONTENT_LENGTH = -1;\n \n \n-HTMLForm::HTMLForm() : field_limit(DFL_FIELD_LIMIT), value_length_limit(DFL_MAX_VALUE_LENGTH), encoding(ENCODING_URL)\n+HTMLForm::HTMLForm(const Settings & settings)\n+    : max_fields_number(settings.http_max_fields)\n+    , max_field_name_size(settings.http_max_field_name_size)\n+    , max_field_value_size(settings.http_max_field_value_size)\n+    , encoding(ENCODING_URL)\n {\n }\n \n \n-HTMLForm::HTMLForm(const std::string & encoding_)\n-    : field_limit(DFL_FIELD_LIMIT), value_length_limit(DFL_MAX_VALUE_LENGTH), encoding(encoding_)\n+HTMLForm::HTMLForm(const Settings & settings, const std::string & encoding_) : HTMLForm(settings)\n {\n+    encoding = encoding_;\n }\n \n \n-HTMLForm::HTMLForm(const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody, PartHandler & handler)\n-    : field_limit(DFL_FIELD_LIMIT), value_length_limit(DFL_MAX_VALUE_LENGTH)\n+HTMLForm::HTMLForm(const Settings & settings, const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody, PartHandler & handler)\n+    : HTMLForm(settings)\n {\n     load(request, requestBody, handler);\n }\n \n \n-HTMLForm::HTMLForm(const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody)\n-    : field_limit(DFL_FIELD_LIMIT), value_length_limit(DFL_MAX_VALUE_LENGTH)\n+HTMLForm::HTMLForm(const Settings & settings, const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody) : HTMLForm(settings)\n {\n     load(request, requestBody);\n }\n \n \n-HTMLForm::HTMLForm(const Poco::Net::HTTPRequest & request) : HTMLForm(Poco::URI(request.getURI()))\n+HTMLForm::HTMLForm(const Settings & settings, const Poco::Net::HTTPRequest & request) : HTMLForm(settings, Poco::URI(request.getURI()))\n {\n }\n \n-HTMLForm::HTMLForm(const Poco::URI & uri) : field_limit(DFL_FIELD_LIMIT), value_length_limit(DFL_MAX_VALUE_LENGTH)\n+HTMLForm::HTMLForm(const Settings & settings, const Poco::URI & uri) : HTMLForm(settings)\n {\n-    ReadBufferFromString istr(uri.getRawQuery()); // STYLE_CHECK_ALLOW_STD_STRING_STREAM\n+    ReadBufferFromString istr(uri.getRawQuery());  // STYLE_CHECK_ALLOW_STD_STRING_STREAM\n     readQuery(istr);\n }\n \n@@ -123,7 +127,7 @@ void HTMLForm::readQuery(ReadBuffer & in)\n \n     while (true)\n     {\n-        if (field_limit > 0 && fields == field_limit)\n+        if (max_fields_number > 0 && fields == max_fields_number)\n             throw Poco::Net::HTMLFormException(\"Too many form fields\");\n \n         std::string name;\n@@ -133,7 +137,7 @@ void HTMLForm::readQuery(ReadBuffer & in)\n         {\n             if (ch == '+')\n                 ch = ' ';\n-            if (name.size() < MAX_NAME_LENGTH)\n+            if (name.size() < max_field_name_size)\n                 name += ch;\n             else\n                 throw Poco::Net::HTMLFormException(\"Field name too long\");\n@@ -145,7 +149,7 @@ void HTMLForm::readQuery(ReadBuffer & in)\n             {\n                 if (ch == '+')\n                     ch = ' ';\n-                if (value.size() < value_length_limit)\n+                if (value.size() < max_field_value_size)\n                     value += ch;\n                 else\n                     throw Poco::Net::HTMLFormException(\"Field value too long\");\n@@ -185,11 +189,11 @@ void HTMLForm::readMultipart(ReadBuffer & in_, PartHandler & handler)\n     /// Read each part until next boundary (or last boundary)\n     while (!in.eof())\n     {\n-        if (field_limit && fields > field_limit)\n+        if (max_fields_number && fields > max_fields_number)\n             throw Poco::Net::HTMLFormException(\"Too many form fields\");\n \n         Poco::Net::MessageHeader header;\n-        readHeaders(header, in);\n+        readHeaders(header, in, max_fields_number, max_field_name_size, max_field_value_size);\n         skipToNextLineOrEOF(in);\n \n         NameValueCollection params;\n@@ -209,7 +213,7 @@ void HTMLForm::readMultipart(ReadBuffer & in_, PartHandler & handler)\n \n             while (in.read(ch))\n             {\n-                if (value.size() > value_length_limit)\n+                if (value.size() > max_field_value_size)\n                     throw Poco::Net::HTMLFormException(\"Field value too long\");\n                 value += ch;\n             }\ndiff --git a/src/Server/HTTP/HTMLForm.h b/src/Server/HTTP/HTMLForm.h\nindex ca6bb9048f14..16889b41d803 100644\n--- a/src/Server/HTTP/HTMLForm.h\n+++ b/src/Server/HTTP/HTMLForm.h\n@@ -12,6 +12,8 @@\n namespace DB\n {\n \n+struct Settings;\n+\n class HTMLForm : public Poco::Net::NameValueCollection, private boost::noncopyable\n {\n public:\n@@ -19,31 +21,31 @@ class HTMLForm : public Poco::Net::NameValueCollection, private boost::noncopyab\n \n     enum Options\n     {\n-        OPT_USE_CONTENT_LENGTH = 0x01 // don't use Chunked Transfer-Encoding for multipart requests.\n+        OPT_USE_CONTENT_LENGTH = 0x01,  /// don't use Chunked Transfer-Encoding for multipart requests.\n     };\n \n     /// Creates an empty HTMLForm and sets the\n     /// encoding to \"application/x-www-form-urlencoded\".\n-    HTMLForm();\n+    explicit HTMLForm(const Settings & settings);\n \n     /// Creates an empty HTMLForm that uses the given encoding.\n     /// Encoding must be either \"application/x-www-form-urlencoded\" (which is the default) or \"multipart/form-data\".\n-    explicit HTMLForm(const std::string & encoding);\n+    explicit HTMLForm(const Settings & settings, const std::string & encoding);\n \n     /// Creates a HTMLForm from the given HTTP request.\n     /// Uploaded files are passed to the given PartHandler.\n-    HTMLForm(const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody, PartHandler & handler);\n+    HTMLForm(const Settings & settings, const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody, PartHandler & handler);\n \n     /// Creates a HTMLForm from the given HTTP request.\n     /// Uploaded files are silently discarded.\n-    HTMLForm(const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody);\n+    HTMLForm(const Settings & settings, const Poco::Net::HTTPRequest & request, ReadBuffer & requestBody);\n \n     /// Creates a HTMLForm from the given HTTP request.\n     /// The request must be a GET request and the form data must be in the query string (URL encoded).\n     /// For POST requests, you must use one of the constructors taking an additional input stream for the request body.\n-    explicit HTMLForm(const Poco::Net::HTTPRequest & request);\n+    explicit HTMLForm(const Settings & settings, const Poco::Net::HTTPRequest & request);\n \n-    explicit HTMLForm(const Poco::URI & uri);\n+    explicit HTMLForm(const Settings & settings, const Poco::URI & uri);\n \n     template <typename T>\n     T getParsed(const std::string & key, T default_value)\n@@ -76,13 +78,6 @@ class HTMLForm : public Poco::Net::NameValueCollection, private boost::noncopyab\n     /// This buffer provides data line by line to check for boundary line in a convenient way.\n     class MultipartReadBuffer;\n \n-    enum Limits\n-    {\n-        DFL_FIELD_LIMIT = 100,\n-        MAX_NAME_LENGTH = 1024,\n-        DFL_MAX_VALUE_LENGTH = 256 * 1024\n-    };\n-\n     struct Part\n     {\n         std::string name;\n@@ -91,8 +86,8 @@ class HTMLForm : public Poco::Net::NameValueCollection, private boost::noncopyab\n \n     using PartVec = std::vector<Part>;\n \n-    size_t field_limit;\n-    size_t value_length_limit;\n+    const size_t max_fields_number, max_field_name_size, max_field_value_size;\n+\n     std::string encoding;\n     std::string boundary;\n     PartVec parts;\ndiff --git a/src/Server/HTTP/HTTPServerRequest.cpp b/src/Server/HTTP/HTTPServerRequest.cpp\nindex 69dc8d4dbdaa..788c13557f35 100644\n--- a/src/Server/HTTP/HTTPServerRequest.cpp\n+++ b/src/Server/HTTP/HTTPServerRequest.cpp\n@@ -17,6 +17,9 @@ namespace DB\n {\n HTTPServerRequest::HTTPServerRequest(ContextPtr context, HTTPServerResponse & response, Poco::Net::HTTPServerSession & session)\n     : max_uri_size(context->getSettingsRef().http_max_uri_size)\n+    , max_fields_number(context->getSettingsRef().http_max_fields)\n+    , max_field_name_size(context->getSettingsRef().http_max_field_name_size)\n+    , max_field_value_size(context->getSettingsRef().http_max_field_value_size)\n {\n     response.attachRequest(this);\n \n@@ -110,7 +113,7 @@ void HTTPServerRequest::readRequest(ReadBuffer & in)\n \n     skipToNextLineOrEOF(in);\n \n-    readHeaders(*this, in);\n+    readHeaders(*this, in, max_fields_number, max_field_name_size, max_field_value_size);\n \n     skipToNextLineOrEOF(in);\n \ndiff --git a/src/Server/HTTP/HTTPServerRequest.h b/src/Server/HTTP/HTTPServerRequest.h\nindex a560f907cf07..9e33e78a424d 100644\n--- a/src/Server/HTTP/HTTPServerRequest.h\n+++ b/src/Server/HTTP/HTTPServerRequest.h\n@@ -40,14 +40,14 @@ class HTTPServerRequest : public HTTPRequest\n     /// Limits for basic sanity checks when reading a header\n     enum Limits\n     {\n-        MAX_NAME_LENGTH = 256,\n-        MAX_VALUE_LENGTH = 8192,\n         MAX_METHOD_LENGTH = 32,\n         MAX_VERSION_LENGTH = 8,\n-        MAX_FIELDS_NUMBER = 100,\n     };\n \n     const size_t max_uri_size;\n+    const size_t max_fields_number;\n+    const size_t max_field_name_size;\n+    const size_t max_field_value_size;\n \n     std::unique_ptr<ReadBuffer> stream;\n     Poco::Net::SocketImpl * socket;\ndiff --git a/src/Server/HTTP/ReadHeaders.h b/src/Server/HTTP/ReadHeaders.h\nindex e94cddcf4896..1b0e627f7796 100644\n--- a/src/Server/HTTP/ReadHeaders.h\n+++ b/src/Server/HTTP/ReadHeaders.h\n@@ -8,10 +8,6 @@ namespace DB\n class ReadBuffer;\n \n void readHeaders(\n-    Poco::Net::MessageHeader & headers,\n-    ReadBuffer & in,\n-    size_t max_fields_number = 100,\n-    size_t max_name_length = 256,\n-    size_t max_value_length = 8192);\n+    Poco::Net::MessageHeader & headers, ReadBuffer & in, size_t max_fields_number, size_t max_name_length, size_t max_value_length);\n \n }\ndiff --git a/src/Server/HTTPHandler.cpp b/src/Server/HTTPHandler.cpp\nindex 6eab6cdda5e5..271c1700daf9 100644\n--- a/src/Server/HTTPHandler.cpp\n+++ b/src/Server/HTTPHandler.cpp\n@@ -895,7 +895,7 @@ void HTTPHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse\n         if (request.getVersion() == HTTPServerRequest::HTTP_1_1)\n             response.setChunkedTransferEncoding(true);\n \n-        HTMLForm params(request);\n+        HTMLForm params(request_context->getSettingsRef(), request);\n         with_stacktrace = params.getParsed<bool>(\"stacktrace\", false);\n \n         /// FIXME: maybe this check is already unnecessary.\ndiff --git a/src/Server/InterserverIOHTTPHandler.cpp b/src/Server/InterserverIOHTTPHandler.cpp\nindex 64af8860b230..d76361e856e7 100644\n--- a/src/Server/InterserverIOHTTPHandler.cpp\n+++ b/src/Server/InterserverIOHTTPHandler.cpp\n@@ -50,7 +50,7 @@ std::pair<String, bool> InterserverIOHTTPHandler::checkAuthentication(HTTPServer\n \n void InterserverIOHTTPHandler::processQuery(HTTPServerRequest & request, HTTPServerResponse & response, Output & used_output)\n {\n-    HTMLForm params(request);\n+    HTMLForm params(server.context()->getSettingsRef(), request);\n \n     LOG_TRACE(log, \"Request URI: {}\", request.getURI());\n \ndiff --git a/src/Server/InterserverIOHTTPHandler.h b/src/Server/InterserverIOHTTPHandler.h\nindex c0d776115e1f..da5b286b9e5e 100644\n--- a/src/Server/InterserverIOHTTPHandler.h\n+++ b/src/Server/InterserverIOHTTPHandler.h\n@@ -1,8 +1,8 @@\n #pragma once\n \n+#include <Interpreters/InterserverCredentials.h>\n #include <Server/HTTP/HTTPRequestHandler.h>\n #include <Common/CurrentMetrics.h>\n-#include <Interpreters/InterserverCredentials.h>\n \n #include <Poco/Logger.h>\n \ndiff --git a/src/Server/ReplicasStatusHandler.cpp b/src/Server/ReplicasStatusHandler.cpp\nindex 86295cc5170f..b7dc8c14858a 100644\n--- a/src/Server/ReplicasStatusHandler.cpp\n+++ b/src/Server/ReplicasStatusHandler.cpp\n@@ -18,23 +18,20 @@\n namespace DB\n {\n \n-\n-ReplicasStatusHandler::ReplicasStatusHandler(IServer & server)\n-    : context(server.context())\n+ReplicasStatusHandler::ReplicasStatusHandler(IServer & server) : WithContext(server.context())\n {\n }\n \n-\n void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServerResponse & response)\n {\n     try\n     {\n-        HTMLForm params(request);\n+        HTMLForm params(getContext()->getSettingsRef(), request);\n \n         /// Even if lag is small, output detailed information about the lag.\n         bool verbose = params.get(\"verbose\", \"\") == \"1\";\n \n-        const MergeTreeSettings & settings = context->getReplicatedMergeTreeSettings();\n+        const MergeTreeSettings & settings = getContext()->getReplicatedMergeTreeSettings();\n \n         bool ok = true;\n         WriteBufferFromOwnString message;\n@@ -48,7 +45,7 @@ void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServe\n             if (!db.second->canContainMergeTreeTables())\n                 continue;\n \n-            for (auto iterator = db.second->getTablesIterator(context); iterator->isValid(); iterator->next())\n+            for (auto iterator = db.second->getTablesIterator(getContext()); iterator->isValid(); iterator->next())\n             {\n                 const auto & table = iterator->table();\n                 if (!table)\n@@ -73,7 +70,7 @@ void ReplicasStatusHandler::handleRequest(HTTPServerRequest & request, HTTPServe\n             }\n         }\n \n-        const auto & config = context->getConfigRef();\n+        const auto & config = getContext()->getConfigRef();\n         setResponseDefaultHeaders(response, config.getUInt(\"keep_alive_timeout\", 10));\n \n         if (!ok)\ndiff --git a/src/Server/ReplicasStatusHandler.h b/src/Server/ReplicasStatusHandler.h\nindex eda0b15ed6fe..1a5388aa2abf 100644\n--- a/src/Server/ReplicasStatusHandler.h\n+++ b/src/Server/ReplicasStatusHandler.h\n@@ -9,11 +9,8 @@ class Context;\n class IServer;\n \n /// Replies \"Ok.\\n\" if all replicas on this server don't lag too much. Otherwise output lag information.\n-class ReplicasStatusHandler : public HTTPRequestHandler\n+class ReplicasStatusHandler : public HTTPRequestHandler, WithContext\n {\n-private:\n-    ContextPtr context;\n-\n public:\n     explicit ReplicasStatusHandler(IServer & server_);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01903_http_fields.reference b/tests/queries/0_stateless/01903_http_fields.reference\nnew file mode 100644\nindex 000000000000..c18b4e9b0829\n--- /dev/null\n+++ b/tests/queries/0_stateless/01903_http_fields.reference\n@@ -0,0 +1,8 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/01903_http_fields.sh b/tests/queries/0_stateless/01903_http_fields.sh\nnew file mode 100755\nindex 000000000000..0f2b0df13d9c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01903_http_fields.sh\n@@ -0,0 +1,27 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+DEFAULT_MAX_NAME_SIZE=$($CLICKHOUSE_CLIENT -q \"SELECT value FROM system.settings WHERE name='http_max_field_name_size'\")\n+DEFAULT_MAX_VALUE_SIZE=$($CLICKHOUSE_CLIENT -q \"SELECT value FROM system.settings WHERE name='http_max_field_value_size'\")\n+\n+python3 -c \"print('a'*($DEFAULT_MAX_NAME_SIZE-2) + ';')\" > $CLICKHOUSE_TMP/short_name.txt\n+python3 -c \"print('a'*($DEFAULT_MAX_NAME_SIZE+1) + ';')\" > $CLICKHOUSE_TMP/long_name.txt\n+python3 -c \"print('a'*($DEFAULT_MAX_NAME_SIZE-2) + ': ' + 'b'*($DEFAULT_MAX_VALUE_SIZE-2))\" > $CLICKHOUSE_TMP/short_short.txt\n+python3 -c \"print('a'*($DEFAULT_MAX_NAME_SIZE-2) + ': ' + 'b'*($DEFAULT_MAX_VALUE_SIZE+1))\" > $CLICKHOUSE_TMP/short_long.txt\n+python3 -c \"print('a'*($DEFAULT_MAX_NAME_SIZE+1) + ': ' + 'b'*($DEFAULT_MAX_VALUE_SIZE-2))\" > $CLICKHOUSE_TMP/long_short.txt\n+\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}\" -H @$CLICKHOUSE_TMP/short_name.txt -d 'SELECT 1'\n+${CLICKHOUSE_CURL} -sSv \"${CLICKHOUSE_URL}\" -H @$CLICKHOUSE_TMP/long_name.txt -d 'SELECT 1' 2>&1 | grep -Fc '400 Bad Request'\n+${CLICKHOUSE_CURL} -sS \"${CLICKHOUSE_URL}\" -H @$CLICKHOUSE_TMP/short_short.txt -d 'SELECT 1'\n+${CLICKHOUSE_CURL} -sSv \"${CLICKHOUSE_URL}\" -H @$CLICKHOUSE_TMP/short_long.txt -d 'SELECT 1' 2>&1 | grep -Fc '400 Bad Request'\n+${CLICKHOUSE_CURL} -sSv \"${CLICKHOUSE_URL}\" -H @$CLICKHOUSE_TMP/long_short.txt -d 'SELECT 1' 2>&1 | grep -Fc '400 Bad Request'\n+\n+# Session and query settings shouldn't affect the HTTP field's name or value sizes.\n+${CLICKHOUSE_CURL} -sSv \"${CLICKHOUSE_URL}&http_max_field_name_size=$(($DEFAULT_MAX_NAME_SIZE+10))\" -H @$CLICKHOUSE_TMP/long_name.txt -d 'SELECT 1' 2>&1 | grep -Fc '400 Bad Request'\n+${CLICKHOUSE_CURL} -sSv \"${CLICKHOUSE_URL}&http_max_field_value_size=$(($DEFAULT_MAX_VALUE_SIZE+10))\" -H @$CLICKHOUSE_TMP/short_long.txt -d 'SELECT 1' 2>&1 | grep -Fc '400 Bad Request'\n+${CLICKHOUSE_CURL} -sSv \"${CLICKHOUSE_URL}&http_max_field_name_size=$(($DEFAULT_MAX_NAME_SIZE+10))\" -H @$CLICKHOUSE_TMP/long_short.txt -d 'SELECT 1' 2>&1 | grep -Fc '400 Bad Request'\n+\n+# TODO: test that session context doesn't affect these settings either.\n",
  "problem_statement": "Limitations on amount of query parameters\n**Describe the unexpected behaviour**\r\nI try to use parameterized queries for our software to prevent SQL injections over user variable fields.\r\nThe implementation worked so far.\r\n\r\nAs our software can create quite large or complicated queries,\r\nwe ran into a first limitation.\r\n\r\nWe have a query with ~800 parameters and get back an error when using `curl` (for debugging).\r\n\r\n\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use\r\n  * 21.5.6.6\r\n* Which interface to use, if matters\r\n  * HTTP\r\n* Non-default settings, if any\r\n* Query\r\n  * As the parameters were not cleaned from confidential data, I can sadly not provide example tables and queries.\r\n  * If needed for further investigation, I would try to create a query, which uses enough parameters to trigger the error.\r\n\r\n**Expected behavior**\r\nThere should not be a limit to the amount of query fields.\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\n$ curl -v `cat url.txt` --data-binary @query.sql\r\n> Host: clickhouse:8123\r\n> User-Agent: curl/7.64.0\r\n> Accept: */*\r\n> Content-Length: 49780\r\n> Content-Type: application/x-www-form-urlencoded\r\n> Expect: 100-continue\r\n>\r\n* Expire in 1000 ms for 0 (transfer 0x558051040fb0)\r\n< HTTP/1.1 100 Continue\r\n* We are completely uploaded and fine\r\n< HTTP/1.1 500 Internal Server Error\r\n< Date: Fri, 11 Jun 2021 14:02:47 GMT\r\n< Connection: Keep-Alive\r\n< Content-Type: text/plain; charset=UTF-8\r\n< X-ClickHouse-Server-Display-Name: 60601d5e39b6\r\n< Transfer-Encoding: chunked\r\n< X-ClickHouse-Exception-Code: 1000\r\n<\r\nPoco::Exception. Code: 1000, e.code() = 0, e.displayText() = HTML Form Exception: Too many form fields (version 20.10.3.30 (official build))\r\n* Connection #0 to host clickhouse left intact\r\n```\r\n\r\nHow large is the limit on the query parameters and would there be a technical solution to not have an upper limit on the parameter count?\r\n\r\nThank you in advance.\n",
  "hints_text": "@abyss7 Let's make all these thresholds customizeable and also raise them to some large enough value by default, e.g. one million of fields.",
  "created_at": "2021-06-15T14:36:44Z",
  "modified_files": [
    "programs/library-bridge/Handlers.cpp",
    "programs/odbc-bridge/ColumnInfoHandler.cpp",
    "programs/odbc-bridge/IdentifierQuoteHandler.cpp",
    "programs/odbc-bridge/MainHandler.cpp",
    "programs/odbc-bridge/SchemaAllowedHandler.cpp",
    "src/Core/Settings.h",
    "src/Server/HTTP/HTMLForm.cpp",
    "src/Server/HTTP/HTMLForm.h",
    "src/Server/HTTP/HTTPServerRequest.cpp",
    "src/Server/HTTP/HTTPServerRequest.h",
    "src/Server/HTTP/ReadHeaders.h",
    "src/Server/HTTPHandler.cpp",
    "src/Server/InterserverIOHTTPHandler.cpp",
    "src/Server/InterserverIOHTTPHandler.h",
    "src/Server/ReplicasStatusHandler.cpp",
    "src/Server/ReplicasStatusHandler.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01903_http_fields.reference",
    "b/tests/queries/0_stateless/01903_http_fields.sh"
  ]
}