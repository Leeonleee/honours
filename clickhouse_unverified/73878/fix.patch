diff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp
index ea46927344ab..26f923a6fd95 100644
--- a/src/DataTypes/DataTypeMap.cpp
+++ b/src/DataTypes/DataTypeMap.cpp
@@ -39,6 +39,17 @@ DataTypeMap::DataTypeMap(const DataTypePtr & nested_)
         throw Exception(ErrorCodes::BAD_ARGUMENTS,
             "Expected Array(Tuple(key, value)) type, got {}", nested->getName());
 
+    if (type_tuple->haveExplicitNames())
+    {
+        const auto & names = type_tuple->getElementNames();
+        if (names[0] != "keys" || names[1] != "values")
+            throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                "Expected Tuple(key, value) with explicit names 'keys', 'values', got explicit names '{}', '{}'", names[0], names[1]);
+    }
+    else
+        throw Exception(ErrorCodes::BAD_ARGUMENTS,
+            "Expected Tuple(key, value) with explicit names 'keys', 'values', got without explicit names");
+
     key_type = type_tuple->getElement(0);
     value_type = type_tuple->getElement(1);
     assertKeyType();
diff --git a/src/Formats/insertNullAsDefaultIfNeeded.cpp b/src/Formats/insertNullAsDefaultIfNeeded.cpp
index ff40d036fb57..b2c077443515 100644
--- a/src/Formats/insertNullAsDefaultIfNeeded.cpp
+++ b/src/Formats/insertNullAsDefaultIfNeeded.cpp
@@ -45,6 +45,9 @@ bool insertNullAsDefaultIfNeeded(ColumnWithTypeAndName & input_column, const Col
         if (tuple_input_type.getElements().size() != tuple_header_type.getElements().size())
             return false;
 
+        bool has_explicit_names = tuple_input_type.haveExplicitNames();
+        Names explicit_names = has_explicit_names ? tuple_input_type.getElementNames() : Names{};
+
         Columns nested_input_columns;
         nested_input_columns.reserve(tuple_input_type.getElements().size());
         DataTypes nested_input_types;
@@ -67,7 +70,9 @@ bool insertNullAsDefaultIfNeeded(ColumnWithTypeAndName & input_column, const Col
             return false;
 
         input_column.column = ColumnTuple::create(std::move(nested_input_columns));
-        input_column.type = std::make_shared<DataTypeTuple>(std::move(nested_input_types));
+        input_column.type = has_explicit_names
+                            ? std::make_shared<DataTypeTuple>(std::move(nested_input_types), explicit_names)
+                            : std::make_shared<DataTypeTuple>(std::move(nested_input_types));
         return true;
     }
 
diff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp
index 9bd40cf35496..0185f565e166 100644
--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp
+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp
@@ -31,6 +31,7 @@ namespace ErrorCodes
 {
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int BAD_ARGUMENTS;
 }
 
 /** An adapter that allows to execute array* functions over Map types arguments.
@@ -78,12 +79,36 @@ class FunctionMapToArrayAdapter : public IFunction
             impl.getReturnTypeImpl(nested_arguments);
         };
 
+        DataTypePtr nested_type;
         /// If method is not overloaded in the implementation call default implementation
         /// from IFunction. Here inheritance cannot be used for template parameterized field.
         if constexpr (impl_has_get_return_type)
-            return Adapter::wrapType(impl.getReturnTypeImpl(nested_arguments));
+            nested_type = impl.getReturnTypeImpl(nested_arguments);
         else
-            return Adapter::wrapType(dynamic_cast<const IFunction &>(impl).getReturnTypeImpl(nested_arguments));
+            nested_type = dynamic_cast<const IFunction &>(impl).getReturnTypeImpl(nested_arguments);
+
+        if constexpr (std::is_same_v<Impl, FunctionArrayMap> || std::is_same_v<Impl, FunctionArrayConcat>)
+        {
+            /// Check if nested type is Array(Tuple(key, value))
+            const auto * type_array = typeid_cast<const DataTypeArray *>(nested_type.get());
+            if (!type_array)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                    "Expected Array(Tuple(key, value)) type, got {}", nested_type->getName());
+
+            const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_array->getNestedType().get());
+            if (!type_tuple)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                    "Expected Array(Tuple(key, value)) type, got {}", nested_type->getName());
+
+            if (type_tuple->getElements().size() != 2)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS,
+                    "Expected Array(Tuple(key, value)) type, got {}", nested_type->getName());
+
+            /// Recreate nested type with explicitly named tuple.
+            return Adapter::wrapType(std::make_shared<DataTypeArray>(std::make_shared<DataTypeTuple>(DataTypes{type_tuple->getElement(0), type_tuple->getElement(1)}, Names{"keys", "values"})));
+        }
+        else
+            return Adapter::wrapType(nested_type);
     }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override
@@ -153,7 +178,7 @@ struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, retur
 
     static DataTypePtr extractNestedType(const DataTypeMap & type_map)
     {
-        return type_map.getNestedTypeWithUnnamedTuple();
+        return type_map.getNestedType();
     }
 
     static ColumnPtr extractNestedColumn(const ColumnMap & column_map)
