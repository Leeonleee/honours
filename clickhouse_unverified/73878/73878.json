{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 73878,
  "instance_id": "ClickHouse__ClickHouse-73878",
  "issue_numbers": [
    "64805"
  ],
  "base_commit": "287e82f42611bf716824cf9808c3e74aff48cd4b",
  "patch": "diff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp\nindex ea46927344ab..26f923a6fd95 100644\n--- a/src/DataTypes/DataTypeMap.cpp\n+++ b/src/DataTypes/DataTypeMap.cpp\n@@ -39,6 +39,17 @@ DataTypeMap::DataTypeMap(const DataTypePtr & nested_)\n         throw Exception(ErrorCodes::BAD_ARGUMENTS,\n             \"Expected Array(Tuple(key, value)) type, got {}\", nested->getName());\n \n+    if (type_tuple->haveExplicitNames())\n+    {\n+        const auto & names = type_tuple->getElementNames();\n+        if (names[0] != \"keys\" || names[1] != \"values\")\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Expected Tuple(key, value) with explicit names 'keys', 'values', got explicit names '{}', '{}'\", names[0], names[1]);\n+    }\n+    else\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Expected Tuple(key, value) with explicit names 'keys', 'values', got without explicit names\");\n+\n     key_type = type_tuple->getElement(0);\n     value_type = type_tuple->getElement(1);\n     assertKeyType();\ndiff --git a/src/Formats/insertNullAsDefaultIfNeeded.cpp b/src/Formats/insertNullAsDefaultIfNeeded.cpp\nindex ff40d036fb57..b2c077443515 100644\n--- a/src/Formats/insertNullAsDefaultIfNeeded.cpp\n+++ b/src/Formats/insertNullAsDefaultIfNeeded.cpp\n@@ -45,6 +45,9 @@ bool insertNullAsDefaultIfNeeded(ColumnWithTypeAndName & input_column, const Col\n         if (tuple_input_type.getElements().size() != tuple_header_type.getElements().size())\n             return false;\n \n+        bool has_explicit_names = tuple_input_type.haveExplicitNames();\n+        Names explicit_names = has_explicit_names ? tuple_input_type.getElementNames() : Names{};\n+\n         Columns nested_input_columns;\n         nested_input_columns.reserve(tuple_input_type.getElements().size());\n         DataTypes nested_input_types;\n@@ -67,7 +70,9 @@ bool insertNullAsDefaultIfNeeded(ColumnWithTypeAndName & input_column, const Col\n             return false;\n \n         input_column.column = ColumnTuple::create(std::move(nested_input_columns));\n-        input_column.type = std::make_shared<DataTypeTuple>(std::move(nested_input_types));\n+        input_column.type = has_explicit_names\n+                            ? std::make_shared<DataTypeTuple>(std::move(nested_input_types), explicit_names)\n+                            : std::make_shared<DataTypeTuple>(std::move(nested_input_types));\n         return true;\n     }\n \ndiff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp\nindex 9bd40cf35496..0185f565e166 100644\n--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp\n+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp\n@@ -31,6 +31,7 @@ namespace ErrorCodes\n {\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int BAD_ARGUMENTS;\n }\n \n /** An adapter that allows to execute array* functions over Map types arguments.\n@@ -78,12 +79,36 @@ class FunctionMapToArrayAdapter : public IFunction\n             impl.getReturnTypeImpl(nested_arguments);\n         };\n \n+        DataTypePtr nested_type;\n         /// If method is not overloaded in the implementation call default implementation\n         /// from IFunction. Here inheritance cannot be used for template parameterized field.\n         if constexpr (impl_has_get_return_type)\n-            return Adapter::wrapType(impl.getReturnTypeImpl(nested_arguments));\n+            nested_type = impl.getReturnTypeImpl(nested_arguments);\n         else\n-            return Adapter::wrapType(dynamic_cast<const IFunction &>(impl).getReturnTypeImpl(nested_arguments));\n+            nested_type = dynamic_cast<const IFunction &>(impl).getReturnTypeImpl(nested_arguments);\n+\n+        if constexpr (std::is_same_v<Impl, FunctionArrayMap> || std::is_same_v<Impl, FunctionArrayConcat>)\n+        {\n+            /// Check if nested type is Array(Tuple(key, value))\n+            const auto * type_array = typeid_cast<const DataTypeArray *>(nested_type.get());\n+            if (!type_array)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Expected Array(Tuple(key, value)) type, got {}\", nested_type->getName());\n+\n+            const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_array->getNestedType().get());\n+            if (!type_tuple)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Expected Array(Tuple(key, value)) type, got {}\", nested_type->getName());\n+\n+            if (type_tuple->getElements().size() != 2)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Expected Array(Tuple(key, value)) type, got {}\", nested_type->getName());\n+\n+            /// Recreate nested type with explicitly named tuple.\n+            return Adapter::wrapType(std::make_shared<DataTypeArray>(std::make_shared<DataTypeTuple>(DataTypes{type_tuple->getElement(0), type_tuple->getElement(1)}, Names{\"keys\", \"values\"})));\n+        }\n+        else\n+            return Adapter::wrapType(nested_type);\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n@@ -153,7 +178,7 @@ struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, retur\n \n     static DataTypePtr extractNestedType(const DataTypeMap & type_map)\n     {\n-        return type_map.getNestedTypeWithUnnamedTuple();\n+        return type_map.getNestedType();\n     }\n \n     static ColumnPtr extractNestedColumn(const ColumnMap & column_map)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03299_map_named_tuple.reference b/tests/queries/0_stateless/03299_map_named_tuple.reference\nnew file mode 100644\nindex 000000000000..6162f782a650\n--- /dev/null\n+++ b/tests/queries/0_stateless/03299_map_named_tuple.reference\n@@ -0,0 +1,1 @@\n+{1:2}\t{{1:2}:2}\ndiff --git a/tests/queries/0_stateless/03299_map_named_tuple.sql b/tests/queries/0_stateless/03299_map_named_tuple.sql\nnew file mode 100644\nindex 000000000000..3e8e597c66d8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03299_map_named_tuple.sql\n@@ -0,0 +1,8 @@\n+\n+-- This is a very subtle issue when map(1 ,2) data type (which is nested with Array(Tuple(key, value))) firstly created with\n+-- explicitly named tuple ('keys' key, 'values' value) as an argument of `mapConcat`, and then as a constant is referenced by\n+-- map constant in the lambda function of mapApply which creates its type without explicit naming and further these types\n+-- are compared, and because tuple naming is participating in this comparison the result is negative - which leads to\n+-- 'incompatible types' error showing exactly same Map types - issue https://github.com/ClickHouse/ClickHouse/issues/64805\n+\n+SELECT mapConcat(map(1, 2)), mapApply((x, y) -> (map(1, 2), x + 1), map(1, 0))\n",
  "problem_statement": "AST Fuzzer LOGICAL_ERROR in Planner: 'Cannot capture column 4 because it has incompatible type: got Map(UInt8, UInt8), but Map(UInt8, UInt8) is expected\nhttps://s3.amazonaws.com/clickhouse-test-reports/64606/14404b8a0a8549beedf544e1c80d1f54bbb5e924/ast_fuzzer__ubsan_.html\r\n\r\nSimplified query:\r\n\r\n```sql\r\nSELECT mapConcat(map(1, 2)), mapApply((x, y) -> (map(1, 2), x + 1), map(1, 0))\r\n```\r\n```\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.742595 [ 2568639 ] {f92d62ed-becf-415f-adf6-c838aeff8b64} <Fatal> : Logical error: 'Cannot capture column 4 because it has incompatible type: got Map(UInt8, UInt8), but Map(UInt8, UInt8) is expected.'.\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.743154 [ 2569336 ] <Fatal> BaseDaemon: ########################################\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.743237 [ 2569336 ] <Fatal> BaseDaemon: (version 24.6.1.1, build id: BF227A7AC47890680605CAB4F15FEB33DE403EEC, git hash: 52eb917ef09b1d87b91d42e4bc327bad130cc276) (from thread 2568639) (query_id: f92d62ed-becf-415f-adf6-c838aeff8b64) (query: SELECT mapConcat(map(1, 2)), mapApply((x, y) -> (map(1, 2), x + 1), map(1, 0))) Received signal Aborted (6)\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.743315 [ 2569336 ] <Fatal> BaseDaemon:\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.743392 [ 2569336 ] <Fatal> BaseDaemon: Stack trace: 0x000000000c55fe6a 0x000000000c55fd60 0x000000000c948db1 0x0000720648245320 0x000072064829eb1d 0x000072064824526e 0x00007206482288ff 0x000000000c50cc42 0x000000000c50cdb5 0x000000000c50d360 0x0000000004de306a 0x0000000004de0869 0x0000000009ec463b 0x0000000014b7a678 0x0000000014b78b82 0x0000000014b78808 0x00000000131d139a 0x00000000131d0d8e 0x0000000004e3b1d9 0x0000000011d8d766 0x000\r\n000011d8e90d 0x0000000011d8f8c2 0x000000001314abca 0x000000001314a41b 0x00000000131c8c80 0x00000000131c7d6c 0x00000000131c4daf 0x00000000131c3ea9 0x00000000131bf8a8 0x00000000131bf60f 0x00000000141eb625 0x000000001427df09 0x000000001427a4de 0x00000000141c0655 0x00000000141bbae8 0x00000000141b923d 0x000000001480f4f2 0x000000001480a0aa 0x0000000015dae139 0x0000000015dc2cbf 0x00000000171f1879 0x00000000171f20c8 0x0000000017283894 0x000000001728063a 0x000000001727f37e\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.757643 [ 2569336 ] <Fatal> BaseDaemon: 0. /data/ch4/src/Common/StackTrace.cpp:349: StackTrace::tryCapture() @ 0x000000000c55fe6a\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.773275 [ 2569336 ] <Fatal> BaseDaemon: 1. /data/ch4/src/Common/StackTrace.cpp:323: StackTrace::StackTrace(ucontext_t const&) @ 0x000000000c55fd60\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.796452 [ 2569336 ] <Fatal> BaseDaemon: 2. /data/ch4/src/Daemon/BaseDaemon.cpp:157: signalHandler(int, siginfo_t*, void*) @ 0x000000000c948db1\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.796503 [ 2569336 ] <Fatal> BaseDaemon: 3. ? @ 0x0000720648245320\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.796567 [ 2569336 ] <Fatal> BaseDaemon: 4. ? @ 0x000072064829eb1d\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.796637 [ 2569336 ] <Fatal> BaseDaemon: 5. ? @ 0x000072064824526e\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.796704 [ 2569336 ] <Fatal> BaseDaemon: 6. ? @ 0x00007206482288ff\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.811828 [ 2569336 ] <Fatal> BaseDaemon: 7. /data/ch4/src/Common/Exception.cpp:0: DB::abortOnFailedAssertion(String const&) @ 0x000000000c50cc42\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.826432 [ 2569336 ] <Fatal> BaseDaemon: 8. /data/ch4/src/Common/Exception.cpp:65: DB::handle_error_code(String const&, int, bool, std::vector<void*, std::allocator<void*>> const&) @ 0x000000000c50cdb5\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.840148 [ 2569336 ] <Fatal> BaseDaemon: 9. /data/ch4/src/Common/Exception.cpp:105: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000c50d360\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.851002 [ 2569336 ] <Fatal> BaseDaemon: 10. /data/ch4/src/Common/Exception.h:95: DB::Exception::Exception(String&&, int, bool) @ 0x0000000004de306a\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.861157 [ 2569336 ] <Fatal> BaseDaemon: 11. /data/ch4/src/Common/Exception.h:68: DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000004de0869\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.874320 [ 2569336 ] <Fatal> BaseDaemon: 12. /data/ch4/src/Common/Exception.h:113: DB::Exception::Exception<unsigned long, String, String>(int, FormatStringHelperImpl<std::type_identity<unsigned long>::type, std::type_identity<String>::type, std::type_identity<String>::type>, unsigned long&&, String&&, String&&) @ 0x0000000009ec463b\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.889584 [ 2569336 ] <Fatal> BaseDaemon: 13. /data/ch4/src/Columns/ColumnFunction.cpp:264: DB::ColumnFunction::appendArgument(DB::ColumnWithTypeAndName const&) @ 0x0000000014b7a678\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.903242 [ 2569336 ] <Fatal> BaseDaemon: 14. /data/ch4/src/Columns/ColumnFunction.cpp:255: DB::ColumnFunction::appendArguments(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&) @ 0x0000000014b78b82\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.916864 [ 2569336 ] <Fatal> BaseDaemon: 15. /data/ch4/src/Columns/ColumnFunction.cpp:40: DB::ColumnFunction::ColumnFunction(unsigned long, std::shared_ptr<DB::IFunctionBase const>, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, bool, bool, bool) @ 0x0000000014b78808\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.956816 [ 2569336 ] <Fatal> BaseDaemon: 16. /data/ch4/src/Common/COW.h:284: COW<DB::IColumn>::mutable_ptr<DB::ColumnFunction> COWHelper<DB::IColumnHelper<DB::ColumnFunction, DB::IColumn>, DB::ColumnFunction>::create<unsigned long&, std::unique_ptr<DB::FunctionExpression, std::default_delete<DB::FunctionExpression>>, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&>(unsigned long&, std::unique_pt\r\n<DB::FunctionExpression, std::default_delete<DB::FunctionExpression>>&&, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&) @ 0x00000000131d139a\r\n[ip-172-31-8-55] 2024.06.04 18:57:10.993393 [ 2569336 ] <Fatal> BaseDaemon: 17. /data/ch4/src/Functions/FunctionsMiscellaneous.h:151: DB::ExecutableFunctionCapture::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000131d0d8e\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.009938 [ 2569336 ] <Fatal> BaseDaemon: 18. /data/ch4/src/Functions/IFunction.h:62: DB::IExecutableFunction::executeDryRunImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x0000000004e3b1d9\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.020863 [ 2569336 ] <Fatal> BaseDaemon: 19. /data/ch4/src/Functions/IFunction.cpp:245: DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000011d8d766\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.031533 [ 2569336 ] <Fatal> BaseDaemon: 20. /data/ch4/src/Functions/IFunction.cpp:307: DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000011d8e90d\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.042284 [ 2569336 ] <Fatal> BaseDaemon: 21. /data/ch4/src/Functions/IFunction.cpp:386: DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000011d8f8c2\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.097297 [ 2569336 ] <Fatal> BaseDaemon: 22. /data/ch4/src/Interpreters/ActionsDAG.cpp:331: DB::ActionsDAG::addFunctionImpl(std::shared_ptr<DB::IFunctionBase const> const&, std::vector<DB::ActionsDAG::Node const*, std::allocator<DB::ActionsDAG::Node const*>>, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>>, String, std::shared_ptr<DB::IDataType const>, bool) @ 0x000000001314abca\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.152105 [ 2569336 ] <Fatal> BaseDaemon: 23. /data/ch4/src/Interpreters/ActionsDAG.cpp:247: DB::ActionsDAG::addFunction(std::shared_ptr<DB::IFunctionOverloadResolver> const&, std::vector<DB::ActionsDAG::Node const*, std::allocator<DB::ActionsDAG::Node const*>>, String) @ 0x000000001314a41b\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.188685 [ 2569336 ] <Fatal> BaseDaemon: 24. /data/ch4/src/Planner/PlannerActionsVisitor.cpp:507: DB::ActionsDAG::Node const* DB::(anonymous namespace)::ActionsScopeNode::addFunctionIfNecessary<std::shared_ptr<DB::FunctionCaptureOverloadResolver>>(String const&, std::vector<DB::ActionsDAG::Node const*, std::allocator<DB::ActionsDAG::Node const*>>, std::shared_ptr<DB::FunctionCaptureOverloadResolver> const&) @ 0x00000000131c8c80\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.222685 [ 2569336 ] <Fatal> BaseDaemon: 25. /data/ch4/src/Planner/PlannerActionsVisitor.cpp:796: DB::(anonymous namespace)::PlannerActionsVisitorImpl::visitLambda(std::shared_ptr<DB::IQueryTreeNode> const&) @ 0x00000000131c7d6c\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.257595 [ 2569336 ] <Fatal> BaseDaemon: 26. /data/ch4/src/Planner/PlannerActionsVisitor.cpp:967: DB::(anonymous namespace)::PlannerActionsVisitorImpl::visitFunction(std::shared_ptr<DB::IQueryTreeNode> const&) @ 0x00000000131c4daf\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.290734 [ 2569336 ] <Fatal> BaseDaemon: 27. /data/ch4/src/Planner/PlannerActionsVisitor.cpp:638: DB::(anonymous namespace)::PlannerActionsVisitorImpl::visitImpl(std::shared_ptr<DB::IQueryTreeNode>) @ 0x00000000131c3ea9\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.323821 [ 2569336 ] <Fatal> BaseDaemon: 28. /data/ch4/src/Planner/PlannerActionsVisitor.cpp:616: DB::(anonymous namespace)::PlannerActionsVisitorImpl::visit(std::shared_ptr<DB::IQueryTreeNode>) @ 0x00000000131bf8a8\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.356880 [ 2569336 ] <Fatal> BaseDaemon: 29. /data/ch4/src/Planner/PlannerActionsVisitor.cpp:1019: DB::PlannerActionsVisitor::visit(std::shared_ptr<DB::ActionsDAG>, std::shared_ptr<DB::IQueryTreeNode>) @ 0x00000000131bf60f\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.388692 [ 2569336 ] <Fatal> BaseDaemon: 30. /data/ch4/src/Planner/Utils.cpp:222: DB::buildActionsDAGFromExpressionNode(std::shared_ptr<DB::IQueryTreeNode> const&, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::PlannerContext> const&) @ 0x00000000141eb625\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.415567 [ 2569336 ] <Fatal> BaseDaemon: 31. /data/ch4/src/Planner/PlannerExpressionAnalysis.cpp:360: DB::(anonymous namespace)::analyzeProjection(DB::QueryNode const&, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::PlannerContext> const&, DB::ActionsChain&) @ 0x000000001427df09\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.441251 [ 2569336 ] <Fatal> BaseDaemon: 32. /data/ch4/src/Planner/PlannerExpressionAnalysis.cpp:569: DB::buildExpressionAnalysisResult(std::shared_ptr<DB::IQueryTreeNode> const&, std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::PlannerContext> const&, DB::PlannerQueryProcessingInfo const&) @ 0x000000001427a4de\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.491676 [ 2569336 ] <Fatal> BaseDaemon: 33. /data/ch4/src/Planner/Planner.cpp:1522: DB::Planner::buildPlanForQueryNode() @ 0x00000000141c0655\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.540506 [ 2569336 ] <Fatal> BaseDaemon: 34. /data/ch4/src/Planner/Planner.cpp:0: DB::Planner::buildQueryPlanIfNeeded() @ 0x00000000141bbae8\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.563001 [ 2569336 ] <Fatal> BaseDaemon: 35. /data/ch4/src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:234: DB::InterpreterSelectQueryAnalyzer::getQueryPlan() @ 0x00000000141b923d\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.607714 [ 2569336 ] <Fatal> BaseDaemon: 36. /data/ch4/src/Interpreters/executeQuery.cpp:1159: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000001480f4f2\r\n[ip-172-31-8-55] 2024.06.04 18:57:11.652586 [ 2569336 ] <Fatal> BaseDaemon: 37. /data/ch4/src/Interpreters/executeQuery.cpp:1376: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x000000001480a0aa\r\n```\n",
  "hints_text": "",
  "created_at": "2024-12-27T09:45:09Z",
  "modified_files": [
    "src/DataTypes/DataTypeMap.cpp",
    "src/Formats/insertNullAsDefaultIfNeeded.cpp",
    "src/Functions/array/FunctionsMapMiscellaneous.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03299_map_named_tuple.reference",
    "b/tests/queries/0_stateless/03299_map_named_tuple.sql"
  ]
}