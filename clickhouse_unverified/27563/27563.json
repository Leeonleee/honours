{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27563,
  "instance_id": "ClickHouse__ClickHouse-27563",
  "issue_numbers": [
    "27469"
  ],
  "base_commit": "10503af0d026359cc4fb2e4d0f02282fa66a8477",
  "patch": "diff --git a/docs/en/sql-reference/aggregate-functions/parametric-functions.md b/docs/en/sql-reference/aggregate-functions/parametric-functions.md\nindex bdf115acb34d..6c24ffdba57b 100644\n--- a/docs/en/sql-reference/aggregate-functions/parametric-functions.md\n+++ b/docs/en/sql-reference/aggregate-functions/parametric-functions.md\n@@ -255,7 +255,7 @@ windowFunnel(window, [mode, [mode, ... ]])(timestamp, cond1, cond2, ..., condN)\n \n -   `window` \u2014 Length of the sliding window, it is the time interval between the first and the last condition. The unit of `window` depends on the `timestamp` itself and varies. Determined using the expression `timestamp of cond1 <= timestamp of cond2 <= ... <= timestamp of condN <= timestamp of cond1 + window`.\n -   `mode` \u2014 It is an optional argument. One or more modes can be set.\n-    -   `'strict'` \u2014 If same condition holds for sequence of events then such non-unique events would be skipped.\n+    -   `'strict_deduplication'` \u2014 If the same condition holds for the sequence of events, then such repeating event interrupts further processing.\n     -   `'strict_order'` \u2014 Don't allow interventions of other events. E.g. in the case of `A->B->D->C`, it stops finding `A->B->C` at the `D` and the max event level is 2.\n     -   `'strict_increase'` \u2014 Apply conditions only to events with strictly increasing timestamps.\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\nindex 591596461f89..982cd1b4e325 100644\n--- a/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n+++ b/src/AggregateFunctions/AggregateFunctionWindowFunnel.h\n@@ -137,8 +137,8 @@ class AggregateFunctionWindowFunnel final\n private:\n     UInt64 window;\n     UInt8 events_size;\n-    /// When the 'strict' is set, it applies conditions only for the not repeating values.\n-    bool strict;\n+    /// When the 'strict_deduplication' is set, it applies conditions only for the not repeating values.\n+    bool strict_deduplication;\n \n     /// When the 'strict_order' is set, it doesn't allow interventions of other events.\n     /// In the case of 'A->B->D->C', it stops finding 'A->B->C' at the 'D' and the max event level is 2.\n@@ -150,7 +150,7 @@ class AggregateFunctionWindowFunnel final\n     /// Loop through the entire events_list, update the event timestamp value\n     /// The level path must be 1---2---3---...---check_events_size, find the max event level that satisfied the path in the sliding window.\n     /// If found, returns the max event level, else return 0.\n-    /// The Algorithm complexity is O(n).\n+    /// The algorithm works in O(n) time, but the overall function works in O(n * log(n)) due to sorting.\n     UInt8 getEventLevel(Data & data) const\n     {\n         if (data.size() == 0)\n@@ -163,10 +163,10 @@ class AggregateFunctionWindowFunnel final\n         /// events_timestamp stores the timestamp of the first and previous i-th level event happen within time window\n         std::vector<std::optional<std::pair<UInt64, UInt64>>> events_timestamp(events_size);\n         bool first_event = false;\n-        for (const auto & pair : data.events_list)\n+        for (size_t i = 0; i < data.events_list.size(); ++i)\n         {\n-            const T & timestamp = pair.first;\n-            const auto & event_idx = pair.second - 1;\n+            const T & timestamp = data.events_list[i].first;\n+            const auto & event_idx = data.events_list[i].second - 1;\n             if (strict_order && event_idx == -1)\n             {\n                 if (first_event)\n@@ -179,9 +179,9 @@ class AggregateFunctionWindowFunnel final\n                 events_timestamp[0] = std::make_pair(timestamp, timestamp);\n                 first_event = true;\n             }\n-            else if (strict && events_timestamp[event_idx].has_value())\n+            else if (strict_deduplication && events_timestamp[event_idx].has_value())\n             {\n-                return event_idx + 1;\n+                return data.events_list[i - 1].second;\n             }\n             else if (strict_order && first_event && !events_timestamp[event_idx - 1].has_value())\n             {\n@@ -226,18 +226,20 @@ class AggregateFunctionWindowFunnel final\n         events_size = arguments.size() - 1;\n         window = params.at(0).safeGet<UInt64>();\n \n-        strict = false;\n+        strict_deduplication = false;\n         strict_order = false;\n         strict_increase = false;\n         for (size_t i = 1; i < params.size(); ++i)\n         {\n             String option = params.at(i).safeGet<String>();\n-            if (option == \"strict\")\n-                strict = true;\n+            if (option == \"strict_deduplication\")\n+                strict_deduplication = true;\n             else if (option == \"strict_order\")\n                 strict_order = true;\n             else if (option == \"strict_increase\")\n                 strict_increase = true;\n+            else if (option == \"strict\")\n+                throw Exception{\"strict is replaced with strict_deduplication in Aggregate function \" + getName(), ErrorCodes::BAD_ARGUMENTS};\n             else\n                 throw Exception{\"Aggregate function \" + getName() + \" doesn't support a parameter: \" + option, ErrorCodes::BAD_ARGUMENTS};\n         }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00632_aggregation_window_funnel.reference b/tests/queries/0_stateless/00632_aggregation_window_funnel.reference\nindex 2c68f277bfa0..d586e5a4b679 100644\n--- a/tests/queries/0_stateless/00632_aggregation_window_funnel.reference\n+++ b/tests/queries/0_stateless/00632_aggregation_window_funnel.reference\n@@ -37,6 +37,7 @@\n [5, 2]\n [6, 1]\n [7, 1]\n+[1]\n [1, 2]\n [2, 2]\n [3, 0]\ndiff --git a/tests/queries/0_stateless/00632_aggregation_window_funnel.sql b/tests/queries/0_stateless/00632_aggregation_window_funnel.sql\nindex aa0dc8042389..e548aa4d81d1 100644\n--- a/tests/queries/0_stateless/00632_aggregation_window_funnel.sql\n+++ b/tests/queries/0_stateless/00632_aggregation_window_funnel.sql\n@@ -43,7 +43,7 @@ drop table if exists funnel_test_strict;\n create table funnel_test_strict (timestamp UInt32, event UInt32) engine=Memory;\n insert into funnel_test_strict values (00,1000),(10,1001),(20,1002),(30,1003),(40,1004),(50,1005),(51,1005),(60,1006),(70,1007),(80,1008);\n \n-select 6 = windowFunnel(10000, 'strict')(timestamp, event = 1000, event = 1001, event = 1002, event = 1003, event = 1004, event = 1005, event = 1006) from funnel_test_strict;\n+select 6 = windowFunnel(10000, 'strict_deduplication')(timestamp, event = 1000, event = 1001, event = 1002, event = 1003, event = 1004, event = 1005, event = 1006) from funnel_test_strict;\n select 7 = windowFunnel(10000)(timestamp, event = 1000, event = 1001, event = 1002, event = 1003, event = 1004, event = 1005, event = 1006) from funnel_test_strict;\n \n \n@@ -62,11 +62,18 @@ insert into funnel_test_strict_order values (1, 5, 'a') (2, 5, 'a') (3, 5, 'b')\n insert into funnel_test_strict_order values (1, 6, 'c') (2, 6, 'c') (3, 6, 'b') (4, 6, 'b') (5, 6, 'a') (6, 6, 'a');\n select user, windowFunnel(86400)(dt, event='a', event='b', event='c') as s from funnel_test_strict_order group by user order by user format JSONCompactEachRow;\n select user, windowFunnel(86400, 'strict_order')(dt, event='a', event='b', event='c') as s from funnel_test_strict_order group by user order by user format JSONCompactEachRow;\n-select user, windowFunnel(86400, 'strict', 'strict_order')(dt, event='a', event='b', event='c') as s from funnel_test_strict_order group by user order by user format JSONCompactEachRow;\n+select user, windowFunnel(86400, 'strict_deduplication', 'strict_order')(dt, event='a', event='b', event='c') as s from funnel_test_strict_order group by user order by user format JSONCompactEachRow;\n insert into funnel_test_strict_order values (1, 7, 'a') (2, 7, 'c') (3, 7, 'b');\n select user, windowFunnel(10, 'strict_order')(dt, event = 'a', event = 'b', event = 'c') as s from funnel_test_strict_order where user = 7 group by user format JSONCompactEachRow;\n drop table funnel_test_strict_order;\n \n+--https://github.com/ClickHouse/ClickHouse/issues/27469\n+drop table if exists strict_BiteTheDDDD;\n+create table strict_BiteTheDDDD (ts UInt64, event String) engine = Log();\n+insert into strict_BiteTheDDDD values (1,'a') (2,'b') (3,'c') (4,'b') (5,'d');\n+select 3 = windowFunnel(86400, 'strict_deduplication')(ts, event='a', event='b', event='c', event='d') from strict_BiteTheDDDD format JSONCompactEachRow;\n+drop table strict_BiteTheDDDD;\n+\n drop table if exists funnel_test_non_null;\n create table funnel_test_non_null (`dt` DateTime, `u` int, `a` Nullable(String), `b` Nullable(String)) engine = MergeTree() partition by dt order by u;\n insert into funnel_test_non_null values (1, 1, 'a1', 'b1') (2, 1, 'a2', 'b2');\n",
  "problem_statement": "What is the precise definition of  WindowFunnel's \u201cstrict\u201d MODE?\nAccording to my reading of the source code, it seems that strict = true, will return Event INDEX directly.\r\nsuch as the event sequence is `A->B->C->B->D` and conditional sequence is`A->B->C->D`, returns 2 (not 3 or 4) when searching the second B.\r\nBut if the conditional sequence is`A->B->C`, it will return directly to 3 when searching `C`.\r\nThis makes me feel confused to `strict`.\r\n\r\n```CPP\r\n        for (const auto & pair : data.events_list)\r\n        {\r\n            const T & timestamp = pair.first;\r\n            const auto & event_idx = pair.second - 1;\r\n            if (strict_order && event_idx == -1)\r\n            {\r\n                if (first_event)\r\n                    break;\r\n                else\r\n                    continue;\r\n            }\r\n            else if (event_idx == 0)\r\n            {\r\n                events_timestamp[0] = std::make_pair(timestamp, timestamp);\r\n                first_event = true;\r\n            }\r\n            else if (strict && events_timestamp[event_idx].has_value())\r\n            {\r\n                return event_idx + 1;//example1 return here\r\n            }\r\n            else if (strict_order && first_event && !events_timestamp[event_idx - 1].has_value())\r\n            {\r\n                for (size_t event = 0; event < events_timestamp.size(); ++event)\r\n                {\r\n                    if (!events_timestamp[event].has_value())\r\n                        return event;\r\n                }\r\n            }\r\n            else if (events_timestamp[event_idx - 1].has_value())\r\n            {\r\n                auto first_timestamp = events_timestamp[event_idx - 1]->first;\r\n                bool time_matched = timestamp <= first_timestamp + window;\r\n                if (strict_increase)\r\n                    time_matched = time_matched && events_timestamp[event_idx - 1]->second < timestamp;\r\n                if (time_matched)\r\n                {\r\n                    events_timestamp[event_idx] = std::make_pair(first_timestamp, timestamp);\r\n                    if (event_idx + 1 == events_size)\r\n                        return events_size;//example2 return here\r\n                }\r\n            }\r\n        }\r\n```\r\nI see a `strict` design purpose in https://github.com/ClickHouse/ClickHouse/pull/6548.\r\nI think the answer in the first example should be 3 instead of 2. Is this a bug? \n",
  "hints_text": "I confused about mode  too.\r\n``` \r\n// table schema\r\nCREATE TABLE funnel_test\r\n(\r\n    `code` UInt32 ,\r\n    `user_id` String ,\r\n    `timestamp` UInt64\r\n)\r\nENGINE = MergeTree()\r\nORDER BY (user_id, timestamp)\r\nSETTINGS index_granularity = 8192;\r\n```\r\n``` \r\n// insert data\r\ninsert into funnel_test values (1,'id',1),(2,'id',3),(4,'id',4),(1,'id',11),(2,'id',13),(3,'id',15)\r\n```\r\n```\r\n// query\r\n// strict_increase mode return 3 rows\r\nselect user_id, windowFunnel(20,'strict_increase')(toDateTime(timestamp), code = 1, code = 2, code=3) as level from funnel_test group by user_id \r\n// strict_order mode return 2 rows\r\nselect user_id, windowFunnel(20,'strict_order')(toDateTime(timestamp), code = 1, code = 2, code=3) as level from funnel_test group by user_id\r\n// strict mode return 2 rows\r\nselect user_id, windowFunnel(20,'strict')(toDateTime(timestamp), code = 1, code = 2, code=3) as level from funnel_test group by user_id\r\n// without mode return 3 rows\r\nselect user_id, windowFunnel(20)(toDateTime(timestamp), code = 1, code = 2, code=3) as level from funnel_test group by user_id\r\n```\r\nmodify first data code from 1 to 6 ,all return 3 rows\r\n```\r\ntruncate table funnel_test\r\ninsert into funnel_test values (6,'id',1),(2,'id',3),(4,'id',4),(1,'id',11),(2,'id',13),(3,'id',15)\r\n```\r\n\r\n\nCC @achimbab \n@BiteTheDDDDt \r\nIt seems a bug, I will fix it ASAP.\r\nThank you.",
  "created_at": "2021-08-11T12:13:12Z",
  "modified_files": [
    "docs/en/sql-reference/aggregate-functions/parametric-functions.md",
    "src/AggregateFunctions/AggregateFunctionWindowFunnel.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00632_aggregation_window_funnel.reference",
    "tests/queries/0_stateless/00632_aggregation_window_funnel.sql"
  ]
}