diff --git a/base/glibc-compatibility/memcpy/memcpy.h b/base/glibc-compatibility/memcpy/memcpy.h
index 86439dda0612..e202a685c1f8 100644
--- a/base/glibc-compatibility/memcpy/memcpy.h
+++ b/base/glibc-compatibility/memcpy/memcpy.h
@@ -181,7 +181,14 @@ static inline void * inline_memcpy(void * __restrict dst_, const void * __restri
             /// Aligned unrolled copy. We will use half of available SSE registers.
             /// It's not possible to have both src and dst aligned.
             /// So, we will use aligned stores and unaligned loads.
-            __m128i c0, c1, c2, c3, c4, c5, c6, c7;
+            __m128i c0;
+            __m128i c1;
+            __m128i c2;
+            __m128i c3;
+            __m128i c4;
+            __m128i c5;
+            __m128i c6;
+            __m128i c7;
 
             while (size >= 128)
             {
diff --git a/src/DataTypes/Serializations/SerializationString.cpp b/src/DataTypes/Serializations/SerializationString.cpp
index d3f23603c4e5..5d1b374b6519 100644
--- a/src/DataTypes/Serializations/SerializationString.cpp
+++ b/src/DataTypes/Serializations/SerializationString.cpp
@@ -14,12 +14,6 @@
 #include <IO/VarInt.h>
 #include <IO/ReadBufferFromString.h>
 
-#include <base/unit.h>
-
-#ifdef __SSE2__
-    #include <emmintrin.h>
-#endif
-
 
 namespace DB
 {
@@ -147,8 +141,8 @@ void SerializationString::serializeBinaryBulk(const IColumn & column, WriteBuffe
     }
 }
 
-template <int UNROLL_TIMES>
-static NO_INLINE void deserializeBinarySSE2(ColumnString::Chars & data, ColumnString::Offsets & offsets, ReadBuffer & istr, size_t limit)
+template <size_t copy_size>
+static NO_INLINE void deserializeBinaryImpl(ColumnString::Chars & data, ColumnString::Offsets & offsets, ReadBuffer & istr, size_t limit)
 {
     size_t offset = data.size();
     /// Avoiding calling resize in a loop improves the performance.
@@ -178,27 +172,24 @@ static NO_INLINE void deserializeBinarySSE2(ColumnString::Chars & data, ColumnSt
 
         if (size)
         {
-#ifdef __SSE2__
             /// An optimistic branch in which more efficient copying is possible.
-            if (offset + 16 * UNROLL_TIMES <= data.capacity() && istr.position() + size + 16 * UNROLL_TIMES <= istr.buffer().end())
+            if (offset + copy_size <= data.capacity() && istr.position() + size + copy_size <= istr.buffer().end())
             {
-                const __m128i * sse_src_pos = reinterpret_cast<const __m128i *>(istr.position());
-                const __m128i * sse_src_end = sse_src_pos + (size + (16 * UNROLL_TIMES - 1)) / 16 / UNROLL_TIMES * UNROLL_TIMES;
-                __m128i * sse_dst_pos = reinterpret_cast<__m128i *>(&data[offset - size - 1]);
+                const char * src_pos = istr.position();
+                const char * src_end = src_pos + size;
+                auto * dst_pos = &data[offset - size - 1];
 
-                while (sse_src_pos < sse_src_end)
+                while (src_pos < src_end)
                 {
-                    for (size_t j = 0; j < UNROLL_TIMES; ++j)
-                        _mm_storeu_si128(sse_dst_pos + j, _mm_loadu_si128(sse_src_pos + j));
+                    __builtin_memcpy(dst_pos, src_pos, copy_size);
 
-                    sse_src_pos += UNROLL_TIMES;
-                    sse_dst_pos += UNROLL_TIMES;
+                    src_pos += copy_size;
+                    dst_pos += copy_size;
                 }
 
                 istr.position() += size;
             }
             else
-#endif
             {
                 istr.readStrict(reinterpret_cast<char*>(&data[offset - size - 1]), size);
             }
@@ -256,13 +247,13 @@ void SerializationString::deserializeBinaryBulk(IColumn & column, ReadBuffer & i
     offsets.reserve(offsets.size() + limit);
 
     if (avg_chars_size >= 64)
-        deserializeBinarySSE2<4>(data, offsets, istr, limit);
+        deserializeBinaryImpl<64>(data, offsets, istr, limit);
     else if (avg_chars_size >= 48)
-        deserializeBinarySSE2<3>(data, offsets, istr, limit);
+        deserializeBinaryImpl<48>(data, offsets, istr, limit);
     else if (avg_chars_size >= 32)
-        deserializeBinarySSE2<2>(data, offsets, istr, limit);
+        deserializeBinaryImpl<32>(data, offsets, istr, limit);
     else
-        deserializeBinarySSE2<1>(data, offsets, istr, limit);
+        deserializeBinaryImpl<16>(data, offsets, istr, limit);
 }
 
 
