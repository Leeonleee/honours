{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48663,
  "instance_id": "ClickHouse__ClickHouse-48663",
  "issue_numbers": [
    "48545"
  ],
  "base_commit": "d85ede23a37a92445f8dc87881d3516003e1c205",
  "patch": "diff --git a/src/Interpreters/AsynchronousInsertQueue.cpp b/src/Interpreters/AsynchronousInsertQueue.cpp\nindex 2dd2409442ee..b8de0246ae2b 100644\n--- a/src/Interpreters/AsynchronousInsertQueue.cpp\n+++ b/src/Interpreters/AsynchronousInsertQueue.cpp\n@@ -342,10 +342,15 @@ void AsynchronousInsertQueue::processBatchDeadlines(size_t shard_num)\n     }\n }\n \n-static void appendElementsToLogSafe(\n+namespace\n+{\n+\n+using TimePoint = std::chrono::time_point<std::chrono::system_clock>;\n+\n+void appendElementsToLogSafe(\n     AsynchronousInsertLog & log,\n     std::vector<AsynchronousInsertLogElement> elements,\n-    std::chrono::time_point<std::chrono::system_clock> flush_time,\n+    TimePoint flush_time,\n     const String & flush_query_id,\n     const String & flush_exception)\n try\n@@ -367,6 +372,8 @@ catch (...)\n     tryLogCurrentException(\"AsynchronousInsertQueue\", \"Failed to add elements to AsynchronousInsertLog\");\n }\n \n+}\n+\n // static\n void AsynchronousInsertQueue::processData(InsertQuery key, InsertDataPtr data, ContextPtr global_context)\n try\n@@ -473,8 +480,26 @@ try\n     format->addBuffer(std::move(last_buffer));\n     auto insert_query_id = insert_context->getCurrentQueryId();\n \n+    auto finish_entries = [&]\n+    {\n+        for (const auto & entry : data->entries)\n+        {\n+            if (!entry->isFinished())\n+                entry->finish();\n+        }\n+\n+        if (!log_elements.empty())\n+        {\n+            auto flush_time = std::chrono::system_clock::now();\n+            appendElementsToLogSafe(*insert_log, std::move(log_elements), flush_time, insert_query_id, \"\");\n+        }\n+    };\n+\n     if (total_rows == 0)\n+    {\n+        finish_entries();\n         return;\n+    }\n \n     try\n     {\n@@ -502,17 +527,7 @@ try\n         throw;\n     }\n \n-    for (const auto & entry : data->entries)\n-    {\n-        if (!entry->isFinished())\n-            entry->finish();\n-    }\n-\n-    if (!log_elements.empty())\n-    {\n-        auto flush_time = std::chrono::system_clock::now();\n-        appendElementsToLogSafe(*insert_log, std::move(log_elements), flush_time, insert_query_id, \"\");\n-    }\n+    finish_entries();\n }\n catch (const Exception & e)\n {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02714_async_inserts_empty_data.reference b/tests/queries/0_stateless/02714_async_inserts_empty_data.reference\nnew file mode 100644\nindex 000000000000..47ee41ddc0f8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02714_async_inserts_empty_data.reference\n@@ -0,0 +1,2 @@\n+0\n+Ok\t0\ndiff --git a/tests/queries/0_stateless/02714_async_inserts_empty_data.sh b/tests/queries/0_stateless/02714_async_inserts_empty_data.sh\nnew file mode 100755\nindex 000000000000..b2dc3298733e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02714_async_inserts_empty_data.sh\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+url=\"${CLICKHOUSE_URL}&async_insert=1&wait_for_async_insert=1\"\n+\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS t_async_insert_empty_data\"\n+${CLICKHOUSE_CLIENT} -q \"CREATE TABLE t_async_insert_empty_data (id UInt32) ENGINE = Memory\"\n+\n+echo -n '' | ${CLICKHOUSE_CURL} -sS \"$url&query=INSERT%20INTO%20t_async_insert_empty_data%20FORMAT%20JSONEachRow\" --data-binary @-\n+\n+${CLICKHOUSE_CLIENT} -q \"SYSTEM FLUSH LOGS\"\n+${CLICKHOUSE_CLIENT} -q \"SELECT count() FROM t_async_insert_empty_data\"\n+${CLICKHOUSE_CLIENT} -q \"SELECT status, bytes FROM system.asynchronous_insert_log WHERE database = '$CLICKHOUSE_DATABASE' AND table = 't_async_insert_empty_data'\"\n+\n+${CLICKHOUSE_CLIENT} -q \"DROP TABLE IF EXISTS t_async_insert_empty_data\"\n",
  "problem_statement": "Unexpected exception while inserting empty data with async_insert=1\n\r\n\r\n**Unexpected behaviour**\r\nInsertion of the empty data set (without records) causes an unexpected and unclear error when async_insert is enabled, error: `The associated promise has been destructed prior to the associated state becoming ready`.\r\nSee the stack trace below. The same error will be visible on the client side.\r\n\r\n**How to reproduce**\r\n* ClickHouse starting from 22.12 (22.12.6.22)\r\n* HTTP interface (curl, clickhouse/client@0.0.11)\r\n* async_insert should be enabled\r\n* Table for demonstration:\r\n```\r\ncreate table default.async_insert_issue (\r\n    key String\r\n  , data UInt32\r\n)\r\nengine = MergeTree() order by (key);\r\n```\r\n* Curl command for demonstration:\r\n```\r\necho '' | curl 'http://localhost:8123?query=insert%20into%20default.async_insert_issue%20settings%20async_insert%3D1%20format%20JSONEachRow' --data-binary @-\r\n```\r\n\r\n**Expected behavior**\r\nInsertion requests without data should be silently ignored, or the user should be warned that no data was provided.\r\nShould be no unexpected errors.\r\n\r\n**Error message and/or stacktrace**\r\n```\r\n2023.04.07 10:34:54.670440 [ 285 ] {3f869f30-6ef5-4430-8eff-4b692f6c97e8} <Error> DynamicQueryHandler: std::exception. Code: 1001, type: std::__1::future_error, e.what() = The associated promise has been destructed prior to the associated state becoming ready., Stack trace (when copying this message, always include the lines below):\r\n\r\n0. std::__1::promise<void>::~promise() @ 0x13b0a7ac in /usr/bin/clickhouse\r\n1. ? @ 0xfa01778 in /usr/bin/clickhouse\r\n2. ? @ 0xfa00e84 in /usr/bin/clickhouse\r\n3. DB::AsynchronousInsertQueue::processData(DB::AsynchronousInsertQueue::InsertQuery, std::__1::unique_ptr<DB::AsynchronousInsertQueue::InsertData, std::__1::default_delete<DB::AsynchronousInsertQueue::InsertData>>, std::__1::shared_ptr<DB::Context const>) @ 0xf9feff4 in /usr/bin/clickhouse\r\n4. ? @ 0xfa01098 in /usr/bin/clickhouse\r\n5. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__1::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0xbabb434 in /usr/bin/clickhouse\r\n6. void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::__1::function<void ()>, long, std::__1::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__1::__function::__policy_storage const*) @ 0xbabdafc in /usr/bin/clickhouse\r\n7. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0xbab7bf0 in /usr/bin/clickhouse\r\n8. ? @ 0xbabcae8 in /usr/bin/clickhouse\r\n9. start_thread @ 0x7624 in /usr/lib/aarch64-linux-gnu/libpthread-2.31.so\r\n10. ? @ 0xd149c in /usr/lib/aarch64-linux-gnu/libc-2.31.so\r\n (version 23.2.5.46 (official build))\r\n```\r\n\r\nPS: Actually not a big deal, but logs are flooded with those errors. \r\n\n",
  "hints_text": "Reproduced on 23.4 (master).",
  "created_at": "2023-04-11T15:15:16Z"
}