{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14771,
  "instance_id": "ClickHouse__ClickHouse-14771",
  "issue_numbers": [
    "4967",
    "2416"
  ],
  "base_commit": "c2f762e20ab8d2ac40e90cfc7c132dad50d75d2f",
  "patch": "diff --git a/src/Interpreters/ApplyWithSubqueryVisitor.cpp b/src/Interpreters/ApplyWithSubqueryVisitor.cpp\nnew file mode 100644\nindex 000000000000..e03682dafb38\n--- /dev/null\n+++ b/src/Interpreters/ApplyWithSubqueryVisitor.cpp\n@@ -0,0 +1,90 @@\n+#include <Interpreters/ApplyWithSubqueryVisitor.h>\n+#include <Interpreters/IdentifierSemantic.h>\n+#include <Interpreters/StorageID.h>\n+#include <Interpreters/misc.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTWithElement.h>\n+\n+namespace DB\n+{\n+void ApplyWithSubqueryVisitor::visit(ASTPtr & ast, const Data & data)\n+{\n+    if (auto * node_select = ast->as<ASTSelectQuery>())\n+    {\n+        auto with = node_select->with();\n+        std::optional<Data> new_data;\n+        if (with)\n+        {\n+            for (auto & child : with->children)\n+                visit(child, data);\n+            for (auto & child : with->children)\n+            {\n+                if (auto * ast_with_elem = child->as<ASTWithElement>())\n+                {\n+                    if (!new_data)\n+                        new_data = data;\n+                    new_data->subqueries[ast_with_elem->name] = ast_with_elem->subquery;\n+                }\n+            }\n+        }\n+\n+        for (auto & child : node_select->children)\n+        {\n+            if (child != with)\n+                visit(child, new_data ? *new_data : data);\n+        }\n+        return;\n+    }\n+\n+    for (auto & child : ast->children)\n+        visit(child, data);\n+    if (auto * node_func = ast->as<ASTFunction>())\n+        visit(*node_func, data);\n+    else if (auto * node_table = ast->as<ASTTableExpression>())\n+        visit(*node_table, data);\n+}\n+\n+void ApplyWithSubqueryVisitor::visit(ASTTableExpression & table, const Data & data)\n+{\n+    if (table.database_and_table_name)\n+    {\n+        auto table_id = IdentifierSemantic::extractDatabaseAndTable(table.database_and_table_name->as<ASTIdentifier &>());\n+        if (table_id.database_name.empty())\n+        {\n+            auto subquery_it = data.subqueries.find(table_id.table_name);\n+            if (subquery_it != data.subqueries.end())\n+            {\n+                table.children.clear();\n+                table.database_and_table_name.reset();\n+                table.subquery = subquery_it->second->clone();\n+                dynamic_cast<ASTWithAlias &>(*table.subquery).alias = table_id.table_name;\n+                table.children.emplace_back(table.subquery);\n+            }\n+        }\n+    }\n+}\n+\n+void ApplyWithSubqueryVisitor::visit(ASTFunction & func, const Data & data)\n+{\n+    if (checkFunctionIsInOrGlobalInOperator(func))\n+    {\n+        auto & ast = func.arguments->children.at(1);\n+        if (const auto * ident = ast->as<ASTIdentifier>())\n+        {\n+            auto table_id = IdentifierSemantic::extractDatabaseAndTable(*ident);\n+            if (table_id.database_name.empty())\n+            {\n+                auto subquery_it = data.subqueries.find(table_id.table_name);\n+                if (subquery_it != data.subqueries.end())\n+                {\n+                    func.arguments->children[1] = subquery_it->second->clone();\n+                    dynamic_cast<ASTWithAlias &>(*func.arguments->children[1]).alias = table_id.table_name;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/src/Interpreters/ApplyWithSubqueryVisitor.h b/src/Interpreters/ApplyWithSubqueryVisitor.h\nnew file mode 100644\nindex 000000000000..2aecd6aee017\n--- /dev/null\n+++ b/src/Interpreters/ApplyWithSubqueryVisitor.h\n@@ -0,0 +1,30 @@\n+#pragma once\n+\n+#include <map>\n+\n+#include <Parsers/IAST.h>\n+\n+namespace DB\n+{\n+// TODO After we support `union_with_global`, this visitor should also be extended to match ASTSelectQueryWithUnion.\n+class ASTSelectQuery;\n+class ASTFunction;\n+struct ASTTableExpression;\n+\n+class ApplyWithSubqueryVisitor\n+{\n+public:\n+    struct Data\n+    {\n+        std::map<String, ASTPtr> subqueries;\n+    };\n+\n+    static void visit(ASTPtr & ast) { visit(ast, {}); }\n+\n+private:\n+    static void visit(ASTPtr & ast, const Data & data);\n+    static void visit(ASTTableExpression & table, const Data & data);\n+    static void visit(ASTFunction & func, const Data & data);\n+};\n+\n+}\ndiff --git a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp\nindex ee29d301c6b0..f7a1fc831828 100644\n--- a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp\n+++ b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp\n@@ -4,6 +4,7 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n #include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTWithElement.h>\n \n #include <Interpreters/Context.h>\n #include <Interpreters/misc.h>\n@@ -40,6 +41,10 @@ bool ExecuteScalarSubqueriesMatcher::needChildVisit(ASTPtr & node, const ASTPtr\n     if (node->as<ASTTableExpression>())\n         return false;\n \n+    /// Do not go to subqueries defined in with statement\n+    if (node->as<ASTWithElement>())\n+        return false;\n+\n     if (node->as<ASTSelectQuery>())\n     {\n         /// Do not go to FROM, JOIN, UNION.\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex dbf6d5ae8d3b..603476ac1ba7 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -14,6 +14,7 @@\n \n #include <Access/AccessFlags.h>\n \n+#include <Interpreters/ApplyWithSubqueryVisitor.h>\n #include <Interpreters/InterpreterSelectQuery.h>\n #include <Interpreters/InterpreterSelectWithUnionQuery.h>\n #include <Interpreters/InterpreterSetQuery.h>\n@@ -249,6 +250,8 @@ InterpreterSelectQuery::InterpreterSelectQuery(\n         source_header = input_pipe->getHeader();\n     }\n \n+    ApplyWithSubqueryVisitor().visit(query_ptr);\n+\n     JoinedTables joined_tables(getSubqueryContext(*context), getSelectQuery());\n \n     if (!has_input && !storage)\ndiff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make\nindex 4eacdab1dcf4..5f520505a8a9 100644\n--- a/src/Interpreters/ya.make\n+++ b/src/Interpreters/ya.make\n@@ -23,6 +23,7 @@ SRCS(\n     addTypeConversionToAST.cpp\n     AggregateDescription.cpp\n     Aggregator.cpp\n+    ApplyWithSubqueryVisitor.cpp\n     ArithmeticOperationsInAgrFuncOptimize.cpp\n     ArrayJoinAction.cpp\n     AsynchronousMetricLog.cpp\ndiff --git a/src/Parsers/ASTWithElement.cpp b/src/Parsers/ASTWithElement.cpp\nnew file mode 100644\nindex 000000000000..e8dd4ff04986\n--- /dev/null\n+++ b/src/Parsers/ASTWithElement.cpp\n@@ -0,0 +1,21 @@\n+#include <Parsers/ASTWithElement.h>\n+\n+namespace DB\n+{\n+\n+ASTPtr ASTWithElement::clone() const\n+{\n+    const auto res = std::make_shared<ASTWithElement>(*this);\n+    res->name = name;\n+    res->subquery = subquery->clone();\n+    res->children.emplace_back(res->subquery);\n+    return res;\n+}\n+\n+void ASTWithElement::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+{\n+    settings.writeIdentifier(name);\n+    settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\");\n+    subquery->formatImpl(settings, state, frame);\n+}\n+}\ndiff --git a/src/Parsers/ASTWithElement.h b/src/Parsers/ASTWithElement.h\nnew file mode 100644\nindex 000000000000..97c68579fa11\n--- /dev/null\n+++ b/src/Parsers/ASTWithElement.h\n@@ -0,0 +1,25 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+\n+\n+namespace DB\n+{\n+/** subquery in with statement\n+  */\n+class ASTWithElement : public IAST\n+{\n+public:\n+    String name;\n+    ASTPtr subquery;\n+\n+    /** Get the text that identifies this element. */\n+    String getID(char) const override { return \"WithElement\"; }\n+\n+    ASTPtr clone() const override;\n+\n+protected:\n+    void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n+};\n+\n+}\ndiff --git a/src/Parsers/ParserSelectQuery.cpp b/src/Parsers/ParserSelectQuery.cpp\nindex d2d7bbf9f21f..9f2df82b4b4a 100644\n--- a/src/Parsers/ParserSelectQuery.cpp\n+++ b/src/Parsers/ParserSelectQuery.cpp\n@@ -8,6 +8,7 @@\n #include <Parsers/ParserSampleRatio.h>\n #include <Parsers/ParserSelectQuery.h>\n #include <Parsers/ParserTablesInSelectQuery.h>\n+#include <Parsers/ParserWithElement.h>\n \n \n namespace DB\n@@ -74,7 +75,10 @@ bool ParserSelectQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         if (s_with.ignore(pos, expected))\n         {\n-            if (!exp_list_for_with_clause.parse(pos, with_expression_list, expected))\n+            if (!ParserList(std::make_unique<ParserWithElement>(), std::make_unique<ParserToken>(TokenType::Comma))\n+                     .parse(pos, with_expression_list, expected))\n+                return false;\n+            if (with_expression_list->children.empty())\n                 return false;\n         }\n     }\ndiff --git a/src/Parsers/ParserWithElement.cpp b/src/Parsers/ParserWithElement.cpp\nnew file mode 100644\nindex 000000000000..048e891f0df2\n--- /dev/null\n+++ b/src/Parsers/ParserWithElement.cpp\n@@ -0,0 +1,39 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTSubquery.h>\n+#include <Parsers/ASTWithElement.h>\n+#include <Parsers/CommonParsers.h>\n+#include <Parsers/ExpressionElementParsers.h>\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/ParserWithElement.h>\n+\n+\n+namespace DB\n+{\n+bool ParserWithElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ParserIdentifier s_ident;\n+    ParserKeyword s_as(\"AS\");\n+    ParserSubquery s_subquery;\n+\n+    auto old_pos = pos;\n+    if (ASTPtr name, subquery;\n+        s_ident.parse(pos, name, expected) && s_as.ignore(pos, expected) && s_subquery.parse(pos, subquery, expected))\n+    {\n+        auto with_element = std::make_shared<ASTWithElement>();\n+        tryGetIdentifierNameInto(name, with_element->name);\n+        with_element->subquery = subquery;\n+        node = with_element;\n+    }\n+    else\n+    {\n+        pos = old_pos;\n+        ParserExpressionWithOptionalAlias s_expr(false);\n+        if (!s_expr.parse(pos, node, expected))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+\n+}\ndiff --git a/src/Parsers/ParserWithElement.h b/src/Parsers/ParserWithElement.h\nnew file mode 100644\nindex 000000000000..75ad11f5debe\n--- /dev/null\n+++ b/src/Parsers/ParserWithElement.h\n@@ -0,0 +1,18 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+\n+\n+namespace DB\n+{\n+/** WITH (scalar query) AS identifier\n+  *  or WITH identifier AS (subquery)\n+  */\n+class ParserWithElement : public IParserBase\n+{\n+protected:\n+    const char * getName() const override { return \"WITH element\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/ya.make b/src/Parsers/ya.make\nindex fabf2bbb8fd6..0a0c301b7224 100644\n--- a/src/Parsers/ya.make\n+++ b/src/Parsers/ya.make\n@@ -61,6 +61,7 @@ SRCS(\n     ASTTTLElement.cpp\n     ASTUserNameWithHost.cpp\n     ASTWithAlias.cpp\n+    ASTWithElement.cpp\n     CommonParsers.cpp\n     ExpressionElementParsers.cpp\n     ExpressionListParsers.cpp\n@@ -133,6 +134,7 @@ SRCS(\n     ParserUseQuery.cpp\n     ParserUserNameWithHost.cpp\n     ParserWatchQuery.cpp\n+    ParserWithElement.cpp\n     parseUserName.cpp\n     queryToString.cpp\n     QueryWithOutputSettingsPushDownVisitor.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01495_subqueries_in_with_statement.reference b/tests/queries/0_stateless/01495_subqueries_in_with_statement.reference\nnew file mode 100644\nindex 000000000000..8e851cd3ba1b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01495_subqueries_in_with_statement.reference\n@@ -0,0 +1,14 @@\n+0\n+1\n+2\n+3\n+4\n+2\t3\n+4\t5\n+2\t3\n+4\t5\n+1\t1\t2\n+3\t3\t4\n+4\t5\n+4\t5\n+4\t5\ndiff --git a/tests/queries/0_stateless/01495_subqueries_in_with_statement.sql b/tests/queries/0_stateless/01495_subqueries_in_with_statement.sql\nnew file mode 100644\nindex 000000000000..9ec921a9d4cb\n--- /dev/null\n+++ b/tests/queries/0_stateless/01495_subqueries_in_with_statement.sql\n@@ -0,0 +1,13 @@\n+DROP TABLE IF EXISTS test1;\n+\n+CREATE TABLE test1(i int, j int) ENGINE Log;\n+\n+INSERT INTO test1 VALUES (1, 2), (3, 4);\n+\n+WITH test1 AS (SELECT * FROM numbers(5)) SELECT * FROM test1;\n+WITH test1 AS (SELECT i + 1, j + 1 FROM test1) SELECT * FROM test1;\n+WITH test1 AS (SELECT i + 1, j + 1 FROM test1) SELECT * FROM (SELECT * FROM test1);\n+SELECT * FROM (WITH test1 AS (SELECT toInt32(*) i FROM numbers(5)) SELECT * FROM test1) l ANY INNER JOIN test1 r on (l.i == r.i);\n+WITH test1 AS (SELECT i + 1, j + 1 FROM test1) SELECT toInt64(4) i, toInt64(5) j FROM numbers(3) WHERE (i, j) IN test1;\n+\n+DROP TABLE IF EXISTS test1;\n",
  "problem_statement": "Support for non-scalar subqueries in WITH.\nThey can be substituted in FROM / IN sections as is.\r\nStill only for non-dependent subqueries.\r\n\r\nExample: \r\n\r\n```\r\nWITH (SELECT 1) AS t\r\nSELECT * FROM t\r\n```\nSupport for non-scalar values in WITH clause\nWill ClickHouse support WITH clause (common table expression, cte)? Like https://www.postgresql.org/docs/9.1/static/queries-with.html\r\n\r\nThe thing that with CTE I can define temp dataset I can then query multiple times in one query statement. Currently, I'm running the same query twice as two subqueries. For example 1) to find distinct IDs and then 2) to get actual data that can be joined on those IDs I found before.\n",
  "hints_text": "It would be wonderful if it could work recursively. For example,\r\n```\r\nwith (select * from table_name) as a;\r\n\r\nwith (select * from a where column = 1) as b;\r\n\r\nselect * from b\r\n```\nBump.\n@simPod I am interested in the same, but I've seen it mentioned in other issues that if you have identical subqueries, ClickHouse only actually runs it once.\nClickhouse supports `WITH` clause since mid 2017, but only for scalar values. \r\n\r\nSample syntax:\r\n```\r\nWITH \r\n  [1,2,3,4,5,6,7,8,9] as numbers,\r\n  arrayMap(x -> x*2, numbers) as doubled_numbers,\r\n  arrayMap(x -> x*x, numbers) as squared_numbers,\r\n  arrayMap( (x,y) -> x+y, doubled_numbers, squared_numbers) as summed_numbers\r\nSELECT\r\n   summed_numbers;\r\n```\n@derekperkins cool, good to know, thanks!\nAre there any plans to support WITH clause for non-scalar values?\nStill not for the first half of 2019.\nThanks for update, your work is appreacited!\nDo we have any trick to make a temporary table work like WITH?\n@alexey-milovidov is it true that \r\n> if you have identical subqueries, ClickHouse only actually runs it once\r\n\r\nare there any preconditions for it to work?\r\n\r\nI have created this query\r\n\r\n```sql\r\nSELECT *\r\nFROM (\r\n    SELECT (intDiv(toUInt32(`time`), 300) * 300) AS `time`,\r\n        avg(volume) AS volume\r\n    FROM (\r\n          SELECT `time`,\r\n              sum(volume) AS volume\r\n          FROM (\r\n                SELECT (intDiv(toUInt32(fetched_at), 60) * 60) AS `time`,\r\n                    port_id,\r\n                    avg(\"bits_in\") / 100 AS volume\r\n                FROM counter_bit\r\n                WHERE port_id IN ('50871ea4-b52a-4179-8d2b-3a8616a0cbba', '7fcd5ffa-c4fb-4bc3-ab4e-26f47100e5ae') AND\r\n                    fetched_at BETWEEN '2019-02-25 16:29:17' AND '2019-02-26 16:29:17'\r\n                GROUP BY `time`, port_id\r\n              )\r\n          GROUP BY `time`\r\n        )\r\n    GROUP BY `time`\r\n    )\r\n     CROSS JOIN (\r\n    SELECT avg(volume) AS avg,\r\n        max((`time`, volume)) . 2 AS current,\r\n        max((volume, `time`)) AS max,\r\n        quantile(0.95)(volume) AS p95,\r\n        avg(volume) * count() * 60 AS sum\r\n    FROM (\r\n          SELECT `time`,\r\n              sum(volume) AS volume\r\n          FROM (\r\n                SELECT `time`,\r\n                    sum(volume) AS volume\r\n                FROM (\r\n                      SELECT (intDiv(toUInt32(fetched_at), 60) * 60) AS `time`,\r\n                          port_id,\r\n                          avg(\"bits_in\") / 100 AS volume\r\n                      FROM counter_bit\r\n                      WHERE port_id IN ('50871ea4-b52a-4179-8d2b-3a8616a0cbba', '7fcd5ffa-c4fb-4bc3-ab4e-26f47100e5ae') AND\r\n                          fetched_at BETWEEN '2019-02-25 16:29:17' AND '2019-02-26 16:29:17'\r\n                      GROUP BY `time`, port_id\r\n                    )\r\n                GROUP BY `time`\r\n                UNION ALL\r\n                SELECT intDiv(\r\n                           toUInt32(\r\n                               toDateTime('2019-02-25 16:29:17') + number * 60\r\n                               ),\r\n                           60\r\n                           ) * 60 AS `time`,\r\n                    toFloat64(0) AS volume\r\n                FROM numbers(toUInt64(((toDateTime('2019-02-26 16:29:17') - toDateTime('2019-02-25 16:29:17')) / 60)))\r\n              )\r\n          GROUP BY `time`\r\n        )\r\n    )\r\nORDER BY `time`\r\n```\r\n\r\nwhere the inner select is identical\r\n\r\n```sql\r\n                      SELECT (intDiv(toUInt32(fetched_at), 60) * 60) AS `time`,\r\n                          port_id,\r\n                          avg(\"bits_in\") / 100 AS volume\r\n                      FROM counter_bit\r\n                      WHERE port_id IN ('50871ea4-b52a-4179-8d2b-3a8616a0cbba', '7fcd5ffa-c4fb-4bc3-ab4e-26f47100e5ae') AND\r\n                          fetched_at BETWEEN '2019-02-25 16:29:17' AND '2019-02-26 16:29:17'\r\n                      GROUP BY `time`, port_id\r\n```\r\n\r\nBut number of rows that are required to be processed is doubled so the result is not reused.\n@derekperkins Could you please show me the issue or link proving you words about ClickHouse only actually runs it once,  if you have identical subqueries? Thank you\n@alexey-milovidov I noticed that `WITH clause` speedups my query which involves a big bitmap(cardinality 99M ) filter from 394s to 93s. Could you  explain why it happen? Thanks!\r\n\r\nThe original query:\r\n```\r\nSELECT\r\n    toDate ( order_complete_time ) AS rowData,\r\n    city_tier AS columnData,\r\n    count( DISTINCT mid_seq ),\r\n    toDecimal128 ( SUM( order_total_sales ), 0 ),\r\n    count( 1 ),\r\n    toDecimal128 ( avg( order_total_sales ), 0 ),\r\n    countIf (\r\n        1 = hasAny ( [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ], detail.p_item_code ) \r\n        AND 0 = hasAll ( [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ], detail.p_item_code ) \r\n    ) AS addonGC,\r\n    avgIf (\r\n        order_total_sales,\r\n        (\r\n            1 = hasAny ( [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ], detail.p_item_code ) \r\n            AND 0 = hasAll ( [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ], detail.p_item_code ) \r\n        ) \r\n    ) AS addonAC,\r\n    countIf (\r\n        1 = hasAny ( [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ], detail.p_item_code ) \r\n        AND 0 = hasAll ( [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ], detail.p_item_code ) \r\n    ) / count( 1 ) AS addonRate \r\nFROM\r\n    dist_cdp_orders_test \r\nWHERE\r\n    toDate ( order_complete_time ) GLOBAL IN (\r\n    SELECT\r\n        toDate ( order_complete_time ) AS ROW \r\n    FROM\r\n        dist_cdp_orders_test \r\n    WHERE\r\n        ( order_complete_time >= '2019-07-01 00:00:00' AND order_complete_time <= '2019-07-31 23:59:59' ) \r\n        AND ( bitmapContains ( ( SELECT mid_seqs FROM cdp_segments WHERE seg_id = '8afe10136d333333016d339320100006' LIMIT 1 ), mid_seq ) ) \r\n    GROUP BY\r\n    ROW \r\n    ORDER BY\r\n    ROW DESC \r\n        LIMIT 0,\r\n        10 \r\n    ) \r\n    AND ( order_complete_time >= '2019-07-01 00:00:00' AND order_complete_time <= '2019-07-31 23:59:59' ) \r\n    AND ( bitmapContains ( ( SELECT mid_seqs FROM cdp_segments WHERE seg_id = '8afe10136d333333016d339320100006' LIMIT 1 ), mid_seq ) ) \r\nGROUP BY\r\n    rowData,\r\n    columnData \r\nORDER BY\r\n    rowData DESC\r\n\r\n``` \r\n\r\nRewrite with` WITH clause`:\r\n```\r\nWITH \r\n    [ '2434', '1440', '2435', '4937', '3449', '3452', '1600', '1100', '1403', '3466' ] AS item_codes,\r\n    (SELECT mid_seqs FROM cdp_segments WHERE seg_id = '8afe10136d333333016d339320100006' LIMIT 1) AS bm\r\nSELECT\r\n    toDate ( order_complete_time ) AS rowData,\r\n    city_tier AS columnData,\r\n    count( DISTINCT mid_seq ),\r\n    toDecimal128 ( SUM( order_total_sales ), 0 ),\r\n    count( 1 ),\r\n    toDecimal128 ( avg( order_total_sales ), 0 ),\r\n    countIf (\r\n        1 = hasAny ( item_codes, detail.p_item_code ) \r\n        AND 0 = hasAll ( item_codes, detail.p_item_code ) \r\n    ) AS addonGC,\r\n    avgIf (\r\n        order_total_sales,\r\n        (\r\n            1 = hasAny ( item_codes, detail.p_item_code ) \r\n            AND 0 = hasAll ( item_codes, detail.p_item_code ) \r\n        ) \r\n    ) AS addonAC,\r\n    countIf (\r\n        1 = hasAny ( item_codes, detail.p_item_code ) \r\n        AND 0 = hasAll ( item_codes, detail.p_item_code ) \r\n    ) / count( 1 ) AS addonRate \r\nFROM\r\n    dist_cdp_orders_test \r\nWHERE\r\n    toDate ( order_complete_time ) GLOBAL IN (\r\n    WITH (SELECT mid_seqs FROM cdp_segments WHERE seg_id = '8afe10136d333333016d339320100006' LIMIT 1) AS bm\r\n    SELECT\r\n        toDate ( order_complete_time ) AS ROW \r\n    FROM\r\n        dist_cdp_orders_test \r\n    WHERE\r\n        ( order_complete_time >= '2019-07-01 00:00:00' AND order_complete_time <= '2019-07-31 23:59:59' ) \r\n        AND ( bitmapContains ( bm, mid_seq ) ) \r\n    GROUP BY\r\n    ROW \r\n    ORDER BY\r\n    ROW DESC \r\n        LIMIT 0,\r\n        10 \r\n    ) \r\n    AND ( order_complete_time >= '2019-07-01 00:00:00' AND order_complete_time <= '2019-07-31 23:59:59' ) \r\n    AND ( bitmapContains ( bm, mid_seq ) ) \r\nGROUP BY\r\n    rowData,\r\n    columnData \r\nORDER BY\r\n    rowData DESC;\r\n\r\n```\r\n\nThis task is still relevant, but is not assigned yet. There is high chance that we will assign it in nearest weeks.\n@alexey-milovidov \r\nwill this end up like \r\n```SQL\r\nWITH (SELECT a, b FROM t) as t1\r\nSELECT * FROM t1 WHERE a=1\r\n```\nto reuse subquery result , please save a kid has suffered so much \uff01\uff01\uff01\r\n`WITH (SELECT  a, b, c FROM test) AS a_ table`\n> to reuse subquery result , please save a kid has suffered so much \uff01\uff01\uff01\r\n> `WITH (SELECT a, b, c FROM test) AS a_ table`\r\n\r\ntemporary tables https://clickhouse.yandex/docs/en/query_language/create/#temporary-tables\n> > to reuse subquery result , please save a kid has suffered so much \uff01\uff01\uff01\r\n> > `WITH (SELECT a, b, c FROM test) AS a_ table`\r\n> \r\n> temporary tables https://clickhouse.yandex/docs/en/query_language/create/#temporary-tables\r\n\r\nthis is not a very  appropriate solution\n\r\n> this is not a very appropriate solution\r\n\r\nThere is no other solutions. So. ",
  "created_at": "2020-09-12T17:07:04Z"
}