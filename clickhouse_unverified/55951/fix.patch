diff --git a/src/Analyzer/FunctionNode.h b/src/Analyzer/FunctionNode.h
index 742374e1f0a0..92bf627b7025 100644
--- a/src/Analyzer/FunctionNode.h
+++ b/src/Analyzer/FunctionNode.h
@@ -44,7 +44,7 @@ using FunctionOverloadResolverPtr = std::shared_ptr<IFunctionOverloadResolver>;
 class FunctionNode;
 using FunctionNodePtr = std::shared_ptr<FunctionNode>;
 
-enum class FunctionKind
+enum class FunctionKind : UInt8
 {
     UNKNOWN,
     ORDINARY,
diff --git a/src/Analyzer/InDepthQueryTreeVisitor.h b/src/Analyzer/InDepthQueryTreeVisitor.h
index 59ee57996c47..dec329b5403e 100644
--- a/src/Analyzer/InDepthQueryTreeVisitor.h
+++ b/src/Analyzer/InDepthQueryTreeVisitor.h
@@ -15,6 +15,11 @@
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int LOGICAL_ERROR;
+}
+
 /** Visitor that traverse query tree in depth.
   * Derived class must implement `visitImpl` method.
   * Additionally subclass can control if child need to be visited using `needChildVisit` method, by
@@ -99,7 +104,7 @@ using ConstInDepthQueryTreeVisitor = InDepthQueryTreeVisitor<Derived, true /*con
   * 2. enterImpl – This method is called before children are processed.
   * 3. leaveImpl – This method is called after children are processed.
   */
-template <typename Derived, bool const_visitor = false>
+template <typename Derived>
 class InDepthQueryTreeVisitorWithContext
 {
 public:
@@ -169,31 +174,45 @@ class InDepthQueryTreeVisitorWithContext
         return *static_cast<Derived *>(this);
     }
 
-    bool shouldSkipSubtree(
+    void visitChildIfNeeded(
         VisitQueryTreeNodeType & parent,
-        VisitQueryTreeNodeType & child,
-        size_t subtree_index)
+        VisitQueryTreeNodeType & child)
     {
         bool need_visit_child = getDerived().needChildVisit(parent, child);
         if (!need_visit_child)
-            return true;
+            return;
 
+        // We do not visit ListNode with arguments of TableFunctionNode directly, because
+        // we need to know which arguments are in the unresolved state.
+        // It must be safe because we do not modify table function arguments list in any visitor.
         if (auto * table_function_node = parent->as<TableFunctionNode>())
         {
+            if (child != table_function_node->getArgumentsNode())
+                throw Exception(ErrorCodes::LOGICAL_ERROR, "TableFunctioNode is expected to have only one child node");
+
             const auto & unresolved_indexes = table_function_node->getUnresolvedArgumentIndexes();
-            return std::find(unresolved_indexes.begin(), unresolved_indexes.end(), subtree_index) != unresolved_indexes.end();
+
+            size_t index = 0;
+            for (auto & argument : table_function_node->getArguments())
+            {
+                if (std::find(unresolved_indexes.begin(),
+                              unresolved_indexes.end(),
+                              index) == unresolved_indexes.end())
+                    visit(argument);
+                ++index;
+            }
+            return;
         }
-        return false;
+        else
+            visit(child);
     }
 
     void visitChildren(VisitQueryTreeNodeType & expression)
     {
-        size_t index = 0;
         for (auto & child : expression->getChildren())
         {
-            if (child && !shouldSkipSubtree(expression, child, index))
-                visit(child);
-            ++index;
+            if (child)
+                visitChildIfNeeded(expression, child);
         }
     }
 
diff --git a/src/Analyzer/Passes/IfConstantConditionPass.cpp b/src/Analyzer/Passes/IfConstantConditionPass.cpp
index 6f9cfe482f1c..fedd7ddc9320 100644
--- a/src/Analyzer/Passes/IfConstantConditionPass.cpp
+++ b/src/Analyzer/Passes/IfConstantConditionPass.cpp
@@ -5,6 +5,7 @@
 #include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/Utils.h>
 
 namespace DB
 {
@@ -12,10 +13,13 @@ namespace DB
 namespace
 {
 
-class IfConstantConditionVisitor : public InDepthQueryTreeVisitor<IfConstantConditionVisitor>
+class IfConstantConditionVisitor : public InDepthQueryTreeVisitorWithContext<IfConstantConditionVisitor>
 {
 public:
-    static void visitImpl(QueryTreeNodePtr & node)
+    using Base = InDepthQueryTreeVisitorWithContext<IfConstantConditionVisitor>;
+    using Base::Base;
+
+    void enterImpl(QueryTreeNodePtr & node)
     {
         auto * function_node = node->as<FunctionNode>();
         if (!function_node || (function_node->getFunctionName() != "if" && function_node->getFunctionName() != "multiIf"))
@@ -40,18 +44,22 @@ class IfConstantConditionVisitor : public InDepthQueryTreeVisitor<IfConstantCond
         else
             return;
 
+        QueryTreeNodePtr argument_node;
         if (condition_boolean_value)
-            node = function_node->getArguments().getNodes()[1];
+            argument_node = function_node->getArguments().getNodes()[1];
         else
-            node = function_node->getArguments().getNodes()[2];
+            argument_node = function_node->getArguments().getNodes()[2];
+
+        if (node->getResultType()->equals(*argument_node->getResultType()))
+            node = argument_node;
     }
 };
 
 }
 
-void IfConstantConditionPass::run(QueryTreeNodePtr query_tree_node, ContextPtr)
+void IfConstantConditionPass::run(QueryTreeNodePtr query_tree_node, ContextPtr context)
 {
-    IfConstantConditionVisitor visitor;
+    IfConstantConditionVisitor visitor(std::move(context));
     visitor.visit(query_tree_node);
 }
 
diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp
index 5e8f2ab8e610..9b3a77e7e931 100644
--- a/src/Analyzer/Utils.cpp
+++ b/src/Analyzer/Utils.cpp
@@ -10,6 +10,8 @@
 #include <DataTypes/DataTypeArray.h>
 #include <DataTypes/DataTypeLowCardinality.h>
 
+#include <AggregateFunctions/AggregateFunctionFactory.h>
+
 #include <Functions/FunctionHelpers.h>
 #include <Functions/FunctionFactory.h>
 
@@ -513,6 +515,31 @@ class CheckFunctionExistsVisitor : public ConstInDepthQueryTreeVisitor<CheckFunc
     bool has_function = false;
 };
 
+inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode * function_node)
+{
+    Array parameters;
+    for (const auto & param : function_node->getParameters())
+    {
+        auto * constant = param->as<ConstantNode>();
+        parameters.push_back(constant->getValue());
+    }
+
+    const auto & function_node_argument_nodes = function_node->getArguments().getNodes();
+
+    DataTypes argument_types;
+    argument_types.reserve(function_node_argument_nodes.size());
+
+    for (const auto & function_node_argument : function_node_argument_nodes)
+        argument_types.emplace_back(function_node_argument->getResultType());
+
+    AggregateFunctionProperties properties;
+    return AggregateFunctionFactory::instance().get(
+        function_node->getFunctionName(),
+        argument_types,
+        parameters,
+        properties);
+}
+
 }
 
 bool hasFunctionNode(const QueryTreeNodePtr & node, std::string_view function_name)
@@ -573,6 +600,32 @@ void replaceColumns(QueryTreeNodePtr & node,
     visitor.visit(node);
 }
 
+void rerunFunctionResolve(FunctionNode * function_node, ContextPtr context)
+{
+    if (!function_node->isResolved())
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Trying to rerun resolve of unresolved function '{}'", function_node->getFunctionName());
+
+    const auto & name = function_node->getFunctionName();
+    if (function_node->isOrdinaryFunction())
+    {
+        // Special case, don't need to be resolved. It must be processed by GroupingFunctionsResolvePass.
+        if (name == "grouping")
+            return;
+        auto function = FunctionFactory::instance().get(name, context);
+        function_node->resolveAsFunction(function->build(function_node->getArgumentColumns()));
+    }
+    else if (function_node->isAggregateFunction())
+    {
+        if (name == "nothing")
+            return;
+        function_node->resolveAsAggregateFunction(resolveAggregateFunction(function_node));
+    }
+    else if (function_node->isWindowFunction())
+    {
+        function_node->resolveAsWindowFunction(resolveAggregateFunction(function_node));
+    }
+}
+
 namespace
 {
 
@@ -605,4 +658,5 @@ NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node)
     visitor.visit(node);
     return out;
 }
+
 }
diff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h
index 6756c4d313c3..2bf12f01d8ab 100644
--- a/src/Analyzer/Utils.h
+++ b/src/Analyzer/Utils.h
@@ -7,6 +7,8 @@
 namespace DB
 {
 
+class FunctionNode;
+
 /// Returns true if node part of root tree, false otherwise
 bool isNodePartOfTree(const IQueryTreeNode * node, const IQueryTreeNode * root);
 
@@ -83,6 +85,10 @@ void replaceColumns(QueryTreeNodePtr & node,
     const QueryTreeNodePtr & table_expression_node,
     const std::unordered_map<std::string, QueryTreeNodePtr> & column_name_to_node);
 
+/** Resolve function node again using it's content.
+  * This function should be called when arguments or parameters are changed.
+  */
+void rerunFunctionResolve(FunctionNode * function_node, ContextPtr context);
 
 /// Just collect all identifiers from query tree
 NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node);
