{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55951,
  "instance_id": "ClickHouse__ClickHouse-55951",
  "issue_numbers": [
    "53717"
  ],
  "base_commit": "f560e7ee52cd43717759ead2abf7e40d4b318dea",
  "patch": "diff --git a/src/Analyzer/FunctionNode.h b/src/Analyzer/FunctionNode.h\nindex 742374e1f0a0..92bf627b7025 100644\n--- a/src/Analyzer/FunctionNode.h\n+++ b/src/Analyzer/FunctionNode.h\n@@ -44,7 +44,7 @@ using FunctionOverloadResolverPtr = std::shared_ptr<IFunctionOverloadResolver>;\n class FunctionNode;\n using FunctionNodePtr = std::shared_ptr<FunctionNode>;\n \n-enum class FunctionKind\n+enum class FunctionKind : UInt8\n {\n     UNKNOWN,\n     ORDINARY,\ndiff --git a/src/Analyzer/InDepthQueryTreeVisitor.h b/src/Analyzer/InDepthQueryTreeVisitor.h\nindex 59ee57996c47..dec329b5403e 100644\n--- a/src/Analyzer/InDepthQueryTreeVisitor.h\n+++ b/src/Analyzer/InDepthQueryTreeVisitor.h\n@@ -15,6 +15,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n /** Visitor that traverse query tree in depth.\n   * Derived class must implement `visitImpl` method.\n   * Additionally subclass can control if child need to be visited using `needChildVisit` method, by\n@@ -99,7 +104,7 @@ using ConstInDepthQueryTreeVisitor = InDepthQueryTreeVisitor<Derived, true /*con\n   * 2. enterImpl \u2013 This method is called before children are processed.\n   * 3. leaveImpl \u2013 This method is called after children are processed.\n   */\n-template <typename Derived, bool const_visitor = false>\n+template <typename Derived>\n class InDepthQueryTreeVisitorWithContext\n {\n public:\n@@ -169,31 +174,45 @@ class InDepthQueryTreeVisitorWithContext\n         return *static_cast<Derived *>(this);\n     }\n \n-    bool shouldSkipSubtree(\n+    void visitChildIfNeeded(\n         VisitQueryTreeNodeType & parent,\n-        VisitQueryTreeNodeType & child,\n-        size_t subtree_index)\n+        VisitQueryTreeNodeType & child)\n     {\n         bool need_visit_child = getDerived().needChildVisit(parent, child);\n         if (!need_visit_child)\n-            return true;\n+            return;\n \n+        // We do not visit ListNode with arguments of TableFunctionNode directly, because\n+        // we need to know which arguments are in the unresolved state.\n+        // It must be safe because we do not modify table function arguments list in any visitor.\n         if (auto * table_function_node = parent->as<TableFunctionNode>())\n         {\n+            if (child != table_function_node->getArgumentsNode())\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"TableFunctioNode is expected to have only one child node\");\n+\n             const auto & unresolved_indexes = table_function_node->getUnresolvedArgumentIndexes();\n-            return std::find(unresolved_indexes.begin(), unresolved_indexes.end(), subtree_index) != unresolved_indexes.end();\n+\n+            size_t index = 0;\n+            for (auto & argument : table_function_node->getArguments())\n+            {\n+                if (std::find(unresolved_indexes.begin(),\n+                              unresolved_indexes.end(),\n+                              index) == unresolved_indexes.end())\n+                    visit(argument);\n+                ++index;\n+            }\n+            return;\n         }\n-        return false;\n+        else\n+            visit(child);\n     }\n \n     void visitChildren(VisitQueryTreeNodeType & expression)\n     {\n-        size_t index = 0;\n         for (auto & child : expression->getChildren())\n         {\n-            if (child && !shouldSkipSubtree(expression, child, index))\n-                visit(child);\n-            ++index;\n+            if (child)\n+                visitChildIfNeeded(expression, child);\n         }\n     }\n \ndiff --git a/src/Analyzer/Passes/IfConstantConditionPass.cpp b/src/Analyzer/Passes/IfConstantConditionPass.cpp\nindex 6f9cfe482f1c..fedd7ddc9320 100644\n--- a/src/Analyzer/Passes/IfConstantConditionPass.cpp\n+++ b/src/Analyzer/Passes/IfConstantConditionPass.cpp\n@@ -5,6 +5,7 @@\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n+#include <Analyzer/Utils.h>\n \n namespace DB\n {\n@@ -12,10 +13,13 @@ namespace DB\n namespace\n {\n \n-class IfConstantConditionVisitor : public InDepthQueryTreeVisitor<IfConstantConditionVisitor>\n+class IfConstantConditionVisitor : public InDepthQueryTreeVisitorWithContext<IfConstantConditionVisitor>\n {\n public:\n-    static void visitImpl(QueryTreeNodePtr & node)\n+    using Base = InDepthQueryTreeVisitorWithContext<IfConstantConditionVisitor>;\n+    using Base::Base;\n+\n+    void enterImpl(QueryTreeNodePtr & node)\n     {\n         auto * function_node = node->as<FunctionNode>();\n         if (!function_node || (function_node->getFunctionName() != \"if\" && function_node->getFunctionName() != \"multiIf\"))\n@@ -40,18 +44,22 @@ class IfConstantConditionVisitor : public InDepthQueryTreeVisitor<IfConstantCond\n         else\n             return;\n \n+        QueryTreeNodePtr argument_node;\n         if (condition_boolean_value)\n-            node = function_node->getArguments().getNodes()[1];\n+            argument_node = function_node->getArguments().getNodes()[1];\n         else\n-            node = function_node->getArguments().getNodes()[2];\n+            argument_node = function_node->getArguments().getNodes()[2];\n+\n+        if (node->getResultType()->equals(*argument_node->getResultType()))\n+            node = argument_node;\n     }\n };\n \n }\n \n-void IfConstantConditionPass::run(QueryTreeNodePtr query_tree_node, ContextPtr)\n+void IfConstantConditionPass::run(QueryTreeNodePtr query_tree_node, ContextPtr context)\n {\n-    IfConstantConditionVisitor visitor;\n+    IfConstantConditionVisitor visitor(std::move(context));\n     visitor.visit(query_tree_node);\n }\n \ndiff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp\nindex 5e8f2ab8e610..9b3a77e7e931 100644\n--- a/src/Analyzer/Utils.cpp\n+++ b/src/Analyzer/Utils.cpp\n@@ -10,6 +10,8 @@\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n \n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+\n #include <Functions/FunctionHelpers.h>\n #include <Functions/FunctionFactory.h>\n \n@@ -513,6 +515,31 @@ class CheckFunctionExistsVisitor : public ConstInDepthQueryTreeVisitor<CheckFunc\n     bool has_function = false;\n };\n \n+inline AggregateFunctionPtr resolveAggregateFunction(FunctionNode * function_node)\n+{\n+    Array parameters;\n+    for (const auto & param : function_node->getParameters())\n+    {\n+        auto * constant = param->as<ConstantNode>();\n+        parameters.push_back(constant->getValue());\n+    }\n+\n+    const auto & function_node_argument_nodes = function_node->getArguments().getNodes();\n+\n+    DataTypes argument_types;\n+    argument_types.reserve(function_node_argument_nodes.size());\n+\n+    for (const auto & function_node_argument : function_node_argument_nodes)\n+        argument_types.emplace_back(function_node_argument->getResultType());\n+\n+    AggregateFunctionProperties properties;\n+    return AggregateFunctionFactory::instance().get(\n+        function_node->getFunctionName(),\n+        argument_types,\n+        parameters,\n+        properties);\n+}\n+\n }\n \n bool hasFunctionNode(const QueryTreeNodePtr & node, std::string_view function_name)\n@@ -573,6 +600,32 @@ void replaceColumns(QueryTreeNodePtr & node,\n     visitor.visit(node);\n }\n \n+void rerunFunctionResolve(FunctionNode * function_node, ContextPtr context)\n+{\n+    if (!function_node->isResolved())\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Trying to rerun resolve of unresolved function '{}'\", function_node->getFunctionName());\n+\n+    const auto & name = function_node->getFunctionName();\n+    if (function_node->isOrdinaryFunction())\n+    {\n+        // Special case, don't need to be resolved. It must be processed by GroupingFunctionsResolvePass.\n+        if (name == \"grouping\")\n+            return;\n+        auto function = FunctionFactory::instance().get(name, context);\n+        function_node->resolveAsFunction(function->build(function_node->getArgumentColumns()));\n+    }\n+    else if (function_node->isAggregateFunction())\n+    {\n+        if (name == \"nothing\")\n+            return;\n+        function_node->resolveAsAggregateFunction(resolveAggregateFunction(function_node));\n+    }\n+    else if (function_node->isWindowFunction())\n+    {\n+        function_node->resolveAsWindowFunction(resolveAggregateFunction(function_node));\n+    }\n+}\n+\n namespace\n {\n \n@@ -605,4 +658,5 @@ NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node)\n     visitor.visit(node);\n     return out;\n }\n+\n }\ndiff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h\nindex 6756c4d313c3..2bf12f01d8ab 100644\n--- a/src/Analyzer/Utils.h\n+++ b/src/Analyzer/Utils.h\n@@ -7,6 +7,8 @@\n namespace DB\n {\n \n+class FunctionNode;\n+\n /// Returns true if node part of root tree, false otherwise\n bool isNodePartOfTree(const IQueryTreeNode * node, const IQueryTreeNode * root);\n \n@@ -83,6 +85,10 @@ void replaceColumns(QueryTreeNodePtr & node,\n     const QueryTreeNodePtr & table_expression_node,\n     const std::unordered_map<std::string, QueryTreeNodePtr> & column_name_to_node);\n \n+/** Resolve function node again using it's content.\n+  * This function should be called when arguments or parameters are changed.\n+  */\n+void rerunFunctionResolve(FunctionNode * function_node, ContextPtr context);\n \n /// Just collect all identifiers from query tree\n NameSet collectIdentifiersFullNames(const QueryTreeNodePtr & node);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00835_if_generic_case.reference b/tests/queries/0_stateless/00835_if_generic_case.reference\nindex 8f9c3f6ef13b..de2d38897a31 100644\n--- a/tests/queries/0_stateless/00835_if_generic_case.reference\n+++ b/tests/queries/0_stateless/00835_if_generic_case.reference\n@@ -4,8 +4,8 @@\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-02 00:00:00\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-02 00:00:00\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-02 00:00:00\n-2000-01-01 00:00:00\t2000-01-02\t2000-01-02\n-2000-01-01 00:00:00\t2000-01-02\t2000-01-02\n+2000-01-01 00:00:00\t2000-01-02\t2000-01-02 00:00:00\n+2000-01-01 00:00:00\t2000-01-02\t2000-01-02 00:00:00\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-01 00:00:00\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-01 00:00:00\n 2000-01-01 00:00:00\t2000-01-02\t2000-01-01 00:00:00\ndiff --git a/tests/queries/0_stateless/02901_remove_nullable_crash_analyzer.reference b/tests/queries/0_stateless/02901_remove_nullable_crash_analyzer.reference\nnew file mode 100644\nindex 000000000000..44e0be8e3569\n--- /dev/null\n+++ b/tests/queries/0_stateless/02901_remove_nullable_crash_analyzer.reference\n@@ -0,0 +1,4 @@\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02901_remove_nullable_crash_analyzer.sql b/tests/queries/0_stateless/02901_remove_nullable_crash_analyzer.sql\nnew file mode 100644\nindex 000000000000..96f88a23a098\n--- /dev/null\n+++ b/tests/queries/0_stateless/02901_remove_nullable_crash_analyzer.sql\n@@ -0,0 +1,6 @@\n+SELECT 1 % ( CASE WHEN 1 THEN (1 IS NOT NULL + *) ELSE NULL END );\n+SELECT CASE 1 WHEN FALSE THEN 1 ELSE CASE WHEN 1 THEN 1 - (CASE 1 WHEN 1 THEN 1 ELSE 1 END) END % 1 END;\n+\n+SELECT 1 % if(1, dummy, NULL); -- { serverError ILLEGAL_DIVISION }\n+SELECT sum(multiIf(1, dummy, NULL));\n+SELECT sum(multiIf(1, dummy, NULL)) OVER ();\n",
  "problem_statement": "ClickHouse Server v23.7.4.5 crashed by a SELECT statement with allow_experimental_analyzer enabled (\"SELECT 1 % (CASE ...\")\n**Describe the bug**\r\nClickHouse Server v23.7.4.5 crashed by a SELECT statement with allow_experimental_analyzer enabled.\r\nIt was found by an in-development fuzzer of WINGFUZZ.\r\n\r\n**How to reproduce**\r\nThe SQL statement to reproduce:\r\n```sql\r\nSELECT 1 % ( CASE WHEN 1 THEN (1 IS NOT NULL + *) ELSE NULL END ) SETTINGS allow_experimental_analyzer = 1 ;\r\n```\r\nIt can be reproduced on the official docker image. (`clickhouse/clickhouse-server:head` (version 23.8.1.2413) and `clickhouse/clickhouse-server:latest` (version 23.7.4.5)).\r\n\r\nThe log traced by ClickHouse Server:\r\n```\r\nSELECT 1 % multiIf(1, (1 IS NOT NULL) + *, NULL)\r\nSETTINGS allow_experimental_analyzer = 1\r\n\r\nQuery id: e2914ca0-8b1f-476d-b485-f8a178f3a877\r\n\r\n[8af69c367457] 2023.08.23 07:50:54.379251 [ 345 ] <Fatal> BaseDaemon: ########################################\r\n[8af69c367457] 2023.08.23 07:50:54.379306 [ 345 ] <Fatal> BaseDaemon: (version 23.8.1.2413 (official build), build id: 4DCA66DD83B2161C82851B4655CD14334A08D535, git hash: 926533306c5969b77571e66163a6930cfce1cf86) (from thread 48) (query_id: e2914ca0-8b1f-476d-b485-f8a178f3a877) (query: SELECT 1 % ( CASE WHEN 1 THEN (1 IS NOT NULL + *) ELSE NULL END ) SETTINGS allow_experimental_analyzer = 1 ;) Received signal Segmentation fault (11)\r\n[8af69c367457] 2023.08.23 07:50:54.379360 [ 345 ] <Fatal> BaseDaemon: Address: 0x18. Access: read. Address not mapped to object.\r\n[8af69c367457] 2023.08.23 07:50:54.379414 [ 345 ] <Fatal> BaseDaemon: Stack trace: 0x000000000a67c7ad 0x000000000a67be4b 0x000000000a67aeba 0x00000000070ba30a 0x00000000070b98ae 0x0000000010a92d6a 0x0000000010a93a82 0x0000000010a94d79 0x00000000113fbecc 0x0000000013253084 0x00000000133ae54e 0x0000000011da4e75 0x0000000011d9f237 0x0000000012137b51 0x000000001213398e 0x0000000012f98d19 0x0000000012faa959 0x0000000015997514 0x0000000015998711 0x0000000015ace847 0x0000000015accb1c 0x00007ffff7f9a609 0x00007ffff7ebf133\r\n[8af69c367457] 2023.08.23 07:50:54.379526 [ 345 ] <Fatal> BaseDaemon: 2. DB::FunctionBinaryArithmetic<DB::ModuloImpl, DB::NameModulo, false, true, true>::executeImpl2(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 63ul, 64ul> const*) const @ 0x000000000a67c7ad in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379576 [ 345 ] <Fatal> BaseDaemon: 3. DB::FunctionBinaryArithmetic<DB::ModuloImpl, DB::NameModulo, false, true, true>::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x000000000a67be4b in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379604 [ 345 ] <Fatal> BaseDaemon: 4. DB::FunctionBinaryArithmeticWithConstants<DB::ModuloImpl, DB::NameModulo, false, true, true>::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x000000000a67aeba in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379660 [ 345 ] <Fatal> BaseDaemon: 5. DB::IFunction::executeImplDryRun(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000070ba30a in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379704 [ 345 ] <Fatal> BaseDaemon: 6. DB::FunctionToExecutableFunctionAdaptor::executeDryRunImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x00000000070b98ae in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379747 [ 345 ] <Fatal> BaseDaemon: 7. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000010a92d6a in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379777 [ 345 ] <Fatal> BaseDaemon: 8. DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000010a93a82 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379803 [ 345 ] <Fatal> BaseDaemon: 9. DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000010a94d79 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379848 [ 345 ] <Fatal> BaseDaemon: 10. DB::ActionsDAG::updateHeader(DB::Block) const @ 0x00000000113fbecc in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379899 [ 345 ] <Fatal> BaseDaemon: 11. DB::ExpressionTransform::transformHeader(DB::Block, DB::ActionsDAG const&) @ 0x0000000013253084 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379950 [ 345 ] <Fatal> BaseDaemon: 12. DB::ExpressionStep::ExpressionStep(DB::DataStream const&, std::shared_ptr<DB::ActionsDAG> const&) @ 0x00000000133ae54e in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.379988 [ 345 ] <Fatal> BaseDaemon: 13. DB::Planner::buildPlanForQueryNode() @ 0x0000000011da4e75 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380014 [ 345 ] <Fatal> BaseDaemon: 14. DB::Planner::buildQueryPlanIfNeeded() @ 0x0000000011d9f237 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380049 [ 345 ] <Fatal> BaseDaemon: 15. DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x0000000012137b51 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380083 [ 345 ] <Fatal> BaseDaemon: 16. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x000000001213398e in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380119 [ 345 ] <Fatal> BaseDaemon: 17. DB::TCPHandler::runImpl() @ 0x0000000012f98d19 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380162 [ 345 ] <Fatal> BaseDaemon: 18. DB::TCPHandler::run() @ 0x0000000012faa959 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380192 [ 345 ] <Fatal> BaseDaemon: 19. Poco::Net::TCPServerConnection::start() @ 0x0000000015997514 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380229 [ 345 ] <Fatal> BaseDaemon: 20. Poco::Net::TCPServerDispatcher::run() @ 0x0000000015998711 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380286 [ 345 ] <Fatal> BaseDaemon: 21. Poco::PooledThread::run() @ 0x0000000015ace847 in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380323 [ 345 ] <Fatal> BaseDaemon: 22. Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000015accb1c in /usr/bin/clickhouse\r\n[8af69c367457] 2023.08.23 07:50:54.380349 [ 345 ] <Fatal> BaseDaemon: 23. ? @ 0x00007ffff7f9a609 in ?\r\n[8af69c367457] 2023.08.23 07:50:54.380368 [ 345 ] <Fatal> BaseDaemon: 24. ? @ 0x00007ffff7ebf133 in ?\r\n[8af69c367457] 2023.08.23 07:50:54.540563 [ 345 ] <Fatal> BaseDaemon: Integrity check of the executable successfully passed (checksum: F37F4F1F1F05354DFEECD70FAB61DC73)\r\n[8af69c367457] 2023.08.23 07:50:54.540852 [ 345 ] <Fatal> BaseDaemon: Report this error to https://github.com/ClickHouse/ClickHouse/issues\r\n[8af69c367457] 2023.08.23 07:50:54.541005 [ 345 ] <Fatal> BaseDaemon: Changed settings: allow_experimental_analyzer = true\r\n```\n",
  "hints_text": "",
  "created_at": "2023-10-23T17:11:55Z"
}