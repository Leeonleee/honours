diff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h
index 3c20446eb154..fbdc308d5bcd 100644
--- a/src/Parsers/ParserCreateQuery.h
+++ b/src/Parsers/ParserCreateQuery.h
@@ -144,8 +144,8 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     /// doesn't check that parsed string is existing data type. In this way
     /// REMOVE keyword can be parsed as data type and further parsing will fail.
     /// So we just check this keyword and in case of success return column
-    /// column declaration with name only.
-    if (s_remove.checkWithoutMoving(pos, expected))
+    /// declaration with name only.
+    if (!require_type && s_remove.checkWithoutMoving(pos, expected))
     {
         if (!check_keywords_after_name)
             return false;
@@ -165,11 +165,12 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     ASTPtr codec_expression;
     ASTPtr ttl_expression;
 
-    if (!s_default.checkWithoutMoving(pos, expected) &&
-        !s_materialized.checkWithoutMoving(pos, expected) &&
-        !s_alias.checkWithoutMoving(pos, expected) &&
-        !s_comment.checkWithoutMoving(pos, expected) &&
-        !s_codec.checkWithoutMoving(pos, expected))
+    if (!s_default.checkWithoutMoving(pos, expected)
+        && !s_materialized.checkWithoutMoving(pos, expected)
+        && !s_alias.checkWithoutMoving(pos, expected)
+        && (require_type
+            || (!s_comment.checkWithoutMoving(pos, expected)
+                && !s_codec.checkWithoutMoving(pos, expected))))
     {
         if (!type_parser.parse(pos, type, expected))
             return false;
