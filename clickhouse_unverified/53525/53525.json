{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53525,
  "instance_id": "ClickHouse__ClickHouse-53525",
  "issue_numbers": [
    "50311"
  ],
  "base_commit": "ec7daed52fdc4bd56c37db89e1650623858e0eeb",
  "patch": "diff --git a/docs/en/sql-reference/functions/hash-functions.md b/docs/en/sql-reference/functions/hash-functions.md\nindex 06097d924807..556fe622c27f 100644\n--- a/docs/en/sql-reference/functions/hash-functions.md\n+++ b/docs/en/sql-reference/functions/hash-functions.md\n@@ -51,7 +51,7 @@ Calculates the MD5 from a string and returns the resulting set of bytes as Fixed\n If you do not need MD5 in particular, but you need a decent cryptographic 128-bit hash, use the \u2018sipHash128\u2019 function instead.\n If you want to get the same result as output by the md5sum utility, use lower(hex(MD5(s))).\n \n-## sipHash64 (#hash_functions-siphash64)\n+## sipHash64 {#hash_functions-siphash64}\n \n Produces a 64-bit [SipHash](https://en.wikipedia.org/wiki/SipHash) hash value.\n \n@@ -63,9 +63,9 @@ This is a cryptographic hash function. It works at least three times faster than\n \n The function [interprets](/docs/en/sql-reference/functions/type-conversion-functions.md/#type_conversion_functions-reinterpretAsString) all the input parameters as strings and calculates the hash value for each of them. It then combines the hashes by the following algorithm:\n \n-1.  The first and the second hash value are concatenated to an array which is hashed.\n-2.  The previously calculated hash value and the hash of the third input parameter are hashed in a similar way.\n-3.  This calculation is repeated for all remaining hash values of the original input.\n+1. The first and the second hash value are concatenated to an array which is hashed.\n+2. The previously calculated hash value and the hash of the third input parameter are hashed in a similar way.\n+3. This calculation is repeated for all remaining hash values of the original input.\n \n **Arguments**\n \ndiff --git a/src/Functions/FunctionsHashing.h b/src/Functions/FunctionsHashing.h\nindex a6a04b4e3134..c4dd14768f5f 100644\n--- a/src/Functions/FunctionsHashing.h\n+++ b/src/Functions/FunctionsHashing.h\n@@ -79,30 +79,56 @@ namespace impl\n         UInt64 key1 = 0;\n     };\n \n-    static SipHashKey parseSipHashKey(const ColumnWithTypeAndName & key)\n+    struct SipHashKeyColumns\n     {\n-        SipHashKey ret{};\n+        ColumnPtr key0;\n+        ColumnPtr key1;\n+        bool is_const;\n \n-        const auto * tuple = checkAndGetColumn<ColumnTuple>(key.column.get());\n+        size_t size() const\n+        {\n+            assert(key0 && key1);\n+            assert(key0->size() == key1->size());\n+            return key0->size();\n+        }\n+        SipHashKey getKey(size_t i) const\n+        {\n+            if (is_const)\n+                i = 0;\n+            const auto & key0data = assert_cast<const ColumnUInt64 &>(*key0).getData();\n+            const auto & key1data = assert_cast<const ColumnUInt64 &>(*key1).getData();\n+            return {key0data[i], key1data[i]};\n+        }\n+    };\n+\n+    static SipHashKeyColumns parseSipHashKeyColumns(const ColumnWithTypeAndName & key)\n+    {\n+        const ColumnTuple * tuple = nullptr;\n+        const auto * column = key.column.get();\n+        bool is_const = false;\n+        if (isColumnConst(*column))\n+        {\n+            is_const = true;\n+            tuple = checkAndGetColumnConstData<ColumnTuple>(column);\n+        }\n+        else\n+            tuple = checkAndGetColumn<ColumnTuple>(column);\n         if (!tuple)\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"key must be a tuple\");\n-\n         if (tuple->tupleSize() != 2)\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"wrong tuple size: key must be a tuple of 2 UInt64\");\n \n-        if (tuple->empty())\n-            return ret;\n-\n-        if (const auto * key0col = checkAndGetColumn<ColumnUInt64>(&(tuple->getColumn(0))))\n-            ret.key0 = key0col->get64(0);\n-        else\n+        SipHashKeyColumns ret{tuple->getColumnPtr(0), tuple->getColumnPtr(1), is_const};\n+        assert(ret.key0);\n+        if (!checkColumn<ColumnUInt64>(*ret.key0))\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"first element of the key tuple is not UInt64\");\n-\n-        if (const auto * key1col = checkAndGetColumn<ColumnUInt64>(&(tuple->getColumn(1))))\n-            ret.key1 = key1col->get64(0);\n-        else\n+        assert(ret.key1);\n+        if (!checkColumn<ColumnUInt64>(*ret.key1))\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"second element of the key tuple is not UInt64\");\n \n+        if (ret.size() == 1)\n+            ret.is_const = true;\n+\n         return ret;\n     }\n }\n@@ -310,8 +336,10 @@ struct SipHash64KeyedImpl\n     static constexpr auto name = \"sipHash64Keyed\";\n     using ReturnType = UInt64;\n     using Key = impl::SipHashKey;\n+    using KeyColumns = impl::SipHashKeyColumns;\n \n-    static Key parseKey(const ColumnWithTypeAndName & key) { return impl::parseSipHashKey(key); }\n+    static KeyColumns parseKeyColumns(const ColumnWithTypeAndName & key) { return impl::parseSipHashKeyColumns(key); }\n+    static Key getKey(const KeyColumns & key, size_t i) { return key.getKey(i); }\n \n     static UInt64 applyKeyed(const Key & key, const char * begin, size_t size) { return sipHash64Keyed(key.key0, key.key1, begin, size); }\n \n@@ -343,8 +371,10 @@ struct SipHash128KeyedImpl\n     static constexpr auto name = \"sipHash128Keyed\";\n     using ReturnType = UInt128;\n     using Key = impl::SipHashKey;\n+    using KeyColumns = impl::SipHashKeyColumns;\n \n-    static Key parseKey(const ColumnWithTypeAndName & key) { return impl::parseSipHashKey(key); }\n+    static KeyColumns parseKeyColumns(const ColumnWithTypeAndName & key) { return impl::parseSipHashKeyColumns(key); }\n+    static Key getKey(const KeyColumns & key, size_t i) { return key.getKey(i); }\n \n     static UInt128 applyKeyed(const Key & key, const char * begin, size_t size) { return sipHash128Keyed(key.key0, key.key1, begin, size); }\n \n@@ -365,13 +395,43 @@ struct SipHash128ReferenceImpl\n \n     using ReturnType = UInt128;\n \n-    static UInt128 combineHashes(UInt128 h1, UInt128 h2) { return combineHashesFunc<UInt128, SipHash128Impl>(h1, h2); }\n+    static UInt128 combineHashes(UInt128 h1, UInt128 h2) { return combineHashesFunc<UInt128, SipHash128ReferenceImpl>(h1, h2); }\n \n     static UInt128 apply(const char * data, const size_t size) { return sipHash128Reference(data, size); }\n \n     static constexpr bool use_int_hash_for_pods = false;\n };\n \n+struct SipHash128ReferenceKeyedImpl\n+{\n+    static constexpr auto name = \"sipHash128ReferenceKeyed\";\n+    using ReturnType = UInt128;\n+    using Key = impl::SipHashKey;\n+    using KeyColumns = impl::SipHashKeyColumns;\n+\n+    static KeyColumns parseKeyColumns(const ColumnWithTypeAndName & key) { return impl::parseSipHashKeyColumns(key); }\n+    static Key getKey(const KeyColumns & key, size_t i) { return key.getKey(i); }\n+\n+    static UInt128 applyKeyed(const Key & key, const char * begin, size_t size)\n+    {\n+        return sipHash128ReferenceKeyed(key.key0, key.key1, begin, size);\n+    }\n+\n+    static UInt128 combineHashesKeyed(const Key & key, UInt128 h1, UInt128 h2)\n+    {\n+#if __BYTE_ORDER__ == __ORDER_BIG_ENDIAN__\n+        UInt128 tmp;\n+        reverseMemcpy(&tmp, &h1, sizeof(UInt128));\n+        h1 = tmp;\n+        reverseMemcpy(&tmp, &h2, sizeof(UInt128));\n+        h2 = tmp;\n+#endif\n+        UInt128 hashes[] = {h1, h2};\n+        return applyKeyed(key, reinterpret_cast<const char *>(hashes), 2 * sizeof(UInt128));\n+    }\n+\n+    static constexpr bool use_int_hash_for_pods = false;\n+};\n \n /** Why we need MurmurHash2?\n   * MurmurHash2 is an outdated hash function, superseded by MurmurHash3 and subsequently by CityHash, xxHash, HighwayHash.\n@@ -981,7 +1041,7 @@ class FunctionIntHash : public TargetSpecific::Default::FunctionIntHash<Impl, Na\n \n DECLARE_MULTITARGET_CODE(\n \n-template <typename Impl, bool Keyed, typename KeyType>\n+template <typename Impl, bool Keyed, typename KeyType, typename KeyColumnsType>\n class FunctionAnyHash : public IFunction\n {\n public:\n@@ -991,9 +1051,12 @@ class FunctionAnyHash : public IFunction\n     using ToType = typename Impl::ReturnType;\n \n     template <typename FromType, bool first>\n-    void executeIntType(const KeyType & key, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n+    void executeIntType(const KeyColumnsType & key_cols, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n     {\n         using ColVecType = ColumnVectorOrDecimal<FromType>;\n+        KeyType key{};\n+        if constexpr (Keyed)\n+            key = Impl::getKey(key_cols, 0);\n \n         if (const ColVecType * col_from = checkAndGetColumn<ColVecType>(column))\n         {\n@@ -1002,6 +1065,11 @@ class FunctionAnyHash : public IFunction\n             for (size_t i = 0; i < size; ++i)\n             {\n                 ToType hash;\n+\n+                if constexpr (Keyed)\n+                    if (!key_cols.is_const && i != 0)\n+                        key = Impl::getKey(key_cols, i);\n+\n                 if constexpr (Impl::use_int_hash_for_pods)\n                 {\n                     if constexpr (std::is_same_v<ToType, UInt64>)\n@@ -1029,6 +1097,14 @@ class FunctionAnyHash : public IFunction\n         }\n         else if (auto col_from_const = checkAndGetColumnConst<ColVecType>(column))\n         {\n+            if constexpr (Keyed)\n+            {\n+                if (!key_cols.is_const)\n+                {\n+                    ColumnPtr full_column = col_from_const->convertToFullColumn();\n+                    return executeIntType<FromType, first>(key_cols, full_column.get(), vec_to);\n+                }\n+            }\n             auto value = col_from_const->template getValue<FromType>();\n \n             ToType hash;\n@@ -1054,8 +1130,15 @@ class FunctionAnyHash : public IFunction\n             if constexpr (first)\n                 vec_to.assign(size, hash);\n             else\n+            {\n                 for (size_t i = 0; i < size; ++i)\n+                {\n+                    if constexpr (Keyed)\n+                        if (!key_cols.is_const && i != 0)\n+                            key = Impl::getKey(key_cols, i);\n                     vec_to[i] = combineHashes(key, vec_to[i], hash);\n+                }\n+            }\n         }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n@@ -1063,9 +1146,12 @@ class FunctionAnyHash : public IFunction\n     }\n \n     template <typename FromType, bool first>\n-    void executeBigIntType(const KeyType & key, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n+    void executeBigIntType(const KeyColumnsType & key_cols, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n     {\n         using ColVecType = ColumnVectorOrDecimal<FromType>;\n+        KeyType key{};\n+        if constexpr (Keyed)\n+            key = Impl::getKey(key_cols, 0);\n \n         static const auto to_little_endian = [](auto & value)\n         {\n@@ -1084,6 +1170,9 @@ class FunctionAnyHash : public IFunction\n             for (size_t i = 0; i < size; ++i)\n             {\n                 ToType hash;\n+                if constexpr (Keyed)\n+                    if (!key_cols.is_const && i != 0)\n+                        key = Impl::getKey(key_cols, i);\n                 if constexpr (std::endian::native == std::endian::little)\n                     hash = apply(key, reinterpret_cast<const char *>(&vec_from[i]), sizeof(vec_from[i]));\n                 else\n@@ -1101,6 +1190,14 @@ class FunctionAnyHash : public IFunction\n         }\n         else if (auto col_from_const = checkAndGetColumnConst<ColVecType>(column))\n         {\n+            if constexpr (Keyed)\n+            {\n+                if (!key_cols.is_const)\n+                {\n+                    ColumnPtr full_column = col_from_const->convertToFullColumn();\n+                    return executeBigIntType<FromType, first>(key_cols, full_column.get(), vec_to);\n+                }\n+            }\n             auto value = col_from_const->template getValue<FromType>();\n             to_little_endian(value);\n \n@@ -1109,8 +1206,15 @@ class FunctionAnyHash : public IFunction\n             if constexpr (first)\n                 vec_to.assign(size, hash);\n             else\n+            {\n                 for (size_t i = 0; i < size; ++i)\n+                {\n+                    if constexpr (Keyed)\n+                        if (!key_cols.is_const && i != 0)\n+                            key = Impl::getKey(key_cols, i);\n                     vec_to[i] = combineHashes(key, vec_to[i], hash);\n+                }\n+            }\n         }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n@@ -1118,10 +1222,16 @@ class FunctionAnyHash : public IFunction\n     }\n \n     template <bool first>\n-    void executeGeneric(const KeyType & key, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n+    void executeGeneric(const KeyColumnsType & key_cols, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n     {\n+        KeyType key{};\n+        if constexpr (Keyed)\n+            key = Impl::getKey(key_cols, 0);\n         for (size_t i = 0, size = column->size(); i < size; ++i)\n         {\n+            if constexpr (Keyed)\n+                if (!key_cols.is_const && i != 0)\n+                    key = Impl::getKey(key_cols, i);\n             StringRef bytes = column->getDataAt(i);\n             const ToType hash = apply(key, bytes.data, bytes.size);\n             if constexpr (first)\n@@ -1132,8 +1242,11 @@ class FunctionAnyHash : public IFunction\n     }\n \n     template <bool first>\n-    void executeString(const KeyType & key, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n+    void executeString(const KeyColumnsType & key_cols, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n     {\n+        KeyType key{};\n+        if constexpr (Keyed)\n+            key = Impl::getKey(key_cols, 0);\n         if (const ColumnString * col_from = checkAndGetColumn<ColumnString>(column))\n         {\n             const typename ColumnString::Chars & data = col_from->getChars();\n@@ -1143,6 +1256,9 @@ class FunctionAnyHash : public IFunction\n             ColumnString::Offset current_offset = 0;\n             for (size_t i = 0; i < size; ++i)\n             {\n+                if constexpr (Keyed)\n+                    if (!key_cols.is_const && i != 0)\n+                        key = Impl::getKey(key_cols, i);\n                 const ToType hash = apply(key,\n                     reinterpret_cast<const char *>(&data[current_offset]),\n                     offsets[i] - current_offset - 1);\n@@ -1163,6 +1279,9 @@ class FunctionAnyHash : public IFunction\n \n             for (size_t i = 0; i < size; ++i)\n             {\n+                if constexpr (Keyed)\n+                    if (!key_cols.is_const && i != 0)\n+                        key = Impl::getKey(key_cols, i);\n                 const ToType hash = apply(key, reinterpret_cast<const char *>(&data[i * n]), n);\n                 if constexpr (first)\n                     vec_to[i] = hash;\n@@ -1172,6 +1291,14 @@ class FunctionAnyHash : public IFunction\n         }\n         else if (const ColumnConst * col_from_const = checkAndGetColumnConstStringOrFixedString(column))\n         {\n+            if constexpr (Keyed)\n+            {\n+                if (!key_cols.is_const)\n+                {\n+                    ColumnPtr full_column = col_from_const->convertToFullColumn();\n+                    return executeString<first>(key_cols, full_column.get(), vec_to);\n+                }\n+            }\n             String value = col_from_const->getValue<String>();\n             const ToType hash = apply(key, value.data(), value.size());\n             const size_t size = vec_to.size();\n@@ -1179,8 +1306,15 @@ class FunctionAnyHash : public IFunction\n             if constexpr (first)\n                 vec_to.assign(size, hash);\n             else\n+            {\n                 for (size_t i = 0; i < size; ++i)\n+                {\n+                    if constexpr (Keyed)\n+                        if (!key_cols.is_const && i != 0)\n+                            key = Impl::getKey(key_cols, i);\n                     vec_to[i] = combineHashes(key, vec_to[i], hash);\n+                }\n+            }\n         }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n@@ -1188,7 +1322,7 @@ class FunctionAnyHash : public IFunction\n     }\n \n     template <bool first>\n-    void executeArray(const KeyType & key, const IDataType * type, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n+    void executeArray(const KeyColumnsType & key_cols, const IDataType * type, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to) const\n     {\n         const IDataType * nested_type = typeid_cast<const DataTypeArray &>(*type).getNestedType().get();\n \n@@ -1200,13 +1334,19 @@ class FunctionAnyHash : public IFunction\n \n             typename ColumnVector<ToType>::Container vec_temp(nested_size);\n             bool nested_is_first = true;\n-            executeForArgument(key, nested_type, nested_column, vec_temp, nested_is_first);\n+            executeForArgument(key_cols, nested_type, nested_column, vec_temp, nested_is_first);\n \n             const size_t size = offsets.size();\n \n             ColumnArray::Offset current_offset = 0;\n+            KeyType key{};\n+            if constexpr (Keyed)\n+                key = Impl::getKey(key_cols, 0);\n             for (size_t i = 0; i < size; ++i)\n             {\n+                if constexpr (Keyed)\n+                    if (!key_cols.is_const && i != 0)\n+                        key = Impl::getKey(key_cols, i);\n                 ColumnArray::Offset next_offset = offsets[i];\n \n                 ToType hash;\n@@ -1230,7 +1370,7 @@ class FunctionAnyHash : public IFunction\n         {\n             /// NOTE: here, of course, you can do without the materialization of the column.\n             ColumnPtr full_column = col_from_const->convertToFullColumn();\n-            executeArray<first>(key, type, full_column.get(), vec_to);\n+            executeArray<first>(key_cols, type, full_column.get(), vec_to);\n         }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function {}\",\n@@ -1238,7 +1378,7 @@ class FunctionAnyHash : public IFunction\n     }\n \n     template <bool first>\n-    void executeAny(const KeyType & key, const IDataType * from_type, const IColumn * icolumn, typename ColumnVector<ToType>::Container & vec_to) const\n+    void executeAny(const KeyColumnsType & key_cols, const IDataType * from_type, const IColumn * icolumn, typename ColumnVector<ToType>::Container & vec_to) const\n     {\n         WhichDataType which(from_type);\n \n@@ -1246,40 +1386,44 @@ class FunctionAnyHash : public IFunction\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"Argument column '{}' size {} doesn't match result column size {} of function {}\",\n                     icolumn->getName(), icolumn->size(), vec_to.size(), getName());\n \n-        if      (which.isUInt8()) executeIntType<UInt8, first>(key, icolumn, vec_to);\n-        else if (which.isUInt16()) executeIntType<UInt16, first>(key, icolumn, vec_to);\n-        else if (which.isUInt32()) executeIntType<UInt32, first>(key, icolumn, vec_to);\n-        else if (which.isUInt64()) executeIntType<UInt64, first>(key, icolumn, vec_to);\n-        else if (which.isUInt128()) executeBigIntType<UInt128, first>(key, icolumn, vec_to);\n-        else if (which.isUInt256()) executeBigIntType<UInt256, first>(key, icolumn, vec_to);\n-        else if (which.isInt8()) executeIntType<Int8, first>(key, icolumn, vec_to);\n-        else if (which.isInt16()) executeIntType<Int16, first>(key, icolumn, vec_to);\n-        else if (which.isInt32()) executeIntType<Int32, first>(key, icolumn, vec_to);\n-        else if (which.isInt64()) executeIntType<Int64, first>(key, icolumn, vec_to);\n-        else if (which.isInt128()) executeBigIntType<Int128, first>(key, icolumn, vec_to);\n-        else if (which.isInt256()) executeBigIntType<Int256, first>(key, icolumn, vec_to);\n-        else if (which.isUUID()) executeBigIntType<UUID, first>(key, icolumn, vec_to);\n-        else if (which.isIPv4()) executeIntType<IPv4, first>(key, icolumn, vec_to);\n-        else if (which.isIPv6()) executeBigIntType<IPv6, first>(key, icolumn, vec_to);\n-        else if (which.isEnum8()) executeIntType<Int8, first>(key, icolumn, vec_to);\n-        else if (which.isEnum16()) executeIntType<Int16, first>(key, icolumn, vec_to);\n-        else if (which.isDate()) executeIntType<UInt16, first>(key, icolumn, vec_to);\n-        else if (which.isDate32()) executeIntType<Int32, first>(key, icolumn, vec_to);\n-        else if (which.isDateTime()) executeIntType<UInt32, first>(key, icolumn, vec_to);\n+        if constexpr (Keyed)\n+            if (key_cols.size() != vec_to.size() && key_cols.size() != 1)\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Key column size {} doesn't match result column size {} of function {}\", key_cols.size(), vec_to.size(), getName());\n+\n+        if      (which.isUInt8()) executeIntType<UInt8, first>(key_cols, icolumn, vec_to);\n+        else if (which.isUInt16()) executeIntType<UInt16, first>(key_cols, icolumn, vec_to);\n+        else if (which.isUInt32()) executeIntType<UInt32, first>(key_cols, icolumn, vec_to);\n+        else if (which.isUInt64()) executeIntType<UInt64, first>(key_cols, icolumn, vec_to);\n+        else if (which.isUInt128()) executeBigIntType<UInt128, first>(key_cols, icolumn, vec_to);\n+        else if (which.isUInt256()) executeBigIntType<UInt256, first>(key_cols, icolumn, vec_to);\n+        else if (which.isInt8()) executeIntType<Int8, first>(key_cols, icolumn, vec_to);\n+        else if (which.isInt16()) executeIntType<Int16, first>(key_cols, icolumn, vec_to);\n+        else if (which.isInt32()) executeIntType<Int32, first>(key_cols, icolumn, vec_to);\n+        else if (which.isInt64()) executeIntType<Int64, first>(key_cols, icolumn, vec_to);\n+        else if (which.isInt128()) executeBigIntType<Int128, first>(key_cols, icolumn, vec_to);\n+        else if (which.isInt256()) executeBigIntType<Int256, first>(key_cols, icolumn, vec_to);\n+        else if (which.isUUID()) executeBigIntType<UUID, first>(key_cols, icolumn, vec_to);\n+        else if (which.isIPv4()) executeIntType<IPv4, first>(key_cols, icolumn, vec_to);\n+        else if (which.isIPv6()) executeBigIntType<IPv6, first>(key_cols, icolumn, vec_to);\n+        else if (which.isEnum8()) executeIntType<Int8, first>(key_cols, icolumn, vec_to);\n+        else if (which.isEnum16()) executeIntType<Int16, first>(key_cols, icolumn, vec_to);\n+        else if (which.isDate()) executeIntType<UInt16, first>(key_cols, icolumn, vec_to);\n+        else if (which.isDate32()) executeIntType<Int32, first>(key_cols, icolumn, vec_to);\n+        else if (which.isDateTime()) executeIntType<UInt32, first>(key_cols, icolumn, vec_to);\n         /// TODO: executeIntType() for Decimal32/64 leads to incompatible result\n-        else if (which.isDecimal32()) executeBigIntType<Decimal32, first>(key, icolumn, vec_to);\n-        else if (which.isDecimal64()) executeBigIntType<Decimal64, first>(key, icolumn, vec_to);\n-        else if (which.isDecimal128()) executeBigIntType<Decimal128, first>(key, icolumn, vec_to);\n-        else if (which.isDecimal256()) executeBigIntType<Decimal256, first>(key, icolumn, vec_to);\n-        else if (which.isFloat32()) executeIntType<Float32, first>(key, icolumn, vec_to);\n-        else if (which.isFloat64()) executeIntType<Float64, first>(key, icolumn, vec_to);\n-        else if (which.isString()) executeString<first>(key, icolumn, vec_to);\n-        else if (which.isFixedString()) executeString<first>(key, icolumn, vec_to);\n-        else if (which.isArray()) executeArray<first>(key, from_type, icolumn, vec_to);\n-        else executeGeneric<first>(key, icolumn, vec_to);\n+        else if (which.isDecimal32()) executeBigIntType<Decimal32, first>(key_cols, icolumn, vec_to);\n+        else if (which.isDecimal64()) executeBigIntType<Decimal64, first>(key_cols, icolumn, vec_to);\n+        else if (which.isDecimal128()) executeBigIntType<Decimal128, first>(key_cols, icolumn, vec_to);\n+        else if (which.isDecimal256()) executeBigIntType<Decimal256, first>(key_cols, icolumn, vec_to);\n+        else if (which.isFloat32()) executeIntType<Float32, first>(key_cols, icolumn, vec_to);\n+        else if (which.isFloat64()) executeIntType<Float64, first>(key_cols, icolumn, vec_to);\n+        else if (which.isString()) executeString<first>(key_cols, icolumn, vec_to);\n+        else if (which.isFixedString()) executeString<first>(key_cols, icolumn, vec_to);\n+        else if (which.isArray()) executeArray<first>(key_cols, from_type, icolumn, vec_to);\n+        else executeGeneric<first>(key_cols, icolumn, vec_to);\n     }\n \n-    void executeForArgument(const KeyType & key, const IDataType * type, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to, bool & is_first) const\n+    void executeForArgument(const KeyColumnsType & key_cols, const IDataType * type, const IColumn * column, typename ColumnVector<ToType>::Container & vec_to, bool & is_first) const\n     {\n         /// Flattening of tuples.\n         if (const ColumnTuple * tuple = typeid_cast<const ColumnTuple *>(column))\n@@ -1288,7 +1432,7 @@ class FunctionAnyHash : public IFunction\n             const DataTypes & tuple_types = typeid_cast<const DataTypeTuple &>(*type).getElements();\n             size_t tuple_size = tuple_columns.size();\n             for (size_t i = 0; i < tuple_size; ++i)\n-                executeForArgument(key, tuple_types[i].get(), tuple_columns[i].get(), vec_to, is_first);\n+                executeForArgument(key_cols, tuple_types[i].get(), tuple_columns[i].get(), vec_to, is_first);\n         }\n         else if (const ColumnTuple * tuple_const = checkAndGetColumnConstData<ColumnTuple>(column))\n         {\n@@ -1298,24 +1442,24 @@ class FunctionAnyHash : public IFunction\n             for (size_t i = 0; i < tuple_size; ++i)\n             {\n                 auto tmp = ColumnConst::create(tuple_columns[i], column->size());\n-                executeForArgument(key, tuple_types[i].get(), tmp.get(), vec_to, is_first);\n+                executeForArgument(key_cols, tuple_types[i].get(), tmp.get(), vec_to, is_first);\n             }\n         }\n         else if (const auto * map = checkAndGetColumn<ColumnMap>(column))\n         {\n             const auto & type_map = assert_cast<const DataTypeMap &>(*type);\n-            executeForArgument(key, type_map.getNestedType().get(), map->getNestedColumnPtr().get(), vec_to, is_first);\n+            executeForArgument(key_cols, type_map.getNestedType().get(), map->getNestedColumnPtr().get(), vec_to, is_first);\n         }\n         else if (const auto * const_map = checkAndGetColumnConst<ColumnMap>(column))\n         {\n-            executeForArgument(key, type, const_map->convertToFullColumnIfConst().get(), vec_to, is_first);\n+            executeForArgument(key_cols, type, const_map->convertToFullColumnIfConst().get(), vec_to, is_first);\n         }\n         else\n         {\n             if (is_first)\n-                executeAny<true>(key, type, column, vec_to);\n+                executeAny<true>(key_cols, type, column, vec_to);\n             else\n-                executeAny<false>(key, type, column, vec_to);\n+                executeAny<false>(key_cols, type, column, vec_to);\n         }\n \n         is_first = false;\n@@ -1346,30 +1490,33 @@ class FunctionAnyHash : public IFunction\n     {\n         auto col_to = ColumnVector<ToType>::create(input_rows_count);\n \n-        typename ColumnVector<ToType>::Container & vec_to = col_to->getData();\n+        if (input_rows_count != 0)\n+        {\n+            typename ColumnVector<ToType>::Container & vec_to = col_to->getData();\n \n-        /// If using a \"keyed\" algorithm, the first argument is the key and\n-        /// the data starts from the second argument.\n-        /// Otherwise there is no key and all arguments are interpreted as data.\n-        constexpr size_t first_data_argument = Keyed;\n+            /// If using a \"keyed\" algorithm, the first argument is the key and\n+            /// the data starts from the second argument.\n+            /// Otherwise there is no key and all arguments are interpreted as data.\n+            constexpr size_t first_data_argument = Keyed;\n \n-        if (arguments.size() <= first_data_argument)\n-        {\n-            /// Return a fixed random-looking magic number when input is empty\n-            vec_to.assign(input_rows_count, static_cast<ToType>(0xe28dbde7fe22e41c));\n-        }\n+            if (arguments.size() <= first_data_argument)\n+            {\n+                /// Return a fixed random-looking magic number when input is empty\n+                vec_to.assign(input_rows_count, static_cast<ToType>(0xe28dbde7fe22e41c));\n+            }\n \n-        KeyType key{};\n-        if constexpr (Keyed)\n-            if (!arguments.empty())\n-                key = Impl::parseKey(arguments[0]);\n+            KeyColumnsType key_cols{};\n+            if constexpr (Keyed)\n+                if (!arguments.empty())\n+                    key_cols = Impl::parseKeyColumns(arguments[0]);\n \n-        /// The function supports arbitrary number of arguments of arbitrary types.\n-        bool is_first_argument = true;\n-        for (size_t i = first_data_argument; i < arguments.size(); ++i)\n-        {\n-            const auto & col = arguments[i];\n-            executeForArgument(key, col.type.get(), col.column.get(), vec_to, is_first_argument);\n+            /// The function supports arbitrary number of arguments of arbitrary types.\n+            bool is_first_argument = true;\n+            for (size_t i = first_data_argument; i < arguments.size(); ++i)\n+            {\n+                const auto & col = arguments[i];\n+                executeForArgument(key_cols, col.type.get(), col.column.get(), vec_to, is_first_argument);\n+            }\n         }\n \n         if constexpr (std::is_same_v<ToType, UInt128>) /// backward-compatible\n@@ -1407,17 +1554,19 @@ class FunctionAnyHash : public IFunction\n \n ) // DECLARE_MULTITARGET_CODE\n \n-template <typename Impl, bool Keyed = false, typename KeyType = char>\n-class FunctionAnyHash : public TargetSpecific::Default::FunctionAnyHash<Impl, Keyed, KeyType>\n+template <typename Impl, bool Keyed = false, typename KeyType = char, typename KeyColumnsType = char>\n+class FunctionAnyHash : public TargetSpecific::Default::FunctionAnyHash<Impl, Keyed, KeyType, KeyColumnsType>\n {\n public:\n     explicit FunctionAnyHash(ContextPtr context) : selector(context)\n     {\n-        selector.registerImplementation<TargetArch::Default, TargetSpecific::Default::FunctionAnyHash<Impl, Keyed, KeyType>>();\n+        selector\n+            .registerImplementation<TargetArch::Default, TargetSpecific::Default::FunctionAnyHash<Impl, Keyed, KeyType, KeyColumnsType>>();\n \n #if USE_MULTITARGET_CODE\n-        selector.registerImplementation<TargetArch::AVX2, TargetSpecific::AVX2::FunctionAnyHash<Impl, Keyed, KeyType>>();\n-        selector.registerImplementation<TargetArch::AVX512F, TargetSpecific::AVX512F::FunctionAnyHash<Impl, Keyed, KeyType>>();\n+        selector.registerImplementation<TargetArch::AVX2, TargetSpecific::AVX2::FunctionAnyHash<Impl, Keyed, KeyType, KeyColumnsType>>();\n+        selector\n+            .registerImplementation<TargetArch::AVX512F, TargetSpecific::AVX512F::FunctionAnyHash<Impl, Keyed, KeyType, KeyColumnsType>>();\n #endif\n     }\n \n@@ -1640,7 +1789,7 @@ struct NameIntHash32 { static constexpr auto name = \"intHash32\"; };\n struct NameIntHash64 { static constexpr auto name = \"intHash64\"; };\n \n using FunctionSipHash64 = FunctionAnyHash<SipHash64Impl>;\n-using FunctionSipHash64Keyed = FunctionAnyHash<SipHash64KeyedImpl, true, SipHash64KeyedImpl::Key>;\n+using FunctionSipHash64Keyed = FunctionAnyHash<SipHash64KeyedImpl, true, SipHash64KeyedImpl::Key, SipHash64KeyedImpl::KeyColumns>;\n using FunctionIntHash32 = FunctionIntHash<IntHash32Impl, NameIntHash32>;\n using FunctionIntHash64 = FunctionIntHash<IntHash64Impl, NameIntHash64>;\n #if USE_SSL\n@@ -1654,8 +1803,10 @@ using FunctionSHA384 = FunctionStringHashFixedString<SHA384Impl>;\n using FunctionSHA512 = FunctionStringHashFixedString<SHA512Impl>;\n #endif\n using FunctionSipHash128 = FunctionAnyHash<SipHash128Impl>;\n-using FunctionSipHash128Keyed = FunctionAnyHash<SipHash128KeyedImpl, true, SipHash128KeyedImpl::Key>;\n+using FunctionSipHash128Keyed = FunctionAnyHash<SipHash128KeyedImpl, true, SipHash128KeyedImpl::Key, SipHash128KeyedImpl::KeyColumns>;\n using FunctionSipHash128Reference = FunctionAnyHash<SipHash128ReferenceImpl>;\n+using FunctionSipHash128ReferenceKeyed\n+    = FunctionAnyHash<SipHash128ReferenceKeyedImpl, true, SipHash128ReferenceKeyedImpl::Key, SipHash128ReferenceKeyedImpl::KeyColumns>;\n using FunctionCityHash64 = FunctionAnyHash<ImplCityHash64>;\n using FunctionFarmFingerprint64 = FunctionAnyHash<ImplFarmFingerprint64>;\n using FunctionFarmHash64 = FunctionAnyHash<ImplFarmHash64>;\ndiff --git a/src/Functions/FunctionsHashingMisc.cpp b/src/Functions/FunctionsHashingMisc.cpp\nindex 56c3c1ed00c4..f56568b25083 100644\n--- a/src/Functions/FunctionsHashingMisc.cpp\n+++ b/src/Functions/FunctionsHashingMisc.cpp\n@@ -20,6 +20,11 @@ REGISTER_FUNCTION(Hashing)\n         .examples{{\"hash\", \"SELECT hex(sipHash128Reference('foo', '\\\\x01', 3))\", \"\"}},\n         .categories{\"Hash\"}\n     });\n+    factory.registerFunction<FunctionSipHash128ReferenceKeyed>(FunctionDocumentation{\n+        .description = \"Same as [sipHash128Reference](#hash_functions-siphash128reference) but additionally takes an explicit key argument \"\n+                       \"instead of using a fixed key.\",\n+        .examples{{\"hash\", \"SELECT hex(sipHash128ReferenceKeyed((506097522914230528, 1084818905618843912),'foo', '\\\\x01', 3));\", \"\"}},\n+        .categories{\"Hash\"}});\n     factory.registerFunction<FunctionCityHash64>();\n     factory.registerFunction<FunctionFarmFingerprint64>();\n     factory.registerFunction<FunctionFarmHash64>();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02534_keyed_siphash.reference b/tests/queries/0_stateless/02534_keyed_siphash.reference\nindex 33838d5298c7..e3fae07333a2 100644\n--- a/tests/queries/0_stateless/02534_keyed_siphash.reference\n+++ b/tests/queries/0_stateless/02534_keyed_siphash.reference\n@@ -197,3 +197,42 @@ E28DBDE7FE22E41C\n Check bug with hashing of const integer values\n 11862823756610506724\n 11862823756610506724\n+86AE90BB6A238D3F6221457630142C9B\n+86AE90BB6A238D3F6221457630142C9B\n+Check memsan bug\n+18096612095653370192\n+20AF99D3A87829E0\n+12489502208762728797\n+Check const columns\n+15080046610211022027\n+15080046610211022027\n+15080046610211022027\n+15080046610211022027\n+2E779C73D13981AA1AE19AFF9617EA49\n+2E779C73D13981AA1AE19AFF9617EA49\n+2E779C73D13981AA1AE19AFF9617EA49\n+2E779C73D13981AA1AE19AFF9617EA49\n+Check multiple keys as tuple from a table\n+11862823756610506724\n+9357996107237883963\n+86AE90BB6A238D3F6221457630142C9B\n+F6D93D8FEA6D7DECCDD95A7A0A2AA36D\n+Check multiple keys as separate ints from a table\n+11862823756610506724\n+9357996107237883963\n+86AE90BB6A238D3F6221457630142C9B\n+F6D93D8FEA6D7DECCDD95A7A0A2AA36D\n+Check constant key and data from a table\n+11862823756610506724\n+11862823756610506724\n+86AE90BB6A238D3F6221457630142C9B\n+86AE90BB6A238D3F6221457630142C9B\n+Check multiple keys as separate ints from a table with constant data\n+11862823756610506724\n+9357996107237883963\n+86AE90BB6A238D3F6221457630142C9B\n+F6D93D8FEA6D7DECCDD95A7A0A2AA36D\n+Check asan bug\n+0\n+Check bug found fuzzing\n+9042C6691B1A75F0EA3314B6F55728BB\ndiff --git a/tests/queries/0_stateless/02534_keyed_siphash.sql b/tests/queries/0_stateless/02534_keyed_siphash.sql\nindex 80180cc568f9..112ae15bf469 100644\n--- a/tests/queries/0_stateless/02534_keyed_siphash.sql\n+++ b/tests/queries/0_stateless/02534_keyed_siphash.sql\n@@ -263,10 +263,10 @@ select sipHash128Keyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8,\n select sipHash128Keyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62)) == sipHash128(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62));\n select sipHash128Keyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63)) == sipHash128(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63));\n \n-select sipHash64Keyed((0, 0), '1'); -- { serverError 48 }\n-select sipHash128Keyed((0, 0), '1'); -- { serverError 48 }\n-select sipHash64Keyed(toUInt64(0), '1'); -- { serverError 48 }\n-select sipHash128Keyed(toUInt64(0), '1'); -- { serverError 48 }\n+select sipHash64Keyed((0, 0), '1'); -- { serverError NOT_IMPLEMENTED }\n+select sipHash128Keyed((0, 0), '1'); -- { serverError NOT_IMPLEMENTED }\n+select sipHash64Keyed(toUInt64(0), '1'); -- { serverError NOT_IMPLEMENTED }\n+select sipHash128Keyed(toUInt64(0), '1'); -- { serverError NOT_IMPLEMENTED }\n \n select hex(sipHash64());\n SELECT hex(sipHash128());\n@@ -280,4 +280,61 @@ INSERT INTO tab VALUES ((2, 2), 4);\n -- these two statements must produce the same result\n SELECT sipHash64Keyed(key, val) FROM tab;\n SELECT sipHash64Keyed(key, 4::UInt64) FROM tab;\n+SELECT hex(sipHash128Keyed(key, val)) FROM tab;\n+SELECT hex(sipHash128Keyed(key, 4::UInt64)) FROM tab;\n DROP TABLE tab;\n+\n+SELECT 'Check memsan bug';\n+SELECT sipHash64Keyed((2::UInt64, toUInt64(2)), 4) GROUP BY toUInt64(2);\n+SELECT hex(sipHash64Keyed((toUInt64(9223372036854775806), toUInt64(-9223372036854775808)), char(2147483646, -2147483648, 1, 3, 4, 7, 2147483647))) GROUP BY toUInt64(257), (toUInt64(9223372036854775806), toUInt64(2147483646));\n+SELECT sipHash64Keyed((toUInt64(9223372036854775806), 9223372036854775808::UInt64), char(2)) GROUP BY toUInt64(9223372036854775806);\n+\n+SELECT 'Check const columns';\n+DROP TABLE IF EXISTS sipHashKeyed_test;\n+CREATE TABLE sipHashKeyed_test ENGINE = Memory() AS SELECT 1 a, 'test' b;\n+SELECT sipHash64Keyed((toUInt64(0), toUInt64(0)), 1, 'test');\n+SELECT sipHash64(tuple(*)) FROM sipHashKeyed_test;\n+SELECT sipHash64Keyed((toUInt64(0), toUInt64(0)), tuple(*)) FROM sipHashKeyed_test;\n+SELECT sipHash64Keyed((toUInt64(0), toUInt64(0)), a, b) FROM sipHashKeyed_test;\n+SELECT hex(sipHash128Keyed((toUInt64(0), toUInt64(0)), 1, 'test'));\n+SELECT hex(sipHash128(tuple(*))) FROM sipHashKeyed_test;\n+SELECT hex(sipHash128Keyed((toUInt64(0), toUInt64(0)), tuple(*))) FROM sipHashKeyed_test;\n+SELECT hex(sipHash128Keyed((toUInt64(0), toUInt64(0)), a, b)) FROM sipHashKeyed_test;\n+DROP TABLE sipHashKeyed_test;\n+\n+SELECT 'Check multiple keys as tuple from a table';\n+DROP TABLE IF EXISTS sipHashKeyed_keys;\n+CREATE TABLE sipHashKeyed_keys (key Tuple(UInt64, UInt64), val UInt64) ENGINE=Memory;\n+INSERT INTO sipHashKeyed_keys VALUES ((2, 2), 4);\n+INSERT INTO sipHashKeyed_keys VALUES ((4, 4), 4);\n+SELECT sipHash64Keyed(key, val) FROM sipHashKeyed_keys ORDER by key;\n+SELECT hex(sipHash128Keyed(key, val)) FROM sipHashKeyed_keys ORDER by key;\n+DROP TABLE sipHashKeyed_keys;\n+\n+SELECT 'Check multiple keys as separate ints from a table';\n+DROP TABLE IF EXISTS sipHashKeyed_keys;\n+CREATE TABLE sipHashKeyed_keys (key0 UInt64, key1 UInt64, val UInt64) ENGINE=Memory;\n+INSERT INTO sipHashKeyed_keys VALUES (2, 2, 4);\n+INSERT INTO sipHashKeyed_keys VALUES (4, 4, 4);\n+SELECT sipHash64Keyed((key0, key1), val) FROM sipHashKeyed_keys ORDER by key0;\n+SELECT hex(sipHash128Keyed((key0, key1), val)) FROM sipHashKeyed_keys ORDER by key0;\n+SELECT 'Check constant key and data from a table';\n+SELECT sipHash64Keyed((2::UInt64, 2::UInt64), val) FROM sipHashKeyed_keys ORDER by val;\n+SELECT hex(sipHash128Keyed((2::UInt64, 2::UInt64), val)) FROM sipHashKeyed_keys ORDER by val;\n+DROP TABLE sipHashKeyed_keys;\n+\n+SELECT 'Check multiple keys as separate ints from a table with constant data';\n+DROP TABLE IF EXISTS sipHashKeyed_keys;\n+CREATE TABLE sipHashKeyed_keys (key0 UInt64, key1 UInt64) ENGINE=Memory;\n+INSERT INTO sipHashKeyed_keys VALUES (2, 2);\n+INSERT INTO sipHashKeyed_keys VALUES (4, 4);\n+SELECT sipHash64Keyed((key0, key1), 4::UInt64) FROM sipHashKeyed_keys ORDER by key0;\n+SELECT hex(sipHash128Keyed((key0, key1), 4::UInt64)) FROM sipHashKeyed_keys ORDER by key0;\n+DROP TABLE sipHashKeyed_keys;\n+\n+SELECT 'Check asan bug';\n+SELECT sipHash128((toUInt64(9223372036854775806), 1)) = sipHash128(1) GROUP BY sipHash128(1::UInt8), toUInt64(9223372036854775806);\n+\n+SELECT 'Check bug found fuzzing';\n+SELECT [(255, 1048575)], sipHash128ReferenceKeyed((toUInt64(2147483646), toUInt64(9223372036854775807)), ([(NULL, 100), (NULL, NULL), (1024, 10)], toUInt64(2), toUInt64(1024)), ''), hex(sipHash128ReferenceKeyed((-9223372036854775807, 1.), '-1', NULL)), ('', toUInt64(65535), [(9223372036854775807, 9223372036854775806)], toUInt64(65536)), arrayJoin((NULL, 65537, 255), [(NULL, NULL)]) GROUP BY tupleElement((NULL, NULL, NULL, -1), toUInt64(2), 2) = NULL;  -- { serverError NOT_IMPLEMENTED }\n+SELECT hex(sipHash128ReferenceKeyed((0::UInt64, 0::UInt64), ([1, 1])));\ndiff --git a/tests/queries/0_stateless/02552_siphash128_reference.reference b/tests/queries/0_stateless/02552_siphash128_reference.reference\nindex 6aa6c7ae0757..ece9f6a4615e 100644\n--- a/tests/queries/0_stateless/02552_siphash128_reference.reference\n+++ b/tests/queries/0_stateless/02552_siphash128_reference.reference\n@@ -1,1 +1,152 @@\n+A3817F04BA25A8E66DF67214C7550293\n+DA87C1D86B99AF44347659119B22FC45\n+8177228DA4A45DC7FCA38BDEF60AFFE4\n+9C70B60C5267A94E5F33B6B02985ED51\n+F88164C12D9C8FAF7D0F6E7C7BCD5579\n+1368875980776F8854527A07690E9627\n+14EECA338B208613485EA0308FD7A15E\n+A1F1EBBED8DBC153C0B84AA61FF08239\n+3B62A9BA6258F5610F83E264F31497B4\n+264499060AD9BAABC47F8B02BB6D71ED\n+00110DC378146956C95447D3F3D0FBBA\n+0151C568386B6677A2B4DC6F81E5DC18\n+D626B266905EF35882634DF68532C125\n+9869E247E9C08B10D029934FC4B952F7\n+31FCEFAC66D7DE9C7EC7485FE4494902\n+5493E99933B0A8117E08EC0F97CFC3D9\n+6EE2A4CA67B054BBFD3315BF85230577\n+473D06E8738DB89854C066C47AE47740\n+A426E5E423BF4885294DA481FEAEF723\n+78017731CF65FAB074D5208952512EB1\n+9E25FC833F2290733E9344A5E83839EB\n+568E495ABE525A218A2214CD3E071D12\n+4A29B54552D16B9A469C10528EFF0AAE\n+C9D184DDD5A9F5E0CF8CE29A9ABF691C\n+2DB479AE78BD50D8882A8A178A6132AD\n+8ECE5F042D5E447B5051B9EACB8D8F6F\n+9C0B53B4B3C307E87EAEE08678141F66\n+ABF248AF69A6EAE4BFD3EB2F129EEB94\n+0664DA1668574B88B935F3027358AEF4\n+AA4B9DC4BF337DE90CD4FD3C467C6AB7\n+EA5C7F471FAF6BDE2B1AD7D4686D2287\n+2939B0183223FAFC1723DE4F52C43D35\n+7C3956CA5EEAFC3E363E9D556546EB68\n+77C6077146F01C32B6B69D5F4EA9FFCF\n+37A6986CB8847EDF0925F0F1309B54DE\n+A705F0E69DA9A8F907241A2E923C8CC8\n+3DC47D1F29C448461E9E76ED904F6711\n+0D62BF01E6FC0E1A0D3C4751C5D3692B\n+8C03468BCA7C669EE4FD5E084BBEE7B5\n+528A5BB93BAF2C9C4473CCE5D0D22BD9\n+DF6A301E95C95DAD97AE0CC8C6913BD8\n+801189902C857F39E73591285E70B6DB\n+E617346AC9C231BB3650AE34CCCA0C5B\n+27D93437EFB721AA401821DCEC5ADF89\n+89237D9DED9C5E78D8B1C9B166CC7342\n+4A6D8091BF5E7D651189FA94A250B14C\n+0E33F96055E7AE893FFC0E3DCF492902\n+E61C432B720B19D18EC8D84BDC63151B\n+F7E5AEF549F782CF379055A608269B16\n+438D030FD0B7A54FA837F2AD201A6403\n+A590D3EE4FBF04E3247E0D27F286423F\n+5FE2C1A172FE93C4B15CD37CAEF9F538\n+2C97325CBD06B36EB2133DD08B3A017C\n+92C814227A6BCA949FF0659F002AD39E\n+DCE850110BD8328CFBD50841D6911D87\n+67F14984C7DA791248E32BB5922583DA\n+1938F2CF72D54EE97E94166FA91D2A36\n+74481E9646ED49FE0F6224301604698E\n+57FCA5DE98A9D6D8006438D0583D8A1D\n+9FECDE1CEFDC1CBED4763674D9575359\n+E3040C00EB28F15366CA73CBD872E740\n+7697009A6A831DFECCA91C5993670F7A\n+5853542321F567A005D547A4F04759BD\n+5150D1772F50834A503E069A973FBD7C\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+Check bug with hashing of const integer values\n+E940B12600C844966162FF8FE7A16AAE\n+E940B12600C844966162FF8FE7A16AAE\n+Check memsan bug\n 1CE422FEE7BD8DE20000000000000000\n+Check const columns\n+B66B53476BDBEB8549A257E3B1766C30\n+B66B53476BDBEB8549A257E3B1766C30\n+B66B53476BDBEB8549A257E3B1766C30\n+B66B53476BDBEB8549A257E3B1766C30\n+Check multiple keys as tuple from a table\n+E940B12600C844966162FF8FE7A16AAE\n+EC58946A98A0D37F4E3FAC02FBBA9480\n+Check multiple keys as separate ints from a table\n+E940B12600C844966162FF8FE7A16AAE\n+EC58946A98A0D37F4E3FAC02FBBA9480\n+Check constant key and data from a table\n+E940B12600C844966162FF8FE7A16AAE\n+E940B12600C844966162FF8FE7A16AAE\n+Check multiple keys as separate ints from a table with constant data\n+E940B12600C844966162FF8FE7A16AAE\n+EC58946A98A0D37F4E3FAC02FBBA9480\ndiff --git a/tests/queries/0_stateless/02552_siphash128_reference.sql b/tests/queries/0_stateless/02552_siphash128_reference.sql\nindex f3cfa6093dc9..f7324ed0ee48 100644\n--- a/tests/queries/0_stateless/02552_siphash128_reference.sql\n+++ b/tests/queries/0_stateless/02552_siphash128_reference.sql\n@@ -1,1 +1,254 @@\n-SELECT hex(sipHash128Reference());\n+-- Test Vectors from the SipHash reference C implementation:\n+-- Written by\n+-- Jean-Philippe Aumasson <jeanphilippe.aumasson@gmail.com>\n+-- Daniel J. Bernstein <djb@cr.yp.to>\n+-- Released under CC0\n+-- https://github.com/veorq/SipHash/blob/eee7d0d84dc7731df2359b243aa5e75d85f6eaef/vectors.h#L645\n+\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           ''));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61)));\n+select hex(sipHash128ReferenceKeyed((toUInt64(506097522914230528), toUInt64(1084818905618843912)),\n+                           char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62)));\n+\n+-- CH tests\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0)) == sipHash128Reference(char(0));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1)) == sipHash128Reference(char(0, 1));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2)) == sipHash128Reference(char(0, 1, 2));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3)) == sipHash128Reference(char(0, 1, 2, 3));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4)) == sipHash128Reference(char(0, 1, 2, 3, 4));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62));\n+select sipHash128ReferenceKeyed((toUInt64(0),toUInt64(0)),char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63)) == sipHash128Reference(char(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63));\n+\n+select sipHash128ReferenceKeyed((0, 0), '1'); -- { serverError NOT_IMPLEMENTED }\n+select sipHash128ReferenceKeyed(toUInt64(0), '1'); -- { serverError NOT_IMPLEMENTED }\n+\n+SELECT hex(sipHash128Reference()) = hex(reverse(unhex('1CE422FEE7BD8DE20000000000000000'))) or hex(sipHash128()) = '1CE422FEE7BD8DE20000000000000000';\n+SELECT hex(sipHash128ReferenceKeyed()) = hex(reverse(unhex('1CE422FEE7BD8DE20000000000000000'))) or hex(sipHash128Keyed()) = '1CE422FEE7BD8DE20000000000000000';\n+\n+SELECT 'Check bug with hashing of const integer values';\n+DROP TABLE IF EXISTS tab;\n+CREATE TABLE tab (key Tuple(UInt64, UInt64), val UInt64) ENGINE=Memory;\n+INSERT INTO tab VALUES ((2, 2), 4);\n+-- these two statements must produce the same result\n+SELECT hex(sipHash128ReferenceKeyed(key, val)) FROM tab;\n+SELECT hex(sipHash128ReferenceKeyed(key, 4::UInt64)) FROM tab;\n+DROP TABLE tab;\n+\n+SELECT 'Check memsan bug';\n+SELECT hex(sipHash128ReferenceKeyed((toUInt64(2), toUInt64(-9223372036854775807)))) GROUP BY (toUInt64(506097522914230528), toUInt64(now64(2, NULL + NULL), 1084818905618843912)), toUInt64(2), NULL + NULL, char(-2147483649, 1);\n+\n+SELECT 'Check const columns';\n+DROP TABLE IF EXISTS sipHashKeyed_test;\n+CREATE TABLE sipHashKeyed_test ENGINE = Memory() AS SELECT 1 a, 'test' b;\n+SELECT hex(sipHash128ReferenceKeyed((toUInt64(0), toUInt64(0)), 1, 'test'));\n+SELECT hex(sipHash128Reference(tuple(*))) FROM sipHashKeyed_test;\n+SELECT hex(sipHash128ReferenceKeyed((toUInt64(0), toUInt64(0)), tuple(*))) FROM sipHashKeyed_test;\n+SELECT hex(sipHash128ReferenceKeyed((toUInt64(0), toUInt64(0)), a, b)) FROM sipHashKeyed_test;\n+DROP TABLE sipHashKeyed_test;\n+\n+SELECT 'Check multiple keys as tuple from a table';\n+DROP TABLE IF EXISTS sipHashKeyed_keys;\n+CREATE TABLE sipHashKeyed_keys (key Tuple(UInt64, UInt64), val UInt64) ENGINE=Memory;\n+INSERT INTO sipHashKeyed_keys VALUES ((2, 2), 4);\n+INSERT INTO sipHashKeyed_keys VALUES ((4, 4), 4);\n+SELECT hex(sipHash128ReferenceKeyed(key, val)) FROM sipHashKeyed_keys ORDER by key;\n+DROP TABLE sipHashKeyed_keys;\n+\n+SELECT 'Check multiple keys as separate ints from a table';\n+DROP TABLE IF EXISTS sipHashKeyed_keys;\n+CREATE TABLE sipHashKeyed_keys (key0 UInt64, key1 UInt64, val UInt64) ENGINE=Memory;\n+INSERT INTO sipHashKeyed_keys VALUES (2, 2, 4);\n+INSERT INTO sipHashKeyed_keys VALUES (4, 4, 4);\n+SELECT hex(sipHash128ReferenceKeyed((key0, key1), val)) FROM sipHashKeyed_keys ORDER by key0;\n+SELECT 'Check constant key and data from a table';\n+SELECT hex(sipHash128ReferenceKeyed((2::UInt64, 2::UInt64), val)) FROM sipHashKeyed_keys ORDER by val;\n+DROP TABLE sipHashKeyed_keys;\n+\n+SELECT 'Check multiple keys as separate ints from a table with constant data';\n+DROP TABLE IF EXISTS sipHashKeyed_keys;\n+CREATE TABLE sipHashKeyed_keys (key0 UInt64, key1 UInt64) ENGINE=Memory;\n+INSERT INTO sipHashKeyed_keys VALUES (2, 2);\n+INSERT INTO sipHashKeyed_keys VALUES (4, 4);\n+SELECT hex(sipHash128ReferenceKeyed((key0, key1), 4::UInt64)) FROM sipHashKeyed_keys ORDER by key0;\n+DROP TABLE sipHashKeyed_keys;\n",
  "problem_statement": "sipHash64Keyed not same sipHash64\nTesting queries (query 6 return Error):\r\n\r\n//------------------------- \u0417\u0430\u043f\u0440\u043e\u0441 1 -------------------------\r\nDROP TABLE IF EXISTS sipHash64Keyed_test\r\n;\r\n//------------------------- \u0417\u0430\u043f\u0440\u043e\u0441 2 -------------------------\r\nCREATE TABLE sipHash64Keyed_test\r\nENGINE = Memory() \r\nAS\r\nSELECT\r\n   1 a,\r\n   'test' b\r\n;\r\n//------------------------- \u0417\u0430\u043f\u0440\u043e\u0441 3 -------------------------\r\nSELECT\r\n  *\r\nFROM  \r\n  sipHash64Keyed_test\r\nFORMAT TSVWithNamesAndTypes\r\n;\r\n//------------------------- \u0417\u0430\u043f\u0440\u043e\u0441 4 -------------------------\r\nSELECT\r\n  sipHash64Keyed((toUInt64(0), toUInt64(0)), 1, 'test')\r\nFORMAT TSVWithNamesAndTypes\r\n;\r\n//------------------------- \u0417\u0430\u043f\u0440\u043e\u0441 5 -------------------------\r\nSELECT\r\n  sipHash64(tuple(*))\r\nFROM  \r\n  sipHash64Keyed_test\r\nFORMAT TSVWithNamesAndTypes\r\n;\r\n//------------------------- \u0417\u0430\u043f\u0440\u043e\u0441 6 -------------------------\r\nSELECT\r\n  sipHash64Keyed((toUInt64(0), toUInt64(0)), tuple(*))\r\nFROM  \r\n  sipHash64Keyed_test\r\nFORMAT TSVWithNamesAndTypes\r\n![Error](https://github.com/ClickHouse/ClickHouse/assets/58112035/d554982d-db51-4e52-92ff-2f784557fb8c)\r\n\n",
  "hints_text": "example https://fiddle.clickhouse.com/ba0f30dc-151f-49dd-9f23-0a4a001168ef\n@aiven-sal \nCuriously enough, the key argument will be a \"const\" column or not depending on the values of other arguments. This behaviour seems a bit odd to me, but it's trivial to make it work. Fix is on the way. ",
  "created_at": "2023-08-17T13:23:41Z"
}