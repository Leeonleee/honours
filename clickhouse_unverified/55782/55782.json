{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55782,
  "instance_id": "ClickHouse__ClickHouse-55782",
  "issue_numbers": [
    "50277"
  ],
  "base_commit": "c391527c863462f6499f076cbeee887046694e3e",
  "patch": "diff --git a/docs/en/operations/named-collections.md b/docs/en/operations/named-collections.md\nindex 6ed72152c1e7..06c05929ffaa 100644\n--- a/docs/en/operations/named-collections.md\n+++ b/docs/en/operations/named-collections.md\n@@ -18,7 +18,15 @@ function, table engine, database, etc. In the examples below the parameter list\n linked to for each type.\n \n Parameters set in a named collection can be overridden in SQL, this is shown in the examples\n-below.\n+below. This ability can be limited using `[NOT] OVERRIDABLE` keywords and XML attributes\n+and/or the configuration option `allow_named_collection_override_by_default`.\n+\n+:::warning\n+If override is allowed, it may be possible for users without administrative access to\n+figure out the credentials that you are trying to hide.\n+If you are using named collections with that purpose, you should disable\n+`allow_named_collection_override_by_default` (which is enabled by default).\n+:::\n \n ## Storing named collections in the system database\n \n@@ -26,11 +34,17 @@ below.\n \n ```sql\n CREATE NAMED COLLECTION name AS\n-key_1 = 'value',\n-key_2 = 'value2',\n+key_1 = 'value' OVERRIDABLE,\n+key_2 = 'value2' NOT OVERRIDABLE,\n url = 'https://connection.url/'\n ```\n \n+In the above example:\n+\n+ * `key_1` can always be overridden.\n+ * `key_2` can never be overridden.\n+ * `url` can be overridden or not depending on the value of `allow_named_collection_override_by_default`.\n+\n ### Permissions to create named collections with DDL\n \n To manage named collections with DDL a user must have the `named_control_collection` privilege.  This can be assigned by adding a file to `/etc/clickhouse-server/users.d/`.  The example gives the user `default` both the `access_management` and `named_collection_control` privileges:\n@@ -61,25 +75,37 @@ In the above example the `password_sha256_hex` value is the hexadecimal represen\n <clickhouse>\n      <named_collections>\n         <name>\n-            <key_1>value</key_1>\n-            <key_2>value_2</key_2>\n+            <key_1 overridable=\"true\">value</key_1>\n+            <key_2 overridable=\"false\">value_2</key_2>\n             <url>https://connection.url/</url>\n         </name>\n      </named_collections>\n </clickhouse>\n ```\n \n+In the above example:\n+\n+ * `key_1` can always be overridden.\n+ * `key_2` can never be overridden.\n+ * `url` can be overridden or not depending on the value of `allow_named_collection_override_by_default`.\n+\n ## Modifying named collections\n \n Named collections that are created with DDL queries can be altered or dropped with DDL. Named collections created with XML files can be managed by editing or deleting the corresponding XML.\n \n ### Alter a DDL named collection\n \n-Change or add the keys `key1` and `key3` of the collection `collection2`:\n+Change or add the keys `key1` and `key3` of the collection `collection2`\n+(this will not change the value of the `overridable` flag for those keys):\n ```sql\n ALTER NAMED COLLECTION collection2 SET key1=4, key3='value3'\n ```\n \n+Change or add the key `key1` and allow it to be always overridden:\n+```sql\n+ALTER NAMED COLLECTION collection2 SET key1=4 OVERRIDABLE\n+```\n+\n Remove the key `key2` from `collection2`:\n ```sql\n ALTER NAMED COLLECTION collection2 DELETE key2\n@@ -90,6 +116,13 @@ Change or add the key `key1` and delete the key `key3` of the collection `collec\n ALTER NAMED COLLECTION collection2 SET key1=4, DELETE key3\n ```\n \n+To force a key to use the default settings for the `overridable` flag, you have to\n+remove and re-add the key.\n+```sql\n+ALTER NAMED COLLECTION collection2 DELETE key1;\n+ALTER NAMED COLLECTION collection2 SET key1=4;\n+```\n+\n ### Drop the DDL named collection `collection2`:\n ```sql\n DROP NAMED COLLECTION collection2\ndiff --git a/docs/en/sql-reference/statements/alter/named-collection.md b/docs/en/sql-reference/statements/alter/named-collection.md\nindex ac6752127c19..71d4bfadd9cd 100644\n--- a/docs/en/sql-reference/statements/alter/named-collection.md\n+++ b/docs/en/sql-reference/statements/alter/named-collection.md\n@@ -12,9 +12,9 @@ This query intends to modify already existing named collections.\n ```sql\n ALTER NAMED COLLECTION [IF EXISTS] name [ON CLUSTER cluster]\n [ SET\n-key_name1 = 'some value',\n-key_name2 = 'some value',\n-key_name3 = 'some value',\n+key_name1 = 'some value' [[NOT] OVERRIDABLE],\n+key_name2 = 'some value' [[NOT] OVERRIDABLE],\n+key_name3 = 'some value' [[NOT] OVERRIDABLE],\n ... ] |\n [ DELETE key_name4, key_name5, ... ]\n ```\n@@ -22,9 +22,9 @@ key_name3 = 'some value',\n **Example**\n \n ```sql\n-CREATE NAMED COLLECTION foobar AS a = '1', b = '2';\n+CREATE NAMED COLLECTION foobar AS a = '1' NOT OVERRIDABLE, b = '2';\n \n-ALTER NAMED COLLECTION foobar SET a = '2', c = '3';\n+ALTER NAMED COLLECTION foobar SET a = '2' OVERRIDABLE, c = '3';\n \n ALTER NAMED COLLECTION foobar DELETE b;\n ```\ndiff --git a/docs/en/sql-reference/statements/create/named-collection.md b/docs/en/sql-reference/statements/create/named-collection.md\nindex 1fc7b11c5543..f69fa2e3678b 100644\n--- a/docs/en/sql-reference/statements/create/named-collection.md\n+++ b/docs/en/sql-reference/statements/create/named-collection.md\n@@ -11,16 +11,16 @@ Creates a new named collection.\n \n ```sql\n CREATE NAMED COLLECTION [IF NOT EXISTS] name [ON CLUSTER cluster] AS\n-key_name1 = 'some value',\n-key_name2 = 'some value',\n-key_name3 = 'some value',\n+key_name1 = 'some value' [[NOT] OVERRIDABLE],\n+key_name2 = 'some value' [[NOT] OVERRIDABLE],\n+key_name3 = 'some value' [[NOT] OVERRIDABLE],\n ...\n ```\n \n **Example**\n \n ```sql\n-CREATE NAMED COLLECTION foobar AS a = '1', b = '2';\n+CREATE NAMED COLLECTION foobar AS a = '1', b = '2' OVERRIDABLE;\n ```\n \n **Related statements**\ndiff --git a/src/Common/NamedCollections/NamedCollectionConfiguration.cpp b/src/Common/NamedCollections/NamedCollectionConfiguration.cpp\nindex d9bf2349a5a1..2bb0dcd9b695 100644\n--- a/src/Common/NamedCollections/NamedCollectionConfiguration.cpp\n+++ b/src/Common/NamedCollections/NamedCollectionConfiguration.cpp\n@@ -18,6 +18,8 @@ namespace ErrorCodes\n namespace NamedCollectionConfiguration\n {\n \n+void setOverridable(Poco::Util::AbstractConfiguration & config, const std::string & path, bool value);\n+\n bool hasConfigValue(\n     const Poco::Util::AbstractConfiguration & config,\n     const std::string & path)\n@@ -72,11 +74,13 @@ template <typename T> T getConfigValueOrDefault(\n     }\n }\n \n-template<typename T> void setConfigValue(\n+template <typename T>\n+void setConfigValue(\n     Poco::Util::AbstractConfiguration & config,\n     const std::string & path,\n     const T & value,\n-    bool update)\n+    bool update,\n+    const std::optional<bool> is_overridable)\n {\n     if (!update && config.has(path))\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Key `{}` already exists\", path);\n@@ -96,6 +100,8 @@ template<typename T> void setConfigValue(\n             ErrorCodes::NOT_IMPLEMENTED,\n             \"Unsupported type in setConfigValue(). \"\n             \"Supported types are String, UInt64, Int64, Float64, bool\");\n+    if (is_overridable)\n+        setOverridable(config, path, *is_overridable);\n }\n \n template <typename T> void copyConfigValue(\n@@ -123,6 +129,9 @@ template <typename T> void copyConfigValue(\n             ErrorCodes::NOT_IMPLEMENTED,\n             \"Unsupported type in copyConfigValue(). \"\n             \"Supported types are String, UInt64, Int64, Float64\");\n+    const auto overridable = isOverridable(from_config, from_path);\n+    if (overridable)\n+        setOverridable(to_config, to_path, *overridable);\n }\n \n void removeConfigValue(\n@@ -147,13 +156,19 @@ ConfigurationPtr createEmptyConfiguration(const std::string & root_name)\n     return config;\n }\n \n-ConfigurationPtr createConfiguration(const std::string & root_name, const SettingsChanges & settings)\n+ConfigurationPtr createConfiguration(\n+    const std::string & root_name, const SettingsChanges & settings, const std::unordered_map<String, bool> & overridability)\n {\n     namespace Configuration = NamedCollectionConfiguration;\n \n     auto config = Configuration::createEmptyConfiguration(root_name);\n     for (const auto & [name, value] : settings)\n+    {\n         Configuration::setConfigValue<String>(*config, name, convertFieldToString(value));\n+        auto ovalue = overridability.find(name);\n+        if (ovalue != overridability.end())\n+            Configuration::setOverridable(*config, name, ovalue->second);\n+    }\n \n     return config;\n }\n@@ -204,6 +219,22 @@ void listKeys(\n     listKeys(config, enumerate_paths, result, depth);\n }\n \n+std::optional<bool> isOverridable(const Poco::Util::AbstractConfiguration & config, const std::string & path)\n+{\n+    // XPath syntax to access path's attribute 'overridable'\n+    // e.g. <url overridable=1>...</url>\n+    std::string overridable_path = path + \"[@overridable]\";\n+    if (config.has(overridable_path))\n+        return config.getBool(overridable_path);\n+    return {};\n+}\n+\n+void setOverridable(Poco::Util::AbstractConfiguration & config, const std::string & path, const bool value)\n+{\n+    std::string overridable_path = path + \"[@overridable]\";\n+    config.setBool(overridable_path, value);\n+}\n+\n template String getConfigValue<String>(const Poco::Util::AbstractConfiguration & config,\n                                        const std::string & path);\n template UInt64 getConfigValue<UInt64>(const Poco::Util::AbstractConfiguration & config,\n@@ -226,16 +257,36 @@ template Float64 getConfigValueOrDefault<Float64>(const Poco::Util::AbstractConf\n template bool getConfigValueOrDefault<bool>(const Poco::Util::AbstractConfiguration & config,\n                                             const std::string & path, const bool * default_value);\n \n-template void setConfigValue<String>(Poco::Util::AbstractConfiguration & config,\n-                                     const std::string & path, const String & value, bool update);\n-template void setConfigValue<UInt64>(Poco::Util::AbstractConfiguration & config,\n-                                     const std::string & path, const UInt64 & value, bool update);\n-template void setConfigValue<Int64>(Poco::Util::AbstractConfiguration & config,\n-                                    const std::string & path, const Int64 & value, bool update);\n-template void setConfigValue<Float64>(Poco::Util::AbstractConfiguration & config,\n-                                      const std::string & path, const Float64 & value, bool update);\n-template void setConfigValue<bool>(Poco::Util::AbstractConfiguration & config,\n-                                   const std::string & path, const bool & value, bool update);\n+template void setConfigValue<String>(\n+    Poco::Util::AbstractConfiguration & config,\n+    const std::string & path,\n+    const String & value,\n+    bool update,\n+    const std::optional<bool> is_overridable);\n+template void setConfigValue<UInt64>(\n+    Poco::Util::AbstractConfiguration & config,\n+    const std::string & path,\n+    const UInt64 & value,\n+    bool update,\n+    const std::optional<bool> is_overridable);\n+template void setConfigValue<Int64>(\n+    Poco::Util::AbstractConfiguration & config,\n+    const std::string & path,\n+    const Int64 & value,\n+    bool update,\n+    const std::optional<bool> is_overridable);\n+template void setConfigValue<Float64>(\n+    Poco::Util::AbstractConfiguration & config,\n+    const std::string & path,\n+    const Float64 & value,\n+    bool update,\n+    const std::optional<bool> is_overridable);\n+template void setConfigValue<bool>(\n+    Poco::Util::AbstractConfiguration & config,\n+    const std::string & path,\n+    const bool & value,\n+    bool update,\n+    const std::optional<bool> is_overridable);\n \n template void copyConfigValue<String>(const Poco::Util::AbstractConfiguration & from_config, const std::string & from_path,\n                                       Poco::Util::AbstractConfiguration & to_config, const std::string & to_path);\ndiff --git a/src/Common/NamedCollections/NamedCollectionConfiguration.h b/src/Common/NamedCollections/NamedCollectionConfiguration.h\nindex bde3bf09d77a..c162e0473496 100644\n--- a/src/Common/NamedCollections/NamedCollectionConfiguration.h\n+++ b/src/Common/NamedCollections/NamedCollectionConfiguration.h\n@@ -1,7 +1,8 @@\n #pragma once\n-#include <Poco/Util/AbstractConfiguration.h>\n #include <queue>\n #include <set>\n+#include <Core/Field.h>\n+#include <Poco/Util/AbstractConfiguration.h>\n \n namespace DB\n {\n@@ -27,11 +28,13 @@ template <typename T> T getConfigValueOrDefault(\n     const std::string & path,\n     const T * default_value = nullptr);\n \n-template<typename T> void setConfigValue(\n+template <typename T>\n+void setConfigValue(\n     Poco::Util::AbstractConfiguration & config,\n     const std::string & path,\n     const T & value,\n-    bool update = false);\n+    bool update = false,\n+    std::optional<bool> is_overridable = {});\n \n template <typename T> void copyConfigValue(\n     const Poco::Util::AbstractConfiguration & from_config,\n@@ -43,7 +46,8 @@ void removeConfigValue(\n     Poco::Util::AbstractConfiguration & config,\n     const std::string & path);\n \n-ConfigurationPtr createConfiguration(const std::string & root_name, const SettingsChanges & settings);\n+ConfigurationPtr createConfiguration(\n+    const std::string & root_name, const SettingsChanges & settings, const std::unordered_map<std::string, bool> & overridability);\n \n /// Enumerate keys paths of the config recursively.\n /// E.g. if `enumerate_paths` = {\"root.key1\"} and config like\n@@ -67,6 +71,8 @@ void listKeys(\n     std::queue<std::string> enumerate_paths,\n     std::set<std::string, std::less<>> & result,\n     ssize_t depth);\n+\n+std::optional<bool> isOverridable(const Poco::Util::AbstractConfiguration & config, const std::string & path);\n }\n \n }\ndiff --git a/src/Common/NamedCollections/NamedCollectionUtils.cpp b/src/Common/NamedCollections/NamedCollectionUtils.cpp\nindex cab844d6213d..9a28a9fc230f 100644\n--- a/src/Common/NamedCollections/NamedCollectionUtils.cpp\n+++ b/src/Common/NamedCollections/NamedCollectionUtils.cpp\n@@ -199,6 +199,12 @@ class LoadFromSQL : private WithContext\n         for (const auto & [name, value] : create_query.changes)\n             result_changes_map.emplace(name, value);\n \n+        std::unordered_map<std::string, bool> result_overridability_map;\n+        for (const auto & [name, value] : query.overridability)\n+            result_overridability_map.emplace(name, value);\n+        for (const auto & [name, value] : create_query.overridability)\n+            result_overridability_map.emplace(name, value);\n+\n         for (const auto & delete_key : query.delete_keys)\n         {\n             auto it = result_changes_map.find(delete_key);\n@@ -210,12 +216,18 @@ class LoadFromSQL : private WithContext\n                     delete_key);\n             }\n             else\n+            {\n                 result_changes_map.erase(it);\n+                auto it_override = result_overridability_map.find(delete_key);\n+                if (it_override != result_overridability_map.end())\n+                    result_overridability_map.erase(it_override);\n+            }\n         }\n \n         create_query.changes.clear();\n         for (const auto & [name, value] : result_changes_map)\n             create_query.changes.emplace_back(name, value);\n+        create_query.overridability = std::move(result_overridability_map);\n \n         writeCreateQueryToMetadata(\n             create_query,\n@@ -244,8 +256,7 @@ class LoadFromSQL : private WithContext\n         const ASTCreateNamedCollectionQuery & query)\n     {\n         const auto & collection_name = query.collection_name;\n-        const auto config = NamedCollectionConfiguration::createConfiguration(\n-            collection_name, query.changes);\n+        const auto config = NamedCollectionConfiguration::createConfiguration(collection_name, query.changes, query.overridability);\n \n         std::set<std::string, std::less<>> keys;\n         for (const auto & [name, _] : query.changes)\n@@ -446,7 +457,13 @@ void updateFromSQL(const ASTAlterNamedCollectionQuery & query, ContextPtr contex\n     auto collection_lock = collection->lock();\n \n     for (const auto & [name, value] : query.changes)\n-        collection->setOrUpdate<String, true>(name, convertFieldToString(value));\n+    {\n+        auto it_override = query.overridability.find(name);\n+        if (it_override != query.overridability.end())\n+            collection->setOrUpdate<String, true>(name, convertFieldToString(value), it_override->second);\n+        else\n+            collection->setOrUpdate<String, true>(name, convertFieldToString(value), {});\n+    }\n \n     for (const auto & key : query.delete_keys)\n         collection->remove<true>(key);\ndiff --git a/src/Common/NamedCollections/NamedCollections.cpp b/src/Common/NamedCollections/NamedCollections.cpp\nindex 0a0f29a8a82f..5b377e94b21a 100644\n--- a/src/Common/NamedCollections/NamedCollections.cpp\n+++ b/src/Common/NamedCollections/NamedCollections.cpp\n@@ -216,13 +216,22 @@ class NamedCollection::Impl\n         return Configuration::getConfigValueOrDefault<T>(*config, key, &default_value);\n     }\n \n-    template <typename T> void set(const Key & key, const T & value, bool update_if_exists)\n+    template <typename T>\n+    void set(const Key & key, const T & value, bool update_if_exists, const std::optional<bool> is_overridable)\n     {\n-        Configuration::setConfigValue<T>(*config, key, value, update_if_exists);\n+        Configuration::setConfigValue<T>(*config, key, value, update_if_exists, is_overridable);\n         if (!keys.contains(key))\n             keys.insert(key);\n     }\n \n+    bool isOverridable(const Key & key, const bool default_value)\n+    {\n+        const auto is_overridable = Configuration::isOverridable(*config, key);\n+        if (is_overridable)\n+            return *is_overridable;\n+        return default_value;\n+    }\n+\n     ImplPtr createCopy(const std::string & collection_name_) const\n     {\n         return create(*config, collection_name_, \"\", keys);\n@@ -396,22 +405,30 @@ template <typename T> T NamedCollection::getAnyOrDefault(const std::initializer_\n     return default_value;\n }\n \n-template <typename T, bool Locked> void NamedCollection::set(const Key & key, const T & value)\n+template <typename T, bool Locked>\n+void NamedCollection::set(const Key & key, const T & value, const std::optional<bool> is_overridable)\n {\n     assertMutable();\n     std::unique_lock lock(mutex, std::defer_lock);\n     if constexpr (!Locked)\n         lock.lock();\n-    pimpl->set<T>(key, value, false);\n+    pimpl->set<T>(key, value, false, is_overridable);\n }\n \n-template <typename T, bool Locked> void NamedCollection::setOrUpdate(const Key & key, const T & value)\n+template <typename T, bool Locked>\n+void NamedCollection::setOrUpdate(const Key & key, const T & value, const std::optional<bool> is_overridable)\n {\n     assertMutable();\n     std::unique_lock lock(mutex, std::defer_lock);\n     if constexpr (!Locked)\n         lock.lock();\n-    pimpl->set<T>(key, value, true);\n+    pimpl->set<T>(key, value, true, is_overridable);\n+}\n+\n+bool NamedCollection::isOverridable(const Key & key, bool default_value) const\n+{\n+    std::lock_guard lock(mutex);\n+    return pimpl->isOverridable(key, default_value);\n }\n \n template <bool Locked> void NamedCollection::remove(const Key & key)\n@@ -499,25 +516,43 @@ template Int64 NamedCollection::getAnyOrDefault<Int64>(const std::initializer_li\n template Float64 NamedCollection::getAnyOrDefault<Float64>(const std::initializer_list<NamedCollection::Key> & key, const Float64 & default_value) const;\n template bool NamedCollection::getAnyOrDefault<bool>(const std::initializer_list<NamedCollection::Key> & key, const bool & default_value) const;\n \n-template void NamedCollection::set<String, true>(const NamedCollection::Key & key, const String & value);\n-template void NamedCollection::set<String, false>(const NamedCollection::Key & key, const String & value);\n-template void NamedCollection::set<UInt64, true>(const NamedCollection::Key & key, const UInt64 & value);\n-template void NamedCollection::set<UInt64, false>(const NamedCollection::Key & key, const UInt64 & value);\n-template void NamedCollection::set<Int64, true>(const NamedCollection::Key & key, const Int64 & value);\n-template void NamedCollection::set<Int64, false>(const NamedCollection::Key & key, const Int64 & value);\n-template void NamedCollection::set<Float64, true>(const NamedCollection::Key & key, const Float64 & value);\n-template void NamedCollection::set<Float64, false>(const NamedCollection::Key & key, const Float64 & value);\n-template void NamedCollection::set<bool, false>(const NamedCollection::Key & key, const bool & value);\n-\n-template void NamedCollection::setOrUpdate<String, true>(const NamedCollection::Key & key, const String & value);\n-template void NamedCollection::setOrUpdate<String, false>(const NamedCollection::Key & key, const String & value);\n-template void NamedCollection::setOrUpdate<UInt64, true>(const NamedCollection::Key & key, const UInt64 & value);\n-template void NamedCollection::setOrUpdate<UInt64, false>(const NamedCollection::Key & key, const UInt64 & value);\n-template void NamedCollection::setOrUpdate<Int64, true>(const NamedCollection::Key & key, const Int64 & value);\n-template void NamedCollection::setOrUpdate<Int64, false>(const NamedCollection::Key & key, const Int64 & value);\n-template void NamedCollection::setOrUpdate<Float64, true>(const NamedCollection::Key & key, const Float64 & value);\n-template void NamedCollection::setOrUpdate<Float64, false>(const NamedCollection::Key & key, const Float64 & value);\n-template void NamedCollection::setOrUpdate<bool, false>(const NamedCollection::Key & key, const bool & value);\n+template void\n+NamedCollection::set<String, true>(const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<String, false>(const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<UInt64, true>(const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<UInt64, false>(const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<Int64, true>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<Int64, false>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<Float64, true>(const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<Float64, false>(const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::set<bool, false>(const NamedCollection::Key & key, const bool & value, const std::optional<bool> is_overridable);\n+\n+template void NamedCollection::setOrUpdate<String, true>(\n+    const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);\n+template void NamedCollection::setOrUpdate<String, false>(\n+    const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);\n+template void NamedCollection::setOrUpdate<UInt64, true>(\n+    const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);\n+template void NamedCollection::setOrUpdate<UInt64, false>(\n+    const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::setOrUpdate<Int64, true>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::setOrUpdate<Int64, false>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);\n+template void NamedCollection::setOrUpdate<Float64, true>(\n+    const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);\n+template void NamedCollection::setOrUpdate<Float64, false>(\n+    const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);\n+template void\n+NamedCollection::setOrUpdate<bool, false>(const NamedCollection::Key & key, const bool & value, const std::optional<bool> is_overridable);\n \n template void NamedCollection::remove<true>(const Key & key);\n template void NamedCollection::remove<false>(const Key & key);\ndiff --git a/src/Common/NamedCollections/NamedCollections.h b/src/Common/NamedCollections/NamedCollections.h\nindex 4a0f020db21b..de27f4e6083a 100644\n--- a/src/Common/NamedCollections/NamedCollections.h\n+++ b/src/Common/NamedCollections/NamedCollections.h\n@@ -47,9 +47,13 @@ class NamedCollection\n \n     std::unique_lock<std::mutex> lock();\n \n-    template <typename T, bool locked = false> void set(const Key & key, const T & value);\n+    template <typename T, bool locked = false>\n+    void set(const Key & key, const T & value, std::optional<bool> is_overridable);\n \n-    template <typename T, bool locked = false> void setOrUpdate(const Key & key, const T & value);\n+    template <typename T, bool locked = false>\n+    void setOrUpdate(const Key & key, const T & value, std::optional<bool> is_overridable);\n+\n+    bool isOverridable(const Key & key, bool default_value) const;\n \n     template <bool locked = false> void remove(const Key & key);\n \ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 5c41c0b08294..0c9c1d218520 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -817,6 +817,7 @@ class IColumn;\n     M(Bool, create_index_ignore_unique, false, \"Ignore UNIQUE keyword in CREATE UNIQUE INDEX. Made for SQL compatibility tests.\", 0) \\\n     M(Bool, print_pretty_type_names, false, \"Print pretty type names in DESCRIBE query and toTypeName() function\", 0) \\\n     M(Bool, create_table_empty_primary_key_by_default, false, \"Allow to create *MergeTree tables with empty primary key when ORDER BY and PRIMARY KEY not specified\", 0) \\\n+    M(Bool, allow_named_collection_override_by_default, true, \"Allow named collections' fields override by default.\", 0)\\\n \n // End of COMMON_SETTINGS\n // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS, move obsolete settings to OBSOLETE_SETTINGS and obsolete format settings to OBSOLETE_FORMAT_SETTINGS.\ndiff --git a/src/Parsers/ASTAlterNamedCollectionQuery.cpp b/src/Parsers/ASTAlterNamedCollectionQuery.cpp\nindex 6363a7306bda..c3c40c42fb73 100644\n--- a/src/Parsers/ASTAlterNamedCollectionQuery.cpp\n+++ b/src/Parsers/ASTAlterNamedCollectionQuery.cpp\n@@ -35,6 +35,9 @@ void ASTAlterNamedCollectionQuery::formatImpl(const IAST::FormatSettings & setti\n                 settings.ostr << \" = \" << applyVisitor(FieldVisitorToString(), change.value);\n             else\n                 settings.ostr << \" = '[HIDDEN]'\";\n+            auto override_value = overridability.find(change.name);\n+            if (override_value != overridability.end())\n+                settings.ostr << \" \" << (override_value->second ? \"\" : \"NOT \") << \"OVERRIDABLE\";\n         }\n     }\n     if (!delete_keys.empty())\ndiff --git a/src/Parsers/ASTAlterNamedCollectionQuery.h b/src/Parsers/ASTAlterNamedCollectionQuery.h\nindex 36cf9c65b818..dc2670a88964 100644\n--- a/src/Parsers/ASTAlterNamedCollectionQuery.h\n+++ b/src/Parsers/ASTAlterNamedCollectionQuery.h\n@@ -15,6 +15,7 @@ class ASTAlterNamedCollectionQuery : public IAST, public ASTQueryWithOnCluster\n     SettingsChanges changes;\n     std::vector<std::string> delete_keys;\n     bool if_exists = false;\n+    std::unordered_map<String, bool> overridability;\n \n     String getID(char) const override { return \"AlterNamedCollectionQuery\"; }\n \ndiff --git a/src/Parsers/ASTCreateNamedCollectionQuery.cpp b/src/Parsers/ASTCreateNamedCollectionQuery.cpp\nindex 45ef8565148c..54a1022102ed 100644\n--- a/src/Parsers/ASTCreateNamedCollectionQuery.cpp\n+++ b/src/Parsers/ASTCreateNamedCollectionQuery.cpp\n@@ -39,6 +39,9 @@ void ASTCreateNamedCollectionQuery::formatImpl(const IAST::FormatSettings & sett\n             settings.ostr << \" = \" << applyVisitor(FieldVisitorToString(), change.value);\n         else\n             settings.ostr << \" = '[HIDDEN]'\";\n+        auto override_value = overridability.find(change.name);\n+        if (override_value != overridability.end())\n+            settings.ostr << \" \" << (override_value->second ? \"\" : \"NOT \") << \"OVERRIDABLE\";\n     }\n }\n \ndiff --git a/src/Parsers/ASTCreateNamedCollectionQuery.h b/src/Parsers/ASTCreateNamedCollectionQuery.h\nindex 785aeb781b4b..47f2352b4cd1 100644\n--- a/src/Parsers/ASTCreateNamedCollectionQuery.h\n+++ b/src/Parsers/ASTCreateNamedCollectionQuery.h\n@@ -14,6 +14,7 @@ class ASTCreateNamedCollectionQuery : public IAST, public ASTQueryWithOnCluster\n     std::string collection_name;\n     SettingsChanges changes;\n     bool if_not_exists = false;\n+    std::unordered_map<String, bool> overridability;\n \n     String getID(char) const override { return \"CreateNamedCollectionQuery\"; }\n \ndiff --git a/src/Parsers/ParserAlterNamedCollectionQuery.cpp b/src/Parsers/ParserAlterNamedCollectionQuery.cpp\nindex 8fb84f86246f..9b33aa253baf 100644\n--- a/src/Parsers/ParserAlterNamedCollectionQuery.cpp\n+++ b/src/Parsers/ParserAlterNamedCollectionQuery.cpp\n@@ -17,14 +17,16 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod\n     ParserKeyword s_on(\"ON\");\n     ParserKeyword s_delete(\"DELETE\");\n     ParserIdentifier name_p;\n-    ParserSetQuery set_p;\n+    ParserKeyword s_set(\"SET\");\n+    ParserKeyword s_overridable(\"OVERRIDABLE\");\n+    ParserKeyword s_not_overridable(\"NOT OVERRIDABLE\");\n     ParserToken s_comma(TokenType::Comma);\n \n     String cluster_str;\n     bool if_exists = false;\n \n     ASTPtr collection_name;\n-    ASTPtr set;\n+\n     std::vector<std::string> delete_keys;\n \n     if (!s_alter.ignore(pos, expected))\n@@ -45,20 +47,27 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod\n             return false;\n     }\n \n-    bool parsed_delete = false;\n-    if (!set_p.parse(pos, set, expected))\n+    SettingsChanges changes;\n+    std::unordered_map<String, bool> overridability;\n+    if (s_set.ignore(pos, expected))\n     {\n-        if (!s_delete.ignore(pos, expected))\n-            return false;\n+        while (true)\n+        {\n+            if (!changes.empty() && !s_comma.ignore(pos))\n+                break;\n \n-        parsed_delete = true;\n-    }\n-    else if (s_delete.ignore(pos, expected))\n-    {\n-        parsed_delete = true;\n+            changes.push_back(SettingChange{});\n+\n+            if (!ParserSetQuery::parseNameValuePair(changes.back(), pos, expected))\n+                return false;\n+            if (s_not_overridable.ignore(pos, expected))\n+                overridability.emplace(changes.back().name, false);\n+            else if (s_overridable.ignore(pos, expected))\n+                overridability.emplace(changes.back().name, true);\n+        }\n     }\n \n-    if (parsed_delete)\n+    if (s_delete.ignore(pos, expected))\n     {\n         while (true)\n         {\n@@ -78,8 +87,8 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod\n     query->collection_name = getIdentifierName(collection_name);\n     query->if_exists = if_exists;\n     query->cluster = std::move(cluster_str);\n-    if (set)\n-        query->changes = set->as<ASTSetQuery>()->changes;\n+    query->changes = changes;\n+    query->overridability = std::move(overridability);\n     query->delete_keys = delete_keys;\n \n     node = query;\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 760ce73cf6f0..2ef37ac3f99d 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -1517,6 +1517,8 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n     ParserKeyword s_on(\"ON\");\n     ParserKeyword s_as(\"AS\");\n+    ParserKeyword s_not_overridable(\"NOT OVERRIDABLE\");\n+    ParserKeyword s_overridable(\"OVERRIDABLE\");\n     ParserIdentifier name_p;\n     ParserToken s_comma(TokenType::Comma);\n \n@@ -1547,6 +1549,7 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec\n         return false;\n \n     SettingsChanges changes;\n+    std::unordered_map<String, bool> overridability;\n \n     while (true)\n     {\n@@ -1557,6 +1560,10 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec\n \n         if (!ParserSetQuery::parseNameValuePair(changes.back(), pos, expected))\n             return false;\n+        if (s_not_overridable.ignore(pos, expected))\n+            overridability.emplace(changes.back().name, false);\n+        else if (s_overridable.ignore(pos, expected))\n+            overridability.emplace(changes.back().name, true);\n     }\n \n     auto query = std::make_shared<ASTCreateNamedCollectionQuery>();\n@@ -1565,6 +1572,7 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec\n     query->if_not_exists = if_not_exists;\n     query->changes = changes;\n     query->cluster = std::move(cluster_str);\n+    query->overridability = overridability;\n \n     node = query;\n     return true;\ndiff --git a/src/Storages/NamedCollectionsHelpers.cpp b/src/Storages/NamedCollectionsHelpers.cpp\nindex f301cca92a13..8124ba651f93 100644\n--- a/src/Storages/NamedCollectionsHelpers.cpp\n+++ b/src/Storages/NamedCollectionsHelpers.cpp\n@@ -92,14 +92,23 @@ MutableNamedCollectionPtr tryGetNamedCollectionWithOverrides(\n     if (asts.size() == 1)\n         return collection_copy;\n \n+    const auto allow_override_by_default = context->getSettings().allow_named_collection_override_by_default;\n+\n     for (auto * it = std::next(asts.begin()); it != asts.end(); ++it)\n     {\n         auto value_override = getKeyValueFromAST(*it, /* fallback_to_ast_value */complex_args != nullptr, context);\n \n-        if (!value_override && !(*it)->as<ASTFunction>())\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected key-value argument or function\");\n         if (!value_override)\n-            continue;\n+        {\n+            if (!(*it)->as<ASTFunction>())\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Expected key-value argument or function\");\n+            if (allow_override_by_default)\n+                continue;\n+            // if allow_override_by_default is false we don't allow extra arguments\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Override not allowed\");\n+        }\n+        else if (!collection_copy->isOverridable(value_override->first, allow_override_by_default))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Override not allowed for '{}'\", value_override->first);\n \n         if (const ASTPtr * value = std::get_if<ASTPtr>(&value_override->second))\n         {\n@@ -108,7 +117,7 @@ MutableNamedCollectionPtr tryGetNamedCollectionWithOverrides(\n         }\n \n         const auto & [key, value] = *value_override;\n-        collection_copy->setOrUpdate<String>(key, toString(std::get<Field>(value_override->second)));\n+        collection_copy->setOrUpdate<String>(key, toString(std::get<Field>(value)), {});\n     }\n \n     return collection_copy;\n@@ -128,8 +137,14 @@ MutableNamedCollectionPtr tryGetNamedCollectionWithOverrides(\n \n     Poco::Util::AbstractConfiguration::Keys keys;\n     config.keys(config_prefix, keys);\n+    const auto allow_override_by_default = context->getSettings().allow_named_collection_override_by_default;\n     for (const auto & key : keys)\n-        collection_copy->setOrUpdate<String>(key, config.getString(config_prefix + '.' + key));\n+    {\n+        if (collection_copy->isOverridable(key, allow_override_by_default))\n+            collection_copy->setOrUpdate<String>(key, config.getString(config_prefix + '.' + key), {});\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Override not allowed for '{}'\", key);\n+    }\n \n     return collection_copy;\n }\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_named_collections.cpp b/src/Common/tests/gtest_named_collections.cpp\nindex bd46d2668e46..e2482f6ba8ba 100644\n--- a/src/Common/tests/gtest_named_collections.cpp\n+++ b/src/Common/tests/gtest_named_collections.cpp\n@@ -77,7 +77,7 @@ key5:\t5\n key6:\t6.6\n )CONFIG\");\n \n-    collection2_copy->setOrUpdate<String>(\"key4\", \"value44\");\n+    collection2_copy->setOrUpdate<String>(\"key4\", \"value44\", {});\n     ASSERT_EQ(collection2_copy->get<String>(\"key4\"), \"value44\");\n     ASSERT_EQ(collection2->get<String>(\"key4\"), \"value4\");\n \n@@ -85,7 +85,7 @@ key6:\t6.6\n     ASSERT_EQ(collection2_copy->getOrDefault<String>(\"key4\", \"N\"), \"N\");\n     ASSERT_EQ(collection2->getOrDefault<String>(\"key4\", \"N\"), \"value4\");\n \n-    collection2_copy->setOrUpdate<String>(\"key4\", \"value45\");\n+    collection2_copy->setOrUpdate<String>(\"key4\", \"value45\", {});\n     ASSERT_EQ(collection2_copy->getOrDefault<String>(\"key4\", \"N\"), \"value45\");\n \n     NamedCollectionFactory::instance().remove(\"collection2_copy\");\ndiff --git a/tests/config/config.d/named_collection.xml b/tests/config/config.d/named_collection.xml\nindex 5b716a7b8da5..01645ccecd50 100644\n--- a/tests/config/config.d/named_collection.xml\n+++ b/tests/config/config.d/named_collection.xml\n@@ -37,5 +37,13 @@\n             <access_key_id>test</access_key_id>\n             <secret_access_key>testtest</secret_access_key>\n         </s3_conn_db>\n+        <url_override1>\n+            <url overridable=\"0\">http://127.0.0.1:8123?query=select+1</url>\n+            <format overridable=\"1\">RawBLOB</format>\n+        </url_override1>\n+        <url_override2>\n+            <url>http://127.0.0.1:8123?query=select+1</url>\n+            <format>RawBLOB</format>\n+        </url_override2>\n     </named_collections>\n </clickhouse>\ndiff --git a/tests/queries/0_stateless/02883_named_collections_override.reference b/tests/queries/0_stateless/02883_named_collections_override.reference\nnew file mode 100644\nindex 000000000000..78b3eeda9873\n--- /dev/null\n+++ b/tests/queries/0_stateless/02883_named_collections_override.reference\n@@ -0,0 +1,32 @@\n+allow_named_collection_override_by_default=1 u1\n+1\\n\n+1\\n\n+1\n+allow_named_collection_override_by_default=1 u2\n+1\\n\n+1\\n\n+2\\n\n+1\n+allow_named_collection_override_by_default=0 u1\n+1\\n\n+1\n+allow_named_collection_override_by_default=0 u2\n+1\\n\n+Test ALTER\n+2\\n\n+1\\n\n+Test XML collections\n+allow_named_collection_override_by_default=1 url_override1\n+1\\n\n+1\\n\n+1\n+allow_named_collection_override_by_default=1 url_override2\n+1\\n\n+1\\n\n+2\\n\n+1\n+allow_named_collection_override_by_default=0 url_override1\n+1\\n\n+1\n+allow_named_collection_override_by_default=0 url_override2\n+1\\n\ndiff --git a/tests/queries/0_stateless/02883_named_collections_override.sh b/tests/queries/0_stateless/02883_named_collections_override.sh\nnew file mode 100755\nindex 000000000000..a08c795127da\n--- /dev/null\n+++ b/tests/queries/0_stateless/02883_named_collections_override.sh\n@@ -0,0 +1,92 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+u1=\"${CLICKHOUSE_TEST_UNIQUE_NAME}_collection1\"\n+u2=\"${CLICKHOUSE_TEST_UNIQUE_NAME}_collection2\"\n+u3=\"${CLICKHOUSE_TEST_UNIQUE_NAME}_collection3\"\n+\n+${CLICKHOUSE_CLIENT}  -nm --query \"\n+\n+DROP NAMED COLLECTION IF EXISTS $u1;\n+DROP NAMED COLLECTION IF EXISTS $u2;\n+DROP NAMED COLLECTION IF EXISTS $u3;\n+\n+CREATE NAMED COLLECTION IF NOT EXISTS $u1 AS\n+    url = 'http://127.0.0.1:8123?query=select+1' NOT OVERRIDABLE,\n+    format = 'RawBLOB' OVERRIDABLE;\n+\n+CREATE NAMED COLLECTION IF NOT EXISTS $u2 AS\n+    url = 'http://127.0.0.1:8123?query=select+1',\n+    format = 'RawBLOB';\n+\n+SET allow_named_collection_override_by_default=1;\n+SELECT 'allow_named_collection_override_by_default=1 u1';\n+SELECT * FROM url($u1);\n+SELECT * FROM url($u1, headers('Accept'='text/csv; charset=utf-8'));\n+SELECT * FROM url($u1, url='http://127.0.0.1:8123?query=select+2'); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url($u1, format='CSV');\n+SELECT 'allow_named_collection_override_by_default=1 u2';\n+SELECT * FROM url($u2);\n+SELECT * FROM url($u2, headers('Accept'='text/csv; charset=utf-8'));\n+SELECT * FROM url($u2, url='http://127.0.0.1:8123?query=select+2');\n+SELECT * FROM url($u2, format='CSV');\n+\n+SET allow_named_collection_override_by_default=0;\n+SELECT 'allow_named_collection_override_by_default=0 u1';\n+SELECT * FROM url($u1);\n+SELECT * FROM url($u1, headers('Accept'='text/csv; charset=utf-8')); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url($u1, url='http://127.0.0.1:8123?query=select+2'); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url($u1, format='CSV');\n+SELECT 'allow_named_collection_override_by_default=0 u2';\n+SELECT * FROM url($u2);\n+SELECT * FROM url($u2, headers('Accept'='text/csv; charset=utf-8')); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url($u2, url='http://127.0.0.1:8123?query=select+2'); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url($u2, format='CSV'); -- { serverError BAD_ARGUMENTS }\n+\n+SELECT 'Test ALTER';\n+\n+CREATE NAMED COLLECTION IF NOT EXISTS $u3 AS\n+    url = 'http://127.0.0.1:8123?query=select+1' NOT OVERRIDABLE,\n+    format = 'RawBLOB' OVERRIDABLE;\n+\n+ALTER NAMED COLLECTION $u3 SET\n+    url = 'http://127.0.0.1:8123?query=select+2' OVERRIDABLE,\n+    format = 'RawBLOB' NOT OVERRIDABLE;\n+\n+SELECT * FROM url($u3);\n+SELECT * FROM url($u3, url='http://127.0.0.1:8123?query=select+1');\n+SELECT * FROM url($u3, format='CSV'); -- { serverError BAD_ARGUMENTS }\n+\n+DROP NAMED COLLECTION IF EXISTS $u1;\n+DROP NAMED COLLECTION IF EXISTS $u2;\n+DROP NAMED COLLECTION IF EXISTS $u2;\n+\n+SELECT 'Test XML collections';\n+\n+SET allow_named_collection_override_by_default=1;\n+SELECT 'allow_named_collection_override_by_default=1 url_override1';\n+SELECT * FROM url(url_override1);\n+SELECT * FROM url(url_override1, headers('Accept'='text/csv; charset=utf-8'));\n+SELECT * FROM url(url_override1, url='http://127.0.0.1:8123?query=select+2'); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url(url_override1, format='CSV');\n+SELECT 'allow_named_collection_override_by_default=1 url_override2';\n+SELECT * FROM url(url_override2);\n+SELECT * FROM url(url_override2, headers('Accept'='text/csv; charset=utf-8'));\n+SELECT * FROM url(url_override2, url='http://127.0.0.1:8123?query=select+2');\n+SELECT * FROM url(url_override2, format='CSV');\n+\n+SET allow_named_collection_override_by_default=0;\n+SELECT 'allow_named_collection_override_by_default=0 url_override1';\n+SELECT * FROM url(url_override1);\n+SELECT * FROM url(url_override1, headers('Accept'='text/csv; charset=utf-8')); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url(url_override1, url='http://127.0.0.1:8123?query=select+2'); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url(url_override1, format='CSV');\n+SELECT 'allow_named_collection_override_by_default=0 url_override2';\n+SELECT * FROM url(url_override2);\n+SELECT * FROM url(url_override2, headers('Accept'='text/csv; charset=utf-8')); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url(url_override2, url='http://127.0.0.1:8123?query=select+2'); -- { serverError BAD_ARGUMENTS }\n+SELECT * FROM url(url_override2, format='CSV'); -- { serverError BAD_ARGUMENTS }\n+\"\n",
  "problem_statement": "grants access/use named collections\nNamed collections is powerful feature.\r\n\r\nWhen you create a named collection it became accessible to all users. There is no way to restrict this access.\r\n\r\nI propose to implement a new feature `grant USE named collection collection1 to user1`.\r\nany verb: `USE` or `EXECUTE` or `ACCESS`.\r\n\r\nNow named collection is a security flaw. \r\n\r\n1. You create named_collections with access to a S3 bucket -- anybody can use it (XML users/SQL users with access to s3 function).\r\n2. You create named_collections with access to a mysql database -- anybody can access it and moreover anybody can access any database / any table, because mysql function allows to override table.\r\n3. Password can be exposed, because you can override mysql host and query own malicious mysql server, which will grab the password.\r\n\r\n---\r\n\r\nAlso maybe add another feature into named_collections, and forbid override keys:\r\n\r\n```\r\nCREATE NAMED COLLECTION mymysql AS\r\nuser = 'myuser',\r\npassword = 'mypass',\r\nhost = '127.0.0.1',\r\nport = 3306,\r\n\r\nallow_to_override = false         --<<<<<----\r\n\r\n;\r\n```\r\n\r\nOr `allow_to_modify` or `modifiable`\n",
  "hints_text": "@alexey-milovidov \r\n\nAnother idea is \r\n\r\n> allow_to_override = false         --<<<<<----\r\n\r\nCould be per key=value pair property\r\n\r\n```\r\nCREATE NAMED COLLECTION mymysql AS\r\nuser = 'myuser' OVERRIDABLE,\r\npassword = 'mypass',\r\nhost = '127.0.0.1',\r\nport = 3306,\r\n```\r\n\r\nAnd even more weird idea, you can pass an array of possible values\r\n\r\n```\r\nCREATE NAMED COLLECTION mymysql AS\r\nuser = 'myuser' OVERRIDABLE,\r\npassword = 'mypass',\r\nhost = '127.0.0.1',\r\nport = 3306,\r\ntable = ['tbl_a', 'tbl_b']\r\n```\r\n\r\nAnd mark some entities as secret...\r\n\r\n```\r\nCREATE NAMED COLLECTION mymysql AS\r\nuser = 'myuser' OVERRIDABLE,\r\npassword = 'mypass' SECRET,\r\nhost = '127.0.0.1',\r\nport = 3306,\r\ntable = ['tbl_a', 'tbl_b']\r\n```\r\n\r\nSo, they will not be visible to users during SHOW CREATE NAMED COLLECTION\nThis task is already discussed - ACL for named collections.\n> This task is already discussed - ACL for named collections.\r\n\r\nyes, but currently there are only grants for `CREATE/SHOW/ALTER/DROP NAMED COLLECTION <collection_name>`, but not for use `USE`, added it here https://github.com/ClickHouse/ClickHouse/pull/50625.\nPart of the proposed is implemented in https://github.com/ClickHouse/ClickHouse/pull/50625.\r\nPart with `\"allow_to_override\"` will add in a separate PR.\nIs any work happening on the `allow_to_override` feature?  We want to use named collections but right now worried about possibility of creds being exposed.\n@kssenii I could work on this issue if it's okay for you.\r\nThe idea would be to work on something like what was proposed [here](https://github.com/ClickHouse/ClickHouse/issues/50277#issuecomment-1565162706): a new keyword to allow overrides (denied by default) with a global setting to control whether this new behaviour is enabled on not (to not break existing setups).\r\n\n> @kssenii I could work on this issue if it's okay for you.\r\n\r\nyes, thank you!\r\n\r\n> The idea would be to work on something like what was proposed https://github.com/ClickHouse/ClickHouse/issues/50277#issuecomment-1565162706: a new keyword to allow overrides\r\n\r\nyes, looks good.\r\n\r\n> denied by default with a global setting to control whether this new behaviour is enabled on not (to not break existing setups).\r\n\r\nI'd rather have a server level config setting like \"allow_named_collection_override_by_default\" which is true by default (for compatibility).",
  "created_at": "2023-10-18T12:39:33Z"
}