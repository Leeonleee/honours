diff --git a/docs/en/operations/named-collections.md b/docs/en/operations/named-collections.md
index 6ed72152c1e7..06c05929ffaa 100644
--- a/docs/en/operations/named-collections.md
+++ b/docs/en/operations/named-collections.md
@@ -18,7 +18,15 @@ function, table engine, database, etc. In the examples below the parameter list
 linked to for each type.
 
 Parameters set in a named collection can be overridden in SQL, this is shown in the examples
-below.
+below. This ability can be limited using `[NOT] OVERRIDABLE` keywords and XML attributes
+and/or the configuration option `allow_named_collection_override_by_default`.
+
+:::warning
+If override is allowed, it may be possible for users without administrative access to
+figure out the credentials that you are trying to hide.
+If you are using named collections with that purpose, you should disable
+`allow_named_collection_override_by_default` (which is enabled by default).
+:::
 
 ## Storing named collections in the system database
 
@@ -26,11 +34,17 @@ below.
 
 ```sql
 CREATE NAMED COLLECTION name AS
-key_1 = 'value',
-key_2 = 'value2',
+key_1 = 'value' OVERRIDABLE,
+key_2 = 'value2' NOT OVERRIDABLE,
 url = 'https://connection.url/'
 ```
 
+In the above example:
+
+ * `key_1` can always be overridden.
+ * `key_2` can never be overridden.
+ * `url` can be overridden or not depending on the value of `allow_named_collection_override_by_default`.
+
 ### Permissions to create named collections with DDL
 
 To manage named collections with DDL a user must have the `named_control_collection` privilege.  This can be assigned by adding a file to `/etc/clickhouse-server/users.d/`.  The example gives the user `default` both the `access_management` and `named_collection_control` privileges:
@@ -61,25 +75,37 @@ In the above example the `password_sha256_hex` value is the hexadecimal represen
 <clickhouse>
      <named_collections>
         <name>
-            <key_1>value</key_1>
-            <key_2>value_2</key_2>
+            <key_1 overridable="true">value</key_1>
+            <key_2 overridable="false">value_2</key_2>
             <url>https://connection.url/</url>
         </name>
      </named_collections>
 </clickhouse>
 ```
 
+In the above example:
+
+ * `key_1` can always be overridden.
+ * `key_2` can never be overridden.
+ * `url` can be overridden or not depending on the value of `allow_named_collection_override_by_default`.
+
 ## Modifying named collections
 
 Named collections that are created with DDL queries can be altered or dropped with DDL. Named collections created with XML files can be managed by editing or deleting the corresponding XML.
 
 ### Alter a DDL named collection
 
-Change or add the keys `key1` and `key3` of the collection `collection2`:
+Change or add the keys `key1` and `key3` of the collection `collection2`
+(this will not change the value of the `overridable` flag for those keys):
 ```sql
 ALTER NAMED COLLECTION collection2 SET key1=4, key3='value3'
 ```
 
+Change or add the key `key1` and allow it to be always overridden:
+```sql
+ALTER NAMED COLLECTION collection2 SET key1=4 OVERRIDABLE
+```
+
 Remove the key `key2` from `collection2`:
 ```sql
 ALTER NAMED COLLECTION collection2 DELETE key2
@@ -90,6 +116,13 @@ Change or add the key `key1` and delete the key `key3` of the collection `collec
 ALTER NAMED COLLECTION collection2 SET key1=4, DELETE key3
 ```
 
+To force a key to use the default settings for the `overridable` flag, you have to
+remove and re-add the key.
+```sql
+ALTER NAMED COLLECTION collection2 DELETE key1;
+ALTER NAMED COLLECTION collection2 SET key1=4;
+```
+
 ### Drop the DDL named collection `collection2`:
 ```sql
 DROP NAMED COLLECTION collection2
diff --git a/docs/en/sql-reference/statements/alter/named-collection.md b/docs/en/sql-reference/statements/alter/named-collection.md
index ac6752127c19..71d4bfadd9cd 100644
--- a/docs/en/sql-reference/statements/alter/named-collection.md
+++ b/docs/en/sql-reference/statements/alter/named-collection.md
@@ -12,9 +12,9 @@ This query intends to modify already existing named collections.
 ```sql
 ALTER NAMED COLLECTION [IF EXISTS] name [ON CLUSTER cluster]
 [ SET
-key_name1 = 'some value',
-key_name2 = 'some value',
-key_name3 = 'some value',
+key_name1 = 'some value' [[NOT] OVERRIDABLE],
+key_name2 = 'some value' [[NOT] OVERRIDABLE],
+key_name3 = 'some value' [[NOT] OVERRIDABLE],
 ... ] |
 [ DELETE key_name4, key_name5, ... ]
 ```
@@ -22,9 +22,9 @@ key_name3 = 'some value',
 **Example**
 
 ```sql
-CREATE NAMED COLLECTION foobar AS a = '1', b = '2';
+CREATE NAMED COLLECTION foobar AS a = '1' NOT OVERRIDABLE, b = '2';
 
-ALTER NAMED COLLECTION foobar SET a = '2', c = '3';
+ALTER NAMED COLLECTION foobar SET a = '2' OVERRIDABLE, c = '3';
 
 ALTER NAMED COLLECTION foobar DELETE b;
 ```
diff --git a/docs/en/sql-reference/statements/create/named-collection.md b/docs/en/sql-reference/statements/create/named-collection.md
index 1fc7b11c5543..f69fa2e3678b 100644
--- a/docs/en/sql-reference/statements/create/named-collection.md
+++ b/docs/en/sql-reference/statements/create/named-collection.md
@@ -11,16 +11,16 @@ Creates a new named collection.
 
 ```sql
 CREATE NAMED COLLECTION [IF NOT EXISTS] name [ON CLUSTER cluster] AS
-key_name1 = 'some value',
-key_name2 = 'some value',
-key_name3 = 'some value',
+key_name1 = 'some value' [[NOT] OVERRIDABLE],
+key_name2 = 'some value' [[NOT] OVERRIDABLE],
+key_name3 = 'some value' [[NOT] OVERRIDABLE],
 ...
 ```
 
 **Example**
 
 ```sql
-CREATE NAMED COLLECTION foobar AS a = '1', b = '2';
+CREATE NAMED COLLECTION foobar AS a = '1', b = '2' OVERRIDABLE;
 ```
 
 **Related statements**
diff --git a/src/Common/NamedCollections/NamedCollectionConfiguration.cpp b/src/Common/NamedCollections/NamedCollectionConfiguration.cpp
index d9bf2349a5a1..2bb0dcd9b695 100644
--- a/src/Common/NamedCollections/NamedCollectionConfiguration.cpp
+++ b/src/Common/NamedCollections/NamedCollectionConfiguration.cpp
@@ -18,6 +18,8 @@ namespace ErrorCodes
 namespace NamedCollectionConfiguration
 {
 
+void setOverridable(Poco::Util::AbstractConfiguration & config, const std::string & path, bool value);
+
 bool hasConfigValue(
     const Poco::Util::AbstractConfiguration & config,
     const std::string & path)
@@ -72,11 +74,13 @@ template <typename T> T getConfigValueOrDefault(
     }
 }
 
-template<typename T> void setConfigValue(
+template <typename T>
+void setConfigValue(
     Poco::Util::AbstractConfiguration & config,
     const std::string & path,
     const T & value,
-    bool update)
+    bool update,
+    const std::optional<bool> is_overridable)
 {
     if (!update && config.has(path))
         throw Exception(ErrorCodes::BAD_ARGUMENTS, "Key `{}` already exists", path);
@@ -96,6 +100,8 @@ template<typename T> void setConfigValue(
             ErrorCodes::NOT_IMPLEMENTED,
             "Unsupported type in setConfigValue(). "
             "Supported types are String, UInt64, Int64, Float64, bool");
+    if (is_overridable)
+        setOverridable(config, path, *is_overridable);
 }
 
 template <typename T> void copyConfigValue(
@@ -123,6 +129,9 @@ template <typename T> void copyConfigValue(
             ErrorCodes::NOT_IMPLEMENTED,
             "Unsupported type in copyConfigValue(). "
             "Supported types are String, UInt64, Int64, Float64");
+    const auto overridable = isOverridable(from_config, from_path);
+    if (overridable)
+        setOverridable(to_config, to_path, *overridable);
 }
 
 void removeConfigValue(
@@ -147,13 +156,19 @@ ConfigurationPtr createEmptyConfiguration(const std::string & root_name)
     return config;
 }
 
-ConfigurationPtr createConfiguration(const std::string & root_name, const SettingsChanges & settings)
+ConfigurationPtr createConfiguration(
+    const std::string & root_name, const SettingsChanges & settings, const std::unordered_map<String, bool> & overridability)
 {
     namespace Configuration = NamedCollectionConfiguration;
 
     auto config = Configuration::createEmptyConfiguration(root_name);
     for (const auto & [name, value] : settings)
+    {
         Configuration::setConfigValue<String>(*config, name, convertFieldToString(value));
+        auto ovalue = overridability.find(name);
+        if (ovalue != overridability.end())
+            Configuration::setOverridable(*config, name, ovalue->second);
+    }
 
     return config;
 }
@@ -204,6 +219,22 @@ void listKeys(
     listKeys(config, enumerate_paths, result, depth);
 }
 
+std::optional<bool> isOverridable(const Poco::Util::AbstractConfiguration & config, const std::string & path)
+{
+    // XPath syntax to access path's attribute 'overridable'
+    // e.g. <url overridable=1>...</url>
+    std::string overridable_path = path + "[@overridable]";
+    if (config.has(overridable_path))
+        return config.getBool(overridable_path);
+    return {};
+}
+
+void setOverridable(Poco::Util::AbstractConfiguration & config, const std::string & path, const bool value)
+{
+    std::string overridable_path = path + "[@overridable]";
+    config.setBool(overridable_path, value);
+}
+
 template String getConfigValue<String>(const Poco::Util::AbstractConfiguration & config,
                                        const std::string & path);
 template UInt64 getConfigValue<UInt64>(const Poco::Util::AbstractConfiguration & config,
@@ -226,16 +257,36 @@ template Float64 getConfigValueOrDefault<Float64>(const Poco::Util::AbstractConf
 template bool getConfigValueOrDefault<bool>(const Poco::Util::AbstractConfiguration & config,
                                             const std::string & path, const bool * default_value);
 
-template void setConfigValue<String>(Poco::Util::AbstractConfiguration & config,
-                                     const std::string & path, const String & value, bool update);
-template void setConfigValue<UInt64>(Poco::Util::AbstractConfiguration & config,
-                                     const std::string & path, const UInt64 & value, bool update);
-template void setConfigValue<Int64>(Poco::Util::AbstractConfiguration & config,
-                                    const std::string & path, const Int64 & value, bool update);
-template void setConfigValue<Float64>(Poco::Util::AbstractConfiguration & config,
-                                      const std::string & path, const Float64 & value, bool update);
-template void setConfigValue<bool>(Poco::Util::AbstractConfiguration & config,
-                                   const std::string & path, const bool & value, bool update);
+template void setConfigValue<String>(
+    Poco::Util::AbstractConfiguration & config,
+    const std::string & path,
+    const String & value,
+    bool update,
+    const std::optional<bool> is_overridable);
+template void setConfigValue<UInt64>(
+    Poco::Util::AbstractConfiguration & config,
+    const std::string & path,
+    const UInt64 & value,
+    bool update,
+    const std::optional<bool> is_overridable);
+template void setConfigValue<Int64>(
+    Poco::Util::AbstractConfiguration & config,
+    const std::string & path,
+    const Int64 & value,
+    bool update,
+    const std::optional<bool> is_overridable);
+template void setConfigValue<Float64>(
+    Poco::Util::AbstractConfiguration & config,
+    const std::string & path,
+    const Float64 & value,
+    bool update,
+    const std::optional<bool> is_overridable);
+template void setConfigValue<bool>(
+    Poco::Util::AbstractConfiguration & config,
+    const std::string & path,
+    const bool & value,
+    bool update,
+    const std::optional<bool> is_overridable);
 
 template void copyConfigValue<String>(const Poco::Util::AbstractConfiguration & from_config, const std::string & from_path,
                                       Poco::Util::AbstractConfiguration & to_config, const std::string & to_path);
diff --git a/src/Common/NamedCollections/NamedCollectionConfiguration.h b/src/Common/NamedCollections/NamedCollectionConfiguration.h
index bde3bf09d77a..c162e0473496 100644
--- a/src/Common/NamedCollections/NamedCollectionConfiguration.h
+++ b/src/Common/NamedCollections/NamedCollectionConfiguration.h
@@ -1,7 +1,8 @@
 #pragma once
-#include <Poco/Util/AbstractConfiguration.h>
 #include <queue>
 #include <set>
+#include <Core/Field.h>
+#include <Poco/Util/AbstractConfiguration.h>
 
 namespace DB
 {
@@ -27,11 +28,13 @@ template <typename T> T getConfigValueOrDefault(
     const std::string & path,
     const T * default_value = nullptr);
 
-template<typename T> void setConfigValue(
+template <typename T>
+void setConfigValue(
     Poco::Util::AbstractConfiguration & config,
     const std::string & path,
     const T & value,
-    bool update = false);
+    bool update = false,
+    std::optional<bool> is_overridable = {});
 
 template <typename T> void copyConfigValue(
     const Poco::Util::AbstractConfiguration & from_config,
@@ -43,7 +46,8 @@ void removeConfigValue(
     Poco::Util::AbstractConfiguration & config,
     const std::string & path);
 
-ConfigurationPtr createConfiguration(const std::string & root_name, const SettingsChanges & settings);
+ConfigurationPtr createConfiguration(
+    const std::string & root_name, const SettingsChanges & settings, const std::unordered_map<std::string, bool> & overridability);
 
 /// Enumerate keys paths of the config recursively.
 /// E.g. if `enumerate_paths` = {"root.key1"} and config like
@@ -67,6 +71,8 @@ void listKeys(
     std::queue<std::string> enumerate_paths,
     std::set<std::string, std::less<>> & result,
     ssize_t depth);
+
+std::optional<bool> isOverridable(const Poco::Util::AbstractConfiguration & config, const std::string & path);
 }
 
 }
diff --git a/src/Common/NamedCollections/NamedCollectionUtils.cpp b/src/Common/NamedCollections/NamedCollectionUtils.cpp
index cab844d6213d..9a28a9fc230f 100644
--- a/src/Common/NamedCollections/NamedCollectionUtils.cpp
+++ b/src/Common/NamedCollections/NamedCollectionUtils.cpp
@@ -199,6 +199,12 @@ class LoadFromSQL : private WithContext
         for (const auto & [name, value] : create_query.changes)
             result_changes_map.emplace(name, value);
 
+        std::unordered_map<std::string, bool> result_overridability_map;
+        for (const auto & [name, value] : query.overridability)
+            result_overridability_map.emplace(name, value);
+        for (const auto & [name, value] : create_query.overridability)
+            result_overridability_map.emplace(name, value);
+
         for (const auto & delete_key : query.delete_keys)
         {
             auto it = result_changes_map.find(delete_key);
@@ -210,12 +216,18 @@ class LoadFromSQL : private WithContext
                     delete_key);
             }
             else
+            {
                 result_changes_map.erase(it);
+                auto it_override = result_overridability_map.find(delete_key);
+                if (it_override != result_overridability_map.end())
+                    result_overridability_map.erase(it_override);
+            }
         }
 
         create_query.changes.clear();
         for (const auto & [name, value] : result_changes_map)
             create_query.changes.emplace_back(name, value);
+        create_query.overridability = std::move(result_overridability_map);
 
         writeCreateQueryToMetadata(
             create_query,
@@ -244,8 +256,7 @@ class LoadFromSQL : private WithContext
         const ASTCreateNamedCollectionQuery & query)
     {
         const auto & collection_name = query.collection_name;
-        const auto config = NamedCollectionConfiguration::createConfiguration(
-            collection_name, query.changes);
+        const auto config = NamedCollectionConfiguration::createConfiguration(collection_name, query.changes, query.overridability);
 
         std::set<std::string, std::less<>> keys;
         for (const auto & [name, _] : query.changes)
@@ -446,7 +457,13 @@ void updateFromSQL(const ASTAlterNamedCollectionQuery & query, ContextPtr contex
     auto collection_lock = collection->lock();
 
     for (const auto & [name, value] : query.changes)
-        collection->setOrUpdate<String, true>(name, convertFieldToString(value));
+    {
+        auto it_override = query.overridability.find(name);
+        if (it_override != query.overridability.end())
+            collection->setOrUpdate<String, true>(name, convertFieldToString(value), it_override->second);
+        else
+            collection->setOrUpdate<String, true>(name, convertFieldToString(value), {});
+    }
 
     for (const auto & key : query.delete_keys)
         collection->remove<true>(key);
diff --git a/src/Common/NamedCollections/NamedCollections.cpp b/src/Common/NamedCollections/NamedCollections.cpp
index 0a0f29a8a82f..5b377e94b21a 100644
--- a/src/Common/NamedCollections/NamedCollections.cpp
+++ b/src/Common/NamedCollections/NamedCollections.cpp
@@ -216,13 +216,22 @@ class NamedCollection::Impl
         return Configuration::getConfigValueOrDefault<T>(*config, key, &default_value);
     }
 
-    template <typename T> void set(const Key & key, const T & value, bool update_if_exists)
+    template <typename T>
+    void set(const Key & key, const T & value, bool update_if_exists, const std::optional<bool> is_overridable)
     {
-        Configuration::setConfigValue<T>(*config, key, value, update_if_exists);
+        Configuration::setConfigValue<T>(*config, key, value, update_if_exists, is_overridable);
         if (!keys.contains(key))
             keys.insert(key);
     }
 
+    bool isOverridable(const Key & key, const bool default_value)
+    {
+        const auto is_overridable = Configuration::isOverridable(*config, key);
+        if (is_overridable)
+            return *is_overridable;
+        return default_value;
+    }
+
     ImplPtr createCopy(const std::string & collection_name_) const
     {
         return create(*config, collection_name_, "", keys);
@@ -396,22 +405,30 @@ template <typename T> T NamedCollection::getAnyOrDefault(const std::initializer_
     return default_value;
 }
 
-template <typename T, bool Locked> void NamedCollection::set(const Key & key, const T & value)
+template <typename T, bool Locked>
+void NamedCollection::set(const Key & key, const T & value, const std::optional<bool> is_overridable)
 {
     assertMutable();
     std::unique_lock lock(mutex, std::defer_lock);
     if constexpr (!Locked)
         lock.lock();
-    pimpl->set<T>(key, value, false);
+    pimpl->set<T>(key, value, false, is_overridable);
 }
 
-template <typename T, bool Locked> void NamedCollection::setOrUpdate(const Key & key, const T & value)
+template <typename T, bool Locked>
+void NamedCollection::setOrUpdate(const Key & key, const T & value, const std::optional<bool> is_overridable)
 {
     assertMutable();
     std::unique_lock lock(mutex, std::defer_lock);
     if constexpr (!Locked)
         lock.lock();
-    pimpl->set<T>(key, value, true);
+    pimpl->set<T>(key, value, true, is_overridable);
+}
+
+bool NamedCollection::isOverridable(const Key & key, bool default_value) const
+{
+    std::lock_guard lock(mutex);
+    return pimpl->isOverridable(key, default_value);
 }
 
 template <bool Locked> void NamedCollection::remove(const Key & key)
@@ -499,25 +516,43 @@ template Int64 NamedCollection::getAnyOrDefault<Int64>(const std::initializer_li
 template Float64 NamedCollection::getAnyOrDefault<Float64>(const std::initializer_list<NamedCollection::Key> & key, const Float64 & default_value) const;
 template bool NamedCollection::getAnyOrDefault<bool>(const std::initializer_list<NamedCollection::Key> & key, const bool & default_value) const;
 
-template void NamedCollection::set<String, true>(const NamedCollection::Key & key, const String & value);
-template void NamedCollection::set<String, false>(const NamedCollection::Key & key, const String & value);
-template void NamedCollection::set<UInt64, true>(const NamedCollection::Key & key, const UInt64 & value);
-template void NamedCollection::set<UInt64, false>(const NamedCollection::Key & key, const UInt64 & value);
-template void NamedCollection::set<Int64, true>(const NamedCollection::Key & key, const Int64 & value);
-template void NamedCollection::set<Int64, false>(const NamedCollection::Key & key, const Int64 & value);
-template void NamedCollection::set<Float64, true>(const NamedCollection::Key & key, const Float64 & value);
-template void NamedCollection::set<Float64, false>(const NamedCollection::Key & key, const Float64 & value);
-template void NamedCollection::set<bool, false>(const NamedCollection::Key & key, const bool & value);
-
-template void NamedCollection::setOrUpdate<String, true>(const NamedCollection::Key & key, const String & value);
-template void NamedCollection::setOrUpdate<String, false>(const NamedCollection::Key & key, const String & value);
-template void NamedCollection::setOrUpdate<UInt64, true>(const NamedCollection::Key & key, const UInt64 & value);
-template void NamedCollection::setOrUpdate<UInt64, false>(const NamedCollection::Key & key, const UInt64 & value);
-template void NamedCollection::setOrUpdate<Int64, true>(const NamedCollection::Key & key, const Int64 & value);
-template void NamedCollection::setOrUpdate<Int64, false>(const NamedCollection::Key & key, const Int64 & value);
-template void NamedCollection::setOrUpdate<Float64, true>(const NamedCollection::Key & key, const Float64 & value);
-template void NamedCollection::setOrUpdate<Float64, false>(const NamedCollection::Key & key, const Float64 & value);
-template void NamedCollection::setOrUpdate<bool, false>(const NamedCollection::Key & key, const bool & value);
+template void
+NamedCollection::set<String, true>(const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<String, false>(const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<UInt64, true>(const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<UInt64, false>(const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<Int64, true>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<Int64, false>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<Float64, true>(const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<Float64, false>(const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::set<bool, false>(const NamedCollection::Key & key, const bool & value, const std::optional<bool> is_overridable);
+
+template void NamedCollection::setOrUpdate<String, true>(
+    const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);
+template void NamedCollection::setOrUpdate<String, false>(
+    const NamedCollection::Key & key, const String & value, const std::optional<bool> is_overridable);
+template void NamedCollection::setOrUpdate<UInt64, true>(
+    const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);
+template void NamedCollection::setOrUpdate<UInt64, false>(
+    const NamedCollection::Key & key, const UInt64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::setOrUpdate<Int64, true>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::setOrUpdate<Int64, false>(const NamedCollection::Key & key, const Int64 & value, const std::optional<bool> is_overridable);
+template void NamedCollection::setOrUpdate<Float64, true>(
+    const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);
+template void NamedCollection::setOrUpdate<Float64, false>(
+    const NamedCollection::Key & key, const Float64 & value, const std::optional<bool> is_overridable);
+template void
+NamedCollection::setOrUpdate<bool, false>(const NamedCollection::Key & key, const bool & value, const std::optional<bool> is_overridable);
 
 template void NamedCollection::remove<true>(const Key & key);
 template void NamedCollection::remove<false>(const Key & key);
diff --git a/src/Common/NamedCollections/NamedCollections.h b/src/Common/NamedCollections/NamedCollections.h
index 4a0f020db21b..de27f4e6083a 100644
--- a/src/Common/NamedCollections/NamedCollections.h
+++ b/src/Common/NamedCollections/NamedCollections.h
@@ -47,9 +47,13 @@ class NamedCollection
 
     std::unique_lock<std::mutex> lock();
 
-    template <typename T, bool locked = false> void set(const Key & key, const T & value);
+    template <typename T, bool locked = false>
+    void set(const Key & key, const T & value, std::optional<bool> is_overridable);
 
-    template <typename T, bool locked = false> void setOrUpdate(const Key & key, const T & value);
+    template <typename T, bool locked = false>
+    void setOrUpdate(const Key & key, const T & value, std::optional<bool> is_overridable);
+
+    bool isOverridable(const Key & key, bool default_value) const;
 
     template <bool locked = false> void remove(const Key & key);
 
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 5c41c0b08294..0c9c1d218520 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -817,6 +817,7 @@ class IColumn;
     M(Bool, create_index_ignore_unique, false, "Ignore UNIQUE keyword in CREATE UNIQUE INDEX. Made for SQL compatibility tests.", 0) \
     M(Bool, print_pretty_type_names, false, "Print pretty type names in DESCRIBE query and toTypeName() function", 0) \
     M(Bool, create_table_empty_primary_key_by_default, false, "Allow to create *MergeTree tables with empty primary key when ORDER BY and PRIMARY KEY not specified", 0) \
+    M(Bool, allow_named_collection_override_by_default, true, "Allow named collections' fields override by default.", 0)\
 
 // End of COMMON_SETTINGS
 // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS, move obsolete settings to OBSOLETE_SETTINGS and obsolete format settings to OBSOLETE_FORMAT_SETTINGS.
diff --git a/src/Parsers/ASTAlterNamedCollectionQuery.cpp b/src/Parsers/ASTAlterNamedCollectionQuery.cpp
index 6363a7306bda..c3c40c42fb73 100644
--- a/src/Parsers/ASTAlterNamedCollectionQuery.cpp
+++ b/src/Parsers/ASTAlterNamedCollectionQuery.cpp
@@ -35,6 +35,9 @@ void ASTAlterNamedCollectionQuery::formatImpl(const IAST::FormatSettings & setti
                 settings.ostr << " = " << applyVisitor(FieldVisitorToString(), change.value);
             else
                 settings.ostr << " = '[HIDDEN]'";
+            auto override_value = overridability.find(change.name);
+            if (override_value != overridability.end())
+                settings.ostr << " " << (override_value->second ? "" : "NOT ") << "OVERRIDABLE";
         }
     }
     if (!delete_keys.empty())
diff --git a/src/Parsers/ASTAlterNamedCollectionQuery.h b/src/Parsers/ASTAlterNamedCollectionQuery.h
index 36cf9c65b818..dc2670a88964 100644
--- a/src/Parsers/ASTAlterNamedCollectionQuery.h
+++ b/src/Parsers/ASTAlterNamedCollectionQuery.h
@@ -15,6 +15,7 @@ class ASTAlterNamedCollectionQuery : public IAST, public ASTQueryWithOnCluster
     SettingsChanges changes;
     std::vector<std::string> delete_keys;
     bool if_exists = false;
+    std::unordered_map<String, bool> overridability;
 
     String getID(char) const override { return "AlterNamedCollectionQuery"; }
 
diff --git a/src/Parsers/ASTCreateNamedCollectionQuery.cpp b/src/Parsers/ASTCreateNamedCollectionQuery.cpp
index 45ef8565148c..54a1022102ed 100644
--- a/src/Parsers/ASTCreateNamedCollectionQuery.cpp
+++ b/src/Parsers/ASTCreateNamedCollectionQuery.cpp
@@ -39,6 +39,9 @@ void ASTCreateNamedCollectionQuery::formatImpl(const IAST::FormatSettings & sett
             settings.ostr << " = " << applyVisitor(FieldVisitorToString(), change.value);
         else
             settings.ostr << " = '[HIDDEN]'";
+        auto override_value = overridability.find(change.name);
+        if (override_value != overridability.end())
+            settings.ostr << " " << (override_value->second ? "" : "NOT ") << "OVERRIDABLE";
     }
 }
 
diff --git a/src/Parsers/ASTCreateNamedCollectionQuery.h b/src/Parsers/ASTCreateNamedCollectionQuery.h
index 785aeb781b4b..47f2352b4cd1 100644
--- a/src/Parsers/ASTCreateNamedCollectionQuery.h
+++ b/src/Parsers/ASTCreateNamedCollectionQuery.h
@@ -14,6 +14,7 @@ class ASTCreateNamedCollectionQuery : public IAST, public ASTQueryWithOnCluster
     std::string collection_name;
     SettingsChanges changes;
     bool if_not_exists = false;
+    std::unordered_map<String, bool> overridability;
 
     String getID(char) const override { return "CreateNamedCollectionQuery"; }
 
diff --git a/src/Parsers/ParserAlterNamedCollectionQuery.cpp b/src/Parsers/ParserAlterNamedCollectionQuery.cpp
index 8fb84f86246f..9b33aa253baf 100644
--- a/src/Parsers/ParserAlterNamedCollectionQuery.cpp
+++ b/src/Parsers/ParserAlterNamedCollectionQuery.cpp
@@ -17,14 +17,16 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod
     ParserKeyword s_on("ON");
     ParserKeyword s_delete("DELETE");
     ParserIdentifier name_p;
-    ParserSetQuery set_p;
+    ParserKeyword s_set("SET");
+    ParserKeyword s_overridable("OVERRIDABLE");
+    ParserKeyword s_not_overridable("NOT OVERRIDABLE");
     ParserToken s_comma(TokenType::Comma);
 
     String cluster_str;
     bool if_exists = false;
 
     ASTPtr collection_name;
-    ASTPtr set;
+
     std::vector<std::string> delete_keys;
 
     if (!s_alter.ignore(pos, expected))
@@ -45,20 +47,27 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod
             return false;
     }
 
-    bool parsed_delete = false;
-    if (!set_p.parse(pos, set, expected))
+    SettingsChanges changes;
+    std::unordered_map<String, bool> overridability;
+    if (s_set.ignore(pos, expected))
     {
-        if (!s_delete.ignore(pos, expected))
-            return false;
+        while (true)
+        {
+            if (!changes.empty() && !s_comma.ignore(pos))
+                break;
 
-        parsed_delete = true;
-    }
-    else if (s_delete.ignore(pos, expected))
-    {
-        parsed_delete = true;
+            changes.push_back(SettingChange{});
+
+            if (!ParserSetQuery::parseNameValuePair(changes.back(), pos, expected))
+                return false;
+            if (s_not_overridable.ignore(pos, expected))
+                overridability.emplace(changes.back().name, false);
+            else if (s_overridable.ignore(pos, expected))
+                overridability.emplace(changes.back().name, true);
+        }
     }
 
-    if (parsed_delete)
+    if (s_delete.ignore(pos, expected))
     {
         while (true)
         {
@@ -78,8 +87,8 @@ bool ParserAlterNamedCollectionQuery::parseImpl(IParser::Pos & pos, ASTPtr & nod
     query->collection_name = getIdentifierName(collection_name);
     query->if_exists = if_exists;
     query->cluster = std::move(cluster_str);
-    if (set)
-        query->changes = set->as<ASTSetQuery>()->changes;
+    query->changes = changes;
+    query->overridability = std::move(overridability);
     query->delete_keys = delete_keys;
 
     node = query;
diff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp
index 760ce73cf6f0..2ef37ac3f99d 100644
--- a/src/Parsers/ParserCreateQuery.cpp
+++ b/src/Parsers/ParserCreateQuery.cpp
@@ -1517,6 +1517,8 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec
     ParserKeyword s_if_not_exists("IF NOT EXISTS");
     ParserKeyword s_on("ON");
     ParserKeyword s_as("AS");
+    ParserKeyword s_not_overridable("NOT OVERRIDABLE");
+    ParserKeyword s_overridable("OVERRIDABLE");
     ParserIdentifier name_p;
     ParserToken s_comma(TokenType::Comma);
 
@@ -1547,6 +1549,7 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec
         return false;
 
     SettingsChanges changes;
+    std::unordered_map<String, bool> overridability;
 
     while (true)
     {
@@ -1557,6 +1560,10 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec
 
         if (!ParserSetQuery::parseNameValuePair(changes.back(), pos, expected))
             return false;
+        if (s_not_overridable.ignore(pos, expected))
+            overridability.emplace(changes.back().name, false);
+        else if (s_overridable.ignore(pos, expected))
+            overridability.emplace(changes.back().name, true);
     }
 
     auto query = std::make_shared<ASTCreateNamedCollectionQuery>();
@@ -1565,6 +1572,7 @@ bool ParserCreateNamedCollectionQuery::parseImpl(Pos & pos, ASTPtr & node, Expec
     query->if_not_exists = if_not_exists;
     query->changes = changes;
     query->cluster = std::move(cluster_str);
+    query->overridability = overridability;
 
     node = query;
     return true;
diff --git a/src/Storages/NamedCollectionsHelpers.cpp b/src/Storages/NamedCollectionsHelpers.cpp
index f301cca92a13..8124ba651f93 100644
--- a/src/Storages/NamedCollectionsHelpers.cpp
+++ b/src/Storages/NamedCollectionsHelpers.cpp
@@ -92,14 +92,23 @@ MutableNamedCollectionPtr tryGetNamedCollectionWithOverrides(
     if (asts.size() == 1)
         return collection_copy;
 
+    const auto allow_override_by_default = context->getSettings().allow_named_collection_override_by_default;
+
     for (auto * it = std::next(asts.begin()); it != asts.end(); ++it)
     {
         auto value_override = getKeyValueFromAST(*it, /* fallback_to_ast_value */complex_args != nullptr, context);
 
-        if (!value_override && !(*it)->as<ASTFunction>())
-            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Expected key-value argument or function");
         if (!value_override)
-            continue;
+        {
+            if (!(*it)->as<ASTFunction>())
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Expected key-value argument or function");
+            if (allow_override_by_default)
+                continue;
+            // if allow_override_by_default is false we don't allow extra arguments
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Override not allowed");
+        }
+        else if (!collection_copy->isOverridable(value_override->first, allow_override_by_default))
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Override not allowed for '{}'", value_override->first);
 
         if (const ASTPtr * value = std::get_if<ASTPtr>(&value_override->second))
         {
@@ -108,7 +117,7 @@ MutableNamedCollectionPtr tryGetNamedCollectionWithOverrides(
         }
 
         const auto & [key, value] = *value_override;
-        collection_copy->setOrUpdate<String>(key, toString(std::get<Field>(value_override->second)));
+        collection_copy->setOrUpdate<String>(key, toString(std::get<Field>(value)), {});
     }
 
     return collection_copy;
@@ -128,8 +137,14 @@ MutableNamedCollectionPtr tryGetNamedCollectionWithOverrides(
 
     Poco::Util::AbstractConfiguration::Keys keys;
     config.keys(config_prefix, keys);
+    const auto allow_override_by_default = context->getSettings().allow_named_collection_override_by_default;
     for (const auto & key : keys)
-        collection_copy->setOrUpdate<String>(key, config.getString(config_prefix + '.' + key));
+    {
+        if (collection_copy->isOverridable(key, allow_override_by_default))
+            collection_copy->setOrUpdate<String>(key, config.getString(config_prefix + '.' + key), {});
+        else
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Override not allowed for '{}'", key);
+    }
 
     return collection_copy;
 }
