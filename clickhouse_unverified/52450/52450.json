{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52450,
  "instance_id": "ClickHouse__ClickHouse-52450",
  "issue_numbers": [
    "52407"
  ],
  "base_commit": "fb045b0d862ea7dd61d116e757e183ada44f37de",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 36f40b372380..c2bd525c4835 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -945,44 +945,6 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## toDecimalString\n-\n-Converts a numeric value to String with the number of fractional digits in the output specified by the user.\n-\n-**Syntax**\n-\n-``` sql\n-toDecimalString(number, scale)\n-```\n-\n-**Parameters**\n-\n-- `number` \u2014 Value to be represented as String, [Int, UInt](/docs/en/sql-reference/data-types/int-uint.md), [Float](/docs/en/sql-reference/data-types/float.md), [Decimal](/docs/en/sql-reference/data-types/decimal.md),\n-- `scale` \u2014 Number of fractional digits, [UInt8](/docs/en/sql-reference/data-types/int-uint.md).\n-    * Maximum scale for [Decimal](/docs/en/sql-reference/data-types/decimal.md) and [Int, UInt](/docs/en/sql-reference/data-types/int-uint.md) types is 77 (it is the maximum possible number of significant digits for Decimal),\n-    * Maximum scale for [Float](/docs/en/sql-reference/data-types/float.md) is 60.\n-\n-**Returned value**\n-\n-- Input value represented as [String](/docs/en/sql-reference/data-types/string.md) with given number of fractional digits (scale).\n-    The number is rounded up or down according to common arithmetic in case requested scale is smaller than original number's scale.\n-\n-**Example**\n-\n-Query:\n-\n-``` sql\n-SELECT toDecimalString(CAST('64.32', 'Float64'), 5);\n-```\n-\n-Result:\n-\n-```response\n-\u250ctoDecimalString(CAST('64.32', 'Float64'), 5)\u2500\u2510\n-\u2502 64.32000                                    \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n ## reinterpretAsUInt(8\\|16\\|32\\|64)\n \n ## reinterpretAsInt(8\\|16\\|32\\|64)\ndiff --git a/docs/ru/sql-reference/functions/type-conversion-functions.md b/docs/ru/sql-reference/functions/type-conversion-functions.md\nindex e53104d8d712..088b1a9a1f12 100644\n--- a/docs/ru/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/ru/sql-reference/functions/type-conversion-functions.md\n@@ -762,44 +762,6 @@ SELECT toFixedString('foo\\0bar', 8) AS s, toStringCutToZero(s) AS s_cut;\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-## toDecimalString\n-\n-\u041f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u043b\u044e\u0431\u043e\u0439 \u0447\u0438\u0441\u043b\u0435\u043d\u043d\u044b\u0439 \u0442\u0438\u043f \u043f\u0435\u0440\u0432\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c, \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0441\u0442\u0440\u043e\u043a\u043e\u0432\u043e\u0435 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0447\u0438\u0441\u043b\u0430 \u0441 \u0442\u043e\u0447\u043d\u043e\u0441\u0442\u044c\u044e, \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0432\u0442\u043e\u0440\u044b\u043c \u0430\u0440\u0433\u0443\u043c\u0435\u043d\u0442\u043e\u043c.\n-\n-**\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n-\n-``` sql\n-toDecimalString(number, scale)\n-```\n-\n-**\u041f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n-\n--   `number` \u2014 \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043b\u044e\u0431\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0433\u043e \u0442\u0438\u043f\u0430: [Int, UInt](/docs/ru/sql-reference/data-types/int-uint.md), [Float](/docs/ru/sql-reference/data-types/float.md), [Decimal](/docs/ru/sql-reference/data-types/decimal.md),\n--   `scale` \u2014 \u0422\u0440\u0435\u0431\u0443\u0435\u043c\u043e\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u044b\u0445 \u0437\u043d\u0430\u043a\u043e\u0432 \u043f\u043e\u0441\u043b\u0435 \u0437\u0430\u043f\u044f\u0442\u043e\u0439, [UInt8](/docs/ru/sql-reference/data-types/int-uint.md).\n-    * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `scale` \u0434\u043b\u044f \u0442\u0438\u043f\u043e\u0432 [Decimal](/docs/ru/sql-reference/data-types/decimal.md) \u0438 [Int, UInt](/docs/ru/sql-reference/data-types/int-uint.md) \u0434\u043e\u043b\u0436\u043d\u043e \u043d\u0435 \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0442\u044c 77 (\u0442\u0430\u043a \u043a\u0430\u043a \u044d\u0442\u043e \u043d\u0430\u0438\u0431\u043e\u043b\u044c\u0448\u0435\u0435 \u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0437\u043d\u0430\u0447\u0438\u043c\u044b\u0445 \u0441\u0438\u043c\u0432\u043e\u043b\u043e\u0432 \u0434\u043b\u044f \u044d\u0442\u0438\u0445 \u0442\u0438\u043f\u043e\u0432),\n-    * \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 `scale` \u0434\u043b\u044f \u0442\u0438\u043f\u0430 [Float](/docs/ru/sql-reference/data-types/float.md) \u043d\u0435 \u0434\u043e\u043b\u0436\u043d\u043e \u043f\u0440\u0435\u0432\u044b\u0448\u0430\u0442\u044c 60.\n-\n-**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n-\n--   \u0421\u0442\u0440\u043e\u043a\u0430 ([String](/docs/en/sql-reference/data-types/string.md)), \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u044f\u044e\u0449\u0430\u044f \u0441\u043e\u0431\u043e\u0439 \u0434\u0435\u0441\u044f\u0442\u0438\u0447\u043d\u043e\u0435 \u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432\u0445\u043e\u0434\u043d\u043e\u0433\u043e \u0447\u0438\u0441\u043b\u0430 \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u043e\u0439 \u0434\u043b\u0438\u043d\u043e\u0439 \u0434\u0440\u043e\u0431\u043d\u043e\u0439 \u0447\u0430\u0441\u0442\u0438.\n-    \u041f\u0440\u0438 \u043d\u0435\u043e\u0431\u0445\u043e\u0434\u0438\u043c\u043e\u0441\u0442\u0438 \u0447\u0438\u0441\u043b\u043e \u043e\u043a\u0440\u0443\u0433\u043b\u044f\u0435\u0442\u0441\u044f \u043f\u043e \u0441\u0442\u0430\u043d\u0434\u0430\u0440\u0442\u043d\u044b\u043c \u043f\u0440\u0430\u0432\u0438\u043b\u0430\u043c \u0430\u0440\u0438\u0444\u043c\u0435\u0442\u0438\u043a\u0438.\n-\n-**\u041f\u0440\u0438\u043c\u0435\u0440 \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f**\n-\n-\u0417\u0430\u043f\u0440\u043e\u0441:\n-\n-``` sql\n-SELECT toDecimalString(CAST('64.32', 'Float64'), 5);\n-```\n-\n-\u0420\u0435\u0437\u0443\u043b\u044c\u0442\u0430\u0442:\n-\n-```response\n-\u250c\u2500toDecimalString(CAST('64.32', 'Float64'), 5)\u2510\n-\u2502 64.32000                                    \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n-```\n-\n ## reinterpretAsUInt(8\\|16\\|32\\|64) {#reinterpretasuint8163264}\n \n ## reinterpretAsInt(8\\|16\\|32\\|64) {#reinterpretasint8163264}\ndiff --git a/src/Functions/FunctionToDecimalString.cpp b/src/Functions/FunctionToDecimalString.cpp\ndeleted file mode 100644\nindex fe417b191373..000000000000\n--- a/src/Functions/FunctionToDecimalString.cpp\n+++ /dev/null\n@@ -1,22 +0,0 @@\n-#include <Functions/FunctionFactory.h>\n-#include <Functions/FunctionToDecimalString.h>\n-#include <Functions/IFunction.h>\n-\n-namespace DB\n-{\n-\n-REGISTER_FUNCTION(ToDecimalString)\n-{\n-    factory.registerFunction<FunctionToDecimalString>(\n-        FunctionDocumentation{\n-            .description=R\"(\n-Returns string representation of a number. First argument is the number of any numeric type,\n-second argument is the desired number of digits in fractional part. Returns String.\n-\n-        )\",\n-            .examples{{\"toDecimalString\", \"SELECT toDecimalString(2.1456,2)\", \"\"}},\n-            .categories{\"String\"}\n-        }, FunctionFactory::CaseInsensitive);\n-}\n-\n-}\ndiff --git a/src/Functions/FunctionToDecimalString.h b/src/Functions/FunctionToDecimalString.h\ndeleted file mode 100644\nindex 6ae007e6b665..000000000000\n--- a/src/Functions/FunctionToDecimalString.h\n+++ /dev/null\n@@ -1,312 +0,0 @@\n-#pragma once\n-\n-#include <Core/Types.h>\n-#include <Core/DecimalFunctions.h>\n-#include <Functions/IFunction.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <Columns/ColumnsNumber.h>\n-#include <Columns/ColumnString.h>\n-#include <Columns/ColumnVector.h>\n-#include <Columns/ColumnDecimal.h>\n-#include <DataTypes/DataTypeString.h>\n-#include <DataTypes/DataTypesNumber.h>\n-#include <IO/WriteBufferFromVector.h>\n-#include <IO/WriteHelpers.h>\n-#include <Interpreters/Context_fwd.h>\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER;\n-}\n-\n-class FunctionToDecimalString : public IFunction\n-{\n-public:\n-    static constexpr auto name = \"toDecimalString\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToDecimalString>(); }\n-\n-    String getName() const override { return name; }\n-\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-\n-    size_t getNumberOfArguments() const override { return 2; }\n-\n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n-    {\n-        if (!isNumber(*arguments[0]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"Illegal first argument for formatDecimal function: got {}, expected numeric type\",\n-                            arguments[0]->getName());\n-\n-        if (!isUInt8(*arguments[1]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                            \"Illegal second argument for formatDecimal function: got {}, expected UInt8\",\n-                            arguments[1]->getName());\n-\n-        return std::make_shared<DataTypeString>();\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-private:\n-    /// For operations with Integer/Float\n-    template <typename FromVectorType>\n-    void vectorConstant(const FromVectorType & vec_from, UInt8 precision,\n-                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets) const\n-    {\n-        size_t input_rows_count = vec_from.size();\n-        result_offsets.resize(input_rows_count);\n-\n-        /// Buffer is used here and in functions below because resulting size cannot be precisely anticipated,\n-        /// and buffer resizes on-the-go. Also, .count() provided by buffer is convenient in this case.\n-        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n-\n-        for (size_t i = 0; i < input_rows_count; ++i)\n-        {\n-            format(vec_from[i], buf_to, precision);\n-            result_offsets[i] = buf_to.count();\n-        }\n-\n-        buf_to.finalize();\n-    }\n-\n-    template <typename FirstArgVectorType>\n-    void vectorVector(const FirstArgVectorType & vec_from, const ColumnVector<UInt8>::Container & vec_precision,\n-                      ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets) const\n-    {\n-        size_t input_rows_count = vec_from.size();\n-        result_offsets.resize(input_rows_count);\n-\n-        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n-\n-        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n-\n-        for (size_t i = 0; i < input_rows_count; ++i)\n-        {\n-            if (vec_precision[i] > max_digits)\n-                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                    \"Too many fractional digits requested, shall not be more than {}\", max_digits);\n-            format(vec_from[i], buf_to, vec_precision[i]);\n-            result_offsets[i] = buf_to.count();\n-        }\n-\n-        buf_to.finalize();\n-    }\n-\n-    template <typename FirstArgType>\n-    void constantVector(const FirstArgType & value_from, const ColumnVector<UInt8>::Container & vec_precision,\n-                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets) const\n-    {\n-        size_t input_rows_count = vec_precision.size();\n-        result_offsets.resize(input_rows_count);\n-\n-        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n-\n-        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n-\n-        for (size_t i = 0; i < input_rows_count; ++i)\n-        {\n-            if (vec_precision[i] > max_digits)\n-                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                    \"Too many fractional digits requested, shall not be more than {}\", max_digits);\n-            format(value_from, buf_to, vec_precision[i]);\n-            result_offsets[i] = buf_to.count();\n-        }\n-\n-        buf_to.finalize();\n-    }\n-\n-    /// For operations with Decimal\n-    template <typename FirstArgVectorType>\n-    void vectorConstant(const FirstArgVectorType & vec_from, UInt8 precision,\n-                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets, UInt8 from_scale) const\n-    {\n-        /// There are no more than 77 meaning digits (as it is the max length of UInt256). So we can limit it with 77.\n-        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n-        if (precision > max_digits)\n-            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                \"Too many fractional digits requested for Decimal, must not be more than {}\", max_digits);\n-\n-        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n-        size_t input_rows_count = vec_from.size();\n-        result_offsets.resize(input_rows_count);\n-\n-        for (size_t i = 0; i < input_rows_count; ++i)\n-        {\n-            writeText(vec_from[i], from_scale, buf_to, true, true, precision);\n-            writeChar(0, buf_to);\n-            result_offsets[i] = buf_to.count();\n-        }\n-        buf_to.finalize();\n-    }\n-\n-    template <typename FirstArgVectorType>\n-    void vectorVector(const FirstArgVectorType & vec_from, const ColumnVector<UInt8>::Container & vec_precision,\n-                      ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets, UInt8 from_scale) const\n-    {\n-        size_t input_rows_count = vec_from.size();\n-        result_offsets.resize(input_rows_count);\n-\n-        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n-\n-        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n-\n-        for (size_t i = 0; i < input_rows_count; ++i)\n-        {\n-            if (vec_precision[i] > max_digits)\n-                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                    \"Too many fractional digits requested for Decimal, must not be more than {}\", max_digits);\n-            writeText(vec_from[i], from_scale, buf_to, true, true, vec_precision[i]);\n-            writeChar(0, buf_to);\n-            result_offsets[i] = buf_to.count();\n-        }\n-        buf_to.finalize();\n-    }\n-\n-    template <typename FirstArgType>\n-    void constantVector(const FirstArgType & value_from, const ColumnVector<UInt8>::Container & vec_precision,\n-                        ColumnString::Chars & vec_to, ColumnString::Offsets & result_offsets, UInt8 from_scale) const\n-    {\n-        size_t input_rows_count = vec_precision.size();\n-        result_offsets.resize(input_rows_count);\n-\n-        WriteBufferFromVector<ColumnString::Chars> buf_to(vec_to);\n-\n-        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n-\n-        for (size_t i = 0; i < input_rows_count; ++i)\n-        {\n-            if (vec_precision[i] > max_digits)\n-                throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                    \"Too many fractional digits requested for Decimal, must not be more than {}\", max_digits);\n-            writeText(value_from, from_scale, buf_to, true, true, vec_precision[i]);\n-            writeChar(0, buf_to);\n-            result_offsets[i] = buf_to.count();\n-        }\n-        buf_to.finalize();\n-    }\n-\n-    template <is_floating_point T>\n-    static void format(T value, DB::WriteBuffer & out, UInt8 precision)\n-    {\n-        /// Maximum of 60 is hard-coded in 'double-conversion/double-conversion.h' for floating point values,\n-        /// Catch this here to give user a more reasonable error.\n-        if (precision > 60)\n-            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                \"Too high precision requested for Float, must not be more than 60, got {}\", Int8(precision));\n-\n-        DB::DoubleConverter<false>::BufferType buffer;\n-        double_conversion::StringBuilder builder{buffer, sizeof(buffer)};\n-\n-        const auto result = DB::DoubleConverter<false>::instance().ToFixed(value, precision, &builder);\n-\n-        if (!result)\n-            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER, \"Error processing number: {}\", value);\n-\n-        out.write(buffer, builder.position());\n-        writeChar(0, out);\n-    }\n-\n-    template <is_integer T>\n-    static void format(T value, DB::WriteBuffer & out, UInt8 precision)\n-    {\n-        /// Fractional part for Integer is just trailing zeros. Let's limit it with 77 (like with Decimals).\n-        constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n-        if (precision > max_digits)\n-            throw DB::Exception(DB::ErrorCodes::CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER,\n-                                \"Too many fractional digits requested, shall not be more than {}\", max_digits);\n-        writeText(value, out);\n-        if (precision > 0) [[likely]]\n-        {\n-            writeChar('.', out);\n-            for (int i = 0; i < precision; ++i)\n-                writeChar('0', out);\n-            writeChar(0, out);\n-        }\n-    }\n-\n-public:\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n-    {\n-        switch (arguments[0].type->getTypeId())\n-        {\n-            case TypeIndex::UInt8:      return executeType<UInt8>(arguments);\n-            case TypeIndex::UInt16:     return executeType<UInt16>(arguments);\n-            case TypeIndex::UInt32:     return executeType<UInt32>(arguments);\n-            case TypeIndex::UInt64:     return executeType<UInt64>(arguments);\n-            case TypeIndex::UInt128:    return executeType<UInt128>(arguments);\n-            case TypeIndex::UInt256:    return executeType<UInt256>(arguments);\n-            case TypeIndex::Int8:       return executeType<Int8>(arguments);\n-            case TypeIndex::Int16:      return executeType<Int16>(arguments);\n-            case TypeIndex::Int32:      return executeType<Int32>(arguments);\n-            case TypeIndex::Int64:      return executeType<Int64>(arguments);\n-            case TypeIndex::Int128:     return executeType<Int128>(arguments);\n-            case TypeIndex::Int256:     return executeType<Int256>(arguments);\n-            case TypeIndex::Float32:    return executeType<Float32>(arguments);\n-            case TypeIndex::Float64:    return executeType<Float64>(arguments);\n-            case TypeIndex::Decimal32:  return executeType<Decimal32>(arguments);\n-            case TypeIndex::Decimal64:  return executeType<Decimal64>(arguments);\n-            case TypeIndex::Decimal128: return executeType<Decimal128>(arguments);\n-            case TypeIndex::Decimal256: return executeType<Decimal256>(arguments);\n-            default:\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\",\n-                                arguments[0].column->getName(), getName());\n-        }\n-    }\n-\n-private:\n-    template <typename T>\n-    ColumnPtr executeType(const ColumnsWithTypeAndName & arguments) const\n-    {\n-        const auto * from_col_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n-        const auto * precision_col = checkAndGetColumn<ColumnVector<UInt8>>(arguments[1].column.get());\n-        const auto * precision_col_const = typeid_cast<const ColumnConst *>(arguments[1].column.get());\n-\n-        auto result_col = ColumnString::create();\n-        auto * result_col_string = assert_cast<ColumnString *>(result_col.get());\n-        ColumnString::Chars & result_chars = result_col_string->getChars();\n-        ColumnString::Offsets & result_offsets = result_col_string->getOffsets();\n-\n-        if constexpr (is_decimal<T>)\n-        {\n-            const auto * from_col = checkAndGetColumn<ColumnDecimal<T>>(arguments[0].column.get());\n-            UInt8 from_scale = from_col->getScale();\n-\n-            if (from_col)\n-            {\n-                if (precision_col_const)\n-                    vectorConstant(from_col->getData(), precision_col_const->template getValue<UInt8>(), result_chars, result_offsets, from_scale);\n-                else\n-                    vectorVector(from_col->getData(), precision_col->getData(), result_chars, result_offsets, from_scale);\n-            }\n-            else if (from_col_const)\n-                constantVector(from_col_const->template getValue<T>(), precision_col->getData(), result_chars, result_offsets, from_scale);\n-            else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function formatDecimal\", arguments[0].column->getName());\n-        }\n-        else\n-        {\n-            const auto * from_col = checkAndGetColumn<ColumnVector<T>>(arguments[0].column.get());\n-            if (from_col)\n-            {\n-                if (precision_col_const)\n-                    vectorConstant(from_col->getData(), precision_col_const->template getValue<UInt8>(), result_chars, result_offsets);\n-                else\n-                    vectorVector(from_col->getData(), precision_col->getData(), result_chars, result_offsets);\n-            }\n-            else if (from_col_const)\n-                constantVector(from_col_const->template getValue<T>(), precision_col->getData(), result_chars, result_offsets);\n-            else\n-                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of first argument of function formatDecimal\", arguments[0].column->getName());\n-        }\n-\n-        return result_col;\n-    }\n-};\n-\n-}\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex aa4c9b17e481..76778543bd0a 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -905,26 +905,26 @@ inline void writeText(const IPv4 & x, WriteBuffer & buf) { writeIPv4Text(x, buf)\n inline void writeText(const IPv6 & x, WriteBuffer & buf) { writeIPv6Text(x, buf); }\n \n template <typename T>\n-void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros,\n-                            bool fixed_fractional_length, UInt32 fractional_length)\n+void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)\n {\n     /// If it's big integer, but the number of digits is small,\n     /// use the implementation for smaller integers for more efficient arithmetic.\n+\n     if constexpr (std::is_same_v<T, Int256>)\n     {\n         if (x <= std::numeric_limits<UInt32>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n+            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros);\n             return;\n         }\n         else if (x <= std::numeric_limits<UInt64>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n+            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros);\n             return;\n         }\n         else if (x <= std::numeric_limits<UInt128>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt128>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n+            writeDecimalFractional(static_cast<UInt128>(x), scale, ostr, trailing_zeros);\n             return;\n         }\n     }\n@@ -932,36 +932,24 @@ void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool\n     {\n         if (x <= std::numeric_limits<UInt32>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n+            writeDecimalFractional(static_cast<UInt32>(x), scale, ostr, trailing_zeros);\n             return;\n         }\n         else if (x <= std::numeric_limits<UInt64>::max())\n         {\n-            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n+            writeDecimalFractional(static_cast<UInt64>(x), scale, ostr, trailing_zeros);\n             return;\n         }\n     }\n \n     constexpr size_t max_digits = std::numeric_limits<UInt256>::digits10;\n     assert(scale <= max_digits);\n-    assert(fractional_length <= max_digits);\n-\n     char buf[max_digits];\n-    memset(buf, '0', std::max(scale, fractional_length));\n+    memset(buf, '0', scale);\n \n     T value = x;\n     Int32 last_nonzero_pos = 0;\n-\n-    if (fixed_fractional_length && fractional_length < scale)\n-    {\n-        T new_value = value / DecimalUtils::scaleMultiplier<Int256>(scale - fractional_length - 1);\n-        auto round_carry = new_value % 10;\n-        value = new_value / 10;\n-        if (round_carry >= 5)\n-            value += 1;\n-    }\n-\n-    for (Int32 pos = fixed_fractional_length ? std::min(scale - 1, fractional_length - 1) : scale - 1; pos >= 0; --pos)\n+    for (Int32 pos = scale - 1; pos >= 0; --pos)\n     {\n         auto remainder = value % 10;\n         value /= 10;\n@@ -973,12 +961,11 @@ void writeDecimalFractional(const T & x, UInt32 scale, WriteBuffer & ostr, bool\n     }\n \n     writeChar('.', ostr);\n-    ostr.write(buf, fixed_fractional_length ? fractional_length : (trailing_zeros ? scale : last_nonzero_pos + 1));\n+    ostr.write(buf, trailing_zeros ? scale : last_nonzero_pos + 1);\n }\n \n template <typename T>\n-void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros,\n-               bool fixed_fractional_length = false, UInt32 fractional_length = 0)\n+void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zeros)\n {\n     T part = DecimalUtils::getWholePart(x, scale);\n \n@@ -989,7 +976,7 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zer\n \n     writeIntText(part, ostr);\n \n-    if (scale || (fixed_fractional_length && fractional_length > 0))\n+    if (scale)\n     {\n         part = DecimalUtils::getFractionalPart(x, scale);\n         if (part || trailing_zeros)\n@@ -997,7 +984,7 @@ void writeText(Decimal<T> x, UInt32 scale, WriteBuffer & ostr, bool trailing_zer\n             if (part < 0)\n                 part *= T(-1);\n \n-            writeDecimalFractional(part, scale, ostr, trailing_zeros, fixed_fractional_length, fractional_length);\n+            writeDecimalFractional(part, scale, ostr, trailing_zeros);\n         }\n     }\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02676_to_decimal_string.reference b/tests/queries/0_stateless/02676_to_decimal_string.reference\ndeleted file mode 100644\nindex 4c27ee5b5286..000000000000\n--- a/tests/queries/0_stateless/02676_to_decimal_string.reference\n+++ /dev/null\n@@ -1,21 +0,0 @@\n-2.00000000000000000000000000000000000000000000000000000000000000000000000000000\n-2.12\n--2.00000000000000000000000000000000000000000000000000000000000000000000000000000\n--2.12\n-2.987600000000000033395508580724708735942840576171875000000000\n-2.15\n--2.987600000000000033395508580724708735942840576171875000000000\n--2.15\n-64.1230010986\n-64.2340000000\n--64.1230010986\n--64.2340000000\n--32.345\n-32.34500000000000000000000000000000000000000000000000000000000000000000000000000\n-32.46\n--64.5671232345\n-128.78932312332132985464\n--128.78932312332132985464\n-128.78932312332132985464000000000000000000000000000000000000000000000000000000000\n-128.7893231233\n--128.78932312332132985464123123789323123321329854600000000000000000000000000000000\ndiff --git a/tests/queries/0_stateless/02676_to_decimal_string.sql b/tests/queries/0_stateless/02676_to_decimal_string.sql\ndeleted file mode 100644\nindex 563d60c62c7e..000000000000\n--- a/tests/queries/0_stateless/02676_to_decimal_string.sql\n+++ /dev/null\n@@ -1,35 +0,0 @@\n--- Regular types\n-SELECT toDecimalString(2, 77);  -- more digits required than exist\n-SELECT toDecimalString(2.123456, 2);  -- rounding\n-SELECT toDecimalString(-2, 77);  -- more digits required than exist\n-SELECT toDecimalString(-2.123456, 2);  -- rounding\n-\n-SELECT toDecimalString(2.9876, 60);  -- more digits required than exist (took 60 as it is float by default)\n-SELECT toDecimalString(2.1456, 2);  -- rounding\n-SELECT toDecimalString(-2.9876, 60);  -- more digits required than exist\n-SELECT toDecimalString(-2.1456, 2);  -- rounding\n-\n--- Float32 and Float64 tests. No sense to test big float precision -- the result will be a mess anyway.\n-SELECT toDecimalString(64.123::Float32, 10);\n-SELECT toDecimalString(64.234::Float64, 10);\n-SELECT toDecimalString(-64.123::Float32, 10);\n-SELECT toDecimalString(-64.234::Float64, 10);\n-\n--- Decimals\n-SELECT toDecimalString(-32.345::Decimal32(3), 3);\n-SELECT toDecimalString(32.345::Decimal32(3), 77);  -- more digits required than exist\n-SELECT toDecimalString(32.456::Decimal32(3), 2);  -- rounding\n-SELECT toDecimalString('-64.5671232345'::Decimal64(10), 10);\n-SELECT toDecimalString('128.78932312332132985464'::Decimal128(20), 20);\n-SELECT toDecimalString('-128.78932312332132985464123123'::Decimal128(26), 20);  -- rounding\n-SELECT toDecimalString('128.78932312332132985464'::Decimal128(20), 77);  -- more digits required than exist\n-SELECT toDecimalString('128.789323123321329854641231237893231233213298546'::Decimal256(45), 10);  -- rounding\n-SELECT toDecimalString('-128.789323123321329854641231237893231233213298546'::Decimal256(45), 77);  -- more digits required than exist\n-\n--- Max number of decimal fractional digits is defined as 77 for Int/UInt/Decimal and 60 for Float.\n--- These values shall work OK.\n-SELECT toDecimalString('32.32'::Float32, 61); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n-SELECT toDecimalString('64.64'::Float64, 61); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n-SELECT toDecimalString('88'::UInt8, 78); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n-SELECT toDecimalString('646464'::Int256, 78); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n-SELECT toDecimalString('-128.789323123321329854641231237893231233213298546'::Decimal256(45), 78); -- {serverError CANNOT_PRINT_FLOAT_OR_DOUBLE_NUMBER}\n",
  "problem_statement": "ClickHouse Server 23.7.1.1659 crashed through a SELECT statement calling the toDecimalString function\n**Describe the bug**\r\nClickHouse Server 23.7.1.1659 crashed through a SELECT statement calling the toDecimalString function.\r\n\r\n**How to reproduce**\r\nThe SQL statement to reproduce:\r\n```sql\r\nSELECT toDecimalString ( '110' :: Decimal256 ( 45 ) , * ) ;\r\n```\r\nIt can be reproduced on the official docker image. (`clickhouse/clickhouse-server:head` and `clickhouse/clickhouse-server:latest`).\r\n\r\nThe log traced by ClickHouse Server:\r\n```\r\nSELECT toDecimalString(CAST('110', 'Decimal256(45)'), *)\r\n\r\nQuery id: aa30d1a0-9002-4fab-9243-887e9b9af1cc\r\n\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617202 [ 333 ] <Fatal> BaseDaemon: ########################################\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617283 [ 333 ] <Fatal> BaseDaemon: (version 23.7.1.1659 (official build), build id: 2A82CED3B49248890AFC97BDD6FE0D5C0590676F, git hash: 234b5047b5cd093b8950bb8de3725eacffe02dc0) (from thread 48) (query_id: aa30d1a0-9002-4fab-9243-887e9b9af1cc) (query: SELECT toDecimalString ( '110' :: Decimal256 ( 45 ) , * ) ;) Received signal Segmentation fault (11)\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617329 [ 333 ] <Fatal> BaseDaemon: Address: 0x28. Access: read. Address not mapped to object.\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617369 [ 333 ] <Fatal> BaseDaemon: Stack trace: 0x000000000907fdd0 0x0000000008cf1a6a 0x0000000008cf100e 0x0000000012c2f22f 0x0000000012c2fca2 0x0000000012c30f99 0x00000000133c0fcc 0x000000001515b224 0x00000000152aed8e 0x0000000013cf35c7 0x0000000013ce2d8a 0x0000000013ce0514 0x0000000013d7e936 0x0000000013d7f844 0x00000000140b2825 0x00000000140ae68e 0x0000000014ed69c4 0x0000000014eedc79 0x0000000017e7a154 0x0000000017e7b371 0x0000000017ffd207 0x0000000017ffac3c 0x00007fd6b78f7609 0x00007fd6b781c133\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617462 [ 333 ] <Fatal> BaseDaemon: 2. ? @ 0x000000000907fdd0 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617514 [ 333 ] <Fatal> BaseDaemon: 3. ? @ 0x0000000008cf1a6a in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617552 [ 333 ] <Fatal> BaseDaemon: 4. ? @ 0x0000000008cf100e in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617623 [ 333 ] <Fatal> BaseDaemon: 5. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000012c2f22f in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617678 [ 333 ] <Fatal> BaseDaemon: 6. DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000012c2fca2 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617737 [ 333 ] <Fatal> BaseDaemon: 7. DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x0000000012c30f99 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617797 [ 333 ] <Fatal> BaseDaemon: 8. DB::ActionsDAG::updateHeader(DB::Block) const @ 0x00000000133c0fcc in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617837 [ 333 ] <Fatal> BaseDaemon: 9. DB::ExpressionTransform::transformHeader(DB::Block, DB::ActionsDAG const&) @ 0x000000001515b224 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617894 [ 333 ] <Fatal> BaseDaemon: 10. DB::ExpressionStep::ExpressionStep(DB::DataStream const&, std::shared_ptr<DB::ActionsDAG> const&) @ 0x00000000152aed8e in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617940 [ 333 ] <Fatal> BaseDaemon: 11. DB::InterpreterSelectQuery::executeExpression(DB::QueryPlan&, std::shared_ptr<DB::ActionsDAG> const&, String const&) @ 0x0000000013cf35c7 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.617983 [ 333 ] <Fatal> BaseDaemon: 12. DB::InterpreterSelectQuery::executeImpl(DB::QueryPlan&, std::optional<DB::Pipe>) @ 0x0000000013ce2d8a in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618030 [ 333 ] <Fatal> BaseDaemon: 13. DB::InterpreterSelectQuery::buildQueryPlan(DB::QueryPlan&) @ 0x0000000013ce0514 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618110 [ 333 ] <Fatal> BaseDaemon: 14. DB::InterpreterSelectWithUnionQuery::buildQueryPlan(DB::QueryPlan&) @ 0x0000000013d7e936 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618155 [ 333 ] <Fatal> BaseDaemon: 15. DB::InterpreterSelectWithUnionQuery::execute() @ 0x0000000013d7f844 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618199 [ 333 ] <Fatal> BaseDaemon: 16. ? @ 0x00000000140b2825 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618251 [ 333 ] <Fatal> BaseDaemon: 17. DB::executeQuery(String const&, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x00000000140ae68e in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618294 [ 333 ] <Fatal> BaseDaemon: 18. DB::TCPHandler::runImpl() @ 0x0000000014ed69c4 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618324 [ 333 ] <Fatal> BaseDaemon: 19. DB::TCPHandler::run() @ 0x0000000014eedc79 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618378 [ 333 ] <Fatal> BaseDaemon: 20. Poco::Net::TCPServerConnection::start() @ 0x0000000017e7a154 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618434 [ 333 ] <Fatal> BaseDaemon: 21. Poco::Net::TCPServerDispatcher::run() @ 0x0000000017e7b371 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618484 [ 333 ] <Fatal> BaseDaemon: 22. Poco::PooledThread::run() @ 0x0000000017ffd207 in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618528 [ 333 ] <Fatal> BaseDaemon: 23. Poco::ThreadImpl::runnableEntry(void*) @ 0x0000000017ffac3c in /usr/bin/clickhouse\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618560 [ 333 ] <Fatal> BaseDaemon: 24. ? @ 0x00007fd6b78f7609 in ?\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.618609 [ 333 ] <Fatal> BaseDaemon: 25. clone @ 0x00007fd6b781c133 in ?\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.908820 [ 333 ] <Fatal> BaseDaemon: Integrity check of the executable successfully passed (checksum: 7D28AF63E0E09B75DF5876280E0C8DBB)\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.909276 [ 333 ] <Fatal> BaseDaemon: Report this error to https://github.com/ClickHouse/ClickHouse/issues\r\n[25b36a6e4a9c] 2023.07.21 10:04:17.909468 [ 333 ] <Fatal> BaseDaemon: No settings were changed\r\n```\n",
  "hints_text": "@zvonand, this is the offender: https://github.com/ClickHouse/ClickHouse/pull/47838\r\nWe must fix it immediately or get rid of this function.",
  "created_at": "2023-07-22T02:55:42Z",
  "modified_files": [
    "docs/en/sql-reference/functions/type-conversion-functions.md",
    "docs/ru/sql-reference/functions/type-conversion-functions.md",
    "src/Functions/FunctionToDecimalString.cpp",
    "src/Functions/FunctionToDecimalString.h",
    "src/IO/WriteHelpers.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02676_to_decimal_string.reference",
    "tests/queries/0_stateless/02676_to_decimal_string.sql"
  ]
}