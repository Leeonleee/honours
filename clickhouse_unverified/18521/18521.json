{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 18521,
  "instance_id": "ClickHouse__ClickHouse-18521",
  "issue_numbers": [
    "1102"
  ],
  "base_commit": "4af0d73446a8845bf7349c332910562eb0876123",
  "patch": "diff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex fb2d10a4fe7f..717a56fb58e8 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -103,12 +103,15 @@ String getObjectDefinitionFromCreateQuery(const ASTPtr & query)\n         create->attach = true;\n \n     /// We remove everything that is not needed for ATTACH from the query.\n+    assert(!create->temporary);\n     create->database.clear();\n     create->as_database.clear();\n     create->as_table.clear();\n     create->if_not_exists = false;\n     create->is_populate = false;\n     create->replace_view = false;\n+    create->replace_table = false;\n+    create->create_or_replace = false;\n \n     /// For views it is necessary to save the SELECT query itself, for the rest - on the contrary\n     if (!create->is_view && !create->is_materialized_view && !create->is_live_view)\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 2396313f980b..9c9726f39d62 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -81,6 +81,7 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n     extern const int PATH_ACCESS_DENIED;\n     extern const int NOT_IMPLEMENTED;\n+    extern const int UNKNOWN_TABLE;\n }\n \n namespace fs = std::filesystem;\n@@ -733,6 +734,36 @@ void InterpreterCreateQuery::assertOrSetUUID(ASTCreateQuery & create, const Data\n         /// Ignore UUID if it's ON CLUSTER query\n         create.uuid = UUIDHelpers::Nil;\n     }\n+\n+    if (create.replace_table)\n+    {\n+        if (database->getUUID() == UUIDHelpers::Nil)\n+            throw Exception(ErrorCodes::INCORRECT_QUERY,\n+                            \"{} query is supported only for Atomic databases\",\n+                            create.create_or_replace ? \"CREATE OR REPLACE TABLE\" : \"REPLACE TABLE\");\n+\n+        UUID uuid_of_table_to_replace;\n+        if (create.create_or_replace)\n+        {\n+            uuid_of_table_to_replace = context.tryResolveStorageID(StorageID(create.database, create.table)).uuid;\n+            if (uuid_of_table_to_replace == UUIDHelpers::Nil)\n+            {\n+                /// Convert to usual CREATE\n+                create.replace_table = false;\n+                assert(!database->isTableExist(create.table, context));\n+            }\n+            else\n+                create.table = \"_tmp_replace_\" + toString(uuid_of_table_to_replace);\n+        }\n+        else\n+        {\n+            uuid_of_table_to_replace = context.resolveStorageID(StorageID(create.database, create.table)).uuid;\n+            if (uuid_of_table_to_replace == UUIDHelpers::Nil)\n+                throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Table {}.{} doesn't exist\",\n+                                backQuoteIfNeed(create.database), backQuoteIfNeed(create.table));\n+            create.table = \"_tmp_replace_\" + toString(uuid_of_table_to_replace);\n+        }\n+    }\n }\n \n \n@@ -756,9 +787,9 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n         auto query = database->getCreateTableQuery(create.table, context);\n         create = query->as<ASTCreateQuery &>(); // Copy the saved create query, but use ATTACH instead of CREATE\n         if (create.is_dictionary)\n-            throw Exception(\n-                \"Cannot ATTACH TABLE \" + backQuoteIfNeed(database_name) + \".\" + backQuoteIfNeed(create.table) + \", it is a Dictionary\",\n-                ErrorCodes::INCORRECT_QUERY);\n+            throw Exception(ErrorCodes::INCORRECT_QUERY,\n+                            \"Cannot ATTACH TABLE {}.{}, it is a Dictionary\",\n+                            backQuoteIfNeed(database_name), backQuoteIfNeed(create.table));\n         create.attach = true;\n         create.attach_short_syntax = true;\n         create.if_not_exists = if_not_exists;\n@@ -804,6 +835,9 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n     /// Set and retrieve list of columns, indices and constraints. Set table engine if needed. Rewrite query in canonical way.\n     TableProperties properties = setProperties(create);\n \n+    if (create.replace_table)\n+        return doCreateOrReplaceTable(create, properties);\n+\n     /// Actually creates table\n     bool created = doCreateTable(create, properties);\n     if (!created)   /// Table already exists\n@@ -820,20 +854,19 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     String data_path;\n     DatabasePtr database;\n \n-    const String table_name = create.table;\n     bool need_add_to_database = !create.temporary;\n     if (need_add_to_database)\n     {\n         /** If the request specifies IF NOT EXISTS, we allow concurrent CREATE queries (which do nothing).\n           * If table doesn't exist, one thread is creating table, while others wait in DDLGuard.\n           */\n-        guard = DatabaseCatalog::instance().getDDLGuard(create.database, table_name);\n+        guard = DatabaseCatalog::instance().getDDLGuard(create.database, create.table);\n \n         database = DatabaseCatalog::instance().getDatabase(create.database);\n         assertOrSetUUID(create, database);\n \n         /// Table can be created before or it can be created concurrently in another thread, while we were waiting in DDLGuard.\n-        if (database->isTableExist(table_name, context))\n+        if (database->isTableExist(create.table, context))\n         {\n             /// TODO Check structure of table\n             if (create.if_not_exists)\n@@ -843,27 +876,28 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n                 /// when executing CREATE OR REPLACE VIEW, drop current existing view\n                 auto drop_ast = std::make_shared<ASTDropQuery>();\n                 drop_ast->database = create.database;\n-                drop_ast->table = table_name;\n+                drop_ast->table = create.table;\n                 drop_ast->no_ddl_lock = true;\n \n                 InterpreterDropQuery interpreter(drop_ast, context);\n                 interpreter.execute();\n             }\n             else\n-                throw Exception(\"Table \" + create.database + \".\" + table_name + \" already exists.\", ErrorCodes::TABLE_ALREADY_EXISTS);\n+                throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Table {}.{} already exists.\", backQuoteIfNeed(create.database), backQuoteIfNeed(create.table));\n         }\n \n         data_path = database->getTableDataPath(create);\n         if (!create.attach && !data_path.empty() && fs::exists(fs::path{context.getPath()} / data_path))\n-            throw Exception(\"Directory for table data \" + data_path + \" already exists\", ErrorCodes::TABLE_ALREADY_EXISTS);\n+            throw Exception(ErrorCodes::TABLE_ALREADY_EXISTS, \"Directory for table data {} already exists\", String(data_path));\n     }\n     else\n     {\n-        if (create.if_not_exists && context.tryResolveStorageID({\"\", table_name}, Context::ResolveExternal))\n+        if (create.if_not_exists && context.tryResolveStorageID({\"\", create.table}, Context::ResolveExternal))\n             return false;\n \n+        String temporary_table_name = create.table;\n         auto temporary_table = TemporaryTableHolder(context, properties.columns, properties.constraints, query_ptr);\n-        context.getSessionContext().addExternalTable(table_name, std::move(temporary_table));\n+        context.getSessionContext().addExternalTable(temporary_table_name, std::move(temporary_table));\n         return true;\n     }\n \n@@ -903,7 +937,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n                         \"ATTACH ... FROM ... query is not supported for {} table engine, \"\n                         \"because such tables do not store any data on disk. Use CREATE instead.\", res->getName());\n \n-    database->createTable(context, table_name, res, query_ptr);\n+    database->createTable(context, create.table, res, query_ptr);\n \n     /// Move table data to the proper place. Wo do not move data earlier to avoid situations\n     /// when data directory moved, but table has not been created due to some error.\n@@ -927,6 +961,50 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,\n     return true;\n }\n \n+\n+BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,\n+                                                       const InterpreterCreateQuery::TableProperties & properties)\n+{\n+    auto ast_drop = std::make_shared<ASTDropQuery>();\n+    String table_to_replace_name = create.table;\n+    bool created = false;\n+    bool replaced = false;\n+\n+    try\n+    {\n+        [[maybe_unused]] bool done = doCreateTable(create, properties);\n+        assert(done);\n+        ast_drop->table = create.table;\n+        ast_drop->database = create.database;\n+        ast_drop->kind = ASTDropQuery::Drop;\n+        created = true;\n+        if (!create.replace_table)\n+            return fillTableIfNeeded(create);\n+\n+        auto ast_rename = std::make_shared<ASTRenameQuery>();\n+        ASTRenameQuery::Element elem\n+        {\n+            ASTRenameQuery::Table{create.database, create.table},\n+            ASTRenameQuery::Table{create.database, table_to_replace_name}\n+        };\n+        ast_rename->elements.push_back(std::move(elem));\n+        ast_rename->exchange = true;\n+        InterpreterRenameQuery(ast_rename, context).execute();\n+        replaced = true;\n+\n+        InterpreterDropQuery(ast_drop, context).execute();\n+\n+        create.table = table_to_replace_name;\n+        return fillTableIfNeeded(create);\n+    }\n+    catch (...)\n+    {\n+        if (created && create.replace_table && !replaced)\n+            InterpreterDropQuery(ast_drop, context).execute();\n+        throw;\n+    }\n+}\n+\n BlockIO InterpreterCreateQuery::fillTableIfNeeded(const ASTCreateQuery & create)\n {\n     /// If the query is a CREATE SELECT, insert the data into the table.\n@@ -1079,22 +1157,22 @@ AccessRightsElements InterpreterCreateQuery::getRequiredAccess() const\n     }\n     else if (create.is_view || create.is_materialized_view || create.is_live_view)\n     {\n-        if (create.temporary)\n-            required_access.emplace_back(AccessType::CREATE_TEMPORARY_TABLE);\n+        assert(!create.temporary);\n+        if (create.replace_view)\n+            required_access.emplace_back(AccessType::DROP_VIEW | AccessType::CREATE_VIEW, create.database, create.table);\n         else\n-        {\n-            if (create.replace_view)\n-                required_access.emplace_back(AccessType::DROP_VIEW | AccessType::CREATE_VIEW, create.database, create.table);\n-            else\n-                required_access.emplace_back(AccessType::CREATE_VIEW, create.database, create.table);\n-        }\n+            required_access.emplace_back(AccessType::CREATE_VIEW, create.database, create.table);\n     }\n     else\n     {\n         if (create.temporary)\n             required_access.emplace_back(AccessType::CREATE_TEMPORARY_TABLE);\n         else\n+        {\n+            if (create.replace_table)\n+                required_access.emplace_back(AccessType::DROP_TABLE, create.database, create.table);\n             required_access.emplace_back(AccessType::CREATE_TABLE, create.database, create.table);\n+        }\n     }\n \n     if (create.to_table_id)\ndiff --git a/src/Interpreters/InterpreterCreateQuery.h b/src/Interpreters/InterpreterCreateQuery.h\nindex 347d84cef0b2..c109b0b7760f 100644\n--- a/src/Interpreters/InterpreterCreateQuery.h\n+++ b/src/Interpreters/InterpreterCreateQuery.h\n@@ -81,6 +81,7 @@ class InterpreterCreateQuery : public IInterpreter\n \n     /// Create IStorage and add it to database. If table already exists and IF NOT EXISTS specified, do nothing and return false.\n     bool doCreateTable(ASTCreateQuery & create, const TableProperties & properties);\n+    BlockIO doCreateOrReplaceTable(ASTCreateQuery & create, const InterpreterCreateQuery::TableProperties & properties);\n     /// Inserts data in created table if it's CREATE ... SELECT\n     BlockIO fillTableIfNeeded(const ASTCreateQuery & create);\n \ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex 03db54c6957e..1ef2f85585c6 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -230,19 +230,28 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n \n     if (!is_dictionary)\n     {\n-        std::string what = \"TABLE\";\n+        String action = \"CREATE\";\n+        if (attach)\n+            action = \"ATTACH\";\n+        else if (replace_view)\n+            action = \"CREATE OR REPLACE\";\n+        else if (replace_table && create_or_replace)\n+            action = \"CREATE OR REPLACE\";\n+        else if (replace_table)\n+            action = \"REPLACE\";\n+\n+        String what = \"TABLE\";\n         if (is_view)\n             what = \"VIEW\";\n-        if (is_materialized_view)\n+        else if (is_materialized_view)\n             what = \"MATERIALIZED VIEW\";\n-        if (is_live_view)\n+        else if (is_live_view)\n             what = \"LIVE VIEW\";\n \n         settings.ostr\n             << (settings.hilite ? hilite_keyword : \"\")\n-                << (attach ? \"ATTACH \" : \"CREATE \")\n+                << action << \" \"\n                 << (temporary ? \"TEMPORARY \" : \"\")\n-                << (replace_view ? \"OR REPLACE \" : \"\")\n                 << what << \" \"\n                 << (if_not_exists ? \"IF NOT EXISTS \" : \"\")\n             << (settings.hilite ? hilite_none : \"\")\ndiff --git a/src/Parsers/ASTCreateQuery.h b/src/Parsers/ASTCreateQuery.h\nindex 7b2deb996985..4f0d9777f041 100644\n--- a/src/Parsers/ASTCreateQuery.h\n+++ b/src/Parsers/ASTCreateQuery.h\n@@ -64,7 +64,7 @@ class ASTCreateQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnC\n     bool replace_view{false}; /// CREATE OR REPLACE VIEW\n     ASTColumns * columns_list = nullptr;\n     ASTExpressionList * tables = nullptr;\n-    //FIXME\n+\n     StorageID to_table_id = StorageID::createEmpty();   /// For CREATE MATERIALIZED VIEW mv TO table.\n     ASTStorage * storage = nullptr;\n     String as_database;\n@@ -81,6 +81,9 @@ class ASTCreateQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnC\n \n     std::optional<String> attach_from_path = std::nullopt;\n \n+    bool replace_table{false};\n+    bool create_or_replace{false};\n+\n     /** Get the text that identifies this element. */\n     String getID(char delim) const override { return (attach ? \"AttachQuery\" : \"CreateQuery\") + (delim + database) + delim + table; }\n \ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 5fe6a4eee801..c77ddc5f1804 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -355,6 +355,8 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n {\n     ParserKeyword s_create(\"CREATE\");\n     ParserKeyword s_attach(\"ATTACH\");\n+    ParserKeyword s_replace(\"REPLACE\");\n+    ParserKeyword s_or_replace(\"OR REPLACE\");\n     ParserKeyword s_temporary(\"TEMPORARY\");\n     ParserKeyword s_table(\"TABLE\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n@@ -383,25 +385,32 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n \n     String cluster_str;\n     bool attach = false;\n+    bool replace = false;\n+    bool or_replace = false;\n     bool if_not_exists = false;\n     bool is_temporary = false;\n \n-    if (!s_create.ignore(pos, expected))\n+    if (s_create.ignore(pos, expected))\n     {\n-        if (s_attach.ignore(pos, expected))\n-            attach = true;\n-        else\n-            return false;\n+        if (s_or_replace.ignore(pos, expected))\n+            replace = or_replace = true;\n     }\n+    else if (s_attach.ignore(pos, expected))\n+        attach = true;\n+    else if (s_replace.ignore(pos, expected))\n+        replace = true;\n+    else\n+        return false;\n \n-    if (s_temporary.ignore(pos, expected))\n+\n+    if (!replace && !or_replace && s_temporary.ignore(pos, expected))\n     {\n         is_temporary = true;\n     }\n     if (!s_table.ignore(pos, expected))\n         return false;\n \n-    if (s_if_not_exists.ignore(pos, expected))\n+    if (!replace && !or_replace && s_if_not_exists.ignore(pos, expected))\n         if_not_exists = true;\n \n     if (!table_name_p.parse(pos, table, expected))\n@@ -505,6 +514,8 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n         query->as_table_function = as_table_function;\n \n     query->attach = attach;\n+    query->replace_table = replace;\n+    query->create_or_replace = or_replace;\n     query->if_not_exists = if_not_exists;\n     query->temporary = is_temporary;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01185_create_or_replace_table.reference b/tests/queries/0_stateless/01185_create_or_replace_table.reference\nnew file mode 100644\nindex 000000000000..84df5f0f5b5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01185_create_or_replace_table.reference\n@@ -0,0 +1,8 @@\n+t1\n+CREATE TABLE test_01185.t1\\n(\\n    `n` UInt64,\\n    `s` String\\n)\\nENGINE = MergeTree\\nORDER BY n\\nSETTINGS index_granularity = 8192\n+t1\n+CREATE TABLE test_01185.t1\\n(\\n    `n` UInt64,\\n    `s` Nullable(String)\\n)\\nENGINE = MergeTree\\nORDER BY n\\nSETTINGS index_granularity = 8192\n+2\t\\N\n+t1\n+CREATE TABLE test_01185.t1\\n(\\n    `n` UInt64\\n)\\nENGINE = MergeTree\\nORDER BY n\\nSETTINGS index_granularity = 8192\n+3\ndiff --git a/tests/queries/0_stateless/01185_create_or_replace_table.sql b/tests/queries/0_stateless/01185_create_or_replace_table.sql\nnew file mode 100644\nindex 000000000000..fe408cc7ac62\n--- /dev/null\n+++ b/tests/queries/0_stateless/01185_create_or_replace_table.sql\n@@ -0,0 +1,23 @@\n+drop database if exists test_01185;\n+create database test_01185 engine=Atomic;\n+\n+replace table test_01185.t1 (n UInt64, s String) engine=MergeTree order by n; -- { serverError 60 }\n+show tables from test_01185;\n+create or replace table test_01185.t1 (n UInt64, s String) engine=MergeTree order by n;\n+show tables from test_01185;\n+show create table test_01185.t1;\n+\n+insert into test_01185.t1 values (1, 'test');\n+create or replace table test_01185.t1 (n UInt64, s Nullable(String)) engine=MergeTree order by n;\n+insert into test_01185.t1 values (2, null);\n+show tables from test_01185;\n+show create table test_01185.t1;\n+select * from test_01185.t1;\n+\n+replace table test_01185.t1 (n UInt64) engine=MergeTree order by n;\n+insert into test_01185.t1 values (3);\n+show tables from test_01185;\n+show create table test_01185.t1;\n+select * from test_01185.t1;\n+\n+drop database test_01185;\n",
  "problem_statement": "FR: REPLACE TABLE statement \nIf users need to reject(delete) some data from a table, they can create a new table and fill it with a select statement which doesn't retrieve unwanted data, then rename it to old table name.\r\n\r\nExample:\r\n\r\n    CREATE TABLE myNewTable AS myOldTable;\r\n\r\nThen load data with:\r\n\r\n    INSERT INTO myNewTable SELECT * FROM myOldTable WHERE CounterID <12345\r\n\r\nDrop old table and rename:\r\n\r\n    DROP TABLE myOldTable;\r\n    RENAME TABLE myNewTable TO myOldTable\r\n\r\nInstead of above, being able to use the following would be nice:\r\n\r\n    REPLACE TABLE myOldTable SELECT * FROM myOldTable WHERE CounterID <12345;\r\n\r\nBehind the scenes, CH can do the creating, dropping and renaming.\n",
  "hints_text": "We are planning to implement a set of related operations:\r\n```\r\nTRUNCATE TABLE\r\nCREATE OR REPLACE TABLE\r\nREPLACE TABLE\r\n```\r\n\r\nThe main downside is that in first implementation they will be supported for all table engines except `Replicated-` tables. This is because for Replicated tables, CREATE and DROP just add or remove single replica for table.\nLooking forward to it.\r\nI would like to contribute to this project, unfortunately I'm far from being good at C++. I'll do my best if there is any other way to help.\nGOOD Suggestion!!!\r\nLet the rename statement support multi renames, and support transaction for the renames, like mysql, will solve my problem.\n> Let the rename statement support multi renames, and support transaction for the renames\r\n\r\nRename support  renaming multiple tables at once. Syntax is usual.\r\n```\r\nRENAME TABLE a1 TO b1, a2 TO b2, a3 TO b3\r\n```\r\n\r\n`RENAME` operation can be considered atomic but \"but only in cases when there was no exceptions during this process and server does not fall\" (see [comment](https://github.com/yandex/ClickHouse/blob/303cc7242f0ac98e3dbaad74764fcddab001e2f7/dbms/src/Interpreters/InterpreterRenameQuery.cpp#L116)).\nWaiting for `REPLACE`. The usecase is switching application to another table by re-creating view like this\r\n```\r\nCREATE VIEW my_table AS SELECT * FROM my_table_v1\r\n...\r\nREPLACE TABLE my_table WITH\r\nCREATE VIEW AS SELECT * FROM my_table_v2\r\n```\r\nand application (which queries `my_table`) seamlessly switches from one table to another.\nNow this feature can be easily implemented on top of DatabaseAtomic.\r\n@tavplubix said that he is ready to take.",
  "created_at": "2020-12-25T16:33:55Z"
}