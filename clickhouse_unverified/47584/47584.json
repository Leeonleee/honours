{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47584,
  "instance_id": "ClickHouse__ClickHouse-47584",
  "issue_numbers": [
    "47317"
  ],
  "base_commit": "6ad3becc6ec40d31deed7a39a2eebf2ff6526ce1",
  "patch": "diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex c5ebe6121ddf..cbf6cc1cbe3e 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -2140,8 +2140,12 @@ ActionsDAGPtr ActionsDAG::cloneActionsForFilterPushDown(\n     }\n \n     auto conjunction = getConjunctionNodes(predicate, allowed_nodes);\n-    if (conjunction.rejected.size() == 1 && WhichDataType{removeNullable(conjunction.rejected.front()->result_type)}.isFloat())\n+    if (conjunction.rejected.size() == 1 && !conjunction.rejected.front()->result_type->equals(*predicate->result_type)\n+        && conjunction.allowed.front()->type == ActionType::COLUMN)\n+    {\n+        // No further optimization can be done\n         return nullptr;\n+    }\n \n     auto actions = cloneActionsForConjunction(conjunction.allowed, all_inputs);\n     if (!actions)\n@@ -2191,55 +2195,26 @@ ActionsDAGPtr ActionsDAG::cloneActionsForFilterPushDown(\n     else\n     {\n         /// Predicate is conjunction, where both allowed and rejected sets are not empty.\n-        /// Replace this node to conjunction of rejected predicates.\n \n         NodeRawConstPtrs new_children = std::move(conjunction.rejected);\n \n-        if (new_children.size() == 1)\n+        if (new_children.size() == 1 && new_children.front()->result_type->equals(*predicate->result_type))\n         {\n-            /// Rejected set has only one predicate.\n-            if (new_children.front()->result_type->equals(*predicate->result_type))\n-            {\n-                /// If it's type is same, just add alias.\n-                Node node;\n-                node.type = ActionType::ALIAS;\n-                node.result_name = predicate->result_name;\n-                node.result_type = predicate->result_type;\n-                node.children.swap(new_children);\n-                *predicate = std::move(node);\n-            }\n-            else if (!WhichDataType{removeNullable(new_children.front()->result_type)}.isFloat())\n-            {\n-                /// If type is different, cast column.\n-                /// This case is possible, cause AND can use any numeric type as argument.\n-                /// But casting floats to UInt8 or Bool produces different results.\n-                /// so we can't apply this optimization to them.\n-                Node node;\n-                node.type = ActionType::COLUMN;\n-                node.result_name = predicate->result_type->getName();\n-                node.column = DataTypeString().createColumnConst(0, node.result_name);\n-                node.result_type = std::make_shared<DataTypeString>();\n-\n-                const auto * right_arg = &nodes.emplace_back(std::move(node));\n-                const auto * left_arg = new_children.front();\n-\n-                predicate->children = {left_arg, right_arg};\n-                auto arguments = prepareFunctionArguments(predicate->children);\n-\n-                FunctionOverloadResolverPtr func_builder_cast = CastInternalOverloadResolver<CastType::nonAccurate>::createImpl();\n-\n-                predicate->function_base = func_builder_cast->build(arguments);\n-                predicate->function = predicate->function_base->prepare(arguments);\n-            }\n+            /// Rejected set has only one predicate. And the type is the same as the result_type.\n+            /// Just add alias.\n+            Node node;\n+            node.type = ActionType::ALIAS;\n+            node.result_name = predicate->result_name;\n+            node.result_type = predicate->result_type;\n+            node.children.swap(new_children);\n+            *predicate = std::move(node);\n         }\n         else\n         {\n-            /// Predicate is function AND, which still have more then one argument.\n-            /// Or there is only one argument that is a float and we can't just\n-            /// remove the AND.\n+            /// Predicate is function AND, which still have more then one argument\n+            /// or it has one argument of the wrong type.\n             /// Just update children and rebuild it.\n-            predicate->children.swap(new_children);\n-            if (WhichDataType{removeNullable(predicate->children.front()->result_type)}.isFloat())\n+            if (new_children.size() == 1)\n             {\n                 Node node;\n                 node.type = ActionType::COLUMN;\n@@ -2247,8 +2222,9 @@ ActionsDAGPtr ActionsDAG::cloneActionsForFilterPushDown(\n                 node.column = DataTypeUInt8().createColumnConst(0, 1u);\n                 node.result_type = std::make_shared<DataTypeUInt8>();\n                 const auto * const_col = &nodes.emplace_back(std::move(node));\n-                predicate->children.emplace_back(const_col);\n+                new_children.emplace_back(const_col);\n             }\n+            predicate->children.swap(new_children);\n             auto arguments = prepareFunctionArguments(predicate->children);\n \n             FunctionOverloadResolverPtr func_builder_and = std::make_unique<FunctionToOverloadResolverAdaptor>(std::make_shared<FunctionAnd>());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01655_plan_optimizations.reference b/tests/queries/0_stateless/01655_plan_optimizations.reference\nindex f870a52284c7..48d99647b434 100644\n--- a/tests/queries/0_stateless/01655_plan_optimizations.reference\n+++ b/tests/queries/0_stateless/01655_plan_optimizations.reference\n@@ -53,7 +53,7 @@ Filter column: notEquals(y, 0)\n 9\t10\n > one condition of filter should be pushed down after aggregating, other condition is casted\n Filter column\n-FUNCTION _CAST(minus(s, 4) :: 1, UInt8 :: 3) -> and(notEquals(y, 0), minus(s, 4))\n+FUNCTION and(minus(s, 4) :: 1, 1 :: 3) -> and(notEquals(y, 0), minus(s, 4)) UInt8 : 2\n Aggregating\n Filter column: notEquals(y, 0)\n 0\t1\ndiff --git a/tests/queries/0_stateless/01655_plan_optimizations.sh b/tests/queries/0_stateless/01655_plan_optimizations.sh\nindex aaecdc390cb1..ec856c9bf270 100755\n--- a/tests/queries/0_stateless/01655_plan_optimizations.sh\n+++ b/tests/queries/0_stateless/01655_plan_optimizations.sh\n@@ -56,7 +56,7 @@ $CLICKHOUSE_CLIENT -q \"\n         select sum(x) as s, y from (select number as x, number + 1 as y from numbers(10)) group by y\n     ) where y != 0 and s - 4\n     settings enable_optimize_predicate_expression=0\" |\n-    grep -o \"Aggregating\\|Filter column\\|Filter column: notEquals(y, 0)\\|FUNCTION _CAST(minus(s, 4) :: 1, UInt8 :: 3) -> and(notEquals(y, 0), minus(s, 4))\"\n+    grep -o \"Aggregating\\|Filter column\\|Filter column: notEquals(y, 0)\\|FUNCTION and(minus(s, 4) :: 1, 1 :: 3) -> and(notEquals(y, 0), minus(s, 4)) UInt8 : 2\"\n $CLICKHOUSE_CLIENT -q \"\n     select s, y from (\n         select sum(x) as s, y from (select number as x, number + 1 as y from numbers(10)) group by y\ndiff --git a/tests/queries/0_stateless/02568_and_consistency.reference b/tests/queries/0_stateless/02568_and_consistency.reference\nnew file mode 100644\nindex 000000000000..07a8041d0ee2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02568_and_consistency.reference\n@@ -0,0 +1,5 @@\n+=\n+1554690688\n+=\n+1554690688\n+=\ndiff --git a/tests/queries/0_stateless/02568_and_consistency.sql b/tests/queries/0_stateless/02568_and_consistency.sql\nnew file mode 100644\nindex 000000000000..4e76da784278\n--- /dev/null\n+++ b/tests/queries/0_stateless/02568_and_consistency.sql\n@@ -0,0 +1,42 @@\n+DROP TABLE IF EXISTS t1;\n+CREATE TABLE t1 (c0 Int32, PRIMARY KEY (c0)) ENGINE=MergeTree;\n+INSERT INTO t1 VALUES (1554690688);\n+\n+select '=';\n+\n+SELECT MIN(t1.c0)\n+FROM t1\n+GROUP BY\n+    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\n+    t1.c0 * t1.c0,\n+    sign(-exp(-t1.c0))\n+HAVING -(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)\n+UNION ALL\n+SELECT MIN(t1.c0)\n+FROM t1\n+GROUP BY\n+    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\n+    t1.c0 * t1.c0,\n+    sign(-exp(-t1.c0))\n+HAVING NOT (-(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL))\n+UNION ALL\n+SELECT MIN(t1.c0)\n+FROM t1\n+GROUP BY\n+    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\n+    t1.c0 * t1.c0,\n+    sign(-exp(-t1.c0))\n+HAVING (-(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)) IS NULL\n+SETTINGS aggregate_functions_null_for_empty = 1, enable_optimize_predicate_expression = 0;\n+\n+select '=';\n+\n+SELECT MIN(t1.c0)\n+FROM t1\n+GROUP BY t1.c0\n+HAVING and(MIN(t1.c0) + MIN(t1.c0), 1)\n+SETTINGS aggregate_functions_null_for_empty = 1, enable_optimize_predicate_expression = 0;\n+\n+select '=';\n+\n+DROP TABLE IF EXISTS t1;\n",
  "problem_statement": "HAVING returning no result\n```\r\nCREATE TABLE t1 (c0 Int32, PRIMARY KEY (c0)) ENGINE=MergeTree;\r\nINSERT INTO t1 VALUES (1554690688);\r\n```\r\n\r\n```\r\nSELECT MIN(t1.c0)\r\nFROM t1\r\nGROUP BY\r\n    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\r\n    t1.c0 * t1.c0,\r\n    sign(-exp(-t1.c0))\r\nSETTINGS aggregate_functions_null_for_empty = 1, enable_optimize_predicate_expression = 0\r\n\r\nQuery id: 53d13f67-8069-48ce-b614-6c04da2dba07\r\n\r\n\u250c\u2500\u2500\u2500\u2500MIN(c0)\u2500\u2510\r\n\u2502 1554690688 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.035 sec.\r\n```\r\nOriginal report:\r\n```\r\nSELECT MIN(t1.c0)\r\nFROM t1\r\nGROUP BY\r\n    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\r\n    t1.c0 * t1.c0,\r\n    sign(-exp(-t1.c0))\r\nHAVING -(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)\r\nUNION ALL\r\nSELECT MIN(t1.c0)\r\nFROM t1\r\nGROUP BY\r\n    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\r\n    t1.c0 * t1.c0,\r\n    sign(-exp(-t1.c0))\r\nHAVING NOT (-(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL))\r\nUNION ALL\r\nSELECT MIN(t1.c0)\r\nFROM t1\r\nGROUP BY\r\n    (-sign(cos(t1.c0))) * (-max2(t1.c0, t1.c0 / t1.c0)),\r\n    t1.c0 * t1.c0,\r\n    sign(-exp(-t1.c0))\r\nHAVING (-(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)) IS NULL\r\nSETTINGS aggregate_functions_null_for_empty = 1, enable_optimize_predicate_expression = 0\r\n\r\nQuery id: b229fc66-42a6-4240-8374-48a3b5c5d8b5\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.143 sec.\r\n```\r\nSimplified bug:\r\n`-(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)` is 1 when computed outside HAVING, when we add it there it returns nothing:\r\n```\r\nSELECT\r\n    MIN(t1.c0),\r\n    -(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL) AS f\r\nFROM t1\r\nGROUP BY c0\r\nHAVING -(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)\r\n\r\n0 rows in set. Elapsed: 0.040 sec.\r\n```\r\n\r\nIf I just add `true AND` in HAVING it is fixed\r\n```\r\nSELECT\r\n    MIN(t1.c0),\r\n    -(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL) AS f\r\nFROM t1\r\nGROUP BY c0\r\nHAVING true AND -(-(MIN(t1.c0) + MIN(t1.c0))) AND (pow('{b' > '-657301241', log(-1004522121)) IS NOT NULL)\r\n\r\n\u250c\u2500\u2500\u2500\u2500MIN(c0)\u2500\u252c\u2500f\u2500\u2510\r\n\u2502 1554690688 \u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.043 sec.\r\n```\r\n\n",
  "hints_text": "Related to #45440 and #45218, but not fixed by #46653 and #47028\r\n@aiven-sal FYI\nWhat version did you use?\r\nThe simplified version (with and without `true AND`) throws here (I'm using master):\r\n```Code: 59. DB::Exception: Illegal type Int64 of column for filter. Must be UInt8 or Nullable(UInt8) or Const variants of them. (ILLEGAL_TYPE_OF_COLUMN_FOR_FILTER)```\nBy the way, the original query works for me as you reported. I'm looking into that :)",
  "created_at": "2023-03-14T17:33:29Z"
}