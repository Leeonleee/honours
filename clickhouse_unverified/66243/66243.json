{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66243,
  "instance_id": "ClickHouse__ClickHouse-66243",
  "issue_numbers": [
    "66173"
  ],
  "base_commit": "8301fa0b06274f9a06941670d05466b906263524",
  "patch": "diff --git a/src/DataTypes/IDataType.cpp b/src/DataTypes/IDataType.cpp\nindex 1cb64b65d3af..824bc6e33b0b 100644\n--- a/src/DataTypes/IDataType.cpp\n+++ b/src/DataTypes/IDataType.cpp\n@@ -90,7 +90,9 @@ void IDataType::forEachSubcolumn(\n             {\n                 auto name = ISerialization::getSubcolumnNameForStream(subpath, prefix_len);\n                 auto subdata = ISerialization::createFromPath(subpath, prefix_len);\n-                callback(subpath, name, subdata);\n+                auto path_copy = subpath;\n+                path_copy.resize(prefix_len);\n+                callback(path_copy, name, subdata);\n             }\n             subpath[i].visited = true;\n         }\ndiff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp\nindex 1d525e5987f9..356e609e77a4 100644\n--- a/src/DataTypes/ObjectUtils.cpp\n+++ b/src/DataTypes/ObjectUtils.cpp\n@@ -8,6 +8,7 @@\n #include <DataTypes/DataTypeNothing.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeMap.h>\n+#include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeNested.h>\n@@ -66,6 +67,36 @@ DataTypePtr getBaseTypeOfArray(const DataTypePtr & type)\n     return last_array ? last_array->getNestedType() : type;\n }\n \n+DataTypePtr getBaseTypeOfArray(DataTypePtr type, const Names & tuple_elements)\n+{\n+    auto it = tuple_elements.begin();\n+    while (true)\n+    {\n+        if (const auto * type_array = typeid_cast<const DataTypeArray *>(type.get()))\n+        {\n+            type = type_array->getNestedType();\n+        }\n+        else if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type.get()))\n+        {\n+            if (it == tuple_elements.end())\n+                break;\n+\n+            auto pos = type_tuple->tryGetPositionByName(*it);\n+            if (!pos)\n+                break;\n+\n+            ++it;\n+            type = type_tuple->getElement(*pos);\n+        }\n+        else\n+        {\n+            break;\n+        }\n+    }\n+\n+    return type;\n+}\n+\n ColumnPtr getBaseColumnOfArray(const ColumnPtr & column)\n {\n     /// Get raw pointers to avoid extra copying of column pointers.\ndiff --git a/src/DataTypes/ObjectUtils.h b/src/DataTypes/ObjectUtils.h\nindex 6599d8adef15..21e5c3b2f596 100644\n--- a/src/DataTypes/ObjectUtils.h\n+++ b/src/DataTypes/ObjectUtils.h\n@@ -27,6 +27,9 @@ size_t getNumberOfDimensions(const IColumn & column);\n /// Returns type of scalars of Array of arbitrary dimensions.\n DataTypePtr getBaseTypeOfArray(const DataTypePtr & type);\n \n+/// The same as above but takes into account Tuples of Nested.\n+DataTypePtr getBaseTypeOfArray(DataTypePtr type, const Names & tuple_elements);\n+\n /// Returns Array type with requested scalar type and number of dimensions.\n DataTypePtr createArrayOfType(DataTypePtr type, size_t num_dimensions);\n \ndiff --git a/src/DataTypes/Serializations/ISerialization.h b/src/DataTypes/Serializations/ISerialization.h\nindex 255dbbfadd20..5d0bf60c59f8 100644\n--- a/src/DataTypes/Serializations/ISerialization.h\n+++ b/src/DataTypes/Serializations/ISerialization.h\n@@ -195,7 +195,7 @@ class ISerialization : private boost::noncopyable, public std::enable_shared_fro\n         /// Types of substreams that can have arbitrary name.\n         static const std::set<Type> named_types;\n \n-        Type type;\n+        Type type = Type::Regular;\n \n         /// The name of a variant element type.\n         String variant_element_name;\n@@ -212,6 +212,7 @@ class ISerialization : private boost::noncopyable, public std::enable_shared_fro\n         /// Flag, that may help to traverse substream paths.\n         mutable bool visited = false;\n \n+        Substream() = default;\n         Substream(Type type_) : type(type_) {} /// NOLINT\n         String toString() const;\n     };\ndiff --git a/src/Interpreters/inplaceBlockConversions.cpp b/src/Interpreters/inplaceBlockConversions.cpp\nindex 62f8aea86d1c..68254768a7d2 100644\n--- a/src/Interpreters/inplaceBlockConversions.cpp\n+++ b/src/Interpreters/inplaceBlockConversions.cpp\n@@ -18,6 +18,7 @@\n #include <Storages/ColumnsDescription.h>\n #include <DataTypes/NestedUtils.h>\n #include <Columns/ColumnArray.h>\n+#include <Columns/ColumnConst.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Storages/StorageInMemoryMetadata.h>\n \n@@ -35,8 +36,13 @@ namespace\n \n /// Add all required expressions for missing columns calculation\n void addDefaultRequiredExpressionsRecursively(\n-    const Block & block, const String & required_column_name, DataTypePtr required_column_type,\n-    const ColumnsDescription & columns, ASTPtr default_expr_list_accum, NameSet & added_columns, bool null_as_default)\n+    const Block & block,\n+    const String & required_column_name,\n+    DataTypePtr required_column_type,\n+    const ColumnsDescription & columns,\n+    ASTPtr default_expr_list_accum,\n+    NameSet & added_columns,\n+    bool null_as_default)\n {\n     checkStackSize();\n \n@@ -271,6 +277,53 @@ static std::unordered_map<String, ColumnPtr> collectOffsetsColumns(\n     return offsets_columns;\n }\n \n+static ColumnPtr createColumnWithDefaultValue(const IDataType & data_type, const String & subcolumn_name, size_t num_rows)\n+{\n+    auto column = data_type.createColumnConstWithDefaultValue(num_rows);\n+\n+    /// We must turn a constant column into a full column because the interpreter could infer\n+    /// that it is constant everywhere but in some blocks (from other parts) it can be a full column.\n+\n+    if (subcolumn_name.empty())\n+        return column->convertToFullColumnIfConst();\n+\n+    /// Firstly get subcolumn from const column and then replicate.\n+    column = assert_cast<const ColumnConst &>(*column).getDataColumnPtr();\n+    column = data_type.getSubcolumn(subcolumn_name, column);\n+\n+    return ColumnConst::create(std::move(column), num_rows)->convertToFullColumnIfConst();\n+}\n+\n+static bool hasDefault(const StorageMetadataPtr & metadata_snapshot, const NameAndTypePair & column)\n+{\n+    if (!metadata_snapshot)\n+        return false;\n+\n+    const auto & columns = metadata_snapshot->getColumns();\n+    if (columns.has(column.name))\n+        return columns.hasDefault(column.name);\n+\n+    auto name_in_storage = column.getNameInStorage();\n+    return columns.hasDefault(name_in_storage);\n+}\n+\n+static String removeTupleElementsFromSubcolumn(String subcolumn_name, const Names & tuple_elements)\n+{\n+    /// Add a dot to the end of name for convenience.\n+    subcolumn_name += \".\";\n+    for (const auto & elem : tuple_elements)\n+    {\n+        auto pos = subcolumn_name.find(elem + \".\");\n+        if (pos != std::string::npos)\n+            subcolumn_name.erase(pos, elem.size() + 1);\n+    }\n+\n+    if (subcolumn_name.ends_with(\".\"))\n+        subcolumn_name.pop_back();\n+\n+    return subcolumn_name;\n+}\n+\n void fillMissingColumns(\n     Columns & res_columns,\n     size_t num_rows,\n@@ -296,21 +349,17 @@ void fillMissingColumns(\n     auto requested_column = requested_columns.begin();\n     for (size_t i = 0; i < num_columns; ++i, ++requested_column)\n     {\n-        const auto & [name, type] = *requested_column;\n-\n-        if (res_columns[i] && partially_read_columns.contains(name))\n+        if (res_columns[i] && partially_read_columns.contains(requested_column->name))\n             res_columns[i] = nullptr;\n \n-        if (res_columns[i])\n-            continue;\n-\n-        if (metadata_snapshot && metadata_snapshot->getColumns().hasDefault(name))\n+        /// Nothing to fill or default should be filled in evaluateMissingDefaults\n+        if (res_columns[i] || hasDefault(metadata_snapshot, *requested_column))\n             continue;\n \n         std::vector<ColumnPtr> current_offsets;\n         size_t num_dimensions = 0;\n \n-        const auto * array_type = typeid_cast<const DataTypeArray *>(type.get());\n+        const auto * array_type = typeid_cast<const DataTypeArray *>(requested_column->type.get());\n         if (array_type && !offsets_columns.empty())\n         {\n             num_dimensions = getNumberOfDimensions(*array_type);\n@@ -345,20 +394,34 @@ void fillMissingColumns(\n \n         if (!current_offsets.empty())\n         {\n+            Names tuple_elements;\n+            auto serialization = IDataType::getSerialization(*requested_column);\n+\n+            /// For Nested columns collect names of tuple elements and skip them while getting the base type of array.\n+            IDataType::forEachSubcolumn([&](const auto & path, const auto &, const auto &)\n+            {\n+                if (path.back().type == ISerialization::Substream::TupleElement)\n+                    tuple_elements.push_back(path.back().name_of_substream);\n+            }, ISerialization::SubstreamData(serialization));\n+\n+            /// The number of dimensions that belongs to the array itself but not shared in Nested column.\n+            /// For example for column \"n Nested(a UInt64, b Array(UInt64))\" this value is 0 for `n.a` and 1 for `n.b`.\n             size_t num_empty_dimensions = num_dimensions - current_offsets.size();\n-            auto scalar_type = createArrayOfType(getBaseTypeOfArray(type), num_empty_dimensions);\n \n+            auto base_type = getBaseTypeOfArray(requested_column->getTypeInStorage(), tuple_elements);\n+            auto scalar_type = createArrayOfType(base_type, num_empty_dimensions);\n             size_t data_size = assert_cast<const ColumnUInt64 &>(*current_offsets.back()).getData().back();\n-            res_columns[i] = scalar_type->createColumnConstWithDefaultValue(data_size)->convertToFullColumnIfConst();\n+\n+            /// Remove names of tuple elements because they are already processed by 'getBaseTypeOfArray'.\n+            auto subcolumn_name = removeTupleElementsFromSubcolumn(requested_column->getSubcolumnName(), tuple_elements);\n+            res_columns[i] = createColumnWithDefaultValue(*scalar_type, subcolumn_name, data_size);\n \n             for (auto it = current_offsets.rbegin(); it != current_offsets.rend(); ++it)\n                 res_columns[i] = ColumnArray::create(res_columns[i], *it);\n         }\n         else\n         {\n-            /// We must turn a constant column into a full column because the interpreter could infer\n-            /// that it is constant everywhere but in some blocks (from other parts) it can be a full column.\n-            res_columns[i] = type->createColumnConstWithDefaultValue(num_rows)->convertToFullColumnIfConst();\n+            res_columns[i] = createColumnWithDefaultValue(*requested_column->getTypeInStorage(), requested_column->getSubcolumnName(), num_rows);\n         }\n     }\n }\ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.cpp b/src/Storages/MergeTree/IMergeTreeReader.cpp\nindex 264b2b397f44..e0b2710c61f2 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeReader.cpp\n@@ -3,6 +3,7 @@\n #include <Storages/MergeTree/MergeTreeVirtualColumns.h>\n #include <Storages/MergeTree/LoadedMergeTreeDataPartInfoForReader.h>\n #include <DataTypes/NestedUtils.h>\n+#include <DataTypes/DataTypeNested.h>\n #include <Common/escapeForFileName.h>\n #include <Compression/CachedCompressedReadBuffer.h>\n #include <Columns/ColumnArray.h>\n@@ -43,6 +44,7 @@ IMergeTreeReader::IMergeTreeReader(\n     , alter_conversions(data_part_info_for_read->getAlterConversions())\n     /// For wide parts convert plain arrays of Nested to subcolumns\n     /// to allow to use shared offset column from cache.\n+    , original_requested_columns(columns_)\n     , requested_columns(data_part_info_for_read->isWidePart()\n         ? Nested::convertToSubcolumns(columns_)\n         : columns_)\n@@ -138,25 +140,33 @@ void IMergeTreeReader::evaluateMissingDefaults(Block additional_columns, Columns\n {\n     try\n     {\n-        size_t num_columns = requested_columns.size();\n+        size_t num_columns = original_requested_columns.size();\n \n         if (res_columns.size() != num_columns)\n             throw Exception(ErrorCodes::LOGICAL_ERROR, \"invalid number of columns passed to MergeTreeReader::fillMissingColumns. \"\n                             \"Expected {}, got {}\", num_columns, res_columns.size());\n \n-        /// Convert columns list to block.\n+        NameSet full_requested_columns_set;\n+        NamesAndTypesList full_requested_columns;\n+\n+        /// Convert columns list to block. And convert subcolumns to full columns.\n+        /// Defaults should be executed on full columns to get correct values for subcolumns.\n         /// TODO: rewrite with columns interface. It will be possible after changes in ExpressionActions.\n-        auto name_and_type = requested_columns.begin();\n-        for (size_t pos = 0; pos < num_columns; ++pos, ++name_and_type)\n+\n+        auto it = original_requested_columns.begin();\n+        for (size_t pos = 0; pos < num_columns; ++pos, ++it)\n         {\n-            if (res_columns[pos] == nullptr)\n-                continue;\n+            auto name_in_storage = it->getNameInStorage();\n \n-            additional_columns.insert({res_columns[pos], name_and_type->type, name_and_type->name});\n+            if (full_requested_columns_set.emplace(name_in_storage).second)\n+                full_requested_columns.emplace_back(name_in_storage, it->getTypeInStorage());\n+\n+            if (res_columns[pos])\n+                additional_columns.insert({res_columns[pos], it->type, it->name});\n         }\n \n         auto dag = DB::evaluateMissingDefaults(\n-            additional_columns, requested_columns,\n+            additional_columns, full_requested_columns,\n             storage_snapshot->metadata->getColumns(),\n             data_part_info_for_read->getContext());\n \n@@ -170,9 +180,18 @@ void IMergeTreeReader::evaluateMissingDefaults(Block additional_columns, Columns\n         }\n \n         /// Move columns from block.\n-        name_and_type = requested_columns.begin();\n-        for (size_t pos = 0; pos < num_columns; ++pos, ++name_and_type)\n-            res_columns[pos] = std::move(additional_columns.getByName(name_and_type->name).column);\n+        it = original_requested_columns.begin();\n+        for (size_t pos = 0; pos < num_columns; ++pos, ++it)\n+        {\n+            auto name_in_storage = it->getNameInStorage();\n+            res_columns[pos] = additional_columns.getByName(name_in_storage).column;\n+\n+            if (it->isSubcolumn())\n+            {\n+                const auto & type_in_storage = it->getTypeInStorage();\n+                res_columns[pos] = type_in_storage->getSubcolumn(it->getSubcolumnName(), res_columns[pos]);\n+            }\n+        }\n     }\n     catch (Exception & e)\n     {\n@@ -192,7 +211,12 @@ bool IMergeTreeReader::isSubcolumnOffsetsOfNested(const String & name_in_storage\n     if (!data_part_info_for_read->isWidePart() || subcolumn_name != \"size0\")\n         return false;\n \n-    return Nested::isSubcolumnOfNested(name_in_storage, part_columns);\n+    auto split = Nested::splitName(name_in_storage);\n+    if (split.second.empty())\n+        return false;\n+\n+    auto nested_column = part_columns.tryGetColumn(GetColumnsOptions::All, split.first);\n+    return nested_column && isNested(nested_column->type);\n }\n \n String IMergeTreeReader::getColumnNameInPart(const NameAndTypePair & required_column) const\ndiff --git a/src/Storages/MergeTree/IMergeTreeReader.h b/src/Storages/MergeTree/IMergeTreeReader.h\nindex a1ec0339fd65..d799ce57b406 100644\n--- a/src/Storages/MergeTree/IMergeTreeReader.h\n+++ b/src/Storages/MergeTree/IMergeTreeReader.h\n@@ -112,6 +112,9 @@ class IMergeTreeReader : private boost::noncopyable\n \n private:\n     /// Columns that are requested to read.\n+    NamesAndTypesList original_requested_columns;\n+\n+    /// The same as above but with converted Arrays to subcolumns of Nested.\n     NamesAndTypesList requested_columns;\n \n     /// Actual columns description in part.\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderCompact.cpp b/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\nindex a2b8f0ad96f5..69dc2e4b2bbb 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReaderCompact.cpp\n@@ -60,39 +60,25 @@ void MergeTreeReaderCompact::fillColumnPositions()\n \n     for (size_t i = 0; i < columns_num; ++i)\n     {\n-        const auto & column_to_read = columns_to_read[i];\n-\n+        auto & column_to_read = columns_to_read[i];\n         auto position = data_part_info_for_read->getColumnPosition(column_to_read.getNameInStorage());\n-        bool is_array = isArray(column_to_read.type);\n \n         if (column_to_read.isSubcolumn())\n         {\n-            auto storage_column_from_part = getColumnInPart(\n-                {column_to_read.getNameInStorage(), column_to_read.getTypeInStorage()});\n+            NameAndTypePair column_in_storage{column_to_read.getNameInStorage(), column_to_read.getTypeInStorage()};\n+            auto storage_column_from_part = getColumnInPart(column_in_storage);\n \n             auto subcolumn_name = column_to_read.getSubcolumnName();\n             if (!storage_column_from_part.type->hasSubcolumn(subcolumn_name))\n                 position.reset();\n         }\n \n+        column_positions[i] = std::move(position);\n+\n         /// If array of Nested column is missing in part,\n         /// we have to read its offsets if they exist.\n-        if (!position && is_array)\n-        {\n-            auto column_to_read_with_subcolumns = getColumnConvertedToSubcolumnOfNested(column_to_read);\n-            auto name_level_for_offsets = findColumnForOffsets(column_to_read_with_subcolumns);\n-\n-            if (name_level_for_offsets.has_value())\n-            {\n-                column_positions[i] = data_part_info_for_read->getColumnPosition(name_level_for_offsets->first);\n-                columns_for_offsets[i] = name_level_for_offsets;\n-                partially_read_columns.insert(column_to_read.name);\n-            }\n-        }\n-        else\n-        {\n-            column_positions[i] = std::move(position);\n-        }\n+        if (!column_positions[i])\n+            findPositionForMissedNested(i);\n     }\n }\n \n@@ -115,7 +101,7 @@ NameAndTypePair MergeTreeReaderCompact::getColumnConvertedToSubcolumnOfNested(co\n \n     if (!storage_columns_with_collected_nested)\n     {\n-        auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();\n+        auto options = GetColumnsOptions(GetColumnsOptions::All).withExtendedObjects();\n         auto storage_columns_list = Nested::collect(storage_snapshot->getColumns(options));\n         storage_columns_with_collected_nested = ColumnsDescription(std::move(storage_columns_list));\n     }\n@@ -125,11 +111,44 @@ NameAndTypePair MergeTreeReaderCompact::getColumnConvertedToSubcolumnOfNested(co\n         Nested::concatenateName(name_in_storage, subcolumn_name));\n }\n \n+void MergeTreeReaderCompact::findPositionForMissedNested(size_t pos)\n+{\n+    auto & column = columns_to_read[pos];\n+\n+    bool is_array = isArray(column.type);\n+    bool is_offsets_subcolumn = isArray(column.getTypeInStorage()) && column.getSubcolumnName() == \"size0\";\n+\n+    if (!is_array && !is_offsets_subcolumn)\n+        return;\n+\n+    NameAndTypePair column_in_storage{column.getNameInStorage(), column.getTypeInStorage()};\n+\n+    auto column_to_read_with_subcolumns = getColumnConvertedToSubcolumnOfNested(column_in_storage);\n+    auto name_level_for_offsets = findColumnForOffsets(column_to_read_with_subcolumns);\n+\n+    if (!name_level_for_offsets)\n+        return;\n+\n+    column_positions[pos] = data_part_info_for_read->getColumnPosition(name_level_for_offsets->first);\n+\n+    if (is_offsets_subcolumn)\n+    {\n+        /// Read offsets from antoher array from the same Nested column.\n+        column = {name_level_for_offsets->first, column.getSubcolumnName(), column.getTypeInStorage(), column.type};\n+    }\n+    else\n+    {\n+        columns_for_offsets[pos] = std::move(name_level_for_offsets);\n+        partially_read_columns.insert(column.name);\n+    }\n+}\n+\n void MergeTreeReaderCompact::readData(\n     const NameAndTypePair & name_and_type,\n     ColumnPtr & column,\n     size_t rows_to_read,\n-    const InputStreamGetter & getter)\n+    const InputStreamGetter & getter,\n+    ISerialization::SubstreamsCache & cache)\n {\n     try\n     {\n@@ -140,6 +159,13 @@ void MergeTreeReaderCompact::readData(\n         deserialize_settings.getter = getter;\n         deserialize_settings.avg_value_size_hint = avg_value_size_hints[name];\n \n+        auto it = cache.find(name);\n+        if (it != cache.end() && it->second != nullptr)\n+        {\n+            column = it->second;\n+            return;\n+        }\n+\n         if (name_and_type.isSubcolumn())\n         {\n             const auto & type_in_storage = name_and_type.getTypeInStorage();\n@@ -163,6 +189,8 @@ void MergeTreeReaderCompact::readData(\n             serialization->deserializeBinaryBulkWithMultipleStreams(column, rows_to_read, deserialize_settings, deserialize_binary_bulk_state_map[name], nullptr);\n         }\n \n+        cache[name] = column;\n+\n         size_t read_rows_in_column = column->size() - column_size_before_reading;\n         if (read_rows_in_column != rows_to_read)\n             throw Exception(ErrorCodes::CANNOT_READ_ALL_DATA,\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderCompact.h b/src/Storages/MergeTree/MergeTreeReaderCompact.h\nindex a783e595af59..1c6bd1474e30 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderCompact.h\n+++ b/src/Storages/MergeTree/MergeTreeReaderCompact.h\n@@ -36,6 +36,7 @@ class MergeTreeReaderCompact : public IMergeTreeReader\n protected:\n     void fillColumnPositions();\n     NameAndTypePair getColumnConvertedToSubcolumnOfNested(const NameAndTypePair & column);\n+    void findPositionForMissedNested(size_t pos);\n \n     using InputStreamGetter = ISerialization::InputStreamGetter;\n \n@@ -43,7 +44,8 @@ class MergeTreeReaderCompact : public IMergeTreeReader\n         const NameAndTypePair & name_and_type,\n         ColumnPtr & column,\n         size_t rows_to_read,\n-        const InputStreamGetter & getter);\n+        const InputStreamGetter & getter,\n+        ISerialization::SubstreamsCache & cache);\n \n     void readPrefix(\n         const NameAndTypePair & name_and_type,\ndiff --git a/src/Storages/MergeTree/MergeTreeReaderCompactSingleBuffer.cpp b/src/Storages/MergeTree/MergeTreeReaderCompactSingleBuffer.cpp\nindex 2b2cf493bb51..649bcce1188c 100644\n--- a/src/Storages/MergeTree/MergeTreeReaderCompactSingleBuffer.cpp\n+++ b/src/Storages/MergeTree/MergeTreeReaderCompactSingleBuffer.cpp\n@@ -26,6 +26,10 @@ try\n     {\n         size_t rows_to_read = data_part_info_for_read->getIndexGranularity().getMarkRows(from_mark);\n \n+        /// Use cache to avoid reading the column with the same name twice.\n+        /// It may happen if there are empty array Nested in the part.\n+        ISerialization::SubstreamsCache cache;\n+\n         for (size_t pos = 0; pos < num_columns; ++pos)\n         {\n             if (!res_columns[pos])\n@@ -52,7 +56,7 @@ try\n             };\n \n             readPrefix(columns_to_read[pos], buffer_getter, buffer_getter_for_prefix, columns_for_offsets[pos]);\n-            readData(columns_to_read[pos], column, rows_to_read, buffer_getter);\n+            readData(columns_to_read[pos], column, rows_to_read, buffer_getter, cache);\n         }\n \n         ++from_mark;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02026_describe_include_subcolumns.reference b/tests/queries/0_stateless/02026_describe_include_subcolumns.reference\nindex dec65f627484..62efafceaad7 100644\n--- a/tests/queries/0_stateless/02026_describe_include_subcolumns.reference\n+++ b/tests/queries/0_stateless/02026_describe_include_subcolumns.reference\n@@ -26,7 +26,7 @@\n 10. \u2502 t.s        \u2502 String                                                                    \u2502              \u2502                    \u2502                         \u2502 ZSTD(1)          \u2502                      \u2502            1 \u2502\n 11. \u2502 t.a        \u2502 Array(Tuple(\n     a UInt32,\n-    b UInt32))                                   \u2502              \u2502                    \u2502                         \u2502                  \u2502                      \u2502            1 \u2502\n+    b UInt32))                                   \u2502              \u2502                    \u2502                         \u2502 ZSTD(1)          \u2502                      \u2502            1 \u2502\n 12. \u2502 t.a.size0  \u2502 UInt64                                                                    \u2502              \u2502                    \u2502                         \u2502                  \u2502                      \u2502            1 \u2502\n 13. \u2502 t.a.a      \u2502 Array(UInt32)                                                             \u2502              \u2502                    \u2502                         \u2502 ZSTD(1)          \u2502                      \u2502            1 \u2502\n 14. \u2502 t.a.b      \u2502 Array(UInt32)                                                             \u2502              \u2502                    \u2502                         \u2502 ZSTD(1)          \u2502                      \u2502            1 \u2502\ndiff --git a/tests/queries/0_stateless/03203_fill_missed_subcolumns.reference b/tests/queries/0_stateless/03203_fill_missed_subcolumns.reference\nnew file mode 100644\nindex 000000000000..872eb7da3c8e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03203_fill_missed_subcolumns.reference\n@@ -0,0 +1,31 @@\n+0\n+2\n+4\n+6\n+8\n+0\n+2\n+4\n+6\n+8\n+1\t['aaa',NULL]\t[NULL,NULL]\n+2\t['ccc']\t[NULL]\n+3\t[NULL]\t[NULL]\n+4\t[NULL,'bbb']\t['ddd',NULL]\n+5\t[NULL]\t[NULL]\n+1\t2\t2\n+2\t1\t1\n+3\t1\t1\n+4\t2\t2\n+5\t1\t1\n+1\t[0,1]\t[1,1]\n+2\t[0]\t[1]\n+3\t[1]\t[1]\n+4\t[1,0]\t[0,1]\n+5\t[1]\t[1]\n+1\t('foo','bar')\t[1,NULL,3]\n+2\t('aaa','bbb')\t[1,NULL,3]\n+3\t('ccc','ddd')\t[4,5,6]\n+1\tfoo\tbar\t3\t[0,1,0]\n+2\tfoo\tbar\t3\t[0,1,0]\n+3\tccc\tddd\t3\t[0,0,0]\ndiff --git a/tests/queries/0_stateless/03203_fill_missed_subcolumns.sql b/tests/queries/0_stateless/03203_fill_missed_subcolumns.sql\nnew file mode 100644\nindex 000000000000..2789c9de35cf\n--- /dev/null\n+++ b/tests/queries/0_stateless/03203_fill_missed_subcolumns.sql\n@@ -0,0 +1,47 @@\n+DROP TABLE IF EXISTS t_missed_subcolumns;\n+\n+-- .null subcolumn\n+\n+CREATE TABLE t_missed_subcolumns (x UInt32) ENGINE = MergeTree ORDER BY tuple();\n+INSERT INTO t_missed_subcolumns SELECT * FROM numbers(10);\n+\n+ALTER TABLE t_missed_subcolumns ADD COLUMN `y` Nullable(UInt32);\n+\n+INSERT INTO t_missed_subcolumns SELECT number, if(number % 2, NULL, number) FROM numbers(10);\n+\n+SELECT x FROM t_missed_subcolumns WHERE y IS NOT NULL SETTINGS optimize_functions_to_subcolumns = 1;\n+SELECT x FROM t_missed_subcolumns WHERE y IS NOT NULL SETTINGS optimize_functions_to_subcolumns = 0;\n+\n+DROP TABLE IF EXISTS t_missed_subcolumns;\n+\n+-- .null and .size0 subcolumn in array\n+\n+CREATE TABLE t_missed_subcolumns (id UInt64, `n.a` Array(Nullable(String))) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_missed_subcolumns VALUES (1, ['aaa', NULL]) (2, ['ccc']) (3, [NULL]);\n+ALTER TABLE t_missed_subcolumns ADD COLUMN `n.b` Array(Nullable(String));\n+INSERT INTO t_missed_subcolumns VALUES (4, [NULL, 'bbb'], ['ddd', NULL]), (5, [NULL], [NULL]);\n+\n+SELECT id, n.a, n.b FROM t_missed_subcolumns ORDER BY id;\n+SELECT id, n.a.size0, n.b.size0 FROM t_missed_subcolumns ORDER BY id;\n+SELECT id, n.a.null, n.b.null FROM t_missed_subcolumns ORDER BY id;\n+\n+DROP TABLE IF EXISTS t_missed_subcolumns;\n+\n+-- subcolumns and custom defaults\n+\n+CREATE TABLE t_missed_subcolumns (id UInt64) ENGINE = MergeTree ORDER BY id;\n+SYSTEM STOP MERGES t_missed_subcolumns;\n+\n+INSERT INTO t_missed_subcolumns VALUES (1);\n+\n+ALTER TABLE t_missed_subcolumns ADD COLUMN t Tuple(a String, b String) DEFAULT ('foo', 'bar');\n+INSERT INTO t_missed_subcolumns VALUES (2, ('aaa', 'bbb'));\n+\n+ALTER TABLE t_missed_subcolumns ADD COLUMN arr Array(Nullable(UInt64)) DEFAULT [1, NULL, 3];\n+INSERT INTO t_missed_subcolumns VALUES (3, ('ccc', 'ddd'), [4, 5, 6]);\n+\n+SELECT id, t, arr FROM t_missed_subcolumns ORDER BY id;\n+SELECT id, t.a, t.b, arr.size0, arr.null FROM t_missed_subcolumns ORDER BY id;\n+\n+DROP TABLE t_missed_subcolumns;\n",
  "problem_statement": "Wrong query result when `optimize_functions_to_subcolumns=1` after alter table add column Nullable\n```sql\r\ncreate table test (x UInt32) engine=MergeTree order by tuple() settings min_bytes_for_wide_part=1, min_rows_for_wide_part=1;\r\ninsert into test select * from numbers(10);\r\nalter table test add column y Nullable(UInt32);\r\ninsert into test select number, if(number % 2, NULL, number) from numbers(10);\r\n```\r\n\r\n```sql\r\navogar-dev :) select x from test where y is not null settings optimize_functions_to_subcolumns=1\r\n\r\nSELECT x\r\nFROM test\r\nWHERE y IS NOT NULL\r\nSETTINGS optimize_functions_to_subcolumns = 1\r\n\r\nQuery id: fc4bf54e-f8c6-4613-84db-96055c0df322\r\n\r\n    \u250c\u2500x\u2500\u2510\r\n 1. \u2502 0 \u2502\r\n 2. \u2502 1 \u2502\r\n 3. \u2502 2 \u2502\r\n 4. \u2502 3 \u2502\r\n 5. \u2502 4 \u2502\r\n 6. \u2502 5 \u2502\r\n 7. \u2502 6 \u2502\r\n 8. \u2502 7 \u2502\r\n 9. \u2502 8 \u2502\r\n10. \u2502 9 \u2502\r\n    \u2514\u2500\u2500\u2500\u2518\r\n    \u250c\u2500x\u2500\u2510\r\n11. \u2502 0 \u2502\r\n12. \u2502 2 \u2502\r\n13. \u2502 4 \u2502\r\n14. \u2502 6 \u2502\r\n15. \u2502 8 \u2502\r\n    \u2514\u2500\u2500\u2500\u2518\r\n\r\n15 rows in set. Elapsed: 0.004 sec.\r\n\r\navogar-dev :) select x from test where y is not null settings optimize_functions_to_subcolumns=0\r\n\r\nSELECT x\r\nFROM test\r\nWHERE y IS NOT NULL\r\nSETTINGS optimize_functions_to_subcolumns = 0\r\n\r\nQuery id: 20defeb3-3d11-4475-8ae0-10cbfb2f5829\r\n\r\n   \u250c\u2500x\u2500\u2510\r\n1. \u2502 0 \u2502\r\n2. \u2502 2 \u2502\r\n3. \u2502 4 \u2502\r\n4. \u2502 6 \u2502\r\n5. \u2502 8 \u2502\r\n   \u2514\u2500\u2500\u2500\u2518\r\n\r\n5 rows in set. Elapsed: 0.004 sec.\r\n```\r\n\r\nThe result with `optimize_functions_to_subcolumns=1` is wrong. It happens because we don't have `y Nullable(UInt32)` column in the first part and during reading we fill all missing columns with default values. But filling `y.null` subcolumn with default values when `y` column is missing is actually wrong.\n",
  "hints_text": "",
  "created_at": "2024-07-08T17:51:05Z"
}