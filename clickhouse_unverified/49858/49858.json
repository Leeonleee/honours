{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49858,
  "instance_id": "ClickHouse__ClickHouse-49858",
  "issue_numbers": [
    "48827"
  ],
  "base_commit": "61f07f5f3c78400436d6356ad1145143eb3bb165",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex a83bc6382b69..7e26602eee47 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -116,6 +116,12 @@ template <> inline constexpr bool UseLeftDecimal<DataTypeDecimal<Decimal128>, Da\n template <> inline constexpr bool UseLeftDecimal<DataTypeDecimal<Decimal128>, DataTypeDecimal<Decimal64>> = true;\n template <> inline constexpr bool UseLeftDecimal<DataTypeDecimal<Decimal64>, DataTypeDecimal<Decimal32>> = true;\n \n+template <typename DataType> constexpr bool IsFixedString = false;\n+template <> inline constexpr bool IsFixedString<DataTypeFixedString> = true;\n+\n+template <typename DataType> constexpr bool IsString = false;\n+template <> inline constexpr bool IsString<DataTypeString> = true;\n+\n template <template <typename, typename> class Operation, typename LeftDataType, typename RightDataType>\n struct BinaryOperationTraits\n {\n@@ -144,6 +150,8 @@ struct BinaryOperationTraits\n         Case<IsOperation<Operation>::allow_decimal && IsDataTypeDecimal<RightDataType> && IsFloatingPoint<LeftDataType>, DataTypeFloat64>,\n \n         Case<IsOperation<Operation>::bit_hamming_distance && IsIntegral<LeftDataType> && IsIntegral<RightDataType>, DataTypeUInt8>,\n+        Case<IsOperation<Operation>::bit_hamming_distance && IsFixedString<LeftDataType> && IsFixedString<RightDataType>, DataTypeUInt16>,\n+        Case<IsOperation<Operation>::bit_hamming_distance && IsString<LeftDataType> && IsString<RightDataType>, DataTypeUInt64>,\n \n         /// Decimal <op> Real is not supported (traditional DBs convert Decimal <op> Real to Real)\n         Case<IsDataTypeDecimal<LeftDataType> && !IsIntegralOrExtendedOrDecimal<RightDataType>, InvalidType>,\n@@ -246,9 +254,6 @@ struct BinaryOperation\n template <typename B, typename Op>\n struct StringIntegerOperationImpl\n {\n-    static const constexpr bool allow_fixed_string = false;\n-    static const constexpr bool allow_string_integer = true;\n-\n     template <OpCase op_case>\n     static void NO_INLINE processFixedString(const UInt8 * __restrict in_vec, const UInt64 n, const B * __restrict b, ColumnFixedString::Chars & out_vec, size_t size)\n     {\n@@ -381,6 +386,105 @@ struct FixedStringOperationImpl\n     }\n };\n \n+template <typename Op>\n+struct FixedStringReduceOperationImpl\n+{\n+    template <OpCase op_case>\n+    static void inline process(const UInt8 * __restrict a, const UInt8 * __restrict b, UInt16 * __restrict result, size_t size, size_t N)\n+    {\n+        if constexpr (op_case == OpCase::Vector)\n+            vectorVector(a, b, result, size, N);\n+        else if constexpr (op_case == OpCase::LeftConstant)\n+            vectorConstant(b, a, result, size, N);\n+        else\n+            vectorConstant(a, b, result, size, N);\n+    }\n+\n+private:\n+    static void vectorVector(const UInt8 * __restrict a, const UInt8 * __restrict b, UInt16 * __restrict result, size_t size, size_t N)\n+    {\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            size_t offset = i * N;\n+            for (size_t j = 0; j < N; ++j)\n+            {\n+                result[i] += Op::template apply<UInt8>(a[offset + j], b[offset + j]);\n+            }\n+        }\n+    }\n+\n+    static void vectorConstant(const UInt8 * __restrict a, const UInt8 * __restrict b, UInt16 * __restrict result, size_t size, size_t N)\n+    {\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            size_t offset = i * N;\n+            for (size_t j = 0; j < N; ++j)\n+            {\n+                result[i] += Op::template apply<UInt8>(a[offset + j], b[j]);\n+            }\n+        }\n+    }\n+};\n+\n+template <typename Op>\n+struct StringReduceOperationImpl\n+{\n+    static void vectorVector(\n+        const ColumnString::Chars & a,\n+        const ColumnString::Offsets & offsets_a,\n+        const ColumnString::Chars & b,\n+        const ColumnString::Offsets & offsets_b,\n+        PaddedPODArray<UInt64> & res)\n+    {\n+        size_t size = res.size();\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            res[i] = process(\n+                a.data() + offsets_a[i - 1],\n+                a.data() + offsets_a[i] - 1,\n+                b.data() + offsets_b[i - 1],\n+                b.data() + offsets_b[i] - 1);\n+        }\n+    }\n+\n+    static void\n+    vectorConstant(const ColumnString::Chars & a, const ColumnString::Offsets & offsets_a, std::string_view b, PaddedPODArray<UInt64> & res)\n+    {\n+        size_t size = res.size();\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            res[i] = process(\n+                a.data() + offsets_a[i - 1],\n+                a.data() + offsets_a[i] - 1,\n+                reinterpret_cast<const UInt8 *>(b.data()),\n+                reinterpret_cast<const UInt8 *>(b.data()) + b.size());\n+        }\n+    }\n+\n+    static inline UInt64 constConst(std::string_view a, std::string_view b)\n+    {\n+        return process(\n+            reinterpret_cast<const UInt8 *>(a.data()),\n+            reinterpret_cast<const UInt8 *>(a.data()) + a.size(),\n+            reinterpret_cast<const UInt8 *>(b.data()),\n+            reinterpret_cast<const UInt8 *>(b.data()) + b.size());\n+    }\n+\n+private:\n+    static UInt64 process(const UInt8 * __restrict start_a, const UInt8 * __restrict end_a, const UInt8 * start_b, const UInt8 * end_b)\n+    {\n+        UInt64 res = 0;\n+        while (start_a < end_a && start_b < end_b)\n+            res += Op::template apply<UInt8>(*start_a++, *start_b++);\n+\n+        while (start_a < end_a)\n+            res += Op::template apply<UInt8>(*start_a++, 0);\n+        while (start_b < end_b)\n+            res += Op::template apply<UInt8>(0, *start_b++);\n+        return res;\n+    }\n+};\n+\n template <typename A, typename B, typename Op, typename ResultType = typename Op::ResultType>\n struct BinaryOperationImpl : BinaryOperation<A, B, Op, ResultType> { };\n \n@@ -632,10 +736,11 @@ using namespace impl_;\n template <template <typename, typename> class Op, typename Name, bool valid_on_default_arguments = true, bool valid_on_float_arguments = true, bool division_by_nullable = false>\n class FunctionBinaryArithmetic : public IFunction\n {\n-    static constexpr const bool is_plus = IsOperation<Op>::plus;\n-    static constexpr const bool is_minus = IsOperation<Op>::minus;\n-    static constexpr const bool is_multiply = IsOperation<Op>::multiply;\n-    static constexpr const bool is_division = IsOperation<Op>::division;\n+    static constexpr bool is_plus = IsOperation<Op>::plus;\n+    static constexpr bool is_minus = IsOperation<Op>::minus;\n+    static constexpr bool is_multiply = IsOperation<Op>::multiply;\n+    static constexpr bool is_division = IsOperation<Op>::division;\n+    static constexpr bool is_bit_hamming_distance = IsOperation<Op>::bit_hamming_distance;\n \n     ContextPtr context;\n     bool check_decimal_overflow = true;\n@@ -780,8 +885,8 @@ class FunctionBinaryArithmetic : public IFunction\n \n         if (tuple_data_type_0)\n         {\n-            auto & tuple_types = tuple_data_type_0->getElements();\n-            for (auto & type : tuple_types)\n+            const auto & tuple_types = tuple_data_type_0->getElements();\n+            for (const auto & type : tuple_types)\n                 if (!isInterval(type))\n                     return {};\n         }\n@@ -1014,11 +1119,9 @@ class FunctionBinaryArithmetic : public IFunction\n     ColumnPtr executeIntervalTupleOfIntervalsPlusMinus(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,\n                                                size_t input_rows_count, const FunctionOverloadResolverPtr & function_builder) const\n     {\n-        ColumnsWithTypeAndName new_arguments = arguments;\n+        auto function = function_builder->build(arguments);\n \n-        auto function = function_builder->build(new_arguments);\n-\n-        return function->execute(new_arguments, result_type, input_rows_count);\n+        return function->execute(arguments, result_type, input_rows_count);\n     }\n \n     ColumnPtr executeTupleNumberOperator(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type,\n@@ -1316,13 +1419,20 @@ class FunctionBinaryArithmetic : public IFunction\n                     {\n                         if (left.getN() == right.getN())\n                         {\n-                            type_res = std::make_shared<LeftDataType>(left.getN());\n+                            if constexpr (is_bit_hamming_distance)\n+                                type_res = std::make_shared<DataTypeUInt16>();\n+                            else\n+                                type_res = std::make_shared<LeftDataType>(left.getN());\n                             return true;\n                         }\n                     }\n                 }\n \n-                if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)\n+                if constexpr (\n+                    is_bit_hamming_distance\n+                    && std::is_same_v<DataTypeString, LeftDataType> && std::is_same_v<DataTypeString, RightDataType>)\n+                    type_res = std::make_shared<DataTypeUInt64>();\n+                else if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)\n                     return false;\n                 else if constexpr (!IsIntegral<RightDataType>)\n                     return false;\n@@ -1411,6 +1521,7 @@ class FunctionBinaryArithmetic : public IFunction\n     ColumnPtr executeFixedString(const ColumnsWithTypeAndName & arguments) const\n     {\n         using OpImpl = FixedStringOperationImpl<Op<UInt8, UInt8>>;\n+        using OpReduceImpl = FixedStringReduceOperationImpl<Op<UInt8, UInt8>>;\n \n         const auto * const col_left_raw = arguments[0].column.get();\n         const auto * const col_right_raw = arguments[1].column.get();\n@@ -1425,18 +1536,30 @@ class FunctionBinaryArithmetic : public IFunction\n                 if (col_left->getN() != col_right->getN())\n                     return nullptr;\n \n-                auto col_res = ColumnFixedString::create(col_left->getN());\n-                auto & out_chars = col_res->getChars();\n+                if constexpr (is_bit_hamming_distance)\n+                {\n+                    auto col_res = ColumnUInt16::create();\n+                    auto & data = col_res->getData();\n+                    data.resize_fill(col_left->size());\n \n-                out_chars.resize(col_left->getN());\n+                    OpReduceImpl::template process<OpCase::Vector>(\n+                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());\n \n-                OpImpl::template process<OpCase::Vector>(\n-                    col_left->getChars().data(),\n-                    col_right->getChars().data(),\n-                    out_chars.data(),\n-                    out_chars.size(), {});\n+                    return ColumnConst::create(std::move(col_res), col_left_raw->size());\n+                }\n+                else\n+                {\n+                    auto col_res = ColumnFixedString::create(col_left->getN());\n+                    auto & out_chars = col_res->getChars();\n+\n+                    out_chars.resize(col_left->getN());\n+\n+                    OpImpl::template process<OpCase::Vector>(\n+                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {});\n+\n+                    return ColumnConst::create(std::move(col_res), col_left_raw->size());\n+                }\n \n-                return ColumnConst::create(std::move(col_res), col_left_raw->size());\n             }\n         }\n \n@@ -1457,35 +1580,112 @@ class FunctionBinaryArithmetic : public IFunction\n             if (col_left->getN() != col_right->getN())\n                 return nullptr;\n \n-            auto col_res = ColumnFixedString::create(col_left->getN());\n-            auto & out_chars = col_res->getChars();\n-            out_chars.resize((is_right_column_const ? col_left->size() : col_right->size()) * col_left->getN());\n+            if constexpr (is_bit_hamming_distance)\n+            {\n+                auto col_res = ColumnUInt16::create();\n+                auto & data = col_res->getData();\n+                data.resize_fill(is_right_column_const ? col_left->size() : col_right->size());\n+\n+                if (!is_left_column_const && !is_right_column_const)\n+                {\n+                    OpReduceImpl::template process<OpCase::Vector>(\n+                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());\n+                }\n+                else if (is_left_column_const)\n+                {\n+                    OpReduceImpl::template process<OpCase::LeftConstant>(\n+                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());\n+                }\n+                else\n+                {\n+                    OpReduceImpl::template process<OpCase::RightConstant>(\n+                        col_left->getChars().data(), col_right->getChars().data(), data.data(), data.size(), col_left->getN());\n+                }\n+\n+                return col_res;\n+            }\n+            else\n+            {\n+                auto col_res = ColumnFixedString::create(col_left->getN());\n+                auto & out_chars = col_res->getChars();\n+                out_chars.resize((is_right_column_const ? col_left->size() : col_right->size()) * col_left->getN());\n+\n+                if (!is_left_column_const && !is_right_column_const)\n+                {\n+                    OpImpl::template process<OpCase::Vector>(\n+                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), {});\n+                }\n+                else if (is_left_column_const)\n+                {\n+                    OpImpl::template process<OpCase::LeftConstant>(\n+                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN());\n+                }\n+                else\n+                {\n+                    OpImpl::template process<OpCase::RightConstant>(\n+                        col_left->getChars().data(), col_right->getChars().data(), out_chars.data(), out_chars.size(), col_left->getN());\n+                }\n+\n+                return col_res;\n+            }\n+        }\n+        return nullptr;\n+    }\n+\n+    /// Only used for bitHammingDistance\n+    ColumnPtr executeString(const ColumnsWithTypeAndName & arguments) const\n+    {\n+        using OpImpl = StringReduceOperationImpl<Op<UInt8, UInt8>>;\n+\n+        const auto * const col_left_raw = arguments[0].column.get();\n+        const auto * const col_right_raw = arguments[1].column.get();\n+\n+        if (const auto * col_left_const = checkAndGetColumnConst<ColumnString>(col_left_raw))\n+        {\n+            if (const auto * col_right_const = checkAndGetColumnConst<ColumnString>(col_right_raw))\n+            {\n+                const auto * col_left = checkAndGetColumn<ColumnString>(col_left_const->getDataColumn());\n+                const auto * col_right = checkAndGetColumn<ColumnString>(col_right_const->getDataColumn());\n+\n+                std::string_view a = col_left->getDataAt(0).toView();\n+                std::string_view b = col_right->getDataAt(0).toView();\n+\n+                auto res = OpImpl::constConst(a, b);\n+\n+                return DataTypeUInt64{}.createColumnConst(1, res);\n+            }\n+        }\n+\n+        const bool is_left_column_const = checkAndGetColumnConst<ColumnString>(col_left_raw) != nullptr;\n+        const bool is_right_column_const = checkAndGetColumnConst<ColumnString>(col_right_raw) != nullptr;\n+\n+        const auto * col_left = is_left_column_const\n+            ? checkAndGetColumn<ColumnString>(checkAndGetColumnConst<ColumnString>(col_left_raw)->getDataColumn())\n+            : checkAndGetColumn<ColumnString>(col_left_raw);\n+        const auto * col_right = is_right_column_const\n+            ? checkAndGetColumn<ColumnString>(checkAndGetColumnConst<ColumnString>(col_right_raw)->getDataColumn())\n+            : checkAndGetColumn<ColumnString>(col_right_raw);\n+\n+        if (col_left && col_right)\n+        {\n+            auto col_res = ColumnUInt64::create();\n+            auto & data = col_res->getData();\n+            data.resize(is_right_column_const ? col_left->size() : col_right->size());\n \n             if (!is_left_column_const && !is_right_column_const)\n             {\n-                OpImpl::template process<OpCase::Vector>(\n-                    col_left->getChars().data(),\n-                    col_right->getChars().data(),\n-                    out_chars.data(),\n-                    out_chars.size(), {});\n+                OpImpl::vectorVector(\n+                    col_left->getChars(), col_left->getOffsets(), col_right->getChars(), col_right->getOffsets(), data);\n             }\n             else if (is_left_column_const)\n             {\n-                OpImpl::template process<OpCase::LeftConstant>(\n-                    col_left->getChars().data(),\n-                    col_right->getChars().data(),\n-                    out_chars.data(),\n-                    out_chars.size(),\n-                    col_left->getN());\n+                std::string_view str_view = col_left->getDataAt(0).toView();\n+                OpImpl::vectorConstant(col_right->getChars(), col_right->getOffsets(), str_view, data);\n             }\n             else\n             {\n-                OpImpl::template process<OpCase::RightConstant>(\n-                    col_left->getChars().data(),\n-                    col_right->getChars().data(),\n-                    out_chars.data(),\n-                    out_chars.size(),\n-                    col_left->getN());\n+                std::string_view str_view = col_right->getDataAt(0).toView();\n+                OpImpl::vectorConstant(col_left->getChars(), col_left->getOffsets(), str_view, data);\n             }\n \n             return col_res;\n@@ -1493,9 +1693,8 @@ class FunctionBinaryArithmetic : public IFunction\n         return nullptr;\n     }\n \n-\n-    template <typename LeftColumnType, typename A, typename B>\n-    ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A & left, const B & right) const\n+template <typename LeftColumnType, typename A, typename B>\n+ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A & left, const B & right) const\n     {\n         using LeftDataType = std::decay_t<decltype(left)>;\n         using RightDataType = std::decay_t<decltype(right)>;\n@@ -1812,7 +2011,11 @@ class FunctionBinaryArithmetic : public IFunction\n                         return (res = executeFixedString(arguments)) != nullptr;\n                 }\n \n-                if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)\n+                if constexpr (\n+                    is_bit_hamming_distance\n+                    && std::is_same_v<DataTypeString, LeftDataType> && std::is_same_v<DataTypeString, RightDataType>)\n+                    return (res = executeString(arguments)) != nullptr;\n+                else if constexpr (!Op<LeftDataType, RightDataType>::allow_string_integer)\n                     return false;\n                 else if constexpr (!IsIntegral<RightDataType>)\n                     return false;\ndiff --git a/src/Functions/bitHammingDistance.cpp b/src/Functions/bitHammingDistance.cpp\nindex 040f45eaedd4..2eaa397dd041 100644\n--- a/src/Functions/bitHammingDistance.cpp\n+++ b/src/Functions/bitHammingDistance.cpp\n@@ -8,7 +8,7 @@ template <typename A, typename B>\n struct BitHammingDistanceImpl\n {\n     using ResultType = UInt8;\n-    static constexpr bool allow_fixed_string = false;\n+    static constexpr bool allow_fixed_string = true;\n     static constexpr bool allow_string_integer = false;\n \n     template <typename Result = ResultType>\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01017_bithamming_distance.reference b/tests/queries/0_stateless/01017_bithamming_distance.reference\nindex cc2d4f39154d..3e82e0d28648 100644\n--- a/tests/queries/0_stateless/01017_bithamming_distance.reference\n+++ b/tests/queries/0_stateless/01017_bithamming_distance.reference\n@@ -13,3 +13,18 @@\n 5\n 9\n 9\n+0\n+6\n+6\n+0\n+6\n+47\n+0\n+6\n+47\n+0\n+6\n+26\n+0\n+6\n+26\ndiff --git a/tests/queries/0_stateless/01017_bithamming_distance.sql b/tests/queries/0_stateless/01017_bithamming_distance.sql\nindex 4b36894b97ca..11f4f27d9a8a 100644\n--- a/tests/queries/0_stateless/01017_bithamming_distance.sql\n+++ b/tests/queries/0_stateless/01017_bithamming_distance.sql\n@@ -18,3 +18,27 @@ SELECT bitHammingDistance(n2, 100) FROM defaults;\n SELECT bitHammingDistance(n3, n4) FROM defaults;\n \n DROP TABLE defaults;\n+\n+DROP TABLE IF EXISTS test_string;\n+\n+CREATE TABLE test_string\n+(\n+\ts1 String,\n+\ts2 String,\n+\ts3 FixedString(10),\n+\ts4 FixedString(10),\n+) ENGINE = Memory;\n+\n+INSERT INTO test_string VALUES ('hello', 'hello', 'hello', 'hello') ('hello', 'hellow', 'hello', 'hellow') ('clickhouse', '012345', 'clickhouse', '012345');\n+\n+SELECT bitHammingDistance('hello', 'hello');\n+SELECT bitHammingDistance('hello', 'hellow');\n+SELECT bitHammingDistance(toFixedString('hello', 6), toFixedString('hellow', 6));\n+\n+SELECT bitHammingDistance(s1, s2) FROM test_string;\n+SELECT bitHammingDistance(s3, s4) FROM test_string;\n+\n+SELECT bitHammingDistance('hello', s2) FROM test_string;\n+SELECT bitHammingDistance(s4, toFixedString('hello', 10)) FROM test_string;\n+\n+DROP TABLE test_string;\n",
  "problem_statement": "Support `bitCount` and `bitHammingDistance` for `String` and `FixedString`\n**Use case**\r\n\r\nVector search databases often use conversion of the vector space into bit-vectors, where every bit represents a subspace of the space divided by random hyperplanes. The hamming distance on these bit-vectors represents an approximation of the distance in the original vector space. The typical size of a bit-vector is 4 * N, where N is the original number of dimensions. It can be significant in size, larger than 256-bit, requiring to use of the FixedString data type.\r\n\r\n```\r\nSELECT toFixedString('Hello, world!!!!', 16) AS x, toFixedString('Goodbye, xyz!!!!', 16) AS y, \r\n    bitAnd(x, y), bitCount(x), bitHammingDistance(x, y)\r\n```\r\n\r\nExample:\r\n\r\n![annoy](https://user-images.githubusercontent.com/18581488/232365185-edff95b7-fd0f-4744-a7df-385bf09203f9.png)\r\n\r\nhttps://pastila.nl/?06d88bfc/ab814eec85d5bbf8d27496884d95c55d\n",
  "hints_text": "@alexey-milovidov For tupleHammingDistance, if the input strings have different size, how to calculate their distance?\nStrings are compared in the same way as if the shorter string is right-padded by zero bytes to the size of the longest string. In other words, every excessive bit of the longer string is compared with zero bit.\r\n\r\nExample: let's compare \"Hello\" and \"Hellow\":\r\n```\r\n\u250c\u2500bin('Hello')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 0100100001100101011011000110110001101111 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500bin('Hellow')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 010010000110010101101100011011000110111101110111 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIt will be the same as the comparison of \"Hello\\0\" and \"Hellow\":\r\n```\r\n\u250c\u2500bin('Hello\\0')\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 010010000110010101101100011011000110111100000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nThe character `w` has 6 non-zero bits:\r\n```\r\n01110111\r\n```\r\n\r\nSo, the Hamming distance is 6.\nHey there! \ud83d\udc4b I'm new to this repository and eager to contribute! \ud83c\udf1f Could you kindly suggest some entry point or files to look into?\r\n\n@ucasfl is already working on it.",
  "created_at": "2023-05-13T13:59:03Z",
  "modified_files": [
    "src/Functions/FunctionBinaryArithmetic.h",
    "src/Functions/bitHammingDistance.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01017_bithamming_distance.reference",
    "tests/queries/0_stateless/01017_bithamming_distance.sql"
  ]
}