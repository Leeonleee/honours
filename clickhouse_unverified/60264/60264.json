{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60264,
  "instance_id": "ClickHouse__ClickHouse-60264",
  "issue_numbers": [
    "59992"
  ],
  "base_commit": "2e61f2bb99189e457b9669b7a9e9084987ca144b",
  "patch": "diff --git a/src/Functions/IFunctionDateOrDateTime.h b/src/Functions/IFunctionDateOrDateTime.h\nindex d9dc594e12b7..eb42faa5387f 100644\n--- a/src/Functions/IFunctionDateOrDateTime.h\n+++ b/src/Functions/IFunctionDateOrDateTime.h\n@@ -22,13 +22,8 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n-template <typename Transform>\n-class IFunctionDateOrDateTime : public IFunction\n+class FunctionDateOrDateTimeBase : public IFunction\n {\n-public:\n-    static constexpr auto name = Transform::name;\n-    String getName() const override { return name; }\n-\n     bool isVariadic() const override { return true; }\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n@@ -44,6 +39,46 @@ class IFunctionDateOrDateTime : public IFunction\n         return true;\n     }\n \n+protected:\n+    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32) const\n+    {\n+        if (arguments.size() == 1)\n+        {\n+            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64\",\n+                    arguments[0].type->getName(), getName());\n+        }\n+        else if (arguments.size() == 2)\n+        {\n+            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64\",\n+                    arguments[0].type->getName(), getName());\n+            if (!isString(arguments[1].type))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Function {} supports 1 or 2 arguments. The optional 2nd argument must be \"\n+                    \"a constant string with a timezone name\",\n+                    getName());\n+            if (isDateOrDate32(arguments[0].type) && is_result_type_date_or_date32)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"The timezone argument of function {} is allowed only when the 1st argument has the type DateTime or DateTime64\",\n+                    getName());\n+        }\n+        else\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2\",\n+                getName(), arguments.size());\n+    }\n+};\n+\n+template <typename Transform>\n+class IFunctionDateOrDateTime : public FunctionDateOrDateTimeBase\n+{\n+public:\n+    static constexpr auto name = Transform::name;\n+    String getName() const override { return name; }\n+\n     Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n     {\n         if constexpr (std::is_same_v<typename Transform::FactorTransform, ZeroTransform>)\n@@ -105,38 +140,6 @@ class IFunctionDateOrDateTime : public IFunction\n                 : is_not_monotonic;\n         }\n     }\n-\n-protected:\n-    void checkArguments(const ColumnsWithTypeAndName & arguments, bool is_result_type_date_or_date32) const\n-    {\n-        if (arguments.size() == 1)\n-        {\n-            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64\",\n-                    arguments[0].type->getName(), getName());\n-        }\n-        else if (arguments.size() == 2)\n-        {\n-            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64\",\n-                    arguments[0].type->getName(), getName());\n-            if (!isString(arguments[1].type))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"Function {} supports 1 or 2 arguments. The optional 2nd argument must be \"\n-                    \"a constant string with a timezone name\",\n-                    getName());\n-            if (isDateOrDate32(arguments[0].type) && is_result_type_date_or_date32)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                    \"The timezone argument of function {} is allowed only when the 1st argument has the type DateTime or DateTime64\",\n-                    getName());\n-        }\n-        else\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be 1 or 2\",\n-                getName(), arguments.size());\n-    }\n };\n \n }\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 1506dc389462..17723d341fb1 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -17,6 +17,7 @@\n #include <Functions/indexHint.h>\n #include <Functions/CastOverloadResolver.h>\n #include <Functions/IFunction.h>\n+#include <Functions/IFunctionDateOrDateTime.h>\n #include <Functions/geometryConverters.h>\n #include <Common/FieldVisitorToString.h>\n #include <Common/HilbertUtils.h>\n@@ -1446,6 +1447,30 @@ class FunctionWithOptionalConstArg : public IFunctionBase\n \n     IFunctionBase::Monotonicity getMonotonicityForRange(const IDataType & type, const Field & left, const Field & right) const override\n     {\n+        if (const auto * adaptor = typeid_cast<const FunctionToFunctionBaseAdaptor *>(func.get()))\n+        {\n+            if (dynamic_cast<FunctionDateOrDateTimeBase *>(adaptor->getFunction().get()) && kind == Kind::RIGHT_CONST)\n+            {\n+                auto time_zone = extractTimeZoneNameFromColumn(const_arg.column.get(), const_arg.name);\n+\n+                const IDataType * type_ptr = &type;\n+                if (const auto * low_cardinality_type = typeid_cast<const DataTypeLowCardinality *>(type_ptr))\n+                    type_ptr = low_cardinality_type->getDictionaryType().get();\n+\n+                if (type_ptr->isNullable())\n+                    type_ptr = static_cast<const DataTypeNullable &>(*type_ptr).getNestedType().get();\n+\n+                DataTypePtr type_with_time_zone;\n+                if (typeid_cast<const DataTypeDateTime *>(type_ptr))\n+                    type_with_time_zone = std::make_shared<DataTypeDateTime>(time_zone);\n+                else if (const auto * dt64 = typeid_cast<const DataTypeDateTime64 *>(type_ptr))\n+                    type_with_time_zone = std::make_shared<DataTypeDateTime64>(dt64->getScale(), time_zone);\n+                else\n+                    return {}; /// In case we will have other types with time zone\n+\n+                return func->getMonotonicityForRange(*type_with_time_zone, left, right);\n+            }\n+        }\n         return func->getMonotonicityForRange(type, left, right);\n     }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02346_to_hour_monotonicity_fix_2.reference b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix_2.reference\nnew file mode 100644\nindex 000000000000..323c900b1c71\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix_2.reference\n@@ -0,0 +1,2 @@\n+60\n+60\ndiff --git a/tests/queries/0_stateless/02346_to_hour_monotonicity_fix_2.sql b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix_2.sql\nnew file mode 100644\nindex 000000000000..5d1452b43c9b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02346_to_hour_monotonicity_fix_2.sql\n@@ -0,0 +1,13 @@\n+DROP TABLE IF EXISTS test;\n+\n+CREATE TABLE test (stamp DateTime('UTC')) ENGINE = MergeTree PARTITION BY toDate(stamp) ORDER BY tuple() as select toDateTime('2020-01-01', 'UTC')+number*60 from numbers(1e3);\n+\n+SELECT count() result FROM test WHERE toHour(stamp, 'America/Montreal') = 7;\n+\n+DROP TABLE test;\n+\n+CREATE TABLE test (stamp Nullable(DateTime('UTC'))) ENGINE = MergeTree PARTITION BY toDate(stamp) ORDER BY tuple() SETTINGS allow_nullable_key = 1 as select toDateTime('2020-01-01', 'UTC')+number*60 from numbers(1e3);\n+\n+SELECT count() result FROM test WHERE toHour(stamp, 'America/Montreal') = 7;\n+\n+DROP TABLE test;\n",
  "problem_statement": "Request WHERE toHour(stamp, 'America/NewYork')  is not consistent with the result of toHour(stamp) \nHello guys,\r\n\r\nUsing CH (23.9.2.56)\r\n\r\nI have a really weird behavior on my ReplicatedMergeTree table (requested through a distributed table).\r\nSo I have a table like Table (stamp DateTime('UTC'), clicks UInt64),\r\nAnd when I :\r\n```\r\nSELECT toHour(stamp, 'America/New_York'), sum(clicks)\r\nFROM mytable\r\nWHERE toDate(stamp, 'America/New_York') = '2024-02-01'\r\nGROUP BY ALL;\r\n```\r\nI get something like (the numbers are made up, but it is a huge traffic table)\r\n\r\n|  stamp(America/NewYork) | clicks  |\r\n|---|---|\r\n|  0 |  34   |\r\n|  1 |   45  |\r\n|  2 |  60  |\r\n|  ... |   ... |\r\n|  7 |   207 |\r\n|  8 |   213 |\r\n\r\nAt 7AM (NY time) for example I get : sum(clicks) => 207.\r\n\r\nBut when I do a more precise request like just adding  AND toHour(stamp, 'America/NewYork') = 7:\r\n```\r\nSELECT toHour(stamp, 'America/New_York'), sum(clicks)\r\nFROM mytable\r\nWHERE toDate(stamp, 'America/New_York') = '2024-02-01'\r\nAND toHour(stamp, 'America/New_York') = 7 \r\nGROUP BY ALL;\r\n```\r\n\r\nI Have a different result like sum(clicks) => 93 :\r\n\r\n|  stamp(America/NewYork) | clicks  |\r\n|---|---|\r\n|  7 |  93   |\r\n\r\nBut If I remove the 'America/New_York' and do the request in UTC time (7AM = 12 PM) the result stay consistent.\r\n\r\n```\r\nSELECT toHour(stamp, 'America/New_York'), sum(clicks)\r\nFROM mytable\r\nWHERE toDate(stamp, 'America/New_York') = '2024-02-01'\r\nAND toHour(stamp) = 12 \r\nGROUP BY ALL;\r\n```\r\n\r\n**How to reproduce**\r\n\r\nUsing Using CH (23.9.2.56)\r\n\r\n- CREATE TABLE db.table_local ON CLUSTER '{cluster}'\r\n(\r\n    `stamp` DateTime('UTC'),\r\n    ..... a lot of others column ....\r\n    `clicks` UInt64 \r\n)\r\nENGINE = ReplicatedMergeTree\r\nPARTITION BY toDate(stamp)\r\n\r\n-  CREATE TABLE db.table_local ON CLUSTER '{cluster}'\r\n(\r\n    `stamp` DateTime('UTC'),\r\n    ..... a lot of others column ....\r\n    `clicks` UInt64 \r\n)\r\nENGINE = Distributed('db', 'db', 'table', rand())\r\n\r\n- send a lot of request (some millions)\r\n- then request playing on the where with the toHour function\r\n\r\n**Expected behavior**\r\n\r\nThe data should be consistent using toHour(stamp, 'someplace') and without the someplace\r\n\n",
  "hints_text": "Just for more information, as workaround I now do :\r\n\r\n```\r\nSELECT toHour(stamp, 'America/New_York'), sum(clicks)\r\nFROM mytable\r\nWHERE toDate(stamp, 'America/New_York') = '2024-02-01'\r\nAND toHour(toDateTime(stamp, 'America/Montreal')) = 7 \r\nGROUP BY ALL;\r\n```\nhttps://fiddle.clickhouse.com/be66ddb3-6ae6-433e-9285-0129402d6ef0\r\n\r\n```sql\r\n\r\nCREATE TABLE test\r\n( stamp DateTime('UTC'))\r\nENGINE = MergeTree\r\nPARTITION BY toDate(stamp)\r\norder by tuple() as select toDateTime('2020-01-01')+number*60 from numbers(1e3);\r\n\r\n\r\nSELECT  countIf( toHour(toDateTime(stamp, 'America/Montreal')) = 7  ) result\r\nFROM test\r\nformat Pretty;\r\n+--------+\r\n| result |\r\n+--------+\r\n|     60 |\r\n+--------+\r\n\r\nSELECT  countIf( toHour(stamp, 'America/Montreal') = 7  ) result\r\nFROM test\r\nformat Pretty;\r\n+--------+\r\n| result |\r\n+--------+\r\n|     60 |\r\n+--------+\r\n\r\nSELECT  count() result\r\nFROM test\r\nWHERE toHour(toDateTime(stamp, 'America/Montreal')) = 7 \r\nformat Pretty;\r\n+--------+\r\n| result |\r\n+--------+\r\n|     60 |\r\n+--------+\r\n\r\nSELECT  count() result\r\nFROM test\r\nWHERE toHour(identity(stamp), 'America/Montreal') = 7 \r\nformat Pretty;\r\n+--------+\r\n| result |\r\n+--------+\r\n|     60 |\r\n+--------+\r\n\r\nSELECT  count() result\r\nFROM test\r\nWHERE toHour(stamp, 'America/Montreal') = 7 \r\nformat Pretty;\r\n+--------+\r\n| result |\r\n+--------+\r\n|      0 |\r\n+--------+\r\n```\r\n\r\n@amosbird \nThe code to get monotonicity range of `toHour` is incorrect. https://github.com/ClickHouse/ClickHouse/pull/39037 only fixes cases when timezone info is attached to type. We should also check timezone in argument.",
  "created_at": "2024-02-22T07:19:39Z"
}