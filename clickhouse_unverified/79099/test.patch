diff --git a/tests/integration/test_ldap_external_user_directory/configs/ldap_no_role_mapping.xml b/tests/integration/test_ldap_external_user_directory/configs/ldap_no_role_mapping.xml
new file mode 100644
index 000000000000..3922e5877e95
--- /dev/null
+++ b/tests/integration/test_ldap_external_user_directory/configs/ldap_no_role_mapping.xml
@@ -0,0 +1,15 @@
+<clickhouse>
+    <ldap_servers>
+        <openldap>
+            <host>openldap</host>
+            <port>1389</port>
+            <bind_dn>cn={user_name},ou=users,dc=example,dc=org</bind_dn>
+            <enable_tls>no</enable_tls>
+        </openldap>
+    </ldap_servers>
+    <user_directories>
+        <ldap>
+            <server>openldap</server>
+        </ldap>
+    </user_directories>
+</clickhouse>
diff --git a/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml b/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml
index cf1bdf9dcb19..802c1f566776 100644
--- a/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml
+++ b/tests/integration/test_ldap_external_user_directory/configs/remote_servers.xml
@@ -1,6 +1,8 @@
 <clickhouse>
+    <interserver_http_port>9009</interserver_http_port>
     <remote_servers>
         <test_ldap_cluster>
+            <secret>my_secret</secret>
             <shard>
                 <replica>
                     <host>instance1</host>
diff --git a/tests/integration/test_ldap_external_user_directory/configs/users.xml b/tests/integration/test_ldap_external_user_directory/configs/users.xml
new file mode 100644
index 000000000000..e284afb67a6b
--- /dev/null
+++ b/tests/integration/test_ldap_external_user_directory/configs/users.xml
@@ -0,0 +1,11 @@
+<clickhouse>
+    <users>
+        <default remove="remove">
+        </default>
+        <common_user>
+            <password>qwerty</password>
+            <access_management>1</access_management>
+            <readonly>0</readonly>
+        </common_user>
+    </users>
+</clickhouse>
\ No newline at end of file
diff --git a/tests/integration/test_ldap_external_user_directory/test.py b/tests/integration/test_ldap_external_user_directory/test.py
index 6b76466e6086..9ffdaf00f25b 100644
--- a/tests/integration/test_ldap_external_user_directory/test.py
+++ b/tests/integration/test_ldap_external_user_directory/test.py
@@ -13,6 +13,7 @@
 instance1 = cluster.add_instance(
     "instance1",
     main_configs=["configs/ldap_with_role_mapping.xml", "configs/remote_servers.xml"],
+    user_configs=["configs/users.xml"],
     macros={"shard": 1, "replica": "instance1"},
     stay_alive=True,
     with_ldap=True,
@@ -21,7 +22,8 @@
 
 instance2 = cluster.add_instance(
     "instance2",
-    main_configs=["configs/remote_servers.xml"],
+    main_configs=["configs/ldap_no_role_mapping.xml", "configs/remote_servers.xml"],
+    user_configs=["configs/users.xml"],
     macros={"shard": 1, "replica": "instance2"},
     stay_alive=True,
     with_zookeeper=True,
@@ -87,6 +89,10 @@ def delete_ldap_group(ldap_cluster, group_cn):
     assert code == 0
 
 
+# NOTE: In this test suite we have default user explicitly disabled because of `test_push_role_to_other_nodes`.
+# We do it to be sure that it is not used in interserver query (this user has very permissive privileges)
+# and that external roles are really passed and applied.
+
 def test_authentication_pass():
     assert instance1.query(
         "SELECT currentUser()", user="janedoe", password="qwerty"
@@ -106,11 +112,11 @@ def test_authentication_fail():
 
 
 def test_role_mapping(ldap_cluster):
-    instance1.query("DROP ROLE IF EXISTS role_1")
-    instance1.query("DROP ROLE IF EXISTS role_2")
-    instance1.query("DROP ROLE IF EXISTS role_3")
-    instance1.query("CREATE ROLE role_1")
-    instance1.query("CREATE ROLE role_2")
+    instance1.query("DROP ROLE IF EXISTS role_1", user="common_user", password="qwerty")
+    instance1.query("DROP ROLE IF EXISTS role_2", user="common_user", password="qwerty")
+    instance1.query("DROP ROLE IF EXISTS role_3", user="common_user", password="qwerty")
+    instance1.query("CREATE ROLE role_1", user="common_user", password="qwerty")
+    instance1.query("CREATE ROLE role_2", user="common_user", password="qwerty")
     add_ldap_group(ldap_cluster, group_cn="clickhouse-role_1", member_cn="johndoe")
     add_ldap_group(ldap_cluster, group_cn="clickhouse-role_2", member_cn="johndoe")
 
@@ -124,7 +130,7 @@ def test_role_mapping(ldap_cluster):
         password="qwertz",
     ) == TSV([["role_1"], ["role_2"]])
 
-    instance1.query("CREATE ROLE role_3")
+    instance1.query("CREATE ROLE role_3", user="common_user", password="qwerty")
     add_ldap_group(ldap_cluster, group_cn="clickhouse-role_3", member_cn="johndoe")
     # Check that non-existing role in ClickHouse is ignored during role update
     # See https://github.com/ClickHouse/ClickHouse/issues/54318
@@ -136,9 +142,9 @@ def test_role_mapping(ldap_cluster):
         password="qwertz",
     ) == TSV([["role_1"], ["role_2"], ["role_3"]])
 
-    instance1.query("DROP ROLE role_1")
-    instance1.query("DROP ROLE role_2")
-    instance1.query("DROP ROLE role_3")
+    instance1.query("DROP ROLE role_1", user="common_user", password="qwerty")
+    instance1.query("DROP ROLE role_2", user="common_user", password="qwerty")
+    instance1.query("DROP ROLE role_3", user="common_user", password="qwerty")
 
     delete_ldap_group(ldap_cluster, group_cn="clickhouse-role_1")
     delete_ldap_group(ldap_cluster, group_cn="clickhouse-role_2")
@@ -147,41 +153,58 @@ def test_role_mapping(ldap_cluster):
 
 
 def test_push_role_to_other_nodes(ldap_cluster):
-    instance1.query("DROP TABLE IF EXISTS distributed_table SYNC")
-    instance1.query("DROP TABLE IF EXISTS local_table SYNC")
-    instance2.query("DROP TABLE IF EXISTS local_table SYNC")
-    instance1.query("DROP ROLE IF EXISTS role_read")
+    add_ldap_group(ldap_cluster, group_cn="clickhouse-role_read", member_cn="johndoe")
 
-    instance1.query("CREATE ROLE role_read")
-    instance1.query("GRANT SELECT ON *.* TO role_read")
+    instance2.query("DROP USER IF EXISTS remote_user", user="common_user", password="qwerty")
+    instance2.query("CREATE USER remote_user IDENTIFIED WITH plaintext_password BY 'qwerty'", user="common_user", password="qwerty")
 
-    add_ldap_group(ldap_cluster, group_cn="clickhouse-role_read", member_cn="johndoe")
+    instance1.query("DROP TABLE IF EXISTS distributed_table SYNC", user="common_user", password="qwerty")
+    instance1.query("DROP TABLE IF EXISTS local_table SYNC", user="common_user", password="qwerty")
+    instance2.query("DROP TABLE IF EXISTS local_table SYNC", user="common_user", password="qwerty")
+
+    instance1.query("DROP ROLE IF EXISTS role_read", user="common_user", password="qwerty")
+    instance2.query("DROP ROLE IF EXISTS role_read", user="common_user", password="qwerty")
+
+    # On both instances create a role and grant the SELECT privilege.
+    instance1.query("CREATE ROLE role_read", user="common_user", password="qwerty")
+    instance1.query("GRANT SELECT ON *.* TO role_read", user="common_user", password="qwerty")
+    instance2.query("CREATE ROLE role_read", user="common_user", password="qwerty")
+    instance2.query("GRANT SELECT ON *.* TO role_read", user="common_user", password="qwerty")
 
+    # Verify that instance1 resolves johndoe correctly.
     assert instance1.query(
-        "select currentUser()", user="johndoe", password="qwertz"
+        "SELECT currentUser()", user="johndoe", password="qwertz"
     ) == TSV([["johndoe"]])
 
+    # Create the underlying table on both nodes.
     instance1.query(
-        "CREATE TABLE IF NOT EXISTS local_table (id UInt32) ENGINE = MergeTree() ORDER BY id"
+        "CREATE TABLE IF NOT EXISTS local_table (id UInt32) ENGINE = MergeTree() ORDER BY id", user="common_user", password="qwerty"
     )
     instance2.query(
-        "CREATE TABLE IF NOT EXISTS local_table (id UInt32) ENGINE = MergeTree() ORDER BY id"
+        "CREATE TABLE IF NOT EXISTS local_table (id UInt32) ENGINE = MergeTree() ORDER BY id", user="common_user", password="qwerty"
     )
-    instance2.query("INSERT INTO local_table VALUES (1), (2), (3)")
+
+    # Insert some test data, only on remote node.
+    instance2.query("INSERT INTO local_table VALUES (1), (2), (3)", user="common_user", password="qwerty")
+
+    # Create a Distributed table on instance1 that points to local_table.
     instance1.query(
-        "CREATE TABLE IF NOT EXISTS distributed_table AS local_table ENGINE = Distributed(test_ldap_cluster, default, local_table)"
+        "CREATE TABLE IF NOT EXISTS distributed_table AS local_table ENGINE = Distributed(test_ldap_cluster, default, local_table)", user="common_user", password="qwerty"
     )
 
+    # Now, run the distributed query as johndoe.
+    # The coordinator (instance1) will resolve johndoe's LDAP mapping,
+    # and push the external role (role_read) to instance2.
+    # Even though instance2 does not have role mapping, it shall honor the pushed role.
     result = instance1.query(
         "SELECT sum(id) FROM distributed_table", user="johndoe", password="qwertz"
     )
     assert result.strip() == "6"
 
-    instance1.query("DROP TABLE IF EXISTS distributed_table SYNC")
-    instance1.query("DROP TABLE IF EXISTS local_table SYNC")
-    instance2.query("DROP TABLE IF EXISTS local_table SYNC")
-    instance2.query("DROP ROLE IF EXISTS role_read")
-
+    instance1.query("DROP TABLE IF EXISTS distributed_table SYNC", user="common_user", password="qwerty")
+    instance1.query("DROP TABLE IF EXISTS local_table SYNC", user="common_user", password="qwerty")
+    instance2.query("DROP TABLE IF EXISTS local_table SYNC", user="common_user", password="qwerty")
+    instance1.query("DROP ROLE IF EXISTS role_read", user="common_user", password="qwerty")
     delete_ldap_group(ldap_cluster, group_cn="clickhouse-role_read")
 
 
@@ -189,19 +212,20 @@ def test_remote_query_user_does_not_exist_locally(ldap_cluster):
     """
     Check that even if user does not exist locally, using it to execute remote queries is still possible
     """
-    instance2.query("DROP USER IF EXISTS non_local")
-    instance2.query("DROP TABLE IF EXISTS test_table sync")
+    instance2.query("DROP USER IF EXISTS non_local", user="common_user", password="qwerty")
+    instance2.query("DROP TABLE IF EXISTS test_table sync", user="common_user", password="qwerty")
 
-    instance2.query("CREATE USER non_local")
-    instance2.query("CREATE TABLE test_table (id Int16) ENGINE=Memory")
-    instance2.query("INSERT INTO test_table VALUES (123)")
-    instance2.query("GRANT SELECT ON default.test_table TO non_local")
+    instance2.query("CREATE USER non_local", user="common_user", password="qwerty")
+    instance2.query("CREATE TABLE test_table (id Int16) ENGINE=Memory", user="common_user", password="qwerty")
+    instance2.query("INSERT INTO test_table VALUES (123)", user="common_user", password="qwerty")
+    instance2.query("GRANT SELECT ON default.test_table TO non_local", user="common_user", password="qwerty")
 
     # serialize_query_plan is disabled because analysis requiers that local table exists.
     result = instance1.query(
-        "SELECT * FROM remote('instance2', 'default.test_table', 'non_local') settings serialize_query_plan = 0"
+        "SELECT * FROM remote('instance2', 'default.test_table', 'non_local') settings serialize_query_plan = 0",
+        user="common_user", password="qwerty"
     )
     assert result.strip() == "123"
 
-    instance2.query("DROP USER IF EXISTS non_local")
-    instance2.query("DROP TABLE IF EXISTS test_table SYNC")
+    instance2.query("DROP USER IF EXISTS non_local", user="common_user", password="qwerty")
+    instance2.query("DROP TABLE IF EXISTS test_table SYNC", user="common_user", password="qwerty")
