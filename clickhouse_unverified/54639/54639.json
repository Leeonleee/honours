{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54639,
  "instance_id": "ClickHouse__ClickHouse-54639",
  "issue_numbers": [
    "54275"
  ],
  "base_commit": "c911c8daf4bd626315d6b67f35ed7ea0f6c476ce",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 87d844250291..75a008685496 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -137,6 +137,54 @@ Like [makeDateTime](#makedatetime) but produces a [DateTime64](../../sql-referen\n makeDateTime32(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])\n ```\n \n+## timestamp\n+\n+Converts the first argument 'expr' to type [DateTime64(6)](../../sql-reference/data-types/datetime64.md).\n+If a second argument 'expr_time' is provided, it adds the specified time to the converted value.\n+\n+**Syntax**\n+\n+``` sql\n+timestamp(expr[, expr_time])\n+```\n+\n+Alias: `TIMESTAMP`\n+\n+**Arguments**\n+\n+- `expr` - Date or date with time. Type: [String](../../sql-reference/data-types/string.md).\n+- `expr_time` - Optional parameter. Time to add. [String](../../sql-reference/data-types/string.md).\n+\n+**Examples**\n+\n+``` sql\n+SELECT timestamp('2023-12-31') as ts;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u2510\n+\u2502 2023-12-31 00:00:00.000000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+``` sql\n+SELECT timestamp('2023-12-31 12:00:00', '12:00:00.11') as ts;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ts\u2500\u2510\n+\u2502 2024-01-01 00:00:00.110000 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Returned value**\n+\n+- [DateTime64](../../sql-reference/data-types/datetime64.md)(6)\n+\n ## timeZone\n \n Returns the timezone of the current session, i.e. the value of setting [session_timezone](../../operations/settings/settings.md#session_timezone).\ndiff --git a/src/Functions/timestamp.cpp b/src/Functions/timestamp.cpp\nnew file mode 100644\nindex 000000000000..48012c1376f0\n--- /dev/null\n+++ b/src/Functions/timestamp.cpp\n@@ -0,0 +1,193 @@\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnsDateTime.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <IO/ReadHelpers.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+namespace\n+{\n+\n+/** timestamp(expr[, expr_time])\n+ *\n+ * Emulates MySQL's TIMESTAMP() but supports only input format 'yyyy-mm-dd[ hh:mm:ss[.mmmmmm]]' instead of\n+ * MySQLs possible input formats (https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html).\n+  */\n+class FunctionTimestamp : public IFunction\n+{\n+public:\n+    static constexpr UInt32 DATETIME_SCALE = 6;\n+\n+    static constexpr auto name = \"timestamp\";\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTimestamp>(); }\n+\n+    String getName() const override { return name; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"timestamp\", &isStringOrFixedString<IDataType>, nullptr, \"String or FixedString\"}\n+        };\n+        FunctionArgumentDescriptors optional_args{\n+            {\"time\", &isString<IDataType>, nullptr, \"String\"}\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n+\n+        return std::make_shared<DataTypeDateTime64>(DATETIME_SCALE);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const DateLUTImpl * local_time_zone = &DateLUT::instance();\n+\n+        auto col_result = ColumnDateTime64::create(input_rows_count, DATETIME_SCALE);\n+        ColumnDateTime64::Container & vec_result = col_result->getData();\n+\n+        const IColumn * col_timestamp = arguments[0].column.get();\n+\n+        if (const ColumnString * col_timestamp_string = checkAndGetColumn<ColumnString>(col_timestamp))\n+        {\n+            const ColumnString::Chars * chars = &col_timestamp_string->getChars();\n+            const IColumn::Offsets * offsets = &col_timestamp_string->getOffsets();\n+\n+            size_t current_offset = 0;\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                const size_t next_offset = (*offsets)[i];\n+                const size_t string_size = next_offset - current_offset - 1;\n+\n+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], string_size);\n+\n+                DateTime64 value = 0;\n+                readDateTime64Text(value, col_result->getScale(), read_buffer, *local_time_zone);\n+                vec_result[i] = value;\n+\n+                current_offset = next_offset;\n+            }\n+        }\n+        else if (const ColumnFixedString * col_timestamp_fixed_string = checkAndGetColumn<ColumnFixedString>(col_timestamp))\n+        {\n+            const ColumnString::Chars * chars = &col_timestamp_fixed_string->getChars();\n+            const size_t fixed_string_size = col_timestamp_fixed_string->getN();\n+\n+            size_t current_offset = 0;\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                const size_t next_offset = current_offset + fixed_string_size;\n+\n+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], fixed_string_size);\n+\n+                DateTime64 value = 0;\n+                readDateTime64Text(value, col_result->getScale(), read_buffer, *local_time_zone);\n+                vec_result[i] = value;\n+\n+                current_offset = next_offset;\n+            }\n+        }\n+        else\n+        {\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of 1st argument of function {}. Must be String or FixedString\",\n+                col_timestamp->getName(),\n+                getName());\n+        }\n+\n+        if (arguments.size() == 1)\n+            return col_result;\n+\n+        const IColumn * col_time = arguments[1].column.get();\n+\n+        if (const ColumnString * col_time_string = checkAndGetColumn<ColumnString>(col_time))\n+        {\n+            const ColumnString::Chars * chars = &col_time_string->getChars();\n+            const IColumn::Offsets * offsets = &col_time_string->getOffsets();\n+\n+            size_t current_offset = 0;\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                const size_t next_offset = (*offsets)[i];\n+                const size_t string_size = next_offset - current_offset - 1;\n+\n+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], string_size);\n+\n+                Decimal64 value = 0;\n+                readTime64Text(value, col_result->getScale(), read_buffer);\n+                vec_result[i].addOverflow(value);\n+\n+                current_offset = next_offset;\n+            }\n+        }\n+        else if (const ColumnFixedString * col_time_fixed_string = checkAndGetColumn<ColumnFixedString>(col_time))\n+        {\n+            const ColumnString::Chars * chars = &col_time_fixed_string->getChars();\n+            const size_t fixed_string_size = col_time_fixed_string->getN();\n+\n+            size_t current_offset = 0;\n+\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                const size_t next_offset = current_offset + fixed_string_size;\n+\n+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], fixed_string_size);\n+\n+                Decimal64 value = 0;\n+                readTime64Text(value, col_result->getScale(), read_buffer);\n+                vec_result[i].addOverflow(value);\n+\n+                current_offset = next_offset;\n+            }\n+        }\n+        else\n+        {\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                \"Illegal column {} of 2nd argument of function {}. Must be String or FixedString\",\n+                col_time->getName(),\n+                getName());\n+        }\n+\n+        return col_result;\n+    }\n+};\n+\n+}\n+\n+REGISTER_FUNCTION(Timestamp)\n+{\n+    factory.registerFunction<FunctionTimestamp>(FunctionDocumentation{\n+        .description = R\"(\n+Converts the first argument 'expr' to type DateTime64(6).\n+If the second argument 'expr_time' is provided, it adds the specified time to the converted value.\n+:::)\",\n+        .syntax = \"timestamp(expr[, expr_time])\",\n+        .arguments = {\n+            {\"expr\", \"Date or date with time. Type: String.\"},\n+            {\"expr_time\", \"Time to add. Type: String.\"}\n+        },\n+        .returned_value = \"The result of conversion and, optionally, addition. Type: DateTime64(6).\",\n+        .examples = {\n+            {\"timestamp\", \"SELECT timestamp('2013-12-31')\", \"2013-12-31 00:00:00.000000\"},\n+            {\"timestamp\", \"SELECT timestamp('2013-12-31 12:00:00')\", \"2013-12-31 12:00:00.000000\"},\n+            {\"timestamp\", \"SELECT timestamp('2013-12-31 12:00:00', '12:00:00.11')\", \"2014-01-01 00:00:00.110000\"},\n+        },\n+        .categories{\"DateTime\"}}, FunctionFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 2636898c1b3c..190e09e853ab 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -1080,6 +1080,97 @@ inline void readDateTimeText(LocalDateTime & datetime, ReadBuffer & buf)\n     datetime.second((s[6] - '0') * 10 + (s[7] - '0'));\n }\n \n+/// In h*:mm:ss format.\n+template <typename ReturnType = void>\n+inline ReturnType readTimeTextImpl(time_t & time, ReadBuffer & buf)\n+{\n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+\n+    int16_t hours;\n+    int16_t minutes;\n+    int16_t seconds;\n+\n+    readIntText(hours, buf);\n+\n+    int negative_multiplier = hours < 0 ? -1 : 1;\n+\n+    // :mm:ss\n+    const size_t remaining_time_size = 6;\n+\n+    char s[remaining_time_size];\n+\n+    size_t size = buf.read(s, remaining_time_size);\n+    if (size != remaining_time_size)\n+    {\n+        s[size] = 0;\n+\n+        if constexpr (throw_exception)\n+            throw ParsingException(ErrorCodes::CANNOT_PARSE_DATETIME, \"Cannot parse DateTime {}\", s);\n+        else\n+            return false;\n+    }\n+\n+    minutes = (s[1] - '0') * 10 + (s[2] - '0');\n+    seconds = (s[4] - '0') * 10 + (s[5] - '0');\n+\n+    time = hours * 3600 + (minutes * 60 + seconds) * negative_multiplier;\n+\n+    return ReturnType(true);\n+}\n+\n+template <typename ReturnType>\n+inline ReturnType readTimeTextImpl(Decimal64 & time64, UInt32 scale, ReadBuffer & buf)\n+{\n+    time_t whole;\n+    if (!readTimeTextImpl<bool>(whole, buf))\n+    {\n+        return ReturnType(false);\n+    }\n+\n+    DB::DecimalUtils::DecimalComponents<Decimal64> components{static_cast<Decimal64::NativeType>(whole), 0};\n+\n+    if (!buf.eof() && *buf.position() == '.')\n+    {\n+        ++buf.position();\n+\n+        /// Read digits, up to 'scale' positions.\n+        for (size_t i = 0; i < scale; ++i)\n+        {\n+            if (!buf.eof() && isNumericASCII(*buf.position()))\n+            {\n+                components.fractional *= 10;\n+                components.fractional += *buf.position() - '0';\n+                ++buf.position();\n+            }\n+            else\n+            {\n+                /// Adjust to scale.\n+                components.fractional *= 10;\n+            }\n+        }\n+\n+        /// Ignore digits that are out of precision.\n+        while (!buf.eof() && isNumericASCII(*buf.position()))\n+            ++buf.position();\n+    }\n+\n+    bool is_ok = true;\n+    if constexpr (std::is_same_v<ReturnType, void>)\n+    {\n+        time64 = DecimalUtils::decimalFromComponents<Decimal64>(components, scale);\n+    }\n+    else\n+    {\n+        is_ok = DecimalUtils::tryGetDecimalFromComponents<Decimal64>(components, scale, time64);\n+    }\n+\n+    return ReturnType(is_ok);\n+}\n+\n+inline void readTime64Text(Decimal64 & time64, UInt32 scale, ReadBuffer & buf)\n+{\n+    readTimeTextImpl<void>(time64, scale, buf);\n+}\n \n /// Generic methods to read value in native binary format.\n template <typename T>\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02834_timestamp_function.reference b/tests/queries/0_stateless/02834_timestamp_function.reference\nnew file mode 100644\nindex 000000000000..d96052837e2f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02834_timestamp_function.reference\n@@ -0,0 +1,19 @@\n+2013-12-31 00:00:00.000000\n+2013-12-31 12:00:00.000000\n+2013-12-31 12:00:00.111111\n+2013-12-31 12:00:00.111111\n+2014-01-01 00:01:02.000000\n+2014-01-01 00:01:02.100000\n+2014-01-01 00:01:02.110000\n+2014-01-01 00:01:02.111000\n+2014-01-01 00:01:02.111100\n+2014-01-01 00:01:02.111110\n+2014-01-01 00:01:02.111111\n+2013-12-30 23:58:57.888889\n+2013-12-31 10:58:57.888889\n+2013-12-27 07:58:57.888889\n+2017-09-26 19:01:02.111111\n+2010-04-06 03:58:57.888889\n+2013-12-31 00:00:00.000000\n+2014-01-01 00:00:00.000000\n+2013-12-31 00:00:00.000000\ndiff --git a/tests/queries/0_stateless/02834_timestamp_function.sql b/tests/queries/0_stateless/02834_timestamp_function.sql\nnew file mode 100644\nindex 000000000000..c816b7d4be5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02834_timestamp_function.sql\n@@ -0,0 +1,28 @@\n+SET session_timezone = 'UTC';\n+\n+SELECT timestamp('2013-12-31');\n+SELECT timestamp('2013-12-31 12:00:00');\n+SELECT timestamp('2013-12-31 12:00:00.111111');\n+SELECT timestamp('2013-12-31 12:00:00.1111111'); -- ignore > 6 fractional parts\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02');\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02.1');\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02.11');\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02.111');\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02.1111');\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02.11111');\n+SELECT timestamp('2013-12-31 12:00:00', '12:01:02.111111');\n+SELECT timestamp('2013-12-31 12:00:00', '-12:01:02.111111');\n+SELECT timestamp('2013-12-31 12:00:00', '-1:01:02.111111');\n+SELECT timestamp('2013-12-31 12:00:00', '-100:01:02.111111');\n+SELECT timestamp('2013-12-31 12:00:00', '32767:01:02.111111');\n+SELECT timestamp('2013-12-31 12:00:00', '32768:01:02.111111'); -- roll over\n+\n+SELECT timestamp(materialize('2013-12-31'));\n+SELECT timestamp(materialize('2013-12-31 12:00:00'), materialize('12:00:00'));\n+\n+SELECT TIMESTAMP('2013-12-31');\n+\n+SELECT timestamp(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT timestamp('2013-12-31 12:00:00', '12:00:00', '');  -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT timestamp(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT timestamp(1, 2); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n",
  "problem_statement": "MySQL compatibility: ADDDATE, TIMESTAMP functions\nRequired by Tableau Online.\r\n\r\nSample query with both examples:\r\n\r\n```sql\r\nSELECT sum(area) AS sum_area_ok\r\nFROM cell_towers\r\nWHERE (ADDDATE(DATE_FORMAT(created, '%Y-01-01 00:00:00'), toIntervalSecond(0)) >= TIMESTAMP('1995-01-01 00:00:00'))\r\n  AND (ADDDATE(DATE_FORMAT(created, '%Y-01-01 00:00:00'), toIntervalSecond(0)) <= TIMESTAMP('2021-01-01 00:00:00'))\r\nHAVING count() > 0\r\n```\r\n\r\nwhich fails with \r\n\r\n```\r\nCode: 46. DB::Exception: Unknown function ADDDATE\r\n```\r\n\r\nSeparately calling TIMESTAMP function (which will be the next issue when ADDDATE fixed):\r\n\r\n```sql\r\nSELECT TIMESTAMP('2021-01-01 00:00:00');\r\n```\r\n\r\n```\r\nCode: 46. DB::Exception: Unknown function TIMESTAMP\r\n```\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: latest master\r\n* Which interface to use, if matters: MySQL\r\n* Sample data for all these tables: cell_towers sample dataset\r\n\r\n**Expected behavior**\r\n\r\n`ADDDATE` and `TIMESTAMP` functions work like in MySQL.\r\n\n",
  "hints_text": "",
  "created_at": "2023-09-14T16:02:55Z",
  "modified_files": [
    "docs/en/sql-reference/functions/date-time-functions.md",
    "b/src/Functions/timestamp.cpp",
    "src/IO/ReadHelpers.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02834_timestamp_function.reference",
    "b/tests/queries/0_stateless/02834_timestamp_function.sql"
  ]
}