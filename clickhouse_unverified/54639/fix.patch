diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 87d844250291..75a008685496 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -137,6 +137,54 @@ Like [makeDateTime](#makedatetime) but produces a [DateTime64](../../sql-referen
 makeDateTime32(year, month, day, hour, minute, second[, fraction[, precision[, timezone]]])
 ```
 
+## timestamp
+
+Converts the first argument 'expr' to type [DateTime64(6)](../../sql-reference/data-types/datetime64.md).
+If a second argument 'expr_time' is provided, it adds the specified time to the converted value.
+
+**Syntax**
+
+``` sql
+timestamp(expr[, expr_time])
+```
+
+Alias: `TIMESTAMP`
+
+**Arguments**
+
+- `expr` - Date or date with time. Type: [String](../../sql-reference/data-types/string.md).
+- `expr_time` - Optional parameter. Time to add. [String](../../sql-reference/data-types/string.md).
+
+**Examples**
+
+``` sql
+SELECT timestamp('2023-12-31') as ts;
+```
+
+Result:
+
+``` text
+┌─────────────────────────ts─┐
+│ 2023-12-31 00:00:00.000000 │
+└────────────────────────────┘
+```
+
+``` sql
+SELECT timestamp('2023-12-31 12:00:00', '12:00:00.11') as ts;
+```
+
+Result:
+
+``` text
+┌─────────────────────────ts─┐
+│ 2024-01-01 00:00:00.110000 │
+└────────────────────────────┘
+```
+
+**Returned value**
+
+- [DateTime64](../../sql-reference/data-types/datetime64.md)(6)
+
 ## timeZone
 
 Returns the timezone of the current session, i.e. the value of setting [session_timezone](../../operations/settings/settings.md#session_timezone).
diff --git a/src/Functions/timestamp.cpp b/src/Functions/timestamp.cpp
new file mode 100644
index 000000000000..48012c1376f0
--- /dev/null
+++ b/src/Functions/timestamp.cpp
@@ -0,0 +1,193 @@
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <DataTypes/DataTypeDateTime64.h>
+#include <Columns/ColumnString.h>
+#include <Columns/ColumnFixedString.h>
+#include <Columns/ColumnsDateTime.h>
+#include <IO/ReadBufferFromMemory.h>
+#include <IO/ReadHelpers.h>
+
+namespace DB
+{
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_COLUMN;
+}
+
+namespace
+{
+
+/** timestamp(expr[, expr_time])
+ *
+ * Emulates MySQL's TIMESTAMP() but supports only input format 'yyyy-mm-dd[ hh:mm:ss[.mmmmmm]]' instead of
+ * MySQLs possible input formats (https://dev.mysql.com/doc/refman/8.0/en/date-and-time-literals.html).
+  */
+class FunctionTimestamp : public IFunction
+{
+public:
+    static constexpr UInt32 DATETIME_SCALE = 6;
+
+    static constexpr auto name = "timestamp";
+
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTimestamp>(); }
+
+    String getName() const override { return name; }
+
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+    bool isVariadic() const override { return true; }
+    size_t getNumberOfArguments() const override { return 0; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        FunctionArgumentDescriptors mandatory_args{
+            {"timestamp", &isStringOrFixedString<IDataType>, nullptr, "String or FixedString"}
+        };
+        FunctionArgumentDescriptors optional_args{
+            {"time", &isString<IDataType>, nullptr, "String"}
+        };
+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);
+
+        return std::make_shared<DataTypeDateTime64>(DATETIME_SCALE);
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
+    {
+        const DateLUTImpl * local_time_zone = &DateLUT::instance();
+
+        auto col_result = ColumnDateTime64::create(input_rows_count, DATETIME_SCALE);
+        ColumnDateTime64::Container & vec_result = col_result->getData();
+
+        const IColumn * col_timestamp = arguments[0].column.get();
+
+        if (const ColumnString * col_timestamp_string = checkAndGetColumn<ColumnString>(col_timestamp))
+        {
+            const ColumnString::Chars * chars = &col_timestamp_string->getChars();
+            const IColumn::Offsets * offsets = &col_timestamp_string->getOffsets();
+
+            size_t current_offset = 0;
+
+            for (size_t i = 0; i < input_rows_count; ++i)
+            {
+                const size_t next_offset = (*offsets)[i];
+                const size_t string_size = next_offset - current_offset - 1;
+
+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], string_size);
+
+                DateTime64 value = 0;
+                readDateTime64Text(value, col_result->getScale(), read_buffer, *local_time_zone);
+                vec_result[i] = value;
+
+                current_offset = next_offset;
+            }
+        }
+        else if (const ColumnFixedString * col_timestamp_fixed_string = checkAndGetColumn<ColumnFixedString>(col_timestamp))
+        {
+            const ColumnString::Chars * chars = &col_timestamp_fixed_string->getChars();
+            const size_t fixed_string_size = col_timestamp_fixed_string->getN();
+
+            size_t current_offset = 0;
+
+            for (size_t i = 0; i < input_rows_count; ++i)
+            {
+                const size_t next_offset = current_offset + fixed_string_size;
+
+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], fixed_string_size);
+
+                DateTime64 value = 0;
+                readDateTime64Text(value, col_result->getScale(), read_buffer, *local_time_zone);
+                vec_result[i] = value;
+
+                current_offset = next_offset;
+            }
+        }
+        else
+        {
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,
+                "Illegal column {} of 1st argument of function {}. Must be String or FixedString",
+                col_timestamp->getName(),
+                getName());
+        }
+
+        if (arguments.size() == 1)
+            return col_result;
+
+        const IColumn * col_time = arguments[1].column.get();
+
+        if (const ColumnString * col_time_string = checkAndGetColumn<ColumnString>(col_time))
+        {
+            const ColumnString::Chars * chars = &col_time_string->getChars();
+            const IColumn::Offsets * offsets = &col_time_string->getOffsets();
+
+            size_t current_offset = 0;
+
+            for (size_t i = 0; i < input_rows_count; ++i)
+            {
+                const size_t next_offset = (*offsets)[i];
+                const size_t string_size = next_offset - current_offset - 1;
+
+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], string_size);
+
+                Decimal64 value = 0;
+                readTime64Text(value, col_result->getScale(), read_buffer);
+                vec_result[i].addOverflow(value);
+
+                current_offset = next_offset;
+            }
+        }
+        else if (const ColumnFixedString * col_time_fixed_string = checkAndGetColumn<ColumnFixedString>(col_time))
+        {
+            const ColumnString::Chars * chars = &col_time_fixed_string->getChars();
+            const size_t fixed_string_size = col_time_fixed_string->getN();
+
+            size_t current_offset = 0;
+
+            for (size_t i = 0; i < input_rows_count; ++i)
+            {
+                const size_t next_offset = current_offset + fixed_string_size;
+
+                ReadBufferFromMemory read_buffer(&(*chars)[current_offset], fixed_string_size);
+
+                Decimal64 value = 0;
+                readTime64Text(value, col_result->getScale(), read_buffer);
+                vec_result[i].addOverflow(value);
+
+                current_offset = next_offset;
+            }
+        }
+        else
+        {
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,
+                "Illegal column {} of 2nd argument of function {}. Must be String or FixedString",
+                col_time->getName(),
+                getName());
+        }
+
+        return col_result;
+    }
+};
+
+}
+
+REGISTER_FUNCTION(Timestamp)
+{
+    factory.registerFunction<FunctionTimestamp>(FunctionDocumentation{
+        .description = R"(
+Converts the first argument 'expr' to type DateTime64(6).
+If the second argument 'expr_time' is provided, it adds the specified time to the converted value.
+:::)",
+        .syntax = "timestamp(expr[, expr_time])",
+        .arguments = {
+            {"expr", "Date or date with time. Type: String."},
+            {"expr_time", "Time to add. Type: String."}
+        },
+        .returned_value = "The result of conversion and, optionally, addition. Type: DateTime64(6).",
+        .examples = {
+            {"timestamp", "SELECT timestamp('2013-12-31')", "2013-12-31 00:00:00.000000"},
+            {"timestamp", "SELECT timestamp('2013-12-31 12:00:00')", "2013-12-31 12:00:00.000000"},
+            {"timestamp", "SELECT timestamp('2013-12-31 12:00:00', '12:00:00.11')", "2014-01-01 00:00:00.110000"},
+        },
+        .categories{"DateTime"}}, FunctionFactory::CaseInsensitive);
+}
+
+}
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index 2636898c1b3c..190e09e853ab 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -1080,6 +1080,97 @@ inline void readDateTimeText(LocalDateTime & datetime, ReadBuffer & buf)
     datetime.second((s[6] - '0') * 10 + (s[7] - '0'));
 }
 
+/// In h*:mm:ss format.
+template <typename ReturnType = void>
+inline ReturnType readTimeTextImpl(time_t & time, ReadBuffer & buf)
+{
+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;
+
+    int16_t hours;
+    int16_t minutes;
+    int16_t seconds;
+
+    readIntText(hours, buf);
+
+    int negative_multiplier = hours < 0 ? -1 : 1;
+
+    // :mm:ss
+    const size_t remaining_time_size = 6;
+
+    char s[remaining_time_size];
+
+    size_t size = buf.read(s, remaining_time_size);
+    if (size != remaining_time_size)
+    {
+        s[size] = 0;
+
+        if constexpr (throw_exception)
+            throw ParsingException(ErrorCodes::CANNOT_PARSE_DATETIME, "Cannot parse DateTime {}", s);
+        else
+            return false;
+    }
+
+    minutes = (s[1] - '0') * 10 + (s[2] - '0');
+    seconds = (s[4] - '0') * 10 + (s[5] - '0');
+
+    time = hours * 3600 + (minutes * 60 + seconds) * negative_multiplier;
+
+    return ReturnType(true);
+}
+
+template <typename ReturnType>
+inline ReturnType readTimeTextImpl(Decimal64 & time64, UInt32 scale, ReadBuffer & buf)
+{
+    time_t whole;
+    if (!readTimeTextImpl<bool>(whole, buf))
+    {
+        return ReturnType(false);
+    }
+
+    DB::DecimalUtils::DecimalComponents<Decimal64> components{static_cast<Decimal64::NativeType>(whole), 0};
+
+    if (!buf.eof() && *buf.position() == '.')
+    {
+        ++buf.position();
+
+        /// Read digits, up to 'scale' positions.
+        for (size_t i = 0; i < scale; ++i)
+        {
+            if (!buf.eof() && isNumericASCII(*buf.position()))
+            {
+                components.fractional *= 10;
+                components.fractional += *buf.position() - '0';
+                ++buf.position();
+            }
+            else
+            {
+                /// Adjust to scale.
+                components.fractional *= 10;
+            }
+        }
+
+        /// Ignore digits that are out of precision.
+        while (!buf.eof() && isNumericASCII(*buf.position()))
+            ++buf.position();
+    }
+
+    bool is_ok = true;
+    if constexpr (std::is_same_v<ReturnType, void>)
+    {
+        time64 = DecimalUtils::decimalFromComponents<Decimal64>(components, scale);
+    }
+    else
+    {
+        is_ok = DecimalUtils::tryGetDecimalFromComponents<Decimal64>(components, scale, time64);
+    }
+
+    return ReturnType(is_ok);
+}
+
+inline void readTime64Text(Decimal64 & time64, UInt32 scale, ReadBuffer & buf)
+{
+    readTimeTextImpl<void>(time64, scale, buf);
+}
 
 /// Generic methods to read value in native binary format.
 template <typename T>
