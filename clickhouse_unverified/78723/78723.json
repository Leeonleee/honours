{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 78723,
  "instance_id": "ClickHouse__ClickHouse-78723",
  "issue_numbers": [
    "76206"
  ],
  "base_commit": "936bbc737106f3ba982c21b599128fd503e08820",
  "patch": "diff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 7d6815d8acb9..71ee18d53598 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -6518,6 +6518,54 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toInterval {#toInterval}\n+\n+Creates an [Interval](../../sql-reference/data-types/special-data-types/interval.md) data type value from a numeric value and interval unit (eg. 'second' or 'day').\n+\n+**Syntax**\n+\n+```sql\n+toInterval(value, unit)\n+```\n+\n+**Arguments**\n+\n+- `value` \u2014 Length of the interval. Integer numbers or string representations thereof, and float numbers. [(U)Int*](../data-types/int-uint.md)/[Float*](../data-types/float.md)/[String](../data-types/string.md).\n+\n+- `unit` \u2014 The type of interval to create. [String Literal](/sql-reference/syntax#string).\n+    Possible values:\n+\n+    - `nanosecond`\n+    - `microsecond`\n+    - `millisecond`\n+    - `second`\n+    - `minute`\n+    - `hour`\n+    - `day`\n+    - `week`\n+    - `month`\n+    - `quarter`\n+    - `year`\n+\n+    The `unit` argument is case-insensitive.\n+\n+\n+**Returned value**\n+\n+- The resulting interval. [Interval](../../sql-reference/data-types/special-data-types/interval.md)\n+\n+**Example**\n+\n+```sql\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval(1, 'hour')\n+```\n+\n+```response\n+\u250c\u2500toDateTime('2025-01-01 00:00:00') + toInterval(1, 'hour') \u2500\u2510\n+\u2502                                        2025-01-01 01:00:00 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## toIntervalYear {#tointervalyear}\n \n Returns an interval of `n` years of data type [IntervalYear](../data-types/special-data-types/interval.md).\ndiff --git a/src/Functions/toInterval.cpp b/src/Functions/toInterval.cpp\nnew file mode 100644\nindex 000000000000..588072c9c43c\n--- /dev/null\n+++ b/src/Functions/toInterval.cpp\n@@ -0,0 +1,85 @@\n+#include <Functions/IFunction.h>\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <DataTypes/DataTypeInterval.h>\n+#include <Functions/DateTimeTransforms.h>\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+class FunctionToInterval : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"toInterval\";\n+\n+    explicit FunctionToInterval(ContextPtr context_) : context(context_) {}\n+\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToInterval>(context); }\n+\n+    String getName() const override { return name; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return 2; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    bool hasInformationAboutMonotonicity() const override { return true; }\n+\n+    Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override\n+    {\n+        return { .is_monotonic = true, .is_always_monotonic = true };\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() != 2)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} must be 2 arguments\", getName());\n+\n+        /// The second argument is a constant string with the name of interval kind.\n+        String interval_kind;\n+        const ColumnConst * kind_column = checkAndGetColumnConst<ColumnString>(arguments[1].column.get());\n+        if (!kind_column)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Second argument for function {} must be constant string: \"\n+                \"unit of interval\", getName());\n+\n+        interval_kind = Poco::toLower(kind_column->getValue<String>());\n+        if (interval_kind.empty())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Second argument (unit) for function {} cannot be empty\", getName());\n+\n+        if (!IntervalKind::tryParseString(interval_kind, kind.kind))\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{} doesn't look like an interval unit in {}\", interval_kind, getName());\n+\n+        return std::make_shared<DataTypeInterval>(kind);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        ColumnsWithTypeAndName temp_columns(1);\n+        temp_columns[0] = arguments[0];\n+\n+        const char * to_interval_function_name = kind.toNameOfFunctionToIntervalDataType();\n+        auto to_interval_function = FunctionFactory::instance().get(to_interval_function_name, context);\n+\n+        return to_interval_function->build(temp_columns)->execute(temp_columns, result_type, input_rows_count, /* dry run = */ false);\n+    }\n+\n+private:\n+    ContextPtr context;\n+    mutable IntervalKind kind = IntervalKind::Kind::Second;\n+};\n+\n+REGISTER_FUNCTION(ToInterval)\n+{\n+    factory.registerFunction<FunctionToInterval>(\n+        FunctionDocumentation{.description = R\"(Creates an interval from a value and a unit.)\"});\n+}\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03403_toInterval.reference b/tests/queries/0_stateless/03403_toInterval.reference\nnew file mode 100644\nindex 000000000000..e41a6ffe8e86\n--- /dev/null\n+++ b/tests/queries/0_stateless/03403_toInterval.reference\n@@ -0,0 +1,24 @@\n+5\t2025-01-01 00:00:00.000000005\n+5\t2025-01-01 00:00:00.000005000\n+5\t2025-01-01 00:00:00.005000000\n+5\t2025-01-01 00:00:05\n+5\t2025-01-01 00:00:05\n+5\t2025-01-01 00:00:05\n+5\t2025-01-01 00:05:00\n+5\t2025-01-01 05:00:00\n+5\t2025-01-06 00:00:00\n+5\t2025-02-05 00:00:00\n+5\t2025-06-01 00:00:00\n+5\t2026-04-01 00:00:00\n+5\t2030-01-01 00:00:00\n+2030-01-01 00:00:00\n+2025-01-01 00:00:00\n+2025-01-01 00:00:01\n+2025-01-01 00:00:02\n+2025-01-01 00:00:03\n+2025-01-01 00:00:04\n+\\N\n+2025-01-01 00:00:00\n+2025-01-01 00:00:00\n+2025-01-01 00:00:01\n+2025-01-01 00:00:05\ndiff --git a/tests/queries/0_stateless/03403_toInterval.sql b/tests/queries/0_stateless/03403_toInterval.sql\nnew file mode 100644\nindex 000000000000..eaa54420883c\n--- /dev/null\n+++ b/tests/queries/0_stateless/03403_toInterval.sql\n@@ -0,0 +1,30 @@\n+SELECT toInterval(5, 'nanosecond') as interval, toDateTime64('2025-01-01 00:00:00', 9) + interval AS res;\n+SELECT toInterval(5, 'microsecond') as interval, toDateTime64('2025-01-01 00:00:00', 9) + interval AS res;\n+SELECT toInterval(5, 'millisecond') as interval, toDateTime64('2025-01-01 00:00:00', 9) + interval AS res;\n+SELECT toInterval(5, 'second') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Second') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'SECOND') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Minute') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Hour') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Day') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Week') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Month') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Quarter') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toInterval(5, 'Year') as interval, toDateTime('2025-01-01 00:00:00') + interval AS res;\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval(5, 'Year') AS res;\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval(number, 'second') FROM numbers(5);\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval(null, 'second');\n+SELECT toDateTime('2025-01-01 00:00:01') + toInterval(-1, 'second');\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval(0, 'second');\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval(1.5, 'second');\n+SELECT toDateTime('2025-01-01 00:00:00') + toInterval('5', 'second');\n+\n+SELECT toInterval(); -- { serverError 42}\n+SELECT toInterval(''); -- { serverError 42}\n+SELECT toInterval('second'); -- { serverError 42 }\n+SELECT toInterval(5, 'second', 10); -- { serverError 42 }\n+\n+SELECT toInterval(10, 5); -- { serverError 43 }\n+\n+SELECT toInterval(5, ''); -- { serverError 36 }\n+SELECT toInterval(5, 'invalid kind'); -- { serverError 36 }\n",
  "problem_statement": "Add a function to construct an Interval from a unit and a length\n### Company or project name\n\n_No response_\n\n### Use case\n\nI want to create a parameterized query or view that uses the [`WITH FILL ... STEP <interval>`](https://clickhouse.com/docs/en/guides/developer/time-series-filling-gaps) feature, using a dynamic step \"unit\".\n\nGiven a parameterized query like this,\n```\nSELECT\n    date_trunc({interval:String}, timestamp) AS bucket,\n    count() AS count\nFROM MidJourney.images\nWHERE (timestamp >= {start:Date}) AND (timestamp <= {end:Date})\nGROUP BY ALL\nORDER BY bucket ASC\nWITH FILL\nSTEP makeInterval({interval:String}, 1) -- This function doesn't exist, and \"INTERVAL 1 {interval:String}\" doesn't seem to be allowed\n```\nI'd then pass `interval='day'/'week'/'month'` into the query as a parameter.\n\nHowever, I don't think `makeInterval(unit, length)` exists (if something analogous exists, or if there's an existing way to solve this problem, please let me know!)\n\n### Describe the solution you'd like\n\nI'd like a `makeInterval(unit, length)` function (or something similar) that allows me to dynamically create an interval of a specified unit and length.\n\n### Describe alternatives you've considered\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-04-05T18:48:47Z",
  "modified_files": [
    "docs/en/sql-reference/functions/type-conversion-functions.md",
    "b/src/Functions/toInterval.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03403_toInterval.reference",
    "b/tests/queries/0_stateless/03403_toInterval.sql"
  ]
}