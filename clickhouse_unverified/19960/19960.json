{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19960,
  "instance_id": "ClickHouse__ClickHouse-19960",
  "issue_numbers": [
    "13962"
  ],
  "base_commit": "8c0ec5105b67c73799a6d8774d7bef939ea2668c",
  "patch": "diff --git a/src/Functions/FunctionsJSON.h b/src/Functions/FunctionsJSON.h\nindex aea5829eaef0..f066bb1029a9 100644\n--- a/src/Functions/FunctionsJSON.h\n+++ b/src/Functions/FunctionsJSON.h\n@@ -25,6 +25,7 @@\n #include <DataTypes/DataTypeTuple.h>\n #include <Interpreters/Context.h>\n #include <ext/range.h>\n+#include <type_traits>\n #include <boost/tti/has_member_function.hpp>\n \n #if !defined(ARCADIA_BUILD)\n@@ -507,11 +508,20 @@ class JSONExtractNumericImpl\n         }\n         else if (element.isDouble())\n         {\n-            if (!accurate::convertNumeric(element.getDouble(), value))\n+            if constexpr (std::is_floating_point_v<NumberType>)\n+            {\n+                /// We permit inaccurate conversion of double to float.\n+                /// Example: double 0.1 from JSON is not representable in float.\n+                /// But it will be more convenient for user to perform conversion.\n+                value = element.getDouble();\n+            }\n+            else if (!accurate::convertNumeric(element.getDouble(), value))\n                 return false;\n         }\n         else if (element.isBool() && is_integer_v<NumberType> && convert_bool_to_integer)\n+        {\n             value = static_cast<NumberType>(element.getBool());\n+        }\n         else\n             return false;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01685_json_extract_double_as_float.reference b/tests/queries/0_stateless/01685_json_extract_double_as_float.reference\nnew file mode 100644\nindex 000000000000..f3f4206b4255\n--- /dev/null\n+++ b/tests/queries/0_stateless/01685_json_extract_double_as_float.reference\n@@ -0,0 +1,10 @@\n+1.1\t1.1\t1.1\t1.1\n+0.01\t0.01\t0.01\t0.01\n+0\n+\\N\n+-1e300\n+-inf\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/01685_json_extract_double_as_float.sql b/tests/queries/0_stateless/01685_json_extract_double_as_float.sql\nnew file mode 100644\nindex 000000000000..c9aa25180852\n--- /dev/null\n+++ b/tests/queries/0_stateless/01685_json_extract_double_as_float.sql\n@@ -0,0 +1,24 @@\n+WITH '{ \"v\":1.1}' AS raw\n+SELECT\n+    JSONExtract(raw, 'v', 'float') AS float32_1,\n+    JSONExtract(raw, 'v', 'Float32') AS float32_2,\n+    JSONExtractFloat(raw, 'v') AS float64_1,\n+    JSONExtract(raw, 'v', 'double') AS float64_2;\n+\n+WITH '{ \"v\":1E-2}' AS raw\n+SELECT\n+    JSONExtract(raw, 'v', 'float') AS float32_1,\n+    JSONExtract(raw, 'v', 'Float32') AS float32_2,\n+    JSONExtractFloat(raw, 'v') AS float64_1,\n+    JSONExtract(raw, 'v', 'double') AS float64_2;\n+\n+SELECT JSONExtract('{\"v\":1.1}', 'v', 'UInt64');\n+SELECT JSONExtract('{\"v\":1.1}', 'v', 'Nullable(UInt64)');\n+\n+SELECT JSONExtract('{\"v\":-1e300}', 'v', 'Float64');\n+SELECT JSONExtract('{\"v\":-1e300}', 'v', 'Float32');\n+\n+SELECT JSONExtract('{\"v\":-1e300}', 'v', 'UInt64');\n+SELECT JSONExtract('{\"v\":-1e300}', 'v', 'Int64');\n+SELECT JSONExtract('{\"v\":-1e300}', 'v', 'UInt8');\n+SELECT JSONExtract('{\"v\":-1e300}', 'v', 'Int8');\n",
  "problem_statement": "JSONExtract returns 0 for numbers with floating-point for type float / Float32\n**Describe the bug**\r\n\r\nJSONExtract returns 0 for numbers with floating-point for type *float / Float32*.\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nWITH '{ \"v\":1.1}' AS raw\r\nSELECT \r\n    JSONExtract(raw, 'v', 'float') AS float32_1,\r\n    JSONExtract(raw, 'v', 'Float32') AS float32_2,\r\n    JSONExtractFloat(raw, 'v') AS float64_1,\r\n    JSONExtract(raw, 'v', 'double') AS float64_2\r\n\r\n/*\r\n\u250c\u2500float32_1\u2500\u252c\u2500float32_2\u2500\u252c\u2500float64_1\u2500\u252c\u2500float64_2\u2500\u2510\r\n\u2502         0 \u2502         0 \u2502       1.1 \u2502       1.1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n*/\r\n```\r\n\r\n```sql\r\nWITH '{ \"v\":1E-2}' AS raw\r\nSELECT \r\n    JSONExtract(raw, 'v', 'float') AS float32_1,\r\n    JSONExtract(raw, 'v', 'Float32') AS float32_2,\r\n    JSONExtractFloat(raw, 'v') AS float64_1,\r\n    JSONExtract(raw, 'v', 'double') AS float64_2\r\n\r\n/*\r\n\u250c\u2500float32_1\u2500\u252c\u2500float32_2\u2500\u252c\u2500float64_1\u2500\u252c\u2500float64_2\u2500\u2510\r\n\u2502         0 \u2502         0 \u2502      0.01 \u2502      0.01 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n*/\r\n```\r\n\r\n**Expected behavior**\r\n\r\nI think either need to add support *float / Float32* type or throw an exception to point to need to use *double / Float64* type.\r\n\r\n**Additional context**\r\nCH v. 20.6.4.44\r\n\n",
  "hints_text": "@vitlibar Maybe you can help?\nThe reason is quite stupid: 0.1 in JSON is treat as double and Float64(0.1) is not representable in Float32.\nAlso note that we do accurate conversions to integers. Example: `JSONExtract('{\"v\":1.1}', 'v', 'UInt64')` will return 0 and `JSONExtract('{\"v\":1.1}', 'v', 'Nullable(UInt64)')` will return NULL.",
  "created_at": "2021-02-02T04:20:38Z",
  "modified_files": [
    "src/Functions/FunctionsJSON.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01685_json_extract_double_as_float.reference",
    "b/tests/queries/0_stateless/01685_json_extract_double_as_float.sql"
  ]
}