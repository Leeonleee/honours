diff --git a/src/Functions/array/FunctionArrayMapped.h b/src/Functions/array/FunctionArrayMapped.h
index 89599edd9d10..5092698d01c0 100644
--- a/src/Functions/array/FunctionArrayMapped.h
+++ b/src/Functions/array/FunctionArrayMapped.h
@@ -75,6 +75,10 @@ const IColumn::Offsets & getOffsets(const T & column)
   * arrayMap(x1,...,xn -> expression, array1,...,arrayn) - apply the expression to each element of the array (or set of parallel arrays).
   * arrayFilter(x -> predicate, array) - leave in the array only the elements for which the expression is true.
   *
+  * It is possible for the functions to require fixed number of positional arguments:
+  * arrayPartialSort(limit, arr)
+  * arrayPartialSort(x -> predicate, limit, arr)
+  *
   * For some functions arrayCount, arrayExists, arrayAll, an overload of the form f(array) is available,
   *  which works in the same way as f(x -> x, array).
   *
@@ -88,12 +92,12 @@ class FunctionArrayMapped : public IFunction
     static constexpr bool is_argument_type_map = std::is_same_v<typename Impl::data_type, DataTypeMap>;
     static constexpr bool is_argument_type_array = std::is_same_v<typename Impl::data_type, DataTypeArray>;
     static constexpr auto argument_type_name = is_argument_type_map ? "Map" : "Array";
+
+    static constexpr size_t num_fixed_params = []{ if constexpr (requires { Impl::num_fixed_params; }) return Impl::num_fixed_params; else return 0; }();
+
     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayMapped>(); }
 
-    String getName() const override
-    {
-        return name;
-    }
+    String getName() const override { return name; }
 
     bool isVariadic() const override { return true; }
     size_t getNumberOfArguments() const override { return 0; }
@@ -104,30 +108,41 @@ class FunctionArrayMapped : public IFunction
     void getLambdaArgumentTypes(DataTypes & arguments) const override
     {
         if (arguments.empty())
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                            "Function {} needs at least one argument, passed {}", getName(), arguments.size());
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Function {} needs at least one argument, passed {}",
+                getName(),
+                arguments.size());
 
-        if (arguments.size() == 1)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                            "Function {} needs at least one argument with data", getName());
+        if (arguments.size() <= 1 + num_fixed_params)
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Function {} needs at least {} argument{} with data",
+                getName(),
+                num_fixed_params + 1,
+                (num_fixed_params + 1 == 1) ? "" : "s");
 
-        if (arguments.size() > 2 && Impl::needOneArray())
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                            "Function {} needs one argument with data", getName());
+        if (arguments.size() > 2 + num_fixed_params && Impl::needOneArray())
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Function {} needs {} argument{} with data",
+                getName(),
+                num_fixed_params + 1,
+                (num_fixed_params + 1 == 1) ? "" : "s");
 
-        size_t nested_types_count = is_argument_type_map ? (arguments.size() - 1) * 2 : (arguments.size() - 1);
+        size_t nested_types_count = (arguments.size() - num_fixed_params - 1) * (is_argument_type_map ? 2 : 1);
         DataTypes nested_types(nested_types_count);
-        for (size_t i = 0; i < arguments.size() - 1; ++i)
+        for (size_t i = 0; i < arguments.size() - 1 - num_fixed_params; ++i)
         {
-            const auto * array_type = checkAndGetDataType<typename Impl::data_type>(&*arguments[i + 1]);
+            const auto * array_type = checkAndGetDataType<typename Impl::data_type>(&*arguments[i + 1 + num_fixed_params]);
             if (!array_type)
                 throw Exception(
                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "Argument {} of function {} must be {}. Found {} instead",
-                    toString(i + 2),
+                    i + 2 + num_fixed_params,
                     getName(),
                     argument_type_name,
-                    arguments[i + 1]->getName());
+                    arguments[i + 1 + num_fixed_params]->getName());
             if constexpr (is_argument_type_map)
             {
                 nested_types[2 * i] = recursiveRemoveLowCardinality(array_type->getKeyType());
@@ -144,32 +159,53 @@ class FunctionArrayMapped : public IFunction
             throw Exception(
                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                 "First argument for this overload of {} must be a function with {} arguments, found {} instead",
-                getName(), nested_types.size(), arguments[0]->getName());
+                getName(),
+                nested_types.size(),
+                arguments[0]->getName());
 
         arguments[0] = std::make_shared<DataTypeFunction>(nested_types);
     }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
-        size_t min_args = Impl::needExpression() ? 2 : 1;
+        size_t min_args = (Impl::needExpression() ? 2 : 1) + num_fixed_params ;
         if (arguments.size() < min_args)
-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                            "Function {} needs at least {} argument, passed {}",
-                            getName(), min_args, arguments.size());
-
-        if ((arguments.size() == 1) && is_argument_type_array)
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Function {} needs at least {} argument{}, passed {}",
+                getName(),
+                min_args,
+                (min_args > 1 ? "s" : ""),
+                arguments.size());
+
+        if ((arguments.size() == 1 + num_fixed_params) && is_argument_type_array)
         {
-            const auto * data_type = checkAndGetDataType<typename Impl::data_type>(arguments[0].type.get());
+            const auto * data_type = checkAndGetDataType<typename Impl::data_type>(arguments[num_fixed_params].type.get());
 
             if (!data_type)
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The only argument for function {} must be array. "
-                                "Found {} instead", getName(), arguments[0].type->getName());
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "The {}{}{} argument for function {} must be array. Found {} instead",
+                    num_fixed_params + 1,
+                    getOrdinalSuffix(num_fixed_params + 1),
+                    (num_fixed_params == 0 ? " and only" : ""),
+                    getName(),
+                    arguments[num_fixed_params].type->getName());
+
+            if constexpr (num_fixed_params)
+                Impl::checkArguments(getName(), arguments.data());
 
             DataTypePtr nested_type = data_type->getNestedType();
 
             if (Impl::needBoolean() && !isUInt8(nested_type))
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "The only argument for function {} must be array of UInt8. "
-                                "Found {} instead", getName(), arguments[0].type->getName());
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "The {}{}{} argument for function {} must be array of UInt8. Found {} instead",
+                    num_fixed_params + 1,
+                    getOrdinalSuffix(num_fixed_params + 1),
+                    (num_fixed_params == 0 ? " and only" : ""),
+                    getName(),
+                    arguments[num_fixed_params].type->getName());
 
             if constexpr (is_argument_type_array)
                 return Impl::getReturnType(nested_type, nested_type);
@@ -178,17 +214,21 @@ class FunctionArrayMapped : public IFunction
         }
         else
         {
-            if (arguments.size() > 2 && Impl::needOneArray())
+            if (arguments.size() > 2 + num_fixed_params && Impl::needOneArray())
                 throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Function {} needs one argument with data", getName());
 
             const auto * data_type_function = checkAndGetDataType<DataTypeFunction>(arguments[0].type.get());
 
             if (!data_type_function)
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                     "First argument for function {} must be a function. Actual {}",
                     getName(),
                     arguments[0].type->getName());
 
+            if constexpr (num_fixed_params)
+                Impl::checkArguments(getName(), arguments.data() + 1);
+
             /// The types of the remaining arguments are already checked in getLambdaArgumentTypes.
 
             DataTypePtr return_type = removeLowCardinality(data_type_function->getReturnType());
@@ -199,21 +239,24 @@ class FunctionArrayMapped : public IFunction
             ///  - lambda may return Nothing or Nullable(Nothing) because of default implementation of functions
             ///    for these types. In this case we will just create UInt8 const column full of 0.
             if (Impl::needBoolean() && !isUInt8(removeNullable(return_type)) && !isNothing(removeNullable(return_type)))
-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                                "Expression for function {} must return UInt8 or Nullable(UInt8), found {}",
-                                getName(), return_type->getName());
+                throw Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                    "Expression for function {} must return UInt8 or Nullable(UInt8), found {}",
+                    getName(),
+                    return_type->getName());
 
             static_assert(is_argument_type_map || is_argument_type_array, "unsupported type");
 
-            if (arguments.size() < 2)
+            if (arguments.size() < 2 + num_fixed_params)
             {
                 throw DB::Exception(ErrorCodes::LOGICAL_ERROR, "Incorrect number of arguments: {}", arguments.size());
             }
 
-            const auto * first_array_type = checkAndGetDataType<typename Impl::data_type>(arguments[1].type.get());
+            const auto * first_array_type = checkAndGetDataType<typename Impl::data_type>(arguments[1 + num_fixed_params].type.get());
 
             if (!first_array_type)
-                throw DB::Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Unsupported type {}", arguments[1].type->getName());
+                throw DB::Exception(
+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Unsupported type {}", arguments[1 + num_fixed_params].type->getName());
 
             if constexpr (is_argument_type_array)
                 return Impl::getReturnType(return_type, first_array_type->getNestedType());
@@ -227,9 +270,9 @@ class FunctionArrayMapped : public IFunction
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override
     {
-        if (arguments.size() == 1)
+        if (arguments.size() == 1 + num_fixed_params)
         {
-            ColumnPtr column_array_ptr = arguments[0].column;
+            ColumnPtr column_array_ptr = arguments[num_fixed_params].column;
             const auto * column_array = checkAndGetColumn<typename Impl::column_type>(column_array_ptr.get());
 
             if (!column_array)
@@ -237,21 +280,30 @@ class FunctionArrayMapped : public IFunction
                 const ColumnConst * column_const_array = checkAndGetColumnConst<typename Impl::column_type>(column_array_ptr.get());
                 if (!column_const_array)
                     throw Exception(
-                        ErrorCodes::ILLEGAL_COLUMN,
-                        "Expected {} column, found {}",
-                        argument_type_name,
-                        column_array_ptr->getName());
+                        ErrorCodes::ILLEGAL_COLUMN, "Expected {} column, found {}", argument_type_name, column_array_ptr->getName());
                 column_array_ptr = column_const_array->convertToFullColumn();
                 column_array = assert_cast<const typename Impl::column_type *>(column_array_ptr.get());
             }
 
             if constexpr (std::is_same_v<typename Impl::column_type, ColumnMap>)
             {
-                return Impl::execute(*column_array, column_array->getNestedColumn().getDataPtr());
+                if constexpr (num_fixed_params)
+                    return Impl::execute(
+                        *column_array,
+                        column_array->getNestedColumn().getDataPtr(),
+                        arguments.data());
+                else
+                    return Impl::execute(*column_array, column_array->getNestedColumn().getDataPtr());
             }
             else
             {
-                return Impl::execute(*column_array, column_array->getDataPtr());
+                if constexpr (num_fixed_params)
+                    return Impl::execute(
+                        *column_array,
+                        column_array->getDataPtr(),
+                        arguments.data());
+                else
+                    return Impl::execute(*column_array, column_array->getDataPtr());
             }
         }
         else
@@ -274,7 +326,7 @@ class FunctionArrayMapped : public IFunction
             ColumnsWithTypeAndName arrays;
             arrays.reserve(arguments.size() - 1);
 
-            for (size_t i = 1; i < arguments.size(); ++i)
+            for (size_t i = 1 + num_fixed_params; i < arguments.size(); ++i)
             {
                 const auto & array_with_type_and_name = arguments[i];
 
@@ -314,7 +366,7 @@ class FunctionArrayMapped : public IFunction
                             getName());
                 }
 
-                if (i == 1)
+                if (i == 1 + num_fixed_params)
                 {
                     column_first_array_ptr = column_array_ptr;
                     column_first_array = column_array;
@@ -380,7 +432,13 @@ class FunctionArrayMapped : public IFunction
                 }
             }
 
-            return Impl::execute(*column_first_array, lambda_result.column);
+            if constexpr (num_fixed_params)
+                return Impl::execute(
+                    *column_first_array,
+                    lambda_result.column,
+                    arguments.data() + 1);
+            else
+                return Impl::execute(*column_first_array, lambda_result.column);
         }
     }
 };
diff --git a/src/Functions/array/arraySort.cpp b/src/Functions/array/arraySort.cpp
index 34c2881a4131..0188324bc198 100644
--- a/src/Functions/array/arraySort.cpp
+++ b/src/Functions/array/arraySort.cpp
@@ -1,19 +1,27 @@
 #include "FunctionArrayMapped.h"
 
-#include <base/sort.h>
 #include <Functions/FunctionFactory.h>
+#include <base/sort.h>
 
 namespace DB
 {
 
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int LOGICAL_ERROR;
+}
+
 /** Sort arrays, by values of its elements, or by values of corresponding elements of calculated expression (known as "schwartzsort").
   */
-template <bool positive>
+template <bool positive, bool is_partial>
 struct ArraySortImpl
 {
     using column_type = ColumnArray;
     using data_type = DataTypeArray;
 
+    static constexpr auto num_fixed_params = is_partial;
+
     static bool needBoolean() { return false; }
     static bool needExpression() { return false; }
     static bool needOneArray() { return false; }
@@ -27,7 +35,7 @@ struct ArraySortImpl
     {
         const IColumn & column;
 
-        explicit Less(const IColumn & column_) : column(column_) {}
+        explicit Less(const IColumn & column_) : column(column_) { }
 
         bool operator()(size_t lhs, size_t rhs) const
         {
@@ -38,8 +46,42 @@ struct ArraySortImpl
         }
     };
 
-    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)
+    static void checkArguments(const String & name, const ColumnWithTypeAndName * fixed_arguments)
+        requires(num_fixed_params)
     {
+        if (!fixed_arguments)
+            throw Exception(
+                ErrorCodes::LOGICAL_ERROR,
+                "Expected fixed arguments to get the limit for partial array sort"
+            );
+        WhichDataType which(fixed_arguments[0].type.get());
+        if (!which.isUInt() && !which.isInt())
+            throw Exception(
+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
+                "Illegal type {} of limit argument of function {} (must be UInt or Int)",
+                fixed_arguments[0].type->getName(),
+                name);
+    }
+
+    static ColumnPtr execute(
+        const ColumnArray & array,
+        ColumnPtr mapped,
+        const ColumnWithTypeAndName * fixed_arguments [[maybe_unused]] = nullptr)
+    {
+        [[maybe_unused]] const auto limit = [&]() -> size_t
+        {
+            if constexpr (is_partial)
+            {
+                if (!fixed_arguments)
+                    throw Exception(
+                        ErrorCodes::LOGICAL_ERROR,
+                        "Expected fixed arguments to get the limit for partial array sort"
+                    );
+                return fixed_arguments[0].column.get()->getUInt(0);
+            }
+            return 0;
+        }();
+
         const ColumnArray::Offsets & offsets = array.getOffsets();
 
         size_t size = offsets.size();
@@ -53,7 +95,18 @@ struct ArraySortImpl
         for (size_t i = 0; i < size; ++i)
         {
             auto next_offset = offsets[i];
-            ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));
+            if constexpr (is_partial)
+            {
+                if (limit)
+                {
+                    const auto effective_limit = std::min<size_t>(limit, next_offset - current_offset);
+                    ::partial_sort(&permutation[current_offset], &permutation[current_offset + effective_limit], &permutation[next_offset], Less(*mapped));
+                }
+                else
+                    ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));
+            }
+            else
+                ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));
             current_offset = next_offset;
         }
 
@@ -61,17 +114,87 @@ struct ArraySortImpl
     }
 };
 
-struct NameArraySort { static constexpr auto name = "arraySort"; };
-struct NameArrayReverseSort { static constexpr auto name = "arrayReverseSort"; };
+struct NameArraySort
+{
+    static constexpr auto name = "arraySort";
+};
+struct NameArrayReverseSort
+{
+    static constexpr auto name = "arrayReverseSort";
+};
+struct NameArrayPartialSort
+{
+    static constexpr auto name = "arrayPartialSort";
+};
+struct NameArrayPartialReverseSort
+{
+    static constexpr auto name = "arrayPartialReverseSort";
+};
 
-using FunctionArraySort = FunctionArrayMapped<ArraySortImpl<true>, NameArraySort>;
-using FunctionArrayReverseSort = FunctionArrayMapped<ArraySortImpl<false>, NameArrayReverseSort>;
+using FunctionArraySort = FunctionArrayMapped<ArraySortImpl<true, false>, NameArraySort>;
+using FunctionArrayReverseSort = FunctionArrayMapped<ArraySortImpl<false, false>, NameArrayReverseSort>;
+using FunctionArrayPartialSort = FunctionArrayMapped<ArraySortImpl<true, true>, NameArrayPartialSort>;
+using FunctionArrayPartialReverseSort = FunctionArrayMapped<ArraySortImpl<false, true>, NameArrayPartialReverseSort>;
 
 REGISTER_FUNCTION(ArraySort)
 {
     factory.registerFunction<FunctionArraySort>();
     factory.registerFunction<FunctionArrayReverseSort>();
-}
 
+    factory.registerFunction<FunctionArrayPartialSort>({
+        R"(
+Returns an array of the same size as the original array where elements in range `[1..limit]`
+are sorted in ascending order. Remaining elements `(limit..N]` shall contain elements in unspecified order.
+[example:simple_int]
+[example:simple_string]
+
+To retain only the sorted elements use `arrayResize`:
+[example:retain_sorted]
+
+If the `func` function is specified, sorting order is determined by the result of the `func`
+function applied to the elements of the array.
+[example:lambda_simple]
+
+If `func` accepts multiple arguments, the `arrayPartialSort` function is passed several arrays
+that the arguments of `func` will correspond to.
+[example:lambda_complex]
+
+For more details see documentation of `arraySort`.
+)",
+        Documentation::Examples{
+            {"simple_int", "SELECT arrayPartialSort(2, [5, 9, 1, 3])"},
+            {"simple_string", "SELECT arrayPartialSort(2, ['expenses','lasso','embolism','gladly'])"},
+            {"retain_sorted", "SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)"},
+            {"lambda_simple", "SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])"},
+            {"lambda_complex", "SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res"}},
+        Documentation::Categories{"Array"}});
+    factory.registerFunction<FunctionArrayPartialReverseSort>({
+        R"(
+Returns an array of the same size as the original array where elements in range `[1..limit]`
+are sorted in descending order. Remaining elements `(limit..N]` shall contain elements in unspecified order.
+[example:simple_int]
+[example:simple_string]
+
+To retain only the sorted elements use `arrayResize`:
+[example:retain_sorted]
+
+If the `func` function is specified, sorting order is determined by the result of the `func`
+function applied to the elements of the array.
+[example:lambda_simple]
+
+If `func` accepts multiple arguments, the `arrayPartialSort` function is passed several arrays
+that the arguments of `func` will correspond to.
+[example:lambda_complex]
+
+For more details see documentation of `arraySort`.
+)",
+        Documentation::Examples{
+            {"simple_int", "SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])"},
+            {"simple_string", "SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])"},
+            {"retain_sorted", "SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)"},
+            {"lambda_simple", "SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])"},
+            {"lambda_complex", "SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res"}},
+        Documentation::Categories{"Array"}});
 }
 
+}
