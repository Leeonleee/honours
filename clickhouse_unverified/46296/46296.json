{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 46296,
  "instance_id": "ClickHouse__ClickHouse-46296",
  "issue_numbers": [
    "11125"
  ],
  "base_commit": "b2fe7bf5c7c8acd652f8c50f39046057f1610981",
  "patch": "diff --git a/src/Functions/array/FunctionArrayMapped.h b/src/Functions/array/FunctionArrayMapped.h\nindex 89599edd9d10..5092698d01c0 100644\n--- a/src/Functions/array/FunctionArrayMapped.h\n+++ b/src/Functions/array/FunctionArrayMapped.h\n@@ -75,6 +75,10 @@ const IColumn::Offsets & getOffsets(const T & column)\n   * arrayMap(x1,...,xn -> expression, array1,...,arrayn) - apply the expression to each element of the array (or set of parallel arrays).\n   * arrayFilter(x -> predicate, array) - leave in the array only the elements for which the expression is true.\n   *\n+  * It is possible for the functions to require fixed number of positional arguments:\n+  * arrayPartialSort(limit, arr)\n+  * arrayPartialSort(x -> predicate, limit, arr)\n+  *\n   * For some functions arrayCount, arrayExists, arrayAll, an overload of the form f(array) is available,\n   *  which works in the same way as f(x -> x, array).\n   *\n@@ -88,12 +92,12 @@ class FunctionArrayMapped : public IFunction\n     static constexpr bool is_argument_type_map = std::is_same_v<typename Impl::data_type, DataTypeMap>;\n     static constexpr bool is_argument_type_array = std::is_same_v<typename Impl::data_type, DataTypeArray>;\n     static constexpr auto argument_type_name = is_argument_type_map ? \"Map\" : \"Array\";\n+\n+    static constexpr size_t num_fixed_params = []{ if constexpr (requires { Impl::num_fixed_params; }) return Impl::num_fixed_params; else return 0; }();\n+\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayMapped>(); }\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n+    String getName() const override { return name; }\n \n     bool isVariadic() const override { return true; }\n     size_t getNumberOfArguments() const override { return 0; }\n@@ -104,30 +108,41 @@ class FunctionArrayMapped : public IFunction\n     void getLambdaArgumentTypes(DataTypes & arguments) const override\n     {\n         if (arguments.empty())\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                            \"Function {} needs at least one argument, passed {}\", getName(), arguments.size());\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Function {} needs at least one argument, passed {}\",\n+                getName(),\n+                arguments.size());\n \n-        if (arguments.size() == 1)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                            \"Function {} needs at least one argument with data\", getName());\n+        if (arguments.size() <= 1 + num_fixed_params)\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Function {} needs at least {} argument{} with data\",\n+                getName(),\n+                num_fixed_params + 1,\n+                (num_fixed_params + 1 == 1) ? \"\" : \"s\");\n \n-        if (arguments.size() > 2 && Impl::needOneArray())\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                            \"Function {} needs one argument with data\", getName());\n+        if (arguments.size() > 2 + num_fixed_params && Impl::needOneArray())\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Function {} needs {} argument{} with data\",\n+                getName(),\n+                num_fixed_params + 1,\n+                (num_fixed_params + 1 == 1) ? \"\" : \"s\");\n \n-        size_t nested_types_count = is_argument_type_map ? (arguments.size() - 1) * 2 : (arguments.size() - 1);\n+        size_t nested_types_count = (arguments.size() - num_fixed_params - 1) * (is_argument_type_map ? 2 : 1);\n         DataTypes nested_types(nested_types_count);\n-        for (size_t i = 0; i < arguments.size() - 1; ++i)\n+        for (size_t i = 0; i < arguments.size() - 1 - num_fixed_params; ++i)\n         {\n-            const auto * array_type = checkAndGetDataType<typename Impl::data_type>(&*arguments[i + 1]);\n+            const auto * array_type = checkAndGetDataType<typename Impl::data_type>(&*arguments[i + 1 + num_fixed_params]);\n             if (!array_type)\n                 throw Exception(\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Argument {} of function {} must be {}. Found {} instead\",\n-                    toString(i + 2),\n+                    i + 2 + num_fixed_params,\n                     getName(),\n                     argument_type_name,\n-                    arguments[i + 1]->getName());\n+                    arguments[i + 1 + num_fixed_params]->getName());\n             if constexpr (is_argument_type_map)\n             {\n                 nested_types[2 * i] = recursiveRemoveLowCardinality(array_type->getKeyType());\n@@ -144,32 +159,53 @@ class FunctionArrayMapped : public IFunction\n             throw Exception(\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"First argument for this overload of {} must be a function with {} arguments, found {} instead\",\n-                getName(), nested_types.size(), arguments[0]->getName());\n+                getName(),\n+                nested_types.size(),\n+                arguments[0]->getName());\n \n         arguments[0] = std::make_shared<DataTypeFunction>(nested_types);\n     }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        size_t min_args = Impl::needExpression() ? 2 : 1;\n+        size_t min_args = (Impl::needExpression() ? 2 : 1) + num_fixed_params ;\n         if (arguments.size() < min_args)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                            \"Function {} needs at least {} argument, passed {}\",\n-                            getName(), min_args, arguments.size());\n-\n-        if ((arguments.size() == 1) && is_argument_type_array)\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Function {} needs at least {} argument{}, passed {}\",\n+                getName(),\n+                min_args,\n+                (min_args > 1 ? \"s\" : \"\"),\n+                arguments.size());\n+\n+        if ((arguments.size() == 1 + num_fixed_params) && is_argument_type_array)\n         {\n-            const auto * data_type = checkAndGetDataType<typename Impl::data_type>(arguments[0].type.get());\n+            const auto * data_type = checkAndGetDataType<typename Impl::data_type>(arguments[num_fixed_params].type.get());\n \n             if (!data_type)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be array. \"\n-                                \"Found {} instead\", getName(), arguments[0].type->getName());\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"The {}{}{} argument for function {} must be array. Found {} instead\",\n+                    num_fixed_params + 1,\n+                    getOrdinalSuffix(num_fixed_params + 1),\n+                    (num_fixed_params == 0 ? \" and only\" : \"\"),\n+                    getName(),\n+                    arguments[num_fixed_params].type->getName());\n+\n+            if constexpr (num_fixed_params)\n+                Impl::checkArguments(getName(), arguments.data());\n \n             DataTypePtr nested_type = data_type->getNestedType();\n \n             if (Impl::needBoolean() && !isUInt8(nested_type))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"The only argument for function {} must be array of UInt8. \"\n-                                \"Found {} instead\", getName(), arguments[0].type->getName());\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"The {}{}{} argument for function {} must be array of UInt8. Found {} instead\",\n+                    num_fixed_params + 1,\n+                    getOrdinalSuffix(num_fixed_params + 1),\n+                    (num_fixed_params == 0 ? \" and only\" : \"\"),\n+                    getName(),\n+                    arguments[num_fixed_params].type->getName());\n \n             if constexpr (is_argument_type_array)\n                 return Impl::getReturnType(nested_type, nested_type);\n@@ -178,17 +214,21 @@ class FunctionArrayMapped : public IFunction\n         }\n         else\n         {\n-            if (arguments.size() > 2 && Impl::needOneArray())\n+            if (arguments.size() > 2 + num_fixed_params && Impl::needOneArray())\n                 throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} needs one argument with data\", getName());\n \n             const auto * data_type_function = checkAndGetDataType<DataTypeFunction>(arguments[0].type.get());\n \n             if (!data_type_function)\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"First argument for function {} must be a function. Actual {}\",\n                     getName(),\n                     arguments[0].type->getName());\n \n+            if constexpr (num_fixed_params)\n+                Impl::checkArguments(getName(), arguments.data() + 1);\n+\n             /// The types of the remaining arguments are already checked in getLambdaArgumentTypes.\n \n             DataTypePtr return_type = removeLowCardinality(data_type_function->getReturnType());\n@@ -199,21 +239,24 @@ class FunctionArrayMapped : public IFunction\n             ///  - lambda may return Nothing or Nullable(Nothing) because of default implementation of functions\n             ///    for these types. In this case we will just create UInt8 const column full of 0.\n             if (Impl::needBoolean() && !isUInt8(removeNullable(return_type)) && !isNothing(removeNullable(return_type)))\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                                \"Expression for function {} must return UInt8 or Nullable(UInt8), found {}\",\n-                                getName(), return_type->getName());\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Expression for function {} must return UInt8 or Nullable(UInt8), found {}\",\n+                    getName(),\n+                    return_type->getName());\n \n             static_assert(is_argument_type_map || is_argument_type_array, \"unsupported type\");\n \n-            if (arguments.size() < 2)\n+            if (arguments.size() < 2 + num_fixed_params)\n             {\n                 throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"Incorrect number of arguments: {}\", arguments.size());\n             }\n \n-            const auto * first_array_type = checkAndGetDataType<typename Impl::data_type>(arguments[1].type.get());\n+            const auto * first_array_type = checkAndGetDataType<typename Impl::data_type>(arguments[1 + num_fixed_params].type.get());\n \n             if (!first_array_type)\n-                throw DB::Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Unsupported type {}\", arguments[1].type->getName());\n+                throw DB::Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Unsupported type {}\", arguments[1 + num_fixed_params].type->getName());\n \n             if constexpr (is_argument_type_array)\n                 return Impl::getReturnType(return_type, first_array_type->getNestedType());\n@@ -227,9 +270,9 @@ class FunctionArrayMapped : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n-        if (arguments.size() == 1)\n+        if (arguments.size() == 1 + num_fixed_params)\n         {\n-            ColumnPtr column_array_ptr = arguments[0].column;\n+            ColumnPtr column_array_ptr = arguments[num_fixed_params].column;\n             const auto * column_array = checkAndGetColumn<typename Impl::column_type>(column_array_ptr.get());\n \n             if (!column_array)\n@@ -237,21 +280,30 @@ class FunctionArrayMapped : public IFunction\n                 const ColumnConst * column_const_array = checkAndGetColumnConst<typename Impl::column_type>(column_array_ptr.get());\n                 if (!column_const_array)\n                     throw Exception(\n-                        ErrorCodes::ILLEGAL_COLUMN,\n-                        \"Expected {} column, found {}\",\n-                        argument_type_name,\n-                        column_array_ptr->getName());\n+                        ErrorCodes::ILLEGAL_COLUMN, \"Expected {} column, found {}\", argument_type_name, column_array_ptr->getName());\n                 column_array_ptr = column_const_array->convertToFullColumn();\n                 column_array = assert_cast<const typename Impl::column_type *>(column_array_ptr.get());\n             }\n \n             if constexpr (std::is_same_v<typename Impl::column_type, ColumnMap>)\n             {\n-                return Impl::execute(*column_array, column_array->getNestedColumn().getDataPtr());\n+                if constexpr (num_fixed_params)\n+                    return Impl::execute(\n+                        *column_array,\n+                        column_array->getNestedColumn().getDataPtr(),\n+                        arguments.data());\n+                else\n+                    return Impl::execute(*column_array, column_array->getNestedColumn().getDataPtr());\n             }\n             else\n             {\n-                return Impl::execute(*column_array, column_array->getDataPtr());\n+                if constexpr (num_fixed_params)\n+                    return Impl::execute(\n+                        *column_array,\n+                        column_array->getDataPtr(),\n+                        arguments.data());\n+                else\n+                    return Impl::execute(*column_array, column_array->getDataPtr());\n             }\n         }\n         else\n@@ -274,7 +326,7 @@ class FunctionArrayMapped : public IFunction\n             ColumnsWithTypeAndName arrays;\n             arrays.reserve(arguments.size() - 1);\n \n-            for (size_t i = 1; i < arguments.size(); ++i)\n+            for (size_t i = 1 + num_fixed_params; i < arguments.size(); ++i)\n             {\n                 const auto & array_with_type_and_name = arguments[i];\n \n@@ -314,7 +366,7 @@ class FunctionArrayMapped : public IFunction\n                             getName());\n                 }\n \n-                if (i == 1)\n+                if (i == 1 + num_fixed_params)\n                 {\n                     column_first_array_ptr = column_array_ptr;\n                     column_first_array = column_array;\n@@ -380,7 +432,13 @@ class FunctionArrayMapped : public IFunction\n                 }\n             }\n \n-            return Impl::execute(*column_first_array, lambda_result.column);\n+            if constexpr (num_fixed_params)\n+                return Impl::execute(\n+                    *column_first_array,\n+                    lambda_result.column,\n+                    arguments.data() + 1);\n+            else\n+                return Impl::execute(*column_first_array, lambda_result.column);\n         }\n     }\n };\ndiff --git a/src/Functions/array/arraySort.cpp b/src/Functions/array/arraySort.cpp\nindex 34c2881a4131..0188324bc198 100644\n--- a/src/Functions/array/arraySort.cpp\n+++ b/src/Functions/array/arraySort.cpp\n@@ -1,19 +1,27 @@\n #include \"FunctionArrayMapped.h\"\n \n-#include <base/sort.h>\n #include <Functions/FunctionFactory.h>\n+#include <base/sort.h>\n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n /** Sort arrays, by values of its elements, or by values of corresponding elements of calculated expression (known as \"schwartzsort\").\n   */\n-template <bool positive>\n+template <bool positive, bool is_partial>\n struct ArraySortImpl\n {\n     using column_type = ColumnArray;\n     using data_type = DataTypeArray;\n \n+    static constexpr auto num_fixed_params = is_partial;\n+\n     static bool needBoolean() { return false; }\n     static bool needExpression() { return false; }\n     static bool needOneArray() { return false; }\n@@ -27,7 +35,7 @@ struct ArraySortImpl\n     {\n         const IColumn & column;\n \n-        explicit Less(const IColumn & column_) : column(column_) {}\n+        explicit Less(const IColumn & column_) : column(column_) { }\n \n         bool operator()(size_t lhs, size_t rhs) const\n         {\n@@ -38,8 +46,42 @@ struct ArraySortImpl\n         }\n     };\n \n-    static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)\n+    static void checkArguments(const String & name, const ColumnWithTypeAndName * fixed_arguments)\n+        requires(num_fixed_params)\n     {\n+        if (!fixed_arguments)\n+            throw Exception(\n+                ErrorCodes::LOGICAL_ERROR,\n+                \"Expected fixed arguments to get the limit for partial array sort\"\n+            );\n+        WhichDataType which(fixed_arguments[0].type.get());\n+        if (!which.isUInt() && !which.isInt())\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type {} of limit argument of function {} (must be UInt or Int)\",\n+                fixed_arguments[0].type->getName(),\n+                name);\n+    }\n+\n+    static ColumnPtr execute(\n+        const ColumnArray & array,\n+        ColumnPtr mapped,\n+        const ColumnWithTypeAndName * fixed_arguments [[maybe_unused]] = nullptr)\n+    {\n+        [[maybe_unused]] const auto limit = [&]() -> size_t\n+        {\n+            if constexpr (is_partial)\n+            {\n+                if (!fixed_arguments)\n+                    throw Exception(\n+                        ErrorCodes::LOGICAL_ERROR,\n+                        \"Expected fixed arguments to get the limit for partial array sort\"\n+                    );\n+                return fixed_arguments[0].column.get()->getUInt(0);\n+            }\n+            return 0;\n+        }();\n+\n         const ColumnArray::Offsets & offsets = array.getOffsets();\n \n         size_t size = offsets.size();\n@@ -53,7 +95,18 @@ struct ArraySortImpl\n         for (size_t i = 0; i < size; ++i)\n         {\n             auto next_offset = offsets[i];\n-            ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));\n+            if constexpr (is_partial)\n+            {\n+                if (limit)\n+                {\n+                    const auto effective_limit = std::min<size_t>(limit, next_offset - current_offset);\n+                    ::partial_sort(&permutation[current_offset], &permutation[current_offset + effective_limit], &permutation[next_offset], Less(*mapped));\n+                }\n+                else\n+                    ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));\n+            }\n+            else\n+                ::sort(&permutation[current_offset], &permutation[next_offset], Less(*mapped));\n             current_offset = next_offset;\n         }\n \n@@ -61,17 +114,87 @@ struct ArraySortImpl\n     }\n };\n \n-struct NameArraySort { static constexpr auto name = \"arraySort\"; };\n-struct NameArrayReverseSort { static constexpr auto name = \"arrayReverseSort\"; };\n+struct NameArraySort\n+{\n+    static constexpr auto name = \"arraySort\";\n+};\n+struct NameArrayReverseSort\n+{\n+    static constexpr auto name = \"arrayReverseSort\";\n+};\n+struct NameArrayPartialSort\n+{\n+    static constexpr auto name = \"arrayPartialSort\";\n+};\n+struct NameArrayPartialReverseSort\n+{\n+    static constexpr auto name = \"arrayPartialReverseSort\";\n+};\n \n-using FunctionArraySort = FunctionArrayMapped<ArraySortImpl<true>, NameArraySort>;\n-using FunctionArrayReverseSort = FunctionArrayMapped<ArraySortImpl<false>, NameArrayReverseSort>;\n+using FunctionArraySort = FunctionArrayMapped<ArraySortImpl<true, false>, NameArraySort>;\n+using FunctionArrayReverseSort = FunctionArrayMapped<ArraySortImpl<false, false>, NameArrayReverseSort>;\n+using FunctionArrayPartialSort = FunctionArrayMapped<ArraySortImpl<true, true>, NameArrayPartialSort>;\n+using FunctionArrayPartialReverseSort = FunctionArrayMapped<ArraySortImpl<false, true>, NameArrayPartialReverseSort>;\n \n REGISTER_FUNCTION(ArraySort)\n {\n     factory.registerFunction<FunctionArraySort>();\n     factory.registerFunction<FunctionArrayReverseSort>();\n-}\n \n+    factory.registerFunction<FunctionArrayPartialSort>({\n+        R\"(\n+Returns an array of the same size as the original array where elements in range `[1..limit]`\n+are sorted in ascending order. Remaining elements `(limit..N]` shall contain elements in unspecified order.\n+[example:simple_int]\n+[example:simple_string]\n+\n+To retain only the sorted elements use `arrayResize`:\n+[example:retain_sorted]\n+\n+If the `func` function is specified, sorting order is determined by the result of the `func`\n+function applied to the elements of the array.\n+[example:lambda_simple]\n+\n+If `func` accepts multiple arguments, the `arrayPartialSort` function is passed several arrays\n+that the arguments of `func` will correspond to.\n+[example:lambda_complex]\n+\n+For more details see documentation of `arraySort`.\n+)\",\n+        Documentation::Examples{\n+            {\"simple_int\", \"SELECT arrayPartialSort(2, [5, 9, 1, 3])\"},\n+            {\"simple_string\", \"SELECT arrayPartialSort(2, ['expenses','lasso','embolism','gladly'])\"},\n+            {\"retain_sorted\", \"SELECT arrayResize(arrayPartialSort(2, [5, 9, 1, 3]), 2)\"},\n+            {\"lambda_simple\", \"SELECT arrayPartialSort((x) -> -x, 2, [5, 9, 1, 3])\"},\n+            {\"lambda_complex\", \"SELECT arrayPartialSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res\"}},\n+        Documentation::Categories{\"Array\"}});\n+    factory.registerFunction<FunctionArrayPartialReverseSort>({\n+        R\"(\n+Returns an array of the same size as the original array where elements in range `[1..limit]`\n+are sorted in descending order. Remaining elements `(limit..N]` shall contain elements in unspecified order.\n+[example:simple_int]\n+[example:simple_string]\n+\n+To retain only the sorted elements use `arrayResize`:\n+[example:retain_sorted]\n+\n+If the `func` function is specified, sorting order is determined by the result of the `func`\n+function applied to the elements of the array.\n+[example:lambda_simple]\n+\n+If `func` accepts multiple arguments, the `arrayPartialSort` function is passed several arrays\n+that the arguments of `func` will correspond to.\n+[example:lambda_complex]\n+\n+For more details see documentation of `arraySort`.\n+)\",\n+        Documentation::Examples{\n+            {\"simple_int\", \"SELECT arrayPartialReverseSort(2, [5, 9, 1, 3])\"},\n+            {\"simple_string\", \"SELECT arrayPartialReverseSort(2, ['expenses','lasso','embolism','gladly'])\"},\n+            {\"retain_sorted\", \"SELECT arrayResize(arrayPartialReverseSort(2, [5, 9, 1, 3]), 2)\"},\n+            {\"lambda_simple\", \"SELECT arrayPartialReverseSort((x) -> -x, 2, [5, 9, 1, 3])\"},\n+            {\"lambda_complex\", \"SELECT arrayPartialReverseSort((x, y) -> -y, 1, [0, 1, 2], [1, 2, 3]) as res\"}},\n+        Documentation::Categories{\"Array\"}});\n }\n \n+}\n",
  "test_patch": "diff --git a/tests/fuzz/all.dict b/tests/fuzz/all.dict\nindex 17ef7d2ab1ef..8ded66cbd0d7 100644\n--- a/tests/fuzz/all.dict\n+++ b/tests/fuzz/all.dict\n@@ -72,7 +72,9 @@\n \"arrayMap\"\n \"arrayMax\"\n \"arrayMin\"\n+\"arrayPartialReverseSort\"\n \"arrayPartialShuffle\"\n+\"arrayPartialSort\"\n \"arrayPopBack\"\n \"arrayPopFront\"\n \"arrayProduct\"\ndiff --git a/tests/fuzz/dictionaries/functions.dict b/tests/fuzz/dictionaries/functions.dict\nindex 877b26798468..dfadb645f3f7 100644\n--- a/tests/fuzz/dictionaries/functions.dict\n+++ b/tests/fuzz/dictionaries/functions.dict\n@@ -334,6 +334,8 @@\n \"wordShingleSimHash\"\n \"arrayCumSum\"\n \"arraySort\"\n+\"arrayPartialSort\"\n+\"arrayPartialReverseSort\"\n \"dumpColumnStructure\"\n \"multiSearchFirstIndex\"\n \"arrayReverseSplit\"\ndiff --git a/tests/queries/0_stateless/00390_array_sort.reference b/tests/queries/0_stateless/00390_array_sort.reference\nindex 732ab75930a7..bfc4de067b62 100644\n--- a/tests/queries/0_stateless/00390_array_sort.reference\n+++ b/tests/queries/0_stateless/00390_array_sort.reference\n@@ -25,3 +25,41 @@\n [7,6,5,4,3,2,1,0]\n []\n ['world','hello']\n+[9,4,8,10,5,2,3,7,1,6]\t4\t[10,9,8,7]\t[10,9,8,7]\n+[9,4,8,10,5,2,3,7,1,6]\t4\t[10,9,8,7]\t[10,9,8,7]\n+['9','4','8','10','5','2','3','7','1','6']\t4\t['9','8','7','6']\t['10','1','2','3']\n+['9','4','8','10','5','2','3','7','1','6']\t4\t['9','8','7','6']\t['10','1','2','3']\n+[[0,1,2,3],[0],[0,1],[0,1,2]]\t2\t[[0],[0,1]]\t[[0,1,2,3],[0,1,2]]\t[[0,1,2,3],[0,1,2]]\n+[[0,1,2,3],[0],[0,1],[0,1,2]]\t2\t[[0],[0,1]]\t[[0,1,2,3],[0,1,2]]\t[[0,1,2,3],[0,1,2]]\n+['476118317','873','1381','']\t3\t['','1381','476118317']\t['','873','1381']\n+['1','577349846663553','72']\t3\t['1','577349846663553','72']\t['1','72','577349846663553']\n+['181981357172','4167749']\t3\t['181981357172','4167749','']\t['4167749','181981357172','']\n+['962446486456','415994']\t3\t['415994','962446486456','']\t['415994','962446486456','']\n+['77667','936175','7','26','8']\t3\t['26','7','77667']\t['7','8','26']\n+['152285784','9','6979435','']\t3\t['','152285784','6979435']\t['','9','6979435']\n+['12742','4333384','853','32']\t3\t['12742','32','4333384']\t['32','853','12742']\n+['1336581123286','26','488']\t3\t['1336581123286','26','488']\t['26','488','1336581123286']\n+['117','','','3455837413562','']\t3\t['','','']\t['','','']\n+['441693','539393268817']\t3\t['441693','539393268817','']\t['441693','539393268817','']\n+[]\n+[]\n+[1,0]\n+[]\n+[3,2]\n+[]\n+[5,4]\n+[]\n+[7,6]\n+[]\n+['wrongly','ignore','relocate']\n+2\t[1,2]\n+2\t['1','10']\n+2\t[10,9]\n+2\t['9','8']\n+4\t[-inf,-4,1,2]\n+4\t[inf,3,2,1]\n+10\t[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]\n+10\t[-inf,-4,1,2,3,inf,nan,nan,NULL,NULL]\n+3\t[[1,2],[-10,-20],[10,20],[0,0],[-1.5,1]]\t[[-10,-20],[-1.5,1],[0,0]]\t[[10,20],[1,2],[0,0]]\t[[-10,-20],[-1.5,1],[0,0]]\n+0\t[NULL,9,4,8,10,5,2,3,7,1,6]\t[1,2,3,4,5,6,7,8,9,10,NULL]\t[10,9,8,7,6,5,4,3,2,1,NULL]\t[10,9,8,7,6,5,4,3,2,1,NULL]\n+10\t[NULL,9,4,8,10,5,2,3,7,1,6]\t[1,2,3,4,5,6,7,8,9,10,NULL]\t[10,9,8,7,6,5,4,3,2,1,NULL]\t[10,9,8,7,6,5,4,3,2,1,NULL]\ndiff --git a/tests/queries/0_stateless/00390_array_sort.sql b/tests/queries/0_stateless/00390_array_sort.sql\nindex e3417ca331c3..8c2307eb3bdd 100644\n--- a/tests/queries/0_stateless/00390_array_sort.sql\n+++ b/tests/queries/0_stateless/00390_array_sort.sql\n@@ -12,3 +12,43 @@ SELECT splitByChar('0', toString(intHash64(number))) AS arr, arraySort(arr) AS s\n SELECT arrayReverseSort(number % 2 ? emptyArrayUInt64() : range(number)) FROM system.numbers LIMIT 10;\n \n SELECT arraySort((x, y) -> y, ['hello', 'world'], [2, 1]);\n+\n+-- Using arrayResize to trim the unsorted bit of the array that is normally left in unspecified order\n+SELECT [9,4,8,10,5,2,3,7,1,6] AS arr, 4 AS lim, arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> -x, lim, arr), lim);\n+SELECT materialize([9,4,8,10,5,2,3,7,1,6]) AS arr, 4 AS lim, arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> -x, lim, arr), lim);\n+\n+SELECT arrayMap(x -> toString(x), [9,4,8,10,5,2,3,7,1,6]) AS arr, 4 AS lim, arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> reverse(x), lim, arr), lim);\n+SELECT arrayMap(x -> toString(x), materialize([9,4,8,10,5,2,3,7,1,6])) AS arr, 4 AS lim, arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> reverse(x), lim, arr), lim);\n+\n+SELECT arrayMap(x -> range(x), [4,1,2,3]) AS arr, 2 AS lim, arrayResize(arrayPartialSort(lim, arr), lim), arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> -length(x), lim, arr), lim);\n+SELECT arrayMap(x -> range(x), materialize([4,1,2,3])) AS arr, 2 AS lim, arrayResize(arrayPartialSort(lim, arr), lim), arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> -length(x), lim, arr), lim);\n+\n+SELECT splitByChar('0', toString(intHash64(number))) AS arr, 3 AS lim, arrayResize(arrayPartialSort(lim, arr), lim) AS sorted, arrayResize(arrayPartialSort(x -> toUInt64OrZero(x), lim, arr), lim) AS sorted_nums FROM system.numbers LIMIT 10;\n+\n+SELECT res FROM (SELECT arrayPartialReverseSort(2, number % 2 ? emptyArrayUInt64() : range(number)) AS arr, arrayResize(arr, if(empty(arr), 0, 2)) AS res FROM system.numbers LIMIT 10);\n+\n+SELECT arrayResize(arrayPartialSort((x, y) -> y, 3, ['directly','ignore','wrongly','relocate','upright'], [4,2,1,3,5]), 3);\n+\n+SELECT 2 as nelems, arrayResize(arrayPartialSort(nelems, [NULL,9,4,8,10,5,2,3,7,1,6]), nelems);\n+SELECT 2 as nelems, arrayResize(arrayPartialSort(nelems, [NULL,'9','4','8','10','5','2','3','7','1','6']), nelems);\n+SELECT 2 as nelems, arrayResize(arrayPartialReverseSort(nelems, [NULL,9,4,8,10,5,2,3,7,1,6]), nelems);\n+SELECT 2 as nelems, arrayResize(arrayPartialReverseSort(nelems, [NULL,'9','4','8','10','5','2','3','7','1','6']), nelems);\n+\n+\n+SELECT 4 as nelems, arrayResize(arrayPartialSort(nelems, [1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]), nelems);\n+SELECT 4 as nelems, arrayResize(arrayPartialSort((x) -> -x, nelems, [1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]), nelems);\n+SELECT 10 as nelems, arrayResize(arrayPartialSort(nelems, [1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]), nelems);\n+SELECT 10 as nelems, arrayResize(arrayPartialSort(nelems, [1, nan, 2, NULL, 3, nan, -4, NULL, inf, -inf]), nelems);\n+\n+SELECT 3 as nelems, [[1,2],[-10,-20],[10,20],[0,0],[-1.5,1]] as arr, arrayResize(arrayPartialSort(nelems, arr), nelems), arrayResize(arrayPartialReverseSort(nelems, arr), nelems), arrayResize(arrayPartialSort((x) -> arraySum(x), nelems, arr), nelems);\n+\n+SELECT 0 as nelems, [NULL,9,4,8,10,5,2,3,7,1,6] AS arr, arrayPartialSort(nelems, arr), arrayPartialReverseSort(nelems, arr), arrayPartialSort((x) -> -x, nelems, arr);\n+SELECT 10 as nelems, [NULL,9,4,8,10,5,2,3,7,1,6] AS arr, arrayPartialSort(nelems, arr), arrayPartialReverseSort(nelems, arr), arrayPartialSort((x) -> -x, nelems, arr);\n+\n+\n+SELECT arrayPartialSort([1,2,3]); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayPartialSort(2, [1,2,3], [1]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayPartialSort(2, [1,2,3], 3); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayPartialSort(arraySort([1,2,3]), [1,2,3]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayMap(x -> range(x), [4, 1, 2, 3]) AS arr, 100 AS lim, arrayResize(arrayPartialSort(arrayPartialSort(lim, arr), arr), lim), arrayResize(arrayPartialReverseSort(lim, arr), lim), arrayResize(arrayPartialSort(x -> (-length(x)), lim, arr), lim); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayPartialReverseSort(arraySort((x, y) -> y, [NULL, NULL], [NULL, NULL]), arr), arrayMap(x -> toString(x), [257, -9223372036854775807, 2, -2147483648, 2147483648, NULL, 65536, -2147483648, 2, 65535]) AS arr, NULL, 100 AS lim, 65536, arrayResize(arrayPartialSort(x -> reverse(x), lim, arr), lim) GROUP BY [NULL, 1023, -2, NULL, 255, '0', NULL, 9223372036854775806] WITH ROLLUP; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n",
  "problem_statement": "random permutation/selection for arrays\nImplement functions for generating random permutations and random selections of an array.\r\n\r\nI need permutations for generating randomization distribution in performance tests, and now have to emulate it with `order by rand()` which becomes painfully slow for big arrays. In contrast, shuffle algorithms work in linear time.\r\n\r\nSelections would also be useful in performance tests for bootstrapping confidence intervals for query run time.\n",
  "hints_text": "If you only need to select a single element from an array, you could do something like the following:\r\n`SELECT arrayElement(range(3), ((rand() % length(range(3))) + 1))`\n`arrayShuffle(arr)`\r\n`arrayPartialShuffle(arr, limit)`\r\n`arrayPartialSort(lambda_func, limit, arr...)`\r\n`arrayPartialReverseSort(lambda_func, limit, arr...)`\r\n\nDo you mean something like this (and related functions):\r\n```\r\nSELECT arrayShuffle([1, 2, 3, 4, 5, 6, 7, 8])\r\n\r\n\u250c\u2500arrayShuffle([1, 2, 3, 4, 5, 6, 7, 8])\u2500\u2510\r\n\u2502 [4,1,2,8,6,5,3,7]                      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT arrayShuffle(x -> (-x), [1, 2, 3, 4, 5, 6, 7, 8])\r\n\r\n\u250c\u2500arrayShuffle(lambda(tuple(x), negate(x)), [1, 2, 3, 4, 5, 6, 7, 8])\u2500\u2510\r\n\u2502 [-6,-4,-1,-5,-2,-7,-8,-3]                                           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nIf yes, then I could have a go.\nI've a question about `arrayPartialSort` and `arrayPartialReverseSort`. What is the desired syntax? Above we have:\r\n```\r\narrayPartialSort(lambda_func, limit, arr...)\r\narrayPartialReverseSort(lambda_func, limit, arr...)\r\n```\r\nI guess it would be nice to have a version with and without `lambda_func`?\r\n\r\nAlso, I was thinking about using `FunctionArrayMapped` - but I think it is fixed that it takes `(lambda, arr)`, `(lambda, arr...)` or `(arr)`, `(arr...)`. If that's the case should I see if it's OK to refactor and templatize it a bit more to support this new use case?",
  "created_at": "2023-02-11T11:30:22Z",
  "modified_files": [
    "src/Functions/array/FunctionArrayMapped.h",
    "src/Functions/array/arraySort.cpp"
  ],
  "modified_test_files": [
    "tests/fuzz/all.dict",
    "tests/fuzz/dictionaries/functions.dict",
    "tests/queries/0_stateless/00390_array_sort.reference",
    "tests/queries/0_stateless/00390_array_sort.sql"
  ]
}