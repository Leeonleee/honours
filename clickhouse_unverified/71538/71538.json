{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71538,
  "instance_id": "ClickHouse__ClickHouse-71538",
  "issue_numbers": [
    "65598"
  ],
  "base_commit": "a0013e0a96e2499ccc54b05c5ae3ea7b7d5eb03e",
  "patch": "diff --git a/src/Analyzer/QueryNode.h b/src/Analyzer/QueryNode.h\nindex aef0c8805bb9..2333fc56218d 100644\n--- a/src/Analyzer/QueryNode.h\n+++ b/src/Analyzer/QueryNode.h\n@@ -602,9 +602,21 @@ class QueryNode final : public IQueryTreeNode\n         return projection_columns;\n     }\n \n+    /// Returns true if query node is resolved, false otherwise\n+    bool isResolved() const\n+    {\n+        return !projection_columns.empty();\n+    }\n+\n     /// Resolve query node projection columns\n     void resolveProjectionColumns(NamesAndTypes projection_columns_value);\n \n+    /// Clear query node projection columns\n+    void clearProjectionColumns()\n+    {\n+        projection_columns.clear();\n+    }\n+\n     /// Remove unused projection columns\n     void removeUnusedProjectionColumns(const std::unordered_set<std::string> & used_projection_columns);\n \ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex cb3087af707c..c2eac8d008b7 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -2958,27 +2958,29 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             /// Replace storage with values storage of insertion block\n             if (StoragePtr storage = scope.context->getViewSource())\n             {\n-                QueryTreeNodePtr table_expression;\n+                QueryTreeNodePtr table_expression = in_second_argument;\n+\n                 /// Process possibly nested sub-selects\n-                for (auto * query_node = in_second_argument->as<QueryNode>(); query_node; query_node = table_expression->as<QueryNode>())\n-                    table_expression = extractLeftTableExpression(query_node->getJoinTree());\n+                while (table_expression)\n+                {\n+                    if (auto * query_node = table_expression->as<QueryNode>())\n+                        table_expression = extractLeftTableExpression(query_node->getJoinTree());\n+                    else if (auto * union_node = table_expression->as<UnionNode>())\n+                        table_expression = union_node->getQueries().getNodes().at(0);\n+                    else\n+                        break;\n+                }\n \n-                if (table_expression)\n+                TableNode * table_expression_table_node = table_expression ? table_expression->as<TableNode>() : nullptr;\n+\n+                if (table_expression_table_node &&\n+                    table_expression_table_node->getStorageID().getFullNameNotQuoted() == storage->getStorageID().getFullNameNotQuoted())\n                 {\n-                    if (auto * query_table_node = table_expression->as<TableNode>())\n-                    {\n-                        if (query_table_node->getStorageID().getFullNameNotQuoted() == storage->getStorageID().getFullNameNotQuoted())\n-                        {\n-                            auto replacement_table_expression = std::make_shared<TableNode>(storage, scope.context);\n-                            if (std::optional<TableExpressionModifiers> table_expression_modifiers = query_table_node->getTableExpressionModifiers())\n-                                replacement_table_expression->setTableExpressionModifiers(*table_expression_modifiers);\n-                            in_second_argument = in_second_argument->cloneAndReplace(table_expression, std::move(replacement_table_expression));\n-                        }\n-                    }\n+                    auto replacement_table_expression_table_node = table_expression_table_node->clone();\n+                    replacement_table_expression_table_node->as<TableNode &>().updateStorage(storage, scope.context);\n+                    in_second_argument = in_second_argument->cloneAndReplace(table_expression, std::move(replacement_table_expression_table_node));\n                 }\n             }\n-\n-            resolveExpressionNode(in_second_argument, scope, false /*allow_lambda_expression*/, true /*allow_table_expression*/);\n         }\n \n         /// Edge case when the first argument of IN is scalar subquery.\n@@ -5310,6 +5312,16 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n \n     auto & query_node_typed = query_node->as<QueryNode &>();\n \n+    /** It is unsafe to call resolveQuery on already resolved query node, because during identifier resolution process\n+      * we replace identifiers with expressions without aliases, also at the end of resolveQuery all aliases from all nodes will be removed.\n+      * For subsequent resolveQuery executions it is possible to have wrong projection header, because for nodes\n+      * with aliases projection name is alias.\n+      *\n+      * If for client it is necessary to resolve query node after clone, client must clear projection columns from query node before resolve.\n+      */\n+    if (query_node_typed.isResolved())\n+        return;\n+\n     if (query_node_typed.isCTE())\n         ctes_in_resolve_process.insert(query_node_typed.getCTEName());\n \n@@ -5675,6 +5687,9 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier\n {\n     auto & union_node_typed = union_node->as<UnionNode &>();\n \n+    if (union_node_typed.isResolved())\n+        return;\n+\n     if (union_node_typed.isCTE())\n         ctes_in_resolve_process.insert(union_node_typed.getCTEName());\n \ndiff --git a/src/Analyzer/UnionNode.cpp b/src/Analyzer/UnionNode.cpp\nindex 6f70f01e5190..545a6b2195be 100644\n--- a/src/Analyzer/UnionNode.cpp\n+++ b/src/Analyzer/UnionNode.cpp\n@@ -35,6 +35,7 @@ namespace ErrorCodes\n {\n     extern const int TYPE_MISMATCH;\n     extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n }\n \n UnionNode::UnionNode(ContextMutablePtr context_, SelectUnionMode union_mode_)\n@@ -50,6 +51,26 @@ UnionNode::UnionNode(ContextMutablePtr context_, SelectUnionMode union_mode_)\n     children[queries_child_index] = std::make_shared<ListNode>();\n }\n \n+bool UnionNode::isResolved() const\n+{\n+    for (const auto & query_node : getQueries().getNodes())\n+    {\n+        bool is_resolved = false;\n+\n+        if (auto * query_node_typed = query_node->as<QueryNode>())\n+            is_resolved = query_node_typed->isResolved();\n+        else if (auto * union_node_typed = query_node->as<UnionNode>())\n+            is_resolved = union_node_typed->isResolved();\n+        else\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected query tree node type in UNION node\");\n+\n+        if (!is_resolved)\n+            return false;\n+    }\n+\n+    return true;\n+}\n+\n NamesAndTypes UnionNode::computeProjectionColumns() const\n {\n     if (recursive_cte_table)\ndiff --git a/src/Analyzer/UnionNode.h b/src/Analyzer/UnionNode.h\nindex 40baad1ad57c..85d6afb1e478 100644\n--- a/src/Analyzer/UnionNode.h\n+++ b/src/Analyzer/UnionNode.h\n@@ -163,6 +163,9 @@ class UnionNode final : public IQueryTreeNode\n         return children[queries_child_index];\n     }\n \n+    /// Returns true if union node is resolved, false otherwise\n+    bool isResolved() const;\n+\n     /// Compute union node projection columns\n     NamesAndTypes computeProjectionColumns() const;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03262_analyzer_materialized_view_in_with_cte.reference b/tests/queries/0_stateless/03262_analyzer_materialized_view_in_with_cte.reference\nnew file mode 100644\nindex 000000000000..5ddf8439af5c\n--- /dev/null\n+++ b/tests/queries/0_stateless/03262_analyzer_materialized_view_in_with_cte.reference\n@@ -0,0 +1,1 @@\n+1\t2\t\\N\ttest\ndiff --git a/tests/queries/0_stateless/03262_analyzer_materialized_view_in_with_cte.sql b/tests/queries/0_stateless/03262_analyzer_materialized_view_in_with_cte.sql\nnew file mode 100644\nindex 000000000000..4543d336d14f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03262_analyzer_materialized_view_in_with_cte.sql\n@@ -0,0 +1,63 @@\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS mv_test;\n+DROP TABLE IF EXISTS mv_test_target;\n+DROP VIEW IF EXISTS mv_test_mv;\n+\n+CREATE TABLE mv_test\n+(\n+    `id` UInt64,\n+    `ref_id` UInt64,\n+    `final_id` Nullable(UInt64),\n+    `display` String\n+)\n+ENGINE = Log;\n+\n+CREATE TABLE mv_test_target\n+(\n+    `id` UInt64,\n+    `ref_id` UInt64,\n+    `final_id` Nullable(UInt64),\n+    `display` String\n+)\n+ENGINE = Log;\n+\n+CREATE MATERIALIZED VIEW mv_test_mv TO mv_test_target\n+(\n+    `id` UInt64,\n+    `ref_id` UInt64,\n+    `final_id` Nullable(UInt64),\n+    `display` String\n+)\n+AS WITH\n+    tester AS\n+    (\n+        SELECT\n+            id,\n+            ref_id,\n+            final_id,\n+            display\n+        FROM mv_test\n+    ),\n+    id_set AS\n+    (\n+        SELECT\n+            display,\n+            max(id) AS max_id\n+        FROM mv_test\n+        GROUP BY display\n+    )\n+SELECT *\n+FROM tester\n+WHERE id IN (\n+    SELECT max_id\n+    FROM id_set\n+);\n+\n+INSERT INTO mv_test ( id, ref_id, display) values ( 1, 2, 'test');\n+\n+SELECT * FROM mv_test_target;\n+\n+DROP VIEW mv_test_mv;\n+DROP TABLE mv_test_target;\n+DROP TABLE mv_test;\ndiff --git a/tests/queries/0_stateless/03263_analyzer_materialized_view_cte_nested.reference b/tests/queries/0_stateless/03263_analyzer_materialized_view_cte_nested.reference\nnew file mode 100644\nindex 000000000000..0cfbf08886fc\n--- /dev/null\n+++ b/tests/queries/0_stateless/03263_analyzer_materialized_view_cte_nested.reference\n@@ -0,0 +1,1 @@\n+2\ndiff --git a/tests/queries/0_stateless/03263_analyzer_materialized_view_cte_nested.sql b/tests/queries/0_stateless/03263_analyzer_materialized_view_cte_nested.sql\nnew file mode 100644\nindex 000000000000..4ea853a7c22a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03263_analyzer_materialized_view_cte_nested.sql\n@@ -0,0 +1,19 @@\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS test_table;\n+DROP VIEW IF EXISTS test_mv;\n+\n+CREATE TABLE test_table ENGINE = MergeTree ORDER BY tuple() AS SELECT 1 as col1;\n+\n+CREATE MATERIALIZED VIEW test_mv ENGINE = MergeTree ORDER BY tuple() AS\n+WITH\n+    subquery_on_source AS (SELECT col1 AS aliased FROM test_table),\n+    output AS (SELECT * FROM test_table WHERE col1 IN (SELECT aliased FROM subquery_on_source))\n+SELECT * FROM output;\n+\n+INSERT INTO test_table VALUES (2);\n+\n+SELECT * FROM test_mv;\n+\n+DROP VIEW test_mv;\n+DROP TABLE test_table;\n",
  "problem_statement": "Insert error for materialized views with multiple CTEs\n\r\n**Describe what's wrong**\r\n\r\nWe recently update from CH version ClickHouse 24.4.1.2088 to ClickHouse 24.5.3.5 and figured out the inserts on source tables with attached materialized view with multiple CTEs  result in an ' Not found column' error\r\n\r\nWe expect that the insert is accepted without errer as in the pervious version.\r\n\r\n\r\n**How to reproduce**\r\n\r\nYou can reproduce the error via:\r\n```\r\n CREATE TABLE mv_test\r\n(\r\n    `id` UInt64,\r\n    `ref_id` UInt64,\r\n    `final_id` Nullable(UInt64),\r\n    `display` String\r\n)\r\nENGINE = Log;\r\n\r\nCREATE TABLE mv_test_target\r\n(\r\n    `id` UInt64,\r\n    `ref_id` UInt64,\r\n    `final_id` Nullable(UInt64),\r\n    `display` String\r\n)\r\nENGINE = Log;\r\n\r\nCREATE MATERIALIZED VIEW mv_test_mv TO mv_test_target\r\n(\r\n    `id` UInt64,\r\n    `ref_id` UInt64,\r\n    `final_id` Nullable(UInt64),\r\n    `display` String\r\n)\r\nAS WITH\r\n    tester AS\r\n    (\r\n        SELECT\r\n            id,\r\n            ref_id,\r\n            final_id,\r\n            display\r\n        FROM mv_test\r\n    ),\r\n    id_set AS\r\n    (\r\n        SELECT\r\n            display,\r\n            max(id) AS max_id\r\n        FROM mv_test\r\n        GROUP BY display\r\n    )\r\nSELECT *\r\nFROM tester\r\nWHERE id IN (\r\n    SELECT max_id\r\n    FROM id_set\r\n);\r\n\r\ninsert into mv_test ( id, ref_id, display) values ( 1, 2, 'test');\r\n```\r\n\r\nOn my test system this results in an \r\n```\r\nCode: 10. DB::Exception: Not found column __table1.max_id: in block : while pushing to view default.mv_test_mv (eb544596-a97b-4c95-89af-4d8c6fc2c77a). (NOT_FOUND_COLUMN_IN_BLOCK) (version 24.5.3.5 (official build)\r\n```\r\n\r\n\r\n**Does it reproduce on the most recent release?**\r\nTested in version ClickHouse 24.5.3.5\r\n\r\n\r\n\n",
  "hints_text": "@KochetovNicolai  https://fiddle.clickhouse.com/20383894-5baf-4848-84ab-faa6c3c2678f worked in 24.4, works without experimental_analyzer\r\n\r\n\n@den-crane thanks for the hint about the experimental analyzer.\r\nUnfortunatly this is not an option for us. Hence we wait for a future fix.\nIt also reproduces when CTEs are inlined into the `SELECT` query.\nI've tested a number of variations on MV queries to try and isolate this failure in the new analyzer and it seems to happen specifically when a column being used in the subquery passed to a `where in` clause comes from a CTE _and_ the selected column(s) in the `where in` subquery include any aliases. Here's a simple demonstration:\r\n\r\n### this does not work:\r\n\r\nhttps://fiddle.clickhouse.com/2fe95db6-600e-4712-a39d-d24769e10e3c\r\n\r\n```sql\r\ncreate or replace table test_table engine=MergeTree order by tuple() as select 1 as col1;\r\n\r\ndrop view if exists test_mv;\r\ncreate materialized view test_mv engine=MergeTree order by tuple() as\r\nwith\r\n    subquery_on_source as (select col1 as aliased from test_table),\r\n    output as (select * from test_table where col1 in (select aliased from subquery_on_source))\r\nselect * from output;\r\n\r\ninsert into test_table values (2);\r\n```\r\n\r\n### this works:\r\n\r\nhttps://fiddle.clickhouse.com/3d65365f-4f37-4c4f-b0ec-0cafd40a2e9e\r\n\r\n```sql\r\ncreate or replace table test_table engine=MergeTree order by tuple() as select 1 as col1;\r\n\r\ndrop view if exists test_mv;\r\ncreate materialized view test_mv engine=MergeTree order by tuple() as\r\nwith\r\n    subquery_on_source as (select col1 from test_table),\r\n    output as (select * from test_table where col1 in (select col1 from subquery_on_source))\r\nselect * from output;\r\n\r\ninsert into test_table values (2);\r\n```\nSeeing the same behavior in Clickhouse Cloud (now analyzer is default) - a materialized view using a CTE contains an alias does not work with the experimental analyzer - if I set enable_analyzer=0 on the insert it runs.\r\n",
  "created_at": "2024-11-06T17:01:53Z"
}