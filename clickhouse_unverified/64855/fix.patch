diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp
index cfccc835d29a..840aff9ebfbc 100644
--- a/src/Interpreters/ActionsDAG.cpp
+++ b/src/Interpreters/ActionsDAG.cpp
@@ -1704,7 +1704,7 @@ void ActionsDAG::mergeNodes(ActionsDAG && second, NodeRawConstPtrs * out_outputs
     }
 }
 
-ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split_nodes, bool create_split_nodes_mapping) const
+ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split_nodes, bool create_split_nodes_mapping, bool avoid_duplicate_inputs) const
 {
     /// Split DAG into two parts.
     /// (first_nodes, first_outputs) is a part which will have split_list in result.
@@ -1718,6 +1718,14 @@ ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split
     /// List of nodes from current actions which are not inputs, but will be in second part.
     NodeRawConstPtrs new_inputs;
 
+    /// Avoid new inputs to have the same name as existing inputs.
+    /// It's allowed for DAG but may break Block invariant 'columns with identical name must have identical structure'.
+    std::unordered_set<std::string_view> duplicate_inputs;
+    size_t duplicate_counter = 0;
+    if (avoid_duplicate_inputs)
+        for (const auto * input : inputs)
+            duplicate_inputs.insert(input->result_name);
+
     struct Frame
     {
         const Node * node = nullptr;
@@ -1830,7 +1838,8 @@ ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split
                                 input_node.result_name = child->result_name;
                                 child_data.to_second = &second_nodes.emplace_back(std::move(input_node));
 
-                                new_inputs.push_back(child);
+                                if (child->type != ActionType::INPUT)
+                                    new_inputs.push_back(child);
                             }
                         }
 
@@ -1886,7 +1895,32 @@ ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split
 
     for (const auto * input : new_inputs)
     {
-        const auto & cur = data[input];
+        auto & cur = data[input];
+
+        if (avoid_duplicate_inputs)
+        {
+            bool is_name_updated = false;
+            while (!duplicate_inputs.insert(cur.to_first->result_name).second)
+            {
+                is_name_updated = true;
+                cur.to_first->result_name = fmt::format("{}_{}", input->result_name, duplicate_counter);
+                ++duplicate_counter;
+            }
+
+            if (is_name_updated)
+            {
+                Node input_node;
+                input_node.type = ActionType::INPUT;
+                input_node.result_type = cur.to_first->result_type;
+                input_node.result_name = cur.to_first->result_name;
+
+                auto * new_input = &second_nodes.emplace_back(std::move(input_node));
+                cur.to_second->type = ActionType::ALIAS;
+                cur.to_second->children = {new_input};
+                cur.to_second = new_input;
+            }
+        }
+
         second_inputs.push_back(cur.to_second);
         first_outputs.push_back(cur.to_first);
     }
diff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h
index 8c0e3f0e5763..7c6753ac9dea 100644
--- a/src/Interpreters/ActionsDAG.h
+++ b/src/Interpreters/ActionsDAG.h
@@ -343,7 +343,7 @@ class ActionsDAG
     ///   initial DAG    : (a, b, c, d, e) -> (w, x, y, z)  | 1 a 2 b 3 c 4 d 5 e 6      ->  1 2 3 4 5 6 w x y z
     ///   split (first)  : (a, c, d) -> (i, j, k, w, y)     | 1 a 2 b 3 c 4 d 5 e 6      ->  1 2 b 3 4 5 e 6 i j k w y
     ///   split (second) : (i, j, k, y, b, e) -> (x, y, z)  | 1 2 b 3 4 5 e 6 i j k w y  ->  1 2 3 4 5 6 w x y z
-    SplitResult split(std::unordered_set<const Node *> split_nodes, bool create_split_nodes_mapping = false) const;
+    SplitResult split(std::unordered_set<const Node *> split_nodes, bool create_split_nodes_mapping = false, bool avoid_duplicate_inputs = false) const;
 
     /// Splits actions into two parts. Returned first half may be swapped with ARRAY JOIN.
     SplitResult splitActionsBeforeArrayJoin(const NameSet & array_joined_columns) const;
diff --git a/src/Processors/QueryPlan/Optimizations/optimizePrewhere.cpp b/src/Processors/QueryPlan/Optimizations/optimizePrewhere.cpp
index fbd9b451ddc6..74da7b8190fc 100644
--- a/src/Processors/QueryPlan/Optimizations/optimizePrewhere.cpp
+++ b/src/Processors/QueryPlan/Optimizations/optimizePrewhere.cpp
@@ -118,7 +118,7 @@ void optimizePrewhere(Stack & stack, QueryPlan::Nodes &)
         outputs.resize(size);
     }
 
-    auto split_result = filter_step->getExpression()->split(optimize_result.prewhere_nodes, true);
+    auto split_result = filter_step->getExpression()->split(optimize_result.prewhere_nodes, true, true);
 
     /// This is the leak of abstraction.
     /// Splited actions may have inputs which are needed only for PREWHERE.
