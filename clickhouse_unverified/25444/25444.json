{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25444,
  "instance_id": "ClickHouse__ClickHouse-25444",
  "issue_numbers": [
    "8205"
  ],
  "base_commit": "6662e7ab0feddeafd5d0507cea5cec38e6efc30a",
  "patch": "diff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex 6b8c470861db..7a529187c84d 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -210,7 +210,7 @@ void DatabaseAtomic::renameTable(ContextPtr local_context, const String & table_\n     std::unique_lock<std::mutex> other_db_lock;\n     if (inside_database)\n         db_lock = std::unique_lock{mutex};\n-    else  if (this < &other_db)\n+    else if (this < &other_db)\n     {\n         db_lock = std::unique_lock{mutex};\n         other_db_lock = std::unique_lock{other_db.mutex};\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 28d88bdd8df9..38e5b266e131 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -1101,6 +1101,7 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,\n         [[maybe_unused]] bool done = doCreateTable(create, properties);\n         assert(done);\n         ast_drop->table = create.table;\n+        ast_drop->is_dictionary = create.is_dictionary;\n         ast_drop->database = create.database;\n         ast_drop->kind = ASTDropQuery::Drop;\n         created = true;\n@@ -1113,14 +1114,18 @@ BlockIO InterpreterCreateQuery::doCreateOrReplaceTable(ASTCreateQuery & create,\n             ASTRenameQuery::Table{create.database, create.table},\n             ASTRenameQuery::Table{create.database, table_to_replace_name}\n         };\n+\n         ast_rename->elements.push_back(std::move(elem));\n         ast_rename->exchange = true;\n+        ast_rename->dictionary = create.is_dictionary;\n+\n         InterpreterRenameQuery(ast_rename, getContext()).execute();\n         replaced = true;\n \n         InterpreterDropQuery(ast_drop, getContext()).execute();\n \n         create.table = table_to_replace_name;\n+\n         return fillTableIfNeeded(create);\n     }\n     catch (...)\ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex d6d424beb3a7..be973a988bdf 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -305,8 +305,16 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n     }\n     else\n     {\n+        String action = \"CREATE\";\n+        if (attach)\n+            action = \"ATTACH\";\n+        else if (replace_table && create_or_replace)\n+            action = \"CREATE OR REPLACE\";\n+        else if (replace_table)\n+            action = \"REPLACE\";\n+\n         /// Always DICTIONARY\n-        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << (attach ? \"ATTACH \" : \"CREATE \") << \"DICTIONARY \"\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << action << \" DICTIONARY \"\n                       << (if_not_exists ? \"IF NOT EXISTS \" : \"\") << (settings.hilite ? hilite_none : \"\")\n                       << (!database.empty() ? backQuoteIfNeed(database) + \".\" : \"\") << backQuoteIfNeed(table);\n         if (uuid != UUIDHelpers::Nil)\ndiff --git a/src/Parsers/ASTRenameQuery.h b/src/Parsers/ASTRenameQuery.h\nindex 8d300f430b31..611f81dc9e9a 100644\n--- a/src/Parsers/ASTRenameQuery.h\n+++ b/src/Parsers/ASTRenameQuery.h\n@@ -75,12 +75,15 @@ class ASTRenameQuery : public ASTQueryWithOutput, public ASTQueryWithOnCluster\n         }\n \n         settings.ostr << (settings.hilite ? hilite_keyword : \"\");\n-        if (exchange)\n+        if (exchange && dictionary)\n+            settings.ostr << \"EXCHANGE DICTIONARIES \";\n+        else if (exchange)\n             settings.ostr << \"EXCHANGE TABLES \";\n         else if (dictionary)\n             settings.ostr << \"RENAME DICTIONARY \";\n         else\n             settings.ostr << \"RENAME TABLE \";\n+\n         settings.ostr << (settings.hilite ? hilite_none : \"\");\n \n         for (auto it = elements.cbegin(); it != elements.cend(); ++it)\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 23a53ed3244c..d4525883e363 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -971,6 +971,8 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n {\n     ParserKeyword s_create(\"CREATE\");\n     ParserKeyword s_attach(\"ATTACH\");\n+    ParserKeyword s_replace(\"REPLACE\");\n+    ParserKeyword s_or_replace(\"OR REPLACE\");\n     ParserKeyword s_dictionary(\"DICTIONARY\");\n     ParserKeyword s_if_not_exists(\"IF NOT EXISTS\");\n     ParserKeyword s_on(\"ON\");\n@@ -982,6 +984,8 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     ParserDictionary dictionary_p;\n \n     bool if_not_exists = false;\n+    bool replace = false;\n+    bool or_replace = false;\n \n     ASTPtr name;\n     ASTPtr attributes;\n@@ -989,13 +993,21 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     String cluster_str;\n \n     bool attach = false;\n-    if (!s_create.ignore(pos, expected))\n+\n+    if (s_create.ignore(pos, expected))\n     {\n-        if (s_attach.ignore(pos, expected))\n-            attach = true;\n-        else\n-            return false;\n+        if (s_or_replace.ignore(pos, expected))\n+        {\n+            replace = true;\n+            or_replace = true;\n+        }\n     }\n+    else if (s_attach.ignore(pos, expected))\n+        attach = true;\n+    else if (s_replace.ignore(pos, expected))\n+        replace = true;\n+    else\n+        return false;\n \n     if (!s_dictionary.ignore(pos, expected))\n         return false;\n@@ -1031,6 +1043,8 @@ bool ParserCreateDictionaryQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, E\n     node = query;\n     query->is_dictionary = true;\n     query->attach = attach;\n+    query->create_or_replace = or_replace;\n+    query->replace_table = replace;\n \n     auto dict_id = name->as<ASTTableIdentifier>()->getTableId();\n     query->database = dict_id.database_name;\ndiff --git a/src/Storages/StorageDictionary.cpp b/src/Storages/StorageDictionary.cpp\nindex 5aeaff590e17..4c31f62b21f0 100644\n--- a/src/Storages/StorageDictionary.cpp\n+++ b/src/Storages/StorageDictionary.cpp\n@@ -215,23 +215,26 @@ LoadablesConfigurationPtr StorageDictionary::getConfiguration() const\n \n void StorageDictionary::renameInMemory(const StorageID & new_table_id)\n {\n+    auto old_table_id = getStorageID();\n+    IStorage::renameInMemory(new_table_id);\n+\n     if (configuration)\n     {\n         configuration->setString(\"dictionary.database\", new_table_id.database_name);\n         configuration->setString(\"dictionary.name\", new_table_id.table_name);\n \n         const auto & external_dictionaries_loader = getContext()->getExternalDictionariesLoader();\n-        external_dictionaries_loader.reloadConfig(getStorageID().getInternalDictionaryName());\n+        auto result = external_dictionaries_loader.getLoadResult(old_table_id.getInternalDictionaryName());\n \n-        auto result = external_dictionaries_loader.getLoadResult(getStorageID().getInternalDictionaryName());\n-        if (!result.object)\n-            return;\n+        if (result.object)\n+        {\n+            const auto dictionary = std::static_pointer_cast<const IDictionary>(result.object);\n+            dictionary->updateDictionaryName(new_table_id);\n+        }\n \n-        const auto dictionary = std::static_pointer_cast<const IDictionary>(result.object);\n-        dictionary->updateDictionaryName(new_table_id);\n+        external_dictionaries_loader.reloadConfig(old_table_id.getInternalDictionaryName());\n+        dictionary_name = new_table_id.getFullNameNotQuoted();\n     }\n-\n-    IStorage::renameInMemory(new_table_id);\n }\n \n void registerStorageDictionary(StorageFactory & factory)\ndiff --git a/src/Storages/StorageDictionary.h b/src/Storages/StorageDictionary.h\nindex e2ba2964b1d9..d074dec2c34b 100644\n--- a/src/Storages/StorageDictionary.h\n+++ b/src/Storages/StorageDictionary.h\n@@ -45,7 +45,7 @@ class StorageDictionary final : public shared_ptr_helper<StorageDictionary>, pub\n     Poco::Timestamp getUpdateTime() const;\n     LoadablesConfigurationPtr getConfiguration() const;\n \n-    const String & getDictionaryName() const { return dictionary_name; }\n+    String getDictionaryName() const { return dictionary_name; }\n \n     /// Specifies where the table is located relative to the dictionary.\n     enum class Location\n@@ -66,7 +66,7 @@ class StorageDictionary final : public shared_ptr_helper<StorageDictionary>, pub\n     };\n \n private:\n-    const String dictionary_name;\n+    String dictionary_name;\n     const Location location;\n \n     mutable std::mutex dictionary_config_mutex;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01913_replace_dictionary.reference b/tests/queries/0_stateless/01913_replace_dictionary.reference\nnew file mode 100644\nindex 000000000000..2d33c16ccc26\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_replace_dictionary.reference\n@@ -0,0 +1,2 @@\n+0\tValue0\n+0\tValue1\ndiff --git a/tests/queries/0_stateless/01913_replace_dictionary.sql b/tests/queries/0_stateless/01913_replace_dictionary.sql\nnew file mode 100644\nindex 000000000000..22b0bd002ae7\n--- /dev/null\n+++ b/tests/queries/0_stateless/01913_replace_dictionary.sql\n@@ -0,0 +1,50 @@\n+DROP DATABASE IF EXISTS 01913_db;\n+CREATE DATABASE 01913_db ENGINE=Atomic;\n+\n+DROP TABLE IF EXISTS 01913_db.test_source_table_1;\n+CREATE TABLE 01913_db.test_source_table_1\n+(\n+    id UInt64,\n+    value String\n+) ENGINE=TinyLog;\n+\n+INSERT INTO 01913_db.test_source_table_1 VALUES (0, 'Value0');\n+\n+DROP DICTIONARY IF EXISTS 01913_db.test_dictionary;\n+CREATE DICTIONARY 01913_db.test_dictionary\n+(\n+    id UInt64,\n+    value String\n+)\n+PRIMARY KEY id\n+LAYOUT(DIRECT())\n+SOURCE(CLICKHOUSE(DB '01913_db' TABLE 'test_source_table_1'));\n+\n+SELECT * FROM 01913_db.test_dictionary;\n+\n+DROP TABLE IF EXISTS 01913_db.test_source_table_2;\n+CREATE TABLE 01913_db.test_source_table_2\n+(\n+    id UInt64,\n+    value_1 String\n+) ENGINE=TinyLog;\n+\n+INSERT INTO 01913_db.test_source_table_2 VALUES (0, 'Value1');\n+\n+REPLACE DICTIONARY 01913_db.test_dictionary\n+(\n+    id UInt64,\n+    value_1 String\n+)\n+PRIMARY KEY id\n+LAYOUT(HASHED())\n+SOURCE(CLICKHOUSE(DB '01913_db' TABLE 'test_source_table_2'))\n+LIFETIME(0);\n+\n+SELECT * FROM 01913_db.test_dictionary;\n+\n+DROP DICTIONARY 01913_db.test_dictionary;\n+DROP TABLE 01913_db.test_source_table_1;\n+DROP TABLE 01913_db.test_source_table_2;\n+\n+DROP DATABASE 01913_db;\ndiff --git a/tests/queries/0_stateless/01914_exchange_dictionaries.reference b/tests/queries/0_stateless/01914_exchange_dictionaries.reference\nnew file mode 100644\nindex 000000000000..9278d0abeed4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01914_exchange_dictionaries.reference\n@@ -0,0 +1,4 @@\n+1\tTable1\n+2\tTable2\n+2\tTable2\n+1\tTable1\ndiff --git a/tests/queries/0_stateless/01914_exchange_dictionaries.sql b/tests/queries/0_stateless/01914_exchange_dictionaries.sql\nnew file mode 100644\nindex 000000000000..ba0c70d13be4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01914_exchange_dictionaries.sql\n@@ -0,0 +1,34 @@\n+DROP TABLE IF EXISTS table_1;\n+CREATE TABLE table_1 (id UInt64, value String) ENGINE=TinyLog;\n+\n+DROP TABLE IF EXISTS table_2;\n+CREATE TABLE table_2 (id UInt64, value String) ENGINE=TinyLog;\n+\n+INSERT INTO table_1 VALUES (1, 'Table1');\n+INSERT INTO table_2 VALUES (2, 'Table2');\n+\n+DROP DICTIONARY IF EXISTS dictionary_1;\n+CREATE DICTIONARY dictionary_1 (id UInt64, value String)\n+PRIMARY KEY id\n+LAYOUT(DIRECT())\n+SOURCE(CLICKHOUSE(TABLE 'table_1'));\n+\n+DROP DICTIONARY IF EXISTS dictionary_2;\n+CREATE DICTIONARY dictionary_2 (id UInt64, value String)\n+PRIMARY KEY id\n+LAYOUT(DIRECT())\n+SOURCE(CLICKHOUSE(TABLE 'table_2'));\n+\n+SELECT * FROM dictionary_1;\n+SELECT * FROM dictionary_2;\n+\n+EXCHANGE DICTIONARIES dictionary_1 AND dictionary_2;\n+\n+SELECT * FROM dictionary_1;\n+SELECT * FROM dictionary_2;\n+\n+DROP DICTIONARY dictionary_1;\n+DROP DICTIONARY dictionary_2;\n+\n+DROP TABLE table_1;\n+DROP TABLE table_2;\ndiff --git a/tests/queries/0_stateless/01915_create_or_replace_dictionary.reference b/tests/queries/0_stateless/01915_create_or_replace_dictionary.reference\nnew file mode 100644\nindex 000000000000..2d33c16ccc26\n--- /dev/null\n+++ b/tests/queries/0_stateless/01915_create_or_replace_dictionary.reference\n@@ -0,0 +1,2 @@\n+0\tValue0\n+0\tValue1\ndiff --git a/tests/queries/0_stateless/01915_create_or_replace_dictionary.sql b/tests/queries/0_stateless/01915_create_or_replace_dictionary.sql\nnew file mode 100644\nindex 000000000000..5d5515f4f8a9\n--- /dev/null\n+++ b/tests/queries/0_stateless/01915_create_or_replace_dictionary.sql\n@@ -0,0 +1,50 @@\n+DROP DATABASE IF EXISTS 01915_db;\n+CREATE DATABASE 01915_db ENGINE=Atomic;\n+\n+DROP TABLE IF EXISTS 01915_db.test_source_table_1;\n+CREATE TABLE 01915_db.test_source_table_1\n+(\n+    id UInt64,\n+    value String\n+) ENGINE=TinyLog;\n+\n+INSERT INTO 01915_db.test_source_table_1 VALUES (0, 'Value0');\n+\n+DROP DICTIONARY IF EXISTS 01915_db.test_dictionary;\n+CREATE OR REPLACE DICTIONARY 01915_db.test_dictionary\n+(\n+    id UInt64,\n+    value String\n+)\n+PRIMARY KEY id\n+LAYOUT(DIRECT())\n+SOURCE(CLICKHOUSE(DB '01915_db' TABLE 'test_source_table_1'));\n+\n+SELECT * FROM 01915_db.test_dictionary;\n+\n+DROP TABLE IF EXISTS 01915_db.test_source_table_2;\n+CREATE TABLE 01915_db.test_source_table_2\n+(\n+    id UInt64,\n+    value_1 String\n+) ENGINE=TinyLog;\n+\n+INSERT INTO 01915_db.test_source_table_2 VALUES (0, 'Value1');\n+\n+CREATE OR REPLACE DICTIONARY 01915_db.test_dictionary\n+(\n+    id UInt64,\n+    value_1 String\n+)\n+PRIMARY KEY id\n+LAYOUT(HASHED())\n+SOURCE(CLICKHOUSE(DB '01915_db' TABLE 'test_source_table_2'))\n+LIFETIME(0);\n+\n+SELECT * FROM 01915_db.test_dictionary;\n+\n+DROP DICTIONARY 01915_db.test_dictionary;\n+DROP TABLE 01915_db.test_source_table_1;\n+DROP TABLE 01915_db.test_source_table_2;\n+\n+DROP DATABASE 01915_db;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 52c2d4684981..fcfd5192ce9e 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -516,7 +516,10 @@\n         \"01913_if_int_decimal\",\n         \"01913_join_push_down_bug\",\n         \"01921_with_fill_with_totals\",\n-        \"01924_argmax_bitmap_state\"\n+        \"01924_argmax_bitmap_state\",\n+        \"01913_replace_dictionary\",\n+        \"01914_exchange_dictionaries\",\n+        \"01915_create_or_replace_dictionary\"\n     ],\n     \"parallel\":\n     [\n",
  "problem_statement": "ALTER DICTIONARY support\nNeed to implement support of `ALTER DICTIONARY` queries for external dictionaries:\r\n1) Attributes\r\n2) Primary key\r\n3) Layout\r\n4) Source\r\n5) Lifetime\r\n6) Range for range_hashed dictionaries\n",
  "hints_text": "Maybe better to allow just `REPLACE DICTIONARY` query?\r\n(atomic dictionary recreate)\r\n\r\nSupport for all possible properties to ALTER will be too cumbersome.\nIt can be implemented much faster and also seems useful! \nALTER DICTIONARY SOURCE w/o dictionary recreation is needed for password rotation (atomic replace would be ok too)",
  "created_at": "2021-06-17T22:33:06Z",
  "modified_files": [
    "src/Databases/DatabaseAtomic.cpp",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Parsers/ASTCreateQuery.cpp",
    "src/Parsers/ASTRenameQuery.h",
    "src/Parsers/ParserCreateQuery.cpp",
    "src/Storages/StorageDictionary.cpp",
    "src/Storages/StorageDictionary.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01913_replace_dictionary.reference",
    "b/tests/queries/0_stateless/01913_replace_dictionary.sql",
    "b/tests/queries/0_stateless/01914_exchange_dictionaries.reference",
    "b/tests/queries/0_stateless/01914_exchange_dictionaries.sql",
    "b/tests/queries/0_stateless/01915_create_or_replace_dictionary.reference",
    "b/tests/queries/0_stateless/01915_create_or_replace_dictionary.sql",
    "tests/queries/skip_list.json"
  ]
}