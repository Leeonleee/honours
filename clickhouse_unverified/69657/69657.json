{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 69657,
  "instance_id": "ClickHouse__ClickHouse-69657",
  "issue_numbers": [
    "69447"
  ],
  "base_commit": "f41d604f28f8937fb5f2445025141d5e5ad47c77",
  "patch": "diff --git a/base/poco/Foundation/include/Poco/Logger.h b/base/poco/Foundation/include/Poco/Logger.h\nindex 74ddceea9dd5..f7da3c08fa32 100644\n--- a/base/poco/Foundation/include/Poco/Logger.h\n+++ b/base/poco/Foundation/include/Poco/Logger.h\n@@ -952,6 +952,8 @@ class Foundation_API Logger : public Channel\n     static std::pair<LoggerMapIterator, bool> add(Logger * pLogger);\n     static std::optional<LoggerMapIterator> find(const std::string & name);\n     static Logger * findRawPtr(const std::string & name);\n+    void unsafeSetChannel(Channel * pChannel);\n+    Channel* unsafeGetChannel() const;\n \n     Logger();\n     Logger(const Logger &);\ndiff --git a/base/poco/Foundation/src/Logger.cpp b/base/poco/Foundation/src/Logger.cpp\nindex 779af384b0be..55564a7a1759 100644\n--- a/base/poco/Foundation/src/Logger.cpp\n+++ b/base/poco/Foundation/src/Logger.cpp\n@@ -61,6 +61,13 @@ Logger::~Logger()\n \n \n void Logger::setChannel(Channel* pChannel)\n+{\n+\tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n+\tunsafeSetChannel(pChannel);\n+}\n+\n+\n+void Logger::unsafeSetChannel(Channel* pChannel)\n {\n \tif (_pChannel) _pChannel->release();\n \t_pChannel = pChannel;\n@@ -69,6 +76,14 @@ void Logger::setChannel(Channel* pChannel)\n \n \n Channel* Logger::getChannel() const\n+{\n+\tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n+\n+\treturn unsafeGetChannel();\n+}\n+\n+\n+Channel* Logger::unsafeGetChannel() const\n {\n \treturn _pChannel;\n }\n@@ -89,7 +104,7 @@ void Logger::setLevel(const std::string& level)\n void Logger::setProperty(const std::string& name, const std::string& value)\n {\n \tif (name == \"channel\")\n-\t\tsetChannel(LoggingRegistry::defaultRegistry().channelForName(value));\n+\t\tunsafeSetChannel(LoggingRegistry::defaultRegistry().channelForName(value));\n \telse if (name == \"level\")\n \t\tsetLevel(value);\n \telse\n@@ -160,7 +175,7 @@ void Logger::setChannel(const std::string& name, Channel* pChannel)\n \t\t\tif (len == 0 ||\n \t\t\t\t(it.first.compare(0, len, name) == 0 && (it.first.length() == len || it.first[len] == '.')))\n \t\t\t{\n-\t\t\t\tit.second.logger->setChannel(pChannel);\n+\t\t\t\tit.second.logger->unsafeSetChannel(pChannel);\n \t\t\t}\n \t\t}\n \t}\n@@ -393,7 +408,7 @@ std::pair<Logger::LoggerMapIterator, bool> Logger::unsafeGet(const std::string&\n \t\telse\n \t\t{\n \t\t\tLogger& par = parent(name);\n-\t\t\tlogger = new Logger(name, par.getChannel(), par.getLevel());\n+\t\t\tlogger = new Logger(name, par.unsafeGetChannel(), par.getLevel());\n \t\t}\n \n \t\treturn add(logger);\ndiff --git a/docs/en/operations/server-configuration-parameters/settings.md b/docs/en/operations/server-configuration-parameters/settings.md\nindex 79407d46ce03..b62384877250 100644\n--- a/docs/en/operations/server-configuration-parameters/settings.md\n+++ b/docs/en/operations/server-configuration-parameters/settings.md\n@@ -1488,6 +1488,8 @@ Keys:\n - `formatting` \u2013 Log format for console output. Currently, only `json` is supported).\n - `use_syslog` - Also forward log output to syslog.\n - `syslog_level` - Log level for logging to syslog.\n+- `message_regexp` - Only log messages that match this regular expression. Defaults to `\"\"`, indicating no filtering.\n+- `message_regexp_negative` - Only log messages that don't match this regular expression. Defaults to `\"\"`, indicating no filtering.\n \n **Log format specifiers**\n \n@@ -1576,6 +1578,28 @@ The log level of individual log names can be overridden. For example, to mute al\n </logger>\n ```\n \n+**Regular Expression Filtering**\n+\n+The messages logged can be filtered using regular expressions using `message_regexp` and `message_regexp_negative`. This can be done on a per-level basis or globally. If both a global and logger-specific pattern is specified, the global pattern is overridden (ignored) and only the logger-specific pattern applies. The positive and negative patterns are considered independently for this situation. Note: Using this feature may cause a slight slowdown in performance.\n+\n+\n+```xml\n+    <logger>\n+        <level>trace</level>\n+        <!-- Global: Don't log Trace messages -->\n+        <message_regexp_negative>.*Trace.*</message_regexp_negative>\n+\n+        <message_regexps>\n+            <logger>\n+                <!-- For the executeQuery logger, only log if message has \"Read\", but not \"from\" -->\n+                <name>executeQuery</name>\n+                <message_regexp>.*Read.*</message_regexp>\n+                <message_regexp_negative>.*from.*</message_regexp_negative>\n+            </logger>\n+        </message_regexps>\n+    </logger>\n+```\n+\n ### syslog\n \n To write log messages additionally to syslog:\ndiff --git a/src/Loggers/Loggers.cpp b/src/Loggers/Loggers.cpp\nindex 35b96bce42aa..b6510b7573ff 100644\n--- a/src/Loggers/Loggers.cpp\n+++ b/src/Loggers/Loggers.cpp\n@@ -1,12 +1,14 @@\n #include \"Loggers.h\"\n \n-#include \"OwnFormattingChannel.h\"\n-#include \"OwnPatternFormatter.h\"\n-#include \"OwnSplitChannel.h\"\n+#include <Loggers/OwnFilteringChannel.h>\n+#include <Loggers/OwnFormattingChannel.h>\n+#include <Loggers/OwnPatternFormatter.h>\n+#include <Loggers/OwnSplitChannel.h>\n \n #include <iostream>\n #include <sstream>\n \n+#include <Poco/AutoPtr.h>\n #include <Poco/ConsoleChannel.h>\n #include <Poco/Logger.h>\n #include <Poco/Net/RemoteSyslogChannel.h>\n@@ -222,6 +224,18 @@ void Loggers::buildLoggers(Poco::Util::AbstractConfiguration & config, Poco::Log\n     logger.close();\n \n     logger.setChannel(split);\n+\n+    const std::string global_pos_pattern = config.getRawString(\"logger.message_regexp\", \"\");\n+    const std::string global_neg_pattern = config.getRawString(\"logger.message_regexp_negative\", \"\");\n+\n+    Poco::AutoPtr<OwnPatternFormatter> pf;\n+    if (config.getString(\"logger.formatting.type\", \"\") == \"json\")\n+        pf = new OwnJSONPatternFormatter(config);\n+    else\n+        pf = new OwnPatternFormatter;\n+\n+    DB::createOrUpdateFilterChannel(logger, global_pos_pattern, global_neg_pattern, pf, Poco::Logger::ROOT);\n+\n     logger.setLevel(max_log_level);\n \n     // Global logging level and channel (it can be overridden for specific loggers).\n@@ -236,6 +250,8 @@ void Loggers::buildLoggers(Poco::Util::AbstractConfiguration & config, Poco::Log\n     {\n         logger.get(name).setLevel(max_log_level);\n         logger.get(name).setChannel(split);\n+\n+        DB::createOrUpdateFilterChannel(logger.get(name), global_pos_pattern, global_neg_pattern, pf, name);\n     }\n \n     // Explicitly specified log levels for specific loggers.\n@@ -262,6 +278,26 @@ void Loggers::buildLoggers(Poco::Util::AbstractConfiguration & config, Poco::Log\n             }\n         }\n     }\n+    // Explicitly specified regexp patterns for filtering specific loggers\n+    {\n+        Poco::Util::AbstractConfiguration::Keys loggers_regexp;\n+        config.keys(\"logger.message_regexps\", loggers_regexp);\n+\n+        if (!loggers_regexp.empty())\n+        {\n+            for (const auto & key : loggers_regexp)\n+            {\n+                if (key == \"logger\" || key.starts_with(\"logger[\"))\n+                {\n+                    const std::string name = config.getString(\"logger.message_regexps.\" + key + \".name\");\n+                    const std::string pos_pattern = config.getRawString(\"logger.message_regexps.\" + key + \".message_regexp\", global_pos_pattern);\n+                    const std::string neg_pattern = config.getRawString(\"logger.message_regexps.\" + key + \".message_regexp_negative\", global_neg_pattern);\n+\n+                    DB::createOrUpdateFilterChannel(logger.root().get(name), pos_pattern, neg_pattern, pf, name);\n+                }\n+            }\n+        }\n+    }\n #ifndef WITHOUT_TEXT_LOG\n     if (allowTextLog() && config.has(\"text_log\"))\n     {\n@@ -347,16 +383,32 @@ void Loggers::updateLevels(Poco::Util::AbstractConfiguration & config, Poco::Log\n     }\n     split->setLevel(\"syslog\", syslog_level);\n \n+    const std::string global_pos_pattern = config.getRawString(\"logger.message_regexp\", \"\");\n+    const std::string global_neg_pattern = config.getRawString(\"logger.message_regexp_negative\", \"\");\n+\n+    Poco::AutoPtr<OwnPatternFormatter> pf;\n+    if (config.getString(\"logger.formatting.type\", \"\") == \"json\")\n+        pf = new OwnJSONPatternFormatter(config);\n+    else\n+        pf = new OwnPatternFormatter;\n+\n+    DB::createOrUpdateFilterChannel(logger, global_pos_pattern, global_neg_pattern, pf, Poco::Logger::ROOT);\n+\n     // Global logging level (it can be overridden for specific loggers).\n     logger.setLevel(max_log_level);\n \n     // Set level to all already created loggers\n     std::vector<std::string> names;\n-\n     logger.root().names(names);\n+\n+    // Set all to global in case logger.levels are not specified\n     for (const auto & name : names)\n+    {\n         logger.root().get(name).setLevel(max_log_level);\n \n+        DB::createOrUpdateFilterChannel(logger.root().get(name), global_pos_pattern, global_neg_pattern, pf, name);\n+    }\n+\n     logger.root().setLevel(max_log_level);\n \n     // Explicitly specified log levels for specific loggers.\n@@ -383,6 +435,27 @@ void Loggers::updateLevels(Poco::Util::AbstractConfiguration & config, Poco::Log\n             }\n         }\n     }\n+\n+    // Explicitly specified regexp patterns for filtering specific loggers\n+    {\n+        Poco::Util::AbstractConfiguration::Keys loggers_regexp;\n+        config.keys(\"logger.message_regexps\", loggers_regexp);\n+\n+        if (!loggers_regexp.empty())\n+        {\n+            for (const auto & key : loggers_regexp)\n+            {\n+                if (key == \"logger\" || key.starts_with(\"logger[\"))\n+                {\n+                    const std::string name(config.getString(\"logger.message_regexps.\" + key + \".name\"));\n+                    const std::string pos_pattern(config.getRawString(\"logger.message_regexps.\" + key + \".message_regexp\", global_pos_pattern));\n+                    const std::string neg_pattern(config.getRawString(\"logger.message_regexps.\" + key + \".message_regexp_negative\", global_neg_pattern));\n+\n+                    DB::createOrUpdateFilterChannel(logger.root().get(name), pos_pattern, neg_pattern, pf, name);\n+                }\n+            }\n+        }\n+    }\n }\n \n /// NOLINTEND(readability-static-accessed-through-instance)\ndiff --git a/src/Loggers/OwnFilteringChannel.cpp b/src/Loggers/OwnFilteringChannel.cpp\nnew file mode 100644\nindex 000000000000..36193c463142\n--- /dev/null\n+++ b/src/Loggers/OwnFilteringChannel.cpp\n@@ -0,0 +1,96 @@\n+#include <shared_mutex>\n+#include <Loggers/OwnFilteringChannel.h>\n+#include <Poco/RegularExpression.h>\n+\n+\n+namespace DB\n+{\n+\n+void OwnFilteringChannel::log(const Poco::Message & msg)\n+{\n+    if (regexpFilteredOut(msg))\n+        return;\n+\n+    pChannel->log(msg);\n+}\n+\n+bool OwnFilteringChannel::regexpFilteredOut(const Poco::Message & msg)\n+{\n+    std::string formatted_text;\n+    auto [pos_pattern, neg_pattern] = safeGetPatterns();\n+\n+    // Skip checks if both patterns are empty\n+    if (!pos_pattern.empty() || !neg_pattern.empty())\n+    {\n+        // Apply formatting to the text\n+        if (pFormatter)\n+        {\n+            pFormatter->formatExtended(ExtendedLogMessage::getFrom(msg), formatted_text);\n+        }\n+        else\n+        {\n+            formatted_text = msg.getText();\n+        }\n+\n+        // Check for patterns in formatted text\n+        Poco::RegularExpression positive_regexp(pos_pattern);\n+        if (!pos_pattern.empty() && !positive_regexp.match(formatted_text))\n+        {\n+            return true;\n+        }\n+\n+        Poco::RegularExpression negative_regexp(neg_pattern);\n+        if (!neg_pattern.empty() && negative_regexp.match(formatted_text))\n+        {\n+            return true;\n+        }\n+    }\n+\n+    return false;\n+}\n+\n+void OwnFilteringChannel::setRegexpPatterns(const std::string & new_pos_pattern, const std::string & new_neg_pattern)\n+{\n+    auto [old_pos_pattern, old_neg_pattern] = safeGetPatterns();\n+    if (old_pos_pattern != new_pos_pattern || old_neg_pattern != new_neg_pattern)\n+    {\n+        std::unique_lock<std::shared_mutex> write_lock(pattern_mutex);\n+        positive_pattern = new_pos_pattern;\n+        negative_pattern = new_neg_pattern;\n+    }\n+}\n+\n+std::pair<std::string, std::string> OwnFilteringChannel::safeGetPatterns()\n+{\n+    std::shared_lock<std::shared_mutex> read_lock(pattern_mutex);\n+    return std::make_pair(positive_pattern, negative_pattern);\n+}\n+\n+void createOrUpdateFilterChannel(Poco::Logger & logger, const std::string & pos_pattern, const std::string & neg_pattern, Poco::AutoPtr<OwnPatternFormatter> pf, const std::string & name)\n+{\n+    Poco::AutoPtr<Poco::Channel> src_channel(logger.getChannel(), true /*shared*/);\n+    Poco::AutoPtr<DB::OwnFilteringChannel> filter_channel(dynamic_cast<DB::OwnFilteringChannel*>(src_channel.get()), true);\n+\n+    // If this logger doesn't have it's own unique filter channel\n+    if (!filter_channel)\n+    {\n+        // Skip if regexp feature has never been used yet\n+        if (pos_pattern.empty() && neg_pattern.empty())\n+            return;\n+\n+        Poco::AutoPtr<DB::OwnFilteringChannel> new_filter_channel = new DB::OwnFilteringChannel(src_channel, pf, pos_pattern, neg_pattern, name);\n+        logger.setChannel(new_filter_channel);\n+    }\n+    // If logger has filter channel, but not it's own unique one (e.g copied from another by default), create copy\n+    else if (filter_channel->getAssignedLoggerName() != name)\n+    {\n+        Poco::AutoPtr<DB::OwnFilteringChannel> new_filter_channel = new DB::OwnFilteringChannel(filter_channel, pos_pattern, neg_pattern, name);\n+        logger.setChannel(new_filter_channel);\n+    }\n+    else\n+    {\n+        filter_channel->setRegexpPatterns(pos_pattern, neg_pattern);\n+    }\n+}\n+\n+}\ndiff --git a/src/Loggers/OwnFilteringChannel.h b/src/Loggers/OwnFilteringChannel.h\nnew file mode 100644\nindex 000000000000..5dce6007baf0\n--- /dev/null\n+++ b/src/Loggers/OwnFilteringChannel.h\n@@ -0,0 +1,84 @@\n+#pragma once\n+#include <Poco/AutoPtr.h>\n+#include <Poco/Channel.h>\n+#include <Poco/Message.h>\n+#include <Poco/Logger.h>\n+#include <Poco/Util/AbstractConfiguration.h>\n+#include <Loggers/OwnPatternFormatter.h>\n+#include <shared_mutex>\n+\n+\n+namespace DB\n+{\n+\n+// Filters the logs based on regular expressions. Should be processed after formatting channel to read entire formatted text\n+class OwnFilteringChannel : public Poco::Channel\n+{\n+public:\n+    explicit OwnFilteringChannel(Poco::AutoPtr<Poco::Channel> pChannel_, Poco::AutoPtr<OwnPatternFormatter> pf,\n+        const std::string & positive_pattern_, const std::string & negative_pattern_, const std::string & name_)\n+    : logger_name(name_), positive_pattern(positive_pattern_), negative_pattern(negative_pattern_), pChannel(pChannel_), pFormatter(pf)\n+    {\n+    }\n+\n+    explicit OwnFilteringChannel(Poco::AutoPtr<OwnFilteringChannel> other, const std::string & positive_pattern_, const std::string & negative_pattern_, const std::string & name_)\n+    : logger_name(name_), positive_pattern(positive_pattern_), negative_pattern(negative_pattern_), pChannel(other->pChannel), pFormatter(other->pFormatter)\n+    {\n+    }\n+\n+    // Only log if pass both positive and negative regexp checks.\n+    // Checks the regexps on the formatted text (without color), but then passes the raw text\n+    // to the split channel to handle formatting for individual channels (e.g apply color)\n+    void log(const Poco::Message & msg) override;\n+\n+    // Sets the regex patterns to use for filtering. Specifying an empty string pattern \"\" indicates no filtering\n+    void setRegexpPatterns(const std::string & new_pos_pattern, const std::string & new_neg_pattern);\n+\n+    std::string getAssignedLoggerName() const\n+    {\n+        return logger_name;\n+    }\n+\n+    void open() override\n+    {\n+        if (pChannel)\n+            pChannel->open();\n+    }\n+\n+    void close() override\n+    {\n+        if (pChannel)\n+            pChannel->close();\n+    }\n+\n+    void setProperty(const std::string & name, const std::string & value) override\n+    {\n+        if (pChannel)\n+            pChannel->setProperty(name, value);\n+    }\n+\n+    std::string getProperty(const std::string & name) const override\n+    {\n+        if (pChannel)\n+            return pChannel->getProperty(name);\n+        return \"\";\n+    }\n+\n+private:\n+    bool regexpFilteredOut(const Poco::Message & msg);\n+\n+    // Create copy safely, so we don't have to worry about race conditions from reading and writing at the same time\n+    std::pair<std::string, std::string> safeGetPatterns();\n+\n+    const std::string logger_name;\n+    std::string positive_pattern;\n+    std::string negative_pattern;\n+    Poco::AutoPtr<Poco::Channel> pChannel;\n+    Poco::AutoPtr<OwnPatternFormatter> pFormatter;\n+    std::shared_mutex pattern_mutex;\n+};\n+\n+// Creates filter channel only if needed or updates if it already exists\n+void createOrUpdateFilterChannel(Poco::Logger & logger, const std::string & pos_pattern, const std::string & neg_pattern, Poco::AutoPtr<OwnPatternFormatter> pf, const std::string & name = \"\");\n+\n+}\n",
  "test_patch": "diff --git a/tests/integration/test_regexp_logger/__init__.py b/tests/integration/test_regexp_logger/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_regexp_logger/configs/log.xml b/tests/integration/test_regexp_logger/configs/log.xml\nnew file mode 100644\nindex 000000000000..a85417d05b81\n--- /dev/null\n+++ b/tests/integration/test_regexp_logger/configs/log.xml\n@@ -0,0 +1,6 @@\n+<clickhouse>\n+    <logger>\n+        <level>trace</level>\n+        <log>/var/log/clickhouse-server/clickhouse-server.log</log>\n+    </logger>\n+</clickhouse>\n\\ No newline at end of file\ndiff --git a/tests/integration/test_regexp_logger/test.py b/tests/integration/test_regexp_logger/test.py\nnew file mode 100644\nindex 000000000000..4f8a7e4be8f0\n--- /dev/null\n+++ b/tests/integration/test_regexp_logger/test.py\n@@ -0,0 +1,74 @@\n+import re\n+\n+import pytest\n+\n+from helpers.cluster import ClickHouseCluster\n+\n+cluster = ClickHouseCluster(__file__)\n+node = cluster.add_instance(\n+    \"node\", with_zookeeper=False, main_configs=[\"configs/log.xml\"]\n+)\n+\n+original_config = \"\"\"\n+<clickhouse>\n+    <logger>\n+        <level>trace</level>\n+        <log>/var/log/clickhouse-server/clickhouse-server.log</log>\n+    </logger>\n+</clickhouse>\n+\"\"\"\n+\n+updated_config = \"\"\"\n+<clickhouse>\n+    <logger>\n+        <level>trace</level>\n+        <log>/var/log/clickhouse-server/clickhouse-server.log</log>\n+        <message_regexp_negative>.*Loaded config.*</message_regexp_negative>\n+        <message_regexps>\n+            <logger>\n+                <name>executeQuery</name>\n+                <message_regexp>.*Read.*</message_regexp>\n+                <message_regexp_negative>.*from.*</message_regexp_negative>\n+            </logger>\n+        </message_regexps>\n+    </logger>\n+</clickhouse>\n+\"\"\"\n+\n+\n+@pytest.fixture(scope=\"module\")\n+def start_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+\n+    finally:\n+        cluster.shutdown()\n+\n+\n+def test_regexp_pattern_update(start_cluster):\n+    # Display config being used\n+    node.exec_in_container([\"cat\", \"/etc/clickhouse-server/config.d/log.xml\"])\n+\n+    # Make sure that there are enough log messages for the test\n+    for _ in range(5):\n+        node.query(\"SYSTEM RELOAD CONFIG\")\n+        node.query(\"SELECT 1\")\n+\n+    assert node.contains_in_log(r\".*Loaded config.*\")\n+    assert node.contains_in_log(r\".*executeQuery.*Read.*\")\n+    assert node.contains_in_log(r\".*executeQuery.*from.*\")\n+\n+    node.replace_config(\"/etc/clickhouse-server/config.d/log.xml\", updated_config)\n+    node.query(\"SYSTEM RELOAD CONFIG;\")\n+    node.rotate_logs()\n+\n+    for _ in range(5):\n+        node.query(\"SYSTEM RELOAD CONFIG\")\n+        node.query(\"SELECT 1\")\n+\n+    assert not node.contains_in_log(r\".*Loaded config.*\")\n+    assert node.contains_in_log(r\".*executeQuery.*Read.*\")\n+    assert not node.contains_in_log(r\".*executeQuery.*from.*\")\n+\n+    node.replace_config(\"/etc/clickhouse-server/config.d/log.xml\", original_config)\n",
  "problem_statement": "Suppress/allow logging based on regexps\nThe log level can currently be configured on a logger-by-logger basis (see \"Per-level overrides\" [here](https://clickhouse.com/docs/en/operations/server-configuration-parameters/settings#logger)):\r\n\r\n```xml\r\n<logger>\r\n    <levels>\r\n        <logger>\r\n            <name>Backup</name>\r\n            <level>none</level>\r\n        </logger>\r\n    </levels>\r\n</logger>\r\n```\r\n\r\nIt would be nice if one could alternatively specify a regexp (for the log message) that enables logging if matched, and suppresses logging otherwise (`<message_regexp>`), or vice versa (`<message_regexp_negative>`).\r\n\r\nFor example\r\n\r\n```xml\r\n<logger>\r\n    <levels>\r\n        <logger>\r\n            <name>Backup</name>\r\n            <!-- log all messages of logger 'Backup' that match regexp 'message_regexp' and which don't match regexp 'message_regexp_negative' -->\r\n            <message_regexp>.*my_table.*</message_regexp>\r\n            <message_regexp_negative>.*host not reachable.*</message_regexp_negative>\r\n        </logger>\r\n    </levels>\r\n</logger>\r\n```\n",
  "hints_text": "In which of the following cases should and shouldn't something be logged?\r\nRegex matches:\r\n  1. `message_regexp` actively says something should be logged, but `log-level` says it shouldn't be logged\r\n  2. `message_regexp_negative` actively says it shouldn't be logged. log-level says it should\r\nRegex doesn't match:\r\n  3. `log-level` says it should be logged, but `message_regexp` doesn't say something should be logged\r\n  4. `log-level` says it should be logged, and `message_regexp_negative` doesn't say not to log (double negative)\r\n\r\nTo me, it makes sense for the regex to only filter logs and not add any new ones. Meaning: case (4) should log and cases (1) (2) and (3) should not log. Would you agree?\n@petern48 I think it is natural to require that a log message fullfils all specified conditions (`level`, `message_regexp`, `message_regexp_negative`), i.e. they are implicitly `AND`-ed. With that, none of your examples 1-4 would log because one particular condition in the conjunction is false.\r\n\r\n(Side note: I also thought about allowing the same type of condition to occur more than once, e.g. 2x `level` or 2x `message_regexp`. However, for `level`, that doesn't make sense, and for the two regexp conditions, the user can use AND directly within the regexp. So it makes more sense to allow each condition only once.\nHi @rschu1ze I'm new to open source and would like to contribute. Can I work on this?\n@cmagapu Oop, forgot to mention in my first message that I'm working on this one. I'm nearly done too. Sorry. If you want, you can filter for \"easy task\" on the issues search to find more beginner-friendly issues.\n@petern48 sure, no problem. Thanks for the tip!",
  "created_at": "2024-09-17T07:10:26Z",
  "modified_files": [
    "base/poco/Foundation/include/Poco/Logger.h",
    "base/poco/Foundation/src/Logger.cpp",
    "docs/en/operations/server-configuration-parameters/settings.md",
    "src/Loggers/Loggers.cpp",
    "b/src/Loggers/OwnFilteringChannel.cpp",
    "b/src/Loggers/OwnFilteringChannel.h"
  ],
  "modified_test_files": [
    "b/tests/integration/test_regexp_logger/configs/log.xml",
    "b/tests/integration/test_regexp_logger/test.py"
  ]
}