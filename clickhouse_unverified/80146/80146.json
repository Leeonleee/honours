{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80146,
  "instance_id": "ClickHouse__ClickHouse-80146",
  "issue_numbers": [
    "75817"
  ],
  "base_commit": "de4ea8f17d02742a4cf2186cd95809d1debcf3ca",
  "patch": "diff --git a/docs/en/operations/system-tables/zookeeper.md b/docs/en/operations/system-tables/zookeeper.md\nindex 059f99001752..8f16e5dcfe8f 100644\n--- a/docs/en/operations/system-tables/zookeeper.md\n+++ b/docs/en/operations/system-tables/zookeeper.md\n@@ -8,8 +8,8 @@ title: 'system.zookeeper'\n \n # system.zookeeper\n \n-The table does not exist unless ClickHouse Keeper or ZooKeeper is configured. The `system.zookeeper` table exposes data from the Keeper cluster defined in the config.\n-The query must either have a 'path ='   condition or a `path IN`  condition set with the `WHERE` clause as shown below. This corresponds to the path of the children that you want to get data for.\n+The table does not exist unless ClickHouse Keeper or ZooKeeper is configured. The `system.zookeeper` table exposes data from the Keeper clusters defined in the config.\n+The query must either have a `path =`   condition or a `path IN`  condition set with the `WHERE` clause as shown below. This corresponds to the path of the children that you want to get data for.\n \n The query `SELECT * FROM system.zookeeper WHERE path = '/clickhouse'` outputs data for all children on the `/clickhouse` node.\n To output data for all root nodes, write path = '/'.\n@@ -19,11 +19,15 @@ The query `SELECT * FROM system.zookeeper WHERE path IN ('/', '/clickhouse')` ou\n If in the specified 'path' collection has does not exist path, an exception will be thrown.\n It can be used to do a batch of Keeper path queries.\n \n+The query `SELECT * FROM system.zookeeper WHERE path = '/clickhouse' AND zookeeperName = 'auxiliary_cluster'` outputs data in `auxiliary_cluster` ZooKeeper cluster.\n+If the specified 'auxiliary_cluster' does not exists, an exception will be thrown.\n+\n Columns:\n \n - `name` (String) \u2014 The name of the node.\n - `path` (String) \u2014 The path to the node.\n - `value` (String) \u2014 Node value.\n+- `zookeeperName` (String) \u2014 The name of default or one of auxiliary ZooKeeper cluster.\n - `dataLength` (Int32) \u2014 Size of the value.\n - `numChildren` (Int32) \u2014 Number of descendants.\n - `czxid` (Int64) \u2014 ID of the transaction that created the node.\ndiff --git a/src/Storages/System/StorageSystemZooKeeper.cpp b/src/Storages/System/StorageSystemZooKeeper.cpp\nindex 0c8f23662e3d..37a01d951842 100644\n--- a/src/Storages/System/StorageSystemZooKeeper.cpp\n+++ b/src/Storages/System/StorageSystemZooKeeper.cpp\n@@ -11,6 +11,7 @@\n #include <Interpreters/Context.h>\n #include <Interpreters/ProcessList.h>\n #include <Interpreters/evaluateConstantExpression.h>\n+#include <Common/Exception.h>\n #include <Common/ZooKeeper/ZooKeeper.h>\n #include <Common/ZooKeeper/ZooKeeperRetries.h>\n #include <Common/ZooKeeper/ZooKeeperWithFaultInjection.h>\n@@ -217,6 +218,7 @@ class ReadFromSystemZooKeeper final : public SourceStepWithFilter\n private:\n     std::shared_ptr<const StorageLimitsList> storage_limits;\n     const UInt64 max_block_size;\n+    String name;\n     Paths paths;\n };\n \n@@ -225,12 +227,14 @@ class SystemZooKeeperSource : public ISource\n {\n public:\n     SystemZooKeeperSource(\n+        String && zookeeper_name_,\n         Paths && paths_,\n         Block header_,\n         UInt64 max_block_size_,\n         ContextPtr context_)\n         : ISource(header_)\n         , max_block_size(max_block_size_)\n+        , name(std::move(zookeeper_name_))\n         , paths(std::move(paths_))\n         , context(std::move(context_))\n     {\n@@ -243,9 +247,10 @@ class SystemZooKeeperSource : public ISource\n \n private:\n     const UInt64 max_block_size;\n+    String name;\n     Paths paths;\n     ContextPtr context;\n-    ZooKeeperWithFaultInjection::Ptr zookeeper;\n+    std::map<String, ZooKeeperWithFaultInjection::Ptr> zookeepers;\n     bool started = false;\n     std::unordered_set<String> visited;\n };\n@@ -294,6 +299,7 @@ ColumnsDescription StorageSystemZooKeeper::getColumnsDescription()\n     {\n         {\"name\",           std::make_shared<DataTypeString>(), \"The name of the node.\"},\n         {\"value\",          std::make_shared<DataTypeString>(), \"Node value.\"},\n+        {\"zookeeperName\",  std::make_shared<DataTypeString>(), \"The name of default or one of auxiliary ZooKeeper cluster.\"},\n         {\"czxid\",          std::make_shared<DataTypeInt64>(), \"ID of the transaction that created the node.\"},\n         {\"mzxid\",          std::make_shared<DataTypeInt64>(), \"ID of the transaction that last changed the node.\"},\n         {\"ctime\",          std::make_shared<DataTypeDateTime>(), \"Time of node creation.\"},\n@@ -335,6 +341,14 @@ static String pathCorrected(const String & path)\n     return path_corrected;\n }\n \n+static bool isNameNode(const ActionsDAG::Node * node)\n+{\n+    while (node->type == ActionsDAG::ActionType::ALIAS)\n+        node = node->children.at(0);\n+\n+    return node->result_name == \"zookeeperName\";\n+}\n+\n static bool isPathNode(const ActionsDAG::Node * node)\n {\n     while (node->type == ActionsDAG::ActionType::ALIAS)\n@@ -343,6 +357,51 @@ static bool isPathNode(const ActionsDAG::Node * node)\n     return node->result_name == \"path\";\n }\n \n+static void extractNameImpl(const ActionsDAG::Node & node, String & res, ContextPtr context)\n+{\n+    /// Only one name is allowed\n+    if (!res.empty())\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                        \"SELECT from system.zookeeper table cannot have multiple different filters by zookeeperName.\");\n+\n+    if (node.type != ActionsDAG::ActionType::FUNCTION)\n+        return;\n+\n+    auto function_name = node.function_base->getName();\n+    if (function_name == \"and\")\n+    {\n+        for (const auto * child : node.children)\n+            extractNameImpl(*child, res, context);\n+\n+        return;\n+    }\n+\n+    if (node.children.size() != 2)\n+        return;\n+\n+    if (function_name == \"equals\")\n+    {\n+        const ActionsDAG::Node * value = nullptr;\n+\n+        if (isNameNode(node.children.at(0)))\n+            value = node.children.at(1);\n+        else if (isNameNode(node.children.at(1)))\n+            value = node.children.at(0);\n+\n+        if (!value || !value->column)\n+            return;\n+\n+        if (!isString(removeNullable(removeLowCardinality(value->result_type))))\n+            return;\n+\n+        if (value->column->size() != 1)\n+            return;\n+\n+        /// Only inserted if the key doesn't exists already\n+        res = value->column->getDataAt(0).toString();\n+    }\n+}\n+\n static void extractPathImpl(const ActionsDAG::Node & node, Paths & res, ContextPtr context, bool allow_unrestricted)\n {\n     if (node.type != ActionsDAG::ActionType::FUNCTION)\n@@ -465,6 +524,20 @@ static void extractPathImpl(const ActionsDAG::Node & node, Paths & res, ContextP\n     }\n }\n \n+/** Retrieve from the query a condition of the form `zookeeperName = 'name`, from conjunctions in the WHERE clause.\n+  */\n+static String extractName(const ActionsDAG::NodeRawConstPtrs & filter_nodes, ContextPtr context)\n+{\n+    String res;\n+    for (const auto * node : filter_nodes)\n+        extractNameImpl(*node, res, context);\n+\n+    if (res.empty())\n+        return {String(zkutil::DEFAULT_ZOOKEEPER_NAME)};\n+\n+    return res;\n+}\n+\n \n /** Retrieve from the query a condition of the form `path = 'path'`, from conjunctions in the WHERE clause.\n   */\n@@ -494,12 +567,19 @@ void ReadFromSystemZooKeeper::applyFilters(ActionDAGNodes added_filter_nodes)\n {\n     SourceStepWithFilter::applyFilters(added_filter_nodes);\n \n+    name = extractName(added_filter_nodes.nodes, context);\n     paths = extractPath(added_filter_nodes.nodes, context, context->getSettingsRef()[Setting::allow_unrestricted_reads_from_keeper]);\n }\n \n \n Chunk SystemZooKeeperSource::generate()\n {\n+    if (name.empty())\n+    {\n+        chassert(0); // In fact, it must always have a default value.\n+        name = zkutil::DEFAULT_ZOOKEEPER_NAME;\n+    }\n+\n     if (paths.empty())\n     {\n         if (!started)\n@@ -531,16 +611,17 @@ Chunk SystemZooKeeperSource::generate()\n     /// Handles reconnects when needed\n     auto get_zookeeper = [&] ()\n     {\n-        if (!zookeeper || zookeeper->expired())\n+        auto zookeeper = zookeepers.find(name);\n+        if (zookeeper == zookeepers.end() || zookeeper->second->expired())\n         {\n-            zookeeper = ZooKeeperWithFaultInjection::createInstance(\n+            zookeepers[name] = ZooKeeperWithFaultInjection::createInstance(\n                 settings[Setting::insert_keeper_fault_injection_probability],\n                 settings[Setting::insert_keeper_fault_injection_seed],\n-                context->getZooKeeper(),\n+                context->getDefaultOrAuxiliaryZooKeeper(name),\n                 \"\",\n                 nullptr);\n         }\n-        return zookeeper;\n+        return zookeepers[name];\n     };\n \n     const Int64 max_inflight_requests = std::max<Int64>(1, context->getSettingsRef()[Setting::max_download_threads].value);\n@@ -678,6 +759,7 @@ Chunk SystemZooKeeperSource::generate()\n             size_t col_num = 0;\n             res_columns[col_num++]->insert(get_task.node);\n             res_columns[col_num++]->insert(res.data);\n+            res_columns[col_num++]->insert(name);\n             res_columns[col_num++]->insert(stat.czxid);\n             res_columns[col_num++]->insert(stat.mzxid);\n             res_columns[col_num++]->insert(UInt64(stat.ctime / 1000));\n@@ -726,7 +808,7 @@ void ReadFromSystemZooKeeper::initializePipeline(QueryPipelineBuilder & pipeline\n {\n     const auto & header = getOutputHeader();\n \n-    auto source = std::make_shared<SystemZooKeeperSource>(std::move(paths), header, max_block_size, context);\n+    auto source = std::make_shared<SystemZooKeeperSource>(std::move(name), std::move(paths), header, max_block_size, context);\n     source->setStorageLimits(storage_limits);\n     processors.emplace_back(source);\n     pipeline.init(Pipe(std::move(source)));\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02735_system_zookeeper_auxiliary.reference b/tests/queries/0_stateless/02735_system_zookeeper_auxiliary.reference\nnew file mode 100644\nindex 000000000000..32c67aa6bb56\n--- /dev/null\n+++ b/tests/queries/0_stateless/02735_system_zookeeper_auxiliary.reference\n@@ -0,0 +1,4 @@\n+default\n+zookeeper2\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02735_system_zookeeper_auxiliary.sql b/tests/queries/0_stateless/02735_system_zookeeper_auxiliary.sql\nnew file mode 100644\nindex 000000000000..fee2d60162e8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02735_system_zookeeper_auxiliary.sql\n@@ -0,0 +1,20 @@\n+-- Tags: no-fasttest, no-replicated-database, no-shared-merge-tree\n+-- no-shared-merge-tree -- smt doesn't support aux zookeepers\n+\n+DROP TABLE IF EXISTS test_system_zookeeper_auxiliary;\n+\n+CREATE TABLE test_system_zookeeper_auxiliary (\n+    key UInt64\n+)\n+ENGINE ReplicatedMergeTree('zookeeper2:/clickhouse/{database}/02731_test_system_zookeeper_auxiliary/{shard}', '{replica}')\n+ORDER BY tuple();\n+\n+SELECT DISTINCT zookeeperName FROM system.zookeeper WHERE path = '/' AND zookeeperName = 'default';\n+SELECT DISTINCT zookeeperName FROM system.zookeeper WHERE path = '/' AND zookeeperName = 'zookeeper2';\n+\n+SELECT count() FROM system.zookeeper WHERE path IN '/' AND zookeeperName = 'zookeeper3'; -- { serverError BAD_ARGUMENTS }\n+\n+SELECT count() = 0 FROM system.zookeeper WHERE path IN '/' AND zookeeperName = 'default' AND zookeeperName = 'zookeeper2';\n+SELECT count() > 0 FROM system.zookeeper WHERE path IN '/' AND zookeeperName = 'zookeeper2' AND zookeeperName = 'zookeeper2';\n+\n+DROP TABLE IF EXISTS test_system_zookeeper_auxiliary;\ndiff --git a/tests/queries/0_stateless/02976_system_zookeeper_filters.reference b/tests/queries/0_stateless/02976_system_zookeeper_filters.reference\nindex a9e2f17562ae..fcb49fa99454 100644\n--- a/tests/queries/0_stateless/02976_system_zookeeper_filters.reference\n+++ b/tests/queries/0_stateless/02976_system_zookeeper_filters.reference\n@@ -4,3 +4,4 @@\n 1\n 1\n 1\n+1\ndiff --git a/tests/queries/0_stateless/02976_system_zookeeper_filters.sql b/tests/queries/0_stateless/02976_system_zookeeper_filters.sql\nindex 3664c817da74..508f224b233c 100644\n--- a/tests/queries/0_stateless/02976_system_zookeeper_filters.sql\n+++ b/tests/queries/0_stateless/02976_system_zookeeper_filters.sql\n@@ -15,3 +15,8 @@ SELECT count() > 0 FROM system.zookeeper WHERE name LIKE '%_%';\n SELECT count() > 0 FROM system.zookeeper WHERE value LIKE '%';\n SELECT count() > 0 FROM system.zookeeper WHERE path LIKE '/%';\n SELECT count() > 0 FROM system.zookeeper WHERE path = '/';\n+\n+SET allow_unrestricted_reads_from_keeper = DEFAULT;\n+\n+SELECT count() > 0 FROM system.zookeeper WHERE path = '/' AND zookeeperName  = 'unknown'; -- { serverError BAD_ARGUMENTS }\n+SELECT count() > 0 FROM system.zookeeper WHERE path = '/' AND zookeeperName  = 'default';\n",
  "problem_statement": "Support auxiliary_zookeepers in system.zookeeper\nFor instance one time I was using the replication protocol to migrate the data, for this I added source keeper into `auxiliary_zookeepers` and I was needed introspection of both keepers.\n",
  "hints_text": "May be, it simpler to add it like table function? zookeeper('aux_zookeeper_name')",
  "created_at": "2025-05-13T03:55:33Z"
}