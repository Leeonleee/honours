{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 27984,
  "instance_id": "ClickHouse__ClickHouse-27984",
  "issue_numbers": [
    "26151"
  ],
  "base_commit": "35fae3426b75bf9dc20e898246794671c6b7ef0a",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.cpp b/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.cpp\nindex 6b5a2c6ee173..7ca6f9ff1bd8 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.cpp\n@@ -51,7 +51,18 @@ ColumnWithTypeAndName getPreparedSetInfo(const SetPtr & prepared_set)\n     return {ColumnTuple::create(set_elements), std::make_shared<DataTypeTuple>(prepared_set->getElementsTypes()), \"dummy\"};\n }\n \n-bool maybeTrueOnBloomFilter(const IColumn * hash_column, const BloomFilterPtr & bloom_filter, size_t hash_functions)\n+bool hashMatchesFilter(const BloomFilterPtr& bloom_filter, UInt64 hash, size_t hash_functions)\n+{\n+    return std::all_of(BloomFilterHash::bf_hash_seed,\n+                       BloomFilterHash::bf_hash_seed + hash_functions,\n+                       [&](const auto &hash_seed)\n+                       {\n+                           return bloom_filter->findHashWithSeed(hash,\n+                                                                 hash_seed);\n+                       });\n+}\n+\n+bool maybeTrueOnBloomFilter(const IColumn * hash_column, const BloomFilterPtr & bloom_filter, size_t hash_functions, bool match_all)\n {\n     const auto * const_column = typeid_cast<const ColumnConst *>(hash_column);\n     const auto * non_const_column = typeid_cast<const ColumnUInt64 *>(hash_column);\n@@ -61,26 +72,34 @@ bool maybeTrueOnBloomFilter(const IColumn * hash_column, const BloomFilterPtr &\n \n     if (const_column)\n     {\n-        for (size_t index = 0; index < hash_functions; ++index)\n-            if (!bloom_filter->findHashWithSeed(const_column->getValue<UInt64>(), BloomFilterHash::bf_hash_seed[index]))\n-                return false;\n-        return true;\n+        return hashMatchesFilter(bloom_filter,\n+                                 const_column->getValue<UInt64>(),\n+                                 hash_functions);\n     }\n-    else\n-    {\n-        bool missing_rows = true;\n-        const ColumnUInt64::Container & data = non_const_column->getData();\n \n-        for (size_t index = 0, size = data.size(); missing_rows && index < size; ++index)\n-        {\n-            bool match_row = true;\n-            for (size_t hash_index = 0; match_row && hash_index < hash_functions; ++hash_index)\n-                match_row = bloom_filter->findHashWithSeed(data[index], BloomFilterHash::bf_hash_seed[hash_index]);\n+    const ColumnUInt64::Container & hashes = non_const_column->getData();\n \n-            missing_rows = !match_row;\n-        }\n-\n-        return !missing_rows;\n+    if (match_all)\n+    {\n+        return std::all_of(hashes.begin(),\n+                           hashes.end(),\n+                           [&](const auto& hash_row)\n+                           {\n+                               return hashMatchesFilter(bloom_filter,\n+                                                        hash_row,\n+                                                        hash_functions);\n+                           });\n+    }\n+    else\n+    {\n+        return std::any_of(hashes.begin(),\n+                           hashes.end(),\n+                           [&](const auto& hash_row)\n+                           {\n+                               return hashMatchesFilter(bloom_filter,\n+                                                        hash_row,\n+                                                        hash_functions);\n+                           });\n     }\n }\n \n@@ -109,6 +128,7 @@ bool MergeTreeIndexConditionBloomFilter::alwaysUnknownOrTrue() const\n             || element.function == RPNElement::FUNCTION_NOT_EQUALS\n             || element.function == RPNElement::FUNCTION_HAS\n             || element.function == RPNElement::FUNCTION_HAS_ANY\n+            || element.function == RPNElement::FUNCTION_HAS_ALL\n             || element.function == RPNElement::FUNCTION_IN\n             || element.function == RPNElement::FUNCTION_NOT_IN\n             || element.function == RPNElement::ALWAYS_FALSE)\n@@ -156,16 +176,23 @@ bool MergeTreeIndexConditionBloomFilter::mayBeTrueOnGranule(const MergeTreeIndex\n             || element.function == RPNElement::FUNCTION_EQUALS\n             || element.function == RPNElement::FUNCTION_NOT_EQUALS\n             || element.function == RPNElement::FUNCTION_HAS\n-            || element.function == RPNElement::FUNCTION_HAS_ANY)\n+            || element.function == RPNElement::FUNCTION_HAS_ANY\n+            || element.function == RPNElement::FUNCTION_HAS_ALL)\n         {\n             bool match_rows = true;\n+            bool match_all = element.function == RPNElement::FUNCTION_HAS_ALL;\n             const auto & predicate = element.predicate;\n             for (size_t index = 0; match_rows && index < predicate.size(); ++index)\n             {\n                 const auto & query_index_hash = predicate[index];\n                 const auto & filter = filters[query_index_hash.first];\n                 const ColumnPtr & hash_column = query_index_hash.second;\n-                match_rows = maybeTrueOnBloomFilter(&*hash_column, filter, hash_functions);\n+\n+\n+                match_rows = maybeTrueOnBloomFilter(&*hash_column,\n+                                                    filter,\n+                                                    hash_functions,\n+                                                    match_all);\n             }\n \n             rpn_stack.emplace_back(match_rows, true);\n@@ -255,7 +282,12 @@ bool MergeTreeIndexConditionBloomFilter::traverseFunction(const ASTPtr & node, B\n                     maybe_useful = true;\n             }\n         }\n-        else if (function->name == \"equals\" || function->name  == \"notEquals\" || function->name == \"has\" || function->name == \"indexOf\" || function->name == \"hasAny\")\n+        else if (function->name == \"equals\" ||\n+                 function->name == \"notEquals\" ||\n+                 function->name == \"has\" ||\n+                 function->name == \"indexOf\" ||\n+                 function->name == \"hasAny\" ||\n+                 function->name == \"hasAll\")\n         {\n             Field const_value;\n             DataTypePtr const_type;\n@@ -412,7 +444,7 @@ bool MergeTreeIndexConditionBloomFilter::traverseASTEquals(\n                 out.predicate.emplace_back(std::make_pair(position, BloomFilterHash::hashWithField(actual_type.get(), converted_field)));\n             }\n         }\n-        else if (function_name == \"hasAny\")\n+        else if (function_name == \"hasAny\" || function_name == \"hasAll\")\n         {\n             if (!array_type)\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be an array.\", function_name);\n@@ -437,7 +469,9 @@ bool MergeTreeIndexConditionBloomFilter::traverseASTEquals(\n                 column = std::move(mutable_column);\n             }\n \n-            out.function = RPNElement::FUNCTION_HAS_ANY;\n+            out.function = function_name == \"hasAny\" ?\n+                RPNElement::FUNCTION_HAS_ANY :\n+                RPNElement::FUNCTION_HAS_ALL;\n             out.predicate.emplace_back(std::make_pair(position, BloomFilterHash::hashWithColumn(actual_type, column, 0, column->size())));\n         }\n         else\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.h b/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.h\nindex fa48b966a929..f2bbd047ca10 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexConditionBloomFilter.h\n@@ -25,6 +25,7 @@ class MergeTreeIndexConditionBloomFilter final : public IMergeTreeIndexCondition\n             FUNCTION_NOT_EQUALS,\n             FUNCTION_HAS,\n             FUNCTION_HAS_ANY,\n+            FUNCTION_HAS_ALL,\n             FUNCTION_IN,\n             FUNCTION_NOT_IN,\n             FUNCTION_UNKNOWN, /// Can take any value.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02013_bloom_filter_hasAll.reference b/tests/queries/0_stateless/02013_bloom_filter_hasAll.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql b/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql\nnew file mode 100644\nindex 000000000000..adba3db6cf5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql\n@@ -0,0 +1,41 @@\n+DROP TABLE IF EXISTS bftest;\n+CREATE TABLE bftest (\n+    k Int64,\n+    y Array(Int64) DEFAULT x,\n+    x Array(Int64),\n+    index ix1(x) TYPE bloom_filter GRANULARITY 3\n+)\n+Engine=MergeTree\n+ORDER BY k;\n+\n+INSERT INTO bftest (k, x) SELECT number, arrayMap(i->rand64()%565656, range(10)) FROM numbers(1000);\n+\n+-- index is not used, but query should still work\n+SELECT count() FROM bftest WHERE hasAll(x, materialize([1,2,3])) FORMAT Null;\n+\n+-- verify the expression in WHERE works on non-index col the same way as on index cols\n+SELECT count() FROM bftest WHERE hasAll(y, [NULL,-42]) FORMAT Null;\n+SELECT count() FROM bftest WHERE hasAll(y, [0,NULL]) FORMAT Null;\n+SELECT count() FROM bftest WHERE hasAll(y, [[123], -42]) FORMAT Null; -- { serverError 386 }\n+SELECT count() FROM bftest WHERE hasAll(y, [toDecimal32(123, 3), 2]) FORMAT Null; -- different, doesn't fail\n+\n+SET force_data_skipping_indices='ix1';\n+SELECT count() FROM bftest WHERE has (x, 42) and has(x, -42) FORMAT Null;\n+SELECT count() FROM bftest WHERE hasAll(x, [42,-42]) FORMAT Null;\n+SELECT count() FROM bftest WHERE hasAll(x, []) FORMAT Null;\n+SELECT count() FROM bftest WHERE hasAll(x, [1]) FORMAT Null;\n+\n+-- can't use bloom_filter with `hasAll` on non-constant arguments (just like `has`)\n+SELECT count() FROM bftest WHERE hasAll(x, materialize([1,2,3])) FORMAT Null; -- { serverError 277 }\n+\n+-- NULLs are not Ok\n+SELECT count() FROM bftest WHERE hasAll(x, [NULL,-42]) FORMAT Null; -- { serverError 277 }\n+SELECT count() FROM bftest WHERE hasAll(x, [0,NULL]) FORMAT Null; -- { serverError 277 }\n+\n+-- non-compatible types\n+SELECT count() FROM bftest WHERE hasAll(x, [[123], -42]) FORMAT Null; -- { serverError 386 }\n+SELECT count() FROM bftest WHERE hasAll(x, [toDecimal32(123, 3), 2]) FORMAT Null; -- { serverError 277 }\n+\n+-- Bug discovered by AST fuzzier (fixed, shouldn't crash).\n+SELECT 1 FROM bftest WHERE has(x, -0.) OR 0. FORMAT Null;\n+SELECT count() FROM bftest WHERE hasAll(x, [0, 1]) OR 0. FORMAT Null;\n",
  "problem_statement": "hasAll() filter condition not relying on bloom filter; re-writing as has() AND has()... does use bloom_filter \n**Describe the situation**\r\nhasAll() filter condition not relying on bloom filter, but re-writing as series of has() AND has()... (or series of indexOf conditions) does use bloom filter \r\n\r\n**How to reproduce**\r\n* ClickHouse server version: 21.2.7.2\r\n\r\nTest Table: \r\n- 33M records, 10 columns\r\n- MergeTree() engine, has a sort order specified\r\n- Has a field STRING_ARRAY that is a Array(String) column. It has a bloom filter data-skipping index (`TYPE bloom_filter(0.01) GRANULARITY 1`)\r\n\r\nThe following query takes 1.5 seconds: \r\n```\r\nSELECT * FROM db_name.table_name\r\nWHERE hasAll(STRING_ARRAY, ['value_1', 'value_2', 'value_3']\r\n```\r\nRunning `EXPLAIN indexes = 1`, only the primary key is picked up. The bloom filter isn't used. \r\n\r\nThe following query takes 0.45 seconds: \r\n```\r\nSELECT * FROM db_name.table_name\r\nWHERE has(STRING_ARRAY, 'value_1') AND has(STRING_ARRAY, 'value_2') AND has(STRING_ARRAY, 'value_3')\r\n```\r\nRunning `EXPLAIN indexes = 1`, the bloom filter is used. \r\n\r\n**Expected performance**\r\nExpecting the hasAll() filter condition to also get performance improvement from the bloom filter on STRING_ARRAY. \r\n\n",
  "hints_text": "This feature would be nice to have. Probably easy to do...\nRelated to #24900 (hasAny is already supported).\r\nCC @Enmk \nHi, may I get assigned to this issue? I would like to contribute the fix\nI'm making my way through the RPN calculations and the bloom filters, but if anyone needs this feature **right now**  I don't mind another person contributing it. ",
  "created_at": "2021-08-22T09:51:29Z"
}