{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 26123,
  "instance_id": "ClickHouse__ClickHouse-26123",
  "issue_numbers": [
    "25806"
  ],
  "base_commit": "a24d2c1fafd765a6dea62171aae0fc2a7df275de",
  "patch": "diff --git a/src/DataTypes/EnumValues.h b/src/DataTypes/EnumValues.h\nindex d03a8867e420..1e5e4f55ea75 100644\n--- a/src/DataTypes/EnumValues.h\n+++ b/src/DataTypes/EnumValues.h\n@@ -42,11 +42,23 @@ class EnumValues : public IHints<1, EnumValues<T>>\n         return it;\n     }\n \n+    /// throws exception if value is not valid\n     const StringRef & getNameForValue(const T & value) const\n     {\n         return findByValue(value)->second;\n     }\n \n+    /// returns false if value is not valid\n+    bool getNameForValue(const T & value, StringRef & result) const\n+    {\n+        const auto it = value_to_name_map.find(value);\n+        if (it == std::end(value_to_name_map))\n+            return false;\n+\n+        result = it->second;\n+        return true;\n+    }\n+\n     T getValue(StringRef field_name, bool try_treat_as_id = false) const;\n \n     template <typename TValues>\ndiff --git a/src/Functions/FunctionHelpers.cpp b/src/Functions/FunctionHelpers.cpp\nindex dcdd0e521eb0..eac1a7ad1a10 100644\n--- a/src/Functions/FunctionHelpers.cpp\n+++ b/src/Functions/FunctionHelpers.cpp\n@@ -49,47 +49,48 @@ Columns convertConstTupleToConstantElements(const ColumnConst & column)\n     return res;\n }\n \n-\n-ColumnsWithTypeAndName createBlockWithNestedColumns(const ColumnsWithTypeAndName & columns)\n+ColumnWithTypeAndName columnGetNested(const ColumnWithTypeAndName & col)\n {\n-    ColumnsWithTypeAndName res;\n-    for (const auto & col : columns)\n+    if (col.type->isNullable())\n     {\n-        if (col.type->isNullable())\n+        const DataTypePtr & nested_type = static_cast<const DataTypeNullable &>(*col.type).getNestedType();\n+\n+        if (!col.column)\n+        {\n+            return ColumnWithTypeAndName{nullptr, nested_type, col.name};\n+        }\n+        else if (const auto * nullable = checkAndGetColumn<ColumnNullable>(*col.column))\n+        {\n+            const auto & nested_col = nullable->getNestedColumnPtr();\n+            return ColumnWithTypeAndName{nested_col, nested_type, col.name};\n+        }\n+        else if (const auto * const_column = checkAndGetColumn<ColumnConst>(*col.column))\n         {\n-            const DataTypePtr & nested_type = static_cast<const DataTypeNullable &>(*col.type).getNestedType();\n+            const auto * nullable_column = checkAndGetColumn<ColumnNullable>(const_column->getDataColumn());\n \n-            if (!col.column)\n+            ColumnPtr nullable_res;\n+            if (nullable_column)\n             {\n-                res.emplace_back(ColumnWithTypeAndName{nullptr, nested_type, col.name});\n+                const auto & nested_col = nullable_column->getNestedColumnPtr();\n+                nullable_res = ColumnConst::create(nested_col, col.column->size());\n             }\n-            else if (const auto * nullable = checkAndGetColumn<ColumnNullable>(*col.column))\n-            {\n-                const auto & nested_col = nullable->getNestedColumnPtr();\n-                res.emplace_back(ColumnWithTypeAndName{nested_col, nested_type, col.name});\n-            }\n-            else if (const auto * const_column = checkAndGetColumn<ColumnConst>(*col.column))\n+            else\n             {\n-                const auto * nullable_column = checkAndGetColumn<ColumnNullable>(const_column->getDataColumn());\n-\n-                ColumnPtr nullable_res;\n-                if (nullable_column)\n-                {\n-                    const auto & nested_col = nullable_column->getNestedColumnPtr();\n-                    nullable_res = ColumnConst::create(nested_col, col.column->size());\n-                }\n-                else\n-                {\n-                    nullable_res = makeNullable(col.column);\n-                }\n-                res.emplace_back(ColumnWithTypeAndName{ nullable_res, nested_type, col.name });\n+                nullable_res = makeNullable(col.column);\n             }\n-            else\n-                throw Exception(\"Illegal column for DataTypeNullable\", ErrorCodes::ILLEGAL_COLUMN);\n+            return ColumnWithTypeAndName{ nullable_res, nested_type, col.name };\n         }\n         else\n-            res.emplace_back(col);\n+            throw Exception(\"Illegal column for DataTypeNullable\", ErrorCodes::ILLEGAL_COLUMN);\n     }\n+    return col;\n+}\n+\n+ColumnsWithTypeAndName createBlockWithNestedColumns(const ColumnsWithTypeAndName & columns)\n+{\n+    ColumnsWithTypeAndName res;\n+    for (const auto & col : columns)\n+        res.emplace_back(columnGetNested(col));\n \n     return res;\n }\ndiff --git a/src/Functions/FunctionHelpers.h b/src/Functions/FunctionHelpers.h\nindex 7ab008b8bea1..5abe24f4e50c 100644\n--- a/src/Functions/FunctionHelpers.h\n+++ b/src/Functions/FunctionHelpers.h\n@@ -81,6 +81,8 @@ inline std::enable_if_t<IsDecimalNumber<T>, Field> toField(const T & x, UInt32 s\n \n Columns convertConstTupleToConstantElements(const ColumnConst & column);\n \n+/// Returns nested column with corrected type if nullable\n+ColumnWithTypeAndName columnGetNested(const ColumnWithTypeAndName & col);\n \n /// Returns the copy of a given columns in which each column is replaced with its respective nested\n /// column if it is nullable.\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex ff97894d98e9..4cb5b5744752 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -579,36 +579,44 @@ template <typename Name> struct ConvertImpl<DataTypeDateTime, DataTypeDateTime64\n template <typename DataType>\n struct FormatImpl\n {\n-    static void execute(const typename DataType::FieldType x, WriteBuffer & wb, const DataType *, const DateLUTImpl *)\n+    template <typename ReturnType = void>\n+    static ReturnType execute(const typename DataType::FieldType x, WriteBuffer & wb, const DataType *, const DateLUTImpl *)\n     {\n         writeText(x, wb);\n+        return ReturnType(true);\n     }\n };\n \n template <>\n struct FormatImpl<DataTypeDate>\n {\n-    static void execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl *)\n+    template <typename ReturnType = void>\n+    static ReturnType execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl *)\n     {\n         writeDateText(DayNum(x), wb);\n+        return ReturnType(true);\n     }\n };\n \n template <>\n struct FormatImpl<DataTypeDateTime>\n {\n-    static void execute(const DataTypeDateTime::FieldType x, WriteBuffer & wb, const DataTypeDateTime *, const DateLUTImpl * time_zone)\n+    template <typename ReturnType = void>\n+    static ReturnType execute(const DataTypeDateTime::FieldType x, WriteBuffer & wb, const DataTypeDateTime *, const DateLUTImpl * time_zone)\n     {\n         writeDateTimeText(x, wb, *time_zone);\n+        return ReturnType(true);\n     }\n };\n \n template <>\n struct FormatImpl<DataTypeDateTime64>\n {\n-    static void execute(const DataTypeDateTime64::FieldType x, WriteBuffer & wb, const DataTypeDateTime64 * type, const DateLUTImpl * time_zone)\n+    template <typename ReturnType = void>\n+    static ReturnType execute(const DataTypeDateTime64::FieldType x, WriteBuffer & wb, const DataTypeDateTime64 * type, const DateLUTImpl * time_zone)\n     {\n         writeDateTimeText(DateTime64(x), type->getScale(), wb, *time_zone);\n+        return ReturnType(true);\n     }\n };\n \n@@ -616,18 +624,34 @@ struct FormatImpl<DataTypeDateTime64>\n template <typename FieldType>\n struct FormatImpl<DataTypeEnum<FieldType>>\n {\n-    static void execute(const FieldType x, WriteBuffer & wb, const DataTypeEnum<FieldType> * type, const DateLUTImpl *)\n+    template <typename ReturnType = void>\n+    static ReturnType execute(const FieldType x, WriteBuffer & wb, const DataTypeEnum<FieldType> * type, const DateLUTImpl *)\n     {\n-        writeString(type->getNameForValue(x), wb);\n+        static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+\n+        if constexpr (throw_exception)\n+        {\n+            writeString(type->getNameForValue(x), wb);\n+        }\n+        else\n+        {\n+            StringRef res;\n+            bool is_ok = type->getNameForValue(x, res);\n+            if (is_ok)\n+                writeString(res, wb);\n+            return ReturnType(is_ok);\n+        }\n     }\n };\n \n template <typename FieldType>\n struct FormatImpl<DataTypeDecimal<FieldType>>\n {\n-    static void execute(const FieldType x, WriteBuffer & wb, const DataTypeDecimal<FieldType> * type, const DateLUTImpl *)\n+    template <typename ReturnType = void>\n+    static ReturnType execute(const FieldType x, WriteBuffer & wb, const DataTypeDecimal<FieldType> * type, const DateLUTImpl *)\n     {\n         writeText(x, type->getScale(), wb);\n+        return ReturnType(true);\n     }\n };\n \n@@ -642,6 +666,16 @@ struct ConvertImpl<DataTypeEnum<FieldType>, DataTypeNumber<FieldType>, Name, Con\n     }\n };\n \n+static ColumnUInt8::MutablePtr copyNullMap(ColumnPtr col)\n+{\n+    ColumnUInt8::MutablePtr null_map = nullptr;\n+    if (const auto * col_null = checkAndGetColumn<ColumnNullable>(col.get()))\n+    {\n+        null_map = ColumnUInt8::create();\n+        null_map->insertRangeFrom(col_null->getNullMapColumn(), 0, col_null->size());\n+    }\n+    return null_map;\n+}\n \n template <typename FromDataType, typename Name>\n struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType, DataTypeString>, DataTypeString>, Name, ConvertDefaultBehaviorTag>\n@@ -651,13 +685,18 @@ struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType,\n \n     static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/)\n     {\n-        const auto & col_with_type_and_name = arguments[0];\n+        ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);\n+\n+        const auto & col_with_type_and_name =  columnGetNested(arguments[0]);\n         const auto & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);\n \n         const DateLUTImpl * time_zone = nullptr;\n         /// For argument of DateTime type, second argument with time zone could be specified.\n         if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDateTime64>)\n-            time_zone = &extractTimeZoneFromFunctionArguments(arguments, 1, 0);\n+        {\n+            auto non_null_args = createBlockWithNestedColumns(arguments);\n+            time_zone = &extractTimeZoneFromFunctionArguments(non_null_args, 1, 0);\n+        }\n \n         if (const auto col_from = checkAndGetColumn<ColVecType>(col_with_type_and_name.column.get()))\n         {\n@@ -681,14 +720,30 @@ struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType,\n \n             WriteBufferFromVector<ColumnString::Chars> write_buffer(data_to);\n \n-            for (size_t i = 0; i < size; ++i)\n+            if (null_map)\n             {\n-                FormatImpl<FromDataType>::execute(vec_from[i], write_buffer, &type, time_zone);\n-                writeChar(0, write_buffer);\n-                offsets_to[i] = write_buffer.count();\n+                for (size_t i = 0; i < size; ++i)\n+                {\n+                    bool is_ok = FormatImpl<FromDataType>::template execute<bool>(vec_from[i], write_buffer, &type, time_zone);\n+                    null_map->getData()[i] |= !is_ok;\n+                    writeChar(0, write_buffer);\n+                    offsets_to[i] = write_buffer.count();\n+                }\n+            }\n+            else\n+            {\n+                for (size_t i = 0; i < size; ++i)\n+                {\n+                    FormatImpl<FromDataType>::template execute<void>(vec_from[i], write_buffer, &type, time_zone);\n+                    writeChar(0, write_buffer);\n+                    offsets_to[i] = write_buffer.count();\n+                }\n             }\n \n             write_buffer.finalize();\n+\n+            if (null_map)\n+                return ColumnNullable::create(std::move(col_to), std::move(null_map));\n             return col_to;\n         }\n         else\n@@ -702,9 +757,11 @@ struct ConvertImpl<FromDataType, std::enable_if_t<!std::is_same_v<FromDataType,\n /// Generic conversion of any type to String.\n struct ConvertImplGenericToString\n {\n-    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments)\n+    static ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type)\n     {\n-        const auto & col_with_type_and_name = arguments[0];\n+        ColumnUInt8::MutablePtr null_map = copyNullMap(arguments[0].column);\n+\n+        const auto & col_with_type_and_name = columnGetNested(arguments[0]);\n         const IDataType & type = *col_with_type_and_name.type;\n         const IColumn & col_from = *col_with_type_and_name.column;\n \n@@ -730,6 +787,9 @@ struct ConvertImplGenericToString\n         }\n \n         write_buffer.finalize();\n+\n+        if (result_type->isNullable() && null_map)\n+            return ColumnNullable::create(std::move(col_to), std::move(null_map));\n         return col_to;\n     }\n };\n@@ -1398,7 +1458,11 @@ class FunctionConvert : public IFunction\n     /// Function actually uses default implementation for nulls,\n     /// but we need to know if return type is Nullable or not,\n     /// so we use checked_return_type only to intercept the first call to getReturnTypeImpl(...).\n-    bool useDefaultImplementationForNulls() const override { return checked_return_type; }\n+    bool useDefaultImplementationForNulls() const override\n+    {\n+        bool to_nullable_string = to_nullable && std::is_same_v<ToDataType, DataTypeString>;\n+        return checked_return_type && !to_nullable_string;\n+    }\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override\n@@ -1463,7 +1527,10 @@ class FunctionConvert : public IFunction\n             throw Exception{\"Function \" + getName() + \" expects at least 1 argument\",\n                ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION};\n \n-        const IDataType * from_type = arguments[0].type.get();\n+        if (result_type->onlyNull())\n+            return result_type->createColumnConstWithDefaultValue(input_rows_count);\n+\n+        const DataTypePtr from_type = removeNullable(arguments[0].type);\n         ColumnPtr result_column;\n \n         auto call = [&](const auto & types, const auto & tag) -> bool\n@@ -1559,7 +1626,7 @@ class FunctionConvert : public IFunction\n             /// Generic conversion of any type to String.\n             if (std::is_same_v<ToDataType, DataTypeString>)\n             {\n-                return ConvertImplGenericToString::execute(arguments);\n+                return ConvertImplGenericToString::execute(arguments, result_type);\n             }\n             else\n                 throw Exception(\"Illegal type \" + arguments[0].type->getName() + \" of argument of function \" + getName(),\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00850_global_join_dups.reference b/tests/queries/0_stateless/00850_global_join_dups.reference\nindex d94e4df34259..bbe467dd08e6 100644\n--- a/tests/queries/0_stateless/00850_global_join_dups.reference\n+++ b/tests/queries/0_stateless/00850_global_join_dups.reference\n@@ -1,5 +1,6 @@\n 1\n \\N\n+\\N\n 0\n 0\n 0\t0\ndiff --git a/tests/queries/0_stateless/00850_global_join_dups.sql b/tests/queries/0_stateless/00850_global_join_dups.sql\nindex 92c1d81aa8ef..5843bf9c2278 100644\n--- a/tests/queries/0_stateless/00850_global_join_dups.sql\n+++ b/tests/queries/0_stateless/00850_global_join_dups.sql\n@@ -22,6 +22,8 @@ GLOBAL INNER JOIN\n -- query from fuzzer\n SELECT toDateTime64(toString(toString('0000-00-00 00:00:000000-00-00 00:00:00', toDateTime64(toDateTime64('655.36', -2, NULL)))), NULL) FROM t1_00850 GLOBAL INNER JOIN (SELECT toDateTime64(toDateTime64('6553.6', '', NULL), NULL), * FROM (SELECT * FROM t2_00850) INNER JOIN (SELECT toDateTime64('6553.7', 1024, NULL), * FROM t1_00850) USING (dummy)) USING (dummy);\n \n+SELECT toString('0000-00-00 00:00:000000-00-00 00:00:00', toDateTime64(toDateTime64('655.36', -2, NULL)));\n+\n DROP TABLE t_local;\n DROP TABLE t1_00850;\n DROP TABLE t2_00850;\ndiff --git a/tests/queries/0_stateless/01736_null_as_default.reference b/tests/queries/0_stateless/01736_null_as_default.reference\nindex baf83eb21d7d..d201a9636efd 100644\n--- a/tests/queries/0_stateless/01736_null_as_default.reference\n+++ b/tests/queries/0_stateless/01736_null_as_default.reference\n@@ -1,2 +1,5 @@\n A\n \\N\n+A\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/01736_null_as_default.sql b/tests/queries/0_stateless/01736_null_as_default.sql\nindex a00011b06d4b..c897d035a50c 100644\n--- a/tests/queries/0_stateless/01736_null_as_default.sql\n+++ b/tests/queries/0_stateless/01736_null_as_default.sql\n@@ -2,4 +2,6 @@ drop table if exists test_enum;\n create table test_enum (c Nullable(Enum16('A' = 1, 'B' = 2))) engine Log;\n insert into test_enum values (1), (NULL);\n select * from test_enum;\n+select toString(c) from test_enum;\n+select toString('aaaa', NULL);\n drop table test_enum;\n",
  "problem_statement": "Setting use_join_nulls to 1 may throw an exception unexpectedly\n**Describe the bug**\r\n\r\nA combination of `use_join_nulls=1`, a `Nullable(enum)` column, `OUTER JOIN`, and `toString()` may throw an exception while generating a result.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nThis happens on 21.6.3 stable.\r\n\r\n**How to reproduce**\r\n\r\nWith the following setup:\r\n\r\n```sql\r\nCREATE TABLE a (\r\n  key  String\r\n) ENGINE=MergeTree ORDER BY key;\r\n\r\nCREATE TABLE b (\r\n  key  String,\r\n  data Nullable(Enum16('a'=1, 'b'=2))\r\n) ENGINE=MergeTree ORDER BY key;\r\n\r\nINSERT INTO a VALUES('x');\r\nINSERT INTO a VALUES('y');\r\n\r\nINSERT INTO b VALUES('x', 'a');\r\n```\r\n\r\nThis query appears to work correctly:\r\n```\r\nSELECT\r\n\tkey, data\r\nFROM a\r\nANY LEFT OUTER JOIN b USING (key)\r\nFORMAT JSONCompact\r\nSETTINGS join_use_nulls = 1;\r\n```\r\n\r\n```\r\n{\r\n        \"meta\":\r\n        [\r\n                {\r\n                        \"name\": \"key\",\r\n                        \"type\": \"String\"\r\n                },\r\n                {\r\n                        \"name\": \"data\",\r\n                        \"type\": \"Nullable(Enum16('a' = 1, 'b' = 2))\"\r\n                }\r\n        ],\r\n        \"data\":\r\n        [\r\n                [\"y\", null],                                                                                                                                                                                                \r\n                [\"x\", \"a\"]                                                                                                                                                                                                     \r\n        ],\r\n        \"rows\": 2,\r\n        \"statistics\":\r\n        {\r\n                \"elapsed\": 0.002955967,\r\n                \"rows_read\": 3,\r\n                \"bytes_read\": 33\r\n        }\r\n}\r\n```\r\n\r\nBut it throws an exception when `toString()` is applied to the joined column:\r\n\r\n```sql\r\nSELECT\r\n\tkey, toString(data)\r\nFROM a\r\nLEFT OUTER JOIN b USING (key)\r\nFORMAT JSONCompact\r\nSETTINGS join_use_nulls = 1;\r\n```\r\n\r\n```\r\n{\r\n        \"meta\":\r\n        [\r\n                {\r\n                        \"name\": \"key\",\r\n                        \"type\": \"String\"\r\n                },\r\n                {\r\n                        \"name\": \"toString(data)\",\r\n                        \"type\": \"Nullable(String)\"\r\n                }\r\n        ],\r\n\r\n        \"data\":\r\n        [\r\n                [\"x\", \"a\"]                                                                                                                                                                                                      Progress: 0.00 rows, 0.00 B (0.00 rows/s., 0.00 B/s.)\r\n1 rows in set. Elapsed: 0.003 sec.\r\n\r\nReceived exception from server (version 21.6.3):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: Unexpected value 0 in enum: while executing 'FUNCTION toString(data :: 1) -> toString(data) Nullable(String) : 2'.\r\n```\r\n\r\n**Expected behavior**\r\n\r\nIt produces a string `NULL` without throwing an exception.\n",
  "hints_text": "",
  "created_at": "2021-07-09T12:20:25Z"
}