{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68477,
  "instance_id": "ClickHouse__ClickHouse-68477",
  "issue_numbers": [
    "68244"
  ],
  "base_commit": "054b38d4ebeabc33010fb532766f937af2d44c03",
  "patch": "diff --git a/docs/en/operations/query-cache.md b/docs/en/operations/query-cache.md\nindex 384938e28f60..955cec0234e9 100644\n--- a/docs/en/operations/query-cache.md\n+++ b/docs/en/operations/query-cache.md\n@@ -155,6 +155,8 @@ SELECT 1 SETTINGS use_query_cache = true, query_cache_tag = 'tag 1';\n SELECT 1 SETTINGS use_query_cache = true, query_cache_tag = 'tag 2';\n ```\n \n+To remove only entries with tag `tag` from the query cache, you can use statement `SYSTEM DROP QUERY CACHE TAG 'tag'`.\n+\n ClickHouse reads table data in blocks of [max_block_size](settings/settings.md#setting-max_block_size) rows. Due to filtering, aggregation,\n etc., result blocks are typically much smaller than 'max_block_size' but there are also cases where they are much bigger. Setting\n [query_cache_squash_partial_results](settings/settings.md#query-cache-squash-partial-results) (enabled by default) controls if result blocks\ndiff --git a/docs/en/sql-reference/statements/system.md b/docs/en/sql-reference/statements/system.md\nindex 3ebcf617491a..77d023b67ce3 100644\n--- a/docs/en/sql-reference/statements/system.md\n+++ b/docs/en/sql-reference/statements/system.md\n@@ -136,7 +136,13 @@ The compiled expression cache is enabled/disabled with the query/user/profile-le\n \n ## DROP QUERY CACHE\n \n+```sql\n+SYSTEM DROP QUERY CACHE;\n+SYSTEM DROP QUERY CACHE TAG '<tag>'\n+````\n+\n Clears the [query cache](../../operations/query-cache.md).\n+If a tag is specified, only query cache entries with the specified tag are deleted.\n \n ## DROP FORMAT SCHEMA CACHE {#system-drop-schema-format}\n \ndiff --git a/src/Common/CacheBase.h b/src/Common/CacheBase.h\nindex a809136f4511..23e6a6fc91c6 100644\n--- a/src/Common/CacheBase.h\n+++ b/src/Common/CacheBase.h\n@@ -197,6 +197,12 @@ class CacheBase\n         cache_policy->remove(key);\n     }\n \n+    void remove(std::function<bool(const Key&, const MappedPtr &)> predicate)\n+    {\n+        std::lock_guard lock(mutex);\n+        cache_policy->remove(predicate);\n+    }\n+\n     size_t sizeInBytes() const\n     {\n         std::lock_guard lock(mutex);\ndiff --git a/src/Common/ICachePolicy.h b/src/Common/ICachePolicy.h\nindex 301a5c6cbbdb..567fa35d9770 100644\n--- a/src/Common/ICachePolicy.h\n+++ b/src/Common/ICachePolicy.h\n@@ -55,6 +55,7 @@ class ICachePolicy\n     virtual void set(const Key & key, const MappedPtr & mapped) = 0;\n \n     virtual void remove(const Key & key) = 0;\n+    virtual void remove(std::function<bool(const Key & key, const MappedPtr & mapped)> predicate) = 0;\n \n     virtual void clear() = 0;\n     virtual std::vector<KeyMapped> dump() const = 0;\ndiff --git a/src/Common/LRUCachePolicy.h b/src/Common/LRUCachePolicy.h\nindex f833e46a8212..cb8fdbd2b9c4 100644\n--- a/src/Common/LRUCachePolicy.h\n+++ b/src/Common/LRUCachePolicy.h\n@@ -79,6 +79,22 @@ class LRUCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n         cells.erase(it);\n     }\n \n+    void remove(std::function<bool(const Key &, const MappedPtr &)> predicate) override\n+    {\n+        for (auto it = cells.begin(); it != cells.end();)\n+        {\n+            if (predicate(it->first, it->second.value))\n+            {\n+                Cell & cell = it->second;\n+                current_size_in_bytes -= cell.size;\n+                queue.erase(cell.queue_iterator);\n+                it = cells.erase(it);\n+            }\n+            else\n+                ++it;\n+        }\n+    }\n+\n     MappedPtr get(const Key & key) override\n     {\n         auto it = cells.find(key);\ndiff --git a/src/Common/SLRUCachePolicy.h b/src/Common/SLRUCachePolicy.h\nindex 354ec1d36d64..5321110f3e52 100644\n--- a/src/Common/SLRUCachePolicy.h\n+++ b/src/Common/SLRUCachePolicy.h\n@@ -95,6 +95,27 @@ class SLRUCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFun\n         cells.erase(it);\n     }\n \n+    void remove(std::function<bool(const Key &, const MappedPtr &)> predicate) override\n+    {\n+        for (auto it = cells.begin(); it != cells.end();)\n+        {\n+            if (predicate(it->first, it->second.value))\n+            {\n+                auto & cell = it->second;\n+\n+                current_size_in_bytes -= cell.size;\n+                if (cell.is_protected)\n+                    current_protected_size -= cell.size;\n+\n+                auto & queue = cell.is_protected ? protected_queue : probationary_queue;\n+                queue.erase(cell.queue_iterator);\n+                it = cells.erase(it);\n+            }\n+            else\n+                ++it;\n+        }\n+    }\n+\n     MappedPtr get(const Key & key) override\n     {\n         auto it = cells.find(key);\ndiff --git a/src/Common/TTLCachePolicy.h b/src/Common/TTLCachePolicy.h\nindex 6401835b0d7b..6c548e5042bd 100644\n--- a/src/Common/TTLCachePolicy.h\n+++ b/src/Common/TTLCachePolicy.h\n@@ -145,6 +145,23 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n         size_in_bytes -= sz;\n     }\n \n+    void remove(std::function<bool(const Key &, const MappedPtr &)> predicate) override\n+    {\n+        for (auto it = cache.begin(); it != cache.end();)\n+        {\n+            if (predicate(it->first, it->second))\n+            {\n+                size_t sz = weight_function(*it->second);\n+                if (it->first.user_id.has_value())\n+                    Base::user_quotas->decreaseActual(*it->first.user_id, sz);\n+                it = cache.erase(it);\n+                size_in_bytes -= sz;\n+            }\n+            else\n+                ++it;\n+        }\n+    }\n+\n     MappedPtr get(const Key & key) override\n     {\n         auto it = cache.find(key);\ndiff --git a/src/Interpreters/Cache/QueryCache.cpp b/src/Interpreters/Cache/QueryCache.cpp\nindex ab926037c670..4312b35e18c3 100644\n--- a/src/Interpreters/Cache/QueryCache.cpp\n+++ b/src/Interpreters/Cache/QueryCache.cpp\n@@ -619,9 +619,18 @@ QueryCache::Writer QueryCache::createWriter(const Key & key, std::chrono::millis\n     return Writer(cache, key, max_entry_size_in_bytes, max_entry_size_in_rows, min_query_runtime, squash_partial_results, max_block_size);\n }\n \n-void QueryCache::clear()\n+void QueryCache::clear(const std::optional<String> & tag)\n {\n-    cache.clear();\n+    if (tag)\n+    {\n+        auto predicate = [tag](const Key & key, const Cache::MappedPtr &) { return key.tag == tag.value(); };\n+        cache.remove(predicate);\n+    }\n+    else\n+    {\n+        cache.clear();\n+    }\n+\n     std::lock_guard lock(mutex);\n     times_executed.clear();\n }\ndiff --git a/src/Interpreters/Cache/QueryCache.h b/src/Interpreters/Cache/QueryCache.h\nindex c7ebaf4d26a5..64407633a8d1 100644\n--- a/src/Interpreters/Cache/QueryCache.h\n+++ b/src/Interpreters/Cache/QueryCache.h\n@@ -211,7 +211,7 @@ class QueryCache\n     Reader createReader(const Key & key);\n     Writer createWriter(const Key & key, std::chrono::milliseconds min_query_runtime, bool squash_partial_results, size_t max_block_size, size_t max_query_cache_size_in_bytes_quota, size_t max_query_cache_entries_quota);\n \n-    void clear();\n+    void clear(const std::optional<String> & tag);\n \n     size_t sizeInBytes() const;\n     size_t count() const;\ndiff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 3cc09370e86b..cfcaf437510f 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -3228,12 +3228,12 @@ QueryCachePtr Context::getQueryCache() const\n     return shared->query_cache;\n }\n \n-void Context::clearQueryCache() const\n+void Context::clearQueryCache(const std::optional<String> & tag) const\n {\n     std::lock_guard lock(shared->mutex);\n \n     if (shared->query_cache)\n-        shared->query_cache->clear();\n+        shared->query_cache->clear(tag);\n }\n \n void Context::clearCaches() const\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex 3da4f124553f..e0c69471e60b 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -1068,7 +1068,7 @@ class Context: public ContextData, public std::enable_shared_from_this<Context>\n     void setQueryCache(size_t max_size_in_bytes, size_t max_entries, size_t max_entry_size_in_bytes, size_t max_entry_size_in_rows);\n     void updateQueryCacheConfiguration(const Poco::Util::AbstractConfiguration & config);\n     std::shared_ptr<QueryCache> getQueryCache() const;\n-    void clearQueryCache() const;\n+    void clearQueryCache(const std::optional<String> & tag) const;\n \n     /** Clear the caches of the uncompressed blocks and marks.\n       * This is usually done when renaming tables, changing the type of columns, deleting a table.\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 21c8b44b3744..d4e2f22036c3 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -369,9 +369,12 @@ BlockIO InterpreterSystemQuery::execute()\n             system_context->clearMMappedFileCache();\n             break;\n         case Type::DROP_QUERY_CACHE:\n+        {\n             getContext()->checkAccess(AccessType::SYSTEM_DROP_QUERY_CACHE);\n-            getContext()->clearQueryCache();\n+            getContext()->clearQueryCache(query.query_cache_tag);\n             break;\n+        }\n+\n         case Type::DROP_COMPILED_EXPRESSION_CACHE:\n #if USE_EMBEDDED_COMPILER\n             getContext()->checkAccess(AccessType::SYSTEM_DROP_COMPILED_EXPRESSION_CACHE);\ndiff --git a/src/Parsers/ASTSystemQuery.h b/src/Parsers/ASTSystemQuery.h\nindex 59de90b1d8e2..d9f5b4251825 100644\n--- a/src/Parsers/ASTSystemQuery.h\n+++ b/src/Parsers/ASTSystemQuery.h\n@@ -131,6 +131,8 @@ class ASTSystemQuery : public IAST, public ASTQueryWithOnCluster\n     String disk;\n     UInt64 seconds{};\n \n+    std::optional<String> query_cache_tag;\n+\n     String filesystem_cache_name;\n     std::string key_to_drop;\n     std::optional<size_t> offset_to_drop;\ndiff --git a/src/Parsers/CommonParsers.h b/src/Parsers/CommonParsers.h\nindex cc2ee79cd363..ab0e70eb0e52 100644\n--- a/src/Parsers/CommonParsers.h\n+++ b/src/Parsers/CommonParsers.h\n@@ -470,6 +470,7 @@ namespace DB\n     MR_MACROS(TABLE_OVERRIDE, \"TABLE OVERRIDE\") \\\n     MR_MACROS(TABLE, \"TABLE\") \\\n     MR_MACROS(TABLES, \"TABLES\") \\\n+    MR_MACROS(TAG, \"TAG\") \\\n     MR_MACROS(TAGS, \"TAGS\") \\\n     MR_MACROS(TAGS_INNER_UUID, \"TAGS INNER UUID\") \\\n     MR_MACROS(TEMPORARY_TABLE, \"TEMPORARY TABLE\") \\\ndiff --git a/src/Parsers/ParserSystemQuery.cpp b/src/Parsers/ParserSystemQuery.cpp\nindex efabbbfa4794..af84dd10bfa7 100644\n--- a/src/Parsers/ParserSystemQuery.cpp\n+++ b/src/Parsers/ParserSystemQuery.cpp\n@@ -471,6 +471,16 @@ bool ParserSystemQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Expected &\n             res->seconds = seconds->as<ASTLiteral>()->value.safeGet<UInt64>();\n             break;\n         }\n+        case Type::DROP_QUERY_CACHE:\n+        {\n+            ParserLiteral tag_parser;\n+            ASTPtr ast;\n+            if (ParserKeyword{Keyword::TAG}.ignore(pos, expected) && tag_parser.parse(pos, ast, expected))\n+                res->query_cache_tag = std::make_optional<String>(ast->as<ASTLiteral>()->value.safeGet<String>());\n+            if (!parseQueryWithOnCluster(res, pos, expected))\n+                return false;\n+            break;\n+        }\n         case Type::DROP_FILESYSTEM_CACHE:\n         {\n             ParserLiteral path_parser;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02494_query_cache_drop_cache.reference b/tests/queries/0_stateless/02494_query_cache_drop_cache.reference\nindex 2f1465d1598d..6481b5e07709 100644\n--- a/tests/queries/0_stateless/02494_query_cache_drop_cache.reference\n+++ b/tests/queries/0_stateless/02494_query_cache_drop_cache.reference\n@@ -1,3 +1,17 @@\n+Cache query result in query cache\n 1\n 1\n+DROP entries with a certain tag, no entry will match\n+1\n+After a full DROP, the cache is empty now\n+0\n+Cache query result with different or no tag in query cache\n+1\n+1\n+1\n+2\n+4\n+DROP entries with certain tags\n+2\n+1\n 0\ndiff --git a/tests/queries/0_stateless/02494_query_cache_drop_cache.sql b/tests/queries/0_stateless/02494_query_cache_drop_cache.sql\nindex bc2e7f442fc7..3d064169a4e5 100644\n--- a/tests/queries/0_stateless/02494_query_cache_drop_cache.sql\n+++ b/tests/queries/0_stateless/02494_query_cache_drop_cache.sql\n@@ -4,10 +4,31 @@\n -- (it's silly to use what will be tested below but we have to assume other tests cluttered the query cache)\n SYSTEM DROP QUERY CACHE;\n \n--- Cache query result in query cache\n+SELECT 'Cache query result in query cache';\n SELECT 1 SETTINGS use_query_cache = true;\n SELECT count(*) FROM system.query_cache;\n \n--- No query results are cached after DROP\n+SELECT 'DROP entries with a certain tag, no entry will match';\n+SYSTEM DROP QUERY CACHE TAG 'tag';\n+SELECT count(*) FROM system.query_cache;\n+\n+SELECT 'After a full DROP, the cache is empty now';\n SYSTEM DROP QUERY CACHE;\n SELECT count(*) FROM system.query_cache;\n+\n+-- More tests for DROP with tags:\n+\n+SELECT 'Cache query result with different or no tag in query cache';\n+SELECT 1 SETTINGS use_query_cache = true;\n+SELECT 1 SETTINGS use_query_cache = true, query_cache_tag = 'abc';\n+SELECT 1 SETTINGS use_query_cache = true, query_cache_tag = 'def';\n+SELECT 2 SETTINGS use_query_cache = true;\n+SELECT count(*) FROM system.query_cache;\n+\n+SELECT 'DROP entries with certain tags';\n+SYSTEM DROP QUERY CACHE TAG '';\n+SELECT count(*) FROM system.query_cache;\n+SYSTEM DROP QUERY CACHE TAG 'def';\n+SELECT count(*) FROM system.query_cache;\n+SYSTEM DROP QUERY CACHE TAG 'abc';\n+SELECT count(*) FROM system.query_cache;\n",
  "problem_statement": "Drop query cache entries with certain tag.\n`SYSTEM DROP QUERY CACHE` drops all query cache entries.\r\n\r\nAs per #65872 / #68235, a tagging mechanism for cache entries was introduced. We could extend the drop cache statement to drop only results with certain cache, e.g. `SYSTEM DROP QUERY CACHE TAG 'some_tag'`. Actually, selective cache dropping is occasionally requested, so this is not a useless exercise.\n",
  "hints_text": "I will try to deal with this.\r\n\nNice, please ping me once you have a PR or I can be of help.\n@rschu1ze, I don't know really how I should write tests for it. I got some stuff working like the query you've just described, and the mechanism for deleting the cache. I will try to make a PR, around the Friday evening or at Sunday/Saturday. \nThat's great. Re testing, you may want to get some inspiration from existing tests `tests/queries/0_stateless/02494_query_cache_*.sql` and see [here](https://clickhouse.com/docs/en/development/tests) about testing in general.",
  "created_at": "2024-08-16T20:56:52Z"
}