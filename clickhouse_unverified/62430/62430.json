{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62430,
  "instance_id": "ClickHouse__ClickHouse-62430",
  "issue_numbers": [
    "56345"
  ],
  "base_commit": "0fd52c36c6c6907a4bace5b7c54431b4e8f1ebd0",
  "patch": "diff --git a/docs/en/interfaces/formats.md b/docs/en/interfaces/formats.md\nindex d25e18bd397c..a137eb2bdf22 100644\n--- a/docs/en/interfaces/formats.md\n+++ b/docs/en/interfaces/formats.md\n@@ -75,7 +75,7 @@ The supported formats are:\n | [ArrowStream](#data-format-arrow-stream)                                                  | \u2714    | \u2714     |\n | [ORC](#data-format-orc)                                                                   | \u2714    | \u2714     |\n | [One](#data-format-one)                                                                   | \u2714    | \u2717     |\n-| [Npy](#data-format-npy)                                                                   | \u2714    | \u2717     |\n+| [Npy](#data-format-npy)                                                                   | \u2714    | \u2714     |\n | [RowBinary](#rowbinary)                                                                   | \u2714    | \u2714     |\n | [RowBinaryWithNames](#rowbinarywithnamesandtypes)                                         | \u2714    | \u2714     |\n | [RowBinaryWithNamesAndTypes](#rowbinarywithnamesandtypes)                                 | \u2714    | \u2714     |\n@@ -2466,23 +2466,22 @@ Result:\n \n ## Npy {#data-format-npy}\n \n-This function is designed to load a NumPy array from a .npy file into ClickHouse. The NumPy file format is a binary format used for efficiently storing arrays of numerical data. During import, ClickHouse treats top level dimension as an array of rows with single column. Supported Npy data types and their corresponding type in ClickHouse:\n-| Npy type | ClickHouse type |\n-|:--------:|:---------------:|\n-| b1       |    UInt8        |\n-| i1       |    Int8         |\n-| i2       |    Int16        |\n-| i4       |    Int32        |\n-| i8       |    Int64        |\n-| u1       |    UInt8        |\n-| u2       |    UInt16       |\n-| u4       |    UInt32       |\n-| u8       |    UInt64       |\n-| f2       |    Float32      |\n-| f4       |    Float32      |\n-| f8       |    Float64      |\n-| S        |    String       |\n-| U        |    String       |\n+This function is designed to load a NumPy array from a .npy file into ClickHouse. The NumPy file format is a binary format used for efficiently storing arrays of numerical data. During import, ClickHouse treats top level dimension as an array of rows with single column. Supported Npy data types and their corresponding type in ClickHouse: \n+\n+| Npy data type (`INSERT`) | ClickHouse data type                                            | Npy data type (`SELECT`) |\n+|--------------------------|-----------------------------------------------------------------|--------------------------|\n+| `i1`                     | [Int8](/docs/en/sql-reference/data-types/int-uint.md)           | `i1`                     |\n+| `i2`                     | [Int16](/docs/en/sql-reference/data-types/int-uint.md)          | `i2`                     |\n+| `i4`                     | [Int32](/docs/en/sql-reference/data-types/int-uint.md)          | `i4`                     |\n+| `i8`                     | [Int64](/docs/en/sql-reference/data-types/int-uint.md)          | `i8`                     |\n+| `u1`, `b1`               | [UInt8](/docs/en/sql-reference/data-types/int-uint.md)          | `u1`                     |\n+| `u2`                     | [UInt16](/docs/en/sql-reference/data-types/int-uint.md)         | `u2`                     |\n+| `u4`                     | [UInt32](/docs/en/sql-reference/data-types/int-uint.md)         | `u4`                     |\n+| `u8`                     | [UInt64](/docs/en/sql-reference/data-types/int-uint.md)         | `u8`                     |\n+| `f2`, `f4`               | [Float32](/docs/en/sql-reference/data-types/float.md)           | `f4`                     |\n+| `f8`                     | [Float64](/docs/en/sql-reference/data-types/float.md)           | `f8`                     |\n+| `S`, `U`                 | [String](/docs/en/sql-reference/data-types/string.md)           | `S`                      |\n+|                          | [FixedString](/docs/en/sql-reference/data-types/fixedstring.md) | `S`                      |\n \n **Example of saving an array in .npy format using Python**\n \n@@ -2509,6 +2508,14 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+**Selecting Data**\n+\n+You can select data from a ClickHouse table and save them into some file in the Npy format by the following command:\n+\n+```bash\n+$ clickhouse-client --query=\"SELECT {column} FROM {some_table} FORMAT Npy\" > {filename.npy}\n+```\n+\n ## LineAsString {#lineasstring}\n \n In this format, every line of input data is interpreted as a single string value. This format can only be parsed for table with a single field of type [String](/docs/en/sql-reference/data-types/string.md). The remaining columns must be set to [DEFAULT](/docs/en/sql-reference/statements/create/table.md/#default) or [MATERIALIZED](/docs/en/sql-reference/statements/create/table.md/#materialized), or omitted.\ndiff --git a/src/Formats/NumpyDataTypes.h b/src/Formats/NumpyDataTypes.h\nindex cb40c67cd19e..062f743c0ea5 100644\n--- a/src/Formats/NumpyDataTypes.h\n+++ b/src/Formats/NumpyDataTypes.h\n@@ -1,10 +1,12 @@\n #pragma once\n #include <cstddef>\n #include <Storages/NamedCollectionsHelpers.h>\n+#include <IO/WriteBufferFromString.h>\n \n namespace ErrorCodes\n {\n     extern const int BAD_ARGUMENTS;\n+    extern const int NOT_IMPLEMENTED;\n }\n \n enum class NumpyDataTypeIndex : uint8_t\n@@ -29,9 +31,9 @@ class NumpyDataType\n public:\n     enum Endianness\n     {\n-        LITTLE,\n-        BIG,\n-        NONE,\n+        LITTLE = '<',\n+        BIG = '>',\n+        NONE = '|',\n     };\n     NumpyDataTypeIndex type_index;\n \n@@ -41,15 +43,18 @@ class NumpyDataType\n     Endianness getEndianness() const { return endianness; }\n \n     virtual NumpyDataTypeIndex getTypeIndex() const = 0;\n+    virtual size_t getSize() const { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, \"Function getSize() is not implemented\"); }\n+    virtual void setSize(size_t) { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, \"Function setSize() is not implemented\"); }\n+    virtual String str() const { throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, \"Function str() is not implemented\"); }\n \n-private:\n+protected:\n     Endianness endianness;\n };\n \n class NumpyDataTypeInt : public NumpyDataType\n {\n public:\n-    NumpyDataTypeInt(Endianness endianness, size_t size_, bool is_signed_) : NumpyDataType(endianness), size(size_), is_signed(is_signed_)\n+    NumpyDataTypeInt(Endianness endianness_, size_t size_, bool is_signed_) : NumpyDataType(endianness_), size(size_), is_signed(is_signed_)\n     {\n         switch (size)\n         {\n@@ -67,6 +72,14 @@ class NumpyDataTypeInt : public NumpyDataType\n         return type_index;\n     }\n     bool isSigned() const { return is_signed; }\n+    String str() const override\n+    {\n+        DB::WriteBufferFromOwnString buf;\n+        writeChar(static_cast<char>(endianness), buf);\n+        writeChar(is_signed ? 'i' : 'u', buf);\n+        writeIntText(size, buf);\n+        return buf.str();\n+    }\n \n private:\n     size_t size;\n@@ -76,7 +89,7 @@ class NumpyDataTypeInt : public NumpyDataType\n class NumpyDataTypeFloat : public NumpyDataType\n {\n public:\n-    NumpyDataTypeFloat(Endianness endianness, size_t size_) : NumpyDataType(endianness), size(size_)\n+    NumpyDataTypeFloat(Endianness endianness_, size_t size_) : NumpyDataType(endianness_), size(size_)\n     {\n         switch (size)\n         {\n@@ -92,6 +105,14 @@ class NumpyDataTypeFloat : public NumpyDataType\n     {\n         return type_index;\n     }\n+    String str() const override\n+    {\n+        DB::WriteBufferFromOwnString buf;\n+        writeChar(static_cast<char>(endianness), buf);\n+        writeChar('f', buf);\n+        writeIntText(size, buf);\n+        return buf.str();\n+    }\n private:\n     size_t size;\n };\n@@ -99,13 +120,22 @@ class NumpyDataTypeFloat : public NumpyDataType\n class NumpyDataTypeString : public NumpyDataType\n {\n public:\n-    NumpyDataTypeString(Endianness endianness, size_t size_) : NumpyDataType(endianness), size(size_)\n+    NumpyDataTypeString(Endianness endianness_, size_t size_) : NumpyDataType(endianness_), size(size_)\n     {\n         type_index = NumpyDataTypeIndex::String;\n     }\n \n     NumpyDataTypeIndex getTypeIndex() const override { return type_index; }\n-    size_t getSize() const { return size; }\n+    size_t getSize() const override { return size; }\n+    void setSize(size_t size_) override { size = size_; }\n+    String str() const override\n+    {\n+        DB::WriteBufferFromOwnString buf;\n+        writeChar(static_cast<char>(endianness), buf);\n+        writeChar('S', buf);\n+        writeIntText(size, buf);\n+        return buf.str();\n+    }\n private:\n     size_t size;\n };\n@@ -113,13 +143,13 @@ class NumpyDataTypeString : public NumpyDataType\n class NumpyDataTypeUnicode : public NumpyDataType\n {\n public:\n-    NumpyDataTypeUnicode(Endianness endianness, size_t size_) : NumpyDataType(endianness), size(size_)\n+    NumpyDataTypeUnicode(Endianness endianness_, size_t size_) : NumpyDataType(endianness_), size(size_)\n     {\n         type_index = NumpyDataTypeIndex::Unicode;\n     }\n \n     NumpyDataTypeIndex getTypeIndex() const override { return type_index; }\n-    size_t getSize() const { return size * 4; }\n+    size_t getSize() const override { return size * 4; }\n private:\n     size_t size;\n };\ndiff --git a/src/Formats/registerFormats.cpp b/src/Formats/registerFormats.cpp\nindex 1f851da850a8..57ca1bb49c83 100644\n--- a/src/Formats/registerFormats.cpp\n+++ b/src/Formats/registerFormats.cpp\n@@ -76,6 +76,8 @@ void registerInputFormatCustomSeparated(FormatFactory & factory);\n void registerOutputFormatCustomSeparated(FormatFactory & factory);\n void registerInputFormatCapnProto(FormatFactory & factory);\n void registerOutputFormatCapnProto(FormatFactory & factory);\n+void registerInputFormatNpy(FormatFactory & factory);\n+void registerOutputFormatNpy(FormatFactory & factory);\n void registerInputFormatForm(FormatFactory & factory);\n \n /// Output only (presentational) formats.\n@@ -104,7 +106,6 @@ void registerInputFormatMySQLDump(FormatFactory & factory);\n void registerInputFormatParquetMetadata(FormatFactory & factory);\n void registerInputFormatDWARF(FormatFactory & factory);\n void registerInputFormatOne(FormatFactory & factory);\n-void registerInputFormatNpy(FormatFactory & factory);\n \n #if USE_HIVE\n void registerInputFormatHiveText(FormatFactory & factory);\n@@ -224,6 +225,8 @@ void registerFormats()\n     registerOutputFormatAvro(factory);\n     registerInputFormatArrow(factory);\n     registerOutputFormatArrow(factory);\n+    registerInputFormatNpy(factory);\n+    registerOutputFormatNpy(factory);\n \n     registerOutputFormatPretty(factory);\n     registerOutputFormatPrettyCompact(factory);\n@@ -254,7 +257,6 @@ void registerFormats()\n     registerInputFormatParquetMetadata(factory);\n     registerInputFormatDWARF(factory);\n     registerInputFormatOne(factory);\n-    registerInputFormatNpy(factory);\n \n     registerNonTrivialPrefixAndSuffixCheckerJSONEachRow(factory);\n     registerNonTrivialPrefixAndSuffixCheckerJSONAsString(factory);\ndiff --git a/src/Processors/Formats/Impl/NpyOutputFormat.cpp b/src/Processors/Formats/Impl/NpyOutputFormat.cpp\nnew file mode 100644\nindex 000000000000..e02787b4f704\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/NpyOutputFormat.cpp\n@@ -0,0 +1,269 @@\n+#include <Processors/Formats/Impl/NpyOutputFormat.h>\n+\n+#include <Core/TypeId.h>\n+#include <DataTypes/DataTypeFixedString.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnArray.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <Formats/FormatFactory.h>\n+\n+#include <Common/assert_cast.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int TOO_MANY_COLUMNS;\n+    extern const int BAD_ARGUMENTS;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+namespace\n+{\n+\n+template <typename ColumnType, typename ValueType>\n+void writeNumpyNumbers(const ColumnPtr & column, WriteBuffer & buf)\n+{\n+    const auto * number_column = assert_cast<const ColumnType *>(column.get());\n+    for (size_t i = 0; i < number_column->size(); ++i)\n+        writeBinaryLittleEndian(ValueType(number_column->getElement(i)), buf);\n+}\n+\n+template <typename ColumnType>\n+void writeNumpyStrings(const ColumnPtr & column, size_t length, WriteBuffer & buf)\n+{\n+    const auto * string_column = assert_cast<const ColumnType *>(column.get());\n+    for (size_t i = 0; i < string_column->size(); ++i)\n+    {\n+        auto data = string_column->getDataAt(i);\n+        buf.write(data.data, data.size);\n+        writeChar(0, length - data.size, buf);\n+    }\n+}\n+\n+}\n+\n+String NpyOutputFormat::shapeStr() const\n+{\n+    WriteBufferFromOwnString shape;\n+    writeIntText(num_rows, shape);\n+    writeChar(',', shape);\n+    for (UInt64 dim : numpy_shape)\n+    {\n+        writeIntText(dim, shape);\n+        writeChar(',', shape);\n+    }\n+\n+    return shape.str();\n+}\n+\n+NpyOutputFormat::NpyOutputFormat(WriteBuffer & out_, const Block & header_) : IOutputFormat(header_, out_)\n+{\n+    const auto & header = getPort(PortKind::Main).getHeader();\n+    auto data_types = header.getDataTypes();\n+    if (data_types.size() > 1)\n+        throw Exception(ErrorCodes::TOO_MANY_COLUMNS, \"Expected single column for Npy output format, got {}\", data_types.size());\n+    data_type = data_types[0];\n+\n+    if (!getNumpyDataType(data_type))\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Type {} is not supported for Npy output format\", nested_data_type->getName());\n+}\n+\n+bool NpyOutputFormat::getNumpyDataType(const DataTypePtr & type)\n+{\n+    switch (type->getTypeId())\n+    {\n+        case TypeIndex::Int8:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(Int8), true);\n+            break;\n+        case TypeIndex::Int16:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(Int16), true);\n+            break;\n+        case TypeIndex::Int32:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(Int32), true);\n+            break;\n+        case TypeIndex::Int64:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(Int64), true);\n+            break;\n+        case TypeIndex::UInt8:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(UInt8), false);\n+            break;\n+        case TypeIndex::UInt16:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(UInt16), false);\n+            break;\n+        case TypeIndex::UInt32:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(UInt32), false);\n+            break;\n+        case TypeIndex::UInt64:\n+            numpy_data_type = std::make_shared<NumpyDataTypeInt>(NumpyDataType::Endianness::LITTLE, sizeof(UInt64), false);\n+            break;\n+        case TypeIndex::Float32:\n+            numpy_data_type = std::make_shared<NumpyDataTypeFloat>(NumpyDataType::Endianness::LITTLE, sizeof(Float32));\n+            break;\n+        case TypeIndex::Float64:\n+            numpy_data_type = std::make_shared<NumpyDataTypeFloat>(NumpyDataType::Endianness::LITTLE, sizeof(Float64));\n+            break;\n+        case TypeIndex::FixedString:\n+            numpy_data_type = std::make_shared<NumpyDataTypeString>(\n+                NumpyDataType::Endianness::NONE, assert_cast<const DataTypeFixedString *>(type.get())->getN());\n+            break;\n+        case TypeIndex::String:\n+            numpy_data_type = std::make_shared<NumpyDataTypeString>(NumpyDataType::Endianness::NONE, 0);\n+            break;\n+        case TypeIndex::Array:\n+            return getNumpyDataType(assert_cast<const DataTypeArray *>(type.get())->getNestedType());\n+        default:\n+            nested_data_type = type;\n+            return false;\n+    }\n+\n+    nested_data_type = type;\n+    return true;\n+}\n+\n+void NpyOutputFormat::consume(Chunk chunk)\n+{\n+    if (!invalid_shape)\n+    {\n+        num_rows += chunk.getNumRows();\n+        const auto & column = chunk.getColumns()[0];\n+\n+        if (!is_initialized)\n+        {\n+            initShape(column);\n+            is_initialized = true;\n+        }\n+\n+        ColumnPtr nested_column = column;\n+        checkShape(nested_column);\n+        updateSizeIfTypeString(nested_column);\n+        columns.push_back(nested_column);\n+    }\n+}\n+\n+void NpyOutputFormat::initShape(const ColumnPtr & column)\n+{\n+    ColumnPtr nested_column = column;\n+    while (const auto * array_column = typeid_cast<const ColumnArray *>(nested_column.get()))\n+    {\n+        auto dim = array_column->getOffsets()[0];\n+        invalid_shape = dim == 0;\n+        numpy_shape.push_back(dim);\n+        nested_column = array_column->getDataPtr();\n+    }\n+\n+    if (invalid_shape)\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Shape ({}) is invalid, as dimension size cannot be 0\", shapeStr());\n+}\n+\n+void NpyOutputFormat::checkShape(ColumnPtr & column)\n+{\n+    int dim = 0;\n+    while (const auto * array_column = typeid_cast<const ColumnArray *>(column.get()))\n+    {\n+        const auto & array_offset = array_column->getOffsets();\n+\n+        for (size_t i = 0; i < array_offset.size(); ++i)\n+            if (array_offset[i] - array_offset[i - 1] != numpy_shape[dim])\n+            {\n+                invalid_shape = true;\n+                throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"ClickHouse doesn't support object types, cannot format ragged nested sequences (which is a list of arrays with different shapes)\");\n+            }\n+\n+        column = array_column->getDataPtr();\n+        dim += 1;\n+    }\n+}\n+\n+void NpyOutputFormat::updateSizeIfTypeString(const ColumnPtr & column)\n+{\n+    if (nested_data_type->getTypeId() == TypeIndex::String)\n+    {\n+        const auto & string_offsets = assert_cast<const ColumnString *>(column.get())->getOffsets();\n+        for (size_t i = 0; i < string_offsets.size(); ++i)\n+        {\n+            size_t string_length = static_cast<size_t>(string_offsets[i] - 1 - string_offsets[i - 1]);\n+            if (numpy_data_type->getSize() < string_length)\n+                numpy_data_type->setSize(string_length);\n+        }\n+    }\n+}\n+\n+void NpyOutputFormat::finalizeImpl()\n+{\n+    if (!invalid_shape)\n+    {\n+        writeHeader();\n+        writeColumns();\n+    }\n+}\n+\n+void NpyOutputFormat::writeHeader()\n+{\n+    String dict = \"{'descr':'\" + numpy_data_type->str() + \"','fortran_order':False,'shape':(\" + shapeStr() + \"),}\";\n+    String padding = \"\\n\";\n+\n+    /// completes the length of the header, which is divisible by 64.\n+    size_t dict_length = dict.length() + 1;\n+    size_t header_length = STATIC_HEADER_LENGTH + sizeof(UInt32) + dict_length;\n+    if (header_length % 64)\n+    {\n+        header_length = ((header_length / 64) + 1) * 64;\n+        dict_length = header_length - STATIC_HEADER_LENGTH - sizeof(UInt32);\n+        padding = std::string(dict_length - dict.length(), '\\x20');\n+        padding.back() = '\\n';\n+    }\n+\n+    out.write(STATIC_HEADER, STATIC_HEADER_LENGTH);\n+    writeBinaryLittleEndian(static_cast<UInt32>(dict_length), out);\n+    out.write(dict.data(), dict.length());\n+    out.write(padding.data(), padding.length());\n+}\n+\n+void NpyOutputFormat::writeColumns()\n+{\n+    for (const auto & column : columns)\n+    {\n+        switch (nested_data_type->getTypeId())\n+        {\n+            case TypeIndex::Int8: writeNumpyNumbers<ColumnInt8, Int8>(column, out); break;\n+            case TypeIndex::Int16: writeNumpyNumbers<ColumnInt16, Int16>(column, out); break;\n+            case TypeIndex::Int32: writeNumpyNumbers<ColumnInt32, Int32>(column, out); break;\n+            case TypeIndex::Int64: writeNumpyNumbers<ColumnInt64, Int64>(column, out); break;\n+            case TypeIndex::UInt8: writeNumpyNumbers<ColumnUInt8, UInt8>(column, out); break;\n+            case TypeIndex::UInt16: writeNumpyNumbers<ColumnUInt16, UInt16>(column, out); break;\n+            case TypeIndex::UInt32: writeNumpyNumbers<ColumnUInt32, UInt32>(column, out); break;\n+            case TypeIndex::UInt64: writeNumpyNumbers<ColumnUInt64, UInt64>(column, out); break;\n+            case TypeIndex::Float32: writeNumpyNumbers<ColumnFloat32, Float32>(column, out); break;\n+            case TypeIndex::Float64: writeNumpyNumbers<ColumnFloat64, Float64>(column, out); break;\n+            case TypeIndex::FixedString:\n+                writeNumpyStrings<ColumnFixedString>(column, numpy_data_type->getSize(), out);\n+                break;\n+            case TypeIndex::String:\n+                writeNumpyStrings<ColumnString>(column, numpy_data_type->getSize(), out);\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+}\n+\n+void registerOutputFormatNpy(FormatFactory & factory)\n+{\n+    factory.registerOutputFormat(\"Npy\",[](\n+        WriteBuffer & buf,\n+        const Block & sample,\n+        const FormatSettings &)\n+    {\n+        return std::make_shared<NpyOutputFormat>(buf, sample);\n+    });\n+    factory.markFormatHasNoAppendSupport(\"Npy\");\n+}\n+\n+}\ndiff --git a/src/Processors/Formats/Impl/NpyOutputFormat.h b/src/Processors/Formats/Impl/NpyOutputFormat.h\nnew file mode 100644\nindex 000000000000..5dd6552ac0c3\n--- /dev/null\n+++ b/src/Processors/Formats/Impl/NpyOutputFormat.h\n@@ -0,0 +1,60 @@\n+#pragma once\n+\n+#include <Core/Block.h>\n+#include <IO/WriteBuffer.h>\n+#include <IO/WriteBufferFromVector.h>\n+#include <Processors/Formats/IRowOutputFormat.h>\n+#include <Formats/FormatSettings.h>\n+#include <Formats/NumpyDataTypes.h>\n+#include <Columns/IColumn.h>\n+#include <Common/PODArray_fwd.h>\n+\n+#include <vector>\n+#include <string>\n+\n+\n+namespace DB\n+{\n+\n+/** Stream for output data in Npy format.\n+  * https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html\n+  */\n+class NpyOutputFormat : public IOutputFormat\n+{\n+public:\n+    NpyOutputFormat(WriteBuffer & out_, const Block & header_);\n+\n+    String getName() const override { return \"NpyOutputFormat\"; }\n+\n+    String getContentType() const override { return \"application/octet-stream\"; }\n+\n+private:\n+    String shapeStr() const;\n+\n+    bool getNumpyDataType(const DataTypePtr & type);\n+\n+    void consume(Chunk) override;\n+    void initShape(const ColumnPtr & column);\n+    void checkShape(ColumnPtr & column);\n+    void updateSizeIfTypeString(const ColumnPtr & column);\n+\n+    void finalizeImpl() override;\n+    void writeHeader();\n+    void writeColumns();\n+\n+    bool is_initialized = false;\n+    bool invalid_shape = false;\n+\n+    DataTypePtr data_type;\n+    DataTypePtr nested_data_type;\n+    std::shared_ptr<NumpyDataType> numpy_data_type;\n+    UInt64 num_rows = 0;\n+    std::vector<UInt64> numpy_shape;\n+    Columns columns;\n+\n+    /// static header (version 3.0)\n+    constexpr static auto STATIC_HEADER = \"\\x93NUMPY\\x03\\x00\";\n+    constexpr static size_t STATIC_HEADER_LENGTH = 8;\n+};\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02187_async_inserts_all_formats.python b/tests/queries/0_stateless/02187_async_inserts_all_formats.python\nindex fa555c78f8b1..943e32d4cf20 100644\n--- a/tests/queries/0_stateless/02187_async_inserts_all_formats.python\n+++ b/tests/queries/0_stateless/02187_async_inserts_all_formats.python\n@@ -38,7 +38,7 @@ def run_test(data_format, gen_data_template, settings):\n formats = (\n     client.query(\n         \"SELECT name FROM system.formats WHERE is_input AND is_output \\\n-    AND name NOT IN ('CapnProto', 'RawBLOB', 'Template', 'ProtobufSingle', 'LineAsString', 'Protobuf', 'ProtobufList') ORDER BY name\"\n+    AND name NOT IN ('CapnProto', 'RawBLOB', 'Template', 'ProtobufSingle', 'LineAsString', 'Protobuf', 'ProtobufList', 'Npy') ORDER BY name\"\n     )\n     .strip()\n     .split(\"\\n\")\ndiff --git a/tests/queries/0_stateless/02895_npy_output_format.reference b/tests/queries/0_stateless/02895_npy_output_format.reference\nnew file mode 100644\nindex 000000000000..ad3366c2a515\n--- /dev/null\n+++ b/tests/queries/0_stateless/02895_npy_output_format.reference\n@@ -0,0 +1,48 @@\n+-- test data types --\n+-1\n+1\n+-1\n+1\n+-1\n+1\n+-1\n+1\n+0\n+1\n+0\n+1\n+0\n+1\n+0\n+1\n+0.2\n+0.1\n+0.02\n+0.01\n+npy\n+npy\n+npynpy\n+npy\n+array\tInt8\t\t\t\t\t\n+array\tInt16\t\t\t\t\t\n+array\tInt32\t\t\t\t\t\n+array\tInt64\t\t\t\t\t\n+array\tUInt8\t\t\t\t\t\n+array\tUInt16\t\t\t\t\t\n+array\tUInt32\t\t\t\t\t\n+array\tUInt64\t\t\t\t\t\n+array\tFloat32\t\t\t\t\t\n+array\tFloat64\t\t\t\t\t\n+array\tString\t\t\t\t\t\n+array\tString\t\t\t\t\t\n+-- test nested data types --\n+[[[1],[2]],[[3],[4]]]\n+[[[1],[2]],[[3],[4]]]\n+[[0.1],[0.2]]\n+[[0.1],[0.2]]\n+['a','bb']\n+['ccc','dddd']\n+array\tArray(Array(Array(Int8)))\t\t\t\t\t\n+array\tArray(Array(Float64))\t\t\t\t\t\n+array\tArray(String)\t\t\t\t\t\n+-- test exceptions --\ndiff --git a/tests/queries/0_stateless/02895_npy_output_format.sh b/tests/queries/0_stateless/02895_npy_output_format.sh\nnew file mode 100755\nindex 000000000000..934c80830c5d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02895_npy_output_format.sh\n@@ -0,0 +1,118 @@\n+#!/usr/bin/env bash\n+# Tags: no-parallel\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+user_files_path=$($CLICKHOUSE_CLIENT_BINARY -q \"select _path,_file from file('nonexist.txt', 'CSV', 'val1 char')\" 2>&1 | grep Exception | awk '{gsub(\"/nonexist.txt\",\"\",$9); print $9}')\n+mkdir -p ${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/\n+rm -rf ${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME:?}/*\n+chmod 777 ${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/\n+\n+${CLICKHOUSE_CLIENT} -n -q --ignore-error \"\n+    DROP DATABASE IF EXISTS npy_output_02895;\n+    CREATE DATABASE IF NOT EXISTS npy_output_02895;\n+\n+    SELECT '-- test data types --';\n+    CREATE TABLE IF NOT EXISTS npy_output_02895.data_types\n+    (\n+        i1 Int8,\n+        i2 Int16,\n+        i4 Int32,\n+        i8 Int64,\n+        u1 UInt8,\n+        u2 UInt16,\n+        u4 UInt32,\n+        u8 UInt64,\n+        f4 Float32,\n+        f8 Float64,\n+        fs FixedString(10),\n+        s String\n+    ) Engine = MergeTree ORDER BY i1;\n+\n+    INSERT INTO npy_output_02895.data_types VALUES (1, 1, 1, 1, 1, 1, 1, 1, 0.1, 0.01, 'npy', 'npy'), (-1, -1, -1, -1, 0, 0, 0, 0, 0.2, 0.02, 'npy', 'npynpy');\n+\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int8.npy') SELECT i1 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int16.npy') SELECT i2 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int32.npy') SELECT i4 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int64.npy') SELECT i8 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint8.npy') SELECT u1 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint16.npy') SELECT u2 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint32.npy') SELECT u4 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint64.npy') SELECT u8 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_float32.npy') SELECT f4 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_float64.npy') SELECT f8 FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_fixedstring.npy') SELECT fs FROM npy_output_02895.data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_string.npy') SELECT s FROM npy_output_02895.data_types;\n+\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int8.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int16.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int32.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int64.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint8.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint16.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint32.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint64.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_float32.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_float64.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_fixedstring.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_string.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int8.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int16.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int32.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_int64.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint8.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint16.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint32.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_uint64.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_float32.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_float64.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_fixedstring.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_dtype_string.npy');\n+\n+    SELECT '-- test nested data types --';\n+    CREATE TABLE IF NOT EXISTS npy_output_02895.nested_data_types\n+    (\n+        i4 Array(Array(Array(Int8))),\n+        f8 Array(Array(Float64)),\n+        s Array(String),\n+    ) Engine = MergeTree ORDER BY i4;\n+\n+    INSERT INTO npy_output_02895.nested_data_types VALUES ([[[1], [2]], [[3], [4]]], [[0.1], [0.2]], ['a', 'bb']), ([[[1], [2]], [[3], [4]]], [[0.1], [0.2]], ['ccc', 'dddd']);\n+\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_int32.npy') SELECT i4 FROM npy_output_02895.nested_data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_float64.npy') SELECT f8 FROM npy_output_02895.nested_data_types;\n+    INSERT INTO TABLE FUNCTION file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_string.npy') SELECT s FROM npy_output_02895.nested_data_types;\n+\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_int32.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_float64.npy');\n+    SELECT * FROM file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_string.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_int32.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_float64.npy');\n+    DESC file('${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME}/02895_nested_dtype_string.npy');\n+\n+    SELECT '-- test exceptions --';\n+    CREATE TABLE IF NOT EXISTS npy_output_02895.exceptions\n+    (\n+        unsupported_u UInt256,\n+        unsupported_date Date,\n+        unsupported_tuple Tuple(Int16, Int16),\n+        unsupported_nested_i Array(Int128),\n+        ragged_dimention Array(Int16),\n+        zero_dimension Array(Int16)\n+    ) Engine = MergeTree ORDER BY unsupported_u;\n+\n+    INSERT INTO npy_output_02895.exceptions VALUES (1, '2019-01-01', (1, 1), [1, 1], [1, 1], []), (0, '2019-01-01', (0, 0), [0, 0], [0], [0]);\n+\n+    SELECT * FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError TOO_MANY_COLUMNS }\n+    SELECT unsupported_u FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError BAD_ARGUMENTS }\n+    SELECT unsupported_date FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError BAD_ARGUMENTS }\n+    SELECT unsupported_tuple FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError BAD_ARGUMENTS }\n+    SELECT unsupported_nested_i FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError BAD_ARGUMENTS }\n+    SELECT ragged_dimention FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError ILLEGAL_COLUMN }\n+    SELECT zero_dimension FROM npy_output_02895.exceptions FORMAT Npy; -- { clientError ILLEGAL_COLUMN }\n+\n+    DROP DATABASE IF EXISTS npy_output_02895;\"\n+\n+rm -rf ${user_files_path}/${CLICKHOUSE_TEST_UNIQUE_NAME:?}\n",
  "problem_statement": "Npy as an output format\n**Use case**\r\n\r\nCurrently it's supported only for input.\n",
  "hints_text": "I can work on this.\n@HowePa, this will be amazing!\nUpdate:  \r\nThe [Npy out format](https://numpy.org/doc/stable/reference/generated/numpy.lib.format.html) maintains a header. For example,\r\n\r\n```\r\n\ufffdNUMPYv{'descr': '|S8', 'fortran_order': False, 'shape': (2, 3), }\r\n```\r\n\r\nOf these, `descr`(data_type) and `shape` are closely related to the data, which leads to two challenges:\r\n1. **Get max_length for type String**. `descr` ends with the length of the data type (like, `'i2'` means `int16_t` which take 2 bytes), so a Column of type `String` or `Array(String)` needs to get the maximun string length.  \r\n2. **Get total num_rows among multiple Blocks**. According to the description of the Npy input format, `shape[0]` is the number of rows.\nIt will require buffering the output in memory.",
  "created_at": "2024-04-09T06:33:13Z"
}