{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34504,
  "instance_id": "ClickHouse__ClickHouse-34504",
  "issue_numbers": [
    "34455"
  ],
  "base_commit": "738355b724871d9b172f462706a36bba84a79e7a",
  "patch": "diff --git a/src/Disks/IStoragePolicy.cpp b/src/Disks/IStoragePolicy.cpp\nnew file mode 100644\nindex 000000000000..2ba6df4be8f5\n--- /dev/null\n+++ b/src/Disks/IStoragePolicy.cpp\n@@ -0,0 +1,34 @@\n+#include <Disks/IStoragePolicy.h>\n+#include <Common/quoteString.h>\n+#include <Common/Exception.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNKNOWN_VOLUME;\n+    extern const int UNKNOWN_DISK;\n+}\n+\n+DiskPtr IStoragePolicy::getDiskByName(const String & disk_name) const\n+{\n+    auto disk = tryGetDiskByName(disk_name);\n+    if (!disk)\n+        throw Exception(ErrorCodes::UNKNOWN_DISK,\n+            \"No such disk {} in storage policy {}\", backQuote(disk_name), backQuote(getName()));\n+\n+    return disk;\n+}\n+\n+VolumePtr IStoragePolicy::getVolumeByName(const String & volume_name) const\n+{\n+    auto volume = tryGetVolumeByName(volume_name);\n+    if (!volume)\n+        throw Exception(ErrorCodes::UNKNOWN_VOLUME,\n+            \"No such volume {} in storage policy {}\", backQuote(volume_name), backQuote(getName()));\n+\n+    return volume;\n+}\n+\n+}\ndiff --git a/src/Disks/IStoragePolicy.h b/src/Disks/IStoragePolicy.h\nindex 8c6d56bdcfde..a5d1120f3777 100644\n--- a/src/Disks/IStoragePolicy.h\n+++ b/src/Disks/IStoragePolicy.h\n@@ -39,7 +39,8 @@ class IStoragePolicy\n     /// Used when it's not important, for example for\n     /// mutations files\n     virtual DiskPtr getAnyDisk() const = 0;\n-    virtual DiskPtr getDiskByName(const String & disk_name) const = 0;\n+    virtual DiskPtr tryGetDiskByName(const String & disk_name) const = 0;\n+    DiskPtr getDiskByName(const String & disk_name) const;\n     /// Get free space from most free disk\n     virtual UInt64 getMaxUnreservedFreeSpace() const = 0;\n     /// Reserves space on any volume with index > min_volume_index or returns nullptr\n@@ -53,7 +54,8 @@ class IStoragePolicy\n     virtual ReservationPtr makeEmptyReservationOnLargestDisk() const = 0;\n     /// Get volume by index.\n     virtual VolumePtr getVolume(size_t index) const = 0;\n-    virtual VolumePtr getVolumeByName(const String & volume_name) const = 0;\n+    virtual VolumePtr tryGetVolumeByName(const String & volume_name) const = 0;\n+    VolumePtr getVolumeByName(const String & volume_name) const;\n     /// Checks if storage policy can be replaced by another one.\n     virtual void checkCompatibleWith(const StoragePolicyPtr & new_storage_policy) const = 0;\n     /// Find volume index, which contains disk\ndiff --git a/src/Disks/StoragePolicy.cpp b/src/Disks/StoragePolicy.cpp\nindex 4c77528f1fc3..20192c3a29f4 100644\n--- a/src/Disks/StoragePolicy.cpp\n+++ b/src/Disks/StoragePolicy.cpp\n@@ -179,7 +179,7 @@ DiskPtr StoragePolicy::getAnyDisk() const\n }\n \n \n-DiskPtr StoragePolicy::getDiskByName(const String & disk_name) const\n+DiskPtr StoragePolicy::tryGetDiskByName(const String & disk_name) const\n {\n     for (auto && volume : volumes)\n         for (auto && disk : volume->getDisks())\n@@ -265,11 +265,11 @@ VolumePtr StoragePolicy::getVolume(size_t index) const\n }\n \n \n-VolumePtr StoragePolicy::getVolumeByName(const String & volume_name) const\n+VolumePtr StoragePolicy::tryGetVolumeByName(const String & volume_name) const\n {\n     auto it = volume_index_by_volume_name.find(volume_name);\n     if (it == volume_index_by_volume_name.end())\n-        throw Exception(\"No such volume \" + backQuote(volume_name) + \" in storage policy \" + backQuote(name), ErrorCodes::UNKNOWN_VOLUME);\n+        return nullptr;\n     return getVolume(it->second);\n }\n \ndiff --git a/src/Disks/StoragePolicy.h b/src/Disks/StoragePolicy.h\nindex b09baf09bdad..c3f72e01ec8d 100644\n--- a/src/Disks/StoragePolicy.h\n+++ b/src/Disks/StoragePolicy.h\n@@ -52,7 +52,7 @@ class StoragePolicy : public IStoragePolicy\n     /// mutations files\n     DiskPtr getAnyDisk() const override;\n \n-    DiskPtr getDiskByName(const String & disk_name) const override;\n+    DiskPtr tryGetDiskByName(const String & disk_name) const override;\n \n     /// Get free space from most free disk\n     UInt64 getMaxUnreservedFreeSpace() const override;\n@@ -84,7 +84,7 @@ class StoragePolicy : public IStoragePolicy\n     /// Get volume by index.\n     VolumePtr getVolume(size_t index) const override;\n \n-    VolumePtr getVolumeByName(const String & volume_name) const override;\n+    VolumePtr tryGetVolumeByName(const String & volume_name) const override;\n \n     /// Checks if storage policy can be replaced by another one.\n     void checkCompatibleWith(const StoragePolicyPtr & new_storage_policy) const override;\ndiff --git a/src/Parsers/ASTTTLElement.cpp b/src/Parsers/ASTTTLElement.cpp\nindex 2d22c1b43078..90278e27c0c0 100644\n--- a/src/Parsers/ASTTTLElement.cpp\n+++ b/src/Parsers/ASTTTLElement.cpp\n@@ -1,13 +1,17 @@\n-\n #include <Columns/Collator.h>\n #include <Common/quoteString.h>\n #include <Parsers/ASTTTLElement.h>\n #include <IO/Operators.h>\n-\n+#include <base/EnumReflection.h>\n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n ASTPtr ASTTTLElement::clone() const\n {\n     auto clone = std::make_shared<ASTTTLElement>(*this);\n@@ -29,13 +33,21 @@ ASTPtr ASTTTLElement::clone() const\n void ASTTTLElement::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n {\n     ttl()->formatImpl(settings, state, frame);\n-    if (mode == TTLMode::MOVE && destination_type == DataDestinationType::DISK)\n+    if (mode == TTLMode::MOVE)\n     {\n-        settings.ostr << \" TO DISK \" << quoteString(destination_name);\n-    }\n-    else if (mode == TTLMode::MOVE && destination_type == DataDestinationType::VOLUME)\n-    {\n-        settings.ostr << \" TO VOLUME \" << quoteString(destination_name);\n+        if (destination_type == DataDestinationType::DISK)\n+            settings.ostr << \" TO DISK \";\n+        else if (destination_type == DataDestinationType::VOLUME)\n+            settings.ostr << \" TO VOLUME \";\n+        else\n+            throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                \"Unsupported destination type {} for TTL MOVE\",\n+                    magic_enum::enum_name(destination_type));\n+\n+        if (if_exists)\n+            settings.ostr << \"IF EXISTS \";\n+\n+        settings.ostr << quoteString(destination_name);\n     }\n     else if (mode == TTLMode::GROUP_BY)\n     {\ndiff --git a/src/Parsers/ASTTTLElement.h b/src/Parsers/ASTTTLElement.h\nindex ce011d76c7b4..a396a4c54e04 100644\n--- a/src/Parsers/ASTTTLElement.h\n+++ b/src/Parsers/ASTTTLElement.h\n@@ -16,16 +16,18 @@ class ASTTTLElement : public IAST\n     TTLMode mode;\n     DataDestinationType destination_type;\n     String destination_name;\n+    bool if_exists = false;\n \n     ASTs group_by_key;\n     ASTs group_by_assignments;\n \n     ASTPtr recompression_codec;\n \n-    ASTTTLElement(TTLMode mode_, DataDestinationType destination_type_, const String & destination_name_)\n+    ASTTTLElement(TTLMode mode_, DataDestinationType destination_type_, const String & destination_name_, bool if_exists_)\n         : mode(mode_)\n         , destination_type(destination_type_)\n         , destination_name(destination_name_)\n+        , if_exists(if_exists_)\n         , ttl_expr_pos(-1)\n         , where_expr_pos(-1)\n     {\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 9c8f8b4e46b7..e00e0aba7b32 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -2360,6 +2360,7 @@ bool ParserTTLElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ParserKeyword s_to_disk(\"TO DISK\");\n     ParserKeyword s_to_volume(\"TO VOLUME\");\n+    ParserKeyword s_if_exists(\"IF EXISTS\");\n     ParserKeyword s_delete(\"DELETE\");\n     ParserKeyword s_where(\"WHERE\");\n     ParserKeyword s_group_by(\"GROUP BY\");\n@@ -2414,9 +2415,13 @@ bool ParserTTLElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     ASTPtr group_by_key;\n     ASTPtr recompression_codec;\n     ASTPtr group_by_assignments;\n+    bool if_exists = false;\n \n     if (mode == TTLMode::MOVE)\n     {\n+        if (s_if_exists.ignore(pos))\n+            if_exists = true;\n+\n         ASTPtr ast_space_name;\n         if (!parser_string_literal.parse(pos, ast_space_name, expected))\n             return false;\n@@ -2448,7 +2453,7 @@ bool ParserTTLElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             return false;\n     }\n \n-    auto ttl_element = std::make_shared<ASTTTLElement>(mode, destination_type, destination_name);\n+    auto ttl_element = std::make_shared<ASTTTLElement>(mode, destination_type, destination_name, if_exists);\n     ttl_element->setTTL(std::move(ttl_expr));\n     if (where_expr)\n         ttl_element->setWhere(std::move(where_expr));\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 68fa81e1df9a..7ce98b36ed2b 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -650,13 +650,14 @@ void MergeTreeData::checkTTLExpressions(const StorageInMemoryMetadata & new_meta\n     {\n         for (const auto & move_ttl : new_table_ttl.move_ttl)\n         {\n-            if (!getDestinationForMoveTTL(move_ttl))\n+            if (!move_ttl.if_exists && !getDestinationForMoveTTL(move_ttl))\n             {\n                 String message;\n                 if (move_ttl.destination_type == DataDestinationType::DISK)\n-                    message = \"No such disk \" + backQuote(move_ttl.destination_name) + \" for given storage policy.\";\n+                    message = \"No such disk \" + backQuote(move_ttl.destination_name) + \" for given storage policy\";\n                 else\n-                    message = \"No such volume \" + backQuote(move_ttl.destination_name) + \" for given storage policy.\";\n+                    message = \"No such volume \" + backQuote(move_ttl.destination_name) + \" for given storage policy\";\n+\n                 throw Exception(message, ErrorCodes::BAD_TTL_EXPRESSION);\n             }\n         }\n@@ -3363,9 +3364,6 @@ void MergeTreeData::movePartitionToDisk(const ASTPtr & partition, const String &\n         parts = getDataPartsVectorInPartition(MergeTreeDataPartState::Active, partition_id);\n \n     auto disk = getStoragePolicy()->getDiskByName(name);\n-    if (!disk)\n-        throw Exception(\"Disk \" + name + \" does not exists on policy \" + getStoragePolicy()->getName(), ErrorCodes::UNKNOWN_DISK);\n-\n     parts.erase(std::remove_if(parts.begin(), parts.end(), [&](auto part_ptr)\n         {\n             return part_ptr->volume->getDisk()->getName() == disk->getName();\n@@ -4112,10 +4110,10 @@ ReservationPtr MergeTreeData::tryReserveSpacePreferringTTLRules(\n         SpacePtr destination_ptr = getDestinationForMoveTTL(*move_ttl_entry, is_insert);\n         if (!destination_ptr)\n         {\n-            if (move_ttl_entry->destination_type == DataDestinationType::VOLUME)\n+            if (move_ttl_entry->destination_type == DataDestinationType::VOLUME && !move_ttl_entry->if_exists)\n                 LOG_WARNING(log, \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but volume was not found or rule is not applicable at the moment\",\n                     move_ttl_entry->destination_name, log_name);\n-            else if (move_ttl_entry->destination_type == DataDestinationType::DISK)\n+            else if (move_ttl_entry->destination_type == DataDestinationType::DISK && !move_ttl_entry->if_exists)\n                 LOG_WARNING(log, \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but disk was not found or rule is not applicable at the moment\",\n                     move_ttl_entry->destination_name, log_name);\n         }\n@@ -4149,7 +4147,7 @@ SpacePtr MergeTreeData::getDestinationForMoveTTL(const TTLDescription & move_ttl\n     auto policy = getStoragePolicy();\n     if (move_ttl.destination_type == DataDestinationType::VOLUME)\n     {\n-        auto volume = policy->getVolumeByName(move_ttl.destination_name);\n+        auto volume = policy->tryGetVolumeByName(move_ttl.destination_name);\n \n         if (!volume)\n             return {};\n@@ -4161,7 +4159,8 @@ SpacePtr MergeTreeData::getDestinationForMoveTTL(const TTLDescription & move_ttl\n     }\n     else if (move_ttl.destination_type == DataDestinationType::DISK)\n     {\n-        auto disk = policy->getDiskByName(move_ttl.destination_name);\n+        auto disk = policy->tryGetDiskByName(move_ttl.destination_name);\n+\n         if (!disk)\n             return {};\n \ndiff --git a/src/Storages/TTLDescription.cpp b/src/Storages/TTLDescription.cpp\nindex 693032644826..ccf924f28279 100644\n--- a/src/Storages/TTLDescription.cpp\n+++ b/src/Storages/TTLDescription.cpp\n@@ -112,6 +112,7 @@ TTLDescription::TTLDescription(const TTLDescription & other)\n     , aggregate_descriptions(other.aggregate_descriptions)\n     , destination_type(other.destination_type)\n     , destination_name(other.destination_name)\n+    , if_exists(other.if_exists)\n     , recompression_codec(other.recompression_codec)\n {\n     if (other.expression)\n@@ -149,6 +150,7 @@ TTLDescription & TTLDescription::operator=(const TTLDescription & other)\n     aggregate_descriptions = other.aggregate_descriptions;\n     destination_type = other.destination_type;\n     destination_name = other.destination_name;\n+    if_exists = other.if_exists;\n \n     if (other.recompression_codec)\n         recompression_codec = other.recompression_codec->clone();\n@@ -185,9 +187,10 @@ TTLDescription TTLDescription::getTTLFromAST(\n     }\n     else /// rows TTL\n     {\n+        result.mode = ttl_element->mode;\n         result.destination_type = ttl_element->destination_type;\n         result.destination_name = ttl_element->destination_name;\n-        result.mode = ttl_element->mode;\n+        result.if_exists = ttl_element->if_exists;\n \n         if (ttl_element->mode == TTLMode::DELETE)\n         {\ndiff --git a/src/Storages/TTLDescription.h b/src/Storages/TTLDescription.h\nindex 17020392013d..8f60eb604b56 100644\n--- a/src/Storages/TTLDescription.h\n+++ b/src/Storages/TTLDescription.h\n@@ -75,6 +75,10 @@ struct TTLDescription\n     /// Name of destination disk or volume\n     String destination_name;\n \n+    /// If true, do nothing if DISK or VOLUME doesn't exist .\n+    /// Only valid for table MOVE TTLs.\n+    bool if_exists = false;\n+\n     /// Codec name which will be used to recompress data\n     ASTPtr recompression_codec;\n \n",
  "test_patch": "diff --git a/tests/integration/test_ttl_move/configs/config.d/storage_configuration.xml b/tests/integration/test_ttl_move/configs/config.d/storage_configuration.xml\nindex a76e984e4e68..ae1dc9dd0383 100644\n--- a/tests/integration/test_ttl_move/configs/config.d/storage_configuration.xml\n+++ b/tests/integration/test_ttl_move/configs/config.d/storage_configuration.xml\n@@ -76,6 +76,14 @@\n             </volumes>\n         </jbod1_with_jbod2>\n \n+        <only_jbod_1>\n+            <volumes>\n+                <main>\n+                    <disk>jbod1</disk>\n+                </main>\n+            </volumes>\n+        </only_jbod_1>\n+\n         <only_jbod2>\n             <volumes>\n                 <main>\ndiff --git a/tests/integration/test_ttl_move/test.py b/tests/integration/test_ttl_move/test.py\nindex 254447478f91..d8373ccb48a4 100644\n--- a/tests/integration/test_ttl_move/test.py\n+++ b/tests/integration/test_ttl_move/test.py\n@@ -1174,3 +1174,57 @@ def test_disabled_ttl_move_on_insert(started_cluster, name, dest_type, engine):\n             node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n         except:\n             pass\n+\n+\n+@pytest.mark.parametrize(\"name,dest_type\", [\n+    pytest.param(\"replicated_mt_move_if_exists\", \"DISK\", id=\"replicated_disk\"),\n+    pytest.param(\"replicated_mt_move_if_exists\", \"VOLUME\", id=\"replicated_volume\"),\n+])\n+def test_ttl_move_if_exists(started_cluster, name, dest_type):\n+    name = unique_table_name(name)\n+\n+    try:\n+        query_template = \"\"\"\n+            CREATE TABLE {name} (\n+                s1 String,\n+                d1 DateTime\n+            ) ENGINE = ReplicatedMergeTree('/clickhouse/replicated_mt_move_if_exists', '{node_name}')\n+            ORDER BY tuple()\n+            TTL d1 TO {dest_type} {if_exists} 'external'\n+            SETTINGS storage_policy='{policy}'\n+        \"\"\"\n+\n+        with pytest.raises(QueryRuntimeException):\n+            node1.query(query_template.format( \\\n+                name=name, node_name=node1.name, dest_type=dest_type, \\\n+                if_exists='', policy='only_jbod_1'))\n+\n+        for (node, policy) in zip([node1, node2], ['only_jbod_1', 'small_jbod_with_external']):\n+            node.query(query_template.format( \\\n+                name=name, node_name=node.name, dest_type=dest_type, \\\n+                if_exists='IF EXISTS', policy=policy))\n+\n+        data = []  # 10MB in total\n+        for i in range(10):\n+            data.append((\"randomPrintableASCII(1024*1024)\", \"toDateTime({})\".format(time.time() - 1)))\n+\n+        node1.query(\"INSERT INTO {} (s1, d1) VALUES {}\".format(name, \",\".join([\"(\" + \",\".join(x) + \")\" for x in data])))\n+        node2.query(\"SYSTEM SYNC REPLICA {}\".format(name))\n+\n+        time.sleep(5)\n+\n+        used_disks1 = get_used_disks_for_table(node1, name)\n+        assert set(used_disks1) == {\"jbod1\"}\n+\n+        used_disks2 = get_used_disks_for_table(node2, name)\n+        assert set(used_disks2) == {\"external\"}\n+\n+        assert node1.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n+        assert node2.query(\"SELECT count() FROM {name}\".format(name=name)).strip() == \"10\"\n+\n+    finally:\n+        try:\n+            node1.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n+            node2.query(\"DROP TABLE IF EXISTS {} NO DELAY\".format(name))\n+        except:\n+            pass\ndiff --git a/tests/queries/0_stateless/02207_ttl_move_if_exists.reference b/tests/queries/0_stateless/02207_ttl_move_if_exists.reference\nnew file mode 100644\nindex 000000000000..bedef1a5ceb2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02207_ttl_move_if_exists.reference\n@@ -0,0 +1,1 @@\n+CREATE TABLE default.t_ttl_move_if_exists\\n(\\n    `d` DateTime,\\n    `a` UInt32\\n)\\nENGINE = MergeTree\\nORDER BY tuple()\\nTTL d TO DISK IF EXISTS \\'non_existing_disk\\'\\nSETTINGS index_granularity = 8192\ndiff --git a/tests/queries/0_stateless/02207_ttl_move_if_exists.sql b/tests/queries/0_stateless/02207_ttl_move_if_exists.sql\nnew file mode 100644\nindex 000000000000..ab17d343e49c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02207_ttl_move_if_exists.sql\n@@ -0,0 +1,9 @@\n+DROP TABLE IF EXISTS t_ttl_move_if_exists;\n+\n+CREATE TABLE t_ttl_move_if_exists (d DateTime, a UInt32)\n+ENGINE = MergeTree ORDER BY tuple()\n+TTL d TO DISK IF EXISTS 'non_existing_disk';\n+\n+SHOW CREATE TABLE t_ttl_move_if_exists;\n+\n+DROP TABLE IF EXISTS t_ttl_move_if_exists;\n",
  "problem_statement": "Ability to specify `TTL MOVE TO [DISK|VOLUME] [IF EXISTS]` \nDifferent replicas can have different disks/volumes/storage policies configuration. But `TTL MOVE` expression is a part of the table definition and cannot be different on different replicas. \r\n\r\nSo the idea is to implement `TTL MOVE IF EXSITS` which works only if disk exists on replica. Other replicas just ignores this expression.\n",
  "hints_text": "Maybe it should be the default behavior? \r\nHow often do we want to see exception in merge/move/mutation in case of missing disk in disk policy?\r\n\n> How often do we want to see exception in merge/move/mutation in case of missing disk in disk policy?\r\n\r\nI want to always get exception if `IF EXISTS` is not specified\r\nto prevent typos.\nI personally didn't like the idea of using `IF EXISTS` for this. It is like asking for a workaround to have what you want. Why not have a more definitive way to tell CH what to do on each replica?\r\n\r\nLet's imagine a scenario where I have N replicas and 2 disks (`SLOW` and `FAST`) for each replica.\r\n\r\nOn R1, R2, ... R(N-1):\r\n* Move rows older than 3 years to `SLOW` disk\r\n* Keep newer rows on `FAST` disk\r\n\r\nOn RN:\r\n* Move rows older than 3 years to `FAST` disk\r\n* Keep newer rows on `SLOW` disk\r\n\r\nThis way I can still get results faster even if the data is older than 3 years, by simply sending my query to RN. I know that queries asking for old data is not that often, but I still want to serve them fast.\r\n\r\nSo having able to tell ClickHouse have different TTL definitions for different replicas would be great, but doing it with `IF EXISTS` is kinda a workaround.\r\n\r\nHow about having something like this:\r\n```\r\nCREATE TABLE table_name ON CLUSTER cluster \r\n(\r\n    col1 String,\r\n    col2 String,\r\n    ...\r\n)\r\nENGINE = ...\r\nTTL WHERE (exp) DO\r\n    d + INTERVAL 1 MONTH [DELETE],\r\n    d + INTERVAL 1 WEEK TO VOLUME 'aaa',\r\n    d + INTERVAL 2 WEEK TO DISK 'bbb';\r\nTTL WHERE (exp) DO\r\n    d + INTERVAL 1 MONTH [DELETE],\r\n    d + INTERVAL 1 WEEK TO VOLUME 'aaa',\r\n    d + INTERVAL 2 WEEK TO DISK 'bbb';\r\nTTL\r\n    d + INTERVAL 1 MONTH [DELETE],\r\n    d + INTERVAL 1 WEEK TO VOLUME 'aaa',\r\n    d + INTERVAL 2 WEEK TO DISK 'bbb';\r\n```\r\n\r\n\r\nHere `exp` can be conditions that satisfy `system.clusters` table like:\r\n```\r\nTTL WHERE shard_num=1 and replica_num=1 and is_local=1 DO ...\r\n```\r\n\r\nand if there is no `WHERE` after `TTL` that applies for all replicas.\r\n\r\n",
  "created_at": "2022-02-10T16:31:50Z"
}