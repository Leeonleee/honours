{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41701,
  "instance_id": "ClickHouse__ClickHouse-41701",
  "issue_numbers": [
    "41433"
  ],
  "base_commit": "a0b064fc99d862dc67815c7ed3030f99146a3352",
  "patch": "diff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex fa13008f352c..174e98dd81f2 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -1766,12 +1766,12 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op\n                     return {true, is_constant_positive, true};\n                 }\n             }\n-            return {false, true, false};\n+            return {false, true, false, false};\n         }\n \n         // For simplicity, we treat every single value interval as positive monotonic.\n         if (applyVisitor(FieldVisitorAccurateEquals(), left_point, right_point))\n-            return {true, true, false};\n+            return {true, true, false, false};\n \n         if (name_view == \"minus\" || name_view == \"plus\")\n         {\n@@ -1797,18 +1797,18 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op\n                     // Check if there is an overflow\n                     if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)\n                             == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))\n-                        return {true, true, false};\n+                        return {true, true, false, true};\n                     else\n-                        return {false, true, false};\n+                        return {false, true, false, false};\n                 }\n                 else\n                 {\n                     // Check if there is an overflow\n                     if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)\n                             != applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))\n-                        return {true, false, false};\n+                        return {true, false, false, true};\n                     else\n-                        return {false, false, false};\n+                        return {false, false, false, false};\n                 }\n             }\n             // variable +|- constant\n@@ -1829,31 +1829,33 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op\n                 // Check if there is an overflow\n                 if (applyVisitor(FieldVisitorAccurateLess(), left_point, right_point)\n                     == applyVisitor(FieldVisitorAccurateLess(), transform(left_point), transform(right_point)))\n-                    return {true, true, false};\n+                    return {true, true, false, true};\n                 else\n-                    return {false, true, false};\n+                    return {false, true, false, false};\n             }\n         }\n         if (name_view == \"divide\" || name_view == \"intDiv\")\n         {\n+            bool is_strict = name_view == \"divide\";\n+\n             // const / variable\n             if (left.column && isColumnConst(*left.column))\n             {\n                 auto constant = (*left.column)[0];\n                 if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))\n-                    return {true, true, false}; // 0 / 0 is undefined, thus it's not always monotonic\n+                    return {true, true, false, false}; // 0 / 0 is undefined, thus it's not always monotonic\n \n                 bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);\n                 if (applyVisitor(FieldVisitorAccurateLess(), left_point, Field(0))\n                     && applyVisitor(FieldVisitorAccurateLess(), right_point, Field(0)))\n                 {\n-                    return {true, is_constant_positive, false};\n+                    return {true, is_constant_positive, false, is_strict};\n                 }\n                 else if (\n                     applyVisitor(FieldVisitorAccurateLess(), Field(0), left_point)\n                     && applyVisitor(FieldVisitorAccurateLess(), Field(0), right_point))\n                 {\n-                    return {true, !is_constant_positive, false};\n+                    return {true, !is_constant_positive, false, is_strict};\n                 }\n             }\n             // variable / constant\n@@ -1861,11 +1863,11 @@ class FunctionBinaryArithmeticWithConstants : public FunctionBinaryArithmetic<Op\n             {\n                 auto constant = (*right.column)[0];\n                 if (applyVisitor(FieldVisitorAccurateEquals(), constant, Field(0)))\n-                    return {false, true, false}; // variable / 0 is undefined, let's treat it as non-monotonic\n+                    return {false, true, false, false}; // variable / 0 is undefined, let's treat it as non-monotonic\n \n                 bool is_constant_positive = applyVisitor(FieldVisitorAccurateLess(), Field(0), constant);\n                 // division is saturated to `inf`, thus it doesn't have overflow issues.\n-                return {true, is_constant_positive, true};\n+                return {true, is_constant_positive, true, is_strict};\n             }\n         }\n         return {false, true, false};\ndiff --git a/src/Functions/IFunction.h b/src/Functions/IFunction.h\nindex 83b89b85b62c..69cd08c2ddb3 100644\n--- a/src/Functions/IFunction.h\n+++ b/src/Functions/IFunction.h\n@@ -265,9 +265,10 @@ class IFunctionBase\n     /// The property of monotonicity for a certain range.\n     struct Monotonicity\n     {\n-        bool is_monotonic = false;    /// Is the function monotonous (non-decreasing or non-increasing).\n-        bool is_positive = true;    /// true if the function is non-decreasing, false if non-increasing. If is_monotonic = false, then it does not matter.\n+        bool is_monotonic = false;   /// Is the function monotonous (non-decreasing or non-increasing).\n+        bool is_positive = true;     /// true if the function is non-decreasing, false if non-increasing. If is_monotonic = false, then it does not matter.\n         bool is_always_monotonic = false; /// Is true if function is monotonic on the whole input range I\n+        bool is_strict = false;      /// true if the function is strictly decreasing or increasing.\n     };\n \n     /** Get information about monotonicity on a range of values. Call only if hasInformationAboutMonotonicity.\ndiff --git a/src/Functions/abs.cpp b/src/Functions/abs.cpp\nindex ae2a2412a4b0..a7afdbacad6f 100644\n--- a/src/Functions/abs.cpp\n+++ b/src/Functions/abs.cpp\n@@ -46,7 +46,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameAbs>\n         if ((left_float < 0 && right_float > 0) || (left_float > 0 && right_float < 0))\n             return {};\n \n-        return { .is_monotonic = true, .is_positive = left_float > 0 };\n+        return { .is_monotonic = true, .is_positive = left_float > 0, .is_strict = true, };\n     }\n };\n \ndiff --git a/src/Functions/fromModifiedJulianDay.cpp b/src/Functions/fromModifiedJulianDay.cpp\nindex ff434715338e..b22711da8113 100644\n--- a/src/Functions/fromModifiedJulianDay.cpp\n+++ b/src/Functions/fromModifiedJulianDay.cpp\n@@ -139,7 +139,7 @@ namespace DB\n \n         Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override\n         {\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n+            return { .is_monotonic = true, .is_always_monotonic = true, .is_strict = true, };\n         }\n \n     private:\ndiff --git a/src/Functions/intExp10.cpp b/src/Functions/intExp10.cpp\nindex e807eec313ca..6e59a41c50be 100644\n--- a/src/Functions/intExp10.cpp\n+++ b/src/Functions/intExp10.cpp\n@@ -55,7 +55,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameIntExp10>\n         if (left_float < 0 || right_float > 19)\n             return {};\n \n-        return { .is_monotonic = true };\n+        return { .is_monotonic = true, .is_strict = true };\n     }\n };\n \ndiff --git a/src/Functions/intExp2.cpp b/src/Functions/intExp2.cpp\nindex 91fc4cb91b11..e39647b6c38e 100644\n--- a/src/Functions/intExp2.cpp\n+++ b/src/Functions/intExp2.cpp\n@@ -58,7 +58,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameIntExp2>\n         if (left_float < 0 || right_float > 63)\n             return {};\n \n-        return { .is_monotonic = true };\n+        return { .is_monotonic = true, .is_strict = true, };\n     }\n };\n \ndiff --git a/src/Functions/negate.cpp b/src/Functions/negate.cpp\nindex 779cc0fff78e..731c0766e9db 100644\n--- a/src/Functions/negate.cpp\n+++ b/src/Functions/negate.cpp\n@@ -42,7 +42,7 @@ template <> struct FunctionUnaryArithmeticMonotonicity<NameNegate>\n     static bool has() { return true; }\n     static IFunction::Monotonicity get(const Field &, const Field &)\n     {\n-        return { .is_monotonic = true, .is_positive = false };\n+        return { .is_monotonic = true, .is_positive = false, .is_strict = true };\n     }\n };\n \ndiff --git a/src/Functions/toModifiedJulianDay.cpp b/src/Functions/toModifiedJulianDay.cpp\nindex 2e9b6eb1c792..6c6eda1673ab 100644\n--- a/src/Functions/toModifiedJulianDay.cpp\n+++ b/src/Functions/toModifiedJulianDay.cpp\n@@ -157,7 +157,7 @@ namespace DB\n \n         Monotonicity getMonotonicityForRange(const IDataType &, const Field &, const Field &) const override\n         {\n-            return { .is_monotonic = true, .is_always_monotonic = true };\n+            return { .is_monotonic = true, .is_always_monotonic = true, .is_strict = true };\n         }\n \n     private:\ndiff --git a/src/Functions/toTimezone.cpp b/src/Functions/toTimezone.cpp\nindex 5f6784c56550..3a16c8756fbe 100644\n--- a/src/Functions/toTimezone.cpp\n+++ b/src/Functions/toTimezone.cpp\n@@ -67,7 +67,7 @@ class FunctionBaseToTimeZone : public IFunctionBase\n     Monotonicity getMonotonicityForRange(const IDataType & /*type*/, const Field & /*left*/, const Field & /*right*/) const override\n     {\n         const bool b = is_constant_timezone;\n-        return { .is_monotonic = b, .is_positive = b, .is_always_monotonic = b };\n+        return { .is_monotonic = b, .is_positive = b, .is_always_monotonic = b, .is_strict = b };\n     }\n \n private:\ndiff --git a/src/Storages/ReadInOrderOptimizer.cpp b/src/Storages/ReadInOrderOptimizer.cpp\nindex b67da14365e1..803b7833494c 100644\n--- a/src/Storages/ReadInOrderOptimizer.cpp\n+++ b/src/Storages/ReadInOrderOptimizer.cpp\n@@ -103,10 +103,17 @@ NameSet getFixedSortingColumns(\n     return fixed_points;\n }\n \n+struct MatchResult\n+{\n+    /// One of {-1, 0, 1} - direction of the match. 0 means - doesn't match.\n+    int direction = 0;\n+    /// If true then current key must be the last in the matched prefix of sort description.\n+    bool is_last_key = false;\n+};\n+\n /// Optimize in case of exact match with order key element\n /// or in some simple cases when order key element is wrapped into monotonic function.\n-/// Returns on of {-1, 0, 1} - direction of the match. 0 means - doesn't match.\n-int matchSortDescriptionAndKey(\n+MatchResult matchSortDescriptionAndKey(\n     const ExpressionActions::Actions & actions,\n     const SortColumnDescription & sort_column,\n     const String & sorting_key_column)\n@@ -114,12 +121,13 @@ int matchSortDescriptionAndKey(\n     /// If required order depend on collation, it cannot be matched with primary key order.\n     /// Because primary keys cannot have collations.\n     if (sort_column.collator)\n-        return 0;\n+        return {};\n+\n+    MatchResult result{sort_column.direction, false};\n \n-    int current_direction = sort_column.direction;\n     /// For the path: order by (sort_column, ...)\n     if (sort_column.column_name == sorting_key_column)\n-        return current_direction;\n+        return result;\n \n     /// For the path: order by (function(sort_column), ...)\n     /// Allow only one simple monotonic functions with one argument\n@@ -132,44 +140,35 @@ int matchSortDescriptionAndKey(\n             continue;\n \n         if (found_function)\n-        {\n-            current_direction = 0;\n-            break;\n-        }\n-        else\n-        {\n-            found_function = true;\n-        }\n+            return {};\n \n+        found_function = true;\n         if (action.node->children.size() != 1 || action.node->children.at(0)->result_name != sorting_key_column)\n-        {\n-            current_direction = 0;\n-            break;\n-        }\n+            return {};\n \n         const auto & func = *action.node->function_base;\n         if (!func.hasInformationAboutMonotonicity())\n-        {\n-            current_direction = 0;\n-            break;\n-        }\n+            return {};\n \n         auto monotonicity = func.getMonotonicityForRange(*func.getArgumentTypes().at(0), {}, {});\n         if (!monotonicity.is_monotonic)\n-        {\n-            current_direction = 0;\n-            break;\n-        }\n-        else if (!monotonicity.is_positive)\n-        {\n-            current_direction *= -1;\n-        }\n+            return {};\n+\n+        /// If function is not strict monotonic, it can break order\n+        /// if it's not last in the prefix of sort description.\n+        /// E.g. if we have ORDER BY (d, u) -- ('2020-01-01', 1), ('2020-01-02', 0), ('2020-01-03', 1)\n+        /// ORDER BY (toStartOfMonth(d), u) -- ('2020-01-01', 1), ('2020-01-01', 0), ('2020-01-01', 1)\n+        if (!monotonicity.is_strict)\n+            result.is_last_key = true;\n+\n+        if (!monotonicity.is_positive)\n+            result.direction *= -1;\n     }\n \n     if (!found_function)\n-        current_direction = 0;\n+        return {};\n \n-    return current_direction;\n+    return result;\n }\n \n }\n@@ -218,8 +217,8 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(\n         if (forbidden_columns.contains(description[desc_pos].column_name))\n             break;\n \n-        int current_direction = matchSortDescriptionAndKey(actions[desc_pos]->getActions(), description[desc_pos], sorting_key_columns[key_pos]);\n-        bool is_matched = current_direction && (desc_pos == 0 || current_direction == read_direction);\n+        auto match = matchSortDescriptionAndKey(actions[desc_pos]->getActions(), description[desc_pos], sorting_key_columns[key_pos]);\n+        bool is_matched = match.direction && (desc_pos == 0 || match.direction == read_direction);\n \n         if (!is_matched)\n         {\n@@ -235,12 +234,15 @@ InputOrderInfoPtr ReadInOrderOptimizer::getInputOrderImpl(\n         }\n \n         if (desc_pos == 0)\n-            read_direction = current_direction;\n+            read_direction = match.direction;\n \n         sort_description_for_merging.push_back(description[desc_pos]);\n \n         ++desc_pos;\n         ++key_pos;\n+\n+        if (match.is_last_key)\n+            break;\n     }\n \n     if (sort_description_for_merging.empty())\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\nindex 437b934c28c9..8a7291c1f088 100644\n--- a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\n+++ b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\n@@ -8,11 +8,13 @@ ExpressionTransform\n   (Limit)\n   Limit\n     (Sorting)\n-    MergingSortedTransform 2 \u2192 1\n-      (Expression)\n-      ExpressionTransform \u00d7 2\n-        (ReadFromMergeTree)\n-        MergeTreeInOrder \u00d7 2 0 \u2192 1\n+    FinishSortingTransform\n+      PartialSortingTransform\n+        MergingSortedTransform 2 \u2192 1\n+          (Expression)\n+          ExpressionTransform \u00d7 2\n+            (ReadFromMergeTree)\n+            MergeTreeInOrder \u00d7 2 0 \u2192 1\n 2020-10-01\t9\n 2020-10-01\t9\n 2020-10-01\t9\n@@ -23,14 +25,16 @@ ExpressionTransform\n   (Limit)\n   Limit\n     (Sorting)\n-    MergingSortedTransform 2 \u2192 1\n-      (Expression)\n-      ExpressionTransform \u00d7 2\n-        (ReadFromMergeTree)\n-        ReverseTransform\n-          MergeTreeReverse 0 \u2192 1\n+    FinishSortingTransform\n+      PartialSortingTransform\n+        MergingSortedTransform 2 \u2192 1\n+          (Expression)\n+          ExpressionTransform \u00d7 2\n+            (ReadFromMergeTree)\n             ReverseTransform\n               MergeTreeReverse 0 \u2192 1\n+                ReverseTransform\n+                  MergeTreeReverse 0 \u2192 1\n 2020-10-01\t9\n 2020-10-01\t9\n 2020-10-01\t9\ndiff --git a/tests/queries/0_stateless/02451_order_by_monotonic.reference b/tests/queries/0_stateless/02451_order_by_monotonic.reference\nnew file mode 100644\nindex 000000000000..d3de324a7e1e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02451_order_by_monotonic.reference\n@@ -0,0 +1,22 @@\n+4\n+2022-09-09 12:00:00\t0\n+2022-09-09 12:00:00\t0x\n+2022-09-09 12:00:00\t0x\n+2022-09-09 12:00:00\t1\n+2022-09-09 12:00:00\t1x\n+  Prefix sort description: toStartOfMinute(t) ASC\n+  Result sort description: toStartOfMinute(t) ASC, c1 ASC\n+  Prefix sort description: toStartOfMinute(t) ASC\n+  Result sort description: toStartOfMinute(t) ASC\n+  Prefix sort description: negate(a) ASC\n+  Result sort description: negate(a) ASC\n+  Prefix sort description: negate(a) ASC, negate(b) ASC\n+  Result sort description: negate(a) ASC, negate(b) ASC\n+  Prefix sort description: a DESC, negate(b) ASC\n+  Result sort description: a DESC, negate(b) ASC\n+  Prefix sort description: negate(a) ASC, b DESC\n+  Result sort description: negate(a) ASC, b DESC\n+  Prefix sort description: negate(a) ASC\n+  Result sort description: negate(a) ASC, b ASC\n+  Prefix sort description: a ASC\n+  Result sort description: a ASC, negate(b) ASC\ndiff --git a/tests/queries/0_stateless/02451_order_by_monotonic.sh b/tests/queries/0_stateless/02451_order_by_monotonic.sh\nnew file mode 100755\nindex 000000000000..cc26ba91e1cf\n--- /dev/null\n+++ b/tests/queries/0_stateless/02451_order_by_monotonic.sh\n@@ -0,0 +1,40 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+function explain_sort_description()\n+{\n+    out=$($CLICKHOUSE_CLIENT --optimize_read_in_order=1 -q \"EXPLAIN PLAN actions = 1 $1\")\n+    echo \"$out\" | grep \"Prefix sort description:\"\n+    echo \"$out\" | grep \"Result sort description:\"\n+}\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS t_order_by_monotonic\"\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE t_order_by_monotonic (t DateTime, c1 String) ENGINE = MergeTree ORDER BY (t, c1)\n+    AS SELECT '2022-09-09 12:00:00', toString(number % 2) FROM numbers(2) UNION ALL\n+       SELECT '2022-09-09 12:00:30', toString(number % 2)|| 'x' FROM numbers(3)\"\n+\n+$CLICKHOUSE_CLIENT --optimize_aggregation_in_order=1 -q \"SELECT count() FROM\n+    (SELECT toStartOfMinute(t) AS s, c1 FROM t_order_by_monotonic GROUP BY s, c1)\"\n+\n+$CLICKHOUSE_CLIENT --optimize_read_in_order=1 -q \"SELECT toStartOfMinute(t) AS s, c1 FROM t_order_by_monotonic ORDER BY s, c1\"\n+\n+explain_sort_description \"SELECT toStartOfMinute(t) AS s, c1 FROM t_order_by_monotonic ORDER BY s, c1\"\n+explain_sort_description \"SELECT toStartOfMinute(t) AS s, c1 FROM t_order_by_monotonic ORDER BY s\"\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS t_order_by_monotonic\"\n+\n+$CLICKHOUSE_CLIENT -q \"CREATE TABLE t_order_by_monotonic (a Int64, b Int64) ENGINE = MergeTree ORDER BY (a, b)\"\n+\n+$CLICKHOUSE_CLIENT -q \"INSERT INTO t_order_by_monotonic VALUES (1, 1) (1, 2), (2, 1) (2, 2)\"\n+\n+explain_sort_description \"SELECT * FROM t_order_by_monotonic ORDER BY -a\"\n+explain_sort_description \"SELECT * FROM t_order_by_monotonic ORDER BY -a, -b\"\n+explain_sort_description \"SELECT * FROM t_order_by_monotonic ORDER BY a DESC, -b\"\n+explain_sort_description \"SELECT * FROM t_order_by_monotonic ORDER BY -a, b DESC\"\n+explain_sort_description \"SELECT * FROM t_order_by_monotonic ORDER BY -a, b\"\n+explain_sort_description \"SELECT * FROM t_order_by_monotonic ORDER BY a, -b\"\n+\n+$CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS t_order_by_monotonic\"\n",
  "problem_statement": "toStartOfMinute without WHERE omitted non-aligned times\nI have struggled to recreate this issue on an isolated from-the-scratch example so will describe the in-situ scenario instead\r\n\r\nA (Summing)MergeTree table is sorted by a timestamp (plus a bunch of other columns) and is full of data that I have a select query on with a `toStartOfMinute` to add-up totals of some count column over minute intervals. A bit like this (for illustration only):\r\n\r\n```\r\nCREATE TABLE x (t DateTime, n UInt32) ENGINE = MergeTree ORDER BY t\r\nINSERT INTO x VALUES ('2022-09-17 07:00:00', 1) ('2022-09-17 07:00:30', 2)\r\nSELECT toStartOfMinute(t) AS s, sum(n) FROM x WHERE s = '2022-09-17 07:00:00' GROUP BY s\r\n```\r\n\r\nExpected result is 3. My real table returns the equivalent of 1, ie the 07:00:30 row is missing\r\n\r\nThe necessary conditions for this to happen include:\r\n\r\n- use `toStartOfMinute` instead of `toStartOfInterval(toIntervalMinute(1))`, and\r\n- don't try to filter down to specific rows using WHERE (instead I let query print full output and manually filter that)\r\n\r\nBelow are some differences of notice. Apart from size, the real table differs from the illustration one by a few other things like partitioning and replication. Of those only the size feels substantial; my illustration query does not break down into concurrent blocks like the real one.\r\n\r\n### Good\r\n\r\nie `toStartOfInterval`\r\n\r\n```\r\n<Debug> (SelectExecutor): Key condition: unknown\r\n<Debug> (SelectExecutor): MinMax index condition: unknown\r\n<Debug> (SelectExecutor): Selected 1771/1771 parts by partition key, 1771 parts by primary key, 1233002/1233002 marks by primary key, 1233002 marks to read from 1771 ranges\r\n<Debug> (SelectExecutor): Reading approx. 10093333761 rows with 32 streams\r\n<Trace> AggregatingTransform: Aggregating\r\n<Trace> Aggregator: Aggregation method: serialized\r\n<Trace> Aggregator: Converting aggregation data to two-level.\r\n<Debug> AggregatingTransform: Aggregated. 0 to 0 rows (from 0.00 B) in 3.133200993 sec. (0.000 rows/sec., 0.00 B/sec.)\r\n                          ...\r\n<Debug> AggregatingTransform: Aggregated. 0 to 0 rows (from 0.00 B) in 3.134824955 sec. (0.000 rows/sec., 0.00 B/sec.)\r\n<Trace> Aggregator: Merging aggregated data\r\n```\r\n\r\n```\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (Expression)                           \u2502\r\n\u2502 ExpressionTransform                    \u2502\r\n\u2502   (Aggregating)                        \u2502\r\n\u2502   Resize 32 \u2192 1                        \u2502\r\n\u2502     AggregatingTransform \u00d7 32          \u2502\r\n\u2502       StrictResize 32 \u2192 32             \u2502\r\n\u2502         (Expression)                   \u2502\r\n\u2502         ExpressionTransform \u00d7 32       \u2502\r\n\u2502           (SettingQuotaAndLimits)      \u2502\r\n\u2502             (ReadFromMergeTree)        \u2502\r\n\u2502             MergeTreeThread \u00d7 32 0 \u2192 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n### Bad\r\n\r\nie `toStartOfMinute`\r\n\r\n```\r\n<Debug> (SelectExecutor): Key condition: (toStartOfMinute(column 0) in [1662724800, 1662724800])\r\n<Debug> (SelectExecutor): MinMax index condition: (toStartOfMinute(column 0) in [1662724800, 1662724800])\r\n<Trace> (SelectExecutor): Used generic exclusion search over index for part 1662724800_0_0_0_5 with 157 steps\r\n<Debug> (SelectExecutor): Selected 1/1778 parts by partition key, 1 parts by primary key, 88/5422 marks by primary key, 88 marks to read from 1 ranges\r\n<Trace> MergeTreeInOrderSelectProcessor: Reading 5 ranges in order from part 1662724800_0_0_0_5, approx. 196608 rows starting from 0\r\n<Trace> MergeTreeInOrderSelectProcessor: Reading 5 ranges in order from part 1662724800_0_0_0_5, approx. 196608 rows starting from 196608\r\n<Trace> MergeTreeInOrderSelectProcessor: Reading 6 ranges in order from part 1662724800_0_0_0_5, approx. 327680 rows starting from 393216\r\n<Trace> AggregatingInOrderTransform: Aggregating in order\r\n<Trace> AggregatingInOrderTransform: Aggregating in order\r\n<Trace> AggregatingInOrderTransform: Aggregating in order\r\n<Trace> Aggregator: Merging partially aggregated blocks (bucket = -1).\r\n<Debug> AggregatingInOrderTransform: Aggregated. 196608 to 196608 rows (from 18.78 MiB)\r\n<Trace> Aggregator: Merging partially aggregated blocks (bucket = -1).\r\n<Debug> Aggregator: Merged partially aggregated blocks. 230062 rows, 18.64 MiB. in 0.225520311 sec. (1020138.714 rows/sec., 82.66 MiB/sec.)\r\n<Debug> AggregatingInOrderTransform: Aggregated. 196608 to 188416 rows (from 17.81 MiB)\r\n<Debug> AggregatingInOrderTransform: Aggregated. 326734 to 326734 rows (from 30.80 MiB)\r\n<Trace> Aggregator: Merging partially aggregated blocks (bucket = -1).\r\n<Debug> Aggregator: Merged partially aggregated blocks. 117168 rows, 9.52 MiB. in 0.089612692 sec. (1307493.363 rows/sec., 106.18 MiB/sec.)\r\n<Debug> Aggregator: Merged partially aggregated blocks. 238778 rows, 19.38 MiB. in 0.219948034 sec. (1085610.977 rows/sec., 88.11 MiB/sec.)\r\n```\r\n\r\n```\r\n\u250c\u2500explain\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 (Expression)                                  \u2502\r\n\u2502 ExpressionTransform \u00d7 32                      \u2502\r\n\u2502   (Aggregating)                               \u2502\r\n\u2502   MergingAggregatedBucketTransform \u00d7 32       \u2502\r\n\u2502     Resize 1 \u2192 32                             \u2502\r\n\u2502       FinishAggregatingInOrderTransform 3 \u2192 1 \u2502\r\n\u2502         AggregatingInOrderTransform \u00d7 3       \u2502\r\n\u2502           (Expression)                        \u2502\r\n\u2502           ExpressionTransform \u00d7 3             \u2502\r\n\u2502             (SettingQuotaAndLimits)           \u2502\r\n\u2502               (ReadFromMergeTree)             \u2502\r\n\u2502               MergeTreeInOrder \u00d7 3 0 \u2192 1      \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI didn't find any relevant GitHub issues and so would appreciate your thoughts or suggestions\r\n\r\nClickHouse server version 22.3.5.5\n",
  "hints_text": "try to upgrade to 22.3.12.19\r\n\r\nDefinitely something wrong with the partition pruning or the index analysis.\r\n\r\nYour real table is partitioned. And you have a timezone defined probably not to UTC or hourly partitioned?\r\n\r\n> for part 1662724800_0_0_0_5 \r\n\r\n```\r\nSELECT toDateTime(1662724800)\r\n\r\n\u250c\u2500toDateTime(1662724800)\u2500\u2510\r\n\u2502    2022-09-09 14:00:00 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nSo provide `select timezone()`, and the real `partition by / order by`\r\n\r\nAlso what is the result of `.... WHERE s = toDateTime('2022-09-17 07:00:00', yourtimezone) ....`\nThank you for the quick response, Denny\r\n\r\nUpgrade to 22.3.12.19 \u2192 same result\r\n\r\nTimezone is definitely UTC, I must have drawn up the illustration numbers on my desktop in CEST timezone (I have not therefore done the 'yourtimezone' query you suggest)\r\n\r\nHere is table create statement with actual data types and partition/order clauses:\r\n\r\n```sql\r\nCREATE TABLE x\r\n(\r\n    t DateTime,\r\n    c1 String,\r\n    c2 UInt64,\r\n    c3 Int8,\r\n    c4 LowCardinality(String),\r\n    c5 LowCardinality(String),\r\n    c6 UInt16,\r\n    c7 UInt32,\r\n    c8 UInt32,\r\n    n UInt64,\r\n    m UInt64\r\n)\r\nENGINE = ReplicatedSummingMergeTree\r\nPARTITION BY toStartOfHour(t)\r\nORDER BY (t, c1, c2, c3, c4, c5, c6, c7, c8)\r\nTTL t + toIntervalDay(14)\r\nSETTINGS ttl_only_drop_parts = 1\r\n```\ncan you please share the result of \r\n\r\n```\r\nSELECT\r\n    toStartOfMinute(identity(t)) AS s,\r\n    min(t),\r\n    max(t),\r\n    _part,\r\n    count()\r\nFROM x\r\nWHERE s = '2022-09-09 12:00:00'\r\nGROUP BY\r\n    s,\r\n    _part\r\n\r\n\r\nSELECT\r\n    toStartOfMinute(t) AS s,\r\n    min(t),\r\n    max(t),\r\n    _part,\r\n    count()\r\nFROM x\r\nWHERE s = '2022-09-09 12:00:00'\r\nGROUP BY\r\n    s,\r\n    _part\r\n\r\n\r\n```\nSame result with and without `identity`:\r\n\r\n```\r\ns:       2022-09-09 12:00:00\r\nmin(t):  2022-09-09 12:00:00\r\nmax(t):  2022-09-09 12:00:30\r\n_part:   1662724800_0_0_0_8\r\ncount(): 759703\r\n```\nCheck `sum(n)` as well,\r\n\r\n```\r\nSELECT\r\n    toStartOfMinute(identity(t)) AS s,\r\n    min(t),\r\n    max(t),\r\n    _part,\r\n    count(), sum(n)\r\nFROM x\r\nWHERE s = '2022-09-09 12:00:00'\r\nGROUP BY\r\n    s,\r\n    _part\r\n\r\n\r\nSELECT\r\n    toStartOfMinute(t) AS s,\r\n    min(t),\r\n    max(t),\r\n    _part,\r\n    count(),sum(n)\r\nFROM x\r\nWHERE s = '2022-09-09 12:00:00'\r\nGROUP BY\r\n    s,\r\n    _part\r\n```\n`sum(n)` returns the total 52461082, with and without `identity`\r\n\r\nWeirdly enough, the n column adds up to the same value in the output of `SELECT expr(t) AS s, sum(n) FROM x WHERE s = '...' GROUP BY s` for both `toStartOfMinute` and `toStartOfInterval` as `expr`. It's only if I browse the output I find that subtotals don't match. Furthermore, distinct values of various other sorting key columns (c2 through to c8) have slight differences. As if the values came from a slightly different interval in one case than the other.\nI am confused. Provide the exact queries with outputs to demonstrate the issue.\nHere are columns c2 and n from the real output. There are many identical runs but many overlap only partially. You'll see c2=281872676 in toStartOfInterval but not in toStartOfMinute. You'll see different values for c2=545845521 between toStartOfInterval and toStartOfMinute. And so on.\r\n\r\n[toStartOfInterval.tsv.gz](https://github.com/ClickHouse/ClickHouse/files/9607662/toStartOfInterval.tsv.gz)\r\n[toStartOfMinute.tsv.gz](https://github.com/ClickHouse/ClickHouse/files/9607663/toStartOfMinute.tsv.gz)\r\n\r\nI have sadly not been able to recreate the issue on a data set smaller than my entire table (0.6TB). What I might try is extracting just the one minute interval to another table of identical schema.\nIt looks just the one minute can recreate it on a freshly created table:\r\n\r\n```sql\r\nCREATE TABLE x\r\n(\r\n    t DateTime,\r\n    c1 String,\r\n    c2 UInt64,\r\n    c3 Int8,\r\n    c4 LowCardinality(String),\r\n    c5 LowCardinality(String),\r\n    c6 UInt16,\r\n    c7 UInt32,\r\n    c8 UInt32,\r\n    n UInt64,\r\n    m UInt64\r\n)\r\nENGINE = SummingMergeTree\r\nPARTITION BY toStartOfHour(t)\r\nORDER BY (t, c1, c2, c3, c4, c5, c6, c7, c8)\r\nTTL t + toIntervalDay(14)\r\nSETTINGS ttl_only_drop_parts = 1\r\n```\r\n\r\nThen:\r\n```sql\r\nINSERT INTO x FROM INFILE '/tmp/x.tsv' FORMAT TSV\r\n```\r\n\r\nTo pick out one difference I do:\r\n```shell\r\nclickhouse client < query.sql | \\\r\n  awk -F$'\\t' '{ if ($2 == \"amw1332333235\" && $3 == \"446612552\"\r\n  && $4 == \"0\" && $5 == \"\" && $6 == \"\" && $7 == \"200\"\r\n  && $8 == \"1671639327\" && $9 == \"12491\") { s += $11 } } END { print s }'\r\n```\r\n\r\nWhere my select query is:\r\n```sql\r\nSELECT\r\n    toStartOfMinute(t) AS s,\r\n    c1,\r\n    c2,\r\n    c3,\r\n    c4,\r\n    c5,\r\n    c6,\r\n    c7,\r\n    c8,\r\n    sum(n) AS n,\r\n    sum(m) AS m\r\nFROM x\r\nWHERE s IN ['2022-09-09 12:00:00', '2022-09-09 12:00:30']\r\nGROUP BY (s, c1, c2, c3, c4, c5, c6, c7, c8)\r\nORDER BY (s, c1, c2, c3, c4, c5, c6, c7, c8)\r\n```\r\n\r\nSum of m (the last column) filtered down by awk is 5 for toStartOfMinute and becomes 17 once I use toStartOfInterval in the query instead\r\n\r\n[x.tsv.gz](https://github.com/ClickHouse/ClickHouse/files/9608071/x.tsv.gz)\nI see, `optimize_aggregation_in_order` is the culprit.\r\n\r\n```\r\n| => clickhouse-client --optimize_aggregation_in_order=1 < query.sql | awk -F$'\\t' '{ if ($2 == \"amw1332333235\" && $3 == \"446612552\" && $4 == \"0\" && $5 == \"\" && $6 == \"\" && $7 == \"200\" && $8 == \"1671639327\" && $9 == \"12491\") { s += $11 } } END { print s }'\r\n5\r\n\r\n| => clickhouse-client --optimize_aggregation_in_order=0 < query.sql | awk -F$'\\t' '{ if ($2 == \"amw1332333235\" && $3 == \"446612552\" && $4 == \"0\" && $5 == \"\" && $6 == \"\" && $7 == \"200\" && $8 == \"1671639327\" && $9 == \"12491\") { s += $11 } } END { print s }'\r\n17\r\n```\nrepro\r\n\r\n```sql\r\ndrop table if exists x3;\r\nCREATE TABLE x3(t DateTime, c1 String) ENGINE = MergeTree ORDER BY (t, c1)\r\nas select '2022-09-09 12:00:00', toString(number%2) from numbers(2) union all  \r\nselect '2022-09-09 12:00:30', toString(number%2)||'x' from numbers(3);\r\n\r\nselect count() from\r\n(SELECT toStartOfMinute(t) AS s, c1 FROM x3 GROUP BY s, c1 limit 100000000)\r\nsettings optimize_aggregation_in_order=1;\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nselect count() from\r\n(SELECT toStartOfMinute(t) AS s, c1 FROM x3 GROUP BY s, c1 limit 100000000)\r\nsettings optimize_aggregation_in_order=0;\r\n\u250c\u2500count()\u2500\u2510\r\n\u2502       4 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nhttps://fiddle.clickhouse.com/d4de6907-d2b6-45ae-95f5-e20b5b2d77f0\r\n\r\n\r\n```sql\r\nSELECT toStartOfMinute(t) AS s, c1,groupArray(c1), groupArray(t) FROM x3 \r\nGROUP BY s, c1 ORDER BY s, c1 settings optimize_aggregation_in_order=1;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500s\u2500\u252c\u2500c1\u2500\u252c\u2500groupArray(c1)\u2500\u2500\u252c\u2500groupArray(t)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 2022-09-09 12:00:00 \u2502 0  \u2502 ['0']           \u2502 ['2022-09-09 12:00:00']                                             \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 1  \u2502 ['1','0x','0x'] \u2502 ['2022-09-09 12:00:00','2022-09-09 12:00:30','2022-09-09 12:00:30'] \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 1x \u2502 ['1x']          \u2502 ['2022-09-09 12:00:30']                                             \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT toStartOfMinute(t) AS s, c1,groupArray(c1), groupArray(t) FROM x3 \r\nGROUP BY s, c1 ORDER BY s, c1 settings optimize_aggregation_in_order=0;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500s\u2500\u252c\u2500c1\u2500\u252c\u2500groupArray(c1)\u2500\u252c\u2500groupArray(t)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 2022-09-09 12:00:00 \u2502 0  \u2502 ['0']          \u2502 ['2022-09-09 12:00:00']                       \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 0x \u2502 ['0x','0x']    \u2502 ['2022-09-09 12:00:30','2022-09-09 12:00:30'] \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 1  \u2502 ['1']          \u2502 ['2022-09-09 12:00:00']                       \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 1x \u2502 ['1x']         \u2502 ['2022-09-09 12:00:30']                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT toStartOfInterval(t, interval 1 minute) AS s, c1,groupArray(c1), groupArray(t) FROM x3\r\nGROUP BY s, c1 ORDER BY s, c1 settings optimize_aggregation_in_order=1;\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500s\u2500\u252c\u2500c1\u2500\u252c\u2500groupArray(c1)\u2500\u252c\u2500groupArray(t)\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 2022-09-09 12:00:00 \u2502 0  \u2502 ['0']          \u2502 ['2022-09-09 12:00:00']                       \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 0x \u2502 ['0x','0x']    \u2502 ['2022-09-09 12:00:30','2022-09-09 12:00:30'] \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 1  \u2502 ['1']          \u2502 ['2022-09-09 12:00:00']                       \u2502\r\n\u2502 2022-09-09 12:00:00 \u2502 1x \u2502 ['1x']         \u2502 ['2022-09-09 12:00:30']                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@larry-cdn77 Please confirm your settings \r\n\r\n```\r\nselect name,value from system.settings where name = 'optimize_aggregation_in_order';\r\n```\r\n\r\nAnd check the result with `optimize_aggregation_in_order=0`\nGood find. I have indeed been using optimize_aggregation_in_order and I can confirm that disabling it fixes my incorrect results.",
  "created_at": "2022-09-22T16:09:37Z"
}