{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 17641,
  "instance_id": "ClickHouse__ClickHouse-17641",
  "issue_numbers": [
    "17457"
  ],
  "base_commit": "424df030afe62cf7ef72bf62ff6305382d0a14ef",
  "patch": "diff --git a/contrib/poco b/contrib/poco\nindex 08974cc024b2..2c32e17c7dfe 160000\n--- a/contrib/poco\n+++ b/contrib/poco\n@@ -1,1 +1,1 @@\n-Subproject commit 08974cc024b2e748f5b1d45415396706b3521d0f\n+Subproject commit 2c32e17c7dfee1f8bf24227b697cdef5fddf0823\ndiff --git a/src/Common/CounterInFile.h b/src/Common/CounterInFile.h\nindex 48414bd09cc3..8cd4534d4135 100644\n--- a/src/Common/CounterInFile.h\n+++ b/src/Common/CounterInFile.h\n@@ -87,7 +87,7 @@ class CounterInFile\n                 {\n                     /// A more understandable error message.\n                     if (e.code() == DB::ErrorCodes::CANNOT_READ_ALL_DATA || e.code() == DB::ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF)\n-                        throw DB::Exception(\"File \" + path + \" is empty. You must fill it manually with appropriate value.\", e.code());\n+                        throw DB::ParsingException(\"File \" + path + \" is empty. You must fill it manually with appropriate value.\", e.code());\n                     else\n                         throw;\n                 }\ndiff --git a/src/Common/Exception.cpp b/src/Common/Exception.cpp\nindex d9bbb170dcca..b782471a4e88 100644\n--- a/src/Common/Exception.cpp\n+++ b/src/Common/Exception.cpp\n@@ -450,5 +450,49 @@ ExecutionStatus ExecutionStatus::fromCurrentException(const std::string & start_\n     return ExecutionStatus(getCurrentExceptionCode(), msg);\n }\n \n+ParsingException::ParsingException()\n+{\n+    Exception::message(Exception::message() + \"{}\");\n+}\n+\n+ParsingException::ParsingException(const std::string & msg, int code)\n+    : Exception(msg, code)\n+{\n+    Exception::message(Exception::message() + \"{}\");\n+}\n+\n+ParsingException::ParsingException(int code, const std::string & message)\n+    : Exception(message, code)\n+{\n+    Exception::message(Exception::message() + \"{}\");\n+}\n+\n+\n+/// We use additional field formatted_message_ to make this method const.\n+std::string ParsingException::displayText() const\n+{\n+    try\n+    {\n+        if (line_number_ == -1)\n+            formatted_message_ = fmt::format(message(), \"\");\n+        else\n+            formatted_message_ = fmt::format(message(), fmt::format(\": (at row {})\\n\", line_number_));\n+    }\n+    catch (...)\n+    {}\n+\n+    if (!formatted_message_.empty())\n+    {\n+        std::string result = name();\n+        result.append(\": \");\n+        result.append(formatted_message_);\n+        return result;\n+    }\n+    else\n+    {\n+        return Exception::displayText();\n+    }\n+}\n+\n \n }\ndiff --git a/src/Common/Exception.h b/src/Common/Exception.h\nindex 3da2e2fb0d0d..4b04de5d8a28 100644\n--- a/src/Common/Exception.h\n+++ b/src/Common/Exception.h\n@@ -96,6 +96,38 @@ class ErrnoException : public Exception\n };\n \n \n+/// Special class of exceptions, used mostly in ParallelParsingInputFormat for\n+/// more convinient calculation of problem line number.\n+class ParsingException : public Exception\n+{\n+public:\n+    ParsingException();\n+    ParsingException(const std::string & msg, int code);\n+    ParsingException(int code, const std::string & message);\n+\n+    // Format message with fmt::format, like the logging functions.\n+    template <typename ...Args>\n+    ParsingException(int code, const std::string & fmt, Args&&... args)\n+        : Exception(fmt::format(fmt, std::forward<Args>(args)...), code)\n+    {\n+        Exception::message(Exception::message() + \"{}\");\n+    }\n+\n+\n+    std::string displayText() const override;\n+\n+    int getLineNumber() { return line_number_; }\n+    void setLineNumber(int line_number) { line_number_ = line_number;}\n+\n+private:\n+    ssize_t line_number_{-1};\n+    mutable std::string formatted_message_;\n+\n+    const char * name() const throw() override { return \"DB::ParsingException\"; }\n+    const char * className() const throw() override { return \"DB::ParsingException\"; }\n+};\n+\n+\n using Exceptions = std::vector<std::exception_ptr>;\n \n \ndiff --git a/src/DataStreams/NativeBlockInputStream.cpp b/src/DataStreams/NativeBlockInputStream.cpp\nindex ae2d6886fa86..b182d5e05882 100644\n--- a/src/DataStreams/NativeBlockInputStream.cpp\n+++ b/src/DataStreams/NativeBlockInputStream.cpp\n@@ -106,7 +106,7 @@ Block NativeBlockInputStream::readImpl()\n     if (istr.eof())\n     {\n         if (use_index)\n-            throw Exception(\"Input doesn't contain all data for index.\", ErrorCodes::CANNOT_READ_ALL_DATA);\n+            throw ParsingException(\"Input doesn't contain all data for index.\", ErrorCodes::CANNOT_READ_ALL_DATA);\n \n         return res;\n     }\ndiff --git a/src/DataStreams/ParallelParsingBlockInputStream.cpp b/src/DataStreams/ParallelParsingBlockInputStream.cpp\nindex 19b04d36fc10..b7a0c3cab99b 100644\n--- a/src/DataStreams/ParallelParsingBlockInputStream.cpp\n+++ b/src/DataStreams/ParallelParsingBlockInputStream.cpp\n@@ -126,8 +126,11 @@ void ParallelParsingBlockInputStream::segmentatorThreadFunction(ThreadGroupStatu\n             // Segmentating the original input.\n             unit.segment.resize(0);\n \n-            const bool have_more_data = file_segmentation_engine(original_buffer,\n-                unit.segment, min_chunk_bytes);\n+            auto [have_more_data, currently_read_rows] = file_segmentation_engine(\n+                original_buffer, unit.segment, min_chunk_bytes);\n+\n+            unit.offset = successfully_read_rows_count;\n+            successfully_read_rows_count += currently_read_rows;\n \n             unit.is_last = !have_more_data;\n             unit.status = READY_TO_PARSE;\n@@ -142,7 +145,7 @@ void ParallelParsingBlockInputStream::segmentatorThreadFunction(ThreadGroupStatu\n     }\n     catch (...)\n     {\n-        onBackgroundException();\n+        onBackgroundException(successfully_read_rows_count);\n     }\n }\n \n@@ -157,11 +160,11 @@ void ParallelParsingBlockInputStream::parserThreadFunction(ThreadGroupStatusPtr\n \n     setThreadName(\"ChunkParser\");\n \n+    const auto current_unit_number = current_ticket_number % processing_units.size();\n+    auto & unit = processing_units[current_unit_number];\n+\n     try\n     {\n-        const auto current_unit_number = current_ticket_number % processing_units.size();\n-        auto & unit = processing_units[current_unit_number];\n-\n         /*\n          * This is kind of suspicious -- the input_process_creator contract with\n          * respect to multithreaded use is not clear, but we hope that it is\n@@ -195,19 +198,22 @@ void ParallelParsingBlockInputStream::parserThreadFunction(ThreadGroupStatusPtr\n     }\n     catch (...)\n     {\n-        onBackgroundException();\n+        onBackgroundException(unit.offset);\n     }\n }\n \n-void ParallelParsingBlockInputStream::onBackgroundException()\n+void ParallelParsingBlockInputStream::onBackgroundException(size_t offset)\n {\n-    tryLogCurrentException(__PRETTY_FUNCTION__);\n-\n     std::unique_lock<std::mutex> lock(mutex);\n     if (!background_exception)\n     {\n         background_exception = std::current_exception();\n+\n+        if (ParsingException * e = exception_cast<ParsingException *>(background_exception))\n+            if (e->getLineNumber() != -1)\n+                e->setLineNumber(e->getLineNumber() + offset);\n     }\n+    tryLogCurrentException(__PRETTY_FUNCTION__);\n     finished = true;\n     reader_condvar.notify_all();\n     segmentator_condvar.notify_all();\ndiff --git a/src/DataStreams/ParallelParsingBlockInputStream.h b/src/DataStreams/ParallelParsingBlockInputStream.h\nindex c882acd9dddf..749de83b583e 100644\n--- a/src/DataStreams/ParallelParsingBlockInputStream.h\n+++ b/src/DataStreams/ParallelParsingBlockInputStream.h\n@@ -149,6 +149,8 @@ class ParallelParsingBlockInputStream : public IBlockInputStream\n         BlockExt block_ext;\n         Memory<> segment;\n         std::atomic<ProcessingUnitStatus> status;\n+        /// Needed for better exception message.\n+        size_t offset = 0;\n         bool is_last{false};\n     };\n \n@@ -159,6 +161,10 @@ class ParallelParsingBlockInputStream : public IBlockInputStream\n     std::deque<ProcessingUnit> processing_units;\n \n \n+    /// Compute it to have a more understandable error message.\n+    size_t successfully_read_rows_count{0};\n+\n+\n     void scheduleParserThreadForUnitWithNumber(size_t ticket_number);\n     void finishAndWait();\n \n@@ -169,7 +175,7 @@ class ParallelParsingBlockInputStream : public IBlockInputStream\n     // threads. This function is used by segmentator and parsed threads.\n     // readImpl() is called from the main thread, so the exception handling\n     // is different.\n-    void onBackgroundException();\n+    void onBackgroundException(size_t offset);\n };\n \n }\ndiff --git a/src/DataTypes/DataTypeArray.cpp b/src/DataTypes/DataTypeArray.cpp\nindex 1a8130fb36dd..9cd56d0e2b5d 100644\n--- a/src/DataTypes/DataTypeArray.cpp\n+++ b/src/DataTypes/DataTypeArray.cpp\n@@ -272,7 +272,7 @@ void DataTypeArray::deserializeBinaryBulkWithMultipleStreams(\n     /// Check consistency between offsets and elements subcolumns.\n     /// But if elements column is empty - it's ok for columns of Nested types that was added by ALTER.\n     if (!nested_column.empty() && nested_column.size() != last_offset)\n-        throw Exception(\"Cannot read all array values: read just \" + toString(nested_column.size()) + \" of \" + toString(last_offset),\n+        throw ParsingException(\"Cannot read all array values: read just \" + toString(nested_column.size()) + \" of \" + toString(last_offset),\n             ErrorCodes::CANNOT_READ_ALL_DATA);\n }\n \n@@ -325,7 +325,7 @@ static void deserializeTextImpl(IColumn & column, ReadBuffer & istr, Reader && r\n                 if (*istr.position() == ',')\n                     ++istr.position();\n                 else\n-                    throw Exception(ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT,\n+                    throw ParsingException(ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT,\n                         \"Cannot read array from text, expected comma or end of array, found '{}'\",\n                         *istr.position());\n             }\ndiff --git a/src/DataTypes/DataTypeNullable.cpp b/src/DataTypes/DataTypeNullable.cpp\nindex ed501939901c..a0fc8baaf7e4 100644\n--- a/src/DataTypes/DataTypeNullable.cpp\n+++ b/src/DataTypes/DataTypeNullable.cpp\n@@ -235,7 +235,7 @@ ReturnType DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer\n     /// Little tricky, because we cannot discriminate null from first character.\n \n     if (istr.eof())\n-        throw Exception(\"Unexpected end of stream, while parsing value of Nullable type\", ErrorCodes::CANNOT_READ_ALL_DATA);\n+        throw ParsingException(\"Unexpected end of stream, while parsing value of Nullable type\", ErrorCodes::CANNOT_READ_ALL_DATA);\n \n     /// This is not null, surely.\n     if (*istr.position() != '\\\\')\n@@ -250,7 +250,7 @@ ReturnType DataTypeNullable::deserializeTextEscaped(IColumn & column, ReadBuffer\n         ++istr.position();\n \n         if (istr.eof())\n-            throw Exception(\"Unexpected end of stream, while parsing value of Nullable type, after backslash\", ErrorCodes::CANNOT_READ_ALL_DATA);\n+            throw ParsingException(\"Unexpected end of stream, while parsing value of Nullable type, after backslash\", ErrorCodes::CANNOT_READ_ALL_DATA);\n \n         return safeDeserialize<ReturnType>(column, *nested_data_type,\n             [&istr]\n@@ -405,11 +405,11 @@ ReturnType DataTypeNullable::deserializeTextCSV(IColumn & column, ReadBuffer & i\n                 /// or if someone uses 'U' or 'L' as delimiter in CSV.\n                 /// In the first case we cannot continue reading anyway. The second case seems to be unlikely.\n                 if (settings.csv.delimiter == 'U' || settings.csv.delimiter == 'L')\n-                    throw DB::Exception(\"Enabled setting input_format_csv_unquoted_null_literal_as_null may not work correctly \"\n+                    throw DB::ParsingException(\"Enabled setting input_format_csv_unquoted_null_literal_as_null may not work correctly \"\n                                         \"with format_csv_delimiter = 'U' or 'L' for large input.\", ErrorCodes::CANNOT_READ_ALL_DATA);\n                 WriteBufferFromOwnString parsed_value;\n                 nested_data_type->serializeAsTextCSV(nested, nested.size() - 1, parsed_value, settings);\n-                throw DB::Exception(\"Error while parsing \\\"\" + std::string(null_literal, null_prefix_len)\n+                throw DB::ParsingException(\"Error while parsing \\\"\" + std::string(null_literal, null_prefix_len)\n                                     + std::string(istr.position(), std::min(size_t{10}, istr.available())) + \"\\\" as Nullable(\" + nested_data_type->getName()\n                                     + \") at position \" + std::to_string(istr.count()) + \": expected \\\"NULL\\\" or \" + nested_data_type->getName()\n                                     + \", got \\\"\" + std::string(null_literal, buf.count()) + \"\\\", which was deserialized as \\\"\"\ndiff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex 926b790a4bd7..877f62dfb348 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -163,7 +163,7 @@ BlockInputStreamPtr FormatFactory::getInput(\n     // (segmentator + two parsers + reader).\n     bool parallel_parsing = settings.input_format_parallel_parsing && file_segmentation_engine && settings.max_threads >= 4;\n \n-    if (settings.min_chunk_bytes_for_parallel_parsing * settings.max_threads * 2 > settings.max_memory_usage)\n+    if (settings.max_memory_usage && settings.min_chunk_bytes_for_parallel_parsing * settings.max_threads * 2 > settings.max_memory_usage)\n         parallel_parsing = false;\n \n     if (parallel_parsing && name == \"JSONEachRow\")\ndiff --git a/src/Formats/FormatFactory.h b/src/Formats/FormatFactory.h\nindex 0fe6f19f0b79..d78cc2e27405 100644\n--- a/src/Formats/FormatFactory.h\n+++ b/src/Formats/FormatFactory.h\n@@ -54,7 +54,7 @@ class FormatFactory final : private boost::noncopyable\n       * Reads at least min_chunk_bytes and some more until the end of the chunk, depends on the format.\n       * Used in ParallelParsingBlockInputStream.\n       */\n-    using FileSegmentationEngine = std::function<bool(\n+    using FileSegmentationEngine = std::function<std::pair<bool, size_t>(\n         ReadBuffer & buf,\n         DB::Memory<> & memory,\n         size_t min_chunk_bytes)>;\ndiff --git a/src/Formats/JSONEachRowUtils.cpp b/src/Formats/JSONEachRowUtils.cpp\nindex a1d9b4a5fff2..6017f3983c6f 100644\n--- a/src/Formats/JSONEachRowUtils.cpp\n+++ b/src/Formats/JSONEachRowUtils.cpp\n@@ -4,13 +4,14 @@\n namespace DB\n {\n \n-bool fileSegmentationEngineJSONEachRowImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n+std::pair<bool, size_t> fileSegmentationEngineJSONEachRowImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n {\n     skipWhitespaceIfAny(in);\n \n     char * pos = in.position();\n     size_t balance = 0;\n     bool quotes = false;\n+    size_t number_of_rows = 0;\n \n     while (loadAtPosition(in, memory, pos) && (balance || memory.size() + static_cast<size_t>(pos - in.position()) < min_chunk_size))\n     {\n@@ -57,11 +58,14 @@ bool fileSegmentationEngineJSONEachRowImpl(ReadBuffer & in, DB::Memory<> & memor\n                 quotes = true;\n                 ++pos;\n             }\n+\n+            if (balance == 0)\n+                ++number_of_rows;\n         }\n     }\n \n     saveUpToPosition(in, memory, pos);\n-    return loadAtPosition(in, memory, pos);\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n }\n \n }\ndiff --git a/src/Formats/JSONEachRowUtils.h b/src/Formats/JSONEachRowUtils.h\nindex 92679fe3589c..adf85f37a22b 100644\n--- a/src/Formats/JSONEachRowUtils.h\n+++ b/src/Formats/JSONEachRowUtils.h\n@@ -3,6 +3,6 @@\n namespace DB\n {\n \n-bool fileSegmentationEngineJSONEachRowImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size);\n+std::pair<bool, size_t> fileSegmentationEngineJSONEachRowImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size);\n \n }\ndiff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex e290da39535c..97a8d937d39a 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -96,7 +96,7 @@ void NO_INLINE throwAtAssertionFailed(const char * s, ReadBuffer & buf)\n     else\n         out << \" before: \" << quote << String(buf.position(), std::min(SHOW_CHARS_ON_SYNTAX_ERROR, buf.buffer().end() - buf.position()));\n \n-    throw Exception(out.str(), ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n+    throw ParsingException(out.str(), ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED);\n }\n \n \n@@ -503,7 +503,7 @@ static void readAnyQuotedStringInto(Vector & s, ReadBuffer & buf)\n {\n     if (buf.eof() || *buf.position() != quote)\n     {\n-        throw Exception(ErrorCodes::CANNOT_PARSE_QUOTED_STRING,\n+        throw ParsingException(ErrorCodes::CANNOT_PARSE_QUOTED_STRING,\n             \"Cannot parse quoted string: expected opening quote '{}', got '{}'\",\n             std::string{quote}, buf.eof() ? \"EOF\" : std::string{*buf.position()});\n     }\n@@ -538,7 +538,7 @@ static void readAnyQuotedStringInto(Vector & s, ReadBuffer & buf)\n             parseComplexEscapeSequence(s, buf);\n     }\n \n-    throw Exception(\"Cannot parse quoted string: expected closing quote\",\n+    throw ParsingException(\"Cannot parse quoted string: expected closing quote\",\n         ErrorCodes::CANNOT_PARSE_QUOTED_STRING);\n }\n \n@@ -716,7 +716,7 @@ ReturnType readJSONStringInto(Vector & s, ReadBuffer & buf)\n     auto error = [](const char * message [[maybe_unused]], int code [[maybe_unused]])\n     {\n         if constexpr (throw_exception)\n-            throw Exception(message, code);\n+            throw ParsingException(message, code);\n         return ReturnType(false);\n     };\n \n@@ -861,7 +861,7 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n             s_pos[size] = 0;\n \n             if constexpr (throw_exception)\n-                throw Exception(std::string(\"Cannot parse datetime \") + s, ErrorCodes::CANNOT_PARSE_DATETIME);\n+                throw ParsingException(std::string(\"Cannot parse datetime \") + s, ErrorCodes::CANNOT_PARSE_DATETIME);\n             else\n                 return false;\n         }\n@@ -899,7 +899,7 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n         else\n         {\n             if constexpr (throw_exception)\n-                throw Exception(\"Cannot parse datetime\", ErrorCodes::CANNOT_PARSE_DATETIME);\n+                throw ParsingException(\"Cannot parse datetime\", ErrorCodes::CANNOT_PARSE_DATETIME);\n             else\n                 return false;\n         }\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex dbbaae0816f6..fa6b1fc2d8a2 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -300,7 +300,7 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n                 else\n                 {\n                     if constexpr (throw_exception)\n-                        throw Exception(\"Unsigned type must not contain '-' symbol\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                        throw ParsingException(\"Unsigned type must not contain '-' symbol\", ErrorCodes::CANNOT_PARSE_NUMBER);\n                     else\n                         return ReturnType(false);\n                 }\n@@ -648,7 +648,7 @@ inline ReturnType readUUIDTextImpl(UUID & uuid, ReadBuffer & buf)\n \n                 if constexpr (throw_exception)\n                 {\n-                    throw Exception(std::string(\"Cannot parse uuid \") + s, ErrorCodes::CANNOT_PARSE_UUID);\n+                    throw ParsingException(std::string(\"Cannot parse uuid \") + s, ErrorCodes::CANNOT_PARSE_UUID);\n                 }\n                 else\n                 {\n@@ -669,7 +669,7 @@ inline ReturnType readUUIDTextImpl(UUID & uuid, ReadBuffer & buf)\n \n         if constexpr (throw_exception)\n         {\n-            throw Exception(std::string(\"Cannot parse uuid \") + s, ErrorCodes::CANNOT_PARSE_UUID);\n+            throw ParsingException(std::string(\"Cannot parse uuid \") + s, ErrorCodes::CANNOT_PARSE_UUID);\n         }\n         else\n         {\n@@ -824,7 +824,7 @@ inline void readDateTimeText(LocalDateTime & datetime, ReadBuffer & buf)\n     if (19 != size)\n     {\n         s[size] = 0;\n-        throw Exception(std::string(\"Cannot parse datetime \") + s, ErrorCodes::CANNOT_PARSE_DATETIME);\n+        throw ParsingException(std::string(\"Cannot parse datetime \") + s, ErrorCodes::CANNOT_PARSE_DATETIME);\n     }\n \n     datetime.year((s[0] - '0') * 1000 + (s[1] - '0') * 100 + (s[2] - '0') * 10 + (s[3] - '0'));\n@@ -1016,7 +1016,7 @@ void readQuoted(std::vector<T> & x, ReadBuffer & buf)\n             if (*buf.position() == ',')\n                 ++buf.position();\n             else\n-                throw Exception(\"Cannot read array from text\", ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT);\n+                throw ParsingException(\"Cannot read array from text\", ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT);\n         }\n \n         first = false;\n@@ -1039,7 +1039,7 @@ void readDoubleQuoted(std::vector<T> & x, ReadBuffer & buf)\n             if (*buf.position() == ',')\n                 ++buf.position();\n             else\n-                throw Exception(\"Cannot read array from text\", ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT);\n+                throw ParsingException(\"Cannot read array from text\", ErrorCodes::CANNOT_READ_ARRAY_FROM_TEXT);\n         }\n \n         first = false;\ndiff --git a/src/IO/parseDateTimeBestEffort.cpp b/src/IO/parseDateTimeBestEffort.cpp\nindex 8a188d222364..063955cdd1ea 100644\n--- a/src/IO/parseDateTimeBestEffort.cpp\n+++ b/src/IO/parseDateTimeBestEffort.cpp\n@@ -99,7 +99,7 @@ ReturnType parseDateTimeBestEffortImpl(\n     auto on_error = [](const std::string & message [[maybe_unused]], int code [[maybe_unused]])\n     {\n         if constexpr (std::is_same_v<ReturnType, void>)\n-            throw Exception(message, code);\n+            throw ParsingException(message, code);\n         else\n             return false;\n     };\ndiff --git a/src/IO/readDecimalText.h b/src/IO/readDecimalText.h\nindex 727dd67c3893..203d8e3963bb 100644\n--- a/src/IO/readDecimalText.h\n+++ b/src/IO/readDecimalText.h\n@@ -120,7 +120,7 @@ inline bool readDigits(ReadBuffer & buf, T & x, uint32_t & digits, int32_t & exp\n                 if (!tryReadIntText(addition_exp, buf))\n                 {\n                     if constexpr (_throw_on_error)\n-                        throw Exception(\"Cannot parse exponent while reading decimal\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                        throw ParsingException(\"Cannot parse exponent while reading decimal\", ErrorCodes::CANNOT_PARSE_NUMBER);\n                     else\n                         return false;\n                 }\n@@ -133,7 +133,7 @@ inline bool readDigits(ReadBuffer & buf, T & x, uint32_t & digits, int32_t & exp\n                 if (digits_only)\n                 {\n                     if constexpr (_throw_on_error)\n-                        throw Exception(\"Unexpected symbol while reading decimal\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                        throw ParsingException(\"Unexpected symbol while reading decimal\", ErrorCodes::CANNOT_PARSE_NUMBER);\n                     return false;\n                 }\n                 stop = true;\ndiff --git a/src/IO/readFloatText.h b/src/IO/readFloatText.h\nindex 5647d574c625..eac6183e3325 100644\n--- a/src/IO/readFloatText.h\n+++ b/src/IO/readFloatText.h\n@@ -160,7 +160,7 @@ ReturnType readFloatTextPreciseImpl(T & x, ReadBuffer & buf)\n         if (unlikely(res.ec != std::errc()))\n         {\n             if constexpr (throw_exception)\n-                throw Exception(\"Cannot read floating point value\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                throw ParsingException(\"Cannot read floating point value\", ErrorCodes::CANNOT_PARSE_NUMBER);\n             else\n                 return ReturnType(false);\n         }\n@@ -243,7 +243,7 @@ ReturnType readFloatTextPreciseImpl(T & x, ReadBuffer & buf)\n         if (unlikely(res.ec != std::errc()))\n         {\n             if constexpr (throw_exception)\n-                throw Exception(\"Cannot read floating point value\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                throw ParsingException(\"Cannot read floating point value\", ErrorCodes::CANNOT_PARSE_NUMBER);\n             else\n                 return ReturnType(false);\n         }\n@@ -331,7 +331,7 @@ ReturnType readFloatTextFastImpl(T & x, ReadBuffer & in)\n     if (in.eof())\n     {\n         if constexpr (throw_exception)\n-            throw Exception(\"Cannot read floating point value\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+            throw ParsingException(\"Cannot read floating point value\", ErrorCodes::CANNOT_PARSE_NUMBER);\n         else\n             return false;\n     }\n@@ -387,7 +387,7 @@ ReturnType readFloatTextFastImpl(T & x, ReadBuffer & in)\n         if (in.eof())\n         {\n             if constexpr (throw_exception)\n-                throw Exception(\"Cannot read floating point value: nothing after exponent\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                throw ParsingException(\"Cannot read floating point value: nothing after exponent\", ErrorCodes::CANNOT_PARSE_NUMBER);\n             else\n                 return false;\n         }\n@@ -425,7 +425,7 @@ ReturnType readFloatTextFastImpl(T & x, ReadBuffer & in)\n         if (in.eof())\n         {\n             if constexpr (throw_exception)\n-                throw Exception(\"Cannot read floating point value: no digits read\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                throw ParsingException(\"Cannot read floating point value: no digits read\", ErrorCodes::CANNOT_PARSE_NUMBER);\n             else\n                 return false;\n         }\n@@ -436,14 +436,14 @@ ReturnType readFloatTextFastImpl(T & x, ReadBuffer & in)\n             if (in.eof())\n             {\n                 if constexpr (throw_exception)\n-                    throw Exception(\"Cannot read floating point value: nothing after plus sign\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                    throw ParsingException(\"Cannot read floating point value: nothing after plus sign\", ErrorCodes::CANNOT_PARSE_NUMBER);\n                 else\n                     return false;\n             }\n             else if (negative)\n             {\n                 if constexpr (throw_exception)\n-                    throw Exception(\"Cannot read floating point value: plus after minus sign\", ErrorCodes::CANNOT_PARSE_NUMBER);\n+                    throw ParsingException(\"Cannot read floating point value: plus after minus sign\", ErrorCodes::CANNOT_PARSE_NUMBER);\n                 else\n                     return false;\n             }\ndiff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp\nindex a6c66f1cacc4..79090ae2b89c 100644\n--- a/src/Processors/Formats/IRowInputFormat.cpp\n+++ b/src/Processors/Formats/IRowInputFormat.cpp\n@@ -132,6 +132,26 @@ Chunk IRowInputFormat::generate()\n             }\n         }\n     }\n+    catch (ParsingException & e)\n+    {\n+        String verbose_diagnostic;\n+        try\n+        {\n+            verbose_diagnostic = getDiagnosticInfo();\n+        }\n+        catch (const Exception & exception)\n+        {\n+            verbose_diagnostic = \"Cannot get verbose diagnostic: \" + exception.message();\n+        }\n+        catch (...)\n+        {\n+            /// Error while trying to obtain verbose diagnostic. Ok to ignore.\n+        }\n+\n+        e.setLineNumber(total_rows);\n+        e.addMessage(verbose_diagnostic);\n+        throw;\n+    }\n     catch (Exception & e)\n     {\n         if (!isParseError(e.code()))\ndiff --git a/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp b/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\nindex 64a9ce68ef71..4edef1f1365e 100644\n--- a/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\n@@ -48,12 +48,12 @@ Chunk ArrowBlockInputFormat::generate()\n     }\n \n     if (!batch_result.ok())\n-        throw Exception(ErrorCodes::CANNOT_READ_ALL_DATA,\n+        throw ParsingException(ErrorCodes::CANNOT_READ_ALL_DATA,\n             \"Error while reading batch of Arrow data: {}\", batch_result.status().ToString());\n \n     auto table_result = arrow::Table::FromRecordBatches({*batch_result});\n     if (!table_result.ok())\n-        throw Exception(ErrorCodes::CANNOT_READ_ALL_DATA,\n+        throw ParsingException(ErrorCodes::CANNOT_READ_ALL_DATA,\n             \"Error while reading batch of Arrow data: {}\", table_result.status().ToString());\n \n     ++record_batch_current;\ndiff --git a/src/Processors/Formats/Impl/AvroRowInputFormat.cpp b/src/Processors/Formats/Impl/AvroRowInputFormat.cpp\nindex ccfe65bbba32..a8d71790f415 100644\n--- a/src/Processors/Formats/Impl/AvroRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/AvroRowInputFormat.cpp\n@@ -190,7 +190,7 @@ AvroDeserializer::DeserializeFn AvroDeserializer::createDeserializeFn(avro::Node\n                 {\n                     decoder.decodeString(tmp);\n                     if (tmp.length() != 36)\n-                        throw Exception(std::string(\"Cannot parse uuid \") + tmp, ErrorCodes::CANNOT_PARSE_UUID);\n+                        throw ParsingException(std::string(\"Cannot parse uuid \") + tmp, ErrorCodes::CANNOT_PARSE_UUID);\n \n                     UUID uuid;\n                     parseUUID(reinterpret_cast<const UInt8 *>(tmp.data()), std::reverse_iterator<UInt8 *>(reinterpret_cast<UInt8 *>(&uuid) + 16));\ndiff --git a/src/Processors/Formats/Impl/CSVRowInputFormat.cpp b/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\nindex 7bca5f2c5d95..8422f09e364c 100644\n--- a/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/CSVRowInputFormat.cpp\n@@ -424,11 +424,12 @@ void registerInputFormatProcessorCSV(FormatFactory & factory)\n     }\n }\n \n-static bool fileSegmentationEngineCSVImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n+static std::pair<bool, size_t> fileSegmentationEngineCSVImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n {\n     char * pos = in.position();\n     bool quotes = false;\n     bool need_more_data = true;\n+    size_t number_of_rows = 0;\n \n     while (loadAtPosition(in, memory, pos) && need_more_data)\n     {\n@@ -458,6 +459,7 @@ static bool fileSegmentationEngineCSVImpl(ReadBuffer & in, DB::Memory<> & memory\n             }\n             else if (*pos == '\\n')\n             {\n+                ++number_of_rows;\n                 if (memory.size() + static_cast<size_t>(pos - in.position()) >= min_chunk_size)\n                     need_more_data = false;\n                 ++pos;\n@@ -470,13 +472,16 @@ static bool fileSegmentationEngineCSVImpl(ReadBuffer & in, DB::Memory<> & memory\n                     need_more_data = false;\n                 ++pos;\n                 if (loadAtPosition(in, memory, pos) && *pos == '\\n')\n+                {\n                     ++pos;\n+                    ++number_of_rows;\n+                }\n             }\n         }\n     }\n \n     saveUpToPosition(in, memory, pos);\n-    return loadAtPosition(in, memory, pos);\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n }\n \n void registerFileSegmentationEngineCSV(FormatFactory & factory)\ndiff --git a/src/Processors/Formats/Impl/JSONCompactEachRowRowInputFormat.cpp b/src/Processors/Formats/Impl/JSONCompactEachRowRowInputFormat.cpp\nindex f20e764dcfd8..1fc5041b1f3c 100644\n--- a/src/Processors/Formats/Impl/JSONCompactEachRowRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/JSONCompactEachRowRowInputFormat.cpp\n@@ -171,7 +171,7 @@ bool JSONCompactEachRowRowInputFormat::readRow(DB::MutableColumns &columns, DB::\n \n         skipWhitespaceIfAny(in);\n         if (in.eof())\n-            throw Exception(\"Unexpected end of stream while parsing JSONCompactEachRow format\", ErrorCodes::CANNOT_READ_ALL_DATA);\n+            throw ParsingException(\"Unexpected end of stream while parsing JSONCompactEachRow format\", ErrorCodes::CANNOT_READ_ALL_DATA);\n         if (file_column + 1 != column_indexes_for_input_fields.size())\n         {\n             assertChar(',', in);\ndiff --git a/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp b/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\nindex 234839b41f58..8a707ae6554f 100644\n--- a/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp\n@@ -173,7 +173,7 @@ inline bool JSONEachRowRowInputFormat::advanceToNextKey(size_t key_index)\n     skipWhitespaceIfAny(in);\n \n     if (in.eof())\n-        throw Exception(\"Unexpected end of stream while parsing JSONEachRow format\", ErrorCodes::CANNOT_READ_ALL_DATA);\n+        throw ParsingException(\"Unexpected end of stream while parsing JSONEachRow format\", ErrorCodes::CANNOT_READ_ALL_DATA);\n     else if (*in.position() == '}')\n     {\n         ++in.position();\ndiff --git a/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp b/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\nindex a12ca09eec02..8bbf0fc089b8 100644\n--- a/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\n@@ -38,7 +38,7 @@ Chunk ORCBlockInputFormat::generate()\n     std::shared_ptr<arrow::Table> table;\n     arrow::Status read_status = file_reader->Read(&table);\n     if (!read_status.ok())\n-        throw Exception{\"Error while reading ORC data: \" + read_status.ToString(),\n+        throw ParsingException{\"Error while reading ORC data: \" + read_status.ToString(),\n                         ErrorCodes::CANNOT_READ_ALL_DATA};\n \n     ArrowColumnToCHColumn::arrowTableToCHChunk(res, table, header, \"ORC\");\ndiff --git a/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp b/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\nindex 031974dc357c..bb55c71b7cab 100644\n--- a/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\n@@ -47,7 +47,7 @@ Chunk ParquetBlockInputFormat::generate()\n     std::shared_ptr<arrow::Table> table;\n     arrow::Status read_status = file_reader->ReadRowGroup(row_group_current, column_indices, &table);\n     if (!read_status.ok())\n-        throw Exception{\"Error while reading Parquet data: \" + read_status.ToString(),\n+        throw ParsingException{\"Error while reading Parquet data: \" + read_status.ToString(),\n                         ErrorCodes::CANNOT_READ_ALL_DATA};\n \n     ++row_group_current;\ndiff --git a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\nindex c3f9d07b8934..6e14a1dc3c8e 100644\n--- a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n@@ -173,10 +173,11 @@ void registerInputFormatProcessorRegexp(FormatFactory & factory)\n     });\n }\n \n-static bool fileSegmentationEngineRegexpImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n+static std::pair<bool, size_t> fileSegmentationEngineRegexpImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n {\n     char * pos = in.position();\n     bool need_more_data = true;\n+    size_t number_of_rows = 0;\n \n     while (loadAtPosition(in, memory, pos) && need_more_data)\n     {\n@@ -196,12 +197,12 @@ static bool fileSegmentationEngineRegexpImpl(ReadBuffer & in, DB::Memory<> & mem\n             need_more_data = false;\n \n         ++pos;\n-\n+        ++number_of_rows;\n     }\n \n     saveUpToPosition(in, memory, pos);\n \n-    return loadAtPosition(in, memory, pos);\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n }\n \n void registerFileSegmentationEngineRegexp(FormatFactory & factory)\ndiff --git a/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp b/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\nindex abb468741c54..8d769cab346f 100644\n--- a/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TSKVRowInputFormat.cpp\n@@ -89,7 +89,7 @@ static bool readName(ReadBuffer & buf, StringRef & ref, String & tmp)\n         }\n     }\n \n-    throw Exception(\"Unexpected end of stream while reading key name from TSKV format\", ErrorCodes::CANNOT_READ_ALL_DATA);\n+    throw ParsingException(\"Unexpected end of stream while reading key name from TSKV format\", ErrorCodes::CANNOT_READ_ALL_DATA);\n }\n \n \n@@ -157,7 +157,7 @@ bool TSKVRowInputFormat::readRow(MutableColumns & columns, RowReadExtension & ex\n \n             if (in.eof())\n             {\n-                throw Exception(\"Unexpected end of stream after field in TSKV format: \" + name_ref.toString(), ErrorCodes::CANNOT_READ_ALL_DATA);\n+                throw ParsingException(\"Unexpected end of stream after field in TSKV format: \" + name_ref.toString(), ErrorCodes::CANNOT_READ_ALL_DATA);\n             }\n             else if (*in.position() == '\\t')\n             {\ndiff --git a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\nindex 529b70e4e097..69a5e61caf20 100644\n--- a/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp\n@@ -423,10 +423,11 @@ void registerInputFormatProcessorTabSeparated(FormatFactory & factory)\n     }\n }\n \n-static bool fileSegmentationEngineTabSeparatedImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n+static std::pair<bool, size_t> fileSegmentationEngineTabSeparatedImpl(ReadBuffer & in, DB::Memory<> & memory, size_t min_chunk_size)\n {\n     bool need_more_data = true;\n     char * pos = in.position();\n+    size_t number_of_rows = 0;\n \n     while (loadAtPosition(in, memory, pos) && need_more_data)\n     {\n@@ -443,6 +444,9 @@ static bool fileSegmentationEngineTabSeparatedImpl(ReadBuffer & in, DB::Memory<>\n         }\n         else if (*pos == '\\n' || *pos == '\\r')\n         {\n+            if (*pos == '\\n')\n+                ++number_of_rows;\n+\n             if (memory.size() + static_cast<size_t>(pos - in.position()) >= min_chunk_size)\n                 need_more_data = false;\n             ++pos;\n@@ -451,7 +455,7 @@ static bool fileSegmentationEngineTabSeparatedImpl(ReadBuffer & in, DB::Memory<>\n \n     saveUpToPosition(in, memory, pos);\n \n-    return loadAtPosition(in, memory, pos);\n+    return {loadAtPosition(in, memory, pos), number_of_rows};\n }\n \n void registerFileSegmentationEngineTabSeparated(FormatFactory & factory)\ndiff --git a/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp b/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\nindex ecb529a99af7..6023b38e4dee 100644\n--- a/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/TemplateRowInputFormat.cpp\n@@ -489,7 +489,7 @@ void TemplateRowInputFormat::skipToNextDelimiterOrEof(const String & delimiter)\n \n void TemplateRowInputFormat::throwUnexpectedEof()\n {\n-    throw Exception(\"Unexpected EOF while parsing row \" + std::to_string(row_num) + \". \"\n+    throw ParsingException(\"Unexpected EOF while parsing row \" + std::to_string(row_num) + \". \"\n                     \"Maybe last row has wrong format or input doesn't contain specified suffix before EOF.\",\n                     ErrorCodes::CANNOT_READ_ALL_DATA);\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00900_parquet_load.reference b/tests/queries/0_stateless/00900_parquet_load.reference\nindex f93be897da8b..1c8901194868 100644\n--- a/tests/queries/0_stateless/00900_parquet_load.reference\n+++ b/tests/queries/0_stateless/00900_parquet_load.reference\n@@ -52,7 +52,7 @@\n 23.00\n 24.00\n === Try load data from datapage_v2.snappy.parquet\n-Code: 33. DB::Ex---tion: Error while reading Parquet data: IOError: Not yet implemented: Unsupported encoding.: data for INSERT was parsed from stdin\n+Code: 33. DB::ParsingEx---tion: Error while reading Parquet data: IOError: Not yet implemented: Unsupported encoding.: data for INSERT was parsed from stdin\n \n === Try load data from dict-page-offset-zero.parquet\n 1552\ndiff --git a/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.reference b/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.reference\nnew file mode 100644\nindex 000000000000..d86bac9de59a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.reference\n@@ -0,0 +1,1 @@\n+OK\ndiff --git a/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.sh b/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.sh\nnew file mode 100755\nindex 000000000000..caa180b1e0fd\n--- /dev/null\n+++ b/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.sh\n@@ -0,0 +1,14 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. \"$CURDIR\"/../shell_config.sh\n+\n+CLICKHOUSE_CLIENT=$(echo ${CLICKHOUSE_CLIENT} | sed 's/'\"--send_logs_level=${CLICKHOUSE_CLIENT_SERVER_LOGS_LEVEL}\"'/--send_logs_level=none/g')\n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE IF EXISTS check;\"\n+\n+$CLICKHOUSE_CLIENT --query=\"CREATE TABLE check (x UInt64) ENGINE = Memory;\"\n+\n+(seq 1 2000000; echo 'hello'; seq 1 20000000) | $CLICKHOUSE_CLIENT --input_format_parallel_parsing=1 --min_chunk_bytes_for_parallel_parsing=1000 --query=\"INSERT INTO check(x) FORMAT TSV \" 2>&1 | grep -q \"(at row 2000001)\" && echo 'OK' || echo 'FAIL' ||:  \n+\n+$CLICKHOUSE_CLIENT --query=\"DROP TABLE check;\"\n",
  "problem_statement": "Suspected: parallel parsing and row numbers reported in parse errors.\n\n",
  "hints_text": "I remember.",
  "created_at": "2020-11-30T16:45:53Z",
  "modified_files": [
    "contrib/poco",
    "src/Common/CounterInFile.h",
    "src/Common/Exception.cpp",
    "src/Common/Exception.h",
    "src/DataStreams/NativeBlockInputStream.cpp",
    "src/DataStreams/ParallelParsingBlockInputStream.cpp",
    "src/DataStreams/ParallelParsingBlockInputStream.h",
    "src/DataTypes/DataTypeArray.cpp",
    "src/DataTypes/DataTypeNullable.cpp",
    "src/Formats/FormatFactory.cpp",
    "src/Formats/FormatFactory.h",
    "src/Formats/JSONEachRowUtils.cpp",
    "src/Formats/JSONEachRowUtils.h",
    "src/IO/ReadHelpers.cpp",
    "src/IO/ReadHelpers.h",
    "src/IO/parseDateTimeBestEffort.cpp",
    "src/IO/readDecimalText.h",
    "src/IO/readFloatText.h",
    "src/Processors/Formats/IRowInputFormat.cpp",
    "src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/AvroRowInputFormat.cpp",
    "src/Processors/Formats/Impl/CSVRowInputFormat.cpp",
    "src/Processors/Formats/Impl/JSONCompactEachRowRowInputFormat.cpp",
    "src/Processors/Formats/Impl/JSONEachRowRowInputFormat.cpp",
    "src/Processors/Formats/Impl/ORCBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/RegexpRowInputFormat.cpp",
    "src/Processors/Formats/Impl/TSKVRowInputFormat.cpp",
    "src/Processors/Formats/Impl/TabSeparatedRowInputFormat.cpp",
    "src/Processors/Formats/Impl/TemplateRowInputFormat.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00900_parquet_load.reference",
    "b/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.reference",
    "b/tests/queries/0_stateless/01583_parallel_parsing_exception_with_offset.sh"
  ]
}