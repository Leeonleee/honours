{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42025,
  "instance_id": "ClickHouse__ClickHouse-42025",
  "issue_numbers": [
    "41686"
  ],
  "base_commit": "f4f85a069b2a246118e8e454c2efccaf7e7e0dfa",
  "patch": "diff --git a/src/DataTypes/DataTypesDecimal.h b/src/DataTypes/DataTypesDecimal.h\nindex 7bcc65934358..659dc16793da 100644\n--- a/src/DataTypes/DataTypesDecimal.h\n+++ b/src/DataTypes/DataTypesDecimal.h\n@@ -205,10 +205,9 @@ inline ReturnType convertToDecimalImpl(const typename FromDataType::FieldType &\n         if (!std::isfinite(value))\n         {\n             if constexpr (throw_exception)\n-                throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Cannot convert infinity or NaN to decimal\",\n-                                ErrorCodes::DECIMAL_OVERFLOW);\n+                throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"{} convert overflow. Cannot convert infinity or NaN to decimal\", ToDataType::family_name);\n             else\n-                return false;\n+                return ReturnType(false);\n         }\n \n         auto out = value * static_cast<FromFieldType>(DecimalUtils::scaleMultiplier<ToNativeType>(scale));\n@@ -217,8 +216,7 @@ inline ReturnType convertToDecimalImpl(const typename FromDataType::FieldType &\n             out >= static_cast<FromFieldType>(std::numeric_limits<ToNativeType>::max()))\n         {\n             if constexpr (throw_exception)\n-                throw Exception(std::string(ToDataType::family_name) + \" convert overflow. Float is out of Decimal range\",\n-                                ErrorCodes::DECIMAL_OVERFLOW);\n+                throw Exception(ErrorCodes::DECIMAL_OVERFLOW, \"{} convert overflow. Float is out of Decimal range\", ToDataType::family_name);\n             else\n                 return ReturnType(false);\n         }\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 0d24f08f1284..e740380637fc 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -323,13 +323,13 @@ struct ToDateTimeImpl\n {\n     static constexpr auto name = \"toDateTime\";\n \n-    static inline UInt32 execute(UInt16 d, const DateLUTImpl & time_zone)\n+    static UInt32 execute(UInt16 d, const DateLUTImpl & time_zone)\n     {\n         auto date_time = time_zone.fromDayNum(ExtendedDayNum(d));\n         return date_time <= 0xffffffff ? UInt32(date_time) : UInt32(0xffffffff);\n     }\n \n-    static inline UInt32 execute(Int32 d, const DateLUTImpl & time_zone)\n+    static UInt32 execute(Int32 d, const DateLUTImpl & time_zone)\n     {\n         if (d < 0)\n             return 0;\n@@ -338,12 +338,12 @@ struct ToDateTimeImpl\n         return date_time <= 0xffffffff ? date_time : 0xffffffff;\n     }\n \n-    static inline UInt32 execute(UInt32 dt, const DateLUTImpl & /*time_zone*/)\n+    static UInt32 execute(UInt32 dt, const DateLUTImpl & /*time_zone*/)\n     {\n         return dt;\n     }\n \n-    static inline UInt32 execute(Int64 d, const DateLUTImpl & time_zone)\n+    static UInt32 execute(Int64 d, const DateLUTImpl & time_zone)\n     {\n         if (d < 0)\n             return 0;\n@@ -352,7 +352,7 @@ struct ToDateTimeImpl\n         return date_time <= 0xffffffff ? date_time : 0xffffffff;\n     }\n \n-    static inline UInt32 execute(const DecimalUtils::DecimalComponents<DateTime64> & t, const DateLUTImpl & /*time_zone*/)\n+    static UInt32 execute(const DecimalUtils::DecimalComponents<DateTime64> & t, const DateLUTImpl & /*time_zone*/)\n     {\n         if (t.whole < 0 || (t.whole >= 0 && t.fractional < 0))\n             return 0;\n@@ -374,7 +374,7 @@ struct ToDateTransform32Or64\n {\n     static constexpr auto name = \"toDate\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n         // since converting to Date, no need in values outside of default LUT range.\n         if (from < 0)\n@@ -391,7 +391,7 @@ struct ToDateTransform32Or64Signed\n {\n     static constexpr auto name = \"toDate\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n         // TODO: decide narrow or extended range based on FromType\n         /// The function should be monotonic (better for query optimizations), so we saturate instead of overflow.\n@@ -413,7 +413,7 @@ struct ToDateTransform8Or16Signed\n {\n     static constexpr auto name = \"toDate\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n         if (from < 0)\n             return 0;\n@@ -431,7 +431,7 @@ struct ToDate32Transform32Or64\n {\n     static constexpr auto name = \"toDate32\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n         return (from < DATE_LUT_MAX_EXTEND_DAY_NUM)\n             ? from\n@@ -444,7 +444,7 @@ struct ToDate32Transform32Or64Signed\n {\n     static constexpr auto name = \"toDate32\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n         static const Int32 daynum_min_offset = -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch());\n         if (from < daynum_min_offset)\n@@ -460,7 +460,7 @@ struct ToDate32Transform8Or16Signed\n {\n     static constexpr auto name = \"toDate32\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n         return from;\n     }\n@@ -529,7 +529,7 @@ struct ToDateTimeTransform64\n {\n     static constexpr auto name = \"toDateTime\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n         return std::min<Int64>(Int64(from), Int64(0xFFFFFFFF));\n     }\n@@ -540,7 +540,7 @@ struct ToDateTimeTransformSigned\n {\n     static constexpr auto name = \"toDateTime\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl &)\n     {\n         if (from < 0)\n             return 0;\n@@ -553,7 +553,7 @@ struct ToDateTimeTransform64Signed\n {\n     static constexpr auto name = \"toDateTime\";\n \n-    static inline NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & /* time_zone */)\n+    static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & /* time_zone */)\n     {\n         if (from < 0)\n             return 0;\n@@ -581,9 +581,9 @@ template <typename Name> struct ConvertImpl<DataTypeFloat32, DataTypeDateTime, N\n template <typename Name> struct ConvertImpl<DataTypeFloat64, DataTypeDateTime, Name>\n     : DateTimeTransformImpl<DataTypeFloat64, DataTypeDateTime, ToDateTimeTransform64Signed<Float64, UInt32>> {};\n \n-const time_t LUT_MIN_TIME = -2208988800l;           //  1900-01-01 UTC\n+constexpr time_t LUT_MIN_TIME = -2208988800l;           //  1900-01-01 UTC\n \n-const time_t LUT_MAX_TIME = 10413791999l;           // 2299-12-31 UTC\n+constexpr time_t LUT_MAX_TIME = 10413791999l;           // 2299-12-31 UTC\n \n /** Conversion of numeric to DateTime64\n   */\n@@ -599,7 +599,7 @@ struct ToDateTime64TransformUnsigned\n         : scale_multiplier(DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale))\n     {}\n \n-    inline NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n+    NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n     {\n         from = std::min<time_t>(from, LUT_MAX_TIME);\n         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(from, 0, scale_multiplier);\n@@ -616,7 +616,7 @@ struct ToDateTime64TransformSigned\n         : scale_multiplier(DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale))\n     {}\n \n-    inline NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n+    NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n     {\n         from = std::max<time_t>(from, LUT_MIN_TIME);\n         from = std::min<time_t>(from, LUT_MAX_TIME);\n@@ -634,11 +634,10 @@ struct ToDateTime64TransformFloat\n         : scale(scale_)\n     {}\n \n-    inline NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n+    NO_SANITIZE_UNDEFINED DateTime64::NativeType execute(FromType from, const DateLUTImpl &) const\n     {\n-        if (from < 0)\n-            return 0;\n-        from = std::min<FromType>(from, FromType(0xFFFFFFFF));\n+        from = std::max(from, static_cast<FromType>(LUT_MIN_TIME));\n+        from = std::min(from, static_cast<FromType>(LUT_MAX_TIME));\n         return convertToDecimal<FromDataType, DataTypeDateTime64>(from, scale);\n     }\n };\n@@ -672,7 +671,7 @@ struct FromDateTime64Transform\n         : scale_multiplier(DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale))\n     {}\n \n-    inline auto execute(DateTime64::NativeType dt, const DateLUTImpl & time_zone) const\n+    auto execute(DateTime64::NativeType dt, const DateLUTImpl & time_zone) const\n     {\n         const auto c = DecimalUtils::splitWithScaleMultiplier(DateTime64(dt), scale_multiplier);\n         return Transform::execute(static_cast<UInt32>(c.whole), time_zone);\n@@ -694,19 +693,19 @@ struct ToDateTime64Transform\n         : scale_multiplier(DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale))\n     {}\n \n-    inline DateTime64::NativeType execute(UInt16 d, const DateLUTImpl & time_zone) const\n+    DateTime64::NativeType execute(UInt16 d, const DateLUTImpl & time_zone) const\n     {\n         const auto dt = ToDateTimeImpl::execute(d, time_zone);\n         return execute(dt, time_zone);\n     }\n \n-    inline DateTime64::NativeType execute(Int32 d, const DateLUTImpl & time_zone) const\n+    DateTime64::NativeType execute(Int32 d, const DateLUTImpl & time_zone) const\n     {\n         const auto dt = time_zone.fromDayNum(ExtendedDayNum(d));\n         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(dt, 0, scale_multiplier);\n     }\n \n-    inline DateTime64::NativeType execute(UInt32 dt, const DateLUTImpl & /*time_zone*/) const\n+    DateTime64::NativeType execute(UInt32 dt, const DateLUTImpl & /*time_zone*/) const\n     {\n         return DecimalUtils::decimalFromComponentsWithMultiplier<DateTime64>(dt, 0, scale_multiplier);\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01691_DateTime64_clamp.reference b/tests/queries/0_stateless/01691_DateTime64_clamp.reference\nindex 75435aebd678..aee06a3350a4 100644\n--- a/tests/queries/0_stateless/01691_DateTime64_clamp.reference\n+++ b/tests/queries/0_stateless/01691_DateTime64_clamp.reference\n@@ -10,11 +10,11 @@ SELECT CAST('2020-01-01 00:00:00.3' AS DateTime64(0, 'Asia/Istanbul'));\n 2020-01-01 00:00:00\n SELECT toDateTime64(bitShiftLeft(toUInt64(1), 33), 2, 'Asia/Istanbul') FORMAT Null;\n SELECT toTimeZone(toDateTime(-2., 2), 'Asia/Istanbul');\n-1970-01-01 02:00:00.00\n+1970-01-01 01:59:58.00\n SELECT toDateTime64(-2., 2, 'Asia/Istanbul');\n-1970-01-01 02:00:00.00\n+1970-01-01 01:59:58.00\n SELECT toDateTime64(toFloat32(bitShiftLeft(toUInt64(1),33)), 2, 'Asia/Istanbul');\n-2106-02-07 09:28:16.00\n+2242-03-16 15:56:32.00\n SELECT toDateTime64(toFloat64(bitShiftLeft(toUInt64(1),33)), 2, 'Asia/Istanbul') FORMAT Null;\n -- These are outsize of extended range and hence clamped\n SELECT toDateTime64(-1 * bitShiftLeft(toUInt64(1), 35), 2, 'Asia/Istanbul');\ndiff --git a/tests/queries/0_stateless/01734_datetime64_from_float.reference b/tests/queries/0_stateless/01734_datetime64_from_float.reference\nindex 4021b6451aa0..b8baabccd2b2 100644\n--- a/tests/queries/0_stateless/01734_datetime64_from_float.reference\n+++ b/tests/queries/0_stateless/01734_datetime64_from_float.reference\n@@ -1,3 +1,13 @@\n 2005-03-18 03:58:31.222\n 2005-03-18 03:58:31.222\n 2005-03-18 03:58:31.222\n+1970-01-01 00:00:00.000000000\n+1970-01-01 00:00:00.000000000\n+1900-04-15 00:53:20.000000000\n+1900-04-15 00:53:20.000000000\n+1900-01-01 00:00:00.000000000\n+1900-01-01 00:00:00.000000000\n+1900-01-01 00:00:00.000000000\n+1900-01-01 00:00:00.000000000\n+2261-07-15 11:33:20.000000000\n+2261-07-15 11:33:20.000000000\ndiff --git a/tests/queries/0_stateless/01734_datetime64_from_float.sql b/tests/queries/0_stateless/01734_datetime64_from_float.sql\nindex bb837c681e3c..c4290a0cadb8 100644\n--- a/tests/queries/0_stateless/01734_datetime64_from_float.sql\n+++ b/tests/queries/0_stateless/01734_datetime64_from_float.sql\n@@ -1,3 +1,22 @@\n SELECT CAST(1111111111.222 AS DateTime64(3, 'Asia/Istanbul'));\n SELECT toDateTime(1111111111.222, 3, 'Asia/Istanbul');\n SELECT toDateTime64(1111111111.222, 3, 'Asia/Istanbul');\n+\n+SELECT toDateTime64(0.0, 9, 'UTC') ;\n+SELECT toDateTime64(0, 9, 'UTC');\n+\n+SELECT toDateTime64(-2200000000.0, 9, 'UTC'); -- 1900-01-01 < value\n+SELECT toDateTime64(-2200000000, 9, 'UTC');\n+\n+SELECT toDateTime64(-2300000000.0, 9, 'UTC'); -- value < 1900-01-01\n+SELECT toDateTime64(-2300000000, 9, 'UTC');\n+\n+SELECT toDateTime64(-999999999999.0, 9, 'UTC'); -- value << 1900-01-01\n+SELECT toDateTime64(-999999999999, 9, 'UTC');\n+\n+SELECT toDateTime64(9200000000.0, 9, 'UTC'); -- value < 2262-04-11\n+SELECT toDateTime64(9200000000, 9, 'UTC');\n+\n+SELECT toDateTime64(9300000000.0, 9, 'UTC'); -- { serverError 407 } # 2262-04-11 < value\n+SELECT toDateTime64(9300000000, 9, 'UTC'); -- { serverError 407 }\n+\n",
  "problem_statement": "toDateTime64 returns different output with Float type and int type arguments.\n\r\nselect toDateTime64(-86400 ,9,'UTC') ==  1969-12-31 00:00:00.000000000\r\n\r\nselect toDateTime64(-86400.00 ,9,'UTC') ==  1970-01-01 00:00:00.000000000 \r\n\r\n\r\nHowever, I expect both outputs to be same. \r\n\r\nVersion affected : 22.8\n",
  "hints_text": "",
  "created_at": "2022-10-03T13:34:11Z"
}