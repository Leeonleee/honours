{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 69091,
  "instance_id": "ClickHouse__ClickHouse-69091",
  "issue_numbers": [
    "65015"
  ],
  "base_commit": "9e12b6cb4e93efac314d14cc197a80287213a620",
  "patch": "diff --git a/docs/en/sql-reference/statements/create/table.md b/docs/en/sql-reference/statements/create/table.md\nindex 7428e6cd6cab..250cddb09dc7 100644\n--- a/docs/en/sql-reference/statements/create/table.md\n+++ b/docs/en/sql-reference/statements/create/table.md\n@@ -43,6 +43,19 @@ CREATE TABLE [IF NOT EXISTS] [db.]table_name AS [db2.]name2 [ENGINE = engine]\n \n Creates a table with the same structure as another table. You can specify a different engine for the table. If the engine is not specified, the same engine will be used as for the `db2.name2` table.\n \n+### With a Schema and Data Cloned from Another Table \n+\n+``` sql\n+CREATE TABLE [IF NOT EXISTS] [db.]table_name CLONE AS [db2.]name2 [ENGINE = engine]\n+```\n+\n+Creates a table with the same structure as another table. You can specify a different engine for the table. If the engine is not specified, the same engine will be used as for the `db2.name2` table. After the new table is created, all partitions from `db2.name2` are attached to it. In other words, the data of `db2.name2` is cloned into `db.table_name` upon creation. This query is equivalent to the following:\n+\n+``` sql\n+CREATE TABLE [IF NOT EXISTS] [db.]table_name AS [db2.]name2 [ENGINE = engine];\n+ALTER TABLE [db.]table_name ATTACH PARTITION ALL FROM [db2].name2;\n+```\n+\n ### From a Table Function\n \n ``` sql\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex e161c0455b96..adbd2ff6d709 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -5,17 +5,20 @@\n #include <Access/AccessControl.h>\n #include <Access/User.h>\n \n+#include <Core/Settings.h>\n+#include <Interpreters/InterpreterAlterQuery.h>\n+#include <Parsers/ASTPartition.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Parsers/queryToString.h>\n #include <Common/Exception.h>\n-#include <Common/StringUtils.h>\n-#include <Common/escapeForFileName.h>\n-#include <Common/typeid_cast.h>\n #include <Common/Macros.h>\n-#include <Common/randomSeed.h>\n-#include <Common/atomicRename.h>\n #include <Common/PoolId.h>\n+#include <Common/StringUtils.h>\n+#include <Common/atomicRename.h>\n+#include <Common/escapeForFileName.h>\n #include <Common/logger_useful.h>\n-#include <Core/Settings.h>\n-#include <Parsers/ASTSetQuery.h>\n+#include <Common/randomSeed.h>\n+#include <Common/typeid_cast.h>\n \n #include <Core/Defines.h>\n #include <Core/SettingsEnums.h>\n@@ -871,6 +874,43 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::getTableProperti\n         }\n \n         properties.constraints = as_storage_metadata->getConstraints();\n+\n+        if (create.is_clone_as)\n+        {\n+            if (!endsWith(as_storage->getName(), \"MergeTree\"))\n+                throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"Only support CLONE AS from tables of the MergeTree family\");\n+\n+            if (create.storage)\n+            {\n+                if (!endsWith(create.storage->engine->name, \"MergeTree\"))\n+                    throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"Only support CLONE AS with tables of the MergeTree family\");\n+\n+                /// Ensure that as_storage and the new storage has the same primary key, sorting key and partition key\n+                auto query_to_string = [](const IAST * ast) { return ast ? queryToString(*ast) : \"\"; };\n+\n+                const String as_storage_sorting_key_str = query_to_string(as_storage_metadata->getSortingKeyAST().get());\n+                const String as_storage_primary_key_str = query_to_string(as_storage_metadata->getPrimaryKeyAST().get());\n+                const String as_storage_partition_key_str = query_to_string(as_storage_metadata->getPartitionKeyAST().get());\n+\n+                const String storage_sorting_key_str = query_to_string(create.storage->order_by);\n+                const String storage_primary_key_str = query_to_string(create.storage->primary_key);\n+                const String storage_partition_key_str = query_to_string(create.storage->partition_by);\n+\n+                if (as_storage_sorting_key_str != storage_sorting_key_str)\n+                {\n+                    /// It is possible that the storage only has primary key and an empty sorting key, and as_storage has both primary key and sorting key with the same value.\n+                    if (as_storage_sorting_key_str != as_storage_primary_key_str || as_storage_sorting_key_str != storage_primary_key_str)\n+                    {\n+                        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Tables have different ordering\");\n+                    }\n+                }\n+                if (as_storage_partition_key_str != storage_partition_key_str)\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Tables have different partition key\");\n+\n+                if (as_storage_primary_key_str != storage_primary_key_str)\n+                    throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Tables have different primary key\");\n+            }\n+        }\n     }\n     else if (create.select)\n     {\n@@ -1537,37 +1577,47 @@ BlockIO InterpreterCreateQuery::createTable(ASTCreateQuery & create)\n     if (create.select && create.is_materialized_view && mode <= LoadingStrictnessLevel::CREATE)\n         validateMaterializedViewColumnsAndEngine(create, properties, database);\n \n-    bool allow_heavy_populate = getContext()->getSettingsRef()[Setting::database_replicated_allow_heavy_create] && create.is_populate;\n-    if (!allow_heavy_populate && database && database->getEngineName() == \"Replicated\" && (create.select || create.is_populate))\n-    {\n-        bool is_storage_replicated = false;\n-\n-        if (create.storage && isReplicated(*create.storage))\n-            is_storage_replicated = true;\n+    bool is_storage_replicated = false;\n+    if (create.storage && isReplicated(*create.storage))\n+        is_storage_replicated = true;\n \n-        if (create.targets)\n+    if (create.targets)\n+    {\n+        for (const auto & inner_table_engine : create.targets->getInnerEngines())\n         {\n-            for (const auto & inner_table_engine : create.targets->getInnerEngines())\n-            {\n-                if (isReplicated(*inner_table_engine))\n-                    is_storage_replicated = true;\n-            }\n+            if (isReplicated(*inner_table_engine))\n+                is_storage_replicated = true;\n+        }\n         }\n \n-        const bool allow_create_select_for_replicated = (create.isView() && !create.is_populate) || create.is_create_empty || !is_storage_replicated;\n-        if (!allow_create_select_for_replicated)\n+        bool allow_heavy_populate = getContext()->getSettingsRef()[Setting::database_replicated_allow_heavy_create] && create.is_populate;\n+        if (!allow_heavy_populate && database && database->getEngineName() == \"Replicated\" && (create.select || create.is_populate))\n         {\n-            /// POPULATE can be enabled with setting, provide hint in error message\n-            if (create.is_populate)\n+            const bool allow_create_select_for_replicated\n+                = (create.isView() && !create.is_populate) || create.is_create_empty || !is_storage_replicated;\n+            if (!allow_create_select_for_replicated)\n+            {\n+                /// POPULATE can be enabled with setting, provide hint in error message\n+                if (create.is_populate)\n+                    throw Exception(\n+                        ErrorCodes::SUPPORT_IS_DISABLED,\n+                        \"CREATE with POPULATE is not supported with Replicated databases. Consider using separate CREATE and INSERT \"\n+                        \"queries. \"\n+                        \"Alternatively, you can enable 'database_replicated_allow_heavy_create' setting to allow this operation, use with \"\n+                        \"caution\");\n+\n                 throw Exception(\n                     ErrorCodes::SUPPORT_IS_DISABLED,\n-                    \"CREATE with POPULATE is not supported with Replicated databases. Consider using separate CREATE and INSERT queries. \"\n-                    \"Alternatively, you can enable 'database_replicated_allow_heavy_create' setting to allow this operation, use with caution\");\n+                    \"CREATE AS SELECT is not supported with Replicated databases. Consider using separate CREATE and INSERT queries.\");\n+            }\n+        }\n \n+    if (create.is_clone_as)\n+    {\n+        if (database && database->getEngineName() == \"Replicated\")\n             throw Exception(\n                 ErrorCodes::SUPPORT_IS_DISABLED,\n-                \"CREATE AS SELECT is not supported with Replicated databases. Consider using separate CREATE and INSERT queries.\");\n-        }\n+                \"CREATE CLONE AS is not supported with Replicated databases. Consider using separate CREATE and INSERT queries.\");\n     }\n \n     if (database && database->shouldReplicateQuery(getContext(), query_ptr))\n@@ -2009,6 +2059,38 @@ BlockIO InterpreterCreateQuery::fillTableIfNeeded(const ASTCreateQuery & create)\n             .execute();\n     }\n \n+    /// If the query is a CREATE TABLE .. CLONE AS ..., attach all partitions of the source table to the newly created table.\n+    if (create.is_clone_as && !as_table_saved.empty() && !create.is_create_empty && !create.is_ordinary_view && !create.is_live_view\n+        && (!(create.is_materialized_view || create.is_window_view) || create.is_populate))\n+    {\n+        String as_database_name = getContext()->resolveDatabase(create.as_database);\n+\n+        auto partition = std::make_shared<ASTPartition>();\n+        partition->all = true;\n+\n+        auto command = std::make_shared<ASTAlterCommand>();\n+        command->replace = false;\n+        command->type = ASTAlterCommand::REPLACE_PARTITION;\n+        command->partition = command->children.emplace_back(std::move(partition)).get();\n+        command->from_database = as_database_name;\n+        command->from_table = as_table_saved;\n+        command->to_database = create.getDatabase();\n+        command->to_table = create.getTable();\n+\n+        auto command_list = std::make_shared<ASTExpressionList>();\n+        command_list->children.push_back(command);\n+\n+        auto query = std::make_shared<ASTAlterQuery>();\n+        query->database = create.database;\n+        query->table = create.table;\n+        query->uuid = create.uuid;\n+        auto * alter = query->as<ASTAlterQuery>();\n+\n+        alter->alter_object = ASTAlterQuery::AlterObjectType::TABLE;\n+        alter->set(alter->command_list, command_list);\n+        return InterpreterAlterQuery(query, getContext()).execute();\n+    }\n+\n     return {};\n }\n \ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex d7f5b8f97025..66422efe6604 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -425,9 +425,19 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" EMPTY\" << (settings.hilite ? hilite_none : \"\");\n     };\n \n+    bool should_add_clone = is_clone_as;\n+    auto add_clone_if_needed = [&]\n+    {\n+        if (!should_add_clone)\n+            return;\n+        should_add_clone = false;\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" CLONE\" << (settings.hilite ? hilite_none : \"\");\n+    };\n+\n     if (!as_table.empty())\n     {\n         add_empty_if_needed();\n+        add_clone_if_needed();\n         settings.ostr\n             << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\")\n             << (!as_database.empty() ? backQuoteIfNeed(as_database) + \".\" : \"\") << backQuoteIfNeed(as_table);\n@@ -446,6 +456,7 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n         }\n \n         add_empty_if_needed();\n+        add_clone_if_needed();\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS \" << (settings.hilite ? hilite_none : \"\");\n         as_table_function->formatImpl(settings, state, frame);\n     }\ndiff --git a/src/Parsers/ASTCreateQuery.h b/src/Parsers/ASTCreateQuery.h\nindex 6be0fa78903c..813e56eaf02c 100644\n--- a/src/Parsers/ASTCreateQuery.h\n+++ b/src/Parsers/ASTCreateQuery.h\n@@ -100,6 +100,7 @@ class ASTCreateQuery : public ASTQueryWithTableAndOutput, public ASTQueryWithOnC\n     bool is_time_series_table{false}; /// CREATE TABLE ... ENGINE=TimeSeries() ...\n     bool is_populate{false};\n     bool is_create_empty{false};    /// CREATE TABLE ... EMPTY AS SELECT ...\n+    bool is_clone_as{false};    /// CREATE TABLE ... CLONE AS ...\n     bool replace_view{false}; /// CREATE OR REPLACE VIEW\n     bool has_uuid{false}; // CREATE TABLE x UUID '...'\n \ndiff --git a/src/Parsers/CommonParsers.h b/src/Parsers/CommonParsers.h\nindex 46e08cf3f7ed..6fa9e0286333 100644\n--- a/src/Parsers/CommonParsers.h\n+++ b/src/Parsers/CommonParsers.h\n@@ -84,6 +84,7 @@ namespace DB\n     MR_MACROS(CLEAR_INDEX, \"CLEAR INDEX\") \\\n     MR_MACROS(CLEAR_PROJECTION, \"CLEAR PROJECTION\") \\\n     MR_MACROS(CLEAR_STATISTICS, \"CLEAR STATISTICS\") \\\n+    MR_MACROS(CLONE_AS, \"CLONE AS\") \\\n     MR_MACROS(CLUSTER, \"CLUSTER\") \\\n     MR_MACROS(CLUSTERS, \"CLUSTERS\") \\\n     MR_MACROS(CN, \"CN\") \\\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 31dc2075db42..8c5b926ef713 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -675,6 +675,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     bool if_not_exists = false;\n     bool is_temporary = false;\n     bool is_create_empty = false;\n+    bool is_clone_as = false;\n \n     if (s_create.ignore(pos, expected))\n     {\n@@ -759,13 +760,18 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n         return true;\n     };\n \n-    auto need_parse_as_select = [&is_create_empty, &pos, &expected]()\n+    auto need_parse_as_select = [&is_create_empty, &is_clone_as, &pos, &expected]()\n     {\n         if (ParserKeyword{Keyword::EMPTY_AS}.ignore(pos, expected))\n         {\n             is_create_empty = true;\n             return true;\n         }\n+        if (ParserKeyword{Keyword::CLONE_AS}.ignore(pos, expected))\n+        {\n+            is_clone_as = true;\n+            return true;\n+        }\n \n         return ParserKeyword{Keyword::AS}.ignore(pos, expected);\n     };\n@@ -893,6 +899,7 @@ bool ParserCreateTableQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expe\n     query->set(query->select, select);\n     query->set(query->targets, targets);\n     query->is_create_empty = is_create_empty;\n+    query->is_clone_as = is_clone_as;\n \n     if (from_path)\n         query->attach_from_path = from_path->as<ASTLiteral &>().value.safeGet<String>();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03231_create_with_clone_as.reference b/tests/queries/0_stateless/03231_create_with_clone_as.reference\nnew file mode 100644\nindex 000000000000..d2046e19a231\n--- /dev/null\n+++ b/tests/queries/0_stateless/03231_create_with_clone_as.reference\n@@ -0,0 +1,42 @@\n+CREATE TABLE default.foo_memory\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = Memory\n+CREATE TABLE default.foo_file\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = File(\\'TabSeparated\\')\n+CREATE TABLE default.foo_merge_tree\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = MergeTree\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+1\ta\n+2\tb\n+CREATE TABLE default.clone_as_foo_merge_tree\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = MergeTree\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+from foo_merge_tree\n+1\ta\n+2\tb\n+from clone_as_foo_merge_tree\n+1\ta\n+2\tb\n+from clone_as_foo_merge_tree_p_x\n+1\ta\n+2\tb\n+CREATE TABLE default.foo_replacing_merge_tree\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = ReplacingMergeTree\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+1\ta\n+2\tb\n+CREATE TABLE default.clone_as_foo_replacing_merge_tree\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = ReplacingMergeTree\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+from foo_replacing_merge_tree\n+1\ta\n+2\tb\n+from clone_as_foo_replacing_merge_tree\n+1\ta\n+2\tb\n+from clone_as_foo_replacing_merge_tree_p_x\n+1\ta\n+2\tb\n+CREATE TABLE default.foo_replicated_merge_tree\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/test_foo_replicated_merge_tree\\', \\'r1\\')\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+from foo_replicated_merge_tree\n+1\ta\n+2\tb\n+CREATE TABLE default.clone_as_foo_replicated_merge_tree_p_x\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/clone_as_foo_replicated_merge_tree_p_x\\', \\'r1\\')\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+from clone_as_foo_replicated_merge_tree_p_x\n+1\ta\n+2\tb\n+s1\tr1\tOK\t0\t0\n+CREATE TABLE default_1.foo_merge_tree\\n(\\n    `x` Int8,\\n    `y` String\\n)\\nENGINE = MergeTree\\nPRIMARY KEY x\\nORDER BY x\\nSETTINGS index_granularity = 8192\n+from foo_merge_tree\n+1\ta\n+2\tb\n+s1\tr1\tOK\t0\t0\ndiff --git a/tests/queries/0_stateless/03231_create_with_clone_as.sql b/tests/queries/0_stateless/03231_create_with_clone_as.sql\nnew file mode 100644\nindex 000000000000..c5793206e88c\n--- /dev/null\n+++ b/tests/queries/0_stateless/03231_create_with_clone_as.sql\n@@ -0,0 +1,121 @@\n+-- Tags: no-replicated-database\n+-- Tag no-replicated-database: Unsupported type of CREATE TABLE ... CLONE AS ... query\n+\n+DROP TABLE IF EXISTS foo_memory;\n+DROP TABLE IF EXISTS clone_as_foo_memory;\n+DROP TABLE IF EXISTS foo_file;\n+DROP TABLE IF EXISTS clone_as_foo_file;\n+DROP TABLE IF EXISTS foo_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree_p_x;\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree_p_y;\n+DROP TABLE IF EXISTS foo_replacing_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replacing_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replacing_merge_tree_p_x;\n+DROP TABLE IF EXISTS clone_as_foo_replacing_merge_tree_p_y;\n+DROP TABLE IF EXISTS foo_replicated_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replicated_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replicated_merge_tree_p_x;\n+DROP TABLE IF EXISTS clone_as_foo_replicated_merge_tree_p_y;\n+\n+-- CLONE AS with a table of Memory engine\n+CREATE TABLE foo_memory (x Int8, y String) ENGINE=Memory;\n+SHOW CREATE TABLE foo_memory;\n+INSERT INTO foo_memory VALUES (1, 'a'), (2, 'b');\n+\n+CREATE TABLE clone_as_foo_memory CLONE AS foo_memory; -- { serverError SUPPORT_IS_DISABLED } \n+\n+-- CLONE AS with a table of File engine\n+CREATE TABLE foo_file (x Int8, y String) ENGINE=File(TabSeparated);\n+SHOW CREATE TABLE foo_file;\n+INSERT INTO foo_file VALUES (1, 'a'), (2, 'b');\n+\n+CREATE TABLE clone_as_foo_file CLONE AS foo_file; -- { serverError SUPPORT_IS_DISABLED } \n+\n+-- CLONE AS with a table of MergeTree engine\n+CREATE TABLE foo_merge_tree (x Int8, y String) ENGINE=MergeTree PRIMARY KEY x;\n+SHOW CREATE TABLE foo_merge_tree;\n+INSERT INTO foo_merge_tree VALUES (1, 'a'), (2, 'b');\n+SELECT * FROM foo_merge_tree;\n+\n+CREATE TABLE clone_as_foo_merge_tree CLONE AS foo_merge_tree;\n+SHOW CREATE TABLE clone_as_foo_merge_tree;\n+SELECT 'from foo_merge_tree';\n+SELECT * FROM foo_merge_tree;\n+SELECT 'from clone_as_foo_merge_tree';\n+SELECT * FROM clone_as_foo_merge_tree;\n+\n+-- Specify ENGINE\n+CREATE TABLE clone_as_foo_merge_tree_p_x CLONE AS foo_merge_tree ENGINE=MergeTree PRIMARY KEY x;\n+SELECT 'from clone_as_foo_merge_tree_p_x';\n+SELECT * FROM clone_as_foo_merge_tree_p_x;\n+CREATE TABLE clone_as_foo_merge_tree_p_y CLONE AS foo_merge_tree ENGINE=MergeTree PRIMARY KEY y; -- { serverError BAD_ARGUMENTS }\n+\n+-- CLONE AS with a table of ReplacingMergeTree engine\n+CREATE TABLE foo_replacing_merge_tree (x Int8, y String) ENGINE=ReplacingMergeTree PRIMARY KEY x;\n+SHOW CREATE TABLE foo_replacing_merge_tree;\n+INSERT INTO foo_replacing_merge_tree VALUES (1, 'a'), (2, 'b');\n+SELECT * FROM foo_replacing_merge_tree;\n+\n+CREATE TABLE clone_as_foo_replacing_merge_tree CLONE AS foo_replacing_merge_tree;\n+SHOW CREATE TABLE clone_as_foo_replacing_merge_tree;\n+SELECT 'from foo_replacing_merge_tree';\n+SELECT * FROM foo_replacing_merge_tree;\n+SELECT 'from clone_as_foo_replacing_merge_tree';\n+SELECT * FROM clone_as_foo_replacing_merge_tree;\n+\n+-- Specify ENGINE\n+CREATE TABLE clone_as_foo_replacing_merge_tree_p_x CLONE AS foo_replacing_merge_tree ENGINE=ReplacingMergeTree PRIMARY KEY x;\n+SELECT 'from clone_as_foo_replacing_merge_tree_p_x';\n+SELECT * FROM clone_as_foo_replacing_merge_tree_p_x;\n+CREATE TABLE clone_as_foo_replacing_merge_tree_p_y CLONE AS foo_replacing_merge_tree ENGINE=ReplacingMergeTree PRIMARY KEY y; -- { serverError BAD_ARGUMENTS }\n+\n+-- CLONE AS with a table of ReplicatedMergeTree engine\n+CREATE TABLE foo_replicated_merge_tree (x Int8, y String) ENGINE=ReplicatedMergeTree('/clickhouse/tables/{database}/test_foo_replicated_merge_tree', 'r1') PRIMARY KEY x;\n+SHOW CREATE TABLE foo_replicated_merge_tree;\n+INSERT INTO foo_replicated_merge_tree VALUES (1, 'a'), (2, 'b');\n+SELECT 'from foo_replicated_merge_tree';\n+SELECT * FROM foo_replicated_merge_tree;\n+\n+CREATE TABLE clone_as_foo_replicated_merge_tree CLONE AS foo_replicated_merge_tree; -- { serverError REPLICA_ALREADY_EXISTS }\n+\n+-- Specify ENGINE\n+CREATE TABLE clone_as_foo_replicated_merge_tree_p_x CLONE AS foo_replicated_merge_tree ENGINE=ReplicatedMergeTree('/clickhouse/tables/{database}/clone_as_foo_replicated_merge_tree_p_x', 'r1') PRIMARY KEY x;\n+SHOW CREATE TABLE clone_as_foo_replicated_merge_tree_p_x;\n+SELECT 'from clone_as_foo_replicated_merge_tree_p_x';\n+SELECT * FROM foo_replicated_merge_tree;\n+CREATE TABLE clone_as_foo_replicated_merge_tree_p_y CLONE AS foo_replicated_merge_tree ENGINE=ReplicatedMergeTree('/clickhouse/tables/{database}/clone_as_foo_replicated_merge_tree_p_y', 'r1') PRIMARY KEY y; -- { serverError BAD_ARGUMENTS }\n+\n+DROP TABLE IF EXISTS foo_memory;\n+DROP TABLE IF EXISTS clone_as_foo_memory;\n+DROP TABLE IF EXISTS foo_file;\n+DROP TABLE IF EXISTS clone_as_foo_file;\n+DROP TABLE IF EXISTS foo_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree_p_x;\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree_p_y;\n+DROP TABLE IF EXISTS foo_replacing_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replacing_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replacing_merge_tree_p_x;\n+DROP TABLE IF EXISTS clone_as_foo_replacing_merge_tree_p_y;\n+DROP TABLE IF EXISTS foo_replicated_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replicated_merge_tree;\n+DROP TABLE IF EXISTS clone_as_foo_replicated_merge_tree_p_x;\n+DROP TABLE IF EXISTS clone_as_foo_replicated_merge_tree_p_y;\n+\n+-- CLONE AS with a Replicated database\n+DROP DATABASE IF EXISTS {CLICKHOUSE_DATABASE_1:Identifier};\n+\n+CREATE DATABASE {CLICKHOUSE_DATABASE_1:Identifier} ENGINE = Replicated('/test/databases/{database}/test_03231', 's1', 'r1');\n+USE {CLICKHOUSE_DATABASE_1:Identifier};\n+\n+CREATE TABLE foo_merge_tree (x Int8, y String) ENGINE=MergeTree PRIMARY KEY x;\n+SHOW CREATE TABLE foo_merge_tree;\n+INSERT INTO foo_merge_tree VALUES (1, 'a'), (2, 'b');\n+SELECT 'from foo_merge_tree';\n+SELECT * FROM foo_merge_tree;\n+CREATE TABLE clone_as_foo_merge_tree CLONE AS foo_merge_tree; -- { serverError SUPPORT_IS_DISABLED }\n+\n+DROP TABLE IF EXISTS clone_as_foo_merge_tree;\n+DROP TABLE IF EXISTS foo_merge_tree;\n+DROP DATABASE IF EXISTS {CLICKHOUSE_DATABASE_1:Identifier};\n\\ No newline at end of file\n",
  "problem_statement": "CREATE TABLE ... CLONE AS ...\n**Use case**\r\n\r\nInstant forking of tables for a quick backup or testing.\r\n\r\n**Describe the solution you'd like**\r\n\r\nIt should work for tables of the MergeTree family. For other tables, it can throw exceptions.\r\n\r\nIt is similar to creating an empty table and doing ATTACH PARTITION ALL FROM the source, but with better UX, and it could be made atomic with the creation.\r\n\r\n**Additional context**\r\n\r\nWhen this feature is implemented, we can also provide an option to short-cut CREATE ... AS SELECT * and INSERT ... AS SELECT * to work as instant attaching all partitions if it is possible.\r\n\n",
  "hints_text": "",
  "created_at": "2024-08-30T08:32:32Z"
}