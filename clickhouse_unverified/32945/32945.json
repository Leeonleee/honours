{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32945,
  "instance_id": "ClickHouse__ClickHouse-32945",
  "issue_numbers": [
    "30245",
    "32777"
  ],
  "base_commit": "d1d872329c570b432b50c780517a8065dabfe793",
  "patch": "diff --git a/src/Functions/ReplaceRegexpImpl.h b/src/Functions/ReplaceRegexpImpl.h\nindex 4320f47c4249..e6305431d8f0 100644\n--- a/src/Functions/ReplaceRegexpImpl.h\n+++ b/src/Functions/ReplaceRegexpImpl.h\n@@ -32,10 +32,18 @@ template <bool replace_one = false>\n struct ReplaceRegexpImpl\n {\n     /// Sequence of instructions, describing how to get resulting string.\n-    /// Each element is either:\n-    /// - substitution (in that case first element of pair is their number and second element is empty)\n-    /// - string that need to be inserted (in that case, first element of pair is that string and second element is -1)\n-    using Instructions = std::vector<std::pair<int, std::string>>;\n+    struct Instruction\n+    {\n+        /// If not negative - perform substitution of n-th subpattern from the regexp match.\n+        int substitution_num = -1;\n+        /// Otherwise - paste this string verbatim.\n+        std::string literal;\n+\n+        Instruction(int substitution_num_) : substitution_num(substitution_num_) {}\n+        Instruction(std::string literal_) : literal(std::move(literal_)) {}\n+    };\n+\n+    using Instructions = std::vector<Instruction>;\n \n     static const size_t max_captures = 10;\n \n@@ -53,10 +61,10 @@ struct ReplaceRegexpImpl\n                 {\n                     if (!now.empty())\n                     {\n-                        instructions.emplace_back(-1, now);\n+                        instructions.emplace_back(now);\n                         now = \"\";\n                     }\n-                    instructions.emplace_back(s[i + 1] - '0', String());\n+                    instructions.emplace_back(s[i + 1] - '0');\n                 }\n                 else\n                     now += s[i + 1]; /// Escaping\n@@ -68,16 +76,15 @@ struct ReplaceRegexpImpl\n \n         if (!now.empty())\n         {\n-            instructions.emplace_back(-1, now);\n+            instructions.emplace_back(now);\n             now = \"\";\n         }\n \n         for (const auto & it : instructions)\n-            if (it.first >= num_captures)\n-                throw Exception(\n-                    \"Invalid replace instruction in replacement string. Id: \" + toString(it.first) + \", but regexp has only \"\n-                        + toString(num_captures - 1) + \" subpatterns\",\n-                    ErrorCodes::BAD_ARGUMENTS);\n+            if (it.substitution_num >= num_captures)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Invalid replace instruction in replacement string. Id: {}, but regexp has only {} subpatterns\",\n+                    it.substitution_num, num_captures - 1);\n \n         return instructions;\n     }\n@@ -93,56 +100,51 @@ struct ReplaceRegexpImpl\n     {\n         re2_st::StringPiece matches[max_captures];\n \n-        size_t start_pos = 0;\n-        bool is_first_match = true;\n-        bool is_start_pos_added_one = false;\n+        size_t copy_pos = 0;\n+        size_t match_pos = 0;\n \n-        while (start_pos < static_cast<size_t>(input.length()))\n+        while (match_pos < static_cast<size_t>(input.length()))\n         {\n             /// If no more replacements possible for current string\n             bool can_finish_current_string = false;\n \n-            if (searcher.Match(input, start_pos, input.length(), re2_st::RE2::Anchor::UNANCHORED, matches, num_captures))\n+            if (searcher.Match(input, match_pos, input.length(), re2_st::RE2::Anchor::UNANCHORED, matches, num_captures))\n             {\n-                if (is_start_pos_added_one)\n-                    start_pos -= 1;\n-\n                 const auto & match = matches[0];\n-                size_t bytes_to_copy = (match.data() - input.data()) - start_pos;\n+                size_t bytes_to_copy = (match.data() - input.data()) - copy_pos;\n \n                 /// Copy prefix before matched regexp without modification\n                 res_data.resize(res_data.size() + bytes_to_copy);\n-                memcpySmallAllowReadWriteOverflow15(&res_data[res_offset], input.data() + start_pos, bytes_to_copy);\n+                memcpySmallAllowReadWriteOverflow15(&res_data[res_offset], input.data() + copy_pos, bytes_to_copy);\n                 res_offset += bytes_to_copy;\n-                start_pos += bytes_to_copy + match.length();\n-\n-                /// To avoid infinite loop.\n-                if (is_first_match && match.length() == 0 && !replace_one && input.length() > 1)\n-                {\n-                    start_pos += 1;\n-                    is_start_pos_added_one = true;\n-                }\n+                copy_pos += bytes_to_copy + match.length();\n+                match_pos = copy_pos;\n \n                 /// Do substitution instructions\n                 for (const auto & it : instructions)\n                 {\n-                    if (it.first >= 0)\n+                    if (it.substitution_num >= 0)\n                     {\n-                        res_data.resize(res_data.size() + matches[it.first].length());\n-                        memcpy(&res_data[res_offset], matches[it.first].data(), matches[it.first].length());\n-                        res_offset += matches[it.first].length();\n+                        const auto & substitution = matches[it.substitution_num];\n+\n+                        res_data.resize(res_data.size() + substitution.length());\n+                        memcpy(&res_data[res_offset], substitution.data(), substitution.length());\n+                        res_offset += substitution.length();\n                     }\n                     else\n                     {\n-                        res_data.resize(res_data.size() + it.second.size());\n-                        memcpy(&res_data[res_offset], it.second.data(), it.second.size());\n-                        res_offset += it.second.size();\n+                        const auto & literal = it.literal;\n+\n+                        res_data.resize(res_data.size() + literal.size());\n+                        memcpy(&res_data[res_offset], literal.data(), literal.size());\n+                        res_offset += literal.size();\n                     }\n                 }\n \n-                if (replace_one || (!is_first_match && match.length() == 0))\n+                if (replace_one)\n                     can_finish_current_string = true;\n-                is_first_match = false;\n+                else if (match.length() == 0)\n+                    ++match_pos; /// Step one character to avoid infinite loop.\n             }\n             else\n                 can_finish_current_string = true;\n@@ -150,10 +152,11 @@ struct ReplaceRegexpImpl\n             /// If ready, append suffix after match to end of string.\n             if (can_finish_current_string)\n             {\n-                res_data.resize(res_data.size() + input.length() - start_pos);\n-                memcpySmallAllowReadWriteOverflow15(&res_data[res_offset], input.data() + start_pos, input.length() - start_pos);\n-                res_offset += input.length() - start_pos;\n-                start_pos = input.length();\n+                res_data.resize(res_data.size() + input.length() - copy_pos);\n+                memcpySmallAllowReadWriteOverflow15(&res_data[res_offset], input.data() + copy_pos, input.length() - copy_pos);\n+                res_offset += input.length() - copy_pos;\n+                copy_pos = input.length();\n+                match_pos = copy_pos;\n             }\n         }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.reference b/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.reference\nnew file mode 100644\nindex 000000000000..6e269c2a6907\n--- /dev/null\n+++ b/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.reference\n@@ -0,0 +1,1 @@\n+here: Hello, World!\ndiff --git a/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.sql b/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.sql\nnew file mode 100644\nindex 000000000000..a7b52a1c8b63\n--- /dev/null\n+++ b/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.sql\n@@ -0,0 +1,1 @@\n+select replaceRegexpAll('Hello, World!', '^', 'here: ');\ndiff --git a/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.reference b/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.reference\nnew file mode 100644\nindex 000000000000..e8183f05f5db\n--- /dev/null\n+++ b/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.reference\n@@ -0,0 +1,3 @@\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.sql b/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.sql\nnew file mode 100644\nindex 000000000000..6725fa041140\n--- /dev/null\n+++ b/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.sql\n@@ -0,0 +1,3 @@\n+select replaceRegexpAll(',,1,,', '^[,]*|[,]*$', '') x;\n+select replaceRegexpAll(',,1', '^[,]*|[,]*$', '') x;\n+select replaceRegexpAll('1,,', '^[,]*|[,]*$', '') x;\n",
  "problem_statement": "trim incorrect result in case of BOTH\n```sql\r\nSELECT trim(BOTH ', ' FROM '5935,5998,6014, ')||'|' x\r\n\r\nSELECT concat(replaceRegexpAll('5935,5998,6014, ', concat('^[', regexpQuoteMeta(', '), ']*|[', regexpQuoteMeta(', '), ']*$'), ''), '|') AS x\r\n\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 5935,5998,6014, | \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\npsql> SELECT trim(BOTH ', ' FROM '5935,5998,6014, ')||'|'\r\n5935,5998,6014|\r\n\r\n```\r\nhttp://sqlfiddle.com/#!17/0a28f/406\r\n\r\nthough trailing\r\n```sql\r\nSELECT trim(trailing ', ' FROM '5935,5998,6014, ')||'|' x\r\n\u250c\u2500x\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 5935,5998,6014| \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nreplaceRegexpAll has different behavior in 21 vs 20, and doesn't match the documentation\n**Describe the unexpected behaviour**\r\n\r\nI expect\r\n\r\n```sql\r\nselect replaceRegexpAll('Hello, World!', '^', 'here: ')\r\n```\r\n\r\nto produce \r\n\r\n```\r\nhere: Hello, World!\r\n```\r\n\r\nin v20, this is the case, and in v21 the result is:\r\n\r\n```\r\nhere: ello, World!\r\n```\r\n\r\n**How to reproduce**\r\n\r\nRun the above query in clickhouse v20, then in v21\n",
  "hints_text": "Let me have a try\n```sql\r\nselect replaceRegexpAll(',,1,,', '^[,]*|[,]*$', '') x;\r\n\u250c\u2500x\u2500\u2510\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n\r\nselect replaceRegexpAll(',,1', '^[,]*|[,]*$', '') x;\r\n\u250c\u2500x\u2500\u2510\r\n\u2502 1 \u2502\r\n\u2514\u2500\u2500\u2500\u2518\r\n\r\nselect replaceRegexpAll('1,,', '^[,]*|[,]*$', '') x;\r\n\u250c\u2500x\u2500\u2500\u2500\u2510\r\n\u2502 1,, \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\nfixed  in https://github.com/ClickHouse/ClickHouse/pull/30292\n",
  "created_at": "2021-12-19T08:32:59Z",
  "modified_files": [
    "src/Functions/ReplaceRegexpImpl.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.reference",
    "b/tests/queries/0_stateless/02150_replace_regexp_all_empty_match.sql",
    "b/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.reference",
    "b/tests/queries/0_stateless/02151_replace_regexp_all_empty_match_alternative.sql"
  ]
}