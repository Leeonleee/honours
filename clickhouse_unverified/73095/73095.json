{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 73095,
  "instance_id": "ClickHouse__ClickHouse-73095",
  "issue_numbers": [
    "73090"
  ],
  "base_commit": "296677b9efc40cb1226206e2163154489f5e47ed",
  "patch": "diff --git a/src/Databases/Iceberg/RestCatalog.cpp b/src/Databases/Iceberg/RestCatalog.cpp\nindex ab51bb8a4959..078d9960ce48 100644\n--- a/src/Databases/Iceberg/RestCatalog.cpp\n+++ b/src/Databases/Iceberg/RestCatalog.cpp\n@@ -53,7 +53,8 @@ std::pair<std::string, std::string> parseCatalogCredential(const std::string & c\n     /// Parse a string of format \"<client_id>:<client_secret>\"\n     /// into separare strings client_id and client_secret.\n \n-    std::string client_id, client_secret;\n+    std::string client_id;\n+    std::string client_secret;\n     if (!catalog_credential.empty())\n     {\n         auto pos = catalog_credential.find(':');\n@@ -623,7 +624,9 @@ bool RestCatalog::getTableMetadataImpl(\n                 static constexpr auto secret_access_key_str = \"s3.secret-access-key\";\n                 static constexpr auto session_token_str = \"s3.session-token\";\n \n-                std::string access_key_id, secret_access_key, session_token;\n+                std::string access_key_id;\n+                std::string secret_access_key;\n+                std::string session_token;\n                 if (config_object->has(access_key_id_str))\n                     access_key_id = config_object->get(access_key_id_str).extract<String>();\n                 if (config_object->has(secret_access_key_str))\ndiff --git a/src/Functions/currentQueryID.cpp b/src/Functions/currentQueryID.cpp\nnew file mode 100644\nindex 000000000000..1d2e5f9b9542\n--- /dev/null\n+++ b/src/Functions/currentQueryID.cpp\n@@ -0,0 +1,70 @@\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Interpreters/Context.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Core/Field.h>\n+\n+\n+namespace DB\n+{\n+namespace\n+{\n+\n+class FunctionCurrentQueryID : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"currentQueryID\";\n+    static FunctionPtr create(ContextPtr context)\n+    {\n+        return std::make_shared<FunctionCurrentQueryID>(context->getCurrentQueryId());\n+    }\n+\n+    explicit FunctionCurrentQueryID(const String & query_id_) : query_id{query_id_} {}\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override\n+    {\n+        return std::make_shared<DataTypeString>();\n+    }\n+\n+    bool isDeterministic() const override { return false; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        return DataTypeString().createColumnConst(input_rows_count, query_id);\n+    }\n+\n+private:\n+    const String query_id;\n+};\n+\n+}\n+\n+REGISTER_FUNCTION(CurrentQueryID)\n+{\n+    factory.registerFunction<FunctionCurrentQueryID>(FunctionDocumentation{\n+        .description = R\"(\n+Returns current Query id.\n+)\",\n+        .syntax = {\"currentQueryID()\"},\n+        .examples = {{{\n+            \"Example\",\n+            R\"(\n+SELECT currentQueryID();\n+)\",\n+            R\"(\n+\u250c\u2500currentQueryID()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 1280d0e8-1a08-4524-be6e-77975bb68e7d \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+)\"}}},\n+        .categories{\"Other\"},\n+    });\n+    factory.registerAlias(\"current_query_id\", FunctionCurrentQueryID::name, FunctionFactory::Case::Insensitive);\n+}\n+\n+}\ndiff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex 194aa90542e5..71cf4952d06a 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -211,6 +211,20 @@ void readStringUntilCharsInto(Vector & s, ReadBuffer & buf)\n     }\n }\n \n+template <char... chars>\n+void skipStringUntilChars(ReadBuffer & buf)\n+{\n+    while (!buf.eof())\n+    {\n+        char * next_pos = find_first_symbols<chars...>(buf.position(), buf.buffer().end());\n+\n+        buf.position() = next_pos;\n+\n+        if (buf.hasPendingData())\n+            return;\n+    }\n+}\n+\n template <typename Vector>\n void readStringInto(Vector & s, ReadBuffer & buf)\n {\n@@ -245,6 +259,11 @@ void readStringUntilWhitespace(String & s, ReadBuffer & buf)\n     readStringUntilWhitespaceInto(s, buf);\n }\n \n+void skipStringUntilWhitespace(ReadBuffer & buf)\n+{\n+    skipStringUntilChars<' '>(buf);\n+}\n+\n void readStringUntilAmpersand(String & s, ReadBuffer & buf)\n {\n     s.clear();\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 1775fc0673a1..86de497c438f 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -625,6 +625,7 @@ void readEscapedStringUntilEOL(String & s, ReadBuffer & buf);\n \n /// Only 0x20 as whitespace character\n void readStringUntilWhitespace(String & s, ReadBuffer & buf);\n+void skipStringUntilWhitespace(ReadBuffer & buf);\n \n void readStringUntilAmpersand(String & s, ReadBuffer & buf);\n void readStringUntilEquals(String & s, ReadBuffer & buf);\ndiff --git a/src/Server/ProxyV1Handler.cpp b/src/Server/ProxyV1Handler.cpp\nindex d733454b2ab4..139d5259a390 100644\n--- a/src/Server/ProxyV1Handler.cpp\n+++ b/src/Server/ProxyV1Handler.cpp\n@@ -43,6 +43,8 @@ void ProxyV1Handler::run()\n     if (word != \"TCP4\" && word != \"TCP6\" && word != \"UNKNOWN\")\n         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, \"PROXY protocol violation\");\n \n+    bool is_tcp6 = (word == \"TCP6\");\n+\n     if (word == \"UNKNOWN\" && eol)\n         return;\n \n@@ -53,7 +55,10 @@ void ProxyV1Handler::run()\n     if (!readWord(39, word, eol) || eol)\n         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, \"PROXY protocol violation\");\n \n-    stack_data.forwarded_for = std::move(word);\n+    if (is_tcp6)\n+        stack_data.forwarded_for = \"[\" + word + \"]\";\n+    else\n+        stack_data.forwarded_for = std::move(word);\n \n     // read address\n     if (!readWord(39, word, eol) || eol)\n@@ -63,6 +68,8 @@ void ProxyV1Handler::run()\n     if (!readWord(5, word, eol) || eol)\n         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, \"PROXY protocol violation\");\n \n+    stack_data.forwarded_for += \":\" + word;\n+\n     // read port and \"\\r\\n\"\n     if (!readWord(5, word, eol) || !eol)\n         throw Exception(ErrorCodes::CANNOT_PARSE_INPUT_ASSERTION_FAILED, \"PROXY protocol violation\");\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex 6d96905462ab..b6ae2fedaaa9 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -1548,12 +1548,28 @@ bool TCPHandler::receiveProxyHeader()\n             return false;\n         }\n \n+        bool is_tcp6 = ('6' == *limit_in.position());\n+\n         ++limit_in.position();\n         assertChar(' ', limit_in);\n \n         /// Read the first field and ignore other.\n         readStringUntilWhitespace(forwarded_address, limit_in);\n \n+        if (is_tcp6)\n+            forwarded_address = \"[\" + forwarded_address + \"]\";\n+\n+        /// Skip second field (destination address)\n+        assertChar(' ', limit_in);\n+        skipStringUntilWhitespace(limit_in);\n+        assertChar(' ', limit_in);\n+\n+        /// Read source port\n+        String port;\n+        readStringUntilWhitespace(port, limit_in);\n+\n+        forwarded_address += \":\" + port;\n+\n         /// Skip until \\r\\n\n         while (!limit_in.eof() && *limit_in.position() != '\\r')\n             ++limit_in.position();\n@@ -2612,7 +2628,7 @@ Poco::Net::SocketAddress TCPHandler::getClientAddress(const ClientInfo & client_\n     /// Only the last proxy can be trusted (if any).\n     String forwarded_address = client_info.getLastForwardedFor();\n     if (!forwarded_address.empty() && server.config().getBool(\"auth_use_forwarded_address\", false))\n-        return Poco::Net::SocketAddress(forwarded_address, socket().peerAddress().port());\n+        return Poco::Net::SocketAddress(forwarded_address);\n     return socket().peerAddress();\n }\n \n",
  "test_patch": "diff --git a/tests/integration/helpers/proxy1.py b/tests/integration/helpers/proxy1.py\nnew file mode 100644\nindex 000000000000..f6ccc7b677ab\n--- /dev/null\n+++ b/tests/integration/helpers/proxy1.py\n@@ -0,0 +1,82 @@\n+import socket\n+import threading\n+\n+\n+# simple one-connection proxy with PROXY v1 protocol\n+# https://www.haproxy.org/download/1.8/doc/proxy-protocol.txt\n+class Proxy1:\n+    def __init__(self, proxy_string=\"\"):\n+        self._proxy_string = proxy_string\n+\n+    def _run(self):\n+        self._server, addr = self._sock.accept()\n+        self._sock.close()\n+        self._client = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+        self._client.bind((\"\", 0))\n+        self._client.connect(self._address)\n+        self._client.send(\"PROXY \".encode(\"utf-8\"))\n+        if self._proxy_string == \"\":\n+            self._client.send(\n+                (\n+                    \"TCP4 \"\n+                    + addr[0]\n+                    + \" \"\n+                    + self._address[0]\n+                    + \" \"\n+                    + str(addr[1])\n+                    + \" \"\n+                    + str(self._address[1])\n+                ).encode(\"utf-8\")\n+            )\n+        else:\n+            self._client.send(self._proxy_string.encode(\"utf-8\"))\n+        self._client.send(\"\\r\\n\".encode(\"utf-8\"))\n+\n+        def forward(source: socket.socket, destination: socket.socket):\n+            while True:\n+                try:\n+                    data = source.recv(4096)\n+                    if not data:\n+                        destination.shutdown(socket.SHUT_WR)\n+                        source.shutdown(socket.SHUT_RD)\n+                        break\n+                    destination.sendall(data)\n+                except Exception:\n+                    break\n+\n+        client_to_server_thread = threading.Thread(\n+            target=forward, args=(self._client, self._server)\n+        )\n+        server_to_client_thread = threading.Thread(\n+            target=forward, args=(self._server, self._client)\n+        )\n+\n+        client_to_server_thread.start()\n+        server_to_client_thread.start()\n+        client_to_server_thread.join()\n+        server_to_client_thread.join()\n+\n+        self._client.close()\n+        self._server.close()\n+\n+    def start(self, address):\n+        self._address = address\n+        self._sock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n+        self._sock.bind((\"\", 0))\n+        self._sock.listen(1)\n+        self._runner = threading.Thread(target=self._run)\n+        self._runner.start()\n+        return self._sock.getsockname()[1]\n+\n+    def wait(self):\n+        if self._runner:\n+            self._runner.join()\n+\n+    def stop(self):\n+        if self._sock:\n+            self._sock.close()\n+        if self._client:\n+            self._client.close()\n+        if self._server:\n+            self._server.close()\n+        self.wait()\ndiff --git a/tests/integration/test_composable_protocols/configs/config.xml b/tests/integration/test_composable_protocols/configs/config.xml\nindex 7d39363bc621..c292df912cfb 100644\n--- a/tests/integration/test_composable_protocols/configs/config.xml\n+++ b/tests/integration/test_composable_protocols/configs/config.xml\n@@ -83,4 +83,9 @@\n     <!--tcp_port>9010</tcp_port--> \n \n     <validate_tcp_client_information>true</validate_tcp_client_information>\n+\n+    <query_log>\n+        <database>system</database>\n+        <table>query_log</table>\n+    </query_log>\n </clickhouse>\ndiff --git a/tests/integration/test_composable_protocols/test.py b/tests/integration/test_composable_protocols/test.py\nindex 5748f22b8452..cd791c586640 100644\n--- a/tests/integration/test_composable_protocols/test.py\n+++ b/tests/integration/test_composable_protocols/test.py\n@@ -11,6 +11,7 @@\n \n from helpers.client import Client\n from helpers.cluster import ClickHouseCluster\n+from helpers.proxy1 import Proxy1\n \n SCRIPT_DIR = os.path.dirname(os.path.realpath(__file__))\n \n@@ -147,26 +148,54 @@ def test_connections():\n         == \"1\\n\"\n     )\n \n-    data = \"PROXY TCP4 255.255.255.255 255.255.255.255 65535 65535\\r\\n\\0\\021ClickHouse client\\024\\r\\253\\251\\003\\0\\007default\\0\\004\\001\\0\\001\\0\\0\\t0.0.0.0:0\\001\\tmilovidov\\021milovidov-desktop\\21ClickHouse client\\024\\r\\253\\251\\003\\0\\001\\0\\0\\0\\002\\001\\025SELECT 'Hello, world'\\002\\0\\247\\203\\254l\\325\\\\z|\\265\\254F\\275\\333\\206\\342\\024\\202\\024\\0\\0\\0\\n\\0\\0\\0\\240\\01\\0\\02\\377\\377\\377\\377\\0\\0\\0\"\n+\n+# tests when using PROXYv1 with enabled auth_use_forwarded_address that forwarded address is used for authentication and query's source address\n+def test_proxy_1():\n+\n+    # default user\n+    proxy = Proxy1(\"TCP4 123.231.132.213 255.255.255.255 12345 65535\")\n+    proxy_client = Client(\n+        \"localhost\",\n+        proxy.start((server.ip_address, 9100)),\n+        command=cluster.client_bin_path,\n+    )\n+    query_id = proxy_client.query(\"SELECT currentQueryID()\")[:-1]\n+    cluster.instances[\"server\"].query(\"SYSTEM FLUSH LOGS\")\n+    client = Client(server.ip_address, 9000, command=cluster.client_bin_path)\n     assert (\n-        netcat(server.ip_address, 9100, bytearray(data, \"latin-1\")).find(\n-            bytearray(\"Hello, world\", \"latin-1\")\n+        client.query(\n+            f\"SELECT forwarded_for, address, port, initial_address, initial_port FROM system.query_log WHERE query_id = '{query_id}' AND type = 'QueryStart'\"\n         )\n-        >= 0\n+        == \"123.231.132.213:12345\\t::ffff:123.231.132.213\\t12345\\t::ffff:123.231.132.213\\t12345\\n\"\n     )\n \n-    data_user_allowed = \"PROXY TCP4 123.123.123.123 255.255.255.255 65535 65535\\r\\n\\0\\021ClickHouse client\\024\\r\\253\\251\\003\\0\\007user123\\0\\004\\001\\0\\001\\0\\0\\t0.0.0.0:0\\001\\tmilovidov\\021milovidov-desktop\\21ClickHouse client\\024\\r\\253\\251\\003\\0\\001\\0\\0\\0\\002\\001\\025SELECT 'Hello, world'\\002\\0\\247\\203\\254l\\325\\\\z|\\265\\254F\\275\\333\\206\\342\\024\\202\\024\\0\\0\\0\\n\\0\\0\\0\\240\\01\\0\\02\\377\\377\\377\\377\\0\\0\\0\"\n+    # user123 only allowed from 123.123.123.123\n+    proxy = Proxy1(\"TCP4 123.123.123.123 255.255.255.255 12345 65535\")\n+    proxy_client = Client(\n+        \"localhost\",\n+        proxy.start((server.ip_address, 9100)),\n+        command=cluster.client_bin_path,\n+    )\n+    query_id = proxy_client.query(\"SELECT currentQueryID()\", user=\"user123\")[:-1]\n+    cluster.instances[\"server\"].query(\"SYSTEM FLUSH LOGS\")\n+    client = Client(server.ip_address, 9000, command=cluster.client_bin_path)\n     assert (\n-        netcat(server.ip_address, 9100, bytearray(data_user_allowed, \"latin-1\")).find(\n-            bytearray(\"Hello, world\", \"latin-1\")\n+        client.query(\n+            f\"SELECT forwarded_for, address, port, initial_address, initial_port FROM system.query_log WHERE query_id = '{query_id}' AND type = 'QueryStart'\"\n         )\n-        >= 0\n+        == \"123.123.123.123:12345\\t::ffff:123.123.123.123\\t12345\\t::ffff:123.123.123.123\\t12345\\n\"\n     )\n \n-    data_user_restricted = \"PROXY TCP4 127.0.0.1 255.255.255.255 65535 65535\\r\\n\\0\\021ClickHouse client\\024\\r\\253\\251\\003\\0\\007user123\\0\\004\\001\\0\\001\\0\\0\\t0.0.0.0:0\\001\\tmilovidov\\021milovidov-desktop\\21ClickHouse client\\024\\r\\253\\251\\003\\0\\001\\0\\0\\0\\002\\001\\025SELECT 'Hello, world'\\002\\0\\247\\203\\254l\\325\\\\z|\\265\\254F\\275\\333\\206\\342\\024\\202\\024\\0\\0\\0\\n\\0\\0\\0\\240\\01\\0\\02\\377\\377\\377\\377\\0\\0\\0\"\n-    assert (\n-        netcat(\n-            server.ip_address, 9100, bytearray(data_user_restricted, \"latin-1\")\n-        ).find(bytearray(\"Exception: user123: Authentication failed\", \"latin-1\"))\n-        >= 0\n+    # user123 is not allowed from other than 123.123.123.123\n+    proxy = Proxy1(\"TCP4 127.0.0.1 255.255.255.255 12345 65535\")\n+    proxy_client = Client(\n+        \"localhost\",\n+        proxy.start((server.ip_address, 9100)),\n+        command=cluster.client_bin_path,\n     )\n+    try:\n+        proxy_client.query(\"SELECT currentQueryID()\", user=\"user123\")\n+    except Exception as e:\n+        assert str(e).find(\"Exception: user123: Authentication failed\") >= 0\n+    else:\n+        assert False, \"Expected 'Exception: user123: Authentication failed'\"\n",
  "problem_statement": "ClickHouse `initial_port` does not extract the port from proxy protocol header when present\n**Describe the unexpected behaviour**\r\nExpected behavior: when proxy protocol header is present, both initial_address and initial_port are coming from the header, instead of port coming from the direct peer's network port.\r\n\r\n**How to reproduce**\r\n\r\n1. setup a client -> proxy (with proxy protocol header enabled) -> clickhouse cluster\r\n2. make a curl\r\n```\r\ncurl -u default:<pwd> 'https://xxxx.us-east-2.aws.clickhouse.cloud:8443' --data-binary 'SELECT 1' \r\n```\r\nand run tcpdump\r\n\r\n```\r\nsudo tcpdump -i any tcp and host dummy-clickhouse-server.com and port 8443   \r\ntcpdump: data link type LINUX_SLL2                                                            \r\ntcpdump: verbose output suppressed, use -v[v]... for full protocol decode                                                                                                                    listening on any, link-type LINUX_SLL2 (Linux cooked v2), snapshot length 262144 bytes\r\n05:08:04.583655 ens4  Out IP local-machine.internal.64748 > dummy-clickhouse-server.com.8443: Flags [S], seq 2579366380, win 65320, options [mss 1420,sackOK,TS val 1708277899 ecr 0,nop,wscale 7], length 0\r\n05:08:04.638403 ens4  In  IP dummy-clickhouse-server.com.8443 > local-machine.internal.64748: Flags [S.], seq 689054106, ack 2579366381, win 62643, options [mss 1460,sackOK,TS val 293089971 ecr 1708277899,nop,wscale 7], length 0\r\n```\r\n\r\nThe port is `64748`\r\n\r\n3. Check in the ClickHouse query log you will find the `initial_address` is handled correctly by extracting proxy protocol, but not the port. the port will be the middle proxy's port, instead of `64748`.\r\n\r\nSome details https://clickhouse-inc.slack.com/archives/C02F2LML5UG/p1733876820252889\r\n\n",
  "hints_text": "we indeed do not preserve original port and use proxy's instead:\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Server/TCPHandler.cpp#L2615",
  "created_at": "2024-12-11T07:44:00Z",
  "modified_files": [
    "src/Databases/Iceberg/RestCatalog.cpp",
    "b/src/Functions/currentQueryID.cpp",
    "src/IO/ReadHelpers.cpp",
    "src/IO/ReadHelpers.h",
    "src/Server/ProxyV1Handler.cpp",
    "src/Server/TCPHandler.cpp"
  ],
  "modified_test_files": [
    "b/tests/integration/helpers/proxy1.py",
    "tests/integration/test_composable_protocols/configs/config.xml",
    "tests/integration/test_composable_protocols/test.py"
  ]
}