{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64226,
  "instance_id": "ClickHouse__ClickHouse-64226",
  "issue_numbers": [
    "62043"
  ],
  "base_commit": "b6dd8446f59d406ba1ba5f1cdb259f071047b910",
  "patch": "diff --git a/src/Analyzer/ArrayJoinNode.cpp b/src/Analyzer/ArrayJoinNode.cpp\nindex 59389d4f2a86..27d7229d46a1 100644\n--- a/src/Analyzer/ArrayJoinNode.cpp\n+++ b/src/Analyzer/ArrayJoinNode.cpp\n@@ -24,6 +24,9 @@ void ArrayJoinNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_stat\n     buffer << std::string(indent, ' ') << \"ARRAY_JOIN id: \" << format_state.getNodeId(this);\n     buffer << \", is_left: \" << is_left;\n \n+    if (hasAlias())\n+        buffer << \", alias: \" << getAlias();\n+\n     buffer << '\\n' << std::string(indent + 2, ' ') << \"TABLE EXPRESSION\\n\";\n     getTableExpression()->dumpTreeImpl(buffer, format_state, indent + 4);\n \ndiff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex b7c223303eb6..3fca66e6eb86 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -607,6 +607,10 @@ struct ScopeAliases\n     std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;\n     std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;\n \n+    /// Names which are aliases from ARRAY JOIN.\n+    /// This is needed to properly qualify columns from matchers and avoid name collision.\n+    std::unordered_set<std::string> array_join_aliases;\n+\n     std::unordered_map<std::string, QueryTreeNodePtr> & getAliasMap(IdentifierLookupContext lookup_context)\n     {\n         switch (lookup_context)\n@@ -1526,7 +1530,7 @@ class QueryAnalyzer\n \n     ProjectionNames resolveFunction(QueryTreeNodePtr & function_node, IdentifierResolveScope & scope);\n \n-    ProjectionNames resolveExpressionNode(QueryTreeNodePtr & node, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression);\n+    ProjectionNames resolveExpressionNode(QueryTreeNodePtr & node, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression, bool ignore_alias = false);\n \n     ProjectionNames resolveExpressionNodeList(QueryTreeNodePtr & node_list, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression);\n \n@@ -2858,7 +2862,7 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromExpressionArguments(cons\n \n bool QueryAnalyzer::tryBindIdentifierToAliases(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)\n {\n-    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr;\n+    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr || scope.aliases.array_join_aliases.contains(identifier_lookup.identifier.front());\n }\n \n /** Resolve identifier from scope aliases.\n@@ -3889,12 +3893,39 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromArrayJoin(const Identifi\n     {\n         auto & array_join_column_expression_typed = array_join_column_expression->as<ColumnNode &>();\n \n-        if (array_join_column_expression_typed.getAlias() == identifier_lookup.identifier.getFullName())\n+        IdentifierView identifier_view(identifier_lookup.identifier);\n+\n+        if (identifier_view.isCompound() && from_array_join_node.hasAlias() && identifier_view.front() == from_array_join_node.getAlias())\n+            identifier_view.popFirst();\n+\n+        const auto & alias_or_name = array_join_column_expression_typed.hasAlias()\n+            ? array_join_column_expression_typed.getAlias()\n+            : array_join_column_expression_typed.getColumnName();\n+\n+        if (identifier_view.front() == alias_or_name)\n+            identifier_view.popFirst();\n+        else if (identifier_view.getFullName() == alias_or_name)\n+            identifier_view.popFirst(identifier_view.getPartsSize()); /// Clear\n+        else\n+            continue;\n+\n+        if (identifier_view.empty())\n         {\n             auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),\n                 array_join_column_expression_typed.getColumnSource());\n             return array_join_column;\n         }\n+\n+        auto compound_expr = tryResolveIdentifierFromCompoundExpression(\n+            identifier_lookup.identifier,\n+            identifier_lookup.identifier.getPartsSize() - identifier_view.getPartsSize() /*identifier_bind_size*/,\n+            array_join_column_expression,\n+            {} /* compound_expression_source */,\n+            scope,\n+            true /* can_be_not_found */);\n+\n+        if (compound_expr)\n+            return compound_expr;\n     }\n \n     if (!resolved_identifier)\n@@ -6284,7 +6315,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n   *\n   * 4. If node has alias, update its value in scope alias map. Deregister alias from expression_aliases_in_resolve_process.\n   */\n-ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression)\n+ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression, bool ignore_alias)\n {\n     checkStackSize();\n \n@@ -6334,7 +6365,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n       * To support both (SELECT 1) AS expression in projection and (SELECT 1) as subquery in IN, do not use\n       * alias table because in alias table subquery could be evaluated as scalar.\n       */\n-    bool use_alias_table = true;\n+    bool use_alias_table = !ignore_alias;\n     if (is_duplicated_alias || (allow_table_expression && isSubqueryNodeType(node->getNodeType())))\n         use_alias_table = false;\n \n@@ -6634,7 +6665,8 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n     if (is_duplicated_alias)\n         scope.non_cached_identifier_lookups_during_expression_resolve.erase({Identifier{node_alias}, IdentifierLookupContext::EXPRESSION});\n \n-    resolved_expressions.emplace(node, result_projection_names);\n+    if (!ignore_alias)\n+        resolved_expressions.emplace(node, result_projection_names);\n \n     scope.popExpressionNode();\n     bool expression_was_root = scope.expressions_in_resolve_process_stack.empty();\n@@ -7569,22 +7601,25 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n     for (auto & array_join_expression : array_join_nodes)\n     {\n         auto array_join_expression_alias = array_join_expression->getAlias();\n-        if (!array_join_expression_alias.empty() && scope.aliases.alias_name_to_expression_node->contains(array_join_expression_alias))\n-            throw Exception(ErrorCodes::MULTIPLE_EXPRESSIONS_FOR_ALIAS,\n-                \"ARRAY JOIN expression {} with duplicate alias {}. In scope {}\",\n-                array_join_expression->formatASTForErrorMessage(),\n-                array_join_expression_alias,\n-                scope.scope_node->formatASTForErrorMessage());\n \n-        /// Add array join expression into scope\n-        expressions_visitor.visit(array_join_expression);\n+        for (const auto & elem : array_join_nodes)\n+        {\n+            if (elem->hasAlias())\n+                scope.aliases.array_join_aliases.insert(elem->getAlias());\n+\n+            for (auto & child : elem->getChildren())\n+            {\n+                if (child)\n+                    expressions_visitor.visit(child);\n+            }\n+        }\n \n         std::string identifier_full_name;\n \n         if (auto * identifier_node = array_join_expression->as<IdentifierNode>())\n             identifier_full_name = identifier_node->getIdentifier().getFullName();\n \n-        resolveExpressionNode(array_join_expression, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+        resolveExpressionNode(array_join_expression, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/, true /*ignore_alias*/);\n \n         auto process_array_join_expression = [&](QueryTreeNodePtr & expression)\n         {\n@@ -7651,27 +7686,7 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n         }\n     }\n \n-    /** Allow to resolve ARRAY JOIN columns from aliases with types after ARRAY JOIN only after ARRAY JOIN expression list is resolved, because\n-      * during resolution of ARRAY JOIN expression list we must use column type before ARRAY JOIN.\n-      *\n-      * Example: SELECT id, value_element FROM test_table ARRAY JOIN [[1,2,3]] AS value_element, value_element AS value\n-      * It is expected that `value_element AS value` expression inside ARRAY JOIN expression list will be\n-      * resolved as `value_element` expression with type before ARRAY JOIN.\n-      * And it is expected that `value_element` inside projection expression list will be resolved as `value_element` expression\n-      * with type after ARRAY JOIN.\n-      */\n     array_join_nodes = std::move(array_join_column_expressions);\n-    for (auto & array_join_column_expression : array_join_nodes)\n-    {\n-        auto it = scope.aliases.alias_name_to_expression_node->find(array_join_column_expression->getAlias());\n-        if (it != scope.aliases.alias_name_to_expression_node->end())\n-        {\n-            auto & array_join_column_expression_typed = array_join_column_expression->as<ColumnNode &>();\n-            auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),\n-                array_join_column_expression_typed.getColumnSource());\n-            it->second = std::move(array_join_column);\n-        }\n-    }\n }\n \n void QueryAnalyzer::checkDuplicateTableNamesOrAlias(const QueryTreeNodePtr & join_node, QueryTreeNodePtr & left_table_expr, QueryTreeNodePtr & right_table_expr, IdentifierResolveScope & scope)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02374_analyzer_array_join.reference b/tests/queries/0_stateless/02374_analyzer_array_join.reference\nindex 6dd384c7d9cc..ad7750228d62 100644\n--- a/tests/queries/0_stateless/02374_analyzer_array_join.reference\n+++ b/tests/queries/0_stateless/02374_analyzer_array_join.reference\n@@ -45,7 +45,13 @@ SELECT id, value, value_1, value_2 FROM test_table ARRAY JOIN [[1, 2, 3]] AS val\n 0\tValue\t[1,2,3]\t1\n 0\tValue\t[1,2,3]\t2\n 0\tValue\t[1,2,3]\t3\n-SELECT 1 AS value FROM test_table ARRAY JOIN [1,2,3] AS value; -- { serverError 179 }\n+SELECT 1 AS value FROM test_table ARRAY JOIN [1,2,3] AS value;\n+1\n+1\n+1\n+1\n+1\n+1\n SELECT 'ARRAY JOIN with column';\n ARRAY JOIN with column\n SELECT id, value, test_table.value_array FROM test_table ARRAY JOIN value_array;\n@@ -84,7 +90,13 @@ SELECT id, value, value_array AS value_array_array_alias FROM test_table ARRAY J\n 0\tValue\t[4,5,6]\n SELECT '--';\n --\n-SELECT id AS value FROM test_table ARRAY JOIN value_array AS value; -- { serverError 179 }\n+SELECT id AS value FROM test_table ARRAY JOIN value_array AS value;\n+0\n+0\n+0\n+0\n+0\n+0\n SELECT '--';\n --\n SELECT id, value, value_array AS value_array_array_alias, value_array_array_alias_element FROM test_table ARRAY JOIN value_array_array_alias AS value_array_array_alias_element;\n@@ -120,3 +132,7 @@ WHERE NOT ignore(elem)\n GROUP BY\n     sum(ignore(ignore(ignore(1., 1, 36, 8, 8), ignore(52, 37, 37, '03147_parquet_memory_tracking.parquet', 37, 37, toUInt256(37), 37, 37, toNullable(37), 37, 37), 1., 1, 36, 8, 8), emptyArrayToSingle(arrayMap(x -> toString(x), arrayMap(x -> nullIf(x, 2), arrayJoin([[1]])))))) IGNORE NULLS,\n     modulo(toLowCardinality('03147_parquet_memory_tracking.parquet'), number, toLowCardinality(3)); -- { serverError UNKNOWN_IDENTIFIER }\n+[1,2]\t1\n+[1,2]\t2\n+1\n+2\ndiff --git a/tests/queries/0_stateless/02374_analyzer_array_join.sql b/tests/queries/0_stateless/02374_analyzer_array_join.sql\nindex bc4bb6616c16..8c26df1806ed 100644\n--- a/tests/queries/0_stateless/02374_analyzer_array_join.sql\n+++ b/tests/queries/0_stateless/02374_analyzer_array_join.sql\n@@ -33,7 +33,7 @@ SELECT '--';\n \n SELECT id, value, value_1, value_2 FROM test_table ARRAY JOIN [[1, 2, 3]] AS value_1 ARRAY JOIN value_1 AS value_2;\n \n-SELECT 1 AS value FROM test_table ARRAY JOIN [1,2,3] AS value; -- { serverError 179 }\n+SELECT 1 AS value FROM test_table ARRAY JOIN [1,2,3] AS value;\n \n SELECT 'ARRAY JOIN with column';\n \n@@ -53,7 +53,7 @@ SELECT id, value, value_array AS value_array_array_alias FROM test_table ARRAY J\n \n SELECT '--';\n \n-SELECT id AS value FROM test_table ARRAY JOIN value_array AS value; -- { serverError 179 }\n+SELECT id AS value FROM test_table ARRAY JOIN value_array AS value;\n \n SELECT '--';\n \n@@ -80,3 +80,6 @@ GROUP BY\n -- { echoOff }\n \n DROP TABLE test_table;\n+\n+select [1, 2] as arr, x from system.one array join arr as x;\n+select x + 1 as x from (select [number] as arr from numbers(2)) as s array join arr as x;\ndiff --git a/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference b/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference\nindex 5e7728e05908..426cfe35e73f 100644\n--- a/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference\n+++ b/tests/queries/0_stateless/02521_analyzer_array_join_crash.reference\n@@ -1,11 +1,10 @@\n -- { echoOn }\n \n-SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_element, value_element AS value;\n-0\t[1,2,3]\t[1,2,3]\n+SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_element, value_element AS value; -- { serverError UNKNOWN_IDENTIFIER }\n SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_element ARRAY JOIN value_element AS value;\n 0\t[1,2,3]\t1\n 0\t[1,2,3]\t2\n 0\t[1,2,3]\t3\n-SELECT value_element, value FROM test_table ARRAY JOIN [1048577] AS value_element, arrayMap(x -> value_element, ['']) AS value;\n-1048577\t[1048577]\n-SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem, arrayMap(x -> splitByChar(x, elem), ['']) AS unused; -- { serverError 44 }\n+SELECT value_element, value FROM test_table ARRAY JOIN [1048577] AS value_element ARRAY JOIN arrayMap(x -> value_element, ['']) AS value;\n+1048577\t1048577\n+SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem ARRAY JOIN arrayMap(x -> splitByChar(x, elem), ['']) AS unused; -- { serverError ILLEGAL_COLUMN }\ndiff --git a/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql b/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql\nindex 53606e01ab7b..7842d47d757d 100644\n--- a/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql\n+++ b/tests/queries/0_stateless/02521_analyzer_array_join_crash.sql\n@@ -11,13 +11,13 @@ INSERT INTO test_table VALUES (0, 'Value');\n \n -- { echoOn }\n \n-SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_element, value_element AS value;\n+SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_element, value_element AS value; -- { serverError UNKNOWN_IDENTIFIER }\n \n SELECT id, value_element, value FROM test_table ARRAY JOIN [[1,2,3]] AS value_element ARRAY JOIN value_element AS value;\n \n-SELECT value_element, value FROM test_table ARRAY JOIN [1048577] AS value_element, arrayMap(x -> value_element, ['']) AS value;\n+SELECT value_element, value FROM test_table ARRAY JOIN [1048577] AS value_element ARRAY JOIN arrayMap(x -> value_element, ['']) AS value;\n \n-SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem, arrayMap(x -> splitByChar(x, elem), ['']) AS unused; -- { serverError 44 }\n+SELECT arrayFilter(x -> notEmpty(concat(x)), [NULL, NULL]) FROM system.one ARRAY JOIN [1048577] AS elem ARRAY JOIN arrayMap(x -> splitByChar(x, elem), ['']) AS unused; -- { serverError ILLEGAL_COLUMN }\n \n -- { echoOff }\n \ndiff --git a/tests/queries/0_stateless/03156_analyzer_array_join_distributed.reference b/tests/queries/0_stateless/03156_analyzer_array_join_distributed.reference\nnew file mode 100644\nindex 000000000000..b5b2aec9c125\n--- /dev/null\n+++ b/tests/queries/0_stateless/03156_analyzer_array_join_distributed.reference\n@@ -0,0 +1,12 @@\n+Hello\t[1,2]\t1\n+Hello\t[1,2]\t2\n+Hello\t[1,2]\t1\n+Hello\t[1,2]\t1\n+Hello\t[1,2]\t2\n+Hello\t[1,2]\t2\n+Hello\t1\n+Hello\t2\n+Hello\t1\n+Hello\t1\n+Hello\t2\n+Hello\t2\ndiff --git a/tests/queries/0_stateless/03156_analyzer_array_join_distributed.sql b/tests/queries/0_stateless/03156_analyzer_array_join_distributed.sql\nnew file mode 100644\nindex 000000000000..f605a3698221\n--- /dev/null\n+++ b/tests/queries/0_stateless/03156_analyzer_array_join_distributed.sql\n@@ -0,0 +1,10 @@\n+CREATE TABLE arrays_test (s String, arr Array(UInt8)) ENGINE = MergeTree() ORDER BY (s);\n+\n+INSERT INTO arrays_test VALUES ('Hello', [1,2]), ('World', [3,4,5]), ('Goodbye', []);\n+\n+SELECT s, arr, a FROM remote('127.0.0.2', currentDatabase(), arrays_test) ARRAY JOIN arr AS a WHERE a < 3 ORDER BY a;\n+SELECT s, arr, a FROM remote('127.0.0.{1,2}', currentDatabase(), arrays_test) ARRAY JOIN arr AS a WHERE a < 3 ORDER BY a;\n+\n+\n+SELECT s, arr FROM remote('127.0.0.2', currentDatabase(), arrays_test) ARRAY JOIN arr WHERE arr < 3 ORDER BY arr;\n+SELECT s, arr FROM remote('127.0.0.{1,2}', currentDatabase(), arrays_test) ARRAY JOIN arr WHERE arr < 3 ORDER BY arr;\n",
  "problem_statement": "Array join not working on distributed tables\nSince version 24.3.1.2672 it is not possible anymore to join an array on a distributed table.\r\n\r\n\r\n**How to reproduce**\r\n```\r\nCREATE TABLE IF NOT EXISTS default.arrays_test on cluster datascience_cluster\r\n(\r\n    s String,\r\n    arr Array(UInt8)\r\n) \r\nENGINE =ReplicatedMergeTree('/clickhouse-final/tables/{shard}/{database}/{table}/{uuid}', '{replica}')\r\nORDER BY (s)\r\nSETTINGS index_granularity = 8192;\r\n\r\nCREATE TABLE IF NOT EXISTS default.arrays_test_distributed ON CLUSTER datascience_cluster\r\n    AS default.arrays_test\r\nENGINE = Distributed('datascience_cluster', 'default', 'arrays_test', rand());\r\n\r\n\r\nINSERT INTO default.arrays_test_distributed\r\nVALUES ('Hello', [1,2]), ('World', [3,4,5]), ('Goodbye', []);\r\n\r\n\r\nSELECT s, arr, a\r\nFROM default.arrays_test_distributed\r\nARRAY JOIN arr AS a\r\nWHERE a < 3;\r\n```\r\n\r\n* Which ClickHouse server version to use\r\n24.3.1.2672\r\n\r\n**Expected behavior**\r\n\r\nI would expect to get following result, as I get I from the same query on a cluster with version 24.2.2.71\r\n\r\n|s |arr   | a |\r\n|------|------|------|\r\n|Hello   |  [1,2] | 1  |\r\n|Hello   |  [1,2]\t| 2 |\r\n\r\n\r\n**Error message and/or stacktrace**\r\n```\r\nSQL Error [179] [07000]: Code: 179. DB::Exception: ARRAY JOIN expression __table2.arr AS a with duplicate alias a. In scope SELECT __table2.s AS s, __table2.arr AS arr, a AS a FROM default.arrays_test AS __table2 ARRAY JOIN __table2.arr AS a WHERE a < 3. (MULTIPLE_EXPRESSIONS_FOR_ALIAS) (version 24.3.1.2672 (official build))\r\n, server ClickHouseNode [uri=http://xxxxxxxxxxxxxxx:8123/default, options={socket_timeout=300000,use_server_time_zone=false,connect_timeout=50000,use_time_zone=false}]@1152851345\r\n```\r\n\r\n**Additional context**\r\nThe same query is working on an clickhouse instance with version 24.2.2.71\r\n\n",
  "hints_text": "Any news? \nWorks without experimental analyzer \r\n\r\n```\r\nSET allow_experimental_analyzer=0;\r\n```\r\n\r\nhttps://fiddle.clickhouse.com/b0ccd3f6-f0ec-4a38-80d4-9ea10a6f5d73",
  "created_at": "2024-05-22T17:18:20Z"
}