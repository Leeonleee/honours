{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71580,
  "instance_id": "ClickHouse__ClickHouse-71580",
  "issue_numbers": [
    "71559"
  ],
  "base_commit": "8659389265ff63cd80daa48af3b3f5381f0e0926",
  "patch": "diff --git a/src/Functions/bitShiftLeft.cpp b/src/Functions/bitShiftLeft.cpp\nindex 0eb0d82ef0fb..7fd0f7cf631a 100644\n--- a/src/Functions/bitShiftLeft.cpp\n+++ b/src/Functions/bitShiftLeft.cpp\n@@ -25,8 +25,10 @@ struct BitShiftLeftImpl\n     {\n         if constexpr (is_big_int_v<B>)\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"BitShiftLeft is not implemented for big integers as second argument\");\n-        else if (b < 0 || static_cast<UInt256>(b) > 8 * sizeof(A))\n-            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift\");\n+        else if (b < 0)\n+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value\");\n+        else if (static_cast<UInt256>(b) > 8 * sizeof(A))\n+            return static_cast<Result>(0);\n         else if constexpr (is_big_int_v<A>)\n             return static_cast<Result>(a) << static_cast<UInt32>(b);\n         else\n@@ -43,9 +45,10 @@ struct BitShiftLeftImpl\n             const UInt8 word_size = 8 * sizeof(*pos);\n             size_t n = end - pos;\n             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;\n-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)\n-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift\");\n-            if (b == bit_limit)\n+            if (b < 0)\n+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value\");\n+\n+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)\n             {\n                 // insert default value\n                 out_vec.push_back(0);\n@@ -111,9 +114,10 @@ struct BitShiftLeftImpl\n             const UInt8 word_size = 8;\n             size_t n = end - pos;\n             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;\n-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)\n-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift\");\n-            if (b == bit_limit)\n+            if (b < 0)\n+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value\");\n+\n+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)\n             {\n                 // insert default value\n                 out_vec.resize_fill(out_vec.size() + n);\ndiff --git a/src/Functions/bitShiftRight.cpp b/src/Functions/bitShiftRight.cpp\nindex 16032b32f688..19ea7b8c7516 100644\n--- a/src/Functions/bitShiftRight.cpp\n+++ b/src/Functions/bitShiftRight.cpp\n@@ -26,8 +26,10 @@ struct BitShiftRightImpl\n     {\n         if constexpr (is_big_int_v<B>)\n             throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"BitShiftRight is not implemented for big integers as second argument\");\n-        else if (b < 0 || static_cast<UInt256>(b) > 8 * sizeof(A))\n-            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift\");\n+        else if (b < 0)\n+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value\");\n+        else if (static_cast<UInt256>(b) > 8 * sizeof(A))\n+            return static_cast<Result>(0);\n         else if constexpr (is_big_int_v<A>)\n             return static_cast<Result>(a) >> static_cast<UInt32>(b);\n         else\n@@ -59,9 +61,10 @@ struct BitShiftRightImpl\n             const UInt8 word_size = 8;\n             size_t n = end - pos;\n             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;\n-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)\n-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift\");\n-            if (b == bit_limit)\n+            if (b < 0)\n+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value\");\n+\n+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)\n             {\n                 /// insert default value\n                 out_vec.push_back(0);\n@@ -99,9 +102,10 @@ struct BitShiftRightImpl\n             const UInt8 word_size = 8;\n             size_t n = end - pos;\n             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;\n-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)\n-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift\");\n-            if (b == bit_limit)\n+            if (b < 0)\n+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, \"The number of shift positions needs to be a non-negative value\");\n+\n+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)\n             {\n                 // insert default value\n                 out_vec.resize_fill(out_vec.size() + n);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02766_bitshift_with_const_arguments.sql b/tests/queries/0_stateless/02766_bitshift_with_const_arguments.sql\nindex 91e8624057c4..6b2961f05555 100644\n--- a/tests/queries/0_stateless/02766_bitshift_with_const_arguments.sql\n+++ b/tests/queries/0_stateless/02766_bitshift_with_const_arguments.sql\n@@ -10,7 +10,7 @@ DROP TABLE IF EXISTS t1;\n CREATE TABLE t0 (vkey UInt32, pkey UInt32, c0 UInt32) engine = TinyLog;\n CREATE TABLE t1 (vkey UInt32) ENGINE = AggregatingMergeTree  ORDER BY vkey;\n INSERT INTO t0 VALUES (15, 25000, 58);\n-SELECT ref_5.pkey AS c_2_c2392_6 FROM t0 AS ref_5 WHERE 'J[' < multiIf(ref_5.pkey IN ( SELECT 1 ), bitShiftLeft(multiIf(ref_5.c0 > NULL, '1', ')'), 40), NULL); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT ref_5.pkey AS c_2_c2392_6 FROM t0 AS ref_5 WHERE 'J[' < multiIf(ref_5.pkey IN ( SELECT 1 ), bitShiftLeft(multiIf(ref_5.c0 > NULL, '1', ')'), 40), NULL);\n DROP TABLE t0;\n DROP TABLE t1;\n \ndiff --git a/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.reference b/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.reference\nindex 33b8cd6ee260..1fda82a97478 100644\n--- a/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.reference\n+++ b/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.reference\n@@ -1,3 +1,9 @@\n -- bitShiftRight\n+0\n+\n+\\0\\0\\0\\0\\0\\0\\0\\0\n -- bitShiftLeft\n+0\n+\n+\\0\\0\\0\\0\\0\\0\\0\\0\n OK\ndiff --git a/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.sql b/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.sql\nindex aec017536739..340cc1292e46 100644\n--- a/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.sql\n+++ b/tests/queries/0_stateless/03198_bit_shift_throws_error_for_out_of_bounds.sql\n@@ -1,17 +1,17 @@\n SELECT '-- bitShiftRight';\n SELECT bitShiftRight(1, -1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n-SELECT bitShiftRight(toUInt8(1), 8 + 1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT bitShiftRight(toUInt8(1), 8 + 1);\n SELECT bitShiftRight('hola', -1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n-SELECT bitShiftRight('hola', 4 * 8 + 1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT bitShiftRight('hola', 4 * 8 + 1);\n SELECT bitShiftRight(toFixedString('hola', 8), -1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n-SELECT bitShiftRight(toFixedString('hola', 8),  8 * 8 + 1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT bitShiftRight(toFixedString('hola', 8),  8 * 8 + 1);\n \n SELECT '-- bitShiftLeft';\n SELECT bitShiftLeft(1, -1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n-SELECT bitShiftLeft(toUInt8(1), 8 + 1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT bitShiftLeft(toUInt8(1), 8 + 1);\n SELECT bitShiftLeft('hola', -1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n-SELECT bitShiftLeft('hola', 4 * 8 + 1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT bitShiftLeft('hola', 4 * 8 + 1);\n SELECT bitShiftLeft(toFixedString('hola', 8), -1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n-SELECT bitShiftLeft(toFixedString('hola', 8),  8 * 8 + 1); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+SELECT bitShiftLeft(toFixedString('hola', 8),  8 * 8 + 1);\n \n SELECT 'OK';\n\\ No newline at end of file\n",
  "problem_statement": "Disable exception on overflow in bit* related functions\n**Use case**\r\n\r\nAbility to make behavior of function expected for users again.\r\n\r\n**Describe the solution you'd like**\r\n\r\nExamples\r\n\r\nMSSQL\r\n\r\nWhen shift_amount is greater than the number of bits in expression_value, the result returned will be 0.\r\n\r\nSQLite\r\n\r\n```\r\n**Schema (SQLite v3.46)**\r\n\r\n    \r\n\r\n---\r\n\r\n**Query #1**\r\n\r\n    SELECT  1 << 100, 1 << 3\r\n\r\n| 1 << 100 | 1 << 3 |\r\n| -------- | ------ |\r\n| 0        | 8      |\r\n\r\n---\r\n```\r\n\r\n\r\nMySQL\r\n\r\nBits shifted off the end of the value are lost without warning, regardless of the argument type. In particular, if the shift count is greater or equal to the number of bits in the bit argument, all bits in the result are 0.\r\n\r\n```\r\n**Schema (MySQL v9)**\r\n\r\n    \r\n\r\n---\r\n\r\n**Query #1**\r\n\r\n    SELECT 1  << 300, 1 << 3\r\n\r\n| 1  << 300 | 1 << 3 |\r\n| --------- | ------ |\r\n| 0         | 8      |\r\n\r\n---\r\n```\r\n\r\n\r\nPostgreSQL\r\n\r\n```\r\n**Schema (PostgreSQL v17)**\r\n\r\n    \r\n\r\n---\r\n\r\n**Query #1**\r\n\r\n    SELECT 1::smallint  << 110, B'10001' << 3\r\n\r\n| ?column? | ?column? |\r\n| -------- | -------- |\r\n| 16384    | 01000    |\r\n\r\n---\r\n```\r\n\r\nPowerBI\r\n\r\nIf absolute value of Shift_Amount is larger than 64, there will be no error but will result in overflow/underflow.\r\n\r\n\r\n**Additional context**\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/issues/65516\r\nhttps://github.com/ClickHouse/ClickHouse/pull/65838\n",
  "hints_text": "No need for a setting.\r\nJust make this change.\nAfter some discussion, we agreed that returning 0 instead of throwing an exception seems like a good compromise. So, we'll be more like MySQL and SQLite rather than PostgreSQL",
  "created_at": "2024-11-07T12:38:23Z"
}