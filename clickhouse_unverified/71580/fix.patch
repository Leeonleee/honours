diff --git a/src/Functions/bitShiftLeft.cpp b/src/Functions/bitShiftLeft.cpp
index 0eb0d82ef0fb..7fd0f7cf631a 100644
--- a/src/Functions/bitShiftLeft.cpp
+++ b/src/Functions/bitShiftLeft.cpp
@@ -25,8 +25,10 @@ struct BitShiftLeftImpl
     {
         if constexpr (is_big_int_v<B>)
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftLeft is not implemented for big integers as second argument");
-        else if (b < 0 || static_cast<UInt256>(b) > 8 * sizeof(A))
-            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
+        else if (b < 0)
+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value");
+        else if (static_cast<UInt256>(b) > 8 * sizeof(A))
+            return static_cast<Result>(0);
         else if constexpr (is_big_int_v<A>)
             return static_cast<Result>(a) << static_cast<UInt32>(b);
         else
@@ -43,9 +45,10 @@ struct BitShiftLeftImpl
             const UInt8 word_size = 8 * sizeof(*pos);
             size_t n = end - pos;
             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
-            if (b == bit_limit)
+            if (b < 0)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value");
+
+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)
             {
                 // insert default value
                 out_vec.push_back(0);
@@ -111,9 +114,10 @@ struct BitShiftLeftImpl
             const UInt8 word_size = 8;
             size_t n = end - pos;
             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
-            if (b == bit_limit)
+            if (b < 0)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value");
+
+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)
             {
                 // insert default value
                 out_vec.resize_fill(out_vec.size() + n);
diff --git a/src/Functions/bitShiftRight.cpp b/src/Functions/bitShiftRight.cpp
index 16032b32f688..19ea7b8c7516 100644
--- a/src/Functions/bitShiftRight.cpp
+++ b/src/Functions/bitShiftRight.cpp
@@ -26,8 +26,10 @@ struct BitShiftRightImpl
     {
         if constexpr (is_big_int_v<B>)
             throw Exception(ErrorCodes::NOT_IMPLEMENTED, "BitShiftRight is not implemented for big integers as second argument");
-        else if (b < 0 || static_cast<UInt256>(b) > 8 * sizeof(A))
-            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
+        else if (b < 0)
+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value");
+        else if (static_cast<UInt256>(b) > 8 * sizeof(A))
+            return static_cast<Result>(0);
         else if constexpr (is_big_int_v<A>)
             return static_cast<Result>(a) >> static_cast<UInt32>(b);
         else
@@ -59,9 +61,10 @@ struct BitShiftRightImpl
             const UInt8 word_size = 8;
             size_t n = end - pos;
             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
-            if (b == bit_limit)
+            if (b < 0)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value");
+
+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)
             {
                 /// insert default value
                 out_vec.push_back(0);
@@ -99,9 +102,10 @@ struct BitShiftRightImpl
             const UInt8 word_size = 8;
             size_t n = end - pos;
             const UInt128 bit_limit = static_cast<UInt128>(word_size) * n;
-            if (b < 0 || static_cast<decltype(bit_limit)>(b) > bit_limit)
-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value and less or equal to the bit width of the value to shift");
-            if (b == bit_limit)
+            if (b < 0)
+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "The number of shift positions needs to be a non-negative value");
+
+            if (b == bit_limit || static_cast<decltype(bit_limit)>(b) > bit_limit)
             {
                 // insert default value
                 out_vec.resize_fill(out_vec.size() + n);
