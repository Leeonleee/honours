{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 18579,
  "instance_id": "ClickHouse__ClickHouse-18579",
  "issue_numbers": [
    "17540"
  ],
  "base_commit": "c8c4de061745c9ca4031231c99eae98106d829f8",
  "patch": "diff --git a/docs/en/sql-reference/functions/other-functions.md b/docs/en/sql-reference/functions/other-functions.md\nindex 982b7d215e73..f42cbef4ca88 100644\n--- a/docs/en/sql-reference/functions/other-functions.md\n+++ b/docs/en/sql-reference/functions/other-functions.md\n@@ -182,6 +182,14 @@ If `NULL` is passed to the function as input, then it returns the `Nullable(Noth\n Gets the size of the block.\n In ClickHouse, queries are always run on blocks (sets of column parts). This function allows getting the size of the block that you called it for.\n \n+## byteSize(...) {#function-bytesize}\n+\n+Get an estimate of uncompressed byte size of its arguments in memory.\n+E.g. for UInt32 argument it will return constant 4, for String argument - the string length + 9 (terminating zero + length).\n+The function can take multiple arguments. The typical application is byteSize(*).\n+\n+Use case: Suppose you have a service that stores data for multiple clients in one table. Users will pay per data volume. So, you need to implement accounting of users data volume. The function will allow to calculate the data size on per-row basis.\n+\n ## materialize(x) {#materializex}\n \n Turns a constant into a full column containing just one value.\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex b51722ed96d5..ad3ed25f266c 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -528,6 +528,7 @@ struct WhichDataType\n     constexpr bool isNullable() const { return idx == TypeIndex::Nullable; }\n     constexpr bool isFunction() const { return idx == TypeIndex::Function; }\n     constexpr bool isAggregateFunction() const { return idx == TypeIndex::AggregateFunction; }\n+    constexpr bool isLowCardinality() const { return idx == TypeIndex::LowCardinality; }\n \n     constexpr bool IsBigIntOrDeimal() const { return isInt128() || isInt256() || isUInt256() || isDecimal256(); }\n };\ndiff --git a/src/Functions/byteSize.cpp b/src/Functions/byteSize.cpp\nnew file mode 100644\nindex 000000000000..8eb83e02f64d\n--- /dev/null\n+++ b/src/Functions/byteSize.cpp\n@@ -0,0 +1,321 @@\n+#include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnLowCardinality.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnTuple.h>\n+#include <Columns/ColumnVector.h>\n+#include <Common/UInt128.h>\n+#include <Core/Types.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes//DataTypeArray.h>\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypeEnum.h>\n+#include <DataTypes/DataTypeFixedString.h>\n+#include <DataTypes/DataTypeInterval.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypeUUID.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunctionImpl.h>\n+\n+#include <ext/range.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+namespace\n+{\n+\n+struct ResultHolder\n+{\n+    ColumnUInt64::Container & vec_res;\n+    bool is_first_argument;\n+\n+    ResultHolder(ColumnUInt64::Container & vec_res_, bool is_first_argument_)\n+        : vec_res(vec_res_), is_first_argument(is_first_argument_) {}\n+\n+    void set(UInt64 byte_size)\n+    {\n+        size_t vec_size = vec_res.size();\n+        if (is_first_argument)\n+        {\n+            for (size_t i = 0; i < vec_size; ++i)\n+                vec_res[i] = byte_size;\n+        }\n+        else\n+        {\n+            for (size_t i = 0; i < vec_size; ++i)\n+                vec_res[i] += byte_size;\n+        }\n+    }\n+\n+    void set(size_t idx, UInt64 byte_size)\n+    {\n+        if (is_first_argument)\n+            vec_res[idx] = byte_size;\n+        else\n+            vec_res[idx] += byte_size;\n+    }\n+\n+    size_t size() const\n+    {\n+        return vec_res.size();\n+    }\n+};\n+\n+/** byteSize() - get the columns size in number of bytes.\n+  */\n+class FunctionByteSize : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"byteSize\";\n+    static FunctionPtr create(const Context &)\n+    {\n+        return std::make_shared<FunctionByteSize>();\n+    }\n+\n+    String getName() const override { return name; }\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & /*arguments*/) const override\n+    {\n+        return std::make_shared<DataTypeUInt64>();\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        auto result_col = ColumnUInt64::create(input_rows_count);\n+        auto & vec_res = result_col->getData();\n+        size_t size = arguments.size();\n+        for (size_t i = 0; i < size; ++i)\n+        {\n+            const IColumn * column = arguments[i].column.get();\n+            const IDataType * data_type = arguments[i].type.get();\n+            ResultHolder res(vec_res, i == 0);\n+            byteSizeOne(data_type, column, res);\n+        }\n+        return result_col;\n+    }\n+\n+private:\n+    static void byteSizeOne(const IDataType * data_type, const IColumn * column, ResultHolder & res)\n+    {\n+        UInt64 byte_size = 0;\n+        if (byteSizeByDataType(data_type, byte_size))\n+        {\n+            res.set(byte_size);\n+        }\n+        else if (byteSizeByColumn(data_type, column, res))\n+            ;\n+        else\n+            throw Exception(\"byteSize for \\\"\" + data_type->getName() + \"\\\" is not supported.\",\n+                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n+\n+    static bool byteSizeByDataType(const IDataType * data_type, UInt64 & byte_size)\n+    {\n+        if (data_type->isValueUnambiguouslyRepresentedInFixedSizeContiguousMemoryRegion())\n+        {\n+            byte_size = data_type->getSizeOfValueInMemory();\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    static bool byteSizeByColumn(const IDataType * data_type, const IColumn * column, ResultHolder & res)\n+    {\n+        WhichDataType which(data_type);\n+        size_t res_size = res.size();\n+\n+        UInt64 byte_size = 0;\n+        if (byteSizeForConstColumn(data_type, column, byte_size))\n+        {\n+            res.set(byte_size);\n+            return true;\n+        }\n+        else if (which.isString()) // TypeIndex::String\n+        {\n+            const ColumnString * col_str = checkAndGetColumn<ColumnString>(column);\n+            const auto & offsets = col_str->getOffsets();\n+            ColumnString::Offset prev_offset = 0;\n+            for (size_t i = 0; i < res_size; ++i)\n+            {\n+                ColumnString::Offset current_offset = offsets[i]; // to ensure offsets[i] not aliased with vec_res[i].\n+                res.set(i, current_offset - prev_offset + sizeof(offsets[0]));\n+                prev_offset = current_offset;\n+            }\n+            return true;\n+        }\n+        else if (which.isArray()) // TypeIndex::Array\n+        {\n+            const ColumnArray * col_arr = checkAndGetColumn<ColumnArray>(column);\n+            const DataTypeArray * type_arr = checkAndGetDataType<DataTypeArray>(data_type);\n+            return byteSizeForArrayByDataType(type_arr, col_arr, res)\n+                   || byteSizeForArray(type_arr, col_arr, res);\n+        }\n+        else if (which.isNullable()) // TypeIndex::Nullable\n+        {\n+            const ColumnNullable * col_null = checkAndGetColumn<ColumnNullable>(column);\n+            const DataTypeNullable * type_null = checkAndGetDataType<DataTypeNullable>(data_type);\n+            for (size_t i = 0; i < res_size; ++i)\n+            {\n+                byte_size = sizeof(bool);\n+                if (!col_null->isNullAt(i))\n+                    byte_size += byteSizeForNestedItem(type_null->getNestedType().get(), &col_null->getNestedColumn(), i);\n+                res.set(i, byte_size);\n+            }\n+            return true;\n+        }\n+        else if (which.isTuple()) // TypeIndex::Tuple\n+        {\n+            const ColumnTuple * col_tuple = checkAndGetColumn<ColumnTuple>(column);\n+            const DataTypeTuple * type_tuple = checkAndGetDataType<DataTypeTuple>(data_type);\n+\n+            size_t tuple_size = col_tuple->tupleSize();\n+            for (size_t col_idx = 0; col_idx < tuple_size; ++col_idx)\n+            {\n+                const IColumn * type_nested = col_tuple->getColumnPtr(col_idx).get();\n+                const IDataType * col_nested = type_tuple->getElements()[col_idx].get();\n+                ResultHolder res_nested(res.vec_res, res.is_first_argument && col_idx == 0);\n+                byteSizeOne(col_nested, type_nested, res_nested);\n+            }\n+            return true;\n+        }\n+        else if (which.isLowCardinality()) // TypeIndex::LowCardinality\n+        {\n+            const ColumnLowCardinality * col_low = checkAndGetColumn<ColumnLowCardinality>(column);\n+            byte_size = col_low->getSizeOfIndexType();\n+            res.set(byte_size);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    static bool byteSizeForConstColumn(const IDataType * data_type, const IColumn * column, UInt64 & byte_size)\n+    {\n+        if (const ColumnConst * col_const = checkAndGetColumn<ColumnConst>(column))\n+        {\n+            const IColumn * col_data = &col_const->getDataColumn();\n+            byte_size = byteSizeForNestedItem(data_type, col_data, 0);\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    static bool byteSizeForArrayByDataType(const DataTypeArray * data_type, const ColumnArray * column, ResultHolder & res)\n+    {\n+        UInt64 byte_size = 0;\n+        if (byteSizeByDataType(data_type->getNestedType().get(), byte_size))\n+        {\n+            size_t res_size = res.size();\n+            const auto & offsets = column->getOffsets();\n+            ColumnArray::Offset prev_offset = 0;\n+            for (size_t i = 0; i < res_size; ++i)\n+            {\n+                size_t array_size = offsets[i] - prev_offset;\n+                res.set(i, array_size * byte_size + sizeof(offsets[0]));\n+                prev_offset += array_size;\n+            }\n+            return true;\n+        }\n+        return false;\n+    }\n+\n+    static UInt64 byteSizeForNestedItem(const IDataType * data_type, const IColumn * column, size_t idx)\n+    {\n+        WhichDataType which(data_type);\n+        UInt64 byte_size = 0;\n+\n+        if (byteSizeByDataType(data_type, byte_size))\n+            return byte_size;\n+        else if (which.isString())\n+        {\n+            const ColumnString * col_str = checkAndGetColumn<ColumnString>(column);\n+            return col_str->getDataAtWithTerminatingZero(idx).size + sizeof(col_str->getOffsets()[0]);\n+        }\n+        else if (which.isArray())\n+        {\n+            const ColumnArray * col_arr = checkAndGetColumn<ColumnArray>(column);\n+            const DataTypeArray * type_arr = checkAndGetDataType<DataTypeArray>(data_type);\n+            const auto & offsets = col_arr->getOffsets();\n+            ColumnArray::Offset current_offset = idx == 0 ? 0 : offsets[idx - 1];\n+            size_t array_size = offsets[idx] - current_offset;\n+            for (size_t i = 0; i < array_size; ++i)\n+                byte_size += byteSizeForNestedItem(type_arr->getNestedType().get(), &col_arr->getData(), current_offset + i);\n+            return byte_size + sizeof(offsets[0]);\n+        }\n+        else if (which.isNullable())\n+        {\n+            const ColumnNullable * col_null = checkAndGetColumn<ColumnNullable>(column);\n+            const DataTypeNullable * type_null = checkAndGetDataType<DataTypeNullable>(data_type);\n+            byte_size = sizeof(bool);\n+            if (!col_null->isNullAt(idx))\n+                byte_size += byteSizeForNestedItem(type_null->getNestedType().get(), &col_null->getNestedColumn(), idx);\n+            return byte_size;\n+        }\n+        else if (which.isTuple())\n+        {\n+            const ColumnTuple * col_tuple = checkAndGetColumn<ColumnTuple>(column);\n+            const DataTypeTuple * type_tuple = checkAndGetDataType<DataTypeTuple>(data_type);\n+\n+            byte_size = 0;\n+            size_t tuple_size = col_tuple->tupleSize();\n+            for (size_t col_idx = 0; col_idx < tuple_size; ++col_idx)\n+            {\n+                const IColumn * col_nested = col_tuple->getColumnPtr(col_idx).get();\n+                const IDataType * type_nested = type_tuple->getElements()[col_idx].get();\n+                byte_size += byteSizeForNestedItem(type_nested, col_nested, idx);\n+            }\n+            return byte_size;\n+        }\n+        else if (which.isLowCardinality())\n+        {\n+            const ColumnLowCardinality * col_low = checkAndGetColumn<ColumnLowCardinality>(column);\n+            return col_low->getSizeOfIndexType();\n+        }\n+\n+        throw Exception(\"byteSize for \\\"\" + data_type->getName() + \"\\\" is not supported.\",\n+                        ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n+\n+    static bool byteSizeForArray(const DataTypeArray * data_type, const ColumnArray * column, ResultHolder & res)\n+    {\n+        const IColumn * col_nested = &column->getData();\n+        const IDataType * type_nested = data_type->getNestedType().get();\n+        size_t res_size = res.size();\n+        const auto & offsets = column->getOffsets();\n+\n+        ColumnArray::Offset current_offset = 0;\n+        for (size_t i = 0; i < res_size; ++i)\n+        {\n+            UInt64 byte_size = 0;\n+            size_t array_size = offsets[i] - current_offset;\n+            for (size_t j = 0; j < array_size; ++j)\n+                byte_size += byteSizeForNestedItem(type_nested, col_nested, current_offset + j);\n+            res.set(i, byte_size + sizeof(offsets[0]));\n+            current_offset += array_size;\n+        }\n+        return true;\n+    }\n+};\n+\n+}\n+\n+void registerFunctionByteSize(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionByteSize>();\n+}\n+\n+}\ndiff --git a/src/Functions/registerFunctionsMiscellaneous.cpp b/src/Functions/registerFunctionsMiscellaneous.cpp\nindex 2c0baa7bba4d..653922bbced6 100644\n--- a/src/Functions/registerFunctionsMiscellaneous.cpp\n+++ b/src/Functions/registerFunctionsMiscellaneous.cpp\n@@ -66,6 +66,7 @@ void registerFunctionHasThreadFuzzer(FunctionFactory &);\n void registerFunctionInitializeAggregation(FunctionFactory &);\n void registerFunctionErrorCodeToName(FunctionFactory &);\n void registerFunctionTcpPort(FunctionFactory &);\n+void registerFunctionByteSize(FunctionFactory &);\n \n #if USE_ICU\n void registerFunctionConvertCharset(FunctionFactory &);\n@@ -132,6 +133,7 @@ void registerFunctionsMiscellaneous(FunctionFactory & factory)\n     registerFunctionInitializeAggregation(factory);\n     registerFunctionErrorCodeToName(factory);\n     registerFunctionTcpPort(factory);\n+    registerFunctionByteSize(factory);\n \n #if USE_ICU\n     registerFunctionConvertCharset(factory);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01622_byte_size.reference b/tests/queries/0_stateless/01622_byte_size.reference\nnew file mode 100644\nindex 000000000000..68e929df5aab\n--- /dev/null\n+++ b/tests/queries/0_stateless/01622_byte_size.reference\n@@ -0,0 +1,66 @@\n+\n+# byteSize\n+\n+byteSize for numbers #0\n+1\tUInt8\t1\tUInt16\t2\tUInt32\t4\tUInt64\t8\tUInt256\t32\n+2\tUInt8\t1\tUInt16\t2\tUInt32\t4\tUInt64\t8\tUInt256\t32\n+1\tInt8\t1\tInt16\t2\tInt32\t4\tInt64\t8\tInt128\t16\tUInt256\t32\n+2\tInt8\t1\tInt16\t2\tInt32\t4\tInt64\t8\tInt128\t16\tUInt256\t32\n+1\tFloat32\t4\tFloat64\t8\n+2\tFloat32\t4\tFloat64\t8\n+\n+byteSize for numbers #1\n+1\t97\tDate\t2\tDateTime\t4\tDateTime64(3)\t8\tUUID\t16\n+2\t97\tDate\t2\tDateTime\t4\tDateTime64(3)\t8\tUUID\t16\n+\n+byteSize for constants\n+1\t1\t256\t2\t65536\t4\t4294967296\t8\t0.5\t8\t1e-10\t8\n+2020-01-01\t2\t2020-01-01 01:02:03\t4\t2020-01-01 01:02:03.000\t8\n+UUID\t16\n+\n+byteSize for strings\n+1\t39\t\t9\ta\t10\t\\0\\0\\0\\0\\0\\0\\0\\0\t8\tabcde\\0\\0\\0\t8\n+2\t43\tabced\t14\t\t9\tabcde\\0\\0\\0\t8\t\\0\\0\\0\\0\\0\\0\\0\\0\t8\n+constants: \t\t9\ta\t10\tabcde\t14\n+\n+byteSize for simple array\n+1\t60\t[]\t8\t[]\t8\t[]\t8\t[]\t8\t[]\t8\t[]\t8\t[]\t8\n+2\t92\t[1]\t9\t[-1]\t9\t[256]\t12\t[1.1]\t12\t[1.1000]\t12\t['2020-01-01']\t10\t['61f0c404-5cb3-11e7-907b-a6006ad3dba0']\t24\n+3\t124\t[1,1]\t10\t[-1,-1]\t10\t[256,256]\t16\t[1.1,1.1]\t16\t[1.1000,1.1000]\t16\t['2020-01-01','2020-01-01']\t12\t['61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0']\t40\n+4\t156\t[1,1,1]\t11\t[-1,-1,-1]\t11\t[256,256,256]\t20\t[1.1,1.1,1.1]\t20\t[1.1000,1.1000,1.1000]\t20\t['2020-01-01','2020-01-01','2020-01-01']\t14\t['61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0']\t56\n+constants:\t[]\t8\t[1,1]\t10\t[-1,-1]\t10\tArray(UInt16)\t12\tArray(Float64)\t24\n+constants:\t[1.1000,1.1000]\t16\t['2020-01-01','2020-01-01']\t12\n+constants:\t['61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0']\t40\n+\n+byteSize for int array of arrays\n+1\t52\t[]\t8\t[[]]\t16\n+2\t102\t[1,2]\t16\t[[],[1,2]]\t32\n+3\t155\t[0,256]\t16\t[[],[1,2],[0,256]]\t48\n+4\t226\t[256,65536]\t16\t[[],[1,2],[0,256],[256,65536]]\t64\n+constants:\t[[],[1,2],[0,65536]]\tArray(Array(UInt32))\t48\n+\n+byteSize for string array of arrays\n+1\t52\t[]\t8\t[[]]\t16\n+2\t102\t['']\t17\t[[],['']]\t33\n+3\t155\t['','a']\t27\t[[],[''],['','a']]\t60\n+4\t226\t['','a','abced']\t41\t[[],[''],['','a'],['','a','abced']]\t101\n+constants:\t[[],[''],['','a']]\t60\n+\n+byteSize for others: Nullable, Tuple, LowCardinality\n+1\t12\t\\N\t1\t\\N\t1\t(1,NULL)\t5\t\t1\n+2\t36\t1\t5\ta\t11\t(1,'a')\t15\ta\t1\n+3\t44\t256\t5\tabcde\t15\t(256,'abcde')\t19\tabcde\t1\n+constants:\t\\N\t1\t(65536,NULL)\t5\t(65536,'a')\t15\n+constants:\tabced\tLowCardinality(String)\t1\n+\n+byteSize for complex fields\n+1\t12\t[]\t8\n+2\t21\t[(NULL,[])]\t17\n+3\t25\t[('a\\0\\0\\0',[])]\t21\n+4\t36\t[('a\\0\\0\\0',[(NULL,'a')])]\t32\n+5\t47\t[('a\\0\\0\\0',[(NULL,'a'),(NULL,'a')])]\t43\n+6\t93\t[(NULL,[]),('a\\0\\0\\0',[]),('a\\0\\0\\0',[(NULL,'a')]),('a\\0\\0\\0',[(NULL,'a'),(NULL,'a')])]\t89\n+constants:\t(NULL,[])\t9\t('a\\0\\0\\0',[])\t13\t('a\\0\\0\\0',[(NULL,'a')])\t24\t('a\\0\\0\\0',[(NULL,'a'),(NULL,'a')])\t35\n+constants:\t[(NULL,[]),('a\\0\\0\\0',[]),('a\\0\\0\\0',[(NULL,'a')]),('a\\0\\0\\0',[(NULL,'a'),(NULL,'a')])]\n+constants:\tArray(Tuple(Nullable(FixedString(4)), Array(Tuple(Nullable(Nothing), String))))\n+constants:\t89\ndiff --git a/tests/queries/0_stateless/01622_byte_size.sql b/tests/queries/0_stateless/01622_byte_size.sql\nnew file mode 100644\nindex 000000000000..5639f92ce112\n--- /dev/null\n+++ b/tests/queries/0_stateless/01622_byte_size.sql\n@@ -0,0 +1,205 @@\n+--\n+-- byteSize\n+--\n+select '';\n+select '# byteSize';\n+\n+set allow_experimental_bigint_types = 1;\n+\n+-- numbers #0 --\n+select '';\n+select 'byteSize for numbers #0';\n+drop table if exists test_byte_size_number0;\n+create table test_byte_size_number0\n+(\n+    key Int32,\n+    u8 UInt8,\n+    u16 UInt16,\n+    u32 UInt32,\n+    u64 UInt64,\n+    u256 UInt256,\n+    i8 Int8,\n+    i16 Int16,\n+    i32 Int32,\n+    i64 Int64,\n+    i128 Int128,\n+    i256 Int256,\n+    f32 Float32,\n+    f64 Float64\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_number0 values(1, 8, 16, 32, 64, 256, -8, -16, -32, -64, -128, -256, 32.32, 64.64);\n+insert into test_byte_size_number0 values(2, 8, 16, 32, 64, 256, -8, -16, -32, -64, -128, -256, 32.32, 64.64);\n+\n+select key, toTypeName(u8),byteSize(u8), toTypeName(u16),byteSize(u16), toTypeName(u32),byteSize(u32), toTypeName(u64),byteSize(u64), toTypeName(u256),byteSize(u256) from test_byte_size_number0 order by key;\n+select key, toTypeName(i8),byteSize(i8), toTypeName(i16),byteSize(i16), toTypeName(i32),byteSize(i32), toTypeName(i64),byteSize(i64), toTypeName(i128),byteSize(i128), toTypeName(u256),byteSize(u256) from test_byte_size_number0 order by key;\n+select key, toTypeName(f32),byteSize(f32), toTypeName(f64),byteSize(f64) from test_byte_size_number0 order by key;\n+\n+drop table if exists test_byte_size_number0;\n+\n+\n+-- numbers #1 --\n+select '';\n+select 'byteSize for numbers #1';\n+drop table if exists test_byte_size_number1;\n+create table test_byte_size_number1\n+(\n+    key Int32,\n+    date Date,\n+    dt DateTime,\n+    dt64 DateTime64(3),\n+    en8 Enum8('a'=1, 'b'=2, 'c'=3, 'd'=4),\n+    en16 Enum16('c'=100, 'l'=101, 'i'=102, 'ck'=103, 'h'=104, 'o'=105, 'u'=106, 's'=107, 'e'=108),\n+    dec32 Decimal32(4),\n+    dec64 Decimal64(8),\n+    dec128 Decimal128(16),\n+    dec256 Decimal256(16),\n+    uuid UUID\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_number1 values(1, '2020-01-01', '2020-01-01 01:02:03', '2020-02-02 01:02:03', 'a', 'ck', 32.32, 64.64, 128.128, 256.256, generateUUIDv4());\n+insert into test_byte_size_number1 values(2, '2020-01-01', '2020-01-01 01:02:03', '2020-02-02 01:02:03', 'a', 'ck', 32.32, 64.64, 128.128, 256.256, generateUUIDv4());\n+\n+select key,byteSize(*), toTypeName(date),byteSize(date), toTypeName(dt),byteSize(dt), toTypeName(dt64),byteSize(dt64), toTypeName(uuid),byteSize(uuid) from test_byte_size_number1 order by key;\n+\n+drop table if exists test_byte_size_number1;\n+\n+\n+-- constant numbers --\n+select '';\n+select 'byteSize for constants';\n+select 0x1,byteSize(0x1), 0x100,byteSize(0x100), 0x10000,byteSize(0x10000), 0x100000000,byteSize(0x100000000), 0.5,byteSize(0.5), 1e-10,byteSize(1e-10);\n+select toDate('2020-01-01'),byteSize(toDate('2020-01-01')), toDateTime('2020-01-01 01:02:03'),byteSize(toDateTime('2020-01-01 01:02:03')), toDateTime64('2020-01-01 01:02:03',3),byteSize(toDateTime64('2020-01-01 01:02:03',3));\n+select toTypeName(generateUUIDv4()),byteSize(generateUUIDv4());\n+\n+\n+-- strings --\n+select '';\n+select 'byteSize for strings';\n+drop table if exists test_byte_size_string;\n+create table test_byte_size_string\n+(\n+    key Int32,\n+    str1 String,\n+    str2 String,\n+    fstr1 FixedString(8),\n+    fstr2 FixedString(8)\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_string values(1, '', 'a', '', 'abcde');\n+insert into test_byte_size_string values(2, 'abced', '', 'abcde', '');\n+\n+select key,byteSize(*), str1,byteSize(str1), str2,byteSize(str2), fstr1,byteSize(fstr1), fstr2,byteSize(fstr2) from test_byte_size_string order by key;\n+select 'constants: ', '',byteSize(''), 'a',byteSize('a'), 'abcde',byteSize('abcde');\n+\n+drop table if exists test_byte_size_string;\n+\n+\n+-- simple arrays --\n+drop table if exists test_byte_size_array;\n+create table test_byte_size_array\n+(\n+    key Int32,\n+    uints8 Array(UInt8),\n+    ints8 Array(Int8),\n+    ints32 Array(Int32),\n+    floats32 Array(Float32),\n+    decs32 Array(Decimal32(4)),\n+    dates Array(Date),\n+    uuids Array(UUID)\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_array values(1, [], [], [], [], [], [], []);\n+insert into test_byte_size_array values(2, [1], [-1], [256], [1.1], [1.1], ['2020-01-01'], ['61f0c404-5cb3-11e7-907b-a6006ad3dba0']);\n+insert into test_byte_size_array values(3, [1,1], [-1,-1], [256,256], [1.1,1.1], [1.1,1.1], ['2020-01-01','2020-01-01'], ['61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0']);\n+insert into test_byte_size_array values(4, [1,1,1], [-1,-1,-1], [256,256,256], [1.1,1.1,1.1], [1.1,1.1,1.1], ['2020-01-01','2020-01-01','2020-01-01'], ['61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0','61f0c404-5cb3-11e7-907b-a6006ad3dba0']);\n+\n+select '';\n+select 'byteSize for simple array';\n+select key,byteSize(*), uints8,byteSize(uints8), ints8,byteSize(ints8), ints32,byteSize(ints32), floats32,byteSize(floats32), decs32,byteSize(decs32), dates,byteSize(dates), uuids,byteSize(uuids) from test_byte_size_array order by key;\n+\n+select 'constants:', [],byteSize([]), [1,1],byteSize([1,1]), [-1,-1],byteSize([-1,-1]), toTypeName([256,256]),byteSize([256,256]), toTypeName([1.1,1.1]),byteSize([1.1,1.1]);\n+select 'constants:', [toDecimal32(1.1,4),toDecimal32(1.1,4)],byteSize([toDecimal32(1.1,4),toDecimal32(1.1,4)]), [toDate('2020-01-01'),toDate('2020-01-01')],byteSize([toDate('2020-01-01'),toDate('2020-01-01')]);\n+select 'constants:', [toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'),toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')],byteSize([toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0'),toUUID('61f0c404-5cb3-11e7-907b-a6006ad3dba0')]);\n+\n+drop table if exists test_byte_size_array;\n+\n+\n+-- complex arrays --\n+drop table if exists test_byte_size_complex_array;\n+create table test_byte_size_complex_array\n+(\n+    key Int32,\n+    ints Array(Int32),\n+    int_ints Array(Array(Int32)),\n+    strs Array(String),\n+    str_strs Array(Array(String))\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_complex_array values(1, [], [[]], [], [[]]);\n+insert into test_byte_size_complex_array values(2, [1,2], [[], [1,2]], [''], [[], ['']]);\n+insert into test_byte_size_complex_array values(3, [0,256], [[], [1,2], [0,256]], ['','a'], [[], [''], ['','a']]);\n+insert into test_byte_size_complex_array values(4, [256,65536], [[], [1,2], [0,256], [256,65536]], ['','a','abced'], [[], [''], ['','a'], ['','a','abced']]);\n+\n+select '';\n+select 'byteSize for int array of arrays';\n+select key,byteSize(*), ints,byteSize(ints), int_ints,byteSize(int_ints) from test_byte_size_complex_array order by key;\n+select 'constants:', [[], [1,2], [0,0x10000]],toTypeName([[], [1,2], [0,0x10000]]),byteSize([[], [1,2], [0,0x10000]]);\n+\n+select '';\n+select 'byteSize for string array of arrays';\n+-- select key,byteSize(*), strs,byteSize(strs), str_strs,byteSize(str_strs) from test_byte_size_complex_array order by key;\n+select key,byteSize(*), strs,byteSize(strs), str_strs,byteSize(str_strs) from test_byte_size_complex_array order by key;\n+select 'constants:', [[], [''], ['','a']],byteSize([[], [''], ['','a']]);\n+\n+drop table if exists test_byte_size_complex_array;\n+\n+\n+-- others --\n+drop table if exists test_byte_size_other;\n+create table test_byte_size_other\n+(\n+    key Int32,\n+    opt_int32 Nullable(Int32),\n+    opt_str Nullable(String),\n+    tuple Tuple(Int32, Nullable(String)),\n+    strings LowCardinality(String)\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_other values(1, NULL, NULL, tuple(1, NULL), '');\n+insert into test_byte_size_other values(2, 1, 'a', tuple(1, 'a'), 'a');\n+insert into test_byte_size_other values(3, 256, 'abcde', tuple(256, 'abcde'), 'abcde');\n+\n+select '';\n+select 'byteSize for others: Nullable, Tuple, LowCardinality';\n+select key,byteSize(*), opt_int32,byteSize(opt_int32), opt_str,byteSize(opt_str), tuple,byteSize(tuple), strings,byteSize(strings) from test_byte_size_other order by key;\n+select 'constants:', NULL,byteSize(NULL), tuple(0x10000, NULL),byteSize(tuple(0x10000, NULL)), tuple(0x10000, toNullable('a')),byteSize(tuple(0x10000, toNullable('a')));\n+select 'constants:', toLowCardinality('abced'),toTypeName(toLowCardinality('abced')),byteSize(toLowCardinality('abced'));\n+\n+drop table if exists test_byte_size_other;\n+\n+\n+-- more complex fields --\n+drop table if exists test_byte_size_more_complex;\n+create table test_byte_size_more_complex\n+(\n+    key Int32,\n+    complex1 Array(Tuple(Nullable(FixedString(4)), Array(Tuple(Nullable(String), String))))\n+) engine MergeTree order by key;\n+\n+insert into test_byte_size_more_complex values(1, []);\n+insert into test_byte_size_more_complex values(2, [tuple(NULL, [])]);\n+insert into test_byte_size_more_complex values(3, [tuple('a', [])]);\n+insert into test_byte_size_more_complex values(4, [tuple('a', [tuple(NULL, 'a')])]);\n+insert into test_byte_size_more_complex values(5, [tuple('a', [tuple(NULL, 'a'), tuple(NULL, 'a')])]);\n+insert into test_byte_size_more_complex values(6, [tuple(NULL, []), tuple('a', []), tuple('a', [tuple(NULL, 'a')]), tuple('a', [tuple(NULL, 'a'), tuple(NULL, 'a')])]);\n+\n+select '';\n+select 'byteSize for complex fields';\n+select key,byteSize(*), complex1,byteSize(complex1) from test_byte_size_more_complex order by key;\n+select 'constants:', tuple(NULL, []),byteSize(tuple(NULL, [])), tuple(toNullable(toFixedString('a',4)), []),byteSize(tuple(toNullable(toFixedString('a',4)), [])), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a')]),byteSize(tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a')])), tuple(toFixedString('a',4), [tuple(NULL, 'a'), tuple(NULL, 'a')]),byteSize(tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a'), tuple(NULL, 'a')]));\n+select 'constants:', [tuple(NULL, []), tuple(toNullable(toFixedString('a',4)), []), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a')]), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a'), tuple(NULL, 'a')])];\n+select 'constants:', toTypeName([tuple(NULL, []), tuple(toNullable(toFixedString('a',4)), []), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a')]), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a'), tuple(NULL, 'a')])]);\n+select 'constants:', byteSize([tuple(NULL, []), tuple(toNullable(toFixedString('a',4)), []), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a')]), tuple(toNullable(toFixedString('a',4)), [tuple(NULL, 'a'), tuple(NULL, 'a')])]);\n+\n+drop table if exists test_byte_size_more_complex;\n",
  "problem_statement": "Function `byteSize`\nThe function should return an estimate of uncompressed byte size of its arguments in memory.\r\nE.g. for UInt32 argument it will return constant 4, for String argument - the string length + 9.\r\nThe function can take multiple arguments. The typical application is `byteSize(*)`.\r\n\r\n**Use case**\r\nSuppose you have a service that stores data for multiple clients in one table. Users will pay per data volume. So, you need to implement accounting of users data volume. The function will allow to calculate the data size on per-row basis.\n",
  "hints_text": "I'd like to have a try.\r\nWould you please assign to me ? @alexey-milovidov \n@pingyu Ok, this task is yours :+1: ",
  "created_at": "2020-12-28T17:43:42Z"
}