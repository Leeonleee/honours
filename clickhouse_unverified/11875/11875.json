{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11875,
  "instance_id": "ClickHouse__ClickHouse-11875",
  "issue_numbers": [
    "11374"
  ],
  "base_commit": "55eee9bfa171fe7f347172be8b78821996f39668",
  "patch": "diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex 05fc1ba9141b..be148ddb3e39 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -1477,7 +1477,8 @@ class Client : public Poco::Util::Application\n                 }\n                 else\n                 {\n-                    out_logs_buf = std::make_unique<WriteBufferFromFile>(server_logs_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_APPEND | O_CREAT);\n+                    out_logs_buf = std::make_unique<WriteBufferFromFile>(\n+                        server_logs_file, DBMS_DEFAULT_BUFFER_SIZE, O_WRONLY | O_APPEND | O_CREAT);\n                     wb = out_logs_buf.get();\n                 }\n             }\ndiff --git a/src/Common/intExp.h b/src/Common/intExp.h\nindex a021d9660ffd..b38a8afd83bb 100644\n--- a/src/Common/intExp.h\n+++ b/src/Common/intExp.h\n@@ -20,14 +20,14 @@ inline NO_SANITIZE_UNDEFINED uint64_t intExp2(int x)\n     return 1ULL << x;\n }\n \n-inline uint64_t intExp10(int x)\n+constexpr inline uint64_t intExp10(int x)\n {\n     if (x < 0)\n         return 0;\n     if (x > 19)\n         return std::numeric_limits<uint64_t>::max();\n \n-    static const uint64_t table[20] =\n+    constexpr uint64_t table[20] =\n     {\n         1ULL,                   10ULL,                   100ULL,\n         1000ULL,                10000ULL,                100000ULL,\n@@ -44,9 +44,10 @@ inline uint64_t intExp10(int x)\n namespace common\n {\n \n-inline int exp10_i32(int x)\n+constexpr inline int exp10_i32(int x)\n {\n-    static const int values[] = {\n+    constexpr int values[] =\n+    {\n         1,\n         10,\n         100,\n@@ -61,74 +62,76 @@ inline int exp10_i32(int x)\n     return values[x];\n }\n \n-inline int64_t exp10_i64(int x)\n+constexpr inline int64_t exp10_i64(int x)\n {\n-    static const int64_t values[] = {\n-        1ll,\n-        10ll,\n-        100ll,\n-        1000ll,\n-        10000ll,\n-        100000ll,\n-        1000000ll,\n-        10000000ll,\n-        100000000ll,\n-        1000000000ll,\n-        10000000000ll,\n-        100000000000ll,\n-        1000000000000ll,\n-        10000000000000ll,\n-        100000000000000ll,\n-        1000000000000000ll,\n-        10000000000000000ll,\n-        100000000000000000ll,\n-        1000000000000000000ll\n+    constexpr int64_t values[] =\n+    {\n+        1LL,\n+        10LL,\n+        100LL,\n+        1000LL,\n+        10000LL,\n+        100000LL,\n+        1000000LL,\n+        10000000LL,\n+        100000000LL,\n+        1000000000LL,\n+        10000000000LL,\n+        100000000000LL,\n+        1000000000000LL,\n+        10000000000000LL,\n+        100000000000000LL,\n+        1000000000000000LL,\n+        10000000000000000LL,\n+        100000000000000000LL,\n+        1000000000000000000LL\n     };\n     return values[x];\n }\n \n-inline __int128 exp10_i128(int x)\n+constexpr inline __int128 exp10_i128(int x)\n {\n-    static const __int128 values[] = {\n-        static_cast<__int128>(1ll),\n-        static_cast<__int128>(10ll),\n-        static_cast<__int128>(100ll),\n-        static_cast<__int128>(1000ll),\n-        static_cast<__int128>(10000ll),\n-        static_cast<__int128>(100000ll),\n-        static_cast<__int128>(1000000ll),\n-        static_cast<__int128>(10000000ll),\n-        static_cast<__int128>(100000000ll),\n-        static_cast<__int128>(1000000000ll),\n-        static_cast<__int128>(10000000000ll),\n-        static_cast<__int128>(100000000000ll),\n-        static_cast<__int128>(1000000000000ll),\n-        static_cast<__int128>(10000000000000ll),\n-        static_cast<__int128>(100000000000000ll),\n-        static_cast<__int128>(1000000000000000ll),\n-        static_cast<__int128>(10000000000000000ll),\n-        static_cast<__int128>(100000000000000000ll),\n-        static_cast<__int128>(1000000000000000000ll),\n-        static_cast<__int128>(1000000000000000000ll) * 10ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100ll,\n-        static_cast<__int128>(1000000000000000000ll) * 1000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 10000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 1000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 10000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 1000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 10000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 1000000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 10000000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 1000000000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 10000000000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000000000000ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000000000000ll * 10ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000000000000ll * 100ll,\n-        static_cast<__int128>(1000000000000000000ll) * 100000000000000000ll * 1000ll\n+    constexpr __int128 values[] =\n+    {\n+        static_cast<__int128>(1LL),\n+        static_cast<__int128>(10LL),\n+        static_cast<__int128>(100LL),\n+        static_cast<__int128>(1000LL),\n+        static_cast<__int128>(10000LL),\n+        static_cast<__int128>(100000LL),\n+        static_cast<__int128>(1000000LL),\n+        static_cast<__int128>(10000000LL),\n+        static_cast<__int128>(100000000LL),\n+        static_cast<__int128>(1000000000LL),\n+        static_cast<__int128>(10000000000LL),\n+        static_cast<__int128>(100000000000LL),\n+        static_cast<__int128>(1000000000000LL),\n+        static_cast<__int128>(10000000000000LL),\n+        static_cast<__int128>(100000000000000LL),\n+        static_cast<__int128>(1000000000000000LL),\n+        static_cast<__int128>(10000000000000000LL),\n+        static_cast<__int128>(100000000000000000LL),\n+        static_cast<__int128>(1000000000000000000LL),\n+        static_cast<__int128>(1000000000000000000LL) * 10LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100LL,\n+        static_cast<__int128>(1000000000000000000LL) * 1000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 10000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 1000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 10000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 1000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 10000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 1000000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 10000000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 1000000000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 10000000000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000000000000LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000000000000LL * 10LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000000000000LL * 100LL,\n+        static_cast<__int128>(1000000000000000000LL) * 100000000000000000LL * 1000LL\n     };\n     return values[x];\n }\n@@ -138,7 +141,7 @@ inline __int128 exp10_i128(int x)\n \n /// intExp10 returning the type T.\n template <typename T>\n-inline T intExp10OfSize(int x)\n+constexpr inline T intExp10OfSize(int x)\n {\n     if constexpr (sizeof(T) <= 8)\n         return intExp10(x);\ndiff --git a/src/DataTypes/DataTypeDateTime64.cpp b/src/DataTypes/DataTypeDateTime64.cpp\nindex 9b4f16ab408d..87da173766d2 100644\n--- a/src/DataTypes/DataTypeDateTime64.cpp\n+++ b/src/DataTypes/DataTypeDateTime64.cpp\n@@ -20,19 +20,34 @@\n #include <optional>\n #include <string>\n \n+\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n+}\n+\n+static constexpr UInt32 max_scale = 9;\n+\n DataTypeDateTime64::DataTypeDateTime64(UInt32 scale_, const std::string & time_zone_name)\n     : DataTypeDecimalBase<DateTime64>(DecimalUtils::maxPrecision<DateTime64>(), scale_),\n       TimezoneMixin(time_zone_name)\n {\n+    if (scale > max_scale)\n+        throw Exception(\"Scale \" + std::to_string(scale) + \" is too large for DateTime64. Maximum is up to nanoseconds (9).\",\n+            ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n }\n \n DataTypeDateTime64::DataTypeDateTime64(UInt32 scale_, const TimezoneMixin & time_zone_info)\n-    : DataTypeDecimalBase<DateTime64>(DecimalUtils::maxPrecision<DateTime64>() - scale_, scale_),\n+    : DataTypeDecimalBase<DateTime64>(DecimalUtils::maxPrecision<DateTime64>(), scale_),\n       TimezoneMixin(time_zone_info)\n-{}\n+{\n+    if (scale > max_scale)\n+        throw Exception(\"Scale \" + std::to_string(scale) + \" is too large for DateTime64. Maximum is up to nanoseconds (9).\",\n+            ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+}\n \n std::string DataTypeDateTime64::doGetName() const\n {\ndiff --git a/src/DataTypes/DataTypeDecimalBase.h b/src/DataTypes/DataTypeDecimalBase.h\nindex 2cf734676445..edfba272110d 100644\n--- a/src/DataTypes/DataTypeDecimalBase.h\n+++ b/src/DataTypes/DataTypeDecimalBase.h\n@@ -72,7 +72,7 @@ class DataTypeDecimalBase : public DataTypeWithSimpleSerialization\n     {\n         if (unlikely(precision < 1 || precision > maxPrecision()))\n             throw Exception(\"Precision \" + std::to_string(precision) + \" is out of bounds\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n-        if (unlikely(scale < 0 || static_cast<UInt32>(scale) > maxPrecision()))\n+        if (unlikely(scale > maxPrecision()))\n             throw Exception(\"Scale \" + std::to_string(scale) + \" is out of bounds\", ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n     }\n \ndiff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp\nindex b11f1aa7454d..9c3ca679467f 100644\n--- a/src/DataTypes/getLeastSupertype.cpp\n+++ b/src/DataTypes/getLeastSupertype.cpp\n@@ -208,7 +208,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n         }\n     }\n \n-    /// For Date and DateTime, the common type is DateTime. No other types are compatible.\n+    /// For Date and DateTime/DateTime64, the common type is DateTime/DateTime64. No other types are compatible.\n     {\n         UInt32 have_date = type_ids.count(TypeIndex::Date);\n         UInt32 have_datetime = type_ids.count(TypeIndex::DateTime);\n@@ -218,40 +218,25 @@ DataTypePtr getLeastSupertype(const DataTypes & types)\n         {\n             bool all_date_or_datetime = type_ids.size() == (have_date + have_datetime + have_datetime64);\n             if (!all_date_or_datetime)\n-                throw Exception(getExceptionMessagePrefix(types) + \" because some of them are Date/DateTime and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+                throw Exception(getExceptionMessagePrefix(types) + \" because some of them are Date/DateTime/DateTime64 and some of them are not\",\n+                    ErrorCodes::NO_COMMON_TYPE);\n \n             if (have_datetime64 == 0)\n-            {\n                 return std::make_shared<DataTypeDateTime>();\n-            }\n \n-            // When DateTime64 involved, make sure that supertype has whole-part precision\n-            // big enough to hold max whole-value of any type from `types`.\n-            // That would sacrifice scale when comparing DateTime64 of different scales.\n+            UInt8 max_scale = 0;\n \n-            UInt32 max_datetime64_whole_precision = 0;\n             for (const auto & t : types)\n             {\n                 if (const auto * dt64 = typeid_cast<const DataTypeDateTime64 *>(t.get()))\n                 {\n-                    const auto whole_precision = dt64->getPrecision() - dt64->getScale();\n-                    max_datetime64_whole_precision = std::max(whole_precision, max_datetime64_whole_precision);\n+                    const auto scale = dt64->getScale();\n+                    if (scale > max_scale)\n+                        max_scale = scale;\n                 }\n             }\n \n-            UInt32 least_decimal_precision = 0;\n-            if (have_datetime)\n-            {\n-                least_decimal_precision = leastDecimalPrecisionFor(TypeIndex::UInt32);\n-            }\n-            else if (have_date)\n-            {\n-                least_decimal_precision = leastDecimalPrecisionFor(TypeIndex::UInt16);\n-            }\n-            max_datetime64_whole_precision = std::max(least_decimal_precision, max_datetime64_whole_precision);\n-\n-            const UInt32 scale = DataTypeDateTime64::maxPrecision() - max_datetime64_whole_precision;\n-            return std::make_shared<DataTypeDateTime64>(scale);\n+            return std::make_shared<DataTypeDateTime64>(max_scale);\n         }\n     }\n \ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 266b5ae1917b..00bc61131868 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -275,8 +275,11 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n         switch (*buf.position())\n         {\n             case '+':\n+            {\n                 break;\n+            }\n             case '-':\n+            {\n                 if constexpr (is_signed_v<T>)\n                     negative = true;\n                 else\n@@ -287,6 +290,7 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n                         return ReturnType(false);\n                 }\n                 break;\n+            }\n             case '0': [[fallthrough]];\n             case '1': [[fallthrough]];\n             case '2': [[fallthrough]];\n@@ -297,20 +301,27 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n             case '7': [[fallthrough]];\n             case '8': [[fallthrough]];\n             case '9':\n+            {\n                 if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW)\n                 {\n-                    // perform relativelly slow overflow check only when number of decimal digits so far is close to the max for given type.\n-                    if (buf.count() - initial_pos >= std::numeric_limits<T>::max_digits10)\n+                    /// Perform relativelly slow overflow check only when\n+                    /// number of decimal digits so far is close to the max for given type.\n+                    /// Example: 20 * 10 will overflow Int8.\n+\n+                    if (buf.count() - initial_pos + 1 >= std::numeric_limits<T>::max_digits10)\n                     {\n-                        if (common::mulOverflow(res, static_cast<decltype(res)>(10), res)\n-                            || common::addOverflow(res, static_cast<decltype(res)>(*buf.position() - '0'), res))\n+                        T signed_res = res;\n+                        if (common::mulOverflow<T>(signed_res, 10, signed_res)\n+                            || common::addOverflow<T>(signed_res, (*buf.position() - '0'), signed_res))\n                             return ReturnType(false);\n+                        res = signed_res;\n                         break;\n                     }\n                 }\n                 res *= 10;\n                 res += *buf.position() - '0';\n                 break;\n+            }\n             default:\n                 goto end;\n         }\n@@ -318,7 +329,23 @@ ReturnType readIntTextImpl(T & x, ReadBuffer & buf)\n     }\n \n end:\n-    x = negative ? -res : res;\n+    if (!negative)\n+    {\n+        x = res;\n+    }\n+    else\n+    {\n+        if constexpr (check_overflow == ReadIntTextCheckOverflow::CHECK_OVERFLOW)\n+        {\n+            x = res;\n+            if (common::mulOverflow<T>(x, -1, x))\n+                return ReturnType(false);\n+        }\n+        else\n+        {\n+            x = -res;\n+        }\n+    }\n \n     return ReturnType(true);\n }\n@@ -658,35 +685,34 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n         return ReturnType(false);\n     }\n \n-    DB::DecimalUtils::DecimalComponents<DateTime64::NativeType> c{static_cast<DateTime64::NativeType>(whole), 0};\n+    DB::DecimalUtils::DecimalComponents<DateTime64::NativeType> components{static_cast<DateTime64::NativeType>(whole), 0};\n \n     if (!buf.eof() && *buf.position() == '.')\n     {\n-        buf.ignore(1); // skip separator\n-        const auto pos_before_fractional = buf.count();\n-        if (!tryReadIntText<ReadIntTextCheckOverflow::CHECK_OVERFLOW>(c.fractional, buf))\n-        {\n-            return ReturnType(false);\n-        }\n-\n-        // Adjust fractional part to the scale, since decimalFromComponents knows nothing\n-        // about convention of ommiting trailing zero on fractional part\n-        // and assumes that fractional part value is less than 10^scale.\n+        ++buf.position();\n \n-        // If scale is 3, but we read '12', promote fractional part to '120'.\n-        // And vice versa: if we read '1234', denote it to '123'.\n-        const auto fractional_length = static_cast<Int32>(buf.count() - pos_before_fractional);\n-        if (const auto adjust_scale = static_cast<Int32>(scale) - fractional_length; adjust_scale > 0)\n+        /// Read digits, up to 'scale' positions.\n+        for (size_t i = 0; i < scale; ++i)\n         {\n-            c.fractional *= common::exp10_i64(adjust_scale);\n-        }\n-        else if (adjust_scale < 0)\n-        {\n-            c.fractional /= common::exp10_i64(-1 * adjust_scale);\n+            if (!buf.eof() && isNumericASCII(*buf.position()))\n+            {\n+                components.fractional *= 10;\n+                components.fractional += *buf.position() - '0';\n+                ++buf.position();\n+            }\n+            else\n+            {\n+                /// Adjust to scale.\n+                components.fractional *= 10;\n+            }\n         }\n+\n+        /// Ignore digits that are out of precision.\n+        while (!buf.eof() && isNumericASCII(*buf.position()))\n+            ++buf.position();\n     }\n \n-    datetime64 = DecimalUtils::decimalFromComponents<DateTime64>(c, scale);\n+    datetime64 = DecimalUtils::decimalFromComponents<DateTime64>(components, scale);\n \n     return ReturnType(true);\n }\n",
  "test_patch": "diff --git a/src/DataTypes/tests/gtest_data_type_get_common_type.cpp b/src/DataTypes/tests/gtest_data_type_get_common_type.cpp\nindex bd13de79ef62..8212555e8bcc 100644\n--- a/src/DataTypes/tests/gtest_data_type_get_common_type.cpp\n+++ b/src/DataTypes/tests/gtest_data_type_get_common_type.cpp\n@@ -86,7 +86,7 @@ TEST_P(LeastSuperTypeTest, getLeastSupertype)\n \n class MostSubtypeTest : public TypeTest {};\n \n-TEST_P(MostSubtypeTest, getLeastSupertype)\n+TEST_P(MostSubtypeTest, getMostSubtype)\n {\n     if (this->expected_type)\n     {\n@@ -124,9 +124,7 @@ INSTANTIATE_TEST_SUITE_P(data_type,\n             {\"Date DateTime64(3)\", \"DateTime64(3)\"},\n             {\"DateTime DateTime64(3)\", \"DateTime64(3)\"},\n             {\"DateTime DateTime64(0)\", \"DateTime64(0)\"},\n-            {\"DateTime64(9) DateTime64(3)\", \"DateTime64(3)\"},\n-            {\"DateTime DateTime64(12)\", \"DateTime64(8)\"},\n-            {\"Date DateTime64(15)\", \"DateTime64(13)\"},\n+            {\"DateTime64(9) DateTime64(3)\", \"DateTime64(9)\"},\n \n             {\"String FixedString(32) FixedString(8)\", \"String\"},\n \ndiff --git a/tests/queries/0_stateless/01259_datetime64_ubsan.sql b/tests/queries/0_stateless/01259_datetime64_ubsan.sql\nindex 3cba78c713f7..4bc7a71dac39 100644\n--- a/tests/queries/0_stateless/01259_datetime64_ubsan.sql\n+++ b/tests/queries/0_stateless/01259_datetime64_ubsan.sql\n@@ -1,2 +1,2 @@\n-select now64(10); -- { serverError 407 }\n+select now64(10); -- { serverError 69 }\n select length(toString(now64(9)));\ndiff --git a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\nindex 4ffcf3be3c99..63d9a11daaad 100644\n--- a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n+++ b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n@@ -6,7 +6,7 @@ WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE D\n WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 43}\n \n SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 53} -- invalid DateTime64 string\n-SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333'; -- {serverError 53} -- invalid string length\n+SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333';\n \n SELECT 'in SELECT';\n WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = S;\ndiff --git a/tests/queries/0_stateless/01340_datetime64_fpe.reference b/tests/queries/0_stateless/01340_datetime64_fpe.reference\nnew file mode 100644\nindex 000000000000..0a99fbafde48\n--- /dev/null\n+++ b/tests/queries/0_stateless/01340_datetime64_fpe.reference\n@@ -0,0 +1,22 @@\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\n+2011-11-11 11:11:11\ndiff --git a/tests/queries/0_stateless/01340_datetime64_fpe.sql b/tests/queries/0_stateless/01340_datetime64_fpe.sql\nnew file mode 100644\nindex 000000000000..3e76e3164b1c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01340_datetime64_fpe.sql\n@@ -0,0 +1,71 @@\n+WITH toDateTime64('2019-09-16 19:20:12.3456789102019-09-16 19:20:12.345678910', 0) AS dt64 SELECT dt64; -- { serverError 6 }\n+\n+SELECT toDateTime64('2011-11-11 11:11:11.1234567890123456789', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.-12345678901234567890', 0); -- { serverError 6 }\n+\n+\n+SELECT toDateTime64('2011-11-11 11:11:11.1', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.1111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.1111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.1111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.1111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.1111111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11111111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111111111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.1111111111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.11111111111111111111', 0);\n+SELECT toDateTime64('2011-11-11 11:11:11.111111111111111111111', 0);\n+\n+SELECT toDateTime64('2011-11-11 11:11:11.-1', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-1111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-1111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-1111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-1111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-1111111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11111111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111111111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-1111111111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-11111111111111111111', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.-111111111111111111111', 0); -- { serverError 6 }\n+\n+SELECT toDateTime64('2011-11-11 11:11:11.+1', 0); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.++11', 10); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+111', 3); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+++1111', 5); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+11111', 7); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+++++111111', 2); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+1111111', 1); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.++++++11111111', 8); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+111111111', 9); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+++++++1111111111', 6); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+11111111111', 4); -- { serverError 6 }\n+SELECT toDateTime64('2011-11-11 11:11:11.++++++++111111111111', 11);  -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+1111111111111', 15); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+++++++++11111111111111', 13); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+111111111111111', 12); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.++++++++++1111111111111111', 16); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+11111111111111111', 14); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+++++++++++111111111111111111', 15); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+1111111111111111111', 17); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.++++++++++++11111111111111111111', 19); -- { serverError 69 }\n+SELECT toDateTime64('2011-11-11 11:11:11.+111111111111111111111', 18); -- { serverError 69 }\ndiff --git a/tests/queries/0_stateless/01341_datetime64_wrong_supertype.reference b/tests/queries/0_stateless/01341_datetime64_wrong_supertype.reference\nnew file mode 100644\nindex 000000000000..09076dd68dba\n--- /dev/null\n+++ b/tests/queries/0_stateless/01341_datetime64_wrong_supertype.reference\n@@ -0,0 +1,1 @@\n+['2000-01-01 01:01:01.123000','2000-01-01 01:01:01.123456']\ndiff --git a/tests/queries/0_stateless/01341_datetime64_wrong_supertype.sql b/tests/queries/0_stateless/01341_datetime64_wrong_supertype.sql\nnew file mode 100644\nindex 000000000000..39acaf93e347\n--- /dev/null\n+++ b/tests/queries/0_stateless/01341_datetime64_wrong_supertype.sql\n@@ -0,0 +1,1 @@\n+SELECT [toDateTime64('2000-01-01 01:01:01.123', 3), toDateTime64('2000-01-01 01:01:01.123456', 6)];\n",
  "problem_statement": "Received signal Floating point exception (8).\n```\r\nWITH toDateTime64('2019-09-16 19:20:12.3456789102019-09-16 19:20:12.345678910', 0) AS dt64\r\nSELECT dt64\r\n```\n",
  "hints_text": "`SELECT toDateTime64('2011-11-11 11:11:11.1234567890123456789', 0)`\n`SELECT toDateTime64('2011-11-11 11:11:11.-12345678901234567890', 0)`",
  "created_at": "2020-06-22T22:09:14Z"
}