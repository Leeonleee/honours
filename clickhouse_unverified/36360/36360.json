{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36360,
  "instance_id": "ClickHouse__ClickHouse-36360",
  "issue_numbers": [
    "36357"
  ],
  "base_commit": "1f3d1d67fcdb36bca95c12a6921c814e3579cf13",
  "patch": "diff --git a/src/Common/SystemLogBase.h b/src/Common/SystemLogBase.h\nindex da3d6c245629..4bdb518b9d6d 100644\n--- a/src/Common/SystemLogBase.h\n+++ b/src/Common/SystemLogBase.h\n@@ -45,7 +45,8 @@ struct StorageID;\n class ISystemLog\n {\n public:\n-    virtual String getName() = 0;\n+    virtual String getName() const = 0;\n+\n     //// force -- force table creation (used for SYSTEM FLUSH LOGS)\n     virtual void flush(bool force = false) = 0; /// NOLINT\n     virtual void prepareTable() = 0;\n@@ -86,7 +87,9 @@ class SystemLogBase : public ISystemLog\n     /// Flush data in the buffer to disk\n     void flush(bool force) override;\n \n-    String getName() override { return LogElement::name(); }\n+    String getName() const override { return LogElement::name(); }\n+\n+    static const char * getDefaultOrderBy() { return \"(event_date, event_time)\"; }\n \n protected:\n     Poco::Logger * log;\ndiff --git a/src/Interpreters/AsynchronousMetricLog.cpp b/src/Interpreters/AsynchronousMetricLog.cpp\nindex c7003cff1695..228934d5f4d6 100644\n--- a/src/Interpreters/AsynchronousMetricLog.cpp\n+++ b/src/Interpreters/AsynchronousMetricLog.cpp\n@@ -17,54 +17,37 @@ NamesAndTypesList AsynchronousMetricLogElement::getNamesAndTypes()\n     {\n         {\"event_date\", std::make_shared<DataTypeDate>()},\n         {\"event_time\", std::make_shared<DataTypeDateTime>()},\n-        {\"event_time_microseconds\", std::make_shared<DataTypeDateTime64>(6)},\n         {\"metric\", std::make_shared<DataTypeLowCardinality>(std::make_shared<DataTypeString>())},\n         {\"value\", std::make_shared<DataTypeFloat64>(),}\n     };\n }\n \n-\n void AsynchronousMetricLogElement::appendToBlock(MutableColumns & columns) const\n {\n     size_t column_idx = 0;\n \n     columns[column_idx++]->insert(event_date);\n     columns[column_idx++]->insert(event_time);\n-    columns[column_idx++]->insert(event_time_microseconds);\n     columns[column_idx++]->insert(metric_name);\n     columns[column_idx++]->insert(value);\n }\n \n-\n-inline UInt64 time_in_milliseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n-{\n-    return std::chrono::duration_cast<std::chrono::milliseconds>(timepoint.time_since_epoch()).count();\n-}\n-\n-inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n-{\n-    return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();\n-}\n-\n-\n-inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n-{\n-    return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();\n-}\n-\n void AsynchronousMetricLog::addValues(const AsynchronousMetricValues & values)\n {\n     AsynchronousMetricLogElement element;\n \n-    const auto now = std::chrono::system_clock::now();\n-    element.event_time = time_in_seconds(now);\n-    element.event_time_microseconds = time_in_microseconds(now);\n+    element.event_time = time(nullptr);\n     element.event_date = DateLUT::instance().toDayNum(element.event_time);\n \n+    /// We will round the values to make them compress better in the table.\n+    /// Note: as an alternative we can also use fixed point Decimal data type,\n+    /// but we need to store up to UINT64_MAX sometimes.\n+    static constexpr double precision = 1000.0;\n+\n     for (const auto & [key, value] : values)\n     {\n         element.metric_name = key;\n-        element.value = value;\n+        element.value = round(value * precision) / precision;\n \n         add(element);\n     }\ndiff --git a/src/Interpreters/AsynchronousMetricLog.h b/src/Interpreters/AsynchronousMetricLog.h\nindex d0f07a041b78..a31ab7eb1462 100644\n--- a/src/Interpreters/AsynchronousMetricLog.h\n+++ b/src/Interpreters/AsynchronousMetricLog.h\n@@ -24,7 +24,6 @@ struct AsynchronousMetricLogElement\n {\n     UInt16 event_date;\n     time_t event_time;\n-    Decimal64 event_time_microseconds;\n     std::string metric_name;\n     double value;\n \n@@ -32,6 +31,17 @@ struct AsynchronousMetricLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+\n+    /// Returns the list of columns as in CREATE TABLE statement or nullptr.\n+    /// If it's not nullptr, this list of columns will be used to create the table.\n+    /// Otherwise the list will be constructed from LogElement::getNamesAndTypes and LogElement::getNamesAndAliases.\n+    static const char * getCustomColumnList()\n+    {\n+        return \"event_date Date CODEC(Delta(2), ZSTD), \"\n+               \"event_time DateTime CODEC(Delta(4), ZSTD), \"\n+               \"metric LowCardinality(String) CODEC(ZSTD), \"\n+               \"value Float64 CODEC(Gorilla, ZSTD(3))\";\n+    }\n };\n \n class AsynchronousMetricLog : public SystemLog<AsynchronousMetricLogElement>\n@@ -40,6 +50,9 @@ class AsynchronousMetricLog : public SystemLog<AsynchronousMetricLogElement>\n     using SystemLog<AsynchronousMetricLogElement>::SystemLog;\n \n     void addValues(const AsynchronousMetricValues &);\n+\n+    /// This table is usually queried for fixed metric name.\n+    static const char * getDefaultOrderBy() { return \"(metric, event_date, event_time)\"; }\n };\n \n }\ndiff --git a/src/Interpreters/CrashLog.h b/src/Interpreters/CrashLog.h\nindex 930515c43ea2..f6061355562f 100644\n--- a/src/Interpreters/CrashLog.h\n+++ b/src/Interpreters/CrashLog.h\n@@ -29,6 +29,7 @@ struct CrashLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n class CrashLog : public SystemLog<CrashLogElement>\ndiff --git a/src/Interpreters/MetricLog.cpp b/src/Interpreters/MetricLog.cpp\nindex f8fab6d7a9df..8b28717ff07c 100644\n--- a/src/Interpreters/MetricLog.cpp\n+++ b/src/Interpreters/MetricLog.cpp\n@@ -78,17 +78,17 @@ void MetricLog::shutdown()\n }\n \n \n-inline UInt64 time_in_milliseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n+static inline UInt64 time_in_milliseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n {\n     return std::chrono::duration_cast<std::chrono::milliseconds>(timepoint.time_since_epoch()).count();\n }\n \n-inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n+static inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n {\n     return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();\n }\n \n-inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n+static inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n {\n     return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();\n }\ndiff --git a/src/Interpreters/MetricLog.h b/src/Interpreters/MetricLog.h\nindex 579e741c479b..44fcdced07ce 100644\n--- a/src/Interpreters/MetricLog.h\n+++ b/src/Interpreters/MetricLog.h\n@@ -30,6 +30,7 @@ struct MetricLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n \ndiff --git a/src/Interpreters/OpenTelemetrySpanLog.h b/src/Interpreters/OpenTelemetrySpanLog.h\nindex aa99a9f8e4b4..677a283bb561 100644\n--- a/src/Interpreters/OpenTelemetrySpanLog.h\n+++ b/src/Interpreters/OpenTelemetrySpanLog.h\n@@ -18,8 +18,7 @@ struct OpenTelemetrySpan\n     Array attribute_names;\n     Array attribute_values;\n     // I don't understand how Links work, namely, which direction should they\n-    // point to, and how they are related with parent_span_id, so no Links for\n-    // now.\n+    // point to, and how they are related with parent_span_id, so no Links for now.\n };\n \n struct OpenTelemetrySpanLogElement : public OpenTelemetrySpan\n@@ -32,6 +31,7 @@ struct OpenTelemetrySpanLogElement : public OpenTelemetrySpan\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases();\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n // OpenTelemetry standartizes some Log data as well, so it's not just\ndiff --git a/src/Interpreters/PartLog.cpp b/src/Interpreters/PartLog.cpp\nindex 4947b50513c8..ce9aa0c03d1b 100644\n--- a/src/Interpreters/PartLog.cpp\n+++ b/src/Interpreters/PartLog.cpp\n@@ -109,13 +109,13 @@ bool PartLog::addNewPart(\n     return addNewParts(current_context, {part}, elapsed_ns, execution_status);\n }\n \n-inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n+static inline UInt64 time_in_microseconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n {\n     return std::chrono::duration_cast<std::chrono::microseconds>(timepoint.time_since_epoch()).count();\n }\n \n \n-inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n+static inline UInt64 time_in_seconds(std::chrono::time_point<std::chrono::system_clock> timepoint)\n {\n     return std::chrono::duration_cast<std::chrono::seconds>(timepoint.time_since_epoch()).count();\n }\ndiff --git a/src/Interpreters/PartLog.h b/src/Interpreters/PartLog.h\nindex 5f502edb3397..7582f6fe9e60 100644\n--- a/src/Interpreters/PartLog.h\n+++ b/src/Interpreters/PartLog.h\n@@ -57,6 +57,7 @@ struct PartLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n class IMergeTreeDataPart;\ndiff --git a/src/Interpreters/ProcessorsProfileLog.h b/src/Interpreters/ProcessorsProfileLog.h\nindex d79ab6e5e5b6..33cb3988e9f3 100644\n--- a/src/Interpreters/ProcessorsProfileLog.h\n+++ b/src/Interpreters/ProcessorsProfileLog.h\n@@ -30,6 +30,7 @@ struct ProcessorProfileLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n class ProcessorsProfileLog : public SystemLog<ProcessorProfileLogElement>\ndiff --git a/src/Interpreters/QueryLog.h b/src/Interpreters/QueryLog.h\nindex 651769cbab65..bb912ccc8174 100644\n--- a/src/Interpreters/QueryLog.h\n+++ b/src/Interpreters/QueryLog.h\n@@ -93,6 +93,7 @@ struct QueryLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases();\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n \n     static void appendClientInfo(const ClientInfo & client_info, MutableColumns & columns, size_t & i);\n };\ndiff --git a/src/Interpreters/QueryThreadLog.h b/src/Interpreters/QueryThreadLog.h\nindex 3b260b71441d..6cdb3142ba36 100644\n--- a/src/Interpreters/QueryThreadLog.h\n+++ b/src/Interpreters/QueryThreadLog.h\n@@ -54,6 +54,7 @@ struct QueryThreadLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases();\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n \n@@ -64,5 +65,3 @@ class QueryThreadLog : public SystemLog<QueryThreadLogElement>\n \n \n }\n-\n-\ndiff --git a/src/Interpreters/QueryViewsLog.h b/src/Interpreters/QueryViewsLog.h\nindex c0936e52a1c8..dab696103da3 100644\n--- a/src/Interpreters/QueryViewsLog.h\n+++ b/src/Interpreters/QueryViewsLog.h\n@@ -79,6 +79,7 @@ struct QueryViewsLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases();\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n \ndiff --git a/src/Interpreters/SessionLog.h b/src/Interpreters/SessionLog.h\nindex 26f137565cb3..57bbbba3037b 100644\n--- a/src/Interpreters/SessionLog.h\n+++ b/src/Interpreters/SessionLog.h\n@@ -60,6 +60,7 @@ struct SessionLogElement\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n \n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n \ndiff --git a/src/Interpreters/SystemLog.cpp b/src/Interpreters/SystemLog.cpp\nindex c53b635ed6cc..862ba6d7bd96 100644\n--- a/src/Interpreters/SystemLog.cpp\n+++ b/src/Interpreters/SystemLog.cpp\n@@ -153,10 +153,12 @@ std::shared_ptr<TSystemLog> createSystemLog(\n         String ttl = config.getString(config_prefix + \".ttl\", \"\");\n         if (!ttl.empty())\n             engine += \" TTL \" + ttl;\n-        engine += \" ORDER BY (event_date, event_time)\";\n+\n+        engine += \" ORDER BY \";\n+        engine += TSystemLog::getDefaultOrderBy();\n     }\n \n-    // Validate engine definition grammatically to prevent some configuration errors\n+    /// Validate engine definition syntax to prevent some configuration errors.\n     ParserStorageWithComment storage_parser;\n     parseQuery(storage_parser, engine.data(), engine.data() + engine.size(),\n             \"Storage to create table for \" + config_prefix, 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n@@ -515,10 +517,24 @@ ASTPtr SystemLog<LogElement>::getCreateTableQuery()\n     create->setDatabase(table_id.database_name);\n     create->setTable(table_id.table_name);\n \n-    auto ordinary_columns = LogElement::getNamesAndTypes();\n-    auto alias_columns = LogElement::getNamesAndAliases();\n     auto new_columns_list = std::make_shared<ASTColumns>();\n-    new_columns_list->set(new_columns_list->columns, InterpreterCreateQuery::formatColumns(ordinary_columns, alias_columns));\n+\n+    if (const char * custom_column_list = LogElement::getCustomColumnList())\n+    {\n+        ParserColumnDeclarationList parser;\n+        const Settings & settings = getContext()->getSettingsRef();\n+\n+        ASTPtr columns_list_raw = parseQuery(parser, custom_column_list, \"columns declaration list\", settings.max_query_size, settings.max_parser_depth);\n+        new_columns_list->set(new_columns_list->columns, columns_list_raw);\n+    }\n+    else\n+    {\n+        auto ordinary_columns = LogElement::getNamesAndTypes();\n+        auto alias_columns = LogElement::getNamesAndAliases();\n+\n+        new_columns_list->set(new_columns_list->columns, InterpreterCreateQuery::formatColumns(ordinary_columns, alias_columns));\n+    }\n+\n     create->set(create->columns_list, new_columns_list);\n \n     ParserStorageWithComment storage_parser;\ndiff --git a/src/Interpreters/SystemLog.h b/src/Interpreters/SystemLog.h\nindex b5135e8a73a4..c60e14eebfe6 100644\n--- a/src/Interpreters/SystemLog.h\n+++ b/src/Interpreters/SystemLog.h\n@@ -27,6 +27,7 @@ namespace DB\n         static std::string name();\n         static NamesAndTypesList getNamesAndTypes();\n         static NamesAndAliases getNamesAndAliases();\n+        static const char * getCustomColumnList();\n         void appendToBlock(MutableColumns & columns) const;\n     };\n     */\ndiff --git a/src/Interpreters/TextLog.h b/src/Interpreters/TextLog.h\nindex 3026452fcc36..243e001fc529 100644\n--- a/src/Interpreters/TextLog.h\n+++ b/src/Interpreters/TextLog.h\n@@ -32,6 +32,7 @@ struct TextLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n class TextLog : public SystemLog<TextLogElement>\ndiff --git a/src/Interpreters/TraceLog.h b/src/Interpreters/TraceLog.h\nindex e8836955d965..43d7861327f3 100644\n--- a/src/Interpreters/TraceLog.h\n+++ b/src/Interpreters/TraceLog.h\n@@ -32,6 +32,7 @@ struct TraceLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n class TraceLog : public SystemLog<TraceLogElement>\ndiff --git a/src/Interpreters/TransactionsInfoLog.h b/src/Interpreters/TransactionsInfoLog.h\nindex f595413a7296..fc3783b59163 100644\n--- a/src/Interpreters/TransactionsInfoLog.h\n+++ b/src/Interpreters/TransactionsInfoLog.h\n@@ -42,6 +42,7 @@ struct TransactionsInfoLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n \n     void fillCommonFields(const TransactionInfoContext * context = nullptr);\n };\ndiff --git a/src/Interpreters/ZooKeeperLog.h b/src/Interpreters/ZooKeeperLog.h\nindex 733c61ba8fb7..43cdebced2d4 100644\n--- a/src/Interpreters/ZooKeeperLog.h\n+++ b/src/Interpreters/ZooKeeperLog.h\n@@ -69,6 +69,7 @@ struct ZooKeeperLogElement\n     static NamesAndTypesList getNamesAndTypes();\n     static NamesAndAliases getNamesAndAliases() { return {}; }\n     void appendToBlock(MutableColumns & columns) const;\n+    static const char * getCustomColumnList() { return nullptr; }\n };\n \n class ZooKeeperLog : public SystemLog<ZooKeeperLogElement>\n",
  "test_patch": "diff --git a/tests/integration/test_asynchronous_metric_log_table/test.py b/tests/integration/test_asynchronous_metric_log_table/test.py\nindex 96de7daf9e1e..622620e232aa 100644\n--- a/tests/integration/test_asynchronous_metric_log_table/test.py\n+++ b/tests/integration/test_asynchronous_metric_log_table/test.py\n@@ -21,7 +21,7 @@ def started_cluster():\n         cluster.shutdown()\n \n \n-# Tests that the event_time_microseconds field in system.asynchronous_metric_log table gets populated.\n+# Tests that the system.asynchronous_metric_log table gets populated.\n # asynchronous metrics are updated once every 60s by default. To make the test run faster, the setting\n # asynchronous_metric_update_period_s is being set to 2s so that the metrics are populated faster and\n # are available for querying during the test.\n@@ -42,21 +42,10 @@ def test_event_time_microseconds_field(started_cluster):\n         node1.query(query_create)\n         node1.query(\"\"\"INSERT INTO replica.test VALUES (1, now())\"\"\")\n         node1.query(\"SYSTEM FLUSH LOGS;\")\n-        # query assumes that the event_time field is accurate\n-        equals_query = \"\"\"WITH (\n-                            (\n-                                SELECT event_time_microseconds\n-                                FROM system.asynchronous_metric_log\n-                                ORDER BY event_time DESC\n-                                LIMIT 1\n-                            ) AS time_with_microseconds,\n-                            (\n-                                SELECT event_time\n-                                FROM system.asynchronous_metric_log\n-                                ORDER BY event_time DESC\n-                                LIMIT 1\n-                            ) AS time)\n-                        SELECT if(dateDiff('second', toDateTime(time_with_microseconds), toDateTime(time)) = 0, 'ok', 'fail')\"\"\"\n-        assert \"ok\\n\" in node1.query(equals_query)\n+\n+        test_query = (\n+            \"SELECT count() > 0 ? 'ok' : 'fail' FROM system.asynchronous_metric_log\"\n+        )\n+        assert \"ok\\n\" in node1.query(test_query)\n     finally:\n         cluster.shutdown()\n",
  "problem_statement": "Choose a decent codec for system.asynchronous_metric_log\n```\r\nplay-eu :) SELECT name, type, data_compressed_bytes, data_uncompressed_bytes, data_uncompressed_bytes / data_compressed_bytes AS ratio FROM system.columns WHERE table = 'asynchronous_metric_log'\r\n\r\nSELECT\r\n    name,\r\n    type,\r\n    data_compressed_bytes,\r\n    data_uncompressed_bytes,\r\n    data_uncompressed_bytes / data_compressed_bytes AS ratio\r\nFROM system.columns\r\nWHERE table = 'asynchronous_metric_log'\r\n\r\nQuery id: 7920a1ca-2cd3-4adc-a389-aceb2d2ef117\r\n\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500data_compressed_bytes\u2500\u252c\u2500data_uncompressed_bytes\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ratio\u2500\u2510\r\n\u2502 event_date              \u2502 Date                   \u2502              50191963 \u2502             11226421168 \u2502 223.66969723818133 \u2502\r\n\u2502 event_time              \u2502 DateTime               \u2502             122579348 \u2502             22452842336 \u2502 183.16986264276753 \u2502\r\n\u2502 event_time_microseconds \u2502 DateTime64(6)          \u2502             248282292 \u2502             44905684672 \u2502 180.86543470446134 \u2502\r\n\u2502 metric                  \u2502 LowCardinality(String) \u2502             486369012 \u2502             11245322027 \u2502 23.120967309899257 \u2502\r\n\u2502 value                   \u2502 Float64                \u2502            5124740586 \u2502             44905684672 \u2502  8.762528350152083 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nmetric and value probably should use ZSTD.\n",
  "hints_text": "Primary key should be (metric, event_date, event_time)\nBetter get rid of `event_time_microseconds`, it costs a lot.\n```\r\nCREATE TABLE asynchronous_metric_log2\r\n(\r\n    `event_date` Date CODEC(Delta, ZSTD),\r\n    `event_time` DateTime CODEC(Delta, ZSTD),\r\n    `metric` LowCardinality(String) CODEC(ZSTD),\r\n    `value` Float64 CODEC(Gorilla, ZSTD(3))\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toYYYYMM(event_date)\r\nORDER BY (metric, event_date, event_time);\r\n\r\n\r\nSELECT\r\n    name,\r\n    type,\r\n    data_compressed_bytes,\r\n    data_uncompressed_bytes,\r\n    data_uncompressed_bytes / data_compressed_bytes AS ratio\r\nFROM system.columns\r\nWHERE table = 'asynchronous_metric_log'\r\n\r\nQuery id: b52186ed-b273-4d12-bff1-162f98bf8db1\r\n\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500data_compressed_bytes\u2500\u252c\u2500data_uncompressed_bytes\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ratio\u2500\u2510\r\n\u2502 event_date              \u2502 Date                   \u2502              50206100 \u2502             11229585516 \u2502  223.6697436367294 \u2502\r\n\u2502 event_time              \u2502 DateTime               \u2502             122613788 \u2502             22459171032 \u2502  183.1700284147489 \u2502\r\n\u2502 metric                  \u2502 LowCardinality(String) \u2502             486506605 \u2502             11248492397 \u2502 23.120944878024833 \u2502\r\n\u2502 value                   \u2502 Float64                \u2502            5126384378 \u2502             44918342064 \u2502   8.76218768470974 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nIf we convert value to Float32 it will take 1433794957 instead of 5126384378 bytes.\nBut Float32 cannot accomodate small changes in byte sizes for data volume.\r\nAnother option is to round value to three significant digits: then it will take just 625625696 bytes.\nYes, rounding is reasonable: https://pastila.nl/?0314cd85/41e7f1c796abb8e33130dd692d76a2a6",
  "created_at": "2022-04-17T21:56:19Z"
}