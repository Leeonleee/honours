{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58214,
  "instance_id": "ClickHouse__ClickHouse-58214",
  "issue_numbers": [
    "57937"
  ],
  "base_commit": "a0fccb04989467edf8f8f0665125b079547d0e32",
  "patch": "diff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\nindex 371c0a075117..59b3b0366988 100644\n--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\n+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp\n@@ -250,13 +250,13 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n \n         if (function_node->getFunctionName() == \"and\")\n         {\n-            tryReplaceAndEqualsChainsWithConstant(node);\n+            tryOptimizeAndEqualsNotEqualsChain(node);\n             return;\n         }\n     }\n \n private:\n-    void tryReplaceAndEqualsChainsWithConstant(QueryTreeNodePtr & node)\n+    void tryOptimizeAndEqualsNotEqualsChain(QueryTreeNodePtr & node)\n     {\n         auto & function_node = node->as<FunctionNode &>();\n         assert(function_node.getFunctionName() == \"and\");\n@@ -266,53 +266,132 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n \n         QueryTreeNodes and_operands;\n \n-        QueryTreeNodePtrWithHashMap<const ConstantNode *> node_to_constants;\n+        QueryTreeNodePtrWithHashMap<const ConstantNode *> equals_node_to_constants;\n+        QueryTreeNodePtrWithHashMap<QueryTreeNodeConstRawPtrWithHashSet> not_equals_node_to_constants;\n+        QueryTreeNodePtrWithHashMap<QueryTreeNodes> node_to_not_equals_functions;\n \n         for (const auto & argument : function_node.getArguments())\n         {\n             auto * argument_function = argument->as<FunctionNode>();\n-            if (!argument_function || argument_function->getFunctionName() != \"equals\")\n+            const auto valid_functions = std::unordered_set<std::string>{\"equals\", \"notEquals\"};\n+            if (!argument_function || !valid_functions.contains(argument_function->getFunctionName()))\n             {\n                 and_operands.push_back(argument);\n                 continue;\n             }\n \n-            const auto & equals_arguments = argument_function->getArguments().getNodes();\n-            const auto & lhs = equals_arguments[0];\n-            const auto & rhs = equals_arguments[1];\n+            const auto function_name = argument_function->getFunctionName();\n+            const auto & function_arguments = argument_function->getArguments().getNodes();\n+            const auto & lhs = function_arguments[0];\n+            const auto & rhs = function_arguments[1];\n \n-            const auto has_and_with_different_constant = [&](const QueryTreeNodePtr & expression, const ConstantNode * constant)\n+            if (function_name == \"equals\")\n             {\n-                if (auto it = node_to_constants.find(expression); it != node_to_constants.end())\n+                const auto has_and_with_different_constant = [&](const QueryTreeNodePtr & expression, const ConstantNode * constant)\n                 {\n-                    if (!it->second->isEqual(*constant))\n-                        return true;\n-                }\n+                    if (auto it = equals_node_to_constants.find(expression); it != equals_node_to_constants.end())\n+                    {\n+                        if (!it->second->isEqual(*constant))\n+                            return true;\n+                    }\n+                    else\n+                    {\n+                        equals_node_to_constants.emplace(expression, constant);\n+                        and_operands.push_back(argument);\n+                    }\n+\n+                    return false;\n+                };\n+\n+                bool collapse_to_false = false;\n+\n+                if (const auto * lhs_literal = lhs->as<ConstantNode>())\n+                    collapse_to_false = has_and_with_different_constant(rhs, lhs_literal);\n+                else if (const auto * rhs_literal = rhs->as<ConstantNode>())\n+                    collapse_to_false = has_and_with_different_constant(lhs, rhs_literal);\n                 else\n-                {\n-                    node_to_constants.emplace(expression, constant);\n                     and_operands.push_back(argument);\n+\n+                if (collapse_to_false)\n+                {\n+                    auto false_value = std::make_shared<ConstantValue>(0u, function_node.getResultType());\n+                    auto false_node = std::make_shared<ConstantNode>(std::move(false_value));\n+                    node = std::move(false_node);\n+                    return;\n                 }\n+            }\n+            else if (function_name == \"notEquals\")\n+            {\n+                 /// collect all inequality checks (x <> value)\n \n-                return false;\n-            };\n+                const auto add_not_equals_function_if_not_present = [&](const auto & expression_node, const ConstantNode * constant)\n+                {\n+                    auto & constant_set = not_equals_node_to_constants[expression_node];\n+                    if (!constant_set.contains(constant))\n+                    {\n+                        constant_set.insert(constant);\n+                        node_to_not_equals_functions[expression_node].push_back(argument);\n+                    }\n+                };\n+\n+                if (const auto * lhs_literal = lhs->as<ConstantNode>();\n+                    lhs_literal && !lhs_literal->getValue().isNull())\n+                    add_not_equals_function_if_not_present(rhs, lhs_literal);\n+                else if (const auto * rhs_literal = rhs->as<ConstantNode>();\n+                        rhs_literal && !rhs_literal->getValue().isNull())\n+                    add_not_equals_function_if_not_present(lhs, rhs_literal);\n+                else\n+                    and_operands.push_back(argument);\n+            }\n+            else\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected function name: '{}'\", function_name);\n+        }\n \n-            bool collapse_to_false = false;\n+        auto not_in_function_resolver = FunctionFactory::instance().get(\"notIn\", getContext());\n \n-            if (const auto * lhs_literal = lhs->as<ConstantNode>())\n-                collapse_to_false = has_and_with_different_constant(rhs, lhs_literal);\n-            else if (const auto * rhs_literal = rhs->as<ConstantNode>())\n-                collapse_to_false = has_and_with_different_constant(lhs, rhs_literal);\n-            else\n-                and_operands.push_back(argument);\n+        for (auto & [expression, not_equals_functions] : node_to_not_equals_functions)\n+        {\n+            const auto & settings = getSettings();\n+            if (not_equals_functions.size() < settings.optimize_min_inequality_conjunction_chain_length && !expression.node->getResultType()->lowCardinality())\n+            {\n+                std::move(not_equals_functions.begin(), not_equals_functions.end(), std::back_inserter(and_operands));\n+                continue;\n+            }\n \n-            if (collapse_to_false)\n+            Tuple args;\n+            args.reserve(not_equals_functions.size());\n+            /// first we create tuple from RHS of notEquals functions\n+            for (const auto & not_equals : not_equals_functions)\n             {\n-                auto false_value = std::make_shared<ConstantValue>(0u, function_node.getResultType());\n-                auto false_node = std::make_shared<ConstantNode>(std::move(false_value));\n-                node = std::move(false_node);\n-                return;\n+                const auto * not_equals_function = not_equals->as<FunctionNode>();\n+                assert(not_equals_function && not_equals_function->getFunctionName() == \"notEquals\");\n+\n+                const auto & not_equals_arguments = not_equals_function->getArguments().getNodes();\n+                if (const auto * rhs_literal = not_equals_arguments[1]->as<ConstantNode>())\n+                {\n+                    args.push_back(rhs_literal->getValue());\n+                }\n+                else\n+                {\n+                    const auto * lhs_literal = not_equals_arguments[0]->as<ConstantNode>();\n+                    assert(lhs_literal);\n+                    args.push_back(lhs_literal->getValue());\n+                }\n             }\n+\n+            auto rhs_node = std::make_shared<ConstantNode>(std::move(args));\n+\n+            auto not_in_function = std::make_shared<FunctionNode>(\"notIn\");\n+\n+            QueryTreeNodes not_in_arguments;\n+            not_in_arguments.reserve(2);\n+            not_in_arguments.push_back(expression.node);\n+            not_in_arguments.push_back(std::move(rhs_node));\n+\n+            not_in_function->getArguments().getNodes() = std::move(not_in_arguments);\n+            not_in_function->resolveAsFunction(not_in_function_resolver);\n+\n+            and_operands.push_back(std::move(not_in_function));\n         }\n \n         if (and_operands.size() == function_node.getArguments().getNodes().size())\n@@ -322,9 +401,6 @@ class LogicalExpressionOptimizerVisitor : public InDepthQueryTreeVisitorWithCont\n         {\n             /// AND operator can have UInt8 or bool as its type.\n             /// bool is used if a bool constant is at least one operand.\n-            /// Because we reduce the number of operands here by eliminating the same equality checks,\n-            /// the only situation we can end up here is we had AND check where all the equality checks are the same so we know the type is UInt8.\n-            /// Otherwise, we will have > 1 operands and we don't have to do anything.\n \n             auto operand_type = and_operands[0]->getResultType();\n             auto function_type = function_node.getResultType();\ndiff --git a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h\nindex 80062f38eacd..658f6d767c4e 100644\n--- a/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h\n+++ b/src/Analyzer/Passes/LogicalExpressionOptimizerPass.h\n@@ -68,7 +68,25 @@ namespace DB\n  * WHERE a = 1 AND b = 'test';\n  * -------------------------------\n  *\n- * 5. Remove unnecessary IS NULL checks in JOIN ON clause\n+ * 5. Replaces chains of inequality functions inside an AND with a single NOT IN operator.\n+ * The replacement is done if:\n+ *  - one of the operands of the inequality function is a constant\n+ *  - length of chain is at least 'optimize_min_inequality_conjunction_chain_length' long OR the expression has type of LowCardinality\n+ *\n+ * E.g. (optimize_min_inequality_conjunction_chain_length = 2)\n+ * -------------------------------\n+ * SELECT *\n+ * FROM table\n+ * WHERE a <> 1 AND a <> 2;\n+ *\n+ * will be transformed into\n+ *\n+ * SELECT *\n+ * FROM TABLE\n+ * WHERE a NOT IN (1, 2);\n+ * -------------------------------\n+ *\n+ * 6. Remove unnecessary IS NULL checks in JOIN ON clause\n  *   - equality check with explicit IS NULL check replaced with <=> operator\n  * -------------------------------\n  * SELECT * FROM t1 JOIN t2 ON a = b OR (a IS NULL AND b IS NULL)\n@@ -85,7 +103,11 @@ class LogicalExpressionOptimizerPass final : public IQueryTreePass\n public:\n     String getName() override { return \"LogicalExpressionOptimizer\"; }\n \n-    String getDescription() override { return \"Transform equality chain to a single IN function or a constant if possible\"; }\n+    String getDescription() override\n+    {\n+        return \"Transforms chains of logical expressions if possible, i.e. \"\n+            \"replace chains of equality functions inside an OR with a single IN operator\";\n+    }\n \n     void run(QueryTreeNodePtr query_tree_node, ContextPtr context) override;\n };\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex b75004a33966..2a56fc0cce52 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -219,6 +219,7 @@ class IColumn;\n     M(Bool, mysql_map_fixed_string_to_text_in_show_columns, false, \"If enabled, FixedString type will be mapped to TEXT in SHOW [FULL] COLUMNS, BLOB otherwise.\", 0) \\\n     \\\n     M(UInt64, optimize_min_equality_disjunction_chain_length, 3, \"The minimum length of the expression `expr = x1 OR ... expr = xN` for optimization \", 0) \\\n+    M(UInt64, optimize_min_inequality_conjunction_chain_length, 3, \"The minimum length of the expression `expr <> x1 AND ... expr <> xN` for optimization \", 0) \\\n     \\\n     M(UInt64, min_bytes_to_use_direct_io, 0, \"The minimum number of bytes for reading the data with O_DIRECT option during SELECT queries execution. 0 - disabled.\", 0) \\\n     M(UInt64, min_bytes_to_use_mmap_io, 0, \"The minimum number of bytes for reading the data with mmap option during SELECT queries execution. 0 - disabled.\", 0) \\\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.reference b/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.reference\nindex 84589668d64a..ff5f7e5a6877 100644\n--- a/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.reference\n+++ b/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.reference\n@@ -36,6 +36,42 @@ QUERY id: 0\n   SETTINGS allow_experimental_analyzer=1\n SELECT a\n FROM t_logical_expressions_optimizer_low_cardinality\n+WHERE (a != \\'x\\') AND (a != \\'y\\')\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a LowCardinality(String)\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      COLUMN id: 2, column_name: a, result_type: LowCardinality(String), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.t_logical_expressions_optimizer_low_cardinality\n+  WHERE\n+    FUNCTION id: 4, function_name: notIn, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 2, column_name: a, result_type: LowCardinality(String), source_id: 3\n+          CONSTANT id: 6, constant_value: Tuple_(\\'x\\', \\'y\\'), constant_value_type: Tuple(String, String)\n+  SETTINGS allow_experimental_analyzer=1\n+SELECT a\n+FROM t_logical_expressions_optimizer_low_cardinality\n+WHERE (a != \\'x\\') AND (\\'y\\' != a)\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a LowCardinality(String)\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      COLUMN id: 2, column_name: a, result_type: LowCardinality(String), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.t_logical_expressions_optimizer_low_cardinality\n+  WHERE\n+    FUNCTION id: 4, function_name: notIn, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          COLUMN id: 2, column_name: a, result_type: LowCardinality(String), source_id: 3\n+          CONSTANT id: 6, constant_value: Tuple_(\\'x\\', \\'y\\'), constant_value_type: Tuple(String, String)\n+  SETTINGS allow_experimental_analyzer=1\n+SELECT a\n+FROM t_logical_expressions_optimizer_low_cardinality\n WHERE (b = 0) OR (b = 1)\n QUERY id: 0\n   PROJECTION COLUMNS\n@@ -60,3 +96,29 @@ QUERY id: 0\n                 COLUMN id: 8, column_name: b, result_type: UInt32, source_id: 3\n                 CONSTANT id: 12, constant_value: UInt64_1, constant_value_type: UInt8\n   SETTINGS allow_experimental_analyzer=1\n+SELECT a\n+FROM t_logical_expressions_optimizer_low_cardinality\n+WHERE (b != 0) AND (b != 1)\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a LowCardinality(String)\n+  PROJECTION\n+    LIST id: 1, nodes: 1\n+      COLUMN id: 2, column_name: a, result_type: LowCardinality(String), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.t_logical_expressions_optimizer_low_cardinality\n+  WHERE\n+    FUNCTION id: 4, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 5, nodes: 2\n+          FUNCTION id: 6, function_name: notEquals, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 7, nodes: 2\n+                COLUMN id: 8, column_name: b, result_type: UInt32, source_id: 3\n+                CONSTANT id: 9, constant_value: UInt64_0, constant_value_type: UInt8\n+          FUNCTION id: 10, function_name: notEquals, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 11, nodes: 2\n+                COLUMN id: 8, column_name: b, result_type: UInt32, source_id: 3\n+                CONSTANT id: 12, constant_value: UInt64_1, constant_value_type: UInt8\n+  SETTINGS allow_experimental_analyzer=1\ndiff --git a/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.sql b/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.sql\nindex 14f8ad830e75..976b21a7e29d 100644\n--- a/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.sql\n+++ b/tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.sql\n@@ -2,13 +2,24 @@ DROP TABLE IF EXISTS t_logical_expressions_optimizer_low_cardinality;\n set optimize_min_equality_disjunction_chain_length=3;\n CREATE TABLE t_logical_expressions_optimizer_low_cardinality (a LowCardinality(String), b UInt32) ENGINE = Memory;\n \n--- LowCardinality case, ignore optimize_min_equality_disjunction_chain_length limit, optimzer applied\n+-- LowCardinality case, ignore optimize_min_equality_disjunction_chain_length limit, optimizer applied\n+-- Chain of OR equals\n EXPLAIN SYNTAX SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a = 'x' OR a = 'y';\n EXPLAIN QUERY TREE SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a = 'x' OR a = 'y' SETTINGS allow_experimental_analyzer = 1;\n EXPLAIN SYNTAX SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a = 'x' OR 'y' = a;\n EXPLAIN QUERY TREE SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a = 'x' OR 'y' = a SETTINGS allow_experimental_analyzer = 1;\n+-- Chain of AND notEquals\n+EXPLAIN SYNTAX SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a <> 'x' AND a <> 'y';\n+EXPLAIN QUERY TREE SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a <> 'x' AND a <> 'y' SETTINGS allow_experimental_analyzer = 1;\n+EXPLAIN SYNTAX SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a <> 'x' AND 'y' <> a;\n+EXPLAIN QUERY TREE SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE a <> 'x' AND 'y' <> a SETTINGS allow_experimental_analyzer = 1;\n+\n -- Non-LowCardinality case, optimizer not applied for short chains\n+-- Chain of OR equals\n EXPLAIN SYNTAX SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE b = 0 OR b = 1;\n EXPLAIN QUERY TREE SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE b = 0 OR b = 1 SETTINGS allow_experimental_analyzer = 1;\n+-- Chain of AND notEquals\n+EXPLAIN SYNTAX SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE b <> 0 AND b <> 1;\n+EXPLAIN QUERY TREE SELECT a FROM t_logical_expressions_optimizer_low_cardinality WHERE b <> 0 AND b <> 1 SETTINGS allow_experimental_analyzer = 1;\n \n DROP TABLE t_logical_expressions_optimizer_low_cardinality;\ndiff --git a/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.reference b/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.reference\nindex cc74b0237fee..089d1849eb4a 100644\n--- a/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.reference\n+++ b/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.reference\n@@ -87,5 +87,40 @@ QUERY id: 0\n         LIST id: 6, nodes: 2\n           COLUMN id: 7, column_name: a, result_type: Int32, source_id: 3\n           CONSTANT id: 8, constant_value: UInt64_2, constant_value_type: UInt8\n+2\ttest2\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b LowCardinality(String)\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: LowCardinality(String), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02668_logical_optimizer\n+  WHERE\n+    FUNCTION id: 5, function_name: notIn, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          COLUMN id: 7, column_name: a, result_type: Int32, source_id: 3\n+          CONSTANT id: 8, constant_value: Tuple_(UInt64_1, UInt64_3), constant_value_type: Tuple(UInt8, UInt8)\n+2\ttest2\n+3\tanother\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b LowCardinality(String)\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: LowCardinality(String), source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02668_logical_optimizer\n+  WHERE\n+    FUNCTION id: 5, function_name: notEquals, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          COLUMN id: 7, column_name: a, result_type: Int32, source_id: 3\n+          CONSTANT id: 8, constant_value: UInt64_1, constant_value_type: UInt8\n 1\n 1\ndiff --git a/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.sql b/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.sql\nindex 5dee450086c0..7d624195df9b 100644\n--- a/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.sql\n+++ b/tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.sql\n@@ -8,6 +8,7 @@ ENGINE=Memory;\n \n INSERT INTO 02668_logical_optimizer VALUES (1, 'test'), (2, 'test2'), (3, 'another');\n \n+-- Chain of OR equals\n SET optimize_min_equality_disjunction_chain_length = 2;\n \n SELECT * FROM 02668_logical_optimizer WHERE a = 1 OR 3 = a OR 1 = a;\n@@ -16,6 +17,7 @@ EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a = 1 OR 3 = a OR\n SELECT * FROM 02668_logical_optimizer WHERE a = 1 OR 1 = a;\n EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a = 1 OR 1 = a;\n \n+-- Chain of AND equals\n SELECT * FROM 02668_logical_optimizer WHERE a = 1 AND 2 = a;\n EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a = 1 AND 2 = a;\n \n@@ -25,6 +27,15 @@ EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a = 3 AND b = 'an\n SELECT * FROM 02668_logical_optimizer WHERE a = 2 AND 2 = a;\n EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a = 2 AND 2 = a;\n \n+-- Chain of AND notEquals\n+SET optimize_min_inequality_conjunction_chain_length = 2;\n+\n+SELECT * FROM 02668_logical_optimizer WHERE a <> 1 AND 3 <> a AND 1 <> a;\n+EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a <> 1 AND 3 <> a AND 1 <> a;\n+\n+SELECT * FROM 02668_logical_optimizer WHERE a <> 1 AND 1 <> a;\n+EXPLAIN QUERY TREE SELECT * FROM 02668_logical_optimizer WHERE a <> 1 AND 1 <> a;\n+\n SELECT a FROM 02668_logical_optimizer WHERE (b = 'test') AND ('test' = b);\n \n SELECT (k = 3) OR ( (k = 1) OR (k = 2) OR ( (NULL OR 1) = k ) ) FROM ( SELECT materialize(1) AS k );\ndiff --git a/tests/queries/0_stateless/02952_conjunction_optimization.reference b/tests/queries/0_stateless/02952_conjunction_optimization.reference\nnew file mode 100644\nindex 000000000000..64663cea6620\n--- /dev/null\n+++ b/tests/queries/0_stateless/02952_conjunction_optimization.reference\n@@ -0,0 +1,117 @@\n+3\tanother\n+3\t\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b String\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: String, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02952_disjunction_optimization\n+  WHERE\n+    FUNCTION id: 5, function_name: notIn, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          COLUMN id: 7, column_name: a, result_type: Int32, source_id: 3\n+          CONSTANT id: 8, constant_value: Tuple_(UInt64_1, UInt64_2, UInt64_4), constant_value_type: Tuple(UInt8, UInt8, UInt8)\n+3\tanother\n+3\t\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b String\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: String, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02952_disjunction_optimization\n+  WHERE\n+    FUNCTION id: 5, function_name: and, function_type: ordinary, result_type: Bool\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          CONSTANT id: 7, constant_value: UInt64_1, constant_value_type: Bool\n+          FUNCTION id: 8, function_name: notIn, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 9, nodes: 2\n+                COLUMN id: 10, column_name: a, result_type: Int32, source_id: 3\n+                CONSTANT id: 11, constant_value: Tuple_(UInt64_1, UInt64_2, UInt64_4), constant_value_type: Tuple(UInt8, UInt8, UInt8)\n+3\tanother\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b String\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: String, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02952_disjunction_optimization\n+  WHERE\n+    FUNCTION id: 5, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          FUNCTION id: 7, function_name: notEquals, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: b, result_type: String, source_id: 3\n+                CONSTANT id: 10, constant_value: \\'\\', constant_value_type: String\n+          FUNCTION id: 11, function_name: notIn, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 12, nodes: 2\n+                COLUMN id: 13, column_name: a, result_type: Int32, source_id: 3\n+                CONSTANT id: 14, constant_value: Tuple_(UInt64_1, UInt64_2, UInt64_4), constant_value_type: Tuple(UInt8, UInt8, UInt8)\n+3\t\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b String\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: String, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02952_disjunction_optimization\n+  WHERE\n+    FUNCTION id: 5, function_name: and, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          FUNCTION id: 7, function_name: equals, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: b, result_type: String, source_id: 3\n+                CONSTANT id: 10, constant_value: \\'\\', constant_value_type: String\n+          FUNCTION id: 11, function_name: notIn, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 12, nodes: 2\n+                COLUMN id: 13, column_name: a, result_type: Int32, source_id: 3\n+                CONSTANT id: 14, constant_value: Tuple_(UInt64_1, UInt64_2, UInt64_4), constant_value_type: Tuple(UInt8, UInt8, UInt8)\n+3\tanother\n+3\t\n+4\t\n+QUERY id: 0\n+  PROJECTION COLUMNS\n+    a Int32\n+    b String\n+  PROJECTION\n+    LIST id: 1, nodes: 2\n+      COLUMN id: 2, column_name: a, result_type: Int32, source_id: 3\n+      COLUMN id: 4, column_name: b, result_type: String, source_id: 3\n+  JOIN TREE\n+    TABLE id: 3, table_name: default.02952_disjunction_optimization\n+  WHERE\n+    FUNCTION id: 5, function_name: or, function_type: ordinary, result_type: UInt8\n+      ARGUMENTS\n+        LIST id: 6, nodes: 2\n+          FUNCTION id: 7, function_name: notIn, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 8, nodes: 2\n+                COLUMN id: 9, column_name: a, result_type: Int32, source_id: 3\n+                CONSTANT id: 10, constant_value: Tuple_(UInt64_1, UInt64_2, UInt64_4), constant_value_type: Tuple(UInt8, UInt8, UInt8)\n+          FUNCTION id: 11, function_name: equals, function_type: ordinary, result_type: UInt8\n+            ARGUMENTS\n+              LIST id: 12, nodes: 2\n+                COLUMN id: 13, column_name: b, result_type: String, source_id: 3\n+                CONSTANT id: 14, constant_value: \\'\\', constant_value_type: String\ndiff --git a/tests/queries/0_stateless/02952_conjunction_optimization.sql b/tests/queries/0_stateless/02952_conjunction_optimization.sql\nnew file mode 100644\nindex 000000000000..94bc352e4c5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02952_conjunction_optimization.sql\n@@ -0,0 +1,26 @@\n+SET allow_experimental_analyzer = 1;\n+\n+DROP TABLE IF EXISTS 02952_disjunction_optimization;\n+\n+CREATE TABLE 02952_disjunction_optimization\n+(a Int32, b String)\n+ENGINE=Memory;\n+\n+INSERT INTO 02952_disjunction_optimization VALUES (1, 'test'), (2, 'test2'), (3, 'another'), (3, ''), (4, '');\n+\n+SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND a <> 4;\n+EXPLAIN QUERY TREE SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND a <> 4;\n+\n+SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND a <> 4 AND true;\n+EXPLAIN QUERY TREE SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND a <> 4 AND true;\n+\n+SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND a <> 4 AND b <> '';\n+EXPLAIN QUERY TREE SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND a <> 4 AND b <> '';\n+\n+SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND b = '' AND a <> 4;\n+EXPLAIN QUERY TREE SELECT * FROM 02952_disjunction_optimization WHERE a <> 1 AND a <> 2 AND b = '' AND a <> 4;\n+\n+SELECT * FROM 02952_disjunction_optimization WHERE (a <> 1 AND a <> 2 AND a <> 4) OR b = '';\n+EXPLAIN QUERY TREE SELECT * FROM 02952_disjunction_optimization WHERE (a <> 1 AND a <> 2 AND a <> 4) OR b = '';\n+\n+DROP TABLE 02952_disjunction_optimization;\n",
  "problem_statement": "notEquals(x, 1) AND notEquals(x, 2) AND notEquals(x, 3) chain rewrite to x NOT IN (1, 2, 3)\n**Use case**\r\n\r\nOptimization for long chain of `AND notEquals` condition, analogue for already existing `OR equals` optimization.\r\n\r\n\n",
  "hints_text": "Hi, I'm interested in contributing to this feature.\nHi,\r\n\r\nYou can take a look into: \r\nhttps://github.com/ClickHouse/ClickHouse/blob/84e5870b71c3771828a1c5ea7d71b330d9b75889/src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp#L336C10-L336C39\r\n\r\nWhich implements similar optimization for `OR equals`. Null literals should be ignored, AFAIK.\r\n\r\n\nGot it, thank you for the reference.",
  "created_at": "2023-12-24T13:36:35Z",
  "modified_files": [
    "src/Analyzer/Passes/LogicalExpressionOptimizerPass.cpp",
    "src/Analyzer/Passes/LogicalExpressionOptimizerPass.h",
    "src/Core/Settings.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.reference",
    "tests/queries/0_stateless/02477_logical_expressions_optimizer_low_cardinality.sql",
    "tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.reference",
    "tests/queries/0_stateless/02668_logical_optimizer_removing_redundant_checks.sql",
    "b/tests/queries/0_stateless/02952_conjunction_optimization.reference",
    "b/tests/queries/0_stateless/02952_conjunction_optimization.sql"
  ]
}