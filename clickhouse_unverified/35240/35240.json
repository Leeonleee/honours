{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35240,
  "instance_id": "ClickHouse__ClickHouse-35240",
  "issue_numbers": [
    "5799",
    "35156",
    "22825"
  ],
  "base_commit": "2211e016cbc717399e81979eea7c2d8d35afd097",
  "patch": "diff --git a/docs/en/sql-reference/functions/ip-address-functions.md b/docs/en/sql-reference/functions/ip-address-functions.md\nindex 469a66d460fa..cf3f92580aa8 100644\n--- a/docs/en/sql-reference/functions/ip-address-functions.md\n+++ b/docs/en/sql-reference/functions/ip-address-functions.md\n@@ -13,10 +13,18 @@ Alias: `INET_NTOA`.\n \n ## IPv4StringToNum(s) {#ipv4stringtonums}\n \n-The reverse function of IPv4NumToString. If the IPv4 address has an invalid format, it returns 0.\n+The reverse function of IPv4NumToString. If the IPv4 address has an invalid format, it throws exception.\n \n Alias: `INET_ATON`.\n \n+## IPv4StringToNumOrDefault(s) {#ipv4stringtonums}\n+\n+Same as `IPv4StringToNum`, but if the IPv4 address has an invalid format, it returns 0.\n+\n+## IPv4StringToNumOrNull(s) {#ipv4stringtonums}\n+\n+Same as `IPv4StringToNum`, but if the IPv4 address has an invalid format, it returns null.\n+\n ## IPv4NumToStringClassC(num) {#ipv4numtostringclasscnum}\n \n Similar to IPv4NumToString, but using xxx instead of the last octet.\n@@ -123,7 +131,7 @@ LIMIT 10\n \n ## IPv6StringToNum {#ipv6stringtonums}\n \n-The reverse function of [IPv6NumToString](#ipv6numtostringx). If the IPv6 address has an invalid format, it returns a string of null bytes.\n+The reverse function of [IPv6NumToString](#ipv6numtostringx). If the IPv6 address has an invalid format, it throws exception.\n \n If the input string contains a valid IPv4 address, returns its IPv6 equivalent.\n HEX can be uppercase or lowercase.\n@@ -168,6 +176,14 @@ Result:\n \n -   [cutIPv6](#cutipv6x-bytestocutforipv6-bytestocutforipv4).\n \n+## IPv6StringToNumOrDefault(s) {#ipv6stringtonums}\n+\n+Same as `IPv6StringToNum`, but if the IPv6 address has an invalid format, it returns 0.\n+\n+## IPv6StringToNumOrNull(s) {#ipv6stringtonums}\n+\n+Same as `IPv6StringToNum`, but if the IPv6 address has an invalid format, it returns null.\n+\n ## IPv4ToIPv6(x) {#ipv4toipv6x}\n \n Takes a `UInt32` number. Interprets it as an IPv4 address in [big endian](https://en.wikipedia.org/wiki/Endianness). Returns a `FixedString(16)` value containing the IPv6 address in binary format. Examples:\n@@ -261,6 +277,14 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toIPv4OrDefault(string) {#toipv4ordefaultstring}\n+\n+Same as `toIPv4`, but if the IPv4 address has an invalid format, it returns 0.\n+\n+## toIPv4OrNull(string) {#toipv4ornullstring}\n+\n+Same as `toIPv4`, but if the IPv4 address has an invalid format, it returns null.\n+\n ## toIPv6 {#toipv6string}\n \n Converts a string form of IPv6 address to [IPv6](../../sql-reference/data-types/domains/ipv6.md) type. If the IPv6 address has an invalid format, returns an empty value.\n@@ -317,6 +341,14 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## IPv6StringToNumOrDefault(s) {#toipv6ordefaultstring}\n+\n+Same as `toIPv6`, but if the IPv6 address has an invalid format, it returns 0.\n+\n+## IPv6StringToNumOrNull(s) {#toipv6ornullstring}\n+\n+Same as `toIPv6`, but if the IPv6 address has an invalid format, it returns null.\n+\n ## isIPv4String {#isipv4string}\n \n Determines whether the input string is an IPv4 address or not. If `string` is IPv6 address returns `0`.\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 15ae646ab378..42a3f3797ff8 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -471,6 +471,7 @@ class IColumn;\n     M(Bool, allow_experimental_geo_types, false, \"Allow geo data types such as Point, Ring, Polygon, MultiPolygon\", 0) \\\n     M(Bool, data_type_default_nullable, false, \"Data types without NULL or NOT NULL will make Nullable\", 0) \\\n     M(Bool, cast_keep_nullable, false, \"CAST operator keep Nullable for result data type\", 0) \\\n+    M(Bool, cast_ipv4_ipv6_default_on_conversion_error, false, \"CAST operator into IPv4, CAST operator into IPV6 type, toIPv4, toIPv6 functions will return default value instead of throwing exception on conversion error.\", 0) \\\n     M(Bool, alter_partition_verbose_result, false, \"Output information about affected parts. Currently works only for FREEZE and ATTACH commands.\", 0) \\\n     M(Bool, allow_experimental_database_materialized_mysql, false, \"Allow to create database with Engine=MaterializedMySQL(...).\", 0) \\\n     M(Bool, allow_experimental_database_materialized_postgresql, false, \"Allow to create database with Engine=MaterializedPostgreSQL(...).\", 0) \\\ndiff --git a/src/Functions/CastOverloadResolver.h b/src/Functions/CastOverloadResolver.h\nindex ffd5dda4af34..cff17d810feb 100644\n--- a/src/Functions/CastOverloadResolver.h\n+++ b/src/Functions/CastOverloadResolver.h\n@@ -33,22 +33,27 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n \n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n \n-    explicit CastOverloadResolverImpl(std::optional<Diagnostic> diagnostic_, bool keep_nullable_)\n-        : diagnostic(std::move(diagnostic_)), keep_nullable(keep_nullable_)\n+    explicit CastOverloadResolverImpl(std::optional<Diagnostic> diagnostic_, bool keep_nullable_, bool cast_ipv4_ipv6_default_on_conversion_error_)\n+        : diagnostic(std::move(diagnostic_))\n+        , keep_nullable(keep_nullable_)\n+        , cast_ipv4_ipv6_default_on_conversion_error(cast_ipv4_ipv6_default_on_conversion_error_)\n     {\n     }\n \n     static FunctionOverloadResolverPtr create(ContextPtr context)\n     {\n+        const auto & settings_ref = context->getSettingsRef();\n+\n         if constexpr (internal)\n-            return createImpl();\n-        return createImpl({}, context->getSettingsRef().cast_keep_nullable);\n+            return createImpl({}, false /*keep_nullable*/, false /*cast_ipv4_ipv6_default_on_conversion_error*/);\n+\n+        return createImpl({}, settings_ref.cast_keep_nullable, settings_ref.cast_ipv4_ipv6_default_on_conversion_error);\n     }\n \n-    static FunctionOverloadResolverPtr createImpl(std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false)\n+    static FunctionOverloadResolverPtr createImpl(std::optional<Diagnostic> diagnostic = {}, bool keep_nullable = false, bool cast_ipv4_ipv6_default_on_conversion_error = false)\n     {\n         assert(!internal || !keep_nullable);\n-        return std::make_unique<CastOverloadResolverImpl>(std::move(diagnostic), keep_nullable);\n+        return std::make_unique<CastOverloadResolverImpl>(std::move(diagnostic), keep_nullable, cast_ipv4_ipv6_default_on_conversion_error);\n     }\n \n protected:\n@@ -61,7 +66,7 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n             data_types[i] = arguments[i].type;\n \n         auto monotonicity = MonotonicityHelper::getMonotonicityInformation(arguments.front().type, return_type.get());\n-        return std::make_unique<FunctionCast<FunctionName>>(name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type);\n+        return std::make_unique<FunctionCast<FunctionName>>(name, std::move(monotonicity), data_types, return_type, diagnostic, cast_type, cast_ipv4_ipv6_default_on_conversion_error);\n     }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n@@ -98,6 +103,7 @@ class CastOverloadResolverImpl : public IFunctionOverloadResolver\n private:\n     std::optional<Diagnostic> diagnostic;\n     bool keep_nullable;\n+    bool cast_ipv4_ipv6_default_on_conversion_error;\n };\n \n \n@@ -115,7 +121,10 @@ struct CastInternalOverloadName\n     static constexpr auto accurate_cast_or_null_name = \"accurate_CastOrNull\";\n };\n \n-template <CastType cast_type> using CastOverloadResolver = CastOverloadResolverImpl<cast_type, false, CastOverloadName, CastName>;\n-template <CastType cast_type> using CastInternalOverloadResolver = CastOverloadResolverImpl<cast_type, true, CastInternalOverloadName, CastInternalName>;\n+template <CastType cast_type>\n+using CastOverloadResolver = CastOverloadResolverImpl<cast_type, false, CastOverloadName, CastName>;\n+\n+template <CastType cast_type>\n+using CastInternalOverloadResolver = CastOverloadResolverImpl<cast_type, true, CastInternalOverloadName, CastInternalName>;\n \n }\ndiff --git a/src/Functions/FunctionsCodingIP.cpp b/src/Functions/FunctionsCodingIP.cpp\nindex 3e7c8bff4d5d..de814529d033 100644\n--- a/src/Functions/FunctionsCodingIP.cpp\n+++ b/src/Functions/FunctionsCodingIP.cpp\n@@ -2,12 +2,15 @@\n #pragma clang diagnostic ignored \"-Wreserved-identifier\"\n #endif\n \n+#include <Functions/FunctionsCodingIP.h>\n+\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnTuple.h>\n #include <Columns/ColumnsNumber.h>\n+#include <Columns/ColumnNullable.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeFactory.h>\n #include <DataTypes/DataTypeFixedString.h>\n@@ -17,7 +20,7 @@\n #include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunction.h>\n-#include <Interpreters/Context_fwd.h>\n+#include <Interpreters/Context.h>\n #include <IO/WriteHelpers.h>\n #include <Common/IPv6ToBinary.h>\n #include <Common/formatIPv6.h>\n@@ -239,17 +242,19 @@ class FunctionCutIPv6 : public IFunction\n     }\n };\n \n-\n+template <IPStringToNumExceptionMode exception_mode>\n class FunctionIPv6StringToNum : public IFunction\n {\n public:\n-    static constexpr auto name = \"IPv6StringToNum\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv6StringToNum>(); }\n+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw\n+        ? \"IPv6StringToNum\"\n+        : (exception_mode == IPStringToNumExceptionMode::Default ? \"IPv6StringToNumOrDefault\" : \"IPv6StringToNumOrNull\");\n+\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionIPv6StringToNum>(context); }\n \n-    static inline bool tryParseIPv4(const char * pos)\n+    explicit FunctionIPv6StringToNum(ContextPtr context)\n+        : cast_ipv4_ipv6_default_on_conversion_error(context->getSettingsRef().cast_ipv4_ipv6_default_on_conversion_error)\n     {\n-        UInt32 result = 0;\n-        return DB::parseIPv4(pos, reinterpret_cast<unsigned char *>(&result));\n     }\n \n     String getName() const override { return name; }\n@@ -258,62 +263,43 @@ class FunctionIPv6StringToNum : public IFunction\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        if (!isString(arguments[0]))\n+        if (!isStringOrFixedString(arguments[0]))\n+        {\n             throw Exception(\n-                \"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n+        }\n \n-        return std::make_shared<DataTypeFixedString>(IPV6_BINARY_LENGTH);\n-    }\n+        auto result_type = std::make_shared<DataTypeFixedString>(IPV6_BINARY_LENGTH);\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        {\n+            return makeNullable(result_type);\n+        }\n+\n+        return result_type;\n+    }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n         const ColumnPtr & column = arguments[0].column;\n \n-        if (const auto * col_in = checkAndGetColumn<ColumnString>(column.get()))\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n         {\n-            auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n-\n-            auto & vec_res = col_res->getChars();\n-            vec_res.resize(col_in->size() * IPV6_BINARY_LENGTH);\n-\n-            const ColumnString::Chars & vec_src = col_in->getChars();\n-            const ColumnString::Offsets & offsets_src = col_in->getOffsets();\n-            size_t src_offset = 0;\n-            char src_ipv4_buf[sizeof(\"::ffff:\") + IPV4_MAX_TEXT_LENGTH + 1] = \"::ffff:\";\n-\n-            for (size_t out_offset = 0, i = 0; out_offset < vec_res.size(); out_offset += IPV6_BINARY_LENGTH, ++i)\n+            if (cast_ipv4_ipv6_default_on_conversion_error)\n             {\n-                /// For both cases below: In case of failure, the function parseIPv6 fills vec_res with zero bytes.\n-\n-                /// If the source IP address is parsable as an IPv4 address, then transform it into a valid IPv6 address.\n-                /// Keeping it simple by just prefixing `::ffff:` to the IPv4 address to represent it as a valid IPv6 address.\n-                if (tryParseIPv4(reinterpret_cast<const char *>(&vec_src[src_offset])))\n-                {\n-                    std::memcpy(\n-                        src_ipv4_buf + std::strlen(\"::ffff:\"),\n-                        reinterpret_cast<const char *>(&vec_src[src_offset]),\n-                        std::min<UInt64>(offsets_src[i] - src_offset, IPV4_MAX_TEXT_LENGTH + 1));\n-                    parseIPv6(src_ipv4_buf, reinterpret_cast<unsigned char *>(&vec_res[out_offset]));\n-                }\n-                else\n-                {\n-                    parseIPv6(\n-                        reinterpret_cast<const char *>(&vec_src[src_offset]), reinterpret_cast<unsigned char *>(&vec_res[out_offset]));\n-                }\n-                src_offset = offsets_src[i];\n+                return convertToIPv6<IPStringToNumExceptionMode::Default>(column);\n             }\n-\n-            return col_res;\n         }\n-        else\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+\n+        return convertToIPv6<exception_mode>(column);\n     }\n+\n+private:\n+    bool cast_ipv4_ipv6_default_on_conversion_error = false;\n };\n \n \n@@ -381,69 +367,64 @@ class FunctionIPv4NumToString : public IFunction\n     }\n };\n \n-\n+template <IPStringToNumExceptionMode exception_mode>\n class FunctionIPv4StringToNum : public IFunction\n {\n public:\n-    static constexpr auto name = \"IPv4StringToNum\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionIPv4StringToNum>(); }\n+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw\n+        ? \"IPv4StringToNum\"\n+        : (exception_mode == IPStringToNumExceptionMode::Default ? \"IPv4StringToNumOrDefault\" : \"IPv4StringToNumOrNull\");\n \n-    String getName() const override\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionIPv4StringToNum>(context); }\n+\n+    explicit FunctionIPv4StringToNum(ContextPtr context)\n+        : cast_ipv4_ipv6_default_on_conversion_error(context->getSettingsRef().cast_ipv4_ipv6_default_on_conversion_error)\n     {\n-        return name;\n     }\n \n+    String getName() const override { return name; }\n+\n     size_t getNumberOfArguments() const override { return 1; }\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        {\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n+        }\n \n-        return std::make_shared<DataTypeUInt32>();\n-    }\n+        auto result_type = std::make_shared<DataTypeUInt32>();\n \n-    static inline UInt32 parseIPv4(const char * pos)\n-    {\n-        UInt32 result = 0;\n-        DB::parseIPv4(pos, reinterpret_cast<unsigned char*>(&result));\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        {\n+            return makeNullable(result_type);\n+        }\n \n-        return result;\n+        return result_type;\n     }\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n         const ColumnPtr & column = arguments[0].column;\n \n-        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n         {\n-            auto col_res = ColumnUInt32::create();\n-\n-            ColumnUInt32::Container & vec_res = col_res->getData();\n-            vec_res.resize(col->size());\n-\n-            const ColumnString::Chars & vec_src = col->getChars();\n-            const ColumnString::Offsets & offsets_src = col->getOffsets();\n-            size_t prev_offset = 0;\n-\n-            for (size_t i = 0; i < vec_res.size(); ++i)\n+            if (cast_ipv4_ipv6_default_on_conversion_error)\n             {\n-                vec_res[i] = parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]));\n-                prev_offset = offsets_src[i];\n+                return convertToIPv4<IPStringToNumExceptionMode::Default>(column);\n             }\n-\n-            return col_res;\n         }\n-        else\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+\n+        return convertToIPv4<exception_mode>(column);\n     }\n+\n+private:\n+    bool cast_ipv4_ipv6_default_on_conversion_error = false;\n };\n \n \n@@ -503,16 +484,21 @@ class FunctionIPv4ToIPv6 : public IFunction\n     }\n };\n \n-class FunctionToIPv4 : public FunctionIPv4StringToNum\n+template <IPStringToNumExceptionMode exception_mode>\n+class FunctionToIPv4 : public FunctionIPv4StringToNum<exception_mode>\n {\n public:\n-    static constexpr auto name = \"toIPv4\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToIPv4>(); }\n+    using Base = FunctionIPv4StringToNum<exception_mode>;\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw\n+        ? \"toIPv4\"\n+        : (exception_mode == IPStringToNumExceptionMode::Default ? \"toIPv4OrDefault\" : \"toIPv4OrNull\");\n+\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToIPv4>(context); }\n+\n+    explicit FunctionToIPv4(ContextPtr context) : Base(context) { }\n+\n+    String getName() const override { return name; }\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n@@ -521,18 +507,35 @@ class FunctionToIPv4 : public FunctionIPv4StringToNum\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        {\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n+        }\n+\n+        auto result_type = DataTypeFactory::instance().get(\"IPv4\");\n+\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        {\n+            return makeNullable(result_type);\n+        }\n \n-        return DataTypeFactory::instance().get(\"IPv4\");\n+        return result_type;\n     }\n };\n \n-class FunctionToIPv6 : public FunctionIPv6StringToNum\n+template <IPStringToNumExceptionMode exception_mode>\n+class FunctionToIPv6 : public FunctionIPv6StringToNum<exception_mode>\n {\n public:\n-    static constexpr auto name = \"toIPv6\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionToIPv6>(); }\n+    using Base = FunctionIPv6StringToNum<exception_mode>;\n+\n+    static constexpr auto name = exception_mode == IPStringToNumExceptionMode::Throw\n+        ? \"toIPv6\"\n+        : (exception_mode == IPStringToNumExceptionMode::Default ? \"toIPv6OrDefault\" : \"toIPv6OrNull\");\n+\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToIPv6>(context); }\n+\n+    explicit FunctionToIPv6(ContextPtr context) : Base(context) { }\n \n     String getName() const override { return name; }\n \n@@ -540,11 +543,20 @@ class FunctionToIPv6 : public FunctionIPv6StringToNum\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n-        if (!isString(arguments[0]))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        if (!isStringOrFixedString(arguments[0]))\n+        {\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n+        }\n+\n+        auto result_type = DataTypeFactory::instance().get(\"IPv6\");\n \n-        return DataTypeFactory::instance().get(\"IPv6\");\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        {\n+            return makeNullable(result_type);\n+        }\n+\n+        return result_type;\n     }\n };\n \n@@ -971,7 +983,7 @@ class FunctionIPv4CIDRToRange : public IFunction\n     }\n };\n \n-class FunctionIsIPv4String : public FunctionIPv4StringToNum\n+class FunctionIsIPv4String : public IFunction\n {\n public:\n     static constexpr auto name = \"isIPv4String\";\n@@ -980,46 +992,51 @@ class FunctionIsIPv4String : public FunctionIPv4StringToNum\n \n     String getName() const override { return name; }\n \n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+            throw Exception(\n+                \"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n         return std::make_shared<DataTypeUInt8>();\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n-        const ColumnPtr & column = arguments[0].column;\n-        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))\n+        const ColumnString * input_column = checkAndGetColumn<ColumnString>(arguments[0].column.get());\n+\n+        if (!input_column)\n         {\n-            auto col_res = ColumnUInt8::create();\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\", arguments[0].column->getName(), getName());\n+        }\n \n-            ColumnUInt8::Container & vec_res = col_res->getData();\n-            vec_res.resize(col->size());\n+        auto col_res = ColumnUInt8::create();\n \n-            const ColumnString::Chars & vec_src = col->getChars();\n-            const ColumnString::Offsets & offsets_src = col->getOffsets();\n-            size_t prev_offset = 0;\n-            UInt32 result = 0;\n+        ColumnUInt8::Container & vec_res = col_res->getData();\n+        vec_res.resize(input_column->size());\n \n-            for (size_t i = 0; i < vec_res.size(); ++i)\n-            {\n-                vec_res[i] = DB::parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char*>(&result));\n-                prev_offset = offsets_src[i];\n-            }\n-            return col_res;\n+        const ColumnString::Chars & vec_src = input_column->getChars();\n+        const ColumnString::Offsets & offsets_src = input_column->getOffsets();\n+        size_t prev_offset = 0;\n+        UInt32 result = 0;\n+\n+        for (size_t i = 0; i < vec_res.size(); ++i)\n+        {\n+            vec_res[i] = DB::parseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(&result));\n+            prev_offset = offsets_src[i];\n         }\n-        else\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+\n+        return col_res;\n     }\n };\n \n-class FunctionIsIPv6String : public FunctionIPv6StringToNum\n+class FunctionIsIPv6String : public IFunction\n {\n public:\n     static constexpr auto name = \"isIPv6String\";\n@@ -1028,44 +1045,49 @@ class FunctionIsIPv6String : public FunctionIPv6StringToNum\n \n     String getName() const override { return name; }\n \n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n-            throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+        {\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type {} of argument of function {}\", arguments[0]->getName(), getName());\n+        }\n \n         return std::make_shared<DataTypeUInt8>();\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override\n     {\n-        const ColumnPtr & column = arguments[0].column;\n-\n-        if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))\n+        const ColumnString * input_column = checkAndGetColumn<ColumnString>(arguments[0].column.get());\n+        if (!input_column)\n         {\n-            auto col_res = ColumnUInt8::create();\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_COLUMN, \"Illegal column {} of argument of function {}\", arguments[0].column->getName(), getName());\n+        }\n \n-            ColumnUInt8::Container & vec_res = col_res->getData();\n-            vec_res.resize(col->size());\n+        auto col_res = ColumnUInt8::create();\n \n-            const ColumnString::Chars & vec_src = col->getChars();\n-            const ColumnString::Offsets & offsets_src = col->getOffsets();\n-            size_t prev_offset = 0;\n-            char v[IPV6_BINARY_LENGTH];\n+        ColumnUInt8::Container & vec_res = col_res->getData();\n+        vec_res.resize(input_column->size());\n \n-            for (size_t i = 0; i < vec_res.size(); ++i)\n-            {\n-                vec_res[i] = DB::parseIPv6(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char*>(v));\n-                prev_offset = offsets_src[i];\n-            }\n-            return col_res;\n+        const ColumnString::Chars & vec_src = input_column->getChars();\n+        const ColumnString::Offsets & offsets_src = input_column->getOffsets();\n+        size_t prev_offset = 0;\n+        char buffer[IPV6_BINARY_LENGTH];\n+\n+        for (size_t i = 0; i < vec_res.size(); ++i)\n+        {\n+            vec_res[i] = DB::parseIPv6(reinterpret_cast<const char *>(&vec_src[prev_offset]), reinterpret_cast<unsigned char *>(buffer));\n+            prev_offset = offsets_src[i];\n         }\n-        else\n-            throw Exception(\"Illegal column \" + arguments[0].column->getName()\n-                            + \" of argument of function \" + getName(),\n-                            ErrorCodes::ILLEGAL_COLUMN);\n+\n+        return col_res;\n     }\n };\n \n@@ -1079,8 +1101,6 @@ void registerFunctionsCoding(FunctionFactory & factory)\n     factory.registerFunction<FunctionMACNumToString>();\n     factory.registerFunction<FunctionMACStringTo<ParseMACImpl>>();\n     factory.registerFunction<FunctionMACStringTo<ParseOUIImpl>>();\n-    factory.registerFunction<FunctionToIPv4>();\n-    factory.registerFunction<FunctionToIPv6>();\n     factory.registerFunction<FunctionIPv6CIDRToRange>();\n     factory.registerFunction<FunctionIPv4CIDRToRange>();\n     factory.registerFunction<FunctionIsIPv4String>();\n@@ -1089,14 +1109,26 @@ void registerFunctionsCoding(FunctionFactory & factory)\n     factory.registerFunction<FunctionIPv4NumToString<0, NameFunctionIPv4NumToString>>();\n     factory.registerFunction<FunctionIPv4NumToString<1, NameFunctionIPv4NumToStringClassC>>();\n \n-    factory.registerFunction<FunctionIPv4StringToNum>();\n+    factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Throw>>();\n+    factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Default>>();\n+    factory.registerFunction<FunctionIPv4StringToNum<IPStringToNumExceptionMode::Null>>();\n+    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Throw>>();\n+    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Default>>();\n+    factory.registerFunction<FunctionToIPv4<IPStringToNumExceptionMode::Null>>();\n+\n     factory.registerFunction<FunctionIPv6NumToString>();\n-    factory.registerFunction<FunctionIPv6StringToNum>();\n+    factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Throw>>();\n+    factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Default>>();\n+    factory.registerFunction<FunctionIPv6StringToNum<IPStringToNumExceptionMode::Null>>();\n+    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Throw>>();\n+    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Default>>();\n+    factory.registerFunction<FunctionToIPv6<IPStringToNumExceptionMode::Null>>();\n+\n \n-    /// MysQL compatibility aliases:\n-    factory.registerAlias(\"INET_ATON\", FunctionIPv4StringToNum::name, FunctionFactory::CaseInsensitive);\n+    /// MySQL compatibility aliases:\n+    factory.registerAlias(\"INET_ATON\", FunctionIPv4StringToNum<IPStringToNumExceptionMode::Throw>::name, FunctionFactory::CaseInsensitive);\n     factory.registerAlias(\"INET6_NTOA\", FunctionIPv6NumToString::name, FunctionFactory::CaseInsensitive);\n-    factory.registerAlias(\"INET6_ATON\", FunctionIPv6StringToNum::name, FunctionFactory::CaseInsensitive);\n+    factory.registerAlias(\"INET6_ATON\", FunctionIPv6StringToNum<IPStringToNumExceptionMode::Throw>::name, FunctionFactory::CaseInsensitive);\n     factory.registerAlias(\"INET_NTOA\", NameFunctionIPv4NumToString::name, FunctionFactory::CaseInsensitive);\n }\n \ndiff --git a/src/Functions/FunctionsCodingIP.h b/src/Functions/FunctionsCodingIP.h\nnew file mode 100644\nindex 000000000000..246e62d965cd\n--- /dev/null\n+++ b/src/Functions/FunctionsCodingIP.h\n@@ -0,0 +1,212 @@\n+#pragma once\n+\n+#include <Common/formatIPv6.h>\n+\n+#include <Columns/ColumnFixedString.h>\n+#include <Columns/ColumnNullable.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnsNumber.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+enum class IPStringToNumExceptionMode : uint8_t\n+{\n+    Throw,\n+    Default,\n+    Null\n+};\n+\n+static inline bool tryParseIPv4(const char * pos, UInt32 & result_value)\n+{\n+    return parseIPv4(pos, reinterpret_cast<unsigned char *>(&result_value));\n+}\n+\n+namespace detail\n+{\n+    template <IPStringToNumExceptionMode exception_mode, typename StringColumnType>\n+    ColumnPtr convertToIPv6(const StringColumnType & string_column)\n+    {\n+        size_t column_size = string_column.size();\n+\n+        ColumnUInt8::MutablePtr col_null_map_to;\n+        ColumnUInt8::Container * vec_null_map_to = nullptr;\n+\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        {\n+            col_null_map_to = ColumnUInt8::create(column_size, false);\n+            vec_null_map_to = &col_null_map_to->getData();\n+        }\n+\n+        auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n+\n+        auto & vec_res = col_res->getChars();\n+        vec_res.resize(column_size * IPV6_BINARY_LENGTH);\n+\n+        using Chars = typename StringColumnType::Chars;\n+        const Chars & vec_src = string_column.getChars();\n+\n+        size_t src_offset = 0;\n+        char src_ipv4_buf[sizeof(\"::ffff:\") + IPV4_MAX_TEXT_LENGTH + 1] = \"::ffff:\";\n+\n+        /// ColumnFixedString contains not null terminated strings. But functions parseIPv6, parseIPv4 expect null terminated string.\n+        std::string fixed_string_buffer;\n+\n+        if constexpr (std::is_same_v<StringColumnType, ColumnFixedString>)\n+        {\n+            fixed_string_buffer.resize(string_column.getN());\n+        }\n+\n+        for (size_t out_offset = 0, i = 0; out_offset < vec_res.size(); out_offset += IPV6_BINARY_LENGTH, ++i)\n+        {\n+            size_t src_next_offset = src_offset;\n+\n+            const char * src_value = nullptr;\n+            unsigned char * res_value = reinterpret_cast<unsigned char *>(&vec_res[out_offset]);\n+\n+            if constexpr (std::is_same_v<StringColumnType, ColumnString>)\n+            {\n+                src_value = reinterpret_cast<const char *>(&vec_src[src_offset]);\n+                src_next_offset = string_column.getOffsets()[i];\n+            }\n+            else if constexpr (std::is_same_v<StringColumnType, ColumnFixedString>)\n+            {\n+                size_t fixed_string_size = string_column.getN();\n+\n+                std::memcpy(fixed_string_buffer.data(), reinterpret_cast<const char *>(&vec_src[src_offset]), fixed_string_size);\n+                src_value = fixed_string_buffer.data();\n+\n+                src_next_offset += fixed_string_size;\n+            }\n+\n+            bool parse_result = false;\n+            UInt32 dummy_result = 0;\n+\n+            /// For both cases below: In case of failure, the function parseIPv6 fills vec_res with zero bytes.\n+\n+            /// If the source IP address is parsable as an IPv4 address, then transform it into a valid IPv6 address.\n+            /// Keeping it simple by just prefixing `::ffff:` to the IPv4 address to represent it as a valid IPv6 address.\n+            if (tryParseIPv4(src_value, dummy_result))\n+            {\n+                std::memcpy(\n+                    src_ipv4_buf + std::strlen(\"::ffff:\"),\n+                    src_value,\n+                    std::min<UInt64>(src_next_offset - src_offset, IPV4_MAX_TEXT_LENGTH + 1));\n+                parse_result = parseIPv6(src_ipv4_buf, res_value);\n+            }\n+            else\n+            {\n+                parse_result = parseIPv6(src_value, res_value);\n+            }\n+\n+            if (!parse_result)\n+            {\n+                if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n+                    throw Exception(\"Invalid IPv6 value\", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);\n+                else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)\n+                    vec_res[i] = 0;\n+                else if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+                    (*vec_null_map_to)[i] = true;\n+            }\n+\n+            src_offset = src_next_offset;\n+        }\n+\n+        if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+            return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));\n+\n+        return col_res;\n+    }\n+}\n+\n+template <IPStringToNumExceptionMode exception_mode>\n+ColumnPtr convertToIPv6(ColumnPtr column)\n+{\n+    size_t column_size = column->size();\n+\n+    auto col_res = ColumnFixedString::create(IPV6_BINARY_LENGTH);\n+\n+    auto & vec_res = col_res->getChars();\n+    vec_res.resize(column_size * IPV6_BINARY_LENGTH);\n+\n+    if (const auto * column_input_string = checkAndGetColumn<ColumnString>(column.get()))\n+    {\n+        return detail::convertToIPv6<exception_mode>(*column_input_string);\n+    }\n+    else if (const auto * column_input_fixed_string = checkAndGetColumn<ColumnFixedString>(column.get()))\n+    {\n+        return detail::convertToIPv6<exception_mode>(*column_input_fixed_string);\n+    }\n+    else\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column type {}. Expected String or FixedString\", column->getName());\n+    }\n+}\n+\n+template <IPStringToNumExceptionMode exception_mode>\n+ColumnPtr convertToIPv4(ColumnPtr column)\n+{\n+    const ColumnString * column_string = checkAndGetColumn<ColumnString>(column.get());\n+\n+    if (!column_string)\n+    {\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column type {}. Expected String.\", column->getName());\n+    }\n+\n+    size_t column_size = column_string->size();\n+\n+    ColumnUInt8::MutablePtr col_null_map_to;\n+    ColumnUInt8::Container * vec_null_map_to = nullptr;\n+\n+    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+    {\n+        col_null_map_to = ColumnUInt8::create(column_size, false);\n+        vec_null_map_to = &col_null_map_to->getData();\n+    }\n+\n+    auto col_res = ColumnUInt32::create();\n+\n+    ColumnUInt32::Container & vec_res = col_res->getData();\n+    vec_res.resize(column_size);\n+\n+    const ColumnString::Chars & vec_src = column_string->getChars();\n+    const ColumnString::Offsets & offsets_src = column_string->getOffsets();\n+    size_t prev_offset = 0;\n+\n+    for (size_t i = 0; i < vec_res.size(); ++i)\n+    {\n+        bool parse_result = tryParseIPv4(reinterpret_cast<const char *>(&vec_src[prev_offset]), vec_res[i]);\n+\n+        if (!parse_result)\n+        {\n+            if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n+            {\n+                throw Exception(\"Invalid IPv4 value\", ErrorCodes::CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING);\n+            }\n+            else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)\n+            {\n+                vec_res[i] = 0;\n+            }\n+            else if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+            {\n+                (*vec_null_map_to)[i] = true;\n+                vec_res[i] = 0;\n+            }\n+        }\n+\n+        prev_offset = offsets_src[i];\n+    }\n+\n+    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));\n+\n+    return col_res;\n+}\n+\n+}\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex f75d67032f28..f41a461a7287 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -45,6 +45,7 @@\n #include <Functions/DateTimeTransforms.h>\n #include <Functions/toFixedString.h>\n #include <Functions/TransformDateTime64.h>\n+#include <Functions/FunctionsCodingIP.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n #include <Columns/ColumnLowCardinality.h>\n #include <Interpreters/Context.h>\n@@ -2532,10 +2533,12 @@ class FunctionCast final : public FunctionCastBase\n             , const DataTypes & argument_types_\n             , const DataTypePtr & return_type_\n             , std::optional<Diagnostic> diagnostic_\n-            , CastType cast_type_)\n+            , CastType cast_type_\n+            , bool cast_ipv4_ipv6_default_on_conversion_error_)\n         : cast_name(cast_name_), monotonicity_for_range(std::move(monotonicity_for_range_))\n         , argument_types(argument_types_), return_type(return_type_), diagnostic(std::move(diagnostic_))\n         , cast_type(cast_type_)\n+        , cast_ipv4_ipv6_default_on_conversion_error(cast_ipv4_ipv6_default_on_conversion_error_)\n     {\n     }\n \n@@ -2584,6 +2587,7 @@ class FunctionCast final : public FunctionCastBase\n \n     std::optional<Diagnostic> diagnostic;\n     CastType cast_type;\n+    bool cast_ipv4_ipv6_default_on_conversion_error;\n \n     static WrapperType createFunctionAdaptor(FunctionPtr function, const DataTypePtr & from_type)\n     {\n@@ -3381,7 +3385,9 @@ class FunctionCast final : public FunctionCastBase\n     /// 'requested_result_is_nullable' is true if CAST to Nullable type is requested.\n     WrapperType prepareImpl(const DataTypePtr & from_type, const DataTypePtr & to_type, bool requested_result_is_nullable) const\n     {\n-        if (from_type->equals(*to_type))\n+        bool convert_to_ipv6 = to_type->getCustomName() && to_type->getCustomName()->getName() == \"IPv6\";\n+\n+        if (from_type->equals(*to_type) && !convert_to_ipv6)\n         {\n             if (isUInt8(from_type))\n                 return createUInt8ToUInt8Wrapper(from_type, to_type);\n@@ -3449,7 +3455,9 @@ class FunctionCast final : public FunctionCastBase\n             return false;\n         };\n \n-        auto make_custom_serialization_wrapper = [&](const auto & types) -> bool\n+        bool cast_ipv4_ipv6_default_on_conversion_error_value = cast_ipv4_ipv6_default_on_conversion_error;\n+\n+        auto make_custom_serialization_wrapper = [&, cast_ipv4_ipv6_default_on_conversion_error_value](const auto & types) -> bool\n         {\n             using Types = std::decay_t<decltype(types)>;\n             using ToDataType = typename Types::RightType;\n@@ -3457,8 +3465,45 @@ class FunctionCast final : public FunctionCastBase\n \n             if constexpr (WhichDataType(FromDataType::type_id).isStringOrFixedString())\n             {\n-                if (to_type->getCustomSerialization())\n+                if (to_type->getCustomSerialization() && to_type->getCustomName())\n                 {\n+                    if (to_type->getCustomName()->getName() == \"IPv4\")\n+                    {\n+                        ret = [cast_ipv4_ipv6_default_on_conversion_error_value](\n+                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t)\n+                            -> ColumnPtr\n+                        {\n+                            if (!WhichDataType(result_type).isUInt32())\n+                                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected UInt32\", result_type->getName());\n+\n+                            if (cast_ipv4_ipv6_default_on_conversion_error_value)\n+                                return convertToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column);\n+                            else\n+                                return convertToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column);\n+                        };\n+\n+                        return true;\n+                    }\n+\n+                    if (to_type->getCustomName()->getName() == \"IPv6\")\n+                    {\n+                        ret = [cast_ipv4_ipv6_default_on_conversion_error_value](\n+                                  ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable *, size_t)\n+                            -> ColumnPtr\n+                        {\n+                            if (!WhichDataType(result_type).isFixedString())\n+                                throw Exception(\n+                                    ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected FixedString\", result_type->getName());\n+\n+                            if (cast_ipv4_ipv6_default_on_conversion_error_value)\n+                                return convertToIPv6<IPStringToNumExceptionMode::Default>(arguments[0].column);\n+                            else\n+                                return convertToIPv6<IPStringToNumExceptionMode::Throw>(arguments[0].column);\n+                        };\n+\n+                        return true;\n+                    }\n+\n                     ret = &ConvertImplGenericFromString<typename FromDataType::ColumnType>::execute;\n                     return true;\n                 }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00076_ip_coding_functions.sql b/tests/queries/0_stateless/00076_ip_coding_functions.sql\nindex 659267c61ed1..f693b336e570 100644\n--- a/tests/queries/0_stateless/00076_ip_coding_functions.sql\n+++ b/tests/queries/0_stateless/00076_ip_coding_functions.sql\n@@ -1,3 +1,5 @@\n+SET cast_ipv4_ipv6_default_on_conversion_error = 1;\n+\n select IPv4StringToNum('') == 0;\n select IPv4StringToNum(materialize('')) == 0;\n select IPv4StringToNum('not an ip string') == 0;\ndiff --git a/tests/queries/0_stateless/00938_ipv6_cidr_range.sql b/tests/queries/0_stateless/00938_ipv6_cidr_range.sql\nindex 3fa4c7c5d3fd..1ceefa8cfb32 100644\n--- a/tests/queries/0_stateless/00938_ipv6_cidr_range.sql\n+++ b/tests/queries/0_stateless/00938_ipv6_cidr_range.sql\n@@ -9,7 +9,7 @@ SELECT 'tests';\n DROP TABLE IF EXISTS ipv6_range;\n CREATE TABLE ipv6_range(ip IPv6, cidr UInt8) ENGINE = Memory;\n \n-INSERT INTO ipv6_range (ip, cidr) VALUES (IPv6StringToNum('2001:0db8:0000:85a3:0000:0000:ac1f:8001'), 0), (IPv6StringToNum('2001:0db8:0000:85a3:ffff:ffff:ffff:ffff'), 32), (IPv6StringToNum('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff'), 16), (IPv6StringToNum('2001:df8:0:85a3::ac1f:8001'), 32), (IPv6StringToNum('2001:0db8:85a3:85a3:0000:0000:ac1f:8001'), 16), (IPv6StringToNum('0000:0000:0000:0000:0000:0000:0000:0000'), 8), (IPv6StringToNum('ffff:0000:0000:0000:0000:0000:0000:0000'), 4);\n+INSERT INTO ipv6_range (ip, cidr) VALUES ('2001:0db8:0000:85a3:0000:0000:ac1f:8001', 0), ('2001:0db8:0000:85a3:ffff:ffff:ffff:ffff', 32), ('ffff:ffff:ffff:ffff:ffff:ffff:ffff:ffff', 16), ('2001:df8:0:85a3::ac1f:8001', 32), ('2001:0db8:85a3:85a3:0000:0000:ac1f:8001', 16), ('0000:0000:0000:0000:0000:0000:0000:0000', 8), ('ffff:0000:0000:0000:0000:0000:0000:0000', 4);\n \n WITH IPv6CIDRToRange(IPv6StringToNum('2001:0db8:0000:85a3:0000:0000:ac1f:8001'), 32) as ip_range SELECT COUNT(*) FROM ipv6_range WHERE ip BETWEEN tupleElement(ip_range, 1) AND tupleElement(ip_range, 2);\n \ndiff --git a/tests/queries/0_stateless/01018_ip_dictionary_long.sql b/tests/queries/0_stateless/01018_ip_dictionary_long.sql\nindex 7d9dfeb1bae8..647c36429cc9 100644\n--- a/tests/queries/0_stateless/01018_ip_dictionary_long.sql\n+++ b/tests/queries/0_stateless/01018_ip_dictionary_long.sql\n@@ -44,7 +44,7 @@ LAYOUT(IP_TRIE())\n LIFETIME(MIN 10 MAX 100);\n \n -- fuzzer\n-SELECT '127.0.0.0/24' = dictGetString('database_for_dict.dict_ipv4_trie', 'prefixprefixprefixprefix', tuple(IPv4StringToNum('127.0.0.0127.0.0.0'))); -- { serverError 36 }\n+SELECT '127.0.0.0/24' = dictGetString('database_for_dict.dict_ipv4_trie', 'prefixprefixprefixprefix', tuple(IPv4StringToNumOrDefault('127.0.0.0127.0.0.0'))); -- { serverError 36 }\n \n SELECT 0 == dictGetUInt32('database_for_dict.dict_ipv4_trie', 'asn', tuple(IPv4StringToNum('0.0.0.0')));\n SELECT 1 == dictGetUInt32('database_for_dict.dict_ipv4_trie', 'asn', tuple(IPv4StringToNum('128.0.0.0')));\ndiff --git a/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.reference b/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.reference\nindex 8a4df1605fb0..8da82a0726f3 100644\n--- a/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.reference\n+++ b/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.reference\n@@ -4,3 +4,4 @@\n 2001:db8:0:85a3::ac1f:8001\tString\n 0.0.0.0\tIPv4\n ::\tIPv6\n+::ffff:1.1.1.1\tIPv6\ndiff --git a/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql b/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql\nindex 2fcc20b98112..b303d580e727 100644\n--- a/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql\n+++ b/tests/queries/0_stateless/02007_ipv4_and_ipv6_to_and_from_string.sql\n@@ -4,10 +4,10 @@ SELECT CAST(toIPv4('127.0.0.1') as String) as v, toTypeName(v);\n SELECT CAST('2001:0db8:0000:85a3:0000:0000:ac1f:8001' as IPv6) as v, toTypeName(v);\n SELECT CAST(toIPv6('2001:0db8:0000:85a3:0000:0000:ac1f:8001') as String) as v, toTypeName(v);\n \n-SELECT toIPv4('hello') as v, toTypeName(v);\n-SELECT toIPv6('hello') as v, toTypeName(v);\n+SELECT toIPv4OrDefault('hello') as v, toTypeName(v);\n+SELECT toIPv6OrDefault('hello') as v, toTypeName(v);\n \n SELECT CAST('hello' as IPv4) as v, toTypeName(v); -- { serverError CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING }\n SELECT CAST('hello' as IPv6) as v, toTypeName(v); -- { serverError CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING }\n \n-SELECT CAST('1.1.1.1' as IPv6) as v, toTypeName(v); -- { serverError CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING }\n+SELECT CAST('1.1.1.1' as IPv6) as v, toTypeName(v);\ndiff --git a/tests/queries/0_stateless/02234_cast_to_ip_address.reference b/tests/queries/0_stateless/02234_cast_to_ip_address.reference\nnew file mode 100644\nindex 000000000000..3a4c40a07cfd\n--- /dev/null\n+++ b/tests/queries/0_stateless/02234_cast_to_ip_address.reference\n@@ -0,0 +1,45 @@\n+IPv4 functions\n+0\n+\\N\n+2130706433\n+2130706433\n+2130706433\n+--\n+0.0.0.0\n+\\N\n+127.0.0.1\n+127.0.0.1\n+127.0.0.1\n+--\n+127.0.0.1\n+--\n+0\n+0.0.0.0\n+0\n+0.0.0.0\n+0.0.0.0\n+0.0.0.0\n+IPv6 functions\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\n+\\N\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\ufffd\ufffd\u007f\\0\\0\u0001\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\ufffd\ufffd\u007f\\0\\0\u0001\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\ufffd\ufffd\u007f\\0\\0\u0001\n+--\n+::\n+\\N\n+::ffff:127.0.0.1\n+::ffff:127.0.0.1\n+::ffff:127.0.0.1\n+--\n+::ffff:127.0.0.1\n+--\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\n+::\n+\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\\0\n+::\n+::\n+::\n+--\n+::ffff:127.0.0.1\t::ffff:127.0.0.1\t::ffff:127.0.0.1\n+::1\\0\\0\t::1\t::1\ndiff --git a/tests/queries/0_stateless/02234_cast_to_ip_address.sql b/tests/queries/0_stateless/02234_cast_to_ip_address.sql\nnew file mode 100644\nindex 000000000000..d436c93b9db1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02234_cast_to_ip_address.sql\n@@ -0,0 +1,82 @@\n+SELECT 'IPv4 functions';\n+\n+SELECT IPv4StringToNum('test'); --{serverError 441}\n+SELECT IPv4StringToNumOrDefault('test');\n+SELECT IPv4StringToNumOrNull('test');\n+\n+SELECT IPv4StringToNum('127.0.0.1');\n+SELECT IPv4StringToNumOrDefault('127.0.0.1');\n+SELECT IPv4StringToNumOrNull('127.0.0.1');\n+\n+SELECT '--';\n+\n+SELECT toIPv4('test'); --{serverError 441}\n+SELECT toIPv4OrDefault('test');\n+SELECT toIPv4OrNull('test');\n+\n+SELECT toIPv4('127.0.0.1');\n+SELECT toIPv4OrDefault('127.0.0.1');\n+SELECT toIPv4OrNull('127.0.0.1');\n+\n+SELECT '--';\n+\n+SELECT cast('test' , 'IPv4'); --{serverError 441}\n+SELECT cast('127.0.0.1' , 'IPv4');\n+\n+SELECT '--';\n+\n+SET cast_ipv4_ipv6_default_on_conversion_error = 1;\n+\n+SELECT IPv4StringToNum('test');\n+SELECT toIPv4('test');\n+SELECT IPv4StringToNum('');\n+SELECT toIPv4('');\n+SELECT cast('test' , 'IPv4');\n+SELECT cast('' , 'IPv4');\n+\n+SET cast_ipv4_ipv6_default_on_conversion_error = 0;\n+\n+SELECT 'IPv6 functions';\n+\n+SELECT IPv6StringToNum('test'); --{serverError 441}\n+SELECT IPv6StringToNumOrDefault('test');\n+SELECT IPv6StringToNumOrNull('test');\n+\n+SELECT IPv6StringToNum('::ffff:127.0.0.1');\n+SELECT IPv6StringToNumOrDefault('::ffff:127.0.0.1');\n+SELECT IPv6StringToNumOrNull('::ffff:127.0.0.1');\n+\n+SELECT '--';\n+\n+SELECT toIPv6('test'); --{serverError 441}\n+SELECT toIPv6OrDefault('test');\n+SELECT toIPv6OrNull('test');\n+\n+SELECT toIPv6('::ffff:127.0.0.1');\n+SELECT toIPv6OrDefault('::ffff:127.0.0.1');\n+SELECT toIPv6OrNull('::ffff:127.0.0.1');\n+\n+SELECT '--';\n+\n+SELECT cast('test' , 'IPv6'); --{serverError 441}\n+SELECT cast('::ffff:127.0.0.1', 'IPv6');\n+\n+SELECT '--';\n+\n+SET cast_ipv4_ipv6_default_on_conversion_error = 1;\n+\n+SELECT IPv6StringToNum('test');\n+SELECT toIPv6('test');\n+SELECT IPv6StringToNum('');\n+SELECT toIPv6('');\n+SELECT cast('test' , 'IPv6');\n+SELECT cast('' , 'IPv6');\n+\n+SELECT '--';\n+\n+SET cast_ipv4_ipv6_default_on_conversion_error = 0;\n+\n+SELECT toFixedString('::ffff:127.0.0.1', 16) as value, cast(value, 'IPv6'), toIPv6(value);\n+SELECT toFixedString('::1', 5) as value, cast(value, 'IPv6'), toIPv6(value);\n+SELECT toFixedString('', 16) as value, cast(value, 'IPv6'); --{serverError 441}\n+SELECT toFixedString('', 16) as value, toIPv6(value); --{serverError 441}\n",
  "problem_statement": "toIPv6(x) doesn't work the same way as CAST(x AS IPv6)\n```\r\n:) select toIPv6(IPv6StringToNum('::1bc0')) format JSON\r\n\r\nSELECT toIPv6(IPv6StringToNum('::1bc0'))\r\nFORMAT JSON\r\n\r\nReceived exception from server (version 19.11.0):\r\nCode: 43. DB::Exception: Received from localhost:9000, ::1. DB::Exception: Illegal type FixedString(16) of argument of function toIPv6. \r\n\r\n0 rows in set. Elapsed: 0.088 sec. \r\n\r\n:) select toIPv6('::1bc0') format JSON                 \r\n\r\nSELECT toIPv6('::1bc0')\r\nFORMAT JSON\r\n\r\n{\r\n        \"meta\":\r\n        [\r\n                {\r\n                        \"name\": \"toIPv6('::1bc0')\",\r\n                        \"type\": \"IPv6\"\r\n                }\r\n        ],\r\n\r\n        \"data\":\r\n        [\r\n                {\r\n                        \"toIPv6('::1bc0')\": \"::1bc0\"\r\n                }\r\n        ],\r\n\r\n        \"rows\": 1,\r\n\r\n        \"statistics\":\r\n        {\r\n                \"elapsed\": 0.000128767,\r\n                \"rows_read\": 1,\r\n                \"bytes_read\": 1\r\n        }\r\n}\r\n\r\n1 rows in set. Elapsed: 0.001 sec. \r\n\r\n:) select CAST(IPv6StringToNum('::1bc0') AS IPv6) format JSON\r\n\r\nSELECT CAST(IPv6StringToNum('::1bc0'), 'IPv6')\r\nFORMAT JSON\r\n\r\n{\r\n        \"meta\":\r\n        [\r\n                {\r\n                        \"name\": \"CAST(IPv6StringToNum('::1bc0'), 'IPv6')\",\r\n                        \"type\": \"IPv6\"\r\n                }\r\n        ],\r\n\r\n        \"data\":\r\n        [\r\n                {\r\n                        \"CAST(IPv6StringToNum('::1bc0'), 'IPv6')\": \"::1bc0\"\r\n                }\r\n        ],\r\n\r\n        \"rows\": 1,\r\n\r\n        \"statistics\":\r\n        {\r\n                \"elapsed\": 0.000189836,\r\n                \"rows_read\": 1,\r\n                \"bytes_read\": 1\r\n        }\r\n}\r\n\r\n1 rows in set. Elapsed: 0.001 sec.\r\n```\nCAST to IPv6 on empty strings changed between 21.x and 22.x\n**Describe the issue**\r\nOn empty strings, the behaviour of the function `CAST('', 'IPv6')` changed between the versions 21.x and 22.x\r\n\r\n**How to reproduce**\r\nOn 21.8.14.5:\r\n```\r\nSELECT CAST('', 'IPv6');\r\nReturns: \r\n\t\r\n::\r\n```\r\n\r\nOn 22.2.2.1:\r\n```\r\nSELECT CAST('', 'IPv6');\r\nTriggers error: \r\n\r\nCode: 441. DB::Exception: Invalid IPv6 value.: While processing CAST('', 'IPv6'). (CANNOT_PARSE_DOMAIN_VALUE_FROM_STRING) (version 22.2.2.1)\r\n\r\n```\r\n\r\n**Additional context**\r\nThis can prevent some users from upgrading to 22.x when the use of this function is spread across a number of table definitions and environments. The following workaround `CAST(toFixedString('', 16), 'IPv6')` works but the manual task of updating all the occurrences is challenging.\r\n\nIPv4OrZero or toIPv4OrNull does not exist.\nClickhouse recommend to use IPv4OrZero or toIPv4OrNull functions in error message, but they do not actually exist.\r\n\r\n\r\n**How to reproduce**\r\nClickhouse version 21.5\r\n\r\n```\r\nSELECT CAST('127.0.0.1', 'IPv4')\r\n\r\nQuery id: f7ce4a55-0e57-41a8-b771-8fd6be54d41b\r\n\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 6. DB::Exception: Received from localhost:9000. DB::Exception: Cannot parse string '127.0.0.1' as IPv4: syntax error at position 3 (parsed just '127'). Note: there are toIPv4OrZero and toIPv4OrNull functions, which returns zero/NULL instead of throwing exception.: While processing CAST('127.0.0.1', 'IPv4').\r\n\r\n\r\nlocaldomain  :) SELECT toIPv4OrZero('127.0.0.1')\u3000;\r\n\r\nSELECT toIPv4OrZero('127.0.0.1')\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 46. DB::Exception: Received from localhost:9000. DB::Exception: Unknown function toIPv4OrZero. Maybe you meant: ['toInt8OrZero','toInt64OrZero']: While processing toIPv4OrZero('127.0.0.1').\r\n\r\nlocaldomain  :) SELECT toIPv4OrNull('127.0.0.1')\u3000;\r\n\r\nSELECT toIPv4OrNull('127.0.0.1')\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n\r\nReceived exception from server (version 21.5.1):\r\nCode: 46. DB::Exception: Received from localhost:9000. DB::Exception: Unknown function toIPv4OrNull. Maybe you meant: ['toInt8OrNull','toInt64OrNull']: While processing toIPv4OrNull('127.0.0.1').\r\n\r\nlocaldomain  :) SELECT toIPv4('127.0.0.1')\u3000;\r\n\r\nSELECT toIPv4('127.0.0.1')\r\n\r\n\r\n\u250c\u2500toIPv4('127.0.0.1')\u2500\u2510\r\n\u2502 127.0.0.1           \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n\r\n```\n",
  "hints_text": "@Enmk \n@kitaisreal checked the code and found that previous behaviour was a bug.\r\nIn previous versions, every invalid input was casted to `::`.\r\n\r\nFor bug-compatibility with old versions we are going to introduce a setting that a customer can enable.\nHere is more:\r\n\r\n```\r\ncreate table netflow( `ip_src` String, `stamp_updated` DateTime ) Engine=MergeTree() order by stamp_updated;\r\ninsert into  netflow values ('10.10.10.10', now()) ;\r\n\r\nalter table netflow modify column `ip_src` IPv4;\r\nDB::Exception: Exception happened during execution of mutation 'mutation_2.txt'\r\n\r\ndesc netflow\r\n\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\r\n\u2502 ip_src        \u2502 IPv4\r\n\r\n\r\nselect * from netflow;\r\n\r\nCannot parse string '10.10.10.10' as IPv4: syntax error at position 2 (parsed just '10'). Note: there are toIPv4OrZero and toIPv4OrNull\r\n\r\n\r\n```\r\n\r\n\nThis is tech debt due to introduction of data type domains here: #3669\r\nMaybe we should get rid of the notion of \"data type domains\", replacing it with real types.",
  "created_at": "2022-03-12T17:21:41Z"
}