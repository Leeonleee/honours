{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58023,
  "instance_id": "ClickHouse__ClickHouse-58023",
  "issue_numbers": [
    "56119"
  ],
  "base_commit": "973e17851ae069cc92471a6f4e863374e1435502",
  "patch": "diff --git a/src/Storages/MergeTree/MutateTask.cpp b/src/Storages/MergeTree/MutateTask.cpp\nindex 9959688d8894..de78e2eee139 100644\n--- a/src/Storages/MergeTree/MutateTask.cpp\n+++ b/src/Storages/MergeTree/MutateTask.cpp\n@@ -73,6 +73,7 @@ static void splitAndModifyMutationCommands(\n     LoggerPtr log)\n {\n     auto part_columns = part->getColumnsDescription();\n+    const auto & table_columns = metadata_snapshot->getColumns();\n \n     if (!isWidePart(part) || !isFullPartStorage(part->getDataPartStorage()))\n     {\n@@ -81,9 +82,19 @@ static void splitAndModifyMutationCommands(\n \n         for (const auto & command : commands)\n         {\n+            if (command.type == MutationCommand::Type::MATERIALIZE_COLUMN)\n+            {\n+                /// For ordinary column with default or materialized expression, MATERIALIZE COLUMN should not override past values\n+                /// So we only mutate column if `command.column_name` is a default/materialized column or if the part does not have physical column file\n+                auto column_ordinary = table_columns.getOrdinary().tryGetByName(command.column_name);\n+                if (!column_ordinary || !part->tryGetColumn(command.column_name) || !part->hasColumnFiles(*column_ordinary))\n+                {\n+                    for_interpreter.push_back(command);\n+                    mutated_columns.emplace(command.column_name);\n+                }\n+            }\n             if (command.type == MutationCommand::Type::MATERIALIZE_INDEX\n                 || command.type == MutationCommand::Type::MATERIALIZE_STATISTIC\n-                || command.type == MutationCommand::Type::MATERIALIZE_COLUMN\n                 || command.type == MutationCommand::Type::MATERIALIZE_PROJECTION\n                 || command.type == MutationCommand::Type::MATERIALIZE_TTL\n                 || command.type == MutationCommand::Type::DELETE\n@@ -93,9 +104,6 @@ static void splitAndModifyMutationCommands(\n                 for_interpreter.push_back(command);\n                 for (const auto & [column_name, expr] : command.column_to_update_expression)\n                     mutated_columns.emplace(column_name);\n-\n-                if (command.type == MutationCommand::Type::MATERIALIZE_COLUMN)\n-                    mutated_columns.emplace(command.column_name);\n             }\n             else if (command.type == MutationCommand::Type::DROP_INDEX\n                      || command.type == MutationCommand::Type::DROP_PROJECTION\n@@ -205,8 +213,15 @@ static void splitAndModifyMutationCommands(\n     {\n         for (const auto & command : commands)\n         {\n-            if (command.type == MutationCommand::Type::MATERIALIZE_INDEX\n-                || command.type == MutationCommand::Type::MATERIALIZE_COLUMN\n+            if (command.type == MutationCommand::Type::MATERIALIZE_COLUMN)\n+            {\n+                /// For ordinary column with default or materialized expression, MATERIALIZE COLUMN should not override past values\n+                /// So we only mutate column if `command.column_name` is a default/materialized column or if the part does not have physical column file\n+                auto column_ordinary = table_columns.getOrdinary().tryGetByName(command.column_name);\n+                if (!column_ordinary || !part->tryGetColumn(command.column_name) || !part->hasColumnFiles(*column_ordinary))\n+                    for_interpreter.push_back(command);\n+            }\n+            else if (command.type == MutationCommand::Type::MATERIALIZE_INDEX\n                 || command.type == MutationCommand::Type::MATERIALIZE_STATISTIC\n                 || command.type == MutationCommand::Type::MATERIALIZE_PROJECTION\n                 || command.type == MutationCommand::Type::MATERIALIZE_TTL\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02008_materialize_column.sql b/tests/queries/0_stateless/02008_materialize_column.sql\nindex a78920d2525b..cc7d3096402c 100644\n--- a/tests/queries/0_stateless/02008_materialize_column.sql\n+++ b/tests/queries/0_stateless/02008_materialize_column.sql\n@@ -17,6 +17,7 @@ ALTER TABLE tmp MATERIALIZE COLUMN s;\n ALTER TABLE tmp MODIFY COLUMN s String DEFAULT toString(x+2);\n SELECT arraySort(groupArray(x)), groupArray(s) FROM tmp;\n \n+ALTER TABLE tmp CLEAR COLUMN s; -- Need to clear because MATERIALIZE COLUMN won't override past values;\n ALTER TABLE tmp MATERIALIZE COLUMN s;\n ALTER TABLE tmp MODIFY COLUMN s String DEFAULT toString(x+3);\n SELECT arraySort(groupArray(x)), groupArray(s) FROM tmp;\ndiff --git a/tests/queries/0_stateless/02946_materialize_column_must_not_override_past_values.reference b/tests/queries/0_stateless/02946_materialize_column_must_not_override_past_values.reference\nnew file mode 100644\nindex 000000000000..461075e9607e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02946_materialize_column_must_not_override_past_values.reference\n@@ -0,0 +1,45 @@\n+DEFAULT expressions\n+-- Compact parts\n+Before materialize\n+1\t1\n+2\t54321\n+After materialize\n+1\t1\n+2\t54321\n+-- Wide parts\n+Before materialize\n+1\t1\n+2\t54321\n+After materialize\n+1\t1\n+2\t54321\n+-- Nullable column != physically absent\n+Before materialize\n+1\t1\n+2\t\\N\n+3\t54321\n+After materialize\n+1\t1\n+2\t\\N\n+3\t54321\n+-- Parts with renamed column\n+Before materialize\n+1\t1\n+2\t54321\n+After rename\n+1\t1\n+2\t54321\n+After materialize\n+1\t1\n+2\t54321\n+MATERIALIZED expressions\n+-- Compact parts\n+Before materialize\n+1\t54321\n+After materialize\n+1\t65432\n+-- Compact parts\n+Before materialize\n+1\t54321\n+After materialize\n+1\t65432\ndiff --git a/tests/queries/0_stateless/02946_materialize_column_must_not_override_past_values.sql b/tests/queries/0_stateless/02946_materialize_column_must_not_override_past_values.sql\nnew file mode 100644\nindex 000000000000..cfdde2877121\n--- /dev/null\n+++ b/tests/queries/0_stateless/02946_materialize_column_must_not_override_past_values.sql\n@@ -0,0 +1,85 @@\n+SET mutations_sync = 2;\n+\n+DROP TABLE IF EXISTS tab;\n+\n+-- Tests that existing parts which contain a non-default value in columns with DEFAULT expression remain unchanged by MATERIALIZE COLUMN>\n+SELECT 'DEFAULT expressions';\n+\n+SELECT '-- Compact parts';\n+\n+CREATE TABLE tab (id Int64, dflt Int64 DEFAULT 54321) ENGINE MergeTree ORDER BY id;\n+INSERT INTO tab (id, dflt) VALUES (1, 1);\n+INSERT INTO tab (id) VALUES (2);\n+SELECT 'Before materialize';\n+SELECT * FROM tab ORDER BY id;\n+ALTER TABLE tab MATERIALIZE COLUMN dflt;\n+SELECT 'After materialize';\n+SELECT * FROM tab ORDER BY id;\n+DROP TABLE tab;\n+\n+SELECT '-- Wide parts';\n+\n+CREATE TABLE tab (id Int64, dflt Int64 DEFAULT 54321) ENGINE MergeTree ORDER BY id SETTINGS min_bytes_for_wide_part = 1;\n+INSERT INTO tab (id, dflt) VALUES (1, 1);\n+INSERT INTO tab (id) VALUES (2);\n+SELECT 'Before materialize';\n+SELECT * FROM tab ORDER BY id;\n+ALTER TABLE tab MATERIALIZE COLUMN dflt;\n+SELECT 'After materialize';\n+SELECT * FROM tab ORDER BY id;\n+DROP TABLE tab;\n+\n+SELECT '-- Nullable column != physically absent';\n+\n+CREATE TABLE tab (id Int64, dflt Nullable(Int64) DEFAULT 54321) ENGINE MergeTree ORDER BY id SETTINGS min_bytes_for_wide_part = 1;\n+INSERT INTO tab (id, dflt) VALUES (1, 1);\n+INSERT INTO tab (id, dflt) VALUES (2, NULL);\n+INSERT INTO tab (id) VALUES (3);\n+SELECT 'Before materialize';\n+SELECT * FROM tab ORDER BY id;\n+ALTER TABLE tab MATERIALIZE COLUMN dflt;\n+SELECT 'After materialize';\n+SELECT * FROM tab ORDER BY id;\n+DROP TABLE tab;\n+\n+SELECT '-- Parts with renamed column';\n+\n+CREATE TABLE tab (id Int64, dflt Int64 DEFAULT 54321) ENGINE MergeTree ORDER BY id;\n+INSERT INTO tab (id, dflt) VALUES (1, 1);\n+INSERT INTO tab (id) VALUES (2);\n+SELECT 'Before materialize';\n+SELECT * FROM tab ORDER BY id;\n+ALTER TABLE tab RENAME COLUMN dflt TO dflt2;\n+SELECT 'After rename';\n+SELECT * FROM tab ORDER BY id;\n+ALTER TABLE tab MATERIALIZE COLUMN dflt2;\n+SELECT 'After materialize';\n+SELECT * FROM tab ORDER BY id;\n+DROP TABLE tab;\n+\n+-- But for columns with MATERIALIZED expression, all existing parts should be rewritten in case a new expression was set in the meantime.\n+SELECT 'MATERIALIZED expressions';\n+\n+SELECT '-- Compact parts';\n+\n+CREATE TABLE tab (id Int64, mtrl Int64 MATERIALIZED 54321) ENGINE MergeTree ORDER BY id;\n+INSERT INTO tab (id) VALUES (1);\n+SELECT 'Before materialize';\n+SELECT id, mtrl FROM tab ORDER BY id;\n+ALTER TABLE tab MODIFY COLUMN mtrl Int64 MATERIALIZED 65432;\n+ALTER TABLE tab MATERIALIZE COLUMN mtrl;\n+SELECT 'After materialize';\n+SELECT id, mtrl FROM tab ORDER BY id;\n+DROP TABLE tab;\n+\n+SELECT '-- Compact parts';\n+\n+CREATE TABLE tab (id Int64, mtrl Int64 MATERIALIZED 54321) ENGINE MergeTree ORDER BY id SETTINGS min_bytes_for_wide_part = 1;\n+INSERT INTO tab (id) VALUES (1);\n+SELECT 'Before materialize';\n+SELECT id, mtrl FROM tab ORDER BY id;\n+ALTER TABLE tab MODIFY COLUMN mtrl Int64 MATERIALIZED 65432;\n+ALTER TABLE tab MATERIALIZE COLUMN mtrl;\n+SELECT 'After materialize';\n+SELECT id, mtrl FROM tab ORDER BY id;\n+DROP TABLE tab;\n",
  "problem_statement": "Materialize column overwrites all past value. It should be documented.\nhttps://clickhouse.com/docs/en/sql-reference/statements/alter/column#materialize-column\r\n\r\nIt does not say an extremely important thing \u2013 column materialization will overwrite all past values in the column.\n",
  "hints_text": "It was meant by `or updates`\nBut probably it can be improved\nhttps://github.com/ClickHouse/ClickHouse/pull/56136 should resolve the problem. ",
  "created_at": "2023-12-19T09:56:52Z"
}