diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index aa78456702ce..69125815d36f 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -351,6 +351,8 @@ class IColumn;
     M(UInt64, partial_merge_join_left_table_buffer_bytes, 0, "If not 0 group left table blocks in bigger ones for left-side table in partial merge join. It uses up to 2x of specified memory per joining thread.", 0) \
     M(UInt64, partial_merge_join_rows_in_right_blocks, 65536, "Split right-hand joining data in blocks of specified size. It's a portion of data indexed by min-max values and possibly unloaded on disk.", 0) \
     M(UInt64, join_on_disk_max_files_to_merge, 64, "For MergeJoin on disk set how much files it's allowed to sort simultaneously. Then this value bigger then more memory used and then less disk I/O needed. Minimum is 2.", 0) \
+    M(Bool, compatibility_ignore_collation_in_create_table, true, "Compatibility ignore collation in create table", 0) \
+    \
     M(String, temporary_files_codec, "LZ4", "Set compression codec for temporary files (sort and join on disk). I.e. LZ4, NONE.", 0) \
     \
     M(UInt64, max_rows_to_transfer, 0, "Maximum size (in rows) of the transmitted external table obtained when the GLOBAL IN/JOIN section is executed.", 0) \
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index 24c58c819a4f..b6efb28a04c4 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -460,8 +460,12 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(
     {
         const auto & col_decl = ast->as<ASTColumnDeclaration &>();
 
-        DataTypePtr column_type = nullptr;
+        if (col_decl.collation && !context_->getSettingsRef().compatibility_ignore_collation_in_create_table)
+        {
+            throw Exception("Cannot support collation, please set compatibility_ignore_collation_in_create_table=true", ErrorCodes::NOT_IMPLEMENTED);
+        }
 
+        DataTypePtr column_type = nullptr;
         if (col_decl.type)
         {
             column_type = DataTypeFactory::instance().get(col_decl.type);
diff --git a/src/Parsers/ASTCollation.cpp b/src/Parsers/ASTCollation.cpp
new file mode 100644
index 000000000000..197164145811
--- /dev/null
+++ b/src/Parsers/ASTCollation.cpp
@@ -0,0 +1,21 @@
+#include <Parsers/ASTCollation.h>
+
+namespace DB
+{
+    ASTPtr ASTCollation::clone() const
+    {
+        auto res = std::make_shared<ASTCollation>(*this);
+        res->collation = collation->clone();
+        return res;
+    }
+
+    void ASTCollation::formatImpl(const FormatSettings &s, FormatState &state, FormatStateStacked frame) const
+    {
+        if (collation)
+        {
+            collation->formatImpl(s, state, frame);
+        }
+
+    }
+
+}
diff --git a/src/Parsers/ASTCollation.h b/src/Parsers/ASTCollation.h
new file mode 100644
index 000000000000..a735956a90e8
--- /dev/null
+++ b/src/Parsers/ASTCollation.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <Parsers/IAST.h>
+
+namespace DB
+{
+
+class ASTCollation : public IAST
+{
+public:
+    ASTPtr collation = nullptr;
+
+    String getID(char) const override { return "Collation"; }
+
+    ASTPtr clone() const override;
+
+    void formatImpl(const FormatSettings & s, FormatState & state, FormatStateStacked frame) const override;
+};
+
+}
diff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp
index 888cd639fb09..dc5651d9f14f 100644
--- a/src/Parsers/ASTColumnDeclaration.cpp
+++ b/src/Parsers/ASTColumnDeclaration.cpp
@@ -43,6 +43,11 @@ ASTPtr ASTColumnDeclaration::clone() const
         res->ttl = ttl->clone();
         res->children.push_back(res->ttl);
     }
+    if (collation)
+    {
+        res->collation = collation->clone();
+        res->children.push_back(res->collation);
+    }
 
     return res;
 }
@@ -97,6 +102,12 @@ void ASTColumnDeclaration::formatImpl(const FormatSettings & settings, FormatSta
         settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "TTL" << (settings.hilite ? hilite_none : "") << ' ';
         ttl->formatImpl(settings, state, frame);
     }
+
+    if (collation)
+    {
+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : "") << "COLLATE" << (settings.hilite ? hilite_none : "") << ' ';
+        collation->formatImpl(settings, state, frame);
+    }
 }
 
 }
diff --git a/src/Parsers/ASTColumnDeclaration.h b/src/Parsers/ASTColumnDeclaration.h
index ea17a8b4dfa3..5ecfb859abcb 100644
--- a/src/Parsers/ASTColumnDeclaration.h
+++ b/src/Parsers/ASTColumnDeclaration.h
@@ -19,6 +19,7 @@ class ASTColumnDeclaration : public IAST
     ASTPtr comment;
     ASTPtr codec;
     ASTPtr ttl;
+    ASTPtr collation;
 
     String getID(char delim) const override { return "ColumnDeclaration" + (delim + name); }
 
diff --git a/src/Parsers/CMakeLists.txt b/src/Parsers/CMakeLists.txt
index b2c313669291..73f300fd5f6e 100644
--- a/src/Parsers/CMakeLists.txt
+++ b/src/Parsers/CMakeLists.txt
@@ -4,7 +4,7 @@ add_headers_and_sources(clickhouse_parsers .)
 add_headers_and_sources(clickhouse_parsers ./Access)
 add_headers_and_sources(clickhouse_parsers ./MySQL)
 add_library(clickhouse_parsers ${clickhouse_parsers_headers} ${clickhouse_parsers_sources})
-target_link_libraries(clickhouse_parsers PUBLIC clickhouse_common_io clickhouse_common_access)
+target_link_libraries(clickhouse_parsers PUBLIC clickhouse_common_io clickhouse_common_access string_utils)
 
 if (USE_DEBUG_HELPERS)
     # CMake generator expression will do insane quoting when it encounters special character like quotes, spaces, etc.
diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index cd07e304a39f..b7c044062979 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -7,8 +7,10 @@
 #include <IO/ReadHelpers.h>
 #include <Parsers/DumpASTNode.h>
 #include <Common/typeid_cast.h>
+#include <Common/StringUtils/StringUtils.h>
 
 #include <Parsers/ASTAsterisk.h>
+#include <Parsers/ASTCollation.h>
 #include <Parsers/ASTColumnsTransformers.h>
 #include <Parsers/ASTExpressionList.h>
 #include <Parsers/ASTFunction.h>
@@ -1309,6 +1311,31 @@ bool ParserCodec::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
     return true;
 }
 
+bool ParserCollation::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
+{
+    ASTPtr collation;
+
+    if (!ParserIdentifier(true).parse(pos, collation, expected))
+        return false;
+
+    // check the collation name is valid
+    const String name = getIdentifierName(collation);
+
+    bool valid_collation = name == "binary" ||
+                           endsWith(name, "_bin") ||
+                           endsWith(name, "_ci") ||
+                           endsWith(name, "_cs") ||
+                           endsWith(name, "_ks");
+
+    if (!valid_collation)
+        return false;
+
+    auto collation_node = std::make_shared<ASTCollation>();
+    collation_node->collation = collation;
+    node = collation_node;
+    return true;
+}
+
 
 template <TokenType ...tokens>
 static bool isOneOf(TokenType token)
diff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h
index 10b4f5fd7d1e..f4dfe80f43e7 100644
--- a/src/Parsers/ExpressionElementParsers.h
+++ b/src/Parsers/ExpressionElementParsers.h
@@ -217,6 +217,18 @@ class ParserCodec : public IParserBase
     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
 };
 
+/** Parse collation
+  * COLLATE utf8_unicode_ci NOT NULL
+  */
+class ParserCollation : public IParserBase
+{
+protected:
+    const char * getName() const override { return "collation"; }
+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;
+private:
+    static const char * valid_collations[];
+};
+
 /// Fast path of cast operator "::".
 /// It tries to read literal as text.
 /// If it fails, later operator will be transformed to function CAST.
diff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h
index a6d3476e3f74..702c8402f6ad 100644
--- a/src/Parsers/ParserCreateQuery.h
+++ b/src/Parsers/ParserCreateQuery.h
@@ -132,9 +132,11 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     ParserKeyword s_ttl{"TTL"};
     ParserKeyword s_remove{"REMOVE"};
     ParserKeyword s_type{"TYPE"};
+    ParserKeyword s_collate{"COLLATE"};
     ParserTernaryOperatorExpression expr_parser;
     ParserStringLiteral string_literal_parser;
     ParserCodec codec_parser;
+    ParserCollation collation_parser;
     ParserExpression expression_parser;
 
     /// mandatory column name
@@ -170,6 +172,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
     ASTPtr comment_expression;
     ASTPtr codec_expression;
     ASTPtr ttl_expression;
+    ASTPtr collation_expression;
 
     if (!s_default.checkWithoutMoving(pos, expected)
         && !s_materialized.checkWithoutMoving(pos, expected)
@@ -183,6 +186,11 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
             return false;
         if (!type_parser.parse(pos, type, expected))
             return false;
+        if (s_collate.ignore(pos, expected))
+        {
+            if (!collation_parser.parse(pos, collation_expression, expected))
+                return false;
+        }
     }
 
     Pos pos_before_specifier = pos;
@@ -269,6 +277,11 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E
         column_declaration->ttl = ttl_expression;
         column_declaration->children.push_back(std::move(ttl_expression));
     }
+    if (collation_expression)
+    {
+        column_declaration->collation = collation_expression;
+        column_declaration->children.push_back(std::move(collation_expression));
+    }
 
     return true;
 }
