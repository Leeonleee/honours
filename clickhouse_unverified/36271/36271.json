{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36271,
  "instance_id": "ClickHouse__ClickHouse-36271",
  "issue_numbers": [
    "35892"
  ],
  "base_commit": "d74d8632923495cc06f603cb4fb788168a66b37a",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex aa78456702ce..69125815d36f 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -351,6 +351,8 @@ class IColumn;\n     M(UInt64, partial_merge_join_left_table_buffer_bytes, 0, \"If not 0 group left table blocks in bigger ones for left-side table in partial merge join. It uses up to 2x of specified memory per joining thread.\", 0) \\\n     M(UInt64, partial_merge_join_rows_in_right_blocks, 65536, \"Split right-hand joining data in blocks of specified size. It's a portion of data indexed by min-max values and possibly unloaded on disk.\", 0) \\\n     M(UInt64, join_on_disk_max_files_to_merge, 64, \"For MergeJoin on disk set how much files it's allowed to sort simultaneously. Then this value bigger then more memory used and then less disk I/O needed. Minimum is 2.\", 0) \\\n+    M(Bool, compatibility_ignore_collation_in_create_table, true, \"Compatibility ignore collation in create table\", 0) \\\n+    \\\n     M(String, temporary_files_codec, \"LZ4\", \"Set compression codec for temporary files (sort and join on disk). I.e. LZ4, NONE.\", 0) \\\n     \\\n     M(UInt64, max_rows_to_transfer, 0, \"Maximum size (in rows) of the transmitted external table obtained when the GLOBAL IN/JOIN section is executed.\", 0) \\\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 24c58c819a4f..b6efb28a04c4 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -460,8 +460,12 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n     {\n         const auto & col_decl = ast->as<ASTColumnDeclaration &>();\n \n-        DataTypePtr column_type = nullptr;\n+        if (col_decl.collation && !context_->getSettingsRef().compatibility_ignore_collation_in_create_table)\n+        {\n+            throw Exception(\"Cannot support collation, please set compatibility_ignore_collation_in_create_table=true\", ErrorCodes::NOT_IMPLEMENTED);\n+        }\n \n+        DataTypePtr column_type = nullptr;\n         if (col_decl.type)\n         {\n             column_type = DataTypeFactory::instance().get(col_decl.type);\ndiff --git a/src/Parsers/ASTCollation.cpp b/src/Parsers/ASTCollation.cpp\nnew file mode 100644\nindex 000000000000..197164145811\n--- /dev/null\n+++ b/src/Parsers/ASTCollation.cpp\n@@ -0,0 +1,21 @@\n+#include <Parsers/ASTCollation.h>\n+\n+namespace DB\n+{\n+    ASTPtr ASTCollation::clone() const\n+    {\n+        auto res = std::make_shared<ASTCollation>(*this);\n+        res->collation = collation->clone();\n+        return res;\n+    }\n+\n+    void ASTCollation::formatImpl(const FormatSettings &s, FormatState &state, FormatStateStacked frame) const\n+    {\n+        if (collation)\n+        {\n+            collation->formatImpl(s, state, frame);\n+        }\n+\n+    }\n+\n+}\ndiff --git a/src/Parsers/ASTCollation.h b/src/Parsers/ASTCollation.h\nnew file mode 100644\nindex 000000000000..a735956a90e8\n--- /dev/null\n+++ b/src/Parsers/ASTCollation.h\n@@ -0,0 +1,20 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+\n+namespace DB\n+{\n+\n+class ASTCollation : public IAST\n+{\n+public:\n+    ASTPtr collation = nullptr;\n+\n+    String getID(char) const override { return \"Collation\"; }\n+\n+    ASTPtr clone() const override;\n+\n+    void formatImpl(const FormatSettings & s, FormatState & state, FormatStateStacked frame) const override;\n+};\n+\n+}\ndiff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp\nindex 888cd639fb09..dc5651d9f14f 100644\n--- a/src/Parsers/ASTColumnDeclaration.cpp\n+++ b/src/Parsers/ASTColumnDeclaration.cpp\n@@ -43,6 +43,11 @@ ASTPtr ASTColumnDeclaration::clone() const\n         res->ttl = ttl->clone();\n         res->children.push_back(res->ttl);\n     }\n+    if (collation)\n+    {\n+        res->collation = collation->clone();\n+        res->children.push_back(res->collation);\n+    }\n \n     return res;\n }\n@@ -97,6 +102,12 @@ void ASTColumnDeclaration::formatImpl(const FormatSettings & settings, FormatSta\n         settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"TTL\" << (settings.hilite ? hilite_none : \"\") << ' ';\n         ttl->formatImpl(settings, state, frame);\n     }\n+\n+    if (collation)\n+    {\n+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"COLLATE\" << (settings.hilite ? hilite_none : \"\") << ' ';\n+        collation->formatImpl(settings, state, frame);\n+    }\n }\n \n }\ndiff --git a/src/Parsers/ASTColumnDeclaration.h b/src/Parsers/ASTColumnDeclaration.h\nindex ea17a8b4dfa3..5ecfb859abcb 100644\n--- a/src/Parsers/ASTColumnDeclaration.h\n+++ b/src/Parsers/ASTColumnDeclaration.h\n@@ -19,6 +19,7 @@ class ASTColumnDeclaration : public IAST\n     ASTPtr comment;\n     ASTPtr codec;\n     ASTPtr ttl;\n+    ASTPtr collation;\n \n     String getID(char delim) const override { return \"ColumnDeclaration\" + (delim + name); }\n \ndiff --git a/src/Parsers/CMakeLists.txt b/src/Parsers/CMakeLists.txt\nindex b2c313669291..73f300fd5f6e 100644\n--- a/src/Parsers/CMakeLists.txt\n+++ b/src/Parsers/CMakeLists.txt\n@@ -4,7 +4,7 @@ add_headers_and_sources(clickhouse_parsers .)\n add_headers_and_sources(clickhouse_parsers ./Access)\n add_headers_and_sources(clickhouse_parsers ./MySQL)\n add_library(clickhouse_parsers ${clickhouse_parsers_headers} ${clickhouse_parsers_sources})\n-target_link_libraries(clickhouse_parsers PUBLIC clickhouse_common_io clickhouse_common_access)\n+target_link_libraries(clickhouse_parsers PUBLIC clickhouse_common_io clickhouse_common_access string_utils)\n \n if (USE_DEBUG_HELPERS)\n     # CMake generator expression will do insane quoting when it encounters special character like quotes, spaces, etc.\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex cd07e304a39f..b7c044062979 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -7,8 +7,10 @@\n #include <IO/ReadHelpers.h>\n #include <Parsers/DumpASTNode.h>\n #include <Common/typeid_cast.h>\n+#include <Common/StringUtils/StringUtils.h>\n \n #include <Parsers/ASTAsterisk.h>\n+#include <Parsers/ASTCollation.h>\n #include <Parsers/ASTColumnsTransformers.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTFunction.h>\n@@ -1309,6 +1311,31 @@ bool ParserCodec::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     return true;\n }\n \n+bool ParserCollation::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr collation;\n+\n+    if (!ParserIdentifier(true).parse(pos, collation, expected))\n+        return false;\n+\n+    // check the collation name is valid\n+    const String name = getIdentifierName(collation);\n+\n+    bool valid_collation = name == \"binary\" ||\n+                           endsWith(name, \"_bin\") ||\n+                           endsWith(name, \"_ci\") ||\n+                           endsWith(name, \"_cs\") ||\n+                           endsWith(name, \"_ks\");\n+\n+    if (!valid_collation)\n+        return false;\n+\n+    auto collation_node = std::make_shared<ASTCollation>();\n+    collation_node->collation = collation;\n+    node = collation_node;\n+    return true;\n+}\n+\n \n template <TokenType ...tokens>\n static bool isOneOf(TokenType token)\ndiff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h\nindex 10b4f5fd7d1e..f4dfe80f43e7 100644\n--- a/src/Parsers/ExpressionElementParsers.h\n+++ b/src/Parsers/ExpressionElementParsers.h\n@@ -217,6 +217,18 @@ class ParserCodec : public IParserBase\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n+/** Parse collation\n+  * COLLATE utf8_unicode_ci NOT NULL\n+  */\n+class ParserCollation : public IParserBase\n+{\n+protected:\n+    const char * getName() const override { return \"collation\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+private:\n+    static const char * valid_collations[];\n+};\n+\n /// Fast path of cast operator \"::\".\n /// It tries to read literal as text.\n /// If it fails, later operator will be transformed to function CAST.\ndiff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h\nindex a6d3476e3f74..702c8402f6ad 100644\n--- a/src/Parsers/ParserCreateQuery.h\n+++ b/src/Parsers/ParserCreateQuery.h\n@@ -132,9 +132,11 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_ttl{\"TTL\"};\n     ParserKeyword s_remove{\"REMOVE\"};\n     ParserKeyword s_type{\"TYPE\"};\n+    ParserKeyword s_collate{\"COLLATE\"};\n     ParserTernaryOperatorExpression expr_parser;\n     ParserStringLiteral string_literal_parser;\n     ParserCodec codec_parser;\n+    ParserCollation collation_parser;\n     ParserExpression expression_parser;\n \n     /// mandatory column name\n@@ -170,6 +172,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ASTPtr comment_expression;\n     ASTPtr codec_expression;\n     ASTPtr ttl_expression;\n+    ASTPtr collation_expression;\n \n     if (!s_default.checkWithoutMoving(pos, expected)\n         && !s_materialized.checkWithoutMoving(pos, expected)\n@@ -183,6 +186,11 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n             return false;\n         if (!type_parser.parse(pos, type, expected))\n             return false;\n+        if (s_collate.ignore(pos, expected))\n+        {\n+            if (!collation_parser.parse(pos, collation_expression, expected))\n+                return false;\n+        }\n     }\n \n     Pos pos_before_specifier = pos;\n@@ -269,6 +277,11 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n         column_declaration->ttl = ttl_expression;\n         column_declaration->children.push_back(std::move(ttl_expression));\n     }\n+    if (collation_expression)\n+    {\n+        column_declaration->collation = collation_expression;\n+        column_declaration->children.push_back(std::move(collation_expression));\n+    }\n \n     return true;\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02269_create_table_with_collation.reference b/tests/queries/0_stateless/02269_create_table_with_collation.reference\nnew file mode 100644\nindex 000000000000..f84ea16742ed\n--- /dev/null\n+++ b/tests/queries/0_stateless/02269_create_table_with_collation.reference\n@@ -0,0 +1,5 @@\n+CREATE TABLE t\n+(\n+    `x` varchar(255) NOT NULL COLLATE binary\n+)\n+ENGINE = Memory\ndiff --git a/tests/queries/0_stateless/02269_create_table_with_collation.sql b/tests/queries/0_stateless/02269_create_table_with_collation.sql\nnew file mode 100644\nindex 000000000000..7a42944319b0\n--- /dev/null\n+++ b/tests/queries/0_stateless/02269_create_table_with_collation.sql\n@@ -0,0 +1,13 @@\n+EXPLAIN SYNTAX CREATE TABLE t (x varchar(255) COLLATE binary NOT NULL) ENGINE=Memory;\n+\n+EXPLAIN SYNTAX CREATE TABLE t (x varchar(255) COLLATE NOT NULL) ENGINE=Memory; -- {clientError SYNTAX_ERROR}\n+EXPLAIN SYNTAX CREATE TABLE t (x varchar(255) COLLATE NULL) ENGINE=Memory; -- {clientError SYNTAX_ERROR}\n+EXPLAIN SYNTAX CREATE TABLE t (x varchar(255) COLLATE something_else NOT NULL) ENGINE=Memory; -- {clientError SYNTAX_ERROR}\n+\n+SET compatibility_ignore_collation_in_create_table=false;\n+CREATE TABLE t_02267_collation (x varchar(255) COLLATE utf8_unicode_ci NOT NULL) ENGINE = Memory; -- {serverError NOT_IMPLEMENTED}\n+\n+SET compatibility_ignore_collation_in_create_table=true;\n+CREATE TABLE t_02267_collation (x varchar(255) COLLATE utf8_unicode_ci NOT NULL) ENGINE = Memory;\n+\n+DROP TABLE t_02267_collation;\n",
  "problem_statement": "Parse collations in CREATE TABLE, throw exception or ignore.\n**Use case**\r\n\r\nEasy migration from MySQL.\r\n\r\n**Describe the solution you'd like**\r\n\r\nSyntax like `x varchar(255) COLLATE utf8_unicode_ci NOT NULL,` should be parsed and supported on AST level.\r\nInterpreter should throw exception if collation is provided, unless a setting `compatibility_ignore_collation_in_create_table` is set to 1 (in that case they are ignored).\n",
  "hints_text": "I can take this work. Could you please assignme\n IMHO, I will create a parser called `ParserCollation` to parse it, save the result in a member of `ASTColumnDeclaration`.   is it feasible ? :). @alexey-milovidov ",
  "created_at": "2022-04-14T17:12:13Z"
}