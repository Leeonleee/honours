{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25974,
  "instance_id": "ClickHouse__ClickHouse-25974",
  "issue_numbers": [
    "3446"
  ],
  "base_commit": "cf2fc94d9da403933a7b0cf4431ac22c12e444c7",
  "patch": "diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 8e54036a21c3..fb410336dcb8 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -357,6 +357,7 @@ inline bool isTuple(const DataTypePtr & data_type) { return WhichDataType(data_t\n inline bool isArray(const DataTypePtr & data_type) { return WhichDataType(data_type).isArray(); }\n inline bool isMap(const DataTypePtr & data_type) { return WhichDataType(data_type).isMap(); }\n inline bool isNothing(const DataTypePtr & data_type) { return WhichDataType(data_type).isNothing(); }\n+inline bool isUUID(const DataTypePtr & data_type) { return WhichDataType(data_type).isUUID(); }\n \n template <typename T>\n inline bool isUInt8(const T & data_type)\ndiff --git a/src/Functions/CRC.cpp b/src/Functions/CRC.cpp\nindex 6083e5ef16f0..00aa631c85b0 100644\n--- a/src/Functions/CRC.cpp\n+++ b/src/Functions/CRC.cpp\n@@ -110,6 +110,11 @@ struct CRCFunctionWrapper\n         throw Exception(\"Cannot apply function \" + std::string(Impl::name) + \" to Array argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n \n+    [[noreturn]] static void uuid(const ColumnUUID::Container & /*offsets*/, size_t /*n*/, PaddedPODArray<ReturnType> & /*res*/)\n+    {\n+        throw Exception(\"Cannot apply function \" + std::string(Impl::name) + \" to UUID argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n+\n private:\n     static ReturnType doCRC(const ColumnString::Chars & buf, size_t offset, size_t size)\n     {\ndiff --git a/src/Functions/EmptyImpl.h b/src/Functions/EmptyImpl.h\nindex 164441135bd9..c3117e0e52db 100644\n--- a/src/Functions/EmptyImpl.h\n+++ b/src/Functions/EmptyImpl.h\n@@ -54,6 +54,12 @@ struct EmptyImpl\n             prev_offset = offsets[i];\n         }\n     }\n+\n+    static void uuid(const ColumnUUID::Container & container, size_t n, PaddedPODArray<UInt8> & res)\n+    {\n+        for (size_t i = 0; i < n; ++i)\n+            res[i] = negative ^ (container.data()->toUnderType() == 0);\n+    }\n };\n \n }\ndiff --git a/src/Functions/FunctionStringOrArrayToT.h b/src/Functions/FunctionStringOrArrayToT.h\nindex 158179fffe99..69f0741a741a 100644\n--- a/src/Functions/FunctionStringOrArrayToT.h\n+++ b/src/Functions/FunctionStringOrArrayToT.h\n@@ -8,6 +8,7 @@\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnMap.h>\n+#include <Columns/ColumnsNumber.h>\n \n \n namespace DB\n@@ -43,7 +44,9 @@ class FunctionStringOrArrayToT : public IFunction\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isStringOrFixedString(arguments[0])\n-            && !isArray(arguments[0]) && !isMap(arguments[0]))\n+            && !isArray(arguments[0])\n+            && !isMap(arguments[0])\n+            && !isUUID(arguments[0]))\n             throw Exception(\"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n \n         return std::make_shared<DataTypeNumber<ResultType>>();\n@@ -51,7 +54,7 @@ class FunctionStringOrArrayToT : public IFunction\n \n     bool useDefaultImplementationForConstants() const override { return true; }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         const ColumnPtr column = arguments[0].column;\n         if (const ColumnString * col = checkAndGetColumn<ColumnString>(column.get()))\n@@ -104,6 +107,14 @@ class FunctionStringOrArrayToT : public IFunction\n             Impl::array(col_nested.getOffsets(), vec_res);\n             return col_res;\n         }\n+        else if (const ColumnUUID * col_uuid = checkAndGetColumn<ColumnUUID>(column.get()))\n+        {\n+            auto col_res = ColumnVector<ResultType>::create();\n+            typename ColumnVector<ResultType>::Container & vec_res = col_res->getData();\n+            vec_res.resize(col_uuid->size());\n+            Impl::uuid(col_uuid->getData(), input_rows_count, vec_res);\n+            return col_res;\n+        }\n         else\n             throw Exception(\"Illegal column \" + arguments[0].column->getName() + \" of argument of function \" + getName(),\n                 ErrorCodes::ILLEGAL_COLUMN);\ndiff --git a/src/Functions/array/length.cpp b/src/Functions/array/length.cpp\nindex a7fe2fb0662f..768590c63130 100644\n--- a/src/Functions/array/length.cpp\n+++ b/src/Functions/array/length.cpp\n@@ -5,7 +5,10 @@\n \n namespace DB\n {\n-\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n \n /** Calculates the length of a string in bytes.\n   */\n@@ -35,6 +38,11 @@ struct LengthImpl\n         for (size_t i = 0; i < size; ++i)\n             res[i] = offsets[i] - offsets[i - 1];\n     }\n+\n+    [[noreturn]] static void uuid(const ColumnUUID::Container &, size_t &, PaddedPODArray<UInt64> &)\n+    {\n+        throw Exception(\"Cannot apply function length to UUID argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n };\n \n \ndiff --git a/src/Functions/isValidUTF8.cpp b/src/Functions/isValidUTF8.cpp\nindex e3158bb709cd..abdda53990d6 100644\n--- a/src/Functions/isValidUTF8.cpp\n+++ b/src/Functions/isValidUTF8.cpp\n@@ -317,6 +317,11 @@ SOFTWARE.\n     {\n         throw Exception(\"Cannot apply function isValidUTF8 to Array argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n+\n+    [[noreturn]] static void uuid(const ColumnUUID::Container &, size_t &, PaddedPODArray<UInt8> &)\n+    {\n+        throw Exception(\"Cannot apply function isValidUTF8 to UUID argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n };\n \n struct NameIsValidUTF8\ndiff --git a/src/Functions/lengthUTF8.cpp b/src/Functions/lengthUTF8.cpp\nindex c067fd4db3ca..349635160a6f 100644\n--- a/src/Functions/lengthUTF8.cpp\n+++ b/src/Functions/lengthUTF8.cpp\n@@ -53,6 +53,11 @@ struct LengthUTF8Impl\n     {\n         throw Exception(\"Cannot apply function lengthUTF8 to Array argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n+\n+    [[noreturn]] static void uuid(const ColumnUUID::Container &, size_t &, PaddedPODArray<UInt64> &)\n+    {\n+        throw Exception(\"Cannot apply function lengthUTF8 to UUID argument\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+    }\n };\n \n struct NameLengthUTF8\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01936_empty_function_support_uuid.reference b/tests/queries/0_stateless/01936_empty_function_support_uuid.reference\nnew file mode 100644\nindex 000000000000..30373074c1ff\n--- /dev/null\n+++ b/tests/queries/0_stateless/01936_empty_function_support_uuid.reference\n@@ -0,0 +1,4 @@\n+1\n+0\n+1\t2\n+2\t1\ndiff --git a/tests/queries/0_stateless/01936_empty_function_support_uuid.sql b/tests/queries/0_stateless/01936_empty_function_support_uuid.sql\nnew file mode 100644\nindex 000000000000..c67f38b776ac\n--- /dev/null\n+++ b/tests/queries/0_stateless/01936_empty_function_support_uuid.sql\n@@ -0,0 +1,35 @@\n+SELECT empty(toUUID('00000000-0000-0000-0000-000000000000'));\n+SELECT notEmpty(toUUID('00000000-0000-0000-0000-000000000000'));\n+SELECT uniqIf(uuid, empty(uuid)), uniqIf(uuid, notEmpty(uuid))\n+FROM\n+(\n+    SELECT toUUID('00000000-0000-0000-0000-000000000002') AS uuid\n+    UNION ALL\n+    SELECT toUUID('00000000-0000-0000-0000-000000000000') AS uuid\n+    UNION ALL\n+    SELECT toUUID('00000000-0000-0000-0000-000000000001') AS uuid\n+);\n+\n+DROP TABLE IF EXISTS users;\n+DROP TABLE IF EXISTS orders;\n+\n+CREATE TABLE users (user_id UUID) ENGINE = Memory;\n+CREATE TABLE orders (order_id UUID, user_id UUID) ENGINE = Memory;\n+\n+INSERT INTO users VALUES ('00000000-0000-0000-0000-000000000001');\n+INSERT INTO users VALUES ('00000000-0000-0000-0000-000000000002');\n+INSERT INTO orders VALUES ('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-000000000001');\n+\n+SELECT\n+    uniq(user_id) AS users,\n+    uniqIf(order_id, notEmpty(order_id)) AS orders\n+FROM\n+(\n+    SELECT * FROM users\n+) t1 ALL LEFT JOIN (\n+    SELECT * FROM orders\n+) t2 USING (user_id);\n+\n+DROP TABLE users;\n+DROP TABLE orders;\n+\n",
  "problem_statement": "DB::Exception: Illegal type UUID of argument of function notEmpty.\nVersion 18.14.54409\r\n\r\nWhen executing JOIN's involving UUID column, you could expect that some of them are not filled in; so using the notEmpty() should be possible; However it seems that this is currently not supported.\r\n\r\nTestcase:\r\n```sql\r\nCREATE DATABASE uuid_empty;\r\nCREATE TABLE uuid_empty.users (user_id UUID) ENGINE = Memory;\r\nCREATE TABLE uuid_empty.orders (order_id UUID, user_id UUID) ENGINE = Memory;\r\nINSERT INTO uuid_empty.users VALUES ('00000000-0000-0000-0000-000000000001');\r\nINSERT INTO uuid_empty.users VALUES ('00000000-0000-0000-0000-000000000002');\r\nINSERT INTO uuid_empty.orders VALUES ('00000000-0000-0000-0000-000000000003', '00000000-0000-0000-0000-000000000001');\r\n\r\nSELECT \r\n    uniq(user_id) AS users, \r\n    uniqIf(order_id, notEmpty(order_id)) AS orders\r\nFROM \r\n(\r\n    SELECT * FROM uuid_empty.users\r\n) ALL LEFT JOIN (\r\n    SELECT * FROM uuid_empty.orders \r\n) USING (user_id);\r\n\r\nDROP DATABASE uuid_empty;\r\n```\r\nShould result in (currently the result using String type)\r\n```sql\r\n\u250c\u2500users\u2500\u252c\u2500orders\u2500\u2510\r\n\u2502     2 \u2502      1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\nBut now returns\r\n```\r\nReceived exception from server (version 18.14.54409):\r\nCode: 43. DB::Exception: Received from localhost:9000, 127.0.0.1. DB::Exception: Illegal type UUID of argument of function notEmpty. \r\n\r\n```\r\n\r\nExecuting the following query without aggregating gives the (empty?) uuid `00000000-0000-0000-0000-000000000000`?\r\n\r\n```sql\r\nSELECT \r\n    user_id, \r\n    order_id\r\nFROM \r\n(\r\n    SELECT *\r\n    FROM uuid_empty.users \r\n) \r\nALL LEFT JOIN \r\n(\r\n    SELECT *\r\n    FROM uuid_empty.orders \r\n) USING (user_id)\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500user_id\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500order_id\u2500\u2510\r\n\u2502 00000000-0000-0000-0000-000000000001 \u2502 00000000-0000-0000-0000-000000000003 \u2502\r\n\u2502 00000000-0000-0000-0000-000000000002 \u2502 00000000-0000-0000-0000-000000000000 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\n\r\n\r\n\n",
  "hints_text": "Simpler test-case:\r\n```\r\nselect notEmpty(toUUID('00000000-0000-0000-0000-000000000000'));\r\n```",
  "created_at": "2021-07-04T14:45:27Z",
  "modified_files": [
    "src/DataTypes/IDataType.h",
    "src/Functions/CRC.cpp",
    "src/Functions/EmptyImpl.h",
    "src/Functions/FunctionStringOrArrayToT.h",
    "src/Functions/array/length.cpp",
    "src/Functions/isValidUTF8.cpp",
    "src/Functions/lengthUTF8.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01936_empty_function_support_uuid.reference",
    "b/tests/queries/0_stateless/01936_empty_function_support_uuid.sql"
  ]
}