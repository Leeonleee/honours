{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21640,
  "instance_id": "ClickHouse__ClickHouse-21640",
  "issue_numbers": [
    "19288",
    "19645",
    "14614"
  ],
  "base_commit": "cc60059b500390eb0836847c01528ca316c35ddc",
  "patch": "diff --git a/src/Storages/transformQueryForExternalDatabase.cpp b/src/Storages/transformQueryForExternalDatabase.cpp\nindex 42daf8cfc267..28e7c09cc44e 100644\n--- a/src/Storages/transformQueryForExternalDatabase.cpp\n+++ b/src/Storages/transformQueryForExternalDatabase.cpp\n@@ -160,8 +160,78 @@ bool isCompatible(const IAST & node)\n     return node.as<ASTIdentifier>();\n }\n \n+bool removeUnknownSubexpressions(ASTPtr & node, const NameSet & known_names);\n+\n+void removeUnknownChildren(ASTs & children, const NameSet & known_names)\n+{\n+\n+    ASTs new_children;\n+    for (auto & child : children)\n+    {\n+        bool leave_child = removeUnknownSubexpressions(child, known_names);\n+        if (leave_child)\n+            new_children.push_back(child);\n+    }\n+    children = std::move(new_children);\n+}\n+\n+/// return `true` if we should leave node in tree\n+bool removeUnknownSubexpressions(ASTPtr & node, const NameSet & known_names)\n+{\n+    if (const auto * ident = node->as<ASTIdentifier>())\n+        return known_names.contains(ident->name());\n+\n+    if (node->as<ASTLiteral>() != nullptr)\n+        return true;\n+\n+    auto * func = node->as<ASTFunction>();\n+    if (func && (func->name == \"and\" || func->name == \"or\"))\n+    {\n+        removeUnknownChildren(func->arguments->children, known_names);\n+        /// all children removed, current node can be removed too\n+        if (func->arguments->children.size() == 1)\n+        {\n+            /// if only one child left, pull it on top level\n+            node = func->arguments->children[0];\n+            return true;\n+        }\n+        return !func->arguments->children.empty();\n+    }\n+\n+    bool leave_child = true;\n+    for (auto & child : node->children)\n+    {\n+        leave_child = leave_child && removeUnknownSubexpressions(child, known_names);\n+        if (!leave_child)\n+            break;\n+    }\n+    return leave_child;\n }\n \n+// When a query references an external table such as table from MySQL database,\n+// the corresponding table storage has to execute the relevant part of the query. We\n+// send the query to the storage as AST. Before that, we have to remove the conditions\n+// that reference other tables from `WHERE`, so that the external engine is not confused\n+// by the unknown columns.\n+bool removeUnknownSubexpressionsFromWhere(ASTPtr & node, const NamesAndTypesList & available_columns)\n+{\n+    if (!node)\n+        return false;\n+\n+    NameSet known_names;\n+    for (const auto & col : available_columns)\n+        known_names.insert(col.name);\n+\n+    if (auto * expr_list = node->as<ASTExpressionList>(); expr_list && !expr_list->children.empty())\n+    {\n+        /// traverse expression list on top level\n+        removeUnknownChildren(expr_list->children, known_names);\n+        return !expr_list->children.empty();\n+    }\n+    return removeUnknownSubexpressions(node, known_names);\n+}\n+\n+}\n \n String transformQueryForExternalDatabase(\n     const SelectQueryInfo & query_info,\n@@ -191,7 +261,8 @@ String transformQueryForExternalDatabase(\n       */\n \n     ASTPtr original_where = clone_query->as<ASTSelectQuery &>().where();\n-    if (original_where)\n+    bool where_has_known_columns = removeUnknownSubexpressionsFromWhere(original_where, available_columns);\n+    if (original_where && where_has_known_columns)\n     {\n         replaceConstantExpressions(original_where, context, available_columns);\n \n",
  "test_patch": "diff --git a/src/Storages/tests/gtest_transform_query_for_external_database.cpp b/src/Storages/tests/gtest_transform_query_for_external_database.cpp\nindex 99dfc55ed696..d40c62fef602 100644\n--- a/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n+++ b/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n@@ -23,15 +23,6 @@ struct State\n     State(const State&) = delete;\n \n     Context context;\n-    NamesAndTypesList columns{\n-        {\"column\", std::make_shared<DataTypeUInt8>()},\n-        {\"apply_id\", std::make_shared<DataTypeUInt64>()},\n-        {\"apply_type\", std::make_shared<DataTypeUInt8>()},\n-        {\"apply_status\", std::make_shared<DataTypeUInt8>()},\n-        {\"create_time\", std::make_shared<DataTypeDateTime>()},\n-        {\"field\", std::make_shared<DataTypeString>()},\n-        {\"value\", std::make_shared<DataTypeString>()},\n-    };\n \n     static const State & instance()\n     {\n@@ -39,27 +30,83 @@ struct State\n         return state;\n     }\n \n+    const NamesAndTypesList & getColumns() const\n+    {\n+        return tables[0].columns;\n+    }\n+\n+    std::vector<TableWithColumnNamesAndTypes> getTables(size_t num = 0) const\n+    {\n+        std::vector<TableWithColumnNamesAndTypes> res;\n+        for (size_t i = 0; i < std::min(num, tables.size()); ++i)\n+            res.push_back(tables[i]);\n+        return res;\n+    }\n+\n private:\n+\n+    static DatabaseAndTableWithAlias createDBAndTable(String table_name)\n+    {\n+        DatabaseAndTableWithAlias res;\n+        res.database = \"test\";\n+        res.table = table_name;\n+        return res;\n+    }\n+\n+    const std::vector<TableWithColumnNamesAndTypes> tables{\n+        TableWithColumnNamesAndTypes(\n+            createDBAndTable(\"table\"),\n+            {\n+                {\"column\", std::make_shared<DataTypeUInt8>()},\n+                {\"apply_id\", std::make_shared<DataTypeUInt64>()},\n+                {\"apply_type\", std::make_shared<DataTypeUInt8>()},\n+                {\"apply_status\", std::make_shared<DataTypeUInt8>()},\n+                {\"create_time\", std::make_shared<DataTypeDateTime>()},\n+                {\"field\", std::make_shared<DataTypeString>()},\n+                {\"value\", std::make_shared<DataTypeString>()},\n+            }),\n+        TableWithColumnNamesAndTypes(\n+            createDBAndTable(\"table2\"),\n+            {\n+                {\"num\", std::make_shared<DataTypeUInt8>()},\n+                {\"attr\", std::make_shared<DataTypeString>()},\n+            }),\n+    };\n+\n     explicit State()\n         : context(getContext().context)\n     {\n         tryRegisterFunctions();\n         DatabasePtr database = std::make_shared<DatabaseMemory>(\"test\", context);\n-        database->attachTable(\"table\", StorageMemory::create(StorageID(\"test\", \"table\"), ColumnsDescription{columns}, ConstraintsDescription{}));\n-        DatabaseCatalog::instance().attachDatabase(\"test\", database);\n+\n+        for (const auto & tab : tables)\n+        {\n+            const auto & table_name = tab.table.table;\n+            const auto & db_name = tab.table.database;\n+            database->attachTable(\n+                table_name,\n+                StorageMemory::create(StorageID(db_name, table_name), ColumnsDescription{getColumns()}, ConstraintsDescription{}));\n+        }\n+        DatabaseCatalog::instance().attachDatabase(database->getDatabaseName(), database);\n         context.setCurrentDatabase(\"test\");\n     }\n };\n \n-\n-static void check(const std::string & query, const std::string & expected, const Context & context, const NamesAndTypesList & columns)\n+static void check(\n+    const State & state,\n+    size_t table_num,\n+    const std::string & query,\n+    const std::string & expected)\n {\n     ParserSelectQuery parser;\n     ASTPtr ast = parseQuery(parser, query, 1000, 1000);\n     SelectQueryInfo query_info;\n-    query_info.syntax_analyzer_result = TreeRewriter(context).analyzeSelect(ast, columns);\n+    SelectQueryOptions select_options;\n+    query_info.syntax_analyzer_result\n+        = TreeRewriter(state.context).analyzeSelect(ast, state.getColumns(), select_options, state.getTables(table_num));\n     query_info.query = ast;\n-    std::string transformed_query = transformQueryForExternalDatabase(query_info, columns, IdentifierQuotingStyle::DoubleQuotes, \"test\", \"table\", context);\n+    std::string transformed_query = transformQueryForExternalDatabase(\n+        query_info, state.getColumns(), IdentifierQuotingStyle::DoubleQuotes, \"test\", \"table\", state.context);\n \n     EXPECT_EQ(transformed_query, expected);\n }\n@@ -69,82 +116,93 @@ TEST(TransformQueryForExternalDatabase, InWithSingleElement)\n {\n     const State & state = State::instance();\n \n-    check(\"SELECT column FROM test.table WHERE 1 IN (1)\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE 1)\",\n-          state.context, state.columns);\n-    check(\"SELECT column FROM test.table WHERE column IN (1, 2)\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" IN (1, 2))\",\n-          state.context, state.columns);\n-    check(\"SELECT column FROM test.table WHERE column NOT IN ('hello', 'world')\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" NOT IN ('hello', 'world'))\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE 1 IN (1)\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE 1)\");\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE column IN (1, 2)\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" IN (1, 2))\");\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE column NOT IN ('hello', 'world')\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" NOT IN ('hello', 'world'))\");\n }\n \n TEST(TransformQueryForExternalDatabase, InWithTable)\n {\n     const State & state = State::instance();\n \n-    check(\"SELECT column FROM test.table WHERE 1 IN external_table\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\")\",\n-          state.context, state.columns);\n-    check(\"SELECT column FROM test.table WHERE 1 IN (x)\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\")\",\n-          state.context, state.columns);\n-    check(\"SELECT column, field, value FROM test.table WHERE column IN (field, value)\",\n-          R\"(SELECT \"column\", \"field\", \"value\" FROM \"test\".\"table\" WHERE \"column\" IN (\"field\", \"value\"))\",\n-          state.context, state.columns);\n-    check(\"SELECT column FROM test.table WHERE column NOT IN hello AND column = 123\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE (\"column\" = 123))\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE 1 IN external_table\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\")\");\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE 1 IN (x)\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\")\");\n+    check(state, 1,\n+          \"SELECT column, field, value FROM test.table WHERE column IN (field, value)\",\n+          R\"(SELECT \"column\", \"field\", \"value\" FROM \"test\".\"table\" WHERE \"column\" IN (\"field\", \"value\"))\");\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE column NOT IN hello AND column = 123\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" = 123)\");\n }\n \n TEST(TransformQueryForExternalDatabase, Like)\n {\n     const State & state = State::instance();\n \n-    check(\"SELECT column FROM test.table WHERE column LIKE '%hello%'\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" LIKE '%hello%')\",\n-          state.context, state.columns);\n-    check(\"SELECT column FROM test.table WHERE column NOT LIKE 'w%rld'\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" NOT LIKE 'w%rld')\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE column LIKE '%hello%'\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" LIKE '%hello%')\");\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE column NOT LIKE 'w%rld'\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE \"column\" NOT LIKE 'w%rld')\");\n }\n \n TEST(TransformQueryForExternalDatabase, Substring)\n {\n     const State & state = State::instance();\n \n-    check(\"SELECT column FROM test.table WHERE left(column, 10) = RIGHT(column, 10) AND SUBSTRING(column FROM 1 FOR 2) = 'Hello'\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\")\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE left(column, 10) = RIGHT(column, 10) AND SUBSTRING(column FROM 1 FOR 2) = 'Hello'\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\")\");\n }\n \n TEST(TransformQueryForExternalDatabase, MultipleAndSubqueries)\n {\n     const State & state = State::instance();\n \n-    check(\"SELECT column FROM test.table WHERE 1 = 1 AND toString(column) = '42' AND column = 42 AND left(column, 10) = RIGHT(column, 10) AND column IN (1, 42) AND SUBSTRING(column FROM 1 FOR 2) = 'Hello' AND column != 4\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE 1 AND (\"column\" = 42) AND (\"column\" IN (1, 42)) AND (\"column\" != 4))\",\n-          state.context, state.columns);\n-    check(\"SELECT column FROM test.table WHERE toString(column) = '42' AND left(column, 10) = RIGHT(column, 10) AND column = 42\",\n-          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE (\"column\" = 42))\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE 1 = 1 AND toString(column) = '42' AND column = 42 AND left(column, 10) = RIGHT(column, 10) AND column IN (1, 42) AND SUBSTRING(column FROM 1 FOR 2) = 'Hello' AND column != 4\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE 1 AND (\"column\" = 42) AND (\"column\" IN (1, 42)) AND (\"column\" != 4))\");\n+    check(state, 1,\n+          \"SELECT column FROM test.table WHERE toString(column) = '42' AND left(column, 10) = RIGHT(column, 10) AND column = 42\",\n+          R\"(SELECT \"column\" FROM \"test\".\"table\" WHERE (\"column\" = 42))\");\n }\n \n TEST(TransformQueryForExternalDatabase, Issue7245)\n {\n     const State & state = State::instance();\n \n-    check(\"select apply_id from test.table where apply_type = 2 and create_time > addDays(toDateTime('2019-01-01 01:02:03'),-7) and apply_status in (3,4)\",\n-          R\"(SELECT \"apply_id\", \"apply_type\", \"apply_status\", \"create_time\" FROM \"test\".\"table\" WHERE (\"apply_type\" = 2) AND (\"create_time\" > '2018-12-25 01:02:03') AND (\"apply_status\" IN (3, 4)))\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT apply_id FROM test.table WHERE apply_type = 2 AND create_time > addDays(toDateTime('2019-01-01 01:02:03'),-7) AND apply_status IN (3,4)\",\n+          R\"(SELECT \"apply_id\", \"apply_type\", \"apply_status\", \"create_time\" FROM \"test\".\"table\" WHERE (\"apply_type\" = 2) AND (\"create_time\" > '2018-12-25 01:02:03') AND (\"apply_status\" IN (3, 4)))\");\n }\n \n TEST(TransformQueryForExternalDatabase, Aliases)\n {\n     const State & state = State::instance();\n \n-    check(\"SELECT field AS value, field AS display WHERE field NOT IN ('') AND display LIKE '%test%'\",\n-          R\"(SELECT \"field\" FROM \"test\".\"table\" WHERE (\"field\" NOT IN ('')) AND (\"field\" LIKE '%test%'))\",\n-          state.context, state.columns);\n+    check(state, 1,\n+          \"SELECT field AS value, field AS display WHERE field NOT IN ('') AND display LIKE '%test%'\",\n+          R\"(SELECT \"field\" FROM \"test\".\"table\" WHERE (\"field\" NOT IN ('')) AND (\"field\" LIKE '%test%'))\");\n+}\n+\n+TEST(TransformQueryForExternalDatabase, ForeignColumnInWhere)\n+{\n+    const State & state = State::instance();\n+\n+    check(state, 2,\n+          \"SELECT column FROM test.table \"\n+          \"JOIN test.table2 AS table2 ON (test.table.apply_id = table2.num) \"\n+          \"WHERE column > 2 AND (apply_id = 1 OR table2.num = 1) AND table2.attr != ''\",\n+          R\"(SELECT \"column\", \"apply_id\" FROM \"test\".\"table\" WHERE (\"column\" > 2) AND (\"apply_id\" = 1))\");\n }\ndiff --git a/tests/integration/test_mysql_database_engine/test.py b/tests/integration/test_mysql_database_engine/test.py\nindex 4d10e2ea6f5a..f4b0bb1b2fc4 100644\n--- a/tests/integration/test_mysql_database_engine/test.py\n+++ b/tests/integration/test_mysql_database_engine/test.py\n@@ -146,10 +146,14 @@ def test_clickhouse_join_for_mysql_database(started_cluster):\n             \"CREATE TABLE default.t1_remote_mysql AS mysql('mysql1:3306','test','t1_mysql_local','root','clickhouse')\")\n         clickhouse_node.query(\n             \"CREATE TABLE default.t2_remote_mysql AS mysql('mysql1:3306','test','t2_mysql_local','root','clickhouse')\")\n+        clickhouse_node.query(\"INSERT INTO `default`.`t1_remote_mysql` VALUES ('EN','A',''),('RU','B','AAA')\")\n+        clickhouse_node.query(\"INSERT INTO `default`.`t2_remote_mysql` VALUES ('A','AAA'),('Z','')\")\n+        \n         assert clickhouse_node.query(\"SELECT s.pays \"\n                                      \"FROM default.t1_remote_mysql AS s \"\n                                      \"LEFT JOIN default.t1_remote_mysql AS s_ref \"\n-                                     \"ON (s_ref.opco = s.opco AND s_ref.service = s.service)\") == ''\n+                                     \"ON (s_ref.opco = s.opco AND s_ref.service = s.service) \"\n+                                     \"WHERE s_ref.opco != '' AND s.opco != '' \").rstrip() == 'RU'\n         mysql_node.query(\"DROP DATABASE test\")\n \n \n",
  "problem_statement": "MySQL (table function, database engine) WHERE clause can't have condition on column from right table\n**Describe the bug**\r\nWhen you trying to join different mysql tables, clickhouse would accept in WHERE clause only columns from left table.\r\n\r\n**Does it reproduce on recent release?**\r\nYes\r\n\r\n**How to reproduce**\r\nClickhouse 21.1\r\n\r\n```\r\ndocker run --name misaka -e MYSQL_ROOT_PASSWORD=xxxxx -p 3306:3306 -d mysql:latest\r\nmysql --host 127.0.0.1 --password\r\n> use mysql;\r\n> CREATE TABLE members (\r\n    member_id INT AUTO_INCREMENT,\r\n    name VARCHAR(100),\r\n    PRIMARY KEY (member_id)\r\n);\r\n\r\n> CREATE TABLE committees (\r\n    committee_id INT AUTO_INCREMENT,\r\n    name VARCHAR(100),\r\n    PRIMARY KEY (committee_id)\r\n);\r\n\r\n\r\n> INSERT INTO members(name)\r\nVALUES('John'),('Jane'),('Mary'),('David'),('Amelia');\r\n\r\n> INSERT INTO committees(name)\r\nVALUES('John'),('Mary'),('Amelia'),('Joe');\r\n\r\nclickhouse\r\n\r\n CREATE DATABASE mysql ENGINE=MySQL('127.0.0.1:3306','mysql','root','xxxxx');\r\n\r\n\r\nSELECT *\r\nFROM mysql.members AS m\r\nINNER JOIN mysql.committees AS c ON m.name = c.name\r\n\r\n\u250c\u2500member_id\u2500\u252c\u2500name\u2500\u2500\u2500\u252c\u2500committee_id\u2500\u252c\u2500c.name\u2500\u2510\r\n\u2502         1 \u2502 John   \u2502            1 \u2502 John   \u2502\r\n\u2502         3 \u2502 Mary   \u2502            2 \u2502 Mary   \u2502\r\n\u2502         5 \u2502 Amelia \u2502            3 \u2502 Amelia \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT *\r\nFROM mysql.members AS m\r\nINNER JOIN mysql.committees AS c ON m.name = c.name\r\nWHERE committee_id = 2\r\n\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'committee_id' while processing query: 'committee_id = 2', required columns: 'committee_id' 'committee_id'\r\n\r\nSELECT *\r\nFROM mysql.members AS m\r\nINNER JOIN mysql.committees AS c ON m.name = c.name\r\nWHERE `c.name` = 2\r\n\r\nCode: 386. DB::Exception: Received from localhost:9000. DB::Exception: There is no supertype for types String, UInt8 because some of them are String/FixedString and some of them are not: while executing 'FUNCTION equals(c.name : 3, 2 : 4) -> equals(c.name, 2) Nullable(UInt8) : 5'. \r\n\r\n^ Clickhouse actually know that c.name type is String.\r\n```\r\n\r\n**Additional context**\r\nIt looks like that clickhouse trying to push all WHERE conditions to the left mysql table.\r\nhttps://github.com/ClickHouse/ClickHouse/issues/14614 Looks like related.\nWhy do join and filters get errors\uff1f\ntable A:\r\n![image](https://user-images.githubusercontent.com/17606375/105842341-f9b40580-6010-11eb-8507-6ea46fe814c8.png)\r\ntable B:\r\n![image](https://user-images.githubusercontent.com/17606375/105842364-0173aa00-6011-11eb-94a3-47c162dd40fd.png)\r\n\r\nselect \r\n  \"T_8FB5CF\".\"id1\" \"__fcol_0\", \r\n  \"T_8FB5CF\".\"id2\" \"__fcol_1\", \r\n  \"T_8FB5CF\".\"id3\" \"__fcol_2\", \r\n  \"T_8FB5CF\".\"id4\" \"__fcol_3\", \r\n  \"T_8FB5CF\".\"id5\" \"__fcol_4\", \r\n  \"T_8FB5CF\".\"date\" \"__fcol_5\", \r\n  \"T_8FB5CF\".\"shuzhi\" \"__fcol_6\", \r\n  \"T_8FB5CF\".\"\u6570\u503c2\" \"__fcol_7\"\r\nfrom \"A1\".\"B\" \"T_8FB5CF\"\r\n  left outer join \"A1\".\"A\" \"T_8C7546\"\r\n  on \"T_8FB5CF\".\"id2\" = \"T_8C7546\".\"id2\"\r\nwhere (\r\n  \"T_8C7546\".\"id2\" = ''\r\n  or \"T_8C7546\".\"id2\" is null\r\n)\r\nlimit 5000\r\nClickHouse exception, code: 47, host: 192.168.5.67, port: 8123; Code: 47, e.displayText() = DB::Exception: Missing columns: 'T_8C7546.id2' while processing query: '(T_8C7546.id2 = '') OR isNull(T_8C7546.id2)', required columns: 'T_8C7546.id2', source columns: '\u6570\u503c2' 'shuzhi' 'date' 'id5' 'id3' 'id2' 'id4' 'id1' (version 20.5.4.40)\nJoining MySQL table and MergeTree table causes 'Missing columns'\n**Describe the bug**\r\nIf you make a query to MySQL Engine Table with joined MergeTree Engine Table, you use any columns of the latter.\r\n\r\n\r\n**How to reproduce**\r\n* ClickHouse server 20.8.2\r\n* ClickHouse client version 20.8.2.3 (official build).\r\n\r\n```sql\r\nCREATE TABLE mysql_table\r\n(\r\n    `id` UInt64,\r\n    `name` Nullable(String),\r\n)\r\nENGINE = MySQL('test:3306', 'test', 'test', 'test', 'test');\r\n```\r\n\r\n```sql\r\nCREATE TABLE ch_table\r\n(\r\n    `id` UInt64,\r\n    `mysql_item_id` UInt64,\r\n    `d` DateTime\r\n)\r\nENGINE = MergeTree()\r\nPARTITION BY toYYYYMM(d)\r\nORDER BY d;\r\n```\r\n\r\nQuery \r\n```sql\r\n    SELECT *\r\n    FROM mysql_table AS t_mysql_table\r\n    LEFT JOIN ch_table AS t_ch_table \r\n         ON t_ch_table.mysql_item_id = t_mysql_table.id\r\n    WHERE t_ch_table.id > 100\r\n```\r\n\r\n**Expected behavior**\r\nReturns empty result without errors.\r\n\r\n**Error message and/or stacktrace**\r\n```\r\nCode: 47. DB::Exception: Received from test:9000. DB::Exception: Missing columns: 't_ch_table.id' while processing query: 't_ch_table.id > 100', required columns: 't_ch_table.id', source columns: 'id', 'name'. \r\n```\r\n\n",
  "hints_text": "If left table would be the clickhouse table, everything is working.\r\n\r\n```\r\nSELECT *\r\nFROM system.one\r\n, mysql.members AS m\r\nINNER JOIN mysql.committees AS c ON m.name = c.name\r\nWHERE (m.name = 'John') AND (committee_id = 1)\r\n\r\nQuery id: 7a31a655-d240-457d-a613-86c214c7553f\r\n\r\n\u250c\u2500one.dummy\u2500\u252c\u2500m.member_id\u2500\u252c\u2500m.name\u2500\u252c\u2500c.committee_id\u2500\u252c\u2500c.name\u2500\u2510\r\n\u2502         0 \u2502           1 \u2502 John   \u2502              1 \u2502 John   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nSELECT *\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM mysql.members\r\n) AS m\r\nINNER JOIN mysql.committees AS c ON m.name = c.name\r\nWHERE (m.name = 'John') AND (committee_id = 1)\r\n\r\nQuery id: 0b930ed0-9a8e-44e1-8a6a-5d3e6d34ec8c\r\n\r\n\u250c\u2500member_id\u2500\u252c\u2500name\u2500\u252c\u2500committee_id\u2500\u252c\u2500c.name\u2500\u2510\r\n\u2502         1 \u2502 John \u2502            1 \u2502 John   \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nThat's true. When preparing a query to be sent to external database, it does not analyze for what tables the columns from WHERE belong.\nMaybe it's better to not push down any conditions in presense of JOIN.\nOtherwise more complications will arise, e.g. RIGHT JOIN ... WHERE column IS NULL.\n20.5.4.40 is obsolete.\r\n\r\nPlease check against 21.1.2.15\r\n\r\nPlease provide `show create table \"A1\".\"B\"` and `show create table \"A1\".\"A\" `\n> 20.5.4.40 is obsolete.\r\n> \r\n> Please check against 21.1.2.15\r\n> \r\n> Please provide `show create table \"A1\".\"B\"` and `show create table \"A1\".\"A\" `\r\n\r\n\r\n\r\n> 20.5.4.40 is obsolete.\r\n> \r\n> Please check against 21.1.2.15\r\n> \r\n> Please provide `show create table \"A1\".\"B\"` and `show create table \"A1\".\"A\" `\r\n\r\nplease help me! thanks\r\nCREATE TABLE A1.B\r\n(\r\nid1 Nullable(String),\r\nid2 Nullable(String),\r\nid3 Nullable(String),\r\nid4 Nullable(String),\r\nid5 Nullable(String),\r\ndate Nullable(Date),\r\nshuzhi Nullable(Int32),\r\n\u6570\u503c2 Nullable(Int32)\r\n)\r\nENGINE = MySQL('192.168.5.57:3306', 'pearl', 'B', 'root', 'root')\r\n\r\nCREATE TABLE A1.A\r\n(\r\nid123 Nullable(String),\r\nid2 Nullable(String),\r\nid 3 Nullable(String),\r\ndate Nullable(Date),\r\nshuzhi Nullable(Int32),\r\n\u6570\u503c2 Nullable(Int32)\r\n)\r\nENGINE = MySQL('192.168.5.57:3306', 'pearl', 'A', 'root', 'root')\n```\r\nDROP DATABASE IF EXISTS A1;\r\nCREATE DATABASE A1;\r\n\r\nCREATE TABLE A1.B\r\n(\r\n    `id1` Nullable(String),\r\n    `id2` Nullable(String),\r\n    `id3` Nullable(String),\r\n    `id4` Nullable(String),\r\n    `id5` Nullable(String),\r\n    `date` Nullable(Date),\r\n    `shuzhi` Nullable(Int32),\r\n    `\u6570\u503c2` Nullable(Int32)\r\n)\r\nENGINE = Memory;\r\n\r\nCREATE TABLE A1.A\r\n(\r\n    `id123` Nullable(String),\r\n    `id2` Nullable(String),\r\n    `id3` Nullable(String),\r\n    `date` Nullable(Date),\r\n    `shuzhi` Nullable(Int32),\r\n    `\u6570\u503c2` Nullable(Int32)\r\n)\r\nENGINE = Memory;\r\n\r\nSELECT\r\n    T_8FB5CF.id1 AS __fcol_0,\r\n    T_8FB5CF.id2 AS __fcol_1,\r\n    T_8FB5CF.id3 AS __fcol_2,\r\n    T_8FB5CF.id4 AS __fcol_3,\r\n    T_8FB5CF.id5 AS __fcol_4,\r\n    T_8FB5CF.date AS __fcol_5,\r\n    T_8FB5CF.shuzhi AS __fcol_6,\r\n    T_8FB5CF.`\u6570\u503c2` AS __fcol_7\r\nFROM A1.B AS T_8FB5CF\r\nLEFT JOIN A1.A AS T_8C7546 ON T_8FB5CF.id2 = T_8C7546.id2\r\nWHERE (T_8C7546.id2 = '') OR isNull(T_8C7546.id2)\r\nLIMIT 5000;\r\n```\r\n\r\nOk.\r\n\r\n```\r\nDROP DATABASE IF EXISTS A1;\r\nCREATE DATABASE A1;\r\n\r\nCREATE TABLE A1.B\r\n(\r\n    `id1` Nullable(String),\r\n    `id2` Nullable(String),\r\n    `id3` Nullable(String),\r\n    `id4` Nullable(String),\r\n    `id5` Nullable(String),\r\n    `date` Nullable(Date),\r\n    `shuzhi` Nullable(Int32),\r\n    `\u6570\u503c2` Nullable(Int32)\r\n)\r\nENGINE = MySQL('192.168.5.57:3306', 'pearl', 'B', 'root', 'root');\r\n\r\nCREATE TABLE A1.A\r\n(\r\n    `id123` Nullable(String),\r\n    `id2` Nullable(String),\r\n    `id3` Nullable(String),\r\n    `date` Nullable(Date),\r\n    `shuzhi` Nullable(Int32),\r\n    `\u6570\u503c2` Nullable(Int32)\r\n)\r\nENGINE = MySQL('192.168.5.57:3306', 'pearl', 'A', 'root', 'root');\r\n\r\nSELECT\r\n    T_8FB5CF.id1 AS __fcol_0,\r\n    T_8FB5CF.id2 AS __fcol_1,\r\n    T_8FB5CF.id3 AS __fcol_2,\r\n    T_8FB5CF.id4 AS __fcol_3,\r\n    T_8FB5CF.id5 AS __fcol_4,\r\n    T_8FB5CF.date AS __fcol_5,\r\n    T_8FB5CF.shuzhi AS __fcol_6,\r\n    T_8FB5CF.`\u6570\u503c2` AS __fcol_7\r\nFROM A1.B AS T_8FB5CF\r\nLEFT JOIN A1.A AS T_8C7546 ON T_8FB5CF.id2 = T_8C7546.id2\r\nWHERE (T_8C7546.id2 = '') OR isNull(T_8C7546.id2)\r\nLIMIT 5000;\r\n\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'T_8C7546.id2' while processing query: '(T_8C7546.id2 = '') OR isNull(T_8C7546.id2)', required columns: 'T_8C7546.id2' 'T_8C7546.id2'. \r\n```\r\n\r\nFail.\nWe have the same issue. Is this fixed in the newer versions? @4ertus2 \r\n\r\nThanks.\n> Is this fixed in the newer versions?\r\n\r\nProbably not. I'm a bit out of context.\n@4ertus2 This is now working for us. But nobody changed anything or upgraded in our environment. I don't know what to do now. Should we trust this as \"it's working\" or we should continue to test it?\nI assume the issue occurs when the joined table has more than 1 entry. We started adding GROUP BY with aggregations and it works fine now.  I'm closing the issue. Thanks.",
  "created_at": "2021-03-11T17:55:16Z"
}