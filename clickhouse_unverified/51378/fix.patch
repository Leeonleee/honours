diff --git a/src/Common/QueryProfiler.cpp b/src/Common/QueryProfiler.cpp
index 085c8fb8af49..313d4b77739d 100644
--- a/src/Common/QueryProfiler.cpp
+++ b/src/Common/QueryProfiler.cpp
@@ -120,6 +120,15 @@ void Timer::createIfNecessary(UInt64 thread_id, int clock_type, int pause_signal
                 throw Exception(ErrorCodes::CANNOT_CREATE_TIMER, "Failed to create thread timer. The function "
                                 "'timer_create' returned non-zero but didn't set errno. This is bug in your OS.");
 
+            /// For example, it cannot be created if the server is run under QEMU:
+            /// "Failed to create thread timer, errno: 11, strerror: Resource temporarily unavailable."
+
+            /// You could accidentally run the server under QEMU without being aware,
+            /// if you use Docker image for a different architecture,
+            /// and you have the "binfmt-misc" kernel module, and "qemu-user" tools.
+
+            /// Also, it cannot be created if the server has too many threads.
+
             throwFromErrno("Failed to create thread timer", ErrorCodes::CANNOT_CREATE_TIMER);
         }
         timer_id.emplace(local_timer_id);
diff --git a/src/Common/StringSearcher.h b/src/Common/StringSearcher.h
index 3ed192d05f33..b3065354f654 100644
--- a/src/Common/StringSearcher.h
+++ b/src/Common/StringSearcher.h
@@ -793,88 +793,6 @@ class StringSearcher<false, false> : public StringSearcherBase
     }
 };
 
-
-// Searches for needle surrounded by token-separators.
-// Separators are anything inside ASCII (0-128) and not alphanum.
-// Any value outside of basic ASCII (>=128) is considered a non-separator symbol, hence UTF-8 strings
-// should work just fine. But any Unicode whitespace is not considered a token separtor.
-template <typename StringSearcher>
-class TokenSearcher : public StringSearcherBase
-{
-    StringSearcher searcher;
-    size_t needle_size;
-
-public:
-
-    template <typename CharT>
-    requires (sizeof(CharT) == 1)
-    static bool isValidNeedle(const CharT * needle_, size_t needle_size_)
-    {
-        return std::none_of(needle_, needle_ + needle_size_, isTokenSeparator);
-    }
-
-    template <typename CharT>
-    requires (sizeof(CharT) == 1)
-    TokenSearcher(const CharT * needle_, size_t needle_size_)
-        : searcher(needle_, needle_size_)
-        , needle_size(needle_size_)
-    {
-        /// The caller is responsible for calling isValidNeedle()
-        chassert(isValidNeedle(needle_, needle_size_));
-    }
-
-    template <typename CharT>
-    requires (sizeof(CharT) == 1)
-    ALWAYS_INLINE bool compare(const CharT * haystack, const CharT * haystack_end, const CharT * pos) const
-    {
-        // use searcher only if pos is in the beginning of token and pos + searcher.needle_size is end of token.
-        if (isToken(haystack, haystack_end, pos))
-            return searcher.compare(haystack, haystack_end, pos);
-
-        return false;
-    }
-
-    template <typename CharT>
-    requires (sizeof(CharT) == 1)
-    const CharT * search(const CharT * haystack, const CharT * const haystack_end) const
-    {
-        // use searcher.search(), then verify that returned value is a token
-        // if it is not, skip it and re-run
-
-        const auto * pos = haystack;
-        while (pos < haystack_end)
-        {
-            pos = searcher.search(pos, haystack_end);
-            if (pos == haystack_end || isToken(haystack, haystack_end, pos))
-                return pos;
-
-            // assuming that heendle does not contain any token separators.
-            pos += needle_size;
-        }
-        return haystack_end;
-    }
-
-    template <typename CharT>
-    requires (sizeof(CharT) == 1)
-    const CharT * search(const CharT * haystack, size_t haystack_size) const
-    {
-        return search(haystack, haystack + haystack_size);
-    }
-
-    template <typename CharT>
-    requires (sizeof(CharT) == 1)
-    ALWAYS_INLINE bool isToken(const CharT * haystack, const CharT * const haystack_end, const CharT* p) const
-    {
-        return (p == haystack || isTokenSeparator(*(p - 1)))
-             && (p + needle_size >= haystack_end || isTokenSeparator(*(p + needle_size)));
-    }
-
-    ALWAYS_INLINE static bool isTokenSeparator(const uint8_t c)
-    {
-        return !(isAlphaNumericASCII(c) || !isASCII(c));
-    }
-};
-
 }
 
 using ASCIICaseSensitiveStringSearcher =   impl::StringSearcher<true, true>;
@@ -882,9 +800,6 @@ using ASCIICaseInsensitiveStringSearcher = impl::StringSearcher<false, true>;
 using UTF8CaseSensitiveStringSearcher =    impl::StringSearcher<true, false>;
 using UTF8CaseInsensitiveStringSearcher =  impl::StringSearcher<false, false>;
 
-using ASCIICaseSensitiveTokenSearcher =    impl::TokenSearcher<ASCIICaseSensitiveStringSearcher>;
-using ASCIICaseInsensitiveTokenSearcher =  impl::TokenSearcher<ASCIICaseInsensitiveStringSearcher>;
-
 /// Use only with short haystacks where cheap initialization is required.
 template <bool CaseInsensitive>
 struct StdLibASCIIStringSearcher
@@ -906,11 +821,11 @@ struct StdLibASCIIStringSearcher
         if constexpr (CaseInsensitive)
             return std::search(
                 haystack_start, haystack_end, needle_start, needle_end,
-                [](char c1, char c2) {return std::toupper(c1) == std::toupper(c2);});
+                [](char c1, char c2) { return std::toupper(c1) == std::toupper(c2); });
         else
             return std::search(
                 haystack_start, haystack_end, needle_start, needle_end,
-                [](char c1, char c2) {return c1 == c2;});
+                [](char c1, char c2) { return c1 == c2; });
     }
 
     template <typename CharT>
diff --git a/src/Common/Volnitsky.h b/src/Common/Volnitsky.h
index 8f9aa23a38aa..3360c197984f 100644
--- a/src/Common/Volnitsky.h
+++ b/src/Common/Volnitsky.h
@@ -730,9 +730,6 @@ using VolnitskyUTF8 = VolnitskyBase<true, false, UTF8CaseSensitiveStringSearcher
 using VolnitskyCaseInsensitive = VolnitskyBase<false, true, ASCIICaseInsensitiveStringSearcher>; /// ignores non-ASCII bytes
 using VolnitskyCaseInsensitiveUTF8 = VolnitskyBase<false, false, UTF8CaseInsensitiveStringSearcher>;
 
-using VolnitskyCaseSensitiveToken = VolnitskyBase<true, true, ASCIICaseSensitiveTokenSearcher>;
-using VolnitskyCaseInsensitiveToken = VolnitskyBase<false, true, ASCIICaseInsensitiveTokenSearcher>;
-
 using MultiVolnitsky = MultiVolnitskyBase<true, true, ASCIICaseSensitiveStringSearcher>;
 using MultiVolnitskyUTF8 = MultiVolnitskyBase<true, false, UTF8CaseSensitiveStringSearcher>;
 using MultiVolnitskyCaseInsensitive = MultiVolnitskyBase<false, true, ASCIICaseInsensitiveStringSearcher>;
diff --git a/src/Functions/HasTokenImpl.h b/src/Functions/HasTokenImpl.h
index 8cacdfff99d9..fdec5fcb0b7b 100644
--- a/src/Functions/HasTokenImpl.h
+++ b/src/Functions/HasTokenImpl.h
@@ -17,7 +17,7 @@ namespace ErrorCodes
 
 /** Token search the string, means that needle must be surrounded by some separator chars, like whitespace or puctuation.
   */
-template <typename Name, typename TokenSearcher, bool negate>
+template <typename Name, typename Searcher, bool negate>
 struct HasTokenImpl
 {
     using ResultType = UInt8;
@@ -46,7 +46,7 @@ struct HasTokenImpl
         const UInt8 * const end = haystack_data.data() + haystack_data.size();
         const UInt8 * pos = begin;
 
-        if (!ASCIICaseSensitiveTokenSearcher::isValidNeedle(pattern.data(), pattern.size()))
+        if (!std::none_of(pattern.begin(), pattern.end(), isTokenSeparator))
         {
             if (res_null)
             {
@@ -58,7 +58,8 @@ struct HasTokenImpl
                 throw Exception(ErrorCodes::BAD_ARGUMENTS, "Needle must not contain whitespace or separator characters");
         }
 
-        TokenSearcher searcher(pattern.data(), pattern.size(), end - pos);
+        size_t pattern_size = pattern.size();
+        Searcher searcher(pattern.data(), pattern_size, end - pos);
         if (res_null)
             std::ranges::fill(res_null->getData(), false);
 
@@ -67,21 +68,31 @@ struct HasTokenImpl
         /// We will search for the next occurrence in all rows at once.
         while (pos < end && end != (pos = searcher.search(pos, end - pos)))
         {
-            /// Let's determine which index it refers to.
-            while (begin + haystack_offsets[i] <= pos)
+            /// The found substring is a token
+            if ((pos == begin || isTokenSeparator(pos[-1]))
+                && (pos + pattern_size == end || isTokenSeparator(pos[pattern_size])))
             {
-                res[i] = negate;
+                /// Let's determine which index it refers to.
+                while (begin + haystack_offsets[i] <= pos)
+                {
+                    res[i] = negate;
+                    ++i;
+                }
+
+                /// We check that the entry does not pass through the boundaries of strings.
+                if (pos + pattern.size() < begin + haystack_offsets[i])
+                    res[i] = !negate;
+                else
+                    res[i] = negate;
+
+                pos = begin + haystack_offsets[i];
                 ++i;
             }
-
-            /// We check that the entry does not pass through the boundaries of strings.
-            if (pos + pattern.size() < begin + haystack_offsets[i])
-                res[i] = !negate;
             else
-                res[i] = negate;
-
-            pos = begin + haystack_offsets[i];
-            ++i;
+            {
+                /// Not a token. Jump over it.
+                pos += pattern_size;
+            }
         }
 
         /// Tail, in which there can be no substring.
@@ -113,6 +124,12 @@ struct HasTokenImpl
     {
         throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Function '{}' doesn't support FixedString haystack argument", name);
     }
+
+private:
+    static bool isTokenSeparator(UInt8 c)
+    {
+        return isASCII(c) && !isAlphaNumericASCII(c);
+    }
 };
 
 }
diff --git a/src/Functions/hasToken.cpp b/src/Functions/hasToken.cpp
index b90750ea233d..fa41abf26415 100644
--- a/src/Functions/hasToken.cpp
+++ b/src/Functions/hasToken.cpp
@@ -6,6 +6,7 @@
 
 namespace DB
 {
+
 struct NameHasToken
 {
     static constexpr auto name = "hasToken";
@@ -17,9 +18,9 @@ struct NameHasTokenOrNull
 };
 
 using FunctionHasToken
-    = FunctionsStringSearch<HasTokenImpl<NameHasToken, VolnitskyCaseSensitiveToken, false>>;
+    = FunctionsStringSearch<HasTokenImpl<NameHasToken, Volnitsky, false>>;
 using FunctionHasTokenOrNull
-    = FunctionsStringSearch<HasTokenImpl<NameHasTokenOrNull, VolnitskyCaseSensitiveToken, false>, ExecutionErrorPolicy::Null>;
+    = FunctionsStringSearch<HasTokenImpl<NameHasTokenOrNull, Volnitsky, false>, ExecutionErrorPolicy::Null>;
 
 REGISTER_FUNCTION(HasToken)
 {
diff --git a/src/Functions/hasTokenCaseInsensitive.cpp b/src/Functions/hasTokenCaseInsensitive.cpp
index d7381e336b56..32675b9384d5 100644
--- a/src/Functions/hasTokenCaseInsensitive.cpp
+++ b/src/Functions/hasTokenCaseInsensitive.cpp
@@ -6,6 +6,7 @@
 
 namespace DB
 {
+
 struct NameHasTokenCaseInsensitive
 {
     static constexpr auto name = "hasTokenCaseInsensitive";
@@ -17,9 +18,9 @@ struct NameHasTokenCaseInsensitiveOrNull
 };
 
 using FunctionHasTokenCaseInsensitive
-    = FunctionsStringSearch<HasTokenImpl<NameHasTokenCaseInsensitive, VolnitskyCaseInsensitiveToken, false>>;
+    = FunctionsStringSearch<HasTokenImpl<NameHasTokenCaseInsensitive, VolnitskyCaseInsensitive, false>>;
 using FunctionHasTokenCaseInsensitiveOrNull
-    = FunctionsStringSearch<HasTokenImpl<NameHasTokenCaseInsensitiveOrNull, VolnitskyCaseInsensitiveToken, false>, ExecutionErrorPolicy::Null>;
+    = FunctionsStringSearch<HasTokenImpl<NameHasTokenCaseInsensitiveOrNull, VolnitskyCaseInsensitive, false>, ExecutionErrorPolicy::Null>;
 
 REGISTER_FUNCTION(HasTokenCaseInsensitive)
 {
