diff --git a/src/Analyzer/ColumnNode.cpp b/src/Analyzer/ColumnNode.cpp
index 2b514a85121b..8034c3f8f45c 100644
--- a/src/Analyzer/ColumnNode.cpp
+++ b/src/Analyzer/ColumnNode.cpp
@@ -16,7 +16,11 @@ namespace ErrorCodes
     extern const int LOGICAL_ERROR;
 }
 
-ColumnNode::ColumnNode(NameAndTypePair column_, QueryTreeNodePtr expression_node_, QueryTreeNodeWeakPtr column_source_)
+ColumnNode::ColumnNode(
+    NameAndTypePair column_,
+    QueryTreeNodePtr expression_node_,
+    QueryTreeNodeWeakPtr column_source_
+)
     : IQueryTreeNode(children_size, weak_pointers_size)
     , column(std::move(column_))
 {
@@ -24,10 +28,12 @@ ColumnNode::ColumnNode(NameAndTypePair column_, QueryTreeNodePtr expression_node
     getSourceWeakPointer() = std::move(column_source_);
 }
 
-ColumnNode::ColumnNode(NameAndTypePair column_, QueryTreeNodeWeakPtr column_source_)
+ColumnNode::ColumnNode(
+    NameAndTypePair column_,
+    QueryTreeNodeWeakPtr column_source_
+)
     : ColumnNode(std::move(column_), nullptr /*expression_node*/, std::move(column_source_))
-{
-}
+{}
 
 QueryTreeNodePtr ColumnNode::getColumnSource() const
 {
diff --git a/src/Analyzer/Resolve/ExpressionsStack.h b/src/Analyzer/Resolve/ExpressionsStack.h
index 82a27aa8b83e..3391c9d3e3f4 100644
--- a/src/Analyzer/Resolve/ExpressionsStack.h
+++ b/src/Analyzer/Resolve/ExpressionsStack.h
@@ -92,11 +92,11 @@ class ExpressionsStack
 
     void dump(WriteBuffer & buffer) const
     {
-        buffer << expressions.size() << '
';
+        buffer << "Expression resolve process stack size: " << expressions.size() << '
';
 
         for (const auto & expression : expressions)
         {
-            buffer << "Expression ";
+            buffer << " Expression ";
             buffer << expression->formatASTForErrorMessage();
 
             const auto & alias = expression->getAlias();
diff --git a/src/Analyzer/Resolve/IdentifierLookup.h b/src/Analyzer/Resolve/IdentifierLookup.h
index 570d3b33bce5..dbde19e772a0 100644
--- a/src/Analyzer/Resolve/IdentifierLookup.h
+++ b/src/Analyzer/Resolve/IdentifierLookup.h
@@ -109,41 +109,46 @@ inline const char * toString(IdentifierResolvePlace resolved_identifier_place)
     }
 }
 
+struct IdentifierResolveScope;
+
 struct IdentifierResolveResult
 {
-    IdentifierResolveResult() = default;
-
     QueryTreeNodePtr resolved_identifier;
     IdentifierResolvePlace resolve_place = IdentifierResolvePlace::NONE;
-    bool resolved_from_parent_scopes = false;
 
-    [[maybe_unused]] bool isResolved() const
+    explicit operator bool() const
     {
-        return resolve_place != IdentifierResolvePlace::NONE;
+        chassert(check_invariant());
+        return resolved_identifier != nullptr;
     }
 
-    [[maybe_unused]] bool isResolvedFromParentScopes() const
+    [[maybe_unused]] bool isResolved() const
     {
-        return resolved_from_parent_scopes;
+        chassert(check_invariant());
+        return resolve_place != IdentifierResolvePlace::NONE;
     }
 
     [[maybe_unused]] bool isResolvedFromExpressionArguments() const
     {
+        chassert(check_invariant());
         return resolve_place == IdentifierResolvePlace::EXPRESSION_ARGUMENTS;
     }
 
     [[maybe_unused]] bool isResolvedFromAliases() const
     {
+        chassert(check_invariant());
         return resolve_place == IdentifierResolvePlace::ALIASES;
     }
 
     [[maybe_unused]] bool isResolvedFromJoinTree() const
     {
+        chassert(check_invariant());
         return resolve_place == IdentifierResolvePlace::JOIN_TREE;
     }
 
     [[maybe_unused]] bool isResolvedFromCTEs() const
     {
+        chassert(check_invariant());
         return resolve_place == IdentifierResolvePlace::CTE;
     }
 
@@ -155,7 +160,7 @@ struct IdentifierResolveResult
             return;
         }
 
-        buffer << resolved_identifier->formatASTForErrorMessage() << " place " << toString(resolve_place) << " resolved from parent scopes " << resolved_from_parent_scopes;
+        buffer << resolved_identifier->formatASTForErrorMessage() << " place " << toString(resolve_place);
     }
 
     [[maybe_unused]] String dump() const
@@ -165,19 +170,31 @@ struct IdentifierResolveResult
 
         return buffer.str();
     }
+
+private:
+    bool check_invariant() const noexcept
+    {
+        return (resolved_identifier == nullptr) == (resolve_place == IdentifierResolvePlace::NONE);
+    }
 };
 
 struct IdentifierResolveState
 {
-    IdentifierResolveResult resolve_result;
-    bool cyclic_identifier_resolve = false;
+    size_t count = 1;
 };
 
-struct IdentifierResolveSettings
+struct IdentifierResolveContext
 {
     /// Allow to check join tree during identifier resolution
     bool allow_to_check_join_tree = true;
 
+    /// Allow to check aliases during identifier resolution.
+    /// It's not allowed to use aliases during identifier resolution in parent scopes:
+    /// 1. If enable_global_with_statement is disabled.
+    /// 2. If initial scope is a QueryNode and it's TableExpression lookup,
+    ///    identifier is allowed to be resolved only as CTE.
+    bool allow_to_check_aliases = true;
+
     /// Allow to check CTEs during table identifier resolution
     bool allow_to_check_cte = true;
 
@@ -189,6 +206,17 @@ struct IdentifierResolveSettings
 
     /// Allow to resolve subquery during identifier resolution
     bool allow_to_resolve_subquery_during_identifier_resolution = true;
+
+    /// Initial scope where identifier resolution started.
+    /// Should be used to resolve aliased expressions.
+    IdentifierResolveScope * scope_to_resolve_alias_expression = nullptr;
+
+    IdentifierResolveContext & resolveAliasesAt(IdentifierResolveScope * scope_to_resolve_alias_expression_)
+    {
+        if (!scope_to_resolve_alias_expression)
+            scope_to_resolve_alias_expression = scope_to_resolve_alias_expression_;
+        return *this;
+    }
 };
 
 }
diff --git a/src/Analyzer/Resolve/IdentifierResolveScope.cpp b/src/Analyzer/Resolve/IdentifierResolveScope.cpp
index 84f6d500f1e7..0f9f099b9e25 100644
--- a/src/Analyzer/Resolve/IdentifierResolveScope.cpp
+++ b/src/Analyzer/Resolve/IdentifierResolveScope.cpp
@@ -46,8 +46,6 @@ IdentifierResolveScope::IdentifierResolveScope(QueryTreeNodePtr scope_node_, Ide
         join_use_nulls = context->getSettingsRef()[Setting::join_use_nulls];
     else if (parent_scope)
         join_use_nulls = parent_scope->join_use_nulls;
-
-    aliases.alias_name_to_expression_node = &aliases.alias_name_to_expression_node_before_group_by;
 }
 
 [[maybe_unused]] const IdentifierResolveScope * IdentifierResolveScope::getNearestQueryScope() const
@@ -108,76 +106,77 @@ const AnalysisTableExpressionData & IdentifierResolveScope::getTableExpressionDa
 
 void IdentifierResolveScope::pushExpressionNode(const QueryTreeNodePtr & node)
 {
-    bool had_aggregate_function = expressions_in_resolve_process_stack.hasAggregateFunction();
     expressions_in_resolve_process_stack.push(node);
-    if (group_by_use_nulls && had_aggregate_function != expressions_in_resolve_process_stack.hasAggregateFunction())
-        aliases.alias_name_to_expression_node = &aliases.alias_name_to_expression_node_before_group_by;
 }
 
 void IdentifierResolveScope::popExpressionNode()
 {
-    bool had_aggregate_function = expressions_in_resolve_process_stack.hasAggregateFunction();
     expressions_in_resolve_process_stack.pop();
-    if (group_by_use_nulls && had_aggregate_function != expressions_in_resolve_process_stack.hasAggregateFunction())
-        aliases.alias_name_to_expression_node = &aliases.alias_name_to_expression_node_after_group_by;
 }
 
-/// Dump identifier resolve scope
-[[maybe_unused]] void IdentifierResolveScope::dump(WriteBuffer & buffer) const
+namespace
 {
-    buffer << "Scope node " << scope_node->formatASTForErrorMessage() << '
';
-    buffer << "Identifier lookup to resolve state " << identifier_lookup_to_resolve_state.size() << '
';
-    for (const auto & [identifier, state] : identifier_lookup_to_resolve_state)
-    {
-        buffer << "Identifier " << identifier.dump() << " resolve result ";
-        state.resolve_result.dump(buffer);
-        buffer << '
';
-    }
 
-    buffer << "Expression argument name to node " << expression_argument_name_to_node.size() << '
';
-    for (const auto & [alias_name, node] : expression_argument_name_to_node)
-        buffer << "Alias name " << alias_name << " node " << node->formatASTForErrorMessage() << '
';
+void dump_mapping(WriteBuffer & buffer, const String & mapping_name, const std::unordered_map<std::string, QueryTreeNodePtr> & mapping)
+{
+    if (mapping.empty())
+        return;
 
-    buffer << "Alias name to expression node table size " << aliases.alias_name_to_expression_node->size() << '
';
-    for (const auto & [alias_name, node] : *aliases.alias_name_to_expression_node)
-        buffer << "Alias name " << alias_name << " expression node " << node->dumpTree() << '
';
+    buffer << mapping_name << " table size: " << mapping.size() << '
';
+    for (const auto & [alias_name, node] : mapping)
+        buffer << " { '" << alias_name << "' : " << node->formatASTForErrorMessage() << " }
";
+}
 
-    buffer << "Alias name to function node table size " << aliases.alias_name_to_lambda_node.size() << '
';
-    for (const auto & [alias_name, node] : aliases.alias_name_to_lambda_node)
-        buffer << "Alias name " << alias_name << " lambda node " << node->formatASTForErrorMessage() << '
';
+void dump_list(WriteBuffer & buffer, const String & list_name, const std::ranges::viewable_range auto & list)
+{
+    if (list.empty())
+        return;
 
-    buffer << "Alias name to table expression node table size " << aliases.alias_name_to_table_expression_node.size() << '
';
-    for (const auto & [alias_name, node] : aliases.alias_name_to_table_expression_node)
-        buffer << "Alias name " << alias_name << " node " << node->formatASTForErrorMessage() << '
';
+    buffer << list_name << " table size: " << list.size() << '
';
+    for (const auto & node : list)
+        buffer << " { '" << node->getAlias() << "' : " << node->formatASTForErrorMessage() << " }
";
+}
 
-    buffer << "CTE name to query node table size " << cte_name_to_query_node.size() << '
';
-    for (const auto & [cte_name, node] : cte_name_to_query_node)
-        buffer << "CTE name " << cte_name << " node " << node->formatASTForErrorMessage() << '
';
+}
 
-    buffer << "WINDOW name to window node table size " << window_name_to_window_node.size() << '
';
-    for (const auto & [window_name, node] : window_name_to_window_node)
-        buffer << "CTE name " << window_name << " node " << node->formatASTForErrorMessage() << '
';
+/// Dump identifier resolve scope
+[[maybe_unused]] void IdentifierResolveScope::dump(WriteBuffer & buffer) const
+{
+    buffer << "Scope node " << scope_node->formatConvertedASTForErrorMessage() << '
';
 
-    buffer << "Nodes with duplicated aliases size " << aliases.nodes_with_duplicated_aliases.size() << '
';
-    for (const auto & node : aliases.nodes_with_duplicated_aliases)
-        buffer << "Alias name " << node->getAlias() << " node " << node->formatASTForErrorMessage() << '
';
+    buffer << "Identifier lookup to resolve state " << identifier_in_lookup_process.size() << '
';
+    for (const auto & [identifier, state] : identifier_in_lookup_process)
+    {
+        buffer << " { '" << identifier.dump() << "' : ";
+        buffer << state.count;
+        buffer << " }
";
+    }
 
-    buffer << "Expression resolve process stack " << '
';
-    expressions_in_resolve_process_stack.dump(buffer);
+    dump_mapping(buffer, "Expression argument name to node", expression_argument_name_to_node);
+    dump_mapping(buffer, "Alias name to expression node", aliases.alias_name_to_expression_node);
+    dump_mapping(buffer, "Alias name to function node", aliases.alias_name_to_lambda_node);
+    dump_mapping(buffer, "Alias name to table expression node", aliases.alias_name_to_table_expression_node);
+    dump_mapping(buffer, "CTE name to query node", cte_name_to_query_node);
+    dump_mapping(buffer, "WINDOW name to window node", window_name_to_window_node);
 
-    buffer << "Table expressions in resolve process size " << table_expressions_in_resolve_process.size() << '
';
-    for (const auto & node : table_expressions_in_resolve_process)
-        buffer << "Table expression " << node->formatASTForErrorMessage() << '
';
+    dump_list(buffer, "Nodes with duplicated aliases size ", aliases.nodes_with_duplicated_aliases);
+    dump_list(buffer, "Nodes to remove aliases ", aliases.node_to_remove_aliases);
 
-    buffer << "Non cached identifier lookups during expression resolve " << non_cached_identifier_lookups_during_expression_resolve.size() << '
';
-    for (const auto & identifier_lookup : non_cached_identifier_lookups_during_expression_resolve)
-        buffer << "Identifier lookup " << identifier_lookup.dump() << '
';
+    expressions_in_resolve_process_stack.dump(buffer);
 
-    buffer << "Table expression node to data " << table_expression_node_to_data.size() << '
';
+    if (!table_expressions_in_resolve_process.empty())
+    {
+        buffer << "Table expressions in resolve process size " << table_expressions_in_resolve_process.size() << '
';
+        for (const auto & node : table_expressions_in_resolve_process)
+            buffer << " { " << node->formatASTForErrorMessage() << " }
";
+    }
+
+    buffer << "Table expression node to data: " << table_expression_node_to_data.size() << '
';
     for (const auto & [table_expression_node, table_expression_data] : table_expression_node_to_data)
-        buffer << "Table expression node " << table_expression_node->formatASTForErrorMessage() << " data " << table_expression_data.dump() << '
';
+        buffer << " { " << table_expression_node->formatASTForErrorMessage() << " data:
  " << table_expression_data.dump() << " }
";
+
+    dump_list(buffer, "Registered table expression nodes", registered_table_expression_nodes);
 
-    buffer << "Use identifier lookup to result cache " << use_identifier_lookup_to_result_cache << '
';
     buffer << "Subquery depth " << subquery_depth << '
';
 }
 
diff --git a/src/Analyzer/Resolve/IdentifierResolveScope.h b/src/Analyzer/Resolve/IdentifierResolveScope.h
index ec46ce4370e1..63f9d092c250 100644
--- a/src/Analyzer/Resolve/IdentifierResolveScope.h
+++ b/src/Analyzer/Resolve/IdentifierResolveScope.h
@@ -137,7 +137,7 @@ struct IdentifierResolveScope
     ContextPtr context;
 
     /// Identifier lookup to result
-    std::unordered_map<IdentifierLookup, IdentifierResolveState, IdentifierLookupHash> identifier_lookup_to_resolve_state;
+    std::unordered_map<IdentifierLookup, IdentifierResolveState, IdentifierLookupHash> identifier_in_lookup_process;
 
     /// Argument can be expression like constant, column, function or table expression
     std::unordered_map<std::string, QueryTreeNodePtr> expression_argument_name_to_node;
@@ -159,9 +159,6 @@ struct IdentifierResolveScope
     /// Table expressions in resolve process
     std::unordered_set<const IQueryTreeNode *> table_expressions_in_resolve_process;
 
-    /// Current scope expression
-    std::unordered_set<IdentifierLookup, IdentifierLookupHash> non_cached_identifier_lookups_during_expression_resolve;
-
     /// Table expression node to data
     std::unordered_map<QueryTreeNodePtr, AnalysisTableExpressionData> table_expression_node_to_data;
 
@@ -169,12 +166,6 @@ struct IdentifierResolveScope
     std::unordered_set<QueryTreeNodePtr> registered_table_expression_nodes;
 
     QueryTreeNodePtrWithHashIgnoreTypesSet nullable_group_by_keys;
-    /// Here we count the number of nullable GROUP BY keys we met resolving expression.
-    /// E.g. for a query `SELECT tuple(tuple(number)) FROM numbers(10) GROUP BY (number, tuple(number)) with cube`
-    /// both `number` and `tuple(number)` would be in nullable_group_by_keys.
-    /// But when we resolve `tuple(tuple(number))` we should figure out that `tuple(number)` is already a key,
-    /// and we should not convert `number` to nullable.
-    size_t found_nullable_group_by_key_in_scope = 0;
 
     /** It's possible that after a JOIN, a column in the projection has a type different from the column in the source table.
       * (For example, after join_use_nulls or USING column cast to supertype)
@@ -183,9 +174,6 @@ struct IdentifierResolveScope
       */
     QueryTreeNodePtrWithHashMap<QueryTreeNodePtr> join_columns_with_changed_types;
 
-    /// Use identifier lookup to result cache
-    bool use_identifier_lookup_to_result_cache = true;
-
     /// Apply nullability to aggregation keys
     bool group_by_use_nulls = false;
     /// Join retutns NULLs instead of default values
diff --git a/src/Analyzer/Resolve/IdentifierResolver.cpp b/src/Analyzer/Resolve/IdentifierResolver.cpp
index f7b114f7dafd..e53286e356b1 100644
--- a/src/Analyzer/Resolve/IdentifierResolver.cpp
+++ b/src/Analyzer/Resolve/IdentifierResolver.cpp
@@ -228,18 +228,22 @@ void IdentifierResolver::collectScopeValidIdentifiersForTypoCorrection(
 
     if (allow_expression_identifiers)
     {
-        for (const auto & [name, expression] : *scope.aliases.alias_name_to_expression_node)
+        for (const auto & [name, expression] : scope.aliases.alias_name_to_expression_node)
         {
             assert(expression);
             auto expression_identifier = Identifier(name);
             valid_identifiers_result.insert(expression_identifier);
+        }
 
-            auto result_type = getExpressionNodeResultTypeOrNull(expression);
-
-            if (identifier_is_compound && result_type)
+        if (identifier_is_compound)
+        {
+            for (const auto & [name, expression_type] : scope.aliases.alias_name_to_expression_type)
             {
+                chassert(expression_type);
+                auto expression_identifier = Identifier(name);
+
                 collectCompoundExpressionValidIdentifiersForTypoCorrection(unresolved_identifier,
-                    result_type,
+                    expression_type,
                     expression_identifier,
                     valid_identifiers_result);
             }
@@ -258,7 +262,7 @@ void IdentifierResolver::collectScopeValidIdentifiersForTypoCorrection(
     {
         if (allow_function_identifiers)
         {
-            for (const auto & [name, _] : *scope.aliases.alias_name_to_expression_node)
+            for (const auto & [name, _] : scope.aliases.alias_name_to_expression_node)
                 valid_identifiers_result.insert(Identifier(name));
         }
 
@@ -393,7 +397,7 @@ QueryTreeNodePtr IdentifierResolver::wrapExpressionNodeInTupleElement(QueryTreeN
 /// Resolve identifier functions implementation
 
 /// Try resolve table identifier from database catalog
-std::shared_ptr<TableNode> IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(const Identifier & table_identifier, ContextPtr context)
+IdentifierResolveResult IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(const Identifier & table_identifier, const ContextPtr & context)
 {
     size_t parts_size = table_identifier.getPartsSize();
     if (parts_size < 1 || parts_size > 2)
@@ -455,7 +459,7 @@ std::shared_ptr<TableNode> IdentifierResolver::tryResolveTableIdentifierFromData
     if (is_temporary_table)
         result->setTemporaryTableName(table_name);
 
-    return result;
+    return { .resolved_identifier = result, .resolve_place = IdentifierResolvePlace::DATABASE_CATALOG };
 }
 
 /// Resolve identifier from compound expression
@@ -540,7 +544,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromCompoundExpression(
   *
   * 3. If identifier is compound and identifier lookup is in expression context use `tryResolveIdentifierFromCompoundExpression`.
   */
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromExpressionArguments(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope)
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromExpressionArguments(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope)
 {
     auto it = scope.expression_argument_name_to_node.find(identifier_lookup.identifier.getFullName());
     bool resolve_full_identifier = it != scope.expression_argument_name_to_node.end();
@@ -563,9 +567,13 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromExpressionArguments
         return {};
 
     if (!resolve_full_identifier && identifier_lookup.identifier.isCompound() && identifier_lookup.isExpressionLookup())
-        return tryResolveIdentifierFromCompoundExpression(identifier_lookup.identifier, 1 /*identifier_bind_size*/, it->second, {}, scope);
+    {
+        if (auto resolved_identifier = tryResolveIdentifierFromCompoundExpression(identifier_lookup.identifier, 1 /*identifier_bind_size*/, it->second, {}, scope))
+            return { .resolved_identifier = resolved_identifier, .resolve_place = IdentifierResolvePlace::EXPRESSION_ARGUMENTS };
+        return {};
+    }
 
-    return it->second;
+    return { .resolved_identifier = it->second, .resolve_place = IdentifierResolvePlace::EXPRESSION_ARGUMENTS };
 }
 
 bool IdentifierResolver::tryBindIdentifierToAliases(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)
@@ -706,7 +714,7 @@ bool IdentifierResolver::tryBindIdentifierToArrayJoinExpressions(const Identifie
     return result;
 }
 
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromStorage(
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromStorage(
     const Identifier & identifier,
     const QueryTreeNodePtr & table_expression_node,
     const AnalysisTableExpressionData & table_expression_data,
@@ -898,10 +906,10 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromStorage(
     auto qualified_identifier_full_name = qualified_identifier.getFullName();
     node_to_projection_name.emplace(result_expression, std::move(qualified_identifier_full_name));
 
-    return result_expression;
+    return { .resolved_identifier = result_expression, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 }
 
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromTableExpression(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromTableExpression(const IdentifierLookup & identifier_lookup,
     const QueryTreeNodePtr & table_expression_node,
     IdentifierResolveScope & scope)
 {
@@ -934,10 +942,11 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromTableExpression(con
         const auto & database_name = table_expression_data.database_name;
 
         if (parts_size == 1 && path_start == table_name)
-            return table_expression_node;
-        if (parts_size == 2 && path_start == database_name && identifier[1] == table_name)
-            return table_expression_node;
-        return {};
+            return { .resolved_identifier = table_expression_node, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
+        else if (parts_size == 2 && path_start == database_name && identifier[1] == table_name)
+            return { .resolved_identifier = table_expression_node, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
+        else
+            return {};
     }
 
      /** If identifier first part binds to some column start or table has full identifier name. Then we can try to find whole identifier in table.
@@ -958,9 +967,9 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromTableExpression(con
           * Example: `SELECT t.t from (SELECT 1 as t) AS a FULL JOIN (SELECT 1 as t) as t ON a.t = t.t;`
           * Initially, we will try to resolve t.t from `a` because `t.` is bound to `1 as t`. However, as it is not a nested column, we will need to resolve it from the second table expression.
           */
-        auto resolved_identifier = tryResolveIdentifierFromStorage(identifier, table_expression_node, table_expression_data, scope, 0 /*identifier_column_qualifier_parts*/, true /*can_be_not_found*/);
-        if (resolved_identifier)
-            return resolved_identifier;
+        auto lookup_result = tryResolveIdentifierFromStorage(identifier, table_expression_node, table_expression_data, scope, 0 /*identifier_column_qualifier_parts*/, true /*can_be_not_found*/);
+        if (lookup_result.resolved_identifier)
+            return lookup_result;
     }
 
     if (identifier.getPartsSize() == 1)
@@ -1036,23 +1045,23 @@ static JoinTableSide choseSideForEqualIdenfifiersFromJoin(
     return JoinTableSide::Left;
 }
 
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromCrossJoin(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromCrossJoin(const IdentifierLookup & identifier_lookup,
     const QueryTreeNodePtr & table_expression_node,
     IdentifierResolveScope & scope)
 {
     const auto & from_cross_join_node = table_expression_node->as<const CrossJoinNode &>();
     bool prefer_left_table = scope.joins_count == 1 && scope.context->getSettingsRef()[Setting::single_join_prefer_left_table];
 
-    QueryTreeNodePtr resolved_identifier;
+    IdentifierResolveResult resolve_result;
     for (const auto & expr : from_cross_join_node.getTableExpressions())
     {
         auto identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, expr, scope);
         if (!identifier)
             continue;
 
-        if (!resolved_identifier)
+        if (!resolve_result)
         {
-            resolved_identifier = std::move(identifier);
+            resolve_result = std::move(identifier);
             continue;
         }
 
@@ -1063,25 +1072,22 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromCrossJoin(const Ide
                 identifier_lookup.dump(),
                 scope.scope_node->formatASTForErrorMessage());
 
-
-        resolved_identifier->isEqual(*identifier, IQueryTreeNode::CompareOptions{.compare_aliases = false});
-
         /// If columns from left or right table were missed Object(Nullable('json')) subcolumns, they will be replaced
         /// to ConstantNode(NULL), which can't be cast to ColumnNode, so we resolve it here.
         // if (auto missed_subcolumn_identifier = checkIsMissedObjectJSONSubcolumn(left_resolved_identifier, right_resolved_identifier))
         //     return missed_subcolumn_identifier;
 
-        if (resolved_identifier->isEqual(*identifier, IQueryTreeNode::CompareOptions{.compare_aliases = false}))
+        if (resolve_result.resolved_identifier->isEqual(*identifier.resolved_identifier, IQueryTreeNode::CompareOptions{.compare_aliases = false}))
         {
             const auto & identifier_path_part = identifier_lookup.identifier.front();
-            auto * left_resolved_identifier_column = resolved_identifier->as<ColumnNode>();
-            auto * right_resolved_identifier_column = identifier->as<ColumnNode>();
+            auto * left_resolved_identifier_column = resolve_result.resolved_identifier->as<ColumnNode>();
+            auto * right_resolved_identifier_column = identifier.resolved_identifier->as<ColumnNode>();
 
             if (left_resolved_identifier_column && right_resolved_identifier_column)
             {
                 auto resolved_side = choseSideForEqualIdenfifiersFromJoin(*left_resolved_identifier_column, *right_resolved_identifier_column, identifier_path_part);
                 if (resolved_side == JoinTableSide::Right)
-                    resolved_identifier = identifier;
+                    resolve_result = identifier;
             }
         }
         else if (!prefer_left_table)
@@ -1094,7 +1100,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromCrossJoin(const Ide
         }
     }
 
-    return resolved_identifier;
+    return resolve_result;
 }
 
 /// Compare resolved identifiers considering columns that become nullable after JOIN
@@ -1112,13 +1118,13 @@ bool resolvedIdenfiersFromJoinAreEquals(
     return left_resolved_to_compare->isEqual(*right_resolved_to_compare, IQueryTreeNode::CompareOptions{.compare_aliases = false});
 }
 
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoin(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoin(const IdentifierLookup & identifier_lookup,
     const QueryTreeNodePtr & table_expression_node,
     IdentifierResolveScope & scope)
 {
     const auto & from_join_node = table_expression_node->as<const JoinNode &>();
-    auto left_resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_join_node.getLeftTableExpression(), scope);
-    auto right_resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_join_node.getRightTableExpression(), scope);
+    auto left_resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_join_node.getLeftTableExpression(), scope).resolved_identifier;
+    auto right_resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_join_node.getRightTableExpression(), scope).resolved_identifier;
 
     if (!identifier_lookup.isExpressionLookup())
     {
@@ -1129,7 +1135,10 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoin(const Identifi
                 identifier_lookup.dump(),
                 scope.scope_node->formatASTForErrorMessage());
 
-        return left_resolved_identifier ? left_resolved_identifier : right_resolved_identifier;
+        return {
+                .resolved_identifier = left_resolved_identifier ? left_resolved_identifier : right_resolved_identifier,
+                .resolve_place = IdentifierResolvePlace::JOIN_TREE
+            };
     }
 
     bool join_node_in_resolve_process = scope.table_expressions_in_resolve_process.contains(table_expression_node.get());
@@ -1212,7 +1221,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoin(const Identifi
     /// If columns from left or right table were missed Object(Nullable('json')) subcolumns, they will be replaced
     /// to ConstantNode(NULL), which can't be cast to ColumnNode, so we resolve it here.
     if (auto missed_subcolumn_identifier = checkIsMissedObjectJSONSubcolumn(left_resolved_identifier, right_resolved_identifier))
-        return missed_subcolumn_identifier;
+        return { .resolved_identifier = missed_subcolumn_identifier, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 
     if (left_resolved_identifier && right_resolved_identifier)
     {
@@ -1332,8 +1341,11 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoin(const Identifi
         }
     }
 
-    if (join_node_in_resolve_process || !resolved_identifier)
-        return resolved_identifier;
+    if (!resolved_identifier)
+        return {};
+
+    if (join_node_in_resolve_process)
+        return { .resolved_identifier = resolved_identifier, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 
     if (scope.join_use_nulls)
     {
@@ -1350,7 +1362,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoin(const Identifi
         }
     }
 
-    return resolved_identifier;
+    return { .resolved_identifier = resolved_identifier, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 }
 
 QueryTreeNodePtr IdentifierResolver::matchArrayJoinSubcolumns(
@@ -1492,15 +1504,15 @@ QueryTreeNodePtr IdentifierResolver::tryResolveExpressionFromArrayJoinExpression
     return array_join_resolved_expression;
 }
 
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromArrayJoin(const IdentifierLookup & identifier_lookup,
     const QueryTreeNodePtr & table_expression_node,
     IdentifierResolveScope & scope)
 {
     const auto & from_array_join_node = table_expression_node->as<const ArrayJoinNode &>();
-    auto resolved_identifier = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_array_join_node.getTableExpression(), scope);
+    auto resolve_result = tryResolveIdentifierFromJoinTreeNode(identifier_lookup, from_array_join_node.getTableExpression(), scope);
 
     if (scope.table_expressions_in_resolve_process.contains(table_expression_node.get()) || !identifier_lookup.isExpressionLookup())
-        return resolved_identifier;
+        return resolve_result;
 
     const auto & array_join_column_expressions = from_array_join_node.getJoinExpressions();
     const auto & array_join_column_expressions_nodes = array_join_column_expressions.getNodes();
@@ -1530,14 +1542,14 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const Ide
         auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),
             array_join_column_expression_typed.getColumnSource());
         if (identifier_view.empty())
-            return array_join_column;
+            return { .resolved_identifier = array_join_column, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 
-        if (resolved_identifier)
+        if (resolve_result.resolved_identifier)
         {
             auto resolved_nested_subcolumn = tryResolveExpressionFromArrayJoinNestedExpression(
-                    resolved_identifier, scope, array_join_column_expression_typed, array_join_column_expression_typed.getExpressionOrThrow());
+                    resolve_result.resolved_identifier, scope, array_join_column_expression_typed, array_join_column_expression_typed.getExpressionOrThrow());
             if (resolved_nested_subcolumn)
-                return resolved_nested_subcolumn;
+                return { .resolved_identifier = resolved_nested_subcolumn, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
         }
 
         /// Resolve subcolumns. Example : SELECT x.y.z FROM tab ARRAY JOIN arr AS x
@@ -1550,20 +1562,20 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromArrayJoin(const Ide
             true /* can_be_not_found */);
 
         if (compound_expr)
-            return compound_expr;
+            return { .resolved_identifier = compound_expr, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
     }
 
-    if (!resolved_identifier)
-        return nullptr;
+    if (!resolve_result.resolved_identifier)
+        return {};
 
-    auto array_join_resolved_expression = tryResolveExpressionFromArrayJoinExpressions(resolved_identifier, table_expression_node, scope);
+    auto array_join_resolved_expression = tryResolveExpressionFromArrayJoinExpressions(resolve_result.resolved_identifier, table_expression_node, scope);
     if (array_join_resolved_expression)
-        resolved_identifier = std::move(array_join_resolved_expression);
+        resolve_result = { .resolved_identifier = std::move(array_join_resolved_expression), .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 
-    return resolved_identifier;
+    return resolve_result;
 }
 
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoinTreeNode(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoinTreeNode(const IdentifierLookup & identifier_lookup,
     const QueryTreeNodePtr & join_tree_node,
     IdentifierResolveScope & scope)
 {
@@ -1616,7 +1628,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoinTreeNode(const
   * Start with identifier first part, if it match some column name in table try to get column with full identifier name.
   * TODO: Need to check if it is okay to throw exception if compound identifier first part bind to column but column is not valid.
   */
-QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoinTree(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult IdentifierResolver::tryResolveIdentifierFromJoinTree(const IdentifierLookup & identifier_lookup,
     IdentifierResolveScope & scope)
 {
     if (identifier_lookup.isFunctionLookup())
@@ -1624,7 +1636,7 @@ QueryTreeNodePtr IdentifierResolver::tryResolveIdentifierFromJoinTree(const Iden
 
     /// Try to resolve identifier from table columns
     if (auto resolved_identifier = tryResolveIdentifierFromTableColumns(identifier_lookup, scope))
-        return resolved_identifier;
+        return { .resolved_identifier = resolved_identifier, .resolve_place = IdentifierResolvePlace::JOIN_TREE };
 
     if (scope.expression_join_tree_node)
         return tryResolveIdentifierFromJoinTreeNode(identifier_lookup, scope.expression_join_tree_node, scope);
diff --git a/src/Analyzer/Resolve/IdentifierResolver.h b/src/Analyzer/Resolve/IdentifierResolver.h
index 3993b9c20966..9bf6dc206380 100644
--- a/src/Analyzer/Resolve/IdentifierResolver.h
+++ b/src/Analyzer/Resolve/IdentifierResolver.h
@@ -32,11 +32,8 @@ class IdentifierResolver
 {
 public:
 
-    IdentifierResolver(
-        std::unordered_set<std::string_view> & ctes_in_resolve_process_,
-        std::unordered_map<QueryTreeNodePtr, ProjectionName> & node_to_projection_name_)
-        : ctes_in_resolve_process(ctes_in_resolve_process_)
-        , node_to_projection_name(node_to_projection_name_)
+    explicit IdentifierResolver(std::unordered_map<QueryTreeNodePtr, ProjectionName> & node_to_projection_name_)
+        : node_to_projection_name(node_to_projection_name_)
     {}
 
     /// Utility functions
@@ -87,7 +84,7 @@ class IdentifierResolver
 
     /// Resolve identifier functions
 
-    static std::shared_ptr<TableNode> tryResolveTableIdentifierFromDatabaseCatalog(const Identifier & table_identifier, ContextPtr context);
+    static IdentifierResolveResult tryResolveTableIdentifierFromDatabaseCatalog(const Identifier & table_identifier, const ContextPtr & context);
 
     QueryTreeNodePtr tryResolveIdentifierFromCompoundExpression(const Identifier & expression_identifier,
         size_t identifier_bind_size,
@@ -96,7 +93,7 @@ class IdentifierResolver
         IdentifierResolveScope & scope,
         bool can_be_not_found = false);
 
-    QueryTreeNodePtr tryResolveIdentifierFromExpressionArguments(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope);
+    IdentifierResolveResult tryResolveIdentifierFromExpressionArguments(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope);
 
     static bool tryBindIdentifierToAliases(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope);
 
@@ -113,15 +110,18 @@ class IdentifierResolver
     static bool tryBindIdentifierToArrayJoinExpressions(const IdentifierLookup & identifier_lookup,
         const IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromTableExpression(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromTableExpression(
+        const IdentifierLookup & identifier_lookup,
         const QueryTreeNodePtr & table_expression_node,
         IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromCrossJoin(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromCrossJoin(
+        const IdentifierLookup & identifier_lookup,
         const QueryTreeNodePtr & table_expression_node,
         IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromJoin(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromJoin(
+        const IdentifierLookup & identifier_lookup,
         const QueryTreeNodePtr & table_expression_node,
         IdentifierResolveScope & scope);
 
@@ -142,18 +142,18 @@ class IdentifierResolver
         const QueryTreeNodePtr & table_expression_node,
         IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromArrayJoin(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromArrayJoin(const IdentifierLookup & identifier_lookup,
         const QueryTreeNodePtr & table_expression_node,
         IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromJoinTreeNode(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromJoinTreeNode(const IdentifierLookup & identifier_lookup,
         const QueryTreeNodePtr & join_tree_node,
         IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromJoinTree(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromJoinTree(const IdentifierLookup & identifier_lookup,
         IdentifierResolveScope & scope);
 
-    QueryTreeNodePtr tryResolveIdentifierFromStorage(
+    IdentifierResolveResult tryResolveIdentifierFromStorage(
         const Identifier & identifier,
         const QueryTreeNodePtr & table_expression_node,
         const AnalysisTableExpressionData & table_expression_data,
@@ -161,12 +161,8 @@ class IdentifierResolver
         size_t identifier_column_qualifier_parts,
         bool can_be_not_found = false);
 
-    /// CTEs that are currently in resolve process
-    std::unordered_set<std::string_view> & ctes_in_resolve_process;
-
     /// Global expression node to projection name map
     std::unordered_map<QueryTreeNodePtr, ProjectionName> & node_to_projection_name;
-
 };
 
 }
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp
index 564b3db6d5eb..b4586e2132e9 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp
+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp
@@ -120,7 +120,6 @@ namespace ErrorCodes
     extern const int UNKNOWN_IDENTIFIER;
     extern const int UNKNOWN_FUNCTION;
     extern const int LOGICAL_ERROR;
-    extern const int CYCLIC_ALIASES;
     extern const int INCORRECT_RESULT_OF_SCALAR_SUBQUERY;
     extern const int BAD_ARGUMENTS;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
@@ -150,7 +149,7 @@ namespace ErrorCodes
 }
 
 QueryAnalyzer::QueryAnalyzer(bool only_analyze_)
-    : identifier_resolver(ctes_in_resolve_process, node_to_projection_name)
+    : identifier_resolver(node_to_projection_name)
     , only_analyze(only_analyze_)
 {}
 
@@ -1120,18 +1119,16 @@ std::string QueryAnalyzer::rewriteAggregateFunctionNameIfNeeded(
 /** Resolve identifier from scope aliases.
   *
   * Resolve strategy:
-  * 1. If alias is registered in current expressions that are in resolve process and if top expression is not part of bottom expression with the same alias subtree
-  * throw cyclic aliases exception.
-  * Otherwise prevent cache usage for identifier lookup and return nullptr.
+  * 1. Try to find identifier first part in the corresponding alias table.
+  * 2. If alias is registered in current expressions that are in resolve process and if top expression is not part of bottom expression with the same alias subtree
+  * it may be cyclic aliases.
+  * In that case return nullptr and allow to continue identifier resolution in other places.
+  * TODO: If following identifier resolution fails throw an CYCLIC_ALIASES exception.
   *
   * This is special scenario where identifier has name the same as alias name in one of its parent expressions including itself.
   * In such case we cannot resolve identifier from aliases because of recursion. It is client responsibility to register and deregister alias
   * names during expressions resolve.
   *
-  * We must prevent cache usage for lookup because lookup outside of expression is supposed to return other value.
-  * Example: SELECT (id + 1) AS id, id + 2. Lookup for id inside (id + 1) as id should return id from table, but lookup (id + 2) should return
-  * (id + 1) AS id.
-  *
   * Below cases should work:
   * Example:
   * SELECT id AS id FROM test_table;
@@ -1143,9 +1140,9 @@ std::string QueryAnalyzer::rewriteAggregateFunctionNameIfNeeded(
   * SELECT (id + b) AS id, id as b FROM test_table;
   * SELECT (1 + b + 1 + id) AS id, b as c, id as b FROM test_table;
   *
-  * 2. Depending on IdentifierLookupContext get alias name to node map from IdentifierResolveScope.
-  * 3. Try to bind identifier to alias name in map. If there are no such binding return nullptr.
-  * 4. If node in map is not resolved, resolve it. It is important in case of compound expressions.
+  * 3. Depending on IdentifierLookupContext select IdentifierResolveScope to resolve aliased expression.
+  * 4. Clone query tree of aliased expression (do not clone table expression from join tree).
+  * 5. Resolve the node. It is important in case of compound expressions.
   * Example: SELECT value.a, cast('(1)', 'Tuple(a UInt64)') AS value;
   *
   * Special case if node is identifier node.
@@ -1156,11 +1153,12 @@ std::string QueryAnalyzer::rewriteAggregateFunctionNameIfNeeded(
   * If identifier is resolved, depending on lookup context, erase entry from expression or lambda map. Check QueryExpressionsAliasVisitor documentation.
   * Pop node from current scope expressions in resolve process stack.
   *
-  * 5. If identifier is compound and identifier lookup is in expression context, use `tryResolveIdentifierFromCompoundExpression`.
+  * 6. Save aliased expression result type for typo correction.
+  * 7. If identifier is compound and identifier lookup is in expression context, use `tryResolveIdentifierFromCompoundExpression`.
   */
-QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const IdentifierLookup & identifier_lookup,
+IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierFromAliases(const IdentifierLookup & identifier_lookup,
     IdentifierResolveScope & scope,
-    IdentifierResolveSettings identifier_resolve_settings)
+    IdentifierResolveContext identifier_resolve_context)
 {
     const auto & identifier_bind_part = identifier_lookup.identifier.front();
 
@@ -1168,7 +1166,13 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier
     if (it == nullptr)
         return {};
 
-    QueryTreeNodePtr & alias_node = *it;
+    auto * scope_to_resolve_alias_expression = &scope;
+    if (identifier_resolve_context.scope_to_resolve_alias_expression)
+    {
+        scope_to_resolve_alias_expression = identifier_resolve_context.scope_to_resolve_alias_expression;
+    }
+
+    QueryTreeNodePtr alias_node = *it;
 
     if (!alias_node)
         throw Exception(ErrorCodes::LOGICAL_ERROR,
@@ -1176,72 +1180,87 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier
             identifier_bind_part,
             scope.scope_node->formatASTForErrorMessage());
 
-    if (auto root_expression_with_alias = scope.expressions_in_resolve_process_stack.getExpressionWithAlias(identifier_bind_part))
+    auto node_type = alias_node->getNodeType();
+    if (!identifier_lookup.isTableExpressionLookup())
     {
-        const auto top_expression = scope.expressions_in_resolve_process_stack.getTop();
-
-        if (!isNodePartOfTree(top_expression.get(), root_expression_with_alias.get()))
-            throw Exception(ErrorCodes::CYCLIC_ALIASES,
-                "Cyclic aliases for identifier '{}'. In scope {}",
-                identifier_lookup.identifier.getFullName(),
-                scope.scope_node->formatASTForErrorMessage());
+        alias_node = alias_node->clone();
+        scope_to_resolve_alias_expression->aliases.node_to_remove_aliases.push_back(alias_node);
+    }
 
-        scope.non_cached_identifier_lookups_during_expression_resolve.insert(identifier_lookup);
+    /* Do not use alias to resolve identifier when it's part of aliased expression. This is required to support queries like:
+     * 1. SELECT dummy + 1 AS dummy
+     * 2. SELECT avg(a) OVER () AS a, id FROM test
+     */
+    if (scope.expressions_in_resolve_process_stack.getExpressionWithAlias(identifier_bind_part) != nullptr)
+    {
+        /* This is an important fallback in the identifier resolution. In the case of transitive aliases,
+         * we may end up in the situation when we try to resolve the same expression, but it's not a cycle.
+         * Example: WITH path('clickhouse.com/a/b/c') AS x SELECT x AS path;
+         * Here, identifier `x` would be resolved one time as a projection column and one time during `path`
+         * function lookup. The second lookup must fail here to break the alias cycle.
+         */
         return {};
     }
 
-    auto node_type = alias_node->getNodeType();
-
     /// Resolve expression if necessary
     if (node_type == QueryTreeNodeType::IDENTIFIER)
     {
-        scope.pushExpressionNode(alias_node);
+        scope_to_resolve_alias_expression->pushExpressionNode(alias_node);
 
         auto & alias_identifier_node = alias_node->as<IdentifierNode &>();
         auto identifier = alias_identifier_node.getIdentifier();
-        auto lookup_result = tryResolveIdentifier(IdentifierLookup{identifier, identifier_lookup.lookup_context}, scope, identifier_resolve_settings);
+        auto lookup_result = tryResolveIdentifier(IdentifierLookup{identifier, identifier_lookup.lookup_context}, *scope_to_resolve_alias_expression, identifier_resolve_context);
+
+        scope_to_resolve_alias_expression->popExpressionNode();
+
         if (!lookup_result.resolved_identifier)
         {
-            std::unordered_set<Identifier> valid_identifiers;
-            IdentifierResolver::collectScopeWithParentScopesValidIdentifiersForTypoCorrection(identifier, scope, true, false, false, valid_identifiers);
-            auto hints = IdentifierResolver::collectIdentifierTypoHints(identifier, valid_identifiers);
-
-            throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER, "Unknown {} identifier '{}'. In scope {}{}",
-                toStringLowercase(identifier_lookup.lookup_context),
-                identifier.getFullName(),
-                scope.scope_node->formatASTForErrorMessage(),
-                getHintsErrorMessageSuffix(hints));
+            // Resolve may succeed in another place or scope
+            return {};
         }
 
         alias_node = lookup_result.resolved_identifier;
-        scope.popExpressionNode();
     }
     else if (node_type == QueryTreeNodeType::FUNCTION)
     {
-        resolveExpressionNode(alias_node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);
+        resolveExpressionNode(alias_node, *scope_to_resolve_alias_expression, false /*allow_lambda_expression*/, false /*allow_table_expression*/);
     }
     else if (node_type == QueryTreeNodeType::QUERY || node_type == QueryTreeNodeType::UNION)
     {
-        if (identifier_resolve_settings.allow_to_resolve_subquery_during_identifier_resolution)
-            resolveExpressionNode(alias_node, scope, false /*allow_lambda_expression*/, identifier_lookup.isTableExpressionLookup() /*allow_table_expression*/);
+        if (identifier_resolve_context.allow_to_resolve_subquery_during_identifier_resolution)
+            resolveExpressionNode(alias_node, *scope_to_resolve_alias_expression, false /*allow_lambda_expression*/, identifier_lookup.isTableExpressionLookup() /*allow_table_expression*/);
+    }
+
+    if (identifier_lookup.isExpressionLookup() && alias_node)
+    {
+        // Do not collect result rype in case of untuple() expression
+        if (alias_node->getNodeType() != QueryTreeNodeType::LIST)
+        {
+            // Remember resolved type for typo correction
+            scope_to_resolve_alias_expression->aliases.alias_name_to_expression_type[identifier_bind_part] = alias_node->getResultType();
+        }
     }
 
     if (identifier_lookup.identifier.isCompound() && alias_node)
     {
         if (identifier_lookup.isExpressionLookup())
         {
-            return identifier_resolver.tryResolveIdentifierFromCompoundExpression(
+            if (auto resolved_identifier = identifier_resolver.tryResolveIdentifierFromCompoundExpression(
                 identifier_lookup.identifier,
                 1 /*identifier_bind_size*/,
                 alias_node,
                 {} /* compound_expression_source */,
                 scope,
-                identifier_resolve_settings.allow_to_check_join_tree /* can_be_not_found */);
+                identifier_resolve_context.allow_to_check_join_tree /* can_be_not_found */))
+            {
+                return { .resolved_identifier = resolved_identifier, .resolve_place = IdentifierResolvePlace::ALIASES };
+            }
+            return {};
         }
         if (identifier_lookup.isFunctionLookup() || identifier_lookup.isTableExpressionLookup())
         {
             throw Exception(
-                ErrorCodes::BAD_ARGUMENTS,
+                ErrorCodes::UNKNOWN_IDENTIFIER,
                 "Compound identifier '{}' cannot be resolved as {}. In scope {}",
                 identifier_lookup.identifier.getFullName(),
                 identifier_lookup.isFunctionLookup() ? "function" : "table expression",
@@ -1249,102 +1268,118 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier
         }
     }
 
-    return alias_node;
+    return { .resolved_identifier = alias_node, .resolve_place = IdentifierResolvePlace::ALIASES };
 }
 
-/** Try resolve identifier in current scope parent scopes.
-  *
-  * TODO: If column is matched, throw exception that nested subqueries are not supported.
+/** Try to resolve identifier recursively in parent scopes.
   *
-  * If initial scope is expression. Then try to resolve identifier in parent scopes until query scope is hit.
-  * For query scope resolve strategy is same as if initial scope if query.
+  * If identifier is resolved to expression it must be resolved in the context of the current scope.
   */
-IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierInParentScopes(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope)
+IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierInParentScopes(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope, IdentifierResolveContext identifier_resolve_context)
 {
-    bool initial_scope_is_query = scope.scope_node->getNodeType() == QueryTreeNodeType::QUERY;
-    bool initial_scope_is_expression = !initial_scope_is_query;
+    if (!scope.parent_scope)
+        return {};
 
-    IdentifierResolveSettings identifier_resolve_settings;
-    identifier_resolve_settings.allow_to_check_parent_scopes = false;
-    identifier_resolve_settings.allow_to_check_database_catalog = false;
+    bool initial_scope_is_query = scope.scope_node->getNodeType() == QueryTreeNodeType::QUERY;
 
-    IdentifierResolveScope * scope_to_check = scope.parent_scope;
+    identifier_resolve_context.resolveAliasesAt(&scope);
 
-    if (initial_scope_is_expression)
+    /** 1. Nested subqueries cannot access outer subqueries table expressions from JOIN tree because
+      * that can prevent resolution of table expression from CTE.
+      *
+      * Example: WITH a AS (SELECT number FROM numbers(1)), b AS (SELECT number FROM a) SELECT * FROM a as l, b as r;
+      *
+      * 2. Allow to check join tree and aliases when resolving lambda body.
+      *
+      * Example: SELECT arrayMap(x -> test_table.* EXCEPT value, [1,2,3]) FROM test_table;
+      */
+    if (initial_scope_is_query)
     {
-        while (scope_to_check != nullptr)
+        if (identifier_lookup.isTableExpressionLookup())
         {
-            auto resolve_result = tryResolveIdentifier(identifier_lookup, *scope_to_check, identifier_resolve_settings);
-            if (resolve_result.resolved_identifier)
-                return resolve_result;
+            identifier_resolve_context.allow_to_check_join_tree = false;
 
-            bool scope_was_query = scope_to_check->scope_node->getNodeType() == QueryTreeNodeType::QUERY;
-            scope_to_check = scope_to_check->parent_scope;
+            /** From parent scopes we can resolve table identifiers only as CTE.
+                * Example: SELECT (SELECT 1 FROM a) FROM test_table AS a;
+                *
+                * During child scope table identifier resolve a, table node test_table with alias a from parent scope
+                * is invalid.
+                */
+            identifier_resolve_context.allow_to_check_aliases = false;
+        }
 
-            if (scope_was_query)
-                break;
+        if (!scope.context->getSettingsRef()[Setting::enable_global_with_statement])
+        {
+            identifier_resolve_context.allow_to_check_aliases = false;
+            identifier_resolve_context.allow_to_check_cte = false;
         }
     }
 
-    if (!scope.context->getSettingsRef()[Setting::enable_global_with_statement])
+    identifier_resolve_context.allow_to_check_database_catalog = false;
+
+    auto resolve_result = tryResolveIdentifier(identifier_lookup, *scope.parent_scope, identifier_resolve_context);
+    auto & resolved_identifier = resolve_result.resolved_identifier;
+
+    if (!resolved_identifier)
         return {};
 
-    /** Nested subqueries cannot access outer subqueries table expressions from JOIN tree because
-      * that can prevent resolution of table expression from CTE.
-      *
-      * Example: WITH a AS (SELECT number FROM numbers(1)), b AS (SELECT number FROM a) SELECT * FROM a as l, b as r;
-      */
+    /** From parent scopes we can resolve table identifiers only as CTE (except the case when initial scope is not query).
+        * Example: SELECT (SELECT 1 FROM a) FROM test_table AS a;
+        *
+        * During table identifier resolution `a` in (SELECT 1 FROM a) scope, table node test_table with alias a from parent scope
+        * is invalid.
+        * Table identifier can be resolved from aliases or join tree in the parent scope
+        * inside of lambda body expression. Example:
+        *
+        * SELECT map(x > x in a, [1, 2]) FROM numbers(3) as a;
+        */
     if (identifier_lookup.isTableExpressionLookup())
-        identifier_resolve_settings.allow_to_check_join_tree = false;
-
-    while (scope_to_check != nullptr)
     {
-        auto lookup_result = tryResolveIdentifier(identifier_lookup, *scope_to_check, identifier_resolve_settings);
-        const auto & resolved_identifier = lookup_result.resolved_identifier;
-
-        scope_to_check = scope_to_check->parent_scope;
+        auto * subquery_node = resolved_identifier->as<QueryNode>();
+        auto * union_node = resolved_identifier->as<UnionNode>();
 
-        if (resolved_identifier)
-        {
-            auto * subquery_node = resolved_identifier->as<QueryNode>();
-            auto * union_node = resolved_identifier->as<UnionNode>();
-
-            bool is_cte = (subquery_node && subquery_node->isCTE()) || (union_node && union_node->isCTE());
-            bool is_table_from_expression_arguments = lookup_result.resolve_place == IdentifierResolvePlace::EXPRESSION_ARGUMENTS &&
-                resolved_identifier->getNodeType() == QueryTreeNodeType::TABLE;
-            bool is_valid_table_expression = is_cte || is_table_from_expression_arguments;
+        /// Resolved to CTE in parent scope.
+        bool is_cte = (subquery_node && subquery_node->isCTE()) || (union_node && union_node->isCTE());
+        /// Resolved to lambda argument.
+        bool is_table_from_expression_arguments = resolve_result.isResolvedFromExpressionArguments() &&
+            resolved_identifier->getNodeType() == QueryTreeNodeType::TABLE;
+        /// Resolved from alias or join tree in the parent scope when initial scope is not query.
+        bool is_from_join_tree_or_aliases = !initial_scope_is_query && (resolve_result.isResolvedFromJoinTree() || resolve_result.isResolvedFromAliases());
+        bool is_valid_table_expression = is_cte || is_table_from_expression_arguments || is_from_join_tree_or_aliases;
 
-            /** From parent scopes we can resolve table identifiers only as CTE.
-              * Example: SELECT (SELECT 1 FROM a) FROM test_table AS a;
-              *
-              * During child scope table identifier resolve a, table node test_table with alias a from parent scope
-              * is invalid.
-              */
-            if (identifier_lookup.isTableExpressionLookup() && !is_valid_table_expression)
-                continue;
+        if (!is_valid_table_expression)
+            return {};
+        return resolve_result;
+    }
+    if (identifier_lookup.isFunctionLookup())
+        return resolve_result;
 
-            if (is_valid_table_expression || resolved_identifier->as<ConstantNode>())
-            {
-                return lookup_result;
-            }
-            if (auto * resolved_function = resolved_identifier->as<FunctionNode>())
+    QueryTreeNodes nodes_to_process = { resolved_identifier };
+    while (!nodes_to_process.empty())
+    {
+        auto current = nodes_to_process.back();
+        nodes_to_process.pop_back();
+        if (auto * current_column = current->as<ColumnNode>())
+        {
+            if (isDependentColumn(&scope, current_column->getColumnSource()))
             {
-                /// Special case: scalar subquery was executed and replaced by __getScalar function.
-                /// Handle it as a constant.
-                if (resolved_function->getFunctionName() == "__getScalar")
-                    return lookup_result;
+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
+                    "Resolved identifier '{}' in parent scope to expression '{}' with correlated column '{}'. In scope {}",
+                    identifier_lookup.identifier.getFullName(),
+                    resolved_identifier->formatASTForErrorMessage(),
+                    current_column->getColumnName(),
+                    scope.scope_node->formatASTForErrorMessage());
             }
+        }
 
-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
-                "Resolve identifier '{}' from parent scope only supported for constants and CTE. Actual {} node type {}. In scope {}",
-                identifier_lookup.identifier.getFullName(),
-                resolved_identifier->formatASTForErrorMessage(),
-                resolved_identifier->getNodeTypeName(),
-                scope.scope_node->formatASTForErrorMessage());
+        for (const auto & child : current->getChildren())
+        {
+            if (child)
+                nodes_to_process.push_back(child);
         }
     }
 
-    return {};
+    return resolve_result;
 }
 
 /** Resolve identifier in scope.
@@ -1383,38 +1418,26 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifierInParentScopes(const
   */
 IdentifierResolveResult QueryAnalyzer::tryResolveIdentifier(const IdentifierLookup & identifier_lookup,
     IdentifierResolveScope & scope,
-    IdentifierResolveSettings identifier_resolve_settings)
+    IdentifierResolveContext identifier_resolve_settings)
 {
-    auto it = scope.identifier_lookup_to_resolve_state.find(identifier_lookup);
-    if (it != scope.identifier_lookup_to_resolve_state.end())
-    {
-        if (it->second.cyclic_identifier_resolve)
-            throw Exception(ErrorCodes::CYCLIC_ALIASES,
-                "Cyclic aliases for identifier '{}'. In scope {}",
-                identifier_lookup.identifier.getFullName(),
-                scope.scope_node->formatASTForErrorMessage());
-
-        if (!it->second.resolve_result.isResolved())
-            it->second.cyclic_identifier_resolve = true;
+    auto it = scope.identifier_in_lookup_process.find(identifier_lookup);
 
-        if (it->second.resolve_result.isResolved() &&
-            scope.use_identifier_lookup_to_result_cache &&
-            !scope.non_cached_identifier_lookups_during_expression_resolve.contains(identifier_lookup) &&
-            (!it->second.resolve_result.isResolvedFromCTEs() || !ctes_in_resolve_process.contains(identifier_lookup.identifier.getFullName())))
-            return it->second.resolve_result;
+    bool already_in_resolve_process = false;
+    if (it != scope.identifier_in_lookup_process.end())
+    {
+        it->second.count++;
+        already_in_resolve_process = true;
     }
     else
     {
-        auto [insert_it, _] = scope.identifier_lookup_to_resolve_state.insert({identifier_lookup, IdentifierResolveState()});
+        auto [insert_it, _] = scope.identifier_in_lookup_process.insert({identifier_lookup, IdentifierResolveState()});
         it = insert_it;
     }
 
     /// Resolve identifier from current scope
 
     IdentifierResolveResult resolve_result;
-    resolve_result.resolved_identifier = identifier_resolver.tryResolveIdentifierFromExpressionArguments(identifier_lookup, scope);
-    if (resolve_result.resolved_identifier)
-        resolve_result.resolve_place = IdentifierResolvePlace::EXPRESSION_ARGUMENTS;
+    resolve_result = identifier_resolver.tryResolveIdentifierFromExpressionArguments(identifier_lookup, scope);
 
     if (!resolve_result.resolved_identifier)
     {
@@ -1440,34 +1463,22 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifier(const IdentifierLook
         {
             if (identifier_resolve_settings.allow_to_check_join_tree)
             {
-                resolve_result.resolved_identifier = identifier_resolver.tryResolveIdentifierFromJoinTree(identifier_lookup, scope);
-
-                if (resolve_result.resolved_identifier)
-                    resolve_result.resolve_place = IdentifierResolvePlace::JOIN_TREE;
+                resolve_result = identifier_resolver.tryResolveIdentifierFromJoinTree(identifier_lookup, scope);
             }
 
-            if (!resolve_result.resolved_identifier)
+            if (identifier_resolve_settings.allow_to_check_aliases && !resolve_result.resolved_identifier && !already_in_resolve_process)
             {
-                resolve_result.resolved_identifier = tryResolveIdentifierFromAliases(identifier_lookup, scope, identifier_resolve_settings);
-
-                if (resolve_result.resolved_identifier)
-                    resolve_result.resolve_place = IdentifierResolvePlace::ALIASES;
+                resolve_result = tryResolveIdentifierFromAliases(identifier_lookup, scope, identifier_resolve_settings);
             }
         }
         else
         {
-            resolve_result.resolved_identifier = tryResolveIdentifierFromAliases(identifier_lookup, scope, identifier_resolve_settings);
+            if (identifier_resolve_settings.allow_to_check_aliases && !already_in_resolve_process)
+                resolve_result = tryResolveIdentifierFromAliases(identifier_lookup, scope, identifier_resolve_settings);
 
-            if (resolve_result.resolved_identifier)
-            {
-                resolve_result.resolve_place = IdentifierResolvePlace::ALIASES;
-            }
-            else if (identifier_resolve_settings.allow_to_check_join_tree)
+            if (!resolve_result.resolved_identifier && identifier_resolve_settings.allow_to_check_join_tree)
             {
-                resolve_result.resolved_identifier = identifier_resolver.tryResolveIdentifierFromJoinTree(identifier_lookup, scope);
-
-                if (resolve_result.resolved_identifier)
-                    resolve_result.resolve_place = IdentifierResolvePlace::JOIN_TREE;
+                resolve_result = identifier_resolver.tryResolveIdentifierFromJoinTree(identifier_lookup, scope);
             }
         }
 
@@ -1487,7 +1498,7 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifier(const IdentifierLook
         }
     }
 
-    if (!resolve_result.resolved_identifier && identifier_lookup.isTableExpressionLookup())
+    if (!resolve_result.resolved_identifier && identifier_resolve_settings.allow_to_check_cte && identifier_lookup.isTableExpressionLookup())
     {
         auto full_name = identifier_lookup.identifier.getFullName();
         auto cte_query_node_it = scope.cte_name_to_query_node.find(full_name);
@@ -1505,45 +1516,29 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifier(const IdentifierLook
         /// To accomplish this behaviour it's not allowed to resolve identifiers to
         /// CTE that is being resolved.
         if (cte_query_node_it != scope.cte_name_to_query_node.end()
-            && !ctes_in_resolve_process.contains(full_name))
+            && !ctes_in_resolve_process.contains(cte_query_node_it->second))
         {
-            resolve_result.resolved_identifier = cte_query_node_it->second;
-            resolve_result.resolve_place = IdentifierResolvePlace::CTE;
+            resolve_result = { .resolved_identifier = cte_query_node_it->second, .resolve_place = IdentifierResolvePlace::CTE };
         }
     }
 
     /// Try to resolve identifier from parent scopes
-
-    if (!resolve_result.resolved_identifier && identifier_resolve_settings.allow_to_check_parent_scopes)
+    if (!resolve_result.resolved_identifier)
     {
-        resolve_result = tryResolveIdentifierInParentScopes(identifier_lookup, scope);
-
-        if (resolve_result.resolved_identifier)
-            resolve_result.resolved_from_parent_scopes = true;
+        resolve_result = tryResolveIdentifierInParentScopes(identifier_lookup, scope, identifier_resolve_settings);
     }
 
     /// Try to resolve table identifier from database catalog
-
     if (!resolve_result.resolved_identifier && identifier_resolve_settings.allow_to_check_database_catalog && identifier_lookup.isTableExpressionLookup())
     {
-        resolve_result.resolved_identifier = IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(identifier_lookup.identifier, scope.context);
-
-        if (resolve_result.resolved_identifier)
-            resolve_result.resolve_place = IdentifierResolvePlace::DATABASE_CATALOG;
+        resolve_result = IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(identifier_lookup.identifier, scope.context);
     }
 
-    bool was_cyclic_identifier_resolve = it->second.cyclic_identifier_resolve;
-    if (!was_cyclic_identifier_resolve)
-        it->second.resolve_result = resolve_result;
-    it->second.cyclic_identifier_resolve = false;
-
-    /** If identifier was not resolved, or during expression resolution identifier was explicitly added into non cached set,
-      * or identifier caching was disabled in resolve scope we remove identifier lookup result from identifier lookup to result table.
-      */
-    if (!was_cyclic_identifier_resolve && (!resolve_result.resolved_identifier ||
-        scope.non_cached_identifier_lookups_during_expression_resolve.contains(identifier_lookup) ||
-        !scope.use_identifier_lookup_to_result_cache))
-        scope.identifier_lookup_to_resolve_state.erase(it);
+    it->second.count--;
+    if (it->second.count == 0)
+    {
+        scope.identifier_in_lookup_process.erase(it);
+    }
 
     return resolve_result;
 }
@@ -1646,7 +1641,7 @@ GetColumnsOptions QueryAnalyzer::buildGetColumnsOptions(QueryTreeNodePtr & match
 QueryAnalyzer::QueryTreeNodesWithNames QueryAnalyzer::getMatchedColumnNodesWithNames(const QueryTreeNodePtr & matcher_node,
     const QueryTreeNodePtr & table_expression_node,
     const NamesAndTypes & matched_columns,
-    const IdentifierResolveScope & scope)
+    IdentifierResolveScope & scope)
 {
     auto & matcher_node_typed = matcher_node->as<MatcherNode &>();
 
@@ -1858,7 +1853,7 @@ QueryAnalyzer::QueryTreeNodesWithNames QueryAnalyzer::resolveQualifiedMatcher(Qu
 
     /// Try to resolve qualified matcher for table expression
 
-    IdentifierResolveSettings identifier_resolve_settings;
+    IdentifierResolveContext identifier_resolve_settings;
     identifier_resolve_settings.allow_to_check_cte = false;
     identifier_resolve_settings.allow_to_check_database_catalog = false;
 
@@ -2599,13 +2594,13 @@ ProjectionNames QueryAnalyzer::resolveLambda(const QueryTreeNodePtr & lambda_nod
     /** Register lambda as being resolved, to prevent recursive lambdas resolution.
       * Example: WITH (x -> x + lambda_2(x)) AS lambda_1, (x -> x + lambda_1(x)) AS lambda_2 SELECT 1;
       */
-    auto it = lambdas_in_resolve_process.find(lambda_node.get());
+    auto it = lambdas_in_resolve_process.find(lambda_node);
     if (it != lambdas_in_resolve_process.end())
         throw Exception(ErrorCodes::UNSUPPORTED_METHOD,
             "Recursive lambda {}. In scope {}",
             lambda_node->formatASTForErrorMessage(),
             scope.scope_node->formatASTForErrorMessage());
-    lambdas_in_resolve_process.emplace(lambda_node.get());
+    lambdas_in_resolve_process.emplace(lambda_node);
 
     size_t arguments_size = lambda_arguments.size();
     if (lambda_arguments_nodes_size != arguments_size)
@@ -2637,7 +2632,7 @@ ProjectionNames QueryAnalyzer::resolveLambda(const QueryTreeNodePtr & lambda_nod
         const auto & lambda_argument_name = lambda_argument_identifier ? lambda_argument_identifier->getIdentifier().getFullName()
                                                                        : lambda_argument_column->getColumnName();
 
-        bool has_expression_node = scope.aliases.alias_name_to_expression_node->contains(lambda_argument_name);
+        bool has_expression_node = scope.aliases.alias_name_to_expression_node.contains(lambda_argument_name);
         bool has_alias_node = scope.aliases.alias_name_to_lambda_node.contains(lambda_argument_name);
 
         if (has_expression_node || has_alias_node)
@@ -2658,7 +2653,7 @@ ProjectionNames QueryAnalyzer::resolveLambda(const QueryTreeNodePtr & lambda_nod
     /// Lambda body expression is resolved as standard query expression node.
     auto result_projection_names = resolveExpressionNode(lambda_to_resolve.getExpression(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);
 
-    lambdas_in_resolve_process.erase(lambda_node.get());
+    lambdas_in_resolve_process.erase(lambda_node);
 
     return result_projection_names;
 }
@@ -2811,7 +2806,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
             }
             else
             {
-                auto table_node = IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(identifier, scope.context);
+                auto table_node = IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(identifier, scope.context).resolved_identifier;
                 if (!table_node)
                     throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                         "Function {} first argument expected table identifier '{}'. In scope {}",
@@ -3412,6 +3407,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
             QueryTreeNodes lambda_arguments;
             lambda_arguments.reserve(lambda_arguments_size);
 
+            IdentifierResolveScope lambda_scope(lambda_to_resolve, &scope /*parent_scope*/);
             for (size_t i = 0; i < lambda_arguments_size; ++i)
             {
                 const auto & argument_type = function_data_type_argument_types[i];
@@ -3419,7 +3415,6 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
                 lambda_arguments.push_back(std::make_shared<ColumnNode>(std::move(column_name_and_type), lambda_to_resolve));
             }
 
-            IdentifierResolveScope lambda_scope(lambda_to_resolve, &scope /*parent_scope*/);
             lambda_projection_names = resolveLambda(lambda_argument, lambda_to_resolve, lambda_arguments, lambda_scope);
 
             if (auto * lambda_list_node_result = lambda_to_resolve_typed.getExpression()->as<ListNode>())
@@ -3621,7 +3616,11 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi
   * 4. If node has alias, update its value in scope alias map. Deregister alias from expression_aliases_in_resolve_process.
   */
 ProjectionNames QueryAnalyzer::resolveExpressionNode(
-    QueryTreeNodePtr & node, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression, bool ignore_alias)
+    QueryTreeNodePtr & node,
+    IdentifierResolveScope & scope,
+    bool allow_lambda_expression,
+    bool allow_table_expression,
+    bool ignore_alias)
 {
     checkStackSize();
 
@@ -3656,42 +3655,11 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
     else
     {
         result_projection_names.push_back(node_alias);
-    }
-
-    bool is_duplicated_alias = scope.aliases.nodes_with_duplicated_aliases.contains(node);
-    if (is_duplicated_alias)
-        scope.non_cached_identifier_lookups_during_expression_resolve.insert({Identifier{node_alias}, IdentifierLookupContext::EXPRESSION});
-
-    /** Do not use alias table if node has alias same as some other node.
-      * Example: WITH x -> x + 1 AS lambda SELECT 1 AS lambda;
-      * During 1 AS lambda resolve if we use alias table we replace node with x -> x + 1 AS lambda.
-      *
-      * Do not use alias table if allow_table_expression = true and we resolve query node directly.
-      * Example: SELECT a FROM test_table WHERE id IN (SELECT 1) AS a;
-      * To support both (SELECT 1) AS expression in projection and (SELECT 1) as subquery in IN, do not use
-      * alias table because in alias table subquery could be evaluated as scalar.
-      */
-    bool use_alias_table = !ignore_alias;
-    if (is_duplicated_alias || (allow_table_expression && IdentifierResolver::isSubqueryNodeType(node->getNodeType())))
-        use_alias_table = false;
-
-    if (!node_alias.empty() && use_alias_table)
-    {
-        /** Node could be potentially resolved by resolving other nodes.
-          * SELECT b, a as b FROM test_table;
-          *
-          * To resolve b we need to resolve a.
-          */
-        auto it = scope.aliases.alias_name_to_expression_node->find(node_alias);
-        if (it != scope.aliases.alias_name_to_expression_node->end())
-            node = it->second;
-
-        if (allow_lambda_expression)
-        {
-            it = scope.aliases.alias_name_to_lambda_node.find(node_alias);
-            if (it != scope.aliases.alias_name_to_lambda_node.end())
-                node = it->second;
-        }
+        /// Remove alias later. This needed to produce the same query tree subtree
+        /// for expressions with aliaes to subexpression. Example:
+        /// SELECT f(a as b) as c FROM t GROUP BY c
+        if (!ignore_alias)
+            scope.aliases.node_to_remove_aliases.push_back(node);
     }
 
     scope.pushExpressionNode(node);
@@ -3731,12 +3699,11 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
 
                     if (resolved_as_cte)
                     {
+                        auto original_cte_node = resolved_identifier_node;
                         resolved_identifier_node = resolved_identifier_node->clone();
                         subquery_node = resolved_identifier_node->as<QueryNode>();
                         union_node = resolved_identifier_node->as<UnionNode>();
 
-                        std::string_view cte_name = subquery_node ? subquery_node->getCTEName() : union_node->getCTEName();
-
                         if (subquery_node)
                             subquery_node->setIsCTE(false);
                         else
@@ -3752,14 +3719,14 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
                         ///
                         /// In this example argument of function `in` is being resolve here. If CTE `test1` is not forbidden,
                         /// `test1` is resolved to CTE (not to the table) in `initializeQueryJoinTreeNode` function.
-                        ctes_in_resolve_process.insert(cte_name);
+                        ctes_in_resolve_process.insert(original_cte_node);
 
                         if (subquery_node)
                             resolveQuery(resolved_identifier_node, subquery_scope);
                         else
                             resolveUnion(resolved_identifier_node, subquery_scope);
 
-                        ctes_in_resolve_process.erase(cte_name);
+                        ctes_in_resolve_process.erase(original_cte_node);
                     }
                 }
             }
@@ -3958,33 +3925,9 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(
         }
     }
 
-    /** Update aliases after expression node was resolved.
-      * Do not update node in alias table if we resolve it for duplicate alias.
-      */
-    if (!node_alias.empty() && use_alias_table && !scope.group_by_use_nulls)
-    {
-        auto it = scope.aliases.alias_name_to_expression_node->find(node_alias);
-        if (it != scope.aliases.alias_name_to_expression_node->end())
-            it->second = node;
-
-        if (allow_lambda_expression)
-        {
-            it = scope.aliases.alias_name_to_lambda_node.find(node_alias);
-            if (it != scope.aliases.alias_name_to_lambda_node.end())
-                it->second = node;
-        }
-    }
-
-    if (is_duplicated_alias)
-        scope.non_cached_identifier_lookups_during_expression_resolve.erase({Identifier{node_alias}, IdentifierLookupContext::EXPRESSION});
-
-    if (!ignore_alias)
-        resolved_expressions.emplace(node, result_projection_names);
+    resolved_expressions.emplace(node, result_projection_names);
 
     scope.popExpressionNode();
-    bool expression_was_root = scope.expressions_in_resolve_process_stack.empty();
-    if (expression_was_root)
-        scope.non_cached_identifier_lookups_during_expression_resolve.clear();
 
     return result_projection_names;
 }
@@ -4383,7 +4326,7 @@ void QueryAnalyzer::initializeQueryJoinTreeNode(QueryTreeNodePtr & join_tree_nod
 
                 auto from_table_identifier_alias = from_table_identifier.getAlias();
 
-                IdentifierResolveSettings resolve_settings;
+                IdentifierResolveContext resolve_settings;
                 /// In join tree initialization ignore join tree as identifier lookup source
                 resolve_settings.allow_to_check_join_tree = false;
                 /** Disable resolve of subquery during identifier resolution.
@@ -4398,9 +4341,6 @@ void QueryAnalyzer::initializeQueryJoinTreeNode(QueryTreeNodePtr & join_tree_nod
                 auto table_identifier_resolve_result = tryResolveIdentifier(table_identifier_lookup, scope, resolve_settings);
 
                 scope.popExpressionNode();
-                bool expression_was_root = scope.expressions_in_resolve_process_stack.empty();
-                if (expression_was_root)
-                    scope.non_cached_identifier_lookups_during_expression_resolve.clear();
 
                 auto resolved_identifier = table_identifier_resolve_result.resolved_identifier;
 
@@ -4758,6 +4698,10 @@ void QueryAnalyzer::resolveTableFunction(QueryTreeNodePtr & table_function_node,
 
         if (parametrized_view_storage)
         {
+            /// Remove initial TableFunctionNode from the set. Otherwise it may lead to segfault
+            /// when IdentifierResolveScope::dump() is used.
+            scope.table_expressions_in_resolve_process.erase(table_function_node.get());
+
             auto fake_table_node = std::make_shared<TableNode>(parametrized_view_storage, scope_context);
             fake_table_node->setAlias(table_function_node->getAlias());
             table_function_node = fake_table_node;
@@ -5044,7 +4988,7 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif
         if (auto * identifier_node = array_join_expression->as<IdentifierNode>())
             identifier_full_name = identifier_node->getIdentifier().getFullName();
 
-        resolveExpressionNode(array_join_expression, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/, true /*ignore_alias*/);
+        resolveExpressionNode(array_join_expression, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);
 
         auto process_array_join_expression = [&](const QueryTreeNodePtr & expression)
         {
@@ -5237,7 +5181,8 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS
                             /// Create ColumnNode with expression from parent projection
                             return std::make_shared<ColumnNode>(
                                 NameAndTypePair{identifier_full_name_, resolved_nodes.front()->getResultType()},
-                                resolved_nodes.front(), left_table_expression);
+                                resolved_nodes.front(),
+                                left_table_expression);
                         }
                     }
                 }
@@ -5255,7 +5200,7 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS
 
             IdentifierLookup identifier_lookup{identifier_node->getIdentifier(), IdentifierLookupContext::EXPRESSION};
             if (!result_left_table_expression)
-                result_left_table_expression = identifier_resolver.tryResolveIdentifierFromJoinTreeNode(identifier_lookup, join_node_typed.getLeftTableExpression(), scope);
+                result_left_table_expression = identifier_resolver.tryResolveIdentifierFromJoinTreeNode(identifier_lookup, join_node_typed.getLeftTableExpression(), scope).resolved_identifier;
 
             /** Here we may try to resolve identifier from projection in case it's not resolved from left table expression
               * and analyzer_compatibility_join_using_top_level_identifier is disabled.
@@ -5299,7 +5244,7 @@ void QueryAnalyzer::resolveJoin(QueryTreeNodePtr & join_node, IdentifierResolveS
                     identifier_full_name,
                     scope.scope_node->formatASTForErrorMessage());
 
-            auto result_right_table_expression = identifier_resolver.tryResolveIdentifierFromJoinTreeNode(identifier_lookup, join_node_typed.getRightTableExpression(), scope);
+            auto result_right_table_expression = identifier_resolver.tryResolveIdentifierFromJoinTreeNode(identifier_lookup, join_node_typed.getRightTableExpression(), scope).resolved_identifier;
             if (!result_right_table_expression)
                 throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER,
                     "JOIN {} using identifier '{}' cannot be resolved from right table expression. In scope {}",
@@ -5348,7 +5293,7 @@ void QueryAnalyzer::resolveQueryJoinTreeNode(QueryTreeNodePtr & join_tree_node,
             [[fallthrough]];
         case QueryTreeNodeType::UNION:
         {
-            resolveExpressionNode(join_tree_node, scope, false /*allow_lambda_expression*/, true /*allow_table_expression*/);
+            resolveExpressionNode(join_tree_node, scope, false /*allow_lambda_expression*/, true /*allow_table_expression*/, true /*ignore_alias=*/);
             break;
         }
         case QueryTreeNodeType::TABLE_FUNCTION:
@@ -5472,7 +5417,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
         return;
 
     if (query_node_typed.isCTE())
-        ctes_in_resolve_process.insert(query_node_typed.getCTEName());
+        ctes_in_resolve_process.emplace(query_node);
 
     bool is_rollup_or_cube = query_node_typed.isGroupByWithRollup() || query_node_typed.isGroupByWithCube();
 
@@ -5556,7 +5501,6 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
         bool subquery_is_cte = (subquery_node && subquery_node->isCTE()) || (union_node && union_node->isCTE());
         if (!subquery_is_cte)
             continue;
-
         const auto & cte_name = subquery_node ? subquery_node->getCTEName() : union_node->getCTEName();
 
         auto [_, inserted] = scope.cte_name_to_query_node.emplace(cte_name, node);
@@ -5599,27 +5543,16 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
                 scope.scope_node->formatASTForErrorMessage());
     }
 
-    /** Disable identifier cache during JOIN TREE resolve.
-      * Depending on JOIN expression section, identifier with same name
-      * can be resolved in different columns.
-      *
-      * Example: SELECT id FROM test_table AS t1 INNER JOIN test_table AS t2 ON t1.id = t2.id INNER JOIN test_table AS t3 ON t1.id = t3.id
-      * In first join expression ON t1.id = t2.id t1.id is resolved into test_table.id column.
-      * In second join expression ON t1.id = t3.id t1.id must be resolved into test_table.id column after first JOIN.
-      */
-    scope.use_identifier_lookup_to_result_cache = false;
+    auto transitive_aliases = std::move(scope.aliases.alias_name_to_table_expression_node);
 
     TableExpressionsAliasVisitor table_expressions_visitor(scope);
     table_expressions_visitor.visit(query_node_typed.getJoinTree());
 
     initializeQueryJoinTreeNode(query_node_typed.getJoinTree(), scope);
-    scope.aliases.alias_name_to_table_expression_node.clear();
+    scope.aliases.alias_name_to_table_expression_node = std::move(transitive_aliases);
 
     resolveQueryJoinTreeNode(query_node_typed.getJoinTree(), scope, visitor);
 
-    if (!scope.group_by_use_nulls)
-        scope.use_identifier_lookup_to_result_cache = true;
-
     /// Resolve query node sections.
 
     NamesAndTypes projection_columns;
@@ -5659,13 +5592,6 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
     if (scope.group_by_use_nulls)
     {
         resolved_expressions.clear();
-        /// Clone is needed cause aliases share subtrees.
-        /// If not clone, the same (shared) subtree could be resolved again with different (Nullable) type
-        /// See 03023_group_by_use_nulls_analyzer_crashes
-        for (auto & [key, node] : scope.aliases.alias_name_to_expression_node_before_group_by)
-            scope.aliases.alias_name_to_expression_node_after_group_by[key] = node->clone();
-
-        scope.aliases.alias_name_to_expression_node = &scope.aliases.alias_name_to_expression_node_after_group_by;
     }
 
     if (query_node_typed.hasHaving())
@@ -5737,28 +5663,29 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
       * After scope nodes are resolved, we can compare node with duplicate alias with
       * node from scope alias table.
       */
-    for (const auto & node_with_duplicated_alias : scope.aliases.cloned_nodes_with_duplicated_aliases)
+    for (const auto & node_with_duplicated_alias : scope.aliases.nodes_with_duplicated_aliases)
     {
         auto node = node_with_duplicated_alias;
         auto node_alias = node->getAlias();
 
-        /// Add current alias to non cached set, because in case of cyclic alias identifier should not be substituted from cache.
-        /// See 02896_cyclic_aliases_crash.
         resolveExpressionNode(node, scope, true /*allow_lambda_expression*/, true /*allow_table_expression*/);
 
         bool has_node_in_alias_table = false;
 
-        auto it = scope.aliases.alias_name_to_expression_node->find(node_alias);
-        if (it != scope.aliases.alias_name_to_expression_node->end())
+        auto it = scope.aliases.alias_name_to_expression_node.find(node_alias);
+        if (it != scope.aliases.alias_name_to_expression_node.end())
         {
             has_node_in_alias_table = true;
 
-            bool matched = it->second->isEqual(*node);
+            auto original_node = it->second;
+            resolveExpressionNode(original_node, scope, true /*allow_lambda_expression*/, true /*allow_table_expression*/);
+
+            bool matched = original_node->isEqual(*node);
             if (!matched)
                 /// Table expression could be resolved as scalar subquery,
                 /// but for duplicating alias we allow table expression to be returned.
                 /// So, check constant node source expression as well.
-                if (const auto * constant_node = it->second->as<ConstantNode>())
+                if (const auto * constant_node = original_node->as<ConstantNode>())
                     if (const auto & source_expression = constant_node->getSourceExpression())
                         matched = source_expression->isEqual(*node);
 
@@ -5766,7 +5693,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
                 throw Exception(ErrorCodes::MULTIPLE_EXPRESSIONS_FOR_ALIAS,
                     "Multiple expressions {} and {} for alias {}. In scope {}",
                     node->formatASTForErrorMessage(),
-                    it->second->formatASTForErrorMessage(),
+                    original_node->formatASTForErrorMessage(),
                     node_alias,
                     scope.scope_node->formatASTForErrorMessage());
         }
@@ -5776,11 +5703,14 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
         {
             has_node_in_alias_table = true;
 
-            if (!it->second->isEqual(*node))
+            auto original_node = it->second;
+            resolveExpressionNode(original_node, scope, true /*allow_lambda_expression*/, true /*allow_table_expression*/);
+
+            if (!original_node->isEqual(*node))
                 throw Exception(ErrorCodes::MULTIPLE_EXPRESSIONS_FOR_ALIAS,
                     "Multiple expressions {} and {} for alias {}. In scope {}",
                     node->formatASTForErrorMessage(),
-                    it->second->formatASTForErrorMessage(),
+                    original_node->formatASTForErrorMessage(),
                     node_alias,
                     scope.scope_node->formatASTForErrorMessage());
         }
@@ -5817,7 +5747,10 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
 
     /// Remove aliases from expression and lambda nodes
 
-    for (auto & [_, node] : *scope.aliases.alias_name_to_expression_node)
+    for (auto & node : scope.aliases.node_to_remove_aliases)
+        node->removeAlias();
+
+    for (auto & [_, node] : scope.aliases.alias_name_to_expression_node)
         node->removeAlias();
 
     for (auto & [_, node] : scope.aliases.alias_name_to_lambda_node)
@@ -5826,7 +5759,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier
     query_node_typed.resolveProjectionColumns(std::move(projection_columns));
 
     if (query_node_typed.isCTE())
-        ctes_in_resolve_process.erase(query_node_typed.getCTEName());
+        ctes_in_resolve_process.erase(query_node);
 }
 
 void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, IdentifierResolveScope & scope)
@@ -5837,7 +5770,7 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier
         return;
 
     if (union_node_typed.isCTE())
-        ctes_in_resolve_process.insert(union_node_typed.getCTEName());
+        ctes_in_resolve_process.insert(union_node);
 
     auto & queries_nodes = union_node_typed.getQueries().getNodes();
 
@@ -5918,7 +5851,7 @@ void QueryAnalyzer::resolveUnion(const QueryTreeNodePtr & union_node, Identifier
     }
 
     if (union_node_typed.isCTE())
-        ctes_in_resolve_process.erase(union_node_typed.getCTEName());
+        ctes_in_resolve_process.erase(union_node);
 }
 
 }
diff --git a/src/Analyzer/Resolve/QueryAnalyzer.h b/src/Analyzer/Resolve/QueryAnalyzer.h
index 38895c55b831..51d5cb7640b7 100644
--- a/src/Analyzer/Resolve/QueryAnalyzer.h
+++ b/src/Analyzer/Resolve/QueryAnalyzer.h
@@ -172,15 +172,15 @@ class QueryAnalyzer
 
     /// Resolve identifier functions
 
-    QueryTreeNodePtr tryResolveIdentifierFromAliases(const IdentifierLookup & identifier_lookup,
+    IdentifierResolveResult tryResolveIdentifierFromAliases(const IdentifierLookup & identifier_lookup,
         IdentifierResolveScope & scope,
-        IdentifierResolveSettings identifier_resolve_settings);
+        IdentifierResolveContext identifier_resolve_context);
 
-    IdentifierResolveResult tryResolveIdentifierInParentScopes(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope);
+    IdentifierResolveResult tryResolveIdentifierInParentScopes(const IdentifierLookup & identifier_lookup, IdentifierResolveScope & scope, IdentifierResolveContext identifier_resolve_context);
 
     IdentifierResolveResult tryResolveIdentifier(const IdentifierLookup & identifier_lookup,
         IdentifierResolveScope & scope,
-        IdentifierResolveSettings identifier_resolve_settings = {});
+        IdentifierResolveContext identifier_resolve_settings = {});
 
     /// Resolve query tree nodes functions
 
@@ -195,7 +195,7 @@ class QueryAnalyzer
     QueryTreeNodesWithNames getMatchedColumnNodesWithNames(const QueryTreeNodePtr & matcher_node,
         const QueryTreeNodePtr & table_expression_node,
         const NamesAndTypes & matched_columns,
-        const IdentifierResolveScope & scope);
+        IdentifierResolveScope & scope);
 
     void updateMatchedColumnsFromJoinUsing(QueryTreeNodesWithNames & result_matched_column_nodes_with_names, const QueryTreeNodePtr & source_table_expression, IdentifierResolveScope & scope);
 
@@ -214,7 +214,12 @@ class QueryAnalyzer
 
     ProjectionNames resolveFunction(QueryTreeNodePtr & function_node, IdentifierResolveScope & scope);
 
-    ProjectionNames resolveExpressionNode(QueryTreeNodePtr & node, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression, bool ignore_alias = false);
+    ProjectionNames resolveExpressionNode(
+        QueryTreeNodePtr & node,
+        IdentifierResolveScope & scope,
+        bool allow_lambda_expression,
+        bool allow_table_expression,
+        bool ignore_alias = false);
 
     ProjectionNames resolveExpressionNodeList(QueryTreeNodePtr & node_list, IdentifierResolveScope & scope, bool allow_lambda_expression, bool allow_table_expression);
 
@@ -251,10 +256,10 @@ class QueryAnalyzer
     void resolveUnion(const QueryTreeNodePtr & union_node, IdentifierResolveScope & scope);
 
     /// Lambdas that are currently in resolve process
-    std::unordered_set<IQueryTreeNode *> lambdas_in_resolve_process;
+    QueryTreeNodePtrWithHashSet lambdas_in_resolve_process;
 
     /// CTEs that are currently in resolve process
-    std::unordered_set<std::string_view> ctes_in_resolve_process;
+    QueryTreeNodePtrWithHashSet ctes_in_resolve_process;
 
     /// Function name to user defined lambda map
     std::unordered_map<std::string, QueryTreeNodePtr> function_name_to_user_defined_lambda;
diff --git a/src/Analyzer/Resolve/QueryExpressionsAliasVisitor.h b/src/Analyzer/Resolve/QueryExpressionsAliasVisitor.h
index b4c47b306ae6..ea39ba328a85 100644
--- a/src/Analyzer/Resolve/QueryExpressionsAliasVisitor.h
+++ b/src/Analyzer/Resolve/QueryExpressionsAliasVisitor.h
@@ -40,14 +40,14 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress
 
     void visitImpl(QueryTreeNodePtr & node)
     {
-        updateAliasesIfNeeded(node, false /*is_lambda_node*/);
+        updateAliasesIfNeeded(node);
     }
 
     bool needChildVisit(const QueryTreeNodePtr &, const QueryTreeNodePtr & child)
     {
         if (auto * /*lambda_node*/ _ = child->as<LambdaNode>())
         {
-            updateAliasesIfNeeded(child, true /*is_lambda_node*/);
+            updateAliasesIfNeeded(child);
             return false;
         }
         if (auto * query_tree_node = child->as<QueryNode>())
@@ -55,7 +55,7 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress
             if (query_tree_node->isCTE())
                 return false;
 
-            updateAliasesIfNeeded(child, false /*is_lambda_node*/);
+            updateAliasesIfNeeded(child);
             return false;
         }
         if (auto * union_node = child->as<UnionNode>())
@@ -63,7 +63,7 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress
             if (union_node->isCTE())
                 return false;
 
-            updateAliasesIfNeeded(child, false /*is_lambda_node*/);
+            updateAliasesIfNeeded(child);
             return false;
         }
 
@@ -72,45 +72,59 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress
 private:
     void addDuplicatingAlias(const QueryTreeNodePtr & node)
     {
-        aliases.nodes_with_duplicated_aliases.emplace(node);
-        auto cloned_node = node->clone();
-        aliases.cloned_nodes_with_duplicated_aliases.emplace_back(cloned_node);
-        aliases.nodes_with_duplicated_aliases.emplace(cloned_node);
+        aliases.nodes_with_duplicated_aliases.emplace_back(node);
     }
 
-    void updateAliasesIfNeeded(const QueryTreeNodePtr & node, bool is_lambda_node)
+    void updateAliasesIfNeeded(const QueryTreeNodePtr & node)
     {
         if (!node->hasAlias())
             return;
 
+        auto node_type = node->getNodeType();
+
         // We should not resolve expressions to WindowNode
-        if (node->getNodeType() == QueryTreeNodeType::WINDOW)
+        if (node_type == QueryTreeNodeType::WINDOW)
             return;
 
         const auto & alias = node->getAlias();
+        auto cloned_alias_node = node->clone();
 
-        if (is_lambda_node)
+        switch (node_type)
         {
-            if (aliases.alias_name_to_expression_node->contains(alias))
-                addDuplicatingAlias(node);
-
-            auto [_, inserted] = aliases.alias_name_to_lambda_node.insert(std::make_pair(alias, node));
-            if (!inserted)
-                addDuplicatingAlias(node);
-
-            return;
+        case QueryTreeNodeType::LAMBDA:
+            {
+                auto [_, inserted] = aliases.alias_name_to_lambda_node.emplace(alias, cloned_alias_node);
+                if (!inserted || aliases.alias_name_to_expression_node.contains(alias))
+                    addDuplicatingAlias(cloned_alias_node);
+                break;
+            }
+        case QueryTreeNodeType::IDENTIFIER:
+            {
+                auto [_1, inserted_expression] = aliases.alias_name_to_expression_node.emplace(alias, cloned_alias_node);
+                bool inserted_lambda           = true; // Avoid adding to duplicating aliases if identifier is compound.
+                bool inserted_table_expression = true; // Avoid adding to duplicating aliases if identifier is compound.
+
+                // Alias to compound identifier cannot reference table expression or lambda.
+                // Example: SELECT x.b as x FROM (SELECT 1 as a, 2 as b) as x
+                auto * identifier_node = node->as<IdentifierNode>();
+                if (identifier_node->getIdentifier().isShort())
+                {
+                    inserted_lambda = aliases.alias_name_to_lambda_node.emplace(alias, cloned_alias_node).second;
+                    inserted_table_expression = aliases.alias_name_to_table_expression_node.emplace(alias, cloned_alias_node).second;
+                }
+
+                if (!inserted_expression || !inserted_lambda || !inserted_table_expression)
+                    addDuplicatingAlias(cloned_alias_node);
+                break;
+            }
+        default:
+            {
+                auto [_, inserted] = aliases.alias_name_to_expression_node.emplace(alias, cloned_alias_node);
+                if (!inserted || aliases.alias_name_to_lambda_node.contains(alias))
+                    addDuplicatingAlias(cloned_alias_node);
+                break;
+            }
         }
-
-        if (aliases.alias_name_to_lambda_node.contains(alias))
-            addDuplicatingAlias(node);
-
-        auto [_, inserted] = aliases.alias_name_to_expression_node->insert(std::make_pair(alias, node));
-        if (!inserted)
-            addDuplicatingAlias(node);
-
-        /// If node is identifier put it into transitive aliases map.
-        if (const auto * identifier = typeid_cast<const IdentifierNode *>(node.get()))
-            aliases.transitive_aliases.insert(std::make_pair(alias, identifier->getIdentifier()));
     }
 
     ScopeAliases & aliases;
diff --git a/src/Analyzer/Resolve/ScopeAliases.h b/src/Analyzer/Resolve/ScopeAliases.h
index c67a94ef2348..5c2a58e1a82c 100644
--- a/src/Analyzer/Resolve/ScopeAliases.h
+++ b/src/Analyzer/Resolve/ScopeAliases.h
@@ -9,10 +9,7 @@ namespace DB
 struct ScopeAliases
 {
     /// Alias name to query expression node
-    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node_before_group_by;
-    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node_after_group_by;
-
-    std::unordered_map<std::string, QueryTreeNodePtr> * alias_name_to_expression_node = nullptr;
+    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node;
 
     /// Alias name to lambda node
     std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_lambda_node;
@@ -20,18 +17,19 @@ struct ScopeAliases
     /// Alias name to table expression node
     std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_table_expression_node;
 
-    /// Expressions like `x as y` where we can't say whether it's a function, expression or table.
-    std::unordered_map<std::string, Identifier> transitive_aliases;
-
     /// Nodes with duplicated aliases
-    std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;
-    std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;
+    QueryTreeNodes nodes_with_duplicated_aliases;
+
+    /// Cloned resolved expressions with aliases that must be removed
+    QueryTreeNodes node_to_remove_aliases;
+
+    std::unordered_map<std::string, DataTypePtr> alias_name_to_expression_type;
 
     std::unordered_map<std::string, QueryTreeNodePtr> & getAliasMap(IdentifierLookupContext lookup_context)
     {
         switch (lookup_context)
         {
-            case IdentifierLookupContext::EXPRESSION: return *alias_name_to_expression_node;
+            case IdentifierLookupContext::EXPRESSION: return alias_name_to_expression_node;
             case IdentifierLookupContext::FUNCTION: return alias_name_to_lambda_node;
             case IdentifierLookupContext::TABLE_EXPRESSION: return alias_name_to_table_expression_node;
         }
@@ -59,27 +57,9 @@ struct ScopeAliases
 
         auto it = alias_map.find(*key);
 
-        if (it != alias_map.end())
-            return &it->second;
-
-        if (lookup.lookup_context == IdentifierLookupContext::TABLE_EXPRESSION)
+        if (it == alias_map.end())
             return {};
 
-        while (it == alias_map.end())
-        {
-            auto jt = transitive_aliases.find(*key);
-            if (jt == transitive_aliases.end())
-                return {};
-
-            const auto & new_key = getKey(jt->second, find_option);
-            /// Ignore potential cyclic aliases.
-            if (new_key == *key)
-                return {};
-
-            key = &new_key;
-            it = alias_map.find(*key);
-        }
-
         return &it->second;
     }
 
diff --git a/src/Analyzer/Resolve/TableExpressionData.h b/src/Analyzer/Resolve/TableExpressionData.h
index 6770672d0c29..bbedad69cfe4 100644
--- a/src/Analyzer/Resolve/TableExpressionData.h
+++ b/src/Analyzer/Resolve/TableExpressionData.h
@@ -54,22 +54,21 @@ struct AnalysisTableExpressionData
 
     [[maybe_unused]] void dump(WriteBuffer & buffer) const
     {
-        buffer << "Table expression name " << table_expression_name;
+        buffer << " Table expression name '" << table_expression_name << "'";
 
         if (!table_expression_description.empty())
-            buffer << " table expression description " << table_expression_description;
+            buffer << ", description '" << table_expression_description << "'
";
 
         if (!database_name.empty())
-            buffer << " database name " << database_name;
+            buffer << "   database name '" << database_name << "'
";
 
         if (!table_name.empty())
-            buffer << " table name " << table_name;
-
-        buffer << " should qualify columns " << should_qualify_columns;
-        buffer << " columns size " << column_name_to_column_node.size() << '
';
+            buffer << "   table name '" << table_name << "'
";
 
+        buffer << "   Should qualify columns " << should_qualify_columns << "
";
+        buffer << "   Columns size " << column_name_to_column_node.size() << "
";
         for (const auto & [column_name, column_node] : column_name_to_column_node)
-            buffer << "Column name " << column_name << " column node " << column_node->dumpTree() << '
';
+            buffer << "    { " << column_name << " : " << column_node->dumpTree() << " }
";
     }
 
     [[maybe_unused]] String dump() const
diff --git a/src/Analyzer/Utils.cpp b/src/Analyzer/Utils.cpp
index 02ee778885f3..a2bf3ae8b0d0 100644
--- a/src/Analyzer/Utils.cpp
+++ b/src/Analyzer/Utils.cpp
@@ -22,17 +22,18 @@
 
 #include <Interpreters/Context.h>
 
-#include <Analyzer/InDepthQueryTreeVisitor.h>
-#include <Analyzer/IdentifierNode.h>
-#include <Analyzer/ConstantNode.h>
+#include <Analyzer/ArrayJoinNode.h>
 #include <Analyzer/ColumnNode.h>
+#include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
+#include <Analyzer/IdentifierNode.h>
+#include <Analyzer/InDepthQueryTreeVisitor.h>
 #include <Analyzer/JoinNode.h>
-#include <Analyzer/ArrayJoinNode.h>
-#include <Analyzer/TableNode.h>
-#include <Analyzer/TableFunctionNode.h>
 #include <Analyzer/QueryNode.h>
+#include <Analyzer/TableFunctionNode.h>
+#include <Analyzer/TableNode.h>
 #include <Analyzer/UnionNode.h>
+#include <Analyzer/Resolve/IdentifierResolveScope.h>
 
 #include <ranges>
 namespace DB
@@ -205,6 +206,27 @@ bool isQueryOrUnionNode(const QueryTreeNodePtr & node)
     return isQueryOrUnionNode(node.get());
 }
 
+bool isDependentColumn(IdentifierResolveScope * scope_to_check, const QueryTreeNodePtr & column_source)
+{
+    /// The case of lambda argument. Example:
+    /// arrayMap(X -> X + Y, [0])
+    ///
+    /// X would have lambda as a source node
+    /// Y comes from outer scope and requires ordinary check.
+    if (column_source->getNodeType() == QueryTreeNodeType::LAMBDA)
+        return false;
+
+    while (scope_to_check != nullptr)
+    {
+        if (scope_to_check->registered_table_expression_nodes.contains(column_source))
+            return false;
+        if (isQueryOrUnionNode(scope_to_check->scope_node))
+            return true;
+        scope_to_check = scope_to_check->parent_scope;
+    }
+    return true;
+}
+
 QueryTreeNodePtr buildCastFunction(const QueryTreeNodePtr & expression,
     const DataTypePtr & type,
     const ContextPtr & context,
diff --git a/src/Analyzer/Utils.h b/src/Analyzer/Utils.h
index 0ace5b722bfe..858e7e2c247d 100644
--- a/src/Analyzer/Utils.h
+++ b/src/Analyzer/Utils.h
@@ -12,6 +12,7 @@ namespace DB
 {
 
 class FunctionNode;
+struct IdentifierResolveScope;
 
 /// Returns true if node part of root tree, false otherwise
 bool isNodePartOfTree(const IQueryTreeNode * node, const IQueryTreeNode * root);
@@ -40,6 +41,11 @@ bool isQueryOrUnionNode(const IQueryTreeNode * node);
 /// Returns true, if node has type QUERY or UNION
 bool isQueryOrUnionNode(const QueryTreeNodePtr & node);
 
+/* Returns true, if coulmn source is not registered in scopes that appear
+ * before nearest query scope.
+ */
+bool isDependentColumn(IdentifierResolveScope * scope_to_check, const QueryTreeNodePtr & column_source);
+
 /** Build cast function that cast expression into type.
   * If resolve = true, then result cast function is resolved during build, otherwise
   * result cast function is not resolved during build.
diff --git a/src/Planner/PlannerContext.cpp b/src/Planner/PlannerContext.cpp
index c9187e6aa2aa..c7d20589a50c 100644
--- a/src/Planner/PlannerContext.cpp
+++ b/src/Planner/PlannerContext.cpp
@@ -129,7 +129,7 @@ const ColumnIdentifier * PlannerContext::getColumnNodeIdentifierOrNull(const Que
 
 PlannerContext::SetKey PlannerContext::createSetKey(const DataTypePtr & left_operand_type, const QueryTreeNodePtr & set_source_node)
 {
-    const auto set_source_hash = set_source_node->getTreeHash();
+    const auto set_source_hash = set_source_node->getTreeHash({ .compare_aliases = false });
     if (set_source_node->as<ConstantNode>())
     {
         /* We need to hash the type of the left operand because we can build different sets for different types.
diff --git a/src/Processors/QueryPlan/SetsSerialization.cpp b/src/Processors/QueryPlan/SetsSerialization.cpp
index ae887d1e18d0..dec272991a55 100644
--- a/src/Processors/QueryPlan/SetsSerialization.cpp
+++ b/src/Processors/QueryPlan/SetsSerialization.cpp
@@ -204,7 +204,7 @@ static void makeSetsFromStorage(std::list<QueryPlanAndSets::SetFromStorage> sets
     for (auto & set : sets)
     {
         Identifier identifier = parseTableIdentifier(set.storage_name, context);
-        auto table_node = resolveTable(identifier, context);
+        auto * table_node = resolveTable(identifier, context);
         const auto * storage_set = typeid_cast<const StorageSet *>(table_node->getStorage().get());
         if (!storage_set)
             throw Exception(ErrorCodes::INCORRECT_DATA, "Table {} is not a StorageSet", set.storage_name);
diff --git a/src/Processors/QueryPlan/resolveStorages.cpp b/src/Processors/QueryPlan/resolveStorages.cpp
index 942d9bf0f850..3d466c6571b7 100644
--- a/src/Processors/QueryPlan/resolveStorages.cpp
+++ b/src/Processors/QueryPlan/resolveStorages.cpp
@@ -39,12 +39,15 @@ Identifier parseTableIdentifier(const std::string & str, const ContextPtr & cont
     return Identifier(std::move(res->as<ASTIdentifier>()->name_parts));
 }
 
-std::shared_ptr<TableNode> resolveTable(const Identifier & identifier, const ContextPtr & context)
+TableNode * resolveTable(const Identifier & identifier, const ContextPtr & context)
 {
-    auto table_node_ptr = IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(identifier, context);
-    if (!table_node_ptr)
+    auto resolve_result = IdentifierResolver::tryResolveTableIdentifierFromDatabaseCatalog(identifier, context);
+    if (!resolve_result)
         throw Exception(ErrorCodes::UNKNOWN_TABLE, "Unknown table {}", identifier.getFullName());
 
+    auto * table_node_ptr = resolve_result.resolved_identifier->as<TableNode>();
+    chassert(table_node_ptr != nullptr);
+
     return table_node_ptr;
 }
 
diff --git a/src/Processors/QueryPlan/resolveStorages.h b/src/Processors/QueryPlan/resolveStorages.h
index c1abd7425dd3..a00ee16de818 100644
--- a/src/Processors/QueryPlan/resolveStorages.h
+++ b/src/Processors/QueryPlan/resolveStorages.h
@@ -7,7 +7,7 @@ namespace DB
 class Identifier;
 class TableNode;
 
-std::shared_ptr<TableNode> resolveTable(const Identifier & identifier, const ContextPtr & context);
+TableNode * resolveTable(const Identifier & identifier, const ContextPtr & context);
 Identifier parseTableIdentifier(const std::string & str, const ContextPtr & context);
 
 }
diff --git a/src/Storages/buildQueryTreeForShard.cpp b/src/Storages/buildQueryTreeForShard.cpp
index 8146529362f8..3d21deebb983 100644
--- a/src/Storages/buildQueryTreeForShard.cpp
+++ b/src/Storages/buildQueryTreeForShard.cpp
@@ -400,19 +400,28 @@ QueryTreeNodePtr buildQueryTreeForShard(const PlannerContextPtr & planner_contex
                 && in_function_node_type != QueryTreeNodeType::TABLE)
                 continue;
 
+            QueryTreeNodePtr replacement_table_expression;
             auto & temporary_table_expression_node = global_in_temporary_tables[in_function_subquery_node];
             if (!temporary_table_expression_node)
             {
                 auto subquery_to_execute = in_function_subquery_node;
                 if (subquery_to_execute->as<TableNode>())
-                    subquery_to_execute
-                        = buildSubqueryToReadColumnsFromTableExpression(subquery_to_execute, planner_context->getQueryContext());
+                    subquery_to_execute = buildSubqueryToReadColumnsFromTableExpression(
+                        subquery_to_execute,
+                        planner_context->getQueryContext());
 
                 temporary_table_expression_node = executeSubqueryNode(
-                    subquery_to_execute, planner_context->getMutableQueryContext(), global_in_or_join_node.subquery_depth);
+                    subquery_to_execute,
+                    planner_context->getMutableQueryContext(),
+                    global_in_or_join_node.subquery_depth);
+                    replacement_table_expression = temporary_table_expression_node;
+            }
+            else
+            {
+                replacement_table_expression = temporary_table_expression_node->clone();
             }
 
-            replacement_map.emplace(in_function_subquery_node.get(), temporary_table_expression_node);
+            replacement_map.emplace(in_function_subquery_node.get(), replacement_table_expression);
         }
         else
         {
