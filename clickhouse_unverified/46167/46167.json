{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 46167,
  "instance_id": "ClickHouse__ClickHouse-46167",
  "issue_numbers": [
    "45655"
  ],
  "base_commit": "9b23068d5e68b72eec8ba4993df2470facb509ad",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-search-functions.md b/docs/en/sql-reference/functions/string-search-functions.md\nindex 7b14b0e96dee..b6b70c7795bc 100644\n--- a/docs/en/sql-reference/functions/string-search-functions.md\n+++ b/docs/en/sql-reference/functions/string-search-functions.md\n@@ -391,10 +391,18 @@ For patterns to search for substrings in a string, it is better to use LIKE or \n \n ## multiMatchAny(haystack, \\[pattern<sub>1</sub>, pattern<sub>2</sub>, \u2026, pattern<sub>n</sub>\\])\n \n-The same as `match`, but returns 0 if none of the regular expressions are matched and 1 if any of the patterns matches. It uses [hyperscan](https://github.com/intel/hyperscan) library. For patterns to search substrings in a string, it is better to use `multiSearchAny` since it works much faster.\n+The same as `match`, but returns 0 if none of the regular expressions are matched and 1 if any of the patterns matches. For patterns to search substrings in a string, it is better to use `multiSearchAny` since it works much faster.\n \n :::note\n-The length of any of the `haystack` string must be less than 2<sup>32</sup> bytes otherwise the exception is thrown. This restriction takes place because of hyperscan API.\n+Functions `multiMatchAny`, `multiMatchAnyIndex`, `multiMatchAllIndices` and their fuzzy equivalents (`multiFuzzyMatchAny`,\n+`multiFuzzyMatchAnyIndex`, `multiFuzzyMatchAllIndices`) use the (Vectorscan)[https://github.com/VectorCamp/vectorscan] library. As such,\n+they are only enabled if ClickHouse is compiled with support for vectorscan.\n+\n+Due to restrictions of vectorscan, the length of the `haystack` string must be less than 2<sup>32</sup> bytes.\n+\n+Hyperscan is generally vulnerable to regular expression denial of service (ReDoS) attacks (e.g. see\n+(here)[https://www.usenix.org/conference/usenixsecurity22/presentation/turonova], (here)[https://doi.org/10.1007/s10664-021-10033-1] and\n+(here)[ https://doi.org/10.1145/3236024.3236027]. Users are adviced to check the provided patterns carefully.\n :::\n \n ## multiMatchAnyIndex(haystack, \\[pattern<sub>1</sub>, pattern<sub>2</sub>, \u2026, pattern<sub>n</sub>\\])\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 983ec4d64165..e378de778751 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -446,6 +446,7 @@ class IColumn;\n     M(Bool, allow_hyperscan, true, \"Allow functions that use Hyperscan library. Disable to avoid potentially long compilation times and excessive resource usage.\", 0) \\\n     M(UInt64, max_hyperscan_regexp_length, 0, \"Max length of regexp than can be used in hyperscan multi-match functions. Zero means unlimited.\", 0) \\\n     M(UInt64, max_hyperscan_regexp_total_length, 0, \"Max total length of all regexps than can be used in hyperscan multi-match functions (per every function). Zero means unlimited.\", 0) \\\n+    M(Bool, reject_expensive_hyperscan_regexps, true, \"Reject patterns which will likely be expensive to evaluate with hyperscan (due to NFA state explosion)\", 0) \\\n     M(Bool, allow_simdjson, true, \"Allow using simdjson library in 'JSON*' functions if AVX2 instructions are available. If disabled rapidjson will be used.\", 0) \\\n     M(Bool, allow_introspection_functions, false, \"Allow functions for introspection of ELF and DWARF for query profiling. These functions are slow and may impose security considerations.\", 0) \\\n     \\\ndiff --git a/src/Dictionaries/RegExpTreeDictionary.cpp b/src/Dictionaries/RegExpTreeDictionary.cpp\nindex fdda2cd407d8..c636f200324a 100644\n--- a/src/Dictionaries/RegExpTreeDictionary.cpp\n+++ b/src/Dictionaries/RegExpTreeDictionary.cpp\n@@ -17,6 +17,7 @@\n #include <DataTypes/DataTypesNumber.h>\n \n #include <Functions/Regexps.h>\n+#include <Functions/checkHyperscanRegexp.h>\n #include <QueryPipeline/QueryPipeline.h>\n \n #include <Dictionaries/ClickHouseDictionarySource.h>\n@@ -152,53 +153,6 @@ void RegExpTreeDictionary::calculateBytesAllocated()\n     bytes_allocated += 2 * sizeof(UInt64) * topology_order.size();\n }\n \n-namespace\n-{\n-    /// hyper scan is not good at processing regex containing {0, 200}\n-    /// This will make re compilation slow and failed. So we select this heavy regular expressions and\n-    /// process it with re2.\n-    struct RegexChecker\n-    {\n-        re2_st::RE2 searcher;\n-        RegexChecker() : searcher(R\"(\\{([\\d]+),([\\d]+)\\})\") {}\n-\n-        static bool isFigureLargerThanFifty(const String & str)\n-        try\n-        {\n-            auto number = std::stoi(str);\n-            return number > 50;\n-        }\n-        catch (std::exception &)\n-        {\n-            return false;\n-        }\n-\n-        [[maybe_unused]]\n-        bool isSimpleRegex(const String & regex) const\n-        {\n-\n-            re2_st::StringPiece haystack(regex.data(), regex.size());\n-            re2_st::StringPiece matches[10];\n-            size_t start_pos = 0;\n-            while (start_pos < regex.size())\n-            {\n-                if (searcher.Match(haystack, start_pos, regex.size(), re2_st::RE2::Anchor::UNANCHORED, matches, 10))\n-                {\n-                    const auto & match = matches[0];\n-                    start_pos += match.length();\n-                    const auto & match1 = matches[1];\n-                    const auto & match2 = matches[2];\n-                    if (isFigureLargerThanFifty(match1.ToString()) || isFigureLargerThanFifty(match2.ToString()))\n-                        return false;\n-                }\n-                else\n-                    break;\n-            }\n-            return true;\n-        }\n-    };\n-}\n-\n void RegExpTreeDictionary::initRegexNodes(Block & block)\n {\n     auto id_column = block.getByName(kId).column;\n@@ -207,7 +161,9 @@ void RegExpTreeDictionary::initRegexNodes(Block & block)\n     auto keys_column = block.getByName(kKeys).column;\n     auto values_column = block.getByName(kValues).column;\n \n-    RegexChecker checker;\n+#ifdef USE_VECTORSCAN\n+    SlowWithHyperscanChecker checker;\n+#endif\n \n     size_t size = block.rows();\n     for (size_t i = 0; i < size; i++)\n@@ -253,7 +209,7 @@ void RegExpTreeDictionary::initRegexNodes(Block & block)\n         }\n         regex_nodes.emplace(id, node);\n #if USE_VECTORSCAN\n-        if (use_vectorscan && checker.isSimpleRegex(regex))\n+        if (use_vectorscan && !checker.isSlow(regex))\n         {\n             simple_regexps.push_back(regex);\n             regexp_ids.push_back(id);\ndiff --git a/src/Functions/FunctionsMultiStringFuzzySearch.h b/src/Functions/FunctionsMultiStringFuzzySearch.h\nindex 5d86dd4dadad..00d989f388ed 100644\n--- a/src/Functions/FunctionsMultiStringFuzzySearch.h\n+++ b/src/Functions/FunctionsMultiStringFuzzySearch.h\n@@ -39,13 +39,14 @@ class FunctionsMultiStringFuzzySearch : public IFunction\n     static FunctionPtr create(ContextPtr context)\n     {\n         const auto & settings = context->getSettingsRef();\n-        return std::make_shared<FunctionsMultiStringFuzzySearch>(settings.allow_hyperscan, settings.max_hyperscan_regexp_length, settings.max_hyperscan_regexp_total_length);\n+        return std::make_shared<FunctionsMultiStringFuzzySearch>(settings.allow_hyperscan, settings.max_hyperscan_regexp_length, settings.max_hyperscan_regexp_total_length, settings.reject_expensive_hyperscan_regexps);\n     }\n \n-    FunctionsMultiStringFuzzySearch(bool allow_hyperscan_, size_t max_hyperscan_regexp_length_, size_t max_hyperscan_regexp_total_length_)\n+    FunctionsMultiStringFuzzySearch(bool allow_hyperscan_, size_t max_hyperscan_regexp_length_, size_t max_hyperscan_regexp_total_length_, bool reject_expensive_hyperscan_regexps_)\n         : allow_hyperscan(allow_hyperscan_)\n         , max_hyperscan_regexp_length(max_hyperscan_regexp_length_)\n         , max_hyperscan_regexp_total_length(max_hyperscan_regexp_total_length_)\n+        , reject_expensive_hyperscan_regexps(reject_expensive_hyperscan_regexps_)\n     {}\n \n     String getName() const override { return name; }\n@@ -112,14 +113,14 @@ class FunctionsMultiStringFuzzySearch : public IFunction\n                 col_needles_const->getValue<Array>(),\n                 vec_res, offsets_res,\n                 edit_distance,\n-                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n         else\n             Impl::vectorVector(\n                 col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n                 col_needles_vector->getData(), col_needles_vector->getOffsets(),\n                 vec_res, offsets_res,\n                 edit_distance,\n-                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n \n         // the combination of const haystack + const needle is not implemented because\n         // useDefaultImplementationForConstants() == true makes upper layers convert both to\n@@ -135,6 +136,7 @@ class FunctionsMultiStringFuzzySearch : public IFunction\n     const bool allow_hyperscan;\n     const size_t max_hyperscan_regexp_length;\n     const size_t max_hyperscan_regexp_total_length;\n+    const bool reject_expensive_hyperscan_regexps;\n };\n \n }\ndiff --git a/src/Functions/FunctionsMultiStringSearch.h b/src/Functions/FunctionsMultiStringSearch.h\nindex 2465567b8836..c0ed90aa042c 100644\n--- a/src/Functions/FunctionsMultiStringSearch.h\n+++ b/src/Functions/FunctionsMultiStringSearch.h\n@@ -53,13 +53,14 @@ class FunctionsMultiStringSearch : public IFunction\n     static FunctionPtr create(ContextPtr context)\n     {\n         const auto & settings = context->getSettingsRef();\n-        return std::make_shared<FunctionsMultiStringSearch>(settings.allow_hyperscan, settings.max_hyperscan_regexp_length, settings.max_hyperscan_regexp_total_length);\n+        return std::make_shared<FunctionsMultiStringSearch>(settings.allow_hyperscan, settings.max_hyperscan_regexp_length, settings.max_hyperscan_regexp_total_length, settings.reject_expensive_hyperscan_regexps);\n     }\n \n-    FunctionsMultiStringSearch(bool allow_hyperscan_, size_t max_hyperscan_regexp_length_, size_t max_hyperscan_regexp_total_length_)\n+    FunctionsMultiStringSearch(bool allow_hyperscan_, size_t max_hyperscan_regexp_length_, size_t max_hyperscan_regexp_total_length_, bool reject_expensive_hyperscan_regexps_)\n         : allow_hyperscan(allow_hyperscan_)\n         , max_hyperscan_regexp_length(max_hyperscan_regexp_length_)\n         , max_hyperscan_regexp_total_length(max_hyperscan_regexp_total_length_)\n+        , reject_expensive_hyperscan_regexps(reject_expensive_hyperscan_regexps_)\n     {}\n \n     String getName() const override { return name; }\n@@ -108,13 +109,13 @@ class FunctionsMultiStringSearch : public IFunction\n                 col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n                 col_needles_const->getValue<Array>(),\n                 vec_res, offsets_res,\n-                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n         else\n             Impl::vectorVector(\n                 col_haystack_vector->getChars(), col_haystack_vector->getOffsets(),\n                 col_needles_vector->getData(), col_needles_vector->getOffsets(),\n                 vec_res, offsets_res,\n-                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+                allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n \n         // the combination of const haystack + const needle is not implemented because\n         // useDefaultImplementationForConstants() == true makes upper layers convert both to\n@@ -130,6 +131,7 @@ class FunctionsMultiStringSearch : public IFunction\n     const bool allow_hyperscan;\n     const size_t max_hyperscan_regexp_length;\n     const size_t max_hyperscan_regexp_total_length;\n+    const bool reject_expensive_hyperscan_regexps;\n };\n \n }\ndiff --git a/src/Functions/MatchImpl.h b/src/Functions/MatchImpl.h\nindex 00c08ea8531a..db8dd55474e4 100644\n--- a/src/Functions/MatchImpl.h\n+++ b/src/Functions/MatchImpl.h\n@@ -6,7 +6,7 @@\n #include <Columns/ColumnString.h>\n #include <Columns/ColumnsNumber.h>\n #include <Core/ColumnNumbers.h>\n-#include \"Regexps.h\"\n+#include <Functions/Regexps.h>\n \n #include \"config.h\"\n #include <re2_st/re2.h>\ndiff --git a/src/Functions/MultiMatchAllIndicesImpl.h b/src/Functions/MultiMatchAllIndicesImpl.h\nindex dec8349e6934..d655311f5320 100644\n--- a/src/Functions/MultiMatchAllIndicesImpl.h\n+++ b/src/Functions/MultiMatchAllIndicesImpl.h\n@@ -6,7 +6,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeArray.h>\n #include <Functions/checkHyperscanRegexp.h>\n-#include \"Regexps.h\"\n+#include <Functions/Regexps.h>\n \n #include \"config.h\"\n \n@@ -51,9 +51,10 @@ struct MultiMatchAllIndicesImpl\n         PaddedPODArray<UInt64> & offsets,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n-        vectorConstant(haystack_data, haystack_offsets, needles_arr, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        vectorConstant(haystack_data, haystack_offsets, needles_arr, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n     }\n \n     static void vectorConstant(\n@@ -65,7 +66,8 @@ struct MultiMatchAllIndicesImpl\n         std::optional<UInt32> edit_distance,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n         if (!allow_hyperscan)\n             throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n@@ -77,6 +79,14 @@ struct MultiMatchAllIndicesImpl\n \n         checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n \n+        if (reject_expensive_hyperscan_regexps)\n+        {\n+            SlowWithHyperscanChecker checker;\n+            for (auto needle : needles)\n+                if (checker.isSlow(needle))\n+                    throw Exception(ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT, \"Regular expression evaluation in vectorscan will be too slow. To ignore this error, disable setting 'reject_expensive_hyperscan_regexps'.\");\n+        }\n+\n         offsets.resize(haystack_offsets.size());\n \n         if (needles_arr.empty())\n@@ -135,6 +145,7 @@ struct MultiMatchAllIndicesImpl\n         (void)edit_distance;\n         (void)max_hyperscan_regexp_length;\n         (void)max_hyperscan_regexp_total_length;\n+        (void)reject_expensive_hyperscan_regexps;\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"multi-search all indices is not implemented when vectorscan is off\");\n #endif // USE_VECTORSCAN\n     }\n@@ -148,9 +159,10 @@ struct MultiMatchAllIndicesImpl\n         PaddedPODArray<UInt64> & offsets,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n-        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n     }\n \n     static void vectorVector(\n@@ -163,7 +175,8 @@ struct MultiMatchAllIndicesImpl\n         std::optional<UInt32> edit_distance,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n         if (!allow_hyperscan)\n             throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n@@ -195,6 +208,14 @@ struct MultiMatchAllIndicesImpl\n \n             checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n \n+            if (reject_expensive_hyperscan_regexps)\n+            {\n+                SlowWithHyperscanChecker checker;\n+                for (auto needle : needles)\n+                    if (checker.isSlow(needle))\n+                        throw Exception(ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT, \"Regular expression evaluation in vectorscan will be too slow. To ignore this error, disable setting 'reject_expensive_hyperscan_regexps'.\");\n+            }\n+\n             MultiRegexps::DeferredConstructedRegexpsPtr deferred_constructed_regexps = MultiRegexps::getOrSet</*SaveIndices*/ true, WithEditDistance>(needles, edit_distance);\n             MultiRegexps::Regexps * regexps = deferred_constructed_regexps->get();\n             hs_scratch_t * scratch = nullptr;\n@@ -249,6 +270,7 @@ struct MultiMatchAllIndicesImpl\n         (void)edit_distance;\n         (void)max_hyperscan_regexp_length;\n         (void)max_hyperscan_regexp_total_length;\n+        (void)reject_expensive_hyperscan_regexps;\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"multi-search all indices is not implemented when vectorscan is off\");\n #endif // USE_VECTORSCAN\n     }\ndiff --git a/src/Functions/MultiMatchAnyImpl.h b/src/Functions/MultiMatchAnyImpl.h\nindex 0e42d4f6b583..672aaa951690 100644\n--- a/src/Functions/MultiMatchAnyImpl.h\n+++ b/src/Functions/MultiMatchAnyImpl.h\n@@ -5,7 +5,7 @@\n #include <Columns/ColumnString.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/checkHyperscanRegexp.h>\n-#include \"Regexps.h\"\n+#include <Functions/Regexps.h>\n \n #include \"config.h\"\n \n@@ -65,9 +65,10 @@ struct MultiMatchAnyImpl\n         PaddedPODArray<UInt64> & offsets,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n-        vectorConstant(haystack_data, haystack_offsets, needles_arr, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        vectorConstant(haystack_data, haystack_offsets, needles_arr, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n     }\n \n     static void vectorConstant(\n@@ -79,7 +80,8 @@ struct MultiMatchAnyImpl\n         [[maybe_unused]] std::optional<UInt32> edit_distance,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n         if (!allow_hyperscan)\n             throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n@@ -91,6 +93,14 @@ struct MultiMatchAnyImpl\n \n         checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n \n+        if (reject_expensive_hyperscan_regexps)\n+        {\n+            SlowWithHyperscanChecker checker;\n+            for (auto needle : needles)\n+                if (checker.isSlow(needle))\n+                    throw Exception(ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT, \"Regular expression evaluation in vectorscan will be too slow. To ignore this error, disable setting 'reject_expensive_hyperscan_regexps'.\");\n+        }\n+\n         res.resize(haystack_offsets.size());\n \n         if (needles_arr.empty())\n@@ -175,9 +185,10 @@ struct MultiMatchAnyImpl\n         PaddedPODArray<UInt64> & offsets,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n-        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n+        vectorVector(haystack_data, haystack_offsets, needles_data, needles_offsets, res, offsets, std::nullopt, allow_hyperscan, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length, reject_expensive_hyperscan_regexps);\n     }\n \n     static void vectorVector(\n@@ -190,7 +201,8 @@ struct MultiMatchAnyImpl\n         std::optional<UInt32> edit_distance,\n         bool allow_hyperscan,\n         size_t max_hyperscan_regexp_length,\n-        size_t max_hyperscan_regexp_total_length)\n+        size_t max_hyperscan_regexp_total_length,\n+        bool reject_expensive_hyperscan_regexps)\n     {\n         if (!allow_hyperscan)\n             throw Exception(ErrorCodes::FUNCTION_NOT_ALLOWED, \"Hyperscan functions are disabled, because setting 'allow_hyperscan' is set to 0\");\n@@ -209,9 +221,7 @@ struct MultiMatchAnyImpl\n             needles.reserve(needles_offsets[i] - prev_needles_offset);\n \n             for (size_t j = prev_needles_offset; j < needles_offsets[i]; ++j)\n-            {\n                 needles.emplace_back(needles_data_string->getDataAt(j).toView());\n-            }\n \n             if (needles.empty())\n             {\n@@ -223,6 +233,14 @@ struct MultiMatchAnyImpl\n \n             checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n \n+            if (reject_expensive_hyperscan_regexps)\n+            {\n+                SlowWithHyperscanChecker checker;\n+                for (auto needle : needles)\n+                    if (checker.isSlow(needle))\n+                        throw Exception(ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT, \"Regular expression evaluation in vectorscan will be too slow. To ignore this error, disable setting 'reject_expensive_hyperscan_regexps'.\");\n+            }\n+\n             MultiRegexps::DeferredConstructedRegexpsPtr deferred_constructed_regexps = MultiRegexps::getOrSet</*SaveIndices*/ FindAnyIndex, WithEditDistance>(needles, edit_distance);\n             MultiRegexps::Regexps * regexps = deferred_constructed_regexps->get();\n             hs_scratch_t * scratch = nullptr;\n@@ -309,6 +327,16 @@ struct MultiMatchAnyImpl\n \n             checkHyperscanRegexp(needles, max_hyperscan_regexp_length, max_hyperscan_regexp_total_length);\n \n+            if (reject_expensive_hyperscan_regexps)\n+            {\n+                for (auto needle : needles)\n+                {\n+                    SlowWithHyperscanChecker checker;\n+                    if (checker.isSlow(needle))\n+                        throw Exception(ErrorCodes::HYPERSCAN_CANNOT_SCAN_TEXT, \"Regular expression evaluation in vectorscan will be too slow. To ignore this error, disable setting 'reject_expensive_hyperscan_regexps'.\");\n+                }\n+            }\n+\n             for (size_t j = 0; j < needles.size(); ++j)\n             {\n                 String needle(needles[j]);\ndiff --git a/src/Functions/MultiSearchFirstIndexImpl.h b/src/Functions/MultiSearchFirstIndexImpl.h\nindex f108f2ca41e2..73f3c92adfb1 100644\n--- a/src/Functions/MultiSearchFirstIndexImpl.h\n+++ b/src/Functions/MultiSearchFirstIndexImpl.h\n@@ -32,7 +32,8 @@ struct MultiSearchFirstIndexImpl\n         PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n-        size_t /*max_hyperscan_regexp_total_length*/)\n+        size_t /*max_hyperscan_regexp_total_length*/,\n+        bool /*reject_expensive_hyperscan_regexps*/)\n     {\n         // For performance of Volnitsky search, it is crucial to save only one byte for pattern number.\n         if (needles_arr.size() > std::numeric_limits<UInt8>::max())\n@@ -78,7 +79,8 @@ struct MultiSearchFirstIndexImpl\n         PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n-        size_t /*max_hyperscan_regexp_total_length*/)\n+        size_t /*max_hyperscan_regexp_total_length*/,\n+        bool /*reject_expensive_hyperscan_regexps*/)\n     {\n         const size_t haystack_size = haystack_offsets.size();\n         res.resize(haystack_size);\ndiff --git a/src/Functions/MultiSearchFirstPositionImpl.h b/src/Functions/MultiSearchFirstPositionImpl.h\nindex 69cab478d134..99dd3f9d3940 100644\n--- a/src/Functions/MultiSearchFirstPositionImpl.h\n+++ b/src/Functions/MultiSearchFirstPositionImpl.h\n@@ -32,7 +32,8 @@ struct MultiSearchFirstPositionImpl\n         PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n-        size_t /*max_hyperscan_regexp_total_length*/)\n+        size_t /*max_hyperscan_regexp_total_length*/,\n+        bool /*reject_expensive_hyperscan_regexps*/)\n     {\n         // For performance of Volnitsky search, it is crucial to save only one byte for pattern number.\n         if (needles_arr.size() > std::numeric_limits<UInt8>::max())\n@@ -87,7 +88,8 @@ struct MultiSearchFirstPositionImpl\n         PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n-        size_t /*max_hyperscan_regexp_total_length*/)\n+        size_t /*max_hyperscan_regexp_total_length*/,\n+        bool /*reject_expensive_hyperscan_regexps*/)\n     {\n         const size_t haystack_size = haystack_offsets.size();\n         res.resize(haystack_size);\ndiff --git a/src/Functions/MultiSearchImpl.h b/src/Functions/MultiSearchImpl.h\nindex d42c2ca43e4b..fb7d56f302ab 100644\n--- a/src/Functions/MultiSearchImpl.h\n+++ b/src/Functions/MultiSearchImpl.h\n@@ -32,7 +32,8 @@ struct MultiSearchImpl\n         PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n-        size_t /*max_hyperscan_regexp_total_length*/)\n+        size_t /*max_hyperscan_regexp_total_length*/,\n+        bool /*reject_expensive_hyperscan_regexps*/)\n     {\n         // For performance of Volnitsky search, it is crucial to save only one byte for pattern number.\n         if (needles_arr.size() > std::numeric_limits<UInt8>::max())\n@@ -77,7 +78,8 @@ struct MultiSearchImpl\n         PaddedPODArray<UInt64> & /*offsets*/,\n         bool /*allow_hyperscan*/,\n         size_t /*max_hyperscan_regexp_length*/,\n-        size_t /*max_hyperscan_regexp_total_length*/)\n+        size_t /*max_hyperscan_regexp_total_length*/,\n+        bool /*reject_expensive_hyperscan_regexps*/)\n     {\n         const size_t haystack_size = haystack_offsets.size();\n         res.resize(haystack_size);\ndiff --git a/src/Functions/checkHyperscanRegexp.cpp b/src/Functions/checkHyperscanRegexp.cpp\nindex 4a1bc4f9031e..e6fbc3baa1a7 100644\n--- a/src/Functions/checkHyperscanRegexp.cpp\n+++ b/src/Functions/checkHyperscanRegexp.cpp\n@@ -1,6 +1,7 @@\n #include <Functions/checkHyperscanRegexp.h>\n \n #include <Common/Exception.h>\n+#include <charconv>\n \n namespace DB\n {\n@@ -27,4 +28,78 @@ void checkHyperscanRegexp(const std::vector<std::string_view> & regexps, size_t\n     }\n }\n \n+namespace\n+{\n+\n+bool isLargerThanFifty(std::string_view str)\n+{\n+    int number;\n+    auto [_, ec] = std::from_chars(str.begin(), str.end(), number);\n+    if (ec != std::errc())\n+        return false;\n+    return number > 50;\n+}\n+\n+}\n+\n+/// Check for sub-patterns of the form x{n} or x{n,} can be expensive. Ignore spaces before/after n and m.\n+bool SlowWithHyperscanChecker::isSlowOneRepeat(std::string_view regexp)\n+{\n+    re2_st::StringPiece haystack(regexp.data(), regexp.size());\n+    re2_st::StringPiece matches[2];\n+    size_t start_pos = 0;\n+    while (start_pos < regexp.size())\n+    {\n+        if (searcher_one_repeat.Match(haystack, start_pos, regexp.size(), re2_st::RE2::Anchor::UNANCHORED, matches, 2))\n+        {\n+            const auto & match = matches[0];\n+            start_pos += (matches[0].data() - haystack.data()) + match.length(); // fwd by prefix + match length\n+            const auto & submatch = matches[1];\n+            if (isLargerThanFifty({submatch.data(), submatch.size()}))\n+                return true;\n+        }\n+        else\n+            break;\n+    }\n+    return false;\n+}\n+\n+/// Check if sub-patterns of the form x{n,m} can be expensive. Ignore spaces before/after n and m.\n+bool SlowWithHyperscanChecker::isSlowTwoRepeats(std::string_view regexp)\n+{\n+    re2_st::StringPiece haystack(regexp.data(), regexp.size());\n+    re2_st::StringPiece matches[3];\n+    size_t start_pos = 0;\n+    while (start_pos < regexp.size())\n+    {\n+        if (searcher_two_repeats.Match(haystack, start_pos, regexp.size(), re2_st::RE2::Anchor::UNANCHORED, matches, 3))\n+        {\n+            const auto & match = matches[0];\n+            start_pos += (matches[0].data() - haystack.data()) + match.length(); // fwd by prefix + match length\n+            const auto & submatch1 = matches[1];\n+            const auto & submatch2 = matches[2];\n+            if (isLargerThanFifty({submatch1.data(), submatch1.size()})\n+             || isLargerThanFifty({submatch2.data(), submatch2.size()}))\n+                return true;\n+        }\n+        else\n+            break;\n+    }\n+    return false;\n+}\n+\n+SlowWithHyperscanChecker::SlowWithHyperscanChecker()\n+    : searcher_one_repeat(R\"(\\{\\s*([\\d]+)\\s*,?\\s*})\")\n+    , searcher_two_repeats(R\"(\\{\\s*([\\d]+)\\s*,\\s*([\\d]+)\\s*\\})\")\n+{}\n+\n+bool SlowWithHyperscanChecker::isSlow(std::string_view regexp)\n+{\n+    if (isSlowOneRepeat(regexp))\n+        return true;\n+    else if (isSlowTwoRepeats(regexp))\n+        return true;\n+    return false;\n+}\n+\n }\ndiff --git a/src/Functions/checkHyperscanRegexp.h b/src/Functions/checkHyperscanRegexp.h\nindex e5f1165a949d..8bb76e6ebc44 100644\n--- a/src/Functions/checkHyperscanRegexp.h\n+++ b/src/Functions/checkHyperscanRegexp.h\n@@ -3,9 +3,27 @@\n #include <string_view>\n #include <vector>\n \n+#include <re2_st/re2.h>\n+\n namespace DB\n {\n \n void checkHyperscanRegexp(const std::vector<std::string_view> & regexps, size_t max_hyperscan_regexp_length, size_t max_hyperscan_regexp_total_length);\n \n+/// Regexp evaluation with hyperscan can be slow for certain patterns due to NFA state explosion. Try to identify such patterns on a\n+/// best-effort basis.\n+\n+class SlowWithHyperscanChecker\n+{\n+public:\n+    SlowWithHyperscanChecker();\n+    bool isSlow(std::string_view regexp);\n+\n+private:\n+    bool isSlowOneRepeat(std::string_view regexp);\n+    bool isSlowTwoRepeats(std::string_view regexp);\n+    re2_st::RE2 searcher_one_repeat;\n+    re2_st::RE2 searcher_two_repeats;\n+};\n+\n }\ndiff --git a/src/Functions/extract.cpp b/src/Functions/extract.cpp\nindex 5d539e03daea..74c5a2fdd366 100644\n--- a/src/Functions/extract.cpp\n+++ b/src/Functions/extract.cpp\n@@ -1,6 +1,6 @@\n-#include \"FunctionsStringSearchToString.h\"\n-#include \"FunctionFactory.h\"\n-#include \"Regexps.h\"\n+#include <Functions/FunctionsStringSearchToString.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/Regexps.h>\n #include <Common/OptimizedRegularExpression.h>\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02560_regexp_denial_of_service.reference b/tests/queries/0_stateless/02560_regexp_denial_of_service.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02560_regexp_denial_of_service.sql b/tests/queries/0_stateless/02560_regexp_denial_of_service.sql\nnew file mode 100644\nindex 000000000000..3a02c12c679a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02560_regexp_denial_of_service.sql\n@@ -0,0 +1,58 @@\n+-- Tags: no-fasttest, use-vectorscan\n+\n+DROP TABLE IF EXISTS t;\n+\n+-- test that the check which rejects hyperscan regexes with too big bounded repeats works\n+\n+-- {n}\n+SELECT multiMatchAny('test', ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{   51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51   }']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['prefix.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51}.suffix']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{4,4}midfix{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+-- {n,}\n+SELECT multiMatchAny('test', ['.{51,}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{   51,}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51   ,}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51,   }']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['prefix.{51,}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51,}.suffix']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{4,4}midfix{51,}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+-- {n,m}\n+SELECT multiMatchAny('test', ['.{1,51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51,52}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{   51,52}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51   ,52}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51,   52}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{51,52   }']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['prefix.{1,51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{1,51}.suffix']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny('test', ['.{4,4}midfix{1,51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+-- test that the check is implemented in all functions which use vectorscan\n+\n+CREATE TABLE t(c String) Engine=MergeTree() ORDER BY c;\n+INSERT INTO t VALUES('Hallo Welt');\n+\n+SELECT multiMatchAny('Hallo Welt', ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAny(c, ['.{51}']) FROM t; -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+SELECT multiMatchAnyIndex('Hallo Welt', ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAnyIndex(c, ['.{51}']) FROM t; -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+SELECT multiMatchAllIndices('Hallo Welt', ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiMatchAllIndices(c, ['.{51}']) FROM t; -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+SELECT multiFuzzyMatchAny('Hallo Welt', 1, ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiFuzzyMatchAny(c, 1, ['.{51}']) FROM t; -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+SELECT multiFuzzyMatchAnyIndex('Hallo Welt', 1, ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiFuzzyMatchAnyIndex(c, 1, ['.{51}']) FROM t; -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+SELECT multiFuzzyMatchAllIndices('Hallo Welt', 1, ['.{51}']); -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+SELECT multiFuzzyMatchAllIndices(c, 1, ['.{51}']) FROM t; -- { serverError HYPERSCAN_CANNOT_SCAN_TEXT }\n+\n+DROP TABLE t;\n",
  "problem_statement": "It's too easy to make DoS with Hyperscan\n```\r\nSELECT multiMatchAny('', ['\\b.{100,10000}\\b'])\r\n```\r\n\r\nThis query runs for 97 seconds and cannot be canceled.\r\n\r\nNote: we knew in advance that Hyperscan is vulnerable to DoS, so there is a setting `allow_hyperscan`\r\nTo remediate this, simply turn the setting off.\r\n\r\nBut there are cases when you want to allow user-defined queries with Hyperscan.\r\nSo, we need to add callbacks into Hyperscan to check for max_execution_time.\r\n\n",
  "hints_text": "",
  "created_at": "2023-02-08T14:38:25Z"
}