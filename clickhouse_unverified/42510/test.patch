diff --git a/contrib/googletest-cmake/CMakeLists.txt b/contrib/googletest-cmake/CMakeLists.txt
index 3905df031557..5b00096615a5 100644
--- a/contrib/googletest-cmake/CMakeLists.txt
+++ b/contrib/googletest-cmake/CMakeLists.txt
@@ -14,12 +14,12 @@ add_library(_gtest_all INTERFACE)
 target_link_libraries(_gtest_all INTERFACE _gtest _gtest_main)
 add_library(ch_contrib::gtest_all ALIAS _gtest_all)
 
-
 add_library(_gmock "${SRC_DIR}/googlemock/src/gmock-all.cc")
 set_target_properties(_gmock PROPERTIES VERSION "1.0.0")
 target_compile_definitions (_gmock PUBLIC GTEST_HAS_POSIX_RE=0)
 target_include_directories(_gmock SYSTEM PUBLIC "${SRC_DIR}/googlemock/include" "${SRC_DIR}/googletest/include")
 target_include_directories(_gmock PRIVATE "${SRC_DIR}/googlemock")
+target_link_libraries(_gmock PUBLIC _gtest)
 
 add_library(_gmock_main "${SRC_DIR}/googlemock/src/gmock_main.cc")
 set_target_properties(_gmock_main PROPERTIES VERSION "1.0.0")
diff --git a/src/Parsers/tests/KQL/gtest_KQL_AggregateFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_AggregateFunctions.cpp
new file mode 100644
index 000000000000..f115f5c6b73b
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_AggregateFunctions.cpp
@@ -0,0 +1,73 @@
+#include <Parsers/tests/gtest_common.h>
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Aggregate, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "Customers | summarize t = stdev(Age) by FirstName",
+            "SELECT
    FirstName,
    sqrt(varSamp(Age)) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = stdevif(Age, Age < 10) by FirstName",
+            "SELECT
    FirstName,
    sqrt(varSampIf(Age, Age < 10)) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = binary_all_and(Age) by FirstName",
+            "SELECT
    FirstName,
    groupBitAnd(Age) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = binary_all_or(Age) by FirstName",
+            "SELECT
    FirstName,
    groupBitOr(Age) AS t
FROM Customers
GROUP BY FirstName"
+
+        },
+        {
+            "Customers | summarize t = binary_all_xor(Age) by FirstName",
+            "SELECT
    FirstName,
    groupBitXor(Age) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize percentiles(Age, 30, 40, 50, 60, 70) by FirstName",
+            "SELECT
    FirstName,
    quantiles(30 / 100, 40 / 100, 50 / 100, 60 / 100, 70 / 100)(Age) AS percentiles_Age
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = percentiles_array(Age, 10, 20, 30, 50) by FirstName",
+            "SELECT
    FirstName,
    quantiles(10 / 100, 20 / 100, 30 / 100, 50 / 100)(Age) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = percentiles_array(Age, dynamic([10, 20, 30, 50])) by FirstName",
+            "SELECT
    FirstName,
    quantiles(10 / 100, 20 / 100, 30 / 100, 50 / 100)(Age) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "DataTable | summarize t = percentilesw(Bucket, Frequency, 50, 75, 99.9)",
+            "SELECT quantilesExactWeighted(50 / 100, 75 / 100, 99.9 / 100)(Bucket, Frequency) AS t
FROM DataTable"
+        },
+        {
+            "DataTable| summarize t = percentilesw_array(Bucket, Frequency, dynamic([10, 50, 30]))",
+            "SELECT quantilesExactWeighted(10 / 100, 50 / 100, 30 / 100)(Bucket, Frequency) AS t
FROM DataTable"
+        },
+        {
+            "Customers | summarize t = percentile(Age, 50) by FirstName",
+            "SELECT
    FirstName,
    quantile(50 / 100)(Age) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "DataTable | summarize t = percentilew(Bucket, Frequency, 50)",
+            "SELECT quantileExactWeighted(50 / 100)(Bucket, Frequency) AS t
FROM DataTable"
+        },
+        {
+             "Customers | summarize t = make_list_with_nulls(Age) by FirstName",
+             "SELECT
    FirstName,
    arrayConcat(groupArray(Age), arrayMap(x -> NULL, range(0, toUInt32(count(*) - length(groupArray(Age))), 1))) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize count() by bin(Age, 10)",
+            "SELECT
    toInt64(toFloat64(Age) / 10) * 10 AS Age,
    count() AS count_
FROM Customers
GROUP BY Age"
+        },
+        {
+            "Customers | summarize count(Age+1) by bin(Age+1, 10)",
+            "SELECT
    toInt64(toFloat64(Age + 1) / 10) * 10 AS Columns1,
    count(Age + 1) AS count_
FROM Customers
GROUP BY Columns1"
+        },
+        {
+            "Customers | summarize count(Age) by bin(Age, 10)",
+            "SELECT
    toInt64(toFloat64(Age) / 10) * 10 AS Age,
    count(Age) AS count_Age
FROM Customers
GROUP BY Age"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_Binary.cpp b/src/Parsers/tests/KQL/gtest_KQL_Binary.cpp
new file mode 100644
index 000000000000..72c9c5a67ebd
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_Binary.cpp
@@ -0,0 +1,37 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Binary, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print binary_and(A, B)",
+            "SELECT bitAnd(CAST(A, 'Int64'), CAST(B, 'Int64'))"
+        },
+        {
+            "print binary_not(A)",
+            "SELECT bitNot(CAST(A, 'Int64'))"
+        },
+        {
+            "print binary_or(A, B)",
+            "SELECT bitOr(CAST(A, 'Int64'), CAST(B, 'Int64'))"
+        },
+        {
+            "print binary_shift_left(A, B)",
+            "SELECT if(B < 0, NULL, bitShiftLeft(CAST(A, 'Int64'), B))"
+        },
+        {
+            "print binary_shift_right(A, B)",
+            "SELECT if(B < 0, NULL, bitShiftRight(CAST(A, 'Int64'), B))"
+        },
+        {
+            "print binary_xor(A, B)",
+            "SELECT bitXor(CAST(A, 'Int64'), CAST(B, 'Int64'))"
+        },
+        {
+            "print bitset_count_ones(A)",
+            "SELECT bitCount(A)"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_Conversion.cpp b/src/Parsers/tests/KQL/gtest_KQL_Conversion.cpp
new file mode 100644
index 000000000000..02e454555241
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_Conversion.cpp
@@ -0,0 +1,80 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(
+    ParserKQLQuery_Conversion,
+    ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print tobool(A)",
+            "SELECT multiIf(toString(A) = 'true', true, toString(A) = 'false', false, toInt64OrNull(toString(A)) != 0)"
+        },
+        {
+            "print toboolean(A)",
+            "SELECT multiIf(toString(A) = 'true', true, toString(A) = 'false', false, toInt64OrNull(toString(A)) != 0)"
+        },
+        {
+            "print todouble(A)",
+            "SELECT toFloat64OrNull(toString(A))"
+        },
+        {
+            "print toint(A)",
+            "SELECT toInt32OrNull(toString(A))"
+        },
+        {
+            "print tolong(A)",
+            "SELECT toInt64OrNull(toString(A))"
+        },
+        {
+            "print toreal(A)",
+            "SELECT toFloat64OrNull(toString(A))"
+        },
+        {
+            "print tostring(A)",
+            "SELECT ifNull(toString(A), '')"
+        },
+        {
+            "print decimal(123.345)",
+            "SELECT toDecimal128(CAST('123.345', 'String'), 32)"
+        },
+        {
+            "print decimal(NULL)",
+            "SELECT NULL"
+        },
+        {
+            "print todecimal('123.45')",
+            "SELECT toDecimal128(CAST('123.45', 'String'), 32)"
+        },
+        {
+            "print todecimal(NULL)",
+            "SELECT NULL"
+        },
+        {
+            "print todecimal(123456.3456)",
+            "SELECT toDecimal128(CAST('123456.3456', 'String'), 12)"
+        },
+        {
+            "print todecimal('abc')",
+            "SELECT NULL"
+        },
+        {
+            "print todecimal('1e5')",
+            "SELECT toDecimal128(CAST('1e5', 'String'), 5)"
+        },
+        {
+            "print decimal(1e-5)",
+            "SELECT toDecimal128(CAST('1e-5', 'String'), 5)"
+        },
+        {
+            "print time(9nanoseconds)",
+            "SELECT CAST('9e-09', 'Float64')"
+        },
+        {
+            "print time(1tick)",
+            "SELECT CAST('1e-07', 'Float64')"
+        }
+
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_DataType.cpp b/src/Parsers/tests/KQL/gtest_KQL_DataType.cpp
new file mode 100644
index 000000000000..ed77bbbada7b
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_DataType.cpp
@@ -0,0 +1,65 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_DataType, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print dynamic(null)",
+            "SELECT NULL"
+        },
+        {
+            "print dynamic(1)",
+            "SELECT 1"
+        },
+        {
+            "print dynamic(datetime(1))",
+            "SELECT parseDateTime64BestEffortOrNull('1', 9, 'UTC')"
+        },
+        {
+            "print dynamic(timespan(1d))",
+            "SELECT CAST('86400', 'Float64')"
+        },
+        {
+            "print dynamic(parse_ipv4('127.0.0.1'))",
+            "throws"
+        },
+        {
+            "print dynamic({ \"a\": 9 })",
+            "throws"
+        },
+        {
+            "print dynamic([1, 2, 3])",
+            "SELECT [1, 2, 3]"
+        },
+        {
+            "print dynamic([1, dynamic([2]), 3])",
+            "SELECT [1, [2], 3]"
+        },
+        {
+            "print dynamic([[1], [2], [3]])",
+            "SELECT [[1], [2], [3]]"
+        },
+        {
+            "print dynamic(['a', \"b\", 'c'])",
+            "SELECT ['a', 'b', 'c']"
+        },
+        {
+            "print dynamic([1, 'a', true, false])",
+            "SELECT [1, 'a', true, false]"
+        },
+        {
+            "print dynamic([date(1), time(1d), 1, 2])",
+            "SELECT [parseDateTime64BestEffortOrNull('1', 9, 'UTC'), CAST('86400', 'Float64'), 1, 2]"
+        },
+        {
+            "print time('13:00:40.00000')",
+            "SELECT CAST('46840', 'Float64')"
+        },
+        {
+            "print timespan('12.23:12:23');",
+            "SELECT CAST('1120343', 'Float64')"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_Distinct.cpp b/src/Parsers/tests/KQL/gtest_KQL_Distinct.cpp
new file mode 100644
index 000000000000..12e8065328a0
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_Distinct.cpp
@@ -0,0 +1,29 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Distinct, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "Customers | distinct *",
+            "SELECT DISTINCT *
FROM Customers"
+        },
+        {
+            "Customers | distinct Occupation",
+            "SELECT DISTINCT Occupation
FROM Customers"
+        },
+        {
+            "Customers | distinct Occupation, Education",
+            "SELECT DISTINCT
    Occupation,
    Education
FROM Customers"
+        },
+        {
+            "Customers |where Age <30| distinct Occupation, Education",
+            "SELECT DISTINCT
    Occupation,
    Education
FROM Customers
WHERE Age < 30"
+        },
+        {
+            "Customers |where Age <30 | order by Age| distinct Occupation, Education",
+            "SELECT DISTINCT
    Occupation,
    Education
FROM Customers
WHERE Age < 30
ORDER BY Age DESC"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_Dynamic.cpp b/src/Parsers/tests/KQL/gtest_KQL_Dynamic.cpp
new file mode 100644
index 000000000000..ab60223daf66
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_Dynamic.cpp
@@ -0,0 +1,139 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_DynamicExactMatch, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print array_concat(A, B)",
+            "SELECT arrayConcat(A, B)"
+        },
+        {
+            "print array_concat(A, B, C, D)",
+            "SELECT arrayConcat(A, B, C, D)"
+        },
+        {
+            "print array_iff(A, B, C)",
+            "SELECT arrayMap(x -> multiIf(toTypeName(x.1) = 'String', NULL, toInt64(x.1) != 0, x.2, x.3), arrayZip(A, arrayResize(B, length(A), NULL), arrayResize(C, length(A), NULL)))"
+        },
+        {
+            "print array_iif(A, B, C)",
+            "SELECT arrayMap(x -> multiIf(toTypeName(x.1) = 'String', NULL, toInt64(x.1) != 0, x.2, x.3), arrayZip(A, arrayResize(B, length(A), NULL), arrayResize(C, length(A), NULL)))"
+        },
+        {
+            "print output = array_index_of(dynamic([1, 2, 3]), 2)",
+            "SELECT indexOf([1, 2, 3], 2) - 1 AS output"
+        },
+        {
+            "print output = array_index_of(dynamic(['a', 'b', 'c']), 'b')",
+            "SELECT indexOf(['a', 'b', 'c'], 'b') - 1 AS output"
+        },
+        {
+            "print output = array_index_of(dynamic(['John', 'Denver', 'Bob', 'Marley']), 'Marley')",
+            "SELECT indexOf(['John', 'Denver', 'Bob', 'Marley'], 'Marley') - 1 AS output"
+        },
+        {
+            "print output = array_length(dynamic([1, 2, 3]))",
+            "SELECT length([1, 2, 3]) AS output"
+        },
+        {
+            "print output = array_length(dynamic(['John', 'Denver', 'Bob', 'Marley']))",
+            "SELECT length(['John', 'Denver', 'Bob', 'Marley']) AS output"
+        },
+        {
+            "print array_reverse(A)",
+            "SELECT if(throwIf(NOT startsWith(toTypeName(A), 'Array'), 'Only arrays are supported'), [], reverse(A))"
+        },
+        {
+            "print array_rotate_left(A, B)",
+            "SELECT arrayMap(x -> (A[moduloOrZero((x + length(A)) + moduloOrZero(B, toInt64(length(A))), length(A)) + 1]), range(0, length(A)))"
+        },
+        {
+            "print array_rotate_right(A, B)",
+            "SELECT arrayMap(x -> (A[moduloOrZero((x + length(A)) + moduloOrZero(-1 * B, toInt64(length(A))), length(A)) + 1]), range(0, length(A)))"
+        },
+        {
+            "print output = array_sum(dynamic([2, 5, 3]))",
+            "SELECT arraySum([2, 5, 3]) AS output"
+        },
+        {
+            "print output = array_sum(dynamic([2.5, 5.5, 3]))",
+            "SELECT arraySum([2.5, 5.5, 3]) AS output"
+        },
+        {
+            "print jaccard_index(A, B)",
+            "SELECT length(arrayIntersect(A, B)) / length(arrayDistinct(arrayConcat(A, B)))"
+        },
+        {
+            "print pack_array(A, B, C, D)",
+            "SELECT [A, B, C, D]"
+        },
+        {
+            "print set_difference(A, B)",
+            "SELECT arrayFilter(x -> (NOT has(arrayDistinct(arrayConcat(B)), x)), arrayDistinct(A))"
+        },
+        {
+            "print set_difference(A, B, C)",
+            "SELECT arrayFilter(x -> (NOT has(arrayDistinct(arrayConcat(B, C)), x)), arrayDistinct(A))"
+        },
+        {
+            "print set_has_element(A, B)",
+            "SELECT has(A, B)"
+        },
+        {
+            "print set_intersect(A, B)",
+            "SELECT arrayIntersect(A, B)"
+        },
+        {
+            "print set_intersect(A, B, C)",
+            "SELECT arrayIntersect(A, B, C)"
+        },
+        {
+            "print set_union(A, B)",
+            "SELECT arrayDistinct(arrayConcat(A, B))"
+        },
+        {
+            "print set_union(A, B, C)",
+            "SELECT arrayDistinct(arrayConcat(A, B, C))"
+        }
+})));
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_DynamicRegex, ParserRegexTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print array_shift_left(A, B)",
+            R"(SELECT arrayResize\(if\(B > 0, arraySlice\(A, B \+ 1\), arrayConcat\(arrayWithConstant\(abs\(B\), fill_value_\d+\), A\)\), length\(A\), if\(\(NULL IS NULL\) AND \(\(extract\(toTypeName\(A\), 'Array\\\\\(\(\.\*\)\\\\\)*'\) AS element_type_\d+\) = 'String'\), defaultValueOfTypeName\(if\(element_type_\d+ = 'Nothing', 'Nullable\(Nothing\)', element_type_\d+\)\), NULL\) AS fill_value_\d+\))"
+        },
+        {
+            "print array_shift_left(A, B, C)",
+            R"(SELECT arrayResize\(if\(B > 0, arraySlice\(A, B \+ 1\), arrayConcat\(arrayWithConstant\(abs\(B\), fill_value_\d+\), A\)\), length\(A\), if\(\(C IS NULL\) AND \(\(extract\(toTypeName\(A\), 'Array\\\\\(\(\.\*\)\\\\\)'\) AS element_type_\d+\) = 'String'\), defaultValueOfTypeName\(if\(element_type_\d+ = 'Nothing', 'Nullable\(Nothing\)', element_type_\d+\)\), C\) AS fill_value_\d+\))"
+        },
+        {
+            "print array_shift_right(A, B)",
+            R"(SELECT arrayResize\(if\(\(-1 \* B\) > 0, arraySlice\(A, \(-1 \* B\) \+ 1\), arrayConcat\(arrayWithConstant\(abs\(-1 \* B\), fill_value_\d+\), A\)\), length\(A\), if\(\(NULL IS NULL\) AND \(\(extract\(toTypeName\(A\), 'Array\\\\\(\(\.\*\)\\\\\)'\) AS element_type_\d+\) = 'String'\), defaultValueOfTypeName\(if\(element_type_\d+ = 'Nothing', 'Nullable\(Nothing\)', element_type_\d+\)\), NULL\) AS fill_value_\d+\))"
+        },
+        {
+            "print array_shift_right(A, B, C)",
+            R"(SELECT arrayResize\(if\(\(-1 \* B\) > 0, arraySlice\(A, \(-1 \* B\) \+ 1\), arrayConcat\(arrayWithConstant\(abs\(-1 \* B\), fill_value_\d+\), A\)\), length\(A\), if\(\(C IS NULL\) AND \(\(extract\(toTypeName\(A\), 'Array\\\\\(\(\.\*\)\\\\\)'\) AS element_type_\d+\) = 'String'\), defaultValueOfTypeName\(if\(element_type_\d+ = 'Nothing', 'Nullable\(Nothing\)', element_type_\d+\)\), C\) AS fill_value_\d+\))"
+        },
+        {
+            "print array_slice(A, B, C)",
+            R"(SELECT arraySlice\(A, 1 \+ if\(B >= 0, B, arrayMax\(\[-length\(A\), B\]\) \+ length\(A\)\) AS offset_\d+, \(\(1 \+ if\(C >= 0, C, arrayMax\(\[-length\(A\), C\]\) \+ length\(A\)\)\) - offset_\d+\) \+ 1\))"
+        },
+        {
+            "print array_split(A, B)",
+            R"(SELECT if\(empty\(arrayMap\(x -> if\(x >= 0, x, arrayMax\(\[0, x \+ CAST\(length\(A\), 'Int\d+'\)\]\)\), flatten\(\[B\]\)\) AS indices_\d+\), \[A\], arrayConcat\(\[arraySlice\(A, 1, indices_\d+\[1\]\)\], arrayMap\(i -> arraySlice\(A, \(indices_\d+\[i\]\) \+ 1, if\(i = length\(indices_\d+\), CAST\(length\(A\), 'Int\d+'\), CAST\(indices_\d+\[i \+ 1\], 'Int\d+'\)\) - \(indices_\d+\[i\]\)\), range\(1, length\(indices_\d+\) \+ 1\)\)\)\))"
+        },
+        {
+            "print zip(A, B)",
+            R"(SELECT arrayMap\(t -> \[untuple\(t\)\], arrayZip\(arrayResize\(arg0_\d+, arrayMax\(\[length\(if\(match\(toTypeName\(A\), 'Array\\\\\(Nullable\\\\\(\.\*\\\\\)\\\\\)'\), A, CAST\(A, concat\('Array\(Nullable\(', extract\(toTypeName\(A\), 'Array\\\\\(\(\.\*\)\\\\\)'\), '\)\)'\)\)\) AS arg0_\d+\), length\(if\(match\(toTypeName\(B\), 'Array\\\\\(Nullable\\\\\(\.\*\\\\\)\\\\\)'\), B, CAST\(B, concat\('Array\(Nullable\(', extract\(toTypeName\(B\), 'Array\\\\\(\(\.\*\)\\\\\)'\), '\)\)'\)\)\) AS arg1_\d+\)\]\) AS max_length_\d+, NULL\), arrayResize\(arg1_\d+, max_length_\d+, NULL\)\)\))"
+        },
+        {
+            "print zip(A, B, C)",
+            R"(SELECT arrayMap\(t -> \[untuple\(t\)\], arrayZip\(arrayResize\(arg0_\d+, arrayMax\(\[length\(if\(match\(toTypeName\(A\), 'Array\\\\\(Nullable\\\\\(\.\*\\\\\)\\\\\)'\), A, CAST\(A, concat\('Array\(Nullable\(', extract\(toTypeName\(A\), 'Array\\\\\(\(\.\*\)\\\\\)'\), '\)\)'\)\)\) AS arg0_\d+\), length\(if\(match\(toTypeName\(B\), 'Array\\\\\(Nullable\\\\\(\.\*\\\\\)\\\\\)'\), B, CAST\(B, concat\('Array\(Nullable\(', extract\(toTypeName\(B\), 'Array\\\\\(\(\.\*\)\\\\\)'\), '\)\)'\)\)\) AS arg1_\d+\), length\(if\(match\(toTypeName\(C\), 'Array\\\\\(Nullable\\\\\(\.\*\\\\\)\\\\\)'\), C, CAST\(C, concat\('Array\(Nullable\(', extract\(toTypeName\(C\), 'Array\\\\\(\(\.\*\)\\\\\)'\), '\)\)'\)\)\) AS arg2_\d+\)\]\) AS max_length_\d+, NULL\), arrayResize\(arg1_\d+, max_length_\d+, NULL\), arrayResize\(arg2_\d+, max_length_\d+, NULL\)\)\))"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_IP.cpp b/src/Parsers/tests/KQL/gtest_KQL_IP.cpp
new file mode 100644
index 000000000000..5cc08ee89b49
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_IP.cpp
@@ -0,0 +1,85 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_IP, ParserRegexTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print format_ipv4(A)",
+            R"(SELECT ifNull\(if\(\(\(\(toUInt32OrNull\(toString\(A\)\) AS param_as_uint32_\d+\) IS NOT NULL\) AND \(toTypeName\(A\) = 'String'\)\) OR \(32 < 0\) OR \(\(ifNull\(param_as_uint32_\d+, multiIf\(length\(splitByChar\('/', ifNull\(toString\(A\), ''\)\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\).1\)\), NULL\)\) AS ip_as_number_\d+\) IS NULL\), NULL, IPv4NumToString\(bitAnd\(ip_as_number_\d+, bitNot\(toUInt32\(intExp2\(toInt32\(32 - 32\)\) - 1\)\)\)\)\), ''\))"
+        },
+        {
+            "print format_ipv4(A, B)",
+            R"(SELECT ifNull\(if\(\(\(\(toUInt32OrNull\(toString\(A\)\) AS param_as_uint32_\d+\) IS NOT NULL\) AND \(toTypeName\(A\) = 'String'\)\) OR \(B < 0\) OR \(\(ifNull\(param_as_uint32_\d+, multiIf\(length\(splitByChar\('/', ifNull\(toString\(A\), ''\)\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\).1\)\), NULL\)\) AS ip_as_number_\d+\) IS NULL\), NULL, IPv4NumToString\(bitAnd\(ip_as_number_\d+, bitNot\(toUInt32\(intExp2\(toInt32\(32 - B\)\) - 1\)\)\)\)\), ''\))"
+        },
+        {
+            "print format_ipv4_mask(A)",
+            R"(SELECT if\(empty\(ifNull\(if\(\(\(\(toUInt32OrNull\(toString\(A\)\) AS param_as_uint32_\d+\) IS NOT NULL\) AND \(toTypeName\(A\) = 'String'\)\) OR \(32 < 0\) OR \(\(ifNull\(param_as_uint32_\d+, multiIf\(length\(splitByChar\('/', ifNull\(toString\(A\), ''\)\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\).1\)\), NULL\)\) AS ip_as_number_\d+\) IS NULL\), NULL, IPv4NumToString\(bitAnd\(ip_as_number_\d+, bitNot\(toUInt32\(intExp2\(toInt32\(32 - 32\)\) - 1\)\)\)\)\), ''\) AS formatted_ip_\d+\) OR \(position\(toTypeName\(32\), 'Int'\) = 0\) OR \(NOT \(\(32 >= 0\) AND \(32 <= 32\)\)\), '', concat\(formatted_ip_\d+, '/', toString\(toInt64\(min2\(32, ifNull\(multiIf\(\(length\(splitByChar\('/', ifNull\(toString\(A\), ''\)\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\) AS suffix_\d+, 32\)\)\)\)\)\))"
+        },
+        {
+            "print format_ipv4_mask(A, B)",
+            R"(SELECT if\(empty\(ifNull\(if\(\(\(\(toUInt\d+OrNull\(toString\(A\)\) AS param_as_uint\d+_\d+\) IS NOT NULL\) AND \(toTypeName\(A\) = 'String'\)\) OR \(B < 0\) OR \(\(ifNull\(param_as_uint\d+_\d+, multiIf\(length\(splitByChar\('/', ifNull\(toString\(A\), ''\)\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\)\) AS ip_as_number_\d+\) IS NULL\), NULL, IPv4NumToString\(bitAnd\(ip_as_number_\d+, bitNot\(toUInt\d+\(intExp2\(toInt32\(\d+ - B\)\) - 1\)\)\)\)\), ''\) AS formatted_ip_\d+\) OR \(position\(toTypeName\(B\), 'Int'\) = 0\) OR \(NOT \(\(B >= 0\) AND \(B <= \d+\)\)\), '', concat\(formatted_ip_\d+, '/', toString\(toInt\d+\(min2\(B, ifNull\(multiIf\(\(length\(splitByChar\('/', ifNull\(toString\(A\), ''\)\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, \d+, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, \d+\)\)\) AS suffix_\d+, \d+\)\)\)\)\)\))"
+        },
+        {
+            "print ipv4_compare(A, B)",
+            R"(SELECT if\(\(\(multiIf\(length\(splitByChar\('/', A\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS lhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', A\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, \d+, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, \d+\)\)\) AS lhs_mask_\d+\) IS NULL\) OR \(\(multiIf\(length\(splitByChar\('/', B\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS rhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', B\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, \d+, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, \d+\)\)\) AS rhs_mask_\d+\) IS NULL\), NULL, sign\(IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(lhs_ip_\d+\), toUInt8\(min2\(\d+, min2\(assumeNotNull\(lhs_mask_\d+\), assumeNotNull\(rhs_mask_\d+\)\)\)\) AS mask_\d+\)\.1\)\) - IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(rhs_ip_\d+\), mask_\d+\)\.1\)\)\)\))"
+        },
+        {
+            "print ipv4_compare(A, B, C)",
+            R"(SELECT if\(\(\(multiIf\(length\(splitByChar\('/', A\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS lhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', A\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, \d+, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, \d+\)\)\) AS lhs_mask_\d+\) IS NULL\) OR \(\(multiIf\(length\(splitByChar\('/', B\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS rhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', B\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, \d+, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, \d+\)\)\) AS rhs_mask_\d+\) IS NULL\), NULL, sign\(IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(lhs_ip_\d+\), toUInt8\(min2\(C, min2\(assumeNotNull\(lhs_mask_\d+\), assumeNotNull\(rhs_mask_\d+\)\)\)\) AS mask_\d+\)\.1\)\) - IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(rhs_ip_\d+\), mask_\d+\)\.1\)\)\)\))"
+        },
+        {
+            "print ipv6_compare(A, B)",
+            R"(SELECT if\(\(length\(splitByChar\('/', A\) AS lhs_tokens_\d+\) > 2\) OR \(length\(splitByChar\('/', B\) AS rhs_tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(lhs_tokens_\d+\[1\]\) AS lhs_ipv6_\d+\) IS NULL\) OR \(\(length\(lhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(lhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(lhs_tokens_\d+\[-1\]\)\) AS lhs_suffix_\d+\) IS NULL\)\) OR \(\(IPv6StringToNumOrNull\(rhs_tokens_\d+\[1\]\) AS rhs_ipv6_\d+\) IS NULL\) OR \(\(length\(rhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(rhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(rhs_tokens_\d+\[-1\]\)\) AS rhs_suffix_\d+\) IS NULL\)\) OR \(\(toUInt8\(min2\(128, min2\(ifNull\(lhs_suffix_\d+, 128\), ifNull\(rhs_suffix_\d+, 128\)\)\)\) AS suffix_\d+\) IS NULL\) OR \(\(bitShiftLeft\(bitShiftRight\(bitNot\(reinterpretAsFixedString\(CAST\('0', 'UInt128'\)\)\), 128 - suffix_\d+ AS zeroes_\d+\), zeroes_\d+\) AS mask_\d+\) IS NULL\) OR \(\(bitAnd\(lhs_ipv6_\d+, mask_\d+\) AS lhs_base_\d+\) IS NULL\) OR \(\(bitAnd\(rhs_ipv6_\d+, mask_\d+\) AS rhs_base_\d+\) IS NULL\), NULL, multiIf\(lhs_base_\d+ < rhs_base_\d+, -1, lhs_base_\d+ > rhs_base_\d+, 1, 0\)\))"
+        },
+        {
+            "print ipv6_compare(A, B, C)",
+            R"(SELECT if\(\(length\(splitByChar\('/', A\) AS lhs_tokens_\d+\) > 2\) OR \(length\(splitByChar\('/', B\) AS rhs_tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(lhs_tokens_\d+\[1\]\) AS lhs_ipv6_\d+\) IS NULL\) OR \(\(length\(lhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(lhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(lhs_tokens_\d+\[-1\]\)\) AS lhs_suffix_\d+\) IS NULL\)\) OR \(\(IPv6StringToNumOrNull\(rhs_tokens_\d+\[1\]\) AS rhs_ipv6_\d+\) IS NULL\) OR \(\(length\(rhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(rhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(rhs_tokens_\d+\[-1\]\)\) AS rhs_suffix_\d+\) IS NULL\)\) OR \(\(toUInt8\(min2\(C, min2\(ifNull\(lhs_suffix_\d+, 128\), ifNull\(rhs_suffix_\d+, 128\)\)\)\) AS suffix_\d+\) IS NULL\) OR \(\(bitShiftLeft\(bitShiftRight\(bitNot\(reinterpretAsFixedString\(CAST\('0', 'UInt128'\)\)\), 128 - suffix_\d+ AS zeroes_\d+\), zeroes_\d+\) AS mask_\d+\) IS NULL\) OR \(\(bitAnd\(lhs_ipv6_\d+, mask_\d+\) AS lhs_base_\d+\) IS NULL\) OR \(\(bitAnd\(rhs_ipv6_\d+, mask_\d+\) AS rhs_base_\d+\) IS NULL\), NULL, multiIf\(lhs_base_\d+ < rhs_base_\d+, -1, lhs_base_\d+ > rhs_base_\d+, 1, 0\)\))"
+        },
+        {
+            "print ipv4_is_in_range(A, B)",
+            R"(SELECT if\(\(\(IPv4StringToNumOrNull\(A\) AS ip_\d+\) IS NULL\) OR \(\(multiIf\(length\(splitByChar\('/', B\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS range_start_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', B\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\) AS range_mask_\d+\) IS NULL\), NULL, bitXor\(range_start_ip_\d+, bitAnd\(ip_\d+, bitNot\(toUInt32\(intExp2\(toInt32\(32 - range_mask_\d+\)\) - 1\)\)\)\) = 0\))"
+        },
+        {
+            "print ipv4_is_match(A, B)",
+            R"(SELECT if\(\(\(multiIf\(length\(splitByChar\('/', A\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS lhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', A\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\) AS lhs_mask_\d+\) IS NULL\) OR \(\(multiIf\(length\(splitByChar\('/', B\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS rhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', B\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\) AS rhs_mask_\d+\) IS NULL\), NULL, sign\(IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(lhs_ip_\d+\), toUInt8\(min2\(32, min2\(assumeNotNull\(lhs_mask_\d+\), assumeNotNull\(rhs_mask_\d+\)\)\)\) AS mask_\d+\)\.1\)\) - IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(rhs_ip_\d+\), mask_\d+\)\.1\)\)\)\) = 0)"
+        },
+        {
+            "print ipv4_is_match(A, B, C)",
+            R"(SELECT if\(\(\(multiIf\(length\(splitByChar\('/', A\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS lhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', A\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\) AS lhs_mask_\d+\) IS NULL\) OR \(\(multiIf\(length\(splitByChar\('/', B\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\) AS rhs_ip_\d+\) IS NULL\) OR \(\(multiIf\(\(length\(splitByChar\('/', B\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\) AS rhs_mask_\d+\) IS NULL\), NULL, sign\(IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(lhs_ip_\d+\), toUInt8\(min2\(C, min2\(assumeNotNull\(lhs_mask_\d+\), assumeNotNull\(rhs_mask_\d+\)\)\)\) AS mask_\d+\)\.1\)\) - IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(assumeNotNull\(rhs_ip_\d+\), mask_\d+\)\.1\)\)\)\) = 0)"
+        },
+        {
+            "print ipv6_is_match(A, B)",
+            R"(SELECT if\(\(length\(splitByChar\('/', A\) AS lhs_tokens_\d+\) > 2\) OR \(length\(splitByChar\('/', B\) AS rhs_tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(lhs_tokens_\d+\[1\]\) AS lhs_ipv6_\d+\) IS NULL\) OR \(\(length\(lhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(lhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(lhs_tokens_\d+\[-1\]\)\) AS lhs_suffix_\d+\) IS NULL\)\) OR \(\(IPv6StringToNumOrNull\(rhs_tokens_\d+\[1\]\) AS rhs_ipv6_\d+\) IS NULL\) OR \(\(length\(rhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(rhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(rhs_tokens_\d+\[-1\]\)\) AS rhs_suffix_\d+\) IS NULL\)\) OR \(\(toUInt8\(min2\(128, min2\(ifNull\(lhs_suffix_\d+, 128\), ifNull\(rhs_suffix_\d+, 128\)\)\)\) AS suffix_\d+\) IS NULL\) OR \(\(bitShiftLeft\(bitShiftRight\(bitNot\(reinterpretAsFixedString\(CAST\('0', 'UInt128'\)\)\), 128 - suffix_\d+ AS zeroes_\d+\), zeroes_\d+\) AS mask_\d+\) IS NULL\) OR \(\(bitAnd\(lhs_ipv6_\d+, mask_\d+\) AS lhs_base_\d+\) IS NULL\) OR \(\(bitAnd\(rhs_ipv6_\d+, mask_\d+\) AS rhs_base_\d+\) IS NULL\), NULL, multiIf\(lhs_base_\d+ < rhs_base_\d+, -1, lhs_base_\d+ > rhs_base_\d+, 1, 0\)\) = 0)"
+        },
+        {
+            "print ipv6_is_match(A, B, C)",
+            R"(SELECT if\(\(length\(splitByChar\('/', A\) AS lhs_tokens_\d+\) > 2\) OR \(length\(splitByChar\('/', B\) AS rhs_tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(lhs_tokens_\d+\[1\]\) AS lhs_ipv6_\d+\) IS NULL\) OR \(\(length\(lhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(lhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(lhs_tokens_\d+\[-1\]\)\) AS lhs_suffix_\d+\) IS NULL\)\) OR \(\(IPv6StringToNumOrNull\(rhs_tokens_\d+\[1\]\) AS rhs_ipv6_\d+\) IS NULL\) OR \(\(length\(rhs_tokens_\d+\) = 2\) AND \(\(\(if\(isIPv4String\(rhs_tokens_\d+\[1\]\), 96, 0\) \+ toUInt8OrNull\(rhs_tokens_\d+\[-1\]\)\) AS rhs_suffix_\d+\) IS NULL\)\) OR \(\(toUInt8\(min2\(C, min2\(ifNull\(lhs_suffix_\d+, 128\), ifNull\(rhs_suffix_\d+, 128\)\)\)\) AS suffix_\d+\) IS NULL\) OR \(\(bitShiftLeft\(bitShiftRight\(bitNot\(reinterpretAsFixedString\(CAST\('0', 'UInt128'\)\)\), 128 - suffix_\d+ AS zeroes_\d+\), zeroes_\d+\) AS mask_\d+\) IS NULL\) OR \(\(bitAnd\(lhs_ipv6_\d+, mask_\d+\) AS lhs_base_\d+\) IS NULL\) OR \(\(bitAnd\(rhs_ipv6_\d+, mask_\d+\) AS rhs_base_\d+\) IS NULL\), NULL, multiIf\(lhs_base_\d+ < rhs_base_\d+, -1, lhs_base_\d+ > rhs_base_\d+, 1, 0\)\) = 0)"
+        },
+        {
+            "print ipv4_is_private(A)",
+            R"(SELECT multiIf\(\(length\(splitByChar\('/', A\) AS tokens_\d+\) > 2\) OR \(\(toIPv4OrNull\(tokens_\d+\[1\]\) AS nullable_ip_\d+\) IS NULL\) OR \(\(length\(tokens_\d+\) = 2\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL\)\), NULL, ignore\(assumeNotNull\(nullable_ip_\d+\) AS ip_\d+, IPv4CIDRToRange\(ip_\d+, assumeNotNull\(mask_\d+\)\) AS range_\d+, IPv4NumToString\(range_\d+.1\) AS begin_\d+, IPv4NumToString\(range_\d+.2\) AS end_\d+\), NULL, \(\(length\(tokens_\d+\) = 1\) AND isIPAddressInRange\(IPv4NumToString\(ip_\d+\), '10.0.0.0/8'\)\) OR \(\(length\(tokens_\d+\) = 2\) AND isIPAddressInRange\(begin_\d+, '10.0.0.0/8'\) AND isIPAddressInRange\(end_\d+, '10.0.0.0/8'\)\) OR \(\(length\(tokens_\d+\) = 1\) AND isIPAddressInRange\(IPv4NumToString\(ip_\d+\), '172.16.0.0/12'\)\) OR \(\(length\(tokens_\d+\) = 2\) AND isIPAddressInRange\(begin_\d+, '172.16.0.0/12'\) AND isIPAddressInRange\(end_\d+, '172.16.0.0/12'\)\) OR \(\(length\(tokens_\d+\) = 1\) AND isIPAddressInRange\(IPv4NumToString\(ip_\d+\), '192.168.0.0/16'\)\) OR \(\(length\(tokens_\d+\) = 2\) AND isIPAddressInRange\(begin_\d+, '192.168.0.0/16'\) AND isIPAddressInRange\(end_\d+, '192.168.0.0/16'\)\)\))"
+        },
+        {
+            "print ipv4_netmask_suffix(A)",
+            R"(SELECT multiIf\(\(length\(splitByChar\('/', A\) AS tokens_\d+\) > 2\) OR \(NOT isIPv4String\(tokens_\d+\[1\]\)\), NULL, length\(tokens_\d+\) = 1, 32, \(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL, NULL, toUInt8\(min2\(mask_\d+, 32\)\)\))"
+        },
+        {
+            "print parse_ipv4(A)",
+            R"(SELECT multiIf\(length\(splitByChar\('/', A\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\))"
+        },
+        {
+            "print parse_ipv4_mask(A, B)",
+            R"(SELECT if\(\(\(toIPv4OrNull\(A\) AS ip_\d+\) IS NULL\) OR \(\(toUInt8OrNull\(toString\(B\)\) AS mask_\d+\) IS NULL\), NULL, toUInt32\(IPv4CIDRToRange\(assumeNotNull\(ip_\d+\), arrayMax\(\[0, arrayMin\(\[32, assumeNotNull\(mask_\d+\)\]\)\]\)\).1\)\))"
+        },
+        {
+            "print parse_ipv6(A)",
+            R"(SELECT if\(\(length\(splitByChar\('/', assumeNotNull\(A\)\) AS tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+\) IS NULL\) OR \(\(length\(tokens_\d+\) = 2\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL\)\), NULL, arrayStringConcat\(flatten\(extractAllGroups\(lower\(hex\(IPv6CIDRToRange\(assumeNotNull\(ip_\d+\), toUInt8\(ifNull\(mask_\d+ \+ if\(isIPv4String\(tokens_\d+\[1\]\), 96, 0\), 128\)\)\)\.1\)\), '\(\[\\\\da-f\]\{4\}\)'\)\), ':'\)\))"
+        },
+        {
+            "print parse_ipv6_mask(A, B)",
+            R"(SELECT if\(empty\(ifNull\(if\(\(\(\(toUInt32OrNull\(toString\(replaceRegexpOne\(A, concat\('\^', '::'\), ''\)\)\) AS param_as_uint32_\d+\) IS NOT NULL\) AND \(toTypeName\(replaceRegexpOne\(A, concat\('\^', '::'\), ''\)\) = 'String'\)\) OR \(\(B - 96\) < 0\) OR \(\(ifNull\(param_as_uint32_\d+, multiIf\(length\(splitByChar\('/', ifNull\(toString\(replaceRegexpOne\(A, concat\('\^', '::'\), ''\)\), ''\)\) AS tokens_\d+\) = 1, IPv4StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+, \(length\(tokens_\d+\) = 2\) AND \(ip_\d+ IS NOT NULL\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NOT NULL\), IPv4StringToNumOrNull\(toString\(IPv4CIDRToRange\(toIPv4\(assumeNotNull\(ip_\d+\)\), assumeNotNull\(mask_\d+\)\)\.1\)\), NULL\)\) AS ip_as_number_\d+\) IS NULL\), NULL, IPv4NumToString\(bitAnd\(ip_as_number_\d+, bitNot\(toUInt32\(intExp2\(toInt32\(32 - \(B - 96\)\)\) - 1\)\)\)\)\), ''\) AS ipv4_\d+\), if\(\(length\(splitByChar\('/', assumeNotNull\(concat\(ifNull\(toString\(if\(\(length\(splitByChar\('/', assumeNotNull\(A\)\) AS tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+\) IS NULL\) OR \(\(length\(tokens_\d+\) = 2\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL\)\), NULL, arrayStringConcat\(flatten\(extractAllGroups\(lower\(hex\(IPv6CIDRToRange\(assumeNotNull\(ip_\d+\), toUInt8\(ifNull\(mask_\d+ \+ if\(isIPv4String\(tokens_\d+\[1\]\), 96, 0\), 128\)\)\)\.1\)\), '\(\[\\\\da-f\]\{4\}\)'\)\), ':'\)\)\), ''\), '/', ifNull\(toString\(B\), ''\)\)\)\) AS tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+\) IS NULL\) OR \(\(length\(tokens_\d+\) = 2\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL\)\), NULL, arrayStringConcat\(flatten\(extractAllGroups\(lower\(hex\(IPv6CIDRToRange\(assumeNotNull\(ip_\d+\), toUInt8\(ifNull\(mask_\d+ \+ if\(isIPv4String\(tokens_\d+\[1\]\), 96, 0\), 128\)\)\)\.1\)\), '\(\[\\\\da-f\]\{4\}\)'\)\), ':'\)\), if\(\(length\(splitByChar\('/', assumeNotNull\(ipv4_\d+\)\) AS tokens_\d+\) > 2\) OR \(\(IPv6StringToNumOrNull\(tokens_\d+\[1\]\) AS ip_\d+\) IS NULL\) OR \(\(length\(tokens_\d+\) = 2\) AND \(\(toUInt8OrNull\(tokens_\d+\[-1\]\) AS mask_\d+\) IS NULL\)\), NULL, arrayStringConcat\(flatten\(extractAllGroups\(lower\(hex\(IPv6CIDRToRange\(assumeNotNull\(ip_\d+\), toUInt8\(ifNull\(mask_\d+ \+ if\(isIPv4String\(tokens_\d+\[1\]\), 96, 0\), 128\)\)\)\.1\)\), '\(\[\\\\da-f\]\{4\}\)'\)\), ':'\)\)\))"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_MVExpand.cpp b/src/Parsers/tests/KQL/gtest_KQL_MVExpand.cpp
new file mode 100644
index 000000000000..b90a700c620f
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_MVExpand.cpp
@@ -0,0 +1,45 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_MVExpand, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "T | mv-expand c",
+            "SELECT *
FROM T
ARRAY JOIN c
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand c, d",
+            "SELECT *
FROM T
ARRAY JOIN
    c,
    d
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand c to typeof(bool)",
+            "SELECT
    * EXCEPT c_ali,
    c_ali AS c
FROM
(
    SELECT
        * EXCEPT c,
        accurateCastOrNull(toInt64OrNull(toString(c)), 'Boolean') AS c_ali
    FROM
    (
        SELECT *
        FROM T
        ARRAY JOIN c
    )
)
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand b | mv-expand c",
+            "SELECT *
FROM
(
    SELECT *
    FROM T
    ARRAY JOIN b
    SETTINGS enable_unaligned_array_join = 1
)
ARRAY JOIN c
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand with_itemindex=index b, c, d",
+            "SELECT
    index,
    *
FROM T
ARRAY JOIN
    b,
    c,
    d,
    range(0, arrayMax([length(b), length(c), length(d)])) AS index
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand array_concat(c,d)",
+            "SELECT
    *,
    array_concat_
FROM T
ARRAY JOIN arrayConcat(c, d) AS array_concat_
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand x = c, y = d",
+            "SELECT
    *,
    x,
    y
FROM T
ARRAY JOIN
    c AS x,
    d AS y
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand xy = array_concat(c, d)",
+            "SELECT
    *,
    xy
FROM T
ARRAY JOIN arrayConcat(c, d) AS xy
SETTINGS enable_unaligned_array_join = 1"
+        },
+        {
+            "T | mv-expand with_itemindex=index c,d to typeof(bool)",
+            "SELECT
    * EXCEPT d_ali,
    d_ali AS d
FROM
(
    SELECT
        * EXCEPT d,
        accurateCastOrNull(toInt64OrNull(toString(d)), 'Boolean') AS d_ali
    FROM
    (
        SELECT
            index,
            *
        FROM T
        ARRAY JOIN
            c,
            d,
            range(0, arrayMax([length(c), length(d)])) AS index
    )
)
SETTINGS enable_unaligned_array_join = 1"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_MakeSeries.cpp b/src/Parsers/tests/KQL/gtest_KQL_MakeSeries.cpp
new file mode 100644
index 000000000000..533b037190da
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_MakeSeries.cpp
@@ -0,0 +1,25 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_MakeSeries, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "T |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 1d by Supplier, Fruit",
+            "SELECT
    Supplier,
    Fruit,
    zipped.1 AS Purchase,
    zipped.2 AS PriceAvg
FROM
(
    SELECT
        toUInt64(min(Purchase_ali)) AS low,
        toUInt64(max(Purchase_ali)) + 86400 AS high,
        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,
        Supplier,
        Fruit,
        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(toUInt64(toDateTime64('2016-09-10', 9, 'UTC')), toUInt64(toDateTime64('2016-09-13', 9, 'UTC')), toUInt64(86400))) - length(ga)) < 0, 0, length(range(toUInt64(toDateTime64('2016-09-10', 9, 'UTC')), toUInt64(toDateTime64('2016-09-13', 9, 'UTC')), toUInt64(86400))) - length(ga))), 1))) AS PriceAvg,
        arrayDistinct(arrayConcat(groupArray(toDateTime64(Purchase_ali - 0, 9, 'UTC')), arrayMap(x -> toDateTime64(x - 0, 9, 'UTC'), range(toUInt64(toDateTime64('2016-09-10', 9, 'UTC')), toUInt64(toDateTime64('2016-09-13', 9, 'UTC')), toUInt64(86400))))) AS Purchase
    FROM
    (
        SELECT
            Supplier,
            Fruit,
            avg(Price) AS PriceAvg_ali,
            toFloat64(toDateTime64('2016-09-10', 9, 'UTC')) + (toInt64((toFloat64(toDateTime64(Purchase, 9, 'UTC')) - toFloat64(toDateTime64('2016-09-10', 9, 'UTC'))) / 86400) * 86400) AS Purchase_ali
        FROM T
        WHERE (toInt64(toFloat64(toDateTime64(Purchase, 9, 'UTC'))) >= toUInt64(toDateTime64('2016-09-10', 9, 'UTC'))) AND (toInt64(toFloat64(toDateTime64(Purchase, 9, 'UTC'))) < toUInt64(toDateTime64('2016-09-13', 9, 'UTC')))
        GROUP BY
            Supplier,
            Fruit,
            Purchase_ali
        ORDER BY Purchase_ali ASC
    )
    GROUP BY
        Supplier,
        Fruit
)"
+        },
+        {
+            "T2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 to  15 step  1.0  by Supplier, Fruit",
+            "SELECT
    Supplier,
    Fruit,
    zipped.1 AS Purchase,
    zipped.2 AS PriceAvg
FROM
(
    SELECT
        toUInt64(min(Purchase_ali)) AS low,
        toUInt64(max(Purchase_ali)) + 1 AS high,
        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,
        Supplier,
        Fruit,
        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(toUInt64(10), toUInt64(15), toUInt64(1))) - length(ga)) < 0, 0, length(range(toUInt64(10), toUInt64(15), toUInt64(1))) - length(ga))), 1))) AS PriceAvg,
        arrayDistinct(arrayConcat(groupArray(Purchase_ali), arrayMap(x -> toFloat64(x), range(toUInt64(10), toUInt64(15), toUInt64(1))))) AS Purchase
    FROM
    (
        SELECT
            Supplier,
            Fruit,
            avg(Price) AS PriceAvg_ali,
            toFloat64(10) + (toInt64((toFloat64(Purchase) - toFloat64(10)) / 1) * 1) AS Purchase_ali
        FROM T2
        WHERE (toInt64(toFloat64(Purchase)) >= toUInt64(10)) AND (toInt64(toFloat64(Purchase)) < toUInt64(15))
        GROUP BY
            Supplier,
            Fruit,
            Purchase_ali
        ORDER BY Purchase_ali ASC
    )
    GROUP BY
        Supplier,
        Fruit
)"
+        },
+        {
+            "T |  make-series PriceAvg = avg(Price) default=0 on Purchase step 1d by Supplier, Fruit",
+            "SELECT
    Supplier,
    Fruit,
    zipped.1 AS Purchase,
    zipped.2 AS PriceAvg
FROM
(
    SELECT
        toUInt64(min(Purchase_ali)) AS low,
        toUInt64(max(Purchase_ali)) + 86400 AS high,
        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,
        Supplier,
        Fruit,
        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(low, high, toUInt64(86400))) - length(ga)) < 0, 0, length(range(low, high, toUInt64(86400))) - length(ga))), 1))) AS PriceAvg,
        arrayDistinct(arrayConcat(groupArray(toDateTime64(Purchase_ali - 62135596800, 9, 'UTC')), arrayMap(x -> toDateTime64(x - 62135596800, 9, 'UTC'), range(low, high, toUInt64(86400))))) AS Purchase
    FROM
    (
        SELECT
            Supplier,
            Fruit,
            avg(Price) AS PriceAvg_ali,
            toFloat64(toInt64((toFloat64(toDateTime64(Purchase, 9, 'UTC')) + 62135596800) / 86400) * 86400) AS Purchase_ali
        FROM T
        GROUP BY
            Supplier,
            Fruit,
            Purchase_ali
        ORDER BY Purchase_ali ASC
    )
    GROUP BY
        Supplier,
        Fruit
)"
+        },
+        {
+            "T2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  1.0  by Supplier, Fruit",
+            "SELECT
    Supplier,
    Fruit,
    zipped.1 AS Purchase,
    zipped.2 AS PriceAvg
FROM
(
    SELECT
        toUInt64(min(Purchase_ali)) AS low,
        toUInt64(max(Purchase_ali)) + 1 AS high,
        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,
        Supplier,
        Fruit,
        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(low, high, toUInt64(1))) - length(ga)) < 0, 0, length(range(low, high, toUInt64(1))) - length(ga))), 1))) AS PriceAvg,
        arrayDistinct(arrayConcat(groupArray(Purchase_ali), arrayMap(x -> toFloat64(x), range(low, high, toUInt64(1))))) AS Purchase
    FROM
    (
        SELECT
            Supplier,
            Fruit,
            avg(Price) AS PriceAvg_ali,
            toFloat64(toInt64((toFloat64(Purchase) + 0) / 1) * 1) AS Purchase_ali
        FROM T2
        GROUP BY
            Supplier,
            Fruit,
            Purchase_ali
        ORDER BY Purchase_ali ASC
    )
    GROUP BY
        Supplier,
        Fruit
)"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_StringFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_StringFunctions.cpp
new file mode 100644
index 000000000000..40a6922210fe
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_StringFunctions.cpp
@@ -0,0 +1,225 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_String, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print base64_encode_fromguid(A)",
+            "SELECT if(toTypeName(A) NOT IN ['UUID', 'Nullable(UUID)'], toString(throwIf(true, 'Expected guid as argument')), base64Encode(UUIDStringToNum(toString(A), 2)))"
+        },
+        {
+            "print base64_decode_toguid(A)",
+            "SELECT toUUIDOrNull(UUIDNumToString(toFixedString(base64Decode(A), 16), 2))"
+        },
+        {
+            "print base64_decode_toarray('S3VzdG8=')",
+            "SELECT arrayMap(x -> reinterpretAsUInt8(x), splitByRegexp('', base64Decode('S3VzdG8=')))"
+        },
+        {
+            "print replace_regex('Hello, World!', '.', '\\0\\0')",
+            "SELECT replaceRegexpAll('Hello, World!', '.', '\\0\\0')"
+        },
+        {
+            "print idx = has_any_index('this is an example', dynamic(['this', 'example'])) ",
+            "SELECT if(empty(['this', 'example']), -1, indexOf(arrayMap(x -> (x IN splitByChar(' ', 'this is an example')), if(empty(['this', 'example']), [''], arrayMap(x -> toString(x), ['this', 'example']))), 1) - 1) AS idx"
+        },
+        {
+            "print idx = has_any_index('this is an example', dynamic([]))",
+            "SELECT if(empty([]), -1, indexOf(arrayMap(x -> (x IN splitByChar(' ', 'this is an example')), if(empty([]), [''], arrayMap(x -> toString(x), []))), 1) - 1) AS idx"
+        },
+        {
+            "print translate('krasp', 'otsku', 'spark')",
+            "SELECT if(length('otsku') = 0, '', translate('spark', 'krasp', multiIf(length('otsku') = 0, 'krasp', (length('krasp') - length('otsku')) > 0, concat('otsku', repeat(substr('otsku', length('otsku'), 1), toUInt16(length('krasp') - length('otsku')))), (length('krasp') - length('otsku')) < 0, substr('otsku', 1, length('krasp')), 'otsku')))"
+        },
+        {
+            "print trim_start('[^\\w]+', strcat('-  ','Te st1','// $'))",
+            "SELECT replaceRegexpOne(concat('-  ', 'Te st1', '// $'), concat('^', '[^\\\\w]+'), '')"
+        },
+        {
+            "print trim_end('.com', 'bing.com')",
+            "SELECT replaceRegexpOne('bing.com', concat('.com', '$'), '')"
+        },
+        {
+            "print trim('--', '--https://bing.com--')",
+            "SELECT replaceRegexpOne(replaceRegexpOne('--https://bing.com--', concat('--', '$'), ''), concat('^', '--'), '')"
+        },
+        {
+            "print bool(1)",
+            "SELECT toBool(1)"
+        },
+        {
+            "print datetime(2015-12-31 23:59:59.9)",
+            "SELECT parseDateTime64BestEffortOrNull('2015-12-31 23:59:59.9', 9, 'UTC')"
+        },
+        {
+            "print datetime(\"2015-12-31 23:59:59.9\")",
+            "SELECT parseDateTime64BestEffortOrNull('2015-12-31 23:59:59.9', 9, 'UTC')"
+        },
+        {
+            "print datetime('2015-12-31 23:59:59.9')",
+            "SELECT parseDateTime64BestEffortOrNull('2015-12-31 23:59:59.9', 9, 'UTC')"
+        },
+        {
+            "print guid(74be27de-1e4e-49d9-b579-fe0b331d3642)",
+            "SELECT toUUIDOrNull('74be27de-1e4e-49d9-b579-fe0b331d3642')"
+        },
+        {
+            "print guid('74be27de-1e4e-49d9-b579-fe0b331d3642')",
+            "SELECT toUUIDOrNull('74be27de-1e4e-49d9-b579-fe0b331d3642')"
+        },
+        {
+            "print guid('74be27de1e4e49d9b579fe0b331d3642')",
+            "SELECT toUUIDOrNull('74be27de1e4e49d9b579fe0b331d3642')"
+        },
+        {
+            "print int(32.5)",
+            "SELECT toInt32(32.5)"
+        },
+        {
+            "print long(32.5)",
+            "SELECT toInt64(32.5)"
+        },
+        {
+            "print real(32.5)",
+            "SELECT toFloat64(32.5)"
+        },
+        {
+            "print time('1.22:34:8.128')",
+            "SELECT CAST('167648.128', 'Float64')"
+        },
+        {
+            "print time('1d')",
+            "SELECT CAST('86400', 'Float64')"
+        },
+        {
+            "print time('1.5d')",
+            "SELECT CAST('129600', 'Float64')"
+        },
+        {
+            "print timespan('1.5d')",
+            "SELECT CAST('129600', 'Float64')"
+        },
+        {
+            "print res = bin_at(6.5, 2.5, 7)",
+            "SELECT toFloat64(7) + (toInt64(((toFloat64(6.5) - toFloat64(7)) / 2.5) + -1) * 2.5) AS res"
+        },
+        {
+            "print res = bin_at(1h, 1d, 12h)",
+            "SELECT concat(toString(toInt32(((toFloat64(43200) + (toInt64(((toFloat64(3600) - toFloat64(43200)) / 86400) + -1) * 86400)) AS x) / 3600)), ':', toString(toInt32((x % 3600) / 60)), ':', toString(toInt32((x % 3600) % 60))) AS res"
+        },
+        {
+            "print res = bin_at(datetime(2017-05-15 10:20:00.0), 1d, datetime(1970-01-01 12:00:00.0))",
+            "SELECT toDateTime64(toFloat64(parseDateTime64BestEffortOrNull('1970-01-01 12:00:00.0', 9, 'UTC')) + (toInt64(((toFloat64(parseDateTime64BestEffortOrNull('2017-05-15 10:20:00.0', 9, 'UTC')) - toFloat64(parseDateTime64BestEffortOrNull('1970-01-01 12:00:00.0', 9, 'UTC'))) / 86400) + 0) * 86400), 9, 'UTC') AS res"
+        },
+        {
+            "print bin(4.5, 1)",
+            "SELECT toInt64(toFloat64(4.5) / 1) * 1"
+        },
+        {
+            "print bin(4.5, -1)",
+            "SELECT toInt64(toFloat64(4.5) / -1) * -1"
+        },
+        {
+            "print bin(time(16d), 7d)",
+            "SELECT concat(toString(toInt32(((toInt64(toFloat64(CAST('1382400', 'Float64')) / 604800) * 604800) AS x) / 3600)), ':', toString(toInt32((x % 3600) / 60)), ':', toString(toInt32((x % 3600) % 60)))"
+        },
+        {
+            "print bin(datetime(1970-05-11 13:45:07), 1d)",
+            "SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07', 9, 'UTC')) / 86400) * 86400, 9, 'UTC')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(bool));",
+            "SELECT accurateCastOrNull(toInt64OrNull(extract('hello x=456|wo', '[0-9.]+')), 'Boolean')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(date));",
+            "SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'DateTime')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(guid));",
+            "SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'UUID')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(int));",
+            "SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'Int32')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(long));",
+            "SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'Int64')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(real));",
+            "SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'Float64')"
+        },
+        {
+            "print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(decimal));",
+            "SELECT toDecimal128OrNull(if(countSubstrings(extract('hello x=456|wo', '[0-9.]+'), '.') > 1, NULL, extract('hello x=456|wo', '[0-9.]+')), length(substr(extract('hello x=456|wo', '[0-9.]+'), position(extract('hello x=456|wo', '[0-9.]+'), '.') + 1)))"
+        },
+        {
+            "print bin(datetime(1970-05-11 13:45:07.456345672), 1ms)",
+            "SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.001) * 0.001, 9, 'UTC')"
+        },
+        {
+            "print bin(datetime(1970-05-11 13:45:07.456345672), 1microseconds)",
+            "SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.000001) * 0.000001, 9, 'UTC')"
+        },
+        {
+            "print parse_version('1.2.3.40')",
+            "SELECT if((length(splitByChar('.', '1.2.3.40')) > 4) OR (length(splitByChar('.', '1.2.3.40')) < 1) OR (match('1.2.3.40', '.*[a-zA-Z]+.*') = 1), toDecimal128OrNull('NULL', 0), toDecimal128OrNull(substring(arrayStringConcat(arrayMap(x -> leftPad(x, 8, '0'), arrayMap(x -> if(empty(x), '0', x), arrayResize(splitByChar('.', '1.2.3.40'), 4)))), 8), 0))"
+        },
+        {
+            "print parse_version('1')",
+            "SELECT if((length(splitByChar('.', '1')) > 4) OR (length(splitByChar('.', '1')) < 1) OR (match('1', '.*[a-zA-Z]+.*') = 1), toDecimal128OrNull('NULL', 0), toDecimal128OrNull(substring(arrayStringConcat(arrayMap(x -> leftPad(x, 8, '0'), arrayMap(x -> if(empty(x), '0', x), arrayResize(splitByChar('.', '1'), 4)))), 8), 0))"
+        },
+        {
+            "print parse_json( dynamic([1, 2, 3]))",
+            "SELECT [1, 2, 3]"
+        },
+        {
+            "print parse_json('{\"a\":123.5, \"b\":\"{\\\"c\\\":456}\"}')",
+            "SELECT if(isValidJSON('{\"a\":123.5, \"b\":\"{\"c\":456}\"}'), JSON_QUERY('{\"a\":123.5, \"b\":\"{\"c\":456}\"}', '$'), toJSONString('{\"a\":123.5, \"b\":\"{\"c\":456}\"}'))"
+        },
+        {
+            "print extract_json( '$.a' , '{\"a\":123, \"b\":\"{\"c\":456}\"}' , typeof(long))",
+            "SELECT accurateCastOrNull(JSON_VALUE('{\"a\":123, \"b\":\"{\"c\":456}\"}', '$.a'), 'Int64')"
+        },
+        {
+            "print bin(datetime(1970-05-11 13:45:07.456345672), 1ms)",
+            "SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.001) * 0.001, 9, 'UTC')"
+        },
+        {
+            "print bin(datetime(1970-05-11 13:45:07.456345672), 1microseconds)",
+            "SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.000001) * 0.000001, 9, 'UTC')"
+        },
+        {
+            "print parse_command_line('echo \"hello world!\" print$?', 'windows')",
+            "SELECT if(empty('echo \"hello world!\" print$?') OR hasAll(splitByChar(' ', 'echo \"hello world!\" print$?'), ['']), arrayMap(x -> NULL, splitByChar(' ', '')), splitByChar(' ', 'echo \"hello world!\" print$?'))"
+        },
+        {
+            "print reverse(123)",
+            "SELECT reverse(accurateCastOrNull(123, 'String'))"
+        },
+        {
+            "print reverse(123.34)",
+            "SELECT reverse(accurateCastOrNull(123.34, 'String'))"
+        },
+        {
+            "print reverse('clickhouse')",
+            "SELECT reverse(accurateCastOrNull('clickhouse', 'String'))"
+        },
+        {
+            "print result=parse_csv('aa,b,cc')",
+            "SELECT if(CAST(position('aa,b,cc', '\
'), 'UInt8'), splitByChar(',', substring('aa,b,cc', 1, position('aa,b,cc', '\
') - 1)), splitByChar(',', substring('aa,b,cc', 1, length('aa,b,cc')))) AS result"
+        },
+        {
+            "print result_multi_record=parse_csv('record1,a,b,c
record2,x,y,z')",
+            "SELECT if(CAST(position('record1,a,b,c\
record2,x,y,z', '\
'), 'UInt8'), splitByChar(',', substring('record1,a,b,c\
record2,x,y,z', 1, position('record1,a,b,c\
record2,x,y,z', '\
') - 1)), splitByChar(',', substring('record1,a,b,c\
record2,x,y,z', 1, length('record1,a,b,c\
record2,x,y,z')))) AS result_multi_record"
+        },
+        {
+            "Customers | project name_abbr = strcat(substring(FirstName,0,3), ' ', substring(LastName,2))| order by LastName",
+            "SELECT concat(if(toInt64(length(FirstName)) <= 0, '', substr(FirstName, (((0 % toInt64(length(FirstName))) + toInt64(length(FirstName))) % toInt64(length(FirstName))) + 1, 3)), ' ', if(toInt64(length(LastName)) <= 0, '', substr(LastName, (((2 % toInt64(length(LastName))) + toInt64(length(LastName))) % toInt64(length(LastName))) + 1))) AS name_abbr
FROM Customers
ORDER BY LastName DESC"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_dateTimeFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_dateTimeFunctions.cpp
new file mode 100644
index 000000000000..ed38411c1b71
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_dateTimeFunctions.cpp
@@ -0,0 +1,218 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Datetime, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "print week_of_year(datetime(2020-12-31))",
+            "SELECT toWeek(parseDateTime64BestEffortOrNull('2020-12-31', 9, 'UTC'), 3, 'UTC')"
+        },
+        {
+            "print startofweek(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT parseDateTime64BestEffortOrNull(toString(toStartOfWeek(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'))), 9, 'UTC') + toIntervalWeek(-1)"
+        },
+        {
+            "print startofmonth(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT parseDateTime64BestEffortOrNull(toString(toStartOfMonth(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'))), 9, 'UTC') + toIntervalMonth(-1)"
+        },
+        {
+            "print startofday(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT parseDateTime64BestEffortOrNull(toString(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'))), 9, 'UTC') + toIntervalDay(-1)"
+        },
+        {
+            "print startofyear(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT parseDateTime64BestEffortOrNull(toString(toStartOfYear(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 'UTC')), 9, 'UTC') + toIntervalYear(-1)"
+        },
+        {
+            "print monthofyear(datetime(2015-12-14))",
+            "SELECT toMonth(parseDateTime64BestEffortOrNull('2015-12-14', 9, 'UTC'))"
+        },
+        {
+            "print hourofday(datetime(2015-12-14 10:54:00))",
+            "SELECT toHour(parseDateTime64BestEffortOrNull('2015-12-14 10:54:00', 9, 'UTC'))"
+        },
+        {
+            "print getyear(datetime(2015-10-12))",
+            "SELECT toYear(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))"
+        },
+        {
+            "print getmonth(datetime(2015-10-12))",
+            "SELECT toMonth(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))"
+        },
+        {
+            "print dayofyear(datetime(2015-10-12))",
+            "SELECT toDayOfYear(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))"
+        },
+        {
+            "print dayofmonth(datetime(2015-10-12))",
+            "SELECT toDayOfMonth(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))"
+        },
+        {
+            "print unixtime_seconds_todatetime(1546300899)",
+            "SELECT if((toTypeName(1546300899) = 'Int64') OR (toTypeName(1546300899) = 'Int32') OR (toTypeName(1546300899) = 'Float64') OR (toTypeName(1546300899) = 'UInt32') OR (toTypeName(1546300899) = 'UInt64'), toDateTime64(1546300899, 9, 'UTC'), toDateTime64(throwIf(true, 'unixtime_seconds_todatetime only accepts Int, Long and double type of arguments'), 9, 'UTC'))"
+        },
+        {
+            "print dayofweek(datetime(2015-12-20))",
+            "SELECT concat(CAST(toDayOfWeek(parseDateTime64BestEffortOrNull('2015-12-20', 9, 'UTC')) % 7, 'String'), '.00:00:00')"
+        },
+        {
+            "print now()",
+            "SELECT now64(9, 'UTC')"
+        },
+        {
+            "print now(1d)",
+            "SELECT now64(9, 'UTC') + 86400"
+        },
+        {
+            "print ago(2d)",
+            "SELECT now64(9, 'UTC') - 172800"
+        },
+        {
+            "print endofday(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalDay(-1 + 1)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print endofday(datetime(2017-01-01 10:10:17), 1)",
+            "SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalDay(1 + 1)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print endofmonth(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT (((toDateTime(toLastDayOfMonth(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalMonth(-1)), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print endofmonth(datetime(2017-01-01 10:10:17), 1)",
+            "SELECT (((toDateTime(toLastDayOfMonth(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalMonth(1)), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print endofweek(datetime(2017-01-01 10:10:17), -1)",
+            "SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalWeek(-1 + 1)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print endofweek(datetime(2017-01-01 10:10:17), 1)",
+            "SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalWeek(1 + 1)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print endofyear(datetime(2017-01-01 10:10:17), -1) ",
+            "SELECT (((toDateTime(toString(toLastDayOfMonth((toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalYear(-1)) + toIntervalMonth(12 - toInt8(substring(toString(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC')), 6, 2))))), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)"
+        },
+        {
+           "print endofyear(datetime(2017-01-01 10:10:17), 1)" ,
+           "SELECT (((toDateTime(toString(toLastDayOfMonth((toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalYear(1)) + toIntervalMonth(12 - toInt8(substring(toString(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC')), 6, 2))))), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)"
+        },
+        {
+            "print make_datetime(2017,10,01)",
+            "SELECT makeDateTime64(2017, 10, 1, 0, 0, 0, 0, 7, 'UTC')"
+        },
+        {
+            "print make_datetime(2017,10,01,12,10)",
+            "SELECT makeDateTime64(2017, 10, 1, 12, 10, 0, 0, 7, 'UTC')"
+        },
+        {
+            "print make_datetime(2017,10,01,12,11,0.1234567)",
+            "SELECT makeDateTime64(2017, 10, 1, 12, 11, 0.1234567, 0, 7, 'UTC')"
+        },
+        {
+            "print unixtime_microseconds_todatetime(1546300800000000)",
+            "SELECT fromUnixTimestamp64Micro(1546300800000000, 'UTC')"
+        },
+        {
+            "print unixtime_milliseconds_todatetime(1546300800000)",
+            "SELECT fromUnixTimestamp64Milli(1546300800000, 'UTC')"
+        },
+        {
+            "print unixtime_nanoseconds_todatetime(1546300800000000000)",
+            "SELECT fromUnixTimestamp64Nano(1546300800000000000, 'UTC')"
+        },
+        {
+            "print datetime_diff('year',datetime(2017-01-01),datetime(2000-12-31))",
+            "SELECT dateDiff('year', parseDateTime64BestEffortOrNull('2017-01-01', 9, 'UTC'), parseDateTime64BestEffortOrNull('2000-12-31', 9, 'UTC')) * -1"
+        },
+        {
+            "print datetime_diff('minute',datetime(2017-10-30 23:05:01),datetime(2017-10-30 23:00:59))",
+            "SELECT dateDiff('minute', parseDateTime64BestEffortOrNull('2017-10-30 23:05:01', 9, 'UTC'), parseDateTime64BestEffortOrNull('2017-10-30 23:00:59', 9, 'UTC')) * -1"
+        },
+        {
+            "print datetime(null)",
+            "SELECT NULL"
+        },
+        {
+            "print datetime('2014-05-25T08:20:03.123456Z')",
+            "SELECT parseDateTime64BestEffortOrNull('2014-05-25T08:20:03.123456Z', 9, 'UTC')"
+        },
+        {
+            "print datetime(2015-12-14 18:54)",
+            "SELECT parseDateTime64BestEffortOrNull('2015-12-14 18:54', 9, 'UTC')"
+        },
+        {
+            "print make_timespan(67,12,30,59.9799)",
+            "SELECT CONCAT('67.', toString(substring(toString(toTime(parseDateTime64BestEffortOrNull('0000-00-00 12:30:59.9799', 9, 'UTC'))), 12)))"
+        },
+        {
+            "print  todatetime('2014-05-25T08:20:03.123456Z')",
+            "SELECT parseDateTime64BestEffortOrNull(toString('2014-05-25T08:20:03.123456Z'), 9, 'UTC')"
+        },
+        {
+            "print format_datetime(todatetime('2009-06-15T13:45:30.6175425'), 'yy-M-dd [H:mm:ss.fff]')",
+            "SELECT concat(substring(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), 1, position(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), '.')), substring(substring(toString(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC')), position(toString(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC')), '.') + 1), 1, 3), substring(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), position(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), '.') + 1, length(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')))))"
+        },
+        {
+            "print format_datetime(datetime(2015-12-14 02:03:04.12345), 'y-M-d h:m:s tt')",
+            "SELECT formatDateTime(parseDateTime64BestEffortOrNull('2015-12-14 02:03:04.12345', 9, 'UTC'), '%y-%m-%e %h:%i:%S %p')"
+        },
+        {
+            "print format_timespan(time(1d), 'd-[hh:mm:ss]')",
+            "SELECT concat(leftPad('1', 1, '0'), toString(formatDateTime(toDateTime64(CAST('86400', 'Float64'), 9, 'UTC'), '-[%h:%i:%S]')))"
+        },
+        {
+            "print format_timespan(time('12:30:55.123'), 'ddddd-[hh:mm:ss.ffff]')",
+            "SELECT concat(leftPad('0', 5, '0'), substring(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')), 1, length(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]'))) - position(reverse(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]'))), ']')), substring(substring(toString(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC')), position(toString(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC')), '.') + 1), 1, 4), substring(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')), position(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')), ']'), length(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')))))"
+        },
+        {
+            "print v1=format_timespan(time('29.09:00:05.12345'), 'dd.hh:mm:ss:FF')",
+            "SELECT concat(leftPad('29', 2, '0'), substring(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S:')), 1, (length(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S:'))) - position(reverse(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S:'))), ':')) + 1), substring(substring(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), position(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), '.') + 1), 1, 2)) AS v1"
+        },
+        {
+            "print v2=format_timespan(time('29.09:00:05.12345'), 'ddd.h:mm:ss [fffffff]');",
+            "SELECT concat(leftPad('29', 3, '0'), substring(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []')), 1, length(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []'))) - position(reverse(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []'))), ']')), substring(substring(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), position(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), '.') + 1), 1, 7), substring(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []')), position(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []')), ']'), length(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []'))))) AS v2"
+        },
+        {
+            "print datetime_part('day', datetime(2017-10-30 01:02:03.7654321))",
+            "SELECT formatDateTime(parseDateTime64BestEffortOrNull('2017-10-30 01:02:03.7654321', 9, 'UTC'), '%e')"
+        },
+        {
+            "print datetime_add('day',1,datetime(2017-10-30 01:02:03.7654321))",
+            "SELECT parseDateTime64BestEffortOrNull('2017-10-30 01:02:03.7654321', 9, 'UTC') + toIntervalDay(1)"
+        },
+        {
+            "print totimespan(time(1d))",
+            "SELECT CAST('86400', 'Float64')"
+        },
+        {
+            "print totimespan('0.01:34:23')",
+            "SELECT CAST('5663', 'Float64')"
+        },
+        {
+            "print totimespan(time('-1:12:34'))",
+            "SELECT CAST('-4354', 'Float64')"
+        },
+        {
+            "print totimespan(-1d)",
+            "SELECT -86400"
+        },
+        {
+            "print totimespan('abc')",
+            "SELECT NULL"
+        },
+        {
+            "print time(2)",
+            "SELECT CAST('172800', 'Float64')"
+        },
+        {
+            "hits | project bin(datetime(EventTime), 1m)",
+            "SELECT toDateTime64(toInt64(toFloat64(if((toTypeName(EventTime) = 'Int64') OR (toTypeName(EventTime) = 'Int32') OR (toTypeName(EventTime) = 'Float64') OR (toTypeName(EventTime) = 'UInt32') OR (toTypeName(EventTime) = 'UInt64'), toDateTime64(EventTime, 9, 'UTC'), parseDateTime64BestEffortOrNull(CAST(EventTime, 'String'), 9, 'UTC'))) / 60) * 60, 9, 'UTC')
FROM hits"
+        }
+
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_dynamicFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_dynamicFunctions.cpp
new file mode 100644
index 000000000000..93df5a6c55f1
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_dynamicFunctions.cpp
@@ -0,0 +1,140 @@
+#include <Parsers/tests/gtest_common.h>
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Dynamic, ParserKQLTest,
+     ::testing::Combine(
+         ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+         ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+         {
+             "print t = array_sort_asc(dynamic([null, 'd', 'a', 'c', 'c']))",
+            "SELECT kql_array_sort_asc([NULL, 'd', 'a', 'c', 'c']).1 AS t"
+        },
+        {
+            "print t = array_sort_asc(dynamic([4, 1, 3, 2]))",
+            "SELECT kql_array_sort_asc([4, 1, 3, 2]).1 AS t"
+        },
+        {
+            "print t = array_sort_asc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))",
+            "SELECT kql_array_sort_asc(['b', 'a', 'c'], ['q', 'p', 'r']).1 AS t"
+        },
+        {
+            "print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , false)",
+            "SELECT kql_array_sort_asc(['d', NULL, 'a', 'c', 'c'], false).1 AS t"
+        },
+        {
+            "print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]) , false)",
+            "SELECT kql_array_sort_asc([NULL, 'd', NULL, NULL, 'a', 'c', 'c', NULL, NULL, NULL], false).1 AS t"
+        },
+        {
+            "print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]) , true)",
+            "SELECT kql_array_sort_asc([NULL, 'd', NULL, NULL, 'a', 'c', 'c', NULL, NULL, NULL], true).1 AS t"
+        },
+        {
+            "print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]))",
+            "SELECT kql_array_sort_asc([NULL, 'd', NULL, NULL, 'a', 'c', 'c', NULL, NULL, NULL]).1 AS t"
+        },
+        {
+            "print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']), 1 < 2)",
+            "SELECT kql_array_sort_asc(['d', NULL, 'a', 'c', 'c'], 1 < 2).1 AS t"
+        },
+        {
+            "print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2)",
+            "SELECT kql_array_sort_asc(['d', NULL, 'a', 'c', 'c'], 1 > 2).1 AS t"
+        },
+        {
+            "print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), false)",
+            "SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], false).1 AS t"
+        },
+        {
+            "print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), 1 > 2)",
+            "SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], 1 > 2).1 AS t"
+        },
+        {
+            "print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), true)",
+            "SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], true).1 AS t"
+        },
+        {
+            "print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), 1 < 2)",
+            "SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], 1 < 2).1 AS t"
+        },
+        {
+            "print t = array_sort_desc(dynamic([null, 'd', 'a', 'c', 'c']))",
+            "SELECT kql_array_sort_desc([NULL, 'd', 'a', 'c', 'c']).1 AS t"
+        },
+        {
+            "print t = array_sort_desc(dynamic([4, 1, 3, 2]))",
+            "SELECT kql_array_sort_desc([4, 1, 3, 2]).1 AS t"
+        },
+        {
+            "print t = array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))",
+             "SELECT kql_array_sort_desc(['b', 'a', 'c'], ['q', 'p', 'r']).1 AS t"
+         },
+         {
+            "print array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))",
+            "SELECT kql_array_sort_desc(['b', 'a', 'c'], ['q', 'p', 'r'])"
+        },
+        {
+            "print t = array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , false)",
+            "SELECT kql_array_sort_desc(['d', NULL, 'a', 'c', 'c'], false).1 AS t"
+        },
+        {
+            "print array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]))[0]",
+            "SELECT tupleElement(kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]), if(0 >= 0, 0 + 1, 0))"
+        },
+        {
+            "print  (t) = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]))",
+            "SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t"
+        },
+        {
+            "print  (t,w) = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]))",
+            "SELECT
    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,
    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).2 AS w"
+        },
+        {
+            "print  t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30])),y=5",
+            "SELECT
    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,
    5 AS y"
+        },
+        {
+            "print 5, (t) = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30])),y=5",
+            "SELECT
    5,
    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,
    5 AS y"
+        },
+        {
+            "print  t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30])),w = array_sort_asc(dynamic([2, 1, 3]))",
+            "SELECT
    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,
    kql_array_sort_asc([2, 1, 3]).1 AS w"
+        },
+         {
+             "print A[0]",
+             "SELECT A[if(0 >= 0, 0 + 1, 0)]"
+         },
+         {
+             "print A[0][1]",
+             "SELECT (A[if(0 >= 0, 0 + 1, 0)])[if(1 >= 0, 1 + 1, 1)]"
+         },
+         {
+             "print dynamic([[1,2,3,4,5],[20,30]])[0]",
+             "SELECT [[1, 2, 3, 4, 5], [20, 30]][if(0 >= 0, 0 + 1, 0)]"
+         },
+         {
+             "print dynamic([[1,2,3,4,5],[20,30]])[1][1]",
+             "SELECT ([[1, 2, 3, 4, 5], [20, 30]][if(1 >= 0, 1 + 1, 1)])[if(1 >= 0, 1 + 1, 1)]"
+         },
+         {
+             "print A[B[1]]",
+             "SELECT A[if((B[if(1 >= 0, 1 + 1, 1)]) >= 0, (B[if(1 >= 0, 1 + 1, 1)]) + 1, B[if(1 >= 0, 1 + 1, 1)])]"
+         },
+         {
+             "print A[strlen('a')-1]",
+             "SELECT A[if((lengthUTF8('a') - 1) >= 0, (lengthUTF8('a') - 1) + 1, lengthUTF8('a') - 1)]"
+         },
+         {
+             "print strlen(A[0])",
+             "SELECT lengthUTF8(A[if(0 >= 0, 0 + 1, 0)])"
+         },
+         {
+            "print repeat(1, 3)",
+            "SELECT if(3 < 0, [NULL], arrayWithConstant(abs(3), 1))"
+         },
+         {
+            "print repeat(1, -3)",
+            "SELECT if(-3 < 0, [NULL], arrayWithConstant(abs(-3), 1))"
+         }
+ })));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_operator_in_sql.cpp b/src/Parsers/tests/KQL/gtest_KQL_operator_in_sql.cpp
new file mode 100644
index 000000000000..a35287f471bc
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_operator_in_sql.cpp
@@ -0,0 +1,66 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+#include <Parsers/ParserSelectQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_operator_in_sql, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserSelectQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "select * from kql($$Customers | where FirstName !in ('Peter', 'Latoya')$$)",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE FirstName NOT IN ('Peter', 'Latoya')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !contains 'Pet'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT (FirstName ILIKE '%Pet%')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !contains_cs 'Pet'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT (FirstName LIKE '%Pet%')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !endswith 'ter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT (FirstName ILIKE '%ter')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !endswith_cs 'ter'$$);"
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT endsWith(FirstName, 'ter')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName != 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE FirstName != 'Peter'
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !has 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT hasTokenCaseInsensitive(FirstName, 'Peter')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !has_cs 'peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT hasToken(FirstName, 'peter')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !hasprefix 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE (NOT (FirstName ILIKE 'Peter%')) AND (NOT (FirstName ILIKE '% Peter%'))
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !hasprefix_cs 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE (NOT startsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '% Peter%'))
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !hassuffix 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE (NOT (FirstName ILIKE '%Peter')) AND (NOT (FirstName ILIKE '%Peter %'))
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !hassuffix_cs 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE (NOT endsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '%Peter %'))
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !startswith 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT (FirstName ILIKE 'Peter%')
)"
+        },
+        {
+            "select * from kql($$Customers | where FirstName !startswith_cs 'Peter'$$);",
+            "SELECT *
FROM view(
    SELECT *
    FROM Customers
    WHERE NOT startsWith(FirstName, 'Peter')
)"
+        }
+})));
diff --git a/src/Parsers/tests/KQL/gtest_KQL_test_subquery.cpp b/src/Parsers/tests/KQL/gtest_KQL_test_subquery.cpp
new file mode 100644
index 000000000000..619f634670a1
--- /dev/null
+++ b/src/Parsers/tests/KQL/gtest_KQL_test_subquery.cpp
@@ -0,0 +1,109 @@
+#include <Parsers/tests/gtest_common.h>
+
+#include <Parsers/Kusto/ParserKQLQuery.h>
+
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_TestSubquery, ParserKQLTest,
+    ::testing::Combine(
+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),
+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !in ('Peter', 'Latoya')));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE FirstName NOT IN ('Peter', 'Latoya')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName, Age | where Age !in (28, 29)));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE Age NOT IN (28, 29)
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !contains 'ste'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT (FirstName ILIKE '%ste%')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !contains_cs 'Ste'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT (FirstName LIKE '%Ste%')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !contains_cs 'ste'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT (FirstName LIKE '%ste%')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !endswith 'ore'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT (FirstName ILIKE '%ore')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !endswith_cs 'Ore'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT endsWith(FirstName, 'Ore')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName != 'Theodore'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE FirstName != 'Theodore'
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !~ 'theodore'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE lower(FirstName) != lower('theodore')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !has 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT hasTokenCaseInsensitive(FirstName, 'Peter')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !has_cs 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT hasToken(FirstName, 'Peter')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hasprefix 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE (NOT (FirstName ILIKE 'Peter%')) AND (NOT (FirstName ILIKE '% Peter%'))
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hasprefix_cs 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE (NOT startsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '% Peter%'))
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hassuffix 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE (NOT (FirstName ILIKE '%Peter')) AND (NOT (FirstName ILIKE '%Peter %'))
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hassuffix_cs 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE (NOT endsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '%Peter %'))
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !startswith 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT (FirstName ILIKE 'Peter%')
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName  | where FirstName !startswith_cs 'Peter'));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE NOT startsWith(FirstName, 'Peter')
)"
+        },
+        {
+            "Customers | where FirstName !in~ ((Customers | project FirstName  | where FirstName !in~ ('peter', 'apple')));",
+            "SELECT *
FROM Customers
WHERE lower(FirstName) NOT IN (
    SELECT lower(FirstName)
    FROM Customers
    WHERE lower(FirstName) NOT IN (lower('peter'), lower('apple'))
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName | where FirstName in~ ('peter', 'apple')));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
    WHERE lower(FirstName) IN (lower('peter'), lower('apple'))
)"
+        },
+        {
+            "Customers | where substring(FirstName,0,3) in~ ((Customers | project substring(FirstName,0,3) | where FirstName in~ ('peter', 'apple')));",
+            "SELECT *
FROM Customers
WHERE lower(if(toInt64(length(FirstName)) <= 0, '', substr(FirstName, (((0 % toInt64(length(FirstName))) + toInt64(length(FirstName))) % toInt64(length(FirstName))) + 1, 3))) IN (
    SELECT lower(if(toInt64(length(FirstName)) <= 0, '', substr(FirstName, (((0 % toInt64(length(FirstName))) + toInt64(length(FirstName))) % toInt64(length(FirstName))) + 1, 3)))
    FROM Customers
    WHERE lower(FirstName) IN (lower('peter'), lower('apple'))
)"
+        },
+        {
+            "Customers | where FirstName in~ ((Customers |  where FirstName !in~ ('peter', 'apple')| project FirstName));",
+            "SELECT *
FROM Customers
WHERE lower(FirstName) IN (
    SELECT lower(FirstName)
    FROM Customers
    WHERE lower(FirstName) NOT IN (lower('peter'), lower('apple'))
)"
+        },
+        {
+            "Customers | where FirstName in ((Customers | project FirstName, LastName, Age));",
+            "SELECT *
FROM Customers
WHERE FirstName IN (
    SELECT FirstName
    FROM Customers
)"
+        },
+        {
+            "Customers | where FirstName in~ ((Customers | project FirstName, LastName, Age|where Age <30));",
+            "SELECT *
FROM Customers
WHERE lower(FirstName) IN (
    SELECT lower(FirstName)
    FROM Customers
    WHERE Age < 30
)"
+        },
+        {
+            "Customers | where FirstName !in ((Customers | project FirstName, LastName, Age |where Age <30 ));",
+            "SELECT *
FROM Customers
WHERE FirstName NOT IN (
    SELECT FirstName
    FROM Customers
    WHERE Age < 30
)"
+        },
+        {
+            "Customers | where FirstName !in~ ((Customers | project FirstName, LastName, Age |where Age <30));",
+            "SELECT *
FROM Customers
WHERE lower(FirstName) NOT IN (
    SELECT lower(FirstName)
    FROM Customers
    WHERE Age < 30
)"
+        }
+})));
diff --git a/src/Parsers/tests/gtest_Parser.cpp b/src/Parsers/tests/gtest_Parser.cpp
index 3a90256f2625..556743e70ec0 100644
--- a/src/Parsers/tests/gtest_Parser.cpp
+++ b/src/Parsers/tests/gtest_Parser.cpp
@@ -18,6 +18,7 @@
 #include <string_view>
 #include <regex>
 #include <gtest/gtest.h>
+#include "gtest_common.h"
 #include <boost/algorithm/string/replace.hpp>
 
 namespace
@@ -26,13 +27,6 @@ using namespace DB;
 using namespace std::literals;
 }
 
-
-struct ParserTestCase
-{
-    const std::string_view input_text;
-    const char * expected_ast = nullptr;
-};
-
 std::ostream & operator<<(std::ostream & ostr, const std::shared_ptr<IParser> parser)
 {
     return ostr << "Parser: " << parser->getName();
@@ -47,9 +41,6 @@ std::ostream & operator<<(std::ostream & ostr, const ParserTestCase & test_case)
     return ostr << "ParserTestCase input: " << input_text;
 }
 
-class ParserTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<IParser>, ParserTestCase>>
-{};
-
 TEST_P(ParserTest, parseQuery)
 {
     const auto & parser = std::get<0>(GetParam());
@@ -307,7 +298,7 @@ INSTANTIATE_TEST_SUITE_P(ParserAttachUserQuery, ParserTest,
         }
 })));
 
-INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,
+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserKQLTest,
     ::testing::Combine(
         ::testing::Values(std::make_shared<ParserKQLQuery>()),
         ::testing::ValuesIn(std::initializer_list<ParserTestCase>{
@@ -339,10 +330,6 @@ INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,
             "Customers | project FirstName,LastName,Occupation | take 3 | project FirstName,LastName",
             "SELECT
    FirstName,
    LastName
FROM
(
    SELECT
        FirstName,
        LastName,
        Occupation
    FROM Customers
    LIMIT 3
)"
         },
-        {
-            "Customers | project FirstName,LastName,Occupation | take 3 | project FirstName,LastName,Education",
-            "SELECT
    FirstName,
    LastName,
    Education
FROM
(
    SELECT
        FirstName,
        LastName,
        Occupation
    FROM Customers
    LIMIT 3
)"
-        },
         {
             "Customers | sort by FirstName desc",
             "SELECT *
FROM Customers
ORDER BY FirstName DESC"
@@ -425,23 +412,23 @@ INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,
         },
         {
             "Customers |summarize count() by Occupation",
-            "SELECT
    count(),
    Occupation
FROM Customers
GROUP BY Occupation"
+            "SELECT
    Occupation,
    count() AS count_
FROM Customers
GROUP BY Occupation"
         },
         {
             "Customers|summarize sum(Age) by Occupation",
-            "SELECT
    sum(Age),
    Occupation
FROM Customers
GROUP BY Occupation"
+            "SELECT
    Occupation,
    sum(Age) AS sum_Age
FROM Customers
GROUP BY Occupation"
         },
         {
             "Customers|summarize  avg(Age) by Occupation",
-            "SELECT
    avg(Age),
    Occupation
FROM Customers
GROUP BY Occupation"
+            "SELECT
    Occupation,
    avg(Age) AS avg_Age
FROM Customers
GROUP BY Occupation"
         },
         {
             "Customers|summarize  min(Age) by Occupation",
-            "SELECT
    min(Age),
    Occupation
FROM Customers
GROUP BY Occupation"
+            "SELECT
    Occupation,
    min(Age) AS min_Age
FROM Customers
GROUP BY Occupation"
         },
         {
             "Customers |summarize  max(Age) by Occupation",
-            "SELECT
    max(Age),
    Occupation
FROM Customers
GROUP BY Occupation"
+            "SELECT
    Occupation,
    max(Age) AS max_Age
FROM Customers
GROUP BY Occupation"
         },
         {
             "Customers | where FirstName contains 'pet'",
@@ -486,6 +473,146 @@ INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,
         {
             "Customers | where FirstName !startswith 'pet'",
             "SELECT *
FROM Customers
WHERE NOT (FirstName ILIKE 'pet%')"
+        },
+        {
+            "Customers | where Age in ((Customers|project Age|where Age < 30))",
+            "SELECT *
FROM Customers
WHERE Age IN (
    SELECT Age
    FROM Customers
    WHERE Age < 30
)"
+        },
+        {
+            "Customers|where Occupation has_any ('Skilled','abcd')",
+            "SELECT *
FROM Customers
WHERE hasTokenCaseInsensitive(Occupation, 'Skilled') OR hasTokenCaseInsensitive(Occupation, 'abcd')"
+        },
+        {
+            "Customers|where Occupation has_all ('Skilled','abcd')",
+            "SELECT *
FROM Customers
WHERE hasTokenCaseInsensitive(Occupation, 'Skilled') AND hasTokenCaseInsensitive(Occupation, 'abcd')"
+        },
+        {
+            "Customers|where Occupation has_all (strcat('Skill','ed'),'Manual')",
+            "SELECT *
FROM Customers
WHERE hasTokenCaseInsensitive(Occupation, concat('Skill', 'ed')) AND hasTokenCaseInsensitive(Occupation, 'Manual')"
+        },
+        {
+            "Customers | where Occupation == strcat('Pro','fessional') | take 1",
+            "SELECT *
FROM Customers
WHERE Occupation = concat('Pro', 'fessional')
LIMIT 1"
+        },
+        {
+            "Customers | project countof('The cat sat on the mat', 'at')",
+            "SELECT countSubstrings('The cat sat on the mat', 'at')
FROM Customers"
+        },
+        {
+            "Customers | project countof('The cat sat on the mat', 'at', 'normal')",
+            "SELECT countSubstrings('The cat sat on the mat', 'at')
FROM Customers"
+        },
+        {
+            "Customers | project countof('The cat sat on the mat', 'at', 'regex')",
+            "SELECT countMatches('The cat sat on the mat', 'at')
FROM Customers"
+        },
+        {
+            "Customers | project extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 0, 'The price of PINEAPPLE ice cream is 10')",
+            "SELECT extract('The price of PINEAPPLE ice cream is 10', '\\b[A-Z]+\\b.+\\b\\\\d+')
FROM Customers"
+        },
+        {
+            "Customers | project extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 1, 'The price of PINEAPPLE ice cream is 20')",
+            "SELECT extract('The price of PINEAPPLE ice cream is 20', '\\b[A-Z]+\\b')
FROM Customers"
+        },
+        {
+            "Customers | project extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 2, 'The price of PINEAPPLE ice cream is 30')",
+            "SELECT extract('The price of PINEAPPLE ice cream is 30', '\\b\\\\d+')
FROM Customers"
+        },
+        {
+            "Customers | project extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 2, 'The price of PINEAPPLE ice cream is 40', typeof(int))",
+            "SELECT accurateCastOrNull(extract('The price of PINEAPPLE ice cream is 40', '\\b\\\\d+'), 'Int32')
FROM Customers"
+        },
+        {
+            "Customers | project extract_all('(\\w)(\\w+)(\\w)','The price of PINEAPPLE ice cream is 50')",
+            "SELECT extractAllGroups('The price of PINEAPPLE ice cream is 50', '(\\\\w)(\\\\w+)(\\\\w)')
FROM Customers"
+        },
+        {
+            " Customers | project split('aa_bb', '_')",
+            "SELECT if(empty('_'), splitByString(' ', 'aa_bb'), splitByString('_', 'aa_bb'))
FROM Customers"
+        },
+        {
+            "Customers | project split('aaa_bbb_ccc', '_', 1)",
+            "SELECT multiIf((length(if(empty('_'), splitByString(' ', 'aaa_bbb_ccc'), splitByString('_', 'aaa_bbb_ccc'))) >= 2) AND (2 > 0), arrayPushBack([], if(empty('_'), splitByString(' ', 'aaa_bbb_ccc'), splitByString('_', 'aaa_bbb_ccc'))[2]), 2 = 0, if(empty('_'), splitByString(' ', 'aaa_bbb_ccc'), splitByString('_', 'aaa_bbb_ccc')), arrayPushBack([], NULL[1]))
FROM Customers"
+        },
+        {
+            "Customers | project strcat_delim('-', '1', '2', 'A')",
+            "SELECT concat('1', '-', '2', '-', 'A')
FROM Customers"
+        },
+        {
+            "Customers | project indexof('abcdefg','cde')",
+            "SELECT position('abcdefg', 'cde', 1) - 1
FROM Customers"
+        },
+        {
+            "Customers | project indexof('abcdefg','cde', 2) ",
+            "SELECT position('abcdefg', 'cde', 3) - 1
FROM Customers"
+        },
+        {
+            "print x=1, s=strcat('Hello', ', ', 'World!')",
+            "SELECT
    1 AS x,
    concat('Hello', ', ', 'World!') AS s"
+        },
+        {
+            "print parse_urlquery('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')",
+            "SELECT concat('{', concat('\"Query Parameters\":', concat('{\"', replace(replace(if(position('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment', '?') > 0, queryString('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), 'https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '=', '\":\"'), '&', '\",\"'), '\"}')), '}')"
+        },
+        {
+            "print strcmp('a','b')",
+            "SELECT multiIf('a' = 'b', 0, 'a' < 'b', -1, 1)"
+        },
+        {
+            "print parse_url('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')",
+            "SELECT concat('{', concat('\"Scheme\":\"', protocol('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\"'), ',', concat('\"Host\":\"', domain('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\"'), ',', concat('\"Port\":\"', toString(port('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')), '\"'), ',', concat('\"Path\":\"', path('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\"'), ',', concat('\"Username\":\"', splitByChar(':', splitByChar('@', netloc('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'))[1])[1], '\"'), ',', concat('\"Password\":\"', splitByChar(':', splitByChar('@', netloc('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'))[1])[2], '\"'), ',', concat('\"Query Parameters\":', concat('{\"', replace(replace(queryString('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '=', '\":\"'), '&', '\",\"'), '\"}')), ',', concat('\"Fragment\":\"', fragment('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\"'), '}')"
+        },
+        {
+            "Customers | summarize t = make_list(FirstName) by FirstName",
+            "SELECT
    FirstName,
    groupArrayIf(FirstName, FirstName IS NOT NULL) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_list(FirstName, 10) by FirstName",
+            "SELECT
    FirstName,
    groupArrayIf(10)(FirstName, FirstName IS NOT NULL) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_list_if(FirstName, Age > 10) by FirstName",
+            "SELECT
    FirstName,
    groupArrayIf(FirstName, Age > 10) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_list_if(FirstName, Age > 10, 10) by FirstName",
+            "SELECT
    FirstName,
    groupArrayIf(10)(FirstName, Age > 10) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_set(FirstName) by FirstName",
+            "SELECT
    FirstName,
    groupUniqArray(FirstName) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_set(FirstName, 10) by FirstName",
+            "SELECT
    FirstName,
    groupUniqArray(10)(FirstName) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_set_if(FirstName, Age > 10) by FirstName",
+            "SELECT
    FirstName,
    groupUniqArrayIf(FirstName, Age > 10) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "Customers | summarize t = make_set_if(FirstName, Age > 10, 10) by FirstName",
+            "SELECT
    FirstName,
    groupUniqArrayIf(10)(FirstName, Age > 10) AS t
FROM Customers
GROUP BY FirstName"
+        },
+        {
+            "print output = dynamic([1, 2, 3])",
+            "SELECT [1, 2, 3] AS output"
+        },
+        {
+            "print output = dynamic(['a', 'b', 'c'])",
+            "SELECT ['a', 'b', 'c'] AS output"
+        },
+        {
+            "T | extend duration = endTime - startTime",
+            "SELECT
    * EXCEPT duration,
    endTime - startTime AS duration
FROM T"
+        },
+        {
+            "T |project endTime, startTime | extend duration = endTime - startTime",
+            "SELECT
    * EXCEPT duration,
    endTime - startTime AS duration
FROM
(
    SELECT
        endTime,
        startTime
    FROM T
)"
+        },
+        {
+            "T | extend c =c*2, b-a, d = a + b, a*b",
+            "SELECT
    * EXCEPT c EXCEPT d,
    c * 2 AS c,
    b - a AS Column1,
    a + b AS d,
    a * b AS Column2
FROM T"
         }
 })));
 
diff --git a/src/Parsers/tests/gtest_common.cpp b/src/Parsers/tests/gtest_common.cpp
new file mode 100644
index 000000000000..7710df946445
--- /dev/null
+++ b/src/Parsers/tests/gtest_common.cpp
@@ -0,0 +1,81 @@
+#include "gtest_common.h"
+
+#include <Parsers/Access/ASTAuthenticationData.h>
+#include <Parsers/Access/ASTCreateUserQuery.h>
+#include <Parsers/formatAST.h>
+#include <Parsers/parseQuery.h>
+#include <Parsers/Kusto/parseKQLQuery.h>
+
+#include <gmock/gmock.h>
+
+#include <regex>
+
+namespace
+{
+using namespace DB;
+using namespace std::literals;
+}
+
+
+TEST_P(ParserRegexTest, parseQuery)
+{
+    const auto & parser = std::get<0>(GetParam());
+    const auto & [input_text, expected_ast] = std::get<1>(GetParam());
+
+    ASSERT_TRUE(parser);
+    ASSERT_TRUE(expected_ast);
+
+    DB::ASTPtr ast;
+    ASSERT_NO_THROW(ast = parseQuery(*parser, input_text.begin(), input_text.end(), 0, 0));
+    DB::WriteBufferFromOwnString buf;
+    formatAST(*ast->clone(), buf, false, false);
+    EXPECT_THAT(buf.str(), ::testing::MatchesRegex(expected_ast));
+}
+
+TEST_P(ParserKQLTest, parseKQLQuery)
+{
+    const auto & parser = std::get<0>(GetParam());
+    const auto & [input_text, expected_ast] = std::get<1>(GetParam());
+
+    ASSERT_NE(nullptr, parser);
+
+    if (expected_ast)
+    {
+        if (std::string(expected_ast).starts_with("throws"))
+        {
+            EXPECT_THROW(parseKQLQuery(*parser, input_text.begin(), input_text.end(), 0, 0), DB::Exception);
+        }
+        else
+        {
+            DB::ASTPtr ast;
+            ASSERT_NO_THROW(ast = parseKQLQuery(*parser, input_text.begin(), input_text.end(), 0, 0));
+            if (std::string("CREATE USER or ALTER USER query") != parser->getName()
+                    && std::string("ATTACH access entity query") != parser->getName())
+            {
+                DB::WriteBufferFromOwnString buf;
+                formatAST(*ast->clone(), buf, false, false);
+                String formatted_ast = buf.str();
+                EXPECT_EQ(expected_ast, formatted_ast);
+            }
+            else
+            {
+                if (input_text.starts_with("ATTACH"))
+                {
+                    auto salt = (dynamic_cast<const ASTCreateUserQuery *>(ast.get())->auth_data)->getSalt().value_or("");
+                    EXPECT_TRUE(std::regex_match(salt, std::regex(expected_ast)));
+                }
+                else
+                {
+                    DB::WriteBufferFromOwnString buf;
+                    formatAST(*ast->clone(), buf, false, false);
+                    String formatted_ast = buf.str();
+                    EXPECT_TRUE(std::regex_match(formatted_ast, std::regex(expected_ast)));
+                }
+            }
+        }
+    }
+    else
+    {
+        ASSERT_THROW(parseKQLQuery(*parser, input_text.begin(), input_text.end(), 0, 0), DB::Exception);
+    }
+}
diff --git a/src/Parsers/tests/gtest_common.h b/src/Parsers/tests/gtest_common.h
new file mode 100644
index 000000000000..0c6b21217fbd
--- /dev/null
+++ b/src/Parsers/tests/gtest_common.h
@@ -0,0 +1,20 @@
+#pragma once
+
+#include <Parsers/IParser.h>
+
+#include <gtest/gtest.h>
+
+#include <string_view>
+
+struct ParserTestCase
+{
+    const std::string_view input_text;
+    const char * expected_ast = nullptr;
+};
+
+class ParserTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<DB::IParser>, ParserTestCase>>
+{};
+class ParserKQLTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<DB::IParser>, ParserTestCase>>
+{};
+class ParserRegexTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<DB::IParser>, ParserTestCase>>
+{};
diff --git a/tests/queries/0_stateless/02366_kql_create_table.reference b/tests/queries/0_stateless/02366_kql_create_table.reference
new file mode 100644
index 000000000000..35136b5ff425
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_create_table.reference
@@ -0,0 +1,4 @@
+-- test create table --
+Theodore
+Diaz
+Theodore	Diaz	28
diff --git a/tests/queries/0_stateless/02366_kql_create_table.sql b/tests/queries/0_stateless/02366_kql_create_table.sql
new file mode 100644
index 000000000000..b266679b06aa
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_create_table.sql
@@ -0,0 +1,29 @@
+DROP TABLE IF EXISTS Customers;
+CREATE TABLE Customers
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Occupation String,
+    Education String,
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+
+INSERT INTO Customers VALUES  ('Theodore','Diaz','Skilled Manual','Bachelors',28),('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);
+Select '-- test create table --' ;
+Select * from kql(Customers|project FirstName) limit 1;;
+DROP TABLE IF EXISTS kql_table1;
+CREATE TABLE kql_table1 ENGINE = Memory AS select *, now() as new_column From kql(Customers | project LastName | filter LastName=='Diaz');
+select LastName from kql_table1 limit 1;
+DROP TABLE IF EXISTS kql_table2;
+CREATE TABLE kql_table2
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+INSERT INTO kql_table2 select * from kql(Customers|project FirstName,LastName,Age | filter FirstName=='Theodore');
+select * from kql_table2 limit 1;
+-- select * from kql(Customers | where FirstName !in ("test", "test2"));
+DROP TABLE IF EXISTS Customers;
+DROP TABLE IF EXISTS kql_table1;
+DROP TABLE IF EXISTS kql_table2;
\ No newline at end of file
diff --git a/tests/queries/0_stateless/02366_kql_datatype.reference b/tests/queries/0_stateless/02366_kql_datatype.reference
new file mode 100644
index 000000000000..fe666f3734c7
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_datatype.reference
@@ -0,0 +1,105 @@
+-- bool
+true
+\N
+-- int
+123
+\N
+-- long
+123
+255
+-1
+\N
+456
+-- real
+0.01
+\N
+nan
+inf
+-inf
+-- datetime
+2015-12-31 23:59:59.900000000
+2015-12-31 00:00:00.000000000
+2014-05-25 08:20:03.123456000
+2014-11-08 15:55:55.000000000
+2014-11-08 15:55:00.000000000
+2014-11-08 00:00:00.000000000
+\N
+2014-05-25 08:20:03.123456000
+2014-11-08 15:55:55.123456000
+-- time
+1216984.12345
+45055.123
+86400
+-86400
+6.000000000000001e-9
+6e-7
+172800
+259200
+-- guid
+\N
+-- timespan (time)
+172800
+1800
+10
+0.1
+0.00001
+1e-7
+1120343
+-- null
+1
+\N	\N	\N	\N	\N
+-- decimal
+\N
+123.345
+100000
+-- dynamic
+\N
+1
+86400
+[1,2,3]
+[[1],[2],[3]]
+['a','b','c']
+-- cast functions
+true
+1
+-- tobool("false")
+false
+1
+-- tobool(1)
+true
+1
+-- tobool(123)
+true
+1
+-- tobool("abc")
+\N
+\N
+-- todouble()
+123.4
+\N
+-- toreal()
+123.4
+\N
+-- toint()
+1
+\N
+-- tostring()
+123
+1
+-- todatetime()
+1
+\N
+-- make_timespan()
+01:12:00	01:12:30	1.12:30:55
+-- totimespan()
+1e-7
+60
+\N
+1120343
+-- tolong()
+123
+\N
+-- todecimal()
+123.345
+\N
+\N
diff --git a/tests/queries/0_stateless/02366_kql_datatype.sql b/tests/queries/0_stateless/02366_kql_datatype.sql
new file mode 100644
index 000000000000..ecd295042984
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_datatype.sql
@@ -0,0 +1,117 @@
+set dialect = 'kusto';
+
+print '-- bool'
+print bool(true);
+print bool(true);
+print bool(null);
+print '-- int';
+print int(123);
+print int(null);
+print int('4'); -- { clientError BAD_ARGUMENTS }
+print '-- long';
+print long(123);
+print long(0xff);
+print long(-1);
+print long(null);
+print 456;
+print '-- real';
+print real(0.01);
+print real(null);
+print real(nan);
+print real(+inf);
+print real(-inf);
+print double('4.2'); -- { clientError BAD_ARGUMENTS }
+print '-- datetime';
+print datetime(2015-12-31 23:59:59.9);
+print datetime(2015-12-31);
+print datetime('2014-05-25T08:20:03.123456');
+print datetime('2014-11-08 15:55:55');
+print datetime('2014-11-08 15:55');
+print datetime('2014-11-08');
+print datetime(null);
+print datetime('2014-05-25T08:20:03.123456Z');
+print datetime('2014-11-08 15:55:55.123456Z');
+print '-- time';
+print time('14.02:03:04.12345');
+print time('12:30:55.123');
+print time(1d);
+print time(-1d);
+print time(6nanoseconds);
+print time(6tick);
+print time(2);
+print time(2) + 1d;
+print '-- guid'
+print guid(74be27de-1e4e-49d9-b579-fe0b331d3642);
+print guid(null);
+print '-- timespan (time)';
+print timespan(2d); --              2 days
+--print timespan(1.5h); -- 	        1.5 hour
+print timespan(30m); -- 	        30 minutes
+print timespan(10s); -- 	        10 seconds
+--print timespan(0.1s); -- 	        0.1 second
+print timespan(100ms); -- 	        100 millisecond
+print timespan(10microsecond); -- 	10 microseconds
+print timespan(1tick); --           100 nanoseconds
+--print timespan(1.5h) / timespan(30m);
+print timespan('12.23:12:23') / timespan(1s);
+print '-- null';
+print isnull(null);
+print bool(null), int(null), long(null), real(null), double(null);
+print '-- decimal';
+print decimal(null);
+print decimal(123.345);
+print decimal(1e5);
+print '-- dynamic'; -- no support for mixed types and bags for now
+print dynamic(null);
+print dynamic(1);
+print dynamic(timespan(1d));
+print dynamic([1,2,3]);
+print dynamic([[1], [2], [3]]);
+print dynamic(['a', "b", 'c']);
+print '-- cast functions'
+print '--tobool("true")'; -- == true
+print tobool('true'); -- == true
+print tobool('true') == toboolean('true'); -- == true
+print '-- tobool("false")'; -- == false
+print tobool('false'); -- == false
+print tobool('false') == toboolean('false'); -- == false
+print '-- tobool(1)'; -- == true
+print tobool(1); -- == true
+print tobool(1) == toboolean(1); -- == true
+print '-- tobool(123)'; -- == true
+print tobool(123); -- == true
+print tobool(123) == toboolean(123); -- == true
+print '-- tobool("abc")'; -- == null
+print tobool('abc'); -- == null
+print tobool('abc') == toboolean('abc'); -- == null
+print '-- todouble()';
+print todouble('123.4');
+print todouble('abc') == null;
+print '-- toreal()';
+print toreal("123.4");
+print toreal('abc') == null;
+print '-- toint()';
+print toint("123") == int(123);
+print toint('abc');
+print '-- tostring()';
+print tostring(123);
+print tostring(null) == '';
+print '-- todatetime()';
+print todatetime("2015-12-24") == datetime(2015-12-24);
+print todatetime('abc') == null;
+print '-- make_timespan()';
+print v1=make_timespan(1,12), v2=make_timespan(1,12,30), v3=make_timespan(1,12,30,55.123);
+print '-- totimespan()';
+print totimespan(1tick);
+print totimespan('0.00:01:00');
+print totimespan('abc');
+print totimespan('12.23:12:23') / totimespan(1s);
+-- print totimespan(strcat('12.', '23', ':12:', '23')) / timespan(1s); -> 1120343
+print '-- tolong()';
+print tolong('123');
+print tolong('abc');
+print '-- todecimal()';
+print todecimal(123.345);
+print todecimal(null);
+print todecimal('abc');
+-- print todecimal(4 * 2 + 3); -> 11
diff --git a/tests/queries/0_stateless/02366_kql_distinct.reference b/tests/queries/0_stateless/02366_kql_distinct.reference
new file mode 100644
index 000000000000..2100f44f18c9
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_distinct.reference
@@ -0,0 +1,27 @@
+--  distinct * --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+\N	why	Professional	Partial College	38
+--  distinct one column --
+Skilled Manual
+Management abcd defg
+Professional
+--  distinct two column --
+Skilled Manual	Bachelors
+Management abcd defg	Bachelors
+Skilled Manual	Graduate Degree
+Professional	Graduate Degree
+Professional	Partial College
+--  distinct with where --
+Skilled Manual	Bachelors
+Management abcd defg	Bachelors
+Skilled Manual	Graduate Degree
+Professional	Graduate Degree
+Professional	Partial College
+--  distinct with where, order --
+Skilled Manual	Bachelors
+Skilled Manual	Graduate Degree
+Professional	Graduate Degree
diff --git a/tests/queries/0_stateless/02366_kql_distinct.sql b/tests/queries/0_stateless/02366_kql_distinct.sql
new file mode 100644
index 000000000000..3c997eb4865b
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_distinct.sql
@@ -0,0 +1,28 @@
+DROP TABLE IF EXISTS Customers;
+CREATE TABLE Customers
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Occupation String,
+    Education String,
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+
+INSERT INTO Customers VALUES ('Theodore','Diaz','Skilled Manual','Bachelors',28), ('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);
+
+set dialect = 'kusto';
+
+print '--  distinct * --';
+Customers | distinct *;
+
+print '--  distinct one column --';
+Customers | distinct Occupation;
+
+print '--  distinct two column --';
+Customers | distinct Occupation, Education;
+
+print '--  distinct with where --';
+Customers where Age <30 | distinct Occupation, Education;
+
+print '--  distinct with where, order --';
+Customers |where Age <30 | order by Age| distinct Occupation, Education;
diff --git a/tests/queries/0_stateless/02366_kql_extend.reference b/tests/queries/0_stateless/02366_kql_extend.reference
new file mode 100644
index 000000000000..2936c9ea19c1
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_extend.reference
@@ -0,0 +1,32 @@
+-- extend #1 --
+Aldi	Apple	4	2016-09-10	400
+Costco	Apple	2	2016-09-11	200
+-- extend #2 --
+Apple	200
+Apple	400
+-- extend #3 --
+Apple cost 480 on average based on 5 samples.
+Snargaluff cost 28080 on average based on 5 samples.
+-- extend #4 --
+1
+-- extend #5 --
+Aldi	Apple	4	2016-09-10	Apple was purchased from Aldi for $4 on 2016-09-10	400
+Costco	Apple	2	2016-09-11	Apple was purchased from Costco for $2 on 2016-09-11	200
+-- extend #6 --
+Aldi	Apple	2016-09-10	400
+Costco	Apple	2016-09-11	200
+Aldi	Apple	2016-09-10	600
+Costco	Snargaluff	2016-09-12	10000
+Aldi	Apple	2016-09-12	700
+Aldi	Snargaluff	2016-09-11	40000
+Costco	Snargaluff	2016-09-12	10400
+Aldi	Apple	2016-09-12	500
+Aldi	Snargaluff	2016-09-11	60000
+Costco	Snargaluff	2016-09-10	20000
+-- extend #7 --
+5
+-- extend #8 --
+-- extend #9 --
+-- extend #10 --
+-- extend #11 --
+5	[2,1]
diff --git a/tests/queries/0_stateless/02366_kql_extend.sql b/tests/queries/0_stateless/02366_kql_extend.sql
new file mode 100644
index 000000000000..3de489b08156
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_extend.sql
@@ -0,0 +1,58 @@
+-- datatable(Supplier:string, Fruit:string, Price: real, Purchase:datetime)
+-- [
+--     'Aldi','Apple',4,'2016-09-10',
+--     'Costco','Apple',2,'2016-09-11',
+--     'Aldi','Apple',6,'2016-09-10',
+--     'Costco','Snargaluff',100,'2016-09-12',
+--     'Aldi','Apple',7,'2016-09-12',
+--     'Aldi','Snargaluff',400,'2016-09-11',
+--     'Costco','Snargaluff',104,'2016-09-12',
+--     'Aldi','Apple',5,'2016-09-12',
+--     'Aldi','Snargaluff',600,'2016-09-11',
+--     'Costco','Snargaluff',200,'2016-09-10',
+-- ]
+
+DROP TABLE IF EXISTS Ledger;
+CREATE TABLE Ledger
+(    
+   Supplier Nullable(String),
+   Fruit String ,
+   Price Float64,
+   Purchase Date 
+) ENGINE = Memory;
+INSERT INTO Ledger VALUES  ('Aldi','Apple',4,'2016-09-10'), ('Costco','Apple',2,'2016-09-11'), ('Aldi','Apple',6,'2016-09-10'), ('Costco','Snargaluff',100,'2016-09-12'), ('Aldi','Apple',7,'2016-09-12'), ('Aldi','Snargaluff',400,'2016-09-11'),('Costco','Snargaluff',104,'2016-09-12'),('Aldi','Apple',5,'2016-09-12'),('Aldi','Snargaluff',600,'2016-09-11'),('Costco','Snargaluff',200,'2016-09-10');
+
+set dialect = 'kusto';
+
+print '-- extend #1 --';
+Ledger | extend PriceInCents = 100 * Price | take 2;
+
+print '-- extend #2 --';
+Ledger | extend PriceInCents = 100 * Price | sort by PriceInCents asc | project Fruit, PriceInCents | take 2;
+
+print '-- extend #3 --';
+Ledger | extend PriceInCents = 100 * Price | sort by PriceInCents asc | project Fruit, PriceInCents | summarize AveragePrice = avg(PriceInCents), Purchases = count() by Fruit | extend Sentence = strcat(Fruit, ' cost ', tostring(AveragePrice), ' on average based on ', tostring(Purchases), ' samples.') | project Sentence;
+
+print '-- extend #4 --';
+Ledger | extend a = Price | extend b = a | extend c = a, d = b + 500 | extend Pass = bool(b == a and c == a and d == b + 500) | summarize binary_all_and(Pass);
+
+print '-- extend #5 --';
+Ledger | take 2 | extend strcat(Fruit, ' was purchased from ', Supplier, ' for $', tostring(Price), ' on ', tostring(Purchase)) | extend PriceInCents = 100 * Price;
+
+print '-- extend #6 --';
+Ledger | extend Price = 100 * Price;
+
+print '-- extend #7 --';
+print a = 4 | extend a = 5;
+
+print '-- extend #8 --';
+-- print x = 5 | extend array_sort_desc(range(0, x), range(1, x + 1))
+
+print '-- extend #9 --';
+print x = 19 | extend = 4 + ; -- { clientError SYNTAX_ERROR }
+
+print '-- extend #10 --';
+Ledger | extend PriceInCents = * Price | sort by PriceInCents asc | project Fruit, PriceInCents | summarize AveragePrice = avg(PriceInCents), Purchases = count() by Fruit | extend Sentence = strcat(Fruit, ' cost ', tostring(AveragePrice), ' on average based on ', tostring(Purchases), ' samples.') | project Sentence; -- { clientError SYNTAX_ERROR }
+
+print '-- extend #11 --'; -- should ideally return this in the future: 5	[2,1] because of the alias ex
+print x = 5 | extend ex = array_sort_desc(dynamic([1, 2]), dynamic([3, 4]));
diff --git a/tests/queries/0_stateless/02366_kql_func_binary.reference b/tests/queries/0_stateless/02366_kql_func_binary.reference
new file mode 100644
index 000000000000..6276cd6d8675
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_binary.reference
@@ -0,0 +1,7 @@
+ -- binary functions
+4	7
+1
+1
+1
+7	3
+1
diff --git a/tests/queries/0_stateless/02366_kql_func_binary.sql b/tests/queries/0_stateless/02366_kql_func_binary.sql
new file mode 100644
index 000000000000..824022b564ce
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_binary.sql
@@ -0,0 +1,8 @@
+set dialect='kusto';
+print ' -- binary functions';
+print binary_and(4,7), binary_or(4,7);
+print binary_shift_left(1, 1) == binary_shift_left(1, 65);
+print binary_shift_right(2, 1) == binary_shift_right(2, 65);
+print binary_shift_right(binary_shift_left(1, 65), 65) == 1;
+print binary_xor(2, 5), bitset_count_ones(42);
+print bitset_count_ones(binary_shift_left(binary_and(4,7), 1));
diff --git a/tests/queries/0_stateless/02366_kql_func_datetime.reference b/tests/queries/0_stateless/02366_kql_func_datetime.reference
new file mode 100644
index 000000000000..40d8d7e19ac9
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_datetime.reference
@@ -0,0 +1,76 @@
+-- dayofmonth()
+31
+-- dayofweek()
+4.00:00:00
+-- dayofyear()
+365
+-- getmonth()
+10
+-- getyear()
+2015
+-- hoursofday()
+23
+-- startofday()
+2017-01-01 00:00:00.000000000
+2016-12-31 00:00:00.000000000
+2017-01-02 00:00:00.000000000
+-- endofday()
+2017-01-01 23:59:59.999999000
+2016-12-31 23:59:59.999999000
+2017-01-02 23:59:59.999999000
+-- endofmonth()
+2017-01-31 23:59:59.999999000
+2016-12-31 23:59:59.999999000
+2017-02-28 23:59:59.999999000
+2022-09-30 23:59:59.999999000
+-- startofweek()
+2017-01-01 00:00:00.000000000
+2016-12-25 00:00:00.000000000
+2017-01-08 00:00:00.000000000
+-- endofweek()
+2017-01-07 23:59:59.999999000
+2016-12-31 23:59:59.999999000
+2017-01-14 23:59:59.999999000
+-- startofyear()
+2017-01-01 00:00:00.000000000
+2016-01-01 00:00:00.000000000
+2018-01-01 00:00:00.000000000
+-- endofyear()
+2017-12-31 23:59:59.999999000
+2016-12-31 23:59:59.999999000
+2018-12-31 23:59:59.999999000
+-- unixtime_seconds_todatetime()
+2019-01-01 00:00:00.000000000
+1970-01-02 00:00:00.000000000
+1969-12-31 00:00:00.000000000
+-- unixtime_microseconds_todatetime
+2019-01-01 00:00:00.000000
+-- unixtime_milliseconds_todatetime()
+2019-01-01 00:00:00.000
+-- unixtime_nanoseconds_todatetime()
+2019-01-01 00:00:00.000000000
+-- weekofyear()
+52
+-- monthofyear()
+12
+-- weekofyear()
+52
+-- now()
+1
+-- make_datetime()
+1
+2017-10-01 12:10:00.0000000
+2017-10-01 12:11:00.0000000
+-- format_datetime
+15-12-14 02:03:04.1234500
+17-01-29 [09:00:05]	2017-01-29 [09:00:05]	17-01-29 [09:00:05 AM]
+-- format_timespan()
+02:03:04.1234500
+29.09:00:05:12
+-- ago()
+-- datetime_diff()
+17	2	13	4	29	2	5	10
+-- datetime_part()
+2017	4	10	44	30	303	01	02	03
+-- datetime_add()
+2018-01-01 00:00:00.0000000	2017-04-01 00:00:00.0000000	2017-02-01 00:00:00.0000000	2017-01-08 00:00:00.0000000	2017-01-02 00:00:00.0000000	2017-01-01 01:00:00.0000000	2017-01-01 00:01:00.0000000	2017-01-01 00:00:01.0000000
diff --git a/tests/queries/0_stateless/02366_kql_func_datetime.sql b/tests/queries/0_stateless/02366_kql_func_datetime.sql
new file mode 100644
index 000000000000..b1fba4166a9e
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_datetime.sql
@@ -0,0 +1,86 @@
+set dialect = 'kusto';
+
+print '-- dayofmonth()';
+print dayofmonth(datetime(2015-12-31));
+print '-- dayofweek()';
+print dayofweek(datetime(2015-12-31));
+print '-- dayofyear()';
+print dayofyear(datetime(2015-12-31));
+print '-- getmonth()';
+print getmonth(datetime(2015-10-12));
+print '-- getyear()';
+print getyear(datetime(2015-10-12));
+print '-- hoursofday()';
+print hourofday(datetime(2015-12-31 23:59:59.9));
+print '-- startofday()';
+print startofday(datetime(2017-01-01 10:10:17));
+print startofday(datetime(2017-01-01 10:10:17), -1);
+print startofday(datetime(2017-01-01 10:10:17), 1);
+print '-- endofday()';
+print endofday(datetime(2017-01-01 10:10:17));
+print endofday(datetime(2017-01-01 10:10:17), -1);
+print endofday(datetime(2017-01-01 10:10:17), 1);
+print '-- endofmonth()';
+print endofmonth(datetime(2017-01-01 10:10:17));
+print endofmonth(datetime(2017-01-01 10:10:17), -1);
+print endofmonth(datetime(2017-01-01 10:10:17), 1);
+print endofmonth(datetime(2022-09-23));
+print '-- startofweek()';
+print startofweek(datetime(2017-01-01 10:10:17));
+print startofweek(datetime(2017-01-01 10:10:17), -1);
+print startofweek(datetime(2017-01-01 10:10:17), 1);
+print '-- endofweek()';
+print endofweek(datetime(2017-01-01 10:10:17));
+print endofweek(datetime(2017-01-01 10:10:17), -1);
+print endofweek(datetime(2017-01-01 10:10:17), 1);
+print '-- startofyear()';
+print startofyear(datetime(2017-01-01 10:10:17));
+print startofyear(datetime(2017-01-01 10:10:17), -1);
+print startofyear(datetime(2017-01-01 10:10:17), 1);
+print '-- endofyear()';
+print endofyear(datetime(2017-01-01 10:10:17));
+print endofyear(datetime(2017-01-01 10:10:17), -1);
+print endofyear(datetime(2017-01-01 10:10:17), 1);
+print '-- unixtime_seconds_todatetime()';
+print unixtime_seconds_todatetime(1546300800);
+print unixtime_seconds_todatetime(1d);
+print unixtime_seconds_todatetime(-1d);
+print '-- unixtime_microseconds_todatetime';
+print unixtime_microseconds_todatetime(1546300800000000);
+print '-- unixtime_milliseconds_todatetime()';
+print unixtime_milliseconds_todatetime(1546300800000);
+print '-- unixtime_nanoseconds_todatetime()';
+print unixtime_nanoseconds_todatetime(1546300800000000000);
+print '-- weekofyear()';
+print week_of_year(datetime(2000-01-01));
+print '-- monthofyear()';
+print monthofyear(datetime(2015-12-31));
+print '-- weekofyear()';
+print week_of_year(datetime(2000-01-01));
+print '-- now()';
+print getyear(now(-2d))>1900;
+print '-- make_datetime()';
+print make_datetime(2017,10,01,12,10) == datetime(2017-10-01 12:10:00);
+print year_month_day_hour_minute = make_datetime(2017,10,01,12,10);
+print year_month_day_hour_minute_second = make_datetime(2017,10,01,12,11,0.1234567);
+print '-- format_datetime';
+print format_datetime(datetime(2015-12-14 02:03:04.12345), 'y-M-d h:m:s.fffffff');
+print v1=format_datetime(datetime(2017-01-29 09:00:05),'yy-MM-dd [HH:mm:ss]'), v2=format_datetime(datetime(2017-01-29 09:00:05), 'yyyy-M-dd [H:mm:ss]'), v3=format_datetime(datetime(2017-01-29 09:00:05), 'yy-MM-dd [hh:mm:ss tt]');
+print '-- format_timespan()';
+print format_timespan(time('14.02:03:04.12345'), 'h:m:s.fffffff');
+print v1=format_timespan(time('29.09:00:05.12345'), 'dd.hh:mm:ss:FF');
+-- print v2=format_timespan(time('29.09:00:05.12345'), 'ddd.h:mm:ss [fffffff]'); == '029.9:00:05 [1234500]'
+print '-- ago()';
+-- print ago(1d) - now();
+print '-- datetime_diff()';
+print year = datetime_diff('year',datetime(2017-01-01),datetime(2000-12-31)), quarter = datetime_diff('quarter',datetime(2017-07-01),datetime(2017-03-30)), month = datetime_diff('month',datetime(2017-01-01),datetime(2015-12-30)), week = datetime_diff('week',datetime(2017-10-29 00:00),datetime(2017-09-30 23:59)), day = datetime_diff('day',datetime(2017-10-29 00:00),datetime(2017-09-30 23:59)), hour = datetime_diff('hour',datetime(2017-10-31 01:00),datetime(2017-10-30 23:59)), minute = datetime_diff('minute',datetime(2017-10-30 23:05:01),datetime(2017-10-30 23:00:59)), second = datetime_diff('second',datetime(2017-10-30 23:00:10.100),datetime(2017-10-30 23:00:00.900));
+-- millisecond = datetime_diff('millisecond',datetime(2017-10-30 23:00:00.200100),datetime(2017-10-30 23:00:00.100900)),
+-- microsecond = datetime_diff('microsecond',datetime(2017-10-30 23:00:00.1009001),datetime(2017-10-30 23:00:00.1008009)),
+-- nanosecond = datetime_diff('nanosecond',datetime(2017-10-30 23:00:00.0000000),datetime(2017-10-30 23:00:00.0000007))
+print '-- datetime_part()';
+print year = datetime_part("year", datetime(2017-10-30 01:02:03.7654321)),quarter = datetime_part("quarter", datetime(2017-10-30 01:02:03.7654321)),month = datetime_part("month", datetime(2017-10-30 01:02:03.7654321)),weekOfYear = datetime_part("week_of_year", datetime(2017-10-30 01:02:03.7654321)),day = datetime_part("day", datetime(2017-10-30 01:02:03.7654321)),dayOfYear = datetime_part("dayOfYear", datetime(2017-10-30 01:02:03.7654321)),hour = datetime_part("hour", datetime(2017-10-30 01:02:03.7654321)),minute = datetime_part("minute", datetime(2017-10-30 01:02:03.7654321)),second = datetime_part("second", datetime(2017-10-30 01:02:03.7654321));
+-- millisecond = datetime_part("millisecond", dt),
+-- microsecond = datetime_part("microsecond", dt),
+-- nanosecond = datetime_part("nanosecond", dt)
+print '-- datetime_add()';
+print  year = datetime_add('year',1,make_datetime(2017,1,1)),quarter = datetime_add('quarter',1,make_datetime(2017,1,1)),month = datetime_add('month',1,make_datetime(2017,1,1)),week = datetime_add('week',1,make_datetime(2017,1,1)),day = datetime_add('day',1,make_datetime(2017,1,1)),hour = datetime_add('hour',1,make_datetime(2017,1,1)),minute = datetime_add('minute',1,make_datetime(2017,1,1)),second = datetime_add('second',1,make_datetime(2017,1,1));
\ No newline at end of file
diff --git a/tests/queries/0_stateless/02366_kql_func_dynamic.reference b/tests/queries/0_stateless/02366_kql_func_dynamic.reference
new file mode 100644
index 000000000000..564f1eebc4bb
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_dynamic.reference
@@ -0,0 +1,152 @@
+-- constant index value
+1	c	['A',NULL,'C']
+-- array_length()
+1
+1
+-- array_sum()
+1
+1
+-- array_index_of()
+3
+1
+-- array_iif()
+[1,5,3]
+[1,5,3]
+[1,5,NULL]
+[NULL,NULL,NULL]
+-- array_concat()
+[1,2,3,4,5,6]
+-- array_reverse()
+[]
+[1]
+[4,3,2,1]
+['example','an','is','this']
+-- array_rotate_left()
+[]
+[]
+[]
+[3,4,5,1,2]
+[1,2,3,4,5]
+[3,4,5,1,2]
+[4,5,1,2,3]
+[1,2,3,4,5]
+[4,5,1,2,3]
+-- array_rotate_right()
+[]
+[]
+[]
+[4,5,1,2,3]
+[1,2,3,4,5]
+[4,5,1,2,3]
+[3,4,5,1,2]
+[1,2,3,4,5]
+[3,4,5,1,2]
+-- array_shift_left()
+[]
+[]
+[]
+[3,4,5,NULL,NULL]
+[NULL,NULL,1,2,3]
+[3,4,5,-1,-1]
+['c','','']
+-- array_shift_right()
+[]
+[]
+[]
+[3,4,5,NULL,NULL]
+[NULL,NULL,1,2,3]
+[3,4,5,-1,-1]
+['c','','']
+-- array_slice()
+[3,4]
+-- array_split()
+[[1],[2,3],[4,5]]
+[[1,2],[3,4,5]]
+[[1],[2,3],[4,5]]
+[[1,2,3,4],[],[4,5]]
+-- array_sort_asc()
+(['a','c','c','d',NULL])
+([1,2,3,4])
+['a','b','c']
+(['p','q','r'],['hello','clickhouse','world'])
+([NULL,'a','c','c','d'])
+([NULL,'a','c','c','d'])
+([NULL,NULL,NULL])
+[1,2,3,NULL,NULL]
+['a','e','b','c','d']
+(['George','John','Paul','Ringo'])
+(['blue','green','yellow',NULL,NULL])
+([NULL,NULL,'blue','green','yellow'])
+-- array_sort_desc()
+(['d','c','c','a',NULL])
+([4,3,2,1])
+['c','b','a']
+(['r','q','p'],['world','clickhouse','hello'])
+([NULL,'d','c','c','a'])
+([NULL,'d','c','c','a'])
+([NULL,NULL,NULL])
+[3,2,1,NULL,NULL]
+['d','c','b','e','a']
+(['Ringo','Paul','John','George'])
+(['yellow','green','blue',NULL,NULL])
+([NULL,NULL,'yellow','green','blue'])
+-- jaccard_index()
+0.75
+0
+0
+nan
+0
+0.75
+0.25
+-- pack_array()
+1	2	4	[1,2,4]
+['ab','0.0.0.42','4.2']
+-- repeat()
+[]
+[1,1,1]
+['asd','asd','asd']
+[86400,86400,86400]
+[true,true,true]
+[NULL]
+[NULL]
+-- set_difference()
+[]
+[]
+[]
+[]
+[4,5,6]
+[4]
+[1,3]
+[1,2,3]
+['d','s']
+['Chewbacca','Han Solo']
+-- set_has_element()
+0
+1
+0
+1
+0
+-- set_intersect()
+[]
+[1,2,3]
+[1,2,3]
+[]
+[5]
+[]
+['a']
+['Darth Vader']
+-- set_union()
+[]
+[1,2,3]
+[1,2,3,4,5,6]
+[1,2,3,4]
+[1,2,3,4,5]
+[1,2,3]
+['a','d','f','s']
+['Chewbacca','Darth Sidious','Darth Vader','Han Solo']
+-- zip()
+[]
+[[1,2],[3,4],[5,6]]
+[['Darth','Vader','has a suit'],['Master','Yoda','doesn\'t have a suit']]
+[[1,10],[2,20],[3,NULL]]
+[[NULL,1],[NULL,2],[NULL,3]]
diff --git a/tests/queries/0_stateless/02366_kql_func_dynamic.sql b/tests/queries/0_stateless/02366_kql_func_dynamic.sql
new file mode 100644
index 000000000000..b0956f032d0c
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_dynamic.sql
@@ -0,0 +1,161 @@
+DROP TABLE IF EXISTS array_test;
+CREATE TABLE array_test (floats Array(Float64),
+                         strings Array(String),
+                         nullable_strings Array(Nullable(String))
+                         ) ENGINE=Memory;
+INSERT INTO array_test VALUES([1.0, 2.5], ['a', 'c'], ['A', NULL, 'C']);
+set dialect = 'kusto';
+print '-- constant index value';
+array_test | project floats[0], strings[1], nullable_strings;
+print '-- array_length()';
+print array_length(dynamic(['John', 'Denver', 'Bob', 'Marley'])) == 4;
+print array_length(dynamic([1, 2, 3])) == 3;
+print '-- array_sum()';
+print array_sum(dynamic([2, 5, 3])) == 10;
+print array_sum(dynamic([2.5, 5.5, 3])) == 11;
+print '-- array_index_of()';
+print array_index_of(dynamic(['John', 'Denver', 'Bob', 'Marley']), 'Marley');
+print array_index_of(dynamic([1, 2, 3]), 2);
+print '-- array_iif()';
+print array_iif(dynamic([true,false,true]), dynamic([1,2,3]), dynamic([4,5,6]));
+print array_iif(dynamic([1,0,1]), dynamic([1,2,3]), dynamic([4,5,6]));
+print array_iif(dynamic([true,false,true]), dynamic([1,2]), dynamic([4,5,6]));
+print array_iif(dynamic(['a','b','c']), dynamic([1,2,3]), dynamic([4,5,6]));
+print '-- array_concat()';
+print array_concat(dynamic([1,2,3]),dynamic([4,5,6]));
+print '-- array_reverse()';
+print array_reverse(dynamic([]));
+print array_reverse(dynamic([1]));
+print array_reverse(dynamic([1,2,3,4]));
+print array_reverse(dynamic(["this", "is", "an", "example"]));
+print '-- array_rotate_left()';
+print array_rotate_left(dynamic([]), 0);
+print array_rotate_left(dynamic([]), 500);
+print array_rotate_left(dynamic([]), -500);
+print array_rotate_left(dynamic([1,2,3,4,5]), 2);
+print array_rotate_left(dynamic([1,2,3,4,5]), 5);
+print array_rotate_left(dynamic([1,2,3,4,5]), 7);
+print array_rotate_left(dynamic([1,2,3,4,5]), -2);
+print array_rotate_left(dynamic([1,2,3,4,5]), -5);
+print array_rotate_left(dynamic([1,2,3,4,5]), -7);
+print '-- array_rotate_right()';
+print array_rotate_right(dynamic([]), 0);
+print array_rotate_right(dynamic([]), 500);
+print array_rotate_right(dynamic([]), -500);
+print array_rotate_right(dynamic([1,2,3,4,5]), 2);
+print array_rotate_right(dynamic([1,2,3,4,5]), 5);
+print array_rotate_right(dynamic([1,2,3,4,5]), 7);
+print array_rotate_right(dynamic([1,2,3,4,5]), -2);
+print array_rotate_right(dynamic([1,2,3,4,5]), -5);
+print array_rotate_right(dynamic([1,2,3,4,5]), -7);
+print '-- array_shift_left()';
+print array_shift_left(dynamic([]), 0);
+print array_shift_left(dynamic([]), 555);
+print array_shift_left(dynamic([]), -555);
+print array_shift_left(dynamic([1,2,3,4,5]), 2);
+print array_shift_left(dynamic([1,2,3,4,5]), -2);
+print array_shift_left(dynamic([1,2,3,4,5]), 2, -1);
+print array_shift_left(dynamic(['a', 'b', 'c']), 2);
+print '-- array_shift_right()';
+print array_shift_left(dynamic([]), 0);
+print array_shift_left(dynamic([]), 555);
+print array_shift_left(dynamic([]), -555);
+print array_shift_right(dynamic([1,2,3,4,5]), -2);
+print array_shift_right(dynamic([1,2,3,4,5]), 2);
+print array_shift_right(dynamic([1,2,3,4,5]), -2, -1);
+print array_shift_right(dynamic(['a', 'b', 'c']), -2);
+print '-- array_slice()';
+--print array_slice(dynamic([1,2,3]), 1, 2); -- will enable whe analyzer dixed
+print array_slice(dynamic([1,2,3,4,5]), -3, -2);
+print '-- array_split()';
+print array_split(dynamic([1,2,3,4,5]), dynamic([1,-2]));
+print array_split(dynamic([1,2,3,4,5]), 2);
+print array_split(dynamic([1,2,3,4,5]), dynamic([1,3]));
+print array_split(dynamic([1,2,3,4,5]), dynamic([-1,-2]));
+print '-- array_sort_asc()';
+print array_sort_asc(dynamic([null, 'd', 'a', 'c', 'c']));
+print array_sort_asc(dynamic([4, 1, 3, 2]));
+print array_sort_asc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))[0];
+print array_sort_asc(dynamic(['q', 'p', 'r']), dynamic(['clickhouse','hello', 'world']));
+print array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , false);
+print array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2);
+print array_sort_asc( dynamic([null, null, null]) , false);
+print array_sort_asc(dynamic([2, 1, null,3, null]), dynamic([20, 10, 40, 30, 50]), 1 < 2)[0];
+print array_sort_asc(dynamic(['1','3','4','5','2']),dynamic(["a","b","c","d","e"]), dynamic(["a","b","c","d","e"]), dynamic(["a","b","c","d","e"]))[3];
+print array_sort_asc(split("John,Paul,George,Ringo", ","));
+print array_sort_asc(dynamic([null,"blue","yellow","green",null]));
+print array_sort_asc(dynamic([null,"blue","yellow","green",null]), false);
+print '-- array_sort_desc()';
+print array_sort_desc(dynamic([null, 'd', 'a', 'c', 'c']));
+print array_sort_desc(dynamic([4, 1, 3, 2]));
+print array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))[0];
+print array_sort_desc(dynamic(['q', 'p', 'r']), dynamic(['clickhouse','hello', 'world']));
+print array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , false);
+print array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2);
+print array_sort_desc( dynamic([null, null, null]) , false);
+print array_sort_desc(dynamic([2, 1, null,3, null]), dynamic([20, 10, 40, 30, 50]), 1 < 2)[0];
+print array_sort_desc(dynamic(['1','3','4','5','2']),dynamic(["a","b","c","d","e"]), dynamic(["a","b","c","d","e"]), dynamic(["a","b","c","d","e"]))[3];
+print array_sort_desc(split("John,Paul,George,Ringo", ","));
+print array_sort_desc(dynamic([null,"blue","yellow","green",null]));
+print array_sort_desc(dynamic([null,"blue","yellow","green",null]), false);
+print '-- jaccard_index()';
+print jaccard_index(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3, 4, 4, 4]));
+print jaccard_index(dynamic([1, 2, 3]), dynamic([]));
+print jaccard_index(dynamic([]), dynamic([1, 2, 3, 4]));
+print jaccard_index(dynamic([]), dynamic([]));
+print jaccard_index(dynamic([1, 2, 3]), dynamic([4, 5, 6, 7]));
+print jaccard_index(dynamic(['a', 's', 'd']), dynamic(['f', 'd', 's', 'a']));
+print jaccard_index(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader']));
+print '-- pack_array()';
+print pack_array(); -- { clientError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }
+print x = 1 | extend y = x * 2 | extend z = y * 2 | extend pack_array(x,y,z);
+print pack_array(strcat('a', 'b'), format_ipv4(42), tostring(4.2));
+print '-- repeat()';
+print repeat(1, 0);
+print repeat(1, 3);
+print repeat("asd", 3);
+print repeat(timespan(1d), 3);
+print repeat(true, 3);
+print repeat(1, -3);
+print repeat(6.7,-4);
+print '-- set_difference()';
+print set_difference(dynamic([]), dynamic([]));
+print set_difference(dynamic([]), dynamic([9]));
+print set_difference(dynamic([]), dynamic(["asd"]));
+print set_difference(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3]));
+print array_sort_asc(set_difference(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[0];
+print set_difference(dynamic([4]), dynamic([1, 2, 3]));
+print array_sort_asc(set_difference(dynamic([1, 2, 3, 4, 5]), dynamic([5]), dynamic([2, 4])))[0];
+print array_sort_asc(set_difference(dynamic([1, 2, 3]), dynamic([])))[0];
+print array_sort_asc(set_difference(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])))[0];
+print array_sort_asc(set_difference(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])))[0];
+print '-- set_has_element()';
+print set_has_element(dynamic([]), 9);
+print set_has_element(dynamic(["this", "is", "an", "example"]), "example");
+print set_has_element(dynamic(["this", "is", "an", "example"]), "examplee");
+print set_has_element(dynamic([1, 2, 3]), 2);
+print set_has_element(dynamic([1, 2, 3, 4.2]), 4);
+print '-- set_intersect()';
+print set_intersect(dynamic([]), dynamic([]));
+print array_sort_asc(set_intersect(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])))[0];
+print array_sort_asc(set_intersect(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[0];
+print set_intersect(dynamic([4]), dynamic([1, 2, 3]));
+print set_intersect(dynamic([1, 2, 3, 4, 5]), dynamic([1, 3, 5]), dynamic([2, 5]));
+print set_intersect(dynamic([1, 2, 3]), dynamic([]));
+print set_intersect(dynamic(['a', 's', 'd']), dynamic(['a', 'f']));
+print set_intersect(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader']));
+print '-- set_union()';
+print set_union(dynamic([]), dynamic([]));
+print array_sort_asc(set_union(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])))[0];
+print array_sort_asc(set_union(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[0];
+print array_sort_asc(set_union(dynamic([4]), dynamic([1, 2, 3])))[0];
+print array_sort_asc(set_union(dynamic([1, 3, 4]), dynamic([5]), dynamic([2, 4])))[0];
+print array_sort_asc(set_union(dynamic([1, 2, 3]), dynamic([])))[0];
+print array_sort_asc(set_union(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])))[0];
+print array_sort_asc(set_union(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])))[0];
+print '-- zip()';
+print zip(dynamic([]), dynamic([]));
+print zip(dynamic([1,3,5]), dynamic([2,4,6]));
+print zip(dynamic(['Darth','Master']), dynamic(['Vader','Yoda']), dynamic(['has a suit','doesn\'t have a suit']));
+print zip(dynamic([1,2,3]), dynamic([10,20]));
+print zip(dynamic([]), dynamic([1,2,3]));
\ No newline at end of file
diff --git a/tests/queries/0_stateless/02366_kql_func_ip.reference b/tests/queries/0_stateless/02366_kql_func_ip.reference
new file mode 100644
index 000000000000..2a0bbf53fff4
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_ip.reference
@@ -0,0 +1,123 @@
+-- ipv4_is_private(\'127.0.0.1\')
+0
+-- ipv4_is_private(\'10.1.2.3\')
+1
+-- ipv4_is_private(\'192.168.1.1/24\')
+1
+ipv4_is_private(strcat(\'192.\',\'168.\',\'1.\',\'1\',\'/24\'))
+1
+-- ipv4_is_private(\'abc\')
+\N
+-- ipv4_netmask_suffix(\'192.168.1.1/24\')
+24
+-- ipv4_netmask_suffix(\'192.168.1.1\')
+32
+-- ipv4_netmask_suffix(\'127.0.0.1/16\')
+16
+-- ipv4_netmask_suffix(\'abc\')
+\N
+ipv4_netmask_suffix(strcat(\'127.\', \'0.\', \'0.1/16\'))
+16
+-- ipv4_is_in_range(\'127.0.0.1\', \'127.0.0.1\')
+1
+-- ipv4_is_in_range(\'192.168.1.6\', \'192.168.1.1/24\')
+1
+-- ipv4_is_in_range(\'192.168.1.1\', \'192.168.2.1/24\')
+0
+-- ipv4_is_in_range(strcat(\'192.\',\'168.\', \'1.1\'), \'192.168.2.1/24\')
+0
+-- ipv4_is_in_range(\'abc\', \'127.0.0.1\')
+\N
+-- parse_ipv6(127.0.0.1)
+0000:0000:0000:0000:0000:ffff:7f00:0001
+-- parse_ipv6(fe80::85d:e82c:9446:7994)
+fe80:0000:0000:0000:085d:e82c:9446:7994
+-- parse_ipv4(\'127.0.0.1\')
+2130706433
+-- parse_ipv4(\'192.1.168.1\') < parse_ipv4(\'192.1.168.2\')
+1
+-- parse_ipv4(arrayStringConcat([\'127\', \'0\', \'0\', \'1\'], \'.\'))
+-- parse_ipv4_mask(\'127.0.0.1\', 24) == 2130706432
+2130706432
+-- parse_ipv4_mask(\'abc\', 31)
+\N
+\N
+-- parse_ipv4_mask(\'192.1.168.2\', 31) == parse_ipv4_mask(\'192.1.168.3\', 31)
+3221334018
+3221334018
+-- ipv4_is_match(\'127.0.0.1\', \'127.0.0.1\')
+1
+-- ipv4_is_match(\'192.168.1.1\', \'192.168.1.255\')
+0
+-- ipv4_is_match(\'192.168.1.1/24\', \'192.168.1.255/24\')
+1
+-- ipv4_is_match(\'192.168.1.1\', \'192.168.1.255\', 24)
+1
+-- ipv4_is_match(\'abc\', \'def\', 24)
+\N
+-- ipv4_compare()
+0
+-1
+1
+0
+0
+0
+0
+0
+0
+0
+0
+-- format_ipv4()
+192.168.1.0
+192.168.1.1
+192.168.1.0
+192.168.1.0
+1
+1
+127.0.0.0
+-- format_ipv4_mask()
+192.168.1.0/24
+192.168.1.0/24
+192.168.1.0/24
+192.168.1.1/32
+192.168.1.0/24
+1
+1
+127.0.0.0/24
+-- parse_ipv6_mask()
+0000:0000:0000:0000:0000:0000:0000:0000
+fe80:0000:0000:0000:085d:e82c:9446:7900
+0000:0000:0000:0000:0000:ffff:c0a8:ff00
+0000:0000:0000:0000:0000:ffff:c0a8:ff00
+0000:0000:0000:0000:0000:ffff:ffff:ffff
+fe80:0000:0000:0000:085d:e82c:9446:7994
+fe80:0000:0000:0000:085d:e82c:9446:7900
+0000:0000:0000:0000:0000:ffff:c0a8:ffff
+0000:0000:0000:0000:0000:ffff:c0a8:ff00
+-- ipv6_is_match()
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
+1
diff --git a/tests/queries/0_stateless/02366_kql_func_ip.sql b/tests/queries/0_stateless/02366_kql_func_ip.sql
new file mode 100644
index 000000000000..c9b335f203a2
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_ip.sql
@@ -0,0 +1,131 @@
+set dialect='kusto';
+print '-- ipv4_is_private(\'127.0.0.1\')';
+print ipv4_is_private('127.0.0.1');
+print '-- ipv4_is_private(\'10.1.2.3\')';
+print ipv4_is_private('10.1.2.3');
+print '-- ipv4_is_private(\'192.168.1.1/24\')';
+print ipv4_is_private('192.168.1.1/24');
+print 'ipv4_is_private(strcat(\'192.\',\'168.\',\'1.\',\'1\',\'/24\'))';
+print ipv4_is_private(strcat('192.','168.','1.','1','/24'));
+print '-- ipv4_is_private(\'abc\')';
+print ipv4_is_private('abc'); -- == null
+
+print '-- ipv4_netmask_suffix(\'192.168.1.1/24\')';
+print ipv4_netmask_suffix('192.168.1.1/24'); -- == 24
+print '-- ipv4_netmask_suffix(\'192.168.1.1\')';
+print ipv4_netmask_suffix('192.168.1.1'); -- == 32
+print '-- ipv4_netmask_suffix(\'127.0.0.1/16\')';
+print ipv4_netmask_suffix('127.0.0.1/16'); -- == 16
+print '-- ipv4_netmask_suffix(\'abc\')';
+print ipv4_netmask_suffix('abc'); -- == null
+print 'ipv4_netmask_suffix(strcat(\'127.\', \'0.\', \'0.1/16\'))';
+print ipv4_netmask_suffix(strcat('127.', '0.', '0.1/16')); -- == 16
+
+print '-- ipv4_is_in_range(\'127.0.0.1\', \'127.0.0.1\')';
+print ipv4_is_in_range('127.0.0.1', '127.0.0.1'); -- == true
+print '-- ipv4_is_in_range(\'192.168.1.6\', \'192.168.1.1/24\')';
+print ipv4_is_in_range('192.168.1.6', '192.168.1.1/24'); -- == true
+print '-- ipv4_is_in_range(\'192.168.1.1\', \'192.168.2.1/24\')';
+print ipv4_is_in_range('192.168.1.1', '192.168.2.1/24'); -- == false
+print '-- ipv4_is_in_range(strcat(\'192.\',\'168.\', \'1.1\'), \'192.168.2.1/24\')';
+print ipv4_is_in_range(strcat('192.','168.', '1.1'), '192.168.2.1/24'); -- == false
+print '-- ipv4_is_in_range(\'abc\', \'127.0.0.1\')'; -- == null
+print ipv4_is_in_range('abc', '127.0.0.1');
+
+print '-- parse_ipv6(127.0.0.1)';
+print parse_ipv6('127.0.0.1');
+print '-- parse_ipv6(fe80::85d:e82c:9446:7994)';
+print parse_ipv6('fe80::85d:e82c:9446:7994');
+print '-- parse_ipv4(\'127.0.0.1\')';
+print parse_ipv4('127.0.0.1');
+print '-- parse_ipv4(\'192.1.168.1\') < parse_ipv4(\'192.1.168.2\')';
+print parse_ipv4('192.1.168.1') < parse_ipv4('192.1.168.2');
+print '-- parse_ipv4(arrayStringConcat([\'127\', \'0\', \'0\', \'1\'], \'.\'))';
+print parse_ipv4(arrayStringConcat(['127', '0', '0', '1'], '.')); -- { clientError UNKNOWN_FUNCTION }
+
+print '-- parse_ipv4_mask(\'127.0.0.1\', 24) == 2130706432';
+print parse_ipv4_mask('127.0.0.1', 24);
+print '-- parse_ipv4_mask(\'abc\', 31)';
+print parse_ipv4_mask('abc', 31)
+print '-- parse_ipv4_mask(\'192.1.168.2\', 1000)';
+print parse_ipv4_mask('192.1.168.2', 1000);
+print '-- parse_ipv4_mask(\'192.1.168.2\', 31) == parse_ipv4_mask(\'192.1.168.3\', 31)';
+--print parse_ipv4_mask('192.1.168.2', 31) == parse_ipv4_mask('192.1.168.3', 31); // this qual failed in analyzer 3221334018
+print parse_ipv4_mask('192.1.168.2', 31);
+print parse_ipv4_mask('192.1.168.3', 31);
+print '-- ipv4_is_match(\'127.0.0.1\', \'127.0.0.1\')';
+print ipv4_is_match('127.0.0.1', '127.0.0.1');
+print '-- ipv4_is_match(\'192.168.1.1\', \'192.168.1.255\')';
+print ipv4_is_match('192.168.1.1', '192.168.1.255');
+print '-- ipv4_is_match(\'192.168.1.1/24\', \'192.168.1.255/24\')';
+print ipv4_is_match('192.168.1.1/24', '192.168.1.255/24');
+print '-- ipv4_is_match(\'192.168.1.1\', \'192.168.1.255\', 24)';
+print ipv4_is_match('192.168.1.1', '192.168.1.255', 24);
+print '-- ipv4_is_match(\'abc\', \'def\', 24)';
+print ipv4_is_match('abc', 'dev', 24);
+print '-- ipv4_compare()';
+print ipv4_compare('127.0.0.1', '127.0.0.1');
+print ipv4_compare('192.168.1.1', '192.168.1.255');
+print ipv4_compare('192.168.1.255', '192.168.1.1');
+print ipv4_compare('192.168.1.1/24', '192.168.1.255/24');
+print ipv4_compare('192.168.1.1', '192.168.1.255', 24);
+print ipv4_compare('192.168.1.1/24', '192.168.1.255');
+print ipv4_compare('192.168.1.1', '192.168.1.255/24');
+print ipv4_compare('192.168.1.1/30', '192.168.1.255/24');
+print ipv4_compare('192.168.1.1', '192.168.1.0', 31);
+print ipv4_compare('192.168.1.1/24', '192.168.1.255', 31);
+print ipv4_compare('192.168.1.1', '192.168.1.255', 24);
+print '-- format_ipv4()';
+print format_ipv4('192.168.1.255', 24);
+print format_ipv4('192.168.1.1', 32);
+print format_ipv4('192.168.1.1/24', 32);
+print format_ipv4(3232236031, 24);
+print format_ipv4('192.168.1.1/24', -1) == '';
+print format_ipv4('abc', 24) == '';
+print format_ipv4(strcat('127.0', '.0.', '1', '/32'), 12 + 12);
+print '-- format_ipv4_mask()';
+print format_ipv4_mask('192.168.1.255', 24);
+print format_ipv4_mask(3232236031, 24);
+print format_ipv4_mask('192.168.1.1', 24);
+print format_ipv4_mask('192.168.1.1', 32);
+print format_ipv4_mask('192.168.1.1/24', 32);
+print format_ipv4_mask('192.168.1.1/24', -1) == '';
+print format_ipv4_mask('abc', 24) == '';
+print format_ipv4_mask(strcat('127.0', '.0.', '1', '/32'), 12 + 12);
+print '-- parse_ipv6_mask()';
+print parse_ipv6_mask("127.0.0.1", 24);
+print parse_ipv6_mask("fe80::85d:e82c:9446:7994", 120);
+print parse_ipv6_mask("192.168.255.255", 120);
+print parse_ipv6_mask("192.168.255.255/24", 124);
+print parse_ipv6_mask("255.255.255.255", 128);
+print parse_ipv6_mask("fe80::85d:e82c:9446:7994", 128);
+print parse_ipv6_mask("fe80::85d:e82c:9446:7994/120", 124);
+print parse_ipv6_mask("::192.168.255.255", 128);
+print parse_ipv6_mask("::192.168.255.255/24", 128);
+print '-- ipv6_is_match()';
+print ipv6_is_match('::ffff:7f00:1', '127.0.0.1') == true;
+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995') == false;
+print ipv6_is_match('192.168.1.1/24', '192.168.1.255/24') == true;
+print ipv6_is_match('fe80::85d:e82c:9446:7994/127', 'fe80::85d:e82c:9446:7995/127') == true;
+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995', 127) == true;
+print ipv6_is_match('192.168.1.1',    '192.168.1.1'); --       // Equal IPs
+print ipv6_is_match('192.168.1.1/24', '192.168.1.255'); --     // 24 bit IP4-prefix is used for comparison
+print ipv6_is_match('192.168.1.1',    '192.168.1.255/24'); --  // 24 bit IP4-prefix is used for comparison
+print ipv6_is_match('192.168.1.1/30', '192.168.1.255/24'); --  // 24 bit IP4-prefix is used for comparison
+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7994'); --         // Equal IPs
+print ipv6_is_match('fe80::85d:e82c:9446:7994/120', 'fe80::85d:e82c:9446:7998'); --     // 120 bit IP6-prefix is used for comparison
+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7998/120'); --     // 120 bit IP6-prefix is used for comparison
+print ipv6_is_match('fe80::85d:e82c:9446:7994/120', 'fe80::85d:e82c:9446:7998/120'); -- // 120 bit IP6-prefix is used for comparison
+print ipv6_is_match('192.168.1.1',      '::ffff:c0a8:0101'); -- // Equal IPs
+print ipv6_is_match('192.168.1.1/24',   '::ffff:c0a8:01ff'); -- // 24 bit IP-prefix is used for comparison
+print ipv6_is_match('::ffff:c0a8:0101', '192.168.1.255/24'); -- // 24 bit IP-prefix is used for comparison
+print ipv6_is_match('::192.168.1.1/30', '192.168.1.255/24'); -- // 24 bit IP-prefix is used for comparison
+print ipv6_is_match('192.168.1.1',    '192.168.1.0',   31); -- // 31 bit IP4-prefix is used for comparison
+print ipv6_is_match('192.168.1.1/24', '192.168.1.255', 31); -- // 24 bit IP4-prefix is used for comparison
+print ipv6_is_match('192.168.1.1',    '192.168.1.255', 24); -- // 24 bit IP4-prefix is used for comparison
+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995',     127); -- // 127 bit IP6-prefix is used for comparison
+print ipv6_is_match('fe80::85d:e82c:9446:7994/127', 'fe80::85d:e82c:9446:7998', 120); -- // 120 bit IP6-prefix is used for comparison
+print ipv6_is_match('fe80::85d:e82c:9446:7994/120', 'fe80::85d:e82c:9446:7998', 127); -- // 120 bit IP6-prefix is used for comparison
+print ipv6_is_match('192.168.1.1/24',   '::ffff:c0a8:01ff', 127); -- // 127 bit IP6-prefix is used for comparison
+print ipv6_is_match('::ffff:c0a8:0101', '192.168.1.255',    120); -- // 120 bit IP6-prefix is used for comparison
+print ipv6_is_match('::192.168.1.1/30', '192.168.1.255/24', 127); -- // 120 bit IP6-prefix is used for comparison
\ No newline at end of file
diff --git a/tests/queries/0_stateless/02366_kql_func_math.reference b/tests/queries/0_stateless/02366_kql_func_math.reference
new file mode 100644
index 000000000000..92f283abcb6e
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_math.reference
@@ -0,0 +1,4 @@
+-- isnan --
+1
+0
+0
diff --git a/tests/queries/0_stateless/02366_kql_func_math.sql b/tests/queries/0_stateless/02366_kql_func_math.sql
new file mode 100644
index 000000000000..4e83622eb6b8
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_math.sql
@@ -0,0 +1,7 @@
+set dialect = 'kusto';
+print '-- isnan --';
+print isnan(double(nan));
+print isnan(4.2);
+print isnan(4); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }
+print isnan(real(+inf));
+print isnan(dynamic(null)); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }
diff --git a/tests/queries/0_stateless/02366_kql_func_scalar.reference b/tests/queries/0_stateless/02366_kql_func_scalar.reference
new file mode 100644
index 000000000000..b7fa62c5d437
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_scalar.reference
@@ -0,0 +1,16 @@
+-- bin_at()
+4.5
+-12:0:0
+2017-05-14 12:00:00.000000000
+2017-05-14 00:00:00.000000000
+2018-02-25 15:14:00.000000000	5
+2018-02-24 15:14:00.000000000	3
+2018-02-23 15:14:00.000000000	4
+-- bin()
+4
+1970-05-11 00:00:00.000000000
+336:0:0
+1970-05-11 13:45:07.345000000
+1970-05-11 13:45:07.345623000
+2022-09-26 10:13:23.987232000
+1970-05-11 13:45:07.456336000
diff --git a/tests/queries/0_stateless/02366_kql_func_scalar.sql b/tests/queries/0_stateless/02366_kql_func_scalar.sql
new file mode 100644
index 000000000000..d7e94cfd9d15
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_scalar.sql
@@ -0,0 +1,26 @@
+DROP TABLE IF EXISTS Bin_at_test;
+CREATE TABLE Bin_at_test
+(    
+    `Date` DateTime('UTC'),
+    Num Nullable(UInt8)
+) ENGINE = Memory;
+INSERT INTO Bin_at_test VALUES ('2018-02-24T15:14:01',3), ('2018-02-23T16:14:01',4), ('2018-02-26T15:14:01',5);
+
+set dialect = 'kusto';
+print '-- bin_at()';
+print bin_at(6.5, 2.5, 7);
+print bin_at(1h, 1d, 12h);
+print bin_at(datetime(2017-05-15 10:20:00.0), 1d, datetime(1970-01-01 12:00:00.0));
+print bin_at(datetime(2017-05-17 10:20:00.0), 7d, datetime(2017-06-04 00:00:00.0));
+Bin_at_test | summarize sum(Num) by d = todatetime(bin_at(Date, 1d, datetime('2018-02-24 15:14:00'))) | order by d;
+print '-- bin()';
+print bin(4.5, 1);
+print bin(datetime(1970-05-11 13:45:07), 1d);
+print bin(16d, 7d);
+print bin(datetime(1970-05-11 13:45:07.345623), 1ms);
+-- print bin(datetime(2022-09-26 10:13:23.987234), 6ms); -> 2022-09-26 10:13:23.982000000
+print bin(datetime(1970-05-11 13:45:07.345623), 1microsecond);
+print bin(datetime(2022-09-26 10:13:23.987234), 6microseconds);
+print bin(datetime(1970-05-11 13:45:07.456345672), 16microseconds);
+-- print bin(datetime(2022-09-26 10:13:23.987234128), 1tick); -> 2022-09-26 10:13:23.987234100
+-- print bin(datetime(2022-09-26 10:13:23.987234128), 99nanosecond); -> null
diff --git a/tests/queries/0_stateless/02366_kql_func_string.reference b/tests/queries/0_stateless/02366_kql_func_string.reference
new file mode 100644
index 000000000000..9bdd38ca5dba
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_string.reference
@@ -0,0 +1,360 @@
+-- test String Functions --
+-- Customers |where Education contains \'degree\'
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+
+-- Customers |where Education !contains \'degree\'
+\N	why	Professional	Partial College	38
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers |where Education contains \'Degree\'
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+
+-- Customers |where Education !contains \'Degree\'
+\N	why	Professional	Partial College	38
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where FirstName endswith \'RE\'
+Theodore	Diaz	Skilled Manual	Bachelors	28
+
+-- Customers | where ! FirstName endswith \'RE\'
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+--Customers | where FirstName endswith_cs \'re\'
+Theodore	Diaz	Skilled Manual	Bachelors	28
+
+-- Customers | where FirstName !endswith_cs \'re\'
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation == \'Skilled Manual\'
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation != \'Skilled Manual\'
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers | where Occupation has \'skilled\'
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation !has \'skilled\'
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers | where Occupation has \'Skilled\'
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation !has \'Skilled\'
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers | where Occupation hasprefix_cs \'Ab\'
+
+-- Customers | where Occupation !hasprefix_cs \'Ab\'
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation hasprefix_cs \'ab\'
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers | where Occupation !hasprefix_cs \'ab\'
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation hassuffix \'Ent\'
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers | where Occupation !hassuffix \'Ent\'
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Occupation hassuffix \'ent\'
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers | where Occupation hassuffix \'ent\'
+Stephanie	Cox	Management abcd defg	Bachelors	33
+
+-- Customers |where Education in (\'Bachelors\',\'High School\')
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where Education !in (\'Bachelors\',\'High School\')
+\N	why	Professional	Partial College	38
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+
+-- Customers | where FirstName matches regex \'P.*r\'
+Peter	Nara	Skilled Manual	Graduate Degree	26
+
+-- Customers | where FirstName startswith \'pet\'
+Peter	Nara	Skilled Manual	Graduate Degree	26
+
+-- Customers | where FirstName !startswith \'pet\'
+Latoya	Shen	Professional	Graduate Degree	25
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where FirstName startswith_cs \'pet\'
+
+-- Customers | where FirstName !startswith_cs \'pet\'
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where isempty(LastName)
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where isnotempty(LastName)
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Latoya	Shen	Professional	Graduate Degree	25
+\N	why	Professional	Partial College	38
+
+-- Customers | where isnotnull(FirstName)
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+
+-- Customers | where isnull(FirstName)
+\N	why	Professional	Partial College	38
+
+-- Customers | project url_decode(\'https%3A%2F%2Fwww.test.com%2Fhello%20word\') | take 1
+https://www.test.com/hello word
+
+-- Customers | project url_encode(\'https://www.test.com/hello word\') | take 1
+https%3A%2F%2Fwww.test.com%2Fhello%20word
+
+-- Customers | project name_abbr = strcat(substring(FirstName,0,3), \' \', substring(LastName,2))
+\N
+Lat en
+Pet ra
+The az
+Ste x
+App 
+
+-- Customers | project name = strcat(FirstName, \' \', LastName)
+\N
+Latoya Shen
+Peter Nara
+Theodore Diaz
+Stephanie Cox
+Apple 
+
+-- Customers | project FirstName, strlen(FirstName)
+\N	\N
+Latoya	6
+Peter	5
+Theodore	8
+Stephanie	9
+Apple	5
+
+-- Customers | project strrep(FirstName,2,\'_\')
+\N
+Latoya_Latoya
+Peter_Peter
+Theodore_Theodore
+Stephanie_Stephanie
+Apple_Apple
+
+-- Customers | project toupper(FirstName)
+\N
+LATOYA
+PETER
+THEODORE
+STEPHANIE
+APPLE
+
+-- Customers | project tolower(FirstName)
+\N
+latoya
+peter
+theodore
+stephanie
+apple
+
+-- support subquery for in orerator (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/in-cs-operator) (subquery need to be wraped with bracket inside bracket); TODO: case-insensitive not supported yet
+Latoya	Shen	Professional	Graduate Degree	25
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- has_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-all-operator); TODO: subquery not supported yet
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Apple		Skilled Manual	Bachelors	28
+
+-- has_any (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-anyoperator); TODO: subquery not supported yet
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Apple		Skilled Manual	Bachelors	28
+
+-- countof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/countoffunction)
+3
+3
+1
+
+-- extract ( https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractfunction)
+PINEAPPLE ice cream is 20
+PINEAPPLE
+20
+
+20
+\N
+\N
+\N
+\N
+\N
+45.6
+45.6
+
+-- extract_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractallfunction); TODO: captureGroups not supported yet
+[['T','h','e'],['p','ric','e'],['P','INEAPPL','E'],['i','c','e'],['c','rea','m']]
+
+-- extract_json (https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/extractjsonfunction)
+
+
+John
+iPhone
+\N
+26
+26
+26
+26
+\N
+
+-- split (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/splitfunction)
+['aa','bb']
+['bbb']
+['']
+['a','','b']
+['aa','cc']
+['aabbcc']
+['aaa','bbb','ccc']
+[NULL]
+
+-- strcat_delim (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/strcat-delimfunction); TODO: only support string now.
+1-2-Ab
+
+-- indexof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/indexoffunction); TODO: length and occurrence not supported yet
+2
+2
+-1
+-- base64_encode_fromguid()
+8jMxriJurkmwahbmqbIS6w==
+-- base64_decode_toarray()
+[]
+[75,117,115,116,111]
+-- base64_decode_toguid()
+10e99626-bc2b-4c75-bb3e-fe606de25700
+1
+-- base64_encode_tostring
+
+S3VzdG8x
+-- base64_decode_tostring
+
+Kusto1
+-- parse_url()
+{"Scheme":"scheme","Host":"","Port":"0","Path":"/this/is/a/path","Username":"username","Password":"password","Query Parameters":{"k1":"v1","k2":"v2"},"Fragment":"fragment"}
+-- parse_urlquery()
+{"Query Parameters":{"k1":"v1","k2":"v2","k3":"v3"}}
+-- strcmp()
+0	1	-1	1
+-- substring()
+CD
+-- translate()
+kusto		xxx
+-- trim()
+https://www.ibm.com
+Te st1
+ asd 
+asd
+sd
+-- trim_start()
+www.ibm.com
+Te st1// $
+asdw
+
+asd
+-- trim_end()
+https
+- Te st1
+wasd
+
+asd
+-- trim, trim_start, trim_end all at once
+--https://bing.com--	--	https://bing.com--	--https://bing.com	https://bing.com
+-- replace_regex
+Number was: 1
+-- has_any_index()
+0	1	-1	-1
+-- parse_version()
+1000000020000000300000040
+1000000020000000000000000
+1000000020000000000000000
+\N
+\N
+\N
+\N
+1000000020000000300000004
+1000000020000000000000000
+1000000020000000300000000
+1000000000000000000000000
+-- parse_json()
+[1,2,3]
+[{"a":123.5,"b":"{\\"c\\":456}"}]
+-- parse_command_line()
+[NULL]
+[NULL]
+-- reverse()
+321
+43.321
+
+dsa
+][
+]3,2,1[
+]\'redaV\',\'htraD\'[
+000000000.00:00:21 51-01-7102
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Latoya	Shen	Professional	Graduate Degree	25
+-- parse_csv()
+['']
+['aaa']
+['aa','b','cc']
+['record1','a','b','c']
diff --git a/tests/queries/0_stateless/02366_kql_func_string.sql b/tests/queries/0_stateless/02366_kql_func_string.sql
new file mode 100644
index 000000000000..d251b04e08bf
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_func_string.sql
@@ -0,0 +1,313 @@
+-- Tags: no-fasttest
+
+DROP TABLE IF EXISTS Customers;
+CREATE TABLE Customers
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Occupation String,
+    Education String,
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+
+INSERT INTO Customers VALUES ('Theodore','Diaz','Skilled Manual','Bachelors',28), ('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);
+
+-- datatable (Version:string) [
+--     '1.2.3.4',
+--     '1.2',
+--     '1.2.3',
+--     '1'
+-- ]
+
+DROP TABLE IF EXISTS Versions;
+CREATE TABLE Versions
+(    
+    Version String
+) ENGINE = Memory;
+INSERT INTO Versions VALUES ('1.2.3.4'),('1.2'),('1.2.3'),('1');
+
+
+set dialect='kusto';
+print '-- test String Functions --';
+
+print '-- Customers |where Education contains \'degree\'';
+Customers |where Education contains 'degree' | order by LastName;
+print '';
+print '-- Customers |where Education !contains \'degree\'';
+Customers |where Education !contains 'degree' | order by LastName;
+print '';
+print '-- Customers |where Education contains \'Degree\'';
+Customers |where Education contains 'Degree' | order by LastName;
+print '';
+print '-- Customers |where Education !contains \'Degree\'';
+Customers |where Education !contains 'Degree' | order by LastName;
+print '';
+print '-- Customers | where FirstName endswith \'RE\'';
+Customers | where FirstName endswith 'RE' | order by LastName;
+print '';
+print '-- Customers | where ! FirstName endswith \'RE\'';
+Customers | where FirstName ! endswith 'RE' | order by LastName;
+print '';
+print '--Customers | where FirstName endswith_cs \'re\'';
+Customers | where FirstName endswith_cs 're' | order by LastName;
+print '';
+print '-- Customers | where FirstName !endswith_cs \'re\'';
+Customers | where FirstName !endswith_cs 're' | order by LastName;
+print '';
+print '-- Customers | where Occupation == \'Skilled Manual\'';
+Customers | where Occupation == 'Skilled Manual' | order by LastName;
+print '';
+print '-- Customers | where Occupation != \'Skilled Manual\'';
+Customers | where Occupation != 'Skilled Manual' | order by LastName;
+print '';
+print '-- Customers | where Occupation has \'skilled\'';
+Customers | where Occupation has 'skilled' | order by LastName;
+print '';
+print '-- Customers | where Occupation !has \'skilled\'';
+Customers | where Occupation !has 'skilled' | order by LastName;
+print '';
+print '-- Customers | where Occupation has \'Skilled\'';
+Customers | where Occupation has 'Skilled'| order by LastName;
+print '';
+print '-- Customers | where Occupation !has \'Skilled\'';
+Customers | where Occupation !has 'Skilled'| order by LastName;
+print '';
+print '-- Customers | where Occupation hasprefix_cs \'Ab\'';
+Customers | where Occupation hasprefix_cs 'Ab'| order by LastName;
+print '';
+print '-- Customers | where Occupation !hasprefix_cs \'Ab\'';
+Customers | where Occupation !hasprefix_cs 'Ab'| order by LastName;
+print '';
+print '-- Customers | where Occupation hasprefix_cs \'ab\'';
+Customers | where Occupation hasprefix_cs 'ab'| order by LastName;
+print '';
+print '-- Customers | where Occupation !hasprefix_cs \'ab\'';
+Customers | where Occupation !hasprefix_cs 'ab'| order by LastName;
+print '';
+print '-- Customers | where Occupation hassuffix \'Ent\'';
+Customers | where Occupation hassuffix 'Ent'| order by LastName;
+print '';
+print '-- Customers | where Occupation !hassuffix \'Ent\'';
+Customers | where Occupation !hassuffix 'Ent'| order by LastName;
+print '';
+print '-- Customers | where Occupation hassuffix \'ent\'';
+Customers | where Occupation hassuffix 'ent'| order by LastName;
+print '';
+print '-- Customers | where Occupation hassuffix \'ent\'';
+Customers | where Occupation hassuffix 'ent'| order by LastName;
+print '';
+print '-- Customers |where Education in (\'Bachelors\',\'High School\')';
+Customers |where Education in ('Bachelors','High School')| order by LastName;
+print '';
+print '-- Customers | where Education !in (\'Bachelors\',\'High School\')';
+Customers | where Education !in ('Bachelors','High School')| order by LastName;
+print '';
+print '-- Customers | where FirstName matches regex \'P.*r\'';
+Customers | where FirstName matches regex 'P.*r'| order by LastName;
+print '';
+print '-- Customers | where FirstName startswith \'pet\'';
+Customers | where FirstName startswith 'pet'| order by LastName;
+print '';
+print '-- Customers | where FirstName !startswith \'pet\'';
+Customers | where FirstName !startswith 'pet'| order by LastName;
+print '';
+print '-- Customers | where FirstName startswith_cs \'pet\'';
+Customers | where FirstName startswith_cs 'pet'| order by LastName;
+print '';
+print '-- Customers | where FirstName !startswith_cs \'pet\'';
+Customers | where FirstName !startswith_cs 'pet'| order by LastName;
+print '';
+print '-- Customers | where isempty(LastName)';
+Customers | where isempty(LastName);
+print '';
+print '-- Customers | where isnotempty(LastName)';
+Customers | where isnotempty(LastName);
+print '';
+print '-- Customers | where isnotnull(FirstName)';
+Customers | where isnotnull(FirstName)| order by LastName;
+print '';
+print '-- Customers | where isnull(FirstName)';
+Customers | where isnull(FirstName)| order by LastName;
+print '';
+print '-- Customers | project url_decode(\'https%3A%2F%2Fwww.test.com%2Fhello%20word\') | take 1';
+Customers | project url_decode('https%3A%2F%2Fwww.test.com%2Fhello%20word') | take 1;
+print '';
+print '-- Customers | project url_encode(\'https://www.test.com/hello word\') | take 1';
+Customers | project url_encode('https://www.test.com/hello word') | take 1;
+print '';
+print '-- Customers | project name_abbr = strcat(substring(FirstName,0,3), \' \', substring(LastName,2))';
+Customers | project name_abbr = strcat(substring(FirstName,0,3), ' ', substring(LastName,2))| order by LastName;
+print '';
+print '-- Customers | project name = strcat(FirstName, \' \', LastName)';
+Customers | project name = strcat(FirstName, ' ', LastName)| order by LastName;
+print '';
+print '-- Customers | project FirstName, strlen(FirstName)';
+Customers | project FirstName, strlen(FirstName)| order by LastName;
+print '';
+print '-- Customers | project strrep(FirstName,2,\'_\')';
+Customers | project strrep(FirstName,2,'_')| order by LastName;
+print '';
+print '-- Customers | project toupper(FirstName)';
+Customers | project toupper(FirstName)| order by LastName;
+print '';
+print '-- Customers | project tolower(FirstName)';
+Customers | project tolower(FirstName)| order by LastName;
+print '';
+print '-- support subquery for in orerator (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/in-cs-operator) (subquery need to be wraped with bracket inside bracket); TODO: case-insensitive not supported yet';
+Customers | where Age in ((Customers|project Age|where Age < 30)) | order by LastName;
+-- Customer | where LastName in~ ("diaz", "cox")
+print '';
+print '-- has_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-all-operator); TODO: subquery not supported yet';
+Customers | where Occupation has_all ('manual', 'skilled') | order by LastName;
+print '';
+print '-- has_any (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-anyoperator); TODO: subquery not supported yet';
+Customers|where Occupation has_any ('Skilled','abcd');
+print '';
+print '-- countof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/countoffunction)';
+Customers | project countof('The cat sat on the mat', 'at') | take 1;
+Customers | project countof('The cat sat on the mat', 'at', 'normal') | take 1;
+Customers | project countof('The cat sat on the mat', '\\s.he', 'regex') | take 1;
+print '';
+print '-- extract ( https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractfunction)';
+print extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 0, 'The price of PINEAPPLE ice cream is 20');
+print extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 1, 'The price of PINEAPPLE ice cream is 20');
+print extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 2, 'The price of PINEAPPLE ice cream is 20');
+print extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 3, 'The price of PINEAPPLE ice cream is 20');
+print extract('(\\b[A-Z]+\\b).+(\\b\\d+)', 2, 'The price of PINEAPPLE ice cream is 20', typeof(real));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(bool));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(date));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(guid));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(int));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(long));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(real));
+print extract("x=([0-9.]+)", 1, "hello x=45.6|wo" , typeof(decimal));
+print '';
+print '-- extract_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractallfunction); TODO: captureGroups not supported yet';
+Customers | project extract_all('(\\w)(\\w+)(\\w)','The price of PINEAPPLE ice cream is 20') | take 1;
+print '';
+print '-- extract_json (https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/extractjsonfunction)';
+print extract_json('', ''); -- { serverError BAD_ARGUMENTS }
+print extract_json('a', ''); -- { serverError BAD_ARGUMENTS }
+print extract_json('$.firstName', '');
+print extract_json('$.phoneNumbers[0].type', '');
+print extractjson('$.firstName', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}');
+print extract_json('$.phoneNumbers[0].type', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(string));
+print extract_json('$.phoneNumbers[0].type', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(int));
+print extract_json('$.age', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}');
+print extract_json('$.age', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(int));
+print extract_json('$.age', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(long));
+-- print extract_json('$.age', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(bool)); -> true
+print extract_json('$.age', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(double));
+print extract_json('$.age', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(guid));
+-- print extract_json('$.phoneNumbers', '{"firstName":"John","lastName":"doe","age":26,"address":{"streetAddress":"naist street","city":"Nara","postalCode":"630-0192"},"phoneNumbers":[{"type":"iPhone","number":"0123-4567-8888"},{"type":"home","number":"0123-4567-8910"}]}', typeof(dynamic)); we won't be able to handle this particular case for a while, because it should return a dictionary
+print '';
+print '-- split (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/splitfunction)';
+Customers | project split('aa_bb', '_') | take 1;
+Customers | project split('aaa_bbb_ccc', '_', 1) | take 1;
+Customers | project split('', '_') | take 1;
+Customers | project split('a__b', '_') | take 1;
+Customers | project split('aabbcc', 'bb') | take 1;
+Customers | project split('aabbcc', '') | take 1;
+Customers | project split('aaa_bbb_ccc', '_', -1) | take 1;
+Customers | project split('aaa_bbb_ccc', '_', 10) | take 1;
+print '';
+print '-- strcat_delim (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/strcat-delimfunction); TODO: only support string now.';
+Customers | project strcat_delim('-', '1', '2', strcat('A','b')) | take 1;
+-- Customers | project strcat_delim('-', '1', '2', 'A' , 1s);
+print '';
+print '-- indexof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/indexoffunction); TODO: length and occurrence not supported yet';
+Customers | project indexof('abcdefg','cde') | take 1;
+Customers | project indexof('abcdefg','cde',2) | take 1;
+Customers | project indexof('abcdefg','cde',6) | take 1;
+print '-- base64_encode_fromguid()';
+-- print base64_encode_fromguid(guid(null));
+print base64_encode_fromguid(guid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb'));
+print base64_encode_fromguid(dynamic(null)); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }
+print base64_encode_fromguid("abcd1231"); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }
+print '-- base64_decode_toarray()';
+print base64_decode_toarray('');
+print base64_decode_toarray('S3VzdG8=');
+print '-- base64_decode_toguid()';
+print base64_decode_toguid("JpbpECu8dUy7Pv5gbeJXAA==");
+print base64_decode_toguid(base64_encode_fromguid(guid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb'))) == guid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb');
+print '-- base64_encode_tostring';
+print base64_encode_tostring('');
+print base64_encode_tostring('Kusto1');
+print '-- base64_decode_tostring';
+print base64_decode_tostring('');
+print base64_decode_tostring('S3VzdG8x');
+print '-- parse_url()';
+print parse_url('scheme://username:password@host:1234/this/is/a/path?k1=v1&k2=v2#fragment');
+print '-- parse_urlquery()';
+print parse_urlquery('k1=v1&k2=v2&k3=v3');
+print '-- strcmp()';
+print strcmp('ABC','ABC'), strcmp('abc','ABC'), strcmp('ABC','abc'), strcmp('abcde','abc');
+print '-- substring()';
+print substring("ABCD", -2, 2);
+print '-- translate()';
+print translate('krasp', 'otsku', 'spark'), translate('abc', '', 'ab'), translate('abc', 'x', 'abc');
+print '-- trim()';
+print trim("--", "--https://www.ibm.com--");
+print trim("[^\w]+", strcat("- ","Te st", "1", "// $"));
+print trim("", " asd ");
+print trim("a$", "asd");
+print trim("^a", "asd");
+print '-- trim_start()';
+print trim_start("https://", "https://www.ibm.com");
+print trim_start("[^\w]+", strcat("-  ","Te st", "1", "// $"));
+print trim_start("asd$", "asdw");
+print trim_start("asd$", "asd");
+print trim_start("d$", "asd");
+print '-- trim_end()';
+print trim_end("://www.ibm.com", "https://www.ibm.com");
+print trim_end("[^\w]+", strcat("- ","Te st", "1", "// $"));
+print trim_end("^asd", "wasd");
+print trim_end("^asd", "asd");
+print trim_end("^a", "asd");
+print '-- trim, trim_start, trim_end all at once';
+print str = "--https://bing.com--", pattern = '--' | extend start = trim_start(pattern, str), end = trim_end(pattern, str), both = trim(pattern, str);
+print '-- replace_regex';
+print replace_regex(strcat('Number is ', '1'), 'is (\d+)', 'was: \1');
+print '-- has_any_index()';
+print has_any_index('this is an example', dynamic(['this', 'example'])), has_any_index("this is an example", dynamic(['not', 'example'])), has_any_index("this is an example", dynamic(['not', 'found'])), has_any_index("this is an example", dynamic([]));
+print '-- parse_version()';
+print parse_version(42); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+-- print parse_version(''); -> NULL
+print parse_version('1.2.3.40');
+print parse_version('1.2');
+print parse_version(strcat('1.', '2'));
+print parse_version('1.2.4.5.6');
+print parse_version('moo'); 
+print parse_version('moo.boo.foo');
+print parse_version(strcat_delim('.', 'moo', 'boo', 'foo'));
+Versions | project parse_version(Version);
+print '-- parse_json()';
+print parse_json(dynamic([1, 2, 3]));
+print parse_json('{"a":123.5, "b":"{\\"c\\":456}"}');
+print '-- parse_command_line()';
+print parse_command_line(55, 'windows'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+-- print parse_command_line((52 + 3) * 4 % 2, 'windows'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+print parse_command_line('', 'windows');
+print parse_command_line(strrep(' ', 6), 'windows'); 
+-- print parse_command_line('echo \"hello world!\" print$?', 'windows'); -> ["echo","hello world!","print$?"]
+-- print parse_command_line("yolo swag 'asd bcd' \"moo moo \"", 'windows'); -> ["yolo","swag","'asd","bcd'","moo moo "]
+-- print parse_command_line(strcat_delim(' ', "yolo", "swag", "\'asd bcd\'", "\"moo moo \""), 'windows'); -> ["yolo","swag","'asd","bcd'","moo moo "]
+print '-- reverse()';
+print reverse(123);
+print reverse(123.34);
+print reverse('');
+print reverse("asd");
+print reverse(dynamic([]));
+print reverse(dynamic([1, 2, 3]));
+print reverse(dynamic(['Darth', "Vader"]));
+print reverse(datetime(2017-10-15 12:00));
+-- print reverse(timespan(3h)); -> 00:00:30
+Customers | where Education contains 'degree' | order by reverse(FirstName);
+print '-- parse_csv()';
+print parse_csv('');
+print parse_csv(65); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }
+print parse_csv('aaa');
+print result=parse_csv('aa,b,cc');
+print result_multi_record=parse_csv('record1,a,b,c
record2,x,y,z');
+-- print result=parse_csv('aa,"b,b,b",cc,"Escaping quotes: ""Title""","line1
line2"'); -> ["aa","b,b,b","cc","Escaping quotes: \"Title\"","line1
line2"]
+-- print parse_csv(strcat(strcat_delim(',', 'aa', '"b,b,b"', 'cc', '"Escaping quotes: ""Title"""', '"line1
line2"'), '\r
', strcat_delim(',', 'asd', 'qcf'))); -> ["aa","b,b,b","cc","Escaping quotes: \"Title\"","line1
line2"]
diff --git a/tests/queries/0_stateless/02366_kql_makeseries.reference b/tests/queries/0_stateless/02366_kql_makeseries.reference
new file mode 100644
index 000000000000..8e7fde997bfb
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_makeseries.reference
@@ -0,0 +1,60 @@
+-- from to
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[200,0,102]
+Costco	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[0,2,0]
+Aldi	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[0,500,0]
+Aldi	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[5,0,6]
+-- from
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[200,0,102]
+Costco	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000']	[0,2]
+Aldi	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000']	[0,500]
+Aldi	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[5,0,6]
+-- to
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[200,0,102]
+Costco	Apple	['2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[2,0]
+Aldi	Snargaluff	['2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[500,0]
+Aldi	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[5,0,6]
+-- without from/to
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[200,0,102]
+Costco	Apple	['2016-09-11 00:00:00.000000000']	[2]
+Aldi	Snargaluff	['2016-09-11 00:00:00.000000000']	[500]
+Aldi	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[5,0,6]
+-- without by
+['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[70,334,54]
+-- without aggregation alias
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[200,0,102]
+Aldi	Snargaluff	['2016-09-11 00:00:00.000000000']	[500]
+Aldi	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[5,0,6]
+Costco	Apple	['2016-09-11 00:00:00.000000000']	[2]
+-- assign group alias
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[200,0,102]
+Aldi	Snargaluff	['2016-09-11 00:00:00.000000000']	[500]
+Aldi	Apple	['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']	[5,0,6]
+Costco	Apple	['2016-09-11 00:00:00.000000000']	[2]
+-- 3d step
+Costco	Snargaluff	['2016-09-10 00:00:00.000000000']	[134.66666666666666]
+Costco	Apple	['2016-09-10 00:00:00.000000000']	[2]
+Aldi	Snargaluff	['2016-09-10 00:00:00.000000000']	[500]
+Aldi	Apple	['2016-09-10 00:00:00.000000000']	[5.5]
+-- numeric column
+Costco	Snargaluff	[10,11,12,13,14]	[200,0,102,0,0]
+Aldi	Snargaluff	[10,11,12,13,14]	[0,500,0,0,0]
+Aldi	Apple	[10,11,12,13,14]	[5,0,6,0,0]
+Costco	Apple	[10,11,12,13,14]	[0,2,0,0,0]
+-- from
+Costco	Snargaluff	[10,11,12]	[200,0,102]
+Aldi	Snargaluff	[10,11]	[0,500]
+Aldi	Apple	[10,11,12]	[5,0,6]
+Costco	Apple	[10,11]	[0,2]
+-- to
+Costco	Snargaluff	[8,12,16]	[200,102,0]
+Aldi	Snargaluff	[8,12,16]	[500,0,0]
+Aldi	Apple	[8,12,16]	[5,6,0]
+Costco	Apple	[8,12,16]	[2,0,0]
+-- without from/to
+Costco	Snargaluff	[10,12]	[200,102]
+Aldi	Snargaluff	[10]	[500]
+Aldi	Apple	[10,12]	[5,6]
+Costco	Apple	[10]	[2]
+-- without by
+[10,12]	[202,54]
+['2017-01-01 00:00:00.000000000','2017-01-02 00:00:00.000000000','2017-01-03 00:00:00.000000000','2017-01-04 00:00:00.000000000','2017-01-05 00:00:00.000000000','2017-01-06 00:00:00.000000000','2017-01-07 00:00:00.000000000','2017-01-08 00:00:00.000000000','2017-01-09 00:00:00.000000000']	[4,3,5,0,10.5,4,3,8,6.5]
diff --git a/tests/queries/0_stateless/02366_kql_makeseries.sql b/tests/queries/0_stateless/02366_kql_makeseries.sql
new file mode 100644
index 000000000000..ecf2ef43cc42
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_makeseries.sql
@@ -0,0 +1,74 @@
+-- Azure Data Explore Test Data
+-- let make_series_test_table = datatable (Supplier:string, Fruit:string, Price: real, Purchase:datetime)
+-- [
+-- 'Aldi','Apple',4,'2016-09-10',
+-- 'Costco','Apple',2,'2016-09-11',
+-- 'Aldi','Apple',6,'2016-09-10',
+-- 'Costco','Snargaluff',100,'2016-09-12',
+-- 'Aldi','Apple',7,'2016-09-12',
+-- 'Aldi','Snargaluff',400,'2016-09-11',
+-- 'Costco','Snargaluff',104,'2016-09-12',
+-- 'Aldi','Apple',5,'2016-09-12',
+-- 'Aldi','Snargaluff',600,'2016-09-11',
+-- 'Costco','Snargaluff',200,'2016-09-10',
+-- ];
+DROP TABLE IF EXISTS make_series_test_table;
+CREATE TABLE make_series_test_table
+(    
+   Supplier Nullable(String),
+   Fruit String ,
+   Price Float64,
+   Purchase Date 
+) ENGINE = Memory;
+INSERT INTO make_series_test_table VALUES  ('Aldi','Apple',4,'2016-09-10'), ('Costco','Apple',2,'2016-09-11'), ('Aldi','Apple',6,'2016-09-10'), ('Costco','Snargaluff',100,'2016-09-12'), ('Aldi','Apple',7,'2016-09-12'), ('Aldi','Snargaluff',400,'2016-09-11'),('Costco','Snargaluff',104,'2016-09-12'),('Aldi','Apple',5,'2016-09-12'),('Aldi','Snargaluff',600,'2016-09-11'),('Costco','Snargaluff',200,'2016-09-10');
+DROP TABLE IF EXISTS make_series_test_table2;
+CREATE TABLE make_series_test_table2
+(    
+   Supplier Nullable(String),
+   Fruit String ,
+   Price Int32,
+   Purchase Int32  
+) ENGINE = Memory;
+INSERT INTO make_series_test_table2 VALUES  ('Aldi','Apple',4,10),('Costco','Apple',2,11),('Aldi','Apple',6,10),('Costco','Snargaluff',100,12),('Aldi','Apple',7,12),('Aldi','Snargaluff',400,11),('Costco','Snargaluff',104,12),('Aldi','Apple',5,12),('Aldi','Snargaluff',600,11),('Costco','Snargaluff',200,10);
+DROP TABLE IF EXISTS make_series_test_table3;
+CREATE TABLE make_series_test_table3
+(    
+    timestamp datetime,
+    metric Float64,
+) ENGINE = Memory;
+INSERT INTO make_series_test_table3 VALUES (parseDateTimeBestEffort('2016-12-31T06:00', 'UTC'), 50), (parseDateTimeBestEffort('2017-01-01', 'UTC'), 4), (parseDateTimeBestEffort('2017-01-02', 'UTC'), 3), (parseDateTimeBestEffort('2017-01-03', 'UTC'), 4), (parseDateTimeBestEffort('2017-01-03T03:00', 'UTC'), 6), (parseDateTimeBestEffort('2017-01-05', 'UTC'), 8), (parseDateTimeBestEffort('2017-01-05T13:40', 'UTC'), 13), (parseDateTimeBestEffort('2017-01-06', 'UTC'), 4), (parseDateTimeBestEffort('2017-01-07', 'UTC'), 3), (parseDateTimeBestEffort('2017-01-08', 'UTC'), 8), (parseDateTimeBestEffort('2017-01-08T21:00', 'UTC'), 8), (parseDateTimeBestEffort('2017-01-09', 'UTC'), 2), (parseDateTimeBestEffort('2017-01-09T12:00', 'UTC'), 11), (parseDateTimeBestEffort('2017-01-10T05:00', 'UTC'), 5);
+
+set dialect = 'kusto';
+print '-- from to';
+make_series_test_table |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 1d by Supplier, Fruit | order by Supplier, Fruit;
+print '-- from';
+make_series_test_table |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  step 1d by Supplier, Fruit | order by Supplier, Fruit;
+print '-- to';
+make_series_test_table |  make-series PriceAvg = avg(Price) default=0 on Purchase to datetime(2016-09-13) step 1d by Supplier, Fruit | order by Supplier, Fruit;
+print '-- without from/to';
+make_series_test_table | make-series PriceAvg = avg(Price) default=0 on Purchase step 1d by Supplier, Fruit | order by Supplier, Fruit;
+print '-- without by';
+make_series_test_table | make-series PriceAvg = avg(Price) default=0 on Purchase step 1d;
+print '-- without aggregation alias';
+make_series_test_table | make-series avg(Price) default=0 on Purchase step 1d by Supplier, Fruit;
+print '-- assign group alias';
+make_series_test_table | make-series avg(Price) default=0 on Purchase step 1d by Supplier_Name = Supplier, Fruit;
+print '-- 3d step';
+make_series_test_table | make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 3d by Supplier, Fruit | order by Supplier, Fruit;
+
+print '-- numeric column'
+print '-- from to';
+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 to  15 step  1.0  by Supplier, Fruit;
+print '-- from';
+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 step  1.0  by Supplier, Fruit;
+print '-- to';
+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase to 18 step  4.0  by Supplier, Fruit;
+print '-- without from/to';
+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  2.0  by Supplier, Fruit;
+print '-- without by';
+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  2.0;
+
+make_series_test_table3 | make-series avg(metric) default=0  on timestamp from datetime(2017-01-01) to datetime(2017-01-10) step 1d 
+
+-- print '-- summarize --'
+-- make_series_test_table | summarize count() by format_datetime(bin(Purchase, 1d), 'yy-MM-dd');
diff --git a/tests/queries/0_stateless/02366_kql_mvexpand.reference b/tests/queries/0_stateless/02366_kql_mvexpand.reference
new file mode 100644
index 000000000000..25be070eb0b7
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_mvexpand.reference
@@ -0,0 +1,65 @@
+-- mv-expand --
+-- mv_expand_test_table | mv-expand c --
+1	['Salmon','Steak','Chicken']	1	[5,6,7,8]
+1	['Salmon','Steak','Chicken']	2	[5,6,7,8]
+1	['Salmon','Steak','Chicken']	3	[5,6,7,8]
+1	['Salmon','Steak','Chicken']	4	[5,6,7,8]
+-- mv_expand_test_table | mv-expand c, d --
+1	['Salmon','Steak','Chicken']	1	5
+1	['Salmon','Steak','Chicken']	2	6
+1	['Salmon','Steak','Chicken']	3	7
+1	['Salmon','Steak','Chicken']	4	8
+-- mv_expand_test_table | mv-expand b | mv-expand c --
+1	Salmon	1	[5,6,7,8]
+1	Salmon	2	[5,6,7,8]
+1	Salmon	3	[5,6,7,8]
+1	Salmon	4	[5,6,7,8]
+1	Steak	1	[5,6,7,8]
+1	Steak	2	[5,6,7,8]
+1	Steak	3	[5,6,7,8]
+1	Steak	4	[5,6,7,8]
+1	Chicken	1	[5,6,7,8]
+1	Chicken	2	[5,6,7,8]
+1	Chicken	3	[5,6,7,8]
+1	Chicken	4	[5,6,7,8]
+-- mv_expand_test_table | mv-expand with_itemindex=index b, c, d --
+0	1	Salmon	1	5
+1	1	Steak	2	6
+2	1	Chicken	3	7
+3	1		4	8
+-- mv_expand_test_table | mv-expand array_concat(c,d) --
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	1
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	2
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	3
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	4
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	5
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	6
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	7
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	8
+-- mv_expand_test_table | mv-expand x = c, y = d --
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	1	5
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	2	6
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	3	7
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	4	8
+-- mv_expand_test_table | mv-expand xy = array_concat(c, d) --
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	1
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	2
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	3
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	4
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	5
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	6
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	7
+1	['Salmon','Steak','Chicken']	[1,2,3,4]	[5,6,7,8]	8
+-- mv_expand_test_table | mv-expand xy = array_concat(c, d) limit 2| summarize count() by xy --
+1	1
+2	1
+-- mv_expand_test_table | mv-expand with_itemindex=index c,d to typeof(bool) --
+0	1	['Salmon','Steak','Chicken']	1	true
+1	1	['Salmon','Steak','Chicken']	2	true
+2	1	['Salmon','Steak','Chicken']	3	true
+3	1	['Salmon','Steak','Chicken']	4	true
+-- mv_expand_test_table | mv-expand c to typeof(bool) --
+1	['Salmon','Steak','Chicken']	[5,6,7,8]	true
+1	['Salmon','Steak','Chicken']	[5,6,7,8]	true
+1	['Salmon','Steak','Chicken']	[5,6,7,8]	true
+1	['Salmon','Steak','Chicken']	[5,6,7,8]	true
diff --git a/tests/queries/0_stateless/02366_kql_mvexpand.sql b/tests/queries/0_stateless/02366_kql_mvexpand.sql
new file mode 100644
index 000000000000..e77986096463
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_mvexpand.sql
@@ -0,0 +1,35 @@
+-- datatable(a: int, b: dynamic, c: dynamic, d: dynamic) [
+--    1, dynamic(['Salmon', 'Steak', 'Chicken']), dynamic([1, 2, 3, 4]), dynamic([5, 6, 7, 8])
+-- ]
+
+DROP TABLE IF EXISTS mv_expand_test_table;
+CREATE TABLE mv_expand_test_table
+(    
+   a UInt8,
+   b Array(String),
+   c Array(Int8),
+   d Array(Int8)
+) ENGINE = Memory;
+INSERT INTO mv_expand_test_table VALUES (1, ['Salmon', 'Steak','Chicken'],[1,2,3,4],[5,6,7,8]);
+set dialect='kusto';
+print '-- mv-expand --';
+print '-- mv_expand_test_table | mv-expand c --';
+mv_expand_test_table | mv-expand c;
+print '-- mv_expand_test_table | mv-expand c, d --';
+mv_expand_test_table | mv-expand c, d;
+print '-- mv_expand_test_table | mv-expand b | mv-expand c --';
+mv_expand_test_table | mv-expand b | mv-expand c;
+print '-- mv_expand_test_table | mv-expand with_itemindex=index b, c, d --';
+mv_expand_test_table | mv-expand with_itemindex=index b, c, d;
+print '-- mv_expand_test_table | mv-expand array_concat(c,d) --';
+mv_expand_test_table | mv-expand array_concat(c,d);
+print '-- mv_expand_test_table | mv-expand x = c, y = d --';
+mv_expand_test_table | mv-expand x = c, y = d;
+print '-- mv_expand_test_table | mv-expand xy = array_concat(c, d) --';
+mv_expand_test_table | mv-expand xy = array_concat(c, d);
+print '-- mv_expand_test_table | mv-expand xy = array_concat(c, d) limit 2| summarize count() by xy --';
+mv_expand_test_table | mv-expand xy = array_concat(c, d) limit 2| summarize count() by xy;
+print '-- mv_expand_test_table | mv-expand with_itemindex=index c,d to typeof(bool) --';
+mv_expand_test_table | mv-expand with_itemindex=index c,d to typeof(bool);
+print '-- mv_expand_test_table | mv-expand c to typeof(bool) --';
+mv_expand_test_table | mv-expand c to typeof(bool);
diff --git a/tests/queries/0_stateless/02366_kql_operator_in_sql.reference b/tests/queries/0_stateless/02366_kql_operator_in_sql.reference
new file mode 100644
index 000000000000..4e0987aa5c38
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_operator_in_sql.reference
@@ -0,0 +1,60 @@
+-- #1 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Apple		Skilled Manual	Bachelors	28
+-- #2 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #3 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #4 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #5 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #6 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #7 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #8 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #9 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #10 --
+-- #11 --
+-- #12 --
+-- #13 --
+-- #14 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
+-- #15 --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management abcd defg	Bachelors	33
+Latoya	Shen	Professional	Graduate Degree	25
+Apple		Skilled Manual	Bachelors	28
diff --git a/tests/queries/0_stateless/02366_kql_operator_in_sql.sql b/tests/queries/0_stateless/02366_kql_operator_in_sql.sql
new file mode 100644
index 000000000000..0b02faa06807
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_operator_in_sql.sql
@@ -0,0 +1,42 @@
+DROP TABLE IF EXISTS Customers;
+CREATE TABLE Customers
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Occupation String,
+    Education String,
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+
+INSERT INTO Customers VALUES  ('Theodore','Diaz','Skilled Manual','Bachelors',28),('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);
+Select '-- #1 --' ;
+select * from kql($$Customers | where FirstName !in ('Peter', 'Latoya')$$);
+Select '-- #2 --' ;
+select * from kql($$Customers | where FirstName !in ("test", "test2")$$);
+Select '-- #3 --' ;
+select * from kql($$Customers | where FirstName !contains 'Pet'$$);
+Select '-- #4 --' ;
+select * from kql($$Customers | where FirstName !contains_cs 'Pet'$$);
+Select '-- #5 --' ;
+select * from kql($$Customers | where FirstName !endswith 'ter'$$);
+Select '-- #6 --' ;
+select * from kql($$Customers | where FirstName !endswith_cs 'ter'$$);
+Select '-- #7 --' ;
+select * from kql($$Customers | where FirstName != 'Peter'$$);
+Select '-- #8 --' ;
+select * from kql($$Customers | where FirstName !has 'Peter'$$);
+Select '-- #9 --' ;
+select * from kql($$Customers | where FirstName !has_cs 'peter'$$);
+Select '-- #10 --' ;
+-- select * from kql($$Customers | where FirstName !hasprefix 'Peter'$$); -- will enable when analyzer fixed `and` issue
+Select '-- #11 --' ;
+--select * from kql($$Customers | where FirstName !hasprefix_cs 'Peter'$$);
+Select '-- #12 --' ;
+--select * from kql($$Customers | where FirstName !hassuffix 'Peter'$$);
+Select '-- #13 --' ;
+--select * from kql($$Customers | where FirstName !hassuffix_cs 'Peter'$$);
+Select '-- #14 --' ;
+select * from kql($$Customers | where FirstName !startswith 'Peter'$$);
+Select '-- #15 --' ;
+select * from kql($$Customers | where FirstName !startswith_cs 'Peter'$$);
+DROP TABLE IF EXISTS Customers;
diff --git a/tests/queries/0_stateless/02366_kql_summarize.reference b/tests/queries/0_stateless/02366_kql_summarize.reference
new file mode 100644
index 000000000000..aeb42feb6bea
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_summarize.reference
@@ -0,0 +1,92 @@
+-- test summarize --
+12	25	46	32.416666666666664	389
+Skilled Manual	5	26	36	30.2	151
+Professional	6	25	46	34.166666666666664	205
+Management abcd defg	1	33	33	33	33
+Skilled Manual	0
+Professional	2
+Management abcd defg	0
+Skilled Manual	36
+Professional	38
+Management abcd defg	33
+Skilled Manual	26
+Professional	25
+Management abcd defg	33
+Skilled Manual	30.2
+Professional	29.25
+Management abcd defg	33
+Skilled Manual	151
+Professional	117
+Management abcd defg	33
+4
+2
+40	2
+30	4
+20	6
+Skilled Manual	5
+Professional	6
+Management abcd defg	1
+-- make_list() --
+Skilled Manual	['Bachelors','Graduate Degree','High School','Partial College','Bachelors']
+Professional	['Graduate Degree','Partial College','Partial College','Partial College','Partial College','Partial College']
+Management abcd defg	['Bachelors']
+Skilled Manual	['Bachelors','Graduate Degree']
+Professional	['Graduate Degree','Partial College']
+Management abcd defg	['Bachelors']
+-- make_list_if() --
+Skilled Manual	['Edward','Christine']
+Professional	['Dalton','Angel']
+Management abcd defg	['Stephanie']
+Skilled Manual	['Edward']
+Professional	['Dalton']
+Management abcd defg	['Stephanie']
+-- make_set() --
+Skilled Manual	['Graduate Degree','High School','Partial College','Bachelors']
+Professional	['Graduate Degree','Partial College']
+Management abcd defg	['Bachelors']
+Skilled Manual	['Graduate Degree','Bachelors']
+Professional	['Graduate Degree','Partial College']
+Management abcd defg	['Bachelors']
+-- make_set_if() --
+Skilled Manual	['Partial College','High School']
+Professional	['Partial College']
+Management abcd defg	['Bachelors']
+Skilled Manual	['High School']
+Professional	['Partial College']
+Management abcd defg	['Bachelors']
+-- stdev() --
+6.855102059227432
+-- stdevif() --
+7.557189365836421
+-- binary_all_and --
+42
+-- binary_all_or --
+46
+-- binary_all_xor --
+4
+43.8
+25.55	30.5	43.8
+30.5
+35
+[25,35,45]
+-- Summarize following sort --
+Skilled Manual	5
+Professional	6
+Management abcd defg	1
+-- summarize with bin --
+0	1
+245000	2
+0	1
+245	2
+0	1
+245	2
+2015-10-12 00:00:00.000000000
+2016-10-12 00:00:00.000000000
+-- make_list_with_nulls --
+['Theodore','Stephanie','Peter','Latoya','Joshua','Edward','Dalton','Christine','Cameron','Angel','Apple',NULL]
+Skilled Manual	['Theodore','Peter','Edward','Christine','Apple']
+Professional	['Latoya','Joshua','Dalton','Cameron','Angel',NULL]
+Management abcd defg	['Stephanie']
+Skilled Manual	['Theodore','Peter','Edward','Christine','Apple']	[28,26,36,33,28]
+Professional	['Latoya','Joshua','Dalton','Cameron','Angel',NULL]	[25,26,42,28,46,38]
+Management abcd defg	['Stephanie']	[33]
diff --git a/tests/queries/0_stateless/02366_kql_summarize.sql b/tests/queries/0_stateless/02366_kql_summarize.sql
new file mode 100644
index 000000000000..21a1b643d987
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_summarize.sql
@@ -0,0 +1,102 @@
+-- datatable(FirstName:string, LastName:string, Occupation:string, Education:string, Age:int) [
+--     'Theodore', 'Diaz', 'Skilled Manual', 'Bachelors', 28, 
+--     'Stephanie', 'Cox', 'Management abcd defg', 'Bachelors', 33, 
+--     'Peter', 'Nara', 'Skilled Manual', 'Graduate Degree', 26, 
+--     'Latoya', 'Shen', 'Professional', 'Graduate Degree', 25, 
+--     'Joshua', 'Lee', 'Professional', 'Partial College', 26, 
+--     'Edward', 'Hernandez', 'Skilled Manual', 'High School', 36, 
+--     'Dalton', 'Wood', 'Professional', 'Partial College', 42, 
+--     'Christine', 'Nara', 'Skilled Manual', 'Partial College', 33, 
+--     'Cameron', 'Rodriguez', 'Professional', 'Partial College', 28, 
+--     'Angel', 'Stewart', 'Professional', 'Partial College', 46, 
+--     'Apple', '', 'Skilled Manual', 'Bachelors', 28, 
+--     dynamic(null), 'why', 'Professional', 'Partial College', 38
+-- ]
+
+DROP TABLE IF EXISTS Customers;
+CREATE TABLE Customers
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Occupation String,
+    Education String,
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+
+INSERT INTO Customers VALUES  ('Theodore','Diaz','Skilled Manual','Bachelors',28),('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Joshua','Lee','Professional','Partial College',26),('Edward','Hernandez','Skilled Manual','High School',36),('Dalton','Wood','Professional','Partial College',42),('Christine','Nara','Skilled Manual','Partial College',33),('Cameron','Rodriguez','Professional','Partial College',28),('Angel','Stewart','Professional','Partial College',46),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);
+
+drop table if exists EventLog;
+create table EventLog
+(
+    LogEntry String,
+    Created Int64
+) ENGINE = Memory;
+
+insert into EventLog values ('Darth Vader has entered the room.', 546), ('Rambo is suspciously looking at Darth Vader.', 245234), ('Darth Sidious electrocutes both using Force Lightning.', 245554);
+
+drop table if exists Dates;
+create table Dates
+(
+    EventTime DateTime,
+) ENGINE = Memory;
+
+Insert into Dates VALUES ('2015-10-12') , ('2016-10-12')
+Select '-- test summarize --' ;
+set dialect='kusto';
+Customers | summarize count(), min(Age), max(Age), avg(Age), sum(Age);
+Customers | summarize count(), min(Age), max(Age), avg(Age), sum(Age) by Occupation | order by Occupation;
+Customers | summarize countif(Age>40) by Occupation | order by Occupation;
+Customers | summarize MyMax = maxif(Age, Age<40) by Occupation | order by Occupation;
+Customers | summarize MyMin = minif(Age, Age<40) by Occupation | order by Occupation;
+Customers | summarize MyAvg = avgif(Age, Age<40) by Occupation | order by Occupation;
+Customers | summarize MySum = sumif(Age, Age<40) by Occupation | order by Occupation;
+Customers | summarize dcount(Education);
+Customers | summarize dcountif(Education, Occupation=='Professional');
+Customers | summarize count_ = count() by bin(Age, 10) | order by count_ asc;
+Customers | summarize job_count = count() by Occupation | where job_count > 0 | order by Occupation;
+Customers | summarize 'Edu Count'=count() by Education | sort by 'Edu Count' desc; -- { clientError 62 }
+
+print '-- make_list() --';
+Customers | summarize f_list = make_list(Education) by Occupation | sort by Occupation;
+Customers | summarize f_list = make_list(Education, 2) by Occupation | sort by Occupation;
+print '-- make_list_if() --';
+Customers | summarize f_list = make_list_if(FirstName, Age>30) by Occupation | sort by Occupation;
+Customers | summarize f_list = make_list_if(FirstName, Age>30, 1) by Occupation | sort by Occupation;
+print '-- make_set() --';
+Customers | summarize f_list = make_set(Education) by Occupation | sort by Occupation;
+Customers | summarize f_list = make_set(Education, 2) by Occupation | sort by Occupation;
+print '-- make_set_if() --';
+Customers | summarize f_list = make_set_if(Education, Age>30) by Occupation | sort by Occupation;
+Customers | summarize f_list = make_set_if(Education, Age>30, 1) by Occupation | sort by Occupation;
+print '-- stdev() --';
+Customers | project Age | summarize stdev(Age);
+print '-- stdevif() --';
+Customers | project Age | summarize stdevif(Age, Age%2==0);
+print '-- binary_all_and --';
+Customers | project Age | where Age > 40 | summarize binary_all_and(Age);
+print '-- binary_all_or --';
+Customers | project Age | where Age > 40 | summarize binary_all_or(Age);
+print '-- binary_all_xor --';
+Customers | project Age | where Age > 40 | summarize binary_all_xor(Age);
+
+Customers | project Age | summarize percentile(Age, 95);
+Customers | project Age | summarize percentiles(Age, 5, 50, 95)|project round(percentiles_Age[0],2),round(percentiles_Age[1],2),round(percentiles_Age[2],2);
+Customers | project Age | summarize percentiles(Age, 5, 50, 95)[1];
+Customers | summarize w=count() by AgeBucket=bin(Age, 5) | summarize percentilew(AgeBucket, w, 75);
+Customers | summarize w=count() by AgeBucket=bin(Age, 5) | summarize percentilesw(AgeBucket, w, 50, 75, 99.9);
+
+print '-- Summarize following sort --';
+Customers | sort by FirstName | summarize count() by Occupation | sort by Occupation;
+
+print '-- summarize with bin --';
+EventLog | summarize count=count() by bin(Created, 1000);
+EventLog | summarize count=count() by bin(unixtime_seconds_todatetime(Created/1000), 1s);
+EventLog | summarize count=count() by time_label=bin(Created/1000, 1s);
+Dates | project bin(datetime(EventTime), 1m);
+print '-- make_list_with_nulls --';
+Customers | summarize t = make_list_with_nulls(FirstName);
+Customers | summarize f_list = make_list_with_nulls(FirstName) by Occupation | sort by Occupation;
+Customers | summarize f_list = make_list_with_nulls(FirstName), a_list = make_list_with_nulls(Age) by Occupation | sort by Occupation;
+-- TODO:
+-- arg_max()
+-- arg_min()
diff --git a/tests/queries/0_stateless/02366_kql_tabular.reference b/tests/queries/0_stateless/02366_kql_tabular.reference
new file mode 100644
index 000000000000..e70c02ce34fa
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_tabular.reference
@@ -0,0 +1,139 @@
+-- test Query only has table name: --
+Theodore	Diaz	Skilled Manual	Bachelors	28
+Stephanie	Cox	Management	Bachelors	33
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Latoya	Shen	Professional	Graduate Degree	25
+Joshua	Lee	Professional	Partial College	26
+Edward	Hernandez	Skilled Manual	High School	36
+Dalton	Wood	Professional	Partial College	42
+Christine	Nara	Skilled Manual	Partial College	33
+Cameron	Rodriguez	Professional	Partial College	28
+Angel	Stewart	Professional	Partial College	46
+-- Query has Column Selection --
+Theodore	Diaz	Skilled Manual
+Stephanie	Cox	Management
+Peter	Nara	Skilled Manual
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+Edward	Hernandez	Skilled Manual
+Dalton	Wood	Professional
+Christine	Nara	Skilled Manual
+Cameron	Rodriguez	Professional
+Angel	Stewart	Professional
+-- Query has limit --
+Theodore	Diaz	Skilled Manual
+Stephanie	Cox	Management
+Peter	Nara	Skilled Manual
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+Theodore	Diaz	Skilled Manual
+Stephanie	Cox	Management
+Peter	Nara	Skilled Manual
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+-- Query has second limit with bigger value --
+Theodore	Diaz	Skilled Manual
+Stephanie	Cox	Management
+Peter	Nara	Skilled Manual
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+-- Query has second limit with smaller value --
+Theodore	Diaz	Skilled Manual
+Stephanie	Cox	Management
+Peter	Nara	Skilled Manual
+-- Query has second Column selection --
+Theodore	Diaz
+Stephanie	Cox
+Peter	Nara
+-- Query has second Column selection with extra column --
+-- Query with desc sort --
+Theodore
+Stephanie
+Peter
+Latoya
+Joshua
+Skilled Manual
+Skilled Manual
+Professional
+Professional
+Management
+-- Query with asc sort --
+Management
+Professional
+Professional
+Skilled Manual
+Skilled Manual
+-- Query with sort (without keyword asc desc) --
+Theodore
+Stephanie
+Peter
+Latoya
+Joshua
+Skilled Manual
+Skilled Manual
+Professional
+Professional
+Management
+-- Query with sort 2 Columns with different direction --
+Stephanie	Cox	Management
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+Peter	Nara	Skilled Manual
+Theodore	Diaz	Skilled Manual
+-- Query with second sort --
+Stephanie	Cox	Management
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+Peter	Nara	Skilled Manual
+Theodore	Diaz	Skilled Manual
+-- Test String Equals (==) --
+Theodore	Diaz	Skilled Manual
+Peter	Nara	Skilled Manual
+Edward	Hernandez	Skilled Manual
+Christine	Nara	Skilled Manual
+-- Test String Not equals (!=) --
+Stephanie	Cox	Management
+Latoya	Shen	Professional
+Joshua	Lee	Professional
+Dalton	Wood	Professional
+Cameron	Rodriguez	Professional
+Angel	Stewart	Professional
+-- Test Filter using a list (in) --
+Theodore	Diaz	Skilled Manual	Bachelors
+Stephanie	Cox	Management	Bachelors
+Edward	Hernandez	Skilled Manual	High School
+-- Test Filter using a list (!in) --
+Peter	Nara	Skilled Manual	Graduate Degree
+Latoya	Shen	Professional	Graduate Degree
+Joshua	Lee	Professional	Partial College
+Dalton	Wood	Professional	Partial College
+Christine	Nara	Skilled Manual	Partial College
+Cameron	Rodriguez	Professional	Partial College
+Angel	Stewart	Professional	Partial College
+-- Test Filter using common string operations (contains_cs) --
+Joshua	Lee	Professional	Partial College
+Dalton	Wood	Professional	Partial College
+Christine	Nara	Skilled Manual	Partial College
+Cameron	Rodriguez	Professional	Partial College
+Angel	Stewart	Professional	Partial College
+-- Test Filter using common string operations (startswith_cs) --
+Latoya	Shen	Professional	Graduate Degree
+Joshua	Lee	Professional	Partial College
+Dalton	Wood	Professional	Partial College
+Cameron	Rodriguez	Professional	Partial College
+Angel	Stewart	Professional	Partial College
+-- Test Filter using common string operations (endswith_cs) --
+Latoya	Shen	Professional	Graduate Degree
+Joshua	Lee	Professional	Partial College
+-- Test Filter using numerical equal (==) --
+Peter	Nara	Skilled Manual	Graduate Degree	26
+Joshua	Lee	Professional	Partial College	26
+-- Test Filter using numerical great and less (> , <) --
+Stephanie	Cox	Management	Bachelors	33
+Edward	Hernandez	Skilled Manual	High School	36
+Christine	Nara	Skilled Manual	Partial College	33
+-- Test Filter using multi where --
+Dalton	Wood	Professional	Partial College	42
+Angel	Stewart	Professional	Partial College	46
+-- Complex query with unknown function --
+-- Missing column in front of startsWith --
diff --git a/tests/queries/0_stateless/02366_kql_tabular.sql b/tests/queries/0_stateless/02366_kql_tabular.sql
new file mode 100644
index 000000000000..f73c4c09ccaa
--- /dev/null
+++ b/tests/queries/0_stateless/02366_kql_tabular.sql
@@ -0,0 +1,88 @@
+DROP TABLE IF EXISTS Customers;
+CREATE TABLE Customers
+(    
+    FirstName Nullable(String),
+    LastName String, 
+    Occupation String,
+    Education String,
+    Age Nullable(UInt8)
+) ENGINE = Memory;
+
+INSERT INTO Customers VALUES ('Theodore','Diaz','Skilled Manual','Bachelors',28), ('Stephanie','Cox','Management','Bachelors',33), ('Peter','Nara','Skilled Manual','Graduate Degree',26), ('Latoya','Shen','Professional','Graduate Degree',25), ('Joshua','Lee','Professional','Partial College',26), ('Edward','Hernandez','Skilled Manual','High School',36), ('Dalton','Wood','Professional','Partial College',42), ('Christine','Nara','Skilled Manual','Partial College',33), ('Cameron','Rodriguez','Professional','Partial College',28), ('Angel','Stewart','Professional','Partial College',46);
+
+set dialect='kusto';
+print '-- test Query only has table name: --';
+Customers;
+
+print '-- Query has Column Selection --';
+Customers | project FirstName,LastName,Occupation;
+
+print '-- Query has limit --';
+Customers | project FirstName,LastName,Occupation | take 5;
+Customers | project FirstName,LastName,Occupation | limit 5;
+
+print '-- Query has second limit with bigger value --';
+Customers | project FirstName,LastName,Occupation | take 5 | take 7;
+
+print '-- Query has second limit with smaller value --';
+Customers | project FirstName,LastName,Occupation | take 5 | take 3;
+
+print '-- Query has second Column selection --';
+Customers | project FirstName,LastName,Occupation | take 3 | project FirstName,LastName;
+
+print '-- Query has second Column selection with extra column --';
+Customers| project FirstName,LastName,Occupation | take 3 | project FirstName,LastName,Education;-- { serverError 47 }
+
+print '-- Query with desc sort --';
+Customers | project FirstName | take 5 | sort by FirstName desc;
+Customers | project Occupation | take 5 | order by Occupation desc;
+
+print '-- Query with asc sort --';
+Customers | project Occupation | take 5 | sort by Occupation asc;
+
+print '-- Query with sort (without keyword asc desc) --';
+Customers | project FirstName | take 5 | sort by FirstName;
+Customers | project Occupation | take 5 | order by Occupation;
+
+print '-- Query with sort 2 Columns with different direction --';
+Customers | project FirstName,LastName,Occupation | take 5 | sort by Occupation asc, LastName desc;
+
+print '-- Query with second sort --';
+Customers | project FirstName,LastName,Occupation | take 5 | sort by Occupation desc |sort by Occupation asc, LastName desc;
+
+print '-- Test String Equals (==) --';
+Customers | project FirstName,LastName,Occupation | where Occupation == 'Skilled Manual';
+
+print '-- Test String Not equals (!=) --';
+Customers | project FirstName,LastName,Occupation | where Occupation != 'Skilled Manual';
+
+print '-- Test Filter using a list (in) --';
+Customers | project FirstName,LastName,Occupation,Education | where Education in  ('Bachelors','High School');
+
+print '-- Test Filter using a list (!in) --';
+set dialect='kusto';
+Customers | project FirstName,LastName,Occupation,Education | where Education !in  ('Bachelors','High School');
+
+print '-- Test Filter using common string operations (contains_cs) --';
+Customers | project FirstName,LastName,Occupation,Education | where Education contains_cs 'Coll';
+
+print '-- Test Filter using common string operations (startswith_cs) --';
+Customers | project FirstName,LastName,Occupation,Education | where Occupation startswith_cs 'Prof';
+
+print '-- Test Filter using common string operations (endswith_cs) --';
+Customers | project FirstName,LastName,Occupation,Education | where FirstName endswith_cs 'a';
+
+print '-- Test Filter using numerical equal (==) --';
+Customers | project FirstName,LastName,Occupation,Education,Age | where Age == 26;
+
+print '-- Test Filter using numerical great and less (> , <) --';
+Customers | project FirstName,LastName,Occupation,Education,Age | where Age > 30 and Age < 40;
+
+print '-- Test Filter using multi where --';
+Customers | project FirstName,LastName,Occupation,Education,Age | where Age > 30 | where Occupation == 'Professional';
+
+print '-- Complex query with unknown function --';
+hits | where CounterID == 62 and EventDate >= '2013-07-14' and EventDate <= '2013-07-15' and IsRefresh == 0 and DontCountHits == 0 | summarize count() by d=bin(poopoo(EventTime), 1m) | order by d | limit 10; -- { clientError UNKNOWN_FUNCTION }
+
+print '-- Missing column in front of startsWith --';
+StormEvents | where startswith "W" | summarize Count=count() by State; -- { clientError SYNTAX_ERROR }
diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql
index 4f40da6c626a..148ad303bd45 100644
--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql
+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql
@@ -15,7 +15,7 @@ AND name NOT IN (
     'h3ToGeoBoundary', 'h3ToParent', 'h3ToString', 'h3UnidirectionalEdgeIsValid', 'h3kRing', 'stringToH3',
     'geoToS2', 's2CapContains', 's2CapUnion', 's2CellsIntersect', 's2GetNeighbors', 's2RectAdd', 's2RectContains', 's2RectIntersection', 's2RectUnion', 's2ToGeo',
     'normalizeUTF8NFC', 'normalizeUTF8NFD', 'normalizeUTF8NFKC', 'normalizeUTF8NFKD',
-    'lemmatize', 'tokenize', 'stem', 'synonyms',
+    'lemmatize', 'tokenize', 'stem', 'synonyms', 'kql_array_sort_asc', 'kql_array_sort_desc',
     'detectCharset', 'detectLanguageUnknown', 'detectProgrammingLanguage', 'detectTonality'
      -- these functions are not enabled in fast test
 ) ORDER BY name;
