{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42510,
  "instance_id": "ClickHouse__ClickHouse-42510",
  "issue_numbers": [
    "1125",
    "1268"
  ],
  "base_commit": "ce734149f7190021a0c3fa628d4623027074a867",
  "patch": "diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex ac5c9f99e0e1..7d70b81a178c 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -706,6 +706,17 @@ bool Client::processWithFuzzing(const String & full_query)\n         return true;\n     }\n \n+    // Kusto is not a subject for fuzzing (yet)\n+    if (global_context->getSettingsRef().dialect == DB::Dialect::kusto)\n+    {\n+        return true;\n+    }\n+    if (auto *q = orig_ast->as<ASTSetQuery>())\n+    {\n+        if (auto *setDialect = q->changes.tryGet(\"dialect\"); setDialect && setDialect->safeGet<String>() == \"kusto\")\n+            return true;\n+    }\n+\n     // Don't repeat:\n     // - INSERT -- Because the tables may grow too big.\n     // - CREATE -- Because first we run the unmodified query, it will succeed,\ndiff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 06d4b98b1ff5..81a75a0d0023 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -592,8 +592,8 @@ if (ENABLE_TESTS)\n     )\n \n     target_link_libraries(unit_tests_dbms PRIVATE\n-        ch_contrib::gtest_all\n         ch_contrib::gmock_all\n+        ch_contrib::gtest_all\n         clickhouse_functions\n         clickhouse_aggregate_functions\n         clickhouse_parsers\ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex 30ffffdeeb1e..9ca104ff942d 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -47,6 +47,7 @@\n #include <Parsers/ASTFunction.h>\n #include <Parsers/Kusto/ParserKQLStatement.h>\n #include <Parsers/PRQL/ParserPRQLQuery.h>\n+#include <Parsers/Kusto/parseKQLQuery.h>\n \n #include <Processors/Formats/Impl/NullFormat.h>\n #include <Processors/Formats/IInputFormat.h>\n@@ -349,7 +350,10 @@ ASTPtr ClientBase::parseQuery(const char *& pos, const char * end, bool allow_mu\n     if (is_interactive || ignore_error)\n     {\n         String message;\n-        res = tryParseQuery(*parser, pos, end, message, true, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n+        if (dialect == Dialect::kusto)\n+            res = tryParseKQLQuery(*parser, pos, end, message, true, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n+        else\n+            res = tryParseQuery(*parser, pos, end, message, true, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n \n         if (!res)\n         {\n@@ -359,7 +363,10 @@ ASTPtr ClientBase::parseQuery(const char *& pos, const char * end, bool allow_mu\n     }\n     else\n     {\n-        res = parseQueryAndMovePosition(*parser, pos, end, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n+        if (dialect == Dialect::kusto)\n+            res = parseKQLQueryAndMovePosition(*parser, pos, end, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n+        else\n+            res = parseQueryAndMovePosition(*parser, pos, end, \"\", allow_multi_statements, max_length, settings.max_parser_depth);\n     }\n \n     if (is_interactive)\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex a30d8040f479..96e80c103e21 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -140,7 +140,7 @@ IMPLEMENT_SETTING_ENUM(Dialect, ErrorCodes::BAD_ARGUMENTS,\n     {{\"clickhouse\", Dialect::clickhouse},\n      {\"kusto\", Dialect::kusto},\n      {\"prql\", Dialect::prql}})\n-    // FIXME: do not add 'kusto_auto' to the list. Maybe remove it from code completely?\n+\n \n IMPLEMENT_SETTING_ENUM(ParallelReplicasCustomKeyFilterType, ErrorCodes::BAD_ARGUMENTS,\n     {{\"default\", ParallelReplicasCustomKeyFilterType::DEFAULT},\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex 034e4c8c887e..006221e45933 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -207,7 +207,6 @@ enum class Dialect\n {\n     clickhouse,\n     kusto,\n-    kusto_auto,\n     prql,\n };\n \ndiff --git a/src/Functions/CMakeLists.txt b/src/Functions/CMakeLists.txt\nindex 48008827f48b..31f7f24eb130 100644\n--- a/src/Functions/CMakeLists.txt\n+++ b/src/Functions/CMakeLists.txt\n@@ -106,6 +106,9 @@ list (APPEND OBJECT_LIBS $<TARGET_OBJECTS:clickhouse_functions_url>)\n add_subdirectory(array)\n list (APPEND OBJECT_LIBS $<TARGET_OBJECTS:clickhouse_functions_array>)\n \n+add_subdirectory(Kusto)\n+list (APPEND OBJECT_LIBS $<TARGET_OBJECTS:clickhouse_functions_kusto>)\n+\n if (TARGET ch_contrib::datasketches)\n     add_subdirectory(UniqTheta)\n     list (APPEND OBJECT_LIBS $<TARGET_OBJECTS:clickhouse_functions_uniqtheta>)\ndiff --git a/src/Functions/Kusto/CMakeLists.txt b/src/Functions/Kusto/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..3c534905d227\n--- /dev/null\n+++ b/src/Functions/Kusto/CMakeLists.txt\n@@ -0,0 +1,8 @@\n+include(\"${ClickHouse_SOURCE_DIR}/cmake/dbms_glob_sources.cmake\")\n+add_headers_and_sources(clickhouse_functions_kusto .)\n+add_library(clickhouse_functions_kusto OBJECT ${clickhouse_functions_kusto_sources} ${clickhouse_functions_kusto_headers})\n+target_link_libraries(clickhouse_functions_kusto PRIVATE dbms clickhouse_functions_gatherutils)\n+\n+if (OMIT_HEAVY_DEBUG_SYMBOLS)\n+    target_compile_options(clickhouse_functions_kusto PRIVATE \"-g0\")\n+endif()\ndiff --git a/src/Functions/Kusto/KqlArraySort.cpp b/src/Functions/Kusto/KqlArraySort.cpp\nnew file mode 100644\nindex 000000000000..5be36328cc37\n--- /dev/null\n+++ b/src/Functions/Kusto/KqlArraySort.cpp\n@@ -0,0 +1,264 @@\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnTuple.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/Kusto/KqlFunctionBase.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+template <typename Name, bool is_desc>\n+class FunctionKqlArraySort : public KqlFunctionBase\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+    explicit FunctionKqlArraySort(ContextPtr context_) : context(context_) { }\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionKqlArraySort>(context); }\n+\n+    String getName() const override { return name; }\n+\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.empty())\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Function {} needs at least one argument; passed {}.\",\n+                getName(),\n+                arguments.size());\n+\n+        auto array_count = arguments.size();\n+\n+        if (!isArray(arguments.at(array_count - 1).type))\n+            --array_count;\n+\n+        DataTypes nested_types;\n+        for (size_t index = 0; index < array_count; ++index)\n+        {\n+            const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[index].type.get());\n+            if (!array_type)\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Argument {} of function {} must be array. Found {} instead.\",\n+                    index + 1,\n+                    getName(),\n+                    arguments[0].type->getName());\n+\n+            nested_types.emplace_back(array_type->getNestedType());\n+        }\n+\n+        DataTypes data_types(array_count);\n+\n+        for (size_t i = 0; i < array_count; ++i)\n+            data_types[i] = std::make_shared<DataTypeArray>(makeNullable(nested_types[i]));\n+\n+        return std::make_shared<DataTypeTuple>(data_types);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        size_t array_count = arguments.size();\n+        const auto & last_arg = arguments[array_count - 1];\n+\n+        size_t input_rows_count_local = input_rows_count;\n+\n+        bool null_last = true;\n+        if (!isArray(last_arg.type))\n+        {\n+            --array_count;\n+            null_last = check_condition(last_arg, context, input_rows_count_local);\n+        }\n+\n+        ColumnsWithTypeAndName new_args;\n+        ColumnPtr first_array_column;\n+        std::unordered_set<size_t> null_indices;\n+        DataTypes nested_types;\n+\n+        String sort_function = is_desc ? \"arrayReverseSort\" : \"arraySort\";\n+\n+        for (size_t i = 0; i < array_count; ++i)\n+        {\n+            ColumnPtr holder = arguments[i].column->convertToFullColumnIfConst();\n+\n+            const ColumnArray * column_array = checkAndGetColumn<ColumnArray>(holder.get());\n+            const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[i].type.get());\n+\n+            if (!column_array)\n+                throw Exception(\n+                    ErrorCodes::ILLEGAL_COLUMN,\n+                    \"Argument {} of function {} must be array. Found column {} instead.\",\n+                    i + 1,\n+                    getName(),\n+                    holder->getName());\n+\n+            nested_types.emplace_back(makeNullable(array_type->getNestedType()));\n+            if (i == 0)\n+            {\n+                first_array_column = holder;\n+                new_args.push_back(arguments[i]);\n+            }\n+            else if (!column_array->hasEqualOffsets(static_cast<const ColumnArray &>(*first_array_column)))\n+            {\n+                null_indices.insert(i);\n+            }\n+            else\n+                new_args.push_back(arguments[i]);\n+        }\n+\n+        auto zipped\n+            = FunctionFactory::instance().get(\"arrayZip\", context)->build(new_args)->execute(new_args, result_type, input_rows_count_local);\n+\n+        ColumnsWithTypeAndName sort_arg({{zipped, std::make_shared<DataTypeArray>(result_type), \"zipped\"}});\n+        auto sorted_tuple\n+            = FunctionFactory::instance().get(sort_function, context)->build(sort_arg)->execute(sort_arg, result_type, input_rows_count_local);\n+\n+        auto null_type = std::make_shared<DataTypeNullable>(std::make_shared<DataTypeInt8>());\n+\n+        Columns tuple_columns(array_count);\n+        size_t sorted_index = 0;\n+        for (size_t i = 0; i < array_count; ++i)\n+        {\n+            if (null_indices.contains(i))\n+            {\n+                auto fun_array = FunctionFactory::instance().get(\"array\", context);\n+\n+                DataTypePtr arg_type\n+                    = std::make_shared<DataTypeArray>(makeNullable(nested_types[i]));\n+\n+                ColumnsWithTypeAndName null_array_arg({\n+                    {null_type->createColumnConstWithDefaultValue(input_rows_count_local), null_type, \"NULL\"},\n+                });\n+\n+                tuple_columns[i] = fun_array->build(null_array_arg)->execute(null_array_arg, arg_type, input_rows_count_local);\n+                tuple_columns[i] = tuple_columns[i]->convertToFullColumnIfConst();\n+            }\n+            else\n+            {\n+                ColumnsWithTypeAndName untuple_args(\n+                    {{ColumnWithTypeAndName(sorted_tuple, std::make_shared<DataTypeArray>(result_type), \"sorted\")},\n+                     {DataTypeUInt8().createColumnConst(1, toField(UInt8(sorted_index + 1))), std::make_shared<DataTypeUInt8>(), \"\"}});\n+                auto tuple_coulmn = FunctionFactory::instance()\n+                                        .get(\"tupleElement\", context)\n+                                        ->build(untuple_args)\n+                                        ->execute(untuple_args, result_type, input_rows_count_local);\n+\n+                auto out_tmp = ColumnArray::create(nested_types[i]->createColumn());\n+\n+                size_t array_size = tuple_coulmn->size();\n+                const auto * arr = checkAndGetColumn<ColumnArray>(tuple_coulmn.get());\n+\n+                for (size_t j = 0; j < array_size; ++j)\n+                {\n+                    Field arr_field;\n+                    arr->get(j, arr_field);\n+                    out_tmp->insert(arr_field);\n+                }\n+\n+                tuple_columns[i] = std::move(out_tmp);\n+\n+                ++sorted_index;\n+            }\n+        }\n+\n+        if (!null_last)\n+        {\n+            Columns adjusted_columns(array_count);\n+\n+            ColumnWithTypeAndName arg_of_index{nullptr, std::make_shared<DataTypeArray>(nested_types[0]), \"array\"};\n+            arg_of_index.column = tuple_columns[0];\n+\n+            auto inside_null_type = nested_types[0];\n+            ColumnsWithTypeAndName indexof_args({\n+                arg_of_index,\n+                {inside_null_type->createColumnConstWithDefaultValue(input_rows_count_local), inside_null_type, \"NULL\"},\n+            });\n+\n+            auto null_index_datetype = std::make_shared<DataTypeUInt64>();\n+\n+            ColumnWithTypeAndName slice_index{nullptr, null_index_datetype, \"\"};\n+            slice_index.column = FunctionFactory::instance()\n+                                     .get(\"indexOf\", context)\n+                                     ->build(indexof_args)\n+                                     ->execute(indexof_args, result_type, input_rows_count_local);\n+\n+            auto null_index_in_array = slice_index.column->get64(0);\n+            if (null_index_in_array > 0)\n+            {\n+                ColumnWithTypeAndName slice_index_len{nullptr, null_index_datetype, \"\"};\n+                slice_index_len.column = DataTypeUInt64().createColumnConst(1, toField(UInt64(null_index_in_array - 1)));\n+\n+                auto fun_slice = FunctionFactory::instance().get(\"arraySlice\", context);\n+\n+                for (size_t i = 0; i < array_count; ++i)\n+                {\n+                    if (null_indices.contains(i))\n+                    {\n+                        adjusted_columns[i] = std::move(tuple_columns[i]);\n+                    }\n+                    else\n+                    {\n+                        DataTypePtr arg_type = std::make_shared<DataTypeArray>(nested_types[i]);\n+\n+                        ColumnsWithTypeAndName slice_args_left(\n+                            {{ColumnWithTypeAndName(tuple_columns[i], arg_type, \"array\")},\n+                             {DataTypeUInt8().createColumnConst(1, toField(UInt8(1))), std::make_shared<DataTypeUInt8>(), \"\"},\n+                             slice_index_len});\n+\n+                        ColumnsWithTypeAndName slice_args_right(\n+                            {{ColumnWithTypeAndName(tuple_columns[i], arg_type, \"array\")}, slice_index});\n+                        ColumnWithTypeAndName arr_left{\n+                            fun_slice->build(slice_args_left)->execute(slice_args_left, arg_type, input_rows_count_local), arg_type, \"\"};\n+                        ColumnWithTypeAndName arr_right{\n+                            fun_slice->build(slice_args_right)->execute(slice_args_right, arg_type, input_rows_count_local), arg_type, \"\"};\n+\n+                        ColumnsWithTypeAndName arr_cancat({arr_right, arr_left});\n+                        auto out_tmp = FunctionFactory::instance()\n+                                           .get(\"arrayConcat\", context)\n+                                           ->build(arr_cancat)\n+                                           ->execute(arr_cancat, arg_type, input_rows_count_local);\n+                        adjusted_columns[i] = std::move(out_tmp);\n+                    }\n+                }\n+                return ColumnTuple::create(adjusted_columns);\n+            }\n+        }\n+        return ColumnTuple::create(tuple_columns);\n+    }\n+\n+private:\n+    ContextPtr context;\n+};\n+\n+struct NameKqlArraySortAsc\n+{\n+    static constexpr auto name = \"kql_array_sort_asc\";\n+};\n+\n+struct NameKqlArraySortDesc\n+{\n+    static constexpr auto name = \"kql_array_sort_desc\";\n+};\n+\n+using FunctionKqlArraySortAsc = FunctionKqlArraySort<NameKqlArraySortAsc, false>;\n+using FunctionKqlArraySortDesc = FunctionKqlArraySort<NameKqlArraySortDesc, true>;\n+\n+REGISTER_FUNCTION(KqlArraySort)\n+{\n+    factory.registerFunction<FunctionKqlArraySortAsc>();\n+    factory.registerFunction<FunctionKqlArraySortDesc>();\n+}\n+\n+}\ndiff --git a/src/Functions/Kusto/KqlFunctionBase.h b/src/Functions/Kusto/KqlFunctionBase.h\nnew file mode 100644\nindex 000000000000..efdf8982f4b1\n--- /dev/null\n+++ b/src/Functions/Kusto/KqlFunctionBase.h\n@@ -0,0 +1,32 @@\n+#pragma once\n+\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnVector.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <Interpreters/Context_fwd.h>\n+#include \"Functions/array/FunctionArrayMapped.h\"\n+\n+namespace DB\n+{\n+\n+class KqlFunctionBase : public IFunction\n+{\n+public:\n+    static bool check_condition (const ColumnWithTypeAndName & condition, ContextPtr context, size_t input_rows_count)\n+    {\n+        ColumnsWithTypeAndName if_columns(\n+        {\n+            condition,\n+            {DataTypeUInt8().createColumnConst(1, toField(UInt8(1))), std::make_shared<DataTypeUInt8>(), \"\"},\n+            {DataTypeUInt8().createColumnConst(1, toField(UInt8(2))), std::make_shared<DataTypeUInt8>(), \"\"}\n+        });\n+        auto if_res = FunctionFactory::instance().get(\"if\", context)->build(if_columns)->execute(if_columns, std::make_shared<DataTypeUInt8>(), input_rows_count);\n+        auto result = if_res->getUInt(0);\n+        return (result == 1);\n+    }\n+};\n+\n+}\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 54bfe33bc00e..637195b1bf60 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -77,6 +77,7 @@\n \n #include <Parsers/Kusto/ParserKQLStatement.h>\n #include <Parsers/PRQL/ParserPRQLQuery.h>\n+#include <Parsers/Kusto/parseKQLQuery.h>\n \n namespace ProfileEvents\n {\n@@ -708,7 +709,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             ParserKQLStatement parser(end, settings.allow_settings_after_format_in_insert);\n \n             /// TODO: parser should fail early when max_query_size limit is reached.\n-            ast = parseQuery(parser, begin, end, \"\", max_query_size, settings.max_parser_depth);\n+            ast = parseKQLQuery(parser, begin, end, \"\", max_query_size, settings.max_parser_depth);\n         }\n         else if (settings.dialect == Dialect::prql && !internal)\n         {\ndiff --git a/src/Parsers/CMakeLists.txt b/src/Parsers/CMakeLists.txt\nindex d74137f8a914..3bc1b3a981f7 100644\n--- a/src/Parsers/CMakeLists.txt\n+++ b/src/Parsers/CMakeLists.txt\n@@ -5,6 +5,7 @@ add_headers_and_sources(clickhouse_parsers ./Access)\n add_headers_and_sources(clickhouse_parsers ./MySQL)\n add_headers_and_sources(clickhouse_parsers ./Kusto)\n add_headers_and_sources(clickhouse_parsers ./PRQL)\n+add_headers_and_sources(clickhouse_parsers ./Kusto/KustoFunctions)\n add_library(clickhouse_parsers ${clickhouse_parsers_headers} ${clickhouse_parsers_sources})\n target_link_libraries(clickhouse_parsers PUBLIC clickhouse_common_io clickhouse_common_access string_utils)\n if (TARGET ch_rust::prql)\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex f25e7f3c7e27..202ca11b9cad 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -43,7 +43,6 @@\n \n #include <Interpreters/StorageID.h>\n \n-\n namespace DB\n {\n \ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 3ebf5571eae5..584d7c8a0abb 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -27,6 +27,7 @@\n #include <Common/logger_useful.h>\n #include <Parsers/queryToString.h>\n #include <Parsers/CommonParsers.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n \n using namespace std::literals;\n \n@@ -662,6 +663,26 @@ class Layer\n             }\n             else\n             {\n+                /// enable using subscript operator for kql_array_sort\n+                if (cur_op.function_name == \"arrayElement\" && !operands.empty())\n+                {\n+                    auto* first_arg_as_node = operands.front()->as<ASTFunction>();\n+                    if (first_arg_as_node)\n+                    {\n+                        if (first_arg_as_node->name == \"kql_array_sort_asc\" || first_arg_as_node->name == \"kql_array_sort_desc\")\n+                        {\n+                            cur_op.function_name = \"tupleElement\";\n+                            cur_op.type = OperatorType::TupleElement;\n+                        }\n+                        else if (first_arg_as_node->name == \"arrayElement\" && !first_arg_as_node->arguments->children.empty())\n+                        {\n+                            auto *arg_inside = first_arg_as_node->arguments->children[0]->as<ASTFunction>();\n+                            if (arg_inside && (arg_inside->name == \"kql_array_sort_asc\" || arg_inside->name == \"kql_array_sort_desc\"))\n+                                first_arg_as_node->name = \"tupleElement\";\n+                        }\n+                    }\n+                }\n+\n                 function = makeASTFunction(cur_op);\n \n                 if (!popLastNOperands(function->children[0]->children, cur_op.arity))\n@@ -2163,6 +2184,56 @@ class ViewLayer : public Layer\n     bool if_permitted;\n };\n \n+/// Layer for table function 'kql'\n+class KustoLayer : public Layer\n+{\n+public:\n+\n+    KustoLayer() : Layer(/*allow_alias*/ true, /*allow_alias_without_as_keyword*/ true) {}\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & /*action*/) override\n+    {\n+        /// kql(table|project ...)\n+        /// 0. Parse the kql query\n+        /// 1. Parse closing token\n+        if (state == 0)\n+        {\n+            ASTPtr query;\n+            --pos;\n+            if (!ParserKQLTableFunction().parse(pos, query, expected))\n+                return false;\n+            --pos;\n+            pushResult(query);\n+\n+            if (!ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+                return false;\n+\n+            finished = true;\n+            state = 1;\n+            return true;\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+protected:\n+    bool getResultImpl(ASTPtr & node) override\n+    {\n+        node = makeASTFunction(\"view\", std::move(elements)); // reuse view function for kql\n+        return true;\n+    }\n+};\n \n std::unique_ptr<Layer> getFunctionLayer(ASTPtr identifier, bool is_table_function, bool allow_function_parameters_ = true)\n {\n@@ -2199,6 +2270,8 @@ std::unique_ptr<Layer> getFunctionLayer(ASTPtr identifier, bool is_table_functio\n             return std::make_unique<ViewLayer>(false);\n         else if (function_name_lowercase == \"viewifpermitted\")\n             return std::make_unique<ViewLayer>(true);\n+        else if (function_name_lowercase == \"kql\")\n+            return std::make_unique<KustoLayer>();\n     }\n \n     if (function_name == \"tuple\")\n@@ -2454,7 +2527,7 @@ Action ParserExpressionImpl::tryParseOperand(Layers & layers, IParser::Pos & pos\n \n     if (layers.front()->is_table_function)\n     {\n-        if (typeid_cast<ViewLayer *>(layers.back().get()))\n+        if (typeid_cast<ViewLayer *>(layers.back().get()) || typeid_cast<KustoLayer *>(layers.back().get()))\n         {\n             if (identifier_parser.parse(pos, tmp, expected)\n                 && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))\n@@ -2592,6 +2665,7 @@ Action ParserExpressionImpl::tryParseOperand(Layers & layers, IParser::Pos & pos\n     }\n     else if (pos->type == TokenType::OpeningRoundBracket)\n     {\n+\n         if (subquery_parser.parse(pos, tmp, expected))\n         {\n             layers.back()->pushOperand(std::move(tmp));\ndiff --git a/src/Parsers/Kusto/KQL_ReleaseNote.md b/src/Parsers/Kusto/KQL_ReleaseNote.md\nnew file mode 100644\nindex 000000000000..bea1a627129a\n--- /dev/null\n+++ b/src/Parsers/Kusto/KQL_ReleaseNote.md\n@@ -0,0 +1,996 @@\n+## KQL implemented features  \n+\n+# October 9, 2022  \n+\n+## operator  \n+- [distinct](https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/distinctoperator)  \n+   `Customers | distinct *`  \n+   `Customers | distinct Occupation`  \n+   `Customers | distinct Occupation, Education`  \n+   `Customers | where Age <30 | distinct Occupation, Education`  \n+   `Customers | where Age <30 | order by Age| distinct Occupation, Education`  \n+\n+## String functions  \n+- [reverse](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/reversefunction)  \n+   `print reverse(123)`  \n+   `print reverse(123.34)`  \n+   `print reverse('clickhouse')`  \n+   `print reverse(3h)`  \n+   `print reverse(datetime(2017-1-1 12:23:34))`  \n+\n+- [parse_command_line](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parse-command-line)  \n+   `print parse_command_line('echo \\\"hello world!\\\" print$?', \\\"Windows\\\")`  \n+  \n+- [parse_csv](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parsecsvfunction)  \n+  `print result=parse_csv('aa,b,cc')`  \n+  `print result_multi_record=parse_csv('record1,a,b,c\\nrecord2,x,y,z')`  \n+\n+- [parse_json](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parsejsonfunction)  \n+   `print parse_json( dynamic([1, 2, 3]))`  \n+   `print parse_json('{\"a\":123.5, \"b\":\"{\\\\\"c\\\\\":456}\"}')`  \n+\n+- [extract_json](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractjsonfunction)  \n+   `print extract_json( \"$.a\" , '{\"a\":123, \"b\":\"{\\\\\"c\\\\\":456}\"}' , typeof(int))`  \n+\n+- [parse_version](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parse-versionfunction)  \n+ `print parse_version('1')`  \n+ `print parse_version('1.2.3.40')`  \n+\n+## Bug fixed\n+- [correct array index in expression](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1474)  \n+   array index should start with 0  \n+- [Summarize should generate alias or use correct columns](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1303)\n+   - if bin is used , the column should be in select list if no alias include  \n+   - if no column included in aggregate functions,  ( like count() ), should has alias with fun name + '_',e.g  count_  \n+   - if column name included in aggregate functions, should have fun name + \"_\" + column name , like count(Age) -> count_Age  \n+   - if argument of an aggregate functions is an exprision, Columns1 ... Columnsn should be used as alias  \n+      ```\n+      Customers | summarize count() by bin(Age, 10)  \n+      \u250c\u2500Age\u2500\u252c\u2500count_\u2500\u2510\n+      \u2502  40 \u2502      2 \u2502\n+      \u2502  20 \u2502      6 \u2502\n+      \u2502  30 \u2502      4 \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      Customers | summarize count(Age) by bin(Age, 10)  \n+      \u250c\u2500Age\u2500\u252c\u2500count_Age\u2500\u2510\n+      \u2502  40 \u2502         2 \u2502\n+      \u2502  20 \u2502         6 \u2502\n+      \u2502  30 \u2502         4 \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      Customers | summarize count(Age+1) by bin(Age+1, 10)\n+      \u250c\u2500Columns1\u2500\u252c\u2500count_\u2500\u2510\n+      \u2502       40 \u2502      2 \u2502\n+      \u2502       20 \u2502      6 \u2502\n+      \u2502       30 \u2502      4 \u2502\n+      \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+      ```\n+- [extend doesn't replace existing columns](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1246)  \n+\n+- [throw exception if use quoted string as alias](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1470)  \n+\n+- [repeat() doesn't work with count argument as negative value](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1368)  \n+\n+- [substring() doesn't work right with negative offsets](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1336)  \n+- [endofmonth() doesn't return correct result](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1370)  \n+\n+- [split() outputs array instead of string](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1343)  \n+\n+- [split() returns empty string when arg goes out of bound](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1328)  \n+\n+- [split() doesn't work with negative index](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1325)  \n+\n+\n+# September 26, 2022\n+## Bug fixed :  \n+[\"select * from kql\" results in syntax error](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1119)  \n+[Parsing ipv4 with arrayStringConcat throws exception](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1259)  \n+[CH Client crashes on invalid function name](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1266)  \n+[extract() doesn't work right with 4th argument i.e typeof()](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1327)  \n+[parse_ipv6_mask return incorrect results](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1050)  \n+[timespan returns wrong output in seconds](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1275)  \n+[timespan doesn't work for nanoseconds and tick](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1298)  \n+[totimespan() doesn't work for nanoseconds and tick timespan unit](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1301)  \n+[data types should throw exception in certain cases](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1112)  \n+[decimal does not support scientific notation](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1197)  \n+[extend statement causes client core dumping](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1260)  \n+[extend crashes with array sorting](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1247)  \n+[Core dump happens when WHERE keyword doesn't follow field name](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1335)  \n+[Null values are missing in the result of `make_list_with_nulls'](https://github.ibm.com/ClickHouse/issue-repo/issues/1009)  \n+[trim functions use non-unique aliases](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1111)  \n+[format_ipv4_mask returns incorrect mask value](https://zenhub.ibm.com/workspaces/clickhouse-project-61250df53aaf060db4e08052/issues/clickhouse/issue-repo/1039)  \n+\n+# September 12, 2022\n+## Extend operator\n+https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extendoperator  \n+`T | extend T | extend duration = endTime - startTime`  \n+`T | project endTime, startTime | extend duration = endTime - startTime`\n+## Array functions\n+- [array_reverse](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/array-reverse-function)  \n+   `print array_reverse(dynamic([\"this\", \"is\", \"an\", \"example\"])) == dynamic([\"example\",\"an\",\"is\",\"this\"])`  \n+\n+- [array_rotate_left](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/array_rotate_leftfunction)  \n+   `print array_rotate_left(dynamic([1,2,3,4,5]), 2) == dynamic([3,4,5,1,2])`  \n+   `print array_rotate_left(dynamic([1,2,3,4,5]), -2) == dynamic([4,5,1,2,3])`  \n+\n+- [array_rotate_right](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/array_rotate_rightfunction)  \n+   `print array_rotate_right(dynamic([1,2,3,4,5]), -2) == dynamic([3,4,5,1,2])`  \n+   `print array_rotate_right(dynamic([1,2,3,4,5]), 2) == dynamic([4,5,1,2,3])`  \n+\n+- [array_shift_left](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/array_shift_leftfunction)  \n+   `print array_shift_left(dynamic([1,2,3,4,5]), 2) == dynamic([3,4,5,null,null])`  \n+   `print array_shift_left(dynamic([1,2,3,4,5]), -2) == dynamic([null,null,1,2,3])`  \n+   `print array_shift_left(dynamic([1,2,3,4,5]), 2, -1) == dynamic([3,4,5,-1,-1])`  \n+   `print array_shift_left(dynamic(['a', 'b', 'c']), 2) == dynamic(['c','',''])`  \n+\n+- [array_shift_right](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/array_shift_rightfunction)  \n+   `print array_shift_right(dynamic([1,2,3,4,5]), -2) == dynamic([3,4,5,null,null])`  \n+   `print array_shift_right(dynamic([1,2,3,4,5]), 2) == dynamic([null,null,1,2,3])`  \n+   `print array_shift_right(dynamic([1,2,3,4,5]), -2, -1) == dynamic([3,4,5,-1,-1])`  \n+   `print array_shift_right(dynamic(['a', 'b', 'c']), -2) == dynamic(['c','',''])`  \n+\n+- [pack_array](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/packarrayfunction)  \n+   `print x = 1, y = x * 2, z = y * 2, pack_array(x,y,z)`  \n+\n+   Please note that only arrays of elements of the same type may be created at this time. The underlying reasons are explained under the release note section of the `dynamic` data type.\n+\n+- [repeat](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/repeatfunction)  \n+   `print repeat(1, 0) == dynamic([])`   \n+   `print repeat(1, 3) == dynamic([1, 1, 1])`  \n+   `print repeat(\"asd\", 3) == dynamic(['asd', 'asd', 'asd'])`  \n+   `print repeat(timespan(1d), 3) == dynamic([86400, 86400, 86400])`  \n+   `print repeat(true, 3) == dynamic([true, true, true])`  \n+\n+- [zip](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/zipfunction)  \n+   `print zip(dynamic([1,3,5]), dynamic([2,4,6]))`  \n+\n+   Please note that only arrays of the same type are supported in our current implementation. The underlying reasons are explained under the release note section of the `dynamic` data type.\n+\n+## Data types\n+ - [dynamic](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/dynamic)  \n+   `print isnull(dynamic(null))`  \n+   `print dynamic(1) == 1`  \n+   `print dynamic(timespan(1d)) == 86400`  \n+   `print dynamic([1, 2, 3])`  \n+   `print dynamic([[1], [2], [3]])`  \n+   `print dynamic(['a', \"b\", 'c'])`  \n+\n+   According to the KQL specifications `dynamic` is a literal, which means that no function calls are permitted. Expressions producing literals such as `datetime` and `timespan` and their aliases (ie. `date` and `time`, respectively) along with nested `dynamic` literals are allowed.\n+\n+   Please note that our current implementation supports only scalars and arrays made up of elements of the same type. Support for mixed types and property bags is deferred for now, based on our understanding of the required effort and discussion with representatives of the QRadar team.\n+\n+## Mathematical functions  \n+ - [isnan](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/isnanfunction)  \n+   `print isnan(double(nan)) == true`  \n+   `print isnan(4.2) == false`  \n+   `print isnan(4) == false`  \n+   `print isnan(real(+inf)) == false`  \n+\n+## Set functions\n+Please note that functions returning arrays with set semantics may return them in any particular order, which may be subject to change in the future.\n+\n+ - [jaccard_index](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/jaccard-index-function)  \n+   `print jaccard_index(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3, 4, 4, 4])) == 0.75`  \n+   `print jaccard_index(dynamic([1, 2, 3]), dynamic([])) == 0`  \n+   `print jaccard_index(dynamic([]), dynamic([1, 2, 3, 4])) == 0`  \n+   `print isnan(jaccard_index(dynamic([]), dynamic([])))`  \n+   `print jaccard_index(dynamic([1, 2, 3]), dynamic([4, 5, 6, 7])) == 0`  \n+   `print jaccard_index(dynamic(['a', 's', 'd']), dynamic(['f', 'd', 's', 'a'])) == 0.75`  \n+   `print jaccard_index(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])) == 0.25`  \n+\n+ - [set_difference](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/setdifferencefunction)  \n+   `print set_difference(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])) == dynamic([])`  \n+   `print array_sort_asc(set_difference(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[1] == dynamic([4, 5, 6])`  \n+   `print set_difference(dynamic([4]), dynamic([1, 2, 3])) == dynamic([4])`  \n+   `print array_sort_asc(set_difference(dynamic([1, 2, 3, 4, 5]), dynamic([5]), dynamic([2, 4])))[1] == dynamic([1, 3])`  \n+   `print array_sort_asc(set_difference(dynamic([1, 2, 3]), dynamic([])))[1] == dynamic([1, 2, 3])`  \n+   `print array_sort_asc(set_difference(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])))[1] == dynamic(['d', 's'])`  \n+   `print array_sort_asc(set_difference(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])))[1] == dynamic(['Chewbacca', 'Han Solo'])`  \n+\n+ - [set_has_element](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/sethaselementfunction)  \n+   `print set_has_element(dynamic([\"this\", \"is\", \"an\", \"example\"]), \"example\") == true`  \n+   `print set_has_element(dynamic([\"this\", \"is\", \"an\", \"example\"]), \"test\") == false`  \n+   `print set_has_element(dynamic([1, 2, 3]), 2) == true`  \n+   `print set_has_element(dynamic([1, 2, 3, 4.2]), 4) == false`  \n+\n+ - [set_intersect](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/setintersectfunction)  \n+   `print array_sort_asc(set_intersect(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])))[1] == dynamic([1, 2, 3])`  \n+   `print array_sort_asc(set_intersect(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[1] == dynamic([1, 2, 3])`  \n+   `print set_intersect(dynamic([4]), dynamic([1, 2, 3])) == dynamic([])`  \n+   `print set_intersect(dynamic([1, 2, 3, 4, 5]), dynamic([1, 3, 5]), dynamic([2, 5])) == dynamic([5])`  \n+   `print set_intersect(dynamic([1, 2, 3]), dynamic([])) == dynamic([])`  \n+   `print set_intersect(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])) == dynamic(['a'])`  \n+   `print set_intersect(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])) == dynamic(['Darth Vader'])`  \n+\n+ - [set_union](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/setunionfunction)  \n+   `print array_sort_asc(set_union(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])))[1] == dynamic([1, 2, 3])`  \n+   `print array_sort_asc(set_union(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[1] == dynamic([1, 2, 3, 4, 5, 6])`  \n+   `print array_sort_asc(set_union(dynamic([4]), dynamic([1, 2, 3])))[1] == dynamic([1, 2, 3, 4])`  \n+   `print array_sort_asc(set_union(dynamic([1, 3, 4]), dynamic([5]), dynamic([2, 4])))[1] == dynamic([1, 2, 3, 4, 5])`  \n+   `print array_sort_asc(set_union(dynamic([1, 2, 3]), dynamic([])))[1] == dynamic([1, 2, 3])`  \n+   `print array_sort_asc(set_union(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])))[1] == dynamic(['a', 'd', 'f', 's'])`  \n+   `print array_sort_asc(set_union(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])))[1] == dynamic(['Chewbacca', 'Darth Sidious', 'Darth Vader', 'Han Solo'])`  \n+\n+# August 29, 2022\n+\n+## **mv-expand operator**\n+https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/mvexpandoperator\n+Note: **expand on array columns only**\n+- test cases \n+   ```\n+   CREATE TABLE T\n+   (    \n+      a UInt8,\n+      b Array(String),\n+      c Array(Int8),\n+      d Array(Int8)\n+   ) ENGINE = Memory;\n+\n+   INSERT INTO T VALUES (1, ['Salmon', 'Steak','Chicken'],[1,2,3,4],[5,6,7,8])\n+   \n+   T | mv-expand c  \n+   T | mv-expand c, d  \n+   T | mv-expand b | mv-expand c  \n+   T | mv-expand c to typeof(bool)  \n+   T | mv-expand with_itemindex=index b, c, d  \n+   T | mv-expand array_concat(c,d)   \n+   T | mv-expand x = c, y = d   \n+   T | mv-expand xy = array_concat(c, d)  \n+   T | mv-expand with_itemindex=index c,d to typeof(bool)  \n+   ```\n+\n+## **make-series operator**  \n+https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/make-seriesoperator\n+\n+- test case make-series on datetime column  \n+   ```\n+   CREATE TABLE T\n+   (    \n+      Supplier Nullable(String),\n+      Fruit String ,\n+      Price Float64,\n+      Purchase Date \n+   ) ENGINE = Memory;\n+\n+   INSERT INTO T VALUES  ('Aldi','Apple',4,'2016-09-10');\n+   INSERT INTO T VALUES  ('Costco','Apple',2,'2016-09-11');\n+   INSERT INTO T VALUES  ('Aldi','Apple',6,'2016-09-10');\n+   INSERT INTO T VALUES  ('Costco','Snargaluff',100,'2016-09-12');\n+   INSERT INTO T VALUES  ('Aldi','Apple',7,'2016-09-12');\n+   INSERT INTO T VALUES  ('Aldi','Snargaluff',400,'2016-09-11');\n+   INSERT INTO T VALUES  ('Costco','Snargaluff',104,'2016-09-12');\n+   INSERT INTO T VALUES  ('Aldi','Apple',5,'2016-09-12');\n+   INSERT INTO T VALUES  ('Aldi','Snargaluff',600,'2016-09-11');\n+   INSERT INTO T VALUES  ('Costco','Snargaluff',200,'2016-09-10');\n+   ```  \n+   Have from and to  \n+   ```\n+   T |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 1d by Supplier, Fruit\n+   ```\n+   Has from , without to  \n+   ```\n+   T |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  step 1d by Supplier, Fruit\n+   ```\n+   Without from , has to  \n+   ```\n+   T |  make-series PriceAvg = avg(Price) default=0 on Purchase  to datetime(2016-09-13) step 1d by Supplier, Fruit\n+   ```\n+   Without from , without to\n+   ```\n+   T |  make-series PriceAvg = avg(Price) default=0 on Purchase step 1d by Supplier, Fruit\n+   ```\n+   Without by clause\n+   ```\n+   T |  make-series PriceAvg = avg(Price) default=0 on Purchase step 1d\n+   ```\n+   Without aggregation alias\n+   ```\n+   T |  make-series avg(Price) default=0 on Purchase step 1d by Supplier, Fruit\n+   ```\n+   Has group expression alias\n+   ```\n+   T |  make-series avg(Price) default=0 on Purchase step 1d by Supplier_Name = Supplier, Fruit\n+   ```\n+   Use different step value\n+   ```\n+   T |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 3d by Supplier, Fruit\n+   ```\n+- test case make-series on numeric column  \n+   ```\n+   CREATE TABLE T2\n+   (    \n+      Supplier Nullable(String),\n+      Fruit String ,\n+      Price Int32,\n+      Purchase Int32  \n+   ) ENGINE = Memory;\n+\n+   INSERT INTO T2 VALUES  ('Aldi','Apple',4,10);\n+   INSERT INTO T2 VALUES  ('Costco','Apple',2,11);\n+   INSERT INTO T2 VALUES  ('Aldi','Apple',6,10);\n+   INSERT INTO T2 VALUES  ('Costco','Snargaluff',100,12);\n+   INSERT INTO T2 VALUES  ('Aldi','Apple',7,12);\n+   INSERT INTO T2 VALUES  ('Aldi','Snargaluff',400,11);\n+   INSERT INTO T2 VALUES  ('Costco','Snargaluff',104,12);\n+   INSERT INTO T2 VALUES  ('Aldi','Apple',5,12);\n+   INSERT INTO T2 VALUES  ('Aldi','Snargaluff',600,11);\n+   INSERT INTO T2 VALUES  ('Costco','Snargaluff',200,10);\n+   ```\n+   Have from and to  \n+   ```\n+   T2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 to  15 step  1.0  by Supplier, Fruit;\n+   ```\n+   Has from , without to  \n+   ```\n+   T2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 step  1.0  by Supplier, Fruit;\n+   ```\n+   Without from , has to  \n+   ```\n+   T2 | make-series PriceAvg=avg(Price) default=0 on Purchase to 18 step  4.0  by Supplier, Fruit;\n+   ```\n+   Without from , without to  \n+   ```\n+   T2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  2.0  by Supplier, Fruit;\n+   ```\n+   Without by clause\n+   ```\n+   T2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  2.0;\n+   ```\n+\n+## Aggregate Functions\n+- [bin](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binfunction)  \n+   `print bin(4.5, 1)`  \n+   `print bin(time(16d), 7d)`  \n+   `print bin(datetime(1970-05-11 13:45:07), 1d)`  \n+- [stdev](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/stdev-aggfunction)  \n+   `Customers | summarize t = stdev(Age) by FirstName`  \n+\n+- [stdevif](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/stdevif-aggfunction)  \n+   `Customers | summarize t = stdevif(Age, Age < 10) by FirstName`  \n+\n+- [binary_all_and](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-all-and-aggfunction)  \n+   `Customers | summarize t = binary_all_and(Age) by FirstName`  \n+\n+- [binary_all_or](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-all-or-aggfunction)  \n+   `Customers | summarize t = binary_all_or(Age) by FirstName`  \n+\n+- [binary_all_xor](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-all-xor-aggfunction)  \n+   `Customers | summarize t = binary_all_xor(Age) by FirstName`  \n+\n+- [percentiles](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/percentiles-aggfunction)  \n+   `Customers | summarize percentiles(Age, 30, 40, 50, 60, 70) by FirstName`  \n+\n+- [percentilesw](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/percentiles-aggfunction)  \n+   `DataTable | summarize t = percentilesw(Bucket, Frequency, 50, 75, 99.9)`  \n+\n+- [percentile](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/percentiles-aggfunction)  \n+   `Customers | summarize t = percentile(Age, 50) by FirstName`  \n+\n+- [percentilew](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/percentiles-aggfunction)  \n+   `DataTable | summarize t = percentilew(Bucket, Frequency, 50)`  \n+\n+## Dynamic functions\n+- [array_sort_asc](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arraysortascfunction)  \n+   **Only support the constant dynamic array.**  \n+   **Returns an array. So, each element of the input has to be of same datatype.**  \n+   `print t = array_sort_asc(dynamic([null, 'd', 'a', 'c', 'c']))`  \n+   `print t = array_sort_asc(dynamic([4, 1, 3, 2]))`  \n+   `print t = array_sort_asc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))`  \n+   `print t = array_sort_asc(dynamic(['q', 'p', 'r']), dynamic(['clickhouse','hello', 'world']))`  \n+   `print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , false)`  \n+   `print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2)`  \n+   `print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]) , false)`  \n+   `print t = array_sort_asc( dynamic([null, null, null]) , false)`  \n+   `print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), 1 > 2)`  \n+   `print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30, 50, 3]), 1 > 2)`  \n+\n+- [array_sort_desc](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arraysortdescfunction) **(only support the constant dynamic array)**  \n+   \n+   `print t = array_sort_desc(dynamic([null, 'd', 'a', 'c', 'c']))`  \n+   `print t = array_sort_desc(dynamic([4, 1, 3, 2]))`  \n+   `print t = array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))`  \n+   `print t = array_sort_desc(dynamic(['q', 'p', 'r']), dynamic(['clickhouse','hello', 'world']))`  \n+   `print t = array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , false)`  \n+   `print t = array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2)`  \n+   `print t = array_sort_desc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]) , false)`  \n+   `print t = array_sort_desc( dynamic([null, null, null]) , false)`  \n+   `print t = array_sort_desc(dynamic([2, 1, null, 3]), dynamic([20, 10, 40, 30]), 1 > 2)`  \n+   `print t = array_sort_desc(dynamic([2, 1, null,3, null]), dynamic([20, 10, 40, 30, 50, 3]), 1 > 2)`  \n+\n+- [array_concat](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arrayconcatfunction)  \n+   `print array_concat(dynamic([1, 2, 3]), dynamic([4, 5]), dynamic([6, 7, 8, 9])) == dynamic([1, 2, 3, 4, 5, 6, 7, 8, 9])`  \n+\n+- [array_iff / array_iif](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arrayifffunction)  \n+   `print array_iif(dynamic([true, false, true]), dynamic([1, 2, 3]), dynamic([4, 5, 6])) == dynamic([1, 5, 3])`  \n+   `print array_iif(dynamic([true, false, true]), dynamic([1, 2, 3, 4]), dynamic([4, 5, 6])) == dynamic([1, 5, 3])`  \n+   `print array_iif(dynamic([true, false, true, false]), dynamic([1, 2, 3, 4]), dynamic([4, 5, 6])) == dynamic([1, 5, 3, null])`  \n+   `print array_iif(dynamic([1, 0, -1, 44, 0]), dynamic([1, 2, 3, 4]), dynamic([4, 5, 6])) == dynamic([1, 5, 3, 4, null])`  \n+\n+- [array_slice](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arrayslicefunction)  \n+   `print array_slice(dynamic([1,2,3]), 1, 2) == dynamic([2, 3])`  \n+   `print array_slice(dynamic([1,2,3,4,5]), 2, -1) == dynamic([3, 4, 5])`  \n+   `print array_slice(dynamic([1,2,3,4,5]), -3, -2) == dynamic([3, 4])`  \n+\n+- [array_split](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arraysplitfunction)  \n+   `print array_split(dynamic([1,2,3,4,5]), 2) == dynamic([[1,2],[3,4,5]])`  \n+   `print array_split(dynamic([1,2,3,4,5]), dynamic([1,3])) == dynamic([[1],[2,3],[4,5]])`  \n+\n+## DateTimeFunctions\n+\n+- [ago](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/agofunction)  \n+   `print ago(2h)`  \n+\n+- [endofday](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/endofdayfunction)  \n+   `print endofday(datetime(2017-01-01 10:10:17), -1)`  \n+   `print endofday(datetime(2017-01-01 10:10:17), 1)`  \n+   `print endofday(datetime(2017-01-01 10:10:17))`  \n+\n+- [endofmonth](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/endofmonthfunction)  \n+   `print endofmonth(datetime(2017-01-01 10:10:17), -1)`  \n+   `print endofmonth(datetime(2017-01-01 10:10:17), 1)`  \n+   `print endofmonth(datetime(2017-01-01 10:10:17))`  \n+\n+- [endofweek](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/endofweekfunction)  \n+   `print endofweek(datetime(2017-01-01 10:10:17), 1)`  \n+   `print endofweek(datetime(2017-01-01 10:10:17), -1)`  \n+   `print endofweek(datetime(2017-01-01 10:10:17))`  \n+\n+- [endofyear](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/endofyearfunction)  \n+   `print endofyear(datetime(2017-01-01 10:10:17), -1)`  \n+   `print endofyear(datetime(2017-01-01 10:10:17), 1)`  \n+   `print endofyear(datetime(2017-01-01 10:10:17))`  \n+\n+- [make_datetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/make-datetimefunction)  \n+   `print make_datetime(2017,10,01)`  \n+   `print make_datetime(2017,10,01,12,10)`  \n+   `print make_datetime(2017,10,01,12,11,0.1234567)`  \n+\n+-  [datetime_diff](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/datetime-difffunction)  \n+   `print datetime_diff('year',datetime(2017-01-01),datetime(2000-12-31))`  \n+   `print datetime_diff('quarter',datetime(2017-07-01),datetime(2017-03-30))`  \n+   `print datetime_diff('minute',datetime(2017-10-30 23:05:01),datetime(2017-10-30 23:00:59))`  \n+\n+- [unixtime_microseconds_todatetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/unixtime-microseconds-todatetimefunction)  \n+   `print unixtime_microseconds_todatetime(1546300800000000)`  \n+\n+- [unixtime_milliseconds_todatetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/unixtime-milliseconds-todatetimefunction)  \n+   `print unixtime_milliseconds_todatetime(1546300800000)`  \n+\n+- [unixtime_nanoseconds_todatetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/unixtime-nanoseconds-todatetimefunction)  \n+   `print unixtime_nanoseconds_todatetime(1546300800000000000)`  \n+\n+- [datetime_part](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/datetime-partfunction)  \n+   `print datetime_part('day', datetime(2017-10-30 01:02:03.7654321))`  \n+\n+- [datetime_add](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/datetime-addfunction)  \n+   `print datetime_add('day',1,datetime(2017-10-30 01:02:03.7654321))`  \n+\n+- [format_timespan](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/format-timespanfunction)  \n+   `print format_timespan(time(1d), 'd-[hh:mm:ss]')`  \n+   `print format_timespan(time('12:30:55.123'), 'ddddd-[hh:mm:ss.ffff]')`  \n+\n+- [format_datetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/format-datetimefunction)  \n+   `print format_datetime(todatetime('2009-06-15T13:45:30.6175425'), 'yy-M-dd [H:mm:ss.fff]')`  \n+   `print format_datetime(datetime(2015-12-14 02:03:04.12345), 'y-M-d h:m:s tt')`  \n+\n+- [todatetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/todatetimefunction)  \n+   `print  todatetime('2014-05-25T08:20:03.123456Z')`  \n+   `print  todatetime('2014-05-25 20:03.123')`  \n+\n+- [totimespan] (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/totimespanfunction)\n+   ` print totimespan('0.01:34:23')`\n+   `print totimespan(1d)`\n+\n+# August 15, 2022\n+   **double quote support**  \n+   ``print res = strcat(\"double \",\"quote\")``  \n+## Aggregate functions\n+ - [bin_at](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binatfunction)  \n+   `print res = bin_at(6.5, 2.5, 7)`  \n+   `print res = bin_at(1h, 1d, 12h)`  \n+   `print res = bin_at(datetime(2017-05-15 10:20:00.0), 1d, datetime(1970-01-01 12:00:00.0))`  \n+   `print res = bin_at(datetime(2017-05-17 10:20:00.0), 7d, datetime(2017-06-04 00:00:00.0))`  \n+\n+ - [array_index_of](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arrayindexoffunction)  \n+    *Supports only basic lookup. Do not support start_index, length and occurrence*  \n+    `print output = array_index_of(dynamic(['John', 'Denver', 'Bob', 'Marley']), 'Marley')`  \n+    `print output = array_index_of(dynamic([1, 2, 3]), 2)`  \n+ - [array_sum](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/array-sum-function)  \n+    `print output = array_sum(dynamic([2, 5, 3]))`  \n+    `print output = array_sum(dynamic([2.5, 5.5, 3]))`  \n+ - [array_length](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/arraylengthfunction)  \n+    `print output = array_length(dynamic(['John', 'Denver', 'Bob', 'Marley']))`  \n+    `print output = array_length(dynamic([1, 2, 3]))`\n+\n+## Conversion\n+- [tobool / toboolean](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/toboolfunction)\n+   `print tobool(true) == true`\n+   `print toboolean(false) == false`\n+   `print tobool(0) == false`\n+   `print toboolean(19819823) == true`\n+   `print tobool(-2) == true`\n+   `print isnull(toboolean('a'))`\n+   `print tobool('true') == true`\n+   `print toboolean('false') == false`\n+\n+- [todouble / toreal](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/todoublefunction)\n+   `print todouble(4) == 4`\n+   `print toreal(4.2) == 4.2`\n+   `print isnull(todouble('a'))`\n+   `print toreal('-0.3') == -0.3`\n+\n+- [toint](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/tointfunction)\n+   `print isnull(toint('a'))`  \n+   `print toint(4) == 4`  \n+   `print toint('4') == 4`  \n+   `print isnull(toint(4.2))`  \n+\n+- [tostring](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/tostringfunction)\n+   `print tostring(123) == '123'`  \n+   `print tostring('asd') == 'asd'`  \n+\n+## Data Types\n+ - [dynamic](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/dynamic)  \n+    *Supports only 1D array*  \n+    `print output = dynamic(['a', 'b', 'c'])`  \n+    `print output = dynamic([1, 2, 3])`  \n+ \n+- [bool,boolean](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/bool)  \n+   `print bool(1)`  \n+   `print boolean(0)`  \n+\n+- [datetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/datetime)  \n+   `print datetime(2015-12-31 23:59:59.9)`  \n+   `print datetime('2015-12-31 23:59:59.9')`  \n+   `print datetime(\"2015-12-31:)`  \n+\n+- [guid](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/guid)  \n+   `print guid(74be27de-1e4e-49d9-b579-fe0b331d3642)`  \n+   `print guid('74be27de-1e4e-49d9-b579-fe0b331d3642')`  \n+   `print guid('74be27de1e4e49d9b579fe0b331d3642')`  \n+\n+- [int](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/int)  \n+   `print int(1)`  \n+\n+- [long](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/long)  \n+   `print long(16)`  \n+\n+- [real](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/real)  \n+   `print real(1)`  \n+\n+- [timespan ,time](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/scalar-data-types/timespan)  \n+   **Note** the timespan is used for calculating datatime, so the output is in seconds. e.g. time(1h) = 3600\n+   `print 1d`  \n+   `print 30m`  \n+   `print time('0.12:34:56.7')`  \n+   `print time(2h)`  \n+   `print timespan(2h)`  \n+\n+\n+## StringFunctions\n+ \n+- [base64_encode_fromguid](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/base64-encode-fromguid-function)  \n+`print Quine = base64_encode_fromguid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb')`  \n+- [base64_decode_toarray](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/base64_decode_toarrayfunction)  \n+`print base64_decode_toarray('S3VzdG8=')`  \n+- [base64_decode_toguid](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/base64-decode-toguid-function)  \n+`print base64_decode_toguid('YWUzMTMzZjItNmUyMi00OWFlLWIwNmEtMTZlNmE5YjIxMmVi')`  \n+- [replace_regex](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/replace-regex-function)  \n+`print replace_regex('Hello, World!', '.', '\\\\0\\\\0')`  \n+- [has_any_index](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-any-index-function)  \n+`print idx = has_any_index('this is an example', dynamic(['this', 'example']))`\n+- [translate](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/translatefunction)  \n+`print translate('krasp', 'otsku', 'spark')`  \n+- [trim](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/trimfunction)  \n+`print trim('--', '--https://bing.com--')`  \n+- [trim_end](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/trimendfunction)  \n+`print trim_end('.com', 'bing.com')`  \n+- [trim_start](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/trimstartfunction)  \n+`print trim_start('[^\\\\w]+', strcat('-  ','Te st1','// $'))`  \n+\n+## DateTimeFunctions\n+- [startofyear](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/startofyearfunction)  \n+   `print startofyear(datetime(2017-01-01 10:10:17), -1)`  \n+   `print startofyear(datetime(2017-01-01 10:10:17), 0)`  \n+   `print startofyear(datetime(2017-01-01 10:10:17), 1)`  \n+- [weekofyear](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/weekofyearfunction)  \n+   `print week_of_year(datetime(2020-12-31))`  \n+   `print week_of_year(datetime(2020-06-15))`  \n+   `print week_of_year(datetime(1970-01-01))`  \n+   `print  week_of_year(datetime(2000-01-01))`  \n+\n+- [startofweek](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/startofweekfunction)  \n+   `print startofweek(datetime(2017-01-01 10:10:17), -1)`  \n+   `print startofweek(datetime(2017-01-01 10:10:17), 0)`  \n+   `print startofweek(datetime(2017-01-01 10:10:17), 1)`  \n+\n+- [startofmonth](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/startofmonthfunction)  \n+   `print startofmonth(datetime(2017-01-01 10:10:17), -1)`  \n+   `print startofmonth(datetime(2017-01-01 10:10:17), 0)`  \n+   `print startofmonth(datetime(2017-01-01 10:10:17), 1)`  \n+\n+- [startofday](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/startofdayfunction)  \n+   `print startofday(datetime(2017-01-01 10:10:17), -1)`  \n+   `print startofday(datetime(2017-01-01 10:10:17), 0)`  \n+   `print startofday(datetime(2017-01-01 10:10:17), 1)`  \n+\n+- [monthofyear](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/monthofyearfunction)  \n+   `print monthofyear(datetime(\"2015-12-14\"))`  \n+\n+- [hourofday](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/hourofdayfunction)  \n+   `print hourofday(datetime(2015-12-14 18:54:00))`  \n+\n+- [getyear](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/getyearfunction)  \n+   `print getyear(datetime(2015-10-12))`  \n+\n+- [getmonth](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/getmonthfunction)  \n+   `print getmonth(datetime(2015-10-12))`  \n+\n+- [dayofyear](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/dayofyearfunction)  \n+   `print dayofyear(datetime(2015-12-14))`  \n+\n+- [dayofmonth](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/dayofmonthfunction)  \n+   `print (datetime(2015-12-14))`  \n+\n+- [unixtime_seconds_todatetime](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/unixtime-seconds-todatetimefunction)  \n+   `print unixtime_seconds_todatetime(1546300800)`  \n+\n+- [dayofweek](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/dayofweekfunction)  \n+   `print dayofweek(datetime(2015-12-20))`  \n+\n+- [now](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/nowfunction)  \n+   `print now()`  \n+   `print now(2d)`  \n+   `print now(-2h)`  \n+   `print now(5microseconds)`  \n+   `print now(5seconds)`  \n+   `print now(6minutes)`  \n+   `print now(-2d) `  \n+   `print now(time(1d))`  \n+\n+\n+## Binary functions\n+- [binary_and](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-andfunction)  \n+   `print binary_and(15, 3) == 3`  \n+   `print binary_and(1, 2) == 0`  \n+- [binary_not](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-notfunction)  \n+   `print binary_not(1) == -2`  \n+- [binary_or](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-orfunction)  \n+   `print binary_or(3, 8) == 11`  \n+   `print binary_or(1, 2) == 3`  \n+- [binary_shift_left](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-shift-leftfunction)  \n+   `print binary_shift_left(1, 1) == 2`  \n+   `print binary_shift_left(1, 64) == 1`  \n+- [binary_shift_right](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-shift-rightfunction)  \n+   `print binary_shift_right(1, 1) == 0`\n+   `print binary_shift_right(1, 64) == 1`\n+- [binary_xor](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/binary-xorfunction)  \n+   `print binary_xor(1, 3) == 2`  \n+- [bitset_count_ones](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/bitset-count-onesfunction)  \n+   `print bitset_count_ones(42) == 3`  \n+\n+## IP functions\n+- [format_ipv4](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/format-ipv4-function)  \n+   `print format_ipv4('192.168.1.255', 24) == '192.168.1.0'`  \n+   `print format_ipv4(3232236031, 24) == '192.168.1.0'`  \n+- [format_ipv4_mask](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/format-ipv4-mask-function)  \n+   `print format_ipv4_mask('192.168.1.255', 24) == '192.168.1.0/24'`  \n+   `print format_ipv4_mask(3232236031, 24) == '192.168.1.0/24'`  \n+- [ipv4_compare](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-comparefunction)  \n+   `print ipv4_compare('127.0.0.1', '127.0.0.1') == 0`  \n+   `print ipv4_compare('192.168.1.1', '192.168.1.255') < 0`  \n+   `print ipv4_compare('192.168.1.1/24', '192.168.1.255/24') == 0`  \n+   `print ipv4_compare('192.168.1.1', '192.168.1.255', 24) == 0`  \n+- [ipv4_is_match](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-is-matchfunction)  \n+   `print ipv4_is_match('127.0.0.1', '127.0.0.1') == true`  \n+   `print ipv4_is_match('192.168.1.1', '192.168.1.255') == false`  \n+   `print ipv4_is_match('192.168.1.1/24', '192.168.1.255/24') == true`  \n+   `print ipv4_is_match('192.168.1.1', '192.168.1.255', 24) == true`  \n+- [ipv6_compare](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv6-comparefunction)  \n+   `print ipv6_compare('::ffff:7f00:1', '127.0.0.1') == 0`  \n+   `print ipv6_compare('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995') < 0`  \n+   `print ipv6_compare('192.168.1.1/24', '192.168.1.255/24') == 0`  \n+   `print ipv6_compare('fe80::85d:e82c:9446:7994/127', 'fe80::85d:e82c:9446:7995/127') == 0`  \n+   `print ipv6_compare('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995', 127) == 0`  \n+- [ipv6_is_match](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv6-is-matchfunction)  \n+   `print ipv6_is_match('::ffff:7f00:1', '127.0.0.1') == true`  \n+   `print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995') == false`  \n+   `print ipv6_is_match('192.168.1.1/24', '192.168.1.255/24') == true`  \n+   `print ipv6_is_match('fe80::85d:e82c:9446:7994/127', 'fe80::85d:e82c:9446:7995/127') == true`  \n+   `print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995', 127) == true`  \n+- [parse_ipv4_mask](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parse-ipv4-maskfunction)  \n+   `print parse_ipv4_mask('127.0.0.1', 24) == 2130706432`  \n+   `print parse_ipv4_mask('192.1.168.2', 31) == 3221334018`  \n+   `print parse_ipv4_mask('192.1.168.3', 31) == 3221334018`  \n+   `print parse_ipv4_mask('127.2.3.4', 32) == 2130838276`  \n+- [parse_ipv6_mask](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parse-ipv6-maskfunction)  \n+   `print parse_ipv6_mask('127.0.0.1', 24) == '0000:0000:0000:0000:0000:ffff:7f00:0000'`  \n+   `print parse_ipv6_mask('fe80::85d:e82c:9446:7994', 120) == 'fe80:0000:0000:0000:085d:e82c:9446:7900'`  \n+\n+# August 1, 2022\n+\n+**The config setting to allow modify dialect setting**.\n+   - Set dialect setting in  server configuration XML at user level(` users.xml `). This sets the ` dialect ` at server startup and CH will do query parsing for all users with ` default ` profile according to dialect value.\n+\n+   For example:\n+   ` <profiles>\n+        <!-- Default settings. -->\n+        <default>\n+            <load_balancing>random</load_balancing>\n+            <dialect>kusto</dialect>\n+        </default> `\n+   \n+   - Query can be executed with HTTP client as below once dialect is set in users.xml\n+      ` echo \"KQL query\" | curl -sS \"http://localhost:8123/?\" --data-binary @- `\n+   \n+   - To execute the query using clickhouse-client , Update clickhouse-client.xml as below and connect clickhouse-client with --config-file option (` clickhouse-client --config-file=<config-file path> `) \n+\n+     ` <config>\n+         <dialect>kusto</dialect>\n+      </config>  `\n+\n+   OR \n+      pass dialect setting with '--'. For example : \n+      ` clickhouse-client --dialect='kusto' -q \"KQL query\" `\n+\n+- **strcmp** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/strcmpfunction)  \n+   `print strcmp('abc','ABC')`\n+\n+- **parse_url** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parseurlfunction)  \n+   `print Result = parse_url('scheme://username:password@www.google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')`\n+\n+- **parse_urlquery** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parseurlqueryfunction)  \n+   `print Result = parse_urlquery('k1=v1&k2=v2&k3=v3')`\n+\n+- **print operator** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/printoperator)  \n+   `print x=1, s=strcat('Hello', ', ', 'World!')`\n+\n+- **Aggregate Functions:**\n+ - [make_list()](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/makelist-aggfunction)  \n+   `Customers | summarize t = make_list(FirstName) by FirstName`\n+   `Customers | summarize t = make_list(FirstName, 10) by FirstName`\n+ - [make_list_if()](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/makelistif-aggfunction)  \n+   `Customers | summarize t = make_list_if(FirstName, Age > 10) by FirstName`\n+   `Customers | summarize t = make_list_if(FirstName, Age > 10, 10) by FirstName`\n+ - [make_list_with_nulls()](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/make-list-with-nulls-aggfunction)  \n+   `Customers | summarize t = make_list_with_nulls(Age) by FirstName`\n+ - [make_set()](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/makeset-aggfunction)  \n+   `Customers | summarize t = make_set(FirstName) by FirstName`\n+   `Customers | summarize t = make_set(FirstName, 10) by FirstName`\n+ - [make_set_if()](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/makesetif-aggfunction)  \n+   `Customers | summarize t = make_set_if(FirstName, Age > 10) by FirstName`\n+   `Customers | summarize t = make_set_if(FirstName, Age > 10, 10) by FirstName`\n+\n+## IP functions\n+\n+- **The following functions now support arbitrary expressions as their argument:**\n+   - [ipv4_is_private](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-is-privatefunction)\n+   - [ipv4_is_in_range](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-is-in-range-function)\n+   - [ipv4_netmask_suffix](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-netmask-suffix-function)\n+      \n+# July 17, 2022\n+\n+## Renamed dialect from sql_dialect to dialect\n+\n+`set dialect='clickhouse'`  \n+`set dialect='kusto'`  \n+\n+## IP functions\n+- [parse_ipv4](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parse-ipv4function)\n+   `\"Customers | project parse_ipv4('127.0.0.1')\"`\n+- [parse_ipv6](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/parse-ipv6function)\n+   `\"Customers | project parse_ipv6('127.0.0.1')\"`\n+\n+Please note that the functions listed below only take constant parameters for now. Further improvement is to be expected to support expressions.\n+\n+- [ipv4_is_private](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-is-privatefunction)\n+   `\"Customers | project ipv4_is_private('192.168.1.6/24')\"`\n+   `\"Customers | project ipv4_is_private('192.168.1.6')\"`\n+- [ipv4_is_in_range](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-is-in-range-function)\n+   `\"Customers | project ipv4_is_in_range('127.0.0.1', '127.0.0.1')\"`\n+   `\"Customers | project ipv4_is_in_range('192.168.1.6', '192.168.1.1/24')\"`\n+- [ipv4_netmask_suffix](https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/ipv4-netmask-suffix-function)\n+   `\"Customers | project ipv4_netmask_suffix('192.168.1.1/24')\"`\n+   `\"Customers | project ipv4_netmask_suffix('192.168.1.1')\"`\n+\n+## string functions\n+- **support subquery for `in` orerator** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/in-cs-operator)  \n+ (subquery need to be wrapped with bracket inside bracket)\n+\n+    `Customers | where Age in ((Customers|project Age|where Age < 30))`\n+ Note: case-insensitive not supported yet\n+- **has_all**  (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-all-operator)  \n+    `Customers|where Occupation has_any ('Skilled','abcd')`  \n+     note : subquery not supported yet\n+- **has _any**  (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-anyoperator)  \n+    `Customers|where Occupation has_all ('Skilled','abcd')`  \n+    note : subquery not supported yet\n+- **countof**  (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/countoffunction)  \n+   `Customers | project countof('The cat sat on the mat', 'at')`  \n+   `Customers | project countof('The cat sat on the mat', 'at', 'normal')`  \n+   `Customers | project countof('The cat sat on the mat', 'at', 'regex')`\n+- **extract**  ( https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractfunction)  \n+`Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 0, 'The price of PINEAPPLE ice cream is 20')`  \n+`Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 1, 'The price of PINEAPPLE ice cream is 20')`  \n+`Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 2, 'The price of PINEAPPLE ice cream is 20')`  \n+`Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 3, 'The price of PINEAPPLE ice cream is 20')`  \n+`Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 2, 'The price of PINEAPPLE ice cream is 20', typeof(real))` \n+\n+- **extract_all** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractallfunction)  \n+\n+    `Customers | project extract_all('(\\\\w)(\\\\w+)(\\\\w)','The price of PINEAPPLE ice cream is 20')`  \n+    note:  captureGroups not supported yet\n+\n+- **split** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/splitfunction)  \n+    `Customers | project split('aa_bb', '_')`  \n+    `Customers | project split('aaa_bbb_ccc', '_', 1)`  \n+    `Customers | project split('', '_')`  \n+    `Customers | project split('a__b', '_')`  \n+    `Customers | project split('aabbcc', 'bb')`  \n+\n+- **strcat_delim**  (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/strcat-delimfunction)  \n+    `Customers | project strcat_delim('-', '1', '2', 'A') , 1s)`  \n+    `Customers | project strcat_delim('-', '1', '2', strcat('A','b'))`  \n+    note: only support string now.\n+\n+- **indexof** (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/indexoffunction)  \n+    `Customers | project indexof('abcdefg','cde')`  \n+    `Customers | project indexof('abcdefg','cde',2)`  \n+    `Customers | project indexof('abcdefg','cde',6)`  \n+    note: length and occurrence not supported yet\n+\n+\n+\n+\n+# July 4, 2022\n+\n+## sql_dialect\n+\n+- default is `clickhouse`  \n+    `set sql_dialect='clickhouse'`\n+- only process kql  \n+    `set sql_dialect='kusto'`\n+\n+## KQL() function\n+\n+ - create table  \n+  `CREATE TABLE kql_table4 ENGINE = Memory AS select *, now() as new_column From kql(Customers | project LastName,Age);`  \n+   verify the content of `kql_table`  \n+    `select * from kql_table`\n+   \n+ - insert into table  \n+    create a tmp table:\n+    ```\n+    CREATE TABLE temp\n+    (    \n+        FirstName Nullable(String),\n+        LastName String, \n+        Age Nullable(UInt8)\n+    ) ENGINE = Memory;\n+    ```\n+    `INSERT INTO temp select * from kql(Customers|project FirstName,LastName,Age);`  \n+    verify the content of `temp`   \n+        `select * from temp`\n+\n+ - Select from kql()  \n+    `Select * from kql(Customers|project FirstName)`\n+\n+## KQL operators:\n+ - Tabular expression statements  \n+    `Customers`\n+ - Select Column  \n+    `Customers | project FirstName,LastName,Occupation`\n+ - Limit returned results  \n+    `Customers | project FirstName,LastName,Occupation | take 1 | take 3`\n+ - sort, order  \n+    `Customers | order by Age desc , FirstName asc`\n+ - Filter   \n+    `Customers | where Occupation == 'Skilled Manual'`\n+ - summarize  \n+    `Customers |summarize  max(Age) by Occupation`\n+\n+## KQL string operators and functions\n+ - contains  \n+    `Customers |where Education contains  'degree'`\n+ - !contains  \n+    `Customers |where Education !contains  'degree'`\n+ - contains_cs  \n+    `Customers |where Education contains  'Degree'`\n+ - !contains_cs  \n+    `Customers |where Education !contains  'Degree'`\n+ - endswith  \n+    `Customers | where FirstName endswith 'RE'`\n+ - !endswith  \n+     `Customers | where !FirstName endswith 'RE'`\n+ - endswith_cs  \n+ `Customers | where FirstName endswith_cs  're'`\n+ - !endswith_cs  \n+  `Customers | where FirstName !endswith_cs  're'`\n+ - ==  \n+    `Customers | where Occupation == 'Skilled Manual'`\n+ - !=  \n+    `Customers | where Occupation != 'Skilled Manual'`\n+ - has  \n+    `Customers | where Occupation has 'skilled'`\n+ - !has  \n+    `Customers | where Occupation !has 'skilled'`\n+ - has_cs  \n+    `Customers | where Occupation has 'Skilled'`\n+ - !has_cs  \n+    `Customers | where Occupation !has 'Skilled'`\n+ - hasprefix  \n+    `Customers | where Occupation hasprefix_cs 'Ab'`\n+ - !hasprefix  \n+    `Customers | where Occupation !hasprefix_cs 'Ab'`\n+ - hasprefix_cs  \n+    `Customers | where Occupation hasprefix_cs 'ab'`\n+ - !hasprefix_cs  \n+    `Customers | where Occupation! hasprefix_cs 'ab'`\n+ - hassuffix  \n+    `Customers | where Occupation hassuffix 'Ent'`\n+ - !hassuffix  \n+    `Customers | where Occupation !hassuffix 'Ent'`\n+ - hassuffix_cs  \n+    `Customers | where Occupation hassuffix 'ent'`\n+ - !hassuffix_cs  \n+    `Customers | where Occupation hassuffix 'ent'`\n+ - in  \n+    `Customers |where Education in ('Bachelors','High School')`\n+ - !in  \n+    `Customers |  where Education !in  ('Bachelors','High School')`\n+ - matches regex  \n+    `Customers | where FirstName matches regex 'P.*r'`\n+ - startswith  \n+    `Customers | where FirstName startswith 'pet'`\n+ - !startswith  \n+    `Customers | where FirstName !startswith 'pet'`\n+ - startswith_cs  \n+    `Customers | where FirstName startswith_cs 'pet'`\n+ - !startswith_cs  \n+     `Customers | where FirstName !startswith_cs 'pet'`\n+\n+ - base64_encode_tostring()  \n+ `Customers | project base64_encode_tostring('Kusto1') | take 1`\n+ - base64_decode_tostring()  \n+ `Customers | project base64_decode_tostring('S3VzdG8x') | take 1`\n+  - isempty()  \n+ `Customers | where  isempty(LastName)`\n+ - isnotempty()  \n+  `Customers | where  isnotempty(LastName)`\n+ - isnotnull()  \n+  `Customers | where  isnotnull(FirstName)`\n+ - isnull()  \n+ `Customers | where  isnull(FirstName)`\n+ - url_decode()  \n+ `Customers | project url_decode('https%3A%2F%2Fwww.test.com%2Fhello%20word') | take 1`\n+ - url_encode()  \n+    `Customers | project url_encode('https://www.test.com/hello word') | take 1`\n+ - substring()  \n+    `Customers | project name_abbr = strcat(substring(FirstName,0,3), ' ', substring(LastName,2))`\n+ - strcat()  \n+    `Customers | project name = strcat(FirstName, ' ', LastName)`\n+ - strlen()  \n+    `Customers | project FirstName, strlen(FirstName)`\n+ - strrep()  \n+    `Customers | project strrep(FirstName,2,'_')`\n+ - toupper()  \n+    `Customers | project toupper(FirstName)`\n+ - tolower()  \n+    `Customers | project tolower(FirstName)`\n+\n+ ## Aggregate Functions\n+ - arg_max()\n+ - arg_min()\n+ - avg()\n+ - avgif()\n+ - count()\n+ - countif()\n+ - max()\n+ - maxif()\n+ - min()\n+ - minif()\n+ - sum()\n+ - sumif()\n+ - dcount()\n+ - dcountif()\n+ - bin\n+ \n\\ No newline at end of file\ndiff --git a/src/Parsers/Kusto/KustoFunctions/IParserKQLFunction.cpp b/src/Parsers/Kusto/KustoFunctions/IParserKQLFunction.cpp\nnew file mode 100644\nindex 000000000000..44b08dd0b864\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/IParserKQLFunction.cpp\n@@ -0,0 +1,382 @@\n+#include \"KQLFunctionFactory.h\"\n+#include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/Utilities.h>\n+#include <Parsers/Kusto/ParserKQLDateTypeTimespan.h>\n+#include <boost/lexical_cast.hpp>\n+#include <magic_enum.hpp>\n+#include <pcg_random.hpp>\n+#include <Poco/String.h>\n+#include <format>\n+#include <numeric>\n+#include <stack>\n+\n+namespace DB::ErrorCodes\n+{\n+extern const int NOT_IMPLEMENTED;\n+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+extern const int SYNTAX_ERROR;\n+extern const int UNKNOWN_FUNCTION;\n+}\n+\n+namespace\n+{\n+constexpr DB::TokenType determineClosingPair(const DB::TokenType token_type)\n+{\n+    if (token_type == DB::TokenType::OpeningCurlyBrace)\n+        return DB::TokenType::ClosingCurlyBrace;\n+    else if (token_type == DB::TokenType::OpeningRoundBracket)\n+        return DB::TokenType::ClosingRoundBracket;\n+    else if (token_type == DB::TokenType::OpeningSquareBracket)\n+        return DB::TokenType::ClosingSquareBracket;\n+\n+    throw DB::Exception(DB::ErrorCodes::NOT_IMPLEMENTED, \"Unhandled token: {}\", magic_enum::enum_name(token_type));\n+}\n+\n+constexpr bool isClosingBracket(const DB::TokenType token_type)\n+{\n+    return token_type == DB::TokenType::ClosingCurlyBrace || token_type == DB::TokenType::ClosingRoundBracket\n+        || token_type == DB::TokenType::ClosingSquareBracket;\n+}\n+\n+constexpr bool isOpeningBracket(const DB::TokenType token_type)\n+{\n+    return token_type == DB::TokenType::OpeningCurlyBrace || token_type == DB::TokenType::OpeningRoundBracket\n+        || token_type == DB::TokenType::OpeningSquareBracket;\n+}\n+}\n+\n+namespace DB\n+{\n+bool IParserKQLFunction::convert(String & out, IParser::Pos & pos)\n+{\n+    return wrapConvertImpl(\n+        pos,\n+        IncreaseDepthTag{},\n+        [&]\n+        {\n+            bool res = convertImpl(out, pos);\n+            if (!res)\n+                out = \"\";\n+            return res;\n+        });\n+}\n+\n+bool IParserKQLFunction::directMapping(\n+    String & out, IParser::Pos & pos, const std::string_view ch_fn, const Interval & argument_count_interval)\n+{\n+    const auto fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    out.append(ch_fn.data(), ch_fn.length());\n+    out.push_back('(');\n+\n+    int argument_count = 0;\n+    const auto begin = pos;\n+    while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+    {\n+        if (pos != begin)\n+            out.append(\", \");\n+\n+        if (const auto argument = getOptionalArgument(fn_name, pos))\n+        {\n+            ++argument_count;\n+            out.append(*argument);\n+        }\n+\n+        if (pos->type == TokenType::ClosingRoundBracket)\n+        {\n+            if (!argument_count_interval.IsWithinBounds(argument_count))\n+                throw Exception(\n+                    ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                    \"{}: between {} and {} arguments are expected, but {} were provided\",\n+                    fn_name,\n+                    argument_count_interval.Min(),\n+                    argument_count_interval.Max(),\n+                    argument_count);\n+\n+            out.push_back(')');\n+            return true;\n+        }\n+    }\n+\n+    out.clear();\n+    pos = begin;\n+    return false;\n+}\n+\n+String IParserKQLFunction::generateUniqueIdentifier()\n+{\n+    // This particular random generator hits each number exactly once before looping over.\n+    // Because of this, it's sufficient for queries consisting of up to 2^16 (= 65536) distinct function calls.\n+    // Reference: https://www.pcg-random.org/using-pcg-cpp.html#insecure-generators\n+    static pcg32_once_insecure random_generator;\n+    return std::to_string(random_generator());\n+}\n+\n+String IParserKQLFunction::getArgument(const String & function_name, DB::IParser::Pos & pos, const ArgumentState argument_state)\n+{\n+    if (auto optional_argument = getOptionalArgument(function_name, pos, argument_state))\n+        return std::move(*optional_argument);\n+\n+    throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Required argument was not provided in {}\", function_name);\n+}\n+\n+std::vector<std::string> IParserKQLFunction::getArguments(\n+    const String & function_name, DB::IParser::Pos & pos, const ArgumentState argument_state, const Interval & argument_count_interval)\n+{\n+    std::vector<std::string> arguments;\n+    while (auto argument = getOptionalArgument(function_name, pos, argument_state))\n+    {\n+        arguments.push_back(std::move(*argument));\n+    }\n+    if (!argument_count_interval.IsWithinBounds(static_cast<int>(arguments.size())))\n+        throw Exception(\n+            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+            \"{}: between {} and {} arguments are expected, but {} were provided\",\n+            function_name,\n+            argument_count_interval.Min(),\n+            argument_count_interval.Max(),\n+            arguments.size());\n+\n+    return arguments;\n+}\n+\n+String IParserKQLFunction::getConvertedArgument(const String & fn_name, IParser::Pos & pos)\n+{\n+    int32_t round_bracket_count = 0, square_bracket_count = 0;\n+    if (pos->type == TokenType::ClosingRoundBracket || pos->type == TokenType::ClosingSquareBracket)\n+        return {};\n+\n+    if (pos->isEnd() || pos->type == TokenType::PipeMark || pos->type == TokenType::Semicolon)\n+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Need more argument(s) in function: {}\", fn_name);\n+\n+    std::vector<String> tokens;\n+    while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+    {\n+        if (pos->type == TokenType::OpeningRoundBracket)\n+            ++round_bracket_count;\n+        if (pos->type == TokenType::ClosingRoundBracket)\n+            --round_bracket_count;\n+\n+        if (pos->type == TokenType::OpeningSquareBracket)\n+            ++square_bracket_count;\n+        if (pos->type == TokenType::ClosingSquareBracket)\n+            --square_bracket_count;\n+\n+        if (!KQLOperators::convert(tokens, pos))\n+        {\n+            if (pos->type == TokenType::BareWord)\n+            {\n+                tokens.push_back(IParserKQLFunction::getExpression(pos));\n+            }\n+            else if (\n+                pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket\n+                || pos->type == TokenType::ClosingSquareBracket)\n+            {\n+                if (pos->type == TokenType::Comma)\n+                    break;\n+                if (pos->type == TokenType::ClosingRoundBracket && round_bracket_count == -1)\n+                    break;\n+                if (pos->type == TokenType::ClosingSquareBracket && square_bracket_count == 0)\n+                    break;\n+                tokens.push_back(String(pos->begin, pos->end));\n+            }\n+            else\n+            {\n+                String token;\n+                if (pos->type == TokenType::QuotedIdentifier)\n+                    token = \"'\" + escapeSingleQuotes(String(pos->begin + 1, pos->end - 1)) + \"'\";\n+                else if (pos->type == TokenType::OpeningSquareBracket)\n+                {\n+                    ++pos;\n+                    String array_index;\n+                    while (!pos->isEnd() && pos->type != TokenType::ClosingSquareBracket)\n+                    {\n+                        array_index += getExpression(pos);\n+                        ++pos;\n+                    }\n+                    token = std::format(\"[ {0} >=0 ? {0} + 1 : {0}]\", array_index);\n+                }\n+                else\n+                    token = String(pos->begin, pos->end);\n+\n+                tokens.push_back(token);\n+            }\n+        }\n+\n+        ++pos;\n+        if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket || pos->type == TokenType::ClosingSquareBracket)\n+        {\n+            if (pos->type == TokenType::Comma)\n+                break;\n+            if (pos->type == TokenType::ClosingRoundBracket && round_bracket_count == -1)\n+                break;\n+            if (pos->type == TokenType::ClosingSquareBracket && square_bracket_count == 0)\n+                break;\n+        }\n+    }\n+\n+    String converted_arg;\n+    for (const auto & token : tokens)\n+        converted_arg.append((converted_arg.empty() ? \"\" : \" \") + token);\n+\n+    return converted_arg;\n+}\n+\n+std::optional<String>\n+IParserKQLFunction::getOptionalArgument(const String & function_name, DB::IParser::Pos & pos, const ArgumentState argument_state)\n+{\n+    if (const auto type = pos->type; type != DB::TokenType::Comma && type != DB::TokenType::OpeningRoundBracket)\n+        return {};\n+\n+    ++pos;\n+    if (const auto type = pos->type; type == DB::TokenType::ClosingRoundBracket || type == DB::TokenType::ClosingSquareBracket)\n+        return {};\n+\n+    if (argument_state == ArgumentState::Parsed)\n+        return getConvertedArgument(function_name, pos);\n+\n+    if (argument_state != ArgumentState::Raw)\n+        throw Exception(\n+            ErrorCodes::NOT_IMPLEMENTED,\n+            \"Argument extraction is not implemented for {}::{}\",\n+            magic_enum::enum_type_name<ArgumentState>(),\n+            magic_enum::enum_name(argument_state));\n+\n+    const auto * begin = pos->begin;\n+    std::stack<DB::TokenType> scopes;\n+    while (!pos->isEnd() && (!scopes.empty() || (pos->type != DB::TokenType::Comma && pos->type != DB::TokenType::ClosingRoundBracket)))\n+    {\n+        const auto token_type = pos->type;\n+        if (isOpeningBracket(token_type))\n+            scopes.push(token_type);\n+        else if (isClosingBracket(token_type))\n+        {\n+            if (scopes.empty() || determineClosingPair(scopes.top()) != token_type)\n+                throw Exception(\n+                    DB::ErrorCodes::SYNTAX_ERROR, \"Unmatched token: {} when parsing {}\", magic_enum::enum_name(token_type), function_name);\n+\n+            scopes.pop();\n+        }\n+\n+        ++pos;\n+    }\n+\n+    return std::string(begin, pos->begin);\n+}\n+\n+String IParserKQLFunction::getKQLFunctionName(IParser::Pos & pos)\n+{\n+    String fn_name(pos->begin, pos->end);\n+    ++pos;\n+    if (pos->type != TokenType::OpeningRoundBracket)\n+    {\n+        --pos;\n+        return \"\";\n+    }\n+    return fn_name;\n+}\n+\n+String IParserKQLFunction::kqlCallToExpression(\n+    const std::string_view function_name, const std::initializer_list<const std::string_view> params, const uint32_t max_depth)\n+{\n+    return kqlCallToExpression(function_name, std::span(params), max_depth);\n+}\n+\n+String IParserKQLFunction::kqlCallToExpression(\n+    const std::string_view function_name, const std::span<const std::string_view> params, const uint32_t max_depth)\n+{\n+    const auto params_str = std::accumulate(\n+        std::cbegin(params),\n+        std::cend(params),\n+        String(),\n+        [](String acc, const std::string_view param)\n+        {\n+            if (!acc.empty())\n+                acc.append(\", \");\n+\n+            acc.append(param.data(), param.length());\n+            return acc;\n+        });\n+\n+    const auto kql_call = std::format(\"{}({})\", function_name, params_str);\n+    DB::Tokens call_tokens(kql_call.c_str(), kql_call.c_str() + kql_call.length());\n+    DB::IParser::Pos tokens_pos(call_tokens, max_depth);\n+    return DB::IParserKQLFunction::getExpression(tokens_pos);\n+}\n+\n+void IParserKQLFunction::validateEndOfFunction(const String & fn_name, IParser::Pos & pos)\n+{\n+    if (pos->type != TokenType::ClosingRoundBracket)\n+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Too many arguments in function: {}\", fn_name);\n+}\n+\n+String IParserKQLFunction::getExpression(IParser::Pos & pos)\n+{\n+    String arg(pos->begin, pos->end);\n+    auto parseConstTimespan = [&]()\n+    {\n+        ParserKQLDateTypeTimespan time_span;\n+        ASTPtr node;\n+        Expected expected;\n+\n+        if (time_span.parse(pos, node, expected))\n+            arg = boost::lexical_cast<std::string>(time_span.toSeconds());\n+    };\n+\n+    if (pos->type == TokenType::BareWord)\n+    {\n+        const auto fun = KQLFunctionFactory::get(arg);\n+        if (String new_arg; fun && fun->convert(new_arg, pos))\n+        {\n+            validateEndOfFunction(arg, pos);\n+            arg = std::move(new_arg);\n+        }\n+        else\n+        {\n+            if (!fun)\n+            {\n+                ++pos;\n+                if (pos->type == TokenType::OpeningRoundBracket)\n+                {\n+                    if (Poco::toLower(arg) != \"and\" && Poco::toLower(arg) != \"or\")\n+                        throw Exception(ErrorCodes::UNKNOWN_FUNCTION, \"{} is not a supported kusto function\", arg);\n+                }\n+                --pos;\n+            }\n+\n+            parseConstTimespan();\n+        }\n+    }\n+    else if (pos->type == TokenType::ErrorWrongNumber)\n+        parseConstTimespan();\n+    else if (pos->type == TokenType::QuotedIdentifier)\n+        arg = \"'\" + escapeSingleQuotes(String(pos->begin + 1, pos->end - 1)) + \"'\";\n+    else if (pos->type == TokenType::OpeningSquareBracket)\n+    {\n+        ++pos;\n+        String array_index;\n+        while (!pos->isEnd() && pos->type != TokenType::ClosingSquareBracket)\n+        {\n+            array_index += getExpression(pos);\n+            ++pos;\n+        }\n+        arg = std::format(\"[ {0} >=0 ? {0} + 1 : {0}]\", array_index);\n+    }\n+\n+    return arg;\n+}\n+\n+String IParserKQLFunction::escapeSingleQuotes(const String & input)\n+{\n+    String output;\n+    for (const auto & ch : input)\n+    {\n+        if (ch == '\\'')\n+            output += ch;\n+        output += ch;\n+    }\n+    return output;\n+}\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/IParserKQLFunction.h b/src/Parsers/Kusto/KustoFunctions/IParserKQLFunction.h\nnew file mode 100644\nindex 000000000000..147436551f97\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/IParserKQLFunction.h\n@@ -0,0 +1,91 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+\n+#include <span>\n+\n+namespace DB\n+{\n+class Interval\n+{\n+public:\n+    using Representation = int;\n+\n+    Interval(const Representation min_, const Representation max_) : max(max_), min(min_) { }\n+\n+    Representation Max() const { return max; }\n+    Representation Min() const { return min; }\n+    bool IsWithinBounds(const Representation value) const { return min <= value && value <= max; }\n+\n+    static constexpr auto max_bound = std::numeric_limits<Representation>::max();\n+    static constexpr auto min_bound = std::numeric_limits<Representation>::min();\n+\n+private:\n+    Representation max = max_bound;\n+    Representation min = min_bound;\n+};\n+\n+class IParserKQLFunction\n+{\n+public:\n+    enum class ArgumentState\n+    {\n+        Parsed,\n+        Raw\n+    };\n+\n+    template <typename F>\n+    ALWAYS_INLINE static bool wrapConvertImpl(IParser::Pos & pos, const F & func)\n+    {\n+        IParser::Pos begin = pos;\n+        bool res = func();\n+        if (!res)\n+            pos = begin;\n+        return res;\n+    }\n+\n+    struct IncreaseDepthTag\n+    {\n+    };\n+\n+    template <typename F>\n+    ALWAYS_INLINE static bool wrapConvertImpl(IParser::Pos & pos, IncreaseDepthTag, const F & func)\n+    {\n+        IParser::Pos begin = pos;\n+        pos.increaseDepth();\n+        bool res = func();\n+        pos.decreaseDepth();\n+        if (!res)\n+            pos = begin;\n+        return res;\n+    }\n+\n+    bool convert(String & out, IParser::Pos & pos);\n+    virtual const char * getName() const = 0;\n+    virtual ~IParserKQLFunction() = default;\n+\n+    static String generateUniqueIdentifier();\n+    static String getArgument(const String & function_name, DB::IParser::Pos & pos, ArgumentState argument_state = ArgumentState::Parsed);\n+    static std::vector<std::string> getArguments(\n+        const String & function_name,\n+        DB::IParser::Pos & pos,\n+        ArgumentState argument_state = ArgumentState::Parsed,\n+        const Interval & argument_count_interval = {0, Interval::max_bound});\n+    static String getConvertedArgument(const String & fn_name, IParser::Pos & pos);\n+    static String getExpression(IParser::Pos & pos);\n+    static String getKQLFunctionName(IParser::Pos & pos);\n+    static std::optional<String>\n+    getOptionalArgument(const String & function_name, DB::IParser::Pos & pos, ArgumentState argument_state = ArgumentState::Parsed);\n+    static String\n+    kqlCallToExpression(std::string_view function_name, std::initializer_list<const std::string_view> params, uint32_t max_depth);\n+    static String kqlCallToExpression(std::string_view function_name, std::span<const std::string_view> params, uint32_t max_depth);\n+    static String escapeSingleQuotes(const String & input);\n+\n+protected:\n+    virtual bool convertImpl(String & out, IParser::Pos & pos) = 0;\n+\n+    static bool directMapping(\n+        String & out, IParser::Pos & pos, std::string_view ch_fn, const Interval & argument_count_interval = {0, Interval::max_bound});\n+    static void validateEndOfFunction(const String & fn_name, IParser::Pos & pos);\n+};\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.cpp\nnew file mode 100644\nindex 000000000000..16436d38d32b\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.cpp\n@@ -0,0 +1,488 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+#include <Common/StringUtils/StringUtils.h>\n+\n+namespace DB\n+{\n+\n+bool ArgMax::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"argMax\");\n+}\n+\n+bool ArgMin::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"argMin\");\n+}\n+\n+bool Avg::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"avg\");\n+}\n+\n+bool AvgIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"avgIf\");\n+}\n+\n+bool BinaryAllAnd::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"groupBitAnd\");\n+}\n+\n+bool BinaryAllOr::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"groupBitOr\");\n+}\n+\n+bool BinaryAllXor::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"groupBitXor\");\n+}\n+\n+bool BuildSchema::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool Count::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"count\");\n+}\n+\n+bool CountIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"countIf\");\n+}\n+\n+bool DCount::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    String value = getConvertedArgument(fn_name, pos);\n+\n+    out = \"count(DISTINCT \" + value + \")\";\n+    return true;\n+}\n+\n+bool DCountIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    String value = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    String condition = getConvertedArgument(fn_name, pos);\n+    out = \"countIf (DISTINCT \" + value + \", \" + condition + \")\";\n+    return true;\n+}\n+\n+bool MakeBag::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool MakeBagIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool MakeList::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto expr = getConvertedArgument(fn_name, pos);\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        const auto max_size = getConvertedArgument(fn_name, pos);\n+        out = \"groupArrayIf(\" + max_size + \")(\" + expr + \" , \" + expr + \" IS NOT NULL)\";\n+    }\n+    else\n+        out = \"groupArrayIf(\" + expr + \" , \" + expr + \" IS NOT NULL)\";\n+    return true;\n+}\n+\n+bool MakeListIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto expr = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    const auto predicate = getConvertedArgument(fn_name, pos);\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        const auto max_size = getConvertedArgument(fn_name, pos);\n+        out = \"groupArrayIf(\" + max_size + \")(\" + expr + \" , \" + predicate + \" )\";\n+    }\n+    else\n+        out = \"groupArrayIf(\" + expr + \" , \" + predicate + \" )\";\n+    return true;\n+}\n+\n+bool MakeListWithNulls::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto column_name = getConvertedArgument(fn_name, pos);\n+    out = \"arrayConcat(groupArray(\" + column_name + \"), arrayMap(x -> null, range(0, toUInt32(count(*)-length(  groupArray(\" + column_name\n+        + \"))),1)))\";\n+    return true;\n+}\n+\n+bool MakeSet::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto expr = getConvertedArgument(fn_name, pos);\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        const auto max_size = getConvertedArgument(fn_name, pos);\n+        out = \"groupUniqArray(\" + max_size + \")(\" + expr + \")\";\n+    }\n+    else\n+        out = \"groupUniqArray(\" + expr + \")\";\n+    return true;\n+}\n+\n+bool MakeSetIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto expr = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    const auto predicate = getConvertedArgument(fn_name, pos);\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        const auto max_size = getConvertedArgument(fn_name, pos);\n+        out = \"groupUniqArrayIf(\" + max_size + \")(\" + expr + \" , \" + predicate + \" )\";\n+    }\n+    else\n+        out = \"groupUniqArrayIf(\" + expr + \" , \" + predicate + \" )\";\n+    return true;\n+}\n+\n+bool Max::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"max\");\n+}\n+\n+bool MaxIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"maxIf\");\n+}\n+\n+bool Min::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"min\");\n+}\n+\n+bool MinIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"minIf\");\n+}\n+\n+bool Percentile::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String column_name = getConvertedArgument(fn_name, pos);\n+    trim(column_name);\n+\n+    ++pos;\n+    String value = getConvertedArgument(fn_name, pos);\n+    trim(value);\n+\n+    out = \"quantile(\" + value + \"/100)(\" + column_name + \")\";\n+    return true;\n+}\n+\n+bool Percentilew::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String bucket_column = getConvertedArgument(fn_name, pos);\n+    trim(bucket_column);\n+\n+    ++pos;\n+    String frequency_column = getConvertedArgument(fn_name, pos);\n+    trim(frequency_column);\n+\n+    ++pos;\n+    String value = getConvertedArgument(fn_name, pos);\n+    trim(value);\n+\n+    out = \"quantileExactWeighted(\" + value + \"/100)(\" + bucket_column + \",\" + frequency_column + \")\";\n+    return true;\n+}\n+\n+bool Percentiles::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String column_name = getConvertedArgument(fn_name, pos);\n+    trim(column_name);\n+    String expr = \"quantiles(\";\n+    String value;\n+    while (pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        if (pos->type != TokenType::Comma)\n+        {\n+            value = String(pos->begin, pos->end);\n+            expr = expr + value + \"/100\";\n+            ++pos;\n+            if (pos->type != TokenType::ClosingRoundBracket)\n+                expr += \", \";\n+        }\n+        else\n+            ++pos;\n+    }\n+    out = expr + \")(\" + column_name + \")\";\n+    return true;\n+}\n+\n+bool PercentilesArray::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String column_name = getConvertedArgument(fn_name, pos);\n+    trim(column_name);\n+    String expr = \"quantiles(\";\n+    String value;\n+    while (pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        if (pos->type != TokenType::Comma && String(pos->begin, pos->end) != \"dynamic\" && pos->type != TokenType::OpeningRoundBracket\n+            && pos->type != TokenType::OpeningSquareBracket && pos->type != TokenType::ClosingSquareBracket)\n+        {\n+            value = String(pos->begin, pos->end);\n+            expr = expr + value + \"/100\";\n+\n+            if (pos->type != TokenType::Comma && pos->type != TokenType::OpeningRoundBracket && pos->type != TokenType::OpeningSquareBracket\n+                && pos->type != TokenType::ClosingSquareBracket)\n+                expr += \", \";\n+            ++pos;\n+        }\n+        else\n+        {\n+            ++pos;\n+        }\n+    }\n+    ++pos;\n+    if (pos->type != TokenType::ClosingRoundBracket)\n+        --pos;\n+\n+    expr.pop_back();\n+    expr.pop_back();\n+    expr = expr + \")(\" + column_name + \")\";\n+    out = expr;\n+    return true;\n+}\n+\n+bool Percentilesw::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String bucket_column = getConvertedArgument(fn_name, pos);\n+    trim(bucket_column);\n+\n+    ++pos;\n+    String frequency_column = getConvertedArgument(fn_name, pos);\n+    trim(frequency_column);\n+\n+    String expr = \"quantilesExactWeighted(\";\n+    String value;\n+\n+    while (pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        if (pos->type != TokenType::Comma)\n+        {\n+            value = String(pos->begin, pos->end);\n+            expr = expr + value + \"/100\";\n+            ++pos;\n+            if (pos->type != TokenType::ClosingRoundBracket)\n+                expr += \", \";\n+        }\n+        else\n+            ++pos;\n+    }\n+    expr = expr + \")(\" + bucket_column + \",\" + frequency_column + \")\";\n+    out = expr;\n+    return true;\n+}\n+\n+bool PercentileswArray::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String bucket_column = getConvertedArgument(fn_name, pos);\n+    trim(bucket_column);\n+\n+    ++pos;\n+    String frequency_column = getConvertedArgument(fn_name, pos);\n+    trim(frequency_column);\n+\n+    String expr = \"quantilesExactWeighted(\";\n+    String value;\n+    while (pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        if (pos->type != TokenType::Comma && String(pos->begin, pos->end) != \"dynamic\" && pos->type != TokenType::OpeningRoundBracket\n+            && pos->type != TokenType::OpeningSquareBracket && pos->type != TokenType::ClosingSquareBracket)\n+        {\n+            value = String(pos->begin, pos->end);\n+            expr = expr + value + \"/100\";\n+\n+            if (pos->type != TokenType::Comma && pos->type != TokenType::OpeningRoundBracket && pos->type != TokenType::OpeningSquareBracket\n+                && pos->type != TokenType::ClosingSquareBracket)\n+                expr += \", \";\n+            ++pos;\n+        }\n+        else\n+        {\n+            ++pos;\n+        }\n+    }\n+    ++pos;\n+    if (pos->type != TokenType::ClosingRoundBracket)\n+        --pos;\n+\n+    expr.pop_back();\n+    expr.pop_back();\n+    expr = expr + \")(\" + bucket_column + \",\" + frequency_column + \")\";\n+    out = expr;\n+    return true;\n+}\n+\n+bool Stdev::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto expr = getConvertedArgument(fn_name, pos);\n+    out = \"sqrt(varSamp(\" + expr + \"))\";\n+    return true;\n+}\n+\n+bool StdevIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const auto expr = getConvertedArgument(fn_name, pos);\n+    if (pos->type != TokenType::Comma)\n+        return false;\n+\n+    ++pos;\n+    const auto predicate = getConvertedArgument(fn_name, pos);\n+    out = \"sqrt(varSampIf(\" + expr + \", \" + predicate + \"))\";\n+    return true;\n+}\n+\n+bool Sum::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"sum\");\n+}\n+\n+bool SumIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"sumIf\");\n+}\n+\n+bool TakeAny::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool TakeAnyIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool Variance::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool VarianceIf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h\nnew file mode 100644\nindex 000000000000..5002590ae430\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h\n@@ -0,0 +1,267 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class ArgMax : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"arg_max()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArgMin : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"arg_min()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Avg : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"avg()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class AvgIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"avgif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryAllAnd : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_all_and()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryAllOr : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_all_or()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryAllXor : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_all_xor()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BuildSchema : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"buildschema()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Count : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"count()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class CountIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"countif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DCount : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"dcount()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DCountIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"dcountif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeBag : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_bag()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeBagIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_bag_if()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeList : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_list()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeListIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_list_if()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeListWithNulls : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_list_with_nulls()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeSet : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_set()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeSetIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_set_if()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Max : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"max()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MaxIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"maxif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Min : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"min()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MinIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"minif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Percentile : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"percentile()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Percentilew : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"percentilew()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Percentiles : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"percentiles()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class PercentilesArray : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"percentiles_array()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Percentilesw : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"percentilesw()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class PercentileswArray : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"percentilesw_array()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Stdev : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"stdev()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StdevIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"stdevif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Sum : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"sum()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SumIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"sumif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class TakeAny : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"take_any()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class TakeAnyIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"take_anyif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Variance : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"variance()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class VarianceIf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"varianceif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.cpp\nnew file mode 100644\nindex 000000000000..f8765b116d4e\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.cpp\n@@ -0,0 +1,99 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+\n+#include <format>\n+\n+namespace DB\n+{\n+\n+bool BinaryAnd::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos);\n+    const auto rhs = getArgument(function_name, pos);\n+    out = std::format(\"bitAnd(cast({0}, 'Int64'), cast({1}, 'Int64'))\", lhs, rhs);\n+    return true;\n+}\n+\n+bool BinaryNot::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto value = getArgument(function_name, pos);\n+    out = std::format(\"bitNot(cast({0}, 'Int64'))\", value);\n+    return true;\n+}\n+\n+bool BinaryOr::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos);\n+    const auto rhs = getArgument(function_name, pos);\n+    out = std::format(\"bitOr(cast({0}, 'Int64'), cast({1}, 'Int64'))\", lhs, rhs);\n+    return true;\n+}\n+\n+bool BinaryShiftLeft::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto value = getArgument(function_name, pos);\n+    const auto count = getArgument(function_name, pos);\n+    out = std::format(\"if({1} < 0, null, bitShiftLeft(cast({0}, 'Int64'), {1}))\", value, count);\n+    return true;\n+}\n+\n+bool BinaryShiftRight::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto value = getArgument(function_name, pos);\n+    const auto count = getArgument(function_name, pos);\n+    out = std::format(\"if({1} < 0, null, bitShiftRight(cast({0}, 'Int64'), {1}))\", value, count);\n+    return true;\n+}\n+\n+bool BinaryXor::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos);\n+    const auto rhs = getArgument(function_name, pos);\n+    out = std::format(\"bitXor(cast({0}, 'Int64'), cast({1}, 'Int64'))\", lhs, rhs);\n+    return true;\n+}\n+\n+bool BitsetCountOnes::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"bitCount\");\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h\nnew file mode 100644\nindex 000000000000..f24b73a0e789\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h\n@@ -0,0 +1,56 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class BinaryAnd : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_and()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryNot : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_not()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryOr : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_or()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryShiftLeft : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_shift_left()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryShiftRight : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_shift_right()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinaryXor : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"binary_xor()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BitsetCountOnes : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bitset_count_ones()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLCastingFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLCastingFunctions.cpp\nnew file mode 100644\nindex 000000000000..a6a7b2ee320d\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLCastingFunctions.cpp\n@@ -0,0 +1,170 @@\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h>\n+\n+#include <format>\n+#include <regex>\n+#include <Poco/String.h>\n+\n+\n+namespace DB\n+{\n+bool ToBool::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto param = getArgument(function_name, pos);\n+    out = std::format(\n+        \"multiIf(toString({0}) = 'true', true, \"\n+        \"toString({0}) = 'false', false, toInt64OrNull(toString({0})) != 0)\",\n+        param,\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool ToDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto param = getArgument(function_name, pos);\n+\n+    out = std::format(\"parseDateTime64BestEffortOrNull(toString({0}),9,'UTC')\", param);\n+    return true;\n+}\n+\n+bool ToDouble::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto param = getArgument(function_name, pos);\n+    out = std::format(\"toFloat64OrNull(toString({0}))\", param);\n+    return true;\n+}\n+\n+bool ToInt::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto param = getArgument(function_name, pos);\n+    out = std::format(\"toInt32OrNull(toString({0}))\", param);\n+    return true;\n+}\n+\n+bool ToLong::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto param = getArgument(function_name, pos);\n+    out = std::format(\"toInt64OrNull(toString({0}))\", param);\n+    return true;\n+}\n+\n+bool ToString::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto param = getArgument(function_name, pos);\n+    out = std::format(\"ifNull(toString({0}), '')\", param);\n+    return true;\n+}\n+bool ToTimeSpan::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+    ++pos;\n+    String arg;\n+    if (pos->type == TokenType::QuotedIdentifier)\n+        arg = String(pos->begin + 1, pos->end - 1);\n+    else if (pos->type == TokenType::StringLiteral)\n+        arg = String(pos->begin, pos->end);\n+    else\n+        arg = getConvertedArgument(function_name, pos);\n+\n+    if (pos->type == TokenType::StringLiteral || pos->type == TokenType::QuotedIdentifier)\n+    {\n+        ++pos;\n+        try\n+        {\n+            auto result = kqlCallToExpression(\"time\", {arg}, pos.max_depth);\n+            out = std::format(\"{}\", result);\n+        }\n+        catch (...)\n+        {\n+            out = \"NULL\";\n+        }\n+    }\n+    else\n+        out = std::format(\"{}\", arg);\n+\n+    return true;\n+}\n+\n+bool ToDecimal::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String res;\n+    int scale = 0;\n+    int precision;\n+\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+    {\n+        res = String(pos->begin + 1, pos->end - 1);\n+        ++pos;\n+        precision = 34;\n+    }\n+    else\n+    {\n+        res = getConvertedArgument(fn_name, pos);\n+        precision = 17;\n+    }\n+    static const std::regex expr{\"^[0-9]+e[+-]?[0-9]+\"};\n+    bool is_string = std::any_of(res.begin(), res.end(), ::isalpha) && !(std::regex_match(res, expr));\n+\n+    if (is_string)\n+        out = \"NULL\";\n+    else if (std::regex_match(res, expr))\n+    {\n+        auto exponential_pos = res.find('e');\n+        if (res[exponential_pos + 1] == '+' || res[exponential_pos + 1] == '-')\n+            scale = std::stoi(res.substr(exponential_pos + 2, res.length()));\n+        else\n+            scale = std::stoi(res.substr(exponential_pos + 1, res.length()));\n+\n+        out = std::format(\"toDecimal128({}::String,{})\", res, scale);\n+    }\n+    else\n+    {\n+        if (const auto dot_pos = res.find('.'); dot_pos != String::npos)\n+        {\n+            const auto tmp = res.substr(0, dot_pos - 1);\n+            const auto tmp_length = static_cast<int>(std::ssize(tmp));\n+            scale = std::max(precision - tmp_length, 0);\n+        }\n+        if (scale < 0)\n+            out = \"NULL\";\n+        else\n+            out = std::format(\"toDecimal128({}::String,{})\", res, scale);\n+    }\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h\nnew file mode 100644\nindex 000000000000..45ce2e44d568\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h\n@@ -0,0 +1,63 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+\n+namespace DB\n+{\n+class ToBool : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"tobool()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"todatetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToDouble : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"todouble()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToInt : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"toint()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToLong : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"tolong()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToString : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"tostring()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToTimeSpan : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"totimespan()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToDecimal : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"todecimal()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.cpp\nnew file mode 100644\nindex 000000000000..9ddc009307ad\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.cpp\n@@ -0,0 +1,261 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.h>\n+#include <Parsers/Kusto/ParserKQLDateTypeTimespan.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+#include \"Poco/String.h\"\n+#include <format>\n+#include <regex>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int SYNTAX_ERROR;\n+}\n+\n+bool DatatypeBool::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toBool\");\n+}\n+\n+bool DatatypeDatetime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    String datetime_str;\n+\n+    ++pos;\n+    if (pos->type == TokenType::QuotedIdentifier)\n+        datetime_str = std::format(\"'{}'\", String(pos->begin + 1, pos->end - 1));\n+    else if (pos->type == TokenType::StringLiteral)\n+        datetime_str = String(pos->begin, pos->end);\n+    else if (pos->type == TokenType::BareWord)\n+    {\n+        datetime_str = getConvertedArgument(fn_name, pos);\n+        if (Poco::toUpper(datetime_str) == \"NULL\")\n+            out = \"NULL\";\n+        else\n+            out = std::format(\n+                \"if(toTypeName({0}) = 'Int64' OR toTypeName({0}) = 'Int32'OR toTypeName({0}) = 'Float64' OR  toTypeName({0}) = 'UInt32' OR \"\n+                \" toTypeName({0}) = 'UInt64', toDateTime64({0},9,'UTC'), parseDateTime64BestEffortOrNull({0}::String,9,'UTC'))\",\n+                datetime_str);\n+        return true;\n+    }\n+    else\n+    {\n+        auto start = pos;\n+        while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+        {\n+            ++pos;\n+            if (pos->type == TokenType::ClosingRoundBracket)\n+                break;\n+        }\n+        --pos;\n+        datetime_str = std::format(\"'{}'\", String(start->begin, pos->end));\n+    }\n+    out = std::format(\"parseDateTime64BestEffortOrNull({},9,'UTC')\", datetime_str);\n+    ++pos;\n+    return true;\n+}\n+\n+bool DatatypeDynamic::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    static const std::unordered_set<std::string_view> ALLOWED_FUNCTIONS{\"date\", \"datetime\", \"dynamic\", \"time\", \"timespan\"};\n+\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    ++pos;\n+    if (pos->type == TokenType::OpeningCurlyBrace)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Property bags are not supported for now in {}\", function_name);\n+\n+    while (!pos->isEnd() && pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        if (const auto token_type = pos->type; token_type == TokenType::BareWord || token_type == TokenType::Number\n+            || token_type == TokenType::QuotedIdentifier || token_type == TokenType::StringLiteral)\n+        {\n+            if (const std::string_view token(pos->begin, pos->end); token_type == TokenType::BareWord && !ALLOWED_FUNCTIONS.contains(token))\n+            {\n+                ++pos;\n+                if (pos->type != TokenType::ClosingRoundBracket && pos->type != TokenType::ClosingSquareBracket\n+                    && pos->type != TokenType::Comma)\n+                    throw Exception(ErrorCodes::SYNTAX_ERROR, \"Expression {} is not supported inside {}\", token, function_name);\n+\n+                --pos;\n+            }\n+\n+            out.append(getConvertedArgument(function_name, pos));\n+        }\n+        else\n+        {\n+            out.append(pos->begin, pos->end);\n+            ++pos;\n+        }\n+    }\n+\n+    return true;\n+}\n+\n+bool DatatypeGuid::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    String guid_str;\n+\n+    ++pos;\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+        guid_str = String(pos->begin + 1, pos->end - 1);\n+    else\n+    {\n+        auto start = pos;\n+        while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+        {\n+            ++pos;\n+            if (pos->type == TokenType::ClosingRoundBracket)\n+                break;\n+        }\n+        --pos;\n+        guid_str = String(start->begin, pos->end);\n+    }\n+    out = std::format(\"toUUIDOrNull('{}')\", guid_str);\n+    ++pos;\n+    return true;\n+}\n+\n+bool DatatypeInt::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    String guid_str;\n+\n+    ++pos;\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"String is not parsed as int literal.\");\n+    else\n+    {\n+        auto arg = getConvertedArgument(fn_name, pos);\n+        out = std::format(\"toInt32({})\", arg);\n+    }\n+    return true;\n+}\n+\n+bool DatatypeLong::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toInt64\");\n+}\n+\n+bool DatatypeReal::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"String is not parsed as double literal.\");\n+    else\n+    {\n+        auto arg = getConvertedArgument(fn_name, pos);\n+        out = std::format(\"toFloat64({})\", arg);\n+    }\n+    return true;\n+}\n+\n+bool DatatypeString::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool DatatypeTimespan::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    ParserKQLDateTypeTimespan time_span;\n+    ASTPtr node;\n+    Expected expected;\n+    bool sign = false;\n+\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    if (pos->type == TokenType::Minus)\n+    {\n+        sign = true;\n+        ++pos;\n+    }\n+    if (time_span.parse(pos, node, expected))\n+    {\n+        if (sign)\n+            out = std::format(\"-{}::Float64\", time_span.toSeconds());\n+        else\n+            out = std::format(\"{}::Float64\", time_span.toSeconds());\n+        ++pos;\n+    }\n+    else\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Not a correct timespan expression: {}\", fn_name);\n+    return true;\n+}\n+\n+bool DatatypeDecimal::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String arg;\n+    int scale = 0;\n+    int precision = 34;\n+\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Failed to parse String as decimal Literal: {}\", fn_name);\n+\n+    --pos;\n+    arg = getArgument(fn_name, pos);\n+\n+    //NULL expr returns NULL not exception\n+    static const std::regex expr{\"^[0-9]+e[+-]?[0-9]+\"};\n+    bool is_string = std::any_of(arg.begin(), arg.end(), ::isalpha) && Poco::toUpper(arg) != \"NULL\" && !(std::regex_match(arg, expr));\n+    if (is_string)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Failed to parse String as decimal Literal: {}\", fn_name);\n+\n+    if (std::regex_match(arg, expr))\n+    {\n+        auto exponential_pos = arg.find('e');\n+        if (arg[exponential_pos + 1] == '+' || arg[exponential_pos + 1] == '-')\n+            scale = std::stoi(arg.substr(exponential_pos + 2, arg.length()));\n+        else\n+            scale = std::stoi(arg.substr(exponential_pos + 1, arg.length()));\n+\n+        out = std::format(\"toDecimal128({}::String,{})\", arg, scale);\n+        return true;\n+    }\n+\n+    if (const auto dot_pos = arg.find('.'); dot_pos != String::npos)\n+    {\n+        const auto length = static_cast<int>(std::ssize(arg.substr(0, dot_pos - 1)));\n+        scale = std::max(precision - length, 0);\n+    }\n+    if (is_string)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Failed to parse String as decimal Literal: {}\", fn_name);\n+\n+    if (scale < 0 || Poco::toUpper(arg) == \"NULL\")\n+        out = \"NULL\";\n+    else\n+        out = std::format(\"toDecimal128({}::String,{})\", arg, scale);\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.h\nnew file mode 100644\nindex 000000000000..e2463cc7d049\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.h\n@@ -0,0 +1,77 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class DatatypeBool : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bool(),boolean()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeDatetime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"datetime(),date()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeDynamic : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"dynamic()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeGuid : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"guid()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeInt : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"int()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeLong : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"long()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeReal : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"real(),double()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeString : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"string()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeTimespan : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"timespan(), time()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatatypeDecimal : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"decimal()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.cpp\nnew file mode 100644\nindex 000000000000..18ac5164df9e\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.cpp\n@@ -0,0 +1,789 @@\n+#include <format>\n+#include <regex>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+#include \"Poco/String.h\"\n+namespace DB::ErrorCodes\n+{\n+extern const int BAD_ARGUMENTS;\n+extern const int SYNTAX_ERROR;\n+}\n+namespace DB\n+{\n+\n+bool TimeSpan::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool Ago::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    if (pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        const auto offset = getConvertedArgument(fn_name, pos);\n+        out = std::format(\"now64(9,'UTC') - {}\", offset);\n+    }\n+    else\n+        out = \"now64(9,'UTC')\";\n+    return true;\n+}\n+\n+bool DatetimeAdd::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String period = getConvertedArgument(fn_name, pos);\n+    //remove quotes from period.\n+    trim(period);\n+    if (period.front() == '\\\"' || period.front() == '\\'')\n+    {\n+        //period.remove\n+        period.erase(0, 1); // erase the first quote\n+        period.erase(period.size() - 1); // erase the last quote\n+    }\n+    ++pos;\n+    const String offset = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    const String datetime = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"date_add({}, {}, {})\", period, offset, datetime);\n+\n+    return true;\n+};\n+\n+bool DatetimePart::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String part = Poco::toUpper(getConvertedArgument(fn_name, pos));\n+    trim(part);\n+    if (part.front() == '\\\"' || part.front() == '\\'')\n+    {\n+        //period.remove\n+        part.erase(0, 1); // erase the first quote\n+        part.erase(part.size() - 1); // erase the last quote\n+    }\n+    String date;\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        date = getConvertedArgument(fn_name, pos);\n+    }\n+    String format;\n+\n+    if (part == \"YEAR\")\n+        format = \"%G\";\n+    else if (part == \"QUARTER\")\n+        format = \"%Q\";\n+    else if (part == \"MONTH\")\n+        format = \"%m\";\n+    else if (part == \"WEEK_OF_YEAR\")\n+        format = \"%V\";\n+    else if (part == \"DAY\")\n+        format = \"%e\";\n+    else if (part == \"DAYOFYEAR\")\n+        format = \"%j\";\n+    else if (part == \"HOUR\")\n+        format = \"%H\";\n+    else if (part == \"MINUTE\")\n+        format = \"%i\";\n+    else if (part == \"SECOND\")\n+        format = \"%S\";\n+    else\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"Unexpected argument {} for {}\", part, fn_name);\n+\n+    out = std::format(\"formatDateTime({}, '{}')\", date, format);\n+    return true;\n+}\n+\n+bool DatetimeDiff::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    String arguments;\n+\n+    arguments = arguments + getConvertedArgument(fn_name, pos) + \",\";\n+    ++pos;\n+    arguments = arguments + getConvertedArgument(fn_name, pos) + \",\";\n+    ++pos;\n+    arguments = arguments + getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"DateDiff({}) * -1\", arguments);\n+    return true;\n+}\n+\n+bool DayOfMonth::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toDayOfMonth\");\n+}\n+\n+bool DayOfWeek::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"concat((toDayOfWeek({})%7)::String, '.00:00:00')\", datetime_str);\n+    return true;\n+}\n+\n+bool DayOfYear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toDayOfYear\");\n+}\n+\n+bool EndOfMonth::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+        if (offset.empty())\n+            throw Exception(ErrorCodes::SYNTAX_ERROR, \"Number of arguments do not match in function: {}\", fn_name);\n+    }\n+    out = std::format(\n+        \"toDateTime(toLastDayOfMonth(toDateTime({}, 9, 'UTC') + toIntervalMonth({})), 9, 'UTC') + toIntervalHour(23) + \"\n+        \"toIntervalMinute(59) + toIntervalSecond(60) - toIntervalMicrosecond(1)\",\n+        datetime_str,\n+        toString(offset));\n+\n+    return true;\n+}\n+\n+bool EndOfDay::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+    }\n+    out = std::format(\n+        \"toDateTime(toStartOfDay({}),9,'UTC') + (INTERVAL {} +1 DAY) - (INTERVAL 1 microsecond)\", datetime_str, toString(offset));\n+\n+    return true;\n+}\n+\n+bool EndOfWeek::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+    }\n+    out = std::format(\n+        \"toDateTime(toStartOfDay({}),9,'UTC') + (INTERVAL {} +1 WEEK) - (INTERVAL 1 microsecond)\", datetime_str, toString(offset));\n+\n+    return true;\n+}\n+\n+bool EndOfYear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+\n+    if (datetime_str.empty())\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"Number of arguments do not match in function: {}\", fn_name);\n+\n+    String offset = \"0\";\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+        if (offset.empty())\n+            throw Exception(ErrorCodes::SYNTAX_ERROR, \"Number of arguments do not match in function: {}\", fn_name);\n+        offset.erase(remove(offset.begin(), offset.end(), ' '), offset.end());\n+    }\n+\n+    out = std::format(\n+        \"(((((toDateTime(toString(toLastDayOfMonth(toDateTime({0}, 9, 'UTC') + toIntervalYear({1}) + toIntervalMonth(12 - \"\n+        \"toInt8(substring(toString(toDateTime({0}, 9, 'UTC')), 6, 2))))), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + \"\n+        \"toIntervalSecond(60)) - toIntervalMicrosecond(1)))\",\n+        datetime_str,\n+        toString(offset));\n+\n+    return true;\n+}\n+\n+bool FormatDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    String formatspecifier;\n+    ++pos;\n+    const auto datetime = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    auto format = getConvertedArgument(fn_name, pos);\n+    trim(format);\n+\n+    //remove quotes and end space from format argument.\n+    if (format.front() == '\\\"' || format.front() == '\\'')\n+    {\n+        format.erase(0, 1); // erase the first quote\n+        format.erase(format.size() - 1); // erase the last quote\n+    }\n+\n+    std::vector<String> res;\n+    getTokens(format, res);\n+    std::string::size_type i = 0;\n+    size_t decimal = 0;\n+    while (i < format.size())\n+    {\n+        char c = format[i];\n+        if (!isalpha(c))\n+        {\n+            //delimiter\n+            if (c == ' ' || c == '-' || c == '_' || c == '[' || c == ']' || c == '/' || c == ',' || c == '.' || c == ':')\n+                formatspecifier = formatspecifier + c;\n+            else\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Invalid format delimiter in function: {}\", fn_name);\n+            ++i;\n+        }\n+        else\n+        {\n+            //format specifier\n+            String arg = res.back();\n+\n+            if (arg == \"y\" || arg == \"yy\")\n+                formatspecifier = formatspecifier + \"%y\";\n+            else if (arg == \"yyyy\")\n+                formatspecifier = formatspecifier + \"%Y\";\n+            else if (arg == \"M\" || arg == \"MM\")\n+                formatspecifier = formatspecifier + \"%m\";\n+            else if (arg == \"s\" || arg == \"ss\")\n+                formatspecifier = formatspecifier + \"%S\";\n+            else if (arg == \"m\" || arg == \"mm\")\n+                formatspecifier = formatspecifier + \"%i\";\n+            else if (arg == \"h\" || arg == \"hh\")\n+                formatspecifier = formatspecifier + \"%h\";\n+            else if (arg == \"H\" || arg == \"HH\")\n+                formatspecifier = formatspecifier + \"%H\";\n+            else if (arg == \"d\")\n+                formatspecifier = formatspecifier + \"%e\";\n+            else if (arg == \"dd\")\n+                formatspecifier = formatspecifier + \"%d\";\n+            else if (arg == \"tt\")\n+                formatspecifier = formatspecifier + \"%p\";\n+            else if (arg.starts_with('f') || arg.starts_with('F'))\n+                decimal = arg.size();\n+            else\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Format specifier {} in function: {} is not supported\", arg, fn_name);\n+            res.pop_back();\n+            i = i + arg.size();\n+        }\n+    }\n+    if (decimal > 0 && formatspecifier.find('.') != String::npos)\n+    {\n+        out = std::format(\n+            \"concat(\"\n+            \"substring(toString(formatDateTime({0} , '{1}')),1, position(toString(formatDateTime({0},'{1}')),'.')) ,\"\n+            \"substring(substring(toString({0}), position(toString({0}),'.')+1),1,{2}),\"\n+            \"substring(toString(formatDateTime({0},'{1}')), position(toString(formatDateTime({0},'{1}')), '.')+1, length \"\n+            \"(toString(formatDateTime({0},'{1}'))))) \",\n+            datetime,\n+            formatspecifier,\n+            decimal);\n+    }\n+    else\n+        out = std::format(\"formatDateTime({0},'{1}')\", datetime, formatspecifier);\n+\n+    return true;\n+}\n+bool FormatTimeSpan::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    String formatspecifier;\n+    ++pos;\n+    const auto datetime = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    auto format = getConvertedArgument(fn_name, pos);\n+    size_t decimal = 0;\n+    trim(format);\n+    //remove quotes and end space from format argument.\n+    if (format.front() == '\\\"' || format.front() == '\\'')\n+    {\n+        format.erase(0, 1); // erase the first quote\n+        format.erase(format.size() - 1); // erase the last quote\n+    }\n+    std::vector<String> res;\n+    getTokens(format, res);\n+    size_t pad = 0;\n+    std::string::size_type i = 0;\n+\n+\n+    bool is_day_in_format = false;\n+    String day_val = std::to_string(std::stoi(datetime) / 86400);\n+    bool is_hour_zero = std::stoi(datetime) % 86400 > 3600 ? false : true;\n+\n+    while (i < format.size())\n+    {\n+        char c = format[i];\n+        if (!isalpha(c))\n+        {\n+            //delimiter\n+            if (c == ' ' || c == '-' || c == '_' || c == '[' || c == ']' || c == '/' || c == ',' || c == '.' || c == ':')\n+                formatspecifier = formatspecifier + c;\n+            else\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Invalid format delimiter in function: {}\", fn_name);\n+            ++i;\n+        }\n+        else\n+        {\n+            //format specifier\n+            String arg = res.back();\n+\n+            if (arg == \"s\" || arg == \"ss\")\n+                formatspecifier = formatspecifier + \"%S\";\n+            else if (arg == \"m\" || arg == \"mm\")\n+                formatspecifier = formatspecifier + \"%i\";\n+            else if (arg == \"h\" || arg == \"hh\")\n+            {\n+                if (is_hour_zero) //To handle the CH limit for 12hr format(01-12). If not handled, 1.00:00:00 returned as 1.12:00:00(in 12 hr format)\n+                    formatspecifier = formatspecifier + \"%h\";\n+                else\n+                    formatspecifier = formatspecifier + \"%H\";\n+            }\n+            else if (arg == \"H\" || arg == \"HH\")\n+                formatspecifier = formatspecifier + \"%H\";\n+            else if (arg.starts_with('d')) //&& arg.size() >2)\n+            {\n+                pad = std::max(arg.size(), day_val.length());\n+                is_day_in_format = true;\n+            }\n+            else if (arg.starts_with('f') || arg.starts_with('F'))\n+                decimal = arg.size();\n+            else\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Format specifier {} in function:{} is not supported\", arg, fn_name);\n+            res.pop_back();\n+            i = i + arg.size();\n+        }\n+    }\n+    auto last_delim = formatspecifier.substr(formatspecifier.length() - 1, formatspecifier.length());\n+\n+    if (!is_day_in_format)\n+    {\n+        if (decimal > 0)\n+        {\n+            if (format.substr(format.length() - decimal - 1, 1) == last_delim)\n+                out = std::format(\n+                    \"concat(substring(toString(formatDateTime(toDateTime64({0},9,'UTC') ,'{1}')),1, length(toString(formatDateTime(\"\n+                    \"toDateTime64({0},9,'UTC'),'{1}'))) - position(\"\n+                    \"reverse(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}'))),'{3}')+1),substring(SUBSTRING(toString(\"\n+                    \"toDateTime64({0},9,'UTC')),position(toString(toDateTime64({0},9,'UTC')),'.')+1),1,{2}))\",\n+                    datetime,\n+                    formatspecifier,\n+                    decimal,\n+                    last_delim);\n+            else\n+                out = std::format(\n+                    \"concat(substring(toString(formatDateTime(toDateTime64({0},9,'UTC') ,'{1}')),1, length(toString(formatDateTime(\"\n+                    \"toDateTime64({0},9,'UTC'),'{1}'))) - position(\"\n+                    \"reverse(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}'))),'{3}')),substring(SUBSTRING(toString(toDateTime64({\"\n+                    \"0},9,'UTC')),position(toString(toDateTime64({0},9,'UTC')),'.')+1),1,{2}))\",\n+                    datetime,\n+                    formatspecifier,\n+                    decimal,\n+                    last_delim);\n+        }\n+        else\n+            out = std::format(\"formatDateTime(toDateTime64({0},9,'UTC'),'{1}')\", datetime, formatspecifier);\n+    }\n+    else\n+    {\n+        if (decimal > 0)\n+        {\n+            if (format.substr(format.length() - decimal - 1, 1) == last_delim)\n+                out = std::format(\n+                    \"concat(leftPad('{5}', {3},'0'),substring(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}')),1,\"\n+                    \"length(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}'))) - position(\"\n+                    \"reverse(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}'))),'{4}') \"\n+                    \"+1),substring(SUBSTRING(toString(toDateTime64({0},9,'UTC')),position(toString(toDateTime64({0},9,'UTC')),'.')+1),1,{2}\"\n+                    \"))\",\n+                    datetime,\n+                    formatspecifier,\n+                    decimal,\n+                    pad,\n+                    last_delim,\n+                    day_val);\n+            else\n+                out = std::format(\n+                    \"concat(leftPad('{5}', {3}, '0'),substring(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}')),1,\"\n+                    \"length(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}'))) - position(\"\n+                    \"reverse(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}'))),'{4}')),substring(SUBSTRING(toString(toDateTime64({\"\n+                    \"0},9,'UTC')),position(toString(toDateTime64({0},9,'UTC')),'.')+1),1,{2}),substring(toString(formatDateTime(\"\n+                    \"toDateTime64({0},9,'UTC'),'{1}')),position(toString(formatDateTime(\"\n+                    \"toDateTime64({0},9,'UTC'),'{1}')),'{4}'),length(toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}')))))\",\n+                    datetime,\n+                    formatspecifier,\n+                    decimal,\n+                    pad,\n+                    last_delim,\n+                    day_val);\n+        }\n+        else if (decimal == 0)\n+            out = std::format(\n+                \"concat(leftPad('{3}',{2},'0'),toString(formatDateTime(toDateTime64({0},9,'UTC'),'{1}')))\",\n+                datetime,\n+                formatspecifier,\n+                pad,\n+                day_val);\n+    }\n+    return true;\n+}\n+\n+bool GetMonth::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toMonth\");\n+}\n+\n+bool GetYear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toYear\");\n+}\n+\n+bool HoursOfDay::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toHour\");\n+}\n+\n+bool MakeTimeSpan::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String datetime_str;\n+    String hour;\n+    String day;\n+    String minute;\n+    String second;\n+    int arg_count = 0;\n+    std::vector<String> args;\n+    while (!pos->isEnd() && pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        String arg = getConvertedArgument(fn_name, pos);\n+        args.insert(args.begin(), arg);\n+        if (pos->type == TokenType::Comma)\n+            ++pos;\n+        ++arg_count;\n+    }\n+\n+    if (arg_count < 2 || arg_count > 4)\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"argument count out of bound in function: {}\", fn_name);\n+\n+    if (arg_count == 2)\n+    {\n+        hour = args.back();\n+        args.pop_back();\n+        minute = args.back();\n+        args.pop_back();\n+        datetime_str = hour + \":\" + minute;\n+    }\n+    else if (arg_count == 3)\n+    {\n+        hour = args.back();\n+        args.pop_back();\n+        minute = args.back();\n+        args.pop_back();\n+        second = args.back();\n+        args.pop_back();\n+\n+        datetime_str = hour + \":\" + minute + \":\" + second;\n+    }\n+    else if (arg_count == 4)\n+    {\n+        day = args.back();\n+        args.pop_back();\n+        hour = args.back();\n+        args.pop_back();\n+        minute = args.back();\n+        args.pop_back();\n+        second = args.back();\n+        args.pop_back();\n+\n+        datetime_str = hour + \":\" + minute + \":\" + second;\n+        day = day + \".\";\n+    }\n+    else\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"argument count out of bound in function: {}\", fn_name);\n+\n+    //Add dummy yyyy-mm-dd to parse datetime in CH\n+    datetime_str = \"0000-00-00 \" + datetime_str;\n+\n+    out = std::format(\n+        \"CONCAT('{}',toString(SUBSTRING(toString(toTime(parseDateTime64BestEffortOrNull('{}', 9,'UTC'))),12)))\", day, datetime_str);\n+    return true;\n+}\n+\n+bool MakeDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String arguments;\n+    int arg_count = 0;\n+\n+    while (!pos->isEnd() && pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        String arg = getConvertedArgument(fn_name, pos);\n+        if (pos->type == TokenType::Comma)\n+            ++pos;\n+        arguments = arguments + arg + \",\";\n+        ++arg_count;\n+    }\n+\n+    if (arg_count < 1 || arg_count > 7)\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"argument count out of bound in function: {}\", fn_name);\n+\n+    if (arg_count < 7)\n+    {\n+        for (int i = arg_count; i < 7; ++i)\n+            arguments = arguments + \"0,\";\n+    }\n+\n+    arguments = arguments + \"7,'UTC'\";\n+    out = std::format(\"makeDateTime64({})\", arguments);\n+\n+    return true;\n+}\n+\n+bool Now::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    if (pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        const auto offset = getConvertedArgument(fn_name, pos);\n+        out = std::format(\"now64(9,'UTC') + {}\", offset);\n+    }\n+    else\n+        out = \"now64(9,'UTC')\";\n+    return true;\n+}\n+\n+bool StartOfDay::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+    }\n+    out = std::format(\"date_add(DAY,{}, parseDateTime64BestEffortOrNull(toString((toStartOfDay({}))), 9, 'UTC')) \", offset, datetime_str);\n+    return true;\n+}\n+\n+bool StartOfMonth::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+    }\n+    out = std::format(\n+        \"date_add(MONTH,{}, parseDateTime64BestEffortOrNull(toString((toStartOfMonth({}))), 9, 'UTC')) \", offset, datetime_str);\n+    return true;\n+}\n+\n+bool StartOfWeek::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+    }\n+    out = std::format(\n+        \"date_add(Week,{}, parseDateTime64BestEffortOrNull(toString((toStartOfWeek({}))), 9, 'UTC')) \", offset, datetime_str);\n+    return true;\n+}\n+\n+bool StartOfYear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String datetime_str = getConvertedArgument(fn_name, pos);\n+    String offset = \"0\";\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        offset = getConvertedArgument(fn_name, pos);\n+    }\n+    out = std::format(\n+        \"date_add(YEAR,{}, parseDateTime64BestEffortOrNull(toString((toStartOfYear({}, 'UTC'))), 9, 'UTC'))\", offset, datetime_str);\n+    return true;\n+}\n+\n+bool UnixTimeMicrosecondsToDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String value = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"fromUnixTimestamp64Micro({},'UTC')\", value);\n+    return true;\n+}\n+\n+bool UnixTimeMillisecondsToDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String value = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"fromUnixTimestamp64Milli({},'UTC')\", value);\n+    return true;\n+}\n+\n+bool UnixTimeNanosecondsToDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String value = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"fromUnixTimestamp64Nano({},'UTC')\", value);\n+    return true;\n+}\n+\n+bool UnixTimeSecondsToDateTime::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{} accepts only long, int and double type of arguments\", fn_name);\n+\n+    String expression = getConvertedArgument(fn_name, pos);\n+    out = std::format(\n+        \" if(toTypeName({0}) = 'Int64' OR toTypeName({0}) = 'Int32'OR toTypeName({0}) = 'Float64' OR  toTypeName({0}) = 'UInt32' OR  \"\n+        \"toTypeName({0}) = 'UInt64', toDateTime64({0}, 9, 'UTC'), toDateTime64(throwIf(true, '{1} only accepts Int, Long and double type \"\n+        \"of arguments'), 9, 'UTC'))\",\n+        expression,\n+        fn_name);\n+\n+    return true;\n+}\n+\n+bool WeekOfYear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const String time_str = getConvertedArgument(fn_name, pos);\n+    out = std::format(\"toWeek({},3,'UTC')\", time_str);\n+    return true;\n+}\n+\n+bool MonthOfYear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"toMonth\");\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h\nnew file mode 100644\nindex 000000000000..77ed110700b4\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h\n@@ -0,0 +1,250 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+\n+class TimeSpan : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"timespan()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+/*\n+class DateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"datetime()\"; }\n+    bool convertImpl(String &out,IParser::Pos &pos) override;\n+};*/\n+\n+\n+class Ago : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ago()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatetimeAdd : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"datetime_add()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatetimePart : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"datetime_part()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DatetimeDiff : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"datetime_diff()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DayOfMonth : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"dayofmonth()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DayOfWeek : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"dayofweek()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class DayOfYear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"dayofyear()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class EndOfDay : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"endofday()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class EndOfMonth : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"endofmonth()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class EndOfWeek : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"endofweek()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class EndOfYear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"endofyear()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class FormatDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"format_datetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class FormatTimeSpan : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"format_timespan()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class GetMonth : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"getmonth()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class GetYear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"getyear()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class HoursOfDay : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"hourofday()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeTimeSpan : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_timespan()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MakeDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"make_datetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Now : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"now()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StartOfDay : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"startofday()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StartOfMonth : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"startofmonth()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StartOfWeek : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"startofweek()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StartOfYear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"startofyear()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class UnixTimeMicrosecondsToDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"unixtime_microseconds_todatetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class UnixTimeMillisecondsToDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"unixtime_milliseconds_todatetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class UnixTimeNanosecondsToDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"unixtime_nanoseconds_todatetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class UnixTimeSecondsToDateTime : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"unixtime_seconds_todatetime()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class WeekOfYear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"week_of_year()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class MonthOfYear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"monthofyear()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+void inline getTokens(String format, std::vector<String> & res)\n+{\n+    String str = format;\n+    String token;\n+    auto pos = str.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzQWERTYUIOPASDFGHJKLZXCVBNM\");\n+    while (pos != String::npos)\n+    {\n+        if (pos != 0)\n+        {\n+            // Found a token\n+            token = str.substr(0, pos);\n+            res.insert(res.begin(), token);\n+        }\n+        str.erase(0, pos + 1); // Always remove pos+1 to get rid of delimiter\n+        pos = str.find_first_not_of(\"abcdefghijklmnopqrstuvwxyzQWERTYUIOPASDFGHJKLZXCVBNM\");\n+    }\n+    // Cover the last (or only) token\n+    if (str.length() > 0)\n+    {\n+        token = str;\n+        res.insert(res.begin(), token);\n+    }\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.cpp\nnew file mode 100644\nindex 000000000000..924ac9f64903\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.cpp\n@@ -0,0 +1,377 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+\n+#include <format>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int SYNTAX_ERROR;\n+}\n+\n+bool ArrayConcat::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"arrayConcat\");\n+}\n+\n+bool ArrayIif::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto conditions = getArgument(function_name, pos);\n+    const auto if_true = getArgument(function_name, pos);\n+    const auto if_false = getArgument(function_name, pos);\n+\n+    out = std::format(\n+        \"arrayMap(x -> multiIf(toTypeName(x.1) = 'String', null, toInt64(x.1) != 0, x.2, x.3), \"\n+        \"arrayZip({0}, arrayResize({1}, length({0}), null), arrayResize({2}, length({0}), null)))\",\n+        conditions,\n+        if_true,\n+        if_false);\n+\n+    return true;\n+}\n+\n+bool ArrayIndexOf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(fn_name, pos);\n+    const auto needle = getArgument(fn_name, pos);\n+    out = \"minus(indexOf(\" + array + \", \" + needle + \"), 1)\";\n+\n+    return true;\n+}\n+\n+bool ArrayLength::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"length\");\n+}\n+\n+bool ArrayReverse::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos);\n+    out = std::format(\"if(throwIf(not startsWith(toTypeName({0}), 'Array'), 'Only arrays are supported'), [], reverse({0}))\", array);\n+\n+    return true;\n+}\n+\n+bool ArrayRotateLeft::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos);\n+    const auto count = getArgument(function_name, pos);\n+    out = std::format(\n+        \"arrayMap(x -> {0}[moduloOrZero(x + length({0}) + moduloOrZero({1}, toInt64(length({0}))), length({0})) + 1], \"\n+        \"range(0, length({0})))\",\n+        array,\n+        count);\n+\n+    return true;\n+}\n+\n+bool ArrayRotateRight::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto count = getArgument(function_name, pos, ArgumentState::Raw);\n+    out = kqlCallToExpression(\"array_rotate_left\", {array, \"-1 * \" + count}, pos.max_depth);\n+\n+    return true;\n+}\n+\n+bool ArrayShiftLeft::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos);\n+    const auto count = getArgument(function_name, pos);\n+    const auto fill = getOptionalArgument(function_name, pos);\n+    out = std::format(\n+        \"arrayResize(if({1} > 0, arraySlice({0}, {1} + 1), arrayConcat(arrayWithConstant(abs({1}), fill_value_{3}), {0})), \"\n+        \"length({0}), if(isNull({2}) and (extract(toTypeName({0}), 'Array\\\\((.*)\\\\)') as element_type_{3}) = 'String', \"\n+        \"defaultValueOfTypeName(if(element_type_{3} = 'Nothing', 'Nullable(Nothing)', element_type_{3})), {2}) as fill_value_{3})\",\n+        array,\n+        count,\n+        fill ? *fill : \"null\",\n+        generateUniqueIdentifier());\n+\n+    return true;\n+}\n+\n+bool ArrayShiftRight::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto count = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto fill = getOptionalArgument(function_name, pos, ArgumentState::Raw);\n+\n+    const auto negated_count = \"-1 * \" + count;\n+    out = kqlCallToExpression(\n+        \"array_shift_left\",\n+        fill ? std::initializer_list<std::string_view>{array, negated_count, *fill}\n+             : std::initializer_list<std::string_view>{array, negated_count},\n+        pos.max_depth);\n+\n+    return true;\n+}\n+\n+bool ArraySlice::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos);\n+    const auto start = getArgument(function_name, pos);\n+    const auto end = getArgument(function_name, pos);\n+\n+    out = std::format(\n+        \"arraySlice({0}, plus(1, if({1} >= 0, {1}, arrayMax([-length({0}), {1}]) + length({0}))) as offset_{3}, \"\n+        \"                plus(1, if({2} >= 0, {2}, arrayMax([-length({0}), {2}]) + length({0}))) - offset_{3} + 1)\",\n+        array,\n+        start,\n+        end,\n+        generateUniqueIdentifier());\n+\n+    return true;\n+}\n+\n+bool ArraySortAsc::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"kql_array_sort_asc\");\n+}\n+\n+bool ArraySortDesc::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"kql_array_sort_desc\");\n+}\n+\n+bool ArraySplit::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto array = getArgument(function_name, pos);\n+    const auto indices = getArgument(function_name, pos);\n+\n+    out = std::format(\n+        \"if(empty(arrayMap(x -> if(x >= 0, x, arrayMax([0, x + length({0})::Int64])), flatten([{1}])) as indices_{2}), [{0}], \"\n+        \"arrayConcat([arraySlice({0}, 1, indices_{2}[1])], arrayMap(i -> arraySlice({0}, indices_{2}[i] + 1, \"\n+        \"if(i = length(indices_{2}), length({0})::Int64, indices_{2}[i + 1]::Int64) - indices_{2}[i]), \"\n+        \"range(1, length(indices_{2}) + 1))))\",\n+        array,\n+        indices,\n+        generateUniqueIdentifier());\n+\n+    return true;\n+}\n+\n+bool ArraySum::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"arraySum\");\n+}\n+\n+bool BagKeys::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool BagMerge::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool BagRemoveKeys::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool JaccardIndex::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto rhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    out = std::format(\n+        \"divide(length({0}), length({1}))\",\n+        kqlCallToExpression(\"set_intersect\", {lhs, rhs}, pos.max_depth),\n+        kqlCallToExpression(\"set_union\", {lhs, rhs}, pos.max_depth));\n+\n+    return true;\n+}\n+\n+bool Pack::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool PackAll::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool PackArray::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"array\", {1, Interval::max_bound});\n+}\n+\n+bool Repeat::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    String value = getArgument(function_name, pos);\n+    String count = getArgument(function_name, pos);\n+\n+    value.erase(remove(value.begin(), value.end(), ' '), value.end());\n+    count.erase(remove(count.begin(), count.end(), ' '), count.end());\n+\n+    if (count.empty())\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"number of arguments do not match in function: {}\", function_name);\n+    else\n+        out = \"if(\" + count + \" < 0, [NULL], \" + std::format(\"arrayWithConstant(abs({1}), {0}))\", value, count);\n+\n+    return true;\n+}\n+\n+bool SetDifference::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos);\n+    const auto rhs = std::invoke(\n+        [&function_name, &pos]\n+        {\n+            std::vector<String> arrays{getArgument(function_name, pos, ArgumentState::Raw)};\n+            while (auto next_array = getOptionalArgument(function_name, pos, ArgumentState::Raw))\n+                arrays.push_back(*next_array);\n+\n+            return kqlCallToExpression(\"set_union\", std::vector<std::string_view>(arrays.cbegin(), arrays.cend()), pos.max_depth);\n+        });\n+\n+    out = std::format(\"arrayFilter(x -> not has({1}, x), arrayDistinct({0}))\", lhs, rhs);\n+\n+    return true;\n+}\n+\n+bool SetHasElement::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"has\");\n+}\n+\n+bool SetIntersect::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"arrayIntersect\");\n+}\n+\n+bool SetUnion::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    if (!directMapping(out, pos, \"arrayConcat\"))\n+        return false;\n+\n+    out = std::format(\"arrayDistinct({0})\", out);\n+\n+    return true;\n+}\n+\n+bool TreePath::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool Zip::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto arguments = std::invoke(\n+        [&function_name, &pos]\n+        {\n+            std::vector<String> result;\n+            while (auto argument = getOptionalArgument(function_name, pos))\n+                result.push_back(std::move(*argument));\n+\n+            return result;\n+        });\n+\n+    if (const auto size = arguments.size(); size < 2 || size > 16)\n+        throw Exception(\n+            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Between 2 and 16 arguments are expected, but {} were provided\", size);\n+\n+    const auto unique_identifier = generateUniqueIdentifier();\n+    const auto resized_arguments = std::invoke(\n+        [&arguments, &unique_identifier]\n+        {\n+            String lengths;\n+            for (int i = 0; i < std::ssize(arguments); ++i)\n+            {\n+                lengths.append(i > 0 ? \", \" : \"\");\n+                lengths.append(std::format(\n+                    \"length(if(match(toTypeName({0}), 'Array\\\\(Nullable\\\\(.*\\\\)\\\\)'), {0}, \"\n+                    \"cast({0}, concat('Array(Nullable(', extract(toTypeName({0}), 'Array\\\\((.*)\\\\)'), '))'))) as arg{1}_{2})\",\n+                    arguments[i],\n+                    i,\n+                    unique_identifier));\n+            }\n+\n+            auto result = std::format(\"arrayResize(arg0_{1}, arrayMax([{0}]) as max_length_{1}, null)\", lengths, unique_identifier);\n+            for (int i = 1; i < std::ssize(arguments); ++i)\n+                result.append(std::format(\", arrayResize(arg{0}_{1}, max_length_{1}, null)\", i, unique_identifier));\n+\n+            return result;\n+        });\n+\n+    out = std::format(\"arrayMap(t -> [untuple(t)], arrayZip({0}))\", resized_arguments);\n+\n+    return true;\n+}\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h\nnew file mode 100644\nindex 000000000000..52c4c637d8a3\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h\n@@ -0,0 +1,203 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class ArrayConcat : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_concat()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayIif : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_iif()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayIndexOf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_index_of()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayLength : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_length()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayReverse : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_reverse()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayRotateLeft : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_rotate_left()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayRotateRight : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_rotate_right()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayShiftLeft : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_shift_left()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArrayShiftRight : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_shift_right()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArraySlice : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_slice()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArraySortAsc : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_sort_asc()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArraySortDesc : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_sort_desc()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArraySplit : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_split()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ArraySum : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"array_sum()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BagKeys : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bag_keys()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BagMerge : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bag_merge()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BagRemoveKeys : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bag_remove_keys()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class JaccardIndex : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"jaccard_index()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Pack : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"pack()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class PackAll : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"pack_all()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class PackArray : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"pack_array()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Repeat : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"repeat()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SetDifference : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"set_difference()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SetHasElement : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"set_has_element()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SetIntersect : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"set_intersect()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SetUnion : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"set_union()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class TreePath : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"treepath()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Zip : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"zip()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLFunctionFactory.cpp b/src/Parsers/Kusto/KustoFunctions/KQLFunctionFactory.cpp\nnew file mode 100644\nindex 000000000000..adac892b49d2\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLFunctionFactory.cpp\n@@ -0,0 +1,819 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDataTypeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+\n+namespace DB\n+{\n+std::unordered_map<String, KQLFunctionValue> KQLFunctionFactory::kql_functions\n+    = {{\"ago\", KQLFunctionValue::ago},\n+       {\"datetime_add\", KQLFunctionValue::datetime_add},\n+       {\"datetime_part\", KQLFunctionValue::datetime_part},\n+       {\"datetime_diff\", KQLFunctionValue::datetime_diff},\n+       {\"dayofmonth\", KQLFunctionValue::dayofmonth},\n+       {\"dayofweek\", KQLFunctionValue::dayofweek},\n+       {\"dayofyear\", KQLFunctionValue::dayofyear},\n+       {\"endofday\", KQLFunctionValue::endofday},\n+       {\"endofweek\", KQLFunctionValue::endofweek},\n+       {\"endofyear\", KQLFunctionValue::endofyear},\n+       {\"endofmonth\", KQLFunctionValue::endofmonth},\n+\n+       {\"format_datetime\", KQLFunctionValue::format_datetime},\n+       {\"format_timespan\", KQLFunctionValue::format_timespan},\n+       {\"getmonth\", KQLFunctionValue::getmonth},\n+       {\"getyear\", KQLFunctionValue::getyear},\n+       {\"hourofday\", KQLFunctionValue::hourofday},\n+       {\"make_timespan\", KQLFunctionValue::make_timespan},\n+       {\"make_datetime\", KQLFunctionValue::make_datetime},\n+       {\"now\", KQLFunctionValue::now},\n+       {\"startofday\", KQLFunctionValue::startofday},\n+       {\"startofmonth\", KQLFunctionValue::startofmonth},\n+       {\"startofweek\", KQLFunctionValue::startofweek},\n+       {\"startofyear\", KQLFunctionValue::startofyear},\n+       {\"todatetime\", KQLFunctionValue::todatetime},\n+       {\"totimespan\", KQLFunctionValue::totimespan},\n+       {\"unixtime_microseconds_todatetime\", KQLFunctionValue::unixtime_microseconds_todatetime},\n+       {\"unixtime_milliseconds_todatetime\", KQLFunctionValue::unixtime_milliseconds_todatetime},\n+       {\"unixtime_nanoseconds_todatetime\", KQLFunctionValue::unixtime_nanoseconds_todatetime},\n+       {\"unixtime_seconds_todatetime\", KQLFunctionValue::unixtime_seconds_todatetime},\n+       {\"week_of_year\", KQLFunctionValue::week_of_year},\n+       {\"monthofyear\", KQLFunctionValue::monthofyear},\n+       {\"base64_encode_tostring\", KQLFunctionValue::base64_encode_tostring},\n+       {\"base64_encode_fromguid\", KQLFunctionValue::base64_encode_fromguid},\n+       {\"base64_decode_tostring\", KQLFunctionValue::base64_decode_tostring},\n+       {\"base64_decode_toarray\", KQLFunctionValue::base64_decode_toarray},\n+       {\"base64_decode_toguid\", KQLFunctionValue::base64_decode_toguid},\n+       {\"countof\", KQLFunctionValue::countof},\n+       {\"extract\", KQLFunctionValue::extract},\n+       {\"extract_all\", KQLFunctionValue::extract_all},\n+       {\"extract_json\", KQLFunctionValue::extract_json},\n+       {\"extractjson\", KQLFunctionValue::extract_json},\n+       {\"has_any_index\", KQLFunctionValue::has_any_index},\n+       {\"indexof\", KQLFunctionValue::indexof},\n+       {\"isempty\", KQLFunctionValue::isempty},\n+       {\"isnan\", KQLFunctionValue::isnan},\n+       {\"isnotempty\", KQLFunctionValue::isnotempty},\n+       {\"notempty\", KQLFunctionValue::isnotempty},\n+       {\"isnotnull\", KQLFunctionValue::isnotnull},\n+       {\"notnull\", KQLFunctionValue::isnotnull},\n+       {\"isnull\", KQLFunctionValue::isnull},\n+       {\"parse_command_line\", KQLFunctionValue::parse_command_line},\n+       {\"parse_csv\", KQLFunctionValue::parse_csv},\n+       {\"parse_json\", KQLFunctionValue::parse_json},\n+       {\"parse_url\", KQLFunctionValue::parse_url},\n+       {\"parse_urlquery\", KQLFunctionValue::parse_urlquery},\n+       {\"parse_version\", KQLFunctionValue::parse_version},\n+       {\"replace_regex\", KQLFunctionValue::replace_regex},\n+       {\"reverse\", KQLFunctionValue::reverse},\n+       {\"split\", KQLFunctionValue::split},\n+       {\"strcat\", KQLFunctionValue::strcat},\n+       {\"strcat_delim\", KQLFunctionValue::strcat_delim},\n+       {\"strcmp\", KQLFunctionValue::strcmp},\n+       {\"strlen\", KQLFunctionValue::strlen},\n+       {\"strrep\", KQLFunctionValue::strrep},\n+       {\"substring\", KQLFunctionValue::substring},\n+       {\"tolower\", KQLFunctionValue::tolower},\n+       {\"toupper\", KQLFunctionValue::toupper},\n+       {\"translate\", KQLFunctionValue::translate},\n+       {\"trim\", KQLFunctionValue::trim},\n+       {\"trim_end\", KQLFunctionValue::trim_end},\n+       {\"trim_start\", KQLFunctionValue::trim_start},\n+       {\"url_decode\", KQLFunctionValue::url_decode},\n+       {\"url_encode\", KQLFunctionValue::url_encode},\n+\n+       {\"array_concat\", KQLFunctionValue::array_concat},\n+       {\"array_iff\", KQLFunctionValue::array_iif},\n+       {\"array_iif\", KQLFunctionValue::array_iif},\n+       {\"array_index_of\", KQLFunctionValue::array_index_of},\n+       {\"array_length\", KQLFunctionValue::array_length},\n+       {\"array_reverse\", KQLFunctionValue::array_reverse},\n+       {\"array_rotate_left\", KQLFunctionValue::array_rotate_left},\n+       {\"array_rotate_right\", KQLFunctionValue::array_rotate_right},\n+       {\"array_shift_left\", KQLFunctionValue::array_shift_left},\n+       {\"array_shift_right\", KQLFunctionValue::array_shift_right},\n+       {\"array_slice\", KQLFunctionValue::array_slice},\n+       {\"array_sort_asc\", KQLFunctionValue::array_sort_asc},\n+       {\"array_sort_desc\", KQLFunctionValue::array_sort_desc},\n+       {\"array_split\", KQLFunctionValue::array_split},\n+       {\"array_sum\", KQLFunctionValue::array_sum},\n+       {\"bag_keys\", KQLFunctionValue::bag_keys},\n+       {\"bag_merge\", KQLFunctionValue::bag_merge},\n+       {\"bag_remove_keys\", KQLFunctionValue::bag_remove_keys},\n+       {\"jaccard_index\", KQLFunctionValue::jaccard_index},\n+       {\"pack\", KQLFunctionValue::pack},\n+       {\"pack_all\", KQLFunctionValue::pack_all},\n+       {\"pack_array\", KQLFunctionValue::pack_array},\n+       {\"repeat\", KQLFunctionValue::repeat},\n+       {\"set_difference\", KQLFunctionValue::set_difference},\n+       {\"set_has_element\", KQLFunctionValue::set_has_element},\n+       {\"set_intersect\", KQLFunctionValue::set_intersect},\n+       {\"set_union\", KQLFunctionValue::set_union},\n+       {\"treepath\", KQLFunctionValue::treepath},\n+       {\"zip\", KQLFunctionValue::zip},\n+\n+       {\"tobool\", KQLFunctionValue::tobool},\n+       {\"toboolean\", KQLFunctionValue::tobool},\n+       {\"todouble\", KQLFunctionValue::todouble},\n+       {\"toint\", KQLFunctionValue::toint},\n+       {\"tolong\", KQLFunctionValue::tolong},\n+       {\"toreal\", KQLFunctionValue::todouble},\n+       {\"tostring\", KQLFunctionValue::tostring},\n+       {\"totimespan\", KQLFunctionValue::totimespan},\n+       {\"todecimal\", KQLFunctionValue::todecimal},\n+\n+       {\"arg_max\", KQLFunctionValue::arg_max},\n+       {\"arg_min\", KQLFunctionValue::arg_min},\n+       {\"avg\", KQLFunctionValue::avg},\n+       {\"avgif\", KQLFunctionValue::avgif},\n+       {\"binary_all_and\", KQLFunctionValue::binary_all_and},\n+       {\"binary_all_or\", KQLFunctionValue::binary_all_or},\n+       {\"binary_all_xor\", KQLFunctionValue::binary_all_xor},\n+       {\"buildschema\", KQLFunctionValue::buildschema},\n+       {\"count\", KQLFunctionValue::count},\n+       {\"countif\", KQLFunctionValue::countif},\n+       {\"dcount\", KQLFunctionValue::dcount},\n+       {\"dcountif\", KQLFunctionValue::dcountif},\n+       {\"make_bag\", KQLFunctionValue::make_bag},\n+       {\"make_bag_if\", KQLFunctionValue::make_bag_if},\n+       {\"make_list\", KQLFunctionValue::make_list},\n+       {\"make_list_if\", KQLFunctionValue::make_list_if},\n+       {\"make_list_with_nulls\", KQLFunctionValue::make_list_with_nulls},\n+       {\"make_set\", KQLFunctionValue::make_set},\n+       {\"make_set_if\", KQLFunctionValue::make_set_if},\n+       {\"max\", KQLFunctionValue::max},\n+       {\"maxif\", KQLFunctionValue::maxif},\n+       {\"min\", KQLFunctionValue::min},\n+       {\"minif\", KQLFunctionValue::minif},\n+       {\"percentile\", KQLFunctionValue::percentile},\n+       {\"percentilew\", KQLFunctionValue::percentilew},\n+       {\"percentiles\", KQLFunctionValue::percentiles},\n+       {\"percentiles_array\", KQLFunctionValue::percentiles_array},\n+       {\"percentilesw\", KQLFunctionValue::percentilesw},\n+       {\"percentilesw_array\", KQLFunctionValue::percentilesw_array},\n+       {\"stdev\", KQLFunctionValue::stdev},\n+       {\"stdevif\", KQLFunctionValue::stdevif},\n+       {\"sum\", KQLFunctionValue::sum},\n+       {\"sumif\", KQLFunctionValue::sumif},\n+       {\"take_any\", KQLFunctionValue::take_any},\n+       {\"take_anyif\", KQLFunctionValue::take_anyif},\n+       {\"variance\", KQLFunctionValue::variance},\n+       {\"varianceif\", KQLFunctionValue::varianceif},\n+\n+       {\"series_fir\", KQLFunctionValue::series_fir},\n+       {\"series_iir\", KQLFunctionValue::series_iir},\n+       {\"series_fit_line\", KQLFunctionValue::series_fit_line},\n+       {\"series_fit_line_dynamic\", KQLFunctionValue::series_fit_line_dynamic},\n+       {\"series_fit_2lines\", KQLFunctionValue::series_fit_2lines},\n+       {\"series_fit_2lines_dynamic\", KQLFunctionValue::series_fit_2lines_dynamic},\n+       {\"series_outliers\", KQLFunctionValue::series_outliers},\n+       {\"series_periods_detect\", KQLFunctionValue::series_periods_detect},\n+       {\"series_periods_validate\", KQLFunctionValue::series_periods_validate},\n+       {\"series_stats_dynamic\", KQLFunctionValue::series_stats_dynamic},\n+       {\"series_stats\", KQLFunctionValue::series_stats},\n+       {\"series_fill_backward\", KQLFunctionValue::series_fill_backward},\n+       {\"series_fill_const\", KQLFunctionValue::series_fill_const},\n+       {\"series_fill_forward\", KQLFunctionValue::series_fill_forward},\n+       {\"series_fill_linear\", KQLFunctionValue::series_fill_linear},\n+\n+       {\"ipv4_compare\", KQLFunctionValue::ipv4_compare},\n+       {\"ipv4_is_in_range\", KQLFunctionValue::ipv4_is_in_range},\n+       {\"ipv4_is_match\", KQLFunctionValue::ipv4_is_match},\n+       {\"ipv4_is_private\", KQLFunctionValue::ipv4_is_private},\n+       {\"ipv4_netmask_suffix\", KQLFunctionValue::ipv4_netmask_suffix},\n+       {\"parse_ipv4\", KQLFunctionValue::parse_ipv4},\n+       {\"parse_ipv4_mask\", KQLFunctionValue::parse_ipv4_mask},\n+       {\"ipv6_compare\", KQLFunctionValue::ipv6_compare},\n+       {\"ipv6_is_match\", KQLFunctionValue::ipv6_is_match},\n+       {\"parse_ipv6\", KQLFunctionValue::parse_ipv6},\n+       {\"parse_ipv6_mask\", KQLFunctionValue::parse_ipv6_mask},\n+       {\"format_ipv4\", KQLFunctionValue::format_ipv4},\n+       {\"format_ipv4_mask\", KQLFunctionValue::format_ipv4_mask},\n+\n+       {\"binary_and\", KQLFunctionValue::binary_and},\n+       {\"binary_not\", KQLFunctionValue::binary_not},\n+       {\"binary_or\", KQLFunctionValue::binary_or},\n+       {\"binary_shift_left\", KQLFunctionValue::binary_shift_left},\n+       {\"binary_shift_right\", KQLFunctionValue::binary_shift_right},\n+       {\"binary_xor\", KQLFunctionValue::binary_xor},\n+       {\"bitset_count_ones\", KQLFunctionValue::bitset_count_ones},\n+\n+       {\"bin\", KQLFunctionValue::bin},\n+       {\"bin_at\", KQLFunctionValue::bin_at},\n+\n+       {\"bool\", KQLFunctionValue::datatype_bool},\n+       {\"boolean\", KQLFunctionValue::datatype_bool},\n+       {\"datetime\", KQLFunctionValue::datatype_datetime},\n+       {\"date\", KQLFunctionValue::datatype_datetime},\n+       {\"dynamic\", KQLFunctionValue::datatype_dynamic},\n+       {\"guid\", KQLFunctionValue::datatype_guid},\n+       {\"int\", KQLFunctionValue::datatype_int},\n+       {\"long\", KQLFunctionValue::datatype_long},\n+       {\"real\", KQLFunctionValue::datatype_real},\n+       {\"double\", KQLFunctionValue::datatype_real},\n+       {\"string\", KQLFunctionValue::datatype_string},\n+       {\"timespan\", KQLFunctionValue::datatype_timespan},\n+       {\"time\", KQLFunctionValue::datatype_timespan},\n+       {\"decimal\", KQLFunctionValue::datatype_decimal},\n+       {\"round\", KQLFunctionValue::round}\n+       };\n+\n+\n+std::unique_ptr<IParserKQLFunction> KQLFunctionFactory::get(String & kql_function)\n+{\n+    if (kql_functions.find(kql_function) == kql_functions.end())\n+        return nullptr;\n+\n+    auto kql_function_id = kql_functions[kql_function];\n+    switch (kql_function_id)\n+    {\n+        case KQLFunctionValue::none:\n+            return nullptr;\n+\n+        case KQLFunctionValue::timespan:\n+            return std::make_unique<TimeSpan>();\n+\n+        case KQLFunctionValue::ago:\n+            return std::make_unique<Ago>();\n+\n+        case KQLFunctionValue::datetime_add:\n+            return std::make_unique<DatetimeAdd>();\n+\n+        case KQLFunctionValue::datetime_part:\n+            return std::make_unique<DatetimePart>();\n+\n+        case KQLFunctionValue::datetime_diff:\n+            return std::make_unique<DatetimeDiff>();\n+\n+        case KQLFunctionValue::dayofmonth:\n+            return std::make_unique<DayOfMonth>();\n+\n+        case KQLFunctionValue::dayofweek:\n+            return std::make_unique<DayOfWeek>();\n+\n+        case KQLFunctionValue::dayofyear:\n+            return std::make_unique<DayOfYear>();\n+\n+        case KQLFunctionValue::endofday:\n+            return std::make_unique<EndOfDay>();\n+\n+        case KQLFunctionValue::endofweek:\n+            return std::make_unique<EndOfWeek>();\n+\n+        case KQLFunctionValue::endofyear:\n+            return std::make_unique<EndOfYear>();\n+\n+        case KQLFunctionValue::endofmonth:\n+            return std::make_unique<EndOfMonth>();\n+\n+        case KQLFunctionValue::monthofyear:\n+            return std::make_unique<MonthOfYear>();\n+\n+        case KQLFunctionValue::format_datetime:\n+            return std::make_unique<FormatDateTime>();\n+\n+        case KQLFunctionValue::format_timespan:\n+            return std::make_unique<FormatTimeSpan>();\n+\n+        case KQLFunctionValue::getmonth:\n+            return std::make_unique<GetMonth>();\n+\n+        case KQLFunctionValue::getyear:\n+            return std::make_unique<GetYear>();\n+\n+        case KQLFunctionValue::hourofday:\n+            return std::make_unique<HoursOfDay>();\n+\n+        case KQLFunctionValue::make_timespan:\n+            return std::make_unique<MakeTimeSpan>();\n+\n+        case KQLFunctionValue::make_datetime:\n+            return std::make_unique<MakeDateTime>();\n+\n+        case KQLFunctionValue::now:\n+            return std::make_unique<Now>();\n+\n+        case KQLFunctionValue::startofday:\n+            return std::make_unique<StartOfDay>();\n+\n+        case KQLFunctionValue::startofmonth:\n+            return std::make_unique<StartOfMonth>();\n+\n+        case KQLFunctionValue::startofweek:\n+            return std::make_unique<StartOfWeek>();\n+\n+        case KQLFunctionValue::startofyear:\n+            return std::make_unique<StartOfYear>();\n+\n+        case KQLFunctionValue::unixtime_microseconds_todatetime:\n+            return std::make_unique<UnixTimeMicrosecondsToDateTime>();\n+\n+        case KQLFunctionValue::unixtime_milliseconds_todatetime:\n+            return std::make_unique<UnixTimeMillisecondsToDateTime>();\n+\n+        case KQLFunctionValue::unixtime_nanoseconds_todatetime:\n+            return std::make_unique<UnixTimeNanosecondsToDateTime>();\n+\n+        case KQLFunctionValue::unixtime_seconds_todatetime:\n+            return std::make_unique<UnixTimeSecondsToDateTime>();\n+\n+        case KQLFunctionValue::week_of_year:\n+            return std::make_unique<WeekOfYear>();\n+\n+        case KQLFunctionValue::base64_encode_tostring:\n+            return std::make_unique<Base64EncodeToString>();\n+\n+        case KQLFunctionValue::base64_encode_fromguid:\n+            return std::make_unique<Base64EncodeFromGuid>();\n+\n+        case KQLFunctionValue::base64_decode_tostring:\n+            return std::make_unique<Base64DecodeToString>();\n+\n+        case KQLFunctionValue::base64_decode_toarray:\n+            return std::make_unique<Base64DecodeToArray>();\n+\n+        case KQLFunctionValue::base64_decode_toguid:\n+            return std::make_unique<Base64DecodeToGuid>();\n+\n+        case KQLFunctionValue::countof:\n+            return std::make_unique<CountOf>();\n+\n+        case KQLFunctionValue::extract:\n+            return std::make_unique<Extract>();\n+\n+        case KQLFunctionValue::extract_all:\n+            return std::make_unique<ExtractAll>();\n+\n+        case KQLFunctionValue::extract_json:\n+            return std::make_unique<ExtractJson>();\n+\n+        case KQLFunctionValue::has_any_index:\n+            return std::make_unique<HasAnyIndex>();\n+\n+        case KQLFunctionValue::indexof:\n+            return std::make_unique<IndexOf>();\n+\n+        case KQLFunctionValue::isempty:\n+            return std::make_unique<IsEmpty>();\n+\n+        case KQLFunctionValue::isnan:\n+            return std::make_unique<IsNan>();\n+\n+        case KQLFunctionValue::isnotempty:\n+            return std::make_unique<IsNotEmpty>();\n+\n+        case KQLFunctionValue::isnotnull:\n+            return std::make_unique<IsNotNull>();\n+\n+        case KQLFunctionValue::isnull:\n+            return std::make_unique<IsNull>();\n+\n+        case KQLFunctionValue::parse_command_line:\n+            return std::make_unique<ParseCommandLine>();\n+\n+        case KQLFunctionValue::parse_csv:\n+            return std::make_unique<ParseCSV>();\n+\n+        case KQLFunctionValue::parse_json:\n+            return std::make_unique<ParseJson>();\n+\n+        case KQLFunctionValue::parse_url:\n+            return std::make_unique<ParseURL>();\n+\n+        case KQLFunctionValue::parse_urlquery:\n+            return std::make_unique<ParseURLQuery>();\n+\n+        case KQLFunctionValue::parse_version:\n+            return std::make_unique<ParseVersion>();\n+\n+        case KQLFunctionValue::replace_regex:\n+            return std::make_unique<ReplaceRegex>();\n+\n+        case KQLFunctionValue::reverse:\n+            return std::make_unique<Reverse>();\n+\n+        case KQLFunctionValue::split:\n+            return std::make_unique<Split>();\n+\n+        case KQLFunctionValue::strcat:\n+            return std::make_unique<StrCat>();\n+\n+        case KQLFunctionValue::strcat_delim:\n+            return std::make_unique<StrCatDelim>();\n+\n+        case KQLFunctionValue::strcmp:\n+            return std::make_unique<StrCmp>();\n+\n+        case KQLFunctionValue::strlen:\n+            return std::make_unique<StrLen>();\n+\n+        case KQLFunctionValue::strrep:\n+            return std::make_unique<StrRep>();\n+\n+        case KQLFunctionValue::substring:\n+            return std::make_unique<SubString>();\n+\n+        case KQLFunctionValue::tolower:\n+            return std::make_unique<ToLower>();\n+\n+        case KQLFunctionValue::toupper:\n+            return std::make_unique<ToUpper>();\n+\n+        case KQLFunctionValue::translate:\n+            return std::make_unique<Translate>();\n+\n+        case KQLFunctionValue::trim:\n+            return std::make_unique<Trim>();\n+\n+        case KQLFunctionValue::trim_end:\n+            return std::make_unique<TrimEnd>();\n+\n+        case KQLFunctionValue::trim_start:\n+            return std::make_unique<TrimStart>();\n+\n+        case KQLFunctionValue::url_decode:\n+            return std::make_unique<URLDecode>();\n+\n+        case KQLFunctionValue::url_encode:\n+            return std::make_unique<URLEncode>();\n+\n+        case KQLFunctionValue::array_concat:\n+            return std::make_unique<ArrayConcat>();\n+\n+        case KQLFunctionValue::array_iif:\n+            return std::make_unique<ArrayIif>();\n+\n+        case KQLFunctionValue::array_index_of:\n+            return std::make_unique<ArrayIndexOf>();\n+\n+        case KQLFunctionValue::array_length:\n+            return std::make_unique<ArrayLength>();\n+\n+        case KQLFunctionValue::array_reverse:\n+            return std::make_unique<ArrayReverse>();\n+\n+        case KQLFunctionValue::array_rotate_left:\n+            return std::make_unique<ArrayRotateLeft>();\n+\n+        case KQLFunctionValue::array_rotate_right:\n+            return std::make_unique<ArrayRotateRight>();\n+\n+        case KQLFunctionValue::array_shift_left:\n+            return std::make_unique<ArrayShiftLeft>();\n+\n+        case KQLFunctionValue::array_shift_right:\n+            return std::make_unique<ArrayShiftRight>();\n+\n+        case KQLFunctionValue::array_slice:\n+            return std::make_unique<ArraySlice>();\n+\n+        case KQLFunctionValue::array_sort_asc:\n+            return std::make_unique<ArraySortAsc>();\n+\n+        case KQLFunctionValue::array_sort_desc:\n+            return std::make_unique<ArraySortDesc>();\n+\n+        case KQLFunctionValue::array_split:\n+            return std::make_unique<ArraySplit>();\n+\n+        case KQLFunctionValue::array_sum:\n+            return std::make_unique<ArraySum>();\n+\n+        case KQLFunctionValue::bag_keys:\n+            return std::make_unique<BagKeys>();\n+\n+        case KQLFunctionValue::bag_merge:\n+            return std::make_unique<BagMerge>();\n+\n+        case KQLFunctionValue::bag_remove_keys:\n+            return std::make_unique<BagRemoveKeys>();\n+\n+        case KQLFunctionValue::jaccard_index:\n+            return std::make_unique<JaccardIndex>();\n+\n+        case KQLFunctionValue::pack:\n+            return std::make_unique<Pack>();\n+\n+        case KQLFunctionValue::pack_all:\n+            return std::make_unique<PackAll>();\n+\n+        case KQLFunctionValue::pack_array:\n+            return std::make_unique<PackArray>();\n+\n+        case KQLFunctionValue::repeat:\n+            return std::make_unique<Repeat>();\n+\n+        case KQLFunctionValue::set_difference:\n+            return std::make_unique<SetDifference>();\n+\n+        case KQLFunctionValue::set_has_element:\n+            return std::make_unique<SetHasElement>();\n+\n+        case KQLFunctionValue::set_intersect:\n+            return std::make_unique<SetIntersect>();\n+\n+        case KQLFunctionValue::set_union:\n+            return std::make_unique<SetUnion>();\n+\n+        case KQLFunctionValue::treepath:\n+            return std::make_unique<TreePath>();\n+\n+        case KQLFunctionValue::zip:\n+            return std::make_unique<Zip>();\n+\n+        case KQLFunctionValue::tobool:\n+            return std::make_unique<ToBool>();\n+\n+        case KQLFunctionValue::todatetime:\n+            return std::make_unique<ToDateTime>();\n+\n+        case KQLFunctionValue::todouble:\n+            return std::make_unique<ToDouble>();\n+\n+        case KQLFunctionValue::toint:\n+            return std::make_unique<ToInt>();\n+\n+        case KQLFunctionValue::tolong:\n+            return std::make_unique<ToLong>();\n+\n+        case KQLFunctionValue::tostring:\n+            return std::make_unique<ToString>();\n+\n+        case KQLFunctionValue::totimespan:\n+            return std::make_unique<ToTimeSpan>();\n+\n+        case KQLFunctionValue::todecimal:\n+            return std::make_unique<ToDecimal>();\n+\n+        case KQLFunctionValue::arg_max:\n+            return std::make_unique<ArgMax>();\n+\n+        case KQLFunctionValue::arg_min:\n+            return std::make_unique<ArgMin>();\n+\n+        case KQLFunctionValue::avg:\n+            return std::make_unique<Avg>();\n+\n+        case KQLFunctionValue::avgif:\n+            return std::make_unique<AvgIf>();\n+\n+        case KQLFunctionValue::binary_all_and:\n+            return std::make_unique<BinaryAllAnd>();\n+\n+        case KQLFunctionValue::binary_all_or:\n+            return std::make_unique<BinaryAllOr>();\n+\n+        case KQLFunctionValue::binary_all_xor:\n+            return std::make_unique<BinaryAllXor>();\n+\n+        case KQLFunctionValue::buildschema:\n+            return std::make_unique<BuildSchema>();\n+\n+        case KQLFunctionValue::count:\n+            return std::make_unique<Count>();\n+\n+        case KQLFunctionValue::countif:\n+            return std::make_unique<CountIf>();\n+\n+        case KQLFunctionValue::dcount:\n+            return std::make_unique<DCount>();\n+\n+        case KQLFunctionValue::dcountif:\n+            return std::make_unique<DCountIf>();\n+\n+        case KQLFunctionValue::make_bag:\n+            return std::make_unique<MakeBag>();\n+\n+        case KQLFunctionValue::make_bag_if:\n+            return std::make_unique<MakeBagIf>();\n+\n+        case KQLFunctionValue::make_list:\n+            return std::make_unique<MakeList>();\n+\n+        case KQLFunctionValue::make_list_if:\n+            return std::make_unique<MakeListIf>();\n+\n+        case KQLFunctionValue::make_list_with_nulls:\n+            return std::make_unique<MakeListWithNulls>();\n+\n+        case KQLFunctionValue::make_set:\n+            return std::make_unique<MakeSet>();\n+\n+        case KQLFunctionValue::make_set_if:\n+            return std::make_unique<MakeSetIf>();\n+\n+        case KQLFunctionValue::max:\n+            return std::make_unique<Max>();\n+\n+        case KQLFunctionValue::maxif:\n+            return std::make_unique<MaxIf>();\n+\n+        case KQLFunctionValue::min:\n+            return std::make_unique<Min>();\n+\n+        case KQLFunctionValue::minif:\n+            return std::make_unique<MinIf>();\n+\n+        case KQLFunctionValue::percentile:\n+            return std::make_unique<Percentile>();\n+\n+        case KQLFunctionValue::percentilew:\n+            return std::make_unique<Percentilew>();\n+\n+        case KQLFunctionValue::percentiles:\n+            return std::make_unique<Percentiles>();\n+\n+        case KQLFunctionValue::percentiles_array:\n+            return std::make_unique<PercentilesArray>();\n+\n+        case KQLFunctionValue::percentilesw:\n+            return std::make_unique<Percentilesw>();\n+\n+        case KQLFunctionValue::percentilesw_array:\n+            return std::make_unique<PercentileswArray>();\n+\n+        case KQLFunctionValue::stdev:\n+            return std::make_unique<Stdev>();\n+\n+        case KQLFunctionValue::stdevif:\n+            return std::make_unique<StdevIf>();\n+\n+        case KQLFunctionValue::sum:\n+            return std::make_unique<Sum>();\n+\n+        case KQLFunctionValue::sumif:\n+            return std::make_unique<SumIf>();\n+\n+        case KQLFunctionValue::take_any:\n+            return std::make_unique<TakeAny>();\n+\n+        case KQLFunctionValue::take_anyif:\n+            return std::make_unique<TakeAnyIf>();\n+\n+        case KQLFunctionValue::variance:\n+            return std::make_unique<Variance>();\n+\n+        case KQLFunctionValue::varianceif:\n+            return std::make_unique<VarianceIf>();\n+\n+        case KQLFunctionValue::series_fir:\n+            return std::make_unique<SeriesFir>();\n+\n+        case KQLFunctionValue::series_iir:\n+            return std::make_unique<SeriesIir>();\n+\n+        case KQLFunctionValue::series_fit_line:\n+            return std::make_unique<SeriesFitLine>();\n+\n+        case KQLFunctionValue::series_fit_line_dynamic:\n+            return std::make_unique<SeriesFitLineDynamic>();\n+\n+        case KQLFunctionValue::series_fit_2lines:\n+            return std::make_unique<SeriesFit2lines>();\n+\n+        case KQLFunctionValue::series_fit_2lines_dynamic:\n+            return std::make_unique<SeriesFit2linesDynamic>();\n+\n+        case KQLFunctionValue::series_outliers:\n+            return std::make_unique<SeriesOutliers>();\n+\n+        case KQLFunctionValue::series_periods_detect:\n+            return std::make_unique<SeriesPeriodsDetect>();\n+\n+        case KQLFunctionValue::series_periods_validate:\n+            return std::make_unique<SeriesPeriodsValidate>();\n+\n+        case KQLFunctionValue::series_stats_dynamic:\n+            return std::make_unique<SeriesStatsDynamic>();\n+\n+        case KQLFunctionValue::series_stats:\n+            return std::make_unique<SeriesStats>();\n+\n+        case KQLFunctionValue::series_fill_backward:\n+            return std::make_unique<SeriesFillBackward>();\n+\n+        case KQLFunctionValue::series_fill_const:\n+            return std::make_unique<SeriesFillConst>();\n+\n+        case KQLFunctionValue::series_fill_forward:\n+            return std::make_unique<SeriesFillForward>();\n+\n+        case KQLFunctionValue::series_fill_linear:\n+            return std::make_unique<SeriesFillLinear>();\n+\n+        case KQLFunctionValue::ipv4_compare:\n+            return std::make_unique<Ipv4Compare>();\n+\n+        case KQLFunctionValue::ipv4_is_in_range:\n+            return std::make_unique<Ipv4IsInRange>();\n+\n+        case KQLFunctionValue::ipv4_is_match:\n+            return std::make_unique<Ipv4IsMatch>();\n+\n+        case KQLFunctionValue::ipv4_is_private:\n+            return std::make_unique<Ipv4IsPrivate>();\n+\n+        case KQLFunctionValue::ipv4_netmask_suffix:\n+            return std::make_unique<Ipv4NetmaskSuffix>();\n+\n+        case KQLFunctionValue::parse_ipv4:\n+            return std::make_unique<ParseIpv4>();\n+\n+        case KQLFunctionValue::parse_ipv4_mask:\n+            return std::make_unique<ParseIpv4Mask>();\n+\n+        case KQLFunctionValue::ipv6_compare:\n+            return std::make_unique<Ipv6Compare>();\n+\n+        case KQLFunctionValue::ipv6_is_match:\n+            return std::make_unique<Ipv6IsMatch>();\n+\n+        case KQLFunctionValue::parse_ipv6:\n+            return std::make_unique<ParseIpv6>();\n+\n+        case KQLFunctionValue::parse_ipv6_mask:\n+            return std::make_unique<ParseIpv6Mask>();\n+\n+        case KQLFunctionValue::format_ipv4:\n+            return std::make_unique<FormatIpv4>();\n+\n+        case KQLFunctionValue::format_ipv4_mask:\n+            return std::make_unique<FormatIpv4Mask>();\n+\n+        case KQLFunctionValue::binary_and:\n+            return std::make_unique<BinaryAnd>();\n+\n+        case KQLFunctionValue::binary_not:\n+            return std::make_unique<BinaryNot>();\n+\n+        case KQLFunctionValue::binary_or:\n+            return std::make_unique<BinaryOr>();\n+\n+        case KQLFunctionValue::binary_shift_left:\n+            return std::make_unique<BinaryShiftLeft>();\n+\n+        case KQLFunctionValue::binary_shift_right:\n+            return std::make_unique<BinaryShiftRight>();\n+\n+        case KQLFunctionValue::binary_xor:\n+            return std::make_unique<BinaryXor>();\n+\n+        case KQLFunctionValue::bitset_count_ones:\n+            return std::make_unique<BitsetCountOnes>();\n+\n+        case KQLFunctionValue::bin:\n+            return std::make_unique<Bin>();\n+\n+        case KQLFunctionValue::bin_at:\n+            return std::make_unique<BinAt>();\n+\n+        case KQLFunctionValue::datatype_bool:\n+            return std::make_unique<DatatypeBool>();\n+\n+        case KQLFunctionValue::datatype_datetime:\n+            return std::make_unique<DatatypeDatetime>();\n+\n+        case KQLFunctionValue::datatype_dynamic:\n+            return std::make_unique<DatatypeDynamic>();\n+\n+        case KQLFunctionValue::datatype_guid:\n+            return std::make_unique<DatatypeGuid>();\n+\n+        case KQLFunctionValue::datatype_int:\n+            return std::make_unique<DatatypeInt>();\n+\n+        case KQLFunctionValue::datatype_long:\n+            return std::make_unique<DatatypeLong>();\n+\n+        case KQLFunctionValue::datatype_real:\n+            return std::make_unique<DatatypeReal>();\n+\n+        case KQLFunctionValue::datatype_string:\n+            return std::make_unique<DatatypeString>();\n+\n+        case KQLFunctionValue::datatype_timespan:\n+            return std::make_unique<DatatypeTimespan>();\n+\n+        case KQLFunctionValue::datatype_decimal:\n+            return std::make_unique<DatatypeDecimal>();\n+\n+        case KQLFunctionValue::round:\n+            return std::make_unique<Round>();\n+    }\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h b/src/Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h\nnew file mode 100644\nindex 000000000000..653d89d42e21\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h\n@@ -0,0 +1,220 @@\n+#pragma once\n+\n+#include <unordered_map>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+enum class KQLFunctionValue : uint16_t\n+{\n+    none,\n+    timespan,\n+    ago,\n+    datetime_add,\n+    datetime_part,\n+    datetime_diff,\n+    dayofmonth,\n+    dayofweek,\n+    dayofyear,\n+    endofday,\n+    endofweek,\n+    endofyear,\n+    endofmonth,\n+    monthofyear,\n+    format_datetime,\n+    format_timespan,\n+    getmonth,\n+    getyear,\n+    hourofday,\n+    make_timespan,\n+    make_datetime,\n+    now,\n+    startofday,\n+    startofmonth,\n+    startofweek,\n+    startofyear,\n+    todatetime,\n+    totimespan,\n+    unixtime_microseconds_todatetime,\n+    unixtime_milliseconds_todatetime,\n+    unixtime_nanoseconds_todatetime,\n+    unixtime_seconds_todatetime,\n+    week_of_year,\n+\n+    base64_encode_tostring,\n+    base64_encode_fromguid,\n+    base64_decode_tostring,\n+    base64_decode_toarray,\n+    base64_decode_toguid,\n+    countof,\n+    extract,\n+    extract_all,\n+    extract_json,\n+    has_any_index,\n+    indexof,\n+    isempty,\n+    isnan,\n+    isnotempty,\n+    isnotnull,\n+    isnull,\n+    parse_command_line,\n+    parse_csv,\n+    parse_json,\n+    parse_url,\n+    parse_urlquery,\n+    parse_version,\n+    replace_regex,\n+    reverse,\n+    split,\n+    strcat,\n+    strcat_delim,\n+    strcmp,\n+    strlen,\n+    strrep,\n+    substring,\n+    tolower,\n+    toupper,\n+    translate,\n+    trim,\n+    trim_end,\n+    trim_start,\n+    url_decode,\n+    url_encode,\n+\n+    array_concat,\n+    array_iif,\n+    array_index_of,\n+    array_length,\n+    array_reverse,\n+    array_rotate_left,\n+    array_rotate_right,\n+    array_shift_left,\n+    array_shift_right,\n+    array_slice,\n+    array_sort_asc,\n+    array_sort_desc,\n+    array_split,\n+    array_sum,\n+    bag_keys,\n+    bag_merge,\n+    bag_remove_keys,\n+    jaccard_index,\n+    pack,\n+    pack_all,\n+    pack_array,\n+    repeat,\n+    set_difference,\n+    set_has_element,\n+    set_intersect,\n+    set_union,\n+    treepath,\n+    zip,\n+\n+    tobool,\n+    todouble,\n+    toint,\n+    tolong,\n+    tostring,\n+    todecimal,\n+\n+    arg_max,\n+    arg_min,\n+    avg,\n+    avgif,\n+    binary_all_and,\n+    binary_all_or,\n+    binary_all_xor,\n+    buildschema,\n+    count,\n+    countif,\n+    dcount,\n+    dcountif,\n+    make_bag,\n+    make_bag_if,\n+    make_list,\n+    make_list_if,\n+    make_list_with_nulls,\n+    make_set,\n+    make_set_if,\n+    max,\n+    maxif,\n+    min,\n+    minif,\n+    percentile,\n+    percentilew,\n+    percentiles,\n+    percentiles_array,\n+    percentilesw,\n+    percentilesw_array,\n+    stdev,\n+    stdevif,\n+    sum,\n+    sumif,\n+    take_any,\n+    take_anyif,\n+    variance,\n+    varianceif,\n+\n+    series_fir,\n+    series_iir,\n+    series_fit_line,\n+    series_fit_line_dynamic,\n+    series_fit_2lines,\n+    series_fit_2lines_dynamic,\n+    series_outliers,\n+    series_periods_detect,\n+    series_periods_validate,\n+    series_stats_dynamic,\n+    series_stats,\n+    series_fill_backward,\n+    series_fill_const,\n+    series_fill_forward,\n+    series_fill_linear,\n+\n+    ipv4_compare,\n+    ipv4_is_in_range,\n+    ipv4_is_match,\n+    ipv4_is_private,\n+    ipv4_netmask_suffix,\n+    parse_ipv4,\n+    parse_ipv4_mask,\n+    ipv6_compare,\n+    ipv6_is_match,\n+    parse_ipv6,\n+    parse_ipv6_mask,\n+    format_ipv4,\n+    format_ipv4_mask,\n+\n+    binary_and,\n+    binary_not,\n+    binary_or,\n+    binary_shift_left,\n+    binary_shift_right,\n+    binary_xor,\n+    bitset_count_ones,\n+\n+    bin,\n+    bin_at,\n+\n+    datatype_bool,\n+    datatype_datetime,\n+    datatype_dynamic,\n+    datatype_guid,\n+    datatype_int,\n+    datatype_long,\n+    datatype_real,\n+    datatype_string,\n+    datatype_timespan,\n+    datatype_decimal,\n+    round\n+};\n+class KQLFunctionFactory\n+{\n+public:\n+    static std::unique_ptr<IParserKQLFunction> get(String & kql_function);\n+\n+protected:\n+    static std::unordered_map<String, KQLFunctionValue> kql_functions;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.cpp\nnew file mode 100644\nindex 000000000000..1e509f9ef0e7\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.cpp\n@@ -0,0 +1,103 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLDateTypeTimespan.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+#include <boost/lexical_cast.hpp>\n+#include <format>\n+\n+namespace DB\n+{\n+\n+bool Bin::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    double bin_size;\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String origal_expr(pos->begin, pos->end);\n+    String value = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    String round_to = getConvertedArgument(fn_name, pos);\n+\n+    //remove sapce between minus and number\n+    round_to.erase(std::remove_if(round_to.begin(), round_to.end(), isspace), round_to.end());\n+\n+    auto t = std::format(\"toFloat64({})\", value);\n+\n+    bin_size = std::stod(round_to);\n+\n+    if (origal_expr == \"datetime\" || origal_expr == \"date\")\n+    {\n+        out = std::format(\"toDateTime64(toInt64({0}/{1}) * {1}, 9, 'UTC')\", t, bin_size);\n+    }\n+    else if (origal_expr == \"timespan\" || origal_expr == \"time\" || ParserKQLDateTypeTimespan().parseConstKQLTimespan(origal_expr))\n+    {\n+        String bin_value = std::format(\"toInt64({0}/{1}) * {1}\", t, bin_size);\n+        out = std::format(\n+            \"concat(toString(toInt32((({}) as x) / 3600)),':', toString(toInt32(x % 3600 / 60)),':',toString(toInt32(x % 3600 % 60)))\",\n+            bin_value);\n+    }\n+    else\n+    {\n+        out = std::format(\"toInt64({0} / {1}) * {1}\", t, bin_size);\n+    }\n+    return true;\n+}\n+\n+bool BinAt::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    double bin_size;\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String origal_expr(pos->begin, pos->end);\n+    String expression_str = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    String bin_size_str = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    String fixed_point_str = getConvertedArgument(fn_name, pos);\n+\n+    auto t1 = std::format(\"toFloat64({})\", fixed_point_str);\n+    auto t2 = std::format(\"toFloat64({})\", expression_str);\n+    int dir = t2 >= t1 ? 0 : -1;\n+    bin_size = std::stod(bin_size_str);\n+\n+    if (origal_expr == \"datetime\" || origal_expr == \"date\")\n+    {\n+        out = std::format(\"toDateTime64({} + toInt64(({} - {}) / {} + {}) * {}, 9, 'UTC')\", t1, t2, t1, bin_size, dir, bin_size);\n+    }\n+    else if (origal_expr == \"timespan\" || origal_expr == \"time\" || ParserKQLDateTypeTimespan().parseConstKQLTimespan(origal_expr))\n+    {\n+        String bin_value = std::format(\"{} + toInt64(({} - {}) / {} + {}) * {}\", t1, t2, t1, bin_size, dir, bin_size);\n+        out = std::format(\n+            \"concat(toString(toInt32((({}) as x) / 3600)),':', toString(toInt32(x % 3600 / 60)), ':', toString(toInt32(x % 3600 % 60)))\",\n+            bin_value);\n+    }\n+    else\n+    {\n+        out = std::format(\"{} + toInt64(({} - {}) / {} + {}) * {}\", t1, t2, t1, bin_size, dir, bin_size);\n+    }\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h\nnew file mode 100644\nindex 000000000000..ba10bab6553b\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h\n@@ -0,0 +1,21 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class Bin : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bin()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class BinAt : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"bin_at()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLIPFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLIPFunctions.cpp\nnew file mode 100644\nindex 000000000000..6f853b16fbce\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLIPFunctions.cpp\n@@ -0,0 +1,275 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+\n+#include <format>\n+\n+namespace DB\n+{\n+bool Ipv4Compare::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto rhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto mask = getOptionalArgument(function_name, pos, ArgumentState::Parsed);\n+    out = std::format(\n+        \"if(isNull({0} as lhs_ip_{5}) or isNull({1} as lhs_mask_{5}) \"\n+        \"or isNull({2} as rhs_ip_{5}) or isNull({3} as rhs_mask_{5}), null, \"\n+        \"sign(IPv4StringToNumOrNull(toString((tupleElement(IPv4CIDRToRange(assumeNotNull(lhs_ip_{5}), \"\n+        \"toUInt8(min2({4}, min2(assumeNotNull(lhs_mask_{5}), assumeNotNull(rhs_mask_{5})))) as mask_{5}), 1))))\"\n+        \"   - IPv4StringToNumOrNull(toString((tupleElement(IPv4CIDRToRange(assumeNotNull(rhs_ip_{5}), mask_{5}), 1))))))\",\n+        kqlCallToExpression(\"parse_ipv4\", {lhs}, pos.max_depth),\n+        kqlCallToExpression(\"ipv4_netmask_suffix\", {lhs}, pos.max_depth),\n+        kqlCallToExpression(\"parse_ipv4\", {rhs}, pos.max_depth),\n+        kqlCallToExpression(\"ipv4_netmask_suffix\", {rhs}, pos.max_depth),\n+        mask ? *mask : \"32\",\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool Ipv4IsInRange::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos, ArgumentState::Parsed);\n+    const auto ip_range = getArgument(function_name, pos, ArgumentState::Raw);\n+    out = std::format(\n+        \"if(isNull(IPv4StringToNumOrNull({0}) as ip_{3}) \"\n+        \"or isNull({1} as range_start_ip_{3}) or isNull({2} as range_mask_{3}), null, \"\n+        \"bitXor(range_start_ip_{3}, bitAnd(ip_{3}, bitNot(toUInt32(intExp2(toInt32(32 - range_mask_{3})) - 1)))) = 0) \",\n+        ip_address,\n+        kqlCallToExpression(\"parse_ipv4\", {ip_range}, pos.max_depth),\n+        kqlCallToExpression(\"ipv4_netmask_suffix\", {ip_range}, pos.max_depth),\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool Ipv4IsMatch::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto rhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto mask = getOptionalArgument(function_name, pos, ArgumentState::Raw);\n+    out = std::format(\"equals({}, 0)\", kqlCallToExpression(\"ipv4_compare\", {lhs, rhs, mask ? *mask : \"32\"}, pos.max_depth));\n+    return true;\n+}\n+\n+bool Ipv4IsPrivate::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    static const std::array<String, 3> s_private_subnets{\"10.0.0.0/8\", \"172.16.0.0/12\", \"192.168.0.0/16\"};\n+\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos);\n+    const auto unique_identifier = generateUniqueIdentifier();\n+\n+    out += std::format(\n+        \"multiIf(length(splitByChar('/', {0}) as tokens_{1}) > 2 or isNull(toIPv4OrNull(tokens_{1}[1]) as nullable_ip_{1}) \"\n+        \"or length(tokens_{1}) = 2 and isNull(toUInt8OrNull(tokens_{1}[-1]) as mask_{1}), null, \"\n+        \"ignore(assumeNotNull(nullable_ip_{1}) as ip_{1}, \"\n+        \"IPv4CIDRToRange(ip_{1}, assumeNotNull(mask_{1})) as range_{1}, IPv4NumToString(tupleElement(range_{1}, 1)) as begin_{1}, \"\n+        \"IPv4NumToString(tupleElement(range_{1}, 2)) as end_{1}), null, \",\n+        ip_address,\n+        unique_identifier);\n+    for (int i = 0; i < std::ssize(s_private_subnets); ++i)\n+    {\n+        if (i > 0)\n+            out += \" or \";\n+\n+        const auto & subnet = s_private_subnets[i];\n+        out += std::format(\n+            \"length(tokens_{1}) = 1 and isIPAddressInRange(IPv4NumToString(ip_{1}), '{0}') or \"\n+            \"length(tokens_{1}) = 2 and isIPAddressInRange(begin_{1}, '{0}') and isIPAddressInRange(end_{1}, '{0}')\",\n+            subnet,\n+            unique_identifier);\n+    }\n+\n+    out.push_back(')');\n+    return true;\n+}\n+\n+bool Ipv4NetmaskSuffix::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_range = getArgument(function_name, pos);\n+    out = std::format(\n+        \"multiIf(length(splitByChar('/', {0}) as tokens_{1}) > 2 or not isIPv4String(tokens_{1}[1]), null, \"\n+        \"length(tokens_{1}) = 1, 32, isNull(toUInt8OrNull(tokens_{1}[-1]) as mask_{1}), null, toUInt8(min2(mask_{1}, 32)))\",\n+        ip_range,\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool ParseIpv4::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos);\n+    out = std::format(\n+        \"multiIf(length(splitByChar('/', {0}) as tokens_{1}) = 1, IPv4StringToNumOrNull(tokens_{1}[1]) as ip_{1}, \"\n+        \"length(tokens_{1}) = 2 and isNotNull(ip_{1}) and isNotNull(toUInt8OrNull(tokens_{1}[-1]) as mask_{1}), \"\n+        \"IPv4StringToNumOrNull(toString(tupleElement(IPv4CIDRToRange(toIPv4(assumeNotNull(ip_{1})), assumeNotNull(mask_{1})), 1))), null)\",\n+        ip_address,\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool ParseIpv4Mask::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos);\n+    const auto mask = getArgument(function_name, pos);\n+    out = std::format(\n+        \"if(isNull(toIPv4OrNull({0}) as ip_{2}) or isNull(toUInt8OrNull(toString({1})) as mask_{2}), null, \"\n+        \"toUInt32(tupleElement(IPv4CIDRToRange(assumeNotNull(ip_{2}), arrayMax([0, arrayMin([32, assumeNotNull(mask_{2})])])), 1)))\",\n+        ip_address,\n+        mask,\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool Ipv6Compare::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos);\n+    const auto rhs = getArgument(function_name, pos);\n+    const auto mask = getOptionalArgument(function_name, pos);\n+    const auto calculated_mask = mask ? *mask : \"128\";\n+    out = std::format(\n+        \"if(length(splitByChar('/', {1}) as lhs_tokens_{0}) > 2 or length(splitByChar('/', {2}) as rhs_tokens_{0}) > 2 \"\n+        \"or isNull(IPv6StringToNumOrNull(lhs_tokens_{0}[1]) as lhs_ipv6_{0}) or length(lhs_tokens_{0}) = 2 \"\n+        \"and isNull((if(isIPv4String(lhs_tokens_{0}[1]), 96, 0) + toUInt8OrNull(lhs_tokens_{0}[-1])) as lhs_suffix_{0}) \"\n+        \"or isNull(IPv6StringToNumOrNull(rhs_tokens_{0}[1]) as rhs_ipv6_{0}) or length(rhs_tokens_{0}) = 2 \"\n+        \"and isNull((if(isIPv4String(rhs_tokens_{0}[1]), 96, 0) + toUInt8OrNull(rhs_tokens_{0}[-1])) as rhs_suffix_{0}) \"\n+        \"or isNull(toUInt8(min2({3}, min2(ifNull(lhs_suffix_{0}, 128), ifNull(rhs_suffix_{0}, 128)))) as suffix_{0}) \"\n+        \"or isNull(bitShiftLeft(bitShiftRight(bitNot(reinterpretAsFixedString(0::UInt128)), (128 - suffix_{0}) as zeroes_{0}), \"\n+        \"zeroes_{0}) as mask_{0}) or isNull(bitAnd(lhs_ipv6_{0}, mask_{0}) as lhs_base_{0}) \"\n+        \"or isNull(bitAnd(rhs_ipv6_{0}, mask_{0}) as rhs_base_{0}), null, \"\n+        \"multiIf(lhs_base_{0} < rhs_base_{0}, -1, lhs_base_{0} > rhs_base_{0}, 1, 0))\",\n+        generateUniqueIdentifier(),\n+        lhs,\n+        rhs,\n+        calculated_mask);\n+    return true;\n+}\n+\n+bool Ipv6IsMatch::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto lhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto rhs = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto mask = getOptionalArgument(function_name, pos, ArgumentState::Raw);\n+    out = std::format(\"equals({}, 0)\", kqlCallToExpression(\"ipv6_compare\", {lhs, rhs, mask ? *mask : \"128\"}, pos.max_depth));\n+    return true;\n+}\n+\n+bool ParseIpv6::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos);\n+    out = std::format(\n+        \"if(length(splitByChar('/', assumeNotNull({0})) as tokens_{1}) > 2 or isNull(IPv6StringToNumOrNull(tokens_{1}[1]) as ip_{1}) \"\n+        \"or length(tokens_{1}) = 2 and isNull(toUInt8OrNull(tokens_{1}[-1]) as mask_{1}), null, \"\n+        \"arrayStringConcat(flatten(extractAllGroups(lower(hex(tupleElement(IPv6CIDRToRange(assumeNotNull(ip_{1}), toUInt8(ifNull(mask_{1} \"\n+        \"+ if(isIPv4String(tokens_{1}[1]), 96, 0), 128))), 1))), '([\\\\da-f]{{4}})')), ':'))\",\n+        ip_address,\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool ParseIpv6Mask::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto mask = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto unique_identifier = generateUniqueIdentifier();\n+    out = std::format(\n+        \"if(empty({0} as ipv4_{3}), {1}, {2})\",\n+        kqlCallToExpression(\"format_ipv4\", {\"trim_start('::', \" + ip_address + \")\", mask + \" - 96\"}, pos.max_depth),\n+        kqlCallToExpression(\"parse_ipv6\", {\"strcat(tostring(parse_ipv6(\" + ip_address + \")), '/', tostring(\" + mask + \"))\"}, pos.max_depth),\n+        kqlCallToExpression(\"parse_ipv6\", {\"ipv4_\" + unique_identifier}, pos.max_depth),\n+        unique_identifier);\n+    return true;\n+}\n+\n+bool FormatIpv4::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto mask = getOptionalArgument(function_name, pos, ArgumentState::Parsed);\n+    out = std::format(\n+        \"ifNull(if(isNotNull(toUInt32OrNull(toString({0})) as param_as_uint32_{3}) and toTypeName({0}) = 'String' or ({1}) < 0 \"\n+        \"or isNull(ifNull(param_as_uint32_{3}, {2}) as ip_as_number_{3}), null, \"\n+        \"IPv4NumToString(bitAnd(ip_as_number_{3}, bitNot(toUInt32(intExp2(toInt32(32 - ({1}))) - 1))))), '')\",\n+        ParserKQLBase::getExprFromToken(ip_address, pos.max_depth),\n+        mask ? *mask : \"32\",\n+        kqlCallToExpression(\"parse_ipv4\", {\"tostring(\" + ip_address + \")\"}, pos.max_depth),\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool FormatIpv4Mask::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto ip_address = getArgument(function_name, pos, ArgumentState::Raw);\n+    const auto mask = getOptionalArgument(function_name, pos, ArgumentState::Raw);\n+    const auto calculated_mask = mask ? *mask : \"32\";\n+    out = std::format(\n+        \"if(empty({1} as formatted_ip_{2}) or position(toTypeName({0}), 'Int') = 0 or not {0} between 0 and 32, '', \"\n+        \"concat(formatted_ip_{2}, '/', toString(toInt64(min2({0}, ifNull({3} as suffix_{2}, 32))))))\",\n+        ParserKQLBase::getExprFromToken(calculated_mask, pos.max_depth),\n+        kqlCallToExpression(\"format_ipv4\", {ip_address, calculated_mask}, pos.max_depth),\n+        generateUniqueIdentifier(),\n+        kqlCallToExpression(\"ipv4_netmask_suffix\", {\"tostring(\" + ip_address + \")\"}, pos.max_depth));\n+    return true;\n+}\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLIPFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLIPFunctions.h\nnew file mode 100644\nindex 000000000000..a654e90ce181\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLIPFunctions.h\n@@ -0,0 +1,98 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class Ipv4Compare : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv4_compare()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Ipv4IsInRange : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv4_is_in_range()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Ipv4IsMatch : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv4_is_match()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Ipv4IsPrivate : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv4_is_private()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Ipv4NetmaskSuffix : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv4_netmask_suffix()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseIpv4 : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_ipv4()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseIpv4Mask : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_ipv4_mask()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Ipv6Compare : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv6_compare()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Ipv6IsMatch : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"ipv6_is_match()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseIpv6 : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_ipv6()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseIpv6Mask : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_ipv6_mask()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class FormatIpv4 : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"format_ipv4()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class FormatIpv4Mask : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"format_ipv4_mask()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.cpp\nnew file mode 100644\nindex 000000000000..4225b093ca29\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.cpp\n@@ -0,0 +1,23 @@\n+#include \"KQLMathematicalFunctions.h\"\n+\n+#include <format>\n+\n+namespace DB\n+{\n+bool IsNan::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto argument = getArgument(function_name, pos);\n+    out = std::format(\"if(toTypeName({0}) = 'Float64', isNaN({0}), throwIf(true, 'Expected argument of data type real'))\", argument);\n+\n+    return true;\n+}\n+\n+bool Round::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"round\");\n+}\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.h\nnew file mode 100644\nindex 000000000000..561f4e674107\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLMathematicalFunctions.h\n@@ -0,0 +1,21 @@\n+#pragma once\n+\n+#include \"IParserKQLFunction.h\"\n+\n+namespace DB\n+{\n+class IsNan : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"isnan()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Round : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"round()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLStringFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLStringFunctions.cpp\nnew file mode 100644\nindex 000000000000..0f9ca67d6dc4\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLStringFunctions.cpp\n@@ -0,0 +1,773 @@\n+#include <Parsers/CommonParsers.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+#include <Poco/String.h>\n+\n+#include <format>\n+\n+\n+namespace DB::ErrorCodes\n+{\n+extern const int SYNTAX_ERROR;\n+extern const int BAD_ARGUMENTS;\n+extern const int UNKNOWN_TYPE;\n+\n+}\n+\n+namespace DB\n+{\n+\n+bool Base64EncodeToString::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"base64Encode\");\n+}\n+\n+bool Base64EncodeFromGuid::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto argument = getArgument(function_name, pos);\n+    out = std::format(\n+        \"if(toTypeName({0}) not in ['UUID', 'Nullable(UUID)'], toString(throwIf(true, 'Expected guid as argument')), \"\n+        \"base64Encode(UUIDStringToNum(toString({0}), 2)))\",\n+        argument,\n+        generateUniqueIdentifier());\n+    return true;\n+}\n+\n+bool Base64DecodeToString::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"base64Decode\");\n+}\n+\n+bool Base64DecodeToArray::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String str = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"arrayMap(x -> (reinterpretAsUInt8(x)), splitByRegexp ('',base64Decode({})))\", str);\n+\n+    return true;\n+}\n+\n+bool Base64DecodeToGuid::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const auto function_name = getKQLFunctionName(pos);\n+    if (function_name.empty())\n+        return false;\n+\n+    const auto argument = getArgument(function_name, pos);\n+    out = std::format(\"toUUIDOrNull(UUIDNumToString(toFixedString(base64Decode({}), 16), 2))\", argument);\n+\n+    return true;\n+}\n+\n+bool CountOf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String source = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String search = getConvertedArgument(fn_name, pos);\n+\n+    String kind = \"'normal'\";\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        kind = getConvertedArgument(fn_name, pos);\n+    }\n+    assert(kind == \"'normal'\" || kind == \"'regex'\");\n+\n+    if (kind == \"'normal'\")\n+        out = \"countSubstrings(\" + source + \", \" + search + \")\";\n+    else\n+        out = \"countMatches(\" + source + \", \" + search + \")\";\n+    return true;\n+}\n+\n+bool Extract::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    ParserKeyword s_kql(\"typeof\");\n+    ParserToken open_bracket(TokenType::OpeningRoundBracket);\n+    ParserToken close_bracket(TokenType::ClosingRoundBracket);\n+    Expected expected;\n+\n+    std::unordered_map<String, String> type_cast\n+        = {{\"bool\", \"Boolean\"},\n+           {\"boolean\", \"Boolean\"},\n+           {\"datetime\", \"DateTime\"},\n+           {\"date\", \"DateTime\"},\n+           {\"guid\", \"UUID\"},\n+           {\"int\", \"Int32\"},\n+           {\"long\", \"Int64\"},\n+           {\"real\", \"Float64\"},\n+           {\"double\", \"Float64\"},\n+           {\"string\", \"String\"},\n+           {\"decimal\", \"Decimal\"}};\n+\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String regex = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    size_t capture_group = stoi(getConvertedArgument(fn_name, pos));\n+\n+    ++pos;\n+    String source = getConvertedArgument(fn_name, pos);\n+\n+    String type_literal;\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+\n+        if (s_kql.ignore(pos, expected))\n+        {\n+            if (!open_bracket.ignore(pos, expected))\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near typeof\");\n+\n+            type_literal = String(pos->begin, pos->end);\n+\n+            if (type_cast.find(type_literal) == type_cast.end())\n+                throw Exception(ErrorCodes::UNKNOWN_TYPE, \"{} is not a supported kusto data type for extract\", type_literal);\n+\n+            type_literal = type_cast[type_literal];\n+            ++pos;\n+\n+            if (!close_bracket.ignore(pos, expected))\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near typeof\");\n+        }\n+    }\n+\n+    if (capture_group == 0)\n+    {\n+        String tmp_regex;\n+        for (auto c : regex)\n+        {\n+            if (c != '(' && c != ')')\n+                tmp_regex += c;\n+        }\n+        regex = std::move(tmp_regex);\n+    }\n+    else\n+    {\n+        size_t group_idx = 0;\n+        size_t str_idx = -1;\n+        for (size_t i = 0; i < regex.length(); ++i)\n+        {\n+            if (regex[i] == '(')\n+            {\n+                ++group_idx;\n+                if (group_idx == capture_group)\n+                {\n+                    str_idx = i + 1;\n+                    break;\n+                }\n+            }\n+        }\n+        String tmp_regex;\n+        if (str_idx > 0)\n+        {\n+            for (size_t i = str_idx; i < regex.length(); ++i)\n+            {\n+                if (regex[i] == ')')\n+                    break;\n+                tmp_regex += regex[i];\n+            }\n+        }\n+        regex = \"'\" + tmp_regex + \"'\";\n+    }\n+\n+    out = \"extract(\" + source + \", \" + regex + \")\";\n+\n+    if (type_literal == \"Decimal\")\n+    {\n+        out = std::format(\"countSubstrings({0}, '.') > 1 ? NULL: {0}, length(substr({0}, position({0},'.') + 1)))\", out);\n+        out = std::format(\"toDecimal128OrNull({0})\", out);\n+    }\n+    else\n+    {\n+        if (type_literal == \"Boolean\")\n+            out = std::format(\"toInt64OrNull({})\", out);\n+\n+        if (!type_literal.empty())\n+            out = \"accurateCastOrNull(\" + out + \", '\" + type_literal + \"')\";\n+    }\n+    return true;\n+}\n+\n+bool ExtractAll::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String regex = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String second_arg = getConvertedArgument(fn_name, pos);\n+\n+    String third_arg;\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        third_arg = getConvertedArgument(fn_name, pos);\n+    }\n+\n+    if (!third_arg.empty()) // currently the captureGroups not supported\n+        return false;\n+\n+    out = \"extractAllGroups(\" + second_arg + \", \" + regex + \")\";\n+    return true;\n+}\n+\n+bool ExtractJson::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String datatype = \"String\";\n+    ParserKeyword s_kql(\"typeof\");\n+    ParserToken open_bracket(TokenType::OpeningRoundBracket);\n+    ParserToken close_bracket(TokenType::ClosingRoundBracket);\n+    Expected expected;\n+\n+    std::unordered_map<String, String> type_cast\n+        = {{\"bool\", \"Boolean\"},\n+           {\"boolean\", \"Boolean\"},\n+           {\"datetime\", \"DateTime\"},\n+           {\"date\", \"DateTime\"},\n+           {\"dynamic\", \"Array\"},\n+           {\"guid\", \"UUID\"},\n+           {\"int\", \"Int32\"},\n+           {\"long\", \"Int64\"},\n+           {\"real\", \"Float64\"},\n+           {\"double\", \"Float64\"},\n+           {\"string\", \"String\"},\n+           {\"decimal\", \"Decimal\"}};\n+\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String json_datapath = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    const String json_datasource = getConvertedArgument(fn_name, pos);\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        if (s_kql.ignore(pos, expected))\n+        {\n+            if (!open_bracket.ignore(pos, expected))\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near typeof\");\n+\n+            datatype = String(pos->begin, pos->end);\n+\n+            if (type_cast.find(datatype) == type_cast.end())\n+                throw Exception(ErrorCodes::UNKNOWN_TYPE, \"{} is not a supported kusto data type for {}\", datatype, fn_name);\n+            datatype = type_cast[datatype];\n+            ++pos;\n+\n+            if (!close_bracket.ignore(pos, expected))\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near typeof\");\n+        }\n+    }\n+    const auto json_val = std::format(\"JSON_VALUE({0},{1})\", json_datasource, json_datapath);\n+\n+    if (datatype == \"Decimal\")\n+    {\n+        out = std::format(\"countSubstrings({0}, '.') > 1 ? NULL: length(substr({0}, position({0},'.') + 1)))\", json_val);\n+        out = std::format(\"toDecimal128OrNull({0}::String, {1})\", json_val, out);\n+    }\n+    else\n+    {\n+        if (datatype == \"Boolean\")\n+            out = std::format(\"toInt64OrNull({})\", json_val);\n+\n+        if (!datatype.empty())\n+            out = std::format(\"accurateCastOrNull({},'{}')\", json_val, datatype);\n+    }\n+    return true;\n+}\n+\n+bool HasAnyIndex::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String source = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String lookup = getConvertedArgument(fn_name, pos);\n+    String src_array = std::format(\"splitByChar(' ',{})\", source);\n+    out = std::format(\n+        \"if(empty({1}), -1, indexOf(arrayMap(x->(x in {0}), if(empty({1}),[''], arrayMap(x->(toString(x)),{1}))),1) - 1)\",\n+        src_array,\n+        lookup);\n+    return true;\n+}\n+\n+bool IndexOf::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    int start_index = 0, length = -1, occurrence = 1;\n+\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String source = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String lookup = getConvertedArgument(fn_name, pos);\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        start_index = stoi(getConvertedArgument(fn_name, pos));\n+\n+        if (pos->type == TokenType::Comma)\n+        {\n+            ++pos;\n+            length = stoi(getConvertedArgument(fn_name, pos));\n+\n+            if (pos->type == TokenType::Comma)\n+            {\n+                ++pos;\n+                occurrence = stoi(getConvertedArgument(fn_name, pos));\n+            }\n+        }\n+    }\n+\n+    if (pos->type == TokenType::ClosingRoundBracket)\n+    {\n+        if (occurrence < 0 || length < -1)\n+            out = \"\";\n+        else if (length == -1)\n+            out = \"position(\" + source + \", \" + lookup + \", \" + std::to_string(start_index + 1) + \") - 1\";\n+        else\n+        {\n+        }\n+\n+        return true;\n+    }\n+\n+    return false;\n+}\n+\n+bool IsEmpty::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"empty\");\n+}\n+\n+bool IsNotEmpty::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"notEmpty\");\n+}\n+\n+bool IsNotNull::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"isNotNull\");\n+}\n+\n+bool ParseCommandLine::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String json_string = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String type = getConvertedArgument(fn_name, pos);\n+\n+    if (type != \"'windows'\")\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Supported type argument is windows for {}\", fn_name);\n+\n+    out = std::format(\n+        \"if(empty({0}) OR hasAll(splitByChar(' ', {0}) , ['']) , arrayMap(x->null, splitByChar(' ', '')), splitByChar(' ', {0}))\",\n+        json_string);\n+    return true;\n+}\n+\n+bool IsNull::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"isNull\");\n+}\n+\n+bool ParseCSV::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String csv_string = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\n+        \"if(position({0} ,'\\n')::UInt8, (splitByChar(',', substring({0}, 1, position({0},'\\n') -1))), (splitByChar(',', substring({0}, 1, \"\n+        \"length({0})))))\",\n+        csv_string);\n+    return true;\n+}\n+\n+bool ParseJson::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    if (String(pos->begin, pos->end) == \"dynamic\")\n+    {\n+        --pos;\n+        auto arg = getArgument(fn_name, pos);\n+        auto result = kqlCallToExpression(\"dynamic\", {arg}, pos.max_depth);\n+        out = std::format(\"{}\", result);\n+    }\n+    else\n+    {\n+        auto arg = getConvertedArgument(fn_name, pos);\n+        out = std::format(\"if (isValidJSON({0}) , JSON_QUERY({0}, '$') , toJSONString({0}))\", arg);\n+    }\n+    return true;\n+}\n+\n+bool ParseURL::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String url = getConvertedArgument(fn_name, pos);\n+\n+    const String scheme = std::format(R\"(concat('\"Scheme\":\"', protocol({0}),'\"'))\", url);\n+    const String host = std::format(R\"(concat('\"Host\":\"', domain({0}),'\"'))\", url);\n+    const String port = std::format(R\"(concat('\"Port\":\"', toString(port({0})),'\"'))\", url);\n+    const String path = std::format(R\"(concat('\"Path\":\"', path({0}),'\"'))\", url);\n+    const String username_pwd = std::format(\"netloc({0})\", url);\n+    const String query_string = std::format(\"queryString({0})\", url);\n+    const String fragment = std::format(R\"(concat('\"Fragment\":\"',fragment({0}),'\"'))\", url);\n+    const String username = std::format(\n+        R\"(concat('\"Username\":\"', arrayElement(splitByChar(':',arrayElement(splitByChar('@',{0}) ,1)),1),'\"'))\", username_pwd);\n+    const String password = std::format(\n+        R\"(concat('\"Password\":\"', arrayElement(splitByChar(':',arrayElement(splitByChar('@',{0}) ,1)),2),'\"'))\", username_pwd);\n+    const String query_parameters = std::format(\n+        R\"(concat('\"Query Parameters\":', concat('{{\"', replace(replace({}, '=', '\":\"'),'&','\",\"') ,'\"}}')))\", query_string);\n+\n+    out = std::format(\n+        \"concat('{{',{},',',{},',',{},',',{},',',{},',',{},',',{},',',{},'}}')\",\n+        scheme,\n+        host,\n+        port,\n+        path,\n+        username,\n+        password,\n+        query_parameters,\n+        fragment);\n+    return true;\n+}\n+\n+bool ParseURLQuery::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    ++pos;\n+    const String query = getConvertedArgument(fn_name, pos);\n+\n+    const String query_string = std::format(\"if (position({},'?') > 0, queryString({}), {})\", query, query, query);\n+    const String query_parameters = std::format(\n+        R\"(concat('\"Query Parameters\":', concat('{{\"', replace(replace({}, '=', '\":\"'),'&','\",\"') ,'\"}}')))\", query_string);\n+    out = std::format(\"concat('{{',{},'}}')\", query_parameters);\n+    return true;\n+}\n+\n+bool ParseVersion::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+    String arg;\n+    ++pos;\n+    arg = getConvertedArgument(fn_name, pos);\n+    out = std::format(\n+        \"length(splitByChar('.', {0})) > 4 OR  length(splitByChar('.', {0})) < 1 OR match({0}, '.*[a-zA-Z]+.*') = 1 ? \"\n+        \"toDecimal128OrNull('NULL' , 0)  : toDecimal128OrNull(substring(arrayStringConcat(arrayMap(x -> leftPad(x, 8, '0'), arrayMap(x -> \"\n+        \"if(empty(x), '0', x), arrayResize(splitByChar('.', {0}), 4)))), 8),0)\",\n+        arg);\n+    return true;\n+}\n+\n+bool ReplaceRegex::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"replaceRegexpAll\");\n+}\n+\n+bool Reverse::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+\n+    auto arg = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"reverse(accurateCastOrNull({} , 'String'))\", arg);\n+\n+    return true;\n+}\n+\n+bool Split::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String source = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String delimiter = getConvertedArgument(fn_name, pos);\n+    auto split_res = std::format(\"empty({0}) ? splitByString(' ' , {1}) : splitByString({0} , {1})\", delimiter, source);\n+    int requested_index = -1;\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        auto arg = getConvertedArgument(fn_name, pos);\n+        // remove space between minus and value\n+        arg.erase(remove_if(arg.begin(), arg.end(), isspace), arg.end());\n+        requested_index = std::stoi(arg);\n+        requested_index += 1;\n+        out = std::format(\n+            \"multiIf(length({0}) >= {1} AND {1} > 0, arrayPushBack([],arrayElement({0}, {1})), {1}=0, {0}, arrayPushBack([] \"\n+            \",arrayElement(NULL,1)))\",\n+            split_res,\n+            requested_index);\n+    }\n+    else\n+        out = split_res;\n+    return true;\n+}\n+\n+bool StrCat::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"concat\");\n+}\n+\n+bool StrCatDelim::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String delimiter = getConvertedArgument(fn_name, pos);\n+\n+    int arg_count = 0;\n+    String args;\n+\n+    while (!pos->isEnd() && pos->type != TokenType::Semicolon && pos->type != TokenType::ClosingRoundBracket)\n+    {\n+        ++pos;\n+        String arg = getConvertedArgument(fn_name, pos);\n+        if (args.empty())\n+            args = \"concat(\" + arg;\n+        else\n+            args = args + \", \" + delimiter + \", \" + arg;\n+        ++arg_count;\n+    }\n+    args += \")\";\n+\n+    if (arg_count < 2 || arg_count > 64)\n+        throw Exception(ErrorCodes::SYNTAX_ERROR, \"argument count out of bound in function: {}\", fn_name);\n+\n+    out = std::move(args);\n+    return true;\n+}\n+\n+bool StrCmp::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String string1 = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    const String string2 = getConvertedArgument(fn_name, pos);\n+\n+    out = std::format(\"multiIf({0} == {1}, 0, {0} < {1}, -1, 1)\", string1, string2);\n+    return true;\n+}\n+\n+bool StrLen::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"lengthUTF8\");\n+}\n+\n+bool StrRep::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    const String value = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    const String multiplier = getConvertedArgument(fn_name, pos);\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        const String delimiter = getConvertedArgument(fn_name, pos);\n+        const String repeated_str = \"repeat(concat(\" + value + \",\" + delimiter + \"),\" + multiplier + \")\";\n+        out = \"substr(\" + repeated_str + \", 1, length(\" + repeated_str + \") - length(\" + delimiter + \"))\";\n+    }\n+    else\n+        out = \"repeat(\" + value + \", \" + multiplier + \")\";\n+\n+    return true;\n+}\n+\n+bool SubString::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String source = getConvertedArgument(fn_name, pos);\n+\n+    ++pos;\n+    String starting_index = getConvertedArgument(fn_name, pos);\n+\n+    if (pos->type == TokenType::Comma)\n+    {\n+        ++pos;\n+        auto length = getConvertedArgument(fn_name, pos);\n+\n+        if (starting_index.empty())\n+            throw Exception(ErrorCodes::SYNTAX_ERROR, \"number of arguments do not match in function: {}\", fn_name);\n+        else\n+            out = \"if(toInt64(length(\" + source + \")) <= 0, '', substr(\" + source + \", \" + \"((\" + starting_index + \"% toInt64(length(\"\n+                + source + \"))  + toInt64(length(\" + source + \"))) % toInt64(length(\" + source + \")))  + 1, \" + length + \") )\";\n+    }\n+    else\n+        out = \"if(toInt64(length(\" + source + \")) <= 0, '', substr(\" + source + \",\" + \"((\" + starting_index + \"% toInt64(length(\" + source\n+            + \")) + toInt64(length(\" + source + \"))) % toInt64(length(\" + source + \"))) + 1))\";\n+\n+    return true;\n+}\n+\n+bool ToLower::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"lower\");\n+}\n+\n+bool ToUpper::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"upper\");\n+}\n+\n+bool Translate::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+\n+    if (fn_name.empty())\n+        return false;\n+\n+    ++pos;\n+    String from = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    String to = getConvertedArgument(fn_name, pos);\n+    ++pos;\n+    String source = getConvertedArgument(fn_name, pos);\n+\n+    String len_diff = std::format(\"length({}) - length({})\", from, to);\n+    String to_str = std::format(\n+        \"multiIf(length({1}) = 0, {0}, {2} > 0, concat({1},repeat(substr({1},length({1}),1),toUInt16({2}))),{2} < 0, \"\n+        \"substr({1},1,length({0})),{1})\",\n+        from,\n+        to,\n+        len_diff);\n+    out = std::format(\"if (length({3}) = 0,'',translate({0},{1},{2}))\", source, from, to_str, to);\n+    return true;\n+}\n+\n+bool Trim::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    const auto regex = getArgument(fn_name, pos, ArgumentState::Raw);\n+    const auto source = getArgument(fn_name, pos, ArgumentState::Raw);\n+    out = kqlCallToExpression(\"trim_start\", {regex, std::format(\"trim_end({0}, {1})\", regex, source)}, pos.max_depth);\n+\n+    return true;\n+}\n+\n+bool TrimEnd::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    const auto regex = getArgument(fn_name, pos);\n+    const auto source = getArgument(fn_name, pos);\n+    out = std::format(\"replaceRegexpOne({0}, concat({1}, '$'), '')\", source, regex);\n+\n+    return true;\n+}\n+\n+bool TrimStart::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    const String fn_name = getKQLFunctionName(pos);\n+    if (fn_name.empty())\n+        return false;\n+\n+    const auto regex = getArgument(fn_name, pos);\n+    const auto source = getArgument(fn_name, pos);\n+    out = std::format(\"replaceRegexpOne({0}, concat('^', {1}), '')\", source, regex);\n+\n+    return true;\n+}\n+\n+bool URLDecode::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"decodeURLComponent\");\n+}\n+\n+bool URLEncode::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    return directMapping(out, pos, \"encodeURLComponent\");\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLStringFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLStringFunctions.h\nnew file mode 100644\nindex 000000000000..492a59263ecc\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLStringFunctions.h\n@@ -0,0 +1,275 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <base/extended_types.h>\n+\n+namespace DB\n+{\n+class Base64EncodeToString : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"base64_encode_tostring()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Base64EncodeFromGuid : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"base64_encode_fromguid()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Base64DecodeToString : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"base64_decode_tostring()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Base64DecodeToArray : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"base64_decode_toarray()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Base64DecodeToGuid : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"base64_decode_toguid()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class CountOf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"countof()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Extract : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"extract()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ExtractAll : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"extract_all()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ExtractJson : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"extract_json(), extractjson()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class HasAnyIndex : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"has_any_index()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class IndexOf : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"indexof()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class IsEmpty : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"isempty()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class IsNotEmpty : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"isnotempty()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class IsNotNull : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"isnotnull()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class IsNull : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"isnull()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseCommandLine : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_command_line()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseCSV : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_csv()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseJson : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_json()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseURL : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_url()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseURLQuery : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_urlquery()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ParseVersion : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"parse_version()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ReplaceRegex : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"replace_regex()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Reverse : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"reverse()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Split : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"split()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StrCat : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"strcat()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StrCatDelim : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"strcat_delim()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StrCmp : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"strcmp()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StrLen : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"strlen()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class StrRep : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"strrep()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SubString : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"substring()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToLower : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"tolower()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class ToUpper : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"toupper()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Translate : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"translate()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class Trim : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"trim()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class TrimEnd : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"trim_end()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class TrimStart : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"trim_start()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class URLDecode : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"url_decode()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class URLEncode : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"url_encode()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.cpp b/src/Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.cpp\nnew file mode 100644\nindex 000000000000..9a7165362100\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.cpp\n@@ -0,0 +1,126 @@\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLAggregationFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLBinaryFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLCastingFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDateTimeFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLDynamicFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLGeneralFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLIPFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLStringFunctions.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/ParserSetQuery.h>\n+\n+namespace DB\n+{\n+\n+bool SeriesFir::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesIir::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFitLine::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFitLineDynamic::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFit2lines::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFit2linesDynamic::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesOutliers::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesPeriodsDetect::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesPeriodsValidate::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesStatsDynamic::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesStats::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFillBackward::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFillConst::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFillForward::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+bool SeriesFillLinear::convertImpl(String & out, IParser::Pos & pos)\n+{\n+    String res = String(pos->begin, pos->end);\n+    out = res;\n+    return false;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h b/src/Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h\nnew file mode 100644\nindex 000000000000..486e2bc6391c\n--- /dev/null\n+++ b/src/Parsers/Kusto/KustoFunctions/KQLTimeSeriesFunctions.h\n@@ -0,0 +1,112 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+namespace DB\n+{\n+class SeriesFir : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fir()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesIir : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_iir()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFitLine : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fit_line()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFitLineDynamic : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fit_line_dynamic()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFit2lines : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fit_2lines()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFit2linesDynamic : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fit_2lines_dynamic()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesOutliers : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_outliers()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesPeriodsDetect : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_periods_detect()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesPeriodsValidate : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_periods_validate()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesStatsDynamic : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_stats_dynamic()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesStats : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_stats()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFillBackward : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fill_backward()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFillConst : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fill_const()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFillForward : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fill_forward()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+class SeriesFillLinear : public IParserKQLFunction\n+{\n+protected:\n+    const char * getName() const override { return \"series_fill_linear()\"; }\n+    bool convertImpl(String & out, IParser::Pos & pos) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLDateTypeTimespan.cpp b/src/Parsers/Kusto/ParserKQLDateTypeTimespan.cpp\nnew file mode 100644\nindex 000000000000..c4f84d576cb9\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLDateTypeTimespan.cpp\n@@ -0,0 +1,202 @@\n+#include <cmath>\n+#include <cstdlib>\n+#include <format>\n+#include <unordered_map>\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLDateTypeTimespan.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Common/StringUtils/StringUtils.h>\n+\n+namespace DB\n+{\n+\n+bool ParserKQLDateTypeTimespan ::parseImpl(Pos & pos, [[maybe_unused]] ASTPtr & node, Expected & expected)\n+{\n+    String token;\n+    const char * current_word = pos->begin;\n+    expected.add(pos, current_word);\n+\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+        token = String(pos->begin + 1, pos->end - 1);\n+    else\n+        token = String(pos->begin, pos->end);\n+    if (!parseConstKQLTimespan(token))\n+        return false;\n+\n+    return true;\n+}\n+\n+double ParserKQLDateTypeTimespan::toSeconds()\n+{\n+    switch (time_span_unit)\n+    {\n+        case KQLTimespanUint::day:\n+            return time_span * 24 * 60 * 60;\n+        case KQLTimespanUint::hour:\n+            return time_span * 60 * 60;\n+        case KQLTimespanUint::minute:\n+            return time_span * 60;\n+        case KQLTimespanUint::second:\n+            return time_span;\n+        case KQLTimespanUint::millisec:\n+            return time_span / 1000.0;\n+        case KQLTimespanUint::microsec:\n+            return time_span / 1000000.0;\n+        case KQLTimespanUint::nanosec:\n+            return time_span / 1000000000.0;\n+        case KQLTimespanUint::tick:\n+            return time_span / 10000000.0;\n+    }\n+}\n+\n+bool ParserKQLDateTypeTimespan ::parseConstKQLTimespan(const String & text)\n+{\n+    std::unordered_map<String, KQLTimespanUint> timespan_suffixes\n+        = {{\"d\", KQLTimespanUint::day},\n+           {\"day\", KQLTimespanUint::day},\n+           {\"days\", KQLTimespanUint::day},\n+           {\"h\", KQLTimespanUint::hour},\n+           {\"hr\", KQLTimespanUint::hour},\n+           {\"hrs\", KQLTimespanUint::hour},\n+           {\"hour\", KQLTimespanUint::hour},\n+           {\"hours\", KQLTimespanUint::hour},\n+           {\"m\", KQLTimespanUint::minute},\n+           {\"min\", KQLTimespanUint::minute},\n+           {\"minute\", KQLTimespanUint::minute},\n+           {\"minutes\", KQLTimespanUint::minute},\n+           {\"s\", KQLTimespanUint::second},\n+           {\"sec\", KQLTimespanUint::second},\n+           {\"second\", KQLTimespanUint::second},\n+           {\"seconds\", KQLTimespanUint::second},\n+           {\"ms\", KQLTimespanUint::millisec},\n+           {\"milli\", KQLTimespanUint::millisec},\n+           {\"millis\", KQLTimespanUint::millisec},\n+           {\"millisec\", KQLTimespanUint::millisec},\n+           {\"millisecond\", KQLTimespanUint::millisec},\n+           {\"milliseconds\", KQLTimespanUint::millisec},\n+           {\"micro\", KQLTimespanUint::microsec},\n+           {\"micros\", KQLTimespanUint::microsec},\n+           {\"microsec\", KQLTimespanUint::microsec},\n+           {\"microsecond\", KQLTimespanUint::microsec},\n+           {\"microseconds\", KQLTimespanUint::microsec},\n+           {\"nano\", KQLTimespanUint::nanosec},\n+           {\"nanos\", KQLTimespanUint::nanosec},\n+           {\"nanosec\", KQLTimespanUint::nanosec},\n+           {\"nanosecond\", KQLTimespanUint::nanosec},\n+           {\"nanoseconds\", KQLTimespanUint::nanosec},\n+           {\"tick\", KQLTimespanUint::tick},\n+           {\"ticks\", KQLTimespanUint::tick}};\n+\n+    int days = 0, hours = 0, minutes = 0, seconds = 0, sec_scale_len = 0;\n+    double nanoseconds = 00.00;\n+\n+    const char * ptr = text.c_str();\n+    bool sign = false;\n+\n+    auto scan_digit = [&](const char * start) -> int\n+    {\n+        const auto * index = start;\n+        while (isdigit(*index))\n+            ++index;\n+        return index > start ? static_cast<int>(index - start) : -1;\n+    };\n+    if (*ptr == '-')\n+    {\n+        sign = true;\n+        ++ptr;\n+    }\n+    auto number_len = scan_digit(ptr);\n+    if (number_len <= 0)\n+        return false;\n+\n+    days = std::stoi(String(ptr, ptr + number_len));\n+\n+    if (*(ptr + number_len) == '.')\n+    {\n+        auto fraction_len = scan_digit(ptr + number_len + 1);\n+        if (fraction_len >= 0)\n+        {\n+            hours = std::stoi(String(ptr + number_len + 1, ptr + number_len + 1 + fraction_len));\n+            number_len += fraction_len + 1;\n+        }\n+    }\n+    else if (*(ptr + number_len) == '\\0')\n+    {\n+        if (sign)\n+            time_span = -(std::stoi(String(ptr, ptr + number_len))) * 86400;\n+        else\n+            time_span = std::stoi(String(ptr, ptr + number_len)) * 86400;\n+\n+        time_span_unit = KQLTimespanUint::second;\n+        return true;\n+    }\n+    else\n+    {\n+        hours = days;\n+        days = 0;\n+    }\n+\n+    if (*(ptr + number_len) != ':')\n+    {\n+        String timespan_suffix(ptr + number_len, ptr + text.size());\n+\n+        trim(timespan_suffix);\n+        if (timespan_suffixes.find(timespan_suffix) == timespan_suffixes.end())\n+            return false;\n+\n+        time_span = std::stod(String(ptr, ptr + number_len));\n+        time_span_unit = timespan_suffixes[timespan_suffix];\n+\n+        return true;\n+    }\n+\n+    if (hours > 23)\n+        return false;\n+\n+    auto min_len = scan_digit(ptr + number_len + 1);\n+    if (min_len < 0)\n+        return false;\n+\n+    minutes = std::stoi(String(ptr + number_len + 1, ptr + number_len + 1 + min_len));\n+    if (minutes > 59)\n+        return false;\n+\n+    number_len += min_len + 1;\n+    if (*(ptr + number_len) == ':')\n+    {\n+        auto sec_len = scan_digit(ptr + number_len + 1);\n+        if (sec_len > 0)\n+        {\n+            seconds = std::stoi(String(ptr + number_len + 1, ptr + number_len + 1 + sec_len));\n+            if (seconds > 59)\n+                return false;\n+\n+            number_len += sec_len + 1;\n+            if (*(ptr + number_len) == '.')\n+            {\n+                sec_scale_len = scan_digit(ptr + number_len + 1);\n+                if (sec_scale_len > 0)\n+                {\n+                    nanoseconds = std::stoi(String(ptr + number_len + 1, ptr + number_len + 1 + sec_scale_len));\n+\n+                    if (nanoseconds > 1000000000)\n+                        return false;\n+                }\n+            }\n+        }\n+    }\n+    auto exponent = 9 - sec_scale_len; // max supported length of fraction of seconds is 9\n+    nanoseconds = nanoseconds * pow(10, exponent);\n+\n+    if (sign)\n+        time_span = -(days * 86400 + hours * 3600 + minutes * 60 + seconds + (nanoseconds / 1000000000));\n+    else\n+        time_span = days * 86400 + hours * 3600 + minutes * 60 + seconds + (nanoseconds / 1000000000);\n+\n+    time_span_unit = KQLTimespanUint::second;\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLDateTypeTimespan.h b/src/Parsers/Kusto/ParserKQLDateTypeTimespan.h\nnew file mode 100644\nindex 000000000000..232bc01d7e9b\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLDateTypeTimespan.h\n@@ -0,0 +1,35 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+class ParserKQLDateTypeTimespan : public ParserKQLBase\n+{\n+public:\n+    enum class KQLTimespanUint : uint8_t\n+    {\n+        day,\n+        hour,\n+        minute,\n+        second,\n+        millisec,\n+        microsec,\n+        nanosec,\n+        tick\n+    };\n+    bool parseConstKQLTimespan(const String & text);\n+    double toSeconds();\n+\n+protected:\n+    const char * getName() const override { return \"KQLDateTypeTimespan\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+\n+private:\n+    double time_span;\n+    KQLTimespanUint time_span_unit;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLDistinct.cpp b/src/Parsers/Kusto/ParserKQLDistinct.cpp\nnew file mode 100644\nindex 000000000000..2de4d2c28e7d\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLDistinct.cpp\n@@ -0,0 +1,26 @@\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/Kusto/ParserKQLDistinct.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+namespace DB\n+{\n+\n+bool ParserKQLDistinct::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr select_expression_list;\n+    String expr;\n+\n+    expr = getExprFromToken(pos);\n+\n+    Tokens tokens(expr.c_str(), expr.c_str() + expr.size());\n+    IParser::Pos new_pos(tokens, pos.max_depth);\n+\n+    if (!ParserNotEmptyExpressionList(false).parse(new_pos, select_expression_list, expected))\n+        return false;\n+\n+    node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::SELECT, std::move(select_expression_list));\n+    node->as<ASTSelectQuery>()->distinct = true;\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLDistinct.h b/src/Parsers/Kusto/ParserKQLDistinct.h\nnew file mode 100644\nindex 000000000000..e3471f351b28\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLDistinct.h\n@@ -0,0 +1,16 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+class ParserKQLDistinct : public ParserKQLBase\n+{\n+protected:\n+    const char * getName() const override { return \"KQL distinct\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLExtend.cpp b/src/Parsers/Kusto/ParserKQLExtend.cpp\nnew file mode 100644\nindex 000000000000..ac5beb805766\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLExtend.cpp\n@@ -0,0 +1,90 @@\n+#include <format>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLExtend.h>\n+#include <Parsers/Kusto/ParserKQLMakeSeries.h>\n+#include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/ParserKQLProject.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/ParserSelectQuery.h>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n+\n+namespace DB\n+{\n+bool ParserKQLExtend ::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr select_query;\n+    int32_t new_column_index = 1;\n+\n+    String extend_expr = getExprFromToken(pos);\n+\n+    String except_str;\n+    String new_extend_str;\n+    Tokens ntokens(extend_expr.c_str(), extend_expr.c_str() + extend_expr.size());\n+    IParser::Pos npos(ntokens, pos.max_depth);\n+\n+    String alias;\n+\n+    auto apply_alias = [&]\n+    {\n+        if (alias.empty())\n+        {\n+            alias = std::format(\"Column{}\", new_column_index);\n+            ++new_column_index;\n+            new_extend_str += \" AS\";\n+        }\n+        else\n+            except_str = except_str.empty() ? \" except \" + alias : except_str + \" except \" + alias;\n+\n+        new_extend_str = new_extend_str + \" \" + alias;\n+\n+        alias.clear();\n+    };\n+\n+    int32_t round_bracket_count = 0;\n+    int32_t square_bracket_count = 0;\n+    while (!npos->isEnd())\n+    {\n+        if (npos->type == TokenType::OpeningRoundBracket)\n+            ++round_bracket_count;\n+        if (npos->type == TokenType::OpeningSquareBracket)\n+            ++square_bracket_count;\n+        if (npos->type == TokenType::ClosingRoundBracket)\n+            --round_bracket_count;\n+        if (npos->type == TokenType::ClosingSquareBracket)\n+            --square_bracket_count;\n+\n+        auto expr = String(npos->begin, npos->end);\n+        if (expr == \"AS\")\n+        {\n+            ++npos;\n+            alias = String(npos->begin, npos->end);\n+        }\n+\n+        if (npos->type == TokenType::Comma && square_bracket_count == 0 && round_bracket_count == 0)\n+        {\n+            apply_alias();\n+            new_extend_str += \", \";\n+        }\n+        else\n+            new_extend_str = new_extend_str.empty() ? expr : new_extend_str + \" \" + expr;\n+\n+        ++npos;\n+    }\n+    apply_alias();\n+\n+    String expr = std::format(\"SELECT * {}, {} from prev\", except_str, new_extend_str);\n+    Tokens tokens(expr.c_str(), expr.c_str() + expr.size());\n+    IParser::Pos new_pos(tokens, pos.max_depth);\n+\n+    if (!ParserSelectQuery().parse(new_pos, select_query, expected))\n+        return false;\n+    if (!setSubQuerySource(select_query, node, false, false))\n+        return false;\n+\n+    node = select_query;\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLExtend.h b/src/Parsers/Kusto/ParserKQLExtend.h\nnew file mode 100644\nindex 000000000000..90d92b6a1c2a\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLExtend.h\n@@ -0,0 +1,17 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLProject.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+class ParserKQLExtend : public ParserKQLBase\n+{\n+protected:\n+    const char * getName() const override { return \"KQL extend\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLFilter.cpp b/src/Parsers/Kusto/ParserKQLFilter.cpp\nindex 3a399bdccdb1..74d8610ecd4b 100644\n--- a/src/Parsers/Kusto/ParserKQLFilter.cpp\n+++ b/src/Parsers/Kusto/ParserKQLFilter.cpp\n@@ -1,19 +1,19 @@\n #include <Parsers/ASTLiteral.h>\n-#include <Parsers/IParserBase.h>\n #include <Parsers/ExpressionListParsers.h>\n-#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/IParserBase.h>\n #include <Parsers/Kusto/ParserKQLFilter.h>\n #include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n \n namespace DB\n {\n \n-bool ParserKQLFilter :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLFilter::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     String expr = getExprFromToken(pos);\n     ASTPtr where_expression;\n \n-    Tokens token_filter(expr.c_str(), expr.c_str()+expr.size());\n+    Tokens token_filter(expr.c_str(), expr.c_str() + expr.size());\n     IParser::Pos pos_filter(token_filter, pos.max_depth);\n     if (!ParserExpressionWithOptionalAlias(false).parse(pos_filter, where_expression, expected))\n         return false;\ndiff --git a/src/Parsers/Kusto/ParserKQLLimit.cpp b/src/Parsers/Kusto/ParserKQLLimit.cpp\nindex bb8e08fd3786..910f0e8e1a37 100644\n--- a/src/Parsers/Kusto/ParserKQLLimit.cpp\n+++ b/src/Parsers/Kusto/ParserKQLLimit.cpp\n@@ -1,15 +1,13 @@\n-#include <Parsers/IParserBase.h>\n+#include <cstdlib>\n #include <Parsers/ExpressionListParsers.h>\n-#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/IParserBase.h>\n #include <Parsers/Kusto/ParserKQLLimit.h>\n-#include <Parsers/ParserTablesInSelectQuery.h>\n-#include <cstdlib>\n-#include <format>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n \n namespace DB\n {\n \n-bool ParserKQLLimit :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLLimit::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr limit_length;\n \ndiff --git a/src/Parsers/Kusto/ParserKQLMVExpand.cpp b/src/Parsers/Kusto/ParserKQLMVExpand.cpp\nnew file mode 100644\nindex 000000000000..bf5fbe64d0b6\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLMVExpand.cpp\n@@ -0,0 +1,311 @@\n+#include <format>\n+#include <unordered_map>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLMVExpand.h>\n+#include <Parsers/Kusto/ParserKQLMakeSeries.h>\n+#include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/ParserSelectQuery.h>\n+#include <Parsers/ParserSetQuery.h>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n+\n+namespace DB::ErrorCodes\n+{\n+extern const int UNKNOWN_TYPE;\n+}\n+\n+namespace DB\n+{\n+\n+std::unordered_map<String, String> ParserKQLMVExpand::type_cast\n+    = {{\"bool\", \"Boolean\"},\n+       {\"boolean\", \"Boolean\"},\n+       {\"datetime\", \"DateTime\"},\n+       {\"date\", \"DateTime\"},\n+       {\"guid\", \"UUID\"},\n+       {\"int\", \"Int32\"},\n+       {\"long\", \"Int64\"},\n+       {\"real\", \"Float64\"},\n+       {\"double\", \"Float64\"},\n+       {\"string\", \"String\"}};\n+\n+bool ParserKQLMVExpand::parseColumnArrayExprs(ColumnArrayExprs & column_array_exprs, Pos & pos, Expected & expected)\n+{\n+    ParserToken equals(TokenType::Equals);\n+    ParserToken open_bracket(TokenType::OpeningRoundBracket);\n+    ParserToken close_bracket(TokenType::ClosingRoundBracket);\n+    ParserToken comma(TokenType::Comma);\n+\n+    ParserKeyword s_to(\"to\");\n+    ParserKeyword s_type(\"typeof\");\n+    uint16_t bracket_count = 0;\n+    Pos expr_begin_pos = pos;\n+    Pos expr_end_pos = pos;\n+\n+    String alias;\n+    String column_array_expr;\n+    String to_type;\n+    --expr_end_pos;\n+\n+    while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+    {\n+        if (pos->type == TokenType::OpeningRoundBracket)\n+            ++bracket_count;\n+\n+        if (pos->type == TokenType::ClosingRoundBracket)\n+            --bracket_count;\n+\n+        if (String(pos->begin, pos->end) == \"=\")\n+        {\n+            --pos;\n+            alias = String(pos->begin, pos->end);\n+            ++pos;\n+            ++pos;\n+            expr_begin_pos = pos;\n+        }\n+\n+        auto add_columns = [&]\n+        {\n+            column_array_expr = getExprFromToken(String(expr_begin_pos->begin, expr_end_pos->end), pos.max_depth);\n+\n+            if (alias.empty())\n+            {\n+                alias = expr_begin_pos == expr_end_pos ? column_array_expr : String(expr_begin_pos->begin, expr_begin_pos->end) + \"_\";\n+            }\n+            column_array_exprs.push_back(ColumnArrayExpr(alias, column_array_expr, to_type));\n+        };\n+\n+        if (s_to.ignore(pos, expected))\n+        {\n+            --pos;\n+            --pos;\n+            expr_end_pos = pos;\n+            ++pos;\n+            ++pos;\n+\n+            column_array_expr = String(expr_begin_pos->begin, expr_end_pos->end);\n+\n+            if (!s_type.ignore(pos, expected))\n+                return false;\n+            if (!open_bracket.ignore(pos, expected))\n+                return false;\n+            to_type = String(pos->begin, pos->end);\n+\n+            if (type_cast.find(to_type) == type_cast.end())\n+                throw Exception(ErrorCodes::UNKNOWN_TYPE, \"{} is not a supported kusto data type for mv-expand\", to_type);\n+\n+            ++pos;\n+            if (!close_bracket.ignore(pos, expected))\n+                return false;\n+            --pos;\n+        }\n+\n+        if ((pos->type == TokenType::Comma && bracket_count == 0) || String(pos->begin, pos->end) == \"limit\"\n+            || pos->type == TokenType::Semicolon)\n+        {\n+            if (column_array_expr.empty())\n+            {\n+                expr_end_pos = pos;\n+                --expr_end_pos;\n+            }\n+            add_columns();\n+            expr_begin_pos = pos;\n+            expr_end_pos = pos;\n+            ++expr_begin_pos;\n+\n+            alias.clear();\n+            column_array_expr.clear();\n+            to_type.clear();\n+\n+            if (pos->type == TokenType::Semicolon)\n+                break;\n+        }\n+\n+        if (String(pos->begin, pos->end) == \"limit\")\n+            break;\n+        if (!pos->isEnd())\n+            ++pos;\n+        if (pos->isEnd() || pos->type == TokenType::PipeMark || pos->type == TokenType::Semicolon)\n+        {\n+            if (expr_end_pos < expr_begin_pos)\n+            {\n+                expr_end_pos = pos;\n+                --expr_end_pos;\n+            }\n+            add_columns();\n+            break;\n+        }\n+    }\n+    return true;\n+}\n+\n+bool ParserKQLMVExpand::parserMVExpand(KQLMVExpand & kql_mv_expand, Pos & pos, Expected & expected)\n+{\n+    ParserKeyword s_bagexpansion(\"bagexpansion\");\n+    ParserKeyword s_kind(\"kind\");\n+    ParserKeyword s_with_itemindex(\"with_itemindex\");\n+    ParserKeyword s_limit(\"limit\");\n+\n+    ParserToken equals(TokenType::Equals);\n+    ParserToken comma(TokenType::Comma);\n+\n+    auto & column_array_exprs = kql_mv_expand.column_array_exprs;\n+    auto & bagexpansion = kql_mv_expand.bagexpansion;\n+    auto & with_itemindex = kql_mv_expand.with_itemindex;\n+    auto & limit = kql_mv_expand.limit;\n+\n+    if (s_bagexpansion.ignore(pos, expected))\n+    {\n+        if (!equals.ignore(pos, expected))\n+            return false;\n+        bagexpansion = String(pos->begin, pos->end);\n+        ++pos;\n+    }\n+    else if (s_kind.ignore(pos, expected))\n+    {\n+        if (!equals.ignore(pos, expected))\n+            return false;\n+        bagexpansion = String(pos->begin, pos->end);\n+        ++pos;\n+    }\n+\n+    if (s_with_itemindex.ignore(pos, expected))\n+    {\n+        if (!equals.ignore(pos, expected))\n+            return false;\n+        with_itemindex = String(pos->begin, pos->end);\n+        ++pos;\n+    }\n+\n+    if (!parseColumnArrayExprs(column_array_exprs, pos, expected))\n+        return false;\n+\n+    if (s_limit.ignore(pos, expected))\n+        limit = String(pos->begin, pos->end);\n+\n+    return true;\n+}\n+\n+bool ParserKQLMVExpand::genQuery(KQLMVExpand & kql_mv_expand, ASTPtr & select_node, int32_t max_depth)\n+{\n+    String expand_str;\n+    String cast_type_column_remove, cast_type_column_rename;\n+    String cast_type_column_restore, cast_type_column_restore_name;\n+    String row_count_str;\n+    String extra_columns;\n+    String input = \"dummy_input\";\n+    for (auto column : kql_mv_expand.column_array_exprs)\n+    {\n+        if (column.alias == column.column_array_expr)\n+            expand_str = expand_str.empty() ? String(\"ARRAY JOIN \") + column.alias : expand_str + \",\" + column.alias;\n+        else\n+        {\n+            expand_str = expand_str.empty() ? std::format(\"ARRAY JOIN {} AS {} \", column.column_array_expr, column.alias)\n+                                            : expand_str + std::format(\", {} AS {}\", column.column_array_expr, column.alias);\n+            extra_columns = extra_columns + \", \" + column.alias;\n+        }\n+\n+        if (!column.to_type.empty())\n+        {\n+            cast_type_column_remove\n+                = cast_type_column_remove.empty() ? \" Except \" + column.alias : cast_type_column_remove + \" Except \" + column.alias;\n+            String rename_str;\n+\n+            if (type_cast[column.to_type] == \"Boolean\")\n+                rename_str = std::format(\n+                    \"accurateCastOrNull(toInt64OrNull(toString({0})),'{1}') as {0}_ali\", column.alias, type_cast[column.to_type]);\n+            else\n+                rename_str = std::format(\"accurateCastOrNull({0},'{1}') as {0}_ali\", column.alias, type_cast[column.to_type]);\n+\n+            cast_type_column_rename = cast_type_column_rename.empty() ? rename_str : cast_type_column_rename + \",\" + rename_str;\n+            cast_type_column_restore = cast_type_column_restore.empty()\n+                ? std::format(\" Except {}_ali \", column.alias)\n+                : cast_type_column_restore + std::format(\" Except {}_ali \", column.alias);\n+            cast_type_column_restore_name = cast_type_column_restore_name.empty()\n+                ? std::format(\"{0}_ali as {0}\", column.alias)\n+                : cast_type_column_restore_name + std::format(\", {0}_ali as {0}\", column.alias);\n+        }\n+\n+        if (!kql_mv_expand.with_itemindex.empty())\n+        {\n+            row_count_str = row_count_str.empty() ? \"length(\" + column.alias + \")\" : row_count_str + \", length(\" + column.alias + \")\";\n+        }\n+    }\n+\n+    String columns = \"*\";\n+    if (!row_count_str.empty())\n+    {\n+        expand_str += std::format(\", range(0, arrayMax([{}])) AS {} \", row_count_str, kql_mv_expand.with_itemindex);\n+        columns = kql_mv_expand.with_itemindex + \" , \" + columns;\n+    }\n+\n+    if (!kql_mv_expand.limit.empty())\n+        expand_str += \" LIMIT \" + kql_mv_expand.limit;\n+\n+    auto query = std::format(\"(Select {} {} From {} {})\", columns, extra_columns, input, expand_str);\n+\n+    ASTPtr sub_query_node;\n+    Expected expected;\n+\n+    if (cast_type_column_remove.empty())\n+    {\n+        query = std::format(\"Select {} {} From {} {}\", columns, extra_columns, input, expand_str);\n+        if (!parseSQLQueryByString(std::make_unique<ParserSelectQuery>(), query, sub_query_node, max_depth))\n+            return false;\n+        if (!setSubQuerySource(sub_query_node, select_node, false, false))\n+            return false;\n+        select_node = std::move(sub_query_node);\n+    }\n+    else\n+    {\n+        query = std::format(\"(Select {} {} From {} {})\", columns, extra_columns, input, expand_str);\n+        if (!parseSQLQueryByString(std::make_unique<ParserTablesInSelectQuery>(), query, sub_query_node, max_depth))\n+            return false;\n+        if (!setSubQuerySource(sub_query_node, select_node, true, false))\n+            return false;\n+        select_node = std::move(sub_query_node);\n+\n+        auto rename_query = std::format(\"(Select * {}, {} From {})\", cast_type_column_remove, cast_type_column_rename, \"query\");\n+        if (!parseSQLQueryByString(std::make_unique<ParserTablesInSelectQuery>(), rename_query, sub_query_node, max_depth))\n+            return false;\n+        if (!setSubQuerySource(sub_query_node, select_node, true, true))\n+            return false;\n+\n+        select_node = std::move(sub_query_node);\n+        query = std::format(\"Select * {}, {} from {}\", cast_type_column_restore, cast_type_column_restore_name, \"rename_query\");\n+\n+        if (!parseSQLQueryByString(std::make_unique<ParserSelectQuery>(), query, sub_query_node, max_depth))\n+            return false;\n+        sub_query_node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::TABLES, std::move(select_node));\n+        select_node = std::move(sub_query_node);\n+    }\n+    return true;\n+}\n+\n+bool ParserKQLMVExpand::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr setting;\n+    ASTPtr select_expression_list;\n+    auto begin = pos;\n+\n+    KQLMVExpand kql_mv_expand;\n+    if (!parserMVExpand(kql_mv_expand, pos, expected))\n+        return false;\n+    if (!genQuery(kql_mv_expand, node, pos.max_depth))\n+        return false;\n+\n+    const String setting_str = \"enable_unaligned_array_join = 1\";\n+    Tokens token_settings(setting_str.c_str(), setting_str.c_str() + setting_str.size());\n+    IParser::Pos pos_settings(token_settings, pos.max_depth);\n+\n+    if (!ParserSetQuery(true).parse(pos_settings, setting, expected))\n+        return false;\n+    node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::SETTINGS, std::move(setting));\n+\n+    pos = begin;\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLMVExpand.h b/src/Parsers/Kusto/ParserKQLMVExpand.h\nnew file mode 100644\nindex 000000000000..61f206bb00da\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLMVExpand.h\n@@ -0,0 +1,41 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+class ParserKQLMVExpand : public ParserKQLBase\n+{\n+protected:\n+    static std::unordered_map<String, String> type_cast;\n+\n+    struct ColumnArrayExpr\n+    {\n+        String alias;\n+        String column_array_expr;\n+        String to_type;\n+        ColumnArrayExpr(String alias_, String column_array_expr_, String to_type_)\n+            : alias(alias_), column_array_expr(column_array_expr_), to_type(to_type_)\n+        {\n+        }\n+    };\n+    using ColumnArrayExprs = std::vector<ColumnArrayExpr>;\n+\n+    struct KQLMVExpand\n+    {\n+        ColumnArrayExprs column_array_exprs;\n+        String bagexpansion;\n+        String with_itemindex;\n+        String limit;\n+    };\n+\n+    static bool parseColumnArrayExprs(ColumnArrayExprs & column_array_exprs, Pos & pos, Expected & expected);\n+    static bool parserMVExpand(KQLMVExpand & kql_mv_expand, Pos & pos, Expected & expected);\n+    static bool genQuery(KQLMVExpand & kql_mv_expand, ASTPtr & select_node, int32_t max_depth);\n+\n+    const char * getName() const override { return \"KQL mv-expand\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLMakeSeries.cpp b/src/Parsers/Kusto/ParserKQLMakeSeries.cpp\nnew file mode 100644\nindex 000000000000..a37276530494\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLMakeSeries.cpp\n@@ -0,0 +1,426 @@\n+#include <format>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLDateTypeTimespan.h>\n+#include <Parsers/Kusto/ParserKQLMakeSeries.h>\n+#include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/ParserSelectQuery.h>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n+\n+namespace DB\n+{\n+\n+bool ParserKQLMakeSeries ::parseAggregationColumns(AggregationColumns & aggregation_columns, Pos & pos)\n+{\n+    std::unordered_set<String> allowed_aggregation(\n+        {\"avg\",\n+         \"avgif\",\n+         \"count\",\n+         \"countif\",\n+         \"dcount\",\n+         \"dcountif\",\n+         \"max\",\n+         \"maxif\",\n+         \"min\",\n+         \"minif\",\n+         \"percentile\",\n+         \"take_any\",\n+         \"stdev\",\n+         \"sum\",\n+         \"sumif\",\n+         \"variance\"});\n+\n+    Expected expected;\n+    ParserKeyword s_default(\"default\");\n+    ParserToken equals(TokenType::Equals);\n+    ParserToken open_bracket(TokenType::OpeningRoundBracket);\n+    ParserToken close_bracket(TokenType::ClosingRoundBracket);\n+    ParserToken comma(TokenType::Comma);\n+\n+    while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+    {\n+        String alias;\n+        String aggregation_fun;\n+        String column;\n+        double default_value = 0;\n+\n+        String first_token(pos->begin, pos->end);\n+\n+        ++pos;\n+        if (equals.ignore(pos, expected))\n+        {\n+            alias = std::move(first_token);\n+            aggregation_fun = String(pos->begin, pos->end);\n+            ++pos;\n+        }\n+        else\n+            aggregation_fun = std::move(first_token);\n+\n+        if (allowed_aggregation.find(aggregation_fun) == allowed_aggregation.end())\n+            return false;\n+\n+        if (open_bracket.ignore(pos, expected))\n+            column = String(pos->begin, pos->end);\n+        else\n+            return false;\n+\n+        ++pos;\n+        if (!close_bracket.ignore(pos, expected))\n+            return false;\n+\n+        if (s_default.ignore(pos, expected))\n+        {\n+            if (!equals.ignore(pos, expected))\n+                return false;\n+\n+            default_value = std::stod(String(pos->begin, pos->end));\n+            ++pos;\n+        }\n+        if (alias.empty())\n+            alias = std::format(\"{}_{}\", aggregation_fun, column);\n+        aggregation_columns.push_back(AggregationColumn(alias, aggregation_fun, column, default_value));\n+\n+        if (!comma.ignore(pos, expected))\n+            break;\n+    }\n+    return true;\n+}\n+\n+bool ParserKQLMakeSeries ::parseFromToStepClause(FromToStepClause & from_to_step, Pos & pos)\n+{\n+    auto begin = pos;\n+    auto from_pos = begin;\n+    auto to_pos = begin;\n+    auto step_pos = begin;\n+    auto end_pos = begin;\n+\n+    while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+    {\n+        if (String(pos->begin, pos->end) == \"from\")\n+            from_pos = pos;\n+        if (String(pos->begin, pos->end) == \"to\")\n+            to_pos = pos;\n+        if (String(pos->begin, pos->end) == \"step\")\n+            step_pos = pos;\n+        if (String(pos->begin, pos->end) == \"by\")\n+        {\n+            end_pos = pos;\n+            break;\n+        }\n+        ++pos;\n+    }\n+\n+    if (end_pos == begin)\n+        end_pos = pos;\n+\n+    if (String(step_pos->begin, step_pos->end) != \"step\")\n+        return false;\n+\n+    if (String(from_pos->begin, from_pos->end) == \"from\")\n+    {\n+        ++from_pos;\n+        auto end_from_pos = (to_pos != begin) ? to_pos : step_pos;\n+        --end_from_pos;\n+        from_to_step.from_str = String(from_pos->begin, end_from_pos->end);\n+    }\n+\n+    if (String(to_pos->begin, to_pos->end) == \"to\")\n+    {\n+        ++to_pos;\n+        --step_pos;\n+        from_to_step.to_str = String(to_pos->begin, step_pos->end);\n+        ++step_pos;\n+    }\n+    --end_pos;\n+    ++step_pos;\n+    from_to_step.step_str = String(step_pos->begin, end_pos->end);\n+\n+    if (String(step_pos->begin, step_pos->end) == \"time\" || String(step_pos->begin, step_pos->end) == \"timespan\"\n+        || ParserKQLDateTypeTimespan().parseConstKQLTimespan(from_to_step.step_str))\n+    {\n+        from_to_step.is_timespan = true;\n+        from_to_step.step = std::stod(getExprFromToken(from_to_step.step_str, pos.max_depth));\n+    }\n+    else\n+        from_to_step.step = std::stod(from_to_step.step_str);\n+\n+    return true;\n+}\n+\n+bool ParserKQLMakeSeries ::makeSeries(KQLMakeSeries & kql_make_series, ASTPtr & select_node, const uint32_t & max_depth)\n+{\n+    const uint64_t era_diff\n+        = 62135596800; // this magic number is the differicen is second form 0001-01-01 (Azure start time ) and 1970-01-01 (CH start time)\n+\n+    String start_str, end_str;\n+    String sub_query, main_query;\n+\n+    auto & aggregation_columns = kql_make_series.aggregation_columns;\n+    auto & from_to_step = kql_make_series.from_to_step;\n+    auto & subquery_columns = kql_make_series.subquery_columns;\n+    auto & axis_column = kql_make_series.axis_column;\n+    auto & group_expression = kql_make_series.group_expression;\n+    auto step = from_to_step.step;\n+\n+    if (!kql_make_series.from_to_step.from_str.empty())\n+        start_str = getExprFromToken(kql_make_series.from_to_step.from_str, max_depth);\n+\n+    if (!kql_make_series.from_to_step.to_str.empty())\n+        end_str = getExprFromToken(from_to_step.to_str, max_depth);\n+\n+    auto date_type_cast = [&](String & src)\n+    {\n+        Tokens tokens(src.c_str(), src.c_str() + src.size());\n+        IParser::Pos pos(tokens, max_depth);\n+        String res;\n+        while (!pos->isEnd())\n+        {\n+            String tmp = String(pos->begin, pos->end);\n+            if (tmp == \"parseDateTime64BestEffortOrNull\")\n+                tmp = \"toDateTime64\";\n+\n+            res = res.empty() ? tmp : res + \" \" + tmp;\n+            ++pos;\n+        }\n+        return res;\n+    };\n+\n+    start_str = date_type_cast(start_str);\n+    end_str = date_type_cast(end_str);\n+\n+    String bin_str, start, end;\n+\n+    uint64_t diff = 0;\n+    String axis_column_format;\n+    String axis_str;\n+\n+    auto get_group_expression_alias = [&]\n+    {\n+        std::vector<String> group_expression_tokens;\n+        Tokens tokens(group_expression.c_str(), group_expression.c_str() + group_expression.size());\n+        IParser::Pos pos(tokens, max_depth);\n+        while (!pos->isEnd())\n+        {\n+            if (String(pos->begin, pos->end) == \"AS\")\n+            {\n+                if (!group_expression_tokens.empty())\n+                    group_expression_tokens.pop_back();\n+                ++pos;\n+                group_expression_tokens.push_back(String(pos->begin, pos->end));\n+            }\n+            else\n+                group_expression_tokens.push_back(String(pos->begin, pos->end));\n+            ++pos;\n+        }\n+        String res;\n+        for (auto const & token : group_expression_tokens)\n+            res = res + token + \" \";\n+        return res;\n+    };\n+\n+    auto group_expression_alias = get_group_expression_alias();\n+\n+    if (from_to_step.is_timespan)\n+    {\n+        axis_column_format = std::format(\"toFloat64(toDateTime64({}, 9, 'UTC'))\", axis_column);\n+    }\n+    else\n+        axis_column_format = std::format(\"toFloat64({})\", axis_column);\n+\n+    if (!start_str.empty()) // has from\n+    {\n+        bin_str = std::format(\n+            \"toFloat64({0}) + (toInt64((({1} - toFloat64({0})) / {2})) * {2}) AS {3}_ali\",\n+            start_str,\n+            axis_column_format,\n+            step,\n+            axis_column);\n+        start = std::format(\"toUInt64({})\", start_str);\n+    }\n+    else\n+    {\n+        if (from_to_step.is_timespan)\n+            diff = era_diff;\n+        bin_str = std::format(\" toFloat64(toInt64(({0} + {1}) / {2}) * {2}) AS {3}_ali \", axis_column_format, diff, step, axis_column);\n+    }\n+\n+    if (!end_str.empty())\n+        end = std::format(\"toUInt64({})\", end_str);\n+\n+    String range, condition;\n+\n+    if (!start_str.empty() && !end_str.empty())\n+    {\n+        range = std::format(\"range({}, {}, toUInt64({}))\", start, end, step);\n+        condition = std::format(\"where toInt64({0}) >= {1} and toInt64({0}) < {2}\", axis_column_format, start, end);\n+    }\n+    else if (start_str.empty() && !end_str.empty())\n+    {\n+        range = std::format(\"range(low, {} + {}, toUInt64({}))\", end, diff, step);\n+        condition = std::format(\"where toInt64({0}) - {1} < {2}\", axis_column_format, diff, end);\n+    }\n+    else if (!start_str.empty() && end_str.empty())\n+    {\n+        range = std::format(\"range({}, high, toUInt64({}))\", start, step);\n+        condition = std::format(\"where toInt64({}) >= {}\", axis_column_format, start);\n+    }\n+    else\n+    {\n+        range = std::format(\"range(low, high, toUInt64({}))\", step);\n+        condition = \" \";\n+    }\n+\n+    auto range_len = std::format(\"length({})\", range);\n+\n+    String sub_sub_query;\n+    if (group_expression.empty())\n+        sub_sub_query = std::format(\n+            \" (Select {0}, {1} FROM {2} {4} GROUP BY  {3}_ali ORDER BY {3}_ali) \",\n+            subquery_columns,\n+            bin_str,\n+            \"table_name\",\n+            axis_column,\n+            condition);\n+    else\n+        sub_sub_query = std::format(\n+            \" (Select {0}, {1}, {2} FROM {3} {5} GROUP BY {0}, {4}_ali ORDER BY {4}_ali) \",\n+            group_expression,\n+            subquery_columns,\n+            bin_str,\n+            \"table_name\",\n+            axis_column,\n+            condition);\n+\n+    ASTPtr sub_query_node;\n+\n+    if (!ParserSimpleCHSubquery(select_node).parseByString(sub_sub_query, sub_query_node, max_depth))\n+        return false;\n+    select_node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::TABLES, std::move(sub_query_node));\n+\n+    if (!group_expression.empty())\n+        main_query = std::format(\"{} \", group_expression_alias);\n+\n+    auto axis_and_agg_alias_list = axis_column;\n+    auto final_axis_agg_alias_list = std::format(\"tupleElement(zipped,1) AS {}\", axis_column);\n+    int idx = 2;\n+    for (auto agg_column : aggregation_columns)\n+    {\n+        String agg_group_column = std::format(\n+            \"arrayConcat(groupArray({}_ali) as ga, arrayMap(x -> ({}),range(0, toUInt32({} - length(ga) < 0 ? 0 : {} - length(ga)),1)))\"\n+            \"as {}\",\n+            agg_column.alias,\n+            agg_column.default_value,\n+            range_len,\n+            range_len,\n+            agg_column.alias);\n+        main_query = main_query.empty() ? agg_group_column : main_query + \", \" + agg_group_column;\n+\n+        axis_and_agg_alias_list += \", \" + agg_column.alias;\n+        final_axis_agg_alias_list += std::format(\", tupleElement(zipped,{}) AS {}\", idx, agg_column.alias);\n+    }\n+\n+    if (from_to_step.is_timespan)\n+        axis_str = std::format(\n+            \"arrayDistinct(arrayConcat(groupArray(toDateTime64({0}_ali - {1},9,'UTC')), arrayMap(x->(toDateTime64(x - {1} ,9,'UTC')),\"\n+            \"{2}))) as {0}\",\n+            axis_column,\n+            diff,\n+            range);\n+    else\n+        axis_str\n+            = std::format(\"arrayDistinct(arrayConcat(groupArray({0}_ali), arrayMap(x->(toFloat64(x)), {1}))) as {0}\", axis_column, range);\n+\n+    main_query += \", \" + axis_str;\n+    auto sub_group_by = group_expression.empty() ? \"\" : std::format(\"GROUP BY {}\", group_expression_alias);\n+\n+    sub_query = std::format(\n+        \"( SELECT toUInt64(min({}_ali)) AS low, toUInt64(max({}_ali))+ {} AS high, arraySort(arrayZip({})) as zipped, {} FROM {} {} )\",\n+        axis_column,\n+        axis_column,\n+        step,\n+        axis_and_agg_alias_list,\n+        main_query,\n+        sub_sub_query,\n+        sub_group_by);\n+\n+    if (group_expression.empty())\n+        main_query = std::format(\"{}\", final_axis_agg_alias_list);\n+    else\n+        main_query = std::format(\"{},{}\", group_expression_alias, final_axis_agg_alias_list);\n+\n+    if (!ParserSimpleCHSubquery(select_node).parseByString(sub_query, sub_query_node, max_depth))\n+        return false;\n+    select_node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::TABLES, std::move(sub_query_node));\n+\n+    kql_make_series.sub_query = std::move(sub_query);\n+    kql_make_series.main_query = std::move(main_query);\n+\n+    return true;\n+}\n+\n+bool ParserKQLMakeSeries ::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    auto begin = pos;\n+    ParserKeyword s_on(\"on\");\n+    ParserKeyword s_by(\"by\");\n+\n+    ParserToken equals(TokenType::Equals);\n+    ParserToken comma(TokenType::Comma);\n+\n+    ASTPtr select_expression_list;\n+\n+    KQLMakeSeries kql_make_series;\n+    auto & aggregation_columns = kql_make_series.aggregation_columns;\n+    auto & from_to_step = kql_make_series.from_to_step;\n+    auto & subquery_columns = kql_make_series.subquery_columns;\n+    auto & axis_column = kql_make_series.axis_column;\n+    auto & group_expression = kql_make_series.group_expression;\n+\n+    ParserKQLDateTypeTimespan time_span;\n+\n+    //const auto make_series_parameters = getMakeSeriesParameters(pos);\n+\n+    if (!parseAggregationColumns(aggregation_columns, pos))\n+        return false;\n+\n+    if (!s_on.ignore(pos, expected))\n+        return false;\n+\n+    axis_column = String(pos->begin, pos->end);\n+    ++pos;\n+\n+    if (!parseFromToStepClause(from_to_step, pos))\n+        return false;\n+\n+    if (s_by.ignore(pos, expected))\n+    {\n+        group_expression = getExprFromToken(pos);\n+        if (group_expression.empty())\n+            return false;\n+    }\n+\n+    for (auto agg_column : aggregation_columns)\n+    {\n+        String column_str = std::format(\"{}({}) AS {}_ali\", agg_column.aggregation_fun, agg_column.column, agg_column.alias);\n+        if (subquery_columns.empty())\n+            subquery_columns = column_str;\n+        else\n+            subquery_columns += \", \" + column_str;\n+    }\n+\n+    makeSeries(kql_make_series, node, pos.max_depth);\n+\n+    Tokens token_main_query(kql_make_series.main_query.c_str(), kql_make_series.main_query.c_str() + kql_make_series.main_query.size());\n+    IParser::Pos pos_main_query(token_main_query, pos.max_depth);\n+\n+    if (!ParserNotEmptyExpressionList(true).parse(pos_main_query, select_expression_list, expected))\n+        return false;\n+    node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::SELECT, std::move(select_expression_list));\n+\n+    pos = begin;\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLMakeSeries.h b/src/Parsers/Kusto/ParserKQLMakeSeries.h\nnew file mode 100644\nindex 000000000000..ef7cc4976f66\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLMakeSeries.h\n@@ -0,0 +1,53 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+class ParserKQLMakeSeries : public ParserKQLBase\n+{\n+protected:\n+    struct AggregationColumn\n+    {\n+        String alias;\n+        String aggregation_fun;\n+        String column;\n+        double default_value;\n+        AggregationColumn(String alias_, String aggregation_fun_, String column_, double default_value_)\n+            : alias(alias_), aggregation_fun(aggregation_fun_), column(column_), default_value(default_value_)\n+        {\n+        }\n+    };\n+    using AggregationColumns = std::vector<AggregationColumn>;\n+\n+    struct FromToStepClause\n+    {\n+        String from_str;\n+        String to_str;\n+        String step_str;\n+        bool is_timespan = false;\n+        double step;\n+    };\n+\n+    struct KQLMakeSeries\n+    {\n+        AggregationColumns aggregation_columns;\n+        FromToStepClause from_to_step;\n+        String axis_column;\n+        String group_expression;\n+        String subquery_columns;\n+        String sub_query;\n+        String main_query;\n+    };\n+\n+    static bool makeSeries(KQLMakeSeries & kql_make_series, ASTPtr & select_node, const uint32_t & max_depth);\n+    static bool parseAggregationColumns(AggregationColumns & aggregation_columns, Pos & pos);\n+    static bool parseFromToStepClause(FromToStepClause & from_to_step, Pos & pos);\n+\n+    const char * getName() const override { return \"KQL make-series\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLOperators.cpp b/src/Parsers/Kusto/ParserKQLOperators.cpp\nindex 1575cffcc394..17b9bd74d0b8 100644\n--- a/src/Parsers/Kusto/ParserKQLOperators.cpp\n+++ b/src/Parsers/Kusto/ParserKQLOperators.cpp\n@@ -1,9 +1,131 @@\n #include <Parsers/ASTLiteral.h>\n-#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/CommonParsers.h>\n+#include <Parsers/Kusto/KustoFunctions/IParserKQLFunction.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h>\n #include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n #include <Parsers/Kusto/ParserKQLStatement.h>\n-#include <Parsers/CommonParsers.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/formatAST.h>\n+#include \"KustoFunctions/IParserKQLFunction.h\"\n+\n+namespace\n+{\n+\n+enum class KQLOperatorValue : uint16_t\n+{\n+    none,\n+    between,\n+    not_between,\n+    contains,\n+    not_contains,\n+    contains_cs,\n+    not_contains_cs,\n+    endswith,\n+    not_endswith,\n+    endswith_cs,\n+    not_endswith_cs,\n+    equal, //=~\n+    not_equal, //!~\n+    equal_cs, //=\n+    not_equal_cs, //!=\n+    has,\n+    not_has,\n+    has_all,\n+    has_any,\n+    has_cs,\n+    not_has_cs,\n+    hasprefix,\n+    not_hasprefix,\n+    hasprefix_cs,\n+    not_hasprefix_cs,\n+    hassuffix,\n+    not_hassuffix,\n+    hassuffix_cs,\n+    not_hassuffix_cs,\n+    in_cs, //in\n+    not_in_cs, //!in\n+    in, //in~\n+    not_in, //!in~\n+    matches_regex,\n+    startswith,\n+    not_startswith,\n+    startswith_cs,\n+    not_startswith_cs,\n+};\n+\n+const std::unordered_map<String, KQLOperatorValue> KQLOperator = {\n+    {\"between\", KQLOperatorValue::between},\n+    {\"!between\", KQLOperatorValue::not_between},\n+    {\"contains\", KQLOperatorValue::contains},\n+    {\"!contains\", KQLOperatorValue::not_contains},\n+    {\"contains_cs\", KQLOperatorValue::contains_cs},\n+    {\"!contains_cs\", KQLOperatorValue::not_contains_cs},\n+    {\"endswith\", KQLOperatorValue::endswith},\n+    {\"!endswith\", KQLOperatorValue::not_endswith},\n+    {\"endswith_cs\", KQLOperatorValue::endswith_cs},\n+    {\"!endswith_cs\", KQLOperatorValue::not_endswith_cs},\n+    {\"=~\", KQLOperatorValue::equal},\n+    {\"!~\", KQLOperatorValue::not_equal},\n+    {\"==\", KQLOperatorValue::equal_cs},\n+    {\"!=\", KQLOperatorValue::not_equal_cs},\n+    {\"has\", KQLOperatorValue::has},\n+    {\"!has\", KQLOperatorValue::not_has},\n+    {\"has_all\", KQLOperatorValue::has_all},\n+    {\"has_any\", KQLOperatorValue::has_any},\n+    {\"has_cs\", KQLOperatorValue::has_cs},\n+    {\"!has_cs\", KQLOperatorValue::not_has_cs},\n+    {\"hasprefix\", KQLOperatorValue::hasprefix},\n+    {\"!hasprefix\", KQLOperatorValue::not_hasprefix},\n+    {\"hasprefix_cs\", KQLOperatorValue::hasprefix_cs},\n+    {\"!hasprefix_cs\", KQLOperatorValue::not_hasprefix_cs},\n+    {\"hassuffix\", KQLOperatorValue::hassuffix},\n+    {\"!hassuffix\", KQLOperatorValue::not_hassuffix},\n+    {\"hassuffix_cs\", KQLOperatorValue::hassuffix_cs},\n+    {\"!hassuffix_cs\", KQLOperatorValue::not_hassuffix_cs},\n+    {\"in\", KQLOperatorValue::in_cs},\n+    {\"!in\", KQLOperatorValue::not_in_cs},\n+    {\"in~\", KQLOperatorValue::in},\n+    {\"!in~\", KQLOperatorValue::not_in},\n+    {\"matches regex\", KQLOperatorValue::matches_regex},\n+    {\"startswith\", KQLOperatorValue::startswith},\n+    {\"!startswith\", KQLOperatorValue::not_startswith},\n+    {\"startswith_cs\", KQLOperatorValue::startswith_cs},\n+    {\"!startswith_cs\", KQLOperatorValue::not_startswith_cs},\n+};\n+\n+void rebuildSubqueryForInOperator(DB::ASTPtr & node, bool useLowerCase)\n+{\n+    //A sub-query for in operator in kql can have multiple columns, but only takes the first column.\n+    //A sub-query for in operator in ClickHouse can not have multiple columns\n+    //So only take the first column if there are multiple columns.\n+    //select * not working for subquery. (a tabular statement without project)\n+\n+    const auto selectColumns = node->children[0]->children[0]->as<DB::ASTSelectQuery>()->select();\n+    while (selectColumns->children.size() > 1)\n+        selectColumns->children.pop_back();\n+\n+    if (useLowerCase)\n+    {\n+        auto args = std::make_shared<DB::ASTExpressionList>();\n+        args->children.push_back(selectColumns->children[0]);\n+        auto func_lower = std::make_shared<DB::ASTFunction>();\n+        func_lower->name = \"lower\";\n+        func_lower->children.push_back(selectColumns->children[0]);\n+        func_lower->arguments = args;\n+        if (selectColumns->children[0]->as<DB::ASTIdentifier>())\n+            func_lower->alias = std::move(selectColumns->children[0]->as<DB::ASTIdentifier>()->alias);\n+        else if (selectColumns->children[0]->as<DB::ASTFunction>())\n+            func_lower->alias = std::move(selectColumns->children[0]->as<DB::ASTFunction>()->alias);\n+\n+        auto funcs = std::make_shared<DB::ASTExpressionList>();\n+        funcs->children.push_back(func_lower);\n+        selectColumns->children[0] = std::move(funcs);\n+    }\n+}\n \n+}\n namespace DB\n {\n \n@@ -12,7 +134,7 @@ namespace ErrorCodes\n     extern const int SYNTAX_ERROR;\n }\n \n-String KQLOperators::genHasAnyAllOpExpr(std::vector<String> &tokens, IParser::Pos &token_pos,String kql_op, String ch_op)\n+String KQLOperators::genHasAnyAllOpExpr(std::vector<String> & tokens, IParser::Pos & token_pos, String kql_op, String ch_op)\n {\n     String new_expr;\n     Expected expected;\n@@ -28,7 +150,7 @@ String KQLOperators::genHasAnyAllOpExpr(std::vector<String> &tokens, IParser::Po\n \n     while (!token_pos->isEnd() && token_pos->type != TokenType::PipeMark && token_pos->type != TokenType::Semicolon)\n     {\n-        auto tmp_arg = String(token_pos->begin, token_pos->end);\n+        auto tmp_arg = IParserKQLFunction::getExpression(token_pos);\n         if (token_pos->type == TokenType::Comma)\n             new_expr = new_expr + logic_op;\n         else\n@@ -37,33 +159,114 @@ String KQLOperators::genHasAnyAllOpExpr(std::vector<String> &tokens, IParser::Po\n         ++token_pos;\n         if (token_pos->type == TokenType::ClosingRoundBracket)\n             break;\n-\n     }\n \n     tokens.pop_back();\n     return new_expr;\n }\n \n-String KQLOperators::genInOpExpr(IParser::Pos &token_pos, String kql_op, String ch_op)\n+String genEqOpExprCis(std::vector<String> & tokens, DB::IParser::Pos & token_pos, const DB::String & ch_op)\n {\n-    String new_expr;\n+    DB::String tmp_arg(token_pos->begin, token_pos->end);\n \n-    ParserToken s_lparen(TokenType::OpeningRoundBracket);\n+    if (tokens.empty() || tmp_arg != \"~\")\n+        return tmp_arg;\n \n-    ASTPtr select;\n-    Expected expected;\n+    DB::String new_expr;\n+    new_expr += \"lower(\" + tokens.back() + \")\" + \" \";\n+    new_expr += ch_op + \" \";\n+    ++token_pos;\n+\n+    if (token_pos->type == DB::TokenType::StringLiteral || token_pos->type == DB::TokenType::QuotedIdentifier)\n+        new_expr += \"lower('\" + DB::IParserKQLFunction::escapeSingleQuotes(String(token_pos->begin + 1, token_pos->end - 1)) + \"')\";\n+    else\n+        new_expr += \"lower(\" + DB::IParserKQLFunction::getExpression(token_pos) + \")\";\n+\n+    tokens.pop_back();\n+    return new_expr;\n+}\n+\n+String genInOpExprCis(std::vector<String> & tokens, DB::IParser::Pos & token_pos, const DB::String & kql_op, const DB::String & ch_op)\n+{\n+    DB::ParserKQLTableFunction kqlfun_p;\n+    DB::ParserToken s_lparen(DB::TokenType::OpeningRoundBracket);\n+\n+    DB::ASTPtr select;\n+    DB::Expected expected;\n+    DB::String new_expr;\n \n     ++token_pos;\n     if (!s_lparen.ignore(token_pos, expected))\n-        throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near {}\", kql_op);\n+        throw DB::Exception(DB::ErrorCodes::SYNTAX_ERROR, \"Syntax error near {}\", kql_op);\n+\n+    if (tokens.empty())\n+        throw DB::Exception(DB::ErrorCodes::SYNTAX_ERROR, \"Syntax error near {}\", kql_op);\n+\n+    new_expr = \"lower(\" + tokens.back() + \") \";\n+    tokens.pop_back();\n+    auto pos = token_pos;\n+    if (kqlfun_p.parse(pos, select, expected))\n+    {\n+        rebuildSubqueryForInOperator(select, true);\n+        new_expr += ch_op + \" (\" + serializeAST(*select) + \")\";\n+        token_pos = pos;\n+        return new_expr;\n+    }\n \n     --token_pos;\n     --token_pos;\n-    return ch_op;\n \n+    new_expr += ch_op;\n+    while (!token_pos->isEnd() && token_pos->type != DB::TokenType::PipeMark && token_pos->type != DB::TokenType::Semicolon)\n+    {\n+        auto tmp_arg = DB::String(token_pos->begin, token_pos->end);\n+        if (token_pos->type != DB::TokenType::Comma && token_pos->type != DB::TokenType::ClosingRoundBracket\n+            && token_pos->type != DB::TokenType::OpeningRoundBracket && token_pos->type != DB::TokenType::OpeningSquareBracket\n+            && token_pos->type != DB::TokenType::ClosingSquareBracket && tmp_arg != \"~\" && tmp_arg != \"dynamic\")\n+        {\n+            if (token_pos->type == DB::TokenType::StringLiteral || token_pos->type == DB::TokenType::QuotedIdentifier)\n+                new_expr += \"lower('\" + DB::IParserKQLFunction::escapeSingleQuotes(String(token_pos->begin + 1, token_pos->end - 1)) + \"')\";\n+            else\n+                new_expr += \"lower(\" + tmp_arg + \")\";\n+        }\n+        else if (tmp_arg != \"~\" && tmp_arg != \"dynamic\" && tmp_arg != \"[\" && tmp_arg != \"]\")\n+            new_expr += tmp_arg;\n+\n+        if (token_pos->type == DB::TokenType::ClosingRoundBracket)\n+            break;\n+        ++token_pos;\n+    }\n+    return new_expr;\n+}\n+\n+std::string genInOpExpr(DB::IParser::Pos & token_pos, const std::string & kql_op, const std::string & ch_op)\n+{\n+    DB::ParserKQLTableFunction kqlfun_p;\n+    DB::ParserToken s_lparen(DB::TokenType::OpeningRoundBracket);\n+\n+    DB::ASTPtr select;\n+    DB::Expected expected;\n+\n+    ++token_pos;\n+    if (!s_lparen.ignore(token_pos, expected))\n+        throw DB::Exception(DB::ErrorCodes::SYNTAX_ERROR, \"Syntax error near {}\", kql_op);\n+\n+    auto pos = token_pos;\n+    if (kqlfun_p.parse(pos, select, expected))\n+    {\n+        rebuildSubqueryForInOperator(select, false);\n+        auto new_expr = ch_op + \" (\" + serializeAST(*select) + \")\";\n+        token_pos = pos;\n+        return new_expr;\n+    }\n+\n+    --token_pos;\n+    --token_pos;\n+    return ch_op;\n }\n \n-String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos &token_pos,String kql_op, String ch_op, WildcardsPos wildcards_pos, WildcardsPos space_pos)\n+String KQLOperators::genHaystackOpExpr(\n+    std::vector<String> & tokens, IParser::Pos & token_pos, String kql_op, String ch_op, WildcardsPos wildcards_pos, WildcardsPos space_pos)\n {\n     String new_expr, left_wildcards, right_wildcards, left_space, right_space;\n \n@@ -73,7 +276,7 @@ String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos\n             break;\n \n         case WildcardsPos::left:\n-            left_wildcards =\"%\";\n+            left_wildcards = \"%\";\n             break;\n \n         case WildcardsPos::right:\n@@ -81,7 +284,7 @@ String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos\n             break;\n \n         case WildcardsPos::both:\n-            left_wildcards =\"%\";\n+            left_wildcards = \"%\";\n             right_wildcards = \"%\";\n             break;\n     }\n@@ -92,7 +295,7 @@ String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos\n             break;\n \n         case WildcardsPos::left:\n-            left_space =\" \";\n+            left_space = \" \";\n             break;\n \n         case WildcardsPos::right:\n@@ -100,7 +303,7 @@ String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos\n             break;\n \n         case WildcardsPos::both:\n-            left_space =\" \";\n+            left_space = \" \";\n             right_space = \" \";\n             break;\n     }\n@@ -108,11 +311,13 @@ String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos\n     ++token_pos;\n \n     if (!tokens.empty() && ((token_pos)->type == TokenType::StringLiteral || token_pos->type == TokenType::QuotedIdentifier))\n-        new_expr = ch_op +\"(\" + tokens.back() +\", '\"+left_wildcards + left_space + String(token_pos->begin + 1,token_pos->end - 1) + right_space + right_wildcards + \"')\";\n+        new_expr = ch_op + \"(\" + tokens.back() + \", '\" + left_wildcards + left_space + String(token_pos->begin + 1, token_pos->end - 1)\n+            + right_space + right_wildcards + \"')\";\n     else if (!tokens.empty() && ((token_pos)->type == TokenType::BareWord))\n     {\n-        auto tmp_arg = String(token_pos->begin, token_pos->end);\n-        new_expr = ch_op +\"(\" + tokens.back() +\", concat('\" + left_wildcards + left_space + \"', \" + tmp_arg +\", '\"+ right_space + right_wildcards + \"'))\";\n+        auto tmp_arg = IParserKQLFunction::getExpression(token_pos);\n+        new_expr = ch_op + \"(\" + tokens.back() + \", concat('\" + left_wildcards + left_space + \"', \" + tmp_arg + \", '\" + right_space\n+            + right_wildcards + \"'))\";\n     }\n     else\n         throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near {}\", kql_op);\n@@ -120,7 +325,7 @@ String KQLOperators::genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos\n     return new_expr;\n }\n \n-bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n+bool KQLOperators::convert(std::vector<String> & tokens, IParser::Pos & pos)\n {\n     auto begin = pos;\n \n@@ -128,7 +333,7 @@ bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n     {\n         KQLOperatorValue op_value = KQLOperatorValue::none;\n \n-        auto token =  String(pos->begin,pos->end);\n+        auto token = String(pos->begin, pos->end);\n \n         String op = token;\n         if (token == \"!\")\n@@ -136,15 +341,15 @@ bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n             ++pos;\n             if (pos->isEnd() || pos->type == TokenType::PipeMark || pos->type == TokenType::Semicolon)\n                 throw Exception(ErrorCodes::SYNTAX_ERROR, \"Invalid negative operator\");\n-            op =\"!\"+String(pos->begin,pos->end);\n+            op = \"!\" + String(pos->begin, pos->end);\n         }\n         else if (token == \"matches\")\n         {\n             ++pos;\n             if (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n             {\n-                if (String(pos->begin,pos->end) == \"regex\")\n-                    op +=\" regex\";\n+                if (String(pos->begin, pos->end) == \"regex\")\n+                    op += \" regex\";\n                 else\n                     --pos;\n             }\n@@ -157,8 +362,8 @@ bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n         ++pos;\n         if (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n         {\n-            if (String(pos->begin,pos->end) == \"~\")\n-                op +=\"~\";\n+            if (String(pos->begin, pos->end) == \"~\")\n+                op += \"~\";\n             else\n                 --pos;\n         }\n@@ -171,7 +376,7 @@ bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n             return false;\n         }\n \n-        op_value = KQLOperator[op];\n+        op_value = KQLOperator.at(op);\n \n         String new_expr;\n \n@@ -179,172 +384,179 @@ bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n             tokens.push_back(op);\n         else\n         {\n+            if (tokens.empty())\n+                throw Exception(ErrorCodes::SYNTAX_ERROR, \"Syntax error near {}\", op);\n+\n             auto last_op = tokens.back();\n             auto last_pos = pos;\n \n             switch (op_value)\n             {\n-            case KQLOperatorValue::contains:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::both);\n-                break;\n-\n-            case KQLOperatorValue::not_contains:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::both);\n-                break;\n-\n-            case KQLOperatorValue::contains_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"like\", WildcardsPos::both);\n-                break;\n-\n-            case KQLOperatorValue::not_contains_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not like\", WildcardsPos::both);\n-                break;\n-\n-            case KQLOperatorValue::endswith:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::left);\n-                break;\n-\n-            case KQLOperatorValue::not_endswith:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::left);\n-                break;\n-\n-            case KQLOperatorValue::endswith_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"endsWith\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::not_endswith_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not endsWith\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::equal:\n-                break;\n-\n-            case KQLOperatorValue::not_equal:\n-                break;\n-\n-            case KQLOperatorValue::equal_cs:\n-                new_expr = \"==\";\n-                break;\n-\n-            case KQLOperatorValue::not_equal_cs:\n-                new_expr = \"!=\";\n-                break;\n-            case KQLOperatorValue::has:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"hasTokenCaseInsensitive\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::not_has:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not hasTokenCaseInsensitive\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::has_all:\n-                new_expr = genHasAnyAllOpExpr(tokens, pos, \"has_all\", \"hasTokenCaseInsensitive\");\n-                break;\n-\n-            case KQLOperatorValue::has_any:\n-                new_expr = genHasAnyAllOpExpr(tokens, pos, \"has_any\", \"hasTokenCaseInsensitive\");\n-                break;\n-\n-            case KQLOperatorValue::has_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"hasToken\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::not_has_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not hasToken\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::hasprefix:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::right);\n-                new_expr += \" or \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"ilike\", WildcardsPos::both, WildcardsPos::left);\n-                break;\n-\n-            case KQLOperatorValue::not_hasprefix:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::right);\n-                new_expr += \" and \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not ilike\", WildcardsPos::both, WildcardsPos::left);\n-                break;\n-\n-            case KQLOperatorValue::hasprefix_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"startsWith\", WildcardsPos::none);\n-                new_expr += \" or \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"like\", WildcardsPos::both, WildcardsPos::left);\n-                break;\n-\n-            case KQLOperatorValue::not_hasprefix_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not startsWith\", WildcardsPos::none);\n-                new_expr += \" and  \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not like\", WildcardsPos::both, WildcardsPos::left);\n-                break;\n-\n-            case KQLOperatorValue::hassuffix:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::left);\n-                new_expr += \" or \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"ilike\", WildcardsPos::both, WildcardsPos::right);\n-                break;\n-\n-            case KQLOperatorValue::not_hassuffix:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::left);\n-                new_expr += \" and \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not ilike\", WildcardsPos::both, WildcardsPos::right);\n-                break;\n-\n-            case KQLOperatorValue::hassuffix_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"endsWith\", WildcardsPos::none);\n-                new_expr += \" or \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"like\", WildcardsPos::both, WildcardsPos::right);\n-                break;\n-\n-            case KQLOperatorValue::not_hassuffix_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not endsWith\", WildcardsPos::none);\n-                new_expr += \" and  \";\n-                tokens.push_back(last_op);\n-                new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not like\", WildcardsPos::both, WildcardsPos::right);\n-                break;\n-\n-            case KQLOperatorValue::in_cs:\n-                new_expr = genInOpExpr(pos,op,\"in\");\n-                break;\n-\n-            case KQLOperatorValue::not_in_cs:\n-                new_expr = genInOpExpr(pos,op,\"not in\");\n-                break;\n-\n-            case KQLOperatorValue::in:\n-                break;\n-\n-            case KQLOperatorValue::not_in:\n-                break;\n-\n-            case KQLOperatorValue::matches_regex:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"match\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::startswith:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::right);\n-                break;\n-\n-            case KQLOperatorValue::not_startswith:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::right);\n-                break;\n-\n-            case KQLOperatorValue::startswith_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"startsWith\", WildcardsPos::none);\n-                break;\n-\n-            case KQLOperatorValue::not_startswith_cs:\n-                new_expr = genHaystackOpExpr(tokens, pos, op, \"not startsWith\", WildcardsPos::none);\n-                break;\n-\n-            default:\n-                break;\n+                case KQLOperatorValue::contains:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::both);\n+                    break;\n+\n+                case KQLOperatorValue::not_contains:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::both);\n+                    break;\n+\n+                case KQLOperatorValue::contains_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"like\", WildcardsPos::both);\n+                    break;\n+\n+                case KQLOperatorValue::not_contains_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not like\", WildcardsPos::both);\n+                    break;\n+\n+                case KQLOperatorValue::endswith:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::left);\n+                    break;\n+\n+                case KQLOperatorValue::not_endswith:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::left);\n+                    break;\n+\n+                case KQLOperatorValue::endswith_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"endsWith\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::not_endswith_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not endsWith\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::equal:\n+                    new_expr = genEqOpExprCis(tokens, pos, \"==\");\n+                    break;\n+\n+                case KQLOperatorValue::not_equal:\n+                    new_expr = genEqOpExprCis(tokens, pos, \"!=\");\n+                    break;\n+\n+                case KQLOperatorValue::equal_cs:\n+                    new_expr = \"==\";\n+                    break;\n+\n+                case KQLOperatorValue::not_equal_cs:\n+                    new_expr = \"!=\";\n+                    break;\n+                case KQLOperatorValue::has:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"hasTokenCaseInsensitive\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::not_has:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not hasTokenCaseInsensitive\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::has_all:\n+                    new_expr = genHasAnyAllOpExpr(tokens, pos, \"has_all\", \"hasTokenCaseInsensitive\");\n+                    break;\n+\n+                case KQLOperatorValue::has_any:\n+                    new_expr = genHasAnyAllOpExpr(tokens, pos, \"has_any\", \"hasTokenCaseInsensitive\");\n+                    break;\n+\n+                case KQLOperatorValue::has_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"hasToken\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::not_has_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not hasToken\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::hasprefix:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::right);\n+                    new_expr += \" or \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"ilike\", WildcardsPos::both, WildcardsPos::left);\n+                    break;\n+\n+                case KQLOperatorValue::not_hasprefix:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::right);\n+                    new_expr += \" and \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not ilike\", WildcardsPos::both, WildcardsPos::left);\n+                    break;\n+\n+                case KQLOperatorValue::hasprefix_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"startsWith\", WildcardsPos::none);\n+                    new_expr += \" or \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"like\", WildcardsPos::both, WildcardsPos::left);\n+                    break;\n+\n+                case KQLOperatorValue::not_hasprefix_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not startsWith\", WildcardsPos::none);\n+                    new_expr += \" and  \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not like\", WildcardsPos::both, WildcardsPos::left);\n+                    break;\n+\n+                case KQLOperatorValue::hassuffix:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::left);\n+                    new_expr += \" or \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"ilike\", WildcardsPos::both, WildcardsPos::right);\n+                    break;\n+\n+                case KQLOperatorValue::not_hassuffix:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::left);\n+                    new_expr += \" and \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not ilike\", WildcardsPos::both, WildcardsPos::right);\n+                    break;\n+\n+                case KQLOperatorValue::hassuffix_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"endsWith\", WildcardsPos::none);\n+                    new_expr += \" or \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"like\", WildcardsPos::both, WildcardsPos::right);\n+                    break;\n+\n+                case KQLOperatorValue::not_hassuffix_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not endsWith\", WildcardsPos::none);\n+                    new_expr += \" and  \";\n+                    tokens.push_back(last_op);\n+                    new_expr += genHaystackOpExpr(tokens, last_pos, op, \"not like\", WildcardsPos::both, WildcardsPos::right);\n+                    break;\n+\n+                case KQLOperatorValue::in_cs:\n+                    new_expr = genInOpExpr(pos, op, \"in\");\n+                    break;\n+\n+                case KQLOperatorValue::not_in_cs:\n+                    new_expr = genInOpExpr(pos, op, \"not in\");\n+                    break;\n+\n+                case KQLOperatorValue::in:\n+                    new_expr = genInOpExprCis(tokens, pos, op, \"in\");\n+                    break;\n+\n+                case KQLOperatorValue::not_in:\n+                    new_expr = genInOpExprCis(tokens, pos, op, \"not in\");\n+                    break;\n+\n+                case KQLOperatorValue::matches_regex:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"match\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::startswith:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"ilike\", WildcardsPos::right);\n+                    break;\n+\n+                case KQLOperatorValue::not_startswith:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not ilike\", WildcardsPos::right);\n+                    break;\n+\n+                case KQLOperatorValue::startswith_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"startsWith\", WildcardsPos::none);\n+                    break;\n+\n+                case KQLOperatorValue::not_startswith_cs:\n+                    new_expr = genHaystackOpExpr(tokens, pos, op, \"not startsWith\", WildcardsPos::none);\n+                    break;\n+\n+                default:\n+                    break;\n             }\n \n             tokens.push_back(new_expr);\n@@ -356,4 +568,3 @@ bool KQLOperators::convert(std::vector<String> &tokens,IParser::Pos &pos)\n }\n \n }\n-\ndiff --git a/src/Parsers/Kusto/ParserKQLOperators.h b/src/Parsers/Kusto/ParserKQLOperators.h\nindex 72e25cc3cf90..2b11976ef7b8 100644\n--- a/src/Parsers/Kusto/ParserKQLOperators.h\n+++ b/src/Parsers/Kusto/ParserKQLOperators.h\n@@ -1,18 +1,18 @@\n #pragma once\n \n+#include <unordered_map>\n #include <Parsers/IParserBase.h>\n #include <Parsers/Kusto/ParserKQLQuery.h>\n-#include <unordered_map>\n namespace DB\n {\n \n class KQLOperators\n {\n public:\n-    bool convert(std::vector<String> &tokens,IParser::Pos &pos);\n-protected:\n+    static bool convert(std::vector<String> & tokens, IParser::Pos & pos);\n \n-    enum class WildcardsPos:uint8_t\n+protected:\n+    enum class WildcardsPos : uint8_t\n     {\n         none,\n         left,\n@@ -20,87 +20,14 @@ class KQLOperators\n         both\n     };\n \n-    enum class KQLOperatorValue : uint16_t\n-    {\n-        none,\n-        contains,\n-        not_contains,\n-        contains_cs,\n-        not_contains_cs,\n-        endswith,\n-        not_endswith,\n-        endswith_cs,\n-        not_endswith_cs,\n-        equal, /// =~\n-        not_equal, /// !~\n-        equal_cs, /// =\n-        not_equal_cs, /// !=\n-        has,\n-        not_has,\n-        has_all,\n-        has_any,\n-        has_cs,\n-        not_has_cs,\n-        hasprefix,\n-        not_hasprefix,\n-        hasprefix_cs,\n-        not_hasprefix_cs,\n-        hassuffix,\n-        not_hassuffix,\n-        hassuffix_cs,\n-        not_hassuffix_cs,\n-        in_cs, /// in\n-        not_in_cs, /// !in\n-        in, /// in~\n-        not_in, /// !in~\n-        matches_regex,\n-        startswith,\n-        not_startswith,\n-        startswith_cs,\n-        not_startswith_cs,\n-    };\n-\n-    std::unordered_map <String,KQLOperatorValue> KQLOperator =\n-    {\n-        {\"contains\" , KQLOperatorValue::contains},\n-        {\"!contains\" , KQLOperatorValue::not_contains},\n-        {\"contains_cs\" , KQLOperatorValue::contains_cs},\n-        {\"!contains_cs\" , KQLOperatorValue::not_contains_cs},\n-        {\"endswith\" , KQLOperatorValue::endswith},\n-        {\"!endswith\" , KQLOperatorValue::not_endswith},\n-        {\"endswith_cs\" , KQLOperatorValue::endswith_cs},\n-        {\"!endswith_cs\" , KQLOperatorValue::not_endswith_cs},\n-        {\"=~\" , KQLOperatorValue::equal},\n-        {\"!~\" , KQLOperatorValue::not_equal},\n-        {\"==\" , KQLOperatorValue::equal_cs},\n-        {\"!=\" , KQLOperatorValue::not_equal_cs},\n-        {\"has\" , KQLOperatorValue::has},\n-        {\"!has\" , KQLOperatorValue::not_has},\n-        {\"has_all\" , KQLOperatorValue::has_all},\n-        {\"has_any\" , KQLOperatorValue::has_any},\n-        {\"has_cs\" , KQLOperatorValue::has_cs},\n-        {\"!has_cs\" , KQLOperatorValue::not_has_cs},\n-        {\"hasprefix\" , KQLOperatorValue::hasprefix},\n-        {\"!hasprefix\" , KQLOperatorValue::not_hasprefix},\n-        {\"hasprefix_cs\" , KQLOperatorValue::hasprefix_cs},\n-        {\"!hasprefix_cs\" , KQLOperatorValue::not_hasprefix_cs},\n-        {\"hassuffix\" , KQLOperatorValue::hassuffix},\n-        {\"!hassuffix\" , KQLOperatorValue::not_hassuffix},\n-        {\"hassuffix_cs\" , KQLOperatorValue::hassuffix_cs},\n-        {\"!hassuffix_cs\" , KQLOperatorValue::not_hassuffix_cs},\n-        {\"in\" , KQLOperatorValue::in_cs},\n-        {\"!in\" , KQLOperatorValue::not_in_cs},\n-        {\"in~\" , KQLOperatorValue::in},\n-        {\"!in~\" , KQLOperatorValue::not_in},\n-        {\"matches regex\" , KQLOperatorValue::matches_regex},\n-        {\"startswith\" , KQLOperatorValue::startswith},\n-        {\"!startswith\" , KQLOperatorValue::not_startswith},\n-        {\"startswith_cs\" , KQLOperatorValue::startswith_cs},\n-        {\"!startswith_cs\" , KQLOperatorValue::not_startswith_cs},\n-    };\n-    static String genHaystackOpExpr(std::vector<String> &tokens,IParser::Pos &token_pos,String kql_op, String ch_op, WildcardsPos wildcards_pos, WildcardsPos space_pos = WildcardsPos::none);\n-    static String genInOpExpr(IParser::Pos &token_pos,String kql_op, String ch_op);\n-    static String genHasAnyAllOpExpr(std::vector<String> &tokens,IParser::Pos &token_pos,String kql_op, String ch_op);\n+    static String genHaystackOpExpr(\n+        std::vector<String> & tokens,\n+        IParser::Pos & token_pos,\n+        String kql_op,\n+        String ch_op,\n+        WildcardsPos wildcards_pos,\n+        WildcardsPos space_pos = WildcardsPos::none);\n+    static String genHasAnyAllOpExpr(std::vector<String> & tokens, IParser::Pos & token_pos, String kql_op, String ch_op);\n };\n \n }\ndiff --git a/src/Parsers/Kusto/ParserKQLPrint.cpp b/src/Parsers/Kusto/ParserKQLPrint.cpp\nnew file mode 100644\nindex 000000000000..bd9980ea96df\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLPrint.cpp\n@@ -0,0 +1,22 @@\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/Kusto/ParserKQLPrint.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+namespace DB\n+{\n+\n+bool ParserKQLPrint::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr select_expression_list;\n+    const String expr = getExprFromToken(pos);\n+\n+    Tokens tokens(expr.c_str(), expr.c_str() + expr.size());\n+    IParser::Pos new_pos(tokens, pos.max_depth);\n+\n+    if (!ParserNotEmptyExpressionList(true).parse(new_pos, select_expression_list, expected))\n+        return false;\n+    node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::SELECT, std::move(select_expression_list));\n+\n+    return true;\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLPrint.h b/src/Parsers/Kusto/ParserKQLPrint.h\nnew file mode 100644\nindex 000000000000..c962d7fa4282\n--- /dev/null\n+++ b/src/Parsers/Kusto/ParserKQLPrint.h\n@@ -0,0 +1,16 @@\n+#pragma once\n+\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+class ParserKQLPrint : public ParserKQLBase\n+{\n+protected:\n+    const char * getName() const override { return \"KQL project\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+}\ndiff --git a/src/Parsers/Kusto/ParserKQLProject.cpp b/src/Parsers/Kusto/ParserKQLProject.cpp\nindex e978323d8215..fdc458b77078 100644\n--- a/src/Parsers/Kusto/ParserKQLProject.cpp\n+++ b/src/Parsers/Kusto/ParserKQLProject.cpp\n@@ -1,20 +1,20 @@\n #include <Parsers/ExpressionListParsers.h>\n-#include <Parsers/Kusto/ParserKQLQuery.h>\n #include <Parsers/Kusto/ParserKQLProject.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n namespace DB\n {\n \n-bool ParserKQLProject :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLProject ::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr select_expression_list;\n     String expr;\n \n     expr = getExprFromToken(pos);\n \n-    Tokens tokens(expr.c_str(), expr.c_str()+expr.size());\n+    Tokens tokens(expr.c_str(), expr.c_str() + expr.size());\n     IParser::Pos new_pos(tokens, pos.max_depth);\n \n-    if (!ParserNotEmptyExpressionList(true).parse(new_pos, select_expression_list, expected))\n+    if (!ParserNotEmptyExpressionList(false).parse(new_pos, select_expression_list, expected))\n         return false;\n \n     node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::SELECT, std::move(select_expression_list));\ndiff --git a/src/Parsers/Kusto/ParserKQLQuery.cpp b/src/Parsers/Kusto/ParserKQLQuery.cpp\nindex 04ee36705a9a..479869436622 100644\n--- a/src/Parsers/Kusto/ParserKQLQuery.cpp\n+++ b/src/Parsers/Kusto/ParserKQLQuery.cpp\n@@ -1,24 +1,124 @@\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/ASTSubquery.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/CommonParsers.h>\n #include <Parsers/IParserBase.h>\n-#include <Parsers/Kusto/ParserKQLQuery.h>\n-#include <Parsers/Kusto/ParserKQLTable.h>\n-#include <Parsers/Kusto/ParserKQLProject.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h>\n+#include <Parsers/Kusto/ParserKQLDistinct.h>\n+#include <Parsers/Kusto/ParserKQLExtend.h>\n #include <Parsers/Kusto/ParserKQLFilter.h>\n-#include <Parsers/Kusto/ParserKQLSort.h>\n-#include <Parsers/Kusto/ParserKQLSummarize.h>\n #include <Parsers/Kusto/ParserKQLLimit.h>\n-#include <Parsers/Kusto/ParserKQLStatement.h>\n-#include <Parsers/CommonParsers.h>\n-#include <format>\n-#include <Parsers/ASTTablesInSelectQuery.h>\n-#include <Parsers/ASTSubquery.h>\n+#include <Parsers/Kusto/ParserKQLMVExpand.h>\n+#include <Parsers/Kusto/ParserKQLMakeSeries.h>\n #include <Parsers/Kusto/ParserKQLOperators.h>\n+#include <Parsers/Kusto/ParserKQLPrint.h>\n+#include <Parsers/Kusto/ParserKQLProject.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/Kusto/ParserKQLSort.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/Kusto/ParserKQLSummarize.h>\n+#include <Parsers/Kusto/ParserKQLTable.h>\n+#include <Parsers/ParserSelectWithUnionQuery.h>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n \n+#include <format>\n namespace DB\n {\n \n-String ParserKQLBase :: getExprFromToken(const String & text, const uint32_t & max_depth)\n+namespace ErrorCodes\n+{\n+    extern const int SYNTAX_ERROR;\n+}\n+\n+bool ParserKQLBase::parseByString(const String expr, ASTPtr & node, const uint32_t max_depth)\n+{\n+    Expected expected;\n+\n+    Tokens tokens(expr.c_str(), expr.c_str() + expr.size());\n+    IParser::Pos pos(tokens, max_depth);\n+    return parse(pos, node, expected);\n+}\n+\n+bool ParserKQLBase::parseSQLQueryByString(ParserPtr && parser, String & query, ASTPtr & select_node, int32_t max_depth)\n+{\n+    Expected expected;\n+    Tokens token_subquery(query.c_str(), query.c_str() + query.size());\n+    IParser::Pos pos_subquery(token_subquery, max_depth);\n+    if (!parser->parse(pos_subquery, select_node, expected))\n+        return false;\n+    return true;\n+};\n+\n+bool ParserKQLBase::setSubQuerySource(ASTPtr & select_query, ASTPtr & source, bool dest_is_subquery, bool src_is_subquery)\n+{\n+    ASTPtr table_expr;\n+    if (!dest_is_subquery)\n+    {\n+        if (!select_query || !select_query->as<ASTSelectQuery>()->tables()\n+            || select_query->as<ASTSelectQuery>()->tables()->as<ASTTablesInSelectQuery>()->children.empty())\n+            return false;\n+        table_expr = select_query->as<ASTSelectQuery>()->tables()->as<ASTTablesInSelectQuery>()->children[0];\n+        table_expr->as<ASTTablesInSelectQueryElement>()->table_expression\n+            = source->as<ASTSelectQuery>()->tables()->children[0]->as<ASTTablesInSelectQueryElement>()->table_expression;\n+        return true;\n+    }\n+\n+    if (!select_query || select_query->as<ASTTablesInSelectQuery>()->children.empty()\n+        || !select_query->as<ASTTablesInSelectQuery>()->children[0]->as<ASTTablesInSelectQueryElement>()->table_expression\n+        || select_query->as<ASTTablesInSelectQuery>()\n+               ->children[0]\n+               ->as<ASTTablesInSelectQueryElement>()\n+               ->table_expression->as<ASTTableExpression>()\n+               ->subquery->children.empty()\n+        || select_query->as<ASTTablesInSelectQuery>()\n+               ->children[0]\n+               ->as<ASTTablesInSelectQueryElement>()\n+               ->table_expression->as<ASTTableExpression>()\n+               ->subquery->children[0]\n+               ->as<ASTSelectWithUnionQuery>()\n+               ->list_of_selects->children.empty()\n+        || select_query->as<ASTTablesInSelectQuery>()\n+               ->children[0]\n+               ->as<ASTTablesInSelectQueryElement>()\n+               ->table_expression->as<ASTTableExpression>()\n+               ->subquery->children[0]\n+               ->as<ASTSelectWithUnionQuery>()\n+               ->list_of_selects->children[0]\n+               ->as<ASTSelectQuery>()\n+               ->tables()\n+               ->as<ASTTablesInSelectQuery>()\n+               ->children.empty())\n+        return false;\n+\n+    table_expr = select_query->as<ASTTablesInSelectQuery>()\n+                     ->children[0]\n+                     ->as<ASTTablesInSelectQueryElement>()\n+                     ->table_expression->as<ASTTableExpression>()\n+                     ->subquery->children[0]\n+                     ->as<ASTSelectWithUnionQuery>()\n+                     ->list_of_selects->children[0]\n+                     ->as<ASTSelectQuery>()\n+                     ->tables()\n+                     ->as<ASTTablesInSelectQuery>()\n+                     ->children[0];\n+\n+    if (!src_is_subquery)\n+    {\n+        table_expr->as<ASTTablesInSelectQueryElement>()->table_expression\n+            = source->as<ASTSelectQuery>()->tables()->children[0]->as<ASTTablesInSelectQueryElement>()->table_expression;\n+    }\n+    else\n+    {\n+        table_expr->as<ASTTablesInSelectQueryElement>()->table_expression\n+            = source->children[0]->as<ASTTablesInSelectQueryElement>()->table_expression;\n+    }\n+\n+    return true;\n+}\n+\n+String ParserKQLBase::getExprFromToken(const String & text, const uint32_t max_depth)\n {\n     Tokens tokens(text.c_str(), text.c_str() + text.size());\n     IParser::Pos pos(tokens, max_depth);\n@@ -26,72 +126,179 @@ String ParserKQLBase :: getExprFromToken(const String & text, const uint32_t & m\n     return getExprFromToken(pos);\n }\n \n-String ParserKQLBase :: getExprFromPipe(Pos & pos)\n+String ParserKQLBase::getExprFromPipe(Pos & pos)\n {\n-    uint16_t bracket_count = 0;\n-    auto begin = pos;\n+    BracketCount bracket_count;\n     auto end = pos;\n     while (!end->isEnd() && end->type != TokenType::Semicolon)\n     {\n-        if (end->type == TokenType::OpeningRoundBracket)\n-            ++bracket_count;\n-\n-        if (end->type == TokenType::OpeningRoundBracket)\n-            --bracket_count;\n-\n-        if (end->type == TokenType::PipeMark && bracket_count == 0)\n+        bracket_count.count(end);\n+        if (end->type == TokenType::PipeMark && bracket_count.isZero())\n             break;\n \n         ++end;\n     }\n-    --end;\n-    return String(begin->begin, end->end);\n+    if (end != pos)\n+        --end;\n+    return (pos <= end) ? String(pos->begin, end->end) : \"\";\n }\n \n-String ParserKQLBase :: getExprFromToken(Pos & pos)\n+String ParserKQLBase::getExprFromToken(Pos & pos)\n {\n-    String res;\n-    std::vector<String> tokens;\n-    String alias;\n+    std::vector<Pos> comma_pos;\n+    comma_pos.push_back(pos);\n \n-    while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n+    size_t paren_count = 0;\n+    while (!pos->isEnd() && pos->type != TokenType::Semicolon)\n     {\n-        String token = String(pos->begin,pos->end);\n+        if (pos->type == TokenType::PipeMark && paren_count == 0)\n+            break;\n \n-        if (token == \"=\")\n+        if (pos->type == TokenType::OpeningRoundBracket)\n+            ++paren_count;\n+        if (pos->type == TokenType::ClosingRoundBracket)\n+            --paren_count;\n+\n+        if (pos->type == TokenType::Comma && paren_count == 0)\n         {\n             ++pos;\n-            if (String(pos->begin,pos->end) != \"~\")\n+            comma_pos.push_back(pos);\n+            --pos;\n+        }\n+        ++pos;\n+    }\n+\n+    std::vector<String> columns;\n+    auto set_columns = [&](Pos & start_pos, Pos & end_pos)\n+    {\n+        bool has_alias = false;\n+        auto equal_pos = start_pos;\n+        auto columms_start_pos = start_pos;\n+        auto it_pos = start_pos;\n+        if (String(it_pos->begin, it_pos->end) == \"=\")\n+            throw Exception(ErrorCodes::SYNTAX_ERROR, \"Invalid equal symbol (=)\");\n+\n+        BracketCount bracket_count;\n+        while (it_pos < end_pos)\n+        {\n+            bracket_count.count(it_pos);\n+            if (String(it_pos->begin, it_pos->end) == \"=\")\n             {\n-                alias = tokens.back();\n-                tokens.pop_back();\n+                ++it_pos;\n+                if (String(it_pos->begin, it_pos->end) != \"~\" && bracket_count.isZero())\n+                {\n+                    if (has_alias)\n+                        throw Exception(ErrorCodes::SYNTAX_ERROR, \"Invalid equal symbol (=)\");\n+                    has_alias = true;\n+                }\n+\n+                --it_pos;\n+                if (equal_pos == start_pos)\n+                    equal_pos = it_pos;\n             }\n-            --pos;\n+            ++it_pos;\n         }\n-        else if (!KQLOperators().convert(tokens,pos))\n+\n+        if (has_alias)\n         {\n-            tokens.push_back(token);\n+            columms_start_pos = equal_pos;\n+            ++columms_start_pos;\n         }\n+        String column_str;\n+        String function_name;\n+        std::vector<String> tokens;\n \n-        if (pos->type == TokenType::Comma && !alias.empty())\n+        while (columms_start_pos < end_pos)\n         {\n-            tokens.pop_back();\n-            tokens.push_back(\"AS\");\n-            tokens.push_back(alias);\n-            tokens.push_back(\",\");\n-            alias.clear();\n+            if (!KQLOperators::convert(tokens, columms_start_pos))\n+            {\n+                if (columms_start_pos->type == TokenType::BareWord && function_name.empty())\n+                    function_name = String(columms_start_pos->begin, columms_start_pos->end);\n+\n+                auto expr = IParserKQLFunction::getExpression(columms_start_pos);\n+                tokens.push_back(expr);\n+            }\n+            ++columms_start_pos;\n         }\n-        ++pos;\n-    }\n \n-    if (!alias.empty())\n+        for (const auto & token : tokens)\n+            column_str = column_str.empty() ? token : column_str + \" \" + token;\n+\n+        if (has_alias)\n+        {\n+            --equal_pos;\n+            if (start_pos == equal_pos)\n+            {\n+                String new_column_str;\n+                if (start_pos->type != TokenType::BareWord)\n+                    throw Exception(\n+                        ErrorCodes::SYNTAX_ERROR, \"{} is not a valid alias\", std::string_view(start_pos->begin, start_pos->end));\n+\n+                if (function_name == \"array_sort_asc\" || function_name == \"array_sort_desc\")\n+                    new_column_str = std::format(\"{0}[1] AS {1}\", column_str, String(start_pos->begin, start_pos->end));\n+                else\n+                    new_column_str = std::format(\"{0} AS {1}\", column_str, String(start_pos->begin, start_pos->end));\n+\n+                columns.push_back(new_column_str);\n+            }\n+            else\n+            {\n+                String whole_alias(start_pos->begin, equal_pos->end);\n+\n+                if (function_name != \"array_sort_asc\" && function_name != \"array_sort_desc\")\n+                    throw Exception(ErrorCodes::SYNTAX_ERROR, \"{} is not a valid alias\", whole_alias);\n+\n+                if (start_pos->type != TokenType::OpeningRoundBracket && equal_pos->type != TokenType::ClosingRoundBracket)\n+                    throw Exception(ErrorCodes::SYNTAX_ERROR, \"{} is not a valid alias for {}\", whole_alias, function_name);\n+\n+                String alias_inside;\n+                bool comma_meet = false;\n+                size_t index = 1;\n+                ++start_pos;\n+                while (start_pos < equal_pos)\n+                {\n+                    if (start_pos->type == TokenType::Comma)\n+                    {\n+                        alias_inside.clear();\n+                        if (comma_meet)\n+                            throw Exception(ErrorCodes::SYNTAX_ERROR, \"{} has invalid alias for {}\", whole_alias, function_name);\n+                        comma_meet = true;\n+                    }\n+                    else\n+                    {\n+                        if (!alias_inside.empty() || start_pos->type != TokenType::BareWord)\n+                            throw Exception(ErrorCodes::SYNTAX_ERROR, \"{} has invalid alias for {}\", whole_alias, function_name);\n+\n+                        alias_inside = String(start_pos->begin, start_pos->end);\n+                        auto new_column_str = std::format(\"{0}[{1}] AS {2}\", column_str, index, alias_inside);\n+                        columns.push_back(new_column_str);\n+                        comma_meet = false;\n+                        ++index;\n+                    }\n+                    ++start_pos;\n+                }\n+            }\n+        }\n+        else\n+            columns.push_back(column_str);\n+    };\n+\n+    size_t cloumn_size = comma_pos.size();\n+    for (size_t i = 0; i < cloumn_size; ++i)\n     {\n-        tokens.push_back(\"AS\");\n-        tokens.push_back(alias);\n+        if (i == cloumn_size - 1)\n+            set_columns(comma_pos[i], pos);\n+        else\n+        {\n+            auto end_pos = comma_pos[i + 1];\n+            --end_pos;\n+            set_columns(comma_pos[i], end_pos);\n+        }\n     }\n \n-    for (auto const &token : tokens)\n-        res = res.empty()? token : res +\" \" + token;\n+    String res;\n+    for (const auto & token : columns)\n+        res = res.empty() ? token : res + \",\" + token;\n     return res;\n }\n \n@@ -103,12 +310,22 @@ std::unique_ptr<IParserBase> ParserKQLQuery::getOperator(String & op_name)\n         return std::make_unique<ParserKQLLimit>();\n     else if (op_name == \"project\")\n         return std::make_unique<ParserKQLProject>();\n+    else if (op_name == \"distinct\")\n+        return std::make_unique<ParserKQLDistinct>();\n+    else if (op_name == \"extend\")\n+        return std::make_unique<ParserKQLExtend>();\n     else if (op_name == \"sort by\" || op_name == \"order by\")\n         return std::make_unique<ParserKQLSort>();\n     else if (op_name == \"summarize\")\n         return std::make_unique<ParserKQLSummarize>();\n     else if (op_name == \"table\")\n         return std::make_unique<ParserKQLTable>();\n+    else if (op_name == \"make-series\")\n+        return std::make_unique<ParserKQLMakeSeries>();\n+    else if (op_name == \"mv-expand\")\n+        return std::make_unique<ParserKQLMVExpand>();\n+    else if (op_name == \"print\")\n+        return std::make_unique<ParserKQLPrint>();\n     else\n         return nullptr;\n }\n@@ -127,49 +344,78 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     node = select_query;\n     ASTPtr tables;\n \n-    std::unordered_map<std::string, KQLOperatorDataFlowState> kql_parser =\n-    {\n-        { \"filter\", {\"filter\", false, false, 3}},\n-        { \"where\", {\"filter\", false, false, 3}},\n-        { \"limit\", {\"limit\", false, true, 3}},\n-        { \"take\", {\"limit\", false, true, 3}},\n-        { \"project\", {\"project\", false, false, 3}},\n-        { \"sort by\", {\"order by\", false, false, 4}},\n-        { \"order by\", {\"order by\", false, false, 4}},\n-        { \"table\", {\"table\", false, false, 3}},\n-        { \"summarize\", {\"summarize\", true, true, 3}}\n-    };\n+    std::unordered_map<std::string, KQLOperatorDataFlowState> kql_parser\n+        = {{\"filter\", {\"filter\", false, false, 3}},\n+           {\"where\", {\"filter\", false, false, 3}},\n+           {\"limit\", {\"limit\", false, true, 3}},\n+           {\"take\", {\"limit\", false, true, 3}},\n+           {\"project\", {\"project\", false, false, 3}},\n+           {\"distinct\", {\"distinct\", false, true, 3}},\n+           {\"extend\", {\"extend\", true, true, 3}},\n+           {\"sort by\", {\"order by\", false, false, 4}},\n+           {\"order by\", {\"order by\", false, false, 4}},\n+           {\"table\", {\"table\", false, false, 3}},\n+           {\"print\", {\"print\", false, true, 3}},\n+           {\"summarize\", {\"summarize\", true, true, 3}},\n+           {\"make-series\", {\"make-series\", true, true, 5}},\n+           {\"mv-expand\", {\"mv-expand\", true, true, 5}}};\n \n     std::vector<std::pair<String, Pos>> operation_pos;\n \n     String table_name(pos->begin, pos->end);\n \n-    operation_pos.push_back(std::make_pair(\"table\", pos));\n+    if (table_name == \"print\")\n+        operation_pos.emplace_back(table_name, pos);\n+    else\n+        operation_pos.emplace_back(\"table\", pos);\n+\n     ++pos;\n+\n     uint16_t bracket_count = 0;\n \n     while (!pos->isEnd() && pos->type != TokenType::Semicolon)\n     {\n         if (pos->type == TokenType::OpeningRoundBracket)\n             ++bracket_count;\n-        if (pos->type == TokenType::OpeningRoundBracket)\n+        if (pos->type == TokenType::ClosingRoundBracket)\n             --bracket_count;\n \n         if (pos->type == TokenType::PipeMark && bracket_count == 0)\n         {\n             ++pos;\n             String kql_operator(pos->begin, pos->end);\n-            if (kql_operator == \"order\" || kql_operator == \"sort\")\n+\n+            auto validate_kql_operator = [&]\n             {\n-                ++pos;\n-                ParserKeyword s_by(\"by\");\n-                if (s_by.ignore(pos,expected))\n+                if (kql_operator == \"order\" || kql_operator == \"sort\")\n                 {\n-                    kql_operator = \"order by\";\n-                    --pos;\n+                    ++pos;\n+                    ParserKeyword s_by(\"by\");\n+                    if (s_by.ignore(pos, expected))\n+                    {\n+                        kql_operator = \"order by\";\n+                        --pos;\n+                    }\n                 }\n-            }\n-            if (pos->type != TokenType::BareWord || kql_parser.find(kql_operator) == kql_parser.end())\n+                else\n+                {\n+                    auto op_pos_begin = pos;\n+                    ++pos;\n+                    ParserToken s_dash(TokenType::Minus);\n+                    if (s_dash.ignore(pos, expected))\n+                    {\n+                        String tmp_op(op_pos_begin->begin, pos->end);\n+                        kql_operator = tmp_op;\n+                    }\n+                    else\n+                        --pos;\n+                }\n+                if (kql_parser.find(kql_operator) == kql_parser.end())\n+                    return false;\n+                return true;\n+            };\n+\n+            if (!validate_kql_operator())\n                 return false;\n             ++pos;\n             operation_pos.push_back(std::make_pair(kql_operator, pos));\n@@ -190,16 +436,27 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n     if (operation_pos.size() == 1)\n     {\n-        if (!kql_operator_p->parse(npos, node, expected))\n-            return false;\n+        if (kql_operator_str == \"print\")\n+        {\n+            ++npos;\n+            if (!ParserKQLPrint().parse(npos, node, expected))\n+                return false;\n+        }\n+        else if (kql_operator_str == \"table\")\n+        {\n+            if (!kql_operator_p->parse(npos, node, expected))\n+                return false;\n+        }\n     }\n     else if (operation_pos.size() == 2 && operation_pos.front().first == \"table\")\n     {\n-        if (!kql_operator_p->parse(npos, node, expected))\n-            return false;\n         npos = operation_pos.front().second;\n         if (!ParserKQLTable().parse(npos, node, expected))\n             return false;\n+\n+        npos = operation_pos.back().second;\n+        if (!kql_operator_p->parse(npos, node, expected))\n+            return false;\n     }\n     else\n     {\n@@ -207,7 +464,7 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         auto last_pos = operation_pos.back().second;\n         auto last_op = operation_pos.back().first;\n \n-        auto set_main_query_clause =[&](String & op, Pos & op_pos)\n+        auto set_main_query_clause = [&](const String & op, Pos & op_pos)\n         {\n             auto op_str = ParserKQLBase::getExprFromPipe(op_pos);\n             if (op == \"project\")\n@@ -224,12 +481,7 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n         operation_pos.pop_back();\n \n-        if (kql_parser[last_op].need_input)\n-        {\n-            if (!kql_operator_p->parse(npos, node, expected))\n-                return false;\n-        }\n-        else\n+        if (!kql_parser[last_op].need_input)\n         {\n             while (!operation_pos.empty())\n             {\n@@ -240,6 +492,7 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n                     break;\n                 if (!project_clause.empty() && prev_op == \"project\")\n                     break;\n+\n                 set_main_query_clause(prev_op, prev_pos);\n                 operation_pos.pop_back();\n                 last_op = prev_op;\n@@ -249,7 +502,7 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n         if (!operation_pos.empty())\n         {\n-            for (auto i = 0; i< kql_parser[last_op].backspace_steps; ++i)\n+            for (auto i = 0; i < kql_parser[last_op].backspace_steps; ++i)\n                 --last_pos;\n \n             String sub_query = std::format(\"({})\", String(operation_pos.front().second->begin, last_pos->end));\n@@ -266,7 +519,10 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n                 return false;\n         }\n \n-        auto set_query_clasue =[&](String op_str, String op_calsue)\n+        if (!kql_operator_p->parse(npos, node, expected))\n+            return false;\n+\n+        auto set_query_clasue = [&](String op_str, String op_calsue)\n         {\n             auto oprator = getOperator(op_str);\n             if (oprator)\n@@ -279,7 +535,7 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             return true;\n         };\n \n-        if (!select_query->select())\n+        if (!node->as<ASTSelectQuery>()->select())\n         {\n             if (project_clause.empty())\n                 project_clause = \"*\";\n@@ -301,23 +557,23 @@ bool ParserKQLQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return true;\n     }\n \n-    if (!select_query->select())\n+    if (!node->as<ASTSelectQuery>()->select())\n     {\n         auto expr = String(\"*\");\n-        Tokens tokens(expr.c_str(), expr.c_str()+expr.size());\n+        Tokens tokens(expr.c_str(), expr.c_str() + expr.size());\n         IParser::Pos new_pos(tokens, pos.max_depth);\n         if (!std::make_unique<ParserKQLProject>()->parse(new_pos, node, expected))\n             return false;\n     }\n \n-     return true;\n+    return true;\n }\n \n bool ParserKQLSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr select_node;\n \n-    if (!ParserKQLTaleFunction().parse(pos, select_node, expected))\n+    if (!ParserKQLTableFunction().parse(pos, select_node, expected))\n         return false;\n \n     ASTPtr node_subquery = std::make_shared<ASTSubquery>();\n@@ -339,4 +595,46 @@ bool ParserKQLSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     return true;\n }\n \n+bool ParserSimpleCHSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr sub_select_node;\n+    ParserSelectWithUnionQuery select;\n+\n+    if (pos->type != TokenType::OpeningRoundBracket)\n+        return false;\n+    ++pos;\n+\n+    if (!select.parse(pos, sub_select_node, expected))\n+        return false;\n+\n+    if (pos->type != TokenType::ClosingRoundBracket)\n+        return false;\n+    ++pos;\n+\n+    if (parent_select_node && parent_select_node->as<ASTSelectQuery>()->tables())\n+    {\n+        auto select_query = sub_select_node->as<ASTSelectWithUnionQuery>()->list_of_selects->children[0];\n+        select_query->as<ASTSelectQuery>()->setExpression(\n+            ASTSelectQuery::Expression::TABLES, parent_select_node->as<ASTSelectQuery>()->tables());\n+    }\n+\n+    ASTPtr node_subquery = std::make_shared<ASTSubquery>();\n+    node_subquery->children.push_back(sub_select_node);\n+\n+    ASTPtr node_table_expr = std::make_shared<ASTTableExpression>();\n+    node_table_expr->as<ASTTableExpression>()->subquery = node_subquery;\n+\n+    node_table_expr->children.emplace_back(node_subquery);\n+\n+    ASTPtr node_table_in_select_query_emlement = std::make_shared<ASTTablesInSelectQueryElement>();\n+    node_table_in_select_query_emlement->as<ASTTablesInSelectQueryElement>()->table_expression = node_table_expr;\n+\n+    ASTPtr res = std::make_shared<ASTTablesInSelectQuery>();\n+\n+    res->children.emplace_back(node_table_in_select_query_emlement);\n+\n+    node = res;\n+    return true;\n+}\n+\n }\ndiff --git a/src/Parsers/Kusto/ParserKQLQuery.h b/src/Parsers/Kusto/ParserKQLQuery.h\nindex 42f5f84f0317..516acb09dead 100644\n--- a/src/Parsers/Kusto/ParserKQLQuery.h\n+++ b/src/Parsers/Kusto/ParserKQLQuery.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n-#include <Parsers/IParserBase.h>\n #include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/IParserBase.h>\n \n namespace DB\n {\n@@ -9,24 +9,57 @@ class ParserKQLBase : public IParserBase\n {\n public:\n     static String getExprFromToken(Pos & pos);\n+    static String getExprFromToken(const String & text, const uint32_t max_depth);\n     static String getExprFromPipe(Pos & pos);\n-    static String getExprFromToken(const String & text, const uint32_t & max_depth);\n+    static bool setSubQuerySource(ASTPtr & select_query, ASTPtr & source, bool dest_is_subquery, bool src_is_subquery);\n+    static bool parseSQLQueryByString(ParserPtr && parser, String & query, ASTPtr & select_node, int32_t max_depth);\n+    bool parseByString(const String expr, ASTPtr & node, const uint32_t max_depth);\n };\n \n class ParserKQLQuery : public IParserBase\n {\n-\n protected:\n-    static std::unique_ptr<IParserBase> getOperator(String &op_name);\n+    static std::unique_ptr<IParserBase> getOperator(String & op_name);\n     const char * getName() const override { return \"KQL query\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n-class ParserKQLSubquery : public IParserBase\n+class ParserKQLSubquery : public ParserKQLBase\n {\n protected:\n     const char * getName() const override { return \"KQL subquery\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n+class ParserSimpleCHSubquery : public ParserKQLBase\n+{\n+public:\n+    ParserSimpleCHSubquery(ASTPtr parent_select_node_ = nullptr) { parent_select_node = parent_select_node_; }\n+\n+protected:\n+    const char * getName() const override { return \"Simple ClickHouse subquery\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+    ASTPtr parent_select_node;\n+};\n+\n+class BracketCount\n+{\n+public:\n+    void count(IParser::Pos & pos)\n+    {\n+        if (pos->type == TokenType::OpeningRoundBracket)\n+            ++round_bracket_count;\n+        if (pos->type == TokenType::ClosingRoundBracket)\n+            --round_bracket_count;\n+        if (pos->type == TokenType::OpeningSquareBracket)\n+            ++square_bracket_count;\n+        if (pos->type == TokenType::ClosingSquareBracket)\n+            --square_bracket_count;\n+    }\n+    bool isZero() const { return round_bracket_count == 0 && square_bracket_count == 0; }\n+\n+private:\n+    int16_t round_bracket_count = 0;\n+    int16_t square_bracket_count = 0;\n+};\n }\ndiff --git a/src/Parsers/Kusto/ParserKQLSort.cpp b/src/Parsers/Kusto/ParserKQLSort.cpp\nindex ef4b84b17c78..193b75567aae 100644\n--- a/src/Parsers/Kusto/ParserKQLSort.cpp\n+++ b/src/Parsers/Kusto/ParserKQLSort.cpp\n@@ -1,17 +1,17 @@\n #include <Parsers/ASTLiteral.h>\n-#include <Parsers/IParserBase.h>\n-#include <Parsers/ExpressionListParsers.h>\n #include <Parsers/ASTOrderByElement.h>\n+#include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/IParserBase.h>\n #include <Parsers/Kusto/ParserKQLQuery.h>\n #include <Parsers/Kusto/ParserKQLSort.h>\n \n namespace DB\n {\n \n-bool ParserKQLSort :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLSort::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     bool has_dir = false;\n-    std::vector <bool> has_directions;\n+    std::vector<bool> has_directions;\n     ParserOrderByExpressionList order_list;\n     ASTPtr order_expression_list;\n \n@@ -35,6 +35,7 @@ bool ParserKQLSort :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n             has_directions.push_back(has_dir);\n             has_dir = false;\n         }\n+\n         ++new_pos;\n     }\n     has_directions.push_back(has_dir);\n@@ -43,7 +44,7 @@ bool ParserKQLSort :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         if (!has_directions[i])\n         {\n-            auto *order_expr =  order_expression_list->children[i]->as<ASTOrderByElement>();\n+            auto * order_expr = order_expression_list->children[i]->as<ASTOrderByElement>();\n             order_expr->direction = -1; // default desc\n             if (!order_expr->nulls_direction_was_explicitly_specified)\n                 order_expr->nulls_direction = -1;\n@@ -53,7 +54,6 @@ bool ParserKQLSort :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     }\n \n     node->as<ASTSelectQuery>()->setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(order_expression_list));\n-\n     return true;\n }\n \ndiff --git a/src/Parsers/Kusto/ParserKQLStatement.cpp b/src/Parsers/Kusto/ParserKQLStatement.cpp\nindex 21e480234d39..f61e2e99ffb0 100644\n--- a/src/Parsers/Kusto/ParserKQLStatement.cpp\n+++ b/src/Parsers/Kusto/ParserKQLStatement.cpp\n@@ -1,10 +1,11 @@\n-#include <Parsers/IParserBase.h>\n-#include <Parsers/ParserSetQuery.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/CommonParsers.h>\n+#include <Parsers/IParserBase.h>\n+#include <Parsers/Kusto/KustoFunctions/KQLFunctionFactory.h>\n #include <Parsers/Kusto/ParserKQLQuery.h>\n #include <Parsers/Kusto/ParserKQLStatement.h>\n-#include <Parsers/CommonParsers.h>\n+#include <Parsers/ParserSetQuery.h>\n \n namespace DB\n {\n@@ -14,8 +15,7 @@ bool ParserKQLStatement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected\n     ParserKQLWithOutput query_with_output_p(end, allow_settings_after_format_in_insert);\n     ParserSetQuery set_p;\n \n-    bool res = query_with_output_p.parse(pos, node, expected)\n-        || set_p.parse(pos, node, expected);\n+    bool res = query_with_output_p.parse(pos, node, expected) || set_p.parse(pos, node, expected);\n \n     return res;\n }\n@@ -36,6 +36,7 @@ bool ParserKQLWithOutput::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n \n bool ParserKQLWithUnionQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n+    // will support union next phase\n     ASTPtr kql_query;\n \n     if (!ParserKQLQuery().parse(pos, kql_query, expected))\n@@ -58,33 +59,40 @@ bool ParserKQLWithUnionQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & exp\n     return true;\n }\n \n-bool ParserKQLTaleFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLTableFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ParserKQLWithUnionQuery kql_p;\n     ASTPtr select;\n     ParserToken s_lparen(TokenType::OpeningRoundBracket);\n \n     auto begin = pos;\n-    auto paren_count = 0 ;\n+    auto paren_count = 0;\n     String kql_statement;\n \n     if (s_lparen.ignore(pos, expected))\n     {\n-        ++paren_count;\n-        while (!pos->isEnd())\n+        if (pos->type == TokenType::HereDoc)\n         {\n-            if (pos->type == TokenType::ClosingRoundBracket)\n-                --paren_count;\n-            if (pos->type == TokenType::OpeningRoundBracket)\n-                ++paren_count;\n-\n-            if (paren_count == 0)\n-                break;\n-\n-            kql_statement = kql_statement + \" \" + String(pos->begin,pos->end);\n-            ++pos;\n+            kql_statement = String(pos->begin + 2, pos->end - 2);\n         }\n-\n+        else\n+        {\n+            ++paren_count;\n+            auto pos_start = pos;\n+            while (!pos->isEnd())\n+            {\n+                if (pos->type == TokenType::ClosingRoundBracket)\n+                    --paren_count;\n+                if (pos->type == TokenType::OpeningRoundBracket)\n+                    ++paren_count;\n+\n+                if (paren_count == 0)\n+                    break;\n+                ++pos;\n+            }\n+            kql_statement = String(pos_start->begin, (--pos)->end);\n+        }\n+        ++pos;\n         Tokens token_kql(kql_statement.c_str(), kql_statement.c_str() + kql_statement.size());\n         IParser::Pos pos_kql(token_kql, pos.max_depth);\n \n@@ -95,8 +103,7 @@ bool ParserKQLTaleFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n             return true;\n         }\n     }\n-    pos =  begin;\n+    pos = begin;\n     return false;\n-};\n-\n+}\n }\ndiff --git a/src/Parsers/Kusto/ParserKQLStatement.h b/src/Parsers/Kusto/ParserKQLStatement.h\nindex ef44b2d6c8ac..fe9b9adfa2ac 100644\n--- a/src/Parsers/Kusto/ParserKQLStatement.h\n+++ b/src/Parsers/Kusto/ParserKQLStatement.h\n@@ -12,14 +12,14 @@ class ParserKQLStatement : public IParserBase\n     bool allow_settings_after_format_in_insert;\n     const char * getName() const override { return \"KQL Statement\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+\n public:\n     explicit ParserKQLStatement(const char * end_, bool allow_settings_after_format_in_insert_ = false)\n-        : end(end_)\n-        , allow_settings_after_format_in_insert(allow_settings_after_format_in_insert_)\n-    {}\n+        : end(end_), allow_settings_after_format_in_insert(allow_settings_after_format_in_insert_)\n+    {\n+    }\n };\n \n-\n class ParserKQLWithOutput : public IParserBase\n {\n protected:\n@@ -27,11 +27,12 @@ class ParserKQLWithOutput : public IParserBase\n     bool allow_settings_after_format_in_insert;\n     const char * getName() const override { return \"KQL with output\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+\n public:\n     explicit ParserKQLWithOutput(const char * end_, bool allow_settings_after_format_in_insert_ = false)\n-        : end(end_)\n-        , allow_settings_after_format_in_insert(allow_settings_after_format_in_insert_)\n-    {}\n+        : end(end_), allow_settings_after_format_in_insert(allow_settings_after_format_in_insert_)\n+    {\n+    }\n };\n \n class ParserKQLWithUnionQuery : public IParserBase\n@@ -41,7 +42,7 @@ class ParserKQLWithUnionQuery : public IParserBase\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n-class ParserKQLTaleFunction : public IParserBase\n+class ParserKQLTableFunction : public IParserBase\n {\n protected:\n     const char * getName() const override { return \"KQL() function\"; }\n@@ -49,4 +50,3 @@ class ParserKQLTaleFunction : public IParserBase\n };\n \n }\n-\ndiff --git a/src/Parsers/Kusto/ParserKQLSummarize.cpp b/src/Parsers/Kusto/ParserKQLSummarize.cpp\nindex 75eacb1adbd2..11518fcc6849 100644\n--- a/src/Parsers/Kusto/ParserKQLSummarize.cpp\n+++ b/src/Parsers/Kusto/ParserKQLSummarize.cpp\n@@ -1,3 +1,8 @@\n+#include <memory>\n+#include <queue>\n+#include <vector>\n+#include <IO/ReadBufferFromString.h>\n+#include <IO/ReadHelpers.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTInterpolateElement.h>\n@@ -10,15 +15,17 @@\n #include <Parsers/IParserBase.h>\n #include <Parsers/Kusto/ParserKQLQuery.h>\n #include <Parsers/Kusto/ParserKQLSummarize.h>\n+#include <Parsers/ParserSampleRatio.h>\n #include <Parsers/ParserSelectQuery.h>\n #include <Parsers/ParserSetQuery.h>\n #include <Parsers/ParserTablesInSelectQuery.h>\n #include <Parsers/ParserWithElement.h>\n+#include <format>\n \n namespace DB\n {\n \n-bool ParserKQLSummarize ::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLSummarize::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr select_expression_list;\n     ASTPtr group_expression_list;\n@@ -27,33 +34,164 @@ bool ParserKQLSummarize ::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n     String expr_groupby;\n     String expr_columns;\n     bool groupby = false;\n+    auto column_begin_pos = pos;\n \n-    auto begin = pos;\n-    auto pos_groupby = pos;\n+    uint16_t bracket_count = 0;\n+    int32_t new_column_index = 1;\n+\n+    std::vector<String> expr_aggregations;\n+    std::vector<String> expr_groupbys;\n+\n+    std::unordered_set<String> aggregate_functions(\n+        {\"arg_max\",\n+         \"arg_min\",\n+         \"avg\",\n+         \"avgif\",\n+         \"binary_all_and\",\n+         \"binary_all_or\",\n+         \"binary_all_xor\",\n+         \"buildschema\",\n+         \"count\",\n+         \"countif\",\n+         \"dcount\",\n+         \"dcountif\",\n+         \"make_bag\",\n+         \"make_bag_if\",\n+         \"make_list\",\n+         \"make_list_if\",\n+         \"make_list_with_nulls\",\n+         \"make_set\",\n+         \"make_set_if\",\n+         \"max\",\n+         \"maxif\",\n+         \"min\",\n+         \"minif\",\n+         \"percentile\",\n+         \"percentilew\",\n+         \"percentiles\",\n+         \"percentiles_array\",\n+         \"percentilesw\",\n+         \"percentilesw_array\",\n+         \"stdev\",\n+         \"stdevif\",\n+         \"sum\",\n+         \"sumif\",\n+         \"take_any\",\n+         \"take_anyif\",\n+         \"variance\",\n+         \"varianceif\"});\n+\n+    auto apply_aliais = [&](Pos & begin_pos, Pos & end_pos, bool is_groupby)\n+    {\n+        auto expr = String(begin_pos->begin, end_pos->end);\n+        auto equal_pos = begin_pos;\n+        ++equal_pos;\n+        if (!is_groupby)\n+        {\n+            if (String(equal_pos->begin, equal_pos->end) != \"=\")\n+            {\n+                String alias;\n+                String aggregate_fun = String(begin_pos->begin, begin_pos->end);\n+                if (aggregate_functions.find(aggregate_fun) == aggregate_functions.end())\n+                {\n+                    alias = std::format(\"Columns{}\", new_column_index);\n+                    ++new_column_index;\n+                }\n+                else\n+                {\n+                    alias = std::format(\"{}_\", aggregate_fun);\n+                    auto agg_colum_pos = begin_pos;\n+                    ++agg_colum_pos;\n+                    ++agg_colum_pos;\n+                    ++agg_colum_pos;\n+                    if (agg_colum_pos->type == TokenType::Comma || agg_colum_pos->type == TokenType::ClosingRoundBracket)\n+                    {\n+                        --agg_colum_pos;\n+                        if (agg_colum_pos->type != TokenType::ClosingRoundBracket)\n+                            alias = alias + String(agg_colum_pos->begin, agg_colum_pos->end);\n+                    }\n+                }\n+                expr = std::format(\"{} = {}\", alias, expr);\n+            }\n+            expr_aggregations.push_back(expr);\n+        }\n+        else\n+        {\n+            if (String(equal_pos->begin, equal_pos->end) != \"=\")\n+            {\n+                String groupby_fun = String(begin_pos->begin, begin_pos->end);\n+                if (equal_pos->isEnd() || equal_pos->type == TokenType::Comma || equal_pos->type == TokenType::Semicolon\n+                    || equal_pos->type == TokenType::PipeMark)\n+                {\n+                    expr = groupby_fun;\n+                }\n+                else\n+                {\n+                    String alias;\n+                    if (groupby_fun == \"bin\" || groupby_fun == \"bin_at\")\n+                    {\n+                        auto bin_colum_pos = begin_pos;\n+                        ++bin_colum_pos;\n+                        ++bin_colum_pos;\n+                        alias = String(bin_colum_pos->begin, bin_colum_pos->end);\n+                        ++bin_colum_pos;\n+                        if (bin_colum_pos->type != TokenType::Comma)\n+                            alias.clear();\n+                    }\n+                    if (alias.empty())\n+                    {\n+                        alias = std::format(\"Columns{}\", new_column_index);\n+                        ++new_column_index;\n+                    }\n+\n+                    expr = std::format(\"{} = {}\", alias, expr);\n+                }\n+            }\n+            expr_groupbys.push_back(expr);\n+        }\n+    };\n \n     while (!pos->isEnd() && pos->type != TokenType::PipeMark && pos->type != TokenType::Semicolon)\n     {\n-        if (String(pos->begin, pos->end) == \"by\")\n+        if (pos->type == TokenType::OpeningRoundBracket)\n+            ++bracket_count;\n+\n+        if (pos->type == TokenType::ClosingRoundBracket)\n+            --bracket_count;\n+\n+        if ((bracket_count == 0 and pos->type == TokenType::Comma) || String(pos->begin, pos->end) == \"by\")\n         {\n-            groupby = true;\n-            auto end = pos;\n-            --end;\n-            expr_aggregation = begin <= end ? String(begin->begin, end->end) : \"\";\n-            pos_groupby = pos;\n-            ++pos_groupby;\n+            auto end_pos = pos;\n+            --end_pos;\n+            apply_aliais(column_begin_pos, end_pos, groupby);\n+            if (String(pos->begin, pos->end) == \"by\")\n+                groupby = true;\n+            column_begin_pos = pos;\n+            ++column_begin_pos;\n         }\n         ++pos;\n     }\n     --pos;\n-    if (groupby)\n-        expr_groupby = String(pos_groupby->begin, pos->end);\n-    else\n-        expr_aggregation = begin <= pos ? String(begin->begin, pos->end) : \"\";\n+    apply_aliais(column_begin_pos, pos, groupby);\n \n-    auto expr_aggregation_str = expr_aggregation.empty() ? \"\" : expr_aggregation +\",\";\n-    expr_columns = groupby ? expr_aggregation_str + expr_groupby : expr_aggregation_str;\n+    for (auto const & expr : expr_aggregations)\n+        expr_aggregation = expr_aggregation.empty() ? expr : expr_aggregation + \",\" + expr;\n \n-    String converted_columns =  getExprFromToken(expr_columns, pos.max_depth);\n+    for (auto const & expr : expr_groupbys)\n+        expr_groupby = expr_groupby.empty() ? expr : expr_groupby + \",\" + expr;\n+\n+    if (!expr_groupby.empty())\n+        expr_columns = expr_groupby;\n+\n+    if (!expr_aggregation.empty())\n+    {\n+        if (expr_columns.empty())\n+            expr_columns = expr_aggregation;\n+        else\n+            expr_columns = expr_columns + \",\" + expr_aggregation;\n+    }\n+\n+    String converted_columns = getExprFromToken(expr_columns, pos.max_depth);\n \n     Tokens token_converted_columns(converted_columns.c_str(), converted_columns.c_str() + converted_columns.size());\n     IParser::Pos pos_converted_columns(token_converted_columns, pos.max_depth);\n@@ -65,7 +203,7 @@ bool ParserKQLSummarize ::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n \n     if (groupby)\n     {\n-        String converted_groupby =  getExprFromToken(expr_groupby, pos.max_depth);\n+        String converted_groupby = getExprFromToken(expr_groupby, pos.max_depth);\n \n         Tokens token_converted_groupby(converted_groupby.c_str(), converted_groupby.c_str() + converted_groupby.size());\n         IParser::Pos postoken_converted_groupby(token_converted_groupby, pos.max_depth);\n@@ -77,5 +215,4 @@ bool ParserKQLSummarize ::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n \n     return true;\n }\n-\n }\ndiff --git a/src/Parsers/Kusto/ParserKQLSummarize.h b/src/Parsers/Kusto/ParserKQLSummarize.h\nindex 1aad02705dfd..e95043c15232 100644\n--- a/src/Parsers/Kusto/ParserKQLSummarize.h\n+++ b/src/Parsers/Kusto/ParserKQLSummarize.h\n@@ -8,7 +8,6 @@ namespace DB\n \n class ParserKQLSummarize : public ParserKQLBase\n {\n-\n protected:\n     const char * getName() const override { return \"KQL summarize\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\ndiff --git a/src/Parsers/Kusto/ParserKQLTable.cpp b/src/Parsers/Kusto/ParserKQLTable.cpp\nindex 6356ad688b67..4ea910ea8ee6 100644\n--- a/src/Parsers/Kusto/ParserKQLTable.cpp\n+++ b/src/Parsers/Kusto/ParserKQLTable.cpp\n@@ -1,45 +1,23 @@\n+#include <unordered_set>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/IParserBase.h>\n-#include <Parsers/ParserTablesInSelectQuery.h>\n #include <Parsers/Kusto/ParserKQLQuery.h>\n #include <Parsers/Kusto/ParserKQLTable.h>\n-#include <unordered_set>\n+#include <Parsers/ParserTablesInSelectQuery.h>\n namespace DB\n {\n \n-bool ParserKQLTable :: parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKQLTable ::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    std::unordered_set<String> sql_keywords\n-    ({\n-        \"SELECT\",\n-        \"INSERT\",\n-        \"CREATE\",\n-        \"ALTER\",\n-        \"SYSTEM\",\n-        \"SHOW\",\n-        \"GRANT\",\n-        \"REVOKE\",\n-        \"ATTACH\",\n-        \"CHECK\",\n-        \"DESCRIBE\",\n-        \"DESC\",\n-        \"DETACH\",\n-        \"DROP\",\n-        \"EXISTS\",\n-        \"KILL\",\n-        \"OPTIMIZE\",\n-        \"RENAME\",\n-        \"SET\",\n-        \"TRUNCATE\",\n-        \"USE\",\n-        \"EXPLAIN\"\n-    });\n+    std::unordered_set<String> sql_keywords({\"SELECT\",   \"INSERT\", \"CREATE\",   \"ALTER\",    \"SYSTEM\", \"SHOW\",   \"GRANT\",  \"REVOKE\",\n+                                             \"ATTACH\",   \"CHECK\",  \"DESCRIBE\", \"DESC\",     \"DETACH\", \"DROP\",   \"EXISTS\", \"KILL\",\n+                                             \"OPTIMIZE\", \"RENAME\", \"SET\",      \"TRUNCATE\", \"USE\",    \"EXPLAIN\"});\n \n     ASTPtr tables;\n-    String table_name(pos->begin,pos->end);\n+    String table_name(pos->begin, pos->end);\n     String table_name_upcase(table_name);\n \n-    std::transform(table_name_upcase.begin(), table_name_upcase.end(),table_name_upcase.begin(), toupper);\n+    std::transform(table_name_upcase.begin(), table_name_upcase.end(), table_name_upcase.begin(), toupper);\n \n     if (sql_keywords.find(table_name_upcase) != sql_keywords.end())\n         return false;\ndiff --git a/src/Parsers/Kusto/ParserKQLTable.h b/src/Parsers/Kusto/ParserKQLTable.h\nindex c67dcb151562..8e03b50cb8bb 100644\n--- a/src/Parsers/Kusto/ParserKQLTable.h\n+++ b/src/Parsers/Kusto/ParserKQLTable.h\n@@ -8,7 +8,6 @@ namespace DB\n \n class ParserKQLTable : public ParserKQLBase\n {\n-\n protected:\n     const char * getName() const override { return \"KQL Table\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\ndiff --git a/src/Parsers/Kusto/Utilities.cpp b/src/Parsers/Kusto/Utilities.cpp\nnew file mode 100644\nindex 000000000000..72c1ee86628d\n--- /dev/null\n+++ b/src/Parsers/Kusto/Utilities.cpp\n@@ -0,0 +1,74 @@\n+#include \"Utilities.h\"\n+\n+#include \"KustoFunctions/IParserKQLFunction.h\"\n+\n+#include <Parsers/ASTAsterisk.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+\n+namespace DB\n+{\n+String extractLiteralArgumentWithoutQuotes(const std::string & function_name, IParser::Pos & pos)\n+{\n+    ++pos;\n+    if (pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral)\n+    {\n+        auto result = extractTokenWithoutQuotes(pos);\n+        ++pos;\n+        return result;\n+    }\n+\n+    --pos;\n+    return IParserKQLFunction::getArgument(function_name, pos, IParserKQLFunction::ArgumentState::Raw);\n+}\n+\n+String extractTokenWithoutQuotes(IParser::Pos & pos)\n+{\n+    const auto offset = static_cast<int>(pos->type == TokenType::QuotedIdentifier || pos->type == TokenType::StringLiteral);\n+    return {pos->begin + offset, pos->end - offset};\n+}\n+\n+void setSelectAll(ASTSelectQuery & select_query)\n+{\n+    auto expression_list = std::make_shared<ASTExpressionList>();\n+    expression_list->children.push_back(std::make_shared<ASTAsterisk>());\n+    select_query.setExpression(ASTSelectQuery::Expression::SELECT, std::move(expression_list));\n+}\n+\n+String wildcardToRegex(const String & wildcard)\n+{\n+    String regex;\n+    for (char c : wildcard)\n+    {\n+        if (c == '*')\n+        {\n+            regex += \".*\";\n+        }\n+        else if (c == '?')\n+        {\n+            regex += \".\";\n+        }\n+        else if (c == '.' || c == '+' || c == '(' || c == ')' || c == '[' || c == ']' || c == '\\\\' || c == '^' || c == '$')\n+        {\n+            regex += \"\\\\\";\n+            regex += c;\n+        }\n+        else\n+        {\n+            regex += c;\n+        }\n+    }\n+    return regex;\n+}\n+\n+ASTPtr wrapInSelectWithUnion(const ASTPtr & select_query)\n+{\n+    auto select_with_union_query = std::make_shared<ASTSelectWithUnionQuery>();\n+    auto & list_of_selects = select_with_union_query->list_of_selects;\n+    list_of_selects = std::make_shared<ASTExpressionList>();\n+    list_of_selects->children.push_back(select_query);\n+    select_with_union_query->children.push_back(list_of_selects);\n+\n+    return select_with_union_query;\n+}\n+}\ndiff --git a/src/Parsers/Kusto/Utilities.h b/src/Parsers/Kusto/Utilities.h\nnew file mode 100644\nindex 000000000000..f19fad72287f\n--- /dev/null\n+++ b/src/Parsers/Kusto/Utilities.h\n@@ -0,0 +1,13 @@\n+#pragma once\n+\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/IParser.h>\n+\n+namespace DB\n+{\n+String extractLiteralArgumentWithoutQuotes(const std::string & function_name, IParser::Pos & pos);\n+String extractTokenWithoutQuotes(IParser::Pos & pos);\n+void setSelectAll(ASTSelectQuery & select_query);\n+String wildcardToRegex(const String & wildcard);\n+ASTPtr wrapInSelectWithUnion(const ASTPtr & select_query);\n+}\ndiff --git a/src/Parsers/Kusto/parseKQLQuery.cpp b/src/Parsers/Kusto/parseKQLQuery.cpp\nnew file mode 100644\nindex 000000000000..bcc04ef70016\n--- /dev/null\n+++ b/src/Parsers/Kusto/parseKQLQuery.cpp\n@@ -0,0 +1,485 @@\n+#include <Parsers/parseQuery.h>\n+\n+#include <Interpreters/OpenTelemetrySpanLog.h>\n+#include <Parsers/ParserQuery.h>\n+#include <Parsers/ASTInsertQuery.h>\n+#include <Parsers/ASTExplainQuery.h>\n+#include <Parsers/Lexer.h>\n+#include <Parsers/TokenIterator.h>\n+#include <Common/StringUtils/StringUtils.h>\n+#include <Common/typeid_cast.h>\n+#include <Common/UTF8Helpers.h>\n+#include <base/find_symbols.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <IO/Operators.h>\n+#include <Parsers/Kusto/ParserKQLStatement.h>\n+#include <Parsers/Kusto/ParserKQLDateTypeTimespan.h>\n+#include <Parsers/Kusto/parseKQLQuery.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int SYNTAX_ERROR;\n+}\n+namespace\n+{\n+\n+/** From position in (possible multiline) query, get line number and column number in line.\n+  * Used in syntax error message.\n+  */\n+std::pair<size_t, size_t> getLineAndCol(const char * begin, const char * pos)\n+{\n+    size_t line = 0;\n+\n+    const char * nl;\n+    while ((nl = find_first_symbols<'\\n'>(begin, pos)) < pos)\n+    {\n+        ++line;\n+        begin = nl + 1;\n+    }\n+\n+    /// Lines numbered from 1.\n+    return { line + 1, pos - begin + 1 };\n+}\n+\n+\n+WriteBuffer & operator<< (WriteBuffer & out, const Expected & expected)\n+{\n+    if (expected.variants.empty())\n+        return out;\n+\n+    if (expected.variants.size() == 1)\n+        return out << *expected.variants.begin();\n+\n+    out << \"one of: \";\n+    bool first = true;\n+    for (const auto & variant : expected.variants)\n+    {\n+        if (!first)\n+            out << \", \";\n+        first = false;\n+\n+        out << variant;\n+    }\n+    return out;\n+}\n+\n+\n+/// Hilite place of syntax error.\n+void writeQueryWithHighlightedErrorPositions(\n+    WriteBuffer & out,\n+    const char * begin,\n+    const char * end,\n+    const Token * positions_to_hilite,   /// must go in ascending order\n+    size_t num_positions_to_hilite)\n+{\n+    const char * pos = begin;\n+    for (size_t position_to_hilite_idx = 0; position_to_hilite_idx < num_positions_to_hilite; ++position_to_hilite_idx)\n+    {\n+        const char * current_position_to_hilite = positions_to_hilite[position_to_hilite_idx].begin;\n+\n+        assert(current_position_to_hilite <= end);\n+        assert(current_position_to_hilite >= begin);\n+\n+        out.write(pos, current_position_to_hilite - pos);\n+\n+        if (current_position_to_hilite == end)\n+        {\n+            out << \"\\033[41;1m \\033[0m\";\n+            return;\n+        }\n+        else\n+        {\n+            size_t bytes_to_hilite = UTF8::seqLength(*current_position_to_hilite);\n+\n+            /// Bright on red background.\n+            out << \"\\033[41;1m\";\n+            out.write(current_position_to_hilite, bytes_to_hilite);\n+            out << \"\\033[0m\";\n+            pos = current_position_to_hilite + bytes_to_hilite;\n+        }\n+    }\n+    out.write(pos, end - pos);\n+}\n+\n+\n+void writeQueryAroundTheError(\n+    WriteBuffer & out,\n+    const char * begin,\n+    const char * end,\n+    bool hilite,\n+    const Token * positions_to_hilite,\n+    size_t num_positions_to_hilite)\n+{\n+    if (hilite)\n+    {\n+        out << \":\\n\\n\";\n+        writeQueryWithHighlightedErrorPositions(out, begin, end, positions_to_hilite, num_positions_to_hilite);\n+        out << \"\\n\\n\";\n+    }\n+    else\n+    {\n+        if (num_positions_to_hilite)\n+            out << \": \" << std::string(positions_to_hilite[0].begin, std::min(SHOW_CHARS_ON_SYNTAX_ERROR, end - positions_to_hilite[0].begin)) << \". \";\n+    }\n+}\n+\n+\n+void writeCommonErrorMessage(\n+    WriteBuffer & out,\n+    const char * begin,\n+    const char * end,\n+    Token last_token,\n+    const std::string & query_description)\n+{\n+    out << \"Syntax error\";\n+\n+    if (!query_description.empty())\n+        out << \" (\" << query_description << \")\";\n+\n+    out << \": failed at position \" << (last_token.begin - begin + 1);\n+\n+    if (last_token.type == TokenType::EndOfStream || last_token.type == TokenType::Semicolon)\n+    {\n+        out << \" (end of query)\";\n+    }\n+    else\n+    {\n+        out << \" ('\" << std::string(last_token.begin, last_token.end - last_token.begin) << \"')\";\n+    }\n+\n+    /// If query is multiline.\n+    const char * nl = find_first_symbols<'\\n'>(begin, end);\n+    if (nl + 1 < end)\n+    {\n+        size_t line = 0;\n+        size_t col = 0;\n+        std::tie(line, col) = getLineAndCol(begin, last_token.begin);\n+\n+        out << \" (line \" << line << \", col \" << col << \")\";\n+    }\n+}\n+\n+\n+std::string getSyntaxErrorMessage(\n+    const char * begin,\n+    const char * end,\n+    Token last_token,\n+    const Expected & expected,\n+    bool hilite,\n+    const std::string & query_description)\n+{\n+    WriteBufferFromOwnString out;\n+    writeCommonErrorMessage(out, begin, end, last_token, query_description);\n+    writeQueryAroundTheError(out, begin, end, hilite, &last_token, 1);\n+\n+    if (!expected.variants.empty())\n+        out << \"Expected \" << expected;\n+\n+    return out.str();\n+}\n+\n+\n+std::string getLexicalErrorMessage(\n+    const char * begin,\n+    const char * end,\n+    Token last_token,\n+    bool hilite,\n+    const std::string & query_description)\n+{\n+    WriteBufferFromOwnString out;\n+    writeCommonErrorMessage(out, begin, end, last_token, query_description);\n+    writeQueryAroundTheError(out, begin, end, hilite, &last_token, 1);\n+\n+    out << getErrorTokenDescription(last_token.type);\n+    if (last_token.size())\n+    {\n+       out << \": '\" << std::string_view{last_token.begin, last_token.size()} << \"'\";\n+    }\n+\n+    return out.str();\n+}\n+\n+\n+std::string getUnmatchedParenthesesErrorMessage(\n+    const char * begin,\n+    const char * end,\n+    const UnmatchedParentheses & unmatched_parens,\n+    bool hilite,\n+    const std::string & query_description)\n+{\n+    WriteBufferFromOwnString out;\n+    writeCommonErrorMessage(out, begin, end, unmatched_parens[0], query_description);\n+    writeQueryAroundTheError(out, begin, end, hilite, unmatched_parens.data(), unmatched_parens.size());\n+\n+    out << \"Unmatched parentheses: \";\n+    for (const Token & paren : unmatched_parens)\n+        out << *paren.begin;\n+\n+    return out.str();\n+}\n+\n+UnmatchedParentheses checkKQLUnmatchedParentheses(TokenIterator begin)\n+{\n+    std::unordered_set<String> valid_kql_negative_suffix(\n+        {\n+         \"between\",\n+         \"contains\",\n+         \"contains_cs\",\n+         \"endswith\",\n+         \"endswith_cs\",\n+         \"~\",\n+         \"=\",\n+         \"has\",\n+         \"has_cs\",\n+         \"hasprefix\",\n+         \"hasprefix_cs\",\n+         \"hassuffix\",\n+         \"hassuffix_cs\",\n+         \"in\",\n+         \"startswith\",\n+         \"startswith_cs\"});\n+    /// We have just two kind of parentheses: () and [].\n+    UnmatchedParentheses stack;\n+\n+    /// We have to iterate through all tokens until the end to avoid false positive \"Unmatched parentheses\" error\n+    /// when parser failed in the middle of the query.\n+    for (TokenIterator it = begin; !it->isEnd(); ++it)\n+    {\n+        if (!it.isValid()) // allow kql negative operators\n+        {\n+            if (it->type == TokenType::ErrorSingleExclamationMark)\n+            {\n+                ++it;\n+                if (!valid_kql_negative_suffix.contains(String(it.get().begin, it.get().end)))\n+                    break;\n+                --it;\n+            }\n+            else if (it->type == TokenType::ErrorWrongNumber)\n+            {\n+                if (!ParserKQLDateTypeTimespan().parseConstKQLTimespan(String(it.get().begin, it.get().end)))\n+                    break;\n+            }\n+            else\n+            {\n+                if (String(it.get().begin, it.get().end) == \"~\")\n+                {\n+                    --it;\n+                    if (const auto prev = String(it.get().begin, it.get().end); prev != \"!\" && prev != \"=\" && prev != \"in\")\n+                        break;\n+                    ++it;\n+                }\n+                else\n+                    break;\n+            }\n+        }\n+\n+        if (it->type == TokenType::OpeningRoundBracket || it->type == TokenType::OpeningSquareBracket)\n+        {\n+            stack.push_back(*it);\n+        }\n+        else if (it->type == TokenType::ClosingRoundBracket || it->type == TokenType::ClosingSquareBracket)\n+        {\n+            if (stack.empty())\n+            {\n+                /// Excessive closing bracket.\n+                stack.push_back(*it);\n+                return stack;\n+            }\n+            else if (\n+                (stack.back().type == TokenType::OpeningRoundBracket && it->type == TokenType::ClosingRoundBracket)\n+                || (stack.back().type == TokenType::OpeningSquareBracket && it->type == TokenType::ClosingSquareBracket))\n+            {\n+                /// Valid match.\n+                stack.pop_back();\n+            }\n+            else\n+            {\n+                /// Closing bracket type doesn't match opening bracket type.\n+                stack.push_back(*it);\n+                return stack;\n+            }\n+        }\n+    }\n+\n+    /// If stack is not empty, we have unclosed brackets.\n+    return stack;\n+}\n+\n+}\n+\n+\n+ASTPtr tryParseKQLQuery(\n+    IParser & parser,\n+    const char * & _out_query_end, /* also query begin as input parameter */\n+    const char * all_queries_end,\n+    std::string & out_error_message,\n+    bool hilite,\n+    const std::string & query_description,\n+    bool allow_multi_statements,\n+    size_t max_query_size,\n+    size_t max_parser_depth,\n+    bool skip_insignificant)\n+{\n+    const char * query_begin = _out_query_end;\n+    Tokens tokens(query_begin, all_queries_end, max_query_size, skip_insignificant);\n+    /// NOTE: consider use UInt32 for max_parser_depth setting.\n+    IParser::Pos token_iterator(tokens, static_cast<uint32_t>(max_parser_depth));\n+\n+    if (token_iterator->isEnd()\n+        || token_iterator->type == TokenType::Semicolon)\n+    {\n+        out_error_message = \"Empty query\";\n+        // Token iterator skips over comments, so we'll get this error for queries\n+        // like this:\n+        // \"\n+        // -- just a comment\n+        // ;\n+        //\"\n+        // Advance the position, so that we can use this parser for stream parsing\n+        // even in presence of such queries.\n+        _out_query_end = token_iterator->begin;\n+        return nullptr;\n+    }\n+\n+    Expected expected;\n+    ASTPtr res;\n+    const bool parse_res = parser.parse(token_iterator, res, expected);\n+    const auto last_token = token_iterator.max();\n+    _out_query_end = last_token.end;\n+\n+    ASTInsertQuery * insert = nullptr;\n+    if (parse_res)\n+    {\n+        if (auto * explain = res->as<ASTExplainQuery>())\n+        {\n+            if (auto explained_query = explain->getExplainedQuery())\n+            {\n+                insert = explained_query->as<ASTInsertQuery>();\n+            }\n+        }\n+        else\n+        {\n+            insert = res->as<ASTInsertQuery>();\n+        }\n+    }\n+\n+    // If parsed query ends at data for insertion. Data for insertion could be\n+    // in any format and not necessary be lexical correct, so we can't perform\n+    // most of the checks.\n+    if (insert && insert->data)\n+    {\n+        return res;\n+    }\n+\n+    // More granular checks for queries other than INSERT w/inline data.\n+    /// Lexical error\n+    if (last_token.isError())\n+    {\n+        out_error_message = getLexicalErrorMessage(query_begin, all_queries_end,\n+            last_token, hilite, query_description);\n+        return nullptr;\n+    }\n+\n+\n+   /// Unmatched parentheses\n+    UnmatchedParentheses unmatched_parens = checkKQLUnmatchedParentheses(TokenIterator(tokens));\n+    if (!unmatched_parens.empty())\n+    {\n+        out_error_message = getUnmatchedParenthesesErrorMessage(query_begin,\n+            all_queries_end, unmatched_parens, hilite, query_description);\n+        return nullptr;\n+    }\n+\n+    if (!parse_res)\n+    {\n+        /// Generic parse error.\n+        out_error_message = getSyntaxErrorMessage(query_begin, all_queries_end,\n+            last_token, expected, hilite, query_description);\n+        return nullptr;\n+    }\n+\n+    /// Excessive input after query. Parsed query must end with end of data or semicolon or data for INSERT.\n+    if (!token_iterator->isEnd()\n+        && token_iterator->type != TokenType::Semicolon)\n+    {\n+        expected.add(last_token.begin, \"end of query\");\n+        out_error_message = getSyntaxErrorMessage(query_begin, all_queries_end,\n+            last_token, expected, hilite, query_description);\n+        return nullptr;\n+    }\n+\n+    // Skip the semicolon that might be left after parsing the VALUES format.\n+    while (token_iterator->type == TokenType::Semicolon)\n+    {\n+        ++token_iterator;\n+    }\n+\n+    // If multi-statements are not allowed, then after semicolon, there must\n+    // be no non-space characters.\n+    if (!allow_multi_statements\n+        && !token_iterator->isEnd())\n+    {\n+        out_error_message = getSyntaxErrorMessage(query_begin, all_queries_end,\n+            last_token, {}, hilite,\n+            (query_description.empty() ? std::string() : std::string(\". \"))\n+                + \"Multi-statements are not allowed\");\n+        return nullptr;\n+    }\n+\n+    return res;\n+}\n+\n+\n+ASTPtr parseKQLQueryAndMovePosition(\n+    IParser & parser,\n+    const char * & pos,\n+    const char * end,\n+    const std::string & query_description,\n+    bool allow_multi_statements,\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n+{\n+    std::string error_message;\n+    ASTPtr res = tryParseKQLQuery(parser, pos, end, error_message, false, query_description, allow_multi_statements, max_query_size, max_parser_depth);\n+\n+    if (res)\n+        return res;\n+\n+    throw Exception::createDeprecated(error_message, ErrorCodes::SYNTAX_ERROR);\n+}\n+\n+ASTPtr parseKQLQuery(\n+    IParser & parser,\n+    const char * begin,\n+    const char * end,\n+    const std::string & query_description,\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n+{\n+    return parseKQLQueryAndMovePosition(parser, begin, end, query_description, false, max_query_size, max_parser_depth);\n+}\n+\n+ASTPtr parseKQLQuery(\n+    IParser & parser,\n+    const std::string & query,\n+    const std::string & query_description,\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n+{\n+    return parseKQLQuery(parser, query.data(), query.data() + query.size(), query_description, max_query_size, max_parser_depth);\n+}\n+\n+ASTPtr parseKQLQuery(\n+    IParser & parser,\n+    const std::string & query,\n+    size_t max_query_size,\n+    size_t max_parser_depth)\n+{\n+    return parseKQLQuery(parser, query.data(), query.data() + query.size(), parser.getName(), max_query_size, max_parser_depth);\n+}\n+\n+}\ndiff --git a/src/Parsers/Kusto/parseKQLQuery.h b/src/Parsers/Kusto/parseKQLQuery.h\nnew file mode 100644\nindex 000000000000..fca017e70fea\n--- /dev/null\n+++ b/src/Parsers/Kusto/parseKQLQuery.h\n@@ -0,0 +1,64 @@\n+#pragma once\n+\n+#include <Parsers/IAST_fwd.h>\n+#include <Parsers/parseQuery.h>\n+#include <IO/WriteBufferFromString.h>\n+namespace DB\n+{\n+\n+/** From position in (possible multiline) query, get line number and column number in line.\n+  * Used in syntax error message.\n+  */\n+\n+}\n+namespace DB\n+{\n+\n+class IParser;\n+\n+/// Parse query or set 'out_error_message'.\n+ASTPtr tryParseKQLQuery(\n+    IParser & parser,\n+    const char * & _out_query_end, // query start as input parameter, query end as output\n+    const char * end,\n+    std::string & out_error_message,\n+    bool hilite,\n+    const std::string & description,\n+    bool allow_multi_statements,    /// If false, check for non-space characters after semicolon and set error message if any.\n+    size_t max_query_size,          /// If (end - pos) > max_query_size and query is longer than max_query_size then throws \"Max query size exceeded\".\n+                                    /// Disabled if zero. Is used in order to check query size if buffer can contains data for INSERT query.\n+    size_t max_parser_depth,\n+    bool skip_insignificant = true);  /// If true, lexer will skip all insignificant tokens (e.g. whitespaces)\n+\n+\n+/// Parse query or throw an exception with error message.\n+ASTPtr parseKQLQueryAndMovePosition(\n+    IParser & parser,\n+    const char * & pos,                /// Moved to end of parsed fragment.\n+    const char * end,\n+    const std::string & description,\n+    bool allow_multi_statements,\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n+\n+ASTPtr parseKQLQuery(\n+    IParser & parser,\n+    const char * begin,\n+    const char * end,\n+    const std::string & description,\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n+\n+ASTPtr parseKQLQuery(\n+    IParser & parser,\n+    const std::string & query,\n+    const std::string & query_description,\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n+\n+ASTPtr parseKQLQuery(\n+    IParser & parser,\n+    const std::string & query,\n+    size_t max_query_size,\n+    size_t max_parser_depth);\n+}\n",
  "test_patch": "diff --git a/contrib/googletest-cmake/CMakeLists.txt b/contrib/googletest-cmake/CMakeLists.txt\nindex 3905df031557..5b00096615a5 100644\n--- a/contrib/googletest-cmake/CMakeLists.txt\n+++ b/contrib/googletest-cmake/CMakeLists.txt\n@@ -14,12 +14,12 @@ add_library(_gtest_all INTERFACE)\n target_link_libraries(_gtest_all INTERFACE _gtest _gtest_main)\n add_library(ch_contrib::gtest_all ALIAS _gtest_all)\n \n-\n add_library(_gmock \"${SRC_DIR}/googlemock/src/gmock-all.cc\")\n set_target_properties(_gmock PROPERTIES VERSION \"1.0.0\")\n target_compile_definitions (_gmock PUBLIC GTEST_HAS_POSIX_RE=0)\n target_include_directories(_gmock SYSTEM PUBLIC \"${SRC_DIR}/googlemock/include\" \"${SRC_DIR}/googletest/include\")\n target_include_directories(_gmock PRIVATE \"${SRC_DIR}/googlemock\")\n+target_link_libraries(_gmock PUBLIC _gtest)\n \n add_library(_gmock_main \"${SRC_DIR}/googlemock/src/gmock_main.cc\")\n set_target_properties(_gmock_main PROPERTIES VERSION \"1.0.0\")\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_AggregateFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_AggregateFunctions.cpp\nnew file mode 100644\nindex 000000000000..f115f5c6b73b\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_AggregateFunctions.cpp\n@@ -0,0 +1,73 @@\n+#include <Parsers/tests/gtest_common.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Aggregate, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"Customers | summarize t = stdev(Age) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    sqrt(varSamp(Age)) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = stdevif(Age, Age < 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    sqrt(varSampIf(Age, Age < 10)) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = binary_all_and(Age) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupBitAnd(Age) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = binary_all_or(Age) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupBitOr(Age) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+\n+        },\n+        {\n+            \"Customers | summarize t = binary_all_xor(Age) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupBitXor(Age) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize percentiles(Age, 30, 40, 50, 60, 70) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    quantiles(30 / 100, 40 / 100, 50 / 100, 60 / 100, 70 / 100)(Age) AS percentiles_Age\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = percentiles_array(Age, 10, 20, 30, 50) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    quantiles(10 / 100, 20 / 100, 30 / 100, 50 / 100)(Age) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = percentiles_array(Age, dynamic([10, 20, 30, 50])) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    quantiles(10 / 100, 20 / 100, 30 / 100, 50 / 100)(Age) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"DataTable | summarize t = percentilesw(Bucket, Frequency, 50, 75, 99.9)\",\n+            \"SELECT quantilesExactWeighted(50 / 100, 75 / 100, 99.9 / 100)(Bucket, Frequency) AS t\\nFROM DataTable\"\n+        },\n+        {\n+            \"DataTable| summarize t = percentilesw_array(Bucket, Frequency, dynamic([10, 50, 30]))\",\n+            \"SELECT quantilesExactWeighted(10 / 100, 50 / 100, 30 / 100)(Bucket, Frequency) AS t\\nFROM DataTable\"\n+        },\n+        {\n+            \"Customers | summarize t = percentile(Age, 50) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    quantile(50 / 100)(Age) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"DataTable | summarize t = percentilew(Bucket, Frequency, 50)\",\n+            \"SELECT quantileExactWeighted(50 / 100)(Bucket, Frequency) AS t\\nFROM DataTable\"\n+        },\n+        {\n+             \"Customers | summarize t = make_list_with_nulls(Age) by FirstName\",\n+             \"SELECT\\n    FirstName,\\n    arrayConcat(groupArray(Age), arrayMap(x -> NULL, range(0, toUInt32(count(*) - length(groupArray(Age))), 1))) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize count() by bin(Age, 10)\",\n+            \"SELECT\\n    toInt64(toFloat64(Age) / 10) * 10 AS Age,\\n    count() AS count_\\nFROM Customers\\nGROUP BY Age\"\n+        },\n+        {\n+            \"Customers | summarize count(Age+1) by bin(Age+1, 10)\",\n+            \"SELECT\\n    toInt64(toFloat64(Age + 1) / 10) * 10 AS Columns1,\\n    count(Age + 1) AS count_\\nFROM Customers\\nGROUP BY Columns1\"\n+        },\n+        {\n+            \"Customers | summarize count(Age) by bin(Age, 10)\",\n+            \"SELECT\\n    toInt64(toFloat64(Age) / 10) * 10 AS Age,\\n    count(Age) AS count_Age\\nFROM Customers\\nGROUP BY Age\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_Binary.cpp b/src/Parsers/tests/KQL/gtest_KQL_Binary.cpp\nnew file mode 100644\nindex 000000000000..72c9c5a67ebd\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_Binary.cpp\n@@ -0,0 +1,37 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Binary, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print binary_and(A, B)\",\n+            \"SELECT bitAnd(CAST(A, 'Int64'), CAST(B, 'Int64'))\"\n+        },\n+        {\n+            \"print binary_not(A)\",\n+            \"SELECT bitNot(CAST(A, 'Int64'))\"\n+        },\n+        {\n+            \"print binary_or(A, B)\",\n+            \"SELECT bitOr(CAST(A, 'Int64'), CAST(B, 'Int64'))\"\n+        },\n+        {\n+            \"print binary_shift_left(A, B)\",\n+            \"SELECT if(B < 0, NULL, bitShiftLeft(CAST(A, 'Int64'), B))\"\n+        },\n+        {\n+            \"print binary_shift_right(A, B)\",\n+            \"SELECT if(B < 0, NULL, bitShiftRight(CAST(A, 'Int64'), B))\"\n+        },\n+        {\n+            \"print binary_xor(A, B)\",\n+            \"SELECT bitXor(CAST(A, 'Int64'), CAST(B, 'Int64'))\"\n+        },\n+        {\n+            \"print bitset_count_ones(A)\",\n+            \"SELECT bitCount(A)\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_Conversion.cpp b/src/Parsers/tests/KQL/gtest_KQL_Conversion.cpp\nnew file mode 100644\nindex 000000000000..02e454555241\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_Conversion.cpp\n@@ -0,0 +1,80 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(\n+    ParserKQLQuery_Conversion,\n+    ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print tobool(A)\",\n+            \"SELECT multiIf(toString(A) = 'true', true, toString(A) = 'false', false, toInt64OrNull(toString(A)) != 0)\"\n+        },\n+        {\n+            \"print toboolean(A)\",\n+            \"SELECT multiIf(toString(A) = 'true', true, toString(A) = 'false', false, toInt64OrNull(toString(A)) != 0)\"\n+        },\n+        {\n+            \"print todouble(A)\",\n+            \"SELECT toFloat64OrNull(toString(A))\"\n+        },\n+        {\n+            \"print toint(A)\",\n+            \"SELECT toInt32OrNull(toString(A))\"\n+        },\n+        {\n+            \"print tolong(A)\",\n+            \"SELECT toInt64OrNull(toString(A))\"\n+        },\n+        {\n+            \"print toreal(A)\",\n+            \"SELECT toFloat64OrNull(toString(A))\"\n+        },\n+        {\n+            \"print tostring(A)\",\n+            \"SELECT ifNull(toString(A), '')\"\n+        },\n+        {\n+            \"print decimal(123.345)\",\n+            \"SELECT toDecimal128(CAST('123.345', 'String'), 32)\"\n+        },\n+        {\n+            \"print decimal(NULL)\",\n+            \"SELECT NULL\"\n+        },\n+        {\n+            \"print todecimal('123.45')\",\n+            \"SELECT toDecimal128(CAST('123.45', 'String'), 32)\"\n+        },\n+        {\n+            \"print todecimal(NULL)\",\n+            \"SELECT NULL\"\n+        },\n+        {\n+            \"print todecimal(123456.3456)\",\n+            \"SELECT toDecimal128(CAST('123456.3456', 'String'), 12)\"\n+        },\n+        {\n+            \"print todecimal('abc')\",\n+            \"SELECT NULL\"\n+        },\n+        {\n+            \"print todecimal('1e5')\",\n+            \"SELECT toDecimal128(CAST('1e5', 'String'), 5)\"\n+        },\n+        {\n+            \"print decimal(1e-5)\",\n+            \"SELECT toDecimal128(CAST('1e-5', 'String'), 5)\"\n+        },\n+        {\n+            \"print time(9nanoseconds)\",\n+            \"SELECT CAST('9e-09', 'Float64')\"\n+        },\n+        {\n+            \"print time(1tick)\",\n+            \"SELECT CAST('1e-07', 'Float64')\"\n+        }\n+\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_DataType.cpp b/src/Parsers/tests/KQL/gtest_KQL_DataType.cpp\nnew file mode 100644\nindex 000000000000..ed77bbbada7b\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_DataType.cpp\n@@ -0,0 +1,65 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_DataType, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print dynamic(null)\",\n+            \"SELECT NULL\"\n+        },\n+        {\n+            \"print dynamic(1)\",\n+            \"SELECT 1\"\n+        },\n+        {\n+            \"print dynamic(datetime(1))\",\n+            \"SELECT parseDateTime64BestEffortOrNull('1', 9, 'UTC')\"\n+        },\n+        {\n+            \"print dynamic(timespan(1d))\",\n+            \"SELECT CAST('86400', 'Float64')\"\n+        },\n+        {\n+            \"print dynamic(parse_ipv4('127.0.0.1'))\",\n+            \"throws\"\n+        },\n+        {\n+            \"print dynamic({ \\\"a\\\": 9 })\",\n+            \"throws\"\n+        },\n+        {\n+            \"print dynamic([1, 2, 3])\",\n+            \"SELECT [1, 2, 3]\"\n+        },\n+        {\n+            \"print dynamic([1, dynamic([2]), 3])\",\n+            \"SELECT [1, [2], 3]\"\n+        },\n+        {\n+            \"print dynamic([[1], [2], [3]])\",\n+            \"SELECT [[1], [2], [3]]\"\n+        },\n+        {\n+            \"print dynamic(['a', \\\"b\\\", 'c'])\",\n+            \"SELECT ['a', 'b', 'c']\"\n+        },\n+        {\n+            \"print dynamic([1, 'a', true, false])\",\n+            \"SELECT [1, 'a', true, false]\"\n+        },\n+        {\n+            \"print dynamic([date(1), time(1d), 1, 2])\",\n+            \"SELECT [parseDateTime64BestEffortOrNull('1', 9, 'UTC'), CAST('86400', 'Float64'), 1, 2]\"\n+        },\n+        {\n+            \"print time('13:00:40.00000')\",\n+            \"SELECT CAST('46840', 'Float64')\"\n+        },\n+        {\n+            \"print timespan('12.23:12:23');\",\n+            \"SELECT CAST('1120343', 'Float64')\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_Distinct.cpp b/src/Parsers/tests/KQL/gtest_KQL_Distinct.cpp\nnew file mode 100644\nindex 000000000000..12e8065328a0\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_Distinct.cpp\n@@ -0,0 +1,29 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Distinct, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"Customers | distinct *\",\n+            \"SELECT DISTINCT *\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | distinct Occupation\",\n+            \"SELECT DISTINCT Occupation\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | distinct Occupation, Education\",\n+            \"SELECT DISTINCT\\n    Occupation,\\n    Education\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers |where Age <30| distinct Occupation, Education\",\n+            \"SELECT DISTINCT\\n    Occupation,\\n    Education\\nFROM Customers\\nWHERE Age < 30\"\n+        },\n+        {\n+            \"Customers |where Age <30 | order by Age| distinct Occupation, Education\",\n+            \"SELECT DISTINCT\\n    Occupation,\\n    Education\\nFROM Customers\\nWHERE Age < 30\\nORDER BY Age DESC\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_Dynamic.cpp b/src/Parsers/tests/KQL/gtest_KQL_Dynamic.cpp\nnew file mode 100644\nindex 000000000000..ab60223daf66\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_Dynamic.cpp\n@@ -0,0 +1,139 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_DynamicExactMatch, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print array_concat(A, B)\",\n+            \"SELECT arrayConcat(A, B)\"\n+        },\n+        {\n+            \"print array_concat(A, B, C, D)\",\n+            \"SELECT arrayConcat(A, B, C, D)\"\n+        },\n+        {\n+            \"print array_iff(A, B, C)\",\n+            \"SELECT arrayMap(x -> multiIf(toTypeName(x.1) = 'String', NULL, toInt64(x.1) != 0, x.2, x.3), arrayZip(A, arrayResize(B, length(A), NULL), arrayResize(C, length(A), NULL)))\"\n+        },\n+        {\n+            \"print array_iif(A, B, C)\",\n+            \"SELECT arrayMap(x -> multiIf(toTypeName(x.1) = 'String', NULL, toInt64(x.1) != 0, x.2, x.3), arrayZip(A, arrayResize(B, length(A), NULL), arrayResize(C, length(A), NULL)))\"\n+        },\n+        {\n+            \"print output = array_index_of(dynamic([1, 2, 3]), 2)\",\n+            \"SELECT indexOf([1, 2, 3], 2) - 1 AS output\"\n+        },\n+        {\n+            \"print output = array_index_of(dynamic(['a', 'b', 'c']), 'b')\",\n+            \"SELECT indexOf(['a', 'b', 'c'], 'b') - 1 AS output\"\n+        },\n+        {\n+            \"print output = array_index_of(dynamic(['John', 'Denver', 'Bob', 'Marley']), 'Marley')\",\n+            \"SELECT indexOf(['John', 'Denver', 'Bob', 'Marley'], 'Marley') - 1 AS output\"\n+        },\n+        {\n+            \"print output = array_length(dynamic([1, 2, 3]))\",\n+            \"SELECT length([1, 2, 3]) AS output\"\n+        },\n+        {\n+            \"print output = array_length(dynamic(['John', 'Denver', 'Bob', 'Marley']))\",\n+            \"SELECT length(['John', 'Denver', 'Bob', 'Marley']) AS output\"\n+        },\n+        {\n+            \"print array_reverse(A)\",\n+            \"SELECT if(throwIf(NOT startsWith(toTypeName(A), 'Array'), 'Only arrays are supported'), [], reverse(A))\"\n+        },\n+        {\n+            \"print array_rotate_left(A, B)\",\n+            \"SELECT arrayMap(x -> (A[moduloOrZero((x + length(A)) + moduloOrZero(B, toInt64(length(A))), length(A)) + 1]), range(0, length(A)))\"\n+        },\n+        {\n+            \"print array_rotate_right(A, B)\",\n+            \"SELECT arrayMap(x -> (A[moduloOrZero((x + length(A)) + moduloOrZero(-1 * B, toInt64(length(A))), length(A)) + 1]), range(0, length(A)))\"\n+        },\n+        {\n+            \"print output = array_sum(dynamic([2, 5, 3]))\",\n+            \"SELECT arraySum([2, 5, 3]) AS output\"\n+        },\n+        {\n+            \"print output = array_sum(dynamic([2.5, 5.5, 3]))\",\n+            \"SELECT arraySum([2.5, 5.5, 3]) AS output\"\n+        },\n+        {\n+            \"print jaccard_index(A, B)\",\n+            \"SELECT length(arrayIntersect(A, B)) / length(arrayDistinct(arrayConcat(A, B)))\"\n+        },\n+        {\n+            \"print pack_array(A, B, C, D)\",\n+            \"SELECT [A, B, C, D]\"\n+        },\n+        {\n+            \"print set_difference(A, B)\",\n+            \"SELECT arrayFilter(x -> (NOT has(arrayDistinct(arrayConcat(B)), x)), arrayDistinct(A))\"\n+        },\n+        {\n+            \"print set_difference(A, B, C)\",\n+            \"SELECT arrayFilter(x -> (NOT has(arrayDistinct(arrayConcat(B, C)), x)), arrayDistinct(A))\"\n+        },\n+        {\n+            \"print set_has_element(A, B)\",\n+            \"SELECT has(A, B)\"\n+        },\n+        {\n+            \"print set_intersect(A, B)\",\n+            \"SELECT arrayIntersect(A, B)\"\n+        },\n+        {\n+            \"print set_intersect(A, B, C)\",\n+            \"SELECT arrayIntersect(A, B, C)\"\n+        },\n+        {\n+            \"print set_union(A, B)\",\n+            \"SELECT arrayDistinct(arrayConcat(A, B))\"\n+        },\n+        {\n+            \"print set_union(A, B, C)\",\n+            \"SELECT arrayDistinct(arrayConcat(A, B, C))\"\n+        }\n+})));\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_DynamicRegex, ParserRegexTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print array_shift_left(A, B)\",\n+            R\"(SELECT arrayResize\\(if\\(B > 0, arraySlice\\(A, B \\+ 1\\), arrayConcat\\(arrayWithConstant\\(abs\\(B\\), fill_value_\\d+\\), A\\)\\), length\\(A\\), if\\(\\(NULL IS NULL\\) AND \\(\\(extract\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)*'\\) AS element_type_\\d+\\) = 'String'\\), defaultValueOfTypeName\\(if\\(element_type_\\d+ = 'Nothing', 'Nullable\\(Nothing\\)', element_type_\\d+\\)\\), NULL\\) AS fill_value_\\d+\\))\"\n+        },\n+        {\n+            \"print array_shift_left(A, B, C)\",\n+            R\"(SELECT arrayResize\\(if\\(B > 0, arraySlice\\(A, B \\+ 1\\), arrayConcat\\(arrayWithConstant\\(abs\\(B\\), fill_value_\\d+\\), A\\)\\), length\\(A\\), if\\(\\(C IS NULL\\) AND \\(\\(extract\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\) AS element_type_\\d+\\) = 'String'\\), defaultValueOfTypeName\\(if\\(element_type_\\d+ = 'Nothing', 'Nullable\\(Nothing\\)', element_type_\\d+\\)\\), C\\) AS fill_value_\\d+\\))\"\n+        },\n+        {\n+            \"print array_shift_right(A, B)\",\n+            R\"(SELECT arrayResize\\(if\\(\\(-1 \\* B\\) > 0, arraySlice\\(A, \\(-1 \\* B\\) \\+ 1\\), arrayConcat\\(arrayWithConstant\\(abs\\(-1 \\* B\\), fill_value_\\d+\\), A\\)\\), length\\(A\\), if\\(\\(NULL IS NULL\\) AND \\(\\(extract\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\) AS element_type_\\d+\\) = 'String'\\), defaultValueOfTypeName\\(if\\(element_type_\\d+ = 'Nothing', 'Nullable\\(Nothing\\)', element_type_\\d+\\)\\), NULL\\) AS fill_value_\\d+\\))\"\n+        },\n+        {\n+            \"print array_shift_right(A, B, C)\",\n+            R\"(SELECT arrayResize\\(if\\(\\(-1 \\* B\\) > 0, arraySlice\\(A, \\(-1 \\* B\\) \\+ 1\\), arrayConcat\\(arrayWithConstant\\(abs\\(-1 \\* B\\), fill_value_\\d+\\), A\\)\\), length\\(A\\), if\\(\\(C IS NULL\\) AND \\(\\(extract\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\) AS element_type_\\d+\\) = 'String'\\), defaultValueOfTypeName\\(if\\(element_type_\\d+ = 'Nothing', 'Nullable\\(Nothing\\)', element_type_\\d+\\)\\), C\\) AS fill_value_\\d+\\))\"\n+        },\n+        {\n+            \"print array_slice(A, B, C)\",\n+            R\"(SELECT arraySlice\\(A, 1 \\+ if\\(B >= 0, B, arrayMax\\(\\[-length\\(A\\), B\\]\\) \\+ length\\(A\\)\\) AS offset_\\d+, \\(\\(1 \\+ if\\(C >= 0, C, arrayMax\\(\\[-length\\(A\\), C\\]\\) \\+ length\\(A\\)\\)\\) - offset_\\d+\\) \\+ 1\\))\"\n+        },\n+        {\n+            \"print array_split(A, B)\",\n+            R\"(SELECT if\\(empty\\(arrayMap\\(x -> if\\(x >= 0, x, arrayMax\\(\\[0, x \\+ CAST\\(length\\(A\\), 'Int\\d+'\\)\\]\\)\\), flatten\\(\\[B\\]\\)\\) AS indices_\\d+\\), \\[A\\], arrayConcat\\(\\[arraySlice\\(A, 1, indices_\\d+\\[1\\]\\)\\], arrayMap\\(i -> arraySlice\\(A, \\(indices_\\d+\\[i\\]\\) \\+ 1, if\\(i = length\\(indices_\\d+\\), CAST\\(length\\(A\\), 'Int\\d+'\\), CAST\\(indices_\\d+\\[i \\+ 1\\], 'Int\\d+'\\)\\) - \\(indices_\\d+\\[i\\]\\)\\), range\\(1, length\\(indices_\\d+\\) \\+ 1\\)\\)\\)\\))\"\n+        },\n+        {\n+            \"print zip(A, B)\",\n+            R\"(SELECT arrayMap\\(t -> \\[untuple\\(t\\)\\], arrayZip\\(arrayResize\\(arg0_\\d+, arrayMax\\(\\[length\\(if\\(match\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(Nullable\\\\\\\\\\(\\.\\*\\\\\\\\\\)\\\\\\\\\\)'\\), A, CAST\\(A, concat\\('Array\\(Nullable\\(', extract\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\), '\\)\\)'\\)\\)\\) AS arg0_\\d+\\), length\\(if\\(match\\(toTypeName\\(B\\), 'Array\\\\\\\\\\(Nullable\\\\\\\\\\(\\.\\*\\\\\\\\\\)\\\\\\\\\\)'\\), B, CAST\\(B, concat\\('Array\\(Nullable\\(', extract\\(toTypeName\\(B\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\), '\\)\\)'\\)\\)\\) AS arg1_\\d+\\)\\]\\) AS max_length_\\d+, NULL\\), arrayResize\\(arg1_\\d+, max_length_\\d+, NULL\\)\\)\\))\"\n+        },\n+        {\n+            \"print zip(A, B, C)\",\n+            R\"(SELECT arrayMap\\(t -> \\[untuple\\(t\\)\\], arrayZip\\(arrayResize\\(arg0_\\d+, arrayMax\\(\\[length\\(if\\(match\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(Nullable\\\\\\\\\\(\\.\\*\\\\\\\\\\)\\\\\\\\\\)'\\), A, CAST\\(A, concat\\('Array\\(Nullable\\(', extract\\(toTypeName\\(A\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\), '\\)\\)'\\)\\)\\) AS arg0_\\d+\\), length\\(if\\(match\\(toTypeName\\(B\\), 'Array\\\\\\\\\\(Nullable\\\\\\\\\\(\\.\\*\\\\\\\\\\)\\\\\\\\\\)'\\), B, CAST\\(B, concat\\('Array\\(Nullable\\(', extract\\(toTypeName\\(B\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\), '\\)\\)'\\)\\)\\) AS arg1_\\d+\\), length\\(if\\(match\\(toTypeName\\(C\\), 'Array\\\\\\\\\\(Nullable\\\\\\\\\\(\\.\\*\\\\\\\\\\)\\\\\\\\\\)'\\), C, CAST\\(C, concat\\('Array\\(Nullable\\(', extract\\(toTypeName\\(C\\), 'Array\\\\\\\\\\(\\(\\.\\*\\)\\\\\\\\\\)'\\), '\\)\\)'\\)\\)\\) AS arg2_\\d+\\)\\]\\) AS max_length_\\d+, NULL\\), arrayResize\\(arg1_\\d+, max_length_\\d+, NULL\\), arrayResize\\(arg2_\\d+, max_length_\\d+, NULL\\)\\)\\))\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_IP.cpp b/src/Parsers/tests/KQL/gtest_KQL_IP.cpp\nnew file mode 100644\nindex 000000000000..5cc08ee89b49\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_IP.cpp\n@@ -0,0 +1,85 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_IP, ParserRegexTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print format_ipv4(A)\",\n+            R\"(SELECT ifNull\\(if\\(\\(\\(\\(toUInt32OrNull\\(toString\\(A\\)\\) AS param_as_uint32_\\d+\\) IS NOT NULL\\) AND \\(toTypeName\\(A\\) = 'String'\\)\\) OR \\(32 < 0\\) OR \\(\\(ifNull\\(param_as_uint32_\\d+, multiIf\\(length\\(splitByChar\\('/', ifNull\\(toString\\(A\\), ''\\)\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\).1\\)\\), NULL\\)\\) AS ip_as_number_\\d+\\) IS NULL\\), NULL, IPv4NumToString\\(bitAnd\\(ip_as_number_\\d+, bitNot\\(toUInt32\\(intExp2\\(toInt32\\(32 - 32\\)\\) - 1\\)\\)\\)\\)\\), ''\\))\"\n+        },\n+        {\n+            \"print format_ipv4(A, B)\",\n+            R\"(SELECT ifNull\\(if\\(\\(\\(\\(toUInt32OrNull\\(toString\\(A\\)\\) AS param_as_uint32_\\d+\\) IS NOT NULL\\) AND \\(toTypeName\\(A\\) = 'String'\\)\\) OR \\(B < 0\\) OR \\(\\(ifNull\\(param_as_uint32_\\d+, multiIf\\(length\\(splitByChar\\('/', ifNull\\(toString\\(A\\), ''\\)\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\).1\\)\\), NULL\\)\\) AS ip_as_number_\\d+\\) IS NULL\\), NULL, IPv4NumToString\\(bitAnd\\(ip_as_number_\\d+, bitNot\\(toUInt32\\(intExp2\\(toInt32\\(32 - B\\)\\) - 1\\)\\)\\)\\)\\), ''\\))\"\n+        },\n+        {\n+            \"print format_ipv4_mask(A)\",\n+            R\"(SELECT if\\(empty\\(ifNull\\(if\\(\\(\\(\\(toUInt32OrNull\\(toString\\(A\\)\\) AS param_as_uint32_\\d+\\) IS NOT NULL\\) AND \\(toTypeName\\(A\\) = 'String'\\)\\) OR \\(32 < 0\\) OR \\(\\(ifNull\\(param_as_uint32_\\d+, multiIf\\(length\\(splitByChar\\('/', ifNull\\(toString\\(A\\), ''\\)\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\).1\\)\\), NULL\\)\\) AS ip_as_number_\\d+\\) IS NULL\\), NULL, IPv4NumToString\\(bitAnd\\(ip_as_number_\\d+, bitNot\\(toUInt32\\(intExp2\\(toInt32\\(32 - 32\\)\\) - 1\\)\\)\\)\\)\\), ''\\) AS formatted_ip_\\d+\\) OR \\(position\\(toTypeName\\(32\\), 'Int'\\) = 0\\) OR \\(NOT \\(\\(32 >= 0\\) AND \\(32 <= 32\\)\\)\\), '', concat\\(formatted_ip_\\d+, '/', toString\\(toInt64\\(min2\\(32, ifNull\\(multiIf\\(\\(length\\(splitByChar\\('/', ifNull\\(toString\\(A\\), ''\\)\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\) AS suffix_\\d+, 32\\)\\)\\)\\)\\)\\))\"\n+        },\n+        {\n+            \"print format_ipv4_mask(A, B)\",\n+            R\"(SELECT if\\(empty\\(ifNull\\(if\\(\\(\\(\\(toUInt\\d+OrNull\\(toString\\(A\\)\\) AS param_as_uint\\d+_\\d+\\) IS NOT NULL\\) AND \\(toTypeName\\(A\\) = 'String'\\)\\) OR \\(B < 0\\) OR \\(\\(ifNull\\(param_as_uint\\d+_\\d+, multiIf\\(length\\(splitByChar\\('/', ifNull\\(toString\\(A\\), ''\\)\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\)\\) AS ip_as_number_\\d+\\) IS NULL\\), NULL, IPv4NumToString\\(bitAnd\\(ip_as_number_\\d+, bitNot\\(toUInt\\d+\\(intExp2\\(toInt32\\(\\d+ - B\\)\\) - 1\\)\\)\\)\\)\\), ''\\) AS formatted_ip_\\d+\\) OR \\(position\\(toTypeName\\(B\\), 'Int'\\) = 0\\) OR \\(NOT \\(\\(B >= 0\\) AND \\(B <= \\d+\\)\\)\\), '', concat\\(formatted_ip_\\d+, '/', toString\\(toInt\\d+\\(min2\\(B, ifNull\\(multiIf\\(\\(length\\(splitByChar\\('/', ifNull\\(toString\\(A\\), ''\\)\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, \\d+, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, \\d+\\)\\)\\) AS suffix_\\d+, \\d+\\)\\)\\)\\)\\)\\))\"\n+        },\n+        {\n+            \"print ipv4_compare(A, B)\",\n+            R\"(SELECT if\\(\\(\\(multiIf\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS lhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, \\d+, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, \\d+\\)\\)\\) AS lhs_mask_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS rhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, \\d+, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, \\d+\\)\\)\\) AS rhs_mask_\\d+\\) IS NULL\\), NULL, sign\\(IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(lhs_ip_\\d+\\), toUInt8\\(min2\\(\\d+, min2\\(assumeNotNull\\(lhs_mask_\\d+\\), assumeNotNull\\(rhs_mask_\\d+\\)\\)\\)\\) AS mask_\\d+\\)\\.1\\)\\) - IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(rhs_ip_\\d+\\), mask_\\d+\\)\\.1\\)\\)\\)\\))\"\n+        },\n+        {\n+            \"print ipv4_compare(A, B, C)\",\n+            R\"(SELECT if\\(\\(\\(multiIf\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS lhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, \\d+, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, \\d+\\)\\)\\) AS lhs_mask_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS rhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, \\d+, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, \\d+\\)\\)\\) AS rhs_mask_\\d+\\) IS NULL\\), NULL, sign\\(IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(lhs_ip_\\d+\\), toUInt8\\(min2\\(C, min2\\(assumeNotNull\\(lhs_mask_\\d+\\), assumeNotNull\\(rhs_mask_\\d+\\)\\)\\)\\) AS mask_\\d+\\)\\.1\\)\\) - IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(rhs_ip_\\d+\\), mask_\\d+\\)\\.1\\)\\)\\)\\))\"\n+        },\n+        {\n+            \"print ipv6_compare(A, B)\",\n+            R\"(SELECT if\\(\\(length\\(splitByChar\\('/', A\\) AS lhs_tokens_\\d+\\) > 2\\) OR \\(length\\(splitByChar\\('/', B\\) AS rhs_tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(lhs_tokens_\\d+\\[1\\]\\) AS lhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(lhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(lhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(lhs_tokens_\\d+\\[-1\\]\\)\\) AS lhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(IPv6StringToNumOrNull\\(rhs_tokens_\\d+\\[1\\]\\) AS rhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(rhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(rhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(rhs_tokens_\\d+\\[-1\\]\\)\\) AS rhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(toUInt8\\(min2\\(128, min2\\(ifNull\\(lhs_suffix_\\d+, 128\\), ifNull\\(rhs_suffix_\\d+, 128\\)\\)\\)\\) AS suffix_\\d+\\) IS NULL\\) OR \\(\\(bitShiftLeft\\(bitShiftRight\\(bitNot\\(reinterpretAsFixedString\\(CAST\\('0', 'UInt128'\\)\\)\\), 128 - suffix_\\d+ AS zeroes_\\d+\\), zeroes_\\d+\\) AS mask_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(lhs_ipv6_\\d+, mask_\\d+\\) AS lhs_base_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(rhs_ipv6_\\d+, mask_\\d+\\) AS rhs_base_\\d+\\) IS NULL\\), NULL, multiIf\\(lhs_base_\\d+ < rhs_base_\\d+, -1, lhs_base_\\d+ > rhs_base_\\d+, 1, 0\\)\\))\"\n+        },\n+        {\n+            \"print ipv6_compare(A, B, C)\",\n+            R\"(SELECT if\\(\\(length\\(splitByChar\\('/', A\\) AS lhs_tokens_\\d+\\) > 2\\) OR \\(length\\(splitByChar\\('/', B\\) AS rhs_tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(lhs_tokens_\\d+\\[1\\]\\) AS lhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(lhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(lhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(lhs_tokens_\\d+\\[-1\\]\\)\\) AS lhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(IPv6StringToNumOrNull\\(rhs_tokens_\\d+\\[1\\]\\) AS rhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(rhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(rhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(rhs_tokens_\\d+\\[-1\\]\\)\\) AS rhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(toUInt8\\(min2\\(C, min2\\(ifNull\\(lhs_suffix_\\d+, 128\\), ifNull\\(rhs_suffix_\\d+, 128\\)\\)\\)\\) AS suffix_\\d+\\) IS NULL\\) OR \\(\\(bitShiftLeft\\(bitShiftRight\\(bitNot\\(reinterpretAsFixedString\\(CAST\\('0', 'UInt128'\\)\\)\\), 128 - suffix_\\d+ AS zeroes_\\d+\\), zeroes_\\d+\\) AS mask_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(lhs_ipv6_\\d+, mask_\\d+\\) AS lhs_base_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(rhs_ipv6_\\d+, mask_\\d+\\) AS rhs_base_\\d+\\) IS NULL\\), NULL, multiIf\\(lhs_base_\\d+ < rhs_base_\\d+, -1, lhs_base_\\d+ > rhs_base_\\d+, 1, 0\\)\\))\"\n+        },\n+        {\n+            \"print ipv4_is_in_range(A, B)\",\n+            R\"(SELECT if\\(\\(\\(IPv4StringToNumOrNull\\(A\\) AS ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS range_start_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\) AS range_mask_\\d+\\) IS NULL\\), NULL, bitXor\\(range_start_ip_\\d+, bitAnd\\(ip_\\d+, bitNot\\(toUInt32\\(intExp2\\(toInt32\\(32 - range_mask_\\d+\\)\\) - 1\\)\\)\\)\\) = 0\\))\"\n+        },\n+        {\n+            \"print ipv4_is_match(A, B)\",\n+            R\"(SELECT if\\(\\(\\(multiIf\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS lhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\) AS lhs_mask_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS rhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\) AS rhs_mask_\\d+\\) IS NULL\\), NULL, sign\\(IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(lhs_ip_\\d+\\), toUInt8\\(min2\\(32, min2\\(assumeNotNull\\(lhs_mask_\\d+\\), assumeNotNull\\(rhs_mask_\\d+\\)\\)\\)\\) AS mask_\\d+\\)\\.1\\)\\) - IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(rhs_ip_\\d+\\), mask_\\d+\\)\\.1\\)\\)\\)\\) = 0)\"\n+        },\n+        {\n+            \"print ipv4_is_match(A, B, C)\",\n+            R\"(SELECT if\\(\\(\\(multiIf\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS lhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\) AS lhs_mask_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\) AS rhs_ip_\\d+\\) IS NULL\\) OR \\(\\(multiIf\\(\\(length\\(splitByChar\\('/', B\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\) AS rhs_mask_\\d+\\) IS NULL\\), NULL, sign\\(IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(lhs_ip_\\d+\\), toUInt8\\(min2\\(C, min2\\(assumeNotNull\\(lhs_mask_\\d+\\), assumeNotNull\\(rhs_mask_\\d+\\)\\)\\)\\) AS mask_\\d+\\)\\.1\\)\\) - IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(assumeNotNull\\(rhs_ip_\\d+\\), mask_\\d+\\)\\.1\\)\\)\\)\\) = 0)\"\n+        },\n+        {\n+            \"print ipv6_is_match(A, B)\",\n+            R\"(SELECT if\\(\\(length\\(splitByChar\\('/', A\\) AS lhs_tokens_\\d+\\) > 2\\) OR \\(length\\(splitByChar\\('/', B\\) AS rhs_tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(lhs_tokens_\\d+\\[1\\]\\) AS lhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(lhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(lhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(lhs_tokens_\\d+\\[-1\\]\\)\\) AS lhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(IPv6StringToNumOrNull\\(rhs_tokens_\\d+\\[1\\]\\) AS rhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(rhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(rhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(rhs_tokens_\\d+\\[-1\\]\\)\\) AS rhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(toUInt8\\(min2\\(128, min2\\(ifNull\\(lhs_suffix_\\d+, 128\\), ifNull\\(rhs_suffix_\\d+, 128\\)\\)\\)\\) AS suffix_\\d+\\) IS NULL\\) OR \\(\\(bitShiftLeft\\(bitShiftRight\\(bitNot\\(reinterpretAsFixedString\\(CAST\\('0', 'UInt128'\\)\\)\\), 128 - suffix_\\d+ AS zeroes_\\d+\\), zeroes_\\d+\\) AS mask_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(lhs_ipv6_\\d+, mask_\\d+\\) AS lhs_base_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(rhs_ipv6_\\d+, mask_\\d+\\) AS rhs_base_\\d+\\) IS NULL\\), NULL, multiIf\\(lhs_base_\\d+ < rhs_base_\\d+, -1, lhs_base_\\d+ > rhs_base_\\d+, 1, 0\\)\\) = 0)\"\n+        },\n+        {\n+            \"print ipv6_is_match(A, B, C)\",\n+            R\"(SELECT if\\(\\(length\\(splitByChar\\('/', A\\) AS lhs_tokens_\\d+\\) > 2\\) OR \\(length\\(splitByChar\\('/', B\\) AS rhs_tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(lhs_tokens_\\d+\\[1\\]\\) AS lhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(lhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(lhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(lhs_tokens_\\d+\\[-1\\]\\)\\) AS lhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(IPv6StringToNumOrNull\\(rhs_tokens_\\d+\\[1\\]\\) AS rhs_ipv6_\\d+\\) IS NULL\\) OR \\(\\(length\\(rhs_tokens_\\d+\\) = 2\\) AND \\(\\(\\(if\\(isIPv4String\\(rhs_tokens_\\d+\\[1\\]\\), 96, 0\\) \\+ toUInt8OrNull\\(rhs_tokens_\\d+\\[-1\\]\\)\\) AS rhs_suffix_\\d+\\) IS NULL\\)\\) OR \\(\\(toUInt8\\(min2\\(C, min2\\(ifNull\\(lhs_suffix_\\d+, 128\\), ifNull\\(rhs_suffix_\\d+, 128\\)\\)\\)\\) AS suffix_\\d+\\) IS NULL\\) OR \\(\\(bitShiftLeft\\(bitShiftRight\\(bitNot\\(reinterpretAsFixedString\\(CAST\\('0', 'UInt128'\\)\\)\\), 128 - suffix_\\d+ AS zeroes_\\d+\\), zeroes_\\d+\\) AS mask_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(lhs_ipv6_\\d+, mask_\\d+\\) AS lhs_base_\\d+\\) IS NULL\\) OR \\(\\(bitAnd\\(rhs_ipv6_\\d+, mask_\\d+\\) AS rhs_base_\\d+\\) IS NULL\\), NULL, multiIf\\(lhs_base_\\d+ < rhs_base_\\d+, -1, lhs_base_\\d+ > rhs_base_\\d+, 1, 0\\)\\) = 0)\"\n+        },\n+        {\n+            \"print ipv4_is_private(A)\",\n+            R\"(SELECT multiIf\\(\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) > 2\\) OR \\(\\(toIPv4OrNull\\(tokens_\\d+\\[1\\]\\) AS nullable_ip_\\d+\\) IS NULL\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL\\)\\), NULL, ignore\\(assumeNotNull\\(nullable_ip_\\d+\\) AS ip_\\d+, IPv4CIDRToRange\\(ip_\\d+, assumeNotNull\\(mask_\\d+\\)\\) AS range_\\d+, IPv4NumToString\\(range_\\d+.1\\) AS begin_\\d+, IPv4NumToString\\(range_\\d+.2\\) AS end_\\d+\\), NULL, \\(\\(length\\(tokens_\\d+\\) = 1\\) AND isIPAddressInRange\\(IPv4NumToString\\(ip_\\d+\\), '10.0.0.0/8'\\)\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND isIPAddressInRange\\(begin_\\d+, '10.0.0.0/8'\\) AND isIPAddressInRange\\(end_\\d+, '10.0.0.0/8'\\)\\) OR \\(\\(length\\(tokens_\\d+\\) = 1\\) AND isIPAddressInRange\\(IPv4NumToString\\(ip_\\d+\\), '172.16.0.0/12'\\)\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND isIPAddressInRange\\(begin_\\d+, '172.16.0.0/12'\\) AND isIPAddressInRange\\(end_\\d+, '172.16.0.0/12'\\)\\) OR \\(\\(length\\(tokens_\\d+\\) = 1\\) AND isIPAddressInRange\\(IPv4NumToString\\(ip_\\d+\\), '192.168.0.0/16'\\)\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND isIPAddressInRange\\(begin_\\d+, '192.168.0.0/16'\\) AND isIPAddressInRange\\(end_\\d+, '192.168.0.0/16'\\)\\)\\))\"\n+        },\n+        {\n+            \"print ipv4_netmask_suffix(A)\",\n+            R\"(SELECT multiIf\\(\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) > 2\\) OR \\(NOT isIPv4String\\(tokens_\\d+\\[1\\]\\)\\), NULL, length\\(tokens_\\d+\\) = 1, 32, \\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL, NULL, toUInt8\\(min2\\(mask_\\d+, 32\\)\\)\\))\"\n+        },\n+        {\n+            \"print parse_ipv4(A)\",\n+            R\"(SELECT multiIf\\(length\\(splitByChar\\('/', A\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\))\"\n+        },\n+        {\n+            \"print parse_ipv4_mask(A, B)\",\n+            R\"(SELECT if\\(\\(\\(toIPv4OrNull\\(A\\) AS ip_\\d+\\) IS NULL\\) OR \\(\\(toUInt8OrNull\\(toString\\(B\\)\\) AS mask_\\d+\\) IS NULL\\), NULL, toUInt32\\(IPv4CIDRToRange\\(assumeNotNull\\(ip_\\d+\\), arrayMax\\(\\[0, arrayMin\\(\\[32, assumeNotNull\\(mask_\\d+\\)\\]\\)\\]\\)\\).1\\)\\))\"\n+        },\n+        {\n+            \"print parse_ipv6(A)\",\n+            R\"(SELECT if\\(\\(length\\(splitByChar\\('/', assumeNotNull\\(A\\)\\) AS tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+\\) IS NULL\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL\\)\\), NULL, arrayStringConcat\\(flatten\\(extractAllGroups\\(lower\\(hex\\(IPv6CIDRToRange\\(assumeNotNull\\(ip_\\d+\\), toUInt8\\(ifNull\\(mask_\\d+ \\+ if\\(isIPv4String\\(tokens_\\d+\\[1\\]\\), 96, 0\\), 128\\)\\)\\)\\.1\\)\\), '\\(\\[\\\\\\\\da-f\\]\\{4\\}\\)'\\)\\), ':'\\)\\))\"\n+        },\n+        {\n+            \"print parse_ipv6_mask(A, B)\",\n+            R\"(SELECT if\\(empty\\(ifNull\\(if\\(\\(\\(\\(toUInt32OrNull\\(toString\\(replaceRegexpOne\\(A, concat\\('\\^', '::'\\), ''\\)\\)\\) AS param_as_uint32_\\d+\\) IS NOT NULL\\) AND \\(toTypeName\\(replaceRegexpOne\\(A, concat\\('\\^', '::'\\), ''\\)\\) = 'String'\\)\\) OR \\(\\(B - 96\\) < 0\\) OR \\(\\(ifNull\\(param_as_uint32_\\d+, multiIf\\(length\\(splitByChar\\('/', ifNull\\(toString\\(replaceRegexpOne\\(A, concat\\('\\^', '::'\\), ''\\)\\), ''\\)\\) AS tokens_\\d+\\) = 1, IPv4StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+, \\(length\\(tokens_\\d+\\) = 2\\) AND \\(ip_\\d+ IS NOT NULL\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NOT NULL\\), IPv4StringToNumOrNull\\(toString\\(IPv4CIDRToRange\\(toIPv4\\(assumeNotNull\\(ip_\\d+\\)\\), assumeNotNull\\(mask_\\d+\\)\\)\\.1\\)\\), NULL\\)\\) AS ip_as_number_\\d+\\) IS NULL\\), NULL, IPv4NumToString\\(bitAnd\\(ip_as_number_\\d+, bitNot\\(toUInt32\\(intExp2\\(toInt32\\(32 - \\(B - 96\\)\\)\\) - 1\\)\\)\\)\\)\\), ''\\) AS ipv4_\\d+\\), if\\(\\(length\\(splitByChar\\('/', assumeNotNull\\(concat\\(ifNull\\(toString\\(if\\(\\(length\\(splitByChar\\('/', assumeNotNull\\(A\\)\\) AS tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+\\) IS NULL\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL\\)\\), NULL, arrayStringConcat\\(flatten\\(extractAllGroups\\(lower\\(hex\\(IPv6CIDRToRange\\(assumeNotNull\\(ip_\\d+\\), toUInt8\\(ifNull\\(mask_\\d+ \\+ if\\(isIPv4String\\(tokens_\\d+\\[1\\]\\), 96, 0\\), 128\\)\\)\\)\\.1\\)\\), '\\(\\[\\\\\\\\da-f\\]\\{4\\}\\)'\\)\\), ':'\\)\\)\\), ''\\), '/', ifNull\\(toString\\(B\\), ''\\)\\)\\)\\) AS tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+\\) IS NULL\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL\\)\\), NULL, arrayStringConcat\\(flatten\\(extractAllGroups\\(lower\\(hex\\(IPv6CIDRToRange\\(assumeNotNull\\(ip_\\d+\\), toUInt8\\(ifNull\\(mask_\\d+ \\+ if\\(isIPv4String\\(tokens_\\d+\\[1\\]\\), 96, 0\\), 128\\)\\)\\)\\.1\\)\\), '\\(\\[\\\\\\\\da-f\\]\\{4\\}\\)'\\)\\), ':'\\)\\), if\\(\\(length\\(splitByChar\\('/', assumeNotNull\\(ipv4_\\d+\\)\\) AS tokens_\\d+\\) > 2\\) OR \\(\\(IPv6StringToNumOrNull\\(tokens_\\d+\\[1\\]\\) AS ip_\\d+\\) IS NULL\\) OR \\(\\(length\\(tokens_\\d+\\) = 2\\) AND \\(\\(toUInt8OrNull\\(tokens_\\d+\\[-1\\]\\) AS mask_\\d+\\) IS NULL\\)\\), NULL, arrayStringConcat\\(flatten\\(extractAllGroups\\(lower\\(hex\\(IPv6CIDRToRange\\(assumeNotNull\\(ip_\\d+\\), toUInt8\\(ifNull\\(mask_\\d+ \\+ if\\(isIPv4String\\(tokens_\\d+\\[1\\]\\), 96, 0\\), 128\\)\\)\\)\\.1\\)\\), '\\(\\[\\\\\\\\da-f\\]\\{4\\}\\)'\\)\\), ':'\\)\\)\\))\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_MVExpand.cpp b/src/Parsers/tests/KQL/gtest_KQL_MVExpand.cpp\nnew file mode 100644\nindex 000000000000..b90a700c620f\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_MVExpand.cpp\n@@ -0,0 +1,45 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_MVExpand, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"T | mv-expand c\",\n+            \"SELECT *\\nFROM T\\nARRAY JOIN c\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand c, d\",\n+            \"SELECT *\\nFROM T\\nARRAY JOIN\\n    c,\\n    d\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand c to typeof(bool)\",\n+            \"SELECT\\n    * EXCEPT c_ali,\\n    c_ali AS c\\nFROM\\n(\\n    SELECT\\n        * EXCEPT c,\\n        accurateCastOrNull(toInt64OrNull(toString(c)), 'Boolean') AS c_ali\\n    FROM\\n    (\\n        SELECT *\\n        FROM T\\n        ARRAY JOIN c\\n    )\\n)\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand b | mv-expand c\",\n+            \"SELECT *\\nFROM\\n(\\n    SELECT *\\n    FROM T\\n    ARRAY JOIN b\\n    SETTINGS enable_unaligned_array_join = 1\\n)\\nARRAY JOIN c\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand with_itemindex=index b, c, d\",\n+            \"SELECT\\n    index,\\n    *\\nFROM T\\nARRAY JOIN\\n    b,\\n    c,\\n    d,\\n    range(0, arrayMax([length(b), length(c), length(d)])) AS index\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand array_concat(c,d)\",\n+            \"SELECT\\n    *,\\n    array_concat_\\nFROM T\\nARRAY JOIN arrayConcat(c, d) AS array_concat_\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand x = c, y = d\",\n+            \"SELECT\\n    *,\\n    x,\\n    y\\nFROM T\\nARRAY JOIN\\n    c AS x,\\n    d AS y\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand xy = array_concat(c, d)\",\n+            \"SELECT\\n    *,\\n    xy\\nFROM T\\nARRAY JOIN arrayConcat(c, d) AS xy\\nSETTINGS enable_unaligned_array_join = 1\"\n+        },\n+        {\n+            \"T | mv-expand with_itemindex=index c,d to typeof(bool)\",\n+            \"SELECT\\n    * EXCEPT d_ali,\\n    d_ali AS d\\nFROM\\n(\\n    SELECT\\n        * EXCEPT d,\\n        accurateCastOrNull(toInt64OrNull(toString(d)), 'Boolean') AS d_ali\\n    FROM\\n    (\\n        SELECT\\n            index,\\n            *\\n        FROM T\\n        ARRAY JOIN\\n            c,\\n            d,\\n            range(0, arrayMax([length(c), length(d)])) AS index\\n    )\\n)\\nSETTINGS enable_unaligned_array_join = 1\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_MakeSeries.cpp b/src/Parsers/tests/KQL/gtest_KQL_MakeSeries.cpp\nnew file mode 100644\nindex 000000000000..533b037190da\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_MakeSeries.cpp\n@@ -0,0 +1,25 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_MakeSeries, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"T |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 1d by Supplier, Fruit\",\n+            \"SELECT\\n    Supplier,\\n    Fruit,\\n    zipped.1 AS Purchase,\\n    zipped.2 AS PriceAvg\\nFROM\\n(\\n    SELECT\\n        toUInt64(min(Purchase_ali)) AS low,\\n        toUInt64(max(Purchase_ali)) + 86400 AS high,\\n        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,\\n        Supplier,\\n        Fruit,\\n        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(toUInt64(toDateTime64('2016-09-10', 9, 'UTC')), toUInt64(toDateTime64('2016-09-13', 9, 'UTC')), toUInt64(86400))) - length(ga)) < 0, 0, length(range(toUInt64(toDateTime64('2016-09-10', 9, 'UTC')), toUInt64(toDateTime64('2016-09-13', 9, 'UTC')), toUInt64(86400))) - length(ga))), 1))) AS PriceAvg,\\n        arrayDistinct(arrayConcat(groupArray(toDateTime64(Purchase_ali - 0, 9, 'UTC')), arrayMap(x -> toDateTime64(x - 0, 9, 'UTC'), range(toUInt64(toDateTime64('2016-09-10', 9, 'UTC')), toUInt64(toDateTime64('2016-09-13', 9, 'UTC')), toUInt64(86400))))) AS Purchase\\n    FROM\\n    (\\n        SELECT\\n            Supplier,\\n            Fruit,\\n            avg(Price) AS PriceAvg_ali,\\n            toFloat64(toDateTime64('2016-09-10', 9, 'UTC')) + (toInt64((toFloat64(toDateTime64(Purchase, 9, 'UTC')) - toFloat64(toDateTime64('2016-09-10', 9, 'UTC'))) / 86400) * 86400) AS Purchase_ali\\n        FROM T\\n        WHERE (toInt64(toFloat64(toDateTime64(Purchase, 9, 'UTC'))) >= toUInt64(toDateTime64('2016-09-10', 9, 'UTC'))) AND (toInt64(toFloat64(toDateTime64(Purchase, 9, 'UTC'))) < toUInt64(toDateTime64('2016-09-13', 9, 'UTC')))\\n        GROUP BY\\n            Supplier,\\n            Fruit,\\n            Purchase_ali\\n        ORDER BY Purchase_ali ASC\\n    )\\n    GROUP BY\\n        Supplier,\\n        Fruit\\n)\"\n+        },\n+        {\n+            \"T2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 to  15 step  1.0  by Supplier, Fruit\",\n+            \"SELECT\\n    Supplier,\\n    Fruit,\\n    zipped.1 AS Purchase,\\n    zipped.2 AS PriceAvg\\nFROM\\n(\\n    SELECT\\n        toUInt64(min(Purchase_ali)) AS low,\\n        toUInt64(max(Purchase_ali)) + 1 AS high,\\n        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,\\n        Supplier,\\n        Fruit,\\n        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(toUInt64(10), toUInt64(15), toUInt64(1))) - length(ga)) < 0, 0, length(range(toUInt64(10), toUInt64(15), toUInt64(1))) - length(ga))), 1))) AS PriceAvg,\\n        arrayDistinct(arrayConcat(groupArray(Purchase_ali), arrayMap(x -> toFloat64(x), range(toUInt64(10), toUInt64(15), toUInt64(1))))) AS Purchase\\n    FROM\\n    (\\n        SELECT\\n            Supplier,\\n            Fruit,\\n            avg(Price) AS PriceAvg_ali,\\n            toFloat64(10) + (toInt64((toFloat64(Purchase) - toFloat64(10)) / 1) * 1) AS Purchase_ali\\n        FROM T2\\n        WHERE (toInt64(toFloat64(Purchase)) >= toUInt64(10)) AND (toInt64(toFloat64(Purchase)) < toUInt64(15))\\n        GROUP BY\\n            Supplier,\\n            Fruit,\\n            Purchase_ali\\n        ORDER BY Purchase_ali ASC\\n    )\\n    GROUP BY\\n        Supplier,\\n        Fruit\\n)\"\n+        },\n+        {\n+            \"T |  make-series PriceAvg = avg(Price) default=0 on Purchase step 1d by Supplier, Fruit\",\n+            \"SELECT\\n    Supplier,\\n    Fruit,\\n    zipped.1 AS Purchase,\\n    zipped.2 AS PriceAvg\\nFROM\\n(\\n    SELECT\\n        toUInt64(min(Purchase_ali)) AS low,\\n        toUInt64(max(Purchase_ali)) + 86400 AS high,\\n        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,\\n        Supplier,\\n        Fruit,\\n        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(low, high, toUInt64(86400))) - length(ga)) < 0, 0, length(range(low, high, toUInt64(86400))) - length(ga))), 1))) AS PriceAvg,\\n        arrayDistinct(arrayConcat(groupArray(toDateTime64(Purchase_ali - 62135596800, 9, 'UTC')), arrayMap(x -> toDateTime64(x - 62135596800, 9, 'UTC'), range(low, high, toUInt64(86400))))) AS Purchase\\n    FROM\\n    (\\n        SELECT\\n            Supplier,\\n            Fruit,\\n            avg(Price) AS PriceAvg_ali,\\n            toFloat64(toInt64((toFloat64(toDateTime64(Purchase, 9, 'UTC')) + 62135596800) / 86400) * 86400) AS Purchase_ali\\n        FROM T\\n        GROUP BY\\n            Supplier,\\n            Fruit,\\n            Purchase_ali\\n        ORDER BY Purchase_ali ASC\\n    )\\n    GROUP BY\\n        Supplier,\\n        Fruit\\n)\"\n+        },\n+        {\n+            \"T2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  1.0  by Supplier, Fruit\",\n+            \"SELECT\\n    Supplier,\\n    Fruit,\\n    zipped.1 AS Purchase,\\n    zipped.2 AS PriceAvg\\nFROM\\n(\\n    SELECT\\n        toUInt64(min(Purchase_ali)) AS low,\\n        toUInt64(max(Purchase_ali)) + 1 AS high,\\n        arraySort(arrayZip(Purchase, PriceAvg)) AS zipped,\\n        Supplier,\\n        Fruit,\\n        arrayConcat(groupArray(PriceAvg_ali) AS ga, arrayMap(x -> 0, range(0, toUInt32(if((length(range(low, high, toUInt64(1))) - length(ga)) < 0, 0, length(range(low, high, toUInt64(1))) - length(ga))), 1))) AS PriceAvg,\\n        arrayDistinct(arrayConcat(groupArray(Purchase_ali), arrayMap(x -> toFloat64(x), range(low, high, toUInt64(1))))) AS Purchase\\n    FROM\\n    (\\n        SELECT\\n            Supplier,\\n            Fruit,\\n            avg(Price) AS PriceAvg_ali,\\n            toFloat64(toInt64((toFloat64(Purchase) + 0) / 1) * 1) AS Purchase_ali\\n        FROM T2\\n        GROUP BY\\n            Supplier,\\n            Fruit,\\n            Purchase_ali\\n        ORDER BY Purchase_ali ASC\\n    )\\n    GROUP BY\\n        Supplier,\\n        Fruit\\n)\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_StringFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_StringFunctions.cpp\nnew file mode 100644\nindex 000000000000..40a6922210fe\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_StringFunctions.cpp\n@@ -0,0 +1,225 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_String, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print base64_encode_fromguid(A)\",\n+            \"SELECT if(toTypeName(A) NOT IN ['UUID', 'Nullable(UUID)'], toString(throwIf(true, 'Expected guid as argument')), base64Encode(UUIDStringToNum(toString(A), 2)))\"\n+        },\n+        {\n+            \"print base64_decode_toguid(A)\",\n+            \"SELECT toUUIDOrNull(UUIDNumToString(toFixedString(base64Decode(A), 16), 2))\"\n+        },\n+        {\n+            \"print base64_decode_toarray('S3VzdG8=')\",\n+            \"SELECT arrayMap(x -> reinterpretAsUInt8(x), splitByRegexp('', base64Decode('S3VzdG8=')))\"\n+        },\n+        {\n+            \"print replace_regex('Hello, World!', '.', '\\\\0\\\\0')\",\n+            \"SELECT replaceRegexpAll('Hello, World!', '.', '\\\\0\\\\0')\"\n+        },\n+        {\n+            \"print idx = has_any_index('this is an example', dynamic(['this', 'example'])) \",\n+            \"SELECT if(empty(['this', 'example']), -1, indexOf(arrayMap(x -> (x IN splitByChar(' ', 'this is an example')), if(empty(['this', 'example']), [''], arrayMap(x -> toString(x), ['this', 'example']))), 1) - 1) AS idx\"\n+        },\n+        {\n+            \"print idx = has_any_index('this is an example', dynamic([]))\",\n+            \"SELECT if(empty([]), -1, indexOf(arrayMap(x -> (x IN splitByChar(' ', 'this is an example')), if(empty([]), [''], arrayMap(x -> toString(x), []))), 1) - 1) AS idx\"\n+        },\n+        {\n+            \"print translate('krasp', 'otsku', 'spark')\",\n+            \"SELECT if(length('otsku') = 0, '', translate('spark', 'krasp', multiIf(length('otsku') = 0, 'krasp', (length('krasp') - length('otsku')) > 0, concat('otsku', repeat(substr('otsku', length('otsku'), 1), toUInt16(length('krasp') - length('otsku')))), (length('krasp') - length('otsku')) < 0, substr('otsku', 1, length('krasp')), 'otsku')))\"\n+        },\n+        {\n+            \"print trim_start('[^\\\\w]+', strcat('-  ','Te st1','// $'))\",\n+            \"SELECT replaceRegexpOne(concat('-  ', 'Te st1', '// $'), concat('^', '[^\\\\\\\\w]+'), '')\"\n+        },\n+        {\n+            \"print trim_end('.com', 'bing.com')\",\n+            \"SELECT replaceRegexpOne('bing.com', concat('.com', '$'), '')\"\n+        },\n+        {\n+            \"print trim('--', '--https://bing.com--')\",\n+            \"SELECT replaceRegexpOne(replaceRegexpOne('--https://bing.com--', concat('--', '$'), ''), concat('^', '--'), '')\"\n+        },\n+        {\n+            \"print bool(1)\",\n+            \"SELECT toBool(1)\"\n+        },\n+        {\n+            \"print datetime(2015-12-31 23:59:59.9)\",\n+            \"SELECT parseDateTime64BestEffortOrNull('2015-12-31 23:59:59.9', 9, 'UTC')\"\n+        },\n+        {\n+            \"print datetime(\\\"2015-12-31 23:59:59.9\\\")\",\n+            \"SELECT parseDateTime64BestEffortOrNull('2015-12-31 23:59:59.9', 9, 'UTC')\"\n+        },\n+        {\n+            \"print datetime('2015-12-31 23:59:59.9')\",\n+            \"SELECT parseDateTime64BestEffortOrNull('2015-12-31 23:59:59.9', 9, 'UTC')\"\n+        },\n+        {\n+            \"print guid(74be27de-1e4e-49d9-b579-fe0b331d3642)\",\n+            \"SELECT toUUIDOrNull('74be27de-1e4e-49d9-b579-fe0b331d3642')\"\n+        },\n+        {\n+            \"print guid('74be27de-1e4e-49d9-b579-fe0b331d3642')\",\n+            \"SELECT toUUIDOrNull('74be27de-1e4e-49d9-b579-fe0b331d3642')\"\n+        },\n+        {\n+            \"print guid('74be27de1e4e49d9b579fe0b331d3642')\",\n+            \"SELECT toUUIDOrNull('74be27de1e4e49d9b579fe0b331d3642')\"\n+        },\n+        {\n+            \"print int(32.5)\",\n+            \"SELECT toInt32(32.5)\"\n+        },\n+        {\n+            \"print long(32.5)\",\n+            \"SELECT toInt64(32.5)\"\n+        },\n+        {\n+            \"print real(32.5)\",\n+            \"SELECT toFloat64(32.5)\"\n+        },\n+        {\n+            \"print time('1.22:34:8.128')\",\n+            \"SELECT CAST('167648.128', 'Float64')\"\n+        },\n+        {\n+            \"print time('1d')\",\n+            \"SELECT CAST('86400', 'Float64')\"\n+        },\n+        {\n+            \"print time('1.5d')\",\n+            \"SELECT CAST('129600', 'Float64')\"\n+        },\n+        {\n+            \"print timespan('1.5d')\",\n+            \"SELECT CAST('129600', 'Float64')\"\n+        },\n+        {\n+            \"print res = bin_at(6.5, 2.5, 7)\",\n+            \"SELECT toFloat64(7) + (toInt64(((toFloat64(6.5) - toFloat64(7)) / 2.5) + -1) * 2.5) AS res\"\n+        },\n+        {\n+            \"print res = bin_at(1h, 1d, 12h)\",\n+            \"SELECT concat(toString(toInt32(((toFloat64(43200) + (toInt64(((toFloat64(3600) - toFloat64(43200)) / 86400) + -1) * 86400)) AS x) / 3600)), ':', toString(toInt32((x % 3600) / 60)), ':', toString(toInt32((x % 3600) % 60))) AS res\"\n+        },\n+        {\n+            \"print res = bin_at(datetime(2017-05-15 10:20:00.0), 1d, datetime(1970-01-01 12:00:00.0))\",\n+            \"SELECT toDateTime64(toFloat64(parseDateTime64BestEffortOrNull('1970-01-01 12:00:00.0', 9, 'UTC')) + (toInt64(((toFloat64(parseDateTime64BestEffortOrNull('2017-05-15 10:20:00.0', 9, 'UTC')) - toFloat64(parseDateTime64BestEffortOrNull('1970-01-01 12:00:00.0', 9, 'UTC'))) / 86400) + 0) * 86400), 9, 'UTC') AS res\"\n+        },\n+        {\n+            \"print bin(4.5, 1)\",\n+            \"SELECT toInt64(toFloat64(4.5) / 1) * 1\"\n+        },\n+        {\n+            \"print bin(4.5, -1)\",\n+            \"SELECT toInt64(toFloat64(4.5) / -1) * -1\"\n+        },\n+        {\n+            \"print bin(time(16d), 7d)\",\n+            \"SELECT concat(toString(toInt32(((toInt64(toFloat64(CAST('1382400', 'Float64')) / 604800) * 604800) AS x) / 3600)), ':', toString(toInt32((x % 3600) / 60)), ':', toString(toInt32((x % 3600) % 60)))\"\n+        },\n+        {\n+            \"print bin(datetime(1970-05-11 13:45:07), 1d)\",\n+            \"SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07', 9, 'UTC')) / 86400) * 86400, 9, 'UTC')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(bool));\",\n+            \"SELECT accurateCastOrNull(toInt64OrNull(extract('hello x=456|wo', '[0-9.]+')), 'Boolean')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(date));\",\n+            \"SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'DateTime')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(guid));\",\n+            \"SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'UUID')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(int));\",\n+            \"SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'Int32')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(long));\",\n+            \"SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'Int64')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(real));\",\n+            \"SELECT accurateCastOrNull(extract('hello x=456|wo', '[0-9.]+'), 'Float64')\"\n+        },\n+        {\n+            \"print extract('x=([0-9.]+)', 1, 'hello x=456|wo' , typeof(decimal));\",\n+            \"SELECT toDecimal128OrNull(if(countSubstrings(extract('hello x=456|wo', '[0-9.]+'), '.') > 1, NULL, extract('hello x=456|wo', '[0-9.]+')), length(substr(extract('hello x=456|wo', '[0-9.]+'), position(extract('hello x=456|wo', '[0-9.]+'), '.') + 1)))\"\n+        },\n+        {\n+            \"print bin(datetime(1970-05-11 13:45:07.456345672), 1ms)\",\n+            \"SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.001) * 0.001, 9, 'UTC')\"\n+        },\n+        {\n+            \"print bin(datetime(1970-05-11 13:45:07.456345672), 1microseconds)\",\n+            \"SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.000001) * 0.000001, 9, 'UTC')\"\n+        },\n+        {\n+            \"print parse_version('1.2.3.40')\",\n+            \"SELECT if((length(splitByChar('.', '1.2.3.40')) > 4) OR (length(splitByChar('.', '1.2.3.40')) < 1) OR (match('1.2.3.40', '.*[a-zA-Z]+.*') = 1), toDecimal128OrNull('NULL', 0), toDecimal128OrNull(substring(arrayStringConcat(arrayMap(x -> leftPad(x, 8, '0'), arrayMap(x -> if(empty(x), '0', x), arrayResize(splitByChar('.', '1.2.3.40'), 4)))), 8), 0))\"\n+        },\n+        {\n+            \"print parse_version('1')\",\n+            \"SELECT if((length(splitByChar('.', '1')) > 4) OR (length(splitByChar('.', '1')) < 1) OR (match('1', '.*[a-zA-Z]+.*') = 1), toDecimal128OrNull('NULL', 0), toDecimal128OrNull(substring(arrayStringConcat(arrayMap(x -> leftPad(x, 8, '0'), arrayMap(x -> if(empty(x), '0', x), arrayResize(splitByChar('.', '1'), 4)))), 8), 0))\"\n+        },\n+        {\n+            \"print parse_json( dynamic([1, 2, 3]))\",\n+            \"SELECT [1, 2, 3]\"\n+        },\n+        {\n+            \"print parse_json('{\\\"a\\\":123.5, \\\"b\\\":\\\"{\\\\\\\"c\\\\\\\":456}\\\"}')\",\n+            \"SELECT if(isValidJSON('{\\\"a\\\":123.5, \\\"b\\\":\\\"{\\\"c\\\":456}\\\"}'), JSON_QUERY('{\\\"a\\\":123.5, \\\"b\\\":\\\"{\\\"c\\\":456}\\\"}', '$'), toJSONString('{\\\"a\\\":123.5, \\\"b\\\":\\\"{\\\"c\\\":456}\\\"}'))\"\n+        },\n+        {\n+            \"print extract_json( '$.a' , '{\\\"a\\\":123, \\\"b\\\":\\\"{\\\"c\\\":456}\\\"}' , typeof(long))\",\n+            \"SELECT accurateCastOrNull(JSON_VALUE('{\\\"a\\\":123, \\\"b\\\":\\\"{\\\"c\\\":456}\\\"}', '$.a'), 'Int64')\"\n+        },\n+        {\n+            \"print bin(datetime(1970-05-11 13:45:07.456345672), 1ms)\",\n+            \"SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.001) * 0.001, 9, 'UTC')\"\n+        },\n+        {\n+            \"print bin(datetime(1970-05-11 13:45:07.456345672), 1microseconds)\",\n+            \"SELECT toDateTime64(toInt64(toFloat64(parseDateTime64BestEffortOrNull('1970-05-11 13:45:07.456345672', 9, 'UTC')) / 0.000001) * 0.000001, 9, 'UTC')\"\n+        },\n+        {\n+            \"print parse_command_line('echo \\\"hello world!\\\" print$?', 'windows')\",\n+            \"SELECT if(empty('echo \\\"hello world!\\\" print$?') OR hasAll(splitByChar(' ', 'echo \\\"hello world!\\\" print$?'), ['']), arrayMap(x -> NULL, splitByChar(' ', '')), splitByChar(' ', 'echo \\\"hello world!\\\" print$?'))\"\n+        },\n+        {\n+            \"print reverse(123)\",\n+            \"SELECT reverse(accurateCastOrNull(123, 'String'))\"\n+        },\n+        {\n+            \"print reverse(123.34)\",\n+            \"SELECT reverse(accurateCastOrNull(123.34, 'String'))\"\n+        },\n+        {\n+            \"print reverse('clickhouse')\",\n+            \"SELECT reverse(accurateCastOrNull('clickhouse', 'String'))\"\n+        },\n+        {\n+            \"print result=parse_csv('aa,b,cc')\",\n+            \"SELECT if(CAST(position('aa,b,cc', '\\\\n'), 'UInt8'), splitByChar(',', substring('aa,b,cc', 1, position('aa,b,cc', '\\\\n') - 1)), splitByChar(',', substring('aa,b,cc', 1, length('aa,b,cc')))) AS result\"\n+        },\n+        {\n+            \"print result_multi_record=parse_csv('record1,a,b,c\\nrecord2,x,y,z')\",\n+            \"SELECT if(CAST(position('record1,a,b,c\\\\nrecord2,x,y,z', '\\\\n'), 'UInt8'), splitByChar(',', substring('record1,a,b,c\\\\nrecord2,x,y,z', 1, position('record1,a,b,c\\\\nrecord2,x,y,z', '\\\\n') - 1)), splitByChar(',', substring('record1,a,b,c\\\\nrecord2,x,y,z', 1, length('record1,a,b,c\\\\nrecord2,x,y,z')))) AS result_multi_record\"\n+        },\n+        {\n+            \"Customers | project name_abbr = strcat(substring(FirstName,0,3), ' ', substring(LastName,2))| order by LastName\",\n+            \"SELECT concat(if(toInt64(length(FirstName)) <= 0, '', substr(FirstName, (((0 % toInt64(length(FirstName))) + toInt64(length(FirstName))) % toInt64(length(FirstName))) + 1, 3)), ' ', if(toInt64(length(LastName)) <= 0, '', substr(LastName, (((2 % toInt64(length(LastName))) + toInt64(length(LastName))) % toInt64(length(LastName))) + 1))) AS name_abbr\\nFROM Customers\\nORDER BY LastName DESC\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_dateTimeFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_dateTimeFunctions.cpp\nnew file mode 100644\nindex 000000000000..ed38411c1b71\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_dateTimeFunctions.cpp\n@@ -0,0 +1,218 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Datetime, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"print week_of_year(datetime(2020-12-31))\",\n+            \"SELECT toWeek(parseDateTime64BestEffortOrNull('2020-12-31', 9, 'UTC'), 3, 'UTC')\"\n+        },\n+        {\n+            \"print startofweek(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT parseDateTime64BestEffortOrNull(toString(toStartOfWeek(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'))), 9, 'UTC') + toIntervalWeek(-1)\"\n+        },\n+        {\n+            \"print startofmonth(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT parseDateTime64BestEffortOrNull(toString(toStartOfMonth(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'))), 9, 'UTC') + toIntervalMonth(-1)\"\n+        },\n+        {\n+            \"print startofday(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT parseDateTime64BestEffortOrNull(toString(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'))), 9, 'UTC') + toIntervalDay(-1)\"\n+        },\n+        {\n+            \"print startofyear(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT parseDateTime64BestEffortOrNull(toString(toStartOfYear(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 'UTC')), 9, 'UTC') + toIntervalYear(-1)\"\n+        },\n+        {\n+            \"print monthofyear(datetime(2015-12-14))\",\n+            \"SELECT toMonth(parseDateTime64BestEffortOrNull('2015-12-14', 9, 'UTC'))\"\n+        },\n+        {\n+            \"print hourofday(datetime(2015-12-14 10:54:00))\",\n+            \"SELECT toHour(parseDateTime64BestEffortOrNull('2015-12-14 10:54:00', 9, 'UTC'))\"\n+        },\n+        {\n+            \"print getyear(datetime(2015-10-12))\",\n+            \"SELECT toYear(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))\"\n+        },\n+        {\n+            \"print getmonth(datetime(2015-10-12))\",\n+            \"SELECT toMonth(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))\"\n+        },\n+        {\n+            \"print dayofyear(datetime(2015-10-12))\",\n+            \"SELECT toDayOfYear(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))\"\n+        },\n+        {\n+            \"print dayofmonth(datetime(2015-10-12))\",\n+            \"SELECT toDayOfMonth(parseDateTime64BestEffortOrNull('2015-10-12', 9, 'UTC'))\"\n+        },\n+        {\n+            \"print unixtime_seconds_todatetime(1546300899)\",\n+            \"SELECT if((toTypeName(1546300899) = 'Int64') OR (toTypeName(1546300899) = 'Int32') OR (toTypeName(1546300899) = 'Float64') OR (toTypeName(1546300899) = 'UInt32') OR (toTypeName(1546300899) = 'UInt64'), toDateTime64(1546300899, 9, 'UTC'), toDateTime64(throwIf(true, 'unixtime_seconds_todatetime only accepts Int, Long and double type of arguments'), 9, 'UTC'))\"\n+        },\n+        {\n+            \"print dayofweek(datetime(2015-12-20))\",\n+            \"SELECT concat(CAST(toDayOfWeek(parseDateTime64BestEffortOrNull('2015-12-20', 9, 'UTC')) % 7, 'String'), '.00:00:00')\"\n+        },\n+        {\n+            \"print now()\",\n+            \"SELECT now64(9, 'UTC')\"\n+        },\n+        {\n+            \"print now(1d)\",\n+            \"SELECT now64(9, 'UTC') + 86400\"\n+        },\n+        {\n+            \"print ago(2d)\",\n+            \"SELECT now64(9, 'UTC') - 172800\"\n+        },\n+        {\n+            \"print endofday(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalDay(-1 + 1)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print endofday(datetime(2017-01-01 10:10:17), 1)\",\n+            \"SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalDay(1 + 1)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print endofmonth(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT (((toDateTime(toLastDayOfMonth(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalMonth(-1)), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print endofmonth(datetime(2017-01-01 10:10:17), 1)\",\n+            \"SELECT (((toDateTime(toLastDayOfMonth(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalMonth(1)), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print endofweek(datetime(2017-01-01 10:10:17), -1)\",\n+            \"SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalWeek(-1 + 1)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print endofweek(datetime(2017-01-01 10:10:17), 1)\",\n+            \"SELECT (toDateTime(toStartOfDay(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC')), 9, 'UTC') + toIntervalWeek(1 + 1)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print endofyear(datetime(2017-01-01 10:10:17), -1) \",\n+            \"SELECT (((toDateTime(toString(toLastDayOfMonth((toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalYear(-1)) + toIntervalMonth(12 - toInt8(substring(toString(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC')), 6, 2))))), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+           \"print endofyear(datetime(2017-01-01 10:10:17), 1)\" ,\n+           \"SELECT (((toDateTime(toString(toLastDayOfMonth((toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC') + toIntervalYear(1)) + toIntervalMonth(12 - toInt8(substring(toString(toDateTime(parseDateTime64BestEffortOrNull('2017-01-01 10:10:17', 9, 'UTC'), 9, 'UTC')), 6, 2))))), 9, 'UTC') + toIntervalHour(23)) + toIntervalMinute(59)) + toIntervalSecond(60)) - toIntervalMicrosecond(1)\"\n+        },\n+        {\n+            \"print make_datetime(2017,10,01)\",\n+            \"SELECT makeDateTime64(2017, 10, 1, 0, 0, 0, 0, 7, 'UTC')\"\n+        },\n+        {\n+            \"print make_datetime(2017,10,01,12,10)\",\n+            \"SELECT makeDateTime64(2017, 10, 1, 12, 10, 0, 0, 7, 'UTC')\"\n+        },\n+        {\n+            \"print make_datetime(2017,10,01,12,11,0.1234567)\",\n+            \"SELECT makeDateTime64(2017, 10, 1, 12, 11, 0.1234567, 0, 7, 'UTC')\"\n+        },\n+        {\n+            \"print unixtime_microseconds_todatetime(1546300800000000)\",\n+            \"SELECT fromUnixTimestamp64Micro(1546300800000000, 'UTC')\"\n+        },\n+        {\n+            \"print unixtime_milliseconds_todatetime(1546300800000)\",\n+            \"SELECT fromUnixTimestamp64Milli(1546300800000, 'UTC')\"\n+        },\n+        {\n+            \"print unixtime_nanoseconds_todatetime(1546300800000000000)\",\n+            \"SELECT fromUnixTimestamp64Nano(1546300800000000000, 'UTC')\"\n+        },\n+        {\n+            \"print datetime_diff('year',datetime(2017-01-01),datetime(2000-12-31))\",\n+            \"SELECT dateDiff('year', parseDateTime64BestEffortOrNull('2017-01-01', 9, 'UTC'), parseDateTime64BestEffortOrNull('2000-12-31', 9, 'UTC')) * -1\"\n+        },\n+        {\n+            \"print datetime_diff('minute',datetime(2017-10-30 23:05:01),datetime(2017-10-30 23:00:59))\",\n+            \"SELECT dateDiff('minute', parseDateTime64BestEffortOrNull('2017-10-30 23:05:01', 9, 'UTC'), parseDateTime64BestEffortOrNull('2017-10-30 23:00:59', 9, 'UTC')) * -1\"\n+        },\n+        {\n+            \"print datetime(null)\",\n+            \"SELECT NULL\"\n+        },\n+        {\n+            \"print datetime('2014-05-25T08:20:03.123456Z')\",\n+            \"SELECT parseDateTime64BestEffortOrNull('2014-05-25T08:20:03.123456Z', 9, 'UTC')\"\n+        },\n+        {\n+            \"print datetime(2015-12-14 18:54)\",\n+            \"SELECT parseDateTime64BestEffortOrNull('2015-12-14 18:54', 9, 'UTC')\"\n+        },\n+        {\n+            \"print make_timespan(67,12,30,59.9799)\",\n+            \"SELECT CONCAT('67.', toString(substring(toString(toTime(parseDateTime64BestEffortOrNull('0000-00-00 12:30:59.9799', 9, 'UTC'))), 12)))\"\n+        },\n+        {\n+            \"print  todatetime('2014-05-25T08:20:03.123456Z')\",\n+            \"SELECT parseDateTime64BestEffortOrNull(toString('2014-05-25T08:20:03.123456Z'), 9, 'UTC')\"\n+        },\n+        {\n+            \"print format_datetime(todatetime('2009-06-15T13:45:30.6175425'), 'yy-M-dd [H:mm:ss.fff]')\",\n+            \"SELECT concat(substring(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), 1, position(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), '.')), substring(substring(toString(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC')), position(toString(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC')), '.') + 1), 1, 3), substring(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), position(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')), '.') + 1, length(toString(formatDateTime(parseDateTime64BestEffortOrNull(toString('2009-06-15T13:45:30.6175425'), 9, 'UTC'), '%y-%m-%d [%H:%i:%S.]')))))\"\n+        },\n+        {\n+            \"print format_datetime(datetime(2015-12-14 02:03:04.12345), 'y-M-d h:m:s tt')\",\n+            \"SELECT formatDateTime(parseDateTime64BestEffortOrNull('2015-12-14 02:03:04.12345', 9, 'UTC'), '%y-%m-%e %h:%i:%S %p')\"\n+        },\n+        {\n+            \"print format_timespan(time(1d), 'd-[hh:mm:ss]')\",\n+            \"SELECT concat(leftPad('1', 1, '0'), toString(formatDateTime(toDateTime64(CAST('86400', 'Float64'), 9, 'UTC'), '-[%h:%i:%S]')))\"\n+        },\n+        {\n+            \"print format_timespan(time('12:30:55.123'), 'ddddd-[hh:mm:ss.ffff]')\",\n+            \"SELECT concat(leftPad('0', 5, '0'), substring(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')), 1, length(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]'))) - position(reverse(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]'))), ']')), substring(substring(toString(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC')), position(toString(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC')), '.') + 1), 1, 4), substring(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')), position(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')), ']'), length(toString(formatDateTime(toDateTime64(CAST('45055.123', 'Float64'), 9, 'UTC'), '-[%H:%i:%S.]')))))\"\n+        },\n+        {\n+            \"print v1=format_timespan(time('29.09:00:05.12345'), 'dd.hh:mm:ss:FF')\",\n+            \"SELECT concat(leftPad('29', 2, '0'), substring(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S:')), 1, (length(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S:'))) - position(reverse(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S:'))), ':')) + 1), substring(substring(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), position(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), '.') + 1), 1, 2)) AS v1\"\n+        },\n+        {\n+            \"print v2=format_timespan(time('29.09:00:05.12345'), 'ddd.h:mm:ss [fffffff]');\",\n+            \"SELECT concat(leftPad('29', 3, '0'), substring(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []')), 1, length(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []'))) - position(reverse(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []'))), ']')), substring(substring(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), position(toString(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC')), '.') + 1), 1, 7), substring(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []')), position(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []')), ']'), length(toString(formatDateTime(toDateTime64(CAST('2538005.12345', 'Float64'), 9, 'UTC'), '.%H:%i:%S []'))))) AS v2\"\n+        },\n+        {\n+            \"print datetime_part('day', datetime(2017-10-30 01:02:03.7654321))\",\n+            \"SELECT formatDateTime(parseDateTime64BestEffortOrNull('2017-10-30 01:02:03.7654321', 9, 'UTC'), '%e')\"\n+        },\n+        {\n+            \"print datetime_add('day',1,datetime(2017-10-30 01:02:03.7654321))\",\n+            \"SELECT parseDateTime64BestEffortOrNull('2017-10-30 01:02:03.7654321', 9, 'UTC') + toIntervalDay(1)\"\n+        },\n+        {\n+            \"print totimespan(time(1d))\",\n+            \"SELECT CAST('86400', 'Float64')\"\n+        },\n+        {\n+            \"print totimespan('0.01:34:23')\",\n+            \"SELECT CAST('5663', 'Float64')\"\n+        },\n+        {\n+            \"print totimespan(time('-1:12:34'))\",\n+            \"SELECT CAST('-4354', 'Float64')\"\n+        },\n+        {\n+            \"print totimespan(-1d)\",\n+            \"SELECT -86400\"\n+        },\n+        {\n+            \"print totimespan('abc')\",\n+            \"SELECT NULL\"\n+        },\n+        {\n+            \"print time(2)\",\n+            \"SELECT CAST('172800', 'Float64')\"\n+        },\n+        {\n+            \"hits | project bin(datetime(EventTime), 1m)\",\n+            \"SELECT toDateTime64(toInt64(toFloat64(if((toTypeName(EventTime) = 'Int64') OR (toTypeName(EventTime) = 'Int32') OR (toTypeName(EventTime) = 'Float64') OR (toTypeName(EventTime) = 'UInt32') OR (toTypeName(EventTime) = 'UInt64'), toDateTime64(EventTime, 9, 'UTC'), parseDateTime64BestEffortOrNull(CAST(EventTime, 'String'), 9, 'UTC'))) / 60) * 60, 9, 'UTC')\\nFROM hits\"\n+        }\n+\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_dynamicFunctions.cpp b/src/Parsers/tests/KQL/gtest_KQL_dynamicFunctions.cpp\nnew file mode 100644\nindex 000000000000..93df5a6c55f1\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_dynamicFunctions.cpp\n@@ -0,0 +1,140 @@\n+#include <Parsers/tests/gtest_common.h>\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_Dynamic, ParserKQLTest,\n+     ::testing::Combine(\n+         ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+         ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+         {\n+             \"print t = array_sort_asc(dynamic([null, 'd', 'a', 'c', 'c']))\",\n+            \"SELECT kql_array_sort_asc([NULL, 'd', 'a', 'c', 'c']).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc(dynamic([4, 1, 3, 2]))\",\n+            \"SELECT kql_array_sort_asc([4, 1, 3, 2]).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))\",\n+            \"SELECT kql_array_sort_asc(['b', 'a', 'c'], ['q', 'p', 'r']).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , false)\",\n+            \"SELECT kql_array_sort_asc(['d', NULL, 'a', 'c', 'c'], false).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]) , false)\",\n+            \"SELECT kql_array_sort_asc([NULL, 'd', NULL, NULL, 'a', 'c', 'c', NULL, NULL, NULL], false).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]) , true)\",\n+            \"SELECT kql_array_sort_asc([NULL, 'd', NULL, NULL, 'a', 'c', 'c', NULL, NULL, NULL], true).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc( dynamic([null, 'd', null, null, 'a', 'c', 'c', null, null, null]))\",\n+            \"SELECT kql_array_sort_asc([NULL, 'd', NULL, NULL, 'a', 'c', 'c', NULL, NULL, NULL]).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']), 1 < 2)\",\n+            \"SELECT kql_array_sort_asc(['d', NULL, 'a', 'c', 'c'], 1 < 2).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2)\",\n+            \"SELECT kql_array_sort_asc(['d', NULL, 'a', 'c', 'c'], 1 > 2).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), false)\",\n+            \"SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], false).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), 1 > 2)\",\n+            \"SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], 1 > 2).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), true)\",\n+            \"SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], true).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]), 1 < 2)\",\n+            \"SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30], 1 < 2).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_desc(dynamic([null, 'd', 'a', 'c', 'c']))\",\n+            \"SELECT kql_array_sort_desc([NULL, 'd', 'a', 'c', 'c']).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_desc(dynamic([4, 1, 3, 2]))\",\n+            \"SELECT kql_array_sort_desc([4, 1, 3, 2]).1 AS t\"\n+        },\n+        {\n+            \"print t = array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))\",\n+             \"SELECT kql_array_sort_desc(['b', 'a', 'c'], ['q', 'p', 'r']).1 AS t\"\n+         },\n+         {\n+            \"print array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))\",\n+            \"SELECT kql_array_sort_desc(['b', 'a', 'c'], ['q', 'p', 'r'])\"\n+        },\n+        {\n+            \"print t = array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , false)\",\n+            \"SELECT kql_array_sort_desc(['d', NULL, 'a', 'c', 'c'], false).1 AS t\"\n+        },\n+        {\n+            \"print array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]))[0]\",\n+            \"SELECT tupleElement(kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]), if(0 >= 0, 0 + 1, 0))\"\n+        },\n+        {\n+            \"print  (t) = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]))\",\n+            \"SELECT kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t\"\n+        },\n+        {\n+            \"print  (t,w) = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30]))\",\n+            \"SELECT\\n    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,\\n    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).2 AS w\"\n+        },\n+        {\n+            \"print  t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30])),y=5\",\n+            \"SELECT\\n    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,\\n    5 AS y\"\n+        },\n+        {\n+            \"print 5, (t) = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30])),y=5\",\n+            \"SELECT\\n    5,\\n    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,\\n    5 AS y\"\n+        },\n+        {\n+            \"print  t = array_sort_asc(dynamic([2, 1, null,3]), dynamic([20, 10, 40, 30])),w = array_sort_asc(dynamic([2, 1, 3]))\",\n+            \"SELECT\\n    kql_array_sort_asc([2, 1, NULL, 3], [20, 10, 40, 30]).1 AS t,\\n    kql_array_sort_asc([2, 1, 3]).1 AS w\"\n+        },\n+         {\n+             \"print A[0]\",\n+             \"SELECT A[if(0 >= 0, 0 + 1, 0)]\"\n+         },\n+         {\n+             \"print A[0][1]\",\n+             \"SELECT (A[if(0 >= 0, 0 + 1, 0)])[if(1 >= 0, 1 + 1, 1)]\"\n+         },\n+         {\n+             \"print dynamic([[1,2,3,4,5],[20,30]])[0]\",\n+             \"SELECT [[1, 2, 3, 4, 5], [20, 30]][if(0 >= 0, 0 + 1, 0)]\"\n+         },\n+         {\n+             \"print dynamic([[1,2,3,4,5],[20,30]])[1][1]\",\n+             \"SELECT ([[1, 2, 3, 4, 5], [20, 30]][if(1 >= 0, 1 + 1, 1)])[if(1 >= 0, 1 + 1, 1)]\"\n+         },\n+         {\n+             \"print A[B[1]]\",\n+             \"SELECT A[if((B[if(1 >= 0, 1 + 1, 1)]) >= 0, (B[if(1 >= 0, 1 + 1, 1)]) + 1, B[if(1 >= 0, 1 + 1, 1)])]\"\n+         },\n+         {\n+             \"print A[strlen('a')-1]\",\n+             \"SELECT A[if((lengthUTF8('a') - 1) >= 0, (lengthUTF8('a') - 1) + 1, lengthUTF8('a') - 1)]\"\n+         },\n+         {\n+             \"print strlen(A[0])\",\n+             \"SELECT lengthUTF8(A[if(0 >= 0, 0 + 1, 0)])\"\n+         },\n+         {\n+            \"print repeat(1, 3)\",\n+            \"SELECT if(3 < 0, [NULL], arrayWithConstant(abs(3), 1))\"\n+         },\n+         {\n+            \"print repeat(1, -3)\",\n+            \"SELECT if(-3 < 0, [NULL], arrayWithConstant(abs(-3), 1))\"\n+         }\n+ })));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_operator_in_sql.cpp b/src/Parsers/tests/KQL/gtest_KQL_operator_in_sql.cpp\nnew file mode 100644\nindex 000000000000..a35287f471bc\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_operator_in_sql.cpp\n@@ -0,0 +1,66 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+#include <Parsers/ParserSelectQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_operator_in_sql, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserSelectQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"select * from kql($$Customers | where FirstName !in ('Peter', 'Latoya')$$)\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE FirstName NOT IN ('Peter', 'Latoya')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !contains 'Pet'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT (FirstName ILIKE '%Pet%')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !contains_cs 'Pet'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT (FirstName LIKE '%Pet%')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !endswith 'ter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT (FirstName ILIKE '%ter')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !endswith_cs 'ter'$$);\"\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT endsWith(FirstName, 'ter')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName != 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE FirstName != 'Peter'\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !has 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT hasTokenCaseInsensitive(FirstName, 'Peter')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !has_cs 'peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT hasToken(FirstName, 'peter')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !hasprefix 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE (NOT (FirstName ILIKE 'Peter%')) AND (NOT (FirstName ILIKE '% Peter%'))\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !hasprefix_cs 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE (NOT startsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '% Peter%'))\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !hassuffix 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE (NOT (FirstName ILIKE '%Peter')) AND (NOT (FirstName ILIKE '%Peter %'))\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !hassuffix_cs 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE (NOT endsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '%Peter %'))\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !startswith 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT (FirstName ILIKE 'Peter%')\\n)\"\n+        },\n+        {\n+            \"select * from kql($$Customers | where FirstName !startswith_cs 'Peter'$$);\",\n+            \"SELECT *\\nFROM view(\\n    SELECT *\\n    FROM Customers\\n    WHERE NOT startsWith(FirstName, 'Peter')\\n)\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/KQL/gtest_KQL_test_subquery.cpp b/src/Parsers/tests/KQL/gtest_KQL_test_subquery.cpp\nnew file mode 100644\nindex 000000000000..619f634670a1\n--- /dev/null\n+++ b/src/Parsers/tests/KQL/gtest_KQL_test_subquery.cpp\n@@ -0,0 +1,109 @@\n+#include <Parsers/tests/gtest_common.h>\n+\n+#include <Parsers/Kusto/ParserKQLQuery.h>\n+\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery_TestSubquery, ParserKQLTest,\n+    ::testing::Combine(\n+        ::testing::Values(std::make_shared<DB::ParserKQLQuery>()),\n+        ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !in ('Peter', 'Latoya')));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE FirstName NOT IN ('Peter', 'Latoya')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName, Age | where Age !in (28, 29)));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE Age NOT IN (28, 29)\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !contains 'ste'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT (FirstName ILIKE '%ste%')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !contains_cs 'Ste'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT (FirstName LIKE '%Ste%')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !contains_cs 'ste'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT (FirstName LIKE '%ste%')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !endswith 'ore'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT (FirstName ILIKE '%ore')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !endswith_cs 'Ore'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT endsWith(FirstName, 'Ore')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName != 'Theodore'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE FirstName != 'Theodore'\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !~ 'theodore'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE lower(FirstName) != lower('theodore')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !has 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT hasTokenCaseInsensitive(FirstName, 'Peter')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !has_cs 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT hasToken(FirstName, 'Peter')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hasprefix 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE (NOT (FirstName ILIKE 'Peter%')) AND (NOT (FirstName ILIKE '% Peter%'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hasprefix_cs 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE (NOT startsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '% Peter%'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hassuffix 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE (NOT (FirstName ILIKE '%Peter')) AND (NOT (FirstName ILIKE '%Peter %'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !hassuffix_cs 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE (NOT endsWith(FirstName, 'Peter')) AND (NOT (FirstName LIKE '%Peter %'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !startswith 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT (FirstName ILIKE 'Peter%')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName  | where FirstName !startswith_cs 'Peter'));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE NOT startsWith(FirstName, 'Peter')\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName !in~ ((Customers | project FirstName  | where FirstName !in~ ('peter', 'apple')));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE lower(FirstName) NOT IN (\\n    SELECT lower(FirstName)\\n    FROM Customers\\n    WHERE lower(FirstName) NOT IN (lower('peter'), lower('apple'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName | where FirstName in~ ('peter', 'apple')));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE lower(FirstName) IN (lower('peter'), lower('apple'))\\n)\"\n+        },\n+        {\n+            \"Customers | where substring(FirstName,0,3) in~ ((Customers | project substring(FirstName,0,3) | where FirstName in~ ('peter', 'apple')));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE lower(if(toInt64(length(FirstName)) <= 0, '', substr(FirstName, (((0 % toInt64(length(FirstName))) + toInt64(length(FirstName))) % toInt64(length(FirstName))) + 1, 3))) IN (\\n    SELECT lower(if(toInt64(length(FirstName)) <= 0, '', substr(FirstName, (((0 % toInt64(length(FirstName))) + toInt64(length(FirstName))) % toInt64(length(FirstName))) + 1, 3)))\\n    FROM Customers\\n    WHERE lower(FirstName) IN (lower('peter'), lower('apple'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in~ ((Customers |  where FirstName !in~ ('peter', 'apple')| project FirstName));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE lower(FirstName) IN (\\n    SELECT lower(FirstName)\\n    FROM Customers\\n    WHERE lower(FirstName) NOT IN (lower('peter'), lower('apple'))\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in ((Customers | project FirstName, LastName, Age));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName IN (\\n    SELECT FirstName\\n    FROM Customers\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName in~ ((Customers | project FirstName, LastName, Age|where Age <30));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE lower(FirstName) IN (\\n    SELECT lower(FirstName)\\n    FROM Customers\\n    WHERE Age < 30\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName !in ((Customers | project FirstName, LastName, Age |where Age <30 ));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE FirstName NOT IN (\\n    SELECT FirstName\\n    FROM Customers\\n    WHERE Age < 30\\n)\"\n+        },\n+        {\n+            \"Customers | where FirstName !in~ ((Customers | project FirstName, LastName, Age |where Age <30));\",\n+            \"SELECT *\\nFROM Customers\\nWHERE lower(FirstName) NOT IN (\\n    SELECT lower(FirstName)\\n    FROM Customers\\n    WHERE Age < 30\\n)\"\n+        }\n+})));\ndiff --git a/src/Parsers/tests/gtest_Parser.cpp b/src/Parsers/tests/gtest_Parser.cpp\nindex 3a90256f2625..556743e70ec0 100644\n--- a/src/Parsers/tests/gtest_Parser.cpp\n+++ b/src/Parsers/tests/gtest_Parser.cpp\n@@ -18,6 +18,7 @@\n #include <string_view>\n #include <regex>\n #include <gtest/gtest.h>\n+#include \"gtest_common.h\"\n #include <boost/algorithm/string/replace.hpp>\n \n namespace\n@@ -26,13 +27,6 @@ using namespace DB;\n using namespace std::literals;\n }\n \n-\n-struct ParserTestCase\n-{\n-    const std::string_view input_text;\n-    const char * expected_ast = nullptr;\n-};\n-\n std::ostream & operator<<(std::ostream & ostr, const std::shared_ptr<IParser> parser)\n {\n     return ostr << \"Parser: \" << parser->getName();\n@@ -47,9 +41,6 @@ std::ostream & operator<<(std::ostream & ostr, const ParserTestCase & test_case)\n     return ostr << \"ParserTestCase input: \" << input_text;\n }\n \n-class ParserTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<IParser>, ParserTestCase>>\n-{};\n-\n TEST_P(ParserTest, parseQuery)\n {\n     const auto & parser = std::get<0>(GetParam());\n@@ -307,7 +298,7 @@ INSTANTIATE_TEST_SUITE_P(ParserAttachUserQuery, ParserTest,\n         }\n })));\n \n-INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,\n+INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserKQLTest,\n     ::testing::Combine(\n         ::testing::Values(std::make_shared<ParserKQLQuery>()),\n         ::testing::ValuesIn(std::initializer_list<ParserTestCase>{\n@@ -339,10 +330,6 @@ INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,\n             \"Customers | project FirstName,LastName,Occupation | take 3 | project FirstName,LastName\",\n             \"SELECT\\n    FirstName,\\n    LastName\\nFROM\\n(\\n    SELECT\\n        FirstName,\\n        LastName,\\n        Occupation\\n    FROM Customers\\n    LIMIT 3\\n)\"\n         },\n-        {\n-            \"Customers | project FirstName,LastName,Occupation | take 3 | project FirstName,LastName,Education\",\n-            \"SELECT\\n    FirstName,\\n    LastName,\\n    Education\\nFROM\\n(\\n    SELECT\\n        FirstName,\\n        LastName,\\n        Occupation\\n    FROM Customers\\n    LIMIT 3\\n)\"\n-        },\n         {\n             \"Customers | sort by FirstName desc\",\n             \"SELECT *\\nFROM Customers\\nORDER BY FirstName DESC\"\n@@ -425,23 +412,23 @@ INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,\n         },\n         {\n             \"Customers |summarize count() by Occupation\",\n-            \"SELECT\\n    count(),\\n    Occupation\\nFROM Customers\\nGROUP BY Occupation\"\n+            \"SELECT\\n    Occupation,\\n    count() AS count_\\nFROM Customers\\nGROUP BY Occupation\"\n         },\n         {\n             \"Customers|summarize sum(Age) by Occupation\",\n-            \"SELECT\\n    sum(Age),\\n    Occupation\\nFROM Customers\\nGROUP BY Occupation\"\n+            \"SELECT\\n    Occupation,\\n    sum(Age) AS sum_Age\\nFROM Customers\\nGROUP BY Occupation\"\n         },\n         {\n             \"Customers|summarize  avg(Age) by Occupation\",\n-            \"SELECT\\n    avg(Age),\\n    Occupation\\nFROM Customers\\nGROUP BY Occupation\"\n+            \"SELECT\\n    Occupation,\\n    avg(Age) AS avg_Age\\nFROM Customers\\nGROUP BY Occupation\"\n         },\n         {\n             \"Customers|summarize  min(Age) by Occupation\",\n-            \"SELECT\\n    min(Age),\\n    Occupation\\nFROM Customers\\nGROUP BY Occupation\"\n+            \"SELECT\\n    Occupation,\\n    min(Age) AS min_Age\\nFROM Customers\\nGROUP BY Occupation\"\n         },\n         {\n             \"Customers |summarize  max(Age) by Occupation\",\n-            \"SELECT\\n    max(Age),\\n    Occupation\\nFROM Customers\\nGROUP BY Occupation\"\n+            \"SELECT\\n    Occupation,\\n    max(Age) AS max_Age\\nFROM Customers\\nGROUP BY Occupation\"\n         },\n         {\n             \"Customers | where FirstName contains 'pet'\",\n@@ -486,6 +473,146 @@ INSTANTIATE_TEST_SUITE_P(ParserKQLQuery, ParserTest,\n         {\n             \"Customers | where FirstName !startswith 'pet'\",\n             \"SELECT *\\nFROM Customers\\nWHERE NOT (FirstName ILIKE 'pet%')\"\n+        },\n+        {\n+            \"Customers | where Age in ((Customers|project Age|where Age < 30))\",\n+            \"SELECT *\\nFROM Customers\\nWHERE Age IN (\\n    SELECT Age\\n    FROM Customers\\n    WHERE Age < 30\\n)\"\n+        },\n+        {\n+            \"Customers|where Occupation has_any ('Skilled','abcd')\",\n+            \"SELECT *\\nFROM Customers\\nWHERE hasTokenCaseInsensitive(Occupation, 'Skilled') OR hasTokenCaseInsensitive(Occupation, 'abcd')\"\n+        },\n+        {\n+            \"Customers|where Occupation has_all ('Skilled','abcd')\",\n+            \"SELECT *\\nFROM Customers\\nWHERE hasTokenCaseInsensitive(Occupation, 'Skilled') AND hasTokenCaseInsensitive(Occupation, 'abcd')\"\n+        },\n+        {\n+            \"Customers|where Occupation has_all (strcat('Skill','ed'),'Manual')\",\n+            \"SELECT *\\nFROM Customers\\nWHERE hasTokenCaseInsensitive(Occupation, concat('Skill', 'ed')) AND hasTokenCaseInsensitive(Occupation, 'Manual')\"\n+        },\n+        {\n+            \"Customers | where Occupation == strcat('Pro','fessional') | take 1\",\n+            \"SELECT *\\nFROM Customers\\nWHERE Occupation = concat('Pro', 'fessional')\\nLIMIT 1\"\n+        },\n+        {\n+            \"Customers | project countof('The cat sat on the mat', 'at')\",\n+            \"SELECT countSubstrings('The cat sat on the mat', 'at')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project countof('The cat sat on the mat', 'at', 'normal')\",\n+            \"SELECT countSubstrings('The cat sat on the mat', 'at')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project countof('The cat sat on the mat', 'at', 'regex')\",\n+            \"SELECT countMatches('The cat sat on the mat', 'at')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 0, 'The price of PINEAPPLE ice cream is 10')\",\n+            \"SELECT extract('The price of PINEAPPLE ice cream is 10', '\\\\b[A-Z]+\\\\b.+\\\\b\\\\\\\\d+')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 1, 'The price of PINEAPPLE ice cream is 20')\",\n+            \"SELECT extract('The price of PINEAPPLE ice cream is 20', '\\\\b[A-Z]+\\\\b')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 2, 'The price of PINEAPPLE ice cream is 30')\",\n+            \"SELECT extract('The price of PINEAPPLE ice cream is 30', '\\\\b\\\\\\\\d+')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 2, 'The price of PINEAPPLE ice cream is 40', typeof(int))\",\n+            \"SELECT accurateCastOrNull(extract('The price of PINEAPPLE ice cream is 40', '\\\\b\\\\\\\\d+'), 'Int32')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project extract_all('(\\\\w)(\\\\w+)(\\\\w)','The price of PINEAPPLE ice cream is 50')\",\n+            \"SELECT extractAllGroups('The price of PINEAPPLE ice cream is 50', '(\\\\\\\\w)(\\\\\\\\w+)(\\\\\\\\w)')\\nFROM Customers\"\n+        },\n+        {\n+            \" Customers | project split('aa_bb', '_')\",\n+            \"SELECT if(empty('_'), splitByString(' ', 'aa_bb'), splitByString('_', 'aa_bb'))\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project split('aaa_bbb_ccc', '_', 1)\",\n+            \"SELECT multiIf((length(if(empty('_'), splitByString(' ', 'aaa_bbb_ccc'), splitByString('_', 'aaa_bbb_ccc'))) >= 2) AND (2 > 0), arrayPushBack([], if(empty('_'), splitByString(' ', 'aaa_bbb_ccc'), splitByString('_', 'aaa_bbb_ccc'))[2]), 2 = 0, if(empty('_'), splitByString(' ', 'aaa_bbb_ccc'), splitByString('_', 'aaa_bbb_ccc')), arrayPushBack([], NULL[1]))\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project strcat_delim('-', '1', '2', 'A')\",\n+            \"SELECT concat('1', '-', '2', '-', 'A')\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project indexof('abcdefg','cde')\",\n+            \"SELECT position('abcdefg', 'cde', 1) - 1\\nFROM Customers\"\n+        },\n+        {\n+            \"Customers | project indexof('abcdefg','cde', 2) \",\n+            \"SELECT position('abcdefg', 'cde', 3) - 1\\nFROM Customers\"\n+        },\n+        {\n+            \"print x=1, s=strcat('Hello', ', ', 'World!')\",\n+            \"SELECT\\n    1 AS x,\\n    concat('Hello', ', ', 'World!') AS s\"\n+        },\n+        {\n+            \"print parse_urlquery('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')\",\n+            \"SELECT concat('{', concat('\\\"Query Parameters\\\":', concat('{\\\"', replace(replace(if(position('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment', '?') > 0, queryString('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), 'https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '=', '\\\":\\\"'), '&', '\\\",\\\"'), '\\\"}')), '}')\"\n+        },\n+        {\n+            \"print strcmp('a','b')\",\n+            \"SELECT multiIf('a' = 'b', 0, 'a' < 'b', -1, 1)\"\n+        },\n+        {\n+            \"print parse_url('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')\",\n+            \"SELECT concat('{', concat('\\\"Scheme\\\":\\\"', protocol('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\\\"'), ',', concat('\\\"Host\\\":\\\"', domain('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\\\"'), ',', concat('\\\"Port\\\":\\\"', toString(port('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment')), '\\\"'), ',', concat('\\\"Path\\\":\\\"', path('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\\\"'), ',', concat('\\\"Username\\\":\\\"', splitByChar(':', splitByChar('@', netloc('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'))[1])[1], '\\\"'), ',', concat('\\\"Password\\\":\\\"', splitByChar(':', splitByChar('@', netloc('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'))[1])[2], '\\\"'), ',', concat('\\\"Query Parameters\\\":', concat('{\\\"', replace(replace(queryString('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '=', '\\\":\\\"'), '&', '\\\",\\\"'), '\\\"}')), ',', concat('\\\"Fragment\\\":\\\"', fragment('https://john:123@google.com:1234/this/is/a/path?k1=v1&k2=v2#fragment'), '\\\"'), '}')\"\n+        },\n+        {\n+            \"Customers | summarize t = make_list(FirstName) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupArrayIf(FirstName, FirstName IS NOT NULL) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_list(FirstName, 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupArrayIf(10)(FirstName, FirstName IS NOT NULL) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_list_if(FirstName, Age > 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupArrayIf(FirstName, Age > 10) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_list_if(FirstName, Age > 10, 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupArrayIf(10)(FirstName, Age > 10) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_set(FirstName) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupUniqArray(FirstName) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_set(FirstName, 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupUniqArray(10)(FirstName) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_set_if(FirstName, Age > 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupUniqArrayIf(FirstName, Age > 10) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"Customers | summarize t = make_set_if(FirstName, Age > 10, 10) by FirstName\",\n+            \"SELECT\\n    FirstName,\\n    groupUniqArrayIf(10)(FirstName, Age > 10) AS t\\nFROM Customers\\nGROUP BY FirstName\"\n+        },\n+        {\n+            \"print output = dynamic([1, 2, 3])\",\n+            \"SELECT [1, 2, 3] AS output\"\n+        },\n+        {\n+            \"print output = dynamic(['a', 'b', 'c'])\",\n+            \"SELECT ['a', 'b', 'c'] AS output\"\n+        },\n+        {\n+            \"T | extend duration = endTime - startTime\",\n+            \"SELECT\\n    * EXCEPT duration,\\n    endTime - startTime AS duration\\nFROM T\"\n+        },\n+        {\n+            \"T |project endTime, startTime | extend duration = endTime - startTime\",\n+            \"SELECT\\n    * EXCEPT duration,\\n    endTime - startTime AS duration\\nFROM\\n(\\n    SELECT\\n        endTime,\\n        startTime\\n    FROM T\\n)\"\n+        },\n+        {\n+            \"T | extend c =c*2, b-a, d = a + b, a*b\",\n+            \"SELECT\\n    * EXCEPT c EXCEPT d,\\n    c * 2 AS c,\\n    b - a AS Column1,\\n    a + b AS d,\\n    a * b AS Column2\\nFROM T\"\n         }\n })));\n \ndiff --git a/src/Parsers/tests/gtest_common.cpp b/src/Parsers/tests/gtest_common.cpp\nnew file mode 100644\nindex 000000000000..7710df946445\n--- /dev/null\n+++ b/src/Parsers/tests/gtest_common.cpp\n@@ -0,0 +1,81 @@\n+#include \"gtest_common.h\"\n+\n+#include <Parsers/Access/ASTAuthenticationData.h>\n+#include <Parsers/Access/ASTCreateUserQuery.h>\n+#include <Parsers/formatAST.h>\n+#include <Parsers/parseQuery.h>\n+#include <Parsers/Kusto/parseKQLQuery.h>\n+\n+#include <gmock/gmock.h>\n+\n+#include <regex>\n+\n+namespace\n+{\n+using namespace DB;\n+using namespace std::literals;\n+}\n+\n+\n+TEST_P(ParserRegexTest, parseQuery)\n+{\n+    const auto & parser = std::get<0>(GetParam());\n+    const auto & [input_text, expected_ast] = std::get<1>(GetParam());\n+\n+    ASSERT_TRUE(parser);\n+    ASSERT_TRUE(expected_ast);\n+\n+    DB::ASTPtr ast;\n+    ASSERT_NO_THROW(ast = parseQuery(*parser, input_text.begin(), input_text.end(), 0, 0));\n+    DB::WriteBufferFromOwnString buf;\n+    formatAST(*ast->clone(), buf, false, false);\n+    EXPECT_THAT(buf.str(), ::testing::MatchesRegex(expected_ast));\n+}\n+\n+TEST_P(ParserKQLTest, parseKQLQuery)\n+{\n+    const auto & parser = std::get<0>(GetParam());\n+    const auto & [input_text, expected_ast] = std::get<1>(GetParam());\n+\n+    ASSERT_NE(nullptr, parser);\n+\n+    if (expected_ast)\n+    {\n+        if (std::string(expected_ast).starts_with(\"throws\"))\n+        {\n+            EXPECT_THROW(parseKQLQuery(*parser, input_text.begin(), input_text.end(), 0, 0), DB::Exception);\n+        }\n+        else\n+        {\n+            DB::ASTPtr ast;\n+            ASSERT_NO_THROW(ast = parseKQLQuery(*parser, input_text.begin(), input_text.end(), 0, 0));\n+            if (std::string(\"CREATE USER or ALTER USER query\") != parser->getName()\n+                    && std::string(\"ATTACH access entity query\") != parser->getName())\n+            {\n+                DB::WriteBufferFromOwnString buf;\n+                formatAST(*ast->clone(), buf, false, false);\n+                String formatted_ast = buf.str();\n+                EXPECT_EQ(expected_ast, formatted_ast);\n+            }\n+            else\n+            {\n+                if (input_text.starts_with(\"ATTACH\"))\n+                {\n+                    auto salt = (dynamic_cast<const ASTCreateUserQuery *>(ast.get())->auth_data)->getSalt().value_or(\"\");\n+                    EXPECT_TRUE(std::regex_match(salt, std::regex(expected_ast)));\n+                }\n+                else\n+                {\n+                    DB::WriteBufferFromOwnString buf;\n+                    formatAST(*ast->clone(), buf, false, false);\n+                    String formatted_ast = buf.str();\n+                    EXPECT_TRUE(std::regex_match(formatted_ast, std::regex(expected_ast)));\n+                }\n+            }\n+        }\n+    }\n+    else\n+    {\n+        ASSERT_THROW(parseKQLQuery(*parser, input_text.begin(), input_text.end(), 0, 0), DB::Exception);\n+    }\n+}\ndiff --git a/src/Parsers/tests/gtest_common.h b/src/Parsers/tests/gtest_common.h\nnew file mode 100644\nindex 000000000000..0c6b21217fbd\n--- /dev/null\n+++ b/src/Parsers/tests/gtest_common.h\n@@ -0,0 +1,20 @@\n+#pragma once\n+\n+#include <Parsers/IParser.h>\n+\n+#include <gtest/gtest.h>\n+\n+#include <string_view>\n+\n+struct ParserTestCase\n+{\n+    const std::string_view input_text;\n+    const char * expected_ast = nullptr;\n+};\n+\n+class ParserTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<DB::IParser>, ParserTestCase>>\n+{};\n+class ParserKQLTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<DB::IParser>, ParserTestCase>>\n+{};\n+class ParserRegexTest : public ::testing::TestWithParam<std::tuple<std::shared_ptr<DB::IParser>, ParserTestCase>>\n+{};\ndiff --git a/tests/queries/0_stateless/02366_kql_create_table.reference b/tests/queries/0_stateless/02366_kql_create_table.reference\nnew file mode 100644\nindex 000000000000..35136b5ff425\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_create_table.reference\n@@ -0,0 +1,4 @@\n+-- test create table --\n+Theodore\n+Diaz\n+Theodore\tDiaz\t28\ndiff --git a/tests/queries/0_stateless/02366_kql_create_table.sql b/tests/queries/0_stateless/02366_kql_create_table.sql\nnew file mode 100644\nindex 000000000000..b266679b06aa\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_create_table.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS Customers;\n+CREATE TABLE Customers\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Occupation String,\n+    Education String,\n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+\n+INSERT INTO Customers VALUES  ('Theodore','Diaz','Skilled Manual','Bachelors',28),('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);\n+Select '-- test create table --' ;\n+Select * from kql(Customers|project FirstName) limit 1;;\n+DROP TABLE IF EXISTS kql_table1;\n+CREATE TABLE kql_table1 ENGINE = Memory AS select *, now() as new_column From kql(Customers | project LastName | filter LastName=='Diaz');\n+select LastName from kql_table1 limit 1;\n+DROP TABLE IF EXISTS kql_table2;\n+CREATE TABLE kql_table2\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+INSERT INTO kql_table2 select * from kql(Customers|project FirstName,LastName,Age | filter FirstName=='Theodore');\n+select * from kql_table2 limit 1;\n+-- select * from kql(Customers | where FirstName !in (\"test\", \"test2\"));\n+DROP TABLE IF EXISTS Customers;\n+DROP TABLE IF EXISTS kql_table1;\n+DROP TABLE IF EXISTS kql_table2;\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02366_kql_datatype.reference b/tests/queries/0_stateless/02366_kql_datatype.reference\nnew file mode 100644\nindex 000000000000..fe666f3734c7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_datatype.reference\n@@ -0,0 +1,105 @@\n+-- bool\n+true\n+\\N\n+-- int\n+123\n+\\N\n+-- long\n+123\n+255\n+-1\n+\\N\n+456\n+-- real\n+0.01\n+\\N\n+nan\n+inf\n+-inf\n+-- datetime\n+2015-12-31 23:59:59.900000000\n+2015-12-31 00:00:00.000000000\n+2014-05-25 08:20:03.123456000\n+2014-11-08 15:55:55.000000000\n+2014-11-08 15:55:00.000000000\n+2014-11-08 00:00:00.000000000\n+\\N\n+2014-05-25 08:20:03.123456000\n+2014-11-08 15:55:55.123456000\n+-- time\n+1216984.12345\n+45055.123\n+86400\n+-86400\n+6.000000000000001e-9\n+6e-7\n+172800\n+259200\n+-- guid\n+\\N\n+-- timespan (time)\n+172800\n+1800\n+10\n+0.1\n+0.00001\n+1e-7\n+1120343\n+-- null\n+1\n+\\N\t\\N\t\\N\t\\N\t\\N\n+-- decimal\n+\\N\n+123.345\n+100000\n+-- dynamic\n+\\N\n+1\n+86400\n+[1,2,3]\n+[[1],[2],[3]]\n+['a','b','c']\n+-- cast functions\n+true\n+1\n+-- tobool(\"false\")\n+false\n+1\n+-- tobool(1)\n+true\n+1\n+-- tobool(123)\n+true\n+1\n+-- tobool(\"abc\")\n+\\N\n+\\N\n+-- todouble()\n+123.4\n+\\N\n+-- toreal()\n+123.4\n+\\N\n+-- toint()\n+1\n+\\N\n+-- tostring()\n+123\n+1\n+-- todatetime()\n+1\n+\\N\n+-- make_timespan()\n+01:12:00\t01:12:30\t1.12:30:55\n+-- totimespan()\n+1e-7\n+60\n+\\N\n+1120343\n+-- tolong()\n+123\n+\\N\n+-- todecimal()\n+123.345\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/02366_kql_datatype.sql b/tests/queries/0_stateless/02366_kql_datatype.sql\nnew file mode 100644\nindex 000000000000..ecd295042984\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_datatype.sql\n@@ -0,0 +1,117 @@\n+set dialect = 'kusto';\n+\n+print '-- bool'\n+print bool(true);\n+print bool(true);\n+print bool(null);\n+print '-- int';\n+print int(123);\n+print int(null);\n+print int('4'); -- { clientError BAD_ARGUMENTS }\n+print '-- long';\n+print long(123);\n+print long(0xff);\n+print long(-1);\n+print long(null);\n+print 456;\n+print '-- real';\n+print real(0.01);\n+print real(null);\n+print real(nan);\n+print real(+inf);\n+print real(-inf);\n+print double('4.2'); -- { clientError BAD_ARGUMENTS }\n+print '-- datetime';\n+print datetime(2015-12-31 23:59:59.9);\n+print datetime(2015-12-31);\n+print datetime('2014-05-25T08:20:03.123456');\n+print datetime('2014-11-08 15:55:55');\n+print datetime('2014-11-08 15:55');\n+print datetime('2014-11-08');\n+print datetime(null);\n+print datetime('2014-05-25T08:20:03.123456Z');\n+print datetime('2014-11-08 15:55:55.123456Z');\n+print '-- time';\n+print time('14.02:03:04.12345');\n+print time('12:30:55.123');\n+print time(1d);\n+print time(-1d);\n+print time(6nanoseconds);\n+print time(6tick);\n+print time(2);\n+print time(2) + 1d;\n+print '-- guid'\n+print guid(74be27de-1e4e-49d9-b579-fe0b331d3642);\n+print guid(null);\n+print '-- timespan (time)';\n+print timespan(2d); --              2 days\n+--print timespan(1.5h); -- \t        1.5 hour\n+print timespan(30m); -- \t        30 minutes\n+print timespan(10s); -- \t        10 seconds\n+--print timespan(0.1s); -- \t        0.1 second\n+print timespan(100ms); -- \t        100 millisecond\n+print timespan(10microsecond); -- \t10 microseconds\n+print timespan(1tick); --           100 nanoseconds\n+--print timespan(1.5h) / timespan(30m);\n+print timespan('12.23:12:23') / timespan(1s);\n+print '-- null';\n+print isnull(null);\n+print bool(null), int(null), long(null), real(null), double(null);\n+print '-- decimal';\n+print decimal(null);\n+print decimal(123.345);\n+print decimal(1e5);\n+print '-- dynamic'; -- no support for mixed types and bags for now\n+print dynamic(null);\n+print dynamic(1);\n+print dynamic(timespan(1d));\n+print dynamic([1,2,3]);\n+print dynamic([[1], [2], [3]]);\n+print dynamic(['a', \"b\", 'c']);\n+print '-- cast functions'\n+print '--tobool(\"true\")'; -- == true\n+print tobool('true'); -- == true\n+print tobool('true') == toboolean('true'); -- == true\n+print '-- tobool(\"false\")'; -- == false\n+print tobool('false'); -- == false\n+print tobool('false') == toboolean('false'); -- == false\n+print '-- tobool(1)'; -- == true\n+print tobool(1); -- == true\n+print tobool(1) == toboolean(1); -- == true\n+print '-- tobool(123)'; -- == true\n+print tobool(123); -- == true\n+print tobool(123) == toboolean(123); -- == true\n+print '-- tobool(\"abc\")'; -- == null\n+print tobool('abc'); -- == null\n+print tobool('abc') == toboolean('abc'); -- == null\n+print '-- todouble()';\n+print todouble('123.4');\n+print todouble('abc') == null;\n+print '-- toreal()';\n+print toreal(\"123.4\");\n+print toreal('abc') == null;\n+print '-- toint()';\n+print toint(\"123\") == int(123);\n+print toint('abc');\n+print '-- tostring()';\n+print tostring(123);\n+print tostring(null) == '';\n+print '-- todatetime()';\n+print todatetime(\"2015-12-24\") == datetime(2015-12-24);\n+print todatetime('abc') == null;\n+print '-- make_timespan()';\n+print v1=make_timespan(1,12), v2=make_timespan(1,12,30), v3=make_timespan(1,12,30,55.123);\n+print '-- totimespan()';\n+print totimespan(1tick);\n+print totimespan('0.00:01:00');\n+print totimespan('abc');\n+print totimespan('12.23:12:23') / totimespan(1s);\n+-- print totimespan(strcat('12.', '23', ':12:', '23')) / timespan(1s); -> 1120343\n+print '-- tolong()';\n+print tolong('123');\n+print tolong('abc');\n+print '-- todecimal()';\n+print todecimal(123.345);\n+print todecimal(null);\n+print todecimal('abc');\n+-- print todecimal(4 * 2 + 3); -> 11\ndiff --git a/tests/queries/0_stateless/02366_kql_distinct.reference b/tests/queries/0_stateless/02366_kql_distinct.reference\nnew file mode 100644\nindex 000000000000..2100f44f18c9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_distinct.reference\n@@ -0,0 +1,27 @@\n+--  distinct * --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\\N\twhy\tProfessional\tPartial College\t38\n+--  distinct one column --\n+Skilled Manual\n+Management abcd defg\n+Professional\n+--  distinct two column --\n+Skilled Manual\tBachelors\n+Management abcd defg\tBachelors\n+Skilled Manual\tGraduate Degree\n+Professional\tGraduate Degree\n+Professional\tPartial College\n+--  distinct with where --\n+Skilled Manual\tBachelors\n+Management abcd defg\tBachelors\n+Skilled Manual\tGraduate Degree\n+Professional\tGraduate Degree\n+Professional\tPartial College\n+--  distinct with where, order --\n+Skilled Manual\tBachelors\n+Skilled Manual\tGraduate Degree\n+Professional\tGraduate Degree\ndiff --git a/tests/queries/0_stateless/02366_kql_distinct.sql b/tests/queries/0_stateless/02366_kql_distinct.sql\nnew file mode 100644\nindex 000000000000..3c997eb4865b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_distinct.sql\n@@ -0,0 +1,28 @@\n+DROP TABLE IF EXISTS Customers;\n+CREATE TABLE Customers\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Occupation String,\n+    Education String,\n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+\n+INSERT INTO Customers VALUES ('Theodore','Diaz','Skilled Manual','Bachelors',28), ('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);\n+\n+set dialect = 'kusto';\n+\n+print '--  distinct * --';\n+Customers | distinct *;\n+\n+print '--  distinct one column --';\n+Customers | distinct Occupation;\n+\n+print '--  distinct two column --';\n+Customers | distinct Occupation, Education;\n+\n+print '--  distinct with where --';\n+Customers where Age <30 | distinct Occupation, Education;\n+\n+print '--  distinct with where, order --';\n+Customers |where Age <30 | order by Age| distinct Occupation, Education;\ndiff --git a/tests/queries/0_stateless/02366_kql_extend.reference b/tests/queries/0_stateless/02366_kql_extend.reference\nnew file mode 100644\nindex 000000000000..2936c9ea19c1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_extend.reference\n@@ -0,0 +1,32 @@\n+-- extend #1 --\n+Aldi\tApple\t4\t2016-09-10\t400\n+Costco\tApple\t2\t2016-09-11\t200\n+-- extend #2 --\n+Apple\t200\n+Apple\t400\n+-- extend #3 --\n+Apple cost 480 on average based on 5 samples.\n+Snargaluff cost 28080 on average based on 5 samples.\n+-- extend #4 --\n+1\n+-- extend #5 --\n+Aldi\tApple\t4\t2016-09-10\tApple was purchased from Aldi for $4 on 2016-09-10\t400\n+Costco\tApple\t2\t2016-09-11\tApple was purchased from Costco for $2 on 2016-09-11\t200\n+-- extend #6 --\n+Aldi\tApple\t2016-09-10\t400\n+Costco\tApple\t2016-09-11\t200\n+Aldi\tApple\t2016-09-10\t600\n+Costco\tSnargaluff\t2016-09-12\t10000\n+Aldi\tApple\t2016-09-12\t700\n+Aldi\tSnargaluff\t2016-09-11\t40000\n+Costco\tSnargaluff\t2016-09-12\t10400\n+Aldi\tApple\t2016-09-12\t500\n+Aldi\tSnargaluff\t2016-09-11\t60000\n+Costco\tSnargaluff\t2016-09-10\t20000\n+-- extend #7 --\n+5\n+-- extend #8 --\n+-- extend #9 --\n+-- extend #10 --\n+-- extend #11 --\n+5\t[2,1]\ndiff --git a/tests/queries/0_stateless/02366_kql_extend.sql b/tests/queries/0_stateless/02366_kql_extend.sql\nnew file mode 100644\nindex 000000000000..3de489b08156\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_extend.sql\n@@ -0,0 +1,58 @@\n+-- datatable(Supplier:string, Fruit:string, Price: real, Purchase:datetime)\n+-- [\n+--     'Aldi','Apple',4,'2016-09-10',\n+--     'Costco','Apple',2,'2016-09-11',\n+--     'Aldi','Apple',6,'2016-09-10',\n+--     'Costco','Snargaluff',100,'2016-09-12',\n+--     'Aldi','Apple',7,'2016-09-12',\n+--     'Aldi','Snargaluff',400,'2016-09-11',\n+--     'Costco','Snargaluff',104,'2016-09-12',\n+--     'Aldi','Apple',5,'2016-09-12',\n+--     'Aldi','Snargaluff',600,'2016-09-11',\n+--     'Costco','Snargaluff',200,'2016-09-10',\n+-- ]\n+\n+DROP TABLE IF EXISTS Ledger;\n+CREATE TABLE Ledger\n+(    \n+   Supplier Nullable(String),\n+   Fruit String ,\n+   Price Float64,\n+   Purchase Date \n+) ENGINE = Memory;\n+INSERT INTO Ledger VALUES  ('Aldi','Apple',4,'2016-09-10'), ('Costco','Apple',2,'2016-09-11'), ('Aldi','Apple',6,'2016-09-10'), ('Costco','Snargaluff',100,'2016-09-12'), ('Aldi','Apple',7,'2016-09-12'), ('Aldi','Snargaluff',400,'2016-09-11'),('Costco','Snargaluff',104,'2016-09-12'),('Aldi','Apple',5,'2016-09-12'),('Aldi','Snargaluff',600,'2016-09-11'),('Costco','Snargaluff',200,'2016-09-10');\n+\n+set dialect = 'kusto';\n+\n+print '-- extend #1 --';\n+Ledger | extend PriceInCents = 100 * Price | take 2;\n+\n+print '-- extend #2 --';\n+Ledger | extend PriceInCents = 100 * Price | sort by PriceInCents asc | project Fruit, PriceInCents | take 2;\n+\n+print '-- extend #3 --';\n+Ledger | extend PriceInCents = 100 * Price | sort by PriceInCents asc | project Fruit, PriceInCents | summarize AveragePrice = avg(PriceInCents), Purchases = count() by Fruit | extend Sentence = strcat(Fruit, ' cost ', tostring(AveragePrice), ' on average based on ', tostring(Purchases), ' samples.') | project Sentence;\n+\n+print '-- extend #4 --';\n+Ledger | extend a = Price | extend b = a | extend c = a, d = b + 500 | extend Pass = bool(b == a and c == a and d == b + 500) | summarize binary_all_and(Pass);\n+\n+print '-- extend #5 --';\n+Ledger | take 2 | extend strcat(Fruit, ' was purchased from ', Supplier, ' for $', tostring(Price), ' on ', tostring(Purchase)) | extend PriceInCents = 100 * Price;\n+\n+print '-- extend #6 --';\n+Ledger | extend Price = 100 * Price;\n+\n+print '-- extend #7 --';\n+print a = 4 | extend a = 5;\n+\n+print '-- extend #8 --';\n+-- print x = 5 | extend array_sort_desc(range(0, x), range(1, x + 1))\n+\n+print '-- extend #9 --';\n+print x = 19 | extend = 4 + ; -- { clientError SYNTAX_ERROR }\n+\n+print '-- extend #10 --';\n+Ledger | extend PriceInCents = * Price | sort by PriceInCents asc | project Fruit, PriceInCents | summarize AveragePrice = avg(PriceInCents), Purchases = count() by Fruit | extend Sentence = strcat(Fruit, ' cost ', tostring(AveragePrice), ' on average based on ', tostring(Purchases), ' samples.') | project Sentence; -- { clientError SYNTAX_ERROR }\n+\n+print '-- extend #11 --'; -- should ideally return this in the future: 5\t[2,1] because of the alias ex\n+print x = 5 | extend ex = array_sort_desc(dynamic([1, 2]), dynamic([3, 4]));\ndiff --git a/tests/queries/0_stateless/02366_kql_func_binary.reference b/tests/queries/0_stateless/02366_kql_func_binary.reference\nnew file mode 100644\nindex 000000000000..6276cd6d8675\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_binary.reference\n@@ -0,0 +1,7 @@\n+ -- binary functions\n+4\t7\n+1\n+1\n+1\n+7\t3\n+1\ndiff --git a/tests/queries/0_stateless/02366_kql_func_binary.sql b/tests/queries/0_stateless/02366_kql_func_binary.sql\nnew file mode 100644\nindex 000000000000..824022b564ce\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_binary.sql\n@@ -0,0 +1,8 @@\n+set dialect='kusto';\n+print ' -- binary functions';\n+print binary_and(4,7), binary_or(4,7);\n+print binary_shift_left(1, 1) == binary_shift_left(1, 65);\n+print binary_shift_right(2, 1) == binary_shift_right(2, 65);\n+print binary_shift_right(binary_shift_left(1, 65), 65) == 1;\n+print binary_xor(2, 5), bitset_count_ones(42);\n+print bitset_count_ones(binary_shift_left(binary_and(4,7), 1));\ndiff --git a/tests/queries/0_stateless/02366_kql_func_datetime.reference b/tests/queries/0_stateless/02366_kql_func_datetime.reference\nnew file mode 100644\nindex 000000000000..40d8d7e19ac9\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_datetime.reference\n@@ -0,0 +1,76 @@\n+-- dayofmonth()\n+31\n+-- dayofweek()\n+4.00:00:00\n+-- dayofyear()\n+365\n+-- getmonth()\n+10\n+-- getyear()\n+2015\n+-- hoursofday()\n+23\n+-- startofday()\n+2017-01-01 00:00:00.000000000\n+2016-12-31 00:00:00.000000000\n+2017-01-02 00:00:00.000000000\n+-- endofday()\n+2017-01-01 23:59:59.999999000\n+2016-12-31 23:59:59.999999000\n+2017-01-02 23:59:59.999999000\n+-- endofmonth()\n+2017-01-31 23:59:59.999999000\n+2016-12-31 23:59:59.999999000\n+2017-02-28 23:59:59.999999000\n+2022-09-30 23:59:59.999999000\n+-- startofweek()\n+2017-01-01 00:00:00.000000000\n+2016-12-25 00:00:00.000000000\n+2017-01-08 00:00:00.000000000\n+-- endofweek()\n+2017-01-07 23:59:59.999999000\n+2016-12-31 23:59:59.999999000\n+2017-01-14 23:59:59.999999000\n+-- startofyear()\n+2017-01-01 00:00:00.000000000\n+2016-01-01 00:00:00.000000000\n+2018-01-01 00:00:00.000000000\n+-- endofyear()\n+2017-12-31 23:59:59.999999000\n+2016-12-31 23:59:59.999999000\n+2018-12-31 23:59:59.999999000\n+-- unixtime_seconds_todatetime()\n+2019-01-01 00:00:00.000000000\n+1970-01-02 00:00:00.000000000\n+1969-12-31 00:00:00.000000000\n+-- unixtime_microseconds_todatetime\n+2019-01-01 00:00:00.000000\n+-- unixtime_milliseconds_todatetime()\n+2019-01-01 00:00:00.000\n+-- unixtime_nanoseconds_todatetime()\n+2019-01-01 00:00:00.000000000\n+-- weekofyear()\n+52\n+-- monthofyear()\n+12\n+-- weekofyear()\n+52\n+-- now()\n+1\n+-- make_datetime()\n+1\n+2017-10-01 12:10:00.0000000\n+2017-10-01 12:11:00.0000000\n+-- format_datetime\n+15-12-14 02:03:04.1234500\n+17-01-29 [09:00:05]\t2017-01-29 [09:00:05]\t17-01-29 [09:00:05 AM]\n+-- format_timespan()\n+02:03:04.1234500\n+29.09:00:05:12\n+-- ago()\n+-- datetime_diff()\n+17\t2\t13\t4\t29\t2\t5\t10\n+-- datetime_part()\n+2017\t4\t10\t44\t30\t303\t01\t02\t03\n+-- datetime_add()\n+2018-01-01 00:00:00.0000000\t2017-04-01 00:00:00.0000000\t2017-02-01 00:00:00.0000000\t2017-01-08 00:00:00.0000000\t2017-01-02 00:00:00.0000000\t2017-01-01 01:00:00.0000000\t2017-01-01 00:01:00.0000000\t2017-01-01 00:00:01.0000000\ndiff --git a/tests/queries/0_stateless/02366_kql_func_datetime.sql b/tests/queries/0_stateless/02366_kql_func_datetime.sql\nnew file mode 100644\nindex 000000000000..b1fba4166a9e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_datetime.sql\n@@ -0,0 +1,86 @@\n+set dialect = 'kusto';\n+\n+print '-- dayofmonth()';\n+print dayofmonth(datetime(2015-12-31));\n+print '-- dayofweek()';\n+print dayofweek(datetime(2015-12-31));\n+print '-- dayofyear()';\n+print dayofyear(datetime(2015-12-31));\n+print '-- getmonth()';\n+print getmonth(datetime(2015-10-12));\n+print '-- getyear()';\n+print getyear(datetime(2015-10-12));\n+print '-- hoursofday()';\n+print hourofday(datetime(2015-12-31 23:59:59.9));\n+print '-- startofday()';\n+print startofday(datetime(2017-01-01 10:10:17));\n+print startofday(datetime(2017-01-01 10:10:17), -1);\n+print startofday(datetime(2017-01-01 10:10:17), 1);\n+print '-- endofday()';\n+print endofday(datetime(2017-01-01 10:10:17));\n+print endofday(datetime(2017-01-01 10:10:17), -1);\n+print endofday(datetime(2017-01-01 10:10:17), 1);\n+print '-- endofmonth()';\n+print endofmonth(datetime(2017-01-01 10:10:17));\n+print endofmonth(datetime(2017-01-01 10:10:17), -1);\n+print endofmonth(datetime(2017-01-01 10:10:17), 1);\n+print endofmonth(datetime(2022-09-23));\n+print '-- startofweek()';\n+print startofweek(datetime(2017-01-01 10:10:17));\n+print startofweek(datetime(2017-01-01 10:10:17), -1);\n+print startofweek(datetime(2017-01-01 10:10:17), 1);\n+print '-- endofweek()';\n+print endofweek(datetime(2017-01-01 10:10:17));\n+print endofweek(datetime(2017-01-01 10:10:17), -1);\n+print endofweek(datetime(2017-01-01 10:10:17), 1);\n+print '-- startofyear()';\n+print startofyear(datetime(2017-01-01 10:10:17));\n+print startofyear(datetime(2017-01-01 10:10:17), -1);\n+print startofyear(datetime(2017-01-01 10:10:17), 1);\n+print '-- endofyear()';\n+print endofyear(datetime(2017-01-01 10:10:17));\n+print endofyear(datetime(2017-01-01 10:10:17), -1);\n+print endofyear(datetime(2017-01-01 10:10:17), 1);\n+print '-- unixtime_seconds_todatetime()';\n+print unixtime_seconds_todatetime(1546300800);\n+print unixtime_seconds_todatetime(1d);\n+print unixtime_seconds_todatetime(-1d);\n+print '-- unixtime_microseconds_todatetime';\n+print unixtime_microseconds_todatetime(1546300800000000);\n+print '-- unixtime_milliseconds_todatetime()';\n+print unixtime_milliseconds_todatetime(1546300800000);\n+print '-- unixtime_nanoseconds_todatetime()';\n+print unixtime_nanoseconds_todatetime(1546300800000000000);\n+print '-- weekofyear()';\n+print week_of_year(datetime(2000-01-01));\n+print '-- monthofyear()';\n+print monthofyear(datetime(2015-12-31));\n+print '-- weekofyear()';\n+print week_of_year(datetime(2000-01-01));\n+print '-- now()';\n+print getyear(now(-2d))>1900;\n+print '-- make_datetime()';\n+print make_datetime(2017,10,01,12,10) == datetime(2017-10-01 12:10:00);\n+print year_month_day_hour_minute = make_datetime(2017,10,01,12,10);\n+print year_month_day_hour_minute_second = make_datetime(2017,10,01,12,11,0.1234567);\n+print '-- format_datetime';\n+print format_datetime(datetime(2015-12-14 02:03:04.12345), 'y-M-d h:m:s.fffffff');\n+print v1=format_datetime(datetime(2017-01-29 09:00:05),'yy-MM-dd [HH:mm:ss]'), v2=format_datetime(datetime(2017-01-29 09:00:05), 'yyyy-M-dd [H:mm:ss]'), v3=format_datetime(datetime(2017-01-29 09:00:05), 'yy-MM-dd [hh:mm:ss tt]');\n+print '-- format_timespan()';\n+print format_timespan(time('14.02:03:04.12345'), 'h:m:s.fffffff');\n+print v1=format_timespan(time('29.09:00:05.12345'), 'dd.hh:mm:ss:FF');\n+-- print v2=format_timespan(time('29.09:00:05.12345'), 'ddd.h:mm:ss [fffffff]'); == '029.9:00:05 [1234500]'\n+print '-- ago()';\n+-- print ago(1d) - now();\n+print '-- datetime_diff()';\n+print year = datetime_diff('year',datetime(2017-01-01),datetime(2000-12-31)), quarter = datetime_diff('quarter',datetime(2017-07-01),datetime(2017-03-30)), month = datetime_diff('month',datetime(2017-01-01),datetime(2015-12-30)), week = datetime_diff('week',datetime(2017-10-29 00:00),datetime(2017-09-30 23:59)), day = datetime_diff('day',datetime(2017-10-29 00:00),datetime(2017-09-30 23:59)), hour = datetime_diff('hour',datetime(2017-10-31 01:00),datetime(2017-10-30 23:59)), minute = datetime_diff('minute',datetime(2017-10-30 23:05:01),datetime(2017-10-30 23:00:59)), second = datetime_diff('second',datetime(2017-10-30 23:00:10.100),datetime(2017-10-30 23:00:00.900));\n+-- millisecond = datetime_diff('millisecond',datetime(2017-10-30 23:00:00.200100),datetime(2017-10-30 23:00:00.100900)),\n+-- microsecond = datetime_diff('microsecond',datetime(2017-10-30 23:00:00.1009001),datetime(2017-10-30 23:00:00.1008009)),\n+-- nanosecond = datetime_diff('nanosecond',datetime(2017-10-30 23:00:00.0000000),datetime(2017-10-30 23:00:00.0000007))\n+print '-- datetime_part()';\n+print year = datetime_part(\"year\", datetime(2017-10-30 01:02:03.7654321)),quarter = datetime_part(\"quarter\", datetime(2017-10-30 01:02:03.7654321)),month = datetime_part(\"month\", datetime(2017-10-30 01:02:03.7654321)),weekOfYear = datetime_part(\"week_of_year\", datetime(2017-10-30 01:02:03.7654321)),day = datetime_part(\"day\", datetime(2017-10-30 01:02:03.7654321)),dayOfYear = datetime_part(\"dayOfYear\", datetime(2017-10-30 01:02:03.7654321)),hour = datetime_part(\"hour\", datetime(2017-10-30 01:02:03.7654321)),minute = datetime_part(\"minute\", datetime(2017-10-30 01:02:03.7654321)),second = datetime_part(\"second\", datetime(2017-10-30 01:02:03.7654321));\n+-- millisecond = datetime_part(\"millisecond\", dt),\n+-- microsecond = datetime_part(\"microsecond\", dt),\n+-- nanosecond = datetime_part(\"nanosecond\", dt)\n+print '-- datetime_add()';\n+print  year = datetime_add('year',1,make_datetime(2017,1,1)),quarter = datetime_add('quarter',1,make_datetime(2017,1,1)),month = datetime_add('month',1,make_datetime(2017,1,1)),week = datetime_add('week',1,make_datetime(2017,1,1)),day = datetime_add('day',1,make_datetime(2017,1,1)),hour = datetime_add('hour',1,make_datetime(2017,1,1)),minute = datetime_add('minute',1,make_datetime(2017,1,1)),second = datetime_add('second',1,make_datetime(2017,1,1));\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02366_kql_func_dynamic.reference b/tests/queries/0_stateless/02366_kql_func_dynamic.reference\nnew file mode 100644\nindex 000000000000..564f1eebc4bb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_dynamic.reference\n@@ -0,0 +1,152 @@\n+-- constant index value\n+1\tc\t['A',NULL,'C']\n+-- array_length()\n+1\n+1\n+-- array_sum()\n+1\n+1\n+-- array_index_of()\n+3\n+1\n+-- array_iif()\n+[1,5,3]\n+[1,5,3]\n+[1,5,NULL]\n+[NULL,NULL,NULL]\n+-- array_concat()\n+[1,2,3,4,5,6]\n+-- array_reverse()\n+[]\n+[1]\n+[4,3,2,1]\n+['example','an','is','this']\n+-- array_rotate_left()\n+[]\n+[]\n+[]\n+[3,4,5,1,2]\n+[1,2,3,4,5]\n+[3,4,5,1,2]\n+[4,5,1,2,3]\n+[1,2,3,4,5]\n+[4,5,1,2,3]\n+-- array_rotate_right()\n+[]\n+[]\n+[]\n+[4,5,1,2,3]\n+[1,2,3,4,5]\n+[4,5,1,2,3]\n+[3,4,5,1,2]\n+[1,2,3,4,5]\n+[3,4,5,1,2]\n+-- array_shift_left()\n+[]\n+[]\n+[]\n+[3,4,5,NULL,NULL]\n+[NULL,NULL,1,2,3]\n+[3,4,5,-1,-1]\n+['c','','']\n+-- array_shift_right()\n+[]\n+[]\n+[]\n+[3,4,5,NULL,NULL]\n+[NULL,NULL,1,2,3]\n+[3,4,5,-1,-1]\n+['c','','']\n+-- array_slice()\n+[3,4]\n+-- array_split()\n+[[1],[2,3],[4,5]]\n+[[1,2],[3,4,5]]\n+[[1],[2,3],[4,5]]\n+[[1,2,3,4],[],[4,5]]\n+-- array_sort_asc()\n+(['a','c','c','d',NULL])\n+([1,2,3,4])\n+['a','b','c']\n+(['p','q','r'],['hello','clickhouse','world'])\n+([NULL,'a','c','c','d'])\n+([NULL,'a','c','c','d'])\n+([NULL,NULL,NULL])\n+[1,2,3,NULL,NULL]\n+['a','e','b','c','d']\n+(['George','John','Paul','Ringo'])\n+(['blue','green','yellow',NULL,NULL])\n+([NULL,NULL,'blue','green','yellow'])\n+-- array_sort_desc()\n+(['d','c','c','a',NULL])\n+([4,3,2,1])\n+['c','b','a']\n+(['r','q','p'],['world','clickhouse','hello'])\n+([NULL,'d','c','c','a'])\n+([NULL,'d','c','c','a'])\n+([NULL,NULL,NULL])\n+[3,2,1,NULL,NULL]\n+['d','c','b','e','a']\n+(['Ringo','Paul','John','George'])\n+(['yellow','green','blue',NULL,NULL])\n+([NULL,NULL,'yellow','green','blue'])\n+-- jaccard_index()\n+0.75\n+0\n+0\n+nan\n+0\n+0.75\n+0.25\n+-- pack_array()\n+1\t2\t4\t[1,2,4]\n+['ab','0.0.0.42','4.2']\n+-- repeat()\n+[]\n+[1,1,1]\n+['asd','asd','asd']\n+[86400,86400,86400]\n+[true,true,true]\n+[NULL]\n+[NULL]\n+-- set_difference()\n+[]\n+[]\n+[]\n+[]\n+[4,5,6]\n+[4]\n+[1,3]\n+[1,2,3]\n+['d','s']\n+['Chewbacca','Han Solo']\n+-- set_has_element()\n+0\n+1\n+0\n+1\n+0\n+-- set_intersect()\n+[]\n+[1,2,3]\n+[1,2,3]\n+[]\n+[5]\n+[]\n+['a']\n+['Darth Vader']\n+-- set_union()\n+[]\n+[1,2,3]\n+[1,2,3,4,5,6]\n+[1,2,3,4]\n+[1,2,3,4,5]\n+[1,2,3]\n+['a','d','f','s']\n+['Chewbacca','Darth Sidious','Darth Vader','Han Solo']\n+-- zip()\n+[]\n+[[1,2],[3,4],[5,6]]\n+[['Darth','Vader','has a suit'],['Master','Yoda','doesn\\'t have a suit']]\n+[[1,10],[2,20],[3,NULL]]\n+[[NULL,1],[NULL,2],[NULL,3]]\ndiff --git a/tests/queries/0_stateless/02366_kql_func_dynamic.sql b/tests/queries/0_stateless/02366_kql_func_dynamic.sql\nnew file mode 100644\nindex 000000000000..b0956f032d0c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_dynamic.sql\n@@ -0,0 +1,161 @@\n+DROP TABLE IF EXISTS array_test;\n+CREATE TABLE array_test (floats Array(Float64),\n+                         strings Array(String),\n+                         nullable_strings Array(Nullable(String))\n+                         ) ENGINE=Memory;\n+INSERT INTO array_test VALUES([1.0, 2.5], ['a', 'c'], ['A', NULL, 'C']);\n+set dialect = 'kusto';\n+print '-- constant index value';\n+array_test | project floats[0], strings[1], nullable_strings;\n+print '-- array_length()';\n+print array_length(dynamic(['John', 'Denver', 'Bob', 'Marley'])) == 4;\n+print array_length(dynamic([1, 2, 3])) == 3;\n+print '-- array_sum()';\n+print array_sum(dynamic([2, 5, 3])) == 10;\n+print array_sum(dynamic([2.5, 5.5, 3])) == 11;\n+print '-- array_index_of()';\n+print array_index_of(dynamic(['John', 'Denver', 'Bob', 'Marley']), 'Marley');\n+print array_index_of(dynamic([1, 2, 3]), 2);\n+print '-- array_iif()';\n+print array_iif(dynamic([true,false,true]), dynamic([1,2,3]), dynamic([4,5,6]));\n+print array_iif(dynamic([1,0,1]), dynamic([1,2,3]), dynamic([4,5,6]));\n+print array_iif(dynamic([true,false,true]), dynamic([1,2]), dynamic([4,5,6]));\n+print array_iif(dynamic(['a','b','c']), dynamic([1,2,3]), dynamic([4,5,6]));\n+print '-- array_concat()';\n+print array_concat(dynamic([1,2,3]),dynamic([4,5,6]));\n+print '-- array_reverse()';\n+print array_reverse(dynamic([]));\n+print array_reverse(dynamic([1]));\n+print array_reverse(dynamic([1,2,3,4]));\n+print array_reverse(dynamic([\"this\", \"is\", \"an\", \"example\"]));\n+print '-- array_rotate_left()';\n+print array_rotate_left(dynamic([]), 0);\n+print array_rotate_left(dynamic([]), 500);\n+print array_rotate_left(dynamic([]), -500);\n+print array_rotate_left(dynamic([1,2,3,4,5]), 2);\n+print array_rotate_left(dynamic([1,2,3,4,5]), 5);\n+print array_rotate_left(dynamic([1,2,3,4,5]), 7);\n+print array_rotate_left(dynamic([1,2,3,4,5]), -2);\n+print array_rotate_left(dynamic([1,2,3,4,5]), -5);\n+print array_rotate_left(dynamic([1,2,3,4,5]), -7);\n+print '-- array_rotate_right()';\n+print array_rotate_right(dynamic([]), 0);\n+print array_rotate_right(dynamic([]), 500);\n+print array_rotate_right(dynamic([]), -500);\n+print array_rotate_right(dynamic([1,2,3,4,5]), 2);\n+print array_rotate_right(dynamic([1,2,3,4,5]), 5);\n+print array_rotate_right(dynamic([1,2,3,4,5]), 7);\n+print array_rotate_right(dynamic([1,2,3,4,5]), -2);\n+print array_rotate_right(dynamic([1,2,3,4,5]), -5);\n+print array_rotate_right(dynamic([1,2,3,4,5]), -7);\n+print '-- array_shift_left()';\n+print array_shift_left(dynamic([]), 0);\n+print array_shift_left(dynamic([]), 555);\n+print array_shift_left(dynamic([]), -555);\n+print array_shift_left(dynamic([1,2,3,4,5]), 2);\n+print array_shift_left(dynamic([1,2,3,4,5]), -2);\n+print array_shift_left(dynamic([1,2,3,4,5]), 2, -1);\n+print array_shift_left(dynamic(['a', 'b', 'c']), 2);\n+print '-- array_shift_right()';\n+print array_shift_left(dynamic([]), 0);\n+print array_shift_left(dynamic([]), 555);\n+print array_shift_left(dynamic([]), -555);\n+print array_shift_right(dynamic([1,2,3,4,5]), -2);\n+print array_shift_right(dynamic([1,2,3,4,5]), 2);\n+print array_shift_right(dynamic([1,2,3,4,5]), -2, -1);\n+print array_shift_right(dynamic(['a', 'b', 'c']), -2);\n+print '-- array_slice()';\n+--print array_slice(dynamic([1,2,3]), 1, 2); -- will enable whe analyzer dixed\n+print array_slice(dynamic([1,2,3,4,5]), -3, -2);\n+print '-- array_split()';\n+print array_split(dynamic([1,2,3,4,5]), dynamic([1,-2]));\n+print array_split(dynamic([1,2,3,4,5]), 2);\n+print array_split(dynamic([1,2,3,4,5]), dynamic([1,3]));\n+print array_split(dynamic([1,2,3,4,5]), dynamic([-1,-2]));\n+print '-- array_sort_asc()';\n+print array_sort_asc(dynamic([null, 'd', 'a', 'c', 'c']));\n+print array_sort_asc(dynamic([4, 1, 3, 2]));\n+print array_sort_asc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))[0];\n+print array_sort_asc(dynamic(['q', 'p', 'r']), dynamic(['clickhouse','hello', 'world']));\n+print array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , false);\n+print array_sort_asc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2);\n+print array_sort_asc( dynamic([null, null, null]) , false);\n+print array_sort_asc(dynamic([2, 1, null,3, null]), dynamic([20, 10, 40, 30, 50]), 1 < 2)[0];\n+print array_sort_asc(dynamic(['1','3','4','5','2']),dynamic([\"a\",\"b\",\"c\",\"d\",\"e\"]), dynamic([\"a\",\"b\",\"c\",\"d\",\"e\"]), dynamic([\"a\",\"b\",\"c\",\"d\",\"e\"]))[3];\n+print array_sort_asc(split(\"John,Paul,George,Ringo\", \",\"));\n+print array_sort_asc(dynamic([null,\"blue\",\"yellow\",\"green\",null]));\n+print array_sort_asc(dynamic([null,\"blue\",\"yellow\",\"green\",null]), false);\n+print '-- array_sort_desc()';\n+print array_sort_desc(dynamic([null, 'd', 'a', 'c', 'c']));\n+print array_sort_desc(dynamic([4, 1, 3, 2]));\n+print array_sort_desc(dynamic(['b', 'a', 'c']), dynamic(['q', 'p', 'r']))[0];\n+print array_sort_desc(dynamic(['q', 'p', 'r']), dynamic(['clickhouse','hello', 'world']));\n+print array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , false);\n+print array_sort_desc( dynamic(['d', null, 'a', 'c', 'c']) , 1 > 2);\n+print array_sort_desc( dynamic([null, null, null]) , false);\n+print array_sort_desc(dynamic([2, 1, null,3, null]), dynamic([20, 10, 40, 30, 50]), 1 < 2)[0];\n+print array_sort_desc(dynamic(['1','3','4','5','2']),dynamic([\"a\",\"b\",\"c\",\"d\",\"e\"]), dynamic([\"a\",\"b\",\"c\",\"d\",\"e\"]), dynamic([\"a\",\"b\",\"c\",\"d\",\"e\"]))[3];\n+print array_sort_desc(split(\"John,Paul,George,Ringo\", \",\"));\n+print array_sort_desc(dynamic([null,\"blue\",\"yellow\",\"green\",null]));\n+print array_sort_desc(dynamic([null,\"blue\",\"yellow\",\"green\",null]), false);\n+print '-- jaccard_index()';\n+print jaccard_index(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3, 4, 4, 4]));\n+print jaccard_index(dynamic([1, 2, 3]), dynamic([]));\n+print jaccard_index(dynamic([]), dynamic([1, 2, 3, 4]));\n+print jaccard_index(dynamic([]), dynamic([]));\n+print jaccard_index(dynamic([1, 2, 3]), dynamic([4, 5, 6, 7]));\n+print jaccard_index(dynamic(['a', 's', 'd']), dynamic(['f', 'd', 's', 'a']));\n+print jaccard_index(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader']));\n+print '-- pack_array()';\n+print pack_array(); -- { clientError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+print x = 1 | extend y = x * 2 | extend z = y * 2 | extend pack_array(x,y,z);\n+print pack_array(strcat('a', 'b'), format_ipv4(42), tostring(4.2));\n+print '-- repeat()';\n+print repeat(1, 0);\n+print repeat(1, 3);\n+print repeat(\"asd\", 3);\n+print repeat(timespan(1d), 3);\n+print repeat(true, 3);\n+print repeat(1, -3);\n+print repeat(6.7,-4);\n+print '-- set_difference()';\n+print set_difference(dynamic([]), dynamic([]));\n+print set_difference(dynamic([]), dynamic([9]));\n+print set_difference(dynamic([]), dynamic([\"asd\"]));\n+print set_difference(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3]));\n+print array_sort_asc(set_difference(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[0];\n+print set_difference(dynamic([4]), dynamic([1, 2, 3]));\n+print array_sort_asc(set_difference(dynamic([1, 2, 3, 4, 5]), dynamic([5]), dynamic([2, 4])))[0];\n+print array_sort_asc(set_difference(dynamic([1, 2, 3]), dynamic([])))[0];\n+print array_sort_asc(set_difference(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])))[0];\n+print array_sort_asc(set_difference(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])))[0];\n+print '-- set_has_element()';\n+print set_has_element(dynamic([]), 9);\n+print set_has_element(dynamic([\"this\", \"is\", \"an\", \"example\"]), \"example\");\n+print set_has_element(dynamic([\"this\", \"is\", \"an\", \"example\"]), \"examplee\");\n+print set_has_element(dynamic([1, 2, 3]), 2);\n+print set_has_element(dynamic([1, 2, 3, 4.2]), 4);\n+print '-- set_intersect()';\n+print set_intersect(dynamic([]), dynamic([]));\n+print array_sort_asc(set_intersect(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])))[0];\n+print array_sort_asc(set_intersect(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[0];\n+print set_intersect(dynamic([4]), dynamic([1, 2, 3]));\n+print set_intersect(dynamic([1, 2, 3, 4, 5]), dynamic([1, 3, 5]), dynamic([2, 5]));\n+print set_intersect(dynamic([1, 2, 3]), dynamic([]));\n+print set_intersect(dynamic(['a', 's', 'd']), dynamic(['a', 'f']));\n+print set_intersect(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader']));\n+print '-- set_union()';\n+print set_union(dynamic([]), dynamic([]));\n+print array_sort_asc(set_union(dynamic([1, 1, 2, 2, 3, 3]), dynamic([1, 2, 3])))[0];\n+print array_sort_asc(set_union(dynamic([1, 4, 2, 3, 5, 4, 6]), dynamic([1, 2, 3])))[0];\n+print array_sort_asc(set_union(dynamic([4]), dynamic([1, 2, 3])))[0];\n+print array_sort_asc(set_union(dynamic([1, 3, 4]), dynamic([5]), dynamic([2, 4])))[0];\n+print array_sort_asc(set_union(dynamic([1, 2, 3]), dynamic([])))[0];\n+print array_sort_asc(set_union(dynamic(['a', 's', 'd']), dynamic(['a', 'f'])))[0];\n+print array_sort_asc(set_union(dynamic(['Chewbacca', 'Darth Vader', 'Han Solo']), dynamic(['Darth Sidious', 'Darth Vader'])))[0];\n+print '-- zip()';\n+print zip(dynamic([]), dynamic([]));\n+print zip(dynamic([1,3,5]), dynamic([2,4,6]));\n+print zip(dynamic(['Darth','Master']), dynamic(['Vader','Yoda']), dynamic(['has a suit','doesn\\'t have a suit']));\n+print zip(dynamic([1,2,3]), dynamic([10,20]));\n+print zip(dynamic([]), dynamic([1,2,3]));\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02366_kql_func_ip.reference b/tests/queries/0_stateless/02366_kql_func_ip.reference\nnew file mode 100644\nindex 000000000000..2a0bbf53fff4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_ip.reference\n@@ -0,0 +1,123 @@\n+-- ipv4_is_private(\\'127.0.0.1\\')\n+0\n+-- ipv4_is_private(\\'10.1.2.3\\')\n+1\n+-- ipv4_is_private(\\'192.168.1.1/24\\')\n+1\n+ipv4_is_private(strcat(\\'192.\\',\\'168.\\',\\'1.\\',\\'1\\',\\'/24\\'))\n+1\n+-- ipv4_is_private(\\'abc\\')\n+\\N\n+-- ipv4_netmask_suffix(\\'192.168.1.1/24\\')\n+24\n+-- ipv4_netmask_suffix(\\'192.168.1.1\\')\n+32\n+-- ipv4_netmask_suffix(\\'127.0.0.1/16\\')\n+16\n+-- ipv4_netmask_suffix(\\'abc\\')\n+\\N\n+ipv4_netmask_suffix(strcat(\\'127.\\', \\'0.\\', \\'0.1/16\\'))\n+16\n+-- ipv4_is_in_range(\\'127.0.0.1\\', \\'127.0.0.1\\')\n+1\n+-- ipv4_is_in_range(\\'192.168.1.6\\', \\'192.168.1.1/24\\')\n+1\n+-- ipv4_is_in_range(\\'192.168.1.1\\', \\'192.168.2.1/24\\')\n+0\n+-- ipv4_is_in_range(strcat(\\'192.\\',\\'168.\\', \\'1.1\\'), \\'192.168.2.1/24\\')\n+0\n+-- ipv4_is_in_range(\\'abc\\', \\'127.0.0.1\\')\n+\\N\n+-- parse_ipv6(127.0.0.1)\n+0000:0000:0000:0000:0000:ffff:7f00:0001\n+-- parse_ipv6(fe80::85d:e82c:9446:7994)\n+fe80:0000:0000:0000:085d:e82c:9446:7994\n+-- parse_ipv4(\\'127.0.0.1\\')\n+2130706433\n+-- parse_ipv4(\\'192.1.168.1\\') < parse_ipv4(\\'192.1.168.2\\')\n+1\n+-- parse_ipv4(arrayStringConcat([\\'127\\', \\'0\\', \\'0\\', \\'1\\'], \\'.\\'))\n+-- parse_ipv4_mask(\\'127.0.0.1\\', 24) == 2130706432\n+2130706432\n+-- parse_ipv4_mask(\\'abc\\', 31)\n+\\N\n+\\N\n+-- parse_ipv4_mask(\\'192.1.168.2\\', 31) == parse_ipv4_mask(\\'192.1.168.3\\', 31)\n+3221334018\n+3221334018\n+-- ipv4_is_match(\\'127.0.0.1\\', \\'127.0.0.1\\')\n+1\n+-- ipv4_is_match(\\'192.168.1.1\\', \\'192.168.1.255\\')\n+0\n+-- ipv4_is_match(\\'192.168.1.1/24\\', \\'192.168.1.255/24\\')\n+1\n+-- ipv4_is_match(\\'192.168.1.1\\', \\'192.168.1.255\\', 24)\n+1\n+-- ipv4_is_match(\\'abc\\', \\'def\\', 24)\n+\\N\n+-- ipv4_compare()\n+0\n+-1\n+1\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+-- format_ipv4()\n+192.168.1.0\n+192.168.1.1\n+192.168.1.0\n+192.168.1.0\n+1\n+1\n+127.0.0.0\n+-- format_ipv4_mask()\n+192.168.1.0/24\n+192.168.1.0/24\n+192.168.1.0/24\n+192.168.1.1/32\n+192.168.1.0/24\n+1\n+1\n+127.0.0.0/24\n+-- parse_ipv6_mask()\n+0000:0000:0000:0000:0000:0000:0000:0000\n+fe80:0000:0000:0000:085d:e82c:9446:7900\n+0000:0000:0000:0000:0000:ffff:c0a8:ff00\n+0000:0000:0000:0000:0000:ffff:c0a8:ff00\n+0000:0000:0000:0000:0000:ffff:ffff:ffff\n+fe80:0000:0000:0000:085d:e82c:9446:7994\n+fe80:0000:0000:0000:085d:e82c:9446:7900\n+0000:0000:0000:0000:0000:ffff:c0a8:ffff\n+0000:0000:0000:0000:0000:ffff:c0a8:ff00\n+-- ipv6_is_match()\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02366_kql_func_ip.sql b/tests/queries/0_stateless/02366_kql_func_ip.sql\nnew file mode 100644\nindex 000000000000..c9b335f203a2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_ip.sql\n@@ -0,0 +1,131 @@\n+set dialect='kusto';\n+print '-- ipv4_is_private(\\'127.0.0.1\\')';\n+print ipv4_is_private('127.0.0.1');\n+print '-- ipv4_is_private(\\'10.1.2.3\\')';\n+print ipv4_is_private('10.1.2.3');\n+print '-- ipv4_is_private(\\'192.168.1.1/24\\')';\n+print ipv4_is_private('192.168.1.1/24');\n+print 'ipv4_is_private(strcat(\\'192.\\',\\'168.\\',\\'1.\\',\\'1\\',\\'/24\\'))';\n+print ipv4_is_private(strcat('192.','168.','1.','1','/24'));\n+print '-- ipv4_is_private(\\'abc\\')';\n+print ipv4_is_private('abc'); -- == null\n+\n+print '-- ipv4_netmask_suffix(\\'192.168.1.1/24\\')';\n+print ipv4_netmask_suffix('192.168.1.1/24'); -- == 24\n+print '-- ipv4_netmask_suffix(\\'192.168.1.1\\')';\n+print ipv4_netmask_suffix('192.168.1.1'); -- == 32\n+print '-- ipv4_netmask_suffix(\\'127.0.0.1/16\\')';\n+print ipv4_netmask_suffix('127.0.0.1/16'); -- == 16\n+print '-- ipv4_netmask_suffix(\\'abc\\')';\n+print ipv4_netmask_suffix('abc'); -- == null\n+print 'ipv4_netmask_suffix(strcat(\\'127.\\', \\'0.\\', \\'0.1/16\\'))';\n+print ipv4_netmask_suffix(strcat('127.', '0.', '0.1/16')); -- == 16\n+\n+print '-- ipv4_is_in_range(\\'127.0.0.1\\', \\'127.0.0.1\\')';\n+print ipv4_is_in_range('127.0.0.1', '127.0.0.1'); -- == true\n+print '-- ipv4_is_in_range(\\'192.168.1.6\\', \\'192.168.1.1/24\\')';\n+print ipv4_is_in_range('192.168.1.6', '192.168.1.1/24'); -- == true\n+print '-- ipv4_is_in_range(\\'192.168.1.1\\', \\'192.168.2.1/24\\')';\n+print ipv4_is_in_range('192.168.1.1', '192.168.2.1/24'); -- == false\n+print '-- ipv4_is_in_range(strcat(\\'192.\\',\\'168.\\', \\'1.1\\'), \\'192.168.2.1/24\\')';\n+print ipv4_is_in_range(strcat('192.','168.', '1.1'), '192.168.2.1/24'); -- == false\n+print '-- ipv4_is_in_range(\\'abc\\', \\'127.0.0.1\\')'; -- == null\n+print ipv4_is_in_range('abc', '127.0.0.1');\n+\n+print '-- parse_ipv6(127.0.0.1)';\n+print parse_ipv6('127.0.0.1');\n+print '-- parse_ipv6(fe80::85d:e82c:9446:7994)';\n+print parse_ipv6('fe80::85d:e82c:9446:7994');\n+print '-- parse_ipv4(\\'127.0.0.1\\')';\n+print parse_ipv4('127.0.0.1');\n+print '-- parse_ipv4(\\'192.1.168.1\\') < parse_ipv4(\\'192.1.168.2\\')';\n+print parse_ipv4('192.1.168.1') < parse_ipv4('192.1.168.2');\n+print '-- parse_ipv4(arrayStringConcat([\\'127\\', \\'0\\', \\'0\\', \\'1\\'], \\'.\\'))';\n+print parse_ipv4(arrayStringConcat(['127', '0', '0', '1'], '.')); -- { clientError UNKNOWN_FUNCTION }\n+\n+print '-- parse_ipv4_mask(\\'127.0.0.1\\', 24) == 2130706432';\n+print parse_ipv4_mask('127.0.0.1', 24);\n+print '-- parse_ipv4_mask(\\'abc\\', 31)';\n+print parse_ipv4_mask('abc', 31)\n+print '-- parse_ipv4_mask(\\'192.1.168.2\\', 1000)';\n+print parse_ipv4_mask('192.1.168.2', 1000);\n+print '-- parse_ipv4_mask(\\'192.1.168.2\\', 31) == parse_ipv4_mask(\\'192.1.168.3\\', 31)';\n+--print parse_ipv4_mask('192.1.168.2', 31) == parse_ipv4_mask('192.1.168.3', 31); // this qual failed in analyzer 3221334018\n+print parse_ipv4_mask('192.1.168.2', 31);\n+print parse_ipv4_mask('192.1.168.3', 31);\n+print '-- ipv4_is_match(\\'127.0.0.1\\', \\'127.0.0.1\\')';\n+print ipv4_is_match('127.0.0.1', '127.0.0.1');\n+print '-- ipv4_is_match(\\'192.168.1.1\\', \\'192.168.1.255\\')';\n+print ipv4_is_match('192.168.1.1', '192.168.1.255');\n+print '-- ipv4_is_match(\\'192.168.1.1/24\\', \\'192.168.1.255/24\\')';\n+print ipv4_is_match('192.168.1.1/24', '192.168.1.255/24');\n+print '-- ipv4_is_match(\\'192.168.1.1\\', \\'192.168.1.255\\', 24)';\n+print ipv4_is_match('192.168.1.1', '192.168.1.255', 24);\n+print '-- ipv4_is_match(\\'abc\\', \\'def\\', 24)';\n+print ipv4_is_match('abc', 'dev', 24);\n+print '-- ipv4_compare()';\n+print ipv4_compare('127.0.0.1', '127.0.0.1');\n+print ipv4_compare('192.168.1.1', '192.168.1.255');\n+print ipv4_compare('192.168.1.255', '192.168.1.1');\n+print ipv4_compare('192.168.1.1/24', '192.168.1.255/24');\n+print ipv4_compare('192.168.1.1', '192.168.1.255', 24);\n+print ipv4_compare('192.168.1.1/24', '192.168.1.255');\n+print ipv4_compare('192.168.1.1', '192.168.1.255/24');\n+print ipv4_compare('192.168.1.1/30', '192.168.1.255/24');\n+print ipv4_compare('192.168.1.1', '192.168.1.0', 31);\n+print ipv4_compare('192.168.1.1/24', '192.168.1.255', 31);\n+print ipv4_compare('192.168.1.1', '192.168.1.255', 24);\n+print '-- format_ipv4()';\n+print format_ipv4('192.168.1.255', 24);\n+print format_ipv4('192.168.1.1', 32);\n+print format_ipv4('192.168.1.1/24', 32);\n+print format_ipv4(3232236031, 24);\n+print format_ipv4('192.168.1.1/24', -1) == '';\n+print format_ipv4('abc', 24) == '';\n+print format_ipv4(strcat('127.0', '.0.', '1', '/32'), 12 + 12);\n+print '-- format_ipv4_mask()';\n+print format_ipv4_mask('192.168.1.255', 24);\n+print format_ipv4_mask(3232236031, 24);\n+print format_ipv4_mask('192.168.1.1', 24);\n+print format_ipv4_mask('192.168.1.1', 32);\n+print format_ipv4_mask('192.168.1.1/24', 32);\n+print format_ipv4_mask('192.168.1.1/24', -1) == '';\n+print format_ipv4_mask('abc', 24) == '';\n+print format_ipv4_mask(strcat('127.0', '.0.', '1', '/32'), 12 + 12);\n+print '-- parse_ipv6_mask()';\n+print parse_ipv6_mask(\"127.0.0.1\", 24);\n+print parse_ipv6_mask(\"fe80::85d:e82c:9446:7994\", 120);\n+print parse_ipv6_mask(\"192.168.255.255\", 120);\n+print parse_ipv6_mask(\"192.168.255.255/24\", 124);\n+print parse_ipv6_mask(\"255.255.255.255\", 128);\n+print parse_ipv6_mask(\"fe80::85d:e82c:9446:7994\", 128);\n+print parse_ipv6_mask(\"fe80::85d:e82c:9446:7994/120\", 124);\n+print parse_ipv6_mask(\"::192.168.255.255\", 128);\n+print parse_ipv6_mask(\"::192.168.255.255/24\", 128);\n+print '-- ipv6_is_match()';\n+print ipv6_is_match('::ffff:7f00:1', '127.0.0.1') == true;\n+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995') == false;\n+print ipv6_is_match('192.168.1.1/24', '192.168.1.255/24') == true;\n+print ipv6_is_match('fe80::85d:e82c:9446:7994/127', 'fe80::85d:e82c:9446:7995/127') == true;\n+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995', 127) == true;\n+print ipv6_is_match('192.168.1.1',    '192.168.1.1'); --       // Equal IPs\n+print ipv6_is_match('192.168.1.1/24', '192.168.1.255'); --     // 24 bit IP4-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1',    '192.168.1.255/24'); --  // 24 bit IP4-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1/30', '192.168.1.255/24'); --  // 24 bit IP4-prefix is used for comparison\n+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7994'); --         // Equal IPs\n+print ipv6_is_match('fe80::85d:e82c:9446:7994/120', 'fe80::85d:e82c:9446:7998'); --     // 120 bit IP6-prefix is used for comparison\n+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7998/120'); --     // 120 bit IP6-prefix is used for comparison\n+print ipv6_is_match('fe80::85d:e82c:9446:7994/120', 'fe80::85d:e82c:9446:7998/120'); -- // 120 bit IP6-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1',      '::ffff:c0a8:0101'); -- // Equal IPs\n+print ipv6_is_match('192.168.1.1/24',   '::ffff:c0a8:01ff'); -- // 24 bit IP-prefix is used for comparison\n+print ipv6_is_match('::ffff:c0a8:0101', '192.168.1.255/24'); -- // 24 bit IP-prefix is used for comparison\n+print ipv6_is_match('::192.168.1.1/30', '192.168.1.255/24'); -- // 24 bit IP-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1',    '192.168.1.0',   31); -- // 31 bit IP4-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1/24', '192.168.1.255', 31); -- // 24 bit IP4-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1',    '192.168.1.255', 24); -- // 24 bit IP4-prefix is used for comparison\n+print ipv6_is_match('fe80::85d:e82c:9446:7994', 'fe80::85d:e82c:9446:7995',     127); -- // 127 bit IP6-prefix is used for comparison\n+print ipv6_is_match('fe80::85d:e82c:9446:7994/127', 'fe80::85d:e82c:9446:7998', 120); -- // 120 bit IP6-prefix is used for comparison\n+print ipv6_is_match('fe80::85d:e82c:9446:7994/120', 'fe80::85d:e82c:9446:7998', 127); -- // 120 bit IP6-prefix is used for comparison\n+print ipv6_is_match('192.168.1.1/24',   '::ffff:c0a8:01ff', 127); -- // 127 bit IP6-prefix is used for comparison\n+print ipv6_is_match('::ffff:c0a8:0101', '192.168.1.255',    120); -- // 120 bit IP6-prefix is used for comparison\n+print ipv6_is_match('::192.168.1.1/30', '192.168.1.255/24', 127); -- // 120 bit IP6-prefix is used for comparison\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02366_kql_func_math.reference b/tests/queries/0_stateless/02366_kql_func_math.reference\nnew file mode 100644\nindex 000000000000..92f283abcb6e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_math.reference\n@@ -0,0 +1,4 @@\n+-- isnan --\n+1\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02366_kql_func_math.sql b/tests/queries/0_stateless/02366_kql_func_math.sql\nnew file mode 100644\nindex 000000000000..4e83622eb6b8\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_math.sql\n@@ -0,0 +1,7 @@\n+set dialect = 'kusto';\n+print '-- isnan --';\n+print isnan(double(nan));\n+print isnan(4.2);\n+print isnan(4); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }\n+print isnan(real(+inf));\n+print isnan(dynamic(null)); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }\ndiff --git a/tests/queries/0_stateless/02366_kql_func_scalar.reference b/tests/queries/0_stateless/02366_kql_func_scalar.reference\nnew file mode 100644\nindex 000000000000..b7fa62c5d437\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_scalar.reference\n@@ -0,0 +1,16 @@\n+-- bin_at()\n+4.5\n+-12:0:0\n+2017-05-14 12:00:00.000000000\n+2017-05-14 00:00:00.000000000\n+2018-02-25 15:14:00.000000000\t5\n+2018-02-24 15:14:00.000000000\t3\n+2018-02-23 15:14:00.000000000\t4\n+-- bin()\n+4\n+1970-05-11 00:00:00.000000000\n+336:0:0\n+1970-05-11 13:45:07.345000000\n+1970-05-11 13:45:07.345623000\n+2022-09-26 10:13:23.987232000\n+1970-05-11 13:45:07.456336000\ndiff --git a/tests/queries/0_stateless/02366_kql_func_scalar.sql b/tests/queries/0_stateless/02366_kql_func_scalar.sql\nnew file mode 100644\nindex 000000000000..d7e94cfd9d15\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_scalar.sql\n@@ -0,0 +1,26 @@\n+DROP TABLE IF EXISTS Bin_at_test;\n+CREATE TABLE Bin_at_test\n+(    \n+    `Date` DateTime('UTC'),\n+    Num Nullable(UInt8)\n+) ENGINE = Memory;\n+INSERT INTO Bin_at_test VALUES ('2018-02-24T15:14:01',3), ('2018-02-23T16:14:01',4), ('2018-02-26T15:14:01',5);\n+\n+set dialect = 'kusto';\n+print '-- bin_at()';\n+print bin_at(6.5, 2.5, 7);\n+print bin_at(1h, 1d, 12h);\n+print bin_at(datetime(2017-05-15 10:20:00.0), 1d, datetime(1970-01-01 12:00:00.0));\n+print bin_at(datetime(2017-05-17 10:20:00.0), 7d, datetime(2017-06-04 00:00:00.0));\n+Bin_at_test | summarize sum(Num) by d = todatetime(bin_at(Date, 1d, datetime('2018-02-24 15:14:00'))) | order by d;\n+print '-- bin()';\n+print bin(4.5, 1);\n+print bin(datetime(1970-05-11 13:45:07), 1d);\n+print bin(16d, 7d);\n+print bin(datetime(1970-05-11 13:45:07.345623), 1ms);\n+-- print bin(datetime(2022-09-26 10:13:23.987234), 6ms); -> 2022-09-26 10:13:23.982000000\n+print bin(datetime(1970-05-11 13:45:07.345623), 1microsecond);\n+print bin(datetime(2022-09-26 10:13:23.987234), 6microseconds);\n+print bin(datetime(1970-05-11 13:45:07.456345672), 16microseconds);\n+-- print bin(datetime(2022-09-26 10:13:23.987234128), 1tick); -> 2022-09-26 10:13:23.987234100\n+-- print bin(datetime(2022-09-26 10:13:23.987234128), 99nanosecond); -> null\ndiff --git a/tests/queries/0_stateless/02366_kql_func_string.reference b/tests/queries/0_stateless/02366_kql_func_string.reference\nnew file mode 100644\nindex 000000000000..9bdd38ca5dba\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_string.reference\n@@ -0,0 +1,360 @@\n+-- test String Functions --\n+-- Customers |where Education contains \\'degree\\'\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+\n+-- Customers |where Education !contains \\'degree\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers |where Education contains \\'Degree\\'\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+\n+-- Customers |where Education !contains \\'Degree\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where FirstName endswith \\'RE\\'\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where ! FirstName endswith \\'RE\\'\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+--Customers | where FirstName endswith_cs \\'re\\'\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where FirstName !endswith_cs \\'re\\'\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation == \\'Skilled Manual\\'\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation != \\'Skilled Manual\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers | where Occupation has \\'skilled\\'\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation !has \\'skilled\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers | where Occupation has \\'Skilled\\'\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation !has \\'Skilled\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers | where Occupation hasprefix_cs \\'Ab\\'\n+\n+-- Customers | where Occupation !hasprefix_cs \\'Ab\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation hasprefix_cs \\'ab\\'\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers | where Occupation !hasprefix_cs \\'ab\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation hassuffix \\'Ent\\'\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers | where Occupation !hassuffix \\'Ent\\'\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Occupation hassuffix \\'ent\\'\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers | where Occupation hassuffix \\'ent\\'\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+\n+-- Customers |where Education in (\\'Bachelors\\',\\'High School\\')\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where Education !in (\\'Bachelors\\',\\'High School\\')\n+\\N\twhy\tProfessional\tPartial College\t38\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+\n+-- Customers | where FirstName matches regex \\'P.*r\\'\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+\n+-- Customers | where FirstName startswith \\'pet\\'\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+\n+-- Customers | where FirstName !startswith \\'pet\\'\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where FirstName startswith_cs \\'pet\\'\n+\n+-- Customers | where FirstName !startswith_cs \\'pet\\'\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where isempty(LastName)\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where isnotempty(LastName)\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+\\N\twhy\tProfessional\tPartial College\t38\n+\n+-- Customers | where isnotnull(FirstName)\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- Customers | where isnull(FirstName)\n+\\N\twhy\tProfessional\tPartial College\t38\n+\n+-- Customers | project url_decode(\\'https%3A%2F%2Fwww.test.com%2Fhello%20word\\') | take 1\n+https://www.test.com/hello word\n+\n+-- Customers | project url_encode(\\'https://www.test.com/hello word\\') | take 1\n+https%3A%2F%2Fwww.test.com%2Fhello%20word\n+\n+-- Customers | project name_abbr = strcat(substring(FirstName,0,3), \\' \\', substring(LastName,2))\n+\\N\n+Lat en\n+Pet ra\n+The az\n+Ste x\n+App \n+\n+-- Customers | project name = strcat(FirstName, \\' \\', LastName)\n+\\N\n+Latoya Shen\n+Peter Nara\n+Theodore Diaz\n+Stephanie Cox\n+Apple \n+\n+-- Customers | project FirstName, strlen(FirstName)\n+\\N\t\\N\n+Latoya\t6\n+Peter\t5\n+Theodore\t8\n+Stephanie\t9\n+Apple\t5\n+\n+-- Customers | project strrep(FirstName,2,\\'_\\')\n+\\N\n+Latoya_Latoya\n+Peter_Peter\n+Theodore_Theodore\n+Stephanie_Stephanie\n+Apple_Apple\n+\n+-- Customers | project toupper(FirstName)\n+\\N\n+LATOYA\n+PETER\n+THEODORE\n+STEPHANIE\n+APPLE\n+\n+-- Customers | project tolower(FirstName)\n+\\N\n+latoya\n+peter\n+theodore\n+stephanie\n+apple\n+\n+-- support subquery for in orerator (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/in-cs-operator) (subquery need to be wraped with bracket inside bracket); TODO: case-insensitive not supported yet\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- has_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-all-operator); TODO: subquery not supported yet\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- has_any (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-anyoperator); TODO: subquery not supported yet\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Apple\t\tSkilled Manual\tBachelors\t28\n+\n+-- countof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/countoffunction)\n+3\n+3\n+1\n+\n+-- extract ( https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractfunction)\n+PINEAPPLE ice cream is 20\n+PINEAPPLE\n+20\n+\n+20\n+\\N\n+\\N\n+\\N\n+\\N\n+\\N\n+45.6\n+45.6\n+\n+-- extract_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractallfunction); TODO: captureGroups not supported yet\n+[['T','h','e'],['p','ric','e'],['P','INEAPPL','E'],['i','c','e'],['c','rea','m']]\n+\n+-- extract_json (https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/extractjsonfunction)\n+\n+\n+John\n+iPhone\n+\\N\n+26\n+26\n+26\n+26\n+\\N\n+\n+-- split (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/splitfunction)\n+['aa','bb']\n+['bbb']\n+['']\n+['a','','b']\n+['aa','cc']\n+['aabbcc']\n+['aaa','bbb','ccc']\n+[NULL]\n+\n+-- strcat_delim (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/strcat-delimfunction); TODO: only support string now.\n+1-2-Ab\n+\n+-- indexof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/indexoffunction); TODO: length and occurrence not supported yet\n+2\n+2\n+-1\n+-- base64_encode_fromguid()\n+8jMxriJurkmwahbmqbIS6w==\n+-- base64_decode_toarray()\n+[]\n+[75,117,115,116,111]\n+-- base64_decode_toguid()\n+10e99626-bc2b-4c75-bb3e-fe606de25700\n+1\n+-- base64_encode_tostring\n+\n+S3VzdG8x\n+-- base64_decode_tostring\n+\n+Kusto1\n+-- parse_url()\n+{\"Scheme\":\"scheme\",\"Host\":\"\",\"Port\":\"0\",\"Path\":\"/this/is/a/path\",\"Username\":\"username\",\"Password\":\"password\",\"Query Parameters\":{\"k1\":\"v1\",\"k2\":\"v2\"},\"Fragment\":\"fragment\"}\n+-- parse_urlquery()\n+{\"Query Parameters\":{\"k1\":\"v1\",\"k2\":\"v2\",\"k3\":\"v3\"}}\n+-- strcmp()\n+0\t1\t-1\t1\n+-- substring()\n+CD\n+-- translate()\n+kusto\t\txxx\n+-- trim()\n+https://www.ibm.com\n+Te st1\n+ asd \n+asd\n+sd\n+-- trim_start()\n+www.ibm.com\n+Te st1// $\n+asdw\n+\n+asd\n+-- trim_end()\n+https\n+- Te st1\n+wasd\n+\n+asd\n+-- trim, trim_start, trim_end all at once\n+--https://bing.com--\t--\thttps://bing.com--\t--https://bing.com\thttps://bing.com\n+-- replace_regex\n+Number was: 1\n+-- has_any_index()\n+0\t1\t-1\t-1\n+-- parse_version()\n+1000000020000000300000040\n+1000000020000000000000000\n+1000000020000000000000000\n+\\N\n+\\N\n+\\N\n+\\N\n+1000000020000000300000004\n+1000000020000000000000000\n+1000000020000000300000000\n+1000000000000000000000000\n+-- parse_json()\n+[1,2,3]\n+[{\"a\":123.5,\"b\":\"{\\\\\"c\\\\\":456}\"}]\n+-- parse_command_line()\n+[NULL]\n+[NULL]\n+-- reverse()\n+321\n+43.321\n+\n+dsa\n+][\n+]3,2,1[\n+]\\'redaV\\',\\'htraD\\'[\n+000000000.00:00:21 51-01-7102\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+-- parse_csv()\n+['']\n+['aaa']\n+['aa','b','cc']\n+['record1','a','b','c']\ndiff --git a/tests/queries/0_stateless/02366_kql_func_string.sql b/tests/queries/0_stateless/02366_kql_func_string.sql\nnew file mode 100644\nindex 000000000000..d251b04e08bf\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_func_string.sql\n@@ -0,0 +1,313 @@\n+-- Tags: no-fasttest\n+\n+DROP TABLE IF EXISTS Customers;\n+CREATE TABLE Customers\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Occupation String,\n+    Education String,\n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+\n+INSERT INTO Customers VALUES ('Theodore','Diaz','Skilled Manual','Bachelors',28), ('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);\n+\n+-- datatable (Version:string) [\n+--     '1.2.3.4',\n+--     '1.2',\n+--     '1.2.3',\n+--     '1'\n+-- ]\n+\n+DROP TABLE IF EXISTS Versions;\n+CREATE TABLE Versions\n+(    \n+    Version String\n+) ENGINE = Memory;\n+INSERT INTO Versions VALUES ('1.2.3.4'),('1.2'),('1.2.3'),('1');\n+\n+\n+set dialect='kusto';\n+print '-- test String Functions --';\n+\n+print '-- Customers |where Education contains \\'degree\\'';\n+Customers |where Education contains 'degree' | order by LastName;\n+print '';\n+print '-- Customers |where Education !contains \\'degree\\'';\n+Customers |where Education !contains 'degree' | order by LastName;\n+print '';\n+print '-- Customers |where Education contains \\'Degree\\'';\n+Customers |where Education contains 'Degree' | order by LastName;\n+print '';\n+print '-- Customers |where Education !contains \\'Degree\\'';\n+Customers |where Education !contains 'Degree' | order by LastName;\n+print '';\n+print '-- Customers | where FirstName endswith \\'RE\\'';\n+Customers | where FirstName endswith 'RE' | order by LastName;\n+print '';\n+print '-- Customers | where ! FirstName endswith \\'RE\\'';\n+Customers | where FirstName ! endswith 'RE' | order by LastName;\n+print '';\n+print '--Customers | where FirstName endswith_cs \\'re\\'';\n+Customers | where FirstName endswith_cs 're' | order by LastName;\n+print '';\n+print '-- Customers | where FirstName !endswith_cs \\'re\\'';\n+Customers | where FirstName !endswith_cs 're' | order by LastName;\n+print '';\n+print '-- Customers | where Occupation == \\'Skilled Manual\\'';\n+Customers | where Occupation == 'Skilled Manual' | order by LastName;\n+print '';\n+print '-- Customers | where Occupation != \\'Skilled Manual\\'';\n+Customers | where Occupation != 'Skilled Manual' | order by LastName;\n+print '';\n+print '-- Customers | where Occupation has \\'skilled\\'';\n+Customers | where Occupation has 'skilled' | order by LastName;\n+print '';\n+print '-- Customers | where Occupation !has \\'skilled\\'';\n+Customers | where Occupation !has 'skilled' | order by LastName;\n+print '';\n+print '-- Customers | where Occupation has \\'Skilled\\'';\n+Customers | where Occupation has 'Skilled'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation !has \\'Skilled\\'';\n+Customers | where Occupation !has 'Skilled'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation hasprefix_cs \\'Ab\\'';\n+Customers | where Occupation hasprefix_cs 'Ab'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation !hasprefix_cs \\'Ab\\'';\n+Customers | where Occupation !hasprefix_cs 'Ab'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation hasprefix_cs \\'ab\\'';\n+Customers | where Occupation hasprefix_cs 'ab'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation !hasprefix_cs \\'ab\\'';\n+Customers | where Occupation !hasprefix_cs 'ab'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation hassuffix \\'Ent\\'';\n+Customers | where Occupation hassuffix 'Ent'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation !hassuffix \\'Ent\\'';\n+Customers | where Occupation !hassuffix 'Ent'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation hassuffix \\'ent\\'';\n+Customers | where Occupation hassuffix 'ent'| order by LastName;\n+print '';\n+print '-- Customers | where Occupation hassuffix \\'ent\\'';\n+Customers | where Occupation hassuffix 'ent'| order by LastName;\n+print '';\n+print '-- Customers |where Education in (\\'Bachelors\\',\\'High School\\')';\n+Customers |where Education in ('Bachelors','High School')| order by LastName;\n+print '';\n+print '-- Customers | where Education !in (\\'Bachelors\\',\\'High School\\')';\n+Customers | where Education !in ('Bachelors','High School')| order by LastName;\n+print '';\n+print '-- Customers | where FirstName matches regex \\'P.*r\\'';\n+Customers | where FirstName matches regex 'P.*r'| order by LastName;\n+print '';\n+print '-- Customers | where FirstName startswith \\'pet\\'';\n+Customers | where FirstName startswith 'pet'| order by LastName;\n+print '';\n+print '-- Customers | where FirstName !startswith \\'pet\\'';\n+Customers | where FirstName !startswith 'pet'| order by LastName;\n+print '';\n+print '-- Customers | where FirstName startswith_cs \\'pet\\'';\n+Customers | where FirstName startswith_cs 'pet'| order by LastName;\n+print '';\n+print '-- Customers | where FirstName !startswith_cs \\'pet\\'';\n+Customers | where FirstName !startswith_cs 'pet'| order by LastName;\n+print '';\n+print '-- Customers | where isempty(LastName)';\n+Customers | where isempty(LastName);\n+print '';\n+print '-- Customers | where isnotempty(LastName)';\n+Customers | where isnotempty(LastName);\n+print '';\n+print '-- Customers | where isnotnull(FirstName)';\n+Customers | where isnotnull(FirstName)| order by LastName;\n+print '';\n+print '-- Customers | where isnull(FirstName)';\n+Customers | where isnull(FirstName)| order by LastName;\n+print '';\n+print '-- Customers | project url_decode(\\'https%3A%2F%2Fwww.test.com%2Fhello%20word\\') | take 1';\n+Customers | project url_decode('https%3A%2F%2Fwww.test.com%2Fhello%20word') | take 1;\n+print '';\n+print '-- Customers | project url_encode(\\'https://www.test.com/hello word\\') | take 1';\n+Customers | project url_encode('https://www.test.com/hello word') | take 1;\n+print '';\n+print '-- Customers | project name_abbr = strcat(substring(FirstName,0,3), \\' \\', substring(LastName,2))';\n+Customers | project name_abbr = strcat(substring(FirstName,0,3), ' ', substring(LastName,2))| order by LastName;\n+print '';\n+print '-- Customers | project name = strcat(FirstName, \\' \\', LastName)';\n+Customers | project name = strcat(FirstName, ' ', LastName)| order by LastName;\n+print '';\n+print '-- Customers | project FirstName, strlen(FirstName)';\n+Customers | project FirstName, strlen(FirstName)| order by LastName;\n+print '';\n+print '-- Customers | project strrep(FirstName,2,\\'_\\')';\n+Customers | project strrep(FirstName,2,'_')| order by LastName;\n+print '';\n+print '-- Customers | project toupper(FirstName)';\n+Customers | project toupper(FirstName)| order by LastName;\n+print '';\n+print '-- Customers | project tolower(FirstName)';\n+Customers | project tolower(FirstName)| order by LastName;\n+print '';\n+print '-- support subquery for in orerator (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/in-cs-operator) (subquery need to be wraped with bracket inside bracket); TODO: case-insensitive not supported yet';\n+Customers | where Age in ((Customers|project Age|where Age < 30)) | order by LastName;\n+-- Customer | where LastName in~ (\"diaz\", \"cox\")\n+print '';\n+print '-- has_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-all-operator); TODO: subquery not supported yet';\n+Customers | where Occupation has_all ('manual', 'skilled') | order by LastName;\n+print '';\n+print '-- has_any (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/has-anyoperator); TODO: subquery not supported yet';\n+Customers|where Occupation has_any ('Skilled','abcd');\n+print '';\n+print '-- countof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/countoffunction)';\n+Customers | project countof('The cat sat on the mat', 'at') | take 1;\n+Customers | project countof('The cat sat on the mat', 'at', 'normal') | take 1;\n+Customers | project countof('The cat sat on the mat', '\\\\s.he', 'regex') | take 1;\n+print '';\n+print '-- extract ( https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractfunction)';\n+print extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 0, 'The price of PINEAPPLE ice cream is 20');\n+print extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 1, 'The price of PINEAPPLE ice cream is 20');\n+print extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 2, 'The price of PINEAPPLE ice cream is 20');\n+print extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 3, 'The price of PINEAPPLE ice cream is 20');\n+print extract('(\\\\b[A-Z]+\\\\b).+(\\\\b\\\\d+)', 2, 'The price of PINEAPPLE ice cream is 20', typeof(real));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(bool));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(date));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(guid));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(int));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(long));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(real));\n+print extract(\"x=([0-9.]+)\", 1, \"hello x=45.6|wo\" , typeof(decimal));\n+print '';\n+print '-- extract_all (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/extractallfunction); TODO: captureGroups not supported yet';\n+Customers | project extract_all('(\\\\w)(\\\\w+)(\\\\w)','The price of PINEAPPLE ice cream is 20') | take 1;\n+print '';\n+print '-- extract_json (https://learn.microsoft.com/en-us/azure/data-explorer/kusto/query/extractjsonfunction)';\n+print extract_json('', ''); -- { serverError BAD_ARGUMENTS }\n+print extract_json('a', ''); -- { serverError BAD_ARGUMENTS }\n+print extract_json('$.firstName', '');\n+print extract_json('$.phoneNumbers[0].type', '');\n+print extractjson('$.firstName', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}');\n+print extract_json('$.phoneNumbers[0].type', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(string));\n+print extract_json('$.phoneNumbers[0].type', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(int));\n+print extract_json('$.age', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}');\n+print extract_json('$.age', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(int));\n+print extract_json('$.age', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(long));\n+-- print extract_json('$.age', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(bool)); -> true\n+print extract_json('$.age', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(double));\n+print extract_json('$.age', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(guid));\n+-- print extract_json('$.phoneNumbers', '{\"firstName\":\"John\",\"lastName\":\"doe\",\"age\":26,\"address\":{\"streetAddress\":\"naist street\",\"city\":\"Nara\",\"postalCode\":\"630-0192\"},\"phoneNumbers\":[{\"type\":\"iPhone\",\"number\":\"0123-4567-8888\"},{\"type\":\"home\",\"number\":\"0123-4567-8910\"}]}', typeof(dynamic)); we won't be able to handle this particular case for a while, because it should return a dictionary\n+print '';\n+print '-- split (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/splitfunction)';\n+Customers | project split('aa_bb', '_') | take 1;\n+Customers | project split('aaa_bbb_ccc', '_', 1) | take 1;\n+Customers | project split('', '_') | take 1;\n+Customers | project split('a__b', '_') | take 1;\n+Customers | project split('aabbcc', 'bb') | take 1;\n+Customers | project split('aabbcc', '') | take 1;\n+Customers | project split('aaa_bbb_ccc', '_', -1) | take 1;\n+Customers | project split('aaa_bbb_ccc', '_', 10) | take 1;\n+print '';\n+print '-- strcat_delim (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/strcat-delimfunction); TODO: only support string now.';\n+Customers | project strcat_delim('-', '1', '2', strcat('A','b')) | take 1;\n+-- Customers | project strcat_delim('-', '1', '2', 'A' , 1s);\n+print '';\n+print '-- indexof (https://docs.microsoft.com/en-us/azure/data-explorer/kusto/query/indexoffunction); TODO: length and occurrence not supported yet';\n+Customers | project indexof('abcdefg','cde') | take 1;\n+Customers | project indexof('abcdefg','cde',2) | take 1;\n+Customers | project indexof('abcdefg','cde',6) | take 1;\n+print '-- base64_encode_fromguid()';\n+-- print base64_encode_fromguid(guid(null));\n+print base64_encode_fromguid(guid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb'));\n+print base64_encode_fromguid(dynamic(null)); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }\n+print base64_encode_fromguid(\"abcd1231\"); -- { serverError FUNCTION_THROW_IF_VALUE_IS_NON_ZERO }\n+print '-- base64_decode_toarray()';\n+print base64_decode_toarray('');\n+print base64_decode_toarray('S3VzdG8=');\n+print '-- base64_decode_toguid()';\n+print base64_decode_toguid(\"JpbpECu8dUy7Pv5gbeJXAA==\");\n+print base64_decode_toguid(base64_encode_fromguid(guid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb'))) == guid('ae3133f2-6e22-49ae-b06a-16e6a9b212eb');\n+print '-- base64_encode_tostring';\n+print base64_encode_tostring('');\n+print base64_encode_tostring('Kusto1');\n+print '-- base64_decode_tostring';\n+print base64_decode_tostring('');\n+print base64_decode_tostring('S3VzdG8x');\n+print '-- parse_url()';\n+print parse_url('scheme://username:password@host:1234/this/is/a/path?k1=v1&k2=v2#fragment');\n+print '-- parse_urlquery()';\n+print parse_urlquery('k1=v1&k2=v2&k3=v3');\n+print '-- strcmp()';\n+print strcmp('ABC','ABC'), strcmp('abc','ABC'), strcmp('ABC','abc'), strcmp('abcde','abc');\n+print '-- substring()';\n+print substring(\"ABCD\", -2, 2);\n+print '-- translate()';\n+print translate('krasp', 'otsku', 'spark'), translate('abc', '', 'ab'), translate('abc', 'x', 'abc');\n+print '-- trim()';\n+print trim(\"--\", \"--https://www.ibm.com--\");\n+print trim(\"[^\\w]+\", strcat(\"- \",\"Te st\", \"1\", \"// $\"));\n+print trim(\"\", \" asd \");\n+print trim(\"a$\", \"asd\");\n+print trim(\"^a\", \"asd\");\n+print '-- trim_start()';\n+print trim_start(\"https://\", \"https://www.ibm.com\");\n+print trim_start(\"[^\\w]+\", strcat(\"-  \",\"Te st\", \"1\", \"// $\"));\n+print trim_start(\"asd$\", \"asdw\");\n+print trim_start(\"asd$\", \"asd\");\n+print trim_start(\"d$\", \"asd\");\n+print '-- trim_end()';\n+print trim_end(\"://www.ibm.com\", \"https://www.ibm.com\");\n+print trim_end(\"[^\\w]+\", strcat(\"- \",\"Te st\", \"1\", \"// $\"));\n+print trim_end(\"^asd\", \"wasd\");\n+print trim_end(\"^asd\", \"asd\");\n+print trim_end(\"^a\", \"asd\");\n+print '-- trim, trim_start, trim_end all at once';\n+print str = \"--https://bing.com--\", pattern = '--' | extend start = trim_start(pattern, str), end = trim_end(pattern, str), both = trim(pattern, str);\n+print '-- replace_regex';\n+print replace_regex(strcat('Number is ', '1'), 'is (\\d+)', 'was: \\1');\n+print '-- has_any_index()';\n+print has_any_index('this is an example', dynamic(['this', 'example'])), has_any_index(\"this is an example\", dynamic(['not', 'example'])), has_any_index(\"this is an example\", dynamic(['not', 'found'])), has_any_index(\"this is an example\", dynamic([]));\n+print '-- parse_version()';\n+print parse_version(42); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+-- print parse_version(''); -> NULL\n+print parse_version('1.2.3.40');\n+print parse_version('1.2');\n+print parse_version(strcat('1.', '2'));\n+print parse_version('1.2.4.5.6');\n+print parse_version('moo'); \n+print parse_version('moo.boo.foo');\n+print parse_version(strcat_delim('.', 'moo', 'boo', 'foo'));\n+Versions | project parse_version(Version);\n+print '-- parse_json()';\n+print parse_json(dynamic([1, 2, 3]));\n+print parse_json('{\"a\":123.5, \"b\":\"{\\\\\"c\\\\\":456}\"}');\n+print '-- parse_command_line()';\n+print parse_command_line(55, 'windows'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+-- print parse_command_line((52 + 3) * 4 % 2, 'windows'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+print parse_command_line('', 'windows');\n+print parse_command_line(strrep(' ', 6), 'windows'); \n+-- print parse_command_line('echo \\\"hello world!\\\" print$?', 'windows'); -> [\"echo\",\"hello world!\",\"print$?\"]\n+-- print parse_command_line(\"yolo swag 'asd bcd' \\\"moo moo \\\"\", 'windows'); -> [\"yolo\",\"swag\",\"'asd\",\"bcd'\",\"moo moo \"]\n+-- print parse_command_line(strcat_delim(' ', \"yolo\", \"swag\", \"\\'asd bcd\\'\", \"\\\"moo moo \\\"\"), 'windows'); -> [\"yolo\",\"swag\",\"'asd\",\"bcd'\",\"moo moo \"]\n+print '-- reverse()';\n+print reverse(123);\n+print reverse(123.34);\n+print reverse('');\n+print reverse(\"asd\");\n+print reverse(dynamic([]));\n+print reverse(dynamic([1, 2, 3]));\n+print reverse(dynamic(['Darth', \"Vader\"]));\n+print reverse(datetime(2017-10-15 12:00));\n+-- print reverse(timespan(3h)); -> 00:00:30\n+Customers | where Education contains 'degree' | order by reverse(FirstName);\n+print '-- parse_csv()';\n+print parse_csv('');\n+print parse_csv(65); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+print parse_csv('aaa');\n+print result=parse_csv('aa,b,cc');\n+print result_multi_record=parse_csv('record1,a,b,c\\nrecord2,x,y,z');\n+-- print result=parse_csv('aa,\"b,b,b\",cc,\"Escaping quotes: \"\"Title\"\"\",\"line1\\nline2\"'); -> [\"aa\",\"b,b,b\",\"cc\",\"Escaping quotes: \\\"Title\\\"\",\"line1\\nline2\"]\n+-- print parse_csv(strcat(strcat_delim(',', 'aa', '\"b,b,b\"', 'cc', '\"Escaping quotes: \"\"Title\"\"\"', '\"line1\\nline2\"'), '\\r\\n', strcat_delim(',', 'asd', 'qcf'))); -> [\"aa\",\"b,b,b\",\"cc\",\"Escaping quotes: \\\"Title\\\"\",\"line1\\nline2\"]\ndiff --git a/tests/queries/0_stateless/02366_kql_makeseries.reference b/tests/queries/0_stateless/02366_kql_makeseries.reference\nnew file mode 100644\nindex 000000000000..8e7fde997bfb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_makeseries.reference\n@@ -0,0 +1,60 @@\n+-- from to\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[200,0,102]\n+Costco\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[0,2,0]\n+Aldi\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[0,500,0]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[5,0,6]\n+-- from\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[200,0,102]\n+Costco\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000']\t[0,2]\n+Aldi\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000']\t[0,500]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[5,0,6]\n+-- to\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[200,0,102]\n+Costco\tApple\t['2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[2,0]\n+Aldi\tSnargaluff\t['2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[500,0]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[5,0,6]\n+-- without from/to\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[200,0,102]\n+Costco\tApple\t['2016-09-11 00:00:00.000000000']\t[2]\n+Aldi\tSnargaluff\t['2016-09-11 00:00:00.000000000']\t[500]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[5,0,6]\n+-- without by\n+['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[70,334,54]\n+-- without aggregation alias\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[200,0,102]\n+Aldi\tSnargaluff\t['2016-09-11 00:00:00.000000000']\t[500]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[5,0,6]\n+Costco\tApple\t['2016-09-11 00:00:00.000000000']\t[2]\n+-- assign group alias\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[200,0,102]\n+Aldi\tSnargaluff\t['2016-09-11 00:00:00.000000000']\t[500]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000','2016-09-11 00:00:00.000000000','2016-09-12 00:00:00.000000000']\t[5,0,6]\n+Costco\tApple\t['2016-09-11 00:00:00.000000000']\t[2]\n+-- 3d step\n+Costco\tSnargaluff\t['2016-09-10 00:00:00.000000000']\t[134.66666666666666]\n+Costco\tApple\t['2016-09-10 00:00:00.000000000']\t[2]\n+Aldi\tSnargaluff\t['2016-09-10 00:00:00.000000000']\t[500]\n+Aldi\tApple\t['2016-09-10 00:00:00.000000000']\t[5.5]\n+-- numeric column\n+Costco\tSnargaluff\t[10,11,12,13,14]\t[200,0,102,0,0]\n+Aldi\tSnargaluff\t[10,11,12,13,14]\t[0,500,0,0,0]\n+Aldi\tApple\t[10,11,12,13,14]\t[5,0,6,0,0]\n+Costco\tApple\t[10,11,12,13,14]\t[0,2,0,0,0]\n+-- from\n+Costco\tSnargaluff\t[10,11,12]\t[200,0,102]\n+Aldi\tSnargaluff\t[10,11]\t[0,500]\n+Aldi\tApple\t[10,11,12]\t[5,0,6]\n+Costco\tApple\t[10,11]\t[0,2]\n+-- to\n+Costco\tSnargaluff\t[8,12,16]\t[200,102,0]\n+Aldi\tSnargaluff\t[8,12,16]\t[500,0,0]\n+Aldi\tApple\t[8,12,16]\t[5,6,0]\n+Costco\tApple\t[8,12,16]\t[2,0,0]\n+-- without from/to\n+Costco\tSnargaluff\t[10,12]\t[200,102]\n+Aldi\tSnargaluff\t[10]\t[500]\n+Aldi\tApple\t[10,12]\t[5,6]\n+Costco\tApple\t[10]\t[2]\n+-- without by\n+[10,12]\t[202,54]\n+['2017-01-01 00:00:00.000000000','2017-01-02 00:00:00.000000000','2017-01-03 00:00:00.000000000','2017-01-04 00:00:00.000000000','2017-01-05 00:00:00.000000000','2017-01-06 00:00:00.000000000','2017-01-07 00:00:00.000000000','2017-01-08 00:00:00.000000000','2017-01-09 00:00:00.000000000']\t[4,3,5,0,10.5,4,3,8,6.5]\ndiff --git a/tests/queries/0_stateless/02366_kql_makeseries.sql b/tests/queries/0_stateless/02366_kql_makeseries.sql\nnew file mode 100644\nindex 000000000000..ecf2ef43cc42\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_makeseries.sql\n@@ -0,0 +1,74 @@\n+-- Azure Data Explore Test Data\n+-- let make_series_test_table = datatable (Supplier:string, Fruit:string, Price: real, Purchase:datetime)\n+-- [\n+-- 'Aldi','Apple',4,'2016-09-10',\n+-- 'Costco','Apple',2,'2016-09-11',\n+-- 'Aldi','Apple',6,'2016-09-10',\n+-- 'Costco','Snargaluff',100,'2016-09-12',\n+-- 'Aldi','Apple',7,'2016-09-12',\n+-- 'Aldi','Snargaluff',400,'2016-09-11',\n+-- 'Costco','Snargaluff',104,'2016-09-12',\n+-- 'Aldi','Apple',5,'2016-09-12',\n+-- 'Aldi','Snargaluff',600,'2016-09-11',\n+-- 'Costco','Snargaluff',200,'2016-09-10',\n+-- ];\n+DROP TABLE IF EXISTS make_series_test_table;\n+CREATE TABLE make_series_test_table\n+(    \n+   Supplier Nullable(String),\n+   Fruit String ,\n+   Price Float64,\n+   Purchase Date \n+) ENGINE = Memory;\n+INSERT INTO make_series_test_table VALUES  ('Aldi','Apple',4,'2016-09-10'), ('Costco','Apple',2,'2016-09-11'), ('Aldi','Apple',6,'2016-09-10'), ('Costco','Snargaluff',100,'2016-09-12'), ('Aldi','Apple',7,'2016-09-12'), ('Aldi','Snargaluff',400,'2016-09-11'),('Costco','Snargaluff',104,'2016-09-12'),('Aldi','Apple',5,'2016-09-12'),('Aldi','Snargaluff',600,'2016-09-11'),('Costco','Snargaluff',200,'2016-09-10');\n+DROP TABLE IF EXISTS make_series_test_table2;\n+CREATE TABLE make_series_test_table2\n+(    \n+   Supplier Nullable(String),\n+   Fruit String ,\n+   Price Int32,\n+   Purchase Int32  \n+) ENGINE = Memory;\n+INSERT INTO make_series_test_table2 VALUES  ('Aldi','Apple',4,10),('Costco','Apple',2,11),('Aldi','Apple',6,10),('Costco','Snargaluff',100,12),('Aldi','Apple',7,12),('Aldi','Snargaluff',400,11),('Costco','Snargaluff',104,12),('Aldi','Apple',5,12),('Aldi','Snargaluff',600,11),('Costco','Snargaluff',200,10);\n+DROP TABLE IF EXISTS make_series_test_table3;\n+CREATE TABLE make_series_test_table3\n+(    \n+    timestamp datetime,\n+    metric Float64,\n+) ENGINE = Memory;\n+INSERT INTO make_series_test_table3 VALUES (parseDateTimeBestEffort('2016-12-31T06:00', 'UTC'), 50), (parseDateTimeBestEffort('2017-01-01', 'UTC'), 4), (parseDateTimeBestEffort('2017-01-02', 'UTC'), 3), (parseDateTimeBestEffort('2017-01-03', 'UTC'), 4), (parseDateTimeBestEffort('2017-01-03T03:00', 'UTC'), 6), (parseDateTimeBestEffort('2017-01-05', 'UTC'), 8), (parseDateTimeBestEffort('2017-01-05T13:40', 'UTC'), 13), (parseDateTimeBestEffort('2017-01-06', 'UTC'), 4), (parseDateTimeBestEffort('2017-01-07', 'UTC'), 3), (parseDateTimeBestEffort('2017-01-08', 'UTC'), 8), (parseDateTimeBestEffort('2017-01-08T21:00', 'UTC'), 8), (parseDateTimeBestEffort('2017-01-09', 'UTC'), 2), (parseDateTimeBestEffort('2017-01-09T12:00', 'UTC'), 11), (parseDateTimeBestEffort('2017-01-10T05:00', 'UTC'), 5);\n+\n+set dialect = 'kusto';\n+print '-- from to';\n+make_series_test_table |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 1d by Supplier, Fruit | order by Supplier, Fruit;\n+print '-- from';\n+make_series_test_table |  make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  step 1d by Supplier, Fruit | order by Supplier, Fruit;\n+print '-- to';\n+make_series_test_table |  make-series PriceAvg = avg(Price) default=0 on Purchase to datetime(2016-09-13) step 1d by Supplier, Fruit | order by Supplier, Fruit;\n+print '-- without from/to';\n+make_series_test_table | make-series PriceAvg = avg(Price) default=0 on Purchase step 1d by Supplier, Fruit | order by Supplier, Fruit;\n+print '-- without by';\n+make_series_test_table | make-series PriceAvg = avg(Price) default=0 on Purchase step 1d;\n+print '-- without aggregation alias';\n+make_series_test_table | make-series avg(Price) default=0 on Purchase step 1d by Supplier, Fruit;\n+print '-- assign group alias';\n+make_series_test_table | make-series avg(Price) default=0 on Purchase step 1d by Supplier_Name = Supplier, Fruit;\n+print '-- 3d step';\n+make_series_test_table | make-series PriceAvg = avg(Price) default=0 on Purchase from datetime(2016-09-10)  to datetime(2016-09-13) step 3d by Supplier, Fruit | order by Supplier, Fruit;\n+\n+print '-- numeric column'\n+print '-- from to';\n+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 to  15 step  1.0  by Supplier, Fruit;\n+print '-- from';\n+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase from 10 step  1.0  by Supplier, Fruit;\n+print '-- to';\n+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase to 18 step  4.0  by Supplier, Fruit;\n+print '-- without from/to';\n+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  2.0  by Supplier, Fruit;\n+print '-- without by';\n+make_series_test_table2 | make-series PriceAvg=avg(Price) default=0 on Purchase step  2.0;\n+\n+make_series_test_table3 | make-series avg(metric) default=0  on timestamp from datetime(2017-01-01) to datetime(2017-01-10) step 1d \n+\n+-- print '-- summarize --'\n+-- make_series_test_table | summarize count() by format_datetime(bin(Purchase, 1d), 'yy-MM-dd');\ndiff --git a/tests/queries/0_stateless/02366_kql_mvexpand.reference b/tests/queries/0_stateless/02366_kql_mvexpand.reference\nnew file mode 100644\nindex 000000000000..25be070eb0b7\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_mvexpand.reference\n@@ -0,0 +1,65 @@\n+-- mv-expand --\n+-- mv_expand_test_table | mv-expand c --\n+1\t['Salmon','Steak','Chicken']\t1\t[5,6,7,8]\n+1\t['Salmon','Steak','Chicken']\t2\t[5,6,7,8]\n+1\t['Salmon','Steak','Chicken']\t3\t[5,6,7,8]\n+1\t['Salmon','Steak','Chicken']\t4\t[5,6,7,8]\n+-- mv_expand_test_table | mv-expand c, d --\n+1\t['Salmon','Steak','Chicken']\t1\t5\n+1\t['Salmon','Steak','Chicken']\t2\t6\n+1\t['Salmon','Steak','Chicken']\t3\t7\n+1\t['Salmon','Steak','Chicken']\t4\t8\n+-- mv_expand_test_table | mv-expand b | mv-expand c --\n+1\tSalmon\t1\t[5,6,7,8]\n+1\tSalmon\t2\t[5,6,7,8]\n+1\tSalmon\t3\t[5,6,7,8]\n+1\tSalmon\t4\t[5,6,7,8]\n+1\tSteak\t1\t[5,6,7,8]\n+1\tSteak\t2\t[5,6,7,8]\n+1\tSteak\t3\t[5,6,7,8]\n+1\tSteak\t4\t[5,6,7,8]\n+1\tChicken\t1\t[5,6,7,8]\n+1\tChicken\t2\t[5,6,7,8]\n+1\tChicken\t3\t[5,6,7,8]\n+1\tChicken\t4\t[5,6,7,8]\n+-- mv_expand_test_table | mv-expand with_itemindex=index b, c, d --\n+0\t1\tSalmon\t1\t5\n+1\t1\tSteak\t2\t6\n+2\t1\tChicken\t3\t7\n+3\t1\t\t4\t8\n+-- mv_expand_test_table | mv-expand array_concat(c,d) --\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t1\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t2\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t3\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t4\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t5\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t6\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t7\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t8\n+-- mv_expand_test_table | mv-expand x = c, y = d --\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t1\t5\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t2\t6\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t3\t7\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t4\t8\n+-- mv_expand_test_table | mv-expand xy = array_concat(c, d) --\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t1\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t2\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t3\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t4\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t5\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t6\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t7\n+1\t['Salmon','Steak','Chicken']\t[1,2,3,4]\t[5,6,7,8]\t8\n+-- mv_expand_test_table | mv-expand xy = array_concat(c, d) limit 2| summarize count() by xy --\n+1\t1\n+2\t1\n+-- mv_expand_test_table | mv-expand with_itemindex=index c,d to typeof(bool) --\n+0\t1\t['Salmon','Steak','Chicken']\t1\ttrue\n+1\t1\t['Salmon','Steak','Chicken']\t2\ttrue\n+2\t1\t['Salmon','Steak','Chicken']\t3\ttrue\n+3\t1\t['Salmon','Steak','Chicken']\t4\ttrue\n+-- mv_expand_test_table | mv-expand c to typeof(bool) --\n+1\t['Salmon','Steak','Chicken']\t[5,6,7,8]\ttrue\n+1\t['Salmon','Steak','Chicken']\t[5,6,7,8]\ttrue\n+1\t['Salmon','Steak','Chicken']\t[5,6,7,8]\ttrue\n+1\t['Salmon','Steak','Chicken']\t[5,6,7,8]\ttrue\ndiff --git a/tests/queries/0_stateless/02366_kql_mvexpand.sql b/tests/queries/0_stateless/02366_kql_mvexpand.sql\nnew file mode 100644\nindex 000000000000..e77986096463\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_mvexpand.sql\n@@ -0,0 +1,35 @@\n+-- datatable(a: int, b: dynamic, c: dynamic, d: dynamic) [\n+--    1, dynamic(['Salmon', 'Steak', 'Chicken']), dynamic([1, 2, 3, 4]), dynamic([5, 6, 7, 8])\n+-- ]\n+\n+DROP TABLE IF EXISTS mv_expand_test_table;\n+CREATE TABLE mv_expand_test_table\n+(    \n+   a UInt8,\n+   b Array(String),\n+   c Array(Int8),\n+   d Array(Int8)\n+) ENGINE = Memory;\n+INSERT INTO mv_expand_test_table VALUES (1, ['Salmon', 'Steak','Chicken'],[1,2,3,4],[5,6,7,8]);\n+set dialect='kusto';\n+print '-- mv-expand --';\n+print '-- mv_expand_test_table | mv-expand c --';\n+mv_expand_test_table | mv-expand c;\n+print '-- mv_expand_test_table | mv-expand c, d --';\n+mv_expand_test_table | mv-expand c, d;\n+print '-- mv_expand_test_table | mv-expand b | mv-expand c --';\n+mv_expand_test_table | mv-expand b | mv-expand c;\n+print '-- mv_expand_test_table | mv-expand with_itemindex=index b, c, d --';\n+mv_expand_test_table | mv-expand with_itemindex=index b, c, d;\n+print '-- mv_expand_test_table | mv-expand array_concat(c,d) --';\n+mv_expand_test_table | mv-expand array_concat(c,d);\n+print '-- mv_expand_test_table | mv-expand x = c, y = d --';\n+mv_expand_test_table | mv-expand x = c, y = d;\n+print '-- mv_expand_test_table | mv-expand xy = array_concat(c, d) --';\n+mv_expand_test_table | mv-expand xy = array_concat(c, d);\n+print '-- mv_expand_test_table | mv-expand xy = array_concat(c, d) limit 2| summarize count() by xy --';\n+mv_expand_test_table | mv-expand xy = array_concat(c, d) limit 2| summarize count() by xy;\n+print '-- mv_expand_test_table | mv-expand with_itemindex=index c,d to typeof(bool) --';\n+mv_expand_test_table | mv-expand with_itemindex=index c,d to typeof(bool);\n+print '-- mv_expand_test_table | mv-expand c to typeof(bool) --';\n+mv_expand_test_table | mv-expand c to typeof(bool);\ndiff --git a/tests/queries/0_stateless/02366_kql_operator_in_sql.reference b/tests/queries/0_stateless/02366_kql_operator_in_sql.reference\nnew file mode 100644\nindex 000000000000..4e0987aa5c38\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_operator_in_sql.reference\n@@ -0,0 +1,60 @@\n+-- #1 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #2 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #3 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #4 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #5 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #6 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #7 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #8 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #9 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #10 --\n+-- #11 --\n+-- #12 --\n+-- #13 --\n+-- #14 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\n+-- #15 --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement abcd defg\tBachelors\t33\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Apple\t\tSkilled Manual\tBachelors\t28\ndiff --git a/tests/queries/0_stateless/02366_kql_operator_in_sql.sql b/tests/queries/0_stateless/02366_kql_operator_in_sql.sql\nnew file mode 100644\nindex 000000000000..0b02faa06807\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_operator_in_sql.sql\n@@ -0,0 +1,42 @@\n+DROP TABLE IF EXISTS Customers;\n+CREATE TABLE Customers\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Occupation String,\n+    Education String,\n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+\n+INSERT INTO Customers VALUES  ('Theodore','Diaz','Skilled Manual','Bachelors',28),('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);\n+Select '-- #1 --' ;\n+select * from kql($$Customers | where FirstName !in ('Peter', 'Latoya')$$);\n+Select '-- #2 --' ;\n+select * from kql($$Customers | where FirstName !in (\"test\", \"test2\")$$);\n+Select '-- #3 --' ;\n+select * from kql($$Customers | where FirstName !contains 'Pet'$$);\n+Select '-- #4 --' ;\n+select * from kql($$Customers | where FirstName !contains_cs 'Pet'$$);\n+Select '-- #5 --' ;\n+select * from kql($$Customers | where FirstName !endswith 'ter'$$);\n+Select '-- #6 --' ;\n+select * from kql($$Customers | where FirstName !endswith_cs 'ter'$$);\n+Select '-- #7 --' ;\n+select * from kql($$Customers | where FirstName != 'Peter'$$);\n+Select '-- #8 --' ;\n+select * from kql($$Customers | where FirstName !has 'Peter'$$);\n+Select '-- #9 --' ;\n+select * from kql($$Customers | where FirstName !has_cs 'peter'$$);\n+Select '-- #10 --' ;\n+-- select * from kql($$Customers | where FirstName !hasprefix 'Peter'$$); -- will enable when analyzer fixed `and` issue\n+Select '-- #11 --' ;\n+--select * from kql($$Customers | where FirstName !hasprefix_cs 'Peter'$$);\n+Select '-- #12 --' ;\n+--select * from kql($$Customers | where FirstName !hassuffix 'Peter'$$);\n+Select '-- #13 --' ;\n+--select * from kql($$Customers | where FirstName !hassuffix_cs 'Peter'$$);\n+Select '-- #14 --' ;\n+select * from kql($$Customers | where FirstName !startswith 'Peter'$$);\n+Select '-- #15 --' ;\n+select * from kql($$Customers | where FirstName !startswith_cs 'Peter'$$);\n+DROP TABLE IF EXISTS Customers;\ndiff --git a/tests/queries/0_stateless/02366_kql_summarize.reference b/tests/queries/0_stateless/02366_kql_summarize.reference\nnew file mode 100644\nindex 000000000000..aeb42feb6bea\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_summarize.reference\n@@ -0,0 +1,92 @@\n+-- test summarize --\n+12\t25\t46\t32.416666666666664\t389\n+Skilled Manual\t5\t26\t36\t30.2\t151\n+Professional\t6\t25\t46\t34.166666666666664\t205\n+Management abcd defg\t1\t33\t33\t33\t33\n+Skilled Manual\t0\n+Professional\t2\n+Management abcd defg\t0\n+Skilled Manual\t36\n+Professional\t38\n+Management abcd defg\t33\n+Skilled Manual\t26\n+Professional\t25\n+Management abcd defg\t33\n+Skilled Manual\t30.2\n+Professional\t29.25\n+Management abcd defg\t33\n+Skilled Manual\t151\n+Professional\t117\n+Management abcd defg\t33\n+4\n+2\n+40\t2\n+30\t4\n+20\t6\n+Skilled Manual\t5\n+Professional\t6\n+Management abcd defg\t1\n+-- make_list() --\n+Skilled Manual\t['Bachelors','Graduate Degree','High School','Partial College','Bachelors']\n+Professional\t['Graduate Degree','Partial College','Partial College','Partial College','Partial College','Partial College']\n+Management abcd defg\t['Bachelors']\n+Skilled Manual\t['Bachelors','Graduate Degree']\n+Professional\t['Graduate Degree','Partial College']\n+Management abcd defg\t['Bachelors']\n+-- make_list_if() --\n+Skilled Manual\t['Edward','Christine']\n+Professional\t['Dalton','Angel']\n+Management abcd defg\t['Stephanie']\n+Skilled Manual\t['Edward']\n+Professional\t['Dalton']\n+Management abcd defg\t['Stephanie']\n+-- make_set() --\n+Skilled Manual\t['Graduate Degree','High School','Partial College','Bachelors']\n+Professional\t['Graduate Degree','Partial College']\n+Management abcd defg\t['Bachelors']\n+Skilled Manual\t['Graduate Degree','Bachelors']\n+Professional\t['Graduate Degree','Partial College']\n+Management abcd defg\t['Bachelors']\n+-- make_set_if() --\n+Skilled Manual\t['Partial College','High School']\n+Professional\t['Partial College']\n+Management abcd defg\t['Bachelors']\n+Skilled Manual\t['High School']\n+Professional\t['Partial College']\n+Management abcd defg\t['Bachelors']\n+-- stdev() --\n+6.855102059227432\n+-- stdevif() --\n+7.557189365836421\n+-- binary_all_and --\n+42\n+-- binary_all_or --\n+46\n+-- binary_all_xor --\n+4\n+43.8\n+25.55\t30.5\t43.8\n+30.5\n+35\n+[25,35,45]\n+-- Summarize following sort --\n+Skilled Manual\t5\n+Professional\t6\n+Management abcd defg\t1\n+-- summarize with bin --\n+0\t1\n+245000\t2\n+0\t1\n+245\t2\n+0\t1\n+245\t2\n+2015-10-12 00:00:00.000000000\n+2016-10-12 00:00:00.000000000\n+-- make_list_with_nulls --\n+['Theodore','Stephanie','Peter','Latoya','Joshua','Edward','Dalton','Christine','Cameron','Angel','Apple',NULL]\n+Skilled Manual\t['Theodore','Peter','Edward','Christine','Apple']\n+Professional\t['Latoya','Joshua','Dalton','Cameron','Angel',NULL]\n+Management abcd defg\t['Stephanie']\n+Skilled Manual\t['Theodore','Peter','Edward','Christine','Apple']\t[28,26,36,33,28]\n+Professional\t['Latoya','Joshua','Dalton','Cameron','Angel',NULL]\t[25,26,42,28,46,38]\n+Management abcd defg\t['Stephanie']\t[33]\ndiff --git a/tests/queries/0_stateless/02366_kql_summarize.sql b/tests/queries/0_stateless/02366_kql_summarize.sql\nnew file mode 100644\nindex 000000000000..21a1b643d987\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_summarize.sql\n@@ -0,0 +1,102 @@\n+-- datatable(FirstName:string, LastName:string, Occupation:string, Education:string, Age:int) [\n+--     'Theodore', 'Diaz', 'Skilled Manual', 'Bachelors', 28, \n+--     'Stephanie', 'Cox', 'Management abcd defg', 'Bachelors', 33, \n+--     'Peter', 'Nara', 'Skilled Manual', 'Graduate Degree', 26, \n+--     'Latoya', 'Shen', 'Professional', 'Graduate Degree', 25, \n+--     'Joshua', 'Lee', 'Professional', 'Partial College', 26, \n+--     'Edward', 'Hernandez', 'Skilled Manual', 'High School', 36, \n+--     'Dalton', 'Wood', 'Professional', 'Partial College', 42, \n+--     'Christine', 'Nara', 'Skilled Manual', 'Partial College', 33, \n+--     'Cameron', 'Rodriguez', 'Professional', 'Partial College', 28, \n+--     'Angel', 'Stewart', 'Professional', 'Partial College', 46, \n+--     'Apple', '', 'Skilled Manual', 'Bachelors', 28, \n+--     dynamic(null), 'why', 'Professional', 'Partial College', 38\n+-- ]\n+\n+DROP TABLE IF EXISTS Customers;\n+CREATE TABLE Customers\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Occupation String,\n+    Education String,\n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+\n+INSERT INTO Customers VALUES  ('Theodore','Diaz','Skilled Manual','Bachelors',28),('Stephanie','Cox','Management abcd defg','Bachelors',33),('Peter','Nara','Skilled Manual','Graduate Degree',26),('Latoya','Shen','Professional','Graduate Degree',25),('Joshua','Lee','Professional','Partial College',26),('Edward','Hernandez','Skilled Manual','High School',36),('Dalton','Wood','Professional','Partial College',42),('Christine','Nara','Skilled Manual','Partial College',33),('Cameron','Rodriguez','Professional','Partial College',28),('Angel','Stewart','Professional','Partial College',46),('Apple','','Skilled Manual','Bachelors',28),(NULL,'why','Professional','Partial College',38);\n+\n+drop table if exists EventLog;\n+create table EventLog\n+(\n+    LogEntry String,\n+    Created Int64\n+) ENGINE = Memory;\n+\n+insert into EventLog values ('Darth Vader has entered the room.', 546), ('Rambo is suspciously looking at Darth Vader.', 245234), ('Darth Sidious electrocutes both using Force Lightning.', 245554);\n+\n+drop table if exists Dates;\n+create table Dates\n+(\n+    EventTime DateTime,\n+) ENGINE = Memory;\n+\n+Insert into Dates VALUES ('2015-10-12') , ('2016-10-12')\n+Select '-- test summarize --' ;\n+set dialect='kusto';\n+Customers | summarize count(), min(Age), max(Age), avg(Age), sum(Age);\n+Customers | summarize count(), min(Age), max(Age), avg(Age), sum(Age) by Occupation | order by Occupation;\n+Customers | summarize countif(Age>40) by Occupation | order by Occupation;\n+Customers | summarize MyMax = maxif(Age, Age<40) by Occupation | order by Occupation;\n+Customers | summarize MyMin = minif(Age, Age<40) by Occupation | order by Occupation;\n+Customers | summarize MyAvg = avgif(Age, Age<40) by Occupation | order by Occupation;\n+Customers | summarize MySum = sumif(Age, Age<40) by Occupation | order by Occupation;\n+Customers | summarize dcount(Education);\n+Customers | summarize dcountif(Education, Occupation=='Professional');\n+Customers | summarize count_ = count() by bin(Age, 10) | order by count_ asc;\n+Customers | summarize job_count = count() by Occupation | where job_count > 0 | order by Occupation;\n+Customers | summarize 'Edu Count'=count() by Education | sort by 'Edu Count' desc; -- { clientError 62 }\n+\n+print '-- make_list() --';\n+Customers | summarize f_list = make_list(Education) by Occupation | sort by Occupation;\n+Customers | summarize f_list = make_list(Education, 2) by Occupation | sort by Occupation;\n+print '-- make_list_if() --';\n+Customers | summarize f_list = make_list_if(FirstName, Age>30) by Occupation | sort by Occupation;\n+Customers | summarize f_list = make_list_if(FirstName, Age>30, 1) by Occupation | sort by Occupation;\n+print '-- make_set() --';\n+Customers | summarize f_list = make_set(Education) by Occupation | sort by Occupation;\n+Customers | summarize f_list = make_set(Education, 2) by Occupation | sort by Occupation;\n+print '-- make_set_if() --';\n+Customers | summarize f_list = make_set_if(Education, Age>30) by Occupation | sort by Occupation;\n+Customers | summarize f_list = make_set_if(Education, Age>30, 1) by Occupation | sort by Occupation;\n+print '-- stdev() --';\n+Customers | project Age | summarize stdev(Age);\n+print '-- stdevif() --';\n+Customers | project Age | summarize stdevif(Age, Age%2==0);\n+print '-- binary_all_and --';\n+Customers | project Age | where Age > 40 | summarize binary_all_and(Age);\n+print '-- binary_all_or --';\n+Customers | project Age | where Age > 40 | summarize binary_all_or(Age);\n+print '-- binary_all_xor --';\n+Customers | project Age | where Age > 40 | summarize binary_all_xor(Age);\n+\n+Customers | project Age | summarize percentile(Age, 95);\n+Customers | project Age | summarize percentiles(Age, 5, 50, 95)|project round(percentiles_Age[0],2),round(percentiles_Age[1],2),round(percentiles_Age[2],2);\n+Customers | project Age | summarize percentiles(Age, 5, 50, 95)[1];\n+Customers | summarize w=count() by AgeBucket=bin(Age, 5) | summarize percentilew(AgeBucket, w, 75);\n+Customers | summarize w=count() by AgeBucket=bin(Age, 5) | summarize percentilesw(AgeBucket, w, 50, 75, 99.9);\n+\n+print '-- Summarize following sort --';\n+Customers | sort by FirstName | summarize count() by Occupation | sort by Occupation;\n+\n+print '-- summarize with bin --';\n+EventLog | summarize count=count() by bin(Created, 1000);\n+EventLog | summarize count=count() by bin(unixtime_seconds_todatetime(Created/1000), 1s);\n+EventLog | summarize count=count() by time_label=bin(Created/1000, 1s);\n+Dates | project bin(datetime(EventTime), 1m);\n+print '-- make_list_with_nulls --';\n+Customers | summarize t = make_list_with_nulls(FirstName);\n+Customers | summarize f_list = make_list_with_nulls(FirstName) by Occupation | sort by Occupation;\n+Customers | summarize f_list = make_list_with_nulls(FirstName), a_list = make_list_with_nulls(Age) by Occupation | sort by Occupation;\n+-- TODO:\n+-- arg_max()\n+-- arg_min()\ndiff --git a/tests/queries/0_stateless/02366_kql_tabular.reference b/tests/queries/0_stateless/02366_kql_tabular.reference\nnew file mode 100644\nindex 000000000000..e70c02ce34fa\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_tabular.reference\n@@ -0,0 +1,139 @@\n+-- test Query only has table name: --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\t28\n+Stephanie\tCox\tManagement\tBachelors\t33\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Latoya\tShen\tProfessional\tGraduate Degree\t25\n+Joshua\tLee\tProfessional\tPartial College\t26\n+Edward\tHernandez\tSkilled Manual\tHigh School\t36\n+Dalton\tWood\tProfessional\tPartial College\t42\n+Christine\tNara\tSkilled Manual\tPartial College\t33\n+Cameron\tRodriguez\tProfessional\tPartial College\t28\n+Angel\tStewart\tProfessional\tPartial College\t46\n+-- Query has Column Selection --\n+Theodore\tDiaz\tSkilled Manual\n+Stephanie\tCox\tManagement\n+Peter\tNara\tSkilled Manual\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+Edward\tHernandez\tSkilled Manual\n+Dalton\tWood\tProfessional\n+Christine\tNara\tSkilled Manual\n+Cameron\tRodriguez\tProfessional\n+Angel\tStewart\tProfessional\n+-- Query has limit --\n+Theodore\tDiaz\tSkilled Manual\n+Stephanie\tCox\tManagement\n+Peter\tNara\tSkilled Manual\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+Theodore\tDiaz\tSkilled Manual\n+Stephanie\tCox\tManagement\n+Peter\tNara\tSkilled Manual\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+-- Query has second limit with bigger value --\n+Theodore\tDiaz\tSkilled Manual\n+Stephanie\tCox\tManagement\n+Peter\tNara\tSkilled Manual\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+-- Query has second limit with smaller value --\n+Theodore\tDiaz\tSkilled Manual\n+Stephanie\tCox\tManagement\n+Peter\tNara\tSkilled Manual\n+-- Query has second Column selection --\n+Theodore\tDiaz\n+Stephanie\tCox\n+Peter\tNara\n+-- Query has second Column selection with extra column --\n+-- Query with desc sort --\n+Theodore\n+Stephanie\n+Peter\n+Latoya\n+Joshua\n+Skilled Manual\n+Skilled Manual\n+Professional\n+Professional\n+Management\n+-- Query with asc sort --\n+Management\n+Professional\n+Professional\n+Skilled Manual\n+Skilled Manual\n+-- Query with sort (without keyword asc desc) --\n+Theodore\n+Stephanie\n+Peter\n+Latoya\n+Joshua\n+Skilled Manual\n+Skilled Manual\n+Professional\n+Professional\n+Management\n+-- Query with sort 2 Columns with different direction --\n+Stephanie\tCox\tManagement\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+Peter\tNara\tSkilled Manual\n+Theodore\tDiaz\tSkilled Manual\n+-- Query with second sort --\n+Stephanie\tCox\tManagement\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+Peter\tNara\tSkilled Manual\n+Theodore\tDiaz\tSkilled Manual\n+-- Test String Equals (==) --\n+Theodore\tDiaz\tSkilled Manual\n+Peter\tNara\tSkilled Manual\n+Edward\tHernandez\tSkilled Manual\n+Christine\tNara\tSkilled Manual\n+-- Test String Not equals (!=) --\n+Stephanie\tCox\tManagement\n+Latoya\tShen\tProfessional\n+Joshua\tLee\tProfessional\n+Dalton\tWood\tProfessional\n+Cameron\tRodriguez\tProfessional\n+Angel\tStewart\tProfessional\n+-- Test Filter using a list (in) --\n+Theodore\tDiaz\tSkilled Manual\tBachelors\n+Stephanie\tCox\tManagement\tBachelors\n+Edward\tHernandez\tSkilled Manual\tHigh School\n+-- Test Filter using a list (!in) --\n+Peter\tNara\tSkilled Manual\tGraduate Degree\n+Latoya\tShen\tProfessional\tGraduate Degree\n+Joshua\tLee\tProfessional\tPartial College\n+Dalton\tWood\tProfessional\tPartial College\n+Christine\tNara\tSkilled Manual\tPartial College\n+Cameron\tRodriguez\tProfessional\tPartial College\n+Angel\tStewart\tProfessional\tPartial College\n+-- Test Filter using common string operations (contains_cs) --\n+Joshua\tLee\tProfessional\tPartial College\n+Dalton\tWood\tProfessional\tPartial College\n+Christine\tNara\tSkilled Manual\tPartial College\n+Cameron\tRodriguez\tProfessional\tPartial College\n+Angel\tStewart\tProfessional\tPartial College\n+-- Test Filter using common string operations (startswith_cs) --\n+Latoya\tShen\tProfessional\tGraduate Degree\n+Joshua\tLee\tProfessional\tPartial College\n+Dalton\tWood\tProfessional\tPartial College\n+Cameron\tRodriguez\tProfessional\tPartial College\n+Angel\tStewart\tProfessional\tPartial College\n+-- Test Filter using common string operations (endswith_cs) --\n+Latoya\tShen\tProfessional\tGraduate Degree\n+Joshua\tLee\tProfessional\tPartial College\n+-- Test Filter using numerical equal (==) --\n+Peter\tNara\tSkilled Manual\tGraduate Degree\t26\n+Joshua\tLee\tProfessional\tPartial College\t26\n+-- Test Filter using numerical great and less (> , <) --\n+Stephanie\tCox\tManagement\tBachelors\t33\n+Edward\tHernandez\tSkilled Manual\tHigh School\t36\n+Christine\tNara\tSkilled Manual\tPartial College\t33\n+-- Test Filter using multi where --\n+Dalton\tWood\tProfessional\tPartial College\t42\n+Angel\tStewart\tProfessional\tPartial College\t46\n+-- Complex query with unknown function --\n+-- Missing column in front of startsWith --\ndiff --git a/tests/queries/0_stateless/02366_kql_tabular.sql b/tests/queries/0_stateless/02366_kql_tabular.sql\nnew file mode 100644\nindex 000000000000..f73c4c09ccaa\n--- /dev/null\n+++ b/tests/queries/0_stateless/02366_kql_tabular.sql\n@@ -0,0 +1,88 @@\n+DROP TABLE IF EXISTS Customers;\n+CREATE TABLE Customers\n+(    \n+    FirstName Nullable(String),\n+    LastName String, \n+    Occupation String,\n+    Education String,\n+    Age Nullable(UInt8)\n+) ENGINE = Memory;\n+\n+INSERT INTO Customers VALUES ('Theodore','Diaz','Skilled Manual','Bachelors',28), ('Stephanie','Cox','Management','Bachelors',33), ('Peter','Nara','Skilled Manual','Graduate Degree',26), ('Latoya','Shen','Professional','Graduate Degree',25), ('Joshua','Lee','Professional','Partial College',26), ('Edward','Hernandez','Skilled Manual','High School',36), ('Dalton','Wood','Professional','Partial College',42), ('Christine','Nara','Skilled Manual','Partial College',33), ('Cameron','Rodriguez','Professional','Partial College',28), ('Angel','Stewart','Professional','Partial College',46);\n+\n+set dialect='kusto';\n+print '-- test Query only has table name: --';\n+Customers;\n+\n+print '-- Query has Column Selection --';\n+Customers | project FirstName,LastName,Occupation;\n+\n+print '-- Query has limit --';\n+Customers | project FirstName,LastName,Occupation | take 5;\n+Customers | project FirstName,LastName,Occupation | limit 5;\n+\n+print '-- Query has second limit with bigger value --';\n+Customers | project FirstName,LastName,Occupation | take 5 | take 7;\n+\n+print '-- Query has second limit with smaller value --';\n+Customers | project FirstName,LastName,Occupation | take 5 | take 3;\n+\n+print '-- Query has second Column selection --';\n+Customers | project FirstName,LastName,Occupation | take 3 | project FirstName,LastName;\n+\n+print '-- Query has second Column selection with extra column --';\n+Customers| project FirstName,LastName,Occupation | take 3 | project FirstName,LastName,Education;-- { serverError 47 }\n+\n+print '-- Query with desc sort --';\n+Customers | project FirstName | take 5 | sort by FirstName desc;\n+Customers | project Occupation | take 5 | order by Occupation desc;\n+\n+print '-- Query with asc sort --';\n+Customers | project Occupation | take 5 | sort by Occupation asc;\n+\n+print '-- Query with sort (without keyword asc desc) --';\n+Customers | project FirstName | take 5 | sort by FirstName;\n+Customers | project Occupation | take 5 | order by Occupation;\n+\n+print '-- Query with sort 2 Columns with different direction --';\n+Customers | project FirstName,LastName,Occupation | take 5 | sort by Occupation asc, LastName desc;\n+\n+print '-- Query with second sort --';\n+Customers | project FirstName,LastName,Occupation | take 5 | sort by Occupation desc |sort by Occupation asc, LastName desc;\n+\n+print '-- Test String Equals (==) --';\n+Customers | project FirstName,LastName,Occupation | where Occupation == 'Skilled Manual';\n+\n+print '-- Test String Not equals (!=) --';\n+Customers | project FirstName,LastName,Occupation | where Occupation != 'Skilled Manual';\n+\n+print '-- Test Filter using a list (in) --';\n+Customers | project FirstName,LastName,Occupation,Education | where Education in  ('Bachelors','High School');\n+\n+print '-- Test Filter using a list (!in) --';\n+set dialect='kusto';\n+Customers | project FirstName,LastName,Occupation,Education | where Education !in  ('Bachelors','High School');\n+\n+print '-- Test Filter using common string operations (contains_cs) --';\n+Customers | project FirstName,LastName,Occupation,Education | where Education contains_cs 'Coll';\n+\n+print '-- Test Filter using common string operations (startswith_cs) --';\n+Customers | project FirstName,LastName,Occupation,Education | where Occupation startswith_cs 'Prof';\n+\n+print '-- Test Filter using common string operations (endswith_cs) --';\n+Customers | project FirstName,LastName,Occupation,Education | where FirstName endswith_cs 'a';\n+\n+print '-- Test Filter using numerical equal (==) --';\n+Customers | project FirstName,LastName,Occupation,Education,Age | where Age == 26;\n+\n+print '-- Test Filter using numerical great and less (> , <) --';\n+Customers | project FirstName,LastName,Occupation,Education,Age | where Age > 30 and Age < 40;\n+\n+print '-- Test Filter using multi where --';\n+Customers | project FirstName,LastName,Occupation,Education,Age | where Age > 30 | where Occupation == 'Professional';\n+\n+print '-- Complex query with unknown function --';\n+hits | where CounterID == 62 and EventDate >= '2013-07-14' and EventDate <= '2013-07-15' and IsRefresh == 0 and DontCountHits == 0 | summarize count() by d=bin(poopoo(EventTime), 1m) | order by d | limit 10; -- { clientError UNKNOWN_FUNCTION }\n+\n+print '-- Missing column in front of startsWith --';\n+StormEvents | where startswith \"W\" | summarize Count=count() by State; -- { clientError SYNTAX_ERROR }\ndiff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\nindex 4f40da6c626a..148ad303bd45 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\n@@ -15,7 +15,7 @@ AND name NOT IN (\n     'h3ToGeoBoundary', 'h3ToParent', 'h3ToString', 'h3UnidirectionalEdgeIsValid', 'h3kRing', 'stringToH3',\n     'geoToS2', 's2CapContains', 's2CapUnion', 's2CellsIntersect', 's2GetNeighbors', 's2RectAdd', 's2RectContains', 's2RectIntersection', 's2RectUnion', 's2ToGeo',\n     'normalizeUTF8NFC', 'normalizeUTF8NFD', 'normalizeUTF8NFKC', 'normalizeUTF8NFKD',\n-    'lemmatize', 'tokenize', 'stem', 'synonyms',\n+    'lemmatize', 'tokenize', 'stem', 'synonyms', 'kql_array_sort_asc', 'kql_array_sort_desc',\n     'detectCharset', 'detectLanguageUnknown', 'detectProgrammingLanguage', 'detectTonality'\n      -- these functions are not enabled in fast test\n ) ORDER BY name;\n",
  "problem_statement": "segmentation fault on inner join and dict\nI tried to join two tables like this:\r\n```sql\r\nCREATE TABLE comments_videos ENGINE=MergeTree(date,(video_id, date), 8192) AS SELECT video_id,\r\n       date,\r\n       dictGetString('video','channel_id',tuple(toString(video_id))) AS channel_id,\r\n       dictGetInt16('video','isRed',tuple(toString(video_id))) AS isRed,\r\n       sentiment\r\n  FROM comments_basic ANY\r\n INNER JOIN comments_sentiment USING uuid\r\n```\r\n\r\nTable 1 (comments_basic)\r\nRows: ~\u00a01 403m\r\n```sql\r\nCREATE MATERIALIZED VIEW yt.comments_basic ( uuid FixedString(36),  date Date,  video_id FixedString(33),  likeCount UInt16) ENGINE = MergeTree(date, (uuid, date), 8192) AS SELECT toFixedString(UUIDNumToString(id), 36) AS uuid, date, video_id, likeCount FROM yt.comments\r\n```\r\n\r\nTable 2 (comments_sentiment)\r\nRows: ~780m \r\n```sql\r\nCREATE MATERIALIZED VIEW yt.comments_sentiment ( const_date Date,  uuid FixedString(36),  sentiment Int16) ENGINE = MergeTree(const_date, (uuid, const_date), 8192) AS SELECT toDate(now()) AS const_date, uuid, if(sentiment = '__label__pos', 1, if(sentiment = '__label__neg', -1, 0)) AS sentiment FROM yt.comments_sentiment_raw\r\n```\r\n\r\nBut got an unexpected (but reproducible) result. Interesting fact: I was already able to run it successfully, but just changed the name of field `const_date` from `date` to `const_date`, because I wanted to pick the date value of table `comments_basic` and it from the other table otherwise.\r\n```log\r\n2017.08.20 10:33:41.608772 [ 571 ] <Error> BaseDaemon: ########################################\r\n2017.08.20 10:33:41.608878 [ 571 ] <Error> BaseDaemon: (from thread 7) Received signal Segmentation fault (11).\r\n2017.08.20 10:33:41.608900 [ 571 ] <Error> BaseDaemon: Address: 0xf8\r\n2017.08.20 10:33:41.678843 [ 571 ] <Error> BaseDaemon: 0. clickhouse-server(DB::LogBlockOutputStream::writeData(std::string const&, DB::IDataType const&, DB::IColumn const&, std::vector<std::pair<unsigned long, DB::Mark>, std::allocator<std::pair<unsigned long, DB::Mark> > >&, std::vector<std::pair<unsigned long, DB::Mark>, std::allocator<std::pair<unsigned long, DB::Mark> > >&, std::set<std::string, std::less<std::string>, std::allocator<std::string> >&, unsigned long)+0x505) [0x2a87965]\r\n2017.08.20 10:33:41.678873 [ 571 ] <Error> BaseDaemon: 1. clickhouse-server(DB::LogBlockOutputStream::write(DB::Block const&)+0x120) [0x2a881e0]\r\n2017.08.20 10:33:41.678891 [ 571 ] <Error> BaseDaemon: 2. clickhouse-server(DB::PushingToViewsBlockOutputStream::write(DB::Block const&)+0x445) [0x2907f55]\r\n2017.08.20 10:33:41.678910 [ 571 ] <Error> BaseDaemon: 3. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x91) [0x2cf5f51]\r\n2017.08.20 10:33:41.678927 [ 571 ] <Error> BaseDaemon: 4. clickhouse-server(DB::PushingToViewsBlockOutputStream::write(DB::Block const&)+0x3f1) [0x2907f01]\r\n2017.08.20 10:33:41.678943 [ 571 ] <Error> BaseDaemon: 5. clickhouse-server(DB::MaterializingBlockOutputStream::write(DB::Block const&)+0x28) [0x2905728]\r\n2017.08.20 10:33:41.678958 [ 571 ] <Error> BaseDaemon: 6. clickhouse-server(DB::AddingDefaultBlockOutputStream::write(DB::Block const&)+0x235) [0x2c1ab25]\r\n2017.08.20 10:33:41.678974 [ 571 ] <Error> BaseDaemon: 7. clickhouse-server(DB::ProhibitColumnsBlockOutputStream::write(DB::Block const&)+0x4f) [0x2cbf22f]\r\n2017.08.20 10:33:41.678991 [ 571 ] <Error> BaseDaemon: 8. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x91) [0x2cf5f51]\r\n2017.08.20 10:33:41.679008 [ 571 ] <Error> BaseDaemon: 9. clickhouse-server(DB::NullAndDoCopyBlockInputStream::readImpl()+0x24) [0x2903e34]\r\n2017.08.20 10:33:41.679023 [ 571 ] <Error> BaseDaemon: 10. clickhouse-server(DB::IProfilingBlockInputStream::read()+0x1e6) [0x22f9216]\r\n2017.08.20 10:33:41.679053 [ 571 ] <Error> BaseDaemon: 11. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x5c) [0x2cf5f1c]\r\n2017.08.20 10:33:41.679076 [ 571 ] <Error> BaseDaemon: 12. clickhouse-server(DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::string const&)>)+0x58b) [0x29a5a6b]\r\n2017.08.20 10:33:41.679096 [ 571 ] <Error> BaseDaemon: 13. clickhouse-server(DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&)+0x1e19) [0x1014449]\r\n2017.08.20 10:33:41.679130 [ 571 ] <Error> BaseDaemon: 14. clickhouse-server(DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&)+0x336) [0x10166e6]\r\n2017.08.20 10:33:41.679146 [ 571 ] <Error> BaseDaemon: 15. clickhouse-server(Poco::Net::HTTPServerConnection::run()+0x253) [0x32054d3]\r\n2017.08.20 10:33:41.679161 [ 571 ] <Error> BaseDaemon: 16. clickhouse-server(Poco::Net::TCPServerConnection::start()+0xf) [0x31feb5f]\r\n2017.08.20 10:33:41.679176 [ 571 ] <Error> BaseDaemon: 17. clickhouse-server(Poco::Net::TCPServerDispatcher::run()+0x10b) [0x320036b]\r\n2017.08.20 10:33:41.679192 [ 571 ] <Error> BaseDaemon: 18. clickhouse-server(Poco::PooledThread::run()+0x87) [0x3306737]\r\n2017.08.20 10:33:41.679207 [ 571 ] <Error> BaseDaemon: 19. clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x96) [0x33012c6]\r\n2017.08.20 10:33:41.679220 [ 571 ] <Error> BaseDaemon: 20. /lib64/libpthread.so.0(+0x7dc5) [0x7ff3b6f8fdc5]\r\n```\r\n\r\n**EDIT**: I just rewrote it to use dictionaries instead of joins (it is a complex hashed external dict with the table as source)\r\n\r\n```sql\r\nCREATE TABLE comments_videos ENGINE=MergeTree(date,(video_id, date), 8192) AS SELECT video_id,\r\n       date,\r\n       dictGetString('video','channel_id',tuple(toString(video_id))) AS channel_id,\r\n       dictGetInt16('video','isRed',tuple(toString(video_id))) AS isRed,\r\n       dictGetInt16('comments_sentiment', 'sentiment', tuple(toString(uuid))) AS sentiment\r\n  FROM comments_basic\r\n```\r\n\r\n And I get a similar same exception:\r\n\r\n```\r\n2017.08.20 11:25:48.312103 [ 25 ] <Error> BaseDaemon: (from thread 24) Received signal Segmentation fault (11).\r\n2017.08.20 11:25:48.312142 [ 25 ] <Error> BaseDaemon: Address: 0xf8\r\n2017.08.20 11:25:48.366136 [ 25 ] <Error> BaseDaemon: 0. clickhouse-server(DB::LogBlockOutputStream::writeData(std::string const&, DB::IDataType const&, DB::IColumn const&, std::vector<std::pair<unsigned long, DB::Mark>, std::allocator<std::pair<unsigned long, DB::Mark> > >&, std::vector<std::pair<unsigned long, DB::Mark>, std::allocator<std::pair<unsigned long, DB::Mark> > >&, std::set<std::string, std::less<std::string>, std::allocator<std::string> >&, unsigned long)+0x505) [0x2a87965]\r\n2017.08.20 11:25:48.366194 [ 25 ] <Error> BaseDaemon: 1. clickhouse-server(DB::LogBlockOutputStream::write(DB::Block const&)+0x120) [0x2a881e0]\r\n2017.08.20 11:25:48.366211 [ 25 ] <Error> BaseDaemon: 2. clickhouse-server(DB::PushingToViewsBlockOutputStream::write(DB::Block const&)+0x445) [0x2907f55]\r\n2017.08.20 11:25:48.366229 [ 25 ] <Error> BaseDaemon: 3. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x91) [0x2cf5f51]\r\n2017.08.20 11:25:48.366245 [ 25 ] <Error> BaseDaemon: 4. clickhouse-server(DB::PushingToViewsBlockOutputStream::write(DB::Block const&)+0x3f1) [0x2907f01]\r\n2017.08.20 11:25:48.366260 [ 25 ] <Error> BaseDaemon: 5. clickhouse-server(DB::MaterializingBlockOutputStream::write(DB::Block const&)+0x28) [0x2905728]\r\n2017.08.20 11:25:48.366275 [ 25 ] <Error> BaseDaemon: 6. clickhouse-server(DB::AddingDefaultBlockOutputStream::write(DB::Block const&)+0x235) [0x2c1ab25]\r\n2017.08.20 11:25:48.366290 [ 25 ] <Error> BaseDaemon: 7. clickhouse-server(DB::ProhibitColumnsBlockOutputStream::write(DB::Block const&)+0x4f) [0x2cbf22f]\r\n2017.08.20 11:25:48.366307 [ 25 ] <Error> BaseDaemon: 8. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x91) [0x2cf5f51]\r\n2017.08.20 11:25:48.366323 [ 25 ] <Error> BaseDaemon: 9. clickhouse-server(DB::NullAndDoCopyBlockInputStream::readImpl()+0x24) [0x2903e34]\r\n2017.08.20 11:25:48.366337 [ 25 ] <Error> BaseDaemon: 10. clickhouse-server(DB::IProfilingBlockInputStream::read()+0x1e6) [0x22f9216]\r\n2017.08.20 11:25:48.366362 [ 25 ] <Error> BaseDaemon: 11. clickhouse-server(DB::copyData(DB::IBlockInputStream&, DB::IBlockOutputStream&, std::atomic<bool>*)+0x5c) [0x2cf5f1c]\r\n2017.08.20 11:25:48.366384 [ 25 ] <Error> BaseDaemon: 12. clickhouse-server(DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, DB::Context&, std::function<void (std::string const&)>)+0x58b) [0x29a5a6b]\r\n2017.08.20 11:25:48.366403 [ 25 ] <Error> BaseDaemon: 13. clickhouse-server(DB::HTTPHandler::processQuery(Poco::Net::HTTPServerRequest&, HTMLForm&, Poco::Net::HTTPServerResponse&, DB::HTTPHandler::Output&)+0x1e19) [0x1014449]\r\n2017.08.20 11:25:48.366418 [ 25 ] <Error> BaseDaemon: 14. clickhouse-server(DB::HTTPHandler::handleRequest(Poco::Net::HTTPServerRequest&, Poco::Net::HTTPServerResponse&)+0x336) [0x10166e6]\r\n2017.08.20 11:25:48.366433 [ 25 ] <Error> BaseDaemon: 15. clickhouse-server(Poco::Net::HTTPServerConnection::run()+0x253) [0x32054d3]\r\n2017.08.20 11:25:48.366447 [ 25 ] <Error> BaseDaemon: 16. clickhouse-server(Poco::Net::TCPServerConnection::start()+0xf) [0x31feb5f]\r\n2017.08.20 11:25:48.366461 [ 25 ] <Error> BaseDaemon: 17. clickhouse-server(Poco::Net::TCPServerDispatcher::run()+0x10b) [0x320036b]\r\n2017.08.20 11:25:48.366477 [ 25 ] <Error> BaseDaemon: 18. clickhouse-server(Poco::PooledThread::run()+0x87) [0x3306737]\r\n2017.08.20 11:25:48.366491 [ 25 ] <Error> BaseDaemon: 19. clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x96) [0x33012c6]\r\n2017.08.20 11:25:48.366503 [ 25 ] <Error> BaseDaemon: 20. /lib64/libpthread.so.0(+0x7dc5) [0x7f560c75cdc5]\r\n```\r\n\n'clickhouse client' in addition to 'clickhouse --client'\n\n",
  "hints_text": "ok, now I know why this happens. I already had the same problem (replacing/re-creating a materialised  view on which another view is based does not work) #1112 ... In this former bug report @ludv1x mentioned that it is similar to #598, which is already closed. But it is just related and the \"you have to add a engine\"-constraint does not resolve this problem.\r\n\r\nA simple workaround is to delete the view which is based on the \"new\" (in my case I had to delete all views based on `comments_videos`) one and recreate it. But it would be important to add some warning/error to provide some feedback.\n> A simple workaround is to delete the view which is based on the \"new\" (in my case I had to delete all views based on comments_videos) one and recreate it. \r\n\r\nHelp me reproduce the problem.\r\nHad you had any ordinary (or MATERIALIZED) VIEWs making SELECTs from `comments_videos` before you (re)created `comments_videos`?\r\nIf so, could you provide their `SHOW CREATE TABLE`?\nJust MATERIALIZED VIEWs and yes I executed some SELECTs before. I already posted the show create table output in the first post or do you need it from the original tables as well?\n@inkrement yep, step-by-step instruction on how to reproduce it would be nice.\n@blinkov I am afraid that I can not reproduce the data or the exact setting :/ ... Thus, I'll close the issue for now and reopen it if I run into it again.\nNote that it should be merged with test env. PR https://nda.ya.ru/3TRcsG\r\nOtherwise, tests are not passed.",
  "created_at": "2022-10-19T22:31:45Z"
}