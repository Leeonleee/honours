{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40620,
  "instance_id": "ClickHouse__ClickHouse-40620",
  "issue_numbers": [
    "40536",
    "40587"
  ],
  "base_commit": "7d1e3ecfa35edf23bae83081b4385f994697b6ab",
  "patch": "diff --git a/src/Common/base58.h b/src/Common/base58.h\nindex 3d4b55a1fba8..bc3c3c7aee88 100644\n--- a/src/Common/base58.h\n+++ b/src/Common/base58.h\n@@ -5,12 +5,22 @@\n namespace DB\n {\n \n-inline size_t encodeBase58(const char8_t * src, char8_t * dst)\n+inline size_t encodeBase58(const char8_t * src, size_t srclen, char8_t * dst)\n {\n     const char * base58_encoding_alphabet = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n \n+    size_t processed = 0;\n+    size_t zeros = 0;\n+    for (;*src == '\\0' && processed < srclen-1; ++src)\n+    {\n+        ++processed;\n+        ++zeros;\n+        *dst++ = '1';\n+    }\n+\n     size_t idx = 0;\n-    for (; *src; ++src)\n+\n+    while (processed < srclen-1)\n     {\n         unsigned int carry = static_cast<unsigned char>(*src);\n         for (size_t j = 0; j < idx; ++j)\n@@ -24,6 +34,8 @@ inline size_t encodeBase58(const char8_t * src, char8_t * dst)\n             dst[idx++] = static_cast<unsigned char>(carry % 58);\n             carry /= 58;\n         }\n+        ++src;\n+        ++processed;\n     }\n \n     size_t c_idx = idx >> 1;\n@@ -37,23 +49,38 @@ inline size_t encodeBase58(const char8_t * src, char8_t * dst)\n     {\n         dst[c_idx] = base58_encoding_alphabet[static_cast<unsigned char>(dst[c_idx])];\n     }\n+\n     dst[idx] = '\\0';\n-    return idx + 1;\n+    return zeros + idx + 1;\n }\n \n-inline size_t decodeBase58(const char8_t * src, char8_t * dst)\n+inline size_t decodeBase58(const char8_t * src, size_t srclen, char8_t * dst)\n {\n     const signed char uint_max = UINT_MAX;\n     const signed char map_digits[128]\n         = {uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max,\n            uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max,\n            uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max,\n-           uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, 0,  1,  2,  3,  4,  5,  6,  7,  8,        uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, 9,  10, 11, 12, 13, 14, 15, 16,       uint_max, 17, 18, 19, 20, 21,       uint_max, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32,\n-           uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43,       uint_max, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57,       uint_max, uint_max, uint_max, uint_max, uint_max};\n+           uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, 0,        1,        2,\n+           3,        4,        5,        6,        7,        8,        uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, uint_max,\n+           9,        10,       11,       12,       13,       14,       15,       16,       uint_max, 17,       18,       19,       20,\n+           21,       uint_max, 22,       23,       24,       25,       26,       27,       28,       29,       30,       31,       32,\n+           uint_max, uint_max, uint_max, uint_max, uint_max, uint_max, 33,       34,       35,       36,       37,       38,       39,\n+           40,       41,       42,       43,       uint_max, 44,       45,       46,       47,       48,       49,       50,       51,\n+           52,       53,       54,       55,       56,       57,       uint_max, uint_max, uint_max, uint_max, uint_max};\n+\n+    size_t processed = 0;\n+    size_t zeros = 0;\n+    for (;*src == '1' && processed < srclen-1; ++src)\n+    {\n+        ++processed;\n+        ++zeros;\n+        *dst++ = '\\0';\n+    }\n \n     size_t idx = 0;\n \n-    for (; *src; ++src)\n+    while (processed < srclen-1)\n     {\n         unsigned int carry = map_digits[*src];\n         if (unlikely(carry == UINT_MAX))\n@@ -71,6 +98,8 @@ inline size_t decodeBase58(const char8_t * src, char8_t * dst)\n             dst[idx++] = static_cast<unsigned char>(carry & 0xff);\n             carry >>= 8;\n         }\n+        ++src;\n+        ++processed;\n     }\n \n     size_t c_idx = idx >> 1;\n@@ -81,7 +110,7 @@ inline size_t decodeBase58(const char8_t * src, char8_t * dst)\n         dst[idx - (i + 1)] = s;\n     }\n     dst[idx] = '\\0';\n-    return idx + 1;\n+    return zeros + idx + 1;\n }\n \n }\ndiff --git a/src/Functions/FunctionBase58Conversion.h b/src/Functions/FunctionBase58Conversion.h\nindex 82e2a2caac04..bc166f2c9f5a 100644\n--- a/src/Functions/FunctionBase58Conversion.h\n+++ b/src/Functions/FunctionBase58Conversion.h\n@@ -48,7 +48,7 @@ struct Base58Encode\n         for (size_t row = 0; row < input_rows_count; ++row)\n         {\n             size_t srclen = src_offsets[row] - src_offset_prev;\n-            auto encoded_size = encodeBase58(src, dst_pos);\n+            auto encoded_size = encodeBase58(src, srclen, dst_pos);\n \n             src += srclen;\n             dst_pos += encoded_size;\n@@ -90,7 +90,7 @@ struct Base58Decode\n         {\n             size_t srclen = src_offsets[row] - src_offset_prev;\n \n-            auto decoded_size = decodeBase58(src, dst_pos);\n+            auto decoded_size = decodeBase58(src, srclen, dst_pos);\n             if (!decoded_size)\n                 throw Exception(\"Invalid Base58 value, cannot be decoded\", ErrorCodes::BAD_ARGUMENTS);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02337_base58.reference b/tests/queries/0_stateless/02337_base58.reference\nindex bc666044388f..20b9124c1502 100644\n--- a/tests/queries/0_stateless/02337_base58.reference\n+++ b/tests/queries/0_stateless/02337_base58.reference\n@@ -21,3 +21,6 @@ foo\n foob\n fooba\n foobar\n+\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02337_base58.sql b/tests/queries/0_stateless/02337_base58.sql\nindex 9c9379a2854f..42b032c7601b 100644\n--- a/tests/queries/0_stateless/02337_base58.sql\n+++ b/tests/queries/0_stateless/02337_base58.sql\n@@ -9,4 +9,7 @@ SELECT base58Decode('Hold my beer...'); -- { serverError 36 }\n SELECT base58Decode(encoded) FROM (SELECT base58Encode(val) as encoded FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar', 'Hello world!']) val));\n \n SELECT base58Encode(val) FROM (select arrayJoin(['', 'f', 'fo', 'foo', 'foob', 'fooba', 'foobar']) val);\n-SELECT base58Decode(val) FROM (select arrayJoin(['', '2m', '8o8', 'bQbp', '3csAg9', 'CZJRhmz', 't1Zv2yaZ']) val);\n+SELECT base58Decode(val) FROM (select arrayJoin(['', '2m', '8o8', 'bQbp', '3csAg9', 'CZJRhmz', 't1Zv2yaZ', '']) val);\n+\n+SELECT base58Encode(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')) == '1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix';\n+select base58Encode('\\x00\\x0b\\xe3\\xe1\\xeb\\xa1\\x7a\\x47\\x3f\\x89\\xb0\\xf7\\xe8\\xe2\\x49\\x40\\xf2\\x0a\\xeb\\x8e\\xbc\\xa7\\x1a\\x88\\xfd\\xe9\\x5d\\x4b\\x83\\xb7\\x1a\\x09') == '1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix';\n",
  "problem_statement": "base58Decode produces incorrect output\nIt looks like ClickHouse's base58Decode function works incorrectly.\r\n\r\nFor example, base58-encoded value `1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix` should be decoded to a 32 byte array. Here is an example from python which works correctly:\r\n\r\n```\r\n$ python3 -m venv ~/.venv/base58\r\n$ ~/.venv/base58/bin/pip install base58\r\n$ ~/.venv/base58/bin/python3\r\n>>> import base58\r\n>>> base58.b58decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')\r\nb'\\x00\\x0b\\xe3\\xe1\\xeb\\xa1zG?\\x89\\xb0\\xf7\\xe8\\xe2I@\\xf2\\n\\xeb\\x8e\\xbc\\xa7\\x1a\\x88\\xfd\\xe9]K\\x83\\xb7\\x1a\\t'\r\n>>> len(base58.b58decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix'))\r\n32\r\n>>> base58.b58decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix').hex()\r\n'000be3e1eba17a473f89b0f7e8e24940f20aeb8ebca71a88fde95d4b83b71a09'\r\n```\r\n\r\nClickhouse produces incorrect, 31 byte string (notice that the leading NULL byte is missing):\r\n\r\n```\r\n:) SELECT length(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')) FORMAT Vertical;\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nlength(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')): 31\r\n\r\n:) select hex(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')) format Vertical;\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nhex(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')): 0BE3E1EBA17A473F89B0F7E8E24940F20AEB8EBCA71A88FDE95D4B83B71A09\r\n\r\n```\r\n\r\nand decode/encode pair does not produce original value:\r\n\r\n```\r\n:) SELECT base58Encode(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')) FORMAT Vertical;\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nbase58Encode(base58Decode('1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix')): BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix\r\n```\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes. The bug was reproduced on:\r\n\r\n```\r\n:) select version() format Vertical;\r\n\r\nRow 1:\r\n\u2500\u2500\u2500\u2500\u2500\u2500\r\nversion(): 22.8.1.2097\r\n```\r\n\r\n**How to reproduce**\r\n\r\nSee above.\r\n\r\n**Expected behavior**\r\n\r\n* base58Decode should produce correct output\r\n* base58Decode/base58Encode pair should return original value\nbase58Encode does not work correctly if a string starts with null byte\n`base58Encode` does not encode the data correctly. Compare output from `base58Encode` to the one from `hex`:\r\n\r\n```\r\n:) select base58Encode('\\x00\\x0b\\xe3\\xe1\\xeb\\xa1\\x7a\\x47\\x3f\\x89\\xb0\\xf7\\xe8\\xe2\\x49\\x40\\xf2\\x0a\\xeb\\x8e\\xbc\\xa7\\x1a\\x88\\xfd\\xe9\\x5d\\x4b\\x83\\xb7\\x1a\\x09') as encoded_data format JSONEachRow;\r\n\r\n{\"encoded_data\":\"\"}\r\n\r\n1 row in set. Elapsed: 0.002 sec.\r\n\r\n:) select hex('\\x00\\x0b\\xe3\\xe1\\xeb\\xa1\\x7a\\x47\\x3f\\x89\\xb0\\xf7\\xe8\\xe2\\x49\\x40\\xf2\\x0a\\xeb\\x8e\\xbc\\xa7\\x1a\\x88\\xfd\\xe9\\x5d\\x4b\\x83\\xb7\\x1a\\x09') as encoded_data format JSONEachRow;\r\n\r\n{\"encoded_data\":\"000BE3E1EBA17A473F89B0F7E8E24940F20AEB8EBCA71A88FDE95D4B83B71A09\"}\r\n\r\n1 row in set. Elapsed: 0.002 sec.\r\n```\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes. Reproduced on ClickHouse version `22.8.1.2097`.\r\n\r\n**Expected behavior**\r\n\r\nPython encodes the data as follows:\r\n\r\n```\r\n$ python3 -m venv ~/.venv/base58\r\n$ ~/.venv/base58/bin/pip install base58\r\n$ ~/.venv/base58/bin/python3\r\n>>> import base58\r\n>>> data = b'\\x00\\x0b\\xe3\\xe1\\xeb\\xa1\\x7a\\x47\\x3f\\x89\\xb0\\xf7\\xe8\\xe2\\x49\\x40\\xf2\\x0a\\xeb\\x8e\\xbc\\xa7\\x1a\\x88\\xfd\\xe9\\x5d\\x4b\\x83\\xb7\\x1a\\x09';\r\n>>> len(data)\r\n32\r\n>>> base58.b58encode(data)\r\nb'1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix'\r\n>>> len(base58.b58encode(data))\r\n43\r\n```\r\n\r\nso I expected base58Encode call to return '1BWutmTvYPwDtmw9abTkS4Ssr8no61spGAvW1X6NDix'.\r\n\r\nNote: I am not sure, but the issue might have the same root cause as the one from https://github.com/ClickHouse/ClickHouse/issues/40536.\r\n\r\nThank you.\n",
  "hints_text": "The encode/decode query should be like SELECT base64Decode(base64Encode(..)), and I think the result is correct. But the result of base64Decode is indeed different from other implementations (missing \\0 at the beginning in some case)\n@zvonand Maybe you want to have a first look (--> https://github.com/ClickHouse/ClickHouse/pull/39292)?\nWill fix\n",
  "created_at": "2022-08-25T12:38:56Z",
  "modified_files": [
    "src/Common/base58.h",
    "src/Functions/FunctionBase58Conversion.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02337_base58.reference",
    "tests/queries/0_stateless/02337_base58.sql"
  ]
}