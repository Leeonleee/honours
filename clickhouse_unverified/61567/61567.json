{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61567,
  "instance_id": "ClickHouse__ClickHouse-61567",
  "issue_numbers": [
    "61531"
  ],
  "base_commit": "ede245e478e78aff7463db1d7c722a39ab6ad8b8",
  "patch": "diff --git a/src/Analyzer/ConstantNode.h b/src/Analyzer/ConstantNode.h\nindex b065853e3150..98a8eb782776 100644\n--- a/src/Analyzer/ConstantNode.h\n+++ b/src/Analyzer/ConstantNode.h\n@@ -4,6 +4,7 @@\n \n #include <Analyzer/IQueryTreeNode.h>\n #include <Analyzer/ConstantValue.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n namespace DB\n {\n@@ -86,6 +87,11 @@ class ConstantNode final : public IQueryTreeNode\n         mask_id = id;\n     }\n \n+    void convertToNullable() override\n+    {\n+        constant_value = std::make_shared<ConstantValue>(constant_value->getValue(), makeNullableSafe(constant_value->getType()));\n+    }\n+\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\ndiff --git a/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp\nindex d881af3a51b3..fd8c3e6ee6cd 100644\n--- a/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp\n+++ b/src/Analyzer/Passes/OptimizeGroupByFunctionKeysPass.cpp\n@@ -31,6 +31,12 @@ class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitorWithCon\n         if (!getSettings().optimize_group_by_function_keys)\n             return;\n \n+        /// When group_by_use_nulls = 1 removing keys from GROUP BY can lead\n+        /// to unexpected types in some functions.\n+        /// See example in https://github.com/ClickHouse/ClickHouse/pull/61567#issuecomment-2018007887\n+        if (getSettings().group_by_use_nulls)\n+            return;\n+\n         auto * query = node->as<QueryNode>();\n         if (!query)\n             return;\n@@ -73,12 +79,14 @@ class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitorWithCon\n             candidates.push_back({ *it, is_deterministic });\n \n         /// Using DFS we traverse function tree and try to find if it uses other keys as function arguments.\n+        bool found_at_least_one_usage = false;\n         while (!candidates.empty())\n         {\n             auto [candidate, parents_are_only_deterministic] = candidates.back();\n             candidates.pop_back();\n \n             bool found = group_by_keys.contains(candidate);\n+            found_at_least_one_usage |= found;\n \n             switch (candidate->getNodeType())\n             {\n@@ -111,7 +119,7 @@ class OptimizeGroupByFunctionKeysVisitor : public InDepthQueryTreeVisitorWithCon\n             }\n         }\n \n-        return true;\n+        return found_at_least_one_usage;\n     }\n \n     static void optimizeGroupingSet(QueryTreeNodes & grouping_set)\ndiff --git a/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp b/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp\nindex ad649834fb04..618932025253 100644\n--- a/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp\n+++ b/src/Analyzer/Passes/OptimizeGroupByInjectiveFunctionsPass.cpp\n@@ -43,6 +43,13 @@ class OptimizeGroupByInjectiveFunctionsVisitor : public InDepthQueryTreeVisitorW\n         if (!getSettings().optimize_injective_functions_in_group_by)\n             return;\n \n+        /// Don't optimize injective functions when group_by_use_nulls=true,\n+        /// because in this case we make initial group by keys Nullable\n+        /// and eliminating some functions can cause issues with arguments Nullability\n+        /// during their execution. See examples in https://github.com/ClickHouse/ClickHouse/pull/61567#issuecomment-2008181143\n+        if (getSettings().group_by_use_nulls)\n+            return;\n+\n         auto * query = node->as<QueryNode>();\n         if (!query)\n             return;\ndiff --git a/src/Functions/materialize.h b/src/Functions/materialize.h\nindex 73bfdec48abf..41994509745b 100644\n--- a/src/Functions/materialize.h\n+++ b/src/Functions/materialize.h\n@@ -36,6 +36,8 @@ class FunctionMaterialize : public IFunction\n \n     bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n \n+    bool isSuitableForConstantFolding() const override { return false; }\n+\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n     size_t getNumberOfArguments() const override\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02516_projections_and_context.reference b/tests/queries/0_stateless/02516_projections_and_context.reference\nindex 6ed281c757a9..e69de29bb2d1 100644\n--- a/tests/queries/0_stateless/02516_projections_and_context.reference\n+++ b/tests/queries/0_stateless/02516_projections_and_context.reference\n@@ -1,2 +0,0 @@\n-1\n-1\ndiff --git a/tests/queries/0_stateless/02516_projections_and_context.sql b/tests/queries/0_stateless/02516_projections_and_context.sql\nindex 2b659eafabc8..334544eb4fa0 100644\n--- a/tests/queries/0_stateless/02516_projections_and_context.sql\n+++ b/tests/queries/0_stateless/02516_projections_and_context.sql\n@@ -5,6 +5,6 @@ set allow_experimental_analyzer = 0;\n SELECT count() FROM test1__fuzz_37 GROUP BY dictHas(NULL, (dictHas(NULL, (('', materialize(NULL)), materialize(NULL))), 'KeyKey')), dictHas('test_dictionary', tuple(materialize('Ke\\0'))), tuple(dictHas(NULL, (tuple('Ke\\0Ke\\0Ke\\0Ke\\0Ke\\0Ke\\0\\0\\0\\0Ke\\0'), materialize(NULL)))), 'test_dicti\\0nary', (('', materialize(NULL)), dictHas(NULL, (dictHas(NULL, tuple(materialize(NULL))), 'KeyKeyKeyKeyKeyKeyKeyKey')), materialize(NULL)); -- { serverError BAD_ARGUMENTS }\n SELECT count() FROM test1__fuzz_37 GROUP BY dictHas('non_existing_dictionary', materialize('a')); -- { serverError BAD_ARGUMENTS }\n set allow_experimental_analyzer = 1;\n-SELECT count() FROM test1__fuzz_37 GROUP BY dictHas(NULL, (dictHas(NULL, (('', materialize(NULL)), materialize(NULL))), 'KeyKey')), dictHas('test_dictionary', tuple(materialize('Ke\\0'))), tuple(dictHas(NULL, (tuple('Ke\\0Ke\\0Ke\\0Ke\\0Ke\\0Ke\\0\\0\\0\\0Ke\\0'), materialize(NULL)))), 'test_dicti\\0nary', (('', materialize(NULL)), dictHas(NULL, (dictHas(NULL, tuple(materialize(NULL))), 'KeyKeyKeyKeyKeyKeyKeyKey')), materialize(NULL));\n-SELECT count() FROM test1__fuzz_37 GROUP BY dictHas('non_existing_dictionary', materialize('a'));\n+SELECT count() FROM test1__fuzz_37 GROUP BY dictHas(NULL, (dictHas(NULL, (('', materialize(NULL)), materialize(NULL))), 'KeyKey')), dictHas('test_dictionary', tuple(materialize('Ke\\0'))), tuple(dictHas(NULL, (tuple('Ke\\0Ke\\0Ke\\0Ke\\0Ke\\0Ke\\0\\0\\0\\0Ke\\0'), materialize(NULL)))), 'test_dicti\\0nary', (('', materialize(NULL)), dictHas(NULL, (dictHas(NULL, tuple(materialize(NULL))), 'KeyKeyKeyKeyKeyKeyKeyKey')), materialize(NULL)); -- { serverError BAD_ARGUMENTS }\n+SELECT count() FROM test1__fuzz_37 GROUP BY dictHas('non_existing_dictionary', materialize('a')); -- { serverError BAD_ARGUMENTS }\n DROP TABLE test1__fuzz_37;\ndiff --git a/tests/queries/0_stateless/03013_group_by_use_nulls_with_materialize_and_analyzer.reference b/tests/queries/0_stateless/03013_group_by_use_nulls_with_materialize_and_analyzer.reference\nnew file mode 100644\nindex 000000000000..2c9c098cea04\n--- /dev/null\n+++ b/tests/queries/0_stateless/03013_group_by_use_nulls_with_materialize_and_analyzer.reference\n@@ -0,0 +1,10 @@\n+6\n+6\n+3\n+\\N\n+0\n+\\N\n+0\n+\\N\n+0\n+\\N\ndiff --git a/tests/queries/0_stateless/03013_group_by_use_nulls_with_materialize_and_analyzer.sql b/tests/queries/0_stateless/03013_group_by_use_nulls_with_materialize_and_analyzer.sql\nnew file mode 100644\nindex 000000000000..b15593b2abd8\n--- /dev/null\n+++ b/tests/queries/0_stateless/03013_group_by_use_nulls_with_materialize_and_analyzer.sql\n@@ -0,0 +1,11 @@\n+set allow_experimental_analyzer = 1;\n+set group_by_use_nulls = 1;\n+set optimize_group_by_function_keys = 1;\n+set optimize_injective_functions_in_group_by = 1;\n+\n+SELECT 3 + 3 from numbers(10) GROUP BY GROUPING SETS (('str'), (3 + 3)) order by all;\n+SELECT materialize(3) from numbers(10) GROUP BY GROUPING SETS (('str'), (materialize(3))) order by all;\n+SELECT ignore(3) from numbers(10) GROUP BY GROUPING SETS (('str'), (ignore(3))) order by all;\n+SELECT materialize(ignore(3)) from numbers(10) GROUP BY GROUPING SETS (('str'), (materialize(ignore(3)))) order by all;\n+SELECT ignore(materialize(3)) from numbers(10) GROUP BY GROUPING SETS (('str'), (ignore(materialize(3)))) order by all;\n+\ndiff --git a/tests/queries/0_stateless/03014_group_by_use_nulls_injective_functions_and_analyzer.reference b/tests/queries/0_stateless/03014_group_by_use_nulls_injective_functions_and_analyzer.reference\nnew file mode 100644\nindex 000000000000..e90d21df61ff\n--- /dev/null\n+++ b/tests/queries/0_stateless/03014_group_by_use_nulls_injective_functions_and_analyzer.reference\n@@ -0,0 +1,24 @@\n+3\n+4\n+5\n+6\n+7\n+8\n+9\n+10\n+11\n+12\n+\\N\n+(((0)))\n+(((0)))\n+(((1)))\n+(((2)))\n+(((3)))\n+(((4)))\n+(((5)))\n+(((6)))\n+(((7)))\n+(((8)))\n+(((9)))\n+6\n+6\ndiff --git a/tests/queries/0_stateless/03014_group_by_use_nulls_injective_functions_and_analyzer.sql b/tests/queries/0_stateless/03014_group_by_use_nulls_injective_functions_and_analyzer.sql\nnew file mode 100644\nindex 000000000000..e7ea964b8768\n--- /dev/null\n+++ b/tests/queries/0_stateless/03014_group_by_use_nulls_injective_functions_and_analyzer.sql\n@@ -0,0 +1,5 @@\n+set allow_experimental_analyzer=1, group_by_use_nulls=1, optimize_injective_functions_in_group_by=1;\n+SELECT bitNot(bitNot(number)) + 3 FROM numbers(10) GROUP BY GROUPING SETS (('str', bitNot(bitNot(number))), ('str')) order by all;\n+SELECT tuple(tuple(tuple(number))) FROM numbers(10) GROUP BY GROUPING SETS (('str', tuple(tuple(number))), ('str')) order by all;\n+SELECT materialize(3) + 3 FROM numbers(10) GROUP BY GROUPING SETS (('str', materialize(materialize(3))), ('str')) order by all;\n+\ndiff --git a/tests/queries/0_stateless/03023_analyzer_optimize_group_by_function_keys_with_nulls.reference b/tests/queries/0_stateless/03023_analyzer_optimize_group_by_function_keys_with_nulls.reference\nnew file mode 100644\nindex 000000000000..4521d575ff3e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03023_analyzer_optimize_group_by_function_keys_with_nulls.reference\n@@ -0,0 +1,10 @@\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\ndiff --git a/tests/queries/0_stateless/03023_analyzer_optimize_group_by_function_keys_with_nulls.sql b/tests/queries/0_stateless/03023_analyzer_optimize_group_by_function_keys_with_nulls.sql\nnew file mode 100644\nindex 000000000000..f0b60caca363\n--- /dev/null\n+++ b/tests/queries/0_stateless/03023_analyzer_optimize_group_by_function_keys_with_nulls.sql\n@@ -0,0 +1,5 @@\n+set allow_experimental_analyzer=1;\n+set group_by_use_nulls=1;\n+set optimize_group_by_function_keys=1;\n+SELECT ignore(toLowCardinality(number)) FROM numbers(10) GROUP BY GROUPING SETS ((ignore(toLowCardinality(number)), toLowCardinality(number)));\n+\n",
  "problem_statement": "Logical error \"Expected single dictionary argument for function\" in `materialize(toLowCardinality(...))`\n**Describe what's wrong**\r\n```\r\nSELECT trunc(materialize(toLowCardinality(0)), materialize(toLowCardinality(0)));\r\n\r\nReceived exception from server (version 24.2.2):\r\nCode: 49. DB::Exception: Received from localhost:9000. DB::Exception: Expected single dictionary argument for function.. (LOGICAL_ERROR)\r\n(query: SELECT trunc(materialize(toLowCardinality(0)), materialize(toLowCardinality(0))))\r\n```\r\nhttps://fiddle.clickhouse.com/a91273fc-32a6-4735-92e1-68bf1a6fd00a\r\n\r\n**Does it reproduce on the most recent release?**\r\nyes\r\n\r\n**Expected behavior**\r\nshould not produce LOGICAL_ERROR\r\n\r\n**Additional context**\r\nFound by fuzzer:\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/58223/be4554ba431c2c496c139e6b4869a68ca3ba58dc/ast_fuzzer__ubsan_.html\r\n\n",
  "hints_text": "",
  "created_at": "2024-03-19T10:43:54Z"
}