{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39968,
  "instance_id": "ClickHouse__ClickHouse-39968",
  "issue_numbers": [
    "38070"
  ],
  "base_commit": "ef6ff51b9a05202a1ff13003e3d06c4d21671a77",
  "patch": "diff --git a/src/Common/ProfileEvents.cpp b/src/Common/ProfileEvents.cpp\nindex 453ed9ec37cb..eb144402b527 100644\n--- a/src/Common/ProfileEvents.cpp\n+++ b/src/Common/ProfileEvents.cpp\n@@ -1,7 +1,6 @@\n #include <Common/ProfileEvents.h>\n #include <Common/CurrentThread.h>\n-#include <Common/typeid_cast.h>\n-#include <Columns/ColumnArray.h>\n+\n \n /// Available events. Add something here as you wish.\n #define APPLY_FOR_EVENTS(M) \\\n@@ -450,7 +449,7 @@ void increment(Event event, Count amount)\n CountersIncrement::CountersIncrement(Counters::Snapshot const & snapshot)\n {\n     init();\n-    std::memcpy(increment_holder.get(), snapshot.counters_holder.get(), Counters::num_counters * sizeof(Increment));\n+    memcpy(increment_holder.get(), snapshot.counters_holder.get(), Counters::num_counters * sizeof(Increment));\n }\n \n CountersIncrement::CountersIncrement(Counters::Snapshot const & after, Counters::Snapshot const & before)\ndiff --git a/src/Common/ProgressIndication.cpp b/src/Common/ProgressIndication.cpp\nindex 8ca1612e916f..ab4ecf5c25fb 100644\n--- a/src/Common/ProgressIndication.cpp\n+++ b/src/Common/ProgressIndication.cpp\n@@ -8,7 +8,6 @@\n #include \"Common/formatReadable.h\"\n #include <Common/TerminalSize.h>\n #include <Common/UnicodeBar.h>\n-#include <Common/Stopwatch.h>\n #include \"IO/WriteBufferFromString.h\"\n #include <Databases/DatabaseMemory.h>\n \n@@ -33,6 +32,13 @@ namespace\n namespace DB\n {\n \n+UInt64 ProgressIndication::getElapsedNanoseconds() const\n+{\n+    /// New server versions send server-side elapsed time, which is preferred for calculations.\n+    UInt64 server_elapsed_ns = progress.elapsed_ns.load(std::memory_order_relaxed);\n+    return server_elapsed_ns ? server_elapsed_ns : watch.elapsed();\n+}\n+\n bool ProgressIndication::updateProgress(const Progress & value)\n {\n     return progress.incrementPiecewiseAtomically(value);\n@@ -56,7 +62,7 @@ void ProgressIndication::resetProgress()\n     write_progress_on_update = false;\n     {\n         std::lock_guard lock(profile_events_mutex);\n-        cpu_usage_meter.reset(static_cast<double>(clock_gettime_ns()));\n+        cpu_usage_meter.reset(getElapsedNanoseconds());\n         thread_data.clear();\n     }\n }\n@@ -93,7 +99,7 @@ void ProgressIndication::updateThreadEventData(HostToThreadTimesMap & new_thread\n         total_cpu_ns += aggregateCPUUsageNs(new_host_map.second);\n         thread_data[new_host_map.first] = std::move(new_host_map.second);\n     }\n-    cpu_usage_meter.add(static_cast<double>(clock_gettime_ns()), total_cpu_ns);\n+    cpu_usage_meter.add(getElapsedNanoseconds(), total_cpu_ns);\n }\n \n size_t ProgressIndication::getUsedThreadsCount() const\n@@ -110,7 +116,7 @@ size_t ProgressIndication::getUsedThreadsCount() const\n double ProgressIndication::getCPUUsage()\n {\n     std::lock_guard lock(profile_events_mutex);\n-    return cpu_usage_meter.rate(clock_gettime_ns());\n+    return cpu_usage_meter.rate(getElapsedNanoseconds());\n }\n \n ProgressIndication::MemoryUsage ProgressIndication::getMemoryUsage() const\n@@ -139,7 +145,7 @@ void ProgressIndication::writeFinalProgress()\n     std::cout << \"Processed \" << formatReadableQuantity(progress.read_rows) << \" rows, \"\n                 << formatReadableSizeWithDecimalSuffix(progress.read_bytes);\n \n-    size_t elapsed_ns = watch.elapsed();\n+    UInt64 elapsed_ns = getElapsedNanoseconds();\n     if (elapsed_ns)\n         std::cout << \" (\" << formatReadableQuantity(progress.read_rows * 1000000000.0 / elapsed_ns) << \" rows/s., \"\n                     << formatReadableSizeWithDecimalSuffix(progress.read_bytes * 1000000000.0 / elapsed_ns) << \"/s.)\";\n@@ -185,7 +191,7 @@ void ProgressIndication::writeProgress()\n         << formatReadableQuantity(progress.read_rows) << \" rows, \"\n         << formatReadableSizeWithDecimalSuffix(progress.read_bytes);\n \n-    auto elapsed_ns = watch.elapsed();\n+    UInt64 elapsed_ns = getElapsedNanoseconds();\n     if (elapsed_ns)\n         message << \" (\"\n                 << formatReadableQuantity(progress.read_rows * 1000000000.0 / elapsed_ns) << \" rows/s., \"\ndiff --git a/src/Common/ProgressIndication.h b/src/Common/ProgressIndication.h\nindex 588a31beca72..4f05f41b9d02 100644\n--- a/src/Common/ProgressIndication.h\n+++ b/src/Common/ProgressIndication.h\n@@ -55,7 +55,7 @@ class ProgressIndication\n     void setFileProgressCallback(ContextMutablePtr context, bool write_progress_on_update = false);\n \n     /// How much seconds passed since query execution start.\n-    double elapsedSeconds() const { return watch.elapsedSeconds(); }\n+    double elapsedSeconds() const { return getElapsedNanoseconds() / 1e9; }\n \n     void addThreadIdToList(String const & host, UInt64 thread_id);\n \n@@ -74,6 +74,8 @@ class ProgressIndication\n \n     MemoryUsage getMemoryUsage() const;\n \n+    UInt64 getElapsedNanoseconds() const;\n+\n     /// This flag controls whether to show the progress bar. We start showing it after\n     /// the query has been executing for 0.5 seconds, and is still less than half complete.\n     bool show_progress_bar = false;\n@@ -86,7 +88,7 @@ class ProgressIndication\n     /// This information is stored here.\n     Progress progress;\n \n-    /// Track query execution time.\n+    /// Track query execution time on client.\n     Stopwatch watch;\n \n     bool write_progress_on_update = false;\ndiff --git a/src/Core/ProtocolDefines.h b/src/Core/ProtocolDefines.h\nindex 78585492c8e1..7e6ae4f5f823 100644\n--- a/src/Core/ProtocolDefines.h\n+++ b/src/Core/ProtocolDefines.h\n@@ -52,7 +52,7 @@\n /// NOTE: DBMS_TCP_PROTOCOL_VERSION has nothing common with VERSION_REVISION,\n /// later is just a number for server version (one number instead of commit SHA)\n /// for simplicity (sometimes it may be more convenient in some use cases).\n-#define DBMS_TCP_PROTOCOL_VERSION 54459\n+#define DBMS_TCP_PROTOCOL_VERSION 54460\n \n #define DBMS_MIN_PROTOCOL_VERSION_WITH_INITIAL_QUERY_START_TIME 54449\n \n@@ -65,3 +65,6 @@\n #define DBMS_MIN_PROTOCOL_VERSION_WITH_QUOTA_KEY 54458\n \n #define DBMS_MIN_PROTOCOL_VERSION_WITH_PARAMETERS 54459\n+\n+/// The server will send query elapsed run time in the Progress packet.\n+#define DBMS_MIN_PROTOCOL_VERSION_WITH_SERVER_QUERY_TIME_IN_PROGRESS 54460\ndiff --git a/src/IO/Progress.cpp b/src/IO/Progress.cpp\nindex eb6eb7fe573b..1069803633c8 100644\n--- a/src/IO/Progress.cpp\n+++ b/src/IO/Progress.cpp\n@@ -11,38 +11,34 @@ namespace DB\n {\n void ProgressValues::read(ReadBuffer & in, UInt64 server_revision)\n {\n-    size_t new_read_rows = 0;\n-    size_t new_read_bytes = 0;\n-    size_t new_total_rows_to_read = 0;\n-    size_t new_written_rows = 0;\n-    size_t new_written_bytes = 0;\n-\n-    readVarUInt(new_read_rows, in);\n-    readVarUInt(new_read_bytes, in);\n-    readVarUInt(new_total_rows_to_read, in);\n+    readVarUInt(read_rows, in);\n+    readVarUInt(read_bytes, in);\n+    readVarUInt(total_rows_to_read, in);\n     if (server_revision >= DBMS_MIN_REVISION_WITH_CLIENT_WRITE_INFO)\n     {\n-        readVarUInt(new_written_rows, in);\n-        readVarUInt(new_written_bytes, in);\n+        readVarUInt(written_rows, in);\n+        readVarUInt(written_bytes, in);\n+    }\n+    if (server_revision >= DBMS_MIN_PROTOCOL_VERSION_WITH_SERVER_QUERY_TIME_IN_PROGRESS)\n+    {\n+        readVarUInt(elapsed_ns, in);\n     }\n-\n-    this->read_rows = new_read_rows;\n-    this->read_bytes = new_read_bytes;\n-    this->total_rows_to_read = new_total_rows_to_read;\n-    this->written_rows = new_written_rows;\n-    this->written_bytes = new_written_bytes;\n }\n \n \n void ProgressValues::write(WriteBuffer & out, UInt64 client_revision) const\n {\n-    writeVarUInt(this->read_rows, out);\n-    writeVarUInt(this->read_bytes, out);\n-    writeVarUInt(this->total_rows_to_read, out);\n+    writeVarUInt(read_rows, out);\n+    writeVarUInt(read_bytes, out);\n+    writeVarUInt(total_rows_to_read, out);\n     if (client_revision >= DBMS_MIN_REVISION_WITH_CLIENT_WRITE_INFO)\n     {\n-        writeVarUInt(this->written_rows, out);\n-        writeVarUInt(this->written_bytes, out);\n+        writeVarUInt(written_rows, out);\n+        writeVarUInt(written_bytes, out);\n+    }\n+    if (client_revision >= DBMS_MIN_PROTOCOL_VERSION_WITH_SERVER_QUERY_TIME_IN_PROGRESS)\n+    {\n+        writeVarUInt(elapsed_ns, out);\n     }\n }\n \n@@ -52,19 +48,19 @@ void ProgressValues::writeJSON(WriteBuffer & out) const\n     ///  of 64-bit integers after interpretation by JavaScript.\n \n     writeCString(\"{\\\"read_rows\\\":\\\"\", out);\n-    writeText(this->read_rows, out);\n+    writeText(read_rows, out);\n     writeCString(\"\\\",\\\"read_bytes\\\":\\\"\", out);\n-    writeText(this->read_bytes, out);\n+    writeText(read_bytes, out);\n     writeCString(\"\\\",\\\"written_rows\\\":\\\"\", out);\n-    writeText(this->written_rows, out);\n+    writeText(written_rows, out);\n     writeCString(\"\\\",\\\"written_bytes\\\":\\\"\", out);\n-    writeText(this->written_bytes, out);\n+    writeText(written_bytes, out);\n     writeCString(\"\\\",\\\"total_rows_to_read\\\":\\\"\", out);\n-    writeText(this->total_rows_to_read, out);\n+    writeText(total_rows_to_read, out);\n     writeCString(\"\\\",\\\"result_rows\\\":\\\"\", out);\n-    writeText(this->result_rows, out);\n+    writeText(result_rows, out);\n     writeCString(\"\\\",\\\"result_bytes\\\":\\\"\", out);\n-    writeText(this->result_bytes, out);\n+    writeText(result_bytes, out);\n     writeCString(\"\\\"}\", out);\n }\n \n@@ -82,6 +78,8 @@ bool Progress::incrementPiecewiseAtomically(const Progress & rhs)\n     result_rows += rhs.result_rows;\n     result_bytes += rhs.result_bytes;\n \n+    elapsed_ns += rhs.elapsed_ns;\n+\n     return rhs.read_rows || rhs.written_rows;\n }\n \n@@ -98,6 +96,8 @@ void Progress::reset()\n \n     result_rows = 0;\n     result_bytes = 0;\n+\n+    elapsed_ns = 0;\n }\n \n ProgressValues Progress::getValues() const\n@@ -116,6 +116,8 @@ ProgressValues Progress::getValues() const\n     res.result_rows = result_rows.load(std::memory_order_relaxed);\n     res.result_bytes = result_bytes.load(std::memory_order_relaxed);\n \n+    res.elapsed_ns = elapsed_ns.load(std::memory_order_relaxed);\n+\n     return res;\n }\n \n@@ -135,6 +137,8 @@ ProgressValues Progress::fetchValuesAndResetPiecewiseAtomically()\n     res.result_rows = result_rows.fetch_and(0);\n     res.result_bytes = result_bytes.fetch_and(0);\n \n+    res.elapsed_ns = elapsed_ns.fetch_and(0);\n+\n     return res;\n }\n \n@@ -154,6 +158,8 @@ Progress Progress::fetchAndResetPiecewiseAtomically()\n     res.result_rows = result_rows.fetch_and(0);\n     res.result_bytes = result_bytes.fetch_and(0);\n \n+    res.elapsed_ns = elapsed_ns.fetch_and(0);\n+\n     return res;\n }\n \n@@ -171,6 +177,8 @@ Progress & Progress::operator=(Progress && other) noexcept\n     result_rows = other.result_rows.load(std::memory_order_relaxed);\n     result_bytes = other.result_bytes.load(std::memory_order_relaxed);\n \n+    elapsed_ns = other.elapsed_ns.load(std::memory_order_relaxed);\n+\n     return *this;\n }\n \n@@ -185,6 +193,8 @@ void Progress::read(ReadBuffer & in, UInt64 server_revision)\n \n     written_rows.store(values.written_rows, std::memory_order_relaxed);\n     written_bytes.store(values.written_bytes, std::memory_order_relaxed);\n+\n+    elapsed_ns.store(values.elapsed_ns, std::memory_order_relaxed);\n }\n \n void Progress::write(WriteBuffer & out, UInt64 client_revision) const\ndiff --git a/src/IO/Progress.h b/src/IO/Progress.h\nindex 8340974b03dc..c21b1b854b0b 100644\n--- a/src/IO/Progress.h\n+++ b/src/IO/Progress.h\n@@ -16,17 +16,19 @@ class WriteBuffer;\n /// See Progress.\n struct ProgressValues\n {\n-    size_t read_rows;\n-    size_t read_bytes;\n+    UInt64 read_rows = 0;\n+    UInt64 read_bytes = 0;\n \n-    size_t total_rows_to_read;\n-    size_t total_bytes_to_read;\n+    UInt64 total_rows_to_read = 0;\n+    UInt64 total_bytes_to_read = 0;\n \n-    size_t written_rows;\n-    size_t written_bytes;\n+    UInt64 written_rows = 0;\n+    UInt64 written_bytes = 0;\n \n-    size_t result_rows;\n-    size_t result_bytes;\n+    UInt64 result_rows = 0;\n+    UInt64 result_bytes = 0;\n+\n+    UInt64 elapsed_ns = 0;\n \n     void read(ReadBuffer & in, UInt64 server_revision);\n     void write(WriteBuffer & out, UInt64 client_revision) const;\n@@ -35,39 +37,39 @@ struct ProgressValues\n \n struct ReadProgress\n {\n-    size_t read_rows;\n-    size_t read_bytes;\n-    size_t total_rows_to_read;\n+    UInt64 read_rows = 0;\n+    UInt64 read_bytes = 0;\n+    UInt64 total_rows_to_read = 0;\n \n-    ReadProgress(size_t read_rows_, size_t read_bytes_, size_t total_rows_to_read_ = 0)\n+    ReadProgress(UInt64 read_rows_, UInt64 read_bytes_, UInt64 total_rows_to_read_ = 0)\n         : read_rows(read_rows_), read_bytes(read_bytes_), total_rows_to_read(total_rows_to_read_) {}\n };\n \n struct WriteProgress\n {\n-    size_t written_rows;\n-    size_t written_bytes;\n+    UInt64 written_rows = 0;\n+    UInt64 written_bytes = 0;\n \n-    WriteProgress(size_t written_rows_, size_t written_bytes_)\n+    WriteProgress(UInt64 written_rows_, UInt64 written_bytes_)\n         : written_rows(written_rows_), written_bytes(written_bytes_) {}\n };\n \n struct ResultProgress\n {\n-    size_t result_rows;\n-    size_t result_bytes;\n+    UInt64 result_rows = 0;\n+    UInt64 result_bytes = 0;\n \n-    ResultProgress(size_t result_rows_, size_t result_bytes_)\n+    ResultProgress(UInt64 result_rows_, UInt64 result_bytes_)\n         : result_rows(result_rows_), result_bytes(result_bytes_) {}\n };\n \n struct FileProgress\n {\n     /// Here read_bytes (raw bytes) - do not equal ReadProgress::read_bytes, which are calculated according to column types.\n-    size_t read_bytes;\n-    size_t total_bytes_to_read;\n+    UInt64 read_bytes = 0;\n+    UInt64 total_bytes_to_read = 0;\n \n-    explicit FileProgress(size_t read_bytes_, size_t total_bytes_to_read_ = 0) : read_bytes(read_bytes_), total_bytes_to_read(total_bytes_to_read_) {}\n+    explicit FileProgress(UInt64 read_bytes_, UInt64 total_bytes_to_read_ = 0) : read_bytes(read_bytes_), total_bytes_to_read(total_bytes_to_read_) {}\n };\n \n \n@@ -77,24 +79,26 @@ struct FileProgress\n   */\n struct Progress\n {\n-    std::atomic<size_t> read_rows {0};        /// Rows (source) processed.\n-    std::atomic<size_t> read_bytes {0};       /// Bytes (uncompressed, source) processed.\n+    std::atomic<UInt64> read_rows {0};        /// Rows (source) processed.\n+    std::atomic<UInt64> read_bytes {0};       /// Bytes (uncompressed, source) processed.\n \n     /** How much rows/bytes must be processed, in total, approximately. Non-zero value is sent when there is information about\n       * some new part of job. Received values must be summed to get estimate of total rows to process.\n       */\n-    std::atomic<size_t> total_rows_to_read {0};\n-    std::atomic<size_t> total_bytes_to_read {0};\n+    std::atomic<UInt64> total_rows_to_read {0};\n+    std::atomic<UInt64> total_bytes_to_read {0};\n+\n+    std::atomic<UInt64> written_rows {0};\n+    std::atomic<UInt64> written_bytes {0};\n \n-    std::atomic<size_t> written_rows {0};\n-    std::atomic<size_t> written_bytes {0};\n+    std::atomic<UInt64> result_rows {0};\n+    std::atomic<UInt64> result_bytes {0};\n \n-    std::atomic<size_t> result_rows {0};\n-    std::atomic<size_t> result_bytes {0};\n+    std::atomic<UInt64> elapsed_ns {0};\n \n     Progress() = default;\n \n-    Progress(size_t read_rows_, size_t read_bytes_, size_t total_rows_to_read_ = 0)\n+    Progress(UInt64 read_rows_, UInt64 read_bytes_, UInt64 total_rows_to_read_ = 0)\n         : read_rows(read_rows_), read_bytes(read_bytes_), total_rows_to_read(total_rows_to_read_) {}\n \n     explicit Progress(ReadProgress read_progress)\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex 4c6eb1a253bb..b268179ae937 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -215,7 +215,6 @@ void TCPHandler::runImpl()\n             break;\n         }\n \n-        Stopwatch watch;\n         state.reset();\n \n         /// Initialized later.\n@@ -394,10 +393,11 @@ void TCPHandler::runImpl()\n \n                 /// Send final progress\n                 ///\n-                /// NOTE: we cannot send Progress for regular INSERT (w/ VALUES)\n+                /// NOTE: we cannot send Progress for regular INSERT (with VALUES)\n                 /// without breaking protocol compatibility, but it can be done\n                 /// by increasing revision.\n                 sendProgress();\n+                sendSelectProfileEvents();\n             }\n \n             state.io.onFinish();\n@@ -405,8 +405,7 @@ void TCPHandler::runImpl()\n             /// Do it before sending end of stream, to have a chance to show log message in client.\n             query_scope->logPeakMemoryUsage();\n \n-            watch.stop();\n-            LOG_DEBUG(log, \"Processed in {} sec.\", watch.elapsedSeconds());\n+            LOG_DEBUG(log, \"Processed in {} sec.\", state.watch.elapsedSeconds());\n             query_duration_already_logged = true;\n \n             if (state.is_connection_closed)\n@@ -520,6 +519,11 @@ void TCPHandler::runImpl()\n             LOG_WARNING(log, \"Can't skip data packets after query failure.\");\n         }\n \n+        if (!query_duration_already_logged)\n+        {\n+            LOG_DEBUG(log, \"Processed in {} sec.\", state.watch.elapsedSeconds());\n+        }\n+\n         try\n         {\n             /// QueryState should be cleared before QueryScope, since otherwise\n@@ -537,12 +541,6 @@ void TCPHandler::runImpl()\n              */\n         }\n \n-        if (!query_duration_already_logged)\n-        {\n-            watch.stop();\n-            LOG_DEBUG(log, \"Processed in {} sec.\", watch.elapsedSeconds());\n-        }\n-\n         /// It is important to destroy query context here. We do not want it to live arbitrarily longer than the query.\n         query_context.reset();\n \n@@ -1822,6 +1820,9 @@ void TCPHandler::sendProgress()\n {\n     writeVarUInt(Protocol::Server::Progress, *out);\n     auto increment = state.progress.fetchValuesAndResetPiecewiseAtomically();\n+    UInt64 current_elapsed_ns = state.watch.elapsedNanoseconds();\n+    increment.elapsed_ns = current_elapsed_ns - state.prev_elapsed_ns;\n+    state.prev_elapsed_ns = current_elapsed_ns;\n     increment.write(*out, client_tcp_protocol_version);\n     out->next();\n }\ndiff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h\nindex cee3cf448d69..ea5fb2f9fe03 100644\n--- a/src/Server/TCPHandler.h\n+++ b/src/Server/TCPHandler.h\n@@ -102,6 +102,8 @@ struct QueryState\n \n     /// To output progress, the difference after the previous sending of progress.\n     Progress progress;\n+    Stopwatch watch;\n+    UInt64 prev_elapsed_ns = 0;\n \n     /// Timeouts setter for current query\n     std::unique_ptr<TimeoutSetter> timeout_setter;\n",
  "test_patch": "diff --git a/docker/test/fasttest/Dockerfile b/docker/test/fasttest/Dockerfile\nindex d74f99cf54b7..7f7a8008d4ed 100644\n--- a/docker/test/fasttest/Dockerfile\n+++ b/docker/test/fasttest/Dockerfile\n@@ -16,7 +16,8 @@ RUN apt-get update \\\n         python3-requests \\\n         python3-termcolor \\\n         unixodbc \\\n-       --yes --no-install-recommends\n+        pv \\\n+    --yes --no-install-recommends\n \n RUN pip3 install numpy scipy pandas Jinja2\n \ndiff --git a/docker/test/stateless/Dockerfile b/docker/test/stateless/Dockerfile\nindex 9141e89d744e..c5d1ec4f12d6 100644\n--- a/docker/test/stateless/Dockerfile\n+++ b/docker/test/stateless/Dockerfile\n@@ -35,6 +35,7 @@ RUN apt-get update -y \\\n             wget \\\n             zstd \\\n             file \\\n+            pv \\\n     && apt-get clean\n \n \ndiff --git a/docker/test/stateless_pytest/Dockerfile b/docker/test/stateless_pytest/Dockerfile\ndeleted file mode 100644\nindex 789ee0e9b308..000000000000\n--- a/docker/test/stateless_pytest/Dockerfile\n+++ /dev/null\n@@ -1,33 +0,0 @@\n-# rebuild in #33610\n-# docker build -t clickhouse/stateless-pytest .\n-ARG FROM_TAG=latest\n-FROM clickhouse/test-base:$FROM_TAG\n-\n-RUN apt-get update -y && \\\n-    apt-get install -y --no-install-recommends \\\n-        python3-pip \\\n-        python3-setuptools \\\n-        python3-wheel \\\n-        brotli \\\n-        netcat-openbsd \\\n-        postgresql-client \\\n-        zstd\n-\n-RUN python3 -m pip install \\\n-    wheel \\\n-    pytest \\\n-    pytest-html \\\n-    pytest-json \\\n-    pytest-randomly \\\n-    pytest-rerunfailures \\\n-    pytest-timeout \\\n-    pytest-xdist \\\n-    pandas \\\n-    numpy \\\n-    scipy\n-\n-CMD dpkg -i package_folder/clickhouse-common-static_*.deb; \\\n-    dpkg -i package_folder/clickhouse-common-static-dbg_*.deb; \\\n-    dpkg -i package_folder/clickhouse-server_*.deb;  \\\n-    dpkg -i package_folder/clickhouse-client_*.deb; \\\n-    python3 -m pytest /usr/share/clickhouse-test/queries -n $(nproc) --reruns=1 --timeout=600 --json=test_output/report.json --html=test_output/report.html --self-contained-html\ndiff --git a/tests/ci/fast_test_check.py b/tests/ci/fast_test_check.py\nindex 84d9d3f16d87..e5fd0eace33d 100644\n--- a/tests/ci/fast_test_check.py\n+++ b/tests/ci/fast_test_check.py\n@@ -31,6 +31,9 @@\n \n NAME = \"Fast test\"\n \n+# Will help to avoid errors like _csv.Error: field larger than field limit (131072)\n+csv.field_size_limit(sys.maxsize)\n+\n \n def get_fasttest_cmd(\n     workspace, output_path, ccache_path, repo_path, pr_number, commit_sha, image\ndiff --git a/tests/queries/0_stateless/02381_client_prints_server_side_time.reference b/tests/queries/0_stateless/02381_client_prints_server_side_time.reference\nnew file mode 100644\nindex 000000000000..7326d9603970\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_client_prints_server_side_time.reference\n@@ -0,0 +1,1 @@\n+Ok\ndiff --git a/tests/queries/0_stateless/02381_client_prints_server_side_time.sh b/tests/queries/0_stateless/02381_client_prints_server_side_time.sh\nnew file mode 100755\nindex 000000000000..e6cd63da95d3\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_client_prints_server_side_time.sh\n@@ -0,0 +1,18 @@\n+#!/usr/bin/env bash\n+# Tags: no-tsan, no-asan, no-ubsan, no-msan, no-debug, no-s3-storage\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+# We will check that --time option of clickhouse-client will display server-side time, not client-side time.\n+# For this purpose, we ask it to output some amount of data that is larger than the buffers in clickhouse-client\n+# but smaller than the pipe buffer, and we slow down output of the query result with 'pv' command to get around one second of run time.\n+# If everything is works as expected, at least sometimes this command should display time less than 100ms.\n+while true\n+do\n+    $CLICKHOUSE_CLIENT --time --query 'SELECT 1 FROM numbers(1000000) FORMAT RowBinary' 2>\"${CLICKHOUSE_TMP}/time\" | pv --quiet --rate-limit 1M > /dev/null\n+    grep -q -F '0.0' \"${CLICKHOUSE_TMP}/time\" && break\n+done\n+\n+echo 'Ok'\n",
  "problem_statement": "Server should have Progress for server-side elapsed time for a query.\n**Use case**\r\n\r\nThis will allow clickhouse-client to show the server-side elapsed time before query result and also to show a more precise CPU usage metric.\r\n\r\n**Describe the solution you'd like**\r\n\r\nUpdate it at least when ProfileEvents are sent to the client, or on every block (but then a coarse timer may be needed).\r\n\r\n**Additional context**\r\n\r\nAlso, implement it for clickhouse-local.\r\n\n",
  "hints_text": "",
  "created_at": "2022-08-08T05:00:27Z"
}