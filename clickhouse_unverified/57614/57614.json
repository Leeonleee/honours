{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57614,
  "instance_id": "ClickHouse__ClickHouse-57614",
  "issue_numbers": [
    "57540"
  ],
  "base_commit": "ba5ff075bb1889c8fc6a9a1c0399760fe3280136",
  "patch": "diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex 060fe95958fc..078797910afd 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -32,7 +32,7 @@\n #include <Common/assert_cast.h>\n \n #include <Functions/FunctionHelpers.h>\n-\n+#include <Interpreters/castColumn.h>\n \n namespace DB\n {\n@@ -217,7 +217,7 @@ static void correctNullabilityInplace(ColumnWithTypeAndName & column, bool nulla\n     }\n }\n \n-static void correctNullabilityInplace(ColumnWithTypeAndName & column, bool nullable, const ColumnUInt8 & negative_null_map)\n+static void correctNullabilityInplace(ColumnWithTypeAndName & column, bool nullable, const IColumn::Filter & negative_null_map)\n {\n     if (nullable)\n     {\n@@ -269,8 +269,9 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n         sample_block_with_columns_to_add = right_table_keys = materializeBlock(right_sample_block);\n     }\n \n-    JoinCommon::convertToFullColumnsInplace(right_table_keys);\n+    materializeBlockInplace(right_table_keys);\n     initRightBlockStructure(data->sample_block);\n+    data->sample_block = prepareRightBlock(data->sample_block);\n \n     JoinCommon::createMissedColumns(sample_block_with_columns_to_add);\n \n@@ -373,10 +374,20 @@ HashJoin::Type HashJoin::chooseMethod(JoinKind kind, const ColumnRawPtrs & key_c\n         return Type::keys256;\n \n     /// If there is single string key, use hash table of it's values.\n-    if (keys_size == 1\n-        && (typeid_cast<const ColumnString *>(key_columns[0])\n-            || (isColumnConst(*key_columns[0]) && typeid_cast<const ColumnString *>(&assert_cast<const ColumnConst *>(key_columns[0])->getDataColumn()))))\n-        return Type::key_string;\n+    if (keys_size == 1)\n+    {\n+        auto is_string_column = [](const IColumn * column_ptr) -> bool\n+        {\n+            if (const auto * lc_column_ptr = typeid_cast<const ColumnLowCardinality *>(column_ptr))\n+                return typeid_cast<const ColumnString *>(lc_column_ptr->getDictionary().getNestedColumn().get());\n+            return typeid_cast<const ColumnString *>(column_ptr);\n+        };\n+\n+        const auto * key_column = key_columns[0];\n+        if (is_string_column(key_column) ||\n+            (isColumnConst(*key_column) && is_string_column(assert_cast<const ColumnConst *>(key_column)->getDataColumnPtr().get())))\n+            return Type::key_string;\n+    }\n \n     if (keys_size == 1 && typeid_cast<const ColumnFixedString *>(key_columns[0]))\n         return Type::key_fixed_string;\n@@ -791,7 +802,13 @@ bool HashJoin::addBlockToJoin(const Block & source_block_, bool check_limits)\n \n     size_t rows = source_block.rows();\n \n-    ColumnPtrMap all_key_columns = JoinCommon::materializeColumnsInplaceMap(source_block, table_join->getAllNames(JoinTableSide::Right));\n+    const auto & right_key_names = table_join->getAllNames(JoinTableSide::Right);\n+    ColumnPtrMap all_key_columns(right_key_names.size());\n+    for (const auto & column_name : right_key_names)\n+    {\n+        const auto & column = source_block.getByName(column_name).column;\n+        all_key_columns[column_name] = recursiveRemoveSparse(column->convertToFullColumnIfConst())->convertToFullColumnIfLowCardinality();\n+    }\n \n     Block block_to_save = prepareRightBlock(source_block);\n     if (shrink_blocks)\n@@ -804,6 +821,8 @@ bool HashJoin::addBlockToJoin(const Block & source_block_, bool check_limits)\n             throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"addBlockToJoin called when HashJoin locked to prevent updates\");\n \n         data->blocks_allocated_size += block_to_save.allocatedBytes();\n+\n+        assertBlocksHaveEqualStructure(data->sample_block, block_to_save, \"joined block\");\n         data->blocks.emplace_back(std::move(block_to_save));\n         Block * stored_block = &data->blocks.back();\n \n@@ -1012,16 +1031,15 @@ class AddedColumns\n     };\n \n     AddedColumns(\n+        const Block & left_block,\n         const Block & block_with_columns_to_add,\n-        const Block & block,\n         const Block & saved_block_sample,\n         const HashJoin & join,\n         std::vector<JoinOnKeyColumns> && join_on_keys_,\n         bool is_asof_join,\n         bool is_join_get_)\n         : join_on_keys(join_on_keys_)\n-        , rows_to_add(block.rows())\n-        , sample_block(saved_block_sample)\n+        , rows_to_add(left_block.rows())\n         , is_join_get(is_join_get_)\n     {\n         size_t num_columns_to_add = block_with_columns_to_add.columns();\n@@ -1038,7 +1056,7 @@ class AddedColumns\n             /// because it uses not qualified right block column names\n             auto qualified_name = join.getTableJoin().renamedRightColumnName(src_column.name);\n             /// Don't insert column if it's in left block\n-            if (!block.has(qualified_name))\n+            if (!left_block.has(qualified_name))\n                 addColumn(src_column, qualified_name);\n         }\n \n@@ -1052,6 +1070,17 @@ class AddedColumns\n \n         for (auto & tn : type_name)\n             right_indexes.push_back(saved_block_sample.getPositionByName(tn.name));\n+\n+        nullable_column_ptrs.resize(right_indexes.size(), nullptr);\n+        for (size_t j = 0; j < right_indexes.size(); ++j)\n+        {\n+            /** If it's joinGetOrNull, we will have nullable columns in result block\n+              * even if right column is not nullable in storage (saved_block_sample).\n+              */\n+            const auto & saved_column = saved_block_sample.getByPosition(right_indexes[j]).column;\n+            if (columns[j]->isNullable() && !saved_column->isNullable())\n+                nullable_column_ptrs[j] = typeid_cast<ColumnNullable *>(columns[j].get());\n+        }\n     }\n \n     size_t size() const { return columns.size(); }\n@@ -1061,33 +1090,6 @@ class AddedColumns\n         return ColumnWithTypeAndName(std::move(columns[i]), type_name[i].type, type_name[i].qualified_name);\n     }\n \n-    static void assertBlockEqualsStructureUpToLowCard(const Block & lhs_block, const Block & rhs_block)\n-    {\n-        if (lhs_block.columns() != rhs_block.columns())\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Different number of columns in blocks [{}] and [{}]\",\n-                lhs_block.dumpStructure(), rhs_block.dumpStructure());\n-\n-        for (size_t i = 0; i < lhs_block.columns(); ++i)\n-        {\n-            const auto & lhs = lhs_block.getByPosition(i);\n-            const auto & rhs = rhs_block.getByPosition(i);\n-            if (lhs.name != rhs.name)\n-                throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"Block structure mismatch: [{}] != [{}] ({} != {})\",\n-                    lhs_block.dumpStructure(), rhs_block.dumpStructure(), lhs.name, rhs.name);\n-\n-            const auto & ltype = recursiveRemoveLowCardinality(lhs.type);\n-            const auto & rtype = recursiveRemoveLowCardinality(rhs.type);\n-            if (!ltype->equals(*rtype))\n-                throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"Block structure mismatch: [{}] != [{}] ({} != {})\",\n-                    lhs_block.dumpStructure(), rhs_block.dumpStructure(), ltype->getName(), rtype->getName());\n-\n-            const auto & lcol = recursiveRemoveLowCardinality(lhs.column);\n-            const auto & rcol = recursiveRemoveLowCardinality(rhs.column);\n-            if (lcol->getDataType() != rcol->getDataType())\n-                throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"Block structure mismatch: [{}] != [{}] ({} != {})\",\n-                    lhs_block.dumpStructure(), rhs_block.dumpStructure(), lcol->getDataType(), rcol->getDataType());\n-        }\n-    }\n \n     template <bool has_defaults>\n     void appendFromBlock(const Block & block, size_t row_num)\n@@ -1096,38 +1098,42 @@ class AddedColumns\n             applyLazyDefaults();\n \n #ifndef NDEBUG\n-        /// Like assertBlocksHaveEqualStructure but doesn't check low cardinality\n-        assertBlockEqualsStructureUpToLowCard(sample_block, block);\n-#else\n-        UNUSED(assertBlockEqualsStructureUpToLowCard);\n+        for (size_t j = 0; j < right_indexes.size(); ++j)\n+        {\n+            const auto & column_from_block = block.getByPosition(right_indexes[j]);\n+            const auto * dest_column = columns[j].get();\n+            if (auto * nullable_col = nullable_column_ptrs[j])\n+            {\n+                if (!is_join_get)\n+                    throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                        \"Columns {} and {} can have different nullability only in joinGetOrNull\",\n+                        dest_column->getName(), column_from_block.column->getName());\n+                dest_column = nullable_col->getNestedColumnPtr().get();\n+            }\n+            if (!dest_column->structureEquals(*column_from_block.column))\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Columns {} and {} are not structure equals\", dest_column->getName(), column_from_block.column->getName());\n+        }\n #endif\n \n         if (is_join_get)\n         {\n-            /// If it's joinGetOrNull, we need to wrap not-nullable columns in StorageJoin.\n-            for (size_t j = 0, size = right_indexes.size(); j < size; ++j)\n+            size_t right_indexes_size = right_indexes.size();\n+            for (size_t j = 0; j < right_indexes_size; ++j)\n             {\n                 const auto & column_from_block = block.getByPosition(right_indexes[j]);\n-                if (auto * nullable_col = typeid_cast<ColumnNullable *>(columns[j].get());\n-                    nullable_col && !column_from_block.column->isNullable())\n+                if (auto * nullable_col = nullable_column_ptrs[j])\n                     nullable_col->insertFromNotNullable(*column_from_block.column, row_num);\n-                else if (auto * lowcard_col = typeid_cast<ColumnLowCardinality *>(columns[j].get());\n-                         lowcard_col && !typeid_cast<const ColumnLowCardinality *>(column_from_block.column.get()))\n-                    lowcard_col->insertFromFullColumn(*column_from_block.column, row_num);\n                 else\n                     columns[j]->insertFrom(*column_from_block.column, row_num);\n             }\n         }\n         else\n         {\n-            for (size_t j = 0, size = right_indexes.size(); j < size; ++j)\n+            size_t right_indexes_size = right_indexes.size();\n+            for (size_t j = 0; j < right_indexes_size; ++j)\n             {\n                 const auto & column_from_block = block.getByPosition(right_indexes[j]);\n-                if (auto * lowcard_col = typeid_cast<ColumnLowCardinality *>(columns[j].get());\n-                    lowcard_col && !typeid_cast<const ColumnLowCardinality *>(column_from_block.column.get()))\n-                    lowcard_col->insertFromFullColumn(*column_from_block.column, row_num);\n-                else\n-                    columns[j]->insertFrom(*column_from_block.column, row_num);\n+                columns[j]->insertFrom(*column_from_block.column, row_num);\n             }\n         }\n     }\n@@ -1158,11 +1164,12 @@ class AddedColumns\n private:\n     std::vector<TypeAndName> type_name;\n     MutableColumns columns;\n+    std::vector<ColumnNullable *> nullable_column_ptrs;\n+\n     std::vector<size_t> right_indexes;\n     size_t lazy_defaults_count = 0;\n     /// for ASOF\n     const IColumn * left_asof_key = nullptr;\n-    Block sample_block;\n \n     bool is_join_get;\n \n@@ -1548,6 +1555,40 @@ IColumn::Filter switchJoinRightColumns(\n     }\n }\n \n+/** Since we do not store right key columns,\n+  * this function is used to copy left key columns to right key columns.\n+  * If the user requests some right columns, we just copy left key columns to right, since they are equal.\n+  * Example: SELECT t1.key, t2.key FROM t1 FULL JOIN t2 ON t1.key = t2.key;\n+  * In that case for matched rows in t2.key we will use values from t1.key.\n+  * However, in some cases we might need to adjust the type of column, e.g. t1.key :: LowCardinality(String) and t2.key :: String\n+  * Also, the nullability of the column might be different.\n+  * Returns the right column after with necessary adjustments.\n+  */\n+ColumnWithTypeAndName copyLeftKeyColumnToRight(\n+    const DataTypePtr & right_key_type, const String & renamed_right_column, const ColumnWithTypeAndName & left_column, const IColumn::Filter * null_map_filter = nullptr)\n+{\n+    ColumnWithTypeAndName right_column = left_column;\n+    right_column.name = renamed_right_column;\n+\n+    if (null_map_filter)\n+        right_column.column = JoinCommon::filterWithBlanks(right_column.column, *null_map_filter);\n+\n+    bool should_be_nullable = isNullableOrLowCardinalityNullable(right_key_type);\n+    if (null_map_filter)\n+        correctNullabilityInplace(right_column, should_be_nullable, *null_map_filter);\n+    else\n+        correctNullabilityInplace(right_column, should_be_nullable);\n+\n+    if (!right_column.type->equals(*right_key_type))\n+    {\n+        right_column.column = castColumnAccurate(right_column, right_key_type);\n+        right_column.type = right_key_type;\n+    }\n+\n+    right_column.column = right_column.column->convertToFullColumnIfConst();\n+    return right_column;\n+}\n+\n } /// nameless\n \n template <JoinKind KIND, JoinStrictness STRICTNESS, typename Maps>\n@@ -1583,8 +1624,8 @@ void HashJoin::joinBlockImpl(\n       * For ASOF, the last column is used as the ASOF column\n       */\n     AddedColumns added_columns(\n-        block_with_columns_to_add,\n         block,\n+        block_with_columns_to_add,\n         savedBlockSample(),\n         *this,\n         std::move(join_on_keys),\n@@ -1614,31 +1655,19 @@ void HashJoin::joinBlockImpl(\n             // renamed ???\n             if (!block.findByName(right_key.name))\n             {\n-                const auto & left_name = required_right_keys_sources[i];\n-\n                 /// asof column is already in block.\n                 if (join_features.is_asof_join && right_key.name == table_join->getOnlyClause().key_names_right.back())\n                     continue;\n \n-                const auto & col = block.getByName(left_name);\n-                bool is_nullable = JoinCommon::isNullable(right_key.type);\n-                auto right_col_name = getTableJoin().renamedRightColumnName(right_key.name);\n-                ColumnWithTypeAndName right_col(col.column, col.type, right_col_name);\n-                if (right_col.type->lowCardinality() != right_key.type->lowCardinality())\n-                    JoinCommon::changeLowCardinalityInplace(right_col);\n-                correctNullabilityInplace(right_col, is_nullable);\n+                const auto & left_column = block.getByName(required_right_keys_sources[i]);\n+                const auto & right_col_name = getTableJoin().renamedRightColumnName(right_key.name);\n+                auto right_col = copyLeftKeyColumnToRight(right_key.type, right_col_name, left_column);\n                 block.insert(std::move(right_col));\n             }\n         }\n     }\n     else if (has_required_right_keys)\n     {\n-        /// Some trash to represent IColumn::Filter as ColumnUInt8 needed for ColumnNullable::applyNullMap()\n-        auto null_map_filter_ptr = ColumnUInt8::create();\n-        ColumnUInt8 & null_map_filter = assert_cast<ColumnUInt8 &>(*null_map_filter_ptr);\n-        null_map_filter.getData().swap(row_filter);\n-        const IColumn::Filter & filter = null_map_filter.getData();\n-\n         /// Add join key columns from right block if needed.\n         for (size_t i = 0; i < required_right_keys.columns(); ++i)\n         {\n@@ -1646,21 +1675,12 @@ void HashJoin::joinBlockImpl(\n             auto right_col_name = getTableJoin().renamedRightColumnName(right_key.name);\n             if (!block.findByName(right_col_name))\n             {\n-                const auto & left_name = required_right_keys_sources[i];\n-\n                 /// asof column is already in block.\n                 if (join_features.is_asof_join && right_key.name == table_join->getOnlyClause().key_names_right.back())\n                     continue;\n \n-                const auto & col = block.getByName(left_name);\n-                bool is_nullable = JoinCommon::isNullable(right_key.type);\n-\n-                ColumnPtr thin_column = JoinCommon::filterWithBlanks(col.column, filter);\n-\n-                ColumnWithTypeAndName right_col(thin_column, col.type, right_col_name);\n-                if (right_col.type->lowCardinality() != right_key.type->lowCardinality())\n-                    JoinCommon::changeLowCardinalityInplace(right_col);\n-                correctNullabilityInplace(right_col, is_nullable, null_map_filter);\n+                const auto & left_column = block.getByName(required_right_keys_sources[i]);\n+                auto right_col = copyLeftKeyColumnToRight(right_key.type, right_col_name, left_column, &row_filter);\n                 block.insert(std::move(right_col));\n \n                 if constexpr (join_features.need_replication)\n@@ -1814,7 +1834,7 @@ ColumnWithTypeAndName HashJoin::joinGet(const Block & block, const Block & block\n     std::vector<const MapsOne *> maps_vector;\n     maps_vector.push_back(&std::get<MapsOne>(data->maps[0]));\n     joinBlockImpl<JoinKind::Left, JoinStrictness::Any>(\n-        keys, block_with_columns_to_add, maps_vector, true);\n+        keys, block_with_columns_to_add, maps_vector, /* is_join_get = */ true);\n     return keys.getByPosition(keys.columns() - 1);\n }\n \n@@ -1941,9 +1961,9 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n         }\n         else\n         {\n-            auto fill_callback = [&](auto, auto strictness, auto & map)\n+            auto fill_callback = [&](auto, auto, auto & map)\n             {\n-                rows_added = fillColumnsFromMap<strictness>(map, columns_right);\n+                rows_added = fillColumnsFromMap(map, columns_right);\n             };\n \n             if (!joinDispatch(parent.kind, parent.strictness, parent.data->maps.front(), fill_callback))\n@@ -2004,24 +2024,24 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n         return rows_added;\n     }\n \n-    template <JoinStrictness STRICTNESS, typename Maps>\n+    template <typename Maps>\n     size_t fillColumnsFromMap(const Maps & maps, MutableColumns & columns_keys_and_right)\n     {\n         switch (parent.data->type)\n         {\n         #define M(TYPE) \\\n             case HashJoin::Type::TYPE: \\\n-                return fillColumns<STRICTNESS>(*maps.TYPE, columns_keys_and_right);\n+                return fillColumns(*maps.TYPE, columns_keys_and_right);\n             APPLY_FOR_JOIN_VARIANTS(M)\n         #undef M\n             default:\n-                throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys (type: {})\", parent.data->type)   ;\n+                throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys (type: {})\", parent.data->type);\n         }\n \n         UNREACHABLE();\n     }\n \n-    template <JoinStrictness STRICTNESS, typename Map>\n+    template <typename Map>\n     size_t fillColumns(const Map & map, MutableColumns & columns_keys_and_right)\n     {\n         size_t rows_added = 0;\n@@ -2067,8 +2087,8 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n             {\n                 const Mapped & mapped = it->getMapped();\n \n-                size_t off = map.offsetInternal(it.getPtr());\n-                if (parent.isUsed(off))\n+                size_t offset = map.offsetInternal(it.getPtr());\n+                if (parent.isUsed(offset))\n                     continue;\n                 AdderNonJoined<Mapped>::add(mapped, rows_added, columns_keys_and_right);\n \n@@ -2179,7 +2199,7 @@ BlocksList HashJoin::releaseJoinedBlocks(bool restructure)\n         for (const auto & sample_column : right_sample_block)\n         {\n             positions.emplace_back(tmp_block.getPositionByName(sample_column.name));\n-            is_nullable.emplace_back(JoinCommon::isNullable(sample_column.type));\n+            is_nullable.emplace_back(isNullableOrLowCardinalityNullable(sample_column.type));\n         }\n     }\n \ndiff --git a/src/Interpreters/JoinUtils.cpp b/src/Interpreters/JoinUtils.cpp\nindex 33c9dfa76ca0..949a97d57482 100644\n--- a/src/Interpreters/JoinUtils.cpp\n+++ b/src/Interpreters/JoinUtils.cpp\n@@ -120,19 +120,11 @@ bool canBecomeNullable(const DataTypePtr & type)\n     return can_be_inside;\n }\n \n-bool isNullable(const DataTypePtr & type)\n-{\n-    bool is_nullable = type->isNullable();\n-    if (const auto * low_cardinality_type = typeid_cast<const DataTypeLowCardinality *>(type.get()))\n-        is_nullable |= low_cardinality_type->getDictionaryType()->isNullable();\n-    return is_nullable;\n-}\n-\n /// Add nullability to type.\n /// Note: LowCardinality(T) transformed to LowCardinality(Nullable(T))\n DataTypePtr convertTypeToNullable(const DataTypePtr & type)\n {\n-    if (isNullable(type))\n+    if (isNullableOrLowCardinalityNullable(type))\n         return type;\n \n     if (const auto * low_cardinality_type = typeid_cast<const DataTypeLowCardinality *>(type.get()))\n@@ -323,20 +315,6 @@ ColumnRawPtrs materializeColumnsInplace(Block & block, const Names & names)\n     return ptrs;\n }\n \n-ColumnPtrMap materializeColumnsInplaceMap(const Block & block, const Names & names)\n-{\n-    ColumnPtrMap ptrs;\n-    ptrs.reserve(names.size());\n-\n-    for (const auto & column_name : names)\n-    {\n-        ColumnPtr column = block.getByName(column_name).column;\n-        ptrs[column_name] = materializeColumn(column);\n-    }\n-\n-    return ptrs;\n-}\n-\n ColumnPtr materializeColumn(const Block & block, const String & column_name)\n {\n     const auto & src_column = block.getByName(column_name).column;\ndiff --git a/src/Interpreters/JoinUtils.h b/src/Interpreters/JoinUtils.h\nindex f112ca22e5b7..a88fca02bd81 100644\n--- a/src/Interpreters/JoinUtils.h\n+++ b/src/Interpreters/JoinUtils.h\n@@ -59,7 +59,6 @@ class JoinMask\n };\n \n \n-bool isNullable(const DataTypePtr & type);\n bool canBecomeNullable(const DataTypePtr & type);\n DataTypePtr convertTypeToNullable(const DataTypePtr & type);\n void convertColumnToNullable(ColumnWithTypeAndName & column);\n@@ -71,7 +70,6 @@ ColumnPtr emptyNotNullableClone(const ColumnPtr & column);\n ColumnPtr materializeColumn(const Block & block, const String & name);\n Columns materializeColumns(const Block & block, const Names & names);\n ColumnRawPtrs materializeColumnsInplace(Block & block, const Names & names);\n-ColumnPtrMap materializeColumnsInplaceMap(const Block & block, const Names & names);\n ColumnRawPtrs getRawPointers(const Columns & columns);\n void convertToFullColumnsInplace(Block & block);\n void convertToFullColumnsInplace(Block & block, const Names & names, bool change_type = true);\ndiff --git a/src/Storages/StorageJoin.cpp b/src/Storages/StorageJoin.cpp\nindex 121d859a3f23..efe446a8ccd8 100644\n--- a/src/Storages/StorageJoin.cpp\n+++ b/src/Storages/StorageJoin.cpp\n@@ -535,8 +535,7 @@ class JoinSource : public ISource\n #undef M\n \n             default:\n-                throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys in StorageJoin. Type: {}\",\n-                                static_cast<UInt32>(join->data->type));\n+                throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys of type {} in StorageJoin\", join->data->type);\n         }\n \n         if (!rows_added)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.reference b/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.reference\nindex 19da8828c30e..83571fd9005f 100644\n--- a/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.reference\n+++ b/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.reference\n@@ -9,3 +9,23 @@\n \\N\n \n 100000000000000000000\n+---\n+[]\t0\t['2']\n+['0']\t2\t['0']\n+['0']\t2\t['0']\n+['1']\t1\t[]\n+\n+[]\t3\t[]\n+---\n+[]\t0\t['2']\t1\n+['0']\t2\t['0']\t2\n+['1']\t1\t[]\t0\n+\n+[]\t3\t[]\t3\n+---\n+[]\t['2']\t1\n+['0']\t['0']\t2\n+['0']\t['0']\t2\n+['1']\t[]\t0\n+\n+[]\t[]\t3\ndiff --git a/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.sql b/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.sql\nindex 6b58d737a3ec..d39efb0b1937 100644\n--- a/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.sql\n+++ b/tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.sql\n@@ -1,5 +1,3 @@\n-SET allow_experimental_analyzer = 1;\n-\n SELECT *\n FROM\n (\n@@ -34,7 +32,6 @@ INNER JOIN\n ) AS t2 USING (a)\n SETTINGS allow_experimental_analyzer=1;\n \n-\n SELECT a\n FROM\n (\n@@ -72,3 +69,46 @@ ALL LEFT JOIN\n         WITH TOTALS\n ) AS js2 USING (a)\n ORDER BY b ASC NULLS FIRST;\n+\n+SELECT '---';\n+SELECT\n+    *\n+FROM (\n+    SELECT ([toString(number % 2)] :: Array(LowCardinality(String))) AS item_id, count() FROM numbers(3) GROUP BY item_id\n+    WITH TOTALS\n+) AS l\n+FULL JOIN (\n+    SELECT ([toString((number % 2) * 2)] :: Array(String)) AS item_id FROM numbers(3)\n+) AS r\n+ON l.item_id = r.item_id\n+ORDER BY 1,2,3\n+;\n+\n+SELECT '---';\n+SELECT\n+    *\n+FROM (\n+    SELECT ([toString(number % 2)] :: Array(LowCardinality(String))) AS item_id, count() FROM numbers(3) GROUP BY item_id\n+    WITH TOTALS\n+) AS l\n+FULL JOIN (\n+    SELECT ([toString((number % 2) * 2)] :: Array(String)) AS item_id, count() FROM numbers(3) GROUP BY item_id\n+    WITH TOTALS\n+) AS r\n+ON l.item_id = r.item_id\n+ORDER BY 1,2,3\n+;\n+\n+SELECT '---';\n+SELECT\n+    *\n+FROM (\n+    SELECT ([toString(number % 2)] :: Array(String)) AS item_id FROM numbers(3)\n+) AS l\n+FULL JOIN (\n+    SELECT ([toString((number % 2) * 2)] :: Array(LowCardinality(String))) AS item_id, count() FROM numbers(3) GROUP BY item_id\n+    WITH TOTALS\n+) AS r\n+ON l.item_id = r.item_id\n+ORDER BY 1,2,3\n+;\n",
  "problem_statement": "Join crash repro\n### Changelog category (leave one):\r\n- Not for changelog (changelog entry is not required)\r\n\r\n\n",
  "hints_text": "<!-- automatic status comment for PR #57540 from ClickHouse/ClickHouse:join-totals-crash -->\n*This is an automated comment for commit ad2a6c23a18572c5bc49931fe95f58780f541dca with description of existing statuses. It's updated for the latest CI running*\n\n[\u274c Click here](https://s3.amazonaws.com/clickhouse-test-reports/57540/ad2a6c23a18572c5bc49931fe95f58780f541dca/ci_running.html) to open a full report in a separate page\n\n<details><summary>Successful checks</summary>\n<table>\n<thead><tr><th>Check name</th><th>Description</th><th>Status</th></tr></thead>\n<tbody>\n<tr><td>Mergeable Check</td><td>Checks if all other necessary checks are successful</td><td><a href=\"https://github.com/ClickHouse/ClickHouse/actions/runs/7103419982\">\u2705 success</a></td></tr>\n<tr><td>Push to Dockerhub</td><td>The check for building and pushing the CI related docker images to docker hub</td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/57540/ad2a6c23a18572c5bc49931fe95f58780f541dca/push_multi-arch_images_to_dockerhub.html\">\u2705 success</a></td></tr>\n<tr><td>Style Check</td><td>Runs a set of checks to keep the code style clean. If some of tests failed, see the related log from the report</td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/57540/ad2a6c23a18572c5bc49931fe95f58780f541dca/style_check.html\">\u2705 success</a></td></tr>\n<tbody>\n</table>\n</details>\n<table>\n<thead><tr><th>Check name</th><th>Description</th><th>Status</th></tr></thead>\n<tbody>\n<tr><td>CI running</td><td>A meta-check that indicates the running CI. Normally, it's in <b>success</b> or <b>pending</b> state. The failed status indicates some problems with the PR</td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/57540/ad2a6c23a18572c5bc49931fe95f58780f541dca/ci_running.html\">\u23f3 pending</a></td></tr>\n<tr><td>Fast test</td><td>Normally this is the first check that is ran for a PR. It builds ClickHouse and runs most of <a href=\"https://clickhouse.com/docs/en/development/tests#functional-tests\">stateless functional tests</a>, omitting some. If it fails, further checks are not started until it is fixed. Look at the report to see which tests fail, then reproduce the failure locally as described <a href=\"https://clickhouse.com/docs/en/development/tests#functional-test-locally\">here</a></td><td><a href=\"https://s3.amazonaws.com/clickhouse-test-reports/57540/ad2a6c23a18572c5bc49931fe95f58780f541dca/fast_test.html\">\u274c failure</a></td></tr>\n<tbody>\n</table>\n",
  "created_at": "2023-12-07T12:13:41Z",
  "modified_files": [
    "src/Interpreters/HashJoin.cpp",
    "src/Interpreters/JoinUtils.cpp",
    "src/Interpreters/JoinUtils.h",
    "src/Storages/StorageJoin.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.reference",
    "tests/queries/0_stateless/02516_join_with_totals_and_subquery_bug.sql"
  ]
}