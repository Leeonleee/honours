{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 39681,
  "instance_id": "ClickHouse__ClickHouse-39681",
  "issue_numbers": [
    "38908"
  ],
  "base_commit": "acb0137dbb75e04cf4cf1567307228a4eb6aab8f",
  "patch": "diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex caf9be1fea63..ea51367ee5d0 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -1,6 +1,7 @@\n #include <string_view>\n \n #include <Parsers/ExpressionListParsers.h>\n+#include <Parsers/ParserSetQuery.h>\n \n #include <Parsers/ASTAsterisk.h>\n #include <Parsers/ASTExpressionList.h>\n@@ -9,6 +10,7 @@\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTSetQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSubquery.h>\n #include <Parsers/ASTTablesInSelectQuery.h>\n@@ -603,6 +605,13 @@ bool ParserTableFunctionExpression::parseImpl(Pos & pos, ASTPtr & node, Expected\n {\n     if (ParserTableFunctionView().parse(pos, node, expected))\n         return true;\n+    ParserKeyword s_settings(\"SETTINGS\");\n+    if (s_settings.ignore(pos, expected))\n+    {\n+        ParserSetQuery parser_settings(true);\n+        if (parser_settings.parse(pos, node, expected))\n+            return true;\n+    }\n     return elem_parser.parse(pos, node, expected);\n }\n \ndiff --git a/src/TableFunctions/TableFunctionExecutable.cpp b/src/TableFunctions/TableFunctionExecutable.cpp\nindex b84008f5ac8d..7489b91659c7 100644\n--- a/src/TableFunctions/TableFunctionExecutable.cpp\n+++ b/src/TableFunctions/TableFunctionExecutable.cpp\n@@ -4,7 +4,10 @@\n #include <TableFunctions/TableFunctionFactory.h>\n #include <TableFunctions/parseColumnsListForTableFunction.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Parsers/parseQuery.h>\n #include <Storages/checkAndGetLiteralArgument.h>\n #include <Storages/StorageExecutable.h>\n #include <DataTypes/DataTypeFactory.h>\n@@ -48,7 +51,7 @@ void TableFunctionExecutable::parseArguments(const ASTPtr & ast_function, Contex\n     std::vector<String> script_name_with_arguments;\n     boost::split(script_name_with_arguments, script_name_with_arguments_value, [](char c){ return c == ' '; });\n \n-    script_name = script_name_with_arguments[0];\n+    script_name = std::move(script_name_with_arguments[0]);\n     script_name_with_arguments.erase(script_name_with_arguments.begin());\n     arguments = std::move(script_name_with_arguments);\n     format = checkAndGetLiteralArgument<String>(args[1], \"format\");\n@@ -56,14 +59,26 @@ void TableFunctionExecutable::parseArguments(const ASTPtr & ast_function, Contex\n \n     for (size_t i = 3; i < args.size(); ++i)\n     {\n-        ASTPtr query = args[i]->children.at(0);\n-        if (!query->as<ASTSelectWithUnionQuery>())\n-            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n-                \"Table function '{}' argument is invalid input query {}\",\n-                getName(),\n-                query->formatForErrorMessage());\n-\n-        input_queries.emplace_back(std::move(query));\n+        if (args[i]->as<ASTSetQuery>())\n+        {\n+            settings_query = std::move(args[i]);\n+        }\n+        else\n+        {\n+            ASTPtr query = args[i]->children.at(0);\n+            if (query->as<ASTSelectWithUnionQuery>())\n+            {\n+                input_queries.emplace_back(std::move(query));\n+            }\n+            else\n+            {\n+                throw Exception(\n+                    ErrorCodes::UNSUPPORTED_METHOD,\n+                    \"Table function '{}' argument is invalid {}\",\n+                    getName(),\n+                    args[i]->formatForErrorMessage());\n+            }\n+        }\n     }\n }\n \n@@ -79,6 +94,8 @@ StoragePtr TableFunctionExecutable::executeImpl(const ASTPtr & /*ast_function*/,\n     ExecutableSettings settings;\n     settings.script_name = script_name;\n     settings.script_arguments = arguments;\n+    if (settings_query != nullptr)\n+        settings.applyChanges(settings_query->as<ASTSetQuery>()->changes);\n \n     auto storage = std::make_shared<StorageExecutable>(storage_id, format, settings, input_queries, getActualTableStructure(context), ConstraintsDescription{});\n     storage->startup();\ndiff --git a/src/TableFunctions/TableFunctionExecutable.h b/src/TableFunctions/TableFunctionExecutable.h\nindex 128ee8e46fcf..820da077ca20 100644\n--- a/src/TableFunctions/TableFunctionExecutable.h\n+++ b/src/TableFunctions/TableFunctionExecutable.h\n@@ -6,6 +6,7 @@ namespace DB\n {\n \n class Context;\n+class ASTSetQuery;\n \n /* executable(script_name_optional_arguments, format, structure, input_query) - creates a temporary storage from executable file\n  *\n@@ -32,5 +33,6 @@ class TableFunctionExecutable : public ITableFunction\n     String format;\n     String structure;\n     std::vector<ASTPtr> input_queries;\n+    ASTPtr settings_query = nullptr;\n };\n }\n",
  "test_patch": "diff --git a/tests/integration/test_executable_table_function/test.py b/tests/integration/test_executable_table_function/test.py\nindex e3ac11eef87e..801a3c7c14af 100644\n--- a/tests/integration/test_executable_table_function/test.py\n+++ b/tests/integration/test_executable_table_function/test.py\n@@ -163,6 +163,19 @@ def test_executable_function_input_multiple_pipes_python(started_cluster):\n     assert actual == expected\n \n \n+def test_executable_function_input_slow_python_timeout_increased(started_cluster):\n+    skip_test_msan(node)\n+    query = \"SELECT * FROM executable('input_slow.py', 'TabSeparated', 'value String', {source}, SETTINGS {settings})\"\n+    settings = \"command_termination_timeout = 26, command_read_timeout = 26000, command_write_timeout = 26000\"\n+    assert node.query(query.format(source=\"(SELECT 1)\", settings=settings)) == \"Key 1\\n\"\n+    assert (\n+        node.query(\n+            query.format(source=\"(SELECT id FROM test_data_table)\", settings=settings)\n+        )\n+        == \"Key 0\\nKey 1\\nKey 2\\n\"\n+    )\n+\n+\n def test_executable_storage_no_input_bash(started_cluster):\n     skip_test_msan(node)\n     node.query(\"DROP TABLE IF EXISTS test_table\")\n",
  "problem_statement": "`executable()` table function has no way to set up settings available in Executable storage\nExecutable settings like `max_command_execution_time` or `command_termination_timeout` cannot be set for `executable()` table function at all. Which means that the hardcoded values will be used.\r\nI suggest to add it to executable function definition.\r\nThe simplest way is:\r\n```\r\nSELECT * FROM executable('<script name>', '<format>', (SET max_command_execution_time=100), (SELECT * FROM table))\r\n```\r\nAs executable constructor already parses input `SELECT` statements anyway, adding `SET` statement there seems pretty logical.\r\nIdeas? Any other better API?\r\nI can implement that one.\n",
  "hints_text": "",
  "created_at": "2022-07-28T17:59:19Z",
  "modified_files": [
    "src/Parsers/ExpressionListParsers.cpp",
    "src/TableFunctions/TableFunctionExecutable.cpp",
    "src/TableFunctions/TableFunctionExecutable.h"
  ],
  "modified_test_files": [
    "tests/integration/test_executable_table_function/test.py"
  ]
}