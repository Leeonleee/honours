diff --git a/src/Functions/reverse.cpp b/src/Functions/reverse.cpp
index d692c42d847d..7dbe324b734d 100644
--- a/src/Functions/reverse.cpp
+++ b/src/Functions/reverse.cpp
@@ -1,11 +1,14 @@
-#include <DataTypes/DataTypeString.h>
-#include <Columns/ColumnFixedString.h>
+#include <Functions/reverse.h>
+
 #include <Columns/ColumnArray.h>
+#include <Columns/ColumnFixedString.h>
+#include <Columns/ColumnTuple.h>
+#include <DataTypes/DataTypeString.h>
+#include <DataTypes/DataTypeTuple.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/FunctionHelpers.h>
 #include <Functions/IFunctionAdaptors.h>
 #include <base/map.h>
-#include "reverse.h"
 
 
 namespace DB
@@ -46,11 +49,32 @@ class FunctionReverse : public IFunction
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
-        if (!isStringOrFixedString(arguments[0])
-            && !isArray(arguments[0]))
+        if (!isStringOrFixedString(arguments[0]) && !isArray(arguments[0]) && !isTuple(arguments[0]))
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type {} of argument of function {}",
                 arguments[0]->getName(), getName());
 
+        if (isTuple(arguments[0]))
+        {
+            const auto & data_type_tuple = checkAndGetDataType<DataTypeTuple>(*arguments[0]);
+            const auto & original_elements = data_type_tuple.getElements();
+            const size_t element_count = original_elements.size();
+
+            DataTypes reversed_types;
+            reversed_types.reserve(element_count);
+            reversed_types.assign(original_elements.rbegin(), original_elements.rend());
+
+            if (data_type_tuple.haveExplicitNames())
+            {
+                const auto & original_names = data_type_tuple.getElementNames();
+                Names reversed_names;
+                reversed_names.reserve(element_count);
+                reversed_names.assign(original_names.rbegin(), original_names.rend());
+                return std::make_shared<DataTypeTuple>(reversed_types, reversed_names);
+            }
+
+            return std::make_shared<DataTypeTuple>(reversed_types);
+        }
+
         return arguments[0];
     }
 
@@ -71,6 +95,16 @@ class FunctionReverse : public IFunction
             ReverseImpl::vectorFixed(col_fixed->getChars(), col_fixed->getN(), col_res->getChars(), input_rows_count);
             return col_res;
         }
+        if (const ColumnTuple * col_tuple = checkAndGetColumn<ColumnTuple>(column.get()))
+        {
+            size_t tuple_size = col_tuple->tupleSize();
+            Columns tuple_columns(tuple_size);
+            for (size_t i = 0; i < tuple_size; ++i)
+            {
+                tuple_columns[i] = col_tuple->getColumnPtr(tuple_size - i - 1);
+            }
+            return ColumnTuple::create(tuple_columns);
+        }
         throw Exception(
             ErrorCodes::ILLEGAL_COLUMN, "Illegal column {} of argument of function {}", arguments[0].column->getName(), getName());
     }
@@ -99,10 +133,7 @@ class ReverseOverloadResolver : public IFunctionOverloadResolver
             return_type);
     }
 
-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
-    {
-        return arguments.at(0);
-    }
+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override { return FunctionReverse{}.getReturnTypeImpl(arguments); }
 
 private:
     ContextPtr context;
