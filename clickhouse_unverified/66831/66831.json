{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 66831,
  "instance_id": "ClickHouse__ClickHouse-66831",
  "issue_numbers": [
    "66638"
  ],
  "base_commit": "08db9fb8f1b08461c2993c7fd4f507340c4eaf92",
  "patch": "diff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 34c59ecab086..5f745f3ccada 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -1954,7 +1954,10 @@ struct ToRelativeSubsecondNumImpl\n             return t.value;\n         if (scale > scale_multiplier)\n             return t.value / (scale / scale_multiplier);\n-        return t.value * (scale_multiplier / scale);\n+        return static_cast<UInt128>(t.value) * static_cast<UInt128>((scale_multiplier / scale));\n+        /// Casting ^^: All integers are Int64, yet if t.value is big enough the multiplication can still\n+        /// overflow which is UB. This place is too low-level and generic to check if t.value is sane.\n+        /// Therefore just let it overflow safely and don't bother further.\n     }\n     static Int64 execute(UInt32 t, const DateLUTImpl &)\n     {\ndiff --git a/src/Functions/dateDiff.cpp b/src/Functions/dateDiff.cpp\nindex 8e8865db7ed2..faab42817ba3 100644\n--- a/src/Functions/dateDiff.cpp\n+++ b/src/Functions/dateDiff.cpp\n@@ -26,8 +26,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ILLEGAL_COLUMN;\n     extern const int BAD_ARGUMENTS;\n }\n@@ -45,84 +43,82 @@ class DateDiffImpl\n \n     template <typename Transform>\n     void dispatchForColumns(\n-        const IColumn & x, const IColumn & y,\n+        const IColumn & col_x, const IColumn & col_y,\n         const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y,\n+        size_t input_rows_count,\n         ColumnInt64::Container & result) const\n     {\n-        if (const auto * x_vec_16 = checkAndGetColumn<ColumnDate>(&x))\n-            dispatchForSecondColumn<Transform>(*x_vec_16, y, timezone_x, timezone_y, result);\n-        else if (const auto * x_vec_32 = checkAndGetColumn<ColumnDateTime>(&x))\n-            dispatchForSecondColumn<Transform>(*x_vec_32, y, timezone_x, timezone_y, result);\n-        else if (const auto * x_vec_32_s = checkAndGetColumn<ColumnDate32>(&x))\n-            dispatchForSecondColumn<Transform>(*x_vec_32_s, y, timezone_x, timezone_y, result);\n-        else if (const auto * x_vec_64 = checkAndGetColumn<ColumnDateTime64>(&x))\n-            dispatchForSecondColumn<Transform>(*x_vec_64, y, timezone_x, timezone_y, result);\n-        else if (const auto * x_const_16 = checkAndGetColumnConst<ColumnDate>(&x))\n-            dispatchConstForSecondColumn<Transform>(x_const_16->getValue<UInt16>(), y, timezone_x, timezone_y, result);\n-        else if (const auto * x_const_32 = checkAndGetColumnConst<ColumnDateTime>(&x))\n-            dispatchConstForSecondColumn<Transform>(x_const_32->getValue<UInt32>(), y, timezone_x, timezone_y, result);\n-        else if (const auto * x_const_32_s = checkAndGetColumnConst<ColumnDate32>(&x))\n-            dispatchConstForSecondColumn<Transform>(x_const_32_s->getValue<Int32>(), y, timezone_x, timezone_y, result);\n-        else if (const auto * x_const_64 = checkAndGetColumnConst<ColumnDateTime64>(&x))\n-            dispatchConstForSecondColumn<Transform>(x_const_64->getValue<DecimalField<DateTime64>>(), y, timezone_x, timezone_y, result);\n+        if (const auto * x_vec_16 = checkAndGetColumn<ColumnDate>(&col_x))\n+            dispatchForSecondColumn<Transform>(*x_vec_16, col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_vec_32 = checkAndGetColumn<ColumnDateTime>(&col_x))\n+            dispatchForSecondColumn<Transform>(*x_vec_32, col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_vec_32_s = checkAndGetColumn<ColumnDate32>(&col_x))\n+            dispatchForSecondColumn<Transform>(*x_vec_32_s, col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_vec_64 = checkAndGetColumn<ColumnDateTime64>(&col_x))\n+            dispatchForSecondColumn<Transform>(*x_vec_64, col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_const_16 = checkAndGetColumnConst<ColumnDate>(&col_x))\n+            dispatchConstForSecondColumn<Transform>(x_const_16->getValue<UInt16>(), col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_const_32 = checkAndGetColumnConst<ColumnDateTime>(&col_x))\n+            dispatchConstForSecondColumn<Transform>(x_const_32->getValue<UInt32>(), col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_const_32_s = checkAndGetColumnConst<ColumnDate32>(&col_x))\n+            dispatchConstForSecondColumn<Transform>(x_const_32_s->getValue<Int32>(), col_y, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * x_const_64 = checkAndGetColumnConst<ColumnDateTime64>(&col_x))\n+            dispatchConstForSecondColumn<Transform>(x_const_64->getValue<DecimalField<DateTime64>>(), col_y, timezone_x, timezone_y, input_rows_count, result);\n         else\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                \"Illegal column for first argument of function {}, must be Date, Date32, DateTime or DateTime64\",\n-                name);\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column for first argument of function {}, must be Date, Date32, DateTime or DateTime64\", name);\n     }\n \n     template <typename Transform, typename LeftColumnType>\n     void dispatchForSecondColumn(\n-        const LeftColumnType & x, const IColumn & y,\n+        const LeftColumnType & x, const IColumn & col_y,\n         const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y,\n+        size_t input_rows_count,\n         ColumnInt64::Container & result) const\n     {\n-        if (const auto * y_vec_16 = checkAndGetColumn<ColumnDate>(&y))\n-            vectorVector<Transform>(x, *y_vec_16, timezone_x, timezone_y, result);\n-        else if (const auto * y_vec_32 = checkAndGetColumn<ColumnDateTime>(&y))\n-            vectorVector<Transform>(x, *y_vec_32, timezone_x, timezone_y, result);\n-        else if (const auto * y_vec_32_s = checkAndGetColumn<ColumnDate32>(&y))\n-            vectorVector<Transform>(x, *y_vec_32_s, timezone_x, timezone_y, result);\n-        else if (const auto * y_vec_64 = checkAndGetColumn<ColumnDateTime64>(&y))\n-            vectorVector<Transform>(x, *y_vec_64, timezone_x, timezone_y, result);\n-        else if (const auto * y_const_16 = checkAndGetColumnConst<ColumnDate>(&y))\n-            vectorConstant<Transform>(x, y_const_16->getValue<UInt16>(), timezone_x, timezone_y, result);\n-        else if (const auto * y_const_32 = checkAndGetColumnConst<ColumnDateTime>(&y))\n-            vectorConstant<Transform>(x, y_const_32->getValue<UInt32>(), timezone_x, timezone_y, result);\n-        else if (const auto * y_const_32_s = checkAndGetColumnConst<ColumnDate32>(&y))\n-            vectorConstant<Transform>(x, y_const_32_s->getValue<Int32>(), timezone_x, timezone_y, result);\n-        else if (const auto * y_const_64 = checkAndGetColumnConst<ColumnDateTime64>(&y))\n-            vectorConstant<Transform>(x, y_const_64->getValue<DecimalField<DateTime64>>(), timezone_x, timezone_y, result);\n+        if (const auto * y_vec_16 = checkAndGetColumn<ColumnDate>(&col_y))\n+            vectorVector<Transform>(x, *y_vec_16, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_vec_32 = checkAndGetColumn<ColumnDateTime>(&col_y))\n+            vectorVector<Transform>(x, *y_vec_32, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_vec_32_s = checkAndGetColumn<ColumnDate32>(&col_y))\n+            vectorVector<Transform>(x, *y_vec_32_s, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_vec_64 = checkAndGetColumn<ColumnDateTime64>(&col_y))\n+            vectorVector<Transform>(x, *y_vec_64, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_const_16 = checkAndGetColumnConst<ColumnDate>(&col_y))\n+            vectorConstant<Transform>(x, y_const_16->getValue<UInt16>(), timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_const_32 = checkAndGetColumnConst<ColumnDateTime>(&col_y))\n+            vectorConstant<Transform>(x, y_const_32->getValue<UInt32>(), timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_const_32_s = checkAndGetColumnConst<ColumnDate32>(&col_y))\n+            vectorConstant<Transform>(x, y_const_32_s->getValue<Int32>(), timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_const_64 = checkAndGetColumnConst<ColumnDateTime64>(&col_y))\n+            vectorConstant<Transform>(x, y_const_64->getValue<DecimalField<DateTime64>>(), timezone_x, timezone_y, input_rows_count, result);\n         else\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                \"Illegal column for second argument of function {}, must be Date, Date32, DateTime or DateTime64\",\n-                name);\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column for second argument of function {}, must be Date, Date32, DateTime or DateTime64\", name);\n     }\n \n     template <typename Transform, typename T1>\n     void dispatchConstForSecondColumn(\n-        T1 x, const IColumn & y,\n+        T1 x, const IColumn & col_y,\n         const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y,\n+        size_t input_rows_count,\n         ColumnInt64::Container & result) const\n     {\n-        if (const auto * y_vec_16 = checkAndGetColumn<ColumnDate>(&y))\n-            constantVector<Transform>(x, *y_vec_16, timezone_x, timezone_y, result);\n-        else if (const auto * y_vec_32 = checkAndGetColumn<ColumnDateTime>(&y))\n-            constantVector<Transform>(x, *y_vec_32, timezone_x, timezone_y, result);\n-        else if (const auto * y_vec_32_s = checkAndGetColumn<ColumnDate32>(&y))\n-            constantVector<Transform>(x, *y_vec_32_s, timezone_x, timezone_y, result);\n-        else if (const auto * y_vec_64 = checkAndGetColumn<ColumnDateTime64>(&y))\n-            constantVector<Transform>(x, *y_vec_64, timezone_x, timezone_y, result);\n+        if (const auto * y_vec_16 = checkAndGetColumn<ColumnDate>(&col_y))\n+            constantVector<Transform>(x, *y_vec_16, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_vec_32 = checkAndGetColumn<ColumnDateTime>(&col_y))\n+            constantVector<Transform>(x, *y_vec_32, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_vec_32_s = checkAndGetColumn<ColumnDate32>(&col_y))\n+            constantVector<Transform>(x, *y_vec_32_s, timezone_x, timezone_y, input_rows_count, result);\n+        else if (const auto * y_vec_64 = checkAndGetColumn<ColumnDateTime64>(&col_y))\n+            constantVector<Transform>(x, *y_vec_64, timezone_x, timezone_y, input_rows_count, result);\n         else\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                \"Illegal column for second argument of function {}, must be Date, Date32, DateTime or DateTime64\",\n-                name);\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column for second argument of function {}, must be Date, Date32, DateTime or DateTime64\", name);\n     }\n \n     template <typename Transform, typename LeftColumnType, typename RightColumnType>\n     void vectorVector(\n         const LeftColumnType & x, const RightColumnType & y,\n         const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y,\n+        size_t input_rows_count,\n         ColumnInt64::Container & result) const\n     {\n         const auto & x_data = x.getData();\n@@ -130,14 +126,15 @@ class DateDiffImpl\n \n         const auto transform_x = TransformDateTime64<Transform>(getScale(x));\n         const auto transform_y = TransformDateTime64<Transform>(getScale(y));\n-        for (size_t i = 0, size = x.size(); i < size; ++i)\n-                result[i] = calculate(transform_x, transform_y, x_data[i], y_data[i], timezone_x, timezone_y);\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+            result[i] = calculate(transform_x, transform_y, x_data[i], y_data[i], timezone_x, timezone_y);\n     }\n \n     template <typename Transform, typename LeftColumnType, typename T2>\n     void vectorConstant(\n         const LeftColumnType & x, T2 y,\n         const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y,\n+        size_t input_rows_count,\n         ColumnInt64::Container & result) const\n     {\n         const auto & x_data = x.getData();\n@@ -145,7 +142,7 @@ class DateDiffImpl\n         const auto transform_y = TransformDateTime64<Transform>(getScale(y));\n         const auto y_value = stripDecimalFieldValue(y);\n \n-        for (size_t i = 0, size = x.size(); i < size; ++i)\n+        for (size_t i = 0; i < input_rows_count; ++i)\n             result[i] = calculate(transform_x, transform_y, x_data[i], y_value, timezone_x, timezone_y);\n     }\n \n@@ -153,6 +150,7 @@ class DateDiffImpl\n     void constantVector(\n         T1 x, const RightColumnType & y,\n         const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y,\n+        size_t input_rows_count,\n         ColumnInt64::Container & result) const\n     {\n         const auto & y_data = y.getData();\n@@ -160,20 +158,22 @@ class DateDiffImpl\n         const auto transform_y = TransformDateTime64<Transform>(getScale(y));\n         const auto x_value = stripDecimalFieldValue(x);\n \n-        for (size_t i = 0, size = y.size(); i < size; ++i)\n+        for (size_t i = 0; i < input_rows_count; ++i)\n             result[i] = calculate(transform_x, transform_y, x_value, y_data[i], timezone_x, timezone_y);\n     }\n \n     template <typename TransformX, typename TransformY, typename T1, typename T2>\n     Int64 calculate(const TransformX & transform_x, const TransformY & transform_y, T1 x, T2 y, const DateLUTImpl & timezone_x, const DateLUTImpl & timezone_y) const\n     {\n+        auto res =  static_cast<Int64>(transform_y.execute(y, timezone_y)) - static_cast<Int64>(transform_x.execute(x, timezone_x));\n+\n         if constexpr (is_diff)\n-            return static_cast<Int64>(transform_y.execute(y, timezone_y))\n-                - static_cast<Int64>(transform_x.execute(x, timezone_x));\n+        {\n+            return res;\n+        }\n         else\n         {\n-            auto res = static_cast<Int64>(transform_y.execute(y, timezone_y))\n-                - static_cast<Int64>(transform_x.execute(x, timezone_x));\n+            /// Adjust res:\n             DateTimeComponentsWithFractionalPart a_comp;\n             DateTimeComponentsWithFractionalPart b_comp;\n             Int64 adjust_value;\n@@ -332,95 +332,73 @@ class FunctionDateDiff : public IFunction\n     static constexpr auto name = is_relative ? \"dateDiff\" : \"age\";\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionDateDiff>(); }\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n+    String getName() const override { return name; }\n \n     bool isVariadic() const override { return true; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n     size_t getNumberOfArguments() const override { return 0; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0, 3}; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.size() != 3 && arguments.size() != 4)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be 3 or 4\",\n-                getName(), arguments.size());\n-\n-        if (!isString(arguments[0]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"First argument for function {} (unit) must be String\",\n-                getName());\n-\n-        if (!isDate(arguments[1]) && !isDate32(arguments[1]) && !isDateTime(arguments[1]) && !isDateTime64(arguments[1]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Second argument for function {} must be Date, Date32, DateTime or DateTime64\",\n-                getName());\n-\n-        if (!isDate(arguments[2]) && !isDate32(arguments[2]) && !isDateTime(arguments[2]) && !isDateTime64(arguments[2]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Third argument for function {} must be Date, Date32, DateTime or DateTime64\",\n-                getName()\n-                );\n-\n-        if (arguments.size() == 4 && !isString(arguments[3]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Fourth argument for function {} (timezone) must be String\",\n-                getName());\n+        FunctionArgumentDescriptors mandatory_args{\n+            {\"unit\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"},\n+            {\"startdate\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isDateOrDate32OrDateTimeOrDateTime64), nullptr, \"Date[32] or DateTime[64]\"},\n+            {\"enddate\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isDateOrDate32OrDateTimeOrDateTime64), nullptr, \"Date[32] or DateTime[64]\"},\n+        };\n+\n+        FunctionArgumentDescriptors optional_args{\n+            {\"timezone\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isString), nullptr, \"String\"},\n+        };\n+\n+        validateFunctionArguments(*this, arguments, mandatory_args, optional_args);\n \n         return std::make_shared<DataTypeInt64>();\n     }\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0, 3}; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        const auto * unit_column = checkAndGetColumnConst<ColumnString>(arguments[0].column.get());\n-        if (!unit_column)\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                \"First argument for function {} must be constant String\",\n-                getName());\n+        const auto * col_unit = checkAndGetColumnConst<ColumnString>(arguments[0].column.get());\n+        if (!col_unit)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"First argument for function {} must be constant String\", getName());\n \n-        String unit = Poco::toLower(unit_column->getValue<String>());\n+        String unit = Poco::toLower(col_unit->getValue<String>());\n \n-        const IColumn & x = *arguments[1].column;\n-        const IColumn & y = *arguments[2].column;\n+        const IColumn & col_x = *arguments[1].column;\n+        const IColumn & col_y = *arguments[2].column;\n \n-        size_t rows = input_rows_count;\n-        auto res = ColumnInt64::create(rows);\n+        auto col_res = ColumnInt64::create(input_rows_count);\n \n         const auto & timezone_x = extractTimeZoneFromFunctionArguments(arguments, 3, 1);\n         const auto & timezone_y = extractTimeZoneFromFunctionArguments(arguments, 3, 2);\n \n         if (unit == \"year\" || unit == \"years\" || unit == \"yy\" || unit == \"yyyy\")\n-            impl.template dispatchForColumns<ToRelativeYearNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeYearNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"quarter\" || unit == \"quarters\" || unit == \"qq\" || unit == \"q\")\n-            impl.template dispatchForColumns<ToRelativeQuarterNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeQuarterNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"month\" || unit == \"months\" || unit == \"mm\" || unit == \"m\")\n-            impl.template dispatchForColumns<ToRelativeMonthNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeMonthNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"week\" || unit == \"weeks\" || unit == \"wk\" || unit == \"ww\")\n-            impl.template dispatchForColumns<ToRelativeWeekNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeWeekNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"day\" || unit == \"days\" || unit == \"dd\" || unit == \"d\")\n-            impl.template dispatchForColumns<ToRelativeDayNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeDayNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"hour\" || unit == \"hours\" || unit == \"hh\" || unit == \"h\")\n-            impl.template dispatchForColumns<ToRelativeHourNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeHourNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"minute\" || unit == \"minutes\" || unit == \"mi\" || unit == \"n\")\n-            impl.template dispatchForColumns<ToRelativeMinuteNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeMinuteNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"second\" || unit == \"seconds\" || unit == \"ss\" || unit == \"s\")\n-            impl.template dispatchForColumns<ToRelativeSecondNumImpl<ResultPrecision::Extended>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeSecondNumImpl<ResultPrecision::Extended>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"millisecond\" || unit == \"milliseconds\" || unit == \"ms\")\n-            impl.template dispatchForColumns<ToRelativeSubsecondNumImpl<millisecond_multiplier>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeSubsecondNumImpl<millisecond_multiplier>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"microsecond\" || unit == \"microseconds\" || unit == \"us\" || unit == \"u\")\n-            impl.template dispatchForColumns<ToRelativeSubsecondNumImpl<microsecond_multiplier>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeSubsecondNumImpl<microsecond_multiplier>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else if (unit == \"nanosecond\" || unit == \"nanoseconds\" || unit == \"ns\")\n-            impl.template dispatchForColumns<ToRelativeSubsecondNumImpl<nanosecond_multiplier>>(x, y, timezone_x, timezone_y, res->getData());\n+            impl.template dispatchForColumns<ToRelativeSubsecondNumImpl<nanosecond_multiplier>>(col_x, col_y, timezone_x, timezone_y, input_rows_count, col_res->getData());\n         else\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"Function {} does not support '{}' unit\", getName(), unit);\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Function {} does not support '{}' unit\", getName(), unit);\n \n-        return res;\n+        return col_res;\n     }\n private:\n     DateDiffImpl<is_relative> impl{name};\n@@ -437,50 +415,35 @@ class FunctionTimeDiff : public IFunction\n     static constexpr auto name = \"timeDiff\";\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTimeDiff>(); }\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n+    String getName() const override { return name; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {}; }\n     bool isVariadic() const override { return false; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n     size_t getNumberOfArguments() const override { return 2; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        if (arguments.size() != 2)\n-            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                \"Number of arguments for function {} doesn't match: passed {}, should be 2\",\n-                getName(), arguments.size());\n-\n-        if (!isDate(arguments[0]) && !isDate32(arguments[0]) && !isDateTime(arguments[0]) && !isDateTime64(arguments[0]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"First argument for function {} must be Date, Date32, DateTime or DateTime64\",\n-                getName());\n-\n-        if (!isDate(arguments[1]) && !isDate32(arguments[1]) && !isDateTime(arguments[1]) && !isDateTime64(arguments[1]))\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"Second argument for function {} must be Date, Date32, DateTime or DateTime64\",\n-                getName()\n-                );\n+        FunctionArgumentDescriptors args{\n+            {\"first_datetime\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isDateOrDate32OrDateTimeOrDateTime64), nullptr, \"Date[32] or DateTime[64]\"},\n+            {\"second_datetime\", static_cast<FunctionArgumentDescriptor::TypeValidator>(&isDateOrDate32OrDateTimeOrDateTime64), nullptr, \"Date[32] or DateTime[64]\"},\n+        };\n+\n+        validateFunctionArguments(*this, arguments, args);\n \n         return std::make_shared<DataTypeInt64>();\n     }\n \n-    bool useDefaultImplementationForConstants() const override { return true; }\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {}; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        const IColumn & x = *arguments[0].column;\n-        const IColumn & y = *arguments[1].column;\n+        const IColumn & col_x = *arguments[0].column;\n+        const IColumn & col_y = *arguments[1].column;\n \n-        size_t rows = input_rows_count;\n-        auto res = ColumnInt64::create(rows);\n+        auto col_res = ColumnInt64::create(input_rows_count);\n \n-        impl.dispatchForColumns<ToRelativeSecondNumImpl<ResultPrecision::Extended>>(x, y, DateLUT::instance(), DateLUT::instance(), res->getData());\n+        impl.dispatchForColumns<ToRelativeSecondNumImpl<ResultPrecision::Extended>>(col_x, col_y, DateLUT::instance(), DateLUT::instance(), input_rows_count, col_res->getData());\n \n-        return res;\n+        return col_res;\n     }\n private:\n     DateDiffImpl<true> impl{name};\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02477_age_datetime64.reference b/tests/queries/0_stateless/02477_age_datetime64.reference\nindex 3b4459dd26d8..fb085f461c93 100644\n--- a/tests/queries/0_stateless/02477_age_datetime64.reference\n+++ b/tests/queries/0_stateless/02477_age_datetime64.reference\n@@ -111,3 +111,8 @@ SELECT age('day', materialize(toDateTime64('2015-08-18 00:00:00', 0, 'UTC')), ma\n 1\n SELECT age('day', materialize(toDate('2015-08-18', 'UTC')), materialize(toDateTime64('2015-08-19 00:00:00', 3, 'UTC')));\n 1\n+-- UBsan bug #66638\n+set session_timezone = 'UTC';\n+SELECT age('second', toDateTime(1157339245694594829, 6, 'UTC'), toDate('2015-08-18'))\n+\n+-8973935999\ndiff --git a/tests/queries/0_stateless/02477_age_datetime64.sql b/tests/queries/0_stateless/02477_age_datetime64.sql\nindex 1bed93991ca7..b5fa4da88377 100644\n--- a/tests/queries/0_stateless/02477_age_datetime64.sql\n+++ b/tests/queries/0_stateless/02477_age_datetime64.sql\n@@ -75,3 +75,7 @@ SELECT age('second', materialize(toDateTime64('2015-08-18 00:00:00', 0, 'UTC')),\n SELECT age('second', materialize(toDateTime('2015-08-18 00:00:00', 'UTC')), materialize(toDateTime64('2015-08-18 00:00:10', 3, 'UTC')));\n SELECT age('day', materialize(toDateTime64('2015-08-18 00:00:00', 0, 'UTC')), materialize(toDate('2015-08-19', 'UTC')));\n SELECT age('day', materialize(toDate('2015-08-18', 'UTC')), materialize(toDateTime64('2015-08-19 00:00:00', 3, 'UTC')));\n+\n+-- UBsan bug #66638\n+set session_timezone = 'UTC';\n+SELECT age('second', toDateTime(1157339245694594829, 6, 'UTC'), toDate('2015-08-18'))\n",
  "problem_statement": "`signed integer overflow` in `age` function\nhttps://s3.amazonaws.com/clickhouse-test-reports/56626/35725b666f6afdf115aa977fadd15d2076cba020/ast_fuzzer__ubsan_.html\r\n\r\n```\r\n/build/src/Functions/DateTimeTransforms.h:1957:24: runtime error: signed integer overflow: 10413791999000000 * 1000 cannot be represented in type 'long'\r\n    #0 0x556384ad4eaf in long DB::(anonymous namespace)::DateDiffImpl<false>::calculate<DB::TransformDateTime64<DB::ToRelativeSecondNumImpl<(DB::ResultPrecision)1>>, DB::TransformDateTime64<DB::ToRelativeSecondNumImpl<(DB::ResultPrecision)1>>, DB::DateTime64, DB::DateTime64>(DB::TransformDateTime64<DB::ToRelativeSecondNumImpl<(DB::ResultPrecision)1>> const&, DB::TransformDateTime64<DB::ToRelativeSecondNumImpl<(DB::ResultPrecision)1>> const&, DB::DateTime64, DB::DateTime64, DateLUTImpl const&, DateLUTImpl const&) const dateDiff.cpp\r\n    #1 0x556384a73474 in void DB::(anonymous namespace)::DateDiffImpl<false>::dispatchForColumns<DB::ToRelativeSecondNumImpl<(DB::ResultPrecision)1>>(DB::IColumn const&, DB::IColumn const&, DateLUTImpl const&, DateLUTImpl const&, DB::PODArray<long, 4096ul, Allocator<false, false>, 63ul, 64ul>&) const dateDiff.cpp\r\n    #2 0x556384a45cac in DB::(anonymous namespace)::FunctionDateDiff<false>::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const dateDiff.cpp\r\n    #3 0x556381da5245 in DB::IFunction::executeImplDryRun(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const (/workspace/clickhouse+0x18818245) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #4 0x556381dd2af8 in DB::FunctionToExecutableFunctionAdaptor::executeDryRunImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const (/workspace/clickhouse+0x18845af8) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #5 0x5563835581e2 in DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fcb1e2) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #6 0x5563835586fa in DB::IExecutableFunction::defaultImplementationForNulls(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fcb6fa) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #7 0x556383558161 in DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fcb161) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #8 0x5563835578bb in DB::IExecutableFunction::defaultImplementationForConstantArguments(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fca8bb) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #9 0x5563835580eb in DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fcb0eb) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #10 0x556383559d48 in DB::IExecutableFunction::executeWithoutSparseColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fccd48) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #11 0x55638355b627 in DB::IExecutableFunction::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName>> const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const (/workspace/clickhouse+0x19fce627) (BuildId: 0ad7d269b487dfdb589935d1efcf94f4065c3b09)\r\n    #12 0x55639a43530e in DB::QueryAnalyzer::resolveFunction(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&) build_docker/./src/Analyzer/Resolve/QueryAnalyzer.cpp:3436:47\r\n    #13 0x55639a405dc7 in DB::QueryAnalyzer::resolveExpressionNode(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool, bool) build_docker/./src/Analyzer/Resolve/QueryAnalyzer.cpp:3736:46\r\n    #14 0x55639a40472c in DB::QueryAnalyzer::resolveExpressionNodeList(std::__1::shared_ptr<DB::IQueryTreeNode>&, DB::IdentifierResolveScope&, bool, bool) build_docker/./src/Analyzer/Resolve/QueryAnalyzer.cpp:3890:49\r\n    #15 0x55639a44e69b in DB::QueryAnalyzer::resolveGroupByNode(DB::QueryNode&, DB::IdentifierResolveScope&) build_docker/./src/Analyzer/Resolve/QueryAnalyzer.cpp:4085:9\r\n    #16 0x55639a3f8845 in DB::QueryAnalyzer::resolveQuery(std::__1::shared_ptr<DB::IQueryTreeNode> const&, DB::IdentifierResolveScope&) build_docker/./src/Analyzer/Resolve/QueryAnalyzer.cpp:5426:9\r\n    #17 0x55639a3f5758 in DB::QueryAnalyzer::resolve(std::__1::shared_ptr<DB::IQueryTreeNode>&, std::__1::shared_ptr<DB::IQueryTreeNode> const&, std::__1::shared_ptr<DB::Context const>) build_docker/./src/Analyzer/Resolve/QueryAnalyzer.cpp:137:13\r\n    #18 0x55639a3f4ecb in DB::QueryAnalysisPass::run(std::__1::shared_ptr<DB::IQueryTreeNode>&, std::__1::shared_ptr<DB::Context const>) build_docker/./src/Analyzer/Resolve/QueryAnalysisPass.cpp:18:14\r\n    #19 0x55639a3ed910 in DB::QueryTreePassManager::run(std::__1::shared_ptr<DB::IQueryTreeNode>) build_docker/./src/Analyzer/QueryTreePassManager.cpp:185:20\r\n    #20 0x55639a69260b in DB::(anonymous namespace)::buildQueryTreeAndRunPasses(std::__1::shared_ptr<DB::IAST> const&, DB::SelectQueryOptions const&, std::__1::shared_ptr<DB::Context const> const&, std::__1::shared_ptr<DB::IStorage> const&) build_docker/./src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:142:33\r\n    #21 0x55639a68f2bb in DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::Context const> const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>>>> const&) build_docker/./src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:160:18\r\n    #22 0x55639a694b96 in std::__1::__unique_if<DB::InterpreterSelectQueryAnalyzer>::__unique_single std::__1::make_unique[abi:v15007]<DB::InterpreterSelectQueryAnalyzer, std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&>(std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&) build_docker/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:714:32\r\n    #23 0x55639a6941e4 in DB::registerInterpreterSelectQueryAnalyzer(DB::InterpreterFactory&)::$_0::operator()(DB::InterpreterFactory::Arguments const&) const build_docker/./src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:270:16\r\n...\r\n```\r\n\r\nMinimal example to reproduce:\r\n```sql\r\nSELECT age('second', toDateTime(1157339245694594829, 6), toDateTime64('2015-08-18 00:00:10', 3))\r\n```\r\n\r\nThe problem is obvious but I'm not sure how do we handle overflows in such functions so maybe @rschu1ze you can give some opinions here.\r\nI'm okay with simply throwing exception if the value is going to overflow.\n",
  "hints_text": "I'll take a look.",
  "created_at": "2024-07-21T17:27:40Z"
}