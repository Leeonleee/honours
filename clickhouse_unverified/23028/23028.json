{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 23028,
  "instance_id": "ClickHouse__ClickHouse-23028",
  "issue_numbers": [
    "21330"
  ],
  "base_commit": "cd1e72e312de0af9b5982137dea7f7f9bdbff16f",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex db36a5b5637b..f54ef635e0c8 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -322,7 +322,7 @@ Truncates sub-seconds.\n **Syntax**\n \n ``` sql\n-toStartOfSecond(value[, timezone])\n+toStartOfSecond(value, [timezone])\n ```\n \n **Arguments**\ndiff --git a/docs/en/sql-reference/functions/type-conversion-functions.md b/docs/en/sql-reference/functions/type-conversion-functions.md\nindex 9b41042c6599..19fa41c56cbf 100644\n--- a/docs/en/sql-reference/functions/type-conversion-functions.md\n+++ b/docs/en/sql-reference/functions/type-conversion-functions.md\n@@ -90,6 +90,27 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toInt(8\\|16\\|32\\|64\\|128\\|256)OrDefault {#toint8163264128256orDefault}\n+\n+It takes an argument of type String and tries to parse it into Int (8 \\| 16 \\| 32 \\| 64 \\| 128 \\| 256). If failed, returns the default type value.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT toInt64OrDefault('123123', cast('-1' as Int64)), toInt8OrDefault('123qwe123', cast('-1' as Int8));\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500toInt64OrDefault('123123', CAST('-1', 'Int64'))\u2500\u252c\u2500toInt8OrDefault('123qwe123', CAST('-1', 'Int8'))\u2500\u2510\n+\u2502                                          123123 \u2502                                               -1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\n ## toUInt(8\\|16\\|32\\|64\\|256) {#touint8163264256}\n \n Converts an input value to the [UInt](../../sql-reference/data-types/int-uint.md) data type. This function family includes:\n@@ -132,12 +153,16 @@ Result:\n \n ## toUInt(8\\|16\\|32\\|64\\|256)OrNull {#touint8163264256ornull}\n \n+## toUInt(8\\|16\\|32\\|64\\|256)OrDefault {#touint8163264256ordefault}\n+\n ## toFloat(32\\|64) {#tofloat3264}\n \n ## toFloat(32\\|64)OrZero {#tofloat3264orzero}\n \n ## toFloat(32\\|64)OrNull {#tofloat3264ornull}\n \n+## toFloat(32\\|64)OrDefault {#tofloat3264ordefault}\n+\n ## toDate {#todate}\n \n Alias: `DATE`.\n@@ -146,23 +171,27 @@ Alias: `DATE`.\n \n ## toDateOrNull {#todateornull}\n \n+## toDateOrDefault {#todateordefault}\n+\n ## toDateTime {#todatetime}\n \n ## toDateTimeOrZero {#todatetimeorzero}\n \n ## toDateTimeOrNull {#todatetimeornull}\n \n+## toDateTimeOrDefault {#todatetimeordefault}\n+\n ## toDate32 {#todate32}\n \n Converts the argument to the [Date32](../../sql-reference/data-types/date32.md) data type. If the value is outside the range returns the border values supported by `Date32`. If the argument has [Date](../../sql-reference/data-types/date.md) type, borders of `Date` are taken into account.\n \n-**Syntax** \n+**Syntax**\n \n ``` sql\n toDate32(expr)\n ```\n \n-**Arguments** \n+**Arguments**\n \n -   `expr` \u2014 The value. [String](../../sql-reference/data-types/string.md), [UInt32](../../sql-reference/data-types/int-uint.md) or [Date](../../sql-reference/data-types/date.md).\n \n@@ -250,6 +279,26 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toDate32OrDefault {#todate32-or-null}\n+\n+The same as [toDate32](#todate32) but returns default value if invalid argument is received.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT toDate32OrDefault('1955-01-01'), toDate32OrDefault('');\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500toDate32OrDefault('1955-01-01')\u2500\u252c\u2500toDate32OrDefault('')\u2500\u2510\n+\u2502                      1955-01-01 \u2502            1970-01-01 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## toDecimal(32\\|64\\|128\\|256) {#todecimal3264128256}\n \n Converts `value` to the [Decimal](../../sql-reference/data-types/decimal.md) data type with precision of `S`. The `value` can be a number or a string. The `S` (scale) parameter specifies the number of decimal places.\n@@ -312,6 +361,60 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+\n+## toDecimal(32\\|64\\|128\\|256)OrDefault {#todecimal3264128256ornull}\n+\n+Converts an input string to a [Decimal(P,S)](../../sql-reference/data-types/decimal.md) data type value. This family of functions include:\n+\n+-   `toDecimal32OrDefault(expr, S)` \u2014 Results in `Decimal32(S)` data type.\n+-   `toDecimal64OrDefault(expr, S)` \u2014 Results in `Decimal64(S)` data type.\n+-   `toDecimal128OrDefault(expr, S)` \u2014 Results in `Decimal128(S)` data type.\n+-   `toDecimal256OrDefault(expr, S)` \u2014 Results in `Decimal256(S)` data type.\n+\n+These functions should be used instead of `toDecimal*()` functions, if you prefer to get a default value instead of an exception in the event of an input value parsing error.\n+\n+**Arguments**\n+\n+-   `expr` \u2014 [Expression](../../sql-reference/syntax.md#syntax-expressions), returns a value in the [String](../../sql-reference/data-types/string.md) data type. ClickHouse expects the textual representation of the decimal number. For example, `'1.111'`.\n+-   `S` \u2014 Scale, the number of decimal places in the resulting value.\n+\n+**Returned value**\n+\n+A value in the `Decimal(P,S)` data type. The value contains:\n+\n+-   Number with `S` decimal places, if ClickHouse interprets the input string as a number.\n+-   Default `Decimal(P,S)` data type value, if ClickHouse can\u2019t interpret the input string as a number or if the input number contains more than `S` decimal places.\n+\n+**Examples**\n+\n+Query:\n+\n+``` sql\n+SELECT toDecimal32OrDefault(toString(-1.111), 5) AS val, toTypeName(val);\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500\u2500\u2500\u2500val\u2500\u252c\u2500toTypeName(toDecimal32OrDefault(toString(-1.111), 5))\u2500\u2510\n+\u2502 -1.111 \u2502 Decimal(9, 5)                                         \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Query:\n+\n+``` sql\n+SELECT toDecimal32OrDefault(toString(-1.111), 2) AS val, toTypeName(val);\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500val\u2500\u252c\u2500toTypeName(toDecimal32OrDefault(toString(-1.111), 2))\u2500\u2510\n+\u2502   0 \u2502 Decimal(9, 2)                                         \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## toDecimal(32\\|64\\|128\\|256)OrZero {#todecimal3264128256orzero}\n \n Converts an input value to the [Decimal(P,S)](../../sql-reference/data-types/decimal.md) data type. This family of functions include:\n@@ -751,6 +854,63 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+\n+## accurateCastOrDefault(x, T[, default_value]) {#type_conversion_function-accurate-cast_or_null}\n+\n+Converts input value `x` to the specified data type `T`. Returns default type value or `default_value` if specified if the casted value is not representable in the target type.\n+\n+**Syntax**\n+\n+```sql\n+accurateCastOrNull(x, T)\n+```\n+\n+**Parameters**\n+\n+-   `x` \u2014 Input value.\n+-   `T` \u2014 The name of the returned data type.\n+-   `default_value` - Default value of returned data type.\n+\n+**Returned value**\n+\n+-   The value, converted to the specified data type `T`.\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT toTypeName(accurateCastOrDefault(5, 'UInt8'));\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500toTypeName(accurateCastOrDefault(5, 'UInt8'))\u2500\u2510\n+\u2502 UInt8                                         \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Query:\n+\n+``` sql\n+SELECT\n+    accurateCastOrDefault(-1, 'UInt8') as uint8,\n+    accurateCastOrDefault(-1, 'UInt8', 5) as uint8_default,\n+    accurateCastOrDefault(128, 'Int8') as int8,\n+    accurateCastOrDefault(128, 'Int8', 5) as int8_default,\n+    accurateCastOrDefault('Test', 'FixedString(2)') as fixed_string,\n+    accurateCastOrDefault('Test', 'FixedString(2)', 'Te') as fixed_string_default;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500uint8\u2500\u252c\u2500uint8_default\u2500\u252c\u2500int8\u2500\u252c\u2500int8_default\u2500\u252c\u2500fixed_string\u2500\u252c\u2500fixed_string_default\u2500\u2510\n+\u2502     0 \u2502             5 \u2502    0 \u2502            5 \u2502              \u2502 Te                   \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## toInterval(Year\\|Quarter\\|Month\\|Week\\|Day\\|Hour\\|Minute\\|Second) {#function-tointerval}\n \n Converts a Number type argument to an [Interval](../../sql-reference/data-types/special-data-types/interval.md) data type.\ndiff --git a/src/Functions/FunctionHelpers.cpp b/src/Functions/FunctionHelpers.cpp\nindex 16dd34d0162b..e44962f4c388 100644\n--- a/src/Functions/FunctionHelpers.cpp\n+++ b/src/Functions/FunctionHelpers.cpp\n@@ -224,14 +224,19 @@ checkAndGetNestedArrayOffset(const IColumn ** columns, size_t num_arguments)\n     return {nested_columns, offsets->data()};\n }\n \n-bool areTypesEqual(const DataTypePtr & lhs, const DataTypePtr & rhs)\n+bool areTypesEqual(const IDataType & lhs, const IDataType & rhs)\n {\n-    const auto & lhs_name = lhs->getName();\n-    const auto & rhs_name = rhs->getName();\n+    const auto & lhs_name = lhs.getName();\n+    const auto & rhs_name = rhs.getName();\n \n     return lhs_name == rhs_name;\n }\n \n+bool areTypesEqual(const DataTypePtr & lhs, const DataTypePtr & rhs)\n+{\n+    return areTypesEqual(*lhs, *rhs);\n+}\n+\n ColumnPtr wrapInNullable(const ColumnPtr & src, const ColumnsWithTypeAndName & args, const DataTypePtr & result_type, size_t input_rows_count)\n {\n     ColumnPtr result_null_map_column;\ndiff --git a/src/Functions/FunctionHelpers.h b/src/Functions/FunctionHelpers.h\nindex 157116210756..8d33c8201855 100644\n--- a/src/Functions/FunctionHelpers.h\n+++ b/src/Functions/FunctionHelpers.h\n@@ -108,8 +108,8 @@ struct FunctionArgumentDescriptor\n {\n     const char * argument_name;\n \n-    bool (* type_validator_func)(const IDataType &);\n-    bool (* column_validator_func)(const IColumn &);\n+    std::function<bool (const IDataType &)> type_validator_func;\n+    std::function<bool (const IColumn &)> column_validator_func;\n \n     const char * expected_type_description;\n \n@@ -155,8 +155,9 @@ void validateFunctionArgumentTypes(const IFunction & func, const ColumnsWithType\n std::pair<std::vector<const IColumn *>, const ColumnArray::Offset *>\n checkAndGetNestedArrayOffset(const IColumn ** columns, size_t num_arguments);\n \n-\n /// Check if two types are equal\n+bool areTypesEqual(const IDataType & lhs, const IDataType & rhs);\n+\n bool areTypesEqual(const DataTypePtr & lhs, const DataTypePtr & rhs);\n \n /** Return ColumnNullable of src, with null map as OR-ed null maps of args columns.\ndiff --git a/src/Functions/FunctionsAES.h b/src/Functions/FunctionsAES.h\nindex d524f3c9b9ac..8feb16c86b6b 100644\n--- a/src/Functions/FunctionsAES.h\n+++ b/src/Functions/FunctionsAES.h\n@@ -156,21 +156,21 @@ class FunctionEncrypt : public IFunction\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         auto optional_args = FunctionArgumentDescriptors{\n-            {\"IV\", isStringOrFixedString, nullptr, \"Initialization vector binary string\"},\n+            {\"IV\", &isStringOrFixedString<IDataType>, nullptr, \"Initialization vector binary string\"},\n         };\n \n         if constexpr (compatibility_mode == OpenSSLDetails::CompatibilityMode::OpenSSL)\n         {\n             optional_args.emplace_back(FunctionArgumentDescriptor{\n-                \"AAD\", isStringOrFixedString, nullptr, \"Additional authenticated data binary string for GCM mode\"\n+                \"AAD\", &isStringOrFixedString<IDataType>, nullptr, \"Additional authenticated data binary string for GCM mode\"\n             });\n         }\n \n         validateFunctionArgumentTypes(*this, arguments,\n             FunctionArgumentDescriptors{\n-                {\"mode\", isStringOrFixedString, isColumnConst, \"encryption mode string\"},\n-                {\"input\", isStringOrFixedString, nullptr, \"plaintext\"},\n-                {\"key\", isStringOrFixedString, nullptr, \"encryption key binary string\"},\n+                {\"mode\", &isStringOrFixedString<IDataType>, isColumnConst, \"encryption mode string\"},\n+                {\"input\", &isStringOrFixedString<IDataType>, nullptr, \"plaintext\"},\n+                {\"key\", &isStringOrFixedString<IDataType>, nullptr, \"encryption key binary string\"},\n             },\n             optional_args\n         );\n@@ -432,21 +432,21 @@ class FunctionDecrypt : public IFunction\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         auto optional_args = FunctionArgumentDescriptors{\n-            {\"IV\", isStringOrFixedString, nullptr, \"Initialization vector binary string\"},\n+            {\"IV\", &isStringOrFixedString<IDataType>, nullptr, \"Initialization vector binary string\"},\n         };\n \n         if constexpr (compatibility_mode == OpenSSLDetails::CompatibilityMode::OpenSSL)\n         {\n             optional_args.emplace_back(FunctionArgumentDescriptor{\n-                \"AAD\", isStringOrFixedString, nullptr, \"Additional authenticated data binary string for GCM mode\"\n+                \"AAD\", &isStringOrFixedString<IDataType>, nullptr, \"Additional authenticated data binary string for GCM mode\"\n             });\n         }\n \n         validateFunctionArgumentTypes(*this, arguments,\n             FunctionArgumentDescriptors{\n-                {\"mode\", isStringOrFixedString, isColumnConst, \"decryption mode string\"},\n+                {\"mode\", &isStringOrFixedString<IDataType>, isColumnConst, \"decryption mode string\"},\n                 {\"input\", nullptr, nullptr, \"ciphertext\"},\n-                {\"key\", isStringOrFixedString, nullptr, \"decryption key binary string\"},\n+                {\"key\", &isStringOrFixedString<IDataType>, nullptr, \"decryption key binary string\"},\n             },\n             optional_args\n         );\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 6ba2c7e02a58..58d4afa494c2 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1510,12 +1510,12 @@ class FunctionConvert : public IFunction\n \n         if constexpr (to_decimal)\n         {\n-            mandatory_args.push_back({\"scale\", &isNativeInteger, &isColumnConst, \"const Integer\"});\n+            mandatory_args.push_back({\"scale\", &isNativeInteger<IDataType>, &isColumnConst, \"const Integer\"});\n         }\n \n         if (!to_decimal && isDateTime64<Name, ToDataType>(arguments))\n         {\n-            mandatory_args.push_back({\"scale\", &isNativeInteger, &isColumnConst, \"const Integer\"});\n+            mandatory_args.push_back({\"scale\", &isNativeInteger<IDataType>, &isColumnConst, \"const Integer\"});\n         }\n \n         // toString(DateTime or DateTime64, [timezone: String])\n@@ -1531,7 +1531,7 @@ class FunctionConvert : public IFunction\n             // toDateTime64(value, scale : Integer[, timezone: String])\n             || std::is_same_v<ToDataType, DataTypeDateTime64>)\n         {\n-            optional_args.push_back({\"timezone\", &isString, &isColumnConst, \"const String\"});\n+            optional_args.push_back({\"timezone\", &isString<IDataType>, &isColumnConst, \"const String\"});\n         }\n \n         validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n@@ -1811,11 +1811,11 @@ class FunctionConvertFromString : public IFunction\n         if (isDateTime64<Name, ToDataType>(arguments))\n         {\n             validateFunctionArgumentTypes(*this, arguments,\n-                FunctionArgumentDescriptors{{\"string\", isStringOrFixedString, nullptr, \"String or FixedString\"}},\n+                FunctionArgumentDescriptors{{\"string\", &isStringOrFixedString<IDataType>, nullptr, \"String or FixedString\"}},\n                 // optional\n                 FunctionArgumentDescriptors{\n-                    {\"precision\", isUInt8, isColumnConst, \"const UInt8\"},\n-                    {\"timezone\", isStringOrFixedString, isColumnConst, \"const String or FixedString\"},\n+                    {\"precision\", &isUInt8<IDataType>, isColumnConst, \"const UInt8\"},\n+                    {\"timezone\", &isStringOrFixedString<IDataType>, isColumnConst, \"const String or FixedString\"},\n                 });\n \n             UInt64 scale = to_datetime64 ? DataTypeDateTime64::default_scale : 0;\ndiff --git a/src/Functions/castOrDefault.cpp b/src/Functions/castOrDefault.cpp\nnew file mode 100644\nindex 000000000000..7394e0f36f96\n--- /dev/null\n+++ b/src/Functions/castOrDefault.cpp\n@@ -0,0 +1,384 @@\n+#include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypesDecimal.h>\n+#include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeDate32.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n+#include <DataTypes/DataTypeUUID.h>\n+#include <Columns/ColumnString.h>\n+#include <Columns/ColumnConst.h>\n+#include <Columns/ColumnNullable.h>\n+\n+#include <Interpreters/Context.h>\n+#include <Interpreters/castColumn.h>\n+\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int BAD_ARGUMENTS;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+class FunctionCastOrDefault final : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"accurateCastOrDefault\";\n+\n+    static FunctionPtr create(ContextPtr context)\n+    {\n+        return std::make_shared<FunctionCastOrDefault>(context);\n+    }\n+\n+    explicit FunctionCastOrDefault(ContextPtr context_)\n+        : keep_nullable(context_->getSettingsRef().cast_keep_nullable)\n+    {\n+    }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForConstants() const override { return false; }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        size_t arguments_size = arguments.size();\n+        if (arguments_size != 2 && arguments_size != 3)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Function {} expected 2 or 3 arguments. Actual {}\",\n+                getName(),\n+                arguments_size);\n+\n+        const auto & type_column = arguments[1].column;\n+        const auto * type_column_typed = checkAndGetColumnConst<ColumnString>(type_column.get());\n+\n+        if (!type_column_typed)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Second argument to {} must be a constant string describing type. Actual {}\",\n+                getName(),\n+                arguments[1].type->getName());\n+\n+        DataTypePtr result_type = DataTypeFactory::instance().get(type_column_typed->getValue<String>());\n+\n+        if (keep_nullable && arguments.front().type->isNullable())\n+            result_type = makeNullable(result_type);\n+\n+        if (arguments.size() == 3)\n+        {\n+            auto default_value_type = arguments[2].type;\n+\n+            if (!areTypesEqual(result_type, default_value_type))\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Default value type should be same as cast type. Expected {}. Actual {}\",\n+                    result_type->getName(),\n+                    default_value_type->getName());\n+            }\n+        }\n+\n+        return result_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type, size_t) const override\n+    {\n+        const ColumnWithTypeAndName & column_to_cast = arguments[0];\n+        auto non_const_column_to_cast = column_to_cast.column->convertToFullColumnIfConst();\n+        ColumnWithTypeAndName column_to_cast_non_const { std::move(non_const_column_to_cast), column_to_cast.type, column_to_cast.name };\n+\n+        auto cast_result = castColumnAccurateOrNull(column_to_cast_non_const, return_type);\n+\n+        const auto & cast_result_nullable = assert_cast<const ColumnNullable &>(*cast_result);\n+        const auto & null_map_data = cast_result_nullable.getNullMapData();\n+        size_t null_map_data_size = null_map_data.size();\n+        const auto & nested_column = cast_result_nullable.getNestedColumn();\n+        IColumn::MutablePtr result = return_type->createColumn();\n+        result->reserve(null_map_data_size);\n+\n+        size_t start_insert_index = 0;\n+\n+        /// Created separate branch because cast and inserting field from other column is slower\n+        if (arguments.size() == 3)\n+        {\n+            const auto & default_column_with_type = arguments[2];\n+            auto default_column = default_column_with_type.column->convertToFullColumnIfConst();\n+\n+            for (size_t i = 0; i < null_map_data_size; ++i)\n+            {\n+                bool is_current_index_null = null_map_data[i];\n+                if (!is_current_index_null)\n+                    continue;\n+\n+                if (i != start_insert_index)\n+                    result->insertRangeFrom(nested_column, start_insert_index, i - start_insert_index);\n+\n+                result->insertFrom(*default_column, i);\n+                start_insert_index = i + 1;\n+            }\n+        }\n+        else\n+        {\n+            for (size_t i = 0; i < null_map_data_size; ++i)\n+            {\n+                bool is_current_index_null = null_map_data[i];\n+                if (!is_current_index_null)\n+                    continue;\n+\n+                if (i != start_insert_index)\n+                    result->insertRangeFrom(nested_column, start_insert_index, i - start_insert_index);\n+\n+                result->insertDefault();\n+                start_insert_index = i + 1;\n+            }\n+        }\n+\n+        if (null_map_data_size != start_insert_index)\n+            result->insertRangeFrom(nested_column, start_insert_index, null_map_data_size - start_insert_index);\n+\n+        return result;\n+    }\n+\n+private:\n+\n+    bool keep_nullable;\n+};\n+\n+template <typename Type, typename Name>\n+class FunctionCastOrDefaultTyped final : public IFunction\n+{\n+public:\n+    static constexpr auto name = Name::name;\n+\n+    static FunctionPtr create(ContextPtr context)\n+    {\n+        return std::make_shared<FunctionCastOrDefaultTyped>(context);\n+    }\n+\n+    explicit FunctionCastOrDefaultTyped(ContextPtr context_)\n+        : impl(context_)\n+    {\n+    }\n+\n+    String getName() const override { return name; }\n+\n+private:\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n+\n+    bool useDefaultImplementationForNulls() const override { return impl.useDefaultImplementationForNulls(); }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return impl.useDefaultImplementationForLowCardinalityColumns();}\n+    bool useDefaultImplementationForConstants() const override { return impl.useDefaultImplementationForConstants();}\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override\n+    {\n+        return impl.isSuitableForShortCircuitArgumentsExecution(arguments);\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors mandatory_args = {{\"Value\", nullptr, nullptr, nullptr}};\n+        FunctionArgumentDescriptors optional_args;\n+\n+        if constexpr (IsDataTypeDecimal<Type>)\n+            mandatory_args.push_back({\"scale\", &isNativeInteger<IDataType>, &isColumnConst, \"const Integer\"});\n+\n+        if (std::is_same_v<Type, DataTypeDateTime> || std::is_same_v<Type, DataTypeDateTime64>)\n+            optional_args.push_back({\"timezone\", &isString<IDataType>, isColumnConst, \"const String\"});\n+\n+        optional_args.push_back({\"default_value\", nullptr, nullptr, nullptr});\n+\n+        validateFunctionArgumentTypes(*this, arguments, mandatory_args, optional_args);\n+\n+        size_t additional_argument_index = 1;\n+\n+        size_t scale = 0;\n+        std::string time_zone;\n+\n+        if constexpr (IsDataTypeDecimal<Type>)\n+        {\n+            const auto & scale_argument = arguments[additional_argument_index];\n+\n+            WhichDataType scale_argument_type(scale_argument.type);\n+\n+            if (!scale_argument_type.isNativeUInt())\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"Function {} decimal scale should have native UInt type. Actual {}\",\n+                    scale_argument.type->getName());\n+            }\n+\n+            scale = arguments[additional_argument_index].column->getUInt(0);\n+            ++additional_argument_index;\n+        }\n+\n+        if constexpr (std::is_same_v<Type, DataTypeDateTime> || std::is_same_v<Type, DataTypeDateTime64>)\n+        {\n+            if (additional_argument_index < arguments.size())\n+            {\n+                time_zone = extractTimeZoneNameFromColumn(*arguments[additional_argument_index].column);\n+                ++additional_argument_index;\n+            }\n+        }\n+\n+        std::shared_ptr<Type> cast_type;\n+\n+        if constexpr (std::is_same_v<Type, DataTypeDateTime64>)\n+            cast_type = std::make_shared<Type>(scale, time_zone);\n+        else if constexpr (IsDataTypeDecimal<Type>)\n+            cast_type = std::make_shared<Type>(Type::maxPrecision(), scale);\n+        else if constexpr (std::is_same_v<Type, DataTypeDateTime> || std::is_same_v<Type, DataTypeDateTime64>)\n+            cast_type = std::make_shared<Type>(time_zone);\n+        else\n+            cast_type = std::make_shared<Type>();\n+\n+        ColumnWithTypeAndName type_argument =\n+        {\n+            DataTypeString().createColumnConst(1, cast_type->getName()),\n+            std::make_shared<DataTypeString>(),\n+            \"\"\n+        };\n+\n+        ColumnsWithTypeAndName arguments_with_cast_type;\n+        arguments_with_cast_type.reserve(arguments.size());\n+\n+        arguments_with_cast_type.emplace_back(arguments[0]);\n+        arguments_with_cast_type.emplace_back(type_argument);\n+\n+        if (additional_argument_index < arguments.size())\n+        {\n+            arguments_with_cast_type.emplace_back(arguments[additional_argument_index]);\n+            ++additional_argument_index;\n+        }\n+\n+        if (additional_argument_index < arguments.size())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"{} wrong arguments size\", getName());\n+\n+        return impl.getReturnTypeImpl(arguments_with_cast_type);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_size) const override\n+    {\n+        size_t additional_arguments_size = IsDataTypeDecimal<Type> + (std::is_same_v<Type, DataTypeDateTime> || std::is_same_v<Type, DataTypeDateTime64>);\n+\n+        ColumnWithTypeAndName second_argument =\n+        {\n+            DataTypeString().createColumnConst(arguments.begin()->column->size(), result_type->getName()),\n+            std::make_shared<DataTypeString>(),\n+            \"\"\n+        };\n+\n+        ColumnsWithTypeAndName arguments_with_cast_type;\n+        arguments_with_cast_type.reserve(arguments.size());\n+\n+        arguments_with_cast_type.emplace_back(arguments[0]);\n+        arguments_with_cast_type.emplace_back(second_argument);\n+\n+        size_t default_column_argument = 1 + additional_arguments_size;\n+        if (default_column_argument < arguments.size())\n+            arguments_with_cast_type.emplace_back(arguments[default_column_argument]);\n+\n+        return impl.executeImpl(arguments_with_cast_type, result_type, input_rows_size);\n+    }\n+\n+    FunctionCastOrDefault impl;\n+};\n+\n+struct NameToUInt8OrDefault { static constexpr auto name = \"toUInt8OrDefault\"; };\n+struct NameToUInt16OrDefault { static constexpr auto name = \"toUInt16OrDefault\"; };\n+struct NameToUInt32OrDefault { static constexpr auto name = \"toUInt32OrDefault\"; };\n+struct NameToUInt64OrDefault { static constexpr auto name = \"toUInt64OrDefault\"; };\n+struct NameToUInt256OrDefault { static constexpr auto name = \"toUInt256OrDefault\"; };\n+struct NameToInt8OrDefault { static constexpr auto name = \"toInt8OrDefault\"; };\n+struct NameToInt16OrDefault { static constexpr auto name = \"toInt16OrDefault\"; };\n+struct NameToInt32OrDefault { static constexpr auto name = \"toInt32OrDefault\"; };\n+struct NameToInt64OrDefault { static constexpr auto name = \"toInt64OrDefault\"; };\n+struct NameToInt128OrDefault { static constexpr auto name = \"toInt128OrDefault\"; };\n+struct NameToInt256OrDefault { static constexpr auto name = \"toInt256OrDefault\"; };\n+struct NameToFloat32OrDefault { static constexpr auto name = \"toFloat32OrDefault\"; };\n+struct NameToFloat64OrDefault { static constexpr auto name = \"toFloat64OrDefault\"; };\n+struct NameToDateOrDefault { static constexpr auto name = \"toDateOrDefault\"; };\n+struct NameToDate32OrDefault { static constexpr auto name = \"toDate32OrDefault\"; };\n+struct NameToDateTimeOrDefault { static constexpr auto name = \"toDateTimeOrDefault\"; };\n+struct NameToDateTime64OrDefault { static constexpr auto name = \"toDateTime64OrDefault\"; };\n+struct NameToDecimal32OrDefault { static constexpr auto name = \"toDecimal32OrDefault\"; };\n+struct NameToDecimal64OrDefault { static constexpr auto name = \"toDecimal64OrDefault\"; };\n+struct NameToDecimal128OrDefault { static constexpr auto name = \"toDecimal128OrDefault\"; };\n+struct NameToDecimal256OrDefault { static constexpr auto name = \"toDecimal256OrDefault\"; };\n+struct NameToUUIDOrDefault { static constexpr auto name = \"toUUIDOrDefault\"; };\n+\n+using FunctionToUInt8OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt8, NameToUInt8OrDefault>;\n+using FunctionToUInt16OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt16, NameToUInt16OrDefault>;\n+using FunctionToUInt32OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt32, NameToUInt32OrDefault>;\n+using FunctionToUInt64OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt64, NameToUInt64OrDefault>;\n+using FunctionToUInt256OrDefault = FunctionCastOrDefaultTyped<DataTypeUInt256, NameToUInt256OrDefault>;\n+\n+using FunctionToInt8OrDefault = FunctionCastOrDefaultTyped<DataTypeInt8, NameToInt8OrDefault>;\n+using FunctionToInt16OrDefault = FunctionCastOrDefaultTyped<DataTypeInt16, NameToInt16OrDefault>;\n+using FunctionToInt32OrDefault = FunctionCastOrDefaultTyped<DataTypeInt32, NameToInt32OrDefault>;\n+using FunctionToInt64OrDefault = FunctionCastOrDefaultTyped<DataTypeInt64, NameToInt64OrDefault>;\n+using FunctionToInt128OrDefault = FunctionCastOrDefaultTyped<DataTypeInt128, NameToInt128OrDefault>;\n+using FunctionToInt256OrDefault = FunctionCastOrDefaultTyped<DataTypeInt256, NameToInt256OrDefault>;\n+\n+using FunctionToFloat32OrDefault = FunctionCastOrDefaultTyped<DataTypeFloat32, NameToFloat32OrDefault>;\n+using FunctionToFloat64OrDefault = FunctionCastOrDefaultTyped<DataTypeFloat64, NameToFloat64OrDefault>;\n+\n+using FunctionToDateOrDefault = FunctionCastOrDefaultTyped<DataTypeDate, NameToDateOrDefault>;\n+using FunctionToDate32OrDefault = FunctionCastOrDefaultTyped<DataTypeDate32, NameToDate32OrDefault>;\n+using FunctionToDateTimeOrDefault = FunctionCastOrDefaultTyped<DataTypeDateTime, NameToDateTimeOrDefault>;\n+using FunctionToDateTime64OrDefault = FunctionCastOrDefaultTyped<DataTypeDateTime64, NameToDateTime64OrDefault>;\n+\n+using FunctionToDecimal32OrDefault = FunctionCastOrDefaultTyped<DataTypeDecimal<Decimal32>, NameToDecimal32OrDefault>;\n+using FunctionToDecimal64OrDefault = FunctionCastOrDefaultTyped<DataTypeDecimal<Decimal64>, NameToDecimal64OrDefault>;\n+using FunctionToDecimal128OrDefault = FunctionCastOrDefaultTyped<DataTypeDecimal<Decimal128>, NameToDecimal128OrDefault>;\n+using FunctionToDecimal256OrDefault = FunctionCastOrDefaultTyped<DataTypeDecimal<Decimal256>, NameToDecimal256OrDefault>;\n+\n+using FunctionToUUIDOrDefault = FunctionCastOrDefaultTyped<DataTypeUUID, NameToUUIDOrDefault>;\n+\n+void registerFunctionCastOrDefault(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionCastOrDefault>();\n+\n+    factory.registerFunction<FunctionToUInt8OrDefault>();\n+    factory.registerFunction<FunctionToUInt16OrDefault>();\n+    factory.registerFunction<FunctionToUInt32OrDefault>();\n+    factory.registerFunction<FunctionToUInt64OrDefault>();\n+    factory.registerFunction<FunctionToUInt256OrDefault>();\n+\n+    factory.registerFunction<FunctionToInt8OrDefault>();\n+    factory.registerFunction<FunctionToInt16OrDefault>();\n+    factory.registerFunction<FunctionToInt32OrDefault>();\n+    factory.registerFunction<FunctionToInt64OrDefault>();\n+    factory.registerFunction<FunctionToInt128OrDefault>();\n+    factory.registerFunction<FunctionToInt256OrDefault>();\n+\n+    factory.registerFunction<FunctionToFloat32OrDefault>();\n+    factory.registerFunction<FunctionToFloat64OrDefault>();\n+\n+    factory.registerFunction<FunctionToDateOrDefault>();\n+    factory.registerFunction<FunctionToDate32OrDefault>();\n+    factory.registerFunction<FunctionToDateTimeOrDefault>();\n+    factory.registerFunction<FunctionToDateTime64OrDefault>();\n+\n+    factory.registerFunction<FunctionToDecimal32OrDefault>();\n+    factory.registerFunction<FunctionToDecimal64OrDefault>();\n+    factory.registerFunction<FunctionToDecimal128OrDefault>();\n+    factory.registerFunction<FunctionToDecimal256OrDefault>();\n+\n+    factory.registerFunction<FunctionToUUIDOrDefault>();\n+}\n+\n+}\ndiff --git a/src/Functions/extractAllGroups.h b/src/Functions/extractAllGroups.h\nindex 4f9a07a275c1..fa75e305af4c 100644\n--- a/src/Functions/extractAllGroups.h\n+++ b/src/Functions/extractAllGroups.h\n@@ -73,8 +73,8 @@ class FunctionExtractAllGroups : public IFunction\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         FunctionArgumentDescriptors args{\n-            {\"haystack\", isStringOrFixedString, nullptr, \"const String or const FixedString\"},\n-            {\"needle\", isStringOrFixedString, isColumnConst, \"const String or const FixedString\"},\n+            {\"haystack\", &isStringOrFixedString<IDataType>, nullptr, \"const String or const FixedString\"},\n+            {\"needle\", &isStringOrFixedString<IDataType>, isColumnConst, \"const String or const FixedString\"},\n         };\n         validateFunctionArgumentTypes(*this, arguments, args);\n \ndiff --git a/src/Functions/extractGroups.cpp b/src/Functions/extractGroups.cpp\nindex 5e4210513851..2286951bb8ff 100644\n--- a/src/Functions/extractGroups.cpp\n+++ b/src/Functions/extractGroups.cpp\n@@ -45,8 +45,8 @@ class FunctionExtractGroups : public IFunction\n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         FunctionArgumentDescriptors args{\n-            {\"haystack\", isStringOrFixedString, nullptr, \"const String or const FixedString\"},\n-            {\"needle\", isStringOrFixedString, isColumnConst, \"const String or const FixedString\"},\n+            {\"haystack\", &isStringOrFixedString<IDataType>, nullptr, \"const String or const FixedString\"},\n+            {\"needle\", &isStringOrFixedString<IDataType>, isColumnConst, \"const String or const FixedString\"},\n         };\n         validateFunctionArgumentTypes(*this, arguments, args);\n \ndiff --git a/src/Functions/extractTimeZoneFromFunctionArguments.cpp b/src/Functions/extractTimeZoneFromFunctionArguments.cpp\nindex 19c02ed23906..9862c80f3c32 100644\n--- a/src/Functions/extractTimeZoneFromFunctionArguments.cpp\n+++ b/src/Functions/extractTimeZoneFromFunctionArguments.cpp\n@@ -17,7 +17,7 @@ namespace ErrorCodes\n }\n \n \n-static std::string extractTimeZoneNameFromColumn(const IColumn & column)\n+std::string extractTimeZoneNameFromColumn(const IColumn & column)\n {\n     const ColumnConst * time_zone_column = checkAndGetColumnConst<ColumnString>(&column);\n \ndiff --git a/src/Functions/extractTimeZoneFromFunctionArguments.h b/src/Functions/extractTimeZoneFromFunctionArguments.h\nindex 9dd3fdd49030..751d7a463f14 100644\n--- a/src/Functions/extractTimeZoneFromFunctionArguments.h\n+++ b/src/Functions/extractTimeZoneFromFunctionArguments.h\n@@ -12,6 +12,8 @@ namespace DB\n \n class Block;\n \n+std::string extractTimeZoneNameFromColumn(const IColumn & column);\n+\n /// Determine working timezone either from optional argument with time zone name or from time zone in DateTime type of argument.\n /// Returns empty string if default time zone should be used.\n std::string extractTimeZoneNameFromFunctionArguments(\ndiff --git a/src/Functions/registerFunctions.cpp b/src/Functions/registerFunctions.cpp\nindex 9b1a7faebbe5..4733829de56a 100644\n--- a/src/Functions/registerFunctions.cpp\n+++ b/src/Functions/registerFunctions.cpp\n@@ -19,6 +19,7 @@ void registerFunctionChar(FunctionFactory &);\n void registerFunctionsComparison(FunctionFactory &);\n void registerFunctionsConditional(FunctionFactory &);\n void registerFunctionsConversion(FunctionFactory &);\n+void registerFunctionCastOrDefault(FunctionFactory &);\n void registerFunctionsDateTime(FunctionFactory &);\n void registerFunctionsEmbeddedDictionaries(FunctionFactory &);\n void registerFunctionsExternalDictionaries(FunctionFactory &);\n@@ -84,6 +85,7 @@ void registerFunctions()\n     registerFunctionsComparison(factory);\n     registerFunctionsConditional(factory);\n     registerFunctionsConversion(factory);\n+    registerFunctionCastOrDefault(factory);\n     registerFunctionsDateTime(factory);\n     registerFunctionsEmbeddedDictionaries(factory);\n     registerFunctionsExternalDictionaries(factory);\ndiff --git a/src/Interpreters/castColumn.cpp b/src/Interpreters/castColumn.cpp\nindex fd71e02ee7ed..dc9882b84b05 100644\n--- a/src/Interpreters/castColumn.cpp\n+++ b/src/Interpreters/castColumn.cpp\n@@ -9,7 +9,7 @@ namespace DB\n template <CastType cast_type = CastType::nonAccurate>\n static ColumnPtr castColumn(const ColumnWithTypeAndName & arg, const DataTypePtr & type)\n {\n-    if (arg.type->equals(*type))\n+    if (arg.type->equals(*type) && cast_type != CastType::accurateOrNull)\n         return arg.column;\n \n     ColumnsWithTypeAndName arguments\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01746_convert_type_with_default.reference b/tests/queries/0_stateless/01746_convert_type_with_default.reference\nnew file mode 100644\nindex 000000000000..9ebef9c4a8d0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01746_convert_type_with_default.reference\n@@ -0,0 +1,24 @@\n+1\n+2\n+-1\n+-2\n+1\n+2\n+-1\n+-2\n+1\n+2\n+-1\n+-2\n+1\n+2\n+-1\n+-2\n+-1\n+-2\n+1\n+2\n+-1\n+-2\n+61f0c404-5cb3-11e7-907b-a6006ad3dba0\n+59f0c404-5cb3-11e7-907b-a6006ad3dba0\ndiff --git a/tests/queries/0_stateless/01746_convert_type_with_default.sql b/tests/queries/0_stateless/01746_convert_type_with_default.sql\nnew file mode 100644\nindex 000000000000..0881e9114660\n--- /dev/null\n+++ b/tests/queries/0_stateless/01746_convert_type_with_default.sql\n@@ -0,0 +1,30 @@\n+select toUInt8OrDefault('1', cast(2 as UInt8));\n+select toUInt8OrDefault('1xx', cast(2 as UInt8));\n+select toInt8OrDefault('-1', cast(-2 as Int8));\n+select toInt8OrDefault('-1xx', cast(-2 as Int8));\n+\n+select toUInt16OrDefault('1', cast(2 as UInt16));\n+select toUInt16OrDefault('1xx', cast(2 as UInt16));\n+select toInt16OrDefault('-1', cast(-2 as Int16));\n+select toInt16OrDefault('-1xx', cast(-2 as Int16));\n+\n+select toUInt32OrDefault('1', cast(2 as UInt32));\n+select toUInt32OrDefault('1xx', cast(2 as UInt32));\n+select toInt32OrDefault('-1', cast(-2 as Int32));\n+select toInt32OrDefault('-1xx', cast(-2 as Int32));\n+\n+select toUInt64OrDefault('1', cast(2 as UInt64));\n+select toUInt64OrDefault('1xx', cast(2 as UInt64));\n+select toInt64OrDefault('-1', cast(-2 as Int64));\n+select toInt64OrDefault('-1xx', cast(-2 as Int64));\n+\n+select toInt128OrDefault('-1', cast(-2 as Int128));\n+select toInt128OrDefault('-1xx', cast(-2 as Int128));\n+\n+select toUInt256OrDefault('1', cast(2 as UInt256));\n+select toUInt256OrDefault('1xx', cast(2 as UInt256));\n+select toInt256OrDefault('-1', cast(-2 as Int256));\n+select toInt256OrDefault('-1xx', cast(-2 as Int256));\n+\n+SELECT toUUIDOrDefault('61f0c404-5cb3-11e7-907b-a6006ad3dba0', cast('59f0c404-5cb3-11e7-907b-a6006ad3dba0' as UUID));\n+SELECT toUUIDOrDefault('-----61f0c404-5cb3-11e7-907b-a6006ad3dba0', cast('59f0c404-5cb3-11e7-907b-a6006ad3dba0' as UUID));\ndiff --git a/tests/queries/0_stateless/2026_accurate_cast_or_default.reference b/tests/queries/0_stateless/2026_accurate_cast_or_default.reference\nnew file mode 100644\nindex 000000000000..67be2da9975e\n--- /dev/null\n+++ b/tests/queries/0_stateless/2026_accurate_cast_or_default.reference\n@@ -0,0 +1,32 @@\n+0\t5\n+5\n+0\t5\n+0\t5\n+5\n+0\t5\n+0\t5\n+5\n+0\t5\n+0\t5\n+5\n+0\t5\n+5\n+0\t5\n+5\n+0\t5\n+0\t2\n+1\n+0\t2\n+\\0\\0\t12\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+0\t5\n+127\t127\n+0\t5\ndiff --git a/tests/queries/0_stateless/2026_accurate_cast_or_default.sql b/tests/queries/0_stateless/2026_accurate_cast_or_default.sql\nnew file mode 100644\nindex 000000000000..1c35055749e8\n--- /dev/null\n+++ b/tests/queries/0_stateless/2026_accurate_cast_or_default.sql\n@@ -0,0 +1,36 @@\n+SELECT accurateCastOrDefault(-1, 'UInt8'), accurateCastOrDefault(5, 'UInt8');\n+SELECT accurateCastOrDefault(5, 'UInt8');\n+SELECT accurateCastOrDefault(257, 'UInt8'),  accurateCastOrDefault(257, 'UInt8', 5);\n+SELECT accurateCastOrDefault(-1, 'UInt16'),  accurateCastOrDefault(-1, 'UInt16', toUInt16(5));\n+SELECT accurateCastOrDefault(5, 'UInt16');\n+SELECT accurateCastOrDefault(65536, 'UInt16'),  accurateCastOrDefault(65536, 'UInt16', toUInt16(5));\n+SELECT accurateCastOrDefault(-1, 'UInt32'),  accurateCastOrDefault(-1, 'UInt32', toUInt32(5));\n+SELECT accurateCastOrDefault(5, 'UInt32');\n+SELECT accurateCastOrDefault(4294967296, 'UInt32'),  accurateCastOrDefault(4294967296, 'UInt32', toUInt32(5));\n+SELECT accurateCastOrDefault(-1, 'UInt64'), accurateCastOrDefault(-1, 'UInt64', toUInt64(5));\n+SELECT accurateCastOrDefault(5, 'UInt64');\n+SELECT accurateCastOrDefault(-1, 'UInt256'), accurateCastOrDefault(-1, 'UInt256', toUInt256(5));\n+SELECT accurateCastOrDefault(5, 'UInt256');\n+SELECT accurateCastOrDefault(-129, 'Int8'), accurateCastOrDefault(-129, 'Int8', toInt8(5));\n+SELECT accurateCastOrDefault(5, 'Int8');\n+SELECT accurateCastOrDefault(128, 'Int8'),  accurateCastOrDefault(128, 'Int8', toInt8(5));\n+\n+SELECT accurateCastOrDefault(10, 'Decimal32(9)'), accurateCastOrDefault(10, 'Decimal32(9)', toDecimal32(2, 9));\n+SELECT accurateCastOrDefault(1, 'Decimal32(9)');\n+SELECT accurateCastOrDefault(-10, 'Decimal32(9)'), accurateCastOrDefault(-10, 'Decimal32(9)', toDecimal32(2, 9));\n+\n+SELECT accurateCastOrDefault('123', 'FixedString(2)'), accurateCastOrDefault('123', 'FixedString(2)', cast('12', 'FixedString(2)'));\n+\n+SELECT accurateCastOrDefault(inf, 'Int64'), accurateCastOrDefault(inf, 'Int64', toInt64(5));\n+SELECT accurateCastOrDefault(inf, 'Int128'), accurateCastOrDefault(inf, 'Int128', toInt128(5));\n+SELECT accurateCastOrDefault(inf, 'Int256'), accurateCastOrDefault(inf, 'Int256', toInt256(5));\n+SELECT accurateCastOrDefault(nan, 'Int64'), accurateCastOrDefault(nan, 'Int64', toInt64(5));\n+SELECT accurateCastOrDefault(nan, 'Int128'), accurateCastOrDefault(nan, 'Int128', toInt128(5));\n+SELECT accurateCastOrDefault(nan, 'Int256'), accurateCastOrDefault(nan, 'Int256', toInt256(5));\n+\n+SELECT accurateCastOrDefault(inf, 'UInt64'), accurateCastOrDefault(inf, 'UInt64', toUInt64(5));\n+SELECT accurateCastOrDefault(inf, 'UInt256'), accurateCastOrDefault(inf, 'UInt256', toUInt256(5));\n+SELECT accurateCastOrDefault(nan, 'UInt64'), accurateCastOrDefault(nan, 'UInt64', toUInt64(5));\n+SELECT accurateCastOrDefault(nan, 'UInt256'), accurateCastOrDefault(nan, 'UInt256', toUInt256(5));\n+\n+SELECT accurateCastOrDefault(number + 127, 'Int8') AS x, accurateCastOrDefault(number + 127, 'Int8', toInt8(5)) AS x_with_default FROM numbers (2) ORDER BY number;\n",
  "problem_statement": "add toIntXXOrDefault and toUUIDOrDefault functions\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- New Feature\r\n\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\n- Add Function `toUUIDOrDefault`, `toUInt8/16/32/64/256OrDefault`, `toInt8/16/32/64/128/256OrDefault`, which enables user defining default value(not null) when string parsing is failed\r\n\r\n\r\nDetailed description / Documentation draft:\r\n- Add Function `toUUIDOrDefault`, `toUInt8/16/32/64/256OrDefault`, `toInt8/16/32/64/128/256OrDefault`, which enables user defining default value(not null) when string parsing is failed\r\n\r\nFor example:\r\n``` text\r\n> SELECT toInt64OrDefault('123123', cast('-1' as Int64)), toInt8OrDefault('123qwe123', cast('-1' as Int8)); \r\n\r\nSELECT\r\n    toInt64OrDefault('123123', CAST('-1', 'Int64')),\r\n    toInt8OrDefault('123qwe123', CAST('-1', 'Int8'))\r\n\r\nQuery id: 80d6db8c-83f3-4080-bdbc-aa5cce8b2584\r\n\r\n\u250c\u2500toInt64OrDefault('123123', CAST('-1', 'Int64'))\u2500\u252c\u2500toInt8OrDefault('123qwe123', CAST('-1', 'Int8'))\u2500\u2510\r\n\u2502                                          123123 \u2502                                               -1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.014 sec. \r\n```\r\n\r\nTODO \r\n- Implement `toXXXOrDefault` function for Datetypes: `Date`, `DateTime`, `DateTime64`, `Decimal`\n",
  "hints_text": "",
  "created_at": "2021-04-13T08:32:55Z"
}