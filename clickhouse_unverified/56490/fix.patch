diff --git a/docs/en/sql-reference/table-functions/fuzzJSON.md b/docs/en/sql-reference/table-functions/fuzzJSON.md
new file mode 100644
index 000000000000..74ccb0bcb8a0
--- /dev/null
+++ b/docs/en/sql-reference/table-functions/fuzzJSON.md
@@ -0,0 +1,86 @@
+---
+slug: /en/sql-reference/table-functions/fuzzJSON
+sidebar_position: 75
+sidebar_label: fuzzJSON
+---
+
+# fuzzJSON
+
+Perturbs a JSON string with random variations.
+
+``` sql
+fuzzJSON({ named_collection [option=value [,..]] | json_str[, random_seed] })
+```
+
+**Arguments**
+
+- `named_collection`- A [NAMED COLLECTION](/docs/en/sql-reference/statements/create/named-collection.md).
+- `option=value` - Named collection optional parameters and their values.
+ - `json_str` (String) - The source string representing structured data in JSON format.
+ - `random_seed` (UInt64) - Manual random seed for producing stable results.
+ - `reuse_output` (boolean) - Reuse the output from a fuzzing process as input for the next fuzzer.
+ - `max_output_length` (UInt64) - Maximum allowable length of the generated or perturbed JSON string.
+ - `probability` (Float64) - The probability to fuzz a JSON field (a key-value pair). Must be within [0, 1] range.
+ - `max_nesting_level` (UInt64) - The maximum allowed depth of nested structures within the JSON data.
+ - `max_array_size` (UInt64) - The maximum allowed size of a JSON array.
+ - `max_object_size` (UInt64) - The maximum allowed number of fields on a single level of a JSON object.
+ - `max_string_value_length` (UInt64) - The maximum length of a String value.
+ - `min_key_length` (UInt64) - The minimum key length. Should be at least 1.
+ - `max_key_length` (UInt64) - The maximum key length. Should be greater or equal than the `min_key_length`, if specified.
+
+**Returned Value**
+
+A table object with a a single column containing perturbed JSON strings.
+
+## Usage Example
+
+``` sql
+CREATE NAMED COLLECTION json_fuzzer AS json_str='{}';
+SELECT * FROM fuzzJSON(json_fuzzer) LIMIT 3;
+```
+
+``` text
+{"52Xz2Zd4vKNcuP2":true}
+{"UPbOhOQAdPKIg91":3405264103600403024}
+{"X0QUWu8yT":[]}
+```
+
+``` sql
+SELECT * FROM fuzzJSON(json_fuzzer, json_str='{"name" : "value"}', random_seed=1234) LIMIT 3;
+```
+
+``` text
+{"key":"value", "mxPG0h1R5":"L-YQLv@9hcZbOIGrAn10%GA"}
+{"BRE3":true}
+{"key":"value", "SWzJdEJZ04nrpSfy":[{"3Q23y":[]}]}
+```
+
+``` sql
+SELECT * FROM fuzzJSON(json_fuzzer, json_str='{"students" : ["Alice", "Bob"]}', reuse_output=true) LIMIT 3;
+```
+
+``` text
+{"students":["Alice", "Bob"], "nwALnRMc4pyKD9Krv":[]}
+{"students":["1rNY5ZNs0wU&82t_P", "Bob"], "wLNRGzwDiMKdw":[{}]}
+{"xeEk":["1rNY5ZNs0wU&82t_P", "Bob"], "wLNRGzwDiMKdw":[{}, {}]}
+```
+
+``` sql
+SELECT * FROM fuzzJSON(json_fuzzer, json_str='{"students" : ["Alice", "Bob"]}', max_output_length=512) LIMIT 3;
+```
+
+``` text
+{"students":["Alice", "Bob"], "BREhhXj5":true}
+{"NyEsSWzJdeJZ04s":["Alice", 5737924650575683711, 5346334167565345826], "BjVO2X9L":true}
+{"NyEsSWzJdeJZ04s":["Alice", 5737924650575683711, 5346334167565345826], "BjVO2X9L":true, "k1SXzbSIz":[{}]}
+```
+
+``` sql
+SELECT * FROM fuzzJSON('{"id":1}', 1234) LIMIT 3;
+```
+
+``` text
+{"id":1, "mxPG0h1R5":"L-YQLv@9hcZbOIGrAn10%GA"}
+{"BRjE":16137826149911306846}
+{"XjKE":15076727133550123563}
+```
diff --git a/src/Storages/StorageFuzzJSON.cpp b/src/Storages/StorageFuzzJSON.cpp
new file mode 100644
index 000000000000..b4025f58a461
--- /dev/null
+++ b/src/Storages/StorageFuzzJSON.cpp
@@ -0,0 +1,695 @@
+#include <optional>
+#include <random>
+#include <string_view>
+#include <unordered_set>
+#include <Columns/ColumnString.h>
+#include <Interpreters/evaluateConstantExpression.h>
+#include <Storages/NamedCollectionsHelpers.h>
+#include <Storages/StorageFactory.h>
+#include <Storages/StorageFuzzJSON.h>
+#include <Storages/checkAndGetLiteralArgument.h>
+#include <Common/JSONParsers/RapidJSONParser.h>
+#include <Common/JSONParsers/SimdJSONParser.h>
+#include <Common/checkStackSize.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+extern const int BAD_ARGUMENTS;
+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+extern const int LOGICAL_ERROR;
+extern const int INCORRECT_DATA;
+}
+
+namespace
+{
+
+using uniform = std::uniform_int_distribution<size_t>;
+
+struct JSONNode;
+using JSONNodeList = std::list<std::shared_ptr<JSONNode>>;
+
+struct JSONValue
+{
+    enum class Type : size_t
+    {
+        Fixed = 0,
+        Array = 1,
+        Object = 2,
+    };
+
+    static Type getType(const JSONValue & v);
+
+    // The node value must be one of the following:
+    // Examples: 5, true, "abc"
+    std::optional<Field> fixed;
+    // Examples: [], ["a"], [1, true]
+    std::optional<JSONNodeList> array;
+    // Examples: {}, {"a": [1,2], "b": "c"}
+    std::optional<JSONNodeList> object;
+};
+
+JSONValue::Type JSONValue::getType(const JSONValue & v)
+{
+    if (v.fixed)
+    {
+        assert(!v.array);
+        assert(!v.object);
+        return JSONValue::Type::Fixed;
+    }
+    else if (v.array)
+    {
+        assert(!v.fixed);
+        assert(!v.object);
+        return JSONValue::Type::Array;
+    }
+    else if (v.object)
+    {
+        assert(!v.fixed);
+        assert(!v.array);
+        return JSONValue::Type::Object;
+    }
+    else
+        throw Exception(ErrorCodes::LOGICAL_ERROR, "Failed to determine JSON node type.");
+}
+
+// A node represents either a JSON field (a key-value pair) or a JSON value.
+// The key is not set for the JSON root and for the array items.
+struct JSONNode
+{
+    std::optional<String> key;
+    JSONValue value;
+};
+
+#if USE_SIMDJSON
+using ParserImpl = DB::SimdJSONParser;
+#elif USE_RAPIDJSON
+using ParserImpl = DB::RapidJSONParser;
+#endif
+
+std::optional<Field> getFixedValue(const ParserImpl::Element & e)
+{
+    return e.isBool()  ? e.getBool()
+        : e.isInt64()  ? e.getInt64()
+        : e.isUInt64() ? e.getUInt64()
+        : e.isDouble() ? e.getDouble()
+        : e.isString() ? e.getString()
+        : e.isNull()   ? Field()
+                       : std::optional<Field>();
+}
+
+void traverse(const ParserImpl::Element & e, std::shared_ptr<JSONNode> node)
+{
+    checkStackSize();
+
+    assert(node);
+
+    auto & val = node->value;
+    if (e.isObject())
+    {
+        const auto & obj = e.getObject();
+        if (!val.object)
+            val.object = JSONNodeList{};
+
+        for (const auto [k, v] : obj)
+        {
+            auto child = std::make_shared<JSONNode>();
+            child->key = k;
+            traverse(v, child);
+            val.object->push_back(child);
+        }
+    }
+    else if (e.isArray())
+    {
+        if (!val.array)
+            val.array = JSONNodeList{};
+
+        const auto arr = e.getArray();
+        for (const auto a : arr)
+        {
+            auto child = std::make_shared<JSONNode>();
+            traverse(a, child);
+            val.array->push_back(child);
+        }
+    }
+    else
+    {
+        auto field = getFixedValue(e);
+        if (!field)
+            throw Exception(ErrorCodes::INCORRECT_DATA, "Failed to parse a fixed JSON value.");
+
+        val.fixed = std::move(field);
+    }
+}
+
+std::shared_ptr<JSONNode> parseJSON(const String & json)
+{
+    std::string_view view{json.begin(), json.end()};
+    ParserImpl::Element document;
+    ParserImpl p;
+
+    if (!p.parse(json, document))
+        throw Exception(ErrorCodes::INCORRECT_DATA, "Failed to parse JSON string.");
+
+    auto root = std::make_shared<JSONNode>();
+    traverse(document, root);
+    return root;
+}
+
+char generateRandomCharacter(pcg64 & rnd, const std::string_view & charset)
+{
+    assert(!charset.empty());
+    auto idx = uniform(0, charset.size() - 1)(rnd);
+    return charset[idx];
+}
+
+char generateRandomKeyCharacter(pcg64 & rnd)
+{
+    static constexpr std::string_view charset = "0123456789"
+                                                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                                                "abcdefghijklmnopqrstuvwxyz";
+    return generateRandomCharacter(rnd, charset);
+}
+
+char generateRandomStringValueCharacter(pcg64 & rnd)
+{
+    static constexpr std::string_view charset = "0123456789"
+                                                "ABCDEFGHIJKLMNOPQRSTUVWXYZ"
+                                                "abcdefghijklmnopqrstuvwxyz"
+                                                "!@#$%^&*-+_";
+    return generateRandomCharacter(rnd, charset);
+}
+
+String generateRandomStringValue(UInt64 min_length, UInt64 max_length, pcg64 & rnd)
+{
+    size_t size = min_length + rnd() % (max_length - min_length + 1);
+    String res;
+    res.reserve(size);
+    for (size_t i = 0; i < size; ++i)
+        res.push_back(generateRandomStringValueCharacter(rnd));
+
+    return res;
+}
+
+String generateRandomKey(UInt64 min_length, UInt64 max_length, pcg64 & rnd)
+{
+    size_t size = min_length + rnd() % (max_length - min_length + 1);
+    String res;
+    res.reserve(size);
+    for (size_t i = 0; i < size; ++i)
+        res.push_back(generateRandomKeyCharacter(rnd));
+
+    return res;
+}
+
+enum class FuzzAction : size_t
+{
+    Skip = 0,
+    Edit = 1,
+    Add = 2,
+    Delete = 3,
+};
+
+Field generateRandomFixedValue(const StorageFuzzJSON::Configuration & config, pcg64 & rnd)
+{
+    // TODO (@jkartseva): support more field types.
+    static std::array<Field::Types::Which, 3> possible_types{
+        Field::Types::Which::UInt64, Field::Types::Which::String, Field::Types::Which::Bool};
+
+    Field f;
+    auto idx = rnd() % possible_types.size();
+    switch (possible_types[idx])
+    {
+        case Field::Types::Which::UInt64: {
+            f = rnd();
+            break;
+        }
+        case Field::Types::Which::String:
+            f = generateRandomStringValue(/*min_length*/ 0, config.max_string_value_length, rnd);
+            break;
+        case Field::Types::Which::Bool:
+            f = bool(rnd() % 2);
+            break;
+        default:
+    }
+    return f;
+}
+
+String fuzzJSONKey(const StorageFuzzJSON::Configuration & config, pcg64 & rnd, const String & source)
+{
+    String result;
+    result.reserve(config.max_key_length);
+
+    using FA = FuzzAction;
+    auto get_action = [&]() -> FuzzAction
+    {
+        static constexpr std::array<FuzzAction, 4> actions{FA::Skip, FA::Edit, FA::Add, FA::Delete};
+        return actions[uniform(0, 3)(rnd)];
+    };
+
+    size_t i = 0;
+    while (i < source.size() && result.size() < config.max_key_length)
+    {
+        auto action = get_action();
+        switch (action)
+        {
+            case FA::Skip: {
+                result.push_back(source[i++]);
+            }
+            break;
+            case FA::Edit: {
+                result.push_back(generateRandomKeyCharacter(rnd));
+                ++i;
+            }
+            break;
+            case FA::Add: {
+                result.push_back(generateRandomKeyCharacter(rnd));
+            }
+            break;
+            default:
+                ++i;
+        }
+    }
+
+    while (result.size() < config.min_key_length)
+        result.push_back(generateRandomKeyCharacter(rnd));
+
+    return result;
+}
+
+std::shared_ptr<JSONNode>
+generateRandomJSONNode(const StorageFuzzJSON::Configuration & config, pcg64 & rnd, bool with_key, JSONValue::Type type)
+{
+    auto node = std::make_shared<JSONNode>();
+
+    if (with_key)
+        node->key = generateRandomKey(config.min_key_length, config.max_key_length, rnd);
+
+    auto & val = node->value;
+    switch (type)
+
+    {
+        case JSONValue::Type::Fixed: {
+            val.fixed = generateRandomFixedValue(config, rnd);
+            break;
+        }
+        case JSONValue::Type::Array: {
+            val.array = JSONNodeList{};
+            break;
+        }
+        case JSONValue::Type::Object: {
+            val.object = JSONNodeList{};
+            break;
+        }
+    }
+    return node;
+}
+
+template <size_t n>
+std::shared_ptr<JSONNode> generateRandomJSONNode(
+    const StorageFuzzJSON::Configuration & config, pcg64 & rnd, bool with_key, const std::array<JSONValue::Type, n> & possible_types)
+{
+    auto type = possible_types[uniform(0, possible_types.size() - 1)(rnd)];
+    return generateRandomJSONNode(config, rnd, with_key, type);
+}
+
+std::shared_ptr<JSONNode> generateRandomJSONNode(const StorageFuzzJSON::Configuration & config, pcg64 & rnd, bool with_key, size_t depth)
+{
+    if (depth >= config.max_nesting_level)
+        return generateRandomJSONNode(config, rnd, with_key, JSONValue::Type::Fixed);
+
+    static constexpr std::array<JSONValue::Type, 3> possible_types
+        = {JSONValue::Type::Fixed, JSONValue::Type::Array, JSONValue::Type::Object};
+    return generateRandomJSONNode(config, rnd, with_key, possible_types);
+}
+
+JSONNode & fuzzSingleJSONNode(JSONNode & n, const StorageFuzzJSON::Configuration & config, pcg64 & rnd, size_t depth, size_t & node_count)
+{
+    auto & val = n.value;
+
+    static constexpr size_t update_key = 1;
+    static constexpr size_t update_value = 2;
+
+    auto action = 1 + rnd() % static_cast<size_t>(update_key | update_value);
+    if (n.key && (action & update_key))
+        n.key = fuzzJSONKey(config, rnd, *n.key);
+
+    if ((action & update_value) == 0)
+        return n;
+
+    if (val.fixed)
+        val.fixed = generateRandomFixedValue(config, rnd);
+    else if (val.array && val.array->size() < config.max_array_size && node_count + val.array->size() < config.value_number_limit)
+    {
+        if (val.array->empty())
+            val.array->push_back(generateRandomJSONNode(config, rnd, /*with_key*/ false, depth));
+        else
+        {
+            // Use the type of the preceding element.
+            const auto & prev = val.array->back();
+            auto value_type = JSONValue::getType(prev->value);
+            val.array->push_back(generateRandomJSONNode(config, rnd, /*with_key*/ false, value_type));
+        }
+        ++node_count;
+    }
+    else if (val.object && val.object->size() < config.max_object_size && node_count + val.object->size() < config.value_number_limit)
+    {
+        val.object->push_back(generateRandomJSONNode(config, rnd, /*with_key*/ true, depth));
+        ++node_count;
+    }
+
+    return n;
+}
+
+
+void fuzzJSONObject(
+    const std::shared_ptr<JSONNode> & node,
+    WriteBuffer & out,
+    const StorageFuzzJSON::Configuration & config,
+    pcg64 & rnd,
+    size_t depth,
+    size_t & node_count)
+{
+    checkStackSize();
+
+    ++node_count;
+
+    bool should_fuzz = rnd() % 100 < 100 * config.probability;
+
+    const auto & next_node = should_fuzz && !config.should_reuse_output ? std::make_shared<JSONNode>(*node) : node;
+
+    if (should_fuzz)
+        fuzzSingleJSONNode(*next_node, config, rnd, depth, node_count);
+
+    if (next_node->key)
+    {
+        writeDoubleQuoted(*next_node->key, out);
+        out << ":";
+    }
+
+    auto & val = next_node->value;
+
+    if (val.fixed)
+    {
+        if (val.fixed->getType() == Field::Types::Which::String)
+            writeDoubleQuoted(val.fixed->get<String>(), out);
+        else
+            writeFieldText(*val.fixed, out);
+    }
+    else
+    {
+        if (!val.array && !val.object)
+            return;
+
+        const auto & [op, cl, node_list] = val.array ? std::make_tuple('[', ']', *val.array) : std::make_tuple('{', '}', *val.object);
+
+        out << op;
+
+        bool first = true;
+        for (const auto & ptr : node_list)
+        {
+            if (node_count >= config.value_number_limit)
+                break;
+
+            WriteBufferFromOwnString child_out;
+            if (!first)
+                child_out << ", ";
+            first = false;
+
+            fuzzJSONObject(ptr, child_out, config, rnd, depth + 1, node_count);
+            // Should not exceed the maximum length of the output string.
+            if (out.count() + child_out.count() >= config.max_output_length)
+                break;
+            out << child_out.str();
+        }
+        out << cl;
+    }
+}
+
+void fuzzJSONObject(std::shared_ptr<JSONNode> n, WriteBuffer & out, const StorageFuzzJSON::Configuration & config, pcg64 & rnd)
+{
+    size_t node_count = 0;
+    return fuzzJSONObject(n, out, config, rnd, /*depth*/ 0, node_count);
+}
+
+class FuzzJSONSource : public ISource
+{
+public:
+    FuzzJSONSource(
+        UInt64 block_size_, Block block_header_, const StorageFuzzJSON::Configuration & config_, std::shared_ptr<JSONNode> json_root_)
+        : ISource(block_header_)
+        , block_size(block_size_)
+        , block_header(std::move(block_header_))
+        , config(config_)
+        , rnd(config.random_seed)
+        , json_root(json_root_)
+    {
+    }
+    String getName() const override { return "FuzzJSON"; }
+
+protected:
+    Chunk generate() override
+    {
+        Columns columns;
+        columns.reserve(block_header.columns());
+        columns.emplace_back(createColumn());
+
+        return {std::move(columns), block_size};
+    }
+
+private:
+    ColumnPtr createColumn();
+
+    UInt64 block_size;
+    Block block_header;
+
+    StorageFuzzJSON::Configuration config;
+    pcg64 rnd;
+
+    std::shared_ptr<JSONNode> json_root;
+};
+
+ColumnPtr FuzzJSONSource::createColumn()
+{
+    auto column = ColumnString::create();
+    ColumnString::Chars & data_to = column->getChars();
+    ColumnString::Offsets & offsets_to = column->getOffsets();
+
+    offsets_to.resize(block_size);
+    IColumn::Offset offset = 0;
+
+    for (size_t row_num = 0; row_num < block_size; ++row_num)
+    {
+        WriteBufferFromOwnString out;
+        fuzzJSONObject(json_root, out, config, rnd);
+
+        auto data = out.str();
+        size_t data_len = data.size();
+
+        IColumn::Offset next_offset = offset + data_len + 1;
+        data_to.resize(next_offset);
+
+        std::copy(data.begin(), data.end(), &data_to[offset]);
+
+        data_to[offset + data_len] = 0;
+        offsets_to[row_num] = next_offset;
+
+        offset = next_offset;
+    }
+
+    return column;
+}
+
+}
+
+StorageFuzzJSON::StorageFuzzJSON(
+    const StorageID & table_id_, const ColumnsDescription & columns_, const String & comment_, const Configuration & config_)
+    : IStorage(table_id_), config(config_)
+{
+    StorageInMemoryMetadata storage_metadata;
+    storage_metadata.setColumns(columns_);
+    storage_metadata.setComment(comment_);
+    setInMemoryMetadata(storage_metadata);
+}
+
+Pipe StorageFuzzJSON::read(
+    const Names & column_names,
+    const StorageSnapshotPtr & storage_snapshot,
+    SelectQueryInfo & /*query_info*/,
+    ContextPtr /*context*/,
+    QueryProcessingStage::Enum /*processed_stage*/,
+    size_t max_block_size,
+    size_t num_streams)
+{
+    storage_snapshot->check(column_names);
+
+    Pipes pipes;
+    pipes.reserve(num_streams);
+
+    const ColumnsDescription & our_columns = storage_snapshot->metadata->getColumns();
+    Block block_header;
+    for (const auto & name : column_names)
+    {
+        const auto & name_type = our_columns.get(name);
+        MutableColumnPtr column = name_type.type->createColumn();
+        block_header.insert({std::move(column), name_type.type, name_type.name});
+    }
+
+    for (UInt64 i = 0; i < num_streams; ++i)
+        pipes.emplace_back(std::make_shared<FuzzJSONSource>(max_block_size, block_header, config, parseJSON(config.json_str)));
+
+    return Pipe::unitePipes(std::move(pipes));
+}
+
+static constexpr std::array<std::string_view, 13> optional_configuration_keys
+    = {"json_str",
+       "random_seed",
+       "reuse_output",
+       "probability",
+       "max_output_length",
+       "max_nesting_level",
+       "max_array_size",
+       "max_object_size",
+       "max_string_value_length",
+       "min_key_length",
+       "max_key_length"};
+
+void StorageFuzzJSON::processNamedCollectionResult(Configuration & configuration, const NamedCollection & collection)
+{
+    validateNamedCollection(
+        collection,
+        std::unordered_set<std::string>(),
+        std::unordered_set<std::string>(optional_configuration_keys.begin(), optional_configuration_keys.end()));
+
+    if (collection.has("json_str"))
+        configuration.json_str = collection.get<String>("json_str");
+
+    if (collection.has("random_seed"))
+        configuration.random_seed = collection.get<UInt64>("random_seed");
+
+    if (collection.has("reuse_output"))
+        configuration.should_reuse_output = static_cast<bool>(collection.get<UInt64>("reuse_output"));
+
+    if (collection.has("probability"))
+    {
+        configuration.probability = collection.get<Float64>("probability");
+
+        if (configuration.probability < 0.0 || configuration.probability > 1.0)
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "The value of the 'probability' argument must be within the interval [0, 1].");
+    }
+
+    if (collection.has("max_output_length"))
+    {
+        configuration.max_output_length = collection.get<UInt64>("max_output_length");
+
+        if (configuration.max_output_length < 2 || configuration.max_output_length > configuration.output_length_limit)
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "The value of the 'max_output_length' argument must be within the interval [2, {}.]",
+                configuration.output_length_limit);
+    }
+
+    if (collection.has("max_nesting_level"))
+        configuration.max_nesting_level = collection.get<UInt64>("max_nesting_level");
+
+    if (collection.has("max_array_size"))
+        configuration.max_array_size = collection.get<UInt64>("max_array_size");
+
+    if (collection.has("max_object_size"))
+        configuration.max_object_size = collection.get<UInt64>("max_object_size");
+
+    if (collection.has("max_string_value_length"))
+    {
+        auto max_string_value_length = collection.get<UInt64>("max_string_value_length");
+        if (max_string_value_length > configuration.output_length_limit)
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "The value of the 'max_string_value_length' argument must be at most {}.",
+                configuration.output_length_limit);
+
+        configuration.max_string_value_length = std::min(max_string_value_length, configuration.max_output_length);
+    }
+
+    if (collection.has("max_key_length"))
+    {
+        auto max_key_length = collection.get<UInt64>("max_key_length");
+        if (max_key_length > configuration.output_length_limit)
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "The value of the 'max_key_length' argument must be less or equal than {}.",
+                configuration.output_length_limit);
+        configuration.max_key_length = std::min(max_key_length, configuration.max_output_length);
+        configuration.min_key_length = std::min(configuration.min_key_length, configuration.max_key_length);
+    }
+
+    if (collection.has("min_key_length"))
+    {
+        auto min_key_length = collection.get<UInt64>("min_key_length");
+        if (min_key_length == 0)
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "The value of the 'min_key_length' argument must be at least 1.");
+
+        if (collection.has("max_key_length") && collection.get<UInt64>("max_key_length") < min_key_length)
+            throw Exception(
+                ErrorCodes::BAD_ARGUMENTS,
+                "The value of the 'min_key_length' argument must be less or equal than "
+                "the value of the 'max_key_lenght' argument.");
+
+        configuration.min_key_length = min_key_length;
+        configuration.max_key_length = std::max(configuration.max_key_length, configuration.min_key_length);
+    }
+}
+
+StorageFuzzJSON::Configuration StorageFuzzJSON::getConfiguration(ASTs & engine_args, ContextPtr local_context)
+{
+    StorageFuzzJSON::Configuration configuration{};
+
+    if (auto named_collection = tryGetNamedCollectionWithOverrides(engine_args, local_context))
+    {
+        StorageFuzzJSON::processNamedCollectionResult(configuration, *named_collection);
+    }
+    else
+    {
+        // Supported signatures:
+        //
+        // FuzzJSON('json_str')
+        // FuzzJSON('json_str', 'random_seed')
+        if (engine_args.empty() || engine_args.size() > 2)
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "FuzzJSON requires 1 to 2 arguments: "
+                "json_str, random_seed");
+        for (auto & engine_arg : engine_args)
+            engine_arg = evaluateConstantExpressionOrIdentifierAsLiteral(engine_arg, local_context);
+
+        auto first_arg = checkAndGetLiteralArgument<String>(engine_args[0], "json_str");
+        configuration.json_str = std::move(first_arg);
+
+        if (engine_args.size() == 2)
+        {
+            const auto & literal = engine_args[1]->as<const ASTLiteral &>();
+            if (!literal.value.isNull())
+                configuration.random_seed = checkAndGetLiteralArgument<UInt64>(literal, "random_seed");
+        }
+    }
+    return configuration;
+}
+
+void registerStorageFuzzJSON(StorageFactory & factory)
+{
+    factory.registerStorage(
+        "FuzzJSON",
+        [](const StorageFactory::Arguments & args) -> std::shared_ptr<StorageFuzzJSON>
+        {
+            ASTs & engine_args = args.engine_args;
+
+            if (engine_args.empty())
+                throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Storage FuzzJSON must have arguments.");
+
+            StorageFuzzJSON::Configuration configuration = StorageFuzzJSON::getConfiguration(engine_args, args.getLocalContext());
+            return std::make_shared<StorageFuzzJSON>(args.table_id, args.columns, args.comment, configuration);
+        });
+}
+
+}
diff --git a/src/Storages/StorageFuzzJSON.h b/src/Storages/StorageFuzzJSON.h
new file mode 100644
index 000000000000..98cde1e83fdb
--- /dev/null
+++ b/src/Storages/StorageFuzzJSON.h
@@ -0,0 +1,68 @@
+#pragma once
+
+#include <Storages/IStorage.h>
+#include <Storages/StorageConfiguration.h>
+#include <Common/randomSeed.h>
+
+namespace DB
+{
+
+class NamedCollection;
+
+class StorageFuzzJSON final : public IStorage
+{
+public:
+    struct Configuration : public StatelessTableEngineConfiguration
+    {
+        // A full N-ary tree may be memory-intensive as it can potentially contain
+        // up to (B^(D + 1) - 1) / (B - 1) nodes, where B is the number of branches,
+        // and D is the depth of the tree. Therefore, a value number limit is introduced.
+        // This limit includes complex values (arrays and nested objects).
+        static constexpr UInt64 value_number_limit = 1000;
+        static constexpr UInt64 output_length_limit = 1LU << 16;
+
+        String json_str = "{}";
+        UInt64 random_seed = randomSeed();
+        bool should_reuse_output = false;
+        Float64 probability = 0.25;
+
+        UInt64 max_output_length = 1024;
+
+        // Key parameters
+        UInt64 min_key_length = 4;
+        UInt64 max_key_length = 20;
+
+        // Value parameters
+        // Maximum number of fields (key-value pairs) at each level of a JSON.
+        UInt64 max_object_size = 10;
+        // Maximum number of elements within a JSON array.
+        UInt64 max_array_size = 10;
+        // Max depth of nested structures. How deeply objects or arrays can be
+        // nested within one another.
+        UInt64 max_nesting_level = 5;
+        UInt64 max_string_value_length = 32;
+    };
+
+    StorageFuzzJSON(
+        const StorageID & table_id_, const ColumnsDescription & columns_, const String & comment_, const Configuration & config_);
+
+    std::string getName() const override { return "FuzzJSON"; }
+
+    Pipe read(
+        const Names & column_names,
+        const StorageSnapshotPtr & storage_snapshot,
+        SelectQueryInfo & query_info,
+        ContextPtr context,
+        QueryProcessingStage::Enum processed_stage,
+        size_t max_block_size,
+        size_t num_streams) override;
+
+    static void processNamedCollectionResult(Configuration & configuration, const NamedCollection & collection);
+
+    static StorageFuzzJSON::Configuration getConfiguration(ASTs & engine_args, ContextPtr local_context);
+
+private:
+    const Configuration config;
+};
+
+}
diff --git a/src/Storages/registerStorages.cpp b/src/Storages/registerStorages.cpp
index b971e9b623ad..c05ff7d613c0 100644
--- a/src/Storages/registerStorages.cpp
+++ b/src/Storages/registerStorages.cpp
@@ -25,6 +25,7 @@ void registerStorageLiveView(StorageFactory & factory);
 void registerStorageGenerateRandom(StorageFactory & factory);
 void registerStorageExecutable(StorageFactory & factory);
 void registerStorageWindowView(StorageFactory & factory);
+void registerStorageFuzzJSON(StorageFactory & factory);
 
 #if USE_AWS_S3
 void registerStorageS3(StorageFactory & factory);
@@ -123,8 +124,9 @@ void registerStorages()
     registerStorageGenerateRandom(factory);
     registerStorageExecutable(factory);
     registerStorageWindowView(factory);
+    registerStorageFuzzJSON(factory);
 
-    #if USE_AWS_S3
+#if USE_AWS_S3
     registerStorageS3(factory);
     registerStorageCOS(factory);
     registerStorageOSS(factory);
diff --git a/src/TableFunctions/CMakeLists.txt b/src/TableFunctions/CMakeLists.txt
index b02a0e79f9cb..770990cc405b 100644
--- a/src/TableFunctions/CMakeLists.txt
+++ b/src/TableFunctions/CMakeLists.txt
@@ -28,3 +28,11 @@ endif ()
 if (TARGET ch_contrib::azure_sdk)
     target_link_libraries(clickhouse_table_functions PRIVATE ch_contrib::azure_sdk)
 endif ()
+
+if (TARGET ch_contrib::simdjson)
+    target_link_libraries(clickhouse_table_functions PRIVATE ch_contrib::simdjson)
+endif ()
+
+if (TARGET ch_contrib::rapidjson)
+    target_link_libraries(clickhouse_table_functions PRIVATE ch_contrib::rapidjson)
+endif ()
diff --git a/src/TableFunctions/TableFunctionFuzzJSON.cpp b/src/TableFunctions/TableFunctionFuzzJSON.cpp
new file mode 100644
index 000000000000..629fbd54b62c
--- /dev/null
+++ b/src/TableFunctions/TableFunctionFuzzJSON.cpp
@@ -0,0 +1,59 @@
+#include <TableFunctions/TableFunctionFuzzJSON.h>
+
+#include <DataTypes/DataTypeString.h>
+#include <Storages/checkAndGetLiteralArgument.h>
+#include <TableFunctions/TableFunctionFactory.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+
+extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
+
+}
+
+void TableFunctionFuzzJSON::parseArguments(const ASTPtr & ast_function, ContextPtr context)
+{
+    ASTs & args_func = ast_function->children;
+
+    if (args_func.size() != 1)
+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, "Table function '{}' must have arguments", getName());
+
+    auto args = args_func.at(0)->children;
+    configuration = StorageFuzzJSON::getConfiguration(args, context);
+}
+
+ColumnsDescription TableFunctionFuzzJSON::getActualTableStructure(ContextPtr /*context*/, bool /*is_insert_query*/) const
+{
+    return ColumnsDescription{{"json", std::make_shared<DataTypeString>()}};
+}
+
+StoragePtr TableFunctionFuzzJSON::executeImpl(
+    const ASTPtr & /*ast_function*/,
+    ContextPtr context,
+    const std::string & table_name,
+    ColumnsDescription /*cached_columns*/,
+    bool is_insert_query) const
+{
+    ColumnsDescription columns = getActualTableStructure(context, is_insert_query);
+    auto res = std::make_shared<StorageFuzzJSON>(
+        StorageID(getDatabaseName(), table_name),
+        columns,
+        /* comment */ String{},
+        configuration);
+    res->startup();
+    return res;
+}
+
+void registerTableFunctionFuzzJSON(TableFunctionFactory & factory)
+{
+    factory.registerFunction<TableFunctionFuzzJSON>(
+        {.documentation
+         = {.description = "Perturbs a JSON string with random variations.",
+            .returned_value = "A table object with a a single column containing perturbed JSON strings."},
+         .allow_readonly = true});
+}
+
+}
diff --git a/src/TableFunctions/TableFunctionFuzzJSON.h b/src/TableFunctions/TableFunctionFuzzJSON.h
new file mode 100644
index 000000000000..821e58bbf8ae
--- /dev/null
+++ b/src/TableFunctions/TableFunctionFuzzJSON.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include <optional>
+
+#include <Storages/StorageFuzzJSON.h>
+#include <TableFunctions/ITableFunction.h>
+
+namespace DB
+{
+
+class TableFunctionFuzzJSON : public ITableFunction
+{
+public:
+    static constexpr auto name = "fuzzJSON";
+    std::string getName() const override { return name; }
+
+    void parseArguments(const ASTPtr & ast_function, ContextPtr context) override;
+
+    ColumnsDescription getActualTableStructure(ContextPtr context, bool is_insert_query) const override;
+
+private:
+    StoragePtr executeImpl(
+        const ASTPtr & ast_function,
+        ContextPtr context,
+        const std::string & table_name,
+        ColumnsDescription cached_columns,
+        bool is_insert_query) const override;
+
+    const char * getStorageTypeName() const override { return "FuzzJSON"; }
+
+    String source;
+    std::optional<UInt64> random_seed;
+    std::optional<bool> should_reuse_output;
+    std::optional<UInt64> max_output_length;
+
+    StorageFuzzJSON::Configuration configuration;
+};
+
+}
diff --git a/src/TableFunctions/registerTableFunctions.cpp b/src/TableFunctions/registerTableFunctions.cpp
index de29c8074b1e..33029475dac1 100644
--- a/src/TableFunctions/registerTableFunctions.cpp
+++ b/src/TableFunctions/registerTableFunctions.cpp
@@ -22,6 +22,7 @@ void registerTableFunctions()
     registerTableFunctionGenerate(factory);
     registerTableFunctionMongoDB(factory);
     registerTableFunctionRedis(factory);
+    registerTableFunctionFuzzJSON(factory);
 
 #if USE_AWS_S3
     registerTableFunctionS3(factory);
diff --git a/src/TableFunctions/registerTableFunctions.h b/src/TableFunctions/registerTableFunctions.h
index 4e39324aba6f..db9451682824 100644
--- a/src/TableFunctions/registerTableFunctions.h
+++ b/src/TableFunctions/registerTableFunctions.h
@@ -19,6 +19,7 @@ void registerTableFunctionInput(TableFunctionFactory & factory);
 void registerTableFunctionGenerate(TableFunctionFactory & factory);
 void registerTableFunctionMongoDB(TableFunctionFactory & factory);
 void registerTableFunctionRedis(TableFunctionFactory & factory);
+void registerTableFunctionFuzzJSON(TableFunctionFactory & factory);
 
 #if USE_AWS_S3
 void registerTableFunctionS3(TableFunctionFactory & factory);
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 86f59e52482a..2ba72c11e788 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1,4 +1,4 @@
-personal_ws-1.1 en 2646 
+personal_ws-1.1 en 2646
 AArch
 ACLs
 ALTERs
@@ -1512,6 +1512,7 @@ fromUnixTimestampInJodaSyntax
 fsync
 func
 fuzzBits
+fuzzJSON
 fuzzer
 fuzzers
 gRPC
