{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 43925,
  "instance_id": "ClickHouse__ClickHouse-43925",
  "issue_numbers": [
    "28967"
  ],
  "base_commit": "9c81fd7afc4c44264248fe9c2c0116decd013372",
  "patch": "diff --git a/src/Common/StringUtils/StringUtils.h b/src/Common/StringUtils/StringUtils.h\nindex b5a081ab6934..72f172a1e450 100644\n--- a/src/Common/StringUtils/StringUtils.h\n+++ b/src/Common/StringUtils/StringUtils.h\n@@ -156,6 +156,20 @@ inline bool isValidIdentifier(std::string_view str)\n         && !(str.size() == strlen(\"null\") && 0 == strncasecmp(str.data(), \"null\", strlen(\"null\")));\n }\n \n+\n+inline bool isNumberSeparator(bool is_start_of_block, bool is_hex, const char * pos, const char * end)\n+{\n+    if (*pos != '_')\n+        return false;\n+    if (is_start_of_block && *pos == '_')\n+        return false; // e.g. _123, 12e_3\n+    if (pos + 1 < end && !(is_hex ? isHexDigit(pos[1]) : isNumericASCII(pos[1])))\n+        return false; // e.g. 1__2, 1_., 1_e, 1_p, 1_;\n+    if (pos + 1 == end)\n+        return false; // e.g. 12_\n+    return true;\n+}\n+\n /// Works assuming isAlphaASCII.\n inline char toLowerIfAlphaASCII(char c)\n {\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 080277539844..74d142924596 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -830,21 +830,65 @@ bool ParserNumber::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n     if (!pos.isValid())\n         return false;\n \n-    /** Maximum length of number. 319 symbols is enough to write maximum double in decimal form.\n-      * Copy is needed to use strto* functions, which require 0-terminated string.\n-      */\n-    static constexpr size_t MAX_LENGTH_OF_NUMBER = 319;\n+    auto try_read_float = [&](const char * it, const char * end)\n+    {\n+        char * str_end;\n+        errno = 0;    /// Functions strto* don't clear errno.\n+        Float64 float_value = std::strtod(it, &str_end);\n+        if (str_end == end && errno != ERANGE)\n+        {\n+            if (float_value < 0)\n+                throw Exception(\"Logical error: token number cannot begin with minus, but parsed float number is less than zero.\", ErrorCodes::LOGICAL_ERROR);\n+\n+            if (negative)\n+                float_value = -float_value;\n+\n+            res = float_value;\n+\n+            auto literal = std::make_shared<ASTLiteral>(res);\n+            literal->begin = literal_begin;\n+            literal->end = ++pos;\n+            node = literal;\n+\n+            return true;\n+        }\n+\n+        expected.add(pos, \"number\");\n+        return false;\n+    };\n \n-    if (pos->size() > MAX_LENGTH_OF_NUMBER)\n+    /// NaN and Inf\n+    if (pos->type == TokenType::BareWord)\n+    {\n+        return try_read_float(pos->begin, pos->end);\n+    }\n+\n+    if (pos->type != TokenType::Number)\n     {\n         expected.add(pos, \"number\");\n         return false;\n     }\n \n+    /** Maximum length of number. 319 symbols is enough to write maximum double in decimal form.\n+      * Copy is needed to use strto* functions, which require 0-terminated string.\n+      */\n+    static constexpr size_t MAX_LENGTH_OF_NUMBER = 319;\n+\n     char buf[MAX_LENGTH_OF_NUMBER + 1];\n \n-    size_t size = pos->size();\n-    memcpy(buf, pos->begin, size);\n+    size_t buf_size = 0;\n+    for (const auto * it = pos->begin; it != pos->end; ++it)\n+    {\n+        if (*it != '_')\n+            buf[buf_size++] = *it;\n+        if (unlikely(buf_size > MAX_LENGTH_OF_NUMBER))\n+        {\n+            expected.add(pos, \"number\");\n+            return false;\n+        }\n+    }\n+\n+    size_t size = buf_size;\n     buf[size] = 0;\n     char * start_pos = buf;\n \n@@ -915,29 +959,7 @@ bool ParserNumber::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return true;\n     }\n \n-    char * pos_double = buf;\n-    errno = 0;    /// Functions strto* don't clear errno.\n-    Float64 float_value = std::strtod(buf, &pos_double);\n-    if (pos_double == buf + pos->size() && errno != ERANGE)\n-    {\n-        if (float_value < 0)\n-            throw Exception(\"Logical error: token number cannot begin with minus, but parsed float number is less than zero.\", ErrorCodes::LOGICAL_ERROR);\n-\n-        if (negative)\n-            float_value = -float_value;\n-\n-        res = float_value;\n-\n-        auto literal = std::make_shared<ASTLiteral>(res);\n-        literal->begin = literal_begin;\n-        literal->end = ++pos;\n-        node = literal;\n-\n-        return true;\n-    }\n-\n-    expected.add(pos, \"number\");\n-    return false;\n+    return try_read_float(buf, buf + buf_size);\n }\n \n \ndiff --git a/src/Parsers/Lexer.cpp b/src/Parsers/Lexer.cpp\nindex debcd9e7fd46..6bd27ee62aea 100644\n--- a/src/Parsers/Lexer.cpp\n+++ b/src/Parsers/Lexer.cpp\n@@ -105,44 +105,71 @@ Token Lexer::nextTokenImpl()\n             if (prev_significant_token_type == TokenType::Dot)\n             {\n                 ++pos;\n-                while (pos < end && isNumericASCII(*pos))\n+                while (pos < end && (isNumericASCII(*pos) || isNumberSeparator(false, false, pos, end)))\n                     ++pos;\n             }\n             else\n             {\n+                bool start_of_block = false;\n                 /// 0x, 0b\n                 bool hex = false;\n                 if (pos + 2 < end && *pos == '0' && (pos[1] == 'x' || pos[1] == 'b' || pos[1] == 'X' || pos[1] == 'B'))\n                 {\n+                    bool is_valid = false;\n                     if (pos[1] == 'x' || pos[1] == 'X')\n-                        hex = true;\n-                    pos += 2;\n+                    {\n+                        if (isHexDigit(pos[2]))\n+                        {\n+                            hex = true;\n+                            is_valid = true; // hex\n+                        }\n+                    }\n+                    else if (pos[2] == '0' || pos[2] == '1')\n+                        is_valid = true; // bin\n+                    if (is_valid)\n+                    {\n+                        pos += 2;\n+                        start_of_block = true;\n+                    }\n+                    else\n+                        ++pos; // consume the leading zero - could be an identifier\n                 }\n                 else\n                     ++pos;\n \n-                while (pos < end && (hex ? isHexDigit(*pos) : isNumericASCII(*pos)))\n+                while (pos < end && ((hex ? isHexDigit(*pos) : isNumericASCII(*pos)) || isNumberSeparator(start_of_block, hex, pos, end)))\n+                {\n                     ++pos;\n+                    start_of_block = false;\n+                }\n \n                 /// decimal point\n                 if (pos < end && *pos == '.')\n                 {\n+                    start_of_block = true;\n                     ++pos;\n-                    while (pos < end && (hex ? isHexDigit(*pos) : isNumericASCII(*pos)))\n+                    while (pos < end && ((hex ? isHexDigit(*pos) : isNumericASCII(*pos)) || isNumberSeparator(start_of_block, hex, pos, end)))\n+                    {\n                         ++pos;\n+                        start_of_block = false;\n+                    }\n                 }\n \n                 /// exponentiation (base 10 or base 2)\n                 if (pos + 1 < end && (hex ? (*pos == 'p' || *pos == 'P') : (*pos == 'e' || *pos == 'E')))\n                 {\n+                    start_of_block = true;\n                     ++pos;\n \n                     /// sign of exponent. It is always decimal.\n                     if (pos + 1 < end && (*pos == '-' || *pos == '+'))\n                         ++pos;\n \n-                    while (pos < end && isNumericASCII(*pos))\n+                    while (pos < end && (isNumericASCII(*pos) || isNumberSeparator(start_of_block, false, pos, end)))\n+                    {\n                         ++pos;\n+                        start_of_block = false;\n+                    }\n                 }\n             }\n \n@@ -201,21 +228,29 @@ Token Lexer::nextTokenImpl()\n                     || prev_significant_token_type == TokenType::Number))\n                 return Token(TokenType::Dot, token_begin, ++pos);\n \n+            bool start_of_block = true;\n             ++pos;\n-            while (pos < end && isNumericASCII(*pos))\n+            while (pos < end && (isNumericASCII(*pos) || isNumberSeparator(start_of_block, false, pos, end)))\n+            {\n                 ++pos;\n+                start_of_block = false;\n+            }\n \n             /// exponentiation\n             if (pos + 1 < end && (*pos == 'e' || *pos == 'E'))\n             {\n+                start_of_block = true;\n                 ++pos;\n \n                 /// sign of exponent\n                 if (pos + 1 < end && (*pos == '-' || *pos == '+'))\n                     ++pos;\n \n-                while (pos < end && isNumericASCII(*pos))\n+                while (pos < end && (isNumericASCII(*pos) || isNumberSeparator(start_of_block, false, pos, end)))\n+                {\n                     ++pos;\n+                    start_of_block = false;\n+                }\n             }\n \n             return Token(TokenType::Number, token_begin, pos);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02493_inconsistent_hex_and_binary_number.expect b/tests/queries/0_stateless/02493_inconsistent_hex_and_binary_number.expect\nnew file mode 100755\nindex 000000000000..a391756ba226\n--- /dev/null\n+++ b/tests/queries/0_stateless/02493_inconsistent_hex_and_binary_number.expect\n@@ -0,0 +1,40 @@\n+#!/usr/bin/expect -f\n+\n+set basedir [file dirname $argv0]\n+set basename [file tail $argv0]\n+exp_internal -f $env(CLICKHOUSE_TMP)/$basename.debuglog 0\n+\n+log_user 0\n+set timeout 60\n+match_max 100000\n+set stty_init \"rows 25 cols 120\"\n+\n+expect_after {\n+    eof { exp_continue }\n+    timeout { exit 1 }\n+}\n+\n+spawn bash\n+send \"source $basedir/../shell_config.sh\\r\"\n+\n+send \"\\$CLICKHOUSE_CLIENT --query 'select 0b'\\r\"\n+expect \"DB::Exception: Missing columns: '0b' while processing query: 'SELECT `0b`', required columns: '0b'. (UNKNOWN_IDENTIFIER)\"\n+\n+send \"\\$CLICKHOUSE_CLIENT --query 'select 0b;'\\r\"\n+expect \"DB::Exception: Missing columns: '0b' while processing query: 'SELECT `0b`', required columns: '0b'. (UNKNOWN_IDENTIFIER)\"\n+\n+send \"\\$CLICKHOUSE_CLIENT --query 'select 0b ;'\\r\"\n+expect \"DB::Exception: Missing columns: '0b' while processing query: 'SELECT `0b`', required columns: '0b'. (UNKNOWN_IDENTIFIER)\"\n+\n+\n+send \"\\$CLICKHOUSE_CLIENT --query 'select 0x'\\r\"\n+expect \"DB::Exception: Missing columns: '0x' while processing query: 'SELECT `0x`', required columns: '0x'. (UNKNOWN_IDENTIFIER)\"\n+\n+send \"\\$CLICKHOUSE_CLIENT --query 'select 0x;'\\r\"\n+expect \"DB::Exception: Missing columns: '0x' while processing query: 'SELECT `0x`', required columns: '0x'. (UNKNOWN_IDENTIFIER)\"\n+\n+send \"\\$CLICKHOUSE_CLIENT --query 'select 0x ;'\\r\"\n+expect \"DB::Exception: Missing columns: '0x' while processing query: 'SELECT `0x`', required columns: '0x'. (UNKNOWN_IDENTIFIER)\"\n+\n+send \"exit\\r\"\n+expect eof\ndiff --git a/tests/queries/0_stateless/02493_inconsistent_hex_and_binary_number.reference b/tests/queries/0_stateless/02493_inconsistent_hex_and_binary_number.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02493_numeric_literals_with_underscores.reference b/tests/queries/0_stateless/02493_numeric_literals_with_underscores.reference\nnew file mode 100644\nindex 000000000000..482ad63ffebc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02493_numeric_literals_with_underscores.reference\n@@ -0,0 +1,126 @@\n+1234\n+1234\n+1234\n+1234\n+1234\n+1234\n+-1234\n+-1234\n+-1234\n+12.34\n+12.34\n+12.34\n+12.34\n+-12.34\n+-12.34\n+-12.34\n+-12.34\n+3.4e22\n+3.4e22\n+3.4e22\n+3.4e22\n+3.4e22\n+3.4e22\n+3.4e22\n+3.4e22\n+3.4e-20\n+3.4e-20\n+3.4e-20\n+3.4e-20\n+-3.4e22\n+-3.4e22\n+-3.4e22\n+-3.4e22\n+-3.4e22\n+-3.4e22\n+-3.4e22\n+-3.4e22\n+-3.4e-20\n+-3.4e-20\n+-3.4e-20\n+-3.4e-20\n+1.34e21\n+1.34e21\n+1.34e21\n+1.34e21\n+1.34e21\n+1.34e21\n+1.34e21\n+1.34e21\n+1.34e-21\n+1.34e-21\n+1.34e-21\n+1.34e-21\n+-1.34e21\n+-1.34e21\n+-1.34e21\n+-1.34e21\n+-1.34e21\n+-1.34e21\n+-1.34e21\n+-1.34e21\n+-1.34e-21\n+-1.34e-21\n+-1.34e-21\n+-1.34e-21\n+-340000000000000000000\n+-340000000000000000000\n+-340000000000000000000\n+-340000000000000000000\n+-340000000000000000000\n+-340000000000000000000\n+-340000000000000000000\n+-340000000000000000000\n+-3.4e-22\n+-3.4e-22\n+-3.4e-22\n+-3.4e-22\n+nan\n+nan\n+inf\n+inf\n+-inf\n+inf\n+inf\n+-inf\n+inf\n+inf\n+-inf\n+15\n+15\n+15\n+-15\n+-15\n+-15\n+4660\n+4660\n+4660\n+-4660\n+-4660\n+-4660\n+238\n+238\n+1.1376953125\n+1.1376953125\n+-1.1376953125\n+-1.1376953125\n+0.9296875\n+0.9296875\n+2.275390625\n+2.275390625\n+2.275390625\n+2.275390625\n+2.275390625\n+2.275390625\n+0.56884765625\n+0.56884765625\n+0.56884765625\n+-2.275390625\n+-2.275390625\n+-2.275390625\n+-2.275390625\n+-2.275390625\n+-2.275390625\n+-0.56884765625\n+-0.56884765625\n+-0.56884765625\ndiff --git a/tests/queries/0_stateless/02493_numeric_literals_with_underscores.sql b/tests/queries/0_stateless/02493_numeric_literals_with_underscores.sql\nnew file mode 100644\nindex 000000000000..a0042fac4c46\n--- /dev/null\n+++ b/tests/queries/0_stateless/02493_numeric_literals_with_underscores.sql\n@@ -0,0 +1,154 @@\n+SELECT 1234; -- Positive integer (+ implied)\n+SELECT 1_234;\n+SELECT 1_2_3_4;\n+SELECT +1234; -- Positive integer (+ explicit)\n+SELECT +1_234;\n+SELECT +1_2_3_4;\n+SELECT -1234; -- Negative integer\n+SELECT -1_234;\n+SELECT -1_2_3_4;\n+SELECT 12.34; -- Positive floating point with . notation\n+SELECT 12.3_4;\n+SELECT 1_2.34;\n+SELECT 1_2.3_4;\n+SELECT -12.34; -- Negative floating point with . notation\n+SELECT -12.3_4;\n+SELECT -1_2.34;\n+SELECT -1_2.3_4;\n+SELECT 34e21; -- Positive floating point with positive scientific notation (+ implied)\n+SELECT 3_4e21;\n+SELECT 34e2_1;\n+SELECT 3_4e2_1;\n+SELECT 34e+21; -- Positive floating point with positive scientific notation (+ explicit)\n+SELECT 3_4e+21;\n+SELECT 34e+2_1;\n+SELECT 3_4e+2_1;\n+SELECT 34e-21; -- Positive floating point with negative scientific notation\n+SELECT 3_4e-21;\n+SELECT 34e-2_1;\n+SELECT 3_4e-2_1;\n+SELECT -34e21; -- Negative floating point with positive scientific notation (+ implied)\n+SELECT -3_4e21;\n+SELECT -34e2_1;\n+SELECT -3_4e2_1;\n+SELECT -34e+21; -- Negative floating point with positive scientific notation (+ explicit)\n+SELECT -3_4e+21;\n+SELECT -34e+2_1;\n+SELECT -3_4e+2_1;\n+SELECT -34e-21; -- Negative floating point with negative scientific notation\n+SELECT -3_4e-21;\n+SELECT -34e-2_1;\n+SELECT -3_4e-2_1;\n+SELECT 1.34e21; -- Positive floating point (with .) with positive scientific notation (+ implied)\n+SELECT 1.3_4e21;\n+SELECT 1.34e2_1;\n+SELECT 1.3_4e2_1;\n+SELECT 1.34e+21; -- Positive floating point (with .) with positive scientific notation (+ explicit)\n+SELECT 1.3_4e+21;\n+SELECT 1.34e+2_1;\n+SELECT 1.3_4e+2_1;\n+SELECT 1.34e-21; -- Positive floating point (with .) with negative scientific notation\n+SELECT 1.3_4e-21;\n+SELECT 1.34e-2_1;\n+SELECT 1.3_4e-2_1;\n+SELECT -1.34e21; -- Negative floating point (with .) with positive scientific notation (+ implied)\n+SELECT -1.3_4e21;\n+SELECT -1.34e2_1;\n+SELECT -1.3_4e2_1;\n+SELECT -1.34e+21; -- Negative floating point (with .) with positive scientific notation (+ explicit)\n+SELECT -1.3_4e+21;\n+SELECT -1.34e+2_1;\n+SELECT -1.3_4e+2_1;\n+SELECT -1.34e-21; -- Negative floating point (with .) with negative scientific notation\n+SELECT -1.3_4e-21;\n+SELECT -1.34e-2_1;\n+SELECT -1.3_4e-2_1;\n+SELECT -.34e21; -- Negative floating point (with .) with positive scientific notation (+ implied)\n+SELECT -.3_4e21;\n+SELECT -.34e2_1;\n+SELECT -.3_4e2_1;\n+SELECT -.34e+21; -- Negative floating point (with .) with positive scientific notation (+ explicit)\n+SELECT -.3_4e+21;\n+SELECT -.34e+2_1;\n+SELECT -.3_4e+2_1;\n+SELECT -.34e-21; -- Negative floating point (with .) with negative scientific notation\n+SELECT -.3_4e-21;\n+SELECT -.34e-2_1;\n+SELECT -.3_4e-2_1;\n+SELECT NaN; -- Specials\n+SELECT nan;\n+SELECT inf;\n+SELECT +inf;\n+SELECT -inf;\n+SELECT Inf;\n+SELECT +Inf;\n+SELECT -Inf;\n+SELECT INF;\n+SELECT +INF;\n+SELECT -INF;\n+SELECT 0b1111; -- Binary\n+SELECT 0b1_111;\n+SELECT 0b1_1_1_1;\n+SELECT -0b1111;\n+SELECT -0b1_111;\n+SELECT -0b1_1_1_1;\n+SELECT 0x1234; -- Hex\n+SELECT 0x1_234;\n+SELECT 0x1_2_3_4;\n+SELECT -0x1234;\n+SELECT -0x1_234;\n+SELECT -0x1_2_3_4;\n+SELECT 0xee;\n+SELECT 0xe_e;\n+SELECT 0x1.234; -- Hex fractions\n+SELECT 0x1.2_3_4;\n+SELECT -0x1.234;\n+SELECT -0x1.2_3_4;\n+SELECT 0x0.ee;\n+SELECT 0x0.e_e;\n+SELECT 0x1.234p01; -- Hex scientific notation\n+SELECT 0x1.2_34p01;\n+SELECT 0x1.234p0_1;\n+SELECT 0x1.234p+01;\n+SELECT 0x1.2_34p+01;\n+SELECT 0x1.2_34p+0_1;\n+SELECT 0x1.234p-01;\n+SELECT 0x1.2_34p-01;\n+SELECT 0x1.2_34p-0_1;\n+SELECT -0x1.234p01;\n+SELECT -0x1.2_34p01;\n+SELECT -0x1.2_34p0_1;\n+SELECT -0x1.234p+01;\n+SELECT -0x1.2_34p+01;\n+SELECT -0x1.2_34p+0_1;\n+SELECT -0x1.234p-01;\n+SELECT -0x1.2_34p-01;\n+SELECT -0x1.2_34p-0_1;\n+\n+-- Things that are not a number\n+\n+select _1000; -- { serverError UNKNOWN_IDENTIFIER }\n+select _1000 FROM (SELECT 1 AS _1000) FORMAT Null;\n+select -_1; -- { serverError UNKNOWN_IDENTIFIER }\n+select -_1 FROM (SELECT -1 AS _1) FORMAT Null;\n+select +_1; -- { clientError SYNTAX_ERROR }\n+select 1__0; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1_; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1_ ; -- { serverError UNKNOWN_IDENTIFIER }\n+select 10_; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1_e5; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1e_5; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1e5_; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1e_; -- { serverError UNKNOWN_IDENTIFIER }\n+select 1_.; -- { clientError SYNTAX_ERROR }\n+select 1e_1; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0_x2; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x2_p2; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x2p_2; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x2p2_; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0b; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0b ; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x ; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x_; -- { serverError UNKNOWN_IDENTIFIER }\n+select 0x_1; -- { serverError UNKNOWN_IDENTIFIER }\n",
  "problem_statement": "Should we support numeric literals in form of 1_000_000? (with underscore separator of groups).\nPros:\r\n- it is convenient to type and read numbers this way;\r\n- Ada, Perl, C++, Go and Rust already support that;\r\n- can support thousands as well as lakhs and crores;\r\n\r\nCons:\r\n- standard SQL does not have this support;\r\n- PostgreSQL treat `SELECT 1_000_000` as number one with `_000_000` alias: http://sqlfiddle.com/#!17/0a28f/400\r\n- C++ has `1'000'000` instead of `1_000_000`;\r\n\r\nWhat do you think?\r\n\n",
  "hints_text": "I'd like to have such feature... I'm always confusing number of zeros. I'd prefer to have `1'000'000` but I understand that it's impossible in SQL.\nbeing able to do an output format with a separator would be nice too.  :)\nOnly one thumb up in 4 months.\nOnly one thumb up in 8 months.\nWow. 7 thumb-ups.\nHi, I'd like to have a try on this one.\n@jh0x yes, you can pull the code from this pull request: https://github.com/ClickHouse/ClickHouse/pull/39129\r\nand continue working on it to address the review comments.",
  "created_at": "2022-12-04T19:20:18Z"
}