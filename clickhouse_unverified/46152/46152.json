{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 46152,
  "instance_id": "ClickHouse__ClickHouse-46152",
  "issue_numbers": [
    "16733"
  ],
  "base_commit": "4fd40582597a358ed4c25eaa4a23694ffb1cf7be",
  "patch": "diff --git a/src/Common/FieldVisitorConvertToNumber.h b/src/Common/FieldVisitorConvertToNumber.h\nindex ed73cd38cda3..df884d7eebf1 100644\n--- a/src/Common/FieldVisitorConvertToNumber.h\n+++ b/src/Common/FieldVisitorConvertToNumber.h\n@@ -12,7 +12,6 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int CANNOT_CONVERT_TYPE;\n-    extern const int NOT_IMPLEMENTED;\n }\n \n \n@@ -53,7 +52,6 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n \n     T operator() (const UInt64 & x) const { return T(x); }\n     T operator() (const Int64 & x) const { return T(x); }\n-    T operator() (const Int128 & x) const { return T(x); }\n     T operator() (const UUID & x) const { return T(x.toUnderType()); }\n     T operator() (const IPv4 & x) const { return T(x.toUnderType()); }\n     T operator() (const IPv6 & x) const { return T(x.toUnderType()); }\n@@ -87,11 +85,6 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n         }\n     }\n \n-    T operator() (const UInt128 &) const\n-    {\n-        throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"Cannot convert UInt128 to {}\", demangle(typeid(T).name()));\n-    }\n-\n     template <typename U>\n     T operator() (const DecimalField<U> & x) const\n     {\n@@ -112,8 +105,6 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>\n     {\n         if constexpr (is_decimal<T>)\n             return static_cast<T>(static_cast<typename T::NativeType>(x));\n-        else if constexpr (std::is_same_v<T, UInt128>)\n-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"No conversion to old UInt128 from {}\", demangle(typeid(U).name()));\n         else\n             return static_cast<T>(x);\n     }\ndiff --git a/src/Common/FieldVisitorsAccurateComparison.h b/src/Common/FieldVisitorsAccurateComparison.h\nindex dfed2609040a..2809974efe50 100644\n--- a/src/Common/FieldVisitorsAccurateComparison.h\n+++ b/src/Common/FieldVisitorsAccurateComparison.h\n@@ -45,20 +45,20 @@ class FieldVisitorAccurateEquals : public StaticVisitor<bool>\n             if constexpr (std::is_same_v<T, U>)\n                 return l == r;\n \n-            if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)\n+            if constexpr (is_arithmetic_v<T> && is_arithmetic_v<U>)\n                 return accurate::equalsOp(l, r);\n \n             /// TODO This is wrong (does not respect scale).\n             if constexpr (is_decimal_field<T> && is_decimal_field<U>)\n                 return l == r;\n \n-            if constexpr (is_decimal_field<T> && std::is_arithmetic_v<U>)\n+            if constexpr (is_decimal_field<T> && is_arithmetic_v<U>)\n                 return l == DecimalField<Decimal256>(Decimal256(r), 0);\n \n-            if constexpr (std::is_arithmetic_v<T> && is_decimal_field<U>)\n+            if constexpr (is_arithmetic_v<T> && is_decimal_field<U>)\n                 return DecimalField<Decimal256>(Decimal256(l), 0) == r;\n \n-            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)\n+            if constexpr (std::is_same_v<T, String> && is_arithmetic_v<U>)\n             {\n                 ReadBufferFromString in(l);\n                 U parsed;\n@@ -66,7 +66,7 @@ class FieldVisitorAccurateEquals : public StaticVisitor<bool>\n                 return operator()(parsed, r);\n             }\n \n-            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)\n+            if constexpr (std::is_same_v<U, String> && is_arithmetic_v<T>)\n             {\n                 ReadBufferFromString in(r);\n                 T parsed;\n@@ -112,20 +112,20 @@ class FieldVisitorAccurateLess : public StaticVisitor<bool>\n             if constexpr (std::is_same_v<T, U>)\n                 return l < r;\n \n-            if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)\n+            if constexpr (is_arithmetic_v<T> && is_arithmetic_v<U>)\n                 return accurate::lessOp(l, r);\n \n             /// TODO This is wrong (does not respect scale).\n             if constexpr (is_decimal_field<T> && is_decimal_field<U>)\n                 return l < r;\n \n-            if constexpr (is_decimal_field<T> && std::is_arithmetic_v<U>)\n+            if constexpr (is_decimal_field<T> && is_arithmetic_v<U>)\n                 return l < DecimalField<Decimal256>(Decimal256(r), 0);\n \n-            if constexpr (std::is_arithmetic_v<T> && is_decimal_field<U>)\n+            if constexpr (is_arithmetic_v<T> && is_decimal_field<U>)\n                 return DecimalField<Decimal256>(Decimal256(l), 0) < r;\n \n-            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)\n+            if constexpr (std::is_same_v<T, String> && is_arithmetic_v<U>)\n             {\n                 ReadBufferFromString in(l);\n                 U parsed;\n@@ -133,7 +133,7 @@ class FieldVisitorAccurateLess : public StaticVisitor<bool>\n                 return operator()(parsed, r);\n             }\n \n-            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)\n+            if constexpr (std::is_same_v<U, String> && is_arithmetic_v<T>)\n             {\n                 ReadBufferFromString in(r);\n                 T parsed;\ndiff --git a/src/Interpreters/FillingRow.cpp b/src/Interpreters/FillingRow.cpp\nindex 561ac2553266..b03049a209f7 100644\n--- a/src/Interpreters/FillingRow.cpp\n+++ b/src/Interpreters/FillingRow.cpp\n@@ -49,7 +49,7 @@ bool FillingRow::next(const FillingRow & to_row)\n     size_t pos = 0;\n \n     /// Find position we need to increment for generating next row.\n-    for (; pos < size(); ++pos)\n+    for (size_t s = size(); pos < s; ++pos)\n         if (!row[pos].isNull() && !to_row.row[pos].isNull() && !equals(row[pos], to_row.row[pos]))\n             break;\n \n@@ -110,12 +110,16 @@ void FillingRow::initFromDefaults(size_t from_pos)\n void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & interpolate_columns, MutableColumns & other_columns,\n     const FillingRow & filling_row, const Block & interpolate_block)\n {\n-    for (size_t i = 0; i < filling_columns.size(); ++i)\n+    for (size_t i = 0, size = filling_columns.size(); i < size; ++i)\n     {\n         if (filling_row[i].isNull())\n+        {\n             filling_columns[i]->insertDefault();\n+        }\n         else\n+        {\n             filling_columns[i]->insert(filling_row[i]);\n+        }\n     }\n \n     if (size_t size = interpolate_block.columns())\n@@ -134,7 +138,7 @@ void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & int\n \n void copyRowFromColumns(MutableColumns & dest, const Columns & source, size_t row_num)\n {\n-    for (size_t i = 0; i < source.size(); ++i)\n+    for (size_t i = 0, size = source.size(); i < size; ++i)\n         dest[i]->insertFrom(*source[i], row_num);\n }\n \ndiff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp\nindex 2c5c550ffe22..bfee5ed8bf97 100644\n--- a/src/Processors/Transforms/FillingTransform.cpp\n+++ b/src/Processors/Transforms/FillingTransform.cpp\n@@ -27,7 +27,7 @@ Block FillingTransform::transformHeader(Block header, const SortDescription & so\n     /// Columns which are not from sorting key may not be constant anymore.\n     for (auto & column : header)\n         if (column.column && isColumnConst(*column.column) && !sort_keys.contains(column.name))\n-            column.column = column.type->createColumn();\n+            column.column = column.column->convertToFullColumnIfConst();\n \n     return header;\n }\n@@ -61,7 +61,7 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &\n     {\n         WhichDataType which_from(descr.fill_from_type);\n         if ((which_from.isDateOrDate32() || which_from.isDateTime() || which_from.isDateTime64()) &&\n-            !descr.fill_from_type->equals(*type))\n+            !descr.fill_from_type->equals(*removeNullable(type)))\n                 return false;\n     }\n \n@@ -73,8 +73,17 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &\n                 return false;\n     }\n \n-    /// TODO Wrong results for big integers.\n-    if (isInteger(type) || which.isDate() || which.isDate32() || which.isDateTime())\n+    if (which.isInt128() || which.isUInt128())\n+    {\n+        max_type = Field::Types::Int128;\n+        to_type = type;\n+    }\n+    else if (which.isInt256() || which.isUInt256())\n+    {\n+        max_type = Field::Types::Int256;\n+        to_type = type;\n+    }\n+    else if (isInteger(type) || which.isDate() || which.isDate32() || which.isDateTime())\n     {\n         max_type = Field::Types::Int64;\n         to_type = std::make_shared<DataTypeInt64>();\n@@ -100,9 +109,12 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &\n         || descr.fill_step.getType() > max_type)\n         return false;\n \n-    descr.fill_from = convertFieldToType(descr.fill_from, *to_type);\n-    descr.fill_to = convertFieldToType(descr.fill_to, *to_type);\n-    descr.fill_step = convertFieldToType(descr.fill_step, *to_type);\n+    if (!descr.fill_from.isNull())\n+        descr.fill_from = convertFieldToTypeOrThrow(descr.fill_from, *to_type);\n+    if (!descr.fill_to.isNull())\n+        descr.fill_to = convertFieldToTypeOrThrow(descr.fill_to, *to_type);\n+    if (!descr.fill_step.isNull())\n+        descr.fill_step = convertFieldToTypeOrThrow(descr.fill_step, *to_type);\n \n     if (descr.step_kind)\n     {\n@@ -184,18 +196,20 @@ FillingTransform::FillingTransform(\n         fill_column_positions.push_back(block_position);\n \n         auto & descr = filling_row.getFillDescription(i);\n-        const auto & type = header_.getByPosition(block_position).type;\n+\n+        const Block & output_header = getOutputPort().getHeader();\n+        const DataTypePtr & type = removeNullable(output_header.getByPosition(block_position).type);\n \n         if (!tryConvertFields(descr, type))\n             throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                            \"Incompatible types of WITH FILL expression values with column type {}\", type->getName());\n+                \"Incompatible types of WITH FILL expression values with column type {}\", type->getName());\n \n-        if (type->isValueRepresentedByUnsignedInteger() &&\n+        if (isUnsignedInteger(type) &&\n             ((!descr.fill_from.isNull() && less(descr.fill_from, Field{0}, 1)) ||\n              (!descr.fill_to.isNull() && less(descr.fill_to, Field{0}, 1))))\n         {\n             throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,\n-                            \"WITH FILL bound values cannot be negative for unsigned type {}\", type->getName());\n+                \"WITH FILL bound values cannot be negative for unsigned type {}\", type->getName());\n         }\n     }\n \n@@ -213,7 +227,7 @@ FillingTransform::FillingTransform(\n                     input_positions.emplace_back(idx, p->second);\n \n         if (!is_fill_column[idx] && !(interpolate_description && interpolate_description->result_columns_set.contains(column.name)))\n-                other_column_positions.push_back(idx);\n+            other_column_positions.push_back(idx);\n \n         ++idx;\n     }\n@@ -335,8 +349,8 @@ void FillingTransform::transform(Chunk & chunk)\n         interpolate();\n         while (filling_row.next(next_row))\n         {\n-                insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n-                interpolate();\n+            insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);\n+            interpolate();\n         }\n \n         setResultColumns(chunk, res_fill_columns, res_interpolate_columns, res_other_columns);\n@@ -352,7 +366,7 @@ void FillingTransform::transform(Chunk & chunk)\n \n     if (first)\n     {\n-        for (size_t i = 0; i < filling_row.size(); ++i)\n+        for (size_t i = 0, size = filling_row.size(); i < size; ++i)\n         {\n             auto current_value = (*old_fill_columns[i])[0];\n             const auto & fill_from = filling_row.getFillDescription(i).fill_from;\ndiff --git a/src/Processors/Transforms/FillingTransform.h b/src/Processors/Transforms/FillingTransform.h\nindex 5e1068e18e23..7b41ab795d19 100644\n--- a/src/Processors/Transforms/FillingTransform.h\n+++ b/src/Processors/Transforms/FillingTransform.h\n@@ -1,9 +1,11 @@\n #pragma once\n+\n #include <Processors/ISimpleTransform.h>\n #include <Core/SortDescription.h>\n #include <Core/InterpolateDescription.h>\n #include <Interpreters/FillingRow.h>\n \n+\n namespace DB\n {\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02560_with_fill_int256_int.reference b/tests/queries/0_stateless/02560_with_fill_int256_int.reference\nnew file mode 100644\nindex 000000000000..1e7b1161f54e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02560_with_fill_int256_int.reference\n@@ -0,0 +1,82 @@\n+0\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+10\n+12\n+14\n+16\n+18\n+0\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+10\n+12\n+14\n+16\n+18\n+0\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+10\n+12\n+14\n+16\n+18\n+0\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+10\n+12\n+14\n+16\n+18\n+-3\n+-2\n+-1\n+0\n+1\n+2\n+3\n+4\n+6\n+8\n+10\n+12\n+14\n+16\n+18\n+-3\n+-2\n+-1\n+0\n+1\n+2\n+3\n+4\n+6\n+8\n+10\n+12\n+14\n+16\n+18\ndiff --git a/tests/queries/0_stateless/02560_with_fill_int256_int.sql b/tests/queries/0_stateless/02560_with_fill_int256_int.sql\nnew file mode 100644\nindex 000000000000..2039f7ec2338\n--- /dev/null\n+++ b/tests/queries/0_stateless/02560_with_fill_int256_int.sql\n@@ -0,0 +1,9 @@\n+SELECT (number * 2)::Int128 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM 3 TO 8;\n+SELECT (number * 2)::Int256 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM 3 TO 8;\n+SELECT (number * 2)::UInt128 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM 3 TO 8;\n+SELECT (number * 2)::UInt256 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM 3 TO 8;\n+\n+SELECT (number * 2)::Int128 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM -3 TO 5;\n+SELECT (number * 2)::Int256 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM -3 TO 5;\n+SELECT (number * 2)::UInt128 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM -3 TO 5; -- { serverError 69 }\n+SELECT (number * 2)::UInt256 FROM numbers(10) ORDER BY 1 ASC WITH FILL FROM -3 TO 5; -- { serverError 69 }\ndiff --git a/tests/queries/0_stateless/02561_with_fill_date_datetime_incompatible.reference b/tests/queries/0_stateless/02561_with_fill_date_datetime_incompatible.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02561_with_fill_date_datetime_incompatible.sql b/tests/queries/0_stateless/02561_with_fill_date_datetime_incompatible.sql\nnew file mode 100644\nindex 000000000000..458e5047a63a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02561_with_fill_date_datetime_incompatible.sql\n@@ -0,0 +1,2 @@\n+SELECT today() AS a\n+ORDER BY a ASC WITH FILL FROM now() - toIntervalMonth(1) TO now() + toIntervalDay(1) STEP 82600; -- { serverError 475 }\ndiff --git a/tests/queries/0_stateless/02562_with_fill_nullable.reference b/tests/queries/0_stateless/02562_with_fill_nullable.reference\nnew file mode 100644\nindex 000000000000..d32f49569b4e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02562_with_fill_nullable.reference\n@@ -0,0 +1,19 @@\n+2023-02-09\n+2023-02-10\n+2023-02-11\n+2023-02-12\n+2023-02-13\n+2023-02-14\n+2023-02-15\n+2023-02-16\n+2023-02-17\n+2023-02-18\n+2023-02-19\n+---\n+2023-02-09\n+2023-02-10\n+2023-02-11\n+2023-02-12\n+2023-02-13\n+\\N\n+\\N\ndiff --git a/tests/queries/0_stateless/02562_with_fill_nullable.sql b/tests/queries/0_stateless/02562_with_fill_nullable.sql\nnew file mode 100644\nindex 000000000000..d2ca09e1a450\n--- /dev/null\n+++ b/tests/queries/0_stateless/02562_with_fill_nullable.sql\n@@ -0,0 +1,4 @@\n+SELECT toNullable('2023-02-09'::Date + number * 10) AS d FROM numbers(2) ORDER BY d WITH FILL;\n+SELECT '---';\n+SELECT number % 2 ? NULL : toNullable('2023-02-09'::Date + number) AS d FROM numbers(5) ORDER BY d ASC NULLS LAST WITH FILL;\n+-- TODO: NULLS FIRST does not work correctly with FILL.\n",
  "problem_statement": "feature request: WITH FILL expression values compatible with column type Nullable\nAppreciate for you all teams brilliant work, it's really fast and useful \r\n\r\n**Use case**\r\nA clear and concise description of what is the intended usage scenario is.\r\nmy sql\r\n`\r\n    SELECT comment_date\r\n    FROM \r\n    (\r\n    SELECT comment_time AS comment_date\r\n    FROM kimberly_nlp_wide)\r\n    GROUP BY comment_date \r\n    ORDER BY comment_date WITH FILL\r\n`\r\n\r\n**Describe the solution you'd like**\r\nA clear and concise description of what you want to happen.\r\n\r\nThe comment_time column type is Nullable(DateTime()). so it could not use \"WITH FILL\"\r\n\r\n**Describe alternatives you've considered**\r\nA clear and concise description of any alternative solutions or features you've considered.\r\ncould only change the column type or process it via Python\r\nHope CK could support it in ur next update, thank u :)\r\n\r\n**Additional context**\r\nAdd any other context or screenshots about the feature request here.\r\n\n",
  "hints_text": "",
  "created_at": "2023-02-08T07:02:16Z"
}