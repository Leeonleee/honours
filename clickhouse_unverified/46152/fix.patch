diff --git a/src/Common/FieldVisitorConvertToNumber.h b/src/Common/FieldVisitorConvertToNumber.h
index ed73cd38cda3..df884d7eebf1 100644
--- a/src/Common/FieldVisitorConvertToNumber.h
+++ b/src/Common/FieldVisitorConvertToNumber.h
@@ -12,7 +12,6 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int CANNOT_CONVERT_TYPE;
-    extern const int NOT_IMPLEMENTED;
 }
 
 
@@ -53,7 +52,6 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>
 
     T operator() (const UInt64 & x) const { return T(x); }
     T operator() (const Int64 & x) const { return T(x); }
-    T operator() (const Int128 & x) const { return T(x); }
     T operator() (const UUID & x) const { return T(x.toUnderType()); }
     T operator() (const IPv4 & x) const { return T(x.toUnderType()); }
     T operator() (const IPv6 & x) const { return T(x.toUnderType()); }
@@ -87,11 +85,6 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>
         }
     }
 
-    T operator() (const UInt128 &) const
-    {
-        throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, "Cannot convert UInt128 to {}", demangle(typeid(T).name()));
-    }
-
     template <typename U>
     T operator() (const DecimalField<U> & x) const
     {
@@ -112,8 +105,6 @@ class FieldVisitorConvertToNumber : public StaticVisitor<T>
     {
         if constexpr (is_decimal<T>)
             return static_cast<T>(static_cast<typename T::NativeType>(x));
-        else if constexpr (std::is_same_v<T, UInt128>)
-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, "No conversion to old UInt128 from {}", demangle(typeid(U).name()));
         else
             return static_cast<T>(x);
     }
diff --git a/src/Common/FieldVisitorsAccurateComparison.h b/src/Common/FieldVisitorsAccurateComparison.h
index dfed2609040a..2809974efe50 100644
--- a/src/Common/FieldVisitorsAccurateComparison.h
+++ b/src/Common/FieldVisitorsAccurateComparison.h
@@ -45,20 +45,20 @@ class FieldVisitorAccurateEquals : public StaticVisitor<bool>
             if constexpr (std::is_same_v<T, U>)
                 return l == r;
 
-            if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)
+            if constexpr (is_arithmetic_v<T> && is_arithmetic_v<U>)
                 return accurate::equalsOp(l, r);
 
             /// TODO This is wrong (does not respect scale).
             if constexpr (is_decimal_field<T> && is_decimal_field<U>)
                 return l == r;
 
-            if constexpr (is_decimal_field<T> && std::is_arithmetic_v<U>)
+            if constexpr (is_decimal_field<T> && is_arithmetic_v<U>)
                 return l == DecimalField<Decimal256>(Decimal256(r), 0);
 
-            if constexpr (std::is_arithmetic_v<T> && is_decimal_field<U>)
+            if constexpr (is_arithmetic_v<T> && is_decimal_field<U>)
                 return DecimalField<Decimal256>(Decimal256(l), 0) == r;
 
-            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)
+            if constexpr (std::is_same_v<T, String> && is_arithmetic_v<U>)
             {
                 ReadBufferFromString in(l);
                 U parsed;
@@ -66,7 +66,7 @@ class FieldVisitorAccurateEquals : public StaticVisitor<bool>
                 return operator()(parsed, r);
             }
 
-            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)
+            if constexpr (std::is_same_v<U, String> && is_arithmetic_v<T>)
             {
                 ReadBufferFromString in(r);
                 T parsed;
@@ -112,20 +112,20 @@ class FieldVisitorAccurateLess : public StaticVisitor<bool>
             if constexpr (std::is_same_v<T, U>)
                 return l < r;
 
-            if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)
+            if constexpr (is_arithmetic_v<T> && is_arithmetic_v<U>)
                 return accurate::lessOp(l, r);
 
             /// TODO This is wrong (does not respect scale).
             if constexpr (is_decimal_field<T> && is_decimal_field<U>)
                 return l < r;
 
-            if constexpr (is_decimal_field<T> && std::is_arithmetic_v<U>)
+            if constexpr (is_decimal_field<T> && is_arithmetic_v<U>)
                 return l < DecimalField<Decimal256>(Decimal256(r), 0);
 
-            if constexpr (std::is_arithmetic_v<T> && is_decimal_field<U>)
+            if constexpr (is_arithmetic_v<T> && is_decimal_field<U>)
                 return DecimalField<Decimal256>(Decimal256(l), 0) < r;
 
-            if constexpr (std::is_same_v<T, String> && std::is_arithmetic_v<U>)
+            if constexpr (std::is_same_v<T, String> && is_arithmetic_v<U>)
             {
                 ReadBufferFromString in(l);
                 U parsed;
@@ -133,7 +133,7 @@ class FieldVisitorAccurateLess : public StaticVisitor<bool>
                 return operator()(parsed, r);
             }
 
-            if constexpr (std::is_same_v<U, String> && std::is_arithmetic_v<T>)
+            if constexpr (std::is_same_v<U, String> && is_arithmetic_v<T>)
             {
                 ReadBufferFromString in(r);
                 T parsed;
diff --git a/src/Interpreters/FillingRow.cpp b/src/Interpreters/FillingRow.cpp
index 561ac2553266..b03049a209f7 100644
--- a/src/Interpreters/FillingRow.cpp
+++ b/src/Interpreters/FillingRow.cpp
@@ -49,7 +49,7 @@ bool FillingRow::next(const FillingRow & to_row)
     size_t pos = 0;
 
     /// Find position we need to increment for generating next row.
-    for (; pos < size(); ++pos)
+    for (size_t s = size(); pos < s; ++pos)
         if (!row[pos].isNull() && !to_row.row[pos].isNull() && !equals(row[pos], to_row.row[pos]))
             break;
 
@@ -110,12 +110,16 @@ void FillingRow::initFromDefaults(size_t from_pos)
 void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & interpolate_columns, MutableColumns & other_columns,
     const FillingRow & filling_row, const Block & interpolate_block)
 {
-    for (size_t i = 0; i < filling_columns.size(); ++i)
+    for (size_t i = 0, size = filling_columns.size(); i < size; ++i)
     {
         if (filling_row[i].isNull())
+        {
             filling_columns[i]->insertDefault();
+        }
         else
+        {
             filling_columns[i]->insert(filling_row[i]);
+        }
     }
 
     if (size_t size = interpolate_block.columns())
@@ -134,7 +138,7 @@ void insertFromFillingRow(MutableColumns & filling_columns, MutableColumns & int
 
 void copyRowFromColumns(MutableColumns & dest, const Columns & source, size_t row_num)
 {
-    for (size_t i = 0; i < source.size(); ++i)
+    for (size_t i = 0, size = source.size(); i < size; ++i)
         dest[i]->insertFrom(*source[i], row_num);
 }
 
diff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp
index 2c5c550ffe22..bfee5ed8bf97 100644
--- a/src/Processors/Transforms/FillingTransform.cpp
+++ b/src/Processors/Transforms/FillingTransform.cpp
@@ -27,7 +27,7 @@ Block FillingTransform::transformHeader(Block header, const SortDescription & so
     /// Columns which are not from sorting key may not be constant anymore.
     for (auto & column : header)
         if (column.column && isColumnConst(*column.column) && !sort_keys.contains(column.name))
-            column.column = column.type->createColumn();
+            column.column = column.column->convertToFullColumnIfConst();
 
     return header;
 }
@@ -61,7 +61,7 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &
     {
         WhichDataType which_from(descr.fill_from_type);
         if ((which_from.isDateOrDate32() || which_from.isDateTime() || which_from.isDateTime64()) &&
-            !descr.fill_from_type->equals(*type))
+            !descr.fill_from_type->equals(*removeNullable(type)))
                 return false;
     }
 
@@ -73,8 +73,17 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &
                 return false;
     }
 
-    /// TODO Wrong results for big integers.
-    if (isInteger(type) || which.isDate() || which.isDate32() || which.isDateTime())
+    if (which.isInt128() || which.isUInt128())
+    {
+        max_type = Field::Types::Int128;
+        to_type = type;
+    }
+    else if (which.isInt256() || which.isUInt256())
+    {
+        max_type = Field::Types::Int256;
+        to_type = type;
+    }
+    else if (isInteger(type) || which.isDate() || which.isDate32() || which.isDateTime())
     {
         max_type = Field::Types::Int64;
         to_type = std::make_shared<DataTypeInt64>();
@@ -100,9 +109,12 @@ static bool tryConvertFields(FillColumnDescription & descr, const DataTypePtr &
         || descr.fill_step.getType() > max_type)
         return false;
 
-    descr.fill_from = convertFieldToType(descr.fill_from, *to_type);
-    descr.fill_to = convertFieldToType(descr.fill_to, *to_type);
-    descr.fill_step = convertFieldToType(descr.fill_step, *to_type);
+    if (!descr.fill_from.isNull())
+        descr.fill_from = convertFieldToTypeOrThrow(descr.fill_from, *to_type);
+    if (!descr.fill_to.isNull())
+        descr.fill_to = convertFieldToTypeOrThrow(descr.fill_to, *to_type);
+    if (!descr.fill_step.isNull())
+        descr.fill_step = convertFieldToTypeOrThrow(descr.fill_step, *to_type);
 
     if (descr.step_kind)
     {
@@ -184,18 +196,20 @@ FillingTransform::FillingTransform(
         fill_column_positions.push_back(block_position);
 
         auto & descr = filling_row.getFillDescription(i);
-        const auto & type = header_.getByPosition(block_position).type;
+
+        const Block & output_header = getOutputPort().getHeader();
+        const DataTypePtr & type = removeNullable(output_header.getByPosition(block_position).type);
 
         if (!tryConvertFields(descr, type))
             throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,
-                            "Incompatible types of WITH FILL expression values with column type {}", type->getName());
+                "Incompatible types of WITH FILL expression values with column type {}", type->getName());
 
-        if (type->isValueRepresentedByUnsignedInteger() &&
+        if (isUnsignedInteger(type) &&
             ((!descr.fill_from.isNull() && less(descr.fill_from, Field{0}, 1)) ||
              (!descr.fill_to.isNull() && less(descr.fill_to, Field{0}, 1))))
         {
             throw Exception(ErrorCodes::INVALID_WITH_FILL_EXPRESSION,
-                            "WITH FILL bound values cannot be negative for unsigned type {}", type->getName());
+                "WITH FILL bound values cannot be negative for unsigned type {}", type->getName());
         }
     }
 
@@ -213,7 +227,7 @@ FillingTransform::FillingTransform(
                     input_positions.emplace_back(idx, p->second);
 
         if (!is_fill_column[idx] && !(interpolate_description && interpolate_description->result_columns_set.contains(column.name)))
-                other_column_positions.push_back(idx);
+            other_column_positions.push_back(idx);
 
         ++idx;
     }
@@ -335,8 +349,8 @@ void FillingTransform::transform(Chunk & chunk)
         interpolate();
         while (filling_row.next(next_row))
         {
-                insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);
-                interpolate();
+            insertFromFillingRow(res_fill_columns, res_interpolate_columns, res_other_columns, filling_row, interpolate_block);
+            interpolate();
         }
 
         setResultColumns(chunk, res_fill_columns, res_interpolate_columns, res_other_columns);
@@ -352,7 +366,7 @@ void FillingTransform::transform(Chunk & chunk)
 
     if (first)
     {
-        for (size_t i = 0; i < filling_row.size(); ++i)
+        for (size_t i = 0, size = filling_row.size(); i < size; ++i)
         {
             auto current_value = (*old_fill_columns[i])[0];
             const auto & fill_from = filling_row.getFillDescription(i).fill_from;
diff --git a/src/Processors/Transforms/FillingTransform.h b/src/Processors/Transforms/FillingTransform.h
index 5e1068e18e23..7b41ab795d19 100644
--- a/src/Processors/Transforms/FillingTransform.h
+++ b/src/Processors/Transforms/FillingTransform.h
@@ -1,9 +1,11 @@
 #pragma once
+
 #include <Processors/ISimpleTransform.h>
 #include <Core/SortDescription.h>
 #include <Core/InterpolateDescription.h>
 #include <Interpreters/FillingRow.h>
 
+
 namespace DB
 {
 
