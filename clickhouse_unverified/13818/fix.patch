diff --git a/docs/en/sql-reference/aggregate-functions/reference/index.md b/docs/en/sql-reference/aggregate-functions/reference/index.md
index 675448a321b7..6e00ad8d9914 100644
--- a/docs/en/sql-reference/aggregate-functions/reference/index.md
+++ b/docs/en/sql-reference/aggregate-functions/reference/index.md
@@ -60,6 +60,8 @@ ClickHouse-specific aggregate functions:
 -   [quantile](../../../sql-reference/aggregate-functions/reference/quantile.md)
 -   [quantiles](../../../sql-reference/aggregate-functions/reference/quantiles.md)
 -   [quantileExact](../../../sql-reference/aggregate-functions/reference/quantileexact.md)
+-   [quantileExactLow](../../../sql-reference/aggregate-functions/reference/quantileexact.md#quantileexactlow)
+-   [quantileExactHigh](../../../sql-reference/aggregate-functions/reference/quantileexact.md#quantileexacthigh)
 -   [quantileExactWeighted](../../../sql-reference/aggregate-functions/reference/quantileexactweighted.md)
 -   [quantileTiming](../../../sql-reference/aggregate-functions/reference/quantiletiming.md)
 -   [quantileTimingWeighted](../../../sql-reference/aggregate-functions/reference/quantiletimingweighted.md)
diff --git a/docs/en/sql-reference/aggregate-functions/reference/quantileexact.md b/docs/en/sql-reference/aggregate-functions/reference/quantileexact.md
index 100d6ea129d4..40b25c14988e 100644
--- a/docs/en/sql-reference/aggregate-functions/reference/quantileexact.md
+++ b/docs/en/sql-reference/aggregate-functions/reference/quantileexact.md
@@ -49,6 +49,114 @@ Result:
 └───────────────────────┘
 ```
 
+# quantileExactLow {#quantileexactlow}
+
+Similar to `quantileExact`, this computes the exact [quantile](https://en.wikipedia.org/wiki/Quantile) of a numeric data sequence.
+
+To get exact value, all the passed values are combined into an array, which is then fully sorted.  The sorting [algorithm's](https://en.cppreference.com/w/cpp/algorithm/sort) complexity is `O(N·log(N))`, where `N = std::distance(first, last)` comparisons.
+
+Depending on the level, i.e if the level is 0.5 then the exact lower median value is returned if there are even number of elements and the middle value is returned if there are odd number of elements. Median is calculated similar to the [median_low](https://docs.python.org/3/library/statistics.html#statistics.median_low) implementation which is used in python.
+
+For all other levels, the element at the the index corresponding to the value of `level * size_of_array` is returned. For example:
+
+```$sql
+SELECT quantileExactLow(0.1)(number) FROM numbers(10)
+
+┌─quantileExactLow(0.1)(number)─┐
+│                             1 │
+└───────────────────────────────┘
+```
+                                                                                                                                                                                 
+When using multiple `quantile*` functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the [quantiles](../../../sql-reference/aggregate-functions/reference/quantiles.md#quantiles) function.
+
+**Syntax**
+
+``` sql
+quantileExact(level)(expr)
+```
+
+Alias: `medianExactLow`.
+
+**Parameters**
+
+-   `level` — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a `level` value in the range of `[0.01, 0.99]`. Default value: 0.5. At `level=0.5` the function calculates [median](https://en.wikipedia.org/wiki/Median).
+-   `expr` — Expression over the column values resulting in numeric [data types](../../../sql-reference/data-types/index.md#data_types), [Date](../../../sql-reference/data-types/date.md) or [DateTime](../../../sql-reference/data-types/datetime.md).
+
+**Returned value**
+
+-   Quantile of the specified level.
+
+Type:
+
+-   [Float64](../../../sql-reference/data-types/float.md) for numeric data type input.
+-   [Date](../../../sql-reference/data-types/date.md) if input values have the `Date` type.
+-   [DateTime](../../../sql-reference/data-types/datetime.md) if input values have the `DateTime` type.
+
+**Example**
+
+Query:
+
+``` sql
+SELECT quantileExactLow(number) FROM numbers(10)
+```
+
+Result:
+
+``` text
+┌─quantileExactLow(number)─┐
+│                        4 │
+└──────────────────────────┘
+```
+# quantileExactHigh {#quantileexacthigh}
+
+Similar to `quantileExact`, this computes the exact [quantile](https://en.wikipedia.org/wiki/Quantile) of a numeric data sequence.
+
+To get exact value, all the passed values are combined into an array, which is then fully sorted.  The sorting [algorithm's](https://en.cppreference.com/w/cpp/algorithm/sort) complexity is `O(N·log(N))`, where `N = std::distance(first, last)` comparisons.
+
+Depending on the level, i.e if the level is 0.5 then the exact higher median value is returned if there are even number of elements and the middle value is returned if there are odd number of elements. Median is calculated similar to the [median_high](https://docs.python.org/3/library/statistics.html#statistics.median_high) implementation which is used in python. For all other levels, the element at the the index corresponding to the value of `level * size_of_array` is returned. 
+
+This implementation behaves exactly similar to the current `quantileExact` implementation.
+
+When using multiple `quantile*` functions with different levels in a query, the internal states are not combined (that is, the query works less efficiently than it could). In this case, use the [quantiles](../../../sql-reference/aggregate-functions/reference/quantiles.md#quantiles) function.
+
+**Syntax**
+
+``` sql
+quantileExactHigh(level)(expr)
+```
+
+Alias: `medianExactHigh`.
+
+**Parameters**
+
+-   `level` — Level of quantile. Optional parameter. Constant floating-point number from 0 to 1. We recommend using a `level` value in the range of `[0.01, 0.99]`. Default value: 0.5. At `level=0.5` the function calculates [median](https://en.wikipedia.org/wiki/Median).
+-   `expr` — Expression over the column values resulting in numeric [data types](../../../sql-reference/data-types/index.md#data_types), [Date](../../../sql-reference/data-types/date.md) or [DateTime](../../../sql-reference/data-types/datetime.md).
+
+**Returned value**
+
+-   Quantile of the specified level.
+
+Type:
+
+-   [Float64](../../../sql-reference/data-types/float.md) for numeric data type input.
+-   [Date](../../../sql-reference/data-types/date.md) if input values have the `Date` type.
+-   [DateTime](../../../sql-reference/data-types/datetime.md) if input values have the `DateTime` type.
+
+**Example**
+
+Query:
+
+``` sql
+SELECT quantileExactHigh(number) FROM numbers(10)
+```
+
+Result:
+
+``` text
+┌─quantileExactHigh(number)─┐
+│                         5 │
+└───────────────────────────┘
+```
 **See Also**
 
 -   [median](../../../sql-reference/aggregate-functions/reference/median.md#median)
diff --git a/src/AggregateFunctions/AggregateFunctionQuantile.cpp b/src/AggregateFunctions/AggregateFunctionQuantile.cpp
index 4d50bd3f5315..52b82fbf733c 100644
--- a/src/AggregateFunctions/AggregateFunctionQuantile.cpp
+++ b/src/AggregateFunctions/AggregateFunctionQuantile.cpp
@@ -26,6 +26,11 @@ template <typename Value, bool float_return> using FuncQuantilesDeterministic =
 template <typename Value, bool _> using FuncQuantileExact = AggregateFunctionQuantile<Value, QuantileExact<Value>, NameQuantileExact, false, void, false>;
 template <typename Value, bool _> using FuncQuantilesExact = AggregateFunctionQuantile<Value, QuantileExact<Value>, NameQuantilesExact, false, void, true>;
 
+template <typename Value, bool _> using FuncQuantileExactLow = AggregateFunctionQuantile<Value, QuantileExactLow<Value>, NameQuantileExactLow, false, void, false>;
+template <typename Value, bool _> using FuncQuantilesExactLow = AggregateFunctionQuantile<Value, QuantileExactLow<Value>, NameQuantilesExactLow, false, void, true>;
+template <typename Value, bool _> using FuncQuantileExactHigh = AggregateFunctionQuantile<Value, QuantileExactHigh<Value>, NameQuantileExactHigh, false, void, false>;
+template <typename Value, bool _> using FuncQuantilesExactHigh = AggregateFunctionQuantile<Value, QuantileExactHigh<Value>, NameQuantilesExactHigh, false, void, true>;
+
 template <typename Value, bool _> using FuncQuantileExactExclusive = AggregateFunctionQuantile<Value, QuantileExactExclusive<Value>, NameQuantileExactExclusive, false, Float64, false>;
 template <typename Value, bool _> using FuncQuantilesExactExclusive = AggregateFunctionQuantile<Value, QuantileExactExclusive<Value>, NameQuantilesExactExclusive, false, Float64, true>;
 
@@ -54,7 +59,11 @@ static constexpr bool supportDecimal()
     return std::is_same_v<Function<Float32, false>, FuncQuantile<Float32, false>> ||
         std::is_same_v<Function<Float32, false>, FuncQuantiles<Float32, false>> ||
         std::is_same_v<Function<Float32, false>, FuncQuantileExact<Float32, false>> ||
+        std::is_same_v<Function<Float32, false>, FuncQuantileExactLow<Float32, false>> ||
+        std::is_same_v<Function<Float32, false>, FuncQuantileExactHigh<Float32, false>> ||
         std::is_same_v<Function<Float32, false>, FuncQuantilesExact<Float32, false>> ||
+        std::is_same_v<Function<Float32, false>, FuncQuantilesExactLow<Float32, false>> ||
+        std::is_same_v<Function<Float32, false>, FuncQuantilesExactHigh<Float32, false>> ||
         std::is_same_v<Function<Float32, false>, FuncQuantileExactWeighted<Float32, false>> ||
         std::is_same_v<Function<Float32, false>, FuncQuantilesExactWeighted<Float32, false>>;
 }
@@ -118,6 +127,12 @@ void registerAggregateFunctionsQuantile(AggregateFunctionFactory & factory)
     factory.registerFunction(NameQuantileExact::name, createAggregateFunctionQuantile<FuncQuantileExact>);
     factory.registerFunction(NameQuantilesExact::name, createAggregateFunctionQuantile<FuncQuantilesExact>);
 
+    factory.registerFunction(NameQuantileExactLow::name, createAggregateFunctionQuantile<FuncQuantileExactLow>);
+    factory.registerFunction(NameQuantilesExactLow::name, createAggregateFunctionQuantile<FuncQuantilesExactLow>);
+
+    factory.registerFunction(NameQuantileExactHigh::name, createAggregateFunctionQuantile<FuncQuantileExactHigh>);
+    factory.registerFunction(NameQuantilesExactHigh::name, createAggregateFunctionQuantile<FuncQuantilesExactHigh>);
+
     factory.registerFunction(NameQuantileExactExclusive::name, createAggregateFunctionQuantile<FuncQuantileExactExclusive>);
     factory.registerFunction(NameQuantilesExactExclusive::name, createAggregateFunctionQuantile<FuncQuantilesExactExclusive>);
 
@@ -143,6 +158,8 @@ void registerAggregateFunctionsQuantile(AggregateFunctionFactory & factory)
     factory.registerAlias("median", NameQuantile::name);
     factory.registerAlias("medianDeterministic", NameQuantileDeterministic::name);
     factory.registerAlias("medianExact", NameQuantileExact::name);
+    factory.registerAlias("medianExactLow", NameQuantileExactLow::name);
+    factory.registerAlias("medianExactHigh", NameQuantileExactHigh::name);
     factory.registerAlias("medianExactWeighted", NameQuantileExactWeighted::name);
     factory.registerAlias("medianTiming", NameQuantileTiming::name);
     factory.registerAlias("medianTimingWeighted", NameQuantileTimingWeighted::name);
diff --git a/src/AggregateFunctions/AggregateFunctionQuantile.h b/src/AggregateFunctions/AggregateFunctionQuantile.h
index 536d9d5683f2..9d2232892f08 100644
--- a/src/AggregateFunctions/AggregateFunctionQuantile.h
+++ b/src/AggregateFunctions/AggregateFunctionQuantile.h
@@ -201,6 +201,12 @@ struct NameQuantilesDeterministic { static constexpr auto name = "quantilesDeter
 struct NameQuantileExact { static constexpr auto name = "quantileExact"; };
 struct NameQuantilesExact { static constexpr auto name = "quantilesExact"; };
 
+struct NameQuantileExactLow { static constexpr auto name = "quantileExactLow"; };
+struct NameQuantilesExactLow { static constexpr auto name = "quantilesExactLow"; };
+
+struct NameQuantileExactHigh { static constexpr auto name = "quantileExactHigh"; };
+struct NameQuantilesExactHigh { static constexpr auto name = "quantilesExactHigh"; };
+
 struct NameQuantileExactExclusive { static constexpr auto name = "quantileExactExclusive"; };
 struct NameQuantilesExactExclusive { static constexpr auto name = "quantilesExactExclusive"; };
 
diff --git a/src/AggregateFunctions/QuantileExact.h b/src/AggregateFunctions/QuantileExact.h
index efe3a8f73ea8..da0f644721bb 100644
--- a/src/AggregateFunctions/QuantileExact.h
+++ b/src/AggregateFunctions/QuantileExact.h
@@ -1,30 +1,25 @@
 #pragma once
 
-#include <Common/PODArray.h>
-#include <Common/NaNUtils.h>
+#include <algorithm>
 #include <Core/Types.h>
-#include <IO/WriteBuffer.h>
 #include <IO/ReadBuffer.h>
 #include <IO/VarInt.h>
+#include <IO/WriteBuffer.h>
+#include <Common/NaNUtils.h>
+#include <Common/PODArray.h>
 
 
 namespace DB
 {
-
 namespace ErrorCodes
 {
     extern const int NOT_IMPLEMENTED;
     extern const int BAD_ARGUMENTS;
 }
 
-/** Calculates quantile by collecting all values into array
-  *  and applying n-th element (introselect) algorithm for the resulting array.
-  *
-  * It uses O(N) memory and it is very inefficient in case of high amount of identical values.
-  * But it is very CPU efficient for not large datasets.
-  */
-template <typename Value>
-struct QuantileExact
+
+template <typename Value, typename Derived>
+struct QuantileExactBase
 {
     /// The memory will be allocated to several elements at once, so that the state occupies 64 bytes.
     static constexpr size_t bytes_in_arena = 64 - sizeof(PODArray<Value>);
@@ -44,10 +39,7 @@ struct QuantileExact
         throw Exception("Method add with weight is not implemented for QuantileExact", ErrorCodes::NOT_IMPLEMENTED);
     }
 
-    void merge(const QuantileExact & rhs)
-    {
-        array.insert(rhs.array.begin(), rhs.array.end());
-    }
+    void merge(const QuantileExactBase & rhs) { array.insert(rhs.array.begin(), rhs.array.end()); }
 
     void serialize(WriteBuffer & buf) const
     {
@@ -64,16 +56,38 @@ struct QuantileExact
         buf.read(reinterpret_cast<char *>(array.data()), size * sizeof(array[0]));
     }
 
-    /// Get the value of the `level` quantile. The level must be between 0 and 1.
     Value get(Float64 level)
+    {
+        auto derived = static_cast<Derived*>(this);
+        return derived->getImpl(level);
+    }
+
+    void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result)
+    {
+        auto derived = static_cast<Derived*>(this);
+        return derived->getManyImpl(levels, indices, size, result);
+    }
+};
+
+/** Calculates quantile by collecting all values into array
+  *  and applying n-th element (introselect) algorithm for the resulting array.
+  *
+  * It uses O(N) memory and it is very inefficient in case of high amount of identical values.
+  * But it is very CPU efficient for not large datasets.
+  */
+template <typename Value>
+struct QuantileExact : QuantileExactBase<Value, QuantileExact<Value>>
+{
+    using QuantileExactBase<Value, QuantileExact<Value>>::array;
+
+    // Get the value of the `level` quantile. The level must be between 0 and 1.
+    Value getImpl(Float64 level)
     {
         if (!array.empty())
         {
-            size_t n = level < 1
-                ? level * array.size()
-                : (array.size() - 1);
+            size_t n = level < 1 ? level * array.size() : (array.size() - 1);
 
-            std::nth_element(array.begin(), array.begin() + n, array.end());    /// NOTE You can think of the radix-select algorithm.
+            std::nth_element(array.begin(), array.begin() + n, array.end()); /// NOTE You can think of the radix-select algorithm.
             return array[n];
         }
 
@@ -82,7 +96,7 @@ struct QuantileExact
 
     /// Get the `size` values of `levels` quantiles. Write `size` results starting with `result` address.
     /// indices - an array of index levels such that the corresponding elements will go in ascending order.
-    void getMany(const Float64 * levels, const size_t * indices, size_t size, Value * result)
+    void getManyImpl(const Float64 * levels, const size_t * indices, size_t size, Value * result)
     {
         if (!array.empty())
         {
@@ -91,9 +105,7 @@ struct QuantileExact
             {
                 auto level = levels[indices[i]];
 
-                size_t n = level < 1
-                    ? level * array.size()
-                    : (array.size() - 1);
+                size_t n = level < 1 ? level * array.size() : (array.size() - 1);
 
                 std::nth_element(array.begin() + prev_n, array.begin() + n, array.end());
 
@@ -111,6 +123,7 @@ struct QuantileExact
 
 /// QuantileExactExclusive is equivalent to Excel PERCENTILE.EXC, R-6, SAS-4, SciPy-(0,0)
 template <typename Value>
+/// There is no virtual-like functions. So we don't inherit from QuantileExactBase.
 struct QuantileExactExclusive : public QuantileExact<Value>
 {
     using QuantileExact<Value>::array;
@@ -178,6 +191,7 @@ struct QuantileExactExclusive : public QuantileExact<Value>
 
 /// QuantileExactInclusive is equivalent to Excel PERCENTILE and PERCENTILE.INC, R-7, SciPy-(1,1)
 template <typename Value>
+/// There is no virtual-like functions. So we don't inherit from QuantileExactBase.
 struct QuantileExactInclusive : public QuantileExact<Value>
 {
     using QuantileExact<Value>::array;
@@ -238,4 +252,137 @@ struct QuantileExactInclusive : public QuantileExact<Value>
     }
 };
 
+// QuantileExactLow returns the low median of given data.
+// Implementation is as per "medium_low" function from python:
+// https://docs.python.org/3/library/statistics.html#statistics.median_low
+template <typename Value>
+struct QuantileExactLow : public QuantileExactBase<Value, QuantileExactLow<Value>>
+{
+    using QuantileExactBase<Value, QuantileExactLow<Value>>::array;
+
+    Value getImpl(Float64 level)
+    {
+        if (!array.empty())
+        {
+            // sort inputs in ascending order
+            std::sort(array.begin(), array.end());
+            size_t n = level < 1 ? level * array.size() : (array.size() - 1);
+            // if level is 0.5 then compute the "low" median of the sorted array
+            // by the method of rounding.
+            if (level == 0.5)
+            {
+                auto s = array.size();
+                if (s % 2 == 1)
+                {
+                    return array[static_cast<size_t>(floor(s / 2))];
+                }
+                else
+                {
+                    return array[static_cast<size_t>((floor(s / 2)) - 1)];
+                }
+            }
+            // else quantile is the nth index of the sorted array obtained by multiplying
+            // level and size of array. Example if level = 0.1 and size of array is 10,
+            // then return array[1].
+            return array[n];
+        }
+        return std::numeric_limits<Value>::quiet_NaN();
+    }
+
+    void getManyImpl(const Float64 * levels, const size_t * indices, size_t size, Value * result)
+    {
+        if (!array.empty())
+        {
+            // sort inputs in ascending order
+            std::sort(array.begin(), array.end());
+            for (size_t i = 0; i < size; ++i)
+            {
+                auto level = levels[indices[i]];
+                size_t n = level < 1 ? level * array.size() : (array.size() - 1);
+                // if level is 0.5 then compute the "low" median of the sorted array
+                // by the method of rounding.
+                if (level == 0.5)
+                {
+                    auto s = array.size();
+                    if (s % 2 == 1)
+                    {
+                        result[indices[i]] = array[static_cast<size_t>(floor(s / 2))];
+                    }
+                    else
+                    {
+                        result[indices[i]] = array[static_cast<size_t>(floor((s / 2) - 1))];
+                    }
+                }
+                // else quantile is the nth index of the sorted array obtained by multiplying
+                // level and size of array. Example if level = 0.1 and size of array is 10.
+                result[indices[i]] = array[n];
+            }
+        }
+        else
+        {
+            for (size_t i = 0; i < size; ++i)
+                result[i] = Value();
+        }
+    }
+};
+
+// QuantileExactLow returns the high median of given data.
+// Implementation is as per "medium_high function from python:
+// https://docs.python.org/3/library/statistics.html#statistics.median_high
+template <typename Value>
+struct QuantileExactHigh : public QuantileExactBase<Value, QuantileExactHigh<Value>>
+{
+    using QuantileExactBase<Value, QuantileExactHigh<Value>>::array;
+
+    Value getImpl(Float64 level)
+    {
+        if (!array.empty())
+        {
+            // sort inputs in ascending order
+            std::sort(array.begin(), array.end());
+            size_t n = level < 1 ? level * array.size() : (array.size() - 1);
+            // if level is 0.5 then compute the "high" median of the sorted array
+            // by the method of rounding.
+            if (level == 0.5)
+            {
+                auto s = array.size();
+                return array[static_cast<size_t>(floor(s / 2))];
+            }
+            // else quantile is the nth index of the sorted array obtained by multiplying
+            // level and size of array. Example if level = 0.1 and size of array is 10.
+            return array[n];
+        }
+        return std::numeric_limits<Value>::quiet_NaN();
+    }
+
+    void getManyImpl(const Float64 * levels, const size_t * indices, size_t size, Value * result)
+    {
+        if (!array.empty())
+        {
+            // sort inputs in ascending order
+            std::sort(array.begin(), array.end());
+            for (size_t i = 0; i < size; ++i)
+            {
+                auto level = levels[indices[i]];
+                size_t n = level < 1 ? level * array.size() : (array.size() - 1);
+                // if level is 0.5 then compute the "high" median of the sorted array
+                // by the method of rounding.
+                if (level == 0.5)
+                {
+                    auto s = array.size();
+                    result[indices[i]] = array[static_cast<size_t>(floor(s / 2))];
+                }
+                // else quantile is the nth index of the sorted array obtained by multiplying
+                // level and size of array. Example if level = 0.1 and size of array is 10.
+                result[indices[i]] = array[n];
+            }
+        }
+        else
+        {
+            for (size_t i = 0; i < size; ++i)
+                result[i] = Value();
+        }
+    }
+};
+
 }
