{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 43733,
  "instance_id": "ClickHouse__ClickHouse-43733",
  "issue_numbers": [
    "43333"
  ],
  "base_commit": "6487acf9c018aff5ad4bb5c028d694e59c38adb9",
  "patch": "diff --git a/src/Functions/array/range.cpp b/src/Functions/array/range.cpp\nindex 3b5bb686e60a..aacf3103df9a 100644\n--- a/src/Functions/array/range.cpp\n+++ b/src/Functions/array/range.cpp\n@@ -9,6 +9,7 @@\n #include <Interpreters/castColumn.h>\n #include <Interpreters/Context.h>\n #include <numeric>\n+#include <vector>\n \n \n namespace DB\n@@ -56,7 +57,7 @@ class FunctionRange : public IFunction\n \n         for (const auto & arg : arguments)\n         {\n-            if (!isUnsignedInteger(arg))\n+            if (!isInteger(arg))\n                 throw Exception{\"Illegal type \" + arg->getName() + \" of argument of function \" + getName(),\n                     ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n         }\n@@ -72,8 +73,12 @@ class FunctionRange : public IFunction\n         {\n             const auto & in_data = in->getData();\n             const auto total_values = std::accumulate(std::begin(in_data), std::end(in_data), size_t{},\n-                [this] (const size_t lhs, const size_t rhs)\n+                [this] (const size_t lhs, const T rhs)\n                 {\n+                    if (rhs < 0)\n+                        throw Exception{\"A call to function \" + getName() + \" overflows, only support positive values when only end is provided\",\n+                            ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+\n                     const auto sum = lhs + rhs;\n                     if (sum < lhs)\n                         throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n@@ -96,7 +101,7 @@ class FunctionRange : public IFunction\n             IColumn::Offset offset{};\n             for (size_t row_idx = 0, rows = in->size(); row_idx < rows; ++row_idx)\n             {\n-                for (size_t elem_idx = 0, elems = in_data[row_idx]; elem_idx < elems; ++elem_idx)\n+                for (T elem_idx = 0, elems = in_data[row_idx]; elem_idx < elems; ++elem_idx)\n                     out_data[offset + elem_idx] = static_cast<T>(elem_idx);\n \n                 offset += in_data[row_idx];\n@@ -121,15 +126,20 @@ class FunctionRange : public IFunction\n \n         size_t total_values = 0;\n         size_t pre_values = 0;\n+        std::vector<size_t> row_length(input_rows_count);\n \n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            if (start < end_data[row_idx] && step == 0)\n+            if (step == 0)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, the 3rd argument step can't be zero\",\n                             ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n \n-            pre_values += start >= end_data[row_idx] ? 0\n-                            : (end_data[row_idx] - start - 1) / step + 1;\n+            if (start < end_data[row_idx] && step > 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_data[row_idx]) - static_cast<__int128_t>(start) - 1) / static_cast<__int128_t>(step) + 1;\n+            else if (start > end_data[row_idx] && step < 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_data[row_idx]) - static_cast<__int128_t>(start) + 1) / static_cast<__int128_t>(step) + 1;\n+\n+            pre_values += row_length[row_idx];\n \n             if (pre_values < total_values)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n@@ -151,15 +161,8 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t st = start, ed = end_data[row_idx]; st < ed; st += step)\n-            {\n-                out_data[offset++] = static_cast<T>(st);\n-\n-                if (st > st + step)\n-                    throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n-                                ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n-            }\n-\n+            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n+                out_data[offset++] = static_cast<T>(start + offset * step);\n             out_offsets[row_idx] = offset;\n         }\n \n@@ -180,19 +183,25 @@ class FunctionRange : public IFunction\n \n         size_t total_values = 0;\n         size_t pre_values = 0;\n+        std::vector<size_t> row_length(input_rows_count);\n \n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            if (start_data[row_idx] < end_data[row_idx] && step == 0)\n+            if (step == 0)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, the 3rd argument step can't be zero\",\n                             ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n \n-            pre_values += start_data[row_idx] >= end_data[row_idx] ? 0\n-                            : (end_data[row_idx] - start_data[row_idx] - 1) / step + 1;\n+            if (start_data[row_idx] < end_data[row_idx] && step > 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_data[row_idx]) - static_cast<__int128_t>(start_data[row_idx]) - 1) / static_cast<__int128_t>(step) + 1;\n+            else if (start_data[row_idx] > end_data[row_idx] && step < 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_data[row_idx]) - static_cast<__int128_t>(start_data[row_idx]) + 1) / static_cast<__int128_t>(step) + 1;\n+\n+\n+            pre_values += row_length[row_idx];\n \n             if (pre_values < total_values)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n-                            ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+                    ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n \n             total_values = pre_values;\n             if (total_values > max_elements)\n@@ -210,15 +219,8 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t st = start_data[row_idx], ed = end_data[row_idx]; st < ed; st += step)\n-            {\n-                out_data[offset++] = static_cast<T>(st);\n-\n-                if (st > st + step)\n-                    throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n-                                ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n-            }\n-\n+            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n+                out_data[offset++] = static_cast<T>(start_data[row_idx] + idx * step);\n             out_offsets[row_idx] = offset;\n         }\n \n@@ -239,15 +241,20 @@ class FunctionRange : public IFunction\n \n         size_t total_values = 0;\n         size_t pre_values = 0;\n+        std::vector<size_t> row_length(input_rows_count);\n \n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            if (start < end_data[row_idx] && step_data[row_idx] == 0)\n+            if (step_data[row_idx] == 0)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, the 3rd argument step can't be zero\",\n-                            ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+                    ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+\n+            if (start < end_data[row_idx] && step_data[row_idx] > 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_data[row_idx]) - static_cast<__int128_t>(start) - 1) / static_cast<__int128_t>(step_data[row_idx]) + 1;\n+            else if (start > end_data[row_idx] && step_data[row_idx] < 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_data[row_idx]) - static_cast<__int128_t>(start) + 1) / static_cast<__int128_t>(step_data[row_idx]) + 1;\n \n-            pre_values += start >= end_data[row_idx] ? 0\n-                            : (end_data[row_idx] - start - 1) / step_data[row_idx] + 1;\n+            pre_values += row_length[row_idx];\n \n             if (pre_values < total_values)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n@@ -269,15 +276,8 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t st = start, ed = end_data[row_idx]; st < ed; st += step_data[row_idx])\n-            {\n-                out_data[offset++] = static_cast<T>(st);\n-\n-                if (st > st + step_data[row_idx])\n-                    throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n-                                ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n-            }\n-\n+            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n+                out_data[offset++] = static_cast<T>(start + offset * step_data[row_idx]);\n             out_offsets[row_idx] = offset;\n         }\n \n@@ -301,15 +301,19 @@ class FunctionRange : public IFunction\n \n         size_t total_values = 0;\n         size_t pre_values = 0;\n+        std::vector<size_t> row_length(input_rows_count);\n \n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            if (start_data[row_idx] < end_start[row_idx] && step_data[row_idx] == 0)\n-                throw Exception{\"A call to function \" + getName() + \" overflows, the 3rd argument step can't be zero\",\n+            if (step_data[row_idx] == 0)\n+                throw Exception{\"A call to function \" + getName() + \" overflows, the 3rd argument step can't less or equal to zero\",\n                             ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n+            if (start_data[row_idx] < end_start[row_idx] && step_data[row_idx] > 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_start[row_idx]) - static_cast<__int128_t>(start_data[row_idx]) - 1) / static_cast<__int128_t>(step_data[row_idx]) + 1;\n+            else if (start_data[row_idx] > end_start[row_idx] && step_data[row_idx] < 0)\n+                row_length[row_idx] = (static_cast<__int128_t>(end_start[row_idx]) - static_cast<__int128_t>(start_data[row_idx]) + 1) / static_cast<__int128_t>(step_data[row_idx]) + 1;\n \n-            pre_values += start_data[row_idx] >= end_start[row_idx] ? 0\n-                            : (end_start[row_idx] -start_data[row_idx] - 1) / (step_data[row_idx]) + 1;\n+            pre_values += row_length[row_idx];\n \n             if (pre_values < total_values)\n                 throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n@@ -331,15 +335,8 @@ class FunctionRange : public IFunction\n         IColumn::Offset offset{};\n         for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            for (size_t st = start_data[row_idx], ed = end_start[row_idx]; st < ed; st += step_data[row_idx])\n-            {\n-                out_data[offset++] = static_cast<T>(st);\n-\n-                if (st > st + step_data[row_idx])\n-                    throw Exception{\"A call to function \" + getName() + \" overflows, investigate the values of arguments you are passing\",\n-                                ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n-            }\n-\n+            for (size_t idx = 0; idx < row_length[row_idx]; idx++)\n+                out_data[offset++] = static_cast<T>(start_data[row_idx] + idx * step_data[row_idx]);\n             out_offsets[row_idx] = offset;\n         }\n \n@@ -351,23 +348,20 @@ class FunctionRange : public IFunction\n         DataTypePtr elem_type = checkAndGetDataType<DataTypeArray>(result_type.get())->getNestedType();\n         WhichDataType which(elem_type);\n \n-        if (!which.isUInt8()\n-            && !which.isUInt16()\n-            && !which.isUInt32()\n-            && !which.isUInt64())\n+        if (!which.isNativeUInt() && !which.isNativeInt())\n         {\n             throw Exception{\"Illegal columns of arguments of function \" + getName()\n-                + \", the function only implemented for unsigned integers up to 64 bit\", ErrorCodes::ILLEGAL_COLUMN};\n+                            + \", the function only implemented for unsigned/signed integers up to 64 bit\",\n+                            ErrorCodes::ILLEGAL_COLUMN};\n         }\n \n         ColumnPtr res;\n         if (arguments.size() == 1)\n         {\n             const auto * col = arguments[0].column.get();\n-            if (!((res = executeInternal<UInt8>(col))\n-                || (res = executeInternal<UInt16>(col))\n-                || (res = executeInternal<UInt32>(col))\n-                || (res = executeInternal<UInt64>(col))))\n+            if (!((res = executeInternal<UInt8>(col)) || (res = executeInternal<UInt16>(col)) || (res = executeInternal<UInt32>(col))\n+                  || (res = executeInternal<UInt64>(col)) || (res = executeInternal<Int8>(col)) || (res = executeInternal<Int16>(col))\n+                  || (res = executeInternal<Int32>(col)) || (res = executeInternal<Int64>(col))))\n             {\n                 throw Exception{\"Illegal column \" + col->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n             }\n@@ -402,44 +396,93 @@ class FunctionRange : public IFunction\n         bool is_step_const = isColumnConst(*column_ptrs[2]);\n         if (is_start_const && is_step_const)\n         {\n-            UInt64 start = assert_cast<const ColumnConst &>(*column_ptrs[0]).getUInt(0);\n-            UInt64 step = assert_cast<const ColumnConst &>(*column_ptrs[2]).getUInt(0);\n-\n-            if ((res = executeConstStartStep<UInt8>(column_ptrs[1], start, step, input_rows_count)) ||\n-                (res = executeConstStartStep<UInt16>(column_ptrs[1], start, step, input_rows_count)) ||\n-                (res = executeConstStartStep<UInt32>(column_ptrs[1], static_cast<UInt32>(start), static_cast<UInt32>(step), input_rows_count)) ||\n-                (res = executeConstStartStep<UInt64>(column_ptrs[1], start, step, input_rows_count)))\n+            if (which.isNativeUInt())\n             {\n+                UInt64 start = assert_cast<const ColumnConst &>(*column_ptrs[0]).getUInt(0);\n+                UInt64 step = assert_cast<const ColumnConst &>(*column_ptrs[2]).getUInt(0);\n+\n+                if ((res = executeConstStartStep<UInt8>(column_ptrs[1], start, step, input_rows_count))\n+                    || (res = executeConstStartStep<UInt16>(column_ptrs[1], start, step, input_rows_count))\n+                    || (res = executeConstStartStep<UInt32>(\n+                            column_ptrs[1], static_cast<UInt32>(start), static_cast<UInt32>(step), input_rows_count))\n+                    || (res = executeConstStartStep<UInt64>(column_ptrs[1], start, step, input_rows_count)))\n+                {\n+                }\n+            }\n+            else if (which.isNativeInt())\n+            {\n+                Int64 start = assert_cast<const ColumnConst &>(*column_ptrs[0]).getInt(0);\n+                Int64 step = assert_cast<const ColumnConst &>(*column_ptrs[2]).getInt(0);\n+\n+                if ((res = executeConstStartStep<Int8>(column_ptrs[1], start, step, input_rows_count))\n+                    || (res = executeConstStartStep<Int16>(column_ptrs[1], start, step, input_rows_count))\n+                    || (res = executeConstStartStep<Int32>(\n+                            column_ptrs[1], static_cast<Int32>(start), static_cast<Int32>(step), input_rows_count))\n+                    || (res = executeConstStartStep<Int64>(column_ptrs[1], start, step, input_rows_count)))\n+                {\n+                }\n             }\n         }\n         else if (is_start_const && !is_step_const)\n         {\n-            UInt64 start = assert_cast<const ColumnConst &>(*column_ptrs[0]).getUInt(0);\n+            if (which.isNativeUInt())\n+            {\n+                UInt64 start = assert_cast<const ColumnConst &>(*column_ptrs[0]).getUInt(0);\n \n-            if ((res = executeConstStart<UInt8>(column_ptrs[1], column_ptrs[2], start, input_rows_count)) ||\n-                (res = executeConstStart<UInt16>(column_ptrs[1], column_ptrs[2], start, input_rows_count)) ||\n-                (res = executeConstStart<UInt32>(column_ptrs[1], column_ptrs[2], static_cast<UInt32>(start), input_rows_count)) ||\n-                (res = executeConstStart<UInt64>(column_ptrs[1], column_ptrs[2], start, input_rows_count)))\n+                if ((res = executeConstStart<UInt8>(column_ptrs[1], column_ptrs[2], start, input_rows_count))\n+                    || (res = executeConstStart<UInt16>(column_ptrs[1], column_ptrs[2], start, input_rows_count))\n+                    || (res = executeConstStart<UInt32>(column_ptrs[1], column_ptrs[2], static_cast<UInt32>(start), input_rows_count))\n+                    || (res = executeConstStart<UInt64>(column_ptrs[1], column_ptrs[2], start, input_rows_count)))\n+                {\n+                }\n+            }\n+            else if (which.isNativeInt())\n             {\n+                Int64 start = assert_cast<const ColumnConst &>(*column_ptrs[0]).getInt(0);\n+\n+                if ((res = executeConstStart<Int8>(column_ptrs[1], column_ptrs[2], start, input_rows_count))\n+                    || (res = executeConstStart<Int16>(column_ptrs[1], column_ptrs[2], start, input_rows_count))\n+                    || (res = executeConstStart<Int32>(column_ptrs[1], column_ptrs[2], static_cast<Int32>(start), input_rows_count))\n+                    || (res = executeConstStart<Int64>(column_ptrs[1], column_ptrs[2], start, input_rows_count)))\n+                {\n+                }\n             }\n         }\n         else if (!is_start_const && is_step_const)\n         {\n-            UInt64 step = assert_cast<const ColumnConst &>(*column_ptrs[2]).getUInt(0);\n+            if (which.isNativeUInt())\n+            {\n+                UInt64 step = assert_cast<const ColumnConst &>(*column_ptrs[2]).getUInt(0);\n \n-            if ((res = executeConstStep<UInt8>(column_ptrs[0], column_ptrs[1], step, input_rows_count)) ||\n-                (res = executeConstStep<UInt16>(column_ptrs[0], column_ptrs[1], step, input_rows_count)) ||\n-                (res = executeConstStep<UInt32>(column_ptrs[0], column_ptrs[1], static_cast<UInt32>(step), input_rows_count)) ||\n-                (res = executeConstStep<UInt64>(column_ptrs[0], column_ptrs[1], step, input_rows_count)))\n+                if ((res = executeConstStep<UInt8>(column_ptrs[0], column_ptrs[1], step, input_rows_count))\n+                    || (res = executeConstStep<UInt16>(column_ptrs[0], column_ptrs[1], step, input_rows_count))\n+                    || (res = executeConstStep<UInt32>(column_ptrs[0], column_ptrs[1], static_cast<UInt32>(step), input_rows_count))\n+                    || (res = executeConstStep<UInt64>(column_ptrs[0], column_ptrs[1], step, input_rows_count)))\n+                {\n+                }\n+            }\n+            else if (which.isNativeInt())\n             {\n+                Int64 step = assert_cast<const ColumnConst &>(*column_ptrs[2]).getInt(0);\n+\n+                if ((res = executeConstStep<Int8>(column_ptrs[0], column_ptrs[1], step, input_rows_count))\n+                    || (res = executeConstStep<Int16>(column_ptrs[0], column_ptrs[1], step, input_rows_count))\n+                    || (res = executeConstStep<Int32>(column_ptrs[0], column_ptrs[1], static_cast<Int32>(step), input_rows_count))\n+                    || (res = executeConstStep<Int64>(column_ptrs[0], column_ptrs[1], step, input_rows_count)))\n+                {\n+                }\n             }\n         }\n         else\n         {\n-            if ((res = executeGeneric<UInt8>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count)) ||\n-                (res = executeGeneric<UInt16>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count)) ||\n-                (res = executeGeneric<UInt32>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count)) ||\n-                (res = executeGeneric<UInt64>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count)))\n+            if ((res = executeGeneric<UInt8>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<UInt16>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<UInt32>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<UInt64>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<Int8>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<Int16>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<Int32>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count))\n+                || (res = executeGeneric<Int64>(column_ptrs[0], column_ptrs[1], column_ptrs[2], input_rows_count)))\n             {\n             }\n         }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01408_range_overflow.reference b/tests/queries/0_stateless/01408_range_overflow.reference\nindex e69de29bb2d1..4f31f0710eeb 100644\n--- a/tests/queries/0_stateless/01408_range_overflow.reference\n+++ b/tests/queries/0_stateless/01408_range_overflow.reference\n@@ -0,0 +1,5 @@\n+[1025,9223372036854776832]\n+[1025,9223372036854776832]\n+[1025,9223372036854776832]\n+[1025,9223372036854776832]\n+[1025,9223372036854776832]\ndiff --git a/tests/queries/0_stateless/01408_range_overflow.sql b/tests/queries/0_stateless/01408_range_overflow.sql\nindex 1640798999c0..2107e8c3f36d 100644\n--- a/tests/queries/0_stateless/01408_range_overflow.sql\n+++ b/tests/queries/0_stateless/01408_range_overflow.sql\n@@ -1,12 +1,13 @@\n -- executeGeneric()\n-SELECT range(1025, 1048576 + 9223372036854775807, 9223372036854775807); -- { serverError 69; }\n-SELECT range(1025, 1048576 + (9223372036854775807 AS i), i); -- { serverError 69; }\n+SELECT range(1025, 1048576 + 9223372036854775807, 9223372036854775807);\n+SELECT range(1025, 1048576 + (9223372036854775807 AS i), i);\n+SELECT range(1025, 18446744073709551615, 1); -- { serverError 69; }\n \n -- executeConstStep()\n-SELECT range(number, 1048576 + 9223372036854775807, 9223372036854775807) FROM system.numbers LIMIT 1 OFFSET 1025; -- { serverError 69; }\n+SELECT range(number, 1048576 + 9223372036854775807, 9223372036854775807) FROM system.numbers LIMIT 1 OFFSET 1025;\n \n -- executeConstStartStep()\n-SELECT range(1025, number + 9223372036854775807, 9223372036854775807) FROM system.numbers LIMIT 1 OFFSET 1048576; -- { serverError 69; }\n+SELECT range(1025, number + 9223372036854775807, 9223372036854775807) FROM system.numbers LIMIT 1 OFFSET 1048576;\n \n -- executeConstStart()\n-SELECT range(1025, 1048576 + 9223372036854775807, number + 9223372036854775807) FROM system.numbers LIMIT 1; -- { serverError 69; }\n+SELECT range(1025, 1048576 + 9223372036854775807, number + 9223372036854775807) FROM system.numbers LIMIT 1;\ndiff --git a/tests/queries/0_stateless/02494_array_function_range.reference b/tests/queries/0_stateless/02494_array_function_range.reference\nnew file mode 100644\nindex 000000000000..133d78d4a373\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_array_function_range.reference\n@@ -0,0 +1,19 @@\n+1\n+1\n+1\n+[-1,0]\n+[-1]\n+[]\n+[5,4,3,2,1]\n+[5,4,3,2,1,0]\n+[1]\n+[-5,-4,-3,-2,-1,0,1,2,3,4]\n+[-4,-3,-2,-1,0,1,2,3,4,5]\n+[-3,-2,-1,0,1,2,3,4,5,6]\n+[-2,-1,0,1,2,3,4,5,6,7]\n+[-1,0,1,2,3,4,5,6,7,8]\n+[0,1,2,3,4,5,6,7,8,9]\n+[1,2,3,4,5,6,7,8,9,10]\n+[2,3,4,5,6,7,8,9,10,11]\n+[3,4,5,6,7,8,9,10,11,12]\n+[4,5,6,7,8,9,10,11,12,13]\ndiff --git a/tests/queries/0_stateless/02494_array_function_range.sql b/tests/queries/0_stateless/02494_array_function_range.sql\nnew file mode 100644\nindex 000000000000..bd945d552548\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_array_function_range.sql\n@@ -0,0 +1,10 @@\n+SELECT range(100) == range(0, 100) and range(0, 100) == range(0, 100, 1);\n+SELECT range(100) == range(cast('100', 'Int8')) and range(100) == range(cast('100', 'Int16')) and range(100) == range(cast('100', 'Int32')) and range(100) == range(cast('100', 'Int64'));\n+SELECT range(cast('100', 'Int8')) == range(0, cast('100', 'Int8')) and  range(0, cast('100', 'Int8')) == range(0, cast('100', 'Int8'), 1) and range(0, cast('100', 'Int8')) == range(0, cast('100', 'Int8'), cast('1', 'Int8'));\n+SELECT range(-1, 1);\n+SELECT range(-1, 1, 2);\n+SELECT range(1,1);\n+SELECT range(5, 0, -1);\n+SELECT range(5, -1, -1);\n+SELECT range(1, 257, 65535);\n+SELECT range(cast(number - 5, 'Int8'), cast(number + 5, 'Int8')) from system.numbers limit 10;\n\\ No newline at end of file\n",
  "problem_statement": "Add support for signed arguments in range() \n**Describe the issue**\r\nAllow to call `range()` with Int* data types.\r\nValidate that arguments are positive.\r\n\r\n**How to reproduce**\r\n```\r\nSELECT range(CAST('1', 'Int8'), CAST('10', 'Int8'))\r\n\r\nQuery id: 8710056b-08d9-454d-bb6a-e858b61dc9a3\r\n\r\n\r\n0 rows in set. Elapsed: 0.081 sec.\r\n\r\nReceived exception from server (version 22.11.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Illegal type Int8 of argument of function range: In scope SELECT range(CAST('1', 'Int8'), CAST('10', 'Int8')). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\n",
  "hints_text": "For Date data type also makes sense\nMay I have a try? ",
  "created_at": "2022-11-27T12:50:09Z",
  "modified_files": [
    "src/Functions/array/range.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01408_range_overflow.reference",
    "tests/queries/0_stateless/01408_range_overflow.sql",
    "b/tests/queries/0_stateless/02494_array_function_range.reference",
    "b/tests/queries/0_stateless/02494_array_function_range.sql"
  ]
}