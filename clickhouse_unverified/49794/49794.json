{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49794,
  "instance_id": "ClickHouse__ClickHouse-49794",
  "issue_numbers": [
    "34155"
  ],
  "base_commit": "b38d4b5b0fb6956242e9a870ea5d6275210f3a22",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 59af1b909caa..cc113a2b74aa 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -1123,6 +1123,32 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## arrayFold\n+\n+Applies a lambda function to one or more equally-sized arrays and collects the result in an accumulator.\n+\n+**Syntax**\n+\n+``` sql\n+arrayFold(lambda_function, arr1, arr2, ..., accumulator)\n+```\n+\n+**Example**\n+\n+Query:\n+\n+``` sql\n+SELECT arrayFold( x,acc -> acc + x*2,  [1, 2, 3, 4], toInt64(3)) AS res;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500arrayFold(lambda(tuple(x, acc), plus(acc, multiply(x, 2))), [1, 2, 3, 4], toInt64(3))\u2500\u2510\n+\u2502                                                                                     3 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## arrayReverse(arr)\n \n Returns an array of the same size as the original array containing the elements in reverse order.\ndiff --git a/src/Functions/array/arrayFold.cpp b/src/Functions/array/arrayFold.cpp\nnew file mode 100644\nindex 000000000000..94ed5d59ca9b\n--- /dev/null\n+++ b/src/Functions/array/arrayFold.cpp\n@@ -0,0 +1,236 @@\n+#include \"FunctionArrayMapped.h\"\n+#include <Functions/FunctionFactory.h>\n+#include <Common/Exception.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int SIZES_OF_ARRAYS_DONT_MATCH;\n+    extern const int TYPE_MISMATCH;\n+}\n+\n+/**\n+ * arrayFold(x1,...,xn,accum -> expression, array1,...,arrayn, accum_initial) - apply the expression to each element of the array (or set of arrays).\n+ */\n+class ArrayFold : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"arrayFold\";\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<ArrayFold>(); }\n+\n+    bool isVariadic() const override { return true; }\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    void getLambdaArgumentTypes(DataTypes & arguments) const override\n+    {\n+        if (arguments.size() < 3)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires as arguments a lambda function, at least one array and an accumulator argument\", getName());\n+\n+        DataTypes nested_types(arguments.size() - 1);\n+        for (size_t i = 0; i < nested_types.size() - 1; ++i)\n+        {\n+            const auto * array_type = checkAndGetDataType<DataTypeArray>(&*arguments[i + 1]);\n+            if (!array_type)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument {} of function {} must be array, found {} instead\", i + 2, getName(), arguments[i + 1]->getName());\n+            nested_types[i] = recursiveRemoveLowCardinality(array_type->getNestedType());\n+        }\n+        nested_types[nested_types.size() - 1] = arguments[arguments.size() - 1];\n+\n+        const auto * function_type = checkAndGetDataType<DataTypeFunction>(arguments[0].get());\n+        if (!function_type || function_type->getArgumentTypes().size() != nested_types.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for this overload of {} must be a function with {} arguments, found {} instead.\",\n+                            getName(), nested_types.size(), arguments[0]->getName());\n+\n+        arguments[0] = std::make_shared<DataTypeFunction>(nested_types);\n+    }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.size() < 2)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires at least 2 arguments, passed: {}.\", getName(), arguments.size());\n+\n+        const auto * data_type_function = checkAndGetDataType<DataTypeFunction>(arguments[0].type.get());\n+        if (!data_type_function)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n+\n+        auto accumulator_type = arguments.back().type;\n+        auto lambda_type = data_type_function->getReturnType();\n+        if (!accumulator_type->equals(*lambda_type))\n+            throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                    \"Return type of lambda function must be the same as the accumulator type, inferred return type of lambda: {}, inferred type of accumulator: {}\",\n+                    lambda_type->getName(), accumulator_type->getName());\n+\n+        return accumulator_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto & lambda_with_type_and_name = arguments[0];\n+\n+        if (!lambda_with_type_and_name.column)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n+\n+        const auto * lambda_function = typeid_cast<const ColumnFunction *>(lambda_with_type_and_name.column.get());\n+        if (!lambda_function)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"First argument for function {} must be a function\", getName());\n+\n+        ColumnPtr offsets_column;\n+        ColumnPtr column_first_array_ptr;\n+        const ColumnArray * column_first_array = nullptr;\n+        ColumnsWithTypeAndName arrays;\n+        arrays.reserve(arguments.size() - 1);\n+        /// Validate input types and get input array columns in convenient form\n+        for (size_t i = 1; i < arguments.size() - 1; ++i)\n+        {\n+            const auto & array_with_type_and_name = arguments[i];\n+            ColumnPtr column_array_ptr = array_with_type_and_name.column;\n+            const auto * column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());\n+            if (!column_array)\n+            {\n+                const ColumnConst * column_const_array = checkAndGetColumnConst<ColumnArray>(column_array_ptr.get());\n+                if (!column_const_array)\n+                    throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Expected array column, found {}\", column_array_ptr->getName());\n+                column_array_ptr = recursiveRemoveLowCardinality(column_const_array->convertToFullColumn());\n+                column_array = checkAndGetColumn<ColumnArray>(column_array_ptr.get());\n+            }\n+\n+            const DataTypePtr & array_type_ptr = array_with_type_and_name.type;\n+            const auto * array_type = checkAndGetDataType<DataTypeArray>(array_type_ptr.get());\n+            if (!array_type)\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Expected array type, found {}\", array_type_ptr->getName());\n+\n+            if (!offsets_column)\n+                offsets_column = column_array->getOffsetsPtr();\n+            else\n+            {\n+                /// The first condition is optimization: do not compare data if the pointers are equal.\n+                if (column_array->getOffsetsPtr() != offsets_column\n+                    && column_array->getOffsets() != typeid_cast<const ColumnArray::ColumnOffsets &>(*offsets_column).getData())\n+                    throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH, \"Arrays passed to {} must have equal size\", getName());\n+            }\n+            if (i == 1)\n+            {\n+                column_first_array_ptr = column_array_ptr;\n+                column_first_array = column_array;\n+            }\n+            arrays.emplace_back(ColumnWithTypeAndName(column_array->getDataPtr(),\n+                                                      recursiveRemoveLowCardinality(array_type->getNestedType()),\n+                                                      array_with_type_and_name.name));\n+        }\n+\n+        ssize_t rows_count = input_rows_count;\n+        ssize_t data_row_count = arrays[0].column->size();\n+        size_t array_count = arrays.size();\n+\n+        if (rows_count == 0)\n+            return arguments.back().column->convertToFullColumnIfConst()->cloneEmpty();\n+\n+        ColumnPtr current_column;\n+        current_column = arguments.back().column->convertToFullColumnIfConst();\n+        MutableColumnPtr result_data = arguments.back().column->convertToFullColumnIfConst()->cloneEmpty();\n+\n+        size_t max_array_size = 0;\n+        const auto & offsets = column_first_array->getOffsets();\n+\n+        IColumn::Selector selector(data_row_count);\n+        size_t cur_ind = 0;\n+        ssize_t cur_arr = 0;\n+\n+        /// skip to the first non empty array\n+        if (data_row_count)\n+            while (offsets[cur_arr] == 0)\n+                ++cur_arr;\n+\n+        /// selector[i] is an index that i_th data element has in an array it corresponds to\n+        for (ssize_t i = 0; i < data_row_count; ++i)\n+        {\n+            selector[i] = cur_ind;\n+            cur_ind++;\n+            if (cur_ind > max_array_size)\n+                max_array_size = cur_ind;\n+            while (cur_arr < rows_count && cur_ind >= offsets[cur_arr] - offsets[cur_arr - 1])\n+            {\n+                ++cur_arr;\n+                cur_ind = 0;\n+            }\n+        }\n+\n+        std::vector<MutableColumns> data_arrays;\n+        data_arrays.resize(array_count);\n+\n+        /// Split each data column to columns containing elements of only Nth index in array\n+        if (max_array_size > 0)\n+            for (size_t i = 0; i < array_count; ++i)\n+                data_arrays[i] = arrays[i].column->scatter(max_array_size, selector);\n+\n+        size_t prev_size = rows_count;\n+\n+        IColumn::Permutation inverse_permutation(rows_count);\n+        size_t inverse_permutation_count = 0;\n+\n+        /// current_column after each iteration contains value of accumulator after applying values under indexes of arrays.\n+        /// At each iteration only rows of current_column with arrays that still has unapplied elements are kept.\n+        /// Discarded rows which contain finished calculations are added to result_data column and as we insert them we save their original row_number in inverse_permutation vector\n+        for (size_t ind = 0; ind < max_array_size; ++ind)\n+        {\n+            IColumn::Selector prev_selector(prev_size);\n+            size_t prev_ind = 0;\n+            for (ssize_t irow = 0; irow < rows_count; ++irow)\n+            {\n+                if (offsets[irow] - offsets[irow - 1] > ind)\n+                    prev_selector[prev_ind++] = 1;\n+                else if (offsets[irow] - offsets[irow - 1] == ind)\n+                {\n+                    inverse_permutation[inverse_permutation_count++] = irow;\n+                    prev_selector[prev_ind++] = 0;\n+                }\n+            }\n+            auto prev = current_column->scatter(2, prev_selector);\n+\n+            result_data->insertRangeFrom(*(prev[0]), 0, prev[0]->size());\n+\n+            auto res_lambda = lambda_function->cloneResized(prev[1]->size());\n+            auto * res_lambda_ptr = typeid_cast<ColumnFunction *>(res_lambda.get());\n+\n+            for (size_t i = 0; i < array_count; i++)\n+                res_lambda_ptr->appendArguments(std::vector({ColumnWithTypeAndName(std::move(data_arrays[i][ind]), arrays[i].type, arrays[i].name)}));\n+            res_lambda_ptr->appendArguments(std::vector({ColumnWithTypeAndName(std::move(prev[1]), arguments.back().type, arguments.back().name)}));\n+\n+            current_column = IColumn::mutate(res_lambda_ptr->reduce().column);\n+            prev_size = current_column->size();\n+        }\n+\n+        result_data->insertRangeFrom(*current_column, 0, current_column->size());\n+        for (ssize_t irow = 0; irow < rows_count; ++irow)\n+            if (offsets[irow] - offsets[irow - 1] == max_array_size)\n+                inverse_permutation[inverse_permutation_count++] = irow;\n+\n+        /// We have result_data containing result for every row and inverse_permutation which contains indexes of rows in input it corresponds to.\n+        /// Now we need to invert inverse_permuation and apply it to result_data to get rows in right order.\n+        IColumn::Permutation perm(rows_count);\n+        for (ssize_t i = 0; i < rows_count; i++)\n+            perm[inverse_permutation[i]] = i;\n+        return result_data->permute(perm, 0);\n+    }\n+\n+private:\n+    String getName() const override\n+    {\n+        return name;\n+    }\n+};\n+\n+REGISTER_FUNCTION(ArrayFold)\n+{\n+    factory.registerFunction<ArrayFold>(FunctionDocumentation{.description=R\"(\n+        Function arrayFold(x1,...,xn,accum -> expression, array1,...,arrayn, accum_initial) applies lambda function to a number of equally-sized arrays\n+        and collects the result in an accumulator.\n+        )\", .examples{{\"sum\", \"SELECT arrayFold(x,acc -> acc+x, [1,2,3,4], toInt64(1));\", \"11\"}}, .categories{\"Array\"}});\n+}\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 23d7e2876d51..57a0d1d274ea 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1046,6 +1046,7 @@ arrayFilter\n arrayFirst\n arrayFirstIndex\n arrayFlatten\n+arrayFold\n arrayIntersect\n arrayJaccardIndex\n arrayJoin\n",
  "test_patch": "diff --git a/tests/performance/array_fold.xml b/tests/performance/array_fold.xml\nnew file mode 100644\nindex 000000000000..fae8bd164a72\n--- /dev/null\n+++ b/tests/performance/array_fold.xml\n@@ -0,0 +1,5 @@\n+<test>\n+    <query>SELECT arrayFold((x, acc) -> acc + x, range(number % 100), toUInt64(0)) from numbers(100000) Format Null</query>\n+    <query>SELECT arrayFold((x, acc) -> acc + 1, range(number % 100), toUInt64(0)) from numbers(100000) Format Null</query>\n+    <query>SELECT arrayFold((x, acc) -> acc + x, range(number), toUInt64(0)) from numbers(10000) Format Null</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/02718_array_fold.reference b/tests/queries/0_stateless/02718_array_fold.reference\nnew file mode 100644\nindex 000000000000..4139232d145e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02718_array_fold.reference\n@@ -0,0 +1,25 @@\n+Negative tests\n+Const arrays\n+23\n+3\n+101\n+[1,2,3,4]\n+[4,3,2,1]\n+([4,3,2,1],[1,2,3,4])\n+([1,3,5],[2,4,6])\n+Non-const arrays\n+0\n+1\n+3\n+6\n+10\n+[]\n+[0]\n+[1,0]\n+[2,1,0]\n+[3,2,1,0]\n+[]\n+[0]\n+[1,0]\n+[1,0,2]\n+[3,1,0,2]\ndiff --git a/tests/queries/0_stateless/02718_array_fold.sql b/tests/queries/0_stateless/02718_array_fold.sql\nnew file mode 100644\nindex 000000000000..7f20602a3715\n--- /dev/null\n+++ b/tests/queries/0_stateless/02718_array_fold.sql\n@@ -0,0 +1,23 @@\n+SELECT 'Negative tests';\n+SELECT arrayFold(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayFold(1); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayFold(1, toUInt64(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( x,acc -> x,  emptyArrayString(), toInt8(0)); -- { serverError TYPE_MISMATCH }\n+SELECT arrayFold( x,acc -> x,  'not an array', toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( x,y,acc -> x,  [0, 1], 'not an array', toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( x,acc -> x,  [0, 1], [2, 3], toUInt8(0)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayFold( x,y,acc -> x,  [0, 1], [2, 3, 4], toUInt8(0)); -- { serverError SIZES_OF_ARRAYS_DONT_MATCH }\n+\n+SELECT 'Const arrays';\n+SELECT arrayFold( x,acc -> acc+x*2,  [1, 2, 3, 4], toInt64(3));\n+SELECT arrayFold( x,acc -> acc+x*2,  emptyArrayInt64(), toInt64(3));\n+SELECT arrayFold( x,y,acc -> acc+x*2+y*3,  [1, 2, 3, 4], [5, 6, 7, 8], toInt64(3));\n+SELECT arrayFold( x,acc -> arrayPushBack(acc, x),  [1, 2, 3, 4], emptyArrayInt64());\n+SELECT arrayFold( x,acc -> arrayPushFront(acc, x),  [1, 2, 3, 4], emptyArrayInt64());\n+SELECT arrayFold( x,acc -> (arrayPushFront(acc.1, x),arrayPushBack(acc.2, x)),  [1, 2, 3, 4], (emptyArrayInt64(), emptyArrayInt64()));\n+SELECT arrayFold( x,acc -> x%2 ? (arrayPushBack(acc.1, x), acc.2): (acc.1, arrayPushBack(acc.2, x)),  [1, 2, 3, 4, 5, 6], (emptyArrayInt64(), emptyArrayInt64()));\n+\n+SELECT 'Non-const arrays';\n+SELECT arrayFold( x,acc -> acc+x,  range(number), number) FROM system.numbers LIMIT 5;\n+SELECT arrayFold( x,acc -> arrayPushFront(acc,x),  range(number), emptyArrayUInt64()) FROM system.numbers LIMIT 5;\n+SELECT arrayFold( x,acc -> x%2 ? arrayPushFront(acc,x) : arrayPushBack(acc,x),  range(number), emptyArrayUInt64()) FROM system.numbers LIMIT 5;\n",
  "problem_statement": "`arrayFold` function\nSee\r\n\r\n#21589\r\n#23248\r\n#27270\n",
  "hints_text": "Hello\uff0ci want to pick this up\nOk, it's yours.\r\n\r\nJust to let you know - it's not an easy task.\r\nWe have to implement \"vertical\" application of the folding function to the column with arrays.\r\n\r\n1. Filter arrays that contain more than zero elements and pick first elements from every array.\r\n2. Apply a function to the first elements of every arrays.\r\n3. Repeat (1) and (2) with the second elements and so forth.\r\n4. Now we have columns with the results for 0-element arrays, 1-element arrays, 2-element arrays and so forth. Gather the results from these columns into the final resulting column.\r\n\r\n@amosbird Maybe you can help @roanhe-ts with this task?\nAll right ...., I thought it was an easy task ...\r\nSo, is there any time limitation? I will consider the complexity with my capability in case of overdue too much.\r\n\r\n@alexey-milovidov \nNo time limitation. You can spend several months if you want :+1: \r\nIt should be doable maybe in a week if someone will help.\n> It should be doable maybe in a week if someone will help.\r\n\r\nOK, I will try my best.\n@alexey-milovidov hello\uff0cI met some problems during this task, could you please help me?\r\n\r\nFirst, according to definition of arrayFold, we can have pseudocode like bellow:\r\n```txt\r\nlet acc = init\r\nfor (array in array_vector)\r\n{\r\n    acc = lambda(array, acc)\r\n}\r\nreturn acc;\r\n```\r\n* **acc need to be updated every time we call lambda expression**\r\n\r\nEvery time, we got acc of N-element arrays, we need to eliminate some of them from acc column, and construct a new acc  column. Because the eliminated acc just got its final result, no more N+1-element arrays can be calculated with them.\r\n\r\nMay be a specific example could help discuss. Say, we have a table foldDemo like this:\r\n\r\n|array1(Array)|array2(Array)|\r\n|--|--|\r\n|[1,2,3,4]|[10,20,30,40]|\r\n|[4]|[40]|\r\n|[21,2]|[10,20]|\r\n|[11,20,30]|[11,2,3]|\r\n\r\n\r\nthe query is like:\r\n```sql\r\nselect arrayFold((x, y, acc) -> (x + acc.1, y + acc.2), array1, array2, (0,0)) from foldDemo\r\n```\r\n\r\n1. Filter all arrays which has at least 1 elements & calculate accumulator of 1-element array, we got\r\n\r\n|accumulator|\r\n|--|\r\n|1,10|\r\n|4,40|\r\n|21,10|\r\n|11,11|\r\n\r\n2. We need to resize column accumulator because row NO.2 does not have 2-element array. So the input arguments of lambda expression in next loop is \r\n\r\n|array1|array2|accumulator|\r\n|--|--|--|\r\n|2|20|(1,10)|\r\n|2|20|(21,10)|\r\n|20|2|(11,11)|\r\n\r\nNo need to continue the processing. \r\nIn step2 on above, the resize of column accumulator is expensive (tuple copy), and we need an ordered map to store the eliminated acc tuple (4,40), or we have to insert it to the row NO.2 of result column, which is also expensive.\r\n\r\nThe problem is:\r\n1. whether the above steps are right? Are there any better way to `Gather the results from these columns into the final resulting column.`\r\n2. Are there any possibility to avoid resize input of lambda expression? For example we use an `NULL-like` array to fill the position so than lambda(null-like-array, acc) still equals to acc\r\n\r\n\r\n",
  "created_at": "2023-05-11T18:51:04Z",
  "modified_files": [
    "docs/en/sql-reference/functions/array-functions.md",
    "b/src/Functions/array/arrayFold.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "b/tests/performance/array_fold.xml",
    "b/tests/queries/0_stateless/02718_array_fold.reference",
    "b/tests/queries/0_stateless/02718_array_fold.sql"
  ]
}