{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62377,
  "instance_id": "ClickHouse__ClickHouse-62377",
  "issue_numbers": [
    "59019"
  ],
  "base_commit": "658a8e9a9b1658cd12c78365f9829b35d016f1b2",
  "patch": "diff --git a/docs/en/sql-reference/functions/conditional-functions.md b/docs/en/sql-reference/functions/conditional-functions.md\nindex eb4e98961f15..564186fd8db7 100644\n--- a/docs/en/sql-reference/functions/conditional-functions.md\n+++ b/docs/en/sql-reference/functions/conditional-functions.md\n@@ -234,3 +234,34 @@ SELECT least(toDateTime32(now() + toIntervalDay(1)), toDateTime64(now(), 3))\n :::note\n The type returned is a DateTime64 as the DataTime32 must be promoted to 64 bit for the comparison.\n :::\n+\n+## clamp\n+\n+Constrain the return value between A and B.\n+\n+**Syntax**\n+\n+``` sql\n+clamp(value, min, max)\n+```\n+\n+**Arguments**\n+\n+- `value` \u2013 Input value.\n+- `min` \u2013 Limit the lower bound.\n+- `max` \u2013 Limit the upper bound.\n+\n+**Returned values**\n+\n+If the value is less than the minimum value, return the minimum value; if it is greater than the maximum value, return the maximum value; otherwise, return the current value.\n+\n+Examples:\n+\n+```sql\n+SELECT clamp(1, 2, 3) result,  toTypeName(result) type;\n+```\n+```response\n+\u250c\u2500result\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2510\n+\u2502      2 \u2502 Float64 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n\\ No newline at end of file\ndiff --git a/src/Functions/clamp.cpp b/src/Functions/clamp.cpp\nnew file mode 100644\nindex 000000000000..bb347a575e44\n--- /dev/null\n+++ b/src/Functions/clamp.cpp\n@@ -0,0 +1,69 @@\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/getLeastSupertype.h>\n+#include <Interpreters/castColumn.h>\n+#include <Interpreters/Context.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+\n+class FunctionClamp : public IFunction\n+{\n+\n+public:\n+    static constexpr auto name = \"clamp\";\n+\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 3; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionClamp>(); }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & types) const override\n+    {\n+        if (types.size() != 3)\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Function {} requires 3 arguments\", getName());\n+\n+        return getLeastSupertype(types);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        size_t arg_size = arguments.size();\n+        Columns converted_columns(arg_size);\n+        for (size_t arg = 0; arg < arg_size; ++arg)\n+            converted_columns[arg] = castColumn(arguments[arg], result_type)->convertToFullColumnIfConst();\n+\n+        auto result_column = result_type->createColumn();\n+        for (size_t row_num = 0; row_num < input_rows_count; ++row_num)\n+        {\n+            if (converted_columns[1]->compareAt(row_num, row_num, *converted_columns[2], 1) > 0)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"The minimum value cannot be greater than the maximum value for function {}\", getName());\n+\n+            size_t best_arg = 0;\n+            if (converted_columns[1]->compareAt(row_num, row_num, *converted_columns[best_arg], 1) > 0)\n+                best_arg = 1;\n+            else if (converted_columns[2]->compareAt(row_num, row_num, *converted_columns[best_arg], 1) < 0)\n+                best_arg = 2;\n+\n+            result_column->insertFrom(*converted_columns[best_arg], row_num);\n+        }\n+\n+        return result_column;\n+    }\n+\n+};\n+\n+REGISTER_FUNCTION(Clamp)\n+{\n+    factory.registerFunction<FunctionClamp>();\n+}\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 3ddf165dec09..a152066a4609 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -201,6 +201,7 @@ cbrt\n ceil\n char\n cityHash64\n+clamp\n coalesce\n concat\n concatAssumeInjective\ndiff --git a/tests/queries/0_stateless/03036_clamp.reference b/tests/queries/0_stateless/03036_clamp.reference\nnew file mode 100644\nindex 000000000000..b866caf2261c\n--- /dev/null\n+++ b/tests/queries/0_stateless/03036_clamp.reference\n@@ -0,0 +1,14 @@\n+10\n+20\n+15\n+b\n+0\n+['hello']\n+-1\n+234\n+\\N\n+\\N\n+5\n+0\n+1\n+2\ndiff --git a/tests/queries/0_stateless/03036_clamp.sql b/tests/queries/0_stateless/03036_clamp.sql\nnew file mode 100644\nindex 000000000000..9973265c13b7\n--- /dev/null\n+++ b/tests/queries/0_stateless/03036_clamp.sql\n@@ -0,0 +1,15 @@\n+SELECT clamp(1, 10, 20);\n+SELECT clamp(30, 10, 20);\n+SELECT clamp(15, 10, 20);\n+SELECT clamp('a', 'b', 'c');\n+SELECT clamp(today(), yesterday() - 10, yesterday() + 10) - today();\n+SELECT clamp([], ['hello'], ['world']);\n+SELECT clamp(-1., -1000., 18446744073709551615.);\n+SELECT clamp(toNullable(123), 234, 456);\n+select clamp(1, null, 5);\n+select clamp(1, 6, null);\n+select clamp(1, 5, nan);\n+select clamp(toInt64(number), toInt64(number-1), toInt64(number+1)) from numbers(3);\n+select clamp(number, number-1, number+1) from numbers(3);   -- { serverError NO_COMMON_TYPE }\n+select clamp(1, 3, 2);   -- { serverError BAD_ARGUMENTS } \n+select clamp(1, data[1], data[2])from (select arrayJoin([[1, 2], [2,3], [3,2], [4, 4]]) as data);   -- { serverError BAD_ARGUMENTS } \n",
  "problem_statement": "A function `clamp`\n**Use case**\r\n\r\n`clamp(x, min, max)`\r\n\r\nis equivalent to\r\n\r\n`least(greatest(x, min), max)`\r\n\n",
  "hints_text": "I'd like to do it on this weekend, but I'm beginner in the project and think that it can take some time\r\n\n@D0zee, thank you! It will be very nice!\n@alexey-milovidov If there are some entry points or places what should I look first, please let me know. It will really reduce time that I'm going to spent.\r\n\r\nNow I have a global idea to create a function that will take 3 arguments and just call the equivalent function.\n@D0zee \r\n\r\nStart working with the codebase: https://clickhouse.com/docs/en/development/developer-instruction/\r\nClickHouse architecture: https://clickhouse.com/docs/en/development/architecture/\r\nExample of adding a function: https://github.com/ClickHouse/ClickHouse/pull/57442\r\nGood video: https://youtu.be/tNzdrw1L1Xk\r\n\n@alexey-milovidov Do I correctly understand that if we have the table with ages (for example 10, 20, 30, 40), then after executing `SELECT clamp(age, 10, 29) FROM people` we should get 2 rows of output or 4 rows with values (10, 20, 29, 29)? I'm just trying to get use cases of `clamp` function.\r\n\r\nIn documentation it is stated that the ordinary function doesn't change count of rows. \r\nCould I ask you via Slack channel if it is more convenient for you? \nThe function, similarly to all ordinary functions, should not change the number of rows. It clamps every row. So, the output will be `(10, 20, 29, 29)`.\nI'll work on this if D0zee is not working on it anymore. ",
  "created_at": "2024-04-07T11:31:36Z"
}