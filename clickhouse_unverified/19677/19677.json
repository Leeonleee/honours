{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19677,
  "instance_id": "ClickHouse__ClickHouse-19677",
  "issue_numbers": [
    "14527"
  ],
  "base_commit": "ef72ba7349f230321750c13ee63b49a11a7c0adc",
  "patch": "diff --git a/src/Core/Block.cpp b/src/Core/Block.cpp\nindex cd2855739e2f..0c9a470dc1d4 100644\n--- a/src/Core/Block.cpp\n+++ b/src/Core/Block.cpp\n@@ -409,6 +409,15 @@ Block Block::cloneWithoutColumns() const\n     return res;\n }\n \n+Block Block::cloneWithCutColumns(size_t start, size_t length) const\n+{\n+    Block copy = *this;\n+\n+    for (auto & column_to_cut : copy.data)\n+        column_to_cut.column = column_to_cut.column->cut(start, length);\n+\n+    return copy;\n+}\n \n Block Block::sortColumns() const\n {\ndiff --git a/src/Core/Block.h b/src/Core/Block.h\nindex f588373aaed3..14f4f57caedc 100644\n--- a/src/Core/Block.h\n+++ b/src/Core/Block.h\n@@ -129,6 +129,7 @@ class Block\n     void setColumns(const Columns & columns);\n     Block cloneWithColumns(const Columns & columns) const;\n     Block cloneWithoutColumns() const;\n+    Block cloneWithCutColumns(size_t start, size_t length) const;\n \n     /** Get empty columns with the same types as in block. */\n     MutableColumns cloneEmptyColumns() const;\ndiff --git a/src/Dictionaries/DictionarySourceHelpers.cpp b/src/Dictionaries/DictionarySourceHelpers.cpp\nindex 309bc64e179e..2a872672aff0 100644\n--- a/src/Dictionaries/DictionarySourceHelpers.cpp\n+++ b/src/Dictionaries/DictionarySourceHelpers.cpp\n@@ -1,6 +1,5 @@\n #include \"DictionarySourceHelpers.h\"\n #include <Columns/ColumnsNumber.h>\n-#include <Core/Block.h>\n #include <Core/ColumnWithTypeAndName.h>\n #include <DataStreams/IBlockOutputStream.h>\n #include <DataTypes/DataTypesNumber.h>\n@@ -13,44 +12,54 @@\n \n namespace DB\n {\n+\n+void formatBlock(BlockOutputStreamPtr & out, const Block & block)\n+{\n+    out->writePrefix();\n+    out->write(block);\n+    out->writeSuffix();\n+    out->flush();\n+}\n+\n /// For simple key\n-void formatIDs(BlockOutputStreamPtr & out, const std::vector<UInt64> & ids)\n+\n+Block blockForIds(\n+    const DictionaryStructure & dict_struct,\n+    const std::vector<UInt64> & ids)\n {\n     auto column = ColumnUInt64::create(ids.size());\n     memcpy(column->getData().data(), ids.data(), ids.size() * sizeof(ids.front()));\n \n-    Block block{{std::move(column), std::make_shared<DataTypeUInt64>(), \"id\"}};\n+    Block block{{std::move(column), std::make_shared<DataTypeUInt64>(), (*dict_struct.id).name}};\n \n-    out->writePrefix();\n-    out->write(block);\n-    out->writeSuffix();\n-    out->flush();\n+    return block;\n }\n \n /// For composite key\n-void formatKeys(\n+\n+Block blockForKeys(\n     const DictionaryStructure & dict_struct,\n-    BlockOutputStreamPtr & out,\n     const Columns & key_columns,\n     const std::vector<size_t> & requested_rows)\n {\n     Block block;\n+\n     for (size_t i = 0, size = key_columns.size(); i < size; ++i)\n     {\n         const ColumnPtr & source_column = key_columns[i];\n-        auto filtered_column = source_column->cloneEmpty();\n-        filtered_column->reserve(requested_rows.size());\n+        size_t column_rows_size = source_column->size();\n+\n+        PaddedPODArray<UInt8> filter(column_rows_size, false);\n \n         for (size_t idx : requested_rows)\n-            filtered_column->insertFrom(*source_column, idx);\n+            filter[idx] = true;\n \n-        block.insert({std::move(filtered_column), (*dict_struct.key)[i].type, toString(i)});\n+        auto filtered_column = source_column->filter(filter, requested_rows.size());\n+\n+        block.insert({std::move(filtered_column), (*dict_struct.key)[i].type, (*dict_struct.key)[i].name});\n     }\n \n-    out->writePrefix();\n-    out->write(block);\n-    out->writeSuffix();\n-    out->flush();\n+    return block;\n }\n \n Context copyContextAndApplySettings(\ndiff --git a/src/Dictionaries/DictionarySourceHelpers.h b/src/Dictionaries/DictionarySourceHelpers.h\nindex 3f42700d3362..cad5441c66e1 100644\n--- a/src/Dictionaries/DictionarySourceHelpers.h\n+++ b/src/Dictionaries/DictionarySourceHelpers.h\n@@ -1,11 +1,15 @@\n #pragma once\n \n #include <vector>\n-#include <Columns/IColumn.h>\n+\n #include <common/types.h>\n+\n #include <Poco/File.h>\n #include <Poco/Util/AbstractConfiguration.h>\n \n+#include <Columns/IColumn.h>\n+#include <Core/Block.h>\n+\n namespace DB\n {\n class IBlockOutputStream;\n@@ -16,13 +20,18 @@ class Context;\n \n /// Write keys to block output stream.\n \n+void formatBlock(BlockOutputStreamPtr & out, const Block & block);\n+\n /// For simple key\n-void formatIDs(BlockOutputStreamPtr & out, const std::vector<UInt64> & ids);\n+\n+Block blockForIds(\n+    const DictionaryStructure & dict_struct,\n+    const std::vector<UInt64> & ids);\n \n /// For composite key\n-void formatKeys(\n+\n+Block blockForKeys(\n     const DictionaryStructure & dict_struct,\n-    BlockOutputStreamPtr & out,\n     const Columns & key_columns,\n     const std::vector<size_t> & requested_rows);\n \n@@ -36,4 +45,5 @@ void applySettingsToContext(\n     const std::string & config_prefix,\n     Context & context,\n     const Poco::Util::AbstractConfiguration & config);\n+\n }\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex 95c2e0a3e09e..25f5736221ea 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -281,6 +281,21 @@ size_t DictionaryStructure::getKeySize() const\n     });\n }\n \n+Strings DictionaryStructure::getKeysNames() const\n+{\n+    if (id)\n+        return { id->name };\n+\n+    const auto & key_attributes = *key;\n+\n+    Strings keys_names;\n+    keys_names.reserve(key_attributes.size());\n+\n+    for (const auto & key_attribute : key_attributes)\n+        keys_names.emplace_back(key_attribute.name);\n+\n+    return keys_names;\n+}\n \n static void checkAttributeKeys(const Poco::Util::AbstractConfiguration::Keys & keys)\n {\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 945e1c55494f..c6c80498a4b7 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -158,6 +158,8 @@ struct DictionaryStructure final\n     std::string getKeyDescription() const;\n     bool isKeySizeFixed() const;\n     size_t getKeySize() const;\n+    Strings getKeysNames() const;\n+\n private:\n     /// range_min and range_max have to be parsed before this function call\n     std::vector<DictionaryAttribute> getAttributes(\ndiff --git a/src/Dictionaries/ExecutableDictionarySource.cpp b/src/Dictionaries/ExecutableDictionarySource.cpp\nindex f2abe10f970c..42dac540f09e 100644\n--- a/src/Dictionaries/ExecutableDictionarySource.cpp\n+++ b/src/Dictionaries/ExecutableDictionarySource.cpp\n@@ -26,6 +26,8 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int DICTIONARY_ACCESS_DENIED;\n+    extern const int UNSUPPORTED_METHOD;\n+    extern const int SIZES_OF_COLUMNS_DOESNT_MATCH;\n }\n \n namespace\n@@ -65,18 +67,34 @@ ExecutableDictionarySource::ExecutableDictionarySource(\n     const Context & context_)\n     : log(&Poco::Logger::get(\"ExecutableDictionarySource\"))\n     , dict_struct{dict_struct_}\n+    , implicit_key{config.getBool(config_prefix + \".implicit_key\", false)}\n     , command{config.getString(config_prefix + \".command\")}\n     , update_field{config.getString(config_prefix + \".update_field\", \"\")}\n     , format{config.getString(config_prefix + \".format\")}\n     , sample_block{sample_block_}\n     , context(context_)\n {\n+    /// Remove keys from sample_block for implicit_key dictionary because\n+    /// these columns will not be returned from source\n+    /// Implicit key means that the source script will return only values,\n+    /// and the correspondence to the requested keys is determined implicitly - by the order of rows in the result.\n+    if (implicit_key)\n+    {\n+        auto keys_names = dict_struct.getKeysNames();\n+\n+        for (auto & key_name : keys_names)\n+        {\n+            size_t key_column_position_in_block = sample_block.getPositionByName(key_name);\n+            sample_block.erase(key_column_position_in_block);\n+        }\n+    }\n }\n \n ExecutableDictionarySource::ExecutableDictionarySource(const ExecutableDictionarySource & other)\n     : log(&Poco::Logger::get(\"ExecutableDictionarySource\"))\n     , update_time{other.update_time}\n     , dict_struct{other.dict_struct}\n+    , implicit_key{other.implicit_key}\n     , command{other.command}\n     , update_field{other.update_field}\n     , format{other.format}\n@@ -87,6 +105,9 @@ ExecutableDictionarySource::ExecutableDictionarySource(const ExecutableDictionar\n \n BlockInputStreamPtr ExecutableDictionarySource::loadAll()\n {\n+    if (implicit_key)\n+        throw Exception(\"ExecutableDictionarySource with implicit_key does not support loadAll method\", ErrorCodes::UNSUPPORTED_METHOD);\n+\n     LOG_TRACE(log, \"loadAll {}\", toString());\n     auto process = ShellCommand::execute(command);\n     auto input_stream = context.getInputFormat(format, process->out, sample_block, max_block_size);\n@@ -95,6 +116,9 @@ BlockInputStreamPtr ExecutableDictionarySource::loadAll()\n \n BlockInputStreamPtr ExecutableDictionarySource::loadUpdatedAll()\n {\n+    if (implicit_key)\n+        throw Exception(\"ExecutableDictionarySource with implicit_key does not support loadUpdatedAll method\", ErrorCodes::UNSUPPORTED_METHOD);\n+\n     time_t new_update_time = time(nullptr);\n     SCOPE_EXIT(update_time = new_update_time);\n \n@@ -173,6 +197,77 @@ namespace\n         std::function<void(WriteBufferFromFile &)> send_data;\n         ThreadFromGlobalPool thread;\n     };\n+\n+    /** A stream, adds additional columns to each block that it will read from inner stream.\n+     *\n+     *  block_to_add rows size must be equal to final sum rows size of all inner stream blocks.\n+     */\n+    class BlockInputStreamWithAdditionalColumns final: public IBlockInputStream\n+    {\n+    public:\n+        BlockInputStreamWithAdditionalColumns(\n+            Block block_to_add_,\n+            std::unique_ptr<IBlockInputStream>&& stream_)\n+            : block_to_add(std::move(block_to_add_))\n+            , stream(std::move(stream_))\n+        {\n+        }\n+\n+        Block getHeader() const override\n+        {\n+            auto header = stream->getHeader();\n+\n+            if (header)\n+            {\n+                for (Int64 i = static_cast<Int64>(block_to_add.columns() - 1); i >= 0; --i)\n+                    header.insert(0, block_to_add.getByPosition(i).cloneEmpty());\n+            }\n+\n+            return header;\n+        }\n+\n+        Block readImpl() override\n+        {\n+            auto block = stream->read();\n+\n+            if (block)\n+            {\n+                auto block_rows = block.rows();\n+\n+                auto cut_block = block_to_add.cloneWithCutColumns(current_range_index, block_rows);\n+\n+                if (cut_block.rows() != block_rows)\n+                    throw Exception(\n+                        \"Number of rows in block to add after cut must equal to number of rows in block from inner stream\",\n+                        ErrorCodes::SIZES_OF_COLUMNS_DOESNT_MATCH);\n+\n+                for (Int64 i = static_cast<Int64>(cut_block.columns() - 1); i >= 0; --i)\n+                    block.insert(0, cut_block.getByPosition(i));\n+\n+                current_range_index += block_rows;\n+            }\n+\n+            return block;\n+        }\n+\n+        void readPrefix() override\n+        {\n+            stream->readPrefix();\n+        }\n+\n+        void readSuffix() override\n+        {\n+            stream->readSuffix();\n+        }\n+\n+        String getName() const override { return \"BlockInputStreamWithAdditionalColumns\"; }\n+\n+    private:\n+        Block block_to_add;\n+        std::unique_ptr<IBlockInputStream> stream;\n+        size_t current_range_index = 0;\n+    };\n+\n }\n \n \n@@ -180,28 +275,44 @@ BlockInputStreamPtr ExecutableDictionarySource::loadIds(const std::vector<UInt64\n {\n     LOG_TRACE(log, \"loadIds {} size = {}\", toString(), ids.size());\n \n-    return std::make_shared<BlockInputStreamWithBackgroundThread>(\n+    auto block = blockForIds(dict_struct, ids);\n+\n+    auto stream = std::make_unique<BlockInputStreamWithBackgroundThread>(\n         context, format, sample_block, command, log,\n-        [&ids, this](WriteBufferFromFile & out) mutable\n+        [block, this](WriteBufferFromFile & out) mutable\n         {\n-            auto output_stream = context.getOutputStream(format, out, sample_block);\n-            formatIDs(output_stream, ids);\n+            auto output_stream = context.getOutputStream(format, out, block.cloneEmpty());\n+            formatBlock(output_stream, block);\n             out.close();\n         });\n+\n+    if (implicit_key)\n+    {\n+        return std::make_shared<BlockInputStreamWithAdditionalColumns>(block, std::move(stream));\n+    }\n+    else\n+        return std::shared_ptr<BlockInputStreamWithBackgroundThread>(stream.release());\n }\n \n BlockInputStreamPtr ExecutableDictionarySource::loadKeys(const Columns & key_columns, const std::vector<size_t> & requested_rows)\n {\n     LOG_TRACE(log, \"loadKeys {} size = {}\", toString(), requested_rows.size());\n \n-    return std::make_shared<BlockInputStreamWithBackgroundThread>(\n+    auto block = blockForKeys(dict_struct, key_columns, requested_rows);\n+\n+    auto stream = std::make_unique<BlockInputStreamWithBackgroundThread>(\n         context, format, sample_block, command, log,\n-        [key_columns, &requested_rows, this](WriteBufferFromFile & out) mutable\n+        [block, this](WriteBufferFromFile & out) mutable\n         {\n-            auto output_stream = context.getOutputStream(format, out, sample_block);\n-            formatKeys(dict_struct, output_stream, key_columns, requested_rows);\n+            auto output_stream = context.getOutputStream(format, out, block.cloneEmpty());\n+            formatBlock(output_stream, block);\n             out.close();\n         });\n+\n+    if (implicit_key)\n+        return std::make_shared<BlockInputStreamWithAdditionalColumns>(block, std::move(stream));\n+    else\n+        return std::shared_ptr<BlockInputStreamWithBackgroundThread>(stream.release());\n }\n \n bool ExecutableDictionarySource::isModified() const\ndiff --git a/src/Dictionaries/ExecutableDictionarySource.h b/src/Dictionaries/ExecutableDictionarySource.h\nindex f28d71ca5e31..7aa203f267b2 100644\n--- a/src/Dictionaries/ExecutableDictionarySource.h\n+++ b/src/Dictionaries/ExecutableDictionarySource.h\n@@ -49,9 +49,9 @@ class ExecutableDictionarySource final : public IDictionarySource\n \n private:\n     Poco::Logger * log;\n-\n     time_t update_time = 0;\n     const DictionaryStructure dict_struct;\n+    bool implicit_key;\n     const std::string command;\n     const std::string update_field;\n     const std::string format;\ndiff --git a/src/Dictionaries/HTTPDictionarySource.cpp b/src/Dictionaries/HTTPDictionarySource.cpp\nindex da5623bcdb05..ddcac117e586 100644\n--- a/src/Dictionaries/HTTPDictionarySource.cpp\n+++ b/src/Dictionaries/HTTPDictionarySource.cpp\n@@ -131,11 +131,13 @@ BlockInputStreamPtr HTTPDictionarySource::loadIds(const std::vector<UInt64> & id\n {\n     LOG_TRACE(log, \"loadIds {} size = {}\", toString(), ids.size());\n \n-    ReadWriteBufferFromHTTP::OutStreamCallback out_stream_callback = [&](std::ostream & ostr)\n+    auto block = blockForIds(dict_struct, ids);\n+\n+    ReadWriteBufferFromHTTP::OutStreamCallback out_stream_callback = [block, this](std::ostream & ostr)\n     {\n         WriteBufferFromOStream out_buffer(ostr);\n         auto output_stream = context.getOutputStream(format, out_buffer, sample_block);\n-        formatIDs(output_stream, ids);\n+        formatBlock(output_stream, block);\n     };\n \n     Poco::URI uri(url);\n@@ -150,11 +152,13 @@ BlockInputStreamPtr HTTPDictionarySource::loadKeys(const Columns & key_columns,\n {\n     LOG_TRACE(log, \"loadKeys {} size = {}\", toString(), requested_rows.size());\n \n-    ReadWriteBufferFromHTTP::OutStreamCallback out_stream_callback = [&](std::ostream & ostr)\n+    auto block = blockForKeys(dict_struct, key_columns, requested_rows);\n+\n+    ReadWriteBufferFromHTTP::OutStreamCallback out_stream_callback = [block, this](std::ostream & ostr)\n     {\n         WriteBufferFromOStream out_buffer(ostr);\n         auto output_stream = context.getOutputStream(format, out_buffer, sample_block);\n-        formatKeys(dict_struct, output_stream, key_columns, requested_rows);\n+        formatBlock(output_stream, block);\n     };\n \n     Poco::URI uri(url);\n",
  "test_patch": "diff --git a/tests/config/executable_dictionary.xml b/tests/config/executable_dictionary.xml\nindex 50df32e2ec60..c5a4a0947bc5 100644\n--- a/tests/config/executable_dictionary.xml\n+++ b/tests/config/executable_dictionary.xml\n@@ -105,4 +105,152 @@\n     </structure>\n </dictionary>\n \n+<dictionary>\n+    <name>simple_executable_cache_dictionary_no_implicit_key</name>\n+\n+    <structure>\n+        <id>\n+            <name>id</name>\n+            <type>UInt64</type>\n+        </id>\n+\n+        <attribute>\n+            <name>value</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable>\n+            <command>echo \"1\\tValue\"</command>\n+            <format>TabSeparated</format>\n+            <implicit_key>false</implicit_key>\n+        </executable>\n+    </source>\n+\n+    <layout>\n+        <cache>\n+            <size_in_cells>10000</size_in_cells>\n+        </cache>\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+<dictionary>\n+    <name>simple_executable_cache_dictionary_implicit_key</name>\n+\n+    <structure>\n+        <id>\n+            <name>id</name>\n+            <type>UInt64</type>\n+        </id>\n+\n+        <attribute>\n+            <name>value</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable>\n+            <command>echo \"Value\"</command>\n+            <format>TabSeparated</format>\n+            <implicit_key>true</implicit_key>\n+        </executable>\n+    </source>\n+\n+    <layout>\n+        <cache>\n+            <size_in_cells>10000</size_in_cells>\n+        </cache>\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+<dictionary>\n+    <name>complex_executable_cache_dictionary_no_implicit_key</name>\n+\n+    <structure>\n+        <key>\n+            <attribute>\n+                <name>id</name>\n+                <type>UInt64</type>\n+                <null_value></null_value>\n+            </attribute>\n+            <attribute>\n+                <name>id_key</name>\n+                <type>String</type>\n+                <null_value></null_value>\n+            </attribute>\n+        </key>\n+\n+        <attribute>\n+            <name>value</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable>\n+            <command>echo \"1\\tFirstKey\\tValue\"</command>\n+            <format>TabSeparated</format>\n+            <implicit_key>false</implicit_key>\n+        </executable>\n+    </source>\n+\n+    <layout>\n+        <complex_key_cache>\n+            <size_in_cells>10000</size_in_cells>\n+        </complex_key_cache>\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n+<dictionary>\n+    <name>complex_executable_cache_dictionary_implicit_key</name>\n+\n+    <structure>\n+        <key>\n+            <attribute>\n+                <name>id</name>\n+                <type>UInt64</type>\n+                <null_value></null_value>\n+            </attribute>\n+            <attribute>\n+                <name>id_key</name>\n+                <type>String</type>\n+                <null_value></null_value>\n+            </attribute>\n+        </key>\n+\n+        <attribute>\n+            <name>value</name>\n+            <type>String</type>\n+            <null_value></null_value>\n+        </attribute>\n+    </structure>\n+\n+    <source>\n+        <executable>\n+            <command>echo \"Value\"</command>\n+            <format>TabSeparated</format>\n+            <implicit_key>true</implicit_key>\n+        </executable>\n+    </source>\n+\n+    <layout>\n+        <complex_key_cache>\n+            <size_in_cells>10000</size_in_cells>\n+        </complex_key_cache>\n+    </layout>\n+\n+    <lifetime>300</lifetime>\n+</dictionary>\n+\n </dictionaries>\ndiff --git a/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.reference b/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.reference\nnew file mode 100644\nindex 000000000000..0777c3c2625c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.reference\n@@ -0,0 +1,4 @@\n+Value\n+Value\n+Value\n+Value\ndiff --git a/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.sql b/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.sql\nnew file mode 100644\nindex 000000000000..c98cb0a5e0fe\n--- /dev/null\n+++ b/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.sql\n@@ -0,0 +1,5 @@\n+SELECT dictGet('simple_executable_cache_dictionary_no_implicit_key', 'value', toUInt64(1));\n+SELECT dictGet('simple_executable_cache_dictionary_implicit_key', 'value', toUInt64(1));\n+\n+SELECT dictGet('complex_executable_cache_dictionary_no_implicit_key', 'value', (toUInt64(1), 'FirstKey'));\n+SELECT dictGet('complex_executable_cache_dictionary_implicit_key', 'value', (toUInt64(1), 'FirstKey'));\ndiff --git a/tests/queries/0_stateless/arcadia_skip_list.txt b/tests/queries/0_stateless/arcadia_skip_list.txt\nindex 253eab720af5..5b8256bb5aff 100644\n--- a/tests/queries/0_stateless/arcadia_skip_list.txt\n+++ b/tests/queries/0_stateless/arcadia_skip_list.txt\n@@ -198,3 +198,4 @@\n 01659_test_base64Decode_mysql_compatibility\n 01675_data_type_coroutine\n 01671_aggregate_function_group_bitmap_data\n+01674_executable_dictionary_implicit_key\n",
  "problem_statement": "Implicit key option for executable dictionary source.\nExecutable dictionary is allowed to output data in arbitrary order but it is required that key is present in every output row along the value.\r\n\r\nExample. Suppose we make a program that transforms numbers to readable form and we use it as a dictionary.\r\nFor input keys:\r\n\r\n```\r\n1\r\n2\r\n33000\r\n```\r\n\r\nIt should output:\r\n```\r\n1       one\r\n2       two\r\n33000   thirty three thousand\r\n```\r\n\r\nLet's add an option `implicit_key` that will allow the dictionary to work if the program will output in the following format:\r\n\r\n```\r\none\r\ntwo\r\nthirty three thousand\r\n```\r\n(when keys will be identified by their order in output)\n",
  "hints_text": "",
  "created_at": "2021-01-26T20:50:19Z",
  "modified_files": [
    "src/Core/Block.cpp",
    "src/Core/Block.h",
    "src/Dictionaries/DictionarySourceHelpers.cpp",
    "src/Dictionaries/DictionarySourceHelpers.h",
    "src/Dictionaries/DictionaryStructure.cpp",
    "src/Dictionaries/DictionaryStructure.h",
    "src/Dictionaries/ExecutableDictionarySource.cpp",
    "src/Dictionaries/ExecutableDictionarySource.h",
    "src/Dictionaries/HTTPDictionarySource.cpp"
  ],
  "modified_test_files": [
    "tests/config/executable_dictionary.xml",
    "b/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.reference",
    "b/tests/queries/0_stateless/01674_executable_dictionary_implicit_key.sql",
    "tests/queries/0_stateless/arcadia_skip_list.txt"
  ]
}