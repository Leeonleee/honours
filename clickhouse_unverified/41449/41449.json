{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 41449,
  "instance_id": "ClickHouse__ClickHouse-41449",
  "issue_numbers": [
    "41443"
  ],
  "base_commit": "bac578b23a2b326ac88a53c232c96a3a8b795a2c",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.cpp b/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.cpp\nindex 35654c08659d..99ffc87e076e 100644\n--- a/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.cpp\n@@ -1,12 +1,18 @@\n-#include <AggregateFunctions/AggregateFunctionCategoricalInformationValue.h>\n-\n+#include <AggregateFunctions/IAggregateFunction.h>\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <AggregateFunctions/FactoryHelpers.h>\n #include <AggregateFunctions/Helpers.h>\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n \n \n namespace DB\n {\n+\n struct Settings;\n \n namespace ErrorCodes\n@@ -15,6 +21,136 @@ namespace ErrorCodes\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n+/** The function takes arguments x1, x2, ... xn, y. All arguments are bool.\n+  * x arguments represents the fact that some category is true.\n+  *\n+  * It calculates how many times y was true and how many times y was false when every n-th category was true\n+  * and the total number of times y was true and false.\n+  *\n+  * So, the size of the state is (n + 1) * 2 cells.\n+  */\n+class AggregateFunctionCategoricalIV final : public IAggregateFunctionHelper<AggregateFunctionCategoricalIV>\n+{\n+private:\n+    using Counter = UInt64;\n+    size_t category_count;\n+\n+    Counter & counter(AggregateDataPtr __restrict place, size_t i, bool what) const\n+    {\n+        return reinterpret_cast<Counter *>(place)[i * 2 + (what ? 1 : 0)];\n+    }\n+\n+    const Counter & counter(ConstAggregateDataPtr __restrict place, size_t i, bool what) const\n+    {\n+        return reinterpret_cast<const Counter *>(place)[i * 2 + (what ? 1 : 0)];\n+    }\n+\n+public:\n+    AggregateFunctionCategoricalIV(const DataTypes & arguments_, const Array & params_) :\n+        IAggregateFunctionHelper<AggregateFunctionCategoricalIV>{arguments_, params_},\n+        category_count{arguments_.size() - 1}\n+    {\n+        // notice: argument types has been checked before\n+    }\n+\n+    String getName() const override\n+    {\n+        return \"categoricalInformationValue\";\n+    }\n+\n+    bool allocatesMemoryInArena() const override { return false; }\n+\n+    void create(AggregateDataPtr __restrict place) const override\n+    {\n+        memset(place, 0, sizeOfData());\n+    }\n+\n+    void destroy(AggregateDataPtr __restrict) const noexcept override\n+    {\n+        // nothing\n+    }\n+\n+    bool hasTrivialDestructor() const override\n+    {\n+        return true;\n+    }\n+\n+    size_t sizeOfData() const override\n+    {\n+        return sizeof(Counter) * (category_count + 1) * 2;\n+    }\n+\n+    size_t alignOfData() const override\n+    {\n+        return alignof(Counter);\n+    }\n+\n+    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override\n+    {\n+        const auto * y_col = static_cast<const ColumnUInt8 *>(columns[category_count]);\n+        bool y = y_col->getData()[row_num];\n+\n+        for (size_t i = 0; i < category_count; ++i)\n+        {\n+            const auto * x_col = static_cast<const ColumnUInt8 *>(columns[i]);\n+            bool x = x_col->getData()[row_num];\n+\n+            if (x)\n+                ++counter(place, i, y);\n+        }\n+\n+        ++counter(place, category_count, y);\n+    }\n+\n+    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override\n+    {\n+        for (size_t i = 0; i <= category_count; ++i)\n+        {\n+            counter(place, i, false) += counter(rhs, i, false);\n+            counter(place, i, true) += counter(rhs, i, true);\n+        }\n+    }\n+\n+    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override\n+    {\n+        buf.write(place, sizeOfData());\n+    }\n+\n+    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version */, Arena *) const override\n+    {\n+        buf.read(place, sizeOfData());\n+    }\n+\n+    DataTypePtr getReturnType() const override\n+    {\n+        return std::make_shared<DataTypeArray>(\n+            std::make_shared<DataTypeNumber<Float64>>());\n+    }\n+\n+    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override /// NOLINT\n+    {\n+        auto & col = static_cast<ColumnArray &>(to);\n+        auto & data_col = static_cast<ColumnFloat64 &>(col.getData());\n+        auto & offset_col = static_cast<ColumnArray::ColumnOffsets &>(col.getOffsetsColumn());\n+\n+        data_col.reserve(data_col.size() + category_count);\n+\n+        Float64 sum_no = static_cast<Float64>(counter(place, category_count, false));\n+        Float64 sum_yes = static_cast<Float64>(counter(place, category_count, true));\n+\n+        for (size_t i = 0; i < category_count; ++i)\n+        {\n+            Float64 no = static_cast<Float64>(counter(place, i, false));\n+            Float64 yes = static_cast<Float64>(counter(place, i, true));\n+\n+            data_col.insertValue((no / sum_no - yes / sum_yes) * (log((no / sum_no) / (yes / sum_yes))));\n+        }\n+\n+        offset_col.insertValue(data_col.size());\n+    }\n+};\n+\n+\n namespace\n {\n \n@@ -39,16 +175,15 @@ AggregateFunctionPtr createAggregateFunctionCategoricalIV(\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n     }\n \n-    return std::make_shared<AggregateFunctionCategoricalIV<>>(arguments, params);\n+    return std::make_shared<AggregateFunctionCategoricalIV>(arguments, params);\n }\n \n }\n \n-void registerAggregateFunctionCategoricalIV(\n-    AggregateFunctionFactory & factory\n-)\n+void registerAggregateFunctionCategoricalIV(AggregateFunctionFactory & factory)\n {\n-    factory.registerFunction(\"categoricalInformationValue\", createAggregateFunctionCategoricalIV);\n+    AggregateFunctionProperties properties = { .returns_default_when_only_null = true };\n+    factory.registerFunction(\"categoricalInformationValue\", { createAggregateFunctionCategoricalIV, properties });\n }\n \n }\ndiff --git a/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h b/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h\ndeleted file mode 100644\nindex 0e0db27cf22f..000000000000\n--- a/src/AggregateFunctions/AggregateFunctionCategoricalInformationValue.h\n+++ /dev/null\n@@ -1,135 +0,0 @@\n-#pragma once\n-\n-#include <AggregateFunctions/IAggregateFunction.h>\n-#include <Columns/ColumnArray.h>\n-#include <Columns/ColumnsNumber.h>\n-#include <DataTypes/DataTypeArray.h>\n-#include <DataTypes/DataTypesNumber.h>\n-#include <IO/ReadHelpers.h>\n-#include <IO/WriteHelpers.h>\n-\n-#include <base/range.h>\n-\n-\n-namespace DB\n-{\n-struct Settings;\n-\n-template <typename T = UInt64>\n-class AggregateFunctionCategoricalIV final : public IAggregateFunctionHelper<AggregateFunctionCategoricalIV<T>>\n-{\n-private:\n-    size_t category_count;\n-\n-public:\n-    AggregateFunctionCategoricalIV(const DataTypes & arguments_, const Array & params_) :\n-        IAggregateFunctionHelper<AggregateFunctionCategoricalIV<T>> {arguments_, params_},\n-        category_count {arguments_.size() - 1}\n-    {\n-        // notice: argument types has been checked before\n-    }\n-\n-    String getName() const override\n-    {\n-        return \"categoricalInformationValue\";\n-    }\n-\n-    bool allocatesMemoryInArena() const override { return false; }\n-\n-    void create(AggregateDataPtr __restrict place) const override\n-    {\n-        memset(place, 0, sizeOfData());\n-    }\n-\n-    void destroy(AggregateDataPtr __restrict) const noexcept override\n-    {\n-        // nothing\n-    }\n-\n-    bool hasTrivialDestructor() const override\n-    {\n-        return true;\n-    }\n-\n-    size_t sizeOfData() const override\n-    {\n-        return sizeof(T) * (category_count + 1) * 2;\n-    }\n-\n-    size_t alignOfData() const override\n-    {\n-        return alignof(T);\n-    }\n-\n-    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override\n-    {\n-        const auto * y_col = static_cast<const ColumnUInt8 *>(columns[category_count]);\n-        bool y = y_col->getData()[row_num];\n-\n-        for (size_t i : collections::range(0, category_count))\n-        {\n-            const auto * x_col = static_cast<const ColumnUInt8 *>(columns[i]);\n-            bool x = x_col->getData()[row_num];\n-\n-            if (x)\n-                reinterpret_cast<T *>(place)[i * 2 + size_t(y)] += 1;\n-        }\n-\n-        reinterpret_cast<T *>(place)[category_count * 2 + size_t(y)] += 1;\n-    }\n-\n-    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override\n-    {\n-        for (size_t i : collections::range(0, category_count + 1))\n-        {\n-            reinterpret_cast<T *>(place)[i * 2] += reinterpret_cast<const T *>(rhs)[i * 2];\n-            reinterpret_cast<T *>(place)[i * 2 + 1] += reinterpret_cast<const T *>(rhs)[i * 2 + 1];\n-        }\n-    }\n-\n-    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf, std::optional<size_t> /* version */) const override\n-    {\n-        buf.write(place, sizeOfData());\n-    }\n-\n-    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, std::optional<size_t> /* version */, Arena *) const override\n-    {\n-        buf.read(place, sizeOfData());\n-    }\n-\n-    DataTypePtr getReturnType() const override\n-    {\n-        return std::make_shared<DataTypeArray>(\n-            std::make_shared<DataTypeNumber<Float64>>()\n-        );\n-    }\n-\n-    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override /// NOLINT\n-    {\n-        auto & col = static_cast<ColumnArray &>(to);\n-        auto & data_col = static_cast<ColumnFloat64 &>(col.getData());\n-        auto & offset_col = static_cast<ColumnArray::ColumnOffsets &>(\n-            col.getOffsetsColumn()\n-        );\n-\n-        data_col.reserve(data_col.size() + category_count);\n-\n-        T sum_no = reinterpret_cast<const T *>(place)[category_count * 2];\n-        T sum_yes = reinterpret_cast<const T *>(place)[category_count * 2 + 1];\n-\n-        Float64 rev_no = 1. / sum_no;\n-        Float64 rev_yes = 1. / sum_yes;\n-\n-        for (size_t i : collections::range(0, category_count))\n-        {\n-            T no = reinterpret_cast<const T *>(place)[i * 2];\n-            T yes = reinterpret_cast<const T *>(place)[i * 2 + 1];\n-\n-            data_col.insertValue((no * rev_no - yes * rev_yes) * (log(no * rev_no) - log(yes * rev_yes)));\n-        }\n-\n-        offset_col.insertValue(data_col.size());\n-    }\n-};\n-\n-}\ndiff --git a/src/DataTypes/Serializations/SerializationArray.cpp b/src/DataTypes/Serializations/SerializationArray.cpp\nindex abd99038e980..75c4c01ac9a2 100644\n--- a/src/DataTypes/Serializations/SerializationArray.cpp\n+++ b/src/DataTypes/Serializations/SerializationArray.cpp\n@@ -174,7 +174,7 @@ namespace\n         {\n             auto current_offset = offsets_data[i];\n             sizes_data[i] = current_offset - prev_offset;\n-            prev_offset =  current_offset;\n+            prev_offset = current_offset;\n         }\n \n         return column_sizes;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02425_categorical_information_value_properties.reference b/tests/queries/0_stateless/02425_categorical_information_value_properties.reference\nnew file mode 100644\nindex 000000000000..bc3af98b0603\n--- /dev/null\n+++ b/tests/queries/0_stateless/02425_categorical_information_value_properties.reference\n@@ -0,0 +1,12 @@\n+0.347\n+0.5\n+0.347\n+0.347\n+[nan]\n+[nan]\n+[nan]\n+[nan]\n+[0]\n+\\N\n+[nan]\n+[0,0]\ndiff --git a/tests/queries/0_stateless/02425_categorical_information_value_properties.sql b/tests/queries/0_stateless/02425_categorical_information_value_properties.sql\nnew file mode 100644\nindex 000000000000..81ed84006809\n--- /dev/null\n+++ b/tests/queries/0_stateless/02425_categorical_information_value_properties.sql\n@@ -0,0 +1,14 @@\n+SELECT round(arrayJoin(categoricalInformationValue(x.1, x.2)), 3) FROM (SELECT arrayJoin([(0, 0), (NULL, 2), (1, 0), (1, 1)]) AS x);\n+SELECT corr(c1, c2) FROM VALUES((0, 0), (NULL, 2), (1, 0), (1, 1));\n+SELECT round(arrayJoin(categoricalInformationValue(c1, c2)), 3) FROM VALUES((0, 0), (NULL, 2), (1, 0), (1, 1));\n+SELECT round(arrayJoin(categoricalInformationValue(c1, c2)), 3) FROM VALUES((0, 0), (NULL, 1), (1, 0), (1, 1));\n+SELECT categoricalInformationValue(c1, c2) FROM VALUES((0, 0), (NULL, 1));\n+SELECT categoricalInformationValue(c1, c2) FROM VALUES((NULL, 1)); -- { serverError 43 }\n+SELECT categoricalInformationValue(dummy, dummy);\n+SELECT categoricalInformationValue(dummy, dummy) WHERE 0;\n+SELECT categoricalInformationValue(c1, c2) FROM VALUES((toNullable(0), 0));\n+SELECT groupUniqArray(*) FROM VALUES(toNullable(0));\n+SELECT groupUniqArray(*) FROM VALUES(NULL);\n+SELECT categoricalInformationValue(c1, c2) FROM VALUES((NULL, NULL)); -- { serverError 43 }\n+SELECT categoricalInformationValue(c1, c2) FROM VALUES((0, 0), (NULL, 0));\n+SELECT quantiles(0.5, 0.9)(c1) FROM VALUES(0::Nullable(UInt8));\n",
  "problem_statement": "Crash in `categorialInformationValue` function\n```\r\nSELECT categoricalInformationValue(x.1, x.2) FROM (SELECT arrayJoin([(0, 0), (NULL, 2), (1, 0), (1, 1)]) AS x)\r\n```\n",
  "hints_text": "",
  "created_at": "2022-09-17T23:23:27Z"
}