{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 83833,
  "instance_id": "ClickHouse__ClickHouse-83833",
  "issue_numbers": [
    "81889"
  ],
  "base_commit": "bf90c66b6735611e7e5534e03e48a06411f39a73",
  "patch": "diff --git a/src/Storages/MergeTree/MergeTreeSettings.cpp b/src/Storages/MergeTree/MergeTreeSettings.cpp\nindex f41618311b73..6eb38807d752 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSettings.cpp\n@@ -2324,6 +2324,17 @@ void MergeTreeSettings::dumpToSystemMergeTreeSettingsColumns(MutableColumnsAndCo\n     }\n }\n \n+void MergeTreeSettings::dumpToSystemCompletionsColumns(MutableColumns & res_columns) const\n+{\n+    static constexpr const char * MERGE_TREE_SETTING_CONTEXT = \"merge tree setting\";\n+    for (const auto & setting : impl->all())\n+    {\n+        const auto & setting_name = setting.getName();\n+        res_columns[0]->insert(setting_name);\n+        res_columns[1]->insert(MERGE_TREE_SETTING_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n \n namespace\n {\ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.h b/src/Storages/MergeTree/MergeTreeSettings.h\nindex 6555b2690cec..bdeb6d98272a 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.h\n+++ b/src/Storages/MergeTree/MergeTreeSettings.h\n@@ -6,6 +6,7 @@\n #include <Core/SettingsFields.h>\n #include <base/types.h>\n #include <Common/SettingsChanges.h>\n+#include <Columns/IColumn_fwd.h>\n \n namespace boost\n {\n@@ -81,6 +82,7 @@ struct MergeTreeSettings\n     void sanityCheck(size_t background_pool_tasks, bool allow_experimental, bool allow_beta) const;\n \n     void dumpToSystemMergeTreeSettingsColumns(MutableColumnsAndConstraints & params) const;\n+    void dumpToSystemCompletionsColumns(MutableColumns & columns) const;\n \n     void addToProgramOptionsIfNotPresent(boost::program_options::options_description & main_options, bool allow_repeated_settings);\n \ndiff --git a/src/Storages/System/StorageSystemCompletions.cpp b/src/Storages/System/StorageSystemCompletions.cpp\nnew file mode 100644\nindex 000000000000..16bdee3ff29d\n--- /dev/null\n+++ b/src/Storages/System/StorageSystemCompletions.cpp\n@@ -0,0 +1,317 @@\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <Access/ContextAccess.h>\n+#include <Columns/ColumnString.h>\n+#include <Common/Macros.h>\n+#include <Core/Settings.h>\n+#include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <Databases/IDatabase.h>\n+#include <Dictionaries/IDictionary.h>\n+#include <Dictionaries/IDictionarySource.h>\n+#include <Dictionaries/DictionaryStructure.h>\n+#include <Formats/FormatFactory.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/UserDefined/UserDefinedSQLFunctionFactory.h>\n+#include <Functions/UserDefined/UserDefinedExecutableFunctionFactory.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/DatabaseCatalog.h>\n+#include <Interpreters/ExternalDictionariesLoader.h>\n+#include <Parsers/CommonParsers.h>\n+#include <Storages/System/StorageSystemCompletions.h>\n+#include <Storages/StorageFactory.h>\n+#include <Storages/MergeTree/MergeTreeSettings.h>\n+#include <TableFunctions/TableFunctionFactory.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace Setting\n+{\n+    extern const SettingsUInt64 readonly;\n+    extern const SettingsSeconds lock_acquire_timeout;\n+}\n+\n+static constexpr const char * DATABASE_CONTEXT = \"database\";\n+static constexpr const char * TABLE_CONTEXT = \"table\";\n+static constexpr const char * COLUMN_CONTEXT = \"column\";\n+static constexpr const char * FUNCTION_CONTEXT = \"function\";\n+static constexpr const char * TABLE_ENGINE_CONTEXT = \"table engine\";\n+static constexpr const char * FORMAT_CONTEXT = \"format\";\n+static constexpr const char * TABLE_FUNCTION_CONTEXT = \"table function\";\n+static constexpr const char * DATA_TYPE_CONTEXT = \"data type\";\n+static constexpr const char * SETTING_CONTEXT = \"setting\";\n+static constexpr const char * KEYWORD_CONTEXT = \"keyword\";\n+static constexpr const char * CLUSTER_CONTEXT = \"cluster\";\n+static constexpr const char * MACRO_CONTEXT = \"macro\";\n+static constexpr const char * POLICY_CONTEXT = \"policy\";\n+static constexpr const char * DICTIONARY_CONTEXT = \"dictionary\";\n+\n+ColumnsDescription StorageSystemCompletions::getColumnsDescription()\n+{\n+    auto description = ColumnsDescription\n+    {\n+        {\"word\", std::make_shared<DataTypeString>(), \"Completion token.\"},\n+        {\"context\", std::make_shared<DataTypeString>(), \"Token entity kind (e.g. table).\"},\n+        {\"belongs\", std::make_shared<DataTypeNullable>(std::make_shared<DataTypeString>()), \"Token for entity, this token belongs to (e.g. name of owning database).\"}\n+    };\n+    return description;\n+}\n+\n+void fillDataWithTableColumns(const String & database_name, const String & table_name, const StoragePtr & table, MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & access = context->getAccess();\n+    if (!access->isGranted(AccessType::SHOW_TABLES) || !access->isGranted(AccessType::SHOW_TABLES, database_name) || !access->isGranted(AccessType::SHOW_TABLES, database_name, table_name))\n+        return;\n+\n+    if (!table)\n+        return; // table was dropped or deleted, while adding columns for previous table\n+\n+    res_columns[0]->insert(table_name);\n+    res_columns[1]->insert(TABLE_CONTEXT);\n+    res_columns[2]->insert(database_name);\n+\n+    if (!access->isGranted(AccessType::SHOW_COLUMNS) || !access->isGranted(AccessType::SHOW_COLUMNS, database_name, table_name))\n+        return;\n+\n+    auto table_lock = table->tryLockForShare(context->getCurrentQueryId(), context->getSettingsRef()[Setting::lock_acquire_timeout]);\n+    if (table_lock == nullptr)\n+        return; // table was dropped while acquiring the lock\n+\n+    const auto & snapshot = table->getInMemoryMetadataPtr();\n+    const auto & columns = snapshot->getColumns();\n+    for (const auto & column : columns)\n+    {\n+        if (!access->isGranted(AccessType::SHOW_COLUMNS, database_name, table_name, column.name))\n+            continue;\n+\n+        res_columns[0]->insert(column.name);\n+        res_columns[1]->insert(COLUMN_CONTEXT);\n+        res_columns[2]->insert(table_name);\n+    }\n+}\n+\n+void fillDataWithDatabasesTablesColumns(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & access = context->getAccess();\n+    const auto & databases = DatabaseCatalog::instance().getDatabases();\n+    for (const auto & [database_name, database_ptr] : databases)\n+    {\n+        if (!access->isGranted(AccessType::SHOW_DATABASES) || !access->isGranted(AccessType::SHOW_DATABASES, database_name))\n+            continue;\n+\n+        if (database_name == DatabaseCatalog::TEMPORARY_DATABASE)\n+            continue; // skipping internal database temporary tables\n+\n+        res_columns[0]->insert(database_name);\n+        res_columns[1]->insert(DATABASE_CONTEXT);\n+        res_columns[2]->insertDefault();\n+\n+        /// We are skipping \"Lazy\" database because we cannot afford initialization of all its tables.\n+        if (database_ptr->getEngineName() == \"Lazy\")\n+            continue;\n+\n+        for (auto iterator = database_ptr->getLightweightTablesIterator(context); iterator->isValid(); iterator->next())\n+        {\n+            const auto & table_name = iterator->name();\n+            const auto & table = iterator->table();\n+            fillDataWithTableColumns(database_name, table_name, table, res_columns, context);\n+        }\n+\n+    }\n+\n+    if (context->hasSessionContext())\n+    {\n+        Tables external_tables = context->getSessionContext()->getExternalTables();\n+        for (auto & [table_name, table] : external_tables)\n+        {\n+            const String database_name(1, '\\0');\n+            fillDataWithTableColumns(database_name, table_name, table, res_columns, context);\n+        }\n+    }\n+}\n+\n+void fillDataWithFunctions(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    auto insert_function = [&](const String & name)\n+    {\n+        res_columns[0]->insert(name);\n+        res_columns[1]->insert(FUNCTION_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    };\n+    const auto & functions_factory = FunctionFactory::instance();\n+    const auto & function_names = functions_factory.getAllRegisteredNames();\n+    for (const auto & function_name : function_names)\n+        insert_function(function_name);\n+    const auto & aggregate_functions_factory = AggregateFunctionFactory::instance();\n+    const auto & aggregate_function_names = aggregate_functions_factory.getAllRegisteredNames();\n+    for (const auto & function_name : aggregate_function_names)\n+        insert_function(function_name);\n+    const auto & user_defined_function_names = UserDefinedExecutableFunctionFactory::getRegisteredNames(context);\n+    for (const auto & function_name : user_defined_function_names)\n+        insert_function(function_name);\n+}\n+\n+void fillDataWithTableEngines(MutableColumns & res_columns)\n+{\n+    const auto & storage_factory = StorageFactory::instance();\n+    const auto & table_engines = storage_factory.getAllStorages();\n+    for (const auto & [table_engine_name, _] : table_engines)\n+    {\n+        res_columns[0]->insert(table_engine_name);\n+        res_columns[1]->insert(TABLE_ENGINE_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithFormats(MutableColumns & res_columns)\n+{\n+    const auto & format_factory = FormatFactory::instance();\n+    const auto & formats = format_factory.getAllFormats();\n+    for (const auto & [format_name, _] : formats)\n+    {\n+        res_columns[0]->insert(format_name);\n+        res_columns[1]->insert(FORMAT_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithTableFunctions(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    bool non_readonly_allowed = context->getSettingsRef()[Setting::readonly] == 0;\n+    const auto & table_functions_factory = TableFunctionFactory::instance();\n+    const auto & table_functions = table_functions_factory.getAllRegisteredNames();\n+    for (const auto & function_name : table_functions)\n+    {\n+        auto properties = table_functions_factory.tryGetProperties(function_name);\n+        if ((non_readonly_allowed) || (properties && properties->allow_readonly))\n+        {\n+            res_columns[0]->insert(function_name);\n+            res_columns[1]->insert(TABLE_FUNCTION_CONTEXT);\n+            res_columns[2]->insertDefault();\n+        }\n+    }\n+}\n+\n+void fillDataWithDataTypeFamilies(MutableColumns & res_columns)\n+{\n+    const auto & data_type_factory = DataTypeFactory::instance();\n+    const auto & data_type_names = data_type_factory.getAllRegisteredNames();\n+    for (const auto & data_type_name : data_type_names)\n+    {\n+        res_columns[0]->insert(data_type_name);\n+        res_columns[1]->insert(DATA_TYPE_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithMergeTreeSettings(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & merge_tree_settings = context->getMergeTreeSettings();\n+    const auto & replicated_merge_tree_settings = context->getReplicatedMergeTreeSettings();\n+    merge_tree_settings.dumpToSystemCompletionsColumns(res_columns);\n+    replicated_merge_tree_settings.dumpToSystemCompletionsColumns(res_columns);\n+}\n+\n+void fillDataWithSettings(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & settings = context->getSettingsRef();\n+    const auto & setting_names = settings.getAllRegisteredNames();\n+    for (const auto & setting_name : setting_names)\n+    {\n+        res_columns[0]->insert(setting_name);\n+        res_columns[1]->insert(SETTING_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithKeywords(MutableColumns & res_columns)\n+{\n+    for (const auto & keyword : getAllKeyWords())\n+    {\n+        res_columns[0]->insert(keyword);\n+        res_columns[1]->insert(KEYWORD_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithClusters(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & clusters = context->getClusters();\n+    for (const auto & [cluster_name, _] : clusters)\n+    {\n+        res_columns[0]->insert(cluster_name);\n+        res_columns[1]->insert(CLUSTER_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithMacros(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & macros = context->getMacros();\n+    for (const auto & [macro_name, _] : macros->getMacroMap())\n+    {\n+        res_columns[0]->insert(macro_name);\n+        res_columns[1]->insert(MACRO_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithPolicies(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    for (const auto & [policy_name, _] : context->getPoliciesMap())\n+    {\n+        res_columns[0]->insert(policy_name);\n+        res_columns[1]->insert(POLICY_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void fillDataWithDictionaries(MutableColumns & res_columns, const ContextPtr & context)\n+{\n+    const auto & access = context->getAccess();\n+    if (access->isGranted(AccessType::SHOW_DICTIONARIES))\n+        return;\n+\n+    const auto & external_dictionaries = context->getExternalDictionariesLoader();\n+    for (const auto & load_result : external_dictionaries.getLoadResults())\n+    {\n+        const auto dict_ptr = std::dynamic_pointer_cast<const IDictionary>(load_result.object);\n+\n+        StorageID dict_id = StorageID::createEmpty();\n+        if (dict_ptr)\n+            dict_id = dict_ptr->getDictionaryID();\n+        else if (load_result.config)\n+            dict_id = StorageID::fromDictionaryConfig(*load_result.config->config, load_result.config->key_in_config);\n+        else\n+            dict_id.table_name = load_result.name;\n+\n+        String db_or_tag = dict_id.database_name.empty() ? IDictionary::NO_DATABASE_TAG : dict_id.database_name;\n+        if (!access->isGranted(AccessType::SHOW_DICTIONARIES, db_or_tag, dict_id.table_name))\n+            continue;\n+        res_columns[0]->insert(dict_id.table_name);\n+        res_columns[1]->insert(DICTIONARY_CONTEXT);\n+        res_columns[2]->insertDefault();\n+    }\n+}\n+\n+void StorageSystemCompletions::fillData(MutableColumns & res_columns, ContextPtr context, const ActionsDAG::Node *, std::vector<UInt8>) const\n+{\n+    fillDataWithDatabasesTablesColumns(res_columns, context);\n+    fillDataWithFunctions(res_columns, context);\n+    fillDataWithTableEngines(res_columns);\n+    fillDataWithFormats(res_columns);\n+    fillDataWithTableFunctions(res_columns, context);\n+    fillDataWithDataTypeFamilies(res_columns);\n+    fillDataWithMergeTreeSettings(res_columns, context);\n+    fillDataWithSettings(res_columns, context);\n+    fillDataWithKeywords(res_columns);\n+    fillDataWithClusters(res_columns, context);\n+    fillDataWithMacros(res_columns, context);\n+    fillDataWithPolicies(res_columns, context);\n+    fillDataWithDictionaries(res_columns, context);\n+}\n+\n+}\ndiff --git a/src/Storages/System/StorageSystemCompletions.h b/src/Storages/System/StorageSystemCompletions.h\nnew file mode 100644\nindex 000000000000..1549db233ce6\n--- /dev/null\n+++ b/src/Storages/System/StorageSystemCompletions.h\n@@ -0,0 +1,27 @@\n+#pragma once\n+\n+#include <Storages/System/IStorageSystemOneBlock.h>\n+\n+namespace DB\n+{\n+\n+class Context;\n+\n+/** Implements `completions` system table, which lists all unique terms (e.g. database names, table names, functions..),\n+ * accessible to the current user to power auto-completion.\n+ */\n+class StorageSystemCompletions final : public IStorageSystemOneBlock\n+{\n+public:\n+    std::string getName() const override\n+    {\n+        return \"SystemCompletions\";\n+    }\n+\n+    static ColumnsDescription getColumnsDescription();\n+protected:\n+    using IStorageSystemOneBlock::IStorageSystemOneBlock;\n+    void fillData(MutableColumns & res_columns, ContextPtr context, const ActionsDAG::Node * predicate, std::vector<UInt8> columns_mask) const override;\n+};\n+\n+}\ndiff --git a/src/Storages/System/attachSystemTables.cpp b/src/Storages/System/attachSystemTables.cpp\nindex 3e9a0c804e1c..076a32a17810 100644\n--- a/src/Storages/System/attachSystemTables.cpp\n+++ b/src/Storages/System/attachSystemTables.cpp\n@@ -14,6 +14,7 @@\n #include <Storages/System/StorageSystemClusters.h>\n #include <Storages/System/StorageSystemColumns.h>\n #include <Storages/System/StorageSystemCodecs.h>\n+#include <Storages/System/StorageSystemCompletions.h>\n #include <Storages/System/StorageSystemDatabases.h>\n #include <Storages/System/StorageSystemDataSkippingIndices.h>\n #include <Storages/System/StorageSystemDataTypeFamilies.h>\n@@ -252,6 +253,7 @@ void attachSystemTablesServer(ContextPtr context, IDatabase & system_database, b\n \n     attach<StorageSystemLatencyBuckets>(context, system_database, \"latency_buckets\", \"Contains buckets bounds used by latency log.\");\n     attach<StorageSystemCodecs>(context, system_database, \"codecs\", \"Contains information about system codecs.\");\n+    attach<StorageSystemCompletions>(context, system_database, \"completions\", \"Contains a list of completion tokens.\");\n }\n \n void attachSystemTablesAsync(ContextPtr context, IDatabase & system_database, AsynchronousMetrics & async_metrics)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03566_system_completions_table.reference b/tests/queries/0_stateless/03566_system_completions_table.reference\nnew file mode 100644\nindex 000000000000..d03e56242d1d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03566_system_completions_table.reference\n@@ -0,0 +1,7 @@\n+   \u250c\u2500word\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500context\u2500\u2500\u252c\u2500belongs\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+1. \u2502 0003566aaabar      \u2502 column   \u2502 0003566aaatable    \u2502\n+2. \u2502 0003566aaabaz      \u2502 column   \u2502 0003566aaatable    \u2502\n+3. \u2502 0003566aaadatabase \u2502 database \u2502 \u1d3a\u1d41\u1d38\u1d38               \u2502\n+4. \u2502 0003566aaafoo      \u2502 column   \u2502 0003566aaatable    \u2502\n+5. \u2502 0003566aaatable    \u2502 table    \u2502 0003566aaadatabase \u2502\n+   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\ndiff --git a/tests/queries/0_stateless/03566_system_completions_table.sql b/tests/queries/0_stateless/03566_system_completions_table.sql\nnew file mode 100644\nindex 000000000000..91b990cf0c80\n--- /dev/null\n+++ b/tests/queries/0_stateless/03566_system_completions_table.sql\n@@ -0,0 +1,15 @@\n+CREATE DATABASE IF NOT EXISTS `0003566aaadatabase`;\n+USE `0003566aaadatabase`;\n+\n+CREATE TABLE IF NOT EXISTS `0003566aaatable` (\n+    `0003566aaafoo`     String,\n+    `0003566aaabar`     UInt16,\n+    `0003566aaabaz`     UInt128\n+) ENGINE = Memory;\n+\n+SELECT *\n+FROM system.completions\n+WHERE startsWith(word, '0003566')\n+ORDER BY word\n+LIMIT 5\n+FORMAT PrettyCompact;\n",
  "problem_statement": "A new system table, `completions`\n### Company or project name\n\nClickHouse\n\n### Use case\n\nSolve completions in clickhouse-client:\n- in a more elegant way;\n- make it easier to extend;\n- provide completion info for third-party tools;\n- solve potential problems in compatibility;\n\n### Describe the solution you'd like\n\nA system table containing one column, `word String`.\nThe contents of this table depend on the context (access, settings).\nIt is filled similarly to what happens in Suggest.h, but on a lower level, without interpreting and running queries.\n\n### Describe alternatives you've considered\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "```\nSELECT * FROM system.completions WHERE prompt = 'xxxxx|'\n```\n\nWill return list of possible completions from `Suggest.h` with weights? \nNo, the client will just fetch the whole table. All matching is in-process.",
  "created_at": "2025-07-16T12:10:15Z",
  "modified_files": [
    "src/Storages/MergeTree/MergeTreeSettings.cpp",
    "src/Storages/MergeTree/MergeTreeSettings.h",
    "b/src/Storages/System/StorageSystemCompletions.cpp",
    "b/src/Storages/System/StorageSystemCompletions.h",
    "src/Storages/System/attachSystemTables.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03566_system_completions_table.reference",
    "b/tests/queries/0_stateless/03566_system_completions_table.sql"
  ]
}