{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58139,
  "instance_id": "ClickHouse__ClickHouse-58139",
  "issue_numbers": [
    "53190"
  ],
  "base_commit": "3cbd895ce1aedcd85f9bfa1bf1a7bec14293c16b",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex bef1e7b420a5..5a06c3630654 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1413,10 +1413,10 @@ inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuff\n template <>\n inline bool tryParseImpl<DataTypeDateTime>(DataTypeDateTime::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone, bool)\n {\n-    time_t tmp = 0;\n-    if (!tryReadDateTimeText(tmp, rb, *time_zone))\n+    time_t time = 0;\n+    if (!tryReadDateTimeText(time, rb, *time_zone))\n         return false;\n-    x = static_cast<UInt32>(tmp);\n+    convertFromTime<DataTypeDateTime>(x, time);\n     return true;\n }\n \n@@ -1697,7 +1697,6 @@ struct ConvertThroughParsing\n                                     break;\n                                 }\n                             }\n-\n                             parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone, precise_float_parsing);\n                         } while (false);\n                     }\n@@ -3291,7 +3290,6 @@ class FunctionCast final : public FunctionCastBase\n         {\n             /// In case when converting to Nullable type, we apply different parsing rule,\n             /// that will not throw an exception but return NULL in case of malformed input.\n-\n             FunctionPtr function = FunctionConvertFromString<ToDataType, FunctionName, ConvertFromStringExceptionMode::Null>::create();\n             return createFunctionAdaptor(function, from_type);\n         }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\nindex a2ccd5af8688..5187a19cc726 100644\n--- a/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.reference\n@@ -36,6 +36,8 @@\n 2023-05-30 14:38:20\n 1970-01-01 00:00:19\n 1970-01-01 19:26:40\n+1970-01-01 00:00:00\n+2106-02-07 06:28:15\n \\N\n \\N\n \\N\ndiff --git a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\nindex 2fb7b1177e61..15ac71dea93e 100644\n--- a/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n+++ b/tests/queries/0_stateless/01556_accurate_cast_or_null.sql\n@@ -39,9 +39,12 @@ SELECT accurateCastOrNull(number + 127, 'Int8') AS x FROM numbers (2) ORDER BY x\n SELECT accurateCastOrNull(-1, 'DateTime');\n SELECT accurateCastOrNull(5000000000, 'DateTime');\n SELECT accurateCastOrNull('1xxx', 'DateTime');\n-select toString(accurateCastOrNull('2023-05-30 14:38:20', 'DateTime'), timezone());\n+SELECT toString(accurateCastOrNull('2023-05-30 14:38:20', 'DateTime'), timezone());\n SELECT toString(accurateCastOrNull(19, 'DateTime'), 'UTC');\n SELECT toString(accurateCastOrNull(70000, 'DateTime'), 'UTC');\n+-- need fixed timezone in these two lines\n+SELECT toString(accurateCastOrNull('1965-05-30 14:38:20', 'DateTime'), timezone()) SETTINGS session_timezone = 'UTC';\n+SELECT toString(accurateCastOrNull('2223-05-30 14:38:20', 'DateTime'), timezone()) SETTINGS session_timezone = 'UTC';\n \n SELECT accurateCastOrNull(-1, 'Date');\n SELECT accurateCastOrNull(5000000000, 'Date');\n",
  "problem_statement": "No results when quering col > '1969' if table partitioned by that column\n**Describe what's wrong**\r\n\r\nDateTime condition comparing to the date before starting of the unix epoch stopped to work if the partitioning key uses that column.\r\n\r\n**Repro**\r\n\r\nhttps://fiddle.clickhouse.com/66a75ef0-c107-4ae1-83f4-ae608971bc9c\r\n\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nYes\r\n\r\n\r\n**How to reproduce**\r\n\r\n```sql\r\nDROP TABLE IF EXISTS test_ts;\r\n\r\nCREATE TABLE test_ts\r\n(\r\n    `id` UInt64,\r\n    `ts` DateTime\r\n)\r\nENGINE = MergeTree()\r\nPARTITION BY toYYYYMM(ts)\r\nORDER BY (id, ts);\r\n\r\nINSERT INTO test_ts VALUES (1, '2023-08-02 08:02:05');\r\n\r\nSELECT 'query 1';\r\n\r\nSELECT * FROM test_ts;\r\n\r\nSELECT 'query 2';\r\n\r\nSELECT * FROM test_ts WHERE ts >= '1969-07-01 00:00:00';\r\n```\r\n\r\nThat is a regression between 22.3 and 22.4\r\n\n",
  "hints_text": "Was probably affected by #35334 as a side effect\r\n\r\nActually, the real issue here is the following:\r\n```sql\r\nselect accurateCastOrNull('1969-07-01 12:12:12', 'DateTime')\r\n```\r\n\r\n```\r\n2105-08-07 18:40:28\r\n```\r\nWhich is neither accurate nor Null :)",
  "created_at": "2023-12-21T21:44:31Z"
}