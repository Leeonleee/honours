{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52635,
  "instance_id": "ClickHouse__ClickHouse-52635",
  "issue_numbers": [
    "52178"
  ],
  "base_commit": "c1ca0f35e7688d1a5e479768cd43d81f930243d3",
  "patch": "diff --git a/docs/en/operations/utilities/clickhouse-local.md b/docs/en/operations/utilities/clickhouse-local.md\nindex 0443a80cf177..0b17afb7e12d 100644\n--- a/docs/en/operations/utilities/clickhouse-local.md\n+++ b/docs/en/operations/utilities/clickhouse-local.md\n@@ -34,7 +34,13 @@ The binary you just downloaded can run all sorts of ClickHouse tools and utiliti\n \n A common use of `clickhouse-local` is to run ad-hoc queries on files: where you don't have to insert the data into a table. `clickhouse-local` can stream the data from a file into a temporary table and execute your SQL.\n \n-If the file is sitting on the same machine as `clickhouse-local`, use the `file` table engine. The following `reviews.tsv` file contains a sampling of Amazon product reviews:\n+If the file is sitting on the same machine as `clickhouse-local`, you can simple specify the file to load. The following `reviews.tsv` file contains a sampling of Amazon product reviews:\n+\n+```bash\n+./clickhouse local -q \"SELECT * FROM 'reviews.tsv'\"\n+```\n+\n+This command is a shortcut of:\n \n ```bash\n ./clickhouse local -q \"SELECT * FROM file('reviews.tsv')\"\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 0149526da79c..587908eb49c2 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -243,6 +243,38 @@ bool ParserIdentifier::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n }\n \n \n+bool ParserTableAsStringLiteralIdentifier::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    if (pos->type != TokenType::StringLiteral)\n+        return false;\n+\n+    ReadBufferFromMemory in(pos->begin, pos->size());\n+    String s;\n+\n+    if (!tryReadQuotedStringInto(s, in))\n+    {\n+        expected.add(pos, \"string literal\");\n+        return false;\n+    }\n+\n+    if (in.count() != pos->size())\n+    {\n+        expected.add(pos, \"string literal\");\n+        return false;\n+    }\n+\n+    if (s.empty())\n+    {\n+        expected.add(pos, \"non-empty string literal\");\n+        return false;\n+    }\n+\n+    node = std::make_shared<ASTTableIdentifier>(s);\n+    ++pos;\n+    return true;\n+}\n+\n+\n bool ParserCompoundIdentifier::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr id_list;\ndiff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h\nindex f33f2d99f713..2d06b26c6dce 100644\n--- a/src/Parsers/ExpressionElementParsers.h\n+++ b/src/Parsers/ExpressionElementParsers.h\n@@ -34,6 +34,19 @@ class ParserIdentifier : public IParserBase\n };\n \n \n+/** An identifier for tables written as string literal, for example, 'mytable.avro'\n+  */\n+class ParserTableAsStringLiteralIdentifier : public IParserBase\n+{\n+public:\n+    explicit ParserTableAsStringLiteralIdentifier() {}\n+\n+protected:\n+    const char * getName() const override { return \"string literal table identifier\"; }\n+    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+};\n+\n+\n /** An identifier, possibly containing a dot, for example, x_yz123 or `something special` or Hits.EventTime,\n  *  possibly with UUID clause like `db name`.`table name` UUID 'xxxxxxxx-xxxx-xxxx-xxxx-xxxxxxxxxxxx'\n   */\ndiff --git a/src/Parsers/ParserTablesInSelectQuery.cpp b/src/Parsers/ParserTablesInSelectQuery.cpp\nindex 08b6f77fafab..b3ae6ca0bb91 100644\n--- a/src/Parsers/ParserTablesInSelectQuery.cpp\n+++ b/src/Parsers/ParserTablesInSelectQuery.cpp\n@@ -24,6 +24,8 @@ bool ParserTableExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n     if (!ParserWithOptionalAlias(std::make_unique<ParserSubquery>(), allow_alias_without_as_keyword).parse(pos, res->subquery, expected)\n         && !ParserWithOptionalAlias(std::make_unique<ParserFunction>(false, true), allow_alias_without_as_keyword).parse(pos, res->table_function, expected)\n         && !ParserWithOptionalAlias(std::make_unique<ParserCompoundIdentifier>(true, true), allow_alias_without_as_keyword)\n+                .parse(pos, res->database_and_table_name, expected)\n+        && !ParserWithOptionalAlias(std::make_unique<ParserTableAsStringLiteralIdentifier>(), allow_alias_without_as_keyword)\n                 .parse(pos, res->database_and_table_name, expected))\n         return false;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02816_clickhouse_local_table_name_expressions.reference b/tests/queries/0_stateless/02816_clickhouse_local_table_name_expressions.reference\nnew file mode 100644\nindex 000000000000..1e3b82ac1363\n--- /dev/null\n+++ b/tests/queries/0_stateless/02816_clickhouse_local_table_name_expressions.reference\n@@ -0,0 +1,27 @@\n+Test 1: check double quotes\n+1\tabc\t123\tabacaba\n+2\tdef\t456\tbacabaa\n+3\tstory\t78912\tacabaab\n+4\thistory\t21321321\tcabaaba\n+Test 1a: check double quotes no parsing overflow\n+1\n+Test 1b: check double quotes empty\n+1\n+Test 2: check back quotes\n+1\tabc\t123\tabacaba\n+2\tdef\t456\tbacabaa\n+3\tstory\t78912\tacabaab\n+4\thistory\t21321321\tcabaaba\n+Test 2a: check back quotes no parsing overflow\n+1\n+Test 2b: check back quotes empty\n+1\n+Test 3: check literal\n+1\tabc\t123\tabacaba\n+2\tdef\t456\tbacabaa\n+3\tstory\t78912\tacabaab\n+4\thistory\t21321321\tcabaaba\n+Test 3a: check literal no parsing overflow\n+1\n+Test 3b: check literal empty\n+1\ndiff --git a/tests/queries/0_stateless/02816_clickhouse_local_table_name_expressions.sh b/tests/queries/0_stateless/02816_clickhouse_local_table_name_expressions.sh\nnew file mode 100755\nindex 000000000000..5cf3b1c88fd4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02816_clickhouse_local_table_name_expressions.sh\n@@ -0,0 +1,56 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+dir=${CLICKHOUSE_TEST_UNIQUE_NAME}\n+[[ -d $dir ]] && rm -rd $dir\n+mkdir $dir\n+\n+# Create temporary csv file for tests\n+echo '\"id\",\"str\",\"int\",\"text\"' > $dir/tmp.csv\n+echo '1,\"abc\",123,\"abacaba\"' >> $dir/tmp.csv\n+echo '2,\"def\",456,\"bacabaa\"' >> $dir/tmp.csv\n+echo '3,\"story\",78912,\"acabaab\"' >> $dir/tmp.csv\n+echo '4,\"history\",21321321,\"cabaaba\"' >> $dir/tmp.csv\n+\n+#################\n+echo \"Test 1: check double quotes\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM \\\"${dir}/tmp.csv\\\"\"\n+#################\n+echo \"Test 1a: check double quotes no parsing overflow\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM \\\"${dir}/tmp.csv\\\"\\\"bad\\\"\" 2>&1 | grep -c \"UNKNOWN_TABLE\"\n+#################\n+echo \"Test 1b: check double quotes empty\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM \\\"\\\"\" 2>&1 | grep -c \"SYNTAX_ERROR\"\n+#################\n+echo \"Test 2: check back quotes\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM \\`${dir}/tmp.csv\\`\"\n+#################\n+echo \"Test 2a: check back quotes no parsing overflow\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM \\`${dir}/tmp.csv\\`\\`bad\\`\" 2>&1 | grep -c \"UNKNOWN_TABLE\"\n+#################\n+echo \"Test 2b: check back quotes empty\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM \\`\\`\" 2>&1 | grep -c \"SYNTAX_ERROR\"\n+#################\n+echo \"Test 3: check literal\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM '${dir}/tmp.csv'\"\n+#################\n+echo \"Test 3a: check literal no parsing overflow\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM '${dir}/tmp.csv''bad'\" 2>&1 | grep -c \"SYNTAX_ERROR\"\n+#################\n+echo \"Test 3b: check literal empty\"\n+\n+$CLICKHOUSE_LOCAL -q \"SELECT * FROM ''\" 2>&1 | grep -c \"SYNTAX_ERROR\"\n+\n+# Remove temporary dir with files\n+rm -rd $dir\n",
  "problem_statement": "Allow writing table name as a string literal.\nCurrently, we allow writing table names as an identifier:\r\n\r\n```\r\nSELECT * FROM table\r\n```\r\n\r\nIdentifiers can be quoted in ANSI SQL style way:\r\n```\r\nSELECT * FROM \"table\"\r\n```\r\n\r\nAnd in MySQL style way:\r\n```\r\nSELECT * FROM `table`\r\n```\r\n\r\nRecently we started to recognize files as table names in clickhouse-local automatically:\r\n```\r\nSELECT * FROM \"dataset.avro\"\r\n```\r\n\r\nAnd clickhouse-local is often used in batch mode:\r\n```\r\nclickhouse-local --query \"SELECT * FROM table\"\r\n```\r\n\r\nBut if a query is specified in double quotes, as in the example above, using either double quotes or backticks for table name identifier is inconvenient:\r\n\r\n```\r\nclickhouse-local --query \"SELECT * FROM \\\"dataset.avro\\\"\"\r\n```\r\n\r\nAnd it will be better to allow table names as string literals:\r\n\r\n```\r\nclickhouse-local --query \"SELECT * FROM 'dataset.avro'\"\r\n```\r\n\r\nAlthough it could make some complications, such as the inability to specify a qualified name with a database name, we can only support a simple, unqualified form initially.\r\n\n",
  "hints_text": "",
  "created_at": "2023-07-26T21:19:48Z"
}