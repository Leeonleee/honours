{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 26235,
  "instance_id": "ClickHouse__ClickHouse-26235",
  "issue_numbers": [
    "11333",
    "25875"
  ],
  "base_commit": "10fc871de95eec8be158c43b277783f81ce3238d",
  "patch": "diff --git a/src/Functions/IFunction.h b/src/Functions/IFunction.h\nindex 58cdb68d1005..c00baf2850b1 100644\n--- a/src/Functions/IFunction.h\n+++ b/src/Functions/IFunction.h\n@@ -113,7 +113,8 @@ class IFunctionBase\n \n     virtual ~IFunctionBase() = default;\n \n-    virtual ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, bool dry_run = false) const\n+    virtual ColumnPtr execute(\n+        const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count, bool dry_run = false) const\n     {\n         return prepare(arguments)->execute(arguments, result_type, input_rows_count, dry_run);\n     }\n@@ -161,7 +162,8 @@ class IFunctionBase\n       * Arguments are passed without modifications, useDefaultImplementationForNulls, useDefaultImplementationForConstants,\n       * useDefaultImplementationForLowCardinality are not applied.\n       */\n-    virtual ColumnPtr getConstantResultForNonConstArguments(const ColumnsWithTypeAndName & /* arguments */, const DataTypePtr & /* result_type */) const { return nullptr; }\n+    virtual ColumnPtr getConstantResultForNonConstArguments(\n+        const ColumnsWithTypeAndName & /* arguments */, const DataTypePtr & /* result_type */) const { return nullptr; }\n \n     /** Function is called \"injective\" if it returns different result for different values of arguments.\n       * Example: hex, negate, tuple...\ndiff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 1518706f0a64..63b0345b3727 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -26,6 +26,7 @@ namespace ErrorCodes\n     extern const int THERE_IS_NO_COLUMN;\n     extern const int ILLEGAL_COLUMN;\n     extern const int NOT_FOUND_COLUMN_IN_BLOCK;\n+    extern const int BAD_ARGUMENTS;\n }\n \n const char * ActionsDAG::typeToString(ActionsDAG::ActionType type)\n@@ -202,6 +203,7 @@ const ActionsDAG::Node & ActionsDAG::addFunction(\n     node.function_base = function->build(arguments);\n     node.result_type = node.function_base->getResultType();\n     node.function = node.function_base->prepare(arguments);\n+    node.is_deterministic = node.function_base->isDeterministic();\n \n     /// If all arguments are constants, and function is suitable to be executed in 'prepare' stage - execute function.\n     if (node.function_base->isSuitableForConstantFolding())\n@@ -426,6 +428,16 @@ void ActionsDAG::removeUnusedActions(bool allow_remove_inputs)\n         {\n             /// Constant folding.\n             node->type = ActionsDAG::ActionType::COLUMN;\n+\n+            for (const auto & child : node->children)\n+            {\n+                if (!child->is_deterministic)\n+                {\n+                    node->is_deterministic = false;\n+                    break;\n+                }\n+            }\n+\n             node->children.clear();\n         }\n \n@@ -981,6 +993,14 @@ bool ActionsDAG::trivial() const\n     return true;\n }\n \n+void ActionsDAG::assertDeterministic() const\n+{\n+    for (const auto & node : nodes)\n+        if (!node.is_deterministic)\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Expression must be deterministic but it contains non-deterministic part `{}`\", node.result_name);\n+}\n+\n void ActionsDAG::addMaterializingOutputActions()\n {\n     for (auto & node : index)\ndiff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h\nindex 9cd0057bb1a0..bfb5b177ac7d 100644\n--- a/src/Interpreters/ActionsDAG.h\n+++ b/src/Interpreters/ActionsDAG.h\n@@ -83,6 +83,9 @@ class ActionsDAG\n         ExecutableFunctionPtr function;\n         /// If function is a compiled statement.\n         bool is_function_compiled = false;\n+        /// It is deterministic (See IFunction::isDeterministic).\n+        /// This property is kept after constant folding of non-deterministic functions like 'now', 'today'.\n+        bool is_deterministic = true;\n \n         /// For COLUMN node and propagated constants.\n         ColumnPtr column;\n@@ -175,6 +178,7 @@ class ActionsDAG\n     bool hasArrayJoin() const;\n     bool hasStatefulFunctions() const;\n     bool trivial() const; /// If actions has no functions or array join.\n+    void assertDeterministic() const; /// Throw if not isDeterministic.\n \n #if USE_EMBEDDED_COMPILER\n     void compileExpressions(size_t min_count_to_compile_expression);\ndiff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp\nindex bd06c7533196..905fcf0331c2 100644\n--- a/src/Interpreters/ExpressionActions.cpp\n+++ b/src/Interpreters/ExpressionActions.cpp\n@@ -531,11 +531,12 @@ Names ExpressionActions::getRequiredColumns() const\n \n bool ExpressionActions::hasArrayJoin() const\n {\n-    for (const auto & action : actions)\n-        if (action.node->type == ActionsDAG::ActionType::ARRAY_JOIN)\n-            return true;\n+    return getActionsDAG().hasArrayJoin();\n+}\n \n-    return false;\n+void ExpressionActions::assertDeterministic() const\n+{\n+    getActionsDAG().assertDeterministic();\n }\n \n \ndiff --git a/src/Interpreters/ExpressionActions.h b/src/Interpreters/ExpressionActions.h\nindex 7699e82a73bd..4fddd1fd27e2 100644\n--- a/src/Interpreters/ExpressionActions.h\n+++ b/src/Interpreters/ExpressionActions.h\n@@ -103,6 +103,7 @@ class ExpressionActions\n     void execute(Block & block, bool dry_run = false) const;\n \n     bool hasArrayJoin() const;\n+    void assertDeterministic() const;\n \n     /// Obtain a sample block that contains the names and types of result columns.\n     const Block & getSampleBlock() const { return sample_block; }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 06838a077f76..88a4ea5df901 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -270,19 +270,17 @@ StoragePolicyPtr MergeTreeData::getStoragePolicy() const\n \n static void checkKeyExpression(const ExpressionActions & expr, const Block & sample_block, const String & key_name, bool allow_nullable_key)\n {\n-    for (const auto & action : expr.getActions())\n-    {\n-        if (action.node->type == ActionsDAG::ActionType::ARRAY_JOIN)\n-            throw Exception(key_name + \" key cannot contain array joins\", ErrorCodes::ILLEGAL_COLUMN);\n+    if (expr.hasArrayJoin())\n+        throw Exception(key_name + \" key cannot contain array joins\", ErrorCodes::ILLEGAL_COLUMN);\n \n-        if (action.node->type == ActionsDAG::ActionType::FUNCTION)\n-        {\n-            IFunctionBase & func = *action.node->function_base;\n-            if (!func.isDeterministic())\n-                throw Exception(key_name + \" key cannot contain non-deterministic functions, \"\n-                    \"but contains function \" + func.getName(),\n-                    ErrorCodes::BAD_ARGUMENTS);\n-        }\n+    try\n+    {\n+        expr.assertDeterministic();\n+    }\n+    catch (Exception & e)\n+    {\n+        e.addMessage(fmt::format(\"for {} key\", key_name));\n+        throw;\n     }\n \n     for (const ColumnWithTypeAndName & element : sample_block)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01943_non_deterministic_order_key.reference b/tests/queries/0_stateless/01943_non_deterministic_order_key.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/01943_non_deterministic_order_key.sql b/tests/queries/0_stateless/01943_non_deterministic_order_key.sql\nnew file mode 100644\nindex 000000000000..200a88ec677a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01943_non_deterministic_order_key.sql\n@@ -0,0 +1,3 @@\n+CREATE TABLE a (number UInt64) ENGINE = MergeTree ORDER BY if(now() > toDateTime('2020-06-01 13:31:40'), toInt64(number), -number); -- { serverError 36 }\n+CREATE TABLE b (number UInt64) ENGINE = MergeTree ORDER BY now() > toDateTime(number); -- { serverError 36 }\n+CREATE TABLE c (number UInt64) ENGINE = MergeTree ORDER BY now(); -- { serverError 36 }\n",
  "problem_statement": "Table ORDER BY sanitization issue\nThings like that should be forbidden:\r\n```\r\nCREATE TABLE a\r\n(\r\n    `number` UInt64\r\n)\r\nENGINE = MergeTree\r\nORDER BY if(now() > toDateTime('2020-06-01 13:31:40'), toInt64(number), -number)\r\n```\r\n\r\nJust like those (which are forbidden already):\r\n```\r\nCREATE TABLE a\r\n(\r\n    `number` UInt64\r\n)\r\nENGINE = MergeTree\r\nORDER BY if(rand() > 100, toInt64(number), -number)\r\n\r\nReceived exception from server (version 20.4.4):\r\nCode: 36. DB::Exception: Received from localhost:9000. DB::Exception: Sorting key cannot contain non-deterministic functions, but contains function rand. \r\n```\r\n\nTable ORDER BY sanitization issue #11333\nI hereby agree to the terms of the CLA available at: https://yandex.ru/legal/cla/?lang=en\r\n\r\nChangelog category (leave one):\r\n- Improvement\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\n\r\nDetailed description / Documentation draft:\r\nSorting key cannot contain non-deterministic functions.\r\nSuch as will failed\r\n```\r\nCREATE TABLE a\r\n(\r\n    `number` UInt64\r\n)\r\nENGINE = MergeTree\r\nORDER BY if(now() > toDateTime('2020-06-01 13:31:40'), toInt64(number), -number)\r\n```\r\nClose #11333  \r\n\n",
  "hints_text": "@alesapin Looks like easy to do. Could you please take a look?\nhi @alexey-milovidov \r\nI find `rand()` is based `IFunction`, but `now()` is based `IExecutableFunction` and return `createColumnConst` as result.\r\nSo the check in  [checkKeyExpression](https://clickhouse.tech/codebrowser/html_report/ClickHouse/src/Storages/MergeTree/MergeTreeData.cpp.html#281) is not work.(I'm not sure).\r\nWhat should we do, change `now()` function to be based `IFunction` or any idea?\n@zxc111 Yes, it is related to constant folding.\r\nThe constant folding happens before the check and the function `now` does not exist in actions.\r\n\r\nProper solutions can be:\r\n- ask ExpressionActions or ActionsDAG to check for non-determinism;\r\n- save folded expressions in .sql metadata, so `now()` is resolved at creation time and substituted; but we should also do the same for ORDER BY key stored in ZooKeeper for Replicated tables, otherwise it will not match.\n",
  "created_at": "2021-07-12T06:39:18Z"
}