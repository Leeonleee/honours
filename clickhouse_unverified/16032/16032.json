{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 16032,
  "instance_id": "ClickHouse__ClickHouse-16032",
  "issue_numbers": [
    "15706"
  ],
  "base_commit": "939d8edf3305c1de82116ed155e3d35d1053df53",
  "patch": "diff --git a/src/Databases/DatabaseLazy.h b/src/Databases/DatabaseLazy.h\nindex 13c14863efbd..2d091297c91d 100644\n--- a/src/Databases/DatabaseLazy.h\n+++ b/src/Databases/DatabaseLazy.h\n@@ -22,6 +22,10 @@ class DatabaseLazy final : public DatabaseOnDisk\n \n     String getEngineName() const override { return \"Lazy\"; }\n \n+    bool canContainMergeTreeTables() const override { return false; }\n+\n+    bool canContainDistributedTables() const override { return false; }\n+\n     void loadStoredObjects(\n         Context & context,\n         bool has_force_restore_data_flag, bool force_attach) override;\ndiff --git a/src/Databases/IDatabase.h b/src/Databases/IDatabase.h\nindex b28bd5fd5997..fadec5fe7a93 100644\n--- a/src/Databases/IDatabase.h\n+++ b/src/Databases/IDatabase.h\n@@ -147,6 +147,10 @@ class IDatabase : public std::enable_shared_from_this<IDatabase>\n     /// Get name of database engine.\n     virtual String getEngineName() const = 0;\n \n+    virtual bool canContainMergeTreeTables() const { return true; }\n+\n+    virtual bool canContainDistributedTables() const { return true; }\n+\n     /// Load a set of existing tables.\n     /// You can call only once, right after the object is created.\n     virtual void loadStoredObjects(Context & /*context*/, bool /*has_force_restore_data_flag*/, bool /*force_attach*/ = false) {}\ndiff --git a/src/Databases/MySQL/DatabaseConnectionMySQL.h b/src/Databases/MySQL/DatabaseConnectionMySQL.h\nindex 7bf5e8c1d882..d8694e71db23 100644\n--- a/src/Databases/MySQL/DatabaseConnectionMySQL.h\n+++ b/src/Databases/MySQL/DatabaseConnectionMySQL.h\n@@ -42,6 +42,12 @@ class DatabaseConnectionMySQL final : public IDatabase\n \n     String getEngineName() const override { return \"MySQL\"; }\n \n+    bool canContainMergeTreeTables() const override { return false; }\n+\n+    bool canContainDistributedTables() const override { return false; }\n+\n+    bool shouldBeEmptyOnDetach() const override { return false; }\n+\n     bool empty() const override;\n \n     DatabaseTablesIteratorPtr getTablesIterator(const Context & context, const FilterByNameFunction & filter_by_table_name) override;\ndiff --git a/src/Interpreters/AsynchronousMetrics.cpp b/src/Interpreters/AsynchronousMetrics.cpp\nindex feb2036a0d6c..e1a9a820ebb9 100644\n--- a/src/Interpreters/AsynchronousMetrics.cpp\n+++ b/src/Interpreters/AsynchronousMetrics.cpp\n@@ -233,8 +233,8 @@ void AsynchronousMetrics::update()\n \n         for (const auto & db : databases)\n         {\n-            /// Lazy database can not contain MergeTree tables\n-            if (db.second->getEngineName() == \"Lazy\")\n+            /// Check if database can contain MergeTree tables\n+            if (!db.second->canContainMergeTreeTables())\n                 continue;\n             for (auto iterator = db.second->getTablesIterator(context); iterator->isValid(); iterator->next())\n             {\ndiff --git a/src/Server/ReplicasStatusHandler.cpp b/src/Server/ReplicasStatusHandler.cpp\nindex bc5436f00ee4..1aa5c10afd78 100644\n--- a/src/Server/ReplicasStatusHandler.cpp\n+++ b/src/Server/ReplicasStatusHandler.cpp\n@@ -43,8 +43,8 @@ void ReplicasStatusHandler::handleRequest(Poco::Net::HTTPServerRequest & request\n         /// Iterate through all the replicated tables.\n         for (const auto & db : databases)\n         {\n-            /// Lazy database can not contain replicated tables\n-            if (db.second->getEngineName() == \"Lazy\")\n+            /// Check if database can contain replicated tables\n+            if (!db.second->canContainMergeTreeTables())\n                 continue;\n \n             for (auto iterator = db.second->getTablesIterator(context); iterator->isValid(); iterator->next())\ndiff --git a/src/Storages/System/StorageSystemDistributionQueue.cpp b/src/Storages/System/StorageSystemDistributionQueue.cpp\nindex 2459be0ba71e..39ccea64e26b 100644\n--- a/src/Storages/System/StorageSystemDistributionQueue.cpp\n+++ b/src/Storages/System/StorageSystemDistributionQueue.cpp\n@@ -38,8 +38,8 @@ void StorageSystemDistributionQueue::fillData(MutableColumns & res_columns, cons\n     std::map<String, std::map<String, StoragePtr>> tables;\n     for (const auto & db : DatabaseCatalog::instance().getDatabases())\n     {\n-        /// Lazy database can not contain distributed tables\n-        if (db.second->getEngineName() == \"Lazy\")\n+        /// Check if database can contain distributed tables\n+        if (!db.second->canContainDistributedTables())\n             continue;\n \n         const bool check_access_for_tables = check_access_for_databases && !access->isGranted(AccessType::SHOW_TABLES, db.first);\ndiff --git a/src/Storages/System/StorageSystemGraphite.cpp b/src/Storages/System/StorageSystemGraphite.cpp\nindex ffa789a47512..93bc16785b2b 100644\n--- a/src/Storages/System/StorageSystemGraphite.cpp\n+++ b/src/Storages/System/StorageSystemGraphite.cpp\n@@ -32,8 +32,8 @@ static StorageSystemGraphite::Configs getConfigs(const Context & context)\n \n     for (const auto & db : databases)\n     {\n-        /// Lazy database can not contain MergeTree tables\n-        if (db.second->getEngineName() == \"Lazy\")\n+        /// Check if database can contain MergeTree tables\n+        if (!db.second->canContainMergeTreeTables())\n             continue;\n \n         for (auto iterator = db.second->getTablesIterator(context); iterator->isValid(); iterator->next())\ndiff --git a/src/Storages/System/StorageSystemMutations.cpp b/src/Storages/System/StorageSystemMutations.cpp\nindex 32f672b84017..f66f57ef5d15 100644\n--- a/src/Storages/System/StorageSystemMutations.cpp\n+++ b/src/Storages/System/StorageSystemMutations.cpp\n@@ -44,8 +44,8 @@ void StorageSystemMutations::fillData(MutableColumns & res_columns, const Contex\n     std::map<String, std::map<String, StoragePtr>> merge_tree_tables;\n     for (const auto & db : DatabaseCatalog::instance().getDatabases())\n     {\n-        /// Lazy database can not contain MergeTree tables\n-        if (db.second->getEngineName() == \"Lazy\")\n+        /// Check if database can contain MergeTree tables\n+        if (!db.second->canContainMergeTreeTables())\n             continue;\n \n         const bool check_access_for_tables = check_access_for_databases && !access->isGranted(AccessType::SHOW_TABLES, db.first);\ndiff --git a/src/Storages/System/StorageSystemPartsBase.cpp b/src/Storages/System/StorageSystemPartsBase.cpp\nindex faa2ec0e1c33..d10346af89f5 100644\n--- a/src/Storages/System/StorageSystemPartsBase.cpp\n+++ b/src/Storages/System/StorageSystemPartsBase.cpp\n@@ -83,9 +83,9 @@ StoragesInfoStream::StoragesInfoStream(const SelectQueryInfo & query_info, const\n         MutableColumnPtr database_column_mut = ColumnString::create();\n         for (const auto & database : databases)\n         {\n-            /// Lazy database can not contain MergeTree tables\n-            /// and it's unnecessary to load all tables of Lazy database just to filter all of them.\n-            if (database.second->getEngineName() != \"Lazy\")\n+            /// Checck if database can contain MergeTree tables,\n+            /// if not it's unnecessary to load all tables of database just to filter all of them.\n+            if (database.second->canContainMergeTreeTables())\n                 database_column_mut->insert(database.first);\n         }\n         block_to_filter.insert(ColumnWithTypeAndName(\ndiff --git a/src/Storages/System/StorageSystemReplicas.cpp b/src/Storages/System/StorageSystemReplicas.cpp\nindex 7ab6e939815d..ab54d7608732 100644\n--- a/src/Storages/System/StorageSystemReplicas.cpp\n+++ b/src/Storages/System/StorageSystemReplicas.cpp\n@@ -74,8 +74,8 @@ Pipe StorageSystemReplicas::read(\n     std::map<String, std::map<String, StoragePtr>> replicated_tables;\n     for (const auto & db : DatabaseCatalog::instance().getDatabases())\n     {\n-        /// Lazy database can not contain replicated tables\n-        if (db.second->getEngineName() == \"Lazy\")\n+        /// Check if database can contain replicated tables\n+        if (!db.second->canContainMergeTreeTables())\n             continue;\n         const bool check_access_for_tables = check_access_for_databases && !access->isGranted(AccessType::SHOW_TABLES, db.first);\n         for (auto iterator = db.second->getTablesIterator(context); iterator->isValid(); iterator->next())\ndiff --git a/src/Storages/System/StorageSystemReplicationQueue.cpp b/src/Storages/System/StorageSystemReplicationQueue.cpp\nindex f04d8759507a..9cd5e8b8ff3f 100644\n--- a/src/Storages/System/StorageSystemReplicationQueue.cpp\n+++ b/src/Storages/System/StorageSystemReplicationQueue.cpp\n@@ -55,8 +55,8 @@ void StorageSystemReplicationQueue::fillData(MutableColumns & res_columns, const\n     std::map<String, std::map<String, StoragePtr>> replicated_tables;\n     for (const auto & db : DatabaseCatalog::instance().getDatabases())\n     {\n-        /// Lazy database can not contain replicated tables\n-        if (db.second->getEngineName() == \"Lazy\")\n+        /// Check if database can contain replicated tables\n+        if (!db.second->canContainMergeTreeTables())\n             continue;\n \n         const bool check_access_for_tables = check_access_for_databases && !access->isGranted(AccessType::SHOW_TABLES, db.first);\n",
  "test_patch": "diff --git a/tests/integration/test_disabled_mysql_server/__init__.py b/tests/integration/test_disabled_mysql_server/__init__.py\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/integration/test_disabled_mysql_server/configs/remote_servers.xml b/tests/integration/test_disabled_mysql_server/configs/remote_servers.xml\nnew file mode 100644\nindex 000000000000..de8e5865f12d\n--- /dev/null\n+++ b/tests/integration/test_disabled_mysql_server/configs/remote_servers.xml\n@@ -0,0 +1,12 @@\n+<yandex>\n+    <remote_servers>\n+        <test_cluster>\n+            <shard>\n+                <replica>\n+                    <host>node1</host>\n+                    <port>9000</port>\n+                </replica>\n+            </shard>\n+        </test_cluster>\n+    </remote_servers>\n+</yandex>\ndiff --git a/tests/integration/test_disabled_mysql_server/test.py b/tests/integration/test_disabled_mysql_server/test.py\nnew file mode 100644\nindex 000000000000..a2cbcb17534f\n--- /dev/null\n+++ b/tests/integration/test_disabled_mysql_server/test.py\n@@ -0,0 +1,60 @@\n+import time\n+import contextlib\n+import pymysql.cursors\n+import pytest\n+import os\n+import subprocess\n+\n+from helpers.client import QueryRuntimeException\n+from helpers.cluster import ClickHouseCluster, get_docker_compose_path\n+from helpers.network import PartitionManager\n+\n+cluster = ClickHouseCluster(__file__)\n+clickhouse_node = cluster.add_instance('node1', main_configs=['configs/remote_servers.xml'], with_mysql=True)\n+\n+@pytest.fixture(scope=\"module\")\n+def started_cluster():\n+    try:\n+        cluster.start()\n+        yield cluster\n+    finally:\n+        cluster.shutdown()\n+\n+\n+class MySQLNodeInstance:\n+    def __init__(self, user='root', password='clickhouse', hostname='127.0.0.1', port=3308):\n+        self.user = user\n+        self.port = port\n+        self.hostname = hostname\n+        self.password = password\n+        self.mysql_connection = None   # lazy init\n+\n+    def alloc_connection(self):\n+        if self.mysql_connection is None:\n+            self.mysql_connection = pymysql.connect(user=self.user, password=self.password, host=self.hostname,\n+                                                    port=self.port, autocommit=True)\n+        return self.mysql_connection\n+\n+    def query(self, execution_query):\n+        with self.alloc_connection().cursor() as cursor:\n+            cursor.execute(execution_query)\n+\n+    def close(self):\n+        if self.mysql_connection is not None:\n+            self.mysql_connection.close()\n+\n+\n+def test_disabled_mysql_server(started_cluster):\n+    with contextlib.closing(MySQLNodeInstance()) as mysql_node:\n+        mysql_node.query(\"CREATE DATABASE test_db;\")\n+        mysql_node.query(\"CREATE TABLE test_db.test_table ( `id` int(11) NOT NULL, PRIMARY KEY (`id`) ) ENGINE=InnoDB;\")\n+\n+    with PartitionManager() as pm:\n+        clickhouse_node.query(\"CREATE DATABASE test_db ENGINE = MySQL('mysql1:3306', 'test_db', 'root', 'clickhouse')\")\n+            \n+        pm._add_rule({'source': clickhouse_node.ip_address, 'destination_port': 3306, 'action': 'DROP'})\n+        clickhouse_node.query(\"SELECT * FROM system.parts\")\n+        clickhouse_node.query(\"SELECT * FROM system.mutations\")\n+        clickhouse_node.query(\"SELECT * FROM system.graphite_retentions\")\n+\n+        clickhouse_node.query(\"DROP DATABASE test_db\")\n",
  "problem_statement": "cannot query system.parts when MySQL server used as database engine is down\n**Describe the bug**\r\nAny query to system.parts doesn't work when MySQL server used as database engine not accessible.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use\r\ntested on 20.5.2.7 and 20.9.2.20\r\n\r\n```\r\nCREATE DATABASE mysql ENGINE = MySQL('mysql:3306', 'db', 'user', 'password');\r\n\r\nSELECT NULL\r\nFROM system.parts\r\nLIMIT 1\r\n\r\n\u250c\u2500NULL\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n-- no results here\r\nSELECT NULL\r\nFROM system.parts\r\nWHERE database = 'mysql'\r\nLIMIT 1\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.025 sec.\r\n```\r\nshutdown mysql\r\n```\r\nSELECT NULL\r\nFROM system.parts\r\nLIMIT 1\r\n\r\nReceived exception from server (version 20.9.2):\r\nCode: 1000. DB::Exception: Received from clickhouse-dev209:9000. DB::Exception: mysqlxx::ConnectionFailed: Unknown MySQL server host 'mysql' (-2) ((nullptr):0).\r\n\r\n-- but works here\r\nSELECT NULL\r\nFROM system.parts\r\nWHERE database != 'mysql'\r\nLIMIT 1\r\n\r\n\u250c\u2500NULL\u2500\u2510\r\n\u2502 \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\r\n**Expected behavior**\r\nSELECT FROM system.parts works without WHERE database NOT IN (_all MySQL dbs_)\n",
  "hints_text": "I also can't drop `mysql` database when it not accessible.\r\n```\r\nDROP DATABASE mysql\r\n\r\nReceived exception from server (version 20.9.2):\r\nCode: 1000. DB::Exception: Received from clickhouse-dev209:9000. DB::Exception: mysqlxx::ConnectionFailed: Unknown MySQL server host 'mysql' (-2) ((nullptr):0).\r\n```\r\n",
  "created_at": "2020-10-15T16:03:31Z"
}