{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 5313,
  "instance_id": "ClickHouse__ClickHouse-5313",
  "issue_numbers": [
    "3540"
  ],
  "base_commit": "21cf553f164f6ac91f96b8b0c3db37a40cf0efcd",
  "patch": "diff --git a/dbms/CMakeLists.txt b/dbms/CMakeLists.txt\nindex d0ca68543f0f..a14495dfc19a 100644\n--- a/dbms/CMakeLists.txt\n+++ b/dbms/CMakeLists.txt\n@@ -367,6 +367,6 @@ if (ENABLE_TESTS AND USE_GTEST)\n     # attach all dbms gtest sources\n     grep_gtest_sources(${ClickHouse_SOURCE_DIR}/dbms dbms_gtest_sources)\n     add_executable(unit_tests_dbms ${dbms_gtest_sources})\n-    target_link_libraries(unit_tests_dbms PRIVATE ${GTEST_BOTH_LIBRARIES} dbms clickhouse_common_zookeeper)\n+    target_link_libraries(unit_tests_dbms PRIVATE ${GTEST_BOTH_LIBRARIES} clickhouse_functions clickhouse_parsers dbms clickhouse_common_zookeeper)\n     add_check(unit_tests_dbms)\n endif ()\ndiff --git a/dbms/src/Parsers/ASTFunction.cpp b/dbms/src/Parsers/ASTFunction.cpp\nindex b45bded96646..5c5dbc9ba904 100644\n--- a/dbms/src/Parsers/ASTFunction.cpp\n+++ b/dbms/src/Parsers/ASTFunction.cpp\n@@ -2,6 +2,7 @@\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/ASTWithAlias.h>\n+#include <Parsers/ASTSubquery.h>\n #include <IO/WriteHelpers.h>\n #include <IO/WriteBufferFromString.h>\n \n@@ -141,7 +142,7 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n             }\n         }\n \n-        /** need_parens - do I need parentheses around the expression with the operator.\n+        /** need_parens - do we need parentheses around the expression with the operator.\n           * They are needed only if this expression is included in another expression with the operator.\n           */\n \n@@ -182,7 +183,22 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n                         && (name == \"like\" || name == \"notLike\")\n                         && highlightStringLiteralWithMetacharacters(arguments->children[1], settings, \"%_\");\n \n-                    if (!special_hilite)\n+                    /// Format x IN 1 as x IN (1): put parens around rhs even if there is a single element in set.\n+                    const auto * second_arg_func = arguments->children[1]->as<ASTFunction>();\n+                    const auto * second_arg_literal = arguments->children[1]->as<ASTLiteral>();\n+                    bool extra_parents_around_in_rhs = (name == \"in\" || name == \"notIn\" || name == \"globalIn\" || name == \"globalNotIn\")\n+                        && !(second_arg_func && second_arg_func->name == \"tuple\")\n+                        && !(second_arg_literal && second_arg_literal->value.getType() == Field::Types::Tuple)\n+                        && !arguments->children[1]->as<ASTSubquery>();\n+\n+                    if (extra_parents_around_in_rhs)\n+                    {\n+                        settings.ostr << '(';\n+                        arguments->children[1]->formatImpl(settings, state, nested_dont_need_parens);\n+                        settings.ostr << ')';\n+                    }\n+\n+                    if (!special_hilite && !extra_parents_around_in_rhs)\n                         arguments->children[1]->formatImpl(settings, state, nested_need_parens);\n \n                     if (frame.need_parens)\ndiff --git a/dbms/src/Parsers/ParserQuery.h b/dbms/src/Parsers/ParserQuery.h\nindex 4bde22b2f6b8..cf8837cb7beb 100644\n--- a/dbms/src/Parsers/ParserQuery.h\n+++ b/dbms/src/Parsers/ParserQuery.h\n@@ -10,7 +10,7 @@ class ParserQuery : public IParserBase\n {\n private:\n     const char * end;\n-    bool enable_explain;\n+    bool enable_explain;    /// Allow queries prefixed with AST and ANALYZE for development purposes.\n \n     const char * getName() const override { return \"Query\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\ndiff --git a/dbms/src/Storages/transformQueryForExternalDatabase.cpp b/dbms/src/Storages/transformQueryForExternalDatabase.cpp\nindex 1a1d1b00dcc1..c0fcbabba42a 100644\n--- a/dbms/src/Storages/transformQueryForExternalDatabase.cpp\n+++ b/dbms/src/Storages/transformQueryForExternalDatabase.cpp\n@@ -16,6 +16,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n static void replaceConstFunction(IAST & node, const Context & context, const NamesAndTypesList & all_columns)\n {\n     for (size_t i = 0; i < node.children.size(); ++i)\n@@ -44,19 +49,33 @@ static bool isCompatible(const IAST & node)\n {\n     if (const auto * function = node.as<ASTFunction>())\n     {\n+        if (function->parameters)   /// Parametric aggregate functions\n+            return false;\n+\n+        if (!function->arguments)\n+            throw Exception(\"Logical error: function->arguments is not set\", ErrorCodes::LOGICAL_ERROR);\n+\n         String name = function->name;\n+\n         if (!(name == \"and\"\n             || name == \"or\"\n             || name == \"not\"\n             || name == \"equals\"\n             || name == \"notEquals\"\n+            || name == \"less\"\n+            || name == \"greater\"\n+            || name == \"lessOrEquals\"\n+            || name == \"greaterOrEquals\"\n             || name == \"like\"\n             || name == \"notLike\"\n             || name == \"in\"\n-            || name == \"greater\"\n-            || name == \"less\"\n-            || name == \"lessOrEquals\"\n-            || name == \"greaterOrEquals\"))\n+            || name == \"notIn\"\n+            || name == \"tuple\"))\n+            return false;\n+\n+        /// A tuple with zero or one elements is represented by a function tuple(x) and is not compatible,\n+        /// but a normal tuple with more than one element is represented as a parenthesed expression (x, y) and is perfectly compatible.\n+        if (name == \"tuple\" && function->arguments->children.size() <= 1)\n             return false;\n \n         for (const auto & expr : function->arguments->children)\n@@ -68,9 +87,8 @@ static bool isCompatible(const IAST & node)\n \n     if (const auto * literal = node.as<ASTLiteral>())\n     {\n-        /// Foreign databases often have no support for Array and Tuple literals.\n-        if (literal->value.getType() == Field::Types::Array\n-            || literal->value.getType() == Field::Types::Tuple)\n+        /// Foreign databases often have no support for Array. But Tuple literals are passed to support IN clause.\n+        if (literal->value.getType() == Field::Types::Array)\n             return false;\n \n         return true;\ndiff --git a/dbms/src/Storages/transformQueryForExternalDatabase.h b/dbms/src/Storages/transformQueryForExternalDatabase.h\nindex 77cc7f3a194d..9b838da51271 100644\n--- a/dbms/src/Storages/transformQueryForExternalDatabase.h\n+++ b/dbms/src/Storages/transformQueryForExternalDatabase.h\n@@ -21,9 +21,6 @@ class Context;\n   * that contain only compatible expressions.\n   *\n   * Compatible expressions are comparisons of identifiers, constants, and logical operations on them.\n-  *\n-  * NOTE There are concerns with proper quoting of identifiers for remote database.\n-  * Some databases use `quotes` and other use \"quotes\".\n   */\n String transformQueryForExternalDatabase(\n     const IAST & query,\n",
  "test_patch": "diff --git a/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp b/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp\nnew file mode 100644\nindex 000000000000..4a25bff5d87d\n--- /dev/null\n+++ b/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n@@ -0,0 +1,75 @@\n+#pragma GCC diagnostic ignored \"-Wsign-compare\"\n+#ifdef __clang__\n+    #pragma clang diagnostic ignored \"-Wzero-as-null-pointer-constant\"\n+    #pragma clang diagnostic ignored \"-Wundef\"\n+#endif\n+#include <gtest/gtest.h>\n+\n+#include <Storages/transformQueryForExternalDatabase.h>\n+#include <Parsers/ParserSelectQuery.h>\n+#include <Parsers/parseQuery.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Interpreters/Context.h>\n+#include <Databases/DatabaseMemory.h>\n+#include <Storages/StorageMemory.h>\n+#include <Functions/registerFunctions.h>\n+\n+\n+using namespace DB;\n+\n+\n+/// NOTE How to do better?\n+struct State\n+{\n+    Context context{Context::createGlobal()};\n+    NamesAndTypesList columns{{\"column\", std::make_shared<DataTypeUInt8>()}};\n+\n+    State()\n+    {\n+        registerFunctions();\n+        DatabasePtr database = std::make_shared<DatabaseMemory>(\"test\");\n+        database->attachTable(\"table\", StorageMemory::create(\"table\", ColumnsDescription{columns}));\n+        context.addDatabase(\"test\", database);\n+        context.setCurrentDatabase(\"test\");\n+    }\n+};\n+\n+State & state()\n+{\n+    static State res;\n+    return res;\n+}\n+\n+\n+void check(const std::string & query, const std::string & expected, const Context & context, const NamesAndTypesList & columns)\n+{\n+    ParserSelectQuery parser;\n+    ASTPtr ast = parseQuery(parser, query, 1000);\n+    std::string transformed_query = transformQueryForExternalDatabase(*ast, columns, IdentifierQuotingStyle::DoubleQuotes, \"test\", \"table\", context);\n+\n+    EXPECT_EQ(transformed_query, expected);\n+}\n+\n+\n+TEST(TransformQueryForExternalDatabase, InWithSingleElement)\n+{\n+    check(\"SELECT column FROM test.table WHERE 1 IN (1)\",\n+          \"SELECT \\\"column\\\" FROM \\\"test\\\".\\\"table\\\"  WHERE 1 IN (1)\",\n+          state().context, state().columns);\n+    check(\"SELECT column FROM test.table WHERE column IN (1, 2)\",\n+          \"SELECT \\\"column\\\" FROM \\\"test\\\".\\\"table\\\"  WHERE \\\"column\\\" IN (1, 2)\",\n+          state().context, state().columns);\n+    check(\"SELECT column FROM test.table WHERE column NOT IN ('hello', 'world')\",\n+          \"SELECT \\\"column\\\" FROM \\\"test\\\".\\\"table\\\"  WHERE \\\"column\\\" NOT IN ('hello', 'world')\",\n+          state().context, state().columns);\n+}\n+\n+TEST(TransformQueryForExternalDatabase, Like)\n+{\n+    check(\"SELECT column FROM test.table WHERE column LIKE '%hello%'\",\n+          \"SELECT \\\"column\\\" FROM \\\"test\\\".\\\"table\\\"  WHERE \\\"column\\\" LIKE '%hello%'\",\n+          state().context, state().columns);\n+    check(\"SELECT column FROM test.table WHERE column NOT LIKE 'w%rld'\",\n+          \"SELECT \\\"column\\\" FROM \\\"test\\\".\\\"table\\\"  WHERE \\\"column\\\" NOT LIKE 'w%rld'\",\n+          state().context, state().columns);\n+}\ndiff --git a/dbms/tests/queries/0_stateless/00948_format_in_with_single_element.reference b/dbms/tests/queries/0_stateless/00948_format_in_with_single_element.reference\nnew file mode 100644\nindex 000000000000..91f53ffadb02\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00948_format_in_with_single_element.reference\n@@ -0,0 +1,13 @@\n+SELECT 1 IN (1)\n+SELECT 1 IN (1)\n+SELECT 1 IN (1, 2)\n+SELECT 1 IN (f(1))\n+SELECT 1 IN (f(1))\n+SELECT 1 IN (f(1), f(2))\n+SELECT 1 IN (f(1, 2))\n+SELECT 1 IN (1 + 1)\n+SELECT 1 IN ('hello')\n+SELECT 1 IN (f('hello'))\n+SELECT 1 IN ('hello', 'world')\n+SELECT 1 IN (f('hello', 'world'))\n+SELECT 1 IN (SELECT 1)\ndiff --git a/dbms/tests/queries/0_stateless/00948_format_in_with_single_element.sh b/dbms/tests/queries/0_stateless/00948_format_in_with_single_element.sh\nnew file mode 100755\nindex 000000000000..c0a2f167ec57\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00948_format_in_with_single_element.sh\n@@ -0,0 +1,22 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+set -e\n+\n+format=\"$CLICKHOUSE_FORMAT --oneline\"\n+\n+echo \"SELECT 1 IN 1\" | $format\n+echo \"SELECT 1 IN (1)\" | $format\n+echo \"SELECT 1 IN (1, 2)\" | $format\n+echo \"SELECT 1 IN f(1)\" | $format\n+echo \"SELECT 1 IN (f(1))\" | $format\n+echo \"SELECT 1 IN (f(1), f(2))\" | $format\n+echo \"SELECT 1 IN f(1, 2)\" | $format\n+echo \"SELECT 1 IN 1 + 1\" | $format\n+echo \"SELECT 1 IN 'hello'\" | $format\n+echo \"SELECT 1 IN f('hello')\" | $format\n+echo \"SELECT 1 IN ('hello', 'world')\" | $format\n+echo \"SELECT 1 IN f('hello', 'world')\" | $format\n+echo \"SELECT 1 IN (SELECT 1)\" | $format\ndiff --git a/dbms/tests/queries/shell_config.sh b/dbms/tests/queries/shell_config.sh\nindex ec65f148b01a..af222fc95310 100644\n--- a/dbms/tests/queries/shell_config.sh\n+++ b/dbms/tests/queries/shell_config.sh\n@@ -22,6 +22,10 @@ export CLICKHOUSE_CONFIG_CLIENT=${CLICKHOUSE_CONFIG_CLIENT:=\"/etc/clickhouse-cli\n [ -x \"${CLICKHOUSE_BINARY}\" ] && CLICKHOUSE_EXTRACT_CONFIG=${CLICKHOUSE_EXTRACT_CONFIG:=\"$CLICKHOUSE_BINARY extract-from-config --config=$CLICKHOUSE_CONFIG\"}\n export CLICKHOUSE_EXTRACT_CONFIG=${CLICKHOUSE_EXTRACT_CONFIG:=\"$CLICKHOUSE_BINARY-extract-from-config --config=$CLICKHOUSE_CONFIG\"}\n \n+[ -x \"${CLICKHOUSE_BINARY}-format\" ] && CLICKHOUSE_FORMAT=${CLICKHOUSE_FORMAT=:=\"$CLICKHOUSE_BINARY-format\"}\n+[ -x \"${CLICKHOUSE_BINARY}\" ] && CLICKHOUSE_FORMAT=${CLICKHOUSE_FORMAT:=\"$CLICKHOUSE_BINARY format\"}\n+export CLICKHOUSE_FORMAT=${CLICKHOUSE_FORMAT:=\"$CLICKHOUSE_BINARY-format\"}\n+\n export CLICKHOUSE_CONFIG_GREP=${CLICKHOUSE_CONFIG_GREP:=\"/etc/clickhouse-server/preprocessed/config.xml\"}\n \n export CLICKHOUSE_HOST=${CLICKHOUSE_HOST:=\"localhost\"}\n",
  "problem_statement": "The MySQL IN () functionality does not get passed to the remote server\nI was very happy to see PR #3182 by @VadimPE, which improved MySQL (and ODBC) functionality so that `IN()` and `LIKE` `WHERE` clauses with a constant right half would get passed to the remote server instead of being executed locally.\r\n\r\nThis was in the `CHANGELOG` for 18.14.9, but the problem is I can't get it to work in latest (18.12.14). Here's an example from a MySQL table containing just 3.7M rows, all of which are getting fetched:\r\n\r\n```clickhouse\r\n# clickhouse client\r\nClickHouse client version 18.14.12.\r\nConnecting to localhost:9000\r\nConnected to ClickHouse server version 18.14.12 revision 54409.\r\n\r\nclickhouse-xh96s :) select * from mysql('mysql-slave', 'clickhouse', 'clickhouse_responses', 'monitor', 'XXXXXXXXXXXXXXXXXXXX') where question_response_id in (4690063,4698156)\r\n\r\nSELECT *\r\nFROM mysql('mysql-slave', 'clickhouse', 'clickhouse_responses', 'monitor', 'XXXXXXXXXXXXXXXXXXXX') \r\nWHERE question_response_id IN (4690063, 4698156)\r\n\r\n<resultset omitted>\r\n\r\n2 rows in set. Elapsed: 23.330 sec. Processed 3.73 million rows, 1.58 GB (159.85 thousand rows/s., 67.76 MB/s.)\r\n```\r\n\r\nAnd on the MySQL server, we can see there is no WHERE clause with an IN:\r\n\r\n```mysql\r\nmysql> show full processlist;\r\n+----+-----------------+--------------------+------------+---------+-------+--------------------------------------------------------+------------------------------------------------------------------------+\r\n| Id | User            | Host               | db         | Command | Time  | State                                                  | Info                                                                   |\r\n+----+-----------------+--------------------+------------+---------+-------+--------------------------------------------------------+------------------------------------------------------------------------+\r\n...\r\n| 95 | monitor         | 192.168.3.38:54306 | clickhouse | Query   |     0 | Sending data                                           | SELECT <column-list-omitted> FROM `clickhouse`.`clickhouse_responses` |\r\n+----+-----------------+--------------------+------------+---------+-------+--------------------------------------------------------+------------------------------------------------------------------------+\r\n8 rows in set (0.00 sec)\r\n```\r\n\r\nI tried on 18.14.9 as well, to see if it worked there:\r\n\r\n```\r\n# clickhouse client\r\nClickHouse client version 18.14.9.\r\nConnecting to localhost:9000.\r\nConnected to ClickHouse server version 18.14.9 revision 54409.\r\n\r\naba40f1edf29 :) select * from mysql('mysql-slave', 'clickhouse', 'clickhouse_responses', 'monitor', 'XXXXXXXXXXXXXXXXXXXX') where question_response_id in (4690063,4698156)\r\n\r\nSELECT *\r\nFROM mysql('10.108.188.46', 'clickhouse', 'clickhouse_responses', 'monitor', 'XXXXXXXXXXXXXXXXXXXX') \r\nWHERE question_response_id IN (4690063, 4698156)\r\n\r\n<resultset omitted>\r\n\r\n2 rows in set. Elapsed: 22.735 sec. Processed 3.73 million rows, 1.58 GB (164.03 thousand rows/s., 69.54 MB/s.) \r\n```\r\n\r\nSame thing: it retrieves all the rows and executes the `WHERE IN()` clause in Clickhouse.\r\n\r\nAm I misunderstanding how this functionality is supposed to work?\r\n\r\n\r\n\n",
  "hints_text": "Additionally, if you have single IN parameter, query is passed to mysql, but with wrong syntax (no parentheses for IN clause):\r\n\r\nClickHouse server version 18.14.15 revision 54409\r\n\r\nCH:\r\n```\r\nSELECT * FROM metrics.advertisers_list  WHERE advertiser_name IN ('XXX') OR campaign_name IN ('XXX')\r\n```\r\n\r\nMySQL:\r\n```\r\nSELECT `advertiser_id`, `advertiser_name`, `campaign_id`, `campaign_name`, `banner_id`, `banner_name`, `advertiser_domain`, `type`, `active` FROM `kx`.`advertisers`  WHERE (`advertiser_name` IN 'XXX') OR (`campaign_name` IN 'XXX')\r\n```\r\n\n@VadimPE do you have any suggestions for @Perlovka and myself?",
  "created_at": "2019-05-16T19:56:30Z"
}