{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 19084,
  "instance_id": "ClickHouse__ClickHouse-19084",
  "issue_numbers": [
    "19029"
  ],
  "base_commit": "09e825e28c768f5c52e0aef4d0e34fe48284c13a",
  "patch": "diff --git a/src/Functions/tupleHammingDistance.cpp b/src/Functions/tupleHammingDistance.cpp\nindex 67d5f73065b1..0fd21e0ea91b 100644\n--- a/src/Functions/tupleHammingDistance.cpp\n+++ b/src/Functions/tupleHammingDistance.cpp\n@@ -11,205 +11,144 @@ namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n }\n \n-template <typename A, typename B>\n-struct TupleHammingDistanceImpl\n+/// tupleHammingDistance function: (Tuple(...), Tuple(...))-> N\n+/// Return the number of non-equal tuple elements\n+class FunctionTupleHammingDistance : public IFunction\n {\n-    using ResultType = UInt8;\n-\n-    static void NO_INLINE vectorVector(\n-        const PaddedPODArray<A> & a1,\n-        const PaddedPODArray<A> & b1,\n-        const PaddedPODArray<B> & a2,\n-        const PaddedPODArray<B> & b2,\n-        PaddedPODArray<ResultType> & c)\n-    {\n-        size_t size = a1.size();\n-        for (size_t i = 0; i < size; ++i)\n-            c[i] = apply(a1[i], a2[i]) + apply(b1[i], b2[i]);\n-    }\n-\n-    static void NO_INLINE\n-    vectorConstant(const PaddedPODArray<A> & a1, const PaddedPODArray<A> & b1, UInt64 a2, UInt64 b2, PaddedPODArray<ResultType> & c)\n-    {\n-        size_t size = a1.size();\n-        for (size_t i = 0; i < size; ++i)\n-            c[i] = apply(a1[i], a2) + apply(b1[i], b2);\n-    }\n-\n-    static void NO_INLINE\n-    constantVector(UInt64 a1, UInt64 b1, const PaddedPODArray<B> & a2, const PaddedPODArray<B> & b2, PaddedPODArray<ResultType> & c)\n-    {\n-        size_t size = a2.size();\n-        for (size_t i = 0; i < size; ++i)\n-            c[i] = apply(a1, a2[i]) + apply(b1, b2[i]);\n-    }\n-\n-    static ResultType constantConstant(UInt64 a1, UInt64 b1, UInt64 a2, UInt64 b2) { return apply(a1, a2) + apply(b1, b2); }\n-\n private:\n-    static inline UInt8 apply(UInt64 a, UInt64 b) { return a != b; }\n-};\n-\n-template <typename F>\n-bool castType(const IDataType * type, F && f)\n-{\n-    return castTypeToEither<\n-        DataTypeInt8,\n-        DataTypeInt16,\n-        DataTypeInt32,\n-        DataTypeInt64,\n-        DataTypeUInt8,\n-        DataTypeUInt16,\n-        DataTypeUInt32,\n-        DataTypeUInt64>(type, std::forward<F>(f));\n-}\n-\n-template <typename F>\n-static bool castBothTypes(const IDataType * left, const IDataType * right, F && f)\n-{\n-    return castType(left, [&](const auto & left_) { return castType(right, [&](const auto & right_) { return f(left_, right_); }); });\n-}\n+    const Context & context;\n \n-// tupleHammingDistance function: (Tuple(Integer, Integer), Tuple(Integer, Integer))->0/1/2\n-// in order to avoid code bloating, for non-constant tuple, we make sure that the elements\n-// in the tuple should have same data type, and for constant tuple, elements can be any integer\n-// data type, we cast all of them into UInt64\n-class FunctionTupleHammingDistance : public IFunction\n-{\n public:\n     static constexpr auto name = \"tupleHammingDistance\";\n     using ResultType = UInt8;\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionTupleHammingDistance>(); }\n+\n+    explicit FunctionTupleHammingDistance(const Context & context_) : context(context_) {}\n+    static FunctionPtr create(const Context & context) { return std::make_shared<FunctionTupleHammingDistance>(context); }\n \n     String getName() const override { return name; }\n \n     size_t getNumberOfArguments() const override { return 2; }\n \n-    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    Columns getTupleElements(const IColumn & column) const\n     {\n-        if (!isTuple(arguments[0]))\n-            throw Exception(\n-                \"Illegal type \" + arguments[0]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        if (!isTuple(arguments[1]))\n-            throw Exception(\n-                \"Illegal type \" + arguments[1]->getName() + \" of argument of function \" + getName(), ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n-        return std::make_shared<DataTypeUInt8>();\n+        if (const auto * const_column = typeid_cast<const ColumnConst *>(&column))\n+            return convertConstTupleToConstantElements(*const_column);\n+\n+        if (const auto * column_tuple = typeid_cast<const ColumnTuple *>(&column))\n+        {\n+            Columns columns(column_tuple->tupleSize());\n+            for (size_t i = 0; i < columns.size(); ++i)\n+                columns[i] = column_tuple->getColumnPtr(i);\n+            return columns;\n+        }\n+\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument of function {} should be tuples, got {}\",\n+                        getName(), column.getName());\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        const ColumnWithTypeAndName & arg1 = arguments[0];\n-        const ColumnWithTypeAndName & arg2 = arguments[1];\n-        const DataTypeTuple & type1 = static_cast<const DataTypeTuple &>(*arg1.type);\n-        const DataTypeTuple & type2 = static_cast<const DataTypeTuple &>(*arg2.type);\n-        const auto & left_elems = type1.getElements();\n-        const auto & right_elems = type2.getElements();\n-        if (left_elems.size() != 2 || right_elems.size() != 2)\n-            throw Exception(\n-                \"Illegal column of arguments of function \" + getName() + \", tuple should have exactly two elements.\",\n-                ErrorCodes::ILLEGAL_COLUMN);\n-\n-        ColumnPtr result_column;\n-\n-        bool valid = castBothTypes(left_elems[0].get(), right_elems[0].get(), [&](const auto & left, const auto & right)\n+        const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n+\n+        if (!left_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 0 of function {} should be tuples, got {}\",\n+                            getName(), arguments[0].type->getName());\n+\n+        if (!right_tuple)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Argument 1 of function {} should be tuples, got {}\",\n+                            getName(), arguments[1].type->getName());\n+\n+        const auto & left_types = left_tuple->getElements();\n+        const auto & right_types = right_tuple->getElements();\n+\n+        Columns left_elements;\n+        Columns right_elements;\n+        if (arguments[0].column)\n+            left_elements = getTupleElements(*arguments[0].column);\n+        if (arguments[1].column)\n+            right_elements = getTupleElements(*arguments[1].column);\n+\n+        if (left_types.size() != right_types.size())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                            \"Expected tuples of the same size as arguments of function {}. Got {} and {}\",\n+                            getName(), arguments[0].type->getName(), arguments[1].type->getName());\n+\n+        size_t tuple_size = left_types.size();\n+        if (tuple_size == 0)\n+            return std::make_shared<DataTypeUInt8>();\n+\n+        auto compare = FunctionFactory::instance().get(\"notEquals\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        DataTypes types(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n         {\n-            using LeftDataType = std::decay_t<decltype(left)>;\n-            using RightDataType = std::decay_t<decltype(right)>;\n-            using T0 = typename LeftDataType::FieldType;\n-            using T1 = typename RightDataType::FieldType;\n-            using ColVecT0 = ColumnVector<T0>;\n-            using ColVecT1 = ColumnVector<T1>;\n-            using ColVecResult = ColumnVector<ResultType>;\n-\n-            using OpImpl = TupleHammingDistanceImpl<T0, T1>;\n-\n-            // we can not useDefaultImplementationForConstants,\n-            // because with that, tupleHammingDistance((10, 300), (10, 20)) does not work,\n-            // since 10 has data type UInt8, and 300 has data type UInt16\n-            if (const ColumnConst * const_col_left = checkAndGetColumnConst<ColumnTuple>(arg1.column.get()))\n-            {\n-                if (const ColumnConst * const_col_right = checkAndGetColumnConst<ColumnTuple>(arg2.column.get()))\n-                {\n-                    auto cols1 = convertConstTupleToConstantElements(*const_col_left);\n-                    auto cols2 = convertConstTupleToConstantElements(*const_col_right);\n-                    Field a1, b1, a2, b2;\n-                    cols1[0]->get(0, a1);\n-                    cols1[1]->get(0, b1);\n-                    cols2[0]->get(0, a2);\n-                    cols2[1]->get(0, b2);\n-                    auto res = OpImpl::constantConstant(a1.get<UInt64>(), b1.get<UInt64>(), a2.get<UInt64>(), b2.get<UInt64>());\n-                    result_column = DataTypeUInt8().createColumnConst(const_col_left->size(), toField(res));\n-                    return true;\n-                }\n-            }\n-\n-            typename ColVecResult::MutablePtr col_res = nullptr;\n-            col_res = ColVecResult::create();\n-            auto & vec_res = col_res->getData();\n-            vec_res.resize(input_rows_count);\n-            // constant tuple - non-constant tuple\n-            if (const ColumnConst * const_col_left = checkAndGetColumnConst<ColumnTuple>(arg1.column.get()))\n+            try\n             {\n-                if (const ColumnTuple * col_right = typeid_cast<const ColumnTuple *>(arg2.column.get()))\n-                {\n-                    auto const_cols = convertConstTupleToConstantElements(*const_col_left);\n-                    Field a1, b1;\n-                    const_cols[0]->get(0, a1);\n-                    const_cols[1]->get(0, b1);\n-                    auto col_r1 = checkAndGetColumn<ColVecT1>(&col_right->getColumn(0));\n-                    auto col_r2 = checkAndGetColumn<ColVecT1>(&col_right->getColumn(1));\n-                    if (col_r1 && col_r2)\n-                        OpImpl::constantVector(a1.get<UInt64>(), b1.get<UInt64>(), col_r1->getData(), col_r2->getData(), vec_res);\n-                    else\n-                        return false;\n-                }\n-                else\n-                    return false;\n+                ColumnWithTypeAndName left{left_elements.empty() ? nullptr : left_elements[i], left_types[i], {}};\n+                ColumnWithTypeAndName right{right_elements.empty() ? nullptr : right_elements[i], right_types[i], {}};\n+                auto elem_compare = compare->build(ColumnsWithTypeAndName{left, right});\n+                types[i] = elem_compare->getResultType();\n             }\n-            else if (const ColumnTuple * col_left = typeid_cast<const ColumnTuple *>(arg1.column.get()))\n+            catch (DB::Exception & e)\n             {\n-                auto col_l1 = checkAndGetColumn<ColVecT0>(&col_left->getColumn(0));\n-                auto col_l2 = checkAndGetColumn<ColVecT0>(&col_left->getColumn(1));\n-                if (col_l1 && col_l2)\n-                {\n-                    // non-constant tuple - constant tuple\n-                    if (const ColumnConst * const_col_right = checkAndGetColumnConst<ColumnTuple>(arg2.column.get()))\n-                    {\n-                        auto const_cols = convertConstTupleToConstantElements(*const_col_right);\n-                        Field a2, b2;\n-                        const_cols[0]->get(0, a2);\n-                        const_cols[1]->get(0, b2);\n-                        OpImpl::vectorConstant(col_l1->getData(), col_l2->getData(), a2.get<UInt64>(), a2.get<UInt64>(), vec_res);\n-                    }\n-                    // non-constant tuple - non-constant tuple\n-                    else if (const ColumnTuple * col_right = typeid_cast<const ColumnTuple *>(arg2.column.get()))\n-                    {\n-                        auto col_r1 = checkAndGetColumn<ColVecT1>(&col_right->getColumn(0));\n-                        auto col_r2 = checkAndGetColumn<ColVecT1>(&col_right->getColumn(1));\n-                        if (col_r1 && col_r2)\n-                            OpImpl::vectorVector(col_l1->getData(), col_l2->getData(), col_r1->getData(), col_r2->getData(), vec_res);\n-                        else\n-                            return false;\n-                    }\n-                    else\n-                        return false;\n-                }\n-                else\n-                    return false;\n+                e.addMessage(\"While executing function {} for tuple element {}\", getName(), i);\n+                throw;\n             }\n-            else\n-                return false;\n-            result_column = std::move(col_res);\n-            return true;\n-        });\n-        if (!valid)\n-            throw Exception(getName() + \"'s arguments do not match the expected data types\", ErrorCodes::ILLEGAL_COLUMN);\n-\n-        return result_column;\n+        }\n+\n+        auto res_type = types[0];\n+        for (size_t i = 1; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName left{res_type, {}};\n+            ColumnWithTypeAndName right{types[i], {}};\n+            auto plus_elem = plus->build({left, right});\n+            res_type = plus_elem->getResultType();\n+        }\n+\n+        return res_type;\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const auto * left_tuple = checkAndGetDataType<DataTypeTuple>(arguments[0].type.get());\n+        const auto * right_tuple = checkAndGetDataType<DataTypeTuple>(arguments[1].type.get());\n+        const auto & left_types = left_tuple->getElements();\n+        const auto & right_types = right_tuple->getElements();\n+        auto left_elements = getTupleElements(*arguments[0].column);\n+        auto right_elements = getTupleElements(*arguments[1].column);\n+\n+        size_t tuple_size = left_elements.size();\n+        if (tuple_size == 0)\n+            return DataTypeUInt8().createColumnConstWithDefaultValue(input_rows_count);\n+\n+        auto compare = FunctionFactory::instance().get(\"notEquals\", context);\n+        auto plus = FunctionFactory::instance().get(\"plus\", context);\n+        ColumnsWithTypeAndName columns(tuple_size);\n+        for (size_t i = 0; i < tuple_size; ++i)\n+        {\n+            ColumnWithTypeAndName left{left_elements[i], left_types[i], {}};\n+            ColumnWithTypeAndName right{right_elements[i], right_types[i], {}};\n+            auto elem_compare = compare->build(ColumnsWithTypeAndName{left, right});\n+            columns[i].type = elem_compare->getResultType();\n+            columns[i].column = elem_compare->execute({left, right}, columns[i].type, input_rows_count);\n+        }\n+\n+        auto res = columns[0];\n+        for (size_t i = 1; i < tuple_size; ++i)\n+        {\n+            auto plus_elem = plus->build({res, columns[i]});\n+            auto res_type = plus_elem->getResultType();\n+            res.column = plus_elem->execute({res, columns[i]}, res_type, input_rows_count);\n+            res.type = res_type;\n+        }\n+\n+        return res.column;\n     }\n };\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01653_tuple_hamming_distance_2.reference b/tests/queries/0_stateless/01653_tuple_hamming_distance_2.reference\nnew file mode 100644\nindex 000000000000..613ab096c8cb\n--- /dev/null\n+++ b/tests/queries/0_stateless/01653_tuple_hamming_distance_2.reference\n@@ -0,0 +1,18 @@\n+0\n+1\n+\\N\n+\\N\n+2\n+1\n+1\n+1\n+0\n+1\n+2\n+\\N\n+\\N\n+\\N\n+1\n+0\n+1\n+2\ndiff --git a/tests/queries/0_stateless/01653_tuple_hamming_distance_2.sql b/tests/queries/0_stateless/01653_tuple_hamming_distance_2.sql\nnew file mode 100644\nindex 000000000000..81afb1e12010\n--- /dev/null\n+++ b/tests/queries/0_stateless/01653_tuple_hamming_distance_2.sql\n@@ -0,0 +1,23 @@\n+SELECT tupleHammingDistance(tuple(1), tuple(1));\n+SELECT tupleHammingDistance(tuple(1), tuple(2));\n+SELECT tupleHammingDistance(tuple(1), tuple(Null));\n+SELECT tupleHammingDistance(tuple(Null), tuple(Null));\n+SELECT tupleHammingDistance((1, 2), (3, 4));\n+SELECT tupleHammingDistance((1, 2), (1, 4));\n+SELECT tupleHammingDistance(materialize((1, 2)), (1, 4));\n+SELECT tupleHammingDistance(materialize((1, 2)),materialize ((1, 4)));\n+SELECT tupleHammingDistance((1, 2), (1, 2));\n+SELECT tupleHammingDistance((1, 2), (1, 257));\n+SELECT tupleHammingDistance((1, 2, 3), (1, 257, 65537));\n+SELECT tupleHammingDistance((1, 2), (1, Null));\n+SELECT tupleHammingDistance((1, Null), (1, Null));\n+SELECT tupleHammingDistance((Null, Null), (Null, Null));\n+SELECT tupleHammingDistance(('abc', 2), ('abc', 257));\n+SELECT tupleHammingDistance(('abc', (1, 2)), ('abc', (1, 2)));\n+SELECT tupleHammingDistance(('abc', (1, 2)), ('def', (1, 2)));\n+SELECT tupleHammingDistance(('abc', (1, 2)), ('def', (1, 3)));\n+\n+\n+SELECT tupleHammingDistance(tuple(1), tuple(1, 1)); --{serverError 43}\n+SELECT tupleHammingDistance(tuple(1), tuple('a')); --{serverError 386}\n+SELECT tupleHammingDistance((1, 3), (3, 'a')); --{serverError 386}\n",
  "problem_statement": "tupleHammingDistance: Logical error: 'Invalid Field get from type Null to type UInt64'.\n**Describe the bug**\r\nhttps://clickhouse-test-reports.s3.yandex.net/18723/5f962015caf6e48f3ec5ea115a8f424e88741c8b/fuzzer/report.html#fail1\r\n\r\n**How to reproduce**\r\n`SELECT tupleHammingDistance((65537, 256), (1025, NULL))`\r\n\n",
  "hints_text": "",
  "created_at": "2021-01-14T16:15:43Z"
}