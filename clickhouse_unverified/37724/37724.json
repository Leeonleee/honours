{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37724,
  "instance_id": "ClickHouse__ClickHouse-37724",
  "issue_numbers": [
    "36037"
  ],
  "base_commit": "77c06447d56fbcb9483047435dc0e03d652f409e",
  "patch": "diff --git a/src/Interpreters/SelectQueryOptions.h b/src/Interpreters/SelectQueryOptions.h\nindex b0183e2761b0..032befe19937 100644\n--- a/src/Interpreters/SelectQueryOptions.h\n+++ b/src/Interpreters/SelectQueryOptions.h\n@@ -135,7 +135,7 @@ struct SelectQueryOptions\n         return *this;\n     }\n \n-    SelectQueryOptions & ignoreASTOptimizationsAlias(bool value = true)\n+    SelectQueryOptions & ignoreASTOptimizations(bool value = true)\n     {\n         ignore_ast_optimizations = value;\n         return *this;\ndiff --git a/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp b/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp\nindex ed9cdf547c25..854a677afb97 100644\n--- a/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp\n+++ b/src/Processors/QueryPlan/DistributedCreateLocalPlan.cpp\n@@ -46,8 +46,15 @@ std::unique_ptr<QueryPlan> createLocalPlan(\n     checkStackSize();\n \n     auto query_plan = std::make_unique<QueryPlan>();\n+    /// Do not apply AST optimizations, because query\n+    /// is already optimized and some optimizations\n+    /// can be applied only for non-distributed tables\n+    /// and we can produce query, inconsistent with remote plans.\n     auto interpreter = InterpreterSelectQuery(\n-        query_ast, context, SelectQueryOptions(processed_stage).setShardInfo(shard_num, shard_count));\n+        query_ast, context,\n+        SelectQueryOptions(processed_stage)\n+            .setShardInfo(shard_num, shard_count)\n+            .ignoreASTOptimizations());\n \n     interpreter.setProperClientInfo();\n     if (coordinator)\ndiff --git a/src/Storages/ProjectionsDescription.cpp b/src/Storages/ProjectionsDescription.cpp\nindex 5e9966a27942..ad35c5d420b7 100644\n--- a/src/Storages/ProjectionsDescription.cpp\n+++ b/src/Storages/ProjectionsDescription.cpp\n@@ -109,7 +109,7 @@ ProjectionDescription::getProjectionFromAST(const ASTPtr & definition_ast, const\n     InterpreterSelectQuery select(\n         result.query_ast, query_context, storage, {},\n         /// Here we ignore ast optimizations because otherwise aggregation keys may be removed from result header as constants.\n-        SelectQueryOptions{QueryProcessingStage::WithMergeableState}.modify().ignoreAlias().ignoreASTOptimizationsAlias());\n+        SelectQueryOptions{QueryProcessingStage::WithMergeableState}.modify().ignoreAlias().ignoreASTOptimizations());\n \n     result.required_columns = select.getRequiredColumns();\n     result.sample_block = select.getSampleBlock();\n@@ -221,7 +221,7 @@ ProjectionDescription ProjectionDescription::getMinMaxCountProjection(\n     InterpreterSelectQuery select(\n         result.query_ast, query_context, storage, {},\n         /// Here we ignore ast optimizations because otherwise aggregation keys may be removed from result header as constants.\n-        SelectQueryOptions{QueryProcessingStage::WithMergeableState}.modify().ignoreAlias().ignoreASTOptimizationsAlias());\n+        SelectQueryOptions{QueryProcessingStage::WithMergeableState}.modify().ignoreAlias().ignoreASTOptimizations());\n     result.required_columns = select.getRequiredColumns();\n     result.sample_block = select.getSampleBlock();\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02315_optimize_monotonous_functions_in_order_by_remote.reference b/tests/queries/0_stateless/02315_optimize_monotonous_functions_in_order_by_remote.reference\nnew file mode 100644\nindex 000000000000..aa47d0d46d47\n--- /dev/null\n+++ b/tests/queries/0_stateless/02315_optimize_monotonous_functions_in_order_by_remote.reference\n@@ -0,0 +1,2 @@\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02315_optimize_monotonous_functions_in_order_by_remote.sql b/tests/queries/0_stateless/02315_optimize_monotonous_functions_in_order_by_remote.sql\nnew file mode 100644\nindex 000000000000..6a5e4a0ae65e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02315_optimize_monotonous_functions_in_order_by_remote.sql\n@@ -0,0 +1,6 @@\n+SET prefer_localhost_replica = 1;\n+SET optimize_monotonous_functions_in_order_by = 1;\n+\n+SELECT *\n+FROM cluster(test_cluster_two_shards_localhost, system, one)\n+ORDER BY toDateTime(dummy);\n",
  "problem_statement": "DB::Exception: Cannot find column `toDateTime(number)` in source stream, there are only columns: [number]. (THERE_IS_NO_COLUMN)\n**How to check**\r\n```\r\nCREATE TABLE test_local on cluster '{cluster}' (number UInt64) ENGINE = MergeTree() ORDER BY number;\r\nCREATE TABLE test_distruted (number UInt64) ENGINE = Distributed('{cluster}', currentDatabase(), test_local);\r\n\r\nINSERT INTO test_local SELECT number from system.numbers limit 3;\r\n\r\nselect number from test_distruted order by toDateTime(number) DESC;\r\n```\r\n\r\nWithout distributed table (only merge tree) it work's correctly\r\n\r\n**Versions**\r\n21.12.4 - ok\r\n22.2.3 - ok\r\n22.3.2 - not ok\n",
  "hints_text": "If i set optimize_monotonous_functions_in_order_by=0 it work's correct\n```sql\r\nSELECT *\r\nFROM cluster(test_cluster_two_shards_localhost, system, one)\r\nORDER BY toDateTime(dummy) DESC\r\nSETTINGS optimize_monotonous_functions_in_order_by = 0;\r\n\u250c\u2500dummy\u2500\u2510\r\n\u2502     0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\u250c\u2500dummy\u2500\u2510\r\n\u2502     0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT *\r\nFROM cluster(test_cluster_two_shards_localhost, system, one)\r\nORDER BY toDateTime(dummy) DESC\r\nSETTINGS optimize_monotonous_functions_in_order_by = 1;\r\n\r\n DB::Exception: Cannot find column `toDateTime(dummy)` in source stream, there are only columns: [dummy].\r\n```",
  "created_at": "2022-06-01T00:52:52Z"
}