diff --git a/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h b/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h
index 5969fca9dcf9..443d76f47cb3 100644
--- a/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h
+++ b/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h
@@ -6,6 +6,7 @@
 
 #include <Common/ArenaAllocator.h>
 #include <Common/assert_cast.h>
+#include <base/arithmeticOverflow.h>
 
 #include <DataTypes/DataTypeDateTime.h>
 #include <DataTypes/DataTypesNumber.h>
@@ -15,6 +16,7 @@
 
 #include <unordered_set>
 
+
 namespace DB
 {
 
@@ -23,12 +25,11 @@ namespace ErrorCodes
     extern const int TOO_LARGE_ARRAY_SIZE;
 }
 
-/**
- * Calculate total length of intervals without intersections. Each interval is the pair of numbers [begin, end];
- * Return UInt64 for integral types (UInt/Int*, Date/DateTime) and return Float64 for Float*.
- *
- * Implementation simply stores intervals sorted by beginning and sums lengths at final.
- */
+/** Calculate total length of intervals without intersections. Each interval is the pair of numbers [begin, end];
+  * Returns UInt64 for integral types (UInt/Int*, Date/DateTime) and returns Float64 for Float*.
+  *
+  * Implementation simply stores intervals sorted by beginning and sums lengths at final.
+  */
 template <typename T>
 struct AggregateFunctionIntervalLengthSumData
 {
@@ -43,10 +44,14 @@ struct AggregateFunctionIntervalLengthSumData
 
     void add(T begin, T end)
     {
+        /// Reversed intervals are counted by absolute value of their length.
+        if (unlikely(end < begin))
+            std::swap(begin, end);
+        else if (unlikely(begin == end))
+            return;
+
         if (sorted && !segments.empty())
-        {
             sorted = segments.back().first <= begin;
-        }
         segments.emplace_back(begin, end);
     }
 
@@ -130,6 +135,11 @@ template <typename T, typename Data>
 class AggregateFunctionIntervalLengthSum final : public IAggregateFunctionDataHelper<Data, AggregateFunctionIntervalLengthSum<T, Data>>
 {
 private:
+    static auto NO_SANITIZE_UNDEFINED length(typename Data::Segment segment)
+    {
+        return segment.second - segment.first;
+    }
+
     template <typename TResult>
     TResult getIntervalLengthSum(Data & data) const
     {
@@ -140,21 +150,24 @@ class AggregateFunctionIntervalLengthSum final : public IAggregateFunctionDataHe
 
         TResult res = 0;
 
-        typename Data::Segment cur_segment = data.segments[0];
+        typename Data::Segment curr_segment = data.segments[0];
 
-        for (size_t i = 1, sz = data.segments.size(); i < sz; ++i)
+        for (size_t i = 1, size = data.segments.size(); i < size; ++i)
         {
-            /// Check if current interval intersect with next one then add length, otherwise advance interval end
-            if (cur_segment.second < data.segments[i].first)
+            const typename Data::Segment & next_segment = data.segments[i];
+
+            /// Check if current interval intersects with next one then add length, otherwise advance interval end.
+            if (curr_segment.second < next_segment.first)
             {
-                res += cur_segment.second - cur_segment.first;
-                cur_segment = data.segments[i];
+                res += length(curr_segment);
+                curr_segment = next_segment;
+            }
+            else if (next_segment.second > curr_segment.second)
+            {
+                curr_segment.second = next_segment.second;
             }
-            else
-                cur_segment.second = std::max(cur_segment.second, data.segments[i].second);
         }
-
-        res += cur_segment.second - cur_segment.first;
+        res += length(curr_segment);
 
         return res;
     }
