{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33335,
  "instance_id": "ClickHouse__ClickHouse-33335",
  "issue_numbers": [
    "33323"
  ],
  "base_commit": "b5ee8cb694cb82fc5cb008189e7b6cf5ae728059",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h b/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h\nindex 5969fca9dcf9..443d76f47cb3 100644\n--- a/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h\n+++ b/src/AggregateFunctions/AggregateFunctionIntervalLengthSum.h\n@@ -6,6 +6,7 @@\n \n #include <Common/ArenaAllocator.h>\n #include <Common/assert_cast.h>\n+#include <base/arithmeticOverflow.h>\n \n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypesNumber.h>\n@@ -15,6 +16,7 @@\n \n #include <unordered_set>\n \n+\n namespace DB\n {\n \n@@ -23,12 +25,11 @@ namespace ErrorCodes\n     extern const int TOO_LARGE_ARRAY_SIZE;\n }\n \n-/**\n- * Calculate total length of intervals without intersections. Each interval is the pair of numbers [begin, end];\n- * Return UInt64 for integral types (UInt/Int*, Date/DateTime) and return Float64 for Float*.\n- *\n- * Implementation simply stores intervals sorted by beginning and sums lengths at final.\n- */\n+/** Calculate total length of intervals without intersections. Each interval is the pair of numbers [begin, end];\n+  * Returns UInt64 for integral types (UInt/Int*, Date/DateTime) and returns Float64 for Float*.\n+  *\n+  * Implementation simply stores intervals sorted by beginning and sums lengths at final.\n+  */\n template <typename T>\n struct AggregateFunctionIntervalLengthSumData\n {\n@@ -43,10 +44,14 @@ struct AggregateFunctionIntervalLengthSumData\n \n     void add(T begin, T end)\n     {\n+        /// Reversed intervals are counted by absolute value of their length.\n+        if (unlikely(end < begin))\n+            std::swap(begin, end);\n+        else if (unlikely(begin == end))\n+            return;\n+\n         if (sorted && !segments.empty())\n-        {\n             sorted = segments.back().first <= begin;\n-        }\n         segments.emplace_back(begin, end);\n     }\n \n@@ -130,6 +135,11 @@ template <typename T, typename Data>\n class AggregateFunctionIntervalLengthSum final : public IAggregateFunctionDataHelper<Data, AggregateFunctionIntervalLengthSum<T, Data>>\n {\n private:\n+    static auto NO_SANITIZE_UNDEFINED length(typename Data::Segment segment)\n+    {\n+        return segment.second - segment.first;\n+    }\n+\n     template <typename TResult>\n     TResult getIntervalLengthSum(Data & data) const\n     {\n@@ -140,21 +150,24 @@ class AggregateFunctionIntervalLengthSum final : public IAggregateFunctionDataHe\n \n         TResult res = 0;\n \n-        typename Data::Segment cur_segment = data.segments[0];\n+        typename Data::Segment curr_segment = data.segments[0];\n \n-        for (size_t i = 1, sz = data.segments.size(); i < sz; ++i)\n+        for (size_t i = 1, size = data.segments.size(); i < size; ++i)\n         {\n-            /// Check if current interval intersect with next one then add length, otherwise advance interval end\n-            if (cur_segment.second < data.segments[i].first)\n+            const typename Data::Segment & next_segment = data.segments[i];\n+\n+            /// Check if current interval intersects with next one then add length, otherwise advance interval end.\n+            if (curr_segment.second < next_segment.first)\n             {\n-                res += cur_segment.second - cur_segment.first;\n-                cur_segment = data.segments[i];\n+                res += length(curr_segment);\n+                curr_segment = next_segment;\n+            }\n+            else if (next_segment.second > curr_segment.second)\n+            {\n+                curr_segment.second = next_segment.second;\n             }\n-            else\n-                cur_segment.second = std::max(cur_segment.second, data.segments[i].second);\n         }\n-\n-        res += cur_segment.second - cur_segment.first;\n+        res += length(curr_segment);\n \n         return res;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02158_interval_length_sum.reference b/tests/queries/0_stateless/02158_interval_length_sum.reference\nnew file mode 100644\nindex 000000000000..b4de39476753\n--- /dev/null\n+++ b/tests/queries/0_stateless/02158_interval_length_sum.reference\n@@ -0,0 +1,1 @@\n+11\ndiff --git a/tests/queries/0_stateless/02158_interval_length_sum.sql b/tests/queries/0_stateless/02158_interval_length_sum.sql\nnew file mode 100644\nindex 000000000000..af22a707caf5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02158_interval_length_sum.sql\n@@ -0,0 +1,1 @@\n+SELECT intervalLengthSum(x, y) FROM values('x Int64, y Int64', (0, 10), (5, 5), (5, 6), (1, -1));\n",
  "problem_statement": "intervalLengthSum(10, 5) UInt64 overflow\n**How to reproduce**\r\n```\r\nSELECT\r\n    intervalLengthSum(10, 5) AS res,\r\n    toInt64(res) AS cast,\r\n    toTypeName(res) AS type\r\n\r\nQuery id: bc8307c2-a520-4499-959e-bb00e0bdf055\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500res\u2500\u252c\u2500cast\u2500\u252c\u2500type\u2500\u2500\u2500\u2510\r\n\u2502 18446744073709551611 \u2502   -5 \u2502 UInt64 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**Expected behavior**\r\nintervals with negative sum will be converted to zero.\n",
  "hints_text": "Why don't simply change the result type to signed integer?\nIt's also possible,\r\n\r\nBut i think it would be useful, if it will be possible to \"skip\" incorrect intervals.\r\n\r\nAnother alternative, new function (like for arrayCumSumNonNegative) -> intervalLengthSumNonNegative\r\n\r\n",
  "created_at": "2021-12-30T20:54:22Z"
}