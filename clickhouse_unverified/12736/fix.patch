diff --git a/contrib/libhdfs3 b/contrib/libhdfs3
index 24b058c35679..30552ac527f2 160000
--- a/contrib/libhdfs3
+++ b/contrib/libhdfs3
@@ -1,1 +1,1 @@
-Subproject commit 24b058c356794ef6cc2d31323dc9adf0386652ff
+Subproject commit 30552ac527f2c14070d834e171493b2e7f662375
diff --git a/programs/server/config.xml b/programs/server/config.xml
index 83921b123824..bf41a331a365 100644
--- a/programs/server/config.xml
+++ b/programs/server/config.xml
@@ -212,22 +212,10 @@
     <!-- Directory with user provided files that are accessible by 'file' table function. -->
     <user_files_path>/var/lib/clickhouse/user_files/</user_files_path>
 
-    <!-- Sources to read users, roles, access rights, profiles of settings, quotas. -->
-    <user_directories>
-        <users_xml>
-            <!-- Path to configuration file with predefined users. -->
-            <path>users.xml</path>
-        </users_xml>
-        <local_directory>
-            <!-- Path to folder where users created by SQL commands are stored. -->
-            <path>/var/lib/clickhouse/access/</path>
-        </local_directory>
-    </user_directories>
-
-    <!-- External user directories (LDAP). -->
+    <!-- LDAP server definitions. -->
     <ldap_servers>
-        <!-- List LDAP servers with their connection parameters here to later use them as authenticators for dedicated users,
-             who have 'ldap' authentication mechanism specified instead of 'password'.
+        <!-- List LDAP servers with their connection parameters here to later 1) use them as authenticators for dedicated local users,
+              who have 'ldap' authentication mechanism specified instead of 'password', or to 2) use them as remote user directories.
              Parameters:
                 host - LDAP server hostname or IP, this parameter is mandatory and cannot be empty.
                 port - LDAP server port, default is 636 if enable_tls is set to true, 389 otherwise.
@@ -246,7 +234,7 @@
                 tls_key_file - path to certificate key file.
                 tls_ca_cert_file - path to CA certificate file.
                 tls_ca_cert_dir - path to the directory containing CA certificates.
-                tls_cipher_suite - allowed cipher suite.
+                tls_cipher_suite - allowed cipher suite (in OpenSSL notation).
              Example:
                 <my_ldap_server>
                     <host>localhost</host>
@@ -265,6 +253,36 @@
         -->
     </ldap_servers>
 
+    <!-- Sources to read users, roles, access rights, profiles of settings, quotas. -->
+    <user_directories>
+        <users_xml>
+            <!-- Path to configuration file with predefined users. -->
+            <path>users.xml</path>
+        </users_xml>
+        <local_directory>
+            <!-- Path to folder where users created by SQL commands are stored. -->
+            <path>/var/lib/clickhouse/access/</path>
+        </local_directory>
+
+        <!-- To add an LDAP server as a remote user directory of users that are not defined locally, define a single 'ldap' section
+              with the following parameters:
+                server - one of LDAP server names defined in 'ldap_servers' config section above.
+                        This parameter is mandatory and cannot be empty.
+                roles - section with a list of locally defined roles that will be assigned to each user retrieved from the LDAP server.
+                        If no roles are specified, user will not be able to perform any actions after authentication.
+                        If any of the listed roles is not defined locally at the time of authentication, the authenthication attept
+                         will fail as if the provided password was incorrect.
+             Example:
+                <ldap>
+                    <server>my_ldap_server</server>
+                    <roles>
+                        <my_local_role1 />
+                        <my_local_role2 />
+                    </roles>
+                </ldap>
+        -->
+    </user_directories>
+
     <!-- Default profile of settings. -->
     <default_profile>default</default_profile>
 
diff --git a/src/Access/AccessControlManager.cpp b/src/Access/AccessControlManager.cpp
index ecbb02966f00..56d225f64f4c 100644
--- a/src/Access/AccessControlManager.cpp
+++ b/src/Access/AccessControlManager.cpp
@@ -3,6 +3,7 @@
 #include <Access/MemoryAccessStorage.h>
 #include <Access/UsersConfigAccessStorage.h>
 #include <Access/DiskAccessStorage.h>
+#include <Access/LDAPAccessStorage.h>
 #include <Access/ContextAccess.h>
 #include <Access/RoleCache.h>
 #include <Access/RowPolicyCache.h>
@@ -253,6 +254,12 @@ void AccessControlManager::addMemoryStorage(const String & storage_name_)
 }
 
 
+void AccessControlManager::addLDAPStorage(const String & storage_name_, const Poco::Util::AbstractConfiguration & config_, const String & prefix_)
+{
+    addStorage(std::make_shared<LDAPAccessStorage>(storage_name_, this, config_, prefix_));
+}
+
+
 void AccessControlManager::addStoragesFromUserDirectoriesConfig(
     const Poco::Util::AbstractConfiguration & config,
     const String & key,
@@ -275,6 +282,8 @@ void AccessControlManager::addStoragesFromUserDirectoriesConfig(
             type = UsersConfigAccessStorage::STORAGE_TYPE;
         else if ((type == "local") || (type == "local_directory"))
             type = DiskAccessStorage::STORAGE_TYPE;
+        else if (type == "ldap")
+            type = LDAPAccessStorage::STORAGE_TYPE;
 
         String name = config.getString(prefix + ".name", type);
 
@@ -295,6 +304,10 @@ void AccessControlManager::addStoragesFromUserDirectoriesConfig(
             bool readonly = config.getBool(prefix + ".readonly", false);
             addDiskStorage(name, path, readonly);
         }
+        else if (type == LDAPAccessStorage::STORAGE_TYPE)
+        {
+            addLDAPStorage(name, config, prefix);
+        }
         else
             throw Exception("Unknown storage type '" + type + "' at " + prefix + " in config", ErrorCodes::UNKNOWN_ELEMENT_IN_CONFIG);
     }
@@ -346,7 +359,7 @@ UUID AccessControlManager::login(const String & user_name, const String & passwo
 
 void AccessControlManager::setExternalAuthenticatorsConfig(const Poco::Util::AbstractConfiguration & config)
 {
-    external_authenticators->setConfig(config, getLogger());
+    external_authenticators->setConfiguration(config, getLogger());
 }
 
 
diff --git a/src/Access/AccessControlManager.h b/src/Access/AccessControlManager.h
index 81a66ce8f1dd..c960b330ee6a 100644
--- a/src/Access/AccessControlManager.h
+++ b/src/Access/AccessControlManager.h
@@ -82,6 +82,9 @@ class AccessControlManager : public MultipleAccessStorage
     void addMemoryStorage();
     void addMemoryStorage(const String & storage_name_);
 
+    /// Adds LDAPAccessStorage which allows querying remote LDAP server for user info.
+    void addLDAPStorage(const String & storage_name_, const Poco::Util::AbstractConfiguration & config_, const String & prefix_);
+
     /// Adds storages from <users_directories> config.
     void addStoragesFromUserDirectoriesConfig(const Poco::Util::AbstractConfiguration & config,
                                               const String & key,
diff --git a/src/Access/ExternalAuthenticators.cpp b/src/Access/ExternalAuthenticators.cpp
index a0c5fbf1a795..3ed1b21c3c2a 100644
--- a/src/Access/ExternalAuthenticators.cpp
+++ b/src/Access/ExternalAuthenticators.cpp
@@ -156,7 +156,7 @@ void ExternalAuthenticators::reset()
     ldap_server_params.clear();
 }
 
-void ExternalAuthenticators::setConfig(const Poco::Util::AbstractConfiguration & config, Poco::Logger * log)
+void ExternalAuthenticators::setConfiguration(const Poco::Util::AbstractConfiguration & config, Poco::Logger * log)
 {
     std::scoped_lock lock(mutex);
     reset();
diff --git a/src/Access/ExternalAuthenticators.h b/src/Access/ExternalAuthenticators.h
index 7484996c4729..7502409d817c 100644
--- a/src/Access/ExternalAuthenticators.h
+++ b/src/Access/ExternalAuthenticators.h
@@ -26,7 +26,7 @@ class ExternalAuthenticators
 {
 public:
     void reset();
-    void setConfig(const Poco::Util::AbstractConfiguration & config, Poco::Logger * log);
+    void setConfiguration(const Poco::Util::AbstractConfiguration & config, Poco::Logger * log);
 
     void setLDAPServerParams(const String & server, const LDAPServerParams & params);
     LDAPServerParams getLDAPServerParams(const String & server) const;
diff --git a/src/Access/IAccessStorage.cpp b/src/Access/IAccessStorage.cpp
index e5170221e185..8dd219e07d79 100644
--- a/src/Access/IAccessStorage.cpp
+++ b/src/Access/IAccessStorage.cpp
@@ -14,6 +14,8 @@ namespace ErrorCodes
     extern const int ACCESS_ENTITY_ALREADY_EXISTS;
     extern const int ACCESS_ENTITY_NOT_FOUND;
     extern const int ACCESS_STORAGE_READONLY;
+    extern const int WRONG_PASSWORD;
+    extern const int IP_ADDRESS_NOT_ALLOWED;
     extern const int AUTHENTICATION_FAILED;
     extern const int LOGICAL_ERROR;
 }
@@ -418,9 +420,21 @@ UUID IAccessStorage::login(
     const String & user_name,
     const String & password,
     const Poco::Net::IPAddress & address,
-    const ExternalAuthenticators & external_authenticators) const
+    const ExternalAuthenticators & external_authenticators,
+    bool replace_exception_with_cannot_authenticate) const
 {
-    return loginImpl(user_name, password, address, external_authenticators);
+    try
+    {
+        return loginImpl(user_name, password, address, external_authenticators);
+    }
+    catch (...)
+    {
+        if (!replace_exception_with_cannot_authenticate)
+            throw;
+
+        tryLogCurrentException(getLogger(), user_name + ": Authentication failed");
+        throwCannotAuthenticate(user_name);
+    }
 }
 
 
@@ -434,11 +448,16 @@ UUID IAccessStorage::loginImpl(
     {
         if (auto user = tryRead<User>(*id))
         {
-            if (isPasswordCorrectImpl(*user, password, external_authenticators) && isAddressAllowedImpl(*user, address))
-                return *id;
+            if (!isPasswordCorrectImpl(*user, password, external_authenticators))
+                throwInvalidPassword();
+
+            if (!isAddressAllowedImpl(*user, address))
+                throwAddressNotAllowed(address);
+
+            return *id;
         }
     }
-    throwCannotAuthenticate(user_name);
+    throwNotFound(EntityType::USER, user_name);
 }
 
 
@@ -554,6 +573,15 @@ void IAccessStorage::throwReadonlyCannotRemove(EntityType type, const String & n
         ErrorCodes::ACCESS_STORAGE_READONLY);
 }
 
+void IAccessStorage::throwAddressNotAllowed(const Poco::Net::IPAddress & address)
+{
+    throw Exception("Connections from " + address.toString() + " are not allowed", ErrorCodes::IP_ADDRESS_NOT_ALLOWED);
+}
+
+void IAccessStorage::throwInvalidPassword()
+{
+    throw Exception("Invalid password", ErrorCodes::WRONG_PASSWORD);
+}
 
 void IAccessStorage::throwCannotAuthenticate(const String & user_name)
 {
diff --git a/src/Access/IAccessStorage.h b/src/Access/IAccessStorage.h
index 5a86e817fb21..ecf6b2607122 100644
--- a/src/Access/IAccessStorage.h
+++ b/src/Access/IAccessStorage.h
@@ -144,7 +144,7 @@ class IAccessStorage
 
     /// Finds an user, check its password and returns the ID of the user.
     /// Throws an exception if no such user or password is incorrect.
-    UUID login(const String & user_name, const String & password, const Poco::Net::IPAddress & address, const ExternalAuthenticators & external_authenticators) const;
+    UUID login(const String & user_name, const String & password, const Poco::Net::IPAddress & address, const ExternalAuthenticators & external_authenticators, bool replace_exception_with_cannot_authenticate = true) const;
 
     /// Returns the ID of an user who has logged in (maybe on another node).
     /// The function assumes that the password has been already checked somehow, so we can skip checking it now.
@@ -182,6 +182,8 @@ class IAccessStorage
     [[noreturn]] void throwReadonlyCannotInsert(EntityType type, const String & name) const;
     [[noreturn]] void throwReadonlyCannotUpdate(EntityType type, const String & name) const;
     [[noreturn]] void throwReadonlyCannotRemove(EntityType type, const String & name) const;
+    [[noreturn]] static void throwAddressNotAllowed(const Poco::Net::IPAddress & address);
+    [[noreturn]] static void throwInvalidPassword();
     [[noreturn]] static void throwCannotAuthenticate(const String & user_name);
 
     using Notification = std::tuple<OnChangedHandler, UUID, AccessEntityPtr>;
diff --git a/src/Access/LDAPAccessStorage.cpp b/src/Access/LDAPAccessStorage.cpp
new file mode 100644
index 000000000000..cf5e7673e40e
--- /dev/null
+++ b/src/Access/LDAPAccessStorage.cpp
@@ -0,0 +1,313 @@
+#include <Access/LDAPAccessStorage.h>
+#include <Access/AccessControlManager.h>
+#include <Access/User.h>
+#include <Access/Role.h>
+#include <Common/Exception.h>
+#include <common/logger_useful.h>
+#include <ext/scope_guard.h>
+#include <Poco/Util/AbstractConfiguration.h>
+#include <Poco/JSON/JSON.h>
+#include <Poco/JSON/Object.h>
+#include <Poco/JSON/Stringifier.h>
+#include <boost/range/algorithm/copy.hpp>
+#include <iterator>
+#include <sstream>
+
+
+namespace DB
+{
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+}
+
+
+LDAPAccessStorage::LDAPAccessStorage(const String & storage_name_, AccessControlManager * access_control_manager_, const Poco::Util::AbstractConfiguration & config, const String & prefix)
+    : IAccessStorage(storage_name_)
+{
+    setConfiguration(access_control_manager_, config, prefix);
+}
+
+
+void LDAPAccessStorage::setConfiguration(AccessControlManager * access_control_manager_, const Poco::Util::AbstractConfiguration & config, const String & prefix)
+{
+    std::scoped_lock lock(mutex);
+
+    // TODO: switch to passing config as a ConfigurationView and remove this extra prefix once a version of Poco with proper implementation is available.
+    const String prefix_str = (prefix.empty() ? "" : prefix + ".");
+
+    const bool has_server = config.has(prefix_str + "server");
+    const bool has_roles = config.has(prefix_str + "roles");
+
+    if (!has_server)
+        throw Exception("Missing 'server' field for LDAP user directory.", ErrorCodes::BAD_ARGUMENTS);
+
+    const auto ldap_server_cfg = config.getString(prefix_str + "server");
+    if (ldap_server_cfg.empty())
+        throw Exception("Empty 'server' field for LDAP user directory.", ErrorCodes::BAD_ARGUMENTS);
+
+    std::set<String> roles_cfg;
+    if (has_roles)
+    {
+        Poco::Util::AbstractConfiguration::Keys role_names;
+        config.keys(prefix_str + "roles", role_names);
+
+        // Currently, we only extract names of roles from the section names and assign them directly and unconditionally.
+        roles_cfg.insert(role_names.begin(), role_names.end());
+    }
+
+    access_control_manager = access_control_manager_;
+    ldap_server = ldap_server_cfg;
+    default_role_names.swap(roles_cfg);
+    roles_of_interest.clear();
+    role_change_subscription = access_control_manager->subscribeForChanges<Role>(
+        [this] (const UUID & id, const AccessEntityPtr & entity)
+        {
+            return this->processRoleChange(id, entity);
+        }
+    );
+
+    /// Update `roles_of_interests` with initial values.
+    for (const auto & role_name : default_role_names)
+    {
+        if (auto role_id = access_control_manager->find<Role>(role_name))
+            roles_of_interest.emplace(*role_id, role_name);
+    }
+}
+
+
+void LDAPAccessStorage::processRoleChange(const UUID & id, const AccessEntityPtr & entity)
+{
+    std::scoped_lock lock(mutex);
+
+    /// Update `roles_of_interests`.
+    auto role = typeid_cast<std::shared_ptr<const Role>>(entity);
+    bool need_to_update_users = false;
+
+    if (role && default_role_names.count(role->getName()))
+    {
+        /// If a role was created with one of the `default_role_names` or renamed to one of the `default_role_names`,
+        /// then set `need_to_update_users`.
+        need_to_update_users = roles_of_interest.insert_or_assign(id, role->getName()).second;
+    }
+    else
+    {
+        /// If a role was removed or renamed to a name which isn't contained in the `default_role_names`,
+        /// then set `need_to_update_users`.
+        need_to_update_users = roles_of_interest.erase(id) > 0;
+    }
+
+    /// Update users which have been created.
+    if (need_to_update_users)
+    {
+        auto update_func = [this] (const AccessEntityPtr & entity_) -> AccessEntityPtr
+        {
+            if (auto user = typeid_cast<std::shared_ptr<const User>>(entity_))
+            {
+                auto changed_user = typeid_cast<std::shared_ptr<User>>(user->clone());
+                auto & granted_roles = changed_user->granted_roles.roles;
+                granted_roles.clear();
+                boost::range::copy(roles_of_interest | boost::adaptors::map_keys, std::inserter(granted_roles, granted_roles.end()));
+                return changed_user;
+            }
+            return entity_;
+        };
+        memory_storage.update(memory_storage.findAll<User>(), update_func);
+    }
+}
+
+
+void LDAPAccessStorage::checkAllDefaultRoleNamesFoundNoLock() const
+{
+    boost::container::flat_set<std::string_view> role_names_of_interest;
+    boost::range::copy(roles_of_interest | boost::adaptors::map_values, std::inserter(role_names_of_interest, role_names_of_interest.end()));
+
+    for (const auto & role_name : default_role_names)
+    {
+        if (!role_names_of_interest.count(role_name))
+            throwDefaultRoleNotFound(role_name);
+    }
+}
+
+
+const char * LDAPAccessStorage::getStorageType() const
+{
+    return STORAGE_TYPE;
+}
+
+
+String LDAPAccessStorage::getStorageParamsJSON() const
+{
+    std::scoped_lock lock(mutex);
+    Poco::JSON::Object params_json;
+
+    params_json.set("server", ldap_server);
+    params_json.set("roles", default_role_names);
+
+    std::ostringstream oss;
+    Poco::JSON::Stringifier::stringify(params_json, oss);
+
+    return oss.str();
+}
+
+
+std::optional<UUID> LDAPAccessStorage::findImpl(EntityType type, const String & name) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.find(type, name);
+}
+
+
+std::vector<UUID> LDAPAccessStorage::findAllImpl(EntityType type) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.findAll(type);
+}
+
+
+bool LDAPAccessStorage::existsImpl(const UUID & id) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.exists(id);
+}
+
+
+AccessEntityPtr LDAPAccessStorage::readImpl(const UUID & id) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.read(id);
+}
+
+
+String LDAPAccessStorage::readNameImpl(const UUID & id) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.readName(id);
+}
+
+
+bool LDAPAccessStorage::canInsertImpl(const AccessEntityPtr &) const
+{
+    return false;
+}
+
+
+UUID LDAPAccessStorage::insertImpl(const AccessEntityPtr & entity, bool)
+{
+    throwReadonlyCannotInsert(entity->getType(), entity->getName());
+}
+
+
+void LDAPAccessStorage::removeImpl(const UUID & id)
+{
+    std::scoped_lock lock(mutex);
+    auto entity = read(id);
+    throwReadonlyCannotRemove(entity->getType(), entity->getName());
+}
+
+
+void LDAPAccessStorage::updateImpl(const UUID & id, const UpdateFunc &)
+{
+    std::scoped_lock lock(mutex);
+    auto entity = read(id);
+    throwReadonlyCannotUpdate(entity->getType(), entity->getName());
+}
+
+
+ext::scope_guard LDAPAccessStorage::subscribeForChangesImpl(const UUID & id, const OnChangedHandler & handler) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.subscribeForChanges(id, handler);
+}
+
+
+ext::scope_guard LDAPAccessStorage::subscribeForChangesImpl(EntityType type, const OnChangedHandler & handler) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.subscribeForChanges(type, handler);
+}
+
+
+bool LDAPAccessStorage::hasSubscriptionImpl(const UUID & id) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.hasSubscription(id);
+}
+
+
+bool LDAPAccessStorage::hasSubscriptionImpl(EntityType type) const
+{
+    std::scoped_lock lock(mutex);
+    return memory_storage.hasSubscription(type);
+}
+
+UUID LDAPAccessStorage::loginImpl(const String & user_name, const String & password, const Poco::Net::IPAddress & address, const ExternalAuthenticators & external_authenticators) const
+{
+    std::scoped_lock lock(mutex);
+    auto id = memory_storage.find<User>(user_name);
+    if (id)
+    {
+        auto user = memory_storage.read<User>(*id);
+
+        if (!isPasswordCorrectImpl(*user, password, external_authenticators))
+            throwInvalidPassword();
+
+        if (!isAddressAllowedImpl(*user, address))
+            throwAddressNotAllowed(address);
+
+        return *id;
+    }
+    else
+    {
+        // User does not exist, so we create one, and will add it if authentication is successful.
+        auto user = std::make_shared<User>();
+        user->setName(user_name);
+        user->authentication = Authentication(Authentication::Type::LDAP_SERVER);
+        user->authentication.setServerName(ldap_server);
+
+        if (!isPasswordCorrectImpl(*user, password, external_authenticators))
+            throwInvalidPassword();
+
+        if (!isAddressAllowedImpl(*user, address))
+            throwAddressNotAllowed(address);
+
+        checkAllDefaultRoleNamesFoundNoLock();
+
+        auto & granted_roles = user->granted_roles.roles;
+        boost::range::copy(roles_of_interest | boost::adaptors::map_keys, std::inserter(granted_roles, granted_roles.end()));
+
+        return memory_storage.insert(user);
+    }
+}
+
+UUID LDAPAccessStorage::getIDOfLoggedUserImpl(const String & user_name) const
+{
+    std::scoped_lock lock(mutex);
+    auto id = memory_storage.find<User>(user_name);
+    if (id)
+    {
+        return *id;
+    }
+    else
+    {
+        // User does not exist, so we create one, and add it pretending that the authentication is successful.
+        auto user = std::make_shared<User>();
+        user->setName(user_name);
+        user->authentication = Authentication(Authentication::Type::LDAP_SERVER);
+        user->authentication.setServerName(ldap_server);
+
+        checkAllDefaultRoleNamesFoundNoLock();
+
+        auto & granted_roles = user->granted_roles.roles;
+        boost::range::copy(roles_of_interest | boost::adaptors::map_keys, std::inserter(granted_roles, granted_roles.end()));
+
+        return memory_storage.insert(user);
+    }
+}
+
+void LDAPAccessStorage::throwDefaultRoleNotFound(const String & role_name)
+{
+    throw Exception("One of the default roles, the role '" + role_name + "', is not found", IAccessEntity::TypeInfo::get(IAccessEntity::Type::ROLE).not_found_error_code);
+}
+
+}
diff --git a/src/Access/LDAPAccessStorage.h b/src/Access/LDAPAccessStorage.h
new file mode 100644
index 000000000000..a845279841ca
--- /dev/null
+++ b/src/Access/LDAPAccessStorage.h
@@ -0,0 +1,71 @@
+#pragma once
+
+#include <Access/MemoryAccessStorage.h>
+#include <Core/Types.h>
+#include <ext/scope_guard.h>
+#include <map>
+#include <mutex>
+#include <set>
+
+
+namespace Poco
+{
+    namespace Util
+    {
+        class AbstractConfiguration;
+    }
+}
+
+
+namespace DB
+{
+class AccessControlManager;
+
+/// Implementation of IAccessStorage which allows attaching users from a remote LDAP server.
+/// Currently, any user name will be treated as a name of an existing remote user,
+/// a user info entity will be created, with LDAP_SERVER authentication type.
+class LDAPAccessStorage : public IAccessStorage
+{
+public:
+    static constexpr char STORAGE_TYPE[] = "ldap";
+
+    explicit LDAPAccessStorage(const String & storage_name_, AccessControlManager * access_control_manager_, const Poco::Util::AbstractConfiguration & config, const String & prefix);
+    virtual ~LDAPAccessStorage() override = default;
+
+public: // IAccessStorage implementations.
+    virtual const char * getStorageType() const override;
+    virtual String getStorageParamsJSON() const override;
+
+private: // IAccessStorage implementations.
+    virtual std::optional<UUID> findImpl(EntityType type, const String & name) const override;
+    virtual std::vector<UUID> findAllImpl(EntityType type) const override;
+    virtual bool existsImpl(const UUID & id) const override;
+    virtual AccessEntityPtr readImpl(const UUID & id) const override;
+    virtual String readNameImpl(const UUID & id) const override;
+    virtual bool canInsertImpl(const AccessEntityPtr &) const override;
+    virtual UUID insertImpl(const AccessEntityPtr & entity, bool replace_if_exists) override;
+    virtual void removeImpl(const UUID & id) override;
+    virtual void updateImpl(const UUID & id, const UpdateFunc & update_func) override;
+    virtual ext::scope_guard subscribeForChangesImpl(const UUID & id, const OnChangedHandler & handler) const override;
+    virtual ext::scope_guard subscribeForChangesImpl(EntityType type, const OnChangedHandler & handler) const override;
+    virtual bool hasSubscriptionImpl(const UUID & id) const override;
+    virtual bool hasSubscriptionImpl(EntityType type) const override;
+    virtual UUID loginImpl(const String & user_name, const String & password, const Poco::Net::IPAddress & address, const ExternalAuthenticators & external_authenticators) const override;
+    virtual UUID getIDOfLoggedUserImpl(const String & user_name) const override;
+
+private:
+    void setConfiguration(AccessControlManager * access_control_manager_, const Poco::Util::AbstractConfiguration & config, const String & prefix);
+    void processRoleChange(const UUID & id, const AccessEntityPtr & entity);
+    void checkAllDefaultRoleNamesFoundNoLock() const;
+
+    [[noreturn]] static void throwDefaultRoleNotFound(const String & role_name);
+
+    mutable std::recursive_mutex mutex;
+    AccessControlManager * access_control_manager = nullptr;
+    String ldap_server;
+    std::set<String> default_role_names;
+    std::map<UUID, String> roles_of_interest;
+    ext::scope_guard role_change_subscription;
+    mutable MemoryAccessStorage memory_storage;
+};
+}
diff --git a/src/Access/LDAPClient.cpp b/src/Access/LDAPClient.cpp
index a85e96ab86c2..a32239023611 100644
--- a/src/Access/LDAPClient.cpp
+++ b/src/Access/LDAPClient.cpp
@@ -2,6 +2,8 @@
 #include <Common/Exception.h>
 #include <ext/scope_guard.h>
 
+#include <mutex>
+
 #include <cstring>
 
 #include <sys/time.h>
@@ -27,16 +29,13 @@ LDAPClient::~LDAPClient()
     closeConnection();
 }
 
-void LDAPClient::openConnection()
-{
-    const bool graceful_bind_failure = false;
-    diag(openConnection(graceful_bind_failure));
-}
-
 #if USE_LDAP
 
 namespace
 {
+
+    std::recursive_mutex ldap_global_mutex;
+
     auto escapeForLDAP(const String & src)
     {
         String dest;
@@ -63,10 +62,13 @@ namespace
 
         return dest;
     }
+
 }
 
 void LDAPClient::diag(const int rc)
 {
+    std::scoped_lock lock(ldap_global_mutex);
+
     if (rc != LDAP_SUCCESS)
     {
         String text;
@@ -100,8 +102,10 @@ void LDAPClient::diag(const int rc)
     }
 }
 
-int LDAPClient::openConnection(const bool graceful_bind_failure)
+void LDAPClient::openConnection()
 {
+    std::scoped_lock lock(ldap_global_mutex);
+
     closeConnection();
 
     {
@@ -232,8 +236,6 @@ int LDAPClient::openConnection(const bool graceful_bind_failure)
     if (params.enable_tls == LDAPServerParams::TLSEnable::YES_STARTTLS)
         diag(ldap_start_tls_s(handle, nullptr, nullptr));
 
-    int rc = LDAP_OTHER;
-
     switch (params.sasl_mechanism)
     {
         case LDAPServerParams::SASLMechanism::SIMPLE:
@@ -244,20 +246,21 @@ int LDAPClient::openConnection(const bool graceful_bind_failure)
             cred.bv_val = const_cast<char *>(params.password.c_str());
             cred.bv_len = params.password.size();
 
-            rc = ldap_sasl_bind_s(handle, dn.c_str(), LDAP_SASL_SIMPLE, &cred, nullptr, nullptr, nullptr);
-
-            if (!graceful_bind_failure)
-                diag(rc);
+            diag(ldap_sasl_bind_s(handle, dn.c_str(), LDAP_SASL_SIMPLE, &cred, nullptr, nullptr, nullptr));
 
             break;
         }
+        default:
+        {
+            throw Exception("Unknown SASL mechanism", ErrorCodes::LDAP_ERROR);
+        }
     }
-
-    return rc;
 }
 
 void LDAPClient::closeConnection() noexcept
 {
+    std::scoped_lock lock(ldap_global_mutex);
+
     if (!handle)
         return;
 
@@ -267,42 +270,21 @@ void LDAPClient::closeConnection() noexcept
 
 bool LDAPSimpleAuthClient::check()
 {
+    std::scoped_lock lock(ldap_global_mutex);
+
     if (params.user.empty())
-        throw Exception("LDAP authentication of a user with an empty name is not allowed", ErrorCodes::BAD_ARGUMENTS);
+        throw Exception("LDAP authentication of a user with empty name is not allowed", ErrorCodes::BAD_ARGUMENTS);
 
+    // Silently reject authentication attempt if the password is empty as if it didn't match.
     if (params.password.empty())
-        return false; // Silently reject authentication attempt if the password is empty as if it didn't match.
+        return false;
 
     SCOPE_EXIT({ closeConnection(); });
 
-    const bool graceful_bind_failure = true;
-    const auto rc = openConnection(graceful_bind_failure);
-
-    bool result = false;
-
-    switch (rc)
-    {
-        case LDAP_SUCCESS:
-        {
-            result = true;
-            break;
-        }
-
-        case LDAP_INVALID_CREDENTIALS:
-        {
-            result = false;
-            break;
-        }
-
-        default:
-        {
-            result = false;
-            diag(rc);
-            break;
-        }
-    }
+    // Will throw on any error, including invalid credentials.
+    openConnection();
 
-    return result;
+    return true;
 }
 
 #else // USE_LDAP
@@ -312,7 +294,7 @@ void LDAPClient::diag(const int)
     throw Exception("ClickHouse was built without LDAP support", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);
 }
 
-int LDAPClient::openConnection(const bool)
+void LDAPClient::openConnection()
 {
     throw Exception("ClickHouse was built without LDAP support", ErrorCodes::FEATURE_IS_NOT_ENABLED_AT_BUILD_TIME);
 }
diff --git a/src/Access/LDAPClient.h b/src/Access/LDAPClient.h
index b117ed9a0265..777c87c5b943 100644
--- a/src/Access/LDAPClient.h
+++ b/src/Access/LDAPClient.h
@@ -32,7 +32,6 @@ class LDAPClient
 protected:
     MAYBE_NORETURN void diag(const int rc);
     MAYBE_NORETURN void openConnection();
-    int openConnection(const bool graceful_bind_failure = false);
     void closeConnection() noexcept;
 
 protected:
diff --git a/src/Access/LDAPParams.h b/src/Access/LDAPParams.h
index 2168ce452032..eeadba6bc01e 100644
--- a/src/Access/LDAPParams.h
+++ b/src/Access/LDAPParams.h
@@ -42,6 +42,7 @@ struct LDAPServerParams
 
     enum class SASLMechanism
     {
+        UNKNOWN,
         SIMPLE
     };
 
diff --git a/src/Access/MemoryAccessStorage.cpp b/src/Access/MemoryAccessStorage.cpp
index 114c8eb8bee3..58280c8b1d74 100644
--- a/src/Access/MemoryAccessStorage.cpp
+++ b/src/Access/MemoryAccessStorage.cpp
@@ -69,7 +69,7 @@ UUID MemoryAccessStorage::insertImpl(const AccessEntityPtr & new_entity, bool re
 
     UUID id = generateRandomID();
     std::lock_guard lock{mutex};
-    insertNoLock(generateRandomID(), new_entity, replace_if_exists, notifications);
+    insertNoLock(id, new_entity, replace_if_exists, notifications);
     return id;
 }
 
diff --git a/src/Access/MultipleAccessStorage.cpp b/src/Access/MultipleAccessStorage.cpp
index 8ddc7410d8dc..a8ce3f602ed2 100644
--- a/src/Access/MultipleAccessStorage.cpp
+++ b/src/Access/MultipleAccessStorage.cpp
@@ -2,6 +2,7 @@
 #include <Common/Exception.h>
 #include <ext/range.h>
 #include <boost/range/adaptor/map.hpp>
+#include <boost/range/adaptor/reversed.hpp>
 #include <boost/range/algorithm/copy.hpp>
 #include <boost/range/algorithm/find.hpp>
 
@@ -27,6 +28,15 @@ MultipleAccessStorage::MultipleAccessStorage(const String & storage_name_)
 {
 }
 
+MultipleAccessStorage::~MultipleAccessStorage()
+{
+    /// It's better to remove the storages in the reverse order because they could depend on each other somehow.
+    const auto storages = getStoragesPtr();
+    for (const auto & storage : *storages | boost::adaptors::reversed)
+    {
+        removeStorage(storage);
+    }
+}
 
 void MultipleAccessStorage::setStorages(const std::vector<StoragePtr> & storages)
 {
@@ -400,7 +410,7 @@ UUID MultipleAccessStorage::loginImpl(const String & user_name, const String & p
     {
         try
         {
-            auto id = storage->login(user_name, password, address, external_authenticators);
+            auto id = storage->login(user_name, password, address, external_authenticators, /* replace_exception_with_cannot_authenticate = */ false);
             std::lock_guard lock{mutex};
             ids_cache.set(id, storage);
             return id;
@@ -416,7 +426,7 @@ UUID MultipleAccessStorage::loginImpl(const String & user_name, const String & p
             throw;
         }
     }
-    throwCannotAuthenticate(user_name);
+    throwNotFound(EntityType::USER, user_name);
 }
 
 
diff --git a/src/Access/MultipleAccessStorage.h b/src/Access/MultipleAccessStorage.h
index 36551f1cbc8d..8844de8c0290 100644
--- a/src/Access/MultipleAccessStorage.h
+++ b/src/Access/MultipleAccessStorage.h
@@ -18,6 +18,7 @@ class MultipleAccessStorage : public IAccessStorage
     using ConstStoragePtr = std::shared_ptr<const Storage>;
 
     MultipleAccessStorage(const String & storage_name_ = STORAGE_TYPE);
+    ~MultipleAccessStorage() override;
 
     const char * getStorageType() const override { return STORAGE_TYPE; }
 
diff --git a/src/Access/ya.make b/src/Access/ya.make
index e5fa73f107c6..b945c5a192af 100644
--- a/src/Access/ya.make
+++ b/src/Access/ya.make
@@ -24,6 +24,7 @@ SRCS(
     GrantedRoles.cpp
     IAccessEntity.cpp
     IAccessStorage.cpp
+    LDAPAccessStorage.cpp
     LDAPClient.cpp
     MemoryAccessStorage.cpp
     MultipleAccessStorage.cpp
