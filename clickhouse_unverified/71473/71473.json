{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 71473,
  "instance_id": "ClickHouse__ClickHouse-71473",
  "issue_numbers": [
    "71244"
  ],
  "base_commit": "dbb20fc864216f4dad09b20330619fbd736c7fd2",
  "patch": "diff --git a/base/base/defines.h b/base/base/defines.h\nindex 5685a6d98333..a0c3c0d1de54 100644\n--- a/base/base/defines.h\n+++ b/base/base/defines.h\n@@ -145,6 +145,7 @@\n #define TSA_TRY_ACQUIRE_SHARED(...) __attribute__((try_acquire_shared_capability(__VA_ARGS__)))  /// function tries to acquire a shared capability and returns a boolean value indicating success or failure\n #define TSA_RELEASE_SHARED(...) __attribute__((release_shared_capability(__VA_ARGS__)))          /// function releases the given shared capability\n #define TSA_SCOPED_LOCKABLE __attribute__((scoped_lockable)) /// object of a class has scoped lockable capability\n+#define TSA_RETURN_CAPABILITY(...) __attribute__((lock_returned(__VA_ARGS__)))             /// to return capabilities in functions\n \n /// Macros for suppressing TSA warnings for specific reads/writes (instead of suppressing it for the whole function)\n /// They use a lambda function to apply function attribute to a single statement. This enable us to suppress warnings locally instead of\ndiff --git a/src/Common/LockGuard.h b/src/Common/LockGuard.h\nindex 8a98c5f553a4..03c8a3e76177 100644\n--- a/src/Common/LockGuard.h\n+++ b/src/Common/LockGuard.h\n@@ -1,23 +1,47 @@\n #pragma once\n \n-#include <Common/OvercommitTracker.h>\n #include <base/defines.h>\n+#include <Common/Exception.h>\n+#include <Common/OvercommitTracker.h>\n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+};\n+\n /** LockGuard provides RAII-style locking mechanism for a mutex.\n- ** It's intended to be used like std::unique_ptr but with TSA annotations\n+ ** It's intended to be used like std::unique_lock but with TSA annotations\n   */\n template <typename Mutex>\n class TSA_SCOPED_LOCKABLE LockGuard\n {\n public:\n-    explicit LockGuard(Mutex & mutex_) TSA_ACQUIRE(mutex_) : mutex(mutex_) { mutex.lock(); }\n-    ~LockGuard() TSA_RELEASE() { mutex.unlock(); }\n+    explicit LockGuard(Mutex & mutex_) TSA_ACQUIRE(mutex_) : mutex(mutex_) { lock(); }\n+    ~LockGuard() TSA_RELEASE() { if (locked) unlock(); }\n+\n+    void lock() TSA_ACQUIRE()\n+    {\n+        /// Don't allow recursive_mutex for now.\n+        if (locked)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Can't lock twice the same mutex\");\n+        mutex.lock();\n+        locked = true;\n+    }\n+\n+    void unlock() TSA_RELEASE()\n+    {\n+        if (!locked)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Can't unlock the mutex without locking it first\");\n+        mutex.unlock();\n+        locked = false;\n+    }\n \n private:\n     Mutex & mutex;\n+    bool locked = false;\n };\n \n template <template<typename> typename TLockGuard, typename Mutex>\ndiff --git a/src/Interpreters/QueryMetricLog.cpp b/src/Interpreters/QueryMetricLog.cpp\nindex 5ab3fe590e0d..52d773b7d1ba 100644\n--- a/src/Interpreters/QueryMetricLog.cpp\n+++ b/src/Interpreters/QueryMetricLog.cpp\n@@ -1,6 +1,7 @@\n #include <base/getFQDNOrHostName.h>\n #include <Common/DateLUT.h>\n #include <Common/DateLUTImpl.h>\n+#include <Common/LockGuard.h>\n #include <DataTypes/DataTypeDate.h>\n #include <DataTypes/DataTypeDateTime.h>\n #include <DataTypes/DataTypeDateTime64.h>\n@@ -16,7 +17,6 @@\n \n #include <chrono>\n #include <fmt/chrono.h>\n-#include <mutex>\n \n \n namespace DB\n@@ -24,6 +24,15 @@ namespace DB\n \n static auto logger = getLogger(\"QueryMetricLog\");\n \n+String timePointToString(QueryMetricLog::TimePoint time)\n+{\n+    /// fmtlib supports subsecond formatting in 10.0.0. We're in 9.1.0, so we need to add the milliseconds ourselves.\n+    auto seconds = std::chrono::time_point_cast<std::chrono::seconds>(time);\n+    auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(time - seconds).count();\n+\n+    return fmt::format(\"{:%Y.%m.%d %H:%M:%S}.{:06}\", seconds, microseconds);\n+}\n+\n ColumnsDescription QueryMetricLogElement::getColumnsDescription()\n {\n     ColumnsDescription result;\n@@ -87,36 +96,73 @@ void QueryMetricLog::shutdown()\n     Base::shutdown();\n }\n \n-void QueryMetricLog::startQuery(const String & query_id, TimePoint start_time, UInt64 interval_milliseconds)\n+void QueryMetricLog::collectMetric(const ProcessList & process_list, String query_id)\n+{\n+    auto current_time = std::chrono::system_clock::now();\n+    const auto query_info = process_list.getQueryInfo(query_id, false, true, false);\n+    if (!query_info)\n+    {\n+        /// TODO: remove trace before 24.11 release after checking everything is fine on the CI\n+        LOG_TRACE(logger, \"Query {} is not running anymore, so we couldn't get its QueryStatusInfo\", query_id);\n+        return;\n+    }\n+\n+    LockGuard global_lock(queries_mutex);\n+    auto it = queries.find(query_id);\n+\n+    /// The query might have finished while the scheduled task is running.\n+    if (it == queries.end())\n+    {\n+        global_lock.unlock();\n+        /// TODO: remove trace before 24.11 release after checking everything is fine on the CI\n+        LOG_TRACE(logger, \"Query {} not found in the list. Finished while this collecting task was running\", query_id);\n+        return;\n+    }\n+\n+    auto & query_status = it->second;\n+    if (!query_status.mutex)\n+    {\n+        global_lock.unlock();\n+        /// TODO: remove trace before 24.11 release after checking everything is fine on the CI\n+        LOG_TRACE(logger, \"Query {} finished while this collecting task was running\", query_id);\n+        return;\n+    }\n+\n+    LockGuard query_lock(query_status.getMutex());\n+    global_lock.unlock();\n+\n+    auto elem = query_status.createLogMetricElement(query_id, *query_info, current_time);\n+    if (elem)\n+        add(std::move(elem.value()));\n+}\n+\n+/// We use TSA_NO_THREAD_SAFETY_ANALYSIS to prevent TSA complaining that we're modifying the query_status fields\n+/// without locking the mutex. Since we're building it from scratch, there's no harm in not holding it.\n+/// If we locked it to make TSA happy, TSAN build would falsely complain about\n+///     lock-order-inversion (potential deadlock)\n+/// which is not a real issue since QueryMetricLogStatus's mutex cannot be locked by anything else\n+/// until we add it to the queries map.\n+void QueryMetricLog::startQuery(const String & query_id, TimePoint start_time, UInt64 interval_milliseconds) TSA_NO_THREAD_SAFETY_ANALYSIS\n {\n-    QueryMetricLogStatus status;\n-    status.interval_milliseconds = interval_milliseconds;\n-    status.next_collect_time = start_time + std::chrono::milliseconds(interval_milliseconds);\n+    QueryMetricLogStatus query_status;\n+    QueryMetricLogStatusInfo & info = query_status.info;\n+    info.interval_milliseconds = interval_milliseconds;\n+    info.next_collect_time = start_time;\n \n     auto context = getContext();\n     const auto & process_list = context->getProcessList();\n-    status.task = context->getSchedulePool().createTask(\"QueryMetricLog\", [this, &process_list, query_id] {\n-        auto current_time = std::chrono::system_clock::now();\n-        const auto query_info = process_list.getQueryInfo(query_id, false, true, false);\n-        if (!query_info)\n-        {\n-            LOG_TRACE(logger, \"Query {} is not running anymore, so we couldn't get its QueryStatusInfo\", query_id);\n-            return;\n-        }\n-\n-        auto elem = createLogMetricElement(query_id, *query_info, current_time);\n-        if (elem)\n-            add(std::move(elem.value()));\n+    info.task = context->getSchedulePool().createTask(\"QueryMetricLog\", [this, &process_list, query_id] {\n+        collectMetric(process_list, query_id);\n     });\n \n-    std::lock_guard lock(queries_mutex);\n-    status.task->scheduleAfter(interval_milliseconds);\n-    queries.emplace(query_id, std::move(status));\n+    LockGuard global_lock(queries_mutex);\n+    query_status.scheduleNext(query_id);\n+    queries.emplace(query_id, std::move(query_status));\n }\n \n void QueryMetricLog::finishQuery(const String & query_id, TimePoint finish_time, QueryStatusInfoPtr query_info)\n {\n-    std::unique_lock lock(queries_mutex);\n+    LockGuard global_lock(queries_mutex);\n     auto it = queries.find(query_id);\n \n     /// finishQuery may be called from logExceptionBeforeStart when the query has not even started\n@@ -124,9 +170,19 @@ void QueryMetricLog::finishQuery(const String & query_id, TimePoint finish_time,\n     if (it == queries.end())\n         return;\n \n+    auto & query_status = it->second;\n+    decltype(query_status.mutex) query_mutex;\n+    LockGuard query_lock(query_status.getMutex());\n+\n+    /// Move the query mutex here so that we hold it until the end, after removing the query from queries.\n+    query_mutex = std::move(query_status.mutex);\n+    query_status.mutex = {};\n+\n+    global_lock.unlock();\n+\n     if (query_info)\n     {\n-        auto elem = createLogMetricElement(query_id, *query_info, finish_time, false);\n+        auto elem = query_status.createLogMetricElement(query_id, *query_info, finish_time, false);\n         if (elem)\n             add(std::move(elem.value()));\n     }\n@@ -139,51 +195,58 @@ void QueryMetricLog::finishQuery(const String & query_id, TimePoint finish_time,\n     /// that order.\n     {\n         /// Take ownership of the task so that we can destroy it in this scope after unlocking `queries_mutex`.\n-        auto task = std::move(it->second.task);\n+        auto task = std::move(query_status.info.task);\n \n         /// Build an empty task for the old task to make sure it does not lock any mutex on its destruction.\n-        it->second.task = {};\n+        query_status.info.task = {};\n+        query_lock.unlock();\n \n+        global_lock.lock();\n         queries.erase(query_id);\n \n         /// Ensure `queries_mutex` is unlocked before calling task's destructor at the end of this\n         /// scope which will lock `exec_mutex`.\n-        lock.unlock();\n+        global_lock.unlock();\n     }\n }\n \n-std::optional<QueryMetricLogElement> QueryMetricLog::createLogMetricElement(const String & query_id, const QueryStatusInfo & query_info, TimePoint query_info_time, bool schedule_next)\n+void QueryMetricLogStatus::scheduleNext(String query_id)\n {\n-    /// fmtlib supports subsecond formatting in 10.0.0. We're in 9.1.0, so we need to add the milliseconds ourselves.\n-    auto seconds = std::chrono::time_point_cast<std::chrono::seconds>(query_info_time);\n-    auto microseconds = std::chrono::duration_cast<std::chrono::microseconds>(query_info_time - seconds).count();\n-    LOG_DEBUG(logger, \"Collecting query_metric_log for query {} with QueryStatusInfo from {:%Y.%m.%d %H:%M:%S}.{:06}. Schedule next: {}\", query_id, seconds, microseconds, schedule_next);\n-\n-    std::unique_lock lock(queries_mutex);\n-    auto query_status_it = queries.find(query_id);\n-\n-    /// The query might have finished while the scheduled task is running.\n-    if (query_status_it == queries.end())\n+    info.next_collect_time += std::chrono::milliseconds(info.interval_milliseconds);\n+    const auto now = std::chrono::system_clock::now();\n+    if (info.next_collect_time > now)\n     {\n-        lock.unlock();\n-        LOG_TRACE(logger, \"Query {} finished already while this collecting task was running\", query_id);\n-        return {};\n+        const auto wait_time = std::chrono::duration_cast<std::chrono::milliseconds>(info.next_collect_time - now).count();\n+        info.task->scheduleAfter(wait_time);\n+    }\n+    else\n+    {\n+        LOG_TRACE(logger, \"The next collecting task for query {} should have already run at {}. Scheduling it right now\",\n+            query_id, timePointToString(info.next_collect_time));\n+        info.task->schedule();\n     }\n+}\n+\n+std::optional<QueryMetricLogElement> QueryMetricLogStatus::createLogMetricElement(const String & query_id, const QueryStatusInfo & query_info, TimePoint query_info_time, bool schedule_next)\n+{\n+    /// TODO: remove trace before 24.11 release after checking everything is fine on the CI\n+    LOG_TRACE(logger, \"Collecting query_metric_log for query {} and interval {} ms with QueryStatusInfo from {}. Next collection time: {}\",\n+        query_id, info.interval_milliseconds, timePointToString(query_info_time),\n+        schedule_next ? timePointToString(info.next_collect_time + std::chrono::milliseconds(info.interval_milliseconds)) : \"finished\");\n \n-    auto & query_status = query_status_it->second;\n-    if (query_info_time <= query_status.last_collect_time)\n+    if (query_info_time <= info.last_collect_time)\n     {\n-        lock.unlock();\n+        /// TODO: remove trace before 24.11 release after checking everything is fine on the CI\n         LOG_TRACE(logger, \"Query {} has a more recent metrics collected. Skipping this one\", query_id);\n         return {};\n     }\n \n-    query_status.last_collect_time = query_info_time;\n+    info.last_collect_time = query_info_time;\n \n     QueryMetricLogElement elem;\n     elem.event_time = timeInSeconds(query_info_time);\n     elem.event_time_microseconds = timeInMicroseconds(query_info_time);\n-    elem.query_id = query_status_it->first;\n+    elem.query_id = query_id;\n     elem.memory_usage = query_info.memory_usage > 0 ? query_info.memory_usage : 0;\n     elem.peak_memory_usage = query_info.peak_memory_usage > 0 ? query_info.peak_memory_usage : 0;\n \n@@ -192,7 +255,7 @@ std::optional<QueryMetricLogElement> QueryMetricLog::createLogMetricElement(cons\n         for (ProfileEvents::Event i = ProfileEvents::Event(0), end = ProfileEvents::end(); i < end; ++i)\n         {\n             const auto & new_value = (*(query_info.profile_counters))[i];\n-            auto & old_value = query_status.last_profile_events[i];\n+            auto & old_value = info.last_profile_events[i];\n \n             /// Profile event counters are supposed to be monotonic. However, at least the `NetworkReceiveBytes` can be inaccurate.\n             /// So, since in the future the counter should always have a bigger value than in the past, we skip this event.\n@@ -208,16 +271,13 @@ std::optional<QueryMetricLogElement> QueryMetricLog::createLogMetricElement(cons\n     }\n     else\n     {\n-        LOG_TRACE(logger, \"Query {} has no profile counters\", query_id);\n+        /// TODO: remove trace before 24.11 release after checking everything is fine on the CI\n+        LOG_DEBUG(logger, \"Query {} has no profile counters\", query_id);\n         elem.profile_events = std::vector<ProfileEvents::Count>(ProfileEvents::end());\n     }\n \n     if (schedule_next)\n-    {\n-        query_status.next_collect_time += std::chrono::milliseconds(query_status.interval_milliseconds);\n-        const auto wait_time = std::chrono::duration_cast<std::chrono::milliseconds>(query_status.next_collect_time - std::chrono::system_clock::now()).count();\n-        query_status.task->scheduleAfter(wait_time);\n-    }\n+        scheduleNext(query_id);\n \n     return elem;\n }\ndiff --git a/src/Interpreters/QueryMetricLog.h b/src/Interpreters/QueryMetricLog.h\nindex 802cee7bf264..9371dfbb6b59 100644\n--- a/src/Interpreters/QueryMetricLog.h\n+++ b/src/Interpreters/QueryMetricLog.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <base/defines.h>\n #include <Common/ProfileEvents.h>\n #include <Common/CurrentMetrics.h>\n #include <Core/BackgroundSchedulePool.h>\n@@ -11,11 +12,17 @@\n \n #include <chrono>\n #include <ctime>\n+#include <mutex>\n \n \n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+};\n+\n /** QueryMetricLogElement is a log of query metric values measured at regular time interval.\n   */\n \n@@ -34,7 +41,7 @@ struct QueryMetricLogElement\n     void appendToBlock(MutableColumns & columns) const;\n };\n \n-struct QueryMetricLogStatus\n+struct QueryMetricLogStatusInfo\n {\n     UInt64 interval_milliseconds;\n     std::chrono::system_clock::time_point last_collect_time;\n@@ -43,24 +50,47 @@ struct QueryMetricLogStatus\n     BackgroundSchedulePool::TaskHolder task;\n };\n \n+struct QueryMetricLogStatus\n+{\n+    using TimePoint = std::chrono::system_clock::time_point;\n+    using Mutex = std::mutex;\n+\n+    QueryMetricLogStatusInfo info TSA_GUARDED_BY(getMutex());\n+\n+    /// We need to be able to move it for the hash map, so we need to add an indirection here.\n+    std::unique_ptr<Mutex> mutex = std::make_unique<Mutex>();\n+\n+    /// Return a reference to the mutex, used for Thread Sanitizer annotations.\n+    Mutex & getMutex() const TSA_RETURN_CAPABILITY(mutex)\n+    {\n+        if (!mutex)\n+            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Mutex cannot be NULL\");\n+        return *mutex;\n+    }\n+\n+    void scheduleNext(String query_id) TSA_REQUIRES(getMutex());\n+    std::optional<QueryMetricLogElement> createLogMetricElement(const String & query_id, const QueryStatusInfo & query_info, TimePoint query_info_time, bool schedule_next = true) TSA_REQUIRES(getMutex());\n+};\n+\n class QueryMetricLog : public SystemLog<QueryMetricLogElement>\n {\n     using SystemLog<QueryMetricLogElement>::SystemLog;\n-    using TimePoint = std::chrono::system_clock::time_point;\n     using Base = SystemLog<QueryMetricLogElement>;\n \n public:\n+    using TimePoint = std::chrono::system_clock::time_point;\n+\n     void shutdown() final;\n \n-    // Both startQuery and finishQuery are called from the thread that executes the query\n+    /// Both startQuery and finishQuery are called from the thread that executes the query.\n     void startQuery(const String & query_id, TimePoint start_time, UInt64 interval_milliseconds);\n     void finishQuery(const String & query_id, TimePoint finish_time, QueryStatusInfoPtr query_info = nullptr);\n \n private:\n-    std::optional<QueryMetricLogElement> createLogMetricElement(const String & query_id, const QueryStatusInfo & query_info, TimePoint query_info_time, bool schedule_next = true);\n+    void collectMetric(const ProcessList & process_list, String query_id);\n \n-    std::recursive_mutex queries_mutex;\n-    std::unordered_map<String, QueryMetricLogStatus> queries;\n+    std::mutex queries_mutex;\n+    std::unordered_map<String, QueryMetricLogStatus> queries TSA_GUARDED_BY(queries_mutex);\n };\n \n }\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex fa28fa04ab1d..0bc1d4956a17 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -505,6 +505,7 @@ void logQueryFinish(\n \n         auto time_now = std::chrono::system_clock::now();\n         QueryStatusInfo info = process_list_elem->getInfo(true, settings[Setting::log_profile_events]);\n+        logQueryMetricLogFinish(context, internal, elem.client_info.current_query_id, time_now, std::make_shared<QueryStatusInfo>(info));\n         elem.type = QueryLogElementType::QUERY_FINISH;\n \n         addStatusInfoToQueryLogElement(elem, info, query_ast, context);\n@@ -623,6 +624,7 @@ void logQueryException(\n     {\n         elem.query_duration_ms = start_watch.elapsedMilliseconds();\n     }\n+    logQueryMetricLogFinish(context, internal, elem.client_info.current_query_id, time_now, info);\n \n     elem.query_cache_usage = QueryCache::Usage::None;\n \n@@ -652,8 +654,6 @@ void logQueryException(\n         query_span->addAttribute(\"clickhouse.exception_code\", elem.exception_code);\n         query_span->finish();\n     }\n-\n-    logQueryMetricLogFinish(context, internal, elem.client_info.current_query_id, time_now, info);\n }\n \n void logExceptionBeforeStart(\n@@ -707,6 +707,8 @@ void logExceptionBeforeStart(\n \n     elem.client_info = context->getClientInfo();\n \n+    logQueryMetricLogFinish(context, false, elem.client_info.current_query_id, std::chrono::system_clock::now(), nullptr);\n+\n     elem.log_comment = settings[Setting::log_comment];\n     if (elem.log_comment.size() > settings[Setting::max_query_size])\n         elem.log_comment.resize(settings[Setting::max_query_size]);\n@@ -751,8 +753,6 @@ void logExceptionBeforeStart(\n             ProfileEvents::increment(ProfileEvents::FailedInsertQuery);\n         }\n     }\n-\n-    logQueryMetricLogFinish(context, false, elem.client_info.current_query_id, std::chrono::system_clock::now(), nullptr);\n }\n \n void validateAnalyzerSettings(ASTPtr ast, bool context_value)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03203_system_query_metric_log.reference b/tests/queries/0_stateless/03203_system_query_metric_log.reference\nindex 940b0c4e1789..fa8e27a7e904 100644\n--- a/tests/queries/0_stateless/03203_system_query_metric_log.reference\n+++ b/tests/queries/0_stateless/03203_system_query_metric_log.reference\n@@ -23,8 +23,8 @@\n --Interval 123: check that the SleepFunctionCalls, SleepFunctionMilliseconds and ProfileEvent_SleepFunctionElapsedMicroseconds are correct\n 1\n --Check that a query_metric_log_interval=0 disables the collection\n-0\n+1\n -Check that a query which execution time is less than query_metric_log_interval is never collected\n-0\n+1\n --Check that there is a final event when queries finish\n-3\n+1\ndiff --git a/tests/queries/0_stateless/03203_system_query_metric_log.sh b/tests/queries/0_stateless/03203_system_query_metric_log.sh\nindex bf94be79d7c9..abcd14c8e5de 100755\n--- a/tests/queries/0_stateless/03203_system_query_metric_log.sh\n+++ b/tests/queries/0_stateless/03203_system_query_metric_log.sh\n@@ -84,17 +84,17 @@ check_log 123\n # query_metric_log_interval=0 disables the collection altogether\n $CLICKHOUSE_CLIENT -m -q \"\"\"\n     SELECT '--Check that a query_metric_log_interval=0 disables the collection';\n-    SELECT count() FROM system.query_metric_log WHERE event_date >= yesterday() AND query_id = '${query_prefix}_0'\n+    SELECT count() == 0 FROM system.query_metric_log WHERE event_date >= yesterday() AND query_id = '${query_prefix}_0'\n \"\"\"\n \n # a quick query that takes less than query_metric_log_interval is never collected\n $CLICKHOUSE_CLIENT -m -q \"\"\"\n     SELECT '-Check that a query which execution time is less than query_metric_log_interval is never collected';\n-    SELECT count() FROM system.query_metric_log WHERE event_date >= yesterday() AND query_id = '${query_prefix}_fast'\n+    SELECT count() == 0 FROM system.query_metric_log WHERE event_date >= yesterday() AND query_id = '${query_prefix}_fast'\n \"\"\"\n \n # a query that takes more than query_metric_log_interval is collected including the final row\n $CLICKHOUSE_CLIENT -m -q \"\"\"\n     SELECT '--Check that there is a final event when queries finish';\n-    SELECT count() FROM system.query_metric_log WHERE event_date >= yesterday() AND query_id = '${query_prefix}_1000'\n+    SELECT count() > 2 FROM system.query_metric_log WHERE event_date >= yesterday() AND query_id = '${query_prefix}_1000'\n \"\"\"\n",
  "problem_statement": "Stateless test `03203_system_query_metric_log` is flaky\nIt's failed in several places \r\nhttps://play.clickhouse.com/play?user=play#V0lUSAogICAgMzAgQVMgbGFzdF9kYXlzX3RvX2NoZWNrLAogICAgMTAwIEFTIG1heF90ZXN0c190b19zaG93LAogICAgNSBhcyBtYXhfcHJzX3RvX3Nob3csCiAgICA3MCBBUyB0ZXN0X25hbWVfbWF4X2xlbmd0aApTRUxFQ1QKICAgIGNoZWNrX3N0YXJ0X3RpbWUsCiAgICBwdWxsX3JlcXVlc3RfbnVtYmVyLAogICAgdGVzdF9zdGF0dXMsCiAgICByZXBvcnRfdXJsLAogICAgcHVsbF9yZXF1ZXN0X3VybApGUk9NIGNoZWNrcwpXSEVSRQogICAgY2hlY2tfc3RhcnRfdGltZSA+PSBub3coKSAtIGludGVydmFsIGxhc3RfZGF5c190b19jaGVjayBkYXkKICAgIEFORCAodGVzdF9zdGF0dXMgIT0gJ09LJyBBTkQgdGVzdF9zdGF0dXMgIT0gJ1NLSVBQRUQnKQogICAgQU5EIHRlc3RfbmFtZSBJTElLRSAnJTAzMjAzX3N5c3RlbV9xdWVyeV9tZXRyaWNfbG9nJScKT1JERVIgQlkgY2hlY2tfc3RhcnRfdGltZSBERVNDCkxJTUlUIG1heF90ZXN0c190b19zaG93\r\n\r\nThis comes from a test that failed on the CI: https://s3.amazonaws.com/clickhouse-test-reports/71036/3ebbb0c2ce0e1cc56d461e0ec96b0cc3a5ed4830/stateless_tests__debug__s3_storage_.html\r\n\r\n```bash\r\nzstdgrep -ina \"QueryMetricLog\" clickhouse-server.log.zst | grep -i test_de08ooxs\r\n1936280:2024.10.26 05:05:10.492623 [ 1152 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1937102:2024.10.26 05:05:10.614481 [ 1044 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1937116:2024.10.26 05:05:10.737650 [ 829 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1937951:2024.10.26 05:05:10.860092 [ 1098 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1937992:2024.10.26 05:05:10.983508 [ 958 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1938708:2024.10.26 05:05:11.106529 [ 1074 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1939972:2024.10.26 05:05:11.229248 [ 947 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1940036:2024.10.26 05:05:11.352791 [ 1045 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1940205:2024.10.26 05:05:11.369476 [ 688 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_1000. Schedule next: true\r\n1940419:2024.10.26 05:05:11.475718 [ 1085 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1941030:2024.10.26 05:05:11.564217 [ 1060 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_1234. Schedule next: true\r\n1941491:2024.10.26 05:05:11.598769 [ 1101 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1942122:2024.10.26 05:05:11.721031 [ 1156 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1943297:2024.10.26 05:05:11.844160 [ 996 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1943577:2024.10.26 05:05:11.967281 [ 914 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1944080:2024.10.26 05:05:12.090420 [ 941 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1945236:2024.10.26 05:05:12.213558 [ 701 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1945998:2024.10.26 05:05:12.336705 [ 1097 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1946470:2024.10.26 05:05:12.368599 [ 781 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_1000. Schedule next: true\r\n1946984:2024.10.26 05:05:12.459824 [ 951 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1947565:2024.10.26 05:05:12.581974 [ 866 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1947894:2024.10.26 05:05:12.705131 [ 974 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1948419:2024.10.26 05:05:12.895327 [ 5246 ] {test_de08ooxs_1234} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_1234. Schedule next: false\r\n1948426:2024.10.26 05:05:12.895632 [ 5249 ] {test_de08ooxs_1000} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_1000. Schedule next: false\r\n1948427:2024.10.26 05:05:12.895655 [ 4831 ] {test_de08ooxs_123} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: false\r\n1948430:2024.10.26 05:05:12.828517 [ 728 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_123. Schedule next: true\r\n1948432:2024.10.26 05:05:12.796953 [ 715 ] {} <Debug> QueryMetricLog: Collecting query_metric_log for query test_de08ooxs_1234. Schedule next: true\r\n```\r\n\r\nAnd\r\n\r\n```sql\r\nSELECT\r\n    event_time_microseconds,\r\n    ProfileEvent_SleepFunctionCalls,\r\n    ProfileEvent_SleepFunctionMicroseconds,\r\n    ProfileEvent_SleepFunctionElapsedMicroseconds\r\nFROM file('query_metric_log.tsv.zst')\r\nWHERE event_time = '2024-10-26 05:05:12'\r\nORDER BY event_time_microseconds ASC\r\n\r\nQuery id: 04e3b798-c2b1-4efa-a0f7-a476e451ac69\r\n\r\n    \u250c\u2500\u2500\u2500\u2500event_time_microseconds\u2500\u252c\u2500ProfileEvent_SleepFunctionCalls\u2500\u252c\u2500ProfileEvent_SleepFunctionMicroseconds\u2500\u252c\u2500ProfileEvent_SleepFunctionElapsedMicroseconds\u2500\u2510\r\n 1. \u2502 2024-10-26 05:05:12.090395 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 2. \u2502 2024-10-26 05:05:12.213534 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 3. \u2502 2024-10-26 05:05:12.336684 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 4. \u2502 2024-10-26 05:05:12.368582 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 5. \u2502 2024-10-26 05:05:12.459804 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 6. \u2502 2024-10-26 05:05:12.581957 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 7. \u2502 2024-10-26 05:05:12.705089 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 8. \u2502 2024-10-26 05:05:12.745783 \u2502                               0 \u2502                                      0 \u2502                                             0 \u2502\r\n 9. \u2502 2024-10-26 05:05:12.796929 \u2502            18446744073709551615 \u2502                   18446744073707051616 \u2502                          18446744073707051616 \u2502\r\n10. \u2502 2024-10-26 05:05:12.828479 \u2502            18446744073709551615 \u2502                   18446744073707051616 \u2502                          18446744073707051616 \u2502\r\n11. \u2502 2024-10-26 05:05:12.895315 \u2502                               1 \u2502                                2500000 \u2502                                       2500000 \u2502\r\n12. \u2502 2024-10-26 05:05:12.895623 \u2502                               1 \u2502                                2500000 \u2502                                       2500000 \u2502\r\n13. \u2502 2024-10-26 05:05:12.895647 \u2502                               1 \u2502                                2500000 \u2502                                       2500000 \u2502\r\n    \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n13 rows in set. Elapsed: 0.190 sec. \r\n```\r\n\r\nThe problem seems to be that some collecting tasks are collecting prior results, so the diff between the new and the old (which is actually more recent) is negative, which for an unsigned turns out to be a very large value. So, it's an actual issue on the source code, not on the test itself.\n",
  "hints_text": "",
  "created_at": "2024-11-05T14:32:09Z",
  "modified_files": [
    "base/base/defines.h",
    "src/Common/LockGuard.h",
    "src/Interpreters/QueryMetricLog.cpp",
    "src/Interpreters/QueryMetricLog.h",
    "src/Interpreters/executeQuery.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/03203_system_query_metric_log.reference",
    "tests/queries/0_stateless/03203_system_query_metric_log.sh"
  ]
}