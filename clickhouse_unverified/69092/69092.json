{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 69092,
  "instance_id": "ClickHouse__ClickHouse-69092",
  "issue_numbers": [
    "33748"
  ],
  "base_commit": "c9dd409baa8103362cef5e5d511ed3d85d7a7e34",
  "patch": "diff --git a/docs/en/engines/database-engines/materialized-postgresql.md b/docs/en/engines/database-engines/materialized-postgresql.md\nindex 3aa6dd01ea3e..97185f35e1e8 100644\n--- a/docs/en/engines/database-engines/materialized-postgresql.md\n+++ b/docs/en/engines/database-engines/materialized-postgresql.md\n@@ -155,6 +155,12 @@ Replication of [**TOAST**](https://www.postgresql.org/docs/9.5/storage-toast.htm\n \n     Sets a comma-separated list of PostgreSQL database tables, which will be replicated via [MaterializedPostgreSQL](../../engines/database-engines/materialized-postgresql.md) database engine.\n \n+    Each table can have subset of replicated columns in brackets. If subset of columns is omitted, then all columns for table will be replicated.\n+\n+    ``` sql\n+    materialized_postgresql_tables_list = 'table1(co1, col2),table2,table3(co3, col5, col7)\n+    ```\n+\n     Default value: empty list \u2014 means whole PostgreSQL database will be replicated.\n \n ### `materialized_postgresql_schema` {#materialized-postgresql-schema}\ndiff --git a/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.cpp b/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.cpp\nindex b9fd9c325f8a..45fd52f27abf 100644\n--- a/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.cpp\n+++ b/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.cpp\n@@ -13,6 +13,7 @@\n #include <DataTypes/DataTypeDateTime64.h>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/algorithm/string/trim.hpp>\n+#include <boost/algorithm/string/join.hpp>\n #include <Common/quoteString.h>\n #include <Core/PostgreSQL/Utils.h>\n #include <base/FnTraits.h>\n@@ -292,7 +293,7 @@ PostgreSQLTableStructure::ColumnsInfoPtr readNamesAndTypesList(\n \n template<typename T>\n PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n-        T & tx, const String & postgres_table, const String & postgres_schema, bool use_nulls, bool with_primary_key, bool with_replica_identity_index)\n+        T & tx, const String & postgres_table, const String & postgres_schema, bool use_nulls, bool with_primary_key, bool with_replica_identity_index, const Strings & columns)\n {\n     PostgreSQLTableStructure table;\n \n@@ -302,6 +303,10 @@ PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n         ? \" AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = 'public')\"\n         : fmt::format(\" AND relnamespace = (SELECT oid FROM pg_namespace WHERE nspname = {})\", quoteString(postgres_schema));\n \n+    std::string columns_part;\n+    if (!columns.empty())\n+        columns_part = fmt::format(\" AND attname IN ('{}')\", boost::algorithm::join(columns, \"','\"));\n+\n     std::string query = fmt::format(\n            \"SELECT attname AS name, \" /// column name\n            \"format_type(atttypid, atttypmod) AS type, \" /// data type\n@@ -312,9 +317,9 @@ PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n            \"attnum as att_num, \"\n            \"attgenerated as generated \" /// if column has GENERATED\n            \"FROM pg_attribute \"\n-           \"WHERE attrelid = (SELECT oid FROM pg_class WHERE {}) \"\n+           \"WHERE attrelid = (SELECT oid FROM pg_class WHERE {}) {}\"\n            \"AND NOT attisdropped AND attnum > 0 \"\n-           \"ORDER BY attnum ASC\", where);\n+           \"ORDER BY attnum ASC\", where, columns_part);\n \n     auto postgres_table_with_schema = postgres_schema.empty() ? postgres_table : doubleQuoteString(postgres_schema) + '.' + doubleQuoteString(postgres_table);\n     table.physical_columns = readNamesAndTypesList(tx, postgres_table_with_schema, query, use_nulls, false);\n@@ -415,7 +420,7 @@ PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n PostgreSQLTableStructure fetchPostgreSQLTableStructure(pqxx::connection & connection, const String & postgres_table, const String & postgres_schema, bool use_nulls)\n {\n     pqxx::ReadTransaction tx(connection);\n-    auto result = fetchPostgreSQLTableStructure(tx, postgres_table, postgres_schema, use_nulls, false, false);\n+    auto result = fetchPostgreSQLTableStructure(tx, postgres_table, postgres_schema, use_nulls, false, false, {});\n     tx.commit();\n     return result;\n }\n@@ -433,17 +438,17 @@ std::set<String> fetchPostgreSQLTablesList(pqxx::connection & connection, const\n template\n PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n         pqxx::ReadTransaction & tx, const String & postgres_table, const String & postgres_schema,\n-        bool use_nulls, bool with_primary_key, bool with_replica_identity_index);\n+        bool use_nulls, bool with_primary_key, bool with_replica_identity_index, const Strings & columns);\n \n template\n PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n         pqxx::ReplicationTransaction & tx, const String & postgres_table, const String & postgres_schema,\n-        bool use_nulls, bool with_primary_key, bool with_replica_identity_index);\n+        bool use_nulls, bool with_primary_key, bool with_replica_identity_index, const Strings & columns);\n \n template\n PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n         pqxx::nontransaction & tx, const String & postgres_table, const String & postrges_schema,\n-        bool use_nulls, bool with_primary_key, bool with_replica_identity_index);\n+        bool use_nulls, bool with_primary_key, bool with_replica_identity_index, const Strings & columns);\n \n std::set<String> fetchPostgreSQLTablesList(pqxx::work & tx, const String & postgres_schema);\n \ndiff --git a/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.h b/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.h\nindex 25ece6909fd5..6f7bae44c356 100644\n--- a/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.h\n+++ b/src/Databases/PostgreSQL/fetchPostgreSQLTableStructure.h\n@@ -48,7 +48,7 @@ PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n template<typename T>\n PostgreSQLTableStructure fetchPostgreSQLTableStructure(\n     T & tx, const String & postgres_table, const String & postgres_schema, bool use_nulls = true,\n-    bool with_primary_key = false, bool with_replica_identity_index = false);\n+    bool with_primary_key = false, bool with_replica_identity_index = false, const Strings & columns = {});\n \n template<typename T>\n std::set<String> fetchPostgreSQLTablesList(T & tx, const String & postgres_schema);\ndiff --git a/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.cpp b/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.cpp\nindex 01f78673ed83..2fe1fb5905ad 100644\n--- a/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.cpp\n+++ b/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.cpp\n@@ -348,11 +348,10 @@ void PostgreSQLReplicationHandler::startSynchronization(bool throw_on_error)\n             auto * materialized_storage = storage->as <StorageMaterializedPostgreSQL>();\n             try\n             {\n-                auto [postgres_table_schema, postgres_table_name] = getSchemaAndTableName(table_name);\n-                auto table_structure = fetchPostgreSQLTableStructure(tx, postgres_table_name, postgres_table_schema, true, true, true);\n-                if (!table_structure.physical_columns)\n+                auto table_structure = fetchTableStructure(tx, table_name);\n+                if (!table_structure->physical_columns)\n                     throw Exception(ErrorCodes::LOGICAL_ERROR, \"No columns\");\n-                auto storage_info = StorageInfo(materialized_storage->getNested(), table_structure.physical_columns->attributes);\n+                auto storage_info = StorageInfo(materialized_storage->getNested(), table_structure->physical_columns->attributes);\n                 nested_storages.emplace(table_name, std::move(storage_info));\n             }\n             catch (Exception & e)\n@@ -399,9 +398,7 @@ ASTPtr PostgreSQLReplicationHandler::getCreateNestedTableQuery(StorageMaterializ\n     postgres::Connection connection(connection_info);\n     pqxx::nontransaction tx(connection.getRef());\n \n-    auto [postgres_table_schema, postgres_table_name] = getSchemaAndTableName(table_name);\n-    auto table_structure = std::make_unique<PostgreSQLTableStructure>(fetchPostgreSQLTableStructure(tx, postgres_table_name, postgres_table_schema, true, true, true));\n-\n+    auto table_structure = fetchTableStructure(tx, table_name);\n     auto table_override = tryGetTableOverride(current_database_name, table_name);\n     return storage->getCreateNestedTableQuery(std::move(table_structure), table_override ? table_override->as<ASTTableOverride>() : nullptr);\n }\n@@ -415,16 +412,35 @@ StorageInfo PostgreSQLReplicationHandler::loadFromSnapshot(postgres::Connection\n     std::string query_str = fmt::format(\"SET TRANSACTION SNAPSHOT '{}'\", snapshot_name);\n     tx->exec(query_str);\n \n-    auto table_structure = fetchTableStructure(*tx, table_name);\n+    PostgreSQLTableStructurePtr table_structure;\n+    try\n+    {\n+        table_structure = fetchTableStructure(*tx, table_name);\n+    }\n+    catch (...)\n+    {\n+        tryLogCurrentException(__PRETTY_FUNCTION__);\n+        table_structure = std::make_unique<PostgreSQLTableStructure>();\n+    }\n     if (!table_structure->physical_columns)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"No table attributes\");\n \n     auto table_attributes = table_structure->physical_columns->attributes;\n+    auto columns = getTableAllowedColumns(table_name);\n \n     /// Load from snapshot, which will show table state before creation of replication slot.\n     /// Already connected to needed database, no need to add it to query.\n     auto quoted_name = doubleQuoteWithSchema(table_name);\n-    query_str = fmt::format(\"SELECT * FROM ONLY {}\", quoted_name);\n+    if (columns.empty())\n+        query_str = fmt::format(\"SELECT * FROM ONLY {}\", quoted_name);\n+    else\n+    {\n+        /// We should not use columns list from getTableAllowedColumns because it may have broken columns order\n+        Strings allowed_columns;\n+        for (const auto & column : table_structure->physical_columns->columns)\n+            allowed_columns.push_back(column.name);\n+        query_str = fmt::format(\"SELECT {} FROM ONLY {}\", boost::algorithm::join(allowed_columns, \",\"), quoted_name);\n+    }\n \n     LOG_DEBUG(log, \"Loading PostgreSQL table {}.{}\", postgres_database, quoted_name);\n \n@@ -700,6 +716,37 @@ void PostgreSQLReplicationHandler::setSetting(const SettingChange & setting)\n }\n \n \n+/// Allowed columns for table from materialized_postgresql_tables_list setting\n+Strings PostgreSQLReplicationHandler::getTableAllowedColumns(const std::string & table_name) const\n+{\n+    Strings result;\n+    if (tables_list.empty())\n+        return result;\n+\n+    size_t table_pos = tables_list.find(table_name);\n+    if (table_pos == std::string::npos)\n+    {\n+        return result;\n+    }\n+\n+    if (table_pos + table_name.length() + 1 > tables_list.length())\n+    {\n+        return result;\n+    }\n+    String column_list = tables_list.substr(table_pos + table_name.length() + 1);\n+    column_list.erase(std::remove(column_list.begin(), column_list.end(), '\"'), column_list.end());\n+    boost::trim(column_list);\n+    if (column_list.empty() || column_list[0] != '(')\n+        return result;\n+\n+    size_t end_bracket_pos = column_list.find(')');\n+    column_list = column_list.substr(1, end_bracket_pos - 1);\n+    splitInto<','>(result, column_list);\n+\n+    return result;\n+}\n+\n+\n void PostgreSQLReplicationHandler::shutdownFinal()\n {\n     try\n@@ -749,11 +796,27 @@ std::set<String> PostgreSQLReplicationHandler::fetchRequiredTables()\n     Strings expected_tables;\n     if (!tables_list.empty())\n     {\n-         splitInto<','>(expected_tables, tables_list);\n-         if (expected_tables.empty())\n-             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Cannot parse tables list: {}\", tables_list);\n-         for (auto & table_name : expected_tables)\n-             boost::trim(table_name);\n+        /// Removing columns `table(col1, col2)` from tables_list\n+        String cleared_tables_list = tables_list;\n+        while (true)\n+        {\n+            size_t start_bracket_pos = cleared_tables_list.find('(');\n+            size_t end_bracket_pos = cleared_tables_list.find(')');\n+            if (start_bracket_pos == std::string::npos || end_bracket_pos == std::string::npos)\n+            {\n+                break;\n+            }\n+            cleared_tables_list = cleared_tables_list.substr(0, start_bracket_pos) + cleared_tables_list.substr(end_bracket_pos + 1);\n+        }\n+\n+        splitInto<','>(expected_tables, cleared_tables_list);\n+        if (expected_tables.empty())\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Cannot parse tables list: {}\", tables_list);\n+\n+        for (auto & table_name : expected_tables)\n+        {\n+            boost::trim(table_name);\n+        }\n     }\n \n     /// Try to fetch tables list from publication if there is not tables list.\n@@ -864,18 +927,50 @@ std::set<String> PostgreSQLReplicationHandler::fetchRequiredTables()\n     /// `schema1.table1, schema2.table2, ...` -> `\"schema1\".\"table1\", \"schema2\".\"table2\", ...`\n     /// or\n     /// `table1, table2, ...` + setting `schema` -> `\"schema\".\"table1\", \"schema\".\"table2\", ...`\n+    /// or\n+    /// `table1, table2(id,name), ...` + setting `schema` -> `\"schema\".\"table1\", \"schema\".\"table2\"(\"id\",\"name\"), ...`\n     if (!tables_list.empty())\n     {\n-        Strings tables_names;\n-        splitInto<','>(tables_names, tables_list);\n-        if (tables_names.empty())\n+        Strings parts;\n+        splitInto<','>(parts, tables_list);\n+        if (parts.empty())\n             throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Empty list of tables\");\n \n+        bool is_column = false;\n         WriteBufferFromOwnString buf;\n-        for (auto & table_name : tables_names)\n+        for (auto & part : parts)\n         {\n-            boost::trim(table_name);\n-            buf << doubleQuoteWithSchema(table_name);\n+            boost::trim(part);\n+\n+            size_t bracket_pos = part.find('(');\n+            if (bracket_pos != std::string::npos)\n+            {\n+                is_column = true;\n+                std::string table_name = part.substr(0, bracket_pos);\n+                boost::trim(table_name);\n+                buf << doubleQuoteWithSchema(table_name);\n+\n+                part = part.substr(bracket_pos + 1);\n+                boost::trim(part);\n+                buf << '(';\n+                buf << doubleQuoteString(part);\n+            }\n+            else if (part.back() == ')')\n+            {\n+                is_column = false;\n+                part = part.substr(0, part.size() - 1);\n+                boost::trim(part);\n+                buf << doubleQuoteString(part);\n+                buf << ')';\n+            }\n+            else if (is_column)\n+            {\n+                buf << doubleQuoteString(part);\n+            }\n+            else\n+            {\n+                buf << doubleQuoteWithSchema(part);\n+            }\n             buf << \",\";\n         }\n         tables_list = buf.str();\n@@ -902,23 +997,28 @@ std::set<String> PostgreSQLReplicationHandler::fetchTablesFromPublication(pqxx::\n }\n \n \n+template<typename T>\n PostgreSQLTableStructurePtr PostgreSQLReplicationHandler::fetchTableStructure(\n-        pqxx::ReplicationTransaction & tx, const std::string & table_name) const\n+        T & tx, const std::string & table_name) const\n {\n     PostgreSQLTableStructure structure;\n-    try\n-    {\n-        auto [schema, table] = getSchemaAndTableName(table_name);\n-        structure = fetchPostgreSQLTableStructure(tx, table, schema, true, true, true);\n-    }\n-    catch (...)\n-    {\n-        tryLogCurrentException(__PRETTY_FUNCTION__);\n-    }\n+    auto [schema, table] = getSchemaAndTableName(table_name);\n+    structure = fetchPostgreSQLTableStructure(tx, table, schema, true, true, true, getTableAllowedColumns(table_name));\n \n     return std::make_unique<PostgreSQLTableStructure>(std::move(structure));\n }\n \n+template\n+PostgreSQLTableStructurePtr PostgreSQLReplicationHandler::fetchTableStructure(\n+        pqxx::ReadTransaction & tx, const std::string & table_name) const;\n+\n+template\n+PostgreSQLTableStructurePtr PostgreSQLReplicationHandler::fetchTableStructure(\n+        pqxx::ReplicationTransaction & tx, const std::string & table_name) const;\n+\n+template\n+PostgreSQLTableStructurePtr PostgreSQLReplicationHandler::fetchTableStructure(\n+        pqxx::nontransaction & tx, const std::string & table_name) const;\n \n void PostgreSQLReplicationHandler::addTableToReplication(StorageMaterializedPostgreSQL * materialized_storage, const String & postgres_table_name)\n {\ndiff --git a/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.h b/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.h\nindex 5c519053d844..8257f92ae1f3 100644\n--- a/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.h\n+++ b/src/Storages/PostgreSQL/PostgreSQLReplicationHandler.h\n@@ -57,6 +57,8 @@ friend class TemporaryReplicationSlot;\n \n     void setSetting(const SettingChange & setting);\n \n+    Strings getTableAllowedColumns(const std::string & table_name) const;\n+\n     void cleanupFunc();\n \n private:\n@@ -94,7 +96,8 @@ friend class TemporaryReplicationSlot;\n \n     StorageInfo loadFromSnapshot(postgres::Connection & connection, std::string & snapshot_name, const String & table_name, StorageMaterializedPostgreSQL * materialized_storage);\n \n-    PostgreSQLTableStructurePtr fetchTableStructure(pqxx::ReplicationTransaction & tx, const String & table_name) const;\n+    template<typename T>\n+    PostgreSQLTableStructurePtr fetchTableStructure(T & tx, const String & table_name) const;\n \n     String doubleQuoteWithSchema(const String & table_name) const;\n \n",
  "test_patch": "diff --git a/tests/integration/helpers/postgres_utility.py b/tests/integration/helpers/postgres_utility.py\nindex 468c3b3bb636..76dddd7d0cfa 100644\n--- a/tests/integration/helpers/postgres_utility.py\n+++ b/tests/integration/helpers/postgres_utility.py\n@@ -359,6 +359,7 @@ def check_tables_are_synchronized(\n     postgres_database=\"postgres_database\",\n     materialized_database=\"test_database\",\n     schema_name=\"\",\n+    columns=[\"*\"],\n ):\n     assert_nested_table_is_created(\n         instance, table_name, materialized_database, schema_name\n@@ -374,7 +375,7 @@ def check_tables_are_synchronized(\n     result_query = f\"select * from {table_path} order by {order_by};\"\n \n     expected = instance.query(\n-        f\"select * from `{postgres_database}`.`{table_name}` order by {order_by};\"\n+        f\"select {','.join(columns)} from `{postgres_database}`.`{table_name}` order by {order_by};\"\n     )\n     result = instance.query(result_query)\n \ndiff --git a/tests/integration/test_postgresql_replica_database_engine_2/test.py b/tests/integration/test_postgresql_replica_database_engine_2/test.py\nindex 7fdd17625a9c..e64c9eb9d1ec 100644\n--- a/tests/integration/test_postgresql_replica_database_engine_2/test.py\n+++ b/tests/integration/test_postgresql_replica_database_engine_2/test.py\n@@ -1141,6 +1141,110 @@ def test_dependent_loading(started_cluster):\n     instance.query(f\"DROP TABLE {table} SYNC\")\n \n \n+def test_partial_table(started_cluster):\n+    table = \"test_partial_table\"\n+\n+    pg_manager.create_postgres_table(\n+        table,\n+        \"\",\n+        f\"\"\"CREATE TABLE {table} (\n+             key integer PRIMARY KEY,\n+             x integer DEFAULT 0,\n+             y integer,\n+             z text DEFAULT 'z');\n+         \"\"\",\n+    )\n+    pg_manager.execute(f\"insert into {table} (key, x, z) values (1,1,'a');\")\n+    pg_manager.execute(f\"insert into {table} (key, x, z) values (2,2,'b');\")\n+\n+    pg_manager.create_materialized_db(\n+        ip=started_cluster.postgres_ip,\n+        port=started_cluster.postgres_port,\n+        settings=[\n+            f\"materialized_postgresql_tables_list = '{table}(z, key)'\",\n+            \"materialized_postgresql_backoff_min_ms = 100\",\n+            \"materialized_postgresql_backoff_max_ms = 100\",\n+        ],\n+    )\n+    check_tables_are_synchronized(\n+        instance,\n+        table,\n+        postgres_database=pg_manager.get_default_database(),\n+        columns=[\"key\", \"z\"],\n+    )\n+\n+    pg_manager.execute(f\"insert into {table} (key, x, z) values (3,3,'c');\")\n+    pg_manager.execute(f\"insert into {table} (key, x, z) values (4,4,'d');\")\n+\n+    check_tables_are_synchronized(\n+        instance,\n+        table,\n+        postgres_database=pg_manager.get_default_database(),\n+        columns=[\"key\", \"z\"],\n+    )\n+\n+\n+def test_partial_and_full_table(started_cluster):\n+    table = \"test_partial_and_full_table\"\n+\n+    pg_manager.create_postgres_table(\n+        table,\n+        \"\",\n+        f\"\"\"CREATE TABLE {table}1 (\n+             key integer PRIMARY KEY,\n+             x integer DEFAULT 0,\n+             y integer,\n+             z text DEFAULT 'z');\n+         \"\"\",\n+    )\n+    pg_manager.execute(f\"insert into {table}1 (key, x, y, z) values (1,1,1,'1');\")\n+    pg_manager.execute(f\"insert into {table}1 (key, x, y, z) values (2,2,2,'2');\")\n+    pg_manager.create_postgres_table(\n+        table,\n+        \"\",\n+        f\"\"\"CREATE TABLE {table}2 (\n+             key integer PRIMARY KEY,\n+             x integer DEFAULT 0,\n+             y integer,\n+             z text DEFAULT 'z');\n+         \"\"\",\n+    )\n+    pg_manager.execute(f\"insert into {table}2 (key, x, y, z) values (3,3,3,'3');\")\n+    pg_manager.execute(f\"insert into {table}2 (key, x, y, z) values (4,4,4,'4');\")\n+\n+    pg_manager.create_materialized_db(\n+        ip=started_cluster.postgres_ip,\n+        port=started_cluster.postgres_port,\n+        settings=[\n+            f\"materialized_postgresql_tables_list = '{table}1(key, x, z), {table}2'\",\n+            \"materialized_postgresql_backoff_min_ms = 100\",\n+            \"materialized_postgresql_backoff_max_ms = 100\",\n+        ],\n+    )\n+    check_tables_are_synchronized(\n+        instance,\n+        f\"{table}1\",\n+        postgres_database=pg_manager.get_default_database(),\n+        columns=[\"key\", \"x\", \"z\"],\n+    )\n+    check_tables_are_synchronized(\n+        instance, f\"{table}2\", postgres_database=pg_manager.get_default_database()\n+    )\n+\n+    pg_manager.execute(f\"insert into {table}1 (key, x, z) values (3,3,'3');\")\n+    pg_manager.execute(f\"insert into {table}2 (key, x, z) values (5,5,'5');\")\n+\n+    check_tables_are_synchronized(\n+        instance,\n+        f\"{table}1\",\n+        postgres_database=pg_manager.get_default_database(),\n+        columns=[\"key\", \"x\", \"z\"],\n+    )\n+    check_tables_are_synchronized(\n+        instance, f\"{table}2\", postgres_database=pg_manager.get_default_database()\n+    )\n+\n+\n if __name__ == \"__main__\":\n     cluster.start()\n     input(\"Cluster created, press any key to destroy...\")\n",
  "problem_statement": "Allow replicate subset of columns through MaterializedPostgreSQL?\nHello!\r\n\r\nAs part of the project, we use postgresql replication in clickhouse through the creation of MaterializedPostgreSQL.\r\nThere was a need not to replicate some columns of tables.\r\nIs it possible to limit replicated columns in a table?\r\n\r\n\n",
  "hints_text": "Hello.\r\nIt is not possible right now to limit columns of tables to be replicated.\r\nBut it is possible to implement.\r\nBut I don't think I will find time for that any time soon.\r\nI'll keep this feature in mind.\r\nIf you want - you can try to implement it too and send a PR :) I can tell what is takes to do to implement this.\nOk, thank you. We will wait this feature :)",
  "created_at": "2024-08-30T08:51:38Z"
}