{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 22001,
  "instance_id": "ClickHouse__ClickHouse-22001",
  "issue_numbers": [
    "9959"
  ],
  "base_commit": "4de5afed4eb15e1fc2f57721df0e464557410a43",
  "patch": "diff --git a/src/Functions/registerFunctionsMiscellaneous.cpp b/src/Functions/registerFunctionsMiscellaneous.cpp\nindex 592f0d6774d0..ca9bc32486e6 100644\n--- a/src/Functions/registerFunctionsMiscellaneous.cpp\n+++ b/src/Functions/registerFunctionsMiscellaneous.cpp\n@@ -41,7 +41,8 @@ void registerFunctionThrowIf(FunctionFactory &);\n void registerFunctionVersion(FunctionFactory &);\n void registerFunctionBuildId(FunctionFactory &);\n void registerFunctionUptime(FunctionFactory &);\n-void registerFunctionTimeZone(FunctionFactory &);\n+void registerFunctionTimezone(FunctionFactory &);\n+void registerFunctionTimezoneOf(FunctionFactory &);\n void registerFunctionRunningAccumulate(FunctionFactory &);\n void registerFunctionRunningDifference(FunctionFactory &);\n void registerFunctionRunningDifferenceStartingWithFirstValue(FunctionFactory &);\n@@ -111,7 +112,8 @@ void registerFunctionsMiscellaneous(FunctionFactory & factory)\n     registerFunctionVersion(factory);\n     registerFunctionBuildId(factory);\n     registerFunctionUptime(factory);\n-    registerFunctionTimeZone(factory);\n+    registerFunctionTimezone(factory);\n+    registerFunctionTimezoneOf(factory);\n     registerFunctionRunningAccumulate(factory);\n     registerFunctionRunningDifference(factory);\n     registerFunctionRunningDifferenceStartingWithFirstValue(factory);\ndiff --git a/src/Functions/timezone.cpp b/src/Functions/timezone.cpp\nindex 4522f21c8b2e..2cd0c28612ba 100644\n--- a/src/Functions/timezone.cpp\n+++ b/src/Functions/timezone.cpp\n@@ -12,13 +12,13 @@ namespace\n \n /** Returns the server time zone.\n   */\n-class FunctionTimeZone : public IFunction\n+class FunctionTimezone : public IFunction\n {\n public:\n     static constexpr auto name = \"timezone\";\n     static FunctionPtr create(const Context &)\n     {\n-        return std::make_shared<FunctionTimeZone>();\n+        return std::make_shared<FunctionTimezone>();\n     }\n \n     String getName() const override\n@@ -45,9 +45,10 @@ class FunctionTimeZone : public IFunction\n \n }\n \n-void registerFunctionTimeZone(FunctionFactory & factory)\n+void registerFunctionTimezone(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionTimeZone>();\n+    factory.registerFunction<FunctionTimezone>();\n+    factory.registerAlias(\"timeZone\", \"timezone\");\n }\n \n }\ndiff --git a/src/Functions/timezoneOf.cpp b/src/Functions/timezoneOf.cpp\nnew file mode 100644\nindex 000000000000..1d007a6e10ee\n--- /dev/null\n+++ b/src/Functions/timezoneOf.cpp\n@@ -0,0 +1,118 @@\n+#include <Functions/IFunctionImpl.h>\n+#include <Functions/FunctionFactory.h>\n+#include <DataTypes/DataTypeString.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <common/DateLUTImpl.h>\n+#include <Core/Field.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n+\n+namespace\n+{\n+\n+\n+/** timezoneOf(x) - get the name of the timezone of DateTime data type.\n+  * Example: Europe/Moscow.\n+  */\n+class ExecutableFunctionTimezoneOf : public IExecutableFunctionImpl\n+{\n+public:\n+    static constexpr auto name = \"timezoneOf\";\n+    String getName() const override { return name; }\n+\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n+\n+    /// Execute the function on the columns.\n+    ColumnPtr execute(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        DataTypePtr type_no_nullable = removeNullable(arguments[0].type);\n+\n+        return DataTypeString().createColumnConst(input_rows_count,\n+            dynamic_cast<const TimezoneMixin &>(*type_no_nullable).getTimeZone().getTimeZone());\n+    }\n+};\n+\n+\n+class BaseFunctionTimezoneOf : public IFunctionBaseImpl\n+{\n+public:\n+    BaseFunctionTimezoneOf(DataTypes argument_types_, DataTypePtr return_type_)\n+        : argument_types(std::move(argument_types_)), return_type(std::move(return_type_)) {}\n+\n+    static constexpr auto name = \"timezoneOf\";\n+    String getName() const override { return name; }\n+\n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n+\n+    const DataTypes & getArgumentTypes() const override { return argument_types; }\n+    const DataTypePtr & getResultType() const override { return return_type; }\n+\n+    ExecutableFunctionImplPtr prepare(const ColumnsWithTypeAndName &) const override\n+    {\n+        return std::make_unique<ExecutableFunctionTimezoneOf>();\n+    }\n+\n+    ColumnPtr getResultIfAlwaysReturnsConstantAndHasArguments(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        DataTypePtr type_no_nullable = removeNullable(arguments[0].type);\n+\n+        return DataTypeString().createColumnConst(1,\n+            dynamic_cast<const TimezoneMixin &>(*type_no_nullable).getTimeZone().getTimeZone());\n+    }\n+\n+private:\n+    DataTypes argument_types;\n+    DataTypePtr return_type;\n+};\n+\n+\n+class FunctionTimezoneOfBuilder : public IFunctionOverloadResolverImpl\n+{\n+public:\n+    static constexpr auto name = \"timezoneOf\";\n+    String getName() const override { return name; }\n+    static FunctionOverloadResolverImplPtr create(const Context &) { return std::make_unique<FunctionTimezoneOfBuilder>(); }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+\n+    DataTypePtr getReturnType(const DataTypes & types) const override\n+    {\n+        DataTypePtr type_no_nullable = removeNullable(types[0]);\n+\n+        if (isDateTime(type_no_nullable) || isDateTime64(type_no_nullable))\n+            return std::make_shared<DataTypeString>();\n+        else\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Bad argument for function {}, should be DateTime or DateTime64\", name);\n+    }\n+\n+    FunctionBaseImplPtr build(const ColumnsWithTypeAndName & arguments, const DataTypePtr & return_type) const override\n+    {\n+        return std::make_unique<BaseFunctionTimezoneOf>(DataTypes{arguments[0].type}, return_type);\n+    }\n+\n+    bool useDefaultImplementationForNulls() const override { return false; }\n+    bool useDefaultImplementationForLowCardinalityColumns() const override { return false; }\n+    ColumnNumbers getArgumentsThatDontImplyNullableReturnType(size_t /*number_of_arguments*/) const override { return {0}; }\n+};\n+\n+}\n+\n+void registerFunctionTimezoneOf(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionTimezoneOfBuilder>();\n+    factory.registerAlias(\"timeZoneOf\", \"timezoneOf\");\n+}\n+\n+}\n+\ndiff --git a/src/Functions/toTimeZone.cpp b/src/Functions/toTimezone.cpp\nsimilarity index 90%\nrename from src/Functions/toTimeZone.cpp\nrename to src/Functions/toTimezone.cpp\nindex fbf3a0778a61..d12f926b2847 100644\n--- a/src/Functions/toTimeZone.cpp\n+++ b/src/Functions/toTimezone.cpp\n@@ -21,11 +21,11 @@ namespace\n {\n \n /// Just changes time zone information for data type. The calculation is free.\n-class FunctionToTimeZone : public IFunction\n+class FunctionToTimezone : public IFunction\n {\n public:\n-    static constexpr auto name = \"toTimeZone\";\n-    static FunctionPtr create(const Context &) { return std::make_shared<FunctionToTimeZone>(); }\n+    static constexpr auto name = \"toTimezone\";\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionToTimezone>(); }\n \n     String getName() const override\n     {\n@@ -64,7 +64,8 @@ class FunctionToTimeZone : public IFunction\n \n void registerFunctionToTimeZone(FunctionFactory & factory)\n {\n-    factory.registerFunction<FunctionToTimeZone>();\n+    factory.registerFunction<FunctionToTimezone>();\n+    factory.registerAlias(\"toTimeZone\", \"toTimezone\");\n }\n \n }\ndiff --git a/src/Functions/ya.make b/src/Functions/ya.make\nindex 3ac64828b9c1..aed2bd9b70d6 100644\n--- a/src/Functions/ya.make\n+++ b/src/Functions/ya.make\n@@ -467,6 +467,7 @@ SRCS(\n     timeSlot.cpp\n     timeSlots.cpp\n     timezone.cpp\n+    timezoneOf.cpp\n     timezoneOffset.cpp\n     toColumnTypeName.cpp\n     toCustomWeek.cpp\n@@ -506,7 +507,7 @@ SRCS(\n     toStartOfTenMinutes.cpp\n     toStartOfYear.cpp\n     toTime.cpp\n-    toTimeZone.cpp\n+    toTimezone.cpp\n     toTypeName.cpp\n     toUnixTimestamp64Micro.cpp\n     toUnixTimestamp64Milli.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01767_timezoneOf.reference b/tests/queries/0_stateless/01767_timezoneOf.reference\nnew file mode 100644\nindex 000000000000..0a8a8c32d4e1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01767_timezoneOf.reference\n@@ -0,0 +1,1 @@\n+Asia/Tehran\tAsia/Tehran\tAsia/Tehran\tAfrica/Accra\tPacific/Pitcairn\ndiff --git a/tests/queries/0_stateless/01767_timezoneOf.sh b/tests/queries/0_stateless/01767_timezoneOf.sh\nnew file mode 100755\nindex 000000000000..9dee051ee3f0\n--- /dev/null\n+++ b/tests/queries/0_stateless/01767_timezoneOf.sh\n@@ -0,0 +1,7 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+TZ=Asia/Tehran $CLICKHOUSE_LOCAL --query \"SELECT timezone(), timezoneOf(now()), timeZone(), timeZoneOf(toTimezone(toNullable(now()), 'Africa/Accra')), timeZoneOf(toTimeZone(now64(3), 'Pacific/Pitcairn'))\"\n",
  "problem_statement": "Date&Time improvements\n- [x] Add getTimeZone function. Trivial, but can help user to answer question about timezone in all cases - `toTypeName` for `DateTime` without timezone does not answer this question and you need to read the docs\r\n``` sql\r\ngetTimeZone(now()) = timezone()\r\n```\r\n- [ ] Add modifier in formatDateTime to print 'Time offsets from UTC' in following formats `\"+02:00\",\"+0200\", or \"+02\".` Note: `+00:00` should be printed with no offset.\r\n\r\n- [x] Add parseDateTimeBestEffort description. At least describe arguments. Probably move out of type conversions. \r\n\r\n- [ ] dateDiff documentation is incomplete. Probably we should define function behavior more strictly.\n",
  "hints_text": "> Note: +00:00 should be printed with no offset.\r\n\r\nISO 8601 also allows Z.\n> getTimeZone\r\n\r\nA bit of a hack, but it can be implemented by\r\n`if(toTypeName(val) like 'DateTime%(%', splitByChar('\\'', toTypeName(val))[2], NULL))`\r\n\r\nExample:\r\n```(sql)\r\nselect\r\n    toDateTime(now(), 'Europe/Moscow') as val,\r\n    if(\r\n        toTypeName(val) = 'DateTime',\r\n        timezone(),\r\n        if(\r\n            toTypeName(val) like 'DateTime%(%',\r\n            splitByChar('\\'', toTypeName(val))[2],\r\n            NULL))\r\n    as val_tz\r\nformat JSONCompact\r\n```\nIt would also be great to add a modifier to formatDateTime to print subsecond values when used in conjunction with DateTime64. Together with the timezone offset from above I would then be able to get a full ISO-8601 timestamp from DateTime64 like `2020-11-27T14:54:10.123456Z`.",
  "created_at": "2021-03-22T19:52:15Z"
}