{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9860,
  "instance_id": "ClickHouse__ClickHouse-9860",
  "issue_numbers": [
    "9850"
  ],
  "base_commit": "fa219179f957276fe99da72b80d98c5715649f02",
  "patch": "diff --git a/dbms/src/Interpreters/MutationsInterpreter.cpp b/dbms/src/Interpreters/MutationsInterpreter.cpp\nindex 056fd5b597a8..9ff7d2bf126e 100644\n--- a/dbms/src/Interpreters/MutationsInterpreter.cpp\n+++ b/dbms/src/Interpreters/MutationsInterpreter.cpp\n@@ -620,38 +620,23 @@ ASTPtr MutationsInterpreter::prepareInterpreterSelectQuery(std::vector<Stage> &\n         }\n         select->setExpression(ASTSelectQuery::Expression::WHERE, std::move(where_expression));\n     }\n-    auto metadata = storage->getInMemoryMetadata();\n     /// We have to execute select in order of primary key\n     /// because we don't sort results additionaly and don't have\n     /// any guarantees on data order without ORDER BY. It's almost free, because we\n     /// have optimization for data read in primary key order.\n-    if (metadata.order_by_ast)\n+    if (ASTPtr key_expr = storage->getSortingKeyAST(); key_expr && !key_expr->children.empty())\n     {\n         ASTPtr dummy;\n-\n-        ASTPtr key_expr;\n-        if (metadata.primary_key_ast)\n-            key_expr = metadata.primary_key_ast;\n-        else\n-            key_expr = metadata.order_by_ast;\n-\n-        bool empty = false;\n-        /// In all other cases we cannot have empty key\n-        if (auto key_function = key_expr->as<ASTFunction>())\n-            empty = key_function->arguments->children.empty();\n-\n-        /// Not explicitely spicified empty key\n-        if (!empty)\n+        auto res = std::make_shared<ASTExpressionList>();\n+        for (const auto & key_part : key_expr->children)\n         {\n             auto order_by_expr = std::make_shared<ASTOrderByElement>(1, 1, false, dummy, false, dummy, dummy, dummy);\n+            order_by_expr->children.push_back(key_part);\n \n-\n-            order_by_expr->children.push_back(key_expr);\n-            auto res = std::make_shared<ASTExpressionList>();\n             res->children.push_back(order_by_expr);\n-\n-            select->setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(res));\n         }\n+\n+        select->setExpression(ASTSelectQuery::Expression::ORDER_BY, std::move(res));\n     }\n \n     return select;\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.reference b/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.reference\nindex d00491fd7e5b..98fb6a686563 100644\n--- a/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.reference\n+++ b/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.reference\n@@ -1,1 +1,4 @@\n 1\n+1\n+1\n+1\ndiff --git a/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.sql b/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.sql\nindex 3c9d14b58cb1..764117586b98 100644\n--- a/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.sql\n+++ b/dbms/tests/queries/0_stateless/01200_mutations_memory_consumption.sql\n@@ -1,6 +1,6 @@\n-DROP TABLE IF EXISTS table_with_pk;\n+DROP TABLE IF EXISTS table_with_single_pk;\n \n-CREATE TABLE table_with_pk\n+CREATE TABLE table_with_single_pk\n (\n   key UInt8,\n   value String\n@@ -8,9 +8,9 @@ CREATE TABLE table_with_pk\n ENGINE = MergeTree\n ORDER BY key;\n \n-INSERT INTO table_with_pk SELECT number, toString(number % 10) FROM numbers(10000000);\n+INSERT INTO table_with_single_pk SELECT number, toString(number % 10) FROM numbers(10000000);\n \n-ALTER TABLE table_with_pk DELETE WHERE key % 77 = 0 SETTINGS mutations_sync = 1;\n+ALTER TABLE table_with_single_pk DELETE WHERE key % 77 = 0 SETTINGS mutations_sync = 1;\n \n SYSTEM FLUSH LOGS;\n \n@@ -20,6 +20,92 @@ SELECT\n   DISTINCT read_bytes >= peak_memory_usage\n FROM\n     system.part_log\n-WHERE event_type = 'MutatePart' AND table = 'table_with_pk' AND database = currentDatabase();\n+WHERE event_type = 'MutatePart' AND table = 'table_with_single_pk' AND database = currentDatabase();\n \n-DROP TABLE IF EXISTS table_with_pk;\n+DROP TABLE IF EXISTS table_with_single_pk;\n+\n+DROP TABLE IF EXISTS table_with_multi_pk;\n+\n+CREATE TABLE table_with_multi_pk\n+(\n+  key1 UInt8,\n+  key2 UInt32,\n+  key3 DateTime64(6, 'UTC'),\n+  value String\n+)\n+ENGINE = MergeTree\n+ORDER BY (key1, key2, key3);\n+\n+INSERT INTO table_with_multi_pk SELECT number % 32, number, toDateTime('2019-10-01 00:00:00'), toString(number % 10) FROM numbers(10000000);\n+\n+ALTER TABLE table_with_multi_pk DELETE WHERE key1 % 77 = 0 SETTINGS mutations_sync = 1;\n+\n+SYSTEM FLUSH LOGS;\n+\n+-- Memory usage for all mutations must be almost constant and less than\n+-- read_bytes.\n+SELECT\n+  DISTINCT read_bytes >= peak_memory_usage\n+  FROM\n+      system.part_log\n+ WHERE event_type = 'MutatePart' AND table = 'table_with_multi_pk' AND database = currentDatabase();\n+\n+DROP TABLE IF EXISTS table_with_multi_pk;\n+\n+\n+DROP TABLE IF EXISTS table_with_function_pk;\n+\n+\n+CREATE TABLE table_with_function_pk\n+  (\n+    key1 UInt8,\n+    key2 UInt32,\n+    key3 DateTime64(6, 'UTC'),\n+    value String\n+  )\n+ENGINE = MergeTree\n+ORDER BY (cast(value as UInt64), key2);\n+\n+INSERT INTO table_with_function_pk SELECT number % 32, number, toDateTime('2019-10-01 00:00:00'), toString(number % 10) FROM numbers(10000000);\n+\n+ALTER TABLE table_with_function_pk DELETE WHERE key1 % 77 = 0 SETTINGS mutations_sync = 1;\n+\n+SYSTEM FLUSH LOGS;\n+\n+-- Memory usage for all mutations must be almost constant and less than\n+-- read_bytes.\n+SELECT\n+  DISTINCT read_bytes >= peak_memory_usage\n+  FROM\n+      system.part_log\n+ WHERE event_type = 'MutatePart' AND table = 'table_with_function_pk' AND database = currentDatabase();\n+\n+DROP TABLE IF EXISTS table_with_function_pk;\n+\n+DROP TABLE IF EXISTS table_without_pk;\n+\n+CREATE TABLE table_without_pk\n+(\n+  key1 UInt8,\n+  key2 UInt32,\n+  key3 DateTime64(6, 'UTC'),\n+  value String\n+)\n+ENGINE = MergeTree\n+ORDER BY tuple();\n+\n+INSERT INTO table_without_pk SELECT number % 32, number, toDateTime('2019-10-01 00:00:00'), toString(number % 10) FROM numbers(10000000);\n+\n+ALTER TABLE table_without_pk DELETE WHERE key1 % 77 = 0 SETTINGS mutations_sync = 1;\n+\n+SYSTEM FLUSH LOGS;\n+\n+-- Memory usage for all mutations must be almost constant and less than\n+-- read_bytes.\n+SELECT\n+  DISTINCT read_bytes >= peak_memory_usage\n+  FROM\n+      system.part_log\n+ WHERE event_type = 'MutatePart' AND table = 'table_without_pk' AND database = currentDatabase();\n+\n+DROP TABLE IF EXISTS table_without_pk;\n",
  "problem_statement": "Excessive memory consumption on `MATERIALIZE INDEX` query.\nTable schema:\r\n\r\n```\r\nCREATE TABLE mt5.ticks  ON CLUSTER '{cluster}' (\r\n  id_broker UInt8          CODEC(T64,LZ4) ,\r\n  id_symbol UInt32         CODEC(T64,LZ4) ,\r\n  dt_evt DateTime64(6, 'UTC')  CODEC(DoubleDelta,LZ4)   ,\r\n  vl_bid Decimal64(5)   CODEC(Gorilla,LZ4) ,\r\n  vl_ask Decimal64(5)   CODEC(Gorilla,LZ4) ,\r\n  vl_lst Decimal64(5)   CODEC(Gorilla,LZ4) ,\r\n  vl_vol Int64          CODEC(Gorilla,LZ4) ,\r\n  tp_flg UInt16         CODEC(T64,LZ4),\r\ndt_m01 DateTime('UTC') materialized        toStartOfMinute(dt_evt                    )  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m02 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 02 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m03 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 03 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m04 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 04 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m05 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 05 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m06 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 06 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m10 DateTime('UTC') materialized    toStartOfTenMinutes(dt_evt                    )  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m12 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 12 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m15 DateTime('UTC') materialized toStartOfFifteenMinutes(dt_evt                   )  CODEC(DoubleDelta,LZ4)   ,\r\ndt_m30 DateTime('UTC') materialized      toStartOfInterval(dt_evt, INTERVAL 30 minute)  CODEC(DoubleDelta,LZ4)   ,\r\ndt_h01 DateTime('UTC') materialized          toStartOfHour(dt_evt                    )  CODEC(DoubleDelta,LZ4)   ,\r\ndt_day DateTime('UTC') materialized                 toDate(dt_evt                    )  CODEC(DoubleDelta,LZ4)   ,\r\ndt_mon DateTime('UTC') materialized         toStartOfMonth(dt_evt                    )  CODEC(DoubleDelta,LZ4)   ,\r\nvl_price   Decimal64(5) materialized  if(vl_bid  <> 0, vl_bid          , if(vl_ask <> 0, vl_ask, if(vl_lst <> 0, vl_lst,  toDecimal64(0,5) ))) CODEC(Gorilla,LZ4) ,\r\nmn_price   Decimal64(5) materialized if(vl_price = 0, toDecimal64(0,5), divide((vl_bid+vl_ask+vl_lst), if(vl_price = 0, 1, if(vl_bid  = 0,0,1)+ if(vl_ask  = 0,0,1)+ if(vl_lst = 0,0,1)))) CODEC(Gorilla,LZ4) ,\r\nvl_spread  Decimal64(5) materialized if(vl_price = 0, toDecimal64(0,5), if(vl_ask > 0 and vl_bid > 0 and vl_ask >= vl_bid,  minus(vl_ask,  vl_bid),  abs(minus(vl_price, mn_price)))) CODEC(Gorilla,LZ4) ,\r\nvl_volume  Int64 materialized if(vl_price = 0, toInt64(0)      , if(bitTest(tp_flg,5) or bitTest(tp_flg,6), vl_vol, toInt64(0) )) CODEC(Gorilla,LZ4) ,\r\ntp_flg_bid   alias bitTest(tp_flg, 1),\r\ntp_flg_ask   alias bitTest(tp_flg, 2),\r\ntp_flg_lst   alias bitTest(tp_flg, 3),\r\ntp_flg_vol   alias bitTest(tp_flg, 4),\r\ntp_flg_buy   alias bitTest(tp_flg, 5),\r\ntp_flg_sel   alias bitTest(tp_flg, 6),\r\ntp_flg_quote alias if(bitTest(tp_flg, 1)+bitTest(tp_flg, 2)>0,1,0),\r\ntp_flg_trans alias if(bitTest(tp_flg, 5)+bitTest(tp_flg, 6)>0,1,0),\r\n  INDEX mmx (dt_evt, dt_m01, dt_m02, dt_m03, dt_m04, dt_m05, dt_m06, dt_m10, dt_m12, dt_m15, dt_m30,\r\n             dt_h01, dt_day, dt_mon) TYPE minmax GRANULARITY 1,\r\n  INDEX set (id_broker, id_symbol  ) TYPE set(0) GRANULARITY 1\r\n) ENGINE = ReplicatedReplacingMergeTree('/clickhouse/tables/mt5.ticks', '{replica}')\r\n  PARTITION BY (toYYYYMM(dt_evt), id_broker)\r\n      order by (id_broker, id_symbol, dt_evt) SETTINGS storage_policy = 'spool_and_rpool_gp';\r\n```\r\n\r\nQuery:\r\n```\r\nalter table mt5.ticks add INDEX id_symbol_set (id_broker, id_symbol  ) TYPE set(0) GRANULARITY 1;\r\nalter table mt5.ticks materialize INDEX id_symbol_set ;\r\n```\r\nAfter some time OOM happens.\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2020-03-25T11:03:08Z"
}