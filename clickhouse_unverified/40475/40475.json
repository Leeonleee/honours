{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40475,
  "instance_id": "ClickHouse__ClickHouse-40475",
  "issue_numbers": [
    "39598"
  ],
  "base_commit": "de1e2eed49148ee5c1b2c67c0cb06f01f22c1476",
  "patch": "diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 0d6ddfdf7c22..91a3bb474dc2 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -1017,9 +1017,7 @@ inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuff\n {\n     ExtendedDayNum tmp(0);\n     if (!tryReadDateText(tmp, rb))\n-    {\n         return false;\n-    }\n     x = tmp;\n     return true;\n }\n@@ -1102,9 +1100,27 @@ struct ConvertThroughParsing\n         if (in.eof())\n             return true;\n \n-        /// Special case, that allows to parse string with DateTime as Date.\n-        if (std::is_same_v<ToDataType, DataTypeDate> && (in.buffer().size()) == strlen(\"YYYY-MM-DD hh:mm:ss\"))\n-            return true;\n+        /// Special case, that allows to parse string with DateTime or DateTime64 as Date or Date32.\n+        if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)\n+        {\n+            if (!in.eof() && (*in.position() == ' ' || *in.position() == 'T'))\n+            {\n+                if (in.buffer().size() == strlen(\"YYYY-MM-DD hh:mm:ss\"))\n+                    return true;\n+\n+                if (in.buffer().size() >= strlen(\"YYYY-MM-DD hh:mm:ss.x\")\n+                    && in.buffer().begin()[19] == '.')\n+                {\n+                    in.position() = in.buffer().begin() + 20;\n+\n+                    while (!in.eof() && isNumericASCII(*in.position()))\n+                        ++in.position();\n+\n+                    if (in.eof())\n+                        return true;\n+                }\n+            }\n+        }\n \n         return false;\n     }\n@@ -1242,8 +1258,10 @@ struct ConvertThroughParsing\n                         vec_to[i] = value;\n                     }\n                     else if constexpr (IsDataTypeDecimal<ToDataType>)\n+                    {\n                         SerializationDecimal<typename ToDataType::FieldType>::readText(\n                             vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n+                    }\n                     else\n                     {\n                         parseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n@@ -1296,8 +1314,10 @@ struct ConvertThroughParsing\n                         vec_to[i] = value;\n                     }\n                     else if constexpr (IsDataTypeDecimal<ToDataType>)\n+                    {\n                         parsed = SerializationDecimal<typename ToDataType::FieldType>::tryReadText(\n                             vec_to[i], read_buffer, ToDataType::maxPrecision(), col_to->getScale());\n+                    }\n                     else\n                         parsed = tryParseImpl<ToDataType>(vec_to[i], read_buffer, local_time_zone);\n                 }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02388_conversion_from_string_with_datetime64_to_date_and_date32.reference b/tests/queries/0_stateless/02388_conversion_from_string_with_datetime64_to_date_and_date32.reference\nnew file mode 100644\nindex 000000000000..78cdbaf0202b\n--- /dev/null\n+++ b/tests/queries/0_stateless/02388_conversion_from_string_with_datetime64_to_date_and_date32.reference\n@@ -0,0 +1,12 @@\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\n+2022-08-22\ndiff --git a/tests/queries/0_stateless/02388_conversion_from_string_with_datetime64_to_date_and_date32.sql b/tests/queries/0_stateless/02388_conversion_from_string_with_datetime64_to_date_and_date32.sql\nnew file mode 100644\nindex 000000000000..b1f905993b45\n--- /dev/null\n+++ b/tests/queries/0_stateless/02388_conversion_from_string_with_datetime64_to_date_and_date32.sql\n@@ -0,0 +1,33 @@\n+SELECT toDate('2022-08-22 01:02:03');\n+SELECT toDate32('2022-08-22 01:02:03');\n+\n+SELECT toDate('2022-08-22 01:02:03.1');\n+SELECT toDate32('2022-08-22 01:02:03.1');\n+\n+SELECT toDate('2022-08-22 01:02:03.123456');\n+SELECT toDate32('2022-08-22 01:02:03.123456');\n+\n+SELECT toDate('2022-08-22T01:02:03');\n+SELECT toDate32('2022-08-22T01:02:03');\n+\n+SELECT toDate('2022-08-22T01:02:03.1');\n+SELECT toDate32('2022-08-22T01:02:03.1');\n+\n+SELECT toDate('2022-08-22T01:02:03.123456');\n+SELECT toDate32('2022-08-22T01:02:03.123456');\n+\n+\n+SELECT toDate('2022-08-22+01:02:03'); -- { serverError 6 }\n+SELECT toDate32('2022-08-22+01:02:03'); -- { serverError 6 }\n+\n+SELECT toDate('2022-08-22 01:02:0'); -- { serverError 6 }\n+SELECT toDate32('2022-08-22 01:02:0'); -- { serverError 6 }\n+\n+SELECT toDate('2022-08-22 01:02:03.'); -- { serverError 6 }\n+SELECT toDate32('2022-08-22 01:02:03.'); -- { serverError 6 }\n+\n+SELECT toDate('2022-08-22 01:02:03.111a'); -- { serverError 6 }\n+SELECT toDate32('2022-08-22 01:02:03.2b'); -- { serverError 6 }\n+\n+SELECT toDate('2022-08-22 01:02:03.a'); -- { serverError 6 }\n+SELECT toDate32('2022-08-22 01:02:03.b'); -- { serverError 6 }\n",
  "problem_statement": "toDate() function should ignore the time part\nHello!\r\n\r\nI've started to use `DateTime64` recently and faced the next issue with `toDate()`/`toDate32()` functions.\r\n\r\nThis query works fine:\r\n```sql\r\nSELECT toDate('2022-07-26 00:00:00')\r\n\r\nQuery id: bf64d8a8-018d-4b3e-ae24-f92600a1fa15\r\n\r\n\u250c\u2500toDate('2022-07-26 00:00:00')\u2500\u2510\r\n\u2502                    2022-07-26 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.003 sec.\r\n```\r\n\r\nBut when the string representation of the timestamp has the milliseconds fraction the function does not work:\r\n```sql\r\nSELECT toDate('2022-07-26 00:00:00.000')\r\n\r\nQuery id: 8b42473a-0ceb-4892-b0e7-6f73f583d4b4\r\n\r\n\r\n0 rows in set. Elapsed: 0.006 sec.\r\n\r\nReceived exception from server (version 22.3.8):\r\nCode: 6. DB::Exception: Received from s:9000. DB::Exception: Cannot parse string '2022-07-26 00:00:00.000' as Date: syntax error at position 10 (parsed just '2022-07-26'): While processing toDate('2022-07-26 00:00:00.000'). (CANNOT_PARSE_TEXT)\r\n```\r\n\r\nThe `toDate32()` doesn't work in both cases.\r\n\r\nYes, you can say I must change the input or use a workaround like this:\r\n```sql\r\nSELECT toDate(toDateTime64('2022-07-26 00:00:00.000', 3, 'UTC')) AS date\r\n```\r\n\r\nBut it's not convenient and it'd be great if the mentioned functions will ignore the time part.\r\n\r\nP.s. ClickHouse server version: `22.3.8.39`\r\n\n",
  "hints_text": "",
  "created_at": "2022-08-21T22:28:36Z"
}