{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 32742,
  "instance_id": "ClickHouse__ClickHouse-32742",
  "issue_numbers": [
    "17733"
  ],
  "base_commit": "bda0cc2f762a89f570d1b05e3847a4c051acffa2",
  "patch": "diff --git a/src/Storages/IStorage.h b/src/Storages/IStorage.h\nindex 8432e5c48d16..bcbc771815b6 100644\n--- a/src/Storages/IStorage.h\n+++ b/src/Storages/IStorage.h\n@@ -511,7 +511,7 @@ class IStorage : public std::enable_shared_from_this<IStorage>, public TypePromo\n     virtual void shutdown() {}\n \n     /// Called before shutdown() to flush data to underlying storage\n-    /// (for Buffer)\n+    /// Data in memory need to be persistent\n     virtual void flush() {}\n \n     /// Asks table to stop executing some action identified by action_type\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex e58472e572bf..9e6002862143 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -1525,6 +1525,24 @@ void MergeTreeData::removePartsFinally(const MergeTreeData::DataPartsVector & pa\n     }\n }\n \n+void MergeTreeData::flushAllInMemoryPartsIfNeeded()\n+{\n+    if (getSettings()->in_memory_parts_enable_wal)\n+        return;\n+\n+    auto metadata_snapshot = getInMemoryMetadataPtr();\n+    DataPartsVector parts = getDataPartsVector();\n+    for (const auto & part : parts)\n+    {\n+        if (auto part_in_memory = asInMemoryPart(part))\n+        {\n+            const auto & storage_relative_path = part_in_memory->storage.relative_data_path;\n+            part_in_memory->flushToDisk(storage_relative_path, part_in_memory->relative_path, metadata_snapshot);\n+        }\n+    }\n+\n+}\n+\n size_t MergeTreeData::clearOldPartsFromFilesystem(bool force)\n {\n     DataPartsVector parts_to_remove = grabOldParts(force);\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 8830aaad7a11..5a3dda785a0e 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -548,6 +548,9 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// Removes parts from data_parts, they should be in Deleting state\n     void removePartsFinally(const DataPartsVector & parts);\n \n+    /// When WAL is not enabled, the InMemoryParts need to be persistent.\n+    void flushAllInMemoryPartsIfNeeded();\n+\n     /// Delete irrelevant parts from memory and disk.\n     /// If 'force' - don't wait for old_parts_lifetime.\n     size_t clearOldPartsFromFilesystem(bool force = false);\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 470a406dbe4d..f83ab0c3f9e3 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -139,6 +139,10 @@ void StorageMergeTree::startup()\n     }\n }\n \n+void StorageMergeTree::flush()\n+{\n+    flushAllInMemoryPartsIfNeeded();\n+}\n \n void StorageMergeTree::shutdown()\n {\ndiff --git a/src/Storages/StorageMergeTree.h b/src/Storages/StorageMergeTree.h\nindex 7aeca1f1a0ca..ee99b412f59a 100644\n--- a/src/Storages/StorageMergeTree.h\n+++ b/src/Storages/StorageMergeTree.h\n@@ -31,6 +31,7 @@ class StorageMergeTree final : public shared_ptr_helper<StorageMergeTree>, publi\n     friend struct shared_ptr_helper<StorageMergeTree>;\n public:\n     void startup() override;\n+    void flush() override;\n     void shutdown() override;\n     ~StorageMergeTree() override;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02148_in_memory_part_flush.reference b/tests/queries/0_stateless/02148_in_memory_part_flush.reference\nnew file mode 100644\nindex 000000000000..219c5f4b22f6\n--- /dev/null\n+++ b/tests/queries/0_stateless/02148_in_memory_part_flush.reference\n@@ -0,0 +1,4 @@\n+before DETACH TABLE\n+500\n+after DETACH TABLE\n+500\ndiff --git a/tests/queries/0_stateless/02148_in_memory_part_flush.sql b/tests/queries/0_stateless/02148_in_memory_part_flush.sql\nnew file mode 100644\nindex 000000000000..ec20721186e2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02148_in_memory_part_flush.sql\n@@ -0,0 +1,26 @@\n+DROP TABLE IF EXISTS mem_part_flush;\n+\n+CREATE TABLE mem_part_flush\n+(\n+`key` UInt32,\n+`ts` DateTime,\n+`db_time` DateTime DEFAULT now()\n+)\n+ENGINE = MergeTree\n+ORDER BY (key, ts)\n+SETTINGS min_rows_for_compact_part = 1000000, min_bytes_for_compact_part = 200000000, in_memory_parts_enable_wal = 0;\n+\n+INSERT INTO mem_part_flush(key, ts) SELECT number % 1000, now() + intDiv(number,1000) FROM numbers(500);\n+\n+SELECT 'before DETACH TABLE';\n+SELECT count(*) FROM mem_part_flush;\n+\n+DETACH TABLE mem_part_flush;\n+\n+ATTACH TABLE mem_part_flush;\n+\n+SELECT 'after DETACH TABLE';\n+SELECT count(*) FROM mem_part_flush;\n+\n+\n+DROP TABLE mem_part_flush;\n",
  "problem_statement": "In-memory parts with disabled wal-log disappear while server restart or DETACH table.\n**How to reproduce**\r\nClickhouse server 20.13.1.5273\r\n```\r\nCREATE TABLE default.test\r\n(\r\n`key` UInt32,\r\n`ts` DateTime CODEC(DoubleDelta, LZ4),\r\n`db_time` DateTime DEFAULT now() COMMENT 'spout-ignore' CODEC(DoubleDelta, LZ4)\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toStartOfTenMinutes(db_time)\r\nORDER BY (key, ts)\r\nTTL db_time + toIntervalHour(3)\r\nSETTINGS index_granularity = 8192, merge_with_ttl_timeout = 3600, min_rows_for_compact_part = 1000000, min_bytes_for_compact_part = 200000000, in_memory_parts_enable_wal = 0;\r\n\r\n\r\nINSERT INTO test(key, ts) SELECT number % 1000, now() + intDiv(number,1000) FROM numbers(500);\r\n\r\nSELECT * FROM test;\r\n500 rows in set. Elapsed: 0.003 sec.\r\n\r\nDETACH TABLE test;\r\n\r\nATTACH TABLE test;\r\n\r\nSELECT * FROM test;\r\n\r\n0 rows in set. Elapsed: 0.002 sec.\r\n```\r\n\r\n**Expected behavior**\r\nClickhouse would flush parts on disk.\n",
  "hints_text": "",
  "created_at": "2021-12-14T08:34:18Z"
}