diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index 5730503a6705..7d2a52c65568 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -4284,6 +4284,32 @@ Possible values:
 
 Default value: `false`.
 
+## rename_files_after_processing
+
+- **Type:** String
+
+- **Default value:** Empty string
+
+This setting allows to specify renaming pattern for files processed by `file` table function. When option is set, all files read by `file` table function will be renamed according to specified pattern with placeholders, only if files processing was successful.
+
+### Placeholders
+
+- `%f` — Original filename without extension (e.g., "sample").
+- `%e` — Original file extension with dot (e.g., ".csv").
+- `%t` — Timestamp (in microseconds).
+- `%%` — Percentage sign ("%").
+
+### Example
+- Option: `--rename_files_after_processing="processed_%f_%t%e"`
+
+- Query: `SELECT * FROM file('sample.csv')`
+
+
+If reading `sample.csv` is successful, file will be renamed to `processed_sample_1683473210851438.csv`
+
+
+
+
 ## function_json_value_return_type_allow_complex
 
 Control whether allow to return complex type (such as: struct, array, map) for json_value function.
diff --git a/docs/en/sql-reference/table-functions/file.md b/docs/en/sql-reference/table-functions/file.md
index 28c2dc9f1f32..577e2e6aa1d2 100644
--- a/docs/en/sql-reference/table-functions/file.md
+++ b/docs/en/sql-reference/table-functions/file.md
@@ -40,7 +40,7 @@ VALUES (1, 2, 3), (3, 2, 1), (1, 3, 2)
 As a result, the data is written into the file `test.tsv`:
 
 ```bash
-# cat /var/lib/clickhouse/user_files/test.tsv 
+# cat /var/lib/clickhouse/user_files/test.tsv
 1	2	3
 3	2	1
 1	3	2
@@ -163,7 +163,7 @@ Query the number of rows in all files of these two directories:
 SELECT count(*) FROM file('{some,another}_dir/*', 'TSV', 'name String, value UInt32');
 ```
 
-:::note    
+:::note
 If your listing of files contains number ranges with leading zeros, use the construction with braces for each digit separately or use `?`.
 :::
 
@@ -199,3 +199,4 @@ SELECT count(*) FROM file('big_dir/**/file002', 'CSV', 'name String, value UInt3
 **See Also**
 
 - [Virtual columns](/docs/en/engines/table-engines/index.md#table_engines-virtual_columns)
+- [Rename files after processing](/docs/en/operations/settings/settings.md#rename_files_after_processing)
diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md
index f5c8f06e3ca6..e3da8302fc8a 100644
--- a/docs/ru/operations/settings/settings.md
+++ b/docs/ru/operations/settings/settings.md
@@ -4126,3 +4126,26 @@ SELECT sum(number) FROM numbers(10000000000) SETTINGS partial_result_on_first_ca
 Возможные значения:: `true`, `false`
 
 Значение по умолчанию: `false`
+
+## rename_files_after_processing
+
+- **Тип:** Строка
+
+- **Значение по умолчанию:** Пустая строка
+
+Этот параметр позволяет задать паттерн для переименования файлов, обрабатываемых табличной функцией `file`. Когда опция установлена, все файлы, прочитанные табличной функцией `file`, будут переименованы в соответствии с указанным шаблоном, если обработка и чтение файла завершились успешно.
+
+### Шаблон
+Шаблон поддерживает следующие виды плейсхолдеров:
+
+- `%f` — Исходное имя файла без расширения (например "sample").
+- `%e` — Оригинальное расширение файла с точкой (например ".csv").
+- `%t` — Текущее время (в микросекундах).
+- `%%` — Знак процента ("%").
+
+### Пример
+- Значение аргумента: `--rename_files_after_processing="processed_%f_%t%e"`
+
+- Запрос: `SELECT * FROM file('sample.csv')`
+
+Если чтение и обработка `sample.csv` прошли успешно, файл будет переименован в `processed_sample_1683473210851438.csv`.
diff --git a/docs/ru/sql-reference/table-functions/file.md b/docs/ru/sql-reference/table-functions/file.md
index 94bc734a8fb2..0983c51d954c 100644
--- a/docs/ru/sql-reference/table-functions/file.md
+++ b/docs/ru/sql-reference/table-functions/file.md
@@ -126,3 +126,4 @@ SELECT count(*) FROM file('big_dir/file{0..9}{0..9}{0..9}', 'CSV', 'name String,
 **Смотрите также**
 
 -   [Виртуальные столбцы](index.md#table_engines-virtual_columns)
+-   [Переименование файлов после обработки](/docs/ru/operations/settings/settings.md#rename_files_after_processing)
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index b7e4e2b733bb..6f295c110702 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -1364,6 +1364,7 @@ void ClientBase::sendData(Block & sample, const ColumnsDescription & columns_des
             columns_description_for_query,
             ConstraintsDescription{},
             String{},
+            {},
         };
         StoragePtr storage = std::make_shared<StorageFile>(in_file, global_context->getUserFilesPath(), args);
         storage->startup();
diff --git a/src/Common/FileRenamer.cpp b/src/Common/FileRenamer.cpp
new file mode 100644
index 000000000000..3473d543c00f
--- /dev/null
+++ b/src/Common/FileRenamer.cpp
@@ -0,0 +1,96 @@
+#include <Common/FileRenamer.h>
+
+#include <Common/DateLUT.h>
+#include <Common/Exception.h>
+
+#include <chrono>
+#include <filesystem>
+#include <format>
+#include <map>
+#include <re2/re2.h>
+
+#include <boost/algorithm/string.hpp>
+#include <boost/algorithm/string/replace.hpp>
+
+namespace fs = std::filesystem;
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+}
+
+FileRenamer::FileRenamer() = default;
+
+FileRenamer::FileRenamer(const String & renaming_rule)
+    : rule(renaming_rule)
+{
+    FileRenamer::validateRenamingRule(rule, true);
+}
+
+String FileRenamer::generateNewFilename(const String & filename) const
+{
+    // Split filename and extension
+    String file_base = fs::path(filename).stem();
+    String file_ext = fs::path(filename).extension();
+
+    // Get current timestamp in microseconds
+    String timestamp;
+    if (rule.find("%t") != String::npos)
+    {
+        auto now = std::chrono::system_clock::now();
+        timestamp = std::to_string(timeInMicroseconds(now));
+    }
+
+    // Define placeholders and their corresponding values
+    std::map<String, String> placeholders =
+    {
+        {"%f", file_base},
+        {"%e", file_ext},
+        {"%t", timestamp},
+        {"%%", "%"}
+    };
+
+    // Replace placeholders with their actual values
+    String new_name = rule;
+    for (const auto & [placeholder, value] : placeholders)
+        boost::replace_all(new_name, placeholder, value);
+
+    return new_name;
+}
+
+bool FileRenamer::isEmpty() const
+{
+    return rule.empty();
+}
+
+bool FileRenamer::validateRenamingRule(const String & rule, bool throw_on_error)
+{
+    // Check if the rule contains invalid placeholders
+    re2::RE2 invalid_placeholder_pattern("^([^%]|%[fet%])*$");
+    if (!re2::RE2::FullMatch(rule, invalid_placeholder_pattern))
+    {
+        if (throw_on_error)
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Invalid renaming rule: Allowed placeholders only %f, %e, %t, and %%");
+        return false;
+    }
+
+    // Replace valid placeholders with empty strings and count remaining percentage signs.
+    String replaced_rule = rule;
+    boost::replace_all(replaced_rule, "%f", "");
+    boost::replace_all(replaced_rule, "%e", "");
+    boost::replace_all(replaced_rule, "%t", "");
+    if (std::count(replaced_rule.begin(), replaced_rule.end(), '%') % 2)
+    {
+        if (throw_on_error)
+            throw Exception(ErrorCodes::BAD_ARGUMENTS, "Invalid renaming rule: Odd number of consecutive percentage signs");
+        return false;
+    }
+
+    return true;
+}
+
+
+} // DB
diff --git a/src/Common/FileRenamer.h b/src/Common/FileRenamer.h
new file mode 100644
index 000000000000..c062978d6f66
--- /dev/null
+++ b/src/Common/FileRenamer.h
@@ -0,0 +1,39 @@
+#pragma once
+
+#include <string>
+#include <base/types.h>
+
+namespace DB
+{
+
+/**
+  * The FileRenamer class provides functionality for renaming files based on given pattern with placeholders
+  * The supported placeholders are:
+  *   %f - Original filename without extension ("sample")
+  *   %e - Original file extension with dot (".csv")
+  *   %t - Timestamp (in microseconds)
+  *   %% - Percentage sign ("%")
+  *
+  * Example:
+  *   Pattern             - "processed_%f_%t%e"
+  *   Original filename   - "sample.csv"
+  *   New filename        - "processed_sample_1683405960646224.csv"
+  */
+class FileRenamer
+{
+public:
+    FileRenamer();
+
+    FileRenamer(const String & renaming_rule);
+
+    String generateNewFilename(const String & filename) const;
+
+    bool isEmpty() const;
+
+    static bool validateRenamingRule(const String & rule, bool throw_on_error = false);
+
+private:
+    String rule;
+};
+
+} // DB
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 6a0833aef60c..93985b1a6def 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -717,6 +717,8 @@ class IColumn;
     M(String, workload, "default", "Name of workload to be used to access resources", 0) \
     M(Milliseconds, storage_system_stack_trace_pipe_read_timeout_ms, 100, "Maximum time to read from a pipe for receiving information from the threads when querying the `system.stack_trace` table. This setting is used for testing purposes and not meant to be changed by users.", 0) \
     \
+    M(String, rename_files_after_processing, "", "Rename successfully processed files according to the specified pattern; Pattern can include the following placeholders: `%f` (original filename without extension), `%e` (file extension with dot), `%t` (current timestamp in µs), and `%%` (% sign)", 0) \
+    \
     M(Bool, parallelize_output_from_storages, true, "Parallelize output for reading step from storage. It allows parallelizing query processing right after reading from storage if possible", 0) \
     M(String, insert_deduplication_token, "", "If not empty, used for duplicate detection instead of data digest", 0) \
     M(String, ann_index_select_query_params, "", "Parameters passed to ANN indexes in SELECT queries, the format is 'param1=x, param2=y, ...'", 0) \
diff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp
index 052775aefcac..dfaf3bb7cd83 100644
--- a/src/Storages/StorageFile.cpp
+++ b/src/Storages/StorageFile.cpp
@@ -40,6 +40,7 @@
 #include <Common/typeid_cast.h>
 #include <Common/parseGlobs.h>
 #include <Common/filesystemHelpers.h>
+#include <Common/logger_useful.h>
 #include <Common/ProfileEvents.h>
 
 #include <QueryPipeline/Pipe.h>
@@ -78,6 +79,7 @@ namespace ErrorCodes
     extern const int UNKNOWN_IDENTIFIER;
     extern const int INCORRECT_FILE_NAME;
     extern const int FILE_DOESNT_EXIST;
+    extern const int FILE_ALREADY_EXISTS;
     extern const int TIMEOUT_EXCEEDED;
     extern const int INCOMPATIBLE_COLUMNS;
     extern const int CANNOT_STAT;
@@ -462,6 +464,8 @@ StorageFile::StorageFile(const std::string & table_path_, const std::string & us
     else
         path_for_partitioned_write = table_path_;
 
+    file_renamer = FileRenamer(args.rename_after_processing);
+
     setStorageMetadata(args);
 }
 
@@ -595,9 +599,69 @@ class StorageFileSource : public ISource
             shared_lock = std::shared_lock(storage->rwlock, getLockTimeout(context));
             if (!shared_lock)
                 throw Exception(ErrorCodes::TIMEOUT_EXCEEDED, "Lock timeout exceeded");
+            storage->readers_counter.fetch_add(1, std::memory_order_release);
         }
     }
 
+
+    /**
+      * If specified option --rename_files_after_processing and files created by TableFunctionFile
+      * Last reader will rename files according to specified pattern if desctuctor of reader was called without uncaught exceptions
+      */
+    void beforeDestroy()
+    {
+        if (storage->file_renamer.isEmpty())
+            return;
+
+        int32_t cnt = storage->readers_counter.fetch_sub(1, std::memory_order_acq_rel);
+
+        if (std::uncaught_exceptions() == 0 && cnt == 1 && !storage->was_renamed)
+        {
+            shared_lock.unlock();
+            auto exclusive_lock = std::unique_lock{storage->rwlock, getLockTimeout(context)};
+
+            if (!exclusive_lock)
+                return;
+            if (storage->readers_counter.load(std::memory_order_acquire) != 0 || storage->was_renamed)
+                return;
+
+            for (auto & file_path_ref : storage->paths)
+            {
+                try
+                {
+                    auto file_path = fs::path(file_path_ref);
+                    String new_filename = storage->file_renamer.generateNewFilename(file_path.filename().string());
+                    file_path.replace_filename(new_filename);
+
+                    // Normalize new path
+                    file_path = file_path.lexically_normal();
+
+                    // Checking access rights
+                    checkCreationIsAllowed(context, context->getUserFilesPath(), file_path, true);
+
+                    // Checking an existing of new file
+                    if (fs::exists(file_path))
+                        throw Exception(ErrorCodes::FILE_ALREADY_EXISTS, "File {} already exists", file_path.string());
+
+                    fs::rename(fs::path(file_path_ref), file_path);
+                    file_path_ref = file_path.string();
+                    storage->was_renamed = true;
+                }
+                catch (const std::exception & e)
+                {
+                    // Cannot throw exception from destructor, will write only error
+                    LOG_ERROR(&Poco::Logger::get("~StorageFileSource"), "Failed to rename file {}: {}", file_path_ref, e.what());
+                    continue;
+                }
+            }
+        }
+    }
+
+    ~StorageFileSource() override
+    {
+        beforeDestroy();
+    }
+
     String getName() const override
     {
         return storage->getName();
@@ -1223,6 +1287,7 @@ void registerStorageFile(StorageFactory & factory)
                 factory_args.columns,
                 factory_args.constraints,
                 factory_args.comment,
+                {},
             };
 
             ASTs & engine_args_ast = factory_args.engine_args;
diff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h
index 53ce7eeaaf6c..0513864fd0ff 100644
--- a/src/Storages/StorageFile.h
+++ b/src/Storages/StorageFile.h
@@ -2,12 +2,11 @@
 
 #include <Storages/IStorage.h>
 #include <Storages/Cache/SchemaCache.h>
-
+#include <Common/FileRenamer.h>
 
 #include <atomic>
 #include <shared_mutex>
 
-
 namespace DB
 {
 
@@ -23,6 +22,8 @@ class StorageFile final : public IStorage
         const ColumnsDescription & columns;
         const ConstraintsDescription & constraints;
         const String & comment;
+
+        const std::string rename_after_processing;
     };
 
     /// From file descriptor
@@ -139,6 +140,11 @@ class StorageFile final : public IStorage
     std::unique_ptr<ReadBuffer> read_buffer_from_fd;
     std::unique_ptr<ReadBuffer> peekable_read_buffer_from_fd;
     std::atomic<bool> has_peekable_read_buffer_from_fd = false;
+
+    // Counts the number of readers
+    std::atomic<int32_t> readers_counter = 0;
+    FileRenamer file_renamer;
+    bool was_renamed = false;
 };
 
 }
diff --git a/src/TableFunctions/TableFunctionFile.cpp b/src/TableFunctions/TableFunctionFile.cpp
index ff64bb3dc677..0e49f26db40a 100644
--- a/src/TableFunctions/TableFunctionFile.cpp
+++ b/src/TableFunctions/TableFunctionFile.cpp
@@ -75,6 +75,7 @@ StoragePtr TableFunctionFile::getStorage(const String & source,
         columns,
         ConstraintsDescription{},
         String{},
+        global_context->getSettingsRef().rename_files_after_processing,
     };
     if (fd >= 0)
         return std::make_shared<StorageFile>(fd, args);
