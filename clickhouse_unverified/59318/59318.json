{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 59318,
  "instance_id": "ClickHouse__ClickHouse-59318",
  "issue_numbers": [
    "54537"
  ],
  "base_commit": "35f8aae919d235f0f15e46efd1cbb72b06af34ff",
  "patch": "diff --git a/docs/en/sql-reference/data-types/map.md b/docs/en/sql-reference/data-types/map.md\nindex 2c734969afcb..9d495126d282 100644\n--- a/docs/en/sql-reference/data-types/map.md\n+++ b/docs/en/sql-reference/data-types/map.md\n@@ -10,7 +10,7 @@ sidebar_label: Map(K, V)\n \n **Parameters**\n \n-- `key` \u2014 The key part of the pair. [String](../../sql-reference/data-types/string.md), [Integer](../../sql-reference/data-types/int-uint.md), [LowCardinality](../../sql-reference/data-types/lowcardinality.md), [FixedString](../../sql-reference/data-types/fixedstring.md), [UUID](../../sql-reference/data-types/uuid.md), [Date](../../sql-reference/data-types/date.md), [DateTime](../../sql-reference/data-types/datetime.md), [Date32](../../sql-reference/data-types/date32.md), [Enum](../../sql-reference/data-types/enum.md).\n+- `key` \u2014 The key part of the pair. Arbitrary type, except [Nullable](../../sql-reference/data-types/nullable.md) and [LowCardinality](../../sql-reference/data-types/lowcardinality.md) nested with [Nullable](../../sql-reference/data-types/nullable.md) types.\n - `value` \u2014 The value part of the pair. Arbitrary type, including [Map](../../sql-reference/data-types/map.md) and [Array](../../sql-reference/data-types/array.md).\n \n To get the value from an `a Map('key', 'value')` column, use `a['key']` syntax. This lookup works now with a linear complexity.\ndiff --git a/docs/en/sql-reference/functions/tuple-map-functions.md b/docs/en/sql-reference/functions/tuple-map-functions.md\nindex 8283de959948..377283bc0062 100644\n--- a/docs/en/sql-reference/functions/tuple-map-functions.md\n+++ b/docs/en/sql-reference/functions/tuple-map-functions.md\n@@ -16,7 +16,7 @@ map(key1, value1[, key2, value2, ...])\n \n **Arguments**\n \n-- `key` \u2014 The key part of the pair. [String](../../sql-reference/data-types/string.md), [Integer](../../sql-reference/data-types/int-uint.md), [LowCardinality](../../sql-reference/data-types/lowcardinality.md), [FixedString](../../sql-reference/data-types/fixedstring.md), [UUID](../../sql-reference/data-types/uuid.md), [Date](../../sql-reference/data-types/date.md), [DateTime](../../sql-reference/data-types/datetime.md), [Date32](../../sql-reference/data-types/date32.md), [Enum](../../sql-reference/data-types/enum.md).\n+- `key` \u2014 The key part of the pair. Arbitrary type, except [Nullable](../../sql-reference/data-types/nullable.md) and [LowCardinality](../../sql-reference/data-types/lowcardinality.md) nested with [Nullable](../../sql-reference/data-types/nullable.md).\n - `value` \u2014 The value part of the pair. Arbitrary type, including [Map](../../sql-reference/data-types/map.md) and [Array](../../sql-reference/data-types/array.md).\n \n **Returned value**\ndiff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp\nindex 4b85606ff263..d9f70e1659de 100644\n--- a/src/DataTypes/DataTypeMap.cpp\n+++ b/src/DataTypes/DataTypeMap.cpp\n@@ -118,22 +118,7 @@ bool DataTypeMap::equals(const IDataType & rhs) const\n \n bool DataTypeMap::checkKeyType(DataTypePtr key_type)\n {\n-    if (key_type->getTypeId() == TypeIndex::LowCardinality)\n-    {\n-        const auto & low_cardinality_data_type = assert_cast<const DataTypeLowCardinality &>(*key_type);\n-        if (!isStringOrFixedString(*(low_cardinality_data_type.getDictionaryType())))\n-            return false;\n-    }\n-    else if (!key_type->isValueRepresentedByInteger()\n-             && !isStringOrFixedString(*key_type)\n-             && !WhichDataType(key_type).isNothing()\n-             && !WhichDataType(key_type).isIPv6()\n-             && !WhichDataType(key_type).isUUID())\n-    {\n-        return false;\n-    }\n-\n-    return true;\n+    return !isNullableOrLowCardinalityNullable(key_type);\n }\n \n DataTypePtr DataTypeMap::getNestedTypeWithUnnamedTuple() const\ndiff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp\nindex d92bfcf0bc65..76c1ec18171c 100644\n--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp\n+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp\n@@ -182,11 +182,37 @@ struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, retur\n \n /// Adapter that extracts array with keys or values from Map columns.\n template <typename Name, size_t position>\n-struct MapToSubcolumnAdapter : public MapAdapterBase<MapToSubcolumnAdapter<Name, position>, Name>\n+struct MapToSubcolumnAdapter\n {\n     static_assert(position <= 1);\n-    using MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypes;\n-    using MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypesAndColumns;\n+\n+    static void extractNestedTypes(DataTypes & types)\n+    {\n+        if (types.empty())\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}, should be at least 1\",\n+                Name::name,\n+                types.size());\n+\n+        DataTypes new_types = {types[0]};\n+        MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypes(new_types);\n+        types[0] = new_types[0];\n+    }\n+\n+    static void extractNestedTypesAndColumns(ColumnsWithTypeAndName & arguments)\n+    {\n+        if (arguments.empty())\n+            throw Exception(\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Number of arguments for function {} doesn't match: passed {}, should be at least 1\",\n+                Name::name,\n+                arguments.size());\n+\n+        ColumnsWithTypeAndName new_arguments = {arguments[0]};\n+        MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypesAndColumns(new_arguments);\n+        arguments[0] = new_arguments[0];\n+    }\n \n     static DataTypePtr extractNestedType(const DataTypeMap & type_map)\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01651_map_functions.reference b/tests/queries/0_stateless/01651_map_functions.reference\nindex 60f1b6e0d0c4..0dafb841e0c1 100644\n--- a/tests/queries/0_stateless/01651_map_functions.reference\n+++ b/tests/queries/0_stateless/01651_map_functions.reference\n@@ -24,6 +24,16 @@\n {'1002':'2004','1002':'3006','1002':'4008'}\n {'aa':4,'bb':5}\t['aa','bb']\t[4,5]\n {'aa':4,'bb':5}\t1\t0\n+{0.1:4,0.2:5}\t[0.1,0.2]\t[4,5]\n+{0.1:4,0.2:5}\t1\t0\n+{0.1:4,0.2:5}\t[0.1,0.2]\t[4,5]\n+{0.1:4,0.2:5}\t1\t0\n+{[1,2]:4,[3,4]:5}\t[[1,2],[3,4]]\t[4,5]\n+{[1,2]:4,[3,4]:5}\t1\t0\n+{{1:2}:4,{3:4}:5}\t[{1:2},{3:4}]\t[4,5]\n+{{1:2}:4,{3:4}:5}\t1\t0\n+{(1,2):4,(3,4):5}\t[(1,2),(3,4)]\t[4,5]\n+{(1,2):4,(3,4):5}\t1\t0\n {0:0}\t1\n {0:0}\t0\n {'aa':4,'bb':5}\ndiff --git a/tests/queries/0_stateless/01651_map_functions.sql b/tests/queries/0_stateless/01651_map_functions.sql\nindex 5942bf8b2c22..5a54d22ac974 100644\n--- a/tests/queries/0_stateless/01651_map_functions.sql\n+++ b/tests/queries/0_stateless/01651_map_functions.sql\n@@ -28,6 +28,17 @@ drop table if exists table_map;\n select map( 'aa', 4, 'bb' , 5) as m, mapKeys(m), mapValues(m);\n select map( 'aa', 4, 'bb' , 5) as m, mapContains(m, 'aa'), mapContains(m, 'k');\n \n+select map(0.1::Float32, 4, 0.2::Float32, 5) as m, mapKeys(m), mapValues(m);\n+select map(0.1::Float32, 4, 0.2::Float32, 5) as m, mapContains(m, 0.1::Float32), mapContains(m, 0.3::Float32);\n+select map(0.1::Float64, 4, 0.2::Float64, 5) as m, mapKeys(m), mapValues(m);\n+select map(0.1::Float64, 4, 0.2::Float64, 5) as m, mapContains(m, 0.1::Float64), mapContains(m, 0.3::Float64);\n+select map(array(1,2), 4, array(3,4), 5) as m, mapKeys(m), mapValues(m);\n+select map(array(1,2), 4, array(3,4), 5) as m, mapContains(m, array(1,2)), mapContains(m, array(1,3));\n+select map(map(1,2), 4, map(3,4), 5) as m, mapKeys(m), mapValues(m);\n+select map(map(1,2), 4, map(3,4), 5) as m, mapContains(m, map(1,2)), mapContains(m, map(1,3));\n+select map(tuple(1,2), 4, tuple(3,4), 5) as m, mapKeys(m), mapValues(m);\n+select map(tuple(1,2), 4, tuple(3,4), 5) as m, mapContains(m, tuple(1,2)), mapContains(m, tuple(1,3));\n+\n select map(0, 0) as m, mapContains(m, number % 2) from numbers(2);\n \n select mapFromArrays(['aa', 'bb'], [4, 5]);\n@@ -38,7 +49,7 @@ select mapFromArrays('aa', [4, 5]); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n select mapFromArrays(['aa', 'bb'], 5); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n select mapFromArrays(['aa', 'bb'], [4, 5], [6, 7]); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n select mapFromArrays(['aa', 'bb'], [4, 5, 6]); -- { serverError SIZES_OF_ARRAYS_DONT_MATCH }\n-select mapFromArrays([[1,2], [3,4]], [4, 5, 6]); -- { serverError BAD_ARGUMENTS }\n+select mapFromArrays([[1,2], [3,4]], [4, 5, 6]); -- { serverError SIZES_OF_ARRAYS_DONT_MATCH }\n \n select mapFromArrays(['aa', 'bb'], map('a', 4, 'b', 5));\n select mapFromArrays(['aa', 'bb'], materialize(map('a', 4, 'b', 5))) from numbers(2);\ndiff --git a/tests/queries/0_stateless/01720_type_map_and_casts.sql b/tests/queries/0_stateless/01720_type_map_and_casts.sql\nindex f03773d90849..d090d0e5b664 100644\n--- a/tests/queries/0_stateless/01720_type_map_and_casts.sql\n+++ b/tests/queries/0_stateless/01720_type_map_and_casts.sql\n@@ -79,6 +79,10 @@ SELECT m[toUInt64(0)], m[toInt64(0)], m[toUInt8(0)], m[toUInt16(0)] FROM table_m\n DROP TABLE IF EXISTS table_map_with_key_integer;\n \n \n-CREATE TABLE table_map_with_key_integer (m Map(Float32, String)) ENGINE = MergeTree() ORDER BY tuple(); -- { serverError 36}\n+CREATE TABLE table_map_with_key_integer (m Map(Float32, String)) ENGINE = MergeTree() ORDER BY tuple();\n+DROP TABLE IF EXISTS table_map_with_key_integer;\n+\n+CREATE TABLE table_map_with_key_integer (m Map(Array(UInt32), String)) ENGINE = MergeTree() ORDER BY tuple();\n+DROP TABLE IF EXISTS table_map_with_key_integer;\n+\n CREATE TABLE table_map_with_key_integer (m Map(Nullable(String), String)) ENGINE = MergeTree() ORDER BY tuple(); -- { serverError 36}\n-CREATE TABLE table_map_with_key_integer (m Map(Array(UInt32), String)) ENGINE = MergeTree() ORDER BY tuple(); -- { serverError 36}\ndiff --git a/tests/queries/0_stateless/02169_map_functions.reference b/tests/queries/0_stateless/02169_map_functions.reference\nindex 10746a70f06c..6100de6abaf2 100644\n--- a/tests/queries/0_stateless/02169_map_functions.reference\n+++ b/tests/queries/0_stateless/02169_map_functions.reference\n@@ -26,6 +26,21 @@\n {}\n {}\n {}\n+{0.1:4}\n+{0.1:4}\n+{[1,2]:4}\n+{{1:2}:4}\n+{(1,2):4}\n+1\n+1\n+1\n+1\n+1\n+{0.1:4,0.2:5}\n+{0.1:4,0.2:5}\n+{[1,2]:4,[3,4]:5}\n+{{1:2}:4,{3:4}:5}\n+{(1,2):4,(3,4):5}\n {'key3':100,'key2':101,'key4':102,'key5':500,'key6':600}\n {'key3':101,'key2':102,'key4':103,'key5':500,'key6':600}\n {'key3':102,'key2':103,'key4':104,'key5':500,'key6':600}\n@@ -42,6 +57,11 @@\n {'key1':1113,'key2':2226,'key5':500,'key6':600}\n {'key5':500,'key6':600}\n {'key5':500,'key6':600}\n+{0.1:4,0.2:5}\n+{0.1:4,0.2:5}\n+{[1,2]:4,[3,4]:5}\n+{{1:2}:4,{3:4}:5}\n+{(1,2):4,(3,4):5}\n 1\n 1\n 1\n@@ -104,3 +124,4 @@\n {1:1,3:3,5:5,0:0,2:4,4:16,6:36}\n {1:1,3:3,5:5,7:7,0:0,2:4,4:16,6:36}\n {1:1,3:3,5:5,7:7,0:0,2:4,4:16,6:36,8:64}\n+{(1,0):(1,0),(2,0):(2,0)}\ndiff --git a/tests/queries/0_stateless/02169_map_functions.sql b/tests/queries/0_stateless/02169_map_functions.sql\nindex febaf2bd9d08..854ce214924e 100644\n--- a/tests/queries/0_stateless/02169_map_functions.sql\n+++ b/tests/queries/0_stateless/02169_map_functions.sql\n@@ -9,11 +9,35 @@ SELECT mapApply((k, v) -> (k, v + 1), col) FROM table_map ORDER BY id;\n SELECT mapFilter((k, v) -> 0, col) from table_map;\n SELECT mapApply((k, v) -> tuple(v + 9223372036854775806), col) FROM table_map; -- { serverError BAD_ARGUMENTS }\n \n+SELECT mapFilter((k, v) -> k = 0.1::Float32, map(0.1::Float32, 4, 0.2::Float32, 5));\n+SELECT mapFilter((k, v) -> k = 0.1::Float64, map(0.1::Float64, 4, 0.2::Float64, 5));\n+SELECT mapFilter((k, v) -> k = array(1,2), map(array(1,2), 4, array(3,4), 5));\n+SELECT mapFilter((k, v) -> k = map(1,2), map(map(1,2), 4, map(3,4), 5));\n+SELECT mapFilter((k, v) -> k = tuple(1,2), map(tuple(1,2), 4, tuple(3,4), 5));\n+\n+SELECT mapExists((k, v) -> k = 0.1::Float32, map(0.1::Float32, 4, 0.2::Float32, 5));\n+SELECT mapExists((k, v) -> k = 0.1::Float64, map(0.1::Float64, 4, 0.2::Float64, 5));\n+SELECT mapExists((k, v) -> k = array(1,2), map(array(1,2), 4, array(3,4), 5));\n+SELECT mapExists((k, v) -> k = map(1,2), map(map(1,2), 4, map(3,4), 5));\n+SELECT mapExists((k, v) -> k = tuple(1,2), map(tuple(1,2), 4, tuple(3,4), 5));\n+\n+SELECT mapSort((k, v) -> k, map(0.1::Float32, 4, 0.2::Float32, 5));\n+SELECT mapSort((k, v) -> k, map(0.1::Float64, 4, 0.2::Float64, 5));\n+SELECT mapSort((k, v) -> k, map(array(1,2), 4, array(3,4), 5));\n+SELECT mapSort((k, v) -> k, map(map(1,2), 4, map(3,4), 5));\n+SELECT mapSort((k, v) -> k, map(tuple(1,2), 4, tuple(3,4), 5));\n+\n SELECT mapConcat(col, map('key5', 500), map('key6', 600)) FROM table_map ORDER BY id;\n SELECT mapConcat(col, materialize(map('key5', 500)), map('key6', 600)) FROM table_map ORDER BY id;\n SELECT concat(map('key5', 500), map('key6', 600));\n SELECT map('key5', 500) || map('key6', 600);\n \n+SELECT mapConcat(map(0.1::Float32, 4), map(0.2::Float32, 5));\n+SELECT mapConcat(map(0.1::Float64, 4), map(0.2::Float64, 5));\n+SELECT mapConcat(map(array(1,2), 4), map(array(3,4), 5));\n+SELECT mapConcat(map(map(1,2), 4), map(map(3,4), 5));\n+SELECT mapConcat(map(tuple(1,2), 4), map(tuple(3,4), 5));\n+\n SELECT mapExists((k, v) -> k LIKE '%3', col) FROM table_map ORDER BY id;\n SELECT mapExists((k, v) -> k LIKE '%2' AND v < 1000, col) FROM table_map ORDER BY id;\n \n@@ -49,7 +73,7 @@ SELECT DISTINCT mapUpdate(m1, m2) FROM numbers (100000);\n SELECT mapApply(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n SELECT mapApply((x, y) -> (x), map(1, 0, 2, 0)); -- { serverError BAD_ARGUMENTS }\n SELECT mapApply((x, y) -> ('x'), map(1, 0, 2, 0)); -- { serverError BAD_ARGUMENTS }\n-SELECT mapApply((x) -> (x, x), map(1, 0, 2, 0)); -- { serverError BAD_ARGUMENTS }\n+SELECT mapApply((x) -> (x, x), map(1, 0, 2, 0));\n SELECT mapApply((x, y) -> (x, 1, 2), map(1, 0, 2, 0)); -- { serverError BAD_ARGUMENTS }\n SELECT mapApply((x, y) -> (x, x + 1)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT mapApply(map(1, 0, 2, 0), (x, y) -> (x, x + 1)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n",
  "problem_statement": "Support complex types as map key\nCurrently OLAP systems like Spark and Presto supports complex types(array/map/tuple) as map key, but CH do not. \r\n\r\nI'm glad to contribute to it if you guys agree with this proposal. \r\n\n",
  "hints_text": "Sounds strange, but if it is easy to do - let's try.",
  "created_at": "2024-01-29T03:28:03Z"
}