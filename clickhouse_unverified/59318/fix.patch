diff --git a/docs/en/sql-reference/data-types/map.md b/docs/en/sql-reference/data-types/map.md
index 2c734969afcb..9d495126d282 100644
--- a/docs/en/sql-reference/data-types/map.md
+++ b/docs/en/sql-reference/data-types/map.md
@@ -10,7 +10,7 @@ sidebar_label: Map(K, V)
 
 **Parameters**
 
-- `key` — The key part of the pair. [String](../../sql-reference/data-types/string.md), [Integer](../../sql-reference/data-types/int-uint.md), [LowCardinality](../../sql-reference/data-types/lowcardinality.md), [FixedString](../../sql-reference/data-types/fixedstring.md), [UUID](../../sql-reference/data-types/uuid.md), [Date](../../sql-reference/data-types/date.md), [DateTime](../../sql-reference/data-types/datetime.md), [Date32](../../sql-reference/data-types/date32.md), [Enum](../../sql-reference/data-types/enum.md).
+- `key` — The key part of the pair. Arbitrary type, except [Nullable](../../sql-reference/data-types/nullable.md) and [LowCardinality](../../sql-reference/data-types/lowcardinality.md) nested with [Nullable](../../sql-reference/data-types/nullable.md) types.
 - `value` — The value part of the pair. Arbitrary type, including [Map](../../sql-reference/data-types/map.md) and [Array](../../sql-reference/data-types/array.md).
 
 To get the value from an `a Map('key', 'value')` column, use `a['key']` syntax. This lookup works now with a linear complexity.
diff --git a/docs/en/sql-reference/functions/tuple-map-functions.md b/docs/en/sql-reference/functions/tuple-map-functions.md
index 8283de959948..377283bc0062 100644
--- a/docs/en/sql-reference/functions/tuple-map-functions.md
+++ b/docs/en/sql-reference/functions/tuple-map-functions.md
@@ -16,7 +16,7 @@ map(key1, value1[, key2, value2, ...])
 
 **Arguments**
 
-- `key` — The key part of the pair. [String](../../sql-reference/data-types/string.md), [Integer](../../sql-reference/data-types/int-uint.md), [LowCardinality](../../sql-reference/data-types/lowcardinality.md), [FixedString](../../sql-reference/data-types/fixedstring.md), [UUID](../../sql-reference/data-types/uuid.md), [Date](../../sql-reference/data-types/date.md), [DateTime](../../sql-reference/data-types/datetime.md), [Date32](../../sql-reference/data-types/date32.md), [Enum](../../sql-reference/data-types/enum.md).
+- `key` — The key part of the pair. Arbitrary type, except [Nullable](../../sql-reference/data-types/nullable.md) and [LowCardinality](../../sql-reference/data-types/lowcardinality.md) nested with [Nullable](../../sql-reference/data-types/nullable.md).
 - `value` — The value part of the pair. Arbitrary type, including [Map](../../sql-reference/data-types/map.md) and [Array](../../sql-reference/data-types/array.md).
 
 **Returned value**
diff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp
index 4b85606ff263..d9f70e1659de 100644
--- a/src/DataTypes/DataTypeMap.cpp
+++ b/src/DataTypes/DataTypeMap.cpp
@@ -118,22 +118,7 @@ bool DataTypeMap::equals(const IDataType & rhs) const
 
 bool DataTypeMap::checkKeyType(DataTypePtr key_type)
 {
-    if (key_type->getTypeId() == TypeIndex::LowCardinality)
-    {
-        const auto & low_cardinality_data_type = assert_cast<const DataTypeLowCardinality &>(*key_type);
-        if (!isStringOrFixedString(*(low_cardinality_data_type.getDictionaryType())))
-            return false;
-    }
-    else if (!key_type->isValueRepresentedByInteger()
-             && !isStringOrFixedString(*key_type)
-             && !WhichDataType(key_type).isNothing()
-             && !WhichDataType(key_type).isIPv6()
-             && !WhichDataType(key_type).isUUID())
-    {
-        return false;
-    }
-
-    return true;
+    return !isNullableOrLowCardinalityNullable(key_type);
 }
 
 DataTypePtr DataTypeMap::getNestedTypeWithUnnamedTuple() const
diff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp
index d92bfcf0bc65..76c1ec18171c 100644
--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp
+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp
@@ -182,11 +182,37 @@ struct MapToNestedAdapter : public MapAdapterBase<MapToNestedAdapter<Name, retur
 
 /// Adapter that extracts array with keys or values from Map columns.
 template <typename Name, size_t position>
-struct MapToSubcolumnAdapter : public MapAdapterBase<MapToSubcolumnAdapter<Name, position>, Name>
+struct MapToSubcolumnAdapter
 {
     static_assert(position <= 1);
-    using MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypes;
-    using MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypesAndColumns;
+
+    static void extractNestedTypes(DataTypes & types)
+    {
+        if (types.empty())
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Number of arguments for function {} doesn't match: passed {}, should be at least 1",
+                Name::name,
+                types.size());
+
+        DataTypes new_types = {types[0]};
+        MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypes(new_types);
+        types[0] = new_types[0];
+    }
+
+    static void extractNestedTypesAndColumns(ColumnsWithTypeAndName & arguments)
+    {
+        if (arguments.empty())
+            throw Exception(
+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                "Number of arguments for function {} doesn't match: passed {}, should be at least 1",
+                Name::name,
+                arguments.size());
+
+        ColumnsWithTypeAndName new_arguments = {arguments[0]};
+        MapAdapterBase<MapToSubcolumnAdapter, Name>::extractNestedTypesAndColumns(new_arguments);
+        arguments[0] = new_arguments[0];
+    }
 
     static DataTypePtr extractNestedType(const DataTypeMap & type_map)
     {
