{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64991,
  "instance_id": "ClickHouse__ClickHouse-64991",
  "issue_numbers": [
    "38832"
  ],
  "base_commit": "c24e905bc6c169aa1d06366cdd4901f803e7be3a",
  "patch": "diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md\nindex c2d19f584221..c535b82d710a 100644\n--- a/docs/en/sql-reference/functions/string-functions.md\n+++ b/docs/en/sql-reference/functions/string-functions.md\n@@ -1136,16 +1136,136 @@ SELECT tryBase58Decode('3dc8KtHrwM') as res, tryBase58Decode('invalid') as res_i\n \n ## base64Encode\n \n-Encodes a String or FixedString as base64.\n+Encodes a String or FixedString as base64, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-4).\n \n Alias: `TO_BASE64`.\n \n+**Syntax**\n+\n+```sql\n+base64Encode(plaintext)\n+```\n+\n+**Arguments**\n+\n+- `plaintext` \u2014 [String](../data-types/string.md) column or constant.\n+\n+**Returned value**\n+\n+- A string containing the encoded value of the argument.\n+\n+**Example**\n+\n+``` sql\n+SELECT base64Encode('clickhouse');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500base64Encode('clickhouse')\u2500\u2510\n+\u2502 Y2xpY2tob3VzZQ==           \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## base64UrlEncode\n+\n+Encodes an URL (String or FixedString) as base64 with URL-specific modifications, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-5).\n+\n+**Syntax**\n+\n+```sql\n+base64UrlEncode(url)\n+```\n+\n+**Arguments**\n+\n+- `url` \u2014 [String](../data-types/string.md) column or constant.\n+\n+**Returned value**\n+\n+- A string containing the encoded value of the argument.\n+\n+**Example**\n+\n+``` sql\n+SELECT base64UrlEncode('https://clickhouse.com');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500base64UrlEncode('https://clickhouse.com')\u2500\u2510\n+\u2502 aHR0cDovL2NsaWNraG91c2UuY29t              \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## base64Decode\n \n-Decodes a base64-encoded String or FixedString. Throws an exception in case of error.\n+Accepts a String and decodes it from base64, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-4). Throws an exception in case of an error.\n \n Alias: `FROM_BASE64`.\n \n+**Syntax**\n+\n+```sql\n+base64Decode(encoded)\n+```\n+\n+**Arguments**\n+\n+- `encoded` \u2014 [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value, an exception is thrown.\n+\n+**Returned value**\n+\n+- A string containing the decoded value of the argument.\n+\n+**Example**\n+\n+``` sql\n+SELECT base64Decode('Y2xpY2tob3VzZQ==');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500base64Decode('Y2xpY2tob3VzZQ==')\u2500\u2510\n+\u2502 clickhouse                       \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## base64UrlDecode\n+\n+Accepts a base64-encoded URL and decodes it from base64 with URL-specific modifications, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-5). Throws an exception in case of an error.\n+\n+**Syntax**\n+\n+```sql\n+base64UrlDecode(encodedUrl)\n+```\n+\n+**Arguments**\n+\n+- `encodedUrl` \u2014 [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, an exception is thrown.\n+\n+**Returned value**\n+\n+- A string containing the decoded value of the argument.\n+\n+**Example**\n+\n+``` sql\n+SELECT base64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t');\n+```\n+\n+Result:\n+\n+```result\n+\u250c\u2500base64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t')\u2500\u2510\n+\u2502 https://clickhouse.com                          \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## tryBase64Decode\n \n Like `base64Decode` but returns an empty string in case of error.\n@@ -1156,9 +1276,13 @@ Like `base64Decode` but returns an empty string in case of error.\n tryBase64Decode(encoded)\n ```\n \n-**Parameters**\n+**Arguments**\n \n-- `encoded`: [String](../data-types/string.md) column or constant. If the string is not a valid Base58-encoded value, returns an empty string in case of error.\n+- `encoded`: [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value, returns an empty string.\n+\n+**Returned value**\n+\n+- A string containing the decoded value of the argument.\n \n **Examples**\n \n@@ -1169,9 +1293,41 @@ SELECT tryBase64Decode('RW5jb2RlZA==') as res, tryBase64Decode('invalid') as res\n ```\n \n ```response\n-\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u252c\u2500res_invalid\u2500\u2510\n-\u2502 Encoded \u2502             \u2502\n-\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500res_invalid\u2500\u2510\n+\u2502 clickhouse \u2502             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## tryBase64UrlDecode\n+\n+Like `base64UrlDecode` but returns an empty string in case of error.\n+\n+**Syntax**\n+\n+```sql\n+tryBase64UrlDecode(encodedUrl)\n+```\n+\n+**Parameters**\n+\n+- `encodedUrl`: [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, returns an empty string.\n+\n+**Returned value**\n+\n+- A string containing the decoded value of the argument.\n+\n+**Examples**\n+\n+Query:\n+\n+```sql\n+SELECT tryBase64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t') as res, tryBase64Decode('aHR0cHM6Ly9jbGlja') as res_invalid;\n+```\n+\n+```response\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500res_invalid\u2500\u2510\n+\u2502 https://clickhouse.com \u2502             \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n ## endsWith {#endswith}\ndiff --git a/docs/ru/sql-reference/functions/string-functions.md b/docs/ru/sql-reference/functions/string-functions.md\nindex fc258f7b4cfc..fa76e84f1301 100644\n--- a/docs/ru/sql-reference/functions/string-functions.md\n+++ b/docs/ru/sql-reference/functions/string-functions.md\n@@ -538,16 +538,28 @@ SELECT base58Decode('3dc8KtHrwM');\n \n \u0421\u0438\u043d\u043e\u043d\u0438\u043c: `TO_BASE64`.\n \n+## base64UrlEncode(s)\n+\n+\u041f\u0440\u043e\u0438\u0437\u0432\u043e\u0434\u0438\u0442 \u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0435 URL (String \u0438\u043b\u0438 FixedString) \u0432 base64-\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 [RFC 4648](https://tools.ietf.org/html/rfc4648).\n+\n ## base64Decode(s) {#base64decode}\n \n \u0414\u0435\u043a\u043e\u0434\u0438\u0440\u0443\u0435\u0442 base64-\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 s \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443. \u041f\u0440\u0438 \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u044b\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\n \n \u0421\u0438\u043d\u043e\u043d\u0438\u043c: `FROM_BASE64`.\n \n+## base64UrlDecode(s)\n+\n+\u0414\u0435\u043a\u043e\u0434\u0438\u0440\u0443\u0435\u0442 base64-\u043f\u0440\u0435\u0434\u0441\u0442\u0430\u0432\u043b\u0435\u043d\u0438\u0435 URL \u0432 \u0438\u0441\u0445\u043e\u0434\u043d\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443 \u0432 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0438\u0438 \u0441 [RFC 4648](https://tools.ietf.org/html/rfc4648). \u041f\u0440\u0438 \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u044b\u0431\u0440\u0430\u0441\u044b\u0432\u0430\u0435\u0442 \u0438\u0441\u043a\u043b\u044e\u0447\u0435\u043d\u0438\u0435\n+\n ## tryBase64Decode(s) {#trybase64decode}\n \n \u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u0435\u043d base64Decode, \u043d\u043e \u043f\u0440\u0438 \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443.\n \n+## tryBase64UrlDecode(s)\n+\n+\u0424\u0443\u043d\u043a\u0446\u0438\u043e\u043d\u0430\u043b \u0430\u043d\u0430\u043b\u043e\u0433\u0438\u0447\u0435\u043d base64UrlDecode, \u043d\u043e \u043f\u0440\u0438 \u043d\u0435\u0432\u043e\u0437\u043c\u043e\u0436\u043d\u043e\u0441\u0442\u0438 \u0434\u0435\u043a\u043e\u0434\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u044f \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u043f\u0443\u0441\u0442\u0443\u044e \u0441\u0442\u0440\u043e\u043a\u0443.\n+\n ## endsWith(s, suffix) {#endswith}\n \n \u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 1, \u0435\u0441\u043b\u0438 \u0441\u0442\u0440\u043e\u043a\u0430 \u0437\u0430\u0432\u0435\u0440\u0448\u0430\u0435\u0442\u0441\u044f \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u043c \u0441\u0443\u0444\u0444\u0438\u043a\u0441\u043e\u043c, \u0438 0 \u0432 \u043f\u0440\u043e\u0442\u0438\u0432\u043d\u043e\u043c \u0441\u043b\u0443\u0447\u0430\u0435.\ndiff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h\nindex 3906563a2549..05914be38378 100644\n--- a/src/Functions/FunctionBase64Conversion.h\n+++ b/src/Functions/FunctionBase64Conversion.h\n@@ -12,7 +12,7 @@\n #    include <Common/MemorySanitizer.h>\n \n #    include <cstddef>\n-#    include <span>\n+#    include <string_view>\n \n namespace DB\n {\n@@ -22,36 +22,125 @@ namespace ErrorCodes\n     extern const int INCORRECT_DATA;\n }\n \n+enum class Base64Variant : uint8_t\n+{\n+    Normal,\n+    Url\n+};\n+\n+inline std::string preprocessBase64Url(std::string_view src)\n+{\n+    std::string padded_src;\n+    padded_src.reserve(src.size() + 3);\n+\n+    // Do symbol substitution as described in https://datatracker.ietf.org/doc/html/rfc4648#section-5\n+    for (auto s : src)\n+    {\n+        switch (s)\n+        {\n+        case '_':\n+            padded_src += '/';\n+            break;\n+        case '-':\n+            padded_src += '+';\n+            break;\n+        default:\n+            padded_src += s;\n+            break;\n+        }\n+    }\n+\n+    /// Insert padding to please aklomp library\n+    size_t remainder = src.size() % 4;\n+    switch (remainder)\n+    {\n+        case 0:\n+            break; // no padding needed\n+        case 1:\n+            padded_src.append(\"===\"); // this case is impossible to occur with valid base64-URL encoded input, however, we'll insert padding anyway\n+            break;\n+        case 2:\n+            padded_src.append(\"==\"); // two bytes padding\n+            break;\n+        default: // remainder == 3\n+            padded_src.append(\"=\"); // one byte padding\n+            break;\n+    }\n+\n+    return padded_src;\n+}\n+\n+inline size_t postprocessBase64Url(UInt8 * dst, size_t out_len)\n+{\n+    // Do symbol substitution as described in https://datatracker.ietf.org/doc/html/rfc4648#section-5\n+    for (size_t i = 0; i < out_len; ++i)\n+    {\n+        switch (dst[i])\n+        {\n+        case '/':\n+            dst[i] = '_';\n+            break;\n+        case '+':\n+            dst[i] = '-';\n+            break;\n+        case '=': // stop when padding is detected\n+            return i;\n+        default:\n+            break;\n+        }\n+    }\n+    return out_len;\n+}\n+\n+template <Base64Variant variant>\n struct Base64Encode\n {\n-    static constexpr auto name = \"base64Encode\";\n+    static constexpr auto name = (variant == Base64Variant::Normal) ? \"base64Encode\" : \"base64UrlEncode\";\n \n     static size_t getBufferSize(size_t string_length, size_t string_count)\n     {\n         return ((string_length - string_count) / 3 + string_count) * 4 + string_count;\n     }\n \n-    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)\n+    static size_t perform(std::string_view src, UInt8 * dst)\n     {\n         size_t outlen = 0;\n-        base64_encode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        base64_encode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+\n+        /// Base64 library is using AVX-512 with some shuffle operations.\n+        /// Memory sanitizer doesn't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.\n+        __msan_unpoison(dst, outlen);\n+\n+        if constexpr (variant == Base64Variant::Url)\n+            outlen = postprocessBase64Url(dst, outlen);\n+\n         return outlen;\n     }\n };\n \n+template <Base64Variant variant>\n struct Base64Decode\n {\n-    static constexpr auto name = \"base64Decode\";\n+    static constexpr auto name = (variant == Base64Variant::Normal) ? \"base64Decode\" : \"base64UrlDecode\";\n \n     static size_t getBufferSize(size_t string_length, size_t string_count)\n     {\n         return ((string_length - string_count) / 4 + string_count) * 3 + string_count;\n     }\n \n-    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)\n+    static size_t perform(std::string_view src, UInt8 * dst)\n     {\n+        int rc;\n         size_t outlen = 0;\n-        int rc = base64_decode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        if constexpr (variant == Base64Variant::Url)\n+        {\n+            std::string src_padded = preprocessBase64Url(src);\n+            rc = base64_decode(src_padded.data(), src_padded.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        }\n+        else\n+        {\n+            rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        }\n \n         if (rc != 1)\n             throw Exception(\n@@ -64,19 +153,29 @@ struct Base64Decode\n     }\n };\n \n+template <Base64Variant variant>\n struct TryBase64Decode\n {\n-    static constexpr auto name = \"tryBase64Decode\";\n+    static constexpr auto name = (variant == Base64Variant::Normal) ? \"tryBase64Decode\" : \"tryBase64UrlDecode\";\n \n     static size_t getBufferSize(size_t string_length, size_t string_count)\n     {\n-        return Base64Decode::getBufferSize(string_length, string_count);\n+        return Base64Decode<variant>::getBufferSize(string_length, string_count);\n     }\n \n-    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)\n+    static size_t perform(std::string_view src, UInt8 * dst)\n     {\n+        int rc;\n         size_t outlen = 0;\n-        int rc = base64_decode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        if constexpr (variant == Base64Variant::Url)\n+        {\n+            std::string src_padded = preprocessBase64Url(src);\n+            rc = base64_decode(src_padded.data(), src_padded.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        }\n+        else\n+        {\n+            rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);\n+        }\n \n         if (rc != 1)\n             outlen = 0;\n@@ -139,7 +238,7 @@ class FunctionBase64Conversion : public IFunction\n \n         auto * dst = dst_chars.data();\n         auto * dst_pos = dst;\n-        const auto * src = src_chars.data();\n+        const auto * src = reinterpret_cast<const char *>(src_chars.data());\n \n         size_t src_offset_prev = 0;\n         for (size_t row = 0; row < src_row_count; ++row)\n@@ -147,10 +246,6 @@ class FunctionBase64Conversion : public IFunction\n             const size_t src_length = src_offsets[row] - src_offset_prev - 1;\n             const size_t outlen = Func::perform({src, src_length}, dst_pos);\n \n-            /// Base64 library is using AVX-512 with some shuffle operations.\n-            /// Memory sanitizer don't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.\n-            __msan_unpoison(dst_pos, outlen);\n-\n             src += src_length + 1;\n             dst_pos += outlen;\n             *dst_pos = '\\0';\n@@ -179,16 +274,12 @@ class FunctionBase64Conversion : public IFunction\n \n         auto * dst = dst_chars.data();\n         auto * dst_pos = dst;\n-        const auto * src = src_chars.data();\n+        const auto * src = reinterpret_cast<const char *>(src_chars.data());\n \n         for (size_t row = 0; row < src_row_count; ++row)\n         {\n             const auto outlen = Func::perform({src, src_n}, dst_pos);\n \n-            /// Base64 library is using AVX-512 with some shuffle operations.\n-            /// Memory sanitizer don't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.\n-            __msan_unpoison(dst_pos, outlen);\n-\n             src += src_n;\n             dst_pos += outlen;\n             *dst_pos = '\\0';\ndiff --git a/src/Functions/base64Decode.cpp b/src/Functions/base64Decode.cpp\nindex 5f7a3406c620..50278c4b0b23 100644\n--- a/src/Functions/base64Decode.cpp\n+++ b/src/Functions/base64Decode.cpp\n@@ -7,7 +7,14 @@ namespace DB\n {\n REGISTER_FUNCTION(Base64Decode)\n {\n-    factory.registerFunction<FunctionBase64Conversion<Base64Decode>>();\n+    FunctionDocumentation::Description description = R\"(Accepts a String and decodes it from base64, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-4). Throws an exception in case of an error. Alias: FROM_BASE64.)\";\n+    FunctionDocumentation::Syntax syntax = \"base64Decode(encoded)\";\n+    FunctionDocumentation::Arguments arguments = {{\"encoded\", \"String column or constant. If the string is not a valid Base64-encoded value, an exception is thrown.\"}};\n+    FunctionDocumentation::ReturnedValue returned_value = \"A string containing the decoded value of the argument.\";\n+    FunctionDocumentation::Examples examples = {{\"Example\", \"SELECT base64Decode('Y2xpY2tob3VzZQ==')\", \"clickhouse\"}};\n+    FunctionDocumentation::Categories categories = {\"String encoding\"};\n+\n+    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, categories});\n \n     /// MySQL compatibility alias.\n     factory.registerAlias(\"FROM_BASE64\", \"base64Decode\", FunctionFactory::CaseInsensitive);\ndiff --git a/src/Functions/base64Encode.cpp b/src/Functions/base64Encode.cpp\nindex 69268f5a25d6..d6e63c38a4ca 100644\n--- a/src/Functions/base64Encode.cpp\n+++ b/src/Functions/base64Encode.cpp\n@@ -7,7 +7,14 @@ namespace DB\n {\n REGISTER_FUNCTION(Base64Encode)\n {\n-    factory.registerFunction<FunctionBase64Conversion<Base64Encode>>();\n+    FunctionDocumentation::Description description = R\"(Encodes a String as base64, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-4). Alias: TO_BASE64.)\";\n+    FunctionDocumentation::Syntax syntax = \"base64Encode(plaintext)\";\n+    FunctionDocumentation::Arguments arguments = {{\"plaintext\", \"String column or constant.\"}};\n+    FunctionDocumentation::ReturnedValue returned_value = \"A string containing the encoded value of the argument.\";\n+    FunctionDocumentation::Examples examples = {{\"Example\", \"SELECT base64Encode('clickhouse')\", \"Y2xpY2tob3VzZQ==\"}};\n+    FunctionDocumentation::Categories categories = {\"String encoding\"};\n+\n+    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, categories});\n \n     /// MySQL compatibility alias.\n     factory.registerAlias(\"TO_BASE64\", \"base64Encode\", FunctionFactory::CaseInsensitive);\ndiff --git a/src/Functions/base64UrlDecode.cpp b/src/Functions/base64UrlDecode.cpp\nnew file mode 100644\nindex 000000000000..59975d8f9d1d\n--- /dev/null\n+++ b/src/Functions/base64UrlDecode.cpp\n@@ -0,0 +1,21 @@\n+#include <Functions/FunctionBase64Conversion.h>\n+\n+#if USE_BASE64\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+REGISTER_FUNCTION(Base64UrlDecode)\n+{\n+    FunctionDocumentation::Description description = R\"(Accepts a base64-encoded URL and decodes it from base64 with URL-specific modifications, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-5).)\";\n+    FunctionDocumentation::Syntax syntax = \"base64UrlDecode(encodedUrl)\";\n+    FunctionDocumentation::Arguments arguments = {{\"encodedUrl\", \"String column or constant. If the string is not a valid Base64-encoded value, an exception is thrown.\"}};\n+    FunctionDocumentation::ReturnedValue returned_value = \"A string containing the decoded value of the argument.\";\n+    FunctionDocumentation::Examples examples = {{\"Example\", \"SELECT base64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t')\", \"https://clickhouse.com\"}};\n+    FunctionDocumentation::Categories categories = {\"String encoding\"};\n+\n+    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::Url>>>({description, syntax, arguments, returned_value, examples, categories});\n+}\n+}\n+\n+#endif\ndiff --git a/src/Functions/base64UrlEncode.cpp b/src/Functions/base64UrlEncode.cpp\nnew file mode 100644\nindex 000000000000..05d50170c148\n--- /dev/null\n+++ b/src/Functions/base64UrlEncode.cpp\n@@ -0,0 +1,21 @@\n+#include <Functions/FunctionBase64Conversion.h>\n+\n+#if USE_BASE64\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+REGISTER_FUNCTION(Base64UrlEncode)\n+{\n+    FunctionDocumentation::Description description = R\"(Encodes an URL (String or FixedString) as base64 with URL-specific modifications, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-5).)\";\n+    FunctionDocumentation::Syntax syntax = \"base64UrlEncode(url)\";\n+    FunctionDocumentation::Arguments arguments = {{\"url\", \"String column or constant.\"}};\n+    FunctionDocumentation::ReturnedValue returned_value = \"A string containing the encoded value of the argument.\";\n+    FunctionDocumentation::Examples examples = {{\"Example\", \"SELECT base64UrlEncode('https://clickhouse.com')\", \"aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ\"}};\n+    FunctionDocumentation::Categories categories = {\"String encoding\"};\n+\n+    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::Url>>>({description, syntax, arguments, returned_value, examples, categories});\n+}\n+}\n+\n+#endif\ndiff --git a/src/Functions/tryBase64Decode.cpp b/src/Functions/tryBase64Decode.cpp\nindex bd452b8357b8..08eabe93200d 100644\n--- a/src/Functions/tryBase64Decode.cpp\n+++ b/src/Functions/tryBase64Decode.cpp\n@@ -7,7 +7,14 @@ namespace DB\n {\n REGISTER_FUNCTION(TryBase64Decode)\n {\n-    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode>>();\n+    FunctionDocumentation::Description description = R\"(Decodes a String or FixedString from base64, like base64Decode but returns an empty string in case of an error.)\";\n+    FunctionDocumentation::Syntax syntax = \"tryBase64Decode(encoded)\";\n+    FunctionDocumentation::Arguments arguments = {{\"encoded\", \"String column or constant. If the string is not a valid Base64-encoded value, returns an empty string.\"}};\n+    FunctionDocumentation::ReturnedValue returned_value = \"A string containing the decoded value of the argument.\";\n+    FunctionDocumentation::Examples examples = {{\"valid\", \"SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')\", \"clickhouse\"}, {\"invalid\", \"SELECT tryBase64Decode('invalid')\", \"\"}};\n+    FunctionDocumentation::Categories categories = {\"String encoding\"};\n+\n+    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, categories});\n }\n }\n \ndiff --git a/src/Functions/tryBase64UrlDecode.cpp b/src/Functions/tryBase64UrlDecode.cpp\nnew file mode 100644\nindex 000000000000..b9aaf4f92735\n--- /dev/null\n+++ b/src/Functions/tryBase64UrlDecode.cpp\n@@ -0,0 +1,21 @@\n+#include <Functions/FunctionBase64Conversion.h>\n+\n+#if USE_BASE64\n+#include <Functions/FunctionFactory.h>\n+\n+namespace DB\n+{\n+REGISTER_FUNCTION(TryBase64UrlDecode)\n+{\n+    FunctionDocumentation::Description description = R\"(Decodes an URL from base64, like base64UrlDecode but returns an empty string in case of an error.)\";\n+    FunctionDocumentation::Syntax syntax = \"tryBase64UrlDecode(encodedUrl)\";\n+    FunctionDocumentation::Arguments arguments = {{\"encodedUrl\", \"String column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, returns an empty string.\"}};\n+    FunctionDocumentation::ReturnedValue returned_value = \"A string containing the decoded value of the argument.\";\n+    FunctionDocumentation::Examples examples = {{\"valid\", \"SELECT tryBase64UrlDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')\", \"https://clickhouse.com\"}, {\"invalid\", \"SELECT tryBase64UrlDecode('aHR0cHM6Ly9jbGlja')\", \"\"}};\n+    FunctionDocumentation::Categories categories = {\"String encoding\"};\n+\n+    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::Url>>>({description, syntax, arguments, returned_value, examples, categories});\n+}\n+}\n+\n+#endif\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 846826899349..64ff3e8e2cb8 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1011,6 +1011,8 @@ Updatable\n Uppercased\n Uptime\n Uptrace\n+UrlDecode\n+UrlEncode\n UserID\n Util\n VARCHAR\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00732_base64_functions.sql b/tests/queries/0_stateless/00732_base64_functions.sql\nindex 3c60bf939fe3..b4be8db4edea 100644\n--- a/tests/queries/0_stateless/00732_base64_functions.sql\n+++ b/tests/queries/0_stateless/00732_base64_functions.sql\n@@ -1,6 +1,5 @@\n -- Tags: no-fasttest\n-\n-SET send_logs_level = 'fatal';\n+-- no-fasttest because aklomp-base64 library is required\n \n SELECT base64Encode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n SELECT base64Decode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\ndiff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\nindex cabcd230eb65..e9deb7780758 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.sql\n@@ -3,7 +3,6 @@\n SELECT name FROM system.functions WHERE NOT is_aggregate AND origin = 'System' AND alias_to = '' AND length(description) < 10\n AND name NOT IN (\n     'aes_decrypt_mysql', 'aes_encrypt_mysql', 'decrypt', 'encrypt',\n-    'base64Decode', 'base64Encode', 'tryBase64Decode',\n     'convertCharset',\n     'detectLanguage', 'detectLanguageMixed',\n     'geoToH3',\ndiff --git a/tests/queries/0_stateless/03167_base64_url_functions.reference b/tests/queries/0_stateless/03167_base64_url_functions.reference\nnew file mode 100644\nindex 000000000000..2a0d0013609e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03167_base64_url_functions.reference\n@@ -0,0 +1,10 @@\n+https://clickhouse.com\taHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ\thttps://clickhouse.com\thttps://clickhouse.com\n+12?\tMTI_\t12?\t12?\n+https://www.google.com/search?q=clickhouse+base64+decode&sca_esv=739f8bb380e4c7ed&ei=TfRiZqCDIrmnwPAP2KLRkA8&ved=0ahUKEwjg3ZHitsmGAxW5ExAIHVhRFPIQ4dUDCBA&uact=5&oq=clickhouse+base64+decode\taHR0cHM6Ly93d3cuZ29vZ2xlLmNvbS9zZWFyY2g_cT1jbGlja2hvdXNlK2Jhc2U2NCtkZWNvZGUmc2NhX2Vzdj03MzlmOGJiMzgwZTRjN2VkJmVpPVRmUmlacUNESXJtbndQQVAyS0xSa0E4JnZlZD0wYWhVS0V3amczWkhpdHNtR0F4VzVFeEFJSFZoUkZQSVE0ZFVEQ0JBJnVhY3Q9NSZvcT1jbGlja2hvdXNlK2Jhc2U2NCtkZWNvZGU\thttps://www.google.com/search?q=clickhouse+base64+decode&sca_esv=739f8bb380e4c7ed&ei=TfRiZqCDIrmnwPAP2KLRkA8&ved=0ahUKEwjg3ZHitsmGAxW5ExAIHVhRFPIQ4dUDCBA&uact=5&oq=clickhouse+base64+decode\thttps://www.google.com/search?q=clickhouse+base64+decode&sca_esv=739f8bb380e4c7ed&ei=TfRiZqCDIrmnwPAP2KLRkA8&ved=0ahUKEwjg3ZHitsmGAxW5ExAIHVhRFPIQ4dUDCBA&uact=5&oq=clickhouse+base64+decode\n+aHR0cHM6Ly9jbGlj\thttps://clic\thttps://clic\n+aHR0cHM6Ly9jbGlja2g\thttps://clickh\thttps://clickh\n+aHR0cHM6Ly9jbGljaw\thttps://click\thttps://click\n+\n+\n+\n+https://clickhouse.com\taHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ\thttps://clickhouse.com\thttps://clickhouse.com\ndiff --git a/tests/queries/0_stateless/03167_base64_url_functions.sql b/tests/queries/0_stateless/03167_base64_url_functions.sql\nnew file mode 100644\nindex 000000000000..674f1ae498bd\n--- /dev/null\n+++ b/tests/queries/0_stateless/03167_base64_url_functions.sql\n@@ -0,0 +1,36 @@\n+-- Tags: no-fasttest\n+-- no-fasttest because aklomp-base64 library is required\n+\n+-- incorrect number of arguments\n+SELECT base64UrlEncode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT base64UrlDecode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT tryBase64UrlDecode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT base64UrlEncode('foo', 'excess argument'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT base64UrlDecode('foo', 'excess argument'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT tryBase64UrlDecode('foo', 'excess argument'); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+\n+-- test with valid inputs\n+\n+SELECT 'https://clickhouse.com' AS original, base64UrlEncode(original) AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n+SELECT '12?' AS original, base64UrlEncode(original) AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n+SELECT 'https://www.google.com/search?q=clickhouse+base64+decode&sca_esv=739f8bb380e4c7ed&ei=TfRiZqCDIrmnwPAP2KLRkA8&ved=0ahUKEwjg3ZHitsmGAxW5ExAIHVhRFPIQ4dUDCBA&uact=5&oq=clickhouse+base64+decode' AS original, base64UrlEncode(original) AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n+\n+-- encoded value has no padding\n+SELECT 'aHR0cHM6Ly9jbGlj' AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n+-- encoded value has one-byte padding\n+SELECT 'aHR0cHM6Ly9jbGlja2g' AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n+-- encoded value has two-bytes padding\n+SELECT 'aHR0cHM6Ly9jbGljaw' AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n+\n+-- test with invalid inputs\n+\n+SELECT base64UrlDecode('https://clickhouse.com'); -- { serverError INCORRECT_DATA }\n+SELECT tryBase64UrlDecode('https://clickhouse.com');\n+SELECT base64UrlDecode('12?'); -- { serverError INCORRECT_DATA }\n+SELECT tryBase64UrlDecode('12?');\n+SELECT base64UrlDecode('aHR0cHM6Ly9jbGlja'); -- { serverError INCORRECT_DATA }\n+SELECT tryBase64UrlDecode('aHR0cHM6Ly9jbGlja');\n+\n+-- test FixedString argument\n+\n+SELECT toFixedString('https://clickhouse.com', 22) AS original, base64UrlEncode(original) AS encoded, base64UrlDecode(encoded), tryBase64UrlDecode(encoded);\n",
  "problem_statement": "Dedicated support for Base64URL encoding\n**Use case**\r\nClickhouse is missing the common Base64URL encoding/decoding. \r\nHaving a dedicated function for this would be much faster.\r\n\r\n**Describe the solution you'd like**\r\nHave implementations of `Base64UrlDecode()`/`Base64UrlEncode()` and `FROM_BASE64URL()`/`TO_BASE64URL()`\r\n\r\n**Describe alternatives you've considered**\r\nCurrent alternative is to replace `+` and `/` for `-` and `_` before/after decode/encode.\n",
  "hints_text": "As a temporary solution `translate` function introduced in #38935 can be used:\r\n\r\n``` translate(s, '+/', '-_')```\nI am currently working on this task. Please assign this task to me if possible.\nSome research on Base64URL support.\r\nBase64URL, as specified in \"RFC 4648 - The Base16, Base32, and Base64 Data Encodings\" at\u00a0https://tools.ietf.org/html/rfc4648, is as variation of the standard Base64 encoding specified in \"RFC 1521 - MIME (Multipurpose Internet Mail Extensions) Part One: Mechanisms for Specifying and Describing the Format of Internet Message Bodies\" at\u00a0https://tools.ietf.org/html/rfc1521.\r\nIn RFC 4648, 2 modifications on Base64 encoding are suggested to define Base64URL encoding:\r\n* \u201c+\u201d in the encoding map is replaced with \u201c-\u201d, since \"+\" in URL represents a space character \" \".\r\n* \u201c/\u201d in the encoding map is replaced with \u201c_\u201d, since \"/\" in URL represents the directory separator.\r\n\r\nClickHouse features base64Encode (alias: TO_BASE64)/base64Decode (alias: FROM_BASE64)/tryBase64Decode functions, but without URL replacement pre/postprocessing support.\r\nLibraries to consider:\r\n\r\n1. [Aklomp-base64](https://github.com/aklomp/base64) (SSSE3/SSE4.1/SSE4.2/AVX2/NEON/AVX512 SIMD optimizations) - this library is currently used in base64Encode/decode CH implementation, but it does not support RFC 4648.\u2028ClickHouse switched to aklomp-base64 from Turbo-Base64 in PR https://github.com/ClickHouse/ClickHouse/issues/31643. The reason is:\u2028\"Replaced the library to handle (encode/decode) base64 values from Turbo-Base64 to aklomp-base64. Both are SIMD-accelerated on x86 and ARM but 1. the license of the latter (BSD-2) is more favorable for ClickHouse, Turbo64 switched in the meantime to GPL-3, 2. with more GitHub stars, aklomp-base64 seems more future-proof, 3. aklomp-base64 has a slightly nicer API (which is arguably subjective), and 4. aklomp-base64 does not require us to hack around bugs (like non-threadsafe initialization). Note: aklomp-base64 rejects unpadded base64 values whereas Turbo-Base64 decodes them on a best-effort basis. RFC-4648 leaves it open whether padding is mandatory or not, but depending on the context this may be a behavioral change to be aware of.\"\r\n2. Poco::Base64Encoder - supports URL encoding/decoding - this library is not SIMD-optimized, but supports RFC 4648 (by using another replacement table, and no line breaks in output stream for URLs)\r\n\r\nSolutions proposed:\r\n1. Switching to Poco::Base64Encoder/Decoder (it lacks hand-written SIMD optimizations, but who benchmarked compiler-generated optimizations there?)\r\n2. Look for some other 3-rd party library that supports Base64URL and SIMD (it is quite expensive and may have a lot of issues such as performance, licensing and compatibility issues).\r\n3. Stay with aklomp library and do pre/post-processing URLs before/after submitting them to aklomp separately (it will require double string processing, but is a good compromise).\r\n4. Submit a PR into aklomp library with RFC 4648 support (there is an issue on Base64url there: https://github.com/aklomp/base64/issues/66). Technically, it is possible to change translation table (see author\u2019s comment below).\r\n5. Same, but patch aklomp library and create a fork in https://github.com/ClickHouse\r\n\r\nThe aklomp library author says:\r\n\u201cHi! Currently this library only supports the\u00a0[standard](https://github.com/aklomp/base64/blob/master/lib/tables/tables.c#L5)\u00a0Base64 alphabet.\r\nIt would probably be feasible, but difficult, to add support for additional alphabets. It could be non-trivial to add that support to the SIMD codecs, because they do arithmetic on the raw character values. Here's\u00a0[an encoder example](https://github.com/aklomp/base64/blob/master/lib/arch/ssse3/enc_translate.c)\u00a0and here's\u00a0[a decoder](https://github.com/aklomp/base64/blob/master/lib/arch/ssse3/dec_loop.c).\r\nMy intuition is that it would probably be possible to find an arithmetic-based solution that works with the alternative alphabet since the differences are small. However, it would require duplicating a lot of code, and adding some sort of user-visible flag to the API to indicate which alphabet to use. Maybe it could be a compile-time flag to not incur runtime penalties or complexities.\u201d (https://github.com/aklomp/base64/issues/66#issuecomment-594227849)\r\n\r\nCurrently, solution 3 seems most viable to me, since URL string are comparatively small and there will be no performance impact compared to the workaround proposed in the issue.\r\n\r\nTest:\u00a0[tests/queries/0_stateless/00732_base64_functions.sql]\r\n\r\n@marcioapm @Algunenano pls comment on this what do you think?\n@rschu1ze Maybe you look at this as well?\r\nIf there is no objections, I'll implement option 3: URLs pre/post-processing before/after encode/decode.\n@mgorshkov Thanks for looking into this.\r\n\r\nThoughts:\r\n- Poco is a jack-of-all-trades, and we should not use it more than necessary. ClickHouse's current fork (actually code dump) lags behind upstream, poco is not very popular these days (people usually prefer Boost), and it lacks a SIMD implementation. Let's not go this route.\r\n- As you noticed we switched to aklomp-base64 from Turbo-Base64. Indeed, aklomp-base64 is actually quite nice (in terms of speed and license) but it obviously does not support base64url.\r\n- Regarding your proposals 1-5: The \"right\" and \"open-source\" way to build this feature are 4. and 5. Basically, make a PR which extends the 3rd-party library with base64url support, then either update ClickHouse's submodule to include the upstream patch or if that takes too long or is otherwise not possible, we can fork aklomp0-base64 in the ClickHouse organization (happens all the time, see https://github.com/ClickHouse/) and include the patch over there.\r\n\r\nBut I'd also totally fine with option 3.\r\n\r\nAs far as I understand, we not only need to replace `+` and `/`, we also need to make sure there is no padding with `=`. Padding in the base64 standard is optional, so we either might want to force the aklomp library to omit padding or remove the padding in a postprocessing step.",
  "created_at": "2024-06-07T15:54:42Z"
}