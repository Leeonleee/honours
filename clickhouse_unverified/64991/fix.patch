diff --git a/docs/en/sql-reference/functions/string-functions.md b/docs/en/sql-reference/functions/string-functions.md
index c2d19f584221..c535b82d710a 100644
--- a/docs/en/sql-reference/functions/string-functions.md
+++ b/docs/en/sql-reference/functions/string-functions.md
@@ -1136,16 +1136,136 @@ SELECT tryBase58Decode('3dc8KtHrwM') as res, tryBase58Decode('invalid') as res_i
 
 ## base64Encode
 
-Encodes a String or FixedString as base64.
+Encodes a String or FixedString as base64, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-4).
 
 Alias: `TO_BASE64`.
 
+**Syntax**
+
+```sql
+base64Encode(plaintext)
+```
+
+**Arguments**
+
+- `plaintext` — [String](../data-types/string.md) column or constant.
+
+**Returned value**
+
+- A string containing the encoded value of the argument.
+
+**Example**
+
+``` sql
+SELECT base64Encode('clickhouse');
+```
+
+Result:
+
+```result
+┌─base64Encode('clickhouse')─┐
+│ Y2xpY2tob3VzZQ==           │
+└────────────────────────────┘
+```
+
+## base64UrlEncode
+
+Encodes an URL (String or FixedString) as base64 with URL-specific modifications, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-5).
+
+**Syntax**
+
+```sql
+base64UrlEncode(url)
+```
+
+**Arguments**
+
+- `url` — [String](../data-types/string.md) column or constant.
+
+**Returned value**
+
+- A string containing the encoded value of the argument.
+
+**Example**
+
+``` sql
+SELECT base64UrlEncode('https://clickhouse.com');
+```
+
+Result:
+
+```result
+┌─base64UrlEncode('https://clickhouse.com')─┐
+│ aHR0cDovL2NsaWNraG91c2UuY29t              │
+└───────────────────────────────────────────┘
+```
+
 ## base64Decode
 
-Decodes a base64-encoded String or FixedString. Throws an exception in case of error.
+Accepts a String and decodes it from base64, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-4). Throws an exception in case of an error.
 
 Alias: `FROM_BASE64`.
 
+**Syntax**
+
+```sql
+base64Decode(encoded)
+```
+
+**Arguments**
+
+- `encoded` — [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value, an exception is thrown.
+
+**Returned value**
+
+- A string containing the decoded value of the argument.
+
+**Example**
+
+``` sql
+SELECT base64Decode('Y2xpY2tob3VzZQ==');
+```
+
+Result:
+
+```result
+┌─base64Decode('Y2xpY2tob3VzZQ==')─┐
+│ clickhouse                       │
+└──────────────────────────────────┘
+```
+
+## base64UrlDecode
+
+Accepts a base64-encoded URL and decodes it from base64 with URL-specific modifications, according to [RFC 4648](https://datatracker.ietf.org/doc/html/rfc4648#section-5). Throws an exception in case of an error.
+
+**Syntax**
+
+```sql
+base64UrlDecode(encodedUrl)
+```
+
+**Arguments**
+
+- `encodedUrl` — [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, an exception is thrown.
+
+**Returned value**
+
+- A string containing the decoded value of the argument.
+
+**Example**
+
+``` sql
+SELECT base64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t');
+```
+
+Result:
+
+```result
+┌─base64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t')─┐
+│ https://clickhouse.com                          │
+└─────────────────────────────────────────────────┘
+```
+
 ## tryBase64Decode
 
 Like `base64Decode` but returns an empty string in case of error.
@@ -1156,9 +1276,13 @@ Like `base64Decode` but returns an empty string in case of error.
 tryBase64Decode(encoded)
 ```
 
-**Parameters**
+**Arguments**
 
-- `encoded`: [String](../data-types/string.md) column or constant. If the string is not a valid Base58-encoded value, returns an empty string in case of error.
+- `encoded`: [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value, returns an empty string.
+
+**Returned value**
+
+- A string containing the decoded value of the argument.
 
 **Examples**
 
@@ -1169,9 +1293,41 @@ SELECT tryBase64Decode('RW5jb2RlZA==') as res, tryBase64Decode('invalid') as res
 ```
 
 ```response
-┌─res─────┬─res_invalid─┐
-│ Encoded │             │
-└─────────┴─────────────┘
+┌─res────────┬─res_invalid─┐
+│ clickhouse │             │
+└────────────┴─────────────┘
+```
+
+## tryBase64UrlDecode
+
+Like `base64UrlDecode` but returns an empty string in case of error.
+
+**Syntax**
+
+```sql
+tryBase64UrlDecode(encodedUrl)
+```
+
+**Parameters**
+
+- `encodedUrl`: [String](../data-types/string.md) column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, returns an empty string.
+
+**Returned value**
+
+- A string containing the decoded value of the argument.
+
+**Examples**
+
+Query:
+
+```sql
+SELECT tryBase64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t') as res, tryBase64Decode('aHR0cHM6Ly9jbGlja') as res_invalid;
+```
+
+```response
+┌─res────────────────────┬─res_invalid─┐
+│ https://clickhouse.com │             │
+└────────────────────────┴─────────────┘
 ```
 
 ## endsWith {#endswith}
diff --git a/docs/ru/sql-reference/functions/string-functions.md b/docs/ru/sql-reference/functions/string-functions.md
index fc258f7b4cfc..fa76e84f1301 100644
--- a/docs/ru/sql-reference/functions/string-functions.md
+++ b/docs/ru/sql-reference/functions/string-functions.md
@@ -538,16 +538,28 @@ SELECT base58Decode('3dc8KtHrwM');
 
 Синоним: `TO_BASE64`.
 
+## base64UrlEncode(s)
+
+Производит кодирование URL (String или FixedString) в base64-представление в соответствии с [RFC 4648](https://tools.ietf.org/html/rfc4648).
+
 ## base64Decode(s) {#base64decode}
 
 Декодирует base64-представление s в исходную строку. При невозможности декодирования выбрасывает исключение
 
 Синоним: `FROM_BASE64`.
 
+## base64UrlDecode(s)
+
+Декодирует base64-представление URL в исходную строку в соответствии с [RFC 4648](https://tools.ietf.org/html/rfc4648). При невозможности декодирования выбрасывает исключение
+
 ## tryBase64Decode(s) {#trybase64decode}
 
 Функционал аналогичен base64Decode, но при невозможности декодирования возвращает пустую строку.
 
+## tryBase64UrlDecode(s)
+
+Функционал аналогичен base64UrlDecode, но при невозможности декодирования возвращает пустую строку.
+
 ## endsWith(s, suffix) {#endswith}
 
 Возвращает 1, если строка завершается указанным суффиксом, и 0 в противном случае.
diff --git a/src/Functions/FunctionBase64Conversion.h b/src/Functions/FunctionBase64Conversion.h
index 3906563a2549..05914be38378 100644
--- a/src/Functions/FunctionBase64Conversion.h
+++ b/src/Functions/FunctionBase64Conversion.h
@@ -12,7 +12,7 @@
 #    include <Common/MemorySanitizer.h>
 
 #    include <cstddef>
-#    include <span>
+#    include <string_view>
 
 namespace DB
 {
@@ -22,36 +22,125 @@ namespace ErrorCodes
     extern const int INCORRECT_DATA;
 }
 
+enum class Base64Variant : uint8_t
+{
+    Normal,
+    Url
+};
+
+inline std::string preprocessBase64Url(std::string_view src)
+{
+    std::string padded_src;
+    padded_src.reserve(src.size() + 3);
+
+    // Do symbol substitution as described in https://datatracker.ietf.org/doc/html/rfc4648#section-5
+    for (auto s : src)
+    {
+        switch (s)
+        {
+        case '_':
+            padded_src += '/';
+            break;
+        case '-':
+            padded_src += '+';
+            break;
+        default:
+            padded_src += s;
+            break;
+        }
+    }
+
+    /// Insert padding to please aklomp library
+    size_t remainder = src.size() % 4;
+    switch (remainder)
+    {
+        case 0:
+            break; // no padding needed
+        case 1:
+            padded_src.append("==="); // this case is impossible to occur with valid base64-URL encoded input, however, we'll insert padding anyway
+            break;
+        case 2:
+            padded_src.append("=="); // two bytes padding
+            break;
+        default: // remainder == 3
+            padded_src.append("="); // one byte padding
+            break;
+    }
+
+    return padded_src;
+}
+
+inline size_t postprocessBase64Url(UInt8 * dst, size_t out_len)
+{
+    // Do symbol substitution as described in https://datatracker.ietf.org/doc/html/rfc4648#section-5
+    for (size_t i = 0; i < out_len; ++i)
+    {
+        switch (dst[i])
+        {
+        case '/':
+            dst[i] = '_';
+            break;
+        case '+':
+            dst[i] = '-';
+            break;
+        case '=': // stop when padding is detected
+            return i;
+        default:
+            break;
+        }
+    }
+    return out_len;
+}
+
+template <Base64Variant variant>
 struct Base64Encode
 {
-    static constexpr auto name = "base64Encode";
+    static constexpr auto name = (variant == Base64Variant::Normal) ? "base64Encode" : "base64UrlEncode";
 
     static size_t getBufferSize(size_t string_length, size_t string_count)
     {
         return ((string_length - string_count) / 3 + string_count) * 4 + string_count;
     }
 
-    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)
+    static size_t perform(std::string_view src, UInt8 * dst)
     {
         size_t outlen = 0;
-        base64_encode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        base64_encode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+
+        /// Base64 library is using AVX-512 with some shuffle operations.
+        /// Memory sanitizer doesn't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.
+        __msan_unpoison(dst, outlen);
+
+        if constexpr (variant == Base64Variant::Url)
+            outlen = postprocessBase64Url(dst, outlen);
+
         return outlen;
     }
 };
 
+template <Base64Variant variant>
 struct Base64Decode
 {
-    static constexpr auto name = "base64Decode";
+    static constexpr auto name = (variant == Base64Variant::Normal) ? "base64Decode" : "base64UrlDecode";
 
     static size_t getBufferSize(size_t string_length, size_t string_count)
     {
         return ((string_length - string_count) / 4 + string_count) * 3 + string_count;
     }
 
-    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)
+    static size_t perform(std::string_view src, UInt8 * dst)
     {
+        int rc;
         size_t outlen = 0;
-        int rc = base64_decode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        if constexpr (variant == Base64Variant::Url)
+        {
+            std::string src_padded = preprocessBase64Url(src);
+            rc = base64_decode(src_padded.data(), src_padded.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        }
+        else
+        {
+            rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        }
 
         if (rc != 1)
             throw Exception(
@@ -64,19 +153,29 @@ struct Base64Decode
     }
 };
 
+template <Base64Variant variant>
 struct TryBase64Decode
 {
-    static constexpr auto name = "tryBase64Decode";
+    static constexpr auto name = (variant == Base64Variant::Normal) ? "tryBase64Decode" : "tryBase64UrlDecode";
 
     static size_t getBufferSize(size_t string_length, size_t string_count)
     {
-        return Base64Decode::getBufferSize(string_length, string_count);
+        return Base64Decode<variant>::getBufferSize(string_length, string_count);
     }
 
-    static size_t perform(const std::span<const UInt8> src, UInt8 * dst)
+    static size_t perform(std::string_view src, UInt8 * dst)
     {
+        int rc;
         size_t outlen = 0;
-        int rc = base64_decode(reinterpret_cast<const char *>(src.data()), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        if constexpr (variant == Base64Variant::Url)
+        {
+            std::string src_padded = preprocessBase64Url(src);
+            rc = base64_decode(src_padded.data(), src_padded.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        }
+        else
+        {
+            rc = base64_decode(src.data(), src.size(), reinterpret_cast<char *>(dst), &outlen, 0);
+        }
 
         if (rc != 1)
             outlen = 0;
@@ -139,7 +238,7 @@ class FunctionBase64Conversion : public IFunction
 
         auto * dst = dst_chars.data();
         auto * dst_pos = dst;
-        const auto * src = src_chars.data();
+        const auto * src = reinterpret_cast<const char *>(src_chars.data());
 
         size_t src_offset_prev = 0;
         for (size_t row = 0; row < src_row_count; ++row)
@@ -147,10 +246,6 @@ class FunctionBase64Conversion : public IFunction
             const size_t src_length = src_offsets[row] - src_offset_prev - 1;
             const size_t outlen = Func::perform({src, src_length}, dst_pos);
 
-            /// Base64 library is using AVX-512 with some shuffle operations.
-            /// Memory sanitizer don't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.
-            __msan_unpoison(dst_pos, outlen);
-
             src += src_length + 1;
             dst_pos += outlen;
             *dst_pos = '\0';
@@ -179,16 +274,12 @@ class FunctionBase64Conversion : public IFunction
 
         auto * dst = dst_chars.data();
         auto * dst_pos = dst;
-        const auto * src = src_chars.data();
+        const auto * src = reinterpret_cast<const char *>(src_chars.data());
 
         for (size_t row = 0; row < src_row_count; ++row)
         {
             const auto outlen = Func::perform({src, src_n}, dst_pos);
 
-            /// Base64 library is using AVX-512 with some shuffle operations.
-            /// Memory sanitizer don't understand if there was uninitialized memory in SIMD register but it was not used in the result of shuffle.
-            __msan_unpoison(dst_pos, outlen);
-
             src += src_n;
             dst_pos += outlen;
             *dst_pos = '\0';
diff --git a/src/Functions/base64Decode.cpp b/src/Functions/base64Decode.cpp
index 5f7a3406c620..50278c4b0b23 100644
--- a/src/Functions/base64Decode.cpp
+++ b/src/Functions/base64Decode.cpp
@@ -7,7 +7,14 @@ namespace DB
 {
 REGISTER_FUNCTION(Base64Decode)
 {
-    factory.registerFunction<FunctionBase64Conversion<Base64Decode>>();
+    FunctionDocumentation::Description description = R"(Accepts a String and decodes it from base64, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-4). Throws an exception in case of an error. Alias: FROM_BASE64.)";
+    FunctionDocumentation::Syntax syntax = "base64Decode(encoded)";
+    FunctionDocumentation::Arguments arguments = {{"encoded", "String column or constant. If the string is not a valid Base64-encoded value, an exception is thrown."}};
+    FunctionDocumentation::ReturnedValue returned_value = "A string containing the decoded value of the argument.";
+    FunctionDocumentation::Examples examples = {{"Example", "SELECT base64Decode('Y2xpY2tob3VzZQ==')", "clickhouse"}};
+    FunctionDocumentation::Categories categories = {"String encoding"};
+
+    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, categories});
 
     /// MySQL compatibility alias.
     factory.registerAlias("FROM_BASE64", "base64Decode", FunctionFactory::CaseInsensitive);
diff --git a/src/Functions/base64Encode.cpp b/src/Functions/base64Encode.cpp
index 69268f5a25d6..d6e63c38a4ca 100644
--- a/src/Functions/base64Encode.cpp
+++ b/src/Functions/base64Encode.cpp
@@ -7,7 +7,14 @@ namespace DB
 {
 REGISTER_FUNCTION(Base64Encode)
 {
-    factory.registerFunction<FunctionBase64Conversion<Base64Encode>>();
+    FunctionDocumentation::Description description = R"(Encodes a String as base64, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-4). Alias: TO_BASE64.)";
+    FunctionDocumentation::Syntax syntax = "base64Encode(plaintext)";
+    FunctionDocumentation::Arguments arguments = {{"plaintext", "String column or constant."}};
+    FunctionDocumentation::ReturnedValue returned_value = "A string containing the encoded value of the argument.";
+    FunctionDocumentation::Examples examples = {{"Example", "SELECT base64Encode('clickhouse')", "Y2xpY2tob3VzZQ=="}};
+    FunctionDocumentation::Categories categories = {"String encoding"};
+
+    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, categories});
 
     /// MySQL compatibility alias.
     factory.registerAlias("TO_BASE64", "base64Encode", FunctionFactory::CaseInsensitive);
diff --git a/src/Functions/base64UrlDecode.cpp b/src/Functions/base64UrlDecode.cpp
new file mode 100644
index 000000000000..59975d8f9d1d
--- /dev/null
+++ b/src/Functions/base64UrlDecode.cpp
@@ -0,0 +1,21 @@
+#include <Functions/FunctionBase64Conversion.h>
+
+#if USE_BASE64
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+REGISTER_FUNCTION(Base64UrlDecode)
+{
+    FunctionDocumentation::Description description = R"(Accepts a base64-encoded URL and decodes it from base64 with URL-specific modifications, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-5).)";
+    FunctionDocumentation::Syntax syntax = "base64UrlDecode(encodedUrl)";
+    FunctionDocumentation::Arguments arguments = {{"encodedUrl", "String column or constant. If the string is not a valid Base64-encoded value, an exception is thrown."}};
+    FunctionDocumentation::ReturnedValue returned_value = "A string containing the decoded value of the argument.";
+    FunctionDocumentation::Examples examples = {{"Example", "SELECT base64UrlDecode('aHR0cDovL2NsaWNraG91c2UuY29t')", "https://clickhouse.com"}};
+    FunctionDocumentation::Categories categories = {"String encoding"};
+
+    factory.registerFunction<FunctionBase64Conversion<Base64Decode<Base64Variant::Url>>>({description, syntax, arguments, returned_value, examples, categories});
+}
+}
+
+#endif
diff --git a/src/Functions/base64UrlEncode.cpp b/src/Functions/base64UrlEncode.cpp
new file mode 100644
index 000000000000..05d50170c148
--- /dev/null
+++ b/src/Functions/base64UrlEncode.cpp
@@ -0,0 +1,21 @@
+#include <Functions/FunctionBase64Conversion.h>
+
+#if USE_BASE64
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+REGISTER_FUNCTION(Base64UrlEncode)
+{
+    FunctionDocumentation::Description description = R"(Encodes an URL (String or FixedString) as base64 with URL-specific modifications, according to RFC 4648 (https://datatracker.ietf.org/doc/html/rfc4648#section-5).)";
+    FunctionDocumentation::Syntax syntax = "base64UrlEncode(url)";
+    FunctionDocumentation::Arguments arguments = {{"url", "String column or constant."}};
+    FunctionDocumentation::ReturnedValue returned_value = "A string containing the encoded value of the argument.";
+    FunctionDocumentation::Examples examples = {{"Example", "SELECT base64UrlEncode('https://clickhouse.com')", "aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ"}};
+    FunctionDocumentation::Categories categories = {"String encoding"};
+
+    factory.registerFunction<FunctionBase64Conversion<Base64Encode<Base64Variant::Url>>>({description, syntax, arguments, returned_value, examples, categories});
+}
+}
+
+#endif
diff --git a/src/Functions/tryBase64Decode.cpp b/src/Functions/tryBase64Decode.cpp
index bd452b8357b8..08eabe93200d 100644
--- a/src/Functions/tryBase64Decode.cpp
+++ b/src/Functions/tryBase64Decode.cpp
@@ -7,7 +7,14 @@ namespace DB
 {
 REGISTER_FUNCTION(TryBase64Decode)
 {
-    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode>>();
+    FunctionDocumentation::Description description = R"(Decodes a String or FixedString from base64, like base64Decode but returns an empty string in case of an error.)";
+    FunctionDocumentation::Syntax syntax = "tryBase64Decode(encoded)";
+    FunctionDocumentation::Arguments arguments = {{"encoded", "String column or constant. If the string is not a valid Base64-encoded value, returns an empty string."}};
+    FunctionDocumentation::ReturnedValue returned_value = "A string containing the decoded value of the argument.";
+    FunctionDocumentation::Examples examples = {{"valid", "SELECT tryBase64Decode('Y2xpY2tob3VzZQ==')", "clickhouse"}, {"invalid", "SELECT tryBase64Decode('invalid')", ""}};
+    FunctionDocumentation::Categories categories = {"String encoding"};
+
+    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::Normal>>>({description, syntax, arguments, returned_value, examples, categories});
 }
 }
 
diff --git a/src/Functions/tryBase64UrlDecode.cpp b/src/Functions/tryBase64UrlDecode.cpp
new file mode 100644
index 000000000000..b9aaf4f92735
--- /dev/null
+++ b/src/Functions/tryBase64UrlDecode.cpp
@@ -0,0 +1,21 @@
+#include <Functions/FunctionBase64Conversion.h>
+
+#if USE_BASE64
+#include <Functions/FunctionFactory.h>
+
+namespace DB
+{
+REGISTER_FUNCTION(TryBase64UrlDecode)
+{
+    FunctionDocumentation::Description description = R"(Decodes an URL from base64, like base64UrlDecode but returns an empty string in case of an error.)";
+    FunctionDocumentation::Syntax syntax = "tryBase64UrlDecode(encodedUrl)";
+    FunctionDocumentation::Arguments arguments = {{"encodedUrl", "String column or constant. If the string is not a valid Base64-encoded value with URL-specific modifications, returns an empty string."}};
+    FunctionDocumentation::ReturnedValue returned_value = "A string containing the decoded value of the argument.";
+    FunctionDocumentation::Examples examples = {{"valid", "SELECT tryBase64UrlDecode('aHR0cHM6Ly9jbGlja2hvdXNlLmNvbQ')", "https://clickhouse.com"}, {"invalid", "SELECT tryBase64UrlDecode('aHR0cHM6Ly9jbGlja')", ""}};
+    FunctionDocumentation::Categories categories = {"String encoding"};
+
+    factory.registerFunction<FunctionBase64Conversion<TryBase64Decode<Base64Variant::Url>>>({description, syntax, arguments, returned_value, examples, categories});
+}
+}
+
+#endif
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 846826899349..64ff3e8e2cb8 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1011,6 +1011,8 @@ Updatable
 Uppercased
 Uptime
 Uptrace
+UrlDecode
+UrlEncode
 UserID
 Util
 VARCHAR
