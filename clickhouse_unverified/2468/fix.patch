diff --git a/dbms/src/Storages/MergeTree/KeyCondition.cpp b/dbms/src/Storages/MergeTree/KeyCondition.cpp
index bc618f8d6550..1a8423e7f1d8 100644
--- a/dbms/src/Storages/MergeTree/KeyCondition.cpp
+++ b/dbms/src/Storages/MergeTree/KeyCondition.cpp
@@ -921,7 +921,7 @@ bool KeyCondition::mayBeTrueInRange(
     return forAnyParallelogram(used_key_size, left_key, right_key, true, right_bounded, key_ranges, 0,
         [&] (const std::vector<Range> & key_ranges)
     {
-        auto res = mayBeTrueInRangeImpl(key_ranges, data_types);
+        auto res = mayBeTrueInParallelogram(key_ranges, data_types);
 
 /*      std::cerr << "Parallelogram: ";
         for (size_t i = 0, size = key_ranges.size(); i != size; ++i)
@@ -969,7 +969,7 @@ std::optional<Range> KeyCondition::applyMonotonicFunctionsChainToRange(
     return key_range;
 }
 
-bool KeyCondition::mayBeTrueInRangeImpl(const std::vector<Range> & key_ranges, const DataTypes & data_types) const
+bool KeyCondition::mayBeTrueInParallelogram(const std::vector<Range> & parallelogram, const DataTypes & data_types) const
 {
     std::vector<BoolMask> rpn_stack;
     for (size_t i = 0; i < rpn.size(); ++i)
@@ -982,7 +982,7 @@ bool KeyCondition::mayBeTrueInRangeImpl(const std::vector<Range> & key_ranges, c
         else if (element.function == RPNElement::FUNCTION_IN_RANGE
             || element.function == RPNElement::FUNCTION_NOT_IN_RANGE)
         {
-            const Range * key_range = &key_ranges[element.key_column];
+            const Range * key_range = &parallelogram[element.key_column];
 
             /// The case when the column is wrapped in a chain of possibly monotonic functions.
             Range transformed_range;
@@ -1019,7 +1019,7 @@ bool KeyCondition::mayBeTrueInRangeImpl(const std::vector<Range> & key_ranges, c
             PreparedSets::const_iterator it = prepared_sets.find(args[1]->range);
             if (in_func && it != prepared_sets.end())
             {
-                rpn_stack.emplace_back(element.set_index->mayBeTrueInRange(key_ranges, data_types));
+                rpn_stack.emplace_back(element.set_index->mayBeTrueInRange(parallelogram, data_types));
                 if (element.function == RPNElement::FUNCTION_NOT_IN_SET)
                     rpn_stack.back() = !rpn_stack.back();
             }
diff --git a/dbms/src/Storages/MergeTree/KeyCondition.h b/dbms/src/Storages/MergeTree/KeyCondition.h
index c7d55b0a575c..f9f44ecc2bd8 100644
--- a/dbms/src/Storages/MergeTree/KeyCondition.h
+++ b/dbms/src/Storages/MergeTree/KeyCondition.h
@@ -240,6 +240,9 @@ class KeyCondition
     /// data_types - the types of the key columns.
     bool mayBeTrueInRange(size_t used_key_size, const Field * left_key, const Field * right_key, const DataTypes & data_types) const;
 
+    /// Whether the condition is feasible in the direct product of single column ranges specified by `parallelogram`.
+    bool mayBeTrueInParallelogram(const std::vector<Range> & parallelogram, const DataTypes & data_types) const;
+
     /// Is the condition valid in a semi-infinite (not limited to the right) key range.
     /// left_key must contain all the fields in the sort_descr in the appropriate order.
     bool mayBeTrueAfter(size_t used_key_size, const Field * left_key, const DataTypes & data_types) const;
@@ -325,8 +328,6 @@ class KeyCondition
         const DataTypes & data_types,
         bool right_bounded) const;
 
-    bool mayBeTrueInRangeImpl(const std::vector<Range> & key_ranges, const DataTypes & data_types) const;
-
     void traverseAST(const ASTPtr & node, const Context & context, Block & block_with_constants);
     bool atomFromAST(const ASTPtr & node, const Context & context, Block & block_with_constants, RPNElement & out);
     bool operatorFromAST(const ASTFunction * func, RPNElement & out);
diff --git a/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp
index 6bac6047dacd..131fe50f0a7b 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeDataPart.cpp
@@ -48,15 +48,19 @@ static ReadBufferFromFile openForReading(const String & path)
 void MergeTreeDataPart::MinMaxIndex::load(const MergeTreeData & storage, const String & part_path)
 {
     size_t minmax_idx_size = storage.minmax_idx_column_types.size();
-    min_values.resize(minmax_idx_size);
-    max_values.resize(minmax_idx_size);
+    parallelogram.reserve(minmax_idx_size);
     for (size_t i = 0; i < minmax_idx_size; ++i)
     {
         String file_name = part_path + "minmax_" + escapeForFileName(storage.minmax_idx_columns[i]) + ".idx";
         ReadBufferFromFile file = openForReading(file_name);
         const DataTypePtr & type = storage.minmax_idx_column_types[i];
-        type->deserializeBinary(min_values[i], file);
-        type->deserializeBinary(max_values[i], file);
+
+        Field min_val;
+        type->deserializeBinary(min_val, file);
+        Field max_val;
+        type->deserializeBinary(max_val, file);
+
+        parallelogram.emplace_back(min_val, true, max_val, true);
     }
     initialized = true;
 }
@@ -74,8 +78,8 @@ void MergeTreeDataPart::MinMaxIndex::store(const MergeTreeData & storage, const
 
         WriteBufferFromFile out(part_path + file_name);
         HashingWriteBuffer out_hashing(out);
-        type->serializeBinary(min_values[i], out_hashing);
-        type->serializeBinary(max_values[i], out_hashing);
+        type->serializeBinary(parallelogram[i].left, out_hashing);
+        type->serializeBinary(parallelogram[i].right, out_hashing);
         out_hashing.next();
         checksums.files[file_name].file_size = out_hashing.count();
         checksums.files[file_name].file_hash = out_hashing.getHash();
@@ -85,10 +89,7 @@ void MergeTreeDataPart::MinMaxIndex::store(const MergeTreeData & storage, const
 void MergeTreeDataPart::MinMaxIndex::update(const Block & block, const Names & column_names)
 {
     if (!initialized)
-    {
-        min_values.resize(column_names.size());
-        max_values.resize(column_names.size());
-    }
+        parallelogram.reserve(column_names.size());
 
     for (size_t i = 0; i < column_names.size(); ++i)
     {
@@ -98,14 +99,11 @@ void MergeTreeDataPart::MinMaxIndex::update(const Block & block, const Names & c
         column.column->getExtremes(min_value, max_value);
 
         if (!initialized)
-        {
-            min_values[i] = Field(min_value);
-            max_values[i] = Field(max_value);
-        }
+            parallelogram.emplace_back(min_value, true, max_value, true);
         else
         {
-            min_values[i] = std::min(min_values[i], min_value);
-            max_values[i] = std::max(max_values[i], max_value);
+            parallelogram[i].left = std::min(parallelogram[i].left, min_value);
+            parallelogram[i].right = std::max(parallelogram[i].right, max_value);
         }
     }
 
@@ -119,16 +117,15 @@ void MergeTreeDataPart::MinMaxIndex::merge(const MinMaxIndex & other)
 
     if (!initialized)
     {
-        min_values.assign(other.min_values);
-        max_values.assign(other.max_values);
+        parallelogram = other.parallelogram;
         initialized = true;
     }
     else
     {
-        for (size_t i = 0; i < min_values.size(); ++i)
+        for (size_t i = 0; i < parallelogram.size(); ++i)
         {
-            min_values[i] = std::min(min_values[i], other.min_values[i]);
-            max_values[i] = std::max(max_values[i], other.max_values[i]);
+            parallelogram[i].left = std::min(parallelogram[i].left, other.parallelogram[i].left);
+            parallelogram[i].right = std::max(parallelogram[i].right, other.parallelogram[i].right);
         }
     }
 }
@@ -255,7 +252,7 @@ String MergeTreeDataPart::getNewName(const MergeTreePartInfo & new_part_info) co
 DayNum MergeTreeDataPart::getMinDate() const
 {
     if (storage.minmax_idx_date_column_pos != -1 && minmax_idx.initialized)
-        return DayNum(minmax_idx.min_values[storage.minmax_idx_date_column_pos].get<UInt64>());
+        return DayNum(minmax_idx.parallelogram[storage.minmax_idx_date_column_pos].left.get<UInt64>());
     else
         return DayNum();
 }
@@ -264,7 +261,7 @@ DayNum MergeTreeDataPart::getMinDate() const
 DayNum MergeTreeDataPart::getMaxDate() const
 {
     if (storage.minmax_idx_date_column_pos != -1 && minmax_idx.initialized)
-        return DayNum(minmax_idx.max_values[storage.minmax_idx_date_column_pos].get<UInt64>());
+        return DayNum(minmax_idx.parallelogram[storage.minmax_idx_date_column_pos].right.get<UInt64>());
     else
         return DayNum();
 }
diff --git a/dbms/src/Storages/MergeTree/MergeTreeDataPart.h b/dbms/src/Storages/MergeTree/MergeTreeDataPart.h
index c3d8b4c2478e..03b6756bd81f 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeDataPart.h
+++ b/dbms/src/Storages/MergeTree/MergeTreeDataPart.h
@@ -2,14 +2,17 @@
 
 #include <Core/Row.h>
 #include <Core/Block.h>
+#include <Core/Types.h>
 #include <Core/NamesAndTypes.h>
 #include <Storages/MergeTree/MergeTreePartInfo.h>
 #include <Storages/MergeTree/MergeTreePartition.h>
 #include <Storages/MergeTree/MergeTreeDataPartChecksum.h>
+#include <Storages/MergeTree/KeyCondition.h>
 #include <Columns/IColumn.h>
+
+#include <Poco/Path.h>
+
 #include <shared_mutex>
-#include "../../../../contrib/poco/Foundation/include/Poco/Path.h"
-#include "../../Core/Types.h"
 
 
 namespace DB
@@ -176,8 +179,8 @@ struct MergeTreeDataPart
     /// can be built using any set of columns.
     struct MinMaxIndex
     {
-        Row min_values;
-        Row max_values;
+        /// A direct product of ranges for each key column. See Storages/MergeTree/KeyCondition.cpp for details.
+        std::vector<Range> parallelogram;
         bool initialized = false;
 
     public:
@@ -185,8 +188,7 @@ struct MergeTreeDataPart
 
         /// For month-based partitioning.
         MinMaxIndex(DayNum min_date, DayNum max_date)
-            : min_values(1, static_cast<UInt64>(min_date))
-            , max_values(1, static_cast<UInt64>(max_date))
+            : parallelogram(1, Range(static_cast<UInt64>(min_date), true, static_cast<UInt64>(max_date), true))
             , initialized(true)
         {
         }
diff --git a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
index ec0c2cd66744..9cdb52a621b6 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp
@@ -251,10 +251,8 @@ BlockInputStreams MergeTreeDataSelectExecutor::read(
             if (part->isEmpty())
                 continue;
 
-            if (minmax_idx_condition && !minmax_idx_condition->mayBeTrueInRange(
-                    data.minmax_idx_columns.size(),
-                    &part->minmax_idx.min_values[0], &part->minmax_idx.max_values[0],
-                    data.minmax_idx_column_types))
+            if (minmax_idx_condition && !minmax_idx_condition->mayBeTrueInParallelogram(
+                    part->minmax_idx.parallelogram, data.minmax_idx_column_types))
                 continue;
 
             if (max_block_number_to_read && part->info.max_block > max_block_number_to_read)
diff --git a/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp
index 4565a4c67793..2a0919f45fec 100644
--- a/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp
+++ b/dbms/src/Storages/MergeTree/MergeTreeDataWriter.cpp
@@ -140,8 +140,8 @@ MergeTreeData::MutableDataPartPtr MergeTreeDataWriter::writeTempPart(BlockWithPa
     String part_name;
     if (data.format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)
     {
-        DayNum min_date(minmax_idx.min_values[data.minmax_idx_date_column_pos].get<UInt64>());
-        DayNum max_date(minmax_idx.max_values[data.minmax_idx_date_column_pos].get<UInt64>());
+        DayNum min_date(minmax_idx.parallelogram[data.minmax_idx_date_column_pos].left.get<UInt64>());
+        DayNum max_date(minmax_idx.parallelogram[data.minmax_idx_date_column_pos].right.get<UInt64>());
 
         const auto & date_lut = DateLUT::instance();
 
