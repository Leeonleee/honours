{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62376,
  "instance_id": "ClickHouse__ClickHouse-62376",
  "issue_numbers": [
    "59071"
  ],
  "base_commit": "fccfdc9edb785ef5ada90d5f41e582b43456e593",
  "patch": "diff --git a/docs/en/operations/query-cache.md b/docs/en/operations/query-cache.md\nindex a8532bc22b7e..7a920671fc23 100644\n--- a/docs/en/operations/query-cache.md\n+++ b/docs/en/operations/query-cache.md\n@@ -67,8 +67,7 @@ SETTINGS use_query_cache = true, enable_writes_to_query_cache = false;\n \n For maximum control, it is generally recommended to provide settings `use_query_cache`, `enable_writes_to_query_cache` and\n `enable_reads_from_query_cache` only with specific queries. It is also possible to enable caching at user or profile level (e.g. via `SET\n-use_query_cache = true`) but one should keep in mind that all `SELECT` queries including monitoring or debugging queries to system tables\n-may return cached results then.\n+use_query_cache = true`) but one should keep in mind that all `SELECT` queries may return cached results then.\n \n The query cache can be cleared using statement `SYSTEM DROP QUERY CACHE`. The content of the query cache is displayed in system table\n [system.query_cache](system-tables/query_cache.md). The number of query cache hits and misses since database start are shown as events\n@@ -175,6 +174,10 @@ Also, results of queries with non-deterministic functions are not cached by defa\n To force caching of results of queries with non-deterministic functions regardless, use setting\n [query_cache_nondeterministic_function_handling](settings/settings.md#query-cache-nondeterministic-function-handling).\n \n+Results of queries that involve system tables, e.g. `system.processes` or `information_schema.tables`, are not cached by default. To force\n+caching of results of queries with system tables regardless, use setting\n+[query_cache_system_table_handling](settings/settings.md#query-cache-system-table-handling).\n+\n :::note\n Prior to ClickHouse v23.11, setting 'query_cache_store_results_of_queries_with_nondeterministic_functions = 0 / 1' controlled whether\n results of queries with non-deterministic results were cached. In newer ClickHouse versions, this setting is obsolete and has no effect.\ndiff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 3e38c22dd8fe..f9fe5f1b2d32 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -1689,6 +1689,18 @@ Possible values:\n \n Default value: `throw`.\n \n+## query_cache_system_table_handling {#query-cache-system-table-handling}\n+\n+Controls how the [query cache](../query-cache.md) handles `SELECT` queries against system tables, i.e. tables in databases `system.*` and `information_schema.*`.\n+\n+Possible values:\n+\n+- `'throw'` - Throw an exception and don't cache the query result.\n+- `'save'` - Cache the query result.\n+- `'ignore'` - Don't cache the query result and don't throw an exception.\n+\n+Default value: `throw`.\n+\n ## query_cache_min_query_runs {#query-cache-min-query-runs}\n \n Minimum number of times a `SELECT` query must run before its result is stored in the [query cache](../query-cache.md).\ndiff --git a/src/Common/ErrorCodes.cpp b/src/Common/ErrorCodes.cpp\nindex af609fabb8f3..97a339b2bace 100644\n--- a/src/Common/ErrorCodes.cpp\n+++ b/src/Common/ErrorCodes.cpp\n@@ -597,6 +597,7 @@\n     M(716, CANNOT_FORGET_PARTITION) \\\n     M(717, EXPERIMENTAL_FEATURE_ERROR) \\\n     M(718, TOO_SLOW_PARSING) \\\n+    M(719, QUERY_CACHE_USED_WITH_SYSTEM_TABLE) \\\n     \\\n     M(900, DISTRIBUTED_CACHE_ERROR) \\\n     M(901, CANNOT_USE_DISTRIBUTED_CACHE) \\\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex d5ea9534e6c8..78e482c60901 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -669,6 +669,7 @@ class IColumn;\n     M(Bool, enable_writes_to_query_cache, true, \"Enable storing results of SELECT queries in the query cache\", 0) \\\n     M(Bool, enable_reads_from_query_cache, true, \"Enable reading results of SELECT queries from the query cache\", 0) \\\n     M(QueryCacheNondeterministicFunctionHandling, query_cache_nondeterministic_function_handling, QueryCacheNondeterministicFunctionHandling::Throw, \"How the query cache handles queries with non-deterministic functions, e.g. now()\", 0) \\\n+    M(QueryCacheSystemTableHandling, query_cache_system_table_handling, QueryCacheSystemTableHandling::Throw, \"How the query cache handles queries against system tables, i.e. tables in databases 'system.*' and 'information_schema.*'\", 0) \\\n     M(UInt64, query_cache_max_size_in_bytes, 0, \"The maximum amount of memory (in bytes) the current user may allocate in the query cache. 0 means unlimited. \", 0) \\\n     M(UInt64, query_cache_max_entries, 0, \"The maximum number of query results the current user may store in the query cache. 0 means unlimited.\", 0) \\\n     M(UInt64, query_cache_min_query_runs, 0, \"Minimum number a SELECT query must run before its result is stored in the query cache\", 0) \\\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex f43ca154d56f..8b5cdf03a33d 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -87,6 +87,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett\n {\n     {\"24.4\", {{\"input_format_json_throw_on_bad_escape_sequence\", true, true, \"Allow to save JSON strings with bad escape sequences\"},\n               {\"lightweight_deletes_sync\", 2, 2, \"The same as 'mutation_sync', but controls only execution of lightweight deletes\"},\n+              {\"query_cache_system_table_handling\", \"save\", \"throw\", \"The query cache no longer caches results of queries against system tables\"},\n               }},\n     {\"24.3\", {{\"s3_connect_timeout_ms\", 1000, 1000, \"Introduce new dedicated setting for s3 connection timeout\"},\n               {\"allow_experimental_shared_merge_tree\", false, true, \"The setting is obsolete\"},\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex e47174a3b9d1..0caf6e8d6098 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -87,6 +87,10 @@ IMPLEMENT_SETTING_ENUM(QueryCacheNondeterministicFunctionHandling, ErrorCodes::B\n      {\"save\",   QueryCacheNondeterministicFunctionHandling::Save},\n      {\"ignore\", QueryCacheNondeterministicFunctionHandling::Ignore}})\n \n+IMPLEMENT_SETTING_ENUM(QueryCacheSystemTableHandling, ErrorCodes::BAD_ARGUMENTS,\n+    {{\"throw\",  QueryCacheSystemTableHandling::Throw},\n+     {\"save\",   QueryCacheSystemTableHandling::Save},\n+     {\"ignore\", QueryCacheSystemTableHandling::Ignore}})\n \n IMPLEMENT_SETTING_ENUM(DateTimeInputFormat, ErrorCodes::BAD_ARGUMENTS,\n     {{\"basic\",       FormatSettings::DateTimeInputFormat::Basic},\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex 0aa8216bb857..b17ff11d4282 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -184,6 +184,15 @@ enum class QueryCacheNondeterministicFunctionHandling\n \n DECLARE_SETTING_ENUM(QueryCacheNondeterministicFunctionHandling)\n \n+/// How the query cache handles queries against system tables, tables in databases 'system.*' and 'information_schema.*'\n+enum class QueryCacheSystemTableHandling\n+{\n+    Throw,\n+    Save,\n+    Ignore\n+};\n+\n+DECLARE_SETTING_ENUM(QueryCacheSystemTableHandling)\n \n DECLARE_SETTING_ENUM_WITH_RENAME(DateTimeInputFormat, FormatSettings::DateTimeInputFormat)\n \ndiff --git a/src/Interpreters/Cache/QueryCache.cpp b/src/Interpreters/Cache/QueryCache.cpp\nindex 151f2ea06cc9..7b1f24e93fca 100644\n--- a/src/Interpreters/Cache/QueryCache.cpp\n+++ b/src/Interpreters/Cache/QueryCache.cpp\n@@ -2,11 +2,17 @@\n \n #include <Functions/FunctionFactory.h>\n #include <Interpreters/Context.h>\n+#include <Interpreters/DatabaseCatalog.h>\n #include <Interpreters/InDepthNodeVisitor.h>\n #include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTSetQuery.h>\n #include <Parsers/IAST.h>\n+#include <Parsers/IParser.h>\n+#include <Parsers/TokenIterator.h>\n #include <Parsers/formatAST.h>\n+#include <Parsers/parseDatabaseAndTableName.h>\n #include <Common/ProfileEvents.h>\n #include <Common/SipHash.h>\n #include <Common/TTLCachePolicy.h>\n@@ -52,7 +58,54 @@ struct HasNonDeterministicFunctionsMatcher\n     }\n };\n \n+struct HasSystemTablesMatcher\n+{\n+    struct Data\n+    {\n+        const ContextPtr context;\n+        bool has_system_tables = false;\n+    };\n+\n+    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }\n+\n+    static void visit(const ASTPtr & node, Data & data)\n+    {\n+        if (data.has_system_tables)\n+            return;\n+\n+        String database_table; /// or whatever else we get, e.g. just a table\n+\n+        /// SELECT [...] FROM <table>\n+        if (const auto * table_identifier = node->as<ASTTableIdentifier>())\n+        {\n+            database_table = table_identifier->name();\n+        }\n+        /// SELECT [...] FROM clusterAllReplicas(<cluster>, <table>)\n+        else if (const auto * identifier = node->as<ASTIdentifier>())\n+        {\n+            database_table = identifier->name();\n+        }\n+        /// Handle SELECT [...] FROM clusterAllReplicas(<cluster>, '<table>')\n+        else if (const auto * literal = node->as<ASTLiteral>())\n+        {\n+            const auto & value = literal->value;\n+            database_table = toString(value);\n+        }\n+\n+        Tokens tokens(database_table.c_str(), database_table.c_str() + database_table.size(), /*max_query_size*/ 2048, /*skip_insignificant*/ true);\n+        IParser::Pos pos(tokens, /*max_depth*/ 42, /*max_backtracks*/ 42);\n+        Expected expected;\n+        String database;\n+        String table;\n+        bool successfully_parsed = parseDatabaseAndTableName(pos, expected, database, table);\n+        if (successfully_parsed)\n+            if (DatabaseCatalog::isPredefinedDatabase(database))\n+                data.has_system_tables = true;\n+    }\n+};\n+\n using HasNonDeterministicFunctionsVisitor = InDepthNodeVisitor<HasNonDeterministicFunctionsMatcher, true>;\n+using HasSystemTablesVisitor = InDepthNodeVisitor<HasSystemTablesMatcher, true>;\n \n }\n \n@@ -63,6 +116,13 @@ bool astContainsNonDeterministicFunctions(ASTPtr ast, ContextPtr context)\n     return finder_data.has_non_deterministic_functions;\n }\n \n+bool astContainsSystemTables(ASTPtr ast, ContextPtr context)\n+{\n+    HasSystemTablesMatcher::Data finder_data{context};\n+    HasSystemTablesVisitor(finder_data).visit(ast);\n+    return finder_data.has_system_tables;\n+}\n+\n namespace\n {\n \ndiff --git a/src/Interpreters/Cache/QueryCache.h b/src/Interpreters/Cache/QueryCache.h\nindex c574f3085e30..a06f504de65b 100644\n--- a/src/Interpreters/Cache/QueryCache.h\n+++ b/src/Interpreters/Cache/QueryCache.h\n@@ -17,6 +17,9 @@ namespace DB\n /// Does AST contain non-deterministic functions like rand() and now()?\n bool astContainsNonDeterministicFunctions(ASTPtr ast, ContextPtr context);\n \n+/// Does AST contain system tables like \"system.processes\"?\n+bool astContainsSystemTables(ASTPtr ast, ContextPtr context);\n+\n /// Maps queries to query results. Useful to avoid repeated query calculation.\n ///\n /// The cache does not aim to be transactionally consistent (which is difficult to get right). For example, the cache is not invalidated\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 7bb6df5f6b6e..db8753000d8e 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -97,6 +97,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int QUERY_CACHE_USED_WITH_NONDETERMINISTIC_FUNCTIONS;\n+    extern const int QUERY_CACHE_USED_WITH_SYSTEM_TABLE;\n     extern const int INTO_OUTFILE_NOT_ALLOWED;\n     extern const int INVALID_TRANSACTION;\n     extern const int LOGICAL_ERROR;\n@@ -1187,15 +1188,26 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     /// top of the pipeline which stores the result in the query cache.\n                     if (can_use_query_cache && settings.enable_writes_to_query_cache)\n                     {\n+                        /// Only use the query cache if the query does not contain non-deterministic functions or system tables (which are typically non-deterministic)\n+\n                         const bool ast_contains_nondeterministic_functions = astContainsNonDeterministicFunctions(ast, context);\n+                        const bool ast_contains_system_tables = astContainsSystemTables(ast, context);\n+\n                         const QueryCacheNondeterministicFunctionHandling nondeterministic_function_handling = settings.query_cache_nondeterministic_function_handling;\n+                        const QueryCacheSystemTableHandling system_table_handling = settings.query_cache_system_table_handling;\n \n                         if (ast_contains_nondeterministic_functions && nondeterministic_function_handling == QueryCacheNondeterministicFunctionHandling::Throw)\n                             throw Exception(ErrorCodes::QUERY_CACHE_USED_WITH_NONDETERMINISTIC_FUNCTIONS,\n                                 \"The query result was not cached because the query contains a non-deterministic function.\"\n                                 \" Use setting `query_cache_nondeterministic_function_handling = 'save'` or `= 'ignore'` to cache the query result regardless or to omit caching\");\n \n-                        if (!ast_contains_nondeterministic_functions || nondeterministic_function_handling == QueryCacheNondeterministicFunctionHandling::Save)\n+                        if (ast_contains_system_tables && system_table_handling == QueryCacheSystemTableHandling::Throw)\n+                            throw Exception(ErrorCodes::QUERY_CACHE_USED_WITH_SYSTEM_TABLE,\n+                                \"The query result was not cached because the query contains a system table.\"\n+                                \" Use setting `query_cache_system_table_handling = 'save'` or `= 'ignore'` to cache the query result regardless or to omit caching\");\n+\n+                        if ((!ast_contains_nondeterministic_functions || nondeterministic_function_handling == QueryCacheNondeterministicFunctionHandling::Save)\n+                            && (!ast_contains_system_tables || system_table_handling == QueryCacheSystemTableHandling::Save))\n                         {\n                             QueryCache::Key key(\n                                 ast, res.pipeline.getHeader(),\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02494_query_cache_eligible_queries.sql b/tests/queries/0_stateless/02494_query_cache_eligible_queries.sql\nindex 5c45ee8aedd4..f7ddb8f8bda3 100644\n--- a/tests/queries/0_stateless/02494_query_cache_eligible_queries.sql\n+++ b/tests/queries/0_stateless/02494_query_cache_eligible_queries.sql\n@@ -7,6 +7,7 @@ DROP TABLE IF EXISTS eligible_test2;\n \n -- enable query cache session-wide but also force it individually in each of below statements\n SET use_query_cache = true;\n+SET query_cache_system_table_handling = 'save';\n \n -- check that SELECT statements create entries in the query cache ...\n SELECT 1 SETTINGS use_query_cache = true;\ndiff --git a/tests/queries/0_stateless/02494_query_cache_explain.sql b/tests/queries/0_stateless/02494_query_cache_explain.sql\nindex d12938181c2e..bf376b47fdb0 100644\n--- a/tests/queries/0_stateless/02494_query_cache_explain.sql\n+++ b/tests/queries/0_stateless/02494_query_cache_explain.sql\n@@ -2,6 +2,7 @@\n -- Tag no-parallel: Messes with internal cache\n \n SET allow_experimental_analyzer = 1;\n+SET query_cache_system_table_handling = 'save';\n \n SYSTEM DROP QUERY CACHE;\n \ndiff --git a/tests/queries/0_stateless/02494_query_cache_sparse_columns.sql b/tests/queries/0_stateless/02494_query_cache_sparse_columns.sql\nindex 4344d139d60b..6266996ac2eb 100644\n--- a/tests/queries/0_stateless/02494_query_cache_sparse_columns.sql\n+++ b/tests/queries/0_stateless/02494_query_cache_sparse_columns.sql\n@@ -12,11 +12,10 @@ SYSTEM STOP MERGES t_cache_sparse;\n INSERT INTO t_cache_sparse SELECT number, number FROM numbers(10000);\n INSERT INTO t_cache_sparse SELECT number, 0 FROM numbers(10000);\n \n-SET use_query_cache = 1;\n SET max_threads = 1;\n \n-SELECT v FROM t_cache_sparse FORMAT Null;\n-SELECT v FROM t_cache_sparse FORMAT Null;\n+SELECT v FROM t_cache_sparse SETTINGS use_query_cache = 1, max_threads = 1 FORMAT Null;\n+SELECT v FROM t_cache_sparse SETTINGS use_query_cache = 1, max_threads = 1 FORMAT Null;\n SELECT count() FROM system.query_cache WHERE query LIKE 'SELECT v FROM t_cache_sparse%';\n \n DROP TABLE t_cache_sparse;\ndiff --git a/tests/queries/0_stateless/02494_query_cache_system_tables.reference b/tests/queries/0_stateless/02494_query_cache_system_tables.reference\nnew file mode 100644\nindex 000000000000..e41e365766e5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_system_tables.reference\n@@ -0,0 +1,13 @@\n+The Default for query_cache_system_table_handling is = throw\n+0\n+Check behavior of query_cache_system_table_handling = throw\n+0\n+Check behavior of query_cache_system_table_handling = save\n+0\n+1\n+Check behavior of query_cache_system_table_handling = ignore\n+0\n+0\n+Other tests\n+0\n+0\ndiff --git a/tests/queries/0_stateless/02494_query_cache_system_tables.sql b/tests/queries/0_stateless/02494_query_cache_system_tables.sql\nnew file mode 100644\nindex 000000000000..7c9f01c4e91f\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_system_tables.sql\n@@ -0,0 +1,64 @@\n+-- Tags: no-parallel\n+-- Tag no-parallel: Messes with internal cache\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT 'The Default for query_cache_system_table_handling is = throw';\n+-- Test that the query cache rejects queries that involve system tables.\n+SELECT * FROM system.one SETTINGS use_query_cache = 1; -- { serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+SELECT count(*) FROM system.query_cache;\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT 'Check behavior of query_cache_system_table_handling = throw';\n+-- Test that the query cache rejects queries that involve system tables.\n+SELECT * FROM system.one SETTINGS use_query_cache = 1, query_cache_system_table_handling = 'throw'; -- { serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+SELECT count(*) FROM system.query_cache;\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT 'Check behavior of query_cache_system_table_handling = save';\n+-- Test that the query cache saves the result of queries that involve system tables.\n+SELECT * FROM system.one SETTINGS use_query_cache = 1, query_cache_system_table_handling = 'save';\n+SELECT count(*) FROM system.query_cache;\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT 'Check behavior of query_cache_system_table_handling = ignore';\n+-- Test that the query cache ignores the result of queries that involve system tables.\n+SELECT * FROM system.one SETTINGS use_query_cache = 1, query_cache_system_table_handling = 'ignore';\n+SELECT count(*) FROM system.query_cache;\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+SELECT 'Other tests';\n+\n+-- Edge case which doesn't work well due to conceptual reasons (QueryCache is AST-based), test it anyways to have it documented.\n+USE system;\n+SELECT * FROM one SETTINGS use_query_cache = 1; -- doesn't throw but should\n+\n+-- This query uses system.zero internally. Since the query cache works at AST level it does not \"see' system.zero and must not complain.\n+SELECT * SETTINGS use_query_cache = 1;\n+\n+-- information_schema is also treated as a system table\n+SELECT * FROM information_schema.tables SETTINGS use_query_cache = 1; -- { serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+SELECT * FROM INFORMATION_SCHEMA.TABLES SETTINGS use_query_cache = 1; -- { serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+\n+-- System tables can be \"hidden\" inside e.g. table functions\n+SELECT * FROM clusterAllReplicas('test_shard_localhost', system.one) SETTINGS use_query_cache = 1; -- {serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+SELECT * FROM clusterAllReplicas('test_shard_localhost', 'system.one') SETTINGS use_query_cache = 1; -- {serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+\n+-- Criminal edge case that a user creates a table named \"system\". The query cache must not reject queries against it.\n+DROP TABLE IF EXISTS system;\n+CREATE TABLE system (c UInt64) ENGINE = Memory;\n+SElECT * FROM system SETTINGS use_query_cache = 1;\n+DROP TABLE system;\n+\n+-- But queries against system.system are rejected.\n+DROP TABLE IF EXISTS system.system;\n+CREATE TABLE system.system (c UInt64) ENGINE = Memory;\n+SElECT * FROM system.system SETTINGS use_query_cache = 1; -- { serverError QUERY_CACHE_USED_WITH_SYSTEM_TABLE }\n+DROP TABLE system.system;\n+\n+-- Cleanup\n+SYSTEM DROP QUERY CACHE;\n",
  "problem_statement": "Query cache must know which system tables are deterministic and which ones are not\n**How to reproduce**\r\n\r\n```\r\nSET use_query_cache=true;\r\n\r\nSELECT * FROM system.processes; -- (A)\r\n\r\nSELECT * FROM system.processes; -- (B) Note that this SELECT shows the same information as (A) -\r\n                                -- for example query id and so on - instead of the actual information\r\n                                -- about processes\r\n```\r\n\r\nThe issue happens because the first result of the query `SELECT * FROM system.processes` is cached in the query cache and then used the second time. The issue was found in https://github.com/ClickHouse/ClickHouse/pull/59041.\r\n\r\nSo we need to make the code understand that any select from `system.processes` must not be cached. And for other system tables which are known to non-deterministic it's the same.\n",
  "hints_text": "Currently we have function [isDeterministic()](https://github.com/ClickHouse/ClickHouse/blob/0791c75315f6ac50ec38f3f884f32ad1157f4f8f/src/Functions/IFunction.h#L228) only for functions, and not for storages. To handle this case correctly we need to give a function like `isDeterministic()` to storages too. Some storages are known to be deterministic (`system.one`, `system.numbers`, `system.build_options`, etc.), and some storages are either known to be non-deterministic (`system.settings`, `system.tables`, etc.), and for some storages it's unknown. If it's unknow we can treat such storages as non-deterministic too.\r\n\r\nSo if only deterministic storages are used in a query, then it's ok to store the query in the query cache.\r\nIf at least one non-deterministic storage is used in a query, then we need to check a setting like `query_cache_nondeterministic_function_handling` but for storages to decide what to do.\nThe surprising behavior is at least [documented](https://clickhouse.com/docs/en/operations/query-cache):\r\n\r\n> \"[...]It is also possible to enable caching at user or profile level (e.g. via SET use_query_cache = true) but one should keep in mind that all SELECT queries including monitoring or debugging queries to system tables may return cached results then. [...]\"\r\n\r\nbut you are right that a distinction between deterministic/non-deterministic storages would be better.",
  "created_at": "2024-04-07T11:17:43Z"
}