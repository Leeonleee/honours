{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21246,
  "instance_id": "ClickHouse__ClickHouse-21246",
  "issue_numbers": [
    "21170",
    "20876"
  ],
  "base_commit": "11f2a271a20664eab916af4dd08f13c7b765f04c",
  "patch": "diff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\nindex 59fcff619361..62dc843f9826 100644\n--- a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n@@ -24,110 +24,8 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int UNION_ALL_RESULT_STRUCTURES_MISMATCH;\n-    extern const int EXPECTED_ALL_OR_DISTINCT;\n }\n \n-struct CustomizeASTSelectWithUnionQueryNormalize\n-{\n-    using TypeToVisit = ASTSelectWithUnionQuery;\n-\n-    const UnionMode & union_default_mode;\n-\n-    static void getSelectsFromUnionListNode(ASTPtr & ast_select, ASTs & selects)\n-    {\n-        if (auto * inner_union = ast_select->as<ASTSelectWithUnionQuery>())\n-        {\n-            for (auto & child : inner_union->list_of_selects->children)\n-                getSelectsFromUnionListNode(child, selects);\n-\n-            return;\n-        }\n-\n-        selects.push_back(std::move(ast_select));\n-    }\n-\n-    void visit(ASTSelectWithUnionQuery & ast, ASTPtr &) const\n-    {\n-        auto & union_modes = ast.list_of_modes;\n-        ASTs selects;\n-        auto & select_list = ast.list_of_selects->children;\n-\n-        int i;\n-        for (i = union_modes.size() - 1; i >= 0; --i)\n-        {\n-            /// Rewrite UNION Mode\n-            if (union_modes[i] == ASTSelectWithUnionQuery::Mode::Unspecified)\n-            {\n-                if (union_default_mode == UnionMode::ALL)\n-                    union_modes[i] = ASTSelectWithUnionQuery::Mode::ALL;\n-                else if (union_default_mode == UnionMode::DISTINCT)\n-                    union_modes[i] = ASTSelectWithUnionQuery::Mode::DISTINCT;\n-                else\n-                    throw Exception(\n-                        \"Expected ALL or DISTINCT in SelectWithUnion query, because setting (union_default_mode) is empty\",\n-                        DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);\n-            }\n-\n-            if (union_modes[i] == ASTSelectWithUnionQuery::Mode::ALL)\n-            {\n-                if (auto * inner_union = select_list[i + 1]->as<ASTSelectWithUnionQuery>())\n-                {\n-                    /// Inner_union is an UNION ALL list, just lift up\n-                    for (auto child = inner_union->list_of_selects->children.rbegin();\n-                         child != inner_union->list_of_selects->children.rend();\n-                         ++child)\n-                        selects.push_back(std::move(*child));\n-                }\n-                else\n-                    selects.push_back(std::move(select_list[i + 1]));\n-            }\n-            /// flatten all left nodes and current node to a UNION DISTINCT list\n-            else if (union_modes[i] == ASTSelectWithUnionQuery::Mode::DISTINCT)\n-            {\n-                auto distinct_list = std::make_shared<ASTSelectWithUnionQuery>();\n-                distinct_list->list_of_selects = std::make_shared<ASTExpressionList>();\n-                distinct_list->children.push_back(distinct_list->list_of_selects);\n-\n-                for (int j = 0; j <= i + 1; ++j)\n-                {\n-                    getSelectsFromUnionListNode(select_list[j], distinct_list->list_of_selects->children);\n-                }\n-\n-                distinct_list->union_mode = ASTSelectWithUnionQuery::Mode::DISTINCT;\n-                distinct_list->is_normalized = true;\n-                selects.push_back(std::move(distinct_list));\n-                break;\n-            }\n-        }\n-\n-        /// No UNION DISTINCT or only one child in select_list\n-        if (i == -1)\n-        {\n-            if (auto * inner_union = select_list[0]->as<ASTSelectWithUnionQuery>())\n-            {\n-                /// Inner_union is an UNION ALL list, just lift it up\n-                for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();\n-                     ++child)\n-                    selects.push_back(std::move(*child));\n-            }\n-            else\n-                selects.push_back(std::move(select_list[0]));\n-        }\n-\n-        // reverse children list\n-        std::reverse(selects.begin(), selects.end());\n-\n-        ast.is_normalized = true;\n-        ast.union_mode = ASTSelectWithUnionQuery::Mode::ALL;\n-\n-        ast.list_of_selects->children = std::move(selects);\n-    }\n-};\n-\n-/// We need normalize children first, so we should visit AST tree bottom up\n-using CustomizeASTSelectWithUnionQueryNormalizeVisitor\n-    = InDepthNodeVisitor<OneTypeMatcher<CustomizeASTSelectWithUnionQueryNormalize>, false>;\n-\n InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(\n     const ASTPtr & query_ptr_, const Context & context_, const SelectQueryOptions & options_, const Names & required_result_column_names)\n     : IInterpreterUnionOrSelectQuery(query_ptr_, context_, options_)\n@@ -138,21 +36,6 @@ InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(\n     if (options.subquery_depth == 0 && (settings.limit > 0 || settings.offset > 0))\n         settings_limit_offset_needed = true;\n \n-    /// Normalize AST Tree\n-    if (!ast->is_normalized)\n-    {\n-        CustomizeASTSelectWithUnionQueryNormalizeVisitor::Data union_default_mode{settings.union_default_mode};\n-        CustomizeASTSelectWithUnionQueryNormalizeVisitor(union_default_mode).visit(query_ptr);\n-\n-        /// After normalization, if it only has one ASTSelectWithUnionQuery child,\n-        /// we can lift it up, this can reduce one unnecessary recursion later.\n-        if (ast->list_of_selects->children.size() == 1 && ast->list_of_selects->children.at(0)->as<ASTSelectWithUnionQuery>())\n-        {\n-            query_ptr = std::move(ast->list_of_selects->children.at(0));\n-            ast = query_ptr->as<ASTSelectWithUnionQuery>();\n-        }\n-    }\n-\n     size_t num_children = ast->list_of_selects->children.size();\n     if (!num_children)\n         throw Exception(\"Logical error: no children in ASTSelectWithUnionQuery\", ErrorCodes::LOGICAL_ERROR);\ndiff --git a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp\nnew file mode 100644\nindex 000000000000..d65755f98baa\n--- /dev/null\n+++ b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp\n@@ -0,0 +1,116 @@\n+#include <Interpreters/NormalizeSelectWithUnionQueryVisitor.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Common/typeid_cast.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int EXPECTED_ALL_OR_DISTINCT;\n+}\n+\n+void NormalizeSelectWithUnionQueryMatcher::getSelectsFromUnionListNode(ASTPtr & ast_select, ASTs & selects)\n+{\n+    if (auto * inner_union = ast_select->as<ASTSelectWithUnionQuery>())\n+    {\n+        for (auto & child : inner_union->list_of_selects->children)\n+            getSelectsFromUnionListNode(child, selects);\n+\n+        return;\n+        }\n+\n+        selects.push_back(ast_select);\n+}\n+\n+void NormalizeSelectWithUnionQueryMatcher::visit(ASTPtr & ast, Data & data)\n+{\n+    if (auto * select_union = ast->as<ASTSelectWithUnionQuery>())\n+        visit(*select_union, data);\n+}\n+\n+void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Data & data)\n+{\n+    auto & union_modes = ast.list_of_modes;\n+    ASTs selects;\n+    auto & select_list = ast.list_of_selects->children;\n+\n+    int i;\n+    for (i = union_modes.size() - 1; i >= 0; --i)\n+    {\n+        /// Rewrite UNION Mode\n+        if (union_modes[i] == ASTSelectWithUnionQuery::Mode::Unspecified)\n+        {\n+            if (data.union_default_mode == UnionMode::ALL)\n+                union_modes[i] = ASTSelectWithUnionQuery::Mode::ALL;\n+            else if (data.union_default_mode == UnionMode::DISTINCT)\n+                union_modes[i] = ASTSelectWithUnionQuery::Mode::DISTINCT;\n+            else\n+                throw Exception(\n+                    \"Expected ALL or DISTINCT in SelectWithUnion query, because setting (union_default_mode) is empty\",\n+                    DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);\n+        }\n+\n+        if (union_modes[i] == ASTSelectWithUnionQuery::Mode::ALL)\n+        {\n+            if (auto * inner_union = select_list[i + 1]->as<ASTSelectWithUnionQuery>();\n+                inner_union && inner_union->union_mode == ASTSelectWithUnionQuery::Mode::ALL)\n+            {\n+                /// Inner_union is an UNION ALL list, just lift up\n+                for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();\n+                     ++child)\n+                    selects.push_back(*child);\n+            }\n+            else\n+                selects.push_back(select_list[i + 1]);\n+        }\n+        /// flatten all left nodes and current node to a UNION DISTINCT list\n+        else if (union_modes[i] == ASTSelectWithUnionQuery::Mode::DISTINCT)\n+        {\n+            auto distinct_list = std::make_shared<ASTSelectWithUnionQuery>();\n+            distinct_list->list_of_selects = std::make_shared<ASTExpressionList>();\n+            distinct_list->children.push_back(distinct_list->list_of_selects);\n+\n+            for (int j = 0; j <= i + 1; ++j)\n+            {\n+                getSelectsFromUnionListNode(select_list[j], distinct_list->list_of_selects->children);\n+            }\n+\n+            distinct_list->union_mode = ASTSelectWithUnionQuery::Mode::DISTINCT;\n+            distinct_list->is_normalized = true;\n+            selects.push_back(std::move(distinct_list));\n+            break;\n+        }\n+    }\n+\n+    /// No UNION DISTINCT or only one child in select_list\n+    if (i == -1)\n+    {\n+        if (auto * inner_union = select_list[0]->as<ASTSelectWithUnionQuery>();\n+            inner_union && inner_union->union_mode == ASTSelectWithUnionQuery::Mode::ALL)\n+        {\n+            /// Inner_union is an UNION ALL list, just lift it up\n+            for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();\n+                 ++child)\n+                selects.push_back(*child);\n+        }\n+        else\n+            selects.push_back(select_list[0]);\n+    }\n+\n+    /// Just one union type child, lift it up\n+    if (selects.size() == 1 && selects[0]->as<ASTSelectWithUnionQuery>())\n+    {\n+        ast = *(selects[0]->as<ASTSelectWithUnionQuery>());\n+        return;\n+    }\n+\n+    // reverse children list\n+    std::reverse(selects.begin(), selects.end());\n+\n+    ast.is_normalized = true;\n+    ast.union_mode = ASTSelectWithUnionQuery::Mode::ALL;\n+\n+    ast.list_of_selects->children = std::move(selects);\n+}\n+}\ndiff --git a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h\nnew file mode 100644\nindex 000000000000..cec2e4265e22\n--- /dev/null\n+++ b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h\n@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <unordered_set>\n+\n+#include <Parsers/IAST.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+\n+#include <Core/Settings.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+\n+namespace DB\n+{\n+\n+class ASTFunction;\n+\n+class NormalizeSelectWithUnionQueryMatcher\n+{\n+public:\n+    struct Data\n+    {\n+        const UnionMode & union_default_mode;\n+    };\n+\n+    static void getSelectsFromUnionListNode(ASTPtr & ast_select, ASTs & selects);\n+\n+    static void visit(ASTPtr & ast, Data &);\n+    static void visit(ASTSelectWithUnionQuery &, Data &);\n+    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }\n+};\n+\n+/// We need normalize children first, so we should visit AST tree bottom up\n+using NormalizeSelectWithUnionQueryVisitor\n+    = InDepthNodeVisitor<NormalizeSelectWithUnionQueryMatcher, false>;\n+}\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex d786e1146beb..1a0aa031d6f8 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -39,16 +39,17 @@\n #include <Storages/StorageInput.h>\n \n #include <Access/EnabledQuota.h>\n+#include <Interpreters/ApplyWithGlobalVisitor.h>\n+#include <Interpreters/Context.h>\n #include <Interpreters/InterpreterFactory.h>\n-#include <Interpreters/ProcessList.h>\n+#include <Interpreters/InterpreterSetQuery.h>\n+#include <Interpreters/NormalizeSelectWithUnionQueryVisitor.h>\n #include <Interpreters/OpenTelemetrySpanLog.h>\n+#include <Interpreters/ProcessList.h>\n #include <Interpreters/QueryLog.h>\n-#include <Interpreters/InterpreterSetQuery.h>\n-#include <Interpreters/ApplyWithGlobalVisitor.h>\n #include <Interpreters/ReplaceQueryParameterVisitor.h>\n #include <Interpreters/SelectQueryOptions.h>\n #include <Interpreters/executeQuery.h>\n-#include <Interpreters/Context.h>\n #include <Common/ProfileEvents.h>\n \n #include <Common/SensitiveDataMasker.h>\n@@ -472,9 +473,12 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         if (settings.enable_global_with_statement)\n         {\n             ApplyWithGlobalVisitor().visit(ast);\n-            query = serializeAST(*ast);\n         }\n \n+        /// Normalize SelectWithUnionQuery\n+        NormalizeSelectWithUnionQueryVisitor::Data data{context.getSettingsRef().union_default_mode};\n+        NormalizeSelectWithUnionQueryVisitor{data}.visit(ast);\n+\n         /// Check the limits.\n         checkASTSizeLimits(*ast, settings);\n \ndiff --git a/src/Interpreters/ya.make b/src/Interpreters/ya.make\nindex 879333db507f..3eab077df864 100644\n--- a/src/Interpreters/ya.make\n+++ b/src/Interpreters/ya.make\n@@ -111,6 +111,7 @@ SRCS(\n     MetricLog.cpp\n     MutationsInterpreter.cpp\n     MySQL/InterpretersMySQLDDLQuery.cpp\n+    NormalizeSelectWithUnionQueryVisitor.cpp\n     NullableUtils.cpp\n     OpenTelemetrySpanLog.cpp\n     OptimizeIfChains.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01732_explain_syntax_union_query.reference b/tests/queries/0_stateless/01732_explain_syntax_union_query.reference\nnew file mode 100644\nindex 000000000000..fe5eb01a7ed8\n--- /dev/null\n+++ b/tests/queries/0_stateless/01732_explain_syntax_union_query.reference\n@@ -0,0 +1,66 @@\n+SELECT 1\n+UNION ALL\n+SELECT 1\n+UNION ALL\n+SELECT 1\n+UNION ALL\n+SELECT 1\n+UNION ALL\n+SELECT 1\n+ \n+SELECT 1\n+UNION ALL\n+(\n+    SELECT 1\n+    UNION DISTINCT\n+    SELECT 1\n+    UNION DISTINCT\n+    SELECT 1\n+)\n+UNION ALL\n+SELECT 1\n+ \n+SELECT x\n+FROM \n+(\n+    SELECT 1 AS x\n+    UNION ALL\n+    (\n+        SELECT 1\n+        UNION DISTINCT\n+        SELECT 1\n+        UNION DISTINCT\n+        SELECT 1\n+    )\n+    UNION ALL\n+    SELECT 1\n+)\n+ \n+SELECT x\n+FROM \n+(\n+    SELECT 1 AS x\n+    UNION ALL\n+    SELECT 1\n+    UNION ALL\n+    SELECT 1\n+)\n+ \n+SELECT 1\n+UNION DISTINCT\n+SELECT 1\n+UNION DISTINCT\n+SELECT 1\n+ \n+SELECT 1\n+ \n+\n+(\n+    SELECT 1\n+    UNION DISTINCT\n+    SELECT 1\n+    UNION DISTINCT\n+    SELECT 1\n+)\n+UNION ALL\n+SELECT 1\ndiff --git a/tests/queries/0_stateless/01732_explain_syntax_union_query.sql b/tests/queries/0_stateless/01732_explain_syntax_union_query.sql\nnew file mode 100644\nindex 000000000000..0dd1e19e7652\n--- /dev/null\n+++ b/tests/queries/0_stateless/01732_explain_syntax_union_query.sql\n@@ -0,0 +1,86 @@\n+EXPLAIN SYNTAX\n+SELECT 1\n+UNION ALL\n+(\n+    SELECT 1\n+    UNION ALL\n+    (\n+        SELECT 1\n+        UNION ALL\n+        SELECT 1\n+    )\n+    UNION ALL\n+    SELECT 1\n+);\n+\n+SELECT ' ';\n+\n+EXPLAIN SYNTAX\n+SELECT 1\n+UNION ALL\n+(\n+    SELECT 1\n+    UNION DISTINCT\n+    (\n+        SELECT 1\n+        UNION ALL\n+        SELECT 1\n+    )\n+    UNION ALL\n+    SELECT 1\n+);\n+\n+SELECT ' ';\n+\n+EXPLAIN SYNTAX\n+SELECT x\n+FROM\n+(\n+    SELECT 1 AS x\n+    UNION ALL\n+    (\n+        SELECT 1\n+        UNION DISTINCT\n+        (\n+            SELECT 1\n+            UNION ALL\n+            SELECT 1\n+        )\n+        UNION ALL\n+        SELECT 1\n+    )\n+);\n+\n+SELECT ' ';\n+\n+EXPLAIN SYNTAX\n+SELECT x\n+FROM \n+(\n+    SELECT 1 AS x\n+    UNION ALL\n+    (\n+        SELECT 1\n+        UNION ALL\n+        SELECT 1\n+    )\n+);\n+\n+SELECT ' ';\n+\n+EXPLAIN SYNTAX\n+SELECT 1\n+UNION ALL\n+SELECT 1\n+UNION DISTINCT\n+SELECT 1;\n+\n+SELECT ' ';\n+\n+EXPLAIN SYNTAX\n+(((((((((((((((SELECT 1)))))))))))))));\n+\n+SELECT ' ';\n+\n+EXPLAIN SYNTAX\n+(((((((((((((((SELECT 1 UNION DISTINCT SELECT 1))) UNION DISTINCT SELECT 1)))) UNION ALL SELECT 1))))))));\n",
  "problem_statement": "panic when A union B union all C\n**Describe the bug**\r\n1. execute SQL: `select 1 from a union select 1 from b union all select 1 from c`\r\n2. server panic\r\n\r\n**Does it reproduce on recent release?**\r\n* 21.3.1.1\r\n* 21.2.2.8\r\n\r\n**Expected behavior**\r\nSQL should error with message: \"Expected ALL or DISTINCT in SelectWithUnion query, because setting (union_default_mode) is empty: While processing SELECT 1 FROM a UNION  SELECT 1 FROM b UNION ALL SELECT 1 FROM c\"\r\n\r\n**Error message and/or stacktrace**\r\n\r\n```\r\n2021.02.25 15:18:36.291248 [ 46895 ] {} <Fatal> BaseDaemon: ########################################\r\n2021.02.25 15:18:36.291294 [ 46895 ] {} <Fatal> BaseDaemon: (version 21.2.2.8 (official build), build id: 67D2DA03ADA750F18CEB331C65F50D0F56E33713) (from thread 78379) (no query) Received signal Segmentation fault (11)\r\n2021.02.25 15:18:36.291323 [ 46895 ] {} <Fatal> BaseDaemon: Address: NULL pointer. Access: read. Address not mapped to object.\r\n2021.02.25 15:18:36.291339 [ 46895 ] {} <Fatal> BaseDaemon: Stack trace: 0x11451fff 0x114434a8 0x1148b1bc 0xed45ba5 0xed4408f 0xeb56650 0xeed0c9c 0xeecf7fc 0xf5ca265 0xf5d9ee9 0x11b76baf 0x11b785c1 0x11caf669 0x11cab4ca 0x7f80b67126db 0x7f80b643b71f\r\n2021.02.25 15:18:36.298150 [ 46895 ] {} <Fatal> BaseDaemon: 2. DB::ASTSelectWithUnionQuery::formatQueryImpl(DB::IAST::FormatSettings const&, DB::IAST::FormatState&, DB::IAST::FormatStateStacked) const @ 0x11451fff in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.300165 [ 46895 ] {} <Fatal> BaseDaemon: 3. DB::ASTQueryWithOutput::formatImpl(DB::IAST::FormatSettings const&, DB::IAST::FormatState&, DB::IAST::FormatStateStacked) const @ 0x114434a8 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.307065 [ 46895 ] {} <Fatal> BaseDaemon: 4. DB::IAST::formatForErrorMessage() const @ 0x1148b1bc in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.311723 [ 46895 ] {} <Fatal> BaseDaemon: 5. DB::InDepthNodeVisitor<DB::OneTypeMatcher<DB::CustomizeASTSelectWithUnionQueryNormalize, &(DB::NeedChild::all(std::__1::shared_ptr<DB::IAST> const&, std::__1::shared_ptr<DB::IAST> const&)), std::__1::shared_ptr<DB::IAST> >, false, std::__1::shared_ptr<DB::IAST> >::visit(std::__1::shared_ptr<DB::IAST>&) @ 0xed45ba5 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.311758 [ 46895 ] {} <Fatal> BaseDaemon: 6. DB::InterpreterSelectWithUnionQuery::InterpreterSelectWithUnionQuery(std::__1::shared_ptr<DB::IAST> const&, DB::Context const&, DB::SelectQueryOptions const&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&) @ 0xed4408f in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.311777 [ 46895 ] {} <Fatal> BaseDaemon: 7. DB::InterpreterFactory::get(std::__1::shared_ptr<DB::IAST>&, DB::Context&, DB::SelectQueryOptions const&) @ 0xeb56650 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.314890 [ 46895 ] {} <Fatal> BaseDaemon: 8. DB::executeQueryImpl(char const*, char const*, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool, DB::ReadBuffer*) @ 0xeed0c9c in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.327946 [ 46895 ] {} <Fatal> BaseDaemon: 9. DB::executeQuery(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, DB::Context&, bool, DB::QueryProcessingStage::Enum, bool) @ 0xeecf7fc in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.330944 [ 46895 ] {} <Fatal> BaseDaemon: 10. DB::TCPHandler::runImpl() @ 0xf5ca265 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.333015 [ 46895 ] {} <Fatal> BaseDaemon: 11. DB::TCPHandler::run() @ 0xf5d9ee9 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.342141 [ 46895 ] {} <Fatal> BaseDaemon: 12. Poco::Net::TCPServerConnection::start() @ 0x11b76baf in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.342165 [ 46895 ] {} <Fatal> BaseDaemon: 13. Poco::Net::TCPServerDispatcher::run() @ 0x11b785c1 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.342447 [ 46895 ] {} <Fatal> BaseDaemon: 14. Poco::PooledThread::run() @ 0x11caf669 in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.342672 [ 46895 ] {} <Fatal> BaseDaemon: 15. Poco::ThreadImpl::runnableEntry(void*) @ 0x11cab4ca in /usr/lib/debug/.build-id/67/d2da03ada750f18ceb331c65f50d0f56e33713.debug\r\n2021.02.25 15:18:36.342689 [ 46895 ] {} <Fatal> BaseDaemon: 16. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2021.02.25 15:18:36.342785 [ 46895 ] {} <Fatal> BaseDaemon: 17. /build/glibc-S9d2JN/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97: __GI___clone @ 0x12171f in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n2021.02.25 15:18:36.433212 [ 46895 ] {} <Fatal> BaseDaemon: Checksum of the binary: 3B52BD94C585A17D2C45E5ABAABC8124, integrity check passed.\r\n2021.02.25 15:20:09.800886 [ 78267 ] {} <Fatal> Application: Child process was terminated by signal 11.\r\n```\nEXPLAIN SYNTAX + UNION DISTINCT in subquery crash\nHow to reproduce:\r\n\r\n```sql\r\nEXPLAIN SYNTAX\r\nSELECT x\r\nFROM \r\n(\r\n    SELECT 1 AS x\r\n    UNION DISTINCT\r\n    SELECT 1\r\n)\r\n\r\nQuery id: e777bc02-5d1b-4d49-ba89-4ebe31172387\r\n\r\n\r\nException on client:\r\nCode: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000\r\n\r\n```\r\n\n",
  "hints_text": "\n",
  "created_at": "2021-02-26T12:11:50Z",
  "modified_files": [
    "src/Interpreters/InterpreterSelectWithUnionQuery.cpp",
    "b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp",
    "b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h",
    "src/Interpreters/executeQuery.cpp",
    "src/Interpreters/ya.make"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01732_explain_syntax_union_query.reference",
    "b/tests/queries/0_stateless/01732_explain_syntax_union_query.sql"
  ]
}