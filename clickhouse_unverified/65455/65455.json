{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 65455,
  "instance_id": "ClickHouse__ClickHouse-65455",
  "issue_numbers": [
    "52756"
  ],
  "base_commit": "762c91a0736402d7bdb92e2f7e8be2390c6ad880",
  "patch": "diff --git a/src/Functions/array/arrayAggregation.cpp b/src/Functions/array/arrayAggregation.cpp\nindex 03aa5fb9086f..adb1bb707d88 100644\n--- a/src/Functions/array/arrayAggregation.cpp\n+++ b/src/Functions/array/arrayAggregation.cpp\n@@ -1,5 +1,7 @@\n #include <base/defines.h>\n \n+#include <Columns/IColumn.h>\n+#include <Columns/ColumnConst.h>\n #include <Columns/ColumnArray.h>\n #include <Columns/ColumnDecimal.h>\n #include <Columns/ColumnsNumber.h>\n@@ -102,6 +104,11 @@ struct ArrayAggregateImpl\n \n     static DataTypePtr getReturnType(const DataTypePtr & expression_return, const DataTypePtr & /*array_element*/)\n     {\n+        if (aggregate_operation == AggregateOperation::max || aggregate_operation == AggregateOperation::min)\n+        {\n+            return expression_return;\n+        }\n+\n         DataTypePtr result;\n \n         auto call = [&](const auto & types)\n@@ -133,31 +140,6 @@ struct ArrayAggregateImpl\n                     return true;\n                 }\n             }\n-            else if constexpr (aggregate_operation == AggregateOperation::max || aggregate_operation == AggregateOperation::min)\n-            {\n-                if constexpr (IsDataTypeDate<DataType>)\n-                {\n-                    result = std::make_shared<DataType>();\n-\n-                    return true;\n-                }\n-                else if constexpr (!IsDataTypeDecimal<DataType>)\n-                {\n-                    std::string timezone = getDateTimeTimezone(*expression_return);\n-                    result = std::make_shared<DataTypeDateTime>(timezone);\n-\n-                    return true;\n-                }\n-                else\n-                {\n-                    std::string timezone = getDateTimeTimezone(*expression_return);\n-                    UInt32 scale = getDecimalScale(*expression_return);\n-                    result = std::make_shared<DataTypeDateTime64>(scale, timezone);\n-\n-                    return true;\n-                }\n-            }\n-\n             return false;\n         };\n \n@@ -378,6 +360,47 @@ struct ArrayAggregateImpl\n \n     static ColumnPtr execute(const ColumnArray & array, ColumnPtr mapped)\n     {\n+        if constexpr (aggregate_operation == AggregateOperation::max || aggregate_operation == AggregateOperation::min)\n+        {\n+            MutableColumnPtr res;\n+            const auto & column = array.getDataPtr();\n+            const ColumnConst * const_column = checkAndGetColumn<ColumnConst>(&*column);\n+            if (const_column)\n+            {\n+                res = const_column->getDataColumn().cloneEmpty();\n+            }\n+            else\n+            {\n+                res = column->cloneEmpty();\n+            }\n+            const IColumn::Offsets & offsets = array.getOffsets();\n+            size_t pos = 0;\n+            for (const auto & offset : offsets)\n+            {\n+                if (offset == pos)\n+                {\n+                    res->insertDefault();\n+                    continue;\n+                }\n+                size_t current_max_or_min_index = pos;\n+                ++pos;\n+                for (; pos < offset; ++pos)\n+                {\n+                    int compare_result = column->compareAt(pos, current_max_or_min_index, *column, 1);\n+                    if (aggregate_operation == AggregateOperation::max && compare_result > 0)\n+                    {\n+                        current_max_or_min_index = pos;\n+                    }\n+                    else if (aggregate_operation == AggregateOperation::min && compare_result < 0)\n+                    {\n+                        current_max_or_min_index = pos;\n+                    }\n+                }\n+                res->insert((*column)[current_max_or_min_index]);\n+            }\n+            return res;\n+        }\n+\n         const IColumn::Offsets & offsets = array.getOffsets();\n         ColumnPtr res;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01602_array_aggregation.reference b/tests/queries/0_stateless/01602_array_aggregation.reference\nindex ec8a08384015..bce8ac88c97c 100644\n--- a/tests/queries/0_stateless/01602_array_aggregation.reference\n+++ b/tests/queries/0_stateless/01602_array_aggregation.reference\n@@ -2,6 +2,10 @@ Array min \t1\n Array max \t6\n Array sum \t21\n Array avg \t3.5\n+Array min :\n+[1]\n+Array max :\n+[3]\n Table array int min\n 1\n 0\ndiff --git a/tests/queries/0_stateless/01602_array_aggregation.sql b/tests/queries/0_stateless/01602_array_aggregation.sql\nindex 7c0f6eb8267d..d8be9eb82f2a 100644\n--- a/tests/queries/0_stateless/01602_array_aggregation.sql\n+++ b/tests/queries/0_stateless/01602_array_aggregation.sql\n@@ -3,6 +3,12 @@ SELECT 'Array max ', (arrayMax(array(1,2,3,4,5,6)));\n SELECT 'Array sum ', (arraySum(array(1,2,3,4,5,6)));\n SELECT 'Array avg ', (arrayAvg(array(1,2,3,4,5,6)));\n \n+SELECT 'Array min :';\n+SELECT arrayMin([[3], [1], [2]]);\n+\n+SELECT 'Array max :';\n+SELECT arrayMax([[3], [1], [2]]);\n+\n DROP TABLE IF EXISTS test_aggregation;\n CREATE TABLE test_aggregation (x Array(Int)) ENGINE=TinyLog;\n \n",
  "problem_statement": "arrayMin/arrayMax should have a generic specialization\n**Use case**\r\n\r\n```\r\nmilovidov-desktop :) SELECT arrayMin([3, 1, 2])\r\n\r\nSELECT arrayMin([3, 1, 2])\r\n\r\nQuery id: 9bf45956-442f-47a6-af83-74f40361cb66\r\n\r\n\u250c\u2500arrayMin([3, 1, 2])\u2500\u2510\r\n\u2502                   1 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec. \r\n\r\nmilovidov-desktop :) SELECT arrayMin([[3], [1], [2]])\r\n\r\nSELECT arrayMin([[3], [1], [2]])\r\n\r\nQuery id: 1d8d574a-ce78-45a0-9bba-a5b80110dbc2\r\n\r\n\r\n0 rows in set. Elapsed: 0.001 sec. \r\n\r\nReceived exception from server (version 23.8.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: array aggregation function cannot be performed on type Array(UInt8): While processing arrayMin([[3], [1], [2]]). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n\r\nmilovidov-desktop :) SELECT arrayReduce('min', [[3], [1], [2]])\r\n\r\nSELECT arrayReduce('min', [[3], [1], [2]])\r\n\r\nQuery id: f7053fe6-4639-4a2f-85bc-acc10592d8ab\r\n\r\n\u250c\u2500arrayReduce('min', [[3], [1], [2]])\u2500\u2510\r\n\u2502 [1]                                 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.001 sec.\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\n`arrayMin/Max` should be applicable to all data types that have `IColumn::compareAt`.\r\n\n",
  "hints_text": "Hey! I can work on this with @sachinthaker\n@lohpaul9 thank you!\nHey @alexey-milovidov , just to let you know - I'm still working on this but have been a little busy with things while familiarizing with the code base, will take a little bit more time\nDo we still need to implement this feature? I think I can give it a try.  \r\n: ) @alexey-milovidov \r\n\nYes, it is still relevant:\r\n\r\n```\r\nmilovidov@milovidov-pc:~/work/ClickHouse$ ch\r\nClickHouse local version 24.6.1.1.\r\n\r\nmilovidov-pc :) SELECT arrayMin([[3], [1], [2]])\r\n\r\nSELECT arrayMin([[3], [1], [2]])\r\n\r\nQuery id: 3dccf305-20be-471b-99db-d9ebe2625d97\r\n\r\n\r\nElapsed: 0.016 sec. \r\n\r\nReceived exception:\r\nCode: 43. DB::Exception: array aggregation function cannot be performed on type Array(UInt8): In scope SELECT arrayMin([[3], [1], [2]]). (ILLEGAL_TYPE_OF_ARGUMENT)\r\n\r\nmilovidov-pc :)\r\n```\r\n\r\nLet's try!",
  "created_at": "2024-06-19T13:00:59Z",
  "modified_files": [
    "src/Functions/array/arrayAggregation.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01602_array_aggregation.reference",
    "tests/queries/0_stateless/01602_array_aggregation.sql"
  ]
}