{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55146,
  "instance_id": "ClickHouse__ClickHouse-55146",
  "issue_numbers": [
    "51753"
  ],
  "base_commit": "465962df7f87c241e2da20a3317d1b028d0bbf07",
  "patch": "diff --git a/src/IO/ReadHelpers.cpp b/src/IO/ReadHelpers.cpp\nindex fa2400a08a58..ad41e8afd65e 100644\n--- a/src/IO/ReadHelpers.cpp\n+++ b/src/IO/ReadHelpers.cpp\n@@ -1139,7 +1139,7 @@ template void readDateTextFallback<void>(LocalDate &, ReadBuffer &);\n template bool readDateTextFallback<bool>(LocalDate &, ReadBuffer &);\n \n \n-template <typename ReturnType>\n+template <typename ReturnType, bool dt64_mode>\n ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const DateLUTImpl & date_lut)\n {\n     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n@@ -1155,11 +1155,30 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n     char * s_pos = s;\n \n     /** Read characters, that could represent unix timestamp.\n-      * Only unix timestamp of at least 5 characters is supported.\n+      * Only unix timestamp of at least 5 characters is supported by default, exception is thrown for a shorter one\n+      * (unless parsing a string like '1.23' or '-12': there is no ambiguity, it is a DT64 timestamp).\n       * Then look at 5th character. If it is a number - treat whole as unix timestamp.\n       * If it is not a number - then parse datetime in YYYY-MM-DD hh:mm:ss or YYYY-MM-DD format.\n       */\n \n+    int negative_multiplier = 1;\n+\n+    if (!buf.eof() && *buf.position() == '-')\n+    {\n+        if constexpr (dt64_mode)\n+        {\n+            negative_multiplier = -1;\n+            ++buf.position();\n+        }\n+        else\n+        {\n+            if constexpr (throw_exception)\n+                throw ParsingException(ErrorCodes::CANNOT_PARSE_DATETIME, \"Cannot parse DateTime\");\n+            else\n+                return false;\n+        }\n+    }\n+\n     /// A piece similar to unix timestamp, maybe scaled to subsecond precision.\n     while (s_pos < s + date_time_broken_down_length && !buf.eof() && isNumericASCII(*buf.position()))\n     {\n@@ -1169,7 +1188,8 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n     }\n \n     /// 2015-01-01 01:02:03 or 2015-01-01\n-    if (s_pos == s + 4 && !buf.eof() && !isNumericASCII(*buf.position()))\n+    /// if negative, it is a timestamp with no ambiguity\n+    if (negative_multiplier == 1 && s_pos == s + 4 && !buf.eof() && !isNumericASCII(*buf.position()))\n     {\n         const auto already_read_length = s_pos - s;\n         const size_t remaining_date_size = date_broken_down_length - already_read_length;\n@@ -1220,27 +1240,34 @@ ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const D\n     }\n     else\n     {\n-        if (s_pos - s >= 5)\n+        datetime = 0;\n+        bool too_short = s_pos - s <= 4;\n+\n+        if (!too_short || dt64_mode)\n         {\n             /// Not very efficient.\n-            datetime = 0;\n             for (const char * digit_pos = s; digit_pos < s_pos; ++digit_pos)\n                 datetime = datetime * 10 + *digit_pos - '0';\n         }\n-        else\n+        datetime *= negative_multiplier;\n+\n+        if (too_short && negative_multiplier != -1)\n         {\n             if constexpr (throw_exception)\n-                throw ParsingException(ErrorCodes::CANNOT_PARSE_DATETIME, \"Cannot parse datetime\");\n+                throw ParsingException(ErrorCodes::CANNOT_PARSE_DATETIME, \"Cannot parse DateTime\");\n             else\n                 return false;\n         }\n+\n     }\n \n     return ReturnType(true);\n }\n \n-template void readDateTimeTextFallback<void>(time_t &, ReadBuffer &, const DateLUTImpl &);\n-template bool readDateTimeTextFallback<bool>(time_t &, ReadBuffer &, const DateLUTImpl &);\n+template void readDateTimeTextFallback<void, false>(time_t &, ReadBuffer &, const DateLUTImpl &);\n+template void readDateTimeTextFallback<void, true>(time_t &, ReadBuffer &, const DateLUTImpl &);\n+template bool readDateTimeTextFallback<bool, false>(time_t &, ReadBuffer &, const DateLUTImpl &);\n+template bool readDateTimeTextFallback<bool, true>(time_t &, ReadBuffer &, const DateLUTImpl &);\n \n \n void skipJSONField(ReadBuffer & buf, StringRef name_of_field)\ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex 415f4e100d2c..40f812050dbd 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -909,15 +909,28 @@ inline T parseFromString(std::string_view str)\n }\n \n \n-template <typename ReturnType = void>\n+template <typename ReturnType = void, bool dt64_mode = false>\n ReturnType readDateTimeTextFallback(time_t & datetime, ReadBuffer & buf, const DateLUTImpl & date_lut);\n \n /** In YYYY-MM-DD hh:mm:ss or YYYY-MM-DD format, according to specified time zone.\n   * As an exception, also supported parsing of unix timestamp in form of decimal number.\n   */\n-template <typename ReturnType = void>\n+template <typename ReturnType = void, bool dt64_mode = false>\n inline ReturnType readDateTimeTextImpl(time_t & datetime, ReadBuffer & buf, const DateLUTImpl & date_lut)\n {\n+    static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n+\n+    if constexpr (!dt64_mode)\n+    {\n+        if (!buf.eof() && !isNumericASCII(*buf.position()))\n+        {\n+            if constexpr (throw_exception)\n+                throw ParsingException(ErrorCodes::CANNOT_PARSE_DATETIME, \"Cannot parse datetime\");\n+            else\n+                return false;\n+        }\n+    }\n+\n     /// Optimistic path, when whole value is in buffer.\n     const char * s = buf.position();\n \n@@ -965,19 +978,30 @@ inline ReturnType readDateTimeTextImpl(time_t & datetime, ReadBuffer & buf, cons\n             return readIntTextImpl<time_t, ReturnType, ReadIntTextCheckOverflow::CHECK_OVERFLOW>(datetime, buf);\n     }\n     else\n-        return readDateTimeTextFallback<ReturnType>(datetime, buf, date_lut);\n+        return readDateTimeTextFallback<ReturnType, dt64_mode>(datetime, buf, date_lut);\n }\n \n template <typename ReturnType>\n inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, ReadBuffer & buf, const DateLUTImpl & date_lut)\n {\n-    time_t whole;\n-    if (!readDateTimeTextImpl<bool>(whole, buf, date_lut))\n+    time_t whole = 0;\n+    bool is_negative_timestamp = (!buf.eof() && *buf.position() == '-');\n+    bool is_empty = buf.eof();\n+\n+    if (!is_empty)\n     {\n-        return ReturnType(false);\n+        try\n+        {\n+            readDateTimeTextImpl<ReturnType, true>(whole, buf, date_lut);\n+        }\n+        catch (const DB::ParsingException & exception)\n+        {\n+            if (buf.eof() || *buf.position() != '.')\n+                throw exception;\n+        }\n     }\n \n-    int negative_multiplier = 1;\n+    int negative_fraction_multiplier = 1;\n \n     DB::DecimalUtils::DecimalComponents<DateTime64> components{static_cast<DateTime64::NativeType>(whole), 0};\n \n@@ -1005,18 +1029,18 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n         while (!buf.eof() && isNumericASCII(*buf.position()))\n             ++buf.position();\n \n-        /// Fractional part (subseconds) is treated as positive by users\n-        /// (as DateTime64 itself is a positive, although underlying decimal is negative)\n-        /// setting fractional part to be negative when whole is 0 results in wrong value,\n-        /// so we multiply result by -1.\n-        if (components.whole < 0 && components.fractional != 0)\n+        /// Fractional part (subseconds) is treated as positive by users, but represented as a negative number.\n+        /// E.g. `1925-12-12 13:14:15.123` is represented internally as timestamp `-1390214744.877`.\n+        /// Thus need to convert <negative_timestamp>.<fractional> to <negative_timestamp+1>.<1-0.<fractional>>\n+        /// Also, setting fractional part to be negative when whole is 0 results in wrong value, in this case multiply result by -1.\n+        if (!is_negative_timestamp && components.whole < 0 && components.fractional != 0)\n         {\n             const auto scale_multiplier = DecimalUtils::scaleMultiplier<DateTime64::NativeType>(scale);\n             ++components.whole;\n             components.fractional = scale_multiplier - components.fractional;\n             if (!components.whole)\n             {\n-                negative_multiplier = -1;\n+                negative_fraction_multiplier = -1;\n             }\n         }\n     }\n@@ -1032,13 +1056,13 @@ inline ReturnType readDateTimeTextImpl(DateTime64 & datetime64, UInt32 scale, Re\n     bool is_ok = true;\n     if constexpr (std::is_same_v<ReturnType, void>)\n     {\n-        datetime64 = DecimalUtils::decimalFromComponents<DateTime64>(components, scale) * negative_multiplier;\n+        datetime64 = DecimalUtils::decimalFromComponents<DateTime64>(components, scale) * negative_fraction_multiplier;\n     }\n     else\n     {\n         is_ok = DecimalUtils::tryGetDecimalFromComponents<DateTime64>(components, scale, datetime64);\n         if (is_ok)\n-            datetime64 *= negative_multiplier;\n+            datetime64 *= negative_fraction_multiplier;\n     }\n \n     return ReturnType(is_ok);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\nindex 63d9a11daaad..3e8597178736 100644\n--- a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n+++ b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n@@ -5,7 +5,7 @@ WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materiali\n WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = materialize(S); -- {serverError 43}\n WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 43}\n \n-SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 53} -- invalid DateTime64 string\n+SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 41} -- invalid DateTime64 string\n SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333';\n \n SELECT 'in SELECT';\ndiff --git a/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference b/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference\nindex ecea0a9f69f4..c07ef5ca6311 100644\n--- a/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference\n+++ b/tests/queries/0_stateless/01702_toDateTime_from_string_clamping.reference\n@@ -1,4 +1,4 @@\n-1940-10-09 21:13:17.6\n+1940-10-09 21:13:16.4\n 2284-06-04 23:46:43.6\n 2299-12-31 23:40:00.1\n 1900-01-01 00:00:00.9\ndiff --git a/tests/queries/0_stateless/02373_datetime64_monotonicity.queries b/tests/queries/0_stateless/02373_datetime64_monotonicity.queries\nindex 212198c89de5..404e3391205b 100644\n--- a/tests/queries/0_stateless/02373_datetime64_monotonicity.queries\n+++ b/tests/queries/0_stateless/02373_datetime64_monotonicity.queries\n@@ -46,11 +46,11 @@ SELECT count() FROM dt64_monot_test WHERE toDateTime64(date_time,0) >= '2020-01-\n SELECT count() FROM dt64_monot_test WHERE toDateTime64(date_time,0) >= '2020-01-01 00:00:01.1' settings force_index_by_date = 1, force_primary_key = 1;\n \n create table dt64_monot_test_string(date_time String, x String) Engine=MergeTree order by date_time;\n-insert into dt64_monot_test_string select '2020-01-01 00:00', '' from numbers(1);\n-insert into dt64_monot_test_string select '2020-01-01 00:00:00.000000' , '' from numbers(10);\n+insert into dt64_monot_test_string select '2020-01-01 00:00:00.000000001', '' from numbers(1);\n+insert into dt64_monot_test_string select '2020-01-01 00:00:00.000', '' from numbers(10);\n \n-SELECT count() FROM dt64_monot_test_string WHERE toDateTime64(date_time,3) = '1970-01-01 00:00:00.000000000';\n-SELECT count() FROM dt64_monot_test_string WHERE toDateTime64(date_time,3) = '1970-01-01 00:00:00.000000001';\n+SELECT count() FROM dt64_monot_test_string WHERE toDateTime64(date_time,9) = '2020-01-01 00:00:00.000000000';\n+SELECT count() FROM dt64_monot_test_string WHERE toDateTime64(date_time,3) = '2020-01-01 00:00:00.000000001';\n SELECT count() FROM dt64_monot_test_string WHERE toDateTime64(date_time,9) = '2020-01-01 00:00:00';\n \n drop table dt64_monot_test;\ndiff --git a/tests/queries/0_stateless/02373_datetime64_monotonicity.reference b/tests/queries/0_stateless/02373_datetime64_monotonicity.reference\nindex d9c310bdbc9a..935ee685cc99 100644\n--- a/tests/queries/0_stateless/02373_datetime64_monotonicity.reference\n+++ b/tests/queries/0_stateless/02373_datetime64_monotonicity.reference\n@@ -17,8 +17,8 @@ Asia/Tehran\n 10\n 0\n 0\n-0\n-0\n+10\n+11\n 10\n \n UTC\n@@ -40,8 +40,8 @@ UTC\n 10\n 10\n 10\n-1\n-1\n+10\n+11\n 10\n \n Canada/Atlantic\n@@ -63,8 +63,8 @@ Canada/Atlantic\n 10\n 10\n 10\n-0\n-0\n+10\n+11\n 10\n \n Europe/Berlin\n@@ -86,7 +86,7 @@ Europe/Berlin\n 10\n 10\n 9\n-0\n-0\n+10\n+11\n 10\n \ndiff --git a/tests/queries/0_stateless/02889_datetime64_from_string.reference b/tests/queries/0_stateless/02889_datetime64_from_string.reference\nnew file mode 100644\nindex 000000000000..e6e2208ed4c1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02889_datetime64_from_string.reference\n@@ -0,0 +1,3 @@\n+1969-12-31 23:57:57.000\n+1970-01-01 00:00:23.900\n+1969-12-31 23:59:36.100\ndiff --git a/tests/queries/0_stateless/02889_datetime64_from_string.sql b/tests/queries/0_stateless/02889_datetime64_from_string.sql\nnew file mode 100644\nindex 000000000000..50c29de19bdd\n--- /dev/null\n+++ b/tests/queries/0_stateless/02889_datetime64_from_string.sql\n@@ -0,0 +1,5 @@\n+SELECT toDateTime64('-123', 3, 'UTC');    -- Allowed: no year starts with '-'\n+SELECT toDateTime64('23.9', 3, 'UTC');    -- Allowed: no year has a dot in notation\n+SELECT toDateTime64('-23.9', 3, 'UTC');   -- Allowed\n+\n+SELECT toDateTime64('1234', 3, 'UTC');    -- { serverError CANNOT_PARSE_DATETIME }\n",
  "problem_statement": "DateTime64 inconsistent parsing from String\nDateTime64 parsing goes wrong for string representing a number smaller than 10000:\r\n```\r\nselect toDateTime64('9999', 3)       -- returns 1970-01-01 00:00:00.000, but CANNOT_PARSE_DATETIME expected\r\nselect toDateTime64('10000', 3)     -- returns 1970-01-01 02:46:40.000 (expected)\r\n```\r\n\r\nHowever, DateTime doesn't have this:\r\n```\r\nselect toDateTime('9999');  -- { serverError CANNOT_PARSE_DATETIME } (expected)\r\nselect toDateTime('10000')              -- returns 1970-01-01 02:46:40 (expected)\r\n```\r\n\r\nSee [fiddle](https://fiddle.clickhouse.com/a9c8deb1-ee2c-48f6-8b1f-2480a9fb00f9).\r\n\r\n**Does it reproduce on recent release?**\r\nYes, on 23.6.1\r\nAlso happens on older versions, e.g. [22.6.7](https://fiddle.clickhouse.com/d5dfbf2c-9f5a-41ae-badb-648bfb0ca767)\r\n\r\n\r\n**Expected behavior**\r\n\r\nDateTime64 shall not silently produce wrong result. It shall throw exception like DateTime does.\r\n\r\nRelated to [these](https://github.com/ClickHouse/ClickHouse/issues/50868#issuecomment-1604947763) [two](https://github.com/ClickHouse/ClickHouse/issues/50868#issuecomment-1587324935) comments.\r\n\r\n#### Parts:\r\n- [x] fix parsing of decimal string numbers with short whole part (e.g. `'123.12'`) -- definitely no ambiguity here\r\n- [x] allow negative numbers in short strings for DT64 -- also no ambiguity\n",
  "hints_text": "I am already working on this, this is just to note the issue.\r\nWill introduce after the mentioned [issue](https://github.com/ClickHouse/ClickHouse/issues/50868) is fixed\nRelated #52089, but we want toDateTime('9999') to work \ud83d\ude22 \r\n@zvonand why `toDateTime('9999')` should throw exception? If `toDateTime(9999)` works then `toDateTIme('9999')` should also work?\n@canhld94 https://github.com/ClickHouse/ClickHouse/issues/52089#issuecomment-1634476558",
  "created_at": "2023-09-29T14:55:51Z"
}