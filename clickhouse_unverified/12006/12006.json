{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 12006,
  "instance_id": "ClickHouse__ClickHouse-12006",
  "issue_numbers": [
    "11369"
  ],
  "base_commit": "b4695846df5fc14068980960244f9ea67ada3faa",
  "patch": "diff --git a/src/Functions/GeoHash.cpp b/src/Functions/GeoHash.cpp\nindex e59cf160ce12..7fdeb52b15c9 100644\n--- a/src/Functions/GeoHash.cpp\n+++ b/src/Functions/GeoHash.cpp\n@@ -3,6 +3,7 @@\n #include <cassert>\n #include <Functions/GeoHash.h>\n \n+\n namespace DB\n {\n \n@@ -260,15 +261,21 @@ void geohashDecode(const char * encoded_string, size_t encoded_len, Float64 * lo\n     *latitude = decodeCoordinate(lat_encoded, LAT_MIN, LAT_MAX, singleCoordBitsPrecision(precision, LATITUDE));\n }\n \n-GeohashesInBoxPreparedArgs geohashesInBoxPrepare(Float64 longitude_min,\n-                                              Float64 latitude_min,\n-                                              Float64 longitude_max,\n-                                              Float64 latitude_max,\n-                                              uint8_t precision)\n+GeohashesInBoxPreparedArgs geohashesInBoxPrepare(\n+    Float64 longitude_min,\n+    Float64 latitude_min,\n+    Float64 longitude_max,\n+    Float64 latitude_max,\n+    uint8_t precision)\n {\n     precision = geohashPrecision(precision);\n \n-    if (longitude_max < longitude_min || latitude_max < latitude_min)\n+    if (longitude_max < longitude_min\n+        || latitude_max < latitude_min\n+        || std::isnan(longitude_min)\n+        || std::isnan(longitude_max)\n+        || std::isnan(latitude_min)\n+        || std::isnan(latitude_max))\n     {\n         return {};\n     }\n@@ -281,51 +288,50 @@ GeohashesInBoxPreparedArgs geohashesInBoxPrepare(Float64 longitude_min,\n     const auto lon_step = getSpan(precision, LONGITUDE);\n     const auto lat_step = getSpan(precision, LATITUDE);\n \n-    // align max to the right(or up) border of geohash grid cell to ensure that cell is in result.\n+    /// Align max to the right (or up) border of geohash grid cell to ensure that cell is in result.\n     Float64 lon_min = floor(longitude_min / lon_step) * lon_step;\n     Float64 lat_min = floor(latitude_min / lat_step) * lat_step;\n     Float64 lon_max = ceil(longitude_max / lon_step) * lon_step;\n     Float64 lat_max = ceil(latitude_max / lat_step) * lat_step;\n \n-    const auto lon_span = lon_max - lon_min;\n-    const auto lat_span = lat_max - lat_min;\n-    // in case of a very small (or zero) span, produce at least 1 item.\n-    const auto items_count = std::max(size_t{1}, static_cast<size_t>(ceil(lon_span/lon_step * lat_span/lat_step)));\n-\n-    return GeohashesInBoxPreparedArgs{\n-            items_count,\n-            precision,\n-            lon_min,\n-            lat_min,\n-            lon_max,\n-            lat_max,\n-            lon_step,\n-            lat_step\n+    UInt32 lon_items = (lon_max - lon_min) / lon_step;\n+    UInt32 lat_items = (lat_max - lat_min) / lat_step;\n+\n+    return GeohashesInBoxPreparedArgs\n+    {\n+        std::max<UInt64>(1, UInt64(lon_items) * lat_items),\n+        lon_items,\n+        lat_items,\n+        lon_min,\n+        lat_min,\n+        lon_step,\n+        lat_step,\n+        precision\n     };\n }\n \n UInt64 geohashesInBox(const GeohashesInBoxPreparedArgs & args, char * out)\n {\n-    if (args.items_count == 0\n-            || args.precision == 0\n-            || args.precision > MAX_PRECISION\n-            || args.latitude_min > args.latitude_max\n-            || args.longitude_min > args.longitude_max\n-            || args.longitude_step <= 0\n-            || args.latitude_step <= 0)\n+    if (args.precision == 0\n+        || args.precision > MAX_PRECISION\n+        || args.longitude_step <= 0\n+        || args.latitude_step <= 0)\n     {\n         return 0;\n     }\n \n     UInt64 items = 0;\n-    for (auto lon = args.longitude_min; lon < args.longitude_max; lon += args.longitude_step) // NOLINT\n+    for (size_t i = 0; i < args.longitude_items; ++i)\n     {\n-        for (auto lat = args.latitude_min; lat < args.latitude_max; lat += args.latitude_step) // NOLINT\n+        for (size_t j = 0; j < args.latitude_items; ++j)\n         {\n-            assert(items <= args.items_count);\n+            size_t length = geohashEncodeImpl(\n+                args.longitude_min + args.longitude_step * i,\n+                args.latitude_min + args.latitude_step * j,\n+                args.precision,\n+                out);\n \n-            size_t l = geohashEncodeImpl(lon, lat, args.precision, out);\n-            out += l;\n+            out += length;\n             *out = '\\0';\n             ++out;\n \n@@ -335,8 +341,8 @@ UInt64 geohashesInBox(const GeohashesInBoxPreparedArgs & args, char * out)\n \n     if (items == 0)\n     {\n-        size_t l = geohashEncodeImpl(args.longitude_min, args.latitude_min, args.precision, out);\n-        out += l;\n+        size_t length = geohashEncodeImpl(args.longitude_min, args.latitude_min, args.precision, out);\n+        out += length;\n         *out = '\\0';\n         ++out;\n \ndiff --git a/src/Functions/GeoHash.h b/src/Functions/GeoHash.h\nindex e1e44a9d9087..105384d714c2 100644\n--- a/src/Functions/GeoHash.h\n+++ b/src/Functions/GeoHash.h\n@@ -23,15 +23,17 @@ std::vector<std::pair<Float64, Float64>> geohashCoverBox(\n struct GeohashesInBoxPreparedArgs\n {\n     UInt64 items_count = 0;\n-    uint8_t precision = 0;\n+\n+    UInt32 longitude_items = 0;\n+    UInt32 latitude_items = 0;\n \n     Float64 longitude_min = 0.0;\n     Float64 latitude_min = 0.0;\n-    Float64 longitude_max = 0.0;\n-    Float64 latitude_max = 0.0;\n \n     Float64 longitude_step = 0.0;\n     Float64 latitude_step = 0.0;\n+\n+    uint8_t precision = 0;\n };\n \n GeohashesInBoxPreparedArgs geohashesInBoxPrepare(\ndiff --git a/src/Functions/geohashesInBox.cpp b/src/Functions/geohashesInBox.cpp\nindex 6bf0e5a82cd0..a3f7f8bd58e9 100644\n--- a/src/Functions/geohashesInBox.cpp\n+++ b/src/Functions/geohashesInBox.cpp\n@@ -11,6 +11,7 @@\n #include <memory>\n #include <string>\n \n+\n namespace DB\n {\n \n@@ -121,9 +122,7 @@ class FunctionGeohashesInBox : public IFunction\n             geohashesInBox(prepared_args, out);\n \n             for (UInt64 i = 1; i <= prepared_args.items_count ; ++i)\n-            {\n                 res_strings_offsets.push_back(starting_offset + (prepared_args.precision + 1) * i);\n-            }\n             res_offsets.push_back((res_offsets.empty() ? 0 : res_offsets.back()) + prepared_args.items_count);\n         }\n         if (!res_strings_offsets.empty() && res_strings_offsets.back() != res_strings_chars.size())\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01351_geohash_assert.reference b/tests/queries/0_stateless/01351_geohash_assert.reference\nnew file mode 100644\nindex 000000000000..1f6205a79d4c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01351_geohash_assert.reference\n@@ -0,0 +1,1 @@\n+['7zz','ebp','ebr','ebx','ebz','ecp','ecr','ecx','ecz','efp','efr','efx','efz','egp','egr','egx','egz','eup','eur','eux','euz','evp','evr','evx','evz','eyp','eyr','eyx','eyz','ezp','ezr','ezx','ezz','gbp','gbr','gbx','gbz','gcp','gcr','gcx','gcz','gfp','gfr','gfx','gfz','ggp','ggr','ggx','ggz','gup','gur','gux','guz','gvp','gvr','gvx','gvz','gyp','gyr','gyx','gyz','gzp','gzr','gzx','gzz','kpb','s00','s02','s08','s0b','s10','s12','s18','s1b','s40','s42','s48','s4b','s50','s52','s58','s5b','sh0','sh2','sh8','shb','sj0','sj2','sj8','sjb','sn0','sn2','sn8','snb','sp0','sp2','sp8','spb','u00','u02','u08','u0b','u10','u12','u18','u1b','u40','u42','u48','u4b','u50','u52','u58','u5b','uh0','uh2','uh8','uhb','uj0','uj2','uj8','ujb','un0','un2','un8','unb','up0','up2','up8','upb']\ndiff --git a/tests/queries/0_stateless/01351_geohash_assert.sql b/tests/queries/0_stateless/01351_geohash_assert.sql\nnew file mode 100644\nindex 000000000000..d364407fa29f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01351_geohash_assert.sql\n@@ -0,0 +1,1 @@\n+SELECT arraySort(geohashesInBox(-1., -1., 1., inf, 3));\n",
  "problem_statement": "DB::geohashesInBox(): Assertion `items <= args.items_count'\n```\r\nSELECT arraySort(geohashesInBox(-1., -1., 1., inf, 3))\r\n```\n",
  "hints_text": "@Enmk FYI\n> @Enmk FYI\r\n\r\ncould you please add a link to the test run ?\n> > @Enmk FYI\r\n> \r\n> could you please add a link to the test run ?\r\n\r\nIt's not a test run, I just found it locally with some experimental fuzzer I'm making. The query from the description should reproduce the problem.",
  "created_at": "2020-06-27T23:09:04Z",
  "modified_files": [
    "src/Functions/GeoHash.cpp",
    "src/Functions/GeoHash.h",
    "src/Functions/geohashesInBox.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01351_geohash_assert.reference",
    "b/tests/queries/0_stateless/01351_geohash_assert.sql"
  ]
}