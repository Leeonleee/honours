{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9223,
  "instance_id": "ClickHouse__ClickHouse-9223",
  "issue_numbers": [
    "9034"
  ],
  "base_commit": "a47c52a909f09de228722cfab384bcae79160836",
  "patch": "diff --git a/dbms/src/Storages/MergeTree/KeyCondition.cpp b/dbms/src/Storages/MergeTree/KeyCondition.cpp\nindex 4ce58c858099..f8c7db4a4230 100644\n--- a/dbms/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/dbms/src/Storages/MergeTree/KeyCondition.cpp\n@@ -264,6 +264,78 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n };\n \n \n+static const std::map<std::string, std::string> inverse_relations = {\n+        {\"equals\", \"notEquals\"},\n+        {\"notEquals\", \"equals\"},\n+        {\"less\", \"greaterOrEquals\"},\n+        {\"greaterOrEquals\", \"less\"},\n+        {\"greater\", \"lessOrEquals\"},\n+        {\"lessOrEquals\", \"greater\"},\n+        {\"in\", \"notIn\"},\n+        {\"notIn\", \"in\"},\n+        {\"like\", \"notLike\"},\n+        {\"notLike\", \"like\"},\n+        {\"empty\", \"notEmpty\"},\n+        {\"notEmpty\", \"empty\"},\n+};\n+\n+\n+bool isLogicalOperator(const String & func_name)\n+{\n+    return (func_name == \"and\" || func_name == \"or\" || func_name == \"not\" || func_name == \"indexHint\");\n+}\n+\n+/// The node can be one of:\n+///   - Logical operator (AND, OR, NOT and indexHint() - logical NOOP)\n+///   - An \"atom\" (relational operator, constant, expression)\n+///   - A logical constant expression\n+///   - Any other function\n+ASTPtr cloneASTWithInversionPushDown(const ASTPtr node, const bool need_inversion = false)\n+{\n+    const ASTFunction * func = node->as<ASTFunction>();\n+\n+    if (func && isLogicalOperator(func->name))\n+    {\n+        if (func->name == \"not\")\n+        {\n+            return cloneASTWithInversionPushDown(func->arguments->children.front(), !need_inversion);\n+        }\n+\n+        const auto result_node = makeASTFunction(func->name);\n+\n+        /// indexHint() is a special case - logical NOOP function\n+        if (result_node->name != \"indexHint\" && need_inversion)\n+        {\n+            result_node->name = (result_node->name == \"and\") ? \"or\" : \"and\";\n+        }\n+\n+        if (func->arguments)\n+        {\n+            for (const auto & child : func->arguments->children)\n+            {\n+                result_node->arguments->children.push_back(cloneASTWithInversionPushDown(child, need_inversion));\n+            }\n+        }\n+\n+        return result_node;\n+    }\n+\n+    const auto cloned_node = node->clone();\n+\n+    if (func && inverse_relations.find(func->name) != inverse_relations.cend())\n+    {\n+        if (need_inversion)\n+        {\n+            cloned_node->as<ASTFunction>()->name = inverse_relations.at(func->name);\n+        }\n+\n+        return cloned_node;\n+    }\n+\n+    return need_inversion ? makeASTFunction(\"not\", cloned_node) : cloned_node;\n+}\n+\n+\n inline bool Range::equals(const Field & lhs, const Field & rhs) { return applyVisitor(FieldVisitorAccurateEquals(), lhs, rhs); }\n inline bool Range::less(const Field & lhs, const Field & rhs) { return applyVisitor(FieldVisitorAccurateLess(), lhs, rhs); }\n \n@@ -345,21 +417,23 @@ KeyCondition::KeyCondition(\n       */\n     Block block_with_constants = getBlockWithConstants(query_info.query, query_info.syntax_analyzer_result, context);\n \n-    /// Trasform WHERE section to Reverse Polish notation\n-    const auto & select = query_info.query->as<ASTSelectQuery &>();\n-    if (select.where())\n-    {\n-        traverseAST(select.where(), context, block_with_constants);\n-\n-        if (select.prewhere())\n-        {\n-            traverseAST(select.prewhere(), context, block_with_constants);\n-            rpn.emplace_back(RPNElement::FUNCTION_AND);\n-        }\n-    }\n-    else if (select.prewhere())\n+    const ASTSelectQuery & select = query_info.query->as<ASTSelectQuery &>();\n+    if (select.where() || select.prewhere())\n     {\n-        traverseAST(select.prewhere(), context, block_with_constants);\n+        ASTPtr filter_query;\n+        if (select.where() && select.prewhere())\n+            filter_query = makeASTFunction(\"and\", select.where(), select.prewhere());\n+        else\n+            filter_query = select.where() ? select.where() : select.prewhere();\n+\n+        /** When non-strictly monotonic functions are employed in functional index (e.g. ORDER BY toStartOfHour(dateTime)),\n+          * the use of NOT operator in predicate will result in the indexing algorithm leave out some data.\n+          * This is caused by rewriting in KeyCondition::tryParseAtomFromAST of relational operators to less strict\n+          * when parsing the AST into internal RPN representation.\n+          * To overcome the problem, before parsing the AST we transform it to its semantically equivalent form where all NOT's\n+          * are pushed down and applied (when possible) to leaf nodes.\n+          */\n+        traverseAST(cloneASTWithInversionPushDown(filter_query), context, block_with_constants);\n     }\n     else\n     {\n@@ -432,9 +506,9 @@ void KeyCondition::traverseAST(const ASTPtr & node, const Context & context, Blo\n {\n     RPNElement element;\n \n-    if (auto * func = node->as<ASTFunction>())\n+    if (const auto * func = node->as<ASTFunction>())\n     {\n-        if (operatorFromAST(func, element))\n+        if (tryParseLogicalOperatorFromAST(func, element))\n         {\n             auto & args = func->arguments->children;\n             for (size_t i = 0, size = args.size(); i < size; ++i)\n@@ -452,7 +526,7 @@ void KeyCondition::traverseAST(const ASTPtr & node, const Context & context, Blo\n         }\n     }\n \n-    if (!atomFromAST(node, context, block_with_constants, element))\n+    if (!tryParseAtomFromAST(node, context, block_with_constants, element))\n     {\n         element.function = RPNElement::FUNCTION_UNKNOWN;\n     }\n@@ -680,7 +754,7 @@ static void castValueToType(const DataTypePtr & desired_type, Field & src_value,\n }\n \n \n-bool KeyCondition::atomFromAST(const ASTPtr & node, const Context & context, Block & block_with_constants, RPNElement & out)\n+bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, const Context & context, Block & block_with_constants, RPNElement & out)\n {\n     /** Functions < > = != <= >= in `notIn`, where one argument is a constant, and the other is one of columns of key,\n       *  or itself, wrapped in a chain of possibly-monotonic functions,\n@@ -768,7 +842,9 @@ bool KeyCondition::atomFromAST(const ASTPtr & node, const Context & context, Blo\n                     func_name = \"lessOrEquals\";\n                 else if (func_name == \"lessOrEquals\")\n                     func_name = \"greaterOrEquals\";\n-                else if (func_name == \"in\" || func_name == \"notIn\" || func_name == \"like\")\n+                else if (func_name == \"in\" || func_name == \"notIn\" ||\n+                         func_name == \"like\" || func_name == \"notLike\" ||\n+                         func_name == \"startsWith\")\n                 {\n                     /// \"const IN data_column\" doesn't make sense (unlike \"data_column IN const\")\n                     return false;\n@@ -809,7 +885,7 @@ bool KeyCondition::atomFromAST(const ASTPtr & node, const Context & context, Blo\n     return false;\n }\n \n-bool KeyCondition::operatorFromAST(const ASTFunction * func, RPNElement & out)\n+bool KeyCondition::tryParseLogicalOperatorFromAST(const ASTFunction * func, RPNElement & out)\n {\n     /// Functions AND, OR, NOT.\n     /** Also a special function `indexHint` - works as if instead of calling a function there are just parentheses\ndiff --git a/dbms/src/Storages/MergeTree/KeyCondition.h b/dbms/src/Storages/MergeTree/KeyCondition.h\nindex fd1d11c0ec80..004cfbc9ea8f 100644\n--- a/dbms/src/Storages/MergeTree/KeyCondition.h\n+++ b/dbms/src/Storages/MergeTree/KeyCondition.h\n@@ -369,8 +369,8 @@ class KeyCondition\n         BoolMask initial_mask) const;\n \n     void traverseAST(const ASTPtr & node, const Context & context, Block & block_with_constants);\n-    bool atomFromAST(const ASTPtr & node, const Context & context, Block & block_with_constants, RPNElement & out);\n-    bool operatorFromAST(const ASTFunction * func, RPNElement & out);\n+    bool tryParseAtomFromAST(const ASTPtr & node, const Context & context, Block & block_with_constants, RPNElement & out);\n+    bool tryParseLogicalOperatorFromAST(const ASTFunction * func, RPNElement & out);\n \n     /** Is node the key column\n       *  or expression in which column of key is wrapped by chain of functions,\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01083_functional_index_in_mergetree.reference b/dbms/tests/queries/0_stateless/01083_functional_index_in_mergetree.reference\nnew file mode 100644\nindex 000000000000..bff552df9916\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_functional_index_in_mergetree.reference\n@@ -0,0 +1,33 @@\n+TP1\n+7.51\n+7.42\n+7.41\n+7.42\n+7.41\n+7.42\n+7.41\n+7.42\n+7.41\n+7.51\n+TP2\n+7.42\n+7.41\n+7.42\n+7.51\n+7.42\n+7.41\n+7.51\n+7.51\n+TP3\n+7.42\n+7.41\n+7.51\n+TP4\n+7.42\n+7.41\n+7.42\n+7.42\n+7.41\n+TP5\n+7.41\n+7.51\ndiff --git a/dbms/tests/queries/0_stateless/01083_functional_index_in_mergetree.sql b/dbms/tests/queries/0_stateless/01083_functional_index_in_mergetree.sql\nnew file mode 100644\nindex 000000000000..d0fbf3356c8a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_functional_index_in_mergetree.sql\n@@ -0,0 +1,33 @@\n+SET max_threads = 1;\n+\n+CREATE TABLE IF NOT EXISTS functional_index_mergetree (x Float64) ENGINE = MergeTree ORDER BY round(x);\n+INSERT INTO functional_index_mergetree VALUES (7.42)(7.41)(7.51);\n+\n+SELECT 'TP1';\n+SELECT * FROM functional_index_mergetree WHERE x > 7.42;\n+SELECT * FROM functional_index_mergetree WHERE x < 7.49;\n+SELECT * FROM functional_index_mergetree WHERE x < 7.5;\n+\n+SELECT * FROM functional_index_mergetree WHERE NOT (NOT x < 7.49);\n+SELECT * FROM functional_index_mergetree WHERE NOT (NOT x < 7.5);\n+SELECT * FROM functional_index_mergetree WHERE NOT (NOT x > 7.42);\n+\n+SELECT 'TP2';\n+SELECT * FROM functional_index_mergetree WHERE NOT x > 7.49;\n+SELECT * FROM functional_index_mergetree WHERE NOT x < 7.42;\n+SELECT * FROM functional_index_mergetree WHERE NOT x < 7.41;\n+SELECT * FROM functional_index_mergetree WHERE NOT x < 7.5;\n+\n+SELECT 'TP3';\n+SELECT * FROM functional_index_mergetree WHERE x > 7.41 AND x < 7.51;\n+SELECT * FROM functional_index_mergetree WHERE NOT (x > 7.41 AND x < 7.51);\n+\n+SELECT 'TP4';\n+SELECT * FROM functional_index_mergetree WHERE NOT x < 7.41 AND NOT x > 7.49;\n+SELECT * FROM functional_index_mergetree WHERE NOT x < 7.42 AND NOT x > 7.42;\n+SELECT * FROM functional_index_mergetree WHERE (NOT x < 7.4) AND (NOT x > 7.49);\n+\n+SELECT 'TP5';\n+SELECT * FROM functional_index_mergetree WHERE NOT or(NOT x, toUInt64(x) AND NOT floor(x) > 6, x >= 7.42 AND round(x) <= 7);\n+\n+DROP TABLE functional_index_mergetree;\n",
  "problem_statement": "key condition negated incorrectly for monotonic functions\n**How to reproduce**\r\n```\r\n\r\nCREATE TABLE datetimeX\r\n(\r\n    `date` DateTime\r\n)\r\nENGINE = MergeTree\r\nORDER BY toStartOfHour(date);\r\n\r\nINSERT INTO datetimeX VALUES(toDateTime('2020-01-20 17:42:42'));\r\n\r\n\r\nSELECT *\r\nFROM datetimeX\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u2510\r\n\u2502 2020-01-20 17:42:42 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n1 rows in set. Elapsed: 0.007 sec.\r\n\r\n\r\nSELECT *\r\nFROM datetimeX\r\nWHERE \r\n    (date >= toDateTime('2020-01-20 17:00:00')) \r\nAND \r\n    (toStartOfHour(date) = toDateTime('2020-01-20 17:00:00'))\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u2510\r\n\u2502 2020-01-20 17:42:42 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n1 rows in set. Elapsed: 0.012 sec.\r\n\r\nSELECT *\r\nFROM datetimeX\r\nWHERE \r\n    (NOT (date < toDateTime('2020-01-20 17:00:00'))) \r\nAND \r\n    (toStartOfHour(date) = toDateTime('2020-01-20 17:00:00'))\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.011 sec.\r\n```\r\n\r\nCondition `(NOT (date < toDateTime('2020-01-20 17:00:00')))` is equal to `(date >= toDateTime('2020-01-20 17:00:00'))`, but we get different results. Looks like bug.\n",
  "hints_text": "Even simplier.\r\n```\r\n :) SELECT * from datetimeX where (NOT (date < toDateTime('2020-01-20 17:00:00')));\r\n\r\nSELECT *\r\nFROM datetimeX\r\nWHERE NOT (date < toDateTime('2020-01-20 17:00:00'))\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.009 sec. \r\n\r\nclick.sas.yp-c.yandex.net :) SELECT * from datetimeX where date >= toDateTime('2020-01-20 17:00:00');\r\n\r\nSELECT *\r\nFROM datetimeX\r\nWHERE date >= toDateTime('2020-01-20 17:00:00')\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u2510\r\n\u2502 2020-01-20 17:42:42 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.009 sec. \r\n```\n19.10.1.5  - works properly.\r\n19.11.2.7 - not. \nThe issue is in final mark.\r\nIt also works.\r\n```\r\nCREATE TABLE datetimeX (`date` DateTime) ENGINE = MergeTree ORDER BY toStartOfHour(date) settings write_final_mark=0;\r\nINSERT INTO datetimeX VALUES(toDateTime('2020-01-20 17:42:42'));\r\nSELECT * FROM datetimeX WHERE (date >= toDateTime('2020-01-20 17:00:00')) AND (toStartOfHour(date) = toDateTime('2020-01-20 17:00:00')) ;\r\nSELECT * FROM datetimeX WHERE (NOT (date < toDateTime('2020-01-20 17:00:00'))) AND (toStartOfHour(date) = toDateTime('2020-01-20 17:00:00'));\r\n```\nBut I'm not sure, that final mark is the original cause of the problem. It just adds another row to index and may be we have bug in index analyze in general case.\nYes, I was wrong about final mark.\r\nThis reproduces even on 18.1 (oldest version that I found on my laptop)\r\n```\r\nap11-nix :) CREATE TABLE datetimeX (`date` DateTime) ENGINE = MergeTree ORDER BY toStartOfHour(date) settings index_granularity=1\r\n\r\nap11-nix :) INSERT INTO datetimeX VALUES(toDateTime('2020-01-20 17:42:42')), (toDateTime('2020-01-20 17:42:43'));\r\n\r\nap11-nix :) SELECT * FROM datetimeX WHERE (NOT (date < toDateTime('2020-01-20 17:00:00')));\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u2510\r\n\u2502 2020-01-20 17:42:43 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.002 sec. \r\n\r\nap11-nix :) SELECT * FROM datetimeX WHERE (NOT (identity(date) < toDateTime('2020-01-20 17:00:00')));\r\n\r\n\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500date\u2500\u2510\r\n\u2502 2020-01-20 17:42:42 \u2502\r\n\u2502 2020-01-20 17:42:43 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n2 rows in set. Elapsed: 0.002 sec. \r\n\r\nap11-nix :) select version()\r\n\r\n\u250c\u2500version()\u2500\u2510\r\n\u2502 18.1.0    \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.001 sec.\r\n```\nSimplier:\r\n```\r\nCREATE TABLE roundX\r\n(\r\n    `value` Float64\r\n)\r\nENGINE = MergeTree\r\nORDER BY round(value)\r\n\r\nOk.\r\ninsert into roundX VALUES(7.42);\r\n\r\nOk.\r\n\r\n1 rows in set. Elapsed: 0.006 sec.\r\n\r\nSELECT *\r\nFROM roundX\r\nWHERE NOT (value < 7)\r\n\r\nOk.\r\n\r\n0 rows in set. Elapsed: 0.014 sec.\r\n\r\n\r\nSELECT *\r\nFROM roundX\r\nWHERE NOT (value > 7.43)\r\n\r\nOk.\r\n```\nIntroduced here https://github.com/ClickHouse/ClickHouse/pull/951.\nIt's also interesting that\r\n\r\n```\r\nCREATE TABLE roundX (value Decimal(18, 4)) ENGINE = MergeTree ORDER BY toDecimal32(round(value), 4);\r\n\r\nINSERT INTO roundX VALUES(toDecimal32(7.42, 4));\r\nSELECT * FROM roundX WHERE NOT (value < 7);\r\nSELECT * FROM roundX WHERE NOT (value > toDecimal32(7.43, 4));\r\n```\r\n\r\n```\r\n7.4200\r\n7.4200\r\n```\n@4ertus2 \r\n\r\nit's not. it does not use PK.\r\n```\r\n\r\nSET force_primary_key = 1;\r\n\r\nSELECT *\r\nFROM roundX\r\nWHERE NOT (value < 7);\r\n\r\nReceived exception from server (version 20.2.1):\r\nCode: 277. DB::Exception: Received from localhost:9000. DB::Exception: Primary key (toDecimal32(round(value), 4)) is not used and setting 'force_primary_key' is set..\r\n\r\n```\r\n\r\ntoDecimal probably is not monotonic because accepts String argument\n> toDecimal probably is not monotonic because accepts String argument\r\n\r\nIt looks like the right answer is monotonicity currently not defined for functions of several arguments even if all of them except one are constants.",
  "created_at": "2020-02-19T13:39:19Z"
}