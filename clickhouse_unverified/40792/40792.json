{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40792,
  "instance_id": "ClickHouse__ClickHouse-40792",
  "issue_numbers": [
    "39787"
  ],
  "base_commit": "d4a1b71b184a06f515fb3d8bb23f4c315528d815",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex af32c15a8678..2dd25feea8d8 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -554,7 +554,9 @@ static constexpr UInt64 operator\"\"_GiB(unsigned long long value)\n     M(UInt64, external_storage_connect_timeout_sec, DBMS_DEFAULT_CONNECT_TIMEOUT_SEC, \"Connect timeout in seconds. Now supported only for MySQL\", 0)  \\\n     M(UInt64, external_storage_rw_timeout_sec, DBMS_DEFAULT_RECEIVE_TIMEOUT_SEC, \"Read/write timeout in seconds. Now supported only for MySQL\", 0)  \\\n     \\\n-    M(UnionMode, union_default_mode, UnionMode::Unspecified, \"Set default Union Mode in SelectWithUnion query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without Union Mode will throw exception.\", 0) \\\n+    M(SetOperationMode, union_default_mode, SetOperationMode::Unspecified, \"Set default mode in UNION query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception.\", 0) \\\n+    M(SetOperationMode, intersect_default_mode, SetOperationMode::ALL, \"Set default mode in INTERSECT query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception.\", 0) \\\n+    M(SetOperationMode, except_default_mode, SetOperationMode::ALL, \"Set default mode in EXCEPT query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception.\", 0) \\\n     M(Bool, optimize_aggregators_of_group_by_keys, true, \"Eliminates min/max/any/anyLast aggregators of GROUP BY keys in SELECT section\", 0) \\\n     M(Bool, optimize_group_by_function_keys, true, \"Eliminates functions of other keys in GROUP BY section\", 0) \\\n     M(Bool, legacy_column_name_of_tuple_literal, false, \"List all names of element of large tuple literals in their column names instead of hash. This settings exists only for compatibility reasons. It makes sense to set to 'true', while doing rolling update of cluster from version lower than 21.7 to higher.\", 0) \\\ndiff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp\nindex 616026520dbc..daa678c01418 100644\n--- a/src/Core/SettingsEnums.cpp\n+++ b/src/Core/SettingsEnums.cpp\n@@ -114,10 +114,10 @@ IMPLEMENT_SETTING_MULTI_ENUM(MySQLDataTypesSupport, ErrorCodes::UNKNOWN_MYSQL_DA\n      {\"date2Date32\", MySQLDataTypesSupport::DATE2DATE32},\n      {\"date2String\", MySQLDataTypesSupport::DATE2STRING}})\n \n-IMPLEMENT_SETTING_ENUM(UnionMode, ErrorCodes::UNKNOWN_UNION,\n-    {{\"\",         UnionMode::Unspecified},\n-     {\"ALL\",      UnionMode::ALL},\n-     {\"DISTINCT\", UnionMode::DISTINCT}})\n+IMPLEMENT_SETTING_ENUM(SetOperationMode, ErrorCodes::UNKNOWN_UNION,\n+    {{\"\",         SetOperationMode::Unspecified},\n+     {\"ALL\",      SetOperationMode::ALL},\n+     {\"DISTINCT\", SetOperationMode::DISTINCT}})\n \n IMPLEMENT_SETTING_ENUM(DistributedDDLOutputMode, ErrorCodes::BAD_ARGUMENTS,\n     {{\"none\",         DistributedDDLOutputMode::NONE},\ndiff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h\nindex 308d53ff690b..518c626fcc01 100644\n--- a/src/Core/SettingsEnums.h\n+++ b/src/Core/SettingsEnums.h\n@@ -130,14 +130,14 @@ enum class MySQLDataTypesSupport\n \n DECLARE_SETTING_MULTI_ENUM(MySQLDataTypesSupport)\n \n-enum class UnionMode\n+enum class SetOperationMode\n {\n-    Unspecified = 0, // Query UNION without UnionMode will throw exception\n-    ALL, // Query UNION without UnionMode -> SELECT ... UNION ALL SELECT ...\n-    DISTINCT // Query UNION without UnionMode -> SELECT ... UNION DISTINCT SELECT ...\n+    Unspecified = 0, // Query UNION / EXCEPT / INTERSECT without SetOperationMode will throw exception\n+    ALL, // Query UNION / EXCEPT / INTERSECT without SetOperationMode -> SELECT ... UNION / EXCEPT / INTERSECT ALL SELECT ...\n+    DISTINCT // Query UNION / EXCEPT / INTERSECT without SetOperationMode -> SELECT ... UNION / EXCEPT / INTERSECT DISTINCT SELECT ...\n };\n \n-DECLARE_SETTING_ENUM(UnionMode)\n+DECLARE_SETTING_ENUM(SetOperationMode)\n \n enum class DistributedDDLOutputMode\n {\ndiff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp\nindex 7b6066575aee..1e1b22cb5e05 100644\n--- a/src/Interpreters/InterpreterInsertQuery.cpp\n+++ b/src/Interpreters/InterpreterInsertQuery.cpp\n@@ -346,7 +346,7 @@ BlockIO InterpreterInsertQuery::execute()\n                 const auto & union_modes = select_query.list_of_modes;\n \n                 /// ASTSelectWithUnionQuery is not normalized now, so it may pass some queries which can be Trivial select queries\n-                const auto mode_is_all = [](const auto & mode) { return mode == SelectUnionMode::ALL; };\n+                const auto mode_is_all = [](const auto & mode) { return mode == SelectUnionMode::UNION_ALL; };\n \n                 is_trivial_insert_select =\n                     std::all_of(union_modes.begin(), union_modes.end(), std::move(mode_is_all))\ndiff --git a/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp b/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp\nindex d6add3f77a9d..a134f7bb9138 100644\n--- a/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp\n@@ -4,11 +4,14 @@\n #include <Interpreters/InterpreterSelectQuery.h>\n #include <Parsers/ASTSelectIntersectExceptQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Processors/QueryPlan/DistinctStep.h>\n+#include <Processors/QueryPlan/ExpressionStep.h>\n #include <Processors/QueryPlan/IQueryPlanStep.h>\n #include <Processors/QueryPlan/IntersectOrExceptStep.h>\n+#include <Processors/QueryPlan/LimitStep.h>\n+#include <Processors/QueryPlan/OffsetStep.h>\n #include <Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h>\n #include <Processors/QueryPlan/QueryPlan.h>\n-#include <Processors/QueryPlan/ExpressionStep.h>\n #include <QueryPipeline/QueryPipelineBuilder.h>\n \n \n@@ -134,10 +137,29 @@ void InterpreterSelectIntersectExceptQuery::buildQueryPlan(QueryPlan & query_pla\n         data_streams[i] = plans[i]->getCurrentDataStream();\n     }\n \n-    auto max_threads = context->getSettingsRef().max_threads;\n+    const Settings & settings = context->getSettingsRef();\n+    auto max_threads = settings.max_threads;\n     auto step = std::make_unique<IntersectOrExceptStep>(std::move(data_streams), final_operator, max_threads);\n     query_plan.unitePlans(std::move(step), std::move(plans));\n \n+    const auto & query = query_ptr->as<ASTSelectIntersectExceptQuery &>();\n+    if (query.final_operator == ASTSelectIntersectExceptQuery::Operator::INTERSECT_DISTINCT\n+        || query.final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT)\n+    {\n+        /// Add distinct transform\n+        SizeLimits limits(settings.max_rows_in_distinct, settings.max_bytes_in_distinct, settings.distinct_overflow_mode);\n+\n+        auto distinct_step = std::make_unique<DistinctStep>(\n+            query_plan.getCurrentDataStream(),\n+            limits,\n+            0,\n+            result_header.getNames(),\n+            false,\n+            settings.optimize_distinct_in_order);\n+\n+        query_plan.addStep(std::move(distinct_step));\n+    }\n+\n     addAdditionalPostFilter(query_plan);\n     query_plan.addInterpreterContext(context);\n }\ndiff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\nindex 87a182e70aeb..a679b17a5bdd 100644\n--- a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp\n@@ -317,13 +317,13 @@ void InterpreterSelectWithUnionQuery::buildQueryPlan(QueryPlan & query_plan)\n             data_streams[i] = plans[i]->getCurrentDataStream();\n         }\n \n-        auto max_threads = context->getSettingsRef().max_threads;\n+        auto max_threads = settings.max_threads;\n         auto union_step = std::make_unique<UnionStep>(std::move(data_streams), max_threads);\n \n         query_plan.unitePlans(std::move(union_step), std::move(plans));\n \n         const auto & query = query_ptr->as<ASTSelectWithUnionQuery &>();\n-        if (query.union_mode == SelectUnionMode::DISTINCT)\n+        if (query.union_mode == SelectUnionMode::UNION_DISTINCT)\n         {\n             /// Add distinct transform\n             SizeLimits limits(settings.max_rows_in_distinct, settings.max_bytes_in_distinct, settings.distinct_overflow_mode);\ndiff --git a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp\nindex 364828e6126b..40c42f7728e4 100644\n--- a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp\n+++ b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp\n@@ -59,22 +59,22 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,\n             continue;\n \n         /// Rewrite UNION Mode\n-        if (union_modes[i] == SelectUnionMode::Unspecified)\n+        if (union_modes[i] == SelectUnionMode::UNION_DEFAULT)\n         {\n-            if (data.union_default_mode == UnionMode::ALL)\n-                union_modes[i] = SelectUnionMode::ALL;\n-            else if (data.union_default_mode == UnionMode::DISTINCT)\n-                union_modes[i] = SelectUnionMode::DISTINCT;\n+            if (data.union_default_mode == SetOperationMode::ALL)\n+                union_modes[i] = SelectUnionMode::UNION_ALL;\n+            else if (data.union_default_mode == SetOperationMode::DISTINCT)\n+                union_modes[i] = SelectUnionMode::UNION_DISTINCT;\n             else\n                 throw Exception(\n                     \"Expected ALL or DISTINCT in SelectWithUnion query, because setting (union_default_mode) is empty\",\n                     DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);\n         }\n \n-        if (union_modes[i] == SelectUnionMode::ALL)\n+        if (union_modes[i] == SelectUnionMode::UNION_ALL)\n         {\n             if (auto * inner_union = select_list[i + 1]->as<ASTSelectWithUnionQuery>();\n-                inner_union && inner_union->union_mode == SelectUnionMode::ALL)\n+                inner_union && inner_union->union_mode == SelectUnionMode::UNION_ALL)\n             {\n                 /// Inner_union is an UNION ALL list, just lift up\n                 for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();\n@@ -85,7 +85,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,\n                 selects.push_back(select_list[i + 1]);\n         }\n         /// flatten all left nodes and current node to a UNION DISTINCT list\n-        else if (union_modes[i] == SelectUnionMode::DISTINCT)\n+        else if (union_modes[i] == SelectUnionMode::UNION_DISTINCT)\n         {\n             auto distinct_list = std::make_shared<ASTSelectWithUnionQuery>();\n             distinct_list->list_of_selects = std::make_shared<ASTExpressionList>();\n@@ -96,7 +96,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,\n                 getSelectsFromUnionListNode(select_list[j], distinct_list->list_of_selects->children);\n             }\n \n-            distinct_list->union_mode = SelectUnionMode::DISTINCT;\n+            distinct_list->union_mode = SelectUnionMode::UNION_DISTINCT;\n             distinct_list->is_normalized = true;\n             selects.push_back(std::move(distinct_list));\n             distinct_found = true;\n@@ -113,7 +113,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,\n     if (!distinct_found)\n     {\n         if (auto * inner_union = select_list[0]->as<ASTSelectWithUnionQuery>();\n-            inner_union && inner_union->union_mode == SelectUnionMode::ALL)\n+            inner_union && inner_union->union_mode == SelectUnionMode::UNION_ALL)\n         {\n             /// Inner_union is an UNION ALL list, just lift it up\n             for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();\n@@ -136,7 +136,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,\n     std::reverse(selects.begin(), selects.end());\n \n     ast.is_normalized = true;\n-    ast.union_mode = SelectUnionMode::ALL;\n+    ast.union_mode = SelectUnionMode::UNION_ALL;\n     ast.set_of_modes = std::move(current_set_of_modes);\n \n     ast.list_of_selects->children = std::move(selects);\ndiff --git a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h\nindex d035e90f5a50..e8194f0dfe15 100644\n--- a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h\n+++ b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h\n@@ -18,7 +18,7 @@ class NormalizeSelectWithUnionQueryMatcher\n public:\n     struct Data\n     {\n-        const UnionMode & union_default_mode;\n+        const SetOperationMode union_default_mode;\n     };\n \n     static void getSelectsFromUnionListNode(ASTPtr ast_select, ASTs & selects);\ndiff --git a/src/Interpreters/RewriteCountDistinctVisitor.cpp b/src/Interpreters/RewriteCountDistinctVisitor.cpp\nindex a7a26a63460d..cf28d8abb872 100644\n--- a/src/Interpreters/RewriteCountDistinctVisitor.cpp\n+++ b/src/Interpreters/RewriteCountDistinctVisitor.cpp\n@@ -62,7 +62,7 @@ void RewriteCountDistinctFunctionMatcher::visit(ASTPtr & ast, Data & /*data*/)\n         auto expr = std::make_shared<ASTExpressionList>();\n         expr->children.emplace_back(cloned_select_query);\n         auto select_with_union = std::make_shared<ASTSelectWithUnionQuery>();\n-        select_with_union->union_mode = SelectUnionMode::Unspecified;\n+        select_with_union->union_mode = SelectUnionMode::UNION_DEFAULT;\n         select_with_union->is_normalized = false;\n         select_with_union->list_of_modes.clear();\n         select_with_union->set_of_modes.clear();\ndiff --git a/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp b/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp\nindex 4d695263f268..756a8a48e25e 100644\n--- a/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp\n+++ b/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp\n@@ -2,6 +2,8 @@\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Common/typeid_cast.h>\n+#include <Core/SettingsEnums.h>\n+#include <Parsers/SelectUnionMode.h>\n \n \n namespace DB\n@@ -9,6 +11,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int EXPECTED_ALL_OR_DISTINCT;\n }\n \n /*\n@@ -27,9 +30,9 @@ void SelectIntersectExceptQueryMatcher::visit(ASTPtr & ast, Data & data)\n         visit(*select_union, data);\n }\n \n-void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Data &)\n+void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Data & data)\n {\n-    const auto & union_modes = ast.list_of_modes;\n+    auto union_modes = std::move(ast.list_of_modes);\n \n     if (union_modes.empty())\n         return;\n@@ -46,14 +49,39 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat\n     selects.pop_back();\n     SelectUnionModes modes;\n \n-    for (const auto & mode : union_modes)\n+    for (auto & mode : union_modes)\n     {\n+        /// Rewrite intersect / except mode\n+        if (mode == SelectUnionMode::EXCEPT_DEFAULT)\n+        {\n+            if (data.except_default_mode == SetOperationMode::ALL)\n+                mode = SelectUnionMode::EXCEPT_ALL;\n+            else if (data.except_default_mode == SetOperationMode::DISTINCT)\n+                mode = SelectUnionMode::EXCEPT_DISTINCT;\n+            else\n+                throw Exception(\n+                    \"Expected ALL or DISTINCT in EXCEPT query, because setting (except_default_mode) is empty\",\n+                    DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);\n+        }\n+        else if (mode == SelectUnionMode::INTERSECT_DEFAULT)\n+        {\n+            if (data.intersect_default_mode == SetOperationMode::ALL)\n+                mode = SelectUnionMode::INTERSECT_ALL;\n+            else if (data.intersect_default_mode == SetOperationMode::DISTINCT)\n+                mode = SelectUnionMode::INTERSECT_DISTINCT;\n+            else\n+                throw Exception(\n+                    \"Expected ALL or DISTINCT in INTERSECT query, because setting (intersect_default_mode) is empty\",\n+                    DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);\n+        }\n+\n         switch (mode)\n         {\n-            case SelectUnionMode::EXCEPT:\n+            case SelectUnionMode::EXCEPT_ALL:\n+            case SelectUnionMode::EXCEPT_DISTINCT:\n             {\n                 auto left = std::make_shared<ASTSelectWithUnionQuery>();\n-                left->union_mode = SelectUnionMode::ALL;\n+                left->union_mode = mode == SelectUnionMode::EXCEPT_ALL ? SelectUnionMode::UNION_ALL : SelectUnionMode::UNION_DISTINCT;\n \n                 left->list_of_selects = std::make_shared<ASTExpressionList>();\n                 left->children.push_back(left->list_of_selects);\n@@ -66,17 +94,22 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat\n                 selects.pop_back();\n \n                 auto except_node = std::make_shared<ASTSelectIntersectExceptQuery>();\n-                except_node->final_operator = ASTSelectIntersectExceptQuery::Operator::EXCEPT;\n+                except_node->final_operator = mode == SelectUnionMode::EXCEPT_ALL\n+                    ? ASTSelectIntersectExceptQuery::Operator::EXCEPT_ALL\n+                    : ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT;\n                 except_node->children = {left, right};\n \n                 children = {except_node};\n                 break;\n             }\n-            case SelectUnionMode::INTERSECT:\n+            case SelectUnionMode::INTERSECT_ALL:\n+            case SelectUnionMode::INTERSECT_DISTINCT:\n             {\n                 bool from_except = false;\n                 const auto * except_ast = typeid_cast<const ASTSelectIntersectExceptQuery *>(children.back().get());\n-                if (except_ast && (except_ast->final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT))\n+                if (except_ast\n+                    && (except_ast->final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_ALL\n+                        || except_ast->final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT))\n                     from_except = true;\n \n                 ASTPtr left;\n@@ -94,7 +127,9 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat\n                 selects.pop_back();\n \n                 auto intersect_node = std::make_shared<ASTSelectIntersectExceptQuery>();\n-                intersect_node->final_operator = ASTSelectIntersectExceptQuery::Operator::INTERSECT;\n+                intersect_node->final_operator = mode == SelectUnionMode::INTERSECT_ALL\n+                    ? ASTSelectIntersectExceptQuery::Operator::INTERSECT_ALL\n+                    : ASTSelectIntersectExceptQuery::Operator::INTERSECT_DISTINCT;\n                 intersect_node->children = {left, right};\n \n                 if (from_except)\n@@ -122,7 +157,6 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat\n         children.emplace_back(std::move(right));\n     }\n \n-    ast.union_mode = SelectUnionMode::Unspecified;\n     ast.list_of_selects->children = std::move(children);\n     ast.list_of_modes = std::move(modes);\n }\ndiff --git a/src/Interpreters/SelectIntersectExceptQueryVisitor.h b/src/Interpreters/SelectIntersectExceptQueryVisitor.h\nindex 5aeb15f70bbe..daf6d2ea0df1 100644\n--- a/src/Interpreters/SelectIntersectExceptQueryVisitor.h\n+++ b/src/Interpreters/SelectIntersectExceptQueryVisitor.h\n@@ -6,6 +6,7 @@\n #include <Interpreters/InDepthNodeVisitor.h>\n \n #include <Parsers/ASTSelectIntersectExceptQuery.h>\n+#include <Core/SettingsEnums.h>\n \n \n namespace DB\n@@ -17,7 +18,11 @@ class ASTSelectWithUnionQuery;\n class SelectIntersectExceptQueryMatcher\n {\n public:\n-    struct Data {};\n+    struct Data\n+    {\n+        const SetOperationMode intersect_default_mode;\n+        const SetOperationMode except_default_mode;\n+    };\n \n     static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }\n \ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex cdddd28adebc..2d669fbb13f0 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -521,13 +521,13 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         }\n \n         {\n-            SelectIntersectExceptQueryVisitor::Data data;\n+            SelectIntersectExceptQueryVisitor::Data data{settings.intersect_default_mode, settings.except_default_mode};\n             SelectIntersectExceptQueryVisitor{data}.visit(ast);\n         }\n \n         {\n             /// Normalize SelectWithUnionQuery\n-            NormalizeSelectWithUnionQueryVisitor::Data data{context->getSettingsRef().union_default_mode};\n+            NormalizeSelectWithUnionQueryVisitor::Data data{settings.union_default_mode};\n             NormalizeSelectWithUnionQueryVisitor{data}.visit(ast);\n         }\n \ndiff --git a/src/Parsers/ASTSelectIntersectExceptQuery.cpp b/src/Parsers/ASTSelectIntersectExceptQuery.cpp\nindex 62eeefba3857..75fbe2b52805 100644\n--- a/src/Parsers/ASTSelectIntersectExceptQuery.cpp\n+++ b/src/Parsers/ASTSelectIntersectExceptQuery.cpp\n@@ -27,7 +27,7 @@ void ASTSelectIntersectExceptQuery::formatImpl(const FormatSettings & settings,\n         if (it != children.begin())\n         {\n             settings.ostr << settings.nl_or_ws << indent_str << (settings.hilite ? hilite_keyword : \"\")\n-                          << (final_operator == Operator::INTERSECT ? \"INTERSECT\" : \"EXCEPT\")\n+                          << fromOperator(final_operator)\n                           << (settings.hilite ? hilite_none : \"\")\n                           << settings.nl_or_ws;\n         }\n@@ -53,4 +53,20 @@ ASTs ASTSelectIntersectExceptQuery::getListOfSelects() const\n     return selects;\n }\n \n+const char * ASTSelectIntersectExceptQuery::fromOperator(Operator op)\n+{\n+    switch (op)\n+    {\n+        case Operator::EXCEPT_ALL:\n+            return \"EXCEPT ALL\";\n+        case Operator::EXCEPT_DISTINCT:\n+            return \"EXCEPT DISTINCT\";\n+        case Operator::INTERSECT_ALL:\n+            return \"INTERSECT ALL\";\n+        case Operator::INTERSECT_DISTINCT:\n+            return \"INTERSECT DISTINCT\";\n+        default:\n+            return \"\";\n+    }\n+}\n }\ndiff --git a/src/Parsers/ASTSelectIntersectExceptQuery.h b/src/Parsers/ASTSelectIntersectExceptQuery.h\nindex c95944a0c357..ad962fe25e21 100644\n--- a/src/Parsers/ASTSelectIntersectExceptQuery.h\n+++ b/src/Parsers/ASTSelectIntersectExceptQuery.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <Parsers/ASTSelectQuery.h>\n+#include \"Parsers/ExpressionListParsers.h\"\n \n \n namespace DB\n@@ -16,8 +17,10 @@ class ASTSelectIntersectExceptQuery : public ASTSelectQuery\n     enum class Operator\n     {\n         UNKNOWN,\n-        INTERSECT,\n-        EXCEPT\n+        EXCEPT_ALL,\n+        EXCEPT_DISTINCT,\n+        INTERSECT_ALL,\n+        INTERSECT_DISTINCT,\n     };\n \n     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n@@ -26,6 +29,8 @@ class ASTSelectIntersectExceptQuery : public ASTSelectQuery\n \n     ASTs getListOfSelects() const;\n \n+    static const char * fromOperator(Operator op);\n+\n     /// Final operator after applying visitor.\n     Operator final_operator = Operator::UNKNOWN;\n };\ndiff --git a/src/Parsers/ASTSelectWithUnionQuery.cpp b/src/Parsers/ASTSelectWithUnionQuery.cpp\nindex 7718b2dc2ded..bc413fbe16d1 100644\n--- a/src/Parsers/ASTSelectWithUnionQuery.cpp\n+++ b/src/Parsers/ASTSelectWithUnionQuery.cpp\n@@ -1,6 +1,7 @@\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ASTSubquery.h>\n #include <Common/typeid_cast.h>\n+#include <Parsers/SelectUnionMode.h>\n #include <IO/Operators.h>\n \n #include <iostream>\n@@ -32,14 +33,18 @@ void ASTSelectWithUnionQuery::formatQueryImpl(const FormatSettings & settings, F\n \n     auto mode_to_str = [&](auto mode)\n     {\n-        if (mode == SelectUnionMode::ALL)\n+        if (mode == SelectUnionMode::UNION_ALL)\n             return \"UNION ALL\";\n-        else if (mode == SelectUnionMode::DISTINCT)\n+        else if (mode == SelectUnionMode::UNION_DISTINCT)\n             return \"UNION DISTINCT\";\n-        else if (mode == SelectUnionMode::INTERSECT)\n-            return \"INTERSECT\";\n-        else if (mode == SelectUnionMode::EXCEPT)\n-            return \"EXCEPT\";\n+        else if (mode == SelectUnionMode::EXCEPT_ALL)\n+            return \"EXCEPT ALL\";\n+        else if (mode == SelectUnionMode::EXCEPT_DISTINCT)\n+            return \"EXCEPT DISTINCT\";\n+        else if (mode == SelectUnionMode::INTERSECT_ALL)\n+            return \"INTERSECT ALL\";\n+        else if (mode == SelectUnionMode::INTERSECT_DISTINCT)\n+            return \"INTERSECT DISTINCT\";\n         return \"\";\n     };\n \n@@ -77,8 +82,8 @@ void ASTSelectWithUnionQuery::formatQueryImpl(const FormatSettings & settings, F\n \n bool ASTSelectWithUnionQuery::hasNonDefaultUnionMode() const\n {\n-    return set_of_modes.contains(SelectUnionMode::DISTINCT) || set_of_modes.contains(SelectUnionMode::INTERSECT)\n-        || set_of_modes.contains(SelectUnionMode::EXCEPT);\n+    return set_of_modes.contains(SelectUnionMode::UNION_DISTINCT) || set_of_modes.contains(SelectUnionMode::INTERSECT_DISTINCT)\n+        || set_of_modes.contains(SelectUnionMode::EXCEPT_DISTINCT);\n }\n \n }\ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex ea51367ee5d0..4e88e5c68e6a 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -139,36 +139,38 @@ bool ParserUnionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return true;\n     };\n \n-    /// Parse UNION type\n+    /// Parse UNION / INTERSECT / EXCEPT mode\n+    /// The mode can be DEFAULT (unspecified) / DISTINCT / ALL\n     auto parse_separator = [&]\n     {\n         if (s_union_parser.ignore(pos, expected))\n         {\n-            // SELECT ... UNION ALL SELECT ...\n             if (s_all_parser.check(pos, expected))\n-            {\n-                union_modes.push_back(SelectUnionMode::ALL);\n-            }\n-            // SELECT ... UNION DISTINCT SELECT ...\n+                union_modes.push_back(SelectUnionMode::UNION_ALL);\n             else if (s_distinct_parser.check(pos, expected))\n-            {\n-                union_modes.push_back(SelectUnionMode::DISTINCT);\n-            }\n-            // SELECT ... UNION SELECT ...\n+                union_modes.push_back(SelectUnionMode::UNION_DISTINCT);\n             else\n-            {\n-                union_modes.push_back(SelectUnionMode::Unspecified);\n-            }\n+                union_modes.push_back(SelectUnionMode::UNION_DEFAULT);\n             return true;\n         }\n         else if (s_except_parser.check(pos, expected))\n         {\n-            union_modes.push_back(SelectUnionMode::EXCEPT);\n+            if (s_all_parser.check(pos, expected))\n+                union_modes.push_back(SelectUnionMode::EXCEPT_ALL);\n+            else if (s_distinct_parser.check(pos, expected))\n+                union_modes.push_back(SelectUnionMode::EXCEPT_DISTINCT);\n+            else\n+                union_modes.push_back(SelectUnionMode::EXCEPT_DEFAULT);\n             return true;\n         }\n         else if (s_intersect_parser.check(pos, expected))\n         {\n-            union_modes.push_back(SelectUnionMode::INTERSECT);\n+            if (s_all_parser.check(pos, expected))\n+                union_modes.push_back(SelectUnionMode::INTERSECT_ALL);\n+            else if (s_distinct_parser.check(pos, expected))\n+                union_modes.push_back(SelectUnionMode::INTERSECT_DISTINCT);\n+            else\n+                union_modes.push_back(SelectUnionMode::INTERSECT_DEFAULT);\n             return true;\n         }\n         return false;\ndiff --git a/src/Parsers/SelectUnionMode.h b/src/Parsers/SelectUnionMode.h\nindex f4ca858d0439..ca3637612aa9 100644\n--- a/src/Parsers/SelectUnionMode.h\n+++ b/src/Parsers/SelectUnionMode.h\n@@ -7,11 +7,15 @@ namespace DB\n {\n enum class SelectUnionMode\n {\n-    Unspecified,\n-    ALL,\n-    DISTINCT,\n-    EXCEPT,\n-    INTERSECT\n+    UNION_DEFAULT,\n+    UNION_ALL,\n+    UNION_DISTINCT,\n+    EXCEPT_DEFAULT,\n+    EXCEPT_ALL,\n+    EXCEPT_DISTINCT,\n+    INTERSECT_DEFAULT,\n+    INTERSECT_ALL,\n+    INTERSECT_DISTINCT\n };\n \n using SelectUnionModes = std::vector<SelectUnionMode>;\ndiff --git a/src/Processors/Transforms/IntersectOrExceptTransform.cpp b/src/Processors/Transforms/IntersectOrExceptTransform.cpp\nindex 1ac82e99cf2d..31a3e304505f 100644\n--- a/src/Processors/Transforms/IntersectOrExceptTransform.cpp\n+++ b/src/Processors/Transforms/IntersectOrExceptTransform.cpp\n@@ -111,7 +111,10 @@ size_t IntersectOrExceptTransform::buildFilter(\n     for (size_t i = 0; i < rows; ++i)\n     {\n         auto find_result = state.findKey(method.data, i, variants.string_pool);\n-        filter[i] = current_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT ? !find_result.isFound() : find_result.isFound();\n+        filter[i] = (current_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_ALL\n+                     || current_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT)\n+            ? !find_result.isFound()\n+            : find_result.isFound();\n         if (filter[i])\n             ++new_rows_num;\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02004_intersect_except_const_column.reference b/tests/queries/0_stateless/02004_intersect_except_const_column.reference\nnew file mode 100644\nindex 000000000000..6e3081b017d4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02004_intersect_except_const_column.reference\n@@ -0,0 +1,85 @@\n+-- { echo }\n+-- Test: crash the server\n+SELECT 'fooooo' INTERSECT DISTINCT SELECT 'fooooo';\n+fooooo\n+SELECT 'fooooo' EXCEPT ALL SELECT 'fooooo';\n+-- Test: intersect return incorrect result for const column\n+SELECT 1 FROM numbers(10) INTERSECT SELECT 1 FROM numbers(10);\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+SELECT toString(1) FROM numbers(10) INTERSECT SELECT toString(1) FROM numbers(10);\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+SELECT '1' FROM numbers(10) INTERSECT SELECT '1' FROM numbers(10);\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+SELECT 1 FROM numbers(10) INTERSECT DISTINCT SELECT 1 FROM numbers(10);\n+1\n+SELECT toString(1) FROM numbers(10) INTERSECT DISTINCT SELECT toString(1) FROM numbers(10);\n+1\n+SELECT '1' FROM numbers(10) INTERSECT DISTINCT SELECT '1' FROM numbers(10);\n+1\n+-- Test: except return incorrect result for const column\n+SELECT 2 FROM numbers(10) EXCEPT SELECT 1 FROM numbers(5);\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+SELECT toString(2) FROM numbers(10) EXCEPT SELECT toString(1) FROM numbers(5);\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+SELECT '2' FROM numbers(10) EXCEPT SELECT '1' FROM numbers(5);\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+2\n+SELECT 2 FROM numbers(10) EXCEPT DISTINCT SELECT 1 FROM numbers(5);\n+2\n+SELECT toString(2) FROM numbers(10) EXCEPT DISTINCT SELECT toString(1) FROM numbers(5);\n+2\n+SELECT '2' FROM numbers(10) EXCEPT DISTINCT SELECT '1' FROM numbers(5);\n+2\ndiff --git a/tests/queries/0_stateless/02004_intersect_except_const_column.sql b/tests/queries/0_stateless/02004_intersect_except_const_column.sql\nnew file mode 100644\nindex 000000000000..6fabf34d38a5\n--- /dev/null\n+++ b/tests/queries/0_stateless/02004_intersect_except_const_column.sql\n@@ -0,0 +1,20 @@\n+-- { echo }\n+-- Test: crash the server\n+SELECT 'fooooo' INTERSECT DISTINCT SELECT 'fooooo';\n+SELECT 'fooooo' EXCEPT ALL SELECT 'fooooo';\n+\n+-- Test: intersect return incorrect result for const column\n+SELECT 1 FROM numbers(10) INTERSECT SELECT 1 FROM numbers(10);\n+SELECT toString(1) FROM numbers(10) INTERSECT SELECT toString(1) FROM numbers(10);\n+SELECT '1' FROM numbers(10) INTERSECT SELECT '1' FROM numbers(10);\n+SELECT 1 FROM numbers(10) INTERSECT DISTINCT SELECT 1 FROM numbers(10);\n+SELECT toString(1) FROM numbers(10) INTERSECT DISTINCT SELECT toString(1) FROM numbers(10);\n+SELECT '1' FROM numbers(10) INTERSECT DISTINCT SELECT '1' FROM numbers(10);\n+\n+-- Test: except return incorrect result for const column\n+SELECT 2 FROM numbers(10) EXCEPT SELECT 1 FROM numbers(5);\n+SELECT toString(2) FROM numbers(10) EXCEPT SELECT toString(1) FROM numbers(5);\n+SELECT '2' FROM numbers(10) EXCEPT SELECT '1' FROM numbers(5);\n+SELECT 2 FROM numbers(10) EXCEPT DISTINCT SELECT 1 FROM numbers(5);\n+SELECT toString(2) FROM numbers(10) EXCEPT DISTINCT SELECT toString(1) FROM numbers(5);\n+SELECT '2' FROM numbers(10) EXCEPT DISTINCT SELECT '1' FROM numbers(5);\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02004_intersect_except_distinct_operators.reference b/tests/queries/0_stateless/02004_intersect_except_distinct_operators.reference\nnew file mode 100644\nindex 000000000000..49529aa76834\n--- /dev/null\n+++ b/tests/queries/0_stateless/02004_intersect_except_distinct_operators.reference\n@@ -0,0 +1,133 @@\n+-- { echo }\n+\n+set intersect_default_mode = 'DISTINCT';\n+set except_default_mode = 'DISTINCT';\n+select 1 intersect select 1;\n+1\n+select 2 intersect select 1;\n+select 1 except select 1;\n+select 2 except select 1;\n+2\n+select 5 from numbers(20) intersect select number from numbers(5, 5);\n+5\n+select number from numbers(10) except select number from numbers(5);\n+5\n+6\n+7\n+8\n+9\n+select number, number+10 from numbers(12) except select number+5, number+15 from numbers(10);\n+0\t10\n+1\t11\n+2\t12\n+3\t13\n+4\t14\n+select 1 except select 2 intersect select 1;\n+1\n+select 1 except select 2 intersect select 2;\n+1\n+select 1 intersect select 1 except select 2;\n+1\n+select 1 intersect select 1 except select 1;\n+select 1 intersect select 1 except select 2 intersect select 1 except select 3 intersect select 1;\n+1\n+select 1 intersect select 1 except select 2 intersect select 1 except select 3 intersect select 2;\n+1\n+select 1 intersect select 1 except select 2 intersect select 1 except select 3 intersect select 2 except select 1;\n+select number%3 from numbers(10) except select 1;\n+0\n+2\n+select number from numbers(100) intersect select number from numbers(20, 60) except select number from numbers(30, 20) except select number from numbers(60, 20);\n+20\n+21\n+22\n+23\n+24\n+25\n+26\n+27\n+28\n+29\n+50\n+51\n+52\n+53\n+54\n+55\n+56\n+57\n+58\n+59\n+select * from (select 1 intersect select 1);\n+1\n+with (select number from numbers(10) intersect select 5) as a select a * 10;\n+50\n+with (select 5 except select 1) as a select a except select 5;\n+with (select number from numbers(10) intersect select 5) as a select a intersect select 1;\n+with (select number from numbers(10) intersect select 5) as a select a except select 1;\n+5\n+select count() from (select number from numbers(10) except select 5);\n+9\n+select count() from (select number from numbers(1000000) intersect select number from numbers(200000, 600000));\n+600000\n+select count() from (select number from numbers(100) intersect select number from numbers(20, 60) except select number from numbers(30, 20) except select number from numbers(60, 20));\n+20\n+select count() from (select number from numbers(100) intersect select number from numbers(20, 60) except select number from numbers(30, 20) except select number from numbers(60, 20) union all select number from numbers(100, 10));\n+30\n+select count() from (select number from numbers(1000000) intersect select number from numbers(200000, 600000) except select number from numbers(300000, 200000) except select number from numbers(600000, 200000));\n+200000\n+select count() from (select 1 intersect select 1) limit 100;\n+1\n+select count() from (select 1 except select 2) limit 100;\n+1\n+with (select count() from (select 1 union distinct select 2 except select 1)) as max\n+select count() from (select 1 union all select max) limit 100;\n+2\n+select 1 union all select 1 intersect select 1;\n+1\n+1\n+select 1 union all select 1 intersect select 2;\n+1\n+select * from (select 1 union all select 2 union all select 3 union all select 4 except select 3 union all select 5) order by 1;\n+1\n+2\n+4\n+5\n+select * from (select 1 union all select 2 union all select 3 union all select 4 intersect select 3 union all select 5) order by 1;\n+1\n+2\n+3\n+5\n+select * from (select 1 union all select 2 union all select 3 union all select 4 intersect select 3 union all select 5 except select 1) order by 1;\n+2\n+3\n+5\n+select 1 intersect (select 1 except select 2);\n+1\n+select 1 union all select 2  except (select 2 except select 1 union all select 1) except select 4;\n+select 1 intersect select count() from (select 1 except select 2 intersect select 2 union all select 1);\n+explain syntax select 1 intersect select 1;\n+SELECT 1\n+INTERSECT DISTINCT\n+SELECT 1\n+explain syntax select 1 except select 1;\n+SELECT 1\n+EXCEPT DISTINCT\n+SELECT 1\n+explain syntax select 1 union all select 2  except (select 2 except select 1 union all select 1) except select 4;\n+SELECT 1\n+UNION ALL\n+SELECT 2\n+EXCEPT DISTINCT\n+SELECT 2\n+EXCEPT DISTINCT\n+SELECT 1\n+UNION ALL\n+SELECT 1\n+EXCEPT DISTINCT\n+SELECT 4\n+set limit=1;\n+select 1 intersect select 1;\n+1\n+(((select 1) intersect select 1));\n+1\ndiff --git a/tests/queries/0_stateless/02004_intersect_except_distinct_operators.sql b/tests/queries/0_stateless/02004_intersect_except_distinct_operators.sql\nnew file mode 100644\nindex 000000000000..efb48e59f3df\n--- /dev/null\n+++ b/tests/queries/0_stateless/02004_intersect_except_distinct_operators.sql\n@@ -0,0 +1,58 @@\n+-- { echo }\n+\n+set intersect_default_mode = 'DISTINCT';\n+set except_default_mode = 'DISTINCT';\n+\n+select 1 intersect select 1;\n+select 2 intersect select 1;\n+select 1 except select 1;\n+select 2 except select 1;\n+\n+select 5 from numbers(20) intersect select number from numbers(5, 5);\n+select number from numbers(10) except select number from numbers(5);\n+select number, number+10 from numbers(12) except select number+5, number+15 from numbers(10);\n+\n+select 1 except select 2 intersect select 1;\n+select 1 except select 2 intersect select 2;\n+select 1 intersect select 1 except select 2;\n+select 1 intersect select 1 except select 1;\n+select 1 intersect select 1 except select 2 intersect select 1 except select 3 intersect select 1;\n+select 1 intersect select 1 except select 2 intersect select 1 except select 3 intersect select 2;\n+select 1 intersect select 1 except select 2 intersect select 1 except select 3 intersect select 2 except select 1;\n+\n+select number%3 from numbers(10) except select 1;\n+select number from numbers(100) intersect select number from numbers(20, 60) except select number from numbers(30, 20) except select number from numbers(60, 20);\n+\n+select * from (select 1 intersect select 1);\n+with (select number from numbers(10) intersect select 5) as a select a * 10;\n+with (select 5 except select 1) as a select a except select 5;\n+with (select number from numbers(10) intersect select 5) as a select a intersect select 1;\n+with (select number from numbers(10) intersect select 5) as a select a except select 1;\n+select count() from (select number from numbers(10) except select 5);\n+select count() from (select number from numbers(1000000) intersect select number from numbers(200000, 600000));\n+select count() from (select number from numbers(100) intersect select number from numbers(20, 60) except select number from numbers(30, 20) except select number from numbers(60, 20));\n+select count() from (select number from numbers(100) intersect select number from numbers(20, 60) except select number from numbers(30, 20) except select number from numbers(60, 20) union all select number from numbers(100, 10));\n+select count() from (select number from numbers(1000000) intersect select number from numbers(200000, 600000) except select number from numbers(300000, 200000) except select number from numbers(600000, 200000));\n+\n+select count() from (select 1 intersect select 1) limit 100;\n+select count() from (select 1 except select 2) limit 100;\n+with (select count() from (select 1 union distinct select 2 except select 1)) as max\n+select count() from (select 1 union all select max) limit 100;\n+\n+select 1 union all select 1 intersect select 1;\n+select 1 union all select 1 intersect select 2;\n+select * from (select 1 union all select 2 union all select 3 union all select 4 except select 3 union all select 5) order by 1;\n+select * from (select 1 union all select 2 union all select 3 union all select 4 intersect select 3 union all select 5) order by 1;\n+select * from (select 1 union all select 2 union all select 3 union all select 4 intersect select 3 union all select 5 except select 1) order by 1;\n+\n+select 1 intersect (select 1 except select 2);\n+select 1 union all select 2  except (select 2 except select 1 union all select 1) except select 4;\n+select 1 intersect select count() from (select 1 except select 2 intersect select 2 union all select 1);\n+\n+explain syntax select 1 intersect select 1;\n+explain syntax select 1 except select 1;\n+explain syntax select 1 union all select 2  except (select 2 except select 1 union all select 1) except select 4;\n+\n+set limit=1;\n+select 1 intersect select 1;\n+(((select 1) intersect select 1));\ndiff --git a/tests/queries/0_stateless/02004_intersect_except_operators.reference b/tests/queries/0_stateless/02004_intersect_except_operators.reference\nindex a96a6bc72649..0acb550c1e84 100644\n--- a/tests/queries/0_stateless/02004_intersect_except_operators.reference\n+++ b/tests/queries/0_stateless/02004_intersect_except_operators.reference\n@@ -116,23 +116,23 @@ select 1 union all select 2  except (select 2 except select 1 union all select 1\n select 1 intersect select count() from (select 1 except select 2 intersect select 2 union all select 1);\n explain syntax select 1 intersect select 1;\n SELECT 1\n-INTERSECT\n+INTERSECT ALL\n SELECT 1\n explain syntax select 1 except select 1;\n SELECT 1\n-EXCEPT\n+EXCEPT ALL\n SELECT 1\n explain syntax select 1 union all select 2  except (select 2 except select 1 union all select 1) except select 4;\n SELECT 1\n UNION ALL\n SELECT 2\n-EXCEPT\n+EXCEPT ALL\n SELECT 2\n-EXCEPT\n+EXCEPT ALL\n SELECT 1\n UNION ALL\n SELECT 1\n-EXCEPT\n+EXCEPT ALL\n SELECT 4\n set limit=1;\n select 1 intersect select 1;\ndiff --git a/tests/queries/0_stateless/02381_intersect_except_const_column.reference b/tests/queries/0_stateless/02381_intersect_except_const_column.reference\ndeleted file mode 100644\nindex 290835b412ec..000000000000\n--- a/tests/queries/0_stateless/02381_intersect_except_const_column.reference\n+++ /dev/null\n@@ -1,61 +0,0 @@\n-fooooo\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-1\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\n-2\ndiff --git a/tests/queries/0_stateless/02381_intersect_except_const_column.sql b/tests/queries/0_stateless/02381_intersect_except_const_column.sql\ndeleted file mode 100644\nindex b10f913dd1e8..000000000000\n--- a/tests/queries/0_stateless/02381_intersect_except_const_column.sql\n+++ /dev/null\n@@ -1,13 +0,0 @@\n--- Test: crash the server\n-SELECT 'fooooo' INTERSECT SELECT 'fooooo';\n-SELECT 'fooooo' EXCEPT SELECT 'fooooo';\n-\n--- Test: intersect return incorrect result for const column\n-SELECT 1 FROM numbers(10) INTERSECT SELECT 1 FROM numbers(10);\n-SELECT toString(1) FROM numbers(10) INTERSECT SELECT toString(1) FROM numbers(10);\n-SELECT '1' FROM numbers(10) INTERSECT SELECT '1' FROM numbers(10);\n-\n--- Test: except return incorrect result for const column\n-SELECT 2 FROM numbers(10) EXCEPT SELECT 1 FROM numbers(5);\n-SELECT toString(2) FROM numbers(10) EXCEPT SELECT toString(1) FROM numbers(5);\n-SELECT '2' FROM numbers(10) EXCEPT SELECT '1' FROM numbers(5);\n\\ No newline at end of file\n",
  "problem_statement": "Support INTERSECT DISTINCT/EXCEPT DISTINCT and make them work with others in arbitrary combination.\n> (you don't have to strictly follow this form)\r\n\r\n**Use case**\r\n\r\nThis feature will help benchmark with TPC-DS.\r\n\r\n**Describe the solution you'd like**\r\n\r\nAllow to write `select 1 from numbers(10) intersect distinct select 1 from numbers(10)`, which returns one row `1`.\r\n\r\nAllow to specify a setting to change the default behavior of `DISTINCT/EXCEPT`, similar to `union_defaut_mode`.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nNo need for this because we don't favor standard SQL.\r\n\r\n**Additional context**\r\n\r\nNone.\n",
  "hints_text": "",
  "created_at": "2022-08-30T10:13:50Z"
}