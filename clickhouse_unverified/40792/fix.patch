diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index af32c15a8678..2dd25feea8d8 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -554,7 +554,9 @@ static constexpr UInt64 operator""_GiB(unsigned long long value)
     M(UInt64, external_storage_connect_timeout_sec, DBMS_DEFAULT_CONNECT_TIMEOUT_SEC, "Connect timeout in seconds. Now supported only for MySQL", 0)  \
     M(UInt64, external_storage_rw_timeout_sec, DBMS_DEFAULT_RECEIVE_TIMEOUT_SEC, "Read/write timeout in seconds. Now supported only for MySQL", 0)  \
     \
-    M(UnionMode, union_default_mode, UnionMode::Unspecified, "Set default Union Mode in SelectWithUnion query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without Union Mode will throw exception.", 0) \
+    M(SetOperationMode, union_default_mode, SetOperationMode::Unspecified, "Set default mode in UNION query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception.", 0) \
+    M(SetOperationMode, intersect_default_mode, SetOperationMode::ALL, "Set default mode in INTERSECT query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception.", 0) \
+    M(SetOperationMode, except_default_mode, SetOperationMode::ALL, "Set default mode in EXCEPT query. Possible values: empty string, 'ALL', 'DISTINCT'. If empty, query without mode will throw exception.", 0) \
     M(Bool, optimize_aggregators_of_group_by_keys, true, "Eliminates min/max/any/anyLast aggregators of GROUP BY keys in SELECT section", 0) \
     M(Bool, optimize_group_by_function_keys, true, "Eliminates functions of other keys in GROUP BY section", 0) \
     M(Bool, legacy_column_name_of_tuple_literal, false, "List all names of element of large tuple literals in their column names instead of hash. This settings exists only for compatibility reasons. It makes sense to set to 'true', while doing rolling update of cluster from version lower than 21.7 to higher.", 0) \
diff --git a/src/Core/SettingsEnums.cpp b/src/Core/SettingsEnums.cpp
index 616026520dbc..daa678c01418 100644
--- a/src/Core/SettingsEnums.cpp
+++ b/src/Core/SettingsEnums.cpp
@@ -114,10 +114,10 @@ IMPLEMENT_SETTING_MULTI_ENUM(MySQLDataTypesSupport, ErrorCodes::UNKNOWN_MYSQL_DA
      {"date2Date32", MySQLDataTypesSupport::DATE2DATE32},
      {"date2String", MySQLDataTypesSupport::DATE2STRING}})
 
-IMPLEMENT_SETTING_ENUM(UnionMode, ErrorCodes::UNKNOWN_UNION,
-    {{"",         UnionMode::Unspecified},
-     {"ALL",      UnionMode::ALL},
-     {"DISTINCT", UnionMode::DISTINCT}})
+IMPLEMENT_SETTING_ENUM(SetOperationMode, ErrorCodes::UNKNOWN_UNION,
+    {{"",         SetOperationMode::Unspecified},
+     {"ALL",      SetOperationMode::ALL},
+     {"DISTINCT", SetOperationMode::DISTINCT}})
 
 IMPLEMENT_SETTING_ENUM(DistributedDDLOutputMode, ErrorCodes::BAD_ARGUMENTS,
     {{"none",         DistributedDDLOutputMode::NONE},
diff --git a/src/Core/SettingsEnums.h b/src/Core/SettingsEnums.h
index 308d53ff690b..518c626fcc01 100644
--- a/src/Core/SettingsEnums.h
+++ b/src/Core/SettingsEnums.h
@@ -130,14 +130,14 @@ enum class MySQLDataTypesSupport
 
 DECLARE_SETTING_MULTI_ENUM(MySQLDataTypesSupport)
 
-enum class UnionMode
+enum class SetOperationMode
 {
-    Unspecified = 0, // Query UNION without UnionMode will throw exception
-    ALL, // Query UNION without UnionMode -> SELECT ... UNION ALL SELECT ...
-    DISTINCT // Query UNION without UnionMode -> SELECT ... UNION DISTINCT SELECT ...
+    Unspecified = 0, // Query UNION / EXCEPT / INTERSECT without SetOperationMode will throw exception
+    ALL, // Query UNION / EXCEPT / INTERSECT without SetOperationMode -> SELECT ... UNION / EXCEPT / INTERSECT ALL SELECT ...
+    DISTINCT // Query UNION / EXCEPT / INTERSECT without SetOperationMode -> SELECT ... UNION / EXCEPT / INTERSECT DISTINCT SELECT ...
 };
 
-DECLARE_SETTING_ENUM(UnionMode)
+DECLARE_SETTING_ENUM(SetOperationMode)
 
 enum class DistributedDDLOutputMode
 {
diff --git a/src/Interpreters/InterpreterInsertQuery.cpp b/src/Interpreters/InterpreterInsertQuery.cpp
index 7b6066575aee..1e1b22cb5e05 100644
--- a/src/Interpreters/InterpreterInsertQuery.cpp
+++ b/src/Interpreters/InterpreterInsertQuery.cpp
@@ -346,7 +346,7 @@ BlockIO InterpreterInsertQuery::execute()
                 const auto & union_modes = select_query.list_of_modes;
 
                 /// ASTSelectWithUnionQuery is not normalized now, so it may pass some queries which can be Trivial select queries
-                const auto mode_is_all = [](const auto & mode) { return mode == SelectUnionMode::ALL; };
+                const auto mode_is_all = [](const auto & mode) { return mode == SelectUnionMode::UNION_ALL; };
 
                 is_trivial_insert_select =
                     std::all_of(union_modes.begin(), union_modes.end(), std::move(mode_is_all))
diff --git a/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp b/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp
index d6add3f77a9d..a134f7bb9138 100644
--- a/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp
+++ b/src/Interpreters/InterpreterSelectIntersectExceptQuery.cpp
@@ -4,11 +4,14 @@
 #include <Interpreters/InterpreterSelectQuery.h>
 #include <Parsers/ASTSelectIntersectExceptQuery.h>
 #include <Parsers/ASTSelectWithUnionQuery.h>
+#include <Processors/QueryPlan/DistinctStep.h>
+#include <Processors/QueryPlan/ExpressionStep.h>
 #include <Processors/QueryPlan/IQueryPlanStep.h>
 #include <Processors/QueryPlan/IntersectOrExceptStep.h>
+#include <Processors/QueryPlan/LimitStep.h>
+#include <Processors/QueryPlan/OffsetStep.h>
 #include <Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h>
 #include <Processors/QueryPlan/QueryPlan.h>
-#include <Processors/QueryPlan/ExpressionStep.h>
 #include <QueryPipeline/QueryPipelineBuilder.h>
 
 
@@ -134,10 +137,29 @@ void InterpreterSelectIntersectExceptQuery::buildQueryPlan(QueryPlan & query_pla
         data_streams[i] = plans[i]->getCurrentDataStream();
     }
 
-    auto max_threads = context->getSettingsRef().max_threads;
+    const Settings & settings = context->getSettingsRef();
+    auto max_threads = settings.max_threads;
     auto step = std::make_unique<IntersectOrExceptStep>(std::move(data_streams), final_operator, max_threads);
     query_plan.unitePlans(std::move(step), std::move(plans));
 
+    const auto & query = query_ptr->as<ASTSelectIntersectExceptQuery &>();
+    if (query.final_operator == ASTSelectIntersectExceptQuery::Operator::INTERSECT_DISTINCT
+        || query.final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT)
+    {
+        /// Add distinct transform
+        SizeLimits limits(settings.max_rows_in_distinct, settings.max_bytes_in_distinct, settings.distinct_overflow_mode);
+
+        auto distinct_step = std::make_unique<DistinctStep>(
+            query_plan.getCurrentDataStream(),
+            limits,
+            0,
+            result_header.getNames(),
+            false,
+            settings.optimize_distinct_in_order);
+
+        query_plan.addStep(std::move(distinct_step));
+    }
+
     addAdditionalPostFilter(query_plan);
     query_plan.addInterpreterContext(context);
 }
diff --git a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
index 87a182e70aeb..a679b17a5bdd 100644
--- a/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
+++ b/src/Interpreters/InterpreterSelectWithUnionQuery.cpp
@@ -317,13 +317,13 @@ void InterpreterSelectWithUnionQuery::buildQueryPlan(QueryPlan & query_plan)
             data_streams[i] = plans[i]->getCurrentDataStream();
         }
 
-        auto max_threads = context->getSettingsRef().max_threads;
+        auto max_threads = settings.max_threads;
         auto union_step = std::make_unique<UnionStep>(std::move(data_streams), max_threads);
 
         query_plan.unitePlans(std::move(union_step), std::move(plans));
 
         const auto & query = query_ptr->as<ASTSelectWithUnionQuery &>();
-        if (query.union_mode == SelectUnionMode::DISTINCT)
+        if (query.union_mode == SelectUnionMode::UNION_DISTINCT)
         {
             /// Add distinct transform
             SizeLimits limits(settings.max_rows_in_distinct, settings.max_bytes_in_distinct, settings.distinct_overflow_mode);
diff --git a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp
index 364828e6126b..40c42f7728e4 100644
--- a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp
+++ b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.cpp
@@ -59,22 +59,22 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,
             continue;
 
         /// Rewrite UNION Mode
-        if (union_modes[i] == SelectUnionMode::Unspecified)
+        if (union_modes[i] == SelectUnionMode::UNION_DEFAULT)
         {
-            if (data.union_default_mode == UnionMode::ALL)
-                union_modes[i] = SelectUnionMode::ALL;
-            else if (data.union_default_mode == UnionMode::DISTINCT)
-                union_modes[i] = SelectUnionMode::DISTINCT;
+            if (data.union_default_mode == SetOperationMode::ALL)
+                union_modes[i] = SelectUnionMode::UNION_ALL;
+            else if (data.union_default_mode == SetOperationMode::DISTINCT)
+                union_modes[i] = SelectUnionMode::UNION_DISTINCT;
             else
                 throw Exception(
                     "Expected ALL or DISTINCT in SelectWithUnion query, because setting (union_default_mode) is empty",
                     DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);
         }
 
-        if (union_modes[i] == SelectUnionMode::ALL)
+        if (union_modes[i] == SelectUnionMode::UNION_ALL)
         {
             if (auto * inner_union = select_list[i + 1]->as<ASTSelectWithUnionQuery>();
-                inner_union && inner_union->union_mode == SelectUnionMode::ALL)
+                inner_union && inner_union->union_mode == SelectUnionMode::UNION_ALL)
             {
                 /// Inner_union is an UNION ALL list, just lift up
                 for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();
@@ -85,7 +85,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,
                 selects.push_back(select_list[i + 1]);
         }
         /// flatten all left nodes and current node to a UNION DISTINCT list
-        else if (union_modes[i] == SelectUnionMode::DISTINCT)
+        else if (union_modes[i] == SelectUnionMode::UNION_DISTINCT)
         {
             auto distinct_list = std::make_shared<ASTSelectWithUnionQuery>();
             distinct_list->list_of_selects = std::make_shared<ASTExpressionList>();
@@ -96,7 +96,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,
                 getSelectsFromUnionListNode(select_list[j], distinct_list->list_of_selects->children);
             }
 
-            distinct_list->union_mode = SelectUnionMode::DISTINCT;
+            distinct_list->union_mode = SelectUnionMode::UNION_DISTINCT;
             distinct_list->is_normalized = true;
             selects.push_back(std::move(distinct_list));
             distinct_found = true;
@@ -113,7 +113,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,
     if (!distinct_found)
     {
         if (auto * inner_union = select_list[0]->as<ASTSelectWithUnionQuery>();
-            inner_union && inner_union->union_mode == SelectUnionMode::ALL)
+            inner_union && inner_union->union_mode == SelectUnionMode::UNION_ALL)
         {
             /// Inner_union is an UNION ALL list, just lift it up
             for (auto child = inner_union->list_of_selects->children.rbegin(); child != inner_union->list_of_selects->children.rend();
@@ -136,7 +136,7 @@ void NormalizeSelectWithUnionQueryMatcher::visit(ASTSelectWithUnionQuery & ast,
     std::reverse(selects.begin(), selects.end());
 
     ast.is_normalized = true;
-    ast.union_mode = SelectUnionMode::ALL;
+    ast.union_mode = SelectUnionMode::UNION_ALL;
     ast.set_of_modes = std::move(current_set_of_modes);
 
     ast.list_of_selects->children = std::move(selects);
diff --git a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h
index d035e90f5a50..e8194f0dfe15 100644
--- a/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h
+++ b/src/Interpreters/NormalizeSelectWithUnionQueryVisitor.h
@@ -18,7 +18,7 @@ class NormalizeSelectWithUnionQueryMatcher
 public:
     struct Data
     {
-        const UnionMode & union_default_mode;
+        const SetOperationMode union_default_mode;
     };
 
     static void getSelectsFromUnionListNode(ASTPtr ast_select, ASTs & selects);
diff --git a/src/Interpreters/RewriteCountDistinctVisitor.cpp b/src/Interpreters/RewriteCountDistinctVisitor.cpp
index a7a26a63460d..cf28d8abb872 100644
--- a/src/Interpreters/RewriteCountDistinctVisitor.cpp
+++ b/src/Interpreters/RewriteCountDistinctVisitor.cpp
@@ -62,7 +62,7 @@ void RewriteCountDistinctFunctionMatcher::visit(ASTPtr & ast, Data & /*data*/)
         auto expr = std::make_shared<ASTExpressionList>();
         expr->children.emplace_back(cloned_select_query);
         auto select_with_union = std::make_shared<ASTSelectWithUnionQuery>();
-        select_with_union->union_mode = SelectUnionMode::Unspecified;
+        select_with_union->union_mode = SelectUnionMode::UNION_DEFAULT;
         select_with_union->is_normalized = false;
         select_with_union->list_of_modes.clear();
         select_with_union->set_of_modes.clear();
diff --git a/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp b/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp
index 4d695263f268..756a8a48e25e 100644
--- a/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp
+++ b/src/Interpreters/SelectIntersectExceptQueryVisitor.cpp
@@ -2,6 +2,8 @@
 #include <Parsers/ASTExpressionList.h>
 #include <Parsers/ASTSelectWithUnionQuery.h>
 #include <Common/typeid_cast.h>
+#include <Core/SettingsEnums.h>
+#include <Parsers/SelectUnionMode.h>
 
 
 namespace DB
@@ -9,6 +11,7 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int LOGICAL_ERROR;
+    extern const int EXPECTED_ALL_OR_DISTINCT;
 }
 
 /*
@@ -27,9 +30,9 @@ void SelectIntersectExceptQueryMatcher::visit(ASTPtr & ast, Data & data)
         visit(*select_union, data);
 }
 
-void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Data &)
+void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Data & data)
 {
-    const auto & union_modes = ast.list_of_modes;
+    auto union_modes = std::move(ast.list_of_modes);
 
     if (union_modes.empty())
         return;
@@ -46,14 +49,39 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat
     selects.pop_back();
     SelectUnionModes modes;
 
-    for (const auto & mode : union_modes)
+    for (auto & mode : union_modes)
     {
+        /// Rewrite intersect / except mode
+        if (mode == SelectUnionMode::EXCEPT_DEFAULT)
+        {
+            if (data.except_default_mode == SetOperationMode::ALL)
+                mode = SelectUnionMode::EXCEPT_ALL;
+            else if (data.except_default_mode == SetOperationMode::DISTINCT)
+                mode = SelectUnionMode::EXCEPT_DISTINCT;
+            else
+                throw Exception(
+                    "Expected ALL or DISTINCT in EXCEPT query, because setting (except_default_mode) is empty",
+                    DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);
+        }
+        else if (mode == SelectUnionMode::INTERSECT_DEFAULT)
+        {
+            if (data.intersect_default_mode == SetOperationMode::ALL)
+                mode = SelectUnionMode::INTERSECT_ALL;
+            else if (data.intersect_default_mode == SetOperationMode::DISTINCT)
+                mode = SelectUnionMode::INTERSECT_DISTINCT;
+            else
+                throw Exception(
+                    "Expected ALL or DISTINCT in INTERSECT query, because setting (intersect_default_mode) is empty",
+                    DB::ErrorCodes::EXPECTED_ALL_OR_DISTINCT);
+        }
+
         switch (mode)
         {
-            case SelectUnionMode::EXCEPT:
+            case SelectUnionMode::EXCEPT_ALL:
+            case SelectUnionMode::EXCEPT_DISTINCT:
             {
                 auto left = std::make_shared<ASTSelectWithUnionQuery>();
-                left->union_mode = SelectUnionMode::ALL;
+                left->union_mode = mode == SelectUnionMode::EXCEPT_ALL ? SelectUnionMode::UNION_ALL : SelectUnionMode::UNION_DISTINCT;
 
                 left->list_of_selects = std::make_shared<ASTExpressionList>();
                 left->children.push_back(left->list_of_selects);
@@ -66,17 +94,22 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat
                 selects.pop_back();
 
                 auto except_node = std::make_shared<ASTSelectIntersectExceptQuery>();
-                except_node->final_operator = ASTSelectIntersectExceptQuery::Operator::EXCEPT;
+                except_node->final_operator = mode == SelectUnionMode::EXCEPT_ALL
+                    ? ASTSelectIntersectExceptQuery::Operator::EXCEPT_ALL
+                    : ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT;
                 except_node->children = {left, right};
 
                 children = {except_node};
                 break;
             }
-            case SelectUnionMode::INTERSECT:
+            case SelectUnionMode::INTERSECT_ALL:
+            case SelectUnionMode::INTERSECT_DISTINCT:
             {
                 bool from_except = false;
                 const auto * except_ast = typeid_cast<const ASTSelectIntersectExceptQuery *>(children.back().get());
-                if (except_ast && (except_ast->final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT))
+                if (except_ast
+                    && (except_ast->final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_ALL
+                        || except_ast->final_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT))
                     from_except = true;
 
                 ASTPtr left;
@@ -94,7 +127,9 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat
                 selects.pop_back();
 
                 auto intersect_node = std::make_shared<ASTSelectIntersectExceptQuery>();
-                intersect_node->final_operator = ASTSelectIntersectExceptQuery::Operator::INTERSECT;
+                intersect_node->final_operator = mode == SelectUnionMode::INTERSECT_ALL
+                    ? ASTSelectIntersectExceptQuery::Operator::INTERSECT_ALL
+                    : ASTSelectIntersectExceptQuery::Operator::INTERSECT_DISTINCT;
                 intersect_node->children = {left, right};
 
                 if (from_except)
@@ -122,7 +157,6 @@ void SelectIntersectExceptQueryMatcher::visit(ASTSelectWithUnionQuery & ast, Dat
         children.emplace_back(std::move(right));
     }
 
-    ast.union_mode = SelectUnionMode::Unspecified;
     ast.list_of_selects->children = std::move(children);
     ast.list_of_modes = std::move(modes);
 }
diff --git a/src/Interpreters/SelectIntersectExceptQueryVisitor.h b/src/Interpreters/SelectIntersectExceptQueryVisitor.h
index 5aeb15f70bbe..daf6d2ea0df1 100644
--- a/src/Interpreters/SelectIntersectExceptQueryVisitor.h
+++ b/src/Interpreters/SelectIntersectExceptQueryVisitor.h
@@ -6,6 +6,7 @@
 #include <Interpreters/InDepthNodeVisitor.h>
 
 #include <Parsers/ASTSelectIntersectExceptQuery.h>
+#include <Core/SettingsEnums.h>
 
 
 namespace DB
@@ -17,7 +18,11 @@ class ASTSelectWithUnionQuery;
 class SelectIntersectExceptQueryMatcher
 {
 public:
-    struct Data {};
+    struct Data
+    {
+        const SetOperationMode intersect_default_mode;
+        const SetOperationMode except_default_mode;
+    };
 
     static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }
 
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index cdddd28adebc..2d669fbb13f0 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -521,13 +521,13 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
         }
 
         {
-            SelectIntersectExceptQueryVisitor::Data data;
+            SelectIntersectExceptQueryVisitor::Data data{settings.intersect_default_mode, settings.except_default_mode};
             SelectIntersectExceptQueryVisitor{data}.visit(ast);
         }
 
         {
             /// Normalize SelectWithUnionQuery
-            NormalizeSelectWithUnionQueryVisitor::Data data{context->getSettingsRef().union_default_mode};
+            NormalizeSelectWithUnionQueryVisitor::Data data{settings.union_default_mode};
             NormalizeSelectWithUnionQueryVisitor{data}.visit(ast);
         }
 
diff --git a/src/Parsers/ASTSelectIntersectExceptQuery.cpp b/src/Parsers/ASTSelectIntersectExceptQuery.cpp
index 62eeefba3857..75fbe2b52805 100644
--- a/src/Parsers/ASTSelectIntersectExceptQuery.cpp
+++ b/src/Parsers/ASTSelectIntersectExceptQuery.cpp
@@ -27,7 +27,7 @@ void ASTSelectIntersectExceptQuery::formatImpl(const FormatSettings & settings,
         if (it != children.begin())
         {
             settings.ostr << settings.nl_or_ws << indent_str << (settings.hilite ? hilite_keyword : "")
-                          << (final_operator == Operator::INTERSECT ? "INTERSECT" : "EXCEPT")
+                          << fromOperator(final_operator)
                           << (settings.hilite ? hilite_none : "")
                           << settings.nl_or_ws;
         }
@@ -53,4 +53,20 @@ ASTs ASTSelectIntersectExceptQuery::getListOfSelects() const
     return selects;
 }
 
+const char * ASTSelectIntersectExceptQuery::fromOperator(Operator op)
+{
+    switch (op)
+    {
+        case Operator::EXCEPT_ALL:
+            return "EXCEPT ALL";
+        case Operator::EXCEPT_DISTINCT:
+            return "EXCEPT DISTINCT";
+        case Operator::INTERSECT_ALL:
+            return "INTERSECT ALL";
+        case Operator::INTERSECT_DISTINCT:
+            return "INTERSECT DISTINCT";
+        default:
+            return "";
+    }
+}
 }
diff --git a/src/Parsers/ASTSelectIntersectExceptQuery.h b/src/Parsers/ASTSelectIntersectExceptQuery.h
index c95944a0c357..ad962fe25e21 100644
--- a/src/Parsers/ASTSelectIntersectExceptQuery.h
+++ b/src/Parsers/ASTSelectIntersectExceptQuery.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <Parsers/ASTSelectQuery.h>
+#include "Parsers/ExpressionListParsers.h"
 
 
 namespace DB
@@ -16,8 +17,10 @@ class ASTSelectIntersectExceptQuery : public ASTSelectQuery
     enum class Operator
     {
         UNKNOWN,
-        INTERSECT,
-        EXCEPT
+        EXCEPT_ALL,
+        EXCEPT_DISTINCT,
+        INTERSECT_ALL,
+        INTERSECT_DISTINCT,
     };
 
     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;
@@ -26,6 +29,8 @@ class ASTSelectIntersectExceptQuery : public ASTSelectQuery
 
     ASTs getListOfSelects() const;
 
+    static const char * fromOperator(Operator op);
+
     /// Final operator after applying visitor.
     Operator final_operator = Operator::UNKNOWN;
 };
diff --git a/src/Parsers/ASTSelectWithUnionQuery.cpp b/src/Parsers/ASTSelectWithUnionQuery.cpp
index 7718b2dc2ded..bc413fbe16d1 100644
--- a/src/Parsers/ASTSelectWithUnionQuery.cpp
+++ b/src/Parsers/ASTSelectWithUnionQuery.cpp
@@ -1,6 +1,7 @@
 #include <Parsers/ASTSelectWithUnionQuery.h>
 #include <Parsers/ASTSubquery.h>
 #include <Common/typeid_cast.h>
+#include <Parsers/SelectUnionMode.h>
 #include <IO/Operators.h>
 
 #include <iostream>
@@ -32,14 +33,18 @@ void ASTSelectWithUnionQuery::formatQueryImpl(const FormatSettings & settings, F
 
     auto mode_to_str = [&](auto mode)
     {
-        if (mode == SelectUnionMode::ALL)
+        if (mode == SelectUnionMode::UNION_ALL)
             return "UNION ALL";
-        else if (mode == SelectUnionMode::DISTINCT)
+        else if (mode == SelectUnionMode::UNION_DISTINCT)
             return "UNION DISTINCT";
-        else if (mode == SelectUnionMode::INTERSECT)
-            return "INTERSECT";
-        else if (mode == SelectUnionMode::EXCEPT)
-            return "EXCEPT";
+        else if (mode == SelectUnionMode::EXCEPT_ALL)
+            return "EXCEPT ALL";
+        else if (mode == SelectUnionMode::EXCEPT_DISTINCT)
+            return "EXCEPT DISTINCT";
+        else if (mode == SelectUnionMode::INTERSECT_ALL)
+            return "INTERSECT ALL";
+        else if (mode == SelectUnionMode::INTERSECT_DISTINCT)
+            return "INTERSECT DISTINCT";
         return "";
     };
 
@@ -77,8 +82,8 @@ void ASTSelectWithUnionQuery::formatQueryImpl(const FormatSettings & settings, F
 
 bool ASTSelectWithUnionQuery::hasNonDefaultUnionMode() const
 {
-    return set_of_modes.contains(SelectUnionMode::DISTINCT) || set_of_modes.contains(SelectUnionMode::INTERSECT)
-        || set_of_modes.contains(SelectUnionMode::EXCEPT);
+    return set_of_modes.contains(SelectUnionMode::UNION_DISTINCT) || set_of_modes.contains(SelectUnionMode::INTERSECT_DISTINCT)
+        || set_of_modes.contains(SelectUnionMode::EXCEPT_DISTINCT);
 }
 
 }
diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp
index ea51367ee5d0..4e88e5c68e6a 100644
--- a/src/Parsers/ExpressionListParsers.cpp
+++ b/src/Parsers/ExpressionListParsers.cpp
@@ -139,36 +139,38 @@ bool ParserUnionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
         return true;
     };
 
-    /// Parse UNION type
+    /// Parse UNION / INTERSECT / EXCEPT mode
+    /// The mode can be DEFAULT (unspecified) / DISTINCT / ALL
     auto parse_separator = [&]
     {
         if (s_union_parser.ignore(pos, expected))
         {
-            // SELECT ... UNION ALL SELECT ...
             if (s_all_parser.check(pos, expected))
-            {
-                union_modes.push_back(SelectUnionMode::ALL);
-            }
-            // SELECT ... UNION DISTINCT SELECT ...
+                union_modes.push_back(SelectUnionMode::UNION_ALL);
             else if (s_distinct_parser.check(pos, expected))
-            {
-                union_modes.push_back(SelectUnionMode::DISTINCT);
-            }
-            // SELECT ... UNION SELECT ...
+                union_modes.push_back(SelectUnionMode::UNION_DISTINCT);
             else
-            {
-                union_modes.push_back(SelectUnionMode::Unspecified);
-            }
+                union_modes.push_back(SelectUnionMode::UNION_DEFAULT);
             return true;
         }
         else if (s_except_parser.check(pos, expected))
         {
-            union_modes.push_back(SelectUnionMode::EXCEPT);
+            if (s_all_parser.check(pos, expected))
+                union_modes.push_back(SelectUnionMode::EXCEPT_ALL);
+            else if (s_distinct_parser.check(pos, expected))
+                union_modes.push_back(SelectUnionMode::EXCEPT_DISTINCT);
+            else
+                union_modes.push_back(SelectUnionMode::EXCEPT_DEFAULT);
             return true;
         }
         else if (s_intersect_parser.check(pos, expected))
         {
-            union_modes.push_back(SelectUnionMode::INTERSECT);
+            if (s_all_parser.check(pos, expected))
+                union_modes.push_back(SelectUnionMode::INTERSECT_ALL);
+            else if (s_distinct_parser.check(pos, expected))
+                union_modes.push_back(SelectUnionMode::INTERSECT_DISTINCT);
+            else
+                union_modes.push_back(SelectUnionMode::INTERSECT_DEFAULT);
             return true;
         }
         return false;
diff --git a/src/Parsers/SelectUnionMode.h b/src/Parsers/SelectUnionMode.h
index f4ca858d0439..ca3637612aa9 100644
--- a/src/Parsers/SelectUnionMode.h
+++ b/src/Parsers/SelectUnionMode.h
@@ -7,11 +7,15 @@ namespace DB
 {
 enum class SelectUnionMode
 {
-    Unspecified,
-    ALL,
-    DISTINCT,
-    EXCEPT,
-    INTERSECT
+    UNION_DEFAULT,
+    UNION_ALL,
+    UNION_DISTINCT,
+    EXCEPT_DEFAULT,
+    EXCEPT_ALL,
+    EXCEPT_DISTINCT,
+    INTERSECT_DEFAULT,
+    INTERSECT_ALL,
+    INTERSECT_DISTINCT
 };
 
 using SelectUnionModes = std::vector<SelectUnionMode>;
diff --git a/src/Processors/Transforms/IntersectOrExceptTransform.cpp b/src/Processors/Transforms/IntersectOrExceptTransform.cpp
index 1ac82e99cf2d..31a3e304505f 100644
--- a/src/Processors/Transforms/IntersectOrExceptTransform.cpp
+++ b/src/Processors/Transforms/IntersectOrExceptTransform.cpp
@@ -111,7 +111,10 @@ size_t IntersectOrExceptTransform::buildFilter(
     for (size_t i = 0; i < rows; ++i)
     {
         auto find_result = state.findKey(method.data, i, variants.string_pool);
-        filter[i] = current_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT ? !find_result.isFound() : find_result.isFound();
+        filter[i] = (current_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_ALL
+                     || current_operator == ASTSelectIntersectExceptQuery::Operator::EXCEPT_DISTINCT)
+            ? !find_result.isFound()
+            : find_result.isFound();
         if (filter[i])
             ++new_rows_num;
     }
