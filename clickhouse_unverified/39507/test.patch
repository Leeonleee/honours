diff --git a/tests/integration/test_attach_partition_distinct_expression_replicated/__init__.py b/tests/integration/test_attach_partition_distinct_expression_replicated/__init__.py
new file mode 100644
index 000000000000..e69de29bb2d1
diff --git a/tests/integration/test_attach_partition_distinct_expression_replicated/configs/remote_servers.xml b/tests/integration/test_attach_partition_distinct_expression_replicated/configs/remote_servers.xml
new file mode 100644
index 000000000000..b40730e9f7d5
--- /dev/null
+++ b/tests/integration/test_attach_partition_distinct_expression_replicated/configs/remote_servers.xml
@@ -0,0 +1,17 @@
+<clickhouse>
+    <remote_servers>
+        <test_cluster>
+            <shard>
+                <internal_replication>true</internal_replication>
+                <replica>
+                    <host>replica1</host>
+                    <port>9000</port>
+                </replica>
+                <replica>
+                    <host>replica2</host>
+                    <port>9000</port>
+                </replica>
+            </shard>
+        </test_cluster>
+    </remote_servers>
+</clickhouse>
diff --git a/tests/integration/test_attach_partition_distinct_expression_replicated/test.py b/tests/integration/test_attach_partition_distinct_expression_replicated/test.py
new file mode 100644
index 000000000000..1d8ac4e9e370
--- /dev/null
+++ b/tests/integration/test_attach_partition_distinct_expression_replicated/test.py
@@ -0,0 +1,214 @@
+import pytest
+from helpers.cluster import ClickHouseCluster
+from helpers.test_tools import assert_eq_with_retry
+
+cluster = ClickHouseCluster(__file__)
+
+replica1 = cluster.add_instance(
+    "replica1", with_zookeeper=True, main_configs=["configs/remote_servers.xml"]
+)
+replica2 = cluster.add_instance(
+    "replica2", with_zookeeper=True, main_configs=["configs/remote_servers.xml"]
+)
+
+
+@pytest.fixture(scope="module")
+def start_cluster():
+    try:
+        cluster.start()
+        yield cluster
+    except Exception as ex:
+        print(ex)
+    finally:
+        cluster.shutdown()
+
+
+def cleanup(nodes):
+    for node in nodes:
+        node.query("DROP TABLE IF EXISTS source SYNC")
+        node.query("DROP TABLE IF EXISTS destination SYNC")
+
+
+def create_table(node, table_name, replicated):
+    replica = node.name
+    engine = (
+        f"ReplicatedMergeTree('/clickhouse/tables/1/{table_name}', '{replica}')"
+        if replicated
+        else "MergeTree()"
+    )
+    partition_expression = (
+        "toYYYYMMDD(timestamp)" if table_name == "source" else "toYYYYMM(timestamp)"
+    )
+    node.query_with_retry(
+        """
+        CREATE TABLE {table_name}(timestamp DateTime)
+        ENGINE = {engine}
+        ORDER BY tuple() PARTITION BY {partition_expression}
+        SETTINGS cleanup_delay_period=1, cleanup_delay_period_random_add=1, max_cleanup_delay_period=1;
+        """.format(
+            table_name=table_name,
+            engine=engine,
+            partition_expression=partition_expression,
+        )
+    )
+
+
+def test_both_replicated(start_cluster):
+    for node in [replica1, replica2]:
+        create_table(node, "source", True)
+        create_table(node, "destination", True)
+
+    replica1.query("INSERT INTO source VALUES ('2010-03-02 02:01:01')")
+    replica1.query("SYSTEM SYNC REPLICA source")
+    replica1.query("SYSTEM SYNC REPLICA destination")
+    replica1.query(
+        f"ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source"
+    )
+
+    assert_eq_with_retry(
+        replica1, f"SELECT * FROM destination", "2010-03-02 02:01:01
"
+    )
+    assert_eq_with_retry(
+        replica1,
+        f"SELECT * FROM destination",
+        replica2.query(f"SELECT * FROM destination"),
+    )
+
+    cleanup([replica1, replica2])
+
+
+def test_only_destination_replicated(start_cluster):
+    create_table(replica1, "source", False)
+    create_table(replica1, "destination", True)
+    create_table(replica2, "destination", True)
+
+    replica1.query("INSERT INTO source VALUES ('2010-03-02 02:01:01')")
+    replica1.query("SYSTEM SYNC REPLICA destination")
+    replica1.query(
+        f"ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source"
+    )
+
+    assert_eq_with_retry(
+        replica1, f"SELECT * FROM destination", "2010-03-02 02:01:01
"
+    )
+    assert_eq_with_retry(
+        replica1,
+        f"SELECT * FROM destination",
+        replica2.query(f"SELECT * FROM destination"),
+    )
+
+    cleanup([replica1, replica2])
+
+
+def test_both_replicated_partitioned_to_unpartitioned(start_cluster):
+    def create_tables(nodes):
+        for node in nodes:
+            source_engine = (
+                f"ReplicatedMergeTree('/clickhouse/tables/1/source', '{node.name}')"
+            )
+            node.query(
+                """
+                CREATE TABLE source(timestamp DateTime)
+                ENGINE = {engine}
+                ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp)
+                SETTINGS cleanup_delay_period=1, cleanup_delay_period_random_add=1, max_cleanup_delay_period=1;
+                """.format(
+                    engine=source_engine,
+                )
+            )
+
+            destination_engine = f"ReplicatedMergeTree('/clickhouse/tables/1/destination', '{node.name}')"
+            node.query(
+                """
+                CREATE TABLE destination(timestamp DateTime)
+                ENGINE = {engine}
+                ORDER BY tuple() PARTITION BY tuple()
+                SETTINGS cleanup_delay_period=1, cleanup_delay_period_random_add=1, max_cleanup_delay_period=1;
+                """.format(
+                    engine=destination_engine,
+                )
+            )
+
+    create_tables([replica1, replica2])
+
+    replica1.query("INSERT INTO source VALUES ('2010-03-02 02:01:01')")
+    replica1.query("INSERT INTO source VALUES ('2010-03-03 02:01:01')")
+    replica1.query("SYSTEM SYNC REPLICA source")
+    replica1.query("SYSTEM SYNC REPLICA destination")
+
+    replica1.query(
+        f"ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source"
+    )
+    replica1.query(
+        f"ALTER TABLE destination ATTACH PARTITION ID '20100303' FROM source"
+    )
+
+    assert_eq_with_retry(
+        replica1,
+        f"SELECT * FROM destination ORDER BY timestamp",
+        "2010-03-02 02:01:01
2010-03-03 02:01:01
",
+    )
+    assert_eq_with_retry(
+        replica1,
+        f"SELECT * FROM destination ORDER BY timestamp",
+        replica2.query(f"SELECT * FROM destination ORDER BY timestamp"),
+    )
+
+    cleanup([replica1, replica2])
+
+
+def test_both_replicated_different_exp_same_id(start_cluster):
+    def create_tables(nodes):
+        for node in nodes:
+            source_engine = (
+                f"ReplicatedMergeTree('/clickhouse/tables/1/source', '{node.name}')"
+            )
+            node.query(
+                """
+                CREATE TABLE source(a UInt16,b UInt16,c UInt16,extra UInt64,Path String,Time DateTime,Value Float64,Timestamp Int64,sign Int8)
+                ENGINE = {engine}
+                ORDER BY tuple() PARTITION BY a % 3
+                SETTINGS cleanup_delay_period=1, cleanup_delay_period_random_add=1, max_cleanup_delay_period=1;
+                """.format(
+                    engine=source_engine,
+                )
+            )
+
+            destination_engine = f"ReplicatedMergeTree('/clickhouse/tables/1/destination', '{node.name}')"
+            node.query(
+                """
+                CREATE TABLE destination(a UInt16,b UInt16,c UInt16,extra UInt64,Path String,Time DateTime,Value Float64,Timestamp Int64,sign Int8)
+                ENGINE = {engine}
+                ORDER BY tuple() PARTITION BY a
+                SETTINGS cleanup_delay_period=1, cleanup_delay_period_random_add=1, max_cleanup_delay_period=1;
+                """.format(
+                    engine=destination_engine,
+                )
+            )
+
+    create_tables([replica1, replica2])
+
+    replica1.query(
+        "INSERT INTO source (a, b, c, extra, sign) VALUES (1, 5, 9, 1000, 1)"
+    )
+    replica1.query(
+        "INSERT INTO source (a, b, c, extra, sign) VALUES (2, 6, 10, 1000, 1)"
+    )
+    replica1.query("SYSTEM SYNC REPLICA source")
+    replica1.query("SYSTEM SYNC REPLICA destination")
+
+    replica1.query(f"ALTER TABLE destination ATTACH PARTITION 1 FROM source")
+    replica1.query(f"ALTER TABLE destination ATTACH PARTITION 2 FROM source")
+
+    assert_eq_with_retry(
+        replica1,
+        f"SELECT * FROM destination ORDER BY a",
+        "1\t5\t9\t1000\t\t1970-01-01 00:00:00\t0\t0\t1
2\t6\t10\t1000\t\t1970-01-01 00:00:00\t0\t0\t1
",
+    )
+    assert_eq_with_retry(
+        replica1,
+        f"SELECT * FROM destination ORDER BY a",
+        replica2.query(f"SELECT * FROM destination ORDER BY a"),
+    )
+
+    cleanup([replica1, replica2])
diff --git a/tests/queries/0_stateless/02456_test_attach_partition_different_partition_exp.reference b/tests/queries/0_stateless/02456_test_attach_partition_different_partition_exp.reference
new file mode 100644
index 000000000000..f1d036b08bf2
--- /dev/null
+++ b/tests/queries/0_stateless/02456_test_attach_partition_different_partition_exp.reference
@@ -0,0 +1,467 @@
+-- { echoOn }
+-- Should be allowed since destination partition expr is monotonically increasing and compatible
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+201003
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '20100302' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+201003
+-- Should be allowed since destination partition expr is monotonically increasing and compatible. Note that even though
+-- the destination partition expression is more granular, the data would still fall in the same partition. Thus, it is valid
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+20100302
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '201003' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+20100302
+-- Should be allowed since destination partition expr is monotonically increasing and compatible for those specific values
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY intDiv(A, 6);
+CREATE TABLE destination (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY A;
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01', 1), ('2010-03-02 02:01:03', 1);
+ALTER TABLE destination ATTACH PARTITION ID '0' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01	1
+2010-03-02 02:01:03	1
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01	1
+2010-03-02 02:01:03	1
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+1
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION 0 FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01	1
+2010-03-02 02:01:03	1
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01	1
+2010-03-02 02:01:03	1
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+1
+-- Should be allowed because dst partition exp is monot inc and data is not split
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY cityHash64(category);
+CREATE TABLE destination (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(category);
+INSERT INTO TABLE source VALUES ('spaghetti', 'food'), ('mop', 'general');
+INSERT INTO TABLE source VALUES ('rice', 'food');
+ALTER TABLE destination ATTACH PARTITION ID '17908065610379824077' from source;
+SELECT * FROM source ORDER BY productName;
+mop	general
+rice	food
+spaghetti	food
+SELECT * FROM destination ORDER BY productName;
+rice	food
+spaghetti	food
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+59532f3c39a412a413f0f014c7750a9d
+59532f3c39a412a413f0f014c7750a9d
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '17908065610379824077' from source;
+SELECT * FROM source ORDER BY productName;
+mop	general
+rice	food
+spaghetti	food
+SELECT * FROM destination ORDER BY productName;
+rice	food
+spaghetti	food
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+59532f3c39a412a413f0f014c7750a9d
+59532f3c39a412a413f0f014c7750a9d
+-- Should be allowed, extra test case to validate https://github.com/ClickHouse/ClickHouse/pull/39507#issuecomment-1747574133
+
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp Int64) engine=MergeTree ORDER BY (timestamp) PARTITION BY intDiv(timestamp, 86400000);
+CREATE TABLE destination (timestamp Int64) engine=MergeTree ORDER BY (timestamp) PARTITION BY toYear(toDateTime(intDiv(timestamp, 1000)));
+INSERT INTO TABLE source VALUES (1267495261123);
+ALTER TABLE destination ATTACH PARTITION ID '14670' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+1267495261123
+SELECT * FROM destination ORDER BY timestamp;
+1267495261123
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+2010
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '14670' from source;
+SELECT * FROM source ORDER BY timestamp;
+1267495261123
+SELECT * FROM destination ORDER BY timestamp;
+1267495261123
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+2010
+-- Should be allowed, extra test case to validate https://github.com/ClickHouse/ClickHouse/pull/39507#issuecomment-1747511726
+
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime('UTC'), key Int64, f Float64) engine=MergeTree ORDER BY (key, timestamp) PARTITION BY toYear(timestamp);
+CREATE TABLE destination (timestamp DateTime('UTC'), key Int64, f Float64) engine=MergeTree ORDER BY (key, timestamp) PARTITION BY (intDiv(toUInt32(timestamp),86400));
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01',1,1),('2010-03-02 02:01:01',1,1),('2011-02-02 02:01:03',1,1);
+ALTER TABLE destination ATTACH PARTITION ID '2010' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01	1	1
+2010-03-02 02:01:01	1	1
+2011-02-02 02:01:03	1	1
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01	1	1
+2010-03-02 02:01:01	1	1
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+14670
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '2010' from source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01	1	1
+2010-03-02 02:01:01	1	1
+2011-02-02 02:01:03	1	1
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01	1	1
+2010-03-02 02:01:01	1	1
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+14670
+-- Should be allowed, partitioned table to unpartitioned. Since the destination is unpartitioned, parts would ultimately
+-- fall into the same partition.
+-- Destination partition by expression is omitted, which causes StorageMetadata::getPartitionKeyAST() to be nullptr.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple();
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+all
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '201003' from source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+all
+-- Same as above, but destination partition by expression is explicitly defined. Test case required to validate that
+-- partition by tuple() is accepted.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY tuple();
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+all
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '201003' from source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+all
+-- Should be allowed because the destination partition expression columns are a subset of the source partition expression columns
+-- Columns in this case refer to the expression elements, not to the actual table columns
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY (a, b, c);
+CREATE TABLE destination (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY (a, b);
+INSERT INTO TABLE source VALUES (1, 2, 3), (1, 2, 4);
+ALTER TABLE destination ATTACH PARTITION ID '1-2-3' FROM source;
+SELECT * FROM source ORDER BY (a, b, c);
+1	2	3
+1	2	4
+SELECT * FROM destination ORDER BY (a, b, c);
+1	2	3
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+1-2
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION (1, 2, 3) from source;
+SELECT * FROM source ORDER BY (a, b, c);
+1	2	3
+1	2	4
+SELECT * FROM destination ORDER BY (a, b, c);
+1	2	3
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+1-2
+-- Should be allowed because the destination partition expression columns are a subset of the source partition expression columns
+-- Columns in this case refer to the expression elements, not to the actual table columns
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY (a, b, c);
+CREATE TABLE destination (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY a;
+INSERT INTO TABLE source VALUES (1, 2, 3), (1, 2, 4);
+ALTER TABLE destination ATTACH PARTITION ID '1-2-3' FROM source;
+SELECT * FROM source ORDER BY (a, b, c);
+1	2	3
+1	2	4
+SELECT * FROM destination ORDER BY (a, b, c);
+1	2	3
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+1
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION (1, 2, 3) from source;
+SELECT * FROM source ORDER BY (a, b, c);
+1	2	3
+1	2	4
+SELECT * FROM destination ORDER BY (a, b, c);
+1	2	3
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+1
+-- Should be allowed. Special test case, tricky to explain. First column of source partition expression is
+-- timestamp, while first column of destination partition expression is `A`. One of the previous implementations
+-- would not match the columns, which could lead to `timestamp` min max being used to calculate monotonicity of `A`.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (`timestamp` DateTime, `A` Int64) ENGINE = MergeTree PARTITION BY tuple(toYYYYMM(timestamp), intDiv(A, 6)) ORDER BY timestamp;
+CREATE TABLE destination (`timestamp` DateTime, `A` Int64) ENGINE = MergeTree PARTITION BY A ORDER BY timestamp;
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01', 5);
+ALTER TABLE destination ATTACH PARTITION ID '201003-0' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01	5
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01	5
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+5
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION (201003, 0) from source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01	5
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01	5
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+5
+-- Should be allowed. Destination partition expression contains multiple expressions, but all of them are monotonically
+-- increasing in the source partition min max indexes.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(A, B) ORDER BY tuple();
+CREATE TABLE destination (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(intDiv(A, 2), intDiv(B, 2)) ORDER BY tuple();
+INSERT INTO TABLE source VALUES (6, 12);
+ALTER TABLE destination ATTACH PARTITION ID '6-12' FROM source;
+SELECT * FROM source ORDER BY A;
+6	12
+SELECT * FROM destination ORDER BY A;
+6	12
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+3-6
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION (6, 12) from source;
+SELECT * FROM source ORDER BY A;
+6	12
+SELECT * FROM destination ORDER BY A;
+6	12
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+3-6
+-- Should be allowed. The same scenario as above, but partition expressions inverted.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(intDiv(A, 2), intDiv(B, 2)) ORDER BY tuple();
+CREATE TABLE destination (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(A, B) ORDER BY tuple();
+INSERT INTO TABLE source VALUES (6, 12);
+ALTER TABLE destination ATTACH PARTITION ID '3-6' FROM source;
+SELECT * FROM source ORDER BY A;
+6	12
+SELECT * FROM destination ORDER BY A;
+6	12
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+6-12
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION (3, 6) from source;
+SELECT * FROM source ORDER BY A;
+6	12
+SELECT * FROM destination ORDER BY A;
+6	12
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+6-12
+-- Should be allowed, it is a local operation, no different than regular attach. Replicated to replicated.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE
+    source(timestamp DateTime)
+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/source_replicated_to_replicated_distinct_expression', '1')
+        PARTITION BY toYYYYMMDD(timestamp)
+        ORDER BY tuple();
+CREATE TABLE
+    destination(timestamp DateTime)
+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/destination_replicated_to_replicated_distinct_expression', '1')
+        PARTITION BY toYYYYMM(timestamp)
+        ORDER BY tuple();
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+201003
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '20100302' from source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+201003
+-- Should be allowed, it is a local operation, no different than regular attach. Non replicated to replicated
+DROP TABLE IF EXISTS source SYNC;
+DROP TABLE IF EXISTS destination SYNC;
+CREATE TABLE source(timestamp DateTime) ENGINE = MergeTree() PARTITION BY toYYYYMMDD(timestamp) ORDER BY tuple();
+CREATE TABLE
+    destination(timestamp DateTime)
+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/destination_non_replicated_to_replicated_distinct_expression', '1')
+        PARTITION BY toYYYYMM(timestamp)
+        ORDER BY tuple();
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+201003
+TRUNCATE TABLE destination;
+ALTER TABLE destination ATTACH PARTITION '20100302' from source;
+SELECT * FROM source ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT * FROM destination ORDER BY timestamp;
+2010-03-02 02:01:01
+2010-03-02 02:01:03
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+201003
+-- Should not be allowed because data would be split into two different partitions
+DROP TABLE IF EXISTS source SYNC;
+DROP TABLE IF EXISTS destination SYNC;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-03 02:01:03');
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source; -- { serverError 248 }
+ALTER TABLE destination ATTACH PARTITION '201003' from source; -- { serverError 248 }
+-- Should not be allowed because data would be split into two different partitions
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY intDiv(A, 6);
+CREATE TABLE destination (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY A;
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01', 1), ('2010-03-02 02:01:03', 2);
+ALTER TABLE destination ATTACH PARTITION ID '0' FROM source; -- { serverError 248 }
+ALTER TABLE destination ATTACH PARTITION 0 FROM source; -- { serverError 248 }
+-- Should not be allowed because dst partition exp takes more than two arguments, so it's not considered monotonically inc
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(category);
+CREATE TABLE destination (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY substring(category, 1, 2);
+INSERT INTO TABLE source VALUES ('spaghetti', 'food'), ('mop', 'general');
+INSERT INTO TABLE source VALUES ('rice', 'food');
+ALTER TABLE destination ATTACH PARTITION ID '4590ba78048910b74a47d5bfb308abed' from source; -- { serverError 36 }
+ALTER TABLE destination ATTACH PARTITION 'food' from source; -- { serverError 36 }
+-- Should not be allowed because dst partition exp depends on a different set of columns
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(category);
+CREATE TABLE destination (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(productName);
+INSERT INTO TABLE source VALUES ('spaghetti', 'food'), ('mop', 'general');
+INSERT INTO TABLE source VALUES ('rice', 'food');
+ALTER TABLE destination ATTACH PARTITION ID '4590ba78048910b74a47d5bfb308abed' from source; -- { serverError 36 }
+ALTER TABLE destination ATTACH PARTITION 'food' from source; -- { serverError 36 }
+-- Should not be allowed because dst partition exp is not monotonically increasing
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (productName String) engine=MergeTree ORDER BY tuple() PARTITION BY left(productName, 2);
+CREATE TABLE destination (productName String) engine=MergeTree ORDER BY tuple() PARTITION BY cityHash64(productName);
+INSERT INTO TABLE source VALUES ('bread'), ('mop');
+INSERT INTO TABLE source VALUES ('broccoli');
+ALTER TABLE destination ATTACH PARTITION ID '4589453b7ee96ce9de1265bd57674496' from source; -- { serverError 36 }
+ALTER TABLE destination ATTACH PARTITION 'br' from source; -- { serverError 36 }
+-- Empty/ non-existent partition, same partition expression. Nothing should happen
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+ALTER TABLE destination ATTACH PARTITION ID '1' FROM source;
+ALTER TABLE destination ATTACH PARTITION 1 FROM source;
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+-- Empty/ non-existent partition, different partition expression. Nothing should happen
+-- https://github.com/ClickHouse/ClickHouse/pull/39507#discussion_r1399839045
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+ALTER TABLE destination ATTACH PARTITION ID '1' FROM source;
+ALTER TABLE destination ATTACH PARTITION 1 FROM source;
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+-- Replace instead of attach. Empty/ non-existent partition, same partition expression. Nothing should happen
+-- https://github.com/ClickHouse/ClickHouse/pull/39507#discussion_r1399839045
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+ALTER TABLE destination REPLACE PARTITION '1' FROM source;
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+-- Replace instead of attach. Empty/ non-existent partition to non-empty partition, same partition id.
+-- https://github.com/ClickHouse/ClickHouse/pull/39507#discussion_r1399839045
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (A Int) engine=MergeTree ORDER BY tuple() PARTITION BY A;
+CREATE TABLE destination (A Int) engine=MergeTree ORDER BY tuple() PARTITION BY A;
+INSERT INTO TABLE destination VALUES (1);
+ALTER TABLE destination REPLACE PARTITION '1' FROM source;
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
diff --git a/tests/queries/0_stateless/02456_test_attach_partition_different_partition_exp.sql b/tests/queries/0_stateless/02456_test_attach_partition_different_partition_exp.sql
new file mode 100644
index 000000000000..9547d6ae249c
--- /dev/null
+++ b/tests/queries/0_stateless/02456_test_attach_partition_different_partition_exp.sql
@@ -0,0 +1,485 @@
+-- { echoOn }
+-- Should be allowed since destination partition expr is monotonically increasing and compatible
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '20100302' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed since destination partition expr is monotonically increasing and compatible. Note that even though
+-- the destination partition expression is more granular, the data would still fall in the same partition. Thus, it is valid
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '201003' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed since destination partition expr is monotonically increasing and compatible for those specific values
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY intDiv(A, 6);
+
+CREATE TABLE destination (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY A;
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01', 1), ('2010-03-02 02:01:03', 1);
+
+ALTER TABLE destination ATTACH PARTITION ID '0' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION 0 FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed because dst partition exp is monot inc and data is not split
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY cityHash64(category);
+CREATE TABLE destination (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(category);
+
+INSERT INTO TABLE source VALUES ('spaghetti', 'food'), ('mop', 'general');
+INSERT INTO TABLE source VALUES ('rice', 'food');
+
+ALTER TABLE destination ATTACH PARTITION ID '17908065610379824077' from source;
+
+SELECT * FROM source ORDER BY productName;
+SELECT * FROM destination ORDER BY productName;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '17908065610379824077' from source;
+
+SELECT * FROM source ORDER BY productName;
+SELECT * FROM destination ORDER BY productName;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed, extra test case to validate https://github.com/ClickHouse/ClickHouse/pull/39507#issuecomment-1747574133
+
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp Int64) engine=MergeTree ORDER BY (timestamp) PARTITION BY intDiv(timestamp, 86400000);
+CREATE TABLE destination (timestamp Int64) engine=MergeTree ORDER BY (timestamp) PARTITION BY toYear(toDateTime(intDiv(timestamp, 1000)));
+
+INSERT INTO TABLE source VALUES (1267495261123);
+
+ALTER TABLE destination ATTACH PARTITION ID '14670' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '14670' from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed, extra test case to validate https://github.com/ClickHouse/ClickHouse/pull/39507#issuecomment-1747511726
+
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime('UTC'), key Int64, f Float64) engine=MergeTree ORDER BY (key, timestamp) PARTITION BY toYear(timestamp);
+CREATE TABLE destination (timestamp DateTime('UTC'), key Int64, f Float64) engine=MergeTree ORDER BY (key, timestamp) PARTITION BY (intDiv(toUInt32(timestamp),86400));
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01',1,1),('2010-03-02 02:01:01',1,1),('2011-02-02 02:01:03',1,1);
+
+ALTER TABLE destination ATTACH PARTITION ID '2010' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '2010' from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed, partitioned table to unpartitioned. Since the destination is unpartitioned, parts would ultimately
+-- fall into the same partition.
+-- Destination partition by expression is omitted, which causes StorageMetadata::getPartitionKeyAST() to be nullptr.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple();
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '201003' from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Same as above, but destination partition by expression is explicitly defined. Test case required to validate that
+-- partition by tuple() is accepted.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY tuple();
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '201003' from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed because the destination partition expression columns are a subset of the source partition expression columns
+-- Columns in this case refer to the expression elements, not to the actual table columns
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY (a, b, c);
+CREATE TABLE destination (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY (a, b);
+
+INSERT INTO TABLE source VALUES (1, 2, 3), (1, 2, 4);
+
+ALTER TABLE destination ATTACH PARTITION ID '1-2-3' FROM source;
+
+SELECT * FROM source ORDER BY (a, b, c);
+SELECT * FROM destination ORDER BY (a, b, c);
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION (1, 2, 3) from source;
+
+SELECT * FROM source ORDER BY (a, b, c);
+SELECT * FROM destination ORDER BY (a, b, c);
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed because the destination partition expression columns are a subset of the source partition expression columns
+-- Columns in this case refer to the expression elements, not to the actual table columns
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE source (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY (a, b, c);
+CREATE TABLE destination (a Int, b Int, c Int) engine=MergeTree ORDER BY tuple() PARTITION BY a;
+
+INSERT INTO TABLE source VALUES (1, 2, 3), (1, 2, 4);
+
+ALTER TABLE destination ATTACH PARTITION ID '1-2-3' FROM source;
+
+SELECT * FROM source ORDER BY (a, b, c);
+SELECT * FROM destination ORDER BY (a, b, c);
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION (1, 2, 3) from source;
+
+SELECT * FROM source ORDER BY (a, b, c);
+SELECT * FROM destination ORDER BY (a, b, c);
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed. Special test case, tricky to explain. First column of source partition expression is
+-- timestamp, while first column of destination partition expression is `A`. One of the previous implementations
+-- would not match the columns, which could lead to `timestamp` min max being used to calculate monotonicity of `A`.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (`timestamp` DateTime, `A` Int64) ENGINE = MergeTree PARTITION BY tuple(toYYYYMM(timestamp), intDiv(A, 6)) ORDER BY timestamp;
+CREATE TABLE destination (`timestamp` DateTime, `A` Int64) ENGINE = MergeTree PARTITION BY A ORDER BY timestamp;
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01', 5);
+
+ALTER TABLE destination ATTACH PARTITION ID '201003-0' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION (201003, 0) from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed. Destination partition expression contains multiple expressions, but all of them are monotonically
+-- increasing in the source partition min max indexes.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(A, B) ORDER BY tuple();
+CREATE TABLE destination (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(intDiv(A, 2), intDiv(B, 2)) ORDER BY tuple();
+
+INSERT INTO TABLE source VALUES (6, 12);
+
+ALTER TABLE destination ATTACH PARTITION ID '6-12' FROM source;
+
+SELECT * FROM source ORDER BY A;
+SELECT * FROM destination ORDER BY A;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION (6, 12) from source;
+
+SELECT * FROM source ORDER BY A;
+SELECT * FROM destination ORDER BY A;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed. The same scenario as above, but partition expressions inverted.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(intDiv(A, 2), intDiv(B, 2)) ORDER BY tuple();
+CREATE TABLE destination (A Int, B Int) ENGINE = MergeTree PARTITION BY tuple(A, B) ORDER BY tuple();
+
+INSERT INTO TABLE source VALUES (6, 12);
+
+ALTER TABLE destination ATTACH PARTITION ID '3-6' FROM source;
+
+SELECT * FROM source ORDER BY A;
+SELECT * FROM destination ORDER BY A;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION (3, 6) from source;
+
+SELECT * FROM source ORDER BY A;
+SELECT * FROM destination ORDER BY A;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed, it is a local operation, no different than regular attach. Replicated to replicated.
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+CREATE TABLE
+    source(timestamp DateTime)
+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/source_replicated_to_replicated_distinct_expression', '1')
+        PARTITION BY toYYYYMMDD(timestamp)
+        ORDER BY tuple();
+
+CREATE TABLE
+    destination(timestamp DateTime)
+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/destination_replicated_to_replicated_distinct_expression', '1')
+        PARTITION BY toYYYYMM(timestamp)
+        ORDER BY tuple();
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '20100302' from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should be allowed, it is a local operation, no different than regular attach. Non replicated to replicated
+DROP TABLE IF EXISTS source SYNC;
+DROP TABLE IF EXISTS destination SYNC;
+CREATE TABLE source(timestamp DateTime) ENGINE = MergeTree() PARTITION BY toYYYYMMDD(timestamp) ORDER BY tuple();
+
+CREATE TABLE
+    destination(timestamp DateTime)
+    ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/test/destination_non_replicated_to_replicated_distinct_expression', '1')
+        PARTITION BY toYYYYMM(timestamp)
+        ORDER BY tuple();
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-02 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '20100302' FROM source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+TRUNCATE TABLE destination;
+
+ALTER TABLE destination ATTACH PARTITION '20100302' from source;
+
+SELECT * FROM source ORDER BY timestamp;
+SELECT * FROM destination ORDER BY timestamp;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Should not be allowed because data would be split into two different partitions
+DROP TABLE IF EXISTS source SYNC;
+DROP TABLE IF EXISTS destination SYNC;
+
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01'), ('2010-03-03 02:01:03');
+
+ALTER TABLE destination ATTACH PARTITION ID '201003' FROM source; -- { serverError 248 }
+ALTER TABLE destination ATTACH PARTITION '201003' from source; -- { serverError 248 }
+
+-- Should not be allowed because data would be split into two different partitions
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY intDiv(A, 6);
+
+CREATE TABLE destination (timestamp DateTime, A Int64) engine=MergeTree ORDER BY timestamp PARTITION BY A;
+
+INSERT INTO TABLE source VALUES ('2010-03-02 02:01:01', 1), ('2010-03-02 02:01:03', 2);
+
+ALTER TABLE destination ATTACH PARTITION ID '0' FROM source; -- { serverError 248 }
+ALTER TABLE destination ATTACH PARTITION 0 FROM source; -- { serverError 248 }
+
+-- Should not be allowed because dst partition exp takes more than two arguments, so it's not considered monotonically inc
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(category);
+CREATE TABLE destination (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY substring(category, 1, 2);
+
+INSERT INTO TABLE source VALUES ('spaghetti', 'food'), ('mop', 'general');
+INSERT INTO TABLE source VALUES ('rice', 'food');
+
+ALTER TABLE destination ATTACH PARTITION ID '4590ba78048910b74a47d5bfb308abed' from source; -- { serverError 36 }
+ALTER TABLE destination ATTACH PARTITION 'food' from source; -- { serverError 36 }
+
+-- Should not be allowed because dst partition exp depends on a different set of columns
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(category);
+CREATE TABLE destination (productName String, category String) engine=MergeTree ORDER BY tuple() PARTITION BY toString(productName);
+
+INSERT INTO TABLE source VALUES ('spaghetti', 'food'), ('mop', 'general');
+INSERT INTO TABLE source VALUES ('rice', 'food');
+
+ALTER TABLE destination ATTACH PARTITION ID '4590ba78048910b74a47d5bfb308abed' from source; -- { serverError 36 }
+ALTER TABLE destination ATTACH PARTITION 'food' from source; -- { serverError 36 }
+
+-- Should not be allowed because dst partition exp is not monotonically increasing
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (productName String) engine=MergeTree ORDER BY tuple() PARTITION BY left(productName, 2);
+CREATE TABLE destination (productName String) engine=MergeTree ORDER BY tuple() PARTITION BY cityHash64(productName);
+
+INSERT INTO TABLE source VALUES ('bread'), ('mop');
+INSERT INTO TABLE source VALUES ('broccoli');
+
+ALTER TABLE destination ATTACH PARTITION ID '4589453b7ee96ce9de1265bd57674496' from source; -- { serverError 36 }
+ALTER TABLE destination ATTACH PARTITION 'br' from source; -- { serverError 36 }
+
+-- Empty/ non-existent partition, same partition expression. Nothing should happen
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+
+ALTER TABLE destination ATTACH PARTITION ID '1' FROM source;
+ALTER TABLE destination ATTACH PARTITION 1 FROM source;
+
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Empty/ non-existent partition, different partition expression. Nothing should happen
+-- https://github.com/ClickHouse/ClickHouse/pull/39507#discussion_r1399839045
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMMDD(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+
+ALTER TABLE destination ATTACH PARTITION ID '1' FROM source;
+ALTER TABLE destination ATTACH PARTITION 1 FROM source;
+
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Replace instead of attach. Empty/ non-existent partition, same partition expression. Nothing should happen
+-- https://github.com/ClickHouse/ClickHouse/pull/39507#discussion_r1399839045
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+CREATE TABLE destination (timestamp DateTime) engine=MergeTree ORDER BY tuple() PARTITION BY toYYYYMM(timestamp);
+
+ALTER TABLE destination REPLACE PARTITION '1' FROM source;
+
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
+
+-- Replace instead of attach. Empty/ non-existent partition to non-empty partition, same partition id.
+-- https://github.com/ClickHouse/ClickHouse/pull/39507#discussion_r1399839045
+DROP TABLE IF EXISTS source;
+DROP TABLE IF EXISTS destination;
+
+CREATE TABLE source (A Int) engine=MergeTree ORDER BY tuple() PARTITION BY A;
+CREATE TABLE destination (A Int) engine=MergeTree ORDER BY tuple() PARTITION BY A;
+
+INSERT INTO TABLE destination VALUES (1);
+
+ALTER TABLE destination REPLACE PARTITION '1' FROM source;
+
+SELECT * FROM destination;
+SELECT partition_id FROM system.parts where table='destination' AND database = currentDatabase() AND active = 1;
