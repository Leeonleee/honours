{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 1123,
  "instance_id": "ClickHouse__ClickHouse-1123",
  "issue_numbers": [
    "598",
    "1112"
  ],
  "base_commit": "61f65e97a8f43dba2d5365d1d542710dbcf6bf4b",
  "patch": "diff --git a/dbms/src/Interpreters/InterpreterCreateQuery.cpp b/dbms/src/Interpreters/InterpreterCreateQuery.cpp\nindex b17ba8dd66f4..80536a76a157 100644\n--- a/dbms/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -445,8 +445,20 @@ String InterpreterCreateQuery::setEngine(\n         String as_database_name = create.as_database.empty() ? context.getCurrentDatabase() : create.as_database;\n         String as_table_name = create.as_table;\n \n-        storage_name = as_storage->getName();\n-        create.storage = typeid_cast<const ASTCreateQuery &>(*context.getCreateQuery(as_database_name, as_table_name)).storage;\n+        auto as_create_ptr = context.getCreateQuery(as_database_name, as_table_name);\n+        auto & as_create = typeid_cast<const ASTCreateQuery &>(*as_create_ptr);\n+\n+        if (!create.storage)\n+        {\n+            if (as_create.is_view || as_create.is_materialized_view)\n+                create.storage = as_create.inner_storage;\n+            else\n+                create.storage = as_create.storage;\n+\n+            storage_name = typeid_cast<const ASTFunction &>(*create.storage).name;\n+        }\n+        else\n+            storage_name = as_storage->getName();\n     }\n     else if (create.is_temporary)\n         set_engine(\"Memory\");\ndiff --git a/dbms/src/Parsers/ParserCreateQuery.cpp b/dbms/src/Parsers/ParserCreateQuery.cpp\nindex f4f939ff01ee..25037bd67b92 100644\n--- a/dbms/src/Parsers/ParserCreateQuery.cpp\n+++ b/dbms/src/Parsers/ParserCreateQuery.cpp\n@@ -323,12 +323,10 @@ bool ParserCreateQuery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         /// AS SELECT ...\n         if (!s_as.ignore(pos, expected))\n             return false;\n-        Pos before_select = pos;\n-        if (!s_select.ignore(pos, expected))\n-            return false;\n-        pos = before_select;\n+\n         ParserSelectQuery select_p;\n-        select_p.parse(pos, select, expected);\n+        if (!select_p.parse(pos, select, expected))\n+            return false;\n     }\n \n     auto query = std::make_shared<ASTCreateQuery>(StringRange(begin, pos));\ndiff --git a/dbms/src/Storages/StorageMaterializedView.cpp b/dbms/src/Storages/StorageMaterializedView.cpp\nindex ba861f04a066..08429ed5e5a2 100644\n--- a/dbms/src/Storages/StorageMaterializedView.cpp\n+++ b/dbms/src/Storages/StorageMaterializedView.cpp\n@@ -19,6 +19,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int INCORRECT_QUERY;\n }\n \n \n@@ -29,7 +30,7 @@ static void extractDependentTable(const ASTSelectQuery & query, String & select_\n     if (!query_table)\n         return;\n \n-    if (const ASTIdentifier * ast_id = typeid_cast<const ASTIdentifier *>(query_table.get()))\n+    if (auto ast_id = typeid_cast<const ASTIdentifier *>(query_table.get()))\n     {\n         auto query_database = query.database();\n \n@@ -41,7 +42,7 @@ static void extractDependentTable(const ASTSelectQuery & query, String & select_\n         select_database_name = typeid_cast<const ASTIdentifier &>(*query_database).name;\n         select_table_name = ast_id->name;\n     }\n-    else if (const ASTSelectQuery * ast_select = typeid_cast<const ASTSelectQuery *>(query_table.get()))\n+    else if (auto ast_select = typeid_cast<const ASTSelectQuery *>(query_table.get()))\n     {\n         extractDependentTable(*ast_select, select_database_name, select_table_name);\n     }\n@@ -66,13 +67,18 @@ StorageMaterializedView::StorageMaterializedView(\n     database_name(database_name_), context(context_), columns(columns_)\n {\n     ASTCreateQuery & create = typeid_cast<ASTCreateQuery &>(*query_);\n+\n+    if (!create.select)\n+        throw Exception(\"SELECT query is not specified for \" + getName(), ErrorCodes::INCORRECT_QUERY);\n+\n+    if (!create.inner_storage)\n+        throw Exception(\"ENGINE of MaterializedView should be specified explicitly\", ErrorCodes::INCORRECT_QUERY);\n+\n     ASTSelectQuery & select = typeid_cast<ASTSelectQuery &>(*create.select);\n \n     /// If the internal query does not specify a database, retrieve it from the context and write it to the query.\n     select.setDatabaseIfNeeded(database_name);\n \n-    inner_query = create.select;\n-\n     extractDependentTable(select, select_database_name, select_table_name);\n \n     if (!select_table_name.empty())\n@@ -80,7 +86,8 @@ StorageMaterializedView::StorageMaterializedView(\n             DatabaseAndTableName(select_database_name, select_table_name),\n             DatabaseAndTableName(database_name, table_name));\n \n-    auto inner_table_name = getInnerTableName();\n+    String inner_table_name = getInnerTableName();\n+    inner_query = create.select;\n \n     /// If there is an ATTACH request, then the internal table must already be connected.\n     if (!attach_)\n@@ -91,18 +98,7 @@ StorageMaterializedView::StorageMaterializedView(\n         manual_create_query->table = inner_table_name;\n         manual_create_query->columns = create.columns;\n         manual_create_query->children.push_back(manual_create_query->columns);\n-\n-        /// If you do not specify a storage type in the query, try retrieving it from SELECT query.\n-        if (!create.inner_storage)\n-        {\n-            /// TODO also try to extract `params` to create a table\n-            auto func = std::make_shared<ASTFunction>();\n-            func->name = context.getTable(select_database_name, select_table_name)->getName();\n-            manual_create_query->storage = func;\n-        }\n-        else\n-            manual_create_query->storage = create.inner_storage;\n-\n+        manual_create_query->storage = create.inner_storage;\n         manual_create_query->children.push_back(manual_create_query->storage);\n \n         /// Execute the query.\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.reference b/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.reference\nindex 8fb767d89d52..37514bc429b3 100644\n--- a/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.reference\n+++ b/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.reference\n@@ -1,2 +1,6 @@\n 2014-01-02\t0\t0\t0000-00-00 00:00:00\t2014-01-02 03:04:06\n 1\t2014-01-02 03:04:06\n+0\n+0\n+0\n+0\ndiff --git a/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.sql b/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.sql\nindex a3f475d2f25c..772ac54d830c 100644\n--- a/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.sql\n+++ b/dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.sql\n@@ -11,3 +11,28 @@ SELECT * FROM default.test_view;\n \n DROP TABLE default.test_table;\n DROP TABLE default.test_view;\n+\n+-- Check only sophisticated constructors and desctructors:\n+\n+USE test;\n+DROP TABLE IF EXISTS tmp;\n+DROP TABLE IF EXISTS tmp_mv;\n+DROP TABLE IF EXISTS tmp_mv2;\n+DROP TABLE IF EXISTS `.inner.tmp_mv`;\n+DROP TABLE IF EXISTS `.inner.tmp_mv2`;\n+\n+CREATE TABLE tmp (date Date, name String) ENGINE = Memory;\n+CREATE MATERIALIZED VIEW tmp_mv ENGINE = AggregatingMergeTree(date, (date, name), 8192) AS SELECT date, name, countState() AS cc FROM tmp GROUP BY date, name;\n+CREATE TABLE tmp_mv2 AS tmp_mv;\n+CREATE TABLE tmp_mv3 AS tmp_mv ENGINE = Memory;\n+CREATE MATERIALIZED VIEW tmp_mv4 ENGINE = AggregatingMergeTree(date, date, 8192) POPULATE AS SELECT DISTINCT * FROM tmp_mv;\n+\n+DROP TABLE tmp_mv;\n+DROP TABLE tmp_mv2;\n+DROP TABLE tmp_mv3;\n+DROP TABLE tmp_mv4;\n+\n+EXISTS TABLE `.inner.tmp_mv`;\n+EXISTS TABLE `.inner.tmp_mv2`;\n+EXISTS TABLE `.inner.tmp_mv3`;\n+EXISTS TABLE `.inner.tmp_mv4`;\n",
  "problem_statement": "CREATE TABLE without Engine spec SIGSEGV\nHi, I was fiddling with MATERIALIZED VIEWs, and when I create a table by using MV schema without ENGINE spec it crashes. A minimal example would be something like:\r\n\r\n```sql\r\nCREATE TABLE tmp (date Date, name String) ENGINE ...;\r\nCREATE MATERIALIZED VIEW tmp_mv ENGINE = AggregatingMergeTree(date, (name), 8192) AS SELECT date, name, countState() AS cc FROM tmp GROUP BY name;\r\nCREATE TABLE IF NOT EXISTS tmp_mv_table AS tmp_mv;\r\n```\r\n\r\nCrashes with:\r\n\r\n```\r\n<Error> BaseDaemon: ########################################\r\n<Error> BaseDaemon: (from thread 118) Received signal Segmentation fault (11).\r\n<Error> BaseDaemon: Address: NULL pointer.\r\n<Error> BaseDaemon: 1. /usr/bin/clickhouse-server(DB::StorageView::StorageView(std::string const&, std::string const&, DB::Context&, std::shared_ptr<DB::IAST>&, std::shared_ptr<DB::NamesAndTypesList>, DB::NamesAndTypesList const&, DB::NamesAndTypesList const&, std::unordered_map<std::string, DB::ColumnDefault, std::hash<std::string>, std::equal_to<std::string>, std::allocator<std::pair<std::string const, DB::ColumnDefault> > > const&)+0x428) [0x12ef6a8]\r\n<Error> BaseDaemon: 2. /usr/bin/clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x96) [0x325d216]\r\n<Error> BaseDaemon: 3. /lib/x86_64-linux-gnu/libpthread.so.0(+0x8064) [0x7f4e62c7f064]\r\n<Error> BaseDaemon: 4. /lib/x86_64-linux-gnu/libc.so.6(clone+0x6d) [0x7f4e622a762d]\r\n```\r\n\r\nIt's the last stable 1.1.54180.\r\n\r\nIt works when I create the the table from MV as:\r\n\r\n```sql\r\nCREATE TABLE IF NOT EXISTS tmp_mv_table AS tmp_mv ENGINE = ...;\r\n```\nSegfault on CREATE VIEW query\nCreating a new view based on another materialised view (based on MergeTree-Engine tables) results in a segmentation fault. The query looks like this:\r\n\r\n> CREATE MATERIALIZED VIEW yt.videoid_lookup POPULATE AS SELECT DISTINCT id, channel_id from videos\r\n\r\nThe error log looks like this:\r\n```\r\n2017.08.17 10:41:18.804826 [ 1 ] <Warning> ConfigProcessor: Include not found: networks\r\n2017.08.17 10:41:18.804876 [ 1 ] <Warning> ConfigProcessor: Include not found: networks\r\n2017.08.17 10:41:20.804800 [ 7 ] <Warning> ConfigProcessor: Include not found: clickhouse_remote_servers\r\n2017.08.17 10:41:20.804902 [ 7 ] <Warning> ConfigProcessor: Include not found: clickhouse_compression\r\n2017.08.17 10:41:24.088431 [ 9 ] <Error> BaseDaemon: ########################################\r\n2017.08.17 10:41:24.088517 [ 9 ] <Error> BaseDaemon: (from thread 8) Received signal Segmentation fault (11).\r\n2017.08.17 10:41:24.088567 [ 9 ] <Error> BaseDaemon: Address: NULL pointer.\r\n2017.08.17 10:41:24.093478 [ 9 ] <Error> BaseDaemon: 1. clickhouse-server(std::enable_if<std::is_reference<DB::ASTSelectQuery&>::value, DB::ASTSelectQuery&>::type typeid_cast<DB::ASTSelectQuery&, DB::IAST>(DB::IAST&)+0x13) [0x27cc6a3]\r\n2017.08.17 10:41:24.093512 [ 9 ] <Error> BaseDaemon: 2. clickhouse-server(Poco::ThreadImpl::runnableEntry(void*)+0x96) [0x31c19c6]\r\n2017.08.17 10:41:24.093529 [ 9 ] <Error> BaseDaemon: 3. /lib64/libpthread.so.0(+0x7dc5) [0x7f7f22fbcdc5]\r\n2017.08.17 10:41:24.093556 [ 9 ] <Error> BaseDaemon: 4. /lib64/libc.so.6(clone+0x6d) [0x7f7f2088f76d]\r\n```\n",
  "hints_text": "Ok. Thank you for the report.\r\n\r\nBut it is not clear for me what such clause should  do\r\n```\r\nCREATE TABLE IF NOT EXISTS tmp_mv_table AS tmp_mv;\r\n```\r\n\r\nEither materialized view\r\n```\r\nCREATE TABLE tmp_mv_table (date Date, name String, cc AggregateFunction(count)) ENGINE = AggregatingMergeTree(date, (name), 8192)\r\n```\r\n, either ordinary table with MV schema\r\n```\r\nCREATE MATERIALIZED VIEW tmp_mv_table ENGINE = AggregatingMergeTree(date, (name), 8192) AS SELECT date, name, countState() AS cc FROM tmp GROUP BY name;\r\n```\r\n\r\nCurrently\r\n```\r\nCREATE TABLE IF NOT EXISTS tmp_mv_table AS tmp_mv ENGINE = ...;\r\n``` \r\ncreates ordinary table with specified engine.\r\nBut for me it is more logically to create MV with specified engine.\r\nIf engine isn't specified, it will use the same engine as tmp_mv.\nMy expectation was that `CREATE TABLE IF NOT EXISTS tmp_mv_table AS tmp_mv` creates a table that reuses the same engine as the MV (AggregatingMergeTree), but it's perfectly fine if it requires me to say explicitly what the engine should be. It just shouldn't crash the CH.\nYes, of course -)\r\nI just needed an opinion about the semantics.\nSure :) I'd vote for: when the statment says `CREATE TABLE`, it should create a table and not MV.\r\nThe MVs are really cool by the way, really cheap way how to do rollups.\nSimilar problem https://github.com/yandex/ClickHouse/issues/598\nok, then I'll close this one.",
  "created_at": "2017-08-18T20:58:36Z",
  "modified_files": [
    "dbms/src/Interpreters/InterpreterCreateQuery.cpp",
    "dbms/src/Parsers/ParserCreateQuery.cpp",
    "dbms/src/Storages/StorageMaterializedView.cpp"
  ],
  "modified_test_files": [
    "dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.reference",
    "dbms/tests/queries/0_stateless/00101_materialized_views_and_insert_without_explicit_database.sql"
  ]
}