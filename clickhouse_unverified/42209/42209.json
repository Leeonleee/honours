{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42209,
  "instance_id": "ClickHouse__ClickHouse-42209",
  "issue_numbers": [
    "42189"
  ],
  "base_commit": "3ed11c7a7bf58ceb5962c4628dea94e428987c4c",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 99c14ede3e2d..8ffd1059a58d 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -29,6 +29,7 @@\n #include <Storages/KeyDescription.h>\n #include <Storages/MergeTree/MergeTreeIndexUtils.h>\n \n+#include <algorithm>\n #include <cassert>\n #include <stack>\n #include <limits>\n@@ -55,10 +56,15 @@ String Range::toString() const\n }\n \n \n-/// Example: for `Hello\\_World% ...` string it returns `Hello_World`, and for `%test%` returns an empty string.\n-String extractFixedPrefixFromLikePattern(const String & like_pattern)\n+/// Returns the prefix of like_pattern before the first wildcard, e.g. 'Hello\\_World% ...' --> 'Hello\\_World'\n+/// We call a pattern \"perfect prefix\" if:\n+/// - (1) the pattern has a wildcard\n+/// - (2) the first wildcard is '%' and is only followed by nothing or other '%'\n+/// e.g. 'test%' or 'test%% has perfect prefix 'test', 'test%x', 'test%_' or 'test_' has no perfect prefix.\n+String extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool requires_perfect_prefix)\n {\n     String fixed_prefix;\n+    fixed_prefix.reserve(like_pattern.size());\n \n     const char * pos = like_pattern.data();\n     const char * end = pos + like_pattern.size();\n@@ -67,10 +73,13 @@ String extractFixedPrefixFromLikePattern(const String & like_pattern)\n         switch (*pos)\n         {\n             case '%':\n-                [[fallthrough]];\n             case '_':\n+                if (requires_perfect_prefix)\n+                {\n+                    bool is_prefect_prefix = std::all_of(pos, end, [](auto c) { return c == '%'; });\n+                    return is_prefect_prefix ? fixed_prefix : \"\";\n+                }\n                 return fixed_prefix;\n-\n             case '\\\\':\n                 ++pos;\n                 if (pos == end)\n@@ -78,12 +87,13 @@ String extractFixedPrefixFromLikePattern(const String & like_pattern)\n                 [[fallthrough]];\n             default:\n                 fixed_prefix += *pos;\n-                break;\n         }\n \n         ++pos;\n     }\n-\n+    /// If we can reach this code, it means there was no wildcard found in the pattern, so it is not a perfect prefix\n+    if (requires_perfect_prefix)\n+        return \"\";\n     return fixed_prefix;\n }\n \n@@ -346,7 +356,7 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n             if (value.getType() != Field::Types::String)\n                 return false;\n \n-            String prefix = extractFixedPrefixFromLikePattern(value.get<const String &>());\n+            String prefix = extractFixedPrefixFromLikePattern(value.get<const String &>(), /*requires_perfect_prefix*/ false);\n             if (prefix.empty())\n                 return false;\n \n@@ -360,6 +370,27 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n             return true;\n         }\n     },\n+    {\n+        \"notLike\",\n+        [] (RPNElement & out, const Field & value)\n+        {\n+            if (value.getType() != Field::Types::String)\n+                return false;\n+\n+            String prefix = extractFixedPrefixFromLikePattern(value.get<const String &>(), /*requires_perfect_prefix*/ true);\n+            if (prefix.empty())\n+                return false;\n+\n+            String right_bound = firstStringThatIsGreaterThanAllStringsWithPrefix(prefix);\n+\n+            out.function = RPNElement::FUNCTION_NOT_IN_RANGE;\n+            out.range = !right_bound.empty()\n+                ? Range(prefix, true, right_bound, false)\n+                : Range::createLeftBounded(prefix, true);\n+\n+            return true;\n+        }\n+    },\n     {\n         \"startsWith\",\n         [] (RPNElement & out, const Field & value)\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex fe1bffa9305f..138dce83db96 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -485,6 +485,6 @@ class KeyCondition\n     bool strict;\n };\n \n-String extractFixedPrefixFromLikePattern(const String & like_pattern);\n+String extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool requires_perfect_prefix);\n \n }\ndiff --git a/src/Storages/System/StorageSystemMergeTreeMetadataCache.cpp b/src/Storages/System/StorageSystemMergeTreeMetadataCache.cpp\nindex 275365648f3c..731cdf941578 100644\n--- a/src/Storages/System/StorageSystemMergeTreeMetadataCache.cpp\n+++ b/src/Storages/System/StorageSystemMergeTreeMetadataCache.cpp\n@@ -116,7 +116,7 @@ void StorageSystemMergeTreeMetadataCache::fillData(MutableColumns & res_columns,\n     }\n     else\n     {\n-        String target = extractFixedPrefixFromLikePattern(key);\n+        String target = extractFixedPrefixFromLikePattern(key, /*requires_perfect_prefix*/ false);\n         if (target.empty())\n             throw Exception(\n                 \"SELECT from system.merge_tree_metadata_cache table must contain condition like key = 'key' or key LIKE 'prefix%' in WHERE clause.\", ErrorCodes::BAD_ARGUMENTS);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02458_key_condition_not_like_prefix.reference b/tests/queries/0_stateless/02458_key_condition_not_like_prefix.reference\nnew file mode 100644\nindex 000000000000..02357561e024\n--- /dev/null\n+++ b/tests/queries/0_stateless/02458_key_condition_not_like_prefix.reference\n@@ -0,0 +1,2 @@\n+200000\n+200000\ndiff --git a/tests/queries/0_stateless/02458_key_condition_not_like_prefix.sql b/tests/queries/0_stateless/02458_key_condition_not_like_prefix.sql\nnew file mode 100644\nindex 000000000000..e821b16ed5ca\n--- /dev/null\n+++ b/tests/queries/0_stateless/02458_key_condition_not_like_prefix.sql\n@@ -0,0 +1,12 @@\n+CREATE TABLE data (str String) ENGINE=MergeTree ORDER BY str;\n+INSERT INTO data (str) SELECT 'aa' FROM numbers(100000);\n+INSERT INTO data (str) SELECT 'ba' FROM numbers(100000);\n+INSERT INTO data (str) SELECT 'ca' FROM numbers(100000);\n+SELECT count() FROM data WHERE str NOT LIKE 'a%' SETTINGS force_primary_key=1;\n+SELECT count() FROM data WHERE str NOT LIKE 'a%%' SETTINGS force_primary_key=1;\n+SELECT count() FROM data WHERE str NOT LIKE 'a' SETTINGS force_primary_key=1; -- { serverError 277 }\n+SELECT count() FROM data WHERE str NOT LIKE '%a' SETTINGS force_primary_key=1; -- { serverError 277 }\n+SELECT count() FROM data WHERE str NOT LIKE 'a_' SETTINGS force_primary_key=1; -- { serverError 277 }\n+SELECT count() FROM data WHERE str NOT LIKE 'a%_' SETTINGS force_primary_key=1; -- { serverError 277 }\n+SELECT count() FROM data WHERE str NOT LIKE '_a' SETTINGS force_primary_key=1; -- { serverError 277 }\n+SELECT count() FROM data WHERE str NOT LIKE 'a%\\_' SETTINGS force_primary_key=1; -- { serverError 277 }\n",
  "problem_statement": "Primary key is not used for NOT LIKE 'prefix%'\nAccording to the following page, a primary key is used for both LIKE and NOT LIKE conditions:\r\nhttps://clickhouse.com/docs/en/engines/table-engines/mergetree-family/mergetree/#functions-support\r\n\r\nAs I found, a primary key is not used for NOT LIKE 'prefix%' conditions, engine scans all granules.\r\n\r\n**How to reproduce**\r\nClickHouse Playground:\r\nhttps://fiddle.clickhouse.com/095384c8-7b7e-45ec-b7e7-42dc8150be89\r\n\r\n```\r\nCREATE TABLE data\r\n(str String)\r\nENGINE=MergeTree\r\nORDER BY str;\r\n\r\nINSERT INTO data (str)\r\nSELECT 'aa' FROM numbers(100000);\r\n\r\nINSERT INTO data (str)\r\nSELECT 'ba' FROM numbers(100000);\r\n\r\nINSERT INTO data (str)\r\nSELECT 'ca' FROM numbers(100000);\r\n\r\nSET send_logs_level='trace';\r\n\r\nSELECT count()\r\nFROM data\r\nWHERE str NOT LIKE 'a%';\r\n```\r\n\r\n`(SelectExecutor): Selected 3/3 parts by partition key, 3 parts by primary key, 36/36 marks by primary key, 36 marks to read from 3 ranges`\r\n\r\n**Additional context**\r\nPrimary key is used for LIKE conditions, engine skips granules:\r\nhttps://fiddle.clickhouse.com/95dd14a6-2e9f-4c45-94cd-169233f2a702\r\n\r\nPrimary key is used for != conditions, engine skips granules:\r\nhttps://fiddle.clickhouse.com/e208b937-20c3-4cc0-896b-bfe83b42454a\r\n\n",
  "hints_text": "",
  "created_at": "2022-10-10T05:33:04Z"
}