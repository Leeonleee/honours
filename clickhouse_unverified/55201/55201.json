{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 55201,
  "instance_id": "ClickHouse__ClickHouse-55201",
  "issue_numbers": [
    "54821"
  ],
  "base_commit": "2f1d4f094b4d9964f364f9e321fef14ed92a110d",
  "patch": "diff --git a/docs/en/engines/table-engines/mergetree-family/mergetree.md b/docs/en/engines/table-engines/mergetree-family/mergetree.md\nindex 9c9caee0e474..f185c11bab37 100644\n--- a/docs/en/engines/table-engines/mergetree-family/mergetree.md\n+++ b/docs/en/engines/table-engines/mergetree-family/mergetree.md\n@@ -39,8 +39,8 @@ If you need to update rows frequently, we recommend using the [`ReplacingMergeTr\n ``` sql\n CREATE TABLE [IF NOT EXISTS] [db.]table_name [ON CLUSTER cluster]\n (\n-    name1 [type1] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr1] [COMMENT ...] [CODEC(codec1)] [STATISTIC(stat1)] [TTL expr1] [PRIMARY KEY],\n-    name2 [type2] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr2] [COMMENT ...] [CODEC(codec2)] [STATISTIC(stat2)] [TTL expr2] [PRIMARY KEY],\n+    name1 [type1] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr1] [COMMENT ...] [CODEC(codec1)] [STATISTIC(stat1)] [TTL expr1] [PRIMARY KEY] [SETTINGS (name = value, ...)],\n+    name2 [type2] [[NOT] NULL] [DEFAULT|MATERIALIZED|ALIAS|EPHEMERAL expr2] [COMMENT ...] [CODEC(codec2)] [STATISTIC(stat2)] [TTL expr2] [PRIMARY KEY] [SETTINGS (name = value, ...)],\n     ...\n     INDEX index_name1 expr1 TYPE type1(...) [GRANULARITY value1],\n     INDEX index_name2 expr2 TYPE type2(...) [GRANULARITY value2],\n@@ -56,7 +56,7 @@ ORDER BY expr\n     [DELETE|TO DISK 'xxx'|TO VOLUME 'xxx' [, ...] ]\n     [WHERE conditions]\n     [GROUP BY key_expr [SET v1 = aggr_func(v1) [, v2 = aggr_func(v2) ...]] ] ]\n-[SETTINGS name=value, ...]\n+[SETTINGS name = value, ...]\n ```\n \n For a description of parameters, see the [CREATE query description](/docs/en/sql-reference/statements/create/table.md).\n@@ -620,7 +620,7 @@ The `TTL` clause can\u2019t be used for key columns.\n #### Creating a table with `TTL`:\n \n ``` sql\n-CREATE TABLE example_table\n+CREATE TABLE tab\n (\n     d DateTime,\n     a Int TTL d + INTERVAL 1 MONTH,\n@@ -635,7 +635,7 @@ ORDER BY d;\n #### Adding TTL to a column of an existing table\n \n ``` sql\n-ALTER TABLE example_table\n+ALTER TABLE tab\n     MODIFY COLUMN\n     c String TTL d + INTERVAL 1 DAY;\n ```\n@@ -643,7 +643,7 @@ ALTER TABLE example_table\n #### Altering TTL of the column\n \n ``` sql\n-ALTER TABLE example_table\n+ALTER TABLE tab\n     MODIFY COLUMN\n     c String TTL d + INTERVAL 1 MONTH;\n ```\n@@ -681,7 +681,7 @@ If a column is not part of the `GROUP BY` expression and is not set explicitly i\n #### Creating a table with `TTL`:\n \n ``` sql\n-CREATE TABLE example_table\n+CREATE TABLE tab\n (\n     d DateTime,\n     a Int\n@@ -697,7 +697,7 @@ TTL d + INTERVAL 1 MONTH DELETE,\n #### Altering `TTL` of the table:\n \n ``` sql\n-ALTER TABLE example_table\n+ALTER TABLE tab\n     MODIFY TTL d + INTERVAL 1 DAY;\n ```\n \n@@ -1366,7 +1366,7 @@ In this sample configuration:\n The statistic declaration is in the columns section of the `CREATE` query for tables from the `*MergeTree*` Family when we enable `set allow_experimental_statistic = 1`.\n \n ``` sql\n-CREATE TABLE example_table\n+CREATE TABLE tab\n (\n     a Int64 STATISTIC(tdigest),\n     b Float64\n@@ -1378,8 +1378,8 @@ ORDER BY a\n We can also manipulate statistics with `ALTER` statements.\n \n ```sql\n-ALTER TABLE example_table ADD STATISTIC b TYPE tdigest;\n-ALTER TABLE example_table DROP STATISTIC a TYPE tdigest;\n+ALTER TABLE tab ADD STATISTIC b TYPE tdigest;\n+ALTER TABLE tab DROP STATISTIC a TYPE tdigest;\n ```\n \n These lightweight statistics aggregate information about distribution of values in columns.\n@@ -1390,3 +1390,42 @@ They can be used for query optimization when we enable `set allow_statistic_opti\n -   `tdigest`\n \n     Stores distribution of values from numeric columns in [TDigest](https://github.com/tdunning/t-digest) sketch.\n+\n+## Column-level Settings {#column-level-settings}\n+\n+Certain MergeTree settings can be override at column level:\n+\n+- `max_compress_block_size` \u2014 Maximum size of blocks of uncompressed data before compressing for writing to a table.\n+- `min_compress_block_size` \u2014 Minimum size of blocks of uncompressed data required for compression when writing the next mark.\n+\n+Example:\n+\n+```sql\n+CREATE TABLE tab\n+(\n+    id Int64,\n+    document String SETTINGS (min_compress_block_size = 16777216, max_compress_block_size = 16777216)\n+)\n+ENGINE = MergeTree\n+ORDER BY id\n+```\n+\n+Column-level settings can be modified or removed using [ALTER MODIFY COLUMN](/docs/en/sql-reference/statements/alter/column.md), for example:\n+\n+- Remove `SETTINGS` from column declaration:\n+\n+```sql\n+ALTER TABLE tab MODIFY COLUMN document REMOVE SETTINGS;\n+```\n+\n+- Modify a setting:\n+\n+```sql\n+ALTER TABLE tab MODIFY COLUMN document MODIFY SETTING min_compress_block_size = 8192;\n+```\n+\n+- Reset one or more settings, also removes the setting declaration in the column expression of the table's CREATE query.\n+\n+```sql\n+ALTER TABLE tab MODIFY COLUMN document RESET SETTING min_compress_block_size;\n+```\ndiff --git a/docs/en/sql-reference/statements/alter/column.md b/docs/en/sql-reference/statements/alter/column.md\nindex 2cb802c863be..676d30f5e447 100644\n--- a/docs/en/sql-reference/statements/alter/column.md\n+++ b/docs/en/sql-reference/statements/alter/column.md\n@@ -23,10 +23,11 @@ The following actions are supported:\n - [RENAME COLUMN](#rename-column) \u2014 Renames an existing column.\n - [CLEAR COLUMN](#clear-column) \u2014 Resets column values.\n - [COMMENT COLUMN](#comment-column) \u2014 Adds a text comment to the column.\n-- [MODIFY COLUMN](#modify-column) \u2014 Changes column\u2019s type, default expression and TTL.\n+- [MODIFY COLUMN](#modify-column) \u2014 Changes column\u2019s type, default expression, TTL, and column settings.\n - [MODIFY COLUMN REMOVE](#modify-column-remove) \u2014 Removes one of the column properties.\n+- [MODIFY COLUMN MODIFY SETTING](#modify-column-modify-setting) - Changes column settings.\n+- [MODIFY COLUMN RESET SETTING](#modify-column-reset-setting) - Reset column settings.\n - [MATERIALIZE COLUMN](#materialize-column) \u2014 Materializes the column in the parts where the column is missing.\n-\n These actions are described in detail below.\n \n ## ADD COLUMN\n@@ -75,7 +76,7 @@ Deletes the column with the name `name`. If the `IF EXISTS` clause is specified,\n \n Deletes data from the file system. Since this deletes entire files, the query is completed almost instantly.\n \n-:::tip    \n+:::tip\n You can\u2019t delete a column if it is referenced by [materialized view](/docs/en/sql-reference/statements/create/view.md/#materialized). Otherwise, it returns an error.\n :::\n \n@@ -208,7 +209,7 @@ The `ALTER` query for changing columns is replicated. The instructions are saved\n \n ## MODIFY COLUMN REMOVE\n \n-Removes one of the column properties: `DEFAULT`, `ALIAS`, `MATERIALIZED`, `CODEC`, `COMMENT`, `TTL`.\n+Removes one of the column properties: `DEFAULT`, `ALIAS`, `MATERIALIZED`, `CODEC`, `COMMENT`, `TTL`, `SETTING`.\n \n Syntax:\n \n@@ -228,6 +229,43 @@ ALTER TABLE table_with_ttl MODIFY COLUMN column_ttl REMOVE TTL;\n \n - [REMOVE TTL](ttl.md).\n \n+\n+## MODIFY COLUMN MODIFY SETTING\n+\n+Modify a column setting.\n+\n+Syntax:\n+\n+```sql\n+ALTER TABLE table_name MODIFY COLUMN MODIFY SETTING name=value,...;\n+```\n+\n+**Example**\n+\n+Modify column's `max_compress_block_size` to `1MB`:\n+\n+```sql\n+ALTER TABLE table_name MODIFY COLUMN MODIFY SETTING max_compress_block_size = 1048576;\n+```\n+\n+## MODIFY COLUMN RESET SETTING\n+\n+Reset a column setting, also removes the setting declaration in the column expression of the table's CREATE query.\n+\n+Syntax:\n+\n+```sql\n+ALTER TABLE table_name MODIFY COLUMN RESET SETTING name,...;\n+```\n+\n+**Example**\n+\n+Remove column setting `max_compress_block_size` to `1MB`:\n+\n+```sql\n+ALTER TABLE table_name MODIFY COLUMN REMOVE SETTING max_compress_block_size;\n+```\n+\n ## MATERIALIZE COLUMN\n \n Materializes or updates a column with an expression for a default value (`DEFAULT` or `MATERIALIZED`).\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex 36e864ace26b..d002cc6d9806 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -11,6 +11,8 @@\n #include <Common/atomicRename.h>\n #include <Common/PoolId.h>\n #include <Common/logger_useful.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Storages/MergeTree/MergeTreeSettings.h>\n #include <base/hex.h>\n \n #include <Core/Defines.h>\n@@ -463,6 +465,14 @@ ASTPtr InterpreterCreateQuery::formatColumns(const ColumnsDescription & columns)\n             column_declaration->children.push_back(column_declaration->ttl);\n         }\n \n+        if (!column.settings.empty())\n+        {\n+            auto settings = std::make_shared<ASTSetQuery>();\n+            settings->is_standalone = false;\n+            settings->changes = column.settings;\n+            column_declaration->settings = std::move(settings);\n+        }\n+\n         columns_list->children.push_back(column_declaration_ptr);\n     }\n \n@@ -670,6 +680,12 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n         if (col_decl.ttl)\n             column.ttl = col_decl.ttl;\n \n+        if (col_decl.settings)\n+        {\n+            column.settings = col_decl.settings->as<ASTSetQuery &>().changes;\n+            MergeTreeColumnSettings::validate(column.settings);\n+        }\n+\n         res.add(std::move(column));\n     }\n \ndiff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp\nindex b0d812eec6be..6c29e0bf9d5f 100644\n--- a/src/Parsers/ASTColumnDeclaration.cpp\n+++ b/src/Parsers/ASTColumnDeclaration.cpp\n@@ -57,70 +57,83 @@ ASTPtr ASTColumnDeclaration::clone() const\n         res->children.push_back(res->collation);\n     }\n \n+    if (settings)\n+    {\n+        res->settings = settings->clone();\n+        res->children.push_back(res->settings);\n+    }\n+\n     return res;\n }\n \n-void ASTColumnDeclaration::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const\n+void ASTColumnDeclaration::formatImpl(const FormatSettings & format_settings, FormatState & state, FormatStateStacked frame) const\n {\n     frame.need_parens = false;\n \n     /// We have to always backquote column names to avoid ambiguouty with INDEX and other declarations in CREATE query.\n-    settings.ostr << backQuote(name);\n+    format_settings.ostr << backQuote(name);\n \n     if (type)\n     {\n-        settings.ostr << ' ';\n+        format_settings.ostr << ' ';\n \n         FormatStateStacked type_frame = frame;\n         type_frame.indent = 0;\n \n-        type->formatImpl(settings, state, type_frame);\n+        type->formatImpl(format_settings, state, type_frame);\n     }\n \n     if (null_modifier)\n     {\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\")\n-                      << (*null_modifier ? \"\" : \"NOT \") << \"NULL\" << (settings.hilite ? hilite_none : \"\");\n+        format_settings.ostr << ' ' << (format_settings.hilite ? hilite_keyword : \"\")\n+                      << (*null_modifier ? \"\" : \"NOT \") << \"NULL\" << (format_settings.hilite ? hilite_none : \"\");\n     }\n \n     if (default_expression)\n     {\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << default_specifier << (settings.hilite ? hilite_none : \"\");\n+        format_settings.ostr << ' ' << (format_settings.hilite ? hilite_keyword : \"\") << default_specifier << (format_settings.hilite ? hilite_none : \"\");\n         if (!ephemeral_default)\n         {\n-            settings.ostr << ' ';\n-            default_expression->formatImpl(settings, state, frame);\n+            format_settings.ostr << ' ';\n+            default_expression->formatImpl(format_settings, state, frame);\n         }\n     }\n \n     if (comment)\n     {\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"COMMENT\" << (settings.hilite ? hilite_none : \"\") << ' ';\n-        comment->formatImpl(settings, state, frame);\n+        format_settings.ostr << ' ' << (format_settings.hilite ? hilite_keyword : \"\") << \"COMMENT\" << (format_settings.hilite ? hilite_none : \"\") << ' ';\n+        comment->formatImpl(format_settings, state, frame);\n     }\n \n     if (codec)\n     {\n-        settings.ostr << ' ';\n-        codec->formatImpl(settings, state, frame);\n+        format_settings.ostr << ' ';\n+        codec->formatImpl(format_settings, state, frame);\n     }\n \n     if (stat_type)\n     {\n-        settings.ostr << ' ';\n-        stat_type->formatImpl(settings, state, frame);\n+        format_settings.ostr << ' ';\n+        stat_type->formatImpl(format_settings, state, frame);\n     }\n \n     if (ttl)\n     {\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"TTL\" << (settings.hilite ? hilite_none : \"\") << ' ';\n-        ttl->formatImpl(settings, state, frame);\n+        format_settings.ostr << ' ' << (format_settings.hilite ? hilite_keyword : \"\") << \"TTL\" << (format_settings.hilite ? hilite_none : \"\") << ' ';\n+        ttl->formatImpl(format_settings, state, frame);\n     }\n \n     if (collation)\n     {\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"COLLATE\" << (settings.hilite ? hilite_none : \"\") << ' ';\n-        collation->formatImpl(settings, state, frame);\n+        format_settings.ostr << ' ' << (format_settings.hilite ? hilite_keyword : \"\") << \"COLLATE\" << (format_settings.hilite ? hilite_none : \"\") << ' ';\n+        collation->formatImpl(format_settings, state, frame);\n+    }\n+\n+    if (settings)\n+    {\n+        format_settings.ostr << ' ' << (format_settings.hilite ? hilite_keyword : \"\") << \"SETTINGS\" << (format_settings.hilite ? hilite_none : \"\") << ' ' << '(';\n+        settings->formatImpl(format_settings, state, frame);\n+        format_settings.ostr << ')';\n     }\n }\n \ndiff --git a/src/Parsers/ASTColumnDeclaration.h b/src/Parsers/ASTColumnDeclaration.h\nindex a54abae97ead..d775928d05c0 100644\n--- a/src/Parsers/ASTColumnDeclaration.h\n+++ b/src/Parsers/ASTColumnDeclaration.h\n@@ -22,12 +22,13 @@ class ASTColumnDeclaration : public IAST\n     ASTPtr stat_type;\n     ASTPtr ttl;\n     ASTPtr collation;\n+    ASTPtr settings;\n     bool primary_key_specifier = false;\n \n     String getID(char delim) const override { return \"ColumnDeclaration\" + (delim + name); }\n \n     ASTPtr clone() const override;\n-    void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n+    void formatImpl(const FormatSettings & format_settings, FormatState & state, FormatStateStacked frame) const override;\n };\n \n }\ndiff --git a/src/Parsers/ParserAlterQuery.cpp b/src/Parsers/ParserAlterQuery.cpp\nindex 8afab927d185..d72fb4933683 100644\n--- a/src/Parsers/ParserAlterQuery.cpp\n+++ b/src/Parsers/ParserAlterQuery.cpp\n@@ -111,6 +111,7 @@ bool ParserAlterCommand::parseImpl(Pos & pos, ASTPtr & node, Expected & expected\n     ParserKeyword s_comment(\"COMMENT\");\n     ParserKeyword s_codec(\"CODEC\");\n     ParserKeyword s_ttl(\"TTL\");\n+    ParserKeyword s_settings(\"SETTINGS\");\n \n     ParserKeyword s_remove_ttl(\"REMOVE TTL\");\n     ParserKeyword s_remove_sample_by(\"REMOVE SAMPLE BY\");\n@@ -725,9 +726,21 @@ bool ParserAlterCommand::parseImpl(Pos & pos, ASTPtr & node, Expected & expected\n                         command->remove_property = \"CODEC\";\n                     else if (s_ttl.ignore(pos, expected))\n                         command->remove_property = \"TTL\";\n+                    else if (s_settings.ignore(pos, expected))\n+                        command->remove_property = \"SETTINGS\";\n                     else\n                         return false;\n                 }\n+                else if (s_modify_setting.ignore(pos, expected))\n+                {\n+                    if (!parser_settings.parse(pos, command_settings_changes, expected))\n+                        return false;\n+                }\n+                else if (s_reset_setting.ignore(pos, expected))\n+                {\n+                    if (!parser_reset_setting.parse(pos, command_settings_resets, expected))\n+                        return false;\n+                }\n                 else\n                 {\n                     if (s_first.ignore(pos, expected))\ndiff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h\nindex 910ee0484421..c9059324bbe5 100644\n--- a/src/Parsers/ParserCreateQuery.h\n+++ b/src/Parsers/ParserCreateQuery.h\n@@ -10,6 +10,7 @@\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/IParserBase.h>\n #include <Parsers/ParserDataType.h>\n+#include <Parsers/ParserSetQuery.h>\n #include <Poco/String.h>\n \n namespace DB\n@@ -120,8 +121,6 @@ using ParserCompoundColumnDeclaration = IParserColumnDeclaration<ParserCompoundI\n template <typename NameParser>\n bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    NameParser name_parser;\n-    ParserDataType type_parser;\n     ParserKeyword s_default{\"DEFAULT\"};\n     ParserKeyword s_null{\"NULL\"};\n     ParserKeyword s_not{\"NOT\"};\n@@ -134,9 +133,15 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_stat{\"STATISTIC\"};\n     ParserKeyword s_ttl{\"TTL\"};\n     ParserKeyword s_remove{\"REMOVE\"};\n+    ParserKeyword s_modify_setting(\"MODIFY SETTING\");\n+    ParserKeyword s_reset_setting(\"RESET SETTING\");\n+    ParserKeyword s_settings(\"SETTINGS\");\n     ParserKeyword s_type{\"TYPE\"};\n     ParserKeyword s_collate{\"COLLATE\"};\n     ParserKeyword s_primary_key{\"PRIMARY KEY\"};\n+\n+    NameParser name_parser;\n+    ParserDataType type_parser;\n     ParserExpression expr_parser;\n     ParserStringLiteral string_literal_parser;\n     ParserLiteral literal_parser;\n@@ -144,6 +149,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserCollation collation_parser;\n     ParserStatisticType stat_type_parser;\n     ParserExpression expression_parser;\n+    ParserSetQuery settings_parser(true);\n \n     /// mandatory column name\n     ASTPtr name;\n@@ -155,11 +161,12 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n \n     /// This keyword may occur only in MODIFY COLUMN query. We check it here\n     /// because ParserDataType parses types as an arbitrary identifiers and\n-    /// doesn't check that parsed string is existing data type. In this way\n-    /// REMOVE keyword can be parsed as data type and further parsing will fail.\n-    /// So we just check this keyword and in case of success return column\n-    /// declaration with name only.\n-    if (!require_type && s_remove.checkWithoutMoving(pos, expected))\n+    /// doesn't check that parsed string is existing data type. In this way,\n+    /// REMOVE, MODIFY SETTING, or RESET SETTING can be parsed as data type\n+    /// and further parsing will fail. So we just check these keyword and in\n+    /// case of success return column declaration with name only.\n+    if (!require_type\n+        && (s_remove.checkWithoutMoving(pos, expected) || s_modify_setting.checkWithoutMoving(pos, expected) || s_reset_setting.checkWithoutMoving(pos, expected)))\n     {\n         if (!check_keywords_after_name)\n             return false;\n@@ -181,6 +188,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ASTPtr stat_type_expression;\n     ASTPtr ttl_expression;\n     ASTPtr collation_expression;\n+    ASTPtr settings;\n     bool primary_key_specifier = false;\n \n     auto null_check_without_moving = [&]() -> bool\n@@ -321,6 +329,28 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n         primary_key_specifier = true;\n     }\n \n+    auto old_pos = pos;\n+    if (s_settings.ignore(pos, expected))\n+    {\n+        /// When the keyword `SETTINGS` appear here, it can be a column settings declaration or query settings\n+        /// For example:\n+        /// - Column settings: `ALTER TABLE xx MODIFY COLUMN yy <new_type> SETTINGS (name = value)`\n+        /// - Query settings: ` ALTER TABLE xx MODIFY COLUMN yy <new_type> SETTINGS mutation_sync = 2`\n+        /// So after parsing keyword `SETTINGS`, we check if it's followed by an `(` then it's the column\n+        /// settings, otherwise it's the query settings and we need to move `pos` back to origin position.\n+        ParserToken parser_opening_bracket(TokenType::OpeningRoundBracket);\n+        if (parser_opening_bracket.ignore(pos, expected))\n+        {\n+            if (!settings_parser.parse(pos, settings, expected))\n+                return false;\n+            ParserToken parser_closing_bracket(TokenType::ClosingRoundBracket);\n+            if (!parser_closing_bracket.ignore(pos, expected))\n+                return false;\n+        }\n+        else\n+            pos = old_pos;\n+    }\n+\n     node = column_declaration;\n \n     if (type)\n@@ -351,6 +381,12 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n         column_declaration->children.push_back(std::move(codec_expression));\n     }\n \n+    if (settings)\n+    {\n+        column_declaration->settings = settings;\n+        column_declaration->children.push_back(std::move(settings));\n+    }\n+\n     if (stat_type_expression)\n     {\n         column_declaration->stat_type = stat_type_expression;\n@@ -362,6 +398,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n         column_declaration->ttl = ttl_expression;\n         column_declaration->children.push_back(std::move(ttl_expression));\n     }\n+\n     if (collation_expression)\n     {\n         column_declaration->collation = collation_expression;\ndiff --git a/src/Storages/AlterCommands.cpp b/src/Storages/AlterCommands.cpp\nindex ddd60fc81d25..766863ed9f9e 100644\n--- a/src/Storages/AlterCommands.cpp\n+++ b/src/Storages/AlterCommands.cpp\n@@ -36,6 +36,7 @@\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <Common/typeid_cast.h>\n #include <Common/randomSeed.h>\n+#include <Storages/MergeTree/MergeTreeSettings.h>\n \n #include <ranges>\n \n@@ -74,6 +75,8 @@ AlterCommand::RemoveProperty removePropertyFromString(const String & property)\n         return AlterCommand::RemoveProperty::CODEC;\n     else if (property == \"TTL\")\n         return AlterCommand::RemoveProperty::TTL;\n+    else if (property == \"SETTINGS\")\n+        return AlterCommand::RemoveProperty::SETTINGS;\n \n     throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Cannot remove unknown property '{}'\", property);\n }\n@@ -173,6 +176,25 @@ std::optional<AlterCommand> AlterCommand::parse(const ASTAlterCommand * command_\n         if (ast_col_decl.codec)\n             command.codec = ast_col_decl.codec;\n \n+        if (ast_col_decl.settings)\n+            command.settings_changes = ast_col_decl.settings->as<ASTSetQuery &>().changes;\n+\n+        /// At most only one of ast_col_decl.settings or command_ast->settings_changes is non-null\n+        if (command_ast->settings_changes)\n+        {\n+            command.settings_changes = command_ast->settings_changes->as<ASTSetQuery &>().changes;\n+            command.append_column_setting = true;\n+        }\n+\n+        if (command_ast->settings_resets)\n+        {\n+            for (const ASTPtr & identifier_ast : command_ast->settings_resets->children)\n+            {\n+                const auto & identifier = identifier_ast->as<ASTIdentifier &>();\n+                command.settings_resets.emplace(identifier.name());\n+            }\n+        }\n+\n         if (command_ast->column)\n             command.after_column = getIdentifierName(command_ast->column);\n \n@@ -501,6 +523,10 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)\n             {\n                 column.ttl.reset();\n             }\n+            else if (to_remove == RemoveProperty::SETTINGS)\n+            {\n+                column.settings.clear();\n+            }\n             else\n             {\n                 if (codec)\n@@ -515,6 +541,22 @@ void AlterCommand::apply(StorageInMemoryMetadata & metadata, ContextPtr context)\n                 if (data_type)\n                     column.type = data_type;\n \n+                if (!settings_changes.empty())\n+                {\n+                    MergeTreeColumnSettings::validate(settings_changes);\n+                    if (append_column_setting)\n+                        for (const auto & change : settings_changes)\n+                            column.settings.setSetting(change.name, change.value);\n+                    else\n+                        column.settings = settings_changes;\n+                }\n+\n+                if (!settings_resets.empty())\n+                {\n+                    for (const auto & setting : settings_resets)\n+                        column.settings.removeSetting(setting);\n+                }\n+\n                 /// User specified default expression or changed\n                 /// datatype. We have to replace default.\n                 if (default_expression || data_type)\n@@ -1357,7 +1399,6 @@ void AlterCommands::validate(const StoragePtr & table, ContextPtr context) const\n                         ErrorCodes::BAD_ARGUMENTS,\n                         \"Column {} doesn't have COMMENT, cannot remove it\",\n                         backQuote(column_name));\n-\n             }\n \n             modified_columns.emplace(column_name);\ndiff --git a/src/Storages/AlterCommands.h b/src/Storages/AlterCommands.h\nindex f40fdc954ec7..d0d5d02b5f7c 100644\n--- a/src/Storages/AlterCommands.h\n+++ b/src/Storages/AlterCommands.h\n@@ -64,7 +64,8 @@ struct AlterCommand\n         /// Other properties\n         COMMENT,\n         CODEC,\n-        TTL\n+        TTL,\n+        SETTINGS\n     };\n \n     Type type = UNKNOWN;\n@@ -137,10 +138,10 @@ struct AlterCommand\n     /// For ADD and MODIFY\n     ASTPtr codec = nullptr;\n \n-    /// For MODIFY SETTING\n+    /// For MODIFY SETTING or MODIFY COLUMN MODIFY SETTING\n     SettingsChanges settings_changes;\n \n-    /// For RESET SETTING\n+    /// For RESET SETTING or MODIFY COLUMN RESET SETTING\n     std::set<String> settings_resets;\n \n     /// For MODIFY_QUERY\n@@ -155,6 +156,9 @@ struct AlterCommand\n     /// What to remove from column (or TTL)\n     RemoveProperty to_remove = RemoveProperty::NO_PROPERTY;\n \n+    /// Is this MODIFY COLUMN MODIFY SETTING or MODIFY COLUMN column with settings declaration)\n+    bool append_column_setting = false;\n+\n     static std::optional<AlterCommand> parse(const ASTAlterCommand * command);\n \n     void apply(StorageInMemoryMetadata & metadata, ContextPtr context) const;\ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex 1712b9845966..d6a241da0324 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -24,6 +24,7 @@\n #include <Interpreters/Context.h>\n #include <Storages/IStorage.h>\n #include <Common/typeid_cast.h>\n+#include \"Parsers/ASTSetQuery.h\"\n #include <Core/Defines.h>\n #include <Compression/CompressionFactory.h>\n #include <Interpreters/ExpressionAnalyzer.h>\n@@ -72,6 +73,7 @@ bool ColumnDescription::operator==(const ColumnDescription & other) const\n         && default_desc == other.default_desc\n         && stat == other.stat\n         && ast_to_str(codec) == ast_to_str(other.codec)\n+        && settings == other.settings\n         && ast_to_str(ttl) == ast_to_str(other.ttl);\n }\n \n@@ -104,6 +106,18 @@ void ColumnDescription::writeText(WriteBuffer & buf) const\n         writeEscapedString(queryToString(codec), buf);\n     }\n \n+    if (!settings.empty())\n+    {\n+        writeChar('\\t', buf);\n+        DB::writeText(\"SETTINGS \", buf);\n+        DB::writeText(\"(\", buf);\n+        ASTSetQuery ast;\n+        ast.is_standalone = false;\n+        ast.changes = settings;\n+        writeEscapedString(queryToString(ast), buf);\n+        DB::writeText(\")\", buf);\n+    }\n+\n     if (stat)\n     {\n         writeChar('\\t', buf);\n@@ -154,6 +168,9 @@ void ColumnDescription::readText(ReadBuffer & buf)\n \n             if (col_ast->ttl)\n                 ttl = col_ast->ttl;\n+\n+            if (col_ast->settings)\n+                settings = col_ast->settings->as<ASTSetQuery &>().changes;\n         }\n         else\n             throw Exception(ErrorCodes::CANNOT_PARSE_TEXT, \"Cannot parse column description\");\ndiff --git a/src/Storages/ColumnsDescription.h b/src/Storages/ColumnsDescription.h\nindex 9a133f81d7af..59179aac17ad 100644\n--- a/src/Storages/ColumnsDescription.h\n+++ b/src/Storages/ColumnsDescription.h\n@@ -7,6 +7,7 @@\n #include <Core/NamesAndAliases.h>\n #include <Interpreters/Context_fwd.h>\n #include <Storages/ColumnDefault.h>\n+#include <Common/SettingsChanges.h>\n #include <Storages/StatisticsDescription.h>\n #include <Common/Exception.h>\n \n@@ -83,6 +84,7 @@ struct ColumnDescription\n     ColumnDefault default_desc;\n     String comment;\n     ASTPtr codec;\n+    SettingsChanges settings;\n     ASTPtr ttl;\n     std::optional<StatisticDescription> stat;\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\nindex d86ff3a17ff4..9d373504473d 100644\n--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp\n@@ -7,6 +7,7 @@\n #include <Columns/ColumnSparse.h>\n #include <Common/logger_useful.h>\n #include <Storages/BlockNumberColumn.h>\n+#include <Storages/ColumnsDescription.h>\n \n namespace DB\n {\n@@ -143,13 +144,22 @@ void MergeTreeDataPartWriterWide::addStreams(\n         auto ast = parseQuery(codec_parser, \"(\" + Poco::toUpper(settings.marks_compression_codec) + \")\", 0, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n         CompressionCodecPtr marks_compression_codec = CompressionCodecFactory::instance().get(ast, nullptr);\n \n+        const auto column_desc = metadata_snapshot->columns.tryGetColumnDescription(GetColumnsOptions(GetColumnsOptions::AllPhysical), column.getNameInStorage());\n+\n+        UInt64 max_compress_block_size = 0;\n+        if (column_desc)\n+            if (const auto * value = column_desc->settings.tryGet(\"max_compress_block_size\"))\n+                max_compress_block_size = value->safeGet<UInt64>();\n+        if (!max_compress_block_size)\n+            max_compress_block_size = settings.max_compress_block_size;\n+\n         column_streams[stream_name] = std::make_unique<Stream<false>>(\n             stream_name,\n             data_part->getDataPartStoragePtr(),\n             stream_name, DATA_FILE_EXTENSION,\n             stream_name, marks_file_extension,\n             compression_codec,\n-            settings.max_compress_block_size,\n+            max_compress_block_size,\n             marks_compression_codec,\n             settings.marks_compress_block_size,\n             settings.query_write_settings);\n@@ -323,6 +333,13 @@ StreamsWithMarks MergeTreeDataPartWriterWide::getCurrentMarksForColumn(\n     WrittenOffsetColumns & offset_columns)\n {\n     StreamsWithMarks result;\n+    const auto column_desc = metadata_snapshot->columns.tryGetColumnDescription(GetColumnsOptions(GetColumnsOptions::AllPhysical), column.getNameInStorage());\n+    UInt64 min_compress_block_size = 0;\n+    if (column_desc)\n+        if (const auto * value = column_desc->settings.tryGet(\"min_compress_block_size\"))\n+            min_compress_block_size = value->safeGet<UInt64>();\n+    if (!min_compress_block_size)\n+        min_compress_block_size = settings.min_compress_block_size;\n     data_part->getSerialization(column.name)->enumerateStreams([&] (const ISerialization::SubstreamPath & substream_path)\n     {\n         bool is_offsets = !substream_path.empty() && substream_path.back().type == ISerialization::Substream::ArraySizes;\n@@ -335,7 +352,7 @@ StreamsWithMarks MergeTreeDataPartWriterWide::getCurrentMarksForColumn(\n         auto & stream = *column_streams[stream_name];\n \n         /// There could already be enough data to compress into the new block.\n-        if (stream.compressed_hashing.offset() >= settings.min_compress_block_size)\n+        if (stream.compressed_hashing.offset() >= min_compress_block_size)\n             stream.compressed_hashing.next();\n \n         StreamNameAndMark stream_with_mark;\ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.cpp b/src/Storages/MergeTree/MergeTreeSettings.cpp\nindex e0015cdeb403..cefee36c1242 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSettings.cpp\n@@ -213,6 +213,27 @@ void MergeTreeSettings::sanityCheck(size_t background_pool_tasks) const\n     }\n }\n \n+void MergeTreeColumnSettings::validate(const SettingsChanges & changes)\n+{\n+    static const MergeTreeSettings merge_tree_settings;\n+    static const std::set<String> allowed_column_level_settings =\n+    {\n+        \"min_compress_block_size\",\n+        \"max_compress_block_size\"\n+    };\n+\n+    for (const auto & change : changes)\n+    {\n+        if (!allowed_column_level_settings.contains(change.name))\n+            throw Exception(\n+                ErrorCodes::UNKNOWN_SETTING,\n+                \"Setting {} is unknown or not supported at column level, supported settings: {}\",\n+                change.name,\n+                fmt::join(allowed_column_level_settings, \", \"));\n+        merge_tree_settings.checkCanSet(change.name, change.value);\n+    }\n+}\n+\n \n std::vector<String> MergeTreeSettings::getAllRegisteredNames() const\n {\ndiff --git a/src/Storages/MergeTree/MergeTreeSettings.h b/src/Storages/MergeTree/MergeTreeSettings.h\nindex eb6c14d7754a..b8ab682de084 100644\n--- a/src/Storages/MergeTree/MergeTreeSettings.h\n+++ b/src/Storages/MergeTree/MergeTreeSettings.h\n@@ -277,4 +277,11 @@ struct MergeTreeSettings : public BaseSettings<MergeTreeSettingsTraits>, public\n \n using MergeTreeSettingsPtr = std::shared_ptr<const MergeTreeSettings>;\n \n+\n+/// Column-level Merge-Tree settings which overwrite MergeTree settings\n+namespace MergeTreeColumnSettings\n+{\n+    void validate(const SettingsChanges & changes);\n+}\n+\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02870_per_column_settings.reference b/tests/queries/0_stateless/02870_per_column_settings.reference\nnew file mode 100644\nindex 000000000000..144c8c5ee2eb\n--- /dev/null\n+++ b/tests/queries/0_stateless/02870_per_column_settings.reference\n@@ -0,0 +1,18 @@\n+CREATE TABLE default.tab\\n(\\n    `id` UInt64,\\n    `long_string` String SETTINGS (min_compress_block_size = 163840, max_compress_block_size = 163840),\\n    `v1` String,\\n    `v2` UInt64,\\n    `v3` Float32,\\n    `v4` Float64\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/tab/2870\\', \\'r1\\')\\nORDER BY id\\nSETTINGS min_bytes_for_wide_part = 1, index_granularity = 8192\n+1000\n+CREATE TABLE default.tab\\n(\\n    `id` UInt64,\\n    `long_string` String SETTINGS (min_compress_block_size = 8192, max_compress_block_size = 163840),\\n    `v1` String,\\n    `v2` UInt64,\\n    `v3` Float32,\\n    `v4` Float64\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/tab/2870\\', \\'r1\\')\\nORDER BY id\\nSETTINGS min_bytes_for_wide_part = 1, index_granularity = 8192\n+CREATE TABLE default.tab\\n(\\n    `id` UInt64,\\n    `long_string` String SETTINGS (max_compress_block_size = 163840),\\n    `v1` String,\\n    `v2` UInt64,\\n    `v3` Float32,\\n    `v4` Float64\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/tab/2870\\', \\'r1\\')\\nORDER BY id\\nSETTINGS min_bytes_for_wide_part = 1, index_granularity = 8192\n+CREATE TABLE default.tab\\n(\\n    `id` UInt64,\\n    `long_string` String,\\n    `v1` String,\\n    `v2` UInt64,\\n    `v3` Float32,\\n    `v4` Float64\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/tab/2870\\', \\'r1\\')\\nORDER BY id\\nSETTINGS min_bytes_for_wide_part = 1, index_granularity = 8192\n+CREATE TABLE default.tab\\n(\\n    `id` UInt64,\\n    `long_string` String SETTINGS (min_compress_block_size = 163840, max_compress_block_size = 163840),\\n    `v1` String,\\n    `v2` UInt64,\\n    `v3` Float32,\\n    `v4` Float64\\n)\\nENGINE = ReplicatedMergeTree(\\'/clickhouse/tables/default/tab/2870\\', \\'r1\\')\\nORDER BY id\\nSETTINGS min_bytes_for_wide_part = 1, index_granularity = 8192\n+--- \n+(0,0)\t0\n+(1,1)\t1\n+(2,2)\t2\n+(3,3)\t3\n+(4,4)\t4\n+(5,5)\t5\n+(6,6)\t6\n+(7,7)\t7\n+(8,8)\t8\n+(9,9)\t9\n+--- \ndiff --git a/tests/queries/0_stateless/02870_per_column_settings.sql b/tests/queries/0_stateless/02870_per_column_settings.sql\nnew file mode 100644\nindex 000000000000..345cf5cc7449\n--- /dev/null\n+++ b/tests/queries/0_stateless/02870_per_column_settings.sql\n@@ -0,0 +1,69 @@\n+-- Tags: no-random-merge-tree-settings, no-replicated-database\n+-- Tag no-replicated-database: Old syntax is not allowed\n+-- The test use replicated table to test serialize and deserialize column with settings declaration on zookeeper\n+-- Tests column-level settings for MergeTree* tables\n+\n+DROP TABLE IF EXISTS tab;\n+\n+CREATE TABLE tab\n+(\n+    id UInt64,\n+    long_string String SETTINGS (min_compress_block_size = 163840, max_compress_block_size = 163840),\n+    v1 String,\n+    v2 UInt64,\n+    v3 Float32,\n+    v4 Float64\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/tables/{database}/tab/2870', 'r1')\n+ORDER BY id\n+SETTINGS min_bytes_for_wide_part = 1;\n+\n+SHOW CREATE tab;\n+\n+INSERT INTO TABLE tab SELECT number, randomPrintableASCII(1000), randomPrintableASCII(10), rand(number), rand(number+1), rand(number+2) FROM numbers(1000);\n+SELECT count() FROM tab;\n+\n+ALTER TABLE tab MODIFY COLUMN long_string MODIFY SETTING min_compress_block_size = 8192;\n+SHOW CREATE tab;\n+\n+ALTER TABLE tab MODIFY COLUMN long_string RESET SETTING min_compress_block_size;\n+SHOW CREATE tab;\n+\n+ALTER TABLE tab MODIFY COLUMN long_string REMOVE SETTINGS;\n+SHOW CREATE tab;\n+\n+ALTER TABLE tab MODIFY COLUMN long_string String SETTINGS (min_compress_block_size = 163840, max_compress_block_size = 163840);\n+SHOW CREATE tab;\n+\n+DROP TABLE tab;\n+\n+SELECT '--- ';\n+\n+SET allow_experimental_object_type = 1;\n+\n+CREATE TABLE tab\n+(\n+    id UInt64,\n+    tup Tuple(UInt64, UInt64) SETTINGS (min_compress_block_size = 81920, max_compress_block_size = 163840),\n+    json JSON SETTINGS (min_compress_block_size = 81920, max_compress_block_size = 163840),\n+)\n+ENGINE = MergeTree\n+ORDER BY id\n+SETTINGS min_bytes_for_wide_part = 1;\n+\n+INSERT INTO TABLE tab SELECT number, tuple(number, number), concat('{\"key\": ', toString(number), ' ,\"value\": ', toString(rand(number+1)), '}') FROM numbers(1000);\n+SELECT tup, json.key AS key FROM tab ORDER BY key LIMIT 10;\n+\n+DROP TABLE tab;\n+\n+SELECT '--- ';\n+\n+-- Unsupported column-level settings are rejected\n+CREATE TABLE tab\n+(\n+    id UInt64,\n+    long_string String SETTINGS (min_block_size = 81920, max_compress_block_size = 163840),\n+)\n+ENGINE = MergeTree\n+ORDER BY id\n+SETTINGS min_bytes_for_wide_part = 1; -- {serverError UNKNOWN_SETTING}\n",
  "problem_statement": "Per-column compression block size\n> (you don't have to strictly follow this form)\r\n\r\n**Use case**\r\n\r\nWhen table has a big string column and we want to explicitly set a big compression block size for that column.\r\n\r\n**Describe the solution you'd like**\r\n\r\n```\r\nCREATE TABLE t\r\n(\r\n        ...\r\n        big_column String CODEC(ZSTD(1)) COMPRESSION BLOCK (min_block_size, max_block_size)\r\n)\r\nENGINE = MergeTree ORDER BY tuple();\r\n```\r\n\r\n**Describe alternatives you've considered**\r\n\r\nTuning `min_compress_block_size` and `max_compress_block_size` but it's hard to get the optimal compression ratio for the big columns without using big compression block size. E.g.\r\n\r\n\r\n```\r\nCREATE TABLE t\r\n(\r\n        ... /*all small columns*/\r\n        big_column String CODEC(ZSTD(1)) COMPRESSION BLOCK (min_block_size, max_block_size)\r\n)\r\nENGINE = MergeTree ORDER BY tuple() SETTINGS min_compress_block_size = 67108864, max _compress_block_size = 67108864;\r\n```\r\n--> good compression ratio, but reading all columns costs too much memory.\r\n\r\n```\r\nCREATE TABLE t\r\n(\r\n        ... /*all small columns*/\r\n        big_column String CODEC(ZSTD(1)) COMPRESSION BLOCK (min_block_size, max_block_size)\r\n)\r\nENGINE = MergeTree ORDER BY tuple() SETTINGS min_compress_block_size = 16384, max _compress_block_size = 67108864;\r\n```\r\n---> compression ratio reduced by 30%\r\n\r\n**Additional context**\r\n\r\n[Greenplum](https://greenplum.org/10-examples-of-compression-enablement-in-greenplum/) can do it as:\r\n\r\n```\r\nCREATE TABLE t \r\n(\r\n        c1 int ENCODING (compresstype=zstd),\r\n        c2 char ENCODING (compresstype=zlib, blocksize=65536),\r\n        c3 char\r\n) WITH (orientation=column);\r\n```\r\n\n",
  "hints_text": "Also, it can make sense to do for other \"user-level\" settings as well:\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/issues/36428\n> Also, it can make sense to do for other \"user-level\" settings as well\r\n\r\nWe will need to examine the `MergeTreeSettings`. If there's many settings that make senses to override at column level, then we will need a general framework for this.",
  "created_at": "2023-10-02T06:12:17Z"
}