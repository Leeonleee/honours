{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 64327,
  "instance_id": "ClickHouse__ClickHouse-64327",
  "issue_numbers": [
    "64136"
  ],
  "base_commit": "7ce09a4a250c880c6107385ec90278823646a77c",
  "patch": "diff --git a/src/Common/TTLCachePolicy.h b/src/Common/TTLCachePolicy.h\nindex 8960b742c74f..6401835b0d7b 100644\n--- a/src/Common/TTLCachePolicy.h\n+++ b/src/Common/TTLCachePolicy.h\n@@ -220,6 +220,7 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n     std::vector<KeyMapped> dump() const override\n     {\n         std::vector<KeyMapped> res;\n+        res.reserve(cache.size());\n         for (const auto & [key, mapped] : cache)\n             res.push_back({key, mapped});\n         return res;\ndiff --git a/src/Interpreters/Cache/QueryCache.cpp b/src/Interpreters/Cache/QueryCache.cpp\nindex 151f2ea06cc9..5f2e574e008f 100644\n--- a/src/Interpreters/Cache/QueryCache.cpp\n+++ b/src/Interpreters/Cache/QueryCache.cpp\n@@ -117,6 +117,21 @@ ASTPtr removeQueryCacheSettings(ASTPtr ast)\n     return transformed_ast;\n }\n \n+IAST::Hash calculateAstHash(ASTPtr ast, const String & current_database)\n+{\n+    ast = removeQueryCacheSettings(ast);\n+\n+    /// Hash the AST, it must consider aliases (issue #56258)\n+    SipHash hash;\n+    ast->updateTreeHash(hash, /*ignore_aliases=*/ false);\n+\n+    /// Also hash the database specified via SQL `USE db`, otherwise identifiers in same query (AST) may mean different columns in different\n+    /// tables (issue #64136)\n+    hash.update(current_database);\n+\n+    return getSipHash128AsPair(hash);\n+}\n+\n String queryStringFromAST(ASTPtr ast)\n {\n     WriteBufferFromOwnString buf;\n@@ -128,12 +143,13 @@ String queryStringFromAST(ASTPtr ast)\n \n QueryCache::Key::Key(\n     ASTPtr ast_,\n+    const String & current_database,\n     Block header_,\n     std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_,\n     bool is_shared_,\n     std::chrono::time_point<std::chrono::system_clock> expires_at_,\n     bool is_compressed_)\n-    : ast(removeQueryCacheSettings(ast_))\n+    : ast_hash(calculateAstHash(ast_, current_database))\n     , header(header_)\n     , user_id(user_id_)\n     , current_user_roles(current_user_roles_)\n@@ -144,23 +160,19 @@ QueryCache::Key::Key(\n {\n }\n \n-QueryCache::Key::Key(ASTPtr ast_, std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_)\n-    : QueryCache::Key(ast_, {}, user_id_, current_user_roles_, false, std::chrono::system_clock::from_time_t(1), false) /// dummy values for everything != AST or user name\n+QueryCache::Key::Key(ASTPtr ast_, const String & current_database, std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_)\n+    : QueryCache::Key(ast_, current_database, {}, user_id_, current_user_roles_, false, std::chrono::system_clock::from_time_t(1), false) /// dummy values for everything != AST, current database, user name/roles\n {\n }\n \n-/// Hashing of ASTs must consider aliases (issue #56258)\n-static constexpr bool ignore_aliases = false;\n-\n bool QueryCache::Key::operator==(const Key & other) const\n {\n-    return ast->getTreeHash(ignore_aliases) == other.ast->getTreeHash(ignore_aliases);\n+    return ast_hash == other.ast_hash;\n }\n \n size_t QueryCache::KeyHasher::operator()(const Key & key) const\n {\n-    IAST::Hash hash = key.ast->getTreeHash(ignore_aliases);\n-    return hash.low64;\n+    return key.ast_hash.low64;\n }\n \n size_t QueryCache::QueryCacheEntryWeight::operator()(const Entry & entry) const\ndiff --git a/src/Interpreters/Cache/QueryCache.h b/src/Interpreters/Cache/QueryCache.h\nindex c574f3085e30..d3939d849f4a 100644\n--- a/src/Interpreters/Cache/QueryCache.h\n+++ b/src/Interpreters/Cache/QueryCache.h\n@@ -3,7 +3,7 @@\n #include <Common/CacheBase.h>\n #include <Common/logger_useful.h>\n #include <Core/Block.h>\n-#include <Parsers/IAST_fwd.h>\n+#include <Parsers/IAST.h>\n #include <Processors/Chunk.h>\n #include <Processors/Sources/SourceFromChunks.h>\n #include <QueryPipeline/Pipe.h>\n@@ -41,8 +41,10 @@ class QueryCache\n         /// ----------------------------------------------------\n         /// The actual key (data which gets hashed):\n \n+\n+        /// The hash of the query AST.\n         /// Unlike the query string, the AST is agnostic to lower/upper case (SELECT vs. select).\n-        const ASTPtr ast;\n+        IAST::Hash ast_hash;\n \n         /// Note: For a transactionally consistent cache, we would need to include the system settings in the cache key or invalidate the\n         /// cache whenever the settings change. This is because certain settings (e.g. \"additional_table_filters\") can affect the query\n@@ -83,6 +85,7 @@ class QueryCache\n \n         /// Ctor to construct a Key for writing into query cache.\n         Key(ASTPtr ast_,\n+            const String & current_database,\n             Block header_,\n             std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_,\n             bool is_shared_,\n@@ -90,7 +93,7 @@ class QueryCache\n             bool is_compressed);\n \n         /// Ctor to construct a Key for reading from query cache (this operation only needs the AST + user name).\n-        Key(ASTPtr ast_, std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_);\n+        Key(ASTPtr ast_, const String & current_database, std::optional<UUID> user_id_, const std::vector<UUID> & current_user_roles_);\n \n         bool operator==(const Key & other) const;\n     };\ndiff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex d609dceca102..84990c7bf0fb 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -1081,7 +1081,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             {\n                 if (can_use_query_cache && settings.enable_reads_from_query_cache)\n                 {\n-                    QueryCache::Key key(ast, context->getUserID(), context->getCurrentRoles());\n+                    QueryCache::Key key(ast, context->getCurrentDatabase(), context->getUserID(), context->getCurrentRoles());\n                     QueryCache::Reader reader = query_cache->createReader(key);\n                     if (reader.hasCacheEntryForKey())\n                     {\n@@ -1193,7 +1193,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                         if (!ast_contains_nondeterministic_functions || nondeterministic_function_handling == QueryCacheNondeterministicFunctionHandling::Save)\n                         {\n                             QueryCache::Key key(\n-                                ast, res.pipeline.getHeader(),\n+                                ast, context->getCurrentDatabase(), res.pipeline.getHeader(),\n                                 context->getUserID(), context->getCurrentRoles(),\n                                 settings.query_cache_share_between_users,\n                                 std::chrono::system_clock::now() + std::chrono::seconds(settings.query_cache_ttl),\ndiff --git a/src/Storages/System/StorageSystemQueryCache.cpp b/src/Storages/System/StorageSystemQueryCache.cpp\nindex 03111755904c..3c9e7a2dd850 100644\n--- a/src/Storages/System/StorageSystemQueryCache.cpp\n+++ b/src/Storages/System/StorageSystemQueryCache.cpp\n@@ -55,7 +55,7 @@ void StorageSystemQueryCache::fillData(MutableColumns & res_columns, ContextPtr\n         res_columns[3]->insert(key.is_shared);\n         res_columns[4]->insert(key.is_compressed);\n         res_columns[5]->insert(std::chrono::system_clock::to_time_t(key.expires_at));\n-        res_columns[6]->insert(key.ast->getTreeHash(/*ignore_aliases=*/ false).low64); /// query cache considers aliases (issue #56258)\n+        res_columns[6]->insert(key.ast_hash.low64); /// query cache considers aliases (issue #56258)\n     }\n }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02494_query_cache_use_database.reference b/tests/queries/0_stateless/02494_query_cache_use_database.reference\nnew file mode 100644\nindex 000000000000..1191247b6d9a\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_use_database.reference\n@@ -0,0 +1,2 @@\n+1\n+2\ndiff --git a/tests/queries/0_stateless/02494_query_cache_use_database.sql b/tests/queries/0_stateless/02494_query_cache_use_database.sql\nnew file mode 100644\nindex 000000000000..df560f82ebbf\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_use_database.sql\n@@ -0,0 +1,30 @@\n+-- Tags: no-parallel, no-fasttest\n+-- Tag no-fasttest: Depends on OpenSSL\n+-- Tag no-parallel: Messes with internal cache\n+\n+-- Test for issue #64136\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+DROP DATABASE IF EXISTS db1;\n+DROP DATABASE IF EXISTS db2;\n+\n+CREATE DATABASE db1;\n+CREATE DATABASE db2;\n+\n+CREATE TABLE db1.tab(a UInt64, PRIMARY KEY a);\n+CREATE TABLE db2.tab(a UInt64, PRIMARY KEY a);\n+\n+INSERT INTO db1.tab values(1);\n+INSERT INTO db2.tab values(2);\n+\n+USE db1;\n+SELECT * FROM tab SETTINGS use_query_cache=1;\n+\n+USE db2;\n+SELECT * FROM tab SETTINGS use_query_cache=1;\n+\n+DROP DATABASE db1;\n+DROP DATABASE db2;\n+\n+SYSTEM DROP QUERY CACHE;\n",
  "problem_statement": "Query cache is not isolated across different databases\nTested on 24.3.2.23 (official build).\r\n\r\n**Describe the unexpected behaviour**\r\nQuery cache is used for the same tables created in different databases when no database alias is used.\r\n\r\n**How to reproduce**\r\n\r\nPrepare debug environment and data:\r\n\r\n```\r\nCREATE DATABASE test ENGINE = Atomic;\r\n\r\nCREATE TABLE default.test\r\n(\r\n    `a` UInt64,\r\n    `b` UUID,\r\n    `c` UInt32 DEFAULT xxHash32(b),\r\n    `d` DateTime,\r\n    `error_count` UInt8,\r\n    INDEX idx_error error_count TYPE minmax GRANULARITY 1\r\n)\r\nENGINE = ReplacingMergeTree(d)\r\nPARTITION BY toYYYYMM(d)\r\nORDER BY (a, c)\r\nTTL d + toIntervalMonth(1)\r\nSETTINGS index_granularity = 6, ttl_only_drop_parts = 1;\r\n\r\nCREATE TABLE test.test AS default.test;\r\n\r\nINSERT INTO test.test SELECT number, generateUUIDv4(), number, '2024-05-20 14:00:00'::DateTime, 2 FROM numbers(10e7);\r\n\r\nALTER TABLE default.test ATTACH PARTITION '202405' FROM test.test;\r\n```\r\n\r\nNow test query cache:\r\n\r\n```\r\nUSE default;\r\n\r\nSELECT a % 100 ids, max(b) uuids, sum(error_count) ec FROM test GROUP BY ids ORDER BY ids SETTINGS use_query_cache=1;\r\n\r\n100 rows in set. Elapsed: 11.742 sec. Processed 75.49 million rows, 1.89 GB (6.43 million rows/s., 160.73 MB/s.)\r\n\r\nSELECT * FROM system.query_cache;\r\n      \u250c\u2500query\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500result_size\u2500\u252c\u2500stale\u2500\u252c\u2500shared\u2500\u252c\u2500compressed\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500expires_at\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500key_hash\u2500\u2510\r\n1. \u2502 SELECT a % 100 AS ids, max(b) AS uuids, sum(error_count) AS ec FROM test GROUP BY ids ORDER BY ids ASC SETTINGS use_query_cache = 1 \u2502        3328 \u2502     0 \u2502      0 \u2502          1 \u2502 2024-05-20 14:09:44 \u2502 5831134195536845086 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\nUSE test;\r\n\r\nSELECT a % 100 ids, max(b) uuids, sum(error_count) ec FROM test GROUP BY ids ORDER BY ids SETTINGS use_query_cache=1;\r\n\r\n100 rows in set. Elapsed: 0.001 sec.\r\n\r\nSELECT * FROM system.query_cache;\r\n   \r\n\u250c\u2500query\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500result_size\u2500\u252c\u2500stale\u2500\u252c\u2500shared\u2500\u252c\u2500compressed\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500expires_at\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500key_hash\u2500\u2510\r\n1. \u2502 SELECT a % 100 AS ids, max(b) AS uuids, sum(error_count) AS ec FROM test GROUP BY ids ORDER BY ids ASC SETTINGS use_query_cache = 1 \u2502        3328 \u2502     0 \u2502      0 \u2502          1 \u2502 2024-05-20 14:09:44 \u2502 5831134195536845086 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\n**Expected behavior**\r\nI expect the query cache to be aware that I'm selecting the data from another table (same table name in another database).\r\n\n",
  "hints_text": "",
  "created_at": "2024-05-23T22:05:59Z"
}