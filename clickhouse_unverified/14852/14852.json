{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 14852,
  "instance_id": "ClickHouse__ClickHouse-14852",
  "issue_numbers": [
    "14781"
  ],
  "base_commit": "018f596d21dbd9f639c58f76d91c6a916d2dc199",
  "patch": "diff --git a/src/Core/MySQL/MySQLReplication.cpp b/src/Core/MySQL/MySQLReplication.cpp\nindex e7f113ba7af7..824440b3dd05 100644\n--- a/src/Core/MySQL/MySQLReplication.cpp\n+++ b/src/Core/MySQL/MySQLReplication.cpp\n@@ -2,6 +2,7 @@\n \n #include <DataTypes/DataTypeString.h>\n #include <IO/ReadBufferFromString.h>\n+#include <IO/MySQLBinlogEventReadBuffer.h>\n #include <IO/ReadHelpers.h>\n #include <common/DateLUT.h>\n #include <Common/FieldVisitors.h>\n@@ -14,6 +15,7 @@ namespace ErrorCodes\n {\n     extern const int UNKNOWN_EXCEPTION;\n     extern const int LOGICAL_ERROR;\n+    extern const int ATTEMPT_TO_READ_AFTER_EOF;\n }\n \n namespace MySQLReplication\n@@ -49,14 +51,13 @@ namespace MySQLReplication\n     {\n         payload.readStrict(reinterpret_cast<char *>(&binlog_version), 2);\n         assert(binlog_version == EVENT_VERSION_V4);\n+        server_version.resize(50);\n         payload.readStrict(reinterpret_cast<char *>(server_version.data()), 50);\n         payload.readStrict(reinterpret_cast<char *>(&create_timestamp), 4);\n         payload.readStrict(reinterpret_cast<char *>(&event_header_length), 1);\n         assert(event_header_length == EVENT_HEADER_LENGTH);\n \n-        size_t len = header.event_size - (2 + 50 + 4 + 1 + EVENT_HEADER_LENGTH) - 1;\n-        event_type_header_length.resize(len);\n-        payload.readStrict(reinterpret_cast<char *>(event_type_header_length.data()), len);\n+        readStringUntilEOF(event_type_header_length, payload);\n     }\n \n     void FormatDescriptionEvent::dump(std::ostream & out) const\n@@ -72,9 +73,7 @@ namespace MySQLReplication\n     void RotateEvent::parseImpl(ReadBuffer & payload)\n     {\n         payload.readStrict(reinterpret_cast<char *>(&position), 8);\n-        size_t len = header.event_size - EVENT_HEADER_LENGTH - 8 - CHECKSUM_CRC32_SIGNATURE_LENGTH;\n-        next_binlog.resize(len);\n-        payload.readStrict(reinterpret_cast<char *>(next_binlog.data()), len);\n+        readStringUntilEOF(next_binlog, payload);\n     }\n \n     void RotateEvent::dump(std::ostream & out) const\n@@ -100,9 +99,7 @@ namespace MySQLReplication\n         payload.readStrict(reinterpret_cast<char *>(schema.data()), schema_len);\n         payload.ignore(1);\n \n-        size_t len = payload.available() - CHECKSUM_CRC32_SIGNATURE_LENGTH;\n-        query.resize(len);\n-        payload.readStrict(reinterpret_cast<char *>(query.data()), len);\n+        readStringUntilEOF(query, payload);\n         if (query.starts_with(\"BEGIN\") || query.starts_with(\"COMMIT\"))\n         {\n             typ = QUERY_EVENT_MULTI_TXN_FLAG;\n@@ -285,7 +282,7 @@ namespace MySQLReplication\n                 break;\n         }\n \n-        while (payload.available() > CHECKSUM_CRC32_SIGNATURE_LENGTH)\n+        while (!payload.eof())\n         {\n             parseRow(payload, columns_present_bitmap1);\n             if (header.type == UPDATE_ROWS_EVENT_V1 || header.type == UPDATE_ROWS_EVENT_V2)\n@@ -738,7 +735,7 @@ namespace MySQLReplication\n         payload.readStrict(reinterpret_cast<char *>(&gtid.seq_no), 8);\n \n         /// Skip others.\n-        payload.ignore(payload.available() - CHECKSUM_CRC32_SIGNATURE_LENGTH);\n+        payload.ignoreAll();\n     }\n \n     void GTIDEvent::dump(std::ostream & out) const\n@@ -751,7 +748,7 @@ namespace MySQLReplication\n         out << \"GTID Next: \" << gtid_next << std::endl;\n     }\n \n-    void DryRunEvent::parseImpl(ReadBuffer & payload) { payload.ignore(header.event_size - EVENT_HEADER_LENGTH); }\n+    void DryRunEvent::parseImpl(ReadBuffer & payload) { payload.ignoreAll(); }\n \n     void DryRunEvent::dump(std::ostream & out) const\n     {\n@@ -804,6 +801,9 @@ namespace MySQLReplication\n \n     void MySQLFlavor::readPayloadImpl(ReadBuffer & payload)\n     {\n+        if (payload.eof())\n+            throw Exception(\"Attempt to read after EOF.\", ErrorCodes::ATTEMPT_TO_READ_AFTER_EOF);\n+\n         UInt16 header = static_cast<unsigned char>(*payload.position());\n         switch (header)\n         {\n@@ -814,37 +814,42 @@ namespace MySQLReplication\n                 err.readPayloadWithUnpacked(payload);\n                 throw ReplicationError(err.error_message, ErrorCodes::UNKNOWN_EXCEPTION);\n         }\n-        // skip the header flag.\n+        // skip the generic response packets header flag.\n         payload.ignore(1);\n \n-        EventType event_type = static_cast<EventType>(*(payload.position() + 4));\n-        switch (event_type)\n+        MySQLBinlogEventReadBuffer event_payload(payload);\n+\n+        EventHeader event_header;\n+        event_header.parse(event_payload);\n+\n+        switch (event_header.type)\n         {\n-            case FORMAT_DESCRIPTION_EVENT: {\n-                event = std::make_shared<FormatDescriptionEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            case FORMAT_DESCRIPTION_EVENT:\n+            {\n+                event = std::make_shared<FormatDescriptionEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n                 position.update(event);\n                 break;\n             }\n-            case ROTATE_EVENT: {\n-                event = std::make_shared<RotateEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            case ROTATE_EVENT:\n+            {\n+                event = std::make_shared<RotateEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n                 position.update(event);\n                 break;\n             }\n-            case QUERY_EVENT: {\n-                event = std::make_shared<QueryEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            case QUERY_EVENT:\n+            {\n+                event = std::make_shared<QueryEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n \n                 auto query = std::static_pointer_cast<QueryEvent>(event);\n                 switch (query->typ)\n                 {\n                     case QUERY_EVENT_MULTI_TXN_FLAG:\n-                    case QUERY_EVENT_XA: {\n-                        event = std::make_shared<DryRunEvent>();\n+                    case QUERY_EVENT_XA:\n+                    {\n+                        event = std::make_shared<DryRunEvent>(std::move(query->header));\n                         break;\n                     }\n                     default:\n@@ -852,68 +857,67 @@ namespace MySQLReplication\n                 }\n                 break;\n             }\n-            case XID_EVENT: {\n-                event = std::make_shared<XIDEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            case XID_EVENT:\n+            {\n+                event = std::make_shared<XIDEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n                 position.update(event);\n                 break;\n             }\n-            case TABLE_MAP_EVENT: {\n-                event = std::make_shared<TableMapEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            case TABLE_MAP_EVENT:\n+            {\n+                event = std::make_shared<TableMapEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n                 table_map = std::static_pointer_cast<TableMapEvent>(event);\n                 break;\n             }\n             case WRITE_ROWS_EVENT_V1:\n-            case WRITE_ROWS_EVENT_V2: {\n+            case WRITE_ROWS_EVENT_V2:\n+            {\n                 if (do_replicate())\n-                    event = std::make_shared<WriteRowsEvent>(table_map);\n+                    event = std::make_shared<WriteRowsEvent>(table_map, std::move(event_header));\n                 else\n-                    event = std::make_shared<DryRunEvent>();\n+                    event = std::make_shared<DryRunEvent>(std::move(event_header));\n \n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+                event->parseEvent(event_payload);\n                 break;\n             }\n             case DELETE_ROWS_EVENT_V1:\n-            case DELETE_ROWS_EVENT_V2: {\n+            case DELETE_ROWS_EVENT_V2:\n+            {\n                 if (do_replicate())\n-                    event = std::make_shared<DeleteRowsEvent>(table_map);\n+                    event = std::make_shared<DeleteRowsEvent>(table_map, std::move(event_header));\n                 else\n-                    event = std::make_shared<DryRunEvent>();\n+                    event = std::make_shared<DryRunEvent>(std::move(event_header));\n \n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+                event->parseEvent(event_payload);\n                 break;\n             }\n             case UPDATE_ROWS_EVENT_V1:\n-            case UPDATE_ROWS_EVENT_V2: {\n+            case UPDATE_ROWS_EVENT_V2:\n+            {\n                 if (do_replicate())\n-                    event = std::make_shared<UpdateRowsEvent>(table_map);\n+                    event = std::make_shared<UpdateRowsEvent>(table_map, std::move(event_header));\n                 else\n-                    event = std::make_shared<DryRunEvent>();\n+                    event = std::make_shared<DryRunEvent>(std::move(event_header));\n \n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+                event->parseEvent(event_payload);\n                 break;\n             }\n-            case GTID_EVENT: {\n-                event = std::make_shared<GTIDEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            case GTID_EVENT:\n+            {\n+                event = std::make_shared<GTIDEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n                 position.update(event);\n                 break;\n             }\n-            default: {\n-                event = std::make_shared<DryRunEvent>();\n-                event->parseHeader(payload);\n-                event->parseEvent(payload);\n+            default:\n+            {\n+                event = std::make_shared<DryRunEvent>(std::move(event_header));\n+                event->parseEvent(event_payload);\n                 break;\n             }\n         }\n-        payload.ignoreAll();\n     }\n }\n \ndiff --git a/src/Core/MySQL/MySQLReplication.h b/src/Core/MySQL/MySQLReplication.h\nindex ad5e53ed2007..fbcd67105ed0 100644\n--- a/src/Core/MySQL/MySQLReplication.h\n+++ b/src/Core/MySQL/MySQLReplication.h\n@@ -19,7 +19,6 @@ namespace MySQLReplication\n {\n     static const int EVENT_VERSION_V4 = 4;\n     static const int EVENT_HEADER_LENGTH = 19;\n-    static const int CHECKSUM_CRC32_SIGNATURE_LENGTH = 4;\n \n     using Bitmap = boost::dynamic_bitset<>;\n \n@@ -301,9 +300,10 @@ namespace MySQLReplication\n     public:\n         EventHeader header;\n \n+        EventBase(EventHeader && header_) : header(std::move(header_)) {}\n+\n         virtual ~EventBase() = default;\n         virtual void dump(std::ostream & out) const = 0;\n-        virtual void parseHeader(ReadBuffer & payload) { header.parse(payload); }\n         virtual void parseEvent(ReadBuffer & payload) { parseImpl(payload); }\n         virtual MySQLEventType type() const { return MYSQL_UNHANDLED_EVENT; }\n \n@@ -314,7 +314,10 @@ namespace MySQLReplication\n     class FormatDescriptionEvent : public EventBase\n     {\n     public:\n-        FormatDescriptionEvent() : binlog_version(0), create_timestamp(0), event_header_length(0) { }\n+        FormatDescriptionEvent(EventHeader && header_)\n+            : EventBase(std::move(header_)), binlog_version(0), create_timestamp(0), event_header_length(0)\n+        {\n+        }\n \n     protected:\n         UInt16 binlog_version;\n@@ -336,7 +339,7 @@ namespace MySQLReplication\n         UInt64 position;\n         String next_binlog;\n \n-        RotateEvent() : position(0) { }\n+        RotateEvent(EventHeader && header_) : EventBase(std::move(header_)), position(0) {}\n         void dump(std::ostream & out) const override;\n \n     protected:\n@@ -363,7 +366,11 @@ namespace MySQLReplication\n         String query;\n         QueryType typ = QUERY_EVENT_DDL;\n \n-        QueryEvent() : thread_id(0), exec_time(0), schema_len(0), error_code(0), status_len(0) { }\n+        QueryEvent(EventHeader && header_)\n+            : EventBase(std::move(header_)), thread_id(0), exec_time(0), schema_len(0), error_code(0), status_len(0)\n+        {\n+        }\n+\n         void dump(std::ostream & out) const override;\n         MySQLEventType type() const override { return MYSQL_QUERY_EVENT; }\n \n@@ -374,7 +381,7 @@ namespace MySQLReplication\n     class XIDEvent : public EventBase\n     {\n     public:\n-        XIDEvent() : xid(0) { }\n+        XIDEvent(EventHeader && header_) : EventBase(std::move(header_)), xid(0) {}\n \n     protected:\n         UInt64 xid;\n@@ -397,7 +404,7 @@ namespace MySQLReplication\n         std::vector<UInt16> column_meta;\n         Bitmap null_bitmap;\n \n-        TableMapEvent() : table_id(0), flags(0), schema_len(0), table_len(0), column_count(0) { }\n+        TableMapEvent(EventHeader && header_) : EventBase(std::move(header_)), table_id(0), flags(0), schema_len(0), table_len(0), column_count(0) {}\n         void dump(std::ostream & out) const override;\n \n     protected:\n@@ -413,8 +420,8 @@ namespace MySQLReplication\n         String table;\n         std::vector<Field> rows;\n \n-        RowsEvent(std::shared_ptr<TableMapEvent> table_map_)\n-            : number_columns(0), table_id(0), flags(0), extra_data_len(0), table_map(table_map_)\n+        RowsEvent(std::shared_ptr<TableMapEvent> table_map_, EventHeader && header_)\n+            : EventBase(std::move(header_)), number_columns(0), table_id(0), flags(0), extra_data_len(0), table_map(table_map_)\n         {\n             schema = table_map->schema;\n             table = table_map->table;\n@@ -439,21 +446,21 @@ namespace MySQLReplication\n     class WriteRowsEvent : public RowsEvent\n     {\n     public:\n-        WriteRowsEvent(std::shared_ptr<TableMapEvent> table_map_) : RowsEvent(table_map_) { }\n+        WriteRowsEvent(std::shared_ptr<TableMapEvent> table_map_, EventHeader && header_) : RowsEvent(table_map_, std::move(header_)) {}\n         MySQLEventType type() const override { return MYSQL_WRITE_ROWS_EVENT; }\n     };\n \n     class DeleteRowsEvent : public RowsEvent\n     {\n     public:\n-        DeleteRowsEvent(std::shared_ptr<TableMapEvent> table_map_) : RowsEvent(table_map_) { }\n+        DeleteRowsEvent(std::shared_ptr<TableMapEvent> table_map_, EventHeader && header_) : RowsEvent(table_map_, std::move(header_)) {}\n         MySQLEventType type() const override { return MYSQL_DELETE_ROWS_EVENT; }\n     };\n \n     class UpdateRowsEvent : public RowsEvent\n     {\n     public:\n-        UpdateRowsEvent(std::shared_ptr<TableMapEvent> table_map_) : RowsEvent(table_map_) { }\n+        UpdateRowsEvent(std::shared_ptr<TableMapEvent> table_map_, EventHeader && header_) : RowsEvent(table_map_, std::move(header_)) {}\n         MySQLEventType type() const override { return MYSQL_UPDATE_ROWS_EVENT; }\n     };\n \n@@ -463,7 +470,7 @@ namespace MySQLReplication\n         UInt8 commit_flag;\n         GTID gtid;\n \n-        GTIDEvent() : commit_flag(0) { }\n+        GTIDEvent(EventHeader && header_) : EventBase(std::move(header_)), commit_flag(0) {}\n         void dump(std::ostream & out) const override;\n \n     protected:\n@@ -472,6 +479,8 @@ namespace MySQLReplication\n \n     class DryRunEvent : public EventBase\n     {\n+    public:\n+        DryRunEvent(EventHeader && header_) : EventBase(std::move(header_)) {}\n         void dump(std::ostream & out) const override;\n \n     protected:\ndiff --git a/src/IO/MySQLBinlogEventReadBuffer.cpp b/src/IO/MySQLBinlogEventReadBuffer.cpp\nnew file mode 100644\nindex 000000000000..3a2aba045d36\n--- /dev/null\n+++ b/src/IO/MySQLBinlogEventReadBuffer.cpp\n@@ -0,0 +1,70 @@\n+#include <IO/MySQLBinlogEventReadBuffer.h>\n+\n+\n+namespace DB\n+{\n+\n+MySQLBinlogEventReadBuffer::MySQLBinlogEventReadBuffer(ReadBuffer & in_)\n+    : ReadBuffer(nullptr, 0, 0), in(in_)\n+{\n+    nextIfAtEnd();\n+}\n+\n+bool MySQLBinlogEventReadBuffer::nextImpl()\n+{\n+    if (hasPendingData())\n+        return true;\n+\n+    if (in.eof())\n+        return false;\n+\n+    if (checksum_buff_size == checksum_buff_limit)\n+    {\n+        if (likely(in.available() > CHECKSUM_CRC32_SIGNATURE_LENGTH))\n+        {\n+            working_buffer = ReadBuffer::Buffer(in.position(), in.buffer().end() - CHECKSUM_CRC32_SIGNATURE_LENGTH);\n+            in.ignore(working_buffer.size());\n+            return true;\n+        }\n+\n+        in.readStrict(checksum_buf, CHECKSUM_CRC32_SIGNATURE_LENGTH);\n+        checksum_buff_size = checksum_buff_limit = CHECKSUM_CRC32_SIGNATURE_LENGTH;\n+    }\n+    else\n+    {\n+        for (size_t index = 0; index < checksum_buff_size - checksum_buff_limit; ++index)\n+            checksum_buf[index] = checksum_buf[checksum_buff_limit + index];\n+\n+        checksum_buff_size -= checksum_buff_limit;\n+        size_t read_bytes = CHECKSUM_CRC32_SIGNATURE_LENGTH - checksum_buff_size;\n+        in.readStrict(checksum_buf + checksum_buff_size, read_bytes);   /// Minimum CHECKSUM_CRC32_SIGNATURE_LENGTH bytes\n+        checksum_buff_size = checksum_buff_limit = CHECKSUM_CRC32_SIGNATURE_LENGTH;\n+    }\n+\n+    if (in.eof())\n+        return false;\n+\n+    if (in.available() < CHECKSUM_CRC32_SIGNATURE_LENGTH)\n+    {\n+        size_t left_move_size = CHECKSUM_CRC32_SIGNATURE_LENGTH - in.available();\n+        checksum_buff_limit = checksum_buff_size - left_move_size;\n+    }\n+\n+    working_buffer = ReadBuffer::Buffer(checksum_buf, checksum_buf + checksum_buff_limit);\n+    return true;\n+}\n+\n+MySQLBinlogEventReadBuffer::~MySQLBinlogEventReadBuffer()\n+{\n+    try\n+    {\n+        /// ignore last 4 bytes\n+        nextIfAtEnd();\n+    }\n+    catch (...)\n+    {\n+        tryLogCurrentException(__PRETTY_FUNCTION__);\n+    }\n+}\n+\n+}\ndiff --git a/src/IO/MySQLBinlogEventReadBuffer.h b/src/IO/MySQLBinlogEventReadBuffer.h\nnew file mode 100644\nindex 000000000000..e9452aa551ec\n--- /dev/null\n+++ b/src/IO/MySQLBinlogEventReadBuffer.h\n@@ -0,0 +1,28 @@\n+#pragma once\n+\n+#include <IO/ReadBuffer.h>\n+\n+namespace DB\n+{\n+\n+class MySQLBinlogEventReadBuffer : public ReadBuffer\n+{\n+protected:\n+    static const size_t CHECKSUM_CRC32_SIGNATURE_LENGTH = 4;\n+    ReadBuffer & in;\n+\n+    size_t checksum_buff_size = 0;\n+    size_t checksum_buff_limit = 0;\n+    char checksum_buf[CHECKSUM_CRC32_SIGNATURE_LENGTH];\n+\n+    bool nextImpl() override;\n+\n+public:\n+    ~MySQLBinlogEventReadBuffer() override;\n+\n+    MySQLBinlogEventReadBuffer(ReadBuffer & in_);\n+\n+};\n+\n+\n+}\ndiff --git a/src/IO/ya.make b/src/IO/ya.make\nindex 0c939588a9b6..28099818b462 100644\n--- a/src/IO/ya.make\n+++ b/src/IO/ya.make\n@@ -28,6 +28,7 @@ SRCS(\n     MemoryReadWriteBuffer.cpp\n     MMapReadBufferFromFile.cpp\n     MMapReadBufferFromFileDescriptor.cpp\n+    MySQLBinlogEventReadBuffer.cpp\n     MySQLPacketPayloadReadBuffer.cpp\n     MySQLPacketPayloadWriteBuffer.cpp\n     NullWriteBuffer.cpp\n",
  "test_patch": "diff --git a/src/IO/tests/gtest_mysql_binlog_event_read_buffer.cpp b/src/IO/tests/gtest_mysql_binlog_event_read_buffer.cpp\nnew file mode 100644\nindex 000000000000..f4d39c73a7c8\n--- /dev/null\n+++ b/src/IO/tests/gtest_mysql_binlog_event_read_buffer.cpp\n@@ -0,0 +1,82 @@\n+#include <gtest/gtest.h>\n+#include <Common/Exception.h>\n+#include <IO/ConcatReadBuffer.h>\n+#include <IO/ReadBufferFromMemory.h>\n+#include <IO/MySQLBinlogEventReadBuffer.h>\n+\n+using namespace DB;\n+\n+TEST(MySQLBinlogEventReadBuffer, CheckBoundary)\n+{\n+    for (size_t index = 1; index < 4; ++index)\n+    {\n+        std::vector<char> memory_data(index, 0x01);\n+        ReadBufferFromMemory nested_in(memory_data.data(), index);\n+\n+        EXPECT_THROW({ MySQLBinlogEventReadBuffer binlog_in(nested_in); }, Exception);\n+    }\n+}\n+\n+TEST(MySQLBinlogEventReadBuffer, NiceBufferSize)\n+{\n+    char res[2];\n+    std::vector<char> memory_data(6, 0x01);\n+    ReadBufferFromMemory nested_in(memory_data.data(), 6);\n+\n+    MySQLBinlogEventReadBuffer binlog_in(nested_in);\n+    binlog_in.readStrict(res, 2);\n+    ASSERT_EQ(res[0], 0x01);\n+    ASSERT_EQ(res[1], 0x01);\n+    ASSERT_TRUE(binlog_in.eof());\n+}\n+\n+TEST(MySQLBinlogEventReadBuffer, BadBufferSizes)\n+{\n+    char res[4];\n+    std::vector<ReadBufferPtr> buffers;\n+    std::vector<ReadBuffer *> nested_buffers;\n+    std::vector<std::shared_ptr<std::vector<char>>> memory_buffers_data;\n+    std::vector<size_t> bad_buffers_size = {2, 1, 2, 3};\n+\n+    for (const auto & bad_buffer_size : bad_buffers_size)\n+    {\n+        memory_buffers_data.emplace_back(std::make_shared<std::vector<char>>(bad_buffer_size, 0x01));\n+        buffers.emplace_back(std::make_shared<ReadBufferFromMemory>(memory_buffers_data.back()->data(), bad_buffer_size));\n+        nested_buffers.emplace_back(buffers.back().get());\n+    }\n+\n+    ConcatReadBuffer concat_buffer(nested_buffers);\n+    MySQLBinlogEventReadBuffer binlog_in(concat_buffer);\n+    binlog_in.readStrict(res, 4);\n+\n+    for (const auto & res_byte : res)\n+        ASSERT_EQ(res_byte, 0x01);\n+\n+    ASSERT_TRUE(binlog_in.eof());\n+}\n+\n+TEST(MySQLBinlogEventReadBuffer, NiceAndBadBufferSizes)\n+{\n+    char res[12];\n+    std::vector<ReadBufferPtr> buffers;\n+    std::vector<ReadBuffer *> nested_buffers;\n+    std::vector<std::shared_ptr<std::vector<char>>> memory_buffers_data;\n+    std::vector<size_t> buffers_size = {6, 1, 3, 6};\n+\n+    for (const auto & bad_buffer_size : buffers_size)\n+    {\n+        memory_buffers_data.emplace_back(std::make_shared<std::vector<char>>(bad_buffer_size, 0x01));\n+        buffers.emplace_back(std::make_shared<ReadBufferFromMemory>(memory_buffers_data.back()->data(), bad_buffer_size));\n+        nested_buffers.emplace_back(buffers.back().get());\n+    }\n+\n+    ConcatReadBuffer concat_buffer(nested_buffers);\n+    MySQLBinlogEventReadBuffer binlog_in(concat_buffer);\n+    binlog_in.readStrict(res, 12);\n+\n+    for (const auto & res_byte : res)\n+        ASSERT_EQ(res_byte, 0x01);\n+\n+    ASSERT_TRUE(binlog_in.eof());\n+}\n+\n",
  "problem_statement": "MaterializeMySQL Data inconsistency between MySQL and Clickhouse \n**Describe the bug**\r\nmysql:5.7.31\r\nclickhouse:20.10.1.4635 \r\nI  found data inconsistency between MySQL and Clickhouse when I execute update in MySQL with one transaction with 439129 rows\r\n**How to reproduce**\r\nstep1:\r\n    I check that the amount of data is consistent between MySQL and Clickhouse\r\n  mysql> select count(1) from mobile_belong \r\n    -> ;\r\n+----------+\r\n| count(1) |\r\n+----------+\r\n|   439129 |\r\n+----------+\r\ntest-1-118.raipeng.com :) select count(1) from mobile_belong;\r\nSELECT count(1)\r\nFROM mobile_belong\r\n\u250c\u2500count(1)\u2500\u2510\r\n\u2502   439129 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n1 rows in set. Elapsed: 0.043 sec. Processed 439.13 thousand rows, 10.98 MB (10.30 million rows/s., 257.46 MB/s.) \r\nstep2: \r\n   I executed update in MySQL as below\r\n mysql> update mobile_belong set province='\u5317\u4eac',city='\u5317\u4eac';\r\nQuery OK, 419371 rows affected (1.98 sec)\r\nRows matched: 439129  Changed: 419371  Warnings: 0\r\nstep3:\r\n checking data in MySQL and ClickHouse, and found  mysql updated data of 439129 rows successfully ,but,clickhouse only have 438459 rows be updated successfully,remian  439129-438459  not be updated.\r\nmysql> select count(1) from mobile_belong where province='\u5317\u4eac' and city='\u5317\u4eac';\r\n+----------+\r\n| count(1) |\r\n+----------+\r\n|   439129 |\r\n+----------+\r\n1 row in set (0.16 sec)\r\ntest-1-118.raipeng.com :) select count(1) from mobile_belong where province='\u5317\u4eac' and city='\u5317\u4eac';\r\nSELECT count(1)\r\nFROM mobile_belong\r\nWHERE (province = '\u5317\u4eac') AND (city = '\u5317\u4eac')\r\n\u250c\u2500count(1)\u2500\u2510\r\n\u2502   438459 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n1 rows in set. Elapsed: 0.068 sec. Processed 523.68 thousand rows, 29.88 MB (7.66 million rows/s., 436.86 MB/s.) \r\n\n",
  "hints_text": "what is the table structure?\n@chang0391 is there any error message in ClickHouse's log?\nno error found, table structure as below\r\nCREATE TABLE `mobile_belong_test` (\r\n  `id` bigint(20) NOT NULL AUTO_INCREMENT,\r\n  `section` int(11) DEFAULT NULL,\r\n  `provinceId` varchar(10) DEFAULT NULL,\r\n  `province` varchar(30) DEFAULT NULL,\r\n  `cityId` varchar(10) DEFAULT NULL,\r\n  `city` varchar(30) DEFAULT NULL,\r\n  `sign` int(11) DEFAULT NULL,\r\n  `name` varchar(10) DEFAULT NULL,\r\n  `section2` int(11) DEFAULT NULL,\r\n  `provinceId2` varchar(10) DEFAULT NULL,\r\n  `province2` varchar(30) DEFAULT NULL,\r\n  `cityId2` varchar(10) DEFAULT NULL,\r\n  `city2` varchar(30) DEFAULT NULL,\r\n  `sign2` int(11) DEFAULT NULL,\r\n  `name2` varchar(10) DEFAULT NULL,\r\n  PRIMARY KEY (`id`)\r\n) ENGINE=InnoDB AUTO_INCREMENT=458746 DEFAULT CHARSET=utf8mb4\nFrom the underlying, this issue duplicated https://github.com/ClickHouse/ClickHouse/issues/14786\r\nit's payload.available() caused, and on the fixing",
  "created_at": "2020-09-15T14:24:46Z",
  "modified_files": [
    "src/Core/MySQL/MySQLReplication.cpp",
    "src/Core/MySQL/MySQLReplication.h",
    "b/src/IO/MySQLBinlogEventReadBuffer.cpp",
    "b/src/IO/MySQLBinlogEventReadBuffer.h",
    "src/IO/ya.make"
  ],
  "modified_test_files": [
    "b/src/IO/tests/gtest_mysql_binlog_event_read_buffer.cpp"
  ]
}