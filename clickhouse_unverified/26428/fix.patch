diff --git a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp
index 1ce6c4f36d86..29a7a0a4d87b 100644
--- a/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp
+++ b/src/Interpreters/ExecuteScalarSubqueriesVisitor.cpp
@@ -157,9 +157,14 @@ void ExecuteScalarSubqueriesMatcher::visit(const ASTSubquery & subquery, ASTPtr
     if (data.only_analyze || !settings.enable_scalar_subquery_optimization || worthConvertingToLiteral(scalar)
         || !data.getContext()->hasQueryContext())
     {
+        /// subquery and ast can be the same object and ast will be moved.
+        /// Save these fields to avoid use after move.
+        auto alias = subquery.alias;
+        auto prefer_alias_to_column_name = subquery.prefer_alias_to_column_name;
+
         auto lit = std::make_unique<ASTLiteral>((*scalar.safeGetByPosition(0).column)[0]);
-        lit->alias = subquery.alias;
-        lit->prefer_alias_to_column_name = subquery.prefer_alias_to_column_name;
+        lit->alias = alias;
+        lit->prefer_alias_to_column_name = prefer_alias_to_column_name;
         ast = addTypeConversionToAST(std::move(lit), scalar.safeGetByPosition(0).type->getName());
 
         /// If only analyze was requested the expression is not suitable for constant folding, disable it.
@@ -167,8 +172,8 @@ void ExecuteScalarSubqueriesMatcher::visit(const ASTSubquery & subquery, ASTPtr
         {
             ast->as<ASTFunction>()->alias.clear();
             auto func = makeASTFunction("identity", std::move(ast));
-            func->alias = subquery.alias;
-            func->prefer_alias_to_column_name = subquery.prefer_alias_to_column_name;
+            func->alias = alias;
+            func->prefer_alias_to_column_name = prefer_alias_to_column_name;
             ast = std::move(func);
         }
     }
