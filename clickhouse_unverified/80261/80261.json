{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 80261,
  "instance_id": "ClickHouse__ClickHouse-80261",
  "issue_numbers": [
    "80250"
  ],
  "base_commit": "5776b89b98684341f92596fdca05e11192f187d1",
  "patch": "diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex adc1da06f32c..09b99888cf72 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -66,7 +66,7 @@ extern const int BAD_TYPE_OF_FIELD;\n /// - (1) the pattern has a wildcard\n /// - (2) the first wildcard is '%' and is only followed by nothing or other '%'\n /// e.g. 'test%' or 'test%% has perfect prefix 'test', 'test%x', 'test%_' or 'test_' has no perfect prefix.\n-String extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool requires_perfect_prefix)\n+std::tuple<String, bool> extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool requires_perfect_prefix)\n {\n     String fixed_prefix;\n     fixed_prefix.reserve(like_pattern.size());\n@@ -79,27 +79,39 @@ String extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool req\n         {\n             case '%':\n             case '_':\n+            {\n+                bool is_perfect_prefix = std::all_of(pos, end, [](auto c) { return c == '%'; });\n                 if (requires_perfect_prefix)\n                 {\n-                    bool is_prefect_prefix = std::all_of(pos, end, [](auto c) { return c == '%'; });\n-                    return is_prefect_prefix ? fixed_prefix : \"\";\n+                    if (is_perfect_prefix)\n+                        return {fixed_prefix, true};\n+                    else\n+                        return {\"\", false};\n+                }\n+                else\n+                {\n+                    return {fixed_prefix, is_perfect_prefix};\n                 }\n-            return fixed_prefix;\n+            }\n             case '\\\\':\n+            {\n                 ++pos;\n-            if (pos == end)\n-                break;\n-            [[fallthrough]];\n+                if (pos == end)\n+                    break;\n+                [[fallthrough]];\n+            }\n             default:\n+            {\n                 fixed_prefix += *pos;\n+            }\n         }\n \n         ++pos;\n     }\n     /// If we can reach this code, it means there was no wildcard found in the pattern, so it is not a perfect prefix\n     if (requires_perfect_prefix)\n-        return \"\";\n-    return fixed_prefix;\n+        return {\"\", false};\n+    return {fixed_prefix, false};\n }\n \n /// for \"^prefix...\" string it returns \"prefix\"\n@@ -361,10 +373,13 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n                 if (value.getType() != Field::Types::String)\n                     return false;\n \n-                String prefix = extractFixedPrefixFromLikePattern(value.safeGet<String>(), /*requires_perfect_prefix*/ false);\n+                auto [prefix, is_perfect] = extractFixedPrefixFromLikePattern(value.safeGet<String>(), /*requires_perfect_prefix*/ false);\n                 if (prefix.empty())\n                     return false;\n \n+                if (!is_perfect)\n+                    out.relaxed = true;\n+\n                 String right_bound = firstStringThatIsGreaterThanAllStringsWithPrefix(prefix);\n \n                 out.function = RPNElement::FUNCTION_IN_RANGE;\n@@ -382,10 +397,12 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n                 if (value.getType() != Field::Types::String)\n                     return false;\n \n-                String prefix = extractFixedPrefixFromLikePattern(value.safeGet<String>(), /*requires_perfect_prefix*/ true);\n+                auto [prefix, is_perfect] = extractFixedPrefixFromLikePattern(value.safeGet<String>(), /*requires_perfect_prefix*/ true);\n                 if (prefix.empty())\n                     return false;\n \n+                chassert(is_perfect);\n+\n                 String right_bound = firstStringThatIsGreaterThanAllStringsWithPrefix(prefix);\n \n                 out.function = RPNElement::FUNCTION_NOT_IN_RANGE;\n@@ -441,6 +458,7 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n                 out.range = !right_bound.empty()\n                     ? Range(prefix, true, right_bound, false)\n                     : Range::createLeftBounded(prefix, true);\n+                out.relaxed = true;\n \n                 return true;\n             }\n@@ -477,7 +495,6 @@ const KeyCondition::AtomMap KeyCondition::atom_map\n         }\n };\n \n-static const std::set<std::string_view> always_relaxed_atom_functions = {\"match\"};\n static const std::set<KeyCondition::RPNElement::Function> always_relaxed_atom_elements\n     = {KeyCondition::RPNElement::FUNCTION_UNKNOWN, KeyCondition::RPNElement::FUNCTION_ARGS_IN_HYPERRECTANGLE, KeyCondition::RPNElement::FUNCTION_POINT_IN_POLYGON};\n \n@@ -2073,9 +2090,6 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n             return atom_it->second(out, const_value);\n         };\n \n-        if (always_relaxed_atom_functions.contains(func_name))\n-            relaxed = true;\n-\n         bool allow_constant_transformation = !no_relaxed_atom_functions.contains(func_name);\n         if (num_args == 1)\n         {\n@@ -2291,7 +2305,10 @@ bool KeyCondition::extractAtomFromTree(const RPNBuilderTreeNode & node, RPNEleme\n         out.monotonic_functions_chain = std::move(chain);\n         out.argument_num_of_space_filling_curve = argument_num_of_space_filling_curve;\n \n-        return atom_it->second(out, const_value);\n+        bool valid_atom = atom_it->second(out, const_value);\n+        if (valid_atom && out.relaxed)\n+            relaxed = true;\n+        return valid_atom;\n     }\n     if (node.tryGetConstant(const_value, const_type))\n     {\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex c20881a0b723..2a1ada8d549d 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -218,6 +218,9 @@ class KeyCondition\n \n         Function function = FUNCTION_UNKNOWN;\n \n+        /// Whether to relax the key condition (e.g., for LIKE queries without a perfect prefix).\n+        bool relaxed = false;\n+\n         /// For FUNCTION_IN_RANGE and FUNCTION_NOT_IN_RANGE.\n         Range range = Range::createWholeUniverse();\n         size_t key_column = 0;\n@@ -481,6 +484,6 @@ class KeyCondition\n     bool relaxed = false;\n };\n \n-String extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool requires_perfect_prefix);\n+std::tuple<String, bool> extractFixedPrefixFromLikePattern(std::string_view like_pattern, bool requires_perfect_prefix);\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03461_pk_prefix_trivial_count.reference b/tests/queries/0_stateless/03461_pk_prefix_trivial_count.reference\nnew file mode 100644\nindex 000000000000..c73616a3aa18\n--- /dev/null\n+++ b/tests/queries/0_stateless/03461_pk_prefix_trivial_count.reference\n@@ -0,0 +1,9 @@\n+-- { echo ON }\n+\n+DROP TABLE IF EXISTS t;\n+CREATE TABLE t(k String) ORDER BY k as select 'dst_'||number from numbers(10);\n+SELECT count(*) FROM t WHERE k LIKE 'dst_kkkk_1111%';\n+0\n+SELECT count(*) FROM t WHERE k LIKE 'dst%kkkk';\n+0\n+DROP TABLE t;\ndiff --git a/tests/queries/0_stateless/03461_pk_prefix_trivial_count.sql b/tests/queries/0_stateless/03461_pk_prefix_trivial_count.sql\nnew file mode 100644\nindex 000000000000..7f733de0919f\n--- /dev/null\n+++ b/tests/queries/0_stateless/03461_pk_prefix_trivial_count.sql\n@@ -0,0 +1,11 @@\n+-- { echo ON }\n+\n+DROP TABLE IF EXISTS t;\n+\n+CREATE TABLE t(k String) ORDER BY k as select 'dst_'||number from numbers(10);\n+\n+SELECT count(*) FROM t WHERE k LIKE 'dst_kkkk_1111%';\n+\n+SELECT count(*) FROM t WHERE k LIKE 'dst%kkkk';\n+\n+DROP TABLE t;\n",
  "problem_statement": "Wrong count result because of trivial count optimization\n### Company or project name\n\nhttps://www.innervate.com/\n\n### Describe what's wrong\n\nWrong query result\n\n### Does it reproduce on the most recent release?\n\nYes\n\n### How to reproduce\n\n```sql\nCREATE TABLE t(k String) ORDER BY k as select 'dst_'||number from numbers(1e6);\n\nselect count(*) from t where k like 'dst_kkkk_1111%';\n--\n1000000 -- expected 0\n\nselect count(*) from t where identity(k) like 'dst_kkkk_1111%';\n--\n0\n\nselect count(*) from t where k like '%dst_kkkk_1111%';\n--\n0\n\n\n\nselect count(*) from t where k like 'dst%kkkkk';\n--\n1000000 -- expected 0\n\nselect count(*) from t where identity(k) like 'dst%kkkkk';\n--\n0\n```\n\nhttps://fiddle.clickhouse.com/d298aa49-80f7-480b-be8c-ad520b72fa2c\n\n\nIntroduced in 24.6. https://fiddle.clickhouse.com/460e99df-cc70-4524-a802-bf06a5c83d1c\n\nRelated to `_` & `%` -- special meaning in like\n\n```\nselect count(*) from t where k like 'dst\\_kkkk\\_1111%';\n--\n0\n```\n\n\n### Expected behavior\n\n_No response_\n\n### Error message and/or stacktrace\n\n_No response_\n\n### Additional context\n\n_No response_\n",
  "hints_text": "BTW `optimize_trivial_count_query=0` does not fix it.\n\nhttps://fiddle.clickhouse.com/8cfda55e-dd2c-4d74-982f-4d322beb7d84\n\nExact range inference somehow failed for string prefix conditions. Will investigate. As a workaround, disable `optimize_use_implicit_projections` ftm.",
  "created_at": "2025-05-15T15:14:06Z"
}