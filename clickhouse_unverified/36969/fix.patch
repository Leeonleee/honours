diff --git a/src/Columns/ColumnArray.h b/src/Columns/ColumnArray.h
index 4e951ec28b82..5970802f598b 100644
--- a/src/Columns/ColumnArray.h
+++ b/src/Columns/ColumnArray.h
@@ -176,6 +176,9 @@ class ColumnArray final : public COWHelper<IColumn, ColumnArray>
 
     void getIndicesOfNonDefaultRows(Offsets & indices, size_t from, size_t limit) const override;
 
+    void finalize() override { data->finalize(); }
+    bool isFinalized() const override { return data->isFinalized(); }
+
     bool isCollationSupported() const override { return getData().isCollationSupported(); }
 
     size_t getNumberOfDimensions() const;
diff --git a/src/Columns/ColumnMap.h b/src/Columns/ColumnMap.h
index a3e171008fff..1e03633ced70 100644
--- a/src/Columns/ColumnMap.h
+++ b/src/Columns/ColumnMap.h
@@ -93,6 +93,8 @@ class ColumnMap final : public COWHelper<IColumn, ColumnMap>
     bool structureEquals(const IColumn & rhs) const override;
     double getRatioOfDefaultRows(double sample_ratio) const override;
     void getIndicesOfNonDefaultRows(Offsets & indices, size_t from, size_t limit) const override;
+    void finalize() override { nested->finalize(); }
+    bool isFinalized() const override { return nested->isFinalized(); }
 
     const ColumnArray & getNestedColumn() const { return assert_cast<const ColumnArray &>(*nested); }
     ColumnArray & getNestedColumn() { return assert_cast<ColumnArray &>(*nested); }
diff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp
index 86586559ff7c..bf4630137d5c 100644
--- a/src/Columns/ColumnObject.cpp
+++ b/src/Columns/ColumnObject.cpp
@@ -732,8 +732,8 @@ void ColumnObject::get(size_t n, Field & res) const
 {
     assert(n < size());
     res = Object();
-
     auto & object = res.get<Object &>();
+
     for (const auto & entry : subcolumns)
     {
         auto it = object.try_emplace(entry->path.getPath()).first;
@@ -744,7 +744,6 @@ void ColumnObject::get(size_t n, Field & res) const
 void ColumnObject::insertFrom(const IColumn & src, size_t n)
 {
     insert(src[n]);
-    finalize();
 }
 
 void ColumnObject::insertRangeFrom(const IColumn & src, size_t start, size_t length)
@@ -792,9 +791,8 @@ MutableColumnPtr ColumnObject::applyForSubcolumns(Func && func) const
 {
     if (!isFinalized())
     {
-        auto finalized = IColumn::mutate(getPtr());
+        auto finalized = cloneFinalized();
         auto & finalized_object = assert_cast<ColumnObject &>(*finalized);
-        finalized_object.finalize();
         return finalized_object.applyForSubcolumns(std::forward<Func>(func));
     }
 
diff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h
index f32356fed6e6..8fcf3d41fbad 100644
--- a/src/Columns/ColumnObject.h
+++ b/src/Columns/ColumnObject.h
@@ -198,10 +198,6 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     Subcolumns & getSubcolumns() { return subcolumns; }
     PathsInData getKeys() const;
 
-    /// Finalizes all subcolumns.
-    void finalize();
-    bool isFinalized() const;
-
     /// Part of interface
 
     const char * getFamilyName() const override { return "Object"; }
@@ -219,12 +215,17 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     void popBack(size_t length) override;
     Field operator[](size_t n) const override;
     void get(size_t n, Field & res) const override;
+
     ColumnPtr permute(const Permutation & perm, size_t limit) const override;
     ColumnPtr filter(const Filter & filter, ssize_t result_size_hint) const override;
     ColumnPtr index(const IColumn & indexes, size_t limit) const override;
     ColumnPtr replicate(const Offsets & offsets) const override;
     MutableColumnPtr cloneResized(size_t new_size) const override;
 
+    /// Finalizes all subcolumns.
+    void finalize() override;
+    bool isFinalized() const override;
+
     /// Order of rows in ColumnObject is undefined.
     void getPermutation(PermutationSortDirection, PermutationSortStability, size_t, int, Permutation & res) const override;
     void compareColumn(const IColumn & rhs, size_t rhs_row_num,
@@ -264,9 +265,7 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
     template <typename Func>
     MutableColumnPtr applyForSubcolumns(Func && func) const;
 
-    /// For given subcolumn return subcolumn from the same Nested type.
     /// It's used to get shared sized of Nested to insert correct default values.
     const Subcolumns::Node * getLeafOfTheSameNested(const Subcolumns::NodePtr & entry) const;
 };
-
 }
diff --git a/src/Columns/ColumnTuple.cpp b/src/Columns/ColumnTuple.cpp
index 3577b6dee284..d8a43bf510db 100644
--- a/src/Columns/ColumnTuple.cpp
+++ b/src/Columns/ColumnTuple.cpp
@@ -570,4 +570,15 @@ void ColumnTuple::getIndicesOfNonDefaultRows(Offsets & indices, size_t from, siz
     return getIndicesOfNonDefaultRowsImpl<ColumnTuple>(indices, from, limit);
 }
 
+void ColumnTuple::finalize()
+{
+    for (auto & column : columns)
+        column->finalize();
+}
+
+bool ColumnTuple::isFinalized() const
+{
+    return std::all_of(columns.begin(), columns.end(), [](const auto & column) { return column->isFinalized(); });
+}
+
 }
diff --git a/src/Columns/ColumnTuple.h b/src/Columns/ColumnTuple.h
index 385de7db1e72..96395d4edfb8 100644
--- a/src/Columns/ColumnTuple.h
+++ b/src/Columns/ColumnTuple.h
@@ -103,6 +103,8 @@ class ColumnTuple final : public COWHelper<IColumn, ColumnTuple>
     ColumnPtr compress() const override;
     double getRatioOfDefaultRows(double sample_ratio) const override;
     void getIndicesOfNonDefaultRows(Offsets & indices, size_t from, size_t limit) const override;
+    void finalize() override;
+    bool isFinalized() const override;
 
     size_t tupleSize() const { return columns.size(); }
 
diff --git a/src/Columns/IColumn.h b/src/Columns/IColumn.h
index 19f3dea4f820..548b2b44f150 100644
--- a/src/Columns/IColumn.h
+++ b/src/Columns/IColumn.h
@@ -453,6 +453,16 @@ class IColumn : public COW<IColumn>
         return getPtr();
     }
 
+    /// Some columns may require finalization before using of other operations.
+    virtual void finalize() {}
+    virtual bool isFinalized() const { return true; }
+
+    MutablePtr cloneFinalized() const
+    {
+        auto finalized = IColumn::mutate(getPtr());
+        finalized->finalize();
+        return finalized;
+    }
 
     [[nodiscard]] static MutablePtr mutate(Ptr ptr)
     {
diff --git a/src/DataTypes/DataTypeArray.h b/src/DataTypes/DataTypeArray.h
index 122ac8e03a3a..033a657c845d 100644
--- a/src/DataTypes/DataTypeArray.h
+++ b/src/DataTypes/DataTypeArray.h
@@ -48,6 +48,7 @@ class DataTypeArray final : public IDataType
     bool textCanContainOnlyValidUTF8() const override { return nested->textCanContainOnlyValidUTF8(); }
     bool isComparable() const override { return nested->isComparable(); }
     bool canBeComparedWithCollation() const override { return nested->canBeComparedWithCollation(); }
+    bool hasDynamicSubcolumns() const override { return nested->hasDynamicSubcolumns(); }
 
     bool isValueUnambiguouslyRepresentedInContiguousMemoryRegion() const override
     {
diff --git a/src/DataTypes/DataTypeMap.cpp b/src/DataTypes/DataTypeMap.cpp
index 42ec739c33ba..d49c205fc592 100644
--- a/src/DataTypes/DataTypeMap.cpp
+++ b/src/DataTypes/DataTypeMap.cpp
@@ -22,6 +22,27 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
 }
 
+DataTypeMap::DataTypeMap(const DataTypePtr & nested_)
+    : nested(nested_)
+{
+    const auto * type_array = typeid_cast<const DataTypeArray *>(nested.get());
+    if (!type_array)
+        throw Exception(ErrorCodes::BAD_ARGUMENTS,
+            "Expected Array(Tuple(key, value)) type, got {}", nested->getName());
+
+    const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_array->getNestedType().get());
+    if (!type_tuple)
+        throw Exception(ErrorCodes::BAD_ARGUMENTS,
+            "Expected Array(Tuple(key, value)) type, got {}", nested->getName());
+
+    if (type_tuple->getElements().size() != 2)
+        throw Exception(ErrorCodes::BAD_ARGUMENTS,
+            "Expected Array(Tuple(key, value)) type, got {}", nested->getName());
+
+    key_type = type_tuple->getElement(0);
+    value_type = type_tuple->getElement(1);
+    assertKeyType();
+}
 
 DataTypeMap::DataTypeMap(const DataTypes & elems_)
 {
diff --git a/src/DataTypes/DataTypeMap.h b/src/DataTypes/DataTypeMap.h
index 479008031fed..2ab5c602a259 100644
--- a/src/DataTypes/DataTypeMap.h
+++ b/src/DataTypes/DataTypeMap.h
@@ -23,6 +23,7 @@ class DataTypeMap final : public IDataType
 public:
     static constexpr bool is_parametric = true;
 
+    explicit DataTypeMap(const DataTypePtr & nested_);
     explicit DataTypeMap(const DataTypes & elems);
     DataTypeMap(const DataTypePtr & key_type_, const DataTypePtr & value_type_);
 
@@ -40,6 +41,7 @@ class DataTypeMap final : public IDataType
     bool isComparable() const override { return key_type->isComparable() && value_type->isComparable(); }
     bool isParametric() const override { return true; }
     bool haveSubtypes() const override { return true; }
+    bool hasDynamicSubcolumns() const override { return nested->hasDynamicSubcolumns(); }
 
     const DataTypePtr & getKeyType() const { return key_type; }
     const DataTypePtr & getValueType() const { return value_type; }
diff --git a/src/DataTypes/DataTypeObject.h b/src/DataTypes/DataTypeObject.h
index 503947c3738b..2f6ad9615123 100644
--- a/src/DataTypes/DataTypeObject.h
+++ b/src/DataTypes/DataTypeObject.h
@@ -36,6 +36,7 @@ class DataTypeObject : public IDataType
     bool haveSubtypes() const override { return false; }
     bool equals(const IDataType & rhs) const override;
     bool isParametric() const override { return true; }
+    bool hasDynamicSubcolumns() const override { return true; }
 
     SerializationPtr doGetDefaultSerialization() const override;
 
diff --git a/src/DataTypes/DataTypeTuple.cpp b/src/DataTypes/DataTypeTuple.cpp
index ef05cd440c03..87cbac4cfb2b 100644
--- a/src/DataTypes/DataTypeTuple.cpp
+++ b/src/DataTypes/DataTypeTuple.cpp
@@ -247,6 +247,11 @@ bool DataTypeTuple::haveMaximumSizeOfValue() const
     return std::all_of(elems.begin(), elems.end(), [](auto && elem) { return elem->haveMaximumSizeOfValue(); });
 }
 
+bool DataTypeTuple::hasDynamicSubcolumns() const
+{
+    return std::any_of(elems.begin(), elems.end(), [](auto && elem) { return elem->hasDynamicSubcolumns(); });
+}
+
 bool DataTypeTuple::isComparable() const
 {
     return std::all_of(elems.begin(), elems.end(), [](auto && elem) { return elem->isComparable(); });
diff --git a/src/DataTypes/DataTypeTuple.h b/src/DataTypes/DataTypeTuple.h
index 5abec18bd3b5..152f21015f5a 100644
--- a/src/DataTypes/DataTypeTuple.h
+++ b/src/DataTypes/DataTypeTuple.h
@@ -50,6 +50,7 @@ class DataTypeTuple final : public IDataType
     bool isComparable() const override;
     bool textCanContainOnlyValidUTF8() const override;
     bool haveMaximumSizeOfValue() const override;
+    bool hasDynamicSubcolumns() const override;
     size_t getMaximumSizeOfValueInMemory() const override;
     size_t getSizeOfValueInMemory() const override;
 
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index c93128ced959..4db944c8c3fb 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -291,6 +291,9 @@ class IDataType : private boost::noncopyable, public std::enable_shared_from_thi
     /// Strings, Numbers, Date, DateTime, Nullable
     virtual bool canBeInsideLowCardinality() const { return false; }
 
+    /// Object, Array(Object), Tuple(..., Object, ...)
+    virtual bool hasDynamicSubcolumns() const { return false; }
+
     /// Updates avg_value_size_hint for newly read column. Uses to optimize deserialization. Zero expected for first column.
     static void updateAvgValueSizeHint(const IColumn & column, double & avg_value_size_hint);
 
diff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp
index e5d8d05acb56..e711b34ffa9b 100644
--- a/src/DataTypes/ObjectUtils.cpp
+++ b/src/DataTypes/ObjectUtils.cpp
@@ -1,17 +1,19 @@
-#include <Storages/StorageSnapshot.h>
 #include <DataTypes/ObjectUtils.h>
 #include <DataTypes/DataTypeObject.h>
 #include <DataTypes/DataTypeNothing.h>
 #include <DataTypes/DataTypeArray.h>
+#include <DataTypes/DataTypeMap.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <DataTypes/DataTypesNumber.h>
 #include <DataTypes/DataTypeNested.h>
 #include <DataTypes/DataTypeFactory.h>
 #include <DataTypes/getLeastSupertype.h>
 #include <DataTypes/NestedUtils.h>
+#include <Storages/StorageSnapshot.h>
 #include <Columns/ColumnObject.h>
 #include <Columns/ColumnTuple.h>
 #include <Columns/ColumnArray.h>
+#include <Columns/ColumnMap.h>
 #include <Columns/ColumnNullable.h>
 #include <Parsers/ASTSelectQuery.h>
 #include <Parsers/ASTExpressionList.h>
@@ -105,10 +107,11 @@ Array createEmptyArrayField(size_t num_dimensions)
 DataTypePtr getDataTypeByColumn(const IColumn & column)
 {
     auto idx = column.getDataType();
-    if (WhichDataType(idx).isSimple())
+    WhichDataType which(idx);
+    if (which.isSimple())
         return DataTypeFactory::instance().get(String(magic_enum::enum_name(idx)));
 
-    if (WhichDataType(idx).isNothing())
+    if (which.isNothing())
         return std::make_shared<DataTypeNothing>();
 
     if (const auto * column_array = checkAndGetColumn<ColumnArray>(&column))
@@ -132,41 +135,124 @@ static auto extractVector(const std::vector<Tuple> & vec)
     return res;
 }
 
-void convertObjectsToTuples(Block & block, const NamesAndTypesList & extended_storage_columns)
+static DataTypePtr recreateTupleWithElements(const DataTypeTuple & type_tuple, const DataTypes & elements)
 {
-    std::unordered_map<String, DataTypePtr> storage_columns_map;
-    for (const auto & [name, type] : extended_storage_columns)
-        storage_columns_map[name] = type;
+    return type_tuple.haveExplicitNames()
+        ? std::make_shared<DataTypeTuple>(elements, type_tuple.getElementNames())
+        : std::make_shared<DataTypeTuple>(elements);
+}
 
-    for (auto & column : block)
+static std::pair<ColumnPtr, DataTypePtr> convertObjectColumnToTuple(
+    const ColumnObject & column_object, const DataTypeObject & type_object)
+{
+    if (!column_object.isFinalized())
     {
-        if (!isObject(column.type))
-            continue;
+        auto finalized = column_object.cloneFinalized();
+        const auto & finalized_object = assert_cast<const ColumnObject &>(*finalized);
+        return convertObjectColumnToTuple(finalized_object, type_object);
+    }
 
-        const auto & column_object = assert_cast<const ColumnObject &>(*column.column);
-        if (!column_object.isFinalized())
-            throw Exception(ErrorCodes::LOGICAL_ERROR,
-                "Cannot convert to tuple column '{}' from type {}. Column should be finalized first",
-                column.name, column.type->getName());
+    const auto & subcolumns = column_object.getSubcolumns();
 
-        std::tie(column.column, column.type) = unflattenObjectToTuple(column_object);
+    PathsInData tuple_paths;
+    DataTypes tuple_types;
+    Columns tuple_columns;
 
-        auto it = storage_columns_map.find(column.name);
-        if (it == storage_columns_map.end())
-            throw Exception(ErrorCodes::LOGICAL_ERROR, "Column '{}' not found in storage", column.name);
+    for (const auto & entry : subcolumns)
+    {
+        tuple_paths.emplace_back(entry->path);
+        tuple_types.emplace_back(entry->data.getLeastCommonType());
+        tuple_columns.emplace_back(entry->data.getFinalizedColumnPtr());
+    }
 
-        /// Check that constructed Tuple type and type in storage are compatible.
-        getLeastCommonTypeForObject({column.type, it->second}, true);
+    return unflattenTuple(tuple_paths, tuple_types, tuple_columns);
+}
+
+static std::pair<ColumnPtr, DataTypePtr> recursivlyConvertDynamicColumnToTuple(
+    const ColumnPtr & column, const DataTypePtr & type)
+{
+    if (!type->hasDynamicSubcolumns())
+        return {column, type};
+
+    if (const auto * type_object = typeid_cast<const DataTypeObject *>(type.get()))
+    {
+        const auto & column_object = assert_cast<const ColumnObject &>(*column);
+        return convertObjectColumnToTuple(column_object, *type_object);
+    }
+
+    if (const auto * type_array = typeid_cast<const DataTypeArray *>(type.get()))
+    {
+        const auto & column_array = assert_cast<const ColumnArray &>(*column);
+        auto [new_column, new_type] = recursivlyConvertDynamicColumnToTuple(
+            column_array.getDataPtr(), type_array->getNestedType());
+
+        return
+        {
+            ColumnArray::create(new_column, column_array.getOffsetsPtr()),
+            std::make_shared<DataTypeArray>(std::move(new_type)),
+        };
+    }
+
+    if (const auto * type_map = typeid_cast<const DataTypeMap *>(type.get()))
+    {
+        const auto & column_map = assert_cast<const ColumnMap &>(*column);
+        auto [new_column, new_type] = recursivlyConvertDynamicColumnToTuple(
+            column_map.getNestedColumnPtr(), type_map->getNestedType());
+
+        return
+        {
+            ColumnMap::create(new_column),
+            std::make_shared<DataTypeMap>(std::move(new_type)),
+        };
     }
+
+    if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type.get()))
+    {
+        const auto & tuple_columns = assert_cast<const ColumnTuple &>(*column).getColumns();
+        const auto & tuple_types = type_tuple->getElements();
+
+        assert(tuple_columns.size() == tuple_types.size());
+        const size_t tuple_size = tuple_types.size();
+
+        Columns new_tuple_columns(tuple_size);
+        DataTypes new_tuple_types(tuple_size);
+
+        for (size_t i = 0; i < tuple_size; ++i)
+        {
+            std::tie(new_tuple_columns[i], new_tuple_types[i])
+                = recursivlyConvertDynamicColumnToTuple(tuple_columns[i], tuple_types[i]);
+        }
+
+        return
+        {
+            ColumnTuple::create(new_tuple_columns),
+            recreateTupleWithElements(*type_tuple, new_tuple_types)
+        };
+    }
+
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Type {} unexpectedly has dynamic columns", type->getName());
 }
 
-void deduceTypesOfObjectColumns(const StorageSnapshotPtr & storage_snapshot, Block & block)
+void convertDynamicColumnsToTuples(Block & block, const StorageSnapshotPtr & storage_snapshot)
 {
-    if (!storage_snapshot->object_columns.empty())
+    for (auto & column : block)
     {
-        auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects();
-        auto storage_columns = storage_snapshot->getColumns(options);
-        convertObjectsToTuples(block, storage_columns);
+        if (!column.type->hasDynamicSubcolumns())
+            continue;
+
+        std::tie(column.column, column.type)
+            = recursivlyConvertDynamicColumnToTuple(column.column, column.type);
+
+        GetColumnsOptions options(GetColumnsOptions::AllPhysical);
+        auto storage_column = storage_snapshot->tryGetColumn(options, column.name);
+        if (!storage_column)
+            throw Exception(ErrorCodes::LOGICAL_ERROR, "Column '{}' not found in storage", column.name);
+
+        auto storage_column_concrete = storage_snapshot->getColumn(options.withExtendedObjects(), column.name);
+
+        /// Check that constructed Tuple type and type in storage are compatible.
+        getLeastCommonTypeForDynamicColumns(
+            storage_column->type, {column.type, storage_column_concrete.type}, true);
     }
 }
 
@@ -217,24 +303,8 @@ void checkObjectHasNoAmbiguosPaths(const PathsInData & paths)
     }
 }
 
-DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambiguos_paths)
+static DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambiguos_paths)
 {
-    if (types.empty())
-        return nullptr;
-
-    bool all_equal = true;
-    for (size_t i = 1; i < types.size(); ++i)
-    {
-        if (!types[i]->equals(*types[0]))
-        {
-            all_equal = false;
-            break;
-        }
-    }
-
-    if (all_equal)
-        return types[0];
-
     /// Types of subcolumns by path from all tuples.
     std::unordered_map<PathInData, DataTypes, PathInData::Hash> subcolumns_types;
 
@@ -287,19 +357,139 @@ DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambi
     return unflattenTuple(tuple_paths, tuple_types);
 }
 
-NameSet getNamesOfObjectColumns(const NamesAndTypesList & columns_list)
+static DataTypePtr getLeastCommonTypeForDynamicColumnsImpl(
+    const DataTypePtr & type_in_storage, const DataTypes & concrete_types, bool check_ambiguos_paths);
+
+template<typename Type>
+static DataTypePtr getLeastCommonTypeForColumnWithNestedType(
+    const Type & type, const DataTypes & concrete_types, bool check_ambiguos_paths)
 {
-    NameSet res;
-    for (const auto & [name, type] : columns_list)
-        if (isObject(type))
-            res.insert(name);
+    DataTypes nested_types;
+    nested_types.reserve(concrete_types.size());
 
-    return res;
+    for (const auto & concrete_type : concrete_types)
+    {
+        const auto * type_with_nested_conctete = typeid_cast<const Type *>(concrete_type.get());
+        if (!type_with_nested_conctete)
+            throw Exception(ErrorCodes::TYPE_MISMATCH, "Expected {} type, got {}", demangle(typeid(Type).name()), concrete_type->getName());
+
+        nested_types.push_back(type_with_nested_conctete->getNestedType());
+    }
+
+    return std::make_shared<Type>(
+        getLeastCommonTypeForDynamicColumnsImpl(
+            type.getNestedType(), nested_types, check_ambiguos_paths));
 }
 
-bool hasObjectColumns(const ColumnsDescription & columns)
+static DataTypePtr getLeastCommonTypeForTuple(
+    const DataTypeTuple & type, const DataTypes & concrete_types, bool check_ambiguos_paths)
 {
-    return std::any_of(columns.begin(), columns.end(), [](const auto & column) { return isObject(column.type); });
+    const auto & element_types = type.getElements();
+    DataTypes new_element_types(element_types.size());
+
+    for (size_t i = 0; i < element_types.size(); ++i)
+    {
+        DataTypes concrete_element_types;
+        concrete_element_types.reserve(concrete_types.size());
+
+        for (const auto & type_concrete : concrete_types)
+        {
+            const auto * type_tuple_conctete = typeid_cast<const DataTypeTuple *>(type_concrete.get());
+            if (!type_tuple_conctete)
+                throw Exception(ErrorCodes::TYPE_MISMATCH, "Expected Tuple type, got {}", type_concrete->getName());
+
+            concrete_element_types.push_back(type_tuple_conctete->getElement(i));
+        }
+
+        new_element_types[i] = getLeastCommonTypeForDynamicColumnsImpl(
+            element_types[i], concrete_element_types, check_ambiguos_paths);
+    }
+
+    return recreateTupleWithElements(type, new_element_types);
+}
+
+static DataTypePtr getLeastCommonTypeForDynamicColumnsImpl(
+    const DataTypePtr & type_in_storage, const DataTypes & concrete_types, bool check_ambiguos_paths)
+{
+    if (!type_in_storage->hasDynamicSubcolumns())
+        return type_in_storage;
+
+    if (isObject(type_in_storage))
+        return getLeastCommonTypeForObject(concrete_types, check_ambiguos_paths);
+
+    if (const auto * type_array = typeid_cast<const DataTypeArray *>(type_in_storage.get()))
+        return getLeastCommonTypeForColumnWithNestedType(*type_array, concrete_types, check_ambiguos_paths);
+
+    if (const auto * type_map = typeid_cast<const DataTypeMap *>(type_in_storage.get()))
+        return getLeastCommonTypeForColumnWithNestedType(*type_map, concrete_types, check_ambiguos_paths);
+
+    if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_in_storage.get()))
+        return getLeastCommonTypeForTuple(*type_tuple, concrete_types, check_ambiguos_paths);
+
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Type {} unexpectedly has dynamic columns", type_in_storage->getName());
+}
+
+DataTypePtr getLeastCommonTypeForDynamicColumns(
+    const DataTypePtr & type_in_storage, const DataTypes & concrete_types, bool check_ambiguos_paths)
+{
+    if (concrete_types.empty())
+        return nullptr;
+
+    bool all_equal = true;
+    for (size_t i = 1; i < concrete_types.size(); ++i)
+    {
+        if (!concrete_types[i]->equals(*concrete_types[0]))
+        {
+            all_equal = false;
+            break;
+        }
+    }
+
+    if (all_equal)
+        return concrete_types[0];
+
+    return getLeastCommonTypeForDynamicColumnsImpl(type_in_storage, concrete_types, check_ambiguos_paths);
+}
+
+DataTypePtr createConcreteEmptyDynamicColumn(const DataTypePtr & type_in_storage)
+{
+    if (!type_in_storage->hasDynamicSubcolumns())
+        return type_in_storage;
+
+    if (isObject(type_in_storage))
+        return std::make_shared<DataTypeTuple>(
+            DataTypes{std::make_shared<DataTypeUInt8>()}, Names{ColumnObject::COLUMN_NAME_DUMMY});
+
+    if (const auto * type_array = typeid_cast<const DataTypeArray *>(type_in_storage.get()))
+        return std::make_shared<DataTypeArray>(
+            createConcreteEmptyDynamicColumn(type_array->getNestedType()));
+
+    if (const auto * type_map = typeid_cast<const DataTypeMap *>(type_in_storage.get()))
+        return std::make_shared<DataTypeMap>(
+            createConcreteEmptyDynamicColumn(type_map->getNestedType()));
+
+    if (const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type_in_storage.get()))
+    {
+        const auto & elements = type_tuple->getElements();
+        DataTypes new_elements;
+        new_elements.reserve(elements.size());
+
+        for (const auto & element : elements)
+            new_elements.push_back(createConcreteEmptyDynamicColumn(element));
+
+        return recreateTupleWithElements(*type_tuple, new_elements);
+    }
+
+    throw Exception(ErrorCodes::LOGICAL_ERROR, "Type {} unexpectedly has dynamic columns", type_in_storage->getName());
+}
+
+bool hasDynamicSubcolumns(const ColumnsDescription & columns)
+{
+    return std::any_of(columns.begin(), columns.end(),
+        [](const auto & column)
+        {
+            return column.type->hasDynamicSubcolumns();
+        });
 }
 
 void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescription & object_columns, bool with_subcolumns)
@@ -320,16 +510,20 @@ void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescript
     columns_list.splice(columns_list.end(), std::move(subcolumns_list));
 }
 
-void updateObjectColumns(ColumnsDescription & object_columns, const NamesAndTypesList & new_columns)
+void updateObjectColumns(
+    ColumnsDescription & object_columns,
+    const ColumnsDescription & storage_columns,
+    const NamesAndTypesList & new_columns)
 {
     for (const auto & new_column : new_columns)
     {
         auto object_column = object_columns.tryGetColumn(GetColumnsOptions::All, new_column.name);
         if (object_column && !object_column->type->equals(*new_column.type))
         {
+            auto storage_column = storage_columns.getColumn(GetColumnsOptions::All, new_column.name);
             object_columns.modify(new_column.name, [&](auto & column)
             {
-                column.type = getLeastCommonTypeForObject({object_column->type, new_column.type});
+                column.type = getLeastCommonTypeForDynamicColumns(storage_column.type, {object_column->type, new_column.type});
             });
         }
     }
@@ -745,13 +939,6 @@ void replaceMissedSubcolumnsByConstants(
             addConstantToWithClause(query, name, type);
 }
 
-void finalizeObjectColumns(const MutableColumns & columns)
-{
-    for (const auto & column : columns)
-        if (auto * column_object = typeid_cast<ColumnObject *>(column.get()))
-            column_object->finalize();
-}
-
 Field FieldVisitorReplaceScalars::operator()(const Array & x) const
 {
     if (num_dimensions_to_keep == 0)
@@ -768,11 +955,13 @@ size_t FieldVisitorToNumberOfDimensions::operator()(const Array & x)
 {
     const size_t size = x.size();
     size_t dimensions = 0;
+
     for (size_t i = 0; i < size; ++i)
     {
         size_t element_dimensions = applyVisitor(*this, x[i]);
         if (i > 0 && element_dimensions != dimensions)
             need_fold_dimension = true;
+
         dimensions = std::max(dimensions, element_dimensions);
     }
 
@@ -783,12 +972,13 @@ Field FieldVisitorFoldDimension::operator()(const Array & x) const
 {
     if (num_dimensions_to_fold == 0)
         return x;
+
     const size_t size = x.size();
     Array res(size);
     for (size_t i = 0; i < size; ++i)
-    {
         res[i] = applyVisitor(FieldVisitorFoldDimension(num_dimensions_to_fold - 1), x[i]);
-    }
+
     return res;
 }
+
 }
diff --git a/src/DataTypes/ObjectUtils.h b/src/DataTypes/ObjectUtils.h
index c60d5bec208c..bd15edfe8513 100644
--- a/src/DataTypes/ObjectUtils.h
+++ b/src/DataTypes/ObjectUtils.h
@@ -39,27 +39,31 @@ Array createEmptyArrayField(size_t num_dimensions);
 DataTypePtr getDataTypeByColumn(const IColumn & column);
 
 /// Converts Object types and columns to Tuples in @columns_list and @block
-/// and checks that types are consistent with types in @extended_storage_columns.
-void convertObjectsToTuples(Block & block, const NamesAndTypesList & extended_storage_columns);
-void deduceTypesOfObjectColumns(const StorageSnapshotPtr & storage_snapshot, Block & block);
+/// and checks that types are consistent with types in @storage_snapshot.
+void convertDynamicColumnsToTuples(Block & block, const StorageSnapshotPtr & storage_snapshot);
 
 /// Checks that each path is not the prefix of any other path.
 void checkObjectHasNoAmbiguosPaths(const PathsInData & paths);
 
 /// Receives several Tuple types and deduces the least common type among them.
-DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambiguos_paths = false);
+DataTypePtr getLeastCommonTypeForDynamicColumns(
+    const DataTypePtr & type_in_storage, const DataTypes & types, bool check_ambiguos_paths = false);
+
+DataTypePtr createConcreteEmptyDynamicColumn(const DataTypePtr & type_in_storage);
 
 /// Converts types of object columns to tuples in @columns_list
 /// according to @object_columns and adds all tuple's subcolumns if needed.
 void extendObjectColumns(NamesAndTypesList & columns_list, const ColumnsDescription & object_columns, bool with_subcolumns);
 
-NameSet getNamesOfObjectColumns(const NamesAndTypesList & columns_list);
-bool hasObjectColumns(const ColumnsDescription & columns);
-void finalizeObjectColumns(const MutableColumns & columns);
+/// Checks whether @columns contain any column with dynamic subcolumns.
+bool hasDynamicSubcolumns(const ColumnsDescription & columns);
 
 /// Updates types of objects in @object_columns inplace
 /// according to types in new_columns.
-void updateObjectColumns(ColumnsDescription & object_columns, const NamesAndTypesList & new_columns);
+void updateObjectColumns(
+    ColumnsDescription & object_columns,
+    const ColumnsDescription & storage_columns,
+    const NamesAndTypesList & new_columns);
 
 using DataTypeTuplePtr = std::shared_ptr<DataTypeTuple>;
 
@@ -142,13 +146,15 @@ class FieldVisitorFoldDimension : public StaticVisitor<Field>
     {
         if (num_dimensions_to_fold == 0)
             return x;
-        Array res(1,x);
+
+        Array res(1, x);
         for (size_t i = 1; i < num_dimensions_to_fold; ++i)
         {
             Array new_res;
             new_res.push_back(std::move(res));
             res = std::move(new_res);
         }
+
         return res;
     }
 
@@ -163,7 +169,7 @@ class FieldVisitorFoldDimension : public StaticVisitor<Field>
 /// columns-like objects from entry to which Iterator points.
 /// columns-like object should have fields "name" and "type".
 template <typename Iterator, typename EntryColumnsGetter>
-ColumnsDescription getObjectColumns(
+ColumnsDescription getConcreteObjectColumns(
     Iterator begin, Iterator end,
     const ColumnsDescription & storage_columns,
     EntryColumnsGetter && entry_columns_getter)
@@ -176,14 +182,8 @@ ColumnsDescription getObjectColumns(
     /// dummy column will be removed.
     for (const auto & column : storage_columns)
     {
-        if (isObject(column.type))
-        {
-            auto tuple_type = std::make_shared<DataTypeTuple>(
-                DataTypes{std::make_shared<DataTypeUInt8>()},
-                Names{ColumnObject::COLUMN_NAME_DUMMY});
-
-            types_in_entries[column.name].push_back(std::move(tuple_type));
-        }
+        if (column.type->hasDynamicSubcolumns())
+            types_in_entries[column.name].push_back(createConcreteEmptyDynamicColumn(column.type));
     }
 
     for (auto it = begin; it != end; ++it)
@@ -192,14 +192,17 @@ ColumnsDescription getObjectColumns(
         for (const auto & column : entry_columns)
         {
             auto storage_column = storage_columns.tryGetPhysical(column.name);
-            if (storage_column && isObject(storage_column->type))
+            if (storage_column && storage_column->type->hasDynamicSubcolumns())
                 types_in_entries[column.name].push_back(column.type);
         }
     }
 
     ColumnsDescription res;
     for (const auto & [name, types] : types_in_entries)
-        res.add({name, getLeastCommonTypeForObject(types)});
+    {
+        auto storage_column = storage_columns.getPhysical(name);
+        res.add({name, getLeastCommonTypeForDynamicColumns(storage_column.type, types)});
+    }
 
     return res;
 }
diff --git a/src/DataTypes/Serializations/ISerialization.h b/src/DataTypes/Serializations/ISerialization.h
index 1193c15b9394..d64b41253f5e 100644
--- a/src/DataTypes/Serializations/ISerialization.h
+++ b/src/DataTypes/Serializations/ISerialization.h
@@ -249,7 +249,9 @@ class ISerialization : private boost::noncopyable, public std::enable_shared_fro
     };
 
     /// Call before serializeBinaryBulkWithMultipleStreams chain to write something before first mark.
+    /// Column may be used only to retrieve the structure.
     virtual void serializeBinaryBulkStatePrefix(
+        const IColumn & /*column*/,
         SerializeBinaryBulkSettings & /*settings*/,
         SerializeBinaryBulkStatePtr & /*state*/) const {}
 
diff --git a/src/DataTypes/Serializations/SerializationArray.cpp b/src/DataTypes/Serializations/SerializationArray.cpp
index eb93b5049a01..143a32643817 100644
--- a/src/DataTypes/Serializations/SerializationArray.cpp
+++ b/src/DataTypes/Serializations/SerializationArray.cpp
@@ -246,11 +246,13 @@ void SerializationArray::enumerateStreams(
 }
 
 void SerializationArray::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
     settings.path.push_back(Substream::ArrayElements);
-    nested->serializeBinaryBulkStatePrefix(settings, state);
+    const auto & column_array = assert_cast<const ColumnArray &>(column);
+    nested->serializeBinaryBulkStatePrefix(column_array.getData(), settings, state);
     settings.path.pop_back();
 }
 
diff --git a/src/DataTypes/Serializations/SerializationArray.h b/src/DataTypes/Serializations/SerializationArray.h
index 84e37acbaad8..860461d667f3 100644
--- a/src/DataTypes/Serializations/SerializationArray.h
+++ b/src/DataTypes/Serializations/SerializationArray.h
@@ -41,6 +41,7 @@ class SerializationArray final : public SimpleTextSerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+            const IColumn & column,
             SerializeBinaryBulkSettings & settings,
             SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationLowCardinality.cpp b/src/DataTypes/Serializations/SerializationLowCardinality.cpp
index 761adf3b765d..c70bb1e14652 100644
--- a/src/DataTypes/Serializations/SerializationLowCardinality.cpp
+++ b/src/DataTypes/Serializations/SerializationLowCardinality.cpp
@@ -221,6 +221,7 @@ struct DeserializeStateLowCardinality : public ISerialization::DeserializeBinary
 };
 
 void SerializationLowCardinality::serializeBinaryBulkStatePrefix(
+    const IColumn & /*column*/,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
diff --git a/src/DataTypes/Serializations/SerializationLowCardinality.h b/src/DataTypes/Serializations/SerializationLowCardinality.h
index cc090f2044e9..1d0c3226faf6 100644
--- a/src/DataTypes/Serializations/SerializationLowCardinality.h
+++ b/src/DataTypes/Serializations/SerializationLowCardinality.h
@@ -23,6 +23,7 @@ class SerializationLowCardinality : public ISerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+            const IColumn & column,
             SerializeBinaryBulkSettings & settings,
             SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationMap.cpp b/src/DataTypes/Serializations/SerializationMap.cpp
index 958e33fbaf48..cd0a99c0c68c 100644
--- a/src/DataTypes/Serializations/SerializationMap.cpp
+++ b/src/DataTypes/Serializations/SerializationMap.cpp
@@ -270,10 +270,11 @@ void SerializationMap::enumerateStreams(
 }
 
 void SerializationMap::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
-    nested->serializeBinaryBulkStatePrefix(settings, state);
+    nested->serializeBinaryBulkStatePrefix(extractNestedColumn(column), settings, state);
 }
 
 void SerializationMap::serializeBinaryBulkStateSuffix(
diff --git a/src/DataTypes/Serializations/SerializationMap.h b/src/DataTypes/Serializations/SerializationMap.h
index 42f99ca7991e..864ac1f3a99e 100644
--- a/src/DataTypes/Serializations/SerializationMap.h
+++ b/src/DataTypes/Serializations/SerializationMap.h
@@ -37,6 +37,7 @@ class SerializationMap final : public SimpleTextSerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+        const IColumn & column,
         SerializeBinaryBulkSettings & settings,
         SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationNamed.cpp b/src/DataTypes/Serializations/SerializationNamed.cpp
index 4dac4b3a922b..ca60948ce687 100644
--- a/src/DataTypes/Serializations/SerializationNamed.cpp
+++ b/src/DataTypes/Serializations/SerializationNamed.cpp
@@ -17,11 +17,12 @@ void SerializationNamed::enumerateStreams(
 }
 
 void SerializationNamed::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
     addToPath(settings.path);
-    nested_serialization->serializeBinaryBulkStatePrefix(settings, state);
+    nested_serialization->serializeBinaryBulkStatePrefix(column, settings, state);
     settings.path.pop_back();
 }
 
diff --git a/src/DataTypes/Serializations/SerializationNamed.h b/src/DataTypes/Serializations/SerializationNamed.h
index 2a2c7c0dfc71..52bbb0394421 100644
--- a/src/DataTypes/Serializations/SerializationNamed.h
+++ b/src/DataTypes/Serializations/SerializationNamed.h
@@ -31,6 +31,7 @@ class SerializationNamed final : public SerializationWrapper
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+        const IColumn & column,
         SerializeBinaryBulkSettings & settings,
         SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationNullable.cpp b/src/DataTypes/Serializations/SerializationNullable.cpp
index 560b73bc8278..c46fde27ddbb 100644
--- a/src/DataTypes/Serializations/SerializationNullable.cpp
+++ b/src/DataTypes/Serializations/SerializationNullable.cpp
@@ -70,11 +70,13 @@ void SerializationNullable::enumerateStreams(
 }
 
 void SerializationNullable::serializeBinaryBulkStatePrefix(
+        const IColumn & column,
         SerializeBinaryBulkSettings & settings,
         SerializeBinaryBulkStatePtr & state) const
 {
     settings.path.push_back(Substream::NullableElements);
-    nested->serializeBinaryBulkStatePrefix(settings, state);
+    const auto & column_nullable = assert_cast<const ColumnNullable &>(column);
+    nested->serializeBinaryBulkStatePrefix(column_nullable.getNestedColumn(), settings, state);
     settings.path.pop_back();
 }
 
diff --git a/src/DataTypes/Serializations/SerializationNullable.h b/src/DataTypes/Serializations/SerializationNullable.h
index ea3958065e7f..9aabbe299cc6 100644
--- a/src/DataTypes/Serializations/SerializationNullable.h
+++ b/src/DataTypes/Serializations/SerializationNullable.h
@@ -19,6 +19,7 @@ class SerializationNullable : public ISerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+            const IColumn & column,
             SerializeBinaryBulkSettings & settings,
             SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp
index b893407e7a53..98a94886f67d 100644
--- a/src/DataTypes/Serializations/SerializationObject.cpp
+++ b/src/DataTypes/Serializations/SerializationObject.cpp
@@ -13,8 +13,6 @@
 #include <Columns/ColumnString.h>
 #include <Functions/FunctionsConversion.h>
 
-#include <Common/FieldVisitorToString.h>
-
 #include <IO/ReadHelpers.h>
 #include <IO/WriteHelpers.h>
 #include <IO/VarInt.h>
@@ -30,6 +28,7 @@ namespace ErrorCodes
     extern const int NOT_IMPLEMENTED;
     extern const int INCORRECT_DATA;
     extern const int CANNOT_READ_ALL_DATA;
+    extern const int ARGUMENT_OUT_OF_BOUND;
     extern const int LOGICAL_ERROR;
 }
 
@@ -141,7 +140,6 @@ void SerializationObject<Parser>::checkSerializationIsSupported(const TSettings
 template <typename Parser>
 struct SerializationObject<Parser>::SerializeStateObject : public ISerialization::SerializeBinaryBulkState
 {
-    bool is_first = true;
     DataTypePtr nested_type;
     SerializationPtr nested_serialization;
     SerializeBinaryBulkStatePtr nested_state;
@@ -158,6 +156,7 @@ struct SerializationObject<Parser>::DeserializeStateObject : public ISerializati
 
 template <typename Parser>
 void SerializationObject<Parser>::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
@@ -166,15 +165,34 @@ void SerializationObject<Parser>::serializeBinaryBulkStatePrefix(
         throw Exception(ErrorCodes::NOT_IMPLEMENTED,
             "DataTypeObject doesn't support serialization with non-trivial state");
 
+    const auto & column_object = assert_cast<const ColumnObject &>(column);
+    if (!column_object.isFinalized())
+    {
+        auto finalized = column_object.cloneFinalized();
+        serializeBinaryBulkStatePrefix(*finalized, settings, state);
+        return;
+    }
+
     settings.path.push_back(Substream::ObjectStructure);
     auto * stream = settings.getter(settings.path);
-    settings.path.pop_back();
 
     if (!stream)
         throw Exception(ErrorCodes::LOGICAL_ERROR, "Missing stream for kind of binary serialization");
 
+    auto [tuple_column, tuple_type] = unflattenObjectToTuple(column_object);
+
     writeIntBinary(static_cast<UInt8>(BinarySerializationKind::TUPLE), *stream);
-    state = std::make_shared<SerializeStateObject>();
+    writeStringBinary(tuple_type->getName(), *stream);
+
+    auto state_object = std::make_shared<SerializeStateObject>();
+    state_object->nested_type = tuple_type;
+    state_object->nested_serialization = tuple_type->getDefaultSerialization();
+
+    settings.path.back() = Substream::ObjectData;
+    state_object->nested_serialization->serializeBinaryBulkStatePrefix(*tuple_column, settings, state_object->nested_state);
+
+    state = std::move(state_object);
+    settings.path.pop_back();
 }
 
 template <typename Parser>
@@ -261,33 +279,14 @@ void SerializationObject<Parser>::serializeBinaryBulkWithMultipleStreams(
 
     if (!column_object.isFinalized())
     {
-        auto finalized_object = column_object.clone();
-        assert_cast<ColumnObject &>(*finalized_object).finalize();
-        serializeBinaryBulkWithMultipleStreams(*finalized_object, offset, limit, settings, state);
+        auto finalized = column_object.cloneFinalized();
+        serializeBinaryBulkWithMultipleStreams(*finalized, offset, limit, settings, state);
         return;
     }
 
     auto [tuple_column, tuple_type] = unflattenObjectToTuple(column_object);
 
-    if (state_object->is_first)
-    {
-        /// Actually it's a part of serializeBinaryBulkStatePrefix,
-        /// but it cannot be done there, because we have to know the
-        /// structure of column.
-
-        settings.path.push_back(Substream::ObjectStructure);
-        if (auto * stream = settings.getter(settings.path))
-            writeStringBinary(tuple_type->getName(), *stream);
-
-        state_object->nested_type = tuple_type;
-        state_object->nested_serialization = tuple_type->getDefaultSerialization();
-        state_object->is_first = false;
-
-        settings.path.back() = Substream::ObjectData;
-        state_object->nested_serialization->serializeBinaryBulkStatePrefix(settings, state_object->nested_state);
-        settings.path.pop_back();
-    }
-    else if (!state_object->nested_type->equals(*tuple_type))
+    if (!state_object->nested_type->equals(*tuple_type))
     {
         throw Exception(ErrorCodes::LOGICAL_ERROR,
             "Types of internal column of Object mismatched. Expected: {}, Got: {}",
@@ -411,18 +410,63 @@ void SerializationObject<Parser>::serializeTextImpl(const IColumn & column, size
     writeChar('{', ostr);
     for (auto it = subcolumns.begin(); it != subcolumns.end(); ++it)
     {
+        const auto & entry = *it;
         if (it != subcolumns.begin())
             writeCString(",", ostr);
 
-        writeDoubleQuoted((*it)->path.getPath(), ostr);
+        writeDoubleQuoted(entry->path.getPath(), ostr);
         writeChar(':', ostr);
-
-        auto serialization = (*it)->data.getLeastCommonType()->getDefaultSerialization();
-        serialization->serializeTextJSON((*it)->data.getFinalizedColumn(), row_num, ostr, settings);
+        serializeTextFromSubcolumn(entry->data, row_num, ostr, settings);
     }
     writeChar('}', ostr);
 }
 
+template <typename Parser>
+void SerializationObject<Parser>::serializeTextFromSubcolumn(
+    const ColumnObject::Subcolumn & subcolumn, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
+{
+    const auto & least_common_type = subcolumn.getLeastCommonType();
+
+    if (subcolumn.isFinalized())
+    {
+        const auto & finalized_column = subcolumn.getFinalizedColumn();
+        auto info = least_common_type->getSerializationInfo(finalized_column);
+        auto serialization = least_common_type->getSerialization(*info);
+        serialization->serializeTextJSON(finalized_column, row_num, ostr, settings);
+        return;
+    }
+
+    size_t ind = row_num;
+    if (ind < subcolumn.getNumberOfDefaultsInPrefix())
+    {
+        /// Suboptimal, but it should happen rarely.
+        auto tmp_column = subcolumn.getLeastCommonType()->createColumn();
+        tmp_column->insertDefault();
+
+        auto info = least_common_type->getSerializationInfo(*tmp_column);
+        auto serialization = least_common_type->getSerialization(*info);
+        serialization->serializeTextJSON(*tmp_column, 0, ostr, settings);
+        return;
+    }
+
+    ind -= subcolumn.getNumberOfDefaultsInPrefix();
+    for (const auto & part : subcolumn.getData())
+    {
+        if (ind < part->size())
+        {
+            auto part_type = getDataTypeByColumn(*part);
+            auto info = part_type->getSerializationInfo(*part);
+            auto serialization = part_type->getSerialization(*info);
+            serialization->serializeTextJSON(*part, ind, ostr, settings);
+            return;
+        }
+
+        ind -= part->size();
+    }
+
+    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND, "Index ({}) for text serialization is out of range", row_num);
+}
+
 template <typename Parser>
 void SerializationObject<Parser>::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const
 {
diff --git a/src/DataTypes/Serializations/SerializationObject.h b/src/DataTypes/Serializations/SerializationObject.h
index ff72c84faaa4..47a7127cd1c6 100644
--- a/src/DataTypes/Serializations/SerializationObject.h
+++ b/src/DataTypes/Serializations/SerializationObject.h
@@ -8,7 +8,7 @@ namespace DB
 {
 
 /** Serialization for data type Object.
-  * Supported only test serialization/deserialization.
+  * Supported only text serialization/deserialization.
   * and binary bulk serialization/deserialization without position independent
   * encoding, i.e. serialization/deserialization into Native format.
   */
@@ -31,6 +31,7 @@ class SerializationObject : public ISerialization
       */
 
     void serializeBinaryBulkStatePrefix(
+        const IColumn & column,
         SerializeBinaryBulkSettings & settings,
         SerializeBinaryBulkStatePtr & state) const override;
 
@@ -104,6 +105,7 @@ class SerializationObject : public ISerialization
     void deserializeTextImpl(IColumn & column, Reader && reader) const;
 
     void serializeTextImpl(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const;
+    void serializeTextFromSubcolumn(const ColumnObject::Subcolumn & subcolumn, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const;
 
     /// Pool of parser objects to make SerializationObject thread safe.
     mutable SimpleObjectPool<Parser> parsers_pool;
diff --git a/src/DataTypes/Serializations/SerializationSparse.cpp b/src/DataTypes/Serializations/SerializationSparse.cpp
index 855bdfa1b3e6..cd09cd7be5a1 100644
--- a/src/DataTypes/Serializations/SerializationSparse.cpp
+++ b/src/DataTypes/Serializations/SerializationSparse.cpp
@@ -178,11 +178,16 @@ void SerializationSparse::enumerateStreams(
 }
 
 void SerializationSparse::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
     settings.path.push_back(Substream::SparseElements);
-    nested->serializeBinaryBulkStatePrefix(settings, state);
+    if (const auto * column_sparse = typeid_cast<const ColumnSparse *>(&column))
+        nested->serializeBinaryBulkStatePrefix(column_sparse->getValuesColumn(), settings, state);
+    else
+        nested->serializeBinaryBulkStatePrefix(column, settings, state);
+
     settings.path.pop_back();
 }
 
diff --git a/src/DataTypes/Serializations/SerializationSparse.h b/src/DataTypes/Serializations/SerializationSparse.h
index dc2f63c5a054..c157fe7ce98d 100644
--- a/src/DataTypes/Serializations/SerializationSparse.h
+++ b/src/DataTypes/Serializations/SerializationSparse.h
@@ -33,6 +33,7 @@ class SerializationSparse final : public ISerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+        const IColumn & column,
         SerializeBinaryBulkSettings & settings,
         SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationTuple.cpp b/src/DataTypes/Serializations/SerializationTuple.cpp
index c2c40cbb5078..8ffb1fe86bcf 100644
--- a/src/DataTypes/Serializations/SerializationTuple.cpp
+++ b/src/DataTypes/Serializations/SerializationTuple.cpp
@@ -314,6 +314,7 @@ struct DeserializeBinaryBulkStateTuple : public ISerialization::DeserializeBinar
 
 
 void SerializationTuple::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
@@ -321,7 +322,7 @@ void SerializationTuple::serializeBinaryBulkStatePrefix(
     tuple_state->states.resize(elems.size());
 
     for (size_t i = 0; i < elems.size(); ++i)
-        elems[i]->serializeBinaryBulkStatePrefix(settings, tuple_state->states[i]);
+        elems[i]->serializeBinaryBulkStatePrefix(extractElementColumn(column, i), settings, tuple_state->states[i]);
 
     state = std::move(tuple_state);
 }
diff --git a/src/DataTypes/Serializations/SerializationTuple.h b/src/DataTypes/Serializations/SerializationTuple.h
index d1caeb73dadb..db0339bc996d 100644
--- a/src/DataTypes/Serializations/SerializationTuple.h
+++ b/src/DataTypes/Serializations/SerializationTuple.h
@@ -39,6 +39,7 @@ class SerializationTuple final : public SimpleTextSerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+            const IColumn & column,
             SerializeBinaryBulkSettings & settings,
             SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/DataTypes/Serializations/SerializationWrapper.cpp b/src/DataTypes/Serializations/SerializationWrapper.cpp
index 7c50c1c6e26f..c83de6147518 100644
--- a/src/DataTypes/Serializations/SerializationWrapper.cpp
+++ b/src/DataTypes/Serializations/SerializationWrapper.cpp
@@ -13,10 +13,11 @@ void SerializationWrapper::enumerateStreams(
 }
 
 void SerializationWrapper::serializeBinaryBulkStatePrefix(
+    const IColumn & column,
     SerializeBinaryBulkSettings & settings,
     SerializeBinaryBulkStatePtr & state) const
 {
-    nested_serialization->serializeBinaryBulkStatePrefix(settings, state);
+    nested_serialization->serializeBinaryBulkStatePrefix(column, settings, state);
 }
 
 void SerializationWrapper::serializeBinaryBulkStateSuffix(
diff --git a/src/DataTypes/Serializations/SerializationWrapper.h b/src/DataTypes/Serializations/SerializationWrapper.h
index d010c6b53149..46941f150e12 100644
--- a/src/DataTypes/Serializations/SerializationWrapper.h
+++ b/src/DataTypes/Serializations/SerializationWrapper.h
@@ -26,6 +26,7 @@ class SerializationWrapper : public ISerialization
         const SubstreamData & data) const override;
 
     void serializeBinaryBulkStatePrefix(
+        const IColumn & column,
         SerializeBinaryBulkSettings & settings,
         SerializeBinaryBulkStatePtr & state) const override;
 
diff --git a/src/Formats/NativeWriter.cpp b/src/Formats/NativeWriter.cpp
index 0cae2a2e7891..c4dea371afd1 100644
--- a/src/Formats/NativeWriter.cpp
+++ b/src/Formats/NativeWriter.cpp
@@ -58,7 +58,7 @@ static void writeData(const ISerialization & serialization, const ColumnPtr & co
     settings.low_cardinality_max_dictionary_size = 0; //-V1048
 
     ISerialization::SerializeBinaryBulkStatePtr state;
-    serialization.serializeBinaryBulkStatePrefix(settings, state);
+    serialization.serializeBinaryBulkStatePrefix(*full_column, settings, state);
     serialization.serializeBinaryBulkWithMultipleStreams(*full_column, offset, limit, settings, state);
     serialization.serializeBinaryBulkStateSuffix(settings, state);
 }
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index 3a69ba43642d..dd494d821bfa 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -3360,9 +3360,8 @@ class FunctionCast final : public FunctionCastBase
         {
             return [] (ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * nullable_source, size_t input_rows_count)
             {
-                auto res = ConvertImplGenericFromString<ColumnString>::execute(arguments, result_type, nullable_source, input_rows_count);
-                auto & res_object = assert_cast<ColumnObject &>(res->assumeMutableRef());
-                res_object.finalize();
+                auto res = ConvertImplGenericFromString<ColumnString>::execute(arguments, result_type, nullable_source, input_rows_count)->assumeMutable();
+                res->finalize();
                 return res;
             };
         }
diff --git a/src/Functions/blockSerializedSize.cpp b/src/Functions/blockSerializedSize.cpp
index d406984c51c2..35be65f3fed8 100644
--- a/src/Functions/blockSerializedSize.cpp
+++ b/src/Functions/blockSerializedSize.cpp
@@ -54,7 +54,7 @@ class FunctionBlockSerializedSize : public IFunction
 
         auto serialization = elem.type->getDefaultSerialization();
 
-        serialization->serializeBinaryBulkStatePrefix(settings, state);
+        serialization->serializeBinaryBulkStatePrefix(*full_column, settings, state);
         serialization->serializeBinaryBulkWithMultipleStreams(*full_column,
             0 /** offset */, 0 /** limit */,
             settings, state);
diff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp
index f41ae31b2396..4a6ce63eb84f 100644
--- a/src/Interpreters/InterpreterCreateQuery.cpp
+++ b/src/Interpreters/InterpreterCreateQuery.cpp
@@ -829,7 +829,7 @@ void InterpreterCreateQuery::validateTableStructure(const ASTCreateQuery & creat
     {
         for (const auto & [name, type] : properties.columns.getAllPhysical())
         {
-            if (isObject(type))
+            if (type->hasDynamicSubcolumns())
             {
                 throw Exception(ErrorCodes::ILLEGAL_COLUMN,
                     "Cannot create table with column '{}' which type is '{}' "
@@ -1398,7 +1398,7 @@ bool InterpreterCreateQuery::doCreateTable(ASTCreateQuery & create,
     /// we can safely destroy the object without a call to "shutdown", because there is guarantee
     /// that no background threads/similar resources remain after exception from "startup".
 
-    if (!res->supportsDynamicSubcolumns() && hasObjectColumns(res->getInMemoryMetadataPtr()->getColumns()))
+    if (!res->supportsDynamicSubcolumns() && hasDynamicSubcolumns(res->getInMemoryMetadataPtr()->getColumns()))
     {
         throw Exception(ErrorCodes::ILLEGAL_COLUMN,
             "Cannot create table with column of type Object, "
diff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp
index 524e5d364033..e57016d969a0 100644
--- a/src/Interpreters/convertFieldToType.cpp
+++ b/src/Interpreters/convertFieldToType.cpp
@@ -387,6 +387,9 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID
     }
     else if (isObject(type))
     {
+        if (src.getType() == Field::Types::Object)
+            return src;  /// Already in needed type.
+
         const auto * from_type_tuple = typeid_cast<const DataTypeTuple *>(from_type_hint);
         if (src.getType() == Field::Types::Tuple && from_type_tuple && from_type_tuple->haveExplicitNames())
         {
diff --git a/src/Processors/Formats/IRowInputFormat.cpp b/src/Processors/Formats/IRowInputFormat.cpp
index abd91ddcf35d..6f153019df5a 100644
--- a/src/Processors/Formats/IRowInputFormat.cpp
+++ b/src/Processors/Formats/IRowInputFormat.cpp
@@ -232,7 +232,9 @@ Chunk IRowInputFormat::generate()
         return {};
     }
 
-    finalizeObjectColumns(columns);
+    for (const auto & column : columns)
+        column->finalize();
+
     Chunk chunk(std::move(columns), num_rows);
     return chunk;
 }
diff --git a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
index 72e89ea00138..108b4203e3ed 100644
--- a/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
+++ b/src/Processors/Formats/Impl/ValuesBlockInputFormat.cpp
@@ -101,7 +101,9 @@ Chunk ValuesBlockInputFormat::generate()
         return {};
     }
 
-    finalizeObjectColumns(columns);
+    for (const auto & column : columns)
+        column->finalize();
+
     size_t rows_in_block = columns[0]->size();
     return Chunk{std::move(columns), rows_in_block};
 }
diff --git a/src/Storages/MergeTree/MergeTask.cpp b/src/Storages/MergeTree/MergeTask.cpp
index 98f05ade18d8..0b6fe23e9616 100644
--- a/src/Storages/MergeTree/MergeTask.cpp
+++ b/src/Storages/MergeTree/MergeTask.cpp
@@ -153,7 +153,7 @@ bool MergeTask::ExecuteAndFinalizeHorizontalPart::prepare()
     global_ctx->all_column_names = global_ctx->metadata_snapshot->getColumns().getNamesOfPhysical();
     global_ctx->storage_columns = global_ctx->metadata_snapshot->getColumns().getAllPhysical();
 
-    auto object_columns = MergeTreeData::getObjectColumns(global_ctx->future_part->parts, global_ctx->metadata_snapshot->getColumns());
+    auto object_columns = MergeTreeData::getConcreteObjectColumns(global_ctx->future_part->parts, global_ctx->metadata_snapshot->getColumns());
     global_ctx->storage_snapshot = std::make_shared<StorageSnapshot>(*global_ctx->data, global_ctx->metadata_snapshot, object_columns);
     extendObjectColumns(global_ctx->storage_columns, object_columns, false);
 
diff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp
index a9e726f25fdb..83e87a0e462d 100644
--- a/src/Storages/MergeTree/MergeTreeData.cpp
+++ b/src/Storages/MergeTree/MergeTreeData.cpp
@@ -7124,18 +7124,18 @@ ReservationPtr MergeTreeData::balancedReservation(
     return reserved_space;
 }
 
-ColumnsDescription MergeTreeData::getObjectColumns(
+ColumnsDescription MergeTreeData::getConcreteObjectColumns(
     const DataPartsVector & parts, const ColumnsDescription & storage_columns)
 {
-    return DB::getObjectColumns(
+    return DB::getConcreteObjectColumns(
         parts.begin(), parts.end(),
         storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });
 }
 
-ColumnsDescription MergeTreeData::getObjectColumns(
+ColumnsDescription MergeTreeData::getConcreteObjectColumns(
     boost::iterator_range<DataPartIteratorByStateAndInfo> range, const ColumnsDescription & storage_columns)
 {
-    return DB::getObjectColumns(
+    return DB::getConcreteObjectColumns(
         range.begin(), range.end(),
         storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });
 }
@@ -7144,21 +7144,21 @@ void MergeTreeData::resetObjectColumnsFromActiveParts(const DataPartsLock & /*lo
 {
     auto metadata_snapshot = getInMemoryMetadataPtr();
     const auto & columns = metadata_snapshot->getColumns();
-    if (!hasObjectColumns(columns))
+    if (!hasDynamicSubcolumns(columns))
         return;
 
     auto range = getDataPartsStateRange(DataPartState::Active);
-    object_columns = getObjectColumns(range, columns);
+    object_columns = getConcreteObjectColumns(range, columns);
 }
 
 void MergeTreeData::updateObjectColumns(const DataPartPtr & part, const DataPartsLock & /*lock*/)
 {
     auto metadata_snapshot = getInMemoryMetadataPtr();
     const auto & columns = metadata_snapshot->getColumns();
-    if (!hasObjectColumns(columns))
+    if (!hasDynamicSubcolumns(columns))
         return;
 
-    DB::updateObjectColumns(object_columns, part->getColumns());
+    DB::updateObjectColumns(object_columns, columns, part->getColumns());
 }
 
 StorageSnapshotPtr MergeTreeData::getStorageSnapshot(const StorageMetadataPtr & metadata_snapshot, ContextPtr query_context) const
diff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h
index 99ba6991e430..8bd0fc1f2807 100644
--- a/src/Storages/MergeTree/MergeTreeData.h
+++ b/src/Storages/MergeTree/MergeTreeData.h
@@ -779,10 +779,10 @@ class MergeTreeData : public IStorage, public WithMutableContext
         return column_sizes;
     }
 
-    const ColumnsDescription & getObjectColumns() const { return object_columns; }
+    const ColumnsDescription & getConcreteObjectColumns() const { return object_columns; }
 
     /// Creates description of columns of data type Object from the range of data parts.
-    static ColumnsDescription getObjectColumns(
+    static ColumnsDescription getConcreteObjectColumns(
         const DataPartsVector & parts, const ColumnsDescription & storage_columns);
 
     IndexSizeByName getSecondaryIndexSizes() const override
@@ -1151,7 +1151,7 @@ class MergeTreeData : public IStorage, public WithMutableContext
     }
 
     /// Creates description of columns of data type Object from the range of data parts.
-    static ColumnsDescription getObjectColumns(
+    static ColumnsDescription getConcreteObjectColumns(
         boost::iterator_range<DataPartIteratorByStateAndInfo> range, const ColumnsDescription & storage_columns);
 
     std::optional<UInt64> totalRowsByPartitionPredicateImpl(
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp
index c9f3c3b5101f..020121e59d79 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterCompact.cpp
@@ -131,7 +131,7 @@ void writeColumnSingleGranule(
     serialize_settings.position_independent_encoding = true; //-V1048
     serialize_settings.low_cardinality_max_dictionary_size = 0; //-V1048
 
-    serialization->serializeBinaryBulkStatePrefix(serialize_settings, state);
+    serialization->serializeBinaryBulkStatePrefix(*column.column, serialize_settings, state);
     serialization->serializeBinaryBulkWithMultipleStreams(*column.column, from_row, number_of_rows, serialize_settings, state);
     serialization->serializeBinaryBulkStateSuffix(serialize_settings, state);
 }
diff --git a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
index f48b350a981b..62917bcb084c 100644
--- a/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataPartWriterWide.cpp
@@ -355,7 +355,7 @@ void MergeTreeDataPartWriterWide::writeColumn(
     {
         ISerialization::SerializeBinaryBulkSettings serialize_settings;
         serialize_settings.getter = createStreamGetter(name_and_type, offset_columns);
-        serialization->serializeBinaryBulkStatePrefix(serialize_settings, it->second);
+        serialization->serializeBinaryBulkStatePrefix(column, serialize_settings, it->second);
     }
 
     const auto & global_settings = storage.getContext()->getSettingsRef();
diff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
index 55404324b751..b8f9b6cced4e 100644
--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
@@ -288,7 +288,7 @@ MergeTreeDataWriter::TemporaryPart MergeTreeDataWriter::writeTempPart(
     auto columns = metadata_snapshot->getColumns().getAllPhysical().filter(block.getNames());
 
     for (auto & column : columns)
-        if (isObject(column.type))
+        if (column.type->hasDynamicSubcolumns())
             column.type = block.getByName(column.name).type;
 
     static const String TMP_PREFIX = "tmp_insert_";
diff --git a/src/Storages/MergeTree/MergeTreeIndexSet.cpp b/src/Storages/MergeTree/MergeTreeIndexSet.cpp
index 3c31deda8234..0e15f2c4cb62 100644
--- a/src/Storages/MergeTree/MergeTreeIndexSet.cpp
+++ b/src/Storages/MergeTree/MergeTreeIndexSet.cpp
@@ -74,8 +74,9 @@ void MergeTreeIndexGranuleSet::serializeBinary(WriteBuffer & ostr) const
         auto serialization = type->getDefaultSerialization();
         ISerialization::SerializeBinaryBulkStatePtr state;
 
-        serialization->serializeBinaryBulkStatePrefix(settings, state);
-        serialization->serializeBinaryBulkWithMultipleStreams(*block.getByPosition(i).column, 0, size(), settings, state);
+        const auto & column = *block.getByPosition(i).column;
+        serialization->serializeBinaryBulkStatePrefix(column, settings, state);
+        serialization->serializeBinaryBulkWithMultipleStreams(column, 0, size(), settings, state);
         serialization->serializeBinaryBulkStateSuffix(settings, state);
     }
 }
diff --git a/src/Storages/MergeTree/MergeTreeSink.cpp b/src/Storages/MergeTree/MergeTreeSink.cpp
index a7ddb9d9e1d6..13a72c24c594 100644
--- a/src/Storages/MergeTree/MergeTreeSink.cpp
+++ b/src/Storages/MergeTree/MergeTreeSink.cpp
@@ -1,8 +1,8 @@
 #include <Storages/MergeTree/MergeTreeSink.h>
 #include <Storages/MergeTree/MergeTreeDataPartInMemory.h>
 #include <Storages/StorageMergeTree.h>
-#include <DataTypes/ObjectUtils.h>
 #include <Interpreters/PartLog.h>
+#include <DataTypes/ObjectUtils.h>
 
 namespace ProfileEvents
 {
@@ -56,8 +56,9 @@ struct MergeTreeSink::DelayedChunk
 void MergeTreeSink::consume(Chunk chunk)
 {
     auto block = getHeader().cloneWithColumns(chunk.detachColumns());
+    if (!storage_snapshot->object_columns.empty())
+        convertDynamicColumnsToTuples(block, storage_snapshot);
 
-    deduceTypesOfObjectColumns(storage_snapshot, block);
     auto part_blocks = storage.writer.splitBlockIntoParts(block, max_parts_per_block, metadata_snapshot, context);
 
     using DelayedPartitions = std::vector<MergeTreeSink::DelayedChunk::Partition>;
diff --git a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp
index 082228d7ebf9..dbc2bd98e203 100644
--- a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp
+++ b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp
@@ -1,10 +1,10 @@
 #include <Storages/StorageReplicatedMergeTree.h>
 #include <Storages/MergeTree/ReplicatedMergeTreeQuorumEntry.h>
 #include <Storages/MergeTree/ReplicatedMergeTreeSink.h>
-#include <DataTypes/ObjectUtils.h>
 #include <Interpreters/PartLog.h>
 #include <Common/SipHash.h>
 #include <Common/ZooKeeper/KeeperException.h>
+#include <DataTypes/ObjectUtils.h>
 #include <Core/Block.h>
 #include <IO/Operators.h>
 
@@ -165,7 +165,9 @@ void ReplicatedMergeTreeSink::consume(Chunk chunk)
       */
     size_t replicas_num = checkQuorumPrecondition(zookeeper);
 
-    deduceTypesOfObjectColumns(storage_snapshot, block);
+    if (!storage_snapshot->object_columns.empty())
+        convertDynamicColumnsToTuples(block, storage_snapshot);
+
     auto part_blocks = storage.writer.splitBlockIntoParts(block, max_parts_per_block, metadata_snapshot, context);
 
     using DelayedPartitions = std::vector<ReplicatedMergeTreeSink::DelayedChunk::Partition>;
diff --git a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h
index a3d578cf5f2d..7bad9947a886 100644
--- a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h
+++ b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h
@@ -47,10 +47,10 @@ class StorageFromMergeTreeDataPart final : public IStorage
         const StorageMetadataPtr & metadata_snapshot, ContextPtr /*query_context*/) const override
     {
         const auto & storage_columns = metadata_snapshot->getColumns();
-        if (!hasObjectColumns(storage_columns))
+        if (!hasDynamicSubcolumns(storage_columns))
             return std::make_shared<StorageSnapshot>(*this, metadata_snapshot);
 
-        auto object_columns = getObjectColumns(
+        auto object_columns = getConcreteObjectColumns(
             parts.begin(), parts.end(),
             storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });
 
diff --git a/src/Storages/StorageDistributed.cpp b/src/Storages/StorageDistributed.cpp
index 8e4715db483d..f7f68eba30fb 100644
--- a/src/Storages/StorageDistributed.cpp
+++ b/src/Storages/StorageDistributed.cpp
@@ -598,7 +598,7 @@ std::optional<QueryProcessingStage::Enum> StorageDistributed::getOptimizedQueryP
 
 static bool requiresObjectColumns(const ColumnsDescription & all_columns, ASTPtr query)
 {
-    if (!hasObjectColumns(all_columns))
+    if (!hasDynamicSubcolumns(all_columns))
         return false;
 
     if (!query)
@@ -613,7 +613,7 @@ static bool requiresObjectColumns(const ColumnsDescription & all_columns, ASTPtr
         auto name_in_storage = Nested::splitName(required_column).first;
         auto column_in_storage = all_columns.tryGetPhysical(name_in_storage);
 
-        if (column_in_storage && isObject(column_in_storage->type))
+        if (column_in_storage && column_in_storage->type->hasDynamicSubcolumns())
             return true;
     }
 
@@ -640,7 +640,7 @@ StorageSnapshotPtr StorageDistributed::getStorageSnapshotForQuery(
         metadata_snapshot->getColumns(),
         getContext());
 
-    auto object_columns = DB::getObjectColumns(
+    auto object_columns = DB::getConcreteObjectColumns(
         snapshot_data->objects_by_shard.begin(),
         snapshot_data->objects_by_shard.end(),
         metadata_snapshot->getColumns(),
diff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp
index 66dcc938aefe..a80f21834db2 100644
--- a/src/Storages/StorageInMemoryMetadata.cpp
+++ b/src/Storages/StorageInMemoryMetadata.cpp
@@ -526,7 +526,7 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns)
 
         const auto * available_type = it->getMapped();
 
-        if (!isObject(*available_type)
+        if (!available_type->hasDynamicSubcolumns()
             && !column.type->equals(*available_type)
             && !isCompatibleEnumTypes(available_type, column.type.get()))
             throw Exception(
@@ -575,7 +575,7 @@ void StorageInMemoryMetadata::check(const NamesAndTypesList & provided_columns,
         const auto * provided_column_type = it->getMapped();
         const auto * available_column_type = jt->getMapped();
 
-        if (!isObject(*provided_column_type)
+        if (!provided_column_type->hasDynamicSubcolumns()
             && !provided_column_type->equals(*available_column_type)
             && !isCompatibleEnumTypes(available_column_type, provided_column_type))
             throw Exception(
@@ -619,7 +619,7 @@ void StorageInMemoryMetadata::check(const Block & block, bool need_all) const
                 listOfColumns(available_columns));
 
         const auto * available_type = it->getMapped();
-        if (!isObject(*available_type)
+        if (!available_type->hasDynamicSubcolumns()
             && !column.type->equals(*available_type)
             && !isCompatibleEnumTypes(available_type, column.type.get()))
             throw Exception(
diff --git a/src/Storages/StorageLog.cpp b/src/Storages/StorageLog.cpp
index 9909489d901a..8ed33220507c 100644
--- a/src/Storages/StorageLog.cpp
+++ b/src/Storages/StorageLog.cpp
@@ -462,7 +462,7 @@ void LogSink::writeData(const NameAndTypePair & name_and_type, const IColumn & c
     settings.getter = createStreamGetter(name_and_type);
 
     if (!serialize_states.contains(name))
-         serialization->serializeBinaryBulkStatePrefix(settings, serialize_states[name]);
+         serialization->serializeBinaryBulkStatePrefix(column, settings, serialize_states[name]);
 
     if (storage.use_marks_file)
     {
diff --git a/src/Storages/StorageMemory.cpp b/src/Storages/StorageMemory.cpp
index 957aae450c8b..881cbc18b10f 100644
--- a/src/Storages/StorageMemory.cpp
+++ b/src/Storages/StorageMemory.cpp
@@ -146,7 +146,7 @@ class MemorySink : public SinkToStorage
             auto extended_storage_columns = storage_snapshot->getColumns(
                 GetColumnsOptions(GetColumnsOptions::AllPhysical).withExtendedObjects());
 
-            convertObjectsToTuples(block, extended_storage_columns);
+            convertDynamicColumnsToTuples(block, storage_snapshot);
         }
 
         if (storage.compress)
@@ -212,10 +212,10 @@ StorageSnapshotPtr StorageMemory::getStorageSnapshot(const StorageMetadataPtr &
     auto snapshot_data = std::make_unique<SnapshotData>();
     snapshot_data->blocks = data.get();
 
-    if (!hasObjectColumns(metadata_snapshot->getColumns()))
+    if (!hasDynamicSubcolumns(metadata_snapshot->getColumns()))
         return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, ColumnsDescription{}, std::move(snapshot_data));
 
-    auto object_columns = getObjectColumns(
+    auto object_columns = getConcreteObjectColumns(
         snapshot_data->blocks->begin(),
         snapshot_data->blocks->end(),
         metadata_snapshot->getColumns(),
diff --git a/src/Storages/StorageSnapshot.cpp b/src/Storages/StorageSnapshot.cpp
index a99fec8c154a..48851f0974dc 100644
--- a/src/Storages/StorageSnapshot.cpp
+++ b/src/Storages/StorageSnapshot.cpp
@@ -76,7 +76,7 @@ std::optional<NameAndTypePair> StorageSnapshot::tryGetColumn(const GetColumnsOpt
 {
     const auto & columns = getMetadataForQuery()->getColumns();
     auto column = columns.tryGetColumn(options, column_name);
-    if (column && (!isObject(column->type) || !options.with_extended_objects))
+    if (column && (!column->type->hasDynamicSubcolumns() || !options.with_extended_objects))
         return column;
 
     if (options.with_extended_objects)
diff --git a/src/Storages/getStructureOfRemoteTable.cpp b/src/Storages/getStructureOfRemoteTable.cpp
index a93a480adb0d..7bd5e629c399 100644
--- a/src/Storages/getStructureOfRemoteTable.cpp
+++ b/src/Storages/getStructureOfRemoteTable.cpp
@@ -200,7 +200,7 @@ ColumnsDescriptionByShardNum getExtendedObjectsOfRemoteTables(
                 auto type_name = type_col[i].get<const String &>();
 
                 auto storage_column = storage_columns.tryGetPhysical(name);
-                if (storage_column && isObject(storage_column->type))
+                if (storage_column && storage_column->type->hasDynamicSubcolumns())
                     res.add(ColumnDescription(std::move(name), DataTypeFactory::instance().get(type_name)));
             }
         }
