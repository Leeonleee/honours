{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25734,
  "instance_id": "ClickHouse__ClickHouse-25734",
  "issue_numbers": [
    "25612"
  ],
  "base_commit": "6bd9b82141c98dcd7796fd9d08326831095ba519",
  "patch": "diff --git a/src/Interpreters/ArrayJoinedColumnsVisitor.h b/src/Interpreters/ArrayJoinedColumnsVisitor.h\nindex 94f6bdaf138e..b64a170cb004 100644\n--- a/src/Interpreters/ArrayJoinedColumnsVisitor.h\n+++ b/src/Interpreters/ArrayJoinedColumnsVisitor.h\n@@ -60,7 +60,7 @@ class ArrayJoinedColumnsMatcher\n private:\n     static void visit(const ASTSelectQuery & node, ASTPtr &, Data & data)\n     {\n-        ASTPtr array_join_expression_list = node.arrayJoinExpressionList();\n+        auto [array_join_expression_list, _] = node.arrayJoinExpressionList();\n         if (!array_join_expression_list)\n             throw Exception(\"Logical error: no ARRAY JOIN\", ErrorCodes::LOGICAL_ERROR);\n \ndiff --git a/src/Interpreters/ExpressionActions.cpp b/src/Interpreters/ExpressionActions.cpp\nindex f3c51487a051..96da6e548020 100644\n--- a/src/Interpreters/ExpressionActions.cpp\n+++ b/src/Interpreters/ExpressionActions.cpp\n@@ -1042,7 +1042,7 @@ ExpressionActionsChain::JoinStep::JoinStep(\n         required_columns.emplace_back(column.name, column.type);\n \n     NamesAndTypesList result_names_and_types = required_columns;\n-    analyzed_join->addJoinedColumnsAndCorrectTypes(result_names_and_types);\n+    analyzed_join->addJoinedColumnsAndCorrectTypes(result_names_and_types, true);\n     for (const auto & [name, type] : result_names_and_types)\n         /// `column` is `nullptr` because we don't care on constness here, it may be changed in join\n         result_columns.emplace_back(nullptr, type, name);\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex dbb1addf2022..d5739b51659d 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -43,7 +43,6 @@\n #include <Common/StringUtils/StringUtils.h>\n \n #include <DataTypes/DataTypeFactory.h>\n-#include <Parsers/parseQuery.h>\n \n #include <Interpreters/ActionsVisitor.h>\n #include <Interpreters/GetAggregatesVisitor.h>\n@@ -152,6 +151,9 @@ ExpressionAnalyzer::ExpressionAnalyzer(\n     /// Replaces global subqueries with the generated names of temporary tables that will be sent to remote servers.\n     initGlobalSubqueriesAndExternalTables(do_global);\n \n+    auto temp_actions = std::make_shared<ActionsDAG>(sourceColumns());\n+    columns_after_array_join = getColumnsAfterArrayJoin(temp_actions, sourceColumns());\n+    columns_after_join = analyzeJoin(temp_actions, columns_after_array_join);\n     /// has_aggregation, aggregation_keys, aggregate_descriptions, aggregated_columns.\n     /// This analysis should be performed after processing global subqueries, because otherwise,\n     /// if the aggregate function contains a global subquery, then `analyzeAggregation` method will save\n@@ -159,7 +161,7 @@ ExpressionAnalyzer::ExpressionAnalyzer(\n     /// global subquery. Then, when you call `initGlobalSubqueriesAndExternalTables` method, this\n     /// the global subquery will be replaced with a temporary table, resulting in aggregate_descriptions\n     /// will contain out-of-date information, which will lead to an error when the query is executed.\n-    analyzeAggregation();\n+    analyzeAggregation(temp_actions);\n }\n \n static ASTPtr checkPositionalArgument(ASTPtr argument, const ASTSelectQuery * select_query, ASTSelectQuery::Expression expression)\n@@ -193,157 +195,158 @@ static ASTPtr checkPositionalArgument(ASTPtr argument, const ASTSelectQuery * se\n     return nullptr;\n }\n \n-void ExpressionAnalyzer::analyzeAggregation()\n+NamesAndTypesList ExpressionAnalyzer::getColumnsAfterArrayJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns)\n {\n-    /** Find aggregation keys (aggregation_keys), information about aggregate functions (aggregate_descriptions),\n-     *  as well as a set of columns obtained after the aggregation, if any,\n-     *  or after all the actions that are usually performed before aggregation (aggregated_columns).\n-     *\n-     * Everything below (compiling temporary ExpressionActions) - only for the purpose of query analysis (type output).\n-     */\n+    const auto * select_query = query->as<ASTSelectQuery>();\n+    if (!select_query)\n+        return {};\n \n-    auto * select_query = query->as<ASTSelectQuery>();\n+    auto [array_join_expression_list, is_array_join_left] = select_query->arrayJoinExpressionList();\n \n-    auto temp_actions = std::make_shared<ActionsDAG>(sourceColumns());\n+    if (!array_join_expression_list)\n+        return src_columns;\n \n-    if (select_query)\n-    {\n-        NamesAndTypesList array_join_columns;\n-        columns_after_array_join = sourceColumns();\n+    getRootActionsNoMakeSet(array_join_expression_list, true, actions, false);\n+\n+    auto array_join = addMultipleArrayJoinAction(actions, is_array_join_left);\n+    auto sample_columns = actions->getResultColumns();\n+    array_join->prepare(sample_columns);\n+    actions = std::make_shared<ActionsDAG>(sample_columns);\n \n-        bool is_array_join_left;\n-        if (ASTPtr array_join_expression_list = select_query->arrayJoinExpressionList(is_array_join_left))\n+    NamesAndTypesList new_columns_after_array_join;\n+    NameSet added_columns;\n+\n+    for (auto & column : actions->getResultColumns())\n+    {\n+        if (syntax->array_join_result_to_source.count(column.name))\n         {\n-            getRootActionsNoMakeSet(array_join_expression_list, true, temp_actions, false);\n+            new_columns_after_array_join.emplace_back(column.name, column.type);\n+            added_columns.emplace(column.name);\n+        }\n+    }\n \n-            auto array_join = addMultipleArrayJoinAction(temp_actions, is_array_join_left);\n-            auto sample_columns = temp_actions->getResultColumns();\n-            array_join->prepare(sample_columns);\n-            temp_actions = std::make_shared<ActionsDAG>(sample_columns);\n+    for (const auto & column : src_columns)\n+        if (added_columns.count(column.name) == 0)\n+            new_columns_after_array_join.emplace_back(column.name, column.type);\n \n-            NamesAndTypesList new_columns_after_array_join;\n-            NameSet added_columns;\n+    return new_columns_after_array_join;\n+}\n \n-            for (auto & column : temp_actions->getResultColumns())\n-            {\n-                if (syntax->array_join_result_to_source.count(column.name))\n-                {\n-                    new_columns_after_array_join.emplace_back(column.name, column.type);\n-                    added_columns.emplace(column.name);\n-                }\n-            }\n+NamesAndTypesList ExpressionAnalyzer::analyzeJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns)\n+{\n+    const auto * select_query = query->as<ASTSelectQuery>();\n+    if (!select_query)\n+        return {};\n \n-            for (auto & column : columns_after_array_join)\n-                if (added_columns.count(column.name) == 0)\n-                    new_columns_after_array_join.emplace_back(column.name, column.type);\n+    const ASTTablesInSelectQueryElement * join = select_query->join();\n+    if (join)\n+    {\n+        getRootActionsNoMakeSet(analyzedJoin().leftKeysList(), true, actions, false);\n+        auto sample_columns = actions->getNamesAndTypesList();\n+        syntax->analyzed_join->addJoinedColumnsAndCorrectTypes(sample_columns, true);\n+        actions = std::make_shared<ActionsDAG>(sample_columns);\n+    }\n \n-            columns_after_array_join.swap(new_columns_after_array_join);\n-        }\n+    NamesAndTypesList result_columns = src_columns;\n+    syntax->analyzed_join->addJoinedColumnsAndCorrectTypes(result_columns,false);\n+    return result_columns;\n+}\n \n-        columns_after_array_join.insert(columns_after_array_join.end(), array_join_columns.begin(), array_join_columns.end());\n+void ExpressionAnalyzer::analyzeAggregation(ActionsDAGPtr & temp_actions)\n+{\n+    /** Find aggregation keys (aggregation_keys), information about aggregate functions (aggregate_descriptions),\n+     *  as well as a set of columns obtained after the aggregation, if any,\n+     *  or after all the actions that are usually performed before aggregation (aggregated_columns).\n+     *\n+     * Everything below (compiling temporary ExpressionActions) - only for the purpose of query analysis (type output).\n+     */\n \n-        const ASTTablesInSelectQueryElement * join = select_query->join();\n-        if (join)\n-        {\n-            getRootActionsNoMakeSet(analyzedJoin().leftKeysList(), true, temp_actions, false);\n-            auto sample_columns = temp_actions->getNamesAndTypesList();\n-            analyzedJoin().addJoinedColumnsAndCorrectTypes(sample_columns);\n-            temp_actions = std::make_shared<ActionsDAG>(sample_columns);\n-        }\n+    auto * select_query = query->as<ASTSelectQuery>();\n \n-        columns_after_join = columns_after_array_join;\n-        analyzedJoin().addJoinedColumnsAndCorrectTypes(columns_after_join, false);\n-    }\n+    makeAggregateDescriptions(temp_actions, aggregate_descriptions);\n+    has_aggregation = !aggregate_descriptions.empty() || (select_query && (select_query->groupBy() || select_query->having()));\n \n-    has_aggregation = makeAggregateDescriptions(temp_actions);\n-    if (select_query && (select_query->groupBy() || select_query->having()))\n-        has_aggregation = true;\n+    if (!has_aggregation)\n+    {\n+        aggregated_columns = temp_actions->getNamesAndTypesList();\n+        return;\n+    }\n \n-    if (has_aggregation)\n+    /// Find out aggregation keys.\n+    if (select_query)\n     {\n-        /// Find out aggregation keys.\n-        if (select_query)\n+        if (ASTPtr group_by_ast = select_query->groupBy())\n         {\n-            if (select_query->groupBy())\n+            NameSet unique_keys;\n+            ASTs & group_asts = group_by_ast->children;\n+            for (ssize_t i = 0; i < ssize_t(group_asts.size()); ++i)\n             {\n-                NameSet unique_keys;\n-                ASTs & group_asts = select_query->groupBy()->children;\n+                ssize_t size = group_asts.size();\n+                getRootActionsNoMakeSet(group_asts[i], true, temp_actions, false);\n \n-                for (ssize_t i = 0; i < ssize_t(group_asts.size()); ++i)\n+                if (getContext()->getSettingsRef().enable_positional_arguments)\n                 {\n-                    ssize_t size = group_asts.size();\n-                    getRootActionsNoMakeSet(group_asts[i], true, temp_actions, false);\n-\n-                    if (getContext()->getSettingsRef().enable_positional_arguments)\n-                    {\n-                        auto new_argument = checkPositionalArgument(group_asts[i], select_query, ASTSelectQuery::Expression::GROUP_BY);\n-                        if (new_argument)\n-                            group_asts[i] = new_argument;\n-                    }\n-\n-                    const auto & column_name = group_asts[i]->getColumnName();\n-                    const auto * node = temp_actions->tryFindInIndex(column_name);\n+                    auto new_argument = checkPositionalArgument(group_asts[i], select_query, ASTSelectQuery::Expression::GROUP_BY);\n+                    if (new_argument)\n+                        group_asts[i] = new_argument;\n+                }\n \n-                    if (!node)\n-                        throw Exception(\"Unknown identifier (in GROUP BY): \" + column_name, ErrorCodes::UNKNOWN_IDENTIFIER);\n+                const auto & column_name = group_asts[i]->getColumnName();\n+                const auto * node = temp_actions->tryFindInIndex(column_name);\n+                if (!node)\n+                    throw Exception(\"Unknown identifier (in GROUP BY): \" + column_name, ErrorCodes::UNKNOWN_IDENTIFIER);\n \n-                    /// Only removes constant keys if it's an initiator or distributed_group_by_no_merge is enabled.\n-                    if (getContext()->getClientInfo().distributed_depth == 0 || settings.distributed_group_by_no_merge > 0)\n+                /// Only removes constant keys if it's an initiator or distributed_group_by_no_merge is enabled.\n+                if (getContext()->getClientInfo().distributed_depth == 0 || settings.distributed_group_by_no_merge > 0)\n+                {\n+                    /// Constant expressions have non-null column pointer at this stage.\n+                    if (node->column && isColumnConst(*node->column))\n                     {\n-                        /// Constant expressions have non-null column pointer at this stage.\n-                        if (node->column && isColumnConst(*node->column))\n-                        {\n-                            select_query->group_by_with_constant_keys = true;\n+                        select_query->group_by_with_constant_keys = true;\n \n-                            /// But don't remove last key column if no aggregate functions, otherwise aggregation will not work.\n-                            if (!aggregate_descriptions.empty() || size > 1)\n-                            {\n-                                if (i + 1 < static_cast<ssize_t>(size))\n-                                    group_asts[i] = std::move(group_asts.back());\n+                        /// But don't remove last key column if no aggregate functions, otherwise aggregation will not work.\n+                        if (!aggregate_descriptions.empty() || size > 1)\n+                        {\n+                            if (i + 1 < static_cast<ssize_t>(size))\n+                                group_asts[i] = std::move(group_asts.back());\n \n-                                group_asts.pop_back();\n+                            group_asts.pop_back();\n \n-                                --i;\n-                                continue;\n-                            }\n+                            --i;\n+                            continue;\n                         }\n                     }\n+                }\n \n-                    NameAndTypePair key{column_name, node->result_type};\n+                NameAndTypePair key{column_name, node->result_type};\n \n-                    /// Aggregation keys are uniqued.\n-                    if (!unique_keys.count(key.name))\n-                    {\n-                        unique_keys.insert(key.name);\n-                        aggregation_keys.push_back(key);\n+                /// Aggregation keys are uniqued.\n+                if (!unique_keys.count(key.name))\n+                {\n+                    unique_keys.insert(key.name);\n+                    aggregation_keys.push_back(key);\n \n-                        /// Key is no longer needed, therefore we can save a little by moving it.\n-                        aggregated_columns.push_back(std::move(key));\n-                    }\n+                    /// Key is no longer needed, therefore we can save a little by moving it.\n+                    aggregated_columns.push_back(std::move(key));\n                 }\n+            }\n \n-                if (group_asts.empty())\n-                {\n-                    select_query->setExpression(ASTSelectQuery::Expression::GROUP_BY, {});\n-                    has_aggregation = select_query->having() || !aggregate_descriptions.empty();\n-                }\n+            if (group_asts.empty())\n+            {\n+                select_query->setExpression(ASTSelectQuery::Expression::GROUP_BY, {});\n+                has_aggregation = select_query->having() || !aggregate_descriptions.empty();\n             }\n         }\n-        else\n-            aggregated_columns = temp_actions->getNamesAndTypesList();\n \n         /// Constant expressions are already removed during first 'analyze' run.\n         /// So for second `analyze` information is taken from select_query.\n-        if (select_query)\n-            has_const_aggregation_keys = select_query->group_by_with_constant_keys;\n-\n-        for (const auto & desc : aggregate_descriptions)\n-            aggregated_columns.emplace_back(desc.column_name, desc.function->getReturnType());\n+        has_const_aggregation_keys = select_query->group_by_with_constant_keys;\n     }\n     else\n-    {\n         aggregated_columns = temp_actions->getNamesAndTypesList();\n-    }\n+\n+    for (const auto & desc : aggregate_descriptions)\n+        aggregated_columns.emplace_back(desc.column_name, desc.function->getReturnType());\n }\n \n \n@@ -487,7 +490,7 @@ void ExpressionAnalyzer::getRootActionsForHaving(const ASTPtr & ast, bool no_sub\n }\n \n \n-bool ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions)\n+void ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions, AggregateDescriptions & descriptions)\n {\n     for (const ASTFunction * node : aggregates())\n     {\n@@ -520,10 +523,8 @@ bool ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions)\n         aggregate.parameters = (node->parameters) ? getAggregateFunctionParametersArray(node->parameters, \"\", getContext()) : Array();\n         aggregate.function = AggregateFunctionFactory::instance().get(node->name, types, aggregate.parameters, properties);\n \n-        aggregate_descriptions.push_back(aggregate);\n+        descriptions.push_back(aggregate);\n     }\n-\n-    return !aggregates().empty();\n }\n \n void makeWindowDescriptionFromAST(const Context & context,\n@@ -804,8 +805,7 @@ ArrayJoinActionPtr SelectQueryExpressionAnalyzer::appendArrayJoin(ExpressionActi\n {\n     const auto * select_query = getSelectQuery();\n \n-    bool is_array_join_left;\n-    ASTPtr array_join_expression_list = select_query->arrayJoinExpressionList(is_array_join_left);\n+    auto [array_join_expression_list, is_array_join_left] = select_query->arrayJoinExpressionList();\n     if (!array_join_expression_list)\n         return nullptr;\n \n@@ -832,14 +832,14 @@ bool SelectQueryExpressionAnalyzer::appendJoinLeftKeys(ExpressionActionsChain &\n     return true;\n }\n \n-JoinPtr SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain)\n+JoinPtr SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain, ActionsDAGPtr & converting_join_columns)\n {\n     const ColumnsWithTypeAndName & left_sample_columns = chain.getLastStep().getResultColumns();\n-    JoinPtr table_join = makeTableJoin(*syntax->ast_join, left_sample_columns);\n+    JoinPtr table_join = makeTableJoin(*syntax->ast_join, left_sample_columns, converting_join_columns);\n \n-    if (syntax->analyzed_join->needConvert())\n+    if (converting_join_columns)\n     {\n-        chain.steps.push_back(std::make_unique<ExpressionActionsChain::ExpressionActionsStep>(syntax->analyzed_join->leftConvertingActions()));\n+        chain.steps.push_back(std::make_unique<ExpressionActionsChain::ExpressionActionsStep>(converting_join_columns));\n         chain.addStep();\n     }\n \n@@ -850,14 +850,6 @@ JoinPtr SelectQueryExpressionAnalyzer::appendJoin(ExpressionActionsChain & chain\n     return table_join;\n }\n \n-static JoinPtr tryGetStorageJoin(std::shared_ptr<TableJoin> analyzed_join)\n-{\n-    if (auto * table = analyzed_join->joined_storage.get())\n-        if (auto * storage_join = dynamic_cast<StorageJoin *>(table))\n-            return storage_join->getJoinLocked(analyzed_join);\n-    return {};\n-}\n-\n static ActionsDAGPtr createJoinedBlockActions(ContextPtr context, const TableJoin & analyzed_join)\n {\n     ASTPtr expression_list = analyzed_join.rightKeysList();\n@@ -865,124 +857,105 @@ static ActionsDAGPtr createJoinedBlockActions(ContextPtr context, const TableJoi\n     return ExpressionAnalyzer(expression_list, syntax_result, context).getActionsDAG(true, false);\n }\n \n-static bool allowDictJoin(StoragePtr joined_storage, ContextPtr context, String & dict_name, String & key_name)\n+static std::shared_ptr<IJoin> chooseJoinAlgorithm(std::shared_ptr<TableJoin> analyzed_join, const Block & sample_block, ContextPtr context)\n {\n-    if (!joined_storage->isDictionary())\n-        return false;\n-\n-    StorageDictionary & storage_dictionary = static_cast<StorageDictionary &>(*joined_storage);\n-    dict_name = storage_dictionary.getDictionaryName();\n-    auto dictionary = context->getExternalDictionariesLoader().getDictionary(dict_name, context);\n-    if (!dictionary)\n-        return false;\n+    /// HashJoin with Dictionary optimisation\n+    if (analyzed_join->tryInitDictJoin(sample_block, context))\n+        return std::make_shared<HashJoin>(analyzed_join, sample_block);\n \n-    const DictionaryStructure & structure = dictionary->getStructure();\n-    if (structure.id)\n-    {\n-        key_name = structure.id->name;\n-        return true;\n-    }\n-    return false;\n+    bool allow_merge_join = analyzed_join->allowMergeJoin();\n+    if (analyzed_join->forceHashJoin() || (analyzed_join->preferMergeJoin() && !allow_merge_join))\n+        return std::make_shared<HashJoin>(analyzed_join, sample_block);\n+    else if (analyzed_join->forceMergeJoin() || (analyzed_join->preferMergeJoin() && allow_merge_join))\n+        return std::make_shared<MergeJoin>(analyzed_join, sample_block);\n+    return std::make_shared<JoinSwitcher>(analyzed_join, sample_block);\n }\n \n-static std::shared_ptr<IJoin> makeJoin(std::shared_ptr<TableJoin> analyzed_join, const Block & sample_block, ContextPtr context)\n+static std::unique_ptr<QueryPlan> buildJoinedPlan(\n+    ContextPtr context,\n+    const ASTTablesInSelectQueryElement & join_element,\n+    TableJoin & analyzed_join,\n+    SelectQueryOptions query_options)\n {\n-    bool allow_merge_join = analyzed_join->allowMergeJoin();\n-\n-    /// HashJoin with Dictionary optimisation\n-    String dict_name;\n-    String key_name;\n-    if (analyzed_join->joined_storage && allowDictJoin(analyzed_join->joined_storage, context, dict_name, key_name))\n+    /// Actions which need to be calculated on joined block.\n+    auto joined_block_actions = createJoinedBlockActions(context, analyzed_join);\n+    Names original_right_columns;\n+\n+    NamesWithAliases required_columns_with_aliases = analyzed_join.getRequiredColumns(\n+        Block(joined_block_actions->getResultColumns()), joined_block_actions->getRequiredColumns().getNames());\n+    for (auto & pr : required_columns_with_aliases)\n+        original_right_columns.push_back(pr.first);\n+\n+    /** For GLOBAL JOINs (in the case, for example, of the push method for executing GLOBAL subqueries), the following occurs\n+        * - in the addExternalStorage function, the JOIN (SELECT ...) subquery is replaced with JOIN _data1,\n+        *   in the subquery_for_set object this subquery is exposed as source and the temporary table _data1 as the `table`.\n+        * - this function shows the expression JOIN _data1.\n+        */\n+    auto interpreter = interpretSubquery(\n+        join_element.table_expression, context, original_right_columns, query_options.copy().setWithAllColumns());\n+    auto joined_plan = std::make_unique<QueryPlan>();\n+    interpreter->buildQueryPlan(*joined_plan);\n     {\n-        Names original_names;\n-        NamesAndTypesList result_columns;\n-        if (analyzed_join->allowDictJoin(key_name, sample_block, original_names, result_columns))\n+        auto sample_block = interpreter->getSampleBlock();\n+        auto rename_dag = std::make_unique<ActionsDAG>(sample_block.getColumnsWithTypeAndName());\n+        for (const auto & name_with_alias : required_columns_with_aliases)\n         {\n-            analyzed_join->dictionary_reader = std::make_shared<DictionaryReader>(dict_name, original_names, result_columns, context);\n-            return std::make_shared<HashJoin>(analyzed_join, sample_block);\n+            if (sample_block.has(name_with_alias.first))\n+            {\n+                auto pos = sample_block.getPositionByName(name_with_alias.first);\n+                const auto & alias = rename_dag->addAlias(*rename_dag->getInputs()[pos], name_with_alias.second);\n+                rename_dag->getIndex()[pos] = &alias;\n+            }\n         }\n+\n+        auto rename_step = std::make_unique<ExpressionStep>(joined_plan->getCurrentDataStream(), std::move(rename_dag));\n+        rename_step->setStepDescription(\"Rename joined columns\");\n+        joined_plan->addStep(std::move(rename_step));\n     }\n \n-    if (analyzed_join->forceHashJoin() || (analyzed_join->preferMergeJoin() && !allow_merge_join))\n-        return std::make_shared<HashJoin>(analyzed_join, sample_block);\n-    else if (analyzed_join->forceMergeJoin() || (analyzed_join->preferMergeJoin() && allow_merge_join))\n-        return std::make_shared<MergeJoin>(analyzed_join, sample_block);\n-    return std::make_shared<JoinSwitcher>(analyzed_join, sample_block);\n+    auto joined_actions_step = std::make_unique<ExpressionStep>(joined_plan->getCurrentDataStream(), std::move(joined_block_actions));\n+    joined_actions_step->setStepDescription(\"Joined actions\");\n+    joined_plan->addStep(std::move(joined_actions_step));\n+\n+    return joined_plan;\n }\n \n JoinPtr SelectQueryExpressionAnalyzer::makeTableJoin(\n-    const ASTTablesInSelectQueryElement & join_element, const ColumnsWithTypeAndName & left_sample_columns)\n+    const ASTTablesInSelectQueryElement & join_element,\n+    const ColumnsWithTypeAndName & left_columns,\n+    ActionsDAGPtr & left_convert_actions)\n {\n     /// Two JOINs are not supported with the same subquery, but different USINGs.\n \n     if (joined_plan)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Table join was already created for query\");\n \n-    /// Use StorageJoin if any.\n-    JoinPtr join = tryGetStorageJoin(syntax->analyzed_join);\n-\n-    if (!join)\n-    {\n-        /// Actions which need to be calculated on joined block.\n-        auto joined_block_actions = createJoinedBlockActions(getContext(), analyzedJoin());\n-\n-        Names original_right_columns;\n-\n-        NamesWithAliases required_columns_with_aliases = analyzedJoin().getRequiredColumns(\n-            Block(joined_block_actions->getResultColumns()), joined_block_actions->getRequiredColumns().getNames());\n-        for (auto & pr : required_columns_with_aliases)\n-            original_right_columns.push_back(pr.first);\n-\n-        /** For GLOBAL JOINs (in the case, for example, of the push method for executing GLOBAL subqueries), the following occurs\n-            * - in the addExternalStorage function, the JOIN (SELECT ...) subquery is replaced with JOIN _data1,\n-            *   in the subquery_for_set object this subquery is exposed as source and the temporary table _data1 as the `table`.\n-            * - this function shows the expression JOIN _data1.\n-            */\n-        auto interpreter = interpretSubquery(\n-            join_element.table_expression, getContext(), original_right_columns, query_options.copy().setWithAllColumns());\n-        {\n-            joined_plan = std::make_unique<QueryPlan>();\n-            interpreter->buildQueryPlan(*joined_plan);\n+    ActionsDAGPtr right_convert_actions = nullptr;\n \n-            auto sample_block = interpreter->getSampleBlock();\n+    const auto & analyzed_join = syntax->analyzed_join;\n \n-            auto rename_dag = std::make_unique<ActionsDAG>(sample_block.getColumnsWithTypeAndName());\n-            for (const auto & name_with_alias : required_columns_with_aliases)\n-            {\n-                if (sample_block.has(name_with_alias.first))\n-                {\n-                    auto pos = sample_block.getPositionByName(name_with_alias.first);\n-                    const auto & alias = rename_dag->addAlias(*rename_dag->getInputs()[pos], name_with_alias.second);\n-                    rename_dag->getIndex()[pos] = &alias;\n-                }\n-            }\n-\n-            auto rename_step = std::make_unique<ExpressionStep>(joined_plan->getCurrentDataStream(), std::move(rename_dag));\n-            rename_step->setStepDescription(\"Rename joined columns\");\n-            joined_plan->addStep(std::move(rename_step));\n-        }\n+    if (auto storage = analyzed_join->getStorageJoin())\n+    {\n+        std::tie(left_convert_actions, right_convert_actions) = analyzed_join->createConvertingActions(left_columns, {});\n+        return storage->getJoinLocked(analyzed_join);\n+    }\n \n-        auto joined_actions_step = std::make_unique<ExpressionStep>(joined_plan->getCurrentDataStream(), std::move(joined_block_actions));\n-        joined_actions_step->setStepDescription(\"Joined actions\");\n-        joined_plan->addStep(std::move(joined_actions_step));\n+    joined_plan = buildJoinedPlan(getContext(), join_element, *analyzed_join, query_options);\n \n-        const ColumnsWithTypeAndName & right_sample_columns = joined_plan->getCurrentDataStream().header.getColumnsWithTypeAndName();\n-        bool need_convert = syntax->analyzed_join->applyJoinKeyConvert(left_sample_columns, right_sample_columns);\n-        if (need_convert)\n-        {\n-            auto converting_step = std::make_unique<ExpressionStep>(joined_plan->getCurrentDataStream(), syntax->analyzed_join->rightConvertingActions());\n-            converting_step->setStepDescription(\"Convert joined columns\");\n-            joined_plan->addStep(std::move(converting_step));\n-        }\n+    const ColumnsWithTypeAndName & right_columns = joined_plan->getCurrentDataStream().header.getColumnsWithTypeAndName();\n+    std::tie(left_convert_actions, right_convert_actions) = analyzed_join->createConvertingActions(left_columns, right_columns);\n+    if (right_convert_actions)\n+    {\n+        auto converting_step = std::make_unique<ExpressionStep>(joined_plan->getCurrentDataStream(), right_convert_actions);\n+        converting_step->setStepDescription(\"Convert joined columns\");\n+        joined_plan->addStep(std::move(converting_step));\n+    }\n \n-        join = makeJoin(syntax->analyzed_join, joined_plan->getCurrentDataStream().header, getContext());\n+    JoinPtr join = chooseJoinAlgorithm(analyzed_join, joined_plan->getCurrentDataStream().header, getContext());\n \n-        /// Do not make subquery for join over dictionary.\n-        if (syntax->analyzed_join->dictionary_reader)\n-            joined_plan.reset();\n-    }\n-    else\n-        syntax->analyzed_join->applyJoinKeyConvert(left_sample_columns, {});\n+    /// Do not make subquery for join over dictionary.\n+    if (analyzed_join->getDictionaryReader())\n+        joined_plan.reset();\n \n     return join;\n }\n@@ -1574,8 +1547,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n         {\n             query_analyzer.appendJoinLeftKeys(chain, only_types || !first_stage);\n             before_join = chain.getLastActions();\n-            join = query_analyzer.appendJoin(chain);\n-            converting_join_columns = query_analyzer.analyzedJoin().leftConvertingActions();\n+            join = query_analyzer.appendJoin(chain, converting_join_columns);\n             chain.addStep();\n         }\n \ndiff --git a/src/Interpreters/ExpressionAnalyzer.h b/src/Interpreters/ExpressionAnalyzer.h\nindex 2d0041bd96be..5e3a7af8e9ee 100644\n--- a/src/Interpreters/ExpressionAnalyzer.h\n+++ b/src/Interpreters/ExpressionAnalyzer.h\n@@ -92,7 +92,7 @@ class ExpressionAnalyzer : protected ExpressionAnalyzerData, private boost::nonc\n         const SizeLimits size_limits_for_set;\n         const UInt64 distributed_group_by_no_merge;\n \n-        ExtractedSettings(const Settings & settings_);\n+        explicit ExtractedSettings(const Settings & settings_);\n     };\n \n public:\n@@ -188,12 +188,15 @@ class ExpressionAnalyzer : protected ExpressionAnalyzerData, private boost::nonc\n       *  or after all the actions that are normally performed before aggregation.\n       * Set has_aggregation = true if there is GROUP BY or at least one aggregate function.\n       */\n-    void analyzeAggregation();\n-    bool makeAggregateDescriptions(ActionsDAGPtr & actions);\n+    void analyzeAggregation(ActionsDAGPtr & temp_actions);\n+    void makeAggregateDescriptions(ActionsDAGPtr & actions, AggregateDescriptions & descriptions);\n \n     const ASTSelectQuery * getSelectQuery() const;\n \n     bool isRemoteStorage() const { return syntax->is_remote_storage; }\n+\n+    NamesAndTypesList getColumnsAfterArrayJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns);\n+    NamesAndTypesList analyzeJoin(ActionsDAGPtr & actions, const NamesAndTypesList & src_columns);\n };\n \n class SelectQueryExpressionAnalyzer;\n@@ -338,7 +341,8 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n \n     JoinPtr makeTableJoin(\n         const ASTTablesInSelectQueryElement & join_element,\n-        const ColumnsWithTypeAndName & left_sample_columns);\n+        const ColumnsWithTypeAndName & left_columns,\n+        ActionsDAGPtr & left_convert_actions);\n \n     const ASTSelectQuery * getAggregatingQuery() const;\n \n@@ -359,7 +363,8 @@ class SelectQueryExpressionAnalyzer : public ExpressionAnalyzer\n     /// Before aggregation:\n     ArrayJoinActionPtr appendArrayJoin(ExpressionActionsChain & chain, ActionsDAGPtr & before_array_join, bool only_types);\n     bool appendJoinLeftKeys(ExpressionActionsChain & chain, bool only_types);\n-    JoinPtr appendJoin(ExpressionActionsChain & chain);\n+    JoinPtr appendJoin(ExpressionActionsChain & chain, ActionsDAGPtr & converting_join_columns);\n+\n     /// remove_filter is set in ExpressionActionsChain::finalize();\n     /// Columns in `additional_required_columns` will not be removed (they can be used for e.g. sampling or FINAL modifier).\n     ActionsDAGPtr appendPrewhere(ExpressionActionsChain & chain, bool only_types, const Names & additional_required_columns);\ndiff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex 46f8c9aac791..1c450d531d6a 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -211,7 +211,7 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n     if (nullable_right_side)\n         JoinCommon::convertColumnsToNullable(sample_block_with_columns_to_add);\n \n-    if (table_join->dictionary_reader)\n+    if (table_join->getDictionaryReader())\n     {\n         LOG_DEBUG(log, \"Performing join over dict\");\n         data->type = Type::DICT;\n@@ -331,7 +331,8 @@ class KeyGetterForDict\n \n     KeyGetterForDict(const TableJoin & table_join, const ColumnRawPtrs & key_columns)\n     {\n-        table_join.dictionary_reader->readKeys(*key_columns[0], read_result, found, positions);\n+        assert(table_join.getDictionaryReader());\n+        table_join.getDictionaryReader()->readKeys(*key_columns[0], read_result, found, positions);\n \n         for (ColumnWithTypeAndName & column : read_result)\n             if (table_join.rightBecomeNullable(column.type))\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 6f64c83f8bf3..5fe9948f857f 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -854,7 +854,7 @@ static std::pair<UInt64, UInt64> getLimitLengthAndOffset(const ASTSelectQuery &\n static UInt64 getLimitForSorting(const ASTSelectQuery & query, ContextPtr context)\n {\n     /// Partial sort can be done if there is LIMIT but no DISTINCT or LIMIT BY, neither ARRAY JOIN.\n-    if (!query.distinct && !query.limitBy() && !query.limit_with_ties && !query.arrayJoinExpressionList() && query.limitLength())\n+    if (!query.distinct && !query.limitBy() && !query.limit_with_ties && !query.arrayJoinExpressionList().first && query.limitLength())\n     {\n         auto [limit_length, limit_offset] = getLimitLengthAndOffset(query, context);\n         if (limit_length > std::numeric_limits<UInt64>::max() - limit_offset)\n@@ -1132,8 +1132,6 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu\n             }\n \n             /// Optional step to convert key columns to common supertype.\n-            /// Columns with changed types will be returned to user,\n-            ///  so its only suitable for `USING` join.\n             if (expressions.converting_join_columns)\n             {\n                 QueryPlanStepPtr convert_join_step = std::make_unique<ExpressionStep>(\n@@ -1354,17 +1352,15 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu\n             bool apply_prelimit = apply_limit &&\n                                   query.limitLength() && !query.limit_with_ties &&\n                                   !hasWithTotalsInAnySubqueryInFromClause(query) &&\n-                                  !query.arrayJoinExpressionList() &&\n+                                  !query.arrayJoinExpressionList().first &&\n                                   !query.distinct &&\n                                   !expressions.hasLimitBy() &&\n                                   !settings.extremes &&\n                                   !has_withfill;\n             bool apply_offset = options.to_stage != QueryProcessingStage::WithMergeableStateAfterAggregationAndLimit;\n-            bool limit_applied = false;\n             if (apply_prelimit)\n             {\n                 executePreLimit(query_plan, /* do_not_skip_offset= */!apply_offset);\n-                limit_applied = true;\n             }\n \n             /** If there was more than one stream,\n@@ -1386,7 +1382,6 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu\n             if (query.limit_with_ties && apply_offset)\n             {\n                 executeLimit(query_plan);\n-                limit_applied = true;\n             }\n \n             /// Projection not be done on the shards, since then initiator will not find column in blocks.\n@@ -1400,6 +1395,7 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, const BlockInpu\n             /// Extremes are calculated before LIMIT, but after LIMIT BY. This is Ok.\n             executeExtremes(query_plan);\n \n+            bool limit_applied = apply_prelimit || (query.limit_with_ties && apply_offset);\n             /// Limit is no longer needed if there is prelimit.\n             ///\n             /// NOTE: that LIMIT cannot be applied if OFFSET should not be applied,\ndiff --git a/src/Interpreters/JoinedTables.cpp b/src/Interpreters/JoinedTables.cpp\nindex 099fb5c2f445..271d73714257 100644\n--- a/src/Interpreters/JoinedTables.cpp\n+++ b/src/Interpreters/JoinedTables.cpp\n@@ -299,16 +299,17 @@ std::shared_ptr<TableJoin> JoinedTables::makeTableJoin(const ASTSelectQuery & se\n     if (table_to_join.database_and_table_name)\n     {\n         auto joined_table_id = context->resolveStorageID(table_to_join.database_and_table_name);\n-        StoragePtr table = DatabaseCatalog::instance().tryGetTable(joined_table_id, context);\n-        if (table)\n+        StoragePtr storage = DatabaseCatalog::instance().tryGetTable(joined_table_id, context);\n+        if (storage)\n         {\n-            if (dynamic_cast<StorageJoin *>(table.get()) ||\n-                dynamic_cast<StorageDictionary *>(table.get()))\n-                table_join->joined_storage = table;\n+            if (auto storage_join = std::dynamic_pointer_cast<StorageJoin>(storage); storage_join)\n+                table_join->setStorageJoin(storage_join);\n+            else if (auto storage_dict = std::dynamic_pointer_cast<StorageDictionary>(storage); storage_dict)\n+                table_join->setStorageJoin(storage_dict);\n         }\n     }\n \n-    if (!table_join->joined_storage &&\n+    if (!table_join->isSpecialStorage() &&\n         settings.enable_optimize_predicate_expression)\n         replaceJoinedTable(select_query);\n \ndiff --git a/src/Interpreters/PredicateExpressionsOptimizer.cpp b/src/Interpreters/PredicateExpressionsOptimizer.cpp\nindex f2e55441fb6a..adc164e05965 100644\n--- a/src/Interpreters/PredicateExpressionsOptimizer.cpp\n+++ b/src/Interpreters/PredicateExpressionsOptimizer.cpp\n@@ -39,7 +39,7 @@ bool PredicateExpressionsOptimizer::optimize(ASTSelectQuery & select_query)\n     if (!select_query.tables() || select_query.tables()->children.empty())\n         return false;\n \n-    if ((!select_query.where() && !select_query.prewhere()) || select_query.arrayJoinExpressionList())\n+    if ((!select_query.where() && !select_query.prewhere()) || select_query.arrayJoinExpressionList().first)\n         return false;\n \n     const auto & tables_predicates = extractTablesPredicates(select_query.where(), select_query.prewhere());\ndiff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp\nindex d15cbe42063d..9194de3073ac 100644\n--- a/src/Interpreters/TableJoin.cpp\n+++ b/src/Interpreters/TableJoin.cpp\n@@ -1,5 +1,6 @@\n #include <Interpreters/TableJoin.h>\n \n+\n #include <Common/StringUtils/StringUtils.h>\n \n #include <Core/Block.h>\n@@ -7,10 +8,20 @@\n #include <Core/Settings.h>\n \n #include <DataTypes/DataTypeNullable.h>\n+\n+#include <Dictionaries/DictionaryStructure.h>\n+\n+#include <Interpreters/DictionaryReader.h>\n+#include <Interpreters/ExternalDictionariesLoader.h>\n+\n #include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTFunction.h>\n #include <Parsers/queryToString.h>\n \n+#include <Storages/IStorage.h>\n+#include <Storages/StorageDictionary.h>\n+#include <Storages/StorageJoin.h>\n+\n #include <common/logger_useful.h>\n \n \n@@ -20,6 +31,24 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int TYPE_MISMATCH;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+namespace\n+{\n+\n+std::string formatTypeMap(const TableJoin::NameToTypeMap & target, const TableJoin::NameToTypeMap & source)\n+{\n+    std::vector<std::string> text;\n+    for (const auto & [k, v] : target)\n+    {\n+        auto src_type_it = source.find(k);\n+        std::string src_type_name = src_type_it != source.end() ? src_type_it->second->getName() : \"\";\n+        text.push_back(fmt::format(\"{} : {} -> {}\", k, src_type_name, v->getName()));\n+    }\n+    return fmt::format(\"{}\", fmt::join(text, \", \"));\n+}\n+\n }\n \n TableJoin::TableJoin(const Settings & settings, VolumePtr tmp_volume_)\n@@ -49,8 +78,6 @@ void TableJoin::resetCollected()\n     renames.clear();\n     left_type_map.clear();\n     right_type_map.clear();\n-    left_converting_actions = nullptr;\n-    right_converting_actions = nullptr;\n }\n \n void TableJoin::addUsingKey(const ASTPtr & ast)\n@@ -184,7 +211,7 @@ Block TableJoin::getRequiredRightKeys(const Block & right_table_keys, std::vecto\n {\n     const Names & left_keys = keyNamesLeft();\n     const Names & right_keys = keyNamesRight();\n-    NameSet required_keys(requiredRightKeys().begin(), requiredRightKeys().end());\n+    NameSet required_keys = requiredRightKeys();\n     Block required_right_keys;\n \n     for (size_t i = 0; i < right_keys.size(); ++i)\n@@ -202,7 +229,6 @@ Block TableJoin::getRequiredRightKeys(const Block & right_table_keys, std::vecto\n     return required_right_keys;\n }\n \n-\n bool TableJoin::leftBecomeNullable(const DataTypePtr & column_type) const\n {\n     return forceNullableLeft() && JoinCommon::canBecomeNullable(column_type);\n@@ -215,36 +241,54 @@ bool TableJoin::rightBecomeNullable(const DataTypePtr & column_type) const\n \n void TableJoin::addJoinedColumn(const NameAndTypePair & joined_column)\n {\n-    DataTypePtr type = joined_column.type;\n+    columns_added_by_join.emplace_back(joined_column);\n+}\n \n-    if (hasUsing())\n+NamesAndTypesList TableJoin::correctedColumnsAddedByJoin() const\n+{\n+    NamesAndTypesList result;\n+    for (const auto & col : columns_added_by_join)\n     {\n-        if (auto it = right_type_map.find(joined_column.name); it != right_type_map.end())\n-            type = it->second;\n-    }\n+        DataTypePtr type = col.type;\n+        if (hasUsing())\n+        {\n+            if (auto it = right_type_map.find(col.name); it != right_type_map.end())\n+                type = it->second;\n+        }\n \n-    if (rightBecomeNullable(type))\n-        type = JoinCommon::convertTypeToNullable(type);\n+        if (rightBecomeNullable(type))\n+            type = JoinCommon::convertTypeToNullable(type);\n+        result.emplace_back(col.name, type);\n+    }\n \n-    columns_added_by_join.emplace_back(joined_column.name, type);\n+    return result;\n }\n \n-void TableJoin::addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability) const\n+void TableJoin::addJoinedColumnsAndCorrectTypes(NamesAndTypesList & left_columns, bool correct_nullability)\n {\n-    for (auto & col : names_and_types)\n+    for (auto & col : left_columns)\n     {\n         if (hasUsing())\n         {\n+            /*\n+             * Join with `USING` semantic allows to have columns with changed types in result table.\n+             * But `JOIN ON` should preserve types from original table.\n+             * So we need to know changed types in result tables before further analysis (e.g. analyzeAggregation)\n+             * For `JOIN ON expr1 == expr2` we will infer common type later in makeTableJoin,\n+             *   when part of plan built and types of expression will be known.\n+             */\n+            inferJoinKeyCommonType(left_columns, columns_from_joined_table, !isSpecialStorage());\n+\n             if (auto it = left_type_map.find(col.name); it != left_type_map.end())\n                 col.type = it->second;\n         }\n+\n         if (correct_nullability && leftBecomeNullable(col.type))\n             col.type = JoinCommon::convertTypeToNullable(col.type);\n     }\n \n-    /// Types in columns_added_by_join already converted and set nullable if needed\n-    for (const auto & col : columns_added_by_join)\n-        names_and_types.emplace_back(col.name, col.type);\n+    for (const auto & col : correctedColumnsAddedByJoin())\n+        left_columns.emplace_back(col.name, col.type);\n }\n \n bool TableJoin::sameStrictnessAndKind(ASTTableJoin::Strictness strictness_, ASTTableJoin::Kind kind_) const\n@@ -282,7 +326,18 @@ bool TableJoin::needStreamWithNonJoinedRows() const\n     return isRightOrFull(kind());\n }\n \n-bool TableJoin::allowDictJoin(const String & dict_key, const Block & sample_block, Names & src_names, NamesAndTypesList & dst_columns) const\n+static std::optional<String> getDictKeyName(const String & dict_name , ContextPtr context)\n+{\n+    auto dictionary = context->getExternalDictionariesLoader().getDictionary(dict_name, context);\n+    if (!dictionary)\n+        return {};\n+\n+    if (const auto & structure = dictionary->getStructure(); structure.id)\n+        return structure.id->name;\n+    return {};\n+}\n+\n+bool TableJoin::tryInitDictJoin(const Block & sample_block, ContextPtr context)\n {\n     /// Support ALL INNER, [ANY | ALL | SEMI | ANTI] LEFT\n     if (!isLeft(kind()) && !(isInner(kind()) && strictness() == ASTTableJoin::Strictness::All))\n@@ -297,9 +352,17 @@ bool TableJoin::allowDictJoin(const String & dict_key, const Block & sample_bloc\n     if (it_key == original_names.end())\n         return false;\n \n-    if (dict_key != it_key->second)\n+    if (!right_storage_dictionary)\n+        return false;\n+\n+    auto dict_name = right_storage_dictionary->getDictionaryName();\n+\n+    auto dict_key = getDictKeyName(dict_name, context);\n+    if (!dict_key.has_value() || *dict_key != it_key->second)\n         return false; /// JOIN key != Dictionary key\n \n+    Names src_names;\n+    NamesAndTypesList dst_columns;\n     for (const auto & col : sample_block)\n     {\n         if (col.name == right_keys[0])\n@@ -313,51 +376,35 @@ bool TableJoin::allowDictJoin(const String & dict_key, const Block & sample_bloc\n             dst_columns.push_back({col.name, col.type});\n         }\n     }\n+    dictionary_reader = std::make_shared<DictionaryReader>(dict_name, src_names, dst_columns, context);\n \n     return true;\n }\n \n-bool TableJoin::applyJoinKeyConvert(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns)\n+std::pair<ActionsDAGPtr, ActionsDAGPtr>\n+TableJoin::createConvertingActions(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns)\n {\n-    bool need_convert = needConvert();\n-    if (!need_convert && !hasUsing())\n-    {\n-        /// For `USING` we already inferred common type an syntax analyzer stage\n-        NamesAndTypesList left_list;\n-        NamesAndTypesList right_list;\n-        for (const auto & col : left_sample_columns)\n-            left_list.emplace_back(col.name, col.type);\n-        for (const auto & col : right_sample_columns)\n-            right_list.emplace_back(col.name, col.type);\n-\n-        need_convert = inferJoinKeyCommonType(left_list, right_list);\n-    }\n+    inferJoinKeyCommonType(left_sample_columns, right_sample_columns, !isSpecialStorage());\n \n-    if (need_convert)\n-    {\n-        left_converting_actions = applyKeyConvertToTable(left_sample_columns, left_type_map, key_names_left);\n-        right_converting_actions = applyKeyConvertToTable(right_sample_columns, right_type_map, key_names_right);\n-    }\n+    auto left_converting_actions = applyKeyConvertToTable(left_sample_columns, left_type_map, key_names_left);\n+    auto right_converting_actions = applyKeyConvertToTable(right_sample_columns, right_type_map, key_names_right);\n \n-    return need_convert;\n+    return {left_converting_actions, right_converting_actions};\n }\n \n-bool TableJoin::inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right)\n+template <typename LeftNamesAndTypes, typename RightNamesAndTypes>\n+bool TableJoin::inferJoinKeyCommonType(const LeftNamesAndTypes & left, const RightNamesAndTypes & right, bool allow_right)\n {\n-    std::unordered_map<String, DataTypePtr> left_types;\n+    if (!left_type_map.empty() || !right_type_map.empty())\n+        return true;\n+\n+    NameToTypeMap left_types;\n     for (const auto & col : left)\n-    {\n         left_types[col.name] = col.type;\n-    }\n \n-    std::unordered_map<String, DataTypePtr> right_types;\n+    NameToTypeMap right_types;\n     for (const auto & col : right)\n-    {\n-        if (auto it = renames.find(col.name); it != renames.end())\n-            right_types[it->second] = col.type;\n-        else\n-            right_types[col.name] = col.type;\n-    }\n+        right_types[renamedRightColumnName(col.name)] = col.type;\n \n     for (size_t i = 0; i < key_names_left.size(); ++i)\n     {\n@@ -374,37 +421,37 @@ bool TableJoin::inferJoinKeyCommonType(const NamesAndTypesList & left, const Nam\n         if (JoinCommon::typesEqualUpToNullability(ltype->second, rtype->second))\n             continue;\n \n-        DataTypePtr supertype;\n+        DataTypePtr common_type;\n         try\n         {\n-            supertype = DB::getLeastSupertype({ltype->second, rtype->second});\n+            /// TODO(vdimir): use getMostSubtype if possible\n+            common_type = DB::getLeastSupertype({ltype->second, rtype->second});\n         }\n         catch (DB::Exception & ex)\n         {\n-            throw Exception(\n-                \"Type mismatch of columns to JOIN by: \" +\n-                    key_names_left[i] + \": \" + ltype->second->getName() + \" at left, \" +\n-                    key_names_right[i] + \": \" + rtype->second->getName() + \" at right. \" +\n-                    \"Can't get supertype: \" + ex.message(),\n-                ErrorCodes::TYPE_MISMATCH);\n+            throw DB::Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Can't infer common type for joined columns: {}: {} at left, {}: {} at right. {}\",\n+                key_names_left[i], ltype->second->getName(),\n+                key_names_right[i], rtype->second->getName(),\n+                ex.message());\n         }\n-        left_type_map[key_names_left[i]] = right_type_map[key_names_right[i]] = supertype;\n+\n+        if (!allow_right && !common_type->equals(*rtype->second))\n+        {\n+            throw DB::Exception(ErrorCodes::TYPE_MISMATCH,\n+                \"Can't change type for right table: {}: {} -> {}.\",\n+                key_names_right[i], rtype->second->getName(), common_type->getName());\n+        }\n+        left_type_map[key_names_left[i]] = right_type_map[key_names_right[i]] = common_type;\n     }\n \n     if (!left_type_map.empty() || !right_type_map.empty())\n     {\n-        auto format_type_map = [](NameToTypeMap mapping) -> std::string\n-        {\n-            std::vector<std::string> text;\n-            for (const auto & [k, v] : mapping)\n-                text.push_back(k + \": \" + v->getName());\n-            return fmt::format(\"{}\", fmt::join(text, \", \"));\n-        };\n         LOG_TRACE(\n             &Poco::Logger::get(\"TableJoin\"),\n             \"Infer supertype for joined columns. Left: [{}], Right: [{}]\",\n-            format_type_map(left_type_map),\n-            format_type_map(right_type_map));\n+            formatTypeMap(left_type_map, left_types),\n+            formatTypeMap(right_type_map, right_types));\n     }\n \n     return !left_type_map.empty();\n@@ -413,15 +460,20 @@ bool TableJoin::inferJoinKeyCommonType(const NamesAndTypesList & left, const Nam\n ActionsDAGPtr TableJoin::applyKeyConvertToTable(\n     const ColumnsWithTypeAndName & cols_src, const NameToTypeMap & type_mapping, Names & names_to_rename) const\n {\n+    bool has_some_to_do = false;\n+\n     ColumnsWithTypeAndName cols_dst = cols_src;\n     for (auto & col : cols_dst)\n     {\n         if (auto it = type_mapping.find(col.name); it != type_mapping.end())\n         {\n+            has_some_to_do = true;\n             col.type = it->second;\n             col.column = nullptr;\n         }\n     }\n+    if (!has_some_to_do)\n+        return nullptr;\n \n     NameToNameMap key_column_rename;\n     /// Returns converting actions for tables that need to be performed before join\n@@ -437,6 +489,20 @@ ActionsDAGPtr TableJoin::applyKeyConvertToTable(\n     return dag;\n }\n \n+void TableJoin::setStorageJoin(std::shared_ptr<StorageJoin> storage)\n+{\n+    if (right_storage_dictionary)\n+        throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"StorageJoin and Dictionary join are mutually exclusive\");\n+    right_storage_join = storage;\n+}\n+\n+void TableJoin::setStorageJoin(std::shared_ptr<StorageDictionary> storage)\n+{\n+    if (right_storage_join)\n+        throw DB::Exception(ErrorCodes::LOGICAL_ERROR, \"StorageJoin and Dictionary join are mutually exclusive\");\n+    right_storage_dictionary = storage;\n+}\n+\n String TableJoin::renamedRightColumnName(const String & name) const\n {\n     if (const auto it = renames.find(name); it != renames.end())\ndiff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h\nindex 5d26a14113ca..462dd540a00a 100644\n--- a/src/Interpreters/TableJoin.h\n+++ b/src/Interpreters/TableJoin.h\n@@ -24,6 +24,8 @@ class ASTSelectQuery;\n struct DatabaseAndTableWithAlias;\n class Block;\n class DictionaryReader;\n+class StorageJoin;\n+class StorageDictionary;\n \n struct ColumnWithTypeAndName;\n using ColumnsWithTypeAndName = std::vector<ColumnWithTypeAndName>;\n@@ -86,16 +88,14 @@ class TableJoin\n     /// All columns which can be read from joined table. Duplicating names are qualified.\n     NamesAndTypesList columns_from_joined_table;\n     /// Columns will be added to block by JOIN.\n-    /// It's a subset of columns_from_joined_table with corrected Nullability and type (if inplace type conversion is required)\n+    /// It's a subset of columns_from_joined_table\n+    /// Note: without corrected Nullability or type, see correctedColumnsAddedByJoin\n     NamesAndTypesList columns_added_by_join;\n \n     /// Target type to convert key columns before join\n     NameToTypeMap left_type_map;\n     NameToTypeMap right_type_map;\n \n-    ActionsDAGPtr left_converting_actions;\n-    ActionsDAGPtr right_converting_actions;\n-\n     /// Name -> original name. Names are the same as in columns_from_joined_table list.\n     std::unordered_map<String, String> original_names;\n     /// Original name -> name. Only renamed columns.\n@@ -103,12 +103,23 @@ class TableJoin\n \n     VolumePtr tmp_volume;\n \n+    std::shared_ptr<StorageJoin> right_storage_join;\n+\n+    std::shared_ptr<StorageDictionary> right_storage_dictionary;\n+    std::shared_ptr<DictionaryReader> dictionary_reader;\n+\n     Names requiredJoinedNames() const;\n \n     /// Create converting actions and change key column names if required\n     ActionsDAGPtr applyKeyConvertToTable(\n         const ColumnsWithTypeAndName & cols_src, const NameToTypeMap & type_mapping, Names & names_to_rename) const;\n \n+    /// Calculates common supertypes for corresponding join key columns.\n+    template <typename LeftNamesAndTypes, typename RightNamesAndTypes>\n+    bool inferJoinKeyCommonType(const LeftNamesAndTypes & left, const RightNamesAndTypes & right, bool allow_right);\n+\n+    NamesAndTypesList correctedColumnsAddedByJoin() const;\n+\n public:\n     TableJoin() = default;\n     TableJoin(const Settings &, VolumePtr tmp_volume);\n@@ -126,16 +137,12 @@ class TableJoin\n         table_join.strictness = strictness;\n     }\n \n-    StoragePtr joined_storage;\n-    std::shared_ptr<DictionaryReader> dictionary_reader;\n-\n     ASTTableJoin::Kind kind() const { return table_join.kind; }\n     ASTTableJoin::Strictness strictness() const { return table_join.strictness; }\n     bool sameStrictnessAndKind(ASTTableJoin::Strictness, ASTTableJoin::Kind) const;\n     const SizeLimits & sizeLimits() const { return size_limits; }\n     VolumePtr getTemporaryVolume() { return tmp_volume; }\n     bool allowMergeJoin() const;\n-    bool allowDictJoin(const String & dict_key, const Block & sample_block, Names &, NamesAndTypesList &) const;\n     bool preferMergeJoin() const { return join_algorithm == JoinAlgorithm::PREFER_PARTIAL_MERGE; }\n     bool forceMergeJoin() const { return join_algorithm == JoinAlgorithm::PARTIAL_MERGE; }\n     bool forceHashJoin() const\n@@ -190,21 +197,13 @@ class TableJoin\n     bool rightBecomeNullable(const DataTypePtr & column_type) const;\n     void addJoinedColumn(const NameAndTypePair & joined_column);\n \n-    void addJoinedColumnsAndCorrectTypes(NamesAndTypesList & names_and_types, bool correct_nullability = true) const;\n-\n-    /// Calculates common supertypes for corresponding join key columns.\n-    bool inferJoinKeyCommonType(const NamesAndTypesList & left, const NamesAndTypesList & right);\n+    void addJoinedColumnsAndCorrectTypes(NamesAndTypesList & left_columns, bool correct_nullability);\n \n     /// Calculate converting actions, rename key columns in required\n     /// For `USING` join we will convert key columns inplace and affect into types in the result table\n     /// For `JOIN ON` we will create new columns with converted keys to join by.\n-    bool applyJoinKeyConvert(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns);\n-\n-    bool needConvert() const { return !left_type_map.empty(); }\n-\n-    /// Key columns should be converted before join.\n-    ActionsDAGPtr leftConvertingActions() const { return left_converting_actions; }\n-    ActionsDAGPtr rightConvertingActions() const { return right_converting_actions; }\n+    std::pair<ActionsDAGPtr, ActionsDAGPtr>\n+    createConvertingActions(const ColumnsWithTypeAndName & left_sample_columns, const ColumnsWithTypeAndName & right_sample_columns);\n \n     void setAsofInequality(ASOF::Inequality inequality) { asof_inequality = inequality; }\n     ASOF::Inequality getAsofInequality() { return asof_inequality; }\n@@ -215,6 +214,7 @@ class TableJoin\n     const Names & keyNamesLeft() const { return key_names_left; }\n     const Names & keyNamesRight() const { return key_names_right; }\n     const NamesAndTypesList & columnsFromJoinedTable() const { return columns_from_joined_table; }\n+\n     Names columnsAddedByJoin() const\n     {\n         Names res;\n@@ -230,6 +230,16 @@ class TableJoin\n \n     String renamedRightColumnName(const String & name) const;\n     std::unordered_map<String, String> leftToRightKeyRemap() const;\n+\n+    void setStorageJoin(std::shared_ptr<StorageJoin> storage);\n+    void setStorageJoin(std::shared_ptr<StorageDictionary> storage);\n+\n+    std::shared_ptr<StorageJoin> getStorageJoin() { return right_storage_join; }\n+\n+    bool tryInitDictJoin(const Block & sample_block, ContextPtr context);\n+\n+    bool isSpecialStorage() const { return right_storage_dictionary || right_storage_join; }\n+    const DictionaryReader * getDictionaryReader() const { return dictionary_reader.get(); }\n };\n \n }\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 5a9e2bfbd17f..51df6cd022b5 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -422,46 +422,44 @@ void executeScalarSubqueries(ASTPtr & query, ContextPtr context, size_t subquery\n void getArrayJoinedColumns(ASTPtr & query, TreeRewriterResult & result, const ASTSelectQuery * select_query,\n                            const NamesAndTypesList & source_columns, const NameSet & source_columns_set)\n {\n-    if (ASTPtr array_join_expression_list = select_query->arrayJoinExpressionList())\n+    if (!select_query->arrayJoinExpressionList().first)\n+        return;\n+\n+    ArrayJoinedColumnsVisitor::Data visitor_data{\n+        result.aliases, result.array_join_name_to_alias, result.array_join_alias_to_name, result.array_join_result_to_source};\n+    ArrayJoinedColumnsVisitor(visitor_data).visit(query);\n+\n+    /// If the result of ARRAY JOIN is not used, it is necessary to ARRAY-JOIN any column,\n+    /// to get the correct number of rows.\n+    if (result.array_join_result_to_source.empty())\n     {\n-        ArrayJoinedColumnsVisitor::Data visitor_data{result.aliases,\n-                                                    result.array_join_name_to_alias,\n-                                                    result.array_join_alias_to_name,\n-                                                    result.array_join_result_to_source};\n-        ArrayJoinedColumnsVisitor(visitor_data).visit(query);\n-\n-        /// If the result of ARRAY JOIN is not used, it is necessary to ARRAY-JOIN any column,\n-        /// to get the correct number of rows.\n-        if (result.array_join_result_to_source.empty())\n-        {\n-            if (select_query->arrayJoinExpressionList()->children.empty())\n-                throw DB::Exception(\"ARRAY JOIN requires an argument\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+        if (select_query->arrayJoinExpressionList().first->children.empty())\n+            throw DB::Exception(\"ARRAY JOIN requires an argument\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-            ASTPtr expr = select_query->arrayJoinExpressionList()->children.at(0);\n-            String source_name = expr->getColumnName();\n-            String result_name = expr->getAliasOrColumnName();\n+        ASTPtr expr = select_query->arrayJoinExpressionList().first->children.at(0);\n+        String source_name = expr->getColumnName();\n+        String result_name = expr->getAliasOrColumnName();\n \n-            /// This is an array.\n-            if (!expr->as<ASTIdentifier>() || source_columns_set.count(source_name))\n-            {\n-                result.array_join_result_to_source[result_name] = source_name;\n-            }\n-            else /// This is a nested table.\n+        /// This is an array.\n+        if (!expr->as<ASTIdentifier>() || source_columns_set.count(source_name))\n+        {\n+            result.array_join_result_to_source[result_name] = source_name;\n+        }\n+        else /// This is a nested table.\n+        {\n+            bool found = false;\n+            for (const auto & column : source_columns)\n             {\n-                bool found = false;\n-                for (const auto & column : source_columns)\n+                auto split = Nested::splitName(column.name);\n+                if (split.first == source_name && !split.second.empty())\n                 {\n-                    auto split = Nested::splitName(column.name);\n-                    if (split.first == source_name && !split.second.empty())\n-                    {\n-                        result.array_join_result_to_source[Nested::concatenateName(result_name, split.second)] = column.name;\n-                        found = true;\n-                        break;\n-                    }\n+                    result.array_join_result_to_source[Nested::concatenateName(result_name, split.second)] = column.name;\n+                    found = true;\n+                    break;\n                 }\n-                if (!found)\n-                    throw Exception(\"No columns in nested table \" + source_name, ErrorCodes::EMPTY_NESTED_TABLE);\n             }\n+            if (!found)\n+                throw Exception(\"No columns in nested table \" + source_name, ErrorCodes::EMPTY_NESTED_TABLE);\n         }\n     }\n }\n@@ -519,13 +517,6 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTTableJoin & table_\n         const auto & keys = table_join.using_expression_list->as<ASTExpressionList &>();\n         for (const auto & key : keys.children)\n             analyzed_join.addUsingKey(key);\n-\n-        /// `USING` semantic allows to have columns with changed types in result table.\n-        /// `JOIN ON` should preserve types from original table\n-        /// We can infer common type on syntax stage for `USING` because join is performed only by columns (not expressions)\n-        /// We need to know  changed types in result tables because some analysis (e.g. analyzeAggregation) performed before join\n-        /// For `JOIN ON expr1 == expr2` we will infer common type later in ExpressionAnalyzer, when types of expression will be known\n-        analyzed_join.inferJoinKeyCommonType(tables[0].columns, tables[1].columns);\n     }\n     else if (table_join.on_expression)\n     {\ndiff --git a/src/Interpreters/TreeRewriter.h b/src/Interpreters/TreeRewriter.h\nindex 0dca00c285e1..98201f35216e 100644\n--- a/src/Interpreters/TreeRewriter.h\n+++ b/src/Interpreters/TreeRewriter.h\n@@ -73,7 +73,7 @@ struct TreeRewriterResult\n     /// Results of scalar sub queries\n     Scalars scalars;\n \n-    TreeRewriterResult(\n+    explicit TreeRewriterResult(\n         const NamesAndTypesList & source_columns_,\n         ConstStoragePtr storage_ = {},\n         const StorageMetadataPtr & metadata_snapshot_ = {},\n@@ -84,7 +84,6 @@ struct TreeRewriterResult\n     Names requiredSourceColumns() const { return required_source_columns.getNames(); }\n     const Names & requiredSourceColumnsForAccessCheck() const { return required_source_columns_before_expanding_alias_columns; }\n     NameSet getArrayJoinSourceNameSet() const;\n-    Names getExpandedAliases() const { return {expanded_aliases.begin(), expanded_aliases.end()}; }\n     const Scalars & getScalars() const { return scalars; }\n };\n \ndiff --git a/src/Parsers/ASTSelectQuery.cpp b/src/Parsers/ASTSelectQuery.cpp\nindex 7699d3806239..1c5a4310f1b6 100644\n--- a/src/Parsers/ASTSelectQuery.cpp\n+++ b/src/Parsers/ASTSelectQuery.cpp\n@@ -319,24 +319,16 @@ bool ASTSelectQuery::withFill() const\n }\n \n \n-ASTPtr ASTSelectQuery::arrayJoinExpressionList(bool & is_left) const\n+std::pair<ASTPtr, bool> ASTSelectQuery::arrayJoinExpressionList() const\n {\n     const ASTArrayJoin * array_join = getFirstArrayJoin(*this);\n     if (!array_join)\n         return {};\n \n-    is_left = (array_join->kind == ASTArrayJoin::Kind::Left);\n-    return array_join->expression_list;\n+    bool is_left = (array_join->kind == ASTArrayJoin::Kind::Left);\n+    return {array_join->expression_list, is_left};\n }\n \n-\n-ASTPtr ASTSelectQuery::arrayJoinExpressionList() const\n-{\n-    bool is_left;\n-    return arrayJoinExpressionList(is_left);\n-}\n-\n-\n const ASTTablesInSelectQueryElement * ASTSelectQuery::join() const\n {\n     return getFirstTableJoin(*this);\ndiff --git a/src/Parsers/ASTSelectQuery.h b/src/Parsers/ASTSelectQuery.h\nindex 2babc2f75c8e..2b004e9e040f 100644\n--- a/src/Parsers/ASTSelectQuery.h\n+++ b/src/Parsers/ASTSelectQuery.h\n@@ -123,8 +123,8 @@ class ASTSelectQuery : public IAST\n     /// Compatibility with old parser of tables list. TODO remove\n     ASTPtr sampleSize() const;\n     ASTPtr sampleOffset() const;\n-    ASTPtr arrayJoinExpressionList(bool & is_left) const;\n-    ASTPtr arrayJoinExpressionList() const;\n+    std::pair<ASTPtr, bool> arrayJoinExpressionList() const;\n+\n     const ASTTablesInSelectQueryElement * join() const;\n     bool final() const;\n     bool withFill() const;\ndiff --git a/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp b/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\nindex 806c861cf007..1f33f3eb092c 100644\n--- a/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\n+++ b/src/Storages/MergeTree/MergeTreeWhereOptimizer.cpp\n@@ -373,7 +373,7 @@ bool MergeTreeWhereOptimizer::cannotBeMoved(const ASTPtr & ptr, bool is_final) c\n \n void MergeTreeWhereOptimizer::determineArrayJoinedNames(ASTSelectQuery & select)\n {\n-    auto array_join_expression_list = select.arrayJoinExpressionList();\n+    auto [array_join_expression_list, _] = select.arrayJoinExpressionList();\n \n     /// much simplified code from ExpressionAnalyzer::getArrayJoinedColumns()\n     if (!array_join_expression_list)\n",
  "test_patch": "diff --git a/src/Storages/tests/gtest_transform_query_for_external_database.cpp b/src/Storages/tests/gtest_transform_query_for_external_database.cpp\nindex 1d4cad576fac..b2621445147b 100644\n--- a/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n+++ b/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n@@ -104,7 +104,7 @@ static void check(\n     SelectQueryInfo query_info;\n     SelectQueryOptions select_options;\n     query_info.syntax_analyzer_result\n-        = TreeRewriter(state.context).analyzeSelect(ast, state.getColumns(), select_options, state.getTables(table_num));\n+        = TreeRewriter(state.context).analyzeSelect(ast, DB::TreeRewriterResult(state.getColumns()), select_options, state.getTables(table_num));\n     query_info.query = ast;\n     std::string transformed_query = transformQueryForExternalDatabase(\n         query_info, state.getColumns(), IdentifierQuotingStyle::DoubleQuotes, \"test\", \"table\", state.context);\ndiff --git a/tests/queries/0_stateless/00561_storage_join.sql b/tests/queries/0_stateless/00561_storage_join.sql\nindex 01e66d0c3808..ad4fab09c208 100644\n--- a/tests/queries/0_stateless/00561_storage_join.sql\n+++ b/tests/queries/0_stateless/00561_storage_join.sql\n@@ -25,24 +25,17 @@ insert into joinbug_join (id, id2, val, val2, created)\n select id, id2, val, val2, created\n from joinbug;\n \n-/* expected */\n-select *\n-from joinbug;\n+select * from joinbug;\n \n-/* wtf */\n select id, id2, val, val2, created\n-from (\n-   SELECT toUInt64(arrayJoin(range(50))) AS id2\n-) js1\n+from ( SELECT toUInt64(arrayJoin(range(50))) AS id2 ) js1\n SEMI LEFT JOIN joinbug_join using id2;\n \n-/* type conversion */\n-SELECT * FROM\n-(\n-    SELECT toUInt32(11) AS id2\n-) AS js1\n-SEMI LEFT JOIN joinbug_join USING (id2);\n+-- type conversion\n+SELECT * FROM ( SELECT toUInt32(11) AS id2 ) AS js1 SEMI LEFT JOIN joinbug_join USING (id2);\n \n+-- can't convert right side in case on storage join\n+SELECT * FROM ( SELECT toInt64(11) AS id2 ) AS js1 SEMI LEFT JOIN joinbug_join USING (id2); -- { serverError 53 }\n \n DROP TABLE joinbug;\n DROP TABLE joinbug_join;\ndiff --git a/tests/queries/0_stateless/00855_join_with_array_join.reference b/tests/queries/0_stateless/00855_join_with_array_join.reference\nindex 88f9253500c4..acb0240fbd27 100644\n--- a/tests/queries/0_stateless/00855_join_with_array_join.reference\n+++ b/tests/queries/0_stateless/00855_join_with_array_join.reference\n@@ -9,3 +9,12 @@\n 2\t2\ta2\n 1\t0\t\n 2\t2\ta2\n+0\t0\n+0\t0\n+0\t0\n+0\t0\n+0\n+0\n+0\n+0\n+0\tInt64\tInt64\ndiff --git a/tests/queries/0_stateless/00855_join_with_array_join.sql b/tests/queries/0_stateless/00855_join_with_array_join.sql\nindex 506d94791105..642f90d4c6cb 100644\n--- a/tests/queries/0_stateless/00855_join_with_array_join.sql\n+++ b/tests/queries/0_stateless/00855_join_with_array_join.sql\n@@ -30,6 +30,22 @@ SELECT did, id, name FROM f LEFT ARRAY JOIN d_ids as did LEFT JOIN d ON d.id = d\n -- name clash, doesn't work yet\n SELECT id, name FROM f LEFT ARRAY JOIN d_ids as id LEFT JOIN d ON d.id = id ORDER BY id; -- { serverError 403 }\n \n+SELECT * FROM ( SELECT [dummy, dummy] AS dummy FROM system.one ) AS x ARRAY JOIN dummy\n+JOIN system.one AS y ON x.dummy == y.dummy;\n+\n+SELECT * FROM ( SELECT [dummy, dummy] AS dummy FROM system.one ) AS x ARRAY JOIN dummy\n+JOIN system.one AS y ON x.dummy + 1 == y.dummy + 1;\n+\n+SELECT * FROM ( SELECT [dummy, dummy] AS dummy FROM system.one ) AS x ARRAY JOIN dummy\n+JOIN system.one AS y USING dummy;\n+\n+SELECT * FROM ( SELECT [toUInt32(dummy), toUInt32(dummy)] AS dummy FROM system.one ) AS x ARRAY JOIN dummy\n+JOIN (select toInt32(dummy) as dummy from system.one ) AS y USING dummy;\n+\n+SELECT dummy > 0, toTypeName(any(dummy)), any(toTypeName(dummy)) \n+FROM ( SELECT [toUInt32(dummy), toUInt32(dummy)] AS dummy FROM system.one ) AS x ARRAY JOIN dummy\n+JOIN ( SELECT toInt32(dummy) AS dummy FROM system.one ) AS y USING dummy GROUP BY (dummy > 0);\n+\n DROP TABLE IF EXISTS f;\n DROP TABLE IF EXISTS d;\n \n",
  "problem_statement": "Combining ARRAY JOIN with JOIN\n**Describe the unexpected behaviour**\r\nThe following query worked fine in 21.3, but stopped working in 21.4+\r\n\r\n**How to reproduce**\r\nClickHouse server: 21.4 or later\r\n```\r\nSELECT * FROM (\r\n    SELECT [dummy, dummy] AS dummy FROM system.one\r\n) x ARRAY JOIN dummy\r\nJOIN system.one USING dummy\r\n```\r\n**Expected behavior**\r\nQuery should run without errors\r\n\r\n**Error message and/or stacktrace**\r\n```\r\nCode: 53, e.displayText() = DB::Exception: Type mismatch of columns to JOIN by: dummy: Array(UInt8) at left, one.dummy: UInt8 at right. Can't get supertype: There is no supertype for types Array(UInt8), UInt8 because some of them are Array and some of them are not (version 21.4.7.3 (official build))\r\n```\n",
  "hints_text": "Stopped work after https://github.com/ClickHouse/ClickHouse/pull/19885. I'll try to allow such cases",
  "created_at": "2021-06-26T11:28:37Z"
}