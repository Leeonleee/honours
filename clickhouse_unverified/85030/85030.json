{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 85030,
  "instance_id": "ClickHouse__ClickHouse-85030",
  "issue_numbers": [
    "82205"
  ],
  "base_commit": "68a69334f1ae4738093b0156c693f36e154a8a63",
  "patch": "diff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 36aac41fece4..31259c84879a 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -232,6 +232,8 @@ void QueryAnalyzer::resolve(QueryTreeNodePtr & node, const QueryTreeNodePtr & ta\n                             node->getNodeTypeName());\n         }\n     }\n+\n+    validateCorrelatedSubqueries(node);\n }\n \n void QueryAnalyzer::resolveConstantExpression(QueryTreeNodePtr & node, const QueryTreeNodePtr & table_expression, ContextPtr context)\n@@ -260,6 +262,8 @@ void QueryAnalyzer::resolveConstantExpression(QueryTreeNodePtr & node, const Que\n         resolveExpressionNodeList(node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n     else\n         resolveExpressionNode(node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+\n+    validateCorrelatedSubqueries(node);\n }\n \n bool isFromJoinTree(const IQueryTreeNode * node_source, const IQueryTreeNode * tree_node)\ndiff --git a/src/Analyzer/ValidationUtils.cpp b/src/Analyzer/ValidationUtils.cpp\nindex d6afe8c59d56..ef89b1db017a 100644\n--- a/src/Analyzer/ValidationUtils.cpp\n+++ b/src/Analyzer/ValidationUtils.cpp\n@@ -1,13 +1,14 @@\n #include <Analyzer/ValidationUtils.h>\n \n+#include <Analyzer/AggregationUtils.h>\n+#include <Analyzer/ColumnNode.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n-#include <Analyzer/ColumnNode.h>\n-#include <Analyzer/TableNode.h>\n-#include <Analyzer/QueryNode.h>\n #include <Analyzer/InDepthQueryTreeVisitor.h>\n-#include <Analyzer/AggregationUtils.h>\n+#include <Analyzer/QueryNode.h>\n+#include <Analyzer/TableNode.h>\n #include <Analyzer/WindowFunctionsUtils.h>\n+#include <Storages/IStorage.h>\n \n namespace DB\n {\n@@ -480,4 +481,64 @@ void validateTreeSize(const QueryTreeNodePtr & node,\n             max_size);\n }\n \n+void validateCorrelatedSubqueries(const QueryTreeNodePtr & node)\n+{\n+    bool has_remote = false;\n+    bool has_correlated_subquery = false;\n+    QueryTreeNodes nodes_to_process = { node };\n+\n+    while (!nodes_to_process.empty())\n+    {\n+        auto current_node = nodes_to_process.back();\n+        nodes_to_process.pop_back();\n+\n+        switch (current_node->getNodeType())\n+        {\n+            case QueryTreeNodeType::QUERY:\n+            {\n+                auto & query_node = current_node->as<QueryNode &>();\n+                if (query_node.isCorrelated())\n+                    has_correlated_subquery = true;\n+                break;\n+            }\n+            case QueryTreeNodeType::UNION:\n+            {\n+                auto & union_node = current_node->as<UnionNode &>();\n+                if (union_node.isCorrelated())\n+                    has_correlated_subquery = true;\n+                break;\n+            }\n+            case QueryTreeNodeType::TABLE:\n+            {\n+                auto & table_node = current_node->as<TableNode &>();\n+                const auto & storage = table_node.getStorage();\n+                if (storage && storage->isRemote())\n+                    has_remote = true;\n+                break;\n+            }\n+            case QueryTreeNodeType::TABLE_FUNCTION:\n+            {\n+                auto & table_function_node = current_node->as<TableFunctionNode &>();\n+                const auto & storage = table_function_node.getStorage();\n+                if (storage && storage->isRemote())\n+                    has_remote = true;\n+                break;\n+            }\n+            default:\n+                break;\n+        }\n+\n+        if (has_remote && has_correlated_subquery)\n+            throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                \"Correlated subqueries are not supported with remote tables. In query {}\",\n+                node->formatASTForErrorMessage());\n+\n+        for (const auto & child : current_node->getChildren())\n+        {\n+            if (child)\n+                nodes_to_process.push_back(child);\n+        }\n+    }\n+}\n+\n }\ndiff --git a/src/Analyzer/ValidationUtils.h b/src/Analyzer/ValidationUtils.h\nindex df2cdb0d52f7..6be599b35194 100644\n--- a/src/Analyzer/ValidationUtils.h\n+++ b/src/Analyzer/ValidationUtils.h\n@@ -41,6 +41,7 @@ void validateTreeSize(const QueryTreeNodePtr & node,\n     size_t max_size,\n     std::unordered_map<QueryTreeNodePtr, size_t> & node_to_tree_size);\n \n+void validateCorrelatedSubqueries(const QueryTreeNodePtr & node);\n \n /** Compare node with group by key node.\n   * Such comparison does not take into account aliases, but checks types and column sources.\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03576_analyzer_distributed_correlated_subquery.reference b/tests/queries/0_stateless/03576_analyzer_distributed_correlated_subquery.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03576_analyzer_distributed_correlated_subquery.sql b/tests/queries/0_stateless/03576_analyzer_distributed_correlated_subquery.sql\nnew file mode 100644\nindex 000000000000..1788e1d739f5\n--- /dev/null\n+++ b/tests/queries/0_stateless/03576_analyzer_distributed_correlated_subquery.sql\n@@ -0,0 +1,5 @@\n+SET enable_analyzer = 1;\n+\n+CREATE TABLE t0 (c0 Int) ENGINE = MergeTree() ORDER BY tuple();\n+CREATE TABLE t1 (c0 Int) ENGINE = Distributed('test_cluster_two_shards', default, t0);\n+SELECT (SELECT _shard_num) FROM t1 GROUP BY _shard_num SETTINGS allow_experimental_correlated_subqueries = 1; -- { serverError NOT_IMPLEMENTED }\n",
  "problem_statement": "Correlated subquery SEGV with Distributed table\n### Describe the bug\n\nSome validation is missing. Not sure if related to https://github.com/ClickHouse/ClickHouse/issues/82092\n\n### How to reproduce\n\nRun Fiddle: https://fiddle.clickhouse.com/cdc7591f-004a-463a-a33c-f18ff1f53f97\n\n### Error message and/or stacktrace\n\nStack trace:\n\n```\n#0  std::__1::vector<std::__1::weak_ptr<DB::IQueryTreeNode>, std::__1::allocator<std::__1::weak_ptr<DB::IQueryTreeNode> > >::size[abi:se190107]() const (this=0x20)\n    at  contrib/llvm-project/libcxx/include/vector:635\n#1  std::__1::vector<std::__1::weak_ptr<DB::IQueryTreeNode>, std::__1::allocator<std::__1::weak_ptr<DB::IQueryTreeNode> > >::operator[][abi:se190107](unsigned long) const (this=0x20, __n=0)\n    at  contrib/llvm-project/libcxx/include/vector:1443\n#2  DB::ColumnNode::getSourceWeakPointer (this=0x0) at  src/Analyzer/ColumnNode.h:145\n#3  DB::ColumnNode::getColumnSource (this=0x0) at  src/Analyzer/ColumnNode.cpp:40\n#4  0x000055556cc5567e in DB::GlobalPlannerContext::collectTableExpressionDataForCorrelatedColumns (this=<optimized out>, table_expression_node=..., planner_context=...)\n    at  src/Planner/PlannerContext.cpp:63\n#5  0x000055556cf58ce7 in DB::(anonymous namespace)::buildPlannerForCorrelatedSubquery (planner_context=..., correlated_subquery=..., select_query_options=...)\n    at  src/Planner/PlannerCorrelatedSubqueries.cpp:445\n#6  0x000055556cf577c8 in DB::buildQueryPlanForCorrelatedSubquery (planner_context=..., query_plan=..., correlated_subquery=..., select_query_options=...)\n    at  src/Planner/PlannerCorrelatedSubqueries.cpp:534\n#7  0x000055556cf6db8a in DB::(anonymous namespace)::addExpressionStep (planner_context=..., query_plan=..., expression_actions=..., correlated_subtrees=..., select_query_options=..., step_description=..., useful_sets=...)\n    at  src/Planner/Planner.cpp:416\n#8  0x000055556cf67eee in DB::Planner::buildPlanForQueryNode (this=0x7ffea1ded518) at  src/Planner/Planner.cpp:1812\n#9  0x000055556cf62433 in DB::Planner::buildQueryPlanIfNeeded (this=0x7ffea1ded518) at  src/Planner/Planner.cpp:1371\n#10 0x000055556cf6105e in DB::(anonymous namespace)::collectFiltersForAnalysis (query_tree=..., table_nodes=..., query_context=...) at  src/Planner/Planner.cpp:253\n#11 DB::(anonymous namespace)::collectFiltersForAnalysis (query_tree_node=..., select_query_options=...) at  src/Planner/Planner.cpp:304\n#12 DB::Planner::Planner (this=0x7ffdfeb95170, query_tree_=..., select_query_options_=...) at  src/Planner/Planner.cpp:1335\n#13 0x000055556d6bb8a6 in DB::InterpreterSelectQueryAnalyzer::InterpreterSelectQueryAnalyzer (this=0x7ffdfeb95100, query_=..., context_=..., select_query_options_=..., column_names=...)\n    at  src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:183\n#14 0x000055556d6be2d0 in std::__1::make_unique[abi:se190107]<DB::InterpreterSelectQueryAnalyzer, std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&>(std::__1::shared_ptr<DB::IAST>&, std::__1::shared_ptr<DB::Context> const&, DB::SelectQueryOptions const&) (__args=..., __args=..., __args=...) at  contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:634\n#15 0x000055556d6543e4 in std::__1::__function::__policy_func<std::__1::unique_ptr<DB::IInterpreter, std::__1::default_delete<DB::IInterpreter> > (DB::InterpreterFactory::Arguments const&)>::operator()[abi:se190107](DB::InterpreterFactory::Arguments const&) const (this=0x7ffea1ded880, __args=...) at  contrib/llvm-project/libcxx/include/__functional/function.h:716\n#16 std::__1::function<std::__1::unique_ptr<DB::IInterpreter, std::__1::default_delete<DB::IInterpreter> >(DB::InterpreterFactory::Arguments const&)>::operator() (this=0x7ffea1ded880, __arg=...)\n    at  contrib/llvm-project/libcxx/include/__functional/function.h:989\n#17 DB::InterpreterFactory::get (this=0x5555794cdea8 <DB::InterpreterFactory::instance()::interpreter_fact>, query=..., context=..., options=...)\n    at  src/Interpreters/InterpreterFactory.cpp:393\n#18 0x000055556d996dcb in DB::executeQueryImpl (begin=<optimized out>, end=<optimized out>, context=..., flags=..., stage=DB::QueryProcessingStage::Complete, istr=0x0, out_ast=...)\n    at  src/Interpreters/executeQuery.cpp:1455\n#19 0x000055556d991871 in DB::executeQuery (query=..., context=..., flags=..., stage=DB::QueryProcessingStage::Complete) at  src/Interpreters/executeQuery.cpp:1715\n#20 0x000055556f74a4f2 in DB::TCPHandler::runImpl (this=0x7ffea109d000) at  src/Server/TCPHandler.cpp:721\n#21 0x000055556f763c24 in DB::TCPHandler::run (this=0x0) at  src/Server/TCPHandler.cpp:2727\n#22 0x0000555573bdf167 in Poco::Net::TCPServerConnection::start (this=0x0) at  base/poco/Net/src/TCPServerConnection.cpp:40\n#23 0x0000555573bdf665 in Poco::Net::TCPServerDispatcher::run (this=0x7ffe12c8b900) at  base/poco/Net/src/TCPServerDispatcher.cpp:115\n#24 0x0000555573b87c9f in Poco::PooledThread::run (this=0x7ffff5b65180) at  base/poco/Foundation/src/ThreadPool.cpp:205\n#25 0x0000555573b85851 in Poco::ThreadImpl::runnableEntry (pThread=<optimized out>) at  base/poco/Foundation/src/Thread_POSIX.cpp:335\n#26 0x00007ffff7ca2ef1 in start_thread (arg=<optimized out>) at ./nptl/pthread_create.c:448\n#27 0x00007ffff7d3445c in __GI___clone3 () at ../sysdeps/unix/sysv/linux/x86_64/clone3.S:78\n```\n",
  "hints_text": "Correlated subqueries are not supported in distributed queries. I'll add a check for it.",
  "created_at": "2025-08-04T13:02:10Z"
}