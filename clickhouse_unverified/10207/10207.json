{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 10207,
  "instance_id": "ClickHouse__ClickHouse-10207",
  "issue_numbers": [
    "9810"
  ],
  "base_commit": "d4a3ef2fdc342cf0951022f9183844505548a5b3",
  "patch": "diff --git a/src/Interpreters/RequiredSourceColumnsVisitor.cpp b/src/Interpreters/RequiredSourceColumnsVisitor.cpp\nindex 5a740805560f..469a5852fa58 100644\n--- a/src/Interpreters/RequiredSourceColumnsVisitor.cpp\n+++ b/src/Interpreters/RequiredSourceColumnsVisitor.cpp\n@@ -88,12 +88,14 @@ void RequiredSourceColumnsMatcher::visit(const ASTPtr & ast, Data & data)\n         visit(*t, ast, data);\n         return;\n     }\n+\n     if (auto * t = ast->as<ASTSelectQuery>())\n     {\n         data.addTableAliasIfAny(*ast);\n         visit(*t, ast, data);\n         return;\n     }\n+\n     if (ast->as<ASTSubquery>())\n     {\n         data.addTableAliasIfAny(*ast);\ndiff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp\nindex 30b5e8e4483c..339fe2dceb3a 100644\n--- a/src/Interpreters/TableJoin.cpp\n+++ b/src/Interpreters/TableJoin.cpp\n@@ -5,6 +5,8 @@\n #include <Core/Settings.h>\n #include <Core/Block.h>\n \n+#include <Common/StringUtils/StringUtils.h>\n+\n #include <DataTypes/DataTypeNullable.h>\n \n \n@@ -79,7 +81,9 @@ void TableJoin::deduplicateAndQualifyColumnNames(const NameSet & left_table_colu\n         dedup_columns.push_back(column);\n         auto & inserted = dedup_columns.back();\n \n-        if (left_table_columns.count(column.name))\n+        /// Also qualify unusual column names - that does not look like identifiers.\n+\n+        if (left_table_columns.count(column.name) || !isValidIdentifierBegin(column.name.at(0)))\n             inserted.name = right_table_prefix + column.name;\n \n         original_names[inserted.name] = column.name;\ndiff --git a/src/Interpreters/TranslateQualifiedNamesVisitor.cpp b/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\nindex 17b1bc004f88..7c31a6db546d 100644\n--- a/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n+++ b/src/Interpreters/TranslateQualifiedNamesVisitor.cpp\n@@ -5,6 +5,7 @@\n #include <Interpreters/AsteriskSemantic.h>\n \n #include <Common/typeid_cast.h>\n+#include <Common/StringUtils/StringUtils.h>\n #include <Core/Names.h>\n \n #include <Parsers/ASTIdentifier.h>\n@@ -107,8 +108,9 @@ void TranslateQualifiedNamesMatcher::visit(ASTIdentifier & identifier, ASTPtr &,\n             IdentifierSemantic::setMembership(identifier, table_pos);\n \n             /// In case if column from the joined table are in source columns, change it's name to qualified.\n+            /// Also always leave unusual identifiers qualified.\n             auto & table = data.tables[table_pos].table;\n-            if (table_pos && data.hasColumn(short_name))\n+            if (table_pos && (data.hasColumn(short_name) || !isValidIdentifierBegin(short_name.at(0))))\n                 IdentifierSemantic::setColumnLongName(identifier, table);\n             else\n                 IdentifierSemantic::setColumnShortName(identifier, table);\n@@ -128,7 +130,7 @@ void TranslateQualifiedNamesMatcher::visit(ASTFunction & node, const ASTPtr &, D\n         func_arguments->children.clear();\n }\n \n-void TranslateQualifiedNamesMatcher::visit(const ASTQualifiedAsterisk & , const ASTPtr & ast, Data & data)\n+void TranslateQualifiedNamesMatcher::visit(const ASTQualifiedAsterisk &, const ASTPtr & ast, Data & data)\n {\n     if (ast->children.size() != 1)\n         throw Exception(\"Logical error: qualified asterisk must have exactly one child\", ErrorCodes::LOGICAL_ERROR);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01120_join_constants.reference b/tests/queries/0_stateless/01120_join_constants.reference\nnew file mode 100644\nindex 000000000000..a16427fbdf7e\n--- /dev/null\n+++ b/tests/queries/0_stateless/01120_join_constants.reference\n@@ -0,0 +1,2 @@\n+1\thello\t1\tworld\tworld\t1\n+2\thello\t0\t\tworld\t1\ndiff --git a/tests/queries/0_stateless/01120_join_constants.sql b/tests/queries/0_stateless/01120_join_constants.sql\nnew file mode 100644\nindex 000000000000..443559c3ea11\n--- /dev/null\n+++ b/tests/queries/0_stateless/01120_join_constants.sql\n@@ -0,0 +1,17 @@\n+SELECT\n+    t1.*,\n+    t2.*,\n+    'world',\n+    isConstant('world')\n+FROM\n+(\n+    SELECT\n+        arrayJoin([1, 2]) AS k,\n+        'hello'\n+) AS t1\n+LEFT JOIN\n+(\n+    SELECT\n+        arrayJoin([1, 3]) AS k,\n+        'world'\n+) AS t2 ON t1.k = t2.k;\ndiff --git a/tests/queries/bugs/join_constants_on.sql b/tests/queries/bugs/join_constants_on.sql\nnew file mode 100644\nindex 000000000000..ae967e07adbb\n--- /dev/null\n+++ b/tests/queries/bugs/join_constants_on.sql\n@@ -0,0 +1,2 @@\n+select cast(1, 'UInt8') from (select arrayJoin([1, 2]) as a) t1 left join (select 1 as b) t2 on b = ignore('UInt8');\n+select isConstant('UInt8'), toFixedString('hello', toUInt8(substring('UInt8', 5, 1))) from (select arrayJoin([1, 2]) as a) t1 left join (select 1 as b) t2 on b = ignore('UInt8');\n",
  "problem_statement": "Cast bug\nReceived exception: DB::Exception: Second argument to CAST must be a constant string describing type (version 19.17.2.4 (official build))\r\n`select cast(1 as String)`\r\n`from (select 1 as iid) as t1`\r\n`join (select '1' as sid) as t2 on t2.sid = cast(t1.iid as String)`\r\n\r\nOn version 19.4.5.1 this query works fine.\r\n\r\nAlso if I change some parts in this query it will be work without exceptions, for example:\r\n`select cast(1 as Date)` -- or another type except String\r\n`from (select 1 as iid) as t1`\r\n`join (select '1' as sid) as t2 on t2.sid = cast(t1.iid as String)`\r\n\r\n`select cast(1 as String)`\r\n`from (select 1 as iid) as t1`\r\n\r\n`select cast(1 as String)` -- or another type\r\n`from (select 1 as iid) as t1`\r\n`join (select '1' as sid) as t2 on cast(t2.sid as UInt8) = t1.iid`\n",
  "hints_text": "reproduces in master, 20.3\nRelated #7798 \nCan be reproduced even simpler:\r\n\r\n```\r\n:) select cast(2 as String), * from (select 2 \"'String'\")\r\n\r\nReceived exception from server (version 20.4.1):\r\nCode: 43. DB::Exception: Received from localhost:9000. DB::Exception: Second argument to CAST must be a constant string describing type. Stack trace:\r\n```\r\n\r\nTechnical note:\r\nThis is a general issue where auto-generated column names collide with other names. In the original case, column (1) is a constant column `\"'String'\"` with value `String`, generated as a second parameter for the function `cast(1, 'String')`. Column (2) is identical, but generated for `cast(t1.iid, 'String')`. Column (2) is below the join, so it gets materialized when JOIN expression action is applied. After that, `cast(1, 'String')` tries to use the same column and finds that it is not constant, hence the error.\r\n\r\n\n```\r\nSELECT concat('xyz', 'abc'), * FROM (SELECT 2 AS `'xyz'`)\r\n```\n@akuzm @4ertus2 To solve this issue, we have to assign unique names only to constant expressions that will be materialized and altered during JOINs.\r\n\r\ne.g. LEFT JOINed constants that may become NULL.\r\n\r\n\nThe most illustrating example for the root cause of this issue:\r\n\r\n```\r\nSELECT \r\n    t1.*, \r\n    t2.*, \r\n    'world', \r\n    isConstant('world')\r\nFROM \r\n(\r\n    SELECT \r\n        arrayJoin([1, 2]) AS k, \r\n        'hello'\r\n) AS t1\r\nLEFT JOIN \r\n(\r\n    SELECT \r\n        arrayJoin([1, 3]) AS k, \r\n        'world'\r\n) AS t2 ON t1.k = t2.k\r\n\r\n\u250c\u2500k\u2500\u252c\u2500'hello'\u2500\u252c\u2500t2.k\u2500\u252c\u2500'world'\u2500\u252c\u2500'world'\u2500\u252c\u2500isConstant('world')\u2500\u2510\r\n\u2502 1 \u2502 hello   \u2502    1 \u2502 world   \u2502 world   \u2502                   0 \u2502\r\n\u2502 2 \u2502 hello   \u2502    0 \u2502         \u2502         \u2502                   0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nhttps://github.com/ClickHouse/ClickHouse/issues/9810#issuecomment-604995430\r\nhttps://github.com/ClickHouse/ClickHouse/issues/9810#issuecomment-605214756\r\nthat two examples are not very relevant because the user intentionally hacked the query analysis with unusual aliases. They not necessary to be fixed.\nWhat about the following logic:\r\n\r\nIf it's a JOIN action and we have a column with constant expression and without an alias, then assign a unique name.\nIt may be simply done by assigning qualified names.",
  "created_at": "2020-04-12T16:27:33Z"
}