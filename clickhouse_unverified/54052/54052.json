{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54052,
  "instance_id": "ClickHouse__ClickHouse-54052",
  "issue_numbers": [
    "40990"
  ],
  "base_commit": "b29e11dcb771a0b31e58c75114fe23c53109ccdf",
  "patch": "diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex 4260d7bd6603..7a405a2ef783 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -12,6 +12,7 @@\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeString.h>\n #include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeObject.h>\n #include <DataTypes/DataTypeTuple.h>\n #include <DataTypes/DataTypeArray.h>\n #include <DataTypes/DataTypeMap.h>\n@@ -2426,6 +2427,20 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromCompoundExpression(const\n             compound_expression_from_error_message += compound_expression_source;\n         }\n \n+        if (auto * column = compound_expression->as<ColumnNode>())\n+        {\n+            const DataTypePtr & column_type = column->getColumn().getTypeInStorage();\n+            if (column_type->getTypeId() == TypeIndex::Object)\n+            {\n+                const auto * object_type = checkAndGetDataType<DataTypeObject>(column_type.get());\n+                if (object_type->getSchemaFormat() == \"json\" && object_type->hasNullableSubcolumns())\n+                {\n+                    QueryTreeNodePtr constant_node_null = std::make_shared<ConstantNode>(Field());\n+                    return constant_node_null;\n+                }\n+            }\n+        }\n+\n         throw Exception(ErrorCodes::UNKNOWN_IDENTIFIER,\n             \"Identifier {} nested path {} cannot be resolved from type {}{}. In scope {}{}\",\n             expression_identifier,\n@@ -3036,6 +3051,31 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromJoin(const IdentifierLoo\n     JoinKind join_kind = from_join_node.getKind();\n     bool join_use_nulls = scope.context->getSettingsRef().join_use_nulls;\n \n+    /// If columns from left or right table were missed Object(Nullable('json')) subcolumns, they will be replaced\n+    /// to ConstantNode(NULL), which can't be cast to ColumnNode, so we resolve it here.\n+    if (left_resolved_identifier && right_resolved_identifier && left_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT\n+        && right_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)\n+    {\n+        auto & left_resolved_column = left_resolved_identifier->as<ConstantNode &>();\n+        auto & right_resolved_column = right_resolved_identifier->as<ConstantNode &>();\n+        if (left_resolved_column.getValueStringRepresentation() == \"NULL\" && right_resolved_column.getValueStringRepresentation() == \"NULL\")\n+            return left_resolved_identifier;\n+    }\n+    else if (left_resolved_identifier && left_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)\n+    {\n+        resolved_side = JoinTableSide::Left;\n+        auto & left_resolved_column = left_resolved_identifier->as<ConstantNode &>();\n+        if (left_resolved_column.getValueStringRepresentation() == \"NULL\")\n+            return left_resolved_identifier;\n+    }\n+    else if (right_resolved_identifier && right_resolved_identifier->getNodeType() == QueryTreeNodeType::CONSTANT)\n+    {\n+        resolved_side = JoinTableSide::Right;\n+        auto & right_resolved_column = right_resolved_identifier->as<ConstantNode &>();\n+        if (right_resolved_column.getValueStringRepresentation() == \"NULL\")\n+            return right_resolved_identifier;\n+    }\n+\n     if (left_resolved_identifier && right_resolved_identifier)\n     {\n         auto & left_resolved_column = left_resolved_identifier->as<ColumnNode &>();\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex d87ac1ed4359..67187be962ca 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -30,6 +30,7 @@\n #include <Interpreters/getTableExpressions.h>\n #include <Interpreters/replaceAliasColumnsInQuery.h>\n #include <Interpreters/replaceForPositionalArguments.h>\n+#include <Interpreters/replaceMissedSubcolumnsInQuery.h>\n \n #include <Functions/UserDefined/UserDefinedSQLFunctionFactory.h>\n #include <Functions/UserDefined/UserDefinedSQLFunctionVisitor.h>\n@@ -48,6 +49,7 @@\n \n #include <DataTypes/NestedUtils.h>\n #include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeObject.h>\n #include <DataTypes/DataTypeLowCardinality.h>\n \n #include <IO/WriteHelpers.h>\n@@ -948,6 +950,10 @@ void TreeRewriterResult::collectSourceColumns(bool add_special)\n             source_columns.swap(columns_from_storage);\n         else\n             source_columns.insert(source_columns.end(), columns_from_storage.begin(), columns_from_storage.end());\n+\n+        auto metadata_snapshot = storage->getInMemoryMetadataPtr();\n+        auto metadata_column_descriptions = metadata_snapshot->getColumns();\n+        source_columns_ordinary = metadata_column_descriptions.getOrdinary();\n     }\n \n     source_columns_set = removeDuplicateColumns(source_columns);\n@@ -1117,6 +1123,33 @@ bool TreeRewriterResult::collectUsedColumns(const ASTPtr & query, bool is_select\n         }\n     }\n \n+    /// Collect missed object subcolumns\n+    if (!unknown_required_source_columns.empty())\n+    {\n+        for (const NameAndTypePair & pair : source_columns_ordinary)\n+        {\n+            for (auto it = unknown_required_source_columns.begin(); it != unknown_required_source_columns.end();)\n+            {\n+                size_t object_pos = it->find('.');\n+                if (object_pos != std::string::npos)\n+                {\n+                    String object_name = it->substr(0, object_pos);\n+                    if (pair.name == object_name && pair.type->getTypeId() == TypeIndex::Object)\n+                    {\n+                        const auto * object_type = typeid_cast<const DataTypeObject *>(pair.type.get());\n+                        if (object_type->getSchemaFormat() == \"json\" && object_type->hasNullableSubcolumns())\n+                        {\n+                            missed_subcolumns.insert(*it);\n+                            it = unknown_required_source_columns.erase(it);\n+                            continue;\n+                        }\n+                    }\n+                }\n+                ++it;\n+            }\n+        }\n+    }\n+\n     if (!unknown_required_source_columns.empty())\n     {\n         constexpr auto format_string = \"Missing columns: {} while processing query: '{}', required columns:{}{}\";\n@@ -1301,6 +1334,13 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n \n     result.collectUsedColumns(query, true, settings.query_plan_optimize_primary_key);\n \n+    if (!result.missed_subcolumns.empty())\n+    {\n+        for (const String & column_name : result.missed_subcolumns)\n+            replaceMissedSubcolumnsInQuery(query, column_name);\n+        result.missed_subcolumns.clear();\n+    }\n+\n     result.required_source_columns_before_expanding_alias_columns = result.required_source_columns.getNames();\n \n     /// rewrite filters for select query, must go after getArrayJoinedColumns\n@@ -1399,6 +1439,14 @@ TreeRewriterResultPtr TreeRewriter::analyze(\n     bool is_ok = result.collectUsedColumns(query, false, settings.query_plan_optimize_primary_key, no_throw);\n     if (!is_ok)\n         return {};\n+\n+    if (!result.missed_subcolumns.empty())\n+    {\n+        for (const String & column_name : result.missed_subcolumns)\n+            replaceMissedSubcolumnsInQuery(query, column_name);\n+        result.missed_subcolumns.clear();\n+    }\n+\n     return std::make_shared<const TreeRewriterResult>(result);\n }\n \ndiff --git a/src/Interpreters/TreeRewriter.h b/src/Interpreters/TreeRewriter.h\nindex 60832f49b355..75d8fcf0223e 100644\n--- a/src/Interpreters/TreeRewriter.h\n+++ b/src/Interpreters/TreeRewriter.h\n@@ -36,6 +36,11 @@ struct TreeRewriterResult\n     /// Same as above but also record alias columns which are expanded. This is for RBAC access check.\n     Names required_source_columns_before_expanding_alias_columns;\n \n+    /// Set of columns that object columns are not extended. This is for distinguishing JSON and Tuple type.\n+    NamesAndTypesList source_columns_ordinary;\n+\n+    NameSet missed_subcolumns;\n+\n     /// Set of alias columns that are expanded to their alias expressions. We still need the original columns to check access permission.\n     NameSet expanded_aliases;\n \ndiff --git a/src/Interpreters/replaceMissedSubcolumnsInQuery.cpp b/src/Interpreters/replaceMissedSubcolumnsInQuery.cpp\nnew file mode 100644\nindex 000000000000..f8e628c0a342\n--- /dev/null\n+++ b/src/Interpreters/replaceMissedSubcolumnsInQuery.cpp\n@@ -0,0 +1,70 @@\n+#include <Interpreters/replaceMissedSubcolumnsInQuery.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTLiteral.h>\n+\n+namespace DB\n+{\n+\n+bool replaceMissedSubcolumnsInFunction(ASTPtr & ast, const String & column_name)\n+{\n+    bool is_replaced = false;\n+\n+    if (auto * identifier = ast->as<ASTIdentifier>())\n+    {\n+        if (column_name == identifier->getColumnName())\n+        {\n+            ast = std::make_shared<ASTLiteral>(Field());\n+            return true;\n+        }\n+    }\n+    else if (auto * node = ast->as<ASTFunction>())\n+    {\n+        if (node->arguments)\n+        {\n+            size_t num_arguments = node->arguments->children.size();\n+            for (size_t arg = 0; arg < num_arguments; ++arg)\n+            {\n+                auto & child = node->arguments->children[arg];\n+                if (replaceMissedSubcolumnsInFunction(child, column_name))\n+                    is_replaced = true;\n+            }\n+        }\n+    }\n+    else\n+    {\n+        for (auto & child : ast->children)\n+        {\n+            if (replaceMissedSubcolumnsInFunction(child, column_name))\n+                is_replaced = true;\n+        }\n+    }\n+\n+    return is_replaced;\n+}\n+\n+void replaceMissedSubcolumnsInQuery(ASTPtr & ast, const String & column_name)\n+{\n+    if (auto * identifier = ast->as<ASTIdentifier>())\n+    {\n+        if (column_name == identifier->getColumnName())\n+        {\n+            auto literal = std::make_shared<ASTLiteral>(Field());\n+            literal->setAlias(identifier->getAliasOrColumnName());\n+            ast = literal;\n+        }\n+    }\n+    else if (auto * node = ast->as<ASTFunction>())\n+    {\n+        String function_alias = node->getAliasOrColumnName();\n+        if (replaceMissedSubcolumnsInFunction(ast, column_name))\n+            ast->setAlias(function_alias);\n+    }\n+    else\n+    {\n+        for (auto & child : ast->children)\n+            replaceMissedSubcolumnsInQuery(child, column_name);\n+    }\n+}\n+\n+}\ndiff --git a/src/Interpreters/replaceMissedSubcolumnsInQuery.h b/src/Interpreters/replaceMissedSubcolumnsInQuery.h\nnew file mode 100644\nindex 000000000000..7f4b53bbbf2d\n--- /dev/null\n+++ b/src/Interpreters/replaceMissedSubcolumnsInQuery.h\n@@ -0,0 +1,20 @@\n+#pragma once\n+\n+#include <Core/Names.h>\n+#include <Parsers/IAST_fwd.h>\n+#include <base/types.h>\n+\n+namespace DB\n+{\n+\n+/// Replace missed Object(Nullable('json')) subcolumns to NULL in query.\n+void replaceMissedSubcolumnsInQuery(ASTPtr & ast, const String & column_name);\n+\n+/// Return true if the ASTFunction has missed object subcolumns.\n+/// Resolving ASTFunction independently is because we may lose the column name of missed object subcolumns.\n+/// For example, if `b.d` is a missed object subcolumn, the column name of `b.d * 2 + 3` will be `plus(multiply(NULL, 2), 3)`,\n+/// while we want to keep it as `plus(multiply(b.d, 2), 3)`.\n+bool replaceMissedSubcolumnsInFunction(ASTPtr & ast, const String & column_name);\n+\n+}\n+\ndiff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\nindex 6ba0d4dcfad3..a586997360af 100644\n--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n@@ -119,7 +119,11 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(\n     addTotalRowsApprox(data_part->rows_count);\n \n     /// Add columns because we don't want to read empty blocks\n-    injectRequiredColumns(LoadedMergeTreeDataPartInfoForReader(data_part, alter_conversions), storage_snapshot, /*with_subcolumns=*/ false, columns_to_read);\n+    injectRequiredColumns(\n+        LoadedMergeTreeDataPartInfoForReader(data_part, alter_conversions),\n+        storage_snapshot,\n+        storage.supportsSubcolumns(),\n+        columns_to_read);\n \n     NamesAndTypesList columns_for_reader;\n     if (take_column_types_from_storage)\n@@ -127,6 +131,8 @@ MergeTreeSequentialSource::MergeTreeSequentialSource(\n         auto options = GetColumnsOptions(GetColumnsOptions::AllPhysical)\n             .withExtendedObjects()\n             .withSystemColumns();\n+        if (storage.supportsSubcolumns())\n+            options.withSubcolumns();\n         columns_for_reader = storage_snapshot->getColumnsByNames(options, columns_to_read);\n     }\n     else\ndiff --git a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\nindex 17078d3e73b1..96b211085c10 100644\n--- a/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\n+++ b/src/Storages/MergeTree/StorageFromMergeTreeDataPart.h\n@@ -52,9 +52,10 @@ class StorageFromMergeTreeDataPart final : public IStorage\n         if (!hasDynamicSubcolumns(storage_columns))\n             return std::make_shared<StorageSnapshot>(*this, metadata_snapshot);\n \n+        auto data_parts = storage.getDataPartsVectorForInternalUsage();\n+\n         auto object_columns = getConcreteObjectColumns(\n-            parts.begin(), parts.end(),\n-            storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });\n+            data_parts.begin(), data_parts.end(), storage_columns, [](const auto & part) -> const auto & { return part->getColumns(); });\n \n         return std::make_shared<StorageSnapshot>(*this, metadata_snapshot, std::move(object_columns));\n     }\n@@ -89,6 +90,8 @@ class StorageFromMergeTreeDataPart final : public IStorage\n \n     bool supportsDynamicSubcolumns() const override { return true; }\n \n+    bool supportsSubcolumns() const override { return true; }\n+\n     bool mayBenefitFromIndexForIn(\n         const ASTPtr & left_in_operand, ContextPtr query_context, const StorageMetadataPtr & metadata_snapshot) const override\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02886_missed_json_subcolumns.reference b/tests/queries/0_stateless/02886_missed_json_subcolumns.reference\nnew file mode 100644\nindex 000000000000..d2bb7e33e7ec\n--- /dev/null\n+++ b/tests/queries/0_stateless/02886_missed_json_subcolumns.reference\n@@ -0,0 +1,7 @@\n+4\t1\n+{\"id\":\"1\",\"n\":\"aaa\",\"obj.k4\":null}\n+{\"id\":\"2\",\"n\":\"bbb\",\"obj.k4\":null}\n+{\"id\":\"3\",\"n\":\"ccc\",\"obj.k4\":null}\n+{\"id\":\"4\",\"n\":\"ddd\",\"obj.k4\":null}\n+4\t1\n+4\t1\ndiff --git a/tests/queries/0_stateless/02886_missed_json_subcolumns.sql b/tests/queries/0_stateless/02886_missed_json_subcolumns.sql\nnew file mode 100644\nindex 000000000000..90a80509e99d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02886_missed_json_subcolumns.sql\n@@ -0,0 +1,29 @@\n+DROP TABLE IF EXISTS t_mutations_subcolumns;\n+\n+SET allow_experimental_object_type = 1;\n+\n+CREATE TABLE t_missed_subcolumns (id UInt64, n String, obj Object(Nullable('json')))\n+ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_missed_subcolumns VALUES (1, 'aaa', '{\"k1\": {\"k2\": \"foo\"}, \"k3\": 5}');\n+INSERT INTO t_missed_subcolumns VALUES (2, 'bbb', '{\"k1\": {\"k2\": \"fee\"}, \"k3\": 4}');\n+INSERT INTO t_missed_subcolumns VALUES (3, 'ccc', '{\"k1\": {\"k2\": \"foo\", \"k4\": \"baz\"}, \"k3\": 4}');\n+INSERT INTO t_missed_subcolumns VALUES (4, 'ddd', '{\"k1\": {\"k2\": \"foo\"}, \"k3\": 4}');\n+\n+OPTIMIZE TABLE t_missed_subcolumns FINAL;\n+\n+SELECT count(), min(id) FROM t_missed_subcolumns;\n+\n+SELECT * FROM t_missed_subcolumns WHERE obj.k4 = 5 ORDER BY id FORMAT JSONEachRow; \n+\n+SELECT * FROM t_missed_subcolumns WHERE obj.k1.k3 = 'fee' ORDER BY id FORMAT JSONEachRow;\n+\n+SELECT id, n, obj.k4 FROM t_missed_subcolumns ORDER BY id FORMAT JSONEachRow;\n+\n+ALTER TABLE t_missed_subcolumns DELETE WHERE obj.k4 = 5;\n+SELECT count(), min(id) FROM t_missed_subcolumns;\n+\n+DELETE FROM t_missed_subcolumns WHERE obj.k1.k3 = 'fee';\n+SELECT count(), min(id) FROM t_missed_subcolumns;\n+\n+DROP TABLE IF EXISTS t_missed_subcolumns;\ndiff --git a/tests/queries/0_stateless/02887_mutations_subcolumns.reference b/tests/queries/0_stateless/02887_mutations_subcolumns.reference\nnew file mode 100644\nindex 000000000000..c2d6cbbd2253\n--- /dev/null\n+++ b/tests/queries/0_stateless/02887_mutations_subcolumns.reference\n@@ -0,0 +1,10 @@\n+6\t1\n+5\t2\n+4\t3\n+3\t4\n+4\tttt\n+5\tttt\n+6\tttt\n+{\"a\":\"1\",\"obj\":{\"k1\":1,\"k2\":null,\"k3\":null}}\n+{\"a\":\"3\",\"obj\":{\"k1\":null,\"k2\":null,\"k3\":1}}\n+{\"a\":\"1\",\"obj\":{\"k1\":1,\"k2\":null,\"k3\":null}}\ndiff --git a/tests/queries/0_stateless/02887_mutations_subcolumns.sql b/tests/queries/0_stateless/02887_mutations_subcolumns.sql\nnew file mode 100644\nindex 000000000000..a01158e1b063\n--- /dev/null\n+++ b/tests/queries/0_stateless/02887_mutations_subcolumns.sql\n@@ -0,0 +1,48 @@\n+DROP TABLE IF EXISTS t_mutations_subcolumns;\n+\n+SET allow_experimental_object_type = 1;\n+\n+CREATE TABLE t_mutations_subcolumns (id UInt64, n String, obj Object(Nullable('json')))\n+ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t_mutations_subcolumns VALUES (1, 'aaa', '{\"k1\": {\"k2\": \"foo\"}, \"k3\": 5}');\n+INSERT INTO t_mutations_subcolumns VALUES (2, 'bbb', '{\"k1\": {\"k2\": \"fee\"}, \"k3\": 4}');\n+INSERT INTO t_mutations_subcolumns VALUES (3, 'ccc', '{\"k1\": {\"k2\": \"foo\", \"k4\": \"baz\"}, \"k3\": 4}');\n+INSERT INTO t_mutations_subcolumns VALUES (4, 'ddd', '{\"k1\": {\"k2\": \"foo\"}, \"k3\": 4}');\n+INSERT INTO t_mutations_subcolumns VALUES (5, 'eee', '{\"k1\": {\"k2\": \"foo\"}, \"k3\": 4}');\n+INSERT INTO t_mutations_subcolumns VALUES (6, 'fff', '{\"k1\": {\"k2\": \"foo\"}, \"k3\": 4}');\n+\n+OPTIMIZE TABLE t_mutations_subcolumns FINAL;\n+\n+SELECT count(), min(id) FROM t_mutations_subcolumns;\n+\n+SET mutations_sync = 2;\n+\n+ALTER TABLE t_mutations_subcolumns DELETE WHERE obj.k3 = 5;\n+SELECT count(), min(id) FROM t_mutations_subcolumns;  \n+\n+DELETE FROM t_mutations_subcolumns WHERE obj.k1.k2 = 'fee';\n+SELECT count(), min(id) FROM t_mutations_subcolumns;\n+\n+ALTER TABLE t_mutations_subcolumns DELETE WHERE obj.k1 = ('foo', 'baz');\n+SELECT count(), min(id) FROM t_mutations_subcolumns;\n+\n+ALTER TABLE t_mutations_subcolumns UPDATE n = 'ttt' WHERE obj.k1.k2 = 'foo';\n+SELECT id, n FROM t_mutations_subcolumns;\n+\n+DROP TABLE IF EXISTS t_mutations_subcolumns;\n+\n+CREATE TABLE t_mutations_subcolumns (a UInt64, obj Object(Nullable('json')))\n+ENGINE = MergeTree ORDER BY a PARTITION BY a;\n+\n+INSERT INTO t_mutations_subcolumns VALUES (1, '{\"k1\": 1}');\n+INSERT INTO t_mutations_subcolumns VALUES (2, '{\"k2\": 1}');\n+INSERT INTO t_mutations_subcolumns VALUES (3, '{\"k3\": 1}');\n+\n+ALTER TABLE t_mutations_subcolumns DELETE WHERE obj.k2 = 1;\n+SELECT * FROM t_mutations_subcolumns ORDER BY a FORMAT JSONEachRow;\n+\n+ALTER TABLE t_mutations_subcolumns DELETE WHERE isNull(obj.k1);\n+SELECT * FROM t_mutations_subcolumns ORDER BY a FORMAT JSONEachRow;\n+\n+DROP TABLE t_mutations_subcolumns;\n",
  "problem_statement": "Delete rows bug for JSON column type\nclickhouse version 22.8\r\ndoesn't delete row from table using alter table delete command\r\n\r\ncreate table query:\r\n```\r\nCREATE TABLE logs\r\n(\r\n    datetime DEFAULT now() Codec(DoubleDelta, LZ4),\r\n    message JSON\r\n)\r\nENGINE = MergeTree\r\norder by datetime;\r\n```\r\n\r\ninsert query:\r\n```\r\nINSERT INTO logs(message) VALUES ('{\"a\": 2, \"b\": { \"c\": 22, \"d\": [12, 122, 13] }, \"f\": \"a\"}');\r\n```\r\n\r\ndelete query:\r\n```\r\nalter table logs delete where message.f = 'a';\r\n```\r\n\r\nerror from select * from system.mutations;\r\n```\r\nCode: 47. DB::Exception: Missing columns: 'message.f' while processing query: 'SELECT count() WHERE (message.f = 'a') OR (message.f = 'a')', required columns: 'message.f', maybe you meant: ['message']. (UNKNOWN_IDENTIFIER) (version 22.3.8.40.altinitystable (altinity build))\r\n```\n",
  "hints_text": "@Avogar could you check, please?\nSeems like a general problem with subcolumns, not only with JSON type (same problem if we will use named Tuple). Let's ask @CurtizJ if it's something known \nupdate also not working\r\n\r\n```\r\nCREATE TABLE tryupdate\r\n(\r\n    datetime DEFAULT now() Codec(DoubleDelta, LZ4),\r\n    message JSON,\r\n    str String,\r\n    int Int64\r\n)\r\nENGINE = MergeTree\r\norder by datetime\r\n\r\nINSERT INTO tryupdate(message,str,int) VALUES ('{\"a\": 2, \"b\": { \"c\": 22, \"d\": [12, 122, 13] }, \"f\": \"a\"}','a',1)\r\n\r\nalter table tryupdateupdate str = 'v' where int = 1;\r\n```\r\n\r\n\r\n\r\nsystem mutation error\r\n```\r\nCode: 16. DB::Exception: There is no physical column or subcolumn message in table: While executing MergeTreeInOrder. (NO_SUCH_COLUMN_IN_TABLE) (version 22.3.8.40.altinitystable (altinity build))\r\n```\nany updates on this? not being able to update / delete rows is a pretty heavy limitation for our use case\nis there any CH version that support update / delete with json column table?\nRemember JSON column is still experimental, so it will be fixed in the future but it is not urgent. As a workaround you can still use 'old' json functions to delete your rows:\r\n\r\n`ALTER TABLE logs\r\n    DELETE WHERE JSONExtractString(toJSONString(message), 'f') = 'a'`\n@shacuros another issue is try alter delete for primitive column also not working according to https://github.com/ClickHouse/ClickHouse/issues/40990#issuecomment-1238279181 change the alter update to delete, ```alter table trydelete delete where int = 1```, error from system.mutations ```Code: 16. DB::Exception: There is no physical column or subcolumn message in table: While executing MergeTreeInOrder. (NO_SUCH_COLUMN_IN_TABLE) (version 22.3.8.40.altinitystable (altinity build))```\n@Kev1ntan i cannot reproduce your update problem on 22.8.\n@shacuros just found the way to reproduce the issue\r\n\r\n```\r\nCREATE TABLE tryupdate\r\n(\r\n    datetime DEFAULT now() Codec(DoubleDelta, LZ4),\r\n    message JSON,\r\n    str String,\r\n    int Int64\r\n)\r\nENGINE = MergeTree\r\norder by datetime;\r\n\r\nINSERT INTO tryupdate(message,str,int) VALUES ('{\"a\": 2, \"b\": { \"c\": 22, \"d\": [12, 122, 13] }, \"f\": \"a\"}','a',1);\r\n\r\nalter table tryupdate update int = 10 where message.a = 2; (Code: 47. DB::Exception: Missing columns: 'message.a' while processing query: 'SELECT count() WHERE message.a = 2', required columns: 'message.a', maybe you meant: ['message']. (UNKNOWN_IDENTIFIER) (version 22.8.4.7 (official build)))\r\n\r\nthen try to update using :\r\nALTER TABLE tryupdate update int = 10 WHERE JSONExtractString(toJSONString(message), 'f') = 'a' (Code: 47. DB::Exception: Missing columns: 'message.a' while processing query: 'SELECT count() WHERE (message.a = 2) OR (JSONExtractString(toJSONString(message), 'f') = 'a')', required columns: 'message.a' 'message', maybe you meant: ['message','message']. (UNKNOWN_IDENTIFIER) (version 22.8.4.7 (official build)))\r\n```\nJSON data type should not be used; it is under development.",
  "created_at": "2023-08-30T05:50:47Z"
}