{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21895,
  "instance_id": "ClickHouse__ClickHouse-21895",
  "issue_numbers": [
    "5485"
  ],
  "base_commit": "f784bd40512a6a951d85cc77220d94b454767e83",
  "patch": "diff --git a/docs/en/sql-reference/window-functions/index.md b/docs/en/sql-reference/window-functions/index.md\nindex cbf03a44d469..a646347ea608 100644\n--- a/docs/en/sql-reference/window-functions/index.md\n+++ b/docs/en/sql-reference/window-functions/index.md\n@@ -23,7 +23,9 @@ ClickHouse supports the standard grammar for defining windows and window functio\n | `GROUPS` frame | not supported |\n | Calculating aggregate functions over a frame (`sum(value) over (order by time)`) | all aggregate functions are supported |\n | `rank()`, `dense_rank()`, `row_number()` | supported |\n-| `lag/lead(value, offset)` | not supported, replace with `any(value) over (.... rows between <offset> preceding and <offset> preceding)`, or `following` for `lead`| \n+| `lag/lead(value, offset)` | Not supported. Workarounds: |\n+|  | 1) replace with `any(value) over (.... rows between <offset> preceding and <offset> preceding)`, or `following` for `lead`|\n+|  | 2) use `lagInFrame/leadInFrame`, which are analogous, but respect the window frame. To get behavior identical to `lag/lead`, use `rows between unbounded preceding and unbounded following` |\n \n ## References\n \ndiff --git a/src/Core/Field.h b/src/Core/Field.h\nindex 558e1fafd74c..81d06693a7fd 100644\n--- a/src/Core/Field.h\n+++ b/src/Core/Field.h\n@@ -953,3 +953,26 @@ void writeFieldText(const Field & x, WriteBuffer & buf);\n String toString(const Field & x);\n \n }\n+\n+template <>\n+struct fmt::formatter<DB::Field>\n+{\n+    constexpr auto parse(format_parse_context & ctx)\n+    {\n+        auto it = ctx.begin();\n+        auto end = ctx.end();\n+\n+        /// Only support {}.\n+        if (it != end && *it != '}')\n+            throw format_error(\"invalid format\");\n+\n+        return it;\n+    }\n+\n+    template <typename FormatContext>\n+    auto format(const DB::Field & x, FormatContext & ctx)\n+    {\n+        return format_to(ctx.out(), \"{}\", toString(x));\n+    }\n+};\n+\ndiff --git a/src/Interpreters/WindowDescription.cpp b/src/Interpreters/WindowDescription.cpp\nindex e922f49c8961..a97ef41204ac 100644\n--- a/src/Interpreters/WindowDescription.cpp\n+++ b/src/Interpreters/WindowDescription.cpp\n@@ -1,5 +1,6 @@\n #include <Interpreters/WindowDescription.h>\n \n+#include <Core/Field.h>\n #include <IO/Operators.h>\n #include <Parsers/ASTFunction.h>\n \n@@ -60,7 +61,7 @@ void WindowFrame::toString(WriteBuffer & buf) const\n     }\n     else\n     {\n-        buf << abs(begin_offset);\n+        buf << applyVisitor(FieldVisitorToString(), begin_offset);\n         buf << \" \"\n             << (begin_preceding ? \"PRECEDING\" : \"FOLLOWING\");\n     }\n@@ -77,7 +78,7 @@ void WindowFrame::toString(WriteBuffer & buf) const\n     }\n     else\n     {\n-        buf << abs(end_offset);\n+        buf << applyVisitor(FieldVisitorToString(), end_offset);\n         buf << \" \"\n             << (end_preceding ? \"PRECEDING\" : \"FOLLOWING\");\n     }\n@@ -121,23 +122,33 @@ void WindowFrame::checkValid() const\n     if (end_type == BoundaryType::Offset\n         && begin_type == BoundaryType::Offset)\n     {\n-        // Frame starting with following rows can't have preceding rows.\n-        if (!(end_preceding && !begin_preceding))\n+        // Frame start offset must be less or equal that the frame end offset.\n+        bool begin_less_equal_end;\n+        if (begin_preceding && end_preceding)\n         {\n-            // Frame start offset must be less or equal that the frame end offset.\n-            const bool begin_before_end\n-                = begin_offset * (begin_preceding ? -1 : 1)\n-                    <= end_offset * (end_preceding ? -1 : 1);\n-\n-            if (!begin_before_end)\n-            {\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Frame start offset {} {} does not precede the frame end offset {} {}\",\n-                    begin_offset, begin_preceding ? \"PRECEDING\" : \"FOLLOWING\",\n-                    end_offset, end_preceding ? \"PRECEDING\" : \"FOLLOWING\");\n-            }\n-            return;\n+            begin_less_equal_end = begin_offset >= end_offset;\n         }\n+        else if (begin_preceding && !end_preceding)\n+        {\n+            begin_less_equal_end = true;\n+        }\n+        else if (!begin_preceding && end_preceding)\n+        {\n+            begin_less_equal_end = false;\n+        }\n+        else /* if (!begin_preceding && !end_preceding) */\n+        {\n+            begin_less_equal_end = begin_offset <= end_offset;\n+        }\n+\n+        if (!begin_less_equal_end)\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Frame start offset {} {} does not precede the frame end offset {} {}\",\n+                begin_offset, begin_preceding ? \"PRECEDING\" : \"FOLLOWING\",\n+                end_offset, end_preceding ? \"PRECEDING\" : \"FOLLOWING\");\n+        }\n+        return;\n     }\n \n     throw Exception(ErrorCodes::BAD_ARGUMENTS,\ndiff --git a/src/Interpreters/WindowDescription.h b/src/Interpreters/WindowDescription.h\nindex faad4649f910..70a4e0e44e02 100644\n--- a/src/Interpreters/WindowDescription.h\n+++ b/src/Interpreters/WindowDescription.h\n@@ -44,14 +44,13 @@ struct WindowFrame\n     // Offset might be both preceding and following, controlled by begin_preceding,\n     // but the offset value must be positive.\n     BoundaryType begin_type = BoundaryType::Unbounded;\n-    // This should have been a Field but I'm getting some crazy linker errors.\n-    int64_t begin_offset = 0;\n+    Field begin_offset = 0;\n     bool begin_preceding = true;\n \n     // Here as well, Unbounded can only be UNBOUNDED FOLLOWING, and end_preceding\n     // must be false.\n     BoundaryType end_type = BoundaryType::Current;\n-    int64_t end_offset = 0;\n+    Field end_offset = 0;\n     bool end_preceding = false;\n \n \ndiff --git a/src/Parsers/ASTSelectQuery.cpp b/src/Parsers/ASTSelectQuery.cpp\nindex aa5508bf1901..4715c7f201bf 100644\n--- a/src/Parsers/ASTSelectQuery.cpp\n+++ b/src/Parsers/ASTSelectQuery.cpp\n@@ -137,8 +137,8 @@ void ASTSelectQuery::formatImpl(const FormatSettings & s, FormatState & state, F\n     if (window())\n     {\n         s.ostr << (s.hilite ? hilite_keyword : \"\") << s.nl_or_ws << indent_str <<\n-            \"WINDOW \" << (s.hilite ? hilite_none : \"\");\n-        window()->formatImpl(s, state, frame);\n+            \"WINDOW\" << (s.hilite ? hilite_none : \"\");\n+        window()->as<ASTExpressionList &>().formatImplMultiline(s, state, frame);\n     }\n \n     if (orderBy())\ndiff --git a/src/Parsers/ASTWindowDefinition.cpp b/src/Parsers/ASTWindowDefinition.cpp\nindex aee951fc1f3e..35374df61772 100644\n--- a/src/Parsers/ASTWindowDefinition.cpp\n+++ b/src/Parsers/ASTWindowDefinition.cpp\n@@ -35,6 +35,8 @@ String ASTWindowDefinition::getID(char) const\n void ASTWindowDefinition::formatImpl(const FormatSettings & settings,\n     FormatState & state, FormatStateStacked format_frame) const\n {\n+    format_frame.expression_list_prepend_whitespace = false;\n+\n     if (partition_by)\n     {\n         settings.ostr << \"PARTITION BY \";\n@@ -70,7 +72,8 @@ void ASTWindowDefinition::formatImpl(const FormatSettings & settings,\n         }\n         else\n         {\n-            settings.ostr << abs(frame.begin_offset);\n+            settings.ostr << applyVisitor(FieldVisitorToString(),\n+                frame.begin_offset);\n             settings.ostr << \" \"\n                 << (!frame.begin_preceding ? \"FOLLOWING\" : \"PRECEDING\");\n         }\n@@ -85,7 +88,8 @@ void ASTWindowDefinition::formatImpl(const FormatSettings & settings,\n         }\n         else\n         {\n-            settings.ostr << abs(frame.end_offset);\n+            settings.ostr << applyVisitor(FieldVisitorToString(),\n+                frame.end_offset);\n             settings.ostr << \" \"\n                 << (!frame.end_preceding ? \"FOLLOWING\" : \"PRECEDING\");\n         }\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex a54573432a12..913813d54866 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -581,30 +581,20 @@ static bool tryParseFrameDefinition(ASTWindowDefinition * node, IParser::Pos & p\n         else if (parser_literal.parse(pos, ast_literal, expected))\n         {\n             const Field & value = ast_literal->as<ASTLiteral &>().value;\n-            if (!isInt64FieldType(value.getType()))\n+            if ((node->frame.type == WindowFrame::FrameType::Rows\n+                    || node->frame.type == WindowFrame::FrameType::Groups)\n+                && !(value.getType() == Field::Types::UInt64\n+                     || (value.getType() == Field::Types::Int64\n+                            && value.get<Int64>() >= 0)))\n             {\n                 throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Only integer frame offsets are supported, '{}' is not supported.\",\n+                    \"Frame offset for '{}' frame must be a nonnegative integer, '{}' of type '{}' given.\",\n+                    WindowFrame::toString(node->frame.type),\n+                    applyVisitor(FieldVisitorToString(), value),\n                     Field::Types::toString(value.getType()));\n             }\n-            node->frame.begin_offset = value.get<Int64>();\n+            node->frame.begin_offset = value;\n             node->frame.begin_type = WindowFrame::BoundaryType::Offset;\n-            // We can easily get a UINT64_MAX here, which doesn't even fit into\n-            // int64_t. Not sure what checks we are going to need here after we\n-            // support floats and dates.\n-            if (node->frame.begin_offset > INT_MAX || node->frame.begin_offset < INT_MIN)\n-            {\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Frame offset must be between {} and {}, but {} is given\",\n-                    INT_MAX, INT_MIN, node->frame.begin_offset);\n-            }\n-\n-            if (node->frame.begin_offset < 0)\n-            {\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"Frame start offset must be greater than zero, {} given\",\n-                    node->frame.begin_offset);\n-            }\n         }\n         else\n         {\n@@ -652,28 +642,20 @@ static bool tryParseFrameDefinition(ASTWindowDefinition * node, IParser::Pos & p\n             else if (parser_literal.parse(pos, ast_literal, expected))\n             {\n                 const Field & value = ast_literal->as<ASTLiteral &>().value;\n-                if (!isInt64FieldType(value.getType()))\n+                if ((node->frame.type == WindowFrame::FrameType::Rows\n+                        || node->frame.type == WindowFrame::FrameType::Groups)\n+                    && !(value.getType() == Field::Types::UInt64\n+                         || (value.getType() == Field::Types::Int64\n+                                && value.get<Int64>() >= 0)))\n                 {\n                     throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                        \"Only integer frame offsets are supported, '{}' is not supported.\",\n+                        \"Frame offset for '{}' frame must be a nonnegative integer, '{}' of type '{}' given.\",\n+                        WindowFrame::toString(node->frame.type),\n+                        applyVisitor(FieldVisitorToString(), value),\n                         Field::Types::toString(value.getType()));\n                 }\n-                node->frame.end_offset = value.get<Int64>();\n+                node->frame.end_offset = value;\n                 node->frame.end_type = WindowFrame::BoundaryType::Offset;\n-\n-                if (node->frame.end_offset > INT_MAX || node->frame.end_offset < INT_MIN)\n-                {\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                        \"Frame offset must be between {} and {}, but {} is given\",\n-                        INT_MAX, INT_MIN, node->frame.end_offset);\n-                }\n-\n-                if (node->frame.end_offset < 0)\n-                {\n-                    throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                        \"Frame end offset must be greater than zero, {} given\",\n-                        node->frame.end_offset);\n-                }\n             }\n             else\n             {\ndiff --git a/src/Processors/Transforms/WindowTransform.cpp b/src/Processors/Transforms/WindowTransform.cpp\nindex 1fc51bd41126..4a5282c1e6bd 100644\n--- a/src/Processors/Transforms/WindowTransform.cpp\n+++ b/src/Processors/Transforms/WindowTransform.cpp\n@@ -3,6 +3,7 @@\n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <Common/Arena.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/getLeastSupertype.h>\n #include <Interpreters/ExpressionActions.h>\n #include <Interpreters/convertFieldToType.h>\n \n@@ -27,7 +28,8 @@ class IWindowFunction\n     virtual ~IWindowFunction() = default;\n \n     // Must insert the result for current_row.\n-    virtual void windowInsertResultInto(IColumn & to, const WindowTransform * transform) = 0;\n+    virtual void windowInsertResultInto(const WindowTransform * transform,\n+        size_t function_index) = 0;\n };\n \n // Compares ORDER BY column values at given rows to find the boundaries of frame:\n@@ -37,7 +39,7 @@ template <typename ColumnType>\n static int compareValuesWithOffset(const IColumn * _compared_column,\n     size_t compared_row, const IColumn * _reference_column,\n     size_t reference_row,\n-    uint64_t _offset,\n+    const Field & _offset,\n     bool offset_is_preceding)\n {\n     // Casting the columns to the known type here makes it faster, probably\n@@ -46,7 +48,8 @@ static int compareValuesWithOffset(const IColumn * _compared_column,\n         _compared_column);\n     const auto * reference_column = assert_cast<const ColumnType *>(\n         _reference_column);\n-    const auto offset = static_cast<typename ColumnType::ValueType>(_offset);\n+    const auto offset = _offset.get<typename ColumnType::ValueType>();\n+    assert(offset >= 0);\n \n     const auto compared_value_data = compared_column->getDataAt(compared_row);\n     assert(compared_value_data.size == sizeof(typename ColumnType::ValueType));\n@@ -101,6 +104,53 @@ static int compareValuesWithOffset(const IColumn * _compared_column,\n     }\n }\n \n+// A specialization of compareValuesWithOffset for floats.\n+template <typename ColumnType>\n+static int compareValuesWithOffsetFloat(const IColumn * _compared_column,\n+    size_t compared_row, const IColumn * _reference_column,\n+    size_t reference_row,\n+    const Field & _offset,\n+    bool offset_is_preceding)\n+{\n+    // Casting the columns to the known type here makes it faster, probably\n+    // because the getData call can be devirtualized.\n+    const auto * compared_column = assert_cast<const ColumnType *>(\n+        _compared_column);\n+    const auto * reference_column = assert_cast<const ColumnType *>(\n+        _reference_column);\n+    const auto offset = _offset.get<typename ColumnType::ValueType>();\n+    assert(offset >= 0);\n+\n+    const auto compared_value_data = compared_column->getDataAt(compared_row);\n+    assert(compared_value_data.size == sizeof(typename ColumnType::ValueType));\n+    auto compared_value = unalignedLoad<typename ColumnType::ValueType>(\n+        compared_value_data.data);\n+\n+    const auto reference_value_data = reference_column->getDataAt(reference_row);\n+    assert(reference_value_data.size == sizeof(typename ColumnType::ValueType));\n+    auto reference_value = unalignedLoad<typename ColumnType::ValueType>(\n+        reference_value_data.data);\n+\n+    // Floats overflow to Inf and the comparison will work normally, so we don't\n+    // have to do anything.\n+    if (offset_is_preceding)\n+    {\n+        reference_value -= offset;\n+    }\n+    else\n+    {\n+        reference_value += offset;\n+    }\n+\n+    const auto result =  compared_value < reference_value ? -1\n+        : compared_value == reference_value ? 0 : 1;\n+\n+//    fmt::print(stderr, \"compared {}, offset {}, reference {}, result {}\\n\",\n+//        compared_value, offset, reference_value, result);\n+\n+    return result;\n+}\n+\n // Helper macros to dispatch on type of the ORDER BY column\n #define APPLY_FOR_ONE_TYPE(FUNCTION, TYPE) \\\n else if (typeid_cast<const TYPE *>(column)) \\\n@@ -114,14 +164,20 @@ if (false) /* NOLINT */ \\\n { \\\n     /* Do nothing, a starter condition. */ \\\n } \\\n-APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int8>) \\\n APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<UInt8>) \\\n-APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int16>) \\\n APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<UInt16>) \\\n-APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int32>) \\\n APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<UInt32>) \\\n-APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int64>) \\\n APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<UInt64>) \\\n+\\\n+APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int8>) \\\n+APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int16>) \\\n+APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int32>) \\\n+APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int64>) \\\n+APPLY_FOR_ONE_TYPE(FUNCTION, ColumnVector<Int128>) \\\n+\\\n+APPLY_FOR_ONE_TYPE(FUNCTION##Float, ColumnVector<Float32>) \\\n+APPLY_FOR_ONE_TYPE(FUNCTION##Float, ColumnVector<Float64>) \\\n+\\\n else \\\n { \\\n     throw Exception(ErrorCodes::NOT_IMPLEMENTED, \\\n@@ -193,9 +249,28 @@ WindowTransform::WindowTransform(const Block & input_header_,\n                 == WindowFrame::BoundaryType::Offset))\n     {\n         assert(order_by_indices.size() == 1);\n-        const IColumn * column = input_header.getByPosition(\n-            order_by_indices[0]).column.get();\n+        const auto & entry = input_header.getByPosition(order_by_indices[0]);\n+        const IColumn * column = entry.column.get();\n         APPLY_FOR_TYPES(compareValuesWithOffset)\n+\n+        // Check that the offset type matches the window type.\n+        // Convert the offsets to the ORDER BY column type. We can't just check\n+        // that it matches, because e.g. the int literals are always (U)Int64,\n+        // but the column might be Int8 and so on.\n+        if (window_description.frame.begin_type\n+            == WindowFrame::BoundaryType::Offset)\n+        {\n+            window_description.frame.begin_offset = convertFieldToTypeOrThrow(\n+                window_description.frame.begin_offset,\n+                *entry.type);\n+        }\n+        if (window_description.frame.end_type\n+            == WindowFrame::BoundaryType::Offset)\n+        {\n+            window_description.frame.end_offset = convertFieldToTypeOrThrow(\n+                window_description.frame.end_offset,\n+                *entry.type);\n+        }\n     }\n }\n \n@@ -391,7 +466,7 @@ void WindowTransform::advanceFrameStartRowsOffset()\n {\n     // Just recalculate it each time by walking blocks.\n     const auto [moved_row, offset_left] = moveRowNumber(current_row,\n-        window_description.frame.begin_offset\n+        window_description.frame.begin_offset.get<UInt64>()\n             * (window_description.frame.begin_preceding ? -1 : 1));\n \n     frame_start = moved_row;\n@@ -638,7 +713,7 @@ void WindowTransform::advanceFrameEndRowsOffset()\n     // Walk the specified offset from the current row. The \"+1\" is needed\n     // because the frame_end is a past-the-end pointer.\n     const auto [moved_row, offset_left] = moveRowNumber(current_row,\n-        window_description.frame.end_offset\n+        window_description.frame.end_offset.get<UInt64>()\n             * (window_description.frame.end_preceding ? -1 : 1)\n             + 1);\n \n@@ -852,14 +927,14 @@ void WindowTransform::writeOutCurrentRow()\n     for (size_t wi = 0; wi < workspaces.size(); ++wi)\n     {\n         auto & ws = workspaces[wi];\n-        IColumn * result_column = block.output_columns[wi].get();\n \n         if (ws.window_function_impl)\n         {\n-            ws.window_function_impl->windowInsertResultInto(*result_column, this);\n+            ws.window_function_impl->windowInsertResultInto(this, wi);\n         }\n         else\n         {\n+            IColumn * result_column = block.output_columns[wi].get();\n             const auto * a = ws.aggregate_function.get();\n             auto * buf = ws.aggregate_function_state.data();\n             // FIXME does it also allocate the result on the arena?\n@@ -1280,8 +1355,11 @@ struct WindowFunctionRank final : public WindowFunction\n     DataTypePtr getReturnType() const override\n     { return std::make_shared<DataTypeUInt64>(); }\n \n-    void windowInsertResultInto(IColumn & to, const WindowTransform * transform) override\n+    void windowInsertResultInto(const WindowTransform * transform,\n+        size_t function_index) override\n     {\n+        IColumn & to = *transform->blockAt(transform->current_row)\n+            .output_columns[function_index];\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(\n             transform->peer_group_start_row_number);\n     }\n@@ -1297,8 +1375,11 @@ struct WindowFunctionDenseRank final : public WindowFunction\n     DataTypePtr getReturnType() const override\n     { return std::make_shared<DataTypeUInt64>(); }\n \n-    void windowInsertResultInto(IColumn & to, const WindowTransform * transform) override\n+    void windowInsertResultInto(const WindowTransform * transform,\n+        size_t function_index) override\n     {\n+        IColumn & to = *transform->blockAt(transform->current_row)\n+            .output_columns[function_index];\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(\n             transform->peer_group_number);\n     }\n@@ -1314,13 +1395,123 @@ struct WindowFunctionRowNumber final : public WindowFunction\n     DataTypePtr getReturnType() const override\n     { return std::make_shared<DataTypeUInt64>(); }\n \n-    void windowInsertResultInto(IColumn & to, const WindowTransform * transform) override\n+    void windowInsertResultInto(const WindowTransform * transform,\n+        size_t function_index) override\n     {\n+        IColumn & to = *transform->blockAt(transform->current_row)\n+            .output_columns[function_index];\n         assert_cast<ColumnUInt64 &>(to).getData().push_back(\n             transform->current_row_number);\n     }\n };\n \n+// ClickHouse-specific variant of lag/lead that respects the window frame.\n+template <bool is_lead>\n+struct WindowFunctionLagLeadInFrame final : public WindowFunction\n+{\n+    WindowFunctionLagLeadInFrame(const std::string & name_,\n+            const DataTypes & argument_types_, const Array & parameters_)\n+        : WindowFunction(name_, argument_types_, parameters_)\n+    {\n+        if (!parameters.empty())\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Function {} cannot be parameterized\", name_);\n+        }\n+\n+        if (argument_types.empty())\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Function {} takes at least one argument\", name_);\n+        }\n+\n+        if (argument_types.size() == 1)\n+        {\n+            return;\n+        }\n+\n+        if (!isInt64FieldType(argument_types[1]->getDefault().getType()))\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Offset must be an integer, '{}' given\",\n+                argument_types[1]->getName());\n+        }\n+\n+        if (argument_types.size() == 2)\n+        {\n+            return;\n+        }\n+\n+        if (!getLeastSupertype({argument_types[0], argument_types[2]}))\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"The default value type '{}' is not convertible to the argument type '{}'\",\n+                argument_types[2]->getName(),\n+                argument_types[0]->getName());\n+        }\n+\n+        if (argument_types.size() > 3)\n+        {\n+            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                \"Function '{}' accepts at most 3 arguments, {} given\",\n+                name, argument_types.size());\n+        }\n+    }\n+\n+    DataTypePtr getReturnType() const override\n+    { return argument_types[0]; }\n+\n+    void windowInsertResultInto(const WindowTransform * transform,\n+        size_t function_index) override\n+    {\n+        const auto & current_block = transform->blockAt(transform->current_row);\n+        IColumn & to = *current_block.output_columns[function_index];\n+        const auto & workspace = transform->workspaces[function_index];\n+\n+        int offset = 1;\n+        if (argument_types.size() > 1)\n+        {\n+            offset = (*current_block.input_columns[\n+                    workspace.argument_column_indices[1]])[\n+                        transform->current_row.row].get<Int64>();\n+            if (offset < 0)\n+            {\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+                    \"The offset for function {} must be nonnegative, {} given\",\n+                    getName(), offset);\n+            }\n+        }\n+\n+        const auto [target_row, offset_left] = transform->moveRowNumber(\n+            transform->current_row, offset * (is_lead ? 1 : -1));\n+\n+        if (offset_left != 0\n+            || target_row < transform->frame_start\n+            || transform->frame_end <= target_row)\n+        {\n+            // Offset is outside the frame.\n+            if (argument_types.size() > 2)\n+            {\n+                // Column with default values is specified.\n+                to.insertFrom(*current_block.input_columns[\n+                            workspace.argument_column_indices[2]],\n+                    transform->current_row.row);\n+            }\n+            else\n+            {\n+                to.insertDefault();\n+            }\n+        }\n+        else\n+        {\n+            // Offset is inside the frame.\n+            to.insertFrom(*transform->blockAt(target_row).input_columns[\n+                    workspace.argument_column_indices[0]],\n+                target_row.row);\n+        }\n+    }\n+};\n+\n void registerWindowFunctions(AggregateFunctionFactory & factory)\n {\n     // Why didn't I implement lag/lead yet? Because they are a mess. I imagine\n@@ -1332,9 +1523,10 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)\n     // the whole partition like Postgres does, because using a linear amount\n     // of additional memory is not an option when we have a lot of data. We must\n     // be able to process at least the lag/lead in streaming fashion.\n-    // Our best bet is probably rewriting, say `lag(value, offset)` to\n-    // `any(value) over (rows between offset preceding and offset preceding)`,\n-    // at the query planning stage.\n+    // A partial solution for constant offsets is rewriting, say `lag(value, offset)\n+    // to `any(value) over (rows between offset preceding and offset preceding)`.\n+    // We also implement non-standard functions `lag/leadInFrame`, that are\n+    // analogous to `lag/lead`, but respect the frame.\n     // Functions like cume_dist() do require materializing the entire\n     // partition, but it's probably also simpler to implement them by rewriting\n     // to a (rows between unbounded preceding and unbounded following) frame,\n@@ -1360,6 +1552,20 @@ void registerWindowFunctions(AggregateFunctionFactory & factory)\n             return std::make_shared<WindowFunctionRowNumber>(name, argument_types,\n                 parameters);\n         });\n+\n+    factory.registerFunction(\"lagInFrame\", [](const std::string & name,\n+            const DataTypes & argument_types, const Array & parameters)\n+        {\n+            return std::make_shared<WindowFunctionLagLeadInFrame<false>>(\n+                name, argument_types, parameters);\n+        });\n+\n+    factory.registerFunction(\"leadInFrame\", [](const std::string & name,\n+            const DataTypes & argument_types, const Array & parameters)\n+        {\n+            return std::make_shared<WindowFunctionLagLeadInFrame<true>>(\n+                name, argument_types, parameters);\n+        });\n }\n \n }\ndiff --git a/src/Processors/Transforms/WindowTransform.h b/src/Processors/Transforms/WindowTransform.h\nindex 5001b984e9a3..882bf429c0a8 100644\n--- a/src/Processors/Transforms/WindowTransform.h\n+++ b/src/Processors/Transforms/WindowTransform.h\n@@ -110,7 +110,9 @@ class WindowTransform : public IProcessor /* public ISimpleTransform */\n     Status prepare() override;\n     void work() override;\n \n-private:\n+    /*\n+     * Implementation details.\n+     */\n     void advancePartitionEnd();\n \n     bool arePeers(const RowNumber & x, const RowNumber & y) const;\n@@ -321,10 +323,7 @@ class WindowTransform : public IProcessor /* public ISimpleTransform */\n     int (* compare_values_with_offset) (\n         const IColumn * compared_column, size_t compared_row,\n         const IColumn * reference_column, size_t reference_row,\n-        // We can make it a Field later if we need the Decimals. Now we only\n-        // have ints and datetime, and the underlying Field type for them is\n-        // uint64_t anyway.\n-        uint64_t offset,\n+        const Field & offset,\n         bool offset_is_preceding);\n };\n \n",
  "test_patch": "diff --git a/docker/test/performance-comparison/perf.py b/docker/test/performance-comparison/perf.py\nindex 3ddaf99b879d..4727f4859435 100755\n--- a/docker/test/performance-comparison/perf.py\n+++ b/docker/test/performance-comparison/perf.py\n@@ -266,14 +266,13 @@ def do_create(connection, index, queries):\n \n             try:\n                 # Will also detect too long queries during warmup stage\n-                res = c.execute(q, query_id = prewarm_id, settings = {'max_execution_time': 10})\n+                res = c.execute(q, query_id = prewarm_id, settings = {'max_execution_time': args.max_query_seconds})\n             except clickhouse_driver.errors.Error as e:\n                 # Add query id to the exception to make debugging easier.\n                 e.args = (prewarm_id, *e.args)\n                 e.message = prewarm_id + ': ' + e.message\n                 raise\n \n-\n             print(f'prewarm\\t{query_index}\\t{prewarm_id}\\t{conn_index}\\t{c.last_query.elapsed}')\n         except KeyboardInterrupt:\n             raise\n@@ -320,7 +319,7 @@ def do_create(connection, index, queries):\n \n         for conn_index, c in enumerate(this_query_connections):\n             try:\n-                res = c.execute(q, query_id = run_id)\n+                res = c.execute(q, query_id = run_id, settings = {'max_execution_time': args.max_query_seconds})\n             except clickhouse_driver.errors.Error as e:\n                 # Add query id to the exception to make debugging easier.\n                 e.args = (run_id, *e.args)\ndiff --git a/tests/performance/window_functions.xml b/tests/performance/window_functions.xml\nindex 622e349d0605..6be3d59e2b0c 100644\n--- a/tests/performance/window_functions.xml\n+++ b/tests/performance/window_functions.xml\n@@ -110,4 +110,46 @@\n         format Null\n     </query>\n \n+    <!-- Our variant of lead. -->\n+    <query>\n+        select leadInFrame(number) over w\n+        from\n+            (select number, intDiv(number, 1111) p, mod(number, 111) o\n+                from numbers(10000000)) t\n+        window w as (partition by p order by o\n+            rows between unbounded preceding and unbounded following)\n+        format Null\n+    </query>\n+\n+    <!-- A faster replacement for lead with constant offset. -->\n+    <query>\n+        select any(number) over w\n+        from\n+            (select number, intDiv(number, 1111) p, mod(number, 111) o\n+                from numbers(10000000)) t\n+        window w as (partition by p order by o\n+            rows between 1 following and 1 following)\n+        format Null\n+    </query>\n+\n+    <query>\n+        select leadInFrame(number, number) over w\n+        from\n+            (select number, intDiv(number, 1111) p, mod(number, 111) o\n+                from numbers(10000000)) t\n+        window w as (partition by p order by o\n+            rows between unbounded preceding and unbounded following)\n+        format Null\n+    </query>\n+\n+    <query>\n+        select leadInFrame(number, number, number) over w\n+        from\n+            (select number, intDiv(number, 1111) p, mod(number, 111) o\n+                from numbers(10000000)) t\n+        window w as (partition by p order by o\n+            rows between unbounded preceding and unbounded following)\n+        format Null\n+    </query>\n+\n </test>\ndiff --git a/tests/queries/0_stateless/01591_window_functions.reference b/tests/queries/0_stateless/01591_window_functions.reference\nindex e31f84763265..14e5889a811c 100644\n--- a/tests/queries/0_stateless/01591_window_functions.reference\n+++ b/tests/queries/0_stateless/01591_window_functions.reference\n@@ -1002,6 +1002,32 @@ from numbers(5);\n 1\t3\n 2\t4\n 3\t\\N\n+-- variants of lag/lead that respect the frame\n+select number, p, pp,\n+    lagInFrame(number, number - pp, number * 11) over w as lag,\n+    leadInFrame(number, number - pp, number * 11) over w as lead\n+from (select number, intDiv(number, 5) p, p * 5 pp from numbers(16))\n+window w as (partition by p order by number\n+    rows between unbounded preceding and unbounded following)\n+order by number\n+settings max_block_size = 3;\n+;\n+0\t0\t0\t0\t0\n+1\t0\t0\t0\t2\n+2\t0\t0\t0\t4\n+3\t0\t0\t0\t33\n+4\t0\t0\t0\t44\n+5\t1\t5\t5\t5\n+6\t1\t5\t5\t7\n+7\t1\t5\t5\t9\n+8\t1\t5\t5\t88\n+9\t1\t5\t5\t99\n+10\t2\t10\t10\t10\n+11\t2\t10\t10\t12\n+12\t2\t10\t10\t14\n+13\t2\t10\t10\t143\n+14\t2\t10\t10\t154\n+15\t3\t15\t15\t15\n -- case-insensitive SQL-standard synonyms for any and anyLast\n select\n     number,\n@@ -1026,3 +1052,16 @@ order by number\n select count() over () from numbers(4) where number < 2;\n 2\n 2\n+-- floating point RANGE frame\n+select\n+    count(*) over (order by (toFloat32(number) as f32) range 5. preceding),\n+    count(*) over (order by (toFloat64(number) as f64) range 5. preceding)\n+from numbers(7)\n+;\n+1\t1\n+2\t2\n+3\t3\n+4\t4\n+5\t5\n+6\t6\n+6\t6\ndiff --git a/tests/queries/0_stateless/01591_window_functions.sql b/tests/queries/0_stateless/01591_window_functions.sql\nindex 7a2d25220386..30847e092465 100644\n--- a/tests/queries/0_stateless/01591_window_functions.sql\n+++ b/tests/queries/0_stateless/01591_window_functions.sql\n@@ -347,6 +347,17 @@ select\n         over (order by number rows between 1 following and 1 following)\n from numbers(5);\n \n+-- variants of lag/lead that respect the frame\n+select number, p, pp,\n+    lagInFrame(number, number - pp, number * 11) over w as lag,\n+    leadInFrame(number, number - pp, number * 11) over w as lead\n+from (select number, intDiv(number, 5) p, p * 5 pp from numbers(16))\n+window w as (partition by p order by number\n+    rows between unbounded preceding and unbounded following)\n+order by number\n+settings max_block_size = 3;\n+;\n+\n -- case-insensitive SQL-standard synonyms for any and anyLast\n select\n     number,\n@@ -360,3 +371,10 @@ order by number\n -- In this case, we had a problem with PartialSortingTransform returning zero-row\n -- chunks for input chunks w/o columns.\n select count() over () from numbers(4) where number < 2;\n+\n+-- floating point RANGE frame\n+select\n+    count(*) over (order by (toFloat32(number) as f32) range 5. preceding),\n+    count(*) over (order by (toFloat64(number) as f64) range 5. preceding)\n+from numbers(7)\n+;\n",
  "problem_statement": "Accessing previous rows (LAG/LEAD - window function style)\nAs far as I see currently there is no way to access previous rows like `lag` window function in SQL? https://www.postgresql.org/docs/11/functions-window.html\r\n\r\nStill, the function `runningAccumulate` accesses the values from the previous rows (only within a single Block??).\r\nLooks like it must be relatively easy to implement function `runningLag` the same way?\n",
  "hints_text": "```\r\nSELECT  t.1 AS k,t.2 AS v\r\nFROM(SELECT arrayJoin([('a', 1), ('a', 2), ('b', 1), ('a', 3), ('b', 2), ('b', 100)]) AS t)\r\n\r\n\u250c\u2500k\u2500\u252c\u2500\u2500\u2500v\u2500\u2510\r\n\u2502 a \u2502   1 \u2502\r\n\u2502 a \u2502   2 \u2502\r\n\u2502 b \u2502   1 \u2502\r\n\u2502 a \u2502   3 \u2502\r\n\u2502 b \u2502   2 \u2502\r\n\u2502 b \u2502 100 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT\r\n    k,\r\n    arrayDifference(groupArray(v))\r\nFROM\r\n(\r\n    SELECT\r\n        t.1 AS k,\r\n        t.2 AS v\r\n    FROM\r\n    (\r\n        SELECT arrayJoin([('a', 1), ('a', 2), ('b', 1), ('a', 3), ('b', 2), ('b', 100)]) AS t\r\n    )\r\n)\r\nGROUP BY k\r\n\r\n\u250c\u2500k\u2500\u252c\u2500arrayDifference(groupArray(v))\u2500\u2510\r\n\u2502 b \u2502 [0,1,98]                       \u2502\r\n\u2502 a \u2502 [0,1,1]                        \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\n@den-crane \r\nThanks, but this does not answer any of my questions :)\r\nOf course it is possible to `groupArray`/`arrayJoin` back and forth, but it is not always convenient and probably it will not be very efficient for a huge number of rows..\r\n\nOK. The only problem where is no function which support (windows/partition by). \r\nrunningAccumulate calculates totalSum without resetting on a next group.\r\n\r\nif need this then your runningLag is equal runningDifference\r\n\r\nSELECT k, runningDifference(v) \r\nFROM (SELECT intDiv(number, 2) AS k, number v FROM numbers(10) ORDER BY k,v);\n@den-crane  Thanks for the explanation, this makes total sense.\r\nSo, if I have a table with web page visits like `visits(visitor, date)` and want to know how many total unique users and new unique users came each date then it should look like the following?\r\n```sql\r\nselect date, total_uniq_visitors, runningDifferenceStartingWithFirstValue(total_uniq_visitors) this_date_uniq_visitors\r\nfrom (\r\nselect date, runningAccumulate(u) total_uniq_visitors\r\nfrom (\r\nselect date, uniqState(visitor) u from visits \r\ngroup by date\r\norder by date\r\n))\r\n```\r\n\nPlease follow also main window function related issue #1469\r\nThere are also several workarounds listed there\nI am hitting an issue using runningDifference that may be me misunderstanding how the function is applied, but here is an example riffing on the example from @den-crane . \r\n\r\nHere I difference, but there is a jump as the key k changes from 'a' to 'b'. \r\n\r\n```\r\nSELECT\r\n    t.1 AS k,\r\n    t.2 AS v,\r\n    runningDifference(v) AS d,\r\n    runningDifference(xxHash32(t.1)) AS i\r\nFROM\r\n(\r\n    SELECT arrayJoin([('a', 1), ('a', 2), ('a', 3), ('b', 11), ('b', 13), ('b', 15)]) AS t\r\n)\r\n\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500d\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502 0 \u2502          0 \u2502\r\n\u2502 a \u2502  2 \u2502 1 \u2502          0 \u2502\r\n\u2502 a \u2502  3 \u2502 1 \u2502          0 \u2502\r\n\u2502 b \u2502 11 \u2502 8 \u2502 1291794793 \u2502\r\n\u2502 b \u2502 13 \u2502 2 \u2502          0 \u2502\r\n\u2502 b \u2502 15 \u2502 2 \u2502          0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nSo I inserted the hash value of the key thinking I could filter to the cases where the hash was equal to zero. But that doesn't work as it seems the runningDifference is lazily evaluated:\r\n\r\n```\r\nSELECT\r\n    k,\r\n    v,\r\n    d,\r\n    i\r\nFROM\r\n(\r\n    SELECT\r\n        t.1 AS k,\r\n        t.2 AS v,\r\n        runningDifference(v) AS d,\r\n        runningDifference(xxHash32(t.1)) AS i\r\n    FROM\r\n    (\r\n        SELECT arrayJoin([('a', 1), ('a', 2), ('a', 3), ('b', 11), ('b', 13), ('b', 15)]) AS t\r\n    )\r\n)\r\nWHERE i = 0\r\n\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500\u2500d\u2500\u252c\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502  0 \u2502 0 \u2502\r\n\u2502 a \u2502  2 \u2502  1 \u2502 0 \u2502\r\n\u2502 a \u2502  3 \u2502  1 \u2502 0 \u2502\r\n\u2502 b \u2502 13 \u2502 10 \u2502 0 \u2502\r\n\u2502 b \u2502 15 \u2502  2 \u2502 0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n\r\nI was expecting the fourth row to have a value of 2 for v.  Is this a bug or expected?\r\n\n@vincenzon enable_optimize_predicate_expression bug\r\n\r\n19.4.3.11\r\n```\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500d\u2500\u252c\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502 0 \u2502 0 \u2502\r\n\u2502 a \u2502  2 \u2502 1 \u2502 0 \u2502\r\n\u2502 a \u2502  3 \u2502 1 \u2502 0 \u2502\r\n\u2502 b \u2502 13 \u2502 2 \u2502 0 \u2502\r\n\u2502 b \u2502 15 \u2502 2 \u2502 0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n19.10.1.669\r\n```\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500\u2500d\u2500\u252c\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502  0 \u2502 0 \u2502\r\n\u2502 a \u2502  2 \u2502  1 \u2502 0 \u2502\r\n\u2502 a \u2502  3 \u2502  1 \u2502 0 \u2502\r\n\u2502 b \u2502 13 \u2502 10 \u2502 0 \u2502\r\n\u2502 b \u2502 15 \u2502  2 \u2502 0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\nSET enable_optimize_predicate_expression = 0\r\n\u250c\u2500k\u2500\u252c\u2500\u2500v\u2500\u252c\u2500d\u2500\u252c\u2500i\u2500\u2510\r\n\u2502 a \u2502  1 \u2502 0 \u2502 0 \u2502\r\n\u2502 a \u2502  2 \u2502 1 \u2502 0 \u2502\r\n\u2502 a \u2502  3 \u2502 1 \u2502 0 \u2502\r\n\u2502 b \u2502 13 \u2502 2 \u2502 0 \u2502\r\n\u2502 b \u2502 15 \u2502 2 \u2502 0 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2518\r\n```\r\n\r\nhttps://github.com/yandex/ClickHouse/issues/3885\r\n\nThanks @den-crane.\n@den-crane  @vincenzon \r\nI want to subtract the values specified in the array\uff0c\r\nI want to find the value of 1-2 and 1-3\uff0c \r\n\u250c\u2500k\u2500v---\r\n\u2502 a \u2502  1 \u2502 \r\n\u2502 a \u2502  2 \u2502\r\n\u2502 a \u2502  3 \u2502 \r\n\n[neighbor](https://clickhouse.tech/docs/en/query_language/functions/other_functions/#neighbor\r\n) function introduced in #5925 is avaliable since 19.14 address that issue.\r\n\r\nBut it works currently inside each block separately:\r\n\r\n```\r\nSELECT \r\n    number, \r\n    neighbor(toNullable(number), 1)\r\nFROM numbers(12)\r\nORDER BY number ASC\r\nSETTINGS max_block_size = 4\r\nFORMAT PrettyCompactMonoBlock\r\n\r\n\u250c\u2500number\u2500\u252c\u2500neighbor(toNullable(number), 1)\u2500\u2510\r\n\u2502      0 \u2502                               1 \u2502\r\n\u2502      1 \u2502                               2 \u2502\r\n\u2502      2 \u2502                               3 \u2502\r\n\u2502      3 \u2502                            \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2502      4 \u2502                               5 \u2502\r\n\u2502      5 \u2502                               6 \u2502\r\n\u2502      6 \u2502                               7 \u2502\r\n\u2502      7 \u2502                            \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2502      8 \u2502                               9 \u2502\r\n\u2502      9 \u2502                              10 \u2502\r\n\u2502     10 \u2502                              11 \u2502\r\n\u2502     11 \u2502                            \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n12 rows in set. Elapsed: 0.006 sec. \r\n```\r\n\n> [neighbor](https://clickhouse.tech/docs/en/query_language/functions/other_functions/#neighbor) function introduced in #5925 is avaliable since 19.14 address that issue.\r\n> \r\n> But it works currently inside each block separately:\r\n> \r\n> ```\r\n> SELECT \r\n>     number, \r\n>     neighbor(toNullable(number), 1)\r\n> FROM numbers(12)\r\n> ORDER BY number ASC\r\n> SETTINGS max_block_size = 4\r\n> FORMAT PrettyCompactMonoBlock\r\n> \r\n> \u250c\u2500number\u2500\u252c\u2500neighbor(toNullable(number), 1)\u2500\u2510\r\n> \u2502      0 \u2502                               1 \u2502\r\n> \u2502      1 \u2502                               2 \u2502\r\n> \u2502      2 \u2502                               3 \u2502\r\n> \u2502      3 \u2502                            \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n> \u2502      4 \u2502                               5 \u2502\r\n> \u2502      5 \u2502                               6 \u2502\r\n> \u2502      6 \u2502                               7 \u2502\r\n> \u2502      7 \u2502                            \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n> \u2502      8 \u2502                               9 \u2502\r\n> \u2502      9 \u2502                              10 \u2502\r\n> \u2502     10 \u2502                              11 \u2502\r\n> \u2502     11 \u2502                            \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n> \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n> \r\n> 12 rows in set. Elapsed: 0.006 sec. \r\n> ```\r\n\r\nSELECT \r\n    a, \r\n    neighbor(toNullable(a), 1)\r\nFROM \r\n(\r\n    SELECT \r\n        arrayJoin([1, 2, 3]) AS a, \r\n        'u' AS b\r\n)\r\n\r\n\u250c\u2500a\u2500\u252c\u2500neighbor(toNullable(a), 1)\u2500\u2510\r\n\u2502 1 \u2502                          2 \u2502\r\n\u2502 2 \u2502                          3 \u2502\r\n\u2502 3 \u2502                       \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n**The result I want is**   \r\nselect  1 - 2 ;   result -1\r\nselect  1 - 3 ;   result -2\r\n\r\nThe final display is as follows  . How to implement\uff1f\uff1f\uff1f\r\n\r\n\u250c\u2500a\u2500\u252c\u2500neighbor(toNullable(a), 1)\u2500\u2510\r\n\u2502 1 \u2502                          -1\u2502\r\n\u2502 2 \u2502                          -2 \u2502\r\n\u2502 3 \u2502                       \u1d3a\u1d41\u1d38\u1d38 \u2502\r\n\u2514\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\nwhen the window function will be supported in Clickhouse?\r\nI hope to see the function early!",
  "created_at": "2021-03-18T23:08:32Z"
}