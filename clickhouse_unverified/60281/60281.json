{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60281,
  "instance_id": "ClickHouse__ClickHouse-60281",
  "issue_numbers": [
    "54746"
  ],
  "base_commit": "fb7924cdb18eccfb7aff18b32b7206710dfa6391",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex c5b3b4cc3aec..83a3bd77cdbb 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -394,8 +394,7 @@ Result:\n \n ## toYear\n \n-Converts a date or date with time to the year number (AD) as `UInt16` value.\n-\n+Returns the year component (AD) of a date or date with time.\n \n **Syntax**\n \n@@ -431,7 +430,7 @@ Result:\n \n ## toQuarter\n \n-Converts a date or date with time to the quarter number (1-4) as `UInt8` value.\n+Returns the quarter (1-4) of a date or date with time.\n \n **Syntax**\n \n@@ -465,10 +464,9 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n-\n ## toMonth\n \n-Converts a date or date with time to the month number (1-12) as `UInt8` value.\n+Returns the month component (1-12) of a date or date with time.\n \n **Syntax**\n \n@@ -504,7 +502,7 @@ Result:\n \n ## toDayOfYear\n \n-Converts a date or date with time to the number of the day of the year (1-366) as `UInt16` value.\n+Returns the number of the day within the year (1-366) of a date or date with time.\n \n **Syntax**\n \n@@ -540,7 +538,7 @@ Result:\n \n ## toDayOfMonth\n \n-Converts a date or date with time to the number of the day in the month (1-31) as `UInt8` value.\n+Returns the number of the day within the month (1-31) of a date or date with time.\n \n **Syntax**\n \n@@ -576,7 +574,7 @@ Result:\n \n ## toDayOfWeek\n \n-Converts a date or date with time to the number of the day in the week as `UInt8` value.\n+Returns the number of the day within the week of a date or date with time.\n \n The two-argument form of `toDayOfWeek()` enables you to specify whether the week starts on Monday or Sunday, and whether the return value should be in the range from 0 to 6 or 1 to 7. If the mode argument is omitted, the default mode is 0. The time zone of the date can be specified as the third argument.\n \n@@ -627,7 +625,7 @@ Result:\n \n ## toHour\n \n-Converts a date with time to the number of the hour in 24-hour time (0-23) as `UInt8` value.\n+Returns the hour component (0-24) of a date with time.\n \n Assumes that if clocks are moved ahead, it is by one hour and occurs at 2 a.m., and if clocks are moved back, it is by one hour and occurs at 3 a.m. (which is not always exactly when it occurs - it depends on the timezone).\n \n@@ -641,7 +639,7 @@ Alias: `HOUR`\n \n **Arguments**\n \n-- `value` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n \n **Returned value**\n \n@@ -665,7 +663,7 @@ Result:\n \n ## toMinute\n \n-Converts a date with time to the number of the minute of the hour (0-59) as `UInt8` value.\n+Returns the minute component (0-59) a date with time.\n \n **Syntax**\n \n@@ -677,7 +675,7 @@ Alias: `MINUTE`\n \n **Arguments**\n \n-- `value` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n \n **Returned value**\n \n@@ -701,7 +699,7 @@ Result:\n \n ## toSecond\n \n-Converts a date with time to the second in the minute (0-59) as `UInt8` value. Leap seconds are not considered.\n+Returns the second component (0-59) of a date with time. Leap seconds are not considered.\n \n **Syntax**\n \n@@ -713,7 +711,7 @@ Alias: `SECOND`\n \n **Arguments**\n \n-- `value` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+- `value` - a [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n \n **Returned value**\n \n@@ -735,6 +733,40 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## toMillisecond\n+\n+Returns the millisecond component (0-999) of a date with time.\n+\n+**Syntax**\n+\n+```sql\n+toMillisecond(value)\n+```\n+\n+*Arguments**\n+\n+- `value` - [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)\n+\n+Alias: `MILLISECOND`\n+\n+```sql\n+SELECT toMillisecond(toDateTime64('2023-04-21 10:20:30.456', 3))\n+```\n+\n+Result:\n+\n+```response\n+\u250c\u2500\u2500toMillisecond(toDateTime64('2023-04-21 10:20:30.456', 3))\u2500\u2510\n+\u2502                                                        456 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Returned value**\n+\n+- The millisecond in the minute (0 - 59) of the given date/time\n+\n+Type: `UInt16`\n+\n ## toUnixTimestamp\n \n Converts a string, a date or a date with time to the [Unix Timestamp](https://en.wikipedia.org/wiki/Unix_time) in `UInt32` representation.\ndiff --git a/src/Common/DateLUTImpl.h b/src/Common/DateLUTImpl.h\nindex 0e72b489acee..7bf66c0504a1 100644\n--- a/src/Common/DateLUTImpl.h\n+++ b/src/Common/DateLUTImpl.h\n@@ -3,13 +3,13 @@\n #include <base/DayNum.h>\n #include <base/defines.h>\n #include <base/types.h>\n+#include <Core/DecimalFunctions.h>\n \n #include <ctime>\n #include <cassert>\n #include <string>\n #include <type_traits>\n \n-\n #define DATE_SECONDS_PER_DAY 86400 /// Number of seconds in a day, 60 * 60 * 24\n \n #define DATE_LUT_MIN_YEAR 1900 /// 1900 since majority of financial organizations consider 1900 as an initial year.\n@@ -280,9 +280,9 @@ class DateLUTImpl\n         static_assert(std::is_integral_v<DateOrTime> && std::is_integral_v<Divisor>);\n         assert(divisor > 0);\n \n-        if (likely(offset_is_whole_number_of_hours_during_epoch))\n+        if (offset_is_whole_number_of_hours_during_epoch) [[likely]]\n         {\n-            if (likely(x >= 0))\n+            if (x >= 0) [[likely]]\n                 return static_cast<DateOrTime>(x / divisor * divisor);\n \n             /// Integer division for negative numbers rounds them towards zero (up).\n@@ -576,10 +576,10 @@ class DateLUTImpl\n \n     unsigned toSecond(Time t) const\n     {\n-        if (likely(offset_is_whole_number_of_minutes_during_epoch))\n+        if (offset_is_whole_number_of_minutes_during_epoch) [[likely]]\n         {\n             Time res = t % 60;\n-            if (likely(res >= 0))\n+            if (res >= 0) [[likely]]\n                 return static_cast<unsigned>(res);\n             return static_cast<unsigned>(res) + 60;\n         }\n@@ -593,6 +593,30 @@ class DateLUTImpl\n         return time % 60;\n     }\n \n+    template <typename DateOrTime>\n+    unsigned toMillisecond(const DateOrTime & datetime, Int64 scale_multiplier) const\n+    {\n+        constexpr Int64 millisecond_multiplier = 1'000;\n+        constexpr Int64 microsecond_multiplier = 1'000 * millisecond_multiplier;\n+        constexpr Int64 divider = microsecond_multiplier / millisecond_multiplier;\n+\n+        auto components = DB::DecimalUtils::splitWithScaleMultiplier(datetime, scale_multiplier);\n+\n+        if (datetime.value < 0 && components.fractional)\n+        {\n+            components.fractional = scale_multiplier + (components.whole ? Int64(-1) : Int64(1)) * components.fractional;\n+            --components.whole;\n+        }\n+        Int64 fractional = components.fractional;\n+        if (scale_multiplier > microsecond_multiplier)\n+            fractional = fractional / (scale_multiplier / microsecond_multiplier);\n+        else if (scale_multiplier < microsecond_multiplier)\n+            fractional = fractional * (microsecond_multiplier / scale_multiplier);\n+\n+        UInt16 millisecond = static_cast<UInt16>(fractional / divider);\n+        return millisecond;\n+    }\n+\n     unsigned toMinute(Time t) const\n     {\n         if (t >= 0 && offset_is_whole_number_of_hours_during_epoch)\n@@ -1122,9 +1146,9 @@ class DateLUTImpl\n     DateOrTime toStartOfMinuteInterval(DateOrTime t, UInt64 minutes) const\n     {\n         Int64 divisor = 60 * minutes;\n-        if (likely(offset_is_whole_number_of_minutes_during_epoch))\n+        if (offset_is_whole_number_of_minutes_during_epoch) [[likely]]\n         {\n-            if (likely(t >= 0))\n+            if (t >= 0) [[likely]]\n                 return static_cast<DateOrTime>(t / divisor * divisor);\n             return static_cast<DateOrTime>((t + 1 - divisor) / divisor * divisor);\n         }\n@@ -1339,7 +1363,7 @@ class DateLUTImpl\n \n     UInt8 saturateDayOfMonth(Int16 year, UInt8 month, UInt8 day_of_month) const\n     {\n-        if (likely(day_of_month <= 28))\n+        if (day_of_month <= 28) [[likely]]\n             return day_of_month;\n \n         UInt8 days_in_month = daysInMonth(year, month);\ndiff --git a/src/Functions/DateTimeTransforms.cpp b/src/Functions/DateTimeTransforms.cpp\nindex 7ec13be9d6d0..006d1e94ccdc 100644\n--- a/src/Functions/DateTimeTransforms.cpp\n+++ b/src/Functions/DateTimeTransforms.cpp\n@@ -10,16 +10,17 @@ namespace ErrorCodes\n \n void throwDateIsNotSupported(const char * name)\n {\n-    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type Date of argument for function {}\", name);\n+    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal argument of type Date for function {}\", name);\n }\n \n-void throwDateTimeIsNotSupported(const char * name)\n+void throwDate32IsNotSupported(const char * name)\n {\n-    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type DateTime of argument for function {}\", name);\n+    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal argument of type Date32 for function {}\", name);\n }\n \n-void throwDate32IsNotSupported(const char * name)\n+void throwDateTimeIsNotSupported(const char * name)\n {\n-    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal type Date32 of argument for function {}\", name);\n+    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Illegal argument of type DateTime for function {}\", name);\n }\n+\n }\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex 5467cf770851..96705a10f151 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -6,6 +6,7 @@\n #include <Common/DateLUTImpl.h>\n #include <Common/DateLUT.h>\n #include <Common/IntervalKind.h>\n+#include \"base/Decimal.h\"\n #include <Columns/ColumnNullable.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnVector.h>\n@@ -54,8 +55,8 @@ constexpr time_t MAX_DATE_TIMESTAMP = 5662310399;       // 2149-06-06 23:59:59 U\n constexpr time_t MAX_DATETIME_DAY_NUM =  49710;               // 2106-02-07\n \n [[noreturn]] void throwDateIsNotSupported(const char * name);\n-[[noreturn]] void throwDateTimeIsNotSupported(const char * name);\n [[noreturn]] void throwDate32IsNotSupported(const char * name);\n+[[noreturn]] void throwDateTimeIsNotSupported(const char * name);\n \n /// This factor transformation will say that the function is monotone everywhere.\n struct ZeroTransform\n@@ -481,7 +482,7 @@ struct ToStartOfInterval<IntervalKind::Nanosecond>\n     }\n     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)\n     {\n-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);\n+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n     static UInt32 execute(UInt32, Int64, const DateLUTImpl &, Int64)\n     {\n@@ -516,7 +517,7 @@ struct ToStartOfInterval<IntervalKind::Microsecond>\n     }\n     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)\n     {\n-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);\n+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n     static UInt32 execute(UInt32, Int64, const DateLUTImpl &, Int64)\n     {\n@@ -559,7 +560,7 @@ struct ToStartOfInterval<IntervalKind::Millisecond>\n     }\n     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)\n     {\n-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);\n+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n     static UInt32 execute(UInt32, Int64, const DateLUTImpl &, Int64)\n     {\n@@ -602,7 +603,7 @@ struct ToStartOfInterval<IntervalKind::Second>\n     }\n     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)\n     {\n-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);\n+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n     static UInt32 execute(UInt32 t, Int64 seconds, const DateLUTImpl & time_zone, Int64)\n     {\n@@ -623,7 +624,7 @@ struct ToStartOfInterval<IntervalKind::Minute>\n     }\n     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)\n     {\n-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);\n+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n     static UInt32 execute(UInt32 t, Int64 minutes, const DateLUTImpl & time_zone, Int64)\n     {\n@@ -644,7 +645,7 @@ struct ToStartOfInterval<IntervalKind::Hour>\n     }\n     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)\n     {\n-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);\n+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);\n     }\n     static UInt32 execute(UInt32 t, Int64 hours, const DateLUTImpl & time_zone, Int64)\n     {\n@@ -777,7 +778,7 @@ struct ToTimeImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -802,7 +803,7 @@ struct ToStartOfMinuteImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -849,7 +850,7 @@ struct ToStartOfSecondImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -897,7 +898,7 @@ struct ToStartOfMillisecondImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -941,7 +942,7 @@ struct ToStartOfMicrosecondImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -979,7 +980,7 @@ struct ToStartOfNanosecondImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1004,7 +1005,7 @@ struct ToStartOfFiveMinutesImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1036,7 +1037,7 @@ struct ToStartOfTenMinutesImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1068,7 +1069,7 @@ struct ToStartOfFifteenMinutesImpl\n     }\n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt32 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1103,7 +1104,7 @@ struct TimeSlotImpl\n \n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n \n     static UInt32 execute(UInt16, const DateLUTImpl &)\n@@ -1142,7 +1143,7 @@ struct ToStartOfHourImpl\n \n     static UInt32 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n \n     static UInt32 execute(UInt16, const DateLUTImpl &)\n@@ -1429,7 +1430,7 @@ struct ToHourImpl\n     }\n     static UInt8 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt8 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1456,7 +1457,7 @@ struct TimezoneOffsetImpl\n \n     static time_t execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n \n     static time_t execute(UInt16, const DateLUTImpl &)\n@@ -1482,7 +1483,7 @@ struct ToMinuteImpl\n     }\n     static UInt8 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt8 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1507,7 +1508,7 @@ struct ToSecondImpl\n     }\n     static UInt8 execute(Int32, const DateLUTImpl &)\n     {\n-        throwDateIsNotSupported(name);\n+        throwDate32IsNotSupported(name);\n     }\n     static UInt8 execute(UInt16, const DateLUTImpl &)\n     {\n@@ -1518,6 +1519,32 @@ struct ToSecondImpl\n     using FactorTransform = ToStartOfMinuteImpl;\n };\n \n+struct ToMillisecondImpl\n+{\n+    static constexpr auto name = \"toMillisecond\";\n+\n+    static UInt16 execute(const DateTime64 & datetime64, Int64 scale_multiplier, const DateLUTImpl & time_zone)\n+    {\n+        return time_zone.toMillisecond<DateTime64>(datetime64, scale_multiplier);\n+    }\n+\n+    static UInt16 execute(UInt32, const DateLUTImpl &)\n+    {\n+        return 0;\n+    }\n+    static UInt16 execute(Int32, const DateLUTImpl &)\n+    {\n+        throwDate32IsNotSupported(name);\n+    }\n+    static UInt16 execute(UInt16, const DateLUTImpl &)\n+    {\n+        throwDateIsNotSupported(name);\n+    }\n+    static constexpr bool hasPreimage() { return false; }\n+\n+    using FactorTransform = ZeroTransform;\n+};\n+\n struct ToISOYearImpl\n {\n     static constexpr auto name = \"toISOYear\";\ndiff --git a/src/Functions/toMillisecond.cpp b/src/Functions/toMillisecond.cpp\nnew file mode 100644\nindex 000000000000..e15b56cc5559\n--- /dev/null\n+++ b/src/Functions/toMillisecond.cpp\n@@ -0,0 +1,18 @@\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/DateTimeTransforms.h>\n+#include <Functions/FunctionDateOrDateTimeToSomething.h>\n+\n+namespace DB\n+{\n+\n+using FunctionToMillisecond = FunctionDateOrDateTimeToSomething<DataTypeUInt16, ToMillisecondImpl>;\n+\n+REGISTER_FUNCTION(ToMillisecond)\n+{\n+    factory.registerFunction<FunctionToMillisecond>();\n+\n+    /// MySQL compatibility alias.\n+    factory.registerAlias(\"MILLISECOND\", \"toMillisecond\", FunctionFactory::CaseInsensitive);\n+}\n+\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex f2e5a744a211..bc6b25da6035 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -2530,6 +2530,7 @@ toRelativeSecondNum\n toRelativeWeekNum\n toRelativeYearNum\n toSecond\n+toMillisecond\n toStartOfDay\n toStartOfFifteenMinutes\n toStartOfFiveMinutes\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02998_to_milliseconds.reference b/tests/queries/0_stateless/02998_to_milliseconds.reference\nnew file mode 100644\nindex 000000000000..05139c19d1d1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02998_to_milliseconds.reference\n@@ -0,0 +1,8 @@\n+2023-04-21 10:20:30\t0\t0\n+2023-04-21 10:20:30\t0\t0\n+2023-04-21 10:20:30.123\t123\t123\n+2023-04-21 10:20:30.123456\t123\t123\n+2023-04-21 10:20:30.123456789\t123\t123\n+120\n+2023-04-21 10:20:30\t0\n+2023-04-21 10:20:30\t0\ndiff --git a/tests/queries/0_stateless/02998_to_milliseconds.sql b/tests/queries/0_stateless/02998_to_milliseconds.sql\nnew file mode 100644\nindex 000000000000..f159f6aab503\n--- /dev/null\n+++ b/tests/queries/0_stateless/02998_to_milliseconds.sql\n@@ -0,0 +1,17 @@\n+-- Negative tests\n+SELECT toMillisecond(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT toMillisecond('string'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toMillisecond(toDate('2024-02-28')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT toMillisecond(toDate32('2024-02-28')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+-- Tests with constant and non-constant arguments\n+SELECT toDateTime('2023-04-21 10:20:30') AS dt, toMillisecond(dt), toMillisecond(materialize(dt));\n+SELECT toDateTime64('2023-04-21 10:20:30', 0) AS dt64, toMillisecond(dt64), toMillisecond(materialize(dt64));\n+SELECT toDateTime64('2023-04-21 10:20:30.123', 3) AS dt64, toMillisecond(dt64), toMillisecond(materialize(dt64));\n+SELECT toDateTime64('2023-04-21 10:20:30.123456', 6) AS dt64, toMillisecond(dt64), toMillisecond(materialize(dt64));\n+SELECT toDateTime64('2023-04-21 10:20:30.123456789', 9) AS dt64, toMillisecond(dt64), toMillisecond(materialize(dt64));\n+\n+-- Special cases\n+SELECT MILLISECOND(toDateTime64('2023-04-21 10:20:30.123456', 2)); -- Alias\n+SELECT toNullable(toDateTime('2023-04-21 10:20:30')) AS dt, toMillisecond(dt); -- Nullable\n+SELECT toLowCardinality(toDateTime('2023-04-21 10:20:30')) AS dt, toMillisecond(dt); -- LowCardinality\n",
  "problem_statement": "Implement toMillisecond()\nImplement a function `toMillisecond()`, similar to existing function `toSecond()` ([docs](https://clickhouse.com/docs/en/sql-reference/functions/date-time-functions#tosecond)).\n",
  "hints_text": "I can't assign it to myself for some reason\n@rschu1ze looks like PRs were closed for some reason? If this issue still needs work then you can assign it to me. Unless @shabroo is still busy with this one?\n@Blargian The author of #55567 and #55569 decided to close the PRs.\r\n\r\nIt would be really nice if you would take a stab at this issue (I have assigned you). Feel free to set me as assignee (aka. reviewer) once you pushed a PR. Thanks!",
  "created_at": "2024-02-22T11:36:34Z"
}