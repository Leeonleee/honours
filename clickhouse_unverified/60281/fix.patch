diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index c5b3b4cc3aec..83a3bd77cdbb 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -394,8 +394,7 @@ Result:
 
 ## toYear
 
-Converts a date or date with time to the year number (AD) as `UInt16` value.
-
+Returns the year component (AD) of a date or date with time.
 
 **Syntax**
 
@@ -431,7 +430,7 @@ Result:
 
 ## toQuarter
 
-Converts a date or date with time to the quarter number (1-4) as `UInt8` value.
+Returns the quarter (1-4) of a date or date with time.
 
 **Syntax**
 
@@ -465,10 +464,9 @@ Result:
 └──────────────────────────────────────────────┘
 ```
 
-
 ## toMonth
 
-Converts a date or date with time to the month number (1-12) as `UInt8` value.
+Returns the month component (1-12) of a date or date with time.
 
 **Syntax**
 
@@ -504,7 +502,7 @@ Result:
 
 ## toDayOfYear
 
-Converts a date or date with time to the number of the day of the year (1-366) as `UInt16` value.
+Returns the number of the day within the year (1-366) of a date or date with time.
 
 **Syntax**
 
@@ -540,7 +538,7 @@ Result:
 
 ## toDayOfMonth
 
-Converts a date or date with time to the number of the day in the month (1-31) as `UInt8` value.
+Returns the number of the day within the month (1-31) of a date or date with time.
 
 **Syntax**
 
@@ -576,7 +574,7 @@ Result:
 
 ## toDayOfWeek
 
-Converts a date or date with time to the number of the day in the week as `UInt8` value.
+Returns the number of the day within the week of a date or date with time.
 
 The two-argument form of `toDayOfWeek()` enables you to specify whether the week starts on Monday or Sunday, and whether the return value should be in the range from 0 to 6 or 1 to 7. If the mode argument is omitted, the default mode is 0. The time zone of the date can be specified as the third argument.
 
@@ -627,7 +625,7 @@ Result:
 
 ## toHour
 
-Converts a date with time to the number of the hour in 24-hour time (0-23) as `UInt8` value.
+Returns the hour component (0-24) of a date with time.
 
 Assumes that if clocks are moved ahead, it is by one hour and occurs at 2 a.m., and if clocks are moved back, it is by one hour and occurs at 3 a.m. (which is not always exactly when it occurs - it depends on the timezone).
 
@@ -641,7 +639,7 @@ Alias: `HOUR`
 
 **Arguments**
 
-- `value` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
+- `value` - a [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
 
 **Returned value**
 
@@ -665,7 +663,7 @@ Result:
 
 ## toMinute
 
-Converts a date with time to the number of the minute of the hour (0-59) as `UInt8` value.
+Returns the minute component (0-59) a date with time.
 
 **Syntax**
 
@@ -677,7 +675,7 @@ Alias: `MINUTE`
 
 **Arguments**
 
-- `value` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
+- `value` - a [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
 
 **Returned value**
 
@@ -701,7 +699,7 @@ Result:
 
 ## toSecond
 
-Converts a date with time to the second in the minute (0-59) as `UInt8` value. Leap seconds are not considered.
+Returns the second component (0-59) of a date with time. Leap seconds are not considered.
 
 **Syntax**
 
@@ -713,7 +711,7 @@ Alias: `SECOND`
 
 **Arguments**
 
-- `value` - a [Date](../data-types/date.md), [Date32](../data-types/date32.md), [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
+- `value` - a [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
 
 **Returned value**
 
@@ -735,6 +733,40 @@ Result:
 └─────────────────────────────────────────────┘
 ```
 
+## toMillisecond
+
+Returns the millisecond component (0-999) of a date with time.
+
+**Syntax**
+
+```sql
+toMillisecond(value)
+```
+
+*Arguments**
+
+- `value` - [DateTime](../data-types/datetime.md) or [DateTime64](../data-types/datetime64.md)
+
+Alias: `MILLISECOND`
+
+```sql
+SELECT toMillisecond(toDateTime64('2023-04-21 10:20:30.456', 3))
+```
+
+Result:
+
+```response
+┌──toMillisecond(toDateTime64('2023-04-21 10:20:30.456', 3))─┐
+│                                                        456 │
+└────────────────────────────────────────────────────────────┘
+```
+
+**Returned value**
+
+- The millisecond in the minute (0 - 59) of the given date/time
+
+Type: `UInt16`
+
 ## toUnixTimestamp
 
 Converts a string, a date or a date with time to the [Unix Timestamp](https://en.wikipedia.org/wiki/Unix_time) in `UInt32` representation.
diff --git a/src/Common/DateLUTImpl.h b/src/Common/DateLUTImpl.h
index 0e72b489acee..7bf66c0504a1 100644
--- a/src/Common/DateLUTImpl.h
+++ b/src/Common/DateLUTImpl.h
@@ -3,13 +3,13 @@
 #include <base/DayNum.h>
 #include <base/defines.h>
 #include <base/types.h>
+#include <Core/DecimalFunctions.h>
 
 #include <ctime>
 #include <cassert>
 #include <string>
 #include <type_traits>
 
-
 #define DATE_SECONDS_PER_DAY 86400 /// Number of seconds in a day, 60 * 60 * 24
 
 #define DATE_LUT_MIN_YEAR 1900 /// 1900 since majority of financial organizations consider 1900 as an initial year.
@@ -280,9 +280,9 @@ class DateLUTImpl
         static_assert(std::is_integral_v<DateOrTime> && std::is_integral_v<Divisor>);
         assert(divisor > 0);
 
-        if (likely(offset_is_whole_number_of_hours_during_epoch))
+        if (offset_is_whole_number_of_hours_during_epoch) [[likely]]
         {
-            if (likely(x >= 0))
+            if (x >= 0) [[likely]]
                 return static_cast<DateOrTime>(x / divisor * divisor);
 
             /// Integer division for negative numbers rounds them towards zero (up).
@@ -576,10 +576,10 @@ class DateLUTImpl
 
     unsigned toSecond(Time t) const
     {
-        if (likely(offset_is_whole_number_of_minutes_during_epoch))
+        if (offset_is_whole_number_of_minutes_during_epoch) [[likely]]
         {
             Time res = t % 60;
-            if (likely(res >= 0))
+            if (res >= 0) [[likely]]
                 return static_cast<unsigned>(res);
             return static_cast<unsigned>(res) + 60;
         }
@@ -593,6 +593,30 @@ class DateLUTImpl
         return time % 60;
     }
 
+    template <typename DateOrTime>
+    unsigned toMillisecond(const DateOrTime & datetime, Int64 scale_multiplier) const
+    {
+        constexpr Int64 millisecond_multiplier = 1'000;
+        constexpr Int64 microsecond_multiplier = 1'000 * millisecond_multiplier;
+        constexpr Int64 divider = microsecond_multiplier / millisecond_multiplier;
+
+        auto components = DB::DecimalUtils::splitWithScaleMultiplier(datetime, scale_multiplier);
+
+        if (datetime.value < 0 && components.fractional)
+        {
+            components.fractional = scale_multiplier + (components.whole ? Int64(-1) : Int64(1)) * components.fractional;
+            --components.whole;
+        }
+        Int64 fractional = components.fractional;
+        if (scale_multiplier > microsecond_multiplier)
+            fractional = fractional / (scale_multiplier / microsecond_multiplier);
+        else if (scale_multiplier < microsecond_multiplier)
+            fractional = fractional * (microsecond_multiplier / scale_multiplier);
+
+        UInt16 millisecond = static_cast<UInt16>(fractional / divider);
+        return millisecond;
+    }
+
     unsigned toMinute(Time t) const
     {
         if (t >= 0 && offset_is_whole_number_of_hours_during_epoch)
@@ -1122,9 +1146,9 @@ class DateLUTImpl
     DateOrTime toStartOfMinuteInterval(DateOrTime t, UInt64 minutes) const
     {
         Int64 divisor = 60 * minutes;
-        if (likely(offset_is_whole_number_of_minutes_during_epoch))
+        if (offset_is_whole_number_of_minutes_during_epoch) [[likely]]
         {
-            if (likely(t >= 0))
+            if (t >= 0) [[likely]]
                 return static_cast<DateOrTime>(t / divisor * divisor);
             return static_cast<DateOrTime>((t + 1 - divisor) / divisor * divisor);
         }
@@ -1339,7 +1363,7 @@ class DateLUTImpl
 
     UInt8 saturateDayOfMonth(Int16 year, UInt8 month, UInt8 day_of_month) const
     {
-        if (likely(day_of_month <= 28))
+        if (day_of_month <= 28) [[likely]]
             return day_of_month;
 
         UInt8 days_in_month = daysInMonth(year, month);
diff --git a/src/Functions/DateTimeTransforms.cpp b/src/Functions/DateTimeTransforms.cpp
index 7ec13be9d6d0..006d1e94ccdc 100644
--- a/src/Functions/DateTimeTransforms.cpp
+++ b/src/Functions/DateTimeTransforms.cpp
@@ -10,16 +10,17 @@ namespace ErrorCodes
 
 void throwDateIsNotSupported(const char * name)
 {
-    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type Date of argument for function {}", name);
+    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal argument of type Date for function {}", name);
 }
 
-void throwDateTimeIsNotSupported(const char * name)
+void throwDate32IsNotSupported(const char * name)
 {
-    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type DateTime of argument for function {}", name);
+    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal argument of type Date32 for function {}", name);
 }
 
-void throwDate32IsNotSupported(const char * name)
+void throwDateTimeIsNotSupported(const char * name)
 {
-    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal type Date32 of argument for function {}", name);
+    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Illegal argument of type DateTime for function {}", name);
 }
+
 }
diff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h
index 5467cf770851..96705a10f151 100644
--- a/src/Functions/DateTimeTransforms.h
+++ b/src/Functions/DateTimeTransforms.h
@@ -6,6 +6,7 @@
 #include <Common/DateLUTImpl.h>
 #include <Common/DateLUT.h>
 #include <Common/IntervalKind.h>
+#include "base/Decimal.h"
 #include <Columns/ColumnNullable.h>
 #include <Columns/ColumnsNumber.h>
 #include <Columns/ColumnVector.h>
@@ -54,8 +55,8 @@ constexpr time_t MAX_DATE_TIMESTAMP = 5662310399;       // 2149-06-06 23:59:59 U
 constexpr time_t MAX_DATETIME_DAY_NUM =  49710;               // 2106-02-07
 
 [[noreturn]] void throwDateIsNotSupported(const char * name);
-[[noreturn]] void throwDateTimeIsNotSupported(const char * name);
 [[noreturn]] void throwDate32IsNotSupported(const char * name);
+[[noreturn]] void throwDateTimeIsNotSupported(const char * name);
 
 /// This factor transformation will say that the function is monotone everywhere.
 struct ZeroTransform
@@ -481,7 +482,7 @@ struct ToStartOfInterval<IntervalKind::Nanosecond>
     }
     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)
     {
-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);
+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);
     }
     static UInt32 execute(UInt32, Int64, const DateLUTImpl &, Int64)
     {
@@ -516,7 +517,7 @@ struct ToStartOfInterval<IntervalKind::Microsecond>
     }
     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)
     {
-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);
+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);
     }
     static UInt32 execute(UInt32, Int64, const DateLUTImpl &, Int64)
     {
@@ -559,7 +560,7 @@ struct ToStartOfInterval<IntervalKind::Millisecond>
     }
     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)
     {
-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);
+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);
     }
     static UInt32 execute(UInt32, Int64, const DateLUTImpl &, Int64)
     {
@@ -602,7 +603,7 @@ struct ToStartOfInterval<IntervalKind::Second>
     }
     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)
     {
-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);
+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);
     }
     static UInt32 execute(UInt32 t, Int64 seconds, const DateLUTImpl & time_zone, Int64)
     {
@@ -623,7 +624,7 @@ struct ToStartOfInterval<IntervalKind::Minute>
     }
     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)
     {
-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);
+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);
     }
     static UInt32 execute(UInt32 t, Int64 minutes, const DateLUTImpl & time_zone, Int64)
     {
@@ -644,7 +645,7 @@ struct ToStartOfInterval<IntervalKind::Hour>
     }
     static UInt32 execute(Int32, Int64, const DateLUTImpl &, Int64)
     {
-        throwDateIsNotSupported(TO_START_OF_INTERVAL_NAME);
+        throwDate32IsNotSupported(TO_START_OF_INTERVAL_NAME);
     }
     static UInt32 execute(UInt32 t, Int64 hours, const DateLUTImpl & time_zone, Int64)
     {
@@ -777,7 +778,7 @@ struct ToTimeImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -802,7 +803,7 @@ struct ToStartOfMinuteImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -849,7 +850,7 @@ struct ToStartOfSecondImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -897,7 +898,7 @@ struct ToStartOfMillisecondImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -941,7 +942,7 @@ struct ToStartOfMicrosecondImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -979,7 +980,7 @@ struct ToStartOfNanosecondImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -1004,7 +1005,7 @@ struct ToStartOfFiveMinutesImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -1036,7 +1037,7 @@ struct ToStartOfTenMinutesImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -1068,7 +1069,7 @@ struct ToStartOfFifteenMinutesImpl
     }
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt32 execute(UInt16, const DateLUTImpl &)
     {
@@ -1103,7 +1104,7 @@ struct TimeSlotImpl
 
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
 
     static UInt32 execute(UInt16, const DateLUTImpl &)
@@ -1142,7 +1143,7 @@ struct ToStartOfHourImpl
 
     static UInt32 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
 
     static UInt32 execute(UInt16, const DateLUTImpl &)
@@ -1429,7 +1430,7 @@ struct ToHourImpl
     }
     static UInt8 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt8 execute(UInt16, const DateLUTImpl &)
     {
@@ -1456,7 +1457,7 @@ struct TimezoneOffsetImpl
 
     static time_t execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
 
     static time_t execute(UInt16, const DateLUTImpl &)
@@ -1482,7 +1483,7 @@ struct ToMinuteImpl
     }
     static UInt8 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt8 execute(UInt16, const DateLUTImpl &)
     {
@@ -1507,7 +1508,7 @@ struct ToSecondImpl
     }
     static UInt8 execute(Int32, const DateLUTImpl &)
     {
-        throwDateIsNotSupported(name);
+        throwDate32IsNotSupported(name);
     }
     static UInt8 execute(UInt16, const DateLUTImpl &)
     {
@@ -1518,6 +1519,32 @@ struct ToSecondImpl
     using FactorTransform = ToStartOfMinuteImpl;
 };
 
+struct ToMillisecondImpl
+{
+    static constexpr auto name = "toMillisecond";
+
+    static UInt16 execute(const DateTime64 & datetime64, Int64 scale_multiplier, const DateLUTImpl & time_zone)
+    {
+        return time_zone.toMillisecond<DateTime64>(datetime64, scale_multiplier);
+    }
+
+    static UInt16 execute(UInt32, const DateLUTImpl &)
+    {
+        return 0;
+    }
+    static UInt16 execute(Int32, const DateLUTImpl &)
+    {
+        throwDate32IsNotSupported(name);
+    }
+    static UInt16 execute(UInt16, const DateLUTImpl &)
+    {
+        throwDateIsNotSupported(name);
+    }
+    static constexpr bool hasPreimage() { return false; }
+
+    using FactorTransform = ZeroTransform;
+};
+
 struct ToISOYearImpl
 {
     static constexpr auto name = "toISOYear";
diff --git a/src/Functions/toMillisecond.cpp b/src/Functions/toMillisecond.cpp
new file mode 100644
index 000000000000..e15b56cc5559
--- /dev/null
+++ b/src/Functions/toMillisecond.cpp
@@ -0,0 +1,18 @@
+#include <Functions/FunctionFactory.h>
+#include <Functions/DateTimeTransforms.h>
+#include <Functions/FunctionDateOrDateTimeToSomething.h>
+
+namespace DB
+{
+
+using FunctionToMillisecond = FunctionDateOrDateTimeToSomething<DataTypeUInt16, ToMillisecondImpl>;
+
+REGISTER_FUNCTION(ToMillisecond)
+{
+    factory.registerFunction<FunctionToMillisecond>();
+
+    /// MySQL compatibility alias.
+    factory.registerAlias("MILLISECOND", "toMillisecond", FunctionFactory::CaseInsensitive);
+}
+
+}
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index f2e5a744a211..bc6b25da6035 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -2530,6 +2530,7 @@ toRelativeSecondNum
 toRelativeWeekNum
 toRelativeYearNum
 toSecond
+toMillisecond
 toStartOfDay
 toStartOfFifteenMinutes
 toStartOfFiveMinutes
