{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 9262,
  "instance_id": "ClickHouse__ClickHouse-9262",
  "issue_numbers": [
    "6508"
  ],
  "base_commit": "eabfdf4ce0a3954060f7b0cae5173dacd20aa7ff",
  "patch": "diff --git a/dbms/programs/server/config.d/ssl.xml b/dbms/programs/server/config.d/ssl.xml\ndeleted file mode 100644\nindex 8686b86236ab..000000000000\n--- a/dbms/programs/server/config.d/ssl.xml\n+++ /dev/null\n@@ -1,31 +0,0 @@\n-<yandex>\n-\n-    <!-- Used with https_port and tcp_port_secure. Full ssl options list: https://github.com/ClickHouse-Extras/poco/blob/master/NetSSL_OpenSSL/include/Poco/Net/SSLManager.h#L71 -->\n-    <openSSL>\n-        <server> <!-- Used for https server AND secure tcp port -->\n-            <!-- openssl req -subj \"/CN=localhost\" -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/clickhouse-server/server.key -out /etc/clickhouse-server/server.crt -->\n-            <certificateFile>/etc/clickhouse-server/server.crt</certificateFile>\n-            <privateKeyFile>/etc/clickhouse-server/server.key</privateKeyFile>\n-            <!-- openssl dhparam -out /etc/clickhouse-server/dhparam.pem 4096 -->\n-            <dhParamsFile>/etc/clickhouse-server/dhparam.pem</dhParamsFile>\n-            <verificationMode>none</verificationMode>\n-            <loadDefaultCAFile>true</loadDefaultCAFile>\n-            <cacheSessions>true</cacheSessions>\n-            <disableProtocols>sslv2,sslv3</disableProtocols>\n-            <preferServerCiphers>true</preferServerCiphers>\n-        </server>\n-\n-        <client> <!-- Used for connecting to https dictionary source -->\n-            <loadDefaultCAFile>true</loadDefaultCAFile>\n-            <cacheSessions>true</cacheSessions>\n-            <disableProtocols>sslv2,sslv3</disableProtocols>\n-            <preferServerCiphers>true</preferServerCiphers>\n-            <!-- Use for self-signed: <verificationMode>none</verificationMode> -->\n-            <invalidCertificateHandler>\n-                <!-- Use for self-signed: <name>AcceptCertificateHandler</name> -->\n-                <name>RejectCertificateHandler</name>\n-            </invalidCertificateHandler>\n-        </client>\n-    </openSSL>\n-\n-</yandex>\ndiff --git a/dbms/programs/server/config.xml b/dbms/programs/server/config.xml\nindex 8d3c27a8d364..ae15a583fcdd 100644\n--- a/dbms/programs/server/config.xml\n+++ b/dbms/programs/server/config.xml\n@@ -35,12 +35,40 @@\n     <http_port>8123</http_port>\n     <tcp_port>9000</tcp_port>\n     <mysql_port>9004</mysql_port>\n-    <!-- For HTTPS and SSL over native protocol. See also ssl.xml in config.d/-->\n+    <!-- For HTTPS and SSL over native protocol. -->\n     <!--\n     <https_port>8443</https_port>\n     <tcp_port_secure>9440</tcp_port_secure>\n     -->\n \n+    <!-- Used with https_port and tcp_port_secure. Full ssl options list: https://github.com/ClickHouse-Extras/poco/blob/master/NetSSL_OpenSSL/include/Poco/Net/SSLManager.h#L71 -->\n+    <openSSL>\n+        <server> <!-- Used for https server AND secure tcp port -->\n+            <!-- openssl req -subj \"/CN=localhost\" -new -newkey rsa:2048 -days 365 -nodes -x509 -keyout /etc/clickhouse-server/server.key -out /etc/clickhouse-server/server.crt -->\n+            <certificateFile>/etc/clickhouse-server/server.crt</certificateFile>\n+            <privateKeyFile>/etc/clickhouse-server/server.key</privateKeyFile>\n+            <!-- openssl dhparam -out /etc/clickhouse-server/dhparam.pem 4096 -->\n+            <dhParamsFile>/etc/clickhouse-server/dhparam.pem</dhParamsFile>\n+            <verificationMode>none</verificationMode>\n+            <loadDefaultCAFile>true</loadDefaultCAFile>\n+            <cacheSessions>true</cacheSessions>\n+            <disableProtocols>sslv2,sslv3</disableProtocols>\n+            <preferServerCiphers>true</preferServerCiphers>\n+        </server>\n+\n+        <client> <!-- Used for connecting to https dictionary source -->\n+            <loadDefaultCAFile>true</loadDefaultCAFile>\n+            <cacheSessions>true</cacheSessions>\n+            <disableProtocols>sslv2,sslv3</disableProtocols>\n+            <preferServerCiphers>true</preferServerCiphers>\n+            <!-- Use for self-signed: <verificationMode>none</verificationMode> -->\n+            <invalidCertificateHandler>\n+                <!-- Use for self-signed: <name>AcceptCertificateHandler</name> -->\n+                <name>RejectCertificateHandler</name>\n+            </invalidCertificateHandler>\n+        </client>\n+    </openSSL>\n+\n     <!-- Default root page on http[s] server. For example load UI from https://tabix.io/ when opening http://localhost:8123 -->\n     <!--\n     <http_server_default_response><![CDATA[<html ng-app=\"SMI2\"><head><base href=\"http://ui.tabix.io/\"></head><body><div ui-view=\"\" class=\"content-ui\"></div><script src=\"http://loader.tabix.io/master.js\"></script></body></html>]]></http_server_default_response>\ndiff --git a/dbms/src/Dictionaries/ClickHouseDictionarySource.cpp b/dbms/src/Dictionaries/ClickHouseDictionarySource.cpp\nindex 3bf03ec28b1e..dc4b687c8dc5 100644\n--- a/dbms/src/Dictionaries/ClickHouseDictionarySource.cpp\n+++ b/dbms/src/Dictionaries/ClickHouseDictionarySource.cpp\n@@ -68,7 +68,7 @@ ClickHouseDictionarySource::ClickHouseDictionarySource(\n     , query_builder{dict_struct, db, table, where, IdentifierQuotingStyle::Backticks}\n     , sample_block{sample_block_}\n     , context(context_)\n-    , is_local{isLocalAddress({host, port}, context.getTCPPort())}\n+    , is_local{isLocalAddress({host, port}, secure ? context.getTCPPortSecure().value_or(0) : context.getTCPPort())}\n     , pool{is_local ? nullptr : createPool(host, port, secure, db, user, password)}\n     , load_all_query{query_builder.composeLoadAllQuery()}\n {\ndiff --git a/dbms/src/Interpreters/InterpreterCreateQuery.cpp b/dbms/src/Interpreters/InterpreterCreateQuery.cpp\nindex bdd1b23d19fc..3d5014ac440a 100644\n--- a/dbms/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/dbms/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -620,6 +620,7 @@ bool InterpreterCreateQuery::doCreateTable(const ASTCreateQuery & create,\n          return false;\n \n     StoragePtr res;\n+    /// NOTE: CREATE query may be rewritten by Storage creator or table function\n     if (create.as_table_function)\n     {\n         const auto & table_function = create.as_table_function->as<ASTFunction &>();\ndiff --git a/dbms/src/Interpreters/evaluateConstantExpression.cpp b/dbms/src/Interpreters/evaluateConstantExpression.cpp\nindex 2e46ff294cc3..23cdcbd9fd56 100644\n--- a/dbms/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/dbms/src/Interpreters/evaluateConstantExpression.cpp\n@@ -16,6 +16,7 @@\n #include <TableFunctions/TableFunctionFactory.h>\n #include <Common/typeid_cast.h>\n #include <Interpreters/ReplaceQueryParameterVisitor.h>\n+#include <Poco/Util/AbstractConfiguration.h>\n \n \n namespace DB\n@@ -25,6 +26,7 @@ namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n     extern const int BAD_ARGUMENTS;\n+    extern const int UNKNOWN_DATABASE;\n }\n \n \n@@ -65,12 +67,6 @@ ASTPtr evaluateConstantExpressionAsLiteral(const ASTPtr & node, const Context &\n     /// If it's already a literal.\n     if (node->as<ASTLiteral>())\n         return node;\n-\n-    /// Skip table functions.\n-    if (const auto * table_func_ptr = node->as<ASTFunction>())\n-        if (TableFunctionFactory::instance().isTableFunctionName(table_func_ptr->name))\n-            return node;\n-\n     return std::make_shared<ASTLiteral>(evaluateConstantExpression(node, context).first);\n }\n \n@@ -82,6 +78,25 @@ ASTPtr evaluateConstantExpressionOrIdentifierAsLiteral(const ASTPtr & node, cons\n     return evaluateConstantExpressionAsLiteral(node, context);\n }\n \n+ASTPtr evaluateConstantExpressionForDatabaseName(const ASTPtr & node, const Context & context)\n+{\n+    ASTPtr res = evaluateConstantExpressionOrIdentifierAsLiteral(node, context);\n+    auto & literal = res->as<ASTLiteral &>();\n+    if (literal.value.safeGet<String>().empty())\n+    {\n+        String current_database = context.getCurrentDatabase();\n+        if (current_database.empty())\n+        {\n+            /// Table was created on older version of ClickHouse and CREATE contains not folded expression.\n+            /// Current database is not set yet during server startup, so we cannot evaluate it correctly.\n+            literal.value = context.getConfigRef().getString(\"default_database\", \"default\");\n+        }\n+        else\n+            literal.value = current_database;\n+    }\n+    return res;\n+}\n+\n namespace\n {\n     using Conjunction = ColumnsWithTypeAndName;\ndiff --git a/dbms/src/Interpreters/evaluateConstantExpression.h b/dbms/src/Interpreters/evaluateConstantExpression.h\nindex a84104c53f43..422afd33d4b3 100644\n--- a/dbms/src/Interpreters/evaluateConstantExpression.h\n+++ b/dbms/src/Interpreters/evaluateConstantExpression.h\n@@ -37,6 +37,12 @@ ASTPtr evaluateConstantExpressionAsLiteral(const ASTPtr & node, const Context &\n   */\n ASTPtr evaluateConstantExpressionOrIdentifierAsLiteral(const ASTPtr & node, const Context & context);\n \n+/** The same as evaluateConstantExpressionOrIdentifierAsLiteral(...),\n+ *  but if result is an empty string, replace it with current database name\n+ *  or default database name.\n+ */\n+ASTPtr evaluateConstantExpressionForDatabaseName(const ASTPtr & node, const Context & context);\n+\n /** Try to fold condition to countable set of constant values.\n   * @param condition a condition that we try to fold.\n   * @param target_expr expression evaluated over a set of constants.\ndiff --git a/dbms/src/Interpreters/getClusterName.cpp b/dbms/src/Interpreters/getClusterName.cpp\nindex d162cbdab9d2..60040ce4cb01 100644\n--- a/dbms/src/Interpreters/getClusterName.cpp\n+++ b/dbms/src/Interpreters/getClusterName.cpp\n@@ -45,4 +45,12 @@ std::string getClusterName(const IAST & node)\n     throw Exception(\"Illegal expression instead of cluster name.\", ErrorCodes::BAD_ARGUMENTS);\n }\n \n+\n+String getClusterNameAndMakeLiteral(ASTPtr & node)\n+{\n+    String cluster_name = getClusterName(*node);\n+    node = std::make_shared<ASTLiteral>(cluster_name);\n+    return cluster_name;\n+}\n+\n }\ndiff --git a/dbms/src/Interpreters/getClusterName.h b/dbms/src/Interpreters/getClusterName.h\nindex dab45713345b..55b73ce3ccfa 100644\n--- a/dbms/src/Interpreters/getClusterName.h\n+++ b/dbms/src/Interpreters/getClusterName.h\n@@ -1,13 +1,11 @@\n #pragma once\n \n #include <string>\n-\n+#include <Parsers/IAST_fwd.h>\n \n namespace DB\n {\n \n-class IAST;\n-\n /// Get the cluster name from AST.\n /** The name of the cluster is the name of the tag in the xml configuration.\n   * Usually it is parsed as an identifier. That is, it can contain underscores, but can not contain hyphens,\n@@ -16,6 +14,8 @@ class IAST;\n   * This name will be parsed as an expression with an operator minus - not at all what you need.\n   * Therefore, consider this case separately.\n   */\n-std::string getClusterName(const IAST & node);\n+String getClusterName(const IAST & node);\n+\n+String getClusterNameAndMakeLiteral(ASTPtr & node);\n \n }\ndiff --git a/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp b/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 0c4359b0f657..75178a075051 100644\n--- a/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/dbms/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -446,8 +446,10 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n     }\n \n     ASTs & engine_args = args.engine_args;\n+    size_t arg_num = 0;\n+    size_t arg_cnt = engine_args.size();\n \n-    if (engine_args.size() < min_num_params || engine_args.size() > max_num_params)\n+    if (arg_cnt < min_num_params || arg_cnt > max_num_params)\n     {\n         String msg;\n         if (is_extended_storage_def)\n@@ -477,15 +479,16 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n \n     if (replicated)\n     {\n-        const auto * ast = engine_args[0]->as<ASTLiteral>();\n+        const auto * ast = engine_args[arg_num]->as<ASTLiteral>();\n         if (ast && ast->value.getType() == Field::Types::String)\n             zookeeper_path = safeGet<String>(ast->value);\n         else\n             throw Exception(\n                 \"Path in ZooKeeper must be a string literal\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::BAD_ARGUMENTS);\n+        ++arg_num;\n \n-        ast = engine_args[1]->as<ASTLiteral>();\n+        ast = engine_args[arg_num]->as<ASTLiteral>();\n         if (ast && ast->value.getType() == Field::Types::String)\n             replica_name = safeGet<String>(ast->value);\n         else\n@@ -497,39 +500,36 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n             throw Exception(\n                 \"No replica name in config\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::NO_REPLICA_NAME_GIVEN);\n-\n-        engine_args.erase(engine_args.begin(), engine_args.begin() + 2);\n+        ++arg_num;\n     }\n \n     if (merging_params.mode == MergeTreeData::MergingParams::Collapsing)\n     {\n-        if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.sign_column))\n+        if (!tryGetIdentifierNameInto(engine_args[arg_cnt - 1], merging_params.sign_column))\n             throw Exception(\n                 \"Sign column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::BAD_ARGUMENTS);\n-\n-        engine_args.pop_back();\n+        --arg_cnt;\n     }\n     else if (merging_params.mode == MergeTreeData::MergingParams::Replacing)\n     {\n         /// If the last element is not index_granularity or replica_name (a literal), then this is the name of the version column.\n-        if (!engine_args.empty() && !engine_args.back()->as<ASTLiteral>())\n+        if (arg_cnt && !engine_args[arg_cnt - 1]->as<ASTLiteral>())\n         {\n-            if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.version_column))\n+            if (!tryGetIdentifierNameInto(engine_args[arg_cnt - 1], merging_params.version_column))\n                 throw Exception(\n                     \"Version column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n-\n-            engine_args.pop_back();\n+            --arg_cnt;\n         }\n     }\n     else if (merging_params.mode == MergeTreeData::MergingParams::Summing)\n     {\n         /// If the last element is not index_granularity or replica_name (a literal), then this is a list of summable columns.\n-        if (!engine_args.empty() && !engine_args.back()->as<ASTLiteral>())\n+        if (arg_cnt && !engine_args[arg_cnt - 1]->as<ASTLiteral>())\n         {\n-            merging_params.columns_to_sum = extractColumnNames(engine_args.back());\n-            engine_args.pop_back();\n+            merging_params.columns_to_sum = extractColumnNames(engine_args[arg_cnt - 1]);\n+            --arg_cnt;\n         }\n     }\n     else if (merging_params.mode == MergeTreeData::MergingParams::Graphite)\n@@ -538,7 +538,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         String error_msg = \"Last parameter of GraphiteMergeTree must be name (in single quotes) of element in configuration file with Graphite options\";\n         error_msg += getMergeTreeVerboseHelp(is_extended_storage_def);\n \n-        if (const auto * ast = engine_args.back()->as<ASTLiteral>())\n+        if (const auto * ast = engine_args[arg_cnt - 1]->as<ASTLiteral>())\n         {\n             if (ast->value.getType() != Field::Types::String)\n                 throw Exception(error_msg, ErrorCodes::BAD_ARGUMENTS);\n@@ -548,24 +548,24 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n         else\n             throw Exception(error_msg, ErrorCodes::BAD_ARGUMENTS);\n \n-        engine_args.pop_back();\n+        --arg_cnt;\n         setGraphitePatternsFromConfig(args.context, graphite_config_name, merging_params.graphite_params);\n     }\n     else if (merging_params.mode == MergeTreeData::MergingParams::VersionedCollapsing)\n     {\n-        if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.version_column))\n+        if (!tryGetIdentifierNameInto(engine_args[arg_cnt - 1], merging_params.version_column))\n             throw Exception(\n                     \"Version column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n \n-        engine_args.pop_back();\n+        --arg_cnt;\n \n-        if (!tryGetIdentifierNameInto(engine_args.back(), merging_params.sign_column))\n+        if (!tryGetIdentifierNameInto(engine_args[arg_cnt - 1], merging_params.sign_column))\n             throw Exception(\n                     \"Sign column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                     ErrorCodes::BAD_ARGUMENTS);\n \n-        engine_args.pop_back();\n+        --arg_cnt;\n     }\n \n     String date_column_name;\n@@ -614,31 +614,38 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n     }\n     else\n     {\n-        /// If there is an expression for sampling. MergeTree(date, [sample_key], primary_key, index_granularity)\n-        if (engine_args.size() == 4)\n-        {\n-            sample_by_ast = engine_args[1];\n-            engine_args.erase(engine_args.begin() + 1);\n-        }\n-\n-        /// Now only three parameters remain - date (or partitioning expression), primary_key, index_granularity.\n-\n-        if (!tryGetIdentifierNameInto(engine_args[0], date_column_name))\n+        /// Syntax: *MergeTree(..., date, [sample_key], primary_key, index_granularity, ...)\n+        /// Get date:\n+        if (!tryGetIdentifierNameInto(engine_args[arg_num], date_column_name))\n             throw Exception(\n                 \"Date column name must be an unquoted string\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::BAD_ARGUMENTS);\n+        ++arg_num;\n \n-        order_by_ast = engine_args[1];\n+        /// If there is an expression for sampling\n+        if (arg_cnt - arg_num == 3)\n+        {\n+            sample_by_ast = engine_args[arg_num];\n+            ++arg_num;\n+        }\n \n-        const auto * ast = engine_args.back()->as<ASTLiteral>();\n+        /// Now only two parameters remain - primary_key, index_granularity.\n+        order_by_ast = engine_args[arg_num];\n+        ++arg_num;\n+\n+        const auto * ast = engine_args[arg_num]->as<ASTLiteral>();\n         if (ast && ast->value.getType() == Field::Types::UInt64)\n             storage_settings->index_granularity = safeGet<UInt64>(ast->value);\n         else\n             throw Exception(\n                 \"Index granularity must be a positive integer\" + getMergeTreeVerboseHelp(is_extended_storage_def),\n                 ErrorCodes::BAD_ARGUMENTS);\n+        ++arg_num;\n     }\n \n+    if (arg_num != arg_cnt)\n+        throw Exception(\"Wrong number of engine arguments.\", ErrorCodes::BAD_ARGUMENTS);\n+\n     if (!args.attach && !indices_description.empty() && !args.local_context.getSettingsRef().allow_experimental_data_skipping_indices)\n         throw Exception(\"You must set the setting `allow_experimental_data_skipping_indices` to 1 \" \\\n                         \"before using data skipping indices.\", ErrorCodes::BAD_ARGUMENTS);\ndiff --git a/dbms/src/Storages/StorageBuffer.cpp b/dbms/src/Storages/StorageBuffer.cpp\nindex b30668896122..fa98af244bfd 100644\n--- a/dbms/src/Storages/StorageBuffer.cpp\n+++ b/dbms/src/Storages/StorageBuffer.cpp\n@@ -768,7 +768,7 @@ void registerStorageBuffer(StorageFactory & factory)\n                 \" destination_database, destination_table, num_buckets, min_time, max_time, min_rows, max_rows, min_bytes, max_bytes.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        engine_args[0] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[0], args.local_context);\n+        engine_args[0] = evaluateConstantExpressionForDatabaseName(engine_args[0], args.local_context);\n         engine_args[1] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[1], args.local_context);\n \n         String destination_database = engine_args[0]->as<ASTLiteral &>().value.safeGet<String>();\ndiff --git a/dbms/src/Storages/StorageDistributed.cpp b/dbms/src/Storages/StorageDistributed.cpp\nindex 4ef0c316bbd4..96420485896a 100644\n--- a/dbms/src/Storages/StorageDistributed.cpp\n+++ b/dbms/src/Storages/StorageDistributed.cpp\n@@ -476,6 +476,9 @@ void StorageDistributed::alter(const AlterCommands & params, const Context & con\n \n void StorageDistributed::startup()\n {\n+    if (remote_database.empty() && !remote_table_function_ptr)\n+        LOG_WARNING(log, \"Name of remote database is empty. Default database will be used implicitly.\");\n+\n     if (!volume)\n         return;\n \n@@ -719,7 +722,7 @@ void registerStorageDistributed(StorageFactory & factory)\n                 \"policy to store data in (optional).\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        String cluster_name = getClusterName(*engine_args[0]);\n+        String cluster_name = getClusterNameAndMakeLiteral(engine_args[0]);\n \n         engine_args[1] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[1], args.local_context);\n         engine_args[2] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[2], args.local_context);\ndiff --git a/dbms/src/Storages/StorageFactory.cpp b/dbms/src/Storages/StorageFactory.cpp\nindex d61d2a04fdf1..8008b9fe39d4 100644\n--- a/dbms/src/Storages/StorageFactory.cpp\n+++ b/dbms/src/Storages/StorageFactory.cpp\n@@ -49,9 +49,10 @@ StoragePtr StorageFactory::get(\n     bool has_force_restore_data_flag) const\n {\n     String name;\n-    ASTs args;\n     ASTStorage * storage_def = query.storage;\n \n+    bool has_engine_args = false;\n+\n     if (query.is_view)\n     {\n         if (query.storage)\n@@ -89,7 +90,7 @@ StoragePtr StorageFactory::get(\n                     \"Engine definition cannot take the form of a parametric function\", ErrorCodes::FUNCTION_CANNOT_HAVE_PARAMETERS);\n \n             if (engine_def.arguments)\n-                args = engine_def.arguments->children;\n+                has_engine_args = true;\n \n             name = engine_def.name;\n \n@@ -162,10 +163,11 @@ StoragePtr StorageFactory::get(\n         }\n     }\n \n+    ASTs empty_engine_args;\n     Arguments arguments\n     {\n         .engine_name = name,\n-        .engine_args = args,\n+        .engine_args = has_engine_args ? storage_def->engine->arguments->children : empty_engine_args,\n         .storage_def = storage_def,\n         .query = query,\n         .relative_data_path = relative_data_path,\ndiff --git a/dbms/src/Storages/StorageMerge.cpp b/dbms/src/Storages/StorageMerge.cpp\nindex 26a3fdc15f22..654289b2d963 100644\n--- a/dbms/src/Storages/StorageMerge.cpp\n+++ b/dbms/src/Storages/StorageMerge.cpp\n@@ -520,7 +520,7 @@ void registerStorageMerge(StorageFactory & factory)\n                 \" - name of source database and regexp for table names.\",\n                 ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-        engine_args[0] = evaluateConstantExpressionOrIdentifierAsLiteral(engine_args[0], args.local_context);\n+        engine_args[0] = evaluateConstantExpressionForDatabaseName(engine_args[0], args.local_context);\n         engine_args[1] = evaluateConstantExpressionAsLiteral(engine_args[1], args.local_context);\n \n         String source_database = engine_args[0]->as<ASTLiteral &>().value.safeGet<String>();\ndiff --git a/dbms/src/TableFunctions/TableFunctionMerge.cpp b/dbms/src/TableFunctions/TableFunctionMerge.cpp\nindex b0c22c961170..a05c0ef4c8b9 100644\n--- a/dbms/src/TableFunctions/TableFunctionMerge.cpp\n+++ b/dbms/src/TableFunctions/TableFunctionMerge.cpp\n@@ -9,7 +9,7 @@\n #include <Access/AccessFlags.h>\n #include <TableFunctions/TableFunctionMerge.h>\n #include <TableFunctions/TableFunctionFactory.h>\n-#include \"registerTableFunctions.h\"\n+#include <TableFunctions/registerTableFunctions.h>\n \n \n namespace DB\n@@ -62,7 +62,7 @@ StoragePtr TableFunctionMerge::executeImpl(const ASTPtr & ast_function, const Co\n             \" - name of source database and regexp for table names.\",\n             ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n \n-    args[0] = evaluateConstantExpressionOrIdentifierAsLiteral(args[0], context);\n+    args[0] = evaluateConstantExpressionForDatabaseName(args[0], context);\n     args[1] = evaluateConstantExpressionAsLiteral(args[1], context);\n \n     String source_database = args[0]->as<ASTLiteral &>().value.safeGet<String>();\ndiff --git a/dbms/src/TableFunctions/TableFunctionRemote.cpp b/dbms/src/TableFunctions/TableFunctionRemote.cpp\nindex da078a0d3f08..ffcec737fb72 100644\n--- a/dbms/src/TableFunctions/TableFunctionRemote.cpp\n+++ b/dbms/src/TableFunctions/TableFunctionRemote.cpp\n@@ -65,8 +65,8 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n \n     if (is_cluster_function)\n     {\n-        ASTPtr ast_name = evaluateConstantExpressionOrIdentifierAsLiteral(args[arg_num], context);\n-        cluster_name = ast_name->as<ASTLiteral &>().value.safeGet<const String &>();\n+        args[arg_num] = evaluateConstantExpressionOrIdentifierAsLiteral(args[arg_num], context);\n+        cluster_name = args[arg_num]->as<ASTLiteral &>().value.safeGet<const String &>();\n     }\n     else\n     {\n@@ -75,8 +75,6 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n     }\n     ++arg_num;\n \n-    args[arg_num] = evaluateConstantExpressionOrIdentifierAsLiteral(args[arg_num], context);\n-\n     const auto * function = args[arg_num]->as<ASTFunction>();\n \n     if (function && TableFunctionFactory::instance().isTableFunctionName(function->name))\n@@ -86,6 +84,7 @@ StoragePtr TableFunctionRemote::executeImpl(const ASTPtr & ast_function, const C\n     }\n     else\n     {\n+        args[arg_num] = evaluateConstantExpressionForDatabaseName(args[arg_num], context);\n         remote_database = args[arg_num]->as<ASTLiteral &>().value.safeGet<String>();\n \n         ++arg_num;\n",
  "test_patch": "diff --git a/dbms/tests/config/secure_ports.xml b/dbms/tests/config/secure_ports.xml\nindex db8b42e8d3f1..d915daaf743a 100644\n--- a/dbms/tests/config/secure_ports.xml\n+++ b/dbms/tests/config/secure_ports.xml\n@@ -3,22 +3,8 @@\n     <tcp_port_secure>9440</tcp_port_secure>\n \n     <openSSL>\n-        <server><certificateFile>/etc/clickhouse-server/server.crt</certificateFile>\n-            <privateKeyFile>/etc/clickhouse-server/server.key</privateKeyFile>\n-            <dhParamsFile>/etc/clickhouse-server/dhparam.pem</dhParamsFile>\n-            <verificationMode>none</verificationMode>\n-            <loadDefaultCAFile>true</loadDefaultCAFile>\n-            <cacheSessions>true</cacheSessions>\n-            <disableProtocols>sslv2,sslv3</disableProtocols>\n-            <preferServerCiphers>true</preferServerCiphers>\n-        </server>\n-\n         <client>\n-            <loadDefaultCAFile>true</loadDefaultCAFile>\n-            <cacheSessions>true</cacheSessions>\n-            <disableProtocols>sslv2,sslv3</disableProtocols>\n-            <preferServerCiphers>true</preferServerCiphers>\n-            <invalidCertificateHandler>\n+            <invalidCertificateHandler replace=\"replace\">\n                 <name>AcceptCertificateHandler</name>  <!-- For tests only-->\n             </invalidCertificateHandler>\n         </client>\ndiff --git a/dbms/tests/queries/0_stateless/00987_distributed_stack_overflow.sql b/dbms/tests/queries/0_stateless/00987_distributed_stack_overflow.sql\nindex 8bc7b6963b97..4baa6969b310 100644\n--- a/dbms/tests/queries/0_stateless/00987_distributed_stack_overflow.sql\n+++ b/dbms/tests/queries/0_stateless/00987_distributed_stack_overflow.sql\n@@ -1,13 +1,18 @@\n+DROP TABLE IF EXISTS distr0;\n DROP TABLE IF EXISTS distr1;\n DROP TABLE IF EXISTS distr2;\n \n CREATE TABLE distr (x UInt8) ENGINE = Distributed(test_shard_localhost, currentDatabase(), distr); -- { serverError 269 }\n \n+CREATE TABLE distr0 (x UInt8) ENGINE = Distributed(test_shard_localhost, '', distr0);\n+SELECT * FROM distr0; -- { serverError 306 }\n+\n CREATE TABLE distr1 (x UInt8) ENGINE = Distributed(test_shard_localhost, currentDatabase(), distr2);\n CREATE TABLE distr2 (x UInt8) ENGINE = Distributed(test_shard_localhost, currentDatabase(), distr1);\n \n SELECT * FROM distr1; -- { serverError 306 }\n SELECT * FROM distr2; -- { serverError 306 }\n \n+DROP TABLE distr0;\n DROP TABLE distr1;\n DROP TABLE distr2;\ndiff --git a/dbms/tests/queries/0_stateless/01033_storage_odbc_parsing_exception_check.reference b/dbms/tests/queries/0_stateless/01033_storage_odbc_parsing_exception_check.reference\nindex 7e6d9355882f..bba4944f4a81 100644\n--- a/dbms/tests/queries/0_stateless/01033_storage_odbc_parsing_exception_check.reference\n+++ b/dbms/tests/queries/0_stateless/01033_storage_odbc_parsing_exception_check.reference\n@@ -1,1 +1,1 @@\n-CREATE TABLE default.BannerDict (`BannerID` UInt64, `CompaignID` UInt64) ENGINE = ODBC(\\'DSN=pgconn;Database=postgres\\', somedb, bannerdict)\n+CREATE TABLE default.BannerDict (`BannerID` UInt64, `CompaignID` UInt64) ENGINE = ODBC(\\'DSN=pgconn;Database=postgres\\', \\'somedb\\', \\'bannerdict\\')\ndiff --git a/dbms/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference b/dbms/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference\nnew file mode 100644\nindex 000000000000..c96ca993fd9e\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_expressions_in_engine_arguments.reference\n@@ -0,0 +1,12 @@\n+CREATE TABLE test_01083.file (`n` Int8) ENGINE = File(\\'TSVWithNamesAndTypes\\')\n+CREATE TABLE test_01083.buffer (`n` Int8) ENGINE = Buffer(\\'test_01083\\', \\'file\\', 16, 10, 200, 10000, 1000000, 10000000, 1000000000)\n+CREATE TABLE test_01083.merge (`n` Int8) ENGINE = Merge(\\'test_01083\\', \\'distributed\\')\n+CREATE TABLE test_01083.merge_tf AS merge(\\'test_01083\\', \\'.*\\')\n+CREATE TABLE test_01083.distributed (`n` Int8) ENGINE = Distributed(\\'test_shard_localhost\\', \\'test_01083\\', \\'file\\')\n+CREATE TABLE test_01083.distributed_tf AS cluster(\\'test_shard_localhost\\', \\'test_01083\\', \\'file\\')\n+CREATE TABLE test_01083.url (`n` UInt64, `_path` String) ENGINE = URL(\\'https://localhost:8443/?query=select+n,+_path+from+test_01083.file+format+CSV\\', \\'CSV\\')\n+CREATE TABLE test_01083.rich_syntax AS remote(\\'localhos{x|y|t}\\', cluster(\\'test_shard_localhost\\', remote(\\'127.0.0.{1..4}\\', \\'test_01083\\', \\'url\\')))\n+1\n+1\n+1\n+1\ndiff --git a/dbms/tests/queries/0_stateless/01083_expressions_in_engine_arguments.sql b/dbms/tests/queries/0_stateless/01083_expressions_in_engine_arguments.sql\nnew file mode 100644\nindex 000000000000..3c4ac17f790d\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01083_expressions_in_engine_arguments.sql\n@@ -0,0 +1,60 @@\n+DROP DATABASE IF EXISTS test_01083;\n+CREATE DATABASE test_01083;\n+USE test_01083;\n+\n+CREATE TABLE file (n Int8) ENGINE = File(upper('tsv') || 'WithNames' || 'AndTypes');\n+CREATE TABLE buffer (n Int8) ENGINE = Buffer(currentDatabase(), file, 16, 10, 200, 10000, 1000000, 10000000, 1000000000);\n+CREATE TABLE merge (n Int8) ENGINE = Merge('', lower('DISTRIBUTED'));\n+CREATE TABLE merge_tf as merge(currentDatabase(), '.*');\n+CREATE TABLE distributed (n Int8) ENGINE = Distributed(test_shard_localhost, currentDatabase(), 'fi' || 'le');\n+CREATE TABLE distributed_tf as cluster('test' || '_' || 'shard_localhost', '', 'fi' || 'le');\n+\n+INSERT INTO file VALUES (1);\n+CREATE TABLE url (n UInt64, _path String) ENGINE=URL\n+(\n+    replace\n+    (\n+        'https://localhost:8443/?query='  || 'select n, _path from ' || currentDatabase() || '.file format CSV', ' ', '+'    -- replace `file` with `merge` here after #9246 is fixed\n+    ),\n+    CSV\n+);\n+\n+-- The following line is needed just to disable checking stderr for emptiness\n+SELECT nonexistentsomething; -- { serverError 47 }\n+\n+CREATE DICTIONARY dict (n UInt64, _path String DEFAULT '42') PRIMARY KEY n\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT 9440 SECURE 1 USER 'default' TABLE 'url' DB 'test_01083')) LIFETIME(1) LAYOUT(CACHE(SIZE_IN_CELLS 1));\n+\n+-- TODO make fuzz test from this\n+CREATE TABLE rich_syntax as remote\n+(\n+    'localhos{x|y|t}',\n+    cluster\n+    (\n+        'test' || '_' || 'shard_localhost',\n+        remote\n+        (\n+            '127.0.0.{1..4}',\n+            if\n+            (\n+                toString(40 + 2.0) NOT IN ('hello', dictGetString(currentDatabase() || '.dict', '_path', toUInt64('0001'))),\n+                currentDatabase(),\n+                'FAIL'\n+            ),\n+            extract('123url456', '[a-z]+')\n+        )\n+    )\n+);\n+\n+SHOW CREATE file;\n+SHOW CREATE buffer;\n+SHOW CREATE merge;\n+SHOW CREATE merge_tf;\n+SHOW CREATE distributed;\n+SHOW CREATE distributed_tf;\n+SHOW CREATE url;\n+SHOW CREATE rich_syntax;\n+\n+SELECT n from rich_syntax;\n+\n+DROP DATABASE test_01083;\ndiff --git a/docker/test/stateless/Dockerfile b/docker/test/stateless/Dockerfile\nindex 6a448f7a16c4..35e1639b7149 100644\n--- a/docker/test/stateless/Dockerfile\n+++ b/docker/test/stateless/Dockerfile\n@@ -61,7 +61,6 @@ CMD dpkg -i package_folder/clickhouse-common-static_*.deb; \\\n     ln -s /usr/share/clickhouse-test/config/server.key /etc/clickhouse-server/; \\\n     ln -s /usr/share/clickhouse-test/config/server.crt /etc/clickhouse-server/; \\\n     ln -s /usr/share/clickhouse-test/config/dhparam.pem /etc/clickhouse-server/; \\\n-    rm -f /etc/clickhouse-server/config.d/ssl.xml; \\\n     ln -sf /usr/share/clickhouse-test/config/client_config.xml /etc/clickhouse-client/config.xml; \\\n     service zookeeper start; sleep 5; \\\n     service clickhouse-server start && sleep 5 && clickhouse-test --testname --shard --zookeeper $ADDITIONAL_OPTIONS $SKIP_TESTS_OPTION 2>&1 | ts '%Y-%m-%d %H:%M:%S' | tee test_output/test_result.txt\ndiff --git a/docker/test/stateless_with_coverage/run.sh b/docker/test/stateless_with_coverage/run.sh\nindex 843d7c9ecdac..a64d92923882 100755\n--- a/docker/test/stateless_with_coverage/run.sh\n+++ b/docker/test/stateless_with_coverage/run.sh\n@@ -68,7 +68,6 @@ ln -s /usr/share/clickhouse-test/config/zookeeper.xml /etc/clickhouse-server/con\n     ln -s /usr/share/clickhouse-test/config/server.key /etc/clickhouse-server/; \\\n     ln -s /usr/share/clickhouse-test/config/server.crt /etc/clickhouse-server/; \\\n     ln -s /usr/share/clickhouse-test/config/dhparam.pem /etc/clickhouse-server/; \\\n-    rm -f /etc/clickhouse-server/config.d/ssl.xml; \\\n     ln -sf /usr/share/clickhouse-test/config/client_config.xml /etc/clickhouse-client/config.xml; \\\n     ln -s /usr/lib/llvm-8/bin/llvm-symbolizer /usr/bin/llvm-symbolizer\n \n",
  "problem_statement": "Buffer tables, created with currentDatabase(), lose their database assigment after restarting clickhouse server\n**Describe the bug**\r\nBuffer tables lose information about their database when the clickhouse server restarts.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use\r\n19.13.2.19\r\n* `CREATE TABLE` statements for all tables involved\r\n\r\n\r\nCREATE TABLE Test (\r\n        uuid            UUID,\r\n        pkghash         UInt64\r\n) \r\nENGINE = MergeTree\r\nORDER BY (uuid, pkghash) PRIMARY KEY (uuid);\r\n\r\nCREATE TABLE Test_buffer AS Test\r\nENGINE = Buffer(currentDatabase(), Test, 16, 10, 200, 10000, 1000000, 10000000, 1000000000);\r\n\r\n\r\n* Sample data for all these tables, use [clickhouse-obfuscator](https://github.com/yandex/ClickHouse/blob/master/dbms/programs/obfuscator/Obfuscator.cpp#L42-L80) if necessary\r\n\r\ninsert into Test_buffer SELECT generateUUIDv4(),rand64()\r\n\r\n\r\n\r\n* Queries to run that lead to unexpected result\r\n\r\n`# systemctl restart clickhouse-server`\r\n`# clickhouse-client -n -d test_buff -q 'INSERT INTO Test_buffer SELECT generateUUIDv4(),rand64();'\r\nReceived exception from server (version 19.13.2):\r\nCode: 81. DB::Exception: Received from localhost:9000. DB::Exception: Default database is not selected.\r\n`\r\n\r\n**Expected behavior**\r\n\r\nInsert without error\r\n\r\n**Error message and/or stacktrace**\r\n\r\nINSERT INTO Test_buffer SELECT \r\n    generateUUIDv4(), \r\n    rand64()\r\n\r\n. Received exception from server (version 19.13.2):\r\nCode: 81. DB::Exception: Received from localhost:9000. DB::Exception: Default database is not selected.\r\n\r\n**Additional context**\r\n\r\n\n",
  "hints_text": "Related #6104\nThis issue has been automatically marked as stale because it has not had recent activity. It will be closed if no further activity occurs. Thank you for your contributions.\n",
  "created_at": "2020-02-20T20:35:07Z"
}