{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 57546,
  "instance_id": "ClickHouse__ClickHouse-57546",
  "issue_numbers": [
    "15449",
    "55650"
  ],
  "base_commit": "6b888f7fa5261311e60cf0618d223a713ebf5035",
  "patch": "diff --git a/src/Storages/IndicesDescription.cpp b/src/Storages/IndicesDescription.cpp\nindex 06518a52c614..c723fa4225c2 100644\n--- a/src/Storages/IndicesDescription.cpp\n+++ b/src/Storages/IndicesDescription.cpp\n@@ -10,6 +10,8 @@\n #include <Parsers/parseQuery.h>\n #include <Storages/extractKeyExpressionList.h>\n \n+#include <Storages/ReplaceAliasByExpressionVisitor.h>\n+\n #include <Core/Defines.h>\n #include \"Common/Exception.h\"\n \n@@ -22,6 +24,11 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+namespace\n+{\n+using ReplaceAliasToExprVisitor = InDepthNodeVisitor<ReplaceAliasByExpressionMatcher, true>;\n+}\n+\n IndexDescription::IndexDescription(const IndexDescription & other)\n     : definition_ast(other.definition_ast ? other.definition_ast->clone() : nullptr)\n     , expression_list_ast(other.expression_list_ast ? other.expression_list_ast->clone() : nullptr)\n@@ -94,6 +101,10 @@ IndexDescription IndexDescription::getIndexFromAST(const ASTPtr & definition_ast\n     if (index_definition->expr)\n     {\n         expr_list = extractKeyExpressionList(index_definition->expr->clone());\n+\n+        ReplaceAliasToExprVisitor::Data data{columns};\n+        ReplaceAliasToExprVisitor{data}.visit(expr_list);\n+\n         result.expression_list_ast = expr_list->clone();\n     }\n     else\ndiff --git a/src/Storages/ReplaceAliasByExpressionVisitor.cpp b/src/Storages/ReplaceAliasByExpressionVisitor.cpp\nnew file mode 100644\nindex 000000000000..b7836cfa9c46\n--- /dev/null\n+++ b/src/Storages/ReplaceAliasByExpressionVisitor.cpp\n@@ -0,0 +1,32 @@\n+#include <Storages/ReplaceAliasByExpressionVisitor.h>\n+\n+#include <Parsers/ASTIdentifier.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Storages/ColumnsDescription.h>\n+#include <Common/typeid_cast.h>\n+\n+namespace DB\n+{\n+\n+void ReplaceAliasByExpressionMatcher::visit(ASTPtr & ast, Data & data)\n+{\n+    if (auto * identifier = ast->as<ASTIdentifier>())\n+    {\n+        visit(*identifier, ast, data);\n+    }\n+}\n+\n+void ReplaceAliasByExpressionMatcher::visit(const ASTIdentifier & column, ASTPtr & ast, Data & data)\n+{\n+    const auto & column_name = column.name();\n+    if (data.columns.hasAlias(column_name))\n+    {\n+        /// Alias expr is saved in default expr.\n+        if (auto col_default = data.columns.getDefault(column_name))\n+        {\n+            ast = col_default->expression->clone();\n+        }\n+    }\n+}\n+\n+}\ndiff --git a/src/Storages/ReplaceAliasByExpressionVisitor.h b/src/Storages/ReplaceAliasByExpressionVisitor.h\nnew file mode 100644\nindex 000000000000..4acc1fd4be7e\n--- /dev/null\n+++ b/src/Storages/ReplaceAliasByExpressionVisitor.h\n@@ -0,0 +1,40 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+\n+namespace DB\n+{\n+\n+class ASTFunction;\n+class ColumnsDescription;\n+class ASTIdentifier;\n+\n+\n+/* The Visitor is used to replace ALIAS by EXPRESSION when we refer to ALIAS\n+ * column in index definition.\n+ *\n+ * For example, if we have following create statement:\n+ * CREATE TABLE t\n+ * (\n+ *     col UInt8,\n+ *     col_alias ALIAS  col + 1\n+ *     INDEX idx (col_alias) TYPE minmax\n+ * ) ENGINE = MergeTree ORDER BY col;\n+ * we need call the visitor to replace `col_alias` by `col` + 1 when get index\n+ * description from index definition AST.\n+*/\n+class ReplaceAliasByExpressionMatcher\n+{\n+public:\n+    struct Data\n+    {\n+        const ColumnsDescription & columns;\n+    };\n+\n+    static void visit(ASTPtr & ast, Data &);\n+    static void visit(const ASTIdentifier &, ASTPtr & ast, Data &);\n+    static bool needChildVisit(const ASTPtr &, const ASTPtr &) { return true; }\n+};\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02911_support_alias_column_in_indices.reference b/tests/queries/0_stateless/02911_support_alias_column_in_indices.reference\nnew file mode 100644\nindex 000000000000..883966ce6b5e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02911_support_alias_column_in_indices.reference\n@@ -0,0 +1,55 @@\n+Expression ((Projection + Before ORDER BY))\n+  Filter (WHERE)\n+    ReadFromMergeTree (02911_support_alias_column_in_indices.test1)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          c\n+        Condition: (plus(c, 1) in [11, +Inf))\n+        Parts: 1/2\n+        Granules: 1/2\n+      Skip\n+        Name: i\n+        Description: minmax GRANULARITY 1\n+        Parts: 1/1\n+        Granules: 1/1\n+Expression ((Project names + Projection))\n+  Filter ((WHERE + Change column names to column identifiers))\n+    ReadFromMergeTree (02911_support_alias_column_in_indices.test1)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          c\n+        Condition: (_CAST(plus(c, \\'UInt64\\'), 1) in [11, +Inf))\n+        Parts: 1/2\n+        Granules: 1/2\n+      Skip\n+        Name: i\n+        Description: minmax GRANULARITY 1\n+        Parts: 1/1\n+        Granules: 1/1\n+Expression ((Projection + Before ORDER BY))\n+  Filter (WHERE)\n+    ReadFromMergeTree (02911_support_alias_column_in_indices.test2)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          c\n+        Condition: (plus(plus(c, 1), 1) in [16, +Inf))\n+        Parts: 1/2\n+        Granules: 1/2\n+      Skip\n+        Name: i\n+        Description: minmax GRANULARITY 1\n+        Parts: 1/1\n+        Granules: 1/1\n+Expression ((Project names + Projection))\n+  Filter ((WHERE + Change column names to column identifiers))\n+    ReadFromMergeTree (02911_support_alias_column_in_indices.test2)\n+    Indexes:\n+      PrimaryKey\n+        Keys: \n+          c\n+        Condition: (_CAST(plus(_CAST(plus(c, \\'UInt64\\'), 1), \\'UInt64\\'), 1) in [16, +Inf))\n+        Parts: 1/2\n+        Granules: 1/2\ndiff --git a/tests/queries/0_stateless/02911_support_alias_column_in_indices.sql b/tests/queries/0_stateless/02911_support_alias_column_in_indices.sql\nnew file mode 100644\nindex 000000000000..46d915343398\n--- /dev/null\n+++ b/tests/queries/0_stateless/02911_support_alias_column_in_indices.sql\n@@ -0,0 +1,40 @@\n+-- Tags: no-parallel\n+\n+drop database if exists 02911_support_alias_column_in_indices;\n+create database 02911_support_alias_column_in_indices;\n+use 02911_support_alias_column_in_indices;\n+\n+create table test1\n+(\n+    c UInt32,\n+    a alias c + 1,\n+    index i (a) type minmax\n+)\n+engine = MergeTree\n+order by c\n+settings index_granularity = 8192, min_index_granularity_bytes = 1024, index_granularity_bytes = 10485760; -- default settings, prevent randomization in tests\n+\n+insert into test1 select * from numbers(10);\n+insert into test1 select * from numbers(11, 20);\n+\n+explain indexes = 1 select * from test1 where a > 10 settings allow_experimental_analyzer = 0;\n+explain indexes = 1 select * from test1 where a > 10 settings allow_experimental_analyzer = 1;\n+\n+create table test2\n+(\n+    c UInt32,\n+    a1 alias c + 1,\n+    a2 alias a1 + 1,\n+    index i (a2) type minmax\n+)\n+engine = MergeTree\n+order by c\n+settings index_granularity = 8192, min_index_granularity_bytes = 1024, index_granularity_bytes = 10485760; -- default settings, prevent randomization in tests\n+\n+insert into test2 select * from numbers(10);\n+insert into test2 select * from numbers(11, 20);\n+\n+explain indexes = 1 select * from test2 where a2 > 15 settings allow_experimental_analyzer = 0;\n+explain indexes = 1 select * from test2 where a2 > 15 settings allow_experimental_analyzer = 1; -- buggy, analyzer does not pick up index i\n+\n+drop database 02911_support_alias_column_in_indices;\n",
  "problem_statement": "ALIAS column in secondary index usage.\n**Use case**\r\nWe have some complex function, which we would like to use in secondary index, and we want to create an alias column as that function in order to have simple and memoriable name to it, which we can use in WHERE clause.\r\n\r\n**Describe the solution you'd like**\r\nClickhouse server version 20.9.2.20\r\n```\r\nCREATE TABLE test_index\r\n(\r\n    `key_string` String,\r\n    `key_uint32` ALIAS toUInt32(key_string),\r\n    INDEX idx key_uint32 TYPE set(0) GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY tuple()\r\nPRIMARY KEY tuple()\r\nORDER BY key_string\r\n\r\n\r\nReceived exception from server (version 20.9.2):\r\nCode: 47. DB::Exception: Received from localhost:9000. DB::Exception: Missing columns: 'key_uint32' while processing query: 'key_uint32', required columns: 'key_uint32', source columns: 'key_string'.\r\n\r\n\r\nCREATE TABLE test_index\r\n(\r\n    `key_string` String,\r\n    `key_uint32` ALIAS toUInt32(key_string),\r\n    INDEX idx toUInt32(key_string) TYPE set(0) GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY tuple()\r\nPRIMARY KEY tuple()\r\nORDER BY key_string;\r\n\r\nINSERT INTO test_index SELECT * FROM numbers(1000000);\r\n\r\nSELECT *\r\nFROM test_index\r\nWHERE key_uint32 = 1\r\n\r\n\u250c\u2500key_string\u2500\u2510\r\n\u2502 1          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.010 sec. Processed 1.00 million rows, 14.89 MB (99.93 million rows/s., 1.49 GB/s.)\r\n\r\nSELECT *\r\nFROM test_index\r\nWHERE toUInt32(key_string) = 1\r\n\r\n\u250c\u2500key_string\u2500\u2510\r\n\u2502 1          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.008 sec. Processed 8.19 thousand rows, 121.96 KB (1.02 million rows/s., 15.20 MB/s.)\r\n```\r\n**Describe alternatives you've considered**\r\nWrite that kind of conditions in full form, but that makes less sense when we have the ability to use ALIAS columns.\r\n\r\n\nCannot use ALIAS columns in indices\nThis does not work:\r\n```\r\nCREATE TABLE test\r\n(\r\n    x UInt32,\r\n    y ALIAS x + 1,\r\n    INDEX i_y (y) TYPE minmax\r\n) ENGINE = MergeTree ORDER BY x;\r\n```\r\n\r\nThis does:\r\n```\r\nCREATE TABLE test\r\n(\r\n    x UInt32,\r\n    y ALIAS x + 1,\r\n    INDEX i_y (x + 1) TYPE minmax\r\n) ENGINE = MergeTree ORDER BY x;\r\n```\n",
  "hints_text": "https://github.com/ClickHouse/ClickHouse/blob/master/src/Storages/MergeTree/MergeTreeData.cpp#L413  Here we only consider physical columns. It's easy to extend.\nMaster\r\nSecond approach works.\r\n```\r\nCREATE TABLE test_index\r\n(\r\n    `key_string` String,\r\n    `key_uint32` ALIAS toUInt32(key_string),\r\n    INDEX idx toUInt32(key_string) TYPE set(0) GRANULARITY 1\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY tuple()\r\nPRIMARY KEY tuple()\r\nORDER BY key_string;\r\n\r\nINSERT INTO test_index SELECT * FROM numbers(1000000);\r\n\r\n SELECT *\u3000FROM test_index\u3000WHERE key_uint32 = 1;\r\n\r\nSELECT *\r\nFROM test_index\r\nWHERE key_uint32 = 1\r\n\r\nQuery id: d16d29bf-df20-4d73-a22e-3c09929de5e6\r\n\r\n\u250c\u2500key_string\u2500\u2510\r\n\u2502 1          \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 rows in set. Elapsed: 0.008 sec. Processed 8.19 thousand rows, 121.96 KB (1.01 million rows/s., 14.96 MB/s.)\r\n```\r\nImplemented via https://github.com/ClickHouse/ClickHouse/pull/16995\r\n\r\nBut it still not possible to use alias column in skip index.\r\n\r\n\n> Pr for use alias column in skip index.\r\n\r\nhttps://github.com/ClickHouse/ClickHouse/pull/57220\n",
  "created_at": "2023-12-05T19:03:22Z",
  "modified_files": [
    "src/Storages/IndicesDescription.cpp",
    "b/src/Storages/ReplaceAliasByExpressionVisitor.cpp",
    "b/src/Storages/ReplaceAliasByExpressionVisitor.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02911_support_alias_column_in_indices.reference",
    "b/tests/queries/0_stateless/02911_support_alias_column_in_indices.sql"
  ]
}