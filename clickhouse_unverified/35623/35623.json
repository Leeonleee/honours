{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 35623,
  "instance_id": "ClickHouse__ClickHouse-35623",
  "issue_numbers": [
    "11103"
  ],
  "base_commit": "bd89fcafdbc44b4b41f1c7458af5eeedec062774",
  "patch": "diff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 25116f5145a4..f06ac229e94a 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -1527,6 +1527,21 @@ ActionsDAG::SplitResult ActionsDAG::splitActionsBeforeArrayJoin(const NameSet &\n     return res;\n }\n \n+ActionsDAG::SplitResult ActionsDAG::splitActionsBySortingDescription(const NameSet & sort_columns) const\n+{\n+    std::unordered_set<const Node *> split_nodes;\n+    for (const auto & sort_column : sort_columns)\n+        if (const auto * node = tryFindInIndex(sort_column))\n+            split_nodes.insert(node);\n+        else\n+            throw Exception(\n+                ErrorCodes::LOGICAL_ERROR, \"Sorting column {} wasn't found in the ActionsDAG's index. DAG:\\n{}\", sort_column, dumpDAG());\n+\n+    auto res = split(split_nodes);\n+    res.second->project_input = project_input;\n+    return res;\n+}\n+\n ActionsDAG::SplitResult ActionsDAG::splitActionsForFilter(const std::string & column_name) const\n {\n     const auto * node = tryFindInIndex(column_name);\ndiff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h\nindex b07ab08c997d..1ff82c8ea607 100644\n--- a/src/Interpreters/ActionsDAG.h\n+++ b/src/Interpreters/ActionsDAG.h\n@@ -274,6 +274,10 @@ class ActionsDAG\n     /// Index of initial actions must contain column_name.\n     SplitResult splitActionsForFilter(const std::string & column_name) const;\n \n+    /// Splits actions into two parts. The first part contains all the calculations required to calculate sort_columns.\n+    /// The second contains the rest.\n+    SplitResult splitActionsBySortingDescription(const NameSet & sort_columns) const;\n+\n     /// Create actions which may calculate part of filter using only available_inputs.\n     /// If nothing may be calculated, returns nullptr.\n     /// Otherwise, return actions which inputs are from available_inputs.\ndiff --git a/src/Processors/QueryPlan/Optimizations/Optimizations.h b/src/Processors/QueryPlan/Optimizations/Optimizations.h\nindex 10bc62935371..1d5b83dc9d0d 100644\n--- a/src/Processors/QueryPlan/Optimizations/Optimizations.h\n+++ b/src/Processors/QueryPlan/Optimizations/Optimizations.h\n@@ -44,16 +44,20 @@ size_t tryMergeExpressions(QueryPlan::Node * parent_node, QueryPlan::Nodes &);\n /// May split FilterStep and push down only part of it.\n size_t tryPushDownFilter(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);\n \n+/// Move ExpressionStep after SortingStep if possible.\n+/// May split ExpressionStep and lift up only a part of it.\n+size_t tryExecuteFunctionsAfterSorting(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);\n+\n inline const auto & getOptimizations()\n {\n-    static const std::array<Optimization, 5> optimizations =\n-    {{\n+    static const std::array<Optimization, 6> optimizations = {{\n         {tryLiftUpArrayJoin, \"liftUpArrayJoin\", &QueryPlanOptimizationSettings::optimize_plan},\n         {tryPushDownLimit, \"pushDownLimit\", &QueryPlanOptimizationSettings::optimize_plan},\n         {trySplitFilter, \"splitFilter\", &QueryPlanOptimizationSettings::optimize_plan},\n         {tryMergeExpressions, \"mergeExpressions\", &QueryPlanOptimizationSettings::optimize_plan},\n         {tryPushDownFilter, \"pushDownFilter\", &QueryPlanOptimizationSettings::filter_push_down},\n-     }};\n+        {tryExecuteFunctionsAfterSorting, \"liftUpFunctions\", &QueryPlanOptimizationSettings::optimize_plan},\n+    }};\n \n     return optimizations;\n }\ndiff --git a/src/Processors/QueryPlan/Optimizations/liftUpFunctions.cpp b/src/Processors/QueryPlan/Optimizations/liftUpFunctions.cpp\nnew file mode 100644\nindex 000000000000..2a415f8c5afb\n--- /dev/null\n+++ b/src/Processors/QueryPlan/Optimizations/liftUpFunctions.cpp\n@@ -0,0 +1,77 @@\n+#include <Interpreters/ActionsDAG.h>\n+#include <Processors/QueryPlan/ExpressionStep.h>\n+#include <Processors/QueryPlan/Optimizations/Optimizations.h>\n+#include <Processors/QueryPlan/SortingStep.h>\n+#include <Common/Exception.h>\n+\n+namespace DB\n+{\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+}\n+\n+namespace\n+{\n+\n+const DB::DataStream & getChildOutputStream(DB::QueryPlan::Node & node)\n+{\n+    if (node.children.size() != 1)\n+        throw DB::Exception(DB::ErrorCodes::LOGICAL_ERROR, \"Node \\\"{}\\\" is expected to have only one child.\", node.step->getName());\n+    return node.children.front()->step->getOutputStream();\n+}\n+\n+}\n+\n+namespace DB::QueryPlanOptimizations\n+{\n+\n+size_t tryExecuteFunctionsAfterSorting(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes)\n+{\n+    if (parent_node->children.size() != 1)\n+        return 0;\n+\n+    QueryPlan::Node * child_node = parent_node->children.front();\n+\n+    auto & parent_step = parent_node->step;\n+    auto & child_step = child_node->step;\n+    auto * sorting_step = typeid_cast<SortingStep *>(parent_step.get());\n+    auto * expression_step = typeid_cast<ExpressionStep *>(child_step.get());\n+\n+    if (!sorting_step || !expression_step)\n+        return 0;\n+\n+    NameSet sort_columns;\n+    for (const auto & col : sorting_step->getSortDescription())\n+        sort_columns.insert(col.column_name);\n+    auto [needed_for_sorting, unneeded_for_sorting] = expression_step->getExpression()->splitActionsBySortingDescription(sort_columns);\n+\n+    // No calculations can be postponed.\n+    if (unneeded_for_sorting->trivial())\n+        return 0;\n+\n+    // Sorting (parent_node) -> Expression (child_node)\n+    auto & node_with_needed = nodes.emplace_back();\n+    std::swap(node_with_needed.children, child_node->children);\n+    child_node->children = {&node_with_needed};\n+\n+    node_with_needed.step = std::make_unique<ExpressionStep>(getChildOutputStream(node_with_needed), std::move(needed_for_sorting));\n+    node_with_needed.step->setStepDescription(child_step->getStepDescription());\n+    // Sorting (parent_node) -> so far the origin Expression (child_node) -> NeededCalculations (node_with_needed)\n+\n+    std::swap(parent_step, child_step);\n+    // so far the origin Expression (parent_node) -> Sorting (child_node) -> NeededCalculations (node_with_needed)\n+\n+    sorting_step->updateInputStream(getChildOutputStream(*child_node));\n+    auto input_header = sorting_step->getInputStreams().at(0).header;\n+    sorting_step->updateOutputStream(std::move(input_header));\n+\n+    auto description = parent_step->getStepDescription();\n+    parent_step = std::make_unique<DB::ExpressionStep>(child_step->getOutputStream(), std::move(unneeded_for_sorting));\n+    parent_step->setStepDescription(description + \" [lifted up part]\");\n+    // UneededCalculations (parent_node) -> Sorting (child_node) -> NeededCalculations (node_with_needed)\n+\n+    return 3;\n+}\n+}\ndiff --git a/src/Processors/QueryPlan/SortingStep.cpp b/src/Processors/QueryPlan/SortingStep.cpp\nindex 1e56c02504ba..859c9fd9e19a 100644\n--- a/src/Processors/QueryPlan/SortingStep.cpp\n+++ b/src/Processors/QueryPlan/SortingStep.cpp\n@@ -1,11 +1,12 @@\n+#include <stdexcept>\n+#include <IO/Operators.h>\n+#include <Processors/Merges/MergingSortedTransform.h>\n #include <Processors/QueryPlan/SortingStep.h>\n-#include <QueryPipeline/QueryPipelineBuilder.h>\n-#include <Processors/Transforms/MergeSortingTransform.h>\n-#include <Processors/Transforms/PartialSortingTransform.h>\n #include <Processors/Transforms/FinishSortingTransform.h>\n-#include <Processors/Merges/MergingSortedTransform.h>\n #include <Processors/Transforms/LimitsCheckingTransform.h>\n-#include <IO/Operators.h>\n+#include <Processors/Transforms/MergeSortingTransform.h>\n+#include <Processors/Transforms/PartialSortingTransform.h>\n+#include <QueryPipeline/QueryPipelineBuilder.h>\n #include <Common/JSONBuilder.h>\n \n namespace DB\n@@ -88,6 +89,18 @@ SortingStep::SortingStep(\n     output_stream->sort_mode = DataStream::SortMode::Stream;\n }\n \n+void SortingStep::updateInputStream(DataStream input_stream)\n+{\n+    input_streams.clear();\n+    input_streams.emplace_back(std::move(input_stream));\n+}\n+\n+void SortingStep::updateOutputStream(Block result_header)\n+{\n+    output_stream = createOutputStream(input_streams.at(0), std::move(result_header), getDataStreamTraits());\n+    updateDistinctColumns(output_stream->header, output_stream->distinct_columns);\n+}\n+\n void SortingStep::updateLimit(size_t limit_)\n {\n     if (limit_ && (limit == 0 || limit_ < limit))\ndiff --git a/src/Processors/QueryPlan/SortingStep.h b/src/Processors/QueryPlan/SortingStep.h\nindex 8e253e71f441..1738d8d4e451 100644\n--- a/src/Processors/QueryPlan/SortingStep.h\n+++ b/src/Processors/QueryPlan/SortingStep.h\n@@ -49,6 +49,11 @@ class SortingStep : public ITransformingStep\n     /// Add limit or change it to lower value.\n     void updateLimit(size_t limit_);\n \n+    void updateInputStream(DataStream input_stream);\n+    void updateOutputStream(Block result_header);\n+\n+    SortDescription getSortDescription() const { return result_description; }\n+\n private:\n \n     enum class Type\n",
  "test_patch": "diff --git a/tests/performance/function_calculation_after_sorting_and_limit.xml b/tests/performance/function_calculation_after_sorting_and_limit.xml\nnew file mode 100644\nindex 000000000000..ddb8f860600d\n--- /dev/null\n+++ b/tests/performance/function_calculation_after_sorting_and_limit.xml\n@@ -0,0 +1,4 @@\n+<test>\n+    <query>SELECT sipHash64(number) FROM numbers(1e8) ORDER BY number LIMIT 5</query>\n+    <query>SELECT sipHash64(number) FROM numbers(1e8) ORDER BY number + 1 LIMIT 5</query>\n+</test>\ndiff --git a/tests/queries/0_stateless/01576_alias_column_rewrite.reference b/tests/queries/0_stateless/01576_alias_column_rewrite.reference\nindex 11cc146dd627..688757351108 100644\n--- a/tests/queries/0_stateless/01576_alias_column_rewrite.reference\n+++ b/tests/queries/0_stateless/01576_alias_column_rewrite.reference\n@@ -35,10 +35,11 @@ Expression (Projection)\n           ReadFromMergeTree (default.test_table)\n Expression (Projection)\n   Limit (preliminary LIMIT (without OFFSET))\n-    Sorting\n-      Expression (Before ORDER BY)\n-        SettingQuotaAndLimits (Set limits and quota after reading from storage)\n-          ReadFromMergeTree (default.test_table)\n+    Expression (Before ORDER BY [lifted up part])\n+      Sorting\n+        Expression (Before ORDER BY)\n+          SettingQuotaAndLimits (Set limits and quota after reading from storage)\n+            ReadFromMergeTree (default.test_table)\n optimize_aggregation_in_order\n Expression ((Projection + Before ORDER BY))\n   Aggregating\ndiff --git a/tests/queries/0_stateless/01591_window_functions.reference b/tests/queries/0_stateless/01591_window_functions.reference\nindex 655232fcdd43..c766bf16f191 100644\n--- a/tests/queries/0_stateless/01591_window_functions.reference\n+++ b/tests/queries/0_stateless/01591_window_functions.reference\n@@ -925,10 +925,11 @@ Expression ((Projection + Before ORDER BY))\n   Window (Window step for window \\'ORDER BY o ASC, number ASC\\')\n     Sorting (Sorting for window \\'ORDER BY o ASC, number ASC\\')\n       Window (Window step for window \\'ORDER BY number ASC\\')\n-        Sorting (Sorting for window \\'ORDER BY number ASC\\')\n-          Expression ((Before window functions + (Projection + Before ORDER BY)))\n-            SettingQuotaAndLimits (Set limits and quota after reading from storage)\n-              ReadFromStorage (SystemNumbers)\n+        Expression ((Before window functions + (Projection + Before ORDER BY)) [lifted up part])\n+          Sorting (Sorting for window \\'ORDER BY number ASC\\')\n+            Expression ((Before window functions + (Projection + Before ORDER BY)))\n+              SettingQuotaAndLimits (Set limits and quota after reading from storage)\n+                ReadFromStorage (SystemNumbers)\n -- A test case for the sort comparator found by fuzzer.\n SELECT\n     max(number) OVER (ORDER BY number DESC NULLS FIRST),\ndiff --git a/tests/queries/0_stateless/01600_remerge_sort_lowered_memory_bytes_ratio.sql b/tests/queries/0_stateless/01600_remerge_sort_lowered_memory_bytes_ratio.sql\nindex 5de4210d3f2d..6e23ab9cdb9d 100644\n--- a/tests/queries/0_stateless/01600_remerge_sort_lowered_memory_bytes_ratio.sql\n+++ b/tests/queries/0_stateless/01600_remerge_sort_lowered_memory_bytes_ratio.sql\n@@ -10,8 +10,8 @@ set max_block_size=40960;\n --     MergeSortingTransform: Re-merging intermediate ORDER BY data (20 blocks with 819200 rows) to save memory consumption\n --     MergeSortingTransform: Memory usage is lowered from 186.25 MiB to 95.00 MiB\n --     MergeSortingTransform: Re-merging is not useful (memory usage was not lowered by remerge_sort_lowered_memory_bytes_ratio=2.0)\n-select number k, repeat(toString(number), 11) v1, repeat(toString(number), 12) v2 from numbers(3e6) order by k limit 400e3 format Null; -- { serverError 241 }\n-select number k, repeat(toString(number), 11) v1, repeat(toString(number), 12) v2 from numbers(3e6) order by k limit 400e3 settings remerge_sort_lowered_memory_bytes_ratio=2. format Null; -- { serverError 241 }\n+select number k, repeat(toString(number), 11) v1, repeat(toString(number), 12) v2 from numbers(3e6) order by v1, v2 limit 400e3 format Null; -- { serverError 241 }\n+select number k, repeat(toString(number), 11) v1, repeat(toString(number), 12) v2 from numbers(3e6) order by v1, v2 limit 400e3 settings remerge_sort_lowered_memory_bytes_ratio=2. format Null; -- { serverError 241 }\n \n -- remerge_sort_lowered_memory_bytes_ratio 1.9 is good (need at least 1.91/0.98=1.94)\n --     MergeSortingTransform: Re-merging intermediate ORDER BY data (20 blocks with 819200 rows) to save memory consumption\ndiff --git a/tests/queries/0_stateless/01655_plan_optimizations.reference b/tests/queries/0_stateless/01655_plan_optimizations.reference\nindex 33a7ff44b749..bb9c614f7287 100644\n--- a/tests/queries/0_stateless/01655_plan_optimizations.reference\n+++ b/tests/queries/0_stateless/01655_plan_optimizations.reference\n@@ -142,3 +142,12 @@ Filter\n Filter\n 2\t3\n 2\t3\n+> function calculation should be done after sorting and limit (if possible)\n+> Expression should be divided into two subexpressions and only one of them should be moved after Sorting\n+Expression (Before ORDER BY [lifted up part])\n+FUNCTION sipHash64\n+Sorting\n+Expression (Before ORDER BY)\n+FUNCTION plus\n+> this query should be executed without throwing an exception\n+0\ndiff --git a/tests/queries/0_stateless/01655_plan_optimizations.sh b/tests/queries/0_stateless/01655_plan_optimizations.sh\nindex b66d788a3380..0b7f004a2ce6 100755\n--- a/tests/queries/0_stateless/01655_plan_optimizations.sh\n+++ b/tests/queries/0_stateless/01655_plan_optimizations.sh\n@@ -196,3 +196,12 @@ $CLICKHOUSE_CLIENT -q \"\n     select a, b from (\n         select number + 1 as a, number + 2 as b from numbers(2) union all select number + 1 as b, number + 2 as a from numbers(2)\n     ) where a != 1 settings enable_optimize_predicate_expression = 0\"\n+\n+echo \"> function calculation should be done after sorting and limit (if possible)\"\n+echo \"> Expression should be divided into two subexpressions and only one of them should be moved after Sorting\"\n+$CLICKHOUSE_CLIENT -q \"\n+    explain actions = 1 select number as n, sipHash64(n) from numbers(100) order by number + 1 limit 5\" |\n+    sed 's/^ *//g' | grep -o \"^ *\\(Expression (Before ORDER BY.*)\\|Sorting\\|FUNCTION \\w\\+\\)\"\n+echo \"> this query should be executed without throwing an exception\"\n+$CLICKHOUSE_CLIENT -q \"\n+    select throwIf(number = 5) from (select * from numbers(10)) order by number limit 1\"\ndiff --git a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\nindex 9e24b7c6ea6c..67a043d6646c 100644\n--- a/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\n+++ b/tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference\n@@ -7,13 +7,15 @@\n ExpressionTransform\n   (Limit)\n   Limit\n-    (Sorting)\n-    MergingSortedTransform 2 \u2192 1\n-      (Expression)\n-      ExpressionTransform \u00d7 2\n-        (SettingQuotaAndLimits)\n-          (ReadFromMergeTree)\n-          MergeTreeInOrder \u00d7 2 0 \u2192 1\n+    (Expression)\n+    ExpressionTransform\n+      (Sorting)\n+      MergingSortedTransform 2 \u2192 1\n+        (Expression)\n+        ExpressionTransform \u00d7 2\n+          (SettingQuotaAndLimits)\n+            (ReadFromMergeTree)\n+            MergeTreeInOrder \u00d7 2 0 \u2192 1\n 2020-10-01\t9\n 2020-10-01\t9\n 2020-10-01\t9\n@@ -23,16 +25,18 @@ ExpressionTransform\n ExpressionTransform\n   (Limit)\n   Limit\n-    (Sorting)\n-    MergingSortedTransform 2 \u2192 1\n-      (Expression)\n-      ExpressionTransform \u00d7 2\n-        (SettingQuotaAndLimits)\n-          (ReadFromMergeTree)\n-          ReverseTransform\n-            MergeTreeReverse 0 \u2192 1\n-              ReverseTransform\n-                MergeTreeReverse 0 \u2192 1\n+    (Expression)\n+    ExpressionTransform\n+      (Sorting)\n+      MergingSortedTransform 2 \u2192 1\n+        (Expression)\n+        ExpressionTransform \u00d7 2\n+          (SettingQuotaAndLimits)\n+            (ReadFromMergeTree)\n+            ReverseTransform\n+              MergeTreeReverse 0 \u2192 1\n+                ReverseTransform\n+                  MergeTreeReverse 0 \u2192 1\n 2020-10-01\t9\n 2020-10-01\t9\n 2020-10-01\t9\n@@ -42,15 +46,17 @@ ExpressionTransform\n ExpressionTransform\n   (Limit)\n   Limit\n-    (Sorting)\n-    FinishSortingTransform\n-      PartialSortingTransform\n-        MergingSortedTransform 2 \u2192 1\n-          (Expression)\n-          ExpressionTransform \u00d7 2\n-            (SettingQuotaAndLimits)\n-              (ReadFromMergeTree)\n-              MergeTreeInOrder \u00d7 2 0 \u2192 1\n+    (Expression)\n+    ExpressionTransform\n+      (Sorting)\n+      FinishSortingTransform\n+        PartialSortingTransform\n+          MergingSortedTransform 2 \u2192 1\n+            (Expression)\n+            ExpressionTransform \u00d7 2\n+              (SettingQuotaAndLimits)\n+                (ReadFromMergeTree)\n+                MergeTreeInOrder \u00d7 2 0 \u2192 1\n 2020-10-11\t0\n 2020-10-11\t0\n 2020-10-11\t0\n",
  "problem_statement": "Calculate functions after sorting and LIMIT if possible.\nExample:\r\n\r\n```\r\nSELECT throwIf(number = 5) FROM (SELECT * FROM numbers(10)) ORDER BY number LIMIT 1\r\n```\r\n\r\nIf the optimization exists, `throwIf(number = 5)` will be calculate only on first row and the query won't throw exception.\n",
  "hints_text": "@KochetovNicolai Maybe the new Query Plan will help?\nYes. It will probably be first optimisation for QueryPlan\nIs it fixed?\nNot yet.\r\n\r\n```sql\r\nEXPLAIN actions = 1\r\nSELECT throwIf(number = 5)\r\nFROM \r\n(\r\n    SELECT *\r\n    FROM numbers(10)\r\n)\r\nORDER BY number ASC\r\nLIMIT 1\r\nFORMAT TSV\r\n\r\nExpression (Projection)\r\nActions: PROJECT throwIf(equals(number, 5))\r\n         PROJECT throwIf(equals(number, 5))\r\n  Limit (preliminary LIMIT)\r\n  Limit 1\r\n  Offset 0\r\n    MergingSorted (Merge sorted streams for ORDER BY)\r\n    Sort description: number ASC\r\n    Limit 1\r\n      MergeSorting (Merge sorted blocks for ORDER BY)\r\n      Sort description: number ASC\r\n      Limit 1\r\n        PartialSorting (Sort each block for ORDER BY)\r\n        Sort description: number ASC\r\n        Limit 1\r\n          Expression (Before ORDER BY and SELECT)\r\n          Actions: ADD 5 UInt8 Const(UInt8)\r\n                   FUNCTION equals(number, 5) UInt8 = equals(number, 5)\r\n                   REMOVE 5\r\n                   FUNCTION throwIf(equals(number, 5)) UInt8 = throwIf(equals(number, 5))\r\n                   REMOVE equals(number, 5)\r\n            Expression (Projection)\r\n            Actions: PROJECT number\r\n              Expression (Before ORDER BY and SELECT)\r\n                ReadFromStorage (Read from SystemNumbers)\r\n```\r\n\r\nPush down for LIMIT works (limit for sorting transforms is 1), but expression with `throwIf` is added to pipeline before sorting.\r\nWe need another optimisation to move expression before sort. Or change the order pipeline is built.",
  "created_at": "2022-03-25T16:46:56Z",
  "modified_files": [
    "src/Interpreters/ActionsDAG.cpp",
    "src/Interpreters/ActionsDAG.h",
    "src/Processors/QueryPlan/Optimizations/Optimizations.h",
    "b/src/Processors/QueryPlan/Optimizations/liftUpFunctions.cpp",
    "src/Processors/QueryPlan/SortingStep.cpp",
    "src/Processors/QueryPlan/SortingStep.h"
  ],
  "modified_test_files": [
    "b/tests/performance/function_calculation_after_sorting_and_limit.xml",
    "tests/queries/0_stateless/01576_alias_column_rewrite.reference",
    "tests/queries/0_stateless/01591_window_functions.reference",
    "tests/queries/0_stateless/01600_remerge_sort_lowered_memory_bytes_ratio.sql",
    "tests/queries/0_stateless/01655_plan_optimizations.reference",
    "tests/queries/0_stateless/01655_plan_optimizations.sh",
    "tests/queries/0_stateless/02149_read_in_order_fixed_prefix.reference"
  ]
}