{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8326,
  "instance_id": "ClickHouse__ClickHouse-8326",
  "issue_numbers": [
    "6528"
  ],
  "base_commit": "980cf16873fbe2293d9a47039bbec487a79107f3",
  "patch": "diff --git a/dbms/src/Functions/runningAccumulate.cpp b/dbms/src/Functions/runningAccumulate.cpp\nindex a4ccc1e15537..761f3692e3d9 100644\n--- a/dbms/src/Functions/runningAccumulate.cpp\n+++ b/dbms/src/Functions/runningAccumulate.cpp\n@@ -15,6 +15,7 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n }\n \n \n@@ -46,10 +47,9 @@ class FunctionRunningAccumulate : public IFunction\n         return true;\n     }\n \n-    size_t getNumberOfArguments() const override\n-    {\n-        return 1;\n-    }\n+    bool isVariadic() const override { return true; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n \n     bool isDeterministic() const override { return false; }\n \n@@ -70,21 +70,32 @@ class FunctionRunningAccumulate : public IFunction\n \n     void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t /*input_rows_count*/) override\n     {\n+        size_t number_of_arguments = arguments.size();\n+\n+        if (number_of_arguments == 0)\n+            throw Exception(\"Incorrect number of arguments of function \" + getName() + \". Must be 1 or 2.\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n         const ColumnAggregateFunction * column_with_states\n             = typeid_cast<const ColumnAggregateFunction *>(&*block.getByPosition(arguments.at(0)).column);\n+\n         if (!column_with_states)\n             throw Exception(\"Illegal column \" + block.getByPosition(arguments.at(0)).column->getName()\n                     + \" of first argument of function \"\n                     + getName(),\n                 ErrorCodes::ILLEGAL_COLUMN);\n \n+        ColumnPtr column_with_groups;\n+\n+        if (number_of_arguments == 2)\n+            column_with_groups = block.getByPosition(arguments[1]).column;\n+\n         AggregateFunctionPtr aggregate_function_ptr = column_with_states->getAggregateFunction();\n         const IAggregateFunction & agg_func = *aggregate_function_ptr;\n \n         AlignedBuffer place(agg_func.sizeOfData(), agg_func.alignOfData());\n-        agg_func.create(place.data());\n-        SCOPE_EXIT(agg_func.destroy(place.data()));\n \n+        /// Will pass empty arena if agg_func does not allocate memory in arena\n         std::unique_ptr<Arena> arena = agg_func.allocatesMemoryInArena() ? std::make_unique<Arena>() : nullptr;\n \n         auto result_column_ptr = agg_func.getReturnType()->createColumn();\n@@ -92,11 +103,38 @@ class FunctionRunningAccumulate : public IFunction\n         result_column.reserve(column_with_states->size());\n \n         const auto & states = column_with_states->getData();\n+\n+        size_t i = 0;\n+\n+        SCOPE_EXIT({\n+            if (i > 0)\n+                agg_func.destroy(place.data());\n+        });\n+\n         for (const auto & state_to_add : states)\n         {\n-            /// Will pass empty arena if agg_func does not allocate memory in arena\n+            if (i == 0 || (column_with_groups && column_with_groups->compareAt(i, i - 1, *column_with_groups, 1) != 0))\n+            {\n+                if (i > 0)\n+                    agg_func.destroy(place.data());\n+\n+                try\n+                {\n+                    agg_func.create(place.data());\n+                }\n+                catch (...)\n+                {\n+                    // prevent destroy after creation failure\n+                    i = 0;\n+\n+                    throw;\n+                }\n+            }\n+\n             agg_func.merge(place.data(), state_to_add, arena.get());\n             agg_func.insertResultInto(place.data(), result_column);\n+\n+            ++i;\n         }\n \n         block.getByPosition(result).column = std::move(result_column_ptr);\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01012_reset_running_accumulate.reference b/dbms/tests/queries/0_stateless/01012_reset_running_accumulate.reference\nnew file mode 100644\nindex 000000000000..98d21902f5c6\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01012_reset_running_accumulate.reference\n@@ -0,0 +1,30 @@\n+0\t0\t0\n+0\t6\t6\n+0\t12\t18\n+0\t18\t36\n+0\t24\t60\n+1\t1\t1\n+1\t7\t8\n+1\t13\t21\n+1\t19\t40\n+1\t25\t65\n+2\t2\t2\n+2\t8\t10\n+2\t14\t24\n+2\t20\t44\n+2\t26\t70\n+3\t3\t3\n+3\t9\t12\n+3\t15\t27\n+3\t21\t48\n+3\t27\t75\n+4\t4\t4\n+4\t10\t14\n+4\t16\t30\n+4\t22\t52\n+4\t28\t80\n+5\t5\t5\n+5\t11\t16\n+5\t17\t33\n+5\t23\t56\n+5\t29\t85\ndiff --git a/dbms/tests/queries/0_stateless/01012_reset_running_accumulate.sql b/dbms/tests/queries/0_stateless/01012_reset_running_accumulate.sql\nnew file mode 100644\nindex 000000000000..b9336b2f50c7\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01012_reset_running_accumulate.sql\n@@ -0,0 +1,11 @@\n+SELECT grouping,\n+       item,\n+       runningAccumulate(state, grouping)\n+FROM (\n+      SELECT number % 6 AS grouping,\n+             number AS item,\n+             sumState(number) AS state\n+      FROM (SELECT number FROM system.numbers LIMIT 30)\n+      GROUP BY grouping, item\n+      ORDER BY grouping, item\n+);\n\\ No newline at end of file\n",
  "problem_statement": "runningAccumulate function with reset key\n**Use case**\r\nWe have `runningAccumulate` function to perform cumulative aggregations, for example: number of distinct users from the begginning up to each day. What if we want to reset accumulations for each month - to calculate number of distinct users from the first day of month up to each day of that month?\r\n\r\n**Describe the solution you'd like**\r\nAdd a second parameter - \"reset key\". If it changes, reset the accumulator.\r\n\n",
  "hints_text": "This is a great idea. Can it also be added to runningDifference* functions and the new neighbour function? https://github.com/yandex/ClickHouse/pull/5925.\r\n\r\nI'd imagine in the neighbour function the behavior would be that if the key for the neighbouring value was not the same as the current row key then it would return NULL.\r\n\n> I'd imagine in the neighbour function the behavior would be that if the key for the neighbouring value was not the same as the current row key then it would return NULL.\r\n\r\nYes, great idea!\nMy PR on `neighbour()` function is not merged yet, so we may apply some additional logic here.\r\nBut it is not clear for me, what behavior you expect? Could you, please, provide an example of input-output?\nNow:\r\n```\r\nSELECT \r\n    *, \r\n    runningDifference(x)\r\nFROM \r\n(\r\n    SELECT \r\n        number, \r\n        arrayJoin([1, 2, 3, 5, 8]) AS x\r\n    FROM numbers(3) \r\n) \r\n\r\n\u250c\u2500number\u2500\u252c\u2500x\u2500\u252c\u2500runningDifference(x)\u2500\u2510\r\n\u2502      0 \u2502 1 \u2502                    0 \u2502\r\n\u2502      0 \u2502 2 \u2502                    1 \u2502\r\n\u2502      0 \u2502 3 \u2502                    1 \u2502\r\n\u2502      0 \u2502 5 \u2502                    2 \u2502\r\n\u2502      0 \u2502 8 \u2502                    3 \u2502\r\n\u2502      1 \u2502 1 \u2502                   -7 \u2502\r\n\u2502      1 \u2502 2 \u2502                    1 \u2502\r\n\u2502      1 \u2502 3 \u2502                    1 \u2502\r\n\u2502      1 \u2502 5 \u2502                    2 \u2502\r\n\u2502      1 \u2502 8 \u2502                    3 \u2502\r\n\u2502      2 \u2502 1 \u2502                   -7 \u2502\r\n\u2502      2 \u2502 2 \u2502                    1 \u2502\r\n\u2502      2 \u2502 3 \u2502                    1 \u2502\r\n\u2502      2 \u2502 5 \u2502                    2 \u2502\r\n\u2502      2 \u2502 8 \u2502                    3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n15 rows in set. Elapsed: 0.003 sec.\r\n```\r\nShould be:\r\n```\r\nSELECT \r\n    number, \r\n    runningDifference(x,number)\r\nFROM \r\n(\r\n    SELECT \r\n        number, \r\n        arrayJoin([1, 2, 3, 5, 8]) AS x\r\n    FROM numbers(3) \r\n) \r\n\r\n\u250c\u2500number\u2500\u252c\u2500x\u2500\u252c\u2500runningDifference(x)\u2500\u2510\r\n\u2502      0 \u2502 1 \u2502                    0 \u2502\r\n\u2502      0 \u2502 2 \u2502                    1 \u2502\r\n\u2502      0 \u2502 3 \u2502                    1 \u2502\r\n\u2502      0 \u2502 5 \u2502                    2 \u2502\r\n\u2502      0 \u2502 8 \u2502                    3 \u2502\r\n\u2502      1 \u2502 1 \u2502                    0 \u2502\r\n\u2502      1 \u2502 2 \u2502                    1 \u2502\r\n\u2502      1 \u2502 3 \u2502                    1 \u2502\r\n\u2502      1 \u2502 5 \u2502                    2 \u2502\r\n\u2502      1 \u2502 8 \u2502                    3 \u2502\r\n\u2502      2 \u2502 1 \u2502                    0 \u2502\r\n\u2502      2 \u2502 2 \u2502                    1 \u2502\r\n\u2502      2 \u2502 3 \u2502                    1 \u2502\r\n\u2502      2 \u2502 5 \u2502                    2 \u2502\r\n\u2502      2 \u2502 8 \u2502                    3 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n15 rows in set. Elapsed: 0.003 sec.\r\n```\n@filimonov , got it, we are going to implement some kind of OVER () section from window functions.\nHave realized this isn't going to work because of processing per block. Is there any way to force consecutive blocks to synchronize?",
  "created_at": "2019-12-20T21:00:25Z"
}