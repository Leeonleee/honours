{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 59273,
  "instance_id": "ClickHouse__ClickHouse-59273",
  "issue_numbers": [
    "59254"
  ],
  "base_commit": "c0fc804797650a20afd01063b6e19da292300a5f",
  "patch": "diff --git a/base/poco/Foundation/include/Poco/Logger.h b/base/poco/Foundation/include/Poco/Logger.h\nindex f91d836f1909..cf2027186625 100644\n--- a/base/poco/Foundation/include/Poco/Logger.h\n+++ b/base/poco/Foundation/include/Poco/Logger.h\n@@ -904,13 +904,6 @@ class Foundation_API Logger : public Channel\n     /// Returns a pointer to the Logger with the given name if it\n     /// exists, or a null pointer otherwise.\n \n-    static bool destroy(const std::string & name);\n-    /// Destroys the logger with the specified name. Does nothing\n-    /// if the logger is not found.\n-    ///\n-    /// After a logger has been destroyed, all references to it\n-    /// become invalid.\n-\n     static void shutdown();\n     /// Shuts down the logging framework and releases all\n     /// Loggers.\n@@ -940,8 +933,6 @@ class Foundation_API Logger : public Channel\n     static const std::string ROOT; /// The name of the root logger (\"\").\n \n protected:\n-    typedef std::map<std::string, Logger *> LoggerMap;\n-\n     Logger(const std::string & name, Channel * pChannel, int level);\n     ~Logger();\n \n@@ -962,8 +953,6 @@ class Foundation_API Logger : public Channel\n     std::string _name;\n     Channel * _pChannel;\n     std::atomic_int _level;\n-\n-    static LoggerMap * _pLoggerMap;\n };\n \n \ndiff --git a/base/poco/Foundation/src/Logger.cpp b/base/poco/Foundation/src/Logger.cpp\nindex 7c54116aaa4d..cfc063c89791 100644\n--- a/base/poco/Foundation/src/Logger.cpp\n+++ b/base/poco/Foundation/src/Logger.cpp\n@@ -20,6 +20,7 @@\n #include \"Poco/NumberParser.h\"\n #include \"Poco/String.h\"\n \n+#include <cassert>\n #include <mutex>\n \n namespace\n@@ -37,12 +38,20 @@ std::mutex & getLoggerMutex()\n \treturn *logger_mutex;\n }\n \n+struct LoggerEntry\n+{\n+\tPoco::Logger * logger;\n+\tbool owned_by_shared_ptr = false;\n+};\n+\n+using LoggerMap = std::unordered_map<std::string, LoggerEntry>;\n+LoggerMap * _pLoggerMap = nullptr;\n+\n }\n \n namespace Poco {\n \n \n-Logger::LoggerMap* Logger::_pLoggerMap = 0;\n const std::string Logger::ROOT;\n \n \n@@ -134,12 +143,12 @@ void Logger::setLevel(const std::string& name, int level)\n \tif (_pLoggerMap)\n \t{\n \t\tstd::string::size_type len = name.length();\n-\t\tfor (LoggerMap::iterator it = _pLoggerMap->begin(); it != _pLoggerMap->end(); ++it)\n+\t\tfor (auto & it : *_pLoggerMap)\n \t\t{\n \t\t\tif (len == 0 ||\n-\t\t\t\t(it->first.compare(0, len, name) == 0 && (it->first.length() == len || it->first[len] == '.')))\n+\t\t\t\t(it.first.compare(0, len, name) == 0 && (it.first.length() == len || it.first[len] == '.')))\n \t\t\t{\n-\t\t\t\tit->second->setLevel(level);\n+\t\t\t\tit.second.logger->setLevel(level);\n \t\t\t}\n \t\t}\n \t}\n@@ -153,12 +162,12 @@ void Logger::setChannel(const std::string& name, Channel* pChannel)\n \tif (_pLoggerMap)\n \t{\n \t\tstd::string::size_type len = name.length();\n-\t\tfor (LoggerMap::iterator it = _pLoggerMap->begin(); it != _pLoggerMap->end(); ++it)\n+\t\tfor (auto & it : *_pLoggerMap)\n \t\t{\n \t\t\tif (len == 0 ||\n-\t\t\t\t(it->first.compare(0, len, name) == 0 && (it->first.length() == len || it->first[len] == '.')))\n+\t\t\t\t(it.first.compare(0, len, name) == 0 && (it.first.length() == len || it.first[len] == '.')))\n \t\t\t{\n-\t\t\t\tit->second->setChannel(pChannel);\n+\t\t\t\tit.second.logger->setChannel(pChannel);\n \t\t\t}\n \t\t}\n \t}\n@@ -172,12 +181,12 @@ void Logger::setProperty(const std::string& loggerName, const std::string& prope\n \tif (_pLoggerMap)\n \t{\n \t\tstd::string::size_type len = loggerName.length();\n-\t\tfor (LoggerMap::iterator it = _pLoggerMap->begin(); it != _pLoggerMap->end(); ++it)\n+\t\tfor (auto & it : *_pLoggerMap)\n \t\t{\n \t\t\tif (len == 0 ||\n-\t\t\t\t(it->first.compare(0, len, loggerName) == 0 && (it->first.length() == len || it->first[len] == '.')))\n+\t\t\t\t(it.first.compare(0, len, loggerName) == 0 && (it.first.length() == len || it.first[len] == '.')))\n \t\t\t{\n-\t\t\t\tit->second->setProperty(propertyName, value);\n+\t\t\t\tit.second.logger->setProperty(propertyName, value);\n \t\t\t}\n \t\t}\n \t}\n@@ -304,35 +313,84 @@ struct LoggerDeleter\n {\n \tvoid operator()(Poco::Logger * logger)\n \t{\n-\t\tif (Logger::destroy(logger->name()))\n+\t\tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n+\n+\t\t/// If logger infrastructure is destroyed just decrement logger reference count\n+\t\tif (!_pLoggerMap)\n+\t\t{\n+\t\t\tlogger->release();\n \t\t\treturn;\n+\t\t}\n+\n+\t\tauto it = _pLoggerMap->find(logger->name());\n+\t\tassert(it != _pLoggerMap->end());\n \n-\t\tlogger->release();\n+\t\t/** If reference count is 1, this means this shared pointer owns logger\n+\t\t  * and need destroy it.\n+\t\t  */\n+\t\tsize_t reference_count_before_release = logger->release();\n+\t\tif (reference_count_before_release == 1)\n+\t\t{\n+\t\t\tassert(it->second.owned_by_shared_ptr);\n+\t\t\t_pLoggerMap->erase(it);\n+\t\t}\n \t}\n };\n \n+\n inline LoggerPtr makeLoggerPtr(Logger & logger)\n {\n-\tlogger.duplicate();\n \treturn std::shared_ptr<Logger>(&logger, LoggerDeleter());\n }\n \n }\n \n+\n Logger& Logger::get(const std::string& name)\n {\n \tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n \n-\treturn unsafeGet(name);\n+\tLogger & logger = unsafeGet(name);\n+\n+\t/** If there are already shared pointer created for this logger\n+\t  * we need to increment Logger reference count and now logger\n+\t  * is owned by logger infrastructure.\n+\t  */\n+\tauto it = _pLoggerMap->find(name);\n+\tif (it->second.owned_by_shared_ptr)\n+\t{\n+\t\tit->second.logger->duplicate();\n+\t\tit->second.owned_by_shared_ptr = false;\n+\t}\n+\n+\treturn logger;\n }\n \n+\n LoggerPtr Logger::getShared(const std::string & name)\n {\n \tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n+\tbool logger_exists = _pLoggerMap && _pLoggerMap->contains(name);\n \n-\treturn makeLoggerPtr(unsafeGet(name));\n+\tLogger & logger = unsafeGet(name);\n+\n+\t/** If logger already exists, then this shared pointer does not own it.\n+\t  * If logger does not exists, logger infrastructure could be already destroyed\n+\t  * or logger was created.\n+\t  */\n+\tif (logger_exists)\n+\t{\n+\t\tlogger.duplicate();\n+\t}\n+\telse if (_pLoggerMap)\n+\t{\n+\t\t_pLoggerMap->find(name)->second.owned_by_shared_ptr = true;\n+\t}\n+\n+\treturn makeLoggerPtr(logger);\n }\n \n+\n Logger& Logger::unsafeGet(const std::string& name)\n {\n \tLogger* pLogger = find(name);\n@@ -364,7 +422,10 @@ LoggerPtr Logger::createShared(const std::string & name, Channel * pChannel, int\n {\n \tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n \n-\treturn makeLoggerPtr(unsafeCreate(name, pChannel, level));\n+\tLogger & logger = unsafeCreate(name, pChannel, level);\n+\t_pLoggerMap->find(name)->second.owned_by_shared_ptr = true;\n+\n+\treturn makeLoggerPtr(logger);\n }\n \n Logger& Logger::root()\n@@ -389,10 +450,14 @@ void Logger::shutdown()\n \n \tif (_pLoggerMap)\n \t{\n-\t\tfor (LoggerMap::iterator it = _pLoggerMap->begin(); it != _pLoggerMap->end(); ++it)\n+\t\tfor (auto & it : *_pLoggerMap)\n \t\t{\n-\t\t\tit->second->release();\n+\t\t\tif (it.second.owned_by_shared_ptr)\n+\t\t\t\tcontinue;\n+\n+\t\t\tit.second.logger->release();\n \t\t}\n+\n \t\tdelete _pLoggerMap;\n \t\t_pLoggerMap = 0;\n \t}\n@@ -405,32 +470,12 @@ Logger* Logger::find(const std::string& name)\n \t{\n \t\tLoggerMap::iterator it = _pLoggerMap->find(name);\n \t\tif (it != _pLoggerMap->end())\n-\t\t\treturn it->second;\n+\t\t\treturn it->second.logger;\n \t}\n \treturn 0;\n }\n \n \n-bool Logger::destroy(const std::string& name)\n-{\n-\tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n-\n-\tif (_pLoggerMap)\n-\t{\n-\t\tLoggerMap::iterator it = _pLoggerMap->find(name);\n-\t\tif (it != _pLoggerMap->end())\n-\t\t{\n-\t\t\tif (it->second->release() == 1)\n-\t\t\t\t_pLoggerMap->erase(it);\n-\n-\t\t\treturn true;\n-\t\t}\n-\t}\n-\n-\treturn false;\n-}\n-\n-\n void Logger::names(std::vector<std::string>& names)\n {\n \tstd::lock_guard<std::mutex> lock(getLoggerMutex());\n@@ -538,7 +583,8 @@ void Logger::add(Logger* pLogger)\n {\n \tif (!_pLoggerMap)\n \t\t_pLoggerMap = new LoggerMap;\n-\t_pLoggerMap->insert(LoggerMap::value_type(pLogger->name(), pLogger));\n+\n+\t_pLoggerMap->emplace(pLogger->name(), LoggerEntry{pLogger, false /*owned_by_shared_ptr*/});\n }\n \n \ndiff --git a/src/Common/AtomicLogger.h b/src/Common/AtomicLogger.h\nnew file mode 100644\nindex 000000000000..4bda55e070b7\n--- /dev/null\n+++ b/src/Common/AtomicLogger.h\n@@ -0,0 +1,51 @@\n+#pragma once\n+\n+#include <memory>\n+\n+#include <Common/Logger.h>\n+#include <Common/SharedMutex.h>\n+#include <Common/SharedLockGuard.h>\n+\n+\n+/** AtomicLogger allows to atomically change logger.\n+  * Standard library does not have atomic_shared_ptr, and we do not use std::atomic* operations,\n+  * because standard library implementation uses fixed table of mutexes, and it is better to avoid contention here.\n+  */\n+class AtomicLogger\n+{\n+public:\n+    explicit AtomicLogger(LoggerPtr logger_)\n+        : logger(std::move(logger_))\n+    {}\n+\n+    explicit AtomicLogger(const std::string & log_name)\n+        : AtomicLogger(::getLogger(log_name))\n+    {}\n+\n+    void store(LoggerPtr new_logger)\n+    {\n+        std::lock_guard lock(log_mutex);\n+        logger = std::move(new_logger);\n+    }\n+\n+    void store(const std::string & new_log_name)\n+    {\n+        auto new_logger = ::getLogger(new_log_name);\n+        store(std::move(new_logger));\n+    }\n+\n+    LoggerPtr load() const\n+    {\n+        DB::SharedLockGuard lock(log_mutex);\n+        return logger;\n+    }\n+\n+    String loadName() const\n+    {\n+        DB::SharedLockGuard lock(log_mutex);\n+        return logger->name();\n+    }\n+private:\n+    mutable DB::SharedMutex log_mutex;\n+    LoggerPtr logger;\n+};\ndiff --git a/src/Common/Exception.cpp b/src/Common/Exception.cpp\nindex ff83f6ba8073..7e73e2c07834 100644\n--- a/src/Common/Exception.cpp\n+++ b/src/Common/Exception.cpp\n@@ -257,6 +257,11 @@ void tryLogCurrentException(LoggerPtr logger, const std::string & start_of_messa\n     tryLogCurrentException(logger.get(), start_of_message);\n }\n \n+void tryLogCurrentException(const AtomicLogger & logger, const std::string & start_of_message)\n+{\n+    tryLogCurrentException(logger.load(), start_of_message);\n+}\n+\n static void getNoSpaceLeftInfoMessage(std::filesystem::path path, String & msg)\n {\n     path = std::filesystem::absolute(path);\n@@ -529,6 +534,11 @@ void tryLogException(std::exception_ptr e, LoggerPtr logger, const std::string &\n     }\n }\n \n+void tryLogException(std::exception_ptr e, const AtomicLogger & logger, const std::string & start_of_message)\n+{\n+    tryLogException(e, logger.load(), start_of_message);\n+}\n+\n std::string getExceptionMessage(const Exception & e, bool with_stacktrace, bool check_embedded_stacktrace)\n {\n     return getExceptionMessageAndPattern(e, with_stacktrace, check_embedded_stacktrace).text;\ndiff --git a/src/Common/Exception.h b/src/Common/Exception.h\nindex 8afed6034cfa..817a4400080b 100644\n--- a/src/Common/Exception.h\n+++ b/src/Common/Exception.h\n@@ -11,6 +11,7 @@\n #include <base/scope_guard.h>\n #include <Common/LoggingFormatStringHelpers.h>\n #include <Common/Logger.h>\n+#include <Common/AtomicLogger.h>\n #include <Common/StackTrace.h>\n \n #include <fmt/format.h>\n@@ -245,6 +246,7 @@ using Exceptions = std::vector<std::exception_ptr>;\n void tryLogCurrentException(const char * log_name, const std::string & start_of_message = \"\");\n void tryLogCurrentException(Poco::Logger * logger, const std::string & start_of_message = \"\");\n void tryLogCurrentException(LoggerPtr logger, const std::string & start_of_message = \"\");\n+void tryLogCurrentException(const AtomicLogger & logger, const std::string & start_of_message = \"\");\n \n \n /** Prints current exception in canonical format.\n@@ -290,6 +292,7 @@ struct ExecutionStatus\n /// TODO: Logger leak constexpr overload\n void tryLogException(std::exception_ptr e, const char * log_name, const std::string & start_of_message = \"\");\n void tryLogException(std::exception_ptr e, LoggerPtr logger, const std::string & start_of_message = \"\");\n+void tryLogException(std::exception_ptr e, const AtomicLogger & logger, const std::string & start_of_message = \"\");\n \n std::string getExceptionMessage(const Exception & e, bool with_stacktrace, bool check_embedded_stacktrace = false);\n PreformattedMessage getExceptionMessageAndPattern(const Exception & e, bool with_stacktrace, bool check_embedded_stacktrace = false);\ndiff --git a/src/Common/Logger.h b/src/Common/Logger.h\nindex 13e1c6bf8f57..6dcdea9a9d87 100644\n--- a/src/Common/Logger.h\n+++ b/src/Common/Logger.h\n@@ -43,7 +43,6 @@ LoggerRawPtr getRawLogger(const std::string & name);\n \n LoggerRawPtr createRawLogger(const std::string & name, Poco::Channel * channel, Poco::Message::Priority level = Poco::Message::PRIO_INFORMATION);\n \n-\n /** Returns true, if currently Logger with specified name is created.\n   * Otherwise, returns false.\n   */\ndiff --git a/src/Common/logger_useful.h b/src/Common/logger_useful.h\nindex 3899d060b7c6..8e78e93e198b 100644\n--- a/src/Common/logger_useful.h\n+++ b/src/Common/logger_useful.h\n@@ -9,6 +9,7 @@\n #include <Common/ProfileEvents.h>\n #include <Common/LoggingFormatStringHelpers.h>\n #include <Common/Logger.h>\n+#include <Common/AtomicLogger.h>\n \n namespace Poco { class Logger; }\n \n@@ -20,7 +21,8 @@ using LogSeriesLimiterPtr = std::shared_ptr<LogSeriesLimiter>;\n \n namespace\n {\n-    [[maybe_unused]] const ::Poco::Logger * getLoggerHelper(const LoggerPtr & logger) { return logger.get(); }\n+    [[maybe_unused]] LoggerPtr getLoggerHelper(const LoggerPtr & logger) { return logger; }\n+    [[maybe_unused]] LoggerPtr getLoggerHelper(const AtomicLogger & logger) { return logger.load(); }\n     [[maybe_unused]] const ::Poco::Logger * getLoggerHelper(const ::Poco::Logger * logger) { return logger; }\n     [[maybe_unused]] std::unique_ptr<LogToStrImpl> getLoggerHelper(std::unique_ptr<LogToStrImpl> && logger) { return logger; }\n     [[maybe_unused]] std::unique_ptr<LogFrequencyLimiterIml> getLoggerHelper(std::unique_ptr<LogFrequencyLimiterIml> && logger) { return logger; }\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex 87f23b0da2ad..19730dc05c17 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -1663,7 +1663,7 @@ try\n \n     metadata_manager->deleteAll(true);\n     metadata_manager->assertAllDeleted(true);\n-    getDataPartStorage().rename(to.parent_path(), to.filename(), storage.log, remove_new_dir_if_exists, fsync_dir);\n+    getDataPartStorage().rename(to.parent_path(), to.filename(), storage.log.load(), remove_new_dir_if_exists, fsync_dir);\n     metadata_manager->updateAll(true);\n \n     auto new_projection_root_path = to.string();\n@@ -1758,7 +1758,7 @@ void IMergeTreeDataPart::remove()\n     }\n \n     bool is_temporary_part = is_temp || state == MergeTreeDataPartState::Temporary;\n-    getDataPartStorage().remove(std::move(can_remove_callback), checksums, projection_checksums, is_temporary_part, storage.log);\n+    getDataPartStorage().remove(std::move(can_remove_callback), checksums, projection_checksums, is_temporary_part, storage.log.load());\n }\n \n std::optional<String> IMergeTreeDataPart::getRelativePathForPrefix(const String & prefix, bool detached, bool broken) const\n@@ -1775,7 +1775,7 @@ std::optional<String> IMergeTreeDataPart::getRelativePathForPrefix(const String\n     if (detached && parent_part)\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot detach projection\");\n \n-    return getDataPartStorage().getRelativePathForPrefix(storage.log, prefix, detached, broken);\n+    return getDataPartStorage().getRelativePathForPrefix(storage.log.load(), prefix, detached, broken);\n }\n \n std::optional<String> IMergeTreeDataPart::getRelativePathForDetachedPart(const String & prefix, bool broken) const\n@@ -1841,7 +1841,7 @@ MutableDataPartStoragePtr IMergeTreeDataPart::makeCloneOnDisk(\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Can not clone data part {} to empty directory.\", name);\n \n     String path_to_clone = fs::path(storage.relative_data_path) / directory_name / \"\";\n-    return getDataPartStorage().clonePart(path_to_clone, getDataPartStorage().getPartDirectory(), disk, read_settings, write_settings, storage.log, cancellation_hook);\n+    return getDataPartStorage().clonePart(path_to_clone, getDataPartStorage().getPartDirectory(), disk, read_settings, write_settings, storage.log.load(), cancellation_hook);\n }\n \n UInt64 IMergeTreeDataPart::getIndexSizeFromFile() const\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 39c113c240eb..f0eeb3602d52 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -354,8 +354,7 @@ MergeTreeData::MergeTreeData(\n     , merging_params(merging_params_)\n     , require_part_metadata(require_part_metadata_)\n     , broken_part_callback(broken_part_callback_)\n-    , log_name(std::make_shared<String>(table_id_.getNameForLogs()))\n-    , log(getLogger(*log_name))\n+    , log(table_id_.getNameForLogs())\n     , storage_settings(std::move(storage_settings_))\n     , pinned_part_uuids(std::make_shared<PinnedPartUUIDs>())\n     , data_parts_by_info(data_parts_indexes.get<TagByInfo>())\n@@ -1296,7 +1295,7 @@ MergeTreeData::LoadPartResult MergeTreeData::loadDataPart(\n         res.is_broken = true;\n         tryLogCurrentException(log, fmt::format(\"while loading part {} on path {}\", part_name, part_path));\n \n-        res.size_of_part = calculatePartSizeSafe(res.part, log);\n+        res.size_of_part = calculatePartSizeSafe(res.part, log.load());\n         auto part_size_str = res.size_of_part ? formatReadableSizeWithBinarySuffix(*res.size_of_part) : \"failed to calculate size\";\n \n         LOG_ERROR(log,\n@@ -1327,7 +1326,7 @@ MergeTreeData::LoadPartResult MergeTreeData::loadDataPart(\n     if (part_disk_ptr->exists(marker_path))\n     {\n         /// NOTE: getBytesOnDisk() cannot be used here, since it may be zero if checksums.txt does not exist.\n-        res.size_of_part = calculatePartSizeSafe(res.part, log);\n+        res.size_of_part = calculatePartSizeSafe(res.part, log.load());\n         res.is_broken = true;\n \n         auto part_size_str = res.size_of_part ? formatReadableSizeWithBinarySuffix(*res.size_of_part) : \"failed to calculate size\";\n@@ -2114,7 +2113,7 @@ size_t MergeTreeData::clearOldTemporaryDirectories(const String & root_path, siz\n                     {\n                         /// Actually we don't rely on temporary_directories_lifetime when removing old temporaries directories,\n                         /// it's just an extra level of protection just in case we have a bug.\n-                        LOG_INFO(LogFrequencyLimiter(log, 10), \"{} is in use (by merge/mutation/INSERT) (consider increasing temporary_directories_lifetime setting)\", full_path);\n+                        LOG_INFO(LogFrequencyLimiter(log.load(), 10), \"{} is in use (by merge/mutation/INSERT) (consider increasing temporary_directories_lifetime setting)\", full_path);\n                         continue;\n                     }\n                     else if (!disk->exists(it->path()))\n@@ -2734,8 +2733,7 @@ void MergeTreeData::rename(const String & new_table_path, const StorageID & new_\n void MergeTreeData::renameInMemory(const StorageID & new_table_id)\n {\n     IStorage::renameInMemory(new_table_id);\n-    std::atomic_store(&log_name, std::make_shared<String>(new_table_id.getNameForLogs()));\n-    log = getLogger(*log_name);\n+    log.store(new_table_id.getNameForLogs());\n }\n \n void MergeTreeData::dropAllData()\n@@ -6249,13 +6247,13 @@ ReservationPtr MergeTreeData::tryReserveSpacePreferringTTLRules(\n                     log,\n                     \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but volume was not found\",\n                     move_ttl_entry->destination_name,\n-                    *std::atomic_load(&log_name));\n+                    log.loadName());\n             else if (move_ttl_entry->destination_type == DataDestinationType::DISK && !move_ttl_entry->if_exists)\n                 LOG_WARNING(\n                     log,\n                     \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but disk was not found\",\n                     move_ttl_entry->destination_name,\n-                    *std::atomic_load(&log_name));\n+                    log.loadName());\n         }\n         else if (is_insert && !perform_ttl_move_on_insert)\n         {\n@@ -6264,7 +6262,7 @@ ReservationPtr MergeTreeData::tryReserveSpacePreferringTTLRules(\n                 \"TTL move on insert to {} {} for table {} is disabled\",\n                 (move_ttl_entry->destination_type == DataDestinationType::VOLUME ? \"volume\" : \"disk\"),\n                 move_ttl_entry->destination_name,\n-                *std::atomic_load(&log_name));\n+                log.loadName());\n         }\n         else\n         {\n@@ -6280,13 +6278,13 @@ ReservationPtr MergeTreeData::tryReserveSpacePreferringTTLRules(\n                         log,\n                         \"Would like to reserve space on volume '{}' by TTL rule of table '{}' but there is not enough space\",\n                         move_ttl_entry->destination_name,\n-                        *std::atomic_load(&log_name));\n+                        log.loadName());\n                 else if (move_ttl_entry->destination_type == DataDestinationType::DISK)\n                     LOG_WARNING(\n                         log,\n                         \"Would like to reserve space on disk '{}' by TTL rule of table '{}' but there is not enough space\",\n                         move_ttl_entry->destination_name,\n-                        *std::atomic_load(&log_name));\n+                        log.loadName());\n             }\n         }\n     }\n@@ -7989,7 +7987,7 @@ bool MergeTreeData::insertQueryIdOrThrowNoLock(const String & query_id, size_t m\n         throw Exception(\n             ErrorCodes::TOO_MANY_SIMULTANEOUS_QUERIES,\n             \"Too many simultaneous queries for table {}. Maximum is: {}\",\n-            *std::atomic_load(&log_name),\n+            log.loadName(),\n             max_queries);\n     query_id_set.insert(query_id);\n     return true;\n@@ -8181,7 +8179,7 @@ ReservationPtr MergeTreeData::balancedReservation(\n                     }\n \n                     // Record submerging big parts in the tagger to clean them up.\n-                    tagger_ptr->emplace(*this, part_name, std::move(covered_parts), log);\n+                    tagger_ptr->emplace(*this, part_name, std::move(covered_parts), log.load());\n                 }\n             }\n         }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex caef247500a8..29aafcc3a13d 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -462,7 +462,7 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// Load the set of data parts from disk. Call once - immediately after the object is created.\n     void loadDataParts(bool skip_sanity_checks, std::optional<std::unordered_set<std::string>> expected_parts);\n \n-    String getLogName() const { return *std::atomic_load(&log_name); }\n+    String getLogName() const { return log.loadName(); }\n \n     Int64 getMaxBlockNumber() const;\n \n@@ -1115,10 +1115,7 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     /// Engine-specific methods\n     BrokenPartCallback broken_part_callback;\n \n-    /// log_name will change during table RENAME. Use atomic_shared_ptr to allow concurrent RW.\n-    /// NOTE clang-14 doesn't have atomic_shared_ptr yet. Use std::atomic* operations for now.\n-    std::shared_ptr<String> log_name;\n-    LoggerPtr log;\n+    AtomicLogger log;\n \n     /// Storage settings.\n     /// Use get and set to receive readonly versions.\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex 7e6c5ca39243..b402191f8953 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -683,7 +683,7 @@ std::optional<MergeTreeMutationStatus> StorageMergeTree::getIncompleteMutationsS\n \n     const auto & mutation_entry = current_mutation_it->second;\n \n-    auto txn = tryGetTransactionForMutation(mutation_entry, log);\n+    auto txn = tryGetTransactionForMutation(mutation_entry, log.load());\n     /// There's no way a transaction may finish before a mutation that was started by the transaction.\n     /// But sometimes we need to check status of an unrelated mutation, in this case we don't care about transactions.\n     assert(txn || mutation_entry.tid.isPrehistoric() || from_another_mutation);\n@@ -829,7 +829,7 @@ CancellationCode StorageMergeTree::killMutation(const String & mutation_id)\n     if (!to_kill)\n         return CancellationCode::NotFound;\n \n-    if (auto txn = tryGetTransactionForMutation(*to_kill, log))\n+    if (auto txn = tryGetTransactionForMutation(*to_kill, log.load()))\n     {\n         LOG_TRACE(log, \"Cancelling transaction {} which had started mutation {}\", to_kill->tid, mutation_id);\n         TransactionLog::instance().rollbackTransaction(txn);\n@@ -1222,7 +1222,7 @@ MergeMutateSelectedEntryPtr StorageMergeTree::selectPartsToMutate(\n             if (!part->version.isVisible(first_mutation_tid.start_csn, first_mutation_tid))\n                 continue;\n \n-            txn = tryGetTransactionForMutation(mutations_begin_it->second, log);\n+            txn = tryGetTransactionForMutation(mutations_begin_it->second, log.load());\n             if (!txn)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Cannot find transaction {} that has started mutation {} \"\n                                 \"that is going to be applied to part {}\",\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex c82721d2a18f..9c2f9dba485a 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -320,7 +320,7 @@ StorageReplicatedMergeTree::StorageReplicatedMergeTree(\n                     attach,\n                     [this] (const std::string & name) { enqueuePartForCheck(name); })\n     , zookeeper_name(zkutil::extractZooKeeperName(zookeeper_path_))\n-    , zookeeper_path(zkutil::extractZooKeeperPath(zookeeper_path_, /* check_starts_with_slash */ !attach, log))\n+    , zookeeper_path(zkutil::extractZooKeeperPath(zookeeper_path_, /* check_starts_with_slash */ !attach, log.load()))\n     , replica_name(replica_name_)\n     , replica_path(fs::path(zookeeper_path) / \"replicas\" / replica_name_)\n     , reader(*this)\n@@ -812,7 +812,7 @@ bool StorageReplicatedMergeTree::createTableIfNotExists(const StorageMetadataPtr\n             else\n             {\n                 auto metadata_drop_lock = zkutil::EphemeralNodeHolder::existing(drop_lock_path, *zookeeper);\n-                if (!removeTableNodesFromZooKeeper(zookeeper, zookeeper_path, metadata_drop_lock, log))\n+                if (!removeTableNodesFromZooKeeper(zookeeper, zookeeper_path, metadata_drop_lock, log.load()))\n                 {\n                     /// Someone is recursively removing table right now, we cannot create new table until old one is removed\n                     continue;\n@@ -1128,7 +1128,7 @@ void StorageReplicatedMergeTree::drop()\n             if (lost_part_count > 0)\n                 LOG_INFO(log, \"Dropping table with non-zero lost_part_count equal to {}\", lost_part_count);\n         }\n-        dropReplica(zookeeper, zookeeper_path, replica_name, log, getSettings(), &has_metadata_in_zookeeper);\n+        dropReplica(zookeeper, zookeeper_path, replica_name, log.load(), getSettings(), &has_metadata_in_zookeeper);\n     }\n }\n \n@@ -4181,7 +4181,7 @@ void StorageReplicatedMergeTree::startBeingLeader()\n         return;\n     }\n \n-    zkutil::checkNoOldLeaders(log, *zookeeper, fs::path(zookeeper_path) / \"leader_election\");\n+    zkutil::checkNoOldLeaders(log.load(), *zookeeper, fs::path(zookeeper_path) / \"leader_election\");\n \n     LOG_INFO(log, \"Became leader\");\n     is_leader = true;\n@@ -4275,7 +4275,7 @@ void StorageReplicatedMergeTree::waitForUniquePartsToBeFetchedByOtherReplicas(St\n \n     auto zookeeper = getZooKeeperIfTableShutDown();\n \n-    auto unique_parts_set = findReplicaUniqueParts(replica_name, zookeeper_path, format_version, zookeeper, log);\n+    auto unique_parts_set = findReplicaUniqueParts(replica_name, zookeeper_path, format_version, zookeeper, log.load());\n     if (unique_parts_set.empty())\n     {\n         LOG_INFO(log, \"Will not wait for unique parts to be fetched because we don't have any unique parts\");\n@@ -9348,7 +9348,7 @@ StorageReplicatedMergeTree::unlockSharedData(const IMergeTreeDataPart & part, co\n \n     return unlockSharedDataByID(\n         part.getUniqueId(), shared_id, part.info, replica_name,\n-        part.getDataPartStorage().getDiskType(), zookeeper, *getSettings(), log, zookeeper_path, format_version);\n+        part.getDataPartStorage().getDiskType(), zookeeper, *getSettings(), log.load(), zookeeper_path, format_version);\n }\n \n namespace\n@@ -10301,7 +10301,7 @@ void StorageReplicatedMergeTree::backupData(\n         bool exists = false;\n         Strings mutation_ids;\n         {\n-            ZooKeeperRetriesControl retries_ctl(\"getMutations\", log, zookeeper_retries_info, nullptr);\n+            ZooKeeperRetriesControl retries_ctl(\"getMutations\", log.load(), zookeeper_retries_info, nullptr);\n             retries_ctl.retryLoop([&]()\n             {\n                 if (!zookeeper || zookeeper->expired())\n@@ -10320,7 +10320,7 @@ void StorageReplicatedMergeTree::backupData(\n                 bool mutation_id_exists = false;\n                 String mutation;\n \n-                ZooKeeperRetriesControl retries_ctl(\"getMutation\", log, zookeeper_retries_info, nullptr);\n+                ZooKeeperRetriesControl retries_ctl(\"getMutation\", log.load(), zookeeper_retries_info, nullptr);\n                 retries_ctl.retryLoop([&]()\n                 {\n                     if (!zookeeper || zookeeper->expired())\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_log.cpp b/src/Common/tests/gtest_log.cpp\nindex 419aac370d6a..622497fe2f56 100644\n--- a/src/Common/tests/gtest_log.cpp\n+++ b/src/Common/tests/gtest_log.cpp\n@@ -32,7 +32,6 @@ TEST(Logger, TestLog)\n         LOG_TEST(log, \"Hello World\");\n \n         EXPECT_EQ(oss.str(), \"Hello World\\n\");\n-        Poco::Logger::destroy(\"TestLogger\");\n     }\n \n     {   /// Test logs invisible for other levels\n@@ -45,8 +44,6 @@ TEST(Logger, TestLog)\n             LOG_TEST(log, \"Hello World\");\n \n             EXPECT_EQ(oss.str(), \"\");\n-\n-            Poco::Logger::destroy(std::string{level} + \"_Logger\");\n         }\n     }\n \ndiff --git a/tests/config/users.d/readonly.xml b/tests/config/users.d/readonly.xml\nindex 0fe1e3fe6d94..799de11decfc 100644\n--- a/tests/config/users.d/readonly.xml\n+++ b/tests/config/users.d/readonly.xml\n@@ -9,7 +9,8 @@\n     <users>\n         <readonly>\n             <password></password>\n-            <networks incl=\"networks\" replace=\"replace\">\n+\n+            <networks>\n                 <ip>::1</ip>\n                 <ip>127.0.0.1</ip>\n             </networks>\ndiff --git a/tests/config/users.d/session_log_test.xml b/tests/config/users.d/session_log_test.xml\nindex cc2c2c5fcde8..f93b0efd8284 100644\n--- a/tests/config/users.d/session_log_test.xml\n+++ b/tests/config/users.d/session_log_test.xml\n@@ -18,7 +18,8 @@\n     <users>\n         <session_log_test_xml_user>\n             <no_password></no_password>\n-            <networks incl=\"networks\" replace=\"replace\">\n+\n+            <networks>\n                 <ip>::1</ip>\n                 <ip>127.0.0.1</ip>\n             </networks>\n",
  "problem_statement": "Data race on logger in ReplicatedMergeTree\nhttps://s3.amazonaws.com/clickhouse-test-reports/56864/0c82926b951fc475f4b8bdc4f1000785c0d4664e/integration_tests__tsan__[6_6]//home/ubuntu/actions-runner/_work/_temp/test/output_dir/integration_run_parallel0_0.log\r\n\r\n```\r\nE           Exception: Sanitizer assert found for instance ==================\r\nE           WARNING: ThreadSanitizer: data race (pid=1)\r\nE             Write of size 8 at 0x7b88002aabf8 by thread T679 (mutexes: write M0, write M1, write M2, write M3):\r\nE               #0 std::__1::enable_if<is_move_constructible<Poco::Logger*>::value && is_move_assignable<Poco::Logger*>::value, void>::type std::__1::swap[abi:v15000]<Poco::Logger*>(Poco::Logger*&, Poco::Logger*&) build_docker/./contrib/llvm-project/libcxx/include/__utility/swap.h:37:7 (clickhouse+0x19c5dd74) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #1 std::__1::shared_ptr<Poco::Logger>::swap[abi:v15000](std::__1::shared_ptr<Poco::Logger>&) build_docker/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:761:9 (clickhouse+0x19c5dd74)\r\nE               #2 std::__1::shared_ptr<Poco::Logger>::operator=[abi:v15000](std::__1::shared_ptr<Poco::Logger>&&) build_docker/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:723:38 (clickhouse+0x19c5dd74)\r\nE               #3 DB::MergeTreeData::renameInMemory(DB::StorageID const&) build_docker/./src/Storages/MergeTree/MergeTreeData.cpp:2738:9 (clickhouse+0x19c5dd74)\r\nE               #4 DB::DatabaseAtomic::renameTable(std::__1::shared_ptr<DB::Context const>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::IDatabase&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, bool) build_docker/./src/Databases/DatabaseAtomic.cpp:287:12 (clickhouse+0x176dc7df) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #5 DB::DatabaseReplicated::renameTable(std::__1::shared_ptr<DB::Context const>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::IDatabase&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, bool) build_docker/./src/Databases/DatabaseReplicated.cpp:1375:21 (clickhouse+0x1771ffe2) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #6 DB::InterpreterRenameQuery::executeToTables(DB::ASTRenameQuery const&, std::__1::vector<DB::RenameDescription, std::__1::allocator<DB::RenameDescription>> const&, std::__1::map<DB::UniqueTableName, std::__1::unique_ptr<DB::DDLGuard, std::__1::default_delete<DB::DDLGuard>>, std::__1::less<DB::UniqueTableName>, std::__1::allocator<std::__1::pair<DB::UniqueTableName const, std::__1::unique_ptr<DB::DDLGuard, std::__1::default_delete<DB::DDLGuard>>>>>&) build_docker/./src/Interpreters/InterpreterRenameQuery.cpp:142:27 (clickhouse+0x187a931a) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #7 DB::InterpreterRenameQuery::execute() build_docker/./src/Interpreters/InterpreterRenameQuery.cpp:76:16 (clickhouse+0x187a7529) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #8 DB::executeQueryImpl(char const*, char const*, std::__1::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) build_docker/./src/Interpreters/executeQuery.cpp:1108:40 (clickhouse+0x18d180aa) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #9 DB::executeQuery(DB::ReadBuffer&, DB::WriteBuffer&, bool, std::__1::shared_ptr<DB::Context>, std::__1::function<void (DB::QueryResultDetails const&)>, DB::QueryFlags, std::__1::optional<DB::FormatSettings> const&, std::__1::function<void (DB::IOutputFormat&)>) build_docker/./src/Interpreters/executeQuery.cpp:1397:34 (clickhouse+0x18d1c59a) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #10 DB::DDLWorker::tryExecuteQuery(DB::DDLTaskBase&, std::__1::shared_ptr<zkutil::ZooKeeper> const&) build_docker/./src/Interpreters/DDLWorker.cpp:497:9 (clickhouse+0x17bc4a50) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #11 DB::DDLWorker::processTask(DB::DDLTaskBase&, std::__1::shared_ptr<zkutil::ZooKeeper> const&) build_docker/./src/Interpreters/DDLWorker.cpp:661:17 (clickhouse+0x17bc2493) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #12 DB::DDLWorker::scheduleTasks(bool) build_docker/./src/Interpreters/DDLWorker.cpp:439:13 (clickhouse+0x17bc00f2) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #13 DB::DDLWorker::runMainThread() build_docker/./src/Interpreters/DDLWorker.cpp:1147:13 (clickhouse+0x17bb9749) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #14 decltype(*std::declval<DB::DDLWorker*&>().*std::declval<void (DB::DDLWorker::*&)()>()()) std::__1::__invoke[abi:v15000]<void (DB::DDLWorker::*&)(), DB::DDLWorker*&, void>(void (DB::DDLWorker::*&)(), DB::DDLWorker*&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:359:23 (clickhouse+0x17bd289f) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #15 decltype(auto) std::__1::__apply_tuple_impl[abi:v15000]<void (DB::DDLWorker::*&)(), std::__1::tuple<DB::DDLWorker*>&, 0ul>(void (DB::DDLWorker::*&)(), std::__1::tuple<DB::DDLWorker*>&, std::__1::__tuple_indices<0ul>) build_docker/./contrib/llvm-project/libcxx/include/tuple:1789:1 (clickhouse+0x17bd289f)\r\nE               #16 decltype(auto) std::__1::apply[abi:v15000]<void (DB::DDLWorker::*&)(), std::__1::tuple<DB::DDLWorker*>&>(void (DB::DDLWorker::*&)(), std::__1::tuple<DB::DDLWorker*>&) build_docker/./contrib/llvm-project/libcxx/include/tuple:1798:1 (clickhouse+0x17bd289f)\r\nE               #17 ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<void (DB::DDLWorker::*)(), DB::DDLWorker*>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&)::'lambda'()::operator()() build_docker/./src/Common/ThreadPool.h:223:13 (clickhouse+0x17bd289f)\r\nE               #18 decltype(std::declval<void (DB::DDLWorker::*)()>()(std::declval<DB::DDLWorker*>())) std::__1::__invoke[abi:v15000]<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<void (DB::DDLWorker::*)(), DB::DDLWorker*>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&)::'lambda'()&>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:394:23 (clickhouse+0x17bd27e1) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #19 void std::__1::__invoke_void_return_wrapper<void, true>::__call<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<void (DB::DDLWorker::*)(), DB::DDLWorker*>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&)::'lambda'()&>(ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<void (DB::DDLWorker::*)(), DB::DDLWorker*>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&)::'lambda'()&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:479:9 (clickhouse+0x17bd27e1)\r\nE               #20 std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<void (DB::DDLWorker::*)(), DB::DDLWorker*>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&)::'lambda'(), void ()>::operator()[abi:v15000]() build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:235:12 (clickhouse+0x17bd27e1)\r\nE               #21 void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<true>::ThreadFromGlobalPoolImpl<void (DB::DDLWorker::*)(), DB::DDLWorker*>(void (DB::DDLWorker::*&&)(), DB::DDLWorker*&&)::'lambda'(), void ()>>(std::__1::__function::__policy_storage const*) build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:716:16 (clickhouse+0x17bd27e1)\r\nE               #22 std::__1::__function::__policy_func<void ()>::operator()[abi:v15000]() const build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:848:16 (clickhouse+0xf7c168e) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #23 std::__1::function<void ()>::operator()() const build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:1187:12 (clickhouse+0xf7c168e)\r\nE               #24 ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) build_docker/./src/Common/ThreadPool.cpp:455:13 (clickhouse+0xf7c168e)\r\nE               #25 void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()::operator()() const build_docker/./src/Common/ThreadPool.cpp:217:73 (clickhouse+0xf7c7551) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #26 decltype(std::declval<void>()()) std::__1::__invoke[abi:v15000]<void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>(void&&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:394:23 (clickhouse+0xf7c7551)\r\nE               #27 void std::__1::__thread_execute[abi:v15000]<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>(std::__1::tuple<void, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>&, std::__1::__tuple_indices<>) build_docker/./contrib/llvm-project/libcxx/include/thread:284:5 (clickhouse+0xf7c7551)\r\nE               #28 void* std::__1::__thread_proxy[abi:v15000]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>>(void*) build_docker/./contrib/llvm-project/libcxx/include/thread:295:5 (clickhouse+0xf7c7551)\r\nE           \r\nE             Previous read of size 8 at 0x7b88002aabf8 by thread T286 (mutexes: write M4):\r\nE               #0 DB::StorageReplicatedMergeTree::mergeSelectingTask() build_docker/./src/Storages/StorageReplicatedMergeTree.cpp:3828:9 (clickhouse+0x196c3e5c) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #1 DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3::operator()() const build_docker/./src/Storages/StorageReplicatedMergeTree.cpp:357:107 (clickhouse+0x1976c1c1) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #2 decltype(std::declval<DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3&>()()) std::__1::__invoke[abi:v15000]<DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3&>(DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:394:23 (clickhouse+0x1976c1c1)\r\nE               #3 void std::__1::__invoke_void_return_wrapper<void, true>::__call<DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3&>(DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:479:9 (clickhouse+0x1976c1c1)\r\nE               #4 std::__1::__function::__default_alloc_func<DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3, void ()>::operator()[abi:v15000]() build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:235:12 (clickhouse+0x1976c1c1)\r\nE               #5 void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<DB::StorageReplicatedMergeTree::StorageReplicatedMergeTree(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, bool, DB::StorageID const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::StorageInMemoryMetadata const&, std::__1::shared_ptr<DB::Context>, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char>> const&, DB::MergeTreeData::MergingParams const&, std::__1::unique_ptr<DB::MergeTreeSettings, std::__1::default_delete<DB::MergeTreeSettings>>, bool, DB::RenamingRestrictions, bool)::$_3, void ()>>(std::__1::__function::__policy_storage const*) build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:716:16 (clickhouse+0x1976c1c1)\r\nE               #6 std::__1::__function::__policy_func<void ()>::operator()[abi:v15000]() const build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:848:16 (clickhouse+0x170b6fb7) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #7 std::__1::function<void ()>::operator()() const build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:1187:12 (clickhouse+0x170b6fb7)\r\nE               #8 DB::BackgroundSchedulePoolTaskInfo::execute() build_docker/./src/Core/BackgroundSchedulePool.cpp:106:9 (clickhouse+0x170b6fb7)\r\nE               #9 DB::BackgroundSchedulePool::threadFunction() build_docker/./src/Core/BackgroundSchedulePool.cpp:304:19 (clickhouse+0x170ba5cd) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #10 DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0::operator()() const build_docker/./src/Core/BackgroundSchedulePool.cpp:170:79 (clickhouse+0x170baeea) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #11 decltype(std::declval<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&>()()) std::__1::__invoke[abi:v15000]<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:394:23 (clickhouse+0x170baeea)\r\nE               #12 decltype(auto) std::__1::__apply_tuple_impl[abi:v15000]<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&, std::__1::tuple<>&>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&, std::__1::tuple<>&, std::__1::__tuple_indices<>) build_docker/./contrib/llvm-project/libcxx/include/tuple:1789:1 (clickhouse+0x170baeea)\r\nE               #13 decltype(auto) std::__1::apply[abi:v15000]<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&, std::__1::tuple<>&>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&, std::__1::tuple<>&) build_docker/./contrib/llvm-project/libcxx/include/tuple:1798:1 (clickhouse+0x170baeea)\r\nE               #14 ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&)::'lambda'()::operator()() build_docker/./src/Common/ThreadPool.h:223:13 (clickhouse+0x170baeea)\r\nE               #15 decltype(std::declval<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>()()) std::__1::__invoke[abi:v15000]<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&)::'lambda'()&>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:394:23 (clickhouse+0x170baeea)\r\nE               #16 void std::__1::__invoke_void_return_wrapper<void, true>::__call<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&)::'lambda'()&>(ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&)::'lambda'()&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:479:9 (clickhouse+0x170baeea)\r\nE               #17 std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&)::'lambda'(), void ()>::operator()[abi:v15000]() build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:235:12 (clickhouse+0x170baeea)\r\nE               #18 void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0>(DB::BackgroundSchedulePool::BackgroundSchedulePool(unsigned long, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, StrongTypedef<unsigned long, CurrentMetrics::MetricTag>, char const*)::$_0&&)::'lambda'(), void ()>>(std::__1::__function::__policy_storage const*) build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:716:16 (clickhouse+0x170baeea)\r\nE               #19 std::__1::__function::__policy_func<void ()>::operator()[abi:v15000]() const build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:848:16 (clickhouse+0xf7c168e) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #20 std::__1::function<void ()>::operator()() const build_docker/./contrib/llvm-project/libcxx/include/__functional/function.h:1187:12 (clickhouse+0xf7c168e)\r\nE               #21 ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) build_docker/./src/Common/ThreadPool.cpp:455:13 (clickhouse+0xf7c168e)\r\nE               #22 void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()::operator()() const build_docker/./src/Common/ThreadPool.cpp:217:73 (clickhouse+0xf7c7551) (BuildId: 748c3368327f42298218329f6ddd3220642d34e9)\r\nE               #23 decltype(std::declval<void>()()) std::__1::__invoke[abi:v15000]<void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>(void&&) build_docker/./contrib/llvm-project/libcxx/include/__functional/invoke.h:394:23 (clickhouse+0xf7c7551)\r\nE               #24 void std::__1::__thread_execute[abi:v15000]<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>(std::__1::tuple<void, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>&, std::__1::__tuple_indices<>) build_docker/./contrib/llvm-project/libcxx/include/thread:284:5 (clickhouse+0xf7c7551)\r\nE               #25 void* std::__1::__thread_proxy[abi:v15000]<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct>>, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, Priority, std::__1::optional<unsigned long>, bool)::'lambda0'()>>(void*) build_docker/./contrib/llvm-project/libcxx/include/thread:295:5 (clickhouse+0xf7c7551)\r\n```\n",
  "hints_text": "Related to https://github.com/ClickHouse/ClickHouse/pull/58831 cc @kitaisreal \r\n\r\nLet's fix or revert :see_no_evil: \nLet's fix.",
  "created_at": "2024-01-26T16:36:05Z"
}