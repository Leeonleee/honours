{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62186,
  "instance_id": "ClickHouse__ClickHouse-62186",
  "issue_numbers": [
    "62113"
  ],
  "base_commit": "e037e68130ef487429710c372ba269c665b7778a",
  "patch": "diff --git a/src/Analyzer/QueryTreeBuilder.cpp b/src/Analyzer/QueryTreeBuilder.cpp\nindex df80f46b3cd1..7f7d7a828854 100644\n--- a/src/Analyzer/QueryTreeBuilder.cpp\n+++ b/src/Analyzer/QueryTreeBuilder.cpp\n@@ -444,8 +444,8 @@ QueryTreeNodePtr QueryTreeBuilder::buildSortList(const ASTPtr & order_by_express\n             nulls_sort_direction = order_by_element.nulls_direction == 1 ? SortDirection::ASCENDING : SortDirection::DESCENDING;\n \n         std::shared_ptr<Collator> collator;\n-        if (order_by_element.collation)\n-            collator = std::make_shared<Collator>(order_by_element.collation->as<ASTLiteral &>().value.get<String &>());\n+        if (order_by_element.getCollation())\n+            collator = std::make_shared<Collator>(order_by_element.getCollation()->as<ASTLiteral &>().value.get<String &>());\n \n         const auto & sort_expression_ast = order_by_element.children.at(0);\n         auto sort_expression = buildExpression(sort_expression_ast, context);\n@@ -455,12 +455,12 @@ QueryTreeNodePtr QueryTreeBuilder::buildSortList(const ASTPtr & order_by_express\n             std::move(collator),\n             order_by_element.with_fill);\n \n-        if (order_by_element.fill_from)\n-            sort_node->getFillFrom() = buildExpression(order_by_element.fill_from, context);\n-        if (order_by_element.fill_to)\n-            sort_node->getFillTo() = buildExpression(order_by_element.fill_to, context);\n-        if (order_by_element.fill_step)\n-            sort_node->getFillStep() = buildExpression(order_by_element.fill_step, context);\n+        if (order_by_element.getFillFrom())\n+            sort_node->getFillFrom() = buildExpression(order_by_element.getFillFrom(), context);\n+        if (order_by_element.getFillTo())\n+            sort_node->getFillTo() = buildExpression(order_by_element.getFillTo(), context);\n+        if (order_by_element.getFillStep())\n+            sort_node->getFillStep() = buildExpression(order_by_element.getFillStep(), context);\n \n         list_node->getNodes().push_back(std::move(sort_node));\n     }\ndiff --git a/src/Analyzer/SortNode.cpp b/src/Analyzer/SortNode.cpp\nindex 8e9913af442c..b9d93511b84b 100644\n--- a/src/Analyzer/SortNode.cpp\n+++ b/src/Analyzer/SortNode.cpp\n@@ -120,17 +120,18 @@ ASTPtr SortNode::toASTImpl(const ConvertToASTOptions & options) const\n \n     result->nulls_direction_was_explicitly_specified = nulls_sort_direction.has_value();\n \n-    result->with_fill = with_fill;\n-    result->fill_from = hasFillFrom() ? getFillFrom()->toAST(options) : nullptr;\n-    result->fill_to = hasFillTo() ? getFillTo()->toAST(options) : nullptr;\n-    result->fill_step = hasFillStep() ? getFillStep()->toAST(options) : nullptr;\n     result->children.push_back(getExpression()->toAST(options));\n \n     if (collator)\n-    {\n-        result->children.push_back(std::make_shared<ASTLiteral>(Field(collator->getLocale())));\n-        result->collation = result->children.back();\n-    }\n+        result->setCollation(std::make_shared<ASTLiteral>(Field(collator->getLocale())));\n+\n+    result->with_fill = with_fill;\n+    if (hasFillFrom())\n+        result->setFillFrom(getFillFrom()->toAST(options));\n+    if (hasFillTo())\n+        result->setFillTo(getFillTo()->toAST(options));\n+    if (hasFillStep())\n+        result->setFillStep(getFillStep()->toAST(options));\n \n     return result;\n }\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex 6bbf03bb1e07..5864b35799e5 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1165,13 +1165,13 @@ static FillColumnDescription getWithFillDescription(const ASTOrderByElement & or\n {\n     FillColumnDescription descr;\n \n-    if (order_by_elem.fill_from)\n-        std::tie(descr.fill_from, descr.fill_from_type) = getWithFillFieldValue(order_by_elem.fill_from, context);\n-    if (order_by_elem.fill_to)\n-        std::tie(descr.fill_to, descr.fill_to_type) = getWithFillFieldValue(order_by_elem.fill_to, context);\n+    if (order_by_elem.getFillFrom())\n+        std::tie(descr.fill_from, descr.fill_from_type) = getWithFillFieldValue(order_by_elem.getFillFrom(), context);\n+    if (order_by_elem.getFillTo())\n+        std::tie(descr.fill_to, descr.fill_to_type) = getWithFillFieldValue(order_by_elem.getFillTo(), context);\n \n-    if (order_by_elem.fill_step)\n-        std::tie(descr.fill_step, descr.step_kind) = getWithFillStep(order_by_elem.fill_step, context);\n+    if (order_by_elem.getFillStep())\n+        std::tie(descr.fill_step, descr.step_kind) = getWithFillStep(order_by_elem.getFillStep(), context);\n     else\n         descr.fill_step = order_by_elem.direction;\n \n@@ -1217,8 +1217,8 @@ SortDescription InterpreterSelectQuery::getSortDescription(const ASTSelectQuery\n         const auto & order_by_elem = elem->as<ASTOrderByElement &>();\n \n         std::shared_ptr<Collator> collator;\n-        if (order_by_elem.collation)\n-            collator = std::make_shared<Collator>(order_by_elem.collation->as<ASTLiteral &>().value.get<String>());\n+        if (order_by_elem.getCollation())\n+            collator = std::make_shared<Collator>(order_by_elem.getCollation()->as<ASTLiteral &>().value.get<String>());\n \n         if (order_by_elem.with_fill)\n         {\ndiff --git a/src/Interpreters/RewriteOrderByVisitor.cpp b/src/Interpreters/RewriteOrderByVisitor.cpp\nindex 694dec84b7a0..26817b70dc05 100644\n--- a/src/Interpreters/RewriteOrderByVisitor.cpp\n+++ b/src/Interpreters/RewriteOrderByVisitor.cpp\n@@ -39,9 +39,8 @@ void RewriteOrderBy::visit(ASTPtr & ast, Data &)\n         {\n             // clone w/o children\n             auto clone = std::make_shared<ASTOrderByElement>(*order_by_elem);\n-            clone->children.clear();\n \n-            clone->children.emplace_back(identifier);\n+            clone->children[0] = identifier;\n             new_order_by->children.emplace_back(clone);\n         }\n         if (!new_order_by->children.empty())\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex b71a8e3681d9..a341dae32fa1 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -277,7 +277,7 @@ void optimizeDuplicatesInOrderBy(const ASTSelectQuery * select_query)\n         const auto & order_by_elem = elem->as<ASTOrderByElement &>();\n \n         if (order_by_elem.with_fill /// Always keep elements WITH FILL as they affects other.\n-            || elems_set.emplace(name, order_by_elem.collation ? order_by_elem.collation->getColumnName() : \"\").second)\n+            || elems_set.emplace(name, order_by_elem.getCollation() ? order_by_elem.getCollation()->getColumnName() : \"\").second)\n             unique_elems.emplace_back(elem);\n     }\n \ndiff --git a/src/Parsers/ASTOrderByElement.cpp b/src/Parsers/ASTOrderByElement.cpp\nindex 318849812aa5..be0416359a18 100644\n--- a/src/Parsers/ASTOrderByElement.cpp\n+++ b/src/Parsers/ASTOrderByElement.cpp\n@@ -31,7 +31,7 @@ void ASTOrderByElement::formatImpl(const FormatSettings & settings, FormatState\n             << (settings.hilite ? hilite_none : \"\");\n     }\n \n-    if (collation)\n+    if (auto collation = getCollation())\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" COLLATE \" << (settings.hilite ? hilite_none : \"\");\n         collation->formatImpl(settings, state, frame);\n@@ -40,17 +40,17 @@ void ASTOrderByElement::formatImpl(const FormatSettings & settings, FormatState\n     if (with_fill)\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" WITH FILL\" << (settings.hilite ? hilite_none : \"\");\n-        if (fill_from)\n+        if (auto fill_from = getFillFrom())\n         {\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" FROM \" << (settings.hilite ? hilite_none : \"\");\n             fill_from->formatImpl(settings, state, frame);\n         }\n-        if (fill_to)\n+        if (auto fill_to = getFillTo())\n         {\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" TO \" << (settings.hilite ? hilite_none : \"\");\n             fill_to->formatImpl(settings, state, frame);\n         }\n-        if (fill_step)\n+        if (auto fill_step = getFillStep())\n         {\n             settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" STEP \" << (settings.hilite ? hilite_none : \"\");\n             fill_step->formatImpl(settings, state, frame);\ndiff --git a/src/Parsers/ASTOrderByElement.h b/src/Parsers/ASTOrderByElement.h\nindex 4cebc30be31b..6edf84d7bde9 100644\n--- a/src/Parsers/ASTOrderByElement.h\n+++ b/src/Parsers/ASTOrderByElement.h\n@@ -10,18 +10,34 @@ namespace DB\n   */\n class ASTOrderByElement : public IAST\n {\n+private:\n+    enum class Child : uint8_t\n+    {\n+        EXPRESSION,\n+        COLLATION,\n+        FILL_FROM,\n+        FILL_TO,\n+        FILL_STEP,\n+    };\n+\n public:\n     int direction = 0; /// 1 for ASC, -1 for DESC\n     int nulls_direction = 0; /// Same as direction for NULLS LAST, opposite for NULLS FIRST.\n     bool nulls_direction_was_explicitly_specified = false;\n \n+    bool with_fill = false;\n+\n     /** Collation for locale-specific string comparison. If empty, then sorting done by bytes. */\n-    ASTPtr collation;\n+    void setCollation(ASTPtr node) { setChild(Child::COLLATION, node); }\n+    void setFillFrom(ASTPtr node)  { setChild(Child::FILL_FROM, node); }\n+    void setFillTo(ASTPtr node)    { setChild(Child::FILL_TO, node);   }\n+    void setFillStep(ASTPtr node)  { setChild(Child::FILL_STEP, node); }\n \n-    bool with_fill = false;\n-    ASTPtr fill_from;\n-    ASTPtr fill_to;\n-    ASTPtr fill_step;\n+    /** Collation for locale-specific string comparison. If empty, then sorting done by bytes. */\n+    ASTPtr getCollation() const { return getChild(Child::COLLATION); }\n+    ASTPtr getFillFrom()  const { return getChild(Child::FILL_FROM); }\n+    ASTPtr getFillTo()    const { return getChild(Child::FILL_TO);   }\n+    ASTPtr getFillStep()  const { return getChild(Child::FILL_STEP); }\n \n     String getID(char) const override { return \"OrderByElement\"; }\n \n@@ -36,6 +52,34 @@ class ASTOrderByElement : public IAST\n \n protected:\n     void formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const override;\n+private:\n+\n+    ASTPtr getChild(Child child) const\n+    {\n+        auto it = positions.find(child);\n+        if (it != positions.end())\n+            return children[it->second];\n+        return {};\n+    }\n+\n+    void setChild(Child child, ASTPtr node)\n+    {\n+        if (node == nullptr)\n+            return;\n+\n+        auto it = positions.find(child);\n+        if (it != positions.end())\n+        {\n+            children[it->second] = node;\n+        }\n+        else\n+        {\n+            positions[child] = children.size();\n+            children.push_back(node);\n+        }\n+    }\n+\n+    std::unordered_map<Child, size_t> positions;\n };\n \n }\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 67f4a306292d..d4ad210b3151 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -2120,17 +2120,16 @@ bool ParserOrderByElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expect\n \n     auto elem = std::make_shared<ASTOrderByElement>();\n \n+    elem->children.push_back(expr_elem);\n+\n     elem->direction = direction;\n     elem->nulls_direction = nulls_direction;\n     elem->nulls_direction_was_explicitly_specified = nulls_direction_was_explicitly_specified;\n-    elem->collation = locale_node;\n+    elem->setCollation(locale_node);\n     elem->with_fill = has_with_fill;\n-    elem->fill_from = fill_from;\n-    elem->fill_to = fill_to;\n-    elem->fill_step = fill_step;\n-    elem->children.push_back(expr_elem);\n-    if (locale_node)\n-        elem->children.push_back(locale_node);\n+    elem->setFillFrom(fill_from);\n+    elem->setFillTo(fill_to);\n+    elem->setFillStep(fill_step);\n \n     node = elem;\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03033_analyzer_query_parameters.reference b/tests/queries/0_stateless/03033_analyzer_query_parameters.reference\nnew file mode 100644\nindex 000000000000..6ed281c757a9\n--- /dev/null\n+++ b/tests/queries/0_stateless/03033_analyzer_query_parameters.reference\n@@ -0,0 +1,2 @@\n+1\n+1\ndiff --git a/tests/queries/0_stateless/03033_analyzer_query_parameters.sh b/tests/queries/0_stateless/03033_analyzer_query_parameters.sh\nnew file mode 100755\nindex 000000000000..c821791e4378\n--- /dev/null\n+++ b/tests/queries/0_stateless/03033_analyzer_query_parameters.sh\n@@ -0,0 +1,8 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+clickhouse-local --param_rounding 1 --query \"SELECT 1 AS x ORDER BY x WITH FILL STEP {rounding:UInt32} SETTINGS allow_experimental_analyzer = 1\"\n+clickhouse-local --param_rounding 1 --query \"SELECT 1 AS x ORDER BY x WITH FILL STEP {rounding:UInt32} SETTINGS allow_experimental_analyzer = 0\"\n",
  "problem_statement": "Query parameters stopped working in the WITH FILL modifier\n```\r\n$ clickhouse-local --param_rounding 1 --query \"SELECT {rounding:UInt32}\"\r\n1\r\n$ clickhouse-local --param_rounding 1 --query \"SELECT 1 AS x ORDER BY x WITH FILL STEP {rounding:UInt32}\"\r\nCode: 456. DB::Exception: Query parameter `rounding` was not set. (UNKNOWN_QUERY_PARAMETER)\r\n\r\n$ programs/server/clickhouse-24.1 local --param_rounding 1 --query \"SELECT 1 AS x ORDER BY x WITH FILL STEP {rounding:UInt32}\"\r\n1\r\n```\n",
  "hints_text": "",
  "created_at": "2024-04-02T15:56:07Z",
  "modified_files": [
    "src/Analyzer/QueryTreeBuilder.cpp",
    "src/Analyzer/SortNode.cpp",
    "src/Interpreters/InterpreterSelectQuery.cpp",
    "src/Interpreters/RewriteOrderByVisitor.cpp",
    "src/Interpreters/TreeOptimizer.cpp",
    "src/Parsers/ASTOrderByElement.cpp",
    "src/Parsers/ASTOrderByElement.h",
    "src/Parsers/ExpressionElementParsers.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03033_analyzer_query_parameters.reference",
    "b/tests/queries/0_stateless/03033_analyzer_query_parameters.sh"
  ]
}