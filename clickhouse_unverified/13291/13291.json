{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 13291,
  "instance_id": "ClickHouse__ClickHouse-13291",
  "issue_numbers": [
    "12958"
  ],
  "base_commit": "b69e6b935b96901604f2db376d6df5fdad6922d3",
  "patch": "diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex 27294a576759..a807a9fa4ee0 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -33,7 +33,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int BAD_TYPE_OF_FIELD;\n     extern const int NOT_IMPLEMENTED;\n     extern const int NO_SUCH_COLUMN_IN_TABLE;\n     extern const int INCOMPATIBLE_TYPE_OF_JOIN;\n@@ -158,25 +157,21 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n     }\n     else if (strictness == ASTTableJoin::Strictness::Asof)\n     {\n-        if (kind != ASTTableJoin::Kind::Left and kind != ASTTableJoin::Kind::Inner)\n-            throw Exception(\"ASOF only supports LEFT and INNER as base joins\", ErrorCodes::NOT_IMPLEMENTED);\n+        /// @note ASOF JOIN is not INNER. It's better avoid use of 'INNER ASOF' combination in messages.\n+        /// In fact INNER means 'LEFT SEMI ASOF' while LEFT means 'LEFT OUTER ASOF'.\n+        if (!isLeft(kind) && !isInner(kind))\n+            throw Exception(\"Wrong ASOF JOIN type. Only ASOF and LEFT ASOF joins are supported\", ErrorCodes::NOT_IMPLEMENTED);\n \n-        const IColumn * asof_column = key_columns.back();\n-        size_t asof_size;\n+        if (key_columns.size() <= 1)\n+            throw Exception(\"ASOF join needs at least one equi-join column\", ErrorCodes::SYNTAX_ERROR);\n \n-        asof_type = AsofRowRefs::getTypeSize(asof_column, asof_size);\n-        if (!asof_type)\n-        {\n-            std::string msg = \"ASOF join not supported for type: \";\n-            msg += asof_column->getFamilyName();\n-            throw Exception(msg, ErrorCodes::BAD_TYPE_OF_FIELD);\n-        }\n+        if (right_table_keys.getByName(key_names_right.back()).type->isNullable())\n+            throw Exception(\"ASOF join over right table Nullable column is not implemented\", ErrorCodes::NOT_IMPLEMENTED);\n \n+        size_t asof_size;\n+        asof_type = AsofRowRefs::getTypeSize(*key_columns.back(), asof_size);\n         key_columns.pop_back();\n \n-        if (key_columns.empty())\n-            throw Exception(\"ASOF join cannot be done without a joining column\", ErrorCodes::SYNTAX_ERROR);\n-\n         /// this is going to set up the appropriate hash table for the direct lookup part of the join\n         /// However, this does not depend on the size of the asof join key (as that goes into the BST)\n         /// Therefore, add it back in such that it can be extracted appropriately from the full stored\n@@ -248,11 +243,6 @@ HashJoin::Type HashJoin::chooseMethod(const ColumnRawPtrs & key_columns, Sizes &\n     return Type::hashed;\n }\n \n-static const IColumn * extractAsofColumn(const ColumnRawPtrs & key_columns)\n-{\n-    return key_columns.back();\n-}\n-\n template<typename KeyGetter, bool is_asof_join>\n static KeyGetter createKeyGetter(const ColumnRawPtrs & key_columns, const Sizes & key_sizes)\n {\n@@ -428,14 +418,15 @@ namespace\n         }\n \n         static ALWAYS_INLINE void insertAsof(HashJoin & join, Map & map, KeyGetter & key_getter, Block * stored_block, size_t i, Arena & pool,\n-                                             const IColumn * asof_column)\n+                                             const IColumn & asof_column)\n         {\n             auto emplace_result = key_getter.emplaceKey(map, i, pool);\n             typename Map::mapped_type * time_series_map = &emplace_result.getMapped();\n \n+            TypeIndex asof_type = *join.getAsofType();\n             if (emplace_result.isInserted())\n-                time_series_map = new (time_series_map) typename Map::mapped_type(join.getAsofType());\n-            time_series_map->insert(join.getAsofType(), asof_column, stored_block, i);\n+                time_series_map = new (time_series_map) typename Map::mapped_type(asof_type);\n+            time_series_map->insert(asof_type, asof_column, stored_block, i);\n         }\n     };\n \n@@ -451,7 +442,7 @@ namespace\n \n         const IColumn * asof_column [[maybe_unused]] = nullptr;\n         if constexpr (is_asof_join)\n-            asof_column = extractAsofColumn(key_columns);\n+            asof_column = key_columns.back();\n \n         auto key_getter = createKeyGetter<KeyGetter, is_asof_join>(key_columns, key_sizes);\n \n@@ -461,7 +452,7 @@ namespace\n                 continue;\n \n             if constexpr (is_asof_join)\n-                Inserter<Map, KeyGetter>::insertAsof(join, map, key_getter, stored_block, i, pool, asof_column);\n+                Inserter<Map, KeyGetter>::insertAsof(join, map, key_getter, stored_block, i, pool, *asof_column);\n             else if constexpr (mapped_one)\n                 Inserter<Map, KeyGetter>::insertOne(join, map, key_getter, stored_block, i, pool);\n             else\n@@ -614,21 +605,22 @@ class AddedColumns\n public:\n     using TypeAndNames = std::vector<std::pair<decltype(ColumnWithTypeAndName::type), decltype(ColumnWithTypeAndName::name)>>;\n \n-    AddedColumns(const Block & sample_block_with_columns_to_add,\n-                 const Block & block_with_columns_to_add,\n+    AddedColumns(const Block & block_with_columns_to_add,\n                  const Block & block,\n                  const Block & saved_block_sample,\n-                 const ColumnsWithTypeAndName & extras,\n-                 const HashJoin & join_,\n+                 const HashJoin & join,\n                  const ColumnRawPtrs & key_columns_,\n-                 const Sizes & key_sizes_)\n-        : join(join_)\n-        , key_columns(key_columns_)\n+                 const Sizes & key_sizes_,\n+                 bool is_asof_join)\n+        : key_columns(key_columns_)\n         , key_sizes(key_sizes_)\n         , rows_to_add(block.rows())\n-        , need_filter(false)\n+        , asof_type(join.getAsofType())\n+        , asof_inequality(join.getAsofInequality())\n     {\n-        size_t num_columns_to_add = sample_block_with_columns_to_add.columns();\n+        size_t num_columns_to_add = block_with_columns_to_add.columns();\n+        if (is_asof_join)\n+            ++num_columns_to_add;\n \n         columns.reserve(num_columns_to_add);\n         type_name.reserve(num_columns_to_add);\n@@ -641,8 +633,12 @@ class AddedColumns\n                 addColumn(src_column);\n         }\n \n-        for (const auto & extra : extras)\n-            addColumn(extra);\n+        if (is_asof_join)\n+        {\n+            const ColumnWithTypeAndName & right_asof_column = join.rightAsofKeyColumn();\n+            addColumn(right_asof_column);\n+            left_asof_key = key_columns.back();\n+        }\n \n         for (auto & tn : type_name)\n             right_indexes.push_back(saved_block_sample.getPositionByName(tn.second));\n@@ -680,18 +676,25 @@ class AddedColumns\n         }\n     }\n \n-    const HashJoin & join;\n+    TypeIndex asofType() const { return *asof_type; }\n+    ASOF::Inequality asofInequality() const { return asof_inequality; }\n+    const IColumn & leftAsofKey() const { return *left_asof_key; }\n+\n     const ColumnRawPtrs & key_columns;\n     const Sizes & key_sizes;\n     size_t rows_to_add;\n     std::unique_ptr<IColumn::Offsets> offsets_to_replicate;\n-    bool need_filter;\n+    bool need_filter = false;\n \n private:\n     TypeAndNames type_name;\n     MutableColumns columns;\n     std::vector<size_t> right_indexes;\n     size_t lazy_defaults_count = 0;\n+    /// for ASOF\n+    std::optional<TypeIndex> asof_type;\n+    ASOF::Inequality asof_inequality;\n+    const IColumn * left_asof_key = nullptr;\n \n     void addColumn(const ColumnWithTypeAndName & src_column)\n     {\n@@ -760,10 +763,6 @@ NO_INLINE IColumn::Filter joinRightColumns(const Map & map, AddedColumns & added\n     if constexpr (need_replication)\n         added_columns.offsets_to_replicate = std::make_unique<IColumn::Offsets>(rows);\n \n-    const IColumn * asof_column [[maybe_unused]] = nullptr;\n-    if constexpr (is_asof_join)\n-        asof_column = extractAsofColumn(added_columns.key_columns);\n-\n     auto key_getter = createKeyGetter<KeyGetter, is_asof_join>(added_columns.key_columns, added_columns.key_sizes);\n \n     IColumn::Offset current_offset = 0;\n@@ -790,8 +789,11 @@ NO_INLINE IColumn::Filter joinRightColumns(const Map & map, AddedColumns & added\n \n             if constexpr (is_asof_join)\n             {\n-                const HashJoin & join = added_columns.join;\n-                if (const RowRef * found = mapped.findAsof(join.getAsofType(), join.getAsofInequality(), asof_column, i))\n+                TypeIndex asof_type = added_columns.asofType();\n+                ASOF::Inequality asof_inequality = added_columns.asofInequality();\n+                const IColumn & left_asof_key = added_columns.leftAsofKey();\n+\n+                if (const RowRef * found = mapped.findAsof(asof_type, asof_inequality, left_asof_key, i))\n                 {\n                     setUsed<need_filter>(filter, i);\n                     mapped.setUsed();\n@@ -932,11 +934,11 @@ void HashJoin::joinBlockImpl(\n \n     /// Rare case, when keys are constant or low cardinality. To avoid code bloat, simply materialize them.\n     Columns materialized_keys = JoinCommon::materializeColumns(block, key_names_left);\n-    ColumnRawPtrs key_columns = JoinCommon::getRawPointers(materialized_keys);\n+    ColumnRawPtrs left_key_columns = JoinCommon::getRawPointers(materialized_keys);\n \n     /// Keys with NULL value in any column won't join to anything.\n     ConstNullMapPtr null_map{};\n-    ColumnPtr null_map_holder = extractNestedColumnsAndNullMap(key_columns, null_map);\n+    ColumnPtr null_map_holder = extractNestedColumnsAndNullMap(left_key_columns, null_map);\n \n     size_t existing_columns = block.columns();\n \n@@ -957,12 +959,8 @@ void HashJoin::joinBlockImpl(\n       *  but they will not be used at this stage of joining (and will be in `AdderNonJoined`), and they need to be skipped.\n       * For ASOF, the last column is used as the ASOF column\n       */\n-    ColumnsWithTypeAndName extras;\n-    if constexpr (is_asof_join)\n-        extras.push_back(right_table_keys.getByName(key_names_right.back()));\n \n-    AddedColumns added_columns(sample_block_with_columns_to_add, block_with_columns_to_add, block, savedBlockSample(),\n-                               extras, *this, key_columns, key_sizes);\n+    AddedColumns added_columns(block_with_columns_to_add, block, savedBlockSample(), *this, left_key_columns, key_sizes, is_asof_join);\n     bool has_required_right_keys = (required_right_keys.columns() != 0);\n     added_columns.need_filter = need_filter || has_required_right_keys;\n \ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex 67d83d27a6dc..fb879e2c5077 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -191,10 +191,16 @@ class HashJoin : public IJoin\n \n     ASTTableJoin::Kind getKind() const { return kind; }\n     ASTTableJoin::Strictness getStrictness() const { return strictness; }\n-    TypeIndex getAsofType() const { return *asof_type; }\n+    const std::optional<TypeIndex> & getAsofType() const { return asof_type; }\n     ASOF::Inequality getAsofInequality() const { return asof_inequality; }\n     bool anyTakeLastRow() const { return any_take_last_row; }\n \n+    const ColumnWithTypeAndName & rightAsofKeyColumn() const\n+    {\n+        /// It should be nullable if nullable_right_side is true\n+        return savedBlockSample().getByName(key_names_right.back());\n+    }\n+\n     /// Different types of keys for maps.\n     #define APPLY_FOR_JOIN_VARIANTS(M) \\\n         M(key8)                        \\\ndiff --git a/src/Interpreters/RowRefs.cpp b/src/Interpreters/RowRefs.cpp\nindex 879a0bcf88ef..a206456f1b66 100644\n--- a/src/Interpreters/RowRefs.cpp\n+++ b/src/Interpreters/RowRefs.cpp\n@@ -12,6 +12,11 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int BAD_TYPE_OF_FIELD;\n+}\n+\n namespace\n {\n \n@@ -56,7 +61,7 @@ AsofRowRefs::AsofRowRefs(TypeIndex type)\n     callWithType(type, call);\n }\n \n-void AsofRowRefs::insert(TypeIndex type, const IColumn * asof_column, const Block * block, size_t row_num)\n+void AsofRowRefs::insert(TypeIndex type, const IColumn & asof_column, const Block * block, size_t row_num)\n {\n     auto call = [&](const auto & t)\n     {\n@@ -64,9 +69,9 @@ void AsofRowRefs::insert(TypeIndex type, const IColumn * asof_column, const Bloc\n         using LookupPtr = typename Entry<T>::LookupPtr;\n \n         using ColumnType = std::conditional_t<IsDecimalNumber<T>, ColumnDecimal<T>, ColumnVector<T>>;\n-        auto * column = typeid_cast<const ColumnType *>(asof_column);\n+        const auto & column = typeid_cast<const ColumnType &>(asof_column);\n \n-        T key = column->getElement(row_num);\n+        T key = column.getElement(row_num);\n         auto entry = Entry<T>(key, RowRef(block, row_num));\n         std::get<LookupPtr>(lookups)->insert(entry);\n     };\n@@ -74,7 +79,7 @@ void AsofRowRefs::insert(TypeIndex type, const IColumn * asof_column, const Bloc\n     callWithType(type, call);\n }\n \n-const RowRef * AsofRowRefs::findAsof(TypeIndex type, ASOF::Inequality inequality, const IColumn * asof_column, size_t row_num) const\n+const RowRef * AsofRowRefs::findAsof(TypeIndex type, ASOF::Inequality inequality, const IColumn & asof_column, size_t row_num) const\n {\n     const RowRef * out = nullptr;\n \n@@ -88,8 +93,8 @@ const RowRef * AsofRowRefs::findAsof(TypeIndex type, ASOF::Inequality inequality\n         using LookupPtr = typename EntryType::LookupPtr;\n \n         using ColumnType = std::conditional_t<IsDecimalNumber<T>, ColumnDecimal<T>, ColumnVector<T>>;\n-        auto * column = typeid_cast<const ColumnType *>(asof_column);\n-        T key = column->getElement(row_num);\n+        const auto & column = typeid_cast<const ColumnType &>(asof_column);\n+        T key = column.getElement(row_num);\n         auto & typed_lookup = std::get<LookupPtr>(lookups);\n \n         if (is_strict)\n@@ -102,9 +107,9 @@ const RowRef * AsofRowRefs::findAsof(TypeIndex type, ASOF::Inequality inequality\n     return out;\n }\n \n-std::optional<TypeIndex> AsofRowRefs::getTypeSize(const IColumn * asof_column, size_t & size)\n+std::optional<TypeIndex> AsofRowRefs::getTypeSize(const IColumn & asof_column, size_t & size)\n {\n-    TypeIndex idx = asof_column->getDataType();\n+    TypeIndex idx = asof_column.getDataType();\n \n     switch (idx)\n     {\n@@ -152,8 +157,7 @@ std::optional<TypeIndex> AsofRowRefs::getTypeSize(const IColumn * asof_column, s\n             break;\n     }\n \n-    size = 0;\n-    return {};\n+    throw Exception(\"ASOF join not supported for type: \" + std::string(asof_column.getFamilyName()), ErrorCodes::BAD_TYPE_OF_FIELD);\n }\n \n }\ndiff --git a/src/Interpreters/RowRefs.h b/src/Interpreters/RowRefs.h\nindex e8231b1c233f..fc035bf626e2 100644\n--- a/src/Interpreters/RowRefs.h\n+++ b/src/Interpreters/RowRefs.h\n@@ -233,13 +233,13 @@ class AsofRowRefs\n     AsofRowRefs() {}\n     AsofRowRefs(TypeIndex t);\n \n-    static std::optional<TypeIndex> getTypeSize(const IColumn * asof_column, size_t & type_size);\n+    static std::optional<TypeIndex> getTypeSize(const IColumn & asof_column, size_t & type_size);\n \n     // This will be synchronized by the rwlock mutex in Join.h\n-    void insert(TypeIndex type, const IColumn * asof_column, const Block * block, size_t row_num);\n+    void insert(TypeIndex type, const IColumn & asof_column, const Block * block, size_t row_num);\n \n     // This will internally synchronize\n-    const RowRef * findAsof(TypeIndex type, ASOF::Inequality inequality, const IColumn * asof_column, size_t row_num) const;\n+    const RowRef * findAsof(TypeIndex type, ASOF::Inequality inequality, const IColumn & asof_column, size_t row_num) const;\n \n private:\n     // Lookups can be stored in a HashTable because it is memmovable\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01428_nullable_asof_join.reference b/tests/queries/0_stateless/01428_nullable_asof_join.reference\nnew file mode 100644\nindex 000000000000..f04655fefaad\n--- /dev/null\n+++ b/tests/queries/0_stateless/01428_nullable_asof_join.reference\n@@ -0,0 +1,20 @@\n+left asof using\n+0\t\\N\t0\t\\N\tUInt8\tNullable(UInt8)\tUInt8\tNullable(UInt8)\n+1\t\\N\t1\t\\N\tUInt8\tNullable(UInt8)\tUInt8\tNullable(UInt8)\n+1\t1\t2\t2\tUInt8\tNullable(UInt8)\tUInt8\tNullable(UInt8)\n+0\t\\N\t0\t\\N\tUInt8\tNullable(UInt8)\tNullable(UInt8)\tNullable(UInt8)\n+1\t\\N\t1\t\\N\tUInt8\tNullable(UInt8)\tNullable(UInt8)\tNullable(UInt8)\n+1\t1\t2\t2\tUInt8\tNullable(UInt8)\tNullable(UInt8)\tNullable(UInt8)\n+left asof on\n+0\t\\N\t0\t\\N\tUInt8\tNullable(UInt8)\tUInt8\tNullable(UInt8)\n+1\t\\N\t1\t\\N\tUInt8\tNullable(UInt8)\tUInt8\tNullable(UInt8)\n+1\t1\t2\t2\tUInt8\tNullable(UInt8)\tUInt8\tNullable(UInt8)\n+0\t\\N\t0\t\\N\tUInt8\tNullable(UInt8)\tNullable(UInt8)\tNullable(UInt8)\n+1\t\\N\t1\t\\N\tUInt8\tNullable(UInt8)\tNullable(UInt8)\tNullable(UInt8)\n+1\t1\t2\t2\tUInt8\tNullable(UInt8)\tNullable(UInt8)\tNullable(UInt8)\n+asof using\n+1\t1\t2\t2\tUInt8\tUInt8\tUInt8\tUInt8\n+1\t1\t2\t2\tUInt8\tUInt8\tNullable(UInt8)\tUInt8\n+asof on\n+1\t1\t2\t2\tUInt8\tUInt8\tUInt8\tUInt8\n+1\t1\t2\t2\tUInt8\tUInt8\tNullable(UInt8)\tUInt8\ndiff --git a/tests/queries/0_stateless/01428_nullable_asof_join.sql b/tests/queries/0_stateless/01428_nullable_asof_join.sql\nnew file mode 100644\nindex 000000000000..c812e6ecfab3\n--- /dev/null\n+++ b/tests/queries/0_stateless/01428_nullable_asof_join.sql\n@@ -0,0 +1,105 @@\n+SET join_use_nulls = 1;\n+\n+select 'left asof using';\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, 2 as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, 2 as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+select 'left asof on';\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, 2 as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, 2 as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF LEFT JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+select 'asof using';\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, 2 as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, 2 as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+USING(pk, dt)\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+select 'asof on';\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, 2 as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, 2 as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toUInt8(number) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;-- { serverError 48 }\n+\n+SELECT a.pk, b.pk, a.dt, b.dt, toTypeName(a.pk), toTypeName(b.pk), toTypeName(materialize(a.dt)), toTypeName(materialize(b.dt))\n+FROM (SELECT toUInt8(number) > 0 as pk, toNullable(toUInt8(number)) as dt FROM numbers(3)) a\n+ASOF JOIN (SELECT 1 as pk, toNullable(0) as dt) b\n+ON a.pk = b.pk AND a.dt >= b.dt\n+ORDER BY a.dt;-- { serverError 48 }\n",
  "problem_statement": "Segmentation fault when using ASOF LEFT JOIN with join_use_nulls=1\n**Describe the bug**\r\nClickHouse server crashes when using ASOF LEFT JOIN with join_use_nulls=1\r\n\r\n**How to reproduce**\r\n* 20.5.2.7 / 20.5.3.27\r\n\r\nMay require to run several times!\r\n\r\n```\r\nClickHouse client version 20.5.3.27 (official build).\r\nConnecting to server253:9000 as user default.\r\nConnected to ClickHouse server version 20.5.3 revision 54435.\r\n\r\nclickhouse-dev253 :) SELECT max(NULL)\r\n:-]   FROM (SELECT * FROM generateRandom('pk UInt32, dt DateTime', 0) LIMIT 1000000000 ) a\r\n:-]   ASOF LEFT JOIN ( SELECT * FROM generateRandom('pk UInt32, dt DateTime', 1) LIMIT 10000000 ) b\r\n:-]  USING (pk, dt) SETTINGS join_use_nulls=1;\r\n\r\nSELECT max(NULL)\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM generateRandom('pk UInt32, dt DateTime', 0)\r\n    LIMIT 1000000000\r\n) AS a\r\nASOF LEFT JOIN\r\n(\r\n    SELECT *\r\n    FROM generateRandom('pk UInt32, dt DateTime', 1)\r\n    LIMIT 10000000\r\n) AS b USING (pk, dt)\r\nSETTINGS join_use_nulls = 1\r\n\r\n\u2199 Progress: 120.72 million rows, 965.74 MB (17.42 million rows/s., 139.35 MB/s.)\r\nException on client:\r\nCode: 32. DB::Exception: Attempt to read after eof: while receiving packet from server253:9000\r\n\r\nConnecting to server253:9000 as user default.\r\nCode: 210. DB::NetException: Connection refused (server253:9000)\r\n```\r\n\r\nlog:\r\n```\r\n2020.07.27 18:22:38.285480 [ 151 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.07.27 18:22:38.285534 [ 151 ] {} <Fatal> BaseDaemon: (version 20.5.3.27 (official build), build id: 5820B4CE93C60E3C) (from thread 91) (query_id: e95c4596-610d-4049-ba64-0c1c83d1a53c) Received signal Segmentation fault (11)\r\n2020.07.27 18:22:38.285565 [ 151 ] {} <Fatal> BaseDaemon: Address: 0x7f6c2fa687b8 Access: read. Attempted access has violated the permissions assigned to the memory area.\r\n2020.07.27 18:22:38.285584 [ 151 ] {} <Fatal> BaseDaemon: Stack trace: 0x9790a7f 0xdc40de6 0xdcc5ccb 0xdc5dacf 0xdd8f2c3 0xdd91c20 0xe9331ec 0xe725910 0xe758df1 0xe75d576 0xe75dbc2 0x9625f47 0x9624433 0x7f6c6cf706db 0x7f6c6c88d88f\r\n2020.07.27 18:22:38.285664 [ 151 ] {} <Fatal> BaseDaemon: 3. DB::ColumnVector<unsigned int>::insertFrom(DB::IColumn const&, unsigned long) @ 0x9790a7f in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285687 [ 151 ] {} <Fatal> BaseDaemon: 4. ? @ 0xdc40de6 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285727 [ 151 ] {} <Fatal> BaseDaemon: 5. void DB::HashJoin::joinBlockImpl<(DB::ASTTableJoin::Kind)1, (DB::ASTTableJoin::Strictness)4, DB::HashJoin::MapsTemplate<DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> > >(DB::Block&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::Block const&, DB::HashJoin::MapsTemplate<DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> > const&) const @ 0xdcc5ccb in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285774 [ 151 ] {} <Fatal> BaseDaemon: 6. DB::HashJoin::joinBlock(DB::Block&, std::__1::shared_ptr<DB::ExtraBlock>&) @ 0xdc5dacf in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285794 [ 151 ] {} <Fatal> BaseDaemon: 7. DB::ExpressionAction::execute(DB::Block&, bool, std::__1::shared_ptr<DB::ExtraBlock>&) const @ 0xdd8f2c3 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285814 [ 151 ] {} <Fatal> BaseDaemon: 8. DB::ExpressionActions::execute(DB::Block&, bool) const @ 0xdd91c20 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285842 [ 151 ] {} <Fatal> BaseDaemon: 9. DB::ExpressionTransform::transform(DB::Chunk&) @ 0xe9331ec in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285869 [ 151 ] {} <Fatal> BaseDaemon: 10. DB::ISimpleTransform::work() @ 0xe725910 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285885 [ 151 ] {} <Fatal> BaseDaemon: 11. ? @ 0xe758df1 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285899 [ 151 ] {} <Fatal> BaseDaemon: 12. ? @ 0xe75d576 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285913 [ 151 ] {} <Fatal> BaseDaemon: 13. ? @ 0xe75dbc2 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285931 [ 151 ] {} <Fatal> BaseDaemon: 14. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x9625f47 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285946 [ 151 ] {} <Fatal> BaseDaemon: 15. ? @ 0x9624433 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.285969 [ 151 ] {} <Fatal> BaseDaemon: 16. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2020.07.27 18:22:38.285990 [ 151 ] {} <Fatal> BaseDaemon: 17. clone @ 0x12188f in /lib/x86_64-linux-gnu/libc-2.27.so\r\n2020.07.27 18:22:38.304851 [ 152 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.07.27 18:22:38.304955 [ 152 ] {} <Fatal> BaseDaemon: (version 20.5.3.27 (official build), build id: 5820B4CE93C60E3C) (from thread 138) (query_id: e95c4596-610d-4049-ba64-0c1c83d1a53c) Received signal Segmentation fault (11)\r\n2020.07.27 18:22:38.305007 [ 152 ] {} <Fatal> BaseDaemon: Address: 0x7f6c2fa68b40 Access: read. Attempted access has violated the permissions assigned to the memory area.\r\n2020.07.27 18:22:38.305035 [ 152 ] {} <Fatal> BaseDaemon: Stack trace: 0x9790a7f 0xdc40de6 0xdcc5ccb 0xdc5dacf 0xdd8f2c3 0xdd91c20 0xe9331ec 0xe725910 0xe758df1 0xe75d576 0xe75dbc2 0x9625f47 0x9624433 0x7f6c6cf706db 0x7f6c6c88d88f\r\n2020.07.27 18:22:38.305121 [ 152 ] {} <Fatal> BaseDaemon: 3. DB::ColumnVector<unsigned int>::insertFrom(DB::IColumn const&, unsigned long) @ 0x9790a7f in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305191 [ 152 ] {} <Fatal> BaseDaemon: 4. ? @ 0xdc40de6 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305241 [ 152 ] {} <Fatal> BaseDaemon: 5. void DB::HashJoin::joinBlockImpl<(DB::ASTTableJoin::Kind)1, (DB::ASTTableJoin::Strictness)4, DB::HashJoin::MapsTemplate<DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> > >(DB::Block&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::Block const&, DB::HashJoin::MapsTemplate<DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> > const&) const @ 0xdcc5ccb in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305290 [ 152 ] {} <Fatal> BaseDaemon: 6. DB::HashJoin::joinBlock(DB::Block&, std::__1::shared_ptr<DB::ExtraBlock>&) @ 0xdc5dacf in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305320 [ 152 ] {} <Fatal> BaseDaemon: 7. DB::ExpressionAction::execute(DB::Block&, bool, std::__1::shared_ptr<DB::ExtraBlock>&) const @ 0xdd8f2c3 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305350 [ 152 ] {} <Fatal> BaseDaemon: 8. DB::ExpressionActions::execute(DB::Block&, bool) const @ 0xdd91c20 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305379 [ 152 ] {} <Fatal> BaseDaemon: 9. DB::ExpressionTransform::transform(DB::Chunk&) @ 0xe9331ec in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305409 [ 152 ] {} <Fatal> BaseDaemon: 10. DB::ISimpleTransform::work() @ 0xe725910 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305435 [ 152 ] {} <Fatal> BaseDaemon: 11. ? @ 0xe758df1 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305468 [ 152 ] {} <Fatal> BaseDaemon: 12. ? @ 0xe75d576 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305493 [ 152 ] {} <Fatal> BaseDaemon: 13. ? @ 0xe75dbc2 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305524 [ 152 ] {} <Fatal> BaseDaemon: 14. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x9625f47 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305550 [ 152 ] {} <Fatal> BaseDaemon: 15. ? @ 0x9624433 in /usr/bin/clickhouse\r\n2020.07.27 18:22:38.305586 [ 152 ] {} <Fatal> BaseDaemon: 16. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2020.07.27 18:22:38.305620 [ 152 ] {} <Fatal> BaseDaemon: 17. clone @ 0x12188f in /lib/x86_64-linux-gnu/libc-2.27.so\r\n...\r\n```\n",
  "hints_text": "```\r\n=================================================================\r\n==30713==ERROR: AddressSanitizer: heap-buffer-overflow on address 0x60400222515c at pc 0x00000c4c0cf9 bp 0x7f86d7d26dc0 sp 0x7f86d7d26db8\r\nREAD of size 4 at 0x60400222515c thread T107 (QueryPipelineEx)\r\n==30713==WARNING: invalid path to external symbolizer!\r\n==30713==WARNING: Failed to use and restart external symbolizer!\r\n    #0 0xc4c0cf8  (/home/qoega/address-ch/output/binary/clickhouse+0xc4c0cf8)\r\n    #1 0x1b4bce0e  (/home/qoega/address-ch/output/binary/clickhouse+0x1b4bce0e)\r\n    #2 0x1b715ce8  (/home/qoega/address-ch/output/binary/clickhouse+0x1b715ce8)\r\n    #3 0x1b361780  (/home/qoega/address-ch/output/binary/clickhouse+0x1b361780)\r\n    #4 0x1b8c4426  (/home/qoega/address-ch/output/binary/clickhouse+0x1b8c4426)\r\n    #5 0x1b8d20bc  (/home/qoega/address-ch/output/binary/clickhouse+0x1b8d20bc)\r\n    #6 0x1d4498f3  (/home/qoega/address-ch/output/binary/clickhouse+0x1d4498f3)\r\n    #7 0x1d4485d8  (/home/qoega/address-ch/output/binary/clickhouse+0x1d4485d8)\r\n    #8 0x1c5df37d  (/home/qoega/address-ch/output/binary/clickhouse+0x1c5df37d)\r\n    #9 0x1d0b72e8  (/home/qoega/address-ch/output/binary/clickhouse+0x1d0b72e8)\r\n    #10 0x1d152fb9  (/home/qoega/address-ch/output/binary/clickhouse+0x1d152fb9)\r\n    #11 0x1d14ec96  (/home/qoega/address-ch/output/binary/clickhouse+0x1d14ec96)\r\n    #12 0x1d15472d  (/home/qoega/address-ch/output/binary/clickhouse+0x1d15472d)\r\n    #13 0xc1cd9c3  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cd9c3)\r\n    #14 0xc1d5757  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d5757)\r\n    #15 0x7f87be13a6da  (/lib/x86_64-linux-gnu/libpthread.so.0+0x76da)\r\n    #16 0x7f87bda57a3e  (/lib/x86_64-linux-gnu/libc.so.6+0x121a3e)\r\n\r\nAddress 0x60400222515c is a wild pointer.\r\nSUMMARY: AddressSanitizer: heap-buffer-overflow (/home/qoega/address-ch/output/binary/clickhouse+0xc4c0cf8)\r\nShadow bytes around the buggy address:\r\n  0x0c088043c9d0: fa fa 00 00 00 00 00 00 fa fa 00 00 00 00 00 00\r\n  0x0c088043c9e0: fa fa 00 00 00 00 00 00 fa fa 00 00 00 00 00 00\r\n  0x0c088043c9f0: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c088043ca00: fa fa fa fa fa fa fa fa fa fa 00 00 00 00 00 00\r\n  0x0c088043ca10: fa fa fa fa fa fa fa fa fa fa 00 00 00 00 00 00\r\n=>0x0c088043ca20: fa fa 00 00 00 00 00 00 fa fa fa[fa]fa fa fa fa\r\n  0x0c088043ca30: fa fa fa fa fa fa fa fa fa fa 00 00 00 00 00 00\r\n  0x0c088043ca40: fa fa 00 00 00 00 00 00 fa fa 00 00 00 00 00 00\r\n  0x0c088043ca50: fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa fa\r\n  0x0c088043ca60: fa fa fa fa fa fa fa fa fa fa 00 00 00 00 00 00\r\n  0x0c088043ca70: fa fa 00 00 00 00 00 00 fa fa fa fa fa fa fa fa\r\nShadow byte legend (one shadow byte represents 8 application bytes):\r\n  Addressable:           00\r\n  Partially addressable: 01 02 03 04 05 06 07\r\n  Heap left redzone:       fa\r\n  Freed heap region:       fd\r\n  Stack left redzone:      f1\r\n  Stack mid redzone:       f2\r\n  Stack right redzone:     f3\r\n  Stack after return:      f5\r\n  Stack use after scope:   f8\r\n  Global redzone:          f9\r\n  Global init order:       f6\r\n  Poisoned by user:        f7\r\n  Container overflow:      fc\r\n  Array cookie:            ac\r\n  Intra object redzone:    bb\r\n  ASan internal:           fe\r\n  Left alloca redzone:     ca\r\n  Right alloca redzone:    cb\r\n  Shadow gap:              cc\r\nThread T107 (QueryPipelineEx) created by T9 (BgSchPool/D) here:\r\n    #0 0xc00e51a  (/home/qoega/address-ch/output/binary/clickhouse+0xc00e51a)\r\n    #1 0xc1d39be  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d39be)\r\n    #2 0xc1cb132  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cb132)\r\n    #3 0xc1cc623  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cc623)\r\n    #4 0xc1d7c6a  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d7c6a)\r\n    #5 0xc1cf1f7  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cf1f7)\r\n    #6 0xc1ce92b  (/home/qoega/address-ch/output/binary/clickhouse+0xc1ce92b)\r\n    #7 0x1ca3e658  (/home/qoega/address-ch/output/binary/clickhouse+0x1ca3e658)\r\n    #8 0x1c5e29bf  (/home/qoega/address-ch/output/binary/clickhouse+0x1c5e29bf)\r\n    #9 0x1ce68fe5  (/home/qoega/address-ch/output/binary/clickhouse+0x1ce68fe5)\r\n    #10 0x1ce59c80  (/home/qoega/address-ch/output/binary/clickhouse+0x1ce59c80)\r\n    #11 0x1ce6b2c4  (/home/qoega/address-ch/output/binary/clickhouse+0x1ce6b2c4)\r\n    #12 0x1c4a3d55  (/home/qoega/address-ch/output/binary/clickhouse+0x1c4a3d55)\r\n    #13 0x1b2c1fcf  (/home/qoega/address-ch/output/binary/clickhouse+0x1b2c1fcf)\r\n    #14 0x1b2df32d  (/home/qoega/address-ch/output/binary/clickhouse+0x1b2df32d)\r\n    #15 0xc1d2472  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d2472)\r\n    #16 0xc1da346  (/home/qoega/address-ch/output/binary/clickhouse+0xc1da346)\r\n    #17 0xc1cd9c3  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cd9c3)\r\n    #18 0xc1d5757  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d5757)\r\n    #19 0x7f87be13a6da  (/lib/x86_64-linux-gnu/libpthread.so.0+0x76da)\r\n\r\nThread T9 (BgSchPool/D) created by T0 here:\r\n    #0 0xc00e51a  (/home/qoega/address-ch/output/binary/clickhouse+0xc00e51a)\r\n    #1 0xc1d39be  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d39be)\r\n    #2 0xc1cb132  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cb132)\r\n    #3 0xc1cc623  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cc623)\r\n    #4 0xc1d7c6a  (/home/qoega/address-ch/output/binary/clickhouse+0xc1d7c6a)\r\n    #5 0xc1cf1f7  (/home/qoega/address-ch/output/binary/clickhouse+0xc1cf1f7)\r\n    #6 0xc1ce92b  (/home/qoega/address-ch/output/binary/clickhouse+0xc1ce92b)\r\n    #7 0x1b2d074d  (/home/qoega/address-ch/output/binary/clickhouse+0x1b2d074d)\r\n    #8 0x1b2d67de  (/home/qoega/address-ch/output/binary/clickhouse+0x1b2d67de)\r\n    #9 0x1b7b9c1d  (/home/qoega/address-ch/output/binary/clickhouse+0x1b7b9c1d)\r\n    #10 0x1b7d6753  (/home/qoega/address-ch/output/binary/clickhouse+0x1b7d6753)\r\n    #11 0x1c1519d1  (/home/qoega/address-ch/output/binary/clickhouse+0x1c1519d1)\r\n    #12 0x1c15268d  (/home/qoega/address-ch/output/binary/clickhouse+0x1c15268d)\r\n    #13 0xc084c73  (/home/qoega/address-ch/output/binary/clickhouse+0xc084c73)\r\n    #14 0x234bbab3  (/home/qoega/address-ch/output/binary/clickhouse+0x234bbab3)\r\n    #15 0xc06e73d  (/home/qoega/address-ch/output/binary/clickhouse+0xc06e73d)\r\n    #16 0xc0bd02b  (/home/qoega/address-ch/output/binary/clickhouse+0xc0bd02b)\r\n    #17 0xc056707  (/home/qoega/address-ch/output/binary/clickhouse+0xc056707)\r\n    #18 0x7f87bd957b96  (/lib/x86_64-linux-gnu/libc.so.6+0x21b96)\r\n\r\n==30713==ABORTING\r\n2020.07.28 14:50:49.842853 [ 30752 ] {} <Trace> BaseDaemon: Received signal -3\r\n2020.07.28 14:50:49.843296 [ 2128 ] {} <Fatal> BaseDaemon: ########################################\r\n2020.07.28 14:50:49.843550 [ 2128 ] {} <Fatal> BaseDaemon: (version 20.7.1.1, build id: 04CED5988B0056EB) (from thread 31025) (query_id: b8accbe7-1327-4b9a-a2a8-0176aeb80e0f) Received signal Unknown signal -3 (-3)\r\n2020.07.28 14:50:49.843658 [ 2128 ] {} <Fatal> BaseDaemon: Sanitizer trap.\r\n2020.07.28 14:50:49.843742 [ 2128 ] {} <Fatal> BaseDaemon: Stack trace: 0xc19a2b7 0x1a905920 0xc03fd96 0xc027709 0xc0291be 0xc0299e8 0xc4c0cf9 0x1b4bce0f 0x1b715ce9 0x1b361781 0x1b8c4427 0x1b8d20bd 0x1d4498f4 0x1d4485d9 0x1c5df37e 0x1d0b72e9 0x1d152fba 0x1d14ec97 0x1d15472e 0xc1cd9c4 0xc1d5758 0x7f87be13a6db 0x7f87bda57a3f\r\n2020.07.28 14:50:49.844094 [ 2128 ] {} <Fatal> BaseDaemon: 0. /build/obj-x86_64-linux-gnu/../src/Common/StackTrace.cpp:291: StackTrace::StackTrace() @ 0xc19a2b7 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.846916 [ 2128 ] {} <Fatal> BaseDaemon: 1. /build/obj-x86_64-linux-gnu/../src/Common/CurrentThread.h:81: sanitizerDeathCallback() @ 0x1a905920 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.851321 [ 2128 ] {} <Fatal> BaseDaemon: 2. __sanitizer::Die() @ 0xc03fd96 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.855546 [ 2128 ] {} <Fatal> BaseDaemon: 3. ? @ 0xc027709 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.859746 [ 2128 ] {} <Fatal> BaseDaemon: 4. __asan::ReportGenericError(unsigned long, unsigned long, unsigned long, unsigned long, bool, unsigned long, unsigned int, bool) @ 0xc0291be in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.863938 [ 2128 ] {} <Fatal> BaseDaemon: 5. __asan_report_load4 @ 0xc0299e8 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.866894 [ 2128 ] {} <Fatal> BaseDaemon: 6. /build/obj-x86_64-linux-gnu/../src/Common/PODArray.h:387: DB::ColumnVector<unsigned int>::insertFrom(DB::IColumn const&, unsigned long) @ 0xc4c0cf9 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.881985 [ 2128 ] {} <Fatal> BaseDaemon: 7. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/vector:656: DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> DB::(anonymous namespace)::joinRightColumns<(DB::ASTTableJoin::Kind)1, (DB::ASTTableJoin::Strictness)4, DB::ColumnsHashing::HashMethodOneNumber<PairNoInit<unsigned int, DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> >, DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> const, unsigned int, false>, HashMapTable<unsigned int, HashMapCell<unsigned int, DB::JoinStuff::WithFlags<DB::AsofRowRefs, false>, HashCRC32<unsigned int>, HashTableNoState>, HashCRC32<unsigned int>, HashTableGrower<8ul>, Allocator<true, true> >, false, false>(HashMapTable<unsigned int, HashMapCell<unsigned int, DB::JoinStuff::WithFlags<DB::AsofRowRefs, false>, HashCRC32<unsigned int>, HashTableNoState>, HashCRC32<unsigned int>, HashTableGrower<8ul>, Allocator<true, true> > const&, DB::(anonymous namespace)::AddedColumns&, DB::PODArray<char8_t, 4096ul, Allocator<false, false>, 15ul, 16ul> const* const&) @ 0x1b4bce0f in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.920767 [ 2128 ] {} <Fatal> BaseDaemon: 8. /build/obj-x86_64-linux-gnu/../src/Interpreters/HashJoin.cpp:873: void DB::HashJoin::joinBlockImpl<(DB::ASTTableJoin::Kind)1, (DB::ASTTableJoin::Strictness)4, DB::HashJoin::MapsTemplate<DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> > >(DB::Block&, std::__1::vector<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::allocator<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > > > const&, DB::Block const&, DB::HashJoin::MapsTemplate<DB::JoinStuff::WithFlags<DB::AsofRowRefs, false> > const&) const @ 0x1b715ce9 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.923977 [ 2128 ] {} <Fatal> BaseDaemon: 9. /build/obj-x86_64-linux-gnu/../src/Interpreters/HashJoin.cpp:1213: DB::HashJoin::joinBlock(DB::Block&, std::__1::shared_ptr<DB::ExtraBlock>&) @ 0x1b361781 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.926690 [ 2128 ] {} <Fatal> BaseDaemon: 10. /build/obj-x86_64-linux-gnu/../src/Interpreters/ExpressionActions.cpp:337: DB::ExpressionAction::execute(DB::Block&, std::__1::shared_ptr<DB::ExtraBlock>&) const @ 0x1b8c4427 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.930007 [ 2128 ] {} <Fatal> BaseDaemon: 11. /build/obj-x86_64-linux-gnu/../src/Interpreters/ExpressionActions.cpp:694: DB::ExpressionActions::execute(DB::Block&, std::__1::shared_ptr<DB::ExtraBlock>&) const @ 0x1b8d20bd in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.933402 [ 2128 ] {} <Fatal> BaseDaemon: 12. /build/obj-x86_64-linux-gnu/../src/Processors/Transforms/InflatingExpressionTransform.cpp:67: DB::InflatingExpressionTransform::readExecute(DB::Chunk&) @ 0x1d4498f4 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.936746 [ 2128 ] {} <Fatal> BaseDaemon: 13. /build/obj-x86_64-linux-gnu/../src/Processors/Transforms/InflatingExpressionTransform.cpp:0: DB::InflatingExpressionTransform::transform(DB::Chunk&) @ 0x1d4485d9 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.943162 [ 2128 ] {} <Fatal> BaseDaemon: 14. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/type_traits:3695: DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x1c5df37e in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.946679 [ 2128 ] {} <Fatal> BaseDaemon: 15. /build/obj-x86_64-linux-gnu/../src/Processors/ISimpleTransform.cpp:99: DB::ISimpleTransform::work() @ 0x1d0b72e9 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.950591 [ 2128 ] {} <Fatal> BaseDaemon: 16. /build/obj-x86_64-linux-gnu/../src/Processors/Executors/PipelineExecutor.cpp:0: std::__1::__function::__func<DB::PipelineExecutor::addJob(DB::PipelineExecutor::ExecutionState*)::$_1, std::__1::allocator<DB::PipelineExecutor::addJob(DB::PipelineExecutor::ExecutionState*)::$_1>, void ()>::operator()() @ 0x1d152fba in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.954375 [ 2128 ] {} <Fatal> BaseDaemon: 17. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/functional:0: DB::PipelineExecutor::executeStepImpl(unsigned long, unsigned long, std::__1::atomic<bool>*) @ 0x1d14ec97 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.958353 [ 2128 ] {} <Fatal> BaseDaemon: 18. /build/obj-x86_64-linux-gnu/../src/Processors/Executors/PipelineExecutor.cpp:804: std::__1::__function::__func<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_6>(DB::PipelineExecutor::executeImpl(unsigned long)::$_6&&)::'lambda'(), std::__1::allocator<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PipelineExecutor::executeImpl(unsigned long)::$_6>(DB::PipelineExecutor::executeImpl(unsigned long)::$_6&&)::'lambda'()>, void ()>::operator()() @ 0x1d15472e in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.958680 [ 2128 ] {} <Fatal> BaseDaemon: 19. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/atomic:1036: ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0xc1cd9c4 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.959262 [ 2128 ] {} <Fatal> BaseDaemon: 20. /build/obj-x86_64-linux-gnu/../contrib/libcxx/include/memory:2615: void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda1'()> >(void*) @ 0xc1d5758 in /home/qoega/address-ch/output/binary/clickhouse\r\n2020.07.28 14:50:49.959391 [ 2128 ] {} <Fatal> BaseDaemon: 21. start_thread @ 0x76db in /lib/x86_64-linux-gnu/libpthread-2.27.so\r\n2020.07.28 14:50:49.959657 [ 2128 ] {} <Fatal> BaseDaemon: 22. /build/glibc-2ORdQG/glibc-2.27/misc/../sysdeps/unix/sysv/linux/x86_64/clone.S:97: __GI___clone @ 0x121a3f in /usr/lib/debug/lib/x86_64-linux-gnu/libc-2.27.so\r\n```\nCH vesion:20.3.13.127 \r\nI  have the same error. \r\n[#13101](https://github.com/ClickHouse/ClickHouse/issues/13101)\n> I have the same error.\r\n\r\nIt's not the same error.\r\n\r\n\nCrash is in `AddedColumns::appendFromBlock()` with block returned from `AsofRowRefs::findAsof()`.\r\nTrying to insert from ColumnNullable to ColumnVector for asof column.",
  "created_at": "2020-08-03T18:13:39Z"
}