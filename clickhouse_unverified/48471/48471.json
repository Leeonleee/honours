{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 48471,
  "instance_id": "ClickHouse__ClickHouse-48471",
  "issue_numbers": [
    "16414"
  ],
  "base_commit": "467ecf45e12cccfeb200378918636e168a0c5daa",
  "patch": "diff --git a/src/Functions/FunctionsCodingULID.cpp b/src/Functions/FunctionsCodingULID.cpp\nindex 3201578791ac..992f9cbf2d7a 100644\n--- a/src/Functions/FunctionsCodingULID.cpp\n+++ b/src/Functions/FunctionsCodingULID.cpp\n@@ -68,8 +68,7 @@ class FunctionULIDStringToDateTime : public IFunction\n         String timezone;\n         if (arguments.size() == 2)\n         {\n-            if (arguments[1].column)\n-                timezone = extractTimeZoneNameFromColumn(*arguments[1].column);\n+            timezone = extractTimeZoneNameFromColumn(arguments[1].column.get(), arguments[1].name);\n \n             if (timezone.empty())\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\ndiff --git a/src/Functions/castOrDefault.cpp b/src/Functions/castOrDefault.cpp\nindex f71675dcbad4..3ae4674b1687 100644\n--- a/src/Functions/castOrDefault.cpp\n+++ b/src/Functions/castOrDefault.cpp\n@@ -245,7 +245,8 @@ class FunctionCastOrDefaultTyped final : public IFunction\n         {\n             if (additional_argument_index < arguments.size())\n             {\n-                time_zone = extractTimeZoneNameFromColumn(*arguments[additional_argument_index].column);\n+                time_zone = extractTimeZoneNameFromColumn(arguments[additional_argument_index].column.get(),\n+                                                          arguments[additional_argument_index].name);\n                 ++additional_argument_index;\n             }\n         }\ndiff --git a/src/Functions/extractTimeZoneFromFunctionArguments.cpp b/src/Functions/extractTimeZoneFromFunctionArguments.cpp\nindex 5a20ca7e9626..7ed240fdbcfd 100644\n--- a/src/Functions/extractTimeZoneFromFunctionArguments.cpp\n+++ b/src/Functions/extractTimeZoneFromFunctionArguments.cpp\n@@ -17,14 +17,14 @@ namespace ErrorCodes\n }\n \n \n-std::string extractTimeZoneNameFromColumn(const IColumn & column)\n+std::string extractTimeZoneNameFromColumn(const IColumn * column, const String & column_name)\n {\n-    const ColumnConst * time_zone_column = checkAndGetColumnConst<ColumnString>(&column);\n+    const ColumnConst * time_zone_column = checkAndGetColumnConst<ColumnString>(column);\n \n     if (!time_zone_column)\n         throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                        \"Illegal column {} of time zone argument of function, must be constant string\",\n-                        column.getName());\n+                        \"Illegal column {} of time zone argument of function, must be a constant string\",\n+                        column_name);\n \n     return time_zone_column->getValue<String>();\n }\n@@ -33,9 +33,9 @@ std::string extractTimeZoneNameFromColumn(const IColumn & column)\n std::string extractTimeZoneNameFromFunctionArguments(const ColumnsWithTypeAndName & arguments, size_t time_zone_arg_num, size_t datetime_arg_num)\n {\n     /// Explicit time zone may be passed in last argument.\n-    if (arguments.size() == time_zone_arg_num + 1 && arguments[time_zone_arg_num].column)\n+    if (arguments.size() == time_zone_arg_num + 1)\n     {\n-        return extractTimeZoneNameFromColumn(*arguments[time_zone_arg_num].column);\n+        return extractTimeZoneNameFromColumn(arguments[time_zone_arg_num].column.get(), arguments[time_zone_arg_num].name);\n     }\n     else\n     {\n@@ -57,7 +57,7 @@ const DateLUTImpl & extractTimeZoneFromFunctionArguments(const ColumnsWithTypeAn\n {\n     if (arguments.size() == time_zone_arg_num + 1)\n     {\n-        std::string time_zone = extractTimeZoneNameFromColumn(*arguments[time_zone_arg_num].column);\n+        std::string time_zone = extractTimeZoneNameFromColumn(arguments[time_zone_arg_num].column.get(), arguments[time_zone_arg_num].name);\n         if (time_zone.empty())\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Provided time zone must be non-empty and be a valid time zone\");\n         return DateLUT::instance(time_zone);\ndiff --git a/src/Functions/extractTimeZoneFromFunctionArguments.h b/src/Functions/extractTimeZoneFromFunctionArguments.h\nindex 751d7a463f14..858be40def7e 100644\n--- a/src/Functions/extractTimeZoneFromFunctionArguments.h\n+++ b/src/Functions/extractTimeZoneFromFunctionArguments.h\n@@ -12,7 +12,7 @@ namespace DB\n \n class Block;\n \n-std::string extractTimeZoneNameFromColumn(const IColumn & column);\n+std::string extractTimeZoneNameFromColumn(const IColumn * column, const String & column_name);\n \n /// Determine working timezone either from optional argument with time zone name or from time zone in DateTime type of argument.\n /// Returns empty string if default time zone should be used.\ndiff --git a/src/Functions/toTimezone.cpp b/src/Functions/toTimezone.cpp\nindex ddac22d3173b..0a54e5a86b7c 100644\n--- a/src/Functions/toTimezone.cpp\n+++ b/src/Functions/toTimezone.cpp\n@@ -8,7 +8,6 @@\n #include <IO/WriteHelpers.h>\n #include <Common/assert_cast.h>\n \n-\n namespace DB\n {\n namespace ErrorCodes\n@@ -100,6 +99,7 @@ class ToTimeZoneOverloadResolver : public IFunctionOverloadResolver\n                 \"Should be DateTime or DateTime64\", arguments[0].type->getName(), getName());\n \n         String time_zone_name = extractTimeZoneNameFromFunctionArguments(arguments, 1, 0);\n+\n         if (which_type.isDateTime())\n             return std::make_shared<DataTypeDateTime>(time_zone_name);\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00515_enhanced_time_zones.sql b/tests/queries/0_stateless/00515_enhanced_time_zones.sql\nindex e555b6b87bca..f719ff70d7a3 100644\n--- a/tests/queries/0_stateless/00515_enhanced_time_zones.sql\n+++ b/tests/queries/0_stateless/00515_enhanced_time_zones.sql\n@@ -20,3 +20,17 @@ SELECT toTimeZone(toDateTime('2017-11-05 08:07:47', 'Asia/Istanbul'), 'Asia/Kolk\n SELECT toString(toDateTime('2017-11-05 08:07:47', 'Asia/Istanbul'));\n SELECT toString(toTimeZone(toDateTime('2017-11-05 08:07:47', 'Asia/Istanbul'), 'Asia/Kolkata'));\n SELECT toString(toDateTime('2017-11-05 08:07:47', 'Asia/Istanbul'), 'Asia/Kolkata');\n+\n+SELECT toTimeZone(dt, tz) FROM (\n+    SELECT toDateTime('2017-11-05 08:07:47', 'Asia/Istanbul') AS dt, arrayJoin(['Asia/Kolkata', 'UTC']) AS tz\n+); -- { serverError ILLEGAL_COLUMN }\n+SELECT materialize('Asia/Kolkata') t, toTimeZone(toDateTime('2017-11-05 08:07:47', 'Asia/Istanbul'), t); -- { serverError ILLEGAL_COLUMN }\n+\n+CREATE TEMPORARY TABLE tmp AS SELECT arrayJoin(['Europe/Istanbul', 'Asia/Istanbul']);\n+SELECT toTimeZone(now(), (*,).1) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n+SELECT now((*,).1) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n+SELECT now64(1, (*,).1) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n+SELECT toStartOfInterval(now(), INTERVAL 3 HOUR, (*,).1) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n+SELECT snowflakeToDateTime(toInt64(123), (*,).1) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n+SELECT toUnixTimestamp(now(), (*,).1) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n+SELECT toDateTimeOrDefault('2023-04-12 16:43:32', (*,).1, now()) FROM tmp; -- { serverError ILLEGAL_COLUMN }\n",
  "problem_statement": "toTimeZone does not throw an error about non-constant timezone\n```\r\nselect materialize('America/Los_Angeles') t, toTimeZone(now(), t)\r\n\r\n\u250c\u2500t\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500toTimeZone(now(), materialize('America/Los_Angeles'))\u2500\u2510\r\n\u2502 America/Los_Angeles \u2502                                   2020-10-26 22:58:42 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\ndesc (select materialize('America/Los_Angeles') t, toTimeZone(now(), t))\r\n\u250c\u2500name\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500type\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\r\n\u2502 t                                                     \u2502 String              \u2502\r\n\u2502 toTimeZone(now(), materialize('America/Los_Angeles')) \u2502 DateTime('Etc/UTC') \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\r\n\r\n\r\n\r\nexample with toString\r\nSELECT\r\n    materialize('America/Los_Angeles') AS t,  toString(now(), t)\r\n\r\nReceived exception from server (version 20.11.1):\r\nCode: 44. DB::Exception: Received from localhost:9000. DB::Exception: Illegal type of argument #2 'timezone' of function toString, expected const String, got String.\r\n\r\n```\n",
  "hints_text": "related https://github.com/ClickHouse/ClickHouse/issues/6948\r\n\nCame across this today in CH22.8 - I was actually writing examples for a guide on working with Timezones in Clickhouse and was going to use it to show how it raises an error when the Timezone is a lookup, except it doesn't.\r\n\r\nI think this is quite tricky because Clickhouse defaults back to the server timezone silently in this case, so a naive user will get the wrong answers if not careful.",
  "created_at": "2023-04-06T11:12:44Z"
}