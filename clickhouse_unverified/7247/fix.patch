diff --git a/dbms/src/Functions/FunctionsConversion.h b/dbms/src/Functions/FunctionsConversion.h
index c16f439c3faa..7f89ea2430f8 100644
--- a/dbms/src/Functions/FunctionsConversion.h
+++ b/dbms/src/Functions/FunctionsConversion.h
@@ -1540,6 +1540,9 @@ class FunctionCast final : public IFunctionBase
 
     String getName() const override { return name; }
 
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
+
     bool hasInformationAboutMonotonicity() const override
     {
         return static_cast<bool>(monotonicity_for_range);
diff --git a/dbms/src/Functions/FunctionsMiscellaneous.h b/dbms/src/Functions/FunctionsMiscellaneous.h
index 96539f9559fa..de1177dd8ed1 100644
--- a/dbms/src/Functions/FunctionsMiscellaneous.h
+++ b/dbms/src/Functions/FunctionsMiscellaneous.h
@@ -26,6 +26,9 @@ class FunctionExpression : public IFunctionBase, public IPreparedFunction,
 
     String getName() const override { return "FunctionExpression"; }
 
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
+
     const DataTypes & getArgumentTypes() const override { return argument_types; }
     const DataTypePtr & getReturnType() const override { return return_type; }
 
@@ -110,6 +113,9 @@ class FunctionCapture : public IFunctionBase, public IPreparedFunction, public F
 
     String getName() const override { return name; }
 
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
+
     const DataTypes & getArgumentTypes() const override { return captured_types; }
     const DataTypePtr & getReturnType() const override { return return_type; }
 
diff --git a/dbms/src/Functions/FunctionsRandom.h b/dbms/src/Functions/FunctionsRandom.h
index 069c0afa86b2..9559f6121fd5 100644
--- a/dbms/src/Functions/FunctionsRandom.h
+++ b/dbms/src/Functions/FunctionsRandom.h
@@ -53,9 +53,11 @@ class FunctionRandom : public IFunction
         return name;
     }
 
+    bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return false; }
+
     bool isVariadic() const override { return true; }
     size_t getNumberOfArguments() const override { return 0; }
-    bool isDeterministicInScopeOfQuery() const override { return false; }
 
     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override
     {
diff --git a/dbms/src/Functions/IFunction.h b/dbms/src/Functions/IFunction.h
index a3b4c7909269..04e9783a5197 100644
--- a/dbms/src/Functions/IFunction.h
+++ b/dbms/src/Functions/IFunction.h
@@ -198,9 +198,9 @@ class IFunctionBase
       * Example: now(). Another example: functions that work with periodically updated dictionaries.
       */
 
-    virtual bool isDeterministic() const { return true; }
+    virtual bool isDeterministic() const = 0;
 
-    virtual bool isDeterministicInScopeOfQuery() const { return true; }
+    virtual bool isDeterministicInScopeOfQuery() const = 0;
 
     /** Lets you know if the function is monotonic in a range of values.
       * This is used to work with the index in a sorted chunk of data.
@@ -240,11 +240,16 @@ class IFunctionBuilder
     /// Get the main function name.
     virtual String getName() const = 0;
 
+    /// See the comment for the same method in IFunctionBase
+    virtual bool isDeterministic() const = 0;
+
+    virtual bool isDeterministicInScopeOfQuery() const = 0;
+
     /// Override and return true if function needs to depend on the state of the data.
-    virtual bool isStateful() const { return false; }
+    virtual bool isStateful() const = 0;
 
     /// Override and return true if function could take different number of arguments.
-    virtual bool isVariadic() const { return false; }
+    virtual bool isVariadic() const = 0;
 
     /// For non-variadic functions, return number of arguments; otherwise return zero (that should be ignored).
     virtual size_t getNumberOfArguments() const = 0;
@@ -277,6 +282,11 @@ class FunctionBuilderImpl : public IFunctionBuilder
         return buildImpl(arguments, getReturnType(arguments));
     }
 
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
+    bool isStateful() const override { return false; }
+    bool isVariadic() const override { return false; }
+
     /// Default implementation. Will check only in non-variadic case.
     void checkNumberOfArguments(size_t number_of_arguments) const override;
 
@@ -357,6 +367,8 @@ class IFunction : public std::enable_shared_from_this<IFunction>,
     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {}; }
     bool canBeExecutedOnDefaultArguments() const override { return true; }
     bool canBeExecutedOnLowCardinalityDictionary() const override { return isDeterministicInScopeOfQuery(); }
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
 
     using PreparedFunctionImpl::execute;
     using PreparedFunctionImpl::executeImplDryRun;
@@ -506,6 +518,9 @@ class DefaultFunctionBuilder : public FunctionBuilderImpl
         return function->checkNumberOfArguments(number_of_arguments);
     }
 
+    bool isDeterministic() const override { return function->isDeterministic(); }
+    bool isDeterministicInScopeOfQuery() const override { return function->isDeterministicInScopeOfQuery(); }
+
     String getName() const override { return function->getName(); }
     bool isStateful() const override { return function->isStateful(); }
     bool isVariadic() const override { return function->isVariadic(); }
diff --git a/dbms/src/Functions/now.cpp b/dbms/src/Functions/now.cpp
index b5b4d9d79183..35ecf75e420e 100644
--- a/dbms/src/Functions/now.cpp
+++ b/dbms/src/Functions/now.cpp
@@ -53,6 +53,7 @@ class FunctionBaseNow : public IFunctionBase
     }
 
     bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
 
 private:
     time_t time_value;
@@ -65,8 +66,10 @@ class FunctionBuilderNow : public FunctionBuilderImpl
     static constexpr auto name = "now";
 
     String getName() const override { return name; }
-    size_t getNumberOfArguments() const override { return 0; }
 
+    bool isDeterministic() const override { return false; }
+
+    size_t getNumberOfArguments() const override { return 0; }
     static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderNow>(); }
 
 protected:
diff --git a/dbms/src/Functions/randConstant.cpp b/dbms/src/Functions/randConstant.cpp
index e854484154c1..3bbb3f56b0eb 100644
--- a/dbms/src/Functions/randConstant.cpp
+++ b/dbms/src/Functions/randConstant.cpp
@@ -50,6 +50,7 @@ class FunctionBaseRandomConstant : public IFunctionBase
     }
 
     bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
 
 private:
     ToType value;
@@ -64,6 +65,8 @@ class FunctionBuilderRandomConstant : public FunctionBuilderImpl
     static constexpr auto name = Name::name;
     String getName() const override { return name; }
 
+    bool isDeterministic() const override { return false; }
+
     bool isVariadic() const override { return true; }
     size_t getNumberOfArguments() const override { return 0; }
 
diff --git a/dbms/src/Functions/runningDifference.h b/dbms/src/Functions/runningDifference.h
index 374142311e9b..7cda3b0be948 100644
--- a/dbms/src/Functions/runningDifference.h
+++ b/dbms/src/Functions/runningDifference.h
@@ -141,6 +141,7 @@ class FunctionRunningDifferenceImpl : public IFunction
         return 1;
     }
 
+    bool isDeterministic() const override { return false; }
     bool isDeterministicInScopeOfQuery() const override
     {
         return false;
diff --git a/dbms/src/Functions/toTypeName.cpp b/dbms/src/Functions/toTypeName.cpp
index 55d602167a50..202274787bcf 100644
--- a/dbms/src/Functions/toTypeName.cpp
+++ b/dbms/src/Functions/toTypeName.cpp
@@ -38,6 +38,9 @@ class BaseFunctionToTypeName : public IFunctionBase
     static constexpr auto name = "toTypeName";
     String getName() const override { return name; }
 
+    bool isDeterministic() const override { return true; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
+
     const DataTypes & getArgumentTypes() const override { return argument_types; }
     const DataTypePtr & getReturnType() const override { return return_type; }
 
diff --git a/dbms/src/Functions/today.cpp b/dbms/src/Functions/today.cpp
index 72e4867a9503..8f6923331700 100644
--- a/dbms/src/Functions/today.cpp
+++ b/dbms/src/Functions/today.cpp
@@ -52,6 +52,7 @@ class FunctionBaseToday : public IFunctionBase
     }
 
     bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
 
 private:
     DayNum day_value;
@@ -64,6 +65,9 @@ class FunctionBuilderToday : public FunctionBuilderImpl
     static constexpr auto name = "today";
 
     String getName() const override { return name; }
+
+    bool isDeterministic() const override { return false; }
+
     size_t getNumberOfArguments() const override { return 0; }
 
     static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderToday>(); }
diff --git a/dbms/src/Functions/yesterday.cpp b/dbms/src/Functions/yesterday.cpp
index 565a2c409132..88aa6896f5a8 100644
--- a/dbms/src/Functions/yesterday.cpp
+++ b/dbms/src/Functions/yesterday.cpp
@@ -52,6 +52,7 @@ class FunctionBaseYesterday : public IFunctionBase
     }
 
     bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return true; }
 
 private:
     DayNum day_value;
@@ -64,6 +65,9 @@ class FunctionBuilderYesterday : public FunctionBuilderImpl
     static constexpr auto name = "yesterday";
 
     String getName() const override { return name; }
+
+    bool isDeterministic() const override { return false; }
+
     size_t getNumberOfArguments() const override { return 0; }
 
     static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderYesterday>(); }
diff --git a/dbms/src/Interpreters/MutationsInterpreter.cpp b/dbms/src/Interpreters/MutationsInterpreter.cpp
index a025ba87c1a1..2641ab2a5c43 100644
--- a/dbms/src/Interpreters/MutationsInterpreter.cpp
+++ b/dbms/src/Interpreters/MutationsInterpreter.cpp
@@ -1,6 +1,11 @@
+#include "MutationsInterpreter.h"
+
+#include <Functions/FunctionFactory.h>
+#include <Functions/IFunction.h>
+#include <Interpreters/InDepthNodeVisitor.h>
+#include <Interpreters/InterpreterSelectQuery.h>
 #include <Interpreters/MutationsInterpreter.h>
 #include <Interpreters/SyntaxAnalyzer.h>
-#include <Interpreters/InterpreterSelectQuery.h>
 #include <Storages/MergeTree/MergeTreeData.h>
 #include <DataStreams/FilterBlockInputStream.h>
 #include <DataStreams/ExpressionBlockInputStream.h>
@@ -14,7 +19,6 @@
 #include <Parsers/ASTSelectQuery.h>
 #include <Parsers/formatAST.h>
 #include <IO/WriteHelpers.h>
-#include "MutationsInterpreter.h"
 
 
 namespace DB
@@ -27,6 +31,67 @@ namespace ErrorCodes
     extern const int CANNOT_UPDATE_COLUMN;
 }
 
+namespace
+{
+struct FirstNonDeterministicFuncData
+{
+    using TypeToVisit = ASTFunction;
+
+    explicit FirstNonDeterministicFuncData(const Context & context_)
+        : context{context_}
+    {}
+
+    const Context & context;
+    std::optional<String> nondeterministic_function_name;
+
+    void visit(ASTFunction & function, ASTPtr &)
+    {
+        if (nondeterministic_function_name)
+            return;
+
+        const auto func = FunctionFactory::instance().get(function.name, context);
+        if (!func->isDeterministic())
+            nondeterministic_function_name = func->getName();
+    }
+};
+
+using FirstNonDeterministicFuncFinder =
+        InDepthNodeVisitor<OneTypeMatcher<FirstNonDeterministicFuncData>, true>;
+
+std::optional<String> findFirstNonDeterministicFuncName(const MutationCommand & command, const Context & context)
+{
+    FirstNonDeterministicFuncData finder_data(context);
+
+    switch (command.type)
+    {
+        case MutationCommand::UPDATE:
+        {
+            auto update_assignments_ast = command.ast->as<const ASTAlterCommand &>().update_assignments->clone();
+            FirstNonDeterministicFuncFinder(finder_data).visit(update_assignments_ast);
+
+            if (finder_data.nondeterministic_function_name)
+                return finder_data.nondeterministic_function_name;
+
+            [[fallthrough]];
+        }
+
+        case MutationCommand::DELETE:
+        {
+            auto predicate_ast = command.predicate->clone();
+            FirstNonDeterministicFuncFinder(finder_data).visit(predicate_ast);
+
+            return finder_data.nondeterministic_function_name;
+        }
+
+        default:
+            break;
+    }
+
+    return {};
+}
+};
+
+
 bool MutationsInterpreter::isStorageTouchedByMutations() const
 {
     if (commands.empty())
@@ -440,6 +505,21 @@ BlockInputStreamPtr MutationsInterpreter::addStreamsForLaterStages(const std::ve
 
 void MutationsInterpreter::validate(TableStructureReadLockHolder &)
 {
+    /// For Replicated* storages mutations cannot employ non-deterministic functions
+    /// because that produces inconsistencies between replicas
+    if (startsWith(storage->getName(), "Replicated"))
+    {
+        for (const auto & command : commands)
+        {
+            const auto nondeterministic_func_name = findFirstNonDeterministicFuncName(command, context);
+            if (nondeterministic_func_name)
+                throw Exception(
+                    "ALTER UPDATE/ALTER DELETE statements must use only deterministic functions! "
+                    "Function '" + *nondeterministic_func_name + "' is non-deterministic",
+                    ErrorCodes::BAD_ARGUMENTS);
+        }
+    }
+
     const auto & select_query = prepare(/* dry_run = */ true);
     InterpreterSelectQuery interpreter{select_query, context, storage, SelectQueryOptions().analyze(/* dry_run = */ true).ignoreLimits()};
     /// Do not use getSampleBlock in order to check the whole pipeline.
