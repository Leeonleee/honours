{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7247,
  "instance_id": "ClickHouse__ClickHouse-7247",
  "issue_numbers": [
    "7097"
  ],
  "base_commit": "0769f80f4ea2516cc301257af27352c27a93df6c",
  "patch": "diff --git a/dbms/src/Functions/FunctionsConversion.h b/dbms/src/Functions/FunctionsConversion.h\nindex c16f439c3faa..7f89ea2430f8 100644\n--- a/dbms/src/Functions/FunctionsConversion.h\n+++ b/dbms/src/Functions/FunctionsConversion.h\n@@ -1540,6 +1540,9 @@ class FunctionCast final : public IFunctionBase\n \n     String getName() const override { return name; }\n \n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n+\n     bool hasInformationAboutMonotonicity() const override\n     {\n         return static_cast<bool>(monotonicity_for_range);\ndiff --git a/dbms/src/Functions/FunctionsMiscellaneous.h b/dbms/src/Functions/FunctionsMiscellaneous.h\nindex 96539f9559fa..de1177dd8ed1 100644\n--- a/dbms/src/Functions/FunctionsMiscellaneous.h\n+++ b/dbms/src/Functions/FunctionsMiscellaneous.h\n@@ -26,6 +26,9 @@ class FunctionExpression : public IFunctionBase, public IPreparedFunction,\n \n     String getName() const override { return \"FunctionExpression\"; }\n \n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n+\n     const DataTypes & getArgumentTypes() const override { return argument_types; }\n     const DataTypePtr & getReturnType() const override { return return_type; }\n \n@@ -110,6 +113,9 @@ class FunctionCapture : public IFunctionBase, public IPreparedFunction, public F\n \n     String getName() const override { return name; }\n \n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n+\n     const DataTypes & getArgumentTypes() const override { return captured_types; }\n     const DataTypePtr & getReturnType() const override { return return_type; }\n \ndiff --git a/dbms/src/Functions/FunctionsRandom.h b/dbms/src/Functions/FunctionsRandom.h\nindex 069c0afa86b2..9559f6121fd5 100644\n--- a/dbms/src/Functions/FunctionsRandom.h\n+++ b/dbms/src/Functions/FunctionsRandom.h\n@@ -53,9 +53,11 @@ class FunctionRandom : public IFunction\n         return name;\n     }\n \n+    bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return false; }\n+\n     bool isVariadic() const override { return true; }\n     size_t getNumberOfArguments() const override { return 0; }\n-    bool isDeterministicInScopeOfQuery() const override { return false; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\ndiff --git a/dbms/src/Functions/IFunction.h b/dbms/src/Functions/IFunction.h\nindex a3b4c7909269..04e9783a5197 100644\n--- a/dbms/src/Functions/IFunction.h\n+++ b/dbms/src/Functions/IFunction.h\n@@ -198,9 +198,9 @@ class IFunctionBase\n       * Example: now(). Another example: functions that work with periodically updated dictionaries.\n       */\n \n-    virtual bool isDeterministic() const { return true; }\n+    virtual bool isDeterministic() const = 0;\n \n-    virtual bool isDeterministicInScopeOfQuery() const { return true; }\n+    virtual bool isDeterministicInScopeOfQuery() const = 0;\n \n     /** Lets you know if the function is monotonic in a range of values.\n       * This is used to work with the index in a sorted chunk of data.\n@@ -240,11 +240,16 @@ class IFunctionBuilder\n     /// Get the main function name.\n     virtual String getName() const = 0;\n \n+    /// See the comment for the same method in IFunctionBase\n+    virtual bool isDeterministic() const = 0;\n+\n+    virtual bool isDeterministicInScopeOfQuery() const = 0;\n+\n     /// Override and return true if function needs to depend on the state of the data.\n-    virtual bool isStateful() const { return false; }\n+    virtual bool isStateful() const = 0;\n \n     /// Override and return true if function could take different number of arguments.\n-    virtual bool isVariadic() const { return false; }\n+    virtual bool isVariadic() const = 0;\n \n     /// For non-variadic functions, return number of arguments; otherwise return zero (that should be ignored).\n     virtual size_t getNumberOfArguments() const = 0;\n@@ -277,6 +282,11 @@ class FunctionBuilderImpl : public IFunctionBuilder\n         return buildImpl(arguments, getReturnType(arguments));\n     }\n \n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n+    bool isStateful() const override { return false; }\n+    bool isVariadic() const override { return false; }\n+\n     /// Default implementation. Will check only in non-variadic case.\n     void checkNumberOfArguments(size_t number_of_arguments) const override;\n \n@@ -357,6 +367,8 @@ class IFunction : public std::enable_shared_from_this<IFunction>,\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {}; }\n     bool canBeExecutedOnDefaultArguments() const override { return true; }\n     bool canBeExecutedOnLowCardinalityDictionary() const override { return isDeterministicInScopeOfQuery(); }\n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n \n     using PreparedFunctionImpl::execute;\n     using PreparedFunctionImpl::executeImplDryRun;\n@@ -506,6 +518,9 @@ class DefaultFunctionBuilder : public FunctionBuilderImpl\n         return function->checkNumberOfArguments(number_of_arguments);\n     }\n \n+    bool isDeterministic() const override { return function->isDeterministic(); }\n+    bool isDeterministicInScopeOfQuery() const override { return function->isDeterministicInScopeOfQuery(); }\n+\n     String getName() const override { return function->getName(); }\n     bool isStateful() const override { return function->isStateful(); }\n     bool isVariadic() const override { return function->isVariadic(); }\ndiff --git a/dbms/src/Functions/now.cpp b/dbms/src/Functions/now.cpp\nindex b5b4d9d79183..35ecf75e420e 100644\n--- a/dbms/src/Functions/now.cpp\n+++ b/dbms/src/Functions/now.cpp\n@@ -53,6 +53,7 @@ class FunctionBaseNow : public IFunctionBase\n     }\n \n     bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n \n private:\n     time_t time_value;\n@@ -65,8 +66,10 @@ class FunctionBuilderNow : public FunctionBuilderImpl\n     static constexpr auto name = \"now\";\n \n     String getName() const override { return name; }\n-    size_t getNumberOfArguments() const override { return 0; }\n \n+    bool isDeterministic() const override { return false; }\n+\n+    size_t getNumberOfArguments() const override { return 0; }\n     static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderNow>(); }\n \n protected:\ndiff --git a/dbms/src/Functions/randConstant.cpp b/dbms/src/Functions/randConstant.cpp\nindex e854484154c1..3bbb3f56b0eb 100644\n--- a/dbms/src/Functions/randConstant.cpp\n+++ b/dbms/src/Functions/randConstant.cpp\n@@ -50,6 +50,7 @@ class FunctionBaseRandomConstant : public IFunctionBase\n     }\n \n     bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n \n private:\n     ToType value;\n@@ -64,6 +65,8 @@ class FunctionBuilderRandomConstant : public FunctionBuilderImpl\n     static constexpr auto name = Name::name;\n     String getName() const override { return name; }\n \n+    bool isDeterministic() const override { return false; }\n+\n     bool isVariadic() const override { return true; }\n     size_t getNumberOfArguments() const override { return 0; }\n \ndiff --git a/dbms/src/Functions/runningDifference.h b/dbms/src/Functions/runningDifference.h\nindex 374142311e9b..7cda3b0be948 100644\n--- a/dbms/src/Functions/runningDifference.h\n+++ b/dbms/src/Functions/runningDifference.h\n@@ -141,6 +141,7 @@ class FunctionRunningDifferenceImpl : public IFunction\n         return 1;\n     }\n \n+    bool isDeterministic() const override { return false; }\n     bool isDeterministicInScopeOfQuery() const override\n     {\n         return false;\ndiff --git a/dbms/src/Functions/toTypeName.cpp b/dbms/src/Functions/toTypeName.cpp\nindex 55d602167a50..202274787bcf 100644\n--- a/dbms/src/Functions/toTypeName.cpp\n+++ b/dbms/src/Functions/toTypeName.cpp\n@@ -38,6 +38,9 @@ class BaseFunctionToTypeName : public IFunctionBase\n     static constexpr auto name = \"toTypeName\";\n     String getName() const override { return name; }\n \n+    bool isDeterministic() const override { return true; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n+\n     const DataTypes & getArgumentTypes() const override { return argument_types; }\n     const DataTypePtr & getReturnType() const override { return return_type; }\n \ndiff --git a/dbms/src/Functions/today.cpp b/dbms/src/Functions/today.cpp\nindex 72e4867a9503..8f6923331700 100644\n--- a/dbms/src/Functions/today.cpp\n+++ b/dbms/src/Functions/today.cpp\n@@ -52,6 +52,7 @@ class FunctionBaseToday : public IFunctionBase\n     }\n \n     bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n \n private:\n     DayNum day_value;\n@@ -64,6 +65,9 @@ class FunctionBuilderToday : public FunctionBuilderImpl\n     static constexpr auto name = \"today\";\n \n     String getName() const override { return name; }\n+\n+    bool isDeterministic() const override { return false; }\n+\n     size_t getNumberOfArguments() const override { return 0; }\n \n     static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderToday>(); }\ndiff --git a/dbms/src/Functions/yesterday.cpp b/dbms/src/Functions/yesterday.cpp\nindex 565a2c409132..88aa6896f5a8 100644\n--- a/dbms/src/Functions/yesterday.cpp\n+++ b/dbms/src/Functions/yesterday.cpp\n@@ -52,6 +52,7 @@ class FunctionBaseYesterday : public IFunctionBase\n     }\n \n     bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return true; }\n \n private:\n     DayNum day_value;\n@@ -64,6 +65,9 @@ class FunctionBuilderYesterday : public FunctionBuilderImpl\n     static constexpr auto name = \"yesterday\";\n \n     String getName() const override { return name; }\n+\n+    bool isDeterministic() const override { return false; }\n+\n     size_t getNumberOfArguments() const override { return 0; }\n \n     static FunctionBuilderPtr create(const Context &) { return std::make_shared<FunctionBuilderYesterday>(); }\ndiff --git a/dbms/src/Interpreters/MutationsInterpreter.cpp b/dbms/src/Interpreters/MutationsInterpreter.cpp\nindex a025ba87c1a1..2641ab2a5c43 100644\n--- a/dbms/src/Interpreters/MutationsInterpreter.cpp\n+++ b/dbms/src/Interpreters/MutationsInterpreter.cpp\n@@ -1,6 +1,11 @@\n+#include \"MutationsInterpreter.h\"\n+\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/IFunction.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n #include <Interpreters/MutationsInterpreter.h>\n #include <Interpreters/SyntaxAnalyzer.h>\n-#include <Interpreters/InterpreterSelectQuery.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n #include <DataStreams/FilterBlockInputStream.h>\n #include <DataStreams/ExpressionBlockInputStream.h>\n@@ -14,7 +19,6 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/formatAST.h>\n #include <IO/WriteHelpers.h>\n-#include \"MutationsInterpreter.h\"\n \n \n namespace DB\n@@ -27,6 +31,67 @@ namespace ErrorCodes\n     extern const int CANNOT_UPDATE_COLUMN;\n }\n \n+namespace\n+{\n+struct FirstNonDeterministicFuncData\n+{\n+    using TypeToVisit = ASTFunction;\n+\n+    explicit FirstNonDeterministicFuncData(const Context & context_)\n+        : context{context_}\n+    {}\n+\n+    const Context & context;\n+    std::optional<String> nondeterministic_function_name;\n+\n+    void visit(ASTFunction & function, ASTPtr &)\n+    {\n+        if (nondeterministic_function_name)\n+            return;\n+\n+        const auto func = FunctionFactory::instance().get(function.name, context);\n+        if (!func->isDeterministic())\n+            nondeterministic_function_name = func->getName();\n+    }\n+};\n+\n+using FirstNonDeterministicFuncFinder =\n+        InDepthNodeVisitor<OneTypeMatcher<FirstNonDeterministicFuncData>, true>;\n+\n+std::optional<String> findFirstNonDeterministicFuncName(const MutationCommand & command, const Context & context)\n+{\n+    FirstNonDeterministicFuncData finder_data(context);\n+\n+    switch (command.type)\n+    {\n+        case MutationCommand::UPDATE:\n+        {\n+            auto update_assignments_ast = command.ast->as<const ASTAlterCommand &>().update_assignments->clone();\n+            FirstNonDeterministicFuncFinder(finder_data).visit(update_assignments_ast);\n+\n+            if (finder_data.nondeterministic_function_name)\n+                return finder_data.nondeterministic_function_name;\n+\n+            [[fallthrough]];\n+        }\n+\n+        case MutationCommand::DELETE:\n+        {\n+            auto predicate_ast = command.predicate->clone();\n+            FirstNonDeterministicFuncFinder(finder_data).visit(predicate_ast);\n+\n+            return finder_data.nondeterministic_function_name;\n+        }\n+\n+        default:\n+            break;\n+    }\n+\n+    return {};\n+}\n+};\n+\n+\n bool MutationsInterpreter::isStorageTouchedByMutations() const\n {\n     if (commands.empty())\n@@ -440,6 +505,21 @@ BlockInputStreamPtr MutationsInterpreter::addStreamsForLaterStages(const std::ve\n \n void MutationsInterpreter::validate(TableStructureReadLockHolder &)\n {\n+    /// For Replicated* storages mutations cannot employ non-deterministic functions\n+    /// because that produces inconsistencies between replicas\n+    if (startsWith(storage->getName(), \"Replicated\"))\n+    {\n+        for (const auto & command : commands)\n+        {\n+            const auto nondeterministic_func_name = findFirstNonDeterministicFuncName(command, context);\n+            if (nondeterministic_func_name)\n+                throw Exception(\n+                    \"ALTER UPDATE/ALTER DELETE statements must use only deterministic functions! \"\n+                    \"Function '\" + *nondeterministic_func_name + \"' is non-deterministic\",\n+                    ErrorCodes::BAD_ARGUMENTS);\n+        }\n+    }\n+\n     const auto & select_query = prepare(/* dry_run = */ true);\n     InterpreterSelectQuery interpreter{select_query, context, storage, SelectQueryOptions().analyze(/* dry_run = */ true).ignoreLimits()};\n     /// Do not use getSampleBlock in order to check the whole pipeline.\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01017_mutations_with_nondeterministic_functions_zookeeper.reference b/dbms/tests/queries/0_stateless/01017_mutations_with_nondeterministic_functions_zookeeper.reference\nnew file mode 100644\nindex 000000000000..b462a5a7baa4\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01017_mutations_with_nondeterministic_functions_zookeeper.reference\n@@ -0,0 +1,4 @@\n+OK\n+OK\n+OK\n+OK\ndiff --git a/dbms/tests/queries/0_stateless/01017_mutations_with_nondeterministic_functions_zookeeper.sh b/dbms/tests/queries/0_stateless/01017_mutations_with_nondeterministic_functions_zookeeper.sh\nnew file mode 100755\nindex 000000000000..ac66dbc352a9\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01017_mutations_with_nondeterministic_functions_zookeeper.sh\n@@ -0,0 +1,43 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+. $CURDIR/../shell_config.sh\n+\n+\n+R1=table_1017_1\n+R2=table_1017_2\n+T1=table_1017_merge\n+\n+${CLICKHOUSE_CLIENT} -n -q \"\n+    DROP TABLE IF EXISTS $R1;\n+    DROP TABLE IF EXISTS $R2;\n+\n+    CREATE TABLE $R1 (x UInt32, y UInt32) ENGINE ReplicatedMergeTree('/clickhouse/tables/${CLICKHOUSE_DATABASE}.table_1017', 'r1') ORDER BY x;\n+    CREATE TABLE $R2 (x UInt32, y UInt32) ENGINE ReplicatedMergeTree('/clickhouse/tables/${CLICKHOUSE_DATABASE}.table_1017', 'r2') ORDER BY x;\n+    CREATE TABLE $T1 (x UInt32, y UInt32) ENGINE MergeTree() ORDER BY x;\n+\n+    INSERT INTO $R1 VALUES (0, 1)(1, 2)(2, 3)(3, 4);\n+    INSERT INTO $T1 VALUES (0, 1)(1, 2)(2, 3)(3, 4);\n+\"\n+\n+# Check that in mutations of replicated tables predicates do not contain non-deterministic functions\n+${CLICKHOUSE_CLIENT} --query \"ALTER TABLE $R1 DELETE WHERE ignore(rand())\" 2>&1 \\\n+| fgrep -q \"must use only deterministic functions\" && echo 'OK' || echo 'FAIL'\n+\n+${CLICKHOUSE_CLIENT} --query \"ALTER TABLE $R1 UPDATE y = y + rand() % 1 WHERE not ignore()\" 2>&1 \\\n+| fgrep -q \"must use only deterministic functions\" && echo 'OK' || echo 'FAIL'\n+\n+\n+# For regular tables we do not enforce deterministic functions\n+${CLICKHOUSE_CLIENT} --query \"ALTER TABLE $T1 DELETE WHERE rand() = 0\" 2>&1 > /dev/null \\\n+&& echo 'OK' || echo 'FAIL'\n+\n+${CLICKHOUSE_CLIENT} --query \"ALTER TABLE $T1 UPDATE y = y + rand() % 1 WHERE not ignore()\" 2>&1 > /dev/null \\\n+&& echo 'OK' || echo 'FAIL'\n+\n+\n+${CLICKHOUSE_CLIENT} -n -q \"\n+    DROP TABLE IF EXISTS $R2;\n+    DROP TABLE IF EXISTS $R1;\n+    DROP TABLE IF EXISTS $T1;\n+\"\n",
  "problem_statement": "Forbid non-deterministic functions in mutations\nSuch as function `rand`.\r\nOtherwise it will lead to fireworks.\r\n\r\nThis issue found by @Akazz \r\n\n",
  "hints_text": "",
  "created_at": "2019-10-09T11:22:53Z"
}