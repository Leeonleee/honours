{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 60156,
  "instance_id": "ClickHouse__ClickHouse-60156",
  "issue_numbers": [
    "55520"
  ],
  "base_commit": "2ff562ebe2e409a15df6155cfcb65c4275a2b9c7",
  "patch": "diff --git a/docs/en/sql-reference/functions/encoding-functions.md b/docs/en/sql-reference/functions/encoding-functions.md\nindex 4f6da764b3c3..465b9e3573bc 100644\n--- a/docs/en/sql-reference/functions/encoding-functions.md\n+++ b/docs/en/sql-reference/functions/encoding-functions.md\n@@ -171,7 +171,7 @@ Performs the opposite operation of [hex](#hex). It interprets each pair of hexad\n \n If you want to convert the result to a number, you can use the [reverse](../../sql-reference/functions/string-functions.md#reverse) and [reinterpretAs&lt;Type&gt;](../../sql-reference/functions/type-conversion-functions.md#type-conversion-functions) functions.\n \n-:::note    \n+:::note\n If `unhex` is invoked from within the `clickhouse-client`, binary strings display using UTF-8.\n :::\n \n@@ -330,11 +330,11 @@ Alias: `UNBIN`.\n \n For a numeric argument `unbin()` does not return the inverse of `bin()`. If you want to convert the result to a number, you can use the [reverse](../../sql-reference/functions/string-functions.md#reverse) and [reinterpretAs&lt;Type&gt;](../../sql-reference/functions/type-conversion-functions.md#reinterpretasuint8163264) functions.\n \n-:::note    \n+:::note\n If `unbin` is invoked from within the `clickhouse-client`, binary strings are displayed using UTF-8.\n :::\n \n-Supports binary digits `0` and `1`. The number of binary digits does not have to be multiples of eight. If the argument string contains anything other than binary digits, some implementation-defined result is returned (an exception isn\u2019t thrown). \n+Supports binary digits `0` and `1`. The number of binary digits does not have to be multiples of eight. If the argument string contains anything other than binary digits, some implementation-defined result is returned (an exception isn\u2019t thrown).\n \n **Arguments**\n \n@@ -496,7 +496,7 @@ mortonEncode(range_mask, args)\n - `range_mask`: 1-8.\n - `args`: up to 8 [unsigned integers](../../sql-reference/data-types/int-uint.md) or columns of the aforementioned type.\n \n-Note: when using columns for `args` the provided `range_mask` tuple should still be a constant. \n+Note: when using columns for `args` the provided `range_mask` tuple should still be a constant.\n \n **Returned value**\n \n@@ -644,7 +644,7 @@ Result:\n Accepts a range mask (tuple) as a first argument and the code as the second argument.\n Each number in the mask configures the amount of range shrink:<br/>\n 1 - no shrink<br/>\n-2 - 2x shrink<br/> \n+2 - 2x shrink<br/>\n 3 - 3x shrink<br/>\n ...<br/>\n Up to 8x shrink.<br/>\n@@ -719,6 +719,267 @@ Result:\n 1\t2\t3\t4\t5\t6\t7\t8\n ```\n \n+## hilbertEncode\n \n+Calculates code for Hilbert Curve for a list of unsigned integers.\n \n+The function has two modes of operation:\n+- Simple\n+- Expanded\n+\n+### Simple mode\n+\n+Simple: accepts up to 2 unsigned integers as arguments and produces a UInt64 code.\n+\n+**Syntax**\n+\n+```sql\n+hilbertEncode(args)\n+```\n+\n+**Parameters**\n+\n+- `args`: up to 2 [unsigned integers](../../sql-reference/data-types/int-uint.md) or columns of the aforementioned type.\n+\n+**Returned value**\n+\n+- A UInt64 code\n+\n+Type: [UInt64](../../sql-reference/data-types/int-uint.md)\n+\n+**Example**\n+\n+Query:\n+\n+```sql\n+SELECT hilbertEncode(3, 4);\n+```\n+Result:\n+\n+```response\n+31\n+```\n+\n+### Expanded mode\n+\n+Accepts a range mask ([tuple](../../sql-reference/data-types/tuple.md)) as a first argument and up to 2 [unsigned integers](../../sql-reference/data-types/int-uint.md) as other arguments.\n+\n+Each number in the mask configures the number of bits by which the corresponding argument will be shifted left, effectively scaling the argument within its range.\n+\n+**Syntax**\n+\n+```sql\n+hilbertEncode(range_mask, args)\n+```\n+\n+**Parameters**\n+- `range_mask`: ([tuple](../../sql-reference/data-types/tuple.md))\n+- `args`: up to 2 [unsigned integers](../../sql-reference/data-types/int-uint.md) or columns of the aforementioned type.\n+\n+Note: when using columns for `args` the provided `range_mask` tuple should still be a constant.\n+\n+**Returned value**\n+\n+- A UInt64 code\n+\n+Type: [UInt64](../../sql-reference/data-types/int-uint.md)\n+\n+\n+**Example**\n+\n+Range expansion can be beneficial when you need a similar distribution for arguments with wildly different ranges (or cardinality)\n+For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).\n+\n+Query:\n+\n+```sql\n+SELECT hilbertEncode((10,6), 1024, 16);\n+```\n+\n+Result:\n+\n+```response\n+4031541586602\n+```\n+\n+Note: tuple size must be equal to the number of the other arguments.\n+\n+**Example**\n+\n+For a single argument without a tuple, the function returns the argument itself as the Hilbert index, since no dimensional mapping is needed.\n+\n+Query:\n+\n+```sql\n+SELECT hilbertEncode(1);\n+```\n+\n+Result:\n+\n+```response\n+1\n+```\n+\n+**Example**\n+\n+If a single argument is provided with a tuple specifying bit shifts, the function shifts the argument left by the specified number of bits.\n+\n+Query:\n+\n+```sql\n+SELECT hilbertEncode(tuple(2), 128);\n+```\n+\n+Result:\n+\n+```response\n+512\n+```\n+\n+**Example**\n+\n+The function also accepts columns as arguments:\n+\n+Query:\n+\n+First create the table and insert some data.\n+\n+```sql\n+create table hilbert_numbers(\n+    n1 UInt32,\n+    n2 UInt32\n+)\n+Engine=MergeTree()\n+ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';\n+insert into hilbert_numbers (*) values(1,2);\n+```\n+Use column names instead of constants as function arguments to `hilbertEncode`\n+\n+Query:\n+\n+```sql\n+SELECT hilbertEncode(n1, n2) FROM hilbert_numbers;\n+```\n+\n+Result:\n+\n+```response\n+13\n+```\n+\n+**implementation details**\n+\n+Please note that you can fit only so many bits of information into Hilbert code as [UInt64](../../sql-reference/data-types/int-uint.md) has. Two arguments will have a range of maximum 2^32 (64/2) each. All overflow will be clamped to zero.\n+\n+## hilbertDecode\n+\n+Decodes a Hilbert curve index back into a tuple of unsigned integers, representing coordinates in multi-dimensional space.\n+\n+As with the `hilbertEncode` function, this function has two modes of operation:\n+- Simple\n+- Expanded\n+\n+### Simple mode\n+\n+Accepts up to 2 unsigned integers as arguments and produces a UInt64 code.\n+\n+**Syntax**\n+\n+```sql\n+hilbertDecode(tuple_size, code)\n+```\n+\n+**Parameters**\n+- `tuple_size`: integer value no more than 2.\n+- `code`: [UInt64](../../sql-reference/data-types/int-uint.md) code.\n+\n+**Returned value**\n+\n+- [tuple](../../sql-reference/data-types/tuple.md) of the specified size.\n+\n+Type: [UInt64](../../sql-reference/data-types/int-uint.md)\n+\n+**Example**\n+\n+Query:\n+\n+```sql\n+SELECT hilbertDecode(2, 31);\n+```\n+\n+Result:\n+\n+```response\n+[\"3\", \"4\"]\n+```\n+\n+### Expanded mode\n+\n+Accepts a range mask (tuple) as a first argument and up to 2 unsigned integers as other arguments.\n+Each number in the mask configures the number of bits by which the corresponding argument will be shifted left, effectively scaling the argument within its range.\n+\n+Range expansion can be beneficial when you need a similar distribution for arguments with wildly different ranges (or cardinality)\n+For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF).\n+As with the encode function, this is limited to 8 numbers at most.\n+\n+**Example**\n+\n+Hilbert code for one argument is always the argument itself (as a tuple).\n+\n+Query:\n+\n+```sql\n+SELECT hilbertDecode(1, 1);\n+```\n+\n+Result:\n+\n+```response\n+[\"1\"]\n+```\n+\n+**Example**\n+\n+A single argument with a tuple specifying bit shifts will be right-shifted accordingly.\n+\n+Query:\n+\n+```sql\n+SELECT hilbertDecode(tuple(2), 32768);\n+```\n+\n+Result:\n \n+```response\n+[\"128\"]\n+```\n+\n+**Example**\n+\n+The function accepts a column of codes as a second argument:\n+\n+First create the table and insert some data.\n+\n+Query:\n+```sql\n+create table hilbert_numbers(\n+    n1 UInt32,\n+    n2 UInt32\n+)\n+Engine=MergeTree()\n+ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';\n+insert into hilbert_numbers (*) values(1,2);\n+```\n+Use column names instead of constants as function arguments to `hilbertDecode`\n+\n+Query:\n+\n+```sql\n+select untuple(hilbertDecode(2, hilbertEncode(n1, n2))) from hilbert_numbers;\n+```\n+\n+Result:\n+\n+```response\n+1\t2\n+```\ndiff --git a/src/Functions/FunctionSpaceFillingCurve.h b/src/Functions/FunctionSpaceFillingCurve.h\nnew file mode 100644\nindex 000000000000..ac9215f88e11\n--- /dev/null\n+++ b/src/Functions/FunctionSpaceFillingCurve.h\n@@ -0,0 +1,142 @@\n+#pragma once\n+#include <Functions/IFunction.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <Columns/ColumnTuple.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Functions/FunctionHelpers.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n+    extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+class FunctionSpaceFillingCurveEncode: public IFunction\n+{\n+public:\n+    bool isVariadic() const override\n+    {\n+        return true;\n+    }\n+\n+    size_t getNumberOfArguments() const override\n+    {\n+        return 0;\n+    }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DB::DataTypes & arguments) const override\n+    {\n+        size_t vector_start_index = 0;\n+        if (arguments.empty())\n+            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION,\n+                            \"At least one UInt argument is required for function {}\",\n+                            getName());\n+        if (WhichDataType(arguments[0]).isTuple())\n+        {\n+            vector_start_index = 1;\n+            const auto * type_tuple = typeid_cast<const DataTypeTuple *>(arguments[0].get());\n+            auto tuple_size = type_tuple->getElements().size();\n+            if (tuple_size != (arguments.size() - 1))\n+                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n+                                \"Illegal argument {} for function {}, tuple size should be equal to number of UInt arguments\",\n+                                arguments[0]->getName(), getName());\n+            for (size_t i = 0; i < tuple_size; i++)\n+            {\n+                if (!WhichDataType(type_tuple->getElement(i)).isNativeUInt())\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                                    \"Illegal type {} of argument in tuple for function {}, should be a native UInt\",\n+                                    type_tuple->getElement(i)->getName(), getName());\n+            }\n+        }\n+\n+        for (size_t i = vector_start_index; i < arguments.size(); i++)\n+        {\n+            const auto & arg = arguments[i];\n+            if (!WhichDataType(arg).isNativeUInt())\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                                \"Illegal type {} of argument for function {}, should be a native UInt\",\n+                                arg->getName(), getName());\n+        }\n+        return std::make_shared<DataTypeUInt64>();\n+    }\n+};\n+\n+template <UInt8 max_dimensions, UInt8 min_ratio, UInt8 max_ratio>\n+class FunctionSpaceFillingCurveDecode: public IFunction\n+{\n+public:\n+    size_t getNumberOfArguments() const override\n+    {\n+        return 2;\n+    }\n+\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0}; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        UInt64 tuple_size = 0;\n+        const auto * col_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n+        if (!col_const)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                            \"Illegal column type {} for function {}, should be a constant (UInt or Tuple)\",\n+                            arguments[0].type->getName(), getName());\n+        if (!WhichDataType(arguments[1].type).isNativeUInt())\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                            \"Illegal column type {} for function {}, should be a native UInt\",\n+                            arguments[1].type->getName(), getName());\n+        const auto * mask = typeid_cast<const ColumnTuple *>(col_const->getDataColumnPtr().get());\n+        if (mask)\n+        {\n+            tuple_size = mask->tupleSize();\n+        }\n+        else if (WhichDataType(arguments[0].type).isNativeUInt())\n+        {\n+            tuple_size = col_const->getUInt(0);\n+        }\n+        else\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                            \"Illegal column type {} for function {}, should be UInt or Tuple\",\n+                            arguments[0].type->getName(), getName());\n+        if (tuple_size > max_dimensions || tuple_size < 1)\n+            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n+                            \"Illegal first argument for function {}, should be a number in range 1-{} or a Tuple of such size\",\n+                            getName(), String{max_dimensions});\n+        if (mask)\n+        {\n+            const auto * type_tuple = typeid_cast<const DataTypeTuple *>(arguments[0].type.get());\n+            for (size_t i = 0; i < tuple_size; i++)\n+            {\n+                if (!WhichDataType(type_tuple->getElement(i)).isNativeUInt())\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                                    \"Illegal type {} of argument in tuple for function {}, should be a native UInt\",\n+                                    type_tuple->getElement(i)->getName(), getName());\n+                auto ratio = mask->getColumn(i).getUInt(0);\n+                if (ratio > max_ratio || ratio < min_ratio)\n+                    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n+                                    \"Illegal argument {} in tuple for function {}, should be a number in range {}-{}\",\n+                                    ratio, getName(), String{min_ratio}, String{max_ratio});\n+            }\n+        }\n+        DataTypes types(tuple_size);\n+        for (size_t i = 0; i < tuple_size; i++)\n+        {\n+            types[i] = std::make_shared<DataTypeUInt64>();\n+        }\n+        return std::make_shared<DataTypeTuple>(types);\n+    }\n+};\n+\n+}\ndiff --git a/src/Functions/hilbertDecode.cpp b/src/Functions/hilbertDecode.cpp\nnew file mode 100644\nindex 000000000000..df7f98f56ac0\n--- /dev/null\n+++ b/src/Functions/hilbertDecode.cpp\n@@ -0,0 +1,124 @@\n+#include <Common/BitHelpers.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/PerformanceAdaptors.h>\n+#include \"hilbertDecode2DLUT.h\"\n+#include <limits>\n+\n+\n+namespace DB\n+{\n+\n+class FunctionHilbertDecode : public FunctionSpaceFillingCurveDecode<2, 0, 32>\n+{\n+public:\n+    static constexpr auto name = \"hilbertDecode\";\n+    static FunctionPtr create(ContextPtr)\n+    {\n+        return std::make_shared<FunctionHilbertDecode>();\n+    }\n+\n+    String getName() const override { return name; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        size_t num_dimensions;\n+        const auto * col_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n+        const auto * mask = typeid_cast<const ColumnTuple *>(col_const->getDataColumnPtr().get());\n+        if (mask)\n+            num_dimensions = mask->tupleSize();\n+        else\n+            num_dimensions = col_const->getUInt(0);\n+        const ColumnPtr & col_code = arguments[1].column;\n+        Columns tuple_columns(num_dimensions);\n+\n+        const auto shrink = [mask](const UInt64 value, const UInt8 column_num)\n+        {\n+            if (mask)\n+                return value >> mask->getColumn(column_num).getUInt(0);\n+            return value;\n+        };\n+\n+        auto col0 = ColumnUInt64::create();\n+        auto & vec0 = col0->getData();\n+        vec0.resize(input_rows_count);\n+\n+        if (num_dimensions == 1)\n+        {\n+            for (size_t i = 0; i < input_rows_count; i++)\n+            {\n+                vec0[i] = shrink(col_code->getUInt(i), 0);\n+            }\n+            tuple_columns[0] = std::move(col0);\n+            return ColumnTuple::create(tuple_columns);\n+        }\n+\n+        auto col1 = ColumnUInt64::create();\n+        auto & vec1 = col1->getData();\n+        vec1.resize(input_rows_count);\n+\n+        if (num_dimensions == 2)\n+        {\n+            for (size_t i = 0; i < input_rows_count; i++)\n+            {\n+                const auto res = FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(col_code->getUInt(i));\n+                vec0[i] = shrink(std::get<0>(res), 0);\n+                vec1[i] = shrink(std::get<1>(res), 1);\n+            }\n+            tuple_columns[0] = std::move(col0);\n+            tuple_columns[1] = std::move(col1);\n+            return ColumnTuple::create(tuple_columns);\n+        }\n+\n+        return ColumnTuple::create(tuple_columns);\n+    }\n+};\n+\n+\n+REGISTER_FUNCTION(HilbertDecode)\n+{\n+    factory.registerFunction<FunctionHilbertDecode>(FunctionDocumentation{\n+    .description=R\"(\n+Decodes a Hilbert curve index back into a tuple of unsigned integers, representing coordinates in multi-dimensional space.\n+\n+The function has two modes of operation:\n+- Simple\n+- Expanded\n+\n+Simple Mode: Accepts the desired tuple size as the first argument (up to 2) and the Hilbert index as the second argument. This mode decodes the index into a tuple of the specified size.\n+[example:simple]\n+Will decode into: `(8, 0)`\n+The resulting tuple size cannot be more than 2\n+\n+Expanded Mode: Takes a range mask (tuple) as the first argument and the Hilbert index as the second argument.\n+Each number in the mask specifies the number of bits by which the corresponding decoded argument will be right-shifted, effectively scaling down the output values.\n+[example:range_shrank]\n+Note: see hilbertEncode() docs on why range change might be beneficial.\n+Still limited to 2 numbers at most.\n+\n+Hilbert code for one argument is always the argument itself (as a tuple).\n+[example:identity]\n+Produces: `(1)`\n+\n+A single argument with a tuple specifying bit shifts will be right-shifted accordingly.\n+[example:identity_shrank]\n+Produces: `(128)`\n+\n+The function accepts a column of codes as a second argument:\n+[example:from_table]\n+\n+The range tuple must be a constant:\n+[example:from_table_range]\n+)\",\n+        .examples{\n+            {\"simple\", \"SELECT hilbertDecode(2, 64)\", \"\"},\n+            {\"range_shrank\", \"SELECT hilbertDecode((1,2), 1572864)\", \"\"},\n+            {\"identity\", \"SELECT hilbertDecode(1, 1)\", \"\"},\n+            {\"identity_shrank\", \"SELECT hilbertDecode(tuple(2), 512)\", \"\"},\n+            {\"from_table\", \"SELECT hilbertDecode(2, code) FROM table\", \"\"},\n+            {\"from_table_range\", \"SELECT hilbertDecode((1,2), code) FROM table\", \"\"},\n+            },\n+        .categories {\"Hilbert coding\", \"Hilbert Curve\"}\n+    });\n+}\n+\n+}\ndiff --git a/src/Functions/hilbertDecode2DLUT.h b/src/Functions/hilbertDecode2DLUT.h\nnew file mode 100644\nindex 000000000000..804ba4eb23f3\n--- /dev/null\n+++ b/src/Functions/hilbertDecode2DLUT.h\n@@ -0,0 +1,145 @@\n+#pragma once\n+#include <Functions/FunctionSpaceFillingCurve.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace HilbertDetails\n+{\n+\n+template <UInt8 bit_step>\n+class HilbertDecodeLookupTable\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[0] = {};\n+};\n+\n+template <>\n+class HilbertDecodeLookupTable<1>\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[16] = {\n+        4, 1, 3, 10,\n+        0, 6, 7, 13,\n+        15, 9, 8, 2,\n+        11, 14, 12, 5\n+    };\n+};\n+\n+template <>\n+class HilbertDecodeLookupTable<2>\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[64] = {\n+        0, 20, 21, 49, 18, 3, 7, 38,\n+        26, 11, 15, 46, 61, 41, 40, 12,\n+        16, 1, 5, 36, 8, 28, 29, 57,\n+        10, 30, 31, 59, 39, 54, 50, 19,\n+        47, 62, 58, 27, 55, 35, 34, 6,\n+        53, 33, 32, 4, 24, 9, 13, 44,\n+        63, 43, 42, 14, 45, 60, 56, 25,\n+        37, 52, 48, 17, 2, 22, 23, 51\n+    };\n+};\n+\n+template <>\n+class HilbertDecodeLookupTable<3>\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[256] = {\n+        64, 1, 9, 136, 16, 88, 89, 209, 18, 90, 91, 211, 139, 202, 194, 67,\n+        4, 76, 77, 197, 70, 7, 15, 142, 86, 23, 31, 158, 221, 149, 148, 28,\n+        36, 108, 109, 229, 102, 39, 47, 174, 118, 55, 63, 190, 253, 181, 180, 60,\n+        187, 250, 242, 115, 235, 163, 162, 42, 233, 161, 160, 40, 112, 49, 57, 184,\n+        0, 72, 73, 193, 66, 3, 11, 138, 82, 19, 27, 154, 217, 145, 144, 24,\n+        96, 33, 41, 168, 48, 120, 121, 241, 50, 122, 123, 243, 171, 234, 226, 99,\n+        100, 37, 45, 172, 52, 124, 125, 245, 54, 126, 127, 247, 175, 238, 230, 103,\n+        223, 151, 150, 30, 157, 220, 212, 85, 141, 204, 196, 69, 6, 78, 79, 199,\n+        255, 183, 182, 62, 189, 252, 244, 117, 173, 236, 228, 101, 38, 110, 111, 231,\n+        159, 222, 214, 87, 207, 135, 134, 14, 205, 133, 132, 12, 84, 21, 29, 156,\n+        155, 218, 210, 83, 203, 131, 130, 10, 201, 129, 128, 8, 80, 17, 25, 152,\n+        32, 104, 105, 225, 98, 35, 43, 170, 114, 51, 59, 186, 249, 177, 176, 56,\n+        191, 254, 246, 119, 239, 167, 166, 46, 237, 165, 164, 44, 116, 53, 61, 188,\n+        251, 179, 178, 58, 185, 248, 240, 113, 169, 232, 224, 97, 34, 106, 107, 227,\n+        219, 147, 146, 26, 153, 216, 208, 81, 137, 200, 192, 65, 2, 74, 75, 195,\n+        68, 5, 13, 140, 20, 92, 93, 213, 22, 94, 95, 215, 143, 206, 198, 71\n+    };\n+};\n+\n+}\n+\n+template <UInt8 bit_step>\n+class FunctionHilbertDecode2DWIthLookupTableImpl\n+{\n+    static_assert(bit_step <= 3, \"bit_step should not be more than 3 to fit in UInt8\");\n+public:\n+    static std::tuple<UInt64, UInt64> decode(UInt64 hilbert_code)\n+    {\n+        UInt64 x = 0;\n+        UInt64 y = 0;\n+        const auto leading_zeros_count = getLeadingZeroBits(hilbert_code);\n+        const auto used_bits = std::numeric_limits<UInt64>::digits - leading_zeros_count;\n+\n+        auto [current_shift, state] = getInitialShiftAndState(used_bits);\n+\n+        while (current_shift >= 0)\n+        {\n+            const UInt8 hilbert_bits = (hilbert_code >> current_shift) & HILBERT_MASK;\n+            const auto [x_bits, y_bits] = getCodeAndUpdateState(hilbert_bits, state);\n+            x |= (x_bits << (current_shift >> 1));\n+            y |= (y_bits << (current_shift >> 1));\n+            current_shift -= getHilbertShift(bit_step);\n+        }\n+\n+        return {x, y};\n+    }\n+\n+private:\n+    // for bit_step = 3\n+    // LOOKUP_TABLE[SSHHHHHH] = SSXXXYYY\n+    // where SS - 2 bits for state, XXX - 3 bits of x, YYY - 3 bits of y\n+    // State is rotation of curve on every step, left/up/right/down - therefore 2 bits\n+    static std::pair<UInt64, UInt64> getCodeAndUpdateState(UInt8 hilbert_bits, UInt8& state)\n+    {\n+        const UInt8 table_index = state | hilbert_bits;\n+        const auto table_code = HilbertDetails::HilbertDecodeLookupTable<bit_step>::LOOKUP_TABLE[table_index];\n+        state = table_code & STATE_MASK;\n+        const UInt64 x_bits = (table_code & X_MASK) >> bit_step;\n+        const UInt64 y_bits = table_code & Y_MASK;\n+        return {x_bits, y_bits};\n+    }\n+\n+    // hilbert code is double size of input values\n+    static constexpr UInt8 getHilbertShift(UInt8 shift)\n+    {\n+        return shift << 1;\n+    }\n+\n+    static std::pair<Int8, UInt8> getInitialShiftAndState(UInt8 used_bits)\n+    {\n+        UInt8 iterations = used_bits / HILBERT_SHIFT;\n+        Int8 initial_shift = iterations * HILBERT_SHIFT;\n+        if (initial_shift < used_bits)\n+        {\n+            ++iterations;\n+        }\n+        else\n+        {\n+            initial_shift -= HILBERT_SHIFT;\n+        }\n+        UInt8 state = iterations % 2 == 0 ? LEFT_STATE : DEFAULT_STATE;\n+        return {initial_shift, state};\n+    }\n+\n+    constexpr static UInt8 STEP_MASK = (1 << bit_step) - 1;\n+    constexpr static UInt8 HILBERT_SHIFT = getHilbertShift(bit_step);\n+    constexpr static UInt8 HILBERT_MASK = (1 << HILBERT_SHIFT) - 1;\n+    constexpr static UInt8 STATE_MASK = 0b11 << HILBERT_SHIFT;\n+    constexpr static UInt8 Y_MASK = STEP_MASK;\n+    constexpr static UInt8 X_MASK = STEP_MASK << bit_step;\n+    constexpr static UInt8 LEFT_STATE = 0b01 << HILBERT_SHIFT;\n+    constexpr static UInt8 DEFAULT_STATE = bit_step % 2 == 0 ? LEFT_STATE : 0;\n+};\n+\n+}\ndiff --git a/src/Functions/hilbertEncode.cpp b/src/Functions/hilbertEncode.cpp\nnew file mode 100644\nindex 000000000000..13512d0d36c0\n--- /dev/null\n+++ b/src/Functions/hilbertEncode.cpp\n@@ -0,0 +1,150 @@\n+#include \"hilbertEncode2DLUT.h\"\n+#include <Common/BitHelpers.h>\n+#include <Functions/PerformanceAdaptors.h>\n+#include <limits>\n+#include <optional>\n+#include <Functions/FunctionFactory.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int ARGUMENT_OUT_OF_BOUND;\n+}\n+\n+\n+class FunctionHilbertEncode : public FunctionSpaceFillingCurveEncode\n+{\n+public:\n+    static constexpr auto name = \"hilbertEncode\";\n+    static FunctionPtr create(ContextPtr)\n+    {\n+        return std::make_shared<FunctionHilbertEncode>();\n+    }\n+\n+    String getName() const override { return name; }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        if (input_rows_count == 0)\n+            return ColumnUInt64::create();\n+\n+        size_t num_dimensions = arguments.size();\n+        size_t vector_start_index = 0;\n+        const auto * const_col = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n+        const ColumnTuple * mask;\n+        if (const_col)\n+            mask = typeid_cast<const ColumnTuple *>(const_col->getDataColumnPtr().get());\n+        else\n+            mask = typeid_cast<const ColumnTuple *>(arguments[0].column.get());\n+        if (mask)\n+        {\n+            num_dimensions = mask->tupleSize();\n+            vector_start_index = 1;\n+            for (size_t i = 0; i < num_dimensions; i++)\n+            {\n+                auto ratio = mask->getColumn(i).getUInt(0);\n+                if (ratio > 32)\n+                    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n+                                    \"Illegal argument {} of function {}, should be a number in range 0-32\",\n+                                    arguments[0].column->getName(), getName());\n+            }\n+        }\n+\n+        auto col_res = ColumnUInt64::create();\n+        ColumnUInt64::Container & vec_res = col_res->getData();\n+        vec_res.resize(input_rows_count);\n+\n+        const auto expand = [mask](const UInt64 value, const UInt8 column_num)\n+        {\n+            if (mask)\n+                return value << mask->getColumn(column_num).getUInt(0);\n+            return value;\n+        };\n+\n+        const ColumnPtr & col0 = arguments[0 + vector_start_index].column;\n+        if (num_dimensions == 1)\n+        {\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                vec_res[i] = expand(col0->getUInt(i), 0);\n+            }\n+            return col_res;\n+        }\n+\n+        const ColumnPtr & col1 = arguments[1 + vector_start_index].column;\n+        if (num_dimensions == 2)\n+        {\n+            for (size_t i = 0; i < input_rows_count; ++i)\n+            {\n+                vec_res[i] = FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(\n+                    expand(col0->getUInt(i), 0),\n+                    expand(col1->getUInt(i), 1));\n+            }\n+            return col_res;\n+        }\n+\n+        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"Illegal number of UInt arguments of function {}: should be not more than 2 dimensions\",\n+                        getName());\n+    }\n+};\n+\n+\n+REGISTER_FUNCTION(HilbertEncode)\n+{\n+    factory.registerFunction<FunctionHilbertEncode>(FunctionDocumentation{\n+        .description=R\"(\n+Calculates code for Hilbert Curve for a list of unsigned integers.\n+\n+The function has two modes of operation:\n+- Simple\n+- Expanded\n+\n+Simple: accepts up to 2 unsigned integers as arguments and produces a UInt64 code.\n+[example:simple]\n+Produces: `31`\n+\n+Expanded: accepts a range mask (tuple) as a first argument and up to 2 unsigned integers as other arguments.\n+Each number in the mask configures the number of bits by which the corresponding argument will be shifted left, effectively scaling the argument within its range.\n+[example:range_expanded]\n+Produces: `4031541586602`\n+Note: tuple size must be equal to the number of the other arguments\n+\n+Range expansion can be beneficial when you need a similar distribution for arguments with wildly different ranges (or cardinality)\n+For example: 'IP Address' (0...FFFFFFFF) and 'Country code' (0...FF)\n+\n+For a single argument without a tuple, the function returns the argument itself as the Hilbert index, since no dimensional mapping is needed.\n+[example:identity]\n+Produces: `1`\n+\n+If a single argument is provided with a tuple specifying bit shifts, the function shifts the argument left by the specified number of bits.\n+[example:identity_expanded]\n+Produces: `512`\n+\n+The function also accepts columns as arguments:\n+[example:from_table]\n+\n+But the range tuple must still be a constant:\n+[example:from_table_range]\n+\n+Please note that you can fit only so much bits of information into Hilbert code as UInt64 has.\n+Two arguments will have a range of maximum 2^32 (64/2) each\n+All overflow will be clamped to zero\n+)\",\n+        .examples{\n+            {\"simple\", \"SELECT hilbertEncode(3, 4)\", \"\"},\n+            {\"range_expanded\", \"SELECT hilbertEncode((10,6), 1024, 16)\", \"\"},\n+            {\"identity\", \"SELECT hilbertEncode(1)\", \"\"},\n+            {\"identity_expanded\", \"SELECT hilbertEncode(tuple(2), 128)\", \"\"},\n+            {\"from_table\", \"SELECT hilbertEncode(n1, n2) FROM table\", \"\"},\n+            {\"from_table_range\", \"SELECT hilbertEncode((1,2), n1, n2) FROM table\", \"\"},\n+        },\n+        .categories {\"Hilbert coding\", \"Hilbert Curve\"}\n+    });\n+}\n+\n+}\ndiff --git a/src/Functions/hilbertEncode2DLUT.h b/src/Functions/hilbertEncode2DLUT.h\nnew file mode 100644\nindex 000000000000..413d976a7621\n--- /dev/null\n+++ b/src/Functions/hilbertEncode2DLUT.h\n@@ -0,0 +1,142 @@\n+#pragma once\n+#include <Functions/FunctionSpaceFillingCurve.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace HilbertDetails\n+{\n+\n+template <UInt8 bit_step>\n+class HilbertEncodeLookupTable\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[0] = {};\n+};\n+\n+template <>\n+class HilbertEncodeLookupTable<1>\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[16] = {\n+        4, 1, 11, 2,\n+        0, 15, 5, 6,\n+        10, 9, 3, 12,\n+        14, 7, 13, 8\n+    };\n+};\n+\n+template <>\n+class HilbertEncodeLookupTable<2>\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[64] = {\n+        0, 51, 20, 5, 17, 18, 39, 6,\n+        46, 45, 24, 9, 15, 60, 43, 10,\n+        16, 1, 62, 31, 35, 2, 61, 44,\n+        4, 55, 8, 59, 21, 22, 25, 26,\n+        42, 41, 38, 37, 11, 56, 7, 52,\n+        28, 13, 50, 19, 47, 14, 49, 32,\n+        58, 27, 12, 63, 57, 40, 29, 30,\n+        54, 23, 34, 33, 53, 36, 3, 48\n+    };\n+};\n+\n+\n+template <>\n+class HilbertEncodeLookupTable<3>\n+{\n+public:\n+    constexpr static UInt8 LOOKUP_TABLE[256] = {\n+        64, 1, 206, 79, 16, 211, 84, 21, 131, 2, 205, 140, 81, 82, 151, 22, 4,\n+        199, 8, 203, 158, 157, 88, 25, 69, 70, 73, 74, 31, 220, 155, 26, 186,\n+        185, 182, 181, 32, 227, 100, 37, 59, 248, 55, 244, 97, 98, 167, 38, 124,\n+        61, 242, 115, 174, 173, 104, 41, 191, 62, 241, 176, 47, 236, 171, 42, 0,\n+        195, 68, 5, 250, 123, 60, 255, 65, 66, 135, 6, 249, 184, 125, 126, 142,\n+        141, 72, 9, 246, 119, 178, 177, 15, 204, 139, 10, 245, 180, 51, 240, 80,\n+        17, 222, 95, 96, 33, 238, 111, 147, 18, 221, 156, 163, 34, 237, 172, 20,\n+        215, 24, 219, 36, 231, 40, 235, 85, 86, 89, 90, 101, 102, 105, 106, 170,\n+        169, 166, 165, 154, 153, 150, 149, 43, 232, 39, 228, 27, 216, 23, 212, 108,\n+        45, 226, 99, 92, 29, 210, 83, 175, 46, 225, 160, 159, 30, 209, 144, 48,\n+        243, 116, 53, 202, 75, 12, 207, 113, 114, 183, 54, 201, 136, 77, 78, 190,\n+        189, 120, 57, 198, 71, 130, 129, 63, 252, 187, 58, 197, 132, 3, 192, 234,\n+        107, 44, 239, 112, 49, 254, 127, 233, 168, 109, 110, 179, 50, 253, 188, 230,\n+        103, 162, 161, 52, 247, 56, 251, 229, 164, 35, 224, 117, 118, 121, 122, 218,\n+        91, 28, 223, 138, 137, 134, 133, 217, 152, 93, 94, 11, 200, 7, 196, 214,\n+        87, 146, 145, 76, 13, 194, 67, 213, 148, 19, 208, 143, 14, 193, 128,\n+    };\n+};\n+\n+}\n+\n+template <UInt8 bit_step>\n+class FunctionHilbertEncode2DWIthLookupTableImpl\n+{\n+    static_assert(bit_step <= 3, \"bit_step should not be more than 3 to fit in UInt8\");\n+public:\n+    static UInt64 encode(UInt64 x, UInt64 y)\n+    {\n+        UInt64 hilbert_code = 0;\n+        const auto leading_zeros_count = getLeadingZeroBits(x | y);\n+        const auto used_bits = std::numeric_limits<UInt64>::digits - leading_zeros_count;\n+        if (used_bits > 32)\n+            return 0; // hilbert code will be overflowed in this case\n+\n+        auto [current_shift, state] = getInitialShiftAndState(used_bits);\n+        while (current_shift >= 0)\n+        {\n+            const UInt8 x_bits = (x >> current_shift) & STEP_MASK;\n+            const UInt8 y_bits = (y >> current_shift) & STEP_MASK;\n+            const auto hilbert_bits = getCodeAndUpdateState(x_bits, y_bits, state);\n+            hilbert_code |= (hilbert_bits << getHilbertShift(current_shift));\n+            current_shift -= bit_step;\n+        }\n+\n+        return hilbert_code;\n+    }\n+\n+private:\n+    // for bit_step = 3\n+    // LOOKUP_TABLE[SSXXXYYY] = SSHHHHHH\n+    // where SS - 2 bits for state, XXX - 3 bits of x, YYY - 3 bits of y\n+    // State is rotation of curve on every step, left/up/right/down - therefore 2 bits\n+    static UInt64 getCodeAndUpdateState(UInt8 x_bits, UInt8 y_bits, UInt8& state)\n+    {\n+        const UInt8 table_index = state | (x_bits << bit_step) | y_bits;\n+        const auto table_code = HilbertDetails::HilbertEncodeLookupTable<bit_step>::LOOKUP_TABLE[table_index];\n+        state = table_code & STATE_MASK;\n+        return table_code & HILBERT_MASK;\n+    }\n+\n+    // hilbert code is double size of input values\n+    static constexpr UInt8 getHilbertShift(UInt8 shift)\n+    {\n+        return shift << 1;\n+    }\n+\n+    static std::pair<Int8, UInt8> getInitialShiftAndState(UInt8 used_bits)\n+    {\n+        UInt8 iterations = used_bits / bit_step;\n+        Int8 initial_shift = iterations * bit_step;\n+        if (initial_shift < used_bits)\n+        {\n+            ++iterations;\n+        }\n+        else\n+        {\n+            initial_shift -= bit_step;\n+        }\n+        UInt8 state = iterations % 2 == 0 ? LEFT_STATE : DEFAULT_STATE;\n+        return {initial_shift, state};\n+    }\n+\n+    constexpr static UInt8 STEP_MASK = (1 << bit_step) - 1;\n+    constexpr static UInt8 HILBERT_SHIFT = getHilbertShift(bit_step);\n+    constexpr static UInt8 HILBERT_MASK = (1 << HILBERT_SHIFT) - 1;\n+    constexpr static UInt8 STATE_MASK = 0b11 << HILBERT_SHIFT;\n+    constexpr static UInt8 LEFT_STATE = 0b01 << HILBERT_SHIFT;\n+    constexpr static UInt8 DEFAULT_STATE = bit_step % 2 == 0 ? LEFT_STATE : 0;\n+};\n+\n+}\ndiff --git a/src/Functions/mortonDecode.cpp b/src/Functions/mortonDecode.cpp\nindex f65f38fb097c..2b7b7b4f2e78 100644\n--- a/src/Functions/mortonDecode.cpp\n+++ b/src/Functions/mortonDecode.cpp\n@@ -1,10 +1,11 @@\n-#include <Functions/IFunction.h>\n-#include <Functions/FunctionFactory.h>\n-#include <DataTypes/DataTypesNumber.h>\n-#include <DataTypes/DataTypeTuple.h>\n+#include <Columns/ColumnTuple.h>\n #include <Columns/ColumnsNumber.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n #include <Functions/FunctionHelpers.h>\n-#include <Columns/ColumnTuple.h>\n+#include <Functions/FunctionSpaceFillingCurve.h>\n+#include <Functions/IFunction.h>\n #include <Functions/PerformanceAdaptors.h>\n \n #include <morton-nd/mortonND_LUT.h>\n@@ -15,13 +16,6 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int ILLEGAL_COLUMN;\n-    extern const int ARGUMENT_OUT_OF_BOUND;\n-}\n-\n // NOLINTBEGIN(bugprone-switch-missing-default-case)\n \n #define EXTRACT_VECTOR(INDEX) \\\n@@ -186,7 +180,7 @@ constexpr auto MortonND_5D_Dec = mortonnd::MortonNDLutDecoder<5, 12, 8>();\n constexpr auto MortonND_6D_Dec = mortonnd::MortonNDLutDecoder<6, 10, 8>();\n constexpr auto MortonND_7D_Dec = mortonnd::MortonNDLutDecoder<7, 9, 8>();\n constexpr auto MortonND_8D_Dec = mortonnd::MortonNDLutDecoder<8, 8, 8>();\n-class FunctionMortonDecode : public IFunction\n+class FunctionMortonDecode : public FunctionSpaceFillingCurveDecode<8, 1, 8>\n {\n public:\n     static constexpr auto name = \"mortonDecode\";\n@@ -200,68 +194,6 @@ class FunctionMortonDecode : public IFunction\n         return name;\n     }\n \n-    size_t getNumberOfArguments() const override\n-    {\n-        return 2;\n-    }\n-\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-\n-    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {0}; }\n-\n-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n-    {\n-        UInt64 tuple_size = 0;\n-        const auto * col_const = typeid_cast<const ColumnConst *>(arguments[0].column.get());\n-        if (!col_const)\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                            \"Illegal column type {} of function {}, should be a constant (UInt or Tuple)\",\n-                            arguments[0].type->getName(), getName());\n-        if (!WhichDataType(arguments[1].type).isNativeUInt())\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                            \"Illegal column type {} of function {}, should be a native UInt\",\n-                            arguments[1].type->getName(), getName());\n-        const auto * mask = typeid_cast<const ColumnTuple *>(col_const->getDataColumnPtr().get());\n-        if (mask)\n-        {\n-            tuple_size = mask->tupleSize();\n-        }\n-        else if (WhichDataType(arguments[0].type).isNativeUInt())\n-        {\n-            tuple_size = col_const->getUInt(0);\n-        }\n-        else\n-            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n-                            \"Illegal column type {} of function {}, should be UInt or Tuple\",\n-                            arguments[0].type->getName(), getName());\n-        if (tuple_size > 8 || tuple_size < 1)\n-            throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n-                            \"Illegal first argument for function {}, should be a number in range 1-8 or a Tuple of such size\",\n-                            getName());\n-        if (mask)\n-        {\n-            const auto * type_tuple = typeid_cast<const DataTypeTuple *>(arguments[0].type.get());\n-            for (size_t i = 0; i < tuple_size; i++)\n-            {\n-                if (!WhichDataType(type_tuple->getElement(i)).isNativeUInt())\n-                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                                    \"Illegal type {} of argument in tuple for function {}, should be a native UInt\",\n-                                    type_tuple->getElement(i)->getName(), getName());\n-                auto ratio = mask->getColumn(i).getUInt(0);\n-                if (ratio > 8 || ratio < 1)\n-                    throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n-                                    \"Illegal argument {} in tuple for function {}, should be a number in range 1-8\",\n-                                    ratio, getName());\n-            }\n-        }\n-        DataTypes types(tuple_size);\n-        for (size_t i = 0; i < tuple_size; i++)\n-        {\n-            types[i] = std::make_shared<DataTypeUInt64>();\n-        }\n-        return std::make_shared<DataTypeTuple>(types);\n-    }\n-\n     static UInt64 shrink(UInt64 ratio, UInt64 value)\n     {\n         switch (ratio) // NOLINT(bugprone-switch-missing-default-case)\ndiff --git a/src/Functions/mortonEncode.cpp b/src/Functions/mortonEncode.cpp\nindex 3b95c114b145..0c19c7c3134c 100644\n--- a/src/Functions/mortonEncode.cpp\n+++ b/src/Functions/mortonEncode.cpp\n@@ -1,10 +1,9 @@\n #include <Functions/IFunction.h>\n #include <Functions/FunctionFactory.h>\n-#include <DataTypes/DataTypesNumber.h>\n-#include <DataTypes/DataTypeTuple.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnConst.h>\n #include <Columns/ColumnTuple.h>\n+#include <Functions/FunctionSpaceFillingCurve.h>\n #include <Functions/PerformanceAdaptors.h>\n \n #include <morton-nd/mortonND_LUT.h>\n@@ -19,7 +18,6 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int ARGUMENT_OUT_OF_BOUND;\n-    extern const int TOO_FEW_ARGUMENTS_FOR_FUNCTION;\n }\n \n #define EXTRACT_VECTOR(INDEX) \\\n@@ -144,7 +142,7 @@ constexpr auto MortonND_5D_Enc = mortonnd::MortonNDLutEncoder<5, 12, 8>();\n constexpr auto MortonND_6D_Enc = mortonnd::MortonNDLutEncoder<6, 10, 8>();\n constexpr auto MortonND_7D_Enc = mortonnd::MortonNDLutEncoder<7, 9, 8>();\n constexpr auto MortonND_8D_Enc = mortonnd::MortonNDLutEncoder<8, 8, 8>();\n-class FunctionMortonEncode : public IFunction\n+class FunctionMortonEncode : public FunctionSpaceFillingCurveEncode\n {\n public:\n     static constexpr auto name = \"mortonEncode\";\n@@ -158,56 +156,6 @@ class FunctionMortonEncode : public IFunction\n         return name;\n     }\n \n-    bool isVariadic() const override\n-    {\n-        return true;\n-    }\n-\n-    size_t getNumberOfArguments() const override\n-    {\n-        return 0;\n-    }\n-\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n-\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-    DataTypePtr getReturnTypeImpl(const DB::DataTypes & arguments) const override\n-    {\n-        size_t vectorStartIndex = 0;\n-        if (arguments.empty())\n-            throw Exception(ErrorCodes::TOO_FEW_ARGUMENTS_FOR_FUNCTION,\n-                            \"At least one UInt argument is required for function {}\",\n-                            getName());\n-        if (WhichDataType(arguments[0]).isTuple())\n-        {\n-            vectorStartIndex = 1;\n-            const auto * type_tuple = typeid_cast<const DataTypeTuple *>(arguments[0].get());\n-            auto tuple_size = type_tuple->getElements().size();\n-            if (tuple_size != (arguments.size() - 1))\n-                throw Exception(ErrorCodes::ARGUMENT_OUT_OF_BOUND,\n-                                \"Illegal argument {} for function {}, tuple size should be equal to number of UInt arguments\",\n-                                arguments[0]->getName(), getName());\n-            for (size_t i = 0; i < tuple_size; i++)\n-            {\n-                if (!WhichDataType(type_tuple->getElement(i)).isNativeUInt())\n-                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                                    \"Illegal type {} of argument in tuple for function {}, should be a native UInt\",\n-                                    type_tuple->getElement(i)->getName(), getName());\n-            }\n-        }\n-\n-        for (size_t i = vectorStartIndex; i < arguments.size(); i++)\n-        {\n-            const auto & arg = arguments[i];\n-            if (!WhichDataType(arg).isNativeUInt())\n-                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                                \"Illegal type {} of argument of function {}, should be a native UInt\",\n-                                arg->getName(), getName());\n-        }\n-        return std::make_shared<DataTypeUInt64>();\n-    }\n-\n     static UInt64 expand(UInt64 ratio, UInt64 value)\n     {\n         switch (ratio) // NOLINT(bugprone-switch-missing-default-case)\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex e63a7608210b..e6d6fba76057 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1723,6 +1723,8 @@ hdfs\n hdfsCluster\n heredoc\n heredocs\n+hilbertEncode\n+hilbertDecode\n hiveHash\n holistics\n homebrew\n",
  "test_patch": "diff --git a/src/Functions/tests/gtest_hilbert_curve.cpp b/src/Functions/tests/gtest_hilbert_curve.cpp\nnew file mode 100644\nindex 000000000000..8e2c1b1b1aa2\n--- /dev/null\n+++ b/src/Functions/tests/gtest_hilbert_curve.cpp\n@@ -0,0 +1,81 @@\n+#include <gtest/gtest.h>\n+#include \"Functions/hilbertDecode2DLUT.h\"\n+#include \"Functions/hilbertEncode2DLUT.h\"\n+#include \"base/types.h\"\n+\n+\n+TEST(HilbertLookupTable, EncodeBit1And3Consistency)\n+{\n+    const size_t bound = 1000;\n+    for (size_t x = 0; x < bound; ++x)\n+    {\n+        for (size_t y = 0; y < bound; ++y)\n+        {\n+            auto hilbert1bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<1>::encode(x, y);\n+            auto hilbert3bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);\n+            ASSERT_EQ(hilbert1bit, hilbert3bit);\n+        }\n+    }\n+}\n+\n+TEST(HilbertLookupTable, EncodeBit2And3Consistency)\n+{\n+    const size_t bound = 1000;\n+    for (size_t x = 0; x < bound; ++x)\n+    {\n+        for (size_t y = 0; y < bound; ++y)\n+        {\n+            auto hilbert2bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<2>::encode(x, y);\n+            auto hilbert3bit = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);\n+            ASSERT_EQ(hilbert3bit, hilbert2bit);\n+        }\n+    }\n+}\n+\n+TEST(HilbertLookupTable, DecodeBit1And3Consistency)\n+{\n+    const size_t bound = 1000 * 1000;\n+    for (size_t hilbert_code = 0; hilbert_code < bound; ++hilbert_code)\n+    {\n+        auto res1 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<1>::decode(hilbert_code);\n+        auto res3 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);\n+        ASSERT_EQ(res1, res3);\n+    }\n+}\n+\n+TEST(HilbertLookupTable, DecodeBit2And3Consistency)\n+{\n+    const size_t bound = 1000 * 1000;\n+    for (size_t hilbert_code = 0; hilbert_code < bound; ++hilbert_code)\n+    {\n+        auto res2 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<2>::decode(hilbert_code);\n+        auto res3 = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);\n+        ASSERT_EQ(res2, res3);\n+    }\n+}\n+\n+TEST(HilbertLookupTable, DecodeAndEncodeAreInverseOperations)\n+{\n+    const size_t bound = 1000;\n+    for (size_t x = 0; x < bound; ++x)\n+    {\n+        for (size_t y = 0; y < bound; ++y)\n+        {\n+            auto hilbert_code = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);\n+            auto [x_new, y_new] = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);\n+            ASSERT_EQ(x_new, x);\n+            ASSERT_EQ(y_new, y);\n+        }\n+    }\n+}\n+\n+TEST(HilbertLookupTable, EncodeAndDecodeAreInverseOperations)\n+{\n+    const size_t bound = 1000 * 1000;\n+    for (size_t hilbert_code = 0; hilbert_code < bound; ++hilbert_code)\n+    {\n+        auto [x, y] = DB::FunctionHilbertDecode2DWIthLookupTableImpl<3>::decode(hilbert_code);\n+        auto hilbert_new = DB::FunctionHilbertEncode2DWIthLookupTableImpl<3>::encode(x, y);\n+        ASSERT_EQ(hilbert_new, hilbert_code);\n+    }\n+}\ndiff --git a/tests/queries/0_stateless/03131_hilbert_coding.reference b/tests/queries/0_stateless/03131_hilbert_coding.reference\nnew file mode 100644\nindex 000000000000..bdb578483faf\n--- /dev/null\n+++ b/tests/queries/0_stateless/03131_hilbert_coding.reference\n@@ -0,0 +1,8 @@\n+----- START -----\n+----- CONST -----\n+133\n+31\n+(3,4)\n+----- 4294967296, 2 -----\n+----- ERRORS -----\n+----- END -----\ndiff --git a/tests/queries/0_stateless/03131_hilbert_coding.sql b/tests/queries/0_stateless/03131_hilbert_coding.sql\nnew file mode 100644\nindex 000000000000..ed293dc6910a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03131_hilbert_coding.sql\n@@ -0,0 +1,55 @@\n+SELECT '----- START -----';\n+drop table if exists hilbert_numbers_03131;\n+create table hilbert_numbers_03131(\n+    n1 UInt32,\n+    n2 UInt32\n+)\n+    Engine=MergeTree()\n+    ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';\n+\n+SELECT '----- CONST -----';\n+select hilbertEncode(133);\n+select hilbertEncode(3, 4);\n+select hilbertDecode(2, 31);\n+\n+SELECT '----- 4294967296, 2 -----';\n+insert into hilbert_numbers_03131\n+select n1.number, n2.number\n+from numbers(pow(2, 32)-8,8) n1\n+    cross join numbers(pow(2, 32)-8, 8) n2\n+;\n+\n+drop table if exists hilbert_numbers_1_03131;\n+create table hilbert_numbers_1_03131(\n+    n1 UInt64,\n+    n2 UInt64\n+)\n+    Engine=MergeTree()\n+    ORDER BY n1 SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';\n+\n+insert into hilbert_numbers_1_03131\n+select untuple(hilbertDecode(2, hilbertEncode(n1, n2)))\n+from hilbert_numbers_03131;\n+\n+(\n+    select n1, n2 from hilbert_numbers_03131\n+    union distinct\n+    select n1, n2 from hilbert_numbers_1_03131\n+)\n+except\n+(\n+    select n1, n2 from hilbert_numbers_03131\n+    intersect\n+    select n1, n2 from hilbert_numbers_1_03131\n+);\n+drop table if exists hilbert_numbers_1_03131;\n+\n+select '----- ERRORS -----';\n+select hilbertEncode(); -- { serverError TOO_FEW_ARGUMENTS_FOR_FUNCTION }\n+select hilbertDecode(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+select hilbertEncode('text'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+select hilbertDecode('text', 'text'); -- { serverError ILLEGAL_COLUMN }\n+select hilbertEncode((1, 2), 3); -- { serverError ARGUMENT_OUT_OF_BOUND }\n+\n+SELECT '----- END -----';\n+drop table if exists hilbert_numbers_03131;\n",
  "problem_statement": "`hilbertEncode`, `hilbertDecode` functions\n**Describe the solution you'd like**\r\n\r\nSimilar to `mortonEncode`, `mortonDecode`, but using Hilbert curve.\r\nExample: https://github.com/spectral3d/hilbert_hpp\n",
  "hints_text": "what do you expect here?\r\n\nThis task has some prerequisites to do it - you should find the source code of functions for Morton curves, learn the difference between Morton and Hilbert, and implement the new functions.\nSo basically you want to implement functionality of morton code using Hilbert curve ?\nI'd like to take a stab at this. Very new to open source but would like to try implementing this feature.\nThank you! Check this repository: https://github.com/becheran/fast-hilbert/blob/main/src/lib.rs\r\nWe will use the same approach (table-based, 2d-only).\r\nWe need to rewrite it in C++.\nFor my own personal understanding, what will this function be applied to. As in what values are going to be encoded/decoded? (IP's, raw data, feature engineering, etc)\nHi! Can I consider this task as open and contribute on it?\nYes, it is currently open.\n> For my own personal understanding, what will this function be applied to.\r\n\r\nThere are two use cases:\r\n\r\n1. Indexing.\r\n\r\nIt will be used to mix together the ordering by two columns that are similar in their distribution. E.g. longitude and latitude; connection IP address and X-Forwarded-For IP address; call start time and call end time; advertiser ID and advertisement place ID; origin and destination address; URL and Referer hash; sender ID and recipient ID.\r\n\r\nQuite a lot of use cases when you have two values, but cannot decide which one is more important than the other.\r\n\r\nIndexing by the Hilbert curve provides better data locality than by the Morton curve.\r\n\r\n2. Visualization.\r\n\r\nIt will be used when you want to map single-dimensional data into 2D space, like I do in my service https://reversedns.space/ You see the example with IP addresses, but another example includes RAM visualization and machine code visualization. The Hilbert curve has fewer discontinuities (zero) than the Morton curve (infinity).\n> Yes, it is currently open.\r\n\r\nCan I ask to assign this task to me? Or it is not necessary and I can try to develop without assigning?\n> > Yes, it is currently open.\r\n> \r\n> Can I ask to assign this task to me? Or it is not necessary and I can try to develop without assigning?\r\n\r\nI am currently working on this issue as assigned task of InternTask (you can see it here https://github.com/ClickHouse/ClickHouse/issues/58394)",
  "created_at": "2024-02-19T20:30:54Z"
}