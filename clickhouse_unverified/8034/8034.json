{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8034,
  "instance_id": "ClickHouse__ClickHouse-8034",
  "issue_numbers": [
    "8000"
  ],
  "base_commit": "dd58ddbc9a5587911b46ad44d0d52b7cabe8466d",
  "patch": "diff --git a/dbms/src/Functions/h3EdgeAngle.cpp b/dbms/src/Functions/h3EdgeAngle.cpp\nnew file mode 100644\nindex 000000000000..be3dac0e9d7b\n--- /dev/null\n+++ b/dbms/src/Functions/h3EdgeAngle.cpp\n@@ -0,0 +1,78 @@\n+#include \"config_functions.h\"\n+#if USE_H3\n+#    include <Columns/ColumnsNumber.h>\n+#    include <DataTypes/DataTypesNumber.h>\n+#    include <Functions/FunctionFactory.h>\n+#    include <Functions/IFunction.h>\n+#    include <Common/typeid_cast.h>\n+#    include <ext/range.h>\n+\n+\n+extern \"C\" {\n+#    ifdef __clang__\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wdocumentation\"\n+#    endif\n+\n+#    include <h3api.h>\n+\n+#    ifdef __clang__\n+#        pragma clang diagnostic pop\n+#    endif\n+}\n+\n+namespace DB\n+{\n+class FunctionH3EdgeAngle : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"h3EdgeAngle\";\n+\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionH3EdgeAngle>(); }\n+\n+    std::string getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        auto arg = arguments[0].get();\n+        if (!WhichDataType(arg).isUInt8())\n+            throw Exception(\n+                \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(1) + \" of function \" + getName() + \". Must be UInt8\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeFloat64>();\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const auto col_hindex = block.getByPosition(arguments[0]).column.get();\n+\n+        auto dst = ColumnVector<Float64>::create();\n+        auto & dst_data = dst->getData();\n+        dst_data.resize(input_rows_count);\n+\n+        for (const auto row : ext::range(0, input_rows_count))\n+        {\n+            const int resolution = col_hindex->getUInt(row);\n+\n+            // Numerical constant is 180 degrees / pi / Earth radius, Earth radius is from h3 sources\n+            Float64 res = 8.99320592271288084e-6 * H3_EXPORT(edgeLengthM)(resolution);\n+\n+            dst_data[row] = res;\n+        }\n+\n+        block.getByPosition(result).column = std::move(dst);\n+    }\n+};\n+\n+\n+void registerFunctionH3EdgeAngle(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionH3EdgeAngle>();\n+}\n+\n+}\n+#endif\ndiff --git a/dbms/src/Functions/h3EdgeLengthM.cpp b/dbms/src/Functions/h3EdgeLengthM.cpp\nnew file mode 100644\nindex 000000000000..5a52d1d54a87\n--- /dev/null\n+++ b/dbms/src/Functions/h3EdgeLengthM.cpp\n@@ -0,0 +1,82 @@\n+#include \"config_functions.h\"\n+#if USE_H3\n+#    include <Columns/ColumnsNumber.h>\n+#    include <DataTypes/DataTypesNumber.h>\n+#    include <Functions/FunctionFactory.h>\n+#    include <Functions/IFunction.h>\n+#    include <Common/typeid_cast.h>\n+#    include <ext/range.h>\n+\n+\n+extern \"C\" {\n+#    ifdef __clang__\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wdocumentation\"\n+#    endif\n+\n+#    include <h3api.h>\n+\n+#    ifdef __clang__\n+#        pragma clang diagnostic pop\n+#    endif\n+}\n+\n+namespace DB\n+{\n+// Average metric edge length of H3 hexagon. The edge length `e` for given resolution `res` can\n+// be used for converting metric search radius `radius` to hexagon search ring size `k` that is\n+// used by `H3kRing` function. For small enough search area simple flat approximation can be used,\n+// i.e. the smallest `k` that satisfies relation `3 k^2 - 3 k + 1 >= (radius / e)^2` should be\n+// chosen\n+class FunctionH3EdgeLengthM : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"h3EdgeLengthM\";\n+\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionH3EdgeLengthM>(); }\n+\n+    std::string getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        auto arg = arguments[0].get();\n+        if (!WhichDataType(arg).isUInt8())\n+            throw Exception(\n+                \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(1) + \" of function \" + getName() + \". Must be UInt8\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeFloat64>();\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const auto col_hindex = block.getByPosition(arguments[0]).column.get();\n+\n+        auto dst = ColumnVector<Float64>::create();\n+        auto & dst_data = dst->getData();\n+        dst_data.resize(input_rows_count);\n+\n+        for (const auto row : ext::range(0, input_rows_count))\n+        {\n+            const int resolution = col_hindex->getUInt(row);\n+\n+            Float64 res = H3_EXPORT(edgeLengthM)(resolution);\n+\n+            dst_data[row] = res;\n+        }\n+\n+        block.getByPosition(result).column = std::move(dst);\n+    }\n+};\n+\n+\n+void registerFunctionH3EdgeLengthM(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionH3EdgeLengthM>();\n+}\n+\n+}\n+#endif\ndiff --git a/dbms/src/Functions/h3GetResolution.cpp b/dbms/src/Functions/h3GetResolution.cpp\nnew file mode 100644\nindex 000000000000..bf52d7a774c6\n--- /dev/null\n+++ b/dbms/src/Functions/h3GetResolution.cpp\n@@ -0,0 +1,77 @@\n+#include \"config_functions.h\"\n+#if USE_H3\n+#    include <Columns/ColumnsNumber.h>\n+#    include <DataTypes/DataTypesNumber.h>\n+#    include <Functions/FunctionFactory.h>\n+#    include <Functions/IFunction.h>\n+#    include <Common/typeid_cast.h>\n+#    include <ext/range.h>\n+\n+\n+extern \"C\" {\n+#    ifdef __clang__\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wdocumentation\"\n+#    endif\n+\n+#    include <h3api.h>\n+\n+#    ifdef __clang__\n+#        pragma clang diagnostic pop\n+#    endif\n+}\n+\n+namespace DB\n+{\n+class FunctionH3GetResolution : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"h3GetResolution\";\n+\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionH3GetResolution>(); }\n+\n+    std::string getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        auto arg = arguments[0].get();\n+        if (!WhichDataType(arg).isUInt64())\n+            throw Exception(\n+                \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(1) + \" of function \" + getName() + \". Must be UInt64\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeUInt8>();\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const auto col_hindex = block.getByPosition(arguments[0]).column.get();\n+\n+        auto dst = ColumnVector<UInt8>::create();\n+        auto & dst_data = dst->getData();\n+        dst_data.resize(input_rows_count);\n+\n+        for (const auto row : ext::range(0, input_rows_count))\n+        {\n+            const UInt64 hindex = col_hindex->getUInt(row);\n+\n+            UInt8 res = H3_EXPORT(h3GetResolution)(hindex);\n+\n+            dst_data[row] = res;\n+        }\n+\n+        block.getByPosition(result).column = std::move(dst);\n+    }\n+};\n+\n+\n+void registerFunctionH3GetResolution(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionH3GetResolution>();\n+}\n+\n+}\n+#endif\ndiff --git a/dbms/src/Functions/h3IsValid.cpp b/dbms/src/Functions/h3IsValid.cpp\nnew file mode 100644\nindex 000000000000..8d0430caddb3\n--- /dev/null\n+++ b/dbms/src/Functions/h3IsValid.cpp\n@@ -0,0 +1,77 @@\n+#include \"config_functions.h\"\n+#if USE_H3\n+#    include <Columns/ColumnsNumber.h>\n+#    include <DataTypes/DataTypesNumber.h>\n+#    include <Functions/FunctionFactory.h>\n+#    include <Functions/IFunction.h>\n+#    include <Common/typeid_cast.h>\n+#    include <ext/range.h>\n+\n+\n+extern \"C\" {\n+#    ifdef __clang__\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wdocumentation\"\n+#    endif\n+\n+#    include <h3api.h>\n+\n+#    ifdef __clang__\n+#        pragma clang diagnostic pop\n+#    endif\n+}\n+\n+namespace DB\n+{\n+class FunctionH3IsValid : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"h3IsValid\";\n+\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionH3IsValid>(); }\n+\n+    std::string getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 1; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        auto arg = arguments[0].get();\n+        if (!WhichDataType(arg).isUInt64())\n+            throw Exception(\n+                \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(1) + \" of function \" + getName() + \". Must be UInt64\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeUInt8>();\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const auto col_hindex = block.getByPosition(arguments[0]).column.get();\n+\n+        auto dst = ColumnVector<UInt8>::create();\n+        auto & dst_data = dst->getData();\n+        dst_data.resize(input_rows_count);\n+\n+        for (const auto row : ext::range(0, input_rows_count))\n+        {\n+            const UInt64 hindex = col_hindex->getUInt(row);\n+\n+            UInt8 is_valid = H3_EXPORT(h3IsValid)(hindex) == 0 ? 0 : 1;\n+\n+            dst_data[row] = is_valid;\n+        }\n+\n+        block.getByPosition(result).column = std::move(dst);\n+    }\n+};\n+\n+\n+void registerFunctionH3IsValid(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionH3IsValid>();\n+}\n+\n+}\n+#endif\ndiff --git a/dbms/src/Functions/h3kRing.cpp b/dbms/src/Functions/h3kRing.cpp\nnew file mode 100644\nindex 000000000000..685ef381d88d\n--- /dev/null\n+++ b/dbms/src/Functions/h3kRing.cpp\n@@ -0,0 +1,103 @@\n+#include \"config_functions.h\"\n+#if USE_H3\n+#    include <vector>\n+#    include <Columns/ColumnArray.h>\n+#    include <Columns/ColumnsNumber.h>\n+#    include <DataTypes/DataTypeArray.h>\n+#    include <DataTypes/DataTypesNumber.h>\n+#    include <DataTypes/IDataType.h>\n+#    include <Functions/FunctionFactory.h>\n+#    include <Functions/IFunction.h>\n+#    include <Common/typeid_cast.h>\n+#    include <ext/range.h>\n+\n+extern \"C\" {\n+#    ifdef __clang__\n+#        pragma clang diagnostic push\n+#        pragma clang diagnostic ignored \"-Wdocumentation\"\n+#    endif\n+\n+#    include <h3api.h>\n+\n+#    ifdef __clang__\n+#        pragma clang diagnostic pop\n+#    endif\n+}\n+\n+namespace DB\n+{\n+class FunctionH3KRing : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"h3kRing\";\n+\n+    static FunctionPtr create(const Context &) { return std::make_shared<FunctionH3KRing>(); }\n+\n+    std::string getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        auto arg = arguments[0].get();\n+        if (!WhichDataType(arg).isUInt64())\n+            throw Exception(\n+                \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(1) + \" of function \" + getName() + \". Must be UInt64\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        arg = arguments[1].get();\n+        if (!isInteger(arg))\n+            throw Exception(\n+                \"Illegal type \" + arg->getName() + \" of argument \" + std::to_string(2) + \" of function \" + getName() + \". Must be integer\",\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n+    }\n+\n+    void executeImpl(Block & block, const ColumnNumbers & arguments, size_t result, size_t input_rows_count) override\n+    {\n+        const auto col_hindex = block.getByPosition(arguments[0]).column.get();\n+        const auto col_k = block.getByPosition(arguments[1]).column.get();\n+\n+        auto dst = ColumnArray::create(ColumnUInt64::create());\n+        auto & dst_data = dst->getData();\n+        auto & dst_offsets = dst->getOffsets();\n+        dst_offsets.resize(input_rows_count);\n+        auto current_offset = 0;\n+\n+        std::vector<H3Index> hindex_vec;\n+\n+        for (const auto row : ext::range(0, input_rows_count))\n+        {\n+            const H3Index origin_hindex = col_hindex->getUInt(row);\n+            const int k = col_k->getInt(row);\n+\n+            const auto vec_size = H3_EXPORT(maxKringSize)(k);\n+            hindex_vec.resize(vec_size);\n+            H3_EXPORT(kRing)(origin_hindex, k, hindex_vec.data());\n+\n+            dst_data.reserve(dst_data.size() + vec_size);\n+            for (auto hindex : hindex_vec)\n+            {\n+                if (hindex != 0)\n+                {\n+                    ++current_offset;\n+                    dst_data.insert(hindex);\n+                }\n+            }\n+            dst_offsets[row] = current_offset;\n+        }\n+\n+        block.getByPosition(result).column = std::move(dst);\n+    }\n+};\n+\n+\n+void registerFunctionH3KRing(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionH3KRing>();\n+}\n+\n+}\n+#endif\ndiff --git a/dbms/src/Functions/registerFunctionsGeo.cpp b/dbms/src/Functions/registerFunctionsGeo.cpp\nindex f2bd7dda7e79..d1a251bacbf4 100644\n--- a/dbms/src/Functions/registerFunctionsGeo.cpp\n+++ b/dbms/src/Functions/registerFunctionsGeo.cpp\n@@ -14,6 +14,11 @@ void registerFunctionGeohashesInBox(FunctionFactory & factory);\n \n #if USE_H3\n void registerFunctionGeoToH3(FunctionFactory &);\n+void registerFunctionH3EdgeAngle(FunctionFactory &);\n+void registerFunctionH3EdgeLengthM(FunctionFactory &);\n+void registerFunctionH3GetResolution(FunctionFactory &);\n+void registerFunctionH3IsValid(FunctionFactory &);\n+void registerFunctionH3KRing(FunctionFactory &);\n #endif\n \n void registerFunctionsGeo(FunctionFactory & factory)\n@@ -27,6 +32,11 @@ void registerFunctionsGeo(FunctionFactory & factory)\n \n #if USE_H3\n     registerFunctionGeoToH3(factory);\n+    registerFunctionH3EdgeAngle(factory);\n+    registerFunctionH3EdgeLengthM(factory);\n+    registerFunctionH3GetResolution(factory);\n+    registerFunctionH3IsValid(factory);\n+    registerFunctionH3KRing(factory);\n #endif\n }\n \ndiff --git a/docs/ru/query_language/functions/geo.md b/docs/ru/query_language/functions/geo.md\nindex 74ea1e12219d..d3dc92c46795 100644\n--- a/docs/ru/query_language/functions/geo.md\n+++ b/docs/ru/query_language/functions/geo.md\n@@ -35,6 +35,38 @@ SELECT greatCircleDistance(55.755831, 37.617673, -55.755831, -37.617673)\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## greatCircleAngle\n+\n+\u0412\u044b\u0447\u0438\u0441\u043b\u044f\u0435\u0442 \u0443\u0433\u043b\u043e\u0432\u043e\u0435 \u0440\u0430\u0441\u0441\u0442\u043e\u044f\u043d\u0438\u0435 \u043d\u0430 \u0441\u0444\u0435\u0440\u0435 \u043f\u043e [\u0444\u043e\u0440\u043c\u0443\u043b\u0435 \u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u043a\u0440\u0443\u0433\u0430](https://en.wikipedia.org/wiki/Great-circle_distance).\n+\n+```sql\n+greatCircleDistance(lon1Deg, lat1Deg, lon2Deg, lat2Deg)\n+```\n+\n+**\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u044b**\n+\n+- `lon1Deg` \u2014 \u0434\u043e\u043b\u0433\u043e\u0442\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445.\n+- `lat1Deg` \u2014 \u0448\u0438\u0440\u043e\u0442\u0430 \u043f\u0435\u0440\u0432\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445.\n+- `lon2Deg` \u2014 \u0434\u043e\u043b\u0433\u043e\u0442\u0430 \u0432\u0442\u043e\u0440\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445.\n+- `lat2Deg` \u2014 \u0448\u0438\u0440\u043e\u0442\u0430 \u0432\u0442\u043e\u0440\u043e\u0439 \u0442\u043e\u0447\u043a\u0438 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445.\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n+\n+\u0414\u043b\u0438\u043d\u0430 \u0434\u0443\u0433\u0438 \u0431\u043e\u043b\u044c\u0448\u043e\u0433\u043e \u043a\u0440\u0443\u0433\u0430 \u043c\u0435\u0436\u0434\u0443 \u0434\u0432\u0443\u043c\u044f \u0442\u043e\u0447\u043a\u0430\u043c\u0438 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445.\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n+\n+```sql\n+SELECT greatCircleAngle(0, 0, 45, 0) AS arc\n+```\n+\n+```text\n+\u250c\u2500arc\u2500\u2510\n+\u2502  45 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\n ## pointInEllipses\n \n \u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442, \u043f\u0440\u0438\u043d\u0430\u0434\u043b\u0435\u0436\u0438\u0442 \u043b\u0438 \u0442\u043e\u0447\u043a\u0430 \u0445\u043e\u0442\u044f \u0431\u044b \u043e\u0434\u043d\u043e\u043c\u0443 \u0438\u0437 \u044d\u043b\u043b\u0438\u043f\u0441\u043e\u0432.\n@@ -157,6 +189,121 @@ SELECT geohashDecode('ezs42') AS res\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## h3IsValid\n+\n+\u041f\u0440\u043e\u0432\u0435\u0440\u044f\u0435\u0442 \u043a\u043e\u0440\u0440\u0435\u043a\u0442\u043d\u043e\u0441\u0442\u044c H3-\u0438\u043d\u0434\u0435\u043a\u0441\u0430.\n+\n+```sql\n+h3IsValid(h3index)\n+```\n+\n+**\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- `h3index` \u2014 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0448\u0435\u0441\u0442\u0438\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. \u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 \u2014 [UInt64](../../data_types/int_uint.md).\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- 0 \u2014 \u0447\u0438\u0441\u043b\u043e \u043d\u0435 \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f H3-\u0438\u043d\u0434\u0435\u043a\u0441\u043e\u043c\n+- 1 \u2014 \u0447\u0438\u0441\u043b\u043e \u044f\u0432\u043b\u044f\u0435\u0442\u0441\u044f H3-\u0438\u043d\u0434\u0435\u043a\u0441\u043e\u043c\n+\n+\u0422\u0438\u043f \u2014 [UInt8](../../data_types/int_uint.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n+\n+```sql\n+SELECT h3IsValid(630814730351855103) as h3IsValid\n+```\n+```text\n+\u250c\u2500h3IsValid\u2500\u2510\n+\u2502         1 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## h3GetResolution\n+\n+\u0418\u0437\u0432\u043b\u0435\u043a\u0430\u0435\u0442 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 H3-\u0438\u043d\u0434\u0435\u043a\u0441\u0430.\n+\n+```sql\n+h3GetResolution(h3index)\n+```\n+\n+**\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- `h3index` \u2014 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0448\u0435\u0441\u0442\u0438\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. \u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 \u2014 [UInt64](../../data_types/int_uint.md).\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- \u0420\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0441\u0435\u0442\u043a\u0438, \u043e\u0442 0 \u0434\u043e 15.\n+- \u0414\u043b\u044f \u043d\u0435\u0441\u0443\u0449\u0435\u0441\u0442\u0432\u0443\u044e\u0449\u0435\u0433\u043e \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u0430 \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0435\u043d\u043e \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0439\u0442\u0435 [h3IsValid](#h3IsValid) \u0434\u043b\u044f \u043f\u0440\u043e\u0432\u0435\u0440\u043a\u0438 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440\u043e\u0432\n+\n+\u0422\u0438\u043f \u2014 [UInt8](../../data_types/int_uint.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n+\n+```sql\n+SELECT h3GetResolution(639821929606596015) as resolution\n+```\n+```text\n+\u250c\u2500resolution\u2500\u2510\n+\u2502         14 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+## h3EdgeAngle\n+\n+\u0418\u043d\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u043e \u0441\u0440\u0435\u0434\u043d\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u0448\u0435\u0441\u0442\u0438\u0433\u0440\u0430\u043d\u043d\u0438\u043a\u0430 H3 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445\n+\n+```sql\n+h3EdgeAngle(resolution)\n+```\n+\n+**\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- `resolution` \u2014 \u0442\u0440\u0435\u0431\u0443\u0435\u043c\u043e\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u0430. \u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 \u2014 [UInt8](../../data_types/int_uint.md). \u0414\u0438\u0430\u043f\u0430\u0437\u043e\u043d \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u2014 `[0, 15]`.\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+\u0421\u0440\u0435\u0434\u043d\u044f\u044f \u0434\u043b\u0438\u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u043c\u043d\u043e\u0433\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 H3 \u0432 \u0433\u0440\u0430\u0434\u0443\u0441\u0430\u0445, \u0442\u0438\u043f \u2014 [Float64](../../data_types/float.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n+\n+```sql\n+SELECT h3EdgeAngle(10) as edgeAngle\n+```\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500h3EdgeAngle(10)\u2500\u2510\n+\u2502 0.0005927224846720883 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\n+## h3EdgeLengthM\n+\n+\u0418\u043d\u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442 \u043e \u0441\u0440\u0435\u0434\u043d\u0435\u043c \u0440\u0430\u0437\u043c\u0435\u0440\u0435 \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u0448\u0435\u0441\u0442\u0438\u0433\u0440\u0430\u043d\u043d\u0438\u043a\u0430 H3 \u0432 \u043c\u0435\u0442\u0440\u0430\u0445\n+\n+```sql\n+h3EdgeLengthM(resolution)\n+```\n+\n+**\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- `resolution` \u2014 \u0442\u0440\u0435\u0431\u0443\u0435\u043c\u043e\u0435 \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435 \u0438\u043d\u0434\u0435\u043a\u0441\u0430. \u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 \u2014 [UInt8](../../data_types/int_uint.md). \u0414\u0438\u0430\u043f\u0430\u0437\u043e\u043d \u0432\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0445 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u2014 `[0, 15]`.\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+\u0421\u0440\u0435\u0434\u043d\u044f\u044f \u0434\u043b\u0438\u043d\u0430 \u0441\u0442\u043e\u0440\u043e\u043d\u044b \u043c\u043d\u043e\u0433\u043e\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430 H3 \u0432 \u043c\u0435\u0442\u0440\u0430\u0445, \u0442\u0438\u043f \u2014 [Float64](../../data_types/float.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n+\n+```sql\n+SELECT h3EdgeLengthM(15) as edgeLengthM\n+```\n+```text\n+\u250c\u2500edgeLengthM\u2500\u2510\n+\u2502 0.509713273 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## geoToH3\n \n \u041f\u043e\u043b\u0443\u0447\u0430\u0435\u0442 H3 \u0438\u043d\u0434\u0435\u043a\u0441 \u0442\u043e\u0447\u043a\u0438 `(lon, lat)` \u0441 \u0437\u0430\u0434\u0430\u043d\u043d\u044b\u043c \u0440\u0430\u0437\u0440\u0435\u0448\u0435\u043d\u0438\u0435\u043c\n@@ -189,4 +336,38 @@ SELECT geoToH3(37.79506683, 55.71290588, 15) as h3Index\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## h3kRing\n+\n+\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 H3-\u0438\u043d\u0434\u0435\u043a\u0441\u044b \u0448\u0435\u0441\u0442\u0438\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u043e\u0432 \u0432 \u0440\u0430\u0434\u0438\u0443\u0441\u0435 `k` \u043e\u0442 \u0434\u0430\u043d\u043d\u043e\u0433\u043e \u0432 \u043f\u0440\u043e\u0438\u0437\u0432\u043e\u043b\u044c\u043d\u043e\u043c \u043f\u043e\u0440\u044f\u0434\u043a\u0435\n+\n+```sql\n+h3kRing(h3index, k)\n+```\n+**\u0412\u0445\u043e\u0434\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+- `h3index` \u2014 \u0438\u0434\u0435\u043d\u0442\u0438\u0444\u0438\u043a\u0430\u0442\u043e\u0440 \u0448\u0435\u0441\u0442\u0438\u0443\u0433\u043e\u043b\u044c\u043d\u0438\u043a\u0430. \u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 \u2014 [UInt64](../../data_types/int_uint.md).\n+- `k` \u2014 \u0440\u0430\u0434\u0438\u0443\u0441. \u0422\u0438\u043f \u0434\u0430\u043d\u043d\u044b\u0445 \u2014 [\u0446\u0435\u043b\u043e\u0435 \u0447\u0438\u0441\u043b\u043e](../../data_types/int_uint.md)\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f**\n+\n+[\u041c\u0430\u0441\u0441\u0438\u0432](../../data_types/array.md) \u0438\u0437 H3-\u0438\u043d\u0434\u0435\u043a\u0441\u043e\u0432 \u0442\u0438\u043f\u0430 [UInt64](../../data_types/int_uint.md).\n+\n+**\u041f\u0440\u0438\u043c\u0435\u0440**\n+\n+```sql\n+SELECT arrayJoin(h3kRing(644325529233966508, 1)) AS h3index\n+```\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500h3index\u2500\u2510\n+\u2502 644325529233966508 \u2502\n+\u2502 644325529233966497 \u2502\n+\u2502 644325529233966510 \u2502\n+\u2502 644325529233966504 \u2502\n+\u2502 644325529233966509 \u2502\n+\u2502 644325529233966355 \u2502\n+\u2502 644325529233966354 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\n [\u041e\u0440\u0438\u0433\u0438\u043d\u0430\u043b\u044c\u043d\u0430\u044f \u0441\u0442\u0430\u0442\u044c\u044f](https://clickhouse.yandex/docs/ru/query_language/functions/geo/) <!--hide-->\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01040_h3_get_resolution.reference b/dbms/tests/queries/0_stateless/01040_h3_get_resolution.reference\nnew file mode 100644\nindex 000000000000..534d68126f60\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01040_h3_get_resolution.reference\n@@ -0,0 +1,3 @@\n+1\n+10\n+15\ndiff --git a/dbms/tests/queries/0_stateless/01040_h3_get_resolution.sql b/dbms/tests/queries/0_stateless/01040_h3_get_resolution.sql\nnew file mode 100644\nindex 000000000000..3dc27216333f\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01040_h3_get_resolution.sql\n@@ -0,0 +1,3 @@\n+SELECT h3GetResolution(581276613233082367);\n+SELECT h3GetResolution(621807531097128959);\n+SELECT h3GetResolution(644325529233966508);\ndiff --git a/dbms/tests/queries/0_stateless/01041_h3_is_valid.reference b/dbms/tests/queries/0_stateless/01041_h3_is_valid.reference\nnew file mode 100644\nindex 000000000000..d9ff83f19498\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01041_h3_is_valid.reference\n@@ -0,0 +1,4 @@\n+1\n+1\n+0\n+0\ndiff --git a/dbms/tests/queries/0_stateless/01041_h3_is_valid.sql b/dbms/tests/queries/0_stateless/01041_h3_is_valid.sql\nnew file mode 100644\nindex 000000000000..058855618442\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01041_h3_is_valid.sql\n@@ -0,0 +1,4 @@\n+SELECT h3IsValid(581276613233082367);\n+SELECT h3IsValid(621807531097128959);\n+SELECT h3IsValid(Cast(0, 'UInt64'));\n+SELECT h3IsValid(100000000000000000);\ndiff --git a/dbms/tests/queries/0_stateless/01042_h3_k_ring.reference b/dbms/tests/queries/0_stateless/01042_h3_k_ring.reference\nnew file mode 100644\nindex 000000000000..860ddac75475\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01042_h3_k_ring.reference\n@@ -0,0 +1,3 @@\n+[581250224954015743,581259021047037951,581267817140060159,581276613233082367,581500913605148671,581518505791193087,581764796395814911]\n+[581276613233082367]\n+[581276613233082367]\ndiff --git a/dbms/tests/queries/0_stateless/01042_h3_k_ring.sql b/dbms/tests/queries/0_stateless/01042_h3_k_ring.sql\nnew file mode 100644\nindex 000000000000..30bd2f58801b\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01042_h3_k_ring.sql\n@@ -0,0 +1,3 @@\n+SELECT arraySort(h3kRing(581276613233082367, 1));\n+SELECT h3kRing(581276613233082367, 0);\n+SELECT h3kRing(581276613233082367, -1);\ndiff --git a/dbms/tests/queries/0_stateless/01043_h3_edge_length_m.reference b/dbms/tests/queries/0_stateless/01043_h3_edge_length_m.reference\nnew file mode 100644\nindex 000000000000..9db87e78ba7c\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01043_h3_edge_length_m.reference\n@@ -0,0 +1,2 @@\n+418676.0055\n+22606.3794\ndiff --git a/dbms/tests/queries/0_stateless/01043_h3_edge_length_m.sql b/dbms/tests/queries/0_stateless/01043_h3_edge_length_m.sql\nnew file mode 100644\nindex 000000000000..dbc517baa8b2\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01043_h3_edge_length_m.sql\n@@ -0,0 +1,2 @@\n+SELECT h3EdgeLengthM(1);\n+SELECT h3EdgeLengthM(4);\ndiff --git a/dbms/tests/queries/0_stateless/01044_h3_edge_angle.reference b/dbms/tests/queries/0_stateless/01044_h3_edge_angle.reference\nnew file mode 100644\nindex 000000000000..e64c5a2787eb\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01044_h3_edge_angle.reference\n@@ -0,0 +1,2 @@\n+0.0005927224846720883\n+0\ndiff --git a/dbms/tests/queries/0_stateless/01044_h3_edge_angle.sql b/dbms/tests/queries/0_stateless/01044_h3_edge_angle.sql\nnew file mode 100644\nindex 000000000000..a22121971f4a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01044_h3_edge_angle.sql\n@@ -0,0 +1,2 @@\n+SELECT h3EdgeAngle(10);\n+SELECT h3EdgeLengthM(2) * 180 / pi() / 6371007.180918475 - h3EdgeAngle(2);\n",
  "problem_statement": "Add full support of h3 indices\n## Add full support of [h3](https://uber.github.io/h3/) spherical index\r\n\r\n**Use case**\r\nSpherical index is useful to make geospatial requests, e.g. to find all points inside a circle on sphere.\r\n\r\n**Describe the solution you'd like**\r\nMake it possible to call other `h3` functions in addition to `geoToH3`, first of all [grid traversal functions](https://uber.github.io/h3/#/documentation/api-reference/traversal), for instance `kRing` or `hexRange`. Then the circle search can be performed with a command\r\n\r\n```sql\r\nSELECT *\r\nFROM some_table\r\nWHERE some_table.h3index IN (\r\n    kRing(\r\n        geoToH3($lon, $lat, res),\r\n        toInt(\r\n            // the length of longest diagonal of a regular hexagon is twice the length of its edge\r\n            ceil(radius / (2 * edgeLengthM(res)))\r\n        )\r\n    )\r\n)\r\n// Second part of the WHERE cause should be performed after previous one, I'm not sure that just AND is enough here\r\nAND greatCircleDistance(some_table.lon, some_table.lat, $lon, $lat) <= radius\r\n```\r\n\r\nwhere `$lon` and `$lat` are coordinates of the circle center in degrees, `radius` is the circle radius in meters, `some_table.lon` and `some_table.lat` are coordinate columns of `some_table`, `some_table.h3index` is precomputed with `geoToH3(some_table.lon, some_table.lat, res)` function index column of `some_table` with resolution `res`, [`edgeLengthM`](https://uber.github.io/h3/#/documentation/api-reference/miscellaneous) returns hexagon edge length.\r\n\r\n**Describe alternatives you've considered**\r\nFor now Clickhouse has limited support of spherical requests: one can find `h3` index value for some coordinates via `geoToH3`, and find distance between two coordinates on Earth surface via `greatCircleDistance`. User can perform all other logic of the request on the client side.\r\n\r\nThe another possibility is implementation of other kind of spherical index with new data type, see [`pgsphere` PostgreSQL extension](https://pgsphere.github.io) for example. Probably it is easier to make available other `h3` functions because it is already a part of Clickhouse codebase.\r\n\n",
  "hints_text": "Some suggestions to workaround that. I  think with the regular indexing features the performance is good enough, I wrote [this about geospatial processing with CH](https://carto.com/blog/geospatial-processing-with-clickhouse/)  some time ago but you have some possibilities:\r\n\r\n- having `ORDER BY (lon, lat)` provides a good enough index to filter out most of the rows by index and then do the fine grained filtering by `greatCircleDistance` or `pointInPolygon`\r\n\r\n- add a new column with the geohash and add it to the order by. Same than H3 but in this case you have `geohashesInBox` which is close to what you are asking for.\r\n\r\n- using the first approach and wait for [zcurve branch](https://github.com/ClickHouse/ClickHouse/pull/6286) to be merged, I'd say that's the most interesting feature regarding performance of geospatial queries.\r\n\r\n\r\n\n@javisantana Thank you for your answer!\r\n\r\nIn my case I need spherical coordinates not for common geographical problems so I cannot use this approach. I have to care of high latitude points and it could be very tricky to solve this problems on client side.",
  "created_at": "2019-12-04T17:40:02Z"
}