{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 37805,
  "instance_id": "ClickHouse__ClickHouse-37805",
  "issue_numbers": [
    "35521"
  ],
  "base_commit": "0b40e05ffcb9e5986425da0d6f61969894168017",
  "patch": "diff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex bd664224d41d..0f75bc27526c 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -184,7 +184,11 @@ ColumnPtr FlatDictionary::getHierarchy(ColumnPtr key_column, const DataTypePtr &\n     const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n     const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-    const UInt64 null_value = dictionary_attribute.null_value.get<UInt64>();\n+    std::optional<UInt64> null_value;\n+\n+    if (!dictionary_attribute.null_value.isNull())\n+        null_value = dictionary_attribute.null_value.get<UInt64>();\n+\n     const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.container);\n \n     auto is_key_valid_func = [&, this](auto & key) { return key < loaded_keys.size() && loaded_keys[key]; };\n@@ -193,13 +197,26 @@ ColumnPtr FlatDictionary::getHierarchy(ColumnPtr key_column, const DataTypePtr &\n \n     auto get_parent_key_func = [&, this](auto & hierarchy_key)\n     {\n+        std::optional<UInt64> result;\n+\n         bool is_key_valid = hierarchy_key < loaded_keys.size() && loaded_keys[hierarchy_key];\n-        std::optional<UInt64> result = is_key_valid ? std::make_optional(parent_keys[hierarchy_key]) : std::nullopt;\n-        keys_found += result.has_value();\n+\n+        if (!is_key_valid)\n+            return result;\n+\n+        if (unlikely(hierarchical_attribute.is_nullable_set) && hierarchical_attribute.is_nullable_set->find(hierarchy_key))\n+            return result;\n+\n+        UInt64 parent_key = parent_keys[hierarchy_key];\n+        if (null_value && *null_value == parent_key)\n+            return result;\n+\n+        result = parent_key;\n+        keys_found += 1;\n         return result;\n     };\n \n-    auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, null_value, is_key_valid_func, get_parent_key_func);\n+    auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, is_key_valid_func, get_parent_key_func);\n \n     query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -222,7 +239,11 @@ ColumnUInt8::Ptr FlatDictionary::isInHierarchy(\n     const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n     const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-    const UInt64 null_value = dictionary_attribute.null_value.get<UInt64>();\n+    std::optional<UInt64> null_value;\n+\n+    if (!dictionary_attribute.null_value.isNull())\n+        null_value = dictionary_attribute.null_value.get<UInt64>();\n+\n     const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.container);\n \n     auto is_key_valid_func = [&, this](auto & key) { return key < loaded_keys.size() && loaded_keys[key]; };\n@@ -231,13 +252,26 @@ ColumnUInt8::Ptr FlatDictionary::isInHierarchy(\n \n     auto get_parent_key_func = [&, this](auto & hierarchy_key)\n     {\n+        std::optional<UInt64> result;\n+\n         bool is_key_valid = hierarchy_key < loaded_keys.size() && loaded_keys[hierarchy_key];\n-        std::optional<UInt64> result = is_key_valid ? std::make_optional(parent_keys[hierarchy_key]) : std::nullopt;\n-        keys_found += result.has_value();\n+\n+        if (!is_key_valid)\n+            return result;\n+\n+        if (unlikely(hierarchical_attribute.is_nullable_set) && hierarchical_attribute.is_nullable_set->find(hierarchy_key))\n+            return result;\n+\n+        UInt64 parent_key = parent_keys[hierarchy_key];\n+        if (null_value && *null_value == parent_key)\n+            return result;\n+\n+        result = parent_keys[hierarchy_key];\n+        keys_found += 1;\n         return result;\n     };\n \n-    auto result = getKeysIsInHierarchyColumn(keys, keys_in, null_value, is_key_valid_func, get_parent_key_func);\n+    auto result = getKeysIsInHierarchyColumn(keys, keys_in, is_key_valid_func, get_parent_key_func);\n \n     query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n     found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -264,6 +298,9 @@ DictionaryHierarchyParentToChildIndexPtr FlatDictionary::getHierarchicalIndex()\n         if (!loaded_keys[child_key])\n             continue;\n \n+        if (unlikely(hierarchical_attribute.is_nullable_set) && hierarchical_attribute.is_nullable_set->find(child_key))\n+            continue;\n+\n         auto parent_key = parent_keys[child_key];\n         parent_to_child[parent_key].emplace_back(child_key);\n     }\ndiff --git a/src/Dictionaries/HashedArrayDictionary.cpp b/src/Dictionaries/HashedArrayDictionary.cpp\nindex 66c63b7330d2..d702a02bc2e2 100644\n--- a/src/Dictionaries/HashedArrayDictionary.cpp\n+++ b/src/Dictionaries/HashedArrayDictionary.cpp\n@@ -191,9 +191,12 @@ ColumnPtr HashedArrayDictionary<dictionary_key_type>::getHierarchy(ColumnPtr key\n         const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n         const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-        const auto & key_attribute_container = key_attribute.container;\n+        std::optional<UInt64> null_value;\n+\n+        if (!dictionary_attribute.null_value.isNull())\n+            null_value = dictionary_attribute.null_value.get<UInt64>();\n \n-        const UInt64 null_value = dictionary_attribute.null_value.template get<UInt64>();\n+        const auto & key_attribute_container = key_attribute.container;\n         const AttributeContainerType<UInt64> & parent_keys_container = std::get<AttributeContainerType<UInt64>>(hierarchical_attribute.container);\n \n         auto is_key_valid_func = [&](auto & key) { return key_attribute_container.find(key) != key_attribute_container.end(); };\n@@ -206,15 +209,25 @@ ColumnPtr HashedArrayDictionary<dictionary_key_type>::getHierarchy(ColumnPtr key\n \n             auto it = key_attribute_container.find(hierarchy_key);\n \n-            if (it != key_attribute_container.end())\n-                result = parent_keys_container[it->getMapped()];\n+            if (it == key_attribute_container.end())\n+                return result;\n+\n+            size_t key_index = it->getMapped();\n+\n+            if (unlikely(hierarchical_attribute.is_index_null) && (*hierarchical_attribute.is_index_null)[key_index])\n+                return result;\n \n-            keys_found += result.has_value();\n+            UInt64 parent_key = parent_keys_container[key_index];\n+            if (null_value && *null_value == parent_key)\n+                return result;\n+\n+            result = parent_key;\n+            keys_found += 1;\n \n             return result;\n         };\n \n-        auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, null_value, is_key_valid_func, get_parent_func);\n+        auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, is_key_valid_func, get_parent_func);\n \n         query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n         found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -246,9 +259,12 @@ ColumnUInt8::Ptr HashedArrayDictionary<dictionary_key_type>::isInHierarchy(\n         const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n         auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-        const auto & key_attribute_container = key_attribute.container;\n+        std::optional<UInt64> null_value;\n \n-        const UInt64 null_value = dictionary_attribute.null_value.template get<UInt64>();\n+        if (!dictionary_attribute.null_value.isNull())\n+            null_value = dictionary_attribute.null_value.get<UInt64>();\n+\n+        const auto & key_attribute_container = key_attribute.container;\n         const AttributeContainerType<UInt64> & parent_keys_container = std::get<AttributeContainerType<UInt64>>(hierarchical_attribute.container);\n \n         auto is_key_valid_func = [&](auto & key) { return key_attribute_container.find(key) != key_attribute_container.end(); };\n@@ -261,15 +277,25 @@ ColumnUInt8::Ptr HashedArrayDictionary<dictionary_key_type>::isInHierarchy(\n \n             auto it = key_attribute_container.find(hierarchy_key);\n \n-            if (it != key_attribute_container.end())\n-                result = parent_keys_container[it->getMapped()];\n+            if (it == key_attribute_container.end())\n+                return result;\n+\n+            size_t key_index = it->getMapped();\n \n-            keys_found += result.has_value();\n+            if (unlikely(hierarchical_attribute.is_index_null) && (*hierarchical_attribute.is_index_null)[key_index])\n+                return result;\n+\n+            UInt64 parent_key = parent_keys_container[key_index];\n+            if (null_value && *null_value == parent_key)\n+                return result;\n+\n+            result = parent_key;\n+            keys_found += 1;\n \n             return result;\n         };\n \n-        auto result = getKeysIsInHierarchyColumn(keys, keys_in, null_value, is_key_valid_func, get_parent_func);\n+        auto result = getKeysIsInHierarchyColumn(keys, keys_in, is_key_valid_func, get_parent_func);\n \n         query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n         found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -305,8 +331,12 @@ DictionaryHierarchicalParentToChildIndexPtr HashedArrayDictionary<dictionary_key\n         HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n         parent_to_child.reserve(index_to_key.size());\n \n-        for (size_t i = 0; i < parent_keys_container.size(); ++i)\n+        size_t parent_keys_container_size = parent_keys_container.size();\n+        for (size_t i = 0; i < parent_keys_container_size; ++i)\n         {\n+            if (unlikely(hierarchical_attribute.is_index_null) && (*hierarchical_attribute.is_index_null)[i])\n+                continue;\n+\n             const auto * it = index_to_key.find(i);\n             if (it == index_to_key.end())\n                 continue;\ndiff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp\nindex 81d3d42617b2..77e0e1c7907c 100644\n--- a/src/Dictionaries/HashedDictionary.cpp\n+++ b/src/Dictionaries/HashedDictionary.cpp\n@@ -235,10 +235,20 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getHierarchy(ColumnPtr\n         const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n         const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-        const UInt64 null_value = dictionary_attribute.null_value.template get<UInt64>();\n-        const CollectionType<UInt64> & parent_keys_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n+        std::optional<UInt64> null_value;\n \n-        auto is_key_valid_func = [&](auto & key) { return parent_keys_map.find(key) != parent_keys_map.end(); };\n+        if (!dictionary_attribute.null_value.isNull())\n+            null_value = dictionary_attribute.null_value.get<UInt64>();\n+\n+        const CollectionType<UInt64> & child_key_to_parent_key_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n+\n+        auto is_key_valid_func = [&](auto & hierarchy_key)\n+        {\n+            if (unlikely(hierarchical_attribute.is_nullable_set) && hierarchical_attribute.is_nullable_set->find(hierarchy_key))\n+                return true;\n+\n+            return child_key_to_parent_key_map.find(hierarchy_key) != child_key_to_parent_key_map.end();\n+        };\n \n         size_t keys_found = 0;\n \n@@ -246,17 +256,22 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getHierarchy(ColumnPtr\n         {\n             std::optional<UInt64> result;\n \n-            auto it = parent_keys_map.find(hierarchy_key);\n+            auto it = child_key_to_parent_key_map.find(hierarchy_key);\n+\n+            if (it == child_key_to_parent_key_map.end())\n+                return result;\n \n-            if (it != parent_keys_map.end())\n-                result = getValueFromCell(it);\n+            UInt64 parent_key = getValueFromCell(it);\n+            if (null_value && *null_value == parent_key)\n+                return result;\n \n-            keys_found += result.has_value();\n+            result = parent_key;\n+            keys_found += 1;\n \n             return result;\n         };\n \n-        auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, null_value, is_key_valid_func, get_parent_func);\n+        auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, is_key_valid_func, get_parent_func);\n \n         query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n         found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -264,7 +279,9 @@ ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getHierarchy(ColumnPtr\n         return dictionary_hierarchy_array;\n     }\n     else\n+    {\n         return nullptr;\n+    }\n }\n \n template <DictionaryKeyType dictionary_key_type, bool sparse>\n@@ -275,6 +292,9 @@ ColumnUInt8::Ptr HashedDictionary<dictionary_key_type, sparse>::isInHierarchy(\n {\n     if constexpr (dictionary_key_type == DictionaryKeyType::Simple)\n     {\n+        if (key_column->isNullable())\n+            key_column = assert_cast<const ColumnNullable *>(key_column.get())->getNestedColumnPtr();\n+\n         PaddedPODArray<UInt64> keys_backup_storage;\n         const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n \n@@ -286,28 +306,43 @@ ColumnUInt8::Ptr HashedDictionary<dictionary_key_type, sparse>::isInHierarchy(\n         const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n         auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-        const UInt64 null_value = dictionary_attribute.null_value.template get<UInt64>();\n-        const CollectionType<UInt64> & parent_keys_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n+        std::optional<UInt64> null_value;\n+\n+        if (!dictionary_attribute.null_value.isNull())\n+            null_value = dictionary_attribute.null_value.get<UInt64>();\n+\n+        const CollectionType<UInt64> & child_key_to_parent_key_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n+\n+        auto is_key_valid_func = [&](auto & hierarchy_key)\n+        {\n+            if (unlikely(hierarchical_attribute.is_nullable_set) && hierarchical_attribute.is_nullable_set->find(hierarchy_key))\n+                return true;\n \n-        auto is_key_valid_func = [&](auto & key) { return parent_keys_map.find(key) != parent_keys_map.end(); };\n+            return child_key_to_parent_key_map.find(hierarchy_key) != child_key_to_parent_key_map.end();\n+        };\n \n         size_t keys_found = 0;\n \n-        auto get_parent_func = [&](auto & hierarchy_key)\n+        auto get_parent_key_func = [&](auto & hierarchy_key)\n         {\n             std::optional<UInt64> result;\n \n-            auto it = parent_keys_map.find(hierarchy_key);\n+            auto it = child_key_to_parent_key_map.find(hierarchy_key);\n+\n+            if (it == child_key_to_parent_key_map.end())\n+                return result;\n \n-            if (it != parent_keys_map.end())\n-                result = getValueFromCell(it);\n+            UInt64 parent_key = getValueFromCell(it);\n+            if (null_value && *null_value == parent_key)\n+                return result;\n \n-            keys_found += result.has_value();\n+            result = parent_key;\n+            keys_found += 1;\n \n             return result;\n         };\n \n-        auto result = getKeysIsInHierarchyColumn(keys, keys_in, null_value, is_key_valid_func, get_parent_func);\n+        auto result = getKeysIsInHierarchyColumn(keys, keys_in, is_key_valid_func, get_parent_key_func);\n \n         query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n         found_count.fetch_add(keys_found, std::memory_order_relaxed);\n@@ -328,13 +363,13 @@ DictionaryHierarchyParentToChildIndexPtr HashedDictionary<dictionary_key_type, s\n \n         size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n         const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n-        const CollectionType<UInt64> & parent_keys = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n+        const CollectionType<UInt64> & child_key_to_parent_key_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n \n         HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n-        parent_to_child.reserve(parent_keys.size());\n+        parent_to_child.reserve(child_key_to_parent_key_map.size());\n \n-        for (const auto & [key, value] : parent_keys)\n-            parent_to_child[value].emplace_back(key);\n+        for (const auto & [child_key, parent_key] : child_key_to_parent_key_map)\n+            parent_to_child[parent_key].emplace_back(child_key);\n \n         return std::make_shared<DictionaryHierarchicalParentToChildIndex>(parent_to_child);\n     }\ndiff --git a/src/Dictionaries/HierarchyDictionariesUtils.cpp b/src/Dictionaries/HierarchyDictionariesUtils.cpp\nindex 0b5f8478f7a8..fd59a0c37db4 100644\n--- a/src/Dictionaries/HierarchyDictionariesUtils.cpp\n+++ b/src/Dictionaries/HierarchyDictionariesUtils.cpp\n@@ -1,5 +1,8 @@\n #include \"HierarchyDictionariesUtils.h\"\n \n+#include <Columns/ColumnNullable.h>\n+\n+\n namespace DB\n {\n \n@@ -26,25 +29,36 @@ namespace detail\n \n namespace\n {\n+    struct ChildToParentHierarchicalContext\n+    {\n+        HashMap<UInt64, UInt64> child_key_to_parent_key;\n+        std::optional<HashSet<UInt64>> child_key_parent_key_is_null;\n+    };\n+\n     /** In case of cache or direct dictionary we does not have structure with child to parent representation.\n       * This function build such structure calling getColumn for initial keys to request and for next keys in hierarchy,\n       * until all keys are requested or result key is null value.\n       * To distinguish null value key and key that is not present in dictionary, we use special default value column\n       * with max UInt64 value, if result column key has such value we assume that current key is not presented in dictionary storage.\n       */\n-    HashMap<UInt64, UInt64> getChildToParentHierarchyMapImpl(\n+    ChildToParentHierarchicalContext getChildToParentHierarchicalContext(\n         const IDictionary * dictionary,\n         const DictionaryAttribute & hierarchical_attribute,\n         const PaddedPODArray<UInt64> & initial_keys_to_request,\n         const DataTypePtr & key_type)\n     {\n-        UInt64 null_value = hierarchical_attribute.null_value.get<UInt64>();\n+        std::optional<UInt64> null_value;\n+\n+        if (!hierarchical_attribute.null_value.isNull())\n+            null_value = hierarchical_attribute.null_value.get<UInt64>();\n \n         ColumnPtr key_to_request_column = ColumnVector<UInt64>::create();\n         auto * key_to_request_column_typed = static_cast<ColumnVector<UInt64> *>(key_to_request_column->assumeMutable().get());\n \n         UInt64 key_not_in_storage_value = std::numeric_limits<UInt64>::max();\n         ColumnPtr key_not_in_storage_default_value_column = ColumnVector<UInt64>::create(initial_keys_to_request.size(), key_not_in_storage_value);\n+        if (hierarchical_attribute.is_nullable)\n+            key_not_in_storage_default_value_column = makeNullable(key_not_in_storage_default_value_column);\n \n         PaddedPODArray<UInt64> & keys_to_request = key_to_request_column_typed->getData();\n         keys_to_request.assign(initial_keys_to_request);\n@@ -52,20 +66,36 @@ namespace\n         PaddedPODArray<UInt64> next_keys_to_request;\n         HashSet<UInt64> already_requested_keys;\n \n-        HashMap<UInt64, UInt64> child_to_parent_key;\n+        ChildToParentHierarchicalContext context;\n+\n+        if (hierarchical_attribute.is_nullable)\n+            context.child_key_parent_key_is_null = HashSet<UInt64>();\n+\n+        HashMap<UInt64, UInt64> & child_key_to_parent_key = context.child_key_to_parent_key;\n+        std::optional<HashSet<UInt64>> & child_key_parent_key_is_null = context.child_key_parent_key_is_null;\n \n         while (!keys_to_request.empty())\n         {\n-            child_to_parent_key.reserve(child_to_parent_key.size() + keys_to_request.size());\n+            child_key_to_parent_key.reserve(keys_to_request.size());\n \n-            auto parent_key_column = dictionary->getColumn(\n+            auto hierarchical_attribute_parent_key_column = dictionary->getColumn(\n                 hierarchical_attribute.name,\n                 hierarchical_attribute.type,\n                 {key_to_request_column},\n                 {key_type},\n                 key_not_in_storage_default_value_column);\n \n-            const auto * parent_key_column_typed = checkAndGetColumn<ColumnVector<UInt64>>(*parent_key_column);\n+            const PaddedPODArray<UInt8> * in_key_column_nullable_mask = nullptr;\n+\n+            ColumnPtr parent_key_column_non_null = hierarchical_attribute_parent_key_column;\n+            if (hierarchical_attribute_parent_key_column->isNullable())\n+            {\n+                const auto * parent_key_column_typed = assert_cast<const ColumnNullable *>(hierarchical_attribute_parent_key_column.get());\n+                in_key_column_nullable_mask = &parent_key_column_typed->getNullMapData();\n+                parent_key_column_non_null = parent_key_column_typed->getNestedColumnPtr();\n+            }\n+\n+            const auto * parent_key_column_typed = checkAndGetColumn<ColumnVector<UInt64>>(*parent_key_column_non_null);\n             if (!parent_key_column_typed)\n                 throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n                     \"Parent key column should be UInt64. Actual {}\",\n@@ -74,17 +104,24 @@ namespace\n             const auto & parent_keys = parent_key_column_typed->getData();\n             next_keys_to_request.clear();\n \n-            for (size_t i = 0; i < keys_to_request.size(); ++i)\n+            size_t keys_to_request_size = keys_to_request.size();\n+            for (size_t i = 0; i < keys_to_request_size; ++i)\n             {\n-                auto key = keys_to_request[i];\n+                auto child_key = keys_to_request[i];\n                 auto parent_key = parent_keys[i];\n \n+                if (unlikely(in_key_column_nullable_mask) && (*in_key_column_nullable_mask)[i])\n+                {\n+                    child_key_parent_key_is_null->insert(child_key);\n+                    continue;\n+                }\n+\n                 if (parent_key == key_not_in_storage_value)\n                     continue;\n \n-                child_to_parent_key[key] = parent_key;\n+                child_key_to_parent_key[child_key] = parent_key;\n \n-                if (parent_key == null_value ||\n+                if ((null_value && parent_key == *null_value) ||\n                     already_requested_keys.find(parent_key) != nullptr)\n                     continue;\n \n@@ -96,7 +133,7 @@ namespace\n             keys_to_request.assign(next_keys_to_request);\n         }\n \n-        return child_to_parent_key;\n+        return context;\n     }\n }\n \n@@ -138,22 +175,41 @@ ColumnPtr getKeysHierarchyDefaultImplementation(\n     const auto & hierarchical_attribute = dictionary_structure.attributes[hierarchical_attribute_index];\n \n     const PaddedPODArray<UInt64> & requested_keys = key_column_typed->getData();\n-    HashMap<UInt64, UInt64> key_to_parent_key = getChildToParentHierarchyMapImpl(dictionary, hierarchical_attribute, requested_keys, key_type);\n+    ChildToParentHierarchicalContext child_to_parent_hierarchical_context\n+        = getChildToParentHierarchicalContext(dictionary, hierarchical_attribute, requested_keys, key_type);\n+\n+    auto is_key_valid_func = [&](auto & key)\n+    {\n+        if (unlikely(child_to_parent_hierarchical_context.child_key_parent_key_is_null)\n+            && child_to_parent_hierarchical_context.child_key_parent_key_is_null->find(key))\n+            return true;\n \n-    auto is_key_valid_func = [&](auto & key) { return key_to_parent_key.find(key) != nullptr; };\n+        return child_to_parent_hierarchical_context.child_key_to_parent_key.find(key) != nullptr;\n+    };\n+\n+    std::optional<UInt64> null_value;\n+\n+    if (!hierarchical_attribute.null_value.isNull())\n+        null_value = hierarchical_attribute.null_value.get<UInt64>();\n \n     auto get_parent_key_func = [&](auto & key)\n     {\n-        auto it = key_to_parent_key.find(key);\n-        std::optional<UInt64> result = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n-        valid_keys += result.has_value();\n+        std::optional<UInt64> result;\n+\n+        auto it = child_to_parent_hierarchical_context.child_key_to_parent_key.find(key);\n+        if (it == nullptr)\n+            return result;\n+\n+        UInt64 parent_key = it->getMapped();\n+        if (null_value && parent_key == *null_value)\n+            return result;\n+\n+        result = parent_key;\n+        valid_keys += 1;\n         return result;\n     };\n \n-    UInt64 null_value = hierarchical_attribute.null_value.get<UInt64>();\n-\n-    auto dictionary_hierarchy_array = getKeysHierarchyArray(requested_keys, null_value, is_key_valid_func, get_parent_key_func);\n-    return dictionary_hierarchy_array;\n+    return getKeysHierarchyArray(requested_keys, is_key_valid_func, get_parent_key_func);\n }\n \n ColumnUInt8::Ptr getKeysIsInHierarchyDefaultImplementation(\n@@ -181,23 +237,42 @@ ColumnUInt8::Ptr getKeysIsInHierarchyDefaultImplementation(\n     const auto & hierarchical_attribute = dictionary_structure.attributes[hierarchical_attribute_index];\n \n     const PaddedPODArray<UInt64> & requested_keys = key_column_typed->getData();\n-    HashMap<UInt64, UInt64> key_to_parent_key = getChildToParentHierarchyMapImpl(dictionary, hierarchical_attribute, requested_keys, key_type);\n+    ChildToParentHierarchicalContext child_to_parent_hierarchical_context\n+        = getChildToParentHierarchicalContext(dictionary, hierarchical_attribute, requested_keys, key_type);\n+\n+    auto is_key_valid_func = [&](auto & key)\n+    {\n+        if (unlikely(child_to_parent_hierarchical_context.child_key_parent_key_is_null)\n+            && child_to_parent_hierarchical_context.child_key_parent_key_is_null->find(key))\n+            return true;\n+\n+        return child_to_parent_hierarchical_context.child_key_to_parent_key.find(key) != nullptr;\n+    };\n+\n+    std::optional<UInt64> null_value;\n \n-    auto is_key_valid_func = [&](auto & key) { return key_to_parent_key.find(key) != nullptr; };\n+    if (!hierarchical_attribute.null_value.isNull())\n+        null_value = hierarchical_attribute.null_value.get<UInt64>();\n \n     auto get_parent_key_func = [&](auto & key)\n     {\n-        auto it = key_to_parent_key.find(key);\n-        std::optional<UInt64> result = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n-        valid_keys += result.has_value();\n+        std::optional<UInt64> result;\n+\n+        auto it = child_to_parent_hierarchical_context.child_key_to_parent_key.find(key);\n+        if (it == nullptr)\n+            return result;\n+\n+        UInt64 parent_key = it->getMapped();\n+        if (null_value && parent_key == *null_value)\n+            return result;\n+\n+        result = parent_key;\n+        valid_keys += 1;\n         return result;\n     };\n \n-    UInt64 null_value = hierarchical_attribute.null_value.get<UInt64>();\n     const auto & in_keys = in_key_column_typed->getData();\n-\n-    auto result = getKeysIsInHierarchyColumn(requested_keys, in_keys, null_value, is_key_valid_func, get_parent_key_func);\n-    return result;\n+    return getKeysIsInHierarchyColumn(requested_keys, in_keys, is_key_valid_func, get_parent_key_func);\n }\n \n }\ndiff --git a/src/Dictionaries/HierarchyDictionariesUtils.h b/src/Dictionaries/HierarchyDictionariesUtils.h\nindex 6a59a37b5e7a..621290f40f92 100644\n--- a/src/Dictionaries/HierarchyDictionariesUtils.h\n+++ b/src/Dictionaries/HierarchyDictionariesUtils.h\n@@ -33,7 +33,7 @@ class DictionaryHierarchicalParentToChildIndex\n         keys.reserve(parent_to_children_map_size);\n         parent_to_children_keys_range.reserve(parent_to_children_map_size);\n \n-        for (auto & [parent, children] : parent_to_children_map_)\n+        for (const auto & [parent, children] : parent_to_children_map_)\n         {\n             size_t keys_size = keys.size();\n             UInt32 start_index = static_cast<UInt32>(keys_size);\n@@ -97,7 +97,6 @@ namespace detail\n     template <typename IsKeyValidFunc, typename GetParentKeyFunc>\n     ElementsAndOffsets getHierarchy(\n         const PaddedPODArray<UInt64> & keys,\n-        const UInt64 & hierarchy_null_value,\n         IsKeyValidFunc && is_key_valid_func,\n         GetParentKeyFunc && get_parent_key_func)\n     {\n@@ -156,7 +155,7 @@ namespace detail\n                     break;\n                 }\n \n-                if (hierarchy_key == hierarchy_null_value || current_hierarchy_depth >= DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH)\n+                if (current_hierarchy_depth >= DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH)\n                     break;\n \n                 already_processes_keys_to_offset[hierarchy_key] = {offsets.size(), current_hierarchy_depth};\n@@ -190,7 +189,6 @@ namespace detail\n     PaddedPODArray<UInt8> getIsInHierarchy(\n         const PaddedPODArray<UInt64> & keys,\n         const PaddedPODArray<UInt64> & in_keys,\n-        const UInt64 & hierarchy_null_value,\n         IsKeyValidFunc && is_key_valid_func,\n         GetParentKeyFunc && get_parent_func)\n     {\n@@ -201,7 +199,6 @@ namespace detail\n \n         detail::ElementsAndOffsets hierarchy = detail::getHierarchy(\n             keys,\n-            hierarchy_null_value,\n             std::forward<IsKeyValidFunc>(is_key_valid_func),\n             std::forward<GetParentKeyFunc>(get_parent_func));\n \n@@ -213,7 +210,7 @@ namespace detail\n             size_t i_elements_start = i > 0 ? offsets[i - 1] : 0;\n             size_t i_elements_end = offsets[i];\n \n-            auto & key_to_find = in_keys[i];\n+            const auto & key_to_find = in_keys[i];\n \n             const auto * begin = elements.begin() + i_elements_start;\n             const auto * end = elements.begin() + i_elements_end;\n@@ -263,8 +260,8 @@ namespace detail\n         Strategy strategy,\n         size_t & valid_keys)\n     {\n-        auto & parent_to_children_keys_range = parent_to_child_index.parent_to_children_keys_range;\n-        auto & children_keys = parent_to_child_index.keys;\n+        const auto & parent_to_children_keys_range = parent_to_child_index.parent_to_children_keys_range;\n+        const auto & children_keys = parent_to_child_index.keys;\n \n         /// If strategy is GetAllDescendantsStrategy we try to cache and later reuse previously calculated descendants.\n         /// If strategy is GetDescendantsAtSpecificLevelStrategy we does not use cache strategy.\n@@ -436,13 +433,11 @@ namespace detail\n template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n ColumnPtr getKeysHierarchyArray(\n     const PaddedPODArray<KeyType> & keys,\n-    const KeyType & hierarchy_null_value,\n     IsKeyValidFunc && is_key_valid_func,\n     GetParentKeyFunc && get_parent_func)\n {\n     auto elements_and_offsets = detail::getHierarchy(\n         keys,\n-        hierarchy_null_value,\n         std::forward<IsKeyValidFunc>(is_key_valid_func),\n         std::forward<GetParentKeyFunc>(get_parent_func));\n \n@@ -454,14 +449,12 @@ template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n ColumnUInt8::Ptr getKeysIsInHierarchyColumn(\n     const PaddedPODArray<KeyType> & hierarchy_keys,\n     const PaddedPODArray<KeyType> & hierarchy_in_keys,\n-    const KeyType & hierarchy_null_value,\n     IsKeyValidFunc && is_key_valid_func,\n     GetParentKeyFunc && get_parent_func)\n {\n     auto is_in_hierarchy_data = detail::getIsInHierarchy(\n         hierarchy_keys,\n         hierarchy_in_keys,\n-        hierarchy_null_value,\n         std::forward<IsKeyValidFunc>(is_key_valid_func),\n         std::forward<GetParentKeyFunc>(get_parent_func));\n \ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 03833f9a2b29..6435948b8700 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -973,7 +973,7 @@ class FunctionDictGetHierarchy final : public IFunction\n         auto dictionary = helper.getDictionary(arguments[0].column);\n         const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n-        return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n+        return std::make_shared<DataTypeArray>(removeNullable(hierarchical_attribute.type));\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n@@ -985,7 +985,7 @@ class FunctionDictGetHierarchy final : public IFunction\n         const auto & hierarchical_attribute = helper.getDictionaryHierarchicalAttribute(dictionary);\n \n         auto key_column = ColumnWithTypeAndName{arguments[1].column, arguments[1].type, arguments[1].name};\n-        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n+        auto key_column_casted = castColumnAccurate(key_column, removeNullable(hierarchical_attribute.type));\n \n         ColumnPtr result = dictionary->getHierarchy(key_column_casted, hierarchical_attribute.type);\n \n@@ -1042,8 +1042,9 @@ class FunctionDictIsIn final : public IFunction\n         auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[2].name};\n         auto in_key_column = ColumnWithTypeAndName{arguments[2].column->convertToFullColumnIfConst(), arguments[2].type, arguments[2].name};\n \n-        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n-        auto in_key_column_casted = castColumnAccurate(in_key_column, hierarchical_attribute.type);\n+        auto hierarchical_attribute_non_nullable = removeNullable(hierarchical_attribute.type);\n+        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute_non_nullable);\n+        auto in_key_column_casted = castColumnAccurate(in_key_column, hierarchical_attribute_non_nullable);\n \n         ColumnPtr result = dictionary->isInHierarchy(key_column_casted, in_key_column_casted, hierarchical_attribute.type);\n \n@@ -1082,10 +1083,9 @@ class FunctionDictGetDescendantsExecutable final : public IExecutableFunction\n         const auto & hierarchical_attribute = dictionary_helper->getDictionaryHierarchicalAttribute(dictionary);\n \n         auto key_column = ColumnWithTypeAndName{arguments[1].column->convertToFullColumnIfConst(), arguments[1].type, arguments[1].name};\n-        auto key_column_casted = castColumnAccurate(key_column, hierarchical_attribute.type);\n+        auto key_column_casted = castColumnAccurate(key_column, removeNullable(hierarchical_attribute.type));\n \n-        ColumnPtr result = dictionary->getDescendants(key_column_casted, hierarchical_attribute.type, level, hierarchical_parent_to_child_index);\n-        return result;\n+        return dictionary->getDescendants(key_column_casted, removeNullable(hierarchical_attribute.type), level, hierarchical_parent_to_child_index);\n     }\n \n     String name;\n@@ -1234,7 +1234,7 @@ class FunctionDictGetDescendantsOverloadResolverImpl final : public IFunctionOve\n         auto dictionary = dictionary_helper->getDictionary(arguments[0].column);\n         const auto & hierarchical_attribute = dictionary_helper->getDictionaryHierarchicalAttribute(dictionary);\n \n-        return std::make_shared<DataTypeArray>(hierarchical_attribute.type);\n+        return std::make_shared<DataTypeArray>(removeNullable(hierarchical_attribute.type));\n     }\n \n     std::shared_ptr<FunctionDictHelper> dictionary_helper;\n",
  "test_patch": "diff --git a/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp b/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\nindex a68f23a978fd..10d335ebbbc1 100644\n--- a/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\n+++ b/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\n@@ -17,19 +17,26 @@ TEST(HierarchyDictionariesUtils, getHierarchy)\n \n         auto is_key_valid_func = [&](auto key) { return child_to_parent.find(key) != nullptr; };\n \n+        UInt64 hierarchy_null_value_key = 0;\n         auto get_parent_key_func = [&](auto key)\n         {\n+            std::optional<UInt64> result;\n             auto it = child_to_parent.find(key);\n-            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n-            return value;\n+            if (it == nullptr)\n+                return result;\n+\n+            UInt64 parent_key = it->getMapped();\n+            if (parent_key == hierarchy_null_value_key)\n+                return result;\n+\n+            result = parent_key;\n+            return result;\n         };\n \n-        UInt64 hierarchy_null_value_key = 0;\n         PaddedPODArray<UInt64> keys = {1, 2, 3, 4, 5};\n \n         auto result = DB::detail::getHierarchy(\n             keys,\n-            hierarchy_null_value_key,\n             is_key_valid_func,\n             get_parent_key_func);\n \n@@ -49,19 +56,26 @@ TEST(HierarchyDictionariesUtils, getHierarchy)\n \n         auto is_key_valid_func = [&](auto key) { return child_to_parent.find(key) != nullptr; };\n \n+        UInt64 hierarchy_null_value_key = 0;\n         auto get_parent_key_func = [&](auto key)\n         {\n+            std::optional<UInt64> result;\n             auto it = child_to_parent.find(key);\n-            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n-            return value;\n+            if (it == nullptr)\n+                return result;\n+\n+            UInt64 parent_key = it->getMapped();\n+            if (parent_key == hierarchy_null_value_key)\n+                return result;\n+\n+            result = parent_key;\n+            return result;\n         };\n \n-        UInt64 hierarchy_null_value_key = 0;\n         PaddedPODArray<UInt64> keys = {1, 2, 3};\n \n         auto result = DB::detail::getHierarchy(\n             keys,\n-            hierarchy_null_value_key,\n             is_key_valid_func,\n             get_parent_key_func);\n \n@@ -87,21 +101,28 @@ TEST(HierarchyDictionariesUtils, getIsInHierarchy)\n \n         auto is_key_valid_func = [&](auto key) { return child_to_parent.find(key) != nullptr; };\n \n+        UInt64 hierarchy_null_value_key = 0;\n         auto get_parent_key_func = [&](auto key)\n         {\n+            std::optional<UInt64> result;\n             auto it = child_to_parent.find(key);\n-            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n-            return value;\n+            if (it == nullptr)\n+                return result;\n+\n+            UInt64 parent_key = it->getMapped();\n+            if (parent_key == hierarchy_null_value_key)\n+                return result;\n+\n+            result = parent_key;\n+            return result;\n         };\n \n-        UInt64 hierarchy_null_value_key = 0;\n         PaddedPODArray<UInt64> keys = {1, 2, 3, 4, 5};\n         PaddedPODArray<UInt64> keys_in = {1, 1, 1, 2, 5};\n \n         PaddedPODArray<UInt8> actual = DB::detail::getIsInHierarchy(\n             keys,\n             keys_in,\n-            hierarchy_null_value_key,\n             is_key_valid_func,\n             get_parent_key_func);\n \n@@ -119,21 +140,28 @@ TEST(HierarchyDictionariesUtils, getIsInHierarchy)\n             return child_to_parent.find(key) != nullptr;\n         };\n \n+        UInt64 hierarchy_null_value_key = 0;\n         auto get_parent_key_func = [&](auto key)\n         {\n+            std::optional<UInt64> result;\n             auto it = child_to_parent.find(key);\n-            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n-            return value;\n+            if (it == nullptr)\n+                return result;\n+\n+            UInt64 parent_key = it->getMapped();\n+            if (parent_key == hierarchy_null_value_key)\n+                return result;\n+\n+            result = parent_key;\n+            return result;\n         };\n \n-        UInt64 hierarchy_null_value_key = 0;\n         PaddedPODArray<UInt64> keys = {1, 2, 3};\n         PaddedPODArray<UInt64> keys_in = {1, 2, 3};\n \n         PaddedPODArray<UInt8> actual = DB::detail::getIsInHierarchy(\n             keys,\n             keys_in,\n-            hierarchy_null_value_key,\n             is_key_valid_func,\n             get_parent_key_func);\n \ndiff --git a/tests/queries/0_stateless/02316_hierarchical_dictionaries_nullable_parent_key.reference b/tests/queries/0_stateless/02316_hierarchical_dictionaries_nullable_parent_key.reference\nnew file mode 100644\nindex 000000000000..60d9fb16c5fe\n--- /dev/null\n+++ b/tests/queries/0_stateless/02316_hierarchical_dictionaries_nullable_parent_key.reference\n@@ -0,0 +1,138 @@\n+Flat dictionary\n+Get hierarchy\n+[0]\n+[1,0]\n+[2,1,0]\n+[3]\n+[4,2,1,0]\n+[]\n+Get is in hierarchy\n+1\n+1\n+1\n+1\n+1\n+0\n+Get children\n+[1]\n+[2]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,2,4]\n+[2,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[2]\n+[4]\n+[]\n+[]\n+[]\n+Hashed dictionary\n+Get hierarchy\n+[0]\n+[1,0]\n+[2,1,0]\n+[3]\n+[4,2,1,0]\n+[]\n+Get is in hierarchy\n+1\n+1\n+1\n+1\n+1\n+0\n+Get children\n+[1]\n+[2]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,2,4]\n+[2,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[2]\n+[4]\n+[]\n+[]\n+[]\n+HashedArray dictionary\n+Get hierarchy\n+[0]\n+[1,0]\n+[2,1,0]\n+[3]\n+[4,2,1,0]\n+[]\n+Get is in hierarchy\n+1\n+1\n+1\n+1\n+1\n+0\n+Get children\n+[1]\n+[2]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,2,4]\n+[2,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[2]\n+[4]\n+[]\n+[]\n+[]\n+Cache dictionary\n+Get hierarchy\n+[0]\n+[1,0]\n+[2,1,0]\n+[3]\n+[4,2,1,0]\n+[]\n+Get is in hierarchy\n+1\n+1\n+1\n+1\n+1\n+0\n+Direct dictionary\n+Get hierarchy\n+[0]\n+[1,0]\n+[2,1,0]\n+[3]\n+[4,2,1,0]\n+[]\n+Get is in hierarchy\n+1\n+1\n+1\n+1\n+1\n+0\ndiff --git a/tests/queries/0_stateless/02316_hierarchical_dictionaries_nullable_parent_key.sql b/tests/queries/0_stateless/02316_hierarchical_dictionaries_nullable_parent_key.sql\nnew file mode 100644\nindex 000000000000..d477d58d3987\n--- /dev/null\n+++ b/tests/queries/0_stateless/02316_hierarchical_dictionaries_nullable_parent_key.sql\n@@ -0,0 +1,123 @@\n+DROP TABLE IF EXISTS test_hierarhical_table;\n+CREATE TABLE test_hierarhical_table\n+(\n+    id UInt64,\n+    parent_id Nullable(UInt64)\n+) ENGINE=TinyLog;\n+\n+INSERT INTO test_hierarhical_table VALUES (0, NULL), (1, 0), (2, 1), (3, NULL), (4, 2);\n+\n+DROP DICTIONARY IF EXISTS hierachical_flat_dictionary;\n+CREATE DICTIONARY hierachical_flat_dictionary\n+(\n+    id UInt64,\n+    parent_id Nullable(UInt64) HIERARCHICAL\n+) PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarhical_table'))\n+LAYOUT(FLAT())\n+LIFETIME(0);\n+\n+SELECT 'Flat dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierachical_flat_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierachical_flat_dictionary', number, number) FROM system.numbers LIMIT 6;\n+SELECT 'Get children';\n+SELECT dictGetChildren('hierachical_flat_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('hierachical_flat_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('hierachical_flat_dictionary', number, 1) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY hierachical_flat_dictionary;\n+\n+DROP DICTIONARY IF EXISTS hierachical_hashed_dictionary;\n+CREATE DICTIONARY hierachical_hashed_dictionary\n+(\n+    id UInt64,\n+    parent_id Nullable(UInt64) HIERARCHICAL\n+) PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarhical_table'))\n+LAYOUT(HASHED())\n+LIFETIME(0);\n+\n+SELECT 'Hashed dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierachical_hashed_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierachical_hashed_dictionary', number, number) FROM system.numbers LIMIT 6;\n+SELECT 'Get children';\n+SELECT dictGetChildren('hierachical_hashed_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('hierachical_hashed_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('hierachical_hashed_dictionary', number, 1) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY hierachical_hashed_dictionary;\n+\n+DROP DICTIONARY IF EXISTS hierachical_hashed_array_dictionary;\n+CREATE DICTIONARY hierachical_hashed_array_dictionary\n+(\n+    id UInt64,\n+    parent_id Nullable(UInt64) HIERARCHICAL\n+) PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarhical_table'))\n+LAYOUT(HASHED_ARRAY())\n+LIFETIME(0);\n+\n+SELECT 'HashedArray dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierachical_hashed_array_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierachical_hashed_array_dictionary', number, number) FROM system.numbers LIMIT 6;\n+SELECT 'Get children';\n+SELECT dictGetChildren('hierachical_hashed_array_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('hierachical_hashed_array_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('hierachical_hashed_array_dictionary', number, 1) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY hierachical_hashed_array_dictionary;\n+\n+DROP DICTIONARY IF EXISTS hierachical_cache_dictionary;\n+CREATE DICTIONARY hierachical_cache_dictionary\n+(\n+    id UInt64,\n+    parent_id Nullable(UInt64) HIERARCHICAL\n+) PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarhical_table'))\n+LAYOUT(CACHE(SIZE_IN_CELLS 10))\n+LIFETIME(0);\n+\n+SELECT 'Cache dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierachical_cache_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierachical_cache_dictionary', number, number) FROM system.numbers LIMIT 6;\n+\n+\n+DROP DICTIONARY hierachical_cache_dictionary;\n+\n+DROP DICTIONARY IF EXISTS hierachical_direct_dictionary;\n+CREATE DICTIONARY hierachical_direct_dictionary\n+(\n+    id UInt64,\n+    parent_id Nullable(UInt64) HIERARCHICAL\n+) PRIMARY KEY id\n+SOURCE(CLICKHOUSE(TABLE 'test_hierarhical_table'))\n+LAYOUT(DIRECT());\n+\n+SELECT 'Direct dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('hierachical_direct_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('hierachical_direct_dictionary', number, number) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY hierachical_direct_dictionary;\n+\n+DROP TABLE test_hierarhical_table;\n",
  "problem_statement": "HIERARCHICAL dictionary not support nullable parent_id with function dictGetDescendants\n```\r\ncreate table default.test_parent\r\n(\r\n    id        UInt64,\r\n    parent_id Nullable(UInt64)\r\n) engine = MergeTree\r\n\r\ncreate dictionary default.d4test_parent\r\n    ( id UInt64,\r\n    parent_id  Nullable(UInt64) HIERARCHICAL\r\n    )\r\n    PRIMARY KEY id\r\n    SOURCE (CLICKHOUSE(DB 'default' TABLE 'test_parent'))\r\n    LIFETIME (MIN 0 MAX 0)\r\n    LAYOUT (HASHED)\r\n;\r\ninsert into default.test_parent\r\nvalues (1, null),\r\n       (2, 3),\r\n       (3, 1),\r\n       (4, 2)\r\n;\r\nsystem reload dictionary default.d4test_parent\r\n;\r\nselect dictGetDescendants('default.d4test_parent', toUInt64(2))\r\n;\r\n```\r\n\r\nCode: 53. DB::Exception: default.d4test_parent (443f6664-e217-44ec-80e2-bbec982b4963): type mismatch: column has wrong type expected UInt64: While processing dictGetDescendants('default.d4test_parent', 2). (TYPE_MISMATCH) (version 22.3.2.1)\r\n\r\n\r\nOn old versions no errors\r\n```\r\nselect version()\r\n-- 21.11.6.7\r\n;\r\nselect dictGetDescendants('default.d4test_parent', toUInt64(2))\r\n-- [4]\r\n```\n",
  "hints_text": "Have the same problem.\nGot same problem, @kitaisreal , @den-crane any news about this bug? When can we expect a solution of this problem?",
  "created_at": "2022-06-02T17:22:46Z"
}