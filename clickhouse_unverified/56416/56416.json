{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56416,
  "instance_id": "ClickHouse__ClickHouse-56416",
  "issue_numbers": [
    "53098"
  ],
  "base_commit": "4db2e25ca2c756e5ce8ecfced463aa7e80a482c1",
  "patch": "diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 02e5d1e5ae26..75fcbab64013 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -2172,6 +2172,72 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+\n+## arrayRandomSample\n+\n+Function `arrayRandomSample` returns a subset with `samples`-many random elements of an input array. If `samples` exceeds the size of the input array, the sample size is limited to the size of the array, i.e. all array elements are returned but their order is not guaranteed. The function can handle both flat arrays and nested arrays.\n+\n+**Syntax**\n+\n+```sql\n+arrayRandomSample(arr, samples)\n+```\n+\n+**Arguments**\n+\n+- `arr` \u2014 The input array from which to sample elements. ([Array(T)](../data-types/array.md))\n+- `samples` \u2014 The number of elements to include in the random sample ([UInt*](../data-types/int-uint.md))\n+\n+**Returned Value**\n+\n+- An array containing a random sample of elements from the input array.\n+\n+Type: [Array](../data-types/array.md).\n+\n+**Examples**\n+\n+Query:\n+\n+```sql\n+SELECT arrayRandomSample(['apple', 'banana', 'cherry', 'date'], 2) as res;\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 ['cherry','apple'] \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Query:\n+\n+```sql\n+SELECT arrayRandomSample([[1, 2], [3, 4], [5, 6]], 2) as res;\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 [[3,4],[5,6]] \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+Query:\n+\n+```sql\n+SELECT arrayRandomSample([1, 2, 3], 5) as res;\n+```\n+\n+Result:\n+\n+```\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 [3,1,2] \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## Distance functions\n \n All supported functions are described in [distance functions documentation](../../sql-reference/functions/distance-functions.md).\ndiff --git a/src/Functions/array/arrayRandomSample.cpp b/src/Functions/array/arrayRandomSample.cpp\nnew file mode 100644\nindex 000000000000..1e28e089a2aa\n--- /dev/null\n+++ b/src/Functions/array/arrayRandomSample.cpp\n@@ -0,0 +1,105 @@\n+#include <Columns/ColumnArray.h>\n+#include <Columns/ColumnsNumber.h>\n+#include <Common/randomSeed.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <Poco/Logger.h>\n+#include <numeric>\n+#include <pcg_random.hpp>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+/// arrayRandomSample(arr, k) - Returns k random elements from the input array\n+class FunctionArrayRandomSample : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"arrayRandomSample\";\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayRandomSample>(); }\n+\n+    String getName() const override { return name; }\n+\n+    size_t getNumberOfArguments() const override { return 2; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        FunctionArgumentDescriptors args{\n+            {\"array\", &isArray<IDataType>, nullptr, \"Array\"},\n+            {\"samples\", &isUInt<IDataType>, isColumnConst, \"const UInt*\"},\n+        };\n+        validateFunctionArgumentTypes(*this, arguments, args);\n+\n+        // Return an array with the same nested type as the input array\n+        const DataTypePtr & array_type = arguments[0].type;\n+        const DataTypeArray * array_data_type = checkAndGetDataType<DataTypeArray>(array_type.get());\n+        const DataTypePtr & nested_type = array_data_type->getNestedType();\n+        return std::make_shared<DataTypeArray>(nested_type);\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n+    {\n+        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        if (!col_array)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"First argument of function {} must be an array\", getName());\n+\n+        const IColumn * col_samples = arguments[1].column.get();\n+        if (!col_samples)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n+                    \"The second argument of function {} is empty or null, type = {}\",\n+                    getName(), arguments[1].type->getName());\n+\n+        const size_t samples = col_samples->getUInt(0);\n+\n+        pcg64_fast rng(randomSeed());\n+\n+        auto col_res_data = col_array->getDataPtr()->cloneEmpty();\n+        auto col_res_offsets = ColumnUInt64::create(input_rows_count);\n+        auto col_res = ColumnArray::create(std::move(col_res_data), std::move(col_res_offsets));\n+\n+        const auto & array_offsets = col_array->getOffsets();\n+        auto & res_offsets = col_res->getOffsets();\n+\n+        std::vector<size_t> indices;\n+        size_t prev_array_offset = 0;\n+        size_t prev_res_offset = 0;\n+\n+        for (size_t row = 0; row < input_rows_count; row++)\n+        {\n+            const size_t num_elements = array_offsets[row] - prev_array_offset;\n+            const size_t cur_samples = std::min(num_elements, samples);\n+\n+            indices.resize(num_elements);\n+            std::iota(indices.begin(), indices.end(), prev_array_offset);\n+            std::shuffle(indices.begin(), indices.end(), rng);\n+\n+            for (UInt64 i = 0; i < cur_samples; i++)\n+                col_res->getData().insertFrom(col_array->getData(), indices[i]);\n+\n+            res_offsets[row] = prev_res_offset + cur_samples;\n+\n+            prev_array_offset += num_elements;\n+            prev_res_offset += cur_samples;\n+            indices.clear();\n+        }\n+\n+        return col_res;\n+    }\n+};\n+\n+REGISTER_FUNCTION(ArrayRandomSample)\n+{\n+    factory.registerFunction<FunctionArrayRandomSample>();\n+}\n+\n+}\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 69e30bbb8bb2..aedb267b3fb4 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1076,6 +1076,7 @@ arrayPopFront\n arrayProduct\n arrayPushBack\n arrayPushFront\n+arrayRandomSample\n arrayReduce\n arrayReduceInRanges\n arrayResize\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex 589ea366030d..379eea4dbbb5 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -126,6 +126,7 @@ arrayPopFront\n arrayProduct\n arrayPushBack\n arrayPushFront\n+arrayRandomSample\n arrayReduce\n arrayReduceInRanges\n arrayResize\ndiff --git a/tests/queries/0_stateless/02874_array_random_sample.reference b/tests/queries/0_stateless/02874_array_random_sample.reference\nnew file mode 100644\nindex 000000000000..7dab23a37b46\n--- /dev/null\n+++ b/tests/queries/0_stateless/02874_array_random_sample.reference\n@@ -0,0 +1,37 @@\n+Running iteration: 1\n+Integer Test: Passed\n+String Test: Passed\n+Nested Array Test: Passed\n+Higher Sample Number Test: Passed\n+Multi-row Test with scalar k: Passed\n+Running iteration: 2\n+Integer Test: Passed\n+String Test: Passed\n+Nested Array Test: Passed\n+Higher Sample Number Test: Passed\n+Multi-row Test with scalar k: Passed\n+Running iteration: 3\n+Integer Test: Passed\n+String Test: Passed\n+Nested Array Test: Passed\n+Higher Sample Number Test: Passed\n+Multi-row Test with scalar k: Passed\n+Running iteration: 4\n+Integer Test: Passed\n+String Test: Passed\n+Nested Array Test: Passed\n+Higher Sample Number Test: Passed\n+Multi-row Test with scalar k: Passed\n+Running iteration: 5\n+Integer Test: Passed\n+String Test: Passed\n+Nested Array Test: Passed\n+Higher Sample Number Test: Passed\n+Multi-row Test with scalar k: Passed\n+Integer Test with K=0: Passed\n+Empty Array with K > 0 Test: Passed\n+Non-Unsigned-Integer K Test (Negative Integer): Passed\n+Non-Unsigned-Integer K Test (String): Passed\n+Non-Unsigned-Integer K Test (Floating-Point): Passed\n+Total tests: 30\n+Passed tests: 30\ndiff --git a/tests/queries/0_stateless/02874_array_random_sample.sh b/tests/queries/0_stateless/02874_array_random_sample.sh\nnew file mode 100755\nindex 000000000000..fe136d6d5d23\n--- /dev/null\n+++ b/tests/queries/0_stateless/02874_array_random_sample.sh\n@@ -0,0 +1,258 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+# Initialize variables\n+total_tests=0\n+passed_tests=0\n+\n+\n+# Test Function for Integer Arrays\n+run_integer_test() {\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([1,2,3], 2)\")\n+    mapfile -t sorted_result < <(echo \"$query_result\" | tr -d '[]' | tr ',' '\\n' | sort -n)\n+    declare -A expected_outcomes\n+    expected_outcomes[\"1 2\"]=1\n+    expected_outcomes[\"1 3\"]=1\n+    expected_outcomes[\"2 3\"]=1\n+    expected_outcomes[\"2 1\"]=1\n+    expected_outcomes[\"3 1\"]=1\n+    expected_outcomes[\"3 2\"]=1\n+\n+    sorted_result_str=$(echo \"${sorted_result[*]}\" | tr ' ' '\\n' | sort -n | tr '\\n' ' ' | sed 's/ $//')\n+    if [[ -n \"${expected_outcomes[$sorted_result_str]}\" ]]; then\n+        echo \"Integer Test: Passed\"\n+        ((passed_tests++))\n+    else\n+        echo \"Integer Test: Failed\"\n+        echo \"Output: $query_result\"\n+    fi\n+    ((total_tests++))\n+}\n+\n+# Test Function for String Arrays\n+run_string_test() {\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample(['a','b','c'], 2)\")\n+    mapfile -t sorted_result < <(echo \"$query_result\" | tr -d \"[]'\" | tr ',' '\\n' | sort)\n+    declare -A expected_outcomes\n+    expected_outcomes[\"a b\"]=1\n+    expected_outcomes[\"a c\"]=1\n+    expected_outcomes[\"b c\"]=1\n+    expected_outcomes[\"b a\"]=1\n+    expected_outcomes[\"c a\"]=1\n+    expected_outcomes[\"c b\"]=1\n+\n+    sorted_result_str=$(echo \"${sorted_result[*]}\" | tr ' ' '\\n' | sort | tr '\\n' ' ' | sed 's/ $//')\n+    if [[ -n \"${expected_outcomes[$sorted_result_str]}\" ]]; then\n+        echo \"String Test: Passed\"\n+        ((passed_tests++))\n+    else\n+        echo \"String Test: Failed\"\n+        echo \"Output: $query_result\"\n+    fi\n+    ((total_tests++))\n+}\n+\n+# Test Function for Nested Arrays\n+run_nested_array_test() {\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([[7,2],[3,4],[7,6]], 2)\")\n+    # Convert to a space-separated string for easy sorting.\n+    converted_result=$(echo \"$query_result\" | tr -d '[]' | tr ',' ' ')\n+\n+    # Sort the string.\n+    sorted_result_str=$(echo \"$converted_result\" | tr ' ' '\\n' | xargs -n2 | sort | tr '\\n' ' ' | sed 's/ $//')\n+\n+    # Define all possible expected outcomes, sorted\n+    declare -A expected_outcomes\n+    expected_outcomes[\"7 2 3 4\"]=1\n+    expected_outcomes[\"7 2 7 6\"]=1\n+    expected_outcomes[\"3 4 7 6\"]=1\n+    expected_outcomes[\"3 4 7 2\"]=1\n+    expected_outcomes[\"7 6 7 2\"]=1\n+    expected_outcomes[\"7 6 3 4\"]=1\n+\n+    if [[ -n \"${expected_outcomes[$sorted_result_str]}\" ]]; then\n+        echo \"Nested Array Test: Passed\"\n+        ((passed_tests++))\n+    else\n+        echo \"Nested Array Test: Failed\"\n+        echo \"Output: $query_result\"\n+        echo \"Processed Output: ${sorted_result_str}\"\n+    fi\n+    ((total_tests++))\n+}\n+\n+\n+# Test Function for K > array.size\n+run_higher_k_test() {\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([1,2,3], 5)\")\n+    mapfile -t sorted_result < <(echo \"$query_result\" | tr -d '[]' | tr ',' '\\n' | sort -n)\n+    sorted_original=(\"1\" \"2\" \"3\")\n+\n+    are_arrays_equal=true\n+    for i in \"${!sorted_result[@]}\"; do\n+        if [[ \"${sorted_result[$i]}\" != \"${sorted_original[$i]}\" ]]; then\n+            are_arrays_equal=false\n+            break\n+        fi\n+    done\n+\n+    if $are_arrays_equal; then\n+        echo \"Higher Sample Number Test: Passed\"\n+        ((passed_tests++))\n+    else\n+        echo \"Higher Sample Number Test: Failed\"\n+        echo \"Output: $query_result\"\n+    fi\n+    ((total_tests++))\n+}\n+\n+# Test Function for Integer Arrays with samples = 0\n+run_integer_with_samples_0_test() {\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([1,2,3], 0)\")\n+    mapfile -t sorted_result < <(echo \"$query_result\" | tr -d '[]' | tr ',' '\\n' | sort -n)\n+\n+    # An empty array should produce an empty string after transformations\n+    declare -A expected_outcomes\n+    expected_outcomes[\"EMPTY_ARRAY\"]=1\n+\n+    # Prepare the result string for comparison\n+    sorted_result_str=$(echo \"${sorted_result[*]}\" | tr ' ' '\\n' | sort -n | tr '\\n' ' ' | sed 's/ $//')\n+\n+    # Use \"EMPTY_ARRAY\" as a placeholder for an empty array\n+    [[ -z \"$sorted_result_str\" ]] && sorted_result_str=\"EMPTY_ARRAY\"\n+\n+    # Compare\n+    if [[ -n \"${expected_outcomes[$sorted_result_str]}\" ]]; then\n+        echo \"Integer Test with K=0: Passed\"\n+        ((passed_tests++))\n+    else\n+        echo \"Integer Test with K=0: Failed\"\n+        echo \"Output: $query_result\"\n+    fi\n+    ((total_tests++))\n+}\n+\n+# Test Function for Empty Array with K > 0\n+run_empty_array_with_k_test() {\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([], 5)\")\n+\n+    if [[ \"$query_result\" == \"[]\" ]]; then\n+        echo \"Empty Array with K > 0 Test: Passed\"\n+        ((passed_tests++))\n+    else {\n+        echo \"Empty Array with K > 0 Test: Failed\"\n+        echo \"Output: $query_result\"\n+    }\n+    fi\n+    ((total_tests++))\n+}\n+\n+# Test Function for Non-Unsigned-Integer K\n+run_non_unsigned_integer_k_test() {\n+    # Test with negative integer\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([1, 2, 3], -5)\" 2>&1)\n+    if [[ \"$query_result\" == *\"ILLEGAL_TYPE_OF_ARGUMENT\"* ]]; then\n+        echo \"Non-Unsigned-Integer K Test (Negative Integer): Passed\"\n+        ((passed_tests++))\n+    else {\n+        echo \"Non-Unsigned-Integer K Test (Negative Integer): Failed\"\n+        echo \"Output: $query_result\"\n+    }\n+    fi\n+    ((total_tests++))\n+\n+    # Test with string\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([1, 2, 3], 'a')\" 2>&1)\n+    if [[ \"$query_result\" == *\"ILLEGAL_TYPE_OF_ARGUMENT\"* ]]; then\n+        echo \"Non-Unsigned-Integer K Test (String): Passed\"\n+        ((passed_tests++))\n+    else {\n+        echo \"Non-Unsigned-Integer K Test (String): Failed\"\n+        echo \"Output: $query_result\"\n+    }\n+    fi\n+    ((total_tests++))\n+\n+    # Test with floating-point number\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample([1, 2, 3], 1.5)\" 2>&1)\n+    if [[ \"$query_result\" == *\"ILLEGAL_TYPE_OF_ARGUMENT\"* ]]; then\n+        echo \"Non-Unsigned-Integer K Test (Floating-Point): Passed\"\n+        ((passed_tests++))\n+    else {\n+        echo \"Non-Unsigned-Integer K Test (Floating-Point): Failed\"\n+        echo \"Output: $query_result\"\n+    }\n+    fi\n+    ((total_tests++))\n+}\n+\n+# Function to run a multi-row test with scalar 'k'\n+run_multi_row_scalar_k_test() {\n+    # Create a table. Use a random database name as tests potentially run in parallel.\n+    db=`tr -dc A-Za-z0-9 </dev/urandom | head -c 13`\n+    clickhouse-client -q \"DROP DATABASE IF EXISTS ${db}\"\n+    clickhouse-client -q \"CREATE DATABASE ${db}\"\n+    clickhouse-client -q \"CREATE TABLE ${db}.array_test (arr Array(Int32)) ENGINE = Memory\"\n+\n+    # Insert multi-row data into the table\n+    clickhouse-client -q \"INSERT INTO ${db}.array_test VALUES ([1, 2, 3]), ([4, 5, 6]), ([7, 8, 9])\"\n+\n+    # Query using arrayRandomSample function and store the result, k is scalar here (for example, 2)\n+    query_result=$(clickhouse-client -q \"SELECT arrayRandomSample(arr, 2) FROM ${db}.array_test\")\n+\n+    # Drop the table\n+    clickhouse-client -q \"DROP DATABASE ${db}\"\n+\n+    # Validate the output here\n+    is_test_passed=1  # flag to indicate if the test passed; 1 means passed, 0 means failed\n+\n+    # Iterate over each line (each array) in the output\n+    echo \"$query_result\" | while read -r line; do\n+        # Remove brackets from the array string\n+        line=$(echo \"$line\" | tr -d '[]')\n+\n+        # Convert the string to an array\n+        IFS=\", \" read -ra nums <<< \"$line\"\n+\n+        # Check if the array contains exactly 2 unique elements\n+        if [[ ${#nums[@]} -ne 2 ]] || [[ ${nums[0]} -eq ${nums[1]} ]]; then\n+            # shellcheck disable=SC2030\n+            is_test_passed=0\n+        fi\n+    done\n+\n+    # Print test result\n+    # shellcheck disable=SC2031\n+    if [[ $is_test_passed -eq 1 ]]; then\n+        echo \"Multi-row Test with scalar k: Passed\"\n+        ((passed_tests++))\n+    else\n+        echo \"Multi-row Test with scalar k: Failed\"\n+        echo \"Output: $query_result\"\n+    fi\n+\n+    ((total_tests++))\n+}\n+\n+\n+\n+# Run test multiple times\n+for i in {1..5}; do\n+    echo \"Running iteration: $i\"\n+    run_integer_test\n+    run_string_test\n+    run_nested_array_test\n+    run_higher_k_test\n+    run_multi_row_scalar_k_test\n+done\n+\n+run_integer_with_samples_0_test\n+run_empty_array_with_k_test\n+run_non_unsigned_integer_k_test\n+\n+# Print overall test results\n+echo \"Total tests: $total_tests\"\n+echo \"Passed tests: $passed_tests\"\n",
  "problem_statement": "Array Of Random Numbers (In a Given Range of N , M)\nCan we please add a feature for generating random arrays. \r\n\r\nI was wondering something like: `generateRandomIntArray(N, M, K)` where `N` is start, `M` is end and `K` is the size of the array.  \r\n\r\nAdditionally, can we also add a random sampler for existing arrays. Something like: `randomSampleFromArray(<Array>, K)` where `K` is the number of samples to get.\n",
  "hints_text": "> Additionally, can we also add a random sampler for existing arrays. Something like: randomSampleFromArray(<Array>, K) where K is the number of samples to get.\r\n\r\nThere is groupArraySample function, but it's aggregation\r\n\r\nStill, you can use it via arrayReduce.\r\n\r\n```\r\nSELECT arrayReduce('groupArraySample(3)', range(10))\r\n\r\nQuery id: 3a7798d7-a465-4f4f-8185-909e5dcd30c5\r\n\r\n\u250c\u2500arrayReduce('groupArraySample(3)', range(10))\u2500\u2510\r\n\u2502 [9,1,2]                                       \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nHey @KochetovNicolai,\r\n\r\n`randomSampleFromArray(<Array>, K) `can get an array of arrays?\r\nIf yes, what will be the result in this case:\r\n\r\n`select randomSampleFromArray([[1,2,3], [5,6], [7,9]], 2);`\r\n[2,5] or [1,2,3] && [7,9]\r\nThe answer is [1,2,3] && [7,9], right? ",
  "created_at": "2023-11-07T13:15:02Z",
  "modified_files": [
    "docs/en/sql-reference/functions/array-functions.md",
    "b/src/Functions/array/arrayRandomSample.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference",
    "b/tests/queries/0_stateless/02874_array_random_sample.reference",
    "b/tests/queries/0_stateless/02874_array_random_sample.sh"
  ]
}