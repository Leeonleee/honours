diff --git a/src/Analyzer/ConstantNode.cpp b/src/Analyzer/ConstantNode.cpp
index fed21a2721bd..62ef2c2341ad 100644
--- a/src/Analyzer/ConstantNode.cpp
+++ b/src/Analyzer/ConstantNode.cpp
@@ -55,58 +55,10 @@ String ConstantNode::getValueStringRepresentation() const
     return applyVisitor(FieldVisitorToString(), getValue());
 }
 
-bool ConstantNode::requiresCastCall(Field::Types::Which type, const DataTypePtr & field_type, const DataTypePtr & data_type)
-{
-    bool need_to_add_cast_function = false;
-    WhichDataType constant_value_type(data_type);
-
-    switch (type)
-    {
-        case Field::Types::String:
-        {
-            need_to_add_cast_function = !constant_value_type.isString();
-            break;
-        }
-        case Field::Types::UInt64:
-        case Field::Types::Int64:
-        case Field::Types::Float64:
-        {
-            WhichDataType constant_value_field_type(field_type);
-            need_to_add_cast_function = constant_value_field_type.idx != constant_value_type.idx;
-            break;
-        }
-        case Field::Types::Int128:
-        case Field::Types::UInt128:
-        case Field::Types::Int256:
-        case Field::Types::UInt256:
-        case Field::Types::Decimal32:
-        case Field::Types::Decimal64:
-        case Field::Types::Decimal128:
-        case Field::Types::Decimal256:
-        case Field::Types::AggregateFunctionState:
-        case Field::Types::Array:
-        case Field::Types::Tuple:
-        case Field::Types::Map:
-        case Field::Types::UUID:
-        case Field::Types::Bool:
-        case Field::Types::Object:
-        case Field::Types::IPv4:
-        case Field::Types::IPv6:
-        case Field::Types::Null:
-        case Field::Types::CustomType:
-        {
-            need_to_add_cast_function = true;
-            break;
-        }
-    }
-
-    return need_to_add_cast_function;
-}
-
 bool ConstantNode::requiresCastCall(const DataTypePtr & field_type, const DataTypePtr & data_type)
 {
     WhichDataType which_field_type(field_type);
-    if (which_field_type.isNullable() || which_field_type.isArray())
+    if (which_field_type.isNullable() || which_field_type.isArray() || which_field_type.isTuple())
         return true;
 
     return field_type->getTypeId() != data_type->getTypeId();
@@ -203,21 +155,29 @@ ASTPtr ConstantNode::toASTImpl(const ConvertToASTOptions & options) const
         return std::make_shared<ASTLiteral>(getFieldFromColumnForASTLiteral(constant_value.getColumn(), 0, constant_value.getType()));
 
     const auto & constant_value_type = constant_value.getType();
-    auto constant_value_ast = std::make_shared<ASTLiteral>(getValue());
 
     // Add cast if constant was created as a result of constant folding.
     // Constant folding may lead to type transformation and literal on shard
     // may have a different type.
-    if (source_expression != nullptr || requiresCastCall(constant_value_ast->value.getType(), applyVisitor(FieldToDataType(), constant_value_ast->value), getResultType()))
+
+    auto requires_cast = [this]()
+    {
+        const auto & [_, type] = getValueNameAndType();
+        return requiresCastCall(type, getResultType());
+    };
+
+    if (source_expression != nullptr || requires_cast())
     {
         /// For some types we cannot just get a field from a column, because it can loose type information during serialization/deserialization of the literal.
         /// For example, DateTime64 will return Field with Decimal64 and we won't be able to parse it to DateTine64 back in some cases.
         /// Also for Dynamic and Object types we can loose types information, so we need to create a Field carefully.
-        constant_value_ast = std::make_shared<ASTLiteral>(getFieldFromColumnForASTLiteral(constant_value.getColumn(), 0, constant_value.getType()));
+        auto constant_value_ast = std::make_shared<ASTLiteral>(getFieldFromColumnForASTLiteral(constant_value.getColumn(), 0, constant_value.getType()));
         auto constant_type_name_ast = std::make_shared<ASTLiteral>(constant_value_type->getName());
         return makeASTFunction("_CAST", std::move(constant_value_ast), std::move(constant_type_name_ast));
     }
 
+    auto constant_value_ast = std::make_shared<ASTLiteral>(getValue());
+
     if (isBool(constant_value_type))
         constant_value_ast->custom_type = constant_value_type;
 
diff --git a/src/Analyzer/ConstantNode.h b/src/Analyzer/ConstantNode.h
index e91e97c34792..e97063427ec2 100644
--- a/src/Analyzer/ConstantNode.h
+++ b/src/Analyzer/ConstantNode.h
@@ -91,7 +91,6 @@ class ConstantNode final : public IQueryTreeNode
     }
 
     /// Check if conversion to AST requires wrapping with _CAST function.
-    static bool requiresCastCall(Field::Types::Which type, const DataTypePtr & field_type, const DataTypePtr & data_type);
     static bool requiresCastCall(const DataTypePtr & field_type, const DataTypePtr & data_type);
 
     /// Check if constant is a result of _CAST function constant folding.
