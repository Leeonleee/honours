{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 53440,
  "instance_id": "ClickHouse__ClickHouse-53440",
  "issue_numbers": [
    "53152"
  ],
  "base_commit": "d5ed014ec4e4a2a0c49ac95a193aa0c15a511f4c",
  "patch": "diff --git a/src/Interpreters/OptimizeDateOrDateTimeConverterWithPreimageVisitor.cpp b/src/Interpreters/OptimizeDateOrDateTimeConverterWithPreimageVisitor.cpp\nindex 6a9251cec49e..dd205ae65080 100644\n--- a/src/Interpreters/OptimizeDateOrDateTimeConverterWithPreimageVisitor.cpp\n+++ b/src/Interpreters/OptimizeDateOrDateTimeConverterWithPreimageVisitor.cpp\n@@ -118,35 +118,37 @@ void OptimizeDateOrDateTimeConverterWithPreimageMatcher::visit(const ASTFunction\n         {\"greaterOrEquals\", \"lessOrEquals\"},\n     };\n \n-    if (!swap_relations.contains(function.name)) return;\n+    if (!swap_relations.contains(function.name))\n+        return;\n \n-    if (!function.arguments || function.arguments->children.size() != 2) return;\n+    if (!function.arguments || function.arguments->children.size() != 2)\n+        return;\n \n     size_t func_id = function.arguments->children.size();\n \n     for (size_t i = 0; i < function.arguments->children.size(); i++)\n-    {\n         if (const auto * func = function.arguments->children[i]->as<ASTFunction>())\n-        {\n             func_id = i;\n-        }\n-    }\n \n-    if (func_id == function.arguments->children.size()) return;\n+    if (func_id == function.arguments->children.size())\n+        return;\n \n     size_t literal_id = 1 - func_id;\n     const auto * literal = function.arguments->children[literal_id]->as<ASTLiteral>();\n \n-    if (!literal || literal->value.getType() != Field::Types::UInt64) return;\n+    if (!literal || literal->value.getType() != Field::Types::UInt64)\n+        return;\n \n     String comparator = literal_id > func_id ? function.name : swap_relations.at(function.name);\n \n     const auto * ast_func = function.arguments->children[func_id]->as<ASTFunction>();\n     /// Currently we only handle single-argument functions.\n-    if (!ast_func || !ast_func->arguments || ast_func->arguments->children.size() != 1) return;\n+    if (!ast_func || !ast_func->arguments || ast_func->arguments->children.size() != 1)\n+        return;\n \n     const auto * column_id = ast_func->arguments->children.at(0)->as<ASTIdentifier>();\n-    if (!column_id) return;\n+    if (!column_id)\n+        return;\n \n     auto pos = IdentifierSemantic::getMembership(*column_id);\n     if (!pos)\n@@ -158,21 +160,30 @@ void OptimizeDateOrDateTimeConverterWithPreimageMatcher::visit(const ASTFunction\n         return;\n \n     auto data_type_and_name = data.tables[*pos].columns.tryGetByName(column_id->shortName());\n-    if (!data_type_and_name) return;\n+    if (!data_type_and_name)\n+        return;\n+\n+    const auto column_type = data_type_and_name->type;\n+    if (!column_type || (!isDateOrDate32(*column_type) && !isDateTime(*column_type) && !isDateTime64(*column_type)))\n+        return;\n \n     const auto & converter = FunctionFactory::instance().tryGet(ast_func->name, data.context);\n-    if (!converter) return;\n+    if (!converter)\n+        return;\n \n     ColumnsWithTypeAndName args;\n-    args.emplace_back(data_type_and_name->type, \"tmp\");\n+    args.emplace_back(column_type, \"tmp\");\n     auto converter_base = converter->build(args);\n-    if (!converter_base || !converter_base->hasInformationAboutPreimage()) return;\n+    if (!converter_base || !converter_base->hasInformationAboutPreimage())\n+        return;\n \n-    auto preimage_range = converter_base->getPreimage(*(data_type_and_name->type), literal->value);\n-    if (!preimage_range) return;\n+    auto preimage_range = converter_base->getPreimage(*column_type, literal->value);\n+    if (!preimage_range)\n+        return;\n \n     const auto new_ast = generateOptimizedDateFilterAST(comparator, *data_type_and_name, *preimage_range);\n-    if (!new_ast) return;\n+    if (!new_ast)\n+        return;\n \n     ast = new_ast;\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02843_date_predicate_optimizations_bugs.reference b/tests/queries/0_stateless/02843_date_predicate_optimizations_bugs.reference\nnew file mode 100644\nindex 000000000000..d641328e9a56\n--- /dev/null\n+++ b/tests/queries/0_stateless/02843_date_predicate_optimizations_bugs.reference\n@@ -0,0 +1,2 @@\n+202308\t1\n+202308\t2\ndiff --git a/tests/queries/0_stateless/02843_date_predicate_optimizations_bugs.sql b/tests/queries/0_stateless/02843_date_predicate_optimizations_bugs.sql\nnew file mode 100644\nindex 000000000000..6e26a5166cb4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02843_date_predicate_optimizations_bugs.sql\n@@ -0,0 +1,9 @@\n+select\n+  toYYYYMM(date) as date_,\n+  n\n+from (select\n+  [toDate('20230815'), toDate('20230816')] as date,\n+  [1, 2] as n\n+) as data\n+array join date, n\n+where date_ >= 202303;\n",
  "problem_statement": "Query with array join and toYYYYMM in predicate doesn't work as expected\nReproduce:\r\n\r\n```sql\r\nselect\r\n  toYYYYMM(date) as date_,\r\n  n\r\nfrom (select \r\n  [toDate(now()), toDate(now())] as date,\r\n  [1, 2] as n\r\n) as data\r\narray join date, n\r\nwhere date_ >= 202303;\r\n```\r\n\r\nWork in 23.6: https://fiddle.clickhouse.com/cabc075a-ac8a-4a15-bd46-2bc2b1de09a6\r\nNot work in 23.7: https://fiddle.clickhouse.com/74c0b0b6-72f2-4fb7-8a0b-bc098307da70\r\n\r\nSuspicious PR: #52091\n",
  "hints_text": "Hi @canhld94, thanks for reporting this issue! I'll start working on its fix right away!",
  "created_at": "2023-08-15T06:23:20Z"
}