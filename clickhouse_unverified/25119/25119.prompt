You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Support Arrays in External Dictionaries
I had a conversation with @alexey-milovidov in Telegram today about supporting arrays in external dictionary attributes. A good use case might be something like Stack Overflow where users can update the tags. The question is immutable, but the tags need to be updated. In MySQL (or whatever external dictionary source), I would store the question id and an array of the string tags.

For now, my workaround is going to be something like this. It seems like this will have some significant performance implications, but I haven't tested them yet.
> Also you can have all tags in a comma separated string field. You can extract this field from the dictionary and split it to array with splitByChar.

cc @alex-zaitsev 

Segmentation fault while reading array from dictionary
**Describe the bug**

ClickHouse crashes when trying to read an array from a dictionary.

**Does it reproduce on recent release?**

Reproduce on v21.6.3.14-stable

**How to reproduce**

```sql
CREATE TABLE IF NOT EXISTS persons_table (
id UUID,
accounts Array(String)
) ENGINE = MergeTree() ORDER BY id;

INSERT INTO persons_table VALUES ('a6c5a46d-bf1e-4813-ada8-06f3406e6103', ['vfedorov@acme','vfedorov','vfedorov@acme.com']);

CREATE DICTIONARY IF NOT EXISTS persons_dictionary_ch (
id UUID,
accounts Array(String)
)
PRIMARY KEY id
SOURCE (CLICKHOUSE( host 'localhost' port 9000 user 'default' password '' db 'default' table 'persons_table' )) LAYOUT(COMPLEX_KEY_HASHED()) LIFETIME(300);

SELECT id, toString(accounts) FROM persons_dictionary_ch;
```

This is a synthetic example. In production, we load the dictionary from HTTP interface.

**Expected behavior**

```sql
SELECT id, toString(accounts) FROM persons_dictionary_ch;

┌─id───────────────────────────────────┬─toString(accounts)───────────────────────────────┐
│ a6c5a46d-bf1e-4813-ada8-06f3406e6103 │ ['vfedorov@acme','vfedorov','vfedorov@acme.com'] │
└──────────────────────────────────────┴──────────────────────────────────────────────────┘

```

**Error message and/or stacktrace**

```sql
SELECT id, toString(accounts) FROM persons_dictionary_ch;

[51b45ab248c5] 2021.06.08 17:28:50.985142 [ 162 ] <Fatal> BaseDaemon: ########################################
[51b45ab248c5] 2021.06.08 17:28:50.985210 [ 162 ] <Fatal> BaseDaemon: (version 21.6.3.14 (official build), build id: F48747FBABB1019F05627059924B154D356B9401) (from thread 161) (query_id: df9e46f0-7f00-42a8-8066-7639cddd512f) Received signal Segmentation fault (11)
[51b45ab248c5] 2021.06.08 17:28:50.985252 [ 162 ] <Fatal> BaseDaemon: Address: 0xfffffffffffffff8 Access: read. Address not mapped to object.
[51b45ab248c5] 2021.06.08 17:28:50.985284 [ 162 ] <Fatal> BaseDaemon: Stack trace: 0xf3ab701 0xa9b6667 0xa9b56e9 0xa9b4d5c 0xa76d20e 0xefc84de 0xefc89d2 0xf5dc1b5 0x105991fc 0x10599590 0x1059c467 0x1046195d 0x1045e4f1 0x1045c52d 0x1045c30d 0x1046957f 0x8b9b49f 0x8b9e9c3 0x7f0ae6ca4609 0x7f0ae6bcb293
[51b45ab248c5] 2021.06.08 17:28:50.985355 [ 162 ] <Fatal> BaseDaemon: 1. DB::SerializationArray::serializeText(DB::IColumn const&, unsigned long, DB::WriteBuffer&, DB::FormatSettings const&) const @ 0xf3ab701 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985441 [ 162 ] <Fatal> BaseDaemon: 2. DB::ConvertImplGenericToString::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&) @ 0xa9b6667 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985479 [ 162 ] <Fatal> BaseDaemon: 3. DB::FunctionConvert<DB::DataTypeString, DB::NameToString, DB::ToStringMonotonicity>::executeInternal(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xa9b56e9 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985518 [ 162 ] <Fatal> BaseDaemon: 4. DB::FunctionConvert<DB::DataTypeString, DB::NameToString, DB::ToStringMonotonicity>::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xa9b4d5c in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985568 [ 162 ] <Fatal> BaseDaemon: 5. DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0xa76d20e in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985611 [ 162 ] <Fatal> BaseDaemon: 6. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xefc84de in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985670 [ 162 ] <Fatal> BaseDaemon: 7. DB::IExecutableFunction::execute(std::__1::vector<DB::ColumnWithTypeAndName, std::__1::allocator<DB::ColumnWithTypeAndName> > const&, std::__1::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0xefc89d2 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985733 [ 162 ] <Fatal> BaseDaemon: 8. DB::ExpressionActions::execute(DB::Block&, unsigned long&, bool) const @ 0xf5dc1b5 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985783 [ 162 ] <Fatal> BaseDaemon: 9. DB::ExpressionTransform::transform(DB::Chunk&) @ 0x105991fc in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985833 [ 162 ] <Fatal> BaseDaemon: 10. DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x10599590 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985880 [ 162 ] <Fatal> BaseDaemon: 11. DB::ISimpleTransform::work() @ 0x1059c467 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985943 [ 162 ] <Fatal> BaseDaemon: 12. ? @ 0x1046195d in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.985982 [ 162 ] <Fatal> BaseDaemon: 13. DB::PipelineExecutor::executeStepImpl(unsigned long, unsigned long, std::__1::atomic<bool>*) @ 0x1045e4f1 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.986030 [ 162 ] <Fatal> BaseDaemon: 14. DB::PipelineExecutor::executeImpl(unsigned long) @ 0x1045c52d in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.986140 [ 162 ] <Fatal> BaseDaemon: 15. DB::PipelineExecutor::execute(unsigned long) @ 0x1045c30d in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.986203 [ 162 ] <Fatal> BaseDaemon: 16. ? @ 0x1046957f in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.986256 [ 162 ] <Fatal> BaseDaemon: 17. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0x8b9b49f in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.986288 [ 162 ] <Fatal> BaseDaemon: 18. ? @ 0x8b9e9c3 in /usr/bin/clickhouse
[51b45ab248c5] 2021.06.08 17:28:50.986342 [ 162 ] <Fatal> BaseDaemon: 19. start_thread @ 0x9609 in /usr/lib/x86_64-linux-gnu/libpthread-2.31.so
[51b45ab248c5] 2021.06.08 17:28:50.986411 [ 162 ] <Fatal> BaseDaemon: 20. clone @ 0x122293 in /usr/lib/x86_64-linux-gnu/libc-2.31.so
[51b45ab248c5] 2021.06.08 17:28:51.090568 [ 162 ] <Fatal> BaseDaemon: Checksum of the binary: B8C77CBC7ACCB6DD2F4B342509B65FEA, integrity check passed.

Exception on client:
Code: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000

Connecting to localhost:9000 as user default.
Code: 210. DB::NetException: Connection refused (localhost:9000)
```
поддержка массивов в словарях
Приветствую.

Массивы в словарях на текущий момент, насколько я мог понять, не поддерживаются. В качестве источника словаря используем PostgreSQL, массивы в которых имеют вид "{el1, el2, ...}".
Работаем с ними сейчас как со строками, используя примерно такие костыли:

```sql
# вариант с массивом
SELECT count() FROM stats WHERE event_date > '2017-10-01' AND offer_id IN (SELECT cast(id as UInt32) FROM dicts.offers_dict WHERE has(splitByChar(',', substring(countries, 2, length(countries)- 2)), '80'));
# вариант с like
SELECT count() FROM stats WHERE event_date > '2017-10-01' AND offer_id IN (SELECT cast(id as UInt32) FROM dicts.offers_dict WHERE concat(',', substring(countries, 2, length(countries) - 2), ',') like '%,80,%');

```

Подзапрос возвращает id тех offers, у которых поле countries содержит элемент "80". 
Вариант с like при этом быстрее примерно в два раза.

Есть ли возможность ускорить запрос? Или каким-то образом нативно использовать массивы в качестве атрибутов словарей?
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
