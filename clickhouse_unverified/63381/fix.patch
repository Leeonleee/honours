diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp
index de926e83024c..59b586d46a0d 100644
--- a/src/Parsers/ExpressionElementParsers.cpp
+++ b/src/Parsers/ExpressionElementParsers.cpp
@@ -170,9 +170,17 @@ bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 
 bool ParserIdentifier::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)
 {
-    /// Identifier in backquotes or in double quotes
+    /// Identifier in backquotes or in double quotes or in English-style Unicode double quotes
     if (pos->type == TokenType::QuotedIdentifier)
     {
+        /// The case of Unicode quotes. No escaping is supported. Assuming UTF-8.
+        if (*pos->begin == '\xE2' && pos->size() > 6) /// Empty identifiers are not allowed.
+        {
+            node = std::make_shared<ASTIdentifier>(String(pos->begin + 3, pos->end - 3));
+            ++pos;
+            return true;
+        }
+
         ReadBufferFromMemory buf(pos->begin, pos->size());
         String s;
 
@@ -1140,18 +1148,26 @@ bool ParserStringLiteral::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte
 
     if (pos->type == TokenType::StringLiteral)
     {
-        if (*pos->begin == 'x' || *pos->begin == 'X')
+        char first_char = *pos->begin;
+
+        if (first_char == 'x' || first_char == 'X')
         {
             constexpr size_t word_size = 2;
             return makeHexOrBinStringLiteral(pos, node, true, word_size);
         }
 
-        if (*pos->begin == 'b' || *pos->begin == 'B')
+        if (first_char == 'b' || first_char == 'B')
         {
             constexpr size_t word_size = 8;
             return makeHexOrBinStringLiteral(pos, node, false, word_size);
         }
 
+        /// The case of Unicode quotes. No escaping is supported. Assuming UTF-8.
+        if (first_char == '\xE2' && pos->size() >= 6)
+        {
+            return makeStringLiteral(pos, node, String(pos->begin + 3, pos->end - 3));
+        }
+
         ReadBufferFromMemory in(pos->begin, pos->size());
 
         try
diff --git a/src/Parsers/Lexer.cpp b/src/Parsers/Lexer.cpp
index 0e6db7a40e5d..15f0c83c074b 100644
--- a/src/Parsers/Lexer.cpp
+++ b/src/Parsers/Lexer.cpp
@@ -11,8 +11,9 @@ namespace
 {
 
 /// This must be consistent with functions in ReadHelpers.h
-template <char quote, TokenType success_token, TokenType error_token>
-Token quotedString(const char *& pos, const char * const token_begin, const char * const end)
+template <char quote>
+Token quotedString(const char *& pos, const char * const token_begin, const char * const end,
+    TokenType success_token, TokenType error_token)
 {
     ++pos;
     while (true)
@@ -45,6 +46,33 @@ Token quotedString(const char *& pos, const char * const token_begin, const char
     }
 }
 
+Token quotedStringWithUnicodeQuotes(const char *& pos, const char * const token_begin, const char * const end,
+    char expected_end_byte, TokenType success_token, TokenType error_token)
+{
+    /// ‘: e2 80 98
+    /// ’: e2 80 99
+    /// “: e2 80 9c
+    /// ”: e2 80 9d
+
+    while (true)
+    {
+        pos = find_first_symbols<'\xE2'>(pos, end);
+        if (pos + 2 >= end)
+            return Token(error_token, token_begin, end);
+        /// Empty identifiers are not allowed, while empty strings are.
+        if (success_token == TokenType::QuotedIdentifier && pos + 3 >= end)
+            return Token(error_token, token_begin, end);
+
+        if (pos[0] == '\xE2' && pos[1] == '\x80' && pos[2] == expected_end_byte)
+        {
+            pos += 3;
+            return Token(success_token, token_begin, pos);
+        }
+
+        ++pos;
+    }
+}
+
 Token quotedHexOrBinString(const char *& pos, const char * const token_begin, const char * const end)
 {
     constexpr char quote = '\'';
@@ -224,11 +252,11 @@ Token Lexer::nextTokenImpl()
         }
 
         case '\'':
-            return quotedString<'\'', TokenType::StringLiteral, TokenType::ErrorSingleQuoteIsNotClosed>(pos, token_begin, end);
+            return quotedString<'\''>(pos, token_begin, end, TokenType::StringLiteral, TokenType::ErrorSingleQuoteIsNotClosed);
         case '"':
-            return quotedString<'"', TokenType::QuotedIdentifier, TokenType::ErrorDoubleQuoteIsNotClosed>(pos, token_begin, end);
+            return quotedString<'"'>(pos, token_begin, end, TokenType::QuotedIdentifier, TokenType::ErrorDoubleQuoteIsNotClosed);
         case '`':
-            return quotedString<'`', TokenType::QuotedIdentifier, TokenType::ErrorBackQuoteIsNotClosed>(pos, token_begin, end);
+            return quotedString<'`'>(pos, token_begin, end, TokenType::QuotedIdentifier, TokenType::ErrorBackQuoteIsNotClosed);
 
         case '(':
             return Token(TokenType::OpeningRoundBracket, token_begin, ++pos);
@@ -434,6 +462,15 @@ Token Lexer::nextTokenImpl()
                 pos += 3;
                 return Token(TokenType::Minus, token_begin, pos);
             }
+            /// Unicode quoted string, ‘Hello’ or “World”.
+            if (pos + 5 < end && pos[0] == '\xE2' && pos[1] == '\x80' && (pos[2] == '\x98' || pos[2] == '\x9C'))
+            {
+                const char expected_end_byte = pos[2] + 1;
+                TokenType success_token = pos[2] == '\x98' ? TokenType::StringLiteral : TokenType::QuotedIdentifier;
+                TokenType error_token = pos[2] == '\x98' ? TokenType::ErrorSingleQuoteIsNotClosed : TokenType::ErrorDoubleQuoteIsNotClosed;
+                pos += 3;
+                return quotedStringWithUnicodeQuotes(pos, token_begin, end, expected_end_byte, success_token, error_token);
+            }
             /// Other characters starting at E2 can be parsed, see skipWhitespacesUTF8
             [[fallthrough]];
         }
