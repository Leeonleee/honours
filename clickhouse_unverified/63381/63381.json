{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63381,
  "instance_id": "ClickHouse__ClickHouse-63381",
  "issue_numbers": [
    "58634"
  ],
  "base_commit": "7ac5821a2396aa6d1880b2b6d58e644e60b2b078",
  "patch": "diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex de926e83024c..59b586d46a0d 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -170,9 +170,17 @@ bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n bool ParserIdentifier::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    /// Identifier in backquotes or in double quotes\n+    /// Identifier in backquotes or in double quotes or in English-style Unicode double quotes\n     if (pos->type == TokenType::QuotedIdentifier)\n     {\n+        /// The case of Unicode quotes. No escaping is supported. Assuming UTF-8.\n+        if (*pos->begin == '\\xE2' && pos->size() > 6) /// Empty identifiers are not allowed.\n+        {\n+            node = std::make_shared<ASTIdentifier>(String(pos->begin + 3, pos->end - 3));\n+            ++pos;\n+            return true;\n+        }\n+\n         ReadBufferFromMemory buf(pos->begin, pos->size());\n         String s;\n \n@@ -1140,18 +1148,26 @@ bool ParserStringLiteral::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n \n     if (pos->type == TokenType::StringLiteral)\n     {\n-        if (*pos->begin == 'x' || *pos->begin == 'X')\n+        char first_char = *pos->begin;\n+\n+        if (first_char == 'x' || first_char == 'X')\n         {\n             constexpr size_t word_size = 2;\n             return makeHexOrBinStringLiteral(pos, node, true, word_size);\n         }\n \n-        if (*pos->begin == 'b' || *pos->begin == 'B')\n+        if (first_char == 'b' || first_char == 'B')\n         {\n             constexpr size_t word_size = 8;\n             return makeHexOrBinStringLiteral(pos, node, false, word_size);\n         }\n \n+        /// The case of Unicode quotes. No escaping is supported. Assuming UTF-8.\n+        if (first_char == '\\xE2' && pos->size() >= 6)\n+        {\n+            return makeStringLiteral(pos, node, String(pos->begin + 3, pos->end - 3));\n+        }\n+\n         ReadBufferFromMemory in(pos->begin, pos->size());\n \n         try\ndiff --git a/src/Parsers/Lexer.cpp b/src/Parsers/Lexer.cpp\nindex 0e6db7a40e5d..15f0c83c074b 100644\n--- a/src/Parsers/Lexer.cpp\n+++ b/src/Parsers/Lexer.cpp\n@@ -11,8 +11,9 @@ namespace\n {\n \n /// This must be consistent with functions in ReadHelpers.h\n-template <char quote, TokenType success_token, TokenType error_token>\n-Token quotedString(const char *& pos, const char * const token_begin, const char * const end)\n+template <char quote>\n+Token quotedString(const char *& pos, const char * const token_begin, const char * const end,\n+    TokenType success_token, TokenType error_token)\n {\n     ++pos;\n     while (true)\n@@ -45,6 +46,33 @@ Token quotedString(const char *& pos, const char * const token_begin, const char\n     }\n }\n \n+Token quotedStringWithUnicodeQuotes(const char *& pos, const char * const token_begin, const char * const end,\n+    char expected_end_byte, TokenType success_token, TokenType error_token)\n+{\n+    /// \u2018: e2 80 98\n+    /// \u2019: e2 80 99\n+    /// \u201c: e2 80 9c\n+    /// \u201d: e2 80 9d\n+\n+    while (true)\n+    {\n+        pos = find_first_symbols<'\\xE2'>(pos, end);\n+        if (pos + 2 >= end)\n+            return Token(error_token, token_begin, end);\n+        /// Empty identifiers are not allowed, while empty strings are.\n+        if (success_token == TokenType::QuotedIdentifier && pos + 3 >= end)\n+            return Token(error_token, token_begin, end);\n+\n+        if (pos[0] == '\\xE2' && pos[1] == '\\x80' && pos[2] == expected_end_byte)\n+        {\n+            pos += 3;\n+            return Token(success_token, token_begin, pos);\n+        }\n+\n+        ++pos;\n+    }\n+}\n+\n Token quotedHexOrBinString(const char *& pos, const char * const token_begin, const char * const end)\n {\n     constexpr char quote = '\\'';\n@@ -224,11 +252,11 @@ Token Lexer::nextTokenImpl()\n         }\n \n         case '\\'':\n-            return quotedString<'\\'', TokenType::StringLiteral, TokenType::ErrorSingleQuoteIsNotClosed>(pos, token_begin, end);\n+            return quotedString<'\\''>(pos, token_begin, end, TokenType::StringLiteral, TokenType::ErrorSingleQuoteIsNotClosed);\n         case '\"':\n-            return quotedString<'\"', TokenType::QuotedIdentifier, TokenType::ErrorDoubleQuoteIsNotClosed>(pos, token_begin, end);\n+            return quotedString<'\"'>(pos, token_begin, end, TokenType::QuotedIdentifier, TokenType::ErrorDoubleQuoteIsNotClosed);\n         case '`':\n-            return quotedString<'`', TokenType::QuotedIdentifier, TokenType::ErrorBackQuoteIsNotClosed>(pos, token_begin, end);\n+            return quotedString<'`'>(pos, token_begin, end, TokenType::QuotedIdentifier, TokenType::ErrorBackQuoteIsNotClosed);\n \n         case '(':\n             return Token(TokenType::OpeningRoundBracket, token_begin, ++pos);\n@@ -434,6 +462,15 @@ Token Lexer::nextTokenImpl()\n                 pos += 3;\n                 return Token(TokenType::Minus, token_begin, pos);\n             }\n+            /// Unicode quoted string, \u2018Hello\u2019 or \u201cWorld\u201d.\n+            if (pos + 5 < end && pos[0] == '\\xE2' && pos[1] == '\\x80' && (pos[2] == '\\x98' || pos[2] == '\\x9C'))\n+            {\n+                const char expected_end_byte = pos[2] + 1;\n+                TokenType success_token = pos[2] == '\\x98' ? TokenType::StringLiteral : TokenType::QuotedIdentifier;\n+                TokenType error_token = pos[2] == '\\x98' ? TokenType::ErrorSingleQuoteIsNotClosed : TokenType::ErrorDoubleQuoteIsNotClosed;\n+                pos += 3;\n+                return quotedStringWithUnicodeQuotes(pos, token_begin, end, expected_end_byte, success_token, error_token);\n+            }\n             /// Other characters starting at E2 can be parsed, see skipWhitespacesUTF8\n             [[fallthrough]];\n         }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03145_unicode_quotes.reference b/tests/queries/0_stateless/03145_unicode_quotes.reference\nnew file mode 100644\nindex 000000000000..8d33edf14e3d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03145_unicode_quotes.reference\n@@ -0,0 +1,5 @@\n+This is an example of using English-style Unicode single quotes.\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+\\c\\\\u\\\\\\r\\\\\\\\l\\\\\\\\\\y\\\\\\\\\\\\: This is \\an \\\\example \u2018of using English-style Unicode single quotes.\\\n+{\"1\":1}\ndiff --git a/tests/queries/0_stateless/03145_unicode_quotes.sql b/tests/queries/0_stateless/03145_unicode_quotes.sql\nnew file mode 100644\nindex 000000000000..34a465cd874b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03145_unicode_quotes.sql\n@@ -0,0 +1,9 @@\n+-- They work:\n+SELECT \u2018This is an example of using English-style Unicode single quotes.\u2019 AS \u201ccurly\u201d;\n+\n+-- It is unspecified which escaping rules apply inside the literal in Unicode quotes, and currently none apply (similarly to heredocs)\n+-- This could be changed.\n+\n+SELECT \u2018This is \\an \\\\example \u2018of using English-style Unicode single quotes.\\\u2019 AS \u201c\\c\\\\u\\\\\\r\\\\\\\\l\\\\\\\\\\y\\\\\\\\\\\\\u201d FORMAT Vertical;\n+\n+SELECT \u2018\u2019 = '' AS \u201c1\u201d FORMAT JSONLines;\n",
  "problem_statement": "Add support for nice single quotes in Lexer\n**Use case**\r\n\r\nA user on Mac first writes a query using a text editor for documents, then copy-pastes it to `clickhouse-client`, and the query looks like this:\r\n\r\n```\r\nSELECT \u2018Hello, world\u2019\r\n```\r\n\r\n**Describe the solution you'd like**\r\n\r\nMake it work.\r\n\n",
  "hints_text": "Hello @alexey-milovidov , can I work on this?\n@chrisxu333, thank you! This will be very appreciated!\n`\u201cidentifier\u201d` for identifiers as well.",
  "created_at": "2024-05-05T02:35:15Z"
}