{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62462,
  "instance_id": "ClickHouse__ClickHouse-62462",
  "issue_numbers": [
    "62036"
  ],
  "base_commit": "ad385238da24682e02e9867b28a38fb060eba834",
  "patch": "diff --git a/src/Planner/PlannerActionsVisitor.cpp b/src/Planner/PlannerActionsVisitor.cpp\nindex 656b6cdaa6e6..02c1c56fae2e 100644\n--- a/src/Planner/PlannerActionsVisitor.cpp\n+++ b/src/Planner/PlannerActionsVisitor.cpp\n@@ -39,6 +39,7 @@ namespace ErrorCodes\n     extern const int UNSUPPORTED_METHOD;\n     extern const int LOGICAL_ERROR;\n     extern const int BAD_ARGUMENTS;\n+    extern const int INCORRECT_QUERY;\n }\n \n namespace\n@@ -500,7 +501,41 @@ class PlannerActionsVisitorImpl\n     ActionsDAG::NodeRawConstPtrs visit(QueryTreeNodePtr expression_node);\n \n private:\n-    using NodeNameAndNodeMinLevel = std::pair<std::string, size_t>;\n+\n+    class Levels\n+    {\n+    public:\n+        explicit Levels(size_t level) { set(level); }\n+\n+        void set(size_t level)\n+        {\n+            check(level);\n+            if (level)\n+                mask |= (uint64_t(1) << (level - 1));\n+        }\n+\n+        void reset(size_t level)\n+        {\n+            check(level);\n+            if (level)\n+                mask &= ~(uint64_t(1) << (level - 1));\n+        }\n+\n+        void add(Levels levels) { mask |= levels.mask; }\n+\n+        size_t max() const { return 64 - getLeadingZeroBits(mask); }\n+\n+    private:\n+        uint64_t mask = 0;\n+\n+        void check(size_t level)\n+        {\n+            if (level > 64)\n+                throw Exception(ErrorCodes::INCORRECT_QUERY, \"Maximum lambda depth exceeded. Maximum 64.\");\n+        }\n+    };\n+\n+    using NodeNameAndNodeMinLevel = std::pair<std::string, Levels>;\n \n     NodeNameAndNodeMinLevel visitImpl(QueryTreeNodePtr node);\n \n@@ -586,11 +621,11 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n             column_source->getNodeType() == QueryTreeNodeType::LAMBDA &&\n             actions_stack[i].getScopeNode().get() == column_source.get())\n         {\n-            return {column_node_name, i};\n+            return {column_node_name, Levels(i)};\n         }\n     }\n \n-    return {column_node_name, 0};\n+    return {column_node_name, Levels(0)};\n }\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitConstant(const QueryTreeNodePtr & node)\n@@ -660,7 +695,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n         actions_stack_node.addInputConstantColumnIfNecessary(constant_node_name, column);\n     }\n \n-    return {constant_node_name, 0};\n+    return {constant_node_name, Levels(0)};\n \n }\n \n@@ -688,7 +723,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     auto lambda_actions_dag = std::make_shared<ActionsDAG>();\n     actions_stack.emplace_back(lambda_actions_dag, node);\n \n-    auto [lambda_expression_node_name, level] = visitImpl(lambda_node.getExpression());\n+    auto [lambda_expression_node_name, levels] = visitImpl(lambda_node.getExpression());\n     lambda_actions_dag->getOutputs().push_back(actions_stack.back().getNodeOrThrow(lambda_expression_node_name));\n     lambda_actions_dag->removeUnusedActions(Names(1, lambda_expression_node_name));\n \n@@ -699,8 +734,9 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     ActionsDAG::NodeRawConstPtrs lambda_children;\n     Names required_column_names = lambda_actions->getRequiredColumns();\n \n-    if (level == actions_stack.size() - 1)\n-        --level;\n+    actions_stack.pop_back();\n+    levels.reset(actions_stack.size());\n+    size_t level = levels.max();\n \n     const auto & lambda_argument_names = lambda_node.getArgumentNames();\n \n@@ -718,7 +754,6 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     auto lambda_node_name = calculateActionNodeName(node, *planner_context);\n     auto function_capture = std::make_shared<FunctionCaptureOverloadResolver>(\n         lambda_actions, captured_column_names, lambda_arguments_names_and_types, lambda_node.getExpression()->getResultType(), lambda_expression_node_name);\n-    actions_stack.pop_back();\n \n     // TODO: Pass IFunctionBase here not FunctionCaptureOverloadResolver.\n     const auto * actions_node = actions_stack[level].addFunctionIfNecessary(lambda_node_name, std::move(lambda_children), function_capture);\n@@ -735,7 +770,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n         actions_stack_node.addInputColumnIfNecessary(lambda_node_name, result_type);\n     }\n \n-    return {lambda_node_name, level};\n+    return {lambda_node_name, levels};\n }\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::makeSetForInFunction(const QueryTreeNodePtr & node)\n@@ -799,7 +834,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::ma\n         actions_stack_node.addInputConstantColumnIfNecessary(column.name, column);\n     }\n \n-    return {column.name, 0};\n+    return {column.name, Levels(0)};\n }\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitIndexHintFunction(const QueryTreeNodePtr & node)\n@@ -833,7 +868,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     size_t index_hint_function_level = actions_stack.size() - 1;\n     actions_stack[index_hint_function_level].addFunctionIfNecessary(function_node_name, {}, index_hint_function_overload_resolver);\n \n-    return {function_node_name, index_hint_function_level};\n+    return {function_node_name, Levels(index_hint_function_level)};\n }\n \n PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::visitFunction(const QueryTreeNodePtr & node)\n@@ -868,7 +903,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n             actions_stack_node.addInputColumnIfNecessary(function_node_name, function_node.getResultType());\n         }\n \n-        return {function_node_name, 0};\n+        return {function_node_name, Levels(0)};\n     }\n \n     const auto & function_arguments = function_node.getArguments().getNodes();\n@@ -877,14 +912,14 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n     Names function_arguments_node_names;\n     function_arguments_node_names.reserve(function_arguments_size);\n \n-    size_t level = 0;\n+    Levels levels(0);\n     for (size_t function_argument_index = 0; function_argument_index < function_arguments_size; ++function_argument_index)\n     {\n         if (in_function_second_argument_node_name_with_level && function_argument_index == 1)\n         {\n-            auto & [node_name, node_min_level] = *in_function_second_argument_node_name_with_level;\n+            auto & [node_name, node_levels] = *in_function_second_argument_node_name_with_level;\n             function_arguments_node_names.push_back(std::move(node_name));\n-            level = std::max(level, node_min_level);\n+            levels.add(node_levels);\n             continue;\n         }\n \n@@ -892,20 +927,21 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n \n         if (argument->getNodeType() == QueryTreeNodeType::LAMBDA)\n         {\n-            auto [node_name, node_min_level] = visitLambda(argument);\n+            auto [node_name, node_levels] = visitLambda(argument);\n             function_arguments_node_names.push_back(std::move(node_name));\n-            level = std::max(level, node_min_level);\n+            levels.add(node_levels);\n             continue;\n         }\n \n-        auto [node_name, node_min_level] = visitImpl(argument);\n+        auto [node_name, node_levels] = visitImpl(argument);\n         function_arguments_node_names.push_back(std::move(node_name));\n-        level = std::max(level, node_min_level);\n+        levels.add(node_levels);\n     }\n \n     ActionsDAG::NodeRawConstPtrs children;\n     children.reserve(function_arguments_size);\n \n+    size_t level = levels.max();\n     for (auto & function_argument_node_name : function_arguments_node_names)\n         children.push_back(actions_stack[level].getNodeOrThrow(function_argument_node_name));\n \n@@ -930,7 +966,7 @@ PlannerActionsVisitorImpl::NodeNameAndNodeMinLevel PlannerActionsVisitorImpl::vi\n         actions_stack_node.addInputColumnIfNecessary(function_node_name, function_node.getResultType());\n     }\n \n-    return {function_node_name, level};\n+    return {function_node_name, levels};\n }\n \n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql b/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql\nindex 48e84246d1c9..be4b64888ca2 100644\n--- a/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql\n+++ b/tests/queries/0_stateless/02389_analyzer_nested_lambda.sql\n@@ -127,3 +127,14 @@ SELECT arrayMap(x -> splitByChar(toString(id), arrayMap(x -> toString(1), [NULL]\n DROP TABLE test_table;\n \n -- { echoOff }\n+\n+SELECT\n+    groupArray(number) AS counts,\n+    arraySum(arrayMap(x -> (x + 1), counts)) as hello,\n+    arrayMap(x -> (x / hello), counts) AS res\n+FROM numbers(1000000) FORMAT Null;\n+\n+SELECT\n+  arrayWithConstant(pow(10,6), 1) AS nums,\n+  arrayMap(x -> x, nums) AS m,\n+  arrayMap(x -> x + arraySum(m), m) AS res FORMAT Null;\n",
  "problem_statement": "Memory limit exceeded with new analyzer\nHello!\r\nI prepared a minimal reproducible example of the problem (tested on 24.3.1.2672):\r\n```sql\r\nWITH\r\n    groupArray(count) AS counts,\r\n    arrayMap(x -> (x + 1), counts) AS some_metric,\r\n    arrayMap(x -> (x / arraySum(some_metric)), some_metric) AS res\r\nSELECT arrayJoin(res) AS result\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM generateRandom('count UInt8')\r\n    LIMIT 1000000\r\n)\r\nFORMAT `Null`\r\nSETTINGS allow_experimental_analyzer = 0\r\n```\r\n```\r\n0 rows in set. Elapsed: 0.045 sec. Processed 1.31 million rows, 1.31 MB (29.08 million rows/s., 29.08 MB/s.)\r\nPeak memory usage: 16.75 MiB.\r\n```\r\n\r\nBut new analyzer needs a way more RAM to handle the same query:\r\n```sql\r\nWITH\r\n    groupArray(count) AS counts,\r\n    arrayMap(x -> (x + 1), counts) AS some_metric,\r\n    arrayMap(x -> (x / arraySum(some_metric)), some_metric) AS res\r\nSELECT arrayJoin(res) AS result\r\nFROM\r\n(\r\n    SELECT *\r\n    FROM generateRandom('count UInt8')\r\n    LIMIT 1000000\r\n)\r\nFORMAT `Null`\r\nSETTINGS allow_experimental_analyzer = 1\r\n```\r\n```\r\nElapsed: 0.023 sec. \r\n\r\nReceived exception from server (version 24.3.1):\r\nCode: 241. DB::Exception: Received from localhost:9000. DB::Exception:\r\nMemory limit (total) exceeded: would use 932.93 GiB (attempt to allocate chunk of 1000003273111 bytes), maximum: 27.93 GiB. OvercommitTracker decision: Query was selected to stop by OvercommitTracker.: while executing 'FUNCTION arrayMap(__lambda_8141180715573801285_17054877471657376131 :: 2, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count)) :: 1) -> arrayMap(__lambda_8141180715573801285_17054877471657376131, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count))) Array(Float64) : 0'. (MEMORY_LIMIT_EXCEEDED)\r\n```\n",
  "hints_text": "I've changed the query a bit and the actions look different: \r\nWithout Analyzer:\r\n```\r\nEXPLAIN actions=1\r\nWITH\r\n    groupArray(count) AS counts,\r\n    arrayMap(x -> (x + 1), counts) AS some_metric,\r\n    arrayMap(x -> (x / arraySum(some_metric)), some_metric) AS res\r\nSELECT arrayJoin(res) AS result\r\nFROM\r\n(\r\n    SELECT number::UInt8 as count\r\n    FROM numbers(1000000)\r\n)\r\nSETTINGS allow_experimental_analyzer = 0\r\n--------------------------------------------\r\nExpression ((Projection + Before ORDER BY))\r\nActions: INPUT : 0 -> counts Array(UInt8) : 0\r\n         COLUMN Const(UInt8) -> 1 UInt8 : 1\r\n         FUNCTION Capture[UInt8](UInt8) -> UInt16(1 :: 1) -> __lambda Function(UInt8 -> UInt16) : 2\r\n         FUNCTION arrayMap(__lambda :: 2, counts :: 0) -> some_metric Array(UInt16) : 1\r\n         FUNCTION arraySum(some_metric : 1) -> arraySum(some_metric) UInt64 : 0\r\n         FUNCTION Capture[UInt64](UInt16) -> Float64(arraySum(some_metric) :: 0) -> __lambda_2 Function(UInt16 -> Float64) : 2\r\n         FUNCTION arrayMap(__lambda_2 :: 2, some_metric :: 1) -> res Array(Float64) : 0\r\n         ARRAY JOIN res :: 0 -> arrayJoin(res) Float64 : 1\r\n         ALIAS arrayJoin(res) :: 1 -> result Float64 : 0\r\nPositions: 0\r\n  Aggregating\r\n  Keys: \r\n  Aggregates:\r\n      counts\r\n        Function: groupArray(UInt8) \u2192 Array(UInt8)\r\n        Arguments: count\r\n  Skip merging: 0\r\n    Expression ((Before GROUP BY + (Projection + Before ORDER BY)))\r\n    Actions: INPUT : 0 -> number UInt64 : 0\r\n             COLUMN Const(String) -> \\'UInt8\\' String : 1\r\n             FUNCTION CAST(number :: 0, \\'UInt8\\' :: 1) -> CAST(number, \\'UInt8\\') UInt8 : 2\r\n             ALIAS CAST(number, \\'UInt8\\') :: 2 -> count UInt8 : 1\r\n    Positions: 1\r\n      ReadFromSystemNumbers\r\n```\r\n\r\nWith Analyzer:\r\n```\r\nEXPLAIN actions=1\r\nWITH\r\n    groupArray(count) AS counts,\r\n    arrayMap(x -> (x + 1), counts) AS some_metric,\r\n    arrayMap(x -> (x / arraySum(some_metric)), some_metric) AS res\r\nSELECT arrayJoin(res) AS result\r\nFROM\r\n(\r\n    SELECT number::UInt8 as count\r\n    FROM numbers(1000000)\r\n)\r\nSETTINGS allow_experimental_analyzer = 1\r\n--------------------------------------------\r\nExpression ((Project names + Projection))\r\nActions: INPUT : 0 -> groupArray(__table1.count) Array(UInt8) : 0\r\n         COLUMN Const(UInt8) -> 1_UInt8 UInt8 : 1\r\n         FUNCTION Capture[UInt8, Array(UInt8)](UInt16) -> Float64(1_UInt8 : 1, groupArray(__table1.count) : 0) -> __lambda_18090036302839473520_7778584759066990996 Function(UInt16 -> Float64) : 2\r\n         FUNCTION Capture[UInt8](UInt8) -> UInt16(1_UInt8 :: 1) -> __lambda_14042983518542017256_6366473326654511736 Function(UInt8 -> UInt16) : 3\r\n         FUNCTION arrayMap(__lambda_14042983518542017256_6366473326654511736 :: 3, groupArray(__table1.count) :: 0) -> arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count)) Array(UInt16) : 1\r\n         FUNCTION arrayMap(__lambda_18090036302839473520_7778584759066990996 :: 2, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count)) :: 1) -> arrayMap(__lambda_18090036302839473520_7778584759066990996, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count))) Array(Float64) : 0\r\n         ARRAY JOIN arrayMap(__lambda_18090036302839473520_7778584759066990996, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count))) :: 0 -> arrayJoin(arrayMap(__lambda_18090036302839473520_7778584759066990996, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count)))) Float64 : 1\r\n         ALIAS arrayJoin(arrayMap(__lambda_18090036302839473520_7778584759066990996, arrayMap(__lambda_14042983518542017256_6366473326654511736, groupArray(__table1.count)))) :: 1 -> result Float64 : 0\r\nPositions: 0\r\n  Aggregating\r\n  Keys: \r\n  Aggregates:\r\n      groupArray(__table1.count)\r\n        Function: groupArray(UInt8) \u2192 Array(UInt8)\r\n        Arguments: __table1.count\r\n  Skip merging: 0\r\n    Expression ((Before GROUP BY + (Change column names to column identifiers + (Project names + (Projection + Change column names to column identifiers)))))\r\n    Actions: INPUT : 0 -> number UInt64 : 0\r\n             COLUMN Const(String) -> \\'UInt8\\'_String String : 1\r\n             ALIAS number :: 0 -> __table2.number UInt64 : 2\r\n             FUNCTION CAST(__table2.number :: 2, \\'UInt8\\'_String :: 1) -> CAST(__table2.number, \\'UInt8\\'_String) UInt8 : 0\r\n             ALIAS CAST(__table2.number, \\'UInt8\\'_String) :: 0 -> count UInt8 : 1\r\n             ALIAS count :: 1 -> __table1.count UInt8 : 0\r\n    Positions: 0\r\n      ReadFromSystemNumbers\r\n```\nSmaller query: \r\n\r\n\r\n```\r\nSELECT\r\n    groupArray(number) AS counts,\r\n    arraySum(arrayMap(x -> (x + 1), counts)) as hello,\r\n    arrayMap(x -> (x / hello), counts) AS res\r\nFROM numbers(1000000)\r\nSETTINGS allow_experimental_analyzer = 1\r\n```\r\n\r\nLooks like we broke ActionsDAG / ExpressionActions and they don't reuse inputs for calculating expressions...\nCan be even smaller.\r\n```sql\r\nSELECT\r\n  arrayWithConstant(pow(10,6), 1) AS nums,\r\n  arrayMap(x -> x, nums) AS m,\r\n  arrayMap(x -> x + arraySum(m), m) AS res\r\nSETTINGS allow_experimental_analyzer = 1\r\n```\r\nThis one prints all array contents into error message.",
  "created_at": "2024-04-09T18:53:37Z"
}