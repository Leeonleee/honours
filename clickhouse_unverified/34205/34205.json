{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34205,
  "instance_id": "ClickHouse__ClickHouse-34205",
  "issue_numbers": [
    "34200"
  ],
  "base_commit": "3a0ed0f8f505640270b426d26d816549e528a443",
  "patch": "diff --git a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\nindex 90db6f6f0ec8..4754b70d3753 100644\n--- a/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/RegexpRowInputFormat.cpp\n@@ -37,7 +37,7 @@ bool RegexpFieldExtractor::parseRow(PeekableReadBuffer & buf)\n \n     do\n     {\n-        char * pos = find_first_symbols<'\\n', '\\r'>(buf.position(), buf.buffer().end());\n+        char * pos = find_first_symbols<'\\n'>(buf.position(), buf.buffer().end());\n         line_size += pos - buf.position();\n         buf.position() = pos;\n     } while (buf.position() == buf.buffer().end() && !buf.eof());\n@@ -45,15 +45,19 @@ bool RegexpFieldExtractor::parseRow(PeekableReadBuffer & buf)\n     buf.makeContinuousMemoryFromCheckpointToPos();\n     buf.rollbackToCheckpoint();\n \n-    bool match = RE2::FullMatchN(re2::StringPiece(buf.position(), line_size), regexp, re2_arguments_ptrs.data(), re2_arguments_ptrs.size());\n+    /// Allow DOS line endings.\n+    size_t line_to_match = line_size;\n+    if (line_size > 0 && buf.position()[line_size - 1] == '\\r')\n+        --line_to_match;\n+\n+    bool match = re2_st::RE2::FullMatchN(re2_st::StringPiece(buf.position(), line_to_match), regexp, re2_arguments_ptrs.data(), re2_arguments_ptrs.size());\n \n     if (!match && !skip_unmatched)\n-        throw Exception(\"Line \\\"\" + std::string(buf.position(), line_size) + \"\\\" doesn't match the regexp.\", ErrorCodes::INCORRECT_DATA);\n+        throw Exception(\"Line \\\"\" + std::string(buf.position(), line_to_match) + \"\\\" doesn't match the regexp.\", ErrorCodes::INCORRECT_DATA);\n \n     buf.position() += line_size;\n-    checkChar('\\r', buf);\n     if (!buf.eof() && !checkChar('\\n', buf))\n-        throw Exception(\"No \\\\n after \\\\r at the end of line.\", ErrorCodes::INCORRECT_DATA);\n+        throw Exception(\"No \\\\n at the end of line.\", ErrorCodes::LOGICAL_ERROR);\n \n     return match;\n }\n@@ -65,12 +69,12 @@ RegexpRowInputFormat::RegexpRowInputFormat(\n }\n \n RegexpRowInputFormat::RegexpRowInputFormat(\n-        std::unique_ptr<PeekableReadBuffer> buf_, const Block & header_, Params params_, const FormatSettings & format_settings_)\n-        : IRowInputFormat(header_, *buf_, std::move(params_))\n-        , buf(std::move(buf_))\n-        , format_settings(format_settings_)\n-        , escaping_rule(format_settings_.regexp.escaping_rule)\n-        , field_extractor(RegexpFieldExtractor(format_settings_))\n+    std::unique_ptr<PeekableReadBuffer> buf_, const Block & header_, Params params_, const FormatSettings & format_settings_)\n+    : IRowInputFormat(header_, *buf_, std::move(params_))\n+    , buf(std::move(buf_))\n+    , format_settings(format_settings_)\n+    , escaping_rule(format_settings_.regexp.escaping_rule)\n+    , field_extractor(RegexpFieldExtractor(format_settings_))\n {\n }\n \n@@ -174,20 +178,12 @@ static std::pair<bool, size_t> fileSegmentationEngineRegexpImpl(ReadBuffer & in,\n \n     while (loadAtPosition(in, memory, pos) && need_more_data)\n     {\n-        pos = find_first_symbols<'\\n', '\\r'>(pos, in.buffer().end());\n+        pos = find_first_symbols<'\\n'>(pos, in.buffer().end());\n         if (pos > in.buffer().end())\n-                throw Exception(\"Position in buffer is out of bounds. There must be a bug.\", ErrorCodes::LOGICAL_ERROR);\n+            throw Exception(\"Position in buffer is out of bounds. There must be a bug.\", ErrorCodes::LOGICAL_ERROR);\n         else if (pos == in.buffer().end())\n             continue;\n \n-        // Support DOS-style newline (\"\\r\\n\")\n-        if (*pos == '\\r')\n-        {\n-            ++pos;\n-            if (pos == in.buffer().end())\n-                loadAtPosition(in, memory, pos);\n-        }\n-\n         if (memory.size() + static_cast<size_t>(pos - in.position()) >= min_chunk_size)\n             need_more_data = false;\n \ndiff --git a/src/Processors/Formats/Impl/RegexpRowInputFormat.h b/src/Processors/Formats/Impl/RegexpRowInputFormat.h\nindex dffd2f82e020..e70595b4bb7c 100644\n--- a/src/Processors/Formats/Impl/RegexpRowInputFormat.h\n+++ b/src/Processors/Formats/Impl/RegexpRowInputFormat.h\n@@ -1,7 +1,7 @@\n #pragma once\n \n-#include <re2/re2.h>\n-#include <re2/stringpiece.h>\n+#include <re2_st/re2.h>\n+#include <re2_st/stringpiece.h>\n #include <string>\n #include <vector>\n #include <Core/Block.h>\n@@ -12,6 +12,7 @@\n #include <IO/PeekableReadBuffer.h>\n #include <Formats/ParsedTemplateFormatString.h>\n \n+\n namespace DB\n {\n \n@@ -26,17 +27,17 @@ class RegexpFieldExtractor\n     /// Return true if row was successfully parsed and row fields were extracted.\n     bool parseRow(PeekableReadBuffer & buf);\n \n-    re2::StringPiece getField(size_t index) { return matched_fields[index]; }\n+    re2_st::StringPiece getField(size_t index) { return matched_fields[index]; }\n     size_t getMatchedFieldsSize() const { return matched_fields.size(); }\n     size_t getNumberOfGroups() const { return regexp.NumberOfCapturingGroups(); }\n \n private:\n-    const RE2 regexp;\n+    const re2_st::RE2 regexp;\n     // The vector of fields extracted from line using regexp.\n-    std::vector<re2::StringPiece> matched_fields;\n+    std::vector<re2_st::StringPiece> matched_fields;\n     // These two vectors are needed to use RE2::FullMatchN (function for extracting fields).\n-    std::vector<RE2::Arg> re2_arguments;\n-    std::vector<RE2::Arg *> re2_arguments_ptrs;\n+    std::vector<re2_st::RE2::Arg> re2_arguments;\n+    std::vector<re2_st::RE2::Arg *> re2_arguments_ptrs;\n     bool skip_unmatched;\n };\n \ndiff --git a/utils/CMakeLists.txt b/utils/CMakeLists.txt\nindex 7822f47ff880..51300472ed11 100644\n--- a/utils/CMakeLists.txt\n+++ b/utils/CMakeLists.txt\n@@ -26,7 +26,6 @@ if (NOT DEFINED ENABLE_UTILS OR ENABLE_UTILS)\n     add_subdirectory (zookeeper-adjust-block-numbers-to-parts)\n     add_subdirectory (wikistat-loader)\n     add_subdirectory (check-marks)\n-    add_subdirectory (convert-month-partitioned-parts)\n     add_subdirectory (checksum-for-compressed-block)\n     add_subdirectory (db-generator)\n     add_subdirectory (wal-dump)\ndiff --git a/utils/convert-month-partitioned-parts/CMakeLists.txt b/utils/convert-month-partitioned-parts/CMakeLists.txt\ndeleted file mode 100644\nindex ea6429a06100..000000000000\n--- a/utils/convert-month-partitioned-parts/CMakeLists.txt\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-add_executable (convert-month-partitioned-parts main.cpp)\n-target_link_libraries(convert-month-partitioned-parts PRIVATE clickhouse_aggregate_functions dbms clickhouse_parsers boost::program_options)\ndiff --git a/utils/convert-month-partitioned-parts/main.cpp b/utils/convert-month-partitioned-parts/main.cpp\ndeleted file mode 100644\nindex a6829d79726c..000000000000\n--- a/utils/convert-month-partitioned-parts/main.cpp\n+++ /dev/null\n@@ -1,148 +0,0 @@\n-#include <DataTypes/DataTypeDate.h>\n-#include <DataTypes/DataTypesNumber.h>\n-#include <IO/HashingWriteBuffer.h>\n-#include <IO/ReadBufferFromFile.h>\n-#include <IO/WriteBufferFromFile.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTIdentifier.h>\n-#include <Storages/MergeTree/IMergeTreeDataPart.h>\n-#include <Storages/MergeTree/MergeTreePartInfo.h>\n-#include <Storages/MergeTree/localBackup.h>\n-#include <Common/Exception.h>\n-\n-#include <boost/program_options.hpp>\n-#include <Poco/Path.h>\n-#include <Poco/File.h>\n-\n-#include <iostream>\n-#include <Disks/DiskLocal.h>\n-\n-namespace DB\n-{\n-\n-namespace ErrorCodes\n-{\n-    extern const int DIRECTORY_ALREADY_EXISTS;\n-    extern const int BAD_DATA_PART_NAME;\n-    extern const int NO_FILE_IN_DATA_PART;\n-}\n-\n-void run(String part_path, String date_column, String dest_path)\n-{\n-    std::shared_ptr<IDisk> disk = std::make_shared<DiskLocal>(\"local\", \"/\", 0);\n-    auto old_part_path = Poco::Path::forDirectory(part_path);\n-    const String & old_part_name = old_part_path.directory(old_part_path.depth() - 1);\n-    String old_part_path_str = old_part_path.toString();\n-\n-    auto part_info = MergeTreePartInfo::fromPartName(old_part_name, MergeTreeDataFormatVersion(0));\n-    String new_part_name = part_info.getPartName();\n-\n-    auto new_part_path = Poco::Path::forDirectory(dest_path);\n-    new_part_path.pushDirectory(new_part_name);\n-    if (Poco::File(new_part_path).exists())\n-        throw Exception(\"Destination part directory `\" + new_part_path.toString() + \"` already exists\",\n-            ErrorCodes::DIRECTORY_ALREADY_EXISTS);\n-\n-    DayNum min_date;\n-    DayNum max_date;\n-    MergeTreePartInfo::parseMinMaxDatesFromPartName(old_part_name, min_date, max_date);\n-\n-    const auto & time_zone = DateLUT::instance();\n-    UInt32 yyyymm = time_zone.toNumYYYYMM(min_date);\n-    if (yyyymm != time_zone.toNumYYYYMM(max_date))\n-        throw Exception(\"Part \" + old_part_name + \" spans different months\",\n-            ErrorCodes::BAD_DATA_PART_NAME);\n-\n-    ReadBufferFromFile checksums_in(old_part_path_str + \"checksums.txt\", 4096);\n-    MergeTreeDataPartChecksums checksums;\n-    checksums.read(checksums_in);\n-\n-    auto date_col_checksum_it = checksums.files.find(date_column + \".bin\");\n-    if (date_col_checksum_it == checksums.files.end())\n-        throw Exception(\"Couldn't find checksum for the date column .bin file `\" + date_column + \".bin`\",\n-            ErrorCodes::NO_FILE_IN_DATA_PART);\n-\n-    UInt64 rows = date_col_checksum_it->second.uncompressed_size / DataTypeDate().getSizeOfValueInMemory();\n-\n-    auto new_tmp_part_path = Poco::Path::forDirectory(dest_path);\n-    new_tmp_part_path.pushDirectory(\"tmp_convert_\" + new_part_name);\n-    String new_tmp_part_path_str = new_tmp_part_path.toString();\n-    try\n-    {\n-        Poco::File(new_tmp_part_path).remove(/* recursive = */ true);\n-    }\n-    catch (const Poco::FileNotFoundException &)\n-    {\n-        /// If the file is already deleted, do nothing.\n-    }\n-    localBackup(disk, old_part_path.toString(), new_tmp_part_path.toString(), {});\n-\n-    WriteBufferFromFile count_out(new_tmp_part_path_str + \"count.txt\", 4096);\n-    HashingWriteBuffer count_out_hashing(count_out);\n-    writeIntText(rows, count_out_hashing);\n-    count_out_hashing.next();\n-    checksums.files[\"count.txt\"].file_size = count_out_hashing.count();\n-    checksums.files[\"count.txt\"].file_hash = count_out_hashing.getHash();\n-\n-    IMergeTreeDataPart::MinMaxIndex minmax_idx(min_date, max_date);\n-    Names minmax_idx_columns = {date_column};\n-    DataTypes minmax_idx_column_types = {std::make_shared<DataTypeDate>()};\n-    minmax_idx.store(minmax_idx_columns, minmax_idx_column_types, disk, new_tmp_part_path_str, checksums);\n-\n-    Block partition_key_sample{{nullptr, std::make_shared<DataTypeUInt32>(), makeASTFunction(\"toYYYYMM\", std::make_shared<ASTIdentifier>(date_column))->getColumnName()}};\n-\n-    MergeTreePartition partition(yyyymm);\n-    partition.store(partition_key_sample, disk, new_tmp_part_path_str, checksums);\n-    String partition_id = partition.getID(partition_key_sample);\n-\n-    Poco::File(new_tmp_part_path_str + \"checksums.txt\").setWriteable();\n-    WriteBufferFromFile checksums_out(new_tmp_part_path_str + \"checksums.txt\", 4096);\n-    checksums.write(checksums_out);\n-    checksums_in.close();\n-    checksums_out.close();\n-\n-    Poco::File(new_tmp_part_path).renameTo(new_part_path.toString());\n-}\n-\n-}\n-\n-int main(int argc, char ** argv)\n-try\n-{\n-    boost::program_options::options_description desc(\"Allowed options\");\n-    desc.add_options()\n-        (\"help,h\", \"produce help message\")\n-        (\"part\", boost::program_options::value<std::string>()->required(),\n-            \"part directory to convert\")\n-        (\"date-column\", boost::program_options::value<std::string>()->required(),\n-            \"name of the date column\")\n-        (\"to\", boost::program_options::value<std::string>()->required(),\n-            \"destination directory\")\n-    ;\n-\n-    boost::program_options::variables_map options;\n-    boost::program_options::store(boost::program_options::parse_command_line(argc, argv, desc), options);\n-\n-    if (options.count(\"help\") || options.size() < 3)\n-    {\n-        std::cout\n-            << \"Convert a MergeTree part from the old-style month-partitioned table \"\n-            << \"(e.g. 20140317_20140323_2_2_0) to the format suitable for ATTACH'ing to a custom-partitioned \"\n-            << \"table (201403_2_2_0).\" << std::endl << std::endl;\n-        std::cout << desc << std::endl;\n-        return 1;\n-    }\n-\n-    auto part_path = options.at(\"part\").as<DB::String>();\n-    auto date_column = options.at(\"date-column\").as<DB::String>();\n-    auto dest_path = options.at(\"to\").as<DB::String>();\n-\n-    DB::run(part_path, date_column, dest_path);\n-\n-    return 0;\n-}\n-catch (...)\n-{\n-    std::cerr << DB::getCurrentExceptionMessage(true) << '\\n';\n-    throw;\n-}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.reference b/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.reference\nnew file mode 100644\nindex 000000000000..858b670b9d93\n--- /dev/null\n+++ b/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.reference\n@@ -0,0 +1,3 @@\n+xyz\\rabc\n+Hello, world\n+End\ndiff --git a/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.sh b/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.sh\nnew file mode 100755\nindex 000000000000..1f6c040a34b2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.sh\n@@ -0,0 +1,8 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest, long\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+echo -ne 'xyz\\rabc\\nHello, world\\r\\nEnd' | ${CLICKHOUSE_LOCAL} --structure 's String' --input-format Regexp --format_regexp '(.*)' --query 'SELECT * FROM table'\n",
  "problem_statement": "Format `Regexp` is unusable\n```\r\nclickhouse-local \\\r\n    --format_regexp_escaping_rule 'Raw' \\\r\n    --format_regexp_skip_unmatched 1 \\\r\n    --format_regexp '^([^ \\.]+)(\\.[^ ]+)? +([^ ]+) +(\\d+) +(\\d+)$' \\\r\n    --query \"\r\nSELECT replaceRegexpOne(_path, '^.+pageviews-(\\\\d{4})(\\\\d{2})(\\\\d{2})-(\\\\d{2})(\\\\d{2})(\\\\d{2}).gz$', '\\1-\\2-\\3 \\4-\\5-\\6')::DateTime AS time, * \r\nFROM file('pageviews*.gz', Regexp, 'project String, subproject String, path String, hits UInt64, size UInt64')\"\r\n```\r\n\r\n```\r\nCode: 117. DB::Exception: No \\n after \\r at the end of line.: (at row 148660)\r\n: While executing ParallelParsingBlockInputFormat: While executing File. (INCORRECT_DATA)\r\n```\r\n\r\n```\r\nclickhouse-local \\\r\n    --format_regexp_escaping_rule 'Raw' \\\r\n    --format_regexp_skip_unmatched 1 \\\r\n    --format_regexp '^([^ \\.]+)(\\.[^ ]+)? +([^ ]+) +(\\d+) +(\\d+).*?$' \\\r\n    --query \"\r\nSELECT replaceRegexpOne(_path, '^.+pageviews-(\\\\d{4})(\\\\d{2})(\\\\d{2})-(\\\\d{2})(\\\\d{2})(\\\\d{2}).gz$', '\\1-\\2-\\3 \\4-\\5-\\6')::DateTime AS time, * \r\nFROM file('pageviews*.gz', Regexp, 'project String, subproject String, path String, hits UInt64, size UInt64')\"\r\n```\r\n\r\n```\r\nCode: 117. DB::Exception: No \\n after \\r at the end of line.: (at row 148660)\r\n: While executing ParallelParsingBlockInputFormat: While executing File. (INCORRECT_DATA)\r\n```\n",
  "hints_text": "",
  "created_at": "2022-01-31T23:50:55Z",
  "modified_files": [
    "src/Processors/Formats/Impl/RegexpRowInputFormat.cpp",
    "src/Processors/Formats/Impl/RegexpRowInputFormat.h",
    "utils/CMakeLists.txt",
    "utils/convert-month-partitioned-parts/CMakeLists.txt",
    "utils/convert-month-partitioned-parts/main.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.reference",
    "b/tests/queries/0_stateless/02190_format_regexp_cr_in_the_middle.sh"
  ]
}