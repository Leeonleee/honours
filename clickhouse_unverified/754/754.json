{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 754,
  "instance_id": "ClickHouse__ClickHouse-754",
  "issue_numbers": [
    "633"
  ],
  "base_commit": "312a0bf5f228501df61caca70d9a23bb29ff63f7",
  "patch": "diff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h b/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h\nindex 30d17f3cd0d8..92ba5da9f4ed 100644\n--- a/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h\n+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/Cipher.h\n@@ -96,7 +96,7 @@ class Crypto_API Cipher: public Poco::RefCountedObject\n \t\tENC_BASE64       = 0x01, /// Base64-encoded output\n \t\tENC_BINHEX       = 0x02, /// BinHex-encoded output\n \t\tENC_BASE64_NO_LF = 0x81, /// Base64-encoded output, no linefeeds\n-\t\tENC_BINHEX_NO_LF = 0x82, /// BinHex-encoded output, no linefeeds\n+\t\tENC_BINHEX_NO_LF = 0x82  /// BinHex-encoded output, no linefeeds\n \t\t\n \t};\n \ndiff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h b/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h\nindex 1ed50941da1e..fcfb20ec26f5 100644\n--- a/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h\n+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/Crypto.h\n@@ -22,7 +22,6 @@\n #define Crypto_Crypto_INCLUDED\n \n \n-#pragma GCC diagnostic push\n #if defined(__APPLE__)\n // OS X 10.7 deprecates some OpenSSL functions\n #pragma GCC diagnostic ignored \"-Wdeprecated-declarations\" \n@@ -116,6 +115,5 @@ void Crypto_API uninitializeCrypto();\n \n } } // namespace Poco::Crypto\n \n-#pragma GCC diagnostic pop\n \n #endif // Crypto_Crypto_INCLUDED\ndiff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h b/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h\nindex 5de75392a833..e2121c414dfd 100644\n--- a/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h\n+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/DigestEngine.h\n@@ -61,7 +61,7 @@ class Crypto_API DigestEngine: public Poco::DigestEngine\n \t\n private:\n \tstd::string _name;\n-\tEVP_MD_CTX* _ctx;\n+\tEVP_MD_CTX* _pContext;\n \tPoco::DigestEngine::Digest _digest;\n \tOpenSSLInitializer _openSSLInitializer;\n };\ndiff --git a/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h b/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h\nindex 472c537637ef..a6d86901248d 100644\n--- a/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h\n+++ b/contrib/libpoco/Crypto/include/Poco/Crypto/X509Certificate.h\n@@ -130,6 +130,14 @@ class Crypto_API X509Certificate\n \t\t/// Returns true if verification against the issuer certificate\n \t\t/// was successfull, false otherwise.\n \n+\tbool equals(const X509Certificate& otherCertificate) const;\n+\t\t/// Checks whether the certificate is equal to\n+\t\t/// the other certificate, by comparing the hashes\n+\t\t/// of both certificates.\n+\t\t///\n+\t\t/// Returns true if both certificates are identical,\n+\t\t/// otherwise false.\n+\n \tconst X509* certificate() const;\n \t\t/// Returns the underlying OpenSSL certificate.\n \ndiff --git a/contrib/libpoco/Crypto/src/CipherImpl.cpp b/contrib/libpoco/Crypto/src/CipherImpl.cpp\nindex c953aae52e2e..b8708a78c81d 100644\n--- a/contrib/libpoco/Crypto/src/CipherImpl.cpp\n+++ b/contrib/libpoco/Crypto/src/CipherImpl.cpp\n@@ -30,7 +30,7 @@ namespace\n \t{\n \t\tunsigned long err;\n \t\tstd::string msg;\n-\n+\t\t\n \t\twhile ((err = ERR_get_error()))\n \t\t{\n \t\t\tif (!msg.empty())\n@@ -60,24 +60,28 @@ namespace\n \t\t\tDirection         dir);\n \n \t\t~CryptoTransformImpl();\n-\n+\t\t\n \t\tstd::size_t blockSize() const;\n \n-\t\tint setPadding(int padding);\n+\t\tint setPadding(int padding);\t\n \n \t\tstd::streamsize transform(\n \t\t\tconst unsigned char* input,\n \t\t\tstd::streamsize      inputLength,\n \t\t\tunsigned char*       output,\n \t\t\tstd::streamsize      outputLength);\n-\n+\t\t\n \t\tstd::streamsize finalize(\n \t\t\tunsigned char*  output,\n \t\t\tstd::streamsize length);\n \n \tprivate:\n \t\tconst EVP_CIPHER* _pCipher;\n-\t\tEVP_CIPHER_CTX    _ctx;\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\tEVP_CIPHER_CTX*   _pContext;\n+#else\n+\t\tEVP_CIPHER_CTX    _context;\n+#endif\n \t\tByteVec           _key;\n \t\tByteVec           _iv;\n \t};\n@@ -92,32 +96,54 @@ namespace\n \t\t_key(key),\n \t\t_iv(iv)\n \t{\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\t_pContext = EVP_CIPHER_CTX_new();\n \t\tEVP_CipherInit(\n-\t\t\t&_ctx,\n+\t\t\t_pContext,\n \t\t\t_pCipher,\n \t\t\t&_key[0],\n \t\t\t_iv.empty() ? 0 : &_iv[0],\n \t\t\t(dir == DIR_ENCRYPT) ? 1 : 0);\n+#else\n+\t\tEVP_CipherInit(\n+\t\t\t&_context,\n+\t\t\t_pCipher,\n+\t\t\t&_key[0],\n+\t\t\t_iv.empty() ? 0 : &_iv[0],\n+\t\t\t(dir == DIR_ENCRYPT) ? 1 : 0);\n+#endif\n \t}\n \n \n \tCryptoTransformImpl::~CryptoTransformImpl()\n \t{\n-\t\tEVP_CIPHER_CTX_cleanup(&_ctx);\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\tEVP_CIPHER_CTX_cleanup(_pContext);\n+#else\n+\t\tEVP_CIPHER_CTX_cleanup(&_context);\n+#endif\n \t}\n \n \n \tstd::size_t CryptoTransformImpl::blockSize() const\n \t{\n-\t\treturn EVP_CIPHER_CTX_block_size(&_ctx);\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\treturn EVP_CIPHER_CTX_block_size(_pContext);\n+#else\n+\t\treturn EVP_CIPHER_CTX_block_size(&_context);\n+#endif\n \t}\n \n-\n+\t\n \tint CryptoTransformImpl::setPadding(int padding)\n \t{\n-\t\treturn EVP_CIPHER_CTX_set_padding(&_ctx, padding);\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\treturn EVP_CIPHER_CTX_block_size(_pContext);\n+#else\n+\t\treturn EVP_CIPHER_CTX_set_padding(&_context, padding);\n+#endif\n \t}\n-\n+\t\n \n \tstd::streamsize CryptoTransformImpl::transform(\n \t\tconst unsigned char* input,\n@@ -125,16 +151,24 @@ namespace\n \t\tunsigned char*       output,\n \t\tstd::streamsize      outputLength)\n \t{\n-\t\tpoco_assert (outputLength >= std::streamsize(inputLength + blockSize() - 1));\n+\t\tpoco_assert (outputLength >= (inputLength + blockSize() - 1));\n \n \t\tint outLen = static_cast<int>(outputLength);\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n \t\tint rc = EVP_CipherUpdate(\n-\t\t\t&_ctx,\n+\t\t\t_pContext,\n \t\t\toutput,\n \t\t\t&outLen,\n \t\t\tinput,\n \t\t\tstatic_cast<int>(inputLength));\n-\n+#else\n+\t\tint rc = EVP_CipherUpdate(\n+\t\t\t&_context,\n+\t\t\toutput,\n+\t\t\t&outLen,\n+\t\t\tinput,\n+\t\t\tstatic_cast<int>(inputLength));\n+#endif\n \t\tif (rc == 0)\n \t\t\tthrowError();\n \n@@ -146,18 +180,22 @@ namespace\n \t\tunsigned char*\toutput,\n \t\tstd::streamsize length)\n \t{\n-\t\tpoco_assert (length >= (std::streamsize)blockSize());\n-\n+\t\tpoco_assert (length >= blockSize());\n+\t\t\n \t\tint len = static_cast<int>(length);\n \n \t\t// Use the '_ex' version that does not perform implicit cleanup since we\n \t\t// will call EVP_CIPHER_CTX_cleanup() from the dtor as there is no\n \t\t// guarantee that finalize() will be called if an error occurred.\n-\t\tint rc = EVP_CipherFinal_ex(&_ctx, output, &len);\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\tint rc = EVP_CipherFinal_ex(_pContext, output, &len);\n+#else\n+\t\tint rc = EVP_CipherFinal_ex(&_context, output, &len);\n+#endif\n \n \t\tif (rc == 0)\n \t\t\tthrowError();\n-\n+\t\t\t\n \t\treturn static_cast<std::streamsize>(len);\n \t}\n }\ndiff --git a/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp b/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp\nindex 58b51c9424dc..bcd7452c696f 100644\n--- a/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp\n+++ b/contrib/libpoco/Crypto/src/CipherKeyImpl.cpp\n@@ -27,8 +27,8 @@ namespace Poco {\n namespace Crypto {\n \n \n-CipherKeyImpl::CipherKeyImpl(const std::string& name,\n-\tconst std::string& passphrase,\n+CipherKeyImpl::CipherKeyImpl(const std::string& name, \n+\tconst std::string& passphrase, \n \tconst std::string& salt,\n \tint iterationCount):\n \t_pCipher(0),\n@@ -48,8 +48,8 @@ CipherKeyImpl::CipherKeyImpl(const std::string& name,\n }\n \n \n-CipherKeyImpl::CipherKeyImpl(const std::string& name,\n-\tconst ByteVec& key,\n+CipherKeyImpl::CipherKeyImpl(const std::string& name, \n+\tconst ByteVec& key, \n \tconst ByteVec& iv):\n \t_pCipher(0),\n \t_name(name),\n@@ -64,7 +64,7 @@ CipherKeyImpl::CipherKeyImpl(const std::string& name,\n \t\tthrow Poco::NotFoundException(\"Cipher \" + name + \" was not found\");\n }\n \n-\n+\t\n CipherKeyImpl::CipherKeyImpl(const std::string& name):\n \t_pCipher(0),\n \t_name(name),\n@@ -117,7 +117,7 @@ void CipherKeyImpl::generateKey()\n \n \tgetRandomBytes(vec, keySize());\n \tsetKey(vec);\n-\n+\t\n \tgetRandomBytes(vec, ivSize());\n \tsetIV(vec);\n }\n@@ -126,11 +126,11 @@ void CipherKeyImpl::generateKey()\n void CipherKeyImpl::getRandomBytes(ByteVec& vec, std::size_t count)\n {\n \tPoco::RandomInputStream random;\n-\n+\t\n \tvec.clear();\n \tvec.reserve(count);\n \n-\tfor (std::size_t i = 0; i < count; ++i)\n+\tfor (int i = 0; i < count; ++i)\n \t\tvec.push_back(static_cast<unsigned char>(random.get()));\n }\n \ndiff --git a/contrib/libpoco/Crypto/src/CryptoStream.cpp b/contrib/libpoco/Crypto/src/CryptoStream.cpp\nindex 34ce13b4c397..97e73ce810f0 100644\n--- a/contrib/libpoco/Crypto/src/CryptoStream.cpp\n+++ b/contrib/libpoco/Crypto/src/CryptoStream.cpp\n@@ -43,7 +43,7 @@ CryptoStreamBuf::CryptoStreamBuf(std::istream& istr, CryptoTransform* pTransform\n \t_buffer(static_cast<std::size_t>(bufferSize))\n {\n \tpoco_check_ptr (pTransform);\n-\tpoco_assert ((size_t)bufferSize > 2 * pTransform->blockSize());\n+\tpoco_assert (bufferSize > 2 * pTransform->blockSize());\n }\n \n \n@@ -56,7 +56,7 @@ CryptoStreamBuf::CryptoStreamBuf(std::ostream& ostr, CryptoTransform* pTransform\n \t_buffer(static_cast<std::size_t>(bufferSize))\n {\n \tpoco_check_ptr (pTransform);\n-\tpoco_assert ((size_t)bufferSize > 2 * pTransform->blockSize());\n+\tpoco_assert (bufferSize > 2 * pTransform->blockSize());\n }\n \n \n@@ -88,10 +88,10 @@ void CryptoStreamBuf::close()\n \t\t// thrown.\n \t\tstd::ostream* pOstr = _pOstr;\n \t\t_pOstr = 0;\n-\n+\t\t\n \t\t// Finalize transformation.\n \t\tstd::streamsize n = _pTransform->finalize(_buffer.begin(), static_cast<std::streamsize>(_buffer.size()));\n-\n+\t\t\n \t\tif (n > 0)\n \t\t{\n \t\t\tpOstr->write(reinterpret_cast<char*>(_buffer.begin()), n);\n@@ -159,7 +159,7 @@ int CryptoStreamBuf::writeToDevice(const char* buffer, std::streamsize length)\n \tstd::size_t maxChunkSize = _buffer.size()/2;\n \tstd::size_t count = 0;\n \n-\twhile (count < (size_t)length)\n+\twhile (count < length)\n \t{\n \t\t// Truncate chunk size so that the maximum output fits into _buffer.\n \t\tstd::size_t n = static_cast<std::size_t>(length) - count;\ndiff --git a/contrib/libpoco/Crypto/src/DigestEngine.cpp b/contrib/libpoco/Crypto/src/DigestEngine.cpp\nindex 6e574ab42e11..64042589f172 100644\n--- a/contrib/libpoco/Crypto/src/DigestEngine.cpp\n+++ b/contrib/libpoco/Crypto/src/DigestEngine.cpp\n@@ -23,46 +23,51 @@ namespace Crypto {\n \n \n DigestEngine::DigestEngine(const std::string& name):\n-\t_name(name)\n+\t_name(name),\n+\t_pContext(EVP_MD_CTX_create())\n {\n \tconst EVP_MD* md = EVP_get_digestbyname(_name.c_str());\n \tif (!md) throw Poco::NotFoundException(_name);\n-\t_ctx = EVP_MD_CTX_create();\n-\tEVP_DigestInit_ex(_ctx, md, NULL);\t\n+\tEVP_DigestInit_ex(_pContext, md, NULL);\t\n }\n \n \t\n DigestEngine::~DigestEngine()\n {\n-\tEVP_MD_CTX_destroy(_ctx);\n+\tEVP_MD_CTX_destroy(_pContext);\n }\n \n int DigestEngine::nid() const\n {\n-\treturn EVP_MD_nid(_ctx->digest);\n+\treturn EVP_MD_nid(EVP_MD_CTX_md(_pContext));\n }\n \n std::size_t DigestEngine::digestLength() const\n {\n-\treturn EVP_MD_CTX_size(_ctx);\n+\treturn EVP_MD_CTX_size(_pContext);\n }\n \n \n void DigestEngine::reset()\n {\n-\tEVP_MD_CTX_cleanup(_ctx);\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\tEVP_MD_CTX_free(_pContext);\n+\t_pContext = EVP_MD_CTX_create();\n+#else\n+\tEVP_MD_CTX_cleanup(_pContext);\n+#endif\n \tconst EVP_MD* md = EVP_get_digestbyname(_name.c_str());\n \tif (!md) throw Poco::NotFoundException(_name);\n-\tEVP_DigestInit_ex(_ctx, md, NULL);\n+\tEVP_DigestInit_ex(_pContext, md, NULL);\n }\n \n \n const Poco::DigestEngine::Digest& DigestEngine::digest()\n {\n \t_digest.clear();\n-\tunsigned len = EVP_MD_CTX_size(_ctx);\n+\tunsigned len = EVP_MD_CTX_size(_pContext);\n \t_digest.resize(len);\n-\tEVP_DigestFinal_ex(_ctx, &_digest[0], &len);\n+\tEVP_DigestFinal_ex(_pContext, &_digest[0], &len);\n \treset();\n \treturn _digest;\n }\n@@ -70,7 +75,7 @@ const Poco::DigestEngine::Digest& DigestEngine::digest()\n \n void DigestEngine::updateImpl(const void* data, std::size_t length)\n {\n-\tEVP_DigestUpdate(_ctx, data, length);\n+\tEVP_DigestUpdate(_pContext, data, length);\n }\n \n \ndiff --git a/contrib/libpoco/Crypto/src/RSACipherImpl.cpp b/contrib/libpoco/Crypto/src/RSACipherImpl.cpp\nindex 01b238512825..91c5b815d618 100644\n--- a/contrib/libpoco/Crypto/src/RSACipherImpl.cpp\n+++ b/contrib/libpoco/Crypto/src/RSACipherImpl.cpp\n@@ -32,7 +32,7 @@ namespace\n \t{\n \t\tunsigned long err;\n \t\tstd::string msg;\n-\n+\t\t\n \t\twhile ((err = ERR_get_error()))\n \t\t{\n \t\t\tif (!msg.empty())\n@@ -68,7 +68,7 @@ namespace\n \tpublic:\n \t\tRSAEncryptImpl(const RSA* pRSA, RSAPaddingMode paddingMode);\n \t\t~RSAEncryptImpl();\n-\n+\t\t\n \t\tstd::size_t blockSize() const;\n \t\tstd::size_t maxDataSize() const;\n \n@@ -77,7 +77,7 @@ namespace\n \t\t\tstd::streamsize\t\t inputLength,\n \t\t\tunsigned char*\t\t output,\n \t\t\tstd::streamsize\t\t outputLength);\n-\n+\t\t\n \t\tstd::streamsize finalize(unsigned char*\toutput, std::streamsize length);\n \n \tprivate:\n@@ -156,7 +156,7 @@ namespace\n \t\t\t\toutput += n;\n \t\t\t\toutputLength -= n;\n \t\t\t\t_pos = 0;\n-\n+\t\t\t\t\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -175,8 +175,8 @@ namespace\n \n \tstd::streamsize RSAEncryptImpl::finalize(unsigned char*\toutput, std::streamsize length)\n \t{\n-\t\tpoco_assert ((size_t)length >= blockSize());\n-\t\tpoco_assert ((size_t)_pos <= maxDataSize());\n+\t\tpoco_assert (length >= blockSize());\n+\t\tpoco_assert (_pos <= maxDataSize());\n \t\tint rc = 0;\n \t\tif (_pos > 0)\n \t\t{\n@@ -192,7 +192,7 @@ namespace\n \tpublic:\n \t\tRSADecryptImpl(const RSA* pRSA, RSAPaddingMode paddingMode);\n \t\t~RSADecryptImpl();\n-\n+\t\t\n \t\tstd::size_t blockSize() const;\n \n \t\tstd::streamsize transform(\n@@ -200,7 +200,7 @@ namespace\n \t\t\tstd::streamsize\t\t inputLength,\n \t\t\tunsigned char*\t\t output,\n \t\t\tstd::streamsize\t\t outputLength);\n-\n+\t\t\n \t\tstd::streamsize finalize(\n \t\t\tunsigned char*\toutput,\n \t\t\tstd::streamsize length);\n@@ -241,7 +241,7 @@ namespace\n \t\tunsigned char*\t\t output,\n \t\tstd::streamsize\t\t outputLength)\n \t{\n-\n+\t\t\n \t\t// always fill up the buffer before decrypting!\n \t\tstd::streamsize rsaSize = static_cast<std::streamsize>(blockSize());\n \t\tpoco_assert_dbg(_pos <= rsaSize);\n@@ -261,7 +261,7 @@ namespace\n \t\t\t\toutput += tmp;\n \t\t\t\toutputLength -= tmp;\n \t\t\t\t_pos = 0;\n-\n+\t\t\t\t\n \t\t\t}\n \t\t\telse\n \t\t\t{\n@@ -280,7 +280,7 @@ namespace\n \n \tstd::streamsize RSADecryptImpl::finalize(unsigned char*\toutput, std::streamsize length)\n \t{\n-\t\tpoco_assert ((size_t)length >= blockSize());\n+\t\tpoco_assert (length >= blockSize());\n \t\tint rc = 0;\n \t\tif (_pos > 0)\n \t\t{\ndiff --git a/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp b/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp\nindex 8333453cee02..3a1580f69124 100644\n--- a/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp\n+++ b/contrib/libpoco/Crypto/src/RSAKeyImpl.cpp\n@@ -207,19 +207,43 @@ int RSAKeyImpl::size() const\n \n RSAKeyImpl::ByteVec RSAKeyImpl::modulus() const\n {\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\tconst BIGNUM* n = 0;\n+\tconst BIGNUM* e = 0;\n+\tconst BIGNUM* d = 0;\n+\tRSA_get0_key(_pRSA, &n, &e, &d);\n+\treturn convertToByteVec(n);\n+#else\n \treturn convertToByteVec(_pRSA->n);\n+#endif\n }\n \n \n RSAKeyImpl::ByteVec RSAKeyImpl::encryptionExponent() const\n {\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\tconst BIGNUM* n = 0;\n+\tconst BIGNUM* e = 0;\n+\tconst BIGNUM* d = 0;\n+\tRSA_get0_key(_pRSA, &n, &e, &d);\n+\treturn convertToByteVec(e);\n+#else\n \treturn convertToByteVec(_pRSA->e);\n+#endif\n }\n \n \n RSAKeyImpl::ByteVec RSAKeyImpl::decryptionExponent() const\n {\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\tconst BIGNUM* n = 0;\n+\tconst BIGNUM* e = 0;\n+\tconst BIGNUM* d = 0;\n+\tRSA_get0_key(_pRSA, &n, &e, &d);\n+\treturn convertToByteVec(d);\n+#else\n \treturn convertToByteVec(_pRSA->d);\n+#endif\n }\n \n \ndiff --git a/contrib/libpoco/Crypto/src/X509Certificate.cpp b/contrib/libpoco/Crypto/src/X509Certificate.cpp\nindex dd9ebd2cab36..f7f37965ed83 100644\n--- a/contrib/libpoco/Crypto/src/X509Certificate.cpp\n+++ b/contrib/libpoco/Crypto/src/X509Certificate.cpp\n@@ -59,7 +59,11 @@ X509Certificate::X509Certificate(X509* pCert, bool shared):\n \t\n \tif (shared)\n \t{\n+#if OPENSSL_VERSION_NUMBER >= 0x10100000L\n+\t\tX509_up_ref(_pCert);\n+#else\n \t\t_pCert->references++;\n+#endif\n \t}\n \n \tinit();\n@@ -205,10 +209,10 @@ std::string X509Certificate::issuerName(NID nid) const\n \tif (X509_NAME* issuer = X509_get_issuer_name(_pCert))\n     {\n \t\tchar buffer[NAME_BUFFER_SIZE];\n-\t\tX509_NAME_get_text_by_NID(issuer, nid, buffer, sizeof(buffer));\n-\t\treturn std::string(buffer);\n+\t\tif (X509_NAME_get_text_by_NID(issuer, nid, buffer, sizeof(buffer)) >= 0)\n+\t\t\treturn std::string(buffer);\n     }\n-    else return std::string();\n+    return std::string();\n }\n \n \n@@ -217,10 +221,10 @@ std::string X509Certificate::subjectName(NID nid) const\n \tif (X509_NAME* subj = X509_get_subject_name(_pCert))\n     {\n \t\tchar buffer[NAME_BUFFER_SIZE];\n-\t\tX509_NAME_get_text_by_NID(subj, nid, buffer, sizeof(buffer));\n-\t\treturn std::string(buffer);\n+\t\tif (X509_NAME_get_text_by_NID(subj, nid, buffer, sizeof(buffer)) >= 0)\n+\t\t\treturn std::string(buffer);\n     }\n-    else return std::string();\n+    return std::string();\n }\n \n \n@@ -280,4 +284,12 @@ bool X509Certificate::issuedBy(const X509Certificate& issuerCertificate) const\n }\n \n \n+bool X509Certificate::equals(const X509Certificate& otherCertificate) const\n+{\n+\tX509* pCert = const_cast<X509*>(_pCert);\n+\tX509* pOtherCert = const_cast<X509*>(otherCertificate.certificate());\n+\treturn X509_cmp(pCert, pOtherCert) == 0;\n+}\n+\n+\n } } // namespace Poco::Crypto\ndiff --git a/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp b/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp\nindex 6a1e922a8a47..a4325c45e7e2 100644\n--- a/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp\n+++ b/dbms/src/AggregateFunctions/AggregateFunctionFactory.cpp\n@@ -46,6 +46,7 @@ void registerAggregateFunctionsStatistics(AggregateFunctionFactory & factory);\n void registerAggregateFunctionSum(AggregateFunctionFactory & factory);\n void registerAggregateFunctionsUniq(AggregateFunctionFactory & factory);\n void registerAggregateFunctionUniqUpTo(AggregateFunctionFactory & factory);\n+void registerAggregateFunctionTopK(AggregateFunctionFactory & factory);\n void registerAggregateFunctionDebug(AggregateFunctionFactory & factory);\n \n AggregateFunctionPtr createAggregateFunctionArray(AggregateFunctionPtr & nested);\n@@ -76,6 +77,7 @@ AggregateFunctionFactory::AggregateFunctionFactory()\n     registerAggregateFunctionSum(*this);\n     registerAggregateFunctionsUniq(*this);\n     registerAggregateFunctionUniqUpTo(*this);\n+    registerAggregateFunctionTopK(*this);\n     registerAggregateFunctionDebug(*this);\n }\n \ndiff --git a/dbms/src/AggregateFunctions/AggregateFunctionTopK.cpp b/dbms/src/AggregateFunctions/AggregateFunctionTopK.cpp\nnew file mode 100644\nindex 000000000000..3310691a8ab4\n--- /dev/null\n+++ b/dbms/src/AggregateFunctions/AggregateFunctionTopK.cpp\n@@ -0,0 +1,70 @@\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <AggregateFunctions/AggregateFunctionTopK.h>\n+#include <AggregateFunctions/Helpers.h>\n+\n+namespace DB\n+{\n+\n+namespace\n+{\n+\n+/// Substitute return type for Date and DateTime\n+class AggregateFunctionTopKDate : public AggregateFunctionTopK<DataTypeDate::FieldType>\n+{\n+    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDate>()); }\n+};\n+\n+class AggregateFunctionTopKDateTime : public AggregateFunctionTopK<DataTypeDateTime::FieldType>\n+{\n+    DataTypePtr getReturnType() const override { return std::make_shared<DataTypeArray>(std::make_shared<DataTypeDateTime>()); }\n+};\n+\n+\n+static IAggregateFunction * createWithExtraTypes(const IDataType & argument_type)\n+{\n+         if (typeid_cast<const DataTypeDate *>(&argument_type))     return new AggregateFunctionTopKDate;\n+    else if (typeid_cast<const DataTypeDateTime *>(&argument_type))    return new AggregateFunctionTopKDateTime;\n+    else\n+    {\n+        /// Check that we can use plain version of AggregateFunctionTopKGeneric\n+        if (typeid_cast<const DataTypeString*>(&argument_type) || typeid_cast<const DataTypeFixedString*>(&argument_type))\n+            return new AggregateFunctionTopKGeneric<true>;\n+\n+        auto * array_type = typeid_cast<const DataTypeArray *>(&argument_type);\n+        if (array_type)\n+        {\n+            auto nested_type = array_type->getNestedType();\n+            if (nested_type->isNumeric() || typeid_cast<DataTypeFixedString *>(nested_type.get()))\n+                return new AggregateFunctionTopKGeneric<true>;\n+        }\n+\n+        return new AggregateFunctionTopKGeneric<false>;\n+    }\n+}\n+\n+AggregateFunctionPtr createAggregateFunctionTopK(const std::string & name, const DataTypes & argument_types)\n+{\n+    if (argument_types.size() != 1)\n+        throw Exception(\"Incorrect number of arguments for aggregate function \" + name,\n+            ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+    AggregateFunctionPtr res(createWithNumericType<AggregateFunctionTopK>(*argument_types[0]));\n+\n+    if (!res)\n+        res = AggregateFunctionPtr(createWithExtraTypes(*argument_types[0]));\n+\n+    if (!res)\n+        throw Exception(\"Illegal type \" + argument_types[0]->getName() +\n+            \" of argument for aggregate function \" + name, ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT);\n+\n+    return res;\n+}\n+\n+}\n+\n+void registerAggregateFunctionTopK(AggregateFunctionFactory & factory)\n+{\n+    factory.registerFunction(\"topK\", createAggregateFunctionTopK);\n+}\n+\n+}\ndiff --git a/dbms/src/AggregateFunctions/AggregateFunctionTopK.h b/dbms/src/AggregateFunctions/AggregateFunctionTopK.h\nnew file mode 100644\nindex 000000000000..b93780d127e2\n--- /dev/null\n+++ b/dbms/src/AggregateFunctions/AggregateFunctionTopK.h\n@@ -0,0 +1,264 @@\n+#pragma once\n+\n+#include <IO/WriteHelpers.h>\n+#include <IO/ReadHelpers.h>\n+\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeString.h>\n+\n+#include <Columns/ColumnArray.h>\n+\n+#include <Common/SpaceSaving.h>\n+\n+#include <Core/FieldVisitors.h>\n+\n+#include <AggregateFunctions/AggregateFunctionGroupArray.h>\n+\n+\n+namespace DB\n+{\n+\n+\n+// Allow NxK more space before calculating top K to increase accuracy\n+#define TOP_K_LOAD_FACTOR 3\n+#define TOP_K_MAX_SIZE 0xFFFFFF\n+\n+\n+template <typename T>\n+struct AggregateFunctionTopKData\n+{\n+    using Set = SpaceSaving<T, DefaultHash<T>>;\n+    Set value;\n+};\n+\n+\n+template <typename T>\n+class AggregateFunctionTopK\n+    : public IUnaryAggregateFunction<AggregateFunctionTopKData<T>, AggregateFunctionTopK<T>>\n+{\n+private:\n+    using State = AggregateFunctionTopKData<T>;\n+    size_t threshold = 10; // Default value if the parameter is not specified.\n+    size_t reserved = TOP_K_LOAD_FACTOR * threshold;\n+\n+public:\n+    String getName() const override { return \"topK\"; }\n+\n+    DataTypePtr getReturnType() const override\n+    {\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeNumber<T>>());\n+    }\n+\n+    void setArgument(const DataTypePtr & argument)\n+    {\n+    }\n+\n+    void setParameters(const Array & params) override\n+    {\n+        if (params.size() != 1)\n+            throw Exception(\"Aggregate function \" + getName() + \" requires exactly one parameter.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        std::size_t k = applyVisitor(FieldVisitorConvertToNumber<size_t>(), params[0]);\n+\n+        if (k > TOP_K_MAX_SIZE)\n+            throw Exception(\"Too large parameter for aggregate function \" + getName() + \". Maximum: \" + toString(TOP_K_MAX_SIZE),\n+                ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+\n+        threshold = k;\n+        reserved = TOP_K_LOAD_FACTOR * k;\n+    }\n+\n+    void addImpl(AggregateDataPtr place, const IColumn & column, size_t row_num, Arena *) const\n+    {\n+        auto & set = this->data(place).value;\n+        if (set.capacity() != reserved) {\n+            set.resize(reserved);\n+        }\n+        set.insert(static_cast<const ColumnVector<T> &>(column).getData()[row_num]);\n+    }\n+\n+    void merge(AggregateDataPtr place, ConstAggregateDataPtr rhs, Arena * arena) const override\n+    {\n+        this->data(place).value.merge(this->data(rhs).value);\n+    }\n+\n+    void serialize(ConstAggregateDataPtr place, WriteBuffer & buf) const override\n+    {\n+        this->data(place).value.write(buf);\n+    }\n+\n+    void deserialize(AggregateDataPtr place, ReadBuffer & buf, Arena *) const override\n+    {\n+        auto & set = this->data(place).value;\n+        set.resize(reserved);\n+        set.read(buf);\n+    }\n+\n+    void insertResultInto(ConstAggregateDataPtr place, IColumn & to) const override\n+    {\n+        ColumnArray & arr_to = static_cast<ColumnArray &>(to);\n+        ColumnArray::Offsets_t & offsets_to = arr_to.getOffsets();\n+\n+        const typename State::Set & set = this->data(place).value;\n+        auto resultVec = set.topK(threshold);\n+        size_t size = resultVec.size();\n+\n+        offsets_to.push_back((offsets_to.size() == 0 ? 0 : offsets_to.back()) + size);\n+\n+        typename ColumnVector<T>::Container_t & data_to = static_cast<ColumnVector<T> &>(arr_to.getData()).getData();\n+        size_t old_size = data_to.size();\n+        data_to.resize(old_size + size);\n+\n+        size_t i = 0;\n+        for (auto it = resultVec.begin(); it != resultVec.end(); ++it, ++i)\n+            data_to[old_size + i] = it->key;\n+    }\n+};\n+\n+\n+/// Generic implementation, it uses serialized representation as object descriptor.\n+struct AggregateFunctionTopKGenericData\n+{\n+    using Set = SpaceSaving<StringRef, StringRefHash>;\n+\n+    Set value;\n+};\n+\n+/** Template parameter with true value should be used for columns that store their elements in memory continuously.\n+ *  For such columns topK() can be implemented more efficently (especially for small numeric arrays).\n+ */\n+template <bool is_plain_column = false>\n+class AggregateFunctionTopKGeneric : public IUnaryAggregateFunction<AggregateFunctionTopKGenericData, AggregateFunctionTopKGeneric<is_plain_column>>\n+{\n+private:\n+    using State = AggregateFunctionTopKGenericData;\n+    DataTypePtr input_data_type;\n+    size_t threshold = 10; // Default value if the parameter is not specified.\n+    size_t reserved = TOP_K_LOAD_FACTOR * threshold;\n+\n+    static StringRef getSerialization(const IColumn & column, size_t row_num, Arena & arena);\n+    static void deserializeAndInsert(StringRef str, IColumn & data_to);\n+\n+public:\n+    String getName() const override { return \"topK\"; }\n+\n+    void setArgument(const DataTypePtr & argument)\n+    {\n+        input_data_type = argument;\n+    }\n+\n+    void setParameters(const Array & params) override\n+    {\n+        if (params.size() != 1)\n+            throw Exception(\"Aggregate function \" + getName() + \" requires exactly one parameter.\", ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n+\n+        size_t k = applyVisitor(FieldVisitorConvertToNumber<size_t>(), params[0]);\n+\n+        if (k > TOP_K_MAX_SIZE)\n+            throw Exception(\"Too large parameter for aggregate function \" + getName() + \". Maximum: \" + toString(TOP_K_MAX_SIZE),\n+                ErrorCodes::ARGUMENT_OUT_OF_BOUND);\n+\n+        threshold = k;\n+        reserved = TOP_K_LOAD_FACTOR * k;\n+    }\n+\n+    DataTypePtr getReturnType() const override\n+    {\n+        return std::make_shared<DataTypeArray>(input_data_type->clone());\n+    }\n+\n+    bool allocatesMemoryInArena() const override\n+    {\n+        return true;\n+    }\n+\n+    void serialize(ConstAggregateDataPtr place, WriteBuffer & buf) const override\n+    {\n+        this->data(place).value.write(buf);\n+    }\n+\n+    void deserialize(AggregateDataPtr place, ReadBuffer & buf, Arena * arena) const override\n+    {\n+        auto & set = this->data(place).value;\n+        set.resize(reserved);\n+\n+        size_t count = 0;\n+        readVarUInt(count, buf);\n+        for (size_t i = 0; i < count; ++i) {\n+            auto key = readStringBinaryInto(*arena, buf);\n+            UInt64 count, error;\n+            readVarUInt(count, buf);\n+            readVarUInt(error, buf);\n+            set.insert(key, count, error);\n+        }\n+    }\n+\n+    void addImpl(AggregateDataPtr place, const IColumn & column, size_t row_num, Arena * arena) const\n+    {\n+        auto & set = this->data(place).value;\n+        if (set.capacity() != reserved) {\n+            set.resize(reserved);\n+        }\n+\n+        StringRef str_serialized = getSerialization(column, row_num, *arena);\n+        if (is_plain_column) {\n+            auto ptr = arena->insert(str_serialized.data, str_serialized.size);\n+            str_serialized = StringRef(ptr, str_serialized.size);\n+        }\n+\n+        set.insert(str_serialized);\n+    }\n+\n+    void merge(AggregateDataPtr place, ConstAggregateDataPtr rhs, Arena * arena) const override\n+    {\n+        this->data(place).value.merge(this->data(rhs).value);\n+    }\n+\n+    void insertResultInto(ConstAggregateDataPtr place, IColumn & to) const override\n+    {\n+        ColumnArray & arr_to = static_cast<ColumnArray &>(to);\n+        ColumnArray::Offsets_t & offsets_to = arr_to.getOffsets();\n+        IColumn & data_to = arr_to.getData();\n+\n+        auto resultVec = this->data(place).value.topK(threshold);\n+        offsets_to.push_back((offsets_to.size() == 0 ? 0 : offsets_to.back()) + resultVec.size());\n+\n+        for (auto & elem : resultVec)\n+        {\n+            deserializeAndInsert(elem.key, data_to);\n+        }\n+    }\n+};\n+\n+\n+template <>\n+inline StringRef AggregateFunctionTopKGeneric<false>::getSerialization(const IColumn & column, size_t row_num, Arena & arena)\n+{\n+    const char * begin = nullptr;\n+    return column.serializeValueIntoArena(row_num, arena, begin);\n+}\n+\n+template <>\n+inline StringRef AggregateFunctionTopKGeneric<true>::getSerialization(const IColumn & column, size_t row_num, Arena &)\n+{\n+    return column.getDataAt(row_num);\n+}\n+\n+template <>\n+inline void AggregateFunctionTopKGeneric<false>::deserializeAndInsert(StringRef str, IColumn & data_to)\n+{\n+    data_to.deserializeAndInsertFromArena(str.data);\n+}\n+\n+template <>\n+inline void AggregateFunctionTopKGeneric<true>::deserializeAndInsert(StringRef str, IColumn & data_to)\n+{\n+    data_to.insertData(str.data, str.size);\n+}\n+\n+\n+#undef TOP_K_MAX_SIZE\n+#undef TOP_K_LOAD_FACTOR\n+\n+}\ndiff --git a/dbms/src/Common/SpaceSaving.h b/dbms/src/Common/SpaceSaving.h\nnew file mode 100644\nindex 000000000000..4f11ebc3bbe8\n--- /dev/null\n+++ b/dbms/src/Common/SpaceSaving.h\n@@ -0,0 +1,254 @@\n+#pragma once\n+\n+#include <iostream>\n+#include <list>\n+#include <vector>\n+\n+#include <boost/range/adaptor/reversed.hpp>\n+\n+#include <Common/UInt128.h>\n+#include <Common/HashTable/Hash.h>\n+#include <Common/HashTable/HashMap.h>\n+\n+#include <IO/WriteBuffer.h>\n+#include <IO/WriteHelpers.h>\n+#include <IO/ReadBuffer.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/VarInt.h>\n+\n+/*\n+ * Implementation of the Filtered Space-Saving for TopK streaming analysis.\n+ *   http://www.l2f.inesc-id.pt/~fmmb/wiki/uploads/Work/misnis.ref0a.pdf\n+ * It implements suggested reduce-and-combine algorithm from Parallel Space Saving:\n+ *   https://arxiv.org/pdf/1401.0702.pdf\n+ */\n+\n+namespace DB\n+{\n+\n+template <typename TKey, typename Hash = DefaultHash<TKey>>\n+class SpaceSaving\n+{\n+public:\n+    struct Counter {\n+        Counter() {}\n+\n+        Counter(const TKey & k, UInt64 c = 0, UInt64 e = 0)\n+          : key(k), slot(0), count(c), error(e) {}\n+\n+        void write(DB::WriteBuffer & wb) const\n+        {\n+              DB::writeBinary(key, wb);\n+              DB::writeVarUInt(count, wb);\n+              DB::writeVarUInt(error, wb);\n+        }\n+\n+        void read(DB::ReadBuffer & rb)\n+        {\n+            DB::readBinary(key, rb);\n+            DB::readVarUInt(count, rb);\n+            DB::readVarUInt(error, rb);\n+        }\n+\n+        // greater() taking slot error into account\n+        bool operator >(const Counter &b) const\n+        {\n+            return (count > b.count) || (count == b.count && error < b.error);\n+        }\n+\n+        TKey key;\n+        size_t slot;\n+        UInt64 count, error;\n+    };\n+\n+    // Suggested constants in the paper \"Finding top-k elements in data streams\", chap 6. equation (24)\n+    SpaceSaving(size_t c = 10) : counterMap(), counterList(), alphaMap(6 * c), cap(c) {}\n+    ~SpaceSaving() { destroyElements(); }\n+\n+    inline size_t size() const\n+    {\n+        return counterList.size();\n+    }\n+\n+    inline size_t capacity() const\n+    {\n+        return cap;\n+    }\n+\n+    void resize(size_t c)\n+    {\n+        counterList.reserve(c);\n+        alphaMap.resize(c * 6);\n+        cap = c;\n+    }\n+\n+    Counter * insert(const TKey & key, UInt64 increment = 1, UInt64 error = 0)\n+    {\n+        // Increase weight of a key that already exists\n+        // It uses hashtable for both value mapping as a presence test (c_i != 0)\n+        auto hash = counterMap.hash(key);\n+        auto it = counterMap.find(key, hash);\n+        if (it != counterMap.end()) {\n+            auto c = it->second;\n+            c->count += increment;\n+            c->error += error;\n+            percolate(c);\n+            return c;\n+        }\n+\n+        // Key doesn't exist, but can fit in the top K\n+        if (size() < capacity()) {\n+            auto c = new Counter(key, increment, error);\n+            push(c);\n+            return c;\n+        }\n+\n+        auto min = counterList.back();\n+        auto & alpha = alphaMap[hash % alphaMap.size()];\n+        if (alpha + increment < min->count) {\n+            alpha += increment;\n+            return nullptr;\n+        }\n+\n+        // Erase the current minimum element\n+        auto minHash = counterMap.hash(min->key);\n+        it = counterMap.find(min->key, minHash);\n+        if (it != counterMap.end()) {\n+            auto cell = it.getPtr();\n+            cell->setZero();\n+        }\n+\n+        // Replace minimum with newly inserted element\n+        bool inserted = false;\n+        counterMap.emplace(key, it, inserted, hash);\n+        if (inserted) {\n+            alphaMap[minHash % alphaMap.size()] = min->count;\n+            min->key = key;\n+            min->count = alpha + increment;\n+            min->error = alpha + error;\n+            it->second = min;\n+            percolate(min);\n+        }\n+\n+        return min;\n+    }\n+\n+    /*\n+     * Parallel Space Saving reduction and combine step from:\n+     *  https://arxiv.org/pdf/1401.0702.pdf\n+     */\n+    void merge(const SpaceSaving<TKey, Hash> & rhs)\n+    {\n+        UInt64 m1 = 0, m2 = 0;\n+        if (size() == capacity()) {\n+            m1 = counterList.back()->count;\n+        }\n+        if (rhs.size() == rhs.capacity()) {\n+            m2 = rhs.counterList.back()->count;\n+        }\n+\n+        /*\n+         * Updated algorithm to mutate current table in place\n+         * without mutating rhs table or creating new one\n+         * in the first step we expect that no elements overlap\n+         * and in the second sweep we correct the error if they do.\n+         */\n+        if (m2 > 0) {\n+            for (auto c : counterList) {\n+                c->count += m2;\n+                c->error += m2;\n+            }\n+        }\n+\n+        // The list is sorted in descending order, we have to scan in reverse\n+        for (auto c : boost::adaptors::reverse(rhs.counterList)) {\n+            if (counterMap.find(c->key) != counterMap.end()) {\n+                // Subtract m2 previously added, guaranteed not negative\n+                insert(c->key, c->count - m2, c->error - m2);\n+            } else {\n+                // Counters not monitored in S1\n+                insert(c->key, c->count + m1, c->error + m1);\n+            }\n+        }\n+    }\n+\n+    std::vector<Counter> topK(size_t k) const\n+    {\n+        std::vector<Counter> res;\n+        for (auto c : counterList) {\n+            res.push_back(*c);\n+            if (res.size() == k) {\n+                break;\n+            }\n+        }\n+        return res;\n+    }\n+\n+    void write(DB::WriteBuffer & wb) const\n+    {\n+        DB::writeVarUInt(size(), wb);\n+        for (auto c : counterList) {\n+            c->write(wb);\n+        }\n+        for (auto a : alphaMap) {\n+            DB::writeVarUInt(a, wb);\n+        }\n+    }\n+\n+    void read(DB::ReadBuffer & rb)\n+    {\n+        destroyElements();\n+        size_t count = 0;\n+        DB::readVarUInt(count, rb);\n+\n+        for (size_t i = 0; i < count; ++i) {\n+            auto c = new Counter();\n+            c->read(rb);\n+            push(c);\n+        }\n+\n+        for (size_t i = 0; i < capacity() * 6; ++i) {\n+            UInt64 alpha = 0;\n+            DB::readVarUInt(alpha, rb);\n+            alphaMap.push_back(alpha);\n+        }\n+    }\n+\n+protected:\n+    void push(Counter * c) {\n+        c->slot = counterList.size();\n+        counterList.push_back(c);\n+        counterMap[c->key] = c;\n+        percolate(c);\n+    }\n+\n+    // This is equivallent to one step of bubble sort\n+    void percolate(Counter * c) {\n+        while (c->slot > 0) {\n+            auto next = counterList[c->slot - 1];\n+            if (*c > *next) {\n+                std::swap(next->slot, c->slot);\n+                std::swap(counterList[next->slot], counterList[c->slot]);\n+            } else {\n+                break;\n+            }\n+        }\n+    }\n+\n+private:\n+    void destroyElements() {\n+        for (auto c : counterList) {\n+            delete c;\n+        }\n+        counterMap.clear();\n+        counterList.clear();\n+        alphaMap.clear();\n+    }\n+\n+    HashMap<TKey, Counter *, Hash> counterMap;\n+    std::vector<Counter *> counterList;\n+    std::vector<UInt64> alphaMap;\n+    size_t cap;\n+};\n+\n+};\n\\ No newline at end of file\ndiff --git a/dbms/src/IO/WriteHelpers.h b/dbms/src/IO/WriteHelpers.h\nindex 46084d622eb7..c8f46aabfc33 100644\n--- a/dbms/src/IO/WriteHelpers.h\n+++ b/dbms/src/IO/WriteHelpers.h\n@@ -583,6 +583,7 @@ inline typename std::enable_if<std::is_arithmetic<T>::value, void>::type\n writeBinary(const T & x, WriteBuffer & buf) { writePODBinary(x, buf); }\n \n inline void writeBinary(const String & x,    WriteBuffer & buf) { writeStringBinary(x, buf); }\n+inline void writeBinary(const StringRef & x,    WriteBuffer & buf) { writeStringBinary(x, buf); }\n inline void writeBinary(const uint128 & x,     WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const LocalDate & x,        WriteBuffer & buf) { writePODBinary(x, buf); }\n inline void writeBinary(const LocalDateTime & x,    WriteBuffer & buf) { writePODBinary(x, buf); }\ndiff --git a/website/reference_en.html b/website/reference_en.html\nindex eef67e1e5486..3c288135dabb 100644\n--- a/website/reference_en.html\n+++ b/website/reference_en.html\n@@ -6418,6 +6418,17 @@ <h1>Aggregate functions</h1>\n Problem: Generate a report that shows only keywords that produced at least 5 unique users.\n Solution: Write in the query <span class=\"inline-example\">GROUP BY SearchPhrase HAVING uniqUpTo(4)(UserID) >= 5</span>\n \n+==topK(N)(x)==\n+\n+Returns the K most frequent argument values as an array sorted by their relative frequency.\n+\n+Recommended for use with small Ns, up to 10. The maximum N value is 65536.\n+\n+For the state of an aggregate function, it uses approximately the amount of memory equal to K * (the size of the key + 16) for counters, and 48 * N bytes for alpha value map.\n+\n+Usage example:\n+Problem: Generate a report that shows top 5 frequent queries.\n+Solution: Write in the query <span class=\"inline-example\">SELECT topK(5)(SearchPhrase)</span>\n \n ==Aggregate function combinators==\n \ndiff --git a/website/reference_ru.html b/website/reference_ru.html\nindex 90de231cb801..b85a0d032235 100644\n--- a/website/reference_ru.html\n+++ b/website/reference_ru.html\n@@ -6534,6 +6534,17 @@ <h1>\u0410\u0433\u0440\u0435\u0433\u0430\u0442\u043d\u044b\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u0438</h1>\n \u0417\u0430\u0434\u0430\u0447\u0430: \u043f\u043e\u043a\u0430\u0437\u044b\u0432\u0430\u0442\u044c \u0432 \u043e\u0442\u0447\u0451\u0442\u0435 \u0442\u043e\u043b\u044c\u043a\u043e \u043f\u043e\u0438\u0441\u043a\u043e\u0432\u044b\u0435 \u0444\u0440\u0430\u0437\u044b, \u043f\u043e \u043a\u043e\u0442\u043e\u0440\u044b\u043c \u0431\u044b\u043b\u043e \u0445\u043e\u0442\u044f \u0431\u044b 5 \u0443\u043d\u0438\u043a\u0430\u043b\u044c\u043d\u044b\u0445 \u043f\u043e\u0441\u0435\u0442\u0438\u0442\u0435\u043b\u0435\u0439.\n \u0420\u0435\u0448\u0435\u043d\u0438\u0435: \u043f\u0438\u0448\u0435\u043c \u0432 \u0437\u0430\u043f\u0440\u043e\u0441\u0435 %%GROUP BY SearchPhrase HAVING uniqUpTo(4)(UserID) &gt;= 5%%\n \n+==topK(N)(x)==\n+\n+Returns the K most frequent argument values as an array sorted by their relative frequency.\n+\n+Recommended for use with small Ns, up to 10. The maximum N value is 65536.\n+\n+For the state of an aggregate function, it uses approximately the amount of memory equal to K * (the size of the key + 16) for counters, and 48 * N bytes for alpha value map.\n+\n+Usage example:\n+Problem: Generate a report that shows top 5 frequent queries.\n+Solution: Write in the query <span class=\"inline-example\">SELECT topK(5)(SearchPhrase)</span>\n \n ==\u041a\u043e\u043c\u0431\u0438\u043d\u0430\u0442\u043e\u0440\u044b \u0430\u0433\u0440\u0435\u0433\u0430\u0442\u043d\u044b\u0445 \u0444\u0443\u043d\u043a\u0446\u0438\u0439==\n \n",
  "test_patch": "diff --git a/contrib/libpoco/Crypto/testsuite/src/CryptoTest.cpp b/contrib/libpoco/Crypto/testsuite/src/CryptoTest.cpp\nindex 8c403470950d..53764df137c2 100644\n--- a/contrib/libpoco/Crypto/testsuite/src/CryptoTest.cpp\n+++ b/contrib/libpoco/Crypto/testsuite/src/CryptoTest.cpp\n@@ -246,6 +246,11 @@ void CryptoTest::testCertificate()\n \t\n \t// fails with recent OpenSSL versions:\n \t// assert (cert.issuedBy(cert));\n+\t\n+\tstd::istringstream otherCertStream(APPINF_PEM);\n+\tX509Certificate otherCert(otherCertStream);\n+\t\n+\tassert (cert.equals(otherCert));\n }\n \n \ndiff --git a/dbms/src/Common/tests/CMakeLists.txt b/dbms/src/Common/tests/CMakeLists.txt\nindex 3b8f53b307c2..072d55473015 100644\n--- a/dbms/src/Common/tests/CMakeLists.txt\n+++ b/dbms/src/Common/tests/CMakeLists.txt\n@@ -54,3 +54,6 @@ target_link_libraries (thread_pool dbms)\n \n add_executable (array_cache array_cache.cpp)\n target_link_libraries (array_cache dbms)\n+\n+add_executable (space_saving space_saving.cpp)\n+target_link_libraries (space_saving dbms)\ndiff --git a/dbms/src/Common/tests/space_saving.cpp b/dbms/src/Common/tests/space_saving.cpp\nnew file mode 100644\nindex 000000000000..5b37b94f43bc\n--- /dev/null\n+++ b/dbms/src/Common/tests/space_saving.cpp\n@@ -0,0 +1,105 @@\n+#include <iostream>\n+#include <iomanip>\n+#include <string>\n+#include <map>\n+\n+#include <Core/StringRef.h>\n+#include <Common/SpaceSaving.h>\n+\n+int main(int argc, char ** argv)\n+{\n+    {\n+        using Cont = DB::SpaceSaving<int>;\n+        Cont first(10);\n+\n+        /* Test biased insertion */\n+\n+        for (int i = 0; i < 200; ++i) {\n+            first.insert(i);\n+            int k = i % 5; // Bias towards 0-4\n+            first.insert(k);\n+        }\n+\n+        /* Test whether the biased elements are retained */\n+\n+        std::map<int, UInt64> expect;\n+        for (int i = 0; i < 5; ++i) {\n+            expect[i] = 41;   \n+        }\n+\n+        for (auto x : first.topK(5)) {\n+            if (expect[x.key] != x.count) {\n+                std::cerr << \"key: \" << x.key << \" value: \" << x.count << \" expected: \" << expect[x.key] << std::endl;\n+            } else {\n+                std::cout << \"key: \" << x.key << \" value: \" << x.count << std::endl;\n+            }\n+            expect.erase(x.key);\n+        }\n+\n+        if (!expect.empty()) {\n+            std::cerr << \"expected to find all heavy hitters\" << std::endl;\n+        }\n+\n+        /* Create another table and test merging */\n+\n+        Cont second(10);\n+        for (int i = 0; i < 200; ++i) {\n+            first.insert(i);\n+        }\n+\n+        for (int i = 0; i < 5; ++i) {\n+            expect[i] = 42;   \n+        }\n+\n+        first.merge(second);\n+\n+        for (auto x : first.topK(5)) {\n+            if (expect[x.key] != x.count) {\n+                std::cerr << \"key: \" << x.key << \" value: \" << x.count << \" expected: \" << expect[x.key] << std::endl;\n+            } else {\n+                std::cout << \"key: \" << x.key << \" value: \" << x.count << std::endl;\n+            }\n+            expect.erase(x.key);\n+        }\n+    }\n+\n+    {\n+        /* Same test for string keys */\n+\n+        using Cont = DB::SpaceSaving<StringRef, StringRefHash>;\n+        Cont cont(10);\n+\n+        std::vector<std::string> refs;\n+\n+        for (int i = 0; i < 400; ++i) {\n+            refs.push_back(std::to_string(i));\n+            cont.insert(StringRef(refs.back()));\n+            refs.push_back(std::to_string(i % 5)); // Bias towards 0-4\n+            cont.insert(StringRef(refs.back()));\n+        }\n+\n+        // The hashing is going to be more lossy\n+        // Expect at least ~ 10% count\n+        std::map<std::string, UInt64> expect;\n+        for (int i = 0; i < 5; ++i) {\n+            expect[std::to_string(i)] = 38;\n+        }\n+\n+        for (auto x : cont.topK(5)) {\n+            auto key = x.key.toString();\n+            if (x.count < expect[key]) {\n+                std::cerr << \"key: \" << key << \" value: \" << x.count << \" expected: \" << expect[key] << std::endl;\n+            } else {\n+                std::cout << \"key: \" << key << \" value: \" << x.count << std::endl;\n+            }\n+            expect.erase(key);\n+        }\n+\n+        if (!expect.empty()) {\n+            std::cerr << \"expected to find all heavy hitters\" << std::endl;\n+            abort();\n+        }\n+    }\n+\n+    return 0;\n+}\ndiff --git a/dbms/tests/queries/0_stateless/00453_top_k.reference b/dbms/tests/queries/0_stateless/00453_top_k.reference\nnew file mode 100644\nindex 000000000000..0b5c06820e8a\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00453_top_k.reference\n@@ -0,0 +1,1 @@\n+[0,1,2,3,4,5,6,7,8,9]\n\\ No newline at end of file\ndiff --git a/dbms/tests/queries/0_stateless/00453_top_k.sql b/dbms/tests/queries/0_stateless/00453_top_k.sql\nnew file mode 100644\nindex 000000000000..1f79a8c53933\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/00453_top_k.sql\n@@ -0,0 +1,1 @@\n+SELECT topK(10)(n) FROM (SELECT if(number % 100 < 10, number % 10, number) AS n FROM system.numbers LIMIT 100000);\n\\ No newline at end of file\n",
  "problem_statement": "what happen in error: field \u2018_ctx\u2019 has incomplete type \u2018EVP_CIPHER_CTX {aka evp_cipher_ctx_st}\u2019\n```\r\n/data/clickhouse_install/off_line_install/ClickHouse/contrib/libpoco/Crypto/src/CipherImpl.cpp:80:21: error: field \u2018_ctx\u2019 has incomplete type \u2018EVP_CIPHER_CTX {aka evp_cipher_ctx_st}\u2019\r\n   EVP_CIPHER_CTX    _ctx;\r\n                     ^~~~\r\nIn file included from /usr/local/include/openssl/crypto.h:31:0,\r\n                 from /data/clickhouse_install/off_line_install/ClickHouse/contrib/libpoco/Crypto/include/Poco/Crypto/OpenSSLInitializer.h:26,\r\n                 from /data/clickhouse_install/off_line_install/ClickHouse/contrib/libpoco/Crypto/include/Poco/Crypto/CipherKeyImpl.h:24,\r\n                 from /data/clickhouse_install/off_line_install/ClickHouse/contrib/libpoco/Crypto/include/Poco/Crypto/CipherKey.h:24,\r\n                 from /data/clickhouse_install/off_line_install/ClickHouse/contrib/libpoco/Crypto/include/Poco/Crypto/CipherImpl.h:25,\r\n                 from /data/clickhouse_install/off_line_install/ClickHouse/contrib/libpoco/Crypto/src/CipherImpl.cpp:17:\r\n/usr/local/include/openssl/ossl_typ.h:90:16: note: forward declaration of \u2018EVP_CIPHER_CTX {aka struct evp_cipher_ctx_st}\u2019\r\n typedef struct evp_cipher_ctx_st EVP_CIPHER_CTX;\r\n                ^~~~~~~~~~~~~~~~~\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-for-loop-analysis\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-local-typedef\u2019\r\ncc1plus: warning: unrecognized command line option \u2018-Wno-unused-private-field\u2019\r\nmake[2]: *** [contrib/libpoco/Crypto/CMakeFiles/PocoCrypto.dir/src/CipherImpl.cpp.o] Error 1\r\nmake[1]: *** [contrib/libpoco/Crypto/CMakeFiles/PocoCrypto.dir/all] Error 2\r\nmake[1]: *** Waiting for unfinished jobs....\r\n\r\n```\r\n\r\nI make Clickhouse is this error.\n",
  "hints_text": "fail in debian jessie\r\nwith openssl 1.0.1t\nfixed in poco - https://github.com/pocoproject/poco/commit/bfaa161c61cca06526eaf238bfdddd190381616b\ncurrent fastest way - build with poco 1.7.8 manually:\r\n```\r\ncd                                                                                                 \r\ngit clone --recursive --depth 1 --branch poco-1.7.8-release https://github.com/pocoproject/poco.git\r\ncd ~/poco && cmake . && make -j `nproc || sysctl -n hw.ncpu || echo 4`                             \r\ncd ~/ClickHouse/                                                                                   \r\nmkdir build                                                                                        \r\ncd build                                                                                           \r\ncmake .. -DUSE_INTERNAL_POCO_LIBRARY=0 -DPoco_ROOT_DIR=~/poco                                      \r\nmake -j `nproc || sysctl -n hw.ncpu || echo 4` clickhouse                                          \r\n```\nDid the answer has helped you?",
  "created_at": "2017-05-02T21:18:23Z"
}