diff --git a/src/Functions/FunctionSQLJSON.h b/src/Functions/FunctionSQLJSON.h
index 0533f3d419a7..3efa40df9bea 100644
--- a/src/Functions/FunctionSQLJSON.h
+++ b/src/Functions/FunctionSQLJSON.h
@@ -26,6 +26,7 @@
 
 #include "config.h"
 
+
 namespace DB
 {
 namespace ErrorCodes
@@ -114,8 +115,6 @@ class JSONStringSerializer
 
 };
 
-class EmptyJSONStringSerializer{};
-
 
 class FunctionSQLJSONHelpers
 {
@@ -156,25 +155,11 @@ class FunctionSQLJSONHelpers
                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Second argument (JSONPath) must be constant string");
             }
 
-            const ColumnPtr & arg_jsonpath = json_path_column.column;
-            const auto * arg_jsonpath_const = typeid_cast<const ColumnConst *>(arg_jsonpath.get());
-            const auto * arg_jsonpath_string = typeid_cast<const ColumnString *>(arg_jsonpath_const->getDataColumnPtr().get());
-
-            const ColumnPtr & arg_json = json_column.column;
-            const auto * col_json_const = typeid_cast<const ColumnConst *>(arg_json.get());
-            const auto * col_json_string
-                = typeid_cast<const ColumnString *>(col_json_const ? col_json_const->getDataColumnPtr().get() : arg_json.get());
-
-            /// Get data and offsets for 1 argument (JSONPath)
-            const ColumnString::Chars & chars_path = arg_jsonpath_string->getChars();
-            const ColumnString::Offsets & offsets_path = arg_jsonpath_string->getOffsets();
-
             /// Prepare to parse 1 argument (JSONPath)
-            const char * query_begin = reinterpret_cast<const char *>(&chars_path[0]);
-            const char * query_end = query_begin + offsets_path[0] - 1;
+            String query = typeid_cast<const ColumnConst &>(*json_path_column.column).getValue<String>();
 
-            /// Tokenize query
-            Tokens tokens(query_begin, query_end);
+            /// Tokenize the query
+            Tokens tokens(query.data(), query.data() + query.size());
             /// Max depth 0 indicates that depth is not limited
             IParser::Pos token_iterator(tokens, parse_depth);
 
@@ -188,10 +173,6 @@ class FunctionSQLJSONHelpers
                 throw Exception(ErrorCodes::BAD_ARGUMENTS, "Unable to parse JSONPath");
             }
 
-            /// Get data and offsets for 2 argument (JSON)
-            const ColumnString::Chars & chars_json = col_json_string->getChars();
-            const ColumnString::Offsets & offsets_json = col_json_string->getOffsets();
-
             JSONParser json_parser;
             using Element = typename JSONParser::Element;
             Element document;
@@ -200,10 +181,9 @@ class FunctionSQLJSONHelpers
             /// Parse JSON for every row
             Impl impl;
             GeneratorJSONPath<JSONParser> generator_json_path(res);
-            for (const auto i : collections::range(0, input_rows_count))
+            for (size_t i = 0; i < input_rows_count; ++i)
             {
-                std::string_view json{
-                    reinterpret_cast<const char *>(&chars_json[offsets_json[i - 1]]), offsets_json[i] - offsets_json[i - 1] - 1};
+                std::string_view json = json_column.column->getDataAt(i).toView();
                 document_ok = json_parser.parse(json, document);
 
                 bool added_to_column = false;
