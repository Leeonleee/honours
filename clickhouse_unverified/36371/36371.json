{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 36371,
  "instance_id": "ClickHouse__ClickHouse-36371",
  "issue_numbers": [
    "36335"
  ],
  "base_commit": "92296484e77f83372d94c9eb3f4861e054c76e63",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex ce768f80de5c..a68eec3f6a3c 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -247,6 +247,8 @@ class IColumn;\n     M(Bool, fallback_to_stale_replicas_for_distributed_queries, true, \"Suppose max_replica_delay_for_distributed_queries is set and all replicas for the queried table are stale. If this setting is enabled, the query will be performed anyway, otherwise the error will be reported.\", 0) \\\n     M(UInt64, preferred_max_column_in_block_size_bytes, 0, \"Limit on max column size in block while reading. Helps to decrease cache misses count. Should be close to L2 cache size.\", 0) \\\n     \\\n+    M(UInt64, parts_to_delay_insert, 150, \"If the destination table contains at least that many active parts in a single partition, artificially slow down insert into table.\", 0) \\\n+    M(UInt64, parts_to_throw_insert, 300, \"If more than this number active parts in a single partition of the destination table, throw 'Too many parts ...' exception.\", 0) \\\n     M(Bool, insert_distributed_sync, false, \"If setting is enabled, insert query into distributed waits until data will be sent to all nodes in cluster.\", 0) \\\n     M(UInt64, insert_distributed_timeout, 0, \"Timeout for insert query into distributed. Setting is used only with insert_distributed_sync enabled. Zero value means no timeout.\", 0) \\\n     M(Int64, distributed_ddl_task_timeout, 180, \"Timeout for DDL query responses from all hosts in cluster. If a ddl request has not been performed on all hosts, a response will contain a timeout error and a request will be executed in an async mode. Negative value means infinite. Zero means async mode.\", 0) \\\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 938c39cb58ef..cfd902cca6dc 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -3260,9 +3260,10 @@ std::optional<Int64> MergeTreeData::getMinPartDataVersion() const\n }\n \n \n-void MergeTreeData::delayInsertOrThrowIfNeeded(Poco::Event * until) const\n+void MergeTreeData::delayInsertOrThrowIfNeeded(Poco::Event * until, ContextPtr query_context) const\n {\n     const auto settings = getSettings();\n+    const auto & query_settings = query_context->getSettingsRef();\n     const size_t parts_count_in_total = getPartsCount();\n     if (parts_count_in_total >= settings->max_parts_in_total)\n     {\n@@ -3286,7 +3287,10 @@ void MergeTreeData::delayInsertOrThrowIfNeeded(Poco::Event * until) const\n         k_inactive = static_cast<ssize_t>(inactive_parts_count_in_partition) - static_cast<ssize_t>(settings->inactive_parts_to_delay_insert);\n     }\n \n-    if (parts_count_in_partition >= settings->parts_to_throw_insert)\n+    auto parts_to_delay_insert = query_settings.parts_to_delay_insert.changed ? query_settings.parts_to_delay_insert : settings->parts_to_delay_insert;\n+    auto parts_to_throw_insert = query_settings.parts_to_throw_insert.changed ? query_settings.parts_to_throw_insert : settings->parts_to_throw_insert;\n+\n+    if (parts_count_in_partition >= parts_to_throw_insert)\n     {\n         ProfileEvents::increment(ProfileEvents::RejectedInserts);\n         throw Exception(\n@@ -3295,15 +3299,15 @@ void MergeTreeData::delayInsertOrThrowIfNeeded(Poco::Event * until) const\n             parts_count_in_partition);\n     }\n \n-    if (k_inactive < 0 && parts_count_in_partition < settings->parts_to_delay_insert)\n+    if (k_inactive < 0 && parts_count_in_partition < parts_to_delay_insert)\n         return;\n \n-    const ssize_t k_active = ssize_t(parts_count_in_partition) - ssize_t(settings->parts_to_delay_insert);\n+    const ssize_t k_active = ssize_t(parts_count_in_partition) - ssize_t(parts_to_delay_insert);\n     size_t max_k;\n     size_t k;\n     if (k_active > k_inactive)\n     {\n-        max_k = settings->parts_to_throw_insert - settings->parts_to_delay_insert;\n+        max_k = parts_to_throw_insert - parts_to_delay_insert;\n         k = k_active + 1;\n     }\n     else\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex 7590d2e1d49e..8515c8583b7b 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -530,7 +530,7 @@ class MergeTreeData : public IStorage, public WithMutableContext\n \n     /// If the table contains too many active parts, sleep for a while to give them time to merge.\n     /// If until is non-null, wake up from the sleep earlier if the event happened.\n-    void delayInsertOrThrowIfNeeded(Poco::Event * until = nullptr) const;\n+    void delayInsertOrThrowIfNeeded(Poco::Event * until, ContextPtr query_context) const;\n \n     /// Renames temporary part to a permanent part and adds it to the parts set.\n     /// It is assumed that the part does not intersect with existing parts.\ndiff --git a/src/Storages/MergeTree/MergeTreeSink.cpp b/src/Storages/MergeTree/MergeTreeSink.cpp\nindex 7e8ee3dcbeff..93b9f3565953 100644\n--- a/src/Storages/MergeTree/MergeTreeSink.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSink.cpp\n@@ -26,7 +26,7 @@ void MergeTreeSink::onStart()\n {\n     /// Only check \"too many parts\" before write,\n     /// because interrupting long-running INSERT query in the middle is not convenient for users.\n-    storage.delayInsertOrThrowIfNeeded();\n+    storage.delayInsertOrThrowIfNeeded(nullptr, context);\n }\n \n void MergeTreeSink::onFinish()\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\nindex c96c180b83de..126d34bcc1d4 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp\n@@ -605,7 +605,7 @@ void ReplicatedMergeTreeSink::onStart()\n {\n     /// Only check \"too many parts\" before write,\n     /// because interrupting long-running INSERT query in the middle is not convenient for users.\n-    storage.delayInsertOrThrowIfNeeded(&storage.partial_shutdown_event);\n+    storage.delayInsertOrThrowIfNeeded(&storage.partial_shutdown_event, context);\n }\n \n void ReplicatedMergeTreeSink::onFinish()\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02280_add_query_level_settings.reference b/tests/queries/0_stateless/02280_add_query_level_settings.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02280_add_query_level_settings.sql b/tests/queries/0_stateless/02280_add_query_level_settings.sql\nnew file mode 100644\nindex 000000000000..a44f8eb854ea\n--- /dev/null\n+++ b/tests/queries/0_stateless/02280_add_query_level_settings.sql\n@@ -0,0 +1,17 @@\n+DROP TABLE IF EXISTS table_for_alter;\n+\n+CREATE TABLE table_for_alter (\n+  id UInt64,\n+  Data String\n+) ENGINE = MergeTree() ORDER BY id SETTINGS parts_to_throw_insert = 1, parts_to_delay_insert = 1;\n+\n+INSERT INTO table_for_alter VALUES (1, '1');\n+INSERT INTO table_for_alter VALUES (2, '2'); -- { serverError 252 }\n+\n+INSERT INTO table_for_alter settings parts_to_throw_insert = 100, parts_to_delay_insert = 100 VALUES (2, '2');\n+\n+INSERT INTO table_for_alter VALUES (3, '3'); -- { serverError 252 }\n+\n+ALTER TABLE table_for_alter MODIFY SETTING parts_to_throw_insert = 100, parts_to_delay_insert = 100;\n+\n+INSERT INTO table_for_alter VALUES (3, '3');\n",
  "problem_statement": "`parts_to_delay_insert` and `parts_to_throw_insert` can be also query-level settings\nIf they are defined, they can override table-level settings.\n",
  "hints_text": "I'd like to do that.\n@Joeywzr Thank you!",
  "created_at": "2022-04-18T04:19:45Z",
  "modified_files": [
    "src/Core/Settings.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeData.h",
    "src/Storages/MergeTree/MergeTreeSink.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeSink.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02280_add_query_level_settings.sql"
  ]
}