{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 84019,
  "instance_id": "ClickHouse__ClickHouse-84019",
  "issue_numbers": [
    "81779"
  ],
  "base_commit": "e83ae279b7ce7fa406179fd62c84532d82ef0ead",
  "patch": "diff --git a/src/Processors/QueryPlan/JoinStepLogical.cpp b/src/Processors/QueryPlan/JoinStepLogical.cpp\nindex 22f995fbfc18..23829917ddbf 100644\n--- a/src/Processors/QueryPlan/JoinStepLogical.cpp\n+++ b/src/Processors/QueryPlan/JoinStepLogical.cpp\n@@ -300,8 +300,16 @@ const ActionsDAG::Node & findOrAddInput(const ActionsDAGPtr & actions_dag, const\n \n JoinActionRef predicateToCondition(const JoinPredicate & predicate, const ActionsDAGPtr & actions_dag)\n {\n-    const auto & left_node = findOrAddInput(actions_dag, predicate.left_node.getColumn());\n-    const auto & right_node = findOrAddInput(actions_dag, predicate.right_node.getColumn());\n+    ColumnWithTypeAndName left_column = predicate.left_node.getColumn();\n+    ColumnWithTypeAndName right_column = predicate.right_node.getColumn();\n+\n+    /// Constant columns from the JOIN condition will be materialized during the JOIN,\n+    /// that's why we can't use them as constants for actions building.\n+    left_column.column = nullptr;\n+    right_column.column = nullptr;\n+\n+    const auto & left_node = findOrAddInput(actions_dag, left_column);\n+    const auto & right_node = findOrAddInput(actions_dag, right_column);\n \n     auto operator_function = FunctionFactory::instance().get(operatorToFunctionName(predicate.op), nullptr);\n     const auto & result_node = actions_dag->addFunction(operator_function, {&left_node, &right_node}, {});\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03571_join_inequality_constants.reference b/tests/queries/0_stateless/03571_join_inequality_constants.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/03571_join_inequality_constants.sql b/tests/queries/0_stateless/03571_join_inequality_constants.sql\nnew file mode 100644\nindex 000000000000..2a2cb98ebddd\n--- /dev/null\n+++ b/tests/queries/0_stateless/03571_join_inequality_constants.sql\n@@ -0,0 +1,4 @@\n+SET enable_analyzer = 1;\n+\n+SELECT id FROM (SELECT toLowCardinality(1) AS id) AS a INNER JOIN (SELECT toLowCardinality(toUInt128(materialize(0))) AS id) AS b USING (id) INNER JOIN a AS t ON b.id < t.id;\n+SELECT 1 FROM (SELECT toLowCardinality(0) a) a FULL JOIN a b USING (a) JOIN a c ON b.a > c.a SETTINGS join_use_nulls = true;\n",
  "problem_statement": "Logical Error: Expected single dictionary argument for function\n### Describe the bug\n\nFrom this run: https://s3.amazonaws.com/clickhouse-test-reports/json.html?REF=master&sha=50f1402abbcafe8f84869dc6a61a58948a8a58a1&name_0=MasterCI&name_1=AST%20fuzzer%20%28amd_debug%29 Triggers since v25.2\n\n### How to reproduce\n\nRun Fiddle: https://fiddle.clickhouse.com/6e51f3cc-c7e0-43fe-b475-43ce7354401d\n\n### Error message and/or stacktrace\n\nStack trace:\n\n```\n<Fatal> : Logical error: 'Expected single dictionary argument for function.'.\n<Fatal> : Stack trace (when copying this message, always include the lines below):\n\n0. contrib/llvm-project/libcxx/include/__exception/exception.h:113: Poco::Exception::Exception(String const&, int) @ 0x000000001d4d28d2\n1. src/Common/Exception.cpp:110: DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x0000000011e6f1c6\n2. src/Common/Exception.h:119: DB::Exception::Exception(PreformattedMessage&&, int) @ 0x000000000ba670ac\n3. src/Common/Exception.h:137: DB::Exception::Exception<>(int, FormatStringHelperImpl<>) @ 0x000000000ba70936\n4. src/Functions/IFunction.cpp:83: DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000001532bdd0\n5. src/Functions/IFunction.cpp:498: DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x000000001532c5c2\n6. src/Interpreters/ActionsDAG.cpp:823: DB::ActionsDAG::evaluatePartialResult(std::unordered_map<DB::ActionsDAG::Node const*, DB::ColumnWithTypeAndName, std::hash<DB::ActionsDAG::Node const*>, std::equal_to<DB::ActionsDAG::Node const*>, std::allocator<std::pair<DB::ActionsDAG::Node const* const, DB::ColumnWithTypeAndName>>>&, std::vector<DB::ActionsDAG::Node const*, std::allocator<DB::ActionsDAG::Node const*>> const&, unsigned long, bool) @ 0x00000000165f08ce\n7. src/Interpreters/ActionsDAG.cpp:908: DB::ActionsDAG::updateHeader(DB::Block const&) const @ 0x00000000165ef7a1\n8. src/Processors/Transforms/FilterTransform.cpp:49: DB::FilterTransform::transformHeader(DB::Block const&, DB::ActionsDAG const*, String const&, bool) @ 0x0000000019448dd8\n9. src/Processors/QueryPlan/FilterStep.cpp:135: DB::FilterStep::FilterStep(DB::Block const&, DB::ActionsDAG, String, bool) @ 0x000000001969ee3b\n10. contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:634: std::__unique_if<DB::FilterStep>::__unique_single std::make_unique[abi:se190107]<DB::FilterStep, DB::Block const&, DB::ActionsDAG, String const&, bool&>(DB::Block const&, DB::ActionsDAG&&, String const&, bool&) @ 0x00000000197b0a26\n11. src/Processors/QueryPlan/Optimizations/optimizeJoin.cpp:318: DB::QueryPlanOptimizations::convertLogicalJoinToPhysical(DB::QueryPlan::Node&, std::list<DB::QueryPlan::Node, std::allocator<DB::QueryPlan::Node>>&, DB::QueryPlanOptimizationSettings const&, std::optional<unsigned long>) @ 0x00000000197af3c4\n12. src/Processors/QueryPlan/Optimizations/optimizeTree.cpp:165: DB::QueryPlanOptimizations::optimizeTreeSecondPass(DB::QueryPlanOptimizationSettings const&, DB::QueryPlan::Node&, std::list<DB::QueryPlan::Node, std::allocator<DB::QueryPlan::Node>>&) @ 0x00000000197a5bd7\n13. src/Processors/QueryPlan/QueryPlan.cpp:494: DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&, bool) @ 0x00000000196d5434\n14. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:289: DB::InterpreterSelectQueryAnalyzer::buildQueryPipeline() @ 0x000000001709d704\n15. src/Interpreters/InterpreterSelectQueryAnalyzer.cpp:256: DB::InterpreterSelectQueryAnalyzer::execute() @ 0x000000001709d47c\n16. src/Interpreters/executeQuery.cpp:1523: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum, DB::ReadBuffer*, std::shared_ptr<DB::IAST>&) @ 0x0000000017376c97\n17. src/Interpreters/executeQuery.cpp:1715: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, DB::QueryFlags, DB::QueryProcessingStage::Enum) @ 0x0000000017370ff1\n18. src/Server/TCPHandler.cpp:687: DB::TCPHandler::runImpl() @ 0x00000000190fb846\n19. src/Server/TCPHandler.cpp:2677: DB::TCPHandler::run() @ 0x0000000019114dc4\n20. base/poco/Net/src/TCPServerConnection.cpp:40: Poco::Net::TCPServerConnection::start() @ 0x000000001d577b27\n21. base/poco/Net/src/TCPServerDispatcher.cpp:115: Poco::Net::TCPServerDispatcher::run() @ 0x000000001d578025\n22. base/poco/Foundation/src/ThreadPool.cpp:205: Poco::PooledThread::run() @ 0x000000001d52065f\n23. base/poco/Foundation/src/Thread_POSIX.cpp:335: Poco::ThreadImpl::runnableEntry(void*) @ 0x000000001d51e211\n24. start_thread @ 0x00000000000a2ef1\n25. __GI___clone3 @ 0x000000000013445c\n```\n",
  "hints_text": "",
  "created_at": "2025-07-18T23:49:09Z",
  "modified_files": [
    "src/Processors/QueryPlan/JoinStepLogical.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/03571_join_inequality_constants.sql"
  ]
}