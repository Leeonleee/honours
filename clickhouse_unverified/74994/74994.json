{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 74994,
  "instance_id": "ClickHouse__ClickHouse-74994",
  "issue_numbers": [
    "55422"
  ],
  "base_commit": "25fbafb780c53202e29a5fa05f6be09f275b3137",
  "patch": "diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp\nindex 9ae0f1477c1c..a5e4eddb6b5f 100644\n--- a/src/Interpreters/executeQuery.cpp\n+++ b/src/Interpreters/executeQuery.cpp\n@@ -881,13 +881,14 @@ void validateAnalyzerSettings(ASTPtr ast, bool context_value)\n     }\n }\n \n-static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n+static BlockIO executeQueryImpl(\n     const char * begin,\n     const char * end,\n     ContextMutablePtr context,\n     QueryFlags flags,\n     QueryProcessingStage::Enum stage,\n-    ReadBuffer * istr)\n+    ReadBuffer * istr,\n+    ASTPtr & out_ast)\n {\n     const bool internal = flags.internal;\n \n@@ -932,7 +933,6 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n     if (internal || client_info.query_kind == ClientInfo::QueryKind::SECONDARY_QUERY)\n         max_query_size = 0;\n \n-    ASTPtr ast;\n     String query;\n     String query_for_logging;\n     size_t log_queries_cut_to_length = settings[Setting::log_queries_cut_to_length];\n@@ -946,20 +946,20 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"Support for Kusto Query Engine (KQL) is disabled (turn on setting 'allow_experimental_kusto_dialect')\");\n             ParserKQLStatement parser(end, settings[Setting::allow_settings_after_format_in_insert]);\n             /// TODO: parser should fail early when max_query_size limit is reached.\n-            ast = parseKQLQuery(parser, begin, end, \"\", max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n+            out_ast = parseKQLQuery(parser, begin, end, \"\", max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n         }\n         else if (settings[Setting::dialect] == Dialect::prql && !internal)\n         {\n             if (!settings[Setting::allow_experimental_prql_dialect])\n                 throw Exception(ErrorCodes::SUPPORT_IS_DISABLED, \"Support for PRQL is disabled (turn on setting 'allow_experimental_prql_dialect')\");\n             ParserPRQLQuery parser(max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n-            ast = parseQuery(parser, begin, end, \"\", max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n+            out_ast = parseQuery(parser, begin, end, \"\", max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n         }\n         else\n         {\n             ParserQuery parser(end, settings[Setting::allow_settings_after_format_in_insert], settings[Setting::implicit_select]);\n             /// TODO: parser should fail early when max_query_size limit is reached.\n-            ast = parseQuery(parser, begin, end, \"\", max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n+            out_ast = parseQuery(parser, begin, end, \"\", max_query_size, settings[Setting::max_parser_depth], settings[Setting::max_parser_backtracks]);\n \n #ifndef NDEBUG\n             try\n@@ -967,7 +967,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 /// Verify that AST formatting is consistent:\n                 /// If you format AST, parse it back, and format it again, you get the same string.\n \n-                String formatted1 = ast->formatWithPossiblyHidingSensitiveData(\n+                String formatted1 = out_ast->formatWithPossiblyHidingSensitiveData(\n                     /*max_length=*/0,\n                     /*one_line=*/true,\n                     /*show_secrets=*/true,\n@@ -1025,15 +1025,15 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         }\n \n         const char * query_end = end;\n-        if (const auto * insert_query = ast->as<ASTInsertQuery>(); insert_query && insert_query->data)\n+        if (const auto * insert_query = out_ast->as<ASTInsertQuery>(); insert_query && insert_query->data)\n             query_end = insert_query->data;\n \n         bool is_create_parameterized_view = false;\n-        if (const auto * create_query = ast->as<ASTCreateQuery>())\n+        if (const auto * create_query = out_ast->as<ASTCreateQuery>())\n         {\n             is_create_parameterized_view = create_query->isParameterizedView();\n         }\n-        else if (const auto * explain_query = ast->as<ASTExplainQuery>())\n+        else if (const auto * explain_query = out_ast->as<ASTExplainQuery>())\n         {\n             if (!explain_query->children.empty())\n                 if (const auto * create_of_explain_query = explain_query->children[0]->as<ASTCreateQuery>())\n@@ -1046,9 +1046,9 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         if (!is_create_parameterized_view && probably_has_params)\n         {\n             ReplaceQueryParameterVisitor visitor(context->getQueryParameters());\n-            visitor.visit(ast);\n+            visitor.visit(out_ast);\n             if (visitor.getNumberOfReplacedParameters())\n-                query = serializeAST(*ast);\n+                query = serializeAST(*out_ast);\n             else\n                 query.assign(begin, query_end);\n         }\n@@ -1062,10 +1062,10 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         /// MUST go before any modification (except for prepared statements,\n         /// since it substitute parameters and without them query does not contain\n         /// parameters), to keep query as-is in query_log and server log.\n-        if (ast->hasSecretParts())\n+        if (out_ast->hasSecretParts())\n         {\n             /// IAST::formatForLogging() wipes secret parts in AST and then calls wipeSensitiveDataAndCutToLength().\n-            query_for_logging = ast->formatForLogging(log_queries_cut_to_length);\n+            query_for_logging = out_ast->formatForLogging(log_queries_cut_to_length);\n         }\n         else\n         {\n@@ -1082,7 +1082,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         logQuery(query_for_logging, context, internal, stage);\n \n         if (!internal)\n-            logExceptionBeforeStart(query_for_logging, context, ast, query_span, start_watch.elapsedMilliseconds());\n+            logExceptionBeforeStart(query_for_logging, context, out_ast, query_span, start_watch.elapsedMilliseconds());\n         throw;\n     }\n \n@@ -1113,7 +1113,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         {\n             chassert(txn->getState() != MergeTreeTransaction::COMMITTING);\n             chassert(txn->getState() != MergeTreeTransaction::COMMITTED);\n-            if (txn->getState() == MergeTreeTransaction::ROLLED_BACK && !ast->as<ASTTransactionControl>() && !ast->as<ASTExplainQuery>())\n+            if (txn->getState() == MergeTreeTransaction::ROLLED_BACK && !out_ast->as<ASTTransactionControl>() && !out_ast->as<ASTExplainQuery>())\n                 throw Exception(\n                     ErrorCodes::INVALID_TRANSACTION,\n                     \"Cannot execute query because current transaction failed. Expecting ROLLBACK statement\");\n@@ -1121,18 +1121,18 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n \n         /// Interpret SETTINGS clauses as early as possible (before invoking the corresponding interpreter),\n         /// to allow settings to take effect.\n-        InterpreterSetQuery::applySettingsFromQuery(ast, context);\n-        validateAnalyzerSettings(ast, settings[Setting::allow_experimental_analyzer]);\n+        InterpreterSetQuery::applySettingsFromQuery(out_ast, context);\n+        validateAnalyzerSettings(out_ast, settings[Setting::allow_experimental_analyzer]);\n \n         if (settings[Setting::enforce_strict_identifier_format])\n         {\n             WriteBufferFromOwnString buf;\n             IAST::FormatSettings enforce_strict_identifier_format_settings(true);\n             enforce_strict_identifier_format_settings.enforce_strict_identifier_format = true;\n-            ast->format(buf, enforce_strict_identifier_format_settings);\n+            out_ast->format(buf, enforce_strict_identifier_format_settings);\n         }\n \n-        if (auto * insert_query = ast->as<ASTInsertQuery>())\n+        if (auto * insert_query = out_ast->as<ASTInsertQuery>())\n             insert_query->tail = istr;\n \n         /// There is an option of probabilistic logging of queries.\n@@ -1147,7 +1147,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             context->setSetting(\"log_queries_probability\", 1.0);\n         }\n \n-        if (const auto * query_with_table_output = dynamic_cast<const ASTQueryWithTableAndOutput *>(ast.get()))\n+        if (const auto * query_with_table_output = dynamic_cast<const ASTQueryWithTableAndOutput *>(out_ast.get()))\n         {\n             query_database = query_with_table_output->getDatabase();\n             query_table = query_with_table_output->getTable();\n@@ -1158,35 +1158,35 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         /// Propagate WITH statement to children ASTSelect.\n         if (settings[Setting::enable_global_with_statement])\n         {\n-            ApplyWithGlobalVisitor::visit(ast);\n+            ApplyWithGlobalVisitor::visit(out_ast);\n         }\n \n         {\n             SelectIntersectExceptQueryVisitor::Data data{settings[Setting::intersect_default_mode], settings[Setting::except_default_mode]};\n-            SelectIntersectExceptQueryVisitor{data}.visit(ast);\n+            SelectIntersectExceptQueryVisitor{data}.visit(out_ast);\n         }\n \n         {\n             /// Normalize SelectWithUnionQuery\n             NormalizeSelectWithUnionQueryVisitor::Data data{settings[Setting::union_default_mode]};\n-            NormalizeSelectWithUnionQueryVisitor{data}.visit(ast);\n+            NormalizeSelectWithUnionQueryVisitor{data}.visit(out_ast);\n         }\n \n         /// Check the limits.\n-        checkASTSizeLimits(*ast, settings);\n+        checkASTSizeLimits(*out_ast, settings);\n \n         /// Put query to process list. But don't put SHOW PROCESSLIST query itself.\n-        if (!internal && !ast->as<ASTShowProcesslistQuery>())\n+        if (!internal && !out_ast->as<ASTShowProcesslistQuery>())\n         {\n             /// processlist also has query masked now, to avoid secrets leaks though SHOW PROCESSLIST by other users.\n-            process_list_entry = context->getProcessList().insert(query_for_logging, ast.get(), context, start_watch.getStart());\n+            process_list_entry = context->getProcessList().insert(query_for_logging, out_ast.get(), context, start_watch.getStart());\n             context->setProcessListElement(process_list_entry->getQueryStatus());\n         }\n \n         /// Load external tables if they were provided\n         context->initializeExternalTablesIfSet();\n \n-        auto * insert_query = ast->as<ASTInsertQuery>();\n+        auto * insert_query = out_ast->as<ASTInsertQuery>();\n         bool async_insert_enabled = settings[Setting::async_insert];\n \n         /// Resolve database before trying to use async insert feature - to properly hash the query.\n@@ -1215,7 +1215,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     auto & input_storage = dynamic_cast<StorageInput &>(*storage);\n                     auto input_metadata_snapshot = input_storage.getInMemoryMetadataPtr();\n                     auto pipe = getSourceFromASTInsertQuery(\n-                        ast, true, input_metadata_snapshot->getSampleBlock(), context, input_function);\n+                        out_ast, true, input_metadata_snapshot->getSampleBlock(), context, input_function);\n                     input_storage.setPipe(std::move(pipe));\n                 }\n             }\n@@ -1283,7 +1283,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 quota->checkExceeded(QuotaType::ERRORS);\n             }\n \n-            auto result = queue->pushQueryWithInlinedData(ast, context);\n+            auto result = queue->pushQueryWithInlinedData(out_ast, context);\n \n             if (result.status == AsynchronousInsertQueue::PushResult::OK)\n             {\n@@ -1320,7 +1320,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n         QueryCachePtr query_cache = context->getQueryCache();\n         const bool can_use_query_cache = query_cache != nullptr && settings[Setting::use_query_cache] && !internal\n             && client_info.query_kind == ClientInfo::QueryKind::INITIAL_QUERY\n-            && (ast->as<ASTSelectQuery>() || ast->as<ASTSelectWithUnionQuery>());\n+            && (out_ast->as<ASTSelectQuery>() || out_ast->as<ASTSelectWithUnionQuery>());\n         QueryCache::Usage query_cache_usage = QueryCache::Usage::None;\n \n         /// Bug 67476: If the query runs with a non-THROW overflow mode and hits a limit, the query cache will store a truncated result (if\n@@ -1355,7 +1355,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             {\n                 if (can_use_query_cache && settings[Setting::enable_reads_from_query_cache])\n                 {\n-                    QueryCache::Key key(ast, context->getCurrentDatabase(), *settings_copy, context->getCurrentQueryId(), context->getUserID(), context->getCurrentRoles());\n+                    QueryCache::Key key(out_ast, context->getCurrentDatabase(), *settings_copy, context->getCurrentQueryId(), context->getUserID(), context->getCurrentRoles());\n                     QueryCache::Reader reader = query_cache->createReader(key);\n                     if (reader.hasCacheEntryForKey())\n                     {\n@@ -1372,7 +1372,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             if (!get_result_from_query_cache())\n             {\n                 /// We need to start the (implicit) transaction before getting the interpreter as this will get links to the latest snapshots\n-                if (!context->getCurrentTransaction() && settings[Setting::implicit_transaction] && !ast->as<ASTTransactionControl>())\n+                if (!context->getCurrentTransaction() && settings[Setting::implicit_transaction] && !out_ast->as<ASTTransactionControl>())\n                 {\n                     try\n                     {\n@@ -1388,13 +1388,13 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     }\n                 }\n \n-                interpreter = InterpreterFactory::instance().get(ast, context, SelectQueryOptions(stage).setInternal(internal));\n+                interpreter = InterpreterFactory::instance().get(out_ast, context, SelectQueryOptions(stage).setInternal(internal));\n \n                 const auto & query_settings = context->getSettingsRef();\n                 if (context->getCurrentTransaction() && query_settings[Setting::throw_on_unsupported_query_inside_transaction])\n                 {\n                     if (!interpreter->supportsTransactions())\n-                        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Transactions are not supported for this type of query ({})\", ast->getID());\n+                        throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Transactions are not supported for this type of query ({})\", out_ast->getID());\n \n                     if (query_settings[Setting::apply_mutations_on_fly])\n                         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Transactions are not supported with enabled setting 'apply_mutations_on_fly'\");\n@@ -1410,11 +1410,11 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     quota = context->getQuota();\n                     if (quota)\n                     {\n-                        if (ast->as<ASTSelectQuery>() || ast->as<ASTSelectWithUnionQuery>())\n+                        if (out_ast->as<ASTSelectQuery>() || out_ast->as<ASTSelectWithUnionQuery>())\n                         {\n                             quota->used(QuotaType::QUERY_SELECTS, 1);\n                         }\n-                        else if (ast->as<ASTInsertQuery>())\n+                        else if (out_ast->as<ASTInsertQuery>())\n                         {\n                             quota->used(QuotaType::QUERY_INSERTS, 1);\n                         }\n@@ -1462,8 +1462,8 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     {\n                         /// Only use the query cache if the query does not contain non-deterministic functions or system tables (which are typically non-deterministic)\n \n-                        const bool ast_contains_nondeterministic_functions = astContainsNonDeterministicFunctions(ast, context);\n-                        const bool ast_contains_system_tables = astContainsSystemTables(ast, context);\n+                        const bool ast_contains_nondeterministic_functions = astContainsNonDeterministicFunctions(out_ast, context);\n+                        const bool ast_contains_system_tables = astContainsSystemTables(out_ast, context);\n \n                         const QueryCacheNondeterministicFunctionHandling nondeterministic_function_handling\n                             = settings[Setting::query_cache_nondeterministic_function_handling];\n@@ -1483,7 +1483,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                             && (!ast_contains_system_tables || system_table_handling == QueryCacheSystemTableHandling::Save))\n                         {\n                             QueryCache::Key key(\n-                                ast, context->getCurrentDatabase(), *settings_copy, res.pipeline.getHeader(),\n+                                out_ast, context->getCurrentDatabase(), *settings_copy, res.pipeline.getHeader(),\n                                 context->getCurrentQueryId(),\n                                 context->getUserID(), context->getCurrentRoles(),\n                                 settings[Setting::query_cache_share_between_users],\n@@ -1548,7 +1548,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 query_start_time,\n                 context,\n                 query_for_logging,\n-                ast,\n+                out_ast,\n                 pipeline,\n                 interpreter,\n                 internal,\n@@ -1558,7 +1558,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             /// Also make possible for caller to log successful query finish and exception during execution.\n             auto finish_callback = [elem,\n                                     context,\n-                                    ast,\n+                                    out_ast,\n                                     query_cache_usage,\n                                     internal,\n                                     implicit_txn_control,\n@@ -1571,14 +1571,14 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                     /// partial/garbage results in case of exceptions during query execution.\n                     query_pipeline.finalizeWriteInQueryCache();\n \n-                logQueryFinish(elem, context, ast, query_pipeline, pulling_pipeline, query_span, query_cache_usage, internal);\n+                logQueryFinish(elem, context, out_ast, query_pipeline, pulling_pipeline, query_span, query_cache_usage, internal);\n \n                 if (*implicit_txn_control)\n                     execute_implicit_tcl_query(context, ASTTransactionControl::COMMIT);\n             };\n \n             auto exception_callback =\n-                [start_watch, elem, context, ast, internal, my_quota(quota), implicit_txn_control, execute_implicit_tcl_query, query_span](\n+                [start_watch, elem, context, out_ast, internal, my_quota(quota), implicit_txn_control, execute_implicit_tcl_query, query_span](\n                     bool log_error) mutable\n             {\n                 if (*implicit_txn_control)\n@@ -1589,7 +1589,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n                 if (my_quota)\n                     my_quota->used(QuotaType::ERRORS, 1, /* check_exceeded = */ false);\n \n-                logQueryException(elem, context, start_watch, ast, query_span, internal, log_error);\n+                logQueryException(elem, context, start_watch, out_ast, query_span, internal, log_error);\n             };\n \n             res.finish_callback = std::move(finish_callback);\n@@ -1604,12 +1604,12 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(\n             txn->onException();\n \n         if (!internal)\n-            logExceptionBeforeStart(query_for_logging, context, ast, query_span, start_watch.elapsedMilliseconds());\n+            logExceptionBeforeStart(query_for_logging, context, out_ast, query_span, start_watch.elapsedMilliseconds());\n \n         throw;\n     }\n \n-    return std::make_tuple(std::move(ast), std::move(res));\n+    return res;\n }\n \n \n@@ -1620,9 +1620,7 @@ std::pair<ASTPtr, BlockIO> executeQuery(\n     QueryProcessingStage::Enum stage)\n {\n     ASTPtr ast;\n-    BlockIO res;\n-\n-    std::tie(ast, res) = executeQueryImpl(query.data(), query.data() + query.size(), context, flags, stage, nullptr);\n+    BlockIO res = executeQueryImpl(query.data(), query.data() + query.size(), context, flags, stage, nullptr, ast);\n \n     if (const auto * ast_query_with_output = dynamic_cast<const ASTQueryWithOutput *>(ast.get()))\n     {\n@@ -1712,8 +1710,8 @@ void executeQuery(\n \n     ASTPtr ast;\n     BlockIO streams;\n-    OutputFormatPtr output_format;\n     String format_name;\n+    OutputFormatPtr output_format;\n \n     auto update_format_on_exception_if_needed = [&]()\n     {\n@@ -1721,7 +1719,11 @@ void executeQuery(\n         {\n             try\n             {\n-                format_name = context->getDefaultFormat();\n+                const ASTQueryWithOutput * ast_query_with_output = dynamic_cast<const ASTQueryWithOutput *>(ast.get());\n+                format_name = ast_query_with_output && ast_query_with_output->format_ast != nullptr\n+                    ? getIdentifierName(ast_query_with_output->format_ast)\n+                    : context->getDefaultFormat();\n+\n                 output_format = FormatFactory::instance().getOutputFormat(format_name, ostr, {}, context, output_format_settings);\n                 if (output_format && output_format->supportsWritingException())\n                 {\n@@ -1745,7 +1747,7 @@ void executeQuery(\n                     }\n                 }\n             }\n-            catch (const DB::Exception & e)\n+            catch (const Exception & e)\n             {\n                 /// Ignore this exception and report the original one\n                 LOG_WARNING(getLogger(\"executeQuery\"), getExceptionMessageAndPattern(e, true));\n@@ -1755,7 +1757,7 @@ void executeQuery(\n \n     try\n     {\n-        std::tie(ast, streams) = executeQueryImpl(begin, end, context, flags, QueryProcessingStage::Complete, &istr);\n+        streams = executeQueryImpl(begin, end, context, flags, QueryProcessingStage::Complete, &istr, ast);\n     }\n     catch (...)\n     {\n@@ -1815,6 +1817,9 @@ void executeQuery(\n         else if (pipeline.pulling())\n         {\n             const ASTQueryWithOutput * ast_query_with_output = dynamic_cast<const ASTQueryWithOutput *>(ast.get());\n+            format_name = ast_query_with_output && ast_query_with_output->format_ast != nullptr\n+                ? getIdentifierName(ast_query_with_output->format_ast)\n+                : context->getDefaultFormat();\n \n             WriteBuffer * out_buf = &ostr;\n             if (ast_query_with_output && ast_query_with_output->out_file)\n@@ -1838,10 +1843,6 @@ void executeQuery(\n                     /* zstd_window_log = */ static_cast<int>(settings[Setting::output_format_compression_zstd_window_log]));\n             }\n \n-            format_name = ast_query_with_output && (ast_query_with_output->format_ast != nullptr)\n-                                    ? getIdentifierName(ast_query_with_output->format_ast)\n-                                    : context->getDefaultFormat();\n-\n             output_format = FormatFactory::instance().getOutputFormatParallelIfPossible(\n                 format_name,\n                 compressed_buffer ? *compressed_buffer : *out_buf,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03319_http_exception_formatting_during_interpretation.reference b/tests/queries/0_stateless/03319_http_exception_formatting_during_interpretation.reference\nnew file mode 100644\nindex 000000000000..3d60b2d19a49\n--- /dev/null\n+++ b/tests/queries/0_stateless/03319_http_exception_formatting_during_interpretation.reference\n@@ -0,0 +1,4 @@\n+< HTTP/1.1 404 Not Found\r\n+< X-ClickHouse-Format: JSONLines\r\n+< X-ClickHouse-Exception-Code: 81\r\n+{\"exception\": \"Code: 81. DB::Exception: Database nonexistent does not exist. (UNKNOWN_DATABASE) \"}\ndiff --git a/tests/queries/0_stateless/03319_http_exception_formatting_during_interpretation.sh b/tests/queries/0_stateless/03319_http_exception_formatting_during_interpretation.sh\nnew file mode 100755\nindex 000000000000..59af1489a153\n--- /dev/null\n+++ b/tests/queries/0_stateless/03319_http_exception_formatting_during_interpretation.sh\n@@ -0,0 +1,8 @@\n+#!/usr/bin/env bash\n+# Tags: long\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CURL} -v -sS \"${CLICKHOUSE_URL}\" -d \"SELECT * FROM nonexistent.nonexistent FORMAT JSONLines\" 2>&1 | grep -P 'X-ClickHouse-Format: |X-ClickHouse-Exception-Code: |\"exception\": |< HTTP/1\\.1 ' | sed -r -e 's/\\(version [^)]+\\)//'\n",
  "problem_statement": "UNKNOWN_TABLE does not use the output format when using http_write_exception_in_output_format\n**Describe what's wrong**\r\n\r\nThrowIf works fine and the exception is returned as part of the JSON response:\r\n```\r\ncurl -i 'localhost:8123/?http_write_exception_in_output_format=1&query=SELECT%20throwIf(1)%20FROM%20system.numbers%20FORMAT%20JSON'\r\nHTTP/1.1 200 OK\r\nDate: Mon, 09 Oct 2023 16:18:48 GMT\r\nConnection: Keep-Alive\r\nContent-Type: application/json; charset=UTF-8\r\nX-ClickHouse-Server-Display-Name: Mordor\r\nTransfer-Encoding: chunked\r\nX-ClickHouse-Query-Id: 18a3e4f2-b041-49e7-b9ba-850018ab1eb5\r\nX-ClickHouse-Format: JSON\r\nX-ClickHouse-Timezone: Europe/Madrid\r\nKeep-Alive: timeout=30\r\nX-ClickHouse-Summary: {\"read_rows\":\"65409\",\"read_bytes\":\"523272\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"0\",\"result_rows\":\"0\",\"result_bytes\":\"0\",\"elapsed_ns\":\"1004645\"}\r\n\r\n{\r\n        \"meta\":\r\n        [\r\n                {\r\n                        \"name\": \"throwIf(1)\",\r\n                        \"type\": \"UInt8\"\r\n                }\r\n        ],\r\n\r\n        \"data\":\r\n        [\r\n\r\n        ],\r\n\r\n        \"rows\": 0,\r\n\r\n        \"exception\": \"Code: 395. DB::Exception: Value passed to 'throwIf' function is non-zero: while executing 'FUNCTION throwIf(1 :: 0) -> throwIf(1) UInt8 : 1'. (FUNCTION_THROW_IF_VALUE_IS_NON_ZERO) (version 23.10.1.1)\"\r\n}\r\n```\r\n\r\nBut when the table doesn't exists you still get a plain text message and not JSON output, which is inconsistent:\r\n\r\n```\r\ncurl -i 'localhost:8123/?http_write_exception_in_output_format=1&query=SELECT%20throwIf(1)%20FROM%20not_existing%20FORMAT%20JSON'\r\nHTTP/1.1 404 Not Found\r\nDate: Mon, 09 Oct 2023 16:18:39 GMT\r\nConnection: Keep-Alive\r\nContent-Type: text/plain; charset=UTF-8\r\nX-ClickHouse-Server-Display-Name: Mordor\r\nTransfer-Encoding: chunked\r\nX-ClickHouse-Query-Id: b2fe023b-250b-44df-834f-359660364044\r\nX-ClickHouse-Timezone: Europe/Madrid\r\nX-ClickHouse-Exception-Code: 60\r\nKeep-Alive: timeout=30\r\nX-ClickHouse-Summary: {\"read_rows\":\"0\",\"read_bytes\":\"0\",\"written_rows\":\"0\",\"written_bytes\":\"0\",\"total_rows_to_read\":\"0\",\"result_rows\":\"0\",\"result_bytes\":\"0\",\"elapsed_ns\":\"516343\"}\r\n\r\nCode: 60. DB::Exception: Table default.not_existing does not exist. (UNKNOWN_TABLE) (version 23.10.1.1)\r\n```\r\n\r\nIdeally it should always use the output format.\r\n\r\nRelated to https://github.com/ClickHouse/ClickHouse/issues/6272\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nTested on master/HEAD\n",
  "hints_text": "",
  "created_at": "2025-01-23T23:10:50Z"
}