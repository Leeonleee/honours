{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33920,
  "instance_id": "ClickHouse__ClickHouse-33920",
  "issue_numbers": [
    "27073"
  ],
  "base_commit": "4ec2861d824f1297597cb66c61bffd6425da11e4",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionFactory.cpp b/src/AggregateFunctions/AggregateFunctionFactory.cpp\nindex eac761c1a827..347f4607dbf6 100644\n--- a/src/AggregateFunctions/AggregateFunctionFactory.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionFactory.cpp\n@@ -70,11 +70,11 @@ static DataTypes convertLowCardinalityTypesToNested(const DataTypes & types)\n AggregateFunctionPtr AggregateFunctionFactory::get(\n     const String & name, const DataTypes & argument_types, const Array & parameters, AggregateFunctionProperties & out_properties) const\n {\n-    auto type_without_low_cardinality = convertLowCardinalityTypesToNested(argument_types);\n+    auto types_without_low_cardinality = convertLowCardinalityTypesToNested(argument_types);\n \n     /// If one of the types is Nullable, we apply aggregate function combinator \"Null\".\n \n-    if (std::any_of(type_without_low_cardinality.begin(), type_without_low_cardinality.end(),\n+    if (std::any_of(types_without_low_cardinality.begin(), types_without_low_cardinality.end(),\n         [](const auto & type) { return type->isNullable(); }))\n     {\n         AggregateFunctionCombinatorPtr combinator = AggregateFunctionCombinatorFactory::instance().tryFindSuffix(\"Null\");\n@@ -82,10 +82,10 @@ AggregateFunctionPtr AggregateFunctionFactory::get(\n             throw Exception(\"Logical error: cannot find aggregate function combinator to apply a function to Nullable arguments.\",\n                 ErrorCodes::LOGICAL_ERROR);\n \n-        DataTypes nested_types = combinator->transformArguments(type_without_low_cardinality);\n+        DataTypes nested_types = combinator->transformArguments(types_without_low_cardinality);\n         Array nested_parameters = combinator->transformParameters(parameters);\n \n-        bool has_null_arguments = std::any_of(type_without_low_cardinality.begin(), type_without_low_cardinality.end(),\n+        bool has_null_arguments = std::any_of(types_without_low_cardinality.begin(), types_without_low_cardinality.end(),\n             [](const auto & type) { return type->onlyNull(); });\n \n         AggregateFunctionPtr nested_function = getImpl(\n@@ -97,13 +97,10 @@ AggregateFunctionPtr AggregateFunctionFactory::get(\n         // that are rewritten to AggregateFunctionNothing, in this case\n         // nested_function is nullptr.\n         if (!nested_function || !nested_function->isOnlyWindowFunction())\n-        {\n-            return combinator->transformAggregateFunction(nested_function,\n-                out_properties, type_without_low_cardinality, parameters);\n-        }\n+            return combinator->transformAggregateFunction(nested_function, out_properties, types_without_low_cardinality, parameters);\n     }\n \n-    auto with_original_arguments = getImpl(name, type_without_low_cardinality, parameters, out_properties, false);\n+    auto with_original_arguments = getImpl(name, types_without_low_cardinality, parameters, out_properties, false);\n \n     if (!with_original_arguments)\n         throw Exception(\"Logical error: AggregateFunctionFactory returned nullptr\", ErrorCodes::LOGICAL_ERROR);\ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.cpp b/src/AggregateFunctions/AggregateFunctionIf.cpp\nindex d752900c0187..5ba54ff8505f 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionIf.cpp\n@@ -40,28 +40,6 @@ class AggregateFunctionCombinatorIf final : public IAggregateFunctionCombinator\n     }\n };\n \n-/** Given an array of flags, checks if it's all zeros\n- *  When the buffer is all zeros, this is slightly faster than doing a memcmp since doesn't require allocating memory\n- *  When the buffer has values, this is much faster since it avoids visiting all memory (and the allocation and function calls)\n- */\n-static bool ALWAYS_INLINE inline is_all_zeros(const UInt8 * flags, size_t size)\n-{\n-    size_t unroll_size = size - size % 8;\n-    size_t i = 0;\n-    while (i < unroll_size)\n-    {\n-        UInt64 v = *reinterpret_cast<const UInt64 *>(&flags[i]);\n-        if (v)\n-            return false;\n-        i += 8;\n-    }\n-\n-    for (; i < size; ++i)\n-        if (flags[i])\n-            return false;\n-\n-    return true;\n-}\n \n /** There are two cases: for single argument and variadic.\n   * Code for single argument is much more efficient.\n@@ -73,6 +51,7 @@ class AggregateFunctionIfNullUnary final\n {\n private:\n     size_t num_arguments;\n+    bool filter_is_nullable = false;\n \n     /// The name of the nested function, including combinators (i.e. *If)\n     ///\n@@ -92,8 +71,26 @@ class AggregateFunctionIfNullUnary final\n \n     using Base = AggregateFunctionNullBase<result_is_nullable, serialize_flag,\n         AggregateFunctionIfNullUnary<result_is_nullable, serialize_flag>>;\n-public:\n \n+    inline bool singleFilter(const IColumn ** columns, size_t row_num, size_t num_arguments) const\n+    {\n+        const IColumn * filter_column = columns[num_arguments - 1];\n+\n+        if (filter_is_nullable)\n+        {\n+            const ColumnNullable * nullable_column = assert_cast<const ColumnNullable *>(filter_column);\n+            filter_column = nullable_column->getNestedColumnPtr().get();\n+            const UInt8 * filter_null_map = nullable_column->getNullMapData().data();\n+\n+            return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num] && !filter_null_map[row_num];\n+        }\n+        else\n+        {\n+            return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num];\n+        }\n+    }\n+\n+public:\n     String getName() const override\n     {\n         return name;\n@@ -105,17 +102,10 @@ class AggregateFunctionIfNullUnary final\n         , name(name_)\n     {\n         if (num_arguments == 0)\n-            throw Exception(\"Aggregate function \" + getName() + \" require at least one argument\",\n-                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH);\n-    }\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Aggregate function {} require at least one argument\", getName());\n \n-    static inline bool singleFilter(const IColumn ** columns, size_t row_num, size_t num_arguments)\n-    {\n-        const IColumn * filter_column = columns[num_arguments - 1];\n-        if (const ColumnNullable * nullable_column = typeid_cast<const ColumnNullable *>(filter_column))\n-            filter_column = nullable_column->getNestedColumnPtr().get();\n-\n-        return assert_cast<const ColumnUInt8 &>(*filter_column).getData()[row_num];\n+        filter_is_nullable = arguments[num_arguments - 1]->isNullable();\n     }\n \n     void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena * arena) const override\n@@ -136,29 +126,41 @@ class AggregateFunctionIfNullUnary final\n         const IColumn * columns_param[] = {&column->getNestedColumn()};\n \n         const IColumn * filter_column = columns[num_arguments - 1];\n-        if (const ColumnNullable * nullable_column = typeid_cast<const ColumnNullable *>(filter_column))\n-            filter_column = nullable_column->getNestedColumnPtr().get();\n-        if constexpr (result_is_nullable)\n+\n+        const UInt8 * filter_values = nullptr;\n+        const UInt8 * filter_null_map = nullptr;\n+\n+        if (filter_is_nullable)\n         {\n-            /// We need to check if there is work to do as otherwise setting the flag would be a mistake,\n-            /// it would mean that the return value would be the default value of the nested type instead of NULL\n-            if (is_all_zeros(assert_cast<const ColumnUInt8 *>(filter_column)->getData().data(), batch_size))\n-                return;\n+            const ColumnNullable * nullable_column = assert_cast<const ColumnNullable *>(filter_column);\n+            filter_column = nullable_column->getNestedColumnPtr().get();\n+            filter_null_map = nullable_column->getNullMapData().data();\n         }\n \n+        filter_values = assert_cast<const ColumnUInt8 *>(filter_column)->getData().data();\n+\n         /// Combine the 2 flag arrays so we can call a simplified version (one check vs 2)\n         /// Note that now the null map will contain 0 if not null and not filtered, or 1 for null or filtered (or both)\n-        const auto * filter_flags = assert_cast<const ColumnUInt8 *>(filter_column)->getData().data();\n+\n         auto final_nulls = std::make_unique<UInt8[]>(batch_size);\n-        for (size_t i = 0; i < batch_size; ++i)\n-            final_nulls[i] = (!!null_map[i]) | (!filter_flags[i]);\n \n-        this->nested_function->addBatchSinglePlaceNotNull(\n-            batch_size, this->nestedPlace(place), columns_param, final_nulls.get(), arena, -1);\n+        if (filter_null_map)\n+            for (size_t i = 0; i < batch_size; ++i)\n+                final_nulls[i] = (!!null_map[i]) | (!filter_values[i]) | (!!filter_null_map[i]);\n+        else\n+            for (size_t i = 0; i < batch_size; ++i)\n+                final_nulls[i] = (!!null_map[i]) | (!filter_values[i]);\n \n         if constexpr (result_is_nullable)\n-            if (!memoryIsByte(null_map, batch_size, 1))\n+        {\n+            if (!memoryIsByte(final_nulls.get(), batch_size, 1))\n                 this->setFlag(place);\n+            else\n+                return; /// No work to do.\n+        }\n+\n+        this->nested_function->addBatchSinglePlaceNotNull(\n+            batch_size, this->nestedPlace(place), columns_param, final_nulls.get(), arena, -1);\n     }\n \n #if USE_EMBEDDED_COMPILER\n@@ -367,10 +369,14 @@ AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(\n     const AggregateFunctionPtr & nested_function, const DataTypes & arguments,\n     const Array & params, const AggregateFunctionProperties & properties) const\n {\n-    bool return_type_is_nullable = !properties.returns_default_when_only_null && getReturnType()->canBeInsideNullable();\n-    size_t nullable_size = std::count_if(arguments.begin(), arguments.end(), [](const auto & element) { return element->isNullable(); });\n-    return_type_is_nullable &= nullable_size != 1 || !arguments.back()->isNullable();   /// If only condition is nullable. we should non-nullable type.\n-    bool serialize_flag = return_type_is_nullable || properties.returns_default_when_only_null;\n+    assert(!arguments.empty());\n+\n+    /// Nullability of the last argument (condition) does not affect the nullability of the result (NULL is processed as false).\n+    /// For other arguments it is as usual (at least one is NULL then the result is NULL if possible).\n+    bool return_type_is_nullable = !properties.returns_default_when_only_null && getReturnType()->canBeInsideNullable()\n+        && std::any_of(arguments.begin(), arguments.end() - 1, [](const auto & element) { return element->isNullable(); });\n+\n+    bool need_to_serialize_flag = return_type_is_nullable || properties.returns_default_when_only_null;\n \n     if (arguments.size() <= 2 && arguments.front()->isNullable())\n     {\n@@ -380,7 +386,7 @@ AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(\n         }\n         else\n         {\n-            if (serialize_flag)\n+            if (need_to_serialize_flag)\n                 return std::make_shared<AggregateFunctionIfNullUnary<false, true>>(nested_function->getName(), nested_func, arguments, params);\n             else\n                 return std::make_shared<AggregateFunctionIfNullUnary<false, false>>(nested_function->getName(), nested_func, arguments, params);\n@@ -394,7 +400,7 @@ AggregateFunctionPtr AggregateFunctionIf::getOwnNullAdapter(\n         }\n         else\n         {\n-            if (serialize_flag)\n+            if (need_to_serialize_flag)\n                 return std::make_shared<AggregateFunctionIfNullVariadic<false, true, true>>(nested_function, arguments, params);\n             else\n                 return std::make_shared<AggregateFunctionIfNullVariadic<false, false, true>>(nested_function, arguments, params);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02183_combinator_if.reference b/tests/queries/0_stateless/02183_combinator_if.reference\nnew file mode 100644\nindex 000000000000..05bda3751b5c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02183_combinator_if.reference\n@@ -0,0 +1,40 @@\n+\\N\n+\\N\n+Hello\n+Hello\n+Hello\n+\n+Hello\n+Hello\n+0\t\\N\n+1\t\\N\n+0\tHello\n+1\tHello\n+0\t\n+1\t\n+0\tHello\n+1\tHello\n+0\t\\N\n+1\t\\N\n+0\tHello\n+1\tHello\n+\\N\n+\\N\n+Hello\n+Hello\n+Hello\n+\n+Hello\n+Hello\n+0\t\\N\n+1\t\\N\n+0\tHello\n+1\tHello\n+0\t\n+1\t\n+0\tHello\n+1\tHello\n+0\t\\N\n+1\t\\N\n+0\tHello\n+1\tHello\ndiff --git a/tests/queries/0_stateless/02183_combinator_if.sql b/tests/queries/0_stateless/02183_combinator_if.sql\nnew file mode 100644\nindex 000000000000..ec7164079395\n--- /dev/null\n+++ b/tests/queries/0_stateless/02183_combinator_if.sql\n@@ -0,0 +1,40 @@\n+SELECT anyIf(toNullable('Hello'), arrayJoin([1, NULL]) = 0);\n+\n+SELECT anyIf(toNullable('Hello'), arrayJoin([1, 1]) = 0);\n+SELECT anyIf(toNullable('Hello'), arrayJoin([1, 0]) = 0);\n+SELECT anyIf(toNullable('Hello'), arrayJoin([0, 1]) = 0);\n+SELECT anyIf(toNullable('Hello'), arrayJoin([0, 0]) = 0);\n+\n+SELECT anyIf('Hello', arrayJoin([1, NULL]) = 0);\n+SELECT anyIf('Hello', arrayJoin([1, NULL]) = 1);\n+SELECT anyIf('Hello', arrayJoin([1, NULL]) IS NULL);\n+\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, NULL]) = 0) FROM numbers(2) GROUP BY number ORDER BY number;\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, NULL, 0]) = 0) FROM numbers(2) GROUP BY number ORDER BY number;\n+\n+SELECT number, anyIf('Hello', arrayJoin([1, NULL]) = 0) FROM numbers(2) GROUP BY number ORDER BY number;\n+SELECT number, anyIf('Hello', arrayJoin([1, NULL, 0]) = 0) FROM numbers(2) GROUP BY number ORDER BY number;\n+\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, 1]) = 0) FROM numbers(2) GROUP BY number ORDER BY number;\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, 0]) = 0) FROM numbers(2) GROUP BY number ORDER BY number;\n+\n+\n+SELECT anyIf(toNullable('Hello'), arrayJoin([1, NULL]) = 0) FROM remote('127.0.0.{1,2}', system.one);\n+\n+SELECT anyIf(toNullable('Hello'), arrayJoin([1, 1]) = 0) FROM remote('127.0.0.{1,2}', system.one);\n+SELECT anyIf(toNullable('Hello'), arrayJoin([1, 0]) = 0) FROM remote('127.0.0.{1,2}', system.one);\n+SELECT anyIf(toNullable('Hello'), arrayJoin([0, 1]) = 0) FROM remote('127.0.0.{1,2}', system.one);\n+SELECT anyIf(toNullable('Hello'), arrayJoin([0, 0]) = 0) FROM remote('127.0.0.{1,2}', system.one);\n+\n+SELECT anyIf('Hello', arrayJoin([1, NULL]) = 0) FROM remote('127.0.0.{1,2}', system.one);\n+SELECT anyIf('Hello', arrayJoin([1, NULL]) = 1) FROM remote('127.0.0.{1,2}', system.one);\n+SELECT anyIf('Hello', arrayJoin([1, NULL]) IS NULL) FROM remote('127.0.0.{1,2}', system.one);\n+\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, NULL]) = 0) FROM remote('127.0.0.{1,2}', numbers(2)) GROUP BY number ORDER BY number;\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, NULL, 0]) = 0) FROM remote('127.0.0.{1,2}', numbers(2)) GROUP BY number ORDER BY number;\n+\n+SELECT number, anyIf('Hello', arrayJoin([1, NULL]) = 0) FROM remote('127.0.0.{1,2}', numbers(2)) GROUP BY number ORDER BY number;\n+SELECT number, anyIf('Hello', arrayJoin([1, NULL, 0]) = 0) FROM remote('127.0.0.{1,2}', numbers(2)) GROUP BY number ORDER BY number;\n+\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, 1]) = 0) FROM remote('127.0.0.{1,2}', numbers(2)) GROUP BY number ORDER BY number;\n+SELECT number, anyIf(toNullable('Hello'), arrayJoin([1, 0]) = 0) FROM remote('127.0.0.{1,2}', numbers(2)) GROUP BY number ORDER BY number;\n",
  "problem_statement": "Invalid sumIf behavior with nullable arguments\n**Describe the bug**\r\n\r\n`sumIf` returns incorrect results in some cases with Nullable arguments.\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use\r\nLatest master/arcadia version\r\n\r\n* Queries to run that lead to unexpected result\r\n```sql\r\n:) select sumIf(toFloat64OrZero(b), a = 0) as r1, sumIf(cast(b as Float), a = 0) as r2, sum(if(a = 0, toFloat64OrZero(b), 0)) as r3 from (select arrayJoin([1, 2, 3, NULL]) as a, toNullable('10.0') as b)\r\n\r\nSELECT\r\n    sumIf(toFloat64OrZero(b), a = 0) AS r1,\r\n    sumIf(CAST(b, 'Float'), a = 0) AS r2,\r\n    sum(if(a = 0, toFloat64OrZero(b), 0)) AS r3\r\nFROM\r\n(\r\n    SELECT\r\n        arrayJoin([1, 2, 3, NULL]) AS a,\r\n        toNullable('10.0') AS b\r\n)\r\n\r\nQuery id: 2e4e320d-e52a-4514-bc6f-118485558191\r\n\r\n\u250c\u2500r1\u2500\u252c\u2500r2\u2500\u252c\u2500r3\u2500\u2510\r\n\u2502 10 \u2502  0 \u2502  0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2518\r\n```\r\n**Expected behavior**\r\n\r\nAll results are 0.\r\n\r\n**Additional context**\r\n\r\nIt breaks when null values in Nullable column are compared with `assumeNotNull` from this column.\r\nIt also only breaks when first argument is Nullable too.\r\n\r\n\n",
  "hints_text": "@DimasKovas which clickhouse server version do you use ?\n> @DimasKovas which clickhouse server version do you use ?\r\n\r\n@kitaisreal I reproduced it on latest master version (1f1795a305c3b170f6137309ccfa169efe4aa8f5), but originally it was found on master version which is ~ half a year old, so the bug exists for quite a while.\nSome tests:\r\n* 20.7.4.11: \u2502  0 \u2502  0 \u2502  0 \u2502\r\n* 20.8.2.3: \u2502 10 \u2502 10 \u2502  0 \u2502\r\n* 20.8.19.4: \u2502 10 \u2502  0 \u2502  0 \u2502\r\n* 21.3.17.2: \u2502 10 \u2502  0 \u2502  0 \u2502\r\n* 21.8.7.22: \u2502 10 \u2502  0 \u2502  0 \u2502\r\n* 21.9.4.35: \u2502 10 \u2502  0 \u2502  0 \u2502\r\n* Master/HEAD: \u2502 10 \u2502  0 \u2502  0 \u2502\r\n\r\nSo it is indeed an old issue. Something changed in 20.8 and it was partially \"reverted\" but not fully fixed.\nMinimal reproducing example:\r\n`SELECT anyIf(toNullable('Hello'), arrayJoin([1, NULL]) = 0)`\nBroken here: #13964",
  "created_at": "2022-01-23T05:30:00Z"
}