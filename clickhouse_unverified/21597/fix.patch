diff --git a/CMakeLists.txt b/CMakeLists.txt
index 9002f1df140c..76b79a0b6c84 100644
--- a/CMakeLists.txt
+++ b/CMakeLists.txt
@@ -169,7 +169,7 @@ endif ()
 set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -rdynamic")
 
 if (OS_LINUX)
-    find_program (OBJCOPY_PATH NAMES "llvm-objcopy" "llvm-objcopy-11" "llvm-objcopy-10" "llvm-objcopy-9" "llvm-objcopy-8" "objcopy")
+    find_program (OBJCOPY_PATH NAMES "llvm-objcopy" "llvm-objcopy-12" "llvm-objcopy-11" "llvm-objcopy-10" "llvm-objcopy-9" "llvm-objcopy-8" "objcopy")
     if (OBJCOPY_PATH)
         message(STATUS "Using objcopy: ${OBJCOPY_PATH}.")
 
@@ -331,7 +331,7 @@ if (COMPILER_CLANG)
     endif ()
 
     # Always prefer llvm tools when using clang. For instance, we cannot use GNU ar when llvm LTO is enabled
-    find_program (LLVM_AR_PATH NAMES "llvm-ar" "llvm-ar-11" "llvm-ar-10" "llvm-ar-9" "llvm-ar-8")
+    find_program (LLVM_AR_PATH NAMES "llvm-ar" "llvm-ar-12" "llvm-ar-11" "llvm-ar-10" "llvm-ar-9" "llvm-ar-8")
 
     if (LLVM_AR_PATH)
         message(STATUS "Using llvm-ar: ${LLVM_AR_PATH}.")
@@ -340,7 +340,7 @@ if (COMPILER_CLANG)
         message(WARNING "Cannot find llvm-ar. System ar will be used instead. It does not work with ThinLTO.")
     endif ()
 
-    find_program (LLVM_RANLIB_PATH NAMES "llvm-ranlib" "llvm-ranlib-11" "llvm-ranlib-10" "llvm-ranlib-9" "llvm-ranlib-8")
+    find_program (LLVM_RANLIB_PATH NAMES "llvm-ranlib" "llvm-ranlib-12" "llvm-ranlib-11" "llvm-ranlib-10" "llvm-ranlib-9" "llvm-ranlib-8")
 
     if (LLVM_RANLIB_PATH)
         message(STATUS "Using llvm-ranlib: ${LLVM_RANLIB_PATH}.")
diff --git a/base/common/wide_integer_impl.h b/base/common/wide_integer_impl.h
index a34e757eaa5b..5b981326e259 100644
--- a/base/common/wide_integer_impl.h
+++ b/base/common/wide_integer_impl.h
@@ -249,15 +249,15 @@ struct integer<Bits, Signed>::_impl
             return;
         }
 
-        const T alpha = t / max_int;
+        const T alpha = t / static_cast<T>(max_int);
 
-        if (alpha <= max_int)
+        if (alpha <= static_cast<T>(max_int))
             self = static_cast<uint64_t>(alpha);
         else // max(double) / 2^64 will surely contain less than 52 precision bits, so speed up computations.
             set_multiplier<double>(self, alpha);
 
         self *= max_int;
-        self += static_cast<uint64_t>(t - alpha * max_int); // += b_i
+        self += static_cast<uint64_t>(t - alpha * static_cast<T>(max_int)); // += b_i
     }
 
     constexpr static void wide_integer_from_bultin(integer<Bits, Signed>& self, double rhs) noexcept {
@@ -275,7 +275,7 @@ struct integer<Bits, Signed>::_impl
             "On your system long double has less than 64 precision bits,"
             "which may result in UB when initializing double from int64_t");
 
-        if ((rhs > 0 && rhs < max_int) || (rhs < 0 && rhs > min_int))
+        if ((rhs > 0 && rhs < static_cast<long double>(max_int)) || (rhs < 0 && rhs > static_cast<long double>(min_int)))
         {
             self = static_cast<int64_t>(rhs);
             return;
diff --git a/base/readpassphrase/CMakeLists.txt b/base/readpassphrase/CMakeLists.txt
index 574130ce6e39..51b12106eca6 100644
--- a/base/readpassphrase/CMakeLists.txt
+++ b/base/readpassphrase/CMakeLists.txt
@@ -4,5 +4,5 @@
 add_library(readpassphrase readpassphrase.c)
 
 set_target_properties(readpassphrase PROPERTIES LINKER_LANGUAGE C)
-target_compile_options(readpassphrase PRIVATE -Wno-unused-result -Wno-reserved-id-macro)
+target_compile_options(readpassphrase PRIVATE -Wno-unused-result -Wno-reserved-id-macro -Wno-disabled-macro-expansion)
 target_include_directories(readpassphrase PUBLIC .)
diff --git a/base/readpassphrase/readpassphrase.c b/base/readpassphrase/readpassphrase.c
index 9e8097643bb4..8a7d31539150 100644
--- a/base/readpassphrase/readpassphrase.c
+++ b/base/readpassphrase/readpassphrase.c
@@ -94,7 +94,7 @@ readpassphrase(const char *prompt, char *buf, size_t bufsiz, int flags)
     if (input != STDIN_FILENO && tcgetattr(input, &oterm) == 0) {
         memcpy(&term, &oterm, sizeof(term));
         if (!(flags & RPP_ECHO_ON))
-            term.c_lflag &= ~(ECHO | ECHONL);
+            term.c_lflag &= ~((unsigned int) (ECHO | ECHONL));
 #ifdef VSTATUS
         if (term.c_cc[VSTATUS] != _POSIX_VDISABLE)
             term.c_cc[VSTATUS] = _POSIX_VDISABLE;
diff --git a/cmake/tools.cmake b/cmake/tools.cmake
index cc4046d24696..abb11843d594 100644
--- a/cmake/tools.cmake
+++ b/cmake/tools.cmake
@@ -75,8 +75,13 @@ if (OS_LINUX AND NOT LINKER_NAME)
 endif ()
 
 if (LINKER_NAME)
-    set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=${LINKER_NAME}")
-    set (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fuse-ld=${LINKER_NAME}")
+    if (COMPILER_CLANG AND (CMAKE_CXX_COMPILER_VERSION VERSION_GREATER 12.0.0 OR CMAKE_CXX_COMPILER_VERSION VERSION_EQUAL 12.0.0))
+        set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} --ld-path=${LINKER_NAME}")
+        set (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} --ld-path=${LINKER_NAME}")
+    else ()
+        set (CMAKE_EXE_LINKER_FLAGS "${CMAKE_EXE_LINKER_FLAGS} -fuse-ld=${LINKER_NAME}")
+        set (CMAKE_SHARED_LINKER_FLAGS "${CMAKE_SHARED_LINKER_FLAGS} -fuse-ld=${LINKER_NAME}")
+    endif ()
 
     message(STATUS "Using custom linker by name: ${LINKER_NAME}")
 endif ()
diff --git a/contrib/boringssl b/contrib/boringssl
index 8b2bf912ba04..fd9ce1a0406f 160000
--- a/contrib/boringssl
+++ b/contrib/boringssl
@@ -1,1 +1,1 @@
-Subproject commit 8b2bf912ba04823cfe9e7e8f5bb60cb7f6252449
+Subproject commit fd9ce1a0406f571507068b9555d0b545b8a18332
diff --git a/contrib/cassandra b/contrib/cassandra
index b446d7eb68e6..c097fb5c7e63 160000
--- a/contrib/cassandra
+++ b/contrib/cassandra
@@ -1,1 +1,1 @@
-Subproject commit b446d7eb68e6962f431e2b3771313bfe9a2bbd93
+Subproject commit c097fb5c7e63cc430016d9a8b240d8e63fbefa52
diff --git a/contrib/mariadb-connector-c b/contrib/mariadb-connector-c
index 21f451d4d315..f4476ee7311b 160000
--- a/contrib/mariadb-connector-c
+++ b/contrib/mariadb-connector-c
@@ -1,1 +1,1 @@
-Subproject commit 21f451d4d3157ffed31ec60a8b76c407190e66bd
+Subproject commit f4476ee7311b35b593750f6ae2cbdb62a4006374
diff --git a/docs/en/development/build.md b/docs/en/development/build.md
index f98329e748f8..3181f26800d0 100644
--- a/docs/en/development/build.md
+++ b/docs/en/development/build.md
@@ -170,7 +170,7 @@ $ ./release
 Normally all tools of the ClickHouse bundle, such as `clickhouse-server`, `clickhouse-client` etc., are linked into a single static executable, `clickhouse`. This executable must be re-linked on every change, which might be slow. Two common ways to improve linking time are to use `lld` linker, and use the 'split' build configuration, which builds a separate binary for every tool, and further splits the code into serveral shared libraries. To enable these tweaks, pass the following flags to `cmake`:
 
 ```
--DCMAKE_C_FLAGS="-fuse-ld=lld" -DCMAKE_CXX_FLAGS="-fuse-ld=lld" -DUSE_STATIC_LIBRARIES=0 -DSPLIT_SHARED_LIBRARIES=1 -DCLICKHOUSE_SPLIT_BINARY=1
+-DCMAKE_C_FLAGS="--ld-path=lld" -DCMAKE_CXX_FLAGS="--ld-path=lld" -DUSE_STATIC_LIBRARIES=0 -DSPLIT_SHARED_LIBRARIES=1 -DCLICKHOUSE_SPLIT_BINARY=1
 ```
 
 ## You Donâ€™t Have to Build ClickHouse {#you-dont-have-to-build-clickhouse}
diff --git a/src/Functions/DivisionUtils.h b/src/Functions/DivisionUtils.h
index 2b4c07b1cfff..174ea7ee7975 100644
--- a/src/Functions/DivisionUtils.h
+++ b/src/Functions/DivisionUtils.h
@@ -105,7 +105,7 @@ struct DivideIntegralImpl
             auto res = checkedDivision(CastA(a), CastB(b));
 
             if constexpr (std::is_floating_point_v<decltype(res)>)
-                if (isNaN(res) || res >= std::numeric_limits<Result>::max() || res <= std::numeric_limits<Result>::lowest())
+                if (isNaN(res) || res >= static_cast<double>(std::numeric_limits<Result>::max()) || res <= std::numeric_limits<Result>::lowest())
                     throw Exception("Cannot perform integer division, because it will produce infinite or too large number",
                         ErrorCodes::ILLEGAL_DIVISION);
 
