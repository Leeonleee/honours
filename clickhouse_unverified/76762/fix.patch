diff --git a/docs/en/engines/table-engines/integrations/mongodb.md b/docs/en/engines/table-engines/integrations/mongodb.md
index 21143a5b12df..8e67e5b262f8 100644
--- a/docs/en/engines/table-engines/integrations/mongodb.md
+++ b/docs/en/engines/table-engines/integrations/mongodb.md
@@ -26,7 +26,7 @@ CREATE TABLE [IF NOT EXISTS] [db.]table_name
     name1 [type1],
     name2 [type2],
     ...
-) ENGINE = MongoDB(host:port, database, collection, user, password [, options]);
+) ENGINE = MongoDB(host:port, database, collection, user, password[, options[, oid_columns]]);
 ```
 
 **Engine Parameters**
@@ -43,40 +43,98 @@ CREATE TABLE [IF NOT EXISTS] [db.]table_name
 
 - `options` — MongoDB connection string options (optional parameter).
 
+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.
+
 :::tip
 If you are using the MongoDB Atlas cloud offering connection url can be obtained from 'Atlas SQL' option.
 Seed list(`mongodb**+srv**`) is not yet supported, but will be added in future releases.
 :::
 
-Also, you can simply pass a URI:
+Alternatively, you can pass a URI:
 
 ``` sql
-ENGINE = MongoDB(uri, collection);
+ENGINE = MongoDB(uri, collection[, oid_columns]);
 ```
 
 **Engine Parameters**
 
-- `uri` — MongoDB server's connection URI
+- `uri` — MongoDB server's connection URI.
 
 - `collection` — Remote collection name.
 
+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.
+
 
 ## Types mappings {#types-mappings}
 
-| MongoDB            | ClickHouse                                                            |
-|--------------------|-----------------------------------------------------------------------|
-| bool, int32, int64 | *any numeric type*, String                                            |
-| double             | Float64, String                                                       |
-| date               | Date, Date32, DateTime, DateTime64, String                            |
-| string             | String, UUID                                                          |
-| document           | String(as JSON)                                                       |
-| array              | Array, String(as JSON)                                                |
-| oid                | String                                                                |
-| binary             | String if in column, base64 encoded string if in an array or document |
-| *any other*        | String                                                                |
+| MongoDB                 | ClickHouse                                                            |
+|-------------------------|-----------------------------------------------------------------------|
+| bool, int32, int64      | *any numeric type*, String                                            |
+| double                  | Float64, String                                                       |
+| date                    | Date, Date32, DateTime, DateTime64, String                            |
+| string                  | String                                                                |
+| document                | String(as JSON)                                                       |
+| array                   | Array, String(as JSON)                                                |
+| oid                     | String                                                                |
+| binary                  | String if in column, base64 encoded string if in an array or document |
+| uuid (binary subtype 4) | UUID                                                                  |
+| *any other*             | String                                                                |
 
 If key is not found in MongoDB document (for example, column name doesn't match), default value or `NULL` (if the column is nullable) will be inserted.
 
+### OID {#oid}
+
+If you want a `String` to be treated as `oid` in the WHERE clause, just put the column's name in the last argument of the table engine.
+This may be necessary when querying a record by the `_id` column, which by default has `oid` type in MongoDB.
+If the `_id` field in the table has other type, for example `uuid`, you need to specify empty `oid_columns`, otherwise the default value for this parameter `_id` is used.
+
+```javascript
+db.sample_oid.insertMany([
+    {"another_oid_column": ObjectId()},
+]);
+
+db.sample_oid.find();
+[
+    {
+        "_id": {"$oid": "67bf6cc44ebc466d33d42fb2"},
+        "another_oid_column": {"$oid": "67bf6cc40000000000ea41b1"}
+    }
+]
+```
+
+By default, only `_id` is treated as `oid` column.
+
+```sql
+CREATE TABLE sample_oid
+(
+    _id String,
+    another_oid_column String
+) ENGINE = MongoDB('mongodb://user:pass@host/db', 'sample_oid');
+
+SELECT count() FROM sample_oid WHERE _id = '67bf6cc44ebc466d33d42fb2'; --will output 1.
+SELECT count() FROM sample_oid WHERE another_oid_column = '67bf6cc40000000000ea41b1'; --will output 0
+```
+
+In this case the output will be `0`, because ClickHouse doesn't know that `another_oid_column` has `oid` type, so let's fix it:
+
+```sql
+CREATE TABLE sample_oid
+(
+    _id String,
+    another_oid_column String
+) ENGINE = MongoDB('mongodb://user:pass@host/db', 'sample_oid', '_id,another_oid_column');
+
+-- or
+
+CREATE TABLE sample_oid
+(
+    _id String,
+    another_oid_column String
+) ENGINE = MongoDB('host', 'db', 'sample_oid', 'user', 'pass', '', '_id,another_oid_column');
+
+SELECT count() FROM sample_oid WHERE another_oid_column = '67bf6cc40000000000ea41b1'; -- will output 1 now
+```
+
 ## Supported clauses {#supported-clauses}
 
 Only queries with simple expressions are supported (for example, `WHERE field = <constant> ORDER BY field2 LIMIT <constant>`).
diff --git a/docs/en/sql-reference/table-functions/mongodb.md b/docs/en/sql-reference/table-functions/mongodb.md
index f1bf66aa43f1..5fde7339bd22 100644
--- a/docs/en/sql-reference/table-functions/mongodb.md
+++ b/docs/en/sql-reference/table-functions/mongodb.md
@@ -13,7 +13,7 @@ Allows `SELECT` queries to be performed on data that is stored on a remote Mongo
 **Syntax**
 
 ``` sql
-mongodb(host:port, database, collection, user, password, structure [, options])
+mongodb(host:port, database, collection, user, password, structure[, options[, oid_columns]])
 ```
 
 **Arguments**
@@ -32,19 +32,22 @@ mongodb(host:port, database, collection, user, password, structure [, options])
 
 - `options` - MongoDB connection string options (optional parameter).
 
+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.
+
 :::tip
 If you are using the MongoDB Atlas cloud offering please add these options:
 
 ```ini
 'connectTimeoutMS=10000&ssl=true&authSource=admin'
 ```
-
 :::
 
-Also, you can connect by URI:
+You can also connect by URI:
+
 ``` sql
-mongodb(uri, collection, structure)
+mongodb(uri, collection, structure[, oid_columns])
 ```
+
 **Arguments**
 
 - `uri` — Connection string.
@@ -53,6 +56,8 @@ mongodb(uri, collection, structure)
 
 - `structure` — The schema for the ClickHouse table returned from this function.
 
+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.
+
 **Returned Value**
 
 A table object with the same columns as the original MongoDB table.
diff --git a/src/Common/BSONCXXHelper.h b/src/Common/BSONCXXHelper.h
index ce2d9aab6eba..db9d15df35f5 100644
--- a/src/Common/BSONCXXHelper.h
+++ b/src/Common/BSONCXXHelper.h
@@ -4,8 +4,13 @@
 
 #if USE_MONGODB
 #include <Common/Base64.h>
-#include <DataTypes/FieldToDataType.h>
+#include <Common/JSONBuilder.h>
+#include <IO/ReadBufferFromMemory.h>
 #include <IO/ReadHelpers.h>
+#include <DataTypes/FieldToDataType.h>
+#include "DataTypes/DataTypeNullable.h"
+
+#include <mongocxx/client.hpp>
 
 namespace DB
 {
@@ -24,13 +29,27 @@ using bsoncxx::builder::basic::document;
 using bsoncxx::builder::basic::kvp;
 using bsoncxx::builder::basic::make_document;
 
-static bsoncxx::types::bson_value::value fieldAsBSONValue(const Field & field, const DataTypePtr & type)
+static bsoncxx::types::bson_value::value fieldAsBSONValue(const Field & field, const DataTypePtr & type, const bool is_oid)
 {
-    switch (type->getTypeId())
+    if (field.isNull())
+        return bsoncxx::types::b_null{};
+
+    auto type_id = type->getTypeId();
+    if (type->isNullable())
+        type_id = typeid_cast<const DataTypeNullable *>(type.get())->getNestedType()->getTypeId();
+
+    switch (type_id)
     {
+        case TypeIndex::Nothing:
+            return bsoncxx::types::b_null{};
         case TypeIndex::String:
+        {
+            if (is_oid)
+                return bsoncxx::oid(field.safeGet<String>());
             return bsoncxx::types::b_string{field.safeGet<String>()};
-        case TypeIndex::UInt8: {
+        }
+        case TypeIndex::UInt8:
+        {
             if (isBool(type))
                 return bsoncxx::types::b_bool{field.safeGet<UInt8>() != 0};
             return bsoncxx::types::b_int32{static_cast<Int32>(field.safeGet<UInt8>())};
@@ -60,17 +79,32 @@ static bsoncxx::types::bson_value::value fieldAsBSONValue(const Field & field, c
         case TypeIndex::DateTime:
             return bsoncxx::types::b_date{std::chrono::seconds{field.safeGet<UInt32>()}};
         case TypeIndex::UUID:
-            return bsoncxx::types::b_string{String{formatUUID(field.safeGet<UUID>()).data()}};
-        case TypeIndex::Tuple: {
-            auto arr = array();
+        {
+            uint64_t uuid_numbers[2];
+            if constexpr (std::endian::native == std::endian::little)
+            {
+                uuid_numbers[0] = std::byteswap(field.safeGet<UUID>().toUnderType().items[0]);
+                uuid_numbers[1] = std::byteswap(field.safeGet<UUID>().toUnderType().items[1]);
+            } else
+            {
+                uuid_numbers[0] = field.safeGet<UUID>().toUnderType().items[0];
+                uuid_numbers[1] = field.safeGet<UUID>().toUnderType().items[1];
+            }
+            return bsoncxx::types::bson_value::value(reinterpret_cast<const uint8_t*>(&uuid_numbers[0]),
+                16, bsoncxx::binary_sub_type::k_uuid);
+        }
+        case TypeIndex::Tuple:
+        {
+            auto arr = bsoncxx::v_noabi::builder::basic::array();
             for (const auto & elem : field.safeGet<Tuple>())
-                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem)));
+                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem), is_oid));
             return arr.view();
         }
-        case TypeIndex::Array: {
-            auto arr = array();
+        case TypeIndex::Array:
+        {
+            auto arr = bsoncxx::v_noabi::builder::basic::array();
             for (const auto & elem : field.safeGet<Array>())
-                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem)));
+                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem), is_oid));
             return arr.view();
         }
         default:
@@ -279,7 +313,8 @@ static Array BSONArrayAsArray(
                     case TypeIndex::Float64:
                         arr.emplace_back(BSONElementAsNumber<Float64, bsoncxx::array::element>(value, name));
                         break;
-                    case TypeIndex::Date: {
+                    case TypeIndex::Date:
+                    {
                         if (value.type() != bsoncxx::type::k_date)
                             throw Exception(
                                 ErrorCodes::TYPE_MISMATCH,
@@ -290,7 +325,8 @@ static Array BSONArrayAsArray(
                         arr.emplace_back(DateLUT::instance().toDayNum(value.get_date().to_int64() / 1000).toUnderType());
                         break;
                     }
-                    case TypeIndex::Date32: {
+                    case TypeIndex::Date32:
+                    {
                         if (value.type() != bsoncxx::type::k_date)
                             throw Exception(
                                 ErrorCodes::TYPE_MISMATCH,
@@ -301,7 +337,8 @@ static Array BSONArrayAsArray(
                         arr.emplace_back(DateLUT::instance().toDayNum(value.get_date().to_int64() / 1000).toUnderType());
                         break;
                     }
-                    case TypeIndex::DateTime: {
+                    case TypeIndex::DateTime:
+                    {
                         if (value.type() != bsoncxx::type::k_date)
                             throw Exception(
                                 ErrorCodes::TYPE_MISMATCH,
@@ -312,7 +349,8 @@ static Array BSONArrayAsArray(
                         arr.emplace_back(static_cast<UInt32>(value.get_date().to_int64() / 1000));
                         break;
                     }
-                    case TypeIndex::DateTime64: {
+                    case TypeIndex::DateTime64:
+                    {
                         if (value.type() != bsoncxx::type::k_date)
                             throw Exception(
                                 ErrorCodes::TYPE_MISMATCH,
@@ -323,15 +361,21 @@ static Array BSONArrayAsArray(
                         arr.emplace_back(static_cast<Decimal64>(value.get_date().to_int64()));
                         break;
                     }
-                    case TypeIndex::UUID: {
-                        if (value.type() != bsoncxx::type::k_string)
-                            throw Exception(
-                                ErrorCodes::TYPE_MISMATCH,
-                                "Type mismatch, expected string (UUID), got {} for column {}.",
-                                bsoncxx::to_string(value.type()),
-                                name);
+                    case TypeIndex::UUID:
+                    {
+                        if (value.type() != bsoncxx::type::k_binary)
+                            throw Exception(ErrorCodes::TYPE_MISMATCH, "Type mismatch, expected uuid(binary subtype 4), got {} for column {}.",
+                                            bsoncxx::to_string(value.type()), name);
+                        if (value.get_binary().sub_type != bsoncxx::binary_sub_type::k_uuid || value.get_binary().size != 16)
+                            throw Exception(ErrorCodes::TYPE_MISMATCH, "Binary of type {} with size cannot be parsed to UUID for column {}.",
+                                bsoncxx::to_string(value.get_binary().sub_type), name);
+
+                        UInt128 uuid_number;
+                        auto valBuf = ReadBufferFromMemory(value.get_binary().bytes, value.get_binary().size);
+                        readBinaryBigEndian(uuid_number.items[0], valBuf);
+                        readBinaryBigEndian(uuid_number.items[1], valBuf);
 
-                        arr.emplace_back(parse<UUID>(value.get_string().value.data()));
+                        arr.emplace_back(UUID(std::move(uuid_number)));
                         break;
                     }
                     case TypeIndex::String:
@@ -349,29 +393,6 @@ static Array BSONArrayAsArray(
     }
     return arr;
 }
-
-static bsoncxx::types::bson_value::value fieldAsOID(const Field & field)
-{
-    switch (field.getType())
-    {
-        case Field::Types::String:
-            return bsoncxx::oid(field.safeGet<String>());
-        case Field::Types::Array: {
-            auto arr = array();
-            for (const auto & elem : field.safeGet<Array>())
-                arr.append(fieldAsOID(elem));
-            return arr.view();
-        }
-        case Field::Types::Tuple: {
-            auto tuple = array();
-            for (const auto & elem : field.safeGet<Tuple>())
-                tuple.append(fieldAsOID(elem));
-            return tuple.view();
-        }
-        default:
-            throw Exception(ErrorCodes::TYPE_MISMATCH, "{} can't be converted to oid.", field.getType());
-    }
-}
 }
 
 }
diff --git a/src/Processors/Sources/MongoDBSource.cpp b/src/Processors/Sources/MongoDBSource.cpp
index f593f36a318b..fdfa50291944 100644
--- a/src/Processors/Sources/MongoDBSource.cpp
+++ b/src/Processors/Sources/MongoDBSource.cpp
@@ -117,11 +117,19 @@ void MongoDBSource::insertValue(IColumn & column, const size_t & idx, const Data
         }
         case TypeIndex::UUID:
         {
-            if (value.type() != bsoncxx::type::k_string)
-                throw Exception(ErrorCodes::TYPE_MISMATCH, "Type mismatch, expected string (UUID), got {} for column {}",
+            if (value.type() != bsoncxx::type::k_binary)
+                throw Exception(ErrorCodes::TYPE_MISMATCH, "Type mismatch, expected uuid(binary subtype 4), got {} for column {}",
                                 bsoncxx::to_string(value.type()), name);
+            if (value.get_binary().sub_type != bsoncxx::binary_sub_type::k_uuid || value.get_binary().size != 16)
+                throw Exception(ErrorCodes::TYPE_MISMATCH, "Binary of type {} cannot be parsed to UUID for column {}",
+                    bsoncxx::to_string(value.get_binary().sub_type), name);
 
-            assert_cast<ColumnUUID &>(column).insertValue(parse<UUID>(value.get_string().value.data()));
+            UInt128 uuid_number;
+            auto valBuf = ReadBufferFromMemory(value.get_binary().bytes, value.get_binary().size);
+            readBinaryBigEndian(uuid_number.items[0], valBuf);
+            readBinaryBigEndian(uuid_number.items[1], valBuf);
+
+            assert_cast<ColumnUUID &>(column).insertValue(UUID(std::move(uuid_number)));
             break;
         }
         case TypeIndex::String:
diff --git a/src/Storages/StorageMongoDB.cpp b/src/Storages/StorageMongoDB.cpp
index 3c5bc244d3a8..9cf5a2c91796 100644
--- a/src/Storages/StorageMongoDB.cpp
+++ b/src/Storages/StorageMongoDB.cpp
@@ -1,15 +1,21 @@
 #include "config.h"
 
 #if USE_MONGODB
-#include <memory>
 
 #include <Analyzer/ColumnNode.h>
 #include <Analyzer/ConstantNode.h>
 #include <Analyzer/FunctionNode.h>
-#include <Analyzer/QueryNode.h>
-#include <Analyzer/TableNode.h>
 #include <Analyzer/JoinNode.h>
+#include <Analyzer/QueryNode.h>
 #include <Analyzer/SortNode.h>
+#include <Analyzer/TableFunctionNode.h>
+#include <Analyzer/TableNode.h>
+#include <Common/BSONCXXHelper.h>
+#include <Common/ErrorCodes.h>
+#include <Common/logger_useful.h>
+#include <Common/parseAddress.h>
+#include <Core/Joins.h>
+#include <Core/Settings.h>
 #include <Formats/BSONTypes.h>
 #include <Interpreters/evaluateConstantExpression.h>
 #include <Parsers/ASTIdentifier.h>
@@ -19,15 +25,14 @@
 #include <Storages/StorageFactory.h>
 #include <Storages/StorageMongoDB.h>
 #include <Storages/checkAndGetLiteralArgument.h>
-#include <Common/parseAddress.h>
-#include <Common/ErrorCodes.h>
-#include <Common/BSONCXXHelper.h>
-#include <Common/logger_useful.h>
-#include <Core/Settings.h>
-#include <Core/Joins.h>
 
 #include <bsoncxx/json.hpp>
 
+#include <boost/algorithm/string/classification.hpp>
+#include <boost/algorithm/string/split.hpp>
+
+#include <memory>
+
 using bsoncxx::builder::basic::document;
 using bsoncxx::builder::basic::make_document;
 using bsoncxx::builder::basic::make_array;
@@ -49,9 +54,6 @@ namespace Setting
     extern const SettingsBool mongodb_throw_on_unsupported_query;
 }
 
-using BSONCXXHelper::fieldAsBSONValue;
-using BSONCXXHelper::fieldAsOID;
-
 StorageMongoDB::StorageMongoDB(
     const StorageID & table_id_,
     MongoDBConfiguration configuration_,
@@ -100,12 +102,13 @@ MongoDBConfiguration StorageMongoDB::getConfiguration(ASTs engine_args, ContextP
     {
         if (named_collection->has("uri"))
         {
-            validateNamedCollection(*named_collection, {"collection"}, {"uri"});
+            validateNamedCollection(*named_collection, {"uri", "collection"}, {"oid_columns"});
             configuration.uri = std::make_unique<mongocxx::uri>(named_collection->get<String>("uri"));
         }
         else
         {
-            validateNamedCollection(*named_collection, {"host", "port", "user", "password", "database", "collection"}, {"options"});
+            validateNamedCollection(*named_collection, {
+                "host", "port", "user", "password", "database", "collection"}, {"options", "oid_columns"});
             String user = named_collection->get<String>("user");
             String auth_string;
             if (!user.empty())
@@ -118,18 +121,20 @@ MongoDBConfiguration StorageMongoDB::getConfiguration(ASTs engine_args, ContextP
                                                           named_collection->getOrDefault<String>("options", "")));
         }
         configuration.collection = named_collection->get<String>("collection");
+        if (named_collection->has("oid_columns"))
+            boost::split(configuration.oid_fields, named_collection->get<String>("oid_columns"), boost::is_any_of(","));
     }
     else
     {
         for (auto & engine_arg : engine_args)
             engine_arg = evaluateConstantExpressionOrIdentifierAsLiteral(engine_arg, context);
 
-        if (engine_args.size() == 5 || engine_args.size() == 6)
+        if (engine_args.size() >= 5 && engine_args.size() <= 7)
         {
             configuration.collection = checkAndGetLiteralArgument<String>(engine_args[2], "collection");
 
             String options;
-            if (engine_args.size() == 6)
+            if (engine_args.size() >= 6)
                 options = checkAndGetLiteralArgument<String>(engine_args[5], "options");
 
             String user = checkAndGetLiteralArgument<String>(engine_args[3], "user");
@@ -143,16 +148,22 @@ MongoDBConfiguration StorageMongoDB::getConfiguration(ASTs engine_args, ContextP
                                                               parsed_host_port.second,
                                                               checkAndGetLiteralArgument<String>(engine_args[1], "database"),
                                                               options));
+            if (engine_args.size() == 7)
+                boost::split(configuration.oid_fields,
+                    checkAndGetLiteralArgument<String>(engine_args[6], "oid_columns"), boost::is_any_of(","));
         }
-        else if (engine_args.size() == 2)
+        else if (engine_args.size() == 2 || engine_args.size() == 3)
         {
             configuration.collection = checkAndGetLiteralArgument<String>(engine_args[1], "database");
             configuration.uri =  std::make_unique<mongocxx::uri>(checkAndGetLiteralArgument<String>(engine_args[0], "host"));
+            if (engine_args.size() == 3)
+                boost::split(configuration.oid_fields,
+                    checkAndGetLiteralArgument<String>(engine_args[2], "oid_columns"), boost::is_any_of(","));
         }
         else
             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                                "Storage MongoDB requires 2 or from to 5 to 6 parameters: "
-                                "MongoDB('host:port', 'database', 'collection', 'user', 'password' [, 'options']) or MongoDB('uri', 'collection').");
+                                "Incorrect number of arguments. Example usage: "
+                                "MongoDB('host:port', 'database', 'collection', 'user', 'password'[, options[, oid_columns]]) or MongoDB('uri', 'collection'[, oid columns]).");
     }
 
     configuration.checkHosts(context);
@@ -202,11 +213,14 @@ std::optional<bsoncxx::document::value> StorageMongoDB::visitWhereFunction(
     {
         // Skip unknown columns, which don't belong to the table.
         const auto & table = column->getColumnSource()->as<TableNode>();
-        if (!table)
+        const auto & table_function = column->getColumnSource()->as<TableFunctionNode>();
+        if (!table && !table_function)
             return {};
 
         // Skip columns from other tables in JOIN queries.
-        if (table->getStorage()->getStorageID() != this->getStorageID())
+        if (table && table->getStorage()->getStorageID() != this->getStorageID())
+            return {};
+        if (table_function && table_function->getStorage()->getStorageID() != this->getStorageID())
             return {};
         if (join_node && column->getColumnSource() != join_node->getLeftTableExpression())
             return {};
@@ -224,6 +238,7 @@ std::optional<bsoncxx::document::value> StorageMongoDB::visitWhereFunction(
         auto func_name = mongoFuncName(func->getFunctionName());
         if (func_name.empty())
         {
+            LOG_DEBUG(log, "MongoDB function name not found for '{}'", func->getFunctionName());
             on_error(func);
             return {};
         }
@@ -234,18 +249,14 @@ std::optional<bsoncxx::document::value> StorageMongoDB::visitWhereFunction(
 
             if (const auto & const_value = value->as<ConstantNode>())
             {
-                std::optional<bsoncxx::types::bson_value::value> func_value{};
-                if (column->getColumnName() == "_id")
-                    func_value = fieldAsOID(const_value->getValue());
-                else
-                    func_value = fieldAsBSONValue(const_value->getValue(), const_value->getResultType());
-
-                if (func_name == "$in" && func_value->view().type() != bsoncxx::v_noabi::type::k_array)
+                auto func_value = BSONCXXHelper::fieldAsBSONValue(const_value->getValue(), const_value->getResultType(),
+                    configuration.isOidColumn(column->getColumnName()));
+                if (func_name == "$in" && func_value.view().type() != bsoncxx::v_noabi::type::k_array)
                     func_name = "$eq";
-                if (func_name == "$nin" && func_value->view().type() != bsoncxx::v_noabi::type::k_array)
+                if (func_name == "$nin" && func_value.view().type() != bsoncxx::v_noabi::type::k_array)
                     func_name = "$ne";
 
-                return make_document(kvp(column->getColumnName(), make_document(kvp(func_name, std::move(*func_value)))));
+                return make_document(kvp(column->getColumnName(), make_document(kvp(func_name, std::move(func_value)))));
             }
 
             if (const auto & func_value = value->as<FunctionNode>())
diff --git a/src/Storages/StorageMongoDB.h b/src/Storages/StorageMongoDB.h
index 15052c67e76a..b6711658799b 100644
--- a/src/Storages/StorageMongoDB.h
+++ b/src/Storages/StorageMongoDB.h
@@ -22,18 +22,24 @@ struct MongoDBConfiguration
 {
     std::unique_ptr<mongocxx::uri> uri;
     String collection;
+    std::unordered_set<String> oid_fields = {"_id"};
 
     void checkHosts(const ContextPtr & context) const
     {
-        // Because domain records will be resolved inside the driver, we can't check IPs for our restrictions.
+        // Because domain records will be resolved inside the driver, we can't check resolved IPs for our restrictions.
         for (const auto & host : uri->hosts())
             context->getRemoteHostFilter().checkHostAndPort(host.name, toString(host.port));
     }
+
+    bool isOidColumn(const std::string & name) const
+    {
+        return oid_fields.contains(name);
+    }
 };
 
 /** Implements storage in the MongoDB database.
- *  Use ENGINE = MongoDB(host:port, database, collection, user, password [, options]);
- *               MongoDB(uri, collection);
+ *  Use ENGINE = MongoDB(host:port, database, collection, user, password[, options[, oid_columns]]);
+ *               MongoDB(uri, collection[, oid columns]);
  *  Read only.
  *  One stream only.
  */
diff --git a/src/TableFunctions/TableFunctionMongoDB.cpp b/src/TableFunctions/TableFunctionMongoDB.cpp
index c979ba41b0f5..d48dc16deb77 100644
--- a/src/TableFunctions/TableFunctionMongoDB.cpp
+++ b/src/TableFunctions/TableFunctionMongoDB.cpp
@@ -56,12 +56,12 @@ StoragePtr TableFunctionMongoDB::executeImpl(const ASTPtr & /*ast_function*/,
 {
     auto columns = getActualTableStructure(context, is_insert_query);
     auto storage = std::make_shared<StorageMongoDB>(
-    StorageID(getDatabaseName(), table_name),
-    std::move(*configuration),
-    columns,
-    ConstraintsDescription(),
-    String{});
-    storage->startup();
+        StorageID(getDatabaseName(), table_name),
+        std::move(*configuration),
+        columns,
+        ConstraintsDescription(),
+        String{});
+        storage->startup();
     return storage;
 }
 
@@ -77,61 +77,32 @@ void TableFunctionMongoDB::parseArguments(const ASTPtr & ast_function, ContextPt
         throw Exception(ErrorCodes::BAD_ARGUMENTS, "Table function 'mongodb' must have arguments.");
 
     ASTs & args = func_args.arguments->children;
+    if ((args.size() < 3 || args.size() > 4) && (args.size() < 6 || args.size() > 8))
+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
+                        "Incorrect argument count for table function '{}'. Usage: "
+                        "mongodb('host:port', database, collection, user, password, structure[, options[, oid_columns]]) or mongodb(uri, collection, structure[, oid_columns]).",
+                        getName());
 
-    if (args.size() == 6 || args.size() == 7)
+    ASTs main_arguments;
+    for (size_t i = 0; i < args.size(); ++i)
     {
-        ASTs main_arguments(args.begin(), args.begin() + 5);
-
-        for (size_t i = 5; i < args.size(); ++i)
+        if (const auto * ast_func = typeid_cast<const ASTFunction *>(args[i].get()))
         {
-            if (const auto * ast_func = typeid_cast<const ASTFunction *>(args[i].get()))
-            {
-                const auto & [arg_name, arg_value] = getKeyValueMongoDBArgument(ast_func);
-                if (arg_name == "structure")
-                    structure = checkAndGetLiteralArgument<String>(arg_value, arg_name);
-                else if (arg_name == "options")
-                    main_arguments.push_back(arg_value);
-            }
-            else if (i == 5)
-            {
-                structure = checkAndGetLiteralArgument<String>(args[i], "structure");
-            }
-            else if (i == 6)
-            {
-                main_arguments.push_back(args[i]);
-            }
+            const auto & [arg_name, arg_value] = getKeyValueMongoDBArgument(ast_func);
+            if (arg_name == "structure")
+                structure = checkAndGetLiteralArgument<String>(arg_value, arg_name);
+            else if (arg_name == "options" || arg_name == "oid_columns")
+                main_arguments.push_back(arg_value);
         }
-
-        configuration = std::make_shared<MongoDBConfiguration>(StorageMongoDB::getConfiguration(main_arguments, context));
+        else if (args.size() >= 6 && i == 5)
+            structure = checkAndGetLiteralArgument<String>(args[i], "structure");
+        else if (args.size() <= 4 && i == 2)
+            structure = checkAndGetLiteralArgument<String>(args[i], "structure");
+        else
+            main_arguments.push_back(args[i]);
     }
-    else if (args.size() == 3)
-    {
-        ASTs main_arguments(args.begin(), args.begin() + 2);
-
-        for (size_t i = 2; i < args.size(); ++i)
-        {
-            if (const auto * ast_func = typeid_cast<const ASTFunction *>(args[i].get()))
-            {
-                const auto & [arg_name, arg_value] = getKeyValueMongoDBArgument(ast_func);
-                if (arg_name == "structure")
-                    structure = checkAndGetLiteralArgument<String>(arg_value, arg_name);
-                else if (arg_name == "options")
-                    main_arguments.push_back(arg_value);
-            }
-            else if (i == 2)
-            {
-                structure = checkAndGetLiteralArgument<String>(args[i], "structure");
-            }
-        }
 
-        configuration = std::make_shared<MongoDBConfiguration>(StorageMongoDB::getConfiguration(main_arguments, context));
-    }
-    else
-    {
-        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,
-                        "Table function 'mongodb' requires 3 or from 6 to 7 parameters: "
-                        "mongodb('host:port', database, collection, user, password, structure, [, options]) or mongodb(uri, collection, structure).");
-    }
+    configuration = std::make_shared<MongoDBConfiguration>(StorageMongoDB::getConfiguration(main_arguments, context));
 }
 
 }
