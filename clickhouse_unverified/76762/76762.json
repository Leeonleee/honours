{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 76762,
  "instance_id": "ClickHouse__ClickHouse-76762",
  "issue_numbers": [
    "72210",
    "74452"
  ],
  "base_commit": "37ddab10fb1b97f58cbdd65e458d8622e6989c11",
  "patch": "diff --git a/docs/en/engines/table-engines/integrations/mongodb.md b/docs/en/engines/table-engines/integrations/mongodb.md\nindex 21143a5b12df..8e67e5b262f8 100644\n--- a/docs/en/engines/table-engines/integrations/mongodb.md\n+++ b/docs/en/engines/table-engines/integrations/mongodb.md\n@@ -26,7 +26,7 @@ CREATE TABLE [IF NOT EXISTS] [db.]table_name\n     name1 [type1],\n     name2 [type2],\n     ...\n-) ENGINE = MongoDB(host:port, database, collection, user, password [, options]);\n+) ENGINE = MongoDB(host:port, database, collection, user, password[, options[, oid_columns]]);\n ```\n \n **Engine Parameters**\n@@ -43,40 +43,98 @@ CREATE TABLE [IF NOT EXISTS] [db.]table_name\n \n - `options` \u2014 MongoDB connection string options (optional parameter).\n \n+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.\n+\n :::tip\n If you are using the MongoDB Atlas cloud offering connection url can be obtained from 'Atlas SQL' option.\n Seed list(`mongodb**+srv**`) is not yet supported, but will be added in future releases.\n :::\n \n-Also, you can simply pass a URI:\n+Alternatively, you can pass a URI:\n \n ``` sql\n-ENGINE = MongoDB(uri, collection);\n+ENGINE = MongoDB(uri, collection[, oid_columns]);\n ```\n \n **Engine Parameters**\n \n-- `uri` \u2014 MongoDB server's connection URI\n+- `uri` \u2014 MongoDB server's connection URI.\n \n - `collection` \u2014 Remote collection name.\n \n+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.\n+\n \n ## Types mappings {#types-mappings}\n \n-| MongoDB            | ClickHouse                                                            |\n-|--------------------|-----------------------------------------------------------------------|\n-| bool, int32, int64 | *any numeric type*, String                                            |\n-| double             | Float64, String                                                       |\n-| date               | Date, Date32, DateTime, DateTime64, String                            |\n-| string             | String, UUID                                                          |\n-| document           | String(as JSON)                                                       |\n-| array              | Array, String(as JSON)                                                |\n-| oid                | String                                                                |\n-| binary             | String if in column, base64 encoded string if in an array or document |\n-| *any other*        | String                                                                |\n+| MongoDB                 | ClickHouse                                                            |\n+|-------------------------|-----------------------------------------------------------------------|\n+| bool, int32, int64      | *any numeric type*, String                                            |\n+| double                  | Float64, String                                                       |\n+| date                    | Date, Date32, DateTime, DateTime64, String                            |\n+| string                  | String                                                                |\n+| document                | String(as JSON)                                                       |\n+| array                   | Array, String(as JSON)                                                |\n+| oid                     | String                                                                |\n+| binary                  | String if in column, base64 encoded string if in an array or document |\n+| uuid (binary subtype 4) | UUID                                                                  |\n+| *any other*             | String                                                                |\n \n If key is not found in MongoDB document (for example, column name doesn't match), default value or `NULL` (if the column is nullable) will be inserted.\n \n+### OID {#oid}\n+\n+If you want a `String` to be treated as `oid` in the WHERE clause, just put the column's name in the last argument of the table engine.\n+This may be necessary when querying a record by the `_id` column, which by default has `oid` type in MongoDB.\n+If the `_id` field in the table has other type, for example `uuid`, you need to specify empty `oid_columns`, otherwise the default value for this parameter `_id` is used.\n+\n+```javascript\n+db.sample_oid.insertMany([\n+    {\"another_oid_column\": ObjectId()},\n+]);\n+\n+db.sample_oid.find();\n+[\n+    {\n+        \"_id\": {\"$oid\": \"67bf6cc44ebc466d33d42fb2\"},\n+        \"another_oid_column\": {\"$oid\": \"67bf6cc40000000000ea41b1\"}\n+    }\n+]\n+```\n+\n+By default, only `_id` is treated as `oid` column.\n+\n+```sql\n+CREATE TABLE sample_oid\n+(\n+    _id String,\n+    another_oid_column String\n+) ENGINE = MongoDB('mongodb://user:pass@host/db', 'sample_oid');\n+\n+SELECT count() FROM sample_oid WHERE _id = '67bf6cc44ebc466d33d42fb2'; --will output 1.\n+SELECT count() FROM sample_oid WHERE another_oid_column = '67bf6cc40000000000ea41b1'; --will output 0\n+```\n+\n+In this case the output will be `0`, because ClickHouse doesn't know that `another_oid_column` has `oid` type, so let's fix it:\n+\n+```sql\n+CREATE TABLE sample_oid\n+(\n+    _id String,\n+    another_oid_column String\n+) ENGINE = MongoDB('mongodb://user:pass@host/db', 'sample_oid', '_id,another_oid_column');\n+\n+-- or\n+\n+CREATE TABLE sample_oid\n+(\n+    _id String,\n+    another_oid_column String\n+) ENGINE = MongoDB('host', 'db', 'sample_oid', 'user', 'pass', '', '_id,another_oid_column');\n+\n+SELECT count() FROM sample_oid WHERE another_oid_column = '67bf6cc40000000000ea41b1'; -- will output 1 now\n+```\n+\n ## Supported clauses {#supported-clauses}\n \n Only queries with simple expressions are supported (for example, `WHERE field = <constant> ORDER BY field2 LIMIT <constant>`).\ndiff --git a/docs/en/sql-reference/table-functions/mongodb.md b/docs/en/sql-reference/table-functions/mongodb.md\nindex f1bf66aa43f1..5fde7339bd22 100644\n--- a/docs/en/sql-reference/table-functions/mongodb.md\n+++ b/docs/en/sql-reference/table-functions/mongodb.md\n@@ -13,7 +13,7 @@ Allows `SELECT` queries to be performed on data that is stored on a remote Mongo\n **Syntax**\n \n ``` sql\n-mongodb(host:port, database, collection, user, password, structure [, options])\n+mongodb(host:port, database, collection, user, password, structure[, options[, oid_columns]])\n ```\n \n **Arguments**\n@@ -32,19 +32,22 @@ mongodb(host:port, database, collection, user, password, structure [, options])\n \n - `options` - MongoDB connection string options (optional parameter).\n \n+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.\n+\n :::tip\n If you are using the MongoDB Atlas cloud offering please add these options:\n \n ```ini\n 'connectTimeoutMS=10000&ssl=true&authSource=admin'\n ```\n-\n :::\n \n-Also, you can connect by URI:\n+You can also connect by URI:\n+\n ``` sql\n-mongodb(uri, collection, structure)\n+mongodb(uri, collection, structure[, oid_columns])\n ```\n+\n **Arguments**\n \n - `uri` \u2014 Connection string.\n@@ -53,6 +56,8 @@ mongodb(uri, collection, structure)\n \n - `structure` \u2014 The schema for the ClickHouse table returned from this function.\n \n+- `oid_columns` - Comma-separated list of columns that should be treated as `oid` in the WHERE clause. `_id` by default.\n+\n **Returned Value**\n \n A table object with the same columns as the original MongoDB table.\ndiff --git a/src/Common/BSONCXXHelper.h b/src/Common/BSONCXXHelper.h\nindex ce2d9aab6eba..db9d15df35f5 100644\n--- a/src/Common/BSONCXXHelper.h\n+++ b/src/Common/BSONCXXHelper.h\n@@ -4,8 +4,13 @@\n \n #if USE_MONGODB\n #include <Common/Base64.h>\n-#include <DataTypes/FieldToDataType.h>\n+#include <Common/JSONBuilder.h>\n+#include <IO/ReadBufferFromMemory.h>\n #include <IO/ReadHelpers.h>\n+#include <DataTypes/FieldToDataType.h>\n+#include \"DataTypes/DataTypeNullable.h\"\n+\n+#include <mongocxx/client.hpp>\n \n namespace DB\n {\n@@ -24,13 +29,27 @@ using bsoncxx::builder::basic::document;\n using bsoncxx::builder::basic::kvp;\n using bsoncxx::builder::basic::make_document;\n \n-static bsoncxx::types::bson_value::value fieldAsBSONValue(const Field & field, const DataTypePtr & type)\n+static bsoncxx::types::bson_value::value fieldAsBSONValue(const Field & field, const DataTypePtr & type, const bool is_oid)\n {\n-    switch (type->getTypeId())\n+    if (field.isNull())\n+        return bsoncxx::types::b_null{};\n+\n+    auto type_id = type->getTypeId();\n+    if (type->isNullable())\n+        type_id = typeid_cast<const DataTypeNullable *>(type.get())->getNestedType()->getTypeId();\n+\n+    switch (type_id)\n     {\n+        case TypeIndex::Nothing:\n+            return bsoncxx::types::b_null{};\n         case TypeIndex::String:\n+        {\n+            if (is_oid)\n+                return bsoncxx::oid(field.safeGet<String>());\n             return bsoncxx::types::b_string{field.safeGet<String>()};\n-        case TypeIndex::UInt8: {\n+        }\n+        case TypeIndex::UInt8:\n+        {\n             if (isBool(type))\n                 return bsoncxx::types::b_bool{field.safeGet<UInt8>() != 0};\n             return bsoncxx::types::b_int32{static_cast<Int32>(field.safeGet<UInt8>())};\n@@ -60,17 +79,32 @@ static bsoncxx::types::bson_value::value fieldAsBSONValue(const Field & field, c\n         case TypeIndex::DateTime:\n             return bsoncxx::types::b_date{std::chrono::seconds{field.safeGet<UInt32>()}};\n         case TypeIndex::UUID:\n-            return bsoncxx::types::b_string{String{formatUUID(field.safeGet<UUID>()).data()}};\n-        case TypeIndex::Tuple: {\n-            auto arr = array();\n+        {\n+            uint64_t uuid_numbers[2];\n+            if constexpr (std::endian::native == std::endian::little)\n+            {\n+                uuid_numbers[0] = std::byteswap(field.safeGet<UUID>().toUnderType().items[0]);\n+                uuid_numbers[1] = std::byteswap(field.safeGet<UUID>().toUnderType().items[1]);\n+            } else\n+            {\n+                uuid_numbers[0] = field.safeGet<UUID>().toUnderType().items[0];\n+                uuid_numbers[1] = field.safeGet<UUID>().toUnderType().items[1];\n+            }\n+            return bsoncxx::types::bson_value::value(reinterpret_cast<const uint8_t*>(&uuid_numbers[0]),\n+                16, bsoncxx::binary_sub_type::k_uuid);\n+        }\n+        case TypeIndex::Tuple:\n+        {\n+            auto arr = bsoncxx::v_noabi::builder::basic::array();\n             for (const auto & elem : field.safeGet<Tuple>())\n-                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem)));\n+                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem), is_oid));\n             return arr.view();\n         }\n-        case TypeIndex::Array: {\n-            auto arr = array();\n+        case TypeIndex::Array:\n+        {\n+            auto arr = bsoncxx::v_noabi::builder::basic::array();\n             for (const auto & elem : field.safeGet<Array>())\n-                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem)));\n+                arr.append(fieldAsBSONValue(elem, applyVisitor(FieldToDataType(), elem), is_oid));\n             return arr.view();\n         }\n         default:\n@@ -279,7 +313,8 @@ static Array BSONArrayAsArray(\n                     case TypeIndex::Float64:\n                         arr.emplace_back(BSONElementAsNumber<Float64, bsoncxx::array::element>(value, name));\n                         break;\n-                    case TypeIndex::Date: {\n+                    case TypeIndex::Date:\n+                    {\n                         if (value.type() != bsoncxx::type::k_date)\n                             throw Exception(\n                                 ErrorCodes::TYPE_MISMATCH,\n@@ -290,7 +325,8 @@ static Array BSONArrayAsArray(\n                         arr.emplace_back(DateLUT::instance().toDayNum(value.get_date().to_int64() / 1000).toUnderType());\n                         break;\n                     }\n-                    case TypeIndex::Date32: {\n+                    case TypeIndex::Date32:\n+                    {\n                         if (value.type() != bsoncxx::type::k_date)\n                             throw Exception(\n                                 ErrorCodes::TYPE_MISMATCH,\n@@ -301,7 +337,8 @@ static Array BSONArrayAsArray(\n                         arr.emplace_back(DateLUT::instance().toDayNum(value.get_date().to_int64() / 1000).toUnderType());\n                         break;\n                     }\n-                    case TypeIndex::DateTime: {\n+                    case TypeIndex::DateTime:\n+                    {\n                         if (value.type() != bsoncxx::type::k_date)\n                             throw Exception(\n                                 ErrorCodes::TYPE_MISMATCH,\n@@ -312,7 +349,8 @@ static Array BSONArrayAsArray(\n                         arr.emplace_back(static_cast<UInt32>(value.get_date().to_int64() / 1000));\n                         break;\n                     }\n-                    case TypeIndex::DateTime64: {\n+                    case TypeIndex::DateTime64:\n+                    {\n                         if (value.type() != bsoncxx::type::k_date)\n                             throw Exception(\n                                 ErrorCodes::TYPE_MISMATCH,\n@@ -323,15 +361,21 @@ static Array BSONArrayAsArray(\n                         arr.emplace_back(static_cast<Decimal64>(value.get_date().to_int64()));\n                         break;\n                     }\n-                    case TypeIndex::UUID: {\n-                        if (value.type() != bsoncxx::type::k_string)\n-                            throw Exception(\n-                                ErrorCodes::TYPE_MISMATCH,\n-                                \"Type mismatch, expected string (UUID), got {} for column {}.\",\n-                                bsoncxx::to_string(value.type()),\n-                                name);\n+                    case TypeIndex::UUID:\n+                    {\n+                        if (value.type() != bsoncxx::type::k_binary)\n+                            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Type mismatch, expected uuid(binary subtype 4), got {} for column {}.\",\n+                                            bsoncxx::to_string(value.type()), name);\n+                        if (value.get_binary().sub_type != bsoncxx::binary_sub_type::k_uuid || value.get_binary().size != 16)\n+                            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Binary of type {} with size cannot be parsed to UUID for column {}.\",\n+                                bsoncxx::to_string(value.get_binary().sub_type), name);\n+\n+                        UInt128 uuid_number;\n+                        auto valBuf = ReadBufferFromMemory(value.get_binary().bytes, value.get_binary().size);\n+                        readBinaryBigEndian(uuid_number.items[0], valBuf);\n+                        readBinaryBigEndian(uuid_number.items[1], valBuf);\n \n-                        arr.emplace_back(parse<UUID>(value.get_string().value.data()));\n+                        arr.emplace_back(UUID(std::move(uuid_number)));\n                         break;\n                     }\n                     case TypeIndex::String:\n@@ -349,29 +393,6 @@ static Array BSONArrayAsArray(\n     }\n     return arr;\n }\n-\n-static bsoncxx::types::bson_value::value fieldAsOID(const Field & field)\n-{\n-    switch (field.getType())\n-    {\n-        case Field::Types::String:\n-            return bsoncxx::oid(field.safeGet<String>());\n-        case Field::Types::Array: {\n-            auto arr = array();\n-            for (const auto & elem : field.safeGet<Array>())\n-                arr.append(fieldAsOID(elem));\n-            return arr.view();\n-        }\n-        case Field::Types::Tuple: {\n-            auto tuple = array();\n-            for (const auto & elem : field.safeGet<Tuple>())\n-                tuple.append(fieldAsOID(elem));\n-            return tuple.view();\n-        }\n-        default:\n-            throw Exception(ErrorCodes::TYPE_MISMATCH, \"{} can't be converted to oid.\", field.getType());\n-    }\n-}\n }\n \n }\ndiff --git a/src/Processors/Sources/MongoDBSource.cpp b/src/Processors/Sources/MongoDBSource.cpp\nindex f593f36a318b..fdfa50291944 100644\n--- a/src/Processors/Sources/MongoDBSource.cpp\n+++ b/src/Processors/Sources/MongoDBSource.cpp\n@@ -117,11 +117,19 @@ void MongoDBSource::insertValue(IColumn & column, const size_t & idx, const Data\n         }\n         case TypeIndex::UUID:\n         {\n-            if (value.type() != bsoncxx::type::k_string)\n-                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Type mismatch, expected string (UUID), got {} for column {}\",\n+            if (value.type() != bsoncxx::type::k_binary)\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Type mismatch, expected uuid(binary subtype 4), got {} for column {}\",\n                                 bsoncxx::to_string(value.type()), name);\n+            if (value.get_binary().sub_type != bsoncxx::binary_sub_type::k_uuid || value.get_binary().size != 16)\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Binary of type {} cannot be parsed to UUID for column {}\",\n+                    bsoncxx::to_string(value.get_binary().sub_type), name);\n \n-            assert_cast<ColumnUUID &>(column).insertValue(parse<UUID>(value.get_string().value.data()));\n+            UInt128 uuid_number;\n+            auto valBuf = ReadBufferFromMemory(value.get_binary().bytes, value.get_binary().size);\n+            readBinaryBigEndian(uuid_number.items[0], valBuf);\n+            readBinaryBigEndian(uuid_number.items[1], valBuf);\n+\n+            assert_cast<ColumnUUID &>(column).insertValue(UUID(std::move(uuid_number)));\n             break;\n         }\n         case TypeIndex::String:\ndiff --git a/src/Storages/StorageMongoDB.cpp b/src/Storages/StorageMongoDB.cpp\nindex 3c5bc244d3a8..9cf5a2c91796 100644\n--- a/src/Storages/StorageMongoDB.cpp\n+++ b/src/Storages/StorageMongoDB.cpp\n@@ -1,15 +1,21 @@\n #include \"config.h\"\n \n #if USE_MONGODB\n-#include <memory>\n \n #include <Analyzer/ColumnNode.h>\n #include <Analyzer/ConstantNode.h>\n #include <Analyzer/FunctionNode.h>\n-#include <Analyzer/QueryNode.h>\n-#include <Analyzer/TableNode.h>\n #include <Analyzer/JoinNode.h>\n+#include <Analyzer/QueryNode.h>\n #include <Analyzer/SortNode.h>\n+#include <Analyzer/TableFunctionNode.h>\n+#include <Analyzer/TableNode.h>\n+#include <Common/BSONCXXHelper.h>\n+#include <Common/ErrorCodes.h>\n+#include <Common/logger_useful.h>\n+#include <Common/parseAddress.h>\n+#include <Core/Joins.h>\n+#include <Core/Settings.h>\n #include <Formats/BSONTypes.h>\n #include <Interpreters/evaluateConstantExpression.h>\n #include <Parsers/ASTIdentifier.h>\n@@ -19,15 +25,14 @@\n #include <Storages/StorageFactory.h>\n #include <Storages/StorageMongoDB.h>\n #include <Storages/checkAndGetLiteralArgument.h>\n-#include <Common/parseAddress.h>\n-#include <Common/ErrorCodes.h>\n-#include <Common/BSONCXXHelper.h>\n-#include <Common/logger_useful.h>\n-#include <Core/Settings.h>\n-#include <Core/Joins.h>\n \n #include <bsoncxx/json.hpp>\n \n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/split.hpp>\n+\n+#include <memory>\n+\n using bsoncxx::builder::basic::document;\n using bsoncxx::builder::basic::make_document;\n using bsoncxx::builder::basic::make_array;\n@@ -49,9 +54,6 @@ namespace Setting\n     extern const SettingsBool mongodb_throw_on_unsupported_query;\n }\n \n-using BSONCXXHelper::fieldAsBSONValue;\n-using BSONCXXHelper::fieldAsOID;\n-\n StorageMongoDB::StorageMongoDB(\n     const StorageID & table_id_,\n     MongoDBConfiguration configuration_,\n@@ -100,12 +102,13 @@ MongoDBConfiguration StorageMongoDB::getConfiguration(ASTs engine_args, ContextP\n     {\n         if (named_collection->has(\"uri\"))\n         {\n-            validateNamedCollection(*named_collection, {\"collection\"}, {\"uri\"});\n+            validateNamedCollection(*named_collection, {\"uri\", \"collection\"}, {\"oid_columns\"});\n             configuration.uri = std::make_unique<mongocxx::uri>(named_collection->get<String>(\"uri\"));\n         }\n         else\n         {\n-            validateNamedCollection(*named_collection, {\"host\", \"port\", \"user\", \"password\", \"database\", \"collection\"}, {\"options\"});\n+            validateNamedCollection(*named_collection, {\n+                \"host\", \"port\", \"user\", \"password\", \"database\", \"collection\"}, {\"options\", \"oid_columns\"});\n             String user = named_collection->get<String>(\"user\");\n             String auth_string;\n             if (!user.empty())\n@@ -118,18 +121,20 @@ MongoDBConfiguration StorageMongoDB::getConfiguration(ASTs engine_args, ContextP\n                                                           named_collection->getOrDefault<String>(\"options\", \"\")));\n         }\n         configuration.collection = named_collection->get<String>(\"collection\");\n+        if (named_collection->has(\"oid_columns\"))\n+            boost::split(configuration.oid_fields, named_collection->get<String>(\"oid_columns\"), boost::is_any_of(\",\"));\n     }\n     else\n     {\n         for (auto & engine_arg : engine_args)\n             engine_arg = evaluateConstantExpressionOrIdentifierAsLiteral(engine_arg, context);\n \n-        if (engine_args.size() == 5 || engine_args.size() == 6)\n+        if (engine_args.size() >= 5 && engine_args.size() <= 7)\n         {\n             configuration.collection = checkAndGetLiteralArgument<String>(engine_args[2], \"collection\");\n \n             String options;\n-            if (engine_args.size() == 6)\n+            if (engine_args.size() >= 6)\n                 options = checkAndGetLiteralArgument<String>(engine_args[5], \"options\");\n \n             String user = checkAndGetLiteralArgument<String>(engine_args[3], \"user\");\n@@ -143,16 +148,22 @@ MongoDBConfiguration StorageMongoDB::getConfiguration(ASTs engine_args, ContextP\n                                                               parsed_host_port.second,\n                                                               checkAndGetLiteralArgument<String>(engine_args[1], \"database\"),\n                                                               options));\n+            if (engine_args.size() == 7)\n+                boost::split(configuration.oid_fields,\n+                    checkAndGetLiteralArgument<String>(engine_args[6], \"oid_columns\"), boost::is_any_of(\",\"));\n         }\n-        else if (engine_args.size() == 2)\n+        else if (engine_args.size() == 2 || engine_args.size() == 3)\n         {\n             configuration.collection = checkAndGetLiteralArgument<String>(engine_args[1], \"database\");\n             configuration.uri =  std::make_unique<mongocxx::uri>(checkAndGetLiteralArgument<String>(engine_args[0], \"host\"));\n+            if (engine_args.size() == 3)\n+                boost::split(configuration.oid_fields,\n+                    checkAndGetLiteralArgument<String>(engine_args[2], \"oid_columns\"), boost::is_any_of(\",\"));\n         }\n         else\n             throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                                \"Storage MongoDB requires 2 or from to 5 to 6 parameters: \"\n-                                \"MongoDB('host:port', 'database', 'collection', 'user', 'password' [, 'options']) or MongoDB('uri', 'collection').\");\n+                                \"Incorrect number of arguments. Example usage: \"\n+                                \"MongoDB('host:port', 'database', 'collection', 'user', 'password'[, options[, oid_columns]]) or MongoDB('uri', 'collection'[, oid columns]).\");\n     }\n \n     configuration.checkHosts(context);\n@@ -202,11 +213,14 @@ std::optional<bsoncxx::document::value> StorageMongoDB::visitWhereFunction(\n     {\n         // Skip unknown columns, which don't belong to the table.\n         const auto & table = column->getColumnSource()->as<TableNode>();\n-        if (!table)\n+        const auto & table_function = column->getColumnSource()->as<TableFunctionNode>();\n+        if (!table && !table_function)\n             return {};\n \n         // Skip columns from other tables in JOIN queries.\n-        if (table->getStorage()->getStorageID() != this->getStorageID())\n+        if (table && table->getStorage()->getStorageID() != this->getStorageID())\n+            return {};\n+        if (table_function && table_function->getStorage()->getStorageID() != this->getStorageID())\n             return {};\n         if (join_node && column->getColumnSource() != join_node->getLeftTableExpression())\n             return {};\n@@ -224,6 +238,7 @@ std::optional<bsoncxx::document::value> StorageMongoDB::visitWhereFunction(\n         auto func_name = mongoFuncName(func->getFunctionName());\n         if (func_name.empty())\n         {\n+            LOG_DEBUG(log, \"MongoDB function name not found for '{}'\", func->getFunctionName());\n             on_error(func);\n             return {};\n         }\n@@ -234,18 +249,14 @@ std::optional<bsoncxx::document::value> StorageMongoDB::visitWhereFunction(\n \n             if (const auto & const_value = value->as<ConstantNode>())\n             {\n-                std::optional<bsoncxx::types::bson_value::value> func_value{};\n-                if (column->getColumnName() == \"_id\")\n-                    func_value = fieldAsOID(const_value->getValue());\n-                else\n-                    func_value = fieldAsBSONValue(const_value->getValue(), const_value->getResultType());\n-\n-                if (func_name == \"$in\" && func_value->view().type() != bsoncxx::v_noabi::type::k_array)\n+                auto func_value = BSONCXXHelper::fieldAsBSONValue(const_value->getValue(), const_value->getResultType(),\n+                    configuration.isOidColumn(column->getColumnName()));\n+                if (func_name == \"$in\" && func_value.view().type() != bsoncxx::v_noabi::type::k_array)\n                     func_name = \"$eq\";\n-                if (func_name == \"$nin\" && func_value->view().type() != bsoncxx::v_noabi::type::k_array)\n+                if (func_name == \"$nin\" && func_value.view().type() != bsoncxx::v_noabi::type::k_array)\n                     func_name = \"$ne\";\n \n-                return make_document(kvp(column->getColumnName(), make_document(kvp(func_name, std::move(*func_value)))));\n+                return make_document(kvp(column->getColumnName(), make_document(kvp(func_name, std::move(func_value)))));\n             }\n \n             if (const auto & func_value = value->as<FunctionNode>())\ndiff --git a/src/Storages/StorageMongoDB.h b/src/Storages/StorageMongoDB.h\nindex 15052c67e76a..b6711658799b 100644\n--- a/src/Storages/StorageMongoDB.h\n+++ b/src/Storages/StorageMongoDB.h\n@@ -22,18 +22,24 @@ struct MongoDBConfiguration\n {\n     std::unique_ptr<mongocxx::uri> uri;\n     String collection;\n+    std::unordered_set<String> oid_fields = {\"_id\"};\n \n     void checkHosts(const ContextPtr & context) const\n     {\n-        // Because domain records will be resolved inside the driver, we can't check IPs for our restrictions.\n+        // Because domain records will be resolved inside the driver, we can't check resolved IPs for our restrictions.\n         for (const auto & host : uri->hosts())\n             context->getRemoteHostFilter().checkHostAndPort(host.name, toString(host.port));\n     }\n+\n+    bool isOidColumn(const std::string & name) const\n+    {\n+        return oid_fields.contains(name);\n+    }\n };\n \n /** Implements storage in the MongoDB database.\n- *  Use ENGINE = MongoDB(host:port, database, collection, user, password [, options]);\n- *               MongoDB(uri, collection);\n+ *  Use ENGINE = MongoDB(host:port, database, collection, user, password[, options[, oid_columns]]);\n+ *               MongoDB(uri, collection[, oid columns]);\n  *  Read only.\n  *  One stream only.\n  */\ndiff --git a/src/TableFunctions/TableFunctionMongoDB.cpp b/src/TableFunctions/TableFunctionMongoDB.cpp\nindex c979ba41b0f5..d48dc16deb77 100644\n--- a/src/TableFunctions/TableFunctionMongoDB.cpp\n+++ b/src/TableFunctions/TableFunctionMongoDB.cpp\n@@ -56,12 +56,12 @@ StoragePtr TableFunctionMongoDB::executeImpl(const ASTPtr & /*ast_function*/,\n {\n     auto columns = getActualTableStructure(context, is_insert_query);\n     auto storage = std::make_shared<StorageMongoDB>(\n-    StorageID(getDatabaseName(), table_name),\n-    std::move(*configuration),\n-    columns,\n-    ConstraintsDescription(),\n-    String{});\n-    storage->startup();\n+        StorageID(getDatabaseName(), table_name),\n+        std::move(*configuration),\n+        columns,\n+        ConstraintsDescription(),\n+        String{});\n+        storage->startup();\n     return storage;\n }\n \n@@ -77,61 +77,32 @@ void TableFunctionMongoDB::parseArguments(const ASTPtr & ast_function, ContextPt\n         throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Table function 'mongodb' must have arguments.\");\n \n     ASTs & args = func_args.arguments->children;\n+    if ((args.size() < 3 || args.size() > 4) && (args.size() < 6 || args.size() > 8))\n+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                        \"Incorrect argument count for table function '{}'. Usage: \"\n+                        \"mongodb('host:port', database, collection, user, password, structure[, options[, oid_columns]]) or mongodb(uri, collection, structure[, oid_columns]).\",\n+                        getName());\n \n-    if (args.size() == 6 || args.size() == 7)\n+    ASTs main_arguments;\n+    for (size_t i = 0; i < args.size(); ++i)\n     {\n-        ASTs main_arguments(args.begin(), args.begin() + 5);\n-\n-        for (size_t i = 5; i < args.size(); ++i)\n+        if (const auto * ast_func = typeid_cast<const ASTFunction *>(args[i].get()))\n         {\n-            if (const auto * ast_func = typeid_cast<const ASTFunction *>(args[i].get()))\n-            {\n-                const auto & [arg_name, arg_value] = getKeyValueMongoDBArgument(ast_func);\n-                if (arg_name == \"structure\")\n-                    structure = checkAndGetLiteralArgument<String>(arg_value, arg_name);\n-                else if (arg_name == \"options\")\n-                    main_arguments.push_back(arg_value);\n-            }\n-            else if (i == 5)\n-            {\n-                structure = checkAndGetLiteralArgument<String>(args[i], \"structure\");\n-            }\n-            else if (i == 6)\n-            {\n-                main_arguments.push_back(args[i]);\n-            }\n+            const auto & [arg_name, arg_value] = getKeyValueMongoDBArgument(ast_func);\n+            if (arg_name == \"structure\")\n+                structure = checkAndGetLiteralArgument<String>(arg_value, arg_name);\n+            else if (arg_name == \"options\" || arg_name == \"oid_columns\")\n+                main_arguments.push_back(arg_value);\n         }\n-\n-        configuration = std::make_shared<MongoDBConfiguration>(StorageMongoDB::getConfiguration(main_arguments, context));\n+        else if (args.size() >= 6 && i == 5)\n+            structure = checkAndGetLiteralArgument<String>(args[i], \"structure\");\n+        else if (args.size() <= 4 && i == 2)\n+            structure = checkAndGetLiteralArgument<String>(args[i], \"structure\");\n+        else\n+            main_arguments.push_back(args[i]);\n     }\n-    else if (args.size() == 3)\n-    {\n-        ASTs main_arguments(args.begin(), args.begin() + 2);\n-\n-        for (size_t i = 2; i < args.size(); ++i)\n-        {\n-            if (const auto * ast_func = typeid_cast<const ASTFunction *>(args[i].get()))\n-            {\n-                const auto & [arg_name, arg_value] = getKeyValueMongoDBArgument(ast_func);\n-                if (arg_name == \"structure\")\n-                    structure = checkAndGetLiteralArgument<String>(arg_value, arg_name);\n-                else if (arg_name == \"options\")\n-                    main_arguments.push_back(arg_value);\n-            }\n-            else if (i == 2)\n-            {\n-                structure = checkAndGetLiteralArgument<String>(args[i], \"structure\");\n-            }\n-        }\n \n-        configuration = std::make_shared<MongoDBConfiguration>(StorageMongoDB::getConfiguration(main_arguments, context));\n-    }\n-    else\n-    {\n-        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n-                        \"Table function 'mongodb' requires 3 or from 6 to 7 parameters: \"\n-                        \"mongodb('host:port', database, collection, user, password, structure, [, options]) or mongodb(uri, collection, structure).\");\n-    }\n+    configuration = std::make_shared<MongoDBConfiguration>(StorageMongoDB::getConfiguration(main_arguments, context));\n }\n \n }\n",
  "test_patch": "diff --git a/tests/integration/helpers/external_sources.py b/tests/integration/helpers/external_sources.py\nindex 1b2c73142f37..28f521644e2b 100644\n--- a/tests/integration/helpers/external_sources.py\n+++ b/tests/integration/helpers/external_sources.py\n@@ -3,6 +3,7 @@\n import logging\n import os\n import uuid\n+import bson\n import warnings\n \n import cassandra.cluster\n@@ -224,15 +225,11 @@ def prepare(self, structure, table_name, cluster):\n         self.converters = {}\n         for field in structure.get_all_fields():\n             if field.field_type == \"Date\":\n-                self.converters[field.name] = lambda x: datetime.datetime.strptime(\n-                    x, \"%Y-%m-%d\"\n-                )\n+                self.converters[field.name] = lambda x: datetime.datetime.strptime(x, \"%Y-%m-%d\")\n             elif field.field_type == \"DateTime\":\n-\n-                def converter(x):\n-                    return datetime.datetime.strptime(x, \"%Y-%m-%d %H:%M:%S\")\n-\n-                self.converters[field.name] = converter\n+                self.converters[field.name] = lambda x: datetime.datetime.strptime(x, \"%Y-%m-%d %H:%M:%S\")\n+            elif field.field_type == \"UUID\":\n+                self.converters[field.name] = lambda x: bson.Binary(uuid.UUID(x).bytes, subtype=4)\n             else:\n                 self.converters[field.name] = lambda x: x\n \ndiff --git a/tests/integration/test_storage_mongodb/test.py b/tests/integration/test_storage_mongodb/test.py\nindex e810b6132905..a95a10585bbb 100644\n--- a/tests/integration/test_storage_mongodb/test.py\n+++ b/tests/integration/test_storage_mongodb/test.py\n@@ -1,5 +1,6 @@\n import datetime\n import json\n+import uuid\n \n import bson\n import pymongo\n@@ -178,8 +179,14 @@ def test_arrays(started_cluster):\n                 ],\n                 \"arr_string\": [str(i + 1), str(i + 2), str(i + 3)],\n                 \"arr_uuid\": [\n-                    \"f0e77736-91d1-48ce-8f01-15123ca1c7ed\",\n-                    \"93376a07-c044-4281-a76e-ad27cf6973c5\",\n+                    bson.Binary(\n+                        uuid.UUID(\"f0e77736-91d1-48ce-8f01-15123ca1c7ed\").bytes,\n+                        subtype=4,\n+                    ),\n+                    bson.Binary(\n+                        uuid.UUID(\"93376a07-c044-4281-a76e-ad27cf6973c5\").bytes,\n+                        subtype=4,\n+                    ),\n                 ],\n                 \"arr_arr_bool\": [\n                     [True, False, True],\n@@ -738,26 +745,10 @@ def test_order_by(started_cluster):\n \n     assert node.query(\"SELECT COUNT() FROM sort_table\") == \"900\\n\"\n     assert node.query(\"SELECT keyInt FROM sort_table ORDER BY keyInt LIMIT 1\") == \"1\\n\"\n-    assert (\n-        node.query(\"SELECT keyInt FROM sort_table ORDER BY keyInt DESC LIMIT 1\")\n-        == \"30\\n\"\n-    )\n-    assert (\n-        node.query(\n-            \"SELECT keyInt, keyFloat FROM sort_table ORDER BY keyInt, keyFloat DESC LIMIT 1\"\n-        )\n-        == \"1\\t1.03\\n\"\n-    )\n-    assert (\n-        node.query(\n-            \"SELECT keyDateTime FROM sort_table ORDER BY keyDateTime DESC LIMIT 1\"\n-        )\n-        == \"1999-12-30 11:23:16\\n\"\n-    )\n-    assert (\n-        node.query(\"SELECT keyDate FROM sort_table ORDER BY keyDate DESC LIMIT 1\")\n-        == \"1999-12-30\\n\"\n-    )\n+    assert node.query(\"SELECT keyInt FROM sort_table ORDER BY keyInt DESC LIMIT 1\") == \"30\\n\"\n+    assert node.query(\"SELECT keyInt, keyFloat FROM sort_table ORDER BY keyInt, keyFloat DESC LIMIT 1\") == \"1\\t1.03\\n\"\n+    assert node.query(\"SELECT keyDateTime FROM sort_table ORDER BY keyDateTime DESC LIMIT 1\") == \"1999-12-30 11:23:16\\n\"\n+    assert node.query(\"SELECT keyDate FROM sort_table ORDER BY keyDate DESC LIMIT 1\") == \"1999-12-30\\n\"\n \n     with pytest.raises(QueryRuntimeException):\n         node.query(\"SELECT * FROM sort_table ORDER BY keyInt WITH FILL\")\n@@ -790,6 +781,10 @@ def test_where(started_cluster):\n                     \"keyDateTime\": datetime.datetime(1999, d, i, 11, 23, 16),\n                     \"keyDate\": datetime.datetime(1999, d, i, 11, 23, 16),\n                     \"keyNull\": None,\n+                    \"keyUuid\": bson.Binary(\n+                        uuid.UUID(\"8d9c5028-3371-4941-943f-84a0c90c5149\").bytes,\n+                        subtype=4,\n+                    ),\n                 }\n             )\n     where_mongo_table.insert_many(data)\n@@ -804,96 +799,42 @@ def test_where(started_cluster):\n              keyDateTime  DateTime,\n              keyDate      Date,\n              keyNull      Nullable(UInt8),\n-             keyNotExists Nullable(Int)\n+             keyNotExists Nullable(Int),\n+             keyUuid      UUID\n         ) ENGINE = MongoDB('mongo1:27017', 'test', 'where_table', 'root', 'clickhouse')\"\"\"\n     )\n \n     assert node.query(\"SELECT COUNT() FROM where_table\") == \"4\\n\"\n \n-    assert (\n-        node.query(\"SELECT keyString FROM where_table WHERE id = '11'\") == \"1string\\n\"\n-    )\n+    assert node.query(\"SELECT keyString FROM where_table WHERE id = '11'\") == \"1string\\n\"\n     assert (\n         node.query(\n             \"SELECT keyString FROM where_table WHERE id != '11' ORDER BY keyFloat\"\n         )\n         == \"2string\\n1string\\n2string\\n\"\n     )\n-    assert (\n-        node.query(\n-            \"SELECT keyString FROM where_table WHERE id = '11' AND keyString = '1string'\"\n-        )\n-        == \"1string\\n\"\n-    )\n-    assert (\n-        node.query(\"SELECT id FROM where_table WHERE keyInt = 1 AND keyFloat = 1.001\")\n-        == \"11\\n\"\n-    )\n-    assert (\n-        node.query(\"SELECT id FROM where_table WHERE keyInt = 0 OR keyFloat = 1.001\")\n-        == \"11\\n\"\n-    )\n+    assert node.query(\"SELECT keyString FROM where_table WHERE id = '11' AND keyString = '1string'\") == \"1string\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE keyInt = 1 AND keyFloat = 1.001\") == \"11\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE keyInt = 0 OR keyFloat = 1.001\") == \"11\\n\"\n \n-    assert (\n-        node.query(\"SELECT id FROM where_table WHERE keyInt BETWEEN 1 AND 2\")\n-        == \"11\\n12\\n21\\n22\\n\"\n-    )\n+    assert node.query(\"SELECT id FROM where_table WHERE keyInt BETWEEN 1 AND 2\") == \"11\\n12\\n21\\n22\\n\"\n     assert node.query(\"SELECT id FROM where_table WHERE keyInt > 10\") == \"\"\n-    assert (\n-        node.query(\"SELECT id FROM where_table WHERE keyInt < 10.1 ORDER BY keyFloat\")\n-        == \"11\\n12\\n21\\n22\\n\"\n-    )\n+    assert node.query(\"SELECT id FROM where_table WHERE keyInt < 10.1 ORDER BY keyFloat\") == \"11\\n12\\n21\\n22\\n\"\n \n     assert node.query(\"SELECT id FROM where_table WHERE id IN ('11')\") == \"11\\n\"\n     assert node.query(\"SELECT id FROM where_table WHERE id IN ['11']\") == \"11\\n\"\n     assert node.query(\"SELECT id FROM where_table WHERE id IN ('11', 100)\") == \"11\\n\"\n-    assert (\n-        node.query(\n-            \"SELECT id FROM where_table WHERE id IN ('11', '22') ORDER BY keyFloat\"\n-        )\n-        == \"11\\n22\\n\"\n-    )\n-    assert (\n-        node.query(\n-            \"SELECT id FROM where_table WHERE id IN ['11', '22'] ORDER BY keyFloat\"\n-        )\n-        == \"11\\n22\\n\"\n-    )\n+    assert node.query(\"SELECT id FROM where_table WHERE id IN ('11', '22') ORDER BY keyFloat\") == \"11\\n22\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE id IN ['11', '22'] ORDER BY keyFloat\") == \"11\\n22\\n\"\n \n-    assert (\n-        node.query(\n-            \"SELECT id FROM where_table WHERE id NOT IN ('11') ORDER BY keyFloat\"\n-        )\n-        == \"12\\n21\\n22\\n\"\n-    )\n-    assert (\n-        node.query(\n-            \"SELECT id FROM where_table WHERE id NOT IN ['11'] ORDER BY keyFloat\"\n-        )\n-        == \"12\\n21\\n22\\n\"\n-    )\n-    assert (\n-        node.query(\n-            \"SELECT id FROM where_table WHERE id NOT IN ('11', 100) ORDER BY keyFloat\"\n-        )\n-        == \"12\\n21\\n22\\n\"\n-    )\n-    assert (\n-        node.query(\"SELECT id FROM where_table WHERE id NOT IN ('11') AND id IN ('12')\")\n-        == \"12\\n\"\n-    )\n-    assert (\n-        node.query(\"SELECT id FROM where_table WHERE id NOT IN ['11'] AND id IN ('12')\")\n-        == \"12\\n\"\n-    )\n+    assert node.query(\"SELECT id FROM where_table WHERE id NOT IN ('11') ORDER BY keyFloat\") == \"12\\n21\\n22\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE id NOT IN ['11'] ORDER BY keyFloat\") == \"12\\n21\\n22\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE id NOT IN ('11', 100) ORDER BY keyFloat\") == \"12\\n21\\n22\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE id NOT IN ('11') AND id IN ('12')\") == \"12\\n\"\n+    assert node.query(\"SELECT id FROM where_table WHERE id NOT IN ['11'] AND id IN ('12')\") == \"12\\n\"\n \n     with pytest.raises(QueryRuntimeException):\n-        assert (\n-            node.query(\n-                \"SELECT id FROM where_table WHERE id NOT IN ['11', 100] ORDER BY keyFloat\"\n-            )\n-            == \"12\\n21\\n22\\n\"\n-        )\n+        assert node.query(\"SELECT id FROM where_table WHERE id NOT IN ['11', 100] ORDER BY keyFloat\") == \"12\\n21\\n22\\n\"\n \n     assert node.query(\"SELECT id FROM where_table WHERE keyDateTime > now()\") == \"\"\n     assert (\n@@ -902,24 +843,20 @@ def test_where(started_cluster):\n         )\n         == \"1\\n2\\n\"\n     )\n-\n-    assert node.query(\"SELECT count() FROM where_table WHERE isNotNull(id)\") == \"4\\n\"\n     assert (\n-        node.query(\"SELECT count() FROM where_table WHERE isNotNull(keyNull)\") == \"0\\n\"\n+        node.query(\n+            \"SELECT keyUuid FROM where_table WHERE keyUuid = toUUID('8d9c5028-3371-4941-943f-84a0c90c5149') LIMIT 1\"\n+        )\n+        == \"8d9c5028-3371-4941-943f-84a0c90c5149\\n\"\n     )\n+\n+    assert node.query(\"SELECT count() FROM where_table WHERE isNotNull(id)\") == \"4\\n\"\n+    assert node.query(\"SELECT count() FROM where_table WHERE isNotNull(keyNull)\") == \"0\\n\"\n     assert node.query(\"SELECT count() FROM where_table WHERE isNull(keyNull)\") == \"4\\n\"\n-    assert (\n-        node.query(\"SELECT count() FROM where_table WHERE isNotNull(keyNotExists)\")\n-        == \"0\\n\"\n-    )\n-    assert (\n-        node.query(\"SELECT count() FROM where_table WHERE isNull(keyNotExists)\")\n-        == \"4\\n\"\n-    )\n+    assert node.query(\"SELECT count() FROM where_table WHERE isNotNull(keyNotExists)\") == \"0\\n\"\n+    assert node.query(\"SELECT count() FROM where_table WHERE isNull(keyNotExists)\") == \"4\\n\"\n     assert node.query(\"SELECT count() FROM where_table WHERE keyNotExists = 0\") == \"0\\n\"\n-    assert (\n-        node.query(\"SELECT count() FROM where_table WHERE keyNotExists != 0\") == \"0\\n\"\n-    )\n+    assert node.query(\"SELECT count() FROM where_table WHERE keyNotExists != 0\") == \"0\\n\"\n \n     with pytest.raises(QueryRuntimeException):\n         node.query(\"SELECT * FROM where_table WHERE keyInt = keyFloat\")\n@@ -1043,14 +980,12 @@ def test_oid(started_cluster):\n     oid_mongo_table = db[\"oid_table\"]\n     inserted_result = oid_mongo_table.insert_many(\n         [\n-            {\"key\": \"a\"},\n-            {\"key\": \"b\"},\n-            {\"key\": \"c\"},\n-            {\"key\": \"d\"},\n-            {\"key\": \"e\"},\n+            {\"key\": \"oid1\"},\n+            {\"key\": \"oid2\"},\n+            {\"key\": \"oid3\"},\n         ]\n     )\n-    oid = inserted_result.inserted_ids\n+    ids = inserted_result.inserted_ids\n \n     node = started_cluster.instances[\"node\"]\n     node.query(\n@@ -1062,42 +997,53 @@ def test_oid(started_cluster):\n         \"\"\"\n     )\n \n-    assert node.query(\"SELECT COUNT() FROM oid_table\") == \"5\\n\"\n+    assert node.query(f\"SELECT COUNT() FROM oid_table\") == \"3\\n\"\n \n-    assert node.query(f\"SELECT key FROM oid_table WHERE _id = '{oid[0]}'\") == \"a\\n\"\n-    assert (\n-        node.query(f\"SELECT * FROM oid_table WHERE _id = '{oid[2]}'\")\n-        == f\"{oid[2]}\\tc\\n\"\n-    )\n-    assert node.query(f\"SELECT COUNT() FROM oid_table WHERE _id != '{oid[0]}'\") == \"4\\n\"\n-\n-    assert (\n-        node.query(\n-            f\"SELECT key FROM oid_table WHERE _id in ('{oid[0]}', '{oid[1]}') ORDER BY key\"\n-        )\n-        == \"a\\nb\\n\"\n-    )\n-    assert (\n-        node.query(\n-            f\"SELECT key FROM oid_table WHERE _id in ['{oid[0]}', '{oid[1]}'] ORDER BY key\"\n-        )\n-        == \"a\\nb\\n\"\n-    )\n-    assert (\n-        node.query(f\"SELECT key FROM oid_table WHERE _id in ('{oid[0]}') ORDER BY key\")\n-        == \"a\\n\"\n-    )\n-    assert (\n-        node.query(f\"SELECT key FROM oid_table WHERE _id in ['{oid[1]}'] ORDER BY key\")\n-        == \"b\\n\"\n-    )\n+    assert node.query(f\"SELECT _id FROM oid_table WHERE _id = '{str(ids[0])}'\") == f\"{str(ids[0])}\\n\"\n+    assert node.query(f\"SELECT key FROM oid_table WHERE _id = '{str(ids[0])}'\") == \"oid1\\n\"\n+    assert (node.query(f\"SELECT key FROM oid_table WHERE _id != '{str(ids[0])}' ORDER BY key\") ==\n+            \"oid2\\noid3\\n\")\n+    assert node.query(f\"SELECT key FROM oid_table WHERE _id in ['{ids[0]}', '{ids[1]}'] ORDER BY key\") == \"oid1\\noid2\\n\"\n+    assert node.query(f\"SELECT key FROM oid_table WHERE _id not in ['{ids[0]}', '{ids[1]}'] ORDER BY key\") == \"oid3\\n\"\n \n     with pytest.raises(QueryRuntimeException):\n-        node.query(\"SELECT * FROM oid_table WHERE _id = 'invalidOID'\")\n+        node.query(f\"SELECT * FROM oid_table WHERE _id = 'not-oid'\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT * FROM oid_table WHERE _id != 'not-oid'\")\n     with pytest.raises(QueryRuntimeException):\n-        node.query(\"SELECT * FROM oid_table WHERE _id = 123123\")\n+        node.query(f\"SELECT * FROM oid_table WHERE _id = 1234567\")\n     with pytest.raises(QueryRuntimeException):\n-        node.query(\"SELECT * FROM oid_table WHERE _id in (123123, 123)\")\n+        node.query(f\"SELECT * FROM oid_table WHERE _id != 1234567\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT key FROM oid_table WHERE _id in ['{ids[0]}', 'not-oid']\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT key FROM oid_table WHERE _id not in ['{ids[0]}', 'not-oid']\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT key FROM oid_table WHERE _id in ['nope', 'not-oid']\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT key FROM oid_table WHERE _id not in ['nope', 'not-oid']\")\n+\n+    node.query(\n+        \"\"\"\n+        CREATE OR REPLACE TABLE oid_table(\n+        _id  String,\n+        key  String\n+        ) ENGINE = MongoDB('mongo1:27017', 'test', 'oid_table', 'root', 'clickhouse', '', 'key')\n+        \"\"\"\n+    )\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT * FROM oid_table WHERE key = 'not-oid'\")\n+\n+    node.query(\n+        \"\"\"\n+        CREATE OR REPLACE TABLE oid_table(\n+        _id  String,\n+        key  String\n+        ) ENGINE = MongoDB('mongodb://mongo1:27017/test', 'oid_table', 'key')\n+        \"\"\"\n+    )\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT * FROM oid_table WHERE key = 'not-oid'\")\n \n     node.query(\"DROP TABLE oid_table\")\n     oid_mongo_table.drop()\n@@ -1111,8 +1057,19 @@ def test_uuid(started_cluster):\n     uuid_mongo_table = db[\"uuid_table\"]\n     uuid_mongo_table.insert_many(\n         [\n-            {\"isValid\": 0, \"kUUID\": \"bad_uuid\"},\n-            {\"isValid\": 1, \"kUUID\": \"f0e77736-91d1-48ce-8f01-15123ca1c7ed\"},\n+            {\"isValid\": 0, \"kUUID\": \"bad_uuid_string\"},\n+            {\n+                \"isValid\": 1,\n+                \"kUUID\": bson.Binary(\n+                    uuid.UUID(\"f0e77736-91d1-48ce-8f01-15123ca1c7ed\").bytes, subtype=0\n+                ),\n+            },\n+            {\n+                \"isValid\": 2,\n+                \"kUUID\": bson.Binary(\n+                    uuid.UUID(\"f0e77736-91d1-48ce-8f01-15123ca1c7ed\").bytes, subtype=4\n+                ),\n+            },\n         ]\n     )\n \n@@ -1126,13 +1083,12 @@ def test_uuid(started_cluster):\n         \"\"\"\n     )\n \n-    assert (\n-        node.query(f\"SELECT kUUID FROM uuid_table WHERE isValid = 1\")\n-        == \"f0e77736-91d1-48ce-8f01-15123ca1c7ed\\n\"\n-    )\n+    assert node.query(f\"SELECT kUUID FROM uuid_table WHERE isValid = 2\") == \"f0e77736-91d1-48ce-8f01-15123ca1c7ed\\n\"\n \n     with pytest.raises(QueryRuntimeException):\n         node.query(\"SELECT * FROM uuid_table WHERE isValid = 0\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(\"SELECT * FROM uuid_table WHERE isValid = 1\")\n     with pytest.raises(QueryRuntimeException):\n         node.query(\"SELECT * FROM uuid_table\")\n \ndiff --git a/tests/integration/test_table_function_mongodb/test.py b/tests/integration/test_table_function_mongodb/test.py\nindex b3e990cf73b1..c0bc0e508a21 100644\n--- a/tests/integration/test_table_function_mongodb/test.py\n+++ b/tests/integration/test_table_function_mongodb/test.py\n@@ -416,3 +416,67 @@ def test_missing_columns(started_cluster):\n     )\n     assert result == \"10\\n\"\n     simple_mongo_table.drop()\n+\n+\n+def test_oid(started_cluster):\n+    mongo_connection = get_mongo_connection(started_cluster)\n+    db = mongo_connection[\"test\"]\n+    db.command(\"dropAllUsersFromDatabase\")\n+    db.command(\"createUser\", \"root\", pwd=\"clickhouse\", roles=[\"readWrite\"])\n+    oid_mongo_table = db[\"oid_table\"]\n+    inserted_result = oid_mongo_table.insert_many(\n+        [\n+            {\"key\": \"oid1\"},\n+            {\"key\": \"oid2\"},\n+            {\"key\": \"oid3\"},\n+        ]\n+    )\n+    ids = inserted_result.inserted_ids\n+\n+    node = started_cluster.instances[\"node\"]\n+    table_definitions = [\n+        \"mongodb('mongo1:27017', 'test', 'oid_table', 'root', 'clickhouse', '_id String, key String')\",\n+        \"mongodb('mongodb://root:clickhouse@mongo1:27017/test', 'oid_table', '_id String, key String')\",\n+    ]\n+\n+    for table_definition in table_definitions:\n+        assert node.query(f\"SELECT COUNT() FROM {table_definition}\") == \"3\\n\"\n+\n+        assert node.query(f\"SELECT _id FROM {table_definition} WHERE _id = '{str(ids[0])}'\") == f\"{str(ids[0])}\\n\"\n+        assert node.query(f\"SELECT key FROM {table_definition} WHERE _id = '{str(ids[0])}'\") == \"oid1\\n\"\n+        assert (node.query(f\"SELECT key FROM {table_definition} WHERE _id != '{str(ids[0])}' ORDER BY key\") ==\n+                \"oid2\\noid3\\n\")\n+        assert (node.query(f\"SELECT key FROM {table_definition} WHERE _id in ['{ids[0]}', '{ids[1]}'] ORDER BY key\")\n+                == \"oid1\\noid2\\n\")\n+        assert (node.query(f\"SELECT key FROM {table_definition} WHERE _id not in ['{ids[0]}', '{ids[1]}'] ORDER BY key\")\n+                == \"oid3\\n\")\n+\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT * FROM {table_definition} WHERE _id = 'not-oid'\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT * FROM {table_definition} WHERE _id != 'not-oid'\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT * FROM {table_definition} WHERE _id = 1234567\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT * FROM {table_definition} WHERE _id != 1234567\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT key FROM {table_definition} WHERE _id in ['{ids[0]}', 'not-oid']\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT key FROM {table_definition} WHERE _id not in ['{ids[0]}', 'not-oid']\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT key FROM {table_definition} WHERE _id in ['nope', 'not-oid']\")\n+        with pytest.raises(QueryRuntimeException):\n+            node.query(f\"SELECT key FROM {table_definition} WHERE _id not in ['nope', 'not-oid']\")\n+\n+    table_definition = (\"mongodb('mongo1:27017', 'test', 'oid_table', 'root', 'clickhouse', '_id String, key String', \"\n+                        \"'', 'key)\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT * FROM {table_definition} WHERE key = 'not-oid'\")\n+\n+    table_definition = (\"mongodb('mongodb://root:clickhouse@mongo1:27017/test', 'oid_table', '_id String, key String', \"\n+                        \"'key')\")\n+    with pytest.raises(QueryRuntimeException):\n+        node.query(f\"SELECT * FROM {table_definition} WHERE key = 'not-oid'\")\n+\n+\n+    oid_mongo_table.drop()\n",
  "problem_statement": "Problems with new mongoDB implementation\nclickhouse v.24.10.2.80\r\n\r\nuse_legacy_mongodb_integration disabled\r\n\r\n1) Different execution time of table function and table engine\r\n\r\n```\r\n--mongo collection with \u00b14000000 records\r\nCREATE TABLE mongo_table\r\n(\r\n    `_id` String\r\n)\r\nENGINE = MongoDB('host:port', 'schema', 'table', 'user', 'pass', 'authSource=admin&connectTimeoutMS=36000');\r\n\r\nselect *\r\nfrom mongodb('host:port', 'schema', 'table', 'user', 'pass',\r\n             structure='_id String', options='authSource=admin&connectTimeoutMS=36000')\r\nwhere _id='my_id';\r\n\r\nselect * from mongo_table where _id='my_id';\r\n```\r\n\r\n```\r\nelapsed time for select from table function: **1 row retrieved starting from 1 in 2 m 42 s 769 ms (execution: 2 m 42 s 570 ms, fetching: 199 ms)**\r\nelapsed time for select from table engine: **1 row retrieved starting from 1 in 303 ms (execution: 83 ms, fetching: 220 ms)**\r\n```\r\n\r\nLooks that pushdown of where condition is not work for table function.\r\n\r\n2) Also, i have some troubles with select from table function with limit.\r\n\r\nFor some cases \r\n```\r\nselect *\r\nfrom mongodb('host:port', 'schema', 'table', 'user', 'pass',\r\n             structure='_id String', options='authSource=admin&connectTimeoutMS=36000')\r\nwhere _id='my_id'\r\nlimit 1; --different behaviour for query with and without limit clause\r\n```\r\nreturn 0 records with limit, and 1 record without limit(and its correct) \nIncorrect MongoDB UUID conversion to Clickhouse ?\n### Company or project name\n\n_No response_\n\n### Question\n\nI am working with MongoDB engine in my project.\r\nIn MongoDB in a collection I have an identifier of the form:\r\n`_id: UUID('d0b3997a-0907-4d29-b685-a55beb9fe727')`\r\n\r\nI deployed in clickhouse docker version 24.8 with a setting in the config \r\n`<use_legacy_mongodb_integration>true<use_legacy_mongodb_integration>` and everything worked fine.\r\n\r\nThe `_id: UUID('d0b3997a-0907-4d29-4d29-b685-a55beb9fe727')` was successfully converted to a UUID of the form 'd0b3997a-0907-4d29-4d29-b685-a55beb9fe727' in clickhouse.\r\n\r\nI recently saw that in the `24.10` release they added the ability to get nested data from MongoDB, which also made me happy. The instructions said to set the `use_legacy_mongodb_integration` setting to false, which I did. \r\nAfter that I couldn't get `_id: UUID('d0b3997a-0907-4d29-b685-a55beb9fe727')` from MongoDB as UUID, I get an error\r\n\r\n```\r\nCode: 53. DB::Exception: Type mismatch, expected string (UUID), got binary for column _id: While executing MongoDB. (TYPE_MISMATCH)\r\n```\r\n\r\nIf I get it as String, I get an unreadable value: `\u0433\ufffdz\t\u0007M)\ufffd\ufffd\ufffd[\ufffd\ufffd'`\r\n\r\nThe same with version 24.11.\r\nBut as soon as I enable `use_legacy_mongodb_integration` = false - the conversion works correctly.\r\n\r\n\r\nCould you please tell me what could be wrong, am I doing something wrong or is this a potential bug?\n",
  "hints_text": "@allmazz \nit seems to be a bug. please enable debug logs, and attach them to the issue\n@allmazz \r\nI saw in the changelogs that it looks like you've basically implemented nested type support for MongoDB. Do you know anything about the problem above?\nI will take a look and fix if needed.\n> I will take a look and fix if needed.\n\nThank you, that would be great.\nI'll be looking forward to updates.",
  "created_at": "2025-02-26T02:34:30Z"
}