{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 63993,
  "instance_id": "ClickHouse__ClickHouse-63993",
  "issue_numbers": [
    "63205"
  ],
  "base_commit": "4ee498a8b55a779948fe722cb139139036ba5fb2",
  "patch": "diff --git a/src/Analyzer/Passes/QueryAnalysisPass.cpp b/src/Analyzer/Passes/QueryAnalysisPass.cpp\nindex bfe2f981c638..2d34f1024d56 100644\n--- a/src/Analyzer/Passes/QueryAnalysisPass.cpp\n+++ b/src/Analyzer/Passes/QueryAnalysisPass.cpp\n@@ -586,6 +586,85 @@ class ExpressionsStack\n     std::unordered_map<std::string, QueryTreeNodes> alias_name_to_expressions;\n };\n \n+struct ScopeAliases\n+{\n+    /// Alias name to query expression node\n+    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node_before_group_by;\n+    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node_after_group_by;\n+\n+    std::unordered_map<std::string, QueryTreeNodePtr> * alias_name_to_expression_node = nullptr;\n+\n+    /// Alias name to lambda node\n+    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_lambda_node;\n+\n+    /// Alias name to table expression node\n+    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_table_expression_node;\n+\n+    /// Expressions like `x as y` where we can't say whether it's a function, expression or table.\n+    std::unordered_map<std::string, Identifier> transitive_aliases;\n+\n+    /// Nodes with duplicated aliases\n+    std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;\n+    std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;\n+\n+    std::unordered_map<std::string, QueryTreeNodePtr> & getAliasMap(IdentifierLookupContext lookup_context)\n+    {\n+        switch (lookup_context)\n+        {\n+            case IdentifierLookupContext::EXPRESSION: return *alias_name_to_expression_node;\n+            case IdentifierLookupContext::FUNCTION: return alias_name_to_lambda_node;\n+            case IdentifierLookupContext::TABLE_EXPRESSION: return alias_name_to_table_expression_node;\n+        }\n+    }\n+\n+    enum class FindOption\n+    {\n+        FIRST_NAME,\n+        FULL_NAME,\n+    };\n+\n+    const std::string & getKey(const Identifier & identifier, FindOption find_option)\n+    {\n+        switch (find_option)\n+        {\n+            case FindOption::FIRST_NAME: return identifier.front();\n+            case FindOption::FULL_NAME: return identifier.getFullName();\n+        }\n+    }\n+\n+    QueryTreeNodePtr * find(IdentifierLookup lookup, FindOption find_option)\n+    {\n+        auto & alias_map = getAliasMap(lookup.lookup_context);\n+        const std::string * key = &getKey(lookup.identifier, find_option);\n+\n+        auto it = alias_map.find(*key);\n+\n+        if (it != alias_map.end())\n+            return &it->second;\n+\n+        if (lookup.lookup_context == IdentifierLookupContext::TABLE_EXPRESSION)\n+            return {};\n+\n+        while (it == alias_map.end())\n+        {\n+            auto jt = transitive_aliases.find(*key);\n+            if (jt == transitive_aliases.end())\n+                return {};\n+\n+            key = &(getKey(jt->second, find_option));\n+            it = alias_map.find(*key);\n+        }\n+\n+        return &it->second;\n+    }\n+\n+    const QueryTreeNodePtr * find(IdentifierLookup lookup, FindOption find_option) const\n+    {\n+        return const_cast<ScopeAliases *>(this)->find(lookup, find_option);\n+    }\n+};\n+\n+\n /** Projection names is name of query tree node that is used in projection part of query node.\n   * Example: SELECT id FROM test_table;\n   * `id` is projection name of column node\n@@ -731,7 +810,7 @@ struct IdentifierResolveScope\n         else if (parent_scope)\n             join_use_nulls = parent_scope->join_use_nulls;\n \n-        alias_name_to_expression_node = &alias_name_to_expression_node_before_group_by;\n+        aliases.alias_name_to_expression_node = &aliases.alias_name_to_expression_node_before_group_by;\n     }\n \n     QueryTreeNodePtr scope_node;\n@@ -746,17 +825,7 @@ struct IdentifierResolveScope\n     /// Argument can be expression like constant, column, function or table expression\n     std::unordered_map<std::string, QueryTreeNodePtr> expression_argument_name_to_node;\n \n-    /// Alias name to query expression node\n-    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node_before_group_by;\n-    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_expression_node_after_group_by;\n-\n-    std::unordered_map<std::string, QueryTreeNodePtr> * alias_name_to_expression_node = nullptr;\n-\n-    /// Alias name to lambda node\n-    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_lambda_node;\n-\n-    /// Alias name to table expression node\n-    std::unordered_map<std::string, QueryTreeNodePtr> alias_name_to_table_expression_node;\n+    ScopeAliases aliases;\n \n     /// Table column name to column node. Valid only during table ALIAS columns resolve.\n     ColumnNameToColumnNodeMap column_name_to_column_node;\n@@ -767,10 +836,6 @@ struct IdentifierResolveScope\n     /// Window name to window node\n     std::unordered_map<std::string, QueryTreeNodePtr> window_name_to_window_node;\n \n-    /// Nodes with duplicated aliases\n-    std::unordered_set<QueryTreeNodePtr> nodes_with_duplicated_aliases;\n-    std::vector<QueryTreeNodePtr> cloned_nodes_with_duplicated_aliases;\n-\n     /// Current scope expression in resolve process stack\n     ExpressionsStack expressions_in_resolve_process_stack;\n \n@@ -889,7 +954,7 @@ struct IdentifierResolveScope\n         bool had_aggregate_function = expressions_in_resolve_process_stack.hasAggregateFunction();\n         expressions_in_resolve_process_stack.push(node);\n         if (group_by_use_nulls && had_aggregate_function != expressions_in_resolve_process_stack.hasAggregateFunction())\n-            alias_name_to_expression_node = &alias_name_to_expression_node_before_group_by;\n+            aliases.alias_name_to_expression_node = &aliases.alias_name_to_expression_node_before_group_by;\n     }\n \n     void popExpressionNode()\n@@ -897,7 +962,7 @@ struct IdentifierResolveScope\n         bool had_aggregate_function = expressions_in_resolve_process_stack.hasAggregateFunction();\n         expressions_in_resolve_process_stack.pop();\n         if (group_by_use_nulls && had_aggregate_function != expressions_in_resolve_process_stack.hasAggregateFunction())\n-            alias_name_to_expression_node = &alias_name_to_expression_node_after_group_by;\n+            aliases.alias_name_to_expression_node = &aliases.alias_name_to_expression_node_after_group_by;\n     }\n \n     /// Dump identifier resolve scope\n@@ -916,16 +981,16 @@ struct IdentifierResolveScope\n         for (const auto & [alias_name, node] : expression_argument_name_to_node)\n             buffer << \"Alias name \" << alias_name << \" node \" << node->formatASTForErrorMessage() << '\\n';\n \n-        buffer << \"Alias name to expression node table size \" << alias_name_to_expression_node->size() << '\\n';\n-        for (const auto & [alias_name, node] : *alias_name_to_expression_node)\n+        buffer << \"Alias name to expression node table size \" << aliases.alias_name_to_expression_node->size() << '\\n';\n+        for (const auto & [alias_name, node] : *aliases.alias_name_to_expression_node)\n             buffer << \"Alias name \" << alias_name << \" expression node \" << node->dumpTree() << '\\n';\n \n-        buffer << \"Alias name to function node table size \" << alias_name_to_lambda_node.size() << '\\n';\n-        for (const auto & [alias_name, node] : alias_name_to_lambda_node)\n+        buffer << \"Alias name to function node table size \" << aliases.alias_name_to_lambda_node.size() << '\\n';\n+        for (const auto & [alias_name, node] : aliases.alias_name_to_lambda_node)\n             buffer << \"Alias name \" << alias_name << \" lambda node \" << node->formatASTForErrorMessage() << '\\n';\n \n-        buffer << \"Alias name to table expression node table size \" << alias_name_to_table_expression_node.size() << '\\n';\n-        for (const auto & [alias_name, node] : alias_name_to_table_expression_node)\n+        buffer << \"Alias name to table expression node table size \" << aliases.alias_name_to_table_expression_node.size() << '\\n';\n+        for (const auto & [alias_name, node] : aliases.alias_name_to_table_expression_node)\n             buffer << \"Alias name \" << alias_name << \" node \" << node->formatASTForErrorMessage() << '\\n';\n \n         buffer << \"CTE name to query node table size \" << cte_name_to_query_node.size() << '\\n';\n@@ -936,8 +1001,8 @@ struct IdentifierResolveScope\n         for (const auto & [window_name, node] : window_name_to_window_node)\n             buffer << \"CTE name \" << window_name << \" node \" << node->formatASTForErrorMessage() << '\\n';\n \n-        buffer << \"Nodes with duplicated aliases size \" << nodes_with_duplicated_aliases.size() << '\\n';\n-        for (const auto & node : nodes_with_duplicated_aliases)\n+        buffer << \"Nodes with duplicated aliases size \" << aliases.nodes_with_duplicated_aliases.size() << '\\n';\n+        for (const auto & node : aliases.nodes_with_duplicated_aliases)\n             buffer << \"Alias name \" << node->getAlias() << \" node \" << node->formatASTForErrorMessage() << '\\n';\n \n         buffer << \"Expression resolve process stack \" << '\\n';\n@@ -996,8 +1061,8 @@ struct IdentifierResolveScope\n class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpressionsAliasVisitor>\n {\n public:\n-    explicit QueryExpressionsAliasVisitor(IdentifierResolveScope & scope_)\n-        : scope(scope_)\n+    explicit QueryExpressionsAliasVisitor(ScopeAliases & aliases_)\n+        : aliases(aliases_)\n     {}\n \n     void visitImpl(QueryTreeNodePtr & node)\n@@ -1034,10 +1099,10 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress\n private:\n     void addDuplicatingAlias(const QueryTreeNodePtr & node)\n     {\n-        scope.nodes_with_duplicated_aliases.emplace(node);\n+        aliases.nodes_with_duplicated_aliases.emplace(node);\n         auto cloned_node = node->clone();\n-        scope.cloned_nodes_with_duplicated_aliases.emplace_back(cloned_node);\n-        scope.nodes_with_duplicated_aliases.emplace(cloned_node);\n+        aliases.cloned_nodes_with_duplicated_aliases.emplace_back(cloned_node);\n+        aliases.nodes_with_duplicated_aliases.emplace(cloned_node);\n     }\n \n     void updateAliasesIfNeeded(const QueryTreeNodePtr & node, bool is_lambda_node)\n@@ -1053,29 +1118,29 @@ class QueryExpressionsAliasVisitor : public InDepthQueryTreeVisitor<QueryExpress\n \n         if (is_lambda_node)\n         {\n-            if (scope.alias_name_to_expression_node->contains(alias))\n+            if (aliases.alias_name_to_expression_node->contains(alias))\n                 addDuplicatingAlias(node);\n \n-            auto [_, inserted] = scope.alias_name_to_lambda_node.insert(std::make_pair(alias, node));\n+            auto [_, inserted] = aliases.alias_name_to_lambda_node.insert(std::make_pair(alias, node));\n             if (!inserted)\n              addDuplicatingAlias(node);\n \n             return;\n         }\n \n-        if (scope.alias_name_to_lambda_node.contains(alias))\n-         addDuplicatingAlias(node);\n+        if (aliases.alias_name_to_lambda_node.contains(alias))\n+            addDuplicatingAlias(node);\n \n-        auto [_, inserted] = scope.alias_name_to_expression_node->insert(std::make_pair(alias, node));\n+        auto [_, inserted] = aliases.alias_name_to_expression_node->insert(std::make_pair(alias, node));\n         if (!inserted)\n-         addDuplicatingAlias(node);\n+            addDuplicatingAlias(node);\n \n-        /// If node is identifier put it also in scope alias name to lambda node map\n-        if (node->getNodeType() == QueryTreeNodeType::IDENTIFIER)\n-            scope.alias_name_to_lambda_node.insert(std::make_pair(alias, node));\n+        /// If node is identifier put it into transitive aliases map.\n+        if (const auto * identifier = typeid_cast<const IdentifierNode *>(node.get()))\n+            aliases.transitive_aliases.insert(std::make_pair(alias, identifier->getIdentifier()));\n     }\n \n-    IdentifierResolveScope & scope;\n+    ScopeAliases & aliases;\n };\n \n class TableExpressionsAliasVisitor : public InDepthQueryTreeVisitor<TableExpressionsAliasVisitor>\n@@ -1122,7 +1187,7 @@ class TableExpressionsAliasVisitor : public InDepthQueryTreeVisitor<TableExpress\n             return;\n \n         const auto & node_alias = node->getAlias();\n-        auto [_, inserted] = scope.alias_name_to_table_expression_node.emplace(node_alias, node);\n+        auto [_, inserted] = scope.aliases.alias_name_to_table_expression_node.emplace(node_alias, node);\n         if (!inserted)\n             throw Exception(ErrorCodes::MULTIPLE_EXPRESSIONS_FOR_ALIAS,\n                 \"Multiple table expressions with same alias {}. In scope {}\",\n@@ -1193,7 +1258,7 @@ class QueryAnalyzer\n             }\n             case QueryTreeNodeType::TABLE_FUNCTION:\n             {\n-                QueryExpressionsAliasVisitor expressions_alias_visitor(scope);\n+                QueryExpressionsAliasVisitor expressions_alias_visitor(scope.aliases);\n                 resolveTableFunction(node, scope, expressions_alias_visitor, false /*nested_table_function*/);\n                 break;\n             }\n@@ -1868,7 +1933,7 @@ void QueryAnalyzer::collectScopeValidIdentifiersForTypoCorrection(\n \n     if (allow_expression_identifiers)\n     {\n-        for (const auto & [name, expression] : *scope.alias_name_to_expression_node)\n+        for (const auto & [name, expression] : *scope.aliases.alias_name_to_expression_node)\n         {\n             assert(expression);\n             auto expression_identifier = Identifier(name);\n@@ -1898,13 +1963,13 @@ void QueryAnalyzer::collectScopeValidIdentifiersForTypoCorrection(\n     {\n         if (allow_function_identifiers)\n         {\n-            for (const auto & [name, _] : *scope.alias_name_to_expression_node)\n+            for (const auto & [name, _] : *scope.aliases.alias_name_to_expression_node)\n                 valid_identifiers_result.insert(Identifier(name));\n         }\n \n         if (allow_table_expression_identifiers)\n         {\n-            for (const auto & [name, _] : scope.alias_name_to_table_expression_node)\n+            for (const auto & [name, _] : scope.aliases.alias_name_to_table_expression_node)\n                 valid_identifiers_result.insert(Identifier(name));\n         }\n     }\n@@ -2793,21 +2858,7 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromExpressionArguments(cons\n \n bool QueryAnalyzer::tryBindIdentifierToAliases(const IdentifierLookup & identifier_lookup, const IdentifierResolveScope & scope)\n {\n-    const auto & identifier_bind_part = identifier_lookup.identifier.front();\n-\n-    auto get_alias_name_to_node_map = [&]() -> const std::unordered_map<std::string, QueryTreeNodePtr> &\n-    {\n-        if (identifier_lookup.isExpressionLookup())\n-            return *scope.alias_name_to_expression_node;\n-        else if (identifier_lookup.isFunctionLookup())\n-            return scope.alias_name_to_lambda_node;\n-\n-        return scope.alias_name_to_table_expression_node;\n-    };\n-\n-    const auto & alias_name_to_node_map = get_alias_name_to_node_map();\n-\n-    return alias_name_to_node_map.contains(identifier_bind_part);\n+    return scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME) != nullptr;\n }\n \n /** Resolve identifier from scope aliases.\n@@ -2857,23 +2908,13 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier\n {\n     const auto & identifier_bind_part = identifier_lookup.identifier.front();\n \n-    auto get_alias_name_to_node_map = [&]() -> std::unordered_map<std::string, QueryTreeNodePtr> &\n-    {\n-        if (identifier_lookup.isExpressionLookup())\n-            return *scope.alias_name_to_expression_node;\n-        else if (identifier_lookup.isFunctionLookup())\n-            return scope.alias_name_to_lambda_node;\n-\n-        return scope.alias_name_to_table_expression_node;\n-    };\n-\n-    auto & alias_name_to_node_map = get_alias_name_to_node_map();\n-    auto it = alias_name_to_node_map.find(identifier_bind_part);\n-\n-    if (it == alias_name_to_node_map.end())\n+    auto * it = scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FIRST_NAME);\n+    if (it == nullptr)\n         return {};\n \n-    if (!it->second)\n+    QueryTreeNodePtr & alias_node = *it;\n+\n+    if (!alias_node)\n         throw Exception(ErrorCodes::LOGICAL_ERROR,\n             \"Node with alias {} is not valid. In scope {}\",\n             identifier_bind_part,\n@@ -2893,14 +2934,14 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier\n         return {};\n     }\n \n-    auto node_type = it->second->getNodeType();\n+    auto node_type = alias_node->getNodeType();\n \n     /// Resolve expression if necessary\n     if (node_type == QueryTreeNodeType::IDENTIFIER)\n     {\n-        scope.pushExpressionNode(it->second);\n+        scope.pushExpressionNode(alias_node);\n \n-        auto & alias_identifier_node = it->second->as<IdentifierNode &>();\n+        auto & alias_identifier_node = alias_node->as<IdentifierNode &>();\n         auto identifier = alias_identifier_node.getIdentifier();\n         auto lookup_result = tryResolveIdentifier(IdentifierLookup{identifier, identifier_lookup.lookup_context}, scope, identifier_resolve_settings);\n         if (!lookup_result.resolved_identifier)\n@@ -2916,43 +2957,27 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier\n                 getHintsErrorMessageSuffix(hints));\n         }\n \n-        it->second = lookup_result.resolved_identifier;\n-\n-        /** During collection of aliases if node is identifier and has alias, we cannot say if it is\n-          * column or function node. Check QueryExpressionsAliasVisitor documentation for clarification.\n-          *\n-          * If we resolved identifier node as expression, we must remove identifier node alias from\n-          * function alias map.\n-          * If we resolved identifier node as function, we must remove identifier node alias from\n-          * expression alias map.\n-          */\n-        if (identifier_lookup.isExpressionLookup())\n-            scope.alias_name_to_lambda_node.erase(identifier_bind_part);\n-        else if (identifier_lookup.isFunctionLookup())\n-            scope.alias_name_to_expression_node->erase(identifier_bind_part);\n-\n+        alias_node = lookup_result.resolved_identifier;\n         scope.popExpressionNode();\n     }\n     else if (node_type == QueryTreeNodeType::FUNCTION)\n     {\n-        resolveExpressionNode(it->second, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n+        resolveExpressionNode(alias_node, scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n     }\n     else if (node_type == QueryTreeNodeType::QUERY || node_type == QueryTreeNodeType::UNION)\n     {\n         if (identifier_resolve_settings.allow_to_resolve_subquery_during_identifier_resolution)\n-            resolveExpressionNode(it->second, scope, false /*allow_lambda_expression*/, identifier_lookup.isTableExpressionLookup() /*allow_table_expression*/);\n+            resolveExpressionNode(alias_node, scope, false /*allow_lambda_expression*/, identifier_lookup.isTableExpressionLookup() /*allow_table_expression*/);\n     }\n \n-    QueryTreeNodePtr result = it->second;\n-\n-    if (identifier_lookup.identifier.isCompound() && result)\n+    if (identifier_lookup.identifier.isCompound() && alias_node)\n     {\n         if (identifier_lookup.isExpressionLookup())\n         {\n             return tryResolveIdentifierFromCompoundExpression(\n                 identifier_lookup.identifier,\n                 1 /*identifier_bind_size*/,\n-                it->second,\n+                alias_node,\n                 {} /* compound_expression_source */,\n                 scope,\n                 identifier_resolve_settings.allow_to_check_join_tree /* can_be_not_found */);\n@@ -2967,7 +2992,7 @@ QueryTreeNodePtr QueryAnalyzer::tryResolveIdentifierFromAliases(const Identifier\n         }\n     }\n \n-    return result;\n+    return alias_node;\n }\n \n /** Resolve identifier from table columns.\n@@ -4128,10 +4153,11 @@ IdentifierResolveResult QueryAnalyzer::tryResolveIdentifier(const IdentifierLook\n              * SELECT id FROM ( SELECT ... ) AS subquery ARRAY JOIN [0] AS id INNER JOIN second_table USING (id)\n              * In the example, identifier `id` should be resolved into one from USING (id) column.\n              */\n-            auto alias_it = scope.alias_name_to_expression_node->find(identifier_lookup.identifier.getFullName());\n-            if (alias_it != scope.alias_name_to_expression_node->end() && alias_it->second->getNodeType() == QueryTreeNodeType::COLUMN)\n+\n+            auto * alias_it = scope.aliases.find(identifier_lookup, ScopeAliases::FindOption::FULL_NAME);\n+            if (alias_it && (*alias_it)->getNodeType() == QueryTreeNodeType::COLUMN)\n             {\n-                const auto & column_node = alias_it->second->as<ColumnNode &>();\n+                const auto & column_node = (*alias_it)->as<ColumnNode &>();\n                 if (column_node.getColumnSource()->getNodeType() == QueryTreeNodeType::ARRAY_JOIN)\n                     prefer_column_name_to_alias = true;\n             }\n@@ -5236,7 +5262,7 @@ ProjectionNames QueryAnalyzer::resolveLambda(const QueryTreeNodePtr & lambda_nod\n             scope.scope_node->formatASTForErrorMessage());\n \n     /// Initialize aliases in lambda scope\n-    QueryExpressionsAliasVisitor visitor(scope);\n+    QueryExpressionsAliasVisitor visitor(scope.aliases);\n     visitor.visit(lambda_to_resolve.getExpression());\n \n     /** Replace lambda arguments with new arguments.\n@@ -5256,8 +5282,8 @@ ProjectionNames QueryAnalyzer::resolveLambda(const QueryTreeNodePtr & lambda_nod\n         const auto & lambda_argument_name = lambda_argument_identifier ? lambda_argument_identifier->getIdentifier().getFullName()\n                                                                        : lambda_argument_column->getColumnName();\n \n-        bool has_expression_node = scope.alias_name_to_expression_node->contains(lambda_argument_name);\n-        bool has_alias_node = scope.alias_name_to_lambda_node.contains(lambda_argument_name);\n+        bool has_expression_node = scope.aliases.alias_name_to_expression_node->contains(lambda_argument_name);\n+        bool has_alias_node = scope.aliases.alias_name_to_lambda_node.contains(lambda_argument_name);\n \n         if (has_expression_node || has_alias_node)\n         {\n@@ -5933,7 +5959,7 @@ ProjectionNames QueryAnalyzer::resolveFunction(QueryTreeNodePtr & node, Identifi\n             function_names = AggregateFunctionFactory::instance().getAllRegisteredNames();\n             possible_function_names.insert(possible_function_names.end(), function_names.begin(), function_names.end());\n \n-            for (auto & [name, lambda_node] : scope.alias_name_to_lambda_node)\n+            for (auto & [name, lambda_node] : scope.aliases.alias_name_to_lambda_node)\n             {\n                 if (lambda_node->getNodeType() == QueryTreeNodeType::LAMBDA)\n                     possible_function_names.push_back(name);\n@@ -6267,7 +6293,7 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n         result_projection_names.push_back(node_alias);\n     }\n \n-    bool is_duplicated_alias = scope.nodes_with_duplicated_aliases.contains(node);\n+    bool is_duplicated_alias = scope.aliases.nodes_with_duplicated_aliases.contains(node);\n     if (is_duplicated_alias)\n         scope.non_cached_identifier_lookups_during_expression_resolve.insert({Identifier{node_alias}, IdentifierLookupContext::EXPRESSION});\n \n@@ -6291,14 +6317,14 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n           *\n           * To resolve b we need to resolve a.\n           */\n-        auto it = scope.alias_name_to_expression_node->find(node_alias);\n-        if (it != scope.alias_name_to_expression_node->end())\n+        auto it = scope.aliases.alias_name_to_expression_node->find(node_alias);\n+        if (it != scope.aliases.alias_name_to_expression_node->end())\n             node = it->second;\n \n         if (allow_lambda_expression)\n         {\n-            it = scope.alias_name_to_lambda_node.find(node_alias);\n-            if (it != scope.alias_name_to_lambda_node.end())\n+            it = scope.aliases.alias_name_to_lambda_node.find(node_alias);\n+            if (it != scope.aliases.alias_name_to_lambda_node.end())\n                 node = it->second;\n         }\n     }\n@@ -6324,17 +6350,9 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n                     result_projection_names.push_back(projection_name_it->second);\n             }\n \n-            if (resolved_identifier_node && !node_alias.empty())\n-                scope.alias_name_to_lambda_node.erase(node_alias);\n-\n             if (!resolved_identifier_node && allow_lambda_expression)\n-            {\n                 resolved_identifier_node = tryResolveIdentifier({unresolved_identifier, IdentifierLookupContext::FUNCTION}, scope).resolved_identifier;\n \n-                if (resolved_identifier_node && !node_alias.empty())\n-                    scope.alias_name_to_expression_node->erase(node_alias);\n-            }\n-\n             if (!resolved_identifier_node && allow_table_expression)\n             {\n                 resolved_identifier_node = tryResolveIdentifier({unresolved_identifier, IdentifierLookupContext::TABLE_EXPRESSION}, scope).resolved_identifier;\n@@ -6573,14 +6591,14 @@ ProjectionNames QueryAnalyzer::resolveExpressionNode(QueryTreeNodePtr & node, Id\n       */\n     if (!node_alias.empty() && use_alias_table && !scope.group_by_use_nulls)\n     {\n-        auto it = scope.alias_name_to_expression_node->find(node_alias);\n-        if (it != scope.alias_name_to_expression_node->end())\n+        auto it = scope.aliases.alias_name_to_expression_node->find(node_alias);\n+        if (it != scope.aliases.alias_name_to_expression_node->end())\n             it->second = node;\n \n         if (allow_lambda_expression)\n         {\n-            it = scope.alias_name_to_lambda_node.find(node_alias);\n-            if (it != scope.alias_name_to_lambda_node.end())\n+            it = scope.aliases.alias_name_to_lambda_node.find(node_alias);\n+            if (it != scope.aliases.alias_name_to_lambda_node.end())\n                 it->second = node;\n         }\n     }\n@@ -6953,8 +6971,8 @@ void QueryAnalyzer::initializeQueryJoinTreeNode(QueryTreeNodePtr & join_tree_nod\n                 resolved_identifier = resolved_identifier->clone();\n \n                 /// Update alias name to table expression map\n-                auto table_expression_it = scope.alias_name_to_table_expression_node.find(from_table_identifier_alias);\n-                if (table_expression_it != scope.alias_name_to_table_expression_node.end())\n+                auto table_expression_it = scope.aliases.alias_name_to_table_expression_node.find(from_table_identifier_alias);\n+                if (table_expression_it != scope.aliases.alias_name_to_table_expression_node.end())\n                     table_expression_it->second = resolved_identifier;\n \n                 auto table_expression_modifiers = from_table_identifier.getTableExpressionModifiers();\n@@ -7153,7 +7171,7 @@ void QueryAnalyzer::initializeTableExpressionData(const QueryTreeNodePtr & table\n             alias_column_resolve_scope.context = scope.context;\n \n             /// Initialize aliases in alias column scope\n-            QueryExpressionsAliasVisitor visitor(alias_column_resolve_scope);\n+            QueryExpressionsAliasVisitor visitor(alias_column_resolve_scope.aliases);\n             visitor.visit(alias_column_to_resolve->getExpression());\n \n             resolveExpressionNode(alias_column_resolve_scope.scope_node,\n@@ -7523,7 +7541,7 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n     for (auto & array_join_expression : array_join_nodes)\n     {\n         auto array_join_expression_alias = array_join_expression->getAlias();\n-        if (!array_join_expression_alias.empty() && scope.alias_name_to_expression_node->contains(array_join_expression_alias))\n+        if (!array_join_expression_alias.empty() && scope.aliases.alias_name_to_expression_node->contains(array_join_expression_alias))\n             throw Exception(ErrorCodes::MULTIPLE_EXPRESSIONS_FOR_ALIAS,\n                 \"ARRAY JOIN expression {} with duplicate alias {}. In scope {}\",\n                 array_join_expression->formatASTForErrorMessage(),\n@@ -7617,8 +7635,8 @@ void QueryAnalyzer::resolveArrayJoin(QueryTreeNodePtr & array_join_node, Identif\n     array_join_nodes = std::move(array_join_column_expressions);\n     for (auto & array_join_column_expression : array_join_nodes)\n     {\n-        auto it = scope.alias_name_to_expression_node->find(array_join_column_expression->getAlias());\n-        if (it != scope.alias_name_to_expression_node->end())\n+        auto it = scope.aliases.alias_name_to_expression_node->find(array_join_column_expression->getAlias());\n+        if (it != scope.aliases.alias_name_to_expression_node->end())\n         {\n             auto & array_join_column_expression_typed = array_join_column_expression->as<ColumnNode &>();\n             auto array_join_column = std::make_shared<ColumnNode>(array_join_column_expression_typed.getColumn(),\n@@ -7915,7 +7933,7 @@ void QueryAnalyzer::resolveQueryJoinTreeNode(QueryTreeNodePtr & join_tree_node,\n         if (alias_name.empty())\n             return;\n \n-        auto [it, inserted] = scope.alias_name_to_table_expression_node.emplace(alias_name, table_expression_node);\n+        auto [it, inserted] = scope.aliases.alias_name_to_table_expression_node.emplace(alias_name, table_expression_node);\n         if (!inserted)\n             throw Exception(ErrorCodes::MULTIPLE_EXPRESSIONS_FOR_ALIAS,\n                 \"Duplicate aliases {} for table expressions in FROM section are not allowed. Try to register {}. Already registered {}.\",\n@@ -7984,7 +8002,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"WITH TOTALS and WITH ROLLUP or CUBE are not supported together in presence of QUALIFY\");\n \n     /// Initialize aliases in query node scope\n-    QueryExpressionsAliasVisitor visitor(scope);\n+    QueryExpressionsAliasVisitor visitor(scope.aliases);\n \n     if (query_node_typed.hasWith())\n         visitor.visit(query_node_typed.getWithNode());\n@@ -8102,7 +8120,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n         table_expressions_visitor.visit(query_node_typed.getJoinTree());\n \n         initializeQueryJoinTreeNode(query_node_typed.getJoinTree(), scope);\n-        scope.alias_name_to_table_expression_node.clear();\n+        scope.aliases.alias_name_to_table_expression_node.clear();\n \n         resolveQueryJoinTreeNode(query_node_typed.getJoinTree(), scope, visitor);\n     }\n@@ -8152,10 +8170,10 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n         /// Clone is needed cause aliases share subtrees.\n         /// If not clone, the same (shared) subtree could be resolved again with different (Nullable) type\n         /// See 03023_group_by_use_nulls_analyzer_crashes\n-        for (auto & [key, node] : scope.alias_name_to_expression_node_before_group_by)\n-            scope.alias_name_to_expression_node_after_group_by[key] = node->clone();\n+        for (auto & [key, node] : scope.aliases.alias_name_to_expression_node_before_group_by)\n+            scope.aliases.alias_name_to_expression_node_after_group_by[key] = node->clone();\n \n-        scope.alias_name_to_expression_node = &scope.alias_name_to_expression_node_after_group_by;\n+        scope.aliases.alias_name_to_expression_node = &scope.aliases.alias_name_to_expression_node_after_group_by;\n     }\n \n     if (query_node_typed.hasHaving())\n@@ -8227,7 +8245,7 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n       * After scope nodes are resolved, we can compare node with duplicate alias with\n       * node from scope alias table.\n       */\n-    for (const auto & node_with_duplicated_alias : scope.cloned_nodes_with_duplicated_aliases)\n+    for (const auto & node_with_duplicated_alias : scope.aliases.cloned_nodes_with_duplicated_aliases)\n     {\n         auto node = node_with_duplicated_alias;\n         auto node_alias = node->getAlias();\n@@ -8238,8 +8256,8 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n \n         bool has_node_in_alias_table = false;\n \n-        auto it = scope.alias_name_to_expression_node->find(node_alias);\n-        if (it != scope.alias_name_to_expression_node->end())\n+        auto it = scope.aliases.alias_name_to_expression_node->find(node_alias);\n+        if (it != scope.aliases.alias_name_to_expression_node->end())\n         {\n             has_node_in_alias_table = true;\n \n@@ -8252,8 +8270,8 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n                     scope.scope_node->formatASTForErrorMessage());\n         }\n \n-        it = scope.alias_name_to_lambda_node.find(node_alias);\n-        if (it != scope.alias_name_to_lambda_node.end())\n+        it = scope.aliases.alias_name_to_lambda_node.find(node_alias);\n+        if (it != scope.aliases.alias_name_to_lambda_node.end())\n         {\n             has_node_in_alias_table = true;\n \n@@ -8298,10 +8316,10 @@ void QueryAnalyzer::resolveQuery(const QueryTreeNodePtr & query_node, Identifier\n \n     /// Remove aliases from expression and lambda nodes\n \n-    for (auto & [_, node] : *scope.alias_name_to_expression_node)\n+    for (auto & [_, node] : *scope.aliases.alias_name_to_expression_node)\n         node->removeAlias();\n \n-    for (auto & [_, node] : scope.alias_name_to_lambda_node)\n+    for (auto & [_, node] : scope.aliases.alias_name_to_lambda_node)\n         node->removeAlias();\n \n     query_node_typed.resolveProjectionColumns(std::move(projection_columns));\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02341_analyzer_aliases_basics.reference b/tests/queries/0_stateless/02341_analyzer_aliases_basics.reference\nindex 3733d6b6084c..e39cdce92b08 100644\n--- a/tests/queries/0_stateless/02341_analyzer_aliases_basics.reference\n+++ b/tests/queries/0_stateless/02341_analyzer_aliases_basics.reference\n@@ -17,3 +17,4 @@ Alias conflict with identifier inside expression\n Alias setting prefer_column_name_to_alias\n 0\n Value\n+/a/b/c\ndiff --git a/tests/queries/0_stateless/02341_analyzer_aliases_basics.sql b/tests/queries/0_stateless/02341_analyzer_aliases_basics.sql\nindex 52a1cd1dae83..467073fc4e89 100644\n--- a/tests/queries/0_stateless/02341_analyzer_aliases_basics.sql\n+++ b/tests/queries/0_stateless/02341_analyzer_aliases_basics.sql\n@@ -48,3 +48,5 @@ WITH id AS value SELECT value FROM test_table;\n SET prefer_column_name_to_alias = 0;\n \n DROP TABLE test_table;\n+\n+WITH path('clickhouse.com/a/b/c') AS x SELECT x AS path;\ndiff --git a/tests/queries/0_stateless/02343_analyzer_lambdas.sql b/tests/queries/0_stateless/02343_analyzer_lambdas.sql\nindex 0c257cf6f18b..25928acb2c3b 100644\n--- a/tests/queries/0_stateless/02343_analyzer_lambdas.sql\n+++ b/tests/queries/0_stateless/02343_analyzer_lambdas.sql\n@@ -93,3 +93,11 @@ SELECT arrayMap(lambda(tuple(x), x + 1), [1, 2, 3]), lambda2(tuple(x), x + 1), 1\n \n DROP TABLE test_table_tuple;\n DROP TABLE test_table;\n+\n+WITH x -> (lambda(x) + 1) AS lambda\n+SELECT lambda(1); -- {serverError UNSUPPORTED_METHOD }\n+\n+WITH\n+    x -> (lambda1(x) + 1) AS lambda,\n+    lambda AS lambda1\n+SELECT lambda(1); -- {serverError UNSUPPORTED_METHOD }\n",
  "problem_statement": "Cyclic aliases for identifier in valid query\nThis query works:\r\n```\r\nWITH path('clickhouse.com/a/b/c') AS x\r\nSELECT x AS path2\r\n```\r\n\r\nBut it doesn't work if the alias is `path`:\r\n\r\n```\r\nWITH path('clickhouse.com/a/b/c') AS x\r\nSELECT x AS path\r\n\r\nQuery id: 65fef495-2e6f-4eaf-820a-252d8cfa45ad\r\n\r\n\r\nElapsed: 0.000 sec. \r\n\r\nReceived exception:\r\nCode: 174. DB::Exception: Cyclic aliases for identifier 'path'. In scope WITH path('clickhouse.com/a/b/c') AS x SELECT x AS path. (CYCLIC_ALIASES)\r\n```\r\n\r\nWorks fine with the old analyzer:\r\n```\r\nWITH path('clickhouse.com/a/b/c') AS x\r\nSELECT x AS path2\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\nQuery id: 6a1cfe5f-7e2e-4e36-92d6-12aa7ecdf9ed\r\n\r\n   \u250c\u2500path2\u2500\u2500\u2510\r\n1. \u2502 /a/b/c \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n1 row in set. Elapsed: 0.000 sec.\r\n```\n",
  "hints_text": "Identifiers used as a function name should disambiguate to a function (builtin or UDF) first, then to aliases.\r\nIf an alias is not a function, it should not be considered in the context of a function name.",
  "created_at": "2024-05-16T17:44:40Z",
  "modified_files": [
    "src/Analyzer/Passes/QueryAnalysisPass.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02341_analyzer_aliases_basics.reference",
    "tests/queries/0_stateless/02341_analyzer_aliases_basics.sql",
    "tests/queries/0_stateless/02343_analyzer_lambdas.sql"
  ]
}