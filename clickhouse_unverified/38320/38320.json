{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 38320,
  "instance_id": "ClickHouse__ClickHouse-38320",
  "issue_numbers": [
    "38305"
  ],
  "base_commit": "25100ad5e52ee7845ec54ddaed1185a9cf2d333d",
  "patch": "diff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h\nindex 77660c54d32c..6e140f4b9cf5 100644\n--- a/src/AggregateFunctions/Helpers.h\n+++ b/src/AggregateFunctions/Helpers.h\n@@ -3,34 +3,6 @@\n #include <DataTypes/IDataType.h>\n #include <AggregateFunctions/IAggregateFunction.h>\n \n-#define FOR_BASIC_NUMERIC_TYPES(M) \\\n-    M(UInt8) \\\n-    M(UInt16) \\\n-    M(UInt32) \\\n-    M(UInt64) \\\n-    M(Int8) \\\n-    M(Int16) \\\n-    M(Int32) \\\n-    M(Int64) \\\n-    M(Float32) \\\n-    M(Float64)\n-\n-#define FOR_NUMERIC_TYPES(M) \\\n-    M(UInt8) \\\n-    M(UInt16) \\\n-    M(UInt32) \\\n-    M(UInt64) \\\n-    M(UInt128) \\\n-    M(UInt256) \\\n-    M(Int8) \\\n-    M(Int16) \\\n-    M(Int32) \\\n-    M(Int64) \\\n-    M(Int128) \\\n-    M(Int256) \\\n-    M(Float32) \\\n-    M(Float64)\n-\n namespace DB\n {\n struct Settings;\ndiff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp\nindex d3e68273d03f..b52a5aab2568 100644\n--- a/src/Columns/ColumnObject.cpp\n+++ b/src/Columns/ColumnObject.cpp\n@@ -138,7 +138,7 @@ class FieldVisitorToScalarType : public StaticVisitor<>\n         type_indexes.insert(TypeToTypeIndex<NearestFieldType<T>>);\n     }\n \n-    DataTypePtr getScalarType() const { return getLeastSupertype(type_indexes, true); }\n+    DataTypePtr getScalarType() const { return getLeastSupertypeOrString(type_indexes); }\n     bool haveNulls() const { return have_nulls; }\n     bool needConvertField() const { return field_types.size() > 1; }\n \n@@ -167,6 +167,7 @@ FieldInfo getFieldInfo(const Field & field)\n ColumnObject::Subcolumn::Subcolumn(MutableColumnPtr && data_, bool is_nullable_)\n     : least_common_type(getDataTypeByColumn(*data_))\n     , is_nullable(is_nullable_)\n+    , num_rows(data_->size())\n {\n     data.push_back(std::move(data_));\n }\n@@ -176,15 +177,13 @@ ColumnObject::Subcolumn::Subcolumn(\n     : least_common_type(std::make_shared<DataTypeNothing>())\n     , is_nullable(is_nullable_)\n     , num_of_defaults_in_prefix(size_)\n+    , num_rows(size_)\n {\n }\n \n size_t ColumnObject::Subcolumn::size() const\n {\n-    size_t res = num_of_defaults_in_prefix;\n-    for (const auto & part : data)\n-        res += part->size();\n-    return res;\n+    return num_rows;\n }\n \n size_t ColumnObject::Subcolumn::byteSize() const\n@@ -321,7 +320,7 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)\n     {\n         if (isConversionRequiredBetweenIntegers(*base_type, *least_common_base_type))\n         {\n-            base_type = getLeastSupertype(DataTypes{std::move(base_type), least_common_base_type}, true);\n+            base_type = getLeastSupertypeOrString(DataTypes{std::move(base_type), least_common_base_type});\n             type_changed = true;\n             if (!least_common_base_type->equals(*base_type))\n                 addNewColumnPart(createArrayOfType(std::move(base_type), value_dim));\n@@ -332,12 +331,14 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)\n         field = convertFieldToTypeOrThrow(field, *least_common_type.get());\n \n     data.back()->insert(field);\n+    ++num_rows;\n }\n \n void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t start, size_t length)\n {\n     assert(start + length <= src.size());\n     size_t end = start + length;\n+    num_rows += length;\n \n     if (data.empty())\n     {\n@@ -345,7 +346,7 @@ void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t star\n     }\n     else if (!least_common_type.get()->equals(*src.getLeastCommonType()))\n     {\n-        auto new_least_common_type = getLeastSupertype(DataTypes{least_common_type.get(), src.getLeastCommonType()}, true);\n+        auto new_least_common_type = getLeastSupertypeOrString(DataTypes{least_common_type.get(), src.getLeastCommonType()});\n         if (!new_least_common_type->equals(*least_common_type.get()))\n             addNewColumnPart(std::move(new_least_common_type));\n     }\n@@ -487,6 +488,8 @@ void ColumnObject::Subcolumn::insertDefault()\n         ++num_of_defaults_in_prefix;\n     else\n         data.back()->insertDefault();\n+\n+    ++num_rows;\n }\n \n void ColumnObject::Subcolumn::insertManyDefaults(size_t length)\n@@ -495,12 +498,15 @@ void ColumnObject::Subcolumn::insertManyDefaults(size_t length)\n         num_of_defaults_in_prefix += length;\n     else\n         data.back()->insertManyDefaults(length);\n+\n+    num_rows += length;\n }\n \n void ColumnObject::Subcolumn::popBack(size_t n)\n {\n     assert(n <= size());\n \n+    num_rows -= n;\n     size_t num_removed = 0;\n     for (auto it = data.rbegin(); it != data.rend(); ++it)\n     {\n@@ -559,15 +565,11 @@ ColumnObject::Subcolumn ColumnObject::Subcolumn::recreateWithDefaultValues(const\n     if (is_nullable)\n         scalar_type = makeNullable(scalar_type);\n \n-    Subcolumn new_subcolumn;\n+    Subcolumn new_subcolumn(*this);\n     new_subcolumn.least_common_type = LeastCommonType{createArrayOfType(scalar_type, field_info.num_dimensions)};\n-    new_subcolumn.is_nullable = is_nullable;\n-    new_subcolumn.num_of_defaults_in_prefix = num_of_defaults_in_prefix;\n-    new_subcolumn.data.reserve(data.size());\n \n-    for (const auto & part : data)\n-        new_subcolumn.data.push_back(recreateColumnWithDefaultValues(\n-            part, scalar_type, field_info.num_dimensions));\n+    for (auto & part : new_subcolumn.data)\n+        part = recreateColumnWithDefaultValues(part, scalar_type, field_info.num_dimensions);\n \n     return new_subcolumn;\n }\ndiff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h\nindex 89e42183ea01..4dc5bb5ce249 100644\n--- a/src/Columns/ColumnObject.h\n+++ b/src/Columns/ColumnObject.h\n@@ -146,6 +146,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>\n         /// least common type and we count number of defaults in prefix,\n         /// which will be converted to the default type of final common type.\n         size_t num_of_defaults_in_prefix = 0;\n+\n+        size_t num_rows = 0;\n     };\n \n     using Subcolumns = SubcolumnsTree<Subcolumn>;\ndiff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp\nindex 283d1b1e41a6..49ece27cc1f5 100644\n--- a/src/DataTypes/FieldToDataType.cpp\n+++ b/src/DataTypes/FieldToDataType.cpp\n@@ -22,13 +22,14 @@ namespace ErrorCodes\n     extern const int EMPTY_DATA_PASSED;\n }\n \n-\n-DataTypePtr FieldToDataType::operator() (const Null &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Null &) const\n {\n     return std::make_shared<DataTypeNullable>(std::make_shared<DataTypeNothing>());\n }\n \n-DataTypePtr FieldToDataType::operator() (const UInt64 & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const UInt64 & x) const\n {\n     if (x <= std::numeric_limits<UInt8>::max()) return std::make_shared<DataTypeUInt8>();\n     if (x <= std::numeric_limits<UInt16>::max()) return std::make_shared<DataTypeUInt16>();\n@@ -36,7 +37,8 @@ DataTypePtr FieldToDataType::operator() (const UInt64 & x) const\n     return std::make_shared<DataTypeUInt64>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const Int64 & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Int64 & x) const\n {\n     if (x <= std::numeric_limits<Int8>::max() && x >= std::numeric_limits<Int8>::min()) return std::make_shared<DataTypeInt8>();\n     if (x <= std::numeric_limits<Int16>::max() && x >= std::numeric_limits<Int16>::min()) return std::make_shared<DataTypeInt16>();\n@@ -44,77 +46,90 @@ DataTypePtr FieldToDataType::operator() (const Int64 & x) const\n     return std::make_shared<DataTypeInt64>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const Float64 &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Float64 &) const\n {\n     return std::make_shared<DataTypeFloat64>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const UInt128 &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const UInt128 &) const\n {\n     return std::make_shared<DataTypeUInt128>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const Int128 &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Int128 &) const\n {\n     return std::make_shared<DataTypeInt128>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const UInt256 &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const UInt256 &) const\n {\n     return std::make_shared<DataTypeUInt256>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const Int256 &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Int256 &) const\n {\n     return std::make_shared<DataTypeInt256>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const UUID &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const UUID &) const\n {\n     return std::make_shared<DataTypeUUID>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const String &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const String &) const\n {\n     return std::make_shared<DataTypeString>();\n }\n \n-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal32> & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal32> & x) const\n {\n     using Type = DataTypeDecimal<Decimal32>;\n     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());\n }\n \n-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal64> & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal64> & x) const\n {\n     using Type = DataTypeDecimal<Decimal64>;\n     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());\n }\n \n-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal128> & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal128> & x) const\n {\n     using Type = DataTypeDecimal<Decimal128>;\n     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());\n }\n \n-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal256> & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal256> & x) const\n {\n     using Type = DataTypeDecimal<Decimal256>;\n     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());\n }\n \n-DataTypePtr FieldToDataType::operator() (const Array & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Array & x) const\n {\n     DataTypes element_types;\n     element_types.reserve(x.size());\n \n     for (const Field & elem : x)\n-        element_types.emplace_back(applyVisitor(FieldToDataType(allow_convertion_to_string), elem));\n+        element_types.emplace_back(applyVisitor(*this, elem));\n \n-    return std::make_shared<DataTypeArray>(getLeastSupertype(element_types, allow_convertion_to_string));\n+    return std::make_shared<DataTypeArray>(getLeastSupertype<on_error>(element_types));\n }\n \n-DataTypePtr FieldToDataType::operator() (const Tuple & tuple) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Tuple & tuple) const\n {\n     if (tuple.empty())\n         throw Exception(\"Cannot infer type of an empty tuple\", ErrorCodes::EMPTY_DATA_PASSED);\n@@ -123,12 +138,13 @@ DataTypePtr FieldToDataType::operator() (const Tuple & tuple) const\n     element_types.reserve(tuple.size());\n \n     for (const auto & element : tuple)\n-        element_types.push_back(applyVisitor(FieldToDataType(allow_convertion_to_string), element));\n+        element_types.push_back(applyVisitor(*this, element));\n \n     return std::make_shared<DataTypeTuple>(element_types);\n }\n \n-DataTypePtr FieldToDataType::operator() (const Map & map) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Map & map) const\n {\n     DataTypes key_types;\n     DataTypes value_types;\n@@ -139,30 +155,37 @@ DataTypePtr FieldToDataType::operator() (const Map & map) const\n     {\n         const auto & tuple = elem.safeGet<const Tuple &>();\n         assert(tuple.size() == 2);\n-        key_types.push_back(applyVisitor(FieldToDataType(allow_convertion_to_string), tuple[0]));\n-        value_types.push_back(applyVisitor(FieldToDataType(allow_convertion_to_string), tuple[1]));\n+        key_types.push_back(applyVisitor(*this, tuple[0]));\n+        value_types.push_back(applyVisitor(*this, tuple[1]));\n     }\n \n     return std::make_shared<DataTypeMap>(\n-        getLeastSupertype(key_types, allow_convertion_to_string),\n-        getLeastSupertype(value_types, allow_convertion_to_string));\n+        getLeastSupertype<on_error>(key_types),\n+        getLeastSupertype<on_error>(value_types));\n }\n \n-DataTypePtr FieldToDataType::operator() (const Object &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const Object &) const\n {\n     /// TODO: Do we need different parameters for type Object?\n     return std::make_shared<DataTypeObject>(\"json\", false);\n }\n \n-DataTypePtr FieldToDataType::operator() (const AggregateFunctionStateData & x) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator() (const AggregateFunctionStateData & x) const\n {\n     const auto & name = static_cast<const AggregateFunctionStateData &>(x).name;\n     return DataTypeFactory::instance().get(name);\n }\n \n-DataTypePtr FieldToDataType::operator()(const bool &) const\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr FieldToDataType<on_error>::operator()(const bool &) const\n {\n     return DataTypeFactory::instance().get(\"Bool\");\n }\n \n+template class FieldToDataType<LeastSupertypeOnError::Throw>;\n+template class FieldToDataType<LeastSupertypeOnError::String>;\n+template class FieldToDataType<LeastSupertypeOnError::Null>;\n+\n }\ndiff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h\nindex 1922ac8b7467..5e66fe420ad4 100644\n--- a/src/DataTypes/FieldToDataType.h\n+++ b/src/DataTypes/FieldToDataType.h\n@@ -4,6 +4,7 @@\n #include <Core/Types.h>\n #include <Core/Field.h>\n #include <Common/FieldVisitors.h>\n+#include <DataTypes/getLeastSupertype.h>\n \n \n namespace DB\n@@ -17,14 +18,10 @@ using DataTypePtr = std::shared_ptr<const IDataType>;\n   * Note that you still have to convert Field to corresponding data type before inserting to columns\n   *  (for example, this is necessary to convert elements of Array to common type).\n   */\n+template <LeastSupertypeOnError on_error = LeastSupertypeOnError::Throw>\n class FieldToDataType : public StaticVisitor<DataTypePtr>\n {\n public:\n-    FieldToDataType(bool allow_convertion_to_string_ = false)\n-      : allow_convertion_to_string(allow_convertion_to_string_)\n-    {\n-    }\n-\n     DataTypePtr operator() (const Null & x) const;\n     DataTypePtr operator() (const UInt64 & x) const;\n     DataTypePtr operator() (const UInt128 & x) const;\n@@ -45,9 +42,6 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>\n     DataTypePtr operator() (const UInt256 & x) const;\n     DataTypePtr operator() (const Int256 & x) const;\n     DataTypePtr operator() (const bool & x) const;\n-\n-private:\n-    bool allow_convertion_to_string;\n };\n \n }\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 420ef61a13fe..fce8906abe5f 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -565,4 +565,31 @@ class DataTypeEnum;\n \n template <typename T> inline constexpr bool IsDataTypeEnum<DataTypeEnum<T>> = true;\n \n+#define FOR_BASIC_NUMERIC_TYPES(M) \\\n+    M(UInt8) \\\n+    M(UInt16) \\\n+    M(UInt32) \\\n+    M(UInt64) \\\n+    M(Int8) \\\n+    M(Int16) \\\n+    M(Int32) \\\n+    M(Int64) \\\n+    M(Float32) \\\n+    M(Float64)\n+\n+#define FOR_NUMERIC_TYPES(M) \\\n+    M(UInt8) \\\n+    M(UInt16) \\\n+    M(UInt32) \\\n+    M(UInt64) \\\n+    M(UInt128) \\\n+    M(UInt256) \\\n+    M(Int8) \\\n+    M(Int16) \\\n+    M(Int32) \\\n+    M(Int64) \\\n+    M(Int128) \\\n+    M(Int256) \\\n+    M(Float32) \\\n+    M(Float64)\n }\ndiff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp\nindex df639ae7aabb..b81c8c7a033e 100644\n--- a/src/DataTypes/ObjectUtils.cpp\n+++ b/src/DataTypes/ObjectUtils.cpp\n@@ -261,7 +261,7 @@ DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambi\n                     key.getPath(), subtypes[0]->getName(), subtypes[i]->getName());\n \n         tuple_paths.emplace_back(key);\n-        tuple_types.emplace_back(getLeastSupertype(subtypes, /*allow_conversion_to_string=*/ true));\n+        tuple_types.emplace_back(getLeastSupertypeOrString(subtypes));\n     }\n \n     if (tuple_paths.empty())\ndiff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp\nindex 85831df271a3..cf49fa8798d8 100644\n--- a/src/DataTypes/Serializations/SerializationObject.cpp\n+++ b/src/DataTypes/Serializations/SerializationObject.cpp\n@@ -61,29 +61,23 @@ void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader &\n     auto & [paths, values] = *result;\n     assert(paths.size() == values.size());\n \n-    HashSet<StringRef, StringRefHash> paths_set;\n-    size_t column_size = column_object.size();\n-\n+    size_t old_column_size = column_object.size();\n     for (size_t i = 0; i < paths.size(); ++i)\n     {\n         auto field_info = getFieldInfo(values[i]);\n         if (isNothing(field_info.scalar_type))\n             continue;\n \n-        if (!paths_set.insert(paths[i].getPath()).second)\n-            throw Exception(ErrorCodes::INCORRECT_DATA,\n-                \"Object has ambiguous path: {}\", paths[i].getPath());\n-\n         if (!column_object.hasSubcolumn(paths[i]))\n         {\n             if (paths[i].hasNested())\n-                column_object.addNestedSubcolumn(paths[i], field_info, column_size);\n+                column_object.addNestedSubcolumn(paths[i], field_info, old_column_size);\n             else\n-                column_object.addSubcolumn(paths[i], column_size);\n+                column_object.addSubcolumn(paths[i], old_column_size);\n         }\n \n         auto & subcolumn = column_object.getSubcolumn(paths[i]);\n-        assert(subcolumn.size() == column_size);\n+        assert(subcolumn.size() == old_column_size);\n \n         subcolumn.insert(std::move(values[i]), std::move(field_info));\n     }\n@@ -92,7 +86,7 @@ void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader &\n     const auto & subcolumns = column_object.getSubcolumns();\n     for (const auto & entry : subcolumns)\n     {\n-        if (!paths_set.has(entry->path.getPath()))\n+        if (entry->data.size() == old_column_size)\n         {\n             bool inserted = column_object.tryInsertDefaultFromNested(entry);\n             if (!inserted)\ndiff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp\nindex 14cfafb1ef3c..ac240c4afceb 100644\n--- a/src/DataTypes/getLeastSupertype.cpp\n+++ b/src/DataTypes/getLeastSupertype.cpp\n@@ -55,16 +55,24 @@ String getExceptionMessagePrefix(const DataTypes & types)\n     return res.str();\n }\n \n-DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_string)\n+template <LeastSupertypeOnError on_error, typename DataTypes>\n+DataTypePtr throwOrReturn(const DataTypes & types, std::string_view message_suffix, int error_code)\n {\n-    auto throw_or_return = [&](std::string_view message, int error_code)\n-    {\n-        if (allow_conversion_to_string)\n-            return std::make_shared<DataTypeString>();\n+    if constexpr (on_error == LeastSupertypeOnError::String)\n+        return std::make_shared<DataTypeString>();\n \n-        throw Exception(String(message), error_code);\n-    };\n+    if constexpr (on_error == LeastSupertypeOnError::Null)\n+        return nullptr;\n+\n+    if (message_suffix.empty())\n+        throw Exception(error_code, getExceptionMessagePrefix(types));\n \n+    throw Exception(error_code, \"{} {}\", getExceptionMessagePrefix(types), message_suffix);\n+}\n+\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr getNumericType(const TypeIndexSet & types)\n+{\n     bool all_numbers = true;\n \n     size_t max_bits_of_signed_integer = 0;\n@@ -107,14 +115,14 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_\n             maximize(max_mantissa_bits_of_floating, 24);\n         else if (type == TypeIndex::Float64)\n             maximize(max_mantissa_bits_of_floating, 53);\n-        else\n+        else if (type != TypeIndex::Nothing)\n             all_numbers = false;\n     }\n \n     if (max_bits_of_signed_integer || max_bits_of_unsigned_integer || max_mantissa_bits_of_floating)\n     {\n         if (!all_numbers)\n-            return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them are numbers and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+            return throwOrReturn<on_error>(types, \"because some of them are numbers and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n \n         /// If there are signed and unsigned types of same bit-width, the result must be signed number with at least one more bit.\n         /// Example, common of Int32, UInt32 = Int64.\n@@ -129,10 +137,9 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_\n             if (min_bit_width_of_integer != 64)\n                 ++min_bit_width_of_integer;\n             else\n-                return throw_or_return(\n-                    getExceptionMessagePrefix(types)\n-                        + \" because some of them are signed integers and some are unsigned integers,\"\n-                            \" but there is no signed integer type, that can exactly represent all required unsigned integer values\",\n+                return throwOrReturn<on_error>(types,\n+                    \"because some of them are signed integers and some are unsigned integers,\"\n+                    \" but there is no signed integer type, that can exactly represent all required unsigned integer values\",\n                     ErrorCodes::NO_COMMON_TYPE);\n         }\n \n@@ -145,8 +152,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_\n             else if (min_mantissa_bits <= 53)\n                 return std::make_shared<DataTypeFloat64>();\n             else\n-                return throw_or_return(getExceptionMessagePrefix(types)\n-                    + \" because some of them are integers and some are floating point,\"\n+                return throwOrReturn<on_error>(types,\n+                    \" because some of them are integers and some are floating point,\"\n                     \" but there is no floating point type, that can exactly represent all required integers\", ErrorCodes::NO_COMMON_TYPE);\n         }\n \n@@ -166,8 +173,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_\n             else if (min_bit_width_of_integer <= 256)\n                 return std::make_shared<DataTypeInt256>();\n             else\n-                return throw_or_return(getExceptionMessagePrefix(types)\n-                    + \" because some of them are signed integers and some are unsigned integers,\"\n+                return throwOrReturn<on_error>(types,\n+                    \" because some of them are signed integers and some are unsigned integers,\"\n                     \" but there is no signed integer type, that can exactly represent all required unsigned integer values\", ErrorCodes::NO_COMMON_TYPE);\n         }\n \n@@ -186,9 +193,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_\n             else if (min_bit_width_of_integer <= 256)\n                 return std::make_shared<DataTypeUInt256>();\n             else\n-                return throw_or_return(\"Logical error: \" + getExceptionMessagePrefix(types)\n-                    + \" but as all data types are unsigned integers, we must have found maximum unsigned integer type\", ErrorCodes::NO_COMMON_TYPE);\n-\n+                return throwOrReturn<on_error>(types,\n+                    \" but as all data types are unsigned integers, we must have found maximum unsigned integer type\", ErrorCodes::NO_COMMON_TYPE);\n         }\n     }\n \n@@ -197,16 +203,9 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_\n \n }\n \n-DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_string)\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr getLeastSupertype(const DataTypes & types)\n {\n-    auto throw_or_return = [&](std::string_view message, int error_code)\n-    {\n-        if (allow_conversion_to_string)\n-            return std::make_shared<DataTypeString>();\n-\n-        throw Exception(String(message), error_code);\n-    };\n-\n     /// Trivial cases\n \n     if (types.empty())\n@@ -243,7 +242,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n                 non_nothing_types.emplace_back(type);\n \n         if (non_nothing_types.size() < types.size())\n-            return getLeastSupertype(non_nothing_types, allow_conversion_to_string);\n+            return getLeastSupertype<on_error>(non_nothing_types);\n     }\n \n     /// For Arrays\n@@ -268,9 +267,9 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n         if (have_array)\n         {\n             if (!all_arrays)\n-                return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them are Array and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+                return throwOrReturn<on_error>(types, \"because some of them are Array and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n \n-            return std::make_shared<DataTypeArray>(getLeastSupertype(nested_types, allow_conversion_to_string));\n+            return std::make_shared<DataTypeArray>(getLeastSupertype<on_error>(nested_types));\n         }\n     }\n \n@@ -294,7 +293,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n                         nested_types[elem_idx].reserve(types.size());\n                 }\n                 else if (tuple_size != type_tuple->getElements().size())\n-                    return throw_or_return(getExceptionMessagePrefix(types) + \" because Tuples have different sizes\", ErrorCodes::NO_COMMON_TYPE);\n+                    return throwOrReturn<on_error>(types, \"because Tuples have different sizes\", ErrorCodes::NO_COMMON_TYPE);\n \n                 have_tuple = true;\n \n@@ -308,11 +307,11 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n         if (have_tuple)\n         {\n             if (!all_tuples)\n-                return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them are Tuple and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+                return throwOrReturn<on_error>(types, \"because some of them are Tuple and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n \n             DataTypes common_tuple_types(tuple_size);\n             for (size_t elem_idx = 0; elem_idx < tuple_size; ++elem_idx)\n-                common_tuple_types[elem_idx] = getLeastSupertype(nested_types[elem_idx], allow_conversion_to_string);\n+                common_tuple_types[elem_idx] = getLeastSupertype<on_error>(nested_types[elem_idx]);\n \n             return std::make_shared<DataTypeTuple>(common_tuple_types);\n         }\n@@ -342,11 +341,11 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n         if (have_maps)\n         {\n             if (!all_maps)\n-                return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them are Maps and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+                return throwOrReturn<on_error>(types, \"because some of them are Maps and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n \n             return std::make_shared<DataTypeMap>(\n-                getLeastSupertype(key_types, allow_conversion_to_string),\n-                getLeastSupertype(value_types, allow_conversion_to_string));\n+                getLeastSupertype<on_error>(key_types),\n+                getLeastSupertype<on_error>(value_types));\n         }\n     }\n \n@@ -377,9 +376,9 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n         if (have_low_cardinality)\n         {\n             if (have_not_low_cardinality)\n-                return getLeastSupertype(nested_types, allow_conversion_to_string);\n+                return getLeastSupertype<on_error>(nested_types);\n             else\n-                return std::make_shared<DataTypeLowCardinality>(getLeastSupertype(nested_types, allow_conversion_to_string));\n+                return std::make_shared<DataTypeLowCardinality>(getLeastSupertype<on_error>(nested_types));\n         }\n     }\n \n@@ -405,7 +404,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n \n         if (have_nullable)\n         {\n-            return std::make_shared<DataTypeNullable>(getLeastSupertype(nested_types, allow_conversion_to_string));\n+            return std::make_shared<DataTypeNullable>(getLeastSupertype<on_error>(nested_types));\n         }\n     }\n \n@@ -425,7 +424,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n         {\n             bool all_strings = type_ids.size() == (have_string + have_fixed_string);\n             if (!all_strings)\n-                return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them are String/FixedString and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+                return throwOrReturn<on_error>(types, \"because some of them are String/FixedString and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n \n             return std::make_shared<DataTypeString>();\n         }\n@@ -442,8 +441,8 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n         {\n             bool all_date_or_datetime = type_ids.size() == (have_date + have_date32 + have_datetime + have_datetime64);\n             if (!all_date_or_datetime)\n-                return throw_or_return(getExceptionMessagePrefix(types)\n-                    + \" because some of them are Date/Date32/DateTime/DateTime64 and some of them are not\",\n+                return throwOrReturn<on_error>(types,\n+                    \"because some of them are Date/Date32/DateTime/DateTime64 and some of them are not\",\n                     ErrorCodes::NO_COMMON_TYPE);\n \n             if (have_datetime64 == 0 && have_date32 == 0)\n@@ -520,8 +519,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n             }\n \n             if (num_supported != type_ids.size())\n-                return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them have no lossless conversion to Decimal\",\n-                                ErrorCodes::NO_COMMON_TYPE);\n+                return throwOrReturn<on_error>(types, \"because some of them have no lossless conversion to Decimal\", ErrorCodes::NO_COMMON_TYPE);\n \n             UInt32 max_scale = 0;\n             for (const auto & type : types)\n@@ -543,7 +541,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n             }\n \n             if (min_precision > DataTypeDecimal<Decimal128>::maxPrecision())\n-                return throw_or_return(getExceptionMessagePrefix(types) + \" because the least supertype is Decimal(\"\n+                return throwOrReturn<on_error>(types, \"because the least supertype is Decimal(\"\n                                 + toString(min_precision) + ',' + toString(max_scale) + ')',\n                                 ErrorCodes::NO_COMMON_TYPE);\n \n@@ -557,68 +555,77 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_\n \n     /// For numeric types, the most complicated part.\n     {\n-        auto numeric_type = getNumericType(type_ids, allow_conversion_to_string);\n+        auto numeric_type = getNumericType<on_error>(type_ids);\n         if (numeric_type)\n             return numeric_type;\n     }\n \n     /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).\n-    return throw_or_return(getExceptionMessagePrefix(types), ErrorCodes::NO_COMMON_TYPE);\n+    return throwOrReturn<on_error>(types, \"\", ErrorCodes::NO_COMMON_TYPE);\n }\n \n-DataTypePtr getLeastSupertype(const TypeIndexSet & types, bool allow_conversion_to_string)\n+DataTypePtr getLeastSupertypeOrString(const DataTypes & types)\n {\n-    auto throw_or_return = [&](std::string_view message, int error_code)\n-    {\n-        if (allow_conversion_to_string)\n-            return std::make_shared<DataTypeString>();\n+    return getLeastSupertype<LeastSupertypeOnError::String>(types);\n+}\n \n-        throw Exception(String(message), error_code);\n-    };\n+DataTypePtr tryGetLeastSupertype(const DataTypes & types)\n+{\n+    return getLeastSupertype<LeastSupertypeOnError::Null>(types);\n+}\n \n-    TypeIndexSet types_set;\n-    for (const auto & type : types)\n+template <LeastSupertypeOnError on_error>\n+DataTypePtr getLeastSupertype(const TypeIndexSet & types)\n+{\n+    if (types.empty())\n+        return std::make_shared<DataTypeNothing>();\n+\n+    if (types.size() == 1)\n     {\n-        if (WhichDataType(type).isNothing())\n-            continue;\n+        WhichDataType which(*types.begin());\n+        if (which.isNothing())\n+            return std::make_shared<DataTypeNothing>();\n \n-        if (!WhichDataType(type).isSimple())\n-            throw Exception(ErrorCodes::NO_COMMON_TYPE,\n-                \"Cannot get common type by type ids with parametric type {}\", typeToString(type));\n+    #define DISPATCH(TYPE) \\\n+        if (which.idx == TypeIndex::TYPE) \\\n+            return std::make_shared<DataTypeNumber<TYPE>>(); /// NOLINT\n \n-        types_set.insert(type);\n-    }\n+        FOR_NUMERIC_TYPES(DISPATCH)\n+    #undef DISPATCH\n \n-    if (types_set.empty())\n-        return std::make_shared<DataTypeNothing>();\n+        if (which.isString())\n+            return std::make_shared<DataTypeString>();\n+\n+        return throwOrReturn<on_error>(types, \"because cannot get common type by type indexes with non-simple types\", ErrorCodes::NO_COMMON_TYPE);\n+    }\n \n     if (types.contains(TypeIndex::String))\n     {\n-        if (types.size() != 1)\n-            return throw_or_return(getExceptionMessagePrefix(types) + \" because some of them are String and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n+        bool only_string = types.size() == 2 && types.contains(TypeIndex::Nothing);\n+        if (!only_string)\n+            return throwOrReturn<on_error>(types, \"because some of them are String and some of them are not\", ErrorCodes::NO_COMMON_TYPE);\n \n         return std::make_shared<DataTypeString>();\n     }\n \n-    /// For numeric types, the most complicated part.\n-    auto numeric_type = getNumericType(types, allow_conversion_to_string);\n+    auto numeric_type = getNumericType<on_error>(types);\n     if (numeric_type)\n         return numeric_type;\n \n-    /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).\n-    return throw_or_return(getExceptionMessagePrefix(types), ErrorCodes::NO_COMMON_TYPE);\n+    return throwOrReturn<on_error>(types, \"\", ErrorCodes::NO_COMMON_TYPE);\n }\n \n-DataTypePtr tryGetLeastSupertype(const DataTypes & types)\n+DataTypePtr getLeastSupertypeOrString(const TypeIndexSet & types)\n {\n-    try\n-    {\n-        return getLeastSupertype(types);\n-    }\n-    catch (...)\n-    {\n-        return nullptr;\n-    }\n+    return getLeastSupertype<LeastSupertypeOnError::String>(types);\n }\n \n+DataTypePtr tryGetLeastSupertype(const TypeIndexSet & types)\n+{\n+    return getLeastSupertype<LeastSupertypeOnError::Null>(types);\n+}\n+\n+template DataTypePtr getLeastSupertype<LeastSupertypeOnError::Throw>(const DataTypes & types);\n+template DataTypePtr getLeastSupertype<LeastSupertypeOnError::Throw>(const TypeIndexSet & types);\n+\n }\ndiff --git a/src/DataTypes/getLeastSupertype.h b/src/DataTypes/getLeastSupertype.h\nindex 5444bb34d063..2ef4a0e6850d 100644\n--- a/src/DataTypes/getLeastSupertype.h\n+++ b/src/DataTypes/getLeastSupertype.h\n@@ -1,24 +1,39 @@\n #pragma once\n-\n #include <DataTypes/IDataType.h>\n \n-\n namespace DB\n {\n \n+enum class LeastSupertypeOnError\n+{\n+    Throw,\n+    String,\n+    Null,\n+};\n+\n /** Get data type that covers all possible values of passed data types.\n-  * If there is no such data type, throws an exception\n-  * or if 'allow_conversion_to_string' is true returns String as common type.\n+  * If there is no such data type, throws an exception.\n   *\n   * Examples: least common supertype for UInt8, Int8 - Int16.\n   * Examples: there is no least common supertype for Array(UInt8), Int8.\n   */\n-DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_string = false);\n+template <LeastSupertypeOnError on_error = LeastSupertypeOnError::Throw>\n+DataTypePtr getLeastSupertype(const DataTypes & types);\n \n-using TypeIndexSet = std::unordered_set<TypeIndex>;\n-DataTypePtr getLeastSupertype(const TypeIndexSet & types, bool allow_conversion_to_string = false);\n+/// Same as above but return String type instead of throwing exception.\n+/// All types can be casted to String, because they can be serialized to String.\n+DataTypePtr getLeastSupertypeOrString(const DataTypes & types);\n \n /// Same as above but return nullptr instead of throwing exception.\n DataTypePtr tryGetLeastSupertype(const DataTypes & types);\n \n+using TypeIndexSet = std::unordered_set<TypeIndex>;\n+\n+template <LeastSupertypeOnError on_error = LeastSupertypeOnError::Throw>\n+DataTypePtr getLeastSupertype(const TypeIndexSet & types);\n+\n+DataTypePtr getLeastSupertypeOrString(const TypeIndexSet & types);\n+\n+DataTypePtr tryGetLeastSupertype(const TypeIndexSet & types);\n+\n }\ndiff --git a/src/Interpreters/RowRefs.cpp b/src/Interpreters/RowRefs.cpp\nindex 97feed54c08e..2a18c2c700a7 100644\n--- a/src/Interpreters/RowRefs.cpp\n+++ b/src/Interpreters/RowRefs.cpp\n@@ -1,7 +1,6 @@\n #include <Interpreters/RowRefs.h>\n \n #include <Common/RadixSort.h>\n-#include <AggregateFunctions/Helpers.h>\n #include <Columns/IColumn.h>\n #include <DataTypes/IDataType.h>\n #include <base/types.h>\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex f6baae723c9f..40f23fe52947 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -1300,7 +1300,7 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, ContextPtr context,\n                 }\n                 else\n                 {\n-                    DataTypePtr common_type = tryGetLeastSupertype({key_expr_type_not_null, const_type});\n+                    DataTypePtr common_type = tryGetLeastSupertype(DataTypes{key_expr_type_not_null, const_type});\n                     if (!common_type)\n                         return false;\n \n",
  "test_patch": "diff --git a/src/Columns/tests/gtest_column_object.cpp b/src/Columns/tests/gtest_column_object.cpp\nindex d5e58e5fce24..e1ad949f6a80 100644\n--- a/src/Columns/tests/gtest_column_object.cpp\n+++ b/src/Columns/tests/gtest_column_object.cpp\n@@ -89,7 +89,7 @@ TEST(ColumnObject, InsertRangeFrom)\n \n         const auto & type_dst = subcolumn_dst.getLeastCommonType();\n         const auto & type_src = subcolumn_src.getLeastCommonType();\n-        auto type_res = getLeastSupertype(DataTypes{type_dst, type_src}, true);\n+        auto type_res = getLeastSupertypeOrString(DataTypes{type_dst, type_src});\n \n         size_t from = rng() % subcolumn_src.size();\n         size_t to = rng() % subcolumn_src.size();\ndiff --git a/tests/performance/json_type.xml b/tests/performance/json_type.xml\nnew file mode 100644\nindex 000000000000..b6406f525793\n--- /dev/null\n+++ b/tests/performance/json_type.xml\n@@ -0,0 +1,41 @@\n+<test>\n+    <settings>\n+        <allow_experimental_object_type>1</allow_experimental_object_type>\n+    </settings>\n+\n+    <!-- Looks like the only way to use json in test's queries is to put them to substitution.\n+         Otherwise jsons are interpreted as substitutions themselves -->\n+\n+    <substitutions>\n+        <substitution>\n+            <name>json1</name>\n+            <values>\n+                <value>'{\"k1\":1, \"k2\": \"some\"}'</value>\n+            </values>\n+        </substitution>\n+        <substitution>\n+            <name>json2</name>\n+            <values>\n+                <value>'{\"col' || toString(number % 100) || '\":' || toString(number) || '}'</value>\n+            </values>\n+        </substitution>\n+        <substitution>\n+            <name>json3</name>\n+            <values>\n+                <value>'{\"k1\":[{\"k2\":\"aaa\",\"k3\":[{\"k4\":\"bbb\"},{\"k4\":\"ccc\"}]},{\"k2\":\"ddd\",\"k3\":[{\"k4\":\"eee\"},{\"k4\":\"fff\"}]}]}'</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <create_query>CREATE TABLE t_json_1(data JSON) ENGINE = MergeTree ORDER BY tuple()</create_query>\n+    <create_query>CREATE TABLE t_json_2(data JSON) ENGINE = MergeTree ORDER BY tuple()</create_query>\n+    <create_query>CREATE TABLE t_json_3(data JSON) ENGINE = MergeTree ORDER BY tuple()</create_query>\n+\n+    <query>INSERT INTO t_json_1 SELECT materialize({json1}) FROM numbers(200000)</query>\n+    <query>INSERT INTO t_json_2 SELECT {json2} FROM numbers(100000)</query>\n+    <query>INSERT INTO t_json_3 SELECT materialize({json3}) FROM numbers_mt(100000)</query>\n+\n+    <drop_query>DROP TABLE IF EXISTS t_json_1</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS t_json_2</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS t_json_3</drop_query>\n+</test>\ndiff --git a/tests/queries/0_stateless/01825_type_json_parallel_insert.reference b/tests/queries/0_stateless/01825_type_json_parallel_insert.reference\nindex ac512064a436..158d61d46f7b 100644\n--- a/tests/queries/0_stateless/01825_type_json_parallel_insert.reference\n+++ b/tests/queries/0_stateless/01825_type_json_parallel_insert.reference\n@@ -1,1 +1,1 @@\n-Tuple(k1 Int8, k2 String)\t3000000\n+Tuple(k1 Int8, k2 String)\t500000\ndiff --git a/tests/queries/0_stateless/01825_type_json_parallel_insert.sql b/tests/queries/0_stateless/01825_type_json_parallel_insert.sql\nindex 93d1eecfbd76..e443c9455d58 100644\n--- a/tests/queries/0_stateless/01825_type_json_parallel_insert.sql\n+++ b/tests/queries/0_stateless/01825_type_json_parallel_insert.sql\n@@ -1,10 +1,10 @@\n -- Tags: long, no-backward-compatibility-check:22.3.2.1\n DROP TABLE IF EXISTS t_json_parallel;\n \n-SET allow_experimental_object_type = 1, max_insert_threads = 20, max_threads = 20;\n+SET allow_experimental_object_type = 1, max_insert_threads = 20, max_threads = 20, min_insert_block_size_rows = 65536;\n CREATE TABLE t_json_parallel (data JSON) ENGINE = MergeTree ORDER BY tuple();\n \n-INSERT INTO t_json_parallel SELECT materialize('{\"k1\":1, \"k2\": \"some\"}') FROM numbers_mt(3000000);\n+INSERT INTO t_json_parallel SELECT materialize('{\"k1\":1, \"k2\": \"some\"}') FROM numbers_mt(500000);\n SELECT any(toTypeName(data)), count() FROM t_json_parallel;\n \n DROP TABLE t_json_parallel;\n",
  "problem_statement": "Hung check: slow JSON deserialization\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/0b8fc627d80013c0288ddf5a7d91546a7d9d6264/stress_test__debug__actions_.html\r\n\r\nSeems like `SerializationObject<DB::JSONDataParser<DB::SimdJSONParser> >::deserializeWholeText` may be too slow, so it triggers Hung Check in Stress Tests sometimes. Probably it's because of `getLeastSupertype`.\r\n\r\nQuery: https://pastila.nl/?030770f4/763c48c7ea794cfd4cb77f01c736978d\r\nStacktrace: https://pastila.nl/?0062e195/229dc868bd7bed9a75396eaf61cb3346\r\n\r\nI would ignore it if it was the only failure, but there's another one with similar stacktrace:\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/0d80874d400e3591ba7aff05eaac970ca6e7ac49/stress_test__debug__actions_.html\r\n\r\nQuery: https://pastila.nl/?027b3a99/63002ee740e15dcedcd2412289337976\r\nStacktraces: https://pastila.nl/?0062e195/f08dd310bd9a5d608e8e55eda4fa6c39\r\n\n",
  "hints_text": "We can disable this test with debug build. With release build its execution takes 1.5 seconds.",
  "created_at": "2022-06-22T16:27:31Z"
}