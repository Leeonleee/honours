diff --git a/src/AggregateFunctions/Helpers.h b/src/AggregateFunctions/Helpers.h
index 77660c54d32c..6e140f4b9cf5 100644
--- a/src/AggregateFunctions/Helpers.h
+++ b/src/AggregateFunctions/Helpers.h
@@ -3,34 +3,6 @@
 #include <DataTypes/IDataType.h>
 #include <AggregateFunctions/IAggregateFunction.h>
 
-#define FOR_BASIC_NUMERIC_TYPES(M) \
-    M(UInt8) \
-    M(UInt16) \
-    M(UInt32) \
-    M(UInt64) \
-    M(Int8) \
-    M(Int16) \
-    M(Int32) \
-    M(Int64) \
-    M(Float32) \
-    M(Float64)
-
-#define FOR_NUMERIC_TYPES(M) \
-    M(UInt8) \
-    M(UInt16) \
-    M(UInt32) \
-    M(UInt64) \
-    M(UInt128) \
-    M(UInt256) \
-    M(Int8) \
-    M(Int16) \
-    M(Int32) \
-    M(Int64) \
-    M(Int128) \
-    M(Int256) \
-    M(Float32) \
-    M(Float64)
-
 namespace DB
 {
 struct Settings;
diff --git a/src/Columns/ColumnObject.cpp b/src/Columns/ColumnObject.cpp
index d3e68273d03f..b52a5aab2568 100644
--- a/src/Columns/ColumnObject.cpp
+++ b/src/Columns/ColumnObject.cpp
@@ -138,7 +138,7 @@ class FieldVisitorToScalarType : public StaticVisitor<>
         type_indexes.insert(TypeToTypeIndex<NearestFieldType<T>>);
     }
 
-    DataTypePtr getScalarType() const { return getLeastSupertype(type_indexes, true); }
+    DataTypePtr getScalarType() const { return getLeastSupertypeOrString(type_indexes); }
     bool haveNulls() const { return have_nulls; }
     bool needConvertField() const { return field_types.size() > 1; }
 
@@ -167,6 +167,7 @@ FieldInfo getFieldInfo(const Field & field)
 ColumnObject::Subcolumn::Subcolumn(MutableColumnPtr && data_, bool is_nullable_)
     : least_common_type(getDataTypeByColumn(*data_))
     , is_nullable(is_nullable_)
+    , num_rows(data_->size())
 {
     data.push_back(std::move(data_));
 }
@@ -176,15 +177,13 @@ ColumnObject::Subcolumn::Subcolumn(
     : least_common_type(std::make_shared<DataTypeNothing>())
     , is_nullable(is_nullable_)
     , num_of_defaults_in_prefix(size_)
+    , num_rows(size_)
 {
 }
 
 size_t ColumnObject::Subcolumn::size() const
 {
-    size_t res = num_of_defaults_in_prefix;
-    for (const auto & part : data)
-        res += part->size();
-    return res;
+    return num_rows;
 }
 
 size_t ColumnObject::Subcolumn::byteSize() const
@@ -321,7 +320,7 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
     {
         if (isConversionRequiredBetweenIntegers(*base_type, *least_common_base_type))
         {
-            base_type = getLeastSupertype(DataTypes{std::move(base_type), least_common_base_type}, true);
+            base_type = getLeastSupertypeOrString(DataTypes{std::move(base_type), least_common_base_type});
             type_changed = true;
             if (!least_common_base_type->equals(*base_type))
                 addNewColumnPart(createArrayOfType(std::move(base_type), value_dim));
@@ -332,12 +331,14 @@ void ColumnObject::Subcolumn::insert(Field field, FieldInfo info)
         field = convertFieldToTypeOrThrow(field, *least_common_type.get());
 
     data.back()->insert(field);
+    ++num_rows;
 }
 
 void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t start, size_t length)
 {
     assert(start + length <= src.size());
     size_t end = start + length;
+    num_rows += length;
 
     if (data.empty())
     {
@@ -345,7 +346,7 @@ void ColumnObject::Subcolumn::insertRangeFrom(const Subcolumn & src, size_t star
     }
     else if (!least_common_type.get()->equals(*src.getLeastCommonType()))
     {
-        auto new_least_common_type = getLeastSupertype(DataTypes{least_common_type.get(), src.getLeastCommonType()}, true);
+        auto new_least_common_type = getLeastSupertypeOrString(DataTypes{least_common_type.get(), src.getLeastCommonType()});
         if (!new_least_common_type->equals(*least_common_type.get()))
             addNewColumnPart(std::move(new_least_common_type));
     }
@@ -487,6 +488,8 @@ void ColumnObject::Subcolumn::insertDefault()
         ++num_of_defaults_in_prefix;
     else
         data.back()->insertDefault();
+
+    ++num_rows;
 }
 
 void ColumnObject::Subcolumn::insertManyDefaults(size_t length)
@@ -495,12 +498,15 @@ void ColumnObject::Subcolumn::insertManyDefaults(size_t length)
         num_of_defaults_in_prefix += length;
     else
         data.back()->insertManyDefaults(length);
+
+    num_rows += length;
 }
 
 void ColumnObject::Subcolumn::popBack(size_t n)
 {
     assert(n <= size());
 
+    num_rows -= n;
     size_t num_removed = 0;
     for (auto it = data.rbegin(); it != data.rend(); ++it)
     {
@@ -559,15 +565,11 @@ ColumnObject::Subcolumn ColumnObject::Subcolumn::recreateWithDefaultValues(const
     if (is_nullable)
         scalar_type = makeNullable(scalar_type);
 
-    Subcolumn new_subcolumn;
+    Subcolumn new_subcolumn(*this);
     new_subcolumn.least_common_type = LeastCommonType{createArrayOfType(scalar_type, field_info.num_dimensions)};
-    new_subcolumn.is_nullable = is_nullable;
-    new_subcolumn.num_of_defaults_in_prefix = num_of_defaults_in_prefix;
-    new_subcolumn.data.reserve(data.size());
 
-    for (const auto & part : data)
-        new_subcolumn.data.push_back(recreateColumnWithDefaultValues(
-            part, scalar_type, field_info.num_dimensions));
+    for (auto & part : new_subcolumn.data)
+        part = recreateColumnWithDefaultValues(part, scalar_type, field_info.num_dimensions);
 
     return new_subcolumn;
 }
diff --git a/src/Columns/ColumnObject.h b/src/Columns/ColumnObject.h
index 89e42183ea01..4dc5bb5ce249 100644
--- a/src/Columns/ColumnObject.h
+++ b/src/Columns/ColumnObject.h
@@ -146,6 +146,8 @@ class ColumnObject final : public COWHelper<IColumn, ColumnObject>
         /// least common type and we count number of defaults in prefix,
         /// which will be converted to the default type of final common type.
         size_t num_of_defaults_in_prefix = 0;
+
+        size_t num_rows = 0;
     };
 
     using Subcolumns = SubcolumnsTree<Subcolumn>;
diff --git a/src/DataTypes/FieldToDataType.cpp b/src/DataTypes/FieldToDataType.cpp
index 283d1b1e41a6..49ece27cc1f5 100644
--- a/src/DataTypes/FieldToDataType.cpp
+++ b/src/DataTypes/FieldToDataType.cpp
@@ -22,13 +22,14 @@ namespace ErrorCodes
     extern const int EMPTY_DATA_PASSED;
 }
 
-
-DataTypePtr FieldToDataType::operator() (const Null &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Null &) const
 {
     return std::make_shared<DataTypeNullable>(std::make_shared<DataTypeNothing>());
 }
 
-DataTypePtr FieldToDataType::operator() (const UInt64 & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const UInt64 & x) const
 {
     if (x <= std::numeric_limits<UInt8>::max()) return std::make_shared<DataTypeUInt8>();
     if (x <= std::numeric_limits<UInt16>::max()) return std::make_shared<DataTypeUInt16>();
@@ -36,7 +37,8 @@ DataTypePtr FieldToDataType::operator() (const UInt64 & x) const
     return std::make_shared<DataTypeUInt64>();
 }
 
-DataTypePtr FieldToDataType::operator() (const Int64 & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Int64 & x) const
 {
     if (x <= std::numeric_limits<Int8>::max() && x >= std::numeric_limits<Int8>::min()) return std::make_shared<DataTypeInt8>();
     if (x <= std::numeric_limits<Int16>::max() && x >= std::numeric_limits<Int16>::min()) return std::make_shared<DataTypeInt16>();
@@ -44,77 +46,90 @@ DataTypePtr FieldToDataType::operator() (const Int64 & x) const
     return std::make_shared<DataTypeInt64>();
 }
 
-DataTypePtr FieldToDataType::operator() (const Float64 &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Float64 &) const
 {
     return std::make_shared<DataTypeFloat64>();
 }
 
-DataTypePtr FieldToDataType::operator() (const UInt128 &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const UInt128 &) const
 {
     return std::make_shared<DataTypeUInt128>();
 }
 
-DataTypePtr FieldToDataType::operator() (const Int128 &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Int128 &) const
 {
     return std::make_shared<DataTypeInt128>();
 }
 
-DataTypePtr FieldToDataType::operator() (const UInt256 &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const UInt256 &) const
 {
     return std::make_shared<DataTypeUInt256>();
 }
 
-DataTypePtr FieldToDataType::operator() (const Int256 &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Int256 &) const
 {
     return std::make_shared<DataTypeInt256>();
 }
 
-DataTypePtr FieldToDataType::operator() (const UUID &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const UUID &) const
 {
     return std::make_shared<DataTypeUUID>();
 }
 
-DataTypePtr FieldToDataType::operator() (const String &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const String &) const
 {
     return std::make_shared<DataTypeString>();
 }
 
-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal32> & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal32> & x) const
 {
     using Type = DataTypeDecimal<Decimal32>;
     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());
 }
 
-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal64> & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal64> & x) const
 {
     using Type = DataTypeDecimal<Decimal64>;
     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());
 }
 
-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal128> & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal128> & x) const
 {
     using Type = DataTypeDecimal<Decimal128>;
     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());
 }
 
-DataTypePtr FieldToDataType::operator() (const DecimalField<Decimal256> & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const DecimalField<Decimal256> & x) const
 {
     using Type = DataTypeDecimal<Decimal256>;
     return std::make_shared<Type>(Type::maxPrecision(), x.getScale());
 }
 
-DataTypePtr FieldToDataType::operator() (const Array & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Array & x) const
 {
     DataTypes element_types;
     element_types.reserve(x.size());
 
     for (const Field & elem : x)
-        element_types.emplace_back(applyVisitor(FieldToDataType(allow_convertion_to_string), elem));
+        element_types.emplace_back(applyVisitor(*this, elem));
 
-    return std::make_shared<DataTypeArray>(getLeastSupertype(element_types, allow_convertion_to_string));
+    return std::make_shared<DataTypeArray>(getLeastSupertype<on_error>(element_types));
 }
 
-DataTypePtr FieldToDataType::operator() (const Tuple & tuple) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Tuple & tuple) const
 {
     if (tuple.empty())
         throw Exception("Cannot infer type of an empty tuple", ErrorCodes::EMPTY_DATA_PASSED);
@@ -123,12 +138,13 @@ DataTypePtr FieldToDataType::operator() (const Tuple & tuple) const
     element_types.reserve(tuple.size());
 
     for (const auto & element : tuple)
-        element_types.push_back(applyVisitor(FieldToDataType(allow_convertion_to_string), element));
+        element_types.push_back(applyVisitor(*this, element));
 
     return std::make_shared<DataTypeTuple>(element_types);
 }
 
-DataTypePtr FieldToDataType::operator() (const Map & map) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Map & map) const
 {
     DataTypes key_types;
     DataTypes value_types;
@@ -139,30 +155,37 @@ DataTypePtr FieldToDataType::operator() (const Map & map) const
     {
         const auto & tuple = elem.safeGet<const Tuple &>();
         assert(tuple.size() == 2);
-        key_types.push_back(applyVisitor(FieldToDataType(allow_convertion_to_string), tuple[0]));
-        value_types.push_back(applyVisitor(FieldToDataType(allow_convertion_to_string), tuple[1]));
+        key_types.push_back(applyVisitor(*this, tuple[0]));
+        value_types.push_back(applyVisitor(*this, tuple[1]));
     }
 
     return std::make_shared<DataTypeMap>(
-        getLeastSupertype(key_types, allow_convertion_to_string),
-        getLeastSupertype(value_types, allow_convertion_to_string));
+        getLeastSupertype<on_error>(key_types),
+        getLeastSupertype<on_error>(value_types));
 }
 
-DataTypePtr FieldToDataType::operator() (const Object &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const Object &) const
 {
     /// TODO: Do we need different parameters for type Object?
     return std::make_shared<DataTypeObject>("json", false);
 }
 
-DataTypePtr FieldToDataType::operator() (const AggregateFunctionStateData & x) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator() (const AggregateFunctionStateData & x) const
 {
     const auto & name = static_cast<const AggregateFunctionStateData &>(x).name;
     return DataTypeFactory::instance().get(name);
 }
 
-DataTypePtr FieldToDataType::operator()(const bool &) const
+template <LeastSupertypeOnError on_error>
+DataTypePtr FieldToDataType<on_error>::operator()(const bool &) const
 {
     return DataTypeFactory::instance().get("Bool");
 }
 
+template class FieldToDataType<LeastSupertypeOnError::Throw>;
+template class FieldToDataType<LeastSupertypeOnError::String>;
+template class FieldToDataType<LeastSupertypeOnError::Null>;
+
 }
diff --git a/src/DataTypes/FieldToDataType.h b/src/DataTypes/FieldToDataType.h
index 1922ac8b7467..5e66fe420ad4 100644
--- a/src/DataTypes/FieldToDataType.h
+++ b/src/DataTypes/FieldToDataType.h
@@ -4,6 +4,7 @@
 #include <Core/Types.h>
 #include <Core/Field.h>
 #include <Common/FieldVisitors.h>
+#include <DataTypes/getLeastSupertype.h>
 
 
 namespace DB
@@ -17,14 +18,10 @@ using DataTypePtr = std::shared_ptr<const IDataType>;
   * Note that you still have to convert Field to corresponding data type before inserting to columns
   *  (for example, this is necessary to convert elements of Array to common type).
   */
+template <LeastSupertypeOnError on_error = LeastSupertypeOnError::Throw>
 class FieldToDataType : public StaticVisitor<DataTypePtr>
 {
 public:
-    FieldToDataType(bool allow_convertion_to_string_ = false)
-      : allow_convertion_to_string(allow_convertion_to_string_)
-    {
-    }
-
     DataTypePtr operator() (const Null & x) const;
     DataTypePtr operator() (const UInt64 & x) const;
     DataTypePtr operator() (const UInt128 & x) const;
@@ -45,9 +42,6 @@ class FieldToDataType : public StaticVisitor<DataTypePtr>
     DataTypePtr operator() (const UInt256 & x) const;
     DataTypePtr operator() (const Int256 & x) const;
     DataTypePtr operator() (const bool & x) const;
-
-private:
-    bool allow_convertion_to_string;
 };
 
 }
diff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h
index 420ef61a13fe..fce8906abe5f 100644
--- a/src/DataTypes/IDataType.h
+++ b/src/DataTypes/IDataType.h
@@ -565,4 +565,31 @@ class DataTypeEnum;
 
 template <typename T> inline constexpr bool IsDataTypeEnum<DataTypeEnum<T>> = true;
 
+#define FOR_BASIC_NUMERIC_TYPES(M) \
+    M(UInt8) \
+    M(UInt16) \
+    M(UInt32) \
+    M(UInt64) \
+    M(Int8) \
+    M(Int16) \
+    M(Int32) \
+    M(Int64) \
+    M(Float32) \
+    M(Float64)
+
+#define FOR_NUMERIC_TYPES(M) \
+    M(UInt8) \
+    M(UInt16) \
+    M(UInt32) \
+    M(UInt64) \
+    M(UInt128) \
+    M(UInt256) \
+    M(Int8) \
+    M(Int16) \
+    M(Int32) \
+    M(Int64) \
+    M(Int128) \
+    M(Int256) \
+    M(Float32) \
+    M(Float64)
 }
diff --git a/src/DataTypes/ObjectUtils.cpp b/src/DataTypes/ObjectUtils.cpp
index df639ae7aabb..b81c8c7a033e 100644
--- a/src/DataTypes/ObjectUtils.cpp
+++ b/src/DataTypes/ObjectUtils.cpp
@@ -261,7 +261,7 @@ DataTypePtr getLeastCommonTypeForObject(const DataTypes & types, bool check_ambi
                     key.getPath(), subtypes[0]->getName(), subtypes[i]->getName());
 
         tuple_paths.emplace_back(key);
-        tuple_types.emplace_back(getLeastSupertype(subtypes, /*allow_conversion_to_string=*/ true));
+        tuple_types.emplace_back(getLeastSupertypeOrString(subtypes));
     }
 
     if (tuple_paths.empty())
diff --git a/src/DataTypes/Serializations/SerializationObject.cpp b/src/DataTypes/Serializations/SerializationObject.cpp
index 85831df271a3..cf49fa8798d8 100644
--- a/src/DataTypes/Serializations/SerializationObject.cpp
+++ b/src/DataTypes/Serializations/SerializationObject.cpp
@@ -61,29 +61,23 @@ void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader &
     auto & [paths, values] = *result;
     assert(paths.size() == values.size());
 
-    HashSet<StringRef, StringRefHash> paths_set;
-    size_t column_size = column_object.size();
-
+    size_t old_column_size = column_object.size();
     for (size_t i = 0; i < paths.size(); ++i)
     {
         auto field_info = getFieldInfo(values[i]);
         if (isNothing(field_info.scalar_type))
             continue;
 
-        if (!paths_set.insert(paths[i].getPath()).second)
-            throw Exception(ErrorCodes::INCORRECT_DATA,
-                "Object has ambiguous path: {}", paths[i].getPath());
-
         if (!column_object.hasSubcolumn(paths[i]))
         {
             if (paths[i].hasNested())
-                column_object.addNestedSubcolumn(paths[i], field_info, column_size);
+                column_object.addNestedSubcolumn(paths[i], field_info, old_column_size);
             else
-                column_object.addSubcolumn(paths[i], column_size);
+                column_object.addSubcolumn(paths[i], old_column_size);
         }
 
         auto & subcolumn = column_object.getSubcolumn(paths[i]);
-        assert(subcolumn.size() == column_size);
+        assert(subcolumn.size() == old_column_size);
 
         subcolumn.insert(std::move(values[i]), std::move(field_info));
     }
@@ -92,7 +86,7 @@ void SerializationObject<Parser>::deserializeTextImpl(IColumn & column, Reader &
     const auto & subcolumns = column_object.getSubcolumns();
     for (const auto & entry : subcolumns)
     {
-        if (!paths_set.has(entry->path.getPath()))
+        if (entry->data.size() == old_column_size)
         {
             bool inserted = column_object.tryInsertDefaultFromNested(entry);
             if (!inserted)
diff --git a/src/DataTypes/getLeastSupertype.cpp b/src/DataTypes/getLeastSupertype.cpp
index 14cfafb1ef3c..ac240c4afceb 100644
--- a/src/DataTypes/getLeastSupertype.cpp
+++ b/src/DataTypes/getLeastSupertype.cpp
@@ -55,16 +55,24 @@ String getExceptionMessagePrefix(const DataTypes & types)
     return res.str();
 }
 
-DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_string)
+template <LeastSupertypeOnError on_error, typename DataTypes>
+DataTypePtr throwOrReturn(const DataTypes & types, std::string_view message_suffix, int error_code)
 {
-    auto throw_or_return = [&](std::string_view message, int error_code)
-    {
-        if (allow_conversion_to_string)
-            return std::make_shared<DataTypeString>();
+    if constexpr (on_error == LeastSupertypeOnError::String)
+        return std::make_shared<DataTypeString>();
 
-        throw Exception(String(message), error_code);
-    };
+    if constexpr (on_error == LeastSupertypeOnError::Null)
+        return nullptr;
+
+    if (message_suffix.empty())
+        throw Exception(error_code, getExceptionMessagePrefix(types));
 
+    throw Exception(error_code, "{} {}", getExceptionMessagePrefix(types), message_suffix);
+}
+
+template <LeastSupertypeOnError on_error>
+DataTypePtr getNumericType(const TypeIndexSet & types)
+{
     bool all_numbers = true;
 
     size_t max_bits_of_signed_integer = 0;
@@ -107,14 +115,14 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_
             maximize(max_mantissa_bits_of_floating, 24);
         else if (type == TypeIndex::Float64)
             maximize(max_mantissa_bits_of_floating, 53);
-        else
+        else if (type != TypeIndex::Nothing)
             all_numbers = false;
     }
 
     if (max_bits_of_signed_integer || max_bits_of_unsigned_integer || max_mantissa_bits_of_floating)
     {
         if (!all_numbers)
-            return throw_or_return(getExceptionMessagePrefix(types) + " because some of them are numbers and some of them are not", ErrorCodes::NO_COMMON_TYPE);
+            return throwOrReturn<on_error>(types, "because some of them are numbers and some of them are not", ErrorCodes::NO_COMMON_TYPE);
 
         /// If there are signed and unsigned types of same bit-width, the result must be signed number with at least one more bit.
         /// Example, common of Int32, UInt32 = Int64.
@@ -129,10 +137,9 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_
             if (min_bit_width_of_integer != 64)
                 ++min_bit_width_of_integer;
             else
-                return throw_or_return(
-                    getExceptionMessagePrefix(types)
-                        + " because some of them are signed integers and some are unsigned integers,"
-                            " but there is no signed integer type, that can exactly represent all required unsigned integer values",
+                return throwOrReturn<on_error>(types,
+                    "because some of them are signed integers and some are unsigned integers,"
+                    " but there is no signed integer type, that can exactly represent all required unsigned integer values",
                     ErrorCodes::NO_COMMON_TYPE);
         }
 
@@ -145,8 +152,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_
             else if (min_mantissa_bits <= 53)
                 return std::make_shared<DataTypeFloat64>();
             else
-                return throw_or_return(getExceptionMessagePrefix(types)
-                    + " because some of them are integers and some are floating point,"
+                return throwOrReturn<on_error>(types,
+                    " because some of them are integers and some are floating point,"
                     " but there is no floating point type, that can exactly represent all required integers", ErrorCodes::NO_COMMON_TYPE);
         }
 
@@ -166,8 +173,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_
             else if (min_bit_width_of_integer <= 256)
                 return std::make_shared<DataTypeInt256>();
             else
-                return throw_or_return(getExceptionMessagePrefix(types)
-                    + " because some of them are signed integers and some are unsigned integers,"
+                return throwOrReturn<on_error>(types,
+                    " because some of them are signed integers and some are unsigned integers,"
                     " but there is no signed integer type, that can exactly represent all required unsigned integer values", ErrorCodes::NO_COMMON_TYPE);
         }
 
@@ -186,9 +193,8 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_
             else if (min_bit_width_of_integer <= 256)
                 return std::make_shared<DataTypeUInt256>();
             else
-                return throw_or_return("Logical error: " + getExceptionMessagePrefix(types)
-                    + " but as all data types are unsigned integers, we must have found maximum unsigned integer type", ErrorCodes::NO_COMMON_TYPE);
-
+                return throwOrReturn<on_error>(types,
+                    " but as all data types are unsigned integers, we must have found maximum unsigned integer type", ErrorCodes::NO_COMMON_TYPE);
         }
     }
 
@@ -197,16 +203,9 @@ DataTypePtr getNumericType(const TypeIndexSet & types, bool allow_conversion_to_
 
 }
 
-DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_string)
+template <LeastSupertypeOnError on_error>
+DataTypePtr getLeastSupertype(const DataTypes & types)
 {
-    auto throw_or_return = [&](std::string_view message, int error_code)
-    {
-        if (allow_conversion_to_string)
-            return std::make_shared<DataTypeString>();
-
-        throw Exception(String(message), error_code);
-    };
-
     /// Trivial cases
 
     if (types.empty())
@@ -243,7 +242,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
                 non_nothing_types.emplace_back(type);
 
         if (non_nothing_types.size() < types.size())
-            return getLeastSupertype(non_nothing_types, allow_conversion_to_string);
+            return getLeastSupertype<on_error>(non_nothing_types);
     }
 
     /// For Arrays
@@ -268,9 +267,9 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
         if (have_array)
         {
             if (!all_arrays)
-                return throw_or_return(getExceptionMessagePrefix(types) + " because some of them are Array and some of them are not", ErrorCodes::NO_COMMON_TYPE);
+                return throwOrReturn<on_error>(types, "because some of them are Array and some of them are not", ErrorCodes::NO_COMMON_TYPE);
 
-            return std::make_shared<DataTypeArray>(getLeastSupertype(nested_types, allow_conversion_to_string));
+            return std::make_shared<DataTypeArray>(getLeastSupertype<on_error>(nested_types));
         }
     }
 
@@ -294,7 +293,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
                         nested_types[elem_idx].reserve(types.size());
                 }
                 else if (tuple_size != type_tuple->getElements().size())
-                    return throw_or_return(getExceptionMessagePrefix(types) + " because Tuples have different sizes", ErrorCodes::NO_COMMON_TYPE);
+                    return throwOrReturn<on_error>(types, "because Tuples have different sizes", ErrorCodes::NO_COMMON_TYPE);
 
                 have_tuple = true;
 
@@ -308,11 +307,11 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
         if (have_tuple)
         {
             if (!all_tuples)
-                return throw_or_return(getExceptionMessagePrefix(types) + " because some of them are Tuple and some of them are not", ErrorCodes::NO_COMMON_TYPE);
+                return throwOrReturn<on_error>(types, "because some of them are Tuple and some of them are not", ErrorCodes::NO_COMMON_TYPE);
 
             DataTypes common_tuple_types(tuple_size);
             for (size_t elem_idx = 0; elem_idx < tuple_size; ++elem_idx)
-                common_tuple_types[elem_idx] = getLeastSupertype(nested_types[elem_idx], allow_conversion_to_string);
+                common_tuple_types[elem_idx] = getLeastSupertype<on_error>(nested_types[elem_idx]);
 
             return std::make_shared<DataTypeTuple>(common_tuple_types);
         }
@@ -342,11 +341,11 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
         if (have_maps)
         {
             if (!all_maps)
-                return throw_or_return(getExceptionMessagePrefix(types) + " because some of them are Maps and some of them are not", ErrorCodes::NO_COMMON_TYPE);
+                return throwOrReturn<on_error>(types, "because some of them are Maps and some of them are not", ErrorCodes::NO_COMMON_TYPE);
 
             return std::make_shared<DataTypeMap>(
-                getLeastSupertype(key_types, allow_conversion_to_string),
-                getLeastSupertype(value_types, allow_conversion_to_string));
+                getLeastSupertype<on_error>(key_types),
+                getLeastSupertype<on_error>(value_types));
         }
     }
 
@@ -377,9 +376,9 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
         if (have_low_cardinality)
         {
             if (have_not_low_cardinality)
-                return getLeastSupertype(nested_types, allow_conversion_to_string);
+                return getLeastSupertype<on_error>(nested_types);
             else
-                return std::make_shared<DataTypeLowCardinality>(getLeastSupertype(nested_types, allow_conversion_to_string));
+                return std::make_shared<DataTypeLowCardinality>(getLeastSupertype<on_error>(nested_types));
         }
     }
 
@@ -405,7 +404,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
 
         if (have_nullable)
         {
-            return std::make_shared<DataTypeNullable>(getLeastSupertype(nested_types, allow_conversion_to_string));
+            return std::make_shared<DataTypeNullable>(getLeastSupertype<on_error>(nested_types));
         }
     }
 
@@ -425,7 +424,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
         {
             bool all_strings = type_ids.size() == (have_string + have_fixed_string);
             if (!all_strings)
-                return throw_or_return(getExceptionMessagePrefix(types) + " because some of them are String/FixedString and some of them are not", ErrorCodes::NO_COMMON_TYPE);
+                return throwOrReturn<on_error>(types, "because some of them are String/FixedString and some of them are not", ErrorCodes::NO_COMMON_TYPE);
 
             return std::make_shared<DataTypeString>();
         }
@@ -442,8 +441,8 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
         {
             bool all_date_or_datetime = type_ids.size() == (have_date + have_date32 + have_datetime + have_datetime64);
             if (!all_date_or_datetime)
-                return throw_or_return(getExceptionMessagePrefix(types)
-                    + " because some of them are Date/Date32/DateTime/DateTime64 and some of them are not",
+                return throwOrReturn<on_error>(types,
+                    "because some of them are Date/Date32/DateTime/DateTime64 and some of them are not",
                     ErrorCodes::NO_COMMON_TYPE);
 
             if (have_datetime64 == 0 && have_date32 == 0)
@@ -520,8 +519,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
             }
 
             if (num_supported != type_ids.size())
-                return throw_or_return(getExceptionMessagePrefix(types) + " because some of them have no lossless conversion to Decimal",
-                                ErrorCodes::NO_COMMON_TYPE);
+                return throwOrReturn<on_error>(types, "because some of them have no lossless conversion to Decimal", ErrorCodes::NO_COMMON_TYPE);
 
             UInt32 max_scale = 0;
             for (const auto & type : types)
@@ -543,7 +541,7 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
             }
 
             if (min_precision > DataTypeDecimal<Decimal128>::maxPrecision())
-                return throw_or_return(getExceptionMessagePrefix(types) + " because the least supertype is Decimal("
+                return throwOrReturn<on_error>(types, "because the least supertype is Decimal("
                                 + toString(min_precision) + ',' + toString(max_scale) + ')',
                                 ErrorCodes::NO_COMMON_TYPE);
 
@@ -557,68 +555,77 @@ DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_
 
     /// For numeric types, the most complicated part.
     {
-        auto numeric_type = getNumericType(type_ids, allow_conversion_to_string);
+        auto numeric_type = getNumericType<on_error>(type_ids);
         if (numeric_type)
             return numeric_type;
     }
 
     /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).
-    return throw_or_return(getExceptionMessagePrefix(types), ErrorCodes::NO_COMMON_TYPE);
+    return throwOrReturn<on_error>(types, "", ErrorCodes::NO_COMMON_TYPE);
 }
 
-DataTypePtr getLeastSupertype(const TypeIndexSet & types, bool allow_conversion_to_string)
+DataTypePtr getLeastSupertypeOrString(const DataTypes & types)
 {
-    auto throw_or_return = [&](std::string_view message, int error_code)
-    {
-        if (allow_conversion_to_string)
-            return std::make_shared<DataTypeString>();
+    return getLeastSupertype<LeastSupertypeOnError::String>(types);
+}
 
-        throw Exception(String(message), error_code);
-    };
+DataTypePtr tryGetLeastSupertype(const DataTypes & types)
+{
+    return getLeastSupertype<LeastSupertypeOnError::Null>(types);
+}
 
-    TypeIndexSet types_set;
-    for (const auto & type : types)
+template <LeastSupertypeOnError on_error>
+DataTypePtr getLeastSupertype(const TypeIndexSet & types)
+{
+    if (types.empty())
+        return std::make_shared<DataTypeNothing>();
+
+    if (types.size() == 1)
     {
-        if (WhichDataType(type).isNothing())
-            continue;
+        WhichDataType which(*types.begin());
+        if (which.isNothing())
+            return std::make_shared<DataTypeNothing>();
 
-        if (!WhichDataType(type).isSimple())
-            throw Exception(ErrorCodes::NO_COMMON_TYPE,
-                "Cannot get common type by type ids with parametric type {}", typeToString(type));
+    #define DISPATCH(TYPE) \
+        if (which.idx == TypeIndex::TYPE) \
+            return std::make_shared<DataTypeNumber<TYPE>>(); /// NOLINT
 
-        types_set.insert(type);
-    }
+        FOR_NUMERIC_TYPES(DISPATCH)
+    #undef DISPATCH
 
-    if (types_set.empty())
-        return std::make_shared<DataTypeNothing>();
+        if (which.isString())
+            return std::make_shared<DataTypeString>();
+
+        return throwOrReturn<on_error>(types, "because cannot get common type by type indexes with non-simple types", ErrorCodes::NO_COMMON_TYPE);
+    }
 
     if (types.contains(TypeIndex::String))
     {
-        if (types.size() != 1)
-            return throw_or_return(getExceptionMessagePrefix(types) + " because some of them are String and some of them are not", ErrorCodes::NO_COMMON_TYPE);
+        bool only_string = types.size() == 2 && types.contains(TypeIndex::Nothing);
+        if (!only_string)
+            return throwOrReturn<on_error>(types, "because some of them are String and some of them are not", ErrorCodes::NO_COMMON_TYPE);
 
         return std::make_shared<DataTypeString>();
     }
 
-    /// For numeric types, the most complicated part.
-    auto numeric_type = getNumericType(types, allow_conversion_to_string);
+    auto numeric_type = getNumericType<on_error>(types);
     if (numeric_type)
         return numeric_type;
 
-    /// All other data types (UUID, AggregateFunction, Enum...) are compatible only if they are the same (checked in trivial cases).
-    return throw_or_return(getExceptionMessagePrefix(types), ErrorCodes::NO_COMMON_TYPE);
+    return throwOrReturn<on_error>(types, "", ErrorCodes::NO_COMMON_TYPE);
 }
 
-DataTypePtr tryGetLeastSupertype(const DataTypes & types)
+DataTypePtr getLeastSupertypeOrString(const TypeIndexSet & types)
 {
-    try
-    {
-        return getLeastSupertype(types);
-    }
-    catch (...)
-    {
-        return nullptr;
-    }
+    return getLeastSupertype<LeastSupertypeOnError::String>(types);
 }
 
+DataTypePtr tryGetLeastSupertype(const TypeIndexSet & types)
+{
+    return getLeastSupertype<LeastSupertypeOnError::Null>(types);
+}
+
+template DataTypePtr getLeastSupertype<LeastSupertypeOnError::Throw>(const DataTypes & types);
+template DataTypePtr getLeastSupertype<LeastSupertypeOnError::Throw>(const TypeIndexSet & types);
+
 }
diff --git a/src/DataTypes/getLeastSupertype.h b/src/DataTypes/getLeastSupertype.h
index 5444bb34d063..2ef4a0e6850d 100644
--- a/src/DataTypes/getLeastSupertype.h
+++ b/src/DataTypes/getLeastSupertype.h
@@ -1,24 +1,39 @@
 #pragma once
-
 #include <DataTypes/IDataType.h>
 
-
 namespace DB
 {
 
+enum class LeastSupertypeOnError
+{
+    Throw,
+    String,
+    Null,
+};
+
 /** Get data type that covers all possible values of passed data types.
-  * If there is no such data type, throws an exception
-  * or if 'allow_conversion_to_string' is true returns String as common type.
+  * If there is no such data type, throws an exception.
   *
   * Examples: least common supertype for UInt8, Int8 - Int16.
   * Examples: there is no least common supertype for Array(UInt8), Int8.
   */
-DataTypePtr getLeastSupertype(const DataTypes & types, bool allow_conversion_to_string = false);
+template <LeastSupertypeOnError on_error = LeastSupertypeOnError::Throw>
+DataTypePtr getLeastSupertype(const DataTypes & types);
 
-using TypeIndexSet = std::unordered_set<TypeIndex>;
-DataTypePtr getLeastSupertype(const TypeIndexSet & types, bool allow_conversion_to_string = false);
+/// Same as above but return String type instead of throwing exception.
+/// All types can be casted to String, because they can be serialized to String.
+DataTypePtr getLeastSupertypeOrString(const DataTypes & types);
 
 /// Same as above but return nullptr instead of throwing exception.
 DataTypePtr tryGetLeastSupertype(const DataTypes & types);
 
+using TypeIndexSet = std::unordered_set<TypeIndex>;
+
+template <LeastSupertypeOnError on_error = LeastSupertypeOnError::Throw>
+DataTypePtr getLeastSupertype(const TypeIndexSet & types);
+
+DataTypePtr getLeastSupertypeOrString(const TypeIndexSet & types);
+
+DataTypePtr tryGetLeastSupertype(const TypeIndexSet & types);
+
 }
diff --git a/src/Interpreters/RowRefs.cpp b/src/Interpreters/RowRefs.cpp
index 97feed54c08e..2a18c2c700a7 100644
--- a/src/Interpreters/RowRefs.cpp
+++ b/src/Interpreters/RowRefs.cpp
@@ -1,7 +1,6 @@
 #include <Interpreters/RowRefs.h>
 
 #include <Common/RadixSort.h>
-#include <AggregateFunctions/Helpers.h>
 #include <Columns/IColumn.h>
 #include <DataTypes/IDataType.h>
 #include <base/types.h>
diff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp
index f6baae723c9f..40f23fe52947 100644
--- a/src/Storages/MergeTree/KeyCondition.cpp
+++ b/src/Storages/MergeTree/KeyCondition.cpp
@@ -1300,7 +1300,7 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, ContextPtr context,
                 }
                 else
                 {
-                    DataTypePtr common_type = tryGetLeastSupertype({key_expr_type_not_null, const_type});
+                    DataTypePtr common_type = tryGetLeastSupertype(DataTypes{key_expr_type_not_null, const_type});
                     if (!common_type)
                         return false;
 
