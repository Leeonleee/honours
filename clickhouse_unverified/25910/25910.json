{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25910,
  "instance_id": "ClickHouse__ClickHouse-25910",
  "issue_numbers": [
    "11607"
  ],
  "base_commit": "7a993404b4d222884bedf4a933f999213be48b5c",
  "patch": "diff --git a/src/AggregateFunctions/parseAggregateFunctionParameters.cpp b/src/AggregateFunctions/parseAggregateFunctionParameters.cpp\nindex 3826d993c4a7..64eb0932de96 100644\n--- a/src/AggregateFunctions/parseAggregateFunctionParameters.cpp\n+++ b/src/AggregateFunctions/parseAggregateFunctionParameters.cpp\n@@ -4,6 +4,8 @@\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/parseQuery.h>\n \n+#include <Interpreters/evaluateConstantExpression.h>\n+\n \n namespace DB\n {\n@@ -15,7 +17,7 @@ namespace ErrorCodes\n     extern const int PARAMETERS_TO_AGGREGATE_FUNCTIONS_MUST_BE_LITERALS;\n }\n \n-Array getAggregateFunctionParametersArray(const ASTPtr & expression_list, const std::string & error_context)\n+Array getAggregateFunctionParametersArray(const ASTPtr & expression_list, const std::string & error_context, ContextPtr context)\n {\n     const ASTs & parameters = expression_list->children;\n     if (parameters.empty())\n@@ -25,25 +27,25 @@ Array getAggregateFunctionParametersArray(const ASTPtr & expression_list, const\n \n     for (size_t i = 0; i < parameters.size(); ++i)\n     {\n-        const auto * literal = parameters[i]->as<ASTLiteral>();\n-\n-        ASTPtr func_literal;\n-        if (!literal)\n-            if (const auto * func = parameters[i]->as<ASTFunction>())\n-                if ((func_literal = func->toLiteral()))\n-                    literal = func_literal->as<ASTLiteral>();\n-\n-        if (!literal)\n+        ASTPtr literal;\n+        try\n+        {\n+            literal = evaluateConstantExpressionAsLiteral(parameters[i], context);\n+        }\n+        catch (Exception & e)\n         {\n-            throw Exception(\n-                ErrorCodes::PARAMETERS_TO_AGGREGATE_FUNCTIONS_MUST_BE_LITERALS,\n-                \"Parameters to aggregate functions must be literals. \"\n-                \"Got parameter '{}'{}\",\n-                parameters[i]->formatForErrorMessage(),\n-                (error_context.empty() ? \"\" : \" (in \" + error_context +\")\"));\n+            if (e.code() == ErrorCodes::BAD_ARGUMENTS)\n+                throw Exception(\n+                    ErrorCodes::PARAMETERS_TO_AGGREGATE_FUNCTIONS_MUST_BE_LITERALS,\n+                    \"Parameters to aggregate functions must be literals. \"\n+                    \"Got parameter '{}'{}\",\n+                    parameters[i]->formatForErrorMessage(),\n+                    (error_context.empty() ? \"\" : \" (in \" + error_context +\")\"));\n+\n+            throw;\n         }\n \n-        params_row[i] = literal->value;\n+        params_row[i] = literal->as<ASTLiteral>()->value;\n     }\n \n     return params_row;\n@@ -54,7 +56,8 @@ void getAggregateFunctionNameAndParametersArray(\n     const std::string & aggregate_function_name_with_params,\n     std::string & aggregate_function_name,\n     Array & aggregate_function_parameters,\n-    const std::string & error_context)\n+    const std::string & error_context,\n+    ContextPtr context)\n {\n     if (aggregate_function_name_with_params.back() != ')')\n     {\n@@ -84,7 +87,7 @@ void getAggregateFunctionNameAndParametersArray(\n         throw Exception(\"Incorrect list of parameters to aggregate function \"\n             + aggregate_function_name, ErrorCodes::BAD_ARGUMENTS);\n \n-    aggregate_function_parameters = getAggregateFunctionParametersArray(args_ast);\n+    aggregate_function_parameters = getAggregateFunctionParametersArray(args_ast, error_context, context);\n }\n \n }\ndiff --git a/src/AggregateFunctions/parseAggregateFunctionParameters.h b/src/AggregateFunctions/parseAggregateFunctionParameters.h\nindex 37f1f1d50970..033e92714dd4 100644\n--- a/src/AggregateFunctions/parseAggregateFunctionParameters.h\n+++ b/src/AggregateFunctions/parseAggregateFunctionParameters.h\n@@ -1,19 +1,23 @@\n #pragma once\n+\n #include <Parsers/ASTLiteral.h>\n #include <Parsers/ASTExpressionList.h>\n+#include <Interpreters/Context_fwd.h>\n \n \n namespace DB\n {\n-struct Settings;\n-\n-Array getAggregateFunctionParametersArray(const ASTPtr & expression_list, const std::string & error_context = \"\");\n \n+Array getAggregateFunctionParametersArray(\n+    const ASTPtr & expression_list,\n+    const std::string & error_context,\n+    ContextPtr context);\n \n void getAggregateFunctionNameAndParametersArray(\n     const std::string & aggregate_function_name_with_params,\n     std::string & aggregate_function_name,\n     Array & aggregate_function_parameters,\n-    const std::string & error_context);\n+    const std::string & error_context,\n+    ContextPtr context);\n \n }\ndiff --git a/src/Functions/array/arrayReduce.cpp b/src/Functions/array/arrayReduce.cpp\nindex 9a4b5aafdb9d..e070596e5ee9 100644\n--- a/src/Functions/array/arrayReduce.cpp\n+++ b/src/Functions/array/arrayReduce.cpp\n@@ -33,11 +33,12 @@ namespace ErrorCodes\n   * arrayReduce('agg', arr1, ...) - apply the aggregate function `agg` to arrays `arr1...`\n   *  If multiple arrays passed, then elements on corresponding positions are passed as multiple arguments to the aggregate function.\n   */\n-class FunctionArrayReduce : public IFunction\n+class FunctionArrayReduce : public IFunction, private WithContext\n {\n public:\n     static constexpr auto name = \"arrayReduce\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayReduce>(); }\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionArrayReduce>(context_); }\n+    explicit FunctionArrayReduce(ContextPtr context_) : WithContext(context_) {}\n \n     String getName() const override { return name; }\n \n@@ -95,7 +96,7 @@ DataTypePtr FunctionArrayReduce::getReturnTypeImpl(const ColumnsWithTypeAndName\n         String aggregate_function_name;\n         Array params_row;\n         getAggregateFunctionNameAndParametersArray(aggregate_function_name_with_params,\n-                                                   aggregate_function_name, params_row, \"function \" + getName());\n+                                                   aggregate_function_name, params_row, \"function \" + getName(), getContext());\n \n         AggregateFunctionProperties properties;\n         aggregate_function = AggregateFunctionFactory::instance().get(aggregate_function_name, argument_types, params_row, properties);\ndiff --git a/src/Functions/array/arrayReduceInRanges.cpp b/src/Functions/array/arrayReduceInRanges.cpp\nindex 9a2e8e1ca95d..18140fe504d5 100644\n--- a/src/Functions/array/arrayReduceInRanges.cpp\n+++ b/src/Functions/array/arrayReduceInRanges.cpp\n@@ -35,12 +35,13 @@ namespace ErrorCodes\n   *\n   * arrayReduceInRanges('agg', indices, lengths, arr1, ...)\n   */\n-class FunctionArrayReduceInRanges : public IFunction\n+class FunctionArrayReduceInRanges : public IFunction, private WithContext\n {\n public:\n     static const size_t minimum_step = 64;\n     static constexpr auto name = \"arrayReduceInRanges\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayReduceInRanges>(); }\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionArrayReduceInRanges>(context_); }\n+    explicit FunctionArrayReduceInRanges(ContextPtr context_) : WithContext(context_) {}\n \n     String getName() const override { return name; }\n \n@@ -113,7 +114,7 @@ DataTypePtr FunctionArrayReduceInRanges::getReturnTypeImpl(const ColumnsWithType\n         String aggregate_function_name;\n         Array params_row;\n         getAggregateFunctionNameAndParametersArray(aggregate_function_name_with_params,\n-                                                   aggregate_function_name, params_row, \"function \" + getName());\n+                                                   aggregate_function_name, params_row, \"function \" + getName(), getContext());\n \n         AggregateFunctionProperties properties;\n         aggregate_function = AggregateFunctionFactory::instance().get(aggregate_function_name, argument_types, params_row, properties);\ndiff --git a/src/Functions/initializeAggregation.cpp b/src/Functions/initializeAggregation.cpp\nindex b9b3d2195519..060788773b62 100644\n--- a/src/Functions/initializeAggregation.cpp\n+++ b/src/Functions/initializeAggregation.cpp\n@@ -25,11 +25,12 @@ namespace ErrorCodes\n namespace\n {\n \n-class FunctionInitializeAggregation : public IFunction\n+class FunctionInitializeAggregation : public IFunction, private WithContext\n {\n public:\n     static constexpr auto name = \"initializeAggregation\";\n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionInitializeAggregation>(); }\n+    static FunctionPtr create(ContextPtr context_) { return std::make_shared<FunctionInitializeAggregation>(context_); }\n+    FunctionInitializeAggregation(ContextPtr context_) : WithContext(context_) {}\n \n     String getName() const override { return name; }\n \n@@ -78,7 +79,7 @@ DataTypePtr FunctionInitializeAggregation::getReturnTypeImpl(const ColumnsWithTy\n         String aggregate_function_name;\n         Array params_row;\n         getAggregateFunctionNameAndParametersArray(aggregate_function_name_with_params,\n-                                                   aggregate_function_name, params_row, \"function \" + getName());\n+                                                   aggregate_function_name, params_row, \"function \" + getName(), getContext());\n \n         AggregateFunctionProperties properties;\n         aggregate_function = AggregateFunctionFactory::instance().get(aggregate_function_name, argument_types, params_row, properties);\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 5b2339975c15..e693d4ba9888 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -468,7 +468,7 @@ bool ExpressionAnalyzer::makeAggregateDescriptions(ActionsDAGPtr & actions)\n         }\n \n         AggregateFunctionProperties properties;\n-        aggregate.parameters = (node->parameters) ? getAggregateFunctionParametersArray(node->parameters) : Array();\n+        aggregate.parameters = (node->parameters) ? getAggregateFunctionParametersArray(node->parameters, \"\", getContext()) : Array();\n         aggregate.function = AggregateFunctionFactory::instance().get(node->name, types, aggregate.parameters, properties);\n \n         aggregate_descriptions.push_back(aggregate);\n@@ -651,7 +651,7 @@ void ExpressionAnalyzer::makeWindowDescriptions(ActionsDAGPtr actions)\n         window_function.function_parameters\n             = window_function.function_node->parameters\n                 ? getAggregateFunctionParametersArray(\n-                    window_function.function_node->parameters)\n+                    window_function.function_node->parameters, \"\", getContext())\n                 : Array();\n \n         // Requiring a constant reference to a shared pointer to non-const AST\ndiff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex 90f6ac84afc5..d91ea9208e43 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -49,17 +49,20 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co\n     expr_for_constant_folding->execute(block_with_constants);\n \n     if (!block_with_constants || block_with_constants.rows() == 0)\n-        throw Exception(\"Logical error: empty block after evaluation of constant expression for IN, VALUES or LIMIT\", ErrorCodes::LOGICAL_ERROR);\n+        throw Exception(\"Logical error: empty block after evaluation of constant expression for IN, VALUES or LIMIT or aggregate function parameter\",\n+                        ErrorCodes::LOGICAL_ERROR);\n \n     if (!block_with_constants.has(name))\n-        throw Exception(\"Element of set in IN, VALUES or LIMIT is not a constant expression (result column not found): \" + name, ErrorCodes::BAD_ARGUMENTS);\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Element of set in IN, VALUES or LIMIT or aggregate function parameter is not a constant expression (result column not found): {}\", name);\n \n     const ColumnWithTypeAndName & result = block_with_constants.getByName(name);\n     const IColumn & result_column = *result.column;\n \n     /// Expressions like rand() or now() are not constant\n     if (!isColumnConst(result_column))\n-        throw Exception(\"Element of set in IN, VALUES or LIMIT is not a constant expression (result column is not const): \" + name, ErrorCodes::BAD_ARGUMENTS);\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS,\n+            \"Element of set in IN, VALUES or LIMIT or aggregate function parameter is not a constant expression (result column is not const): {}\", name);\n \n     return std::make_pair(result_column[0], result.type);\n }\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex b3b9ce31ff5a..539f77133203 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -116,8 +116,11 @@ static bool compareRetentions(const Graphite::Retention & a, const Graphite::Ret\n   *     </default>\n   * </graphite_rollup>\n   */\n-static void\n-appendGraphitePattern(const Poco::Util::AbstractConfiguration & config, const String & config_element, Graphite::Patterns & patterns)\n+static void appendGraphitePattern(\n+    const Poco::Util::AbstractConfiguration & config,\n+    const String & config_element,\n+    Graphite::Patterns & out_patterns,\n+    ContextPtr context)\n {\n     Graphite::Pattern pattern;\n \n@@ -137,7 +140,7 @@ appendGraphitePattern(const Poco::Util::AbstractConfiguration & config, const St\n             String aggregate_function_name;\n             Array params_row;\n             getAggregateFunctionNameAndParametersArray(\n-                aggregate_function_name_with_params, aggregate_function_name, params_row, \"GraphiteMergeTree storage initialization\");\n+                aggregate_function_name_with_params, aggregate_function_name, params_row, \"GraphiteMergeTree storage initialization\", context);\n \n             /// TODO Not only Float64\n             AggregateFunctionProperties properties;\n@@ -181,7 +184,7 @@ appendGraphitePattern(const Poco::Util::AbstractConfiguration & config, const St\n     if (pattern.type & pattern.TypeRetention) /// TypeRetention or TypeAll\n         std::sort(pattern.retentions.begin(), pattern.retentions.end(), compareRetentions);\n \n-    patterns.emplace_back(pattern);\n+    out_patterns.emplace_back(pattern);\n }\n \n static void setGraphitePatternsFromConfig(ContextPtr context, const String & config_element, Graphite::Params & params)\n@@ -204,7 +207,7 @@ static void setGraphitePatternsFromConfig(ContextPtr context, const String & con\n     {\n         if (startsWith(key, \"pattern\"))\n         {\n-            appendGraphitePattern(config, config_element + \".\" + key, params.patterns);\n+            appendGraphitePattern(config, config_element + \".\" + key, params.patterns, context);\n         }\n         else if (key == \"default\")\n         {\n@@ -219,7 +222,7 @@ static void setGraphitePatternsFromConfig(ContextPtr context, const String & con\n     }\n \n     if (config.has(config_element + \".default\"))\n-        appendGraphitePattern(config, config_element + \".\" + \".default\", params.patterns);\n+        appendGraphitePattern(config, config_element + \".\" + \".default\", params.patterns, context);\n }\n \n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.reference b/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.reference\nnew file mode 100644\nindex 000000000000..61be3e78ae75\n--- /dev/null\n+++ b/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.reference\n@@ -0,0 +1,2 @@\n+[0,1,2,3,4]\n+[0,1,2,3,4]\ndiff --git a/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.sql b/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.sql\nnew file mode 100644\nindex 000000000000..3ab969ca2567\n--- /dev/null\n+++ b/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.sql\n@@ -0,0 +1,11 @@\n+SELECT groupArray(2 + 3)(number) FROM numbers(10);\n+SELECT groupArray('5'::UInt8)(number) FROM numbers(10);\n+\n+SELECT groupArray()(number) FROM numbers(10); -- { serverError 36 }\n+SELECT groupArray(NULL)(number) FROM numbers(10); -- { serverError 36 }\n+SELECT groupArray(NULL + NULL)(number) FROM numbers(10); -- { serverError 36 }\n+SELECT groupArray([])(number) FROM numbers(10); -- { serverError 36 }\n+SELECT groupArray(throwIf(1))(number) FROM numbers(10); -- { serverError 395 }\n+\n+-- Not the best error message, can be improved.\n+SELECT groupArray(number)(number) FROM numbers(10); -- { serverError 47 }\ndiff --git a/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.reference b/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.reference\nnew file mode 100644\nindex 000000000000..0cfbf08886fc\n--- /dev/null\n+++ b/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.reference\n@@ -0,0 +1,1 @@\n+2\ndiff --git a/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.sh b/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.sh\nnew file mode 100755\nindex 000000000000..bbc24af12142\n--- /dev/null\n+++ b/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.sh\n@@ -0,0 +1,7 @@\n+#!/usr/bin/env bash\n+\n+CUR_DIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CUR_DIR\"/../shell_config.sh\n+\n+${CLICKHOUSE_CURL} -sS -XPOST \"${CLICKHOUSE_URL}&param_lim=2\" --data-binary 'select length(topKArray({lim:UInt32})([1,1,2,3,4,5,6,7,7,7]))'\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex 7c1f998e91dc..64aef86ec9ca 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -520,7 +520,8 @@\n         \"01914_exchange_dictionaries\",\n         \"01915_create_or_replace_dictionary\",\n         \"01913_names_of_tuple_literal\",\n-        \"01925_merge_prewhere_table\"\n+        \"01925_merge_prewhere_table\",\n+        \"01934_constexpr_aggregate_function_parameters\"\n     ],\n     \"parallel\":\n     [\n",
  "problem_statement": "Http request uri parameter: Code: 134, e.displayText() = DB::Exception: Parameters to aggregate functions must be literals \n**Describe the bug**\r\nQuery with http parameter of type Int32 for topKArray function throwing an error:\r\nCode: 134, e.displayText() = DB::Exception: Parameters to aggregate functions must be literals \r\nOther signed of unsigned types does not work too\r\n\r\n**How to reproduce**\r\nVersions: 20.4.5.36 or 20.4.4.18 or 20.3.8.53\r\ncurl -XPOST 'http://localhost:8123/?param_lim=2' -d 'select topKArray({lim:UInt32})([1,1,2,3,4,5,6,7,7,7])' \r\n\r\n**Expected behavior**\r\nSame result if you specify parameter value inside query\r\ncurl -XPOST 'http://localhost:8123/' -d 'select topKArray(2)([1,1,2,3,4,5,6,7,7,7])' \r\n\r\n**Error message and/or stacktrace**\r\nCode: 134, e.displayText() = DB::Exception: Parameters to aggregate functions must be literals \r\n\n",
  "hints_text": "",
  "created_at": "2021-07-02T00:55:00Z",
  "modified_files": [
    "src/AggregateFunctions/parseAggregateFunctionParameters.cpp",
    "src/AggregateFunctions/parseAggregateFunctionParameters.h",
    "src/Functions/array/arrayReduce.cpp",
    "src/Functions/array/arrayReduceInRanges.cpp",
    "src/Functions/initializeAggregation.cpp",
    "src/Interpreters/ExpressionAnalyzer.cpp",
    "src/Interpreters/evaluateConstantExpression.cpp",
    "src/Storages/MergeTree/registerStorageMergeTree.cpp"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.reference",
    "b/tests/queries/0_stateless/01934_constexpr_aggregate_function_parameters.sql",
    "b/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.reference",
    "b/tests/queries/0_stateless/01935_parametrized_query_parametric_aggregate_function.sh",
    "tests/queries/skip_list.json"
  ]
}