{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 44149,
  "instance_id": "ClickHouse__ClickHouse-44149",
  "issue_numbers": [
    "34600"
  ],
  "base_commit": "f35faa4b8f9f8efffec13d9af8d24933b82dbe49",
  "patch": "diff --git a/docs/en/operations/server-configuration-parameters/settings.md b/docs/en/operations/server-configuration-parameters/settings.md\nindex ce62d4368135..5643e273d39a 100644\n--- a/docs/en/operations/server-configuration-parameters/settings.md\n+++ b/docs/en/operations/server-configuration-parameters/settings.md\n@@ -1975,6 +1975,10 @@ The time zone is necessary for conversions between String and DateTime formats w\n <timezone>Asia/Istanbul</timezone>\n ```\n \n+**See also**\n+\n+- [session_timezone](../settings/settings.md#session_timezone)\n+\n ## tcp_port {#server_configuration_parameters-tcp_port}\n \n Port for communicating with clients over the TCP protocol.\ndiff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex baefbb2cf6fc..cff65e049f32 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -4251,6 +4251,69 @@ Default value: `0`.\n Use this setting only for backward compatibility if your use cases depend on old syntax.\n :::\n \n+## session_timezone {#session_timezone}\n+\n+Sets the implicit time zone of the current session or query.\n+The implicit time zone is the time zone applied to values of type DateTime/DateTime64 which have no explicitly specified time zone. \n+The setting takes precedence over the globally configured (server-level) implicit time zone.\n+A value of '' (empty string) means that the implicit time zone of the current session or query is equal to the [server time zone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone).\n+\n+You can use functions `timeZone()` and `serverTimeZone()` to get the session time zone and server time zone.\n+\n+Possible values:\n+\n+-    Any time zone name from `system.time_zones`, e.g. `Europe/Berlin`, `UTC` or `Zulu`\n+\n+Default value: `''`.\n+\n+Examples:\n+\n+```sql\n+SELECT timeZone(), serverTimeZone() FORMAT TSV\n+\n+Europe/Berlin\tEurope/Berlin\n+```\n+\n+```sql\n+SELECT timeZone(), serverTimeZone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT TSV\n+\n+Asia/Novosibirsk\tEurope/Berlin\n+```\n+\n+Assign session time zone 'America/Denver' to the inner DateTime without explicitly specified time zone:\n+\n+```sql\n+SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV\n+\n+1999-12-13 07:23:23.123\n+```\n+\n+:::warning\n+Not all functions that parse DateTime/DateTime64 respect `session_timezone`. This can lead to subtle errors. \n+See the following example and explanation.\n+:::\n+\n+```sql\n+CREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');\n+\n+SELECT *, timeZone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'\n+0 rows in set.\n+\n+SELECT *, timeZone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d\u2500\u252c\u2500timeZone()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 2000-01-01 00:00:00 \u2502 Asia/Novosibirsk \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+This happens due to different parsing pipelines:\n+\n+- `toDateTime()` without explicitly given time zone used in the first `SELECT` query honors setting `session_timezone` and the global time zone.\n+- In the second query, a DateTime is parsed from a String, and inherits the type and time zone of the existing column`d`. Thus, setting `session_timezone` and the global time zone are not honored.\n+\n+**See also**\n+\n+- [timezone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone)\n+\n ## final {#final}\n \n Automatically applies [FINAL](../../sql-reference/statements/select/from.md#final-modifier) modifier to all tables in a query, to tables where [FINAL](../../sql-reference/statements/select/from.md#final-modifier) is applicable, including joined tables and tables in sub-queries, and\ndiff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 280b41e7a5f6..3f61e7a214da 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -139,8 +139,8 @@ makeDateTime32(year, month, day, hour, minute, second[, fraction[, precision[, t\n \n ## timeZone\n \n-Returns the timezone of the server.\n-If the function is executed in the context of a distributed table, it generates a normal column with values relevant to each shard, otherwise it produces a constant value.\n+Returns the timezone of the current session, i.e. the value of setting [session_timezone](../../operations/settings/settings.md#session_timezone).\n+If the function is executed in the context of a distributed table, then it generates a normal column with values relevant to each shard, otherwise it produces a constant value.\n \n **Syntax**\n \n@@ -156,6 +156,33 @@ Alias: `timezone`.\n \n Type: [String](../../sql-reference/data-types/string.md).\n \n+**See also**\n+\n+- [serverTimeZone](#serverTimeZone)\n+\n+## serverTimeZone\n+\n+Returns the timezone of the server, i.e. the value of setting [timezone](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-timezone).\n+If the function is executed in the context of a distributed table, then it generates a normal column with values relevant to each shard. Otherwise, it produces a constant value.\n+\n+**Syntax**\n+\n+``` sql\n+serverTimeZone()\n+```\n+\n+Alias: `serverTimezone`.\n+\n+**Returned value**\n+\n+-   Timezone.\n+\n+Type: [String](../../sql-reference/data-types/string.md).\n+\n+**See also**\n+\n+- [timeZone](#timeZone)\n+\n ## toTimeZone\n \n Converts a date or date with time to the specified time zone. Does not change the internal value (number of unix seconds) of the data, only the value's time zone attribute and the value's string representation changes.\ndiff --git a/docs/ru/operations/server-configuration-parameters/settings.md b/docs/ru/operations/server-configuration-parameters/settings.md\nindex 787153d4d199..33db6df0fdd3 100644\n--- a/docs/ru/operations/server-configuration-parameters/settings.md\n+++ b/docs/ru/operations/server-configuration-parameters/settings.md\n@@ -1355,6 +1355,10 @@ Parameters:\n <timezone>Europe/Moscow</timezone>\n ```\n \n+**\u0421\u043c. \u0442\u0430\u043a\u0436\u0435**\n+\n+- [session_timezone](../settings/settings.md#session_timezone)\n+\n ## tcp_port {#server_configuration_parameters-tcp_port}\n \n \u041f\u043e\u0440\u0442 \u0434\u043b\u044f \u0432\u0437\u0430\u0438\u043c\u043e\u0434\u0435\u0439\u0441\u0442\u0432\u0438\u044f \u0441 \u043a\u043b\u0438\u0435\u043d\u0442\u0430\u043c\u0438 \u043f\u043e \u043f\u0440\u043e\u0442\u043e\u043a\u043e\u043b\u0443 TCP.\ndiff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md\nindex e3da8302fc8a..f83d05ff7103 100644\n--- a/docs/ru/operations/settings/settings.md\n+++ b/docs/ru/operations/settings/settings.md\n@@ -4127,6 +4127,63 @@ SELECT sum(number) FROM numbers(10000000000) SETTINGS partial_result_on_first_ca\n \n \u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `false`\n \n+## session_timezone {#session_timezone}\n+\n+\u0417\u0430\u0434\u0430\u0451\u0442 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0447\u0430\u0441\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u044f\u0441\u0430 (session_timezone) \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e \u0434\u043b\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0441\u0435\u0441\u0441\u0438\u0438 \u0432\u043c\u0435\u0441\u0442\u043e [\u0447\u0430\u0441\u043e\u0432\u043e\u0433\u043e \u043f\u043e\u044f\u0441\u0430 \u0441\u0435\u0440\u0432\u0435\u0440\u0430](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone). \u0422\u043e \u0435\u0441\u0442\u044c, \u0432\u0441\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f DateTime/DateTime64, \u0434\u043b\u044f \u043a\u043e\u0442\u043e\u0440\u044b\u0445 \u044f\u0432\u043d\u043e \u043d\u0435 \u0437\u0430\u0434\u0430\u043d \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441, \u0431\u0443\u0434\u0443\u0442 \u0438\u043d\u0442\u0435\u0440\u043f\u0440\u0435\u0442\u0438\u0440\u043e\u0432\u0430\u043d\u044b \u043a\u0430\u043a \u043e\u0442\u043d\u043e\u0441\u044f\u0449\u0438\u0435\u0441\u044f \u043a \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u043e\u0439 \u0437\u043e\u043d\u0435.\n+\u041f\u0440\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0438 \u043d\u0430\u0441\u0442\u0440\u043e\u0439\u043a\u0438 `''` (\u043f\u0443\u0441\u0442\u0430\u044f \u0441\u0442\u0440\u043e\u043a\u0430), \u0431\u0443\u0434\u0435\u0442 \u0441\u043e\u0432\u043f\u0430\u0434\u0430\u0442\u044c \u0441 \u0447\u0430\u0441\u043e\u0432\u044b\u043c \u043f\u043e\u044f\u0441\u043e\u043c \u0441\u0435\u0440\u0432\u0435\u0440\u0430. \n+\n+\u0424\u0443\u043d\u043a\u0446\u0438\u0438 `timeZone()` and `serverTimezone()` \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u044e\u0442 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441 \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0441\u0435\u0441\u0441\u0438\u0438 \u0438 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e.\n+\n+\u041f\u0440\u0438\u043c\u0435\u0440\u044b:\n+```sql\n+SELECT timeZone(), serverTimezone() FORMAT TSV\n+\n+Europe/Berlin\tEurope/Berlin\n+```\n+\n+```sql\n+SELECT timeZone(), serverTimezone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT TSV\n+\n+Asia/Novosibirsk\tEurope/Berlin\n+```\n+\n+```sql\n+SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV\n+\n+1999-12-13 07:23:23.123\n+```\n+\n+\u0412\u043e\u0437\u043c\u043e\u0436\u043d\u044b\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f:\n+\n+-    \u041b\u044e\u0431\u0430\u044f \u0437\u043e\u043d\u0430 \u0438\u0437 `system.time_zones`, \u043d\u0430\u043f\u0440\u0438\u043c\u0435\u0440 `Europe/Berlin`, `UTC` \u0438\u043b\u0438 `Zulu`\n+\n+\u0417\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e: `''`.\n+\n+:::warning\n+\u0418\u043d\u043e\u0433\u0434\u0430 \u043f\u0440\u0438 \u0444\u043e\u0440\u043c\u0438\u0440\u043e\u0432\u0430\u043d\u0438\u0438 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0439 \u0442\u0438\u043f\u0430 `DateTime` \u0438 `DateTime64` \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440  `session_timezone` \u043c\u043e\u0436\u0435\u0442 \u0431\u044b\u0442\u044c \u043f\u0440\u043e\u0438\u0433\u043d\u043e\u0440\u0438\u0440\u043e\u0432\u0430\u043d.\n+\u042d\u0442\u043e \u043c\u043e\u0436\u0435\u0442 \u043f\u0440\u0438\u0432\u0435\u0441\u0442\u0438 \u043a \u043f\u0443\u0442\u0430\u043d\u0438\u0446\u0435. \u041f\u0440\u0438\u043c\u0435\u0440 \u0438 \u043f\u043e\u044f\u0441\u043d\u0435\u043d\u0438\u0435 \u0441\u043c. \u043d\u0438\u0436\u0435.\n+:::\n+\n+```sql\n+CREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');\n+\n+SELECT *, timezone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'\n+0 rows in set.\n+\n+SELECT *, timezone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500d\u2500\u252c\u2500timezone()\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 2000-01-01 00:00:00 \u2502 Asia/Novosibirsk \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+\u042d\u0442\u043e \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0434\u0438\u0442 \u0438\u0437-\u0437\u0430 \u0440\u0430\u0437\u043b\u0438\u0447\u043d\u043e\u0433\u043e \u043f\u0440\u043e\u0438\u0441\u0445\u043e\u0436\u0434\u0435\u043d\u0438\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f, \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u0443\u0435\u043c\u043e\u0433\u043e \u0434\u043b\u044f \u0441\u0440\u0430\u0432\u043d\u0435\u043d\u0438\u044f:\n+- \u0412 \u043f\u0435\u0440\u0432\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0435 \u0444\u0443\u043d\u043a\u0446\u0438\u044f `toDateTime()`, \u0441\u043e\u0437\u0434\u0430\u0432\u0430\u044f \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u0442\u0438\u043f\u0430 `DateTime`, \u043f\u0440\u0438\u043d\u0438\u043c\u0430\u0435\u0442 \u0432\u043e \u0432\u043d\u0438\u043c\u0430\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 `session_timezone` \u0438\u0437 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0430 \u0437\u0430\u043f\u0440\u043e\u0441\u0430;\n+- \u0412\u043e \u0432\u0442\u043e\u0440\u043e\u043c \u0437\u0430\u043f\u0440\u043e\u0441\u0435 `DateTime` \u0444\u043e\u0440\u043c\u0438\u0440\u0443\u0435\u0442\u0441\u044f \u0438\u0437 \u0441\u0442\u0440\u043e\u043a\u0438 \u043d\u0435\u044f\u0432\u043d\u043e, \u043d\u0430\u0441\u043b\u0435\u0434\u0443\u044f \u0442\u0438\u043f \u043a\u043e\u043b\u043e\u043d\u043a\u0438 `d` (\u0432 \u0442\u043e\u043c \u0447\u0438\u0441\u043b\u0435 \u0438 \u0447\u0438\u0441\u043b\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441), \u0438 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440 `session_timezone` \u0438\u0433\u043d\u043e\u0440\u0438\u0440\u0443\u0435\u0442\u0441\u044f.\n+\n+**\u0421\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0442\u0430\u043a\u0436\u0435**\n+\n+- [timezone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone)\n+\n ## rename_files_after_processing\n \n - **\u0422\u0438\u043f:** \u0421\u0442\u0440\u043e\u043a\u0430\ndiff --git a/docs/ru/sql-reference/functions/date-time-functions.md b/docs/ru/sql-reference/functions/date-time-functions.md\nindex 867d71d334c0..17ab04b7799e 100644\n--- a/docs/ru/sql-reference/functions/date-time-functions.md\n+++ b/docs/ru/sql-reference/functions/date-time-functions.md\n@@ -26,7 +26,8 @@ SELECT\n \n ## timeZone {#timezone}\n \n-\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430.\n+\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430, \u0441\u0447\u0438\u0442\u0430\u044e\u0449\u0438\u0439\u0441\u044f \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u0435\u043c \u0434\u043b\u044f \u0442\u0435\u043a\u0443\u0449\u0435\u0439 \u0441\u0435\u0441\u0441\u0438\u0438: \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 \u043f\u0430\u0440\u0430\u043c\u0435\u0442\u0440\u0430 [session_timezone](../../operations/settings/settings.md#session_timezone), \u0435\u0441\u043b\u0438 \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043e.\n+\n \u0415\u0441\u043b\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0432 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b, \u0442\u043e \u043e\u043d\u0430 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u043e\u0431\u044b\u0447\u043d\u044b\u0439 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u0441\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438, \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0448\u0430\u0440\u0434\u0430. \u0418\u043d\u0430\u0447\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430.\n \n **\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n@@ -43,6 +44,33 @@ timeZone()\n \n \u0422\u0438\u043f: [String](../../sql-reference/data-types/string.md).\n \n+**\u0421\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0442\u0430\u043a\u0436\u0435**\n+\n+- [serverTimeZone](#servertimezone)\n+\n+## serverTimeZone {#servertimezone}\n+\n+\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441 \u0441\u0435\u0440\u0432\u0435\u0440\u0430 \u043f\u043e \u0443\u043c\u043e\u043b\u0447\u0430\u043d\u0438\u044e, \u0432 \u0442.\u0447. \u0443\u0441\u0442\u0430\u043d\u043e\u0432\u043b\u0435\u043d\u043d\u044b\u0439 [timezone](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-timezone)\n+\u0415\u0441\u043b\u0438 \u0444\u0443\u043d\u043a\u0446\u0438\u044f \u0432\u044b\u0437\u044b\u0432\u0430\u0435\u0442\u0441\u044f \u0432 \u043a\u043e\u043d\u0442\u0435\u043a\u0441\u0442\u0435 \u0440\u0430\u0441\u043f\u0440\u0435\u0434\u0435\u043b\u0435\u043d\u043d\u043e\u0439 \u0442\u0430\u0431\u043b\u0438\u0446\u044b, \u0442\u043e \u043e\u043d\u0430 \u0433\u0435\u043d\u0435\u0440\u0438\u0440\u0443\u0435\u0442 \u043e\u0431\u044b\u0447\u043d\u044b\u0439 \u0441\u0442\u043e\u043b\u0431\u0435\u0446 \u0441\u043e \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u044f\u043c\u0438, \u0430\u043a\u0442\u0443\u0430\u043b\u044c\u043d\u044b\u043c\u0438 \u0434\u043b\u044f \u043a\u0430\u0436\u0434\u043e\u0433\u043e \u0448\u0430\u0440\u0434\u0430. \u0418\u043d\u0430\u0447\u0435 \u0432\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u0442\u0441\u044f \u043a\u043e\u043d\u0441\u0442\u0430\u043d\u0442\u0430.\n+\n+**\u0421\u0438\u043d\u0442\u0430\u043a\u0441\u0438\u0441**\n+\n+``` sql\n+serverTimeZone()\n+```\n+\n+\u0421\u0438\u043d\u043e\u043d\u0438\u043c\u044b: `serverTimezone`.\n+\n+**\u0412\u043e\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043c\u043e\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435**\n+\n+-   \u0427\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441.\n+\n+\u0422\u0438\u043f: [String](../../sql-reference/data-types/string.md).\n+\n+**\u0421\u043c\u043e\u0442\u0440\u0438\u0442\u0435 \u0442\u0430\u043a\u0436\u0435**\n+\n+- [timeZone](#timezone)\n+\n ## toTimeZone {#totimezone}\n \n \u041f\u0435\u0440\u0435\u0432\u043e\u0434\u0438\u0442 \u0434\u0430\u0442\u0443 \u0438\u043b\u0438 \u0434\u0430\u0442\u0443 \u0441 \u0432\u0440\u0435\u043c\u0435\u043d\u0435\u043c \u0432 \u0443\u043a\u0430\u0437\u0430\u043d\u043d\u044b\u0439 \u0447\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441. \u0427\u0430\u0441\u043e\u0432\u043e\u0439 \u043f\u043e\u044f\u0441 - \u044d\u0442\u043e \u0430\u0442\u0440\u0438\u0431\u0443\u0442 \u0442\u0438\u043f\u043e\u0432 `Date` \u0438 `DateTime`. \u0412\u043d\u0443\u0442\u0440\u0435\u043d\u043d\u0435\u0435 \u0437\u043d\u0430\u0447\u0435\u043d\u0438\u0435 (\u043a\u043e\u043b\u0438\u0447\u0435\u0441\u0442\u0432\u043e \u0441\u0435\u043a\u0443\u043d\u0434) \u043f\u043e\u043b\u044f \u0442\u0430\u0431\u043b\u0438\u0446\u044b \u0438\u043b\u0438 \u0440\u0435\u0437\u0443\u043b\u044c\u0442\u0438\u0440\u0443\u044e\u0449\u0435\u0433\u043e \u0441\u0442\u043e\u043b\u0431\u0446\u0430 \u043d\u0435 \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f, \u0438\u0437\u043c\u0435\u043d\u044f\u0435\u0442\u0441\u044f \u0442\u0438\u043f \u043f\u043e\u043b\u044f \u0438, \u0441\u043e\u043e\u0442\u0432\u0435\u0442\u0441\u0442\u0432\u0435\u043d\u043d\u043e, \u0435\u0433\u043e \u0442\u0435\u043a\u0441\u0442\u043e\u0432\u043e\u0435 \u043e\u0442\u043e\u0431\u0440\u0430\u0436\u0435\u043d\u0438\u0435.\ndiff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex 54b091700b2f..14516bfa9390 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -4,7 +4,9 @@\n #include <map>\n #include <iostream>\n #include <iomanip>\n+#include <memory>\n #include <optional>\n+#include <Common/ThreadStatus.h>\n #include <Common/scope_guard_safe.h>\n #include <boost/program_options.hpp>\n #include <boost/algorithm/string/replace.hpp>\n@@ -307,7 +309,7 @@ int Client::main(const std::vector<std::string> & /*args*/)\n try\n {\n     UseSSL use_ssl;\n-    MainThreadStatus::getInstance();\n+    auto & thread_status = MainThreadStatus::getInstance();\n     setupSignalHandler();\n \n     std::cout << std::fixed << std::setprecision(3);\n@@ -320,6 +322,14 @@ try\n     processConfig();\n     initTtyBuffer(toProgressOption(config().getString(\"progress\", \"default\")));\n \n+    {\n+        // All that just to set DB::CurrentThread::get().getGlobalContext()\n+        // which is required for client timezone (pushed from server) to work.\n+        auto thread_group = std::make_shared<ThreadGroup>();\n+        const_cast<ContextWeakPtr&>(thread_group->global_context) = global_context;\n+        thread_status.attachToGroup(thread_group, false);\n+    }\n+\n     /// Includes delayed_interactive.\n     if (is_interactive)\n     {\ndiff --git a/programs/copier/ClusterCopierApp.cpp b/programs/copier/ClusterCopierApp.cpp\nindex 822289dd89c2..64071423b8e2 100644\n--- a/programs/copier/ClusterCopierApp.cpp\n+++ b/programs/copier/ClusterCopierApp.cpp\n@@ -44,7 +44,7 @@ void ClusterCopierApp::initialize(Poco::Util::Application & self)\n     time_t timestamp = Poco::Timestamp().epochTime();\n     auto curr_pid = Poco::Process::id();\n \n-    process_id = std::to_string(DateLUT::instance().toNumYYYYMMDDhhmmss(timestamp)) + \"_\" + std::to_string(curr_pid);\n+    process_id = std::to_string(DateLUT::serverTimezoneInstance().toNumYYYYMMDDhhmmss(timestamp)) + \"_\" + std::to_string(curr_pid);\n     host_id = escapeForFileName(getFQDNOrHostName()) + '#' + process_id;\n     process_path = fs::weakly_canonical(fs::path(base_dir) / (\"clickhouse-copier_\" + process_id));\n     fs::create_directories(process_path);\ndiff --git a/programs/keeper/Keeper.cpp b/programs/keeper/Keeper.cpp\nindex 57760b5ebbfa..a18256651888 100644\n--- a/programs/keeper/Keeper.cpp\n+++ b/programs/keeper/Keeper.cpp\n@@ -306,8 +306,8 @@ try\n \n     /// Initialize DateLUT early, to not interfere with running time of first query.\n     LOG_DEBUG(log, \"Initializing DateLUT.\");\n-    DateLUT::instance();\n-    LOG_TRACE(log, \"Initialized DateLUT with time zone '{}'.\", DateLUT::instance().getTimeZone());\n+    DateLUT::serverTimezoneInstance();\n+    LOG_TRACE(log, \"Initialized DateLUT with time zone '{}'.\", DateLUT::serverTimezoneInstance().getTimeZone());\n \n     /// Don't want to use DNS cache\n     DNSResolver::instance().setDisableCacheFlag();\ndiff --git a/programs/obfuscator/Obfuscator.cpp b/programs/obfuscator/Obfuscator.cpp\nindex add16ec5205e..3042ae2bb577 100644\n--- a/programs/obfuscator/Obfuscator.cpp\n+++ b/programs/obfuscator/Obfuscator.cpp\n@@ -491,7 +491,7 @@ class DateTimeModel : public IModel\n     const DateLUTImpl & date_lut;\n \n public:\n-    explicit DateTimeModel(UInt64 seed_) : seed(seed_), date_lut(DateLUT::instance()) {}\n+    explicit DateTimeModel(UInt64 seed_) : seed(seed_), date_lut(DateLUT::serverTimezoneInstance()) {}\n \n     void train(const IColumn &) override {}\n     void finalize() override {}\ndiff --git a/programs/server/Server.cpp b/programs/server/Server.cpp\nindex cfef7f0a94a2..d2d8a0d07fb7 100644\n--- a/programs/server/Server.cpp\n+++ b/programs/server/Server.cpp\n@@ -960,8 +960,8 @@ try\n \n     /// Initialize DateLUT early, to not interfere with running time of first query.\n     LOG_DEBUG(log, \"Initializing DateLUT.\");\n-    DateLUT::instance();\n-    LOG_TRACE(log, \"Initialized DateLUT with time zone '{}'.\", DateLUT::instance().getTimeZone());\n+    DateLUT::serverTimezoneInstance();\n+    LOG_TRACE(log, \"Initialized DateLUT with time zone '{}'.\", DateLUT::serverTimezoneInstance().getTimeZone());\n \n     /// Storage with temporary data for processing of heavy queries.\n     if (!server_settings.tmp_policy.value.empty())\ndiff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp\nindex badee99d8559..479db03c883d 100644\n--- a/src/Client/ClientBase.cpp\n+++ b/src/Client/ClientBase.cpp\n@@ -77,7 +77,6 @@\n #include \"config_version.h\"\n #include \"config.h\"\n \n-\n namespace fs = std::filesystem;\n using namespace std::literals;\n \n@@ -896,7 +895,6 @@ void ClientBase::processOrdinaryQuery(const String & query_to_execute, ASTPtr pa\n \n             if (send_external_tables)\n                 sendExternalTables(parsed_query);\n-\n             receiveResult(parsed_query, signals_before_stop, settings.partial_result_on_first_cancel);\n \n             break;\n@@ -1048,6 +1046,10 @@ bool ClientBase::receiveAndProcessPacket(ASTPtr parsed_query, bool cancelled_)\n             onProfileEvents(packet.block);\n             return true;\n \n+        case Protocol::Server::TimezoneUpdate:\n+            onTimezoneUpdate(packet.server_timezone);\n+            return true;\n+\n         default:\n             throw Exception(\n                 ErrorCodes::UNKNOWN_PACKET_FROM_SERVER, \"Unknown packet {} from server {}\", packet.type, connection->getDescription());\n@@ -1070,6 +1072,11 @@ void ClientBase::onProgress(const Progress & value)\n         progress_indication.writeProgress(*tty_buf);\n }\n \n+void ClientBase::onTimezoneUpdate(const String & tz)\n+{\n+    global_context->setSetting(\"session_timezone\", tz);\n+}\n+\n \n void ClientBase::onEndOfStream()\n {\n@@ -1221,9 +1228,13 @@ bool ClientBase::receiveSampleBlock(Block & out, ColumnsDescription & columns_de\n                 columns_description = ColumnsDescription::parse(packet.multistring_message[1]);\n                 return receiveSampleBlock(out, columns_description, parsed_query);\n \n+            case Protocol::Server::TimezoneUpdate:\n+                onTimezoneUpdate(packet.server_timezone);\n+                break;\n+\n             default:\n                 throw NetException(ErrorCodes::UNEXPECTED_PACKET_FROM_SERVER,\n-                    \"Unexpected packet from server (expected Data, Exception or Log, got {})\",\n+                    \"Unexpected packet from server (expected Data, Exception, Log or TimezoneUpdate, got {})\",\n                     String(Protocol::Server::toString(packet.type)));\n         }\n     }\n@@ -1538,7 +1549,9 @@ void ClientBase::receiveLogsAndProfileEvents(ASTPtr parsed_query)\n {\n     auto packet_type = connection->checkPacket(0);\n \n-    while (packet_type && (*packet_type == Protocol::Server::Log || *packet_type == Protocol::Server::ProfileEvents))\n+    while (packet_type && (*packet_type == Protocol::Server::Log\n+            || *packet_type == Protocol::Server::ProfileEvents\n+            || *packet_type == Protocol::Server::TimezoneUpdate))\n     {\n         receiveAndProcessPacket(parsed_query, false);\n         packet_type = connection->checkPacket(0);\n@@ -1575,6 +1588,10 @@ bool ClientBase::receiveEndOfQuery()\n                 onProfileEvents(packet.block);\n                 break;\n \n+            case Protocol::Server::TimezoneUpdate:\n+                onTimezoneUpdate(packet.server_timezone);\n+                break;\n+\n             default:\n                 throw NetException(ErrorCodes::UNEXPECTED_PACKET_FROM_SERVER,\n                     \"Unexpected packet from server (expected Exception, EndOfStream, Log, Progress or ProfileEvents. Got {})\",\ndiff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h\nindex ee4567a09223..bd17318d1dff 100644\n--- a/src/Client/ClientBase.h\n+++ b/src/Client/ClientBase.h\n@@ -148,6 +148,7 @@ class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>\n     void cancelQuery();\n \n     void onProgress(const Progress & value);\n+    void onTimezoneUpdate(const String & tz);\n     void onData(Block & block, ASTPtr parsed_query);\n     void onLogData(Block & block);\n     void onTotals(Block & block, ASTPtr parsed_query);\ndiff --git a/src/Client/Connection.cpp b/src/Client/Connection.cpp\nindex 636532ade4b6..be226bfd9dd9 100644\n--- a/src/Client/Connection.cpp\n+++ b/src/Client/Connection.cpp\n@@ -1022,6 +1022,11 @@ Packet Connection::receivePacket()\n                 res.block = receiveProfileEvents();\n                 return res;\n \n+            case Protocol::Server::TimezoneUpdate:\n+                readStringBinary(server_timezone, *in);\n+                res.server_timezone = server_timezone;\n+                return res;\n+\n             default:\n                 /// In unknown state, disconnect - to not leave unsynchronised connection.\n                 disconnect();\ndiff --git a/src/Client/HedgedConnections.cpp b/src/Client/HedgedConnections.cpp\nindex f8966847e5ab..fb6fe258d486 100644\n--- a/src/Client/HedgedConnections.cpp\n+++ b/src/Client/HedgedConnections.cpp\n@@ -419,6 +419,7 @@ Packet HedgedConnections::receivePacketFromReplica(const ReplicaLocation & repli\n             }\n             replica_with_last_received_packet = replica_location;\n             break;\n+        case Protocol::Server::TimezoneUpdate:\n         case Protocol::Server::PartUUIDs:\n         case Protocol::Server::ProfileInfo:\n         case Protocol::Server::Totals:\ndiff --git a/src/Client/IServerConnection.h b/src/Client/IServerConnection.h\nindex cd4db8f5258f..52382ff9d454 100644\n--- a/src/Client/IServerConnection.h\n+++ b/src/Client/IServerConnection.h\n@@ -38,6 +38,8 @@ struct Packet\n     ParallelReadRequest request;\n     ParallelReadResponse response;\n \n+    std::string server_timezone;\n+\n     Packet() : type(Protocol::Server::Hello) {}\n };\n \ndiff --git a/src/Client/MultiplexedConnections.cpp b/src/Client/MultiplexedConnections.cpp\nindex 71f536b96877..e5c4a19e02a3 100644\n--- a/src/Client/MultiplexedConnections.cpp\n+++ b/src/Client/MultiplexedConnections.cpp\n@@ -259,6 +259,7 @@ Packet MultiplexedConnections::drain()\n \n         switch (packet.type)\n         {\n+            case Protocol::Server::TimezoneUpdate:\n             case Protocol::Server::MergeTreeAllRangesAnnounecement:\n             case Protocol::Server::MergeTreeReadTaskRequest:\n             case Protocol::Server::ReadTaskRequest:\n@@ -340,6 +341,7 @@ Packet MultiplexedConnections::receivePacketUnlocked(AsyncCallback async_callbac\n \n     switch (packet.type)\n     {\n+        case Protocol::Server::TimezoneUpdate:\n         case Protocol::Server::MergeTreeAllRangesAnnounecement:\n         case Protocol::Server::MergeTreeReadTaskRequest:\n         case Protocol::Server::ReadTaskRequest:\ndiff --git a/src/Client/Suggest.cpp b/src/Client/Suggest.cpp\nindex 4e38add0ef5f..3d07080bb281 100644\n--- a/src/Client/Suggest.cpp\n+++ b/src/Client/Suggest.cpp\n@@ -160,6 +160,7 @@ void Suggest::fetch(IServerConnection & connection, const ConnectionTimeouts & t\n                 fillWordsFromBlock(packet.block);\n                 continue;\n \n+            case Protocol::Server::TimezoneUpdate:\n             case Protocol::Server::Progress:\n             case Protocol::Server::ProfileInfo:\n             case Protocol::Server::Totals:\ndiff --git a/src/Common/DateLUT.cpp b/src/Common/DateLUT.cpp\nindex a31ece00c0b9..2b261a28469d 100644\n--- a/src/Common/DateLUT.cpp\n+++ b/src/Common/DateLUT.cpp\n@@ -7,6 +7,7 @@\n \n #include <filesystem>\n #include <fstream>\n+#include <Interpreters/Context.h>\n \n \n namespace\n@@ -163,3 +164,8 @@ DateLUT & DateLUT::getInstance()\n     static DateLUT ret;\n     return ret;\n }\n+\n+std::string DateLUT::extractTimezoneFromContext(DB::ContextPtr query_context)\n+{\n+    return query_context->getSettingsRef().session_timezone.value;\n+}\ndiff --git a/src/Common/DateLUT.h b/src/Common/DateLUT.h\nindex fe259f0f3c37..2045d4895e71 100644\n--- a/src/Common/DateLUT.h\n+++ b/src/Common/DateLUT.h\n@@ -5,6 +5,7 @@\n #include <base/defines.h>\n \n #include <boost/noncopyable.hpp>\n+#include \"Common/CurrentThread.h\"\n \n #include <atomic>\n #include <memory>\n@@ -16,22 +17,59 @@\n class DateLUT : private boost::noncopyable\n {\n public:\n-    /// Return singleton DateLUTImpl instance for the default time zone.\n+    /// Return DateLUTImpl instance for session timezone.\n+    /// session_timezone is a session-level setting.\n+    /// If setting is not set, returns the server timezone.\n     static ALWAYS_INLINE const DateLUTImpl & instance()\n     {\n         const auto & date_lut = getInstance();\n-        return *date_lut.default_impl.load(std::memory_order_acquire);\n+\n+        if (DB::CurrentThread::isInitialized())\n+        {\n+            std::string timezone_from_context;\n+            const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();\n+\n+            if (query_context)\n+            {\n+                timezone_from_context = extractTimezoneFromContext(query_context);\n+\n+                if (!timezone_from_context.empty())\n+                    return date_lut.getImplementation(timezone_from_context);\n+            }\n+\n+            /// On the server side, timezone is passed in query_context,\n+            /// but on CH-client side we have no query context,\n+            /// and each time we modify client's global context\n+            const DB::ContextPtr global_context = DB::CurrentThread::get().getGlobalContext();\n+            if (global_context)\n+            {\n+                timezone_from_context = extractTimezoneFromContext(global_context);\n+\n+                if (!timezone_from_context.empty())\n+                    return date_lut.getImplementation(timezone_from_context);\n+            }\n+\n+        }\n+        return serverTimezoneInstance();\n     }\n \n-    /// Return singleton DateLUTImpl instance for a given time zone.\n     static ALWAYS_INLINE const DateLUTImpl & instance(const std::string & time_zone)\n     {\n-        const auto & date_lut = getInstance();\n         if (time_zone.empty())\n-            return *date_lut.default_impl.load(std::memory_order_acquire);\n+            return instance();\n \n+        const auto & date_lut = getInstance();\n         return date_lut.getImplementation(time_zone);\n     }\n+\n+    /// Return singleton DateLUTImpl for the server time zone.\n+    /// It may be set using 'timezone' server setting.\n+    static ALWAYS_INLINE const DateLUTImpl & serverTimezoneInstance()\n+    {\n+        const auto & date_lut = getInstance();\n+        return *date_lut.default_impl.load(std::memory_order_acquire);\n+    }\n+\n     static void setDefaultTimezone(const std::string & time_zone)\n     {\n         auto & date_lut = getInstance();\n@@ -45,6 +83,8 @@ class DateLUT : private boost::noncopyable\n private:\n     static DateLUT & getInstance();\n \n+    static std::string extractTimezoneFromContext(DB::ContextPtr query_context);\n+\n     const DateLUTImpl & getImplementation(const std::string & time_zone) const;\n \n     using DateLUTImplPtr = std::unique_ptr<DateLUTImpl>;\ndiff --git a/src/Common/LocalDate.h b/src/Common/LocalDate.h\nindex dc36f92bebf2..2331a40fd124 100644\n--- a/src/Common/LocalDate.h\n+++ b/src/Common/LocalDate.h\n@@ -24,9 +24,8 @@ class LocalDate\n     unsigned char m_month;\n     unsigned char m_day;\n \n-    void init(time_t time)\n+    void init(time_t time, const DateLUTImpl & date_lut)\n     {\n-        const auto & date_lut = DateLUT::instance();\n         const auto & values = date_lut.getValues(time);\n \n         m_year = values.year;\n@@ -56,22 +55,22 @@ class LocalDate\n     }\n \n public:\n-    explicit LocalDate(time_t time)\n+    explicit LocalDate(time_t time, const DateLUTImpl & time_zone = DateLUT::instance())\n     {\n-        init(time);\n+        init(time, time_zone);\n     }\n \n-    LocalDate(DayNum day_num) /// NOLINT\n+    LocalDate(DayNum day_num, const DateLUTImpl & time_zone = DateLUT::instance()) /// NOLINT\n     {\n-        const auto & values = DateLUT::instance().getValues(day_num);\n+        const auto & values = time_zone.getValues(day_num);\n         m_year  = values.year;\n         m_month = values.month;\n         m_day   = values.day_of_month;\n     }\n \n-    explicit LocalDate(ExtendedDayNum day_num)\n+    explicit LocalDate(ExtendedDayNum day_num, const DateLUTImpl & time_zone = DateLUT::instance())\n     {\n-        const auto & values = DateLUT::instance().getValues(day_num);\n+        const auto & values = time_zone.getValues(day_num);\n         m_year  = values.year;\n         m_month = values.month;\n         m_day   = values.day_of_month;\n@@ -99,15 +98,13 @@ class LocalDate\n     LocalDate(const LocalDate &) noexcept = default;\n     LocalDate & operator= (const LocalDate &) noexcept = default;\n \n-    DayNum getDayNum() const\n+    DayNum getDayNum(const DateLUTImpl & lut = DateLUT::instance()) const\n     {\n-        const auto & lut = DateLUT::instance();\n         return DayNum(lut.makeDayNum(m_year, m_month, m_day).toUnderType());\n     }\n \n-    ExtendedDayNum  getExtenedDayNum() const\n+    ExtendedDayNum getExtenedDayNum(const DateLUTImpl & lut = DateLUT::instance()) const\n     {\n-        const auto & lut = DateLUT::instance();\n         return ExtendedDayNum (lut.makeDayNum(m_year, m_month, m_day).toUnderType());\n     }\n \ndiff --git a/src/Core/Protocol.h b/src/Core/Protocol.h\nindex 86c0a851c60f..97a2831ffe8f 100644\n--- a/src/Core/Protocol.h\n+++ b/src/Core/Protocol.h\n@@ -83,7 +83,8 @@ namespace Protocol\n             ProfileEvents = 14,             /// Packet with profile events from server.\n             MergeTreeAllRangesAnnounecement = 15,\n             MergeTreeReadTaskRequest = 16,  /// Request from a MergeTree replica to a coordinator\n-            MAX = MergeTreeReadTaskRequest,\n+            TimezoneUpdate = 17,            /// Receive server's (session-wide) default timezone\n+            MAX = TimezoneUpdate,\n \n         };\n \n@@ -111,6 +112,7 @@ namespace Protocol\n                 \"ProfileEvents\",\n                 \"MergeTreeAllRangesAnnounecement\",\n                 \"MergeTreeReadTaskRequest\",\n+                \"TimezoneUpdate\",\n             };\n             return packet <= MAX\n                 ? data[packet]\ndiff --git a/src/Core/ProtocolDefines.h b/src/Core/ProtocolDefines.h\nindex 237ef9340818..dbe13d9502a1 100644\n--- a/src/Core/ProtocolDefines.h\n+++ b/src/Core/ProtocolDefines.h\n@@ -53,7 +53,7 @@\n /// NOTE: DBMS_TCP_PROTOCOL_VERSION has nothing common with VERSION_REVISION,\n /// later is just a number for server version (one number instead of commit SHA)\n /// for simplicity (sometimes it may be more convenient in some use cases).\n-#define DBMS_TCP_PROTOCOL_VERSION 54463\n+#define DBMS_TCP_PROTOCOL_VERSION 54464\n \n #define DBMS_MIN_PROTOCOL_VERSION_WITH_INITIAL_QUERY_START_TIME 54449\n \n@@ -75,3 +75,5 @@\n #define DBMS_MIN_REVISION_WITH_INTERSERVER_SECRET_V2 54462\n \n #define DBMS_MIN_PROTOCOL_VERSION_WITH_TOTAL_BYTES_IN_PROGRESS 54463\n+\n+#define DBMS_MIN_PROTOCOL_VERSION_WITH_TIMEZONE_UPDATES 54464\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex fbb6528e643c..3d42bd582ed4 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -770,6 +770,7 @@ class IColumn;\n     M(Bool, allow_experimental_undrop_table_query, false, \"Allow to use undrop query to restore dropped table in a limited time\", 0) \\\n     M(Bool, keeper_map_strict_mode, false, \"Enforce additional checks during operations on KeeperMap. E.g. throw an exception on an insert for already existing key\", 0) \\\n     M(UInt64, extract_kvp_max_pairs_per_row, 1000, \"Max number pairs that can be produced by extractKeyValuePairs function. Used to safeguard against consuming too much memory.\", 0) \\\n+    M(Timezone, session_timezone, \"\", \"The default timezone for current session or query. The server default timezone if empty.\", 0) \\\n     // End of COMMON_SETTINGS\n     // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS and move obsolete settings to OBSOLETE_SETTINGS.\n \ndiff --git a/src/Core/SettingsFields.cpp b/src/Core/SettingsFields.cpp\nindex 8cd4efb68c67..a0f643f8d302 100644\n--- a/src/Core/SettingsFields.cpp\n+++ b/src/Core/SettingsFields.cpp\n@@ -13,7 +13,6 @@\n \n #include <cmath>\n \n-\n namespace DB\n {\n namespace ErrorCodes\n@@ -451,6 +450,17 @@ String SettingFieldEnumHelpers::readBinary(ReadBuffer & in)\n     return str;\n }\n \n+void SettingFieldTimezone::writeBinary(WriteBuffer & out) const\n+{\n+    writeStringBinary(value, out);\n+}\n+\n+void SettingFieldTimezone::readBinary(ReadBuffer & in)\n+{\n+    String str;\n+    readStringBinary(str, in);\n+    *this = std::move(str);\n+}\n \n String SettingFieldCustom::toString() const\n {\ndiff --git a/src/Core/SettingsFields.h b/src/Core/SettingsFields.h\nindex 686638d497f0..786492a72567 100644\n--- a/src/Core/SettingsFields.h\n+++ b/src/Core/SettingsFields.h\n@@ -6,6 +6,7 @@\n #include <Core/Field.h>\n #include <Core/MultiEnum.h>\n #include <boost/range/adaptor/map.hpp>\n+#include <cctz/time_zone.h>\n #include <chrono>\n #include <unordered_map>\n #include <string_view>\n@@ -565,6 +566,42 @@ void SettingFieldMultiEnum<EnumT, Traits>::readBinary(ReadBuffer & in)\n         return getEnumValues<EnumType>().size();\\\n     }\n \n+/// Setting field for specifying user-defined timezone. It is basically a string, but it needs validation.\n+struct SettingFieldTimezone\n+{\n+    String value;\n+    bool changed = false;\n+\n+    explicit SettingFieldTimezone(std::string_view str = {}) { validateTimezone(std::string(str)); value = str; }\n+    explicit SettingFieldTimezone(const String & str) { validateTimezone(str); value = str; }\n+    explicit SettingFieldTimezone(String && str) { validateTimezone(str); value = std::move(str); }\n+    explicit SettingFieldTimezone(const char * str) { validateTimezone(str); value = str; }\n+    explicit SettingFieldTimezone(const Field & f) { const String & str = f.safeGet<const String &>(); validateTimezone(str); value = str; }\n+\n+    SettingFieldTimezone & operator =(std::string_view str) { validateTimezone(std::string(str)); value = str; changed = true; return *this; }\n+    SettingFieldTimezone & operator =(const String & str) { *this = std::string_view{str}; return *this; }\n+    SettingFieldTimezone & operator =(String && str) { validateTimezone(str); value = std::move(str); changed = true; return *this; }\n+    SettingFieldTimezone & operator =(const char * str) { *this = std::string_view{str}; return *this; }\n+    SettingFieldTimezone & operator =(const Field & f) { *this = f.safeGet<const String &>(); return *this; }\n+\n+    operator const String &() const { return value; } /// NOLINT\n+    explicit operator Field() const { return value; }\n+\n+    const String & toString() const { return value; }\n+    void parseFromString(const String & str) { *this = str; }\n+\n+    void writeBinary(WriteBuffer & out) const;\n+    void readBinary(ReadBuffer & in);\n+\n+private:\n+    void validateTimezone(const std::string & tz_str)\n+    {\n+        cctz::time_zone validated_tz;\n+        if (!tz_str.empty() && !cctz::load_time_zone(tz_str, &validated_tz))\n+            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, \"Invalid time zone: {}\", tz_str);\n+    }\n+};\n+\n /// Can keep a value of any type. Used for user-defined settings.\n struct SettingFieldCustom\n {\ndiff --git a/src/Daemon/BaseDaemon.cpp b/src/Daemon/BaseDaemon.cpp\nindex bfd5568b71d9..f08231b6f32a 100644\n--- a/src/Daemon/BaseDaemon.cpp\n+++ b/src/Daemon/BaseDaemon.cpp\n@@ -1042,7 +1042,7 @@ void BaseDaemon::shouldSetupWatchdog(char * argv0_)\n void BaseDaemon::setupWatchdog()\n {\n     /// Initialize in advance to avoid double initialization in forked processes.\n-    DateLUT::instance();\n+    DateLUT::serverTimezoneInstance();\n \n     std::string original_process_name;\n     if (argv0)\ndiff --git a/src/DataTypes/DataTypeDateTime.h b/src/DataTypes/DataTypeDateTime.h\nindex edc8b016490c..a473aae1faf5 100644\n--- a/src/DataTypes/DataTypeDateTime.h\n+++ b/src/DataTypes/DataTypeDateTime.h\n@@ -21,7 +21,9 @@ namespace DB\n   *  all types with different time zones are equivalent and may be used interchangingly.\n   * Time zone only affects parsing and displaying in text formats.\n   *\n-  * If time zone is not specified (example: DateTime without parameter), then default time zone is used.\n+  * If time zone is not specified (example: DateTime without parameter),\n+  * then `session_timezone` setting value is used.\n+  * If `session_timezone` is not set (or empty string), server default time zone is used.\n   * Default time zone is server time zone, if server is doing transformations\n   *  and if client is doing transformations, unless 'use_client_time_zone' setting is passed to client;\n   * Server time zone is the time zone specified in 'timezone' parameter in configuration file,\ndiff --git a/src/DataTypes/Serializations/SerializationDate.cpp b/src/DataTypes/Serializations/SerializationDate.cpp\nindex 678817017e0b..1ed48fdd31da 100644\n--- a/src/DataTypes/Serializations/SerializationDate.cpp\n+++ b/src/DataTypes/Serializations/SerializationDate.cpp\n@@ -13,7 +13,7 @@ namespace DB\n \n void SerializationDate::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const\n {\n-    writeDateText(DayNum(assert_cast<const ColumnUInt16 &>(column).getData()[row_num]), ostr);\n+    writeDateText(DayNum(assert_cast<const ColumnUInt16 &>(column).getData()[row_num]), ostr, time_zone);\n }\n \n void SerializationDate::deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n@@ -26,7 +26,7 @@ void SerializationDate::deserializeWholeText(IColumn & column, ReadBuffer & istr\n void SerializationDate::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n     DayNum x;\n-    readDateText(x, istr);\n+    readDateText(x, istr, time_zone);\n     assert_cast<ColumnUInt16 &>(column).getData().push_back(x);\n }\n \n@@ -46,7 +46,7 @@ void SerializationDate::deserializeTextQuoted(IColumn & column, ReadBuffer & ist\n {\n     DayNum x;\n     assertChar('\\'', istr);\n-    readDateText(x, istr);\n+    readDateText(x, istr, time_zone);\n     assertChar('\\'', istr);\n     assert_cast<ColumnUInt16 &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.\n }\n@@ -62,7 +62,7 @@ void SerializationDate::deserializeTextJSON(IColumn & column, ReadBuffer & istr,\n {\n     DayNum x;\n     assertChar('\"', istr);\n-    readDateText(x, istr);\n+    readDateText(x, istr, time_zone);\n     assertChar('\"', istr);\n     assert_cast<ColumnUInt16 &>(column).getData().push_back(x);\n }\n@@ -77,8 +77,12 @@ void SerializationDate::serializeTextCSV(const IColumn & column, size_t row_num,\n void SerializationDate::deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n     DayNum value;\n-    readCSV(value, istr);\n+    readCSV(value, istr, time_zone);\n     assert_cast<ColumnUInt16 &>(column).getData().push_back(value);\n }\n \n+SerializationDate::SerializationDate(const DateLUTImpl & time_zone_) : time_zone(time_zone_)\n+{\n+}\n+\n }\ndiff --git a/src/DataTypes/Serializations/SerializationDate.h b/src/DataTypes/Serializations/SerializationDate.h\nindex 099d7444c3d9..f751b06fba66 100644\n--- a/src/DataTypes/Serializations/SerializationDate.h\n+++ b/src/DataTypes/Serializations/SerializationDate.h\n@@ -1,6 +1,7 @@\n #pragma once\n \n #include <DataTypes/Serializations/SerializationNumber.h>\n+#include <Common/DateLUT.h>\n \n namespace DB\n {\n@@ -8,6 +9,8 @@ namespace DB\n class SerializationDate final : public SerializationNumber<UInt16>\n {\n public:\n+    explicit SerializationDate(const DateLUTImpl & time_zone_ = DateLUT::instance());\n+\n     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n@@ -18,6 +21,9 @@ class SerializationDate final : public SerializationNumber<UInt16>\n     void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override;\n+\n+protected:\n+    const DateLUTImpl & time_zone;\n };\n \n }\ndiff --git a/src/DataTypes/Serializations/SerializationDate32.cpp b/src/DataTypes/Serializations/SerializationDate32.cpp\nindex ef92202f89d2..851710de8392 100644\n--- a/src/DataTypes/Serializations/SerializationDate32.cpp\n+++ b/src/DataTypes/Serializations/SerializationDate32.cpp\n@@ -11,7 +11,7 @@ namespace DB\n \n void SerializationDate32::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const\n {\n-    writeDateText(ExtendedDayNum(assert_cast<const ColumnInt32 &>(column).getData()[row_num]), ostr);\n+    writeDateText(ExtendedDayNum(assert_cast<const ColumnInt32 &>(column).getData()[row_num]), ostr, time_zone);\n }\n \n void SerializationDate32::deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n@@ -24,7 +24,7 @@ void SerializationDate32::deserializeWholeText(IColumn & column, ReadBuffer & is\n void SerializationDate32::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n     ExtendedDayNum x;\n-    readDateText(x, istr);\n+    readDateText(x, istr, time_zone);\n     assert_cast<ColumnInt32 &>(column).getData().push_back(x);\n }\n \n@@ -44,7 +44,7 @@ void SerializationDate32::deserializeTextQuoted(IColumn & column, ReadBuffer & i\n {\n     ExtendedDayNum x;\n     assertChar('\\'', istr);\n-    readDateText(x, istr);\n+    readDateText(x, istr, time_zone);\n     assertChar('\\'', istr);\n     assert_cast<ColumnInt32 &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.\n }\n@@ -60,7 +60,7 @@ void SerializationDate32::deserializeTextJSON(IColumn & column, ReadBuffer & ist\n {\n     ExtendedDayNum x;\n     assertChar('\"', istr);\n-    readDateText(x, istr);\n+    readDateText(x, istr, time_zone);\n     assertChar('\"', istr);\n     assert_cast<ColumnInt32 &>(column).getData().push_back(x);\n }\n@@ -78,4 +78,8 @@ void SerializationDate32::deserializeTextCSV(IColumn & column, ReadBuffer & istr\n     readCSV(value, istr);\n     assert_cast<ColumnInt32 &>(column).getData().push_back(value.getExtenedDayNum());\n }\n+\n+SerializationDate32::SerializationDate32(const DateLUTImpl & time_zone_) : time_zone(time_zone_)\n+{\n+}\n }\ndiff --git a/src/DataTypes/Serializations/SerializationDate32.h b/src/DataTypes/Serializations/SerializationDate32.h\nindex 484b4f4a9582..49560fb6c7d3 100644\n--- a/src/DataTypes/Serializations/SerializationDate32.h\n+++ b/src/DataTypes/Serializations/SerializationDate32.h\n@@ -1,12 +1,15 @@\n #pragma once\n \n #include <DataTypes/Serializations/SerializationNumber.h>\n+#include <Common/DateLUT.h>\n \n namespace DB\n {\n class SerializationDate32 final : public SerializationNumber<Int32>\n {\n public:\n+    explicit SerializationDate32(const DateLUTImpl & time_zone_ = DateLUT::instance());\n+\n     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n@@ -17,5 +20,8 @@ class SerializationDate32 final : public SerializationNumber<Int32>\n     void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override;\n+\n+protected:\n+    const DateLUTImpl & time_zone;\n };\n }\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 7a48f7bc914c..023f1ab5425a 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -434,7 +434,7 @@ struct ToDate32Transform32Or64Signed\n \n     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)\n     {\n-        static const Int32 daynum_min_offset = -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch());\n+        static const Int32 daynum_min_offset = -static_cast<Int32>(time_zone.getDayNumOffsetEpoch());\n         if (from < daynum_min_offset)\n             return daynum_min_offset;\n         return (from < DATE_LUT_MAX_EXTEND_DAY_NUM)\n@@ -713,9 +713,9 @@ template <>\n struct FormatImpl<DataTypeDate>\n {\n     template <typename ReturnType = void>\n-    static ReturnType execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl *)\n+    static ReturnType execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl * time_zone)\n     {\n-        writeDateText(DayNum(x), wb);\n+        writeDateText(DayNum(x), wb, *time_zone);\n         return ReturnType(true);\n     }\n };\n@@ -724,9 +724,9 @@ template <>\n struct FormatImpl<DataTypeDate32>\n {\n     template <typename ReturnType = void>\n-    static ReturnType execute(const DataTypeDate32::FieldType x, WriteBuffer & wb, const DataTypeDate32 *, const DateLUTImpl *)\n+    static ReturnType execute(const DataTypeDate32::FieldType x, WriteBuffer & wb, const DataTypeDate32 *, const DateLUTImpl * time_zone)\n     {\n-        writeDateText(ExtendedDayNum(x), wb);\n+        writeDateText(ExtendedDayNum(x), wb, *time_zone);\n         return ReturnType(true);\n     }\n };\n@@ -825,7 +825,10 @@ struct ConvertImpl<FromDataType, DataTypeString, Name, ConvertDefaultBehaviorTag\n         const auto & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);\n \n         const DateLUTImpl * time_zone = nullptr;\n-        /// For argument of DateTime type, second argument with time zone could be specified.\n+\n+        if constexpr (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>)\n+            time_zone = &DateLUT::instance();\n+        /// For argument of Date or DateTime type, second argument with time zone could be specified.\n         if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDateTime64>)\n         {\n             auto non_null_args = createBlockWithNestedColumns(arguments);\n@@ -976,18 +979,18 @@ void parseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTI\n }\n \n template <>\n-inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n {\n     DayNum tmp(0);\n-    readDateText(tmp, rb);\n+    readDateText(tmp, rb, *time_zone);\n     x = tmp;\n }\n \n template <>\n-inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n {\n     ExtendedDayNum tmp(0);\n-    readDateText(tmp, rb);\n+    readDateText(tmp, rb, *time_zone);\n     x = tmp;\n }\n \n@@ -1035,20 +1038,20 @@ bool tryParseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateL\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n {\n     DayNum tmp(0);\n-    if (!tryReadDateText(tmp, rb))\n+    if (!tryReadDateText(tmp, rb, *time_zone))\n         return false;\n     x = tmp;\n     return true;\n }\n \n template <>\n-inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)\n+inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)\n {\n     ExtendedDayNum tmp(0);\n-    if (!tryReadDateText(tmp, rb))\n+    if (!tryReadDateText(tmp, rb, *time_zone))\n         return false;\n     x = tmp;\n     return true;\n@@ -1188,7 +1191,7 @@ struct ConvertThroughParsing\n         const DateLUTImpl * local_time_zone [[maybe_unused]] = nullptr;\n         const DateLUTImpl * utc_time_zone [[maybe_unused]] = nullptr;\n \n-        /// For conversion to DateTime type, second argument with time zone could be specified.\n+        /// For conversion to Date or DateTime type, second argument with time zone could be specified.\n         if constexpr (std::is_same_v<ToDataType, DataTypeDateTime> || to_datetime64)\n         {\n             const auto result_type = removeNullable(res_type);\n@@ -1201,6 +1204,12 @@ struct ConvertThroughParsing\n             if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort || parsing_mode == ConvertFromStringParsingMode::BestEffortUS)\n                 utc_time_zone = &DateLUT::instance(\"UTC\");\n         }\n+        else if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)\n+        {\n+            // Timezone is more or less dummy when parsing Date/Date32 from string.\n+            local_time_zone = &DateLUT::instance();\n+            utc_time_zone = &DateLUT::instance(\"UTC\");\n+        }\n \n         const IColumn * col_from = arguments[0].column.get();\n         const ColumnString * col_from_string = checkAndGetColumn<ColumnString>(col_from);\n@@ -1751,7 +1760,7 @@ class FunctionConvert : public IFunction\n             || std::is_same_v<Name, NameToUnixTimestamp>\n             // toDate(value[, timezone : String])\n             || std::is_same_v<ToDataType, DataTypeDate> // TODO: shall we allow timestamp argument for toDate? DateTime knows nothing about timezones and this argument is ignored below.\n-            // toDate(value[, timezone : String])\n+            // toDate32(value[, timezone : String])\n             || std::is_same_v<ToDataType, DataTypeDate32>\n             // toDateTime(value[, timezone: String])\n             || std::is_same_v<ToDataType, DataTypeDateTime>\ndiff --git a/src/Functions/serverConstants.cpp b/src/Functions/serverConstants.cpp\nindex 19a0d82caf43..0fda53414dee 100644\n--- a/src/Functions/serverConstants.cpp\n+++ b/src/Functions/serverConstants.cpp\n@@ -60,13 +60,22 @@ namespace\n     };\n \n \n-    /// Returns the server time zone.\n+    /// Returns timezone for current session.\n     class FunctionTimezone : public FunctionConstantBase<FunctionTimezone, String, DataTypeString>\n     {\n     public:\n         static constexpr auto name = \"timezone\";\n         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionTimezone>(context); }\n-        explicit FunctionTimezone(ContextPtr context) : FunctionConstantBase(String{DateLUT::instance().getTimeZone()}, context->isDistributed()) {}\n+        explicit FunctionTimezone(ContextPtr context) : FunctionConstantBase(DateLUT::instance().getTimeZone(), context->isDistributed()) {}\n+    };\n+\n+    /// Returns the server time zone (timezone in which server runs).\n+    class FunctionServerTimezone : public FunctionConstantBase<FunctionServerTimezone, String, DataTypeString>\n+    {\n+    public:\n+        static constexpr auto name = \"serverTimezone\";\n+        static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionServerTimezone>(context); }\n+        explicit FunctionServerTimezone(ContextPtr context) : FunctionConstantBase(DateLUT::serverTimezoneInstance().getTimeZone(), context->isDistributed()) {}\n     };\n \n \n@@ -151,8 +160,34 @@ REGISTER_FUNCTION(TcpPort)\n \n REGISTER_FUNCTION(Timezone)\n {\n-    factory.registerFunction<FunctionTimezone>();\n-    factory.registerAlias(\"timeZone\", \"timezone\");\n+    factory.registerFunction<FunctionTimezone>(\n+        FunctionDocumentation{\n+        .description=R\"(\n+Returns the default timezone for current session.\n+Used as default timezone for parsing DateTime|DateTime64 without explicitly specified timezone.\n+Can be changed with SET timezone = 'New/Tz'\n+\n+[example:timezone]\n+    )\",\n+    .examples{{\"timezone\", \"SELECT timezone();\", \"\"}},\n+    .categories{\"Constant\", \"Miscellaneous\"}\n+});\n+factory.registerAlias(\"timeZone\", \"timezone\");\n+}\n+\n+REGISTER_FUNCTION(ServerTimezone)\n+{\n+    factory.registerFunction<FunctionServerTimezone>(\n+    FunctionDocumentation{\n+        .description=R\"(\n+Returns the timezone name in which server operates.\n+\n+[example:serverTimezone]\n+    )\",\n+     .examples{{\"serverTimezone\", \"SELECT serverTimezone();\", \"\"}},\n+     .categories{\"Constant\", \"Miscellaneous\"}\n+});\n+    factory.registerAlias(\"serverTimeZone\", \"serverTimezone\");\n }\n \n REGISTER_FUNCTION(Uptime)\ndiff --git a/src/Functions/timezoneOf.cpp b/src/Functions/timezoneOf.cpp\nindex 6454b1cd7353..7a5957a5dbce 100644\n--- a/src/Functions/timezoneOf.cpp\n+++ b/src/Functions/timezoneOf.cpp\n@@ -6,7 +6,6 @@\n #include <Common/DateLUTImpl.h>\n #include <Core/Field.h>\n \n-\n namespace DB\n {\n \ndiff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h\nindex dabb21c046c1..af8d4942ff10 100644\n--- a/src/IO/ReadHelpers.h\n+++ b/src/IO/ReadHelpers.h\n@@ -702,7 +702,7 @@ inline void convertToDayNum(DayNum & date, ExtendedDayNum & from)\n }\n \n template <typename ReturnType = void>\n-inline ReturnType readDateTextImpl(DayNum & date, ReadBuffer & buf)\n+inline ReturnType readDateTextImpl(DayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut)\n {\n     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n \n@@ -713,13 +713,13 @@ inline ReturnType readDateTextImpl(DayNum & date, ReadBuffer & buf)\n     else if (!readDateTextImpl<ReturnType>(local_date, buf))\n         return false;\n \n-    ExtendedDayNum ret = DateLUT::instance().makeDayNum(local_date.year(), local_date.month(), local_date.day());\n-    convertToDayNum(date,ret);\n+    ExtendedDayNum ret = date_lut.makeDayNum(local_date.year(), local_date.month(), local_date.day());\n+    convertToDayNum(date, ret);\n     return ReturnType(true);\n }\n \n template <typename ReturnType = void>\n-inline ReturnType readDateTextImpl(ExtendedDayNum & date, ReadBuffer & buf)\n+inline ReturnType readDateTextImpl(ExtendedDayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut)\n {\n     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;\n \n@@ -731,7 +731,7 @@ inline ReturnType readDateTextImpl(ExtendedDayNum & date, ReadBuffer & buf)\n         return false;\n \n     /// When the parameter is out of rule or out of range, Date32 uses 1925-01-01 as the default value (-DateLUT::instance().getDayNumOffsetEpoch(), -16436) and Date uses 1970-01-01.\n-    date = DateLUT::instance().makeDayNum(local_date.year(), local_date.month(), local_date.day(), -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch()));\n+    date = date_lut.makeDayNum(local_date.year(), local_date.month(), local_date.day(), -static_cast<Int32>(date_lut.getDayNumOffsetEpoch()));\n     return ReturnType(true);\n }\n \n@@ -741,14 +741,14 @@ inline void readDateText(LocalDate & date, ReadBuffer & buf)\n     readDateTextImpl<void>(date, buf);\n }\n \n-inline void readDateText(DayNum & date, ReadBuffer & buf)\n+inline void readDateText(DayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut = DateLUT::instance())\n {\n-    readDateTextImpl<void>(date, buf);\n+    readDateTextImpl<void>(date, buf, date_lut);\n }\n \n-inline void readDateText(ExtendedDayNum & date, ReadBuffer & buf)\n+inline void readDateText(ExtendedDayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut = DateLUT::instance())\n {\n-    readDateTextImpl<void>(date, buf);\n+    readDateTextImpl<void>(date, buf, date_lut);\n }\n \n inline bool tryReadDateText(LocalDate & date, ReadBuffer & buf)\n@@ -756,14 +756,14 @@ inline bool tryReadDateText(LocalDate & date, ReadBuffer & buf)\n     return readDateTextImpl<bool>(date, buf);\n }\n \n-inline bool tryReadDateText(DayNum & date, ReadBuffer & buf)\n+inline bool tryReadDateText(DayNum & date, ReadBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())\n {\n-    return readDateTextImpl<bool>(date, buf);\n+    return readDateTextImpl<bool>(date, buf, time_zone);\n }\n \n-inline bool tryReadDateText(ExtendedDayNum & date, ReadBuffer & buf)\n+inline bool tryReadDateText(ExtendedDayNum & date, ReadBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())\n {\n-    return readDateTextImpl<bool>(date, buf);\n+    return readDateTextImpl<bool>(date, buf, time_zone);\n }\n \n UUID parseUUID(std::span<const UInt8> src);\n@@ -1135,8 +1135,10 @@ inline bool tryReadText(IPv6 & x, ReadBuffer & buf) { return tryReadIPv6Text(x,\n inline void readText(is_floating_point auto & x, ReadBuffer & buf) { readFloatText(x, buf); }\n \n inline void readText(String & x, ReadBuffer & buf) { readEscapedString(x, buf); }\n+\n+inline void readText(DayNum & x, ReadBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance()) { readDateText(x, buf, time_zone); }\n+\n inline void readText(LocalDate & x, ReadBuffer & buf) { readDateText(x, buf); }\n-inline void readText(DayNum & x, ReadBuffer & buf) { readDateText(x, buf); }\n inline void readText(LocalDateTime & x, ReadBuffer & buf) { readDateTimeText(x, buf); }\n inline void readText(UUID & x, ReadBuffer & buf) { readUUIDText(x, buf); }\n inline void readText(IPv4 & x, ReadBuffer & buf) { readIPv4Text(x, buf); }\n@@ -1148,6 +1150,10 @@ template <typename T>\n requires is_arithmetic_v<T>\n inline void readQuoted(T & x, ReadBuffer & buf) { readText(x, buf); }\n \n+template <typename T>\n+requires is_arithmetic_v<T>\n+inline void readQuoted(T & x, ReadBuffer & buf, const DateLUTImpl & time_zone) { readText(x, buf, time_zone); }\n+\n inline void readQuoted(String & x, ReadBuffer & buf) { readQuotedString(x, buf); }\n \n inline void readQuoted(LocalDate & x, ReadBuffer & buf)\n@@ -1190,6 +1196,10 @@ template <typename T>\n requires is_arithmetic_v<T>\n inline void readDoubleQuoted(T & x, ReadBuffer & buf) { readText(x, buf); }\n \n+template <typename T>\n+requires is_arithmetic_v<T>\n+inline void readDoubleQuoted(T & x, ReadBuffer & buf, const DateLUTImpl & time_zone) { readText(x, buf, time_zone); }\n+\n inline void readDoubleQuoted(String & x, ReadBuffer & buf) { readDoubleQuotedString(x, buf); }\n \n inline void readDoubleQuoted(LocalDate & x, ReadBuffer & buf)\n@@ -1206,7 +1216,7 @@ inline void readDoubleQuoted(LocalDateTime & x, ReadBuffer & buf)\n     assertChar('\"', buf);\n }\n \n-/// CSV, for numbers, dates: quotes are optional, no special escaping rules.\n+/// CSV for numbers: quotes are optional, no special escaping rules.\n template <typename T>\n inline void readCSVSimple(T & x, ReadBuffer & buf)\n {\n@@ -1224,6 +1234,24 @@ inline void readCSVSimple(T & x, ReadBuffer & buf)\n         assertChar(maybe_quote, buf);\n }\n \n+// standalone overload for dates: to avoid instantiating DateLUTs while parsing other types\n+template <typename T>\n+inline void readCSVSimple(T & x, ReadBuffer & buf, const DateLUTImpl & time_zone)\n+{\n+    if (buf.eof()) [[unlikely]]\n+        throwReadAfterEOF();\n+\n+    char maybe_quote = *buf.position();\n+\n+    if (maybe_quote == '\\'' || maybe_quote == '\\\"')\n+        ++buf.position();\n+\n+    readText(x, buf, time_zone);\n+\n+    if (maybe_quote == '\\'' || maybe_quote == '\\\"')\n+        assertChar(maybe_quote, buf);\n+}\n+\n template <typename T>\n requires is_arithmetic_v<T>\n inline void readCSV(T & x, ReadBuffer & buf)\n@@ -1234,6 +1262,7 @@ inline void readCSV(T & x, ReadBuffer & buf)\n inline void readCSV(String & x, ReadBuffer & buf, const FormatSettings::CSV & settings) { readCSVString(x, buf, settings); }\n inline void readCSV(LocalDate & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(DayNum & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n+inline void readCSV(DayNum & x, ReadBuffer & buf, const DateLUTImpl & time_zone) { readCSVSimple(x, buf, time_zone); }\n inline void readCSV(LocalDateTime & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(UUID & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\n inline void readCSV(IPv4 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }\ndiff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h\nindex 3d1a5aa49efa..29eb1355fd80 100644\n--- a/src/IO/WriteHelpers.h\n+++ b/src/IO/WriteHelpers.h\n@@ -697,15 +697,15 @@ inline void writeDateText(const LocalDate & date, WriteBuffer & buf)\n }\n \n template <char delimiter = '-'>\n-inline void writeDateText(DayNum date, WriteBuffer & buf)\n+inline void writeDateText(DayNum date, WriteBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())\n {\n-    writeDateText<delimiter>(LocalDate(date), buf);\n+    writeDateText<delimiter>(LocalDate(date, time_zone), buf);\n }\n \n template <char delimiter = '-'>\n-inline void writeDateText(ExtendedDayNum date, WriteBuffer & buf)\n+inline void writeDateText(ExtendedDayNum date, WriteBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())\n {\n-    writeDateText<delimiter>(LocalDate(date), buf);\n+    writeDateText<delimiter>(LocalDate(date, time_zone), buf);\n }\n \n /// In the format YYYY-MM-DD HH:MM:SS\n@@ -886,7 +886,7 @@ inline void writeText(is_enum auto x, WriteBuffer & buf) { writeText(magic_enum:\n \n inline void writeText(std::string_view x, WriteBuffer & buf) { writeString(x.data(), x.size(), buf); }\n \n-inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(LocalDate(x), buf); }\n+inline void writeText(const DayNum & x, WriteBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance()) { writeDateText(LocalDate(x, time_zone), buf); }\n inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }\n inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }\n inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }\ndiff --git a/src/Loggers/OwnPatternFormatter.cpp b/src/Loggers/OwnPatternFormatter.cpp\nindex 0c2256aaa1b6..8d8e35432e89 100644\n--- a/src/Loggers/OwnPatternFormatter.cpp\n+++ b/src/Loggers/OwnPatternFormatter.cpp\n@@ -20,7 +20,7 @@ void OwnPatternFormatter::formatExtended(const DB::ExtendedLogMessage & msg_ext,\n     const Poco::Message & msg = msg_ext.base;\n \n     /// Change delimiters in date for compatibility with old logs.\n-    DB::writeDateTimeText<'.', ':'>(msg_ext.time_seconds, wb);\n+    DB::writeDateTimeText<'.', ':'>(msg_ext.time_seconds, wb, server_timezone);\n \n     DB::writeChar('.', wb);\n     DB::writeChar('0' + ((msg_ext.time_microseconds / 100000) % 10), wb);\ndiff --git a/src/Loggers/OwnPatternFormatter.h b/src/Loggers/OwnPatternFormatter.h\nindex d776b097cb2b..8b0d11bcec12 100644\n--- a/src/Loggers/OwnPatternFormatter.h\n+++ b/src/Loggers/OwnPatternFormatter.h\n@@ -2,6 +2,7 @@\n \n \n #include <Poco/PatternFormatter.h>\n+#include <Common/DateLUT.h>\n #include \"ExtendedLogChannel.h\"\n \n \n@@ -30,5 +31,6 @@ class OwnPatternFormatter : public Poco::PatternFormatter\n     virtual void formatExtended(const DB::ExtendedLogMessage & msg_ext, std::string & text) const;\n \n private:\n+    const DateLUTImpl & server_timezone = DateLUT::serverTimezoneInstance();\n     bool color;\n };\ndiff --git a/src/QueryPipeline/RemoteInserter.cpp b/src/QueryPipeline/RemoteInserter.cpp\nindex b8a878b56c3c..134c169e35ff 100644\n--- a/src/QueryPipeline/RemoteInserter.cpp\n+++ b/src/QueryPipeline/RemoteInserter.cpp\n@@ -130,7 +130,7 @@ void RemoteInserter::onFinish()\n             break;\n         else if (Protocol::Server::Exception == packet.type)\n             packet.exception->rethrow();\n-        else if (Protocol::Server::Log == packet.type)\n+        else if (Protocol::Server::Log == packet.type || Protocol::Server::TimezoneUpdate == packet.type)\n         {\n             // Do nothing\n         }\ndiff --git a/src/QueryPipeline/RemoteQueryExecutor.cpp b/src/QueryPipeline/RemoteQueryExecutor.cpp\nindex 3f9f945fd457..233dfe13339b 100644\n--- a/src/QueryPipeline/RemoteQueryExecutor.cpp\n+++ b/src/QueryPipeline/RemoteQueryExecutor.cpp\n@@ -512,6 +512,9 @@ RemoteQueryExecutor::ReadResult RemoteQueryExecutor::processPacket(Packet packet\n                     throw Exception(ErrorCodes::SYSTEM_ERROR, \"Could not push into profile queue\");\n             break;\n \n+        case Protocol::Server::TimezoneUpdate:\n+            break;\n+\n         default:\n             got_unknown_packet_from_replica = true;\n             throw Exception(\n@@ -616,6 +619,9 @@ void RemoteQueryExecutor::finish()\n                     throw Exception(ErrorCodes::SYSTEM_ERROR, \"Could not push into profile queue\");\n             break;\n \n+        case Protocol::Server::TimezoneUpdate:\n+            break;\n+\n         default:\n             got_unknown_packet_from_replica = true;\n             throw Exception(ErrorCodes::UNKNOWN_PACKET_FROM_SERVER, \"Unknown packet {} from one of the following replicas: {}\",\ndiff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp\nindex 50e9d50e2f60..0cdb714588c7 100644\n--- a/src/Server/TCPHandler.cpp\n+++ b/src/Server/TCPHandler.cpp\n@@ -350,6 +350,7 @@ void TCPHandler::runImpl()\n                 /// Send block to the client - input storage structure.\n                 state.input_header = metadata_snapshot->getSampleBlock();\n                 sendData(state.input_header);\n+                sendTimezone();\n             });\n \n             query_context->setInputBlocksReaderCallback([this] (ContextPtr context) -> Block\n@@ -763,7 +764,6 @@ void TCPHandler::processInsertQuery()\n \n         /// Send block to the client - table structure.\n         sendData(executor.getHeader());\n-\n         sendLogs();\n \n         while (readDataNext())\n@@ -1063,6 +1063,20 @@ void TCPHandler::sendInsertProfileEvents()\n     sendProfileEvents();\n }\n \n+void TCPHandler::sendTimezone()\n+{\n+    if (client_tcp_protocol_version < DBMS_MIN_PROTOCOL_VERSION_WITH_TIMEZONE_UPDATES)\n+        return;\n+\n+    const String & tz = query_context->getSettingsRef().session_timezone.value;\n+\n+    LOG_DEBUG(log, \"TCPHandler::sendTimezone(): {}\", tz);\n+    writeVarUInt(Protocol::Server::TimezoneUpdate, *out);\n+    writeStringBinary(tz, *out);\n+    out->next();\n+}\n+\n+\n bool TCPHandler::receiveProxyHeader()\n {\n     if (in->eof())\ndiff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h\nindex d18ffc5afe85..629738fa16fd 100644\n--- a/src/Server/TCPHandler.h\n+++ b/src/Server/TCPHandler.h\n@@ -274,6 +274,7 @@ class TCPHandler : public Poco::Net::TCPServerConnection\n     void sendProfileEvents();\n     void sendSelectProfileEvents();\n     void sendInsertProfileEvents();\n+    void sendTimezone();\n \n     /// Creates state.block_in/block_out for blocks read/write, depending on whether compression is enabled.\n     void initBlockInput();\ndiff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\nindex 8019ca938e01..cf2d1b19326f 100644\n--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp\n@@ -1053,7 +1053,7 @@ void IMergeTreeDataPart::loadPartitionAndMinMaxIndex()\n         DayNum max_date;\n         MergeTreePartInfo::parseMinMaxDatesFromPartName(name, min_date, max_date);\n \n-        const auto & date_lut = DateLUT::instance();\n+        const auto & date_lut = DateLUT::serverTimezoneInstance();\n         partition = MergeTreePartition(date_lut.toNumYYYYMM(min_date));\n         minmax_idx = std::make_shared<MinMaxIndex>(min_date, max_date);\n     }\ndiff --git a/src/Storages/MergeTree/MergeFromLogEntryTask.cpp b/src/Storages/MergeTree/MergeFromLogEntryTask.cpp\nindex 5cee402f88c6..586d8b8ff83c 100644\n--- a/src/Storages/MergeTree/MergeFromLogEntryTask.cpp\n+++ b/src/Storages/MergeTree/MergeFromLogEntryTask.cpp\n@@ -57,7 +57,7 @@ ReplicatedMergeMutateTaskBase::PrepareResult MergeFromLogEntryTask::prepare()\n     {\n         LOG_INFO(log, \"Will try to fetch part {} until '{}' because this part assigned to recompression merge. \"\n             \"Source replica {} will try to merge this part first\", entry.new_part_name,\n-            DateLUT::instance().timeToString(entry.create_time + storage_settings_ptr->try_fetch_recompressed_part_timeout.totalSeconds()), entry.source_replica);\n+            DateLUT::serverTimezoneInstance().timeToString(entry.create_time + storage_settings_ptr->try_fetch_recompressed_part_timeout.totalSeconds()), entry.source_replica);\n             /// Waiting other replica to recompress part. No need to check it.\n             return PrepareResult{\n                 .prepared_successfully = false,\ndiff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\nindex da2b9608e435..7e306880e9ce 100644\n--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp\n@@ -116,7 +116,7 @@ void updateTTL(\n \n     if (const ColumnUInt16 * column_date = typeid_cast<const ColumnUInt16 *>(ttl_column.get()))\n     {\n-        const auto & date_lut = DateLUT::instance();\n+        const auto & date_lut = DateLUT::serverTimezoneInstance();\n         for (const auto & val : column_date->getData())\n             ttl_info.update(date_lut.fromDayNum(DayNum(val)));\n     }\n@@ -129,7 +129,7 @@ void updateTTL(\n     {\n         if (typeid_cast<const ColumnUInt16 *>(&column_const->getDataColumn()))\n         {\n-            const auto & date_lut = DateLUT::instance();\n+            const auto & date_lut = DateLUT::serverTimezoneInstance();\n             ttl_info.update(date_lut.fromDayNum(DayNum(column_const->getValue<UInt16>())));\n         }\n         else if (typeid_cast<const ColumnUInt32 *>(&column_const->getDataColumn()))\n@@ -383,7 +383,7 @@ MergeTreeDataWriter::TemporaryPart MergeTreeDataWriter::writeTempPartImpl(\n         DayNum min_date(minmax_idx->hyperrectangle[data.minmax_idx_date_column_pos].left.get<UInt64>());\n         DayNum max_date(minmax_idx->hyperrectangle[data.minmax_idx_date_column_pos].right.get<UInt64>());\n \n-        const auto & date_lut = DateLUT::instance();\n+        const auto & date_lut = DateLUT::serverTimezoneInstance();\n \n         auto min_month = date_lut.toNumYYYYMM(min_date);\n         auto max_month = date_lut.toNumYYYYMM(max_date);\ndiff --git a/src/Storages/MergeTree/MergeTreeMutationEntry.cpp b/src/Storages/MergeTree/MergeTreeMutationEntry.cpp\nindex feffffb57eab..cac26c5ac236 100644\n--- a/src/Storages/MergeTree/MergeTreeMutationEntry.cpp\n+++ b/src/Storages/MergeTree/MergeTreeMutationEntry.cpp\n@@ -128,7 +128,7 @@ MergeTreeMutationEntry::MergeTreeMutationEntry(DiskPtr disk_, const String & pat\n \n     LocalDateTime create_time_dt;\n     *buf >> \"create time: \" >> create_time_dt >> \"\\n\";\n-    create_time = DateLUT::instance().makeDateTime(\n+    create_time = DateLUT::serverTimezoneInstance().makeDateTime(\n         create_time_dt.year(), create_time_dt.month(), create_time_dt.day(),\n         create_time_dt.hour(), create_time_dt.minute(), create_time_dt.second());\n \ndiff --git a/src/Storages/MergeTree/MergeTreePartInfo.cpp b/src/Storages/MergeTree/MergeTreePartInfo.cpp\nindex 84432a293d7f..e1b52d8a7b7c 100644\n--- a/src/Storages/MergeTree/MergeTreePartInfo.cpp\n+++ b/src/Storages/MergeTree/MergeTreePartInfo.cpp\n@@ -148,7 +148,7 @@ void MergeTreePartInfo::parseMinMaxDatesFromPartName(const String & part_name, D\n         throw Exception(ErrorCodes::BAD_DATA_PART_NAME, \"Unexpected part name: {}\", part_name);\n     }\n \n-    const auto & date_lut = DateLUT::instance();\n+    const auto & date_lut = DateLUT::serverTimezoneInstance();\n \n     min_date = date_lut.YYYYMMDDToDayNum(min_yyyymmdd);\n     max_date = date_lut.YYYYMMDDToDayNum(max_yyyymmdd);\n@@ -219,7 +219,7 @@ String MergeTreePartInfo::getPartNameV1() const\n \n String MergeTreePartInfo::getPartNameV0(DayNum left_date, DayNum right_date) const\n {\n-    const auto & date_lut = DateLUT::instance();\n+    const auto & date_lut = DateLUT::serverTimezoneInstance();\n \n     /// Directory name for the part has form: `YYYYMMDD_YYYYMMDD_N_N_L`.\n \ndiff --git a/src/Storages/MergeTree/MergeTreePartition.cpp b/src/Storages/MergeTree/MergeTreePartition.cpp\nindex 62ad658730ea..bce33438229b 100644\n--- a/src/Storages/MergeTree/MergeTreePartition.cpp\n+++ b/src/Storages/MergeTree/MergeTreePartition.cpp\n@@ -247,7 +247,7 @@ String MergeTreePartition::getID(const Block & partition_key_sample) const\n                 result += '-';\n \n             if (typeid_cast<const DataTypeDate *>(partition_key_sample.getByPosition(i).type.get()))\n-                result += toString(DateLUT::instance().toNumYYYYMMDD(DayNum(value[i].safeGet<UInt64>())));\n+                result += toString(DateLUT::serverTimezoneInstance().toNumYYYYMMDD(DayNum(value[i].safeGet<UInt64>())));\n             else if (typeid_cast<const DataTypeIPv4 *>(partition_key_sample.getByPosition(i).type.get()))\n                 result += toString(value[i].get<IPv4>().toUnderType());\n             else\n@@ -331,7 +331,7 @@ std::optional<Row> MergeTreePartition::tryParseValueFromID(const String & partit\n                     throw Exception(\n                         ErrorCodes::INVALID_PARTITION_VALUE, \"Cannot parse partition_id: got unexpected Date: {}\", date_yyyymmdd);\n \n-                UInt32 date = DateLUT::instance().YYYYMMDDToDayNum(date_yyyymmdd);\n+                UInt32 date = DateLUT::serverTimezoneInstance().YYYYMMDDToDayNum(date_yyyymmdd);\n                 res.emplace_back(date);\n                 break;\n             }\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp\nindex 79b0beb09330..ac956433eab7 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp\n@@ -199,7 +199,7 @@ void ReplicatedMergeTreeLogEntryData::readText(ReadBuffer & in, MergeTreeDataFor\n     {\n         LocalDateTime create_time_dt;\n         in >> \"create_time: \" >> create_time_dt >> \"\\n\";\n-        create_time = DateLUT::instance().makeDateTime(\n+        create_time = DateLUT::serverTimezoneInstance().makeDateTime(\n             create_time_dt.year(), create_time_dt.month(), create_time_dt.day(),\n             create_time_dt.hour(), create_time_dt.minute(), create_time_dt.second());\n     }\ndiff --git a/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp\nindex 5e01cd96f6b7..1bbb246338cb 100644\n--- a/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp\n+++ b/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp\n@@ -38,7 +38,7 @@ void ReplicatedMergeTreeMutationEntry::readText(ReadBuffer & in)\n \n     LocalDateTime create_time_dt;\n     in >> \"create time: \" >> create_time_dt >> \"\\n\";\n-    create_time = DateLUT::instance().makeDateTime(\n+    create_time = DateLUT::serverTimezoneInstance().makeDateTime(\n         create_time_dt.year(), create_time_dt.month(), create_time_dt.day(),\n         create_time_dt.hour(), create_time_dt.minute(), create_time_dt.second());\n \ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex bb99e21e4abc..ae4e8ac0a8f1 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -5591,7 +5591,7 @@ String getPartNamePossiblyFake(MergeTreeDataFormatVersion format_version, const\n     if (format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)\n     {\n         /// The date range is all month long.\n-        const auto & lut = DateLUT::instance();\n+        const auto & lut = DateLUT::serverTimezoneInstance();\n         time_t start_time = lut.YYYYMMDDToDate(parse<UInt32>(part_info.partition_id + \"01\"));\n         DayNum left_date = DayNum(lut.toDayNum(start_time).toUnderType());\n         DayNum right_date = DayNum(static_cast<size_t>(left_date) + lut.daysInMonth(start_time) - 1);\ndiff --git a/src/Storages/WindowView/StorageWindowView.cpp b/src/Storages/WindowView/StorageWindowView.cpp\nindex 7fca9b5f078c..242e8e5d5709 100644\n--- a/src/Storages/WindowView/StorageWindowView.cpp\n+++ b/src/Storages/WindowView/StorageWindowView.cpp\n@@ -1340,7 +1340,7 @@ ASTPtr StorageWindowView::innerQueryParser(const ASTSelectQuery & query)\n         time_zone = &DateLUT::instance(window_view_timezone);\n     }\n     else\n-        time_zone = &DateLUT::instance();\n+        time_zone = &DateLUT::serverTimezoneInstance();\n \n     return result;\n }\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex 46bd0da4236a..893a2bae74ff 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -2134,6 +2134,8 @@ seektable\n sequenceCount\n sequenceMatch\n sequenceNextNode\n+serverTimeZone\n+serverTimezone\n serverUUID\n sessionCacheSize\n sessionIdContext\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex bf43288fe1dd..b5c133988e6b 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -686,7 +686,6 @@ throwIf\n tid\n timeSlot\n timeSlots\n-timezone\n timezoneOf\n timezoneOffset\n toBool\ndiff --git a/tests/queries/0_stateless/02737_timezone_setting.reference b/tests/queries/0_stateless/02737_timezone_setting.reference\nnew file mode 100644\nindex 000000000000..578aec4e3162\n--- /dev/null\n+++ b/tests/queries/0_stateless/02737_timezone_setting.reference\n@@ -0,0 +1,7 @@\n+Pacific/Pitcairn\tPacific/Pitcairn\n+Asia/Novosibirsk\tAsia/Novosibirsk\n+2022-12-12 17:23:23\n+2022-12-13 07:23:23.123\n+2002-12-12 23:23:23\t2002-12-12 23:23:23\n+2002-12-12 23:23:23.123\t2002-12-12 23:23:23.123\n+2000-01-01 01:00:00\ndiff --git a/tests/queries/0_stateless/02737_timezone_setting.sql b/tests/queries/0_stateless/02737_timezone_setting.sql\nnew file mode 100644\nindex 000000000000..8543e2a2c82e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02737_timezone_setting.sql\n@@ -0,0 +1,26 @@\n+SET session_timezone = '\u0410\u0431\u044b\u0440\u0432\u0430\u043b\u0433'; -- { serverError BAD_ARGUMENTS}\n+\n+SELECT timezone(), timezoneOf(now()) SETTINGS session_timezone = 'Pacific/Pitcairn';\n+\n+SET session_timezone = 'Asia/Novosibirsk';\n+SELECT timezone(), timezoneOf(now());\n+\n+-- test simple queries\n+SELECT toDateTime(toDateTime('2022-12-12 23:23:23'), 'Europe/Zurich');\n+SELECT toDateTime64(toDateTime64('2022-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver';\n+\n+-- test proper serialization\n+SELECT toDateTime('2002-12-12 23:23:23') AS dt, toString(dt) SETTINGS session_timezone = 'Asia/Phnom_Penh';\n+SELECT toDateTime64('2002-12-12 23:23:23.123', 3) AS dt64, toString(dt64) SETTINGS session_timezone = 'Asia/Phnom_Penh';\n+\n+-- Create a table and test that DateTimes are processed correctly on insert\n+CREATE TABLE test_tz_setting (d DateTime('UTC')) Engine=Memory AS SELECT toDateTime('2000-01-01 00:00:00');\n+INSERT INTO test_tz_setting VALUES ('2000-01-01 01:00:00'); -- this is parsed using timezone from `d` column\n+INSERT INTO test_tz_setting VALUES (toDateTime('2000-01-02 02:00:00')); -- this is parsed using `session_timezone`\n+\n+-- Test parsing in WHERE filter, shall have the same logic as insert\n+SELECT d FROM test_tz_setting WHERE d == '2000-01-01 01:00:00'; -- 1 row expected\n+SELECT d FROM test_tz_setting WHERE d == toDateTime('2000-01-01 02:00:00'); -- 0 rows expected\n+\n+-- Cleanup table\n+DROP TABLE test_tz_setting SYNC;\n",
  "problem_statement": "Introduce session setting for applied timezone.\n**Use case**\r\n\r\nI want my reports to show data to customers in different timezones, for example histogram of daily visits. And not manually and tediously make the conversion for a particular timezone. One session setting like \"applied_time_zone\" should be used to convert all dates/datetimes in queried data.\r\nFunctions like `toStartOfDay`, `toStartOfWeek` should return correct time in applied timezone.\r\n\r\nNow we have parameter in clickhouse-client: \r\n```\r\n--use_client_time_zone arg\r\n\r\nUse client timezone for interpreting \r\nDateTime string values, instead of \r\nadopting server timezone.\r\n```\r\n\r\nThe proposed setting should work on a session level `WITH SETTINGS ....` and dynamically applied.\r\n\r\n**Describe alternatives you've considered**\r\n\r\nThere are several ways to workaround this: \r\n1. manually convert each date/datetime value `toDateTime( , timezone)`\r\n2. use `--use_client_time_zone`, but only applicable to client, and not language libraries.\r\n\r\n\r\n\n",
  "hints_text": "@zvonand works on this ",
  "created_at": "2022-12-12T02:46:31Z",
  "modified_files": [
    "docs/en/operations/server-configuration-parameters/settings.md",
    "docs/en/operations/settings/settings.md",
    "docs/en/sql-reference/functions/date-time-functions.md",
    "docs/ru/operations/server-configuration-parameters/settings.md",
    "docs/ru/operations/settings/settings.md",
    "docs/ru/sql-reference/functions/date-time-functions.md",
    "programs/client/Client.cpp",
    "programs/copier/ClusterCopierApp.cpp",
    "programs/keeper/Keeper.cpp",
    "programs/obfuscator/Obfuscator.cpp",
    "programs/server/Server.cpp",
    "src/Client/ClientBase.cpp",
    "src/Client/ClientBase.h",
    "src/Client/Connection.cpp",
    "src/Client/HedgedConnections.cpp",
    "src/Client/IServerConnection.h",
    "src/Client/MultiplexedConnections.cpp",
    "src/Client/Suggest.cpp",
    "src/Common/DateLUT.cpp",
    "src/Common/DateLUT.h",
    "src/Common/LocalDate.h",
    "src/Core/Protocol.h",
    "src/Core/ProtocolDefines.h",
    "src/Core/Settings.h",
    "src/Core/SettingsFields.cpp",
    "src/Core/SettingsFields.h",
    "src/Daemon/BaseDaemon.cpp",
    "src/DataTypes/DataTypeDateTime.h",
    "src/DataTypes/Serializations/SerializationDate.cpp",
    "src/DataTypes/Serializations/SerializationDate.h",
    "src/DataTypes/Serializations/SerializationDate32.cpp",
    "src/DataTypes/Serializations/SerializationDate32.h",
    "src/Functions/FunctionsConversion.h",
    "src/Functions/serverConstants.cpp",
    "src/Functions/timezoneOf.cpp",
    "src/IO/ReadHelpers.h",
    "src/IO/WriteHelpers.h",
    "src/Loggers/OwnPatternFormatter.cpp",
    "src/Loggers/OwnPatternFormatter.h",
    "src/QueryPipeline/RemoteInserter.cpp",
    "src/QueryPipeline/RemoteQueryExecutor.cpp",
    "src/Server/TCPHandler.cpp",
    "src/Server/TCPHandler.h",
    "src/Storages/MergeTree/IMergeTreeDataPart.cpp",
    "src/Storages/MergeTree/MergeFromLogEntryTask.cpp",
    "src/Storages/MergeTree/MergeTreeDataWriter.cpp",
    "src/Storages/MergeTree/MergeTreeMutationEntry.cpp",
    "src/Storages/MergeTree/MergeTreePartInfo.cpp",
    "src/Storages/MergeTree/MergeTreePartition.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp",
    "src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp",
    "src/Storages/WindowView/StorageWindowView.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference",
    "b/tests/queries/0_stateless/02737_timezone_setting.reference",
    "b/tests/queries/0_stateless/02737_timezone_setting.sql"
  ]
}