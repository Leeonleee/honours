diff --git a/docs/en/operations/server-configuration-parameters/settings.md b/docs/en/operations/server-configuration-parameters/settings.md
index ce62d4368135..5643e273d39a 100644
--- a/docs/en/operations/server-configuration-parameters/settings.md
+++ b/docs/en/operations/server-configuration-parameters/settings.md
@@ -1975,6 +1975,10 @@ The time zone is necessary for conversions between String and DateTime formats w
 <timezone>Asia/Istanbul</timezone>
 ```
 
+**See also**
+
+- [session_timezone](../settings/settings.md#session_timezone)
+
 ## tcp_port {#server_configuration_parameters-tcp_port}
 
 Port for communicating with clients over the TCP protocol.
diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md
index baefbb2cf6fc..cff65e049f32 100644
--- a/docs/en/operations/settings/settings.md
+++ b/docs/en/operations/settings/settings.md
@@ -4251,6 +4251,69 @@ Default value: `0`.
 Use this setting only for backward compatibility if your use cases depend on old syntax.
 :::
 
+## session_timezone {#session_timezone}
+
+Sets the implicit time zone of the current session or query.
+The implicit time zone is the time zone applied to values of type DateTime/DateTime64 which have no explicitly specified time zone. 
+The setting takes precedence over the globally configured (server-level) implicit time zone.
+A value of '' (empty string) means that the implicit time zone of the current session or query is equal to the [server time zone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone).
+
+You can use functions `timeZone()` and `serverTimeZone()` to get the session time zone and server time zone.
+
+Possible values:
+
+-    Any time zone name from `system.time_zones`, e.g. `Europe/Berlin`, `UTC` or `Zulu`
+
+Default value: `''`.
+
+Examples:
+
+```sql
+SELECT timeZone(), serverTimeZone() FORMAT TSV
+
+Europe/Berlin	Europe/Berlin
+```
+
+```sql
+SELECT timeZone(), serverTimeZone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT TSV
+
+Asia/Novosibirsk	Europe/Berlin
+```
+
+Assign session time zone 'America/Denver' to the inner DateTime without explicitly specified time zone:
+
+```sql
+SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV
+
+1999-12-13 07:23:23.123
+```
+
+:::warning
+Not all functions that parse DateTime/DateTime64 respect `session_timezone`. This can lead to subtle errors. 
+See the following example and explanation.
+:::
+
+```sql
+CREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');
+
+SELECT *, timeZone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'
+0 rows in set.
+
+SELECT *, timeZone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'
+┌───────────────────d─┬─timeZone()───────┐
+│ 2000-01-01 00:00:00 │ Asia/Novosibirsk │
+└─────────────────────┴──────────────────┘
+```
+
+This happens due to different parsing pipelines:
+
+- `toDateTime()` without explicitly given time zone used in the first `SELECT` query honors setting `session_timezone` and the global time zone.
+- In the second query, a DateTime is parsed from a String, and inherits the type and time zone of the existing column`d`. Thus, setting `session_timezone` and the global time zone are not honored.
+
+**See also**
+
+- [timezone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone)
+
 ## final {#final}
 
 Automatically applies [FINAL](../../sql-reference/statements/select/from.md#final-modifier) modifier to all tables in a query, to tables where [FINAL](../../sql-reference/statements/select/from.md#final-modifier) is applicable, including joined tables and tables in sub-queries, and
diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 280b41e7a5f6..3f61e7a214da 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -139,8 +139,8 @@ makeDateTime32(year, month, day, hour, minute, second[, fraction[, precision[, t
 
 ## timeZone
 
-Returns the timezone of the server.
-If the function is executed in the context of a distributed table, it generates a normal column with values relevant to each shard, otherwise it produces a constant value.
+Returns the timezone of the current session, i.e. the value of setting [session_timezone](../../operations/settings/settings.md#session_timezone).
+If the function is executed in the context of a distributed table, then it generates a normal column with values relevant to each shard, otherwise it produces a constant value.
 
 **Syntax**
 
@@ -156,6 +156,33 @@ Alias: `timezone`.
 
 Type: [String](../../sql-reference/data-types/string.md).
 
+**See also**
+
+- [serverTimeZone](#serverTimeZone)
+
+## serverTimeZone
+
+Returns the timezone of the server, i.e. the value of setting [timezone](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-timezone).
+If the function is executed in the context of a distributed table, then it generates a normal column with values relevant to each shard. Otherwise, it produces a constant value.
+
+**Syntax**
+
+``` sql
+serverTimeZone()
+```
+
+Alias: `serverTimezone`.
+
+**Returned value**
+
+-   Timezone.
+
+Type: [String](../../sql-reference/data-types/string.md).
+
+**See also**
+
+- [timeZone](#timeZone)
+
 ## toTimeZone
 
 Converts a date or date with time to the specified time zone. Does not change the internal value (number of unix seconds) of the data, only the value's time zone attribute and the value's string representation changes.
diff --git a/docs/ru/operations/server-configuration-parameters/settings.md b/docs/ru/operations/server-configuration-parameters/settings.md
index 787153d4d199..33db6df0fdd3 100644
--- a/docs/ru/operations/server-configuration-parameters/settings.md
+++ b/docs/ru/operations/server-configuration-parameters/settings.md
@@ -1355,6 +1355,10 @@ Parameters:
 <timezone>Europe/Moscow</timezone>
 ```
 
+**См. также**
+
+- [session_timezone](../settings/settings.md#session_timezone)
+
 ## tcp_port {#server_configuration_parameters-tcp_port}
 
 Порт для взаимодействия с клиентами по протоколу TCP.
diff --git a/docs/ru/operations/settings/settings.md b/docs/ru/operations/settings/settings.md
index e3da8302fc8a..f83d05ff7103 100644
--- a/docs/ru/operations/settings/settings.md
+++ b/docs/ru/operations/settings/settings.md
@@ -4127,6 +4127,63 @@ SELECT sum(number) FROM numbers(10000000000) SETTINGS partial_result_on_first_ca
 
 Значение по умолчанию: `false`
 
+## session_timezone {#session_timezone}
+
+Задаёт значение часового пояса (session_timezone) по умолчанию для текущей сессии вместо [часового пояса сервера](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone). То есть, все значения DateTime/DateTime64, для которых явно не задан часовой пояс, будут интерпретированы как относящиеся к указанной зоне.
+При значении настройки `''` (пустая строка), будет совпадать с часовым поясом сервера. 
+
+Функции `timeZone()` and `serverTimezone()` возвращают часовой пояс текущей сессии и сервера соответственно.
+
+Примеры:
+```sql
+SELECT timeZone(), serverTimezone() FORMAT TSV
+
+Europe/Berlin	Europe/Berlin
+```
+
+```sql
+SELECT timeZone(), serverTimezone() SETTINGS session_timezone = 'Asia/Novosibirsk' FORMAT TSV
+
+Asia/Novosibirsk	Europe/Berlin
+```
+
+```sql
+SELECT toDateTime64(toDateTime64('1999-12-12 23:23:23.123', 3), 3, 'Europe/Zurich') SETTINGS session_timezone = 'America/Denver' FORMAT TSV
+
+1999-12-13 07:23:23.123
+```
+
+Возможные значения:
+
+-    Любая зона из `system.time_zones`, например `Europe/Berlin`, `UTC` или `Zulu`
+
+Значение по умолчанию: `''`.
+
+:::warning
+Иногда при формировании значений типа `DateTime` и `DateTime64` параметр  `session_timezone` может быть проигнорирован.
+Это может привести к путанице. Пример и пояснение см. ниже.
+:::
+
+```sql
+CREATE TABLE test_tz (`d` DateTime('UTC')) ENGINE = Memory AS SELECT toDateTime('2000-01-01 00:00:00', 'UTC');
+
+SELECT *, timezone() FROM test_tz WHERE d = toDateTime('2000-01-01 00:00:00') SETTINGS session_timezone = 'Asia/Novosibirsk'
+0 rows in set.
+
+SELECT *, timezone() FROM test_tz WHERE d = '2000-01-01 00:00:00' SETTINGS session_timezone = 'Asia/Novosibirsk'
+┌───────────────────d─┬─timezone()───────┐
+│ 2000-01-01 00:00:00 │ Asia/Novosibirsk │
+└─────────────────────┴──────────────────┘
+```
+
+Это происходит из-за различного происхождения значения, используемого для сравнения:
+- В первом запросе функция `toDateTime()`, создавая значение типа `DateTime`, принимает во внимание параметр `session_timezone` из контекста запроса;
+- Во втором запросе `DateTime` формируется из строки неявно, наследуя тип колонки `d` (в том числе и числовой пояс), и параметр `session_timezone` игнорируется.
+
+**Смотрите также**
+
+- [timezone](../server-configuration-parameters/settings.md#server_configuration_parameters-timezone)
+
 ## rename_files_after_processing
 
 - **Тип:** Строка
diff --git a/docs/ru/sql-reference/functions/date-time-functions.md b/docs/ru/sql-reference/functions/date-time-functions.md
index 867d71d334c0..17ab04b7799e 100644
--- a/docs/ru/sql-reference/functions/date-time-functions.md
+++ b/docs/ru/sql-reference/functions/date-time-functions.md
@@ -26,7 +26,8 @@ SELECT
 
 ## timeZone {#timezone}
 
-Возвращает часовой пояс сервера.
+Возвращает часовой пояс сервера, считающийся умолчанием для текущей сессии: значение параметра [session_timezone](../../operations/settings/settings.md#session_timezone), если установлено.
+
 Если функция вызывается в контексте распределенной таблицы, то она генерирует обычный столбец со значениями, актуальными для каждого шарда. Иначе возвращается константа.
 
 **Синтаксис**
@@ -43,6 +44,33 @@ timeZone()
 
 Тип: [String](../../sql-reference/data-types/string.md).
 
+**Смотрите также**
+
+- [serverTimeZone](#servertimezone)
+
+## serverTimeZone {#servertimezone}
+
+Возвращает часовой пояс сервера по умолчанию, в т.ч. установленный [timezone](../../operations/server-configuration-parameters/settings.md#server_configuration_parameters-timezone)
+Если функция вызывается в контексте распределенной таблицы, то она генерирует обычный столбец со значениями, актуальными для каждого шарда. Иначе возвращается константа.
+
+**Синтаксис**
+
+``` sql
+serverTimeZone()
+```
+
+Синонимы: `serverTimezone`.
+
+**Возвращаемое значение**
+
+-   Часовой пояс.
+
+Тип: [String](../../sql-reference/data-types/string.md).
+
+**Смотрите также**
+
+- [timeZone](#timezone)
+
 ## toTimeZone {#totimezone}
 
 Переводит дату или дату с временем в указанный часовой пояс. Часовой пояс - это атрибут типов `Date` и `DateTime`. Внутреннее значение (количество секунд) поля таблицы или результирующего столбца не изменяется, изменяется тип поля и, соответственно, его текстовое отображение.
diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp
index 54b091700b2f..14516bfa9390 100644
--- a/programs/client/Client.cpp
+++ b/programs/client/Client.cpp
@@ -4,7 +4,9 @@
 #include <map>
 #include <iostream>
 #include <iomanip>
+#include <memory>
 #include <optional>
+#include <Common/ThreadStatus.h>
 #include <Common/scope_guard_safe.h>
 #include <boost/program_options.hpp>
 #include <boost/algorithm/string/replace.hpp>
@@ -307,7 +309,7 @@ int Client::main(const std::vector<std::string> & /*args*/)
 try
 {
     UseSSL use_ssl;
-    MainThreadStatus::getInstance();
+    auto & thread_status = MainThreadStatus::getInstance();
     setupSignalHandler();
 
     std::cout << std::fixed << std::setprecision(3);
@@ -320,6 +322,14 @@ try
     processConfig();
     initTtyBuffer(toProgressOption(config().getString("progress", "default")));
 
+    {
+        // All that just to set DB::CurrentThread::get().getGlobalContext()
+        // which is required for client timezone (pushed from server) to work.
+        auto thread_group = std::make_shared<ThreadGroup>();
+        const_cast<ContextWeakPtr&>(thread_group->global_context) = global_context;
+        thread_status.attachToGroup(thread_group, false);
+    }
+
     /// Includes delayed_interactive.
     if (is_interactive)
     {
diff --git a/programs/copier/ClusterCopierApp.cpp b/programs/copier/ClusterCopierApp.cpp
index 822289dd89c2..64071423b8e2 100644
--- a/programs/copier/ClusterCopierApp.cpp
+++ b/programs/copier/ClusterCopierApp.cpp
@@ -44,7 +44,7 @@ void ClusterCopierApp::initialize(Poco::Util::Application & self)
     time_t timestamp = Poco::Timestamp().epochTime();
     auto curr_pid = Poco::Process::id();
 
-    process_id = std::to_string(DateLUT::instance().toNumYYYYMMDDhhmmss(timestamp)) + "_" + std::to_string(curr_pid);
+    process_id = std::to_string(DateLUT::serverTimezoneInstance().toNumYYYYMMDDhhmmss(timestamp)) + "_" + std::to_string(curr_pid);
     host_id = escapeForFileName(getFQDNOrHostName()) + '#' + process_id;
     process_path = fs::weakly_canonical(fs::path(base_dir) / ("clickhouse-copier_" + process_id));
     fs::create_directories(process_path);
diff --git a/programs/keeper/Keeper.cpp b/programs/keeper/Keeper.cpp
index 57760b5ebbfa..a18256651888 100644
--- a/programs/keeper/Keeper.cpp
+++ b/programs/keeper/Keeper.cpp
@@ -306,8 +306,8 @@ try
 
     /// Initialize DateLUT early, to not interfere with running time of first query.
     LOG_DEBUG(log, "Initializing DateLUT.");
-    DateLUT::instance();
-    LOG_TRACE(log, "Initialized DateLUT with time zone '{}'.", DateLUT::instance().getTimeZone());
+    DateLUT::serverTimezoneInstance();
+    LOG_TRACE(log, "Initialized DateLUT with time zone '{}'.", DateLUT::serverTimezoneInstance().getTimeZone());
 
     /// Don't want to use DNS cache
     DNSResolver::instance().setDisableCacheFlag();
diff --git a/programs/obfuscator/Obfuscator.cpp b/programs/obfuscator/Obfuscator.cpp
index add16ec5205e..3042ae2bb577 100644
--- a/programs/obfuscator/Obfuscator.cpp
+++ b/programs/obfuscator/Obfuscator.cpp
@@ -491,7 +491,7 @@ class DateTimeModel : public IModel
     const DateLUTImpl & date_lut;
 
 public:
-    explicit DateTimeModel(UInt64 seed_) : seed(seed_), date_lut(DateLUT::instance()) {}
+    explicit DateTimeModel(UInt64 seed_) : seed(seed_), date_lut(DateLUT::serverTimezoneInstance()) {}
 
     void train(const IColumn &) override {}
     void finalize() override {}
diff --git a/programs/server/Server.cpp b/programs/server/Server.cpp
index cfef7f0a94a2..d2d8a0d07fb7 100644
--- a/programs/server/Server.cpp
+++ b/programs/server/Server.cpp
@@ -960,8 +960,8 @@ try
 
     /// Initialize DateLUT early, to not interfere with running time of first query.
     LOG_DEBUG(log, "Initializing DateLUT.");
-    DateLUT::instance();
-    LOG_TRACE(log, "Initialized DateLUT with time zone '{}'.", DateLUT::instance().getTimeZone());
+    DateLUT::serverTimezoneInstance();
+    LOG_TRACE(log, "Initialized DateLUT with time zone '{}'.", DateLUT::serverTimezoneInstance().getTimeZone());
 
     /// Storage with temporary data for processing of heavy queries.
     if (!server_settings.tmp_policy.value.empty())
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index badee99d8559..479db03c883d 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -77,7 +77,6 @@
 #include "config_version.h"
 #include "config.h"
 
-
 namespace fs = std::filesystem;
 using namespace std::literals;
 
@@ -896,7 +895,6 @@ void ClientBase::processOrdinaryQuery(const String & query_to_execute, ASTPtr pa
 
             if (send_external_tables)
                 sendExternalTables(parsed_query);
-
             receiveResult(parsed_query, signals_before_stop, settings.partial_result_on_first_cancel);
 
             break;
@@ -1048,6 +1046,10 @@ bool ClientBase::receiveAndProcessPacket(ASTPtr parsed_query, bool cancelled_)
             onProfileEvents(packet.block);
             return true;
 
+        case Protocol::Server::TimezoneUpdate:
+            onTimezoneUpdate(packet.server_timezone);
+            return true;
+
         default:
             throw Exception(
                 ErrorCodes::UNKNOWN_PACKET_FROM_SERVER, "Unknown packet {} from server {}", packet.type, connection->getDescription());
@@ -1070,6 +1072,11 @@ void ClientBase::onProgress(const Progress & value)
         progress_indication.writeProgress(*tty_buf);
 }
 
+void ClientBase::onTimezoneUpdate(const String & tz)
+{
+    global_context->setSetting("session_timezone", tz);
+}
+
 
 void ClientBase::onEndOfStream()
 {
@@ -1221,9 +1228,13 @@ bool ClientBase::receiveSampleBlock(Block & out, ColumnsDescription & columns_de
                 columns_description = ColumnsDescription::parse(packet.multistring_message[1]);
                 return receiveSampleBlock(out, columns_description, parsed_query);
 
+            case Protocol::Server::TimezoneUpdate:
+                onTimezoneUpdate(packet.server_timezone);
+                break;
+
             default:
                 throw NetException(ErrorCodes::UNEXPECTED_PACKET_FROM_SERVER,
-                    "Unexpected packet from server (expected Data, Exception or Log, got {})",
+                    "Unexpected packet from server (expected Data, Exception, Log or TimezoneUpdate, got {})",
                     String(Protocol::Server::toString(packet.type)));
         }
     }
@@ -1538,7 +1549,9 @@ void ClientBase::receiveLogsAndProfileEvents(ASTPtr parsed_query)
 {
     auto packet_type = connection->checkPacket(0);
 
-    while (packet_type && (*packet_type == Protocol::Server::Log || *packet_type == Protocol::Server::ProfileEvents))
+    while (packet_type && (*packet_type == Protocol::Server::Log
+            || *packet_type == Protocol::Server::ProfileEvents
+            || *packet_type == Protocol::Server::TimezoneUpdate))
     {
         receiveAndProcessPacket(parsed_query, false);
         packet_type = connection->checkPacket(0);
@@ -1575,6 +1588,10 @@ bool ClientBase::receiveEndOfQuery()
                 onProfileEvents(packet.block);
                 break;
 
+            case Protocol::Server::TimezoneUpdate:
+                onTimezoneUpdate(packet.server_timezone);
+                break;
+
             default:
                 throw NetException(ErrorCodes::UNEXPECTED_PACKET_FROM_SERVER,
                     "Unexpected packet from server (expected Exception, EndOfStream, Log, Progress or ProfileEvents. Got {})",
diff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h
index ee4567a09223..bd17318d1dff 100644
--- a/src/Client/ClientBase.h
+++ b/src/Client/ClientBase.h
@@ -148,6 +148,7 @@ class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>
     void cancelQuery();
 
     void onProgress(const Progress & value);
+    void onTimezoneUpdate(const String & tz);
     void onData(Block & block, ASTPtr parsed_query);
     void onLogData(Block & block);
     void onTotals(Block & block, ASTPtr parsed_query);
diff --git a/src/Client/Connection.cpp b/src/Client/Connection.cpp
index 636532ade4b6..be226bfd9dd9 100644
--- a/src/Client/Connection.cpp
+++ b/src/Client/Connection.cpp
@@ -1022,6 +1022,11 @@ Packet Connection::receivePacket()
                 res.block = receiveProfileEvents();
                 return res;
 
+            case Protocol::Server::TimezoneUpdate:
+                readStringBinary(server_timezone, *in);
+                res.server_timezone = server_timezone;
+                return res;
+
             default:
                 /// In unknown state, disconnect - to not leave unsynchronised connection.
                 disconnect();
diff --git a/src/Client/HedgedConnections.cpp b/src/Client/HedgedConnections.cpp
index f8966847e5ab..fb6fe258d486 100644
--- a/src/Client/HedgedConnections.cpp
+++ b/src/Client/HedgedConnections.cpp
@@ -419,6 +419,7 @@ Packet HedgedConnections::receivePacketFromReplica(const ReplicaLocation & repli
             }
             replica_with_last_received_packet = replica_location;
             break;
+        case Protocol::Server::TimezoneUpdate:
         case Protocol::Server::PartUUIDs:
         case Protocol::Server::ProfileInfo:
         case Protocol::Server::Totals:
diff --git a/src/Client/IServerConnection.h b/src/Client/IServerConnection.h
index cd4db8f5258f..52382ff9d454 100644
--- a/src/Client/IServerConnection.h
+++ b/src/Client/IServerConnection.h
@@ -38,6 +38,8 @@ struct Packet
     ParallelReadRequest request;
     ParallelReadResponse response;
 
+    std::string server_timezone;
+
     Packet() : type(Protocol::Server::Hello) {}
 };
 
diff --git a/src/Client/MultiplexedConnections.cpp b/src/Client/MultiplexedConnections.cpp
index 71f536b96877..e5c4a19e02a3 100644
--- a/src/Client/MultiplexedConnections.cpp
+++ b/src/Client/MultiplexedConnections.cpp
@@ -259,6 +259,7 @@ Packet MultiplexedConnections::drain()
 
         switch (packet.type)
         {
+            case Protocol::Server::TimezoneUpdate:
             case Protocol::Server::MergeTreeAllRangesAnnounecement:
             case Protocol::Server::MergeTreeReadTaskRequest:
             case Protocol::Server::ReadTaskRequest:
@@ -340,6 +341,7 @@ Packet MultiplexedConnections::receivePacketUnlocked(AsyncCallback async_callbac
 
     switch (packet.type)
     {
+        case Protocol::Server::TimezoneUpdate:
         case Protocol::Server::MergeTreeAllRangesAnnounecement:
         case Protocol::Server::MergeTreeReadTaskRequest:
         case Protocol::Server::ReadTaskRequest:
diff --git a/src/Client/Suggest.cpp b/src/Client/Suggest.cpp
index 4e38add0ef5f..3d07080bb281 100644
--- a/src/Client/Suggest.cpp
+++ b/src/Client/Suggest.cpp
@@ -160,6 +160,7 @@ void Suggest::fetch(IServerConnection & connection, const ConnectionTimeouts & t
                 fillWordsFromBlock(packet.block);
                 continue;
 
+            case Protocol::Server::TimezoneUpdate:
             case Protocol::Server::Progress:
             case Protocol::Server::ProfileInfo:
             case Protocol::Server::Totals:
diff --git a/src/Common/DateLUT.cpp b/src/Common/DateLUT.cpp
index a31ece00c0b9..2b261a28469d 100644
--- a/src/Common/DateLUT.cpp
+++ b/src/Common/DateLUT.cpp
@@ -7,6 +7,7 @@
 
 #include <filesystem>
 #include <fstream>
+#include <Interpreters/Context.h>
 
 
 namespace
@@ -163,3 +164,8 @@ DateLUT & DateLUT::getInstance()
     static DateLUT ret;
     return ret;
 }
+
+std::string DateLUT::extractTimezoneFromContext(DB::ContextPtr query_context)
+{
+    return query_context->getSettingsRef().session_timezone.value;
+}
diff --git a/src/Common/DateLUT.h b/src/Common/DateLUT.h
index fe259f0f3c37..2045d4895e71 100644
--- a/src/Common/DateLUT.h
+++ b/src/Common/DateLUT.h
@@ -5,6 +5,7 @@
 #include <base/defines.h>
 
 #include <boost/noncopyable.hpp>
+#include "Common/CurrentThread.h"
 
 #include <atomic>
 #include <memory>
@@ -16,22 +17,59 @@
 class DateLUT : private boost::noncopyable
 {
 public:
-    /// Return singleton DateLUTImpl instance for the default time zone.
+    /// Return DateLUTImpl instance for session timezone.
+    /// session_timezone is a session-level setting.
+    /// If setting is not set, returns the server timezone.
     static ALWAYS_INLINE const DateLUTImpl & instance()
     {
         const auto & date_lut = getInstance();
-        return *date_lut.default_impl.load(std::memory_order_acquire);
+
+        if (DB::CurrentThread::isInitialized())
+        {
+            std::string timezone_from_context;
+            const DB::ContextPtr query_context = DB::CurrentThread::get().getQueryContext();
+
+            if (query_context)
+            {
+                timezone_from_context = extractTimezoneFromContext(query_context);
+
+                if (!timezone_from_context.empty())
+                    return date_lut.getImplementation(timezone_from_context);
+            }
+
+            /// On the server side, timezone is passed in query_context,
+            /// but on CH-client side we have no query context,
+            /// and each time we modify client's global context
+            const DB::ContextPtr global_context = DB::CurrentThread::get().getGlobalContext();
+            if (global_context)
+            {
+                timezone_from_context = extractTimezoneFromContext(global_context);
+
+                if (!timezone_from_context.empty())
+                    return date_lut.getImplementation(timezone_from_context);
+            }
+
+        }
+        return serverTimezoneInstance();
     }
 
-    /// Return singleton DateLUTImpl instance for a given time zone.
     static ALWAYS_INLINE const DateLUTImpl & instance(const std::string & time_zone)
     {
-        const auto & date_lut = getInstance();
         if (time_zone.empty())
-            return *date_lut.default_impl.load(std::memory_order_acquire);
+            return instance();
 
+        const auto & date_lut = getInstance();
         return date_lut.getImplementation(time_zone);
     }
+
+    /// Return singleton DateLUTImpl for the server time zone.
+    /// It may be set using 'timezone' server setting.
+    static ALWAYS_INLINE const DateLUTImpl & serverTimezoneInstance()
+    {
+        const auto & date_lut = getInstance();
+        return *date_lut.default_impl.load(std::memory_order_acquire);
+    }
+
     static void setDefaultTimezone(const std::string & time_zone)
     {
         auto & date_lut = getInstance();
@@ -45,6 +83,8 @@ class DateLUT : private boost::noncopyable
 private:
     static DateLUT & getInstance();
 
+    static std::string extractTimezoneFromContext(DB::ContextPtr query_context);
+
     const DateLUTImpl & getImplementation(const std::string & time_zone) const;
 
     using DateLUTImplPtr = std::unique_ptr<DateLUTImpl>;
diff --git a/src/Common/LocalDate.h b/src/Common/LocalDate.h
index dc36f92bebf2..2331a40fd124 100644
--- a/src/Common/LocalDate.h
+++ b/src/Common/LocalDate.h
@@ -24,9 +24,8 @@ class LocalDate
     unsigned char m_month;
     unsigned char m_day;
 
-    void init(time_t time)
+    void init(time_t time, const DateLUTImpl & date_lut)
     {
-        const auto & date_lut = DateLUT::instance();
         const auto & values = date_lut.getValues(time);
 
         m_year = values.year;
@@ -56,22 +55,22 @@ class LocalDate
     }
 
 public:
-    explicit LocalDate(time_t time)
+    explicit LocalDate(time_t time, const DateLUTImpl & time_zone = DateLUT::instance())
     {
-        init(time);
+        init(time, time_zone);
     }
 
-    LocalDate(DayNum day_num) /// NOLINT
+    LocalDate(DayNum day_num, const DateLUTImpl & time_zone = DateLUT::instance()) /// NOLINT
     {
-        const auto & values = DateLUT::instance().getValues(day_num);
+        const auto & values = time_zone.getValues(day_num);
         m_year  = values.year;
         m_month = values.month;
         m_day   = values.day_of_month;
     }
 
-    explicit LocalDate(ExtendedDayNum day_num)
+    explicit LocalDate(ExtendedDayNum day_num, const DateLUTImpl & time_zone = DateLUT::instance())
     {
-        const auto & values = DateLUT::instance().getValues(day_num);
+        const auto & values = time_zone.getValues(day_num);
         m_year  = values.year;
         m_month = values.month;
         m_day   = values.day_of_month;
@@ -99,15 +98,13 @@ class LocalDate
     LocalDate(const LocalDate &) noexcept = default;
     LocalDate & operator= (const LocalDate &) noexcept = default;
 
-    DayNum getDayNum() const
+    DayNum getDayNum(const DateLUTImpl & lut = DateLUT::instance()) const
     {
-        const auto & lut = DateLUT::instance();
         return DayNum(lut.makeDayNum(m_year, m_month, m_day).toUnderType());
     }
 
-    ExtendedDayNum  getExtenedDayNum() const
+    ExtendedDayNum getExtenedDayNum(const DateLUTImpl & lut = DateLUT::instance()) const
     {
-        const auto & lut = DateLUT::instance();
         return ExtendedDayNum (lut.makeDayNum(m_year, m_month, m_day).toUnderType());
     }
 
diff --git a/src/Core/Protocol.h b/src/Core/Protocol.h
index 86c0a851c60f..97a2831ffe8f 100644
--- a/src/Core/Protocol.h
+++ b/src/Core/Protocol.h
@@ -83,7 +83,8 @@ namespace Protocol
             ProfileEvents = 14,             /// Packet with profile events from server.
             MergeTreeAllRangesAnnounecement = 15,
             MergeTreeReadTaskRequest = 16,  /// Request from a MergeTree replica to a coordinator
-            MAX = MergeTreeReadTaskRequest,
+            TimezoneUpdate = 17,            /// Receive server's (session-wide) default timezone
+            MAX = TimezoneUpdate,
 
         };
 
@@ -111,6 +112,7 @@ namespace Protocol
                 "ProfileEvents",
                 "MergeTreeAllRangesAnnounecement",
                 "MergeTreeReadTaskRequest",
+                "TimezoneUpdate",
             };
             return packet <= MAX
                 ? data[packet]
diff --git a/src/Core/ProtocolDefines.h b/src/Core/ProtocolDefines.h
index 237ef9340818..dbe13d9502a1 100644
--- a/src/Core/ProtocolDefines.h
+++ b/src/Core/ProtocolDefines.h
@@ -53,7 +53,7 @@
 /// NOTE: DBMS_TCP_PROTOCOL_VERSION has nothing common with VERSION_REVISION,
 /// later is just a number for server version (one number instead of commit SHA)
 /// for simplicity (sometimes it may be more convenient in some use cases).
-#define DBMS_TCP_PROTOCOL_VERSION 54463
+#define DBMS_TCP_PROTOCOL_VERSION 54464
 
 #define DBMS_MIN_PROTOCOL_VERSION_WITH_INITIAL_QUERY_START_TIME 54449
 
@@ -75,3 +75,5 @@
 #define DBMS_MIN_REVISION_WITH_INTERSERVER_SECRET_V2 54462
 
 #define DBMS_MIN_PROTOCOL_VERSION_WITH_TOTAL_BYTES_IN_PROGRESS 54463
+
+#define DBMS_MIN_PROTOCOL_VERSION_WITH_TIMEZONE_UPDATES 54464
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index fbb6528e643c..3d42bd582ed4 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -770,6 +770,7 @@ class IColumn;
     M(Bool, allow_experimental_undrop_table_query, false, "Allow to use undrop query to restore dropped table in a limited time", 0) \
     M(Bool, keeper_map_strict_mode, false, "Enforce additional checks during operations on KeeperMap. E.g. throw an exception on an insert for already existing key", 0) \
     M(UInt64, extract_kvp_max_pairs_per_row, 1000, "Max number pairs that can be produced by extractKeyValuePairs function. Used to safeguard against consuming too much memory.", 0) \
+    M(Timezone, session_timezone, "", "The default timezone for current session or query. The server default timezone if empty.", 0) \
     // End of COMMON_SETTINGS
     // Please add settings related to formats into the FORMAT_FACTORY_SETTINGS and move obsolete settings to OBSOLETE_SETTINGS.
 
diff --git a/src/Core/SettingsFields.cpp b/src/Core/SettingsFields.cpp
index 8cd4efb68c67..a0f643f8d302 100644
--- a/src/Core/SettingsFields.cpp
+++ b/src/Core/SettingsFields.cpp
@@ -13,7 +13,6 @@
 
 #include <cmath>
 
-
 namespace DB
 {
 namespace ErrorCodes
@@ -451,6 +450,17 @@ String SettingFieldEnumHelpers::readBinary(ReadBuffer & in)
     return str;
 }
 
+void SettingFieldTimezone::writeBinary(WriteBuffer & out) const
+{
+    writeStringBinary(value, out);
+}
+
+void SettingFieldTimezone::readBinary(ReadBuffer & in)
+{
+    String str;
+    readStringBinary(str, in);
+    *this = std::move(str);
+}
 
 String SettingFieldCustom::toString() const
 {
diff --git a/src/Core/SettingsFields.h b/src/Core/SettingsFields.h
index 686638d497f0..786492a72567 100644
--- a/src/Core/SettingsFields.h
+++ b/src/Core/SettingsFields.h
@@ -6,6 +6,7 @@
 #include <Core/Field.h>
 #include <Core/MultiEnum.h>
 #include <boost/range/adaptor/map.hpp>
+#include <cctz/time_zone.h>
 #include <chrono>
 #include <unordered_map>
 #include <string_view>
@@ -565,6 +566,42 @@ void SettingFieldMultiEnum<EnumT, Traits>::readBinary(ReadBuffer & in)
         return getEnumValues<EnumType>().size();\
     }
 
+/// Setting field for specifying user-defined timezone. It is basically a string, but it needs validation.
+struct SettingFieldTimezone
+{
+    String value;
+    bool changed = false;
+
+    explicit SettingFieldTimezone(std::string_view str = {}) { validateTimezone(std::string(str)); value = str; }
+    explicit SettingFieldTimezone(const String & str) { validateTimezone(str); value = str; }
+    explicit SettingFieldTimezone(String && str) { validateTimezone(str); value = std::move(str); }
+    explicit SettingFieldTimezone(const char * str) { validateTimezone(str); value = str; }
+    explicit SettingFieldTimezone(const Field & f) { const String & str = f.safeGet<const String &>(); validateTimezone(str); value = str; }
+
+    SettingFieldTimezone & operator =(std::string_view str) { validateTimezone(std::string(str)); value = str; changed = true; return *this; }
+    SettingFieldTimezone & operator =(const String & str) { *this = std::string_view{str}; return *this; }
+    SettingFieldTimezone & operator =(String && str) { validateTimezone(str); value = std::move(str); changed = true; return *this; }
+    SettingFieldTimezone & operator =(const char * str) { *this = std::string_view{str}; return *this; }
+    SettingFieldTimezone & operator =(const Field & f) { *this = f.safeGet<const String &>(); return *this; }
+
+    operator const String &() const { return value; } /// NOLINT
+    explicit operator Field() const { return value; }
+
+    const String & toString() const { return value; }
+    void parseFromString(const String & str) { *this = str; }
+
+    void writeBinary(WriteBuffer & out) const;
+    void readBinary(ReadBuffer & in);
+
+private:
+    void validateTimezone(const std::string & tz_str)
+    {
+        cctz::time_zone validated_tz;
+        if (!tz_str.empty() && !cctz::load_time_zone(tz_str, &validated_tz))
+            throw DB::Exception(DB::ErrorCodes::BAD_ARGUMENTS, "Invalid time zone: {}", tz_str);
+    }
+};
+
 /// Can keep a value of any type. Used for user-defined settings.
 struct SettingFieldCustom
 {
diff --git a/src/Daemon/BaseDaemon.cpp b/src/Daemon/BaseDaemon.cpp
index bfd5568b71d9..f08231b6f32a 100644
--- a/src/Daemon/BaseDaemon.cpp
+++ b/src/Daemon/BaseDaemon.cpp
@@ -1042,7 +1042,7 @@ void BaseDaemon::shouldSetupWatchdog(char * argv0_)
 void BaseDaemon::setupWatchdog()
 {
     /// Initialize in advance to avoid double initialization in forked processes.
-    DateLUT::instance();
+    DateLUT::serverTimezoneInstance();
 
     std::string original_process_name;
     if (argv0)
diff --git a/src/DataTypes/DataTypeDateTime.h b/src/DataTypes/DataTypeDateTime.h
index edc8b016490c..a473aae1faf5 100644
--- a/src/DataTypes/DataTypeDateTime.h
+++ b/src/DataTypes/DataTypeDateTime.h
@@ -21,7 +21,9 @@ namespace DB
   *  all types with different time zones are equivalent and may be used interchangingly.
   * Time zone only affects parsing and displaying in text formats.
   *
-  * If time zone is not specified (example: DateTime without parameter), then default time zone is used.
+  * If time zone is not specified (example: DateTime without parameter),
+  * then `session_timezone` setting value is used.
+  * If `session_timezone` is not set (or empty string), server default time zone is used.
   * Default time zone is server time zone, if server is doing transformations
   *  and if client is doing transformations, unless 'use_client_time_zone' setting is passed to client;
   * Server time zone is the time zone specified in 'timezone' parameter in configuration file,
diff --git a/src/DataTypes/Serializations/SerializationDate.cpp b/src/DataTypes/Serializations/SerializationDate.cpp
index 678817017e0b..1ed48fdd31da 100644
--- a/src/DataTypes/Serializations/SerializationDate.cpp
+++ b/src/DataTypes/Serializations/SerializationDate.cpp
@@ -13,7 +13,7 @@ namespace DB
 
 void SerializationDate::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const
 {
-    writeDateText(DayNum(assert_cast<const ColumnUInt16 &>(column).getData()[row_num]), ostr);
+    writeDateText(DayNum(assert_cast<const ColumnUInt16 &>(column).getData()[row_num]), ostr, time_zone);
 }
 
 void SerializationDate::deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
@@ -26,7 +26,7 @@ void SerializationDate::deserializeWholeText(IColumn & column, ReadBuffer & istr
 void SerializationDate::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const
 {
     DayNum x;
-    readDateText(x, istr);
+    readDateText(x, istr, time_zone);
     assert_cast<ColumnUInt16 &>(column).getData().push_back(x);
 }
 
@@ -46,7 +46,7 @@ void SerializationDate::deserializeTextQuoted(IColumn & column, ReadBuffer & ist
 {
     DayNum x;
     assertChar('\'', istr);
-    readDateText(x, istr);
+    readDateText(x, istr, time_zone);
     assertChar('\'', istr);
     assert_cast<ColumnUInt16 &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.
 }
@@ -62,7 +62,7 @@ void SerializationDate::deserializeTextJSON(IColumn & column, ReadBuffer & istr,
 {
     DayNum x;
     assertChar('"', istr);
-    readDateText(x, istr);
+    readDateText(x, istr, time_zone);
     assertChar('"', istr);
     assert_cast<ColumnUInt16 &>(column).getData().push_back(x);
 }
@@ -77,8 +77,12 @@ void SerializationDate::serializeTextCSV(const IColumn & column, size_t row_num,
 void SerializationDate::deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings &) const
 {
     DayNum value;
-    readCSV(value, istr);
+    readCSV(value, istr, time_zone);
     assert_cast<ColumnUInt16 &>(column).getData().push_back(value);
 }
 
+SerializationDate::SerializationDate(const DateLUTImpl & time_zone_) : time_zone(time_zone_)
+{
+}
+
 }
diff --git a/src/DataTypes/Serializations/SerializationDate.h b/src/DataTypes/Serializations/SerializationDate.h
index 099d7444c3d9..f751b06fba66 100644
--- a/src/DataTypes/Serializations/SerializationDate.h
+++ b/src/DataTypes/Serializations/SerializationDate.h
@@ -1,6 +1,7 @@
 #pragma once
 
 #include <DataTypes/Serializations/SerializationNumber.h>
+#include <Common/DateLUT.h>
 
 namespace DB
 {
@@ -8,6 +9,8 @@ namespace DB
 class SerializationDate final : public SerializationNumber<UInt16>
 {
 public:
+    explicit SerializationDate(const DateLUTImpl & time_zone_ = DateLUT::instance());
+
     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
     void deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;
     void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
@@ -18,6 +21,9 @@ class SerializationDate final : public SerializationNumber<UInt16>
     void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;
     void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
     void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override;
+
+protected:
+    const DateLUTImpl & time_zone;
 };
 
 }
diff --git a/src/DataTypes/Serializations/SerializationDate32.cpp b/src/DataTypes/Serializations/SerializationDate32.cpp
index ef92202f89d2..851710de8392 100644
--- a/src/DataTypes/Serializations/SerializationDate32.cpp
+++ b/src/DataTypes/Serializations/SerializationDate32.cpp
@@ -11,7 +11,7 @@ namespace DB
 
 void SerializationDate32::serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const
 {
-    writeDateText(ExtendedDayNum(assert_cast<const ColumnInt32 &>(column).getData()[row_num]), ostr);
+    writeDateText(ExtendedDayNum(assert_cast<const ColumnInt32 &>(column).getData()[row_num]), ostr, time_zone);
 }
 
 void SerializationDate32::deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const
@@ -24,7 +24,7 @@ void SerializationDate32::deserializeWholeText(IColumn & column, ReadBuffer & is
 void SerializationDate32::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const
 {
     ExtendedDayNum x;
-    readDateText(x, istr);
+    readDateText(x, istr, time_zone);
     assert_cast<ColumnInt32 &>(column).getData().push_back(x);
 }
 
@@ -44,7 +44,7 @@ void SerializationDate32::deserializeTextQuoted(IColumn & column, ReadBuffer & i
 {
     ExtendedDayNum x;
     assertChar('\'', istr);
-    readDateText(x, istr);
+    readDateText(x, istr, time_zone);
     assertChar('\'', istr);
     assert_cast<ColumnInt32 &>(column).getData().push_back(x);    /// It's important to do this at the end - for exception safety.
 }
@@ -60,7 +60,7 @@ void SerializationDate32::deserializeTextJSON(IColumn & column, ReadBuffer & ist
 {
     ExtendedDayNum x;
     assertChar('"', istr);
-    readDateText(x, istr);
+    readDateText(x, istr, time_zone);
     assertChar('"', istr);
     assert_cast<ColumnInt32 &>(column).getData().push_back(x);
 }
@@ -78,4 +78,8 @@ void SerializationDate32::deserializeTextCSV(IColumn & column, ReadBuffer & istr
     readCSV(value, istr);
     assert_cast<ColumnInt32 &>(column).getData().push_back(value.getExtenedDayNum());
 }
+
+SerializationDate32::SerializationDate32(const DateLUTImpl & time_zone_) : time_zone(time_zone_)
+{
+}
 }
diff --git a/src/DataTypes/Serializations/SerializationDate32.h b/src/DataTypes/Serializations/SerializationDate32.h
index 484b4f4a9582..49560fb6c7d3 100644
--- a/src/DataTypes/Serializations/SerializationDate32.h
+++ b/src/DataTypes/Serializations/SerializationDate32.h
@@ -1,12 +1,15 @@
 #pragma once
 
 #include <DataTypes/Serializations/SerializationNumber.h>
+#include <Common/DateLUT.h>
 
 namespace DB
 {
 class SerializationDate32 final : public SerializationNumber<Int32>
 {
 public:
+    explicit SerializationDate32(const DateLUTImpl & time_zone_ = DateLUT::instance());
+
     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
     void deserializeWholeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;
     void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
@@ -17,5 +20,8 @@ class SerializationDate32 final : public SerializationNumber<Int32>
     void deserializeTextJSON(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;
     void serializeTextCSV(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;
     void deserializeTextCSV(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const override;
+
+protected:
+    const DateLUTImpl & time_zone;
 };
 }
diff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h
index 7a48f7bc914c..023f1ab5425a 100644
--- a/src/Functions/FunctionsConversion.h
+++ b/src/Functions/FunctionsConversion.h
@@ -434,7 +434,7 @@ struct ToDate32Transform32Or64Signed
 
     static NO_SANITIZE_UNDEFINED ToType execute(const FromType & from, const DateLUTImpl & time_zone)
     {
-        static const Int32 daynum_min_offset = -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch());
+        static const Int32 daynum_min_offset = -static_cast<Int32>(time_zone.getDayNumOffsetEpoch());
         if (from < daynum_min_offset)
             return daynum_min_offset;
         return (from < DATE_LUT_MAX_EXTEND_DAY_NUM)
@@ -713,9 +713,9 @@ template <>
 struct FormatImpl<DataTypeDate>
 {
     template <typename ReturnType = void>
-    static ReturnType execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl *)
+    static ReturnType execute(const DataTypeDate::FieldType x, WriteBuffer & wb, const DataTypeDate *, const DateLUTImpl * time_zone)
     {
-        writeDateText(DayNum(x), wb);
+        writeDateText(DayNum(x), wb, *time_zone);
         return ReturnType(true);
     }
 };
@@ -724,9 +724,9 @@ template <>
 struct FormatImpl<DataTypeDate32>
 {
     template <typename ReturnType = void>
-    static ReturnType execute(const DataTypeDate32::FieldType x, WriteBuffer & wb, const DataTypeDate32 *, const DateLUTImpl *)
+    static ReturnType execute(const DataTypeDate32::FieldType x, WriteBuffer & wb, const DataTypeDate32 *, const DateLUTImpl * time_zone)
     {
-        writeDateText(ExtendedDayNum(x), wb);
+        writeDateText(ExtendedDayNum(x), wb, *time_zone);
         return ReturnType(true);
     }
 };
@@ -825,7 +825,10 @@ struct ConvertImpl<FromDataType, DataTypeString, Name, ConvertDefaultBehaviorTag
         const auto & type = static_cast<const FromDataType &>(*col_with_type_and_name.type);
 
         const DateLUTImpl * time_zone = nullptr;
-        /// For argument of DateTime type, second argument with time zone could be specified.
+
+        if constexpr (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>)
+            time_zone = &DateLUT::instance();
+        /// For argument of Date or DateTime type, second argument with time zone could be specified.
         if constexpr (std::is_same_v<FromDataType, DataTypeDateTime> || std::is_same_v<FromDataType, DataTypeDateTime64>)
         {
             auto non_null_args = createBlockWithNestedColumns(arguments);
@@ -976,18 +979,18 @@ void parseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateLUTI
 }
 
 template <>
-inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)
+inline void parseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)
 {
     DayNum tmp(0);
-    readDateText(tmp, rb);
+    readDateText(tmp, rb, *time_zone);
     x = tmp;
 }
 
 template <>
-inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)
+inline void parseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)
 {
     ExtendedDayNum tmp(0);
-    readDateText(tmp, rb);
+    readDateText(tmp, rb, *time_zone);
     x = tmp;
 }
 
@@ -1035,20 +1038,20 @@ bool tryParseImpl(typename DataType::FieldType & x, ReadBuffer & rb, const DateL
 }
 
 template <>
-inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)
+inline bool tryParseImpl<DataTypeDate>(DataTypeDate::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)
 {
     DayNum tmp(0);
-    if (!tryReadDateText(tmp, rb))
+    if (!tryReadDateText(tmp, rb, *time_zone))
         return false;
     x = tmp;
     return true;
 }
 
 template <>
-inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl *)
+inline bool tryParseImpl<DataTypeDate32>(DataTypeDate32::FieldType & x, ReadBuffer & rb, const DateLUTImpl * time_zone)
 {
     ExtendedDayNum tmp(0);
-    if (!tryReadDateText(tmp, rb))
+    if (!tryReadDateText(tmp, rb, *time_zone))
         return false;
     x = tmp;
     return true;
@@ -1188,7 +1191,7 @@ struct ConvertThroughParsing
         const DateLUTImpl * local_time_zone [[maybe_unused]] = nullptr;
         const DateLUTImpl * utc_time_zone [[maybe_unused]] = nullptr;
 
-        /// For conversion to DateTime type, second argument with time zone could be specified.
+        /// For conversion to Date or DateTime type, second argument with time zone could be specified.
         if constexpr (std::is_same_v<ToDataType, DataTypeDateTime> || to_datetime64)
         {
             const auto result_type = removeNullable(res_type);
@@ -1201,6 +1204,12 @@ struct ConvertThroughParsing
             if constexpr (parsing_mode == ConvertFromStringParsingMode::BestEffort || parsing_mode == ConvertFromStringParsingMode::BestEffortUS)
                 utc_time_zone = &DateLUT::instance("UTC");
         }
+        else if constexpr (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>)
+        {
+            // Timezone is more or less dummy when parsing Date/Date32 from string.
+            local_time_zone = &DateLUT::instance();
+            utc_time_zone = &DateLUT::instance("UTC");
+        }
 
         const IColumn * col_from = arguments[0].column.get();
         const ColumnString * col_from_string = checkAndGetColumn<ColumnString>(col_from);
@@ -1751,7 +1760,7 @@ class FunctionConvert : public IFunction
             || std::is_same_v<Name, NameToUnixTimestamp>
             // toDate(value[, timezone : String])
             || std::is_same_v<ToDataType, DataTypeDate> // TODO: shall we allow timestamp argument for toDate? DateTime knows nothing about timezones and this argument is ignored below.
-            // toDate(value[, timezone : String])
+            // toDate32(value[, timezone : String])
             || std::is_same_v<ToDataType, DataTypeDate32>
             // toDateTime(value[, timezone: String])
             || std::is_same_v<ToDataType, DataTypeDateTime>
diff --git a/src/Functions/serverConstants.cpp b/src/Functions/serverConstants.cpp
index 19a0d82caf43..0fda53414dee 100644
--- a/src/Functions/serverConstants.cpp
+++ b/src/Functions/serverConstants.cpp
@@ -60,13 +60,22 @@ namespace
     };
 
 
-    /// Returns the server time zone.
+    /// Returns timezone for current session.
     class FunctionTimezone : public FunctionConstantBase<FunctionTimezone, String, DataTypeString>
     {
     public:
         static constexpr auto name = "timezone";
         static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionTimezone>(context); }
-        explicit FunctionTimezone(ContextPtr context) : FunctionConstantBase(String{DateLUT::instance().getTimeZone()}, context->isDistributed()) {}
+        explicit FunctionTimezone(ContextPtr context) : FunctionConstantBase(DateLUT::instance().getTimeZone(), context->isDistributed()) {}
+    };
+
+    /// Returns the server time zone (timezone in which server runs).
+    class FunctionServerTimezone : public FunctionConstantBase<FunctionServerTimezone, String, DataTypeString>
+    {
+    public:
+        static constexpr auto name = "serverTimezone";
+        static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionServerTimezone>(context); }
+        explicit FunctionServerTimezone(ContextPtr context) : FunctionConstantBase(DateLUT::serverTimezoneInstance().getTimeZone(), context->isDistributed()) {}
     };
 
 
@@ -151,8 +160,34 @@ REGISTER_FUNCTION(TcpPort)
 
 REGISTER_FUNCTION(Timezone)
 {
-    factory.registerFunction<FunctionTimezone>();
-    factory.registerAlias("timeZone", "timezone");
+    factory.registerFunction<FunctionTimezone>(
+        FunctionDocumentation{
+        .description=R"(
+Returns the default timezone for current session.
+Used as default timezone for parsing DateTime|DateTime64 without explicitly specified timezone.
+Can be changed with SET timezone = 'New/Tz'
+
+[example:timezone]
+    )",
+    .examples{{"timezone", "SELECT timezone();", ""}},
+    .categories{"Constant", "Miscellaneous"}
+});
+factory.registerAlias("timeZone", "timezone");
+}
+
+REGISTER_FUNCTION(ServerTimezone)
+{
+    factory.registerFunction<FunctionServerTimezone>(
+    FunctionDocumentation{
+        .description=R"(
+Returns the timezone name in which server operates.
+
+[example:serverTimezone]
+    )",
+     .examples{{"serverTimezone", "SELECT serverTimezone();", ""}},
+     .categories{"Constant", "Miscellaneous"}
+});
+    factory.registerAlias("serverTimeZone", "serverTimezone");
 }
 
 REGISTER_FUNCTION(Uptime)
diff --git a/src/Functions/timezoneOf.cpp b/src/Functions/timezoneOf.cpp
index 6454b1cd7353..7a5957a5dbce 100644
--- a/src/Functions/timezoneOf.cpp
+++ b/src/Functions/timezoneOf.cpp
@@ -6,7 +6,6 @@
 #include <Common/DateLUTImpl.h>
 #include <Core/Field.h>
 
-
 namespace DB
 {
 
diff --git a/src/IO/ReadHelpers.h b/src/IO/ReadHelpers.h
index dabb21c046c1..af8d4942ff10 100644
--- a/src/IO/ReadHelpers.h
+++ b/src/IO/ReadHelpers.h
@@ -702,7 +702,7 @@ inline void convertToDayNum(DayNum & date, ExtendedDayNum & from)
 }
 
 template <typename ReturnType = void>
-inline ReturnType readDateTextImpl(DayNum & date, ReadBuffer & buf)
+inline ReturnType readDateTextImpl(DayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut)
 {
     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;
 
@@ -713,13 +713,13 @@ inline ReturnType readDateTextImpl(DayNum & date, ReadBuffer & buf)
     else if (!readDateTextImpl<ReturnType>(local_date, buf))
         return false;
 
-    ExtendedDayNum ret = DateLUT::instance().makeDayNum(local_date.year(), local_date.month(), local_date.day());
-    convertToDayNum(date,ret);
+    ExtendedDayNum ret = date_lut.makeDayNum(local_date.year(), local_date.month(), local_date.day());
+    convertToDayNum(date, ret);
     return ReturnType(true);
 }
 
 template <typename ReturnType = void>
-inline ReturnType readDateTextImpl(ExtendedDayNum & date, ReadBuffer & buf)
+inline ReturnType readDateTextImpl(ExtendedDayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut)
 {
     static constexpr bool throw_exception = std::is_same_v<ReturnType, void>;
 
@@ -731,7 +731,7 @@ inline ReturnType readDateTextImpl(ExtendedDayNum & date, ReadBuffer & buf)
         return false;
 
     /// When the parameter is out of rule or out of range, Date32 uses 1925-01-01 as the default value (-DateLUT::instance().getDayNumOffsetEpoch(), -16436) and Date uses 1970-01-01.
-    date = DateLUT::instance().makeDayNum(local_date.year(), local_date.month(), local_date.day(), -static_cast<Int32>(DateLUT::instance().getDayNumOffsetEpoch()));
+    date = date_lut.makeDayNum(local_date.year(), local_date.month(), local_date.day(), -static_cast<Int32>(date_lut.getDayNumOffsetEpoch()));
     return ReturnType(true);
 }
 
@@ -741,14 +741,14 @@ inline void readDateText(LocalDate & date, ReadBuffer & buf)
     readDateTextImpl<void>(date, buf);
 }
 
-inline void readDateText(DayNum & date, ReadBuffer & buf)
+inline void readDateText(DayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut = DateLUT::instance())
 {
-    readDateTextImpl<void>(date, buf);
+    readDateTextImpl<void>(date, buf, date_lut);
 }
 
-inline void readDateText(ExtendedDayNum & date, ReadBuffer & buf)
+inline void readDateText(ExtendedDayNum & date, ReadBuffer & buf, const DateLUTImpl & date_lut = DateLUT::instance())
 {
-    readDateTextImpl<void>(date, buf);
+    readDateTextImpl<void>(date, buf, date_lut);
 }
 
 inline bool tryReadDateText(LocalDate & date, ReadBuffer & buf)
@@ -756,14 +756,14 @@ inline bool tryReadDateText(LocalDate & date, ReadBuffer & buf)
     return readDateTextImpl<bool>(date, buf);
 }
 
-inline bool tryReadDateText(DayNum & date, ReadBuffer & buf)
+inline bool tryReadDateText(DayNum & date, ReadBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())
 {
-    return readDateTextImpl<bool>(date, buf);
+    return readDateTextImpl<bool>(date, buf, time_zone);
 }
 
-inline bool tryReadDateText(ExtendedDayNum & date, ReadBuffer & buf)
+inline bool tryReadDateText(ExtendedDayNum & date, ReadBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())
 {
-    return readDateTextImpl<bool>(date, buf);
+    return readDateTextImpl<bool>(date, buf, time_zone);
 }
 
 UUID parseUUID(std::span<const UInt8> src);
@@ -1135,8 +1135,10 @@ inline bool tryReadText(IPv6 & x, ReadBuffer & buf) { return tryReadIPv6Text(x,
 inline void readText(is_floating_point auto & x, ReadBuffer & buf) { readFloatText(x, buf); }
 
 inline void readText(String & x, ReadBuffer & buf) { readEscapedString(x, buf); }
+
+inline void readText(DayNum & x, ReadBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance()) { readDateText(x, buf, time_zone); }
+
 inline void readText(LocalDate & x, ReadBuffer & buf) { readDateText(x, buf); }
-inline void readText(DayNum & x, ReadBuffer & buf) { readDateText(x, buf); }
 inline void readText(LocalDateTime & x, ReadBuffer & buf) { readDateTimeText(x, buf); }
 inline void readText(UUID & x, ReadBuffer & buf) { readUUIDText(x, buf); }
 inline void readText(IPv4 & x, ReadBuffer & buf) { readIPv4Text(x, buf); }
@@ -1148,6 +1150,10 @@ template <typename T>
 requires is_arithmetic_v<T>
 inline void readQuoted(T & x, ReadBuffer & buf) { readText(x, buf); }
 
+template <typename T>
+requires is_arithmetic_v<T>
+inline void readQuoted(T & x, ReadBuffer & buf, const DateLUTImpl & time_zone) { readText(x, buf, time_zone); }
+
 inline void readQuoted(String & x, ReadBuffer & buf) { readQuotedString(x, buf); }
 
 inline void readQuoted(LocalDate & x, ReadBuffer & buf)
@@ -1190,6 +1196,10 @@ template <typename T>
 requires is_arithmetic_v<T>
 inline void readDoubleQuoted(T & x, ReadBuffer & buf) { readText(x, buf); }
 
+template <typename T>
+requires is_arithmetic_v<T>
+inline void readDoubleQuoted(T & x, ReadBuffer & buf, const DateLUTImpl & time_zone) { readText(x, buf, time_zone); }
+
 inline void readDoubleQuoted(String & x, ReadBuffer & buf) { readDoubleQuotedString(x, buf); }
 
 inline void readDoubleQuoted(LocalDate & x, ReadBuffer & buf)
@@ -1206,7 +1216,7 @@ inline void readDoubleQuoted(LocalDateTime & x, ReadBuffer & buf)
     assertChar('"', buf);
 }
 
-/// CSV, for numbers, dates: quotes are optional, no special escaping rules.
+/// CSV for numbers: quotes are optional, no special escaping rules.
 template <typename T>
 inline void readCSVSimple(T & x, ReadBuffer & buf)
 {
@@ -1224,6 +1234,24 @@ inline void readCSVSimple(T & x, ReadBuffer & buf)
         assertChar(maybe_quote, buf);
 }
 
+// standalone overload for dates: to avoid instantiating DateLUTs while parsing other types
+template <typename T>
+inline void readCSVSimple(T & x, ReadBuffer & buf, const DateLUTImpl & time_zone)
+{
+    if (buf.eof()) [[unlikely]]
+        throwReadAfterEOF();
+
+    char maybe_quote = *buf.position();
+
+    if (maybe_quote == '\'' || maybe_quote == '\"')
+        ++buf.position();
+
+    readText(x, buf, time_zone);
+
+    if (maybe_quote == '\'' || maybe_quote == '\"')
+        assertChar(maybe_quote, buf);
+}
+
 template <typename T>
 requires is_arithmetic_v<T>
 inline void readCSV(T & x, ReadBuffer & buf)
@@ -1234,6 +1262,7 @@ inline void readCSV(T & x, ReadBuffer & buf)
 inline void readCSV(String & x, ReadBuffer & buf, const FormatSettings::CSV & settings) { readCSVString(x, buf, settings); }
 inline void readCSV(LocalDate & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(DayNum & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
+inline void readCSV(DayNum & x, ReadBuffer & buf, const DateLUTImpl & time_zone) { readCSVSimple(x, buf, time_zone); }
 inline void readCSV(LocalDateTime & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(UUID & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
 inline void readCSV(IPv4 & x, ReadBuffer & buf) { readCSVSimple(x, buf); }
diff --git a/src/IO/WriteHelpers.h b/src/IO/WriteHelpers.h
index 3d1a5aa49efa..29eb1355fd80 100644
--- a/src/IO/WriteHelpers.h
+++ b/src/IO/WriteHelpers.h
@@ -697,15 +697,15 @@ inline void writeDateText(const LocalDate & date, WriteBuffer & buf)
 }
 
 template <char delimiter = '-'>
-inline void writeDateText(DayNum date, WriteBuffer & buf)
+inline void writeDateText(DayNum date, WriteBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())
 {
-    writeDateText<delimiter>(LocalDate(date), buf);
+    writeDateText<delimiter>(LocalDate(date, time_zone), buf);
 }
 
 template <char delimiter = '-'>
-inline void writeDateText(ExtendedDayNum date, WriteBuffer & buf)
+inline void writeDateText(ExtendedDayNum date, WriteBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance())
 {
-    writeDateText<delimiter>(LocalDate(date), buf);
+    writeDateText<delimiter>(LocalDate(date, time_zone), buf);
 }
 
 /// In the format YYYY-MM-DD HH:MM:SS
@@ -886,7 +886,7 @@ inline void writeText(is_enum auto x, WriteBuffer & buf) { writeText(magic_enum:
 
 inline void writeText(std::string_view x, WriteBuffer & buf) { writeString(x.data(), x.size(), buf); }
 
-inline void writeText(const DayNum & x, WriteBuffer & buf) { writeDateText(LocalDate(x), buf); }
+inline void writeText(const DayNum & x, WriteBuffer & buf, const DateLUTImpl & time_zone = DateLUT::instance()) { writeDateText(LocalDate(x, time_zone), buf); }
 inline void writeText(const LocalDate & x, WriteBuffer & buf) { writeDateText(x, buf); }
 inline void writeText(const LocalDateTime & x, WriteBuffer & buf) { writeDateTimeText(x, buf); }
 inline void writeText(const UUID & x, WriteBuffer & buf) { writeUUIDText(x, buf); }
diff --git a/src/Loggers/OwnPatternFormatter.cpp b/src/Loggers/OwnPatternFormatter.cpp
index 0c2256aaa1b6..8d8e35432e89 100644
--- a/src/Loggers/OwnPatternFormatter.cpp
+++ b/src/Loggers/OwnPatternFormatter.cpp
@@ -20,7 +20,7 @@ void OwnPatternFormatter::formatExtended(const DB::ExtendedLogMessage & msg_ext,
     const Poco::Message & msg = msg_ext.base;
 
     /// Change delimiters in date for compatibility with old logs.
-    DB::writeDateTimeText<'.', ':'>(msg_ext.time_seconds, wb);
+    DB::writeDateTimeText<'.', ':'>(msg_ext.time_seconds, wb, server_timezone);
 
     DB::writeChar('.', wb);
     DB::writeChar('0' + ((msg_ext.time_microseconds / 100000) % 10), wb);
diff --git a/src/Loggers/OwnPatternFormatter.h b/src/Loggers/OwnPatternFormatter.h
index d776b097cb2b..8b0d11bcec12 100644
--- a/src/Loggers/OwnPatternFormatter.h
+++ b/src/Loggers/OwnPatternFormatter.h
@@ -2,6 +2,7 @@
 
 
 #include <Poco/PatternFormatter.h>
+#include <Common/DateLUT.h>
 #include "ExtendedLogChannel.h"
 
 
@@ -30,5 +31,6 @@ class OwnPatternFormatter : public Poco::PatternFormatter
     virtual void formatExtended(const DB::ExtendedLogMessage & msg_ext, std::string & text) const;
 
 private:
+    const DateLUTImpl & server_timezone = DateLUT::serverTimezoneInstance();
     bool color;
 };
diff --git a/src/QueryPipeline/RemoteInserter.cpp b/src/QueryPipeline/RemoteInserter.cpp
index b8a878b56c3c..134c169e35ff 100644
--- a/src/QueryPipeline/RemoteInserter.cpp
+++ b/src/QueryPipeline/RemoteInserter.cpp
@@ -130,7 +130,7 @@ void RemoteInserter::onFinish()
             break;
         else if (Protocol::Server::Exception == packet.type)
             packet.exception->rethrow();
-        else if (Protocol::Server::Log == packet.type)
+        else if (Protocol::Server::Log == packet.type || Protocol::Server::TimezoneUpdate == packet.type)
         {
             // Do nothing
         }
diff --git a/src/QueryPipeline/RemoteQueryExecutor.cpp b/src/QueryPipeline/RemoteQueryExecutor.cpp
index 3f9f945fd457..233dfe13339b 100644
--- a/src/QueryPipeline/RemoteQueryExecutor.cpp
+++ b/src/QueryPipeline/RemoteQueryExecutor.cpp
@@ -512,6 +512,9 @@ RemoteQueryExecutor::ReadResult RemoteQueryExecutor::processPacket(Packet packet
                     throw Exception(ErrorCodes::SYSTEM_ERROR, "Could not push into profile queue");
             break;
 
+        case Protocol::Server::TimezoneUpdate:
+            break;
+
         default:
             got_unknown_packet_from_replica = true;
             throw Exception(
@@ -616,6 +619,9 @@ void RemoteQueryExecutor::finish()
                     throw Exception(ErrorCodes::SYSTEM_ERROR, "Could not push into profile queue");
             break;
 
+        case Protocol::Server::TimezoneUpdate:
+            break;
+
         default:
             got_unknown_packet_from_replica = true;
             throw Exception(ErrorCodes::UNKNOWN_PACKET_FROM_SERVER, "Unknown packet {} from one of the following replicas: {}",
diff --git a/src/Server/TCPHandler.cpp b/src/Server/TCPHandler.cpp
index 50e9d50e2f60..0cdb714588c7 100644
--- a/src/Server/TCPHandler.cpp
+++ b/src/Server/TCPHandler.cpp
@@ -350,6 +350,7 @@ void TCPHandler::runImpl()
                 /// Send block to the client - input storage structure.
                 state.input_header = metadata_snapshot->getSampleBlock();
                 sendData(state.input_header);
+                sendTimezone();
             });
 
             query_context->setInputBlocksReaderCallback([this] (ContextPtr context) -> Block
@@ -763,7 +764,6 @@ void TCPHandler::processInsertQuery()
 
         /// Send block to the client - table structure.
         sendData(executor.getHeader());
-
         sendLogs();
 
         while (readDataNext())
@@ -1063,6 +1063,20 @@ void TCPHandler::sendInsertProfileEvents()
     sendProfileEvents();
 }
 
+void TCPHandler::sendTimezone()
+{
+    if (client_tcp_protocol_version < DBMS_MIN_PROTOCOL_VERSION_WITH_TIMEZONE_UPDATES)
+        return;
+
+    const String & tz = query_context->getSettingsRef().session_timezone.value;
+
+    LOG_DEBUG(log, "TCPHandler::sendTimezone(): {}", tz);
+    writeVarUInt(Protocol::Server::TimezoneUpdate, *out);
+    writeStringBinary(tz, *out);
+    out->next();
+}
+
+
 bool TCPHandler::receiveProxyHeader()
 {
     if (in->eof())
diff --git a/src/Server/TCPHandler.h b/src/Server/TCPHandler.h
index d18ffc5afe85..629738fa16fd 100644
--- a/src/Server/TCPHandler.h
+++ b/src/Server/TCPHandler.h
@@ -274,6 +274,7 @@ class TCPHandler : public Poco::Net::TCPServerConnection
     void sendProfileEvents();
     void sendSelectProfileEvents();
     void sendInsertProfileEvents();
+    void sendTimezone();
 
     /// Creates state.block_in/block_out for blocks read/write, depending on whether compression is enabled.
     void initBlockInput();
diff --git a/src/Storages/MergeTree/IMergeTreeDataPart.cpp b/src/Storages/MergeTree/IMergeTreeDataPart.cpp
index 8019ca938e01..cf2d1b19326f 100644
--- a/src/Storages/MergeTree/IMergeTreeDataPart.cpp
+++ b/src/Storages/MergeTree/IMergeTreeDataPart.cpp
@@ -1053,7 +1053,7 @@ void IMergeTreeDataPart::loadPartitionAndMinMaxIndex()
         DayNum max_date;
         MergeTreePartInfo::parseMinMaxDatesFromPartName(name, min_date, max_date);
 
-        const auto & date_lut = DateLUT::instance();
+        const auto & date_lut = DateLUT::serverTimezoneInstance();
         partition = MergeTreePartition(date_lut.toNumYYYYMM(min_date));
         minmax_idx = std::make_shared<MinMaxIndex>(min_date, max_date);
     }
diff --git a/src/Storages/MergeTree/MergeFromLogEntryTask.cpp b/src/Storages/MergeTree/MergeFromLogEntryTask.cpp
index 5cee402f88c6..586d8b8ff83c 100644
--- a/src/Storages/MergeTree/MergeFromLogEntryTask.cpp
+++ b/src/Storages/MergeTree/MergeFromLogEntryTask.cpp
@@ -57,7 +57,7 @@ ReplicatedMergeMutateTaskBase::PrepareResult MergeFromLogEntryTask::prepare()
     {
         LOG_INFO(log, "Will try to fetch part {} until '{}' because this part assigned to recompression merge. "
             "Source replica {} will try to merge this part first", entry.new_part_name,
-            DateLUT::instance().timeToString(entry.create_time + storage_settings_ptr->try_fetch_recompressed_part_timeout.totalSeconds()), entry.source_replica);
+            DateLUT::serverTimezoneInstance().timeToString(entry.create_time + storage_settings_ptr->try_fetch_recompressed_part_timeout.totalSeconds()), entry.source_replica);
             /// Waiting other replica to recompress part. No need to check it.
             return PrepareResult{
                 .prepared_successfully = false,
diff --git a/src/Storages/MergeTree/MergeTreeDataWriter.cpp b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
index da2b9608e435..7e306880e9ce 100644
--- a/src/Storages/MergeTree/MergeTreeDataWriter.cpp
+++ b/src/Storages/MergeTree/MergeTreeDataWriter.cpp
@@ -116,7 +116,7 @@ void updateTTL(
 
     if (const ColumnUInt16 * column_date = typeid_cast<const ColumnUInt16 *>(ttl_column.get()))
     {
-        const auto & date_lut = DateLUT::instance();
+        const auto & date_lut = DateLUT::serverTimezoneInstance();
         for (const auto & val : column_date->getData())
             ttl_info.update(date_lut.fromDayNum(DayNum(val)));
     }
@@ -129,7 +129,7 @@ void updateTTL(
     {
         if (typeid_cast<const ColumnUInt16 *>(&column_const->getDataColumn()))
         {
-            const auto & date_lut = DateLUT::instance();
+            const auto & date_lut = DateLUT::serverTimezoneInstance();
             ttl_info.update(date_lut.fromDayNum(DayNum(column_const->getValue<UInt16>())));
         }
         else if (typeid_cast<const ColumnUInt32 *>(&column_const->getDataColumn()))
@@ -383,7 +383,7 @@ MergeTreeDataWriter::TemporaryPart MergeTreeDataWriter::writeTempPartImpl(
         DayNum min_date(minmax_idx->hyperrectangle[data.minmax_idx_date_column_pos].left.get<UInt64>());
         DayNum max_date(minmax_idx->hyperrectangle[data.minmax_idx_date_column_pos].right.get<UInt64>());
 
-        const auto & date_lut = DateLUT::instance();
+        const auto & date_lut = DateLUT::serverTimezoneInstance();
 
         auto min_month = date_lut.toNumYYYYMM(min_date);
         auto max_month = date_lut.toNumYYYYMM(max_date);
diff --git a/src/Storages/MergeTree/MergeTreeMutationEntry.cpp b/src/Storages/MergeTree/MergeTreeMutationEntry.cpp
index feffffb57eab..cac26c5ac236 100644
--- a/src/Storages/MergeTree/MergeTreeMutationEntry.cpp
+++ b/src/Storages/MergeTree/MergeTreeMutationEntry.cpp
@@ -128,7 +128,7 @@ MergeTreeMutationEntry::MergeTreeMutationEntry(DiskPtr disk_, const String & pat
 
     LocalDateTime create_time_dt;
     *buf >> "create time: " >> create_time_dt >> "
";
-    create_time = DateLUT::instance().makeDateTime(
+    create_time = DateLUT::serverTimezoneInstance().makeDateTime(
         create_time_dt.year(), create_time_dt.month(), create_time_dt.day(),
         create_time_dt.hour(), create_time_dt.minute(), create_time_dt.second());
 
diff --git a/src/Storages/MergeTree/MergeTreePartInfo.cpp b/src/Storages/MergeTree/MergeTreePartInfo.cpp
index 84432a293d7f..e1b52d8a7b7c 100644
--- a/src/Storages/MergeTree/MergeTreePartInfo.cpp
+++ b/src/Storages/MergeTree/MergeTreePartInfo.cpp
@@ -148,7 +148,7 @@ void MergeTreePartInfo::parseMinMaxDatesFromPartName(const String & part_name, D
         throw Exception(ErrorCodes::BAD_DATA_PART_NAME, "Unexpected part name: {}", part_name);
     }
 
-    const auto & date_lut = DateLUT::instance();
+    const auto & date_lut = DateLUT::serverTimezoneInstance();
 
     min_date = date_lut.YYYYMMDDToDayNum(min_yyyymmdd);
     max_date = date_lut.YYYYMMDDToDayNum(max_yyyymmdd);
@@ -219,7 +219,7 @@ String MergeTreePartInfo::getPartNameV1() const
 
 String MergeTreePartInfo::getPartNameV0(DayNum left_date, DayNum right_date) const
 {
-    const auto & date_lut = DateLUT::instance();
+    const auto & date_lut = DateLUT::serverTimezoneInstance();
 
     /// Directory name for the part has form: `YYYYMMDD_YYYYMMDD_N_N_L`.
 
diff --git a/src/Storages/MergeTree/MergeTreePartition.cpp b/src/Storages/MergeTree/MergeTreePartition.cpp
index 62ad658730ea..bce33438229b 100644
--- a/src/Storages/MergeTree/MergeTreePartition.cpp
+++ b/src/Storages/MergeTree/MergeTreePartition.cpp
@@ -247,7 +247,7 @@ String MergeTreePartition::getID(const Block & partition_key_sample) const
                 result += '-';
 
             if (typeid_cast<const DataTypeDate *>(partition_key_sample.getByPosition(i).type.get()))
-                result += toString(DateLUT::instance().toNumYYYYMMDD(DayNum(value[i].safeGet<UInt64>())));
+                result += toString(DateLUT::serverTimezoneInstance().toNumYYYYMMDD(DayNum(value[i].safeGet<UInt64>())));
             else if (typeid_cast<const DataTypeIPv4 *>(partition_key_sample.getByPosition(i).type.get()))
                 result += toString(value[i].get<IPv4>().toUnderType());
             else
@@ -331,7 +331,7 @@ std::optional<Row> MergeTreePartition::tryParseValueFromID(const String & partit
                     throw Exception(
                         ErrorCodes::INVALID_PARTITION_VALUE, "Cannot parse partition_id: got unexpected Date: {}", date_yyyymmdd);
 
-                UInt32 date = DateLUT::instance().YYYYMMDDToDayNum(date_yyyymmdd);
+                UInt32 date = DateLUT::serverTimezoneInstance().YYYYMMDDToDayNum(date_yyyymmdd);
                 res.emplace_back(date);
                 break;
             }
diff --git a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp
index 79b0beb09330..ac956433eab7 100644
--- a/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp
+++ b/src/Storages/MergeTree/ReplicatedMergeTreeLogEntry.cpp
@@ -199,7 +199,7 @@ void ReplicatedMergeTreeLogEntryData::readText(ReadBuffer & in, MergeTreeDataFor
     {
         LocalDateTime create_time_dt;
         in >> "create_time: " >> create_time_dt >> "
";
-        create_time = DateLUT::instance().makeDateTime(
+        create_time = DateLUT::serverTimezoneInstance().makeDateTime(
             create_time_dt.year(), create_time_dt.month(), create_time_dt.day(),
             create_time_dt.hour(), create_time_dt.minute(), create_time_dt.second());
     }
diff --git a/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp b/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp
index 5e01cd96f6b7..1bbb246338cb 100644
--- a/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp
+++ b/src/Storages/MergeTree/ReplicatedMergeTreeMutationEntry.cpp
@@ -38,7 +38,7 @@ void ReplicatedMergeTreeMutationEntry::readText(ReadBuffer & in)
 
     LocalDateTime create_time_dt;
     in >> "create time: " >> create_time_dt >> "
";
-    create_time = DateLUT::instance().makeDateTime(
+    create_time = DateLUT::serverTimezoneInstance().makeDateTime(
         create_time_dt.year(), create_time_dt.month(), create_time_dt.day(),
         create_time_dt.hour(), create_time_dt.minute(), create_time_dt.second());
 
diff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp
index bb99e21e4abc..ae4e8ac0a8f1 100644
--- a/src/Storages/StorageReplicatedMergeTree.cpp
+++ b/src/Storages/StorageReplicatedMergeTree.cpp
@@ -5591,7 +5591,7 @@ String getPartNamePossiblyFake(MergeTreeDataFormatVersion format_version, const
     if (format_version < MERGE_TREE_DATA_MIN_FORMAT_VERSION_WITH_CUSTOM_PARTITIONING)
     {
         /// The date range is all month long.
-        const auto & lut = DateLUT::instance();
+        const auto & lut = DateLUT::serverTimezoneInstance();
         time_t start_time = lut.YYYYMMDDToDate(parse<UInt32>(part_info.partition_id + "01"));
         DayNum left_date = DayNum(lut.toDayNum(start_time).toUnderType());
         DayNum right_date = DayNum(static_cast<size_t>(left_date) + lut.daysInMonth(start_time) - 1);
diff --git a/src/Storages/WindowView/StorageWindowView.cpp b/src/Storages/WindowView/StorageWindowView.cpp
index 7fca9b5f078c..242e8e5d5709 100644
--- a/src/Storages/WindowView/StorageWindowView.cpp
+++ b/src/Storages/WindowView/StorageWindowView.cpp
@@ -1340,7 +1340,7 @@ ASTPtr StorageWindowView::innerQueryParser(const ASTSelectQuery & query)
         time_zone = &DateLUT::instance(window_view_timezone);
     }
     else
-        time_zone = &DateLUT::instance();
+        time_zone = &DateLUT::serverTimezoneInstance();
 
     return result;
 }
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index 46bd0da4236a..893a2bae74ff 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -2134,6 +2134,8 @@ seektable
 sequenceCount
 sequenceMatch
 sequenceNextNode
+serverTimeZone
+serverTimezone
 serverUUID
 sessionCacheSize
 sessionIdContext
