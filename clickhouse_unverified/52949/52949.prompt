You will be provided with a partial code base and an issue statement explaining a problem to resolve.

<issue>
Nested column: Segfault after adding new column to existing ReplicatedMergeTree table
**Describe what's wrong**

After adding a new column to an existing, long-lived, and steadily written-to `ReplicatedMergeTree` table, we saw segfaults that seemed to occur in worker threads related to replication (or part merging?). 

> A link to reproducer in [https://fiddle.clickhouse.com/](https://fiddle.clickhouse.com/).

TODO: This is not a crash experienced at query time. Is it possible to construct a fiddler environment to repro replication/merging related crashes like this? Open to all feedback!

**Does it reproduce on recent release?**

We are experiencing this on a LTS version of Clickhouse: `clickhouse-server:23.3.2.37`. We are also seeing this on the most recent patch version of that `23.3` release: `23.3.8.21`.

**Enable crash reporting**

TODO/TBD

**How to reproduce**

* Which ClickHouse server version to use

`23.3`: `23.3.2.37` or `23.3.8.21` confirmed

* Which interface to use, if matters

N/A

* Non-default settings, if any

N/A 

* `CREATE TABLE` statements for all tables involved

Create a table with this shape (NB: nested column of a map type)
```
CREATE TABLE IF NOT EXISTS cool_table(
 "nested_things" Nested(
   otherColumns...
   "string_map" Map(LowCardinality(String), String),
   otherColumns...
 ) 
) ReplicatedMergeTree(...)
```

Write some data to this table, let it replicate/merge/etc, and then run an alter like this to add a new column (which you don't need to insert any values into). The intent of this DDL is to add a map from low cardinality strings to floats within the nested type that already exists on the table.
```
ALTER TABLE cool_table
  ADD COLUMN IF NOT EXISTS `nested_things.float_map` Array(Map(LowCardinality(String), Float64)) AFTER `string_map`;
```

* Sample data for all these tables, use [clickhouse-obfuscator](https://github.com/ClickHouse/ClickHouse/blob/master/programs/obfuscator/Obfuscator.cpp#L42-L80) if necessary

TODO/TBD

* Queries to run that lead to unexpected result

No queries needed, but you could consider one stream of inserts into the columns of the original table schema (not needing to start inserting values into the new column, for example).

**Expected behavior**

Replication/merging after additive DDLs (adding a column, and not even writing to it yet) should not crash the server process, even if there are existing file parts on-disk that predate the schema change.

**Error message and/or stacktrace**

```
########################################
2023-07-19 14:36:03.599 EDT (version 23.3.2.37 (official build), build id: 2F54F417C7E2A810B4069A69AC827CF045266F9E) (from thread 243) (query_id: 10d2e694-52db-49ed-812b-446ce4901294::78110_0_2675_6) (query: ) Received signal Segmentation fault (11)
2023-07-19 14:36:03.599 EDT Address: 0x44e3380. Access: write. Attempted access has violated the permissions assigned to the memory area.
2023-07-19 14:36:03.599 EDT Stack trace: 0x13c1c1c7 0x12b09f83 0x12b243c4 0x12b2498c 0x12b0a430 0x12b02c41 0x13c1a105 0x146852ea 0x1469414e 0x14a14f95 0x14a14b06 0x14a2e70a 0x14a2377b 0x14a22b68 0x14a33757 0x14a33913 0x144e93ef 0x144e934b 0x144ee3ba 0x1478614c 0x14785014 0x89d430c 0x89d3f8a 0xe2b5625 0xe2b8195 0xe2b13f3 0xe2b7061 0x7f87b006eb43 0x7f87b0100a00
2023-07-19 14:36:03.599 EDT 2. ? @ 0x13c1c1c7 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 3. DB::SerializationArray::enumerateStreams(DB::ISerialization::EnumerateStreamsSettings&, std::function<void (DB::ISerialization::SubstreamPath const&)> const&, DB::ISerialization::SubstreamData const&) const @ 0x12b09f83 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 4. DB::SerializationMap::enumerateStreams(DB::ISerialization::EnumerateStreamsSettings&, std::function<void (DB::ISerialization::SubstreamPath const&)> const&, DB::ISerialization::SubstreamData const&) const @ 0x12b243c4 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 5. DB::SerializationNamed::enumerateStreams(DB::ISerialization::EnumerateStreamsSettings&, std::function<void (DB::ISerialization::SubstreamPath const&)> const&, DB::ISerialization::SubstreamData const&) const @ 0x12b2498c in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 6. DB::SerializationArray::enumerateStreams(DB::ISerialization::EnumerateStreamsSettings&, std::function<void (DB::ISerialization::SubstreamPath const&)> const&, DB::ISerialization::SubstreamData const&) const @ 0x12b0a430 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 7. DB::ISerialization::enumerateStreams(std::function<void (DB::ISerialization::SubstreamPath const&)> const&, std::shared_ptr<DB::IDataType const> const&, COW<DB::IColumn>::immutable_ptr<DB::IColumn> const&) const @ 0x12b02c41 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 8. DB::fillMissingColumns(std::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn>>>&, unsigned long, DB::NamesAndTypesList const&, DB::NamesAndTypesList const&, std::unordered_set<String, std::hash<String>, std::equal_to<String>, std::allocator<String>> const&, std::shared_ptr<DB::StorageInMemoryMetadata const>) @ 0x13c1a105 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 9. DB::IMergeTreeReader::fillMissingColumns(std::vector<COW<DB::IColumn>::immutable_ptr<DB::IColumn>, std::allocator<COW<DB::IColumn>::immutable_ptr<DB::IColumn>>>&, bool&, unsigned long) const @ 0x146852ea in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 10. DB::MergeTreeSequentialSource::generate() @ 0x1469414e in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 11. DB::ISource::tryGenerate() @ 0x14a14f95 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 12. DB::ISource::work() @ 0x14a14b06 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 13. DB::ExecutionThreadContext::executeTask() @ 0x14a2e70a in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 14. DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x14a2377b in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 15. DB::PipelineExecutor::executeStep(std::atomic<bool>*) @ 0x14a22b68 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 16. DB::PullingPipelineExecutor::pull(DB::Chunk&) @ 0x14a33757 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 17. DB::PullingPipelineExecutor::pull(DB::Block&) @ 0x14a33913 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 18. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::executeImpl() @ 0x144e93ef in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 19. DB::MergeTask::ExecuteAndFinalizeHorizontalPart::execute() @ 0x144e934b in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 20. DB::MergeTask::execute() @ 0x144ee3ba in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 21. DB::ReplicatedMergeMutateTaskBase::executeImpl() @ 0x1478614c in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 22. DB::ReplicatedMergeMutateTaskBase::executeStep() @ 0x14785014 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 23. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::routine(std::shared_ptr<DB::TaskRuntimeData>) @ 0x89d430c in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 24. DB::MergeTreeBackgroundExecutor<DB::DynamicRuntimeQueue>::threadFunction() @ 0x89d3f8a in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 25. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false>, void*>) @ 0xe2b5625 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 26. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false>>::scheduleImpl<void>(std::function<void ()>, long, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0xe2b8195 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 27. ThreadPoolImpl<std::thread>::worker(std::__list_iterator<std::thread, void*>) @ 0xe2b13f3 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 28. ? @ 0xe2b7061 in /usr/bin/clickhouse
2023-07-19 14:36:03.599 EDT 29. ? @ 0x7f87b006eb43 in ?
2023-07-19 14:36:03.599 EDT 30. ? @ 0x7f87b0100a00 in ?
2023-07-19 14:36:03.748 EDT Integrity check of the executable successfully passed (checksum: 2391C2E4C30B9E637CFE4E448BCD472A)
```

**Additional context**

This segfault leads to a k8s crash loop. Upon restart the server, would resume trying to work against the replication queue and reproduce the crash. The container would be stabilized/healthy once the table was detached (something we've learned can be done a few ways). Note: we hadn't started inserting values into this column yet. Dropping the column and cleaning up ZK metadata using `SYSTEM` commands on the replica stabilized the container. Restoring the column reliably reproduces the issue in some of our higher-write-volume (and larger-shard-count, e.g. 8 shards x 2 replicas) installations, but interestingly we did not see this is some low-write 2x2 shard*replica installations.
</issue>

I need you to solve the provided issue by generating a code fix that can be applied directly to the repository

Respond below:
