{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28914,
  "instance_id": "ClickHouse__ClickHouse-28914",
  "issue_numbers": [
    "27511"
  ],
  "base_commit": "20d8523a2ebe22c93266e56fc097e273e4c8c68b",
  "patch": "diff --git a/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp b/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp\nnew file mode 100644\nindex 000000000000..8569e8f9c8c0\n--- /dev/null\n+++ b/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp\n@@ -0,0 +1,98 @@\n+#include <AggregateFunctions/IAggregateFunction.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <AggregateFunctions/FactoryHelpers.h>\n+#include <Common/ExponentiallySmoothedCounter.h>\n+#include <Common/FieldVisitorConvertToNumber.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteHelpers.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+\n+/** See the comments in ExponentiallySmoothedCounter.h\n+  */\n+class AggregateFunctionExponentialMovingAverage final\n+    : public IAggregateFunctionDataHelper<ExponentiallySmoothedAverage, AggregateFunctionExponentialMovingAverage>\n+{\n+private:\n+    String name;\n+    Float64 half_decay;\n+\n+public:\n+    AggregateFunctionExponentialMovingAverage(const DataTypes & argument_types_, const Array & params)\n+        : IAggregateFunctionDataHelper<ExponentiallySmoothedAverage, AggregateFunctionExponentialMovingAverage>(argument_types_, params)\n+    {\n+        if (params.size() != 1)\n+            throw Exception{\"Aggregate function \" + getName() + \" requires exactly one parameter: half decay time.\",\n+                ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH};\n+\n+        half_decay = applyVisitor(FieldVisitorConvertToNumber<Float64>(), params[0]);\n+    }\n+\n+    String getName() const override\n+    {\n+        return \"exponentialMovingAverage\";\n+    }\n+\n+    DataTypePtr getReturnType() const override\n+    {\n+        return std::make_shared<DataTypeNumber<Float64>>();\n+    }\n+\n+    bool allocatesMemoryInArena() const override { return false; }\n+\n+    void add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override\n+    {\n+        const auto & value = columns[0]->getFloat64(row_num);\n+        const auto & time = columns[1]->getFloat64(row_num);\n+        this->data(place).add(value, time, half_decay);\n+    }\n+\n+    void merge(AggregateDataPtr __restrict place, ConstAggregateDataPtr rhs, Arena *) const override\n+    {\n+        this->data(place).merge(this->data(rhs), half_decay);\n+    }\n+\n+    void serialize(ConstAggregateDataPtr __restrict place, WriteBuffer & buf) const override\n+    {\n+        writeBinary(this->data(place).value, buf);\n+        writeBinary(this->data(place).time, buf);\n+    }\n+\n+    void deserialize(AggregateDataPtr __restrict place, ReadBuffer & buf, Arena *) const override\n+    {\n+        readBinary(this->data(place).value, buf);\n+        readBinary(this->data(place).time, buf);\n+    }\n+\n+    void insertResultInto(AggregateDataPtr __restrict place, IColumn & to, Arena *) const override\n+    {\n+        auto & column = assert_cast<ColumnVector<Float64> &>(to);\n+        column.getData().push_back(this->data(place).get(half_decay));\n+    }\n+};\n+\n+void registerAggregateFunctionExponentialMovingAverage(AggregateFunctionFactory & factory)\n+{\n+    factory.registerFunction(\"exponentialMovingAverage\",\n+        [](const std::string & name, const DataTypes & argument_types, const Array & params, const Settings *) -> AggregateFunctionPtr\n+        {\n+            assertBinary(name, argument_types);\n+            for (const auto & type : argument_types)\n+                if (!isNumber(*type))\n+                    throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                        \"Both arguments for aggregate function {} must have numeric type, got {}\", name, type->getName());\n+            return std::make_shared<AggregateFunctionExponentialMovingAverage>(argument_types, params);\n+        });\n+}\n+\n+}\ndiff --git a/src/AggregateFunctions/registerAggregateFunctions.cpp b/src/AggregateFunctions/registerAggregateFunctions.cpp\nindex dd1f292a3926..5d0af7192906 100644\n--- a/src/AggregateFunctions/registerAggregateFunctions.cpp\n+++ b/src/AggregateFunctions/registerAggregateFunctions.cpp\n@@ -50,7 +50,9 @@ void registerAggregateFunctionWelchTTest(AggregateFunctionFactory &);\n void registerAggregateFunctionStudentTTest(AggregateFunctionFactory &);\n void registerAggregateFunctionSingleValueOrNull(AggregateFunctionFactory &);\n void registerAggregateFunctionSequenceNextNode(AggregateFunctionFactory &);\n+void registerAggregateFunctionExponentialMovingAverage(AggregateFunctionFactory &);\n void registerAggregateFunctionSparkbar(AggregateFunctionFactory &);\n+void registerAggregateFunctionIntervalLengthSum(AggregateFunctionFactory &);\n \n class AggregateFunctionCombinatorFactory;\n void registerAggregateFunctionCombinatorIf(AggregateFunctionCombinatorFactory &);\n@@ -66,8 +68,6 @@ void registerAggregateFunctionCombinatorDistinct(AggregateFunctionCombinatorFact\n \n void registerWindowFunctions(AggregateFunctionFactory & factory);\n \n-void registerAggregateFunctionIntervalLengthSum(AggregateFunctionFactory &);\n-\n void registerAggregateFunctions()\n {\n     {\n@@ -116,11 +116,11 @@ void registerAggregateFunctions()\n         registerAggregateFunctionWelchTTest(factory);\n         registerAggregateFunctionStudentTTest(factory);\n         registerAggregateFunctionSingleValueOrNull(factory);\n-\n-        registerWindowFunctions(factory);\n-\n         registerAggregateFunctionIntervalLengthSum(factory);\n+        registerAggregateFunctionExponentialMovingAverage(factory);\n         registerAggregateFunctionSparkbar(factory);\n+\n+        registerWindowFunctions(factory);\n     }\n \n     {\ndiff --git a/src/Common/ExponentiallySmoothedCounter.h b/src/Common/ExponentiallySmoothedCounter.h\nnew file mode 100644\nindex 000000000000..28d4e5e25c1a\n--- /dev/null\n+++ b/src/Common/ExponentiallySmoothedCounter.h\n@@ -0,0 +1,114 @@\n+#pragma once\n+\n+#include <cmath>\n+#include <limits>\n+\n+\n+namespace DB\n+{\n+\n+/** https://en.wikipedia.org/wiki/Exponential_smoothing\n+  *\n+  * Exponentially smoothed average over time is weighted average with weight proportional to negative exponent of the time passed.\n+  * For example, the last value is taken with weight 1/2, the value one second ago with weight 1/4, two seconds ago - 1/8, etc.\n+  * It can be understood as an average over sliding window, but with different kernel.\n+  *\n+  * As an advantage, it is easy to update. Instead of collecting values and calculating a series of x1 / 2 + x2 / 4 + x3 / 8...\n+  * just calculate x_old / 2 + x_new / 2.\n+  *\n+  * It is often used for resource usage metrics. For example, \"load average\" in Linux is exponentially smoothed moving average.\n+  * We can use exponentially smoothed counters in query scheduler.\n+  */\n+struct ExponentiallySmoothedAverage\n+{\n+    /// The sum. It contains the last value and all previous values scaled accordingly to the difference of their time to the reference time.\n+    /// Older values are summed with exponentially smaller coefficients.\n+    /// To obtain the average, you have to divide this value to the sum of all coefficients (see 'sumWeights').\n+\n+    double value = 0;\n+\n+    /// The point of reference. You can translate the value to a different point of reference (see 'remap').\n+    /// You can imagine that the value exponentially decays over time.\n+    /// But it is also meaningful to treat the whole counters as constants over time but in another non-linear coordinate system,\n+    /// that inflates over time, while the counter itself does not change\n+    /// (it continues to be the same physical quantity, but only changes its representation in the \"usual\" coordinate system).\n+\n+    /// Recap: the whole counter is one dimensional and it can be represented as a curve formed by two dependent coordinates in 2d plane,\n+    /// the space can be represented by (value, time) coordinates, and the curves will be exponentially decaying over time,\n+    /// alternatively the space can be represented by (exponentially_adjusted_value, time) and then the curves will be constant over time.\n+\n+    /// Also useful analogy is the exponential representation of a number: x = a * exp(b) = a * e (where e = exp(b))\n+    /// a number x is represented by a curve in 2d plane that can be parametrized by coordinates (a, b) or (a, e).\n+\n+    double time = 0;\n+\n+\n+    ExponentiallySmoothedAverage()\n+    {\n+    }\n+\n+    ExponentiallySmoothedAverage(double current_value, double current_time)\n+        : value(current_value), time(current_time)\n+    {\n+    }\n+\n+    /// How much value decays after time_passed.\n+    static double scale(double time_passed, double half_decay_time)\n+    {\n+        return exp2(-time_passed / half_decay_time);\n+    }\n+\n+    /// Sum of weights of all values. Divide by it to get the average.\n+    static double sumWeights(double half_decay_time)\n+    {\n+        double k = scale(1.0, half_decay_time);\n+        return 1 / (1 - k);\n+    }\n+\n+    /// Obtain the same counter in another point of reference.\n+    ExponentiallySmoothedAverage remap(double current_time, double half_decay_time) const\n+    {\n+        return ExponentiallySmoothedAverage(value * scale(current_time - time, half_decay_time), current_time);\n+    }\n+\n+    /// Merge two counters. It is done by moving to the same point of reference and summing the values.\n+    static ExponentiallySmoothedAverage merge(const ExponentiallySmoothedAverage & a, const ExponentiallySmoothedAverage & b, double half_decay_time)\n+    {\n+        if (a.time > b.time)\n+            return ExponentiallySmoothedAverage(a.value + b.remap(a.time, half_decay_time).value, a.time);\n+        if (a.time < b.time)\n+            return ExponentiallySmoothedAverage(b.value + a.remap(b.time, half_decay_time).value, b.time);\n+\n+        return ExponentiallySmoothedAverage(a.value + b.value, a.time);\n+    }\n+\n+    void merge(const ExponentiallySmoothedAverage & other, double half_decay_time)\n+    {\n+        *this = merge(*this, other, half_decay_time);\n+    }\n+\n+    void add(double new_value, double current_time, double half_decay_time)\n+    {\n+        merge(ExponentiallySmoothedAverage(new_value, current_time), half_decay_time);\n+    }\n+\n+    /// Calculate the average from the sum.\n+    double get(double half_decay_time) const\n+    {\n+        return value / sumWeights(half_decay_time);\n+    }\n+\n+    double get(double current_time, double half_decay_time) const\n+    {\n+        return remap(current_time, half_decay_time).get(half_decay_time);\n+    }\n+\n+    /// Compare two counters (by moving to the same point of reference and comparing sums).\n+    /// You can store the counters in container and sort it without changing the stored values over time.\n+    bool less(const ExponentiallySmoothedAverage & other, double half_decay_time) const\n+    {\n+        return remap(other.time, half_decay_time).value < other.value;\n+    }\n+};\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/2020_exponential_smoothing.reference b/tests/queries/0_stateless/2020_exponential_smoothing.reference\nnew file mode 100644\nindex 000000000000..8ebf4c3c066f\n--- /dev/null\n+++ b/tests/queries/0_stateless/2020_exponential_smoothing.reference\n@@ -0,0 +1,130 @@\n+1\t0\t0.5\n+0\t1\t0.25\n+0\t2\t0.125\n+0\t3\t0.0625\n+0\t4\t0.03125\n+0\t5\t0.015625\n+0\t6\t0.0078125\n+0\t7\t0.00390625\n+0\t8\t0.001953125\n+0\t9\t0.0009765625\n+1\t0\t0.067\n+0\t1\t0.062\n+0\t2\t0.058\n+0\t3\t0.054\n+0\t4\t0.051\n+0\t5\t0.047\n+0\t6\t0.044\n+0\t7\t0.041\n+0\t8\t0.038\n+0\t9\t0.036\n+0\t0\t0\n+1\t1\t0.5\n+2\t2\t1.25\n+3\t3\t2.125\n+4\t4\t3.0625\n+5\t5\t4.03125\n+6\t6\t5.015625\n+7\t7\t6.0078125\n+8\t8\t7.00390625\n+9\t9\t8.001953125\n+1\t0\t0.067\t\u2588\u2588\u2588\u258e\n+0\t1\t0.062\t\u2588\u2588\u2588\n+0\t2\t0.058\t\u2588\u2588\u258a\n+0\t3\t0.054\t\u2588\u2588\u258b\n+0\t4\t0.051\t\u2588\u2588\u258c\n+0\t5\t0.047\t\u2588\u2588\u258e\n+0\t6\t0.044\t\u2588\u2588\u258f\n+0\t7\t0.041\t\u2588\u2588\n+0\t8\t0.038\t\u2588\u258a\n+0\t9\t0.036\t\u2588\u258b\n+0\t10\t0.033\t\u2588\u258b\n+0\t11\t0.031\t\u2588\u258c\n+0\t12\t0.029\t\u2588\u258d\n+0\t13\t0.027\t\u2588\u258e\n+0\t14\t0.025\t\u2588\u258e\n+0\t15\t0.024\t\u2588\u258f\n+0\t16\t0.022\t\u2588\n+0\t17\t0.021\t\u2588\n+0\t18\t0.019\t\u258a\n+0\t19\t0.018\t\u258a\n+0\t20\t0.017\t\u258b\n+0\t21\t0.016\t\u258b\n+0\t22\t0.015\t\u258b\n+0\t23\t0.014\t\u258b\n+0\t24\t0.013\t\u258b\n+1\t25\t0.079\t\u2588\u2588\u2588\u258a\n+1\t26\t0.14\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n+1\t27\t0.198\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+1\t28\t0.252\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\n+1\t29\t0.302\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n+1\t30\t0.349\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+1\t31\t0.392\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\n+1\t32\t0.433\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t33\t0.471\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\n+1\t34\t0.506\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e\n+1\t35\t0.539\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+1\t36\t0.57\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\n+1\t37\t0.599\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+1\t38\t0.626\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e\n+1\t39\t0.651\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\n+1\t40\t0.674\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t41\t0.696\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t42\t0.716\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t43\t0.735\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t44\t0.753\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t45\t0.77\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+1\t46\t0.785\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e\n+1\t47\t0.8\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+1\t48\t0.813\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+1\t49\t0.825\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258e\n+1\t0\t0.5\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\n+0\t1\t0.25\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258c\n+0\t2\t0.125\t\u2588\u2588\u2588\u2588\u2588\u2588\u258e\n+0\t3\t0.062\t\u2588\u2588\u2588\n+0\t4\t0.031\t\u2588\u258c\n+1\t5\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t6\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t7\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t8\t0.064\t\u2588\u2588\u2588\u258f\n+0\t9\t0.032\t\u2588\u258c\n+1\t10\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t11\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t12\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t13\t0.065\t\u2588\u2588\u2588\u258f\n+0\t14\t0.032\t\u2588\u258c\n+1\t15\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t16\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t17\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t18\t0.065\t\u2588\u2588\u2588\u258f\n+0\t19\t0.032\t\u2588\u258c\n+1\t20\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t21\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t22\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t23\t0.065\t\u2588\u2588\u2588\u258f\n+0\t24\t0.032\t\u2588\u258c\n+1\t25\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t26\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t27\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t28\t0.065\t\u2588\u2588\u2588\u258f\n+0\t29\t0.032\t\u2588\u258c\n+1\t30\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t31\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t32\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t33\t0.065\t\u2588\u2588\u2588\u258f\n+0\t34\t0.032\t\u2588\u258c\n+1\t35\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t36\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t37\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t38\t0.065\t\u2588\u2588\u2588\u258f\n+0\t39\t0.032\t\u2588\u258c\n+1\t40\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t41\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t42\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t43\t0.065\t\u2588\u2588\u2588\u258f\n+0\t44\t0.032\t\u2588\u258c\n+1\t45\t0.516\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258b\n+0\t46\t0.258\t\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u2588\u258a\n+0\t47\t0.129\t\u2588\u2588\u2588\u2588\u2588\u2588\u258d\n+0\t48\t0.065\t\u2588\u2588\u2588\u258f\n+0\t49\t0.032\t\u2588\u258c\ndiff --git a/tests/queries/0_stateless/2020_exponential_smoothing.sql b/tests/queries/0_stateless/2020_exponential_smoothing.sql\nnew file mode 100644\nindex 000000000000..a210225453a1\n--- /dev/null\n+++ b/tests/queries/0_stateless/2020_exponential_smoothing.sql\n@@ -0,0 +1,32 @@\n+SELECT number = 0 AS value, number AS time, exponentialMovingAverage(1)(value, time) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS exp_smooth FROM numbers(10);\n+SELECT value, time, round(exp_smooth, 3) FROM (SELECT number = 0 AS value, number AS time, exponentialMovingAverage(10)(value, time) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS exp_smooth FROM numbers(10));\n+\n+SELECT number AS value, number AS time, exponentialMovingAverage(1)(value, time) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS exp_smooth FROM numbers(10);\n+\n+SELECT\n+    value,\n+    time,\n+    round(exp_smooth, 3),\n+    bar(exp_smooth, 0, 1, 50) AS bar\n+FROM\n+(\n+    SELECT\n+        (number = 0) OR (number >= 25) AS value,\n+        number AS time,\n+        exponentialMovingAverage(10)(value, time) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS exp_smooth\n+    FROM numbers(50)\n+);\n+\n+SELECT\n+    value,\n+    time,\n+    round(exp_smooth, 3),\n+    bar(exp_smooth, 0, 1, 50) AS bar\n+FROM\n+(\n+    SELECT\n+        (number % 5) = 0 AS value,\n+        number AS time,\n+        exponentialMovingAverage(1)(value, time) OVER (ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW) AS exp_smooth\n+    FROM numbers(50)\n+);\ndiff --git a/tests/queries/0_stateless/2021_exponential_sum.reference b/tests/queries/0_stateless/2021_exponential_sum.reference\nnew file mode 100644\nindex 000000000000..5bd77479cf75\n--- /dev/null\n+++ b/tests/queries/0_stateless/2021_exponential_sum.reference\n@@ -0,0 +1,8 @@\n+0.0009765625\n+0.0009775171065493646\n+0.0009775171065493646\n+0.0009775171065493646\n+0.0009775171065493646\n+0.0009775171065493646\n+0.0009775171065493646\n+0.0009775171065493646\ndiff --git a/tests/queries/0_stateless/2021_exponential_sum.sql b/tests/queries/0_stateless/2021_exponential_sum.sql\nnew file mode 100644\nindex 000000000000..8ab7638029cc\n--- /dev/null\n+++ b/tests/queries/0_stateless/2021_exponential_sum.sql\n@@ -0,0 +1,9 @@\n+-- Check that it is deterministic\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(10);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(100);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(1000);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(10000);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(100000);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(1000000);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(10000000);\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM numbers_mt(100000000);\ndiff --git a/tests/queries/0_stateless/2021_exponential_sum_shard.reference b/tests/queries/0_stateless/2021_exponential_sum_shard.reference\nnew file mode 100644\nindex 000000000000..8453706a05a9\n--- /dev/null\n+++ b/tests/queries/0_stateless/2021_exponential_sum_shard.reference\n@@ -0,0 +1,5 @@\n+0.009775171065493644\n+0.009775171065493644\n+0.009775171065493644\n+0.009775171065493644\n+0.009775171065493644\ndiff --git a/tests/queries/0_stateless/2021_exponential_sum_shard.sql b/tests/queries/0_stateless/2021_exponential_sum_shard.sql\nnew file mode 100644\nindex 000000000000..49fde0fe2173\n--- /dev/null\n+++ b/tests/queries/0_stateless/2021_exponential_sum_shard.sql\n@@ -0,0 +1,6 @@\n+-- Check that it is deterministic\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM remote('127.0.0.{1..10}', numbers_mt(1000));\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM remote('127.0.0.{1..10}', numbers_mt(10000));\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM remote('127.0.0.{1..10}', numbers_mt(100000));\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM remote('127.0.0.{1..10}', numbers_mt(1000000));\n+WITH number % 10 = 0 AS value, number AS time SELECT exponentialMovingAverage(1)(value, time) AS exp_smooth FROM remote('127.0.0.{1..10}', numbers_mt(10000000));\n",
  "problem_statement": "Exponentially smoothed moving average as aggregate function.\nThe function will take two arguments: value and time and also parameter - half-decay period.\r\n\r\nExample: `exponentialMovingAverage(300)(temperature, timestamp)`\r\n\\- exponentially smoothed moving average of the temperature for the past five minutes at the latest point of time.\r\n\r\nThe state of the aggregate function is current averaged value and the latest time: (v, t).\r\nWhenever new value or new state is appeared, the state is updated as:\r\n\r\n```\r\nt_new = max(t_old, t)\r\nv_new = v_old * (1 / exp2((t_new - t_old) / half_decay)) + v * (1 - 1 / exp2((t_new - t_old) / half_decay))\r\n```\r\n(a sort of - did I write the formula correctly?)\r\n(does this way of calculation depend on the order of updates?)\n",
  "hints_text": ">  The state of the aggregate function is current averaged value and the latest time: (v, t).\r\n> (does this way of calculation depend on the order of updates?)\r\n\r\nI doubt that it's possible to combine multiple states (which holds only last value + timestamp) and get some reasonable answer.\r\nWhat if second state was calculated only from single value, so it's equals to this single value (or to zero), it would mess up result quite a bit.\r\n\r\nAnd just aggregate function, which returns only last value would have limited usage due: \r\nLast value could be calculated via regular arraySum and arithmetic functions without huge performance impact.  \r\n\r\nMain problem right now, is: without recursive functions like (arrayScan) it's impossible to calculate multiple values efficiently. (W/O calculation of whole sequence for each value)\n> I doubt that it's possible to combine multiple states (which holds only last value + timestamp) and get some reasonable answer.\r\n\r\nNo doubt. This is how exponential smoothing typically works.\r\nExponential smoothing is basically: `sum(value * exp(-elapsed_time * k))`\r\n\r\n> And just aggregate function, which returns only last value would have limited usage\r\n\r\nIt will be used for aggregated materialized views (antifraud, user summaries) and with window functions (smoothing over a window).\nI've received this reply in email but cannot see it on GitHub (probably a bug on GitHub).\r\nBy **Kenji Noguchi**:\r\n\r\n> It's nice to have the dedicated function. I'm looking forward to it.\r\n\r\n> In the mean time, CH can do ema using window. N is the number of elements, and k is the decay factor.\r\n\r\n```\r\nSET allow_experimental_window_functions = 1;\r\nWITH\r\n 3   AS n,\r\n 0.05 AS k,\r\n reverse(arrayMap(v->exp(-v * k), range(n))) as weights\r\nSELECT\r\n  number as original,\r\n  arraySum(arrayMap(pair -> pair.1 * pair.2, arrayZip(arrayResize(grouped_numbers, n, 0), weights))) / n as ema\r\nFROM (\r\n SELECT\r\n   number,\r\n   groupArray(number) OVER (ORDER BY number ASC ROWS BETWEEN n - 1 PRECEDING AND CURRENT ROW) AS grouped_numbers\r\n FROM (select number from system.numbers limit 10)\r\n)\r\n\r\n\u250c\u2500original\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500ema\u2500\u2510\r\n\u2502        0 \u2502                   0 \u2502\r\n\u2502        1 \u2502 0.31707647483350115 \u2502\r\n\u2502        2 \u2502   0.983743141500168 \u2502\r\n\u2502        3 \u2502  1.9357654223454428 \u2502\r\n\u2502        4 \u2502  2.8877877031907175 \u2502\r\n\u2502        5 \u2502   3.839809984035993 \u2502\r\n\u2502        6 \u2502  4.7918322648812675 \u2502\r\n\u2502        7 \u2502   5.743854545726542 \u2502\r\n\u2502        8 \u2502   6.695876826571818 \u2502\r\n\u2502        9 \u2502   7.647899107417093 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n> Off topic but SMA is much simpler\r\n\r\n```\r\nWITH 3 as n\r\nSELECT\r\n  number as original,\r\n  avg(number) OVER (ORDER BY number ASC ROWS BETWEEN n - 1 PRECEDING AND CURRENT ROW) AS sma\r\nFROM (select number from system.numbers limit 10)\r\n\r\n\u250c\u2500original\u2500\u252c\u2500sma\u2500\u2510\r\n\u2502        0 \u2502   0 \u2502\r\n\u2502        1 \u2502 0.5 \u2502\r\n\u2502        2 \u2502   1 \u2502\r\n\u2502        3 \u2502   2 \u2502\r\n\u2502        4 \u2502   3 \u2502\r\n\u2502        5 \u2502   4 \u2502\r\n\u2502        6 \u2502   5 \u2502\r\n\u2502        7 \u2502   6 \u2502\r\n\u2502        8 \u2502   7 \u2502\r\n\u2502        9 \u2502   8 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nWe should probably have `fold` aggregate function that would take a lambda: `fold(curr, acc -> curr * k + acc * (1 - k), values, 0 /* initial value */) over (order by timestamp)`.\r\nIt would be similar to `arrayFold` https://github.com/ClickHouse/ClickHouse/pull/21589\n@akuzm @alexey-milovidov @alz @filimonov , what about :\r\n`fold(c0, c1, ..., (c0, c0_acc, c1, c1_acc, ...) -> (c0 * (exp(-(c1-c1_acc)/C) as k) + c0_acc * (1 - k)), c1), (0, 0) /* initial value */) over (order by timestamp)`\r\n?\r\n\r\nSo, we have N columns, which are calculated by:\r\n```\r\nXn' = f(X, Xn, Y, Yn...)[0]\r\nYn' = f(X, Xn, Y, Yn...)[1]\r\n...\r\nZn' = f(X, Xn, Y, Yn...)[...]\r\n```\r\n\r\nIn case of exponential smoothing,\r\n```\r\nF[x](x, x_acc, t, t_acc) = C * x + (1-C) * x_acc\r\nF[t](x, x_acc, t, t_acc) = t\r\n```\r\nwhere C is `exp(-(t-t_acc)/T)`.\nBTW, aggregate functions can not use lambdas in its arguments currently :disappointed: \nYes, it cannot be calculated deterministically if data is arrived in arbitrary order.\r\nBut it's still usable for window functions or aggregation after ORDER BY.\r\nAnd even with non-deterministic calculation it gives decent results.",
  "created_at": "2021-09-12T05:27:38Z",
  "modified_files": [
    "b/src/AggregateFunctions/AggregateFunctionExponentialMovingAverage.cpp",
    "src/AggregateFunctions/registerAggregateFunctions.cpp",
    "b/src/Common/ExponentiallySmoothedCounter.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/2020_exponential_smoothing.reference",
    "b/tests/queries/0_stateless/2020_exponential_smoothing.sql",
    "b/tests/queries/0_stateless/2021_exponential_sum.reference",
    "b/tests/queries/0_stateless/2021_exponential_sum.sql",
    "b/tests/queries/0_stateless/2021_exponential_sum_shard.reference",
    "b/tests/queries/0_stateless/2021_exponential_sum_shard.sql"
  ]
}