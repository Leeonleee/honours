{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 54856,
  "instance_id": "ClickHouse__ClickHouse-54856",
  "issue_numbers": [
    "54796"
  ],
  "base_commit": "d260b7abe492d91e5342121a64a5f8fec7ee497b",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex a3883cd22ce7..0364a6104041 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -732,14 +732,15 @@ Returns for a given date, the number of days passed since [1 January 0000](https\n **Syntax**\n \n ``` sql\n-toDaysSinceYearZero(date)\n+toDaysSinceYearZero(date[, time_zone])\n ```\n \n Aliases: `TO_DAYS`\n \n-**Arguments**\n \n-- `date` \u2014 The date to calculate the number of days passed since year zero from. [Date](../../sql-reference/data-types/date.md) or [Date32](../../sql-reference/data-types/date32.md).\n+**Arguments**\n+- `date` \u2014 The date to calculate the number of days passed since year zero from. [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md) or [DateTime64](../../sql-reference/data-types/datetime64.md).\n+- `time_zone` \u2014 A String type const value or a expression represent the time zone. [String types](../../sql-reference/data-types/string.md)\n \n **Returned value**\n \ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 54cb3d0d5c2e..782dce116a4c 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -371,9 +371,11 @@ struct WhichDataType\n \n     constexpr bool isDate() const { return idx == TypeIndex::Date; }\n     constexpr bool isDate32() const { return idx == TypeIndex::Date32; }\n+    constexpr bool isDateOrDate32() const { return isDate() || isDate32(); }\n     constexpr bool isDateTime() const { return idx == TypeIndex::DateTime; }\n     constexpr bool isDateTime64() const { return idx == TypeIndex::DateTime64; }\n-    constexpr bool isDateOrDate32() const { return isDate() || isDate32(); }\n+    constexpr bool isDateTimeOrDateTime64() const { return isDateTime() || isDateTime64(); }\n+    constexpr bool isDateOrDate32OrDateTimeOrDateTime64() const { return isDateOrDate32() || isDateTimeOrDateTime64(); }\n \n     constexpr bool isString() const { return idx == TypeIndex::String; }\n     constexpr bool isFixedString() const { return idx == TypeIndex::FixedString; }\n@@ -410,6 +412,10 @@ template <typename T>\n inline bool isDateTime(const T & data_type) { return WhichDataType(data_type).isDateTime(); }\n template <typename T>\n inline bool isDateTime64(const T & data_type) { return WhichDataType(data_type).isDateTime64(); }\n+template <typename T>\n+inline bool isDateTimeOrDateTime64(const T & data_type) { return WhichDataType(data_type).isDateTimeOrDateTime64(); }\n+template <typename T>\n+inline bool isDateOrDate32OrDateTimeOrDateTime64(const T & data_type) { return WhichDataType(data_type).isDateOrDate32OrDateTimeOrDateTime64(); }\n \n template <typename T>\n inline bool isEnum(const T & data_type) { return WhichDataType(data_type).isEnum(); }\n@@ -433,26 +439,14 @@ template <typename T>\n inline bool isIPv6(const T & data_type) { return WhichDataType(data_type).isIPv6(); }\n \n template <typename T>\n-inline bool isObject(const T & data_type) { return WhichDataType(data_type).isObject();\n-}\n+inline bool isObject(const T & data_type) { return WhichDataType(data_type).isObject(); }\n \n template <typename T>\n-inline bool isUInt8(const T & data_type)\n-{\n-    return WhichDataType(data_type).isUInt8();\n-}\n-\n+inline bool isUInt8(const T & data_type) { return WhichDataType(data_type).isUInt8(); }\n template <typename T>\n-inline bool isUInt64(const T & data_type)\n-{\n-    return WhichDataType(data_type).isUInt64();\n-}\n-\n+inline bool isUInt64(const T & data_type) { return WhichDataType(data_type).isUInt64(); }\n template <typename T>\n-inline bool isUnsignedInteger(const T & data_type)\n-{\n-    return WhichDataType(data_type).isUInt();\n-}\n+inline bool isUnsignedInteger(const T & data_type) { return WhichDataType(data_type).isUInt(); }\n \n template <typename T>\n inline bool isInteger(const T & data_type)\ndiff --git a/src/Functions/DateTimeTransforms.h b/src/Functions/DateTimeTransforms.h\nindex a351d7fdf306..a845f63626dd 100644\n--- a/src/Functions/DateTimeTransforms.h\n+++ b/src/Functions/DateTimeTransforms.h\n@@ -928,28 +928,27 @@ struct ToDayOfYearImpl\n struct ToDaysSinceYearZeroImpl\n {\n private:\n-    /// Constant calculated from MySQL's TO_DAYS() implementation.\n-    /// https://github.com/mysql/mysql-server/blob/ea1efa9822d81044b726aab20c857d5e1b7e046a/mysys/my_time.cc#L1042\n-    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1900 = 693'961; /// 01 January, each\n+    static constexpr auto DAYS_BETWEEN_YEARS_0_AND_1970 = 719'528; /// 01 January, each. Constant taken from Java LocalDate. Consistent with MySQL's TO_DAYS().\n+    static constexpr auto SECONDS_PER_DAY = 60 * 60 * 24;\n \n public:\n     static constexpr auto name = \"toDaysSinceYearZero\";\n \n-    static UInt32 execute(Int64, const DateLUTImpl &)\n+    static UInt32 execute(Int64 t, const DateLUTImpl & time_zone)\n     {\n-        throwDateTimeIsNotSupported(name);\n+        return DAYS_BETWEEN_YEARS_0_AND_1970 + static_cast<UInt32>(time_zone.toDayNum(t));\n     }\n-    static UInt32 execute(UInt32, const DateLUTImpl &)\n+    static UInt32 execute(UInt32 d, const DateLUTImpl &)\n     {\n-        throwDateTimeIsNotSupported(name);\n+        return DAYS_BETWEEN_YEARS_0_AND_1970 + d / SECONDS_PER_DAY;\n     }\n     static UInt32 execute(Int32 d, const DateLUTImpl &)\n     {\n-        return DAYS_BETWEEN_YEARS_0_AND_1900 + d;\n+        return DAYS_BETWEEN_YEARS_0_AND_1970 + d;\n     }\n     static UInt32 execute(UInt16 d, const DateLUTImpl &)\n     {\n-        return DAYS_BETWEEN_YEARS_0_AND_1900 + d;\n+        return DAYS_BETWEEN_YEARS_0_AND_1970 + d;\n     }\n     static constexpr bool hasPreimage() { return false; }\n \ndiff --git a/src/Functions/FunctionDateOrDateTimeToSomething.h b/src/Functions/FunctionDateOrDateTimeToSomething.h\nindex d98b788c7d74..e5e12ec6e92d 100644\n--- a/src/Functions/FunctionDateOrDateTimeToSomething.h\n+++ b/src/Functions/FunctionDateOrDateTimeToSomething.h\n@@ -19,9 +19,10 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n-        this->checkArguments(arguments, (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>));\n+        constexpr bool result_is_date_or_date32 = (std::is_same_v<ToDataType, DataTypeDate> || std::is_same_v<ToDataType, DataTypeDate32>);\n+        this->checkArguments(arguments, result_is_date_or_date32);\n \n-        /// For DateTime, if time zone is specified, attach it to type.\n+        /// For DateTime results, if time zone is specified, attach it to type.\n         /// If the time zone is specified but empty, throw an exception.\n         if constexpr (std::is_same_v<ToDataType, DataTypeDateTime>)\n         {\n@@ -34,6 +35,7 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo\n                     this->getName());\n             return std::make_shared<ToDataType>(time_zone);\n         }\n+\n         if constexpr (std::is_same_v<ToDataType, DataTypeDateTime64>)\n         {\n             Int64 scale = DataTypeDateTime64::default_scale;\n@@ -42,17 +44,11 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo\n             auto source_scale = scale;\n \n             if constexpr (std::is_same_v<ToStartOfMillisecondImpl, Transform>)\n-            {\n                 scale = std::max(source_scale, static_cast<Int64>(3));\n-            }\n             else if constexpr (std::is_same_v<ToStartOfMicrosecondImpl, Transform>)\n-            {\n                 scale = std::max(source_scale, static_cast<Int64>(6));\n-            }\n             else if constexpr (std::is_same_v<ToStartOfNanosecondImpl, Transform>)\n-            {\n                 scale = std::max(source_scale, static_cast<Int64>(9));\n-            }\n \n             return std::make_shared<ToDataType>(scale, extractTimeZoneNameFromFunctionArguments(arguments, 1, 0, false));\n         }\n@@ -63,18 +59,16 @@ class FunctionDateOrDateTimeToSomething : public IFunctionDateOrDateTime<Transfo\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         const IDataType * from_type = arguments[0].type.get();\n-        WhichDataType which(from_type);\n \n-        if (which.isDate())\n+        if (isDate(from_type))\n             return DateTimeTransformImpl<DataTypeDate, ToDataType, Transform>::execute(arguments, result_type, input_rows_count);\n-        else if (which.isDate32())\n+        else if (isDate32(from_type))\n             return DateTimeTransformImpl<DataTypeDate32, ToDataType, Transform>::execute(arguments, result_type, input_rows_count);\n-        else if (which.isDateTime())\n+        else if (isDateTime(from_type))\n             return DateTimeTransformImpl<DataTypeDateTime, ToDataType, Transform>::execute(arguments, result_type, input_rows_count);\n-        else if (which.isDateTime64())\n+        else if (isDateTime64(from_type))\n         {\n             const auto scale = static_cast<const DataTypeDateTime64 *>(from_type)->getScale();\n-\n             const TransformDateTime64<Transform> transformer(scale);\n             return DateTimeTransformImpl<DataTypeDateTime64, ToDataType, decltype(transformer)>::execute(arguments, result_type, input_rows_count, transformer);\n         }\ndiff --git a/src/Functions/IFunctionDateOrDateTime.h b/src/Functions/IFunctionDateOrDateTime.h\nindex c22754eecd76..762b79bfafc7 100644\n--- a/src/Functions/IFunctionDateOrDateTime.h\n+++ b/src/Functions/IFunctionDateOrDateTime.h\n@@ -110,14 +110,14 @@ class IFunctionDateOrDateTime : public IFunction\n     {\n         if (arguments.size() == 1)\n         {\n-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64\",\n                     arguments[0].type->getName(), getName());\n         }\n         else if (arguments.size() == 2)\n         {\n-            if (!isDateOrDate32(arguments[0].type) && !isDateTime(arguments[0].type) && !isDateTime64(arguments[0].type))\n+            if (!isDateOrDate32OrDateTimeOrDateTime64(arguments[0].type))\n                 throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                     \"Illegal type {} of argument of function {}. Should be Date, Date32, DateTime or DateTime64\",\n                     arguments[0].type->getName(), getName());\ndiff --git a/src/Functions/toDaysSinceYearZero.cpp b/src/Functions/toDaysSinceYearZero.cpp\nindex e569c5cb1f30..f6239b2900b3 100644\n--- a/src/Functions/toDaysSinceYearZero.cpp\n+++ b/src/Functions/toDaysSinceYearZero.cpp\n@@ -1,80 +1,23 @@\n-#include <Columns/ColumnsNumber.h>\n-#include <DataTypes/DataTypeDate.h>\n-#include <DataTypes/DataTypeDate32.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Functions/DateTimeTransforms.h>\n+#include <Functions/FunctionDateOrDateTimeToSomething.h>\n #include <Functions/FunctionFactory.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <Functions/IFunction.h>\n \n \n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-}\n-\n-namespace\n-{\n-\n-/** Returns number of days passed since 0000-01-01 */\n-class FunctionToDaysSinceYearZero : public IFunction\n-{\n-    using ResultType = DataTypeUInt32;\n-public:\n-    static constexpr auto name = \"toDaysSinceYearZero\";\n-    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionToDaysSinceYearZero>(context); }\n-\n-    explicit FunctionToDaysSinceYearZero(ContextPtr /*context*/) {}\n-\n-    String getName() const override { return name; }\n-    size_t getNumberOfArguments() const override { return 1; }\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n-    bool useDefaultImplementationForConstants() const override { return true; }\n-\n-    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n-    {\n-        FunctionArgumentDescriptors mandatory_args{\n-            {\"date\", &isDateOrDate32<IDataType>, nullptr, \"Date or Date32\"}\n-        };\n-\n-        validateFunctionArgumentTypes(*this, arguments, mandatory_args);\n-\n-        return std::make_shared<DataTypeUInt32>();\n-    }\n-\n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n-    {\n-        const IDataType * from_type = arguments[0].type.get();\n-        WhichDataType which(from_type);\n-\n-        if (which.isDate())\n-            return DateTimeTransformImpl<DataTypeDate, ResultType, ToDaysSinceYearZeroImpl>::execute(arguments, result_type, input_rows_count);\n-        else if (which.isDate32())\n-            return DateTimeTransformImpl<DataTypeDate32, ResultType, ToDaysSinceYearZeroImpl>::execute(arguments, result_type, input_rows_count);\n-\n-        throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-            \"Illegal type {} of argument of function {}\",\n-            arguments[0].type->getName(), this->getName());\n-    }\n-};\n-\n-}\n+using FunctionToDaysSinceYearZero = FunctionDateOrDateTimeToSomething<DataTypeUInt32, ToDaysSinceYearZeroImpl>;\n \n REGISTER_FUNCTION(ToDaysSinceYearZero)\n {\n-    factory.registerFunction<FunctionToDaysSinceYearZero>(\n-    FunctionDocumentation{\n-    .description=R\"(\n-Returns for a given date, the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601.\n+    factory.registerFunction<FunctionToDaysSinceYearZero>(FunctionDocumentation{\n+        .description = R\"(\n+Returns for a given date or date with time, the number of days passed since 1 January 0000 in the proleptic Gregorian calendar defined by ISO 8601.\n The calculation is the same as in MySQL's TO_DAYS() function.\n )\",\n-    .examples{\n-        {\"typical\", \"SELECT toDaysSinceYearZero(toDate('2023-09-08'))\", \"713569\"}},\n-    .categories{\"Dates and Times\"}\n-    });\n+        .examples{{\"typical\", \"SELECT toDaysSinceYearZero(toDate('2023-09-08'))\", \"713569\"}},\n+        .categories{\"Dates and Times\"}});\n \n     /// MySQL compatibility alias.\n     factory.registerAlias(\"TO_DAYS\", FunctionToDaysSinceYearZero::name, FunctionFactory::CaseInsensitive);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02874_toDaysSinceYearZero.reference b/tests/queries/0_stateless/02874_toDaysSinceYearZero.reference\nindex 885332ab8354..04c5efd81b78 100644\n--- a/tests/queries/0_stateless/02874_toDaysSinceYearZero.reference\n+++ b/tests/queries/0_stateless/02874_toDaysSinceYearZero.reference\n@@ -1,13 +1,25 @@\n Invalid parameters\n Const argument\n+719528\n+739136\n+739136\n 693961\n-713569\n-668394\n-713569\n+739136\n+739136\n+719528\n+739136\n+739136\n+693961\n+739136\n+739136\n+739136\n \\N\n Non-const argument\n-713569\n-713569\n+739136\n+739136\n+739136\n+739136\n+739136\n MySQL alias\n-713569\n-713569\n+739136\n+739136\ndiff --git a/tests/queries/0_stateless/02874_toDaysSinceYearZero.sql b/tests/queries/0_stateless/02874_toDaysSinceYearZero.sql\nindex 2c35920e5699..a02591f793e2 100644\n--- a/tests/queries/0_stateless/02874_toDaysSinceYearZero.sql\n+++ b/tests/queries/0_stateless/02874_toDaysSinceYearZero.sql\n@@ -1,21 +1,33 @@\n+SET session_timezone = 'Europe/Amsterdam'; -- disable time zone randomization in CI\n+\n SELECT 'Invalid parameters';\n SELECT toDaysSinceYearZero(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n-SELECT toDaysSinceYearZero(toDate('2023-09-08'), toDate('2023-09-08')); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT toDaysSinceYearZero(toDate('2023-09-08'), 3); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT toDaysSinceYearZero('str'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT toDaysSinceYearZero(42); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT toDaysSinceYearZero(toDateTime('2023-09-08 11:11:11')); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n-SELECT toDaysSinceYearZero(toDateTime64('2023-09-08 11:11:11', 3)); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n \n SELECT 'Const argument';\n SELECT toDaysSinceYearZero(toDate('1970-01-01'));\n SELECT toDaysSinceYearZero(toDate('2023-09-08'));\n+SELECT toDaysSinceYearZero(toDate('2023-09-08'), 'America/Los_Angeles');\n SELECT toDaysSinceYearZero(toDate32('1900-01-01'));\n SELECT toDaysSinceYearZero(toDate32('2023-09-08'));\n+SELECT toDaysSinceYearZero(toDate32('2023-09-08'), 'America/Los_Angeles');\n+SELECT toDaysSinceYearZero(toDateTime('1970-01-01 00:00:00'));\n+SELECT toDaysSinceYearZero(toDateTime('2023-09-08 11:11:11'));\n+SELECT toDaysSinceYearZero(toDateTime('2023-09-08 11:11:11'), 'America/Los_Angeles');\n+SELECT toDaysSinceYearZero(toDateTime64('1900-01-01 00:00:00.000', 3));\n+SELECT toDaysSinceYearZero(toDateTime64('2023-09-08 11:11:11.123', 3));\n+SELECT toDaysSinceYearZero(toDateTime64('2023-09-08 11:11:11.123', 3), 'America/Los_Angeles');\n+SELECT toDaysSinceYearZero(toDateTime64('2023-09-08 11:11:11.123123123', 9));\n SELECT toDaysSinceYearZero(NULL);\n \n SELECT 'Non-const argument';\n SELECT toDaysSinceYearZero(materialize(toDate('2023-09-08')));\n SELECT toDaysSinceYearZero(materialize(toDate32('2023-09-08')));\n+SELECT toDaysSinceYearZero(materialize(toDateTime('2023-09-08 11:11:11')));\n+SELECT toDaysSinceYearZero(materialize(toDateTime64('2023-09-08 11:11:11.123', 3)));\n+SELECT toDaysSinceYearZero(materialize(toDateTime64('2023-09-08 11:11:11.123123123', 9)));\n \n SELECT 'MySQL alias';\n SELECT to_days(toDate('2023-09-08'));\n",
  "problem_statement": "MySQL compatibility: Illegal type of argument #1 'date' of function toDaysSinceYearZero\nRequired for Tableau Online. \r\n\r\nSample rendered query:\r\n\r\n```sql\r\nSELECT SUM(`cell_towers`.`mcc`)   AS `sum_mcc_ok`,\r\n       ADDDATE(FROM_DAYS(TO_DAYS(`cell_towers`.`updated`) - (DAYOFWEEK(`cell_towers`.`updated`) - 1)),\r\n               INTERVAL 0 SECOND) AS `twk_updated_ok`\r\nFROM `cell_towers`\r\nGROUP BY 2;\r\n```\r\n\r\nfails with\r\n\r\n```\r\nCode: 43. DB::Exception: Illegal type of argument #1 'date' of function toDaysSinceYearZero, expected Date or Date32, got DateTime: In scope SELECT SUM(cell_towers.mcc) AS sum_mcc_ok, ADDDATE(FROM_DAYS(TO_DAYS(cell_towers.updated) - (DAYOFWEEK(cell_towers.updated) - 1)), toIntervalSecond(0)) AS twk_updated_ok FROM cell_towers GROUP BY 2. (ILLEGAL_TYPE_OF_ARGUMENT)\r\n```\r\n\r\nReduced example:\r\n\r\n```sql\r\nSELECT TO_DAYS(`cell_towers`.`updated`) FROM cell_towers LIMIT 1;\r\n```\r\n\r\n**How to reproduce**\r\n\r\n* Which ClickHouse server version to use: latest master\r\n* Which interface to use, if matters: MySQL\r\n* Sample data for all these tables: cell_towers sample dataset\r\n\r\n**Expected behavior**\r\n\r\nTO_DAYS accepts DateTime/DateTime64 to be more in line with the MySQL standard.\n",
  "hints_text": "",
  "created_at": "2023-09-20T16:12:39Z",
  "modified_files": [
    "docs/en/sql-reference/functions/date-time-functions.md",
    "src/DataTypes/IDataType.h",
    "src/Functions/DateTimeTransforms.h",
    "src/Functions/FunctionDateOrDateTimeToSomething.h",
    "src/Functions/IFunctionDateOrDateTime.h",
    "src/Functions/toDaysSinceYearZero.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02874_toDaysSinceYearZero.reference",
    "tests/queries/0_stateless/02874_toDaysSinceYearZero.sql"
  ]
}