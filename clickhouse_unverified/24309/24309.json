{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 24309,
  "instance_id": "ClickHouse__ClickHouse-24309",
  "issue_numbers": [
    "23926"
  ],
  "base_commit": "9982f05e4deb23d923f4f17ace5cef9d53146b67",
  "patch": "diff --git a/src/Storages/StorageMaterializedView.cpp b/src/Storages/StorageMaterializedView.cpp\nindex 27cd649aae40..67bd6b21c3f4 100644\n--- a/src/Storages/StorageMaterializedView.cpp\n+++ b/src/Storages/StorageMaterializedView.cpp\n@@ -366,17 +366,18 @@ void StorageMaterializedView::renameInMemory(const StorageID & new_table_id)\n     auto metadata_snapshot = getInMemoryMetadataPtr();\n     bool from_atomic_to_atomic_database = old_table_id.hasUUID() && new_table_id.hasUUID();\n \n-    if (has_inner_table && tryGetTargetTable() && !from_atomic_to_atomic_database)\n+    if (!from_atomic_to_atomic_database && has_inner_table && tryGetTargetTable())\n     {\n         auto new_target_table_name = generateInnerTableName(new_table_id);\n         auto rename = std::make_shared<ASTRenameQuery>();\n \n         ASTRenameQuery::Table from;\n+        assert(target_table_id.database_name == old_table_id.database_name);\n         from.database = target_table_id.database_name;\n         from.table = target_table_id.table_name;\n \n         ASTRenameQuery::Table to;\n-        to.database = target_table_id.database_name;\n+        to.database = new_table_id.database_name;\n         to.table = new_target_table_name;\n \n         ASTRenameQuery::Element elem;\n@@ -385,10 +386,16 @@ void StorageMaterializedView::renameInMemory(const StorageID & new_table_id)\n         rename->elements.emplace_back(elem);\n \n         InterpreterRenameQuery(rename, getContext()).execute();\n+        target_table_id.database_name = new_table_id.database_name;\n         target_table_id.table_name = new_target_table_name;\n     }\n \n     IStorage::renameInMemory(new_table_id);\n+    if (from_atomic_to_atomic_database && has_inner_table)\n+    {\n+        assert(target_table_id.database_name == old_table_id.database_name);\n+        target_table_id.database_name = new_table_id.database_name;\n+    }\n     const auto & select_query = metadata_snapshot->getSelectQuery();\n     // TODO Actually we don't need to update dependency if MV has UUID, but then db and table name will be outdated\n     DatabaseCatalog::instance().updateDependency(select_query.select_table_id, old_table_id, select_query.select_table_id, getStorageID());\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01155_rename_move_materialized_view.reference b/tests/queries/0_stateless/01155_rename_move_materialized_view.reference\nnew file mode 100644\nindex 000000000000..942cedf86967\n--- /dev/null\n+++ b/tests/queries/0_stateless/01155_rename_move_materialized_view.reference\n@@ -0,0 +1,58 @@\n+1\t.inner.mv1\tbefore moving tablesmv1\n+1\tdst\tbefore moving tablesmv2\n+1\tmv1\tbefore moving tablesmv1\n+1\tmv2\tbefore moving tablesmv2\n+1\tsrc\tbefore moving tables\n+ordinary:\n+.inner.mv1\n+dst\n+mv1\n+mv2\n+src\n+ordinary after rename:\n+atomic after rename:\n+.inner_id.\n+dst\n+mv1\n+mv2\n+src\n+3\t.inner_id.\tafter renaming databasemv1\n+3\t.inner_id.\tbefore moving tablesmv1\n+3\tdst\tafter renaming databasemv2\n+3\tdst\tbefore moving tablesmv2\n+3\tmv1\tafter renaming databasemv1\n+3\tmv1\tbefore moving tablesmv1\n+3\tmv2\tafter renaming databasemv2\n+3\tmv2\tbefore moving tablesmv2\n+3\tsrc\tafter moving tables\n+3\tsrc\tafter renaming database\n+3\tsrc\tbefore moving tables\n+.inner_id.\n+dst\n+mv1\n+mv2\n+src\n+CREATE DATABASE test_01155_atomic\\nENGINE = Atomic\n+4\t.inner.mv1\tafter renaming databasemv1\n+4\t.inner.mv1\tafter renaming tablesmv1\n+4\t.inner.mv1\tbefore moving tablesmv1\n+4\tdst\tafter renaming databasemv2\n+4\tdst\tafter renaming tablesmv2\n+4\tdst\tbefore moving tablesmv2\n+4\tmv1\tafter renaming databasemv1\n+4\tmv1\tafter renaming tablesmv1\n+4\tmv1\tbefore moving tablesmv1\n+4\tmv2\tafter renaming databasemv2\n+4\tmv2\tafter renaming tablesmv2\n+4\tmv2\tbefore moving tablesmv2\n+4\tsrc\tafter moving tables\n+4\tsrc\tafter renaming database\n+4\tsrc\tafter renaming tables\n+4\tsrc\tbefore moving tables\n+test_01155_ordinary:\n+.inner.mv1\n+dst\n+mv1\n+mv2\n+src\n+test_01155_atomic:\ndiff --git a/tests/queries/0_stateless/01155_rename_move_materialized_view.sql b/tests/queries/0_stateless/01155_rename_move_materialized_view.sql\nnew file mode 100644\nindex 000000000000..2ede0fbcedfa\n--- /dev/null\n+++ b/tests/queries/0_stateless/01155_rename_move_materialized_view.sql\n@@ -0,0 +1,59 @@\n+DROP DATABASE IF EXISTS test_01155_ordinary;\n+DROP DATABASE IF EXISTS test_01155_atomic;\n+\n+CREATE DATABASE test_01155_ordinary ENGINE=Ordinary;\n+CREATE DATABASE test_01155_atomic ENGINE=Atomic;\n+\n+USE test_01155_ordinary;\n+CREATE TABLE src (s String) ENGINE=MergeTree() PARTITION BY tuple() ORDER BY s;\n+CREATE MATERIALIZED VIEW mv1 (s String) ENGINE=MergeTree() PARTITION BY tuple() ORDER BY s AS SELECT (*,).1 || 'mv1' as s FROM src;\n+CREATE TABLE dst (s String) ENGINE=MergeTree() PARTITION BY tuple() ORDER BY s;\n+CREATE MATERIALIZED VIEW mv2 TO dst (s String) AS SELECT (*,).1 || 'mv2' as s FROM src;\n+INSERT INTO src VALUES ('before moving tables');\n+SELECT 1, substr(_table, 1, 10), s FROM merge('test_01155_ordinary', '') ORDER BY _table, s;\n+\n+-- Move tables with materialized views from Ordinary to Atomic\n+SELECT 'ordinary:';\n+SHOW TABLES FROM test_01155_ordinary;\n+RENAME TABLE test_01155_ordinary.mv1 TO test_01155_atomic.mv1;\n+RENAME TABLE test_01155_ordinary.mv2 TO test_01155_atomic.mv2;\n+RENAME TABLE test_01155_ordinary.dst TO test_01155_atomic.dst;\n+RENAME TABLE test_01155_ordinary.src TO test_01155_atomic.src;\n+SELECT 'ordinary after rename:';\n+SELECT substr(name, 1, 10) FROM system.tables WHERE database='test_01155_ordinary';\n+SELECT 'atomic after rename:';\n+SELECT substr(name, 1, 10) FROM system.tables WHERE database='test_01155_atomic';\n+DROP DATABASE test_01155_ordinary;\n+USE default;\n+\n+INSERT INTO test_01155_atomic.src VALUES ('after moving tables');\n+SELECT 2, substr(_table, 1, 10), s FROM merge('test_01155_atomic', '') ORDER BY _table, s; -- { serverError 81 }\n+\n+RENAME DATABASE test_01155_atomic TO test_01155_ordinary;\n+USE test_01155_ordinary;\n+\n+INSERT INTO src VALUES ('after renaming database');\n+SELECT 3, substr(_table, 1, 10), s FROM merge('test_01155_ordinary', '') ORDER BY _table, s;\n+\n+SELECT substr(name, 1, 10) FROM system.tables WHERE database='test_01155_ordinary';\n+\n+-- Move tables back\n+RENAME DATABASE test_01155_ordinary TO test_01155_atomic;\n+\n+CREATE DATABASE test_01155_ordinary ENGINE=Ordinary;\n+SHOW CREATE DATABASE test_01155_atomic;\n+\n+RENAME TABLE test_01155_atomic.mv1 TO test_01155_ordinary.mv1;\n+RENAME TABLE test_01155_atomic.mv2 TO test_01155_ordinary.mv2;\n+RENAME TABLE test_01155_atomic.dst TO test_01155_ordinary.dst;\n+RENAME TABLE test_01155_atomic.src TO test_01155_ordinary.src;\n+\n+INSERT INTO src VALUES ('after renaming tables');\n+SELECT 4, substr(_table, 1, 10), s FROM merge('test_01155_ordinary', '') ORDER BY _table, s;\n+SELECT 'test_01155_ordinary:';\n+SHOW TABLES FROM test_01155_ordinary;\n+SELECT 'test_01155_atomic:';\n+SHOW TABLES FROM test_01155_atomic;\n+\n+DROP DATABASE IF EXISTS test_01155_atomic;\n+DROP DATABASE IF EXISTS test_01155_ordinary;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex cba090403119..cbe7d4868be2 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -572,6 +572,7 @@\n         \"01153_attach_mv_uuid\",\n         \"01152_cross_replication\",\n         \"01154_move_partition_long\",\n+        \"01155_rename_move_materialized_view\",\n         \"01185_create_or_replace_table\",\n         \"01190_full_attach_syntax\",\n         \"01191_rename_dictionary\",\n",
  "problem_statement": "Data table for MatView behaves strangely when MV moved from Ordinary to Atomic DB\n**Describe the unexpected behaviour**\r\nWhen MatView is moved from Ordinary DB to Atomic, data table stays in the same DB but renamed. I'd expected it moved to another DB too. Or at least not renamed and moved separately.\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use: 21.3.9\r\n* Which interface to use, if matters: doesn't matter\r\n* Full reproduction SQL:\r\n\r\n```sql\r\nCREATE DATABASE IF NOT EXISTS ordinary ENGINE=Ordinary;\r\nCREATE DATABASE IF NOT EXISTS atomic ENGINE=Atomic;\r\nCREATE TABLE IF NOT EXISTS ordinary.data (s String) ENGINE=MergeTree() PARTITION BY tuple() ORDER BY s;\r\nCREATE MATERIALIZED VIEW IF NOT EXISTS ordinary.mv (s String) ENGINE=MergeTree() PARTITION BY tuple() ORDER BY s AS SELECT * FROM ordinary.data;\r\nSELECT 'ordinary:';\r\nSHOW TABLES FROM ordinary;\r\nRENAME TABLE ordinary.mv TO atomic.mv;\r\nSELECT 'ordinary after rename:';\r\nSHOW TABLES FROM ordinary;\r\nSELECT 'atomic after rename:';\r\nSHOW TABLES FROM atomic;\r\n```\r\n\r\nOutput:\r\n\r\n```\r\nordinary:\r\n.inner.mv\r\ndata\r\nmv\r\nordinary after rename:\r\n.inner_id.d9584e69-6200-440f-a82d-3f8e5e18ff5e\r\ndata\r\natomic after rename:\r\nmv\r\n```\r\n\r\n**Expected behavior**\r\nEither `.inner.mv` stays as is in Ordinary DB or moved together with `mv` to the Atomic DB\n",
  "hints_text": "https://kb.altinity.com/engines/altinity-kb-atomic-database-engine/altinity-kb-how-to-convert-atomic-to-ordinary#schemas-with-materialized-view\nSorry, Denis, it's otherwise. I rename ordinary TO atomic. \nBTW opposite rename (from atomic to ordinary DB) of MV with implicitly created storage table also do a very weird thing - it renames the table but leaves it in atomic DB. ",
  "created_at": "2021-05-19T18:59:12Z"
}