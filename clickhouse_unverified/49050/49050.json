{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49050,
  "instance_id": "ClickHouse__ClickHouse-49050",
  "issue_numbers": [
    "48828"
  ],
  "base_commit": "6676285f02aff06bef6f6417fe024561dca9dc5f",
  "patch": "diff --git a/src/Functions/array/arrayAUC.cpp b/src/Functions/array/arrayAUC.cpp\nindex ab7799cc68e3..4d2b8175f5bd 100644\n--- a/src/Functions/array/arrayAUC.cpp\n+++ b/src/Functions/array/arrayAUC.cpp\n@@ -90,7 +90,7 @@ class ArrayAUCImpl\n         return std::make_shared<DataTypeNumber<ResultType>>();\n     }\n \n-    template <typename T, typename U>\n+    template <typename ResultType, typename T, typename U>\n     static ResultType apply(\n         const T * scores,\n         const U * labels,\ndiff --git a/src/Functions/array/arrayDotProduct.cpp b/src/Functions/array/arrayDotProduct.cpp\nnew file mode 100644\nindex 000000000000..d17c223cc2f2\n--- /dev/null\n+++ b/src/Functions/array/arrayDotProduct.cpp\n@@ -0,0 +1,81 @@\n+#include <DataTypes/DataTypesNumber.h>\n+#include <Functions/FunctionFactory.h>\n+#include <DataTypes/getLeastSupertype.h>\n+#include <Core/Types_fwd.h>\n+#include <DataTypes/Serializations/ISerialization.h>\n+#include <Functions/castTypeToEither.h>\n+#include <Functions/array/arrayScalarProduct.h>\n+#include <base/types.h>\n+#include <Functions/FunctionBinaryArithmetic.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+}\n+\n+struct NameArrayDotProduct\n+{\n+    static constexpr auto name = \"arrayDotProduct\";\n+};\n+\n+class ArrayDotProductImpl\n+{\n+public:\n+    static DataTypePtr getReturnType(const DataTypePtr & left, const DataTypePtr & right)\n+    {\n+        using Types = TypeList<DataTypeFloat32, DataTypeFloat64,\n+                               DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64,\n+                               DataTypeInt8, DataTypeInt16, DataTypeInt32, DataTypeInt64>;\n+\n+        DataTypePtr result_type;\n+        bool valid = castTypeToEither(Types{}, left.get(), [&](const auto & left_)\n+        {\n+            return castTypeToEither(Types{}, right.get(), [&](const auto & right_)\n+            {\n+                using LeftDataType = typename std::decay_t<decltype(left_)>::FieldType;\n+                using RightDataType = typename std::decay_t<decltype(right_)>::FieldType;\n+                using ResultType = typename NumberTraits::ResultOfAdditionMultiplication<LeftDataType, RightDataType>::Type;\n+                if (std::is_same_v<LeftDataType, Float32> && std::is_same_v<RightDataType, Float32>)\n+                    result_type = std::make_shared<DataTypeFloat32>();\n+                else\n+                    result_type = std::make_shared<DataTypeFromFieldType<ResultType>>();\n+                return true;\n+            });\n+        });\n+\n+        if (!valid)\n+            throw Exception(\n+                ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Arguments of function {} \"\n+                \"only support: UInt8, UInt16, UInt32, UInt64, Int8, Int16, Int32, Int64, Float32, Float64.\",\n+                std::string(NameArrayDotProduct::name));\n+        return result_type;\n+    }\n+\n+    template <typename ResultType, typename T, typename U>\n+    static inline NO_SANITIZE_UNDEFINED ResultType apply(\n+        const T * left,\n+        const U * right,\n+        size_t size)\n+    {\n+        ResultType result = 0;\n+        for (size_t i = 0; i < size; ++i)\n+            result += static_cast<ResultType>(left[i]) * static_cast<ResultType>(right[i]);\n+        return result;\n+    }\n+};\n+\n+using FunctionArrayDotProduct = FunctionArrayScalarProduct<ArrayDotProductImpl, NameArrayDotProduct>;\n+\n+REGISTER_FUNCTION(ArrayDotProduct)\n+{\n+    factory.registerFunction<FunctionArrayDotProduct>();\n+}\n+\n+// These functions are used by TupleOrArrayFunction in Function/vectorFunctions.cpp\n+FunctionPtr createFunctionArrayDotProduct(ContextPtr context_) { return FunctionArrayDotProduct::create(context_); }\n+}\ndiff --git a/src/Functions/array/arrayScalarProduct.h b/src/Functions/array/arrayScalarProduct.h\nindex 94ce1bc533c4..374a2d8a1944 100644\n--- a/src/Functions/array/arrayScalarProduct.h\n+++ b/src/Functions/array/arrayScalarProduct.h\n@@ -6,6 +6,7 @@\n #include <Functions/FunctionHelpers.h>\n #include <Functions/IFunction.h>\n #include <Interpreters/Context_fwd.h>\n+#include <Core/TypeId.h>\n \n \n namespace DB\n@@ -18,6 +19,7 @@ namespace ErrorCodes\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int BAD_ARGUMENTS;\n+    extern const int LOGICAL_ERROR;\n }\n \n \n@@ -29,29 +31,28 @@ class FunctionArrayScalarProduct : public IFunction\n     static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayScalarProduct>(); }\n \n private:\n-    using ResultColumnType = ColumnVector<typename Method::ResultType>;\n \n-    template <typename T>\n+    template <typename ResultType, typename T>\n     ColumnPtr executeNumber(const ColumnsWithTypeAndName & arguments) const\n     {\n         ColumnPtr res;\n-        if (   (res = executeNumberNumber<T, UInt8>(arguments))\n-            || (res = executeNumberNumber<T, UInt16>(arguments))\n-            || (res = executeNumberNumber<T, UInt32>(arguments))\n-            || (res = executeNumberNumber<T, UInt64>(arguments))\n-            || (res = executeNumberNumber<T, Int8>(arguments))\n-            || (res = executeNumberNumber<T, Int16>(arguments))\n-            || (res = executeNumberNumber<T, Int32>(arguments))\n-            || (res = executeNumberNumber<T, Int64>(arguments))\n-            || (res = executeNumberNumber<T, Float32>(arguments))\n-            || (res = executeNumberNumber<T, Float64>(arguments)))\n+        if (   (res = executeNumberNumber<ResultType, T, UInt8>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, UInt16>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, UInt32>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, UInt64>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, Int8>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, Int16>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, Int32>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, Int64>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, Float32>(arguments))\n+            || (res = executeNumberNumber<ResultType, T, Float64>(arguments)))\n             return res;\n \n        return nullptr;\n     }\n \n \n-    template <typename T, typename U>\n+    template <typename ResultType, typename T, typename U>\n     ColumnPtr executeNumberNumber(const ColumnsWithTypeAndName & arguments) const\n     {\n         ColumnPtr col1 = arguments[0].column->convertToFullColumnIfConst();\n@@ -72,7 +73,7 @@ class FunctionArrayScalarProduct : public IFunction\n         if (!col_nested1 || !col_nested2)\n             return nullptr;\n \n-        auto col_res = ResultColumnType::create();\n+        auto col_res = ColumnVector<ResultType>::create();\n \n         vector(\n             col_nested1->getData(),\n@@ -83,12 +84,12 @@ class FunctionArrayScalarProduct : public IFunction\n         return col_res;\n     }\n \n-    template <typename T, typename U>\n+    template <typename ResultType, typename T, typename U>\n     static NO_INLINE void vector(\n         const PaddedPODArray<T> & data1,\n         const PaddedPODArray<U> & data2,\n         const ColumnArray::Offsets & offsets,\n-        PaddedPODArray<typename Method::ResultType> & result)\n+        PaddedPODArray<ResultType> & result)\n     {\n         size_t size = offsets.size();\n         result.resize(size);\n@@ -97,7 +98,7 @@ class FunctionArrayScalarProduct : public IFunction\n         for (size_t i = 0; i < size; ++i)\n         {\n             size_t array_size = offsets[i] - current_offset;\n-            result[i] = Method::apply(&data1[current_offset], &data2[current_offset], array_size);\n+            result[i] = Method::template apply<ResultType, T, U>(&data1[current_offset], &data2[current_offset], array_size);\n             current_offset = offsets[i];\n         }\n     }\n@@ -130,24 +131,51 @@ class FunctionArrayScalarProduct : public IFunction\n         return Method::getReturnType(nested_types[0], nested_types[1]);\n     }\n \n-    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /* input_rows_count */) const override\n+    template <typename ResultType>\n+    ColumnPtr executeWithResultType(const ColumnsWithTypeAndName & arguments) const\n     {\n         ColumnPtr res;\n-        if (!((res = executeNumber<UInt8>(arguments))\n-            || (res = executeNumber<UInt16>(arguments))\n-            || (res = executeNumber<UInt32>(arguments))\n-            || (res = executeNumber<UInt64>(arguments))\n-            || (res = executeNumber<Int8>(arguments))\n-            || (res = executeNumber<Int16>(arguments))\n-            || (res = executeNumber<Int32>(arguments))\n-            || (res = executeNumber<Int64>(arguments))\n-            || (res = executeNumber<Float32>(arguments))\n-            || (res = executeNumber<Float64>(arguments))))\n+        if (!((res = executeNumber<ResultType, UInt8>(arguments))\n+            || (res = executeNumber<ResultType, UInt16>(arguments))\n+            || (res = executeNumber<ResultType, UInt32>(arguments))\n+            || (res = executeNumber<ResultType, UInt64>(arguments))\n+            || (res = executeNumber<ResultType, Int8>(arguments))\n+            || (res = executeNumber<ResultType, Int16>(arguments))\n+            || (res = executeNumber<ResultType, Int32>(arguments))\n+            || (res = executeNumber<ResultType, Int64>(arguments))\n+            || (res = executeNumber<ResultType, Float32>(arguments))\n+            || (res = executeNumber<ResultType, Float64>(arguments))))\n             throw Exception(ErrorCodes::ILLEGAL_COLUMN,\n                 \"Illegal column {} of first argument of function {}\", arguments[0].column->getName(), getName());\n \n         return res;\n     }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /* input_rows_count */) const override\n+    {\n+        switch (result_type->getTypeId())\n+        {\n+        #define SUPPORTED_TYPE(type) \\\n+            case TypeIndex::type: \\\n+                return executeWithResultType<type>(arguments); \\\n+                break;\n+\n+            SUPPORTED_TYPE(UInt8)\n+            SUPPORTED_TYPE(UInt16)\n+            SUPPORTED_TYPE(UInt32)\n+            SUPPORTED_TYPE(UInt64)\n+            SUPPORTED_TYPE(Int8)\n+            SUPPORTED_TYPE(Int16)\n+            SUPPORTED_TYPE(Int32)\n+            SUPPORTED_TYPE(Int64)\n+            SUPPORTED_TYPE(Float32)\n+            SUPPORTED_TYPE(Float64)\n+        #undef SUPPORTED_TYPE\n+\n+            default:\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected result type {}\", result_type->getName());\n+        }\n+    }\n };\n \n }\ndiff --git a/src/Functions/vectorFunctions.cpp b/src/Functions/vectorFunctions.cpp\nindex a063dd9b05cb..db907af972d6 100644\n--- a/src/Functions/vectorFunctions.cpp\n+++ b/src/Functions/vectorFunctions.cpp\n@@ -1429,6 +1429,8 @@ class TupleOrArrayFunction : public IFunction\n     FunctionPtr array_function;\n };\n \n+extern FunctionPtr createFunctionArrayDotProduct(ContextPtr context_);\n+\n extern FunctionPtr createFunctionArrayL1Norm(ContextPtr context_);\n extern FunctionPtr createFunctionArrayL2Norm(ContextPtr context_);\n extern FunctionPtr createFunctionArrayL2SquaredNorm(ContextPtr context_);\n@@ -1442,6 +1444,14 @@ extern FunctionPtr createFunctionArrayLpDistance(ContextPtr context_);\n extern FunctionPtr createFunctionArrayLinfDistance(ContextPtr context_);\n extern FunctionPtr createFunctionArrayCosineDistance(ContextPtr context_);\n \n+struct DotProduct\n+{\n+    static constexpr auto name = \"dotProduct\";\n+\n+    static constexpr auto CreateTupleFunction = FunctionDotProduct::create;\n+    static constexpr auto CreateArrayFunction = createFunctionArrayDotProduct;\n+};\n+\n struct L1NormTraits\n {\n     static constexpr auto name = \"L1Norm\";\n@@ -1530,6 +1540,8 @@ struct CosineDistanceTraits\n     static constexpr auto CreateArrayFunction = createFunctionArrayCosineDistance;\n };\n \n+using TupleOrArrayFunctionDotProduct = TupleOrArrayFunction<DotProduct>;\n+\n using TupleOrArrayFunctionL1Norm = TupleOrArrayFunction<L1NormTraits>;\n using TupleOrArrayFunctionL2Norm = TupleOrArrayFunction<L2NormTraits>;\n using TupleOrArrayFunctionL2SquaredNorm = TupleOrArrayFunction<L2SquaredNormTraits>;\n@@ -1615,8 +1627,8 @@ If the types of the first interval (or the interval in the tuple) and the second\n     factory.registerFunction<FunctionTupleMultiplyByNumber>();\n     factory.registerFunction<FunctionTupleDivideByNumber>();\n \n-    factory.registerFunction<FunctionDotProduct>();\n-    factory.registerAlias(\"scalarProduct\", FunctionDotProduct::name, FunctionFactory::CaseInsensitive);\n+    factory.registerFunction<TupleOrArrayFunctionDotProduct>();\n+    factory.registerAlias(\"scalarProduct\", TupleOrArrayFunctionDotProduct::name, FunctionFactory::CaseInsensitive);\n \n     factory.registerFunction<TupleOrArrayFunctionL1Norm>();\n     factory.registerFunction<TupleOrArrayFunctionL2Norm>();\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\nindex eb574c4e4f58..79a6ad1fa2d0 100644\n--- a/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n+++ b/tests/queries/0_stateless/02415_all_new_functions_must_be_documented.reference\n@@ -97,6 +97,7 @@ arrayCumSum\n arrayCumSumNonNegative\n arrayDifference\n arrayDistinct\n+arrayDotProduct\n arrayElement\n arrayEnumerate\n arrayEnumerateDense\ndiff --git a/tests/queries/0_stateless/02708_dot_product.reference b/tests/queries/0_stateless/02708_dot_product.reference\nnew file mode 100644\nindex 000000000000..45e53871aa23\n--- /dev/null\n+++ b/tests/queries/0_stateless/02708_dot_product.reference\n@@ -0,0 +1,14 @@\n+3881.304\n+3881.304\n+3881.304\n+376.5\n+230\n+0\n+0\n+Float64\n+Float32\n+Float64\n+Float64\n+UInt16\n+UInt64\n+Int64\ndiff --git a/tests/queries/0_stateless/02708_dot_product.sql b/tests/queries/0_stateless/02708_dot_product.sql\nnew file mode 100644\nindex 000000000000..e94cb577bf40\n--- /dev/null\n+++ b/tests/queries/0_stateless/02708_dot_product.sql\n@@ -0,0 +1,55 @@\n+SELECT dotProduct([12, 2.22, 302], [1.32, 231.2, 11.1]);\n+\n+SELECT scalarProduct([12, 2.22, 302], [1.32, 231.2, 11.1]);\n+\n+SELECT arrayDotProduct([12, 2.22, 302], [1.32, 231.2, 11.1]);\n+\n+SELECT dotProduct([1.3, 2, 3, 4, 5], [222, 12, 5.3, 2, 8]);\n+\n+SELECT dotProduct([1, 1, 1, 1, 1], [222, 12, 0, -12, 8]);\n+\n+SELECT round(dotProduct([12345678901234567], [1]) - dotProduct(tuple(12345678901234567), tuple(1)), 2);\n+\n+SELECT round(dotProduct([-1, 2, 3.002], [2, 3.4, 4]) - dotProduct((-1, 2, 3.002), (2, 3.4, 4)), 2);\n+\n+DROP TABLE IF EXISTS product_fp64_fp64;\n+CREATE TABLE product_fp64_fp64 (x Array(Float64), y Array(Float64)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_fp64_fp64 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_fp64_fp64;\n+DROP TABLE product_fp64_fp64;\n+\n+DROP TABLE IF EXISTS product_fp32_fp32;\n+CREATE TABLE product_fp32_fp32 (x Array(Float32), y Array(Float32)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_fp32_fp32 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_fp32_fp32;\n+DROP TABLE product_fp32_fp32;\n+\n+DROP TABLE IF EXISTS product_fp32_fp64;\n+CREATE TABLE product_fp32_fp64 (x Array(Float32), y Array(Float64)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_fp32_fp64 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_fp32_fp64;\n+DROP TABLE product_fp32_fp64;\n+\n+DROP TABLE IF EXISTS product_uint8_fp64;\n+CREATE TABLE product_uint8_fp64 (x Array(UInt8), y Array(Float64)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_uint8_fp64 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_uint8_fp64;\n+DROP TABLE product_uint8_fp64;\n+\n+DROP TABLE IF EXISTS product_uint8_uint8;\n+CREATE TABLE product_uint8_uint8 (x Array(UInt8), y Array(UInt8)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_uint8_uint8 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_uint8_uint8;\n+DROP TABLE product_uint8_uint8;\n+\n+DROP TABLE IF EXISTS product_uint64_uint64;\n+CREATE TABLE product_uint64_uint64 (x Array(UInt64), y Array(UInt64)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_uint64_uint64 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_uint64_uint64;\n+DROP TABLE product_uint64_uint64;\n+\n+DROP TABLE IF EXISTS product_int32_uint64;\n+CREATE TABLE product_int32_uint64 (x Array(Int32), y Array(UInt64)) engine = MergeTree() order by x;\n+INSERT INTO TABLE product_int32_uint64 (x, y) values ([1, 2], [3, 4]);\n+SELECT toTypeName(dotProduct(x, y)) from product_int32_uint64;\n+DROP TABLE product_int32_uint64;\n",
  "problem_statement": "`dotProduct` should work for arrays\n**Use case**\r\n\r\nVector search databases.\r\n\r\n**Implementation**\r\n\r\nCurrently, it works only for tuples.\r\n\r\n```\r\nSELECT dotProduct([1., 2.], [3., 4.])\r\n```\r\n\r\nAlthough it can be easily emulated by the following expression:\r\n```\r\narraySum((x, y) -> x * y, arr1, arr2)\r\n```\r\n\r\nAnd this expression is quite fast, but there is one downside: if the arguments have Float32 data type, the intermediate expressions, and the result will have Float64 data type.\r\n\r\nA dedicated `dotProduct` implementation should keep the calculation within the same data type.\r\nAdditionally, it could be further optimized.\r\n\n",
  "hints_text": "I'd like to do it.\n@FFFFFFFHHHHHHH Thank you! Let's try.",
  "created_at": "2023-04-22T19:26:36Z"
}