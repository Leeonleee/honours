diff --git a/src/AggregateFunctions/AggregateFunctionFactory.cpp b/src/AggregateFunctions/AggregateFunctionFactory.cpp
index f7c6fe9da14a..1c66650be451 100644
--- a/src/AggregateFunctions/AggregateFunctionFactory.cpp
+++ b/src/AggregateFunctions/AggregateFunctionFactory.cpp
@@ -56,11 +56,7 @@ static DataTypes convertLowCardinalityTypesToNested(const DataTypes & types)
 }
 
 AggregateFunctionPtr AggregateFunctionFactory::get(
-    const String & name,
-    const DataTypes & argument_types,
-    const Array & parameters,
-    AggregateFunctionProperties & out_properties,
-    int recursion_level) const
+    const String & name, const DataTypes & argument_types, const Array & parameters, AggregateFunctionProperties & out_properties) const
 {
     auto type_without_low_cardinality = convertLowCardinalityTypesToNested(argument_types);
 
@@ -81,11 +77,11 @@ AggregateFunctionPtr AggregateFunctionFactory::get(
             [](const auto & type) { return type->onlyNull(); });
 
         AggregateFunctionPtr nested_function = getImpl(
-            name, nested_types, nested_parameters, out_properties, has_null_arguments, recursion_level);
+            name, nested_types, nested_parameters, out_properties, has_null_arguments);
         return combinator->transformAggregateFunction(nested_function, out_properties, type_without_low_cardinality, parameters);
     }
 
-    auto res = getImpl(name, type_without_low_cardinality, parameters, out_properties, false, recursion_level);
+    auto res = getImpl(name, type_without_low_cardinality, parameters, out_properties, false);
     if (!res)
         throw Exception("Logical error: AggregateFunctionFactory returned nullptr", ErrorCodes::LOGICAL_ERROR);
     return res;
@@ -97,8 +93,7 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(
     const DataTypes & argument_types,
     const Array & parameters,
     AggregateFunctionProperties & out_properties,
-    bool has_null_arguments,
-    int recursion_level) const
+    bool has_null_arguments) const
 {
     String name = getAliasToOrName(name_param);
     Value found;
@@ -108,13 +103,9 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(
     {
         found = it->second;
     }
-    /// Find by case-insensitive name.
-    /// Combinators cannot apply for case insensitive (SQL-style) aggregate function names. Only for native names.
-    else if (recursion_level == 0)
-    {
-        if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())
-            found = jt->second;
-    }
+
+    if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())
+        found = jt->second;
 
     if (found.creator)
     {
@@ -140,7 +131,7 @@ AggregateFunctionPtr AggregateFunctionFactory::getImpl(
         DataTypes nested_types = combinator->transformArguments(argument_types);
         Array nested_parameters = combinator->transformParameters(parameters);
 
-        AggregateFunctionPtr nested_function = get(nested_name, nested_types, nested_parameters, out_properties, recursion_level + 1);
+        AggregateFunctionPtr nested_function = get(nested_name, nested_types, nested_parameters, out_properties);
         return combinator->transformAggregateFunction(nested_function, out_properties, argument_types, parameters);
     }
 
@@ -162,7 +153,7 @@ AggregateFunctionPtr AggregateFunctionFactory::tryGet(
 }
 
 
-std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPropertiesImpl(const String & name_param, int recursion_level) const
+std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPropertiesImpl(const String & name_param) const
 {
     String name = getAliasToOrName(name_param);
     Value found;
@@ -172,13 +163,9 @@ std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPrope
     {
         found = it->second;
     }
-    /// Find by case-insensitive name.
-    /// Combinators cannot apply for case insensitive (SQL-style) aggregate function names. Only for native names.
-    else if (recursion_level == 0)
-    {
-        if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())
-            found = jt->second;
-    }
+
+    if (auto jt = case_insensitive_aggregate_functions.find(Poco::toLower(name)); jt != case_insensitive_aggregate_functions.end())
+        found = jt->second;
 
     if (found.creator)
         return found.properties;
@@ -195,7 +182,7 @@ std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPrope
         String nested_name = name.substr(0, name.size() - combinator->getName().size());
 
         /// NOTE: It's reasonable to also allow to transform properties by combinator.
-        return tryGetPropertiesImpl(nested_name, recursion_level + 1);
+        return tryGetPropertiesImpl(nested_name);
     }
 
     return {};
@@ -204,21 +191,21 @@ std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetPrope
 
 std::optional<AggregateFunctionProperties> AggregateFunctionFactory::tryGetProperties(const String & name) const
 {
-    return tryGetPropertiesImpl(name, 0);
+    return tryGetPropertiesImpl(name);
 }
 
 
-bool AggregateFunctionFactory::isAggregateFunctionName(const String & name, int recursion_level) const
+bool AggregateFunctionFactory::isAggregateFunctionName(const String & name) const
 {
     if (aggregate_functions.count(name) || isAlias(name))
         return true;
 
     String name_lowercase = Poco::toLower(name);
-    if (recursion_level == 0 && (case_insensitive_aggregate_functions.count(name_lowercase) || isAlias(name_lowercase)))
+    if (case_insensitive_aggregate_functions.count(name_lowercase) || isAlias(name_lowercase))
         return true;
 
     if (AggregateFunctionCombinatorPtr combinator = AggregateFunctionCombinatorFactory::instance().tryFindSuffix(name))
-        return isAggregateFunctionName(name.substr(0, name.size() - combinator->getName().size()), recursion_level + 1);
+        return isAggregateFunctionName(name.substr(0, name.size() - combinator->getName().size()));
 
     return false;
 }
diff --git a/src/AggregateFunctions/AggregateFunctionFactory.h b/src/AggregateFunctions/AggregateFunctionFactory.h
index 143e6562a305..7bbe04aff705 100644
--- a/src/AggregateFunctions/AggregateFunctionFactory.h
+++ b/src/AggregateFunctions/AggregateFunctionFactory.h
@@ -59,12 +59,11 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto
         CaseSensitiveness case_sensitiveness = CaseSensitive);
 
     /// Throws an exception if not found.
-    AggregateFunctionPtr get(
-        const String & name,
+    AggregateFunctionPtr
+    get(const String & name,
         const DataTypes & argument_types,
         const Array & parameters,
-        AggregateFunctionProperties & out_properties,
-        int recursion_level = 0) const;
+        AggregateFunctionProperties & out_properties) const;
 
     /// Returns nullptr if not found.
     AggregateFunctionPtr tryGet(
@@ -76,7 +75,7 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto
     /// Get properties if the aggregate function exists.
     std::optional<AggregateFunctionProperties> tryGetProperties(const String & name) const;
 
-    bool isAggregateFunctionName(const String & name, int recursion_level = 0) const;
+    bool isAggregateFunctionName(const String & name) const;
 
 private:
     AggregateFunctionPtr getImpl(
@@ -84,10 +83,9 @@ class AggregateFunctionFactory final : private boost::noncopyable, public IFacto
         const DataTypes & argument_types,
         const Array & parameters,
         AggregateFunctionProperties & out_properties,
-        bool has_null_arguments,
-        int recursion_level) const;
+        bool has_null_arguments) const;
 
-    std::optional<AggregateFunctionProperties> tryGetPropertiesImpl(const String & name, int recursion_level) const;
+    std::optional<AggregateFunctionProperties> tryGetPropertiesImpl(const String & name) const;
 
 private:
     using AggregateFunctions = std::unordered_map<String, Value>;
