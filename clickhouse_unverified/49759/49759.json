{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 49759,
  "instance_id": "ClickHouse__ClickHouse-49759",
  "issue_numbers": [
    "20469"
  ],
  "base_commit": "945a119fc6d2b3061a2d4edb19e5c5eef73f6a54",
  "patch": "diff --git a/src/Functions/FunctionsCodingIP.h b/src/Functions/FunctionsCodingIP.h\nindex d02cc81f6084..9d090abb736a 100644\n--- a/src/Functions/FunctionsCodingIP.h\n+++ b/src/Functions/FunctionsCodingIP.h\n@@ -2,6 +2,7 @@\n \n #include <type_traits>\n #include <Common/formatIPv6.h>\n+#include <Common/IPv6ToBinary.h>\n \n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnNullable.h>\n@@ -16,6 +17,7 @@ namespace ErrorCodes\n     extern const int CANNOT_PARSE_IPV4;\n     extern const int CANNOT_PARSE_IPV6;\n     extern const int ILLEGAL_COLUMN;\n+    extern const int CANNOT_CONVERT_TYPE;\n }\n \n enum class IPStringToNumExceptionMode : uint8_t\n@@ -296,4 +298,87 @@ ColumnPtr convertToIPv4(ColumnPtr column, const PaddedPODArray<UInt8> * null_map\n     return col_res;\n }\n \n+template <IPStringToNumExceptionMode exception_mode, typename ToColumn = ColumnIPv4>\n+ColumnPtr convertIPv6ToIPv4(ColumnPtr column, const PaddedPODArray<UInt8> * null_map = nullptr)\n+{\n+    const ColumnIPv6 * column_ipv6 = checkAndGetColumn<ColumnIPv6>(column.get());\n+\n+    if (!column_ipv6)\n+        throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Illegal column type {}. Expected IPv6.\", column->getName());\n+\n+    size_t column_size = column_ipv6->size();\n+\n+    ColumnUInt8::MutablePtr col_null_map_to;\n+    ColumnUInt8::Container * vec_null_map_to = nullptr;\n+\n+    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+    {\n+        col_null_map_to = ColumnUInt8::create(column_size, false);\n+        vec_null_map_to = &col_null_map_to->getData();\n+    }\n+\n+    const uint8_t ip4_cidr[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00};\n+\n+    auto col_res = ToColumn::create();\n+    auto & vec_res = col_res->getData();\n+    vec_res.resize(column_size);\n+    const auto & vec_src = column_ipv6->getData();\n+\n+    for (size_t i = 0; i < vec_res.size(); ++i)\n+    {\n+        const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_src[i]);\n+        uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_res[i]);\n+\n+        if (null_map && (*null_map)[i])\n+        {\n+            std::memset(dst, '\\0', IPV4_BINARY_LENGTH);\n+            if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+                (*vec_null_map_to)[i] = true;\n+            continue;\n+        }\n+\n+        if (!matchIPv6Subnet(src, ip4_cidr, 96))\n+        {\n+            if constexpr (exception_mode == IPStringToNumExceptionMode::Throw)\n+            {\n+                char addr[IPV6_MAX_TEXT_LENGTH + 1] {};\n+                char * paddr = addr;\n+                formatIPv6(src, paddr);\n+\n+                throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"IPv6 {} in column {} is not in IPv4 mapping block\", addr, column->getName());\n+            }\n+            else if constexpr (exception_mode == IPStringToNumExceptionMode::Default)\n+            {\n+                std::memset(dst, '\\0', IPV4_BINARY_LENGTH);\n+            }\n+            else if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+            {\n+                (*vec_null_map_to)[i] = true;\n+                std::memset(dst, '\\0', IPV4_BINARY_LENGTH);\n+            }\n+            continue;\n+        }\n+\n+        if constexpr (std::endian::native == std::endian::little)\n+        {\n+            dst[0] = src[15];\n+            dst[1] = src[14];\n+            dst[2] = src[13];\n+            dst[3] = src[12];\n+        }\n+        else\n+        {\n+            dst[0] = src[12];\n+            dst[1] = src[13];\n+            dst[2] = src[14];\n+            dst[3] = src[15];\n+        }\n+    }\n+\n+    if constexpr (exception_mode == IPStringToNumExceptionMode::Null)\n+        return ColumnNullable::create(std::move(col_res), std::move(col_null_map_to));\n+\n+    return col_res;\n+}\n+\n }\ndiff --git a/src/Functions/FunctionsConversion.h b/src/Functions/FunctionsConversion.h\nindex 023f1ab5425a..00c4cfe7284d 100644\n--- a/src/Functions/FunctionsConversion.h\n+++ b/src/Functions/FunctionsConversion.h\n@@ -57,6 +57,7 @@\n #include <Interpreters/Context.h>\n #include <Common/HashTable/HashMap.h>\n #include <DataTypes/DataTypeIPv4andIPv6.h>\n+#include <Common/IPv6ToBinary.h>\n #include <Core/Types.h>\n \n \n@@ -210,13 +211,13 @@ struct ConvertImpl\n                 }\n                 else if constexpr (\n                     (std::is_same_v<FromDataType, DataTypeIPv4> != std::is_same_v<ToDataType, DataTypeIPv4>)\n-                    && !(is_any_of<FromDataType, DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64> || is_any_of<ToDataType, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256>)\n+                    && !(is_any_of<FromDataType, DataTypeUInt8, DataTypeUInt16, DataTypeUInt32, DataTypeUInt64, DataTypeIPv6> || is_any_of<ToDataType, DataTypeUInt32, DataTypeUInt64, DataTypeUInt128, DataTypeUInt256, DataTypeIPv6>)\n                 )\n                 {\n                     throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Conversion from {} to {} is not supported\",\n                                     TypeName<typename FromDataType::FieldType>, TypeName<typename ToDataType::FieldType>);\n                 }\n-                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> != std::is_same_v<ToDataType, DataTypeIPv6>)\n+                else if constexpr (std::is_same_v<FromDataType, DataTypeIPv6> != std::is_same_v<ToDataType, DataTypeIPv6> && !(std::is_same_v<ToDataType, DataTypeIPv4> || std::is_same_v<FromDataType, DataTypeIPv4>))\n                 {\n                     throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n                                     \"Conversion between numeric types and IPv6 is not supported. \"\n@@ -297,7 +298,58 @@ struct ConvertImpl\n                         }\n                         else\n                         {\n-                            if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeUInt64>)\n+                            if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeIPv6>)\n+                            {\n+                                const uint8_t ip4_cidr[] {0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff, 0xff, 0x00, 0x00, 0x00, 0x00};\n+                                const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_from[i].toUnderType());\n+                                if (!matchIPv6Subnet(src, ip4_cidr, 96))\n+                                {\n+                                    char addr[IPV6_MAX_TEXT_LENGTH + 1] {};\n+                                    char * paddr = addr;\n+                                    formatIPv6(src, paddr);\n+\n+                                    throw Exception(ErrorCodes::CANNOT_CONVERT_TYPE, \"IPv6 {} in column {} is not in IPv4 mapping block\", addr, named_from.column->getName());\n+                                }\n+\n+                                uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_to[i].toUnderType());\n+                                if constexpr (std::endian::native == std::endian::little)\n+                                {\n+                                    dst[0] = src[15];\n+                                    dst[1] = src[14];\n+                                    dst[2] = src[13];\n+                                    dst[3] = src[12];\n+                                }\n+                                else\n+                                {\n+                                    dst[0] = src[12];\n+                                    dst[1] = src[13];\n+                                    dst[2] = src[14];\n+                                    dst[3] = src[15];\n+                                }\n+                            }\n+                            else if constexpr (std::is_same_v<ToDataType, DataTypeIPv6> && std::is_same_v<FromDataType, DataTypeIPv4>)\n+                            {\n+                                const uint8_t * src = reinterpret_cast<const uint8_t *>(&vec_from[i].toUnderType());\n+                                uint8_t * dst = reinterpret_cast<uint8_t *>(&vec_to[i].toUnderType());\n+                                std::memset(dst, '\\0', IPV6_BINARY_LENGTH);\n+                                dst[10] = dst[11] = 0xff;\n+\n+                                if constexpr (std::endian::native == std::endian::little)\n+                                {\n+                                    dst[12] = src[3];\n+                                    dst[13] = src[2];\n+                                    dst[14] = src[1];\n+                                    dst[15] = src[0];\n+                                }\n+                                else\n+                                {\n+                                    dst[12] = src[0];\n+                                    dst[13] = src[1];\n+                                    dst[14] = src[2];\n+                                    dst[15] = src[3];\n+                                }\n+                            }\n+                            else if constexpr (std::is_same_v<ToDataType, DataTypeIPv4> && std::is_same_v<FromDataType, DataTypeUInt64>)\n                                 vec_to[i] = static_cast<ToFieldType>(static_cast<IPv4::UnderlyingType>(vec_from[i]));\n                             else if constexpr (std::is_same_v<Name, NameToUnixTimestamp> && (std::is_same_v<FromDataType, DataTypeDate> || std::is_same_v<FromDataType, DataTypeDate32>))\n                                 vec_to[i] = static_cast<ToFieldType>(vec_from[i] * DATE_SECONDS_PER_DAY);\n@@ -4010,6 +4062,26 @@ class FunctionCast final : public FunctionCastBase\n                     return true;\n                 }\n             }\n+            else if constexpr (WhichDataType(FromDataType::type_id).isIPv6() && WhichDataType(ToDataType::type_id).isIPv4())\n+            {\n+                ret = [cast_ipv4_ipv6_default_on_conversion_error_value, requested_result_is_nullable](\n+                                ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const ColumnNullable * column_nullable, size_t)\n+                        -> ColumnPtr\n+                {\n+                    if (!WhichDataType(result_type).isIPv4())\n+                        throw Exception(\n+                            ErrorCodes::TYPE_MISMATCH, \"Wrong result type {}. Expected IPv4\", result_type->getName());\n+\n+                    const auto * null_map = column_nullable ? &column_nullable->getNullMapData() : nullptr;\n+                    if (cast_ipv4_ipv6_default_on_conversion_error_value || requested_result_is_nullable)\n+                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Default>(arguments[0].column, null_map);\n+                    else\n+                        return convertIPv6ToIPv4<IPStringToNumExceptionMode::Throw>(arguments[0].column, null_map);\n+                };\n+\n+                return true;\n+            }\n+\n             if constexpr (WhichDataType(ToDataType::type_id).isStringOrFixedString())\n             {\n                 if (from_type->getCustomSerialization())\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02234_cast_to_ip_address.reference b/tests/queries/0_stateless/02234_cast_to_ip_address.reference\nindex 9023b36a9bfc..fa9c6bd0f943 100644\n--- a/tests/queries/0_stateless/02234_cast_to_ip_address.reference\n+++ b/tests/queries/0_stateless/02234_cast_to_ip_address.reference\n@@ -11,6 +11,10 @@ IPv4 functions\n 127.0.0.1\n 127.0.0.1\n --\n+1.2.3.4\n+1.2.3.4\n+0.0.0.0\n+--\n 127.0.0.1\n --\n 0\ndiff --git a/tests/queries/0_stateless/02234_cast_to_ip_address.sql b/tests/queries/0_stateless/02234_cast_to_ip_address.sql\nindex 6c65fe86cc91..28f1afff57f5 100644\n--- a/tests/queries/0_stateless/02234_cast_to_ip_address.sql\n+++ b/tests/queries/0_stateless/02234_cast_to_ip_address.sql\n@@ -20,6 +20,13 @@ SELECT toIPv4OrNull('127.0.0.1');\n \n SELECT '--';\n \n+SELECT toIPv4(toIPv6('::ffff:1.2.3.4'));\n+SELECT toIPv4(toIPv6('::afff:1.2.3.4')); --{serverError CANNOT_CONVERT_TYPE}\n+SELECT toIPv4OrDefault(toIPv6('::ffff:1.2.3.4'));\n+SELECT toIPv4OrDefault(toIPv6('::afff:1.2.3.4'));\n+\n+SELECT '--';\n+\n SELECT cast('test' , 'IPv4'); --{serverError CANNOT_PARSE_IPV4}\n SELECT cast('127.0.0.1' , 'IPv4');\n \n",
  "problem_statement": "Function to convert IPv6 to appropriate IPv4/6 string?\nFollowing on from #19518, it would be nice to have a reverse function which operates on an ipv6 address and returns it in ipv4 or ipv6 notation depending on type. So basically `replaceOne(IPv6NumToString(ip), '::ffff:', '')`. This should then allow the `IPv6` type to work pretty much the same as the postgres `inet` type I think?\n",
  "hints_text": "Yes we will need `toIPv4`,  `FunctionIPv4StringToNum`  mirror the current behavior  `toIPv6` & `FunctionIPv6StringToNum`. \r\n\r\nI can work on  this if someone can /assign this to me (related to my previous work on #19518).\r\n\r\nCurrently toIPv4 does:\r\n\r\n```sql\r\nSELECT toIPv4('::ffff:192.168.1.1')\r\n\u250c\u2500toIPv4('::ffff:192.168.1.1')\u2500\u2510\r\n\u2502                      0.0.0.0 \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\nInstead it should do:\r\n\r\n```sql\r\nSELECT toIPv4('::ffff:192.168.1.1')\r\n\r\n\u250c\u2500toIPv4('::ffff:192.168.1.1')\u2500\u2510\r\n\u2502                  192.168.1.1 |\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\r\n\r\n\nMaybe, however my request was for a function that effectively doesn't care if the source is ipv4 or ipv6 (within an ipv6 domain) but returns an ipv4 string if it is ipv4 address. That way and with the new toipv6 improvements in becomes trivial to dual stack stuff (with \"legacy\" clients expecting an ipv4 string) just using the ipv6 domain\nSo we need a function to convert IPv6 to string, which will not add `::ffff:` prefix for IPv4 addressed stored in IPv6. \r\n\r\n@mzealey any ideas how to name it? \r\n\nI'm not good with names - perhaps `IPv6NumToIPString` ?\nAny movement on this issue?\nStill no progress? We'd like to use this function.\n@yakov-olkhovskiy do we have any changes regarding that?\nApparently this issue was abandoned. I think we can add ability for functions 'toIPv4()' to accept IPv6 type and proper ip4 string address in ip6 domain...",
  "created_at": "2023-05-11T00:00:40Z"
}