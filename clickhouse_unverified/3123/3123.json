{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 3123,
  "instance_id": "ClickHouse__ClickHouse-3123",
  "issue_numbers": [
    "2093"
  ],
  "base_commit": "ea297c95ef3f0eac4854c6974373de224af51a90",
  "patch": "diff --git a/dbms/src/DataTypes/IDataType.h b/dbms/src/DataTypes/IDataType.h\nindex b08b1811151d..95b6b029dc52 100644\n--- a/dbms/src/DataTypes/IDataType.h\n+++ b/dbms/src/DataTypes/IDataType.h\n@@ -474,6 +474,7 @@ struct WhichDataType\n \n /// IDataType helpers (alternative for IDataType virtual methods with single point of truth)\n \n+inline bool isDate(const DataTypePtr & data_type) { return WhichDataType(data_type).isDate(); }\n inline bool isDateOrDateTime(const DataTypePtr & data_type) { return WhichDataType(data_type).isDateOrDateTime(); }\n inline bool isEnum(const DataTypePtr & data_type) { return WhichDataType(data_type).isEnum(); }\n inline bool isDecimal(const DataTypePtr & data_type) { return WhichDataType(data_type).isDecimal(); }\ndiff --git a/dbms/src/Dictionaries/DictionarySourceFactory.cpp b/dbms/src/Dictionaries/DictionarySourceFactory.cpp\nindex 88065113b2a9..82d8cb8f5968 100644\n--- a/dbms/src/Dictionaries/DictionarySourceFactory.cpp\n+++ b/dbms/src/Dictionaries/DictionarySourceFactory.cpp\n@@ -9,6 +9,7 @@\n #include <Dictionaries/LibraryDictionarySource.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeDate.h>\n+#include <DataTypes/DataTypeNullable.h>\n #include <Common/FieldVisitors.h>\n #include <Columns/ColumnsNumber.h>\n #include <IO/HTTPCommon.h>\n@@ -64,9 +65,16 @@ Block createSampleBlock(const DictionaryStructure & dict_struct)\n     }\n \n     if (dict_struct.range_min)\n+    {\n         for (const auto & attribute : { dict_struct.range_min, dict_struct.range_max })\n-            block.insert(ColumnWithTypeAndName{\n-                ColumnUInt16::create(1, 0), std::make_shared<DataTypeDate>(), attribute->name});\n+        {\n+            const auto & type = std::make_shared<DataTypeNullable>(attribute->type);\n+            auto column = type->createColumn();\n+            column->insertDefault();\n+\n+            block.insert(ColumnWithTypeAndName{std::move(column), type, attribute->name});\n+        }\n+    }\n \n     for (const auto & attribute : dict_struct.attributes)\n     {\ndiff --git a/dbms/src/Dictionaries/DictionaryStructure.cpp b/dbms/src/Dictionaries/DictionaryStructure.cpp\nindex 1f0d15422659..0aeed4914550 100644\n--- a/dbms/src/Dictionaries/DictionaryStructure.cpp\n+++ b/dbms/src/Dictionaries/DictionaryStructure.cpp\n@@ -1,6 +1,7 @@\n #include <Dictionaries/DictionaryStructure.h>\n #include <Formats/FormatSettings.h>\n #include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypeNullable.h>\n #include <Columns/IColumn.h>\n #include <Common/StringUtils/StringUtils.h>\n #include <IO/WriteHelpers.h>\n@@ -22,6 +23,25 @@ namespace ErrorCodes\n     extern const int BAD_ARGUMENTS;\n }\n \n+namespace\n+{\n+DictionaryTypedSpecialAttribute makeDictionaryTypedSpecialAttribute(\n+        const Poco::Util::AbstractConfiguration & config,\n+        const std::string & config_prefix,\n+        const std::string& default_type)\n+{\n+    const auto name = config.getString(config_prefix + \".name\", \"\");\n+    const auto expression = config.getString(config_prefix + \".expression\", \"\");\n+\n+    if (name.empty() && !expression.empty())\n+        throw Exception{\"Element \" + config_prefix + \".name is empty\", ErrorCodes::BAD_ARGUMENTS};\n+\n+    const auto type_name = config.getString(config_prefix + \".type\", default_type);\n+    return DictionaryTypedSpecialAttribute{std::move(name), std::move(expression), DataTypeFactory::instance().get(type_name)};\n+}\n+\n+} // namespace\n+\n \n bool isAttributeTypeConvertibleTo(AttributeUnderlyingType from, AttributeUnderlyingType to)\n {\n@@ -143,11 +163,33 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration\n         if (id->name.empty())\n             throw Exception{\"'id' cannot be empty\", ErrorCodes::BAD_ARGUMENTS};\n \n+        const auto range_default_type = \"Date\";\n         if (config.has(config_prefix + \".range_min\"))\n-            range_min.emplace(config, config_prefix + \".range_min\");\n+            range_min.emplace(std::move(makeDictionaryTypedSpecialAttribute(config, config_prefix + \".range_min\", range_default_type)));\n \n         if (config.has(config_prefix + \".range_max\"))\n-            range_max.emplace(config, config_prefix + \".range_max\");\n+            range_max.emplace(std::move(makeDictionaryTypedSpecialAttribute(config, config_prefix + \".range_max\", range_default_type)));\n+\n+        if (range_min.has_value() != range_max.has_value())\n+        {\n+            throw Exception{\"Dictionary structure should have both 'range_min' and 'range_max' either specified or not.\", ErrorCodes::BAD_ARGUMENTS};\n+        }\n+\n+        if (range_min && range_max && !range_min->type->equals(*range_max->type))\n+        {\n+            throw Exception{\"Dictionary structure 'range_min' and 'range_max' should have same type, \"\n+                \"'range_min' type: \" + range_min->type->getName() + \", \"\n+                \"'range_max' type: \" + range_max->type->getName(),\n+                ErrorCodes::BAD_ARGUMENTS};\n+        }\n+\n+        if (range_min)\n+        {\n+            if (!range_min->type->isValueRepresentedByInteger())\n+                throw Exception{\"Dictionary structure type of 'range_min' and 'range_max' should be an integer, Date, DateTime, or Enum.\"\n+                    \" Actual 'range_min' and 'range_max' type is \" + range_min->type->getName(),\n+                    ErrorCodes::BAD_ARGUMENTS};\n+        }\n \n         if (!id->expression.empty() ||\n             (range_min && !range_min->expression.empty()) ||\ndiff --git a/dbms/src/Dictionaries/DictionaryStructure.h b/dbms/src/Dictionaries/DictionaryStructure.h\nindex a42883582d96..a34964b8b2fa 100644\n--- a/dbms/src/Dictionaries/DictionaryStructure.h\n+++ b/dbms/src/Dictionaries/DictionaryStructure.h\n@@ -74,6 +74,13 @@ struct DictionarySpecialAttribute final\n     DictionarySpecialAttribute(const Poco::Util::AbstractConfiguration & config, const std::string & config_prefix);\n };\n \n+struct DictionaryTypedSpecialAttribute final\n+{\n+    const std::string name;\n+    const std::string expression;\n+    const DataTypePtr type;\n+};\n+\n \n /// Name of identifier plus list of attributes\n struct DictionaryStructure final\n@@ -81,8 +88,8 @@ struct DictionaryStructure final\n     std::optional<DictionarySpecialAttribute> id;\n     std::optional<std::vector<DictionaryAttribute>> key;\n     std::vector<DictionaryAttribute> attributes;\n-    std::optional<DictionarySpecialAttribute> range_min;\n-    std::optional<DictionarySpecialAttribute> range_max;\n+    std::optional<DictionaryTypedSpecialAttribute> range_min;\n+    std::optional<DictionaryTypedSpecialAttribute> range_max;\n     bool has_expressions = false;\n \n     DictionaryStructure(const Poco::Util::AbstractConfiguration & config, const std::string & config_prefix);\ndiff --git a/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h b/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h\nindex e954f68a9fdc..beef86cc9a5f 100644\n--- a/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h\n+++ b/dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h\n@@ -25,8 +25,8 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n     using DictionaryPtr = std::shared_ptr<DictionaryType const>;\n \n     RangeDictionaryBlockInputStream(\n-        DictionaryPtr dictionary, size_t max_block_size, const Names & column_names, PaddedPODArray<Key> && ids,\n-        PaddedPODArray<UInt16> && start_dates, PaddedPODArray<UInt16> && end_dates);\n+        DictionaryPtr dictionary, size_t max_block_size, const Names & column_names, PaddedPODArray<Key> && ids_to_fill,\n+        PaddedPODArray<Int64> && start_dates, PaddedPODArray<Int64> && end_dates);\n \n     String getName() const override\n     {\n@@ -39,44 +39,44 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n private:\n     template <typename Type>\n     using DictionaryGetter = void (DictionaryType::*)(const std::string &, const PaddedPODArray<Key> &,\n-                             const PaddedPODArray<UInt16> &, PaddedPODArray<Type> &) const;\n+                             const PaddedPODArray<Int64> &, PaddedPODArray<Type> &) const;\n \n     template <typename AttributeType>\n     ColumnPtr getColumnFromAttribute(DictionaryGetter<AttributeType> getter,\n-                                     const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<UInt16> & dates,\n+                                     const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<Int64> & dates,\n                                      const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const;\n-    ColumnPtr getColumnFromAttributeString(const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<UInt16> & dates,\n+    ColumnPtr getColumnFromAttributeString(const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<Int64> & dates,\n                                            const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const;\n     template <typename T>\n     ColumnPtr getColumnFromPODArray(const PaddedPODArray<T> & array) const;\n \n-    template <typename T>\n+    template <typename DictionarySpecialAttributeType, typename T>\n     void addSpecialColumn(\n-        const std::optional<DictionarySpecialAttribute> & attribute, DataTypePtr type,\n+        const std::optional<DictionarySpecialAttributeType> & attribute, DataTypePtr type,\n         const std::string & default_name, const std::unordered_set<std::string> & column_names_set,\n         const PaddedPODArray<T> & values, ColumnsWithTypeAndName & columns) const;\n \n     Block fillBlock(const PaddedPODArray<Key> & ids_to_fill,\n-                    const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const;\n+                    const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const;\n \n-    PaddedPODArray<UInt16> makeDateKey(\n-        const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const;\n+    PaddedPODArray<Int64> makeDateKey(\n+        const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const;\n \n     DictionaryPtr dictionary;\n     Names column_names;\n     PaddedPODArray<Key> ids;\n-    PaddedPODArray<UInt16> start_dates;\n-    PaddedPODArray<UInt16> end_dates;\n+    PaddedPODArray<Int64> start_dates;\n+    PaddedPODArray<Int64> end_dates;\n };\n \n \n template <typename DictionaryType, typename Key>\n RangeDictionaryBlockInputStream<DictionaryType, Key>::RangeDictionaryBlockInputStream(\n     DictionaryPtr dictionary, size_t max_column_size, const Names & column_names, PaddedPODArray<Key> && ids,\n-    PaddedPODArray<UInt16> && start_dates, PaddedPODArray<UInt16> && end_dates)\n+    PaddedPODArray<Int64> && block_start_dates, PaddedPODArray<Int64> && block_end_dates)\n     : DictionaryBlockInputStreamBase(ids.size(), max_column_size),\n       dictionary(dictionary), column_names(column_names),\n-      ids(std::move(ids)), start_dates(std::move(start_dates)), end_dates(std::move(end_dates))\n+      ids(std::move(ids)), start_dates(std::move(block_start_dates)), end_dates(std::move(block_end_dates))\n {\n }\n \n@@ -84,8 +84,8 @@ template <typename DictionaryType, typename Key>\n Block RangeDictionaryBlockInputStream<DictionaryType, Key>::getBlock(size_t start, size_t length) const\n {\n     PaddedPODArray<Key> block_ids;\n-    PaddedPODArray<UInt16> block_start_dates;\n-    PaddedPODArray<UInt16> block_end_dates;\n+    PaddedPODArray<Int64> block_start_dates;\n+    PaddedPODArray<Int64> block_end_dates;\n     block_ids.reserve(length);\n     block_start_dates.reserve(length);\n     block_end_dates.reserve(length);\n@@ -104,7 +104,7 @@ template <typename DictionaryType, typename Key>\n template <typename AttributeType>\n ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromAttribute(\n     DictionaryGetter<AttributeType> getter, const PaddedPODArray<Key> & ids_to_fill,\n-    const PaddedPODArray<UInt16> & dates, const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const\n+    const PaddedPODArray<Int64> & dates, const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const\n {\n     auto column_vector = ColumnVector<AttributeType>::create(ids_to_fill.size());\n     (concrete_dictionary.*getter)(attribute.name, ids_to_fill, dates, column_vector->getData());\n@@ -113,7 +113,7 @@ ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromAtt\n \n template <typename DictionaryType, typename Key>\n ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromAttributeString(\n-    const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<UInt16> & dates,\n+    const PaddedPODArray<Key> & ids_to_fill, const PaddedPODArray<Int64> & dates,\n     const DictionaryAttribute & attribute, const DictionaryType & concrete_dictionary) const\n {\n     auto column_string = ColumnString::create();\n@@ -134,9 +134,9 @@ ColumnPtr RangeDictionaryBlockInputStream<DictionaryType, Key>::getColumnFromPOD\n \n \n template <typename DictionaryType, typename Key>\n-template <typename T>\n+template <typename DictionarySpecialAttributeType, typename T>\n void RangeDictionaryBlockInputStream<DictionaryType, Key>::addSpecialColumn(\n-    const std::optional<DictionarySpecialAttribute> & attribute, DataTypePtr type,\n+    const std::optional<DictionarySpecialAttributeType> & attribute, DataTypePtr type,\n     const std::string & default_name, const std::unordered_set<std::string> & column_names_set,\n     const PaddedPODArray<T> & values, ColumnsWithTypeAndName & columns) const\n {\n@@ -149,10 +149,10 @@ void RangeDictionaryBlockInputStream<DictionaryType, Key>::addSpecialColumn(\n }\n \n template <typename DictionaryType, typename Key>\n-PaddedPODArray<UInt16> RangeDictionaryBlockInputStream<DictionaryType, Key>::makeDateKey(\n-        const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const\n+PaddedPODArray<Int64> RangeDictionaryBlockInputStream<DictionaryType, Key>::makeDateKey(\n+        const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const\n {\n-    PaddedPODArray<UInt16> key(block_start_dates.size());\n+    PaddedPODArray<Int64> key(block_start_dates.size());\n     for (size_t i = 0; i < key.size(); ++i)\n     {\n         if (RangeHashedDictionary::Range::isCorrectDate(block_start_dates[i]))\n@@ -168,7 +168,7 @@ PaddedPODArray<UInt16> RangeDictionaryBlockInputStream<DictionaryType, Key>::mak\n template <typename DictionaryType, typename Key>\n Block RangeDictionaryBlockInputStream<DictionaryType, Key>::fillBlock(\n     const PaddedPODArray<Key> & ids_to_fill,\n-    const PaddedPODArray<UInt16> & block_start_dates, const PaddedPODArray<UInt16> & block_end_dates) const\n+    const PaddedPODArray<Int64> & block_start_dates, const PaddedPODArray<Int64> & block_end_dates) const\n {\n     ColumnsWithTypeAndName columns;\n     const DictionaryStructure & structure = dictionary->getStructure();\n@@ -176,8 +176,8 @@ Block RangeDictionaryBlockInputStream<DictionaryType, Key>::fillBlock(\n     std::unordered_set<std::string> names(column_names.begin(), column_names.end());\n \n     addSpecialColumn(structure.id, std::make_shared<DataTypeUInt64>(), \"ID\", names, ids_to_fill, columns);\n-    addSpecialColumn(structure.range_min, std::make_shared<DataTypeDate>(), \"Range Start\", names, block_start_dates, columns);\n-    addSpecialColumn(structure.range_max, std::make_shared<DataTypeDate>(), \"Range End\", names, block_end_dates, columns);\n+    addSpecialColumn(structure.range_min, structure.range_max->type, \"Range Start\", names, block_start_dates, columns);\n+    addSpecialColumn(structure.range_max, structure.range_max->type, \"Range End\", names, block_end_dates, columns);\n \n     auto date_key = makeDateKey(block_start_dates, block_end_dates);\n \ndiff --git a/dbms/src/Dictionaries/RangeHashedDictionary.cpp b/dbms/src/Dictionaries/RangeHashedDictionary.cpp\nindex 890ee293cc83..2360c42fb7c9 100644\n--- a/dbms/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/dbms/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -1,7 +1,46 @@\n #include <Dictionaries/RangeHashedDictionary.h>\n #include <Dictionaries/RangeDictionaryBlockInputStream.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Columns/ColumnNullable.h>\n+#include <ext/range.h>\n \n \n+namespace\n+{\n+\n+using RangeStorageType = DB::RangeHashedDictionary::RangeStorageType;\n+\n+// Null values mean that specified boundary, either min or max is not set on range.\n+// To simplify comparison, null value of min bound should be bigger than any other value,\n+// and null value of maxbound - less than any value.\n+const RangeStorageType RANGE_MIN_NULL_VALUE = std::numeric_limits<RangeStorageType>::max();\n+const RangeStorageType RANGE_MAX_NULL_VALUE = std::numeric_limits<RangeStorageType>::min();\n+\n+// Handle both kinds of null values: explicit nulls of NullableColumn and 'implicit' nulls of Date type.\n+RangeStorageType getColumnIntValueOrDefault(const DB::IColumn & column, size_t index, bool isDate, const RangeStorageType & default_value)\n+{\n+    if (column.isNullAt(index))\n+        return default_value;\n+\n+    const RangeStorageType result = static_cast<RangeStorageType>(column.getInt(index));\n+    if (isDate && !DB::RangeHashedDictionary::Range::isCorrectDate(result))\n+        return default_value;\n+\n+    return result;\n+}\n+\n+const DB::IColumn & unwrapNullableColumn(const DB::IColumn & column)\n+{\n+    if (const auto * m = DB::checkAndGetColumn<DB::ColumnNullable>(&column))\n+    {\n+        return m->getNestedColumn();\n+    }\n+\n+    return column;\n+}\n+\n+} // namespace\n+\n namespace DB\n {\n \n@@ -12,6 +51,21 @@ namespace ErrorCodes\n     extern const int TYPE_MISMATCH;\n }\n \n+bool RangeHashedDictionary::Range::isCorrectDate(const RangeStorageType & date)\n+{\n+    return 0 < date && date <= DATE_LUT_MAX_DAY_NUM;\n+}\n+\n+bool RangeHashedDictionary::Range::contains(const RangeStorageType & value) const\n+{\n+    return left <= value && value <= right;\n+}\n+\n+bool operator<(const RangeHashedDictionary::Range & left, const RangeHashedDictionary::Range & right)\n+{\n+    return std::tie(left.left, left.right) < std::tie(right.left, right.right);\n+}\n+\n \n RangeHashedDictionary::RangeHashedDictionary(\n     const std::string & dictionary_name, const DictionaryStructure & dict_struct, DictionarySourcePtr source_ptr,\n@@ -43,7 +97,7 @@ RangeHashedDictionary::RangeHashedDictionary(const RangeHashedDictionary & other\n \n #define DECLARE_MULTIPLE_GETTER(TYPE)\\\n void RangeHashedDictionary::get##TYPE(\\\n-    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,\\\n+    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<RangeStorageType> & dates,\\\n     PaddedPODArray<TYPE> & out) const\\\n {\\\n     const auto & attribute = getAttributeWithType(attribute_name, AttributeUnderlyingType::TYPE);\\\n@@ -63,7 +117,7 @@ DECLARE_MULTIPLE_GETTER(Float64)\n #undef DECLARE_MULTIPLE_GETTER\n \n void RangeHashedDictionary::getString(\n-    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,\n+    const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<RangeStorageType> & dates,\n     ColumnString * out) const\n {\n     const auto & attribute = getAttributeWithType(attribute_name, AttributeUnderlyingType::String);\n@@ -114,8 +168,12 @@ void RangeHashedDictionary::loadData()\n     while (const auto block = stream->read())\n     {\n         const auto & id_column = *block.safeGetByPosition(0).column;\n-        const auto & min_range_column = *block.safeGetByPosition(1).column;\n-        const auto & max_range_column = *block.safeGetByPosition(2).column;\n+\n+        // Support old behaviour, where invalid date means 'open range'.\n+        const bool is_date = isDate(block.safeGetByPosition(1).type);\n+\n+        const auto & min_range_column = unwrapNullableColumn(*block.safeGetByPosition(1).column);\n+        const auto & max_range_column = unwrapNullableColumn(*block.safeGetByPosition(2).column);\n \n         element_count += id_column.size();\n \n@@ -124,10 +182,14 @@ void RangeHashedDictionary::loadData()\n             const auto & attribute_column = *block.safeGetByPosition(attribute_idx + 3).column;\n             auto & attribute = attributes[attribute_idx];\n \n-            for (const auto row_idx : ext::range(0, id_column.size()))\n-                setAttributeValue(attribute, id_column[row_idx].get<UInt64>(),\n-                    Range(min_range_column[row_idx].get<UInt64>(), max_range_column[row_idx].get<UInt64>()),\n+            for (const auto row_idx : ext::range(0, id_column.size())) {\n+                const auto min = getColumnIntValueOrDefault(min_range_column, row_idx, is_date, RANGE_MIN_NULL_VALUE);\n+                const auto max = getColumnIntValueOrDefault(max_range_column, row_idx, is_date, RANGE_MAX_NULL_VALUE);\n+\n+                setAttributeValue(attribute, id_column.getUInt(row_idx),\n+                    Range{min, max},\n                     attribute_column[row_idx]);\n+            }\n         }\n     }\n \n@@ -216,7 +278,7 @@ template <typename OutputType>\n void RangeHashedDictionary::getItems(\n     const Attribute & attribute,\n     const PaddedPODArray<Key> & ids,\n-    const PaddedPODArray<UInt16> & dates,\n+    const PaddedPODArray<RangeStorageType> & dates,\n     PaddedPODArray<OutputType> & out) const\n {\n     if (false) {}\n@@ -243,7 +305,7 @@ template <typename AttributeType, typename OutputType>\n void RangeHashedDictionary::getItemsImpl(\n     const Attribute & attribute,\n     const PaddedPODArray<Key> & ids,\n-    const PaddedPODArray<UInt16> & dates,\n+    const PaddedPODArray<RangeStorageType> & dates,\n     PaddedPODArray<OutputType> & out) const\n {\n     const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);\n@@ -354,7 +416,8 @@ const RangeHashedDictionary::Attribute & RangeHashedDictionary::getAttributeWith\n }\n \n void RangeHashedDictionary::getIdsAndDates(PaddedPODArray<Key> & ids,\n-                                           PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const\n+    PaddedPODArray<RangeStorageType> & start_dates,\n+    PaddedPODArray<RangeStorageType> & end_dates) const\n {\n     const auto & attribute = attributes.front();\n \n@@ -377,7 +440,8 @@ void RangeHashedDictionary::getIdsAndDates(PaddedPODArray<Key> & ids,\n \n template <typename T>\n void RangeHashedDictionary::getIdsAndDates(const Attribute & attribute, PaddedPODArray<Key> & ids,\n-                                           PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const\n+                                           PaddedPODArray<RangeStorageType> & start_dates,\n+                                           PaddedPODArray<RangeStorageType> & end_dates) const\n {\n     const HashMap<UInt64, Values<T>> & attr = *std::get<Ptr<T>>(attribute.maps);\n \n@@ -390,8 +454,8 @@ void RangeHashedDictionary::getIdsAndDates(const Attribute & attribute, PaddedPO\n         for (const auto & value : key.second)\n         {\n             ids.push_back(key.first);\n-            start_dates.push_back(value.range.first);\n-            end_dates.push_back(value.range.second);\n+            start_dates.push_back(value.range.left);\n+            end_dates.push_back(value.range.right);\n         }\n     }\n }\n@@ -399,8 +463,8 @@ void RangeHashedDictionary::getIdsAndDates(const Attribute & attribute, PaddedPO\n BlockInputStreamPtr RangeHashedDictionary::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n {\n     PaddedPODArray<Key> ids;\n-    PaddedPODArray<UInt16> start_dates;\n-    PaddedPODArray<UInt16> end_dates;\n+    PaddedPODArray<RangeStorageType> start_dates;\n+    PaddedPODArray<RangeStorageType> end_dates;\n     getIdsAndDates(ids, start_dates, end_dates);\n \n     using BlockInputStreamType = RangeDictionaryBlockInputStream<RangeHashedDictionary, Key>;\ndiff --git a/dbms/src/Dictionaries/RangeHashedDictionary.h b/dbms/src/Dictionaries/RangeHashedDictionary.h\nindex e6841388b857..73cb7ff4610d 100644\n--- a/dbms/src/Dictionaries/RangeHashedDictionary.h\n+++ b/dbms/src/Dictionaries/RangeHashedDictionary.h\n@@ -5,7 +5,7 @@\n #include <Dictionaries/DictionaryStructure.h>\n #include <Common/HashTable/HashMap.h>\n #include <Columns/ColumnString.h>\n-#include <ext/range.h>\n+\n #include <atomic>\n #include <memory>\n #include <tuple>\n@@ -59,9 +59,13 @@ class RangeHashedDictionary final : public IDictionaryBase\n         return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;\n     }\n \n+    typedef Int64 RangeStorageType;\n+\n #define DECLARE_MULTIPLE_GETTER(TYPE)\\\n     void get##TYPE(\\\n-        const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,\\\n+        const std::string & attribute_name,\\\n+        const PaddedPODArray<Key> & ids,\\\n+        const PaddedPODArray<RangeStorageType> & dates,\\\n         PaddedPODArray<TYPE> & out) const;\n     DECLARE_MULTIPLE_GETTER(UInt8)\n     DECLARE_MULTIPLE_GETTER(UInt16)\n@@ -77,33 +81,18 @@ class RangeHashedDictionary final : public IDictionaryBase\n #undef DECLARE_MULTIPLE_GETTER\n \n     void getString(\n-        const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<UInt16> & dates,\n+        const std::string & attribute_name, const PaddedPODArray<Key> & ids, const PaddedPODArray<RangeStorageType> & dates,\n         ColumnString * out) const;\n \n     BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;\n \n-    struct Range : std::pair<UInt16, UInt16>\n+    struct Range\n     {\n-        using std::pair<UInt16, UInt16>::pair;\n-\n-        static bool isCorrectDate(const UInt16 date) { return 0 < date && date <= DATE_LUT_MAX_DAY_NUM; }\n-\n-        bool contains(const UInt16 date) const\n-        {\n-            const auto & left = first;\n-            const auto & right = second;\n-\n-            if (left <= date && date <= right)\n-                return true;\n-\n-            const auto has_left_bound = isCorrectDate(left);\n-            const auto has_right_bound = isCorrectDate(right);\n-\n-            if ((!has_left_bound || left <= date) && (!has_right_bound || date <= right))\n-                return true;\n+        RangeStorageType left;\n+        RangeStorageType right;\n \n-            return false;\n-        }\n+        static bool isCorrectDate(const RangeStorageType & date);\n+        bool contains(const RangeStorageType& value) const;\n     };\n \n private:\n@@ -153,14 +142,14 @@ class RangeHashedDictionary final : public IDictionaryBase\n     void getItems(\n         const Attribute & attribute,\n         const PaddedPODArray<Key> & ids,\n-        const PaddedPODArray<UInt16> & dates,\n+        const PaddedPODArray<RangeStorageType> & dates,\n         PaddedPODArray<OutputType> & out) const;\n \n     template <typename AttributeType, typename OutputType>\n     void getItemsImpl(\n         const Attribute & attribute,\n         const PaddedPODArray<Key> & ids,\n-        const PaddedPODArray<UInt16> & dates,\n+        const PaddedPODArray<RangeStorageType> & dates,\n         PaddedPODArray<OutputType> & out) const;\n \n \n@@ -174,11 +163,11 @@ class RangeHashedDictionary final : public IDictionaryBase\n     const Attribute & getAttributeWithType(const std::string & name, const AttributeUnderlyingType type) const;\n \n     void getIdsAndDates(PaddedPODArray<Key> & ids,\n-                        PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const;\n+                        PaddedPODArray<RangeStorageType> & start_dates, PaddedPODArray<RangeStorageType> & end_dates) const;\n \n     template <typename T>\n     void getIdsAndDates(const Attribute & attribute, PaddedPODArray<Key> & ids,\n-                        PaddedPODArray<UInt16> & start_dates, PaddedPODArray<UInt16> & end_dates) const;\n+                        PaddedPODArray<RangeStorageType> & start_dates, PaddedPODArray<RangeStorageType> & end_dates) const;\n \n     const std::string dictionary_name;\n     const DictionaryStructure dict_struct;\ndiff --git a/dbms/src/Functions/FunctionsExternalDictionaries.h b/dbms/src/Functions/FunctionsExternalDictionaries.h\nindex 7aa24f5115f8..7a41439d3fed 100644\n--- a/dbms/src/Functions/FunctionsExternalDictionaries.h\n+++ b/dbms/src/Functions/FunctionsExternalDictionaries.h\n@@ -32,6 +32,7 @@\n \n #include <ext/range.h>\n \n+#include <type_traits>\n \n namespace DB\n {\n@@ -109,7 +110,7 @@ class FunctionDictHas final : public IFunction\n           * This feature is controversial and implemented specially\n           *  for backward compatibility with the case in Yandex Banner System.\n           */\n-        if (input_rows_count== 0)\n+        if (input_rows_count == 0)\n         {\n             auto & elem = block.getByPosition(result);\n             elem.column = elem.type->createColumn();\n@@ -197,6 +198,8 @@ static bool isDictGetFunctionInjective(const ExternalDictionaries & dictionaries\n     return dictionaries.getDictionary(dict_name_col->getValue<String>())->isInjective(attr_name_col->getValue<String>());\n }\n \n+template <typename T>\n+const PaddedPODArray<T> * getColumnDataAsPaddedPODArray(const IColumn * column, PaddedPODArray<T> * backup_storage);\n \n class FunctionDictGetString final : public IFunction\n {\n@@ -250,10 +253,11 @@ class FunctionDictGetString final : public IFunction\n         }\n \n         /// This is for the case of range dictionaries.\n-        if (arguments.size() == 4 && !WhichDataType(arguments[3]).isDate())\n+        if (arguments.size() == 4 && !arguments[3]->isValueRepresentedByInteger())\n         {\n-            throw Exception{\"Illegal type \" + arguments[3]->getName() + \" of fourth argument of function \" + getName()\n-                + \", must be Date.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception{\"Illegal type \" + arguments[3]->getName() +\n+                            \" of fourth argument of function \" + getName() +\n+                            \" must be convertible to Int64.\", ErrorCodes::ILLEGAL_COLUMN};\n         }\n \n         return std::make_shared<DataTypeString>();\n@@ -377,68 +381,18 @@ class FunctionDictGetString final : public IFunction\n         String attr_name = attr_name_col->getValue<String>();\n \n         const auto id_col_untyped = block.getByPosition(arguments[2]).column.get();\n-        const auto date_col_untyped = block.getByPosition(arguments[3]).column.get();\n-        if (const auto id_col = checkAndGetColumn<ColumnUInt64>(id_col_untyped))\n-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);\n-        else if (const auto id_col = checkAndGetColumnConst<ColumnVector<UInt64>>(id_col_untyped))\n-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);\n-        else\n-        {\n-            throw Exception{\"Third argument of function \" + getName() + \" must be UInt64\", ErrorCodes::ILLEGAL_COLUMN};\n-        }\n-\n-        return true;\n-    }\n+        const auto range_col_untyped = block.getByPosition(arguments[3]).column.get();\n \n-    template <typename DictionaryType>\n-    void executeRange(\n-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,\n-        const ColumnUInt64 * id_col, const IColumn * date_col_untyped)\n-    {\n-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))\n-        {\n-            auto out = ColumnString::create();\n-            dictionary->getString(attr_name, id_col->getData(), date_col->getData(), out.get());\n-            block.getByPosition(result).column = std::move(out);\n-        }\n-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))\n-        {\n-            auto out = ColumnString::create();\n-            const PaddedPODArray<UInt16> dates(id_col->size(), date_col->getValue<UInt64>());\n-            dictionary->getString(attr_name, id_col->getData(), dates, out.get());\n-            block.getByPosition(result).column = std::move(out);\n-        }\n-        else\n-        {\n-            throw Exception{\"Fourth argument of function \" + getName() + \" must be Date\", ErrorCodes::ILLEGAL_COLUMN};\n-        }\n-    }\n+        PaddedPODArray<UInt64> id_col_values_storage;\n+        PaddedPODArray<Int64> range_col_values_storage;\n+        const auto * id_col_values = getColumnDataAsPaddedPODArray(id_col_untyped, &id_col_values_storage);\n+        const auto * range_col_values = getColumnDataAsPaddedPODArray(range_col_untyped, &range_col_values_storage);\n \n-    template <typename DictionaryType>\n-    void executeRange(\n-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,\n-        const ColumnConst * id_col, const IColumn * date_col_untyped)\n-    {\n-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))\n-        {\n-            auto out = ColumnString::create();\n-            const PaddedPODArray<UInt64> ids(date_col->size(), id_col->getValue<UInt64>());\n-            dictionary->getString(attr_name, ids, date_col->getData(), out.get());\n-            block.getByPosition(result).column = std::move(out);\n-        }\n-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))\n-        {\n-            const PaddedPODArray<UInt64> ids(1, id_col->getValue<UInt64>());\n-            const PaddedPODArray<UInt16> dates(1, date_col->getValue<UInt16>());\n+        auto out = ColumnString::create();\n+        dict->getString(attr_name, *id_col_values, *range_col_values, out.get());\n+        block.getByPosition(result).column = std::move(out);\n \n-            auto out = ColumnString::create();\n-            dictionary->getString(attr_name, ids, dates, out.get());\n-            block.getByPosition(result).column = DataTypeString().createColumnConst(id_col->size(), out->getDataAt(0).toString());\n-        }\n-        else\n-        {\n-            throw Exception{\"Fourth argument of function \" + getName() + \" must be Date\", ErrorCodes::ILLEGAL_COLUMN};\n-        }\n+        return true;\n     }\n \n     const ExternalDictionaries & dictionaries;\n@@ -666,7 +620,7 @@ template <> struct DictGetTraits<DATA_TYPE>\\\n     template <typename DictionaryType>\\\n     static void get(\\\n         const DictionaryType * dict, const std::string & name, const PaddedPODArray<UInt64> & ids,\\\n-        const PaddedPODArray<UInt16> & dates, PaddedPODArray<TYPE> & out)\\\n+        const PaddedPODArray<Int64> & dates, PaddedPODArray<TYPE> & out)\\\n     {\\\n         dict->get##TYPE(name, ids, dates, out);\\\n     }\\\n@@ -748,9 +702,15 @@ class FunctionDictGet final : public IFunction\n             throw Exception{\"Illegal type \" + arguments[2]->getName() + \" of third argument of function \" + getName()\n                 + \", must be UInt64 or tuple(...).\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n \n-        if (arguments.size() == 4 && !WhichDataType(arguments[3]).isDate())\n-            throw Exception{\"Illegal type \" + arguments[3]->getName() + \" of fourth argument of function \" + getName()\n-                + \", must be Date.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+        if (arguments.size() == 4 )\n+        {\n+            const auto range_argument = arguments[3].get();\n+            if (!(range_argument->isValueRepresentedByInteger() &&\n+                   range_argument->getSizeOfValueInMemory() <= sizeof(Int64)))\n+                throw Exception{\"Illegal type \" + range_argument->getName() + \" of fourth argument of function \" + getName()\n+                    + \", must be convertible to \" + TypeName<Int64>::get() + \".\",\n+                    ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+        }\n \n         return std::make_shared<DataType>();\n     }\n@@ -883,74 +843,19 @@ class FunctionDictGet final : public IFunction\n         String attr_name = attr_name_col->getValue<String>();\n \n         const auto id_col_untyped = block.getByPosition(arguments[2]).column.get();\n-        const auto date_col_untyped = block.getByPosition(arguments[3]).column.get();\n-        if (const auto id_col = checkAndGetColumn<ColumnUInt64>(id_col_untyped))\n-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);\n-        else if (const auto id_col = checkAndGetColumnConst<ColumnVector<UInt64>>(id_col_untyped))\n-            executeRange(block, result, dict, attr_name, id_col, date_col_untyped);\n-        else\n-            throw Exception{\"Third argument of function \" + getName() + \" must be UInt64\", ErrorCodes::ILLEGAL_COLUMN};\n+        const auto range_col_untyped = block.getByPosition(arguments[3]).column.get();\n \n-        return true;\n-    }\n+        PaddedPODArray<UInt64> id_col_values_storage;\n+        PaddedPODArray<Int64> range_col_values_storage;\n+        const auto * id_col_values = getColumnDataAsPaddedPODArray(id_col_untyped, &id_col_values_storage);\n+        const auto * range_col_values = getColumnDataAsPaddedPODArray(range_col_untyped, &range_col_values_storage);\n \n-    template <typename DictionaryType>\n-    void executeRange(\n-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,\n-        const ColumnUInt64 * id_col, const IColumn * date_col_untyped)\n-    {\n-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))\n-        {\n-            const auto size = id_col->size();\n-            const auto & ids = id_col->getData();\n-            const auto & dates = date_col->getData();\n-\n-            auto out = ColumnVector<Type>::create(size);\n-            auto & data = out->getData();\n-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);\n-            block.getByPosition(result).column = std::move(out);\n-        }\n-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))\n-        {\n-            const auto size = id_col->size();\n-            const auto & ids = id_col->getData();\n-            const PaddedPODArray<UInt16> dates(size, date_col->getValue<UInt16>());\n-\n-            auto out = ColumnVector<Type>::create(size);\n-            auto & data = out->getData();\n-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);\n-            block.getByPosition(result).column = std::move(out);\n-        }\n-        else\n-            throw Exception{\"Fourth argument of function \" + getName() + \" must be Date\", ErrorCodes::ILLEGAL_COLUMN};\n-    }\n-\n-    template <typename DictionaryType>\n-    void executeRange(\n-        Block & block, const size_t result, const DictionaryType * dictionary, const std::string & attr_name,\n-        const ColumnConst * id_col, const IColumn * date_col_untyped)\n-    {\n-        if (const auto date_col = checkAndGetColumn<ColumnUInt16>(date_col_untyped))\n-        {\n-            const auto size = date_col->size();\n-            const PaddedPODArray<UInt64> ids(size, id_col->getValue<UInt64>());\n-            const auto & dates = date_col->getData();\n+        auto out = ColumnVector<Type>::create(id_col_untyped->size());\n+        auto & data = out->getData();\n+        DictGetTraits<DataType>::get(dict, attr_name, *id_col_values, *range_col_values, data);\n+        block.getByPosition(result).column = std::move(out);\n \n-            auto out = ColumnVector<Type>::create(size);\n-            auto & data = out->getData();\n-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);\n-            block.getByPosition(result).column = std::move(out);\n-        }\n-        else if (const auto date_col = checkAndGetColumnConst<ColumnVector<UInt16>>(date_col_untyped))\n-        {\n-            const PaddedPODArray<UInt64> ids(1, id_col->getValue<UInt64>());\n-            const PaddedPODArray<UInt16> dates(1, date_col->getValue<UInt16>());\n-            PaddedPODArray<Type> data(1);\n-            DictGetTraits<DataType>::get(dictionary, attr_name, ids, dates, data);\n-            block.getByPosition(result).column = DataTypeNumber<Type>().createColumnConst(id_col->size(), toField(data.front()));\n-        }\n-        else\n-            throw Exception{\"Fourth argument of function \" + getName() + \" must be Date\", ErrorCodes::ILLEGAL_COLUMN};\n+        return true;\n     }\n \n     const ExternalDictionaries & dictionaries;\n@@ -1547,4 +1452,42 @@ class FunctionDictIsIn final : public IFunction\n     const ExternalDictionaries & dictionaries;\n };\n \n+\n+template <typename T>\n+auto getColumnData(const IColumn * column, size_t index) ->\n+    std::enable_if_t<std::is_signed_v<T> && std::is_integral_v<T>, Int64>\n+{\n+    return column->getInt(index);\n+}\n+\n+template <typename T>\n+auto getColumnData(const IColumn * column, size_t index) ->\n+    std::enable_if_t<std::is_unsigned_v<T> && std::is_integral_v<T>, UInt64>\n+{\n+    return column->getUInt(index);\n+}\n+\n+template <typename T>\n+const PaddedPODArray<T> * getColumnDataAsPaddedPODArray(const IColumn * column, PaddedPODArray<T> * backup_storage)\n+{\n+    if (const auto vector_col = checkAndGetColumn<ColumnVector<T>>(column))\n+    {\n+        return &vector_col->getData();\n+    }\n+    if (const auto const_col = checkAndGetColumnConstData<ColumnVector<T>>(column))\n+    {\n+        return &const_col->getData();\n+    }\n+\n+    // With type conversion, need to use backup storage here\n+    const auto size = column->size();\n+    backup_storage->resize(size);\n+    for (size_t i = 0; i < size; ++i)\n+    {\n+        (*backup_storage)[i] = getColumnData<T>(column, i);\n+    }\n+\n+    return backup_storage;\n+}\n+\n }\ndiff --git a/dbms/src/Storages/StorageDictionary.cpp b/dbms/src/Storages/StorageDictionary.cpp\nindex 26fdccbc3b8e..fab2e5408042 100644\n--- a/dbms/src/Storages/StorageDictionary.cpp\n+++ b/dbms/src/Storages/StorageDictionary.cpp\n@@ -54,9 +54,9 @@ NamesAndTypesList StorageDictionary::getNamesAndTypes(const DictionaryStructure\n     if (dictionary_structure.id)\n         dictionary_names_and_types.emplace_back(dictionary_structure.id->name, std::make_shared<DataTypeUInt64>());\n     if (dictionary_structure.range_min)\n-        dictionary_names_and_types.emplace_back(dictionary_structure.range_min->name, std::make_shared<DataTypeDate>());\n+        dictionary_names_and_types.emplace_back(dictionary_structure.range_min->name, dictionary_structure.range_min->type);\n     if (dictionary_structure.range_max)\n-        dictionary_names_and_types.emplace_back(dictionary_structure.range_max->name, std::make_shared<DataTypeDate>());\n+        dictionary_names_and_types.emplace_back(dictionary_structure.range_max->name, dictionary_structure.range_max->type);\n     if (dictionary_structure.key)\n         for (const auto & attribute : *dictionary_structure.key)\n             dictionary_names_and_types.emplace_back(attribute.name, attribute.type);\n",
  "test_patch": "diff --git a/dbms/tests/external_dictionaries/generate_and_test.py b/dbms/tests/external_dictionaries/generate_and_test.py\nindex 9c775610b2dc..98b673453268 100755\n--- a/dbms/tests/external_dictionaries/generate_and_test.py\n+++ b/dbms/tests/external_dictionaries/generate_and_test.py\n@@ -7,6 +7,7 @@\n import time\n import lxml.etree as et\n import atexit\n+import fnmatch\n from itertools import chain\n from os import system\n from argparse import ArgumentParser\n@@ -136,8 +137,16 @@ def generate_structure(args):\n             # [ 'library_c_complex_mixed_key_cache', 2, False ],\n         ])\n \n+    for range_hashed_range_type in range_hashed_range_types:\n+        base_name = 'range_hashed_' + range_hashed_range_type\n+        dictionaries.extend([\n+            [ 'file_' + base_name, 3, False ],\n+            # [ 'clickhouse_' + base_name, 3, True ],\n+            # [ 'executable_flat' + base_name, 3, True ]\n+        ])\n \n-files = [ 'key_simple.tsv', 'key_complex_integers.tsv', 'key_complex_mixed.tsv' ]\n+\n+files = [ 'key_simple.tsv', 'key_complex_integers.tsv', 'key_complex_mixed.tsv', 'key_range_hashed_{range_hashed_range_type}.tsv' ]\n \n \n types = [\n@@ -166,6 +175,37 @@ def generate_structure(args):\n     '2015-11-25', '2015-11-25 00:00:00', \"550e8400-e29b-41d4-a716-446655440000\"\n ]\n \n+range_hashed_range_types = [\n+    '', # default type (Date) for compatibility with older versions\n+    'UInt8', 'UInt16', 'UInt32', 'UInt64',\n+    'Int8', 'Int16', 'Int32', 'Int64',\n+    'Date', 'DateTime'\n+]\n+\n+# values for range_hashed dictionary according to range_min/range_max type.\n+range_hashed_dictGet_values = {\n+    # [(range_min, range_max), (hit, ...), (miss, ...)]\n+    # due to the nature of reference results, there should be equal number of hit and miss cases.\n+    'UInt8':  [('1', '10'), ('1', '5', '10'), ('0', '11', '255')],\n+    'UInt16': [('1', '10'), ('1', '5', '10'), ('0', '11', '65535')],\n+    'UInt32': [('1', '10'), ('1', '5', '10'), ('0', '11', '4294967295')],\n+    'UInt64': [('1', '10'), ('1', '5', '10'), ('0', '11', '18446744073709551605')],\n+    'Int8':   [('-10', '10'), ('-10', '0', '10'), ('-11', '11', '255')],\n+    'Int16':  [('-10', '10'), ('-10', '0', '10'), ('-11', '11', '65535')],\n+    'Int32':  [('-10', '10'), ('-10', '0', '10'), ('-11', '11', '4294967295')],\n+    'Int64':  [('-10', '10'), ('-10', '0', '10'), ('-11', '11', '18446744073709551605')],\n+    # default type (Date) for compatibility with older versions:\n+    '':         [(\"toDate('2015-11-20')\", \"toDate('2015-11-25')\"),\n+                 (\"toDate('2015-11-20')\", \"toDate('2015-11-22')\", \"toDate('2015-11-25')\"),\n+                 (\"toDate('2015-11-19')\", \"toDate('2015-11-26')\", \"toDate('2018-09-14')\")],\n+    'Date':     [(\"toDate('2015-11-20')\", \"toDate('2015-11-25')\"),\n+                 (\"toDate('2015-11-20')\", \"toDate('2015-11-22')\", \"toDate('2015-11-25')\"),\n+                 (\"toDate('2015-11-19')\", \"toDate('2015-11-26')\", \"toDate('2018-09-14')\")],\n+    'DateTime': [(\"toDateTime('2015-11-20 00:00:00')\", \"toDateTime('2015-11-25 00:00:00')\"),\n+                 (\"toDateTime('2015-11-20 00:00:00')\", \"toDateTime('2015-11-22 00:00:00')\", \"toDateTime('2015-11-25 00:00:00')\"),\n+                 (\"toDateTime('2015-11-19 23:59:59')\", \"toDateTime('2015-10-26 00:00:01')\", \"toDateTime('2018-09-14 00:00:00')\")],\n+}\n+\n \n def dump_report(destination, suite, test_case, report):\n     if destination is not None:\n@@ -196,7 +236,8 @@ def columns():\n     key_columns = [\n         [ 'id' ],\n         [ 'key0', 'key1' ],\n-        [ 'key0_str', 'key1' ]\n+        [ 'key0_str', 'key1' ],\n+        # Explicitly no column for range_hashed, since it is completely separate case\n     ]\n \n     print 'Creating ClickHouse table'\n@@ -214,13 +255,19 @@ def columns():\n               ') engine=Log; insert into test.dictionary_source format TabSeparated'\n               '\"'.format(source = args.source, ch = args.client, port = args.port))\n \n-    # generate 3 files with different key types\n+    # generate files with different key types\n     print 'Creating .tsv files'\n     file_source_query = 'select %s from test.dictionary_source format TabSeparated;'\n     for file, keys in zip(files, key_columns):\n         query = file_source_query % comma_separated(chain(keys, columns(), [ 'Parent' ] if 1 == len(keys) else []))\n         call([ args.client, '--port', args.port, '--query', query ], 'generated/' + file)\n \n+    for range_hashed_range_type in range_hashed_range_types:\n+        file = files[3].format(range_hashed_range_type=range_hashed_range_type)\n+        keys = list(chain(['id'], range_hashed_dictGet_values[range_hashed_range_type][0]))\n+        query = file_source_query % comma_separated(chain(keys, columns(), ['Parent'] if 1 == len(keys) else []))\n+        call([args.client, '--port', args.port, '--query', query], 'generated/' + file)\n+\n     # create MySQL table from complete_query\n     if not args.no_mysql:\n         print 'Creating MySQL table'\n@@ -411,6 +458,7 @@ def generate_dictionaries(args):\n     layout_cache = '<cache><size_in_cells>128</size_in_cells></cache>'\n     layout_complex_key_hashed = '<complex_key_hashed />'\n     layout_complex_key_cache = '<complex_key_cache><size_in_cells>128</size_in_cells></complex_key_cache>'\n+    layout_range_hashed = '<range_hashed />'\n \n     key_simple = '''\n     <id>\n@@ -444,7 +492,22 @@ def generate_dictionaries(args):\n     </key>\n     '''\n \n-    keys = [ key_simple, key_complex_integers, key_complex_mixed ]\n+    # For range hashed, range_min and range_max are kind of additional keys, so it makes sense to put it here.\n+    key_range_hashed = '''\n+    <id>\n+        <name>id</name>\n+    </id>\n+    <range_min>\n+            <name>StartDate</name>\n+            {range_hashed_range_type}\n+    </range_min>\n+    <range_max>\n+            <name>EndDate</name>\n+            {range_hashed_range_type}\n+    </range_max>\n+    '''\n+\n+    keys = [ key_simple, key_complex_integers, key_complex_mixed, key_range_hashed ]\n \n     parent_attribute = '''\n     <attribute>\n@@ -549,11 +612,27 @@ def generate_dictionaries(args):\n         #[ source_library_c, layout_complex_key_cache ],\n     ])\n \n+    for range_hashed_range_type in range_hashed_range_types:\n+        sources_and_layouts.extend([\n+            [ source_file % (generated_prefix + (files[3].format(range_hashed_range_type=range_hashed_range_type))), (layout_range_hashed, range_hashed_range_type) ],\n+            # [ source_clickhouse, layout_range_hashed ],\n+            # [ source_executable, layout_range_hashed ]\n+        ])\n+\n     for (name, key_idx, has_parent), (source, layout) in zip(dictionaries, sources_and_layouts):\n         filename = os.path.join(args.generated, 'dictionary_%s.xml' % name)\n+        key = keys[key_idx]\n+\n+        if key_idx == 3:\n+            layout, range_hashed_range_type = layout\n+            # Wrap non-empty type (default) with <type> tag.\n+            if range_hashed_range_type:\n+                range_hashed_range_type = '<type>{}</type>'.format(range_hashed_range_type)\n+            key = key.format(range_hashed_range_type=range_hashed_range_type)\n+\n         with open(filename, 'w') as file:\n             dictionary_xml = dictionary_skeleton.format(\n-                key = keys[key_idx], parent = parent_attribute if has_parent else '', **locals())\n+                parent = parent_attribute if has_parent else '', **locals())\n             file.write(dictionary_xml)\n \n \n@@ -570,17 +649,31 @@ def http_killer():\n         def https_killer():\n            https_server.kill()\n \n-    keys = [ 'toUInt64(n)', '(n, n)', '(toString(n), n)' ]\n+    if args.filter:\n+        print 'Only test cases matching filter \"{}\" are going to be executed.'.format(args.filter)\n+\n+    keys = [ 'toUInt64(n)', '(n, n)', '(toString(n), n)', 'toUInt64(n)' ]\n     dict_get_query_skeleton = \"select dictGet{type}('{name}', '{type}_', {key}) from system.one array join range(8) as n;\"\n     dict_has_query_skeleton = \"select dictHas('{name}', {key}) from system.one array join range(8) as n;\"\n     dict_get_or_default_query_skeleton = \"select dictGet{type}OrDefault('{name}', '{type}_', {key}, to{type}({default})) from system.one array join range(8) as n;\"\n     dict_hierarchy_query_skeleton = \"select dictGetHierarchy('{name}' as d, key), dictIsIn(d, key, toUInt64(1)), dictIsIn(d, key, key) from system.one array join range(toUInt64(8)) as key;\"\n+    # Designed to match 4 rows hit, 4 rows miss pattern of reference file\n+    dict_get_query_range_hashed_skeleton = \"\"\"\n+            select dictGet{type}('{name}', '{type}_', {key}, r)\n+            from system.one\n+                array join range(4) as n\n+                cross join (select r from system.one array join array({hit}, {miss}) as r);\n+    \"\"\"\n \n     def test_query(dict, query, reference, name):\n         global failures\n         global SERVER_DIED\n \n         print \"{0:100}\".format('Dictionary: ' + dict + ' Name: ' + name + \": \"),\n+        if args.filter and not fnmatch.fnmatch(dict, args.filter) and not fnmatch.fnmatch(name, args.filter):\n+            print \" ... skipped due to filter.\"\n+            return\n+\n         sys.stdout.flush()\n         report_testcase = et.Element(\"testcase\", attrib = {\"name\": name})\n \n@@ -688,19 +781,30 @@ def test_query(dict, query, reference, name):\n         key = keys[key_idx]\n         print 'Testing dictionary', name\n \n-        # query dictHas\n-        test_query(name, dict_has_query_skeleton.format(**locals()), 'has', 'dictHas')\n+        if key_idx == 3:\n+            t = name.split('_')[-1] # get range_min/max type from dictionary name\n+            for type, default in zip(types, explicit_defaults):\n+                if SERVER_DIED and not args.no_break:\n+                    break\n+                for hit, miss in zip(*range_hashed_dictGet_values[t][1:]):\n+                    test_query(name,\n+                        dict_get_query_range_hashed_skeleton.format(**locals()),\n+                            type, 'dictGet' + type)\n \n-        # query dictGet*\n-        for type, default in zip(types, explicit_defaults):\n-            if SERVER_DIED and not args.no_break:\n-                break\n-            test_query(name,\n-                dict_get_query_skeleton.format(**locals()),\n-                type, 'dictGet' + type)\n-            test_query(name,\n-                dict_get_or_default_query_skeleton.format(**locals()),\n-                type + 'OrDefault', 'dictGet' + type + 'OrDefault')\n+        else:\n+            # query dictHas is not supported for range_hashed dictionaries\n+            test_query(name, dict_has_query_skeleton.format(**locals()), 'has', 'dictHas')\n+\n+            # query dictGet*\n+            for type, default in zip(types, explicit_defaults):\n+                if SERVER_DIED and not args.no_break:\n+                    break\n+                test_query(name,\n+                    dict_get_query_skeleton.format(**locals()),\n+                    type, 'dictGet' + type)\n+                test_query(name,\n+                    dict_get_or_default_query_skeleton.format(**locals()),\n+                    type + 'OrDefault', 'dictGet' + type + 'OrDefault')\n \n         # query dictGetHierarchy, dictIsIn\n         if has_parent:\n@@ -750,6 +854,8 @@ def main(args):\n     parser.add_argument('--https_path', default = '/generated/', help = 'https server path')\n     parser.add_argument('--no_break', action='store_true', help = 'Dont stop on errors')\n \n+    parser.add_argument('--filter', type = str, default = None, help = 'Run only test cases matching given glob filter.')\n+\n     args = parser.parse_args()\n \n     main(args)\ndiff --git a/dbms/tests/external_dictionaries/run.sh b/dbms/tests/external_dictionaries/run.sh\nindex b134be0fac52..a04be3080a97 100755\n--- a/dbms/tests/external_dictionaries/run.sh\n+++ b/dbms/tests/external_dictionaries/run.sh\n@@ -7,78 +7,98 @@ if [ -z $(which python) ]; then\n     sudo apt-get -y install python-lxml python-termcolor\n fi\n \n-# MySQL\n-if [ -z $(which mysqld) ] || [ -z $(which mysqld) ]; then\n-    echo 'Installing MySQL'\n-    sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password password '\n-    sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password_again password '\n-    sudo apt-get -y --force-yes install mysql-server >/dev/null\n-    which mysqld >/dev/null\n-    if [ $? -ne 0 ]; then\n-        echo 'Failed installing mysql-server'\n-        exit -1\n+NO_MYSQL=0\n+NO_MONGO=0\n+\n+for arg in \"$@\"; do\n+    if [ \"$arg\" = \"--no_mysql\" ]; then\n+        NO_MYSQL=1\n+    fi\n+    if [ \"$arg\" == \"--no_mongo\" ]; then\n+        NO_MONGO=1\n     fi\n+done\n \n-    echo 'Installed mysql-server'\n+# MySQL\n+if [ $NO_MYSQL -eq 1 ]; then\n+    echo \"Not using MySQL\"\n else\n-    echo 'MySQL already installed'\n-fi\n+    if [ -z $(which mysqld) ] || [ -z $(which mysqld) ]; then\n+        echo 'Installing MySQL'\n+        sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password password '\n+        sudo debconf-set-selections <<< 'mysql-server mysql-server/root_password_again password '\n+        sudo apt-get -y --force-yes install mysql-server >/dev/null\n+        which mysqld >/dev/null\n+        if [ $? -ne 0 ]; then\n+            echo 'Failed installing mysql-server'\n+            exit -1\n+        fi\n \n-MY_CNF=/etc/mysql/my.cnf\n-LOCAL_INFILE_ENABLED=$(grep 'local-infile' $MY_CNF | cut -d= -f2)\n-if [ -z $LOCAL_INFILE_ENABLED ] || [ $LOCAL_INFILE_ENABLED != 1 ]; then\n-    echo 'Enabling local-infile support'\n-    if [ -z \"$(grep 'local-infile' $MY_CNF)\" ]; then\n-        # add local-infile\n-        MY_CNF_PATTERN='/\\[mysqld\\]/alocal-infile = 1'\n+        echo 'Installed mysql-server'\n     else\n-        # edit local-infile just in case\n-        MY_CNF_PATTERN='s/local-infile.*/local-infile = 1/'\n+        echo 'MySQL already installed'\n     fi\n-    sudo sed -i \"$MY_CNF_PATTERN\" $MY_CNF\n \n-    echo 'Enabled local-infile support for mysql'\n-    sudo service mysql stop\n-    sudo service mysql start\n-else\n-    echo 'Support for local-infile already present'\n-    echo 'select 1;' | mysql $MYSQL_OPTIONS &>/dev/null\n-    if [ $? -ne 0 ]; then\n+    MY_CNF=/etc/mysql/my.cnf\n+    LOCAL_INFILE_ENABLED=$(grep 'local-infile' $MY_CNF | cut -d= -f2)\n+    if [ -z $LOCAL_INFILE_ENABLED ] || [ $LOCAL_INFILE_ENABLED != 1 ]; then\n+        echo 'Enabling local-infile support'\n+        if [ -z \"$(grep 'local-infile' $MY_CNF)\" ]; then\n+            # add local-infile\n+            MY_CNF_PATTERN='/\\[mysqld\\]/alocal-infile = 1'\n+        else\n+            # edit local-infile just in case\n+            MY_CNF_PATTERN='s/local-infile.*/local-infile = 1/'\n+        fi\n+        sudo sed -i \"$MY_CNF_PATTERN\" $MY_CNF\n+\n+        echo 'Enabled local-infile support for mysql'\n+        sudo service mysql stop\n         sudo service mysql start\n     else\n-        echo 'MySQL already started'\n+        echo 'Support for local-infile already present'\n+        echo 'select 1;' | mysql $MYSQL_OPTIONS &>/dev/null\n+        if [ $? -ne 0 ]; then\n+            sudo service mysql start\n+        else\n+            echo 'MySQL already started'\n+        fi\n     fi\n fi\n \n # MongoDB\n-if [ -z $(which mongod) ] || [ -z $(which mongo) ]; then\n-    echo 'Installing MongoDB'\n+if [ $NO_MONGO -eq 1 ]; then\n+    echo \"Not using MongoDB\"\n+else\n+    if [ -z $(which mongod) ] || [ -z $(which mongo) ]; then\n+        echo 'Installing MongoDB'\n \n-    if [ $OS_NAME == \"trusty\" ]; then\n-        MONGODB_ORG_VERSION=3.0.6\n-        sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10 &>/dev/null\n-        #echo \"deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.list >/dev/null\n-        sudo apt-get update &>/dev/null\n-        sudo apt-get install -y mongodb-org=$MONGODB_ORG_VERSION >/dev/null\n+        if [ $OS_NAME == \"trusty\" ]; then\n+            MONGODB_ORG_VERSION=3.0.6\n+            sudo apt-key adv --keyserver hkp://keyserver.ubuntu.com:80 --recv 7F0CEB10 &>/dev/null\n+            #echo \"deb http://repo.mongodb.org/apt/ubuntu trusty/mongodb-org/3.0 multiverse\" | sudo tee /etc/apt/sources.list.d/mongodb-org-3.0.list >/dev/null\n+            sudo apt-get update &>/dev/null\n+            sudo apt-get install -y mongodb-org=$MONGODB_ORG_VERSION >/dev/null\n \n-        which mongod >/dev/null\n-        if [ $? -ne 0 ]; then\n-            echo 'Failed installing mongodb-org'\n-            exit -1\n+            which mongod >/dev/null\n+            if [ $? -ne 0 ]; then\n+                echo 'Failed installing mongodb-org'\n+                exit -1\n+            fi\n+\n+            echo \"Installed mongodb-org $MONGODB_ORG_VERSION\"\n+        else\n+            sudo apt-get install -y mongodb\n         fi\n \n-        echo \"Installed mongodb-org $MONGODB_ORG_VERSION\"\n-    else\n-        sudo apt-get install -y mongodb\n     fi\n \n-fi\n-\n-echo | mongo &>/dev/null\n-if [ $? -ne 0 ]; then\n-    sudo service mongod start\n-else\n-    echo 'MongoDB already started'\n+    echo | mongo &>/dev/null\n+    if [ $? -ne 0 ]; then\n+        sudo service mongod start\n+    else\n+        echo 'MongoDB already started'\n+    fi\n fi\n \n # ClickHouse\n@@ -91,7 +111,7 @@ if [ $? -ne 0 ]; then\n fi\n echo 'Started ClickHouse server'\n PID=$(grep PID clickhouse/status | sed 's/PID: //')\n-python ./generate_and_test.py\n+python ./generate_and_test.py \"$@\"\n if [ $? -ne 0 ]; then\n     echo 'Some test failed'\n fi\n",
  "problem_statement": "Support arbitrary data type for ranges in 'range_hashed' dictionary\n'range_hashed' dictionary supports only Date for range min/max. \r\n\r\nPlease consider support for other datatypes, e.g. DateTime, IntXX.\r\n\r\n    <range_min>\r\n        <name>smth_from</name>\r\n        <type>Int32</type>\r\n    </range_min>\r\n\r\n    <range_max>\r\n         <name>smth_to</name>\r\n         <type>Int32</type>\r\n    </range_max>\r\n\n",
  "hints_text": "This would be great. My use case is doing range queries for IP addresses but I cannot use `ip_trie` since many of the ranges cannot be represented as CIDR blocks, so I would want to use the FixedString(16) representation resulting from `IPv6StringToNum()`. \r\n\r\nHowever, it would be nice for any ordered type to be able to be used for range_min/range_max\nIt would be great for determining region from telephone number.",
  "created_at": "2018-09-13T13:43:10Z",
  "modified_files": [
    "dbms/src/DataTypes/IDataType.h",
    "dbms/src/Dictionaries/DictionarySourceFactory.cpp",
    "dbms/src/Dictionaries/DictionaryStructure.cpp",
    "dbms/src/Dictionaries/DictionaryStructure.h",
    "dbms/src/Dictionaries/RangeDictionaryBlockInputStream.h",
    "dbms/src/Dictionaries/RangeHashedDictionary.cpp",
    "dbms/src/Dictionaries/RangeHashedDictionary.h",
    "dbms/src/Functions/FunctionsExternalDictionaries.h",
    "dbms/src/Storages/StorageDictionary.cpp"
  ],
  "modified_test_files": [
    "dbms/tests/external_dictionaries/generate_and_test.py",
    "dbms/tests/external_dictionaries/run.sh"
  ]
}