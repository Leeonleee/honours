diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md
index 3b742e07482c..9735599a178a 100644
--- a/docs/en/sql-reference/functions/date-time-functions.md
+++ b/docs/en/sql-reference/functions/date-time-functions.md
@@ -2858,7 +2858,8 @@ Result:
 
 ## nowInBlock {#nowInBlock}
 
-Returns the current date and time at the moment of processing of each block of data. In contrast to the function [now](#now), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.
+Returns the current date and time at the moment of processing of each block of data.
+In contrast to the function [now](#now), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.
 
 It makes sense to use this function to generate the current time in long-running INSERT SELECT queries.
 
@@ -2898,6 +2899,74 @@ Result:
 └─────────────────────┴─────────────────────┴──────────┘
 ```
 
+## nowInBlock64 {#nowInBlock64}
+
+Returns the current date and time at the moment of processing of each block of data in milliseconds.
+In contrast to the function [now64](#now64), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.
+
+It makes sense to use this function to generate the current time in long-running INSERT SELECT queries.
+
+**Syntax**
+
+```sql
+nowInBlock([scale[, timezone]])
+```
+
+**Arguments**
+
+- `scale` - Tick size (precision): 10<sup>-precision</sup> seconds. Valid range: [ 0 : 9 ]. Typical values used: 3 (milliseconds), 6 (microseconds), 9 (nanoseconds) (optional).
+
+- `timezone` — [Timezone name](../../operations/server-configuration-parameters/settings.md#timezone) for the returned value (optional). [String](../data-types/string.md).
+
+**Returned value**
+
+- Current date and time at the moment of processing of each block of data with precision in  10<sup>-precision</sup> seconds. [DateTime](../data-types/datetime.md).
+
+**Example**
+
+```sql
+SELECT
+    now64(),
+    nowInBlock64(),
+    sleep(1)
+FROM numbers(3)
+SETTINGS max_block_size = 1
+FORMAT PrettyCompactMonoBlock
+```
+
+Result:
+
+```text
+┌─────────────────now64()─┬──────────nowInBlock64()─┬─sleep(1)─┐
+│ 2025-07-29 17:07:29.526 │ 2025-07-29 17:07:29.534 │        0 │
+│ 2025-07-29 17:07:29.526 │ 2025-07-29 17:07:30.535 │        0 │
+│ 2025-07-29 17:07:29.526 │ 2025-07-29 17:07:31.535 │        0 │
+└─────────────────────────┴─────────────────────────┴──────────┘
+```
+
+**Example with parameters**
+
+```sql
+SELECT
+    nowInBlock64(6),
+    nowInBlock64(6, 'America/Sao_Paulo'),
+    nowInBlock64(9, 'Pacific/Pitcairn'),
+    sleep(1)
+FROM numbers(3)
+SETTINGS max_block_size = 1
+FORMAT PrettyCompactMonoBlock
+```
+
+Result:
+
+```text
+┌────────────nowInBlock64(6)─┬─nowInBlock64(6, 'America/Sao_Paulo')─┬─nowInBlock64(9, 'Pacific/Pitcairn')─┬─sleep(1)─┐
+│ 2025-07-29 17:09:37.775725 │ 2025-07-29 17:09:37.775815           │ 2025-07-29 12:09:37.775856787       │        0 │
+│ 2025-07-29 17:09:38.776867 │ 2025-07-29 17:09:38.776888           │ 2025-07-29 12:09:38.776903370       │        0 │
+│ 2025-07-29 17:09:39.777645 │ 2025-07-29 17:09:39.777688           │ 2025-07-29 12:09:39.777725056       │        0 │
+└────────────────────────────┴──────────────────────────────────────┴─────────────────────────────────────┴──────────┘
+```
+
 ## today {#today}
 
 Returns the current date at moment of query analysis. It is the same as 'toDate(now())' and has aliases: `curdate`, `current_date`.
diff --git a/src/Functions/now64.cpp b/src/Functions/now64.cpp
index e9947d91de30..90322cd5ac43 100644
--- a/src/Functions/now64.cpp
+++ b/src/Functions/now64.cpp
@@ -1,17 +1,12 @@
-#include <DataTypes/DataTypeDateTime64.h>
-
-#include <Core/DecimalFunctions.h>
+#include <Common/assert_cast.h>
 #include <Core/Settings.h>
+#include <DataTypes/DataTypeDateTime64.h>
 #include <DataTypes/DataTypeNullable.h>
 #include <Functions/FunctionFactory.h>
 #include <Functions/IFunction.h>
 #include <Functions/extractTimeZoneFromFunctionArguments.h>
+#include <Functions/nowSubsecond.h>
 #include <Interpreters/Context.h>
-#include <Common/intExp10.h>
-
-#include <Common/assert_cast.h>
-
-#include <ctime>
 
 
 namespace DB
@@ -24,36 +19,12 @@ namespace Setting
 namespace ErrorCodes
 {
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int CANNOT_CLOCK_GETTIME;
     extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;
 }
 
 namespace
 {
 
-Field nowSubsecond(UInt32 scale)
-{
-    static constexpr Int32 fractional_scale = 9;
-
-    timespec spec{};
-    if (clock_gettime(CLOCK_REALTIME, &spec))
-        throw ErrnoException(ErrorCodes::CANNOT_CLOCK_GETTIME, "Cannot clock_gettime");
-
-    DecimalUtils::DecimalComponents<DateTime64> components{spec.tv_sec, spec.tv_nsec};
-
-    // clock_gettime produces subsecond part in nanoseconds, but decimalFromComponents fractional is scale-dependent.
-    // Andjust fractional to scale, e.g. for 123456789 nanoseconds:
-    //   if scale is  6 (miscoseconds) => divide by 9 - 6 = 3 to get 123456 microseconds
-    //   if scale is 12 (picoseconds)  => multiply by abs(9 - 12) = 3 to get 123456789000 picoseconds
-    const auto adjust_scale = fractional_scale - static_cast<Int32>(scale);
-    if (adjust_scale < 0)
-        components.fractional *= intExp10(std::abs(adjust_scale));
-    else if (adjust_scale > 0)
-        components.fractional /= intExp10(adjust_scale);
-
-    return DecimalField<DateTime64>(DecimalUtils::decimalFromComponents<DateTime64>(components, scale), scale);
-}
-
 /// Get the current time. (It is a constant, it is evaluated once for the entire query.)
 class ExecutableFunctionNow64 : public IExecutableFunction
 {
diff --git a/src/Functions/nowInBlock.cpp b/src/Functions/nowInBlock.cpp
index 146a48f78b4c..0d87e31f9e00 100644
--- a/src/Functions/nowInBlock.cpp
+++ b/src/Functions/nowInBlock.cpp
@@ -1,10 +1,10 @@
-#include <Functions/IFunction.h>
-#include <Functions/FunctionFactory.h>
-#include <Functions/extractTimeZoneFromFunctionArguments.h>
-#include <DataTypes/DataTypeDateTime.h>
-#include <Columns/ColumnsDateTime.h>
 #include <Columns/ColumnVector.h>
+#include <Columns/ColumnsDateTime.h>
 #include <Core/Settings.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/IFunction.h>
+#include <Functions/extractTimeZoneFromFunctionArguments.h>
 #include <Interpreters/Context.h>
 
 
@@ -17,8 +17,8 @@ namespace Setting
 
 namespace ErrorCodes
 {
-    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;
 }
 
 namespace
@@ -39,46 +39,24 @@ class FunctionNowInBlock : public IFunction
         : allow_nonconst_timezone_arguments(context->getSettingsRef()[Setting::allow_nonconst_timezone_arguments])
     {}
 
-    String getName() const override
-    {
-        return name;
-    }
-
-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override
-    {
-        return false;
-    }
-
-    /// Optional timezone argument.
-    bool isVariadic() const override { return true; }
-
+    String getName() const override { return name; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+    bool isVariadic() const override { return true; } /// Optional timezone argument.
     size_t getNumberOfArguments() const override { return 0; }
-
-    bool isDeterministic() const override
-    {
-        return false;
-    }
-
-    bool isDeterministicInScopeOfQuery() const override
-    {
-        return false;
-    }
+    bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return false; }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
     {
         if (arguments.size() > 1)
-        {
-            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, "Arguments size of function {} should be 0 or 1", getName());
-        }
+            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, "Function {} should have 0 or 1 arguments", getName());
+
         if (arguments.size() == 1 && !isStringOrFixedString(arguments[0].type))
-        {
-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Arguments of function {} should be String or FixedString",
-                getName());
-        }
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "1st argument of function {} should be String or FixedString", getName());
+
         if (arguments.size() == 1)
-        {
             return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 0, 0, allow_nonconst_timezone_arguments));
-        }
+
         return std::make_shared<DataTypeDateTime>();
     }
 
@@ -86,6 +64,7 @@ class FunctionNowInBlock : public IFunction
     {
         return ColumnDateTime::create(input_rows_count, static_cast<UInt32>(time(nullptr)));
     }
+
 private:
     const bool allow_nonconst_timezone_arguments;
 };
diff --git a/src/Functions/nowInBlock64.cpp b/src/Functions/nowInBlock64.cpp
new file mode 100644
index 000000000000..fb384101a5fd
--- /dev/null
+++ b/src/Functions/nowInBlock64.cpp
@@ -0,0 +1,120 @@
+#include <Columns/ColumnVector.h>
+#include <Columns/ColumnsDateTime.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <Functions/IFunction.h>
+#include <Functions/extractTimeZoneFromFunctionArguments.h>
+#include <Functions/nowSubsecond.h>
+#include <Interpreters/Context.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;
+    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;
+}
+
+namespace
+{
+
+/** Returns current time at calculation of every block.
+* In contrast to 'now64' function, it's not a constant expression and is not a subject of constant folding.
+*/
+class FunctionNowInBlock64 : public IFunction
+{
+public:
+    static constexpr auto name = "nowInBlock64";
+    static FunctionPtr create(ContextPtr /*context*/) { return std::make_shared<FunctionNowInBlock64>(); }
+
+    String getName() const override { return name; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
+    bool isVariadic() const override { return true; } /// Optional timezone argument.
+    size_t getNumberOfArguments() const override { return 0; }
+    bool isDeterministic() const override { return false; }
+    bool isDeterministicInScopeOfQuery() const override { return false; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+        if (arguments.empty())
+            return std::make_shared<DataTypeDateTime64>(DataTypeDateTime64::default_scale);
+
+        if (arguments.size() > 2)
+            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, "Function {} should have 0, 1 or 2 arguments", getName());
+
+        if (!isInteger(arguments[0].type))
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "1st argument of function {} should be (U)Int*", getName());
+
+        auto scale = static_cast<UInt32>(arguments[0].column->get64(0));
+
+        if (arguments.size() == 1)
+            return std::make_shared<DataTypeDateTime64>(scale);
+
+        if (!isStringOrFixedString(arguments[1].type))
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "2nd argument of function {} should be String or FixedString", getName());
+
+        return std::make_shared<DataTypeDateTime64>(scale, extractTimeZoneNameFromFunctionArguments(arguments, 1, 1, false));
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr & type, size_t input_rows_count) const override
+    {
+        const auto * data_type_datetime64 = checkAndGetDataType<DataTypeDateTime64>(type.get());
+
+        if (!data_type_datetime64)
+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, "Expected a DateTime64, got {}", type->getName());
+
+        auto col_res = ColumnDateTime64::create(input_rows_count, data_type_datetime64->getScale());
+        auto & vec_res = col_res->getData();
+
+        auto now = nowSubsecond(data_type_datetime64->getScale()).safeGet<Decimal64>();
+        for (size_t i = 0; i < input_rows_count; ++i)
+            vec_res[i] = now.getValue();
+
+        return col_res;
+    }
+};
+
+}
+
+REGISTER_FUNCTION(NowInBlock64)
+{
+    FunctionDocumentation::Description description = R"(
+Returns the current date and time at the moment of processing of each block of data in milliseconds. In contrast to the function [now64](#now64), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.
+
+It makes sense to use this function to generate the current time in long-running INSERT SELECT queries.
+    )";
+    FunctionDocumentation::Syntax syntax = R"(
+nowInBlock([scale[, timezone]])
+    )";
+    FunctionDocumentation::Arguments arguments = {
+        {"scale", "Optional. Tick size (precision): 10^-precision seconds. Valid range: [0 : 9]. Typically, are used - 3 (default) (milliseconds), 6 (microseconds), 9 (nanoseconds).", {"UInt8"}},
+        {"timezone", "Optional. Timezone name for the returned value.", {"String"}}
+    };
+    FunctionDocumentation::ReturnedValue returned_value = {"Returns the current date and time at the moment of processing of each block of data with sub-second precision.", {"DateTime64"}};
+    FunctionDocumentation::Examples examples = {
+        {"Difference with the now64() function", R"(
+SELECT
+    now64(),
+    nowInBlock64(),
+    sleep(1)
+FROM numbers(3)
+SETTINGS max_block_size = 1
+FORMAT PrettyCompactMonoBlock
+        )",
+        R"(
+┌─────────────────now64()─┬──────────nowInBlock64()─┬─sleep(1)─┐
+│ 2025-07-29 17:07:29.526 │ 2025-07-29 17:07:29.534 │        0 │
+│ 2025-07-29 17:07:29.526 │ 2025-07-29 17:07:30.535 │        0 │
+│ 2025-07-29 17:07:29.526 │ 2025-07-29 17:07:31.535 │        0 │
+└─────────────────────────┴─────────────────────────┴──────────┘
+        )"}
+    };
+    FunctionDocumentation::IntroducedIn introduced_in = {25, 8};
+    FunctionDocumentation::Category category = FunctionDocumentation::Category::DateAndTime;
+    FunctionDocumentation documentation = {description, syntax, arguments, returned_value, examples, introduced_in, category};
+
+    factory.registerFunction<FunctionNowInBlock64>(documentation);
+}
+
+}
diff --git a/src/Functions/nowSubsecond.cpp b/src/Functions/nowSubsecond.cpp
new file mode 100644
index 000000000000..89fc2c0cdf70
--- /dev/null
+++ b/src/Functions/nowSubsecond.cpp
@@ -0,0 +1,37 @@
+#include <Common/intExp10.h>
+#include <Core/DecimalFunctions.h>
+#include <DataTypes/DataTypeDateTime.h>
+#include <Functions/nowSubsecond.h>
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int CANNOT_CLOCK_GETTIME;
+}
+
+Field nowSubsecond(UInt32 scale)
+{
+    static constexpr Int32 fractional_scale = 9;
+
+    timespec spec{};
+    if (clock_gettime(CLOCK_REALTIME, &spec))
+        throw ErrnoException(ErrorCodes::CANNOT_CLOCK_GETTIME, "Cannot clock_gettime");
+
+    DecimalUtils::DecimalComponents<DateTime64> components{spec.tv_sec, spec.tv_nsec};
+
+    // clock_gettime produces subsecond part in nanoseconds, but decimalFromComponents fractional is scale-dependent.
+    // Andjust fractional to scale, e.g. for 123456789 nanoseconds:
+    //   if scale is  6 (miscoseconds) => divide by 9 - 6 = 3 to get 123456 microseconds
+    //   if scale is 12 (picoseconds)  => multiply by abs(9 - 12) = 3 to get 123456789000 picoseconds
+    const auto adjust_scale = fractional_scale - static_cast<Int32>(scale);
+    if (adjust_scale < 0)
+        components.fractional *= intExp10(std::abs(adjust_scale));
+    else if (adjust_scale > 0)
+        components.fractional /= intExp10(adjust_scale);
+
+    return DecimalField<DateTime64>(DecimalUtils::decimalFromComponents<DateTime64>(components, scale), scale);
+}
+
+}
diff --git a/src/Functions/nowSubsecond.h b/src/Functions/nowSubsecond.h
new file mode 100644
index 000000000000..7c7ef690898c
--- /dev/null
+++ b/src/Functions/nowSubsecond.h
@@ -0,0 +1,10 @@
+#pragma once
+
+#include <Core/Field.h>
+
+namespace DB
+{
+
+Field nowSubsecond(UInt32 scale);
+
+}
