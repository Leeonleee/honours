{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 84178,
  "instance_id": "ClickHouse__ClickHouse-84178",
  "issue_numbers": [
    "83526"
  ],
  "base_commit": "1ee2c21a0a07ab1d2e846827c84aa99647b2ce3b",
  "patch": "diff --git a/docs/en/sql-reference/functions/date-time-functions.md b/docs/en/sql-reference/functions/date-time-functions.md\nindex 3b742e07482c..9735599a178a 100644\n--- a/docs/en/sql-reference/functions/date-time-functions.md\n+++ b/docs/en/sql-reference/functions/date-time-functions.md\n@@ -2858,7 +2858,8 @@ Result:\n \n ## nowInBlock {#nowInBlock}\n \n-Returns the current date and time at the moment of processing of each block of data. In contrast to the function [now](#now), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.\n+Returns the current date and time at the moment of processing of each block of data.\n+In contrast to the function [now](#now), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.\n \n It makes sense to use this function to generate the current time in long-running INSERT SELECT queries.\n \n@@ -2898,6 +2899,74 @@ Result:\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## nowInBlock64 {#nowInBlock64}\n+\n+Returns the current date and time at the moment of processing of each block of data in milliseconds.\n+In contrast to the function [now64](#now64), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.\n+\n+It makes sense to use this function to generate the current time in long-running INSERT SELECT queries.\n+\n+**Syntax**\n+\n+```sql\n+nowInBlock([scale[, timezone]])\n+```\n+\n+**Arguments**\n+\n+- `scale` - Tick size (precision): 10<sup>-precision</sup> seconds. Valid range: [ 0 : 9 ]. Typical values used: 3 (milliseconds), 6 (microseconds), 9 (nanoseconds) (optional).\n+\n+- `timezone` \u2014 [Timezone name](../../operations/server-configuration-parameters/settings.md#timezone) for the returned value (optional). [String](../data-types/string.md).\n+\n+**Returned value**\n+\n+- Current date and time at the moment of processing of each block of data with precision in  10<sup>-precision</sup> seconds. [DateTime](../data-types/datetime.md).\n+\n+**Example**\n+\n+```sql\n+SELECT\n+    now64(),\n+    nowInBlock64(),\n+    sleep(1)\n+FROM numbers(3)\n+SETTINGS max_block_size = 1\n+FORMAT PrettyCompactMonoBlock\n+```\n+\n+Result:\n+\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now64()\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500nowInBlock64()\u2500\u252c\u2500sleep(1)\u2500\u2510\n+\u2502 2025-07-29 17:07:29.526 \u2502 2025-07-29 17:07:29.534 \u2502        0 \u2502\n+\u2502 2025-07-29 17:07:29.526 \u2502 2025-07-29 17:07:30.535 \u2502        0 \u2502\n+\u2502 2025-07-29 17:07:29.526 \u2502 2025-07-29 17:07:31.535 \u2502        0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n+**Example with parameters**\n+\n+```sql\n+SELECT\n+    nowInBlock64(6),\n+    nowInBlock64(6, 'America/Sao_Paulo'),\n+    nowInBlock64(9, 'Pacific/Pitcairn'),\n+    sleep(1)\n+FROM numbers(3)\n+SETTINGS max_block_size = 1\n+FORMAT PrettyCompactMonoBlock\n+```\n+\n+Result:\n+\n+```text\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500nowInBlock64(6)\u2500\u252c\u2500nowInBlock64(6, 'America/Sao_Paulo')\u2500\u252c\u2500nowInBlock64(9, 'Pacific/Pitcairn')\u2500\u252c\u2500sleep(1)\u2500\u2510\n+\u2502 2025-07-29 17:09:37.775725 \u2502 2025-07-29 17:09:37.775815           \u2502 2025-07-29 12:09:37.775856787       \u2502        0 \u2502\n+\u2502 2025-07-29 17:09:38.776867 \u2502 2025-07-29 17:09:38.776888           \u2502 2025-07-29 12:09:38.776903370       \u2502        0 \u2502\n+\u2502 2025-07-29 17:09:39.777645 \u2502 2025-07-29 17:09:39.777688           \u2502 2025-07-29 12:09:39.777725056       \u2502        0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## today {#today}\n \n Returns the current date at moment of query analysis. It is the same as 'toDate(now())' and has aliases: `curdate`, `current_date`.\ndiff --git a/src/Functions/now64.cpp b/src/Functions/now64.cpp\nindex e9947d91de30..90322cd5ac43 100644\n--- a/src/Functions/now64.cpp\n+++ b/src/Functions/now64.cpp\n@@ -1,17 +1,12 @@\n-#include <DataTypes/DataTypeDateTime64.h>\n-\n-#include <Core/DecimalFunctions.h>\n+#include <Common/assert_cast.h>\n #include <Core/Settings.h>\n+#include <DataTypes/DataTypeDateTime64.h>\n #include <DataTypes/DataTypeNullable.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/IFunction.h>\n #include <Functions/extractTimeZoneFromFunctionArguments.h>\n+#include <Functions/nowSubsecond.h>\n #include <Interpreters/Context.h>\n-#include <Common/intExp10.h>\n-\n-#include <Common/assert_cast.h>\n-\n-#include <ctime>\n \n \n namespace DB\n@@ -24,36 +19,12 @@ namespace Setting\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int CANNOT_CLOCK_GETTIME;\n     extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;\n }\n \n namespace\n {\n \n-Field nowSubsecond(UInt32 scale)\n-{\n-    static constexpr Int32 fractional_scale = 9;\n-\n-    timespec spec{};\n-    if (clock_gettime(CLOCK_REALTIME, &spec))\n-        throw ErrnoException(ErrorCodes::CANNOT_CLOCK_GETTIME, \"Cannot clock_gettime\");\n-\n-    DecimalUtils::DecimalComponents<DateTime64> components{spec.tv_sec, spec.tv_nsec};\n-\n-    // clock_gettime produces subsecond part in nanoseconds, but decimalFromComponents fractional is scale-dependent.\n-    // Andjust fractional to scale, e.g. for 123456789 nanoseconds:\n-    //   if scale is  6 (miscoseconds) => divide by 9 - 6 = 3 to get 123456 microseconds\n-    //   if scale is 12 (picoseconds)  => multiply by abs(9 - 12) = 3 to get 123456789000 picoseconds\n-    const auto adjust_scale = fractional_scale - static_cast<Int32>(scale);\n-    if (adjust_scale < 0)\n-        components.fractional *= intExp10(std::abs(adjust_scale));\n-    else if (adjust_scale > 0)\n-        components.fractional /= intExp10(adjust_scale);\n-\n-    return DecimalField<DateTime64>(DecimalUtils::decimalFromComponents<DateTime64>(components, scale), scale);\n-}\n-\n /// Get the current time. (It is a constant, it is evaluated once for the entire query.)\n class ExecutableFunctionNow64 : public IExecutableFunction\n {\ndiff --git a/src/Functions/nowInBlock.cpp b/src/Functions/nowInBlock.cpp\nindex 146a48f78b4c..0d87e31f9e00 100644\n--- a/src/Functions/nowInBlock.cpp\n+++ b/src/Functions/nowInBlock.cpp\n@@ -1,10 +1,10 @@\n-#include <Functions/IFunction.h>\n-#include <Functions/FunctionFactory.h>\n-#include <Functions/extractTimeZoneFromFunctionArguments.h>\n-#include <DataTypes/DataTypeDateTime.h>\n-#include <Columns/ColumnsDateTime.h>\n #include <Columns/ColumnVector.h>\n+#include <Columns/ColumnsDateTime.h>\n #include <Core/Settings.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n #include <Interpreters/Context.h>\n \n \n@@ -17,8 +17,8 @@ namespace Setting\n \n namespace ErrorCodes\n {\n-    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;\n }\n \n namespace\n@@ -39,46 +39,24 @@ class FunctionNowInBlock : public IFunction\n         : allow_nonconst_timezone_arguments(context->getSettingsRef()[Setting::allow_nonconst_timezone_arguments])\n     {}\n \n-    String getName() const override\n-    {\n-        return name;\n-    }\n-\n-    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override\n-    {\n-        return false;\n-    }\n-\n-    /// Optional timezone argument.\n-    bool isVariadic() const override { return true; }\n-\n+    String getName() const override { return name; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+    bool isVariadic() const override { return true; } /// Optional timezone argument.\n     size_t getNumberOfArguments() const override { return 0; }\n-\n-    bool isDeterministic() const override\n-    {\n-        return false;\n-    }\n-\n-    bool isDeterministicInScopeOfQuery() const override\n-    {\n-        return false;\n-    }\n+    bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return false; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n     {\n         if (arguments.size() > 1)\n-        {\n-            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, \"Arguments size of function {} should be 0 or 1\", getName());\n-        }\n+            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, \"Function {} should have 0 or 1 arguments\", getName());\n+\n         if (arguments.size() == 1 && !isStringOrFixedString(arguments[0].type))\n-        {\n-            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Arguments of function {} should be String or FixedString\",\n-                getName());\n-        }\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"1st argument of function {} should be String or FixedString\", getName());\n+\n         if (arguments.size() == 1)\n-        {\n             return std::make_shared<DataTypeDateTime>(extractTimeZoneNameFromFunctionArguments(arguments, 0, 0, allow_nonconst_timezone_arguments));\n-        }\n+\n         return std::make_shared<DataTypeDateTime>();\n     }\n \n@@ -86,6 +64,7 @@ class FunctionNowInBlock : public IFunction\n     {\n         return ColumnDateTime::create(input_rows_count, static_cast<UInt32>(time(nullptr)));\n     }\n+\n private:\n     const bool allow_nonconst_timezone_arguments;\n };\ndiff --git a/src/Functions/nowInBlock64.cpp b/src/Functions/nowInBlock64.cpp\nnew file mode 100644\nindex 000000000000..fb384101a5fd\n--- /dev/null\n+++ b/src/Functions/nowInBlock64.cpp\n@@ -0,0 +1,120 @@\n+#include <Columns/ColumnVector.h>\n+#include <Columns/ColumnsDateTime.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <Functions/IFunction.h>\n+#include <Functions/extractTimeZoneFromFunctionArguments.h>\n+#include <Functions/nowSubsecond.h>\n+#include <Interpreters/Context.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n+    extern const int TOO_MANY_ARGUMENTS_FOR_FUNCTION;\n+}\n+\n+namespace\n+{\n+\n+/** Returns current time at calculation of every block.\n+* In contrast to 'now64' function, it's not a constant expression and is not a subject of constant folding.\n+*/\n+class FunctionNowInBlock64 : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"nowInBlock64\";\n+    static FunctionPtr create(ContextPtr /*context*/) { return std::make_shared<FunctionNowInBlock64>(); }\n+\n+    String getName() const override { return name; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n+    bool isVariadic() const override { return true; } /// Optional timezone argument.\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isDeterministic() const override { return false; }\n+    bool isDeterministicInScopeOfQuery() const override { return false; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+        if (arguments.empty())\n+            return std::make_shared<DataTypeDateTime64>(DataTypeDateTime64::default_scale);\n+\n+        if (arguments.size() > 2)\n+            throw Exception(ErrorCodes::TOO_MANY_ARGUMENTS_FOR_FUNCTION, \"Function {} should have 0, 1 or 2 arguments\", getName());\n+\n+        if (!isInteger(arguments[0].type))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"1st argument of function {} should be (U)Int*\", getName());\n+\n+        auto scale = static_cast<UInt32>(arguments[0].column->get64(0));\n+\n+        if (arguments.size() == 1)\n+            return std::make_shared<DataTypeDateTime64>(scale);\n+\n+        if (!isStringOrFixedString(arguments[1].type))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"2nd argument of function {} should be String or FixedString\", getName());\n+\n+        return std::make_shared<DataTypeDateTime64>(scale, extractTimeZoneNameFromFunctionArguments(arguments, 1, 1, false));\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName &, const DataTypePtr & type, size_t input_rows_count) const override\n+    {\n+        const auto * data_type_datetime64 = checkAndGetDataType<DataTypeDateTime64>(type.get());\n+\n+        if (!data_type_datetime64)\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT, \"Expected a DateTime64, got {}\", type->getName());\n+\n+        auto col_res = ColumnDateTime64::create(input_rows_count, data_type_datetime64->getScale());\n+        auto & vec_res = col_res->getData();\n+\n+        auto now = nowSubsecond(data_type_datetime64->getScale()).safeGet<Decimal64>();\n+        for (size_t i = 0; i < input_rows_count; ++i)\n+            vec_res[i] = now.getValue();\n+\n+        return col_res;\n+    }\n+};\n+\n+}\n+\n+REGISTER_FUNCTION(NowInBlock64)\n+{\n+    FunctionDocumentation::Description description = R\"(\n+Returns the current date and time at the moment of processing of each block of data in milliseconds. In contrast to the function [now64](#now64), it is not a constant expression, and the returned value will be different in different blocks for long-running queries.\n+\n+It makes sense to use this function to generate the current time in long-running INSERT SELECT queries.\n+    )\";\n+    FunctionDocumentation::Syntax syntax = R\"(\n+nowInBlock([scale[, timezone]])\n+    )\";\n+    FunctionDocumentation::Arguments arguments = {\n+        {\"scale\", \"Optional. Tick size (precision): 10^-precision seconds. Valid range: [0 : 9]. Typically, are used - 3 (default) (milliseconds), 6 (microseconds), 9 (nanoseconds).\", {\"UInt8\"}},\n+        {\"timezone\", \"Optional. Timezone name for the returned value.\", {\"String\"}}\n+    };\n+    FunctionDocumentation::ReturnedValue returned_value = {\"Returns the current date and time at the moment of processing of each block of data with sub-second precision.\", {\"DateTime64\"}};\n+    FunctionDocumentation::Examples examples = {\n+        {\"Difference with the now64() function\", R\"(\n+SELECT\n+    now64(),\n+    nowInBlock64(),\n+    sleep(1)\n+FROM numbers(3)\n+SETTINGS max_block_size = 1\n+FORMAT PrettyCompactMonoBlock\n+        )\",\n+        R\"(\n+\u250c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500now64()\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500nowInBlock64()\u2500\u252c\u2500sleep(1)\u2500\u2510\n+\u2502 2025-07-29 17:07:29.526 \u2502 2025-07-29 17:07:29.534 \u2502        0 \u2502\n+\u2502 2025-07-29 17:07:29.526 \u2502 2025-07-29 17:07:30.535 \u2502        0 \u2502\n+\u2502 2025-07-29 17:07:29.526 \u2502 2025-07-29 17:07:31.535 \u2502        0 \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+        )\"}\n+    };\n+    FunctionDocumentation::IntroducedIn introduced_in = {25, 8};\n+    FunctionDocumentation::Category category = FunctionDocumentation::Category::DateAndTime;\n+    FunctionDocumentation documentation = {description, syntax, arguments, returned_value, examples, introduced_in, category};\n+\n+    factory.registerFunction<FunctionNowInBlock64>(documentation);\n+}\n+\n+}\ndiff --git a/src/Functions/nowSubsecond.cpp b/src/Functions/nowSubsecond.cpp\nnew file mode 100644\nindex 000000000000..89fc2c0cdf70\n--- /dev/null\n+++ b/src/Functions/nowSubsecond.cpp\n@@ -0,0 +1,37 @@\n+#include <Common/intExp10.h>\n+#include <Core/DecimalFunctions.h>\n+#include <DataTypes/DataTypeDateTime.h>\n+#include <Functions/nowSubsecond.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int CANNOT_CLOCK_GETTIME;\n+}\n+\n+Field nowSubsecond(UInt32 scale)\n+{\n+    static constexpr Int32 fractional_scale = 9;\n+\n+    timespec spec{};\n+    if (clock_gettime(CLOCK_REALTIME, &spec))\n+        throw ErrnoException(ErrorCodes::CANNOT_CLOCK_GETTIME, \"Cannot clock_gettime\");\n+\n+    DecimalUtils::DecimalComponents<DateTime64> components{spec.tv_sec, spec.tv_nsec};\n+\n+    // clock_gettime produces subsecond part in nanoseconds, but decimalFromComponents fractional is scale-dependent.\n+    // Andjust fractional to scale, e.g. for 123456789 nanoseconds:\n+    //   if scale is  6 (miscoseconds) => divide by 9 - 6 = 3 to get 123456 microseconds\n+    //   if scale is 12 (picoseconds)  => multiply by abs(9 - 12) = 3 to get 123456789000 picoseconds\n+    const auto adjust_scale = fractional_scale - static_cast<Int32>(scale);\n+    if (adjust_scale < 0)\n+        components.fractional *= intExp10(std::abs(adjust_scale));\n+    else if (adjust_scale > 0)\n+        components.fractional /= intExp10(adjust_scale);\n+\n+    return DecimalField<DateTime64>(DecimalUtils::decimalFromComponents<DateTime64>(components, scale), scale);\n+}\n+\n+}\ndiff --git a/src/Functions/nowSubsecond.h b/src/Functions/nowSubsecond.h\nnew file mode 100644\nindex 000000000000..7c7ef690898c\n--- /dev/null\n+++ b/src/Functions/nowSubsecond.h\n@@ -0,0 +1,10 @@\n+#pragma once\n+\n+#include <Core/Field.h>\n+\n+namespace DB\n+{\n+\n+Field nowSubsecond(UInt32 scale);\n+\n+}\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02372_now_in_block.reference b/tests/queries/0_stateless/02372_nowInBlock.reference\nsimilarity index 100%\nrename from tests/queries/0_stateless/02372_now_in_block.reference\nrename to tests/queries/0_stateless/02372_nowInBlock.reference\ndiff --git a/tests/queries/0_stateless/02372_now_in_block.sql b/tests/queries/0_stateless/02372_nowInBlock.sql\nsimilarity index 99%\nrename from tests/queries/0_stateless/02372_now_in_block.sql\nrename to tests/queries/0_stateless/02372_nowInBlock.sql\nindex d0aec471801b..ee067f5e4df9 100644\n--- a/tests/queries/0_stateless/02372_now_in_block.sql\n+++ b/tests/queries/0_stateless/02372_nowInBlock.sql\n@@ -1,4 +1,5 @@\n SET max_rows_to_read = 0, max_bytes_to_read = 0;\n+\n SELECT count() FROM (SELECT DISTINCT nowInBlock(), nowInBlock('Pacific/Pitcairn') FROM system.numbers LIMIT 2);\n SELECT nowInBlock(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n SELECT nowInBlock(NULL) IS NULL;\ndiff --git a/tests/queries/0_stateless/03567_nowInBlock64.reference b/tests/queries/0_stateless/03567_nowInBlock64.reference\nnew file mode 100644\nindex 000000000000..f00580c40607\n--- /dev/null\n+++ b/tests/queries/0_stateless/03567_nowInBlock64.reference\n@@ -0,0 +1,2 @@\n+3\n+1\ndiff --git a/tests/queries/0_stateless/03567_nowInBlock64.sql b/tests/queries/0_stateless/03567_nowInBlock64.sql\nnew file mode 100644\nindex 000000000000..577b4fd2bc4d\n--- /dev/null\n+++ b/tests/queries/0_stateless/03567_nowInBlock64.sql\n@@ -0,0 +1,11 @@\n+SET max_rows_to_read = 0, max_bytes_to_read = 0;\n+\n+SELECT nowInBlock64(3, 'America/Sao_Paulo', 3); --{serverError TOO_MANY_ARGUMENTS_FOR_FUNCTION}\n+SELECT nowInBlock64(10); --{serverError ARGUMENT_OUT_OF_BOUND}\n+SELECT nowInBlock64('string'); --{serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT nowInBlock64(3, true); --{serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT nowInBlock64(3, 3); --{serverError ILLEGAL_TYPE_OF_ARGUMENT}\n+SELECT nowInBlock64(3, 'string'); --{serverError BAD_ARGUMENTS}\n+\n+SELECT count() FROM (SELECT DISTINCT nowInBlock64(), nowInBlock64(3), nowInBlock64(3, 'Pacific/Pitcairn') FROM system.numbers LIMIT 3);\n+SELECT nowInBlock64(NULL) IS NULL;\n",
  "problem_statement": "now64InBlock\n### Company or project name\n\n_No response_\n\n### Use case\n\nsame as nowInBlock but with subsecond resolution\n\n### Describe the solution you'd like\n\nselect now64InBlock(3)\n\n### Describe alternatives you've considered\n\nugly workaround:\n\n```\nsnowflakeIDToDateTime64(generateSnowflakeID())\n```\n\n\n### Additional context\n\n_No response_\n",
  "hints_text": "",
  "created_at": "2025-07-21T20:54:35Z"
}