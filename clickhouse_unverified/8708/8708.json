{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 8708,
  "instance_id": "ClickHouse__ClickHouse-8708",
  "issue_numbers": [
    "8702"
  ],
  "base_commit": "e2d8360a7675eeddc6fef9eb3cd81889b15f43f7",
  "patch": "diff --git a/dbms/src/Functions/bitCount.cpp b/dbms/src/Functions/bitCount.cpp\nnew file mode 100644\nindex 000000000000..1e17d52ab602\n--- /dev/null\n+++ b/dbms/src/Functions/bitCount.cpp\n@@ -0,0 +1,45 @@\n+#include <ext/bit_cast.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionUnaryArithmetic.h>\n+\n+\n+namespace DB\n+{\n+\n+template <typename A>\n+struct BitCountImpl\n+{\n+    using ResultType = UInt8;\n+\n+    static inline ResultType apply(A a)\n+    {\n+        /// We count bits in the value representation in memory. For example, we support floats.\n+        /// We need to avoid sign-extension when converting signed numbers to larger type. So, uint8_t(-1) has 8 bits.\n+\n+        return __builtin_popcountll(ext::bit_cast<unsigned long long>(a));\n+    }\n+\n+#if USE_EMBEDDED_COMPILER\n+    static constexpr bool compilable = false;\n+#endif\n+};\n+\n+struct NameBitCount { static constexpr auto name = \"bitCount\"; };\n+using FunctionBitCount = FunctionUnaryArithmetic<BitCountImpl, NameBitCount, false /* is injective */>;\n+\n+/// The function has no ranges of monotonicity.\n+template <> struct FunctionUnaryArithmeticMonotonicity<NameBitCount>\n+{\n+    static bool has() { return false; }\n+    static IFunction::Monotonicity get(const Field &, const Field &)\n+    {\n+        return {};\n+    }\n+};\n+\n+void registerFunctionBitCount(FunctionFactory & factory)\n+{\n+    factory.registerFunction<FunctionBitCount>();\n+}\n+\n+}\ndiff --git a/dbms/src/Functions/registerFunctionsArithmetic.cpp b/dbms/src/Functions/registerFunctionsArithmetic.cpp\nindex eb68fc32fa15..88350b4fac74 100644\n--- a/dbms/src/Functions/registerFunctionsArithmetic.cpp\n+++ b/dbms/src/Functions/registerFunctionsArithmetic.cpp\n@@ -20,6 +20,7 @@ void registerFunctionBitShiftLeft(FunctionFactory & factory);\n void registerFunctionBitShiftRight(FunctionFactory & factory);\n void registerFunctionBitRotateLeft(FunctionFactory & factory);\n void registerFunctionBitRotateRight(FunctionFactory & factory);\n+void registerFunctionBitCount(FunctionFactory & factory);\n void registerFunctionLeast(FunctionFactory & factory);\n void registerFunctionGreatest(FunctionFactory & factory);\n void registerFunctionBitTest(FunctionFactory & factory);\n@@ -58,6 +59,7 @@ void registerFunctionsArithmetic(FunctionFactory & factory)\n     registerFunctionBitShiftRight(factory);\n     registerFunctionBitRotateLeft(factory);\n     registerFunctionBitRotateRight(factory);\n+    registerFunctionBitCount(factory);\n     registerFunctionLeast(factory);\n     registerFunctionGreatest(factory);\n     registerFunctionBitTest(factory);\n",
  "test_patch": "diff --git a/dbms/tests/queries/0_stateless/01066_bit_count.reference b/dbms/tests/queries/0_stateless/01066_bit_count.reference\nnew file mode 100644\nindex 000000000000..4a3b084b4a26\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01066_bit_count.reference\n@@ -0,0 +1,21 @@\n+0\n+1\n+1\n+2\n+1\n+2\n+2\n+3\n+1\n+2\n+4\n+0\n+1\n+8\n+64\n+32\n+16\n+8\n+1\t10\t000000000000F03F\n+-1\t11\t000000000000F0BF\n+inf\t11\t000000000000F07F\ndiff --git a/dbms/tests/queries/0_stateless/01066_bit_count.sql b/dbms/tests/queries/0_stateless/01066_bit_count.sql\nnew file mode 100644\nindex 000000000000..d50b26575422\n--- /dev/null\n+++ b/dbms/tests/queries/0_stateless/01066_bit_count.sql\n@@ -0,0 +1,13 @@\n+SELECT bitCount(number) FROM numbers(10);\n+SELECT avg(bitCount(number)) FROM numbers(256);\n+\n+SELECT bitCount(0);\n+SELECT bitCount(1);\n+SELECT bitCount(-1);\n+\n+SELECT bitCount(toInt64(-1));\n+SELECT bitCount(toInt32(-1));\n+SELECT bitCount(toInt16(-1));\n+SELECT bitCount(toInt8(-1));\n+\n+SELECT x, bitCount(x), hex(reinterpretAsString(x)) FROM VALUES ('x Float64', (1), (-1), (inf));\n",
  "problem_statement": "Add bitCount function\n**Feature request**\r\nI request to add a new `bitCount(a)` function that should calculate the number of set bits in the supplied integer number (`UInt8`, `UInt16`, `UInt32`, `UInt64`, `Int8`, `Int16`, `Int32`, `Int64`).\r\n\r\n**Use case**\r\nIn my project there is a scenario when I need to calculate hamming distance on binary representation of a number (for perceptual hashing), which can be expressed as `bitCount(bitXor(A, B))`. `bitXor` has already been implemented, so it would be nice to implement `bitCount` as well.\r\n\r\n**Implementation**\r\n`bitCount` function can be implemented with `popcnt` machine instruction when it is available or with hand-written efficient approach stated here: https://en.wikipedia.org/wiki/Hamming_weight\r\n\n",
  "hints_text": "",
  "created_at": "2020-01-17T19:57:45Z",
  "modified_files": [
    "b/dbms/src/Functions/bitCount.cpp",
    "dbms/src/Functions/registerFunctionsArithmetic.cpp"
  ],
  "modified_test_files": [
    "b/dbms/tests/queries/0_stateless/01066_bit_count.reference",
    "b/dbms/tests/queries/0_stateless/01066_bit_count.sql"
  ]
}