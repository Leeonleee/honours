{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 7252,
  "instance_id": "ClickHouse__ClickHouse-7252",
  "issue_numbers": [
    "7245"
  ],
  "base_commit": "2a941984453aaf6816e78a9f32bab979a01169ea",
  "patch": "diff --git a/dbms/src/Interpreters/evaluateConstantExpression.cpp b/dbms/src/Interpreters/evaluateConstantExpression.cpp\nindex 07a657fb7ddd..f7843f682b72 100644\n--- a/dbms/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/dbms/src/Interpreters/evaluateConstantExpression.cpp\n@@ -60,11 +60,11 @@ std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(co\n \n ASTPtr evaluateConstantExpressionAsLiteral(const ASTPtr & node, const Context & context)\n {\n-    /// Branch with string in query.\n+    /// If it's already a literal.\n     if (node->as<ASTLiteral>())\n         return node;\n \n-    /// Branch with TableFunction in query.\n+    /// Skip table functions.\n     if (const auto * table_func_ptr = node->as<ASTFunction>())\n         if (TableFunctionFactory::instance().isTableFunctionName(table_func_ptr->name))\n             return node;\ndiff --git a/dbms/src/Interpreters/evaluateConstantExpression.h b/dbms/src/Interpreters/evaluateConstantExpression.h\nindex a901612040bc..a84104c53f43 100644\n--- a/dbms/src/Interpreters/evaluateConstantExpression.h\n+++ b/dbms/src/Interpreters/evaluateConstantExpression.h\n@@ -20,6 +20,7 @@ using ExpressionActionsPtr = std::shared_ptr<ExpressionActions>;\n \n /** Evaluate constant expression and its type.\n   * Used in rare cases - for elements of set for IN, for data to INSERT.\n+  * Throws exception if it's not a constant expression.\n   * Quite suboptimal.\n   */\n std::pair<Field, std::shared_ptr<const IDataType>> evaluateConstantExpression(const ASTPtr & node, const Context & context);\ndiff --git a/dbms/src/Storages/transformQueryForExternalDatabase.cpp b/dbms/src/Storages/transformQueryForExternalDatabase.cpp\nindex b6e48836efa3..aab240dc0707 100644\n--- a/dbms/src/Storages/transformQueryForExternalDatabase.cpp\n+++ b/dbms/src/Storages/transformQueryForExternalDatabase.cpp\n@@ -1,5 +1,6 @@\n #include <sstream>\n #include <Common/typeid_cast.h>\n+#include <Columns/ColumnConst.h>\n #include <DataTypes/DataTypesNumber.h>\n #include <Parsers/IAST.h>\n #include <Parsers/ASTFunction.h>\n@@ -8,6 +9,8 @@\n #include <Parsers/ASTSelectQuery.h>\n #include <Parsers/ASTExpressionList.h>\n #include <Interpreters/SyntaxAnalyzer.h>\n+#include <Interpreters/InDepthNodeVisitor.h>\n+#include <IO/WriteBufferFromString.h>\n #include <Storages/transformQueryForExternalDatabase.h>\n #include <Storages/MergeTree/KeyCondition.h>\n \n@@ -20,31 +23,64 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n-static void replaceConstFunction(IAST & node, const Context & context, const NamesAndTypesList & all_columns)\n+namespace\n {\n-    for (size_t i = 0; i < node.children.size(); ++i)\n+\n+class ReplacingConstantExpressionsMatcher\n+{\n+public:\n+    using Data = Block;\n+\n+    static bool needChildVisit(ASTPtr &, const ASTPtr &)\n     {\n-        auto child = node.children[i];\n-        if (auto * exp_list = child->as<ASTExpressionList>())\n-            replaceConstFunction(*exp_list, context, all_columns);\n+        return true;\n+    }\n \n-        if (auto * function = child->as<ASTFunction>())\n+    static void visit(ASTPtr & node, Block & block_with_constants)\n+    {\n+        if (!node->as<ASTFunction>())\n+            return;\n+\n+        std::string name = node->getColumnName();\n+        if (block_with_constants.has(name))\n         {\n-            NamesAndTypesList source_columns = all_columns;\n-            ASTPtr query = function->ptr();\n-            auto syntax_result = SyntaxAnalyzer(context).analyze(query, source_columns);\n-            auto result_block = KeyCondition::getBlockWithConstants(query, syntax_result, context);\n-            if (!result_block.has(child->getColumnName()))\n+            auto result = block_with_constants.getByName(name);\n+            if (!isColumnConst(*result.column))\n                 return;\n \n-            auto result_column = result_block.getByName(child->getColumnName()).column;\n+            if (result.column->isNullAt(0))\n+            {\n+                node = std::make_shared<ASTLiteral>(Field());\n+            }\n+            else if (isNumber(result.type))\n+            {\n+                node = std::make_shared<ASTLiteral>(assert_cast<const ColumnConst &>(*result.column).getField());\n+            }\n+            else\n+            {\n+                /// Everything except numbers is put as string literal. This is important for Date, DateTime, UUID.\n+\n+                const IColumn & inner_column = assert_cast<const ColumnConst &>(*result.column).getDataColumn();\n \n-            node.children[i] = std::make_shared<ASTLiteral>((*result_column)[0]);\n+                WriteBufferFromOwnString out;\n+                result.type->serializeAsText(inner_column, 0, out, FormatSettings());\n+                node = std::make_shared<ASTLiteral>(out.str());\n+            }\n         }\n     }\n+};\n+\n+void replaceConstantExpressions(ASTPtr & node, const Context & context, const NamesAndTypesList & all_columns)\n+{\n+    auto syntax_result = SyntaxAnalyzer(context).analyze(node, all_columns);\n+    Block block_with_constants = KeyCondition::getBlockWithConstants(node, syntax_result, context);\n+\n+    InDepthNodeVisitor<ReplacingConstantExpressionsMatcher, true> visitor(block_with_constants);\n+    visitor.visit(node);\n }\n \n-static bool isCompatible(const IAST & node)\n+\n+bool isCompatible(const IAST & node)\n {\n     if (const auto * function = node.as<ASTFunction>())\n     {\n@@ -99,6 +135,8 @@ static bool isCompatible(const IAST & node)\n     return false;\n }\n \n+}\n+\n \n String transformQueryForExternalDatabase(\n     const IAST & query,\n@@ -131,7 +169,8 @@ String transformQueryForExternalDatabase(\n     ASTPtr original_where = clone_query->as<ASTSelectQuery &>().where();\n     if (original_where)\n     {\n-        replaceConstFunction(*original_where, context, available_columns);\n+        replaceConstantExpressions(original_where, context, available_columns);\n+\n         if (isCompatible(*original_where))\n         {\n             select->setExpression(ASTSelectQuery::Expression::WHERE, std::move(original_where));\n",
  "test_patch": "diff --git a/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp b/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp\nindex 34f6ce64278d..797cb677d6a1 100644\n--- a/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n+++ b/dbms/src/Storages/tests/gtest_transform_query_for_external_database.cpp\n@@ -4,6 +4,7 @@\n #include <Parsers/ParserSelectQuery.h>\n #include <Parsers/parseQuery.h>\n #include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypeDateTime.h>\n #include <Interpreters/Context.h>\n #include <Databases/DatabaseMemory.h>\n #include <Storages/StorageMemory.h>\n@@ -17,7 +18,13 @@ using namespace DB;\n struct State\n {\n     Context context{Context::createGlobal()};\n-    NamesAndTypesList columns{{\"column\", std::make_shared<DataTypeUInt8>()}};\n+    NamesAndTypesList columns{\n+        {\"column\", std::make_shared<DataTypeUInt8>()},\n+        {\"apply_id\", std::make_shared<DataTypeUInt64>()},\n+        {\"apply_type\", std::make_shared<DataTypeUInt8>()},\n+        {\"apply_status\", std::make_shared<DataTypeUInt8>()},\n+        {\"create_time\", std::make_shared<DataTypeDateTime>()},\n+    };\n \n     State()\n     {\n@@ -85,5 +92,11 @@ TEST(TransformQueryForExternalDatabase, MultipleAndSubqueries)\n     check(\"SELECT column FROM test.table WHERE toString(column) = '42' AND left(column, 10) = RIGHT(column, 10) AND column = 42\",\n           \"SELECT \\\"column\\\" FROM \\\"test\\\".\\\"table\\\" WHERE (\\\"column\\\" = 42)\",\n           state().context, state().columns);\n+}\n \n+TEST(TransformQueryForExternalDatabase, Issue7245)\n+{\n+    check(\"select apply_id from test.table where apply_type = 2 and create_time > addDays(toDateTime('2019-01-01 01:02:03'),-7) and apply_status in (3,4)\",\n+          \"SELECT \\\"apply_id\\\", \\\"apply_type\\\", \\\"apply_status\\\", \\\"create_time\\\" FROM \\\"test\\\".\\\"table\\\" WHERE (\\\"apply_type\\\" = 2) AND (\\\"create_time\\\" > '2018-12-25 01:02:03') AND (\\\"apply_status\\\" IN (3, 4))\",\n+          state().context, state().columns);\n }\n",
  "problem_statement": "sql error 1241 operand should contain 1 column\n**Describe the bug:**\r\nQuery error, error info is sql error 1241 operand should contain 1 column\r\nVersion : 19.13.3.26\r\n\r\n```\r\ncreate table xjy_mysql_inventory_apply\r\n(\r\n    apply_id      Int64,\r\n    campus_id     Int32,\r\n    apply_user_id Int32,\r\n    apply_type    Int8,\r\n    apply_status  Int8,\r\n    create_time   DateTime\r\n)\r\n    engine = MySQL();\r\n```\r\n\r\n\r\nerror sql :\r\n```SQL\r\nselect apply_id\r\n                 from xjy_mysql_inventory_apply\r\n                 where apply_type = 2\r\n                   and create_time > addDays(now(),-7)\r\n                   and apply_status in (3,4)\r\n```\r\n\r\nbut i changed  addDays(now(),-7) to '2019-09-01 00:00:00', it works fine.\r\n\r\n```SQL\r\nselect apply_id\r\n                 from xjy_mysql_inventory_apply\r\n                 where apply_type = 2\r\n                   and create_time > '2019-09-01 00:00:00'\r\n                   and apply_status in (3,4)\r\n```\r\n\r\n**Expected behavior**\r\nBoth SQL should run OK\n",
  "hints_text": "",
  "created_at": "2019-10-09T20:18:26Z"
}