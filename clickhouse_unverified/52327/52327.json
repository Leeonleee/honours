{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 52327,
  "instance_id": "ClickHouse__ClickHouse-52327",
  "issue_numbers": [
    "50183",
    "50093"
  ],
  "base_commit": "234b5047b5cd093b8950bb8de3725eacffe02dc0",
  "patch": "diff --git a/src/Interpreters/Context.cpp b/src/Interpreters/Context.cpp\nindex 9e4d1e8d1e20..cc1277e08b90 100644\n--- a/src/Interpreters/Context.cpp\n+++ b/src/Interpreters/Context.cpp\n@@ -1461,15 +1461,24 @@ void Context::addQueryAccessInfo(\n void Context::addQueryAccessInfo(const Names & partition_names)\n {\n     if (isGlobalContext())\n-    {\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"Global context cannot have query access info\");\n-    }\n \n     std::lock_guard<std::mutex> lock(query_access_info.mutex);\n     for (const auto & partition_name : partition_names)\n-    {\n         query_access_info.partitions.emplace(partition_name);\n-    }\n+}\n+\n+void Context::addQueryAccessInfo(const QualifiedProjectionName & qualified_projection_name)\n+{\n+    if (!qualified_projection_name)\n+        return;\n+\n+    if (isGlobalContext())\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Global context cannot have query access info\");\n+\n+    std::lock_guard<std::mutex> lock(query_access_info.mutex);\n+    query_access_info.projections.emplace(fmt::format(\n+        \"{}.{}\", qualified_projection_name.storage_id.getFullTableName(), backQuoteIfNeed(qualified_projection_name.projection_name)));\n }\n \n void Context::addQueryFactoriesInfo(QueryLogFactories factory_type, const String & created_object) const\ndiff --git a/src/Interpreters/Context.h b/src/Interpreters/Context.h\nindex 3a8d41bf1300..fa210f044512 100644\n--- a/src/Interpreters/Context.h\n+++ b/src/Interpreters/Context.h\n@@ -658,6 +658,14 @@ class Context: public std::enable_shared_from_this<Context>\n         const String & view_name = {});\n     void addQueryAccessInfo(const Names & partition_names);\n \n+    struct QualifiedProjectionName\n+    {\n+        StorageID storage_id = StorageID::createEmpty();\n+        String projection_name;\n+        explicit operator bool() const { return !projection_name.empty(); }\n+    };\n+    void addQueryAccessInfo(const QualifiedProjectionName & qualified_projection_name);\n+\n \n     /// Supported factories for records in query_log\n     enum class QueryLogFactories\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\nindex f183bdca7a9f..53f47bcdf951 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n@@ -625,8 +625,16 @@ bool optimizeUseAggregateProjections(QueryPlan::Node & node, QueryPlan::Nodes &\n         //           candidates.minmax_projection->block.dumpStructure());\n \n         Pipe pipe(std::make_shared<SourceFromSingleChunk>(std::move(candidates.minmax_projection->block)));\n-        projection_reading = std::make_unique<ReadFromPreparedSource>(std::move(pipe));\n-\n+        projection_reading = std::make_unique<ReadFromPreparedSource>(\n+            std::move(pipe),\n+            context,\n+            query_info.is_internal\n+                ? Context::QualifiedProjectionName{}\n+                : Context::QualifiedProjectionName\n+                  {\n+                      .storage_id = reading->getMergeTreeData().getStorageID(),\n+                      .projection_name = candidates.minmax_projection->candidate.projection->name,\n+                  });\n         has_ordinary_parts = !candidates.minmax_projection->normal_parts.empty();\n         if (has_ordinary_parts)\n             reading->resetParts(std::move(candidates.minmax_projection->normal_parts));\n@@ -658,7 +666,16 @@ bool optimizeUseAggregateProjections(QueryPlan::Node & node, QueryPlan::Nodes &\n         {\n             auto header = proj_snapshot->getSampleBlockForColumns(best_candidate->dag->getRequiredColumnsNames());\n             Pipe pipe(std::make_shared<NullSource>(std::move(header)));\n-            projection_reading = std::make_unique<ReadFromPreparedSource>(std::move(pipe));\n+            projection_reading = std::make_unique<ReadFromPreparedSource>(\n+                std::move(pipe),\n+                context,\n+                query_info.is_internal\n+                    ? Context::QualifiedProjectionName{}\n+                    : Context::QualifiedProjectionName\n+                      {\n+                          .storage_id = reading->getMergeTreeData().getStorageID(),\n+                          .projection_name = best_candidate->projection->name,\n+                      });\n         }\n \n         has_ordinary_parts = best_candidate->merge_tree_ordinary_select_result_ptr != nullptr;\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\nindex dd7a5d449bcc..f6ace6f8025e 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseNormalProjection.cpp\n@@ -183,7 +183,16 @@ bool optimizeUseNormalProjections(Stack & stack, QueryPlan::Nodes & nodes)\n     if (!projection_reading)\n     {\n         Pipe pipe(std::make_shared<NullSource>(proj_snapshot->getSampleBlockForColumns(required_columns)));\n-        projection_reading = std::make_unique<ReadFromPreparedSource>(std::move(pipe));\n+        projection_reading = std::make_unique<ReadFromPreparedSource>(\n+            std::move(pipe),\n+            context,\n+            query_info.is_internal\n+                ? Context::QualifiedProjectionName{}\n+                : Context::QualifiedProjectionName\n+                  {\n+                      .storage_id = reading->getMergeTreeData().getStorageID(),\n+                      .projection_name = best_candidate->projection->name,\n+                  });\n     }\n \n     bool has_ordinary_parts = best_candidate->merge_tree_ordinary_select_result_ptr != nullptr;\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex 13de5d1d1402..2d2412f7e36f 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1761,6 +1761,10 @@ void ReadFromMergeTree::initializePipeline(QueryPipelineBuilder & pipeline, cons\n                 fmt::format(\"{}.{}\", data.getStorageID().getFullNameNotQuoted(), part.data_part->info.partition_id));\n         }\n         context->getQueryContext()->addQueryAccessInfo(partition_names);\n+\n+        if (storage_snapshot->projection)\n+            context->getQueryContext()->addQueryAccessInfo(\n+                Context::QualifiedProjectionName{.storage_id = data.getStorageID(), .projection_name = storage_snapshot->projection->name});\n     }\n \n     ProfileEvents::increment(ProfileEvents::SelectedParts, result.selected_parts);\ndiff --git a/src/Processors/QueryPlan/ReadFromPreparedSource.cpp b/src/Processors/QueryPlan/ReadFromPreparedSource.cpp\nindex 7446203ec358..a24c4dbe4d08 100644\n--- a/src/Processors/QueryPlan/ReadFromPreparedSource.cpp\n+++ b/src/Processors/QueryPlan/ReadFromPreparedSource.cpp\n@@ -4,14 +4,19 @@\n namespace DB\n {\n \n-ReadFromPreparedSource::ReadFromPreparedSource(Pipe pipe_)\n+ReadFromPreparedSource::ReadFromPreparedSource(Pipe pipe_, ContextPtr context_, Context::QualifiedProjectionName qualified_projection_name_)\n     : ISourceStep(DataStream{.header = pipe_.getHeader()})\n     , pipe(std::move(pipe_))\n+    , context(std::move(context_))\n+    , qualified_projection_name(std::move(qualified_projection_name_))\n {\n }\n \n void ReadFromPreparedSource::initializePipeline(QueryPipelineBuilder & pipeline, const BuildQueryPipelineSettings &)\n {\n+    if (context && context->hasQueryContext())\n+        context->getQueryContext()->addQueryAccessInfo(qualified_projection_name);\n+\n     for (const auto & processor : pipe.getProcessors())\n         processors.emplace_back(processor);\n \ndiff --git a/src/Processors/QueryPlan/ReadFromPreparedSource.h b/src/Processors/QueryPlan/ReadFromPreparedSource.h\nindex 05e3ebd51027..2606f5010099 100644\n--- a/src/Processors/QueryPlan/ReadFromPreparedSource.h\n+++ b/src/Processors/QueryPlan/ReadFromPreparedSource.h\n@@ -1,4 +1,6 @@\n #pragma once\n+\n+#include <Interpreters/Context.h>\n #include <Processors/QueryPlan/ISourceStep.h>\n #include <QueryPipeline/Pipe.h>\n \n@@ -9,7 +11,8 @@ namespace DB\n class ReadFromPreparedSource : public ISourceStep\n {\n public:\n-    explicit ReadFromPreparedSource(Pipe pipe_);\n+    explicit ReadFromPreparedSource(\n+        Pipe pipe_, ContextPtr context_ = nullptr, Context::QualifiedProjectionName qualified_projection_name_ = {});\n \n     String getName() const override { return \"ReadFromPreparedSource\"; }\n \n@@ -18,6 +21,7 @@ class ReadFromPreparedSource : public ISourceStep\n protected:\n     Pipe pipe;\n     ContextPtr context;\n+    Context::QualifiedProjectionName qualified_projection_name;\n };\n \n class ReadFromStorageStep : public ReadFromPreparedSource\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01710_query_log_with_projection_info.reference b/tests/queries/0_stateless/01710_query_log_with_projection_info.reference\nnew file mode 100644\nindex 000000000000..9c2e9df6662b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01710_query_log_with_projection_info.reference\n@@ -0,0 +1,3 @@\n+t.t_normal\n+t.t_agg\n+t._minmax_count_projection\ndiff --git a/tests/queries/0_stateless/01710_query_log_with_projection_info.sql b/tests/queries/0_stateless/01710_query_log_with_projection_info.sql\nnew file mode 100644\nindex 000000000000..cd84b392fe58\n--- /dev/null\n+++ b/tests/queries/0_stateless/01710_query_log_with_projection_info.sql\n@@ -0,0 +1,66 @@\n+set log_queries=1;\n+set log_queries_min_type='QUERY_FINISH';\n+set optimize_use_implicit_projections=1;\n+\n+DROP TABLE IF EXISTS t;\n+\n+CREATE TABLE t\n+(\n+    `id` UInt64,\n+    `id2` UInt64,\n+    `id3` UInt64,\n+    PROJECTION t_normal\n+    (\n+        SELECT\n+            id,\n+            id2,\n+            id3\n+        ORDER BY\n+            id2,\n+            id,\n+            id3\n+    ),\n+    PROJECTION t_agg\n+    (\n+        SELECT\n+            sum(id3)\n+        GROUP BY id2\n+    )\n+)\n+ENGINE = MergeTree\n+ORDER BY id\n+SETTINGS index_granularity = 8;\n+\n+insert into t SELECT number, -number, number FROM numbers(10000);\n+\n+SELECT * FROM t WHERE id2 = 3 FORMAT Null;\n+SELECT sum(id3) FROM t GROUP BY id2 FORMAT Null;\n+SELECT min(id) FROM t FORMAT Null;\n+\n+SYSTEM FLUSH LOGS;\n+\n+SELECT\n+    --Remove the prefix string which is a mutable database name.\n+    arrayStringConcat(arrayPopFront(splitByString('.', projections[1])), '.')\n+FROM\n+    system.query_log\n+WHERE\n+    current_database=currentDatabase() and query = 'SELECT * FROM t WHERE id2 = 3 FORMAT Null;';\n+\n+SELECT\n+    --Remove the prefix string which is a mutable database name.\n+    arrayStringConcat(arrayPopFront(splitByString('.', projections[1])), '.')\n+FROM\n+    system.query_log\n+WHERE\n+    current_database=currentDatabase() and query = 'SELECT sum(id3) FROM t GROUP BY id2 FORMAT Null;';\n+\n+SELECT\n+    --Remove the prefix string which is a mutable database name.\n+    arrayStringConcat(arrayPopFront(splitByString('.', projections[1])), '.')\n+FROM\n+    system.query_log\n+WHERE\n+    current_database=currentDatabase() and query = 'SELECT min(id) FROM t FORMAT Null;';\n+\n+DROP TABLE t;\n",
  "problem_statement": "Missing projection QueryAccessInfo when query_plan_optimize_projection = true\n**Describe the unexpected behaviour**\r\nWhen `query_plan_optimize_projection = true`, there is no projection information in query_log.\r\n\r\nThis is because we don't store used projection in `query_info` anymore. We need to find a place to store the name of used projection inside query plan.\r\n\r\nP.S.  we should also add the info here https://github.com/ClickHouse/ClickHouse/blob/master/src/Planner/PlannerJoinTree.cpp#L733\r\n\nExample of projection from documentations is not work\nClickHouse v.23.3.2.37\r\n\r\nTrying to work with projections example from ClickHouse documentation, but its not work.\r\nLink to example from doc:\r\nhttps://clickhouse.com/docs/en/sql-reference/statements/alter/projection#example-filtering-without-using-primary-keys\r\n\r\ncode:\r\n```\r\nCREATE TABLE visits_order\r\n(\r\n   `user_id` UInt64,\r\n   `user_name` String,\r\n   `pages_visited` Nullable(Float64),\r\n   `user_agent` String\r\n)\r\nENGINE = MergeTree()\r\nPRIMARY KEY user_agent;\r\n\r\nALTER TABLE visits_order ADD PROJECTION user_name_projection (SELECT * ORDER BY user_name)\r\n\r\nALTER TABLE visits_order MATERIALIZE PROJECTION user_name_projection;\r\n\r\nINSERT INTO visits_order SELECT\r\n    number,\r\n    'test',\r\n    1.5 * (number / 2),\r\n    'Android'\r\nFROM numbers(1, 100);\r\n\r\n\r\nSELECT\r\n    *\r\nFROM visits_order\r\nWHERE user_name='test'\r\nLIMIT 2;\r\n\r\nSELECT query, projections FROM system.query_log WHERE query_id='<query_id>'\r\n```\r\n\r\n\r\nSo, when i try to check projections  column from query_log, i see nothing ([])\r\nWhat i do wrong?\n",
  "hints_text": "\ncc: @amosbird \nhttps://fiddle.clickhouse.com/4b0ce12f-9353-4c39-9e4a-d72070f1f75a\r\n\r\nInteresting that \r\n`WHERE user_name='test'` does not use the projection, it looks like CBO\r\n`WHERE user_name='1test'` uses the projection but `system.query_log` is empty anyway\n> WHERE user_name='test' does not use the projection, it looks like CBO\r\n\r\nYes, it's because all `user_name` equal to `test` and projection won't help.\r\n\r\n> WHERE user_name='1test' uses the projection but system.query_log is empty anyway\r\n\r\nIt's an issue when `query_plan_optimize_projection = 1`. It's also an issue when selected projection doesn't return any data. Will  fix it this week.",
  "created_at": "2023-07-19T13:29:57Z"
}