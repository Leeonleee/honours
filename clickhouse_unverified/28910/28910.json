{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 28910,
  "instance_id": "ClickHouse__ClickHouse-28910",
  "issue_numbers": [
    "28908",
    "26049"
  ],
  "base_commit": "a4153e562933d4940421e99a6c0e382d6950c44f",
  "patch": "diff --git a/src/Interpreters/DuplicateOrderByVisitor.cpp b/src/Interpreters/DuplicateOrderByVisitor.cpp\nnew file mode 100644\nindex 000000000000..df063fc849e4\n--- /dev/null\n+++ b/src/Interpreters/DuplicateOrderByVisitor.cpp\n@@ -0,0 +1,124 @@\n+#include <Interpreters/DuplicateOrderByVisitor.h>\n+#include <Functions/FunctionFactory.h>\n+#include <AggregateFunctions/AggregateFunctionFactory.h>\n+#include <IO/WriteHelpers.h>\n+#include <Parsers/ASTFunction.h>\n+#include <Parsers/ASTLiteral.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Parsers/ASTTablesInSelectQuery.h>\n+#include <Parsers/ASTOrderByElement.h>\n+#include <Common/typeid_cast.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNKNOWN_TYPE_OF_AST_NODE;\n+}\n+\n+\n+namespace\n+{\n+\n+/// Checks if SELECT has stateful functions\n+class ASTFunctionStatefulData\n+{\n+public:\n+    using TypeToVisit = ASTFunction;\n+\n+    ContextPtr context;\n+    bool & is_stateful;\n+    void visit(ASTFunction & ast_function, ASTPtr &)\n+    {\n+        auto aggregate_function_properties = AggregateFunctionFactory::instance().tryGetProperties(ast_function.name);\n+\n+        if (aggregate_function_properties && aggregate_function_properties->is_order_dependent)\n+        {\n+            is_stateful = true;\n+            return;\n+        }\n+\n+        const auto & function = FunctionFactory::instance().tryGet(ast_function.name, context);\n+\n+        if (function && function->isStateful())\n+        {\n+            is_stateful = true;\n+            return;\n+        }\n+    }\n+};\n+\n+using ASTFunctionStatefulMatcher = OneTypeMatcher<ASTFunctionStatefulData>;\n+using ASTFunctionStatefulVisitor = InDepthNodeVisitor<ASTFunctionStatefulMatcher, true>;\n+\n+}\n+\n+\n+void DuplicateOrderByFromSubqueriesData::visit(ASTSelectQuery & select_query, ASTPtr &)\n+{\n+    if (done)\n+        return;\n+    done = true;\n+\n+    if (select_query.orderBy())\n+    {\n+        /// If we have limits then the ORDER BY is non-removable.\n+        if (select_query.limitBy()\n+            || select_query.limitByOffset()\n+            || select_query.limitByLength()\n+            || select_query.limitLength()\n+            || select_query.limitOffset())\n+        {\n+            return;\n+        }\n+\n+        /// If ORDER BY contains filling (in addition to sorting) it is non-removable.\n+        for (const auto & child : select_query.orderBy()->children)\n+        {\n+            auto * ast = child->as<ASTOrderByElement>();\n+            if (!ast || ast->children.empty())\n+                throw Exception(\"Bad ORDER BY expression AST\", ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE);\n+\n+            if (ast->with_fill)\n+                return;\n+        }\n+\n+        select_query.setExpression(ASTSelectQuery::Expression::ORDER_BY, nullptr);\n+    }\n+}\n+\n+void DuplicateOrderByData::visit(ASTSelectQuery & select_query, ASTPtr &)\n+{\n+    if (select_query.orderBy() || select_query.groupBy())\n+    {\n+        for (auto & elem : select_query.children)\n+        {\n+            if (elem->as<ASTExpressionList>())\n+            {\n+                bool is_stateful = false;\n+                ASTFunctionStatefulVisitor::Data data{context, is_stateful};\n+                ASTFunctionStatefulVisitor(data).visit(elem);\n+                if (is_stateful) //-V547\n+                    return;\n+            }\n+        }\n+\n+        if (auto select_table_ptr = select_query.tables())\n+        {\n+            if (auto * select_table = select_table_ptr->as<ASTTablesInSelectQuery>())\n+            {\n+                if (!select_table->children.empty())\n+                {\n+                    DuplicateOrderByFromSubqueriesVisitor::Data data{false};\n+                    DuplicateOrderByFromSubqueriesVisitor(data).visit(select_table->children[0]);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+}\n+\ndiff --git a/src/Interpreters/DuplicateOrderByVisitor.h b/src/Interpreters/DuplicateOrderByVisitor.h\nindex 4231b2600af0..de8cb4c8f32a 100644\n--- a/src/Interpreters/DuplicateOrderByVisitor.h\n+++ b/src/Interpreters/DuplicateOrderByVisitor.h\n@@ -1,51 +1,13 @@\n #pragma once\n \n-#include <Functions/FunctionFactory.h>\n-#include <AggregateFunctions/AggregateFunctionFactory.h>\n-#include <IO/WriteHelpers.h>\n #include <Interpreters/InDepthNodeVisitor.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ASTSetQuery.h>\n-#include <Parsers/ASTTablesInSelectQuery.h>\n #include <Parsers/IAST.h>\n-#include <Common/typeid_cast.h>\n \n-namespace DB\n-{\n \n-/// Checks if SELECT has stateful functions\n-class ASTFunctionStatefulData\n+namespace DB\n {\n-public:\n-    using TypeToVisit = ASTFunction;\n-\n-    ContextPtr context;\n-    bool & is_stateful;\n-    void visit(ASTFunction & ast_function, ASTPtr &)\n-    {\n-        auto aggregate_function_properties = AggregateFunctionFactory::instance().tryGetProperties(ast_function.name);\n-\n-        if (aggregate_function_properties && aggregate_function_properties->is_order_dependent)\n-        {\n-            is_stateful = true;\n-            return;\n-        }\n-\n-        const auto & function = FunctionFactory::instance().tryGet(ast_function.name, context);\n-\n-        if (function && function->isStateful())\n-        {\n-            is_stateful = true;\n-            return;\n-        }\n-    }\n-};\n-\n-using ASTFunctionStatefulMatcher = OneTypeMatcher<ASTFunctionStatefulData>;\n-using ASTFunctionStatefulVisitor = InDepthNodeVisitor<ASTFunctionStatefulMatcher, true>;\n \n+class ASTSelectQuery;\n \n /// Erases unnecessary ORDER BY from subquery\n class DuplicateOrderByFromSubqueriesData\n@@ -55,19 +17,7 @@ class DuplicateOrderByFromSubqueriesData\n \n     bool done = false;\n \n-    void visit(ASTSelectQuery & select_query, ASTPtr &)\n-    {\n-        if (done)\n-            return;\n-\n-        if (select_query.orderBy() && !select_query.limitBy() && !select_query.limitByOffset() &&\n-            !select_query.limitByLength() && !select_query.limitLength() && !select_query.limitOffset())\n-        {\n-            select_query.setExpression(ASTSelectQuery::Expression::ORDER_BY, nullptr);\n-        }\n-\n-        done = true;\n-    }\n+    void visit(ASTSelectQuery & select_query, ASTPtr &);\n };\n \n using DuplicateOrderByFromSubqueriesMatcher = OneTypeMatcher<DuplicateOrderByFromSubqueriesData>;\n@@ -82,35 +32,7 @@ class DuplicateOrderByData\n \n     ContextPtr context;\n \n-    void visit(ASTSelectQuery & select_query, ASTPtr &)\n-    {\n-        if (select_query.orderBy() || select_query.groupBy())\n-        {\n-            for (auto & elem : select_query.children)\n-            {\n-                if (elem->as<ASTExpressionList>())\n-                {\n-                    bool is_stateful = false;\n-                    ASTFunctionStatefulVisitor::Data data{context, is_stateful};\n-                    ASTFunctionStatefulVisitor(data).visit(elem);\n-                    if (is_stateful) //-V547\n-                        return;\n-                }\n-            }\n-\n-            if (auto select_table_ptr = select_query.tables())\n-            {\n-                if (auto * select_table = select_table_ptr->as<ASTTablesInSelectQuery>())\n-                {\n-                    if (!select_table->children.empty())\n-                    {\n-                        DuplicateOrderByFromSubqueriesVisitor::Data data{false};\n-                        DuplicateOrderByFromSubqueriesVisitor(data).visit(select_table->children[0]);\n-                    }\n-                }\n-            }\n-        }\n-    }\n+    void visit(ASTSelectQuery & select_query, ASTPtr &);\n };\n \n using DuplicateOrderByMatcher = OneTypeMatcher<DuplicateOrderByData>;\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex d5739b51659d..5119c4090f82 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -1240,7 +1240,7 @@ ActionsDAGPtr SelectQueryExpressionAnalyzer::appendOrderBy(ExpressionActionsChai\n     {\n         auto * ast = child->as<ASTOrderByElement>();\n         if (!ast || ast->children.empty())\n-            throw Exception(\"Bad order expression AST\", ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE);\n+            throw Exception(\"Bad ORDER BY expression AST\", ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE);\n \n         if (getContext()->getSettingsRef().enable_positional_arguments)\n         {\ndiff --git a/src/Interpreters/FillingRow.h b/src/Interpreters/FillingRow.h\nindex 434a92707181..604f4b1ee741 100644\n--- a/src/Interpreters/FillingRow.h\n+++ b/src/Interpreters/FillingRow.h\n@@ -24,14 +24,14 @@ class FillingRow\n \n     void initFromDefaults(size_t from_pos = 0);\n \n-    Field & operator[](size_t ind) { return row[ind]; }\n-    const Field & operator[](size_t ind) const { return row[ind]; }\n+    Field & operator[](size_t index) { return row[index]; }\n+    const Field & operator[](size_t index) const { return row[index]; }\n     size_t size() const { return row.size(); }\n     bool operator<(const FillingRow & other) const;\n     bool operator==(const FillingRow & other) const;\n \n-    int getDirection(size_t ind) const { return description[ind].direction; }\n-    FillColumnDescription & getFillDescription(size_t ind) { return description[ind].fill_description; }\n+    int getDirection(size_t index) const { return description[index].direction; }\n+    FillColumnDescription & getFillDescription(size_t index) { return description[index].fill_description; }\n \n private:\n     Row row;\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 518c041d7858..833d76a26b8e 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -39,6 +39,7 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int LOGICAL_ERROR;\n+    extern const int UNKNOWN_TYPE_OF_AST_NODE;\n }\n \n namespace\n@@ -282,7 +283,8 @@ void optimizeDuplicatesInOrderBy(const ASTSelectQuery * select_query)\n         String name = elem->children.front()->getColumnName();\n         const auto & order_by_elem = elem->as<ASTOrderByElement &>();\n \n-        if (elems_set.emplace(name, order_by_elem.collation ? order_by_elem.collation->getColumnName() : \"\").second)\n+        if (order_by_elem.with_fill /// Always keep elements WITH FILL as they affects other.\n+            || elems_set.emplace(name, order_by_elem.collation ? order_by_elem.collation->getColumnName() : \"\").second)\n             unique_elems.emplace_back(elem);\n     }\n \n@@ -425,6 +427,17 @@ void optimizeMonotonousFunctionsInOrderBy(ASTSelectQuery * select_query, Context\n     if (!order_by)\n         return;\n \n+    for (const auto & child : order_by->children)\n+    {\n+        auto * order_by_element = child->as<ASTOrderByElement>();\n+\n+        if (!order_by_element || order_by_element->children.empty())\n+            throw Exception(\"Bad ORDER BY expression AST\", ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE);\n+\n+        if (order_by_element->with_fill)\n+            return;\n+    }\n+\n     std::unordered_set<String> group_by_hashes;\n     if (auto group_by = select_query->groupBy())\n     {\n@@ -440,6 +453,7 @@ void optimizeMonotonousFunctionsInOrderBy(ASTSelectQuery * select_query, Context\n     for (size_t i = 0; i < order_by->children.size(); ++i)\n     {\n         auto * order_by_element = order_by->children[i]->as<ASTOrderByElement>();\n+\n         auto & ast_func = order_by_element->children[0];\n         if (!ast_func->as<ASTFunction>())\n             continue;\n@@ -475,6 +489,17 @@ void optimizeRedundantFunctionsInOrderBy(const ASTSelectQuery * select_query, Co\n     if (!order_by)\n         return;\n \n+    for (const auto & child : order_by->children)\n+    {\n+        auto * order_by_element = child->as<ASTOrderByElement>();\n+\n+        if (!order_by_element || order_by_element->children.empty())\n+            throw Exception(\"Bad ORDER BY expression AST\", ErrorCodes::UNKNOWN_TYPE_OF_AST_NODE);\n+\n+        if (order_by_element->with_fill)\n+            return;\n+    }\n+\n     std::unordered_set<String> prev_keys;\n     ASTs modified;\n     modified.reserve(order_by->children.size());\ndiff --git a/src/Processors/Transforms/FillingTransform.cpp b/src/Processors/Transforms/FillingTransform.cpp\nindex 831130d06d18..3ff89c302ff8 100644\n--- a/src/Processors/Transforms/FillingTransform.cpp\n+++ b/src/Processors/Transforms/FillingTransform.cpp\n@@ -81,7 +81,7 @@ FillingTransform::FillingTransform(\n     };\n \n     std::vector<bool> is_fill_column(header_.columns());\n-    for (size_t i = 0; i < sort_description.size(); ++i)\n+    for (size_t i = 0, size = sort_description.size(); i < size; ++i)\n     {\n         size_t block_position = header_.getPositionByName(sort_description[i].column_name);\n         is_fill_column[block_position] = true;\n@@ -103,6 +103,11 @@ FillingTransform::FillingTransform(\n         }\n     }\n \n+    std::set<size_t> unique_positions;\n+    for (auto pos : fill_column_positions)\n+        if (!unique_positions.insert(pos).second)\n+            throw Exception(\"Multiple WITH FILL for identical expressions is not supported in ORDER BY\", ErrorCodes::INVALID_WITH_FILL_EXPRESSION);\n+\n     for (size_t i = 0; i < header_.columns(); ++i)\n         if (!is_fill_column[i])\n             other_column_positions.push_back(i);\n@@ -114,7 +119,7 @@ IProcessor::Status FillingTransform::prepare()\n     {\n         should_insert_first = next_row < filling_row;\n \n-        for (size_t i = 0; i < filling_row.size(); ++i)\n+        for (size_t i = 0, size = filling_row.size(); i < size; ++i)\n             next_row[i] = filling_row.getFillDescription(i).fill_to;\n \n         if (filling_row < next_row)\n@@ -227,9 +232,9 @@ void FillingTransform::setResultColumns(Chunk & chunk, MutableColumns & fill_col\n     /// fill_columns always non-empty.\n     size_t num_rows = fill_columns[0]->size();\n \n-    for (size_t i = 0; i < fill_columns.size(); ++i)\n+    for (size_t i = 0, size = fill_columns.size(); i < size; ++i)\n         result_columns[fill_column_positions[i]] = std::move(fill_columns[i]);\n-    for (size_t i = 0; i < other_columns.size(); ++i)\n+    for (size_t i = 0, size = other_columns.size(); i < size; ++i)\n         result_columns[other_column_positions[i]] = std::move(other_columns[i]);\n \n     chunk.setColumns(std::move(result_columns), num_rows);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/2015_order_by_with_fill_misoptimization.reference b/tests/queries/0_stateless/2015_order_by_with_fill_misoptimization.reference\nnew file mode 100644\nindex 000000000000..07258cd829ac\n--- /dev/null\n+++ b/tests/queries/0_stateless/2015_order_by_with_fill_misoptimization.reference\n@@ -0,0 +1,9 @@\n+\n+\n+\n+\n+\n+\n+\n+\n+Hello\ndiff --git a/tests/queries/0_stateless/2015_order_by_with_fill_misoptimization.sql b/tests/queries/0_stateless/2015_order_by_with_fill_misoptimization.sql\nnew file mode 100644\nindex 000000000000..f0d90f151b2c\n--- /dev/null\n+++ b/tests/queries/0_stateless/2015_order_by_with_fill_misoptimization.sql\n@@ -0,0 +1,1 @@\n+SELECT s FROM (SELECT 5 AS x, 'Hello' AS s ORDER BY x WITH FILL FROM 1 TO 10) ORDER BY s;\ndiff --git a/tests/queries/0_stateless/2016_order_by_with_fill_monotonic_functions_removal.reference b/tests/queries/0_stateless/2016_order_by_with_fill_monotonic_functions_removal.reference\nnew file mode 100644\nindex 000000000000..264f29a6ecd1\n--- /dev/null\n+++ b/tests/queries/0_stateless/2016_order_by_with_fill_monotonic_functions_removal.reference\n@@ -0,0 +1,3 @@\n+2021-07-07 15:21:00\n+2021-07-07 15:21:05\n+2021-07-07 15:21:10\ndiff --git a/tests/queries/0_stateless/2016_order_by_with_fill_monotonic_functions_removal.sql b/tests/queries/0_stateless/2016_order_by_with_fill_monotonic_functions_removal.sql\nnew file mode 100644\nindex 000000000000..bf232ed5c864\n--- /dev/null\n+++ b/tests/queries/0_stateless/2016_order_by_with_fill_monotonic_functions_removal.sql\n@@ -0,0 +1,6 @@\n+SELECT toStartOfMinute(some_time) AS ts\n+FROM\n+(\n+    SELECT toDateTime('2021-07-07 15:21:05') AS some_time\n+)\n+ORDER BY ts ASC WITH FILL FROM toDateTime('2021-07-07 15:21:00') TO toDateTime('2021-07-07 15:21:15') STEP 5;\ndiff --git a/tests/queries/0_stateless/2017_order_by_with_fill_redundant_functions.reference b/tests/queries/0_stateless/2017_order_by_with_fill_redundant_functions.reference\nnew file mode 100644\nindex 000000000000..07193989308c\n--- /dev/null\n+++ b/tests/queries/0_stateless/2017_order_by_with_fill_redundant_functions.reference\n@@ -0,0 +1,9 @@\n+1\n+2\n+3\n+4\n+5\n+6\n+7\n+8\n+9\ndiff --git a/tests/queries/0_stateless/2017_order_by_with_fill_redundant_functions.sql b/tests/queries/0_stateless/2017_order_by_with_fill_redundant_functions.sql\nnew file mode 100644\nindex 000000000000..6f3e6787c344\n--- /dev/null\n+++ b/tests/queries/0_stateless/2017_order_by_with_fill_redundant_functions.sql\n@@ -0,0 +1,1 @@\n+SELECT x FROM (SELECT 5 AS x) ORDER BY -x, x WITH FILL FROM 1 TO 10;\ndiff --git a/tests/queries/0_stateless/2018_multiple_with_fill_for_the_same_column.reference b/tests/queries/0_stateless/2018_multiple_with_fill_for_the_same_column.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/2018_multiple_with_fill_for_the_same_column.sql b/tests/queries/0_stateless/2018_multiple_with_fill_for_the_same_column.sql\nnew file mode 100644\nindex 000000000000..32b38388cf6d\n--- /dev/null\n+++ b/tests/queries/0_stateless/2018_multiple_with_fill_for_the_same_column.sql\n@@ -0,0 +1,1 @@\n+SELECT x, y FROM (SELECT 5 AS x, 'Hello' AS y) ORDER BY x WITH FILL FROM 3 TO 7, y, x WITH FILL FROM 1 TO 10; -- { serverError 475 }\ndiff --git a/tests/queries/0_stateless/2019_multiple_weird_with_fill.reference b/tests/queries/0_stateless/2019_multiple_weird_with_fill.reference\nnew file mode 100644\nindex 000000000000..822d290564a8\n--- /dev/null\n+++ b/tests/queries/0_stateless/2019_multiple_weird_with_fill.reference\n@@ -0,0 +1,45 @@\n+3\t-10\t\n+3\t-9\t\n+3\t-8\t\n+3\t-7\t\n+3\t-6\t\n+3\t-5\t\n+3\t-4\t\n+3\t-3\t\n+3\t-2\t\n+4\t-10\t\n+4\t-9\t\n+4\t-8\t\n+4\t-7\t\n+4\t-6\t\n+4\t-5\t\n+4\t-4\t\n+4\t-3\t\n+4\t-2\t\n+5\t-10\t\n+5\t-9\t\n+5\t-8\t\n+5\t-7\t\n+5\t-6\t\n+5\t-5\tHello\n+5\t-4\t\n+5\t-3\t\n+5\t-2\t\n+6\t-10\t\n+6\t-9\t\n+6\t-8\t\n+6\t-7\t\n+6\t-6\t\n+6\t-5\t\n+6\t-4\t\n+6\t-3\t\n+6\t-2\t\n+7\t-10\t\n+7\t-9\t\n+7\t-8\t\n+7\t-7\t\n+7\t-6\t\n+7\t-5\t\n+7\t-4\t\n+7\t-3\t\n+7\t-2\t\ndiff --git a/tests/queries/0_stateless/2019_multiple_weird_with_fill.sql b/tests/queries/0_stateless/2019_multiple_weird_with_fill.sql\nnew file mode 100644\nindex 000000000000..a2ed33c51ddc\n--- /dev/null\n+++ b/tests/queries/0_stateless/2019_multiple_weird_with_fill.sql\n@@ -0,0 +1,14 @@\n+SELECT\n+    x,\n+    -x,\n+    y\n+FROM\n+(\n+    SELECT\n+        5 AS x,\n+        'Hello' AS y\n+)\n+ORDER BY\n+    x ASC WITH FILL FROM 3 TO 7,\n+    y ASC,\n+    -x ASC WITH FILL FROM -10 TO -1;\n",
  "problem_statement": "In some cases ORDER BY is mistakenly removed from subquery if WITH FILL is used\n```\r\nSELECT s FROM (SELECT 5 AS x, 'Hello' AS s ORDER BY x WITH FILL FROM 1 TO 10) ORDER BY s\r\n\r\n\u250c\u2500s\u2500\u2500\u2500\u2500\u2500\u2510\r\n\u2502 Hello \u2502\r\n\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n```\nIncorrect results of ORDER BY ... WITH FILL when used together with toStartOfMinute()\n```\r\nselect toStartOfMinute(some_time) as ts\r\nfrom (select toDateTime('2021-07-07 15:21:05') as some_time)\r\norder by ts with fill from toDateTime('2021-07-07 15:21:00') to toDateTime('2021-07-07 15:21:15') step 5\r\n\r\n```\r\nreturns \r\n1970-01-01 01:00:00\r\n2021-07-07 15:21:00\r\n1970-01-01 01:00:00\r\n\r\nbut expected to return\r\n2021-07-07 15:21:00\r\n2021-07-07 15:21:05\r\n2021-07-07 15:21:10\r\n\r\nselect version()\r\n21.4.7.3\n",
  "hints_text": "\n",
  "created_at": "2021-09-11T22:25:01Z"
}