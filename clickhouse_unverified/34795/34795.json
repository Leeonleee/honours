{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34795,
  "instance_id": "ClickHouse__ClickHouse-34795",
  "issue_numbers": [
    "34010"
  ],
  "base_commit": "065305ab65d2733fea463e863eeabb19be0b1c82",
  "patch": "diff --git a/src/Functions/array/arrayCompact.cpp b/src/Functions/array/arrayCompact.cpp\nindex c2908e37e125..8c16d536e463 100644\n--- a/src/Functions/array/arrayCompact.cpp\n+++ b/src/Functions/array/arrayCompact.cpp\n@@ -20,9 +20,9 @@ struct ArrayCompactImpl\n     static bool needExpression() { return false; }\n     static bool needOneArray() { return false; }\n \n-    static DataTypePtr getReturnType(const DataTypePtr & nested_type, const DataTypePtr &)\n+    static DataTypePtr getReturnType(const DataTypePtr & , const DataTypePtr & array_element)\n     {\n-        return std::make_shared<DataTypeArray>(nested_type);\n+        return std::make_shared<DataTypeArray>(array_element);\n     }\n \n     template <typename T>\n@@ -30,14 +30,16 @@ struct ArrayCompactImpl\n     {\n         using ColVecType = ColumnVectorOrDecimal<T>;\n \n-        const ColVecType * src_values_column = checkAndGetColumn<ColVecType>(mapped.get());\n+        const ColVecType * check_values_column = checkAndGetColumn<ColVecType>(mapped.get());\n+        const ColVecType * src_values_column = checkAndGetColumn<ColVecType>(array.getData());\n \n-        if (!src_values_column)\n+        if (!src_values_column || !check_values_column)\n             return false;\n \n         const IColumn::Offsets & src_offsets = array.getOffsets();\n-        const typename ColVecType::Container & src_values = src_values_column->getData();\n \n+        const auto & src_values = src_values_column->getData();\n+        const auto & check_values = check_values_column->getData();\n         typename ColVecType::MutablePtr res_values_column;\n         if constexpr (is_decimal<T>)\n             res_values_column = ColVecType::create(src_values.size(), src_values_column->getScale());\n@@ -45,6 +47,7 @@ struct ArrayCompactImpl\n             res_values_column = ColVecType::create(src_values.size());\n \n         typename ColVecType::Container & res_values = res_values_column->getData();\n+\n         size_t src_offsets_size = src_offsets.size();\n         auto res_offsets_column = ColumnArray::ColumnOffsets::create(src_offsets_size);\n         IColumn::Offsets & res_offsets = res_offsets_column->getData();\n@@ -67,7 +70,7 @@ struct ArrayCompactImpl\n                 ++res_pos;\n                 for (; src_pos < src_offset; ++src_pos)\n                 {\n-                    if (!bitEquals(src_values[src_pos], src_values[src_pos - 1]))\n+                    if (!bitEquals(check_values[src_pos], check_values[src_pos - 1]))\n                     {\n                         res_values[res_pos] = src_values[src_pos];\n                         ++res_pos;\n@@ -86,8 +89,9 @@ struct ArrayCompactImpl\n     {\n         const IColumn::Offsets & src_offsets = array.getOffsets();\n \n-        auto res_values_column = mapped->cloneEmpty();\n-        res_values_column->reserve(mapped->size());\n+        const auto & src_values = array.getData();\n+        auto res_values_column = src_values.cloneEmpty();\n+        res_values_column->reserve(src_values.size());\n \n         size_t src_offsets_size = src_offsets.size();\n         auto res_offsets_column = ColumnArray::ColumnOffsets::create(src_offsets_size);\n@@ -104,7 +108,7 @@ struct ArrayCompactImpl\n             if (src_pos < src_offset)\n             {\n                 /// Insert first element unconditionally.\n-                res_values_column->insertFrom(*mapped, src_pos);\n+                res_values_column->insertFrom(src_values, src_pos);\n \n                 /// For the rest of elements, insert if the element is different from the previous.\n                 ++src_pos;\n@@ -113,7 +117,7 @@ struct ArrayCompactImpl\n                 {\n                     if (mapped->compareAt(src_pos - 1, src_pos, *mapped, 1))\n                     {\n-                        res_values_column->insertFrom(*mapped, src_pos);\n+                        res_values_column->insertFrom(src_values, src_pos);\n                         ++res_pos;\n                     }\n                 }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01020_function_array_compact.sql b/tests/queries/0_stateless/01020_function_array_compact.sql\nindex d4aaa4d3fca6..29adb007dc4d 100644\n--- a/tests/queries/0_stateless/01020_function_array_compact.sql\n+++ b/tests/queries/0_stateless/01020_function_array_compact.sql\n@@ -7,5 +7,5 @@ select arrayCompact([1,1,2]);\n select arrayCompact([1,2,1]);\n select arrayCompact([2,1,1]);\n select arrayCompact([1,2,2,3,3,3,4,4,4,4,5,5,5,5,5]);\n-SELECT arrayCompact(x->0, [NULL]);\n-SELECT toString(arrayCompact(x->0, [NULL]));\n+SELECT arrayCompact(arrayMap(x->0, [NULL]));\n+SELECT toString(arrayCompact(arrayMap(x->0, [NULL])));\ndiff --git a/tests/queries/0_stateless/01025_array_compact_generic.reference b/tests/queries/0_stateless/01025_array_compact_generic.reference\nindex d95e269cd3ff..572c7ee140ce 100644\n--- a/tests/queries/0_stateless/01025_array_compact_generic.reference\n+++ b/tests/queries/0_stateless/01025_array_compact_generic.reference\n@@ -15,3 +15,6 @@\n ['0','1','2']\n ['0','1','2']\n ['0','1','2']\n+[(0,0),(3,1),(6,2),(9,0)]\n+[('0','0'),('3','1'),('6','2'),('9','0')]\n+[('0',0),('3',1),('6',2),('9',0)]\ndiff --git a/tests/queries/0_stateless/01025_array_compact_generic.sql b/tests/queries/0_stateless/01025_array_compact_generic.sql\nindex bea39bfbd44f..4446d10e9d48 100644\n--- a/tests/queries/0_stateless/01025_array_compact_generic.sql\n+++ b/tests/queries/0_stateless/01025_array_compact_generic.sql\n@@ -5,4 +5,7 @@ SELECT arrayCompact([1, 1, NULL, NULL, 2, 2, 2]);\n SELECT arrayCompact([1, 1, NULL, NULL, nan, nan, 2, 2, 2]);\n SELECT arrayCompact(['hello', '', '', '', 'world', 'world']);\n SELECT arrayCompact([[[]], [[], []], [[], []], [[]]]);\n-SELECT arrayCompact(x -> toString(intDiv(x, 3)), range(number)) FROM numbers(10);\n+SELECT arrayCompact(arrayMap(x -> toString(intDiv(x, 3)), range(number))) FROM numbers(10);\n+SELECT arrayCompact(x -> x.2, groupArray((number, intDiv(number, 3) % 3))) FROM numbers(10);\n+SELECT arrayCompact(x -> x.2, groupArray((toString(number), toString(intDiv(number, 3) % 3)))) FROM numbers(10);\n+SELECT arrayCompact(x -> x.2, groupArray((toString(number), intDiv(number, 3) % 3))) FROM numbers(10);\n",
  "problem_statement": "arrayCompact: higher-order ?\n\r\n**Describe the unexpected behaviour**\r\n\r\nCurrent implementation of arrayCompact does not behave as other higher-order functions: it accepts lambda function as its first argument, but then it compacts array returned by lambda, not original array (see below for example).\r\n\r\n**How to reproduce**\r\n* Which ClickHouse server version to use\r\n\r\nAny modern\r\n\r\n* Queries to run that lead to unexpected result\r\n\r\nselect arrayCompact(x -> x.2 , groupArray(tuple(number, intDiv(number, 3) % 3))) from numbers(10);\r\n\r\n**Expected behavior**\r\n\r\narrayCompact shall follow normal higher-order functons way and use results of lambda function ([0,0,0,1,1,1,2,2,2,0]) to compact original array ([(0,0),(1,0),(2,0),(3,1),(4,1),(5,1),(6,2),(7,2),(8,2),(9,0)]) into [(0,0),(3,1),(6,2),(9,0)]\r\n\r\n**Additional context**\r\n\r\nUse case: timeseries (time, value) with lots of repeated values that shall be compacted into (first time, value) when value repeats.\r\n\n",
  "hints_text": "Related https://github.com/ClickHouse/ClickHouse/issues/18535 https://github.com/ClickHouse/ClickHouse/issues/14778",
  "created_at": "2022-02-21T14:20:33Z"
}