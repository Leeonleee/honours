{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 67229,
  "instance_id": "ClickHouse__ClickHouse-67229",
  "issue_numbers": [
    "67112"
  ],
  "base_commit": "ee87209445ac4ef12eb0b67def20b500c794b24a",
  "patch": "diff --git a/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp b/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp\nindex c1adf05ac765..a48e88132a68 100644\n--- a/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp\n+++ b/src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp\n@@ -2,6 +2,7 @@\n \n #include <DataTypes/DataTypesNumber.h>\n #include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeAggregateFunction.h>\n \n #include <AggregateFunctions/AggregateFunctionFactory.h>\n #include <AggregateFunctions/IAggregateFunction.h>\n@@ -42,7 +43,7 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith\n         if (lower_name.ends_with(\"if\"))\n             return;\n \n-        auto & function_arguments_nodes = function_node->getArguments().getNodes();\n+        const auto & function_arguments_nodes = function_node->getArguments().getNodes();\n         if (function_arguments_nodes.size() != 1)\n             return;\n \n@@ -50,6 +51,8 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith\n         if (!if_node || if_node->getFunctionName() != \"if\")\n             return;\n \n+        FunctionNodePtr replaced_node;\n+\n         auto if_arguments_nodes = if_node->getArguments().getNodes();\n         auto * first_const_node = if_arguments_nodes[1]->as<ConstantNode>();\n         auto * second_const_node = if_arguments_nodes[2]->as<ConstantNode>();\n@@ -75,8 +78,11 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith\n                     new_arguments[0] = std::move(if_arguments_nodes[1]);\n \n                 new_arguments[1] = std::move(if_arguments_nodes[0]);\n-                function_arguments_nodes = std::move(new_arguments);\n-                resolveAggregateFunctionNodeByName(*function_node, function_node->getFunctionName() + \"If\");\n+\n+                replaced_node = std::make_shared<FunctionNode>(function_node->getFunctionName() + \"If\");\n+                replaced_node->getArguments().getNodes() = std::move(new_arguments);\n+                replaced_node->getParameters().getNodes() = function_node->getParameters().getNodes();\n+                resolveAggregateFunctionNodeByName(*replaced_node, replaced_node->getFunctionName());\n             }\n         }\n         else if (first_const_node)\n@@ -104,10 +110,26 @@ class RewriteAggregateFunctionWithIfVisitor : public InDepthQueryTreeVisitorWith\n                     FunctionFactory::instance().get(\"not\", getContext())->build(not_function->getArgumentColumns()));\n                 new_arguments[1] = std::move(not_function);\n \n-                function_arguments_nodes = std::move(new_arguments);\n-                resolveAggregateFunctionNodeByName(*function_node, function_node->getFunctionName() + \"If\");\n+                replaced_node = std::make_shared<FunctionNode>(function_node->getFunctionName() + \"If\");\n+                replaced_node->getArguments().getNodes() = std::move(new_arguments);\n+                replaced_node->getParameters().getNodes() = function_node->getParameters().getNodes();\n+                resolveAggregateFunctionNodeByName(*replaced_node, replaced_node->getFunctionName());\n             }\n         }\n+\n+        if (!replaced_node)\n+            return;\n+\n+        auto prev_type = function_node->getResultType();\n+        auto curr_type = replaced_node->getResultType();\n+        if (!prev_type->equals(*curr_type))\n+            return;\n+\n+        /// Just in case, CAST compatible aggregate function states.\n+        if (WhichDataType(prev_type).isAggregateFunction() && !DataTypeAggregateFunction::strictEquals(prev_type, curr_type))\n+            node = createCastFunction(std::move(replaced_node), prev_type, getContext());\n+        else\n+            node = std::move(replaced_node);\n     }\n };\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03132_rewrite_aggregate_function_with_if_implicit_cast.reference b/tests/queries/0_stateless/03132_rewrite_aggregate_function_with_if_implicit_cast.reference\nindex 070a6c9e21cb..8289ab68ae4c 100644\n--- a/tests/queries/0_stateless/03132_rewrite_aggregate_function_with_if_implicit_cast.reference\n+++ b/tests/queries/0_stateless/03132_rewrite_aggregate_function_with_if_implicit_cast.reference\n@@ -30,14 +30,14 @@ QUERY id: 0\n       FUNCTION id: 15, function_name: toTypeName, function_type: ordinary, result_type: String\n         ARGUMENTS\n           LIST id: 16, nodes: 1\n-            FUNCTION id: 2, function_name: anyIf, function_type: aggregate, result_type: Nullable(Int128)\n+            FUNCTION id: 17, function_name: anyIf, function_type: aggregate, result_type: Nullable(Int128)\n               ARGUMENTS\n-                LIST id: 3, nodes: 2\n-                  FUNCTION id: 4, function_name: _CAST, function_type: ordinary, result_type: Nullable(Int128)\n+                LIST id: 18, nodes: 2\n+                  FUNCTION id: 19, function_name: _CAST, function_type: ordinary, result_type: Nullable(Int128)\n                     ARGUMENTS\n-                      LIST id: 5, nodes: 2\n+                      LIST id: 20, nodes: 2\n                         COLUMN id: 6, column_name: number, result_type: UInt64, source_id: 7\n-                        CONSTANT id: 8, constant_value: \\'Nullable(Int128)\\', constant_value_type: String\n+                        CONSTANT id: 21, constant_value: \\'Nullable(Int128)\\', constant_value_type: String\n                   FUNCTION id: 9, function_name: equals, function_type: ordinary, result_type: UInt8\n                     ARGUMENTS\n                       LIST id: 10, nodes: 2\n@@ -50,8 +50,8 @@ QUERY id: 0\n   JOIN TREE\n     TABLE_FUNCTION id: 7, alias: __table1, table_function_name: numbers\n       ARGUMENTS\n-        LIST id: 17, nodes: 1\n-          CONSTANT id: 18, constant_value: UInt64_100, constant_value_type: UInt8\n+        LIST id: 22, nodes: 1\n+          CONSTANT id: 23, constant_value: UInt64_100, constant_value_type: UInt8\n SELECT any(if((number % 10) = 5, CAST(NULL, 'Nullable(Int128)'), number)) AS a, toTypeName(a) FROM numbers(100) AS a;\n 0\tNullable(Int128)\n EXPLAIN QUERY TREE SELECT any(if((number % 10) = 5, CAST(NULL, 'Nullable(Int128)'), number)) AS a, toTypeName(a) FROM numbers(100);\n@@ -84,17 +84,17 @@ QUERY id: 0\n       FUNCTION id: 17, function_name: toTypeName, function_type: ordinary, result_type: String\n         ARGUMENTS\n           LIST id: 18, nodes: 1\n-            FUNCTION id: 2, function_name: anyIf, function_type: aggregate, result_type: Nullable(Int128)\n+            FUNCTION id: 19, function_name: anyIf, function_type: aggregate, result_type: Nullable(Int128)\n               ARGUMENTS\n-                LIST id: 3, nodes: 2\n-                  FUNCTION id: 4, function_name: _CAST, function_type: ordinary, result_type: Nullable(Int128)\n+                LIST id: 20, nodes: 2\n+                  FUNCTION id: 21, function_name: _CAST, function_type: ordinary, result_type: Nullable(Int128)\n                     ARGUMENTS\n-                      LIST id: 5, nodes: 2\n+                      LIST id: 22, nodes: 2\n                         COLUMN id: 6, column_name: number, result_type: UInt64, source_id: 7\n-                        CONSTANT id: 8, constant_value: \\'Nullable(Int128)\\', constant_value_type: String\n-                  FUNCTION id: 9, function_name: not, function_type: ordinary, result_type: UInt8\n+                        CONSTANT id: 23, constant_value: \\'Nullable(Int128)\\', constant_value_type: String\n+                  FUNCTION id: 24, function_name: not, function_type: ordinary, result_type: UInt8\n                     ARGUMENTS\n-                      LIST id: 10, nodes: 1\n+                      LIST id: 25, nodes: 1\n                         FUNCTION id: 11, function_name: equals, function_type: ordinary, result_type: UInt8\n                           ARGUMENTS\n                             LIST id: 12, nodes: 2\n@@ -107,5 +107,5 @@ QUERY id: 0\n   JOIN TREE\n     TABLE_FUNCTION id: 7, alias: __table1, table_function_name: numbers\n       ARGUMENTS\n-        LIST id: 19, nodes: 1\n-          CONSTANT id: 20, constant_value: UInt64_100, constant_value_type: UInt8\n+        LIST id: 26, nodes: 1\n+          CONSTANT id: 27, constant_value: UInt64_100, constant_value_type: UInt8\ndiff --git a/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.reference b/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.reference\nnew file mode 100644\nindex 000000000000..0693acb91683\n--- /dev/null\n+++ b/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.reference\n@@ -0,0 +1,9 @@\n+03\n+AggregateFunction(count, Nullable(UInt64))\n+function_name: _CAST, function_type: ordinary, result_type: AggregateFunction(count, Nullable(UInt64))\n+function_name: countStateIf, function_type: aggregate, result_type: AggregateFunction(count, UInt64)\n+constant_value: \\'AggregateFunction(count, Nullable(UInt64))\\', constant_value_type: String\n+AggregateFunction(uniq, Nullable(UInt64))\n+010003000000007518F0A8E7830665\n+function_name: uniqState, function_type: aggregate, result_type: AggregateFunction(uniq, Nullable(UInt64))\n+----\ndiff --git a/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.sql b/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.sql\nnew file mode 100644\nindex 000000000000..565a481940ad\n--- /dev/null\n+++ b/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.sql\n@@ -0,0 +1,39 @@\n+SET allow_experimental_analyzer = 1;\n+\n+-- For function count, rewrite countState to countStateIf changes the type from AggregateFunction(count, Nullable(UInt64)) to AggregateFunction(count, UInt64)\n+-- We can cast AggregateFunction(count, UInt64) back to AggregateFunction(count, Nullable(UInt64)) with additional _CAST\n+select hex(countState(if(toNullable(number % 2 = 0), number, null))) from numbers(5) settings optimize_rewrite_aggregate_function_with_if=1;\n+select toTypeName(countState(if(toNullable(number % 2 = 0), number, null))) from numbers(5) settings optimize_rewrite_aggregate_function_with_if=1;\n+select arrayStringConcat(arraySlice(splitByString(', ', trimLeft(explain)), 2), ', ') from (explain query tree select hex(countState(if(toNullable(number % 2 = 0), number, null))) from numbers(5) settings optimize_rewrite_aggregate_function_with_if=1) where explain like '%AggregateFunction%';\n+\n+-- For function uniq, rewrite uniqState to uniqStateIf changes the type from AggregateFunction(uniq, Nullable(UInt64)) to AggregateFunction(uniq, UInt64)\n+-- We can't cast AggregateFunction(uniq, UInt64) back to AggregateFunction(uniq, Nullable(UInt64)) so rewrite is not happening.\n+select toTypeName(uniqState(if(toNullable(number % 2 = 0), number, null))) from numbers(5) settings optimize_rewrite_aggregate_function_with_if=1;\n+select hex(uniqState(if(toNullable(number % 2 = 0), number, null))) from numbers(5) settings optimize_rewrite_aggregate_function_with_if=1;\n+select arrayStringConcat(arraySlice(splitByString(', ', trimLeft(explain)), 2), ', ') from (explain query tree select hex(uniqState(if(toNullable(number % 2 = 0), number, null))) from numbers(5) settings optimize_rewrite_aggregate_function_with_if=1) where explain like '%AggregateFunction%';\n+\n+select '----';\n+\n+CREATE TABLE a\n+(\n+    `a_id` String\n+)\n+ENGINE = MergeTree\n+PARTITION BY tuple()\n+ORDER BY tuple();\n+\n+\n+CREATE TABLE b\n+(\n+    `b_id` AggregateFunction(uniq, Nullable(String))\n+)\n+ENGINE = AggregatingMergeTree\n+PARTITION BY tuple()\n+ORDER BY tuple();\n+\n+CREATE MATERIALIZED VIEW mv TO b\n+(\n+    `b_id` AggregateFunction(uniq, Nullable(String))\n+)\n+AS SELECT uniqState(if(a_id != '', a_id, NULL)) AS b_id\n+FROM a;\n",
  "problem_statement": "create MATERIALIZED VIEW failed\nreproduce:\r\nCREATE TABLE a\r\n(\r\n    a_id String\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY tuple() order by tuple();\r\n\r\nCREATE TABLE b\r\n(\r\n    b_id AggregateFunction(uniq, Nullable(String))\r\n)\r\nENGINE = AggregatingMergeTree\r\nPARTITION BY tuple() order by tuple();\r\n\r\nCREATE MATERIALIZED VIEW mv TO b\r\n(\r\n    b_id AggregateFunction(uniq, Nullable(String))\r\n) AS\r\nSELECT\r\n    uniqState(if(a_id != '', a_id, NULL)) as b_id\r\nFROM a;\r\n\r\nReceived exception:\r\nCode: 70. DB::Exception: Conversion from AggregateFunction(uniq, String) to AggregateFunction(uniq, Nullable(String)) is not supported: while converting source column b_id to destination column b_id. (CANNOT_CONVERT_TYPE)\r\n\r\nIt can work on earlier version like 23.11.x\r\n\n",
  "hints_text": "related to experimental analyzer  https://fiddle.clickhouse.com/143a8dac-c2be-41b8-8ef9-64090ba0a171\r\n\r\nyou can disable analyzer \r\n\r\n```\r\ncat /etc/clickhouse-server/users.d/allow_experimental_analyzer.xml\r\n<?xml version=\"1.0\" ?>\r\n<clickhouse>\r\n    <profiles>\r\n        <default>\r\n            <allow_experimental_analyzer>0</allow_experimental_analyzer>\r\n        </default>\r\n    </profiles>\r\n</clickhouse>\r\n```\r\n\r\nor use `uniqState(toNullable(if(a_id != '', a_id, NULL))) as b_id`\r\n\r\nBTW, Nullable has little sense here, you can use `uniqStateIf(a_id, a_id != '')`\n> related to experimental analyzer https://fiddle.clickhouse.com/143a8dac-c2be-41b8-8ef9-64090ba0a171\r\n> \r\n> you can disable analyzer\r\n> \r\n> ```\r\n> cat /etc/clickhouse-server/users.d/allow_experimental_analyzer.xml\r\n> <?xml version=\"1.0\" ?>\r\n> <clickhouse>\r\n>     <profiles>\r\n>         <default>\r\n>             <allow_experimental_analyzer>0</allow_experimental_analyzer>\r\n>         </default>\r\n>     </profiles>\r\n> </clickhouse>\r\n> ```\r\n> \r\n> or use `uniqState(toNullable(if(a_id != '', a_id, NULL))) as b_id`\r\n> \r\n> BTW, Nullable has little sense here, you can use `uniqStateIf(a_id, a_id != '')`\r\nuniqStateIf(a_id, a_id != '') is not work if not setting allow_experimental_analyzer=0\r\nI'm still a little confused that:\r\nSELECT toTypeName(if(a_id != '', a_id, NULL))\r\nFROM a\r\nit return **Nullable(String)**\r\nwhy should I use **toNullable** function to convert **Nullable(String)** type ?\r\n\r\n\n@caoyang10 \r\n\r\nJust use \r\n\r\n```\r\ncat /etc/clickhouse-server/users.d/allow_experimental_analyzer.xml\r\n<?xml version=\"1.0\" ?>\r\n<clickhouse>\r\n    <profiles>\r\n        <default>\r\n            <allow_experimental_analyzer>0</allow_experimental_analyzer>\r\n        </default>\r\n    </profiles>\r\n</clickhouse>\r\n```\r\n\r\n------\r\n\r\n>why should I use toNullable function \r\n\r\nsee https://fiddle.clickhouse.com/ecf4b482-0495-4fe6-8469-1c42b9e6ed21\n@alexey-milovidov https://fiddle.clickhouse.com/143a8dac-c2be-41b8-8ef9-64090ba0a171 \nyeah, set allow_experimental_analyzer = 0 can solve my problem.\r\nBut I think whatever allow_experimental_analyzer is,\r\nif(a_id != '', a_id, NULL) return Nullable(String) type,\r\nuniqState(if(a_id != '', a_id, NULL)) should return AggregateFunction(uniq, Nullable(String)) type, but not AggregateFunction(uniq, String)\r\nthat makes me confused. @den-crane @alexey-milovidov \r\nhttps://fiddle.clickhouse.com/e85eafcf-1721-4e7f-a90f-4116937c8647\nThis is because of `optimize_rewrite_aggregate_function_with_if` optimization.\r\n```\r\nSELECT toTypeName(uniqStateIf(toNullable(number), number > 0))\r\nFROM numbers(2)\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\nQuery id: 4ca82c5c-30f1-4b6a-8f8f-075fa73f7b9f\r\n\r\n   \u250c\u2500toTypeName(uniqStateIf(toNullable(number), greater(number, 0)))\u2500\u2510\r\n1. \u2502 AggregateFunction(uniq, UInt64)                                 \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n\r\nSELECT toTypeName(uniqState(toNullable(number)))\r\nFROM numbers(2)\r\nSETTINGS allow_experimental_analyzer = 0\r\n\r\nQuery id: 4716ac8d-cf57-465f-844d-930e2fbcc937\r\n\r\n   \u250c\u2500toTypeName(uniqState(toNullable(number)))\u2500\u2510\r\n1. \u2502 AggregateFunction(uniq, Nullable(UInt64)) \u2502\r\n   \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\r\n\r\n```\r\n\r\nIt is strange that `If` changes the return type. But I suppose it is too late to fix it: it would be backward incompatible. (Also, we can't cast `AggregateFunction(uniq, UInt64)` to `AggregateFunction(uniq, Nullable(UInt64))` ).\r\n\r\nI am about to disable this case for `uniq`.\r\n",
  "created_at": "2024-07-26T17:42:48Z",
  "modified_files": [
    "src/Analyzer/Passes/RewriteAggregateFunctionWithIfPass.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/03132_rewrite_aggregate_function_with_if_implicit_cast.reference",
    "b/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.reference",
    "b/tests/queries/0_stateless/03210_optimize_rewrite_aggregate_function_with_if_return_type_bug.sql"
  ]
}