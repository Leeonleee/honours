{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40037,
  "instance_id": "ClickHouse__ClickHouse-40037",
  "issue_numbers": [
    "39635",
    "39678"
  ],
  "base_commit": "fdb1c2545f6acda414510e510bb537d719f162d0",
  "patch": "diff --git a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\nindex f922ff048b2b..36f4536d9188 100644\n--- a/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\n+++ b/src/Processors/Formats/Impl/ArrowColumnToCHColumn.cpp\n@@ -326,6 +326,69 @@ static std::shared_ptr<arrow::ChunkedArray> getNestedArrowColumn(std::shared_ptr\n     return std::make_shared<arrow::ChunkedArray>(array_vector);\n }\n \n+static ColumnWithTypeAndName createLCColumnFromArrowDictionaryValues(\n+    const std::shared_ptr<ColumnWithTypeAndName> & dict_values,\n+    const ColumnPtr & indexes_column,\n+    const String & column_name\n+)\n+{\n+    auto lc_type = std::make_shared<DataTypeLowCardinality>(dict_values->type);\n+\n+    auto lc_column = lc_type->createColumn();\n+\n+    for (auto i = 0u; i < indexes_column->size(); i++)\n+    {\n+        Field f;\n+        dict_values->column->get(indexes_column->getUInt(i), f);\n+        lc_column->insert(f);\n+    }\n+\n+    return {std::move(lc_column), std::move(lc_type), column_name};\n+}\n+\n+/*\n+ * Dictionary(Nullable(X)) in ArrowColumn format is composed of a nullmap, dictionary and an index.\n+ * It doesn't have the concept of null or default values.\n+ * An empty string is just a regular value appended at any position of the dictionary.\n+ * Null values have an index of 0, but it should be ignored since the nullmap will return null.\n+ * In ClickHouse LowCardinality, it's different. The dictionary contains null and default values at the beginning.\n+ * [null, default, ...]. Therefore, null values have an index of 0 and default values have an index of 1.\n+ * No nullmap is used.\n+ * */\n+static ColumnWithTypeAndName createLCOfNullableColumnFromArrowDictionaryValues(\n+    const std::shared_ptr<ColumnWithTypeAndName> & dict_values,\n+    const ColumnPtr & indexes_column,\n+    const ColumnPtr & nullmap_column,\n+    const String & column_name\n+)\n+{\n+    /*\n+     * ArrowColumn format handles nulls by maintaining a nullmap column, there is no nullable type.\n+     * Therefore, dict_values->type is the actual data type/ non-nullable. It needs to be transformed into nullable\n+     * so LC column is created from nullable type and a null value at the beginning of the collection\n+     * is automatically added.\n+     * */\n+    auto lc_type = std::make_shared<DataTypeLowCardinality>(makeNullable(dict_values->type));\n+\n+    auto lc_column = lc_type->createColumn();\n+\n+    for (auto i = 0u; i < indexes_column->size(); i++)\n+    {\n+        if (nullmap_column && nullmap_column->getBool(i))\n+        {\n+            lc_column->insertDefault();\n+        }\n+        else\n+        {\n+            Field f;\n+            dict_values->column->get(indexes_column->getUInt(i), f);\n+            lc_column->insert(f);\n+        }\n+    }\n+\n+    return {std::move(lc_column), std::move(lc_type), column_name};\n+}\n+\n static ColumnWithTypeAndName readColumnFromArrowColumn(\n     std::shared_ptr<arrow::ChunkedArray> & arrow_column,\n     const std::string & column_name,\n@@ -338,7 +401,8 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n     bool & skipped)\n {\n     if (!is_nullable && arrow_column->null_count() && arrow_column->type()->id() != arrow::Type::LIST\n-        && arrow_column->type()->id() != arrow::Type::MAP && arrow_column->type()->id() != arrow::Type::STRUCT)\n+        && arrow_column->type()->id() != arrow::Type::MAP && arrow_column->type()->id() != arrow::Type::STRUCT &&\n+        arrow_column->type()->id() != arrow::Type::DICTIONARY)\n     {\n         auto nested_column = readColumnFromArrowColumn(arrow_column, column_name, format_name, true, dictionary_values, read_ints_as_dates, allow_null_type, skip_columns_with_unsupported_types, skipped);\n         if (skipped)\n@@ -455,12 +519,6 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n                 }\n                 auto arrow_dict_column = std::make_shared<arrow::ChunkedArray>(dict_array);\n                 auto dict_column = readColumnFromArrowColumn(arrow_dict_column, column_name, format_name, false, dictionary_values, read_ints_as_dates, allow_null_type, skip_columns_with_unsupported_types, skipped);\n-\n-                /// We should convert read column to ColumnUnique.\n-                auto tmp_lc_column = DataTypeLowCardinality(dict_column.type).createColumn();\n-                auto tmp_dict_column = IColumn::mutate(assert_cast<ColumnLowCardinality *>(tmp_lc_column.get())->getDictionaryPtr());\n-                static_cast<IColumnUnique *>(tmp_dict_column.get())->uniqueInsertRangeFrom(*dict_column.column, 0, dict_column.column->size());\n-                dict_column.column = std::move(tmp_dict_column);\n                 dict_values = std::make_shared<ColumnWithTypeAndName>(std::move(dict_column));\n             }\n \n@@ -473,9 +531,19 @@ static ColumnWithTypeAndName readColumnFromArrowColumn(\n \n             auto arrow_indexes_column = std::make_shared<arrow::ChunkedArray>(indexes_array);\n             auto indexes_column = readColumnWithIndexesData(arrow_indexes_column);\n-            auto lc_column = ColumnLowCardinality::create(dict_values->column, indexes_column);\n-            auto lc_type = std::make_shared<DataTypeLowCardinality>(dict_values->type);\n-            return {std::move(lc_column), std::move(lc_type), column_name};\n+\n+            const auto contains_null = arrow_column->null_count() > 0;\n+\n+            if (contains_null)\n+            {\n+                auto nullmap_column = readByteMapFromArrowColumn(arrow_column);\n+\n+                return createLCOfNullableColumnFromArrowDictionaryValues(dict_values, indexes_column, nullmap_column, column_name);\n+            }\n+            else\n+            {\n+                return createLCColumnFromArrowDictionaryValues(dict_values, indexes_column, column_name);\n+            }\n         }\n #    define DISPATCH(ARROW_NUMERIC_TYPE, CPP_NUMERIC_TYPE) \\\n         case ARROW_NUMERIC_TYPE: \\\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02381_arrow_dict_of_nullable_string_to_lc.reference b/tests/queries/0_stateless/02381_arrow_dict_of_nullable_string_to_lc.reference\nnew file mode 100644\nindex 000000000000..a6c4a5b13a22\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_arrow_dict_of_nullable_string_to_lc.reference\n@@ -0,0 +1,9 @@\n+lc_nullable_string\n+LowCardinality(Nullable(String))\n+one\n+\\N\n+three\n+\n+\\N\n+\n+six\ndiff --git a/tests/queries/0_stateless/02381_arrow_dict_of_nullable_string_to_lc.sh b/tests/queries/0_stateless/02381_arrow_dict_of_nullable_string_to_lc.sh\nnew file mode 100755\nindex 000000000000..2d854c956b25\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_arrow_dict_of_nullable_string_to_lc.sh\n@@ -0,0 +1,31 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# ## reading ArrowStream file from python\n+# import pyarrow as pa\n+# stream = pa.ipc.open_stream(\"test.arrows\")\n+# x = stream.read_all()\n+# print(x)\n+\n+## writing ArrowStream file from python\n+# import pyarrow as pa\n+# data = [\n+#     pa.array([\"one\", None, \"three\", \"\", None, \"\", \"six\"]).dictionary_encode(),\n+# ]\n+# batch = pa.record_batch(data, names=['id', 'lc_nullable', 'lc_int_nullable', 'bool_nullable'])\n+# writer = pa.ipc.new_stream(\"test4.arrows\", batch.schema)\n+# writer.write_batch(batch)\n+# writer.close()\n+\n+# cat data.arrow | gzip | base64\n+\n+cat <<EOF | base64 --decode | gunzip | $CLICKHOUSE_LOCAL --query='SELECT * FROM table FORMAT TSVWithNamesAndTypes' --input-format=ArrowStream\n+H4sIAAAAAAAAA3VQQQ6CQAychRWIcjCGGA4ePHrwCT7Bgz8waoiSICaoiU/wGR49+Me1XboIJDYp\n+3d2ZTjsYY8wLwBgcQ8QIMEBEJwqloal8iMNVUSaWmxIjQEjsMb3UvWrA2IZySalRx4SyOGzLe1Hs\n+9kW2vd6qvDyC+iPL4m8MvseUob2z2NyiutGhFcxb5sP2JLJpbPvhaYstBK8d1PrOW0pMLcha3p0+\n+h4//4eamUkctTPV02nqRpONfyux2qrLsmj8aX8+Or2nXl6/tzEWj2vWxEh9ha67X2w2yA8esh7k+\n+13PueVAtzMPvH/HebPkLlbsntUACAAA=\n+EOF\n\\ No newline at end of file\ndiff --git a/tests/queries/0_stateless/02381_arrow_dict_to_lc.reference b/tests/queries/0_stateless/02381_arrow_dict_to_lc.reference\nnew file mode 100644\nindex 000000000000..7d35a0d4b77e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_arrow_dict_to_lc.reference\n@@ -0,0 +1,7 @@\n+id\tlc_nullable\tlc_int_nullable\tbool_nullable\n+Nullable(Int64)\tLowCardinality(Nullable(String))\tLowCardinality(Nullable(Int64))\tNullable(UInt8)\n+1\tonee\t1\t1\n+2\ttwoo\t2\t0\n+3\tthree\t3\t1\n+4\tfour\t4\t1\n+5\tfive\t5\t1\ndiff --git a/tests/queries/0_stateless/02381_arrow_dict_to_lc.sh b/tests/queries/0_stateless/02381_arrow_dict_to_lc.sh\nnew file mode 100755\nindex 000000000000..9fb0272eeb07\n--- /dev/null\n+++ b/tests/queries/0_stateless/02381_arrow_dict_to_lc.sh\n@@ -0,0 +1,36 @@\n+#!/usr/bin/env bash\n+# Tags: no-fasttest\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# ## reading ArrowStream file from python\n+# import pyarrow as pa\n+# stream = pa.ipc.open_stream(\"test.arrows\")\n+# x = stream.read_all()\n+# print(x)\n+\n+## writing ArrowStream file from python\n+# import pyarrow as pa\n+#data = [\n+#    pa.array([1, 2, 3, 4, 5]),\n+#    pa.array([\"onee\", \"twoo\", \"three\", \"four\", \"five\"]).dictionary_encode(),\n+#    pa.array([1, 2, 3, 4, 5]).dictionary_encode(),\n+#    pa.array([True, False, True, True, True])\n+#]\n+# batch = pa.record_batch(data, names=['id', 'lc_nullable', 'lc_int_nullable', 'bool_nullable'])\n+# writer = pa.ipc.new_stream(\"test4.arrows\", batch.schema)\n+# writer.write_batch(batch)\n+# writer.close()\n+\n+# cat data.arrow | gzip | base64\n+\n+cat <<EOF | base64 --decode | gunzip | $CLICKHOUSE_LOCAL --query='SELECT * FROM table FORMAT TSVWithNamesAndTypes' --input-format=ArrowStream\n+H4sIAAAAAAAAA5VTsU7DQAz1pZc2giBaFFAGkBgYMjIyMOQD+gHdCqWpiBQlqErhZzowMvIB/Ft4\n+d+drrqGFYsny+fzO9rN1TdM0L4JoSEqOKKQ++RTgBBGSJEwEjLL6DOwn7B37IWIA9tX7a75TcgKd\n+VVUxLVdF8TgrMvgpsGuD9yL4Y2jivDmFFk/TvKzbVwFFUAk1PQpqZaJzkVB153xONS4Gvk8DsBni\n+veEmfFVTxW+cmsemplMv0NGAMV9ODUlmHkPdk8mvPM7vKXvp5Pag+ZyADaEDndP2iLTNh5onY0Oc\n+zORDnZU8qWO3HDcbaeegdhUDKTky5nvfmU+P9kvcsedOTHTyWJG6D7PbEb+pyiyr36qqfl5m2aJa\n+LRf5a8b83g/gl2z4nW32HJO7522e9zt4er/wTJzzLl62js1hZ2Z3aPGKTyxcPhfbfHpS9/2wp+/1\n+jr6DA/pO9tzbPtJOPO3EJ5249d1/JOnnXP7rHzpHi/UYI/+4v2LbmH9I36C0faSwBAAA\n+EOF\n\\ No newline at end of file\n",
  "problem_statement": "Nested type LowCardinality(String) cannot be inside Nullable type: While executing ArrowBlockInputFormat\n```\r\nclickhouse-local -mn --query='SELECT * FROM table' --stacktrace --input-format=ArrowStream < test.arrow\r\n```\r\n\r\n```\r\nCode: 43. DB::Exception: Nested type LowCardinality(String) cannot be inside Nullable type: While executing ArrowBlockInputFormat: While executing File. (ILLEGAL_TYPE_OF_ARGUMENT), Stack trace (when copying this message, always include the lines below):\r\n\r\n0. DB::Exception::Exception(std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, int, bool) @ 0xba2879a in /usr/bin/clickhouse\r\n1. DB::DataTypeNullable::DataTypeNullable(std::__1::shared_ptr<DB::IDataType const> const&) @ 0x160bb75f in /usr/bin/clickhouse\r\n2. std::__1::shared_ptr<DB::DataTypeNullable> std::__1::allocate_shared<DB::DataTypeNullable, std::__1::allocator<DB::DataTypeNullable>, std::__1::shared_ptr<DB::IDataType const>, void>(std::__1::allocator<DB::DataTypeNullable> const&, std::__1::shared_ptr<DB::IDataType const>&&) @ 0x160f56e8 in /usr/bin/clickhouse\r\n3. DB::readColumnFromArrowColumn(std::__1::shared_ptr<arrow::ChunkedArray>&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const&, bool, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::shared_ptr<DB::ColumnWithTypeAndName>, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::shared_ptr<DB::ColumnWithTypeAndName> > > >&, bool, bool, bool, bool&) @ 0x17b9ccbc in /usr/bin/clickhouse\r\n4. DB::ArrowColumnToCHColumn::arrowColumnsToCHChunk(DB::Chunk&, std::__1::unordered_map<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> >, std::__1::shared_ptr<arrow::ChunkedArray>, std::__1::hash<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::equal_to<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > >, std::__1::allocator<std::__1::pair<std::__1::basic_string<char, std::__1::char_traits<char>, std::__1::allocator<char> > const, std::__1::shared_ptr<arrow::ChunkedArray> > > >&) @ 0x17ba15a3 in /usr/bin/clickhouse\r\n5. DB::ArrowColumnToCHColumn::arrowTableToCHChunk(DB::Chunk&, std::__1::shared_ptr<arrow::Table>&) @ 0x17ba0ffc in /usr/bin/clickhouse\r\n6. DB::ArrowBlockInputFormat::generate() @ 0x17b8e270 in /usr/bin/clickhouse\r\n7. DB::ISource::tryGenerate() @ 0x17b60b95 in /usr/bin/clickhouse\r\n8. DB::ISource::work() @ 0x17b606e6 in /usr/bin/clickhouse\r\n9. DB::ExecutionThreadContext::executeTask() @ 0x17b7cf0a in /usr/bin/clickhouse\r\n10. DB::PipelineExecutor::executeStepImpl(unsigned long, std::__1::atomic<bool>*) @ 0x17b71df0 in /usr/bin/clickhouse\r\n11. DB::PipelineExecutor::executeStep(std::__1::atomic<bool>*) @ 0x17b715c0 in /usr/bin/clickhouse\r\n12. DB::PullingPipelineExecutor::pull(DB::Chunk&) @ 0x17b81b43 in /usr/bin/clickhouse\r\n13. DB::StorageFileSource::generate() @ 0x171394d7 in /usr/bin/clickhouse\r\n14. DB::ISource::tryGenerate() @ 0x17b60b95 in /usr/bin/clickhouse\r\n15. DB::ISource::work() @ 0x17b606e6 in /usr/bin/clickhouse\r\n16. DB::ExecutionThreadContext::executeTask() @ 0x17b7cf0a in /usr/bin/clickhouse\r\n17. DB::PipelineExecutor::executeStepImpl(unsigned long, std::__1::atomic<bool>*) @ 0x17b71df0 in /usr/bin/clickhouse\r\n18. DB::PipelineExecutor::executeImpl(unsigned long) @ 0x17b70e64 in /usr/bin/clickhouse\r\n19. DB::PipelineExecutor::execute(unsigned long) @ 0x17b70bfd in /usr/bin/clickhouse\r\n20. void std::__1::__function::__policy_invoker<void ()>::__call_impl<std::__1::__function::__default_alloc_func<ThreadFromGlobalPool::ThreadFromGlobalPool<DB::PullingAsyncPipelineExecutor::pull(DB::Chunk&, unsigned long)::$_0>(DB::PullingAsyncPipelineExecutor::pull(DB::Chunk&, unsigned long)::$_0&&)::'lambda'(), void ()> >(std::__1::__function::__policy_storage const*) @ 0x17b80e13 in /usr/bin/clickhouse\r\n21. ThreadPoolImpl<std::__1::thread>::worker(std::__1::__list_iterator<std::__1::thread, void*>) @ 0xbaf5268 in /usr/bin/clickhouse\r\n22. void* std::__1::__thread_proxy<std::__1::tuple<std::__1::unique_ptr<std::__1::__thread_struct, std::__1::default_delete<std::__1::__thread_struct> >, void ThreadPoolImpl<std::__1::thread>::scheduleImpl<void>(std::__1::function<void ()>, int, std::__1::optional<unsigned long>)::'lambda0'()> >(void*) @ 0xbaf85fd in /usr/bin/clickhouse\r\n23. ? @ 0x7fdefda5d609 in ?\r\n24. clone @ 0x7fdefd982133 in ?\r\n```\r\n\r\n[test.zip](https://github.com/ClickHouse/ClickHouse/files/9196695/test.zip)\nDictionary in Arrow format issue\n```py\r\n## writing ArrowStream file from python\r\nimport pyarrow as pa\r\ndata = [\r\n    pa.array([1, 2, 3, 4, 5]),\r\n    pa.array([\"one\", \"two\", \"three\", \"four\", \"five\"]).dictionary_encode(),\r\n    pa.array([1, 2, 3, 4, 5]).dictionary_encode(),\r\n    pa.array([True, False, True, True, True])\r\n]\r\nbatch = pa.record_batch(data, names=['id', 'lc_nullable', 'lc_int_nullable', 'bool_nullable'])\r\nwriter = pa.ipc.new_stream(\"test4.arrows\", batch.schema)\r\nwriter.write_batch(batch)\r\nwriter.close()\r\n```\r\n\r\n```\r\nclickhouse-local --query='SELECT * FROM table FORMAT TSVWithNamesAndTypes' --stacktrace --input-format=ArrowStream < test4.arrows\r\nid\tlc_nullable\tlc_int_nullable\tbool_nullable\r\nNullable(Int64)\tLowCardinality(Nullable(String))\tLowCardinality(Nullable(Int64))\tNullable(UInt8)\r\n1\t\t0\t1\r\n2\tone\t1\t0\r\n3\ttwo\t2\t1\r\n4\tthree\t3\t1\r\n5\tfour\t4\t1\r\n```\r\n\r\n0 in LowCardianality dictionary in ClickHouse have special meaning (null/default), while in Arrow it's a regular values.\r\n\r\nProbably remapping needed... :|\n",
  "hints_text": "\n",
  "created_at": "2022-08-09T19:14:07Z"
}