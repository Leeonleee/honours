{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68574,
  "instance_id": "ClickHouse__ClickHouse-68574",
  "issue_numbers": [
    "67508"
  ],
  "base_commit": "e78ad9d5e6fc887b5006360de1cf966a08224042",
  "patch": "diff --git a/src/Databases/DatabaseMemory.cpp b/src/Databases/DatabaseMemory.cpp\nindex 2ab09366f784..6159ccb39676 100644\n--- a/src/Databases/DatabaseMemory.cpp\n+++ b/src/Databases/DatabaseMemory.cpp\n@@ -150,7 +150,7 @@ void DatabaseMemory::alterTable(ContextPtr local_context, const StorageID & tabl\n     if (it == create_queries.end() || !it->second)\n         throw Exception(ErrorCodes::UNKNOWN_TABLE, \"Cannot alter: There is no metadata of table {}\", table_id.getNameForLogs());\n \n-    applyMetadataChangesToCreateQuery(it->second, metadata);\n+    applyMetadataChangesToCreateQuery(it->second, metadata, local_context);\n \n     /// The create query of the table has been just changed, we need to update dependencies too.\n     auto ref_dependencies = getDependenciesFromCreateQuery(local_context->getGlobalContext(), table_id.getQualifiedName(), it->second, local_context->getCurrentDatabase());\ndiff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp\nindex 942ba602d922..5adf73514289 100644\n--- a/src/Databases/DatabaseOnDisk.cpp\n+++ b/src/Databases/DatabaseOnDisk.cpp\n@@ -123,7 +123,7 @@ std::pair<String, StoragePtr> createTableFromAST(\n         else\n         {\n             columns = InterpreterCreateQuery::getColumnsDescription(*ast_create_query.columns_list->columns, context, mode);\n-            constraints = InterpreterCreateQuery::getConstraintsDescription(ast_create_query.columns_list->constraints);\n+            constraints = InterpreterCreateQuery::getConstraintsDescription(ast_create_query.columns_list->constraints, columns, context);\n         }\n     }\n \ndiff --git a/src/Databases/DatabaseOrdinary.cpp b/src/Databases/DatabaseOrdinary.cpp\nindex c98f2709116e..02fcdb5aa1a6 100644\n--- a/src/Databases/DatabaseOrdinary.cpp\n+++ b/src/Databases/DatabaseOrdinary.cpp\n@@ -567,7 +567,7 @@ void DatabaseOrdinary::alterTable(ContextPtr local_context, const StorageID & ta\n         local_context->getSettingsRef()[Setting::max_parser_depth],\n         local_context->getSettingsRef()[Setting::max_parser_backtracks]);\n \n-    applyMetadataChangesToCreateQuery(ast, metadata);\n+    applyMetadataChangesToCreateQuery(ast, metadata, local_context);\n \n     statement = getObjectDefinitionFromCreateQuery(ast);\n     {\ndiff --git a/src/Databases/DatabaseReplicated.h b/src/Databases/DatabaseReplicated.h\nindex db683be8f36d..3195de48c1fa 100644\n--- a/src/Databases/DatabaseReplicated.h\n+++ b/src/Databases/DatabaseReplicated.h\n@@ -87,7 +87,7 @@ class DatabaseReplicated : public DatabaseAtomic\n \n     void shutdown() override;\n \n-    std::vector<std::pair<ASTPtr, StoragePtr>> getTablesForBackup(const FilterByNameFunction & filter, const ContextPtr & local_context) const override;\n+    std::vector<std::pair<ASTPtr, StoragePtr>> getTablesForBackup(const FilterByNameFunction & filter, const ContextPtr &) const override;\n     void createTableRestoredFromBackup(const ASTPtr & create_table_query, ContextMutablePtr local_context, std::shared_ptr<IRestoreCoordination> restore_coordination, UInt64 timeout_ms) override;\n \n     bool shouldReplicateQuery(const ContextPtr & query_context, const ASTPtr & query_ptr) const override;\ndiff --git a/src/Databases/DatabasesCommon.cpp b/src/Databases/DatabasesCommon.cpp\nindex 14fc5a9a691f..d26ec9d6eec8 100644\n--- a/src/Databases/DatabasesCommon.cpp\n+++ b/src/Databases/DatabasesCommon.cpp\n@@ -2,15 +2,22 @@\n \n #include <Backups/BackupEntriesCollector.h>\n #include <Backups/RestorerFromBackup.h>\n+#include <Core/Settings.h>\n #include <Interpreters/Context.h>\n #include <Interpreters/DatabaseCatalog.h>\n #include <Interpreters/InterpreterCreateQuery.h>\n+#include <Interpreters/TreeRewriter.h>\n #include <Parsers/ASTCreateQuery.h>\n+#include <Parsers/ASTExpressionList.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/formatAST.h>\n+#include <Parsers/parseQuery.h>\n+#include <Storages/ColumnsDescription.h>\n+#include <Storages/KeyDescription.h>\n #include <Storages/StorageDictionary.h>\n #include <Storages/StorageFactory.h>\n+#include <Storages/TTLDescription.h>\n #include <Storages/Utils.h>\n #include <TableFunctions/TableFunctionFactory.h>\n #include <Common/CurrentMetrics.h>\n@@ -18,10 +25,14 @@\n #include <Common/logger_useful.h>\n #include <Common/typeid_cast.h>\n \n-\n namespace DB\n {\n \n+namespace Setting\n+{\n+    extern const SettingsUInt64 max_parser_backtracks;\n+    extern const SettingsUInt64 max_parser_depth;\n+}\n namespace ErrorCodes\n {\n     extern const int TABLE_ALREADY_EXISTS;\n@@ -31,8 +42,87 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n     extern const int CANNOT_GET_CREATE_TABLE_QUERY;\n }\n+namespace\n+{\n+void validateCreateQuery(const ASTCreateQuery & query, ContextPtr context)\n+{\n+    /// First validate that the query can be parsed\n+    const auto serialized_query = serializeAST(query);\n+    ParserCreateQuery parser;\n+    ASTPtr new_query_raw = parseQuery(\n+        parser,\n+        serialized_query.data(),\n+        serialized_query.data() + serialized_query.size(),\n+        \"after altering table \",\n+        0,\n+        context->getSettingsRef()[Setting::max_parser_backtracks],\n+        context->getSettingsRef()[Setting::max_parser_depth]);\n+    const auto & new_query = new_query_raw->as<const ASTCreateQuery &>();\n+    /// If there are no columns, then there is nothing much we can do\n+    if (!new_query.columns_list || !new_query.columns_list->columns)\n+        return;\n+\n+    const auto & columns = *new_query.columns_list;\n+    /// Do some basic sanity checks. We cannot do the same strict checks as on create, because context might not have the same settings if it is not called directly from an alter query.\n+    /// SECONDARY_CREATE should check most of the important things.\n+    const auto columns_desc\n+        = InterpreterCreateQuery::getColumnsDescription(*columns.columns, context, LoadingStrictnessLevel::SECONDARY_CREATE, false);\n+\n+    /// Default expressions are only validated in level CREATE, so let's check them now\n+    DefaultExpressionsInfo default_expr_info{std::make_shared<ASTExpressionList>()};\n+\n+    for (const auto & ast : columns.columns->children)\n+    {\n+        const auto & col_decl = ast->as<ASTColumnDeclaration &>();\n+        /// There might be some special columns for which `columns_desc.get` would throw, e.g. Nested column when flatten_nested is enabled.\n+        /// At the time of writing I am not aware of anything else, but my knowledge is limited and new types might be added, so let's be safe.\n+        if (!col_decl.default_expression)\n+            continue;\n+\n+        /// If no column description for the name, let's skip the validation of default expressions, but let's log the fact that something went wrong\n+        if (const auto * maybe_column_desc = columns_desc.tryGet(col_decl.name); maybe_column_desc)\n+            getDefaultExpressionInfoInto(col_decl, maybe_column_desc->type, default_expr_info);\n+        else\n+            LOG_WARNING(getLogger(\"validateCreateQuery\"), \"Couldn't get column description for column {}\", col_decl.name);\n+    }\n+\n+    if (default_expr_info.expr_list)\n+        validateColumnsDefaultsAndGetSampleBlock(default_expr_info.expr_list, columns_desc.getAll(), context);\n \n-void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemoryMetadata & metadata)\n+    if (columns.indices)\n+    {\n+        for (const auto & child : columns.indices->children)\n+            IndexDescription::getIndexFromAST(child, columns_desc, context);\n+    }\n+    if (columns.constraints)\n+    {\n+        InterpreterCreateQuery::getConstraintsDescription(columns.constraints, columns_desc, context);\n+    }\n+    if (columns.projections)\n+    {\n+        for (const auto & child : columns.projections->children)\n+            ProjectionDescription::getProjectionFromAST(child, columns_desc, context);\n+    }\n+    if (!new_query.storage)\n+        return;\n+    const auto & storage = *new_query.storage;\n+\n+    std::optional<KeyDescription> primary_key;\n+    /// First get the key description from order by, so if there is no primary key we will use that\n+    if (storage.order_by)\n+        primary_key = KeyDescription::getKeyFromAST(storage.order_by->ptr(), columns_desc, context);\n+    if (storage.primary_key)\n+        primary_key = KeyDescription::getKeyFromAST(storage.primary_key->ptr(), columns_desc, context);\n+    if (storage.partition_by)\n+        KeyDescription::getKeyFromAST(storage.partition_by->ptr(), columns_desc, context);\n+    if (storage.sample_by)\n+        KeyDescription::getKeyFromAST(storage.sample_by->ptr(), columns_desc, context);\n+    if (storage.ttl_table && primary_key.has_value())\n+        TTLTableDescription::getTTLForTableFromAST(storage.ttl_table->ptr(), columns_desc, context, *primary_key, true);\n+}\n+}\n+\n+void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemoryMetadata & metadata, ContextPtr context)\n {\n     auto & ast_create_query = query->as<ASTCreateQuery &>();\n \n@@ -115,6 +205,8 @@ void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemo\n         ast_create_query.reset(ast_create_query.comment);\n     else\n         ast_create_query.set(ast_create_query.comment, std::make_shared<ASTLiteral>(metadata.comment));\n+\n+    validateCreateQuery(ast_create_query, context);\n }\n \n \ndiff --git a/src/Databases/DatabasesCommon.h b/src/Databases/DatabasesCommon.h\nindex c27479571ef1..b71881bf1c16 100644\n--- a/src/Databases/DatabasesCommon.h\n+++ b/src/Databases/DatabasesCommon.h\n@@ -1,10 +1,9 @@\n #pragma once\n \n-#include <base/types.h>\n+#include <Databases/IDatabase.h>\n #include <Parsers/IAST_fwd.h>\n #include <Storages/IStorage_fwd.h>\n-#include <Databases/IDatabase.h>\n-#include <mutex>\n+#include <base/types.h>\n \n \n /// General functionality for several different database engines.\n@@ -12,15 +11,13 @@\n namespace DB\n {\n \n-void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemoryMetadata & metadata);\n+void applyMetadataChangesToCreateQuery(const ASTPtr & query, const StorageInMemoryMetadata & metadata, ContextPtr context);\n ASTPtr getCreateQueryFromStorage(const StoragePtr & storage, const ASTPtr & ast_storage, bool only_ordinary,\n     uint32_t max_parser_depth, uint32_t max_parser_backtracks, bool throw_on_error);\n \n /// Cleans a CREATE QUERY from temporary flags like \"IF NOT EXISTS\", \"OR REPLACE\", \"AS SELECT\" (for non-views), etc.\n void cleanupObjectDefinitionFromTemporaryFlags(ASTCreateQuery & query);\n \n-class Context;\n-\n /// A base class for databases that manage their own list of tables.\n class DatabaseWithOwnTablesBase : public IDatabase, protected WithContext\n {\ndiff --git a/src/Interpreters/InterpreterCreateQuery.cpp b/src/Interpreters/InterpreterCreateQuery.cpp\nindex e1784842cb93..647a1ba098eb 100644\n--- a/src/Interpreters/InterpreterCreateQuery.cpp\n+++ b/src/Interpreters/InterpreterCreateQuery.cpp\n@@ -575,6 +575,47 @@ ASTPtr InterpreterCreateQuery::formatProjections(const ProjectionsDescription &\n     return res;\n }\n \n+DataTypePtr InterpreterCreateQuery::getColumnType(\n+    const ASTColumnDeclaration & col_decl, const LoadingStrictnessLevel mode, const bool make_columns_nullable)\n+{\n+    if (!col_decl.type)\n+    {\n+        /// we're creating dummy DataTypeUInt8 in order to prevent the NullPointerException in ExpressionActions\n+        return std::make_shared<DataTypeUInt8>();\n+    }\n+\n+    DataTypePtr column_type = DataTypeFactory::instance().get(col_decl.type);\n+\n+    if (LoadingStrictnessLevel::ATTACH <= mode)\n+        setVersionToAggregateFunctions(column_type, true);\n+\n+    if (col_decl.null_modifier)\n+    {\n+        if (column_type->isNullable())\n+            throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_DATA_TYPE, \"Can't use [NOT] NULL modifier with Nullable type\");\n+        if (*col_decl.null_modifier)\n+            column_type = makeNullable(column_type);\n+    }\n+    else if (make_columns_nullable)\n+    {\n+        column_type = makeNullable(column_type);\n+    }\n+    else if (\n+        !hasNullable(column_type) && col_decl.default_specifier == \"DEFAULT\" && col_decl.default_expression\n+        && col_decl.default_expression->as<ASTLiteral>() && col_decl.default_expression->as<ASTLiteral>()->value.isNull())\n+    {\n+        if (column_type->lowCardinality())\n+        {\n+            const auto * low_cardinality_type = typeid_cast<const DataTypeLowCardinality *>(column_type.get());\n+            assert(low_cardinality_type);\n+            column_type = std::make_shared<DataTypeLowCardinality>(makeNullable(low_cardinality_type->getDictionaryType()));\n+        }\n+        else\n+            column_type = makeNullable(column_type);\n+    }\n+    return column_type;\n+}\n+\n ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n     const ASTExpressionList & columns_ast, ContextPtr context_, LoadingStrictnessLevel mode, bool is_restore_from_backup)\n {\n@@ -583,11 +624,10 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n     /** all default_expressions as a single expression list,\n      *  mixed with conversion-columns for each explicitly specified type */\n \n-    ASTPtr default_expr_list = std::make_shared<ASTExpressionList>();\n+    DefaultExpressionsInfo default_expr_info{std::make_shared<ASTExpressionList>()};\n     NamesAndTypesList column_names_and_types;\n     bool make_columns_nullable = mode <= LoadingStrictnessLevel::SECONDARY_CREATE && !is_restore_from_backup\n         && context_->getSettingsRef()[Setting::data_type_default_nullable];\n-    bool has_columns_with_default_without_type = false;\n \n     for (const auto & ast : columns_ast.children)\n     {\n@@ -595,78 +635,15 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n \n         if (col_decl.collation && !context_->getSettingsRef()[Setting::compatibility_ignore_collation_in_create_table])\n         {\n-            throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot support collation, please set compatibility_ignore_collation_in_create_table=true\");\n+            throw Exception(\n+                ErrorCodes::NOT_IMPLEMENTED, \"Cannot support collation, please set compatibility_ignore_collation_in_create_table=true\");\n         }\n \n-        DataTypePtr column_type = nullptr;\n-        if (col_decl.type)\n-        {\n-            column_type = DataTypeFactory::instance().get(col_decl.type);\n \n-            if (LoadingStrictnessLevel::ATTACH <= mode)\n-                setVersionToAggregateFunctions(column_type, true);\n-\n-            if (col_decl.null_modifier)\n-            {\n-                if (column_type->isNullable())\n-                    throw Exception(ErrorCodes::ILLEGAL_SYNTAX_FOR_DATA_TYPE, \"Can't use [NOT] NULL modifier with Nullable type\");\n-                if (*col_decl.null_modifier)\n-                    column_type = makeNullable(column_type);\n-            }\n-            else if (make_columns_nullable)\n-            {\n-                column_type = makeNullable(column_type);\n-            }\n-            else if (!hasNullable(column_type) &&\n-                     col_decl.default_specifier == \"DEFAULT\" &&\n-                     col_decl.default_expression &&\n-                     col_decl.default_expression->as<ASTLiteral>() &&\n-                     col_decl.default_expression->as<ASTLiteral>()->value.isNull())\n-            {\n-                if (column_type->lowCardinality())\n-                {\n-                    const auto * low_cardinality_type = typeid_cast<const DataTypeLowCardinality *>(column_type.get());\n-                    assert(low_cardinality_type);\n-                    column_type = std::make_shared<DataTypeLowCardinality>(makeNullable(low_cardinality_type->getDictionaryType()));\n-                }\n-                else\n-                    column_type = makeNullable(column_type);\n-            }\n-\n-            column_names_and_types.emplace_back(col_decl.name, column_type);\n-        }\n-        else\n-        {\n-            /// we're creating dummy DataTypeUInt8 in order to prevent the NullPointerException in ExpressionActions\n-            column_names_and_types.emplace_back(col_decl.name, std::make_shared<DataTypeUInt8>());\n-        }\n+        column_names_and_types.emplace_back(col_decl.name, getColumnType(col_decl, mode, make_columns_nullable));\n \n         /// add column to postprocessing if there is a default_expression specified\n-        if (col_decl.default_expression)\n-        {\n-            /** For columns with explicitly-specified type create two expressions:\n-              * 1. default_expression aliased as column name with _tmp suffix\n-              * 2. conversion of expression (1) to explicitly-specified type alias as column name\n-              */\n-            if (col_decl.type)\n-            {\n-                const auto & final_column_name = col_decl.name;\n-                const auto tmp_column_name = final_column_name + \"_tmp_alter\" + toString(randomSeed());\n-                const auto * data_type_ptr = column_names_and_types.back().type.get();\n-\n-                default_expr_list->children.emplace_back(\n-                    setAlias(addTypeConversionToAST(std::make_shared<ASTIdentifier>(tmp_column_name), data_type_ptr->getName()),\n-                        final_column_name));\n-\n-                default_expr_list->children.emplace_back(\n-                    setAlias(col_decl.default_expression->clone(), tmp_column_name));\n-            }\n-            else\n-            {\n-                has_columns_with_default_without_type = true;\n-                default_expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), col_decl.name));\n-            }\n-        }\n+        getDefaultExpressionInfoInto(col_decl, column_names_and_types.back().type, default_expr_info);\n     }\n \n     Block defaults_sample_block;\n@@ -674,9 +651,10 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n     /// We try to avoid that validation while restoring from a backup because it might be slow or troublesome\n     /// (for example, a default expression can contain dictGet() and that dictionary can access remote servers or\n     /// require different users to authenticate).\n-    if (!default_expr_list->children.empty() && (has_columns_with_default_without_type || (mode <= LoadingStrictnessLevel::CREATE)))\n+    if (!default_expr_info.expr_list->children.empty()\n+        && (default_expr_info.has_columns_with_default_without_type || (mode <= LoadingStrictnessLevel::CREATE)))\n     {\n-        defaults_sample_block = validateColumnsDefaultsAndGetSampleBlock(default_expr_list, column_names_and_types, context_);\n+        defaults_sample_block = validateColumnsDefaultsAndGetSampleBlock(default_expr_info.expr_list, column_names_and_types, context_);\n     }\n \n     bool skip_checks = LoadingStrictnessLevel::SECONDARY_CREATE <= mode;\n@@ -778,13 +756,18 @@ ColumnsDescription InterpreterCreateQuery::getColumnsDescription(\n }\n \n \n-ConstraintsDescription InterpreterCreateQuery::getConstraintsDescription(const ASTExpressionList * constraints)\n+ConstraintsDescription InterpreterCreateQuery::getConstraintsDescription(\n+    const ASTExpressionList * constraints, const ColumnsDescription & columns, ContextPtr local_context)\n {\n     ASTs constraints_data;\n+    const auto column_names_and_types = columns.getAllPhysical();\n     if (constraints)\n         for (const auto & constraint : constraints->children)\n+        {\n+            auto clone = constraint->clone();\n+            TreeRewriter(local_context).analyze(clone, column_names_and_types);\n             constraints_data.push_back(constraint->clone());\n-\n+        }\n     return ConstraintsDescription{constraints_data};\n }\n \n@@ -847,7 +830,7 @@ InterpreterCreateQuery::TableProperties InterpreterCreateQuery::getTableProperti\n                 properties.projections.add(std::move(projection));\n             }\n \n-        properties.constraints = getConstraintsDescription(create.columns_list->constraints);\n+        properties.constraints = getConstraintsDescription(create.columns_list->constraints, properties.columns, getContext());\n     }\n     else if (!create.as_table.empty())\n     {\ndiff --git a/src/Interpreters/InterpreterCreateQuery.h b/src/Interpreters/InterpreterCreateQuery.h\nindex 5047c372c716..25ff32a09d3a 100644\n--- a/src/Interpreters/InterpreterCreateQuery.h\n+++ b/src/Interpreters/InterpreterCreateQuery.h\n@@ -14,6 +14,7 @@ namespace DB\n {\n \n class ASTCreateQuery;\n+class ASTColumnDeclaration;\n class ASTExpressionList;\n class ASTConstraintDeclaration;\n class ASTStorage;\n@@ -71,10 +72,13 @@ class InterpreterCreateQuery : public IInterpreter, WithMutableContext\n         is_restore_from_backup = is_restore_from_backup_;\n     }\n \n+    static DataTypePtr getColumnType(const ASTColumnDeclaration & col_decl, LoadingStrictnessLevel mode, bool make_columns_nullable);\n+\n     /// Obtain information about columns, their types, default values and column comments,\n     ///  for case when columns in CREATE query is specified explicitly.\n     static ColumnsDescription getColumnsDescription(const ASTExpressionList & columns, ContextPtr context, LoadingStrictnessLevel mode, bool is_restore_from_backup = false);\n-    static ConstraintsDescription getConstraintsDescription(const ASTExpressionList * constraints);\n+    static ConstraintsDescription\n+    getConstraintsDescription(const ASTExpressionList * constraints, const ColumnsDescription & columns, ContextPtr local_context);\n \n     static void prepareOnClusterQuery(ASTCreateQuery & create, ContextPtr context, const String & cluster_name);\n \ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 6ff608c1841a..459f854978c5 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -889,7 +889,7 @@ StoragePtr InterpreterSystemQuery::tryRestartReplica(const StorageID & replica,\n     create.attach = true;\n \n     auto columns = InterpreterCreateQuery::getColumnsDescription(*create.columns_list->columns, system_context, LoadingStrictnessLevel::ATTACH);\n-    auto constraints = InterpreterCreateQuery::getConstraintsDescription(create.columns_list->constraints);\n+    auto constraints = InterpreterCreateQuery::getConstraintsDescription(create.columns_list->constraints, columns, system_context);\n     auto data_path = database->getTableDataPath(create);\n \n     table = StorageFactory::instance().get(create,\ndiff --git a/src/Storages/ColumnsDescription.cpp b/src/Storages/ColumnsDescription.cpp\nindex 0d0689618ebf..3922f1cfcfb2 100644\n--- a/src/Storages/ColumnsDescription.cpp\n+++ b/src/Storages/ColumnsDescription.cpp\n@@ -1,36 +1,42 @@\n #include <Storages/ColumnsDescription.h>\n \n+#include <memory>\n+#include <Compression/CompressionFactory.h>\n+#include <Core/Defines.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypeNested.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/NestedUtils.h>\n+#include <IO/ReadBuffer.h>\n+#include <IO/ReadBufferFromString.h>\n+#include <IO/ReadHelpers.h>\n+#include <IO/WriteBuffer.h>\n+#include <IO/WriteBufferFromString.h>\n+#include <IO/WriteHelpers.h>\n+#include <Interpreters/Context.h>\n+#include <Interpreters/ExpressionActions.h>\n+#include <Interpreters/ExpressionAnalyzer.h>\n+#include <Interpreters/FunctionNameNormalizer.h>\n+#include <Interpreters/TreeRewriter.h>\n+#include <Interpreters/addTypeConversionToAST.h>\n+#include <Parsers/ASTColumnDeclaration.h>\n+#include <Parsers/ASTExpressionList.h>\n+#include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTLiteral.h>\n+#include <Parsers/ASTSelectQuery.h>\n+#include <Parsers/ASTSelectWithUnionQuery.h>\n+#include <Parsers/ASTSetQuery.h>\n+#include <Parsers/ASTSubquery.h>\n #include <Parsers/ExpressionElementParsers.h>\n #include <Parsers/ExpressionListParsers.h>\n #include <Parsers/ParserCreateQuery.h>\n #include <Parsers/parseQuery.h>\n #include <Parsers/queryToString.h>\n-#include <Parsers/ASTSubquery.h>\n-#include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ASTSelectWithUnionQuery.h>\n-#include <Parsers/ASTSetQuery.h>\n-#include <IO/WriteBuffer.h>\n-#include <IO/WriteHelpers.h>\n-#include <IO/ReadBuffer.h>\n-#include <IO/ReadHelpers.h>\n-#include <IO/WriteBufferFromString.h>\n-#include <IO/ReadBufferFromString.h>\n-#include <DataTypes/DataTypeFactory.h>\n-#include <DataTypes/NestedUtils.h>\n-#include <DataTypes/DataTypeArray.h>\n-#include <DataTypes/DataTypeTuple.h>\n-#include <DataTypes/DataTypeNested.h>\n-#include <Common/Exception.h>\n-#include <Interpreters/Context.h>\n #include <Storages/IStorage.h>\n+#include <Common/Exception.h>\n+#include <Common/randomSeed.h>\n #include <Common/typeid_cast.h>\n-#include <Core/Defines.h>\n-#include <Compression/CompressionFactory.h>\n-#include <Interpreters/ExpressionAnalyzer.h>\n-#include <Interpreters/TreeRewriter.h>\n-#include <Interpreters/ExpressionActions.h>\n-#include <Interpreters/FunctionNameNormalizer.h>\n \n \n namespace DB\n@@ -970,7 +976,36 @@ std::vector<String> ColumnsDescription::getAllRegisteredNames() const\n     return names;\n }\n \n-Block validateColumnsDefaultsAndGetSampleBlock(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context)\n+void getDefaultExpressionInfoInto(const ASTColumnDeclaration & col_decl, const DataTypePtr & data_type, DefaultExpressionsInfo & info)\n+{\n+    if (!col_decl.default_expression)\n+        return;\n+\n+    /** For columns with explicitly-specified type create two expressions:\n+    * 1. default_expression aliased as column name with _tmp suffix\n+    * 2. conversion of expression (1) to explicitly-specified type alias as column name\n+    */\n+    if (col_decl.type)\n+    {\n+        const auto & final_column_name = col_decl.name;\n+        const auto tmp_column_name = final_column_name + \"_tmp_alter\" + toString(randomSeed());\n+        const auto * data_type_ptr = data_type.get();\n+\n+        info.expr_list->children.emplace_back(setAlias(\n+            addTypeConversionToAST(std::make_shared<ASTIdentifier>(tmp_column_name), data_type_ptr->getName()), final_column_name));\n+\n+        info.expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), tmp_column_name));\n+    }\n+    else\n+    {\n+        info.has_columns_with_default_without_type = true;\n+        info.expr_list->children.emplace_back(setAlias(col_decl.default_expression->clone(), col_decl.name));\n+    }\n+}\n+\n+namespace\n+{\n+std::optional<Block> validateColumnsDefaultsAndGetSampleBlockImpl(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context, bool get_sample_block)\n {\n     for (const auto & child : default_expr_list->children)\n         if (child->as<ASTSelectQuery>() || child->as<ASTSelectWithUnionQuery>() || child->as<ASTSubquery>())\n@@ -984,6 +1019,9 @@ Block validateColumnsDefaultsAndGetSampleBlock(ASTPtr default_expr_list, const N\n             if (action.node->type == ActionsDAG::ActionType::ARRAY_JOIN)\n                 throw Exception(ErrorCodes::THERE_IS_NO_DEFAULT_VALUE, \"Unsupported default value that requires ARRAY JOIN action\");\n \n+        if (!get_sample_block)\n+            return {};\n+\n         return actions->getSampleBlock();\n     }\n     catch (Exception & ex)\n@@ -992,5 +1030,19 @@ Block validateColumnsDefaultsAndGetSampleBlock(ASTPtr default_expr_list, const N\n         throw;\n     }\n }\n+}\n+\n+void validateColumnsDefaults(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context)\n+{\n+    /// Do not execute the default expressions as they might be heavy, e.g.: access remote servers, etc.\n+    validateColumnsDefaultsAndGetSampleBlockImpl(default_expr_list, all_columns, context, /*get_sample_block=*/false);\n+}\n+\n+Block validateColumnsDefaultsAndGetSampleBlock(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context)\n+{\n+    auto result = validateColumnsDefaultsAndGetSampleBlockImpl(default_expr_list, all_columns, context, /*get_sample_block=*/true);\n+    chassert(result.has_value());\n+    return std::move(*result);\n+}\n \n }\ndiff --git a/src/Storages/ColumnsDescription.h b/src/Storages/ColumnsDescription.h\nindex c89c26501e8a..27496da543a6 100644\n--- a/src/Storages/ColumnsDescription.h\n+++ b/src/Storages/ColumnsDescription.h\n@@ -268,10 +268,21 @@ class ColumnsDescription : public IHints<>\n     void removeSubcolumns(const String & name_in_storage);\n };\n \n+class ASTColumnDeclaration;\n+\n+struct DefaultExpressionsInfo\n+{\n+    ASTPtr expr_list = nullptr;\n+    bool has_columns_with_default_without_type = false;\n+};\n+\n+void getDefaultExpressionInfoInto(const ASTColumnDeclaration & col_decl, const DataTypePtr & data_type, DefaultExpressionsInfo & info);\n+\n /// Validate default expressions and corresponding types compatibility, i.e.\n /// default expression result can be casted to column_type. Also checks, that we\n /// don't have strange constructions in default expression like SELECT query or\n /// arrayJoin function.\n+void validateColumnsDefaults(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context);\n Block validateColumnsDefaultsAndGetSampleBlock(ASTPtr default_expr_list, const NamesAndTypesList & all_columns, ContextPtr context);\n \n }\ndiff --git a/src/Storages/StorageMergeTree.cpp b/src/Storages/StorageMergeTree.cpp\nindex f76a0b569862..14b82cde3863 100644\n--- a/src/Storages/StorageMergeTree.cpp\n+++ b/src/Storages/StorageMergeTree.cpp\n@@ -378,11 +378,13 @@ void StorageMergeTree::alter(\n     if (commands.isSettingsAlter())\n     {\n         changeSettings(new_metadata.settings_changes, table_lock_holder);\n+        /// It is safe to ignore exceptions here as only settings are changed, which is not validated in `alterTable`\n         DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n     }\n     else if (commands.isCommentAlter())\n     {\n         setInMemoryMetadata(new_metadata);\n+        /// It is safe to ignore exceptions here as only the comment changed, which is not validated in `alterTable`\n         DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n     }\n     else\n@@ -413,7 +415,17 @@ void StorageMergeTree::alter(\n             /// Reinitialize primary key because primary key column types might have changed.\n             setProperties(new_metadata, old_metadata, false, local_context);\n \n-            DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n+            try\n+            {\n+                DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n+            }\n+            catch (...)\n+            {\n+                LOG_ERROR(log, \"Failed to alter table in database, reverting changes\");\n+                changeSettings(old_metadata.settings_changes, table_lock_holder);\n+                setProperties(old_metadata, new_metadata, false, local_context);\n+                throw;\n+            }\n \n             {\n                 /// Reset Object columns, because column of type\ndiff --git a/src/Storages/StorageReplicatedMergeTree.cpp b/src/Storages/StorageReplicatedMergeTree.cpp\nindex e8bde2f4ec1b..de1ecb43bb1c 100644\n--- a/src/Storages/StorageReplicatedMergeTree.cpp\n+++ b/src/Storages/StorageReplicatedMergeTree.cpp\n@@ -1564,7 +1564,16 @@ void StorageReplicatedMergeTree::setTableStructure(const StorageID & table_id, c\n     checkTTLExpressions(new_metadata, old_metadata);\n     setProperties(new_metadata, old_metadata);\n \n-    DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n+    try\n+    {\n+        DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(local_context, table_id, new_metadata);\n+    }\n+    catch (...)\n+    {\n+        LOG_ERROR(log, \"Failed to set table structure, reverting changes\");\n+        setProperties(old_metadata, new_metadata);\n+        throw;\n+    }\n }\n \n \n@@ -6160,40 +6169,42 @@ void StorageReplicatedMergeTree::alter(\n     auto table_id = getStorageID();\n     const auto & query_settings = query_context->getSettingsRef();\n \n+    StorageInMemoryMetadata future_metadata = getInMemoryMetadata();\n+    commands.apply(future_metadata, query_context);\n+\n     if (commands.isSettingsAlter())\n     {\n         /// We don't replicate storage_settings_ptr ALTER. It's local operation.\n         /// Also we don't upgrade alter lock to table structure lock.\n-        StorageInMemoryMetadata future_metadata = getInMemoryMetadata();\n-        commands.apply(future_metadata, query_context);\n-\n         merge_strategy_picker.refreshState();\n \n         changeSettings(future_metadata.settings_changes, table_lock_holder);\n \n+        /// It is safe to ignore exceptions here as only settings are changed, which is not validated in `alterTable`\n         DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(query_context, table_id, future_metadata);\n         return;\n     }\n \n     if (commands.isCommentAlter())\n     {\n-        StorageInMemoryMetadata future_metadata = getInMemoryMetadata();\n-        commands.apply(future_metadata, query_context);\n-\n         setInMemoryMetadata(future_metadata);\n \n+        /// It is safe to ignore exceptions here as only the comment is changed, which is not validated in `alterTable`\n         DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(query_context, table_id, future_metadata);\n         return;\n     }\n \n     if (!query_settings[Setting::allow_suspicious_primary_key])\n     {\n-        StorageInMemoryMetadata future_metadata = getInMemoryMetadata();\n-        commands.apply(future_metadata, query_context);\n-\n         MergeTreeData::verifySortingKey(future_metadata.sorting_key);\n     }\n \n+    {\n+        /// Call applyMetadataChangesToCreateQuery to validate the resulting CREATE query\n+        auto ast = DatabaseCatalog::instance().getDatabase(table_id.database_name)->getCreateTableQuery(table_id.table_name, query_context);\n+        applyMetadataChangesToCreateQuery(ast, future_metadata, query_context);\n+    }\n+\n     auto ast_to_str = [](ASTPtr query) -> String\n     {\n         if (!query)\n@@ -6239,9 +6250,6 @@ void StorageReplicatedMergeTree::alter(\n \n         auto current_metadata = getInMemoryMetadataPtr();\n \n-        StorageInMemoryMetadata future_metadata = *current_metadata;\n-        commands.apply(future_metadata, query_context);\n-\n         ReplicatedMergeTreeTableMetadata future_metadata_in_zk(*this, current_metadata);\n         if (ast_to_str(future_metadata.sorting_key.definition_ast) != ast_to_str(current_metadata->sorting_key.definition_ast))\n         {\n@@ -6309,6 +6317,8 @@ void StorageReplicatedMergeTree::alter(\n                 setInMemoryMetadata(metadata_copy);\n             }\n \n+            /// Only the comment and/or settings changed here, so it is okay to assume alterTable won't throw as neither\n+            /// of them are validated in alterTable.\n             DatabaseCatalog::instance().getDatabase(table_id.database_name)->alterTable(query_context, table_id, metadata_copy);\n         }\n \n@@ -6378,7 +6388,7 @@ void StorageReplicatedMergeTree::alter(\n             /// so we have to update metadata of DatabaseReplicated here.\n             String metadata_zk_path = fs::path(txn->getDatabaseZooKeeperPath()) / \"metadata\" / escapeForFileName(table_id.table_name);\n             auto ast = DatabaseCatalog::instance().getDatabase(table_id.database_name)->getCreateTableQuery(table_id.table_name, query_context);\n-            applyMetadataChangesToCreateQuery(ast, future_metadata);\n+            applyMetadataChangesToCreateQuery(ast, future_metadata, query_context);\n             ops.emplace_back(zkutil::makeSetRequest(metadata_zk_path, getObjectDefinitionFromCreateQuery(ast), -1));\n         }\n \n@@ -10592,7 +10602,7 @@ void StorageReplicatedMergeTree::adjustCreateQueryForBackup(ASTPtr & create_quer\n         auto current_metadata = getInMemoryMetadataPtr();\n         auto metadata_diff = ReplicatedMergeTreeTableMetadata(*this, current_metadata).checkAndFindDiff(metadata_from_entry, current_metadata->getColumns(), getContext());\n         auto adjusted_metadata = metadata_diff.getNewMetadata(columns_from_entry, getContext(), *current_metadata);\n-        applyMetadataChangesToCreateQuery(create_query, adjusted_metadata);\n+        applyMetadataChangesToCreateQuery(create_query, adjusted_metadata, getContext());\n     }\n     catch (...)\n     {\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00515_enhanced_time_zones.sql b/tests/queries/0_stateless/00515_enhanced_time_zones.sql\nindex f7eb90fa5c8c..c5cafdbb53b1 100644\n--- a/tests/queries/0_stateless/00515_enhanced_time_zones.sql\n+++ b/tests/queries/0_stateless/00515_enhanced_time_zones.sql\n@@ -40,7 +40,7 @@ SELECT val FROM tab WHERE nowInBlock(tz) != toDateTime('2000-01-01 00:00:00') OR\n SELECT val FROM tab WHERE nowInBlock(tz) != toDateTime('2000-01-01 00:00:00') ORDER BY val SETTINGS allow_nonconst_timezone_arguments = 1;\n \n SELECT val FROM tab WHERE toTimeZone(toDateTime(val), tz) != toDateTime('2023-06-11 14:14:14') ORDER BY val SETTINGS allow_nonconst_timezone_arguments = 0; -- { serverError ILLEGAL_COLUMN }\n-SELECT val FROM tab WHERE toTimeZone(toDateTime(val), tz) != toDateTime('2023-06-11 14:14:14') ORDER BY val SETTINGS allow_nonconst_timezone_arguments = 1; \n+SELECT val FROM tab WHERE toTimeZone(toDateTime(val), tz) != toDateTime('2023-06-11 14:14:14') ORDER BY val SETTINGS allow_nonconst_timezone_arguments = 1;\n \n SELECT val FROM tab WHERE fromUnixTimestamp64Milli(val, tz) != toDateTime64('2023-06-11 14:14:14', 6) ORDER BY val SETTINGS allow_nonconst_timezone_arguments = 0; -- { serverError ILLEGAL_COLUMN }\n SELECT val FROM tab WHERE fromUnixTimestamp64Milli(val, tz) != toDateTime64('2023-06-11 14:14:14', 6) ORDER BY val SETTINGS allow_nonconst_timezone_arguments = 1;\n@@ -72,5 +72,5 @@ SET allow_nonconst_timezone_arguments = 0;\n ATTACH TABLE tab;\n DROP TABLE tab;\n \n--- CREATE TABLE does check the default expessions, so the following is expected to fail:\n+-- CREATE TABLE does check the default expressions, so the following is expected to fail:\n CREATE TABLE tab (`country` LowCardinality(FixedString(7)) DEFAULT 'unknown', `city` LowCardinality(String) DEFAULT 'unknown', `region` LowCardinality(String) DEFAULT 'unknown', `continent` LowCardinality(FixedString(7)) DEFAULT 'unknown', `is_eu_country` Bool, `date` DateTime CODEC(DoubleDelta, LZ4), `viewer_date` DateTime ALIAS toTimezone(date, timezone), `device_browser` LowCardinality(String) DEFAULT 'unknown', `metro_code` LowCardinality(String) DEFAULT 'unknown', `domain` String DEFAULT 'unknown', `device_platform` LowCardinality(String) DEFAULT 'unknown', `device_type` LowCardinality(String) DEFAULT 'unknown', `device_vendor` LowCardinality(String) DEFAULT 'unknown', `ip` FixedString(39) DEFAULT 'unknown', `lat` Decimal(8, 6) CODEC(T64), `lng` Decimal(9, 6) CODEC(T64), `asset_id` String DEFAULT 'unknown', `is_personalized` Bool, `metric` String, `origin` String DEFAULT 'unknown', `product_id` UInt64 CODEC(T64), `referer` String DEFAULT 'unknown', `server_side` Int8 CODEC(T64), `third_party_id` String DEFAULT 'unknown', `partner_slug` LowCardinality(FixedString(10)) DEFAULT 'unknown', `user_agent` String DEFAULT 'unknown', `user_id` UUID, `zip` FixedString(10) DEFAULT 'unknown', `timezone` LowCardinality(String), `as_organization` LowCardinality(String) DEFAULT 'unknown', `content_cat` Array(String), `playback_method` LowCardinality(String) DEFAULT 'unknown', `store_id` LowCardinality(String) DEFAULT 'unknown', `store_url` String DEFAULT 'unknown', `timestamp` Nullable(DateTime), `ad_count` Int8 CODEC(T64), `ad_type` LowCardinality(FixedString(10)) DEFAULT 'unknown', `ad_categories` Array(FixedString(8)), `blocked_ad_categories` Array(FixedString(8)), `break_max_ad_length` Int8 CODEC(T64), `break_max_ads` Int8 CODEC(T64), `break_max_duration` Int8 CODEC(T64), `break_min_ad_length` Int8 CODEC(T64), `break_position` LowCardinality(FixedString(18)) DEFAULT 'unknown', `media_playhead` String DEFAULT 'unknown', `placement_type` Int8 CODEC(T64), `transaction_id` String, `universal_ad_id` Array(String), `client_ua` LowCardinality(String) DEFAULT 'unknown', `device_ip` FixedString(39) DEFAULT 'unknown', `device_ua` LowCardinality(String) DEFAULT 'unknown', `ifa` String, `ifa_type` LowCardinality(String) DEFAULT 'unknown', `vast_lat` Decimal(8, 6) CODEC(T64), `vast_long` Decimal(9, 6) CODEC(T64), `server_ua` String DEFAULT 'unknown', `app_bundle` String DEFAULT 'unknown', `page_url` String DEFAULT 'unknown', `api_framework` Array(UInt8), `click_type` LowCardinality(String), `extensions` Array(String), `media_mime` Array(String), `om_id_partner` LowCardinality(String) DEFAULT 'unknown', `player_capabilities` Array(FixedString(12)), `vast_versions` Array(UInt8), `verification_vendors` Array(String), `ad_play_head` String DEFAULT 'unknown', `ad_serving_id` String DEFAULT 'unknown', `asset_uri` String DEFAULT 'unknown', `content_id` String DEFAULT 'unknown', `content_uri` String DEFAULT 'unknown', `inventory_state` Array(FixedString(14)), `player_size` Array(UInt8), `player_state` Array(FixedString(12)), `pod_sequence` Int8 CODEC(T64), `click_position` Array(UInt32), `error_code` Int16 CODEC(T64), `error_reason` Int8 CODEC(T64), `gdpr_consent` String DEFAULT 'unknown', `limited_tracking` Bool, `regulations` String DEFAULT 'unknown', `content_category` Array(String), PROJECTION projection_TPAG_VAST_date (SELECT * ORDER BY toYYYYMMDD(date), metric, product_id, asset_id)) ENGINE = MergeTree ORDER BY (product_id, metric, asset_id, toYYYYMMDD(date)); -- { serverError ILLEGAL_COLUMN }\ndiff --git a/tests/queries/0_stateless/03224_invalid_alter.reference b/tests/queries/0_stateless/03224_invalid_alter.reference\nnew file mode 100644\nindex 000000000000..76f18fbeb55e\n--- /dev/null\n+++ b/tests/queries/0_stateless/03224_invalid_alter.reference\n@@ -0,0 +1,8 @@\n+test\ttesta\ttesta\ttestc\n+test2\ttest2a\ttest2a\ttest2c\n+localhost\t9000\t0\t\t0\t0\n+localhost\t9000\t0\t\t0\t0\n+localhost\t9000\t0\t\t0\t0\n+localhost\t9000\t0\t\t0\t0\n+test3\ttest3a\ttest3a\ttest3c\n+test4\ttest4a\ttest4a\ttest4c\ndiff --git a/tests/queries/0_stateless/03224_invalid_alter.sql b/tests/queries/0_stateless/03224_invalid_alter.sql\nnew file mode 100644\nindex 000000000000..8f9c1d30b4b5\n--- /dev/null\n+++ b/tests/queries/0_stateless/03224_invalid_alter.sql\n@@ -0,0 +1,84 @@\n+-- Tags: no-replicated-database\n+-- no-replicated-database: It messes up the output and this test explicitly checks the replicated database\n+\n+CREATE TABLE test\n+(\n+    str String,\n+    column_with_codec String CODEC(ZSTD),\n+    column_with_alias String MATERIALIZED concat(str, 'a' AS a),\n+)\n+ENGINE = MergeTree()\n+ORDER BY tuple();\n+\n+-- Cannot have a different expression with the same alias\n+ALTER TABLE test ADD COLUMN invalid_column String MATERIALIZED concat(str, 'b' AS a); -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test ADD COLUMN invalid_column String DEFAULT concat(str, 'b' AS a); -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+-- Cannot specify codec for column type ALIAS\n+ALTER TABLE test MODIFY COLUMN column_with_codec String ALIAS str; -- { serverError BAD_ARGUMENTS }\n+-- alias is defined exactly the same\n+ALTER TABLE test ADD COLUMN valid_column_1 String DEFAULT concat(str, 'a' AS a);\n+-- different alias\n+ALTER TABLE test ADD COLUMN valid_column_2 String MATERIALIZED concat(str, 'c' AS c);\n+-- do one insert to make sure we can insert into the table\n+INSERT INTO test(str, column_with_codec) VALUES ('test', 'test2');\n+SELECT str, column_with_alias, valid_column_1, valid_column_2 FROM test;\n+DROP TABLE test;\n+\n+CREATE TABLE test2\n+(\n+    str String,\n+    column_with_codec String CODEC(ZSTD),\n+    column_with_alias String MATERIALIZED concat(str, 'a' AS a),\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/03224_invalid_alter/{database}/{table}', 'r1')\n+ORDER BY tuple();\n+\n+ALTER TABLE test2 ADD COLUMN invalid_column String MATERIALIZED concat(str, 'b' AS a); -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test2 ADD COLUMN invalid_column String DEFAULT concat(str, 'b' AS a); -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test2 MODIFY COLUMN column_with_codec String ALIAS str; -- { serverError BAD_ARGUMENTS }\n+ALTER TABLE test2 ADD COLUMN valid_column_1 String DEFAULT concat(str, 'a' AS a);\n+ALTER TABLE test2 ADD COLUMN valid_column_2 String MATERIALIZED concat(str, 'c' AS c);\n+INSERT INTO test2(str, column_with_codec) VALUES ('test2', 'test22');\n+SELECT str, column_with_alias, valid_column_1, valid_column_2 FROM test2;\n+\n+DROP DATABASE {CLICKHOUSE_DATABASE:Identifier};\n+\n+CREATE DATABASE {CLICKHOUSE_DATABASE:Identifier} ON CLUSTER test_shard_localhost ENGINE = Atomic;\n+\n+CREATE TABLE test3 ON CLUSTER test_shard_localhost\n+(\n+    str String,\n+    column_with_codec String CODEC(ZSTD),\n+    column_with_alias String MATERIALIZED concat(str, 'a' AS a),\n+)\n+ENGINE = ReplicatedMergeTree('/clickhouse/03224_invalid_alter/{database}_atomic/{table}', 'r1')\n+ORDER BY tuple();\n+\n+ALTER TABLE test3 ON CLUSTER test_shard_localhost ADD COLUMN invalid_column String MATERIALIZED concat(str, 'b' AS a) FORMAT Null SETTINGS distributed_ddl_output_mode='throw'; -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test3 ON CLUSTER test_shard_localhost ADD COLUMN invalid_column String DEFAULT concat(str, 'b' AS a) FORMAT Null SETTINGS distributed_ddl_output_mode='throw'; -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test3 ON CLUSTER test_shard_localhost MODIFY COLUMN column_with_codec String ALIAS str FORMAT Null SETTINGS distributed_ddl_output_mode='throw'; -- { serverError BAD_ARGUMENTS }\n+ALTER TABLE test3 ON CLUSTER test_shard_localhost ADD COLUMN valid_column_1 String DEFAULT concat(str, 'a' AS a);\n+ALTER TABLE test3 ON CLUSTER test_shard_localhost ADD COLUMN valid_column_2 String MATERIALIZED concat(str, 'c' AS c);\n+INSERT INTO test3(str, column_with_codec) VALUES ('test3', 'test32');\n+SELECT str, column_with_alias, valid_column_1, valid_column_2 FROM test3;\n+\n+DROP DATABASE {CLICKHOUSE_DATABASE:Identifier};\n+CREATE DATABASE {CLICKHOUSE_DATABASE:Identifier} ENGINE = Replicated('/clickhouse/03224_invalid_alter/{database}_replicated', 'shard1', 'replica1') FORMAT Null;\n+\n+CREATE TABLE test4\n+(\n+    str String,\n+    column_with_codec String CODEC(ZSTD),\n+    column_with_alias String MATERIALIZED concat(str, 'a' AS a),\n+)\n+ENGINE = ReplicatedMergeTree()\n+ORDER BY tuple()\n+FORMAT Null;\n+\n+ALTER TABLE test4 ADD COLUMN invalid_column String MATERIALIZED concat(str, 'b' AS a) FORMAT Null SETTINGS distributed_ddl_output_mode='throw'; -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test4 ADD COLUMN invalid_column String DEFAULT concat(str, 'b' AS a) FORMAT Null SETTINGS distributed_ddl_output_mode='throw'; -- { serverError MULTIPLE_EXPRESSIONS_FOR_ALIAS }\n+ALTER TABLE test4 MODIFY COLUMN column_with_codec String ALIAS str FORMAT Null SETTINGS distributed_ddl_output_mode='throw'; -- { serverError BAD_ARGUMENTS }\n+ALTER TABLE test4 ADD COLUMN valid_column_1 String DEFAULT concat(str, 'a' AS a) FORMAT Null SETTINGS distributed_ddl_output_mode='throw';\n+ALTER TABLE test4 ADD COLUMN valid_column_2 String MATERIALIZED concat(str, 'c' AS c) FORMAT Null SETTINGS distributed_ddl_output_mode='throw';\n+INSERT INTO test4(str, column_with_codec) VALUES ('test4', 'test42');\n+SELECT str, column_with_alias, valid_column_1, valid_column_2 FROM test4;\n",
  "problem_statement": "`ALTER` query can make table definition invalid\n**Describe what's wrong**\r\n\r\nWhen a column is added to a table, the materialized expression (and maybe other expressions) might make the table definition invalid. E.g.: defining an alias with an already existing name. No error is thrown on alter, but only on the first insert after the alter.\r\n\r\n[Repro](https://fiddle.clickhouse.com/5746afd4-ffbc-4da9-b4b8-4924b2324357):\r\n```\r\nCREATE TABLE test\r\n(\r\n    str String,\r\n    mat_1 String MATERIALIZED concat(str, 'a' AS a),\r\n)\r\nENGINE = MergeTree()\r\nORDER BY tuple();\r\n\r\nINSERT INTO test (str) VALUES ('asd1');\r\n\r\nALTER TABLE test ADD COLUMN mat_2 String MATERIALIZED concat(str, 'b' AS a);\r\n\r\nINSERT INTO test (str) VALUES ('asd2');\r\n```\r\n\r\nResult:\r\n```\r\nReceived exception from server (version 24.6.2):\r\nCode: 179. DB::Exception: Received from localhost:9000. DB::Exception: Different expressions with the same alias a:\r\n'b' AS a\r\nand\r\n'a' AS a\r\n: While processing 'b' AS a. (MULTIPLE_EXPRESSIONS_FOR_ALIAS)\r\n(query: INSERT INTO test (str) VALUES ('asd2');)\r\n\r\n```\r\n\r\n**Does it reproduce on the most recent release?**\r\n\r\nYes.\r\n\r\n**How to reproduce**\r\n\r\nSee above.\r\n\r\n**Expected behavior**\r\n\r\nThe `ALTER` query should fail if it makes the table definition invalid.\r\n\n",
  "hints_text": "One idea to fix: As creating the table with the resulting structure (same alias twice with different value) fails in the analyze step (`TreeRewriter::normalize`), we can analyze the create query after changing it with `ALTER` and fail the alter if it doesn't succeed. ",
  "created_at": "2024-08-19T17:04:05Z",
  "modified_files": [
    "src/Databases/DatabaseMemory.cpp",
    "src/Databases/DatabaseOnDisk.cpp",
    "src/Databases/DatabaseOrdinary.cpp",
    "src/Databases/DatabaseReplicated.h",
    "src/Databases/DatabasesCommon.cpp",
    "src/Databases/DatabasesCommon.h",
    "src/Interpreters/InterpreterCreateQuery.cpp",
    "src/Interpreters/InterpreterCreateQuery.h",
    "src/Interpreters/InterpreterSystemQuery.cpp",
    "src/Storages/ColumnsDescription.cpp",
    "src/Storages/ColumnsDescription.h",
    "src/Storages/StorageMergeTree.cpp",
    "src/Storages/StorageReplicatedMergeTree.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00515_enhanced_time_zones.sql",
    "b/tests/queries/0_stateless/03224_invalid_alter.reference",
    "b/tests/queries/0_stateless/03224_invalid_alter.sql"
  ]
}