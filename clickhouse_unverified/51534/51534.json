{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 51534,
  "instance_id": "ClickHouse__ClickHouse-51534",
  "issue_numbers": [
    "51525"
  ],
  "base_commit": "bd88a2195a2f867deb5dbf673be550f56d0239d3",
  "patch": "diff --git a/docs/en/sql-reference/functions/tuple-functions.md b/docs/en/sql-reference/functions/tuple-functions.md\nindex 1739920c9f05..7ed2deaeda67 100644\n--- a/docs/en/sql-reference/functions/tuple-functions.md\n+++ b/docs/en/sql-reference/functions/tuple-functions.md\n@@ -22,14 +22,15 @@ tuple(x, y, \u2026)\n \n A function that allows getting a column from a tuple.\n \n-If the second argument is a number `n`, it is the column index, starting from 1. If the second argument is a string `s`, it represents the name of the element. Besides, we can provide the third optional argument, such that when index out of bounds or element for such name does not exist, the default value returned instead of throw exception. The second and third arguments if provided are always must be constant. There is no cost to execute the function.\n+If the second argument is a number `index`, it is the column index, starting from 1. If the second argument is a string `name`, it represents the name of the element. Besides, we can provide the third optional argument, such that when index out of bounds or no element exist for the name, the default value returned instead of throwing an exception. The second and third arguments, if provided, must be constants. There is no cost to execute the function.\n \n-The function implements the operator `x.n` and `x.s`.\n+The function implements operators `x.index` and `x.name`.\n \n **Syntax**\n \n ``` sql\n-tupleElement(tuple, n/s [, default_value])\n+tupleElement(tuple, index, [, default_value])\n+tupleElement(tuple, name, [, default_value])\n ```\n \n ## untuple\ndiff --git a/src/Common/assert_cast.h b/src/Common/assert_cast.h\nindex 604cfaed6e2e..0b73ba1cc12a 100644\n--- a/src/Common/assert_cast.h\n+++ b/src/Common/assert_cast.h\n@@ -23,7 +23,7 @@ namespace DB\n   * The exact match of the type is checked. That is, cast to the ancestor will be unsuccessful.\n   */\n template <typename To, typename From>\n-To assert_cast(From && from)\n+inline To assert_cast(From && from)\n {\n #ifndef NDEBUG\n     try\ndiff --git a/src/Functions/tupleElement.cpp b/src/Functions/tupleElement.cpp\nindex b1fd200f5cd6..96b5a047419e 100644\n--- a/src/Functions/tupleElement.cpp\n+++ b/src/Functions/tupleElement.cpp\n@@ -17,11 +17,8 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n-    extern const int ILLEGAL_INDEX;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int NOT_FOUND_COLUMN_IN_BLOCK;\n-    extern const int NUMBER_OF_DIMENSIONS_MISMATCHED;\n-    extern const int SIZES_OF_ARRAYS_DONT_MATCH;\n }\n \n namespace\n@@ -34,32 +31,14 @@ class FunctionTupleElement : public IFunction\n {\n public:\n     static constexpr auto name = \"tupleElement\";\n-    static FunctionPtr create(ContextPtr)\n-    {\n-        return std::make_shared<FunctionTupleElement>();\n-    }\n-\n-    String getName() const override\n-    {\n-        return name;\n-    }\n \n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTupleElement>(); }\n+    String getName() const override { return name; }\n     bool isVariadic() const override { return true; }\n-\n-    size_t getNumberOfArguments() const override\n-    {\n-        return 0;\n-    }\n-\n-    bool useDefaultImplementationForConstants() const override\n-    {\n-        return true;\n-    }\n-\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }\n-\n     bool useDefaultImplementationForNulls() const override { return false; }\n-\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\n \n     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n@@ -72,193 +51,111 @@ class FunctionTupleElement : public IFunction\n                             getName(), number_of_arguments);\n \n         size_t count_arrays = 0;\n-        const IDataType * tuple_col = arguments[0].type.get();\n-        while (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(tuple_col))\n+        const IDataType * input_type = arguments[0].type.get();\n+        while (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(input_type))\n         {\n-            tuple_col = array->getNestedType().get();\n+            input_type = array->getNestedType().get();\n             ++count_arrays;\n         }\n \n-        const DataTypeTuple * tuple = checkAndGetDataType<DataTypeTuple>(tuple_col);\n+        const DataTypeTuple * tuple = checkAndGetDataType<DataTypeTuple>(input_type);\n         if (!tuple)\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"First argument for function {} must be tuple or array of tuple. Actual {}\",\n                 getName(),\n                 arguments[0].type->getName());\n \n-        auto index = getElementNum(arguments[1].column, *tuple, number_of_arguments);\n+        std::optional<size_t> index = getElementIndex(arguments[1].column, *tuple, number_of_arguments);\n         if (index.has_value())\n         {\n-            DataTypePtr out_return_type = tuple->getElements()[index.value()];\n+            DataTypePtr return_type = tuple->getElements()[index.value()];\n \n             for (; count_arrays; --count_arrays)\n-                out_return_type = std::make_shared<DataTypeArray>(out_return_type);\n+                return_type = std::make_shared<DataTypeArray>(return_type);\n \n-            return out_return_type;\n+            return return_type;\n         }\n         else\n-        {\n-            const IDataType * default_col = arguments[2].type.get();\n-            size_t default_argument_count_arrays = 0;\n-            if (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(default_col))\n-            {\n-                default_argument_count_arrays = array->getNumberOfDimensions();\n-            }\n-\n-            if (count_arrays != default_argument_count_arrays)\n-            {\n-                throw Exception(ErrorCodes::NUMBER_OF_DIMENSIONS_MISMATCHED,\n-                                \"Dimension of types mismatched between first argument and third argument. \"\n-                                \"Dimension of 1st argument: {}. \"\n-                                \"Dimension of 3rd argument: {}.\",count_arrays, default_argument_count_arrays);\n-            }\n             return arguments[2].type;\n-        }\n     }\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override\n     {\n-        Columns array_offsets;\n+        const auto & input_arg = arguments[0];\n+        const IDataType * input_type = input_arg.type.get();\n+        const IColumn * input_col = input_arg.column.get();\n \n-        const auto & first_arg = arguments[0];\n-\n-        const IDataType * tuple_type = first_arg.type.get();\n-        const IColumn * tuple_col = first_arg.column.get();\n-        bool first_arg_is_const = false;\n-        if (typeid_cast<const ColumnConst *>(tuple_col))\n+        bool input_arg_is_const = false;\n+        if (typeid_cast<const ColumnConst *>(input_col))\n         {\n-            tuple_col = assert_cast<const ColumnConst *>(tuple_col)->getDataColumnPtr().get();\n-            first_arg_is_const = true;\n+            input_col = assert_cast<const ColumnConst *>(input_col)->getDataColumnPtr().get();\n+            input_arg_is_const = true;\n         }\n-        while (const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(tuple_type))\n+\n+        Columns array_offsets;\n+        while (const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(input_type))\n         {\n-            const ColumnArray * array_col = assert_cast<const ColumnArray *>(tuple_col);\n+            const ColumnArray * array_col = assert_cast<const ColumnArray *>(input_col);\n \n-            tuple_type = array_type->getNestedType().get();\n-            tuple_col = &array_col->getData();\n+            input_type = array_type->getNestedType().get();\n+            input_col = &array_col->getData();\n             array_offsets.push_back(array_col->getOffsetsPtr());\n         }\n \n-        const DataTypeTuple * tuple_type_concrete = checkAndGetDataType<DataTypeTuple>(tuple_type);\n-        const ColumnTuple * tuple_col_concrete = checkAndGetColumn<ColumnTuple>(tuple_col);\n-        if (!tuple_type_concrete || !tuple_col_concrete)\n+        const DataTypeTuple * input_type_as_tuple = checkAndGetDataType<DataTypeTuple>(input_type);\n+        const ColumnTuple * input_col_as_tuple = checkAndGetColumn<ColumnTuple>(input_col);\n+        if (!input_type_as_tuple || !input_col_as_tuple)\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n-                \"First argument for function {} must be tuple or array of tuple. Actual {}\",\n-                getName(),\n-                first_arg.type->getName());\n+                \"First argument for function {} must be tuple or array of tuple. Actual {}\", getName(), input_arg.type->getName());\n \n-        auto index = getElementNum(arguments[1].column, *tuple_type_concrete, arguments.size());\n+        std::optional<size_t> index = getElementIndex(arguments[1].column, *input_type_as_tuple, arguments.size());\n \n         if (!index.has_value())\n-        {\n-            if (!array_offsets.empty())\n-            {\n-                recursiveCheckArrayOffsets(arguments[0].column, arguments[2].column, array_offsets.size());\n-            }\n             return arguments[2].column;\n-        }\n \n-        ColumnPtr res = tuple_col_concrete->getColumns()[index.value()];\n+        ColumnPtr res = input_col_as_tuple->getColumns()[index.value()];\n \n         /// Wrap into Arrays\n         for (auto it = array_offsets.rbegin(); it != array_offsets.rend(); ++it)\n             res = ColumnArray::create(res, *it);\n \n-        if (first_arg_is_const)\n-        {\n+        if (input_arg_is_const)\n             res = ColumnConst::create(res, input_rows_count);\n-        }\n         return res;\n     }\n \n private:\n-\n-    void recursiveCheckArrayOffsets(ColumnPtr col_x, ColumnPtr col_y, size_t depth) const\n-    {\n-        for (size_t i = 1; i < depth; ++i)\n-        {\n-            checkArrayOffsets(col_x, col_y);\n-            col_x = assert_cast<const ColumnArray *>(col_x.get())->getDataPtr();\n-            col_y = assert_cast<const ColumnArray *>(col_y.get())->getDataPtr();\n-        }\n-        checkArrayOffsets(col_x, col_y);\n-    }\n-\n-    void checkArrayOffsets(ColumnPtr col_x, ColumnPtr col_y) const\n-    {\n-        if (isColumnConst(*col_x))\n-        {\n-            checkArrayOffsetsWithFirstArgConst(col_x, col_y);\n-        }\n-        else if (isColumnConst(*col_y))\n-        {\n-            checkArrayOffsetsWithFirstArgConst(col_y, col_x);\n-        }\n-        else\n-        {\n-            const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());\n-            const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());\n-            if (!array_x.hasEqualOffsets(array_y))\n-            {\n-                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,\n-                                \"The argument 1 and argument 3 of function {} have different array sizes\", getName());\n-            }\n-        }\n-    }\n-\n-    void checkArrayOffsetsWithFirstArgConst(ColumnPtr col_x, ColumnPtr col_y) const\n-    {\n-        col_x = assert_cast<const ColumnConst *>(col_x.get())->getDataColumnPtr();\n-        col_y = col_y->convertToFullColumnIfConst();\n-        const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());\n-        const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());\n-\n-        const auto & offsets_x = array_x.getOffsets();\n-        const auto & offsets_y = array_y.getOffsets();\n-\n-        ColumnArray::Offset prev_offset = 0;\n-        size_t row_size = offsets_y.size();\n-        for (size_t row = 0; row < row_size; ++row)\n-        {\n-            if (unlikely(offsets_x[0] != offsets_y[row] - prev_offset))\n-            {\n-                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,\n-                                \"The argument 1 and argument 3 of function {} have different array sizes\", getName());\n-            }\n-            prev_offset = offsets_y[row];\n-        }\n-    }\n-\n-    std::optional<size_t> getElementNum(const ColumnPtr & index_column, const DataTypeTuple & tuple, const size_t argument_size) const\n+    std::optional<size_t> getElementIndex(const ColumnPtr & index_column, const DataTypeTuple & tuple, size_t argument_size) const\n     {\n         if (checkAndGetColumnConst<ColumnUInt8>(index_column.get())\n             || checkAndGetColumnConst<ColumnUInt16>(index_column.get())\n             || checkAndGetColumnConst<ColumnUInt32>(index_column.get())\n             || checkAndGetColumnConst<ColumnUInt64>(index_column.get()))\n         {\n-            size_t index = index_column->getUInt(0);\n-\n-            if (index == 0)\n-                throw Exception(ErrorCodes::ILLEGAL_INDEX, \"Indices in tuples are 1-based.\");\n+            const size_t index = index_column->getUInt(0);\n \n-            if (index > tuple.getElements().size())\n-                throw Exception(ErrorCodes::ILLEGAL_INDEX, \"Index for tuple element is out of range.\");\n+            if (index > 0 && index <= tuple.getElements().size())\n+                return {index - 1};\n+            else\n+            {\n+                if (argument_size == 2)\n+                    throw Exception(ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK, \"Tuple doesn't have element with index '{}'\", index);\n+                return std::nullopt;\n+            }\n \n-            return std::optional<size_t>(index - 1);\n         }\n         else if (const auto * name_col = checkAndGetColumnConst<ColumnString>(index_column.get()))\n         {\n-            auto index = tuple.tryGetPositionByName(name_col->getValue<String>());\n+            std::optional<size_t> index = tuple.tryGetPositionByName(name_col->getValue<String>());\n+\n             if (index.has_value())\n-            {\n                 return index;\n-            }\n-\n-            if (argument_size == 2)\n+            else\n             {\n-                throw Exception(ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK, \"Tuple doesn't have element with name '{}'\", name_col->getValue<String>());\n+                if (argument_size == 2)\n+                    throw Exception(ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK, \"Tuple doesn't have element with name '{}'\", name_col->getValue<String>());\n+                return std::nullopt;\n             }\n-            return std::nullopt;\n         }\n         else\n             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02116_tuple_element.sql b/tests/queries/0_stateless/02116_tuple_element.sql\nindex c911712684dd..bedfedd7c2d9 100644\n--- a/tests/queries/0_stateless/02116_tuple_element.sql\n+++ b/tests/queries/0_stateless/02116_tuple_element.sql\n@@ -14,12 +14,12 @@ EXPLAIN SYNTAX SELECT tupleElement(t1, 2) FROM t_tuple_element;\n SELECT tupleElement(t1, 'a') FROM t_tuple_element;\n EXPLAIN SYNTAX SELECT tupleElement(t1, 'a') FROM t_tuple_element;\n \n-SELECT tupleElement(number, 1) FROM numbers(1); -- { serverError 43 }\n-SELECT tupleElement(t1) FROM t_tuple_element; -- { serverError 42 }\n-SELECT tupleElement(t1, 'b') FROM t_tuple_element; -- { serverError 10, 47 }\n-SELECT tupleElement(t1, 0) FROM t_tuple_element; -- { serverError 127 }\n-SELECT tupleElement(t1, 3) FROM t_tuple_element; -- { serverError 127 }\n-SELECT tupleElement(t1, materialize('a')) FROM t_tuple_element; -- { serverError 43 }\n+SELECT tupleElement(number, 1) FROM numbers(1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT tupleElement(t1) FROM t_tuple_element; -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT tupleElement(t1, 'b') FROM t_tuple_element; -- { serverError NOT_FOUND_COLUMN_IN_BLOCK, UNKNOWN_IDENTIFIER }\n+SELECT tupleElement(t1, 0) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX }\n+SELECT tupleElement(t1, 3) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX }\n+SELECT tupleElement(t1, materialize('a')) FROM t_tuple_element; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n \n SELECT t2.1 FROM t_tuple_element;\n EXPLAIN SYNTAX SELECT t2.1 FROM t_tuple_element;\n@@ -27,11 +27,11 @@ EXPLAIN SYNTAX SELECT t2.1 FROM t_tuple_element;\n SELECT tupleElement(t2, 1) FROM t_tuple_element;\n EXPLAIN SYNTAX SELECT tupleElement(t2, 1) FROM t_tuple_element;\n \n-SELECT tupleElement(t2) FROM t_tuple_element; -- { serverError 42 }\n-SELECT tupleElement(t2, 'a') FROM t_tuple_element; -- { serverError 10, 47 }\n-SELECT tupleElement(t2, 0) FROM t_tuple_element; -- { serverError 127 }\n-SELECT tupleElement(t2, 3) FROM t_tuple_element; -- { serverError 127 }\n-SELECT tupleElement(t2, materialize(1)) FROM t_tuple_element; -- { serverError 43 }\n+SELECT tupleElement(t2) FROM t_tuple_element; -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT tupleElement(t2, 'a') FROM t_tuple_element; -- { serverError NOT_FOUND_COLUMN_IN_BLOCK, UNKNOWN_IDENTIFIER }\n+SELECT tupleElement(t2, 0) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX }\n+SELECT tupleElement(t2, 3) FROM t_tuple_element; -- { serverError ILLEGAL_INDEX }\n+SELECT tupleElement(t2, materialize(1)) FROM t_tuple_element; -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n \n DROP TABLE t_tuple_element;\n \ndiff --git a/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql b/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql\nindex a5fd8e57ad5a..f723284ad619 100644\n--- a/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql\n+++ b/tests/queries/0_stateless/02286_tuple_numeric_identifier.sql\n@@ -12,8 +12,8 @@ SELECT * FROM t_tuple_numeric FORMAT JSONEachRow;\n SELECT `t`.`1`.`2`, `t`.`1`.`3`, `t`.`4` FROM t_tuple_numeric;\n SELECT t.1.1, t.1.2, t.2 FROM t_tuple_numeric;\n \n-SELECT t.1.3 FROM t_tuple_numeric; -- {serverError ILLEGAL_INDEX}\n-SELECT t.4 FROM t_tuple_numeric; -- {serverError ILLEGAL_INDEX}\n+SELECT t.1.3 FROM t_tuple_numeric; -- {serverError NOT_FOUND_COLUMN_IN_BLOCK}\n+SELECT t.4 FROM t_tuple_numeric; -- {serverError NOT_FOUND_COLUMN_IN_BLOCK}\n SELECT `t`.`1`.`1`, `t`.`1`.`2`, `t`.`2` FROM t_tuple_numeric; -- {serverError UNKNOWN_IDENTIFIER}\n \n DROP TABLE t_tuple_numeric;\ndiff --git a/tests/queries/0_stateless/02354_tuple_element_with_default.reference b/tests/queries/0_stateless/02354_tuple_element_with_default.reference\nindex d5dfff17ef19..499b4c36a106 100644\n--- a/tests/queries/0_stateless/02354_tuple_element_with_default.reference\n+++ b/tests/queries/0_stateless/02354_tuple_element_with_default.reference\n@@ -1,26 +1,15 @@\n-z\n-SELECT tupleElement(t1, \\'z\\', \\'z\\')\n-FROM t_tuple_element_default\n-0\n-SELECT tupleElement(t1, \\'z\\', 0)\n-FROM t_tuple_element_default\n-z\n-SELECT tupleElement(t2, \\'z\\', \\'z\\')\n-FROM t_tuple_element_default\n---------------------\n-[(3,4)]\n-SELECT tupleElement([(1, 2)], \\'a\\', [(3, 4)])\n---------------------\n-SELECT tupleElement(t1, \\'a\\', [tuple(1)])\n-FROM t_tuple_element_default\n---------------------\n-[(0)]\n-SELECT tupleElement(t1, \\'a\\', [tuple(0)])\n-FROM t_tuple_element_default\n-[0]\n-SELECT tupleElement(t1, \\'a\\', [0])\n-FROM t_tuple_element_default\n-[0]\n-[0]\n-SELECT tupleElement(t1, \\'a\\', [0])\n-FROM t_tuple_element_default\n+hello\n+world\n+default\n+default\n+[(['a'],1)]\n+[1,3]\n+[2,4]\n+default\n+--------\n+hello\n+world\n+default\n+default\n+[(['a'],1)]\n+[[1,2,3]]\ndiff --git a/tests/queries/0_stateless/02354_tuple_element_with_default.sql b/tests/queries/0_stateless/02354_tuple_element_with_default.sql\nindex 908a869885b5..89320f4d210b 100644\n--- a/tests/queries/0_stateless/02354_tuple_element_with_default.sql\n+++ b/tests/queries/0_stateless/02354_tuple_element_with_default.sql\n@@ -1,50 +1,23 @@\n-DROP TABLE IF EXISTS t_tuple_element_default;\n+-- const tuple argument\n \n-CREATE TABLE t_tuple_element_default(t1 Tuple(a UInt32, s String), t2 Tuple(UInt32, String)) ENGINE = Memory;\n-INSERT INTO t_tuple_element_default VALUES ((1, 'a'), (2, 'b'));\n+SELECT tupleElement(('hello', 'world'), 1, 'default');\n+SELECT tupleElement(('hello', 'world'), 2, 'default');\n+SELECT tupleElement(('hello', 'world'), 3, 'default');\n+SELECT tupleElement(('hello', 'world'), 'xyz', 'default');\n+SELECT tupleElement(('hello', 'world'), 3, [([('a')], 1)]); -- arbitrary default value\n \n-SELECT tupleElement(t1, 'z', 'z') FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'z', 'z') FROM t_tuple_element_default;\n-SELECT tupleElement(t1, 'z', 0) FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'z', 0) FROM t_tuple_element_default;\n-SELECT tupleElement(t2, 'z', 'z') FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t2, 'z', 'z') FROM t_tuple_element_default;\n+SELECT tupleElement([(1, 2), (3, 4)], 1, 'default');\n+SELECT tupleElement([(1, 2), (3, 4)], 2, 'default');\n+SELECT tupleElement([(1, 2), (3, 4)], 3, 'default');\n \n-SELECT tupleElement(t1, 3, 'z') FROM t_tuple_element_default; -- { serverError 127 }\n-SELECT tupleElement(t1, 0, 'z') FROM t_tuple_element_default; -- { serverError 127 }\n+SELECT '--------';\n \n-DROP TABLE t_tuple_element_default;\n+-- non-const tuple argument\n \n-SELECT '--------------------';\n-\n-SELECT tupleElement(array(tuple(1, 2)), 'a', 0); -- { serverError 645 }\n-SELECT tupleElement(array(tuple(1, 2)), 'a', array(tuple(1, 2), tuple(3, 4))); -- { serverError 190 }\n-SELECT tupleElement(array(array(tuple(1))), 'a', array(array(1, 2, 3))); -- { serverError 190 }\n-\n-SELECT tupleElement(array(tuple(1, 2)), 'a', array(tuple(3, 4)));\n-EXPLAIN SYNTAX SELECT tupleElement(array(tuple(1, 2)), 'a', array(tuple(3, 4)));\n-\n-SELECT '--------------------';\n-\n-CREATE TABLE t_tuple_element_default(t1 Array(Tuple(UInt32)), t2 UInt32) ENGINE = Memory;\n-\n-SELECT tupleElement(t1, 'a', array(tuple(1))) FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(tuple(1))) FROM t_tuple_element_default;\n-\n-SELECT '--------------------';\n-\n-INSERT INTO t_tuple_element_default VALUES ([(1)], 100);\n-\n-SELECT tupleElement(t1, 'a', array(tuple(0))) FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(tuple(0))) FROM t_tuple_element_default;\n-\n-SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n-\n-INSERT INTO t_tuple_element_default VALUES ([(2)], 200);\n-\n-SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n-EXPLAIN SYNTAX SELECT tupleElement(t1, 'a', array(0)) FROM t_tuple_element_default;\n-\n-DROP TABLE t_tuple_element_default;\n+SELECT tupleElement(materialize(('hello', 'world')), 1, 'default');\n+SELECT tupleElement(materialize(('hello', 'world')), 2, 'default');\n+SELECT tupleElement(materialize(('hello', 'world')), 3, 'default');\n+SELECT tupleElement(materialize(('hello', 'world')), 'xzy', 'default');\n+SELECT tupleElement(materialize(('hello', 'world')), 'xzy', [([('a')], 1)]); -- arbitrary default value\n \n+SELECT tupleElement([[(count('2147483646'), 1)]], 'aaaa', [[1, 2, 3]]) -- bug #51525\n",
  "problem_statement": "Fuzzer: Logical error in tupleElement()\n`SELECT tupleElement([[(count('2147483646'), 1)]], 'aaaa', [[1, 2, 3]])`\r\n\r\n--> `Logical error: 'Bad cast from type DB::IColumn const* to DB::ColumnArray const*'.`\r\n\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/0/abf56b80a9303b0ffea4996753d7c670acfcdf61/fuzzer_astfuzzerdebug/report.html\n",
  "hints_text": "",
  "created_at": "2023-06-28T12:52:27Z",
  "modified_files": [
    "docs/en/sql-reference/functions/tuple-functions.md",
    "src/Common/assert_cast.h",
    "src/Functions/tupleElement.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/02116_tuple_element.sql",
    "tests/queries/0_stateless/02286_tuple_numeric_identifier.sql",
    "tests/queries/0_stateless/02354_tuple_element_with_default.reference",
    "tests/queries/0_stateless/02354_tuple_element_with_default.sql"
  ]
}