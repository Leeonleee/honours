diff --git a/docs/en/sql-reference/functions/tuple-functions.md b/docs/en/sql-reference/functions/tuple-functions.md
index 1739920c9f05..7ed2deaeda67 100644
--- a/docs/en/sql-reference/functions/tuple-functions.md
+++ b/docs/en/sql-reference/functions/tuple-functions.md
@@ -22,14 +22,15 @@ tuple(x, y, â€¦)
 
 A function that allows getting a column from a tuple.
 
-If the second argument is a number `n`, it is the column index, starting from 1. If the second argument is a string `s`, it represents the name of the element. Besides, we can provide the third optional argument, such that when index out of bounds or element for such name does not exist, the default value returned instead of throw exception. The second and third arguments if provided are always must be constant. There is no cost to execute the function.
+If the second argument is a number `index`, it is the column index, starting from 1. If the second argument is a string `name`, it represents the name of the element. Besides, we can provide the third optional argument, such that when index out of bounds or no element exist for the name, the default value returned instead of throwing an exception. The second and third arguments, if provided, must be constants. There is no cost to execute the function.
 
-The function implements the operator `x.n` and `x.s`.
+The function implements operators `x.index` and `x.name`.
 
 **Syntax**
 
 ``` sql
-tupleElement(tuple, n/s [, default_value])
+tupleElement(tuple, index, [, default_value])
+tupleElement(tuple, name, [, default_value])
 ```
 
 ## untuple
diff --git a/src/Common/assert_cast.h b/src/Common/assert_cast.h
index 604cfaed6e2e..0b73ba1cc12a 100644
--- a/src/Common/assert_cast.h
+++ b/src/Common/assert_cast.h
@@ -23,7 +23,7 @@ namespace DB
   * The exact match of the type is checked. That is, cast to the ancestor will be unsuccessful.
   */
 template <typename To, typename From>
-To assert_cast(From && from)
+inline To assert_cast(From && from)
 {
 #ifndef NDEBUG
     try
diff --git a/src/Functions/tupleElement.cpp b/src/Functions/tupleElement.cpp
index b1fd200f5cd6..96b5a047419e 100644
--- a/src/Functions/tupleElement.cpp
+++ b/src/Functions/tupleElement.cpp
@@ -17,11 +17,8 @@ namespace DB
 namespace ErrorCodes
 {
     extern const int ILLEGAL_TYPE_OF_ARGUMENT;
-    extern const int ILLEGAL_INDEX;
     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;
     extern const int NOT_FOUND_COLUMN_IN_BLOCK;
-    extern const int NUMBER_OF_DIMENSIONS_MISMATCHED;
-    extern const int SIZES_OF_ARRAYS_DONT_MATCH;
 }
 
 namespace
@@ -34,32 +31,14 @@ class FunctionTupleElement : public IFunction
 {
 public:
     static constexpr auto name = "tupleElement";
-    static FunctionPtr create(ContextPtr)
-    {
-        return std::make_shared<FunctionTupleElement>();
-    }
-
-    String getName() const override
-    {
-        return name;
-    }
 
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionTupleElement>(); }
+    String getName() const override { return name; }
     bool isVariadic() const override { return true; }
-
-    size_t getNumberOfArguments() const override
-    {
-        return 0;
-    }
-
-    bool useDefaultImplementationForConstants() const override
-    {
-        return true;
-    }
-
+    size_t getNumberOfArguments() const override { return 0; }
+    bool useDefaultImplementationForConstants() const override { return true; }
     ColumnNumbers getArgumentsThatAreAlwaysConstant() const override { return {1}; }
-
     bool useDefaultImplementationForNulls() const override { return false; }
-
     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }
 
     DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
@@ -72,193 +51,111 @@ class FunctionTupleElement : public IFunction
                             getName(), number_of_arguments);
 
         size_t count_arrays = 0;
-        const IDataType * tuple_col = arguments[0].type.get();
-        while (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(tuple_col))
+        const IDataType * input_type = arguments[0].type.get();
+        while (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(input_type))
         {
-            tuple_col = array->getNestedType().get();
+            input_type = array->getNestedType().get();
             ++count_arrays;
         }
 
-        const DataTypeTuple * tuple = checkAndGetDataType<DataTypeTuple>(tuple_col);
+        const DataTypeTuple * tuple = checkAndGetDataType<DataTypeTuple>(input_type);
         if (!tuple)
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
                 "First argument for function {} must be tuple or array of tuple. Actual {}",
                 getName(),
                 arguments[0].type->getName());
 
-        auto index = getElementNum(arguments[1].column, *tuple, number_of_arguments);
+        std::optional<size_t> index = getElementIndex(arguments[1].column, *tuple, number_of_arguments);
         if (index.has_value())
         {
-            DataTypePtr out_return_type = tuple->getElements()[index.value()];
+            DataTypePtr return_type = tuple->getElements()[index.value()];
 
             for (; count_arrays; --count_arrays)
-                out_return_type = std::make_shared<DataTypeArray>(out_return_type);
+                return_type = std::make_shared<DataTypeArray>(return_type);
 
-            return out_return_type;
+            return return_type;
         }
         else
-        {
-            const IDataType * default_col = arguments[2].type.get();
-            size_t default_argument_count_arrays = 0;
-            if (const DataTypeArray * array = checkAndGetDataType<DataTypeArray>(default_col))
-            {
-                default_argument_count_arrays = array->getNumberOfDimensions();
-            }
-
-            if (count_arrays != default_argument_count_arrays)
-            {
-                throw Exception(ErrorCodes::NUMBER_OF_DIMENSIONS_MISMATCHED,
-                                "Dimension of types mismatched between first argument and third argument. "
-                                "Dimension of 1st argument: {}. "
-                                "Dimension of 3rd argument: {}.",count_arrays, default_argument_count_arrays);
-            }
             return arguments[2].type;
-        }
     }
 
     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t input_rows_count) const override
     {
-        Columns array_offsets;
+        const auto & input_arg = arguments[0];
+        const IDataType * input_type = input_arg.type.get();
+        const IColumn * input_col = input_arg.column.get();
 
-        const auto & first_arg = arguments[0];
-
-        const IDataType * tuple_type = first_arg.type.get();
-        const IColumn * tuple_col = first_arg.column.get();
-        bool first_arg_is_const = false;
-        if (typeid_cast<const ColumnConst *>(tuple_col))
+        bool input_arg_is_const = false;
+        if (typeid_cast<const ColumnConst *>(input_col))
         {
-            tuple_col = assert_cast<const ColumnConst *>(tuple_col)->getDataColumnPtr().get();
-            first_arg_is_const = true;
+            input_col = assert_cast<const ColumnConst *>(input_col)->getDataColumnPtr().get();
+            input_arg_is_const = true;
         }
-        while (const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(tuple_type))
+
+        Columns array_offsets;
+        while (const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(input_type))
         {
-            const ColumnArray * array_col = assert_cast<const ColumnArray *>(tuple_col);
+            const ColumnArray * array_col = assert_cast<const ColumnArray *>(input_col);
 
-            tuple_type = array_type->getNestedType().get();
-            tuple_col = &array_col->getData();
+            input_type = array_type->getNestedType().get();
+            input_col = &array_col->getData();
             array_offsets.push_back(array_col->getOffsetsPtr());
         }
 
-        const DataTypeTuple * tuple_type_concrete = checkAndGetDataType<DataTypeTuple>(tuple_type);
-        const ColumnTuple * tuple_col_concrete = checkAndGetColumn<ColumnTuple>(tuple_col);
-        if (!tuple_type_concrete || !tuple_col_concrete)
+        const DataTypeTuple * input_type_as_tuple = checkAndGetDataType<DataTypeTuple>(input_type);
+        const ColumnTuple * input_col_as_tuple = checkAndGetColumn<ColumnTuple>(input_col);
+        if (!input_type_as_tuple || !input_col_as_tuple)
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
-                "First argument for function {} must be tuple or array of tuple. Actual {}",
-                getName(),
-                first_arg.type->getName());
+                "First argument for function {} must be tuple or array of tuple. Actual {}", getName(), input_arg.type->getName());
 
-        auto index = getElementNum(arguments[1].column, *tuple_type_concrete, arguments.size());
+        std::optional<size_t> index = getElementIndex(arguments[1].column, *input_type_as_tuple, arguments.size());
 
         if (!index.has_value())
-        {
-            if (!array_offsets.empty())
-            {
-                recursiveCheckArrayOffsets(arguments[0].column, arguments[2].column, array_offsets.size());
-            }
             return arguments[2].column;
-        }
 
-        ColumnPtr res = tuple_col_concrete->getColumns()[index.value()];
+        ColumnPtr res = input_col_as_tuple->getColumns()[index.value()];
 
         /// Wrap into Arrays
         for (auto it = array_offsets.rbegin(); it != array_offsets.rend(); ++it)
             res = ColumnArray::create(res, *it);
 
-        if (first_arg_is_const)
-        {
+        if (input_arg_is_const)
             res = ColumnConst::create(res, input_rows_count);
-        }
         return res;
     }
 
 private:
-
-    void recursiveCheckArrayOffsets(ColumnPtr col_x, ColumnPtr col_y, size_t depth) const
-    {
-        for (size_t i = 1; i < depth; ++i)
-        {
-            checkArrayOffsets(col_x, col_y);
-            col_x = assert_cast<const ColumnArray *>(col_x.get())->getDataPtr();
-            col_y = assert_cast<const ColumnArray *>(col_y.get())->getDataPtr();
-        }
-        checkArrayOffsets(col_x, col_y);
-    }
-
-    void checkArrayOffsets(ColumnPtr col_x, ColumnPtr col_y) const
-    {
-        if (isColumnConst(*col_x))
-        {
-            checkArrayOffsetsWithFirstArgConst(col_x, col_y);
-        }
-        else if (isColumnConst(*col_y))
-        {
-            checkArrayOffsetsWithFirstArgConst(col_y, col_x);
-        }
-        else
-        {
-            const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());
-            const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());
-            if (!array_x.hasEqualOffsets(array_y))
-            {
-                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,
-                                "The argument 1 and argument 3 of function {} have different array sizes", getName());
-            }
-        }
-    }
-
-    void checkArrayOffsetsWithFirstArgConst(ColumnPtr col_x, ColumnPtr col_y) const
-    {
-        col_x = assert_cast<const ColumnConst *>(col_x.get())->getDataColumnPtr();
-        col_y = col_y->convertToFullColumnIfConst();
-        const auto & array_x = *assert_cast<const ColumnArray *>(col_x.get());
-        const auto & array_y = *assert_cast<const ColumnArray *>(col_y.get());
-
-        const auto & offsets_x = array_x.getOffsets();
-        const auto & offsets_y = array_y.getOffsets();
-
-        ColumnArray::Offset prev_offset = 0;
-        size_t row_size = offsets_y.size();
-        for (size_t row = 0; row < row_size; ++row)
-        {
-            if (unlikely(offsets_x[0] != offsets_y[row] - prev_offset))
-            {
-                throw Exception(ErrorCodes::SIZES_OF_ARRAYS_DONT_MATCH,
-                                "The argument 1 and argument 3 of function {} have different array sizes", getName());
-            }
-            prev_offset = offsets_y[row];
-        }
-    }
-
-    std::optional<size_t> getElementNum(const ColumnPtr & index_column, const DataTypeTuple & tuple, const size_t argument_size) const
+    std::optional<size_t> getElementIndex(const ColumnPtr & index_column, const DataTypeTuple & tuple, size_t argument_size) const
     {
         if (checkAndGetColumnConst<ColumnUInt8>(index_column.get())
             || checkAndGetColumnConst<ColumnUInt16>(index_column.get())
             || checkAndGetColumnConst<ColumnUInt32>(index_column.get())
             || checkAndGetColumnConst<ColumnUInt64>(index_column.get()))
         {
-            size_t index = index_column->getUInt(0);
-
-            if (index == 0)
-                throw Exception(ErrorCodes::ILLEGAL_INDEX, "Indices in tuples are 1-based.");
+            const size_t index = index_column->getUInt(0);
 
-            if (index > tuple.getElements().size())
-                throw Exception(ErrorCodes::ILLEGAL_INDEX, "Index for tuple element is out of range.");
+            if (index > 0 && index <= tuple.getElements().size())
+                return {index - 1};
+            else
+            {
+                if (argument_size == 2)
+                    throw Exception(ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK, "Tuple doesn't have element with index '{}'", index);
+                return std::nullopt;
+            }
 
-            return std::optional<size_t>(index - 1);
         }
         else if (const auto * name_col = checkAndGetColumnConst<ColumnString>(index_column.get()))
         {
-            auto index = tuple.tryGetPositionByName(name_col->getValue<String>());
+            std::optional<size_t> index = tuple.tryGetPositionByName(name_col->getValue<String>());
+
             if (index.has_value())
-            {
                 return index;
-            }
-
-            if (argument_size == 2)
+            else
             {
-                throw Exception(ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK, "Tuple doesn't have element with name '{}'", name_col->getValue<String>());
+                if (argument_size == 2)
+                    throw Exception(ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK, "Tuple doesn't have element with name '{}'", name_col->getValue<String>());
+                return std::nullopt;
             }
-            return std::nullopt;
         }
         else
             throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,
