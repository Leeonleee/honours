diff --git a/src/Storages/System/StorageSystemZooKeeper.cpp b/src/Storages/System/StorageSystemZooKeeper.cpp
index 4ba6c00ad9df..1212d9da60ae 100644
--- a/src/Storages/System/StorageSystemZooKeeper.cpp
+++ b/src/Storages/System/StorageSystemZooKeeper.cpp
@@ -16,8 +16,12 @@
 #include <Interpreters/Set.h>
 #include <Interpreters/interpretSubquery.h>
 #include <Processors/Executors/PullingPipelineExecutor.h>
+#include <Processors/Sinks/SinkToStorage.h>
+#include <boost/algorithm/string/join.hpp>
+#include <boost/algorithm/string.hpp>
 #include <algorithm>
 #include <deque>
+#include <climits>
 
 
 namespace DB
@@ -28,6 +32,157 @@ namespace ErrorCodes
     extern const int BAD_ARGUMENTS;
 }
 
+/** ZkNodeCache is a trie tree to cache all the zookeeper writes. The purpose of this struct is to avoid creating/setting nodes
+  * repeatedly. For example, If we create path /a/b/c/d/e and path /a/b/d/f in the same transaction. We don't want to create
+  * their common path "/a/b" twice. This data structure will cache this changes and generates the eventual requests within one pass.
+  */
+struct ZkNodeCache
+{
+    using ZkNodeCachePtr = std::shared_ptr<ZkNodeCache>;
+
+    std::unordered_map<String, ZkNodeCachePtr> children;
+    String value;
+    String path;
+    bool exists;
+    bool changed;
+
+    ZkNodeCache() : exists(true), changed(false) { }
+    ZkNodeCache(String path_, bool exists_) : path(path_), exists(exists_), changed(false) { }
+
+    void insert(const std::vector<String> & nodes, zkutil::ZooKeeperPtr zookeeper, const String & value_to_set, size_t index)
+    {
+        /// If this node has an empty name, just skip it.
+        /// Possibly a "/a//b///c//d/" will cause empty node.
+        while (index < nodes.size() && nodes[index].empty())
+            ++index;
+
+        if (index == nodes.size())
+        {
+            value = value_to_set;
+            changed = true;
+            return;
+        }
+        const String & child_name = nodes[index];
+        ++index;
+        if (!children.contains(child_name))
+        {
+            String sub_path = path + "/" + child_name;
+            bool child_exist = false;
+            if (exists)
+            {
+                /// If this node doesn't exists, neither will its child.
+                child_exist = zookeeper->exists(sub_path);
+            }
+            children[child_name] = std::make_shared<ZkNodeCache>(sub_path, child_exist);
+        }
+        children[child_name]->insert(nodes, zookeeper, value_to_set, index);
+    }
+
+    void generateRequests(Coordination::Requests & requests)
+    {
+        /** If the node doesn't exists, we should generate create request.
+          * If the node exists, we should generate set request.
+          * This dfs will prove ancestor nodes are processed first.
+          */
+        if (!exists)
+        {
+            auto request = zkutil::makeCreateRequest(path, value, zkutil::CreateMode::Persistent);
+            requests.push_back(request);
+        }
+        else if (changed)
+        {
+            auto request = zkutil::makeSetRequest(path, value, -1);
+            requests.push_back(request);
+        }
+        for (auto [_, child] : children)
+            child->generateRequests(requests);
+    }
+};
+
+class ZooKeeperSink : public SinkToStorage
+{
+    zkutil::ZooKeeperPtr zookeeper;
+
+    ZkNodeCache cache;
+
+public:
+    ZooKeeperSink(const Block & header, ContextPtr context) : SinkToStorage(header), zookeeper(context->getZooKeeper()) { }
+    String getName() const override { return "ZooKeeperSink"; }
+
+    void consume(Chunk chunk) override
+    {
+        auto block = getHeader().cloneWithColumns(chunk.getColumns());
+        size_t rows = block.rows();
+        for (size_t i = 0; i < rows; i++)
+        {
+            String name = block.getByPosition(0).column->getDataAt(i).toString();
+            String value = block.getByPosition(1).column->getDataAt(i).toString();
+            String path = block.getByPosition(2).column->getDataAt(i).toString();
+
+            /// We don't expect a "name" contains a path.
+            if (name.find('/') != std::string::npos)
+            {
+                throw Exception("Column `name` should not contain '/'", ErrorCodes::BAD_ARGUMENTS);
+            }
+
+            if (name.empty())
+            {
+                throw Exception("Column `name` should not be empty", ErrorCodes::BAD_ARGUMENTS);
+            }
+
+            if (path.empty())
+            {
+                throw Exception("Column `path` should not be empty", ErrorCodes::BAD_ARGUMENTS);
+            }
+
+            if (path.size() + name.size() > PATH_MAX)
+            {
+                throw Exception("Sum of `name` length and `path` length should not exceed PATH_MAX", ErrorCodes::BAD_ARGUMENTS);
+            }
+
+            std::vector<String> path_vec;
+            boost::split(path_vec, path, boost::is_any_of("/"));
+            path_vec.push_back(name);
+            cache.insert(path_vec, zookeeper, value, 0);
+        }
+    }
+
+    void onFinish() override
+    {
+        Coordination::Requests requests;
+        cache.generateRequests(requests);
+        zookeeper->multi(requests);
+    }
+};
+
+StorageSystemZooKeeper::StorageSystemZooKeeper(const StorageID & table_id_)
+        : IStorageSystemOneBlock<StorageSystemZooKeeper>(table_id_)
+{
+        StorageInMemoryMetadata storage_metadata;
+        ColumnsDescription desc;
+        auto columns = getNamesAndTypes();
+        for (const auto & col : columns)
+        {
+            ColumnDescription col_desc(col.name, col.type);
+            /// We only allow column `name`, `path`, `value` to insert.
+            if (col.name != "name" && col.name != "path" && col.name != "value")
+                col_desc.default_desc.kind = ColumnDefaultKind::Materialized;
+            desc.add(col_desc);
+        }
+        storage_metadata.setColumns(desc);
+        setInMemoryMetadata(storage_metadata);
+}
+
+SinkToStoragePtr StorageSystemZooKeeper::write(const ASTPtr &, const StorageMetadataPtr &, ContextPtr context)
+{
+    if (!context->getConfigRef().getBool("allow_zookeeper_write", false))
+        throw Exception("Prohibit writing to system.zookeeper, unless config `allow_zookeeper_write` as true", ErrorCodes::BAD_ARGUMENTS);
+    Block write_header;
+    write_header.insert(ColumnWithTypeAndName(std::make_shared<DataTypeString>(), "name"));
+    write_header.insert(ColumnWithTypeAndName(std::make_shared<DataTypeString>(), "value"));
+    write_header.insert(ColumnWithTypeAndName(std::make_shared<DataTypeString>(), "path"));
+    return std::make_shared<ZooKeeperSink>(write_header, context);
+}
 
 NamesAndTypesList StorageSystemZooKeeper::getNamesAndTypes()
 {
diff --git a/src/Storages/System/StorageSystemZooKeeper.h b/src/Storages/System/StorageSystemZooKeeper.h
index 32ca767ac244..20ad29af4818 100644
--- a/src/Storages/System/StorageSystemZooKeeper.h
+++ b/src/Storages/System/StorageSystemZooKeeper.h
@@ -14,10 +14,14 @@ class Context;
 class StorageSystemZooKeeper final : public IStorageSystemOneBlock<StorageSystemZooKeeper>
 {
 public:
+    explicit StorageSystemZooKeeper(const StorageID & table_id_);
+
     std::string getName() const override { return "SystemZooKeeper"; }
 
     static NamesAndTypesList getNamesAndTypes();
 
+    SinkToStoragePtr write(const ASTPtr & /*query*/, const StorageMetadataPtr & /*metadata_snapshot*/, ContextPtr /*context*/) override;
+
 protected:
     using IStorageSystemOneBlock::IStorageSystemOneBlock;
 
