{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 22299,
  "instance_id": "ClickHouse__ClickHouse-22299",
  "issue_numbers": [
    "20129"
  ],
  "base_commit": "8c3ccaa247246934a8c0abc7cfab6fdd1bfb34ea",
  "patch": "diff --git a/src/Formats/FormatFactory.cpp b/src/Formats/FormatFactory.cpp\nindex f7f32cf9b6f5..0591fe003fa4 100644\n--- a/src/Formats/FormatFactory.cpp\n+++ b/src/Formats/FormatFactory.cpp\n@@ -412,11 +412,26 @@ void FormatFactory::markOutputFormatSupportsParallelFormatting(const String & na\n {\n     auto & target = dict[name].supports_parallel_formatting;\n     if (target)\n-        throw Exception(\"FormatFactory: Output format \" + name + \" is already marked as supporting parallel formatting.\", ErrorCodes::LOGICAL_ERROR);\n+        throw Exception(\"FormatFactory: Output format \" + name + \" is already marked as supporting parallel formatting\", ErrorCodes::LOGICAL_ERROR);\n     target = true;\n }\n \n \n+void FormatFactory::markFormatAsColumnOriented(const String & name)\n+{\n+    auto & target = dict[name].is_column_oriented;\n+    if (target)\n+        throw Exception(\"FormatFactory: Format \" + name + \" is already marked as column oriented\", ErrorCodes::LOGICAL_ERROR);\n+    target = true;\n+}\n+\n+\n+bool FormatFactory::checkIfFormatIsColumnOriented(const String & name)\n+{\n+    const auto & target = getCreators(name);\n+    return target.is_column_oriented;\n+}\n+\n FormatFactory & FormatFactory::instance()\n {\n     static FormatFactory ret;\ndiff --git a/src/Formats/FormatFactory.h b/src/Formats/FormatFactory.h\nindex 4fa7e9a0c017..3a21ef91d350 100644\n--- a/src/Formats/FormatFactory.h\n+++ b/src/Formats/FormatFactory.h\n@@ -101,6 +101,7 @@ class FormatFactory final : private boost::noncopyable\n         OutputProcessorCreator output_processor_creator;\n         FileSegmentationEngine file_segmentation_engine;\n         bool supports_parallel_formatting{false};\n+        bool is_column_oriented{false};\n     };\n \n     using FormatsDictionary = std::unordered_map<String, Creators>;\n@@ -155,6 +156,9 @@ class FormatFactory final : private boost::noncopyable\n     void registerOutputFormatProcessor(const String & name, OutputProcessorCreator output_creator);\n \n     void markOutputFormatSupportsParallelFormatting(const String & name);\n+    void markFormatAsColumnOriented(const String & name);\n+\n+    bool checkIfFormatIsColumnOriented(const String & name);\n \n     const FormatsDictionary & getAllFormats() const\n     {\ndiff --git a/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp b/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\nindex 4edef1f1365e..6a5c97182782 100644\n--- a/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp\n@@ -101,7 +101,7 @@ void ArrowBlockInputFormat::prepareReader()\n     record_batch_current = 0;\n }\n \n-void registerInputFormatProcessorArrow(FormatFactory &factory)\n+void registerInputFormatProcessorArrow(FormatFactory & factory)\n {\n     factory.registerInputFormatProcessor(\n         \"Arrow\",\n@@ -112,7 +112,7 @@ void registerInputFormatProcessorArrow(FormatFactory &factory)\n         {\n             return std::make_shared<ArrowBlockInputFormat>(buf, sample, false);\n         });\n-\n+    factory.markFormatAsColumnOriented(\"Arrow\");\n     factory.registerInputFormatProcessor(\n         \"ArrowStream\",\n         [](ReadBuffer & buf,\ndiff --git a/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp b/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\nindex 7776a904f1cc..9af03e93c329 100644\n--- a/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ORCBlockInputFormat.cpp\n@@ -64,6 +64,7 @@ void registerInputFormatProcessorORC(FormatFactory &factory)\n             {\n                 return std::make_shared<ORCBlockInputFormat>(buf, sample);\n             });\n+    factory.markFormatAsColumnOriented(\"ORC\");\n }\n \n }\ndiff --git a/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp b/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\nindex bb55c71b7cab..162185e75b83 100644\n--- a/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\n+++ b/src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp\n@@ -94,6 +94,7 @@ void registerInputFormatProcessorParquet(FormatFactory &factory)\n             {\n                 return std::make_shared<ParquetBlockInputFormat>(buf, sample);\n             });\n+    factory.markFormatAsColumnOriented(\"Parquet\");\n }\n \n }\ndiff --git a/src/Storages/StorageFile.cpp b/src/Storages/StorageFile.cpp\nindex 5524569e1f0d..56f08802bc40 100644\n--- a/src/Storages/StorageFile.cpp\n+++ b/src/Storages/StorageFile.cpp\n@@ -22,6 +22,8 @@\n #include <Common/escapeForFileName.h>\n #include <Common/typeid_cast.h>\n #include <Common/parseGlobs.h>\n+#include <Storages/ColumnsDescription.h>\n+#include <Storages/StorageInMemoryMetadata.h>\n \n #include <fcntl.h>\n #include <unistd.h>\n@@ -149,6 +151,11 @@ Strings StorageFile::getPathsList(const String & table_path, const String & user\n     return paths;\n }\n \n+bool StorageFile::isColumnOriented() const\n+{\n+    return format_name != \"Distributed\" && FormatFactory::instance().checkIfFormatIsColumnOriented(format_name);\n+}\n+\n StorageFile::StorageFile(int table_fd_, CommonArguments args)\n     : StorageFile(args)\n {\n@@ -227,6 +234,8 @@ static std::chrono::seconds getLockTimeout(const Context & context)\n     return std::chrono::seconds{lock_timeout};\n }\n \n+using StorageFilePtr = std::shared_ptr<StorageFile>;\n+\n \n class StorageFileSource : public SourceWithProgress\n {\n@@ -257,6 +266,18 @@ class StorageFileSource : public SourceWithProgress\n         return header;\n     }\n \n+    static Block getBlockForSource(\n+        const StorageFilePtr & storage,\n+        const StorageMetadataPtr & metadata_snapshot,\n+        const ColumnsDescription & columns_description,\n+        const FilesInfoPtr & files_info)\n+    {\n+        if (storage->isColumnOriented())\n+            return metadata_snapshot->getSampleBlockForColumns(columns_description.getNamesOfPhysical(), storage->getVirtuals(), storage->getStorageID());\n+        else\n+            return getHeader(metadata_snapshot, files_info->need_path_column, files_info->need_file_column);\n+    }\n+\n     StorageFileSource(\n         std::shared_ptr<StorageFile> storage_,\n         const StorageMetadataPtr & metadata_snapshot_,\n@@ -264,7 +285,7 @@ class StorageFileSource : public SourceWithProgress\n         UInt64 max_block_size_,\n         FilesInfoPtr files_info_,\n         ColumnsDescription columns_description_)\n-        : SourceWithProgress(getHeader(metadata_snapshot_, files_info_->need_path_column, files_info_->need_file_column))\n+        : SourceWithProgress(getBlockForSource(storage_, metadata_snapshot_, columns_description_, files_info_))\n         , storage(std::move(storage_))\n         , metadata_snapshot(metadata_snapshot_)\n         , files_info(std::move(files_info_))\n@@ -344,8 +365,16 @@ class StorageFileSource : public SourceWithProgress\n                 }\n \n                 read_buf = wrapReadBufferWithCompressionMethod(std::move(nested_buffer), method);\n+\n+                auto get_block_for_format = [&]() -> Block\n+                {\n+                    if (storage->isColumnOriented())\n+                        return metadata_snapshot->getSampleBlockForColumns(columns_description.getNamesOfPhysical());\n+                    return metadata_snapshot->getSampleBlock();\n+                };\n+\n                 auto format = FormatFactory::instance().getInput(\n-                        storage->format_name, *read_buf, metadata_snapshot->getSampleBlock(), context, max_block_size, storage->format_settings);\n+                    storage->format_name, *read_buf, get_block_for_format(), context, max_block_size, storage->format_settings);\n \n                 reader = std::make_shared<InputStreamFromInputFormat>(format);\n \n@@ -412,7 +441,6 @@ class StorageFileSource : public SourceWithProgress\n     std::unique_lock<std::shared_timed_mutex> unique_lock;\n };\n \n-\n Pipe StorageFile::read(\n     const Names & column_names,\n     const StorageMetadataPtr & metadata_snapshot,\n@@ -457,9 +485,16 @@ Pipe StorageFile::read(\n \n     for (size_t i = 0; i < num_streams; ++i)\n     {\n+        const auto get_columns_for_format = [&]() -> ColumnsDescription\n+        {\n+            if (isColumnOriented())\n+                return ColumnsDescription{\n+                    metadata_snapshot->getSampleBlockForColumns(column_names, getVirtuals(), getStorageID()).getNamesAndTypesList()};\n+            else\n+                return metadata_snapshot->getColumns();\n+        };\n         pipes.emplace_back(std::make_shared<StorageFileSource>(\n-            this_ptr, metadata_snapshot, context, max_block_size, files_info,\n-            metadata_snapshot->getColumns()));\n+            this_ptr, metadata_snapshot, context, max_block_size, files_info, get_columns_for_format()));\n     }\n \n     return Pipe::unitePipes(std::move(pipes));\ndiff --git a/src/Storages/StorageFile.h b/src/Storages/StorageFile.h\nindex c316412f808c..27f7419321ca 100644\n--- a/src/Storages/StorageFile.h\n+++ b/src/Storages/StorageFile.h\n@@ -64,6 +64,12 @@ class StorageFile final : public ext::shared_ptr_helper<StorageFile>, public ISt\n \n     static Strings getPathsList(const String & table_path, const String & user_files_path, const Context & context);\n \n+    /// Check if the format is column-oriented.\n+    /// Is is useful because column oriented formats could effectively skip unknown columns\n+    /// So we can create a header of only required columns in read method and ask\n+    /// format to read only them. Note: this hack cannot be done with ordinary formats like TSV.\n+    bool isColumnOriented() const;\n+\n protected:\n     friend class StorageFileSource;\n     friend class StorageFileBlockOutputStream;\ndiff --git a/src/Storages/StorageInMemoryMetadata.cpp b/src/Storages/StorageInMemoryMetadata.cpp\nindex 871ff38c07f6..2f4a24a5c60f 100644\n--- a/src/Storages/StorageInMemoryMetadata.cpp\n+++ b/src/Storages/StorageInMemoryMetadata.cpp\n@@ -291,9 +291,10 @@ Block StorageInMemoryMetadata::getSampleBlockForColumns(\n {\n     Block res;\n \n+    auto all_columns = getColumns().getAllWithSubcolumns();\n     std::unordered_map<String, DataTypePtr> columns_map;\n+    columns_map.reserve(all_columns.size());\n \n-    auto all_columns = getColumns().getAllWithSubcolumns();\n     for (const auto & elem : all_columns)\n         columns_map.emplace(elem.name, elem.type);\n \n@@ -306,15 +307,11 @@ Block StorageInMemoryMetadata::getSampleBlockForColumns(\n     {\n         auto it = columns_map.find(name);\n         if (it != columns_map.end())\n-        {\n             res.insert({it->second->createColumn(), it->second, it->first});\n-        }\n         else\n-        {\n             throw Exception(\n-                \"Column \" + backQuote(name) + \" not found in table \" + storage_id.getNameForLogs(),\n+                \"Column \" + backQuote(name) + \" not found in table \" + (storage_id.empty() ? \"\" : storage_id.getNameForLogs()),\n                 ErrorCodes::NOT_FOUND_COLUMN_IN_BLOCK);\n-        }\n     }\n \n     return res;\ndiff --git a/src/Storages/StorageInMemoryMetadata.h b/src/Storages/StorageInMemoryMetadata.h\nindex 038416aff7d6..00fb944c0b54 100644\n--- a/src/Storages/StorageInMemoryMetadata.h\n+++ b/src/Storages/StorageInMemoryMetadata.h\n@@ -85,9 +85,10 @@ struct StorageInMemoryMetadata\n \n     /// Returns combined set of columns\n     const ColumnsDescription & getColumns() const;\n-    /// Returns secondary indices\n \n+    /// Returns secondary indices\n     const IndicesDescription & getSecondaryIndices() const;\n+\n     /// Has at least one non primary index\n     bool hasSecondaryIndices() const;\n \n@@ -146,8 +147,7 @@ struct StorageInMemoryMetadata\n     /// Storage metadata. StorageID required only for more clear exception\n     /// message.\n     Block getSampleBlockForColumns(\n-        const Names & column_names, const NamesAndTypesList & virtuals, const StorageID & storage_id) const;\n-\n+        const Names & column_names, const NamesAndTypesList & virtuals = {}, const StorageID & storage_id = StorageID::createEmpty()) const;\n     /// Returns structure with partition key.\n     const KeyDescription & getPartitionKey() const;\n     /// Returns ASTExpressionList of partition key expression for storage or nullptr if there is none.\n",
  "test_patch": "diff --git a/tests/queries/1_stateful/00163_column_oriented_formats.reference b/tests/queries/1_stateful/00163_column_oriented_formats.reference\nnew file mode 100644\nindex 000000000000..cb20aca43925\n--- /dev/null\n+++ b/tests/queries/1_stateful/00163_column_oriented_formats.reference\n@@ -0,0 +1,12 @@\n+Parquet\n+6b397d4643bc1f920f3eb8aa87ee180c  -\n+7fe6d8c57ddc5fe37bbdcb7f73c5fa78  -\n+d8746733270cbeff7ab3550c9b944fb6  -\n+Arrow\n+6b397d4643bc1f920f3eb8aa87ee180c  -\n+7fe6d8c57ddc5fe37bbdcb7f73c5fa78  -\n+d8746733270cbeff7ab3550c9b944fb6  -\n+ORC\n+6b397d4643bc1f920f3eb8aa87ee180c  -\n+7fe6d8c57ddc5fe37bbdcb7f73c5fa78  -\n+d8746733270cbeff7ab3550c9b944fb6  -\ndiff --git a/tests/queries/1_stateful/00163_column_oriented_formats.sh b/tests/queries/1_stateful/00163_column_oriented_formats.sh\nnew file mode 100755\nindex 000000000000..1363ccf3c00c\n--- /dev/null\n+++ b/tests/queries/1_stateful/00163_column_oriented_formats.sh\n@@ -0,0 +1,20 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+\n+FORMATS=('Parquet' 'Arrow' 'ORC')\n+\n+for format in \"${FORMATS[@]}\"\n+do\n+    echo $format\n+    $CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS 00163_column_oriented SYNC\"\n+    $CLICKHOUSE_CLIENT -q \"CREATE TABLE 00163_column_oriented(ClientEventTime DateTime, MobilePhoneModel String, ClientIP6 FixedString(16)) ENGINE=File($format)\"\n+    $CLICKHOUSE_CLIENT -q \"INSERT INTO 00163_column_oriented SELECT ClientEventTime, MobilePhoneModel, ClientIP6 FROM test.hits ORDER BY ClientEventTime, MobilePhoneModel, ClientIP6 LIMIT 100\"\n+    $CLICKHOUSE_CLIENT -q \"SELECT ClientEventTime from 00163_column_oriented\" | md5sum\n+    $CLICKHOUSE_CLIENT -q \"SELECT MobilePhoneModel from 00163_column_oriented\" | md5sum\n+    $CLICKHOUSE_CLIENT -q \"SELECT ClientIP6 from 00163_column_oriented\" | md5sum\n+    $CLICKHOUSE_CLIENT -q \"DROP TABLE IF EXISTS 00163_column_oriented SYNC\"\n+done\n",
  "problem_statement": "InputFormat should allow to read subset of columns.\n**Use case**\r\n\r\n`File`-like table engine with column oriented format (Native, Parquet, Arrow) under the hood.\r\nFor more quick data import and for serverless data processing.\n",
  "hints_text": "I'd like to take this one~\nThank you, let's do it!",
  "created_at": "2021-03-29T13:48:24Z",
  "modified_files": [
    "src/Formats/FormatFactory.cpp",
    "src/Formats/FormatFactory.h",
    "src/Processors/Formats/Impl/ArrowBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/ORCBlockInputFormat.cpp",
    "src/Processors/Formats/Impl/ParquetBlockInputFormat.cpp",
    "src/Storages/StorageFile.cpp",
    "src/Storages/StorageFile.h",
    "src/Storages/StorageInMemoryMetadata.cpp",
    "src/Storages/StorageInMemoryMetadata.h"
  ],
  "modified_test_files": [
    "b/tests/queries/1_stateful/00163_column_oriented_formats.reference",
    "b/tests/queries/1_stateful/00163_column_oriented_formats.sh"
  ]
}