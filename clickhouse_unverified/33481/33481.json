{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 33481,
  "instance_id": "ClickHouse__ClickHouse-33481",
  "issue_numbers": [
    "20158"
  ],
  "base_commit": "ff645a062a306f20f844150766197604d13aac5f",
  "patch": "diff --git a/src/Parsers/CommonParsers.cpp b/src/Parsers/CommonParsers.cpp\nindex bffba4aa773a..275679d61f07 100644\n--- a/src/Parsers/CommonParsers.cpp\n+++ b/src/Parsers/CommonParsers.cpp\n@@ -3,6 +3,7 @@\n \n namespace DB\n {\n+\n bool ParserKeyword::parseImpl(Pos & pos, [[maybe_unused]] ASTPtr & node, Expected & expected)\n {\n     if (pos->type != TokenType::BareWord)\n@@ -36,4 +37,5 @@ bool ParserKeyword::parseImpl(Pos & pos, [[maybe_unused]] ASTPtr & node, Expecte\n \n     return true;\n }\n+\n }\ndiff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 5e2dd8e5c58f..526b3aeb2bd2 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -295,37 +295,37 @@ ASTPtr createFunctionCast(const ASTPtr & expr_ast, const ASTPtr & type_ast)\n \n namespace\n {\n-\n-class ParserCastAsExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"CAST AS expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseCastAs(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         /// expr AS type\n \n         ASTPtr expr_node;\n         ASTPtr type_node;\n \n-        if (ParserExpression().parse(pos, expr_node, expected)\n-            && ParserKeyword(\"AS\").ignore(pos, expected)\n-            && ParserDataType().parse(pos, type_node, expected))\n+        if (ParserExpression().parse(pos, expr_node, expected))\n         {\n-            node = createFunctionCast(expr_node, type_node);\n-            return true;\n+            if (ParserKeyword(\"AS\").ignore(pos, expected))\n+            {\n+                if (ParserDataType().parse(pos, type_node, expected))\n+                {\n+                    node = createFunctionCast(expr_node, type_node);\n+                    return true;\n+                }\n+            }\n+            else if (ParserToken(TokenType::Comma).ignore(pos, expected))\n+            {\n+                if (ParserExpression().parse(pos, type_node, expected))\n+                {\n+                    node = makeASTFunction(\"CAST\", expr_node, type_node);\n+                    return true;\n+                }\n+            }\n         }\n \n         return false;\n     }\n-};\n \n-class ParserSubstringExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"SUBSTRING expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseSubstring(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         /// Either SUBSTRING(expr FROM start) or SUBSTRING(expr FROM start FOR length) or SUBSTRING(expr, start, length)\n         /// The latter will be parsed normally as a function later.\n@@ -374,22 +374,8 @@ class ParserSubstringExpression : public IParserBase\n \n         return true;\n     }\n-};\n-\n-class ParserTrimExpression : public IParserBase\n-{\n-public:\n-    ParserTrimExpression(bool trim_left_, bool trim_right_)\n-        : trim_left(trim_left_), trim_right(trim_right_)\n-    {\n-    }\n-private:\n-    bool trim_left = false;\n-    bool trim_right = false;\n-\n-    const char * getName() const override { return \"TRIM expression\"; }\n \n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseTrim(bool trim_left, bool trim_right, IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         /// Handles all possible TRIM/LTRIM/RTRIM call variants\n \n@@ -516,19 +502,25 @@ class ParserTrimExpression : public IParserBase\n             node = makeASTFunction(func_name, expr_node);\n         return true;\n     }\n-};\n \n-class ParserExtractExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"EXTRACT expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseExtract(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         ASTPtr expr;\n \n         IntervalKind interval_kind;\n         if (!parseIntervalKind(pos, expected, interval_kind))\n-            return false;\n+        {\n+            ASTPtr expr_list;\n+            if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))\n+                return false;\n+\n+            auto res = std::make_shared<ASTFunction>();\n+            res->name = \"extract\";\n+            res->arguments = expr_list;\n+            res->children.push_back(res->arguments);\n+            node = std::move(res);\n+            return true;\n+        }\n \n         ParserKeyword s_from(\"FROM\");\n         if (!s_from.ignore(pos, expected))\n@@ -541,46 +533,37 @@ class ParserExtractExpression : public IParserBase\n         node = makeASTFunction(interval_kind.toNameOfFunctionExtractTimePart(), expr);\n         return true;\n     }\n-};\n \n-class ParserPositionExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"POSITION expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parsePosition(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n-        ParserExpression elem_parser;\n-\n-        ASTPtr in_expr;\n-        if (!ParserExpression().parse(pos, in_expr, expected))\n+        ASTPtr expr_list_node;\n+        if (!ParserExpressionList(false, false).parse(pos, expr_list_node, expected))\n             return false;\n \n-        auto * in_func = in_expr->as<ASTFunction>();\n-        if (!in_func || in_func->name != \"in\")\n-            return false;\n-\n-        auto & arg_list = in_func->arguments->as<ASTExpressionList &>();\n-        if (arg_list.children.size() != 2)\n-            return false;\n+        ASTExpressionList * expr_list = typeid_cast<ASTExpressionList *>(expr_list_node.get());\n+        if (expr_list && expr_list->children.size() == 1)\n+        {\n+            ASTFunction * func_in = typeid_cast<ASTFunction *>(expr_list->children[0].get());\n+            if (func_in && func_in->name == \"in\")\n+            {\n+                ASTExpressionList * in_args = typeid_cast<ASTExpressionList *>(func_in->arguments.get());\n+                if (in_args && in_args->children.size() == 2)\n+                {\n+                    node = makeASTFunction(\"position\", in_args->children[1], in_args->children[0]);\n+                    return true;\n+                }\n+            }\n+        }\n \n-        node = makeASTFunction(\"position\", arg_list.children[1], arg_list.children[0]);\n+        auto res = std::make_shared<ASTFunction>();\n+        res->name = \"position\";\n+        res->arguments = expr_list_node;\n+        res->children.push_back(res->arguments);\n+        node = std::move(res);\n         return true;\n     }\n-};\n \n-class ParserDateAddExpression : public IParserBase\n-{\n-public:\n-    explicit ParserDateAddExpression(const char * function_name_)\n-        : function_name(function_name_)\n-    {\n-    }\n-private:\n-    const char * function_name;\n-\n-    const char * getName() const override { return \"DATE_ADD expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseDateAdd(const char * function_name, IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         ASTPtr timestamp_node;\n         ASTPtr offset_node;\n@@ -613,36 +596,41 @@ class ParserDateAddExpression : public IParserBase\n         }\n         else\n         {\n-            /// function(timestamp, INTERVAL offset unit)\n-            if (!ParserExpression().parse(pos, timestamp_node, expected))\n+            ASTPtr expr_list;\n+            if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))\n                 return false;\n \n-            if (pos->type != TokenType::Comma)\n-                return false;\n-            ++pos;\n-\n-            if (!ParserIntervalOperatorExpression{}.parse(pos, interval_func_node, expected))\n-                return false;\n+            auto res = std::make_shared<ASTFunction>();\n+            res->name = function_name;\n+            res->arguments = expr_list;\n+            res->children.push_back(res->arguments);\n+            node = std::move(res);\n+            return true;\n         }\n \n         node = makeASTFunction(function_name, timestamp_node, interval_func_node);\n         return true;\n     }\n-};\n \n-class ParserDateDiffExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"DATE_DIFF expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseDateDiff(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         ASTPtr left_node;\n         ASTPtr right_node;\n \n         IntervalKind interval_kind;\n         if (!parseIntervalKind(pos, expected, interval_kind))\n-            return false;\n+        {\n+            ASTPtr expr_list;\n+            if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))\n+                return false;\n+\n+            auto res = std::make_shared<ASTFunction>();\n+            res->name = \"dateDiff\";\n+            res->arguments = expr_list;\n+            res->children.push_back(res->arguments);\n+            node = std::move(res);\n+            return true;\n+        }\n \n         if (pos->type != TokenType::Comma)\n             return false;\n@@ -661,13 +649,8 @@ class ParserDateDiffExpression : public IParserBase\n         node = makeASTFunction(\"dateDiff\", std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit()), left_node, right_node);\n         return true;\n     }\n-};\n \n-class ParserExistsExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"EXISTS subquery\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n+    bool parseExists(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n     {\n         if (!ParserSelectWithUnionQuery().parse(pos, node, expected))\n             return false;\n@@ -677,8 +660,6 @@ class ParserExistsExpression : public IParserBase\n         node = makeASTFunction(\"exists\", subquery);\n         return true;\n     }\n-};\n-\n }\n \n \n@@ -707,36 +688,66 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n         return false;\n     ++pos;\n \n+    /// Avoid excessive backtracking.\n+    //pos.putBarrier();\n+\n     /// Special cases for expressions that look like functions but contain some syntax sugar:\n+\n     /// CAST, EXTRACT, POSITION, EXISTS\n     /// DATE_ADD, DATEADD, TIMESTAMPADD, DATE_SUB, DATESUB, TIMESTAMPSUB,\n     /// DATE_DIFF, DATEDIFF, TIMESTAMPDIFF, TIMESTAMP_DIFF,\n-    /// SUBSTRING, TRIM, LEFT, RIGHT, POSITION\n+    /// SUBSTRING, TRIM, LTRIM, RTRIM, POSITION\n+\n+    /// Can be parsed as a composition of functions, but the contents must be unwrapped:\n+    /// POSITION(x IN y) -> POSITION(in(x, y)) -> POSITION(y, x)\n+\n+    /// Can be parsed as a function, but not always:\n+    /// CAST(x AS type) - alias has to be unwrapped\n+    /// CAST(x AS type(params))\n+\n+    /// Can be parsed as a function, but some identifier arguments have special meanings.\n+    /// DATE_ADD(MINUTE, x, y) -> addMinutes(x, y)\n+    /// DATE_DIFF(MINUTE, x, y)\n+\n+    /// Have keywords that have to processed explicitly:\n+    /// EXTRACT(x FROM y)\n+    /// TRIM(BOTH|LEADING|TRAILING x FROM y)\n+    /// SUBSTRING(x FROM a)\n+    /// SUBSTRING(x FROM a FOR b)\n \n     String function_name = getIdentifierName(identifier);\n     String function_name_lowercase = Poco::toLower(function_name);\n \n-    if (((function_name_lowercase == \"cast\" && ParserCastAsExpression().parse(pos, node, expected))\n-        || (function_name_lowercase == \"extract\" && ParserExtractExpression().parse(pos, node, expected))\n-        || (function_name_lowercase == \"substring\" && ParserSubstringExpression().parse(pos, node, expected))\n-        || (function_name_lowercase == \"position\" && ParserPositionExpression().parse(pos, node, expected))\n-        || (function_name_lowercase == \"exists\" && ParserExistsExpression().parse(pos, node, expected))\n-        || (function_name_lowercase == \"trim\" && ParserTrimExpression(false, false).parse(pos, node, expected))\n-        || (function_name_lowercase == \"ltrim\" && ParserTrimExpression(true, false).parse(pos, node, expected))\n-        || (function_name_lowercase == \"rtrim\" && ParserTrimExpression(false, true).parse(pos, node, expected))\n-        || ((function_name_lowercase == \"dateadd\" || function_name_lowercase == \"date_add\"\n-            || function_name_lowercase == \"timestampadd\" || function_name_lowercase == \"timestamp_add\")\n-            && ParserDateAddExpression(\"plus\").parse(pos, node, expected))\n-        || ((function_name_lowercase == \"datesub\" || function_name_lowercase == \"date_sub\"\n-            || function_name_lowercase == \"timestampsub\" || function_name_lowercase == \"timestamp_sub\")\n-            && ParserDateAddExpression(\"minus\").parse(pos, node, expected))\n-        || ((function_name_lowercase == \"datediff\" || function_name_lowercase == \"date_diff\"\n-            || function_name_lowercase == \"timestampdiff\" || function_name_lowercase == \"timestamp_diff\")\n-            && ParserDateDiffExpression().parse(pos, node, expected)))\n-        && ParserToken(TokenType::ClosingRoundBracket).ignore(pos))\n-    {\n-        return true;\n-    }\n+    std::optional<bool> parsed_special_function;\n+\n+    if (function_name_lowercase == \"cast\")\n+        parsed_special_function = parseCastAs(pos, node, expected);\n+    else if (function_name_lowercase == \"extract\")\n+        parsed_special_function = parseExtract(pos, node, expected);\n+    else if (function_name_lowercase == \"substring\")\n+        parsed_special_function = parseSubstring(pos, node, expected);\n+    else if (function_name_lowercase == \"position\")\n+        parsed_special_function = parsePosition(pos, node, expected);\n+    else if (function_name_lowercase == \"exists\")\n+        parsed_special_function = parseExists(pos, node, expected);\n+    else if (function_name_lowercase == \"trim\")\n+        parsed_special_function = parseTrim(false, false, pos, node, expected);\n+    else if (function_name_lowercase == \"ltrim\")\n+        parsed_special_function = parseTrim(true, false, pos, node, expected);\n+    else if (function_name_lowercase == \"rtrim\")\n+        parsed_special_function = parseTrim(false, true, pos, node, expected);\n+    else if (function_name_lowercase == \"dateadd\" || function_name_lowercase == \"date_add\"\n+        || function_name_lowercase == \"timestampadd\" || function_name_lowercase == \"timestamp_add\")\n+        parsed_special_function = parseDateAdd(\"plus\", pos, node, expected);\n+    else if (function_name_lowercase == \"datesub\" || function_name_lowercase == \"date_sub\"\n+        || function_name_lowercase == \"timestampsub\" || function_name_lowercase == \"timestamp_sub\")\n+        parsed_special_function = parseDateAdd(\"minus\", pos, node, expected);\n+    else if (function_name_lowercase == \"datediff\" || function_name_lowercase == \"date_diff\"\n+        || function_name_lowercase == \"timestampdiff\" || function_name_lowercase == \"timestamp_diff\")\n+        parsed_special_function = parseDateDiff(pos, node, expected);\n+\n+    if (parsed_special_function.has_value())\n+        return parsed_special_function.value() && ParserToken(TokenType::ClosingRoundBracket).ignore(pos);\n \n     auto pos_after_bracket = pos;\n     auto old_expected = expected;\n@@ -877,9 +888,7 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n         ParserFilterClause filter_parser;\n         if (!filter_parser.parse(pos, function_node_as_iast, expected))\n-        {\n             return false;\n-        }\n     }\n \n     if (over.ignore(pos, expected))\n@@ -890,9 +899,7 @@ bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n \n         ParserWindowReference window_reference;\n         if (!window_reference.parse(pos, function_node_as_iast, expected))\n-        {\n             return false;\n-        }\n     }\n \n     node = function_node;\ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 680d3f6031b8..96c1bad75c24 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -689,7 +689,7 @@ bool ParserUnaryExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expec\n bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr expr_ast;\n-    if (!elem_parser.parse(pos, expr_ast, expected))\n+    if (!ParserExpressionElement().parse(pos, expr_ast, expected))\n         return false;\n \n     ASTPtr type_ast;\ndiff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h\nindex e9389f15bbb5..a035d4a2ef0c 100644\n--- a/src/Parsers/ExpressionListParsers.h\n+++ b/src/Parsers/ExpressionListParsers.h\n@@ -203,9 +203,6 @@ class ParserPrefixUnaryOperatorExpression : public IParserBase\n /// Example: \"[1, 1 + 1, 1 + 2]::Array(UInt8)\"\n class ParserCastExpression : public IParserBase\n {\n-private:\n-    ParserExpressionElement elem_parser;\n-\n protected:\n     const char * getName() const override { return \"CAST expression\"; }\n \ndiff --git a/src/Parsers/IParser.h b/src/Parsers/IParser.h\nindex 64f117c707fd..4e6dbca15a68 100644\n--- a/src/Parsers/IParser.h\n+++ b/src/Parsers/IParser.h\n@@ -60,7 +60,9 @@ class IParser\n         uint32_t depth = 0;\n         uint32_t max_depth = 0;\n \n-        Pos(Tokens & tokens_, uint32_t max_depth_) : TokenIterator(tokens_), max_depth(max_depth_) {}\n+        Pos(Tokens & tokens_, uint32_t max_depth_) : TokenIterator(tokens_), max_depth(max_depth_)\n+        {\n+        }\n \n         ALWAYS_INLINE void increaseDepth()\n         {\ndiff --git a/src/Parsers/IParserBase.h b/src/Parsers/IParserBase.h\nindex ce08bdef7908..6fd195da40d2 100644\n--- a/src/Parsers/IParserBase.h\n+++ b/src/Parsers/IParserBase.h\n@@ -17,7 +17,7 @@ class IParserBase : public IParser\n         Pos begin = pos;\n         bool res = func();\n         if (!res)\n-          pos = begin;\n+            pos = begin;\n         return res;\n     }\n \n@@ -31,7 +31,7 @@ class IParserBase : public IParser\n         bool res = func();\n         pos.decreaseDepth();\n         if (!res)\n-          pos = begin;\n+            pos = begin;\n         return res;\n     }\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01503_if_const_optimization.reference b/tests/queries/0_stateless/01503_if_const_optimization.reference\nindex e69de29bb2d1..dec7d2fabd2e 100644\n--- a/tests/queries/0_stateless/01503_if_const_optimization.reference\n+++ b/tests/queries/0_stateless/01503_if_const_optimization.reference\n@@ -0,0 +1,1 @@\n+\\N\ndiff --git a/tests/queries/0_stateless/01503_if_const_optimization.sql b/tests/queries/0_stateless/01503_if_const_optimization.sql\nindex 047f6f757e80..a64be6bc80b0 100644\n--- a/tests/queries/0_stateless/01503_if_const_optimization.sql\n+++ b/tests/queries/0_stateless/01503_if_const_optimization.sql\n@@ -1,1 +1,1 @@\n-SELECT if(CAST(NULL), '2.55', NULL) AS x; -- { serverError 42 }\n+SELECT if(CAST(NULL AS Nullable(UInt8)), '2.55', NULL) AS x;\ndiff --git a/tests/queries/0_stateless/01534_lambda_array_join.sql b/tests/queries/0_stateless/01534_lambda_array_join.sql\nindex aee9dd1411aa..092c569b25fb 100644\n--- a/tests/queries/0_stateless/01534_lambda_array_join.sql\n+++ b/tests/queries/0_stateless/01534_lambda_array_join.sql\n@@ -6,7 +6,7 @@ SELECT\n         count() AS c\n     FROM numbers(10)\n     GROUP BY\n-        arrayMap(x -> reinterpretAsUInt8(substring(randomString(randomString(range(randomString(255), NULL)), NULL))), range(3)),\n+        arrayMap(x -> reinterpretAsUInt8(substring(randomString(randomString(range(randomString(255), NULL)), NULL), NULL)), range(3)),\n         randomString(range(randomString(1048577), NULL), NULL),\n         byte\n     ORDER BY byte ASC;\ndiff --git a/tests/queries/0_stateless/02154_parser_backtracking.reference b/tests/queries/0_stateless/02154_parser_backtracking.reference\nnew file mode 100644\nindex 000000000000..23751ef6c1fe\n--- /dev/null\n+++ b/tests/queries/0_stateless/02154_parser_backtracking.reference\n@@ -0,0 +1,14 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02154_parser_backtracking.sh b/tests/queries/0_stateless/02154_parser_backtracking.sh\nnew file mode 100755\nindex 000000000000..af0320080698\n--- /dev/null\n+++ b/tests/queries/0_stateless/02154_parser_backtracking.sh\n@@ -0,0 +1,25 @@\n+#!/usr/bin/env bash\n+\n+CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n+# shellcheck source=../shell_config.sh\n+. \"$CURDIR\"/../shell_config.sh\n+\n+# Should finish in reasonable time (milliseconds).\n+# In previous versions this query led to exponential backtracking.\n+\n+echo 'SELECT '\"$(perl -e 'print \"CAST(\" x 100')\"'a b c'\"$(perl -e 'print \")\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'Syntax error'\n+echo 'SELECT '\"$(perl -e 'print \"CAST(\" x 100')\"'a, b'\"$(perl -e 'print \")\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'Syntax error'\n+echo 'SELECT '\"$(perl -e 'print \"CAST(\" x 100')\"'a AS b'\"$(perl -e 'print \")\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'Syntax error'\n+echo 'SELECT '\"$(perl -e 'print \"CAST(\" x 100')\"'1'\"$(perl -e 'print \", '\"'UInt8'\"')\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000\n+echo 'SELECT '\"$(perl -e 'print \"CAST(\" x 100')\"'1'\"$(perl -e 'print \" AS UInt8)\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000\n+\n+echo \"SELECT fo,22222?LUTAY(SELECT(NOT CAUTAY(SELECT(NOT CAST(NOTT(NOT CAST(NOT NOT LEfT(NOT coARRAYlumnsFLuTAY(SELECT(NO0?LUTAY(SELECT(NOT CAUTAY(SELECT(NOT CAST(NOTT(NOT CAST(NOT NOT LEfT(NOT coARRAYlumnsFLuTAY(SELECT(NOTAYTAY(SELECT(NOTAYEFAULT(fo,22222?LUTAY(%SELECT(NOT CAST(NOT NOTAYTAY(SELECT(NOTAYEFAULT(fo,22222?LUTAY(SELECT(NOT CAST(NOT NOT (NOe)))))))))))))))))))))))))))))))))\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'Syntax error'\n+echo \"SELECT position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(a b))))))))))))))))))))\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'Syntax error'\n+echo \"SELECT position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(a, b))))))))))))))))))))\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'UNKNOWN_IDENTIFIER'\n+echo \"SELECT position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(a, b, c))))))))))))))))))))\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'UNKNOWN_IDENTIFIER'\n+\n+echo 'SELECT '\"$(perl -e 'print \"position(\" x 100')\"'x'\"$(perl -e 'print \")\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'UNKNOWN_IDENTIFIER'\n+echo 'SELECT '\"$(perl -e 'print \"position(\" x 100')\"'x y'\"$(perl -e 'print \")\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'Syntax error'\n+echo 'SELECT '\"$(perl -e 'print \"position(\" x 100')\"'x IN y'\"$(perl -e 'print \")\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'UNKNOWN_IDENTIFIER'\n+echo 'SELECT '\"$(perl -e 'print \"position(\" x 100')\"'x'\"$(perl -e 'print \" IN x)\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'UNKNOWN_IDENTIFIER'\n+echo 'SELECT '\"$(perl -e 'print \"position(\" x 100')\"'x'\"$(perl -e 'print \", x)\" x 100')\" | ${CLICKHOUSE_LOCAL} --max_parser_depth 10000 2>&1 | grep -cF 'UNKNOWN_IDENTIFIER'\ndiff --git a/tests/queries/0_stateless/02160_special_functions.reference b/tests/queries/0_stateless/02160_special_functions.reference\nnew file mode 100644\nindex 000000000000..3a1dcd889026\n--- /dev/null\n+++ b/tests/queries/0_stateless/02160_special_functions.reference\n@@ -0,0 +1,36 @@\n+1\n+[]\n+1\n+world\n+world\n+world\n+world\n+def\n+abc\n+bcde\n+abcdef\n+abcdef \n+ abcdef\n+2022\n+Hello\n+3\n+3\n+2023-01-01\n+2023-01-01\n+2023-01-01\n+2023-01-01\n+2023-01-01\n+2023-01-01\n+2023-01-01\n+2023-01-01\n+2021-01-01\n+2021-01-01\n+2021-01-01\n+2021-01-01\n+2021-01-01\n+2021-01-01\n+2021-01-01\n+2021-01-01\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02160_special_functions.sql b/tests/queries/0_stateless/02160_special_functions.sql\nnew file mode 100644\nindex 000000000000..6d18e7d0d250\n--- /dev/null\n+++ b/tests/queries/0_stateless/02160_special_functions.sql\n@@ -0,0 +1,44 @@\n+SELECT CAST(1 AS UInt8);\n+SELECT CAST([] AS Array(UInt8));\n+SELECT CAST(1, 'UInt8');\n+\n+SELECT SUBSTRING('Hello, world' FROM 8);\n+SELECT SUBSTRING('Hello, world' FROM 8 FOR 5);\n+SELECT SUBSTRING('Hello, world', 8);\n+SELECT SUBSTRING('Hello, world', 8, 5);\n+\n+SELECT TRIM(LEADING 'abc' FROM 'abcdef');\n+SELECT TRIM(TRAILING 'def' FROM 'abcdef');\n+SELECT TRIM(BOTH 'af' FROM 'abcdef');\n+SELECT TRIM(' abcdef ');\n+SELECT LTRIM(' abcdef ');\n+SELECT RTRIM(' abcdef ');\n+\n+SELECT EXTRACT(YEAR FROM DATE '2022-01-01');\n+SELECT EXTRACT('Hello, world', '^\\w+');\n+\n+SELECT POSITION('ll' IN 'Hello');\n+SELECT POSITION('Hello', 'll');\n+\n+SELECT DATE_ADD(YEAR, 1, DATE '2022-01-01');\n+SELECT DATE_ADD(INTERVAL 1 YEAR, DATE '2022-01-01');\n+SELECT DATEADD(YEAR, 1, DATE '2022-01-01');\n+SELECT DATEADD(INTERVAL 1 YEAR, DATE '2022-01-01');\n+SELECT TIMESTAMP_ADD(YEAR, 1, DATE '2022-01-01');\n+SELECT TIMESTAMP_ADD(INTERVAL 1 YEAR, DATE '2022-01-01');\n+SELECT TIMESTAMPADD(YEAR, 1, DATE '2022-01-01');\n+SELECT TIMESTAMPADD(INTERVAL 1 YEAR, DATE '2022-01-01');\n+\n+SELECT DATE_SUB(YEAR, 1, DATE '2022-01-01');\n+SELECT DATE_SUB(DATE '2022-01-01', INTERVAL 1 YEAR);\n+SELECT DATESUB(YEAR, 1, DATE '2022-01-01');\n+SELECT DATESUB(DATE '2022-01-01', INTERVAL 1 YEAR);\n+SELECT TIMESTAMP_SUB(YEAR, 1, DATE '2022-01-01');\n+SELECT TIMESTAMP_SUB(DATE '2022-01-01', INTERVAL 1 YEAR);\n+SELECT TIMESTAMPSUB(YEAR, 1, DATE '2022-01-01');\n+SELECT TIMESTAMPSUB(DATE '2022-01-01', INTERVAL 1 YEAR);\n+\n+SELECT DATE_DIFF(YEAR, DATE '2021-01-01', DATE '2022-01-01');\n+SELECT DATEDIFF(YEAR, DATE '2021-01-01', DATE '2022-01-01');\n+\n+SELECT EXISTS (SELECT 1);\n",
  "problem_statement": "The following query took 800 ms to parse.\nFound with fuzzing. See the attachment.\r\n[query.txt](https://github.com/ClickHouse/ClickHouse/files/5937426/query.txt)\r\n\r\nShould take 0.\n",
  "hints_text": "`SELECT fo,22222?LUTAY(SELECT(NOT CAUTAY(SELECT(NOT CAST(NOTT(NOT CAST(NOT NOT LEfT(NOT coARRAYlumnsFLuTAY(SELECT(NO0?LUTAY(SELECT(NOT CAUTAY(SELECT(NOT CAST(NOTT(NOT CAST(NOT NOT LEfT(NOT coARRAYlumnsFLuTAY(SELECT(NOTAYTAY(SELECT(NOTAYEFAULT(fo,22222?LUTAY(%SELECT(NOT CAST(NOT NOTAYTAY(SELECT(NOTAYEFAULT(fo,22222?LUTAY(SELECT(NOT CAST(NOT NOT (NOe)))))))))))))))))))))))))))))))))`\n`echo 'SELECT '$(perl -e 'print \"CAST(\" x 100')'a b c'$(perl -e 'print \")\" x 100') | clickhouse-local --max_parser_depth 10000`\n`SELECT position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(position(a b))))))))))))))))))))`",
  "created_at": "2022-01-09T05:28:42Z",
  "modified_files": [
    "src/Parsers/CommonParsers.cpp",
    "src/Parsers/ExpressionElementParsers.cpp",
    "src/Parsers/ExpressionListParsers.cpp",
    "src/Parsers/ExpressionListParsers.h",
    "src/Parsers/IParser.h",
    "src/Parsers/IParserBase.h"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01503_if_const_optimization.reference",
    "tests/queries/0_stateless/01503_if_const_optimization.sql",
    "tests/queries/0_stateless/01534_lambda_array_join.sql",
    "b/tests/queries/0_stateless/02154_parser_backtracking.reference",
    "b/tests/queries/0_stateless/02154_parser_backtracking.sh",
    "b/tests/queries/0_stateless/02160_special_functions.reference",
    "b/tests/queries/0_stateless/02160_special_functions.sql"
  ]
}