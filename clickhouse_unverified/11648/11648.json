{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 11648,
  "instance_id": "ClickHouse__ClickHouse-11648",
  "issue_numbers": [
    "11630"
  ],
  "base_commit": "561d4b5b0108b300746d9a03978d7dfa75d58a36",
  "patch": "diff --git a/src/Common/Arena.h b/src/Common/Arena.h\nindex d203a92d4a3d..44a9b444ff23 100644\n--- a/src/Common/Arena.h\n+++ b/src/Common/Arena.h\n@@ -4,10 +4,10 @@\n #include <memory>\n #include <vector>\n #include <boost/noncopyable.hpp>\n-#if __has_include(<sanitizer/asan_interface.h>)\n+#include <Core/Defines.h>\n+#if __has_include(<sanitizer/asan_interface.h>) && defined(ADDRESS_SANITIZER)\n #   include <sanitizer/asan_interface.h>\n #endif\n-#include <Core/Defines.h>\n #include <Common/memcpySmall.h>\n #include <Common/ProfileEvents.h>\n #include <Common/Allocator.h>\ndiff --git a/src/Common/ArenaWithFreeLists.h b/src/Common/ArenaWithFreeLists.h\nindex 6092f03ce191..1284c3586c0a 100644\n--- a/src/Common/ArenaWithFreeLists.h\n+++ b/src/Common/ArenaWithFreeLists.h\n@@ -1,9 +1,9 @@\n #pragma once\n \n-#if __has_include(<sanitizer/asan_interface.h>)\n+#include <Core/Defines.h>\n+#if __has_include(<sanitizer/asan_interface.h>) && defined(ADDRESS_SANITIZER)\n #   include <sanitizer/asan_interface.h>\n #endif\n-#include <Core/Defines.h>\n #include <Common/Arena.h>\n #include <Common/BitHelpers.h>\n \ndiff --git a/src/Common/FieldVisitors.h b/src/Common/FieldVisitors.h\nindex 90f80974ab12..ddeddb8fbf69 100644\n--- a/src/Common/FieldVisitors.h\n+++ b/src/Common/FieldVisitors.h\n@@ -1,7 +1,6 @@\n #pragma once\n \n #include <Core/Field.h>\n-#include <Core/AccurateComparison.h>\n #include <common/demangle.h>\n \n \n@@ -14,7 +13,6 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int CANNOT_CONVERT_TYPE;\n-    extern const int BAD_TYPE_OF_FIELD;\n     extern const int LOGICAL_ERROR;\n }\n \n@@ -177,243 +175,6 @@ template <> constexpr bool isDecimalField<DecimalField<Decimal64>>() { return tr\n template <> constexpr bool isDecimalField<DecimalField<Decimal128>>() { return true; }\n \n \n-/** More precise comparison, used for index.\n-  * Differs from Field::operator< and Field::operator== in that it also compares values of different types.\n-  * Comparison rules are same as in FunctionsComparison (to be consistent with expression evaluation in query).\n-  */\n-class FieldVisitorAccurateEquals : public StaticVisitor<bool>\n-{\n-public:\n-    bool operator() (const UInt64 &, const Null &)          const { return false; }\n-    bool operator() (const UInt64 & l, const UInt64 & r)    const { return l == r; }\n-    bool operator() (const UInt64 & l, const UInt128 & r)   const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const Int64 & r)     const { return accurate::equalsOp(l, r); }\n-    bool operator() (const UInt64 & l, const Float64 & r)   const { return accurate::equalsOp(l, r); }\n-    bool operator() (const UInt64 & l, const String & r)    const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const Array & r)     const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const Tuple & r)     const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const AggregateFunctionStateData & r) const { return cantCompare(l, r); }\n-\n-    bool operator() (const Int64 &, const Null &)           const { return false; }\n-    bool operator() (const Int64 & l, const UInt64 & r)     const { return accurate::equalsOp(l, r); }\n-    bool operator() (const Int64 & l, const UInt128 & r)    const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const Int64 & r)      const { return l == r; }\n-    bool operator() (const Int64 & l, const Float64 & r)    const { return accurate::equalsOp(l, r); }\n-    bool operator() (const Int64 & l, const String & r)     const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const Array & r)      const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const Tuple & r)      const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const AggregateFunctionStateData & r) const { return cantCompare(l, r); }\n-\n-    bool operator() (const Float64 &, const Null &)         const { return false; }\n-    bool operator() (const Float64 & l, const UInt64 & r)   const { return accurate::equalsOp(l, r); }\n-    bool operator() (const Float64 & l, const UInt128 & r)  const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const Int64 & r)    const { return accurate::equalsOp(l, r); }\n-    bool operator() (const Float64 & l, const Float64 & r)  const { return l == r; }\n-    bool operator() (const Float64 & l, const String & r)   const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const Array & r)    const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const Tuple & r)    const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const AggregateFunctionStateData & r) const { return cantCompare(l, r); }\n-\n-    template <typename T>\n-    bool operator() (const Null &, const T &) const\n-    {\n-        return std::is_same_v<T, Null>;\n-    }\n-\n-    template <typename T>\n-    bool operator() (const String & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, String>)\n-            return l == r;\n-        if constexpr (std::is_same_v<T, UInt128>)\n-            return stringToUUID(l) == r;\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T>\n-    bool operator() (const UInt128 & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, UInt128>)\n-            return l == r;\n-        if constexpr (std::is_same_v<T, String>)\n-            return l == stringToUUID(r);\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T>\n-    bool operator() (const Array & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, Array>)\n-            return l == r;\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T>\n-    bool operator() (const Tuple & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, Tuple>)\n-            return l == r;\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T, typename U>\n-    bool operator() (const DecimalField<T> & l, const U & r) const\n-    {\n-        if constexpr (isDecimalField<U>())\n-            return l == r;\n-        if constexpr (std::is_same_v<U, Int64> || std::is_same_v<U, UInt64>)\n-            return l == DecimalField<Decimal128>(r, 0);\n-        if constexpr (std::is_same_v<U, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T> bool operator() (const UInt64 & l, const DecimalField<T> & r) const { return DecimalField<Decimal128>(l, 0) == r; }\n-    template <typename T> bool operator() (const Int64 & l, const DecimalField<T> & r) const { return DecimalField<Decimal128>(l, 0) == r; }\n-    template <typename T> bool operator() (const Float64 & l, const DecimalField<T> & r) const { return cantCompare(l, r); }\n-\n-    template <typename T>\n-    bool operator() (const AggregateFunctionStateData & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, AggregateFunctionStateData>)\n-            return l == r;\n-        return cantCompare(l, r);\n-    }\n-\n-private:\n-    template <typename T, typename U>\n-    bool cantCompare(const T &, const U &) const\n-    {\n-        if constexpr (std::is_same_v<U, Null>)\n-            return false;\n-        throw Exception(\"Cannot compare \" + demangle(typeid(T).name()) + \" with \" + demangle(typeid(U).name()),\n-                        ErrorCodes::BAD_TYPE_OF_FIELD);\n-    }\n-};\n-\n-class FieldVisitorAccurateLess : public StaticVisitor<bool>\n-{\n-public:\n-    bool operator() (const UInt64 &, const Null &)          const { return false; }\n-    bool operator() (const UInt64 & l, const UInt64 & r)    const { return l < r; }\n-    bool operator() (const UInt64 & l, const UInt128 & r)   const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const Int64 & r)     const { return accurate::lessOp(l, r); }\n-    bool operator() (const UInt64 & l, const Float64 & r)   const { return accurate::lessOp(l, r); }\n-    bool operator() (const UInt64 & l, const String & r)    const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const Array & r)     const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const Tuple & r)     const { return cantCompare(l, r); }\n-    bool operator() (const UInt64 & l, const AggregateFunctionStateData & r) const { return cantCompare(l, r); }\n-\n-    bool operator() (const Int64 &, const Null &)           const { return false; }\n-    bool operator() (const Int64 & l, const UInt64 & r)     const { return accurate::lessOp(l, r); }\n-    bool operator() (const Int64 & l, const UInt128 & r)    const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const Int64 & r)      const { return l < r; }\n-    bool operator() (const Int64 & l, const Float64 & r)    const { return accurate::lessOp(l, r); }\n-    bool operator() (const Int64 & l, const String & r)     const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const Array & r)      const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const Tuple & r)      const { return cantCompare(l, r); }\n-    bool operator() (const Int64 & l, const AggregateFunctionStateData & r) const { return cantCompare(l, r); }\n-\n-    bool operator() (const Float64 &, const Null &)         const { return false; }\n-    bool operator() (const Float64 & l, const UInt64 & r)   const { return accurate::lessOp(l, r); }\n-    bool operator() (const Float64 & l, const UInt128 & r)  const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const Int64 & r)    const { return accurate::lessOp(l, r); }\n-    bool operator() (const Float64 & l, const Float64 & r)  const { return l < r; }\n-    bool operator() (const Float64 & l, const String & r)   const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const Array & r)    const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const Tuple & r)    const { return cantCompare(l, r); }\n-    bool operator() (const Float64 & l, const AggregateFunctionStateData & r) const { return cantCompare(l, r); }\n-\n-    template <typename T>\n-    bool operator() (const Null &, const T &) const\n-    {\n-        return !std::is_same_v<T, Null>;\n-    }\n-\n-    template <typename T>\n-    bool operator() (const String & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, String>)\n-            return l < r;\n-        if constexpr (std::is_same_v<T, UInt128>)\n-            return stringToUUID(l) < r;\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T>\n-    bool operator() (const UInt128 & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, UInt128>)\n-            return l < r;\n-        if constexpr (std::is_same_v<T, String>)\n-            return l < stringToUUID(r);\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T>\n-    bool operator() (const Array & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, Array>)\n-            return l < r;\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T>\n-    bool operator() (const Tuple & l, const T & r) const\n-    {\n-        if constexpr (std::is_same_v<T, Tuple>)\n-            return l < r;\n-        if constexpr (std::is_same_v<T, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T, typename U>\n-    bool operator() (const DecimalField<T> & l, const U & r) const\n-    {\n-        if constexpr (isDecimalField<U>())\n-            return l < r;\n-        if constexpr (std::is_same_v<U, Int64> || std::is_same_v<U, UInt64>)\n-            return l < DecimalField<Decimal128>(r, 0);\n-        if constexpr (std::is_same_v<U, Null>)\n-            return false;\n-        return cantCompare(l, r);\n-    }\n-\n-    template <typename T> bool operator() (const UInt64 & l, const DecimalField<T> & r) const { return DecimalField<Decimal128>(l, 0) < r; }\n-    template <typename T> bool operator() (const Int64 & l, const DecimalField<T> & r) const { return DecimalField<Decimal128>(l, 0) < r; }\n-    template <typename T> bool operator() (const Float64 &, const DecimalField<T> &) const { return false; }\n-\n-    template <typename T>\n-    bool operator() (const AggregateFunctionStateData & l, const T & r) const\n-    {\n-        return cantCompare(l, r);\n-    }\n-\n-private:\n-    template <typename T, typename U>\n-    bool cantCompare(const T &, const U &) const\n-    {\n-        throw Exception(\"Cannot compare \" + demangle(typeid(T).name()) + \" with \" + demangle(typeid(U).name()),\n-                        ErrorCodes::BAD_TYPE_OF_FIELD);\n-    }\n-};\n-\n-\n /** Implements `+=` operation.\n  *  Returns false if the result is zero.\n  */\ndiff --git a/src/Common/FieldVisitorsAccurateComparison.h b/src/Common/FieldVisitorsAccurateComparison.h\nnew file mode 100644\nindex 000000000000..91fa4bf28def\n--- /dev/null\n+++ b/src/Common/FieldVisitorsAccurateComparison.h\n@@ -0,0 +1,142 @@\n+#pragma once\n+\n+#include <Core/Field.h>\n+#include <Core/AccurateComparison.h>\n+#include <common/demangle.h>\n+#include <Common/FieldVisitors.h>\n+#include <IO/ReadBufferFromString.h>\n+#include <IO/ReadHelpers.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_TYPE_OF_FIELD;\n+}\n+\n+/** More precise comparison, used for index.\n+  * Differs from Field::operator< and Field::operator== in that it also compares values of different types.\n+  * Comparison rules are same as in FunctionsComparison (to be consistent with expression evaluation in query).\n+  */\n+class FieldVisitorAccurateEquals : public StaticVisitor<bool>\n+{\n+public:\n+    template <typename T, typename U>\n+    bool operator() (const T & l, const U & r) const\n+    {\n+        if constexpr (std::is_same_v<T, Null> || std::is_same_v<U, Null>)\n+            return std::is_same_v<T, U>;\n+        else\n+        {\n+            if constexpr (std::is_same_v<T, U>)\n+                return l == r;\n+\n+            if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)\n+                return accurate::equalsOp(l, r);\n+\n+            if constexpr (isDecimalField<T>() && isDecimalField<U>())\n+                return l == r;\n+\n+            if constexpr (isDecimalField<T>() && std::is_arithmetic_v<U>)\n+                return l == DecimalField<Decimal128>(r, 0);\n+\n+            if constexpr (std::is_arithmetic_v<T> && isDecimalField<U>())\n+                return DecimalField<Decimal128>(l, 0) == r;\n+\n+            if constexpr (std::is_same_v<T, String>)\n+            {\n+                if constexpr (std::is_same_v<U, UInt128>)\n+                    return stringToUUID(l) == r;\n+\n+                if constexpr (std::is_arithmetic_v<U>)\n+                {\n+                    ReadBufferFromString in(l);\n+                    T parsed;\n+                    readText(parsed, in);\n+                    return operator()(parsed, r);\n+                }\n+            }\n+\n+            if constexpr (std::is_same_v<U, String>)\n+            {\n+                if constexpr (std::is_same_v<T, UInt128>)\n+                    return l == stringToUUID(r);\n+\n+                if constexpr (std::is_arithmetic_v<T>)\n+                {\n+                    ReadBufferFromString in(r);\n+                    T parsed;\n+                    readText(parsed, in);\n+                    return operator()(l, parsed);\n+                }\n+            }\n+        }\n+\n+        throw Exception(\"Cannot compare \" + demangle(typeid(T).name()) + \" with \" + demangle(typeid(U).name()),\n+            ErrorCodes::BAD_TYPE_OF_FIELD);\n+    }\n+};\n+\n+\n+class FieldVisitorAccurateLess : public StaticVisitor<bool>\n+{\n+public:\n+    template <typename T, typename U>\n+    bool operator() (const T & l, const U & r) const\n+    {\n+        if constexpr (std::is_same_v<T, Null> || std::is_same_v<U, Null>)\n+            return false;\n+        else\n+        {\n+            if constexpr (std::is_same_v<T, U>)\n+                return l < r;\n+\n+            if constexpr (std::is_arithmetic_v<T> && std::is_arithmetic_v<U>)\n+                return accurate::lessOp(l, r);\n+\n+            if constexpr (isDecimalField<T>() && isDecimalField<U>())\n+                return l < r;\n+\n+            if constexpr (isDecimalField<T>() && std::is_arithmetic_v<U>)\n+                return l < DecimalField<Decimal128>(r, 0);\n+\n+            if constexpr (std::is_arithmetic_v<T> && isDecimalField<U>())\n+                return DecimalField<Decimal128>(l, 0) < r;\n+\n+            if constexpr (std::is_same_v<T, String>)\n+            {\n+                if constexpr (std::is_same_v<U, UInt128>)\n+                    return stringToUUID(l) < r;\n+\n+                if constexpr (std::is_arithmetic_v<U>)\n+                {\n+                    ReadBufferFromString in(l);\n+                    T parsed;\n+                    readText(parsed, in);\n+                    return operator()(parsed, r);\n+                }\n+            }\n+\n+            if constexpr (std::is_same_v<U, String>)\n+            {\n+                if constexpr (std::is_same_v<T, UInt128>)\n+                    return l < stringToUUID(r);\n+\n+                if constexpr (std::is_arithmetic_v<T>)\n+                {\n+                    ReadBufferFromString in(r);\n+                    T parsed;\n+                    readText(parsed, in);\n+                    return operator()(l, parsed);\n+                }\n+            }\n+        }\n+\n+        throw Exception(\"Cannot compare \" + demangle(typeid(T).name()) + \" with \" + demangle(typeid(U).name()),\n+            ErrorCodes::BAD_TYPE_OF_FIELD);\n+    }\n+};\n+\n+}\ndiff --git a/src/Core/Defines.h b/src/Core/Defines.h\nindex 13070c565b48..8b26f486c9d4 100644\n--- a/src/Core/Defines.h\n+++ b/src/Core/Defines.h\n@@ -87,7 +87,7 @@\n #define DBMS_DISTRIBUTED_SIGNATURE_HEADER 0xCAFEDACEull\n #define DBMS_DISTRIBUTED_SIGNATURE_HEADER_OLD_FORMAT 0xCAFECABEull\n \n-#if !__has_include(<sanitizer/asan_interface.h>)\n+#if !__has_include(<sanitizer/asan_interface.h>) || !defined(ADDRESS_SANITIZER)\n #   define ASAN_UNPOISON_MEMORY_REGION(a, b)\n #   define ASAN_POISON_MEMORY_REGION(a, b)\n #endif\ndiff --git a/src/DataTypes/DataTypeDateTime64.h b/src/DataTypes/DataTypeDateTime64.h\nindex b575e9d81c13..249da255eb0f 100644\n--- a/src/DataTypes/DataTypeDateTime64.h\n+++ b/src/DataTypes/DataTypeDateTime64.h\n@@ -45,6 +45,8 @@ class DataTypeDateTime64 final : public DataTypeDecimalBase<DateTime64>, public\n     void deserializeProtobuf(IColumn & column, ProtobufReader & protobuf, bool allow_add_row, bool & row_added) const override;\n \n     bool equals(const IDataType & rhs) const override;\n+\n+    bool canBePromoted() const override { return false; }\n };\n \n /** Tansform-type wrapper for DateTime64, applies given Transform to DateTime64 value or only to a whole part of it.\ndiff --git a/src/DataTypes/DataTypeUUID.cpp b/src/DataTypes/DataTypeUUID.cpp\nindex 87e306cf4772..94a043eb4724 100644\n--- a/src/DataTypes/DataTypeUUID.cpp\n+++ b/src/DataTypes/DataTypeUUID.cpp\n@@ -16,13 +16,18 @@ void DataTypeUUID::serializeText(const IColumn & column, size_t row_num, WriteBu\n     writeText(UUID(assert_cast<const ColumnUInt128 &>(column).getData()[row_num]), ostr);\n }\n \n-void DataTypeUUID::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n+void DataTypeUUID::deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const\n {\n     UUID x;\n     readText(x, istr);\n     assert_cast<ColumnUInt128 &>(column).getData().push_back(x);\n }\n \n+void DataTypeUUID::deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings & settings) const\n+{\n+    deserializeText(column, istr, settings);\n+}\n+\n void DataTypeUUID::serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings & settings) const\n {\n     serializeText(column, row_num, ostr, settings);\ndiff --git a/src/DataTypes/DataTypeUUID.h b/src/DataTypes/DataTypeUUID.h\nindex 75e634bc625f..e9f1d22325bd 100644\n--- a/src/DataTypes/DataTypeUUID.h\n+++ b/src/DataTypes/DataTypeUUID.h\n@@ -17,6 +17,7 @@ class DataTypeUUID final : public DataTypeNumberBase<UInt128>\n     bool equals(const IDataType & rhs) const override;\n \n     void serializeText(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n+    void deserializeText(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextEscaped(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n     void deserializeTextEscaped(IColumn & column, ReadBuffer & istr, const FormatSettings &) const override;\n     void serializeTextQuoted(const IColumn & column, size_t row_num, WriteBuffer & ostr, const FormatSettings &) const override;\n@@ -30,6 +31,8 @@ class DataTypeUUID final : public DataTypeNumberBase<UInt128>\n \n     bool canBeUsedInBitOperations() const override { return true; }\n     bool canBeInsideNullable() const override { return true; }\n+\n+    bool canBePromoted() const override { return false; }\n };\n \n }\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 642995974b5d..91525f84c14a 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -22,6 +22,7 @@\n #include <DataTypes/DataTypeEnum.h>\n #include <DataTypes/getLeastSupertype.h>\n \n+#include <Interpreters/convertFieldToType.h>\n #include <Interpreters/castColumn.h>\n \n #include <Functions/IFunctionAdaptors.h>\n@@ -51,7 +52,6 @@ namespace DB\n \n namespace ErrorCodes\n {\n-    extern const int TOO_LARGE_STRING_SIZE;\n     extern const int ILLEGAL_COLUMN;\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int LOGICAL_ERROR;\n@@ -812,92 +812,49 @@ class FunctionComparison : public IFunction\n         }\n     }\n \n-    bool executeDateOrDateTimeOrEnumOrUUIDWithConstString(\n+    bool executeWithConstString(\n         Block & block, size_t result, const IColumn * col_left_untyped, const IColumn * col_right_untyped,\n-        const DataTypePtr & left_type, const DataTypePtr & right_type, bool left_is_num, size_t input_rows_count)\n+        const DataTypePtr & left_type, const DataTypePtr & right_type, size_t input_rows_count)\n     {\n-        /// This is no longer very special case - comparing dates, datetimes, and enumerations with a string constant.\n-        const IColumn * column_string_untyped = !left_is_num ? col_left_untyped : col_right_untyped;\n-        const IColumn * column_number = left_is_num ? col_left_untyped : col_right_untyped;\n-        const IDataType * number_type = left_is_num ? left_type.get() : right_type.get();\n+        /// To compare something with const string, we cast constant to appropriate type and compare as usual.\n+        /// It is ok to throw exception if value is not convertible.\n+        /// We should deal with possible overflows, e.g. toUInt8(1) = '257' should return false.\n \n-        WhichDataType which(number_type);\n+        const ColumnConst * left_const = checkAndGetColumnConstStringOrFixedString(col_left_untyped);\n+        const ColumnConst * right_const = checkAndGetColumnConstStringOrFixedString(col_right_untyped);\n \n-        const bool legal_types = which.isDateOrDateTime() || which.isEnum() || which.isUUID();\n-\n-        const auto column_string = checkAndGetColumnConst<ColumnString>(column_string_untyped);\n-        if (!column_string || !legal_types)\n+        if (!left_const && !right_const)\n             return false;\n \n-        StringRef string_value = column_string->getDataAt(0);\n+        const IDataType * type_string = left_const ? left_type.get() : right_type.get();\n+        const DataTypePtr & type_to_compare = !left_const ? left_type : right_type;\n \n-        if (which.isDate())\n-        {\n-            DayNum date;\n-            ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readDateText(date, in);\n-            if (!in.eof())\n-                throw Exception(\"String is too long for Date: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-            ColumnPtr parsed_const_date_holder = DataTypeDate().createColumnConst(input_rows_count, date);\n-            const ColumnConst * parsed_const_date = assert_cast<const ColumnConst *>(parsed_const_date_holder.get());\n-            executeNumLeftType<DataTypeDate::FieldType>(block, result,\n-                left_is_num ? col_left_untyped : parsed_const_date,\n-                left_is_num ? parsed_const_date : col_right_untyped);\n-        }\n-        else if (which.isDateTime())\n+        Field string_value = left_const ? left_const->getField() : right_const->getField();\n+        Field converted = convertFieldToType(string_value, *type_to_compare, type_string);\n+\n+        /// If not possible to convert, comparison with =, <, >, <=, >= yields to false and comparison with != yields to true.\n+        if (converted.isNull())\n         {\n-            time_t date_time;\n-            ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readDateTimeText(date_time, in, dynamic_cast<const DataTypeDateTime &>(*number_type).getTimeZone());\n-            if (!in.eof())\n-                throw Exception(\"String is too long for DateTime: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-            ColumnPtr parsed_const_date_time_holder = DataTypeDateTime().createColumnConst(input_rows_count, UInt64(date_time));\n-            const ColumnConst * parsed_const_date_time = assert_cast<const ColumnConst *>(parsed_const_date_time_holder.get());\n-            executeNumLeftType<DataTypeDateTime::FieldType>(block, result,\n-                left_is_num ? col_left_untyped : parsed_const_date_time,\n-                left_is_num ? parsed_const_date_time : col_right_untyped);\n+            block.getByPosition(result).column = DataTypeUInt8().createColumnConst(input_rows_count,\n+                std::is_same_v<Op<int, int>, NotEqualsOp<int, int>>);\n         }\n-        else if (which.isUUID())\n+        else\n         {\n-            UUID uuid;\n-            ReadBufferFromMemory in(string_value.data, string_value.size);\n-            readText(uuid, in);\n-            if (!in.eof())\n-                throw Exception(\"String is too long for UUID: \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-            ColumnPtr parsed_const_uuid_holder = DataTypeUUID().createColumnConst(input_rows_count, uuid);\n-            const ColumnConst * parsed_const_uuid = assert_cast<const ColumnConst *>(parsed_const_uuid_holder.get());\n-            executeNumLeftType<DataTypeUUID::FieldType>(block, result,\n-                left_is_num ? col_left_untyped : parsed_const_uuid,\n-                left_is_num ? parsed_const_uuid : col_right_untyped);\n-        }\n-\n-        else if (which.isEnum8())\n-            executeEnumWithConstString<DataTypeEnum8>(block, result, column_number, column_string,\n-                number_type, left_is_num, input_rows_count);\n-        else if (which.isEnum16())\n-            executeEnumWithConstString<DataTypeEnum16>(block, result, column_number, column_string,\n-                number_type, left_is_num, input_rows_count);\n+            auto column_converted = type_to_compare->createColumnConst(input_rows_count, converted);\n \n-        return true;\n-    }\n+            Block tmp_block\n+            {\n+                { left_const ? column_converted : col_left_untyped->getPtr(), type_to_compare, \"\" },\n+                { !left_const ? column_converted : col_right_untyped->getPtr(), type_to_compare, \"\" },\n+                block.getByPosition(result)\n+            };\n \n-    /// Comparison between DataTypeEnum<T> and string constant containing the name of an enum element\n-    template <typename EnumType>\n-    void executeEnumWithConstString(\n-        Block & block, const size_t result, const IColumn * column_number, const ColumnConst * column_string,\n-        const IDataType * type_untyped, const bool left_is_num, size_t input_rows_count)\n-    {\n-        const auto type = static_cast<const EnumType *>(type_untyped);\n+            executeImpl(tmp_block, {0, 1}, 2, input_rows_count);\n \n-        const Field x = castToNearestFieldType(type->getValue(column_string->getValue<String>()));\n-        const auto enum_col = type->createColumnConst(input_rows_count, x);\n+            block.getByPosition(result).column = std::move(tmp_block.getByPosition(2).column);\n+        }\n \n-        executeNumLeftType<typename EnumType::FieldType>(block, result,\n-            left_is_num ? column_number : enum_col.get(),\n-            left_is_num ? enum_col.get() : column_number);\n+        return true;\n     }\n \n     void executeTuple(Block & block, size_t result, const ColumnWithTypeAndName & c0, const ColumnWithTypeAndName & c1,\n@@ -1124,17 +1081,11 @@ class FunctionComparison : public IFunction\n         bool has_date = left.isDate() || right.isDate();\n \n         if (!((both_represented_by_number && !has_date)   /// Do not allow compare date and number.\n-            || (left.isStringOrFixedString() && right.isStringOrFixedString())\n+            || (left.isStringOrFixedString() || right.isStringOrFixedString())  /// Everything can be compared with string by conversion.\n             /// You can compare the date, datetime, or datatime64 and an enumeration with a constant string.\n-            || (left.isString() && right.isDateOrDateTime())\n-            || (left.isDateOrDateTime() && right.isString())\n             || (left.isDateOrDateTime() && right.isDateOrDateTime() && left.idx == right.idx) /// only date vs date, or datetime vs datetime\n             || (left.isUUID() && right.isUUID())\n-            || (left.isUUID() && right.isString())\n-            || (left.isString() && right.isUUID())\n             || (left.isEnum() && right.isEnum() && arguments[0]->getName() == arguments[1]->getName()) /// only equivalent enum type values can be compared against\n-            || (left.isEnum() && right.isString())\n-            || (left.isString() && right.isEnum())\n             || (left_tuple && right_tuple && left_tuple->getElements().size() == right_tuple->getElements().size())\n             || (arguments[0]->equals(*arguments[1]))))\n         {\n@@ -1151,7 +1102,8 @@ class FunctionComparison : public IFunction\n \n         if (left_tuple && right_tuple)\n         {\n-            auto adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(FunctionComparison<Op, Name>::create(context)));\n+            auto adaptor = FunctionOverloadResolverAdaptor(std::make_unique<DefaultOverloadResolver>(\n+                FunctionComparison<Op, Name>::create(context)));\n \n             size_t size = left_tuple->getElements().size();\n             for (size_t i = 0; i < size; ++i)\n@@ -1201,6 +1153,9 @@ class FunctionComparison : public IFunction\n         const bool left_is_num = col_left_untyped->isNumeric();\n         const bool right_is_num = col_right_untyped->isNumeric();\n \n+        const bool left_is_string = isStringOrFixedString(which_left);\n+        const bool right_is_string = isStringOrFixedString(which_right);\n+\n         bool date_and_datetime = (left_type != right_type) &&\n             which_left.isDateOrDateTime() && which_right.isDateOrDateTime();\n \n@@ -1226,64 +1181,14 @@ class FunctionComparison : public IFunction\n         {\n             executeTuple(block, result, col_with_type_and_name_left, col_with_type_and_name_right, input_rows_count);\n         }\n-        else if (which_left.idx != which_right.idx\n-                 && (which_left.isDateTime64() || which_right.isDateTime64())\n-                 && (which_left.isStringOrFixedString() || which_right.isStringOrFixedString()))\n+        else if (left_is_string && right_is_string && executeString(block, result, col_left_untyped, col_right_untyped))\n+        {\n+        }\n+        else if (executeWithConstString(\n+                block, result, col_left_untyped, col_right_untyped,\n+                left_type, right_type,\n+                input_rows_count))\n         {\n-            /** Special case of comparing DateTime64 against a string.\n-             *\n-             * Can't be moved to executeDateOrDateTimeOrEnumOrUUIDWithConstString()\n-             * since DateTime64 is basically a Decimal, but we do similar things, except type inference.\n-             * Outline:\n-             * - Extract string content\n-             * - Parse it as a ColumnDateTime64 value (same type as DateTime64, means same precision)\n-             * - Fabricate a column with type and name\n-             * - Compare left and right comlumns as DateTime64 columns.\n-             */\n-\n-            const size_t datetime64_col_index = which_left.isDateTime64() ? 0 : 1;\n-            const size_t string_col_index = which_left.isStringOrFixedString() ? 0 : 1;\n-\n-            const auto & datetime64_col_with_type_and_name = block.getByPosition(arguments[datetime64_col_index]);\n-            const auto & string_col_with_type_and_name = block.getByPosition(arguments[string_col_index]);\n-\n-            if (!isColumnConst(*string_col_with_type_and_name.column))\n-                throw Exception(getName() + \", illegal column type of argument #\" + std::to_string(string_col_index)\n-                        + \" '\" + string_col_with_type_and_name.name + \"'\"\n-                        \" expected const String or const FixedString,\"\n-                        \" got \" + string_col_with_type_and_name.type->getName(),\n-                        ErrorCodes::ILLEGAL_COLUMN);\n-\n-            if (datetime64_col_with_type_and_name.column->size() == 0 || string_col_with_type_and_name.column->size() == 0)\n-            {\n-                // For some reason, when both left and right columns are empty (dry run while building a header block)\n-                // executeDecimal() fills result column with bogus value.\n-                block.getByPosition(result).column = ColumnUInt8::create();\n-                return;\n-            }\n-\n-            auto parsed_tmp_column_holder = datetime64_col_with_type_and_name.type->createColumn();\n-\n-            {\n-                const StringRef string_value = string_col_with_type_and_name.column->getDataAt(0);\n-                ReadBufferFromMemory in(string_value.data, string_value.size);\n-                datetime64_col_with_type_and_name.type->deserializeAsWholeText(*parsed_tmp_column_holder, in, FormatSettings{});\n-\n-                if (!in.eof())\n-                    throw Exception(getName() + \": String is too long for \" + datetime64_col_with_type_and_name.type->getName() + \" : \" + string_value.toString(), ErrorCodes::TOO_LARGE_STRING_SIZE);\n-            }\n-\n-            // It is necessary to wrap tmp column in ColumnConst to avoid overflow when comparing.\n-            // (non-const columns are expected to have same number of rows as every other column in block).\n-            const ColumnWithTypeAndName parsed_tmp_col_with_type_and_name{\n-                    ColumnConst::create(std::move(parsed_tmp_column_holder), 1),\n-                    datetime64_col_with_type_and_name.type,\n-                    string_col_with_type_and_name.name};\n-\n-            executeDecimal(block, result,\n-                which_left.isDateTime64() ? datetime64_col_with_type_and_name : parsed_tmp_col_with_type_and_name,\n-                which_right.isDateTime64() ? datetime64_col_with_type_and_name : parsed_tmp_col_with_type_and_name);\n-\n         }\n         else if (isColumnedAsDecimal(left_type) || isColumnedAsDecimal(right_type))\n         {\n@@ -1294,19 +1199,10 @@ class FunctionComparison : public IFunction\n \n             executeDecimal(block, result, col_with_type_and_name_left, col_with_type_and_name_right);\n         }\n-        else if (!left_is_num && !right_is_num && executeString(block, result, col_left_untyped, col_right_untyped))\n-        {\n-        }\n         else if (left_type->equals(*right_type))\n         {\n             executeGenericIdenticalTypes(block, result, col_left_untyped, col_right_untyped);\n         }\n-        else if (executeDateOrDateTimeOrEnumOrUUIDWithConstString(\n-                block, result, col_left_untyped, col_right_untyped,\n-                left_type, right_type,\n-                left_is_num, input_rows_count))\n-        {\n-        }\n         else\n         {\n             executeGeneric(block, result, col_with_type_and_name_left, col_with_type_and_name_right);\ndiff --git a/src/Functions/array/arrayIndex.h b/src/Functions/array/arrayIndex.h\nindex fab1332cbdaa..50214ee790f8 100644\n--- a/src/Functions/array/arrayIndex.h\n+++ b/src/Functions/array/arrayIndex.h\n@@ -9,7 +9,7 @@\n #include <Columns/ColumnFixedString.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnNullable.h>\n-#include <Common/FieldVisitors.h>\n+#include <Common/FieldVisitorsAccurateComparison.h>\n #include <Common/memcmpSmall.h>\n #include <Common/assert_cast.h>\n \ndiff --git a/src/Interpreters/FillingRow.cpp b/src/Interpreters/FillingRow.cpp\nindex dc48b5347c45..7e32d9514a6d 100644\n--- a/src/Interpreters/FillingRow.cpp\n+++ b/src/Interpreters/FillingRow.cpp\n@@ -1,4 +1,6 @@\n #include <Interpreters/FillingRow.h>\n+#include <Common/FieldVisitorsAccurateComparison.h>\n+\n \n namespace DB\n {\ndiff --git a/src/Interpreters/FillingRow.h b/src/Interpreters/FillingRow.h\nindex 1753508e1392..0e1d60d0d7a0 100644\n--- a/src/Interpreters/FillingRow.h\n+++ b/src/Interpreters/FillingRow.h\n@@ -1,7 +1,7 @@\n #pragma once\n #include <Core/SortDescription.h>\n #include <Columns/IColumn.h>\n-#include <Common/FieldVisitors.h>\n+\n \n namespace DB\n {\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex f9072e6176a7..dc32371b6c12 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -37,7 +37,7 @@\n #include <Core/Field.h>\n #include <Core/Types.h>\n #include <Columns/Collator.h>\n-#include <Common/FieldVisitors.h>\n+#include <Common/FieldVisitorsAccurateComparison.h>\n #include <Common/typeid_cast.h>\n #include <Common/checkStackSize.h>\n #include <ext/map.h>\ndiff --git a/src/Interpreters/convertFieldToType.cpp b/src/Interpreters/convertFieldToType.cpp\nindex 3cb774596c02..d46573d04614 100644\n--- a/src/Interpreters/convertFieldToType.cpp\n+++ b/src/Interpreters/convertFieldToType.cpp\n@@ -33,8 +33,6 @@ namespace ErrorCodes\n {\n     extern const int ARGUMENT_OUT_OF_BOUND;\n     extern const int TYPE_MISMATCH;\n-    extern const int TOO_LARGE_STRING_SIZE;\n-    extern const int CANNOT_CONVERT_TYPE;\n }\n \n \n@@ -124,42 +122,6 @@ static Field convertDecimalType(const Field & from, const To & type)\n }\n \n \n-DayNum stringToDate(const String & s)\n-{\n-    ReadBufferFromString in(s);\n-    DayNum date{};\n-\n-    readDateText(date, in);\n-    if (!in.eof())\n-        throw Exception(\"String is too long for Date: \" + s, ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-    return date;\n-}\n-\n-UInt64 stringToDateTime(const String & s)\n-{\n-    ReadBufferFromString in(s);\n-    time_t date_time{};\n-\n-    readDateTimeText(date_time, in);\n-    if (!in.eof())\n-        throw Exception(\"String is too long for DateTime: \" + s, ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-    return UInt64(date_time);\n-}\n-\n-DateTime64::NativeType stringToDateTime64(const String & s, UInt32 scale)\n-{\n-    ReadBufferFromString in(s);\n-    DateTime64 datetime64 {0};\n-\n-    readDateTime64Text(datetime64, scale, in);\n-    if (!in.eof())\n-        throw Exception(\"String is too long for DateTime64: \" + s, ErrorCodes::TOO_LARGE_STRING_SIZE);\n-\n-    return datetime64.value;\n-}\n-\n Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const IDataType * from_type_hint)\n {\n     WhichDataType which_type(type);\n@@ -184,7 +146,7 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n     {\n         return static_cast<const DataTypeDateTime &>(type).getTimeZone().fromDayNum(DayNum(src.get<UInt64>()));\n     }\n-    else if (type.isValueRepresentedByNumber())\n+    else if (type.isValueRepresentedByNumber() && src.getType() != Field::Types::String)\n     {\n         if (which_type.isUInt8()) return convertNumericType<UInt8>(src, type);\n         if (which_type.isUInt16()) return convertNumericType<UInt16>(src, type);\n@@ -200,9 +162,6 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n         if (const auto * ptype = typeid_cast<const DataTypeDecimal<Decimal64> *>(&type)) return convertDecimalType(src, *ptype);\n         if (const auto * ptype = typeid_cast<const DataTypeDecimal<Decimal128> *>(&type)) return convertDecimalType(src, *ptype);\n \n-        if (!which_type.isDateOrDateTime() && !which_type.isUUID() && !which_type.isEnum())\n-            throw Exception{\"Cannot convert field to type \" + type.getName(), ErrorCodes::CANNOT_CONVERT_TYPE};\n-\n         if (which_type.isEnum() && (src.getType() == Field::Types::UInt64 || src.getType() == Field::Types::Int64))\n         {\n             /// Convert UInt64 or Int64 to Enum's value\n@@ -214,36 +173,20 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n             /// We don't need any conversion UInt64 is under type of Date and DateTime\n             return src;\n         }\n-        // TODO (vnemkov): extra cases for DateTime64: converting from integer, converting from Decimal\n \n-        if (src.getType() == Field::Types::String)\n+        if (which_type.isUUID() && src.getType() == Field::Types::UInt128)\n         {\n-            if (which_type.isDate())\n-            {\n-                /// Convert 'YYYY-MM-DD' Strings to Date\n-                return stringToDate(src.get<const String &>());\n-            }\n-            else if (which_type.isDateTime())\n-            {\n-                /// Convert 'YYYY-MM-DD hh:mm:ss' Strings to DateTime\n-                return stringToDateTime(src.get<const String &>());\n-            }\n-            else if (which_type.isDateTime64())\n-            {\n-                const auto * date_time64 = typeid_cast<const DataTypeDateTime64 *>(&type);\n-                /// Convert 'YYYY-MM-DD hh:mm:ss.NNNNNNNNN' Strings to DateTime\n-                return stringToDateTime64(src.get<const String &>(), date_time64->getScale());\n-            }\n-            else if (which_type.isUUID())\n-            {\n-                return stringToUUID(src.get<const String &>());\n-            }\n-            else if (which_type.isEnum())\n-            {\n-                /// Convert String to Enum's value\n-                return dynamic_cast<const IDataTypeEnum &>(type).castToValue(src);\n-            }\n+            /// Already in needed type.\n+            return src;\n+        }\n+\n+        if (which_type.isDateTime64() && src.getType() == Field::Types::Decimal64)\n+        {\n+            /// Already in needed type.\n+            return src;\n         }\n+\n+        /// TODO Conversion from integers to DateTime64\n     }\n     else if (which_type.isStringOrFixedString())\n     {\n@@ -328,17 +271,37 @@ Field convertFieldToTypeImpl(const Field & src, const IDataType & type, const ID\n         return src;\n     }\n \n+    /// Conversion from string by parsing.\n     if (src.getType() == Field::Types::String)\n     {\n-        const auto col = type.createColumn();\n-        ReadBufferFromString buffer(src.get<String>());\n-        type.deserializeAsTextEscaped(*col, buffer, FormatSettings{});\n+        /// Promote data type to avoid overflows. Note that overflows in the largest data type are still possible.\n+        const IDataType * type_to_parse = &type;\n+        DataTypePtr holder;\n \n-        return (*col)[0];\n-    }\n+        if (type.canBePromoted())\n+        {\n+            holder = type.promoteNumericType();\n+            type_to_parse = holder.get();\n+        }\n+\n+        const auto col = type_to_parse->createColumn();\n+        ReadBufferFromString in_buffer(src.get<String>());\n+        try\n+        {\n+            type_to_parse->deserializeAsWholeText(*col, in_buffer, FormatSettings{});\n+        }\n+        catch (Exception & e)\n+        {\n+            e.addMessage(fmt::format(\"while converting '{}' to {}\", src.get<String>(), type.getName()));\n+            throw;\n+        }\n+        if (!in_buffer.eof())\n+            throw Exception(ErrorCodes::TYPE_MISMATCH, \"Cannot convert string {} to type {}\", src.get<String>(), type.getName());\n \n+        Field parsed = (*col)[0];\n+        return convertFieldToType(parsed, type, from_type_hint);\n+    }\n \n-    // TODO (nemkov): should we attempt to parse value using or `type.deserializeAsTextEscaped()` type.deserializeAsTextEscaped() ?\n     throw Exception(\"Type mismatch in IN or VALUES section. Expected: \" + type.getName() + \". Got: \"\n         + Field::Types::toString(src.getType()), ErrorCodes::TYPE_MISMATCH);\n }\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex dad73b6a0030..281f8511a592 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -7,7 +7,7 @@\n #include <Interpreters/misc.h>\n #include <Functions/FunctionFactory.h>\n #include <Functions/IFunction.h>\n-#include <Common/FieldVisitors.h>\n+#include <Common/FieldVisitorsAccurateComparison.h>\n #include <Common/typeid_cast.h>\n #include <Interpreters/convertFieldToType.h>\n #include <Interpreters/Set.h>\n@@ -826,8 +826,8 @@ bool KeyCondition::tryParseAtomFromAST(const ASTPtr & node, const Context & cont\n             }\n \n             bool cast_not_needed =\n-                    is_set_const /// Set args are already casted inside Set::createFromAST\n-                    || (isNativeNumber(key_expr_type) && isNativeNumber(const_type)); /// Numbers are accurately compared without cast.\n+                is_set_const /// Set args are already casted inside Set::createFromAST\n+                || (isNativeNumber(key_expr_type) && isNativeNumber(const_type)); /// Numbers are accurately compared without cast.\n \n             if (!cast_not_needed)\n                 castValueToType(key_expr_type, const_value, const_type, node);\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql b/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql\nindex 3071e3075178..e729bfdf188c 100644\n--- a/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql\n+++ b/tests/queries/0_stateless/00578_merge_table_shadow_virtual_column.sql\n@@ -4,7 +4,7 @@ DROP TABLE IF EXISTS numbers2;\n CREATE TABLE numbers1 ENGINE = Memory AS SELECT number as _table FROM numbers(1000);\n CREATE TABLE numbers2 ENGINE = Memory AS SELECT number as _table FROM numbers(1000);\n \n-SELECT count() FROM merge(currentDatabase(), '^numbers\\\\d+$') WHERE _table='numbers1'; -- { serverError 43 }\n+SELECT count() FROM merge(currentDatabase(), '^numbers\\\\d+$') WHERE _table='numbers1'; -- { serverError 53 }\n SELECT count() FROM merge(currentDatabase(), '^numbers\\\\d+$') WHERE _table=1;\n \n DROP TABLE numbers1;\ndiff --git a/tests/queries/0_stateless/00700_decimal_compare.reference b/tests/queries/0_stateless/00700_decimal_compare.reference\nindex 32f0b0a6dea1..2325847045f5 100644\n--- a/tests/queries/0_stateless/00700_decimal_compare.reference\n+++ b/tests/queries/0_stateless/00700_decimal_compare.reference\n@@ -1,3 +1,5 @@\n+0\n+1\n -42\t-42\t1\t0\t0\t0\t1\t1\n 42\t42\t1\t0\t0\t0\t1\t1\n -42\t-42.42000\t0\t0\t1\t1\t0\t1\ndiff --git a/tests/queries/0_stateless/00700_decimal_compare.sql b/tests/queries/0_stateless/00700_decimal_compare.sql\nindex 24b4ce588e57..ae2f5790570f 100644\n--- a/tests/queries/0_stateless/00700_decimal_compare.sql\n+++ b/tests/queries/0_stateless/00700_decimal_compare.sql\n@@ -19,7 +19,7 @@ INSERT INTO decimal (a, b, c, d, e, f, g, h, i, j) VALUES (-42, -42, -42, -0.42,\n \n SELECT a > toFloat64(0) FROM decimal; -- { serverError 43 }\n SELECT g > toFloat32(0) FROM decimal; -- { serverError 43 }\n-SELECT a > '0.0' FROM decimal; -- { serverError 43 }\n+SELECT a > '0.0' FROM decimal ORDER BY a;\n \n SELECT a, b, a = b, a < b, a > b, a != b, a <= b, a >= b FROM decimal ORDER BY a;\n SELECT a, g, a = g, a < g, a > g, a != g, a <= g, a >= g FROM decimal ORDER BY a;\ndiff --git a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\nindex c65bf668d717..4ffcf3be3c99 100644\n--- a/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n+++ b/tests/queries/0_stateless/01268_DateTime64_in_WHERE.sql\n@@ -1,12 +1,12 @@\n -- Error cases:\n -- non-const string column\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = materialize(S); -- {serverError 44}\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materialize(S) = toDateTime64(S, 3); -- {serverError 44}\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = materialize(S); -- {serverError 44}\n-WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 44}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = materialize(S); -- {serverError 43}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT materialize(S) = toDateTime64(S, 3); -- {serverError 43}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE DT64 = materialize(S); -- {serverError 43}\n+WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT * WHERE materialize(S) = DT64; -- {serverError 43}\n \n-SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 131} -- invalid DateTime64 string\n-SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333'; -- {serverError 131} -- invalid string length\n+SELECT * WHERE toDateTime64(123.345, 3) == 'ABCD'; -- {serverError 53} -- invalid DateTime64 string\n+SELECT * WHERE toDateTime64(123.345, 3) == '2020-02-05 14:34:12.33333333333333333333333333333333333333333333333333333333'; -- {serverError 53} -- invalid string length\n \n SELECT 'in SELECT';\n WITH '2020-02-05 14:34:12.333' as S, toDateTime64(S, 3) as DT64 SELECT DT64 = S;\ndiff --git a/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql b/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql\nindex 05295575cf14..4712c1242370 100644\n--- a/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql\n+++ b/tests/queries/0_stateless/01277_convert_field_to_type_logical_error.sql\n@@ -1,1 +1,1 @@\n-SELECT -2487, globalNullIn(toIntervalMinute(-88074), 'qEkek..'), [-27.537293]; -- { serverError 70 }\n+SELECT -2487, globalNullIn(toIntervalMinute(-88074), 'qEkek..'), [-27.537293]; -- { serverError 53 }\ndiff --git a/tests/queries/0_stateless/01310_enum_comparison.reference b/tests/queries/0_stateless/01310_enum_comparison.reference\nnew file mode 100644\nindex 000000000000..b261da18d51a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01310_enum_comparison.reference\n@@ -0,0 +1,2 @@\n+1\n+0\ndiff --git a/tests/queries/0_stateless/01310_enum_comparison.sql b/tests/queries/0_stateless/01310_enum_comparison.sql\nnew file mode 100644\nindex 000000000000..26901a61b2b2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01310_enum_comparison.sql\n@@ -0,0 +1,6 @@\n+CREATE TEMPORARY TABLE enum (x Enum('hello' = 1, 'world' = 2));\n+INSERT INTO enum VALUES ('hello');\n+\n+SELECT count() FROM enum WHERE x = 'hello';\n+SELECT count() FROM enum WHERE x = 'world';\n+SELECT count() FROM enum WHERE x = 'xyz'; -- { serverError 36 }\ndiff --git a/tests/queries/0_stateless/01311_comparison_with_constant_string.reference b/tests/queries/0_stateless/01311_comparison_with_constant_string.reference\nnew file mode 100644\nindex 000000000000..7865f42932d1\n--- /dev/null\n+++ b/tests/queries/0_stateless/01311_comparison_with_constant_string.reference\n@@ -0,0 +1,32 @@\n+0\n+1\n+0\n+---\n+1\n+0\n+1\n+---\n+1\n+0\n+0\n+---\n+0\n+---\n+1\n+0\n+---\n+---\n+0\n+---\n+1\n+---\n+0\n+---\n+0\n+---\n+0\n+---\n+0\n+---\n+1\n+---\ndiff --git a/tests/queries/0_stateless/01311_comparison_with_constant_string.sql b/tests/queries/0_stateless/01311_comparison_with_constant_string.sql\nnew file mode 100644\nindex 000000000000..d6641a50c45f\n--- /dev/null\n+++ b/tests/queries/0_stateless/01311_comparison_with_constant_string.sql\n@@ -0,0 +1,33 @@\n+SELECT number = '1' FROM numbers(3);\n+SELECT '---';\n+SELECT '1' != number FROM numbers(3);\n+SELECT '---';\n+SELECT '1' > number FROM numbers(3);\n+SELECT '---';\n+SELECT 1 = '257';\n+SELECT '---';\n+SELECT 1 IN (1.23, '1', 2);\n+SELECT 1 IN (1.23, '2', 2);\n+SELECT '---';\n+\n+-- it should work but it doesn't.\n+SELECT 1 = '1.0'; -- { serverError 53 }\n+SELECT '---';\n+\n+SELECT 1 = '257';\n+SELECT '---';\n+SELECT 1 != '257';\n+SELECT '---';\n+SELECT 1 < '257'; -- this is wrong for now\n+SELECT '---';\n+SELECT 1 > '257';\n+SELECT '---';\n+SELECT 1 <= '257'; -- this is wrong for now\n+SELECT '---';\n+SELECT 1 >= '257';\n+SELECT '---';\n+\n+SELECT toDateTime('2020-06-13 01:02:03') = '2020-06-13T01:02:03';\n+SELECT '---';\n+\n+SELECT 0 = ''; -- { serverError 32 }\ndiff --git a/tests/queries/0_stateless/01312_comparison_with_constant_string_in_index_analysis.reference b/tests/queries/0_stateless/01312_comparison_with_constant_string_in_index_analysis.reference\nnew file mode 100644\nindex 000000000000..ee98bdf033bd\n--- /dev/null\n+++ b/tests/queries/0_stateless/01312_comparison_with_constant_string_in_index_analysis.reference\n@@ -0,0 +1,12 @@\n+1\n+999999\n+100000\n+899999\n+100001\n+900000\n+1\n+999999\n+100000\n+899999\n+100001\n+900000\ndiff --git a/tests/queries/0_stateless/01312_comparison_with_constant_string_in_index_analysis.sql b/tests/queries/0_stateless/01312_comparison_with_constant_string_in_index_analysis.sql\nnew file mode 100644\nindex 000000000000..e37f647e81f4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01312_comparison_with_constant_string_in_index_analysis.sql\n@@ -0,0 +1,32 @@\n+DROP TABLE IF EXISTS test;\n+CREATE TABLE test (x UInt64) ENGINE = MergeTree ORDER BY x SETTINGS index_granularity = 1000;\n+INSERT INTO test SELECT * FROM numbers(1000000);\n+OPTIMIZE TABLE test;\n+\n+SET max_rows_to_read = 2000;\n+SELECT count() FROM test WHERE x = 100000;\n+SET max_rows_to_read = 1000000;\n+SELECT count() FROM test WHERE x != 100000;\n+SET max_rows_to_read = 101000;\n+SELECT count() FROM test WHERE x < 100000;\n+SET max_rows_to_read = 900000;\n+SELECT count() FROM test WHERE x > 100000;\n+SET max_rows_to_read = 101000;\n+SELECT count() FROM test WHERE x <= 100000;\n+SET max_rows_to_read = 901000;\n+SELECT count() FROM test WHERE x >= 100000;\n+\n+SET max_rows_to_read = 2000;\n+SELECT count() FROM test WHERE x = '100000';\n+SET max_rows_to_read = 1000000;\n+SELECT count() FROM test WHERE x != '100000';\n+SET max_rows_to_read = 101000;\n+SELECT count() FROM test WHERE x < '100000';\n+SET max_rows_to_read = 900000;\n+SELECT count() FROM test WHERE x > '100000';\n+SET max_rows_to_read = 101000;\n+SELECT count() FROM test WHERE x <= '100000';\n+SET max_rows_to_read = 901000;\n+SELECT count() FROM test WHERE x >= '100000';\n+\n+DROP TABLE test;\n",
  "problem_statement": "RFC: automatic type cast of literals in obvious cases\n```\r\nselect * from numbers(100) where number = '1';\r\n```\r\nliterals can be casted to the column type. \r\n\r\nIn general case there are too many side effects.\n",
  "hints_text": "Usual issue with other databases: in case col_string = 1 need to cast col_string to Int and this breaks index access.\nYep, that why I'm saying only of allowing cast of literal (i.e. constants used in the query) to column type, and never opposite (that sounds relatively safe, but maybe there are some other issues). \nWe have to implement it for SQL compatibility.\r\nBut it is not in development.\r\n\r\nIt will be more handy if we can postpone it after implementation of #3775 but that task is abandoned, and we should find simpler solution.\r\n\r\nExample: a setting to enable cast of constants in comparison operators.\r\nNote that it was already implemented for date and datetime: you can write `d = '2000-01-01'`.",
  "created_at": "2020-06-14T00:17:56Z"
}