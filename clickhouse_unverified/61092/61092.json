{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 61092,
  "instance_id": "ClickHouse__ClickHouse-61092",
  "issue_numbers": [
    "61051"
  ],
  "base_commit": "1cdd280c9f54a77bbdbde5c17ba5c7964f1a3812",
  "patch": "diff --git a/docs/en/operations/settings/settings.md b/docs/en/operations/settings/settings.md\nindex 3f4dec9dc931..6c427442e498 100644\n--- a/docs/en/operations/settings/settings.md\n+++ b/docs/en/operations/settings/settings.md\n@@ -4337,6 +4337,18 @@ Possible values:\n \n Default value: `0`.\n \n+\n+## function_locate_has_mysql_compatible_argument_order {#function-locate-has-mysql-compatible-argument-order}\n+\n+Controls the order of arguments in function [locate](../../sql-reference/functions/string-search-functions.md#locate).\n+\n+Possible values:\n+\n+- 0 \u2014 Function `locate` accepts arguments `(haystack, needle[, start_pos])`.\n+- 1 \u2014 Function `locate` accepts arguments `(needle, haystack, [, start_pos])` (MySQL-compatible behavior)\n+\n+Default value: `1`.\n+\n ## date_time_overflow_behavior {#date_time_overflow_behavior}\n \n Defines the behavior when [Date](../../sql-reference/data-types/date.md), [Date32](../../sql-reference/data-types/date32.md), [DateTime](../../sql-reference/data-types/datetime.md), [DateTime64](../../sql-reference/data-types/datetime64.md) or integers are converted into Date, Date32, DateTime or DateTime64 but the value cannot be represented in the result type.\ndiff --git a/docs/en/sql-reference/functions/string-search-functions.md b/docs/en/sql-reference/functions/string-search-functions.md\nindex 22f879c62aee..1b03f220db22 100644\n--- a/docs/en/sql-reference/functions/string-search-functions.md\n+++ b/docs/en/sql-reference/functions/string-search-functions.md\n@@ -30,7 +30,6 @@ position(haystack, needle[, start_pos])\n \n Alias:\n - `position(needle IN haystack)`\n-- `locate(haystack, needle[, start_pos])`.\n \n **Arguments**\n \n@@ -49,7 +48,7 @@ If substring `needle` is empty, these rules apply:\n - if `start_pos >= 1` and `start_pos <= length(haystack) + 1`: return `start_pos`\n - otherwise: return `0`\n \n-The same rules also apply to functions `positionCaseInsensitive`, `positionUTF8` and `positionCaseInsensitiveUTF8`\n+The same rules also apply to functions `locate`, `positionCaseInsensitive`, `positionUTF8` and `positionCaseInsensitiveUTF8`.\n \n Type: `Integer`.\n \n@@ -114,6 +113,21 @@ SELECT\n \u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n ```\n \n+## locate\n+\n+Like [position](#position) but with arguments `haystack` and `locate` switched.\n+\n+The behavior of this function depends on the ClickHouse version:\n+- in versions < v24.3, `locate` was an alias of function `position` and accepted arguments `(haystack, needle[, start_pos])`.\n+- in versions >= 24.3,, `locate` is an individual function (for better compatibility with MySQL) and accepts arguments `(needle, haystack[, start_pos])`. The previous behavior\n+  can be restored using setting [function_locate_has_mysql_compatible_argument_order = false](../../operations/settings/settings.md#function-locate-has-mysql-compatible-argument-order);\n+\n+**Syntax**\n+\n+``` sql\n+locate(needle, haystack[, start_pos])\n+```\n+\n ## positionCaseInsensitive\n \n Like [position](#position) but searches case-insensitively.\ndiff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 48f6b4d621c8..530a5ca3253a 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -175,6 +175,7 @@ class IColumn;\n     M(Bool, enable_positional_arguments, true, \"Enable positional arguments in ORDER BY, GROUP BY and LIMIT BY\", 0) \\\n     M(Bool, enable_extended_results_for_datetime_functions, false, \"Enable date functions like toLastDayOfMonth return Date32 results (instead of Date results) for Date32/DateTime64 arguments.\", 0) \\\n     M(Bool, allow_nonconst_timezone_arguments, false, \"Allow non-const timezone arguments in certain time-related functions like toTimeZone(), fromUnixTimestamp*(), snowflakeToDateTime*()\", 0) \\\n+    M(Bool, function_locate_has_mysql_compatible_argument_order, true, \"Function locate() has arguments (needle, haystack[, start_pos]) like in MySQL instead of (haystack, needle[, start_pos]) like function position()\", 0) \\\n     \\\n     M(Bool, group_by_use_nulls, false, \"Treat columns mentioned in ROLLUP, CUBE or GROUPING SETS as Nullable\", 0) \\\n     \\\ndiff --git a/src/Core/SettingsChangesHistory.h b/src/Core/SettingsChangesHistory.h\nindex 4914f97a6fb5..7690f5537fdd 100644\n--- a/src/Core/SettingsChangesHistory.h\n+++ b/src/Core/SettingsChangesHistory.h\n@@ -94,6 +94,7 @@ static std::map<ClickHouseVersion, SettingsChangesHistory::SettingsChanges> sett\n               {\"input_format_json_use_string_type_for_ambiguous_paths_in_named_tuples_inference_from_objects\", false, false, \"Allow to use String type for ambiguous paths during named tuple inference from JSON objects\"},\n               {\"throw_if_deduplication_in_dependent_materialized_views_enabled_with_async_insert\", false, true, \"Deduplication is dependent materialized view cannot work together with async inserts.\"},\n               {\"parallel_replicas_allow_in_with_subquery\", false, true, \"If true, subquery for IN will be executed on every follower replica\"},\n+              {\"function_locate_has_mysql_compatible_argument_order\", false, true, \"Increase compatibility with MySQL's locate function.\"},\n               {\"filesystem_cache_reserve_space_wait_lock_timeout_milliseconds\", 1000, 1000, \"Wait time to lock cache for sapce reservation in filesystem cache\"},\n               }},\n     {\"24.2\", {{\"allow_suspicious_variant_types\", true, false, \"Don't allow creating Variant type with suspicious variants by default\"},\ndiff --git a/src/Functions/FunctionsStringSearch.h b/src/Functions/FunctionsStringSearch.h\nindex 41b476ccc569..53d99198134f 100644\n--- a/src/Functions/FunctionsStringSearch.h\n+++ b/src/Functions/FunctionsStringSearch.h\n@@ -22,13 +22,13 @@ namespace DB\n   * positionCaseInsensitive(haystack, needle)\n   * positionCaseInsensitiveUTF8(haystack, needle)\n   *\n-  * like(haystack, pattern)        - search by the regular expression LIKE; Returns 0 or 1. Case-insensitive, but only for Latin.\n-  * notLike(haystack, pattern)\n+  * like(haystack, needle)        - search by the regular expression LIKE; Returns 0 or 1. Case-insensitive, but only for Latin.\n+  * notLike(haystack, needle)\n   *\n-  * ilike(haystack, pattern) - like 'like' but case-insensitive\n-  * notIlike(haystack, pattern)\n+  * ilike(haystack, needle) - like 'like' but case-insensitive\n+  * notIlike(haystack, needle)\n   *\n-  * match(haystack, pattern)       - search by regular expression re2; Returns 0 or 1.\n+  * match(haystack, needle)       - search by regular expression re2; Returns 0 or 1.\n   *\n   * countSubstrings(haystack, needle) -- count number of occurrences of needle in haystack.\n   * countSubstringsCaseInsensitive(haystack, needle)\n@@ -53,7 +53,7 @@ namespace DB\n   * - the first subpattern, if the regexp has a subpattern;\n   * - the zero subpattern (the match part, otherwise);\n   * - if not match - an empty string.\n-  * extract(haystack, pattern)\n+  * extract(haystack, needle)\n   */\n \n namespace ErrorCodes\n@@ -69,13 +69,39 @@ enum class ExecutionErrorPolicy\n     Throw\n };\n \n-template <typename Impl, ExecutionErrorPolicy execution_error_policy = ExecutionErrorPolicy::Throw>\n+enum class HaystackNeedleOrderIsConfigurable\n+{\n+    No,     /// function arguments are always: (haystack, needle[, position])\n+    Yes     /// depending on a setting, the function arguments are (haystack, needle[, position]) or (needle, haystack[, position])\n+};\n+\n+template <typename Impl,\n+         ExecutionErrorPolicy execution_error_policy = ExecutionErrorPolicy::Throw,\n+         HaystackNeedleOrderIsConfigurable haystack_needle_order_is_configurable = HaystackNeedleOrderIsConfigurable::No>\n class FunctionsStringSearch : public IFunction\n {\n+private:\n+    enum class ArgumentOrder\n+    {\n+        HaystackNeedle,\n+        NeedleHaystack\n+    };\n+\n+    ArgumentOrder argument_order = ArgumentOrder::HaystackNeedle;\n+\n public:\n     static constexpr auto name = Impl::name;\n \n-    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionsStringSearch>(); }\n+    static FunctionPtr create(ContextPtr context) { return std::make_shared<FunctionsStringSearch>(context); }\n+\n+    explicit FunctionsStringSearch([[maybe_unused]] ContextPtr context)\n+    {\n+        if constexpr (haystack_needle_order_is_configurable == HaystackNeedleOrderIsConfigurable::Yes)\n+        {\n+            if (context->getSettingsRef().function_locate_has_mysql_compatible_argument_order)\n+                argument_order = ArgumentOrder::NeedleHaystack;\n+        }\n+    }\n \n     String getName() const override { return name; }\n \n@@ -105,13 +131,16 @@ class FunctionsStringSearch : public IFunction\n                 \"Number of arguments for function {} doesn't match: passed {}, should be 2 or 3\",\n                 getName(), arguments.size());\n \n-        if (!isStringOrFixedString(arguments[0]))\n+        const auto & haystack_type = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[0] : arguments[1];\n+        const auto & needle_type = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[1] : arguments[0];\n+\n+        if (!isStringOrFixedString(haystack_type))\n             throw Exception(\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type {} of argument of function {}\",\n                 arguments[0]->getName(), getName());\n \n-        if (!isString(arguments[1]))\n+        if (!isString(needle_type))\n             throw Exception(\n                 ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n                 \"Illegal type {} of argument of function {}\",\n@@ -135,8 +164,8 @@ class FunctionsStringSearch : public IFunction\n \n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t /*input_rows_count*/) const override\n     {\n-        const ColumnPtr & column_haystack = arguments[0].column;\n-        const ColumnPtr & column_needle = arguments[1].column;\n+        const ColumnPtr & column_haystack = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[0].column : arguments[1].column;\n+        const ColumnPtr & column_needle = (argument_order == ArgumentOrder::HaystackNeedle) ? arguments[1].column : arguments[0].column;\n \n         ColumnPtr column_start_pos = nullptr;\n         if (arguments.size() >= 3)\ndiff --git a/src/Functions/array/FunctionsMapMiscellaneous.cpp b/src/Functions/array/FunctionsMapMiscellaneous.cpp\nindex 157f2fa8a262..d92bfcf0bc65 100644\n--- a/src/Functions/array/FunctionsMapMiscellaneous.cpp\n+++ b/src/Functions/array/FunctionsMapMiscellaneous.cpp\n@@ -213,6 +213,7 @@ struct MapToSubcolumnAdapter : public MapAdapterBase<MapToSubcolumnAdapter<Name,\n class FunctionMapKeyLike : public IFunction\n {\n public:\n+    FunctionMapKeyLike() : impl(/*context*/ nullptr) {} /// nullptr because getting a context here is hard and FunctionLike doesn't need context\n     String getName() const override { return \"mapKeyLike\"; }\n     size_t getNumberOfArguments() const override { return 3; }\n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return false; }\ndiff --git a/src/Functions/like.cpp b/src/Functions/like.cpp\nindex 5a86e37a92d8..de9073802654 100644\n--- a/src/Functions/like.cpp\n+++ b/src/Functions/like.cpp\n@@ -1,5 +1,5 @@\n-#include \"FunctionFactory.h\"\n #include \"like.h\"\n+#include \"FunctionFactory.h\"\n \n \n namespace DB\ndiff --git a/src/Functions/locate.cpp b/src/Functions/locate.cpp\nnew file mode 100644\nindex 000000000000..9a70fbb2d721\n--- /dev/null\n+++ b/src/Functions/locate.cpp\n@@ -0,0 +1,34 @@\n+#include \"FunctionsStringSearch.h\"\n+#include \"FunctionFactory.h\"\n+#include \"PositionImpl.h\"\n+\n+\n+namespace DB\n+{\n+namespace\n+{\n+\n+struct NameLocate\n+{\n+    static constexpr auto name = \"locate\";\n+};\n+\n+using FunctionLocate = FunctionsStringSearch<PositionImpl<NameLocate, PositionCaseSensitiveASCII>, ExecutionErrorPolicy::Throw, HaystackNeedleOrderIsConfigurable::Yes>;\n+\n+}\n+\n+REGISTER_FUNCTION(Locate)\n+{\n+    FunctionDocumentation::Description doc_description = \"Like function `position` but with arguments `haystack` and `locate` switched. The behavior of this function depends on the ClickHouse version: In versions < v24.3, `locate` was an alias of function `position` and accepted arguments `(haystack, needle[, start_pos])`. In versions >= 24.3,, `locate` is an individual function (for better compatibility with MySQL) and accepts arguments `(needle, haystack[, start_pos])`. The previous behaviorcan be restored using setting `function_locate_has_mysql_compatible_argument_order = false`.\";\n+    FunctionDocumentation::Syntax doc_syntax = \"location(needle, haystack[, start_pos])\";\n+    FunctionDocumentation::Arguments doc_arguments = {{\"needle\", \"Substring to be searched (String)\"},\n+                                                      {\"haystack\", \"String in which the search is performed (String).\"},\n+                                                      {\"start_pos\", \"Position (1-based) in `haystack` at which the search starts (UInt*).\"}};\n+    FunctionDocumentation::ReturnedValue doc_returned_value = \"Starting position in bytes and counting from 1, if the substring was found. 0, if the substring was not found.\";\n+    FunctionDocumentation::Examples doc_examples = {{\"Example\", \"SELECT locate('abcabc', 'ca');\", \"3\"}};\n+    FunctionDocumentation::Categories doc_categories = {\"String search\"};\n+\n+\n+    factory.registerFunction<FunctionLocate>({doc_description, doc_syntax, doc_arguments, doc_returned_value, doc_examples, doc_categories}, FunctionFactory::CaseInsensitive);\n+}\n+}\ndiff --git a/src/Functions/position.cpp b/src/Functions/position.cpp\nindex 409a593b44cc..29a5db2eb24b 100644\n--- a/src/Functions/position.cpp\n+++ b/src/Functions/position.cpp\n@@ -20,6 +20,5 @@ using FunctionPosition = FunctionsStringSearch<PositionImpl<NamePosition, Positi\n REGISTER_FUNCTION(Position)\n {\n     factory.registerFunction<FunctionPosition>({}, FunctionFactory::CaseInsensitive);\n-    factory.registerAlias(\"locate\", NamePosition::name, FunctionFactory::CaseInsensitive);\n }\n }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00765_locate.reference b/tests/queries/0_stateless/00765_locate.reference\nnew file mode 100644\nindex 000000000000..3b066c0d68bf\n--- /dev/null\n+++ b/tests/queries/0_stateless/00765_locate.reference\n@@ -0,0 +1,7 @@\n+-- negative tests\n+-- test mysql compatibility setting\n+0\n+0\n+3\n+-- the function name needs to be case-insensitive for historical reasons\n+0\ndiff --git a/tests/queries/0_stateless/00765_locate.sql b/tests/queries/0_stateless/00765_locate.sql\nnew file mode 100644\nindex 000000000000..3467ebd4249c\n--- /dev/null\n+++ b/tests/queries/0_stateless/00765_locate.sql\n@@ -0,0 +1,15 @@\n+SET send_logs_level = 'fatal';\n+\n+SELECT '-- negative tests';\n+SELECT locate(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT locate(1, 'abc'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT locate('abc', 1); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT locate('abc', 'abc', 'abc'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+\n+SELECT '-- test mysql compatibility setting';\n+SELECT locate('abcabc', 'ca');\n+SELECT locate('abcabc', 'ca') SETTINGS function_locate_has_mysql_compatible_argument_order = true;\n+SELECT locate('abcabc', 'ca') SETTINGS function_locate_has_mysql_compatible_argument_order = false;\n+\n+SELECT '-- the function name needs to be case-insensitive for historical reasons';\n+SELECT LoCaTe('abcabc', 'ca');\ndiff --git a/tests/queries/0_stateless/00765_sql_compatibility_aliases.reference b/tests/queries/0_stateless/00765_sql_compatibility_aliases.reference\nindex 285b9a62d20f..6d31168c2b70 100644\n--- a/tests/queries/0_stateless/00765_sql_compatibility_aliases.reference\n+++ b/tests/queries/0_stateless/00765_sql_compatibility_aliases.reference\n@@ -4,7 +4,6 @@ foo\n FOO\n baz\n zzz\n-2\n fo\n oo\n o\ndiff --git a/tests/queries/0_stateless/00765_sql_compatibility_aliases.sql b/tests/queries/0_stateless/00765_sql_compatibility_aliases.sql\nindex da0eb9bea6d0..995aaef9ea57 100644\n--- a/tests/queries/0_stateless/00765_sql_compatibility_aliases.sql\n+++ b/tests/queries/0_stateless/00765_sql_compatibility_aliases.sql\n@@ -6,7 +6,6 @@ select LOWER('Foo');\n select UPPER('Foo');\n select REPLACE('bar', 'r', 'z');\n select REGEXP_REPLACE('bar', '.', 'z');\n-select Locate('foo', 'o');\n select SUBSTRING('foo', 1, 2);\n select Substr('foo', 2);\n select mid('foo', 3);\ndiff --git a/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.reference b/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.reference\nindex de5a62159efa..76dd04b0e422 100644\n--- a/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.reference\n+++ b/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.reference\n@@ -26,7 +26,6 @@ SELECT\n     least(1),\n     length('1'),\n     log(1),\n-    position('1', '1'),\n     log(1),\n     log10(1),\n     log2(1),\ndiff --git a/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.sql b/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.sql\nindex dda2e045e760..d8054b9757c0 100644\n--- a/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.sql\n+++ b/tests/queries/0_stateless/01705_normalize_case_insensitive_function_names.sql\n@@ -1,1 +1,1 @@\n-EXPLAIN SYNTAX SELECT CAST(1 AS INT), CEIL(1), CEILING(1), CHAR(49), CHAR_LENGTH('1'), CHARACTER_LENGTH('1'), COALESCE(1), CONCAT('1', '1'), CORR(1, 1), COS(1), COUNT(1), COVAR_POP(1, 1), COVAR_SAMP(1, 1), DATABASE(), SCHEMA(), DATEDIFF('DAY', toDate('2020-10-24'), toDate('2019-10-24')), EXP(1), FLATTEN([[1]]), FLOOR(1), FQDN(), GREATEST(1), IF(1, 1, 1), IFNULL(1, 1), LCASE('A'), LEAST(1), LENGTH('1'), LN(1), LOCATE('1', '1'), LOG(1), LOG10(1), LOG2(1), LOWER('A'), MAX(1), MID('123', 1, 1), MIN(1), MOD(1, 1), NOT(1), NOW(), NOW64(), NULLIF(1, 1), PI(), POSITION('123', '2'), POW(1, 1), POWER(1, 1), RAND(), REPLACE('1', '1', '2'), REVERSE('123'), ROUND(1), SIN(1), SQRT(1), STDDEV_POP(1), STDDEV_SAMP(1), SUBSTR('123', 2), SUBSTRING('123', 2), SUM(1), TAN(1), TANH(1), TRUNC(1), TRUNCATE(1), UCASE('A'), UPPER('A'), USER(), VAR_POP(1), VAR_SAMP(1), WEEK(toDate('2020-10-24')), YEARWEEK(toDate('2020-10-24')) format TSVRaw;\n+EXPLAIN SYNTAX SELECT CAST(1 AS INT), CEIL(1), CEILING(1), CHAR(49), CHAR_LENGTH('1'), CHARACTER_LENGTH('1'), COALESCE(1), CONCAT('1', '1'), CORR(1, 1), COS(1), COUNT(1), COVAR_POP(1, 1), COVAR_SAMP(1, 1), DATABASE(), SCHEMA(), DATEDIFF('DAY', toDate('2020-10-24'), toDate('2019-10-24')), EXP(1), FLATTEN([[1]]), FLOOR(1), FQDN(), GREATEST(1), IF(1, 1, 1), IFNULL(1, 1), LCASE('A'), LEAST(1), LENGTH('1'), LN(1), LOG(1), LOG10(1), LOG2(1), LOWER('A'), MAX(1), MID('123', 1, 1), MIN(1), MOD(1, 1), NOT(1), NOW(), NOW64(), NULLIF(1, 1), PI(), POSITION('123', '2'), POW(1, 1), POWER(1, 1), RAND(), REPLACE('1', '1', '2'), REVERSE('123'), ROUND(1), SIN(1), SQRT(1), STDDEV_POP(1), STDDEV_SAMP(1), SUBSTR('123', 2), SUBSTRING('123', 2), SUM(1), TAN(1), TANH(1), TRUNC(1), TRUNCATE(1), UCASE('A'), UPPER('A'), USER(), VAR_POP(1), VAR_SAMP(1), WEEK(toDate('2020-10-24')), YEARWEEK(toDate('2020-10-24')) format TSVRaw;\n",
  "problem_statement": "MySQL compatibility: LOCATE has a different order of arguments in ClickHouse and MySQL\n(aliased to LOCATE) https://clickhouse.com/docs/en/sql-reference/functions/string-search-functions#position\r\n```\r\nposition(haystack, needle[, start_pos])\r\n```\r\n\r\nhttps://dev.mysql.com/doc/refman/8.0/en/string-functions.html#function_locate\r\n```\r\nLOCATE(substr,str), LOCATE(substr,str,pos)\r\n```\r\n\r\nin MySQL, \"needle\" and \"haystack\" are reverted.\r\n\r\nSome generated queries (Tableau) will expect the following:\r\n```sql\r\nSELECT CASE WHEN (LOCATE('ENDPOINT', UPPER(' ENDPOINT ')) > 0) THEN 'Yes' ELSE 'NO' END\r\n```\r\nto yield \"Yes\".\n",
  "hints_text": "",
  "created_at": "2024-03-08T12:16:27Z"
}