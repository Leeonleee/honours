{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 22096,
  "instance_id": "ClickHouse__ClickHouse-22096",
  "issue_numbers": [
    "14656"
  ],
  "base_commit": "5fa2244aa48c05c31c83b434198d901af36edc32",
  "patch": "diff --git a/src/Common/HashTable/HashMap.h b/src/Common/HashTable/HashMap.h\nindex 99dc54141073..c3cd09eccb23 100644\n--- a/src/Common/HashTable/HashMap.h\n+++ b/src/Common/HashTable/HashMap.h\n@@ -48,7 +48,7 @@ struct HashMapCell\n \n     value_type value;\n \n-    HashMapCell() {}\n+    HashMapCell() = default;\n     HashMapCell(const Key & key_, const State &) : value(key_, NoInitTag()) {}\n     HashMapCell(const value_type & value_, const State &) : value(value_) {}\n \n@@ -114,8 +114,39 @@ struct HashMapCell\n \n     static void move(HashMapCell * /* old_location */, HashMapCell * /* new_location */) {}\n \n+    template <size_t I>\n+    auto & get() & {\n+        if constexpr (I == 0) return value.first;\n+        else if constexpr (I == 1) return value.second;\n+    }\n+\n+    template <size_t I>\n+    auto const & get() const & {\n+        if constexpr (I == 0) return value.first;\n+        else if constexpr (I == 1) return value.second;\n+    }\n+\n+    template <size_t I>\n+    auto && get() && {\n+        if constexpr (I == 0) return std::move(value.first);\n+        else if constexpr (I == 1) return std::move(value.second);\n+    }\n+\n };\n \n+namespace std\n+{\n+\n+    template <typename Key, typename TMapped, typename Hash, typename TState>\n+    struct tuple_size<HashMapCell<Key, TMapped, Hash, TState>> : std::integral_constant<size_t, 2> { };\n+\n+    template <typename Key, typename TMapped, typename Hash, typename TState>\n+    struct tuple_element<0, HashMapCell<Key, TMapped, Hash, TState>> { using type = Key; };\n+\n+    template <typename Key, typename TMapped, typename Hash, typename TState>\n+    struct tuple_element<1, HashMapCell<Key, TMapped, Hash, TState>> { using type = TMapped; };\n+}\n+\n template <typename Key, typename TMapped, typename Hash, typename TState = HashTableNoState>\n struct HashMapCellWithSavedHash : public HashMapCell<Key, TMapped, Hash, TState>\n {\n@@ -227,6 +258,19 @@ class HashMapTable : public HashTable<Key, Cell, Hash, Grower, Allocator>\n     }\n };\n \n+namespace std\n+{\n+\n+    template <typename Key, typename TMapped, typename Hash, typename TState>\n+    struct tuple_size<HashMapCellWithSavedHash<Key, TMapped, Hash, TState>> : std::integral_constant<size_t, 2> { };\n+\n+    template <typename Key, typename TMapped, typename Hash, typename TState>\n+    struct tuple_element<0, HashMapCellWithSavedHash<Key, TMapped, Hash, TState>> { using type = Key; };\n+\n+    template <typename Key, typename TMapped, typename Hash, typename TState>\n+    struct tuple_element<1, HashMapCellWithSavedHash<Key, TMapped, Hash, TState>> { using type = TMapped; };\n+}\n+\n \n template <\n     typename Key,\ndiff --git a/src/Common/PODArray.h b/src/Common/PODArray.h\nindex 57ad3d461772..b1042332cfac 100644\n--- a/src/Common/PODArray.h\n+++ b/src/Common/PODArray.h\n@@ -530,6 +530,31 @@ class PODArray : public PODArrayBase<sizeof(T), initial_bytes, TAllocator, pad_r\n         this->c_end += bytes_to_copy;\n     }\n \n+    template <typename ... TAllocatorParams>\n+    void insertFromItself(iterator from_begin, iterator from_end, TAllocatorParams && ... allocator_params)\n+    {\n+        static_assert(memcpy_can_be_used_for_assignment<std::decay_t<T>, std::decay_t<decltype(*from_begin)>>);\n+\n+        /// Convert iterators to indexes because reserve can invalidate iterators\n+        size_t start_index = from_begin - begin();\n+        size_t end_index = from_end - begin();\n+        size_t copy_size = end_index - start_index;\n+\n+        assert(start_index <= end_index);\n+\n+        size_t required_capacity = this->size() + copy_size;\n+        if (required_capacity > this->capacity())\n+            this->reserve(roundUpToPowerOfTwoOrZero(required_capacity), std::forward<TAllocatorParams>(allocator_params)...);\n+\n+        size_t bytes_to_copy = this->byte_size(copy_size);\n+        if (bytes_to_copy)\n+        {\n+            auto begin = this->c_start + this->byte_size(start_index);\n+            memcpy(this->c_end, reinterpret_cast<const void *>(&*begin), bytes_to_copy);\n+            this->c_end += bytes_to_copy;\n+        }\n+    }\n+\n     template <typename It1, typename It2>\n     void insert_assume_reserved(It1 from_begin, It2 from_end)\n     {\ndiff --git a/src/Databases/DatabaseAtomic.cpp b/src/Databases/DatabaseAtomic.cpp\nindex e0078da57b7a..b4222a7e349b 100644\n--- a/src/Databases/DatabaseAtomic.cpp\n+++ b/src/Databases/DatabaseAtomic.cpp\n@@ -567,7 +567,7 @@ void DatabaseAtomic::renameDictionaryInMemoryUnlocked(const StorageID & old_name\n     auto result = external_loader.getLoadResult(toString(old_name.uuid));\n     if (!result.object)\n         return;\n-    const auto & dict = dynamic_cast<const IDictionaryBase &>(*result.object);\n+    const auto & dict = dynamic_cast<const IDictionary &>(*result.object);\n     dict.updateDictionaryName(new_name);\n }\n void DatabaseAtomic::waitDetachedTableNotInUse(const UUID & uuid)\ndiff --git a/src/Databases/DatabaseWithDictionaries.cpp b/src/Databases/DatabaseWithDictionaries.cpp\nindex d92f0f1897e6..55b04f27c58e 100644\n--- a/src/Databases/DatabaseWithDictionaries.cpp\n+++ b/src/Databases/DatabaseWithDictionaries.cpp\n@@ -49,7 +49,7 @@ void DatabaseWithDictionaries::attachDictionary(const String & dictionary_name,\n         /// Attach the dictionary as table too.\n         try\n         {\n-            /// TODO Make StorageDictionary an owner of IDictionaryBase objects.\n+            /// TODO Make StorageDictionary an owner of IDictionary objects.\n             /// All DDL operations with dictionaries will work with StorageDictionary table,\n             /// and StorageDictionary will be responsible for loading of DDL dictionaries.\n             /// ExternalLoaderDatabaseConfigRepository and other hacks related to ExternalLoader\ndiff --git a/src/Dictionaries/CacheDictionary.cpp b/src/Dictionaries/CacheDictionary.cpp\nindex eedf4dd3d877..535e862af402 100644\n--- a/src/Dictionaries/CacheDictionary.cpp\n+++ b/src/Dictionaries/CacheDictionary.cpp\n@@ -13,7 +13,9 @@\n #include <Common/HashTable/HashSet.h>\n #include <Common/ProfileEvents.h>\n #include <Common/ProfilingScopedRWLock.h>\n+\n #include <Dictionaries/DictionaryBlockInputStream.h>\n+#include <Dictionaries/HierarchyDictionariesUtils.h>\n \n namespace ProfileEvents\n {\n@@ -39,7 +41,6 @@ namespace DB\n namespace ErrorCodes\n {\n     extern const int CACHE_DICTIONARY_UPDATE_FAIL;\n-    extern const int TYPE_MISMATCH;\n     extern const int UNSUPPORTED_METHOD;\n }\n \n@@ -70,8 +71,6 @@ CacheDictionary<dictionary_key_type>::CacheDictionary(\n {\n     if (!source_ptr->supportsSelectiveLoad())\n         throw Exception{full_name + \": source cannot be used with CacheDictionary\", ErrorCodes::UNSUPPORTED_METHOD};\n-\n-    setupHierarchicalAttribute();\n }\n \n template <DictionaryKeyType dictionary_key_type>\n@@ -120,164 +119,6 @@ const IDictionarySource * CacheDictionary<dictionary_key_type>::getSource() cons\n     return source_ptr.get();\n }\n \n-template <DictionaryKeyType dictionary_key_type>\n-void CacheDictionary<dictionary_key_type>::toParent(const PaddedPODArray<UInt64> & ids [[maybe_unused]], PaddedPODArray<UInt64> & out [[maybe_unused]]) const\n-{\n-    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n-    {\n-        /// Run update on requested keys before fetch from storage\n-        const auto & attribute_name = hierarchical_attribute->name;\n-\n-        auto result_type = std::make_shared<DataTypeUInt64>();\n-        auto input_column = result_type->createColumn();\n-        auto & input_column_typed = assert_cast<ColumnVector<UInt64> &>(*input_column);\n-        auto & data = input_column_typed.getData();\n-        data.insert(ids.begin(), ids.end());\n-\n-        auto column = getColumn({attribute_name}, result_type, {std::move(input_column)}, {result_type}, {nullptr});\n-        const auto & result_column_typed = assert_cast<const ColumnVector<UInt64> &>(*column);\n-        const auto & result_data = result_column_typed.getData();\n-\n-        out.assign(result_data);\n-    }\n-    else\n-        throw Exception(\"Hierarchy is not supported for complex key CacheDictionary\", ErrorCodes::UNSUPPORTED_METHOD);\n-}\n-\n-\n-/// Allow to use single value in same way as array.\n-static inline UInt64 getAt(const PaddedPODArray<UInt64> & arr, const size_t idx)\n-{\n-    return arr[idx];\n-}\n-static inline UInt64 getAt(const UInt64 & value, const size_t)\n-{\n-    return value;\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-template <typename AncestorType>\n-void CacheDictionary<dictionary_key_type>::isInImpl(const PaddedPODArray<Key> & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    /// Transform all children to parents until ancestor id or null_value will be reached.\n-\n-    size_t out_size = out.size();\n-    memset(out.data(), 0xFF, out_size); /// 0xFF means \"not calculated\"\n-\n-    const auto null_value = hierarchical_attribute->null_value.get<UInt64>();\n-\n-    PaddedPODArray<Key> children(out_size, 0);\n-    PaddedPODArray<Key> parents(child_ids.begin(), child_ids.end());\n-\n-    for (size_t i = 0; i < DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH; ++i)\n-    {\n-        size_t out_idx = 0;\n-        size_t parents_idx = 0;\n-        size_t new_children_idx = 0;\n-\n-        while (out_idx < out_size)\n-        {\n-            /// Already calculated\n-            if (out[out_idx] != 0xFF)\n-            {\n-                ++out_idx;\n-                continue;\n-            }\n-\n-            /// No parent\n-            if (parents[parents_idx] == null_value)\n-            {\n-                out[out_idx] = 0;\n-            }\n-            /// Found ancestor\n-            else if (parents[parents_idx] == getAt(ancestor_ids, parents_idx))\n-            {\n-                out[out_idx] = 1;\n-            }\n-            /// Loop detected\n-            else if (children[new_children_idx] == parents[parents_idx])\n-            {\n-                out[out_idx] = 1;\n-            }\n-            /// Found intermediate parent, add this value to search at next loop iteration\n-            else\n-            {\n-                children[new_children_idx] = parents[parents_idx];\n-                ++new_children_idx;\n-            }\n-\n-            ++out_idx;\n-            ++parents_idx;\n-        }\n-\n-        if (new_children_idx == 0)\n-            break;\n-\n-        /// Transform all children to its parents.\n-        children.resize(new_children_idx);\n-        parents.resize(new_children_idx);\n-\n-        toParent(children, parents);\n-    }\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void CacheDictionary<dictionary_key_type>::isInVectorVector(\n-    const PaddedPODArray<UInt64> & child_ids, const PaddedPODArray<UInt64> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_ids, out);\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void CacheDictionary<dictionary_key_type>::isInVectorConstant(const PaddedPODArray<UInt64> & child_ids, const UInt64 ancestor_id, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_id, out);\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void CacheDictionary<dictionary_key_type>::isInConstantVector(const UInt64 child_id, const PaddedPODArray<UInt64> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    /// Special case with single child value.\n-\n-    const auto null_value = hierarchical_attribute->null_value.get<UInt64>();\n-\n-    PaddedPODArray<Key> child(1, child_id);\n-    PaddedPODArray<Key> parent(1);\n-    std::vector<Key> ancestors(1, child_id);\n-\n-    /// Iteratively find all ancestors for child.\n-    for (size_t i = 0; i < DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH; ++i)\n-    {\n-        toParent(child, parent);\n-\n-        if (parent[0] == null_value)\n-            break;\n-\n-        child[0] = parent[0];\n-        ancestors.push_back(parent[0]);\n-    }\n-\n-    /// Assuming short hierarchy, so linear search is Ok.\n-    for (size_t i = 0, out_size = out.size(); i < out_size; ++i)\n-        out[i] = std::find(ancestors.begin(), ancestors.end(), ancestor_ids[i]) != ancestors.end();\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void CacheDictionary<dictionary_key_type>::setupHierarchicalAttribute()\n-{\n-    /// TODO: Move this to DictionaryStructure\n-    for (const auto & attribute : dict_struct.attributes)\n-    {\n-        if (attribute.hierarchical)\n-        {\n-            hierarchical_attribute = &attribute;\n-\n-            if (attribute.underlying_type != AttributeUnderlyingType::utUInt64)\n-                throw Exception{full_name + \": hierarchical attribute must be UInt64.\", ErrorCodes::TYPE_MISMATCH};\n-        }\n-    }\n-}\n-\n template <DictionaryKeyType dictionary_key_type>\n ColumnPtr CacheDictionary<dictionary_key_type>::getColumn(\n     const std::string & attribute_name,\n@@ -296,23 +137,6 @@ Columns CacheDictionary<dictionary_key_type>::getColumns(\n     const Columns & key_columns,\n     const DataTypes & key_types,\n     const Columns & default_values_columns) const\n-{\n-    if (dictionary_key_type == DictionaryKeyType::complex)\n-        dict_struct.validateKeyTypes(key_types);\n-\n-    Arena complex_keys_arena;\n-    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, complex_keys_arena);\n-    auto & keys = extractor.getKeys();\n-\n-    return getColumnsImpl(attribute_names, key_columns, keys, default_values_columns);\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-Columns CacheDictionary<dictionary_key_type>::getColumnsImpl(\n-    const Strings & attribute_names,\n-    const Columns & key_columns,\n-    const PaddedPODArray<KeyType> & keys,\n-    const Columns & default_values_columns) const\n {\n     /**\n     * Flow of getColumsImpl\n@@ -328,6 +152,13 @@ Columns CacheDictionary<dictionary_key_type>::getColumnsImpl(\n     * use default value.\n     */\n \n+    if (dictionary_key_type == DictionaryKeyType::complex)\n+        dict_struct.validateKeyTypes(key_types);\n+\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n+    auto keys = extractor.extractAllKeys();\n+\n     DictionaryStorageFetchRequest request(dict_struct, attribute_names, default_values_columns);\n \n     FetchResult result_of_fetch_from_storage;\n@@ -440,9 +271,10 @@ ColumnUInt8::Ptr CacheDictionary<dictionary_key_type>::hasKeys(const Columns & k\n     if (dictionary_key_type == DictionaryKeyType::complex)\n         dict_struct.validateKeyTypes(key_types);\n \n-    Arena complex_keys_arena;\n-    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, complex_keys_arena);\n-    const auto & keys = extractor.getKeys();\n+\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n+    const auto keys = extractor.extractAllKeys();\n \n     /// We make empty request just to fetch if keys exists\n     DictionaryStorageFetchRequest request(dict_struct, {}, {});\n@@ -526,6 +358,37 @@ ColumnUInt8::Ptr CacheDictionary<dictionary_key_type>::hasKeys(const Columns & k\n     return result;\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr CacheDictionary<dictionary_key_type>::getHierarchy(\n+    ColumnPtr key_column [[maybe_unused]],\n+    const DataTypePtr & key_type [[maybe_unused]]) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::simple)\n+    {\n+        auto result = getKeysHierarchyDefaultImplementation(this, key_column, key_type);\n+        query_count.fetch_add(key_column->size(), std::memory_order_relaxed);\n+        return result;\n+    }\n+    else\n+        return nullptr;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnUInt8::Ptr CacheDictionary<dictionary_key_type>::isInHierarchy(\n+    ColumnPtr key_column [[maybe_unused]],\n+    ColumnPtr in_key_column [[maybe_unused]],\n+    const DataTypePtr & key_type [[maybe_unused]]) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::simple)\n+    {\n+        auto result = getKeysIsInHierarchyDefaultImplementation(this, key_column, in_key_column, key_type);\n+        query_count.fetch_add(key_column->size(), std::memory_order_relaxed);\n+        return result;\n+    }\n+    else\n+        return nullptr;\n+}\n+\n template <DictionaryKeyType dictionary_key_type>\n MutableColumns CacheDictionary<dictionary_key_type>::aggregateColumnsInOrderOfKeys(\n     const PaddedPODArray<KeyType> & keys,\n@@ -618,19 +481,18 @@ MutableColumns CacheDictionary<dictionary_key_type>::aggregateColumns(\n template <DictionaryKeyType dictionary_key_type>\n BlockInputStreamPtr CacheDictionary<dictionary_key_type>::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n {\n-    using BlockInputStreamType = DictionaryBlockInputStream<Key>;\n-    std::shared_ptr<BlockInputStreamType> stream;\n+    std::shared_ptr<DictionaryBlockInputStream> stream;\n \n     {\n         /// Write lock on storage\n         const ProfilingScopedWriteRWLock write_lock{rw_lock, ProfileEvents::DictCacheLockWriteNs};\n \n         if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n-            stream = std::make_shared<BlockInputStreamType>(shared_from_this(), max_block_size, cache_storage_ptr->getCachedSimpleKeys(), column_names);\n+            stream = std::make_shared<DictionaryBlockInputStream>(shared_from_this(), max_block_size, cache_storage_ptr->getCachedSimpleKeys(), column_names);\n         else\n         {\n             auto keys = cache_storage_ptr->getCachedComplexKeys();\n-            stream = std::make_shared<BlockInputStreamType>(shared_from_this(), max_block_size, keys, column_names);\n+            stream = std::make_shared<DictionaryBlockInputStream>(shared_from_this(), max_block_size, keys, column_names);\n         }\n     }\n \n@@ -660,14 +522,20 @@ void CacheDictionary<dictionary_key_type>::update(CacheDictionaryUpdateUnitPtr<d\n \n     size_t found_keys_size = 0;\n \n-    DictionaryKeysExtractor<dictionary_key_type> requested_keys_extractor(update_unit_ptr->key_columns, update_unit_ptr->complex_key_arena);\n-    const auto & requested_keys = requested_keys_extractor.getKeys();\n+    Arena * complex_key_arena = update_unit_ptr->complex_keys_arena_holder.getComplexKeyArena();\n+    DictionaryKeysExtractor<dictionary_key_type> requested_keys_extractor(update_unit_ptr->key_columns, complex_key_arena);\n+    auto requested_keys = requested_keys_extractor.extractAllKeys();\n \n     HashSet<KeyType> not_found_keys;\n \n     std::vector<UInt64> requested_keys_vector;\n     std::vector<size_t> requested_complex_key_rows;\n \n+    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n+        requested_keys_vector.reserve(requested_keys.size());\n+    else\n+        requested_complex_key_rows.reserve(requested_keys.size());\n+\n     auto & key_index_to_state_from_storage = update_unit_ptr->key_index_to_state;\n \n     for (size_t i = 0; i < key_index_to_state_from_storage.size(); ++i)\n@@ -727,8 +595,8 @@ void CacheDictionary<dictionary_key_type>::update(CacheDictionaryUpdateUnitPtr<d\n                     block_columns.erase(block_columns.begin());\n                 }\n \n-                DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, update_unit_ptr->complex_key_arena);\n-                const auto & keys_extracted_from_block = keys_extractor.getKeys();\n+                DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, complex_key_arena);\n+                auto keys_extracted_from_block = keys_extractor.extractAllKeys();\n \n                 for (size_t index_of_attribute = 0; index_of_attribute < fetched_columns_during_update.size(); ++index_of_attribute)\n                 {\n@@ -740,6 +608,7 @@ void CacheDictionary<dictionary_key_type>::update(CacheDictionaryUpdateUnitPtr<d\n                 for (size_t i = 0; i < keys_extracted_from_block.size(); ++i)\n                 {\n                     auto fetched_key_from_source = keys_extracted_from_block[i];\n+\n                     not_found_keys.erase(fetched_key_from_source);\n                     update_unit_ptr->requested_keys_to_fetched_columns_during_update_index[fetched_key_from_source] = found_keys_size;\n                     found_keys_in_source.emplace_back(fetched_key_from_source);\ndiff --git a/src/Dictionaries/CacheDictionary.h b/src/Dictionaries/CacheDictionary.h\nindex 1192db737370..62cd509d0060 100644\n--- a/src/Dictionaries/CacheDictionary.h\n+++ b/src/Dictionaries/CacheDictionary.h\n@@ -130,33 +130,18 @@ class CacheDictionary final : public IDictionary\n \n     std::exception_ptr getLastException() const override;\n \n-    bool hasHierarchy() const override { return dictionary_key_type == DictionaryKeyType::simple && hierarchical_attribute; }\n+    bool hasHierarchy() const override { return dictionary_key_type == DictionaryKeyType::simple && dict_struct.hierarchical_attribute_index.has_value(); }\n \n-    void toParent(const PaddedPODArray<UInt64> & ids, PaddedPODArray<UInt64> & out) const override;\n+    ColumnPtr getHierarchy(ColumnPtr key_column, const DataTypePtr & key_type) const override;\n \n-    void isInVectorVector(\n-        const PaddedPODArray<UInt64> & child_ids,\n-        const PaddedPODArray<UInt64> & ancestor_ids,\n-        PaddedPODArray<UInt8> & out) const override;\n-\n-    void isInVectorConstant(\n-        const PaddedPODArray<UInt64> & child_ids,\n-        const UInt64 ancestor_id, PaddedPODArray<UInt8> & out) const override;\n-\n-    void isInConstantVector(\n-        const UInt64 child_id,\n-        const PaddedPODArray<UInt64> & ancestor_ids,\n-        PaddedPODArray<UInt8> & out) const override;\n+    ColumnUInt8::Ptr isInHierarchy(\n+        ColumnPtr key_column,\n+        ColumnPtr in_key_column,\n+        const DataTypePtr & key_type) const override;\n \n private:\n     using FetchResult = std::conditional_t<dictionary_key_type == DictionaryKeyType::simple, SimpleKeysStorageFetchResult, ComplexKeysStorageFetchResult>;\n \n-    Columns getColumnsImpl(\n-        const Strings & attribute_names,\n-        const Columns & key_columns,\n-        const PaddedPODArray<KeyType> & keys,\n-        const Columns & default_values_columns) const;\n-\n     static MutableColumns aggregateColumnsInOrderOfKeys(\n         const PaddedPODArray<KeyType> & keys,\n         const DictionaryStorageFetchRequest & request,\n@@ -171,8 +156,6 @@ class CacheDictionary final : public IDictionary\n         const MutableColumns & fetched_columns_during_update,\n         const HashMap<KeyType, size_t> & found_keys_to_fetched_columns_during_update_index);\n \n-    void setupHierarchicalAttribute();\n-\n     void update(CacheDictionaryUpdateUnitPtr<dictionary_key_type> update_unit_ptr);\n \n     /// Update dictionary source pointer if required and return it. Thread safe.\n@@ -193,9 +176,6 @@ class CacheDictionary final : public IDictionary\n         return source_ptr;\n     }\n \n-    template <typename AncestorType>\n-    void isInImpl(const PaddedPODArray<Key> & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n-\n     const DictionaryStructure dict_struct;\n \n     /// Dictionary source should be used with mutex\n@@ -218,8 +198,6 @@ class CacheDictionary final : public IDictionary\n     /// readers. Surprisingly this lock is also used for last_exception pointer.\n     mutable std::shared_mutex rw_lock;\n \n-    const DictionaryAttribute * hierarchical_attribute = nullptr;\n-\n     mutable std::exception_ptr last_exception;\n     mutable std::atomic<size_t> error_count {0};\n     mutable std::atomic<std::chrono::system_clock::time_point> backoff_end_time{std::chrono::system_clock::time_point{}};\ndiff --git a/src/Dictionaries/CacheDictionaryUpdateQueue.h b/src/Dictionaries/CacheDictionaryUpdateQueue.h\nindex 2e636af6db66..3d27a1577529 100644\n--- a/src/Dictionaries/CacheDictionaryUpdateQueue.h\n+++ b/src/Dictionaries/CacheDictionaryUpdateQueue.h\n@@ -66,8 +66,9 @@ class CacheDictionaryUpdateUnit\n \n     HashMap<KeyType, size_t> requested_keys_to_fetched_columns_during_update_index;\n     MutableColumns fetched_columns_during_update;\n+\n     /// Complex keys are serialized in this arena\n-    Arena complex_key_arena;\n+    DictionaryKeysArenaHolder<dictionary_key_type> complex_keys_arena_holder;\n \n private:\n     template <DictionaryKeyType>\ndiff --git a/src/Dictionaries/ComplexKeyHashedDictionary.cpp b/src/Dictionaries/ComplexKeyHashedDictionary.cpp\ndeleted file mode 100644\nindex 4086082e66d3..000000000000\n--- a/src/Dictionaries/ComplexKeyHashedDictionary.cpp\n+++ /dev/null\n@@ -1,594 +0,0 @@\n-#include \"ComplexKeyHashedDictionary.h\"\n-#include <ext/map.h>\n-#include <ext/range.h>\n-#include <Columns/ColumnsNumber.h>\n-#include <Columns/ColumnNullable.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <DataTypes/DataTypesDecimal.h>\n-#include \"DictionaryBlockInputStream.h\"\n-#include \"DictionaryFactory.h\"\n-\n-namespace DB\n-{\n-namespace ErrorCodes\n-{\n-    extern const int TYPE_MISMATCH;\n-    extern const int BAD_ARGUMENTS;\n-    extern const int DICTIONARY_IS_EMPTY;\n-}\n-\n-ComplexKeyHashedDictionary::ComplexKeyHashedDictionary(\n-    const StorageID & dict_id_,\n-    const DictionaryStructure & dict_struct_,\n-    DictionarySourcePtr source_ptr_,\n-    const DictionaryLifetime dict_lifetime_,\n-    bool require_nonempty_,\n-    BlockPtr saved_block_)\n-    : IDictionaryBase(dict_id_)\n-    , dict_struct(dict_struct_)\n-    , source_ptr{std::move(source_ptr_)}\n-    , dict_lifetime(dict_lifetime_)\n-    , require_nonempty(require_nonempty_)\n-    , saved_block{std::move(saved_block_)}\n-{\n-    createAttributes();\n-    loadData();\n-    calculateBytesAllocated();\n-}\n-\n-ColumnPtr ComplexKeyHashedDictionary::getColumn(\n-    const std::string & attribute_name,\n-    const DataTypePtr & result_type,\n-    const Columns & key_columns,\n-    const DataTypes & key_types,\n-    const ColumnPtr & default_values_column) const\n-{\n-    dict_struct.validateKeyTypes(key_types);\n-\n-    ColumnPtr result;\n-\n-    const auto & attribute = getAttribute(attribute_name);\n-    const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n-\n-    auto keys_size = key_columns.front()->size();\n-\n-    ColumnUInt8::MutablePtr col_null_map_to;\n-    ColumnUInt8::Container * vec_null_map_to = nullptr;\n-    if (attribute.is_nullable)\n-    {\n-        col_null_map_to = ColumnUInt8::create(keys_size, false);\n-        vec_null_map_to = &col_null_map_to->getData();\n-    }\n-\n-    auto type_call = [&](const auto &dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        using ValueType = DictionaryValueType<AttributeType>;\n-        using ColumnProvider = DictionaryAttributeColumnProvider<AttributeType>;\n-\n-        const auto attribute_null_value = std::get<ValueType>(attribute.null_values);\n-        AttributeType null_value = static_cast<AttributeType>(attribute_null_value);\n-        DictionaryDefaultValueExtractor<AttributeType> default_value_extractor(std::move(null_value), default_values_column);\n-\n-        auto column = ColumnProvider::getColumn(dictionary_attribute, keys_size);\n-\n-        if constexpr (std::is_same_v<AttributeType, String>)\n-        {\n-            auto * out = column.get();\n-\n-            getItemsImpl<StringRef, StringRef>(\n-                attribute,\n-                key_columns,\n-                [&](const size_t row, const StringRef value, bool is_null)\n-                {\n-                    if (attribute.is_nullable)\n-                        (*vec_null_map_to)[row] = is_null;\n-\n-                    out->insertData(value.data, value.size);\n-                },\n-                default_value_extractor);\n-        }\n-        else\n-        {\n-            auto & out = column->getData();\n-\n-            getItemsImpl<AttributeType, AttributeType>(\n-                attribute,\n-                key_columns,\n-                [&](const size_t row, const auto value, bool is_null)\n-                {\n-                    if (attribute.is_nullable)\n-                        (*vec_null_map_to)[row] = is_null;\n-\n-                    out[row] = value;\n-                },\n-                default_value_extractor);\n-        }\n-\n-        result = std::move(column);\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-\n-    if (attribute.is_nullable)\n-    {\n-        result = ColumnNullable::create(result, std::move(col_null_map_to));\n-    }\n-\n-    return result;\n-}\n-\n-ColumnUInt8::Ptr ComplexKeyHashedDictionary::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n-{\n-    dict_struct.validateKeyTypes(key_types);\n-\n-    auto size = key_columns.front()->size();\n-    auto result = ColumnUInt8::create(size);\n-    auto& out = result->getData();\n-\n-    const auto & attribute = attributes.front();\n-\n-    auto type_call = [&](const auto & dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        using ValueType = DictionaryValueType<AttributeType>;\n-\n-        has<ValueType>(attribute, key_columns, out);\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-\n-    return result;\n-}\n-\n-void ComplexKeyHashedDictionary::createAttributes()\n-{\n-    const auto size = dict_struct.attributes.size();\n-    attributes.reserve(size);\n-\n-    for (const auto & attribute : dict_struct.attributes)\n-    {\n-        attribute_index_by_name.emplace(attribute.name, attributes.size());\n-        attributes.push_back(createAttribute(attribute, attribute.null_value));\n-\n-        if (attribute.hierarchical)\n-            throw Exception{full_name + \": hierarchical attributes not supported for dictionary of type \" + getTypeName(),\n-                            ErrorCodes::TYPE_MISMATCH};\n-    }\n-}\n-\n-void ComplexKeyHashedDictionary::blockToAttributes(const Block & block)\n-{\n-    /// created upfront to avoid excess allocations\n-    const auto keys_size = dict_struct.key->size();\n-    StringRefs keys(keys_size);\n-\n-    const auto attributes_size = attributes.size();\n-    const auto rows = block.rows();\n-    element_count += rows;\n-\n-    const auto key_column_ptrs = ext::map<Columns>(\n-        ext::range(0, keys_size), [&](const size_t attribute_idx) { return block.safeGetByPosition(attribute_idx).column; });\n-\n-    const auto attribute_column_ptrs = ext::map<Columns>(ext::range(0, attributes_size), [&](const size_t attribute_idx)\n-    {\n-        return block.safeGetByPosition(keys_size + attribute_idx).column;\n-    });\n-\n-    for (const auto row_idx : ext::range(0, rows))\n-    {\n-        /// calculate key once per row\n-        const auto key = placeKeysInPool(row_idx, key_column_ptrs, keys, keys_pool);\n-\n-        auto should_rollback = false;\n-\n-        for (const auto attribute_idx : ext::range(0, attributes_size))\n-        {\n-            const auto & attribute_column = *attribute_column_ptrs[attribute_idx];\n-            auto & attribute = attributes[attribute_idx];\n-            const auto inserted = setAttributeValue(attribute, key, attribute_column[row_idx]);\n-            if (!inserted)\n-                should_rollback = true;\n-        }\n-\n-        /// @note on multiple equal keys the mapped value for the first one is stored\n-        if (should_rollback)\n-            keys_pool.rollback(key.size);\n-    }\n-}\n-\n-void ComplexKeyHashedDictionary::updateData()\n-{\n-    /// created upfront to avoid excess allocations\n-    const auto keys_size = dict_struct.key->size();\n-    StringRefs keys(keys_size);\n-\n-    const auto attributes_size = attributes.size();\n-\n-    if (!saved_block || saved_block->rows() == 0)\n-    {\n-        auto stream = source_ptr->loadUpdatedAll();\n-        stream->readPrefix();\n-\n-        while (const auto block = stream->read())\n-        {\n-            /// We are using this method to keep saved data if input stream consists of multiple blocks\n-            if (!saved_block)\n-                saved_block = std::make_shared<DB::Block>(block.cloneEmpty());\n-            for (const auto attribute_idx : ext::range(0, keys_size + attributes_size))\n-            {\n-                const IColumn & update_column = *block.getByPosition(attribute_idx).column.get();\n-                MutableColumnPtr saved_column = saved_block->getByPosition(attribute_idx).column->assumeMutable();\n-                saved_column->insertRangeFrom(update_column, 0, update_column.size());\n-            }\n-        }\n-        stream->readSuffix();\n-    }\n-    else\n-    {\n-        auto stream = source_ptr->loadUpdatedAll();\n-\n-        stream->readPrefix();\n-        while (Block block = stream->read())\n-        {\n-            const auto saved_key_column_ptrs = ext::map<Columns>(\n-                ext::range(0, keys_size), [&](const size_t key_idx) { return saved_block->safeGetByPosition(key_idx).column; });\n-\n-            const auto update_key_column_ptrs = ext::map<Columns>(\n-                ext::range(0, keys_size), [&](const size_t key_idx) { return block.safeGetByPosition(key_idx).column; });\n-\n-            Arena temp_key_pool;\n-            ContainerType<std::vector<size_t>> update_key_hash;\n-\n-            for (size_t i = 0; i < block.rows(); ++i)\n-            {\n-                const auto u_key = placeKeysInPool(i, update_key_column_ptrs, keys, temp_key_pool);\n-                update_key_hash[u_key].push_back(i);\n-            }\n-\n-            const size_t rows = saved_block->rows();\n-            IColumn::Filter filter(rows);\n-\n-            for (size_t i = 0; i < saved_block->rows(); ++i)\n-            {\n-                const auto s_key = placeKeysInPool(i, saved_key_column_ptrs, keys, temp_key_pool);\n-                auto * it = update_key_hash.find(s_key);\n-                if (it)\n-                    filter[i] = 0;\n-                else\n-                    filter[i] = 1;\n-            }\n-\n-            auto block_columns = block.mutateColumns();\n-            for (const auto attribute_idx : ext::range(0, keys_size + attributes_size))\n-            {\n-                auto & column = saved_block->safeGetByPosition(attribute_idx).column;\n-                const auto & filtered_column = column->filter(filter, -1);\n-\n-                block_columns[attribute_idx]->insertRangeFrom(*filtered_column.get(), 0, filtered_column->size());\n-            }\n-\n-            saved_block->setColumns(std::move(block_columns));\n-        }\n-        stream->readSuffix();\n-    }\n-\n-    if (saved_block)\n-        blockToAttributes(*saved_block.get());\n-}\n-\n-void ComplexKeyHashedDictionary::loadData()\n-{\n-    if (!source_ptr->hasUpdateField())\n-    {\n-        auto stream = source_ptr->loadAll();\n-        stream->readPrefix();\n-\n-        while (const auto block = stream->read())\n-            blockToAttributes(block);\n-\n-        stream->readSuffix();\n-    }\n-    else\n-        updateData();\n-\n-    if (require_nonempty && 0 == element_count)\n-        throw Exception{full_name + \": dictionary source is empty and 'require_nonempty' property is set.\", ErrorCodes::DICTIONARY_IS_EMPTY};\n-}\n-\n-template <typename T>\n-void ComplexKeyHashedDictionary::addAttributeSize(const Attribute & attribute)\n-{\n-    const auto & map_ref = std::get<ContainerType<T>>(attribute.maps);\n-    bytes_allocated += sizeof(ContainerType<T>) + map_ref.getBufferSizeInBytes();\n-    bucket_count = map_ref.getBufferSizeInCells();\n-}\n-\n-template <>\n-void ComplexKeyHashedDictionary::addAttributeSize<String>(const Attribute & attribute)\n-{\n-    const auto & map_ref = std::get<ContainerType<StringRef>>(attribute.maps);\n-    bytes_allocated += sizeof(ContainerType<StringRef>) + map_ref.getBufferSizeInBytes();\n-    bucket_count = map_ref.getBufferSizeInCells();\n-    bytes_allocated += sizeof(Arena) + attribute.string_arena->size();\n-}\n-\n-void ComplexKeyHashedDictionary::calculateBytesAllocated()\n-{\n-    bytes_allocated += attributes.size() * sizeof(attributes.front());\n-\n-    for (const auto & attribute : attributes)\n-    {\n-        auto type_call = [&](const auto & dictionary_attribute_type)\n-        {\n-            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-            using AttributeType = typename Type::AttributeType;\n-\n-            addAttributeSize<AttributeType>(attribute);\n-        };\n-\n-        callOnDictionaryAttributeType(attribute.type, type_call);\n-    }\n-\n-    bytes_allocated += keys_pool.size();\n-}\n-\n-template <typename T>\n-void ComplexKeyHashedDictionary::createAttributeImpl(Attribute & attribute, const Field & null_value)\n-{\n-    attribute.null_values = T(null_value.get<T>());\n-    attribute.maps.emplace<ContainerType<T>>();\n-}\n-\n-template <>\n-void ComplexKeyHashedDictionary::createAttributeImpl<String>(Attribute & attribute, const Field & null_value)\n-{\n-    attribute.string_arena = std::make_unique<Arena>();\n-    const String & string = null_value.get<String>();\n-    const char * string_in_arena = attribute.string_arena->insert(string.data(), string.size());\n-    attribute.null_values.emplace<StringRef>(string_in_arena, string.size());\n-    attribute.maps.emplace<ContainerType<StringRef>>();\n-}\n-\n-ComplexKeyHashedDictionary::Attribute\n-ComplexKeyHashedDictionary::createAttribute(const DictionaryAttribute & attribute, const Field & null_value)\n-{\n-    auto nullable_set = attribute.is_nullable ? std::make_unique<NullableSet>() : nullptr;\n-    Attribute attr{attribute.underlying_type, attribute.is_nullable, std::move(nullable_set), {}, {}, {}};\n-\n-    auto type_call = [&](const auto &dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        createAttributeImpl<AttributeType>(attr, null_value);\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.underlying_type, type_call);\n-\n-    return attr;\n-}\n-\n-\n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n-void ComplexKeyHashedDictionary::getItemsImpl(\n-    const Attribute & attribute,\n-    const Columns & key_columns,\n-    ValueSetter && set_value,\n-    DefaultValueExtractor & default_value_extractor) const\n-{\n-    const auto & attr = std::get<ContainerType<AttributeType>>(attribute.maps);\n-\n-    const auto keys_size = key_columns.size();\n-    StringRefs keys(keys_size);\n-    Arena temporary_keys_pool;\n-\n-    const auto rows = key_columns.front()->size();\n-    for (const auto i : ext::range(0, rows))\n-    {\n-        /// copy key data to arena so it is contiguous and return StringRef to it\n-        const auto key = placeKeysInPool(i, key_columns, keys, temporary_keys_pool);\n-\n-        const auto it = attr.find(key);\n-\n-        if (it)\n-        {\n-            set_value(i, static_cast<OutputType>(it->getMapped()), false);\n-        }\n-        else\n-        {\n-            if (attribute.is_nullable && attribute.nullable_set->find(key) != nullptr)\n-                set_value(i, default_value_extractor[i], true);\n-            else\n-                set_value(i, default_value_extractor[i], false);\n-        }\n-\n-        /// free memory allocated for the key\n-        temporary_keys_pool.rollback(key.size);\n-    }\n-\n-    query_count.fetch_add(rows, std::memory_order_relaxed);\n-}\n-\n-\n-template <typename T>\n-bool ComplexKeyHashedDictionary::setAttributeValueImpl(Attribute & attribute, const StringRef key, const T value)\n-{\n-    auto & map = std::get<ContainerType<T>>(attribute.maps);\n-    const auto pair = map.insert({key, value});\n-    return pair.second;\n-}\n-\n-template <>\n-bool ComplexKeyHashedDictionary::setAttributeValueImpl<String>(Attribute & attribute, const StringRef key, const String value)\n-{\n-    const auto * string_in_arena = attribute.string_arena->insert(value.data(), value.size());\n-    return setAttributeValueImpl<StringRef>(attribute, key, StringRef{string_in_arena, value.size()});\n-}\n-\n-bool ComplexKeyHashedDictionary::setAttributeValue(Attribute & attribute, const StringRef key, const Field & value)\n-{\n-    bool result = false;\n-\n-    auto type_call = [&](const auto &dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-\n-        if (attribute.is_nullable)\n-        {\n-            if (value.isNull())\n-            {\n-                attribute.nullable_set->insert(key);\n-                result = true;\n-                return;\n-            }\n-            else\n-            {\n-                attribute.nullable_set->erase(key);\n-            }\n-        }\n-\n-        result = setAttributeValueImpl<AttributeType>(attribute, key, value.get<AttributeType>());\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-\n-    return result;\n-}\n-\n-const ComplexKeyHashedDictionary::Attribute & ComplexKeyHashedDictionary::getAttribute(const std::string & attribute_name) const\n-{\n-    const auto it = attribute_index_by_name.find(attribute_name);\n-    if (it == std::end(attribute_index_by_name))\n-        throw Exception{full_name + \": no such attribute '\" + attribute_name + \"'\", ErrorCodes::BAD_ARGUMENTS};\n-\n-    return attributes[it->second];\n-}\n-\n-StringRef ComplexKeyHashedDictionary::placeKeysInPool(const size_t row, const Columns & key_columns, StringRefs & keys, Arena & pool)\n-{\n-    const auto keys_size = key_columns.size();\n-    size_t sum_keys_size{};\n-\n-    const char * block_start = nullptr;\n-    for (size_t j = 0; j < keys_size; ++j)\n-    {\n-        keys[j] = key_columns[j]->serializeValueIntoArena(row, pool, block_start);\n-        sum_keys_size += keys[j].size;\n-    }\n-\n-    const auto * key_start = block_start;\n-    for (size_t j = 0; j < keys_size; ++j)\n-    {\n-        keys[j].data = key_start;\n-        key_start += keys[j].size;\n-    }\n-\n-    return {block_start, sum_keys_size};\n-}\n-\n-template <typename T>\n-void ComplexKeyHashedDictionary::has(const Attribute & attribute, const Columns & key_columns, PaddedPODArray<UInt8> & out) const\n-{\n-    const auto & attr = std::get<ContainerType<T>>(attribute.maps);\n-    const auto keys_size = key_columns.size();\n-    StringRefs keys(keys_size);\n-    Arena temporary_keys_pool;\n-    const auto rows = key_columns.front()->size();\n-\n-    for (const auto i : ext::range(0, rows))\n-    {\n-        /// copy key data to arena so it is contiguous and return StringRef to it\n-        const auto key = placeKeysInPool(i, key_columns, keys, temporary_keys_pool);\n-\n-        const auto it = attr.find(key);\n-        out[i] = static_cast<bool>(it);\n-\n-        if (attribute.is_nullable && !out[i])\n-            out[i] = attribute.nullable_set->find(key) != nullptr;\n-\n-        /// free memory allocated for the key\n-        temporary_keys_pool.rollback(key.size);\n-    }\n-\n-    query_count.fetch_add(rows, std::memory_order_relaxed);\n-}\n-\n-std::vector<StringRef> ComplexKeyHashedDictionary::getKeys() const\n-{\n-    const Attribute & attribute = attributes.front();\n-\n-    std::vector<StringRef> result;\n-\n-    auto type_call = [&](const auto & dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-\n-        if constexpr (std::is_same_v<AttributeType, String>)\n-        {\n-            result = getKeys<StringRef>(attribute);\n-        }\n-        else\n-        {\n-            result = getKeys<AttributeType>(attribute);\n-        }\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-\n-    return result;\n-}\n-\n-template <typename T>\n-std::vector<StringRef> ComplexKeyHashedDictionary::getKeys(const Attribute & attribute) const\n-{\n-    const ContainerType<T> & attr = std::get<ContainerType<T>>(attribute.maps);\n-    std::vector<StringRef> keys;\n-    keys.reserve(attr.size());\n-    for (const auto & key : attr)\n-        keys.push_back(key.getKey());\n-\n-    if (attribute.is_nullable)\n-    {\n-        for (const auto & key: *attribute.nullable_set)\n-            keys.push_back(key.getKey());\n-    }\n-\n-    return keys;\n-}\n-\n-BlockInputStreamPtr ComplexKeyHashedDictionary::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n-{\n-    using BlockInputStreamType = DictionaryBlockInputStream<UInt64>;\n-    auto vector_keys = getKeys();\n-\n-    PaddedPODArray<StringRef> keys;\n-    keys.reserve(vector_keys.size());\n-    keys.assign(vector_keys.begin(), vector_keys.end());\n-\n-    return std::make_shared<BlockInputStreamType>(shared_from_this(), max_block_size, keys, column_names);\n-}\n-\n-void registerDictionaryComplexKeyHashed(DictionaryFactory & factory)\n-{\n-    auto create_layout = [=](const std::string &,\n-                             const DictionaryStructure & dict_struct,\n-                             const Poco::Util::AbstractConfiguration & config,\n-                             const std::string & config_prefix,\n-                             DictionarySourcePtr source_ptr) -> DictionaryPtr\n-    {\n-        if (!dict_struct.key)\n-            throw Exception{\"'key' is required for dictionary of layout 'complex_key_hashed'\", ErrorCodes::BAD_ARGUMENTS};\n-\n-        const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n-        const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n-        const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<ComplexKeyHashedDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n-    };\n-    factory.registerLayout(\"complex_key_hashed\", create_layout, true);\n-}\n-\n-}\ndiff --git a/src/Dictionaries/ComplexKeyHashedDictionary.h b/src/Dictionaries/ComplexKeyHashedDictionary.h\ndeleted file mode 100644\nindex 091974bbf435..000000000000\n--- a/src/Dictionaries/ComplexKeyHashedDictionary.h\n+++ /dev/null\n@@ -1,185 +0,0 @@\n-#pragma once\n-\n-#include <atomic>\n-#include <memory>\n-#include <variant>\n-#include <Columns/ColumnDecimal.h>\n-#include <Columns/ColumnString.h>\n-#include <Common/Arena.h>\n-#include <Common/HashTable/HashMap.h>\n-#include <Common/HashTable/HashSet.h>\n-#include <Core/Block.h>\n-#include <common/StringRef.h>\n-#include <ext/range.h>\n-#include \"IDictionary.h\"\n-#include \"IDictionarySource.h\"\n-#include \"DictionaryStructure.h\"\n-#include \"DictionaryHelpers.h\"\n-\n-namespace DB\n-{\n-\n-class ComplexKeyHashedDictionary final : public IDictionaryBase\n-{\n-public:\n-    ComplexKeyHashedDictionary(\n-        const StorageID & dict_id_,\n-        const DictionaryStructure & dict_struct_,\n-        DictionarySourcePtr source_ptr_,\n-        const DictionaryLifetime dict_lifetime_,\n-        bool require_nonempty_,\n-        BlockPtr saved_block_ = nullptr);\n-\n-    std::string getKeyDescription() const { return key_description; }\n-\n-    std::string getTypeName() const override { return \"ComplexKeyHashed\"; }\n-\n-    size_t getBytesAllocated() const override { return bytes_allocated; }\n-\n-    size_t getQueryCount() const override { return query_count.load(std::memory_order_relaxed); }\n-\n-    double getHitRate() const override { return 1.0; }\n-\n-    size_t getElementCount() const override { return element_count; }\n-\n-    double getLoadFactor() const override { return static_cast<double>(element_count) / bucket_count; }\n-\n-    std::shared_ptr<const IExternalLoadable> clone() const override\n-    {\n-        return std::make_shared<ComplexKeyHashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, saved_block);\n-    }\n-\n-    const IDictionarySource * getSource() const override { return source_ptr.get(); }\n-\n-    const DictionaryLifetime & getLifetime() const override { return dict_lifetime; }\n-\n-    const DictionaryStructure & getStructure() const override { return dict_struct; }\n-\n-    bool isInjective(const std::string & attribute_name) const override\n-    {\n-        return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;\n-    }\n-\n-    DictionaryKeyType getKeyType() const override { return DictionaryKeyType::complex; }\n-\n-    ColumnPtr getColumn(\n-        const std::string& attribute_name,\n-        const DataTypePtr & result_type,\n-        const Columns & key_columns,\n-        const DataTypes & key_types,\n-        const ColumnPtr & default_values_column) const override;\n-\n-    ColumnUInt8::Ptr hasKeys(const Columns & key_columns, const DataTypes & key_types) const override;\n-\n-    BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;\n-\n-private:\n-    template <typename Value>\n-    using ContainerType = HashMapWithSavedHash<StringRef, Value, StringRefHash>;\n-\n-    using NullableSet = HashSetWithSavedHash<StringRef, StringRefHash>;\n-\n-    struct Attribute final\n-    {\n-        AttributeUnderlyingType type;\n-        bool is_nullable;\n-        std::unique_ptr<NullableSet> nullable_set;\n-\n-        std::variant<\n-            UInt8,\n-            UInt16,\n-            UInt32,\n-            UInt64,\n-            UInt128,\n-            Int8,\n-            Int16,\n-            Int32,\n-            Int64,\n-            Decimal32,\n-            Decimal64,\n-            Decimal128,\n-            Float32,\n-            Float64,\n-            StringRef>\n-            null_values;\n-        std::variant<\n-            ContainerType<UInt8>,\n-            ContainerType<UInt16>,\n-            ContainerType<UInt32>,\n-            ContainerType<UInt64>,\n-            ContainerType<UInt128>,\n-            ContainerType<Int8>,\n-            ContainerType<Int16>,\n-            ContainerType<Int32>,\n-            ContainerType<Int64>,\n-            ContainerType<Decimal32>,\n-            ContainerType<Decimal64>,\n-            ContainerType<Decimal128>,\n-            ContainerType<Float32>,\n-            ContainerType<Float64>,\n-            ContainerType<StringRef>>\n-            maps;\n-        std::unique_ptr<Arena> string_arena;\n-    };\n-\n-    void createAttributes();\n-\n-    void blockToAttributes(const Block & block);\n-\n-    void updateData();\n-\n-    void loadData();\n-\n-    template <typename T>\n-    void addAttributeSize(const Attribute & attribute);\n-\n-    void calculateBytesAllocated();\n-\n-    template <typename T>\n-    static void createAttributeImpl(Attribute & attribute, const Field & null_value);\n-\n-    static Attribute createAttribute(const DictionaryAttribute & attribute, const Field & null_value);\n-\n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n-    void getItemsImpl(\n-        const Attribute & attribute,\n-        const Columns & key_columns,\n-        ValueSetter && set_value,\n-        DefaultValueExtractor & default_value_extractor) const;\n-\n-    template <typename T>\n-    static bool setAttributeValueImpl(Attribute & attribute, const StringRef key, const T value);\n-\n-    static bool setAttributeValue(Attribute & attribute, const StringRef key, const Field & value);\n-\n-    const Attribute & getAttribute(const std::string & attribute_name) const;\n-\n-    static StringRef placeKeysInPool(const size_t row, const Columns & key_columns, StringRefs & keys, Arena & pool);\n-\n-    template <typename T>\n-    void has(const Attribute & attribute, const Columns & key_columns, PaddedPODArray<UInt8> & out) const;\n-\n-    std::vector<StringRef> getKeys() const;\n-\n-    template <typename T>\n-    std::vector<StringRef> getKeys(const Attribute & attribute) const;\n-\n-    const DictionaryStructure dict_struct;\n-    const DictionarySourcePtr source_ptr;\n-    const DictionaryLifetime dict_lifetime;\n-    const bool require_nonempty;\n-    const std::string key_description{dict_struct.getKeyDescription()};\n-\n-    std::map<std::string, size_t> attribute_index_by_name;\n-    std::vector<Attribute> attributes;\n-    Arena keys_pool;\n-\n-    size_t bytes_allocated = 0;\n-    size_t element_count = 0;\n-    size_t bucket_count = 0;\n-    mutable std::atomic<size_t> query_count{0};\n-\n-    BlockPtr saved_block;\n-};\n-\n-}\ndiff --git a/src/Dictionaries/DictionaryBlockInputStream.cpp b/src/Dictionaries/DictionaryBlockInputStream.cpp\nnew file mode 100644\nindex 000000000000..433ff2118314\n--- /dev/null\n+++ b/src/Dictionaries/DictionaryBlockInputStream.cpp\n@@ -0,0 +1,200 @@\n+#include \"DictionaryBlockInputStream.h\"\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+DictionaryBlockInputStream::DictionaryBlockInputStream(\n+    std::shared_ptr<const IDictionary> dictionary_, UInt64 max_block_size_, PaddedPODArray<UInt64> && ids_, const Names & column_names_)\n+    : DictionaryBlockInputStreamBase(ids_.size(), max_block_size_)\n+    , dictionary(dictionary_)\n+    , column_names(column_names_)\n+    , ids(std::move(ids_))\n+    , key_type(DictionaryInputStreamKeyType::Id)\n+{\n+}\n+\n+DictionaryBlockInputStream::DictionaryBlockInputStream(\n+    std::shared_ptr<const IDictionary> dictionary_,\n+    UInt64 max_block_size_,\n+    const PaddedPODArray<StringRef> & keys,\n+    const Names & column_names_)\n+    : DictionaryBlockInputStreamBase(keys.size(), max_block_size_)\n+    , dictionary(dictionary_)\n+    , column_names(column_names_)\n+    , key_type(DictionaryInputStreamKeyType::ComplexKey)\n+{\n+    const DictionaryStructure & dictionary_structure = dictionary->getStructure();\n+    fillKeyColumns(keys, 0, keys.size(), dictionary_structure, key_columns);\n+}\n+\n+DictionaryBlockInputStream::DictionaryBlockInputStream(\n+    std::shared_ptr<const IDictionary> dictionary_,\n+    UInt64 max_block_size_,\n+    const Columns & data_columns_,\n+    const Names & column_names_,\n+    GetColumnsFunction && get_key_columns_function_,\n+    GetColumnsFunction && get_view_columns_function_)\n+    : DictionaryBlockInputStreamBase(data_columns_.front()->size(), max_block_size_)\n+    , dictionary(dictionary_)\n+    , column_names(column_names_)\n+    , data_columns(data_columns_)\n+    , get_key_columns_function(std::move(get_key_columns_function_))\n+    , get_view_columns_function(std::move(get_view_columns_function_))\n+    , key_type(DictionaryInputStreamKeyType::Callback)\n+{\n+}\n+\n+Block DictionaryBlockInputStream::getBlock(size_t start, size_t length) const\n+{\n+    /// TODO: Rewrite\n+    switch (key_type)\n+    {\n+        case DictionaryInputStreamKeyType::ComplexKey:\n+        {\n+            Columns columns;\n+            ColumnsWithTypeAndName view_columns;\n+            columns.reserve(key_columns.size());\n+            for (const auto & key_column : key_columns)\n+            {\n+                ColumnPtr column = key_column.column->cut(start, length);\n+                columns.emplace_back(column);\n+                view_columns.emplace_back(column, key_column.type, key_column.name);\n+            }\n+            return fillBlock({}, columns, {}, std::move(view_columns));\n+        }\n+\n+        case DictionaryInputStreamKeyType::Id:\n+        {\n+            PaddedPODArray<UInt64> ids_to_fill(ids.begin() + start, ids.begin() + start + length);\n+            return fillBlock(ids_to_fill, {}, {}, {});\n+        }\n+\n+        case DictionaryInputStreamKeyType::Callback:\n+        {\n+            Columns columns;\n+            columns.reserve(data_columns.size());\n+            for (const auto & data_column : data_columns)\n+                columns.push_back(data_column->cut(start, length));\n+            const DictionaryStructure & dictionaty_structure = dictionary->getStructure();\n+            const auto & attributes = *dictionaty_structure.key;\n+            ColumnsWithTypeAndName keys_with_type_and_name = get_key_columns_function(columns, attributes);\n+            ColumnsWithTypeAndName view_with_type_and_name = get_view_columns_function(columns, attributes);\n+            DataTypes types;\n+            columns.clear();\n+            for (const auto & key_column : keys_with_type_and_name)\n+            {\n+                columns.push_back(key_column.column);\n+                types.push_back(key_column.type);\n+            }\n+            return fillBlock({}, columns, types, std::move(view_with_type_and_name));\n+        }\n+    }\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unexpected DictionaryInputStreamKeyType.\");\n+}\n+\n+Block DictionaryBlockInputStream::fillBlock(\n+    const PaddedPODArray<UInt64> & ids_to_fill,\n+    const Columns & keys,\n+    const DataTypes & types,\n+    ColumnsWithTypeAndName && view) const\n+{\n+    std::unordered_set<std::string> names(column_names.begin(), column_names.end());\n+\n+    DataTypes data_types = types;\n+    ColumnsWithTypeAndName block_columns;\n+\n+    data_types.reserve(keys.size());\n+    const DictionaryStructure & dictionary_structure = dictionary->getStructure();\n+    if (data_types.empty() && dictionary_structure.key)\n+        for (const auto & key : *dictionary_structure.key)\n+            data_types.push_back(key.type);\n+\n+    for (const auto & column : view)\n+        if (names.find(column.name) != names.end())\n+            block_columns.push_back(column);\n+\n+    const DictionaryStructure & structure = dictionary->getStructure();\n+    ColumnPtr ids_column = getColumnFromIds(ids_to_fill);\n+\n+    if (structure.id && names.find(structure.id->name) != names.end())\n+    {\n+        block_columns.emplace_back(ids_column, std::make_shared<DataTypeUInt64>(), structure.id->name);\n+    }\n+\n+    auto dictionary_key_type = dictionary->getKeyType();\n+\n+    for (const auto idx : ext::range(0, structure.attributes.size()))\n+    {\n+        const DictionaryAttribute & attribute = structure.attributes[idx];\n+        if (names.find(attribute.name) != names.end())\n+        {\n+            ColumnPtr column;\n+\n+            if (dictionary_key_type == DictionaryKeyType::simple)\n+            {\n+                column = dictionary->getColumn(\n+                    attribute.name,\n+                    attribute.type,\n+                    {ids_column},\n+                    {std::make_shared<DataTypeUInt64>()},\n+                    nullptr /* default_values_column */);\n+            }\n+            else\n+            {\n+                column = dictionary->getColumn(\n+                    attribute.name,\n+                    attribute.type,\n+                    keys,\n+                    data_types,\n+                    nullptr /* default_values_column*/);\n+            }\n+\n+            block_columns.emplace_back(column, attribute.type, attribute.name);\n+        }\n+    }\n+\n+    return Block(block_columns);\n+}\n+\n+ColumnPtr DictionaryBlockInputStream::getColumnFromIds(const PaddedPODArray<UInt64> & ids_to_fill)\n+{\n+    auto column_vector = ColumnVector<UInt64>::create();\n+    column_vector->getData().assign(ids_to_fill);\n+    return column_vector;\n+}\n+\n+void DictionaryBlockInputStream::fillKeyColumns(\n+    const PaddedPODArray<StringRef> & keys,\n+    size_t start,\n+    size_t size,\n+    const DictionaryStructure & dictionary_structure,\n+    ColumnsWithTypeAndName & result)\n+{\n+    MutableColumns columns;\n+    columns.reserve(dictionary_structure.key->size());\n+\n+    for (const DictionaryAttribute & attribute : *dictionary_structure.key)\n+        columns.emplace_back(attribute.type->createColumn());\n+\n+    for (auto idx : ext::range(start, size))\n+    {\n+        const auto & key = keys[idx];\n+        const auto *ptr = key.data;\n+        for (auto & column : columns)\n+            ptr = column->deserializeAndInsertFromArena(ptr);\n+    }\n+\n+    for (size_t i = 0, num_columns = columns.size(); i < num_columns; ++i)\n+    {\n+        const auto & dictionary_attribute = (*dictionary_structure.key)[i];\n+        result.emplace_back(ColumnWithTypeAndName{std::move(columns[i]), dictionary_attribute.type, dictionary_attribute.name});\n+    }\n+}\n+\n+}\ndiff --git a/src/Dictionaries/DictionaryBlockInputStream.h b/src/Dictionaries/DictionaryBlockInputStream.h\nindex 71615efa7f8e..5197df411fa7 100644\n--- a/src/Dictionaries/DictionaryBlockInputStream.h\n+++ b/src/Dictionaries/DictionaryBlockInputStream.h\n@@ -16,27 +16,22 @@\n \n namespace DB\n {\n-namespace ErrorCodes\n-{\n-    extern const int LOGICAL_ERROR;\n-}\n \n /// TODO: Remove this class\n /* BlockInputStream implementation for external dictionaries\n  * read() returns blocks consisting of the in-memory contents of the dictionaries\n  */\n-template <typename Key>\n class DictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n {\n public:\n     DictionaryBlockInputStream(\n-        std::shared_ptr<const IDictionaryBase> dictionary,\n+        std::shared_ptr<const IDictionary> dictionary,\n         UInt64 max_block_size,\n-        PaddedPODArray<Key> && ids,\n+        PaddedPODArray<UInt64> && ids,\n         const Names & column_names);\n \n     DictionaryBlockInputStream(\n-        std::shared_ptr<const IDictionaryBase> dictionary,\n+        std::shared_ptr<const IDictionary> dictionary,\n         UInt64 max_block_size,\n         const PaddedPODArray<StringRef> & keys,\n         const Names & column_names);\n@@ -48,7 +43,7 @@ class DictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n     // and get_view_columns_function to get key representation.\n     // Now used in trie dictionary, where columns are stored as ip and mask, and are showed as string\n     DictionaryBlockInputStream(\n-        std::shared_ptr<const IDictionaryBase> dictionary,\n+        std::shared_ptr<const IDictionary> dictionary,\n         UInt64 max_block_size,\n         const Columns & data_columns,\n         const Names & column_names,\n@@ -61,21 +56,24 @@ class DictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n     Block getBlock(size_t start, size_t length) const override;\n \n private:\n-    Block\n-    fillBlock(const PaddedPODArray<Key> & ids_to_fill, const Columns & keys, const DataTypes & types, ColumnsWithTypeAndName && view) const;\n+    Block fillBlock(\n+        const PaddedPODArray<UInt64> & ids_to_fill,\n+        const Columns & keys,\n+        const DataTypes & types,\n+        ColumnsWithTypeAndName && view) const;\n \n-    ColumnPtr getColumnFromIds(const PaddedPODArray<Key> & ids_to_fill) const;\n+    static ColumnPtr getColumnFromIds(const PaddedPODArray<UInt64> & ids_to_fill);\n \n-    void fillKeyColumns(\n+    static void fillKeyColumns(\n         const PaddedPODArray<StringRef> & keys,\n         size_t start,\n         size_t size,\n         const DictionaryStructure & dictionary_structure,\n-        ColumnsWithTypeAndName & columns) const;\n+        ColumnsWithTypeAndName & result);\n \n-    std::shared_ptr<const IDictionaryBase> dictionary;\n+    std::shared_ptr<const IDictionary> dictionary;\n     Names column_names;\n-    PaddedPODArray<Key> ids;\n+    PaddedPODArray<UInt64> ids;\n     ColumnsWithTypeAndName key_columns;\n \n     Columns data_columns;\n@@ -92,200 +90,4 @@ class DictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n     DictionaryInputStreamKeyType key_type;\n };\n \n-\n-template <typename Key>\n-DictionaryBlockInputStream<Key>::DictionaryBlockInputStream(\n-    std::shared_ptr<const IDictionaryBase> dictionary_, UInt64 max_block_size_, PaddedPODArray<Key> && ids_, const Names & column_names_)\n-    : DictionaryBlockInputStreamBase(ids_.size(), max_block_size_)\n-    , dictionary(dictionary_)\n-    , column_names(column_names_)\n-    , ids(std::move(ids_))\n-    , key_type(DictionaryInputStreamKeyType::Id)\n-{\n-}\n-\n-template <typename Key>\n-DictionaryBlockInputStream<Key>::DictionaryBlockInputStream(\n-    std::shared_ptr<const IDictionaryBase> dictionary_,\n-    UInt64 max_block_size_,\n-    const PaddedPODArray<StringRef> & keys,\n-    const Names & column_names_)\n-    : DictionaryBlockInputStreamBase(keys.size(), max_block_size_)\n-    , dictionary(dictionary_)\n-    , column_names(column_names_)\n-    , key_type(DictionaryInputStreamKeyType::ComplexKey)\n-{\n-    const DictionaryStructure & dictionary_structure = dictionary->getStructure();\n-    fillKeyColumns(keys, 0, keys.size(), dictionary_structure, key_columns);\n-}\n-\n-template <typename Key>\n-DictionaryBlockInputStream<Key>::DictionaryBlockInputStream(\n-    std::shared_ptr<const IDictionaryBase> dictionary_,\n-    UInt64 max_block_size_,\n-    const Columns & data_columns_,\n-    const Names & column_names_,\n-    GetColumnsFunction && get_key_columns_function_,\n-    GetColumnsFunction && get_view_columns_function_)\n-    : DictionaryBlockInputStreamBase(data_columns_.front()->size(), max_block_size_)\n-    , dictionary(dictionary_)\n-    , column_names(column_names_)\n-    , data_columns(data_columns_)\n-    , get_key_columns_function(std::move(get_key_columns_function_))\n-    , get_view_columns_function(std::move(get_view_columns_function_))\n-    , key_type(DictionaryInputStreamKeyType::Callback)\n-{\n-}\n-\n-\n-template <typename Key>\n-Block DictionaryBlockInputStream<Key>::getBlock(size_t start, size_t length) const\n-{\n-    /// TODO: Rewrite\n-    switch (key_type)\n-    {\n-        case DictionaryInputStreamKeyType::ComplexKey:\n-        {\n-            Columns columns;\n-            ColumnsWithTypeAndName view_columns;\n-            columns.reserve(key_columns.size());\n-            for (const auto & key_column : key_columns)\n-            {\n-                ColumnPtr column = key_column.column->cut(start, length);\n-                columns.emplace_back(column);\n-                view_columns.emplace_back(column, key_column.type, key_column.name);\n-            }\n-            return fillBlock({}, columns, {}, std::move(view_columns));\n-        }\n-\n-        case DictionaryInputStreamKeyType::Id:\n-        {\n-            PaddedPODArray<Key> ids_to_fill(ids.begin() + start, ids.begin() + start + length);\n-            return fillBlock(ids_to_fill, {}, {}, {});\n-        }\n-\n-        case DictionaryInputStreamKeyType::Callback:\n-        {\n-            Columns columns;\n-            columns.reserve(data_columns.size());\n-            for (const auto & data_column : data_columns)\n-                columns.push_back(data_column->cut(start, length));\n-            const DictionaryStructure & dictionaty_structure = dictionary->getStructure();\n-            const auto & attributes = *dictionaty_structure.key;\n-            ColumnsWithTypeAndName keys_with_type_and_name = get_key_columns_function(columns, attributes);\n-            ColumnsWithTypeAndName view_with_type_and_name = get_view_columns_function(columns, attributes);\n-            DataTypes types;\n-            columns.clear();\n-            for (const auto & key_column : keys_with_type_and_name)\n-            {\n-                columns.push_back(key_column.column);\n-                types.push_back(key_column.type);\n-            }\n-            return fillBlock({}, columns, types, std::move(view_with_type_and_name));\n-        }\n-    }\n-\n-    throw Exception(\"Unexpected DictionaryInputStreamKeyType.\", ErrorCodes::LOGICAL_ERROR);\n-}\n-\n-template <typename Key>\n-Block DictionaryBlockInputStream<Key>::fillBlock(\n-    const PaddedPODArray<Key> & ids_to_fill, const Columns & keys, const DataTypes & types, ColumnsWithTypeAndName && view) const\n-{\n-    std::unordered_set<std::string> names(column_names.begin(), column_names.end());\n-\n-    DataTypes data_types = types;\n-    ColumnsWithTypeAndName block_columns;\n-\n-    data_types.reserve(keys.size());\n-    const DictionaryStructure & dictionaty_structure = dictionary->getStructure();\n-    if (data_types.empty() && dictionaty_structure.key)\n-        for (const auto & key : *dictionaty_structure.key)\n-            data_types.push_back(key.type);\n-\n-    for (const auto & column : view)\n-        if (names.find(column.name) != names.end())\n-            block_columns.push_back(column);\n-\n-    const DictionaryStructure & structure = dictionary->getStructure();\n-    ColumnPtr ids_column = getColumnFromIds(ids_to_fill);\n-\n-    if (structure.id && names.find(structure.id->name) != names.end())\n-    {\n-        block_columns.emplace_back(ids_column, std::make_shared<DataTypeUInt64>(), structure.id->name);\n-    }\n-\n-    auto dictionary_key_type = dictionary->getKeyType();\n-\n-    for (const auto idx : ext::range(0, structure.attributes.size()))\n-    {\n-        const DictionaryAttribute & attribute = structure.attributes[idx];\n-        if (names.find(attribute.name) != names.end())\n-        {\n-            ColumnPtr column;\n-\n-            if (dictionary_key_type == DictionaryKeyType::simple)\n-            {\n-                column = dictionary->getColumn(\n-                    attribute.name,\n-                    attribute.type,\n-                    {ids_column},\n-                    {std::make_shared<DataTypeUInt64>()},\n-                    nullptr /* default_values_column */);\n-            }\n-            else\n-            {\n-                column = dictionary->getColumn(\n-                    attribute.name,\n-                    attribute.type,\n-                    keys,\n-                    data_types,\n-                    nullptr /* default_values_column*/);\n-            }\n-\n-            block_columns.emplace_back(column, attribute.type, attribute.name);\n-        }\n-    }\n-\n-    return Block(block_columns);\n-}\n-\n-template <typename Key>\n-ColumnPtr DictionaryBlockInputStream<Key>::getColumnFromIds(const PaddedPODArray<Key> & ids_to_fill) const\n-{\n-    auto column_vector = ColumnVector<UInt64>::create();\n-    column_vector->getData().reserve(ids_to_fill.size());\n-    for (UInt64 id : ids_to_fill)\n-        column_vector->insertValue(id);\n-    return column_vector;\n-}\n-\n-\n-template <typename Key>\n-void DictionaryBlockInputStream<Key>::fillKeyColumns(\n-    const PaddedPODArray<StringRef> & keys,\n-    size_t start,\n-    size_t size,\n-    const DictionaryStructure & dictionary_structure,\n-    ColumnsWithTypeAndName & res) const\n-{\n-    MutableColumns columns;\n-    columns.reserve(dictionary_structure.key->size());\n-\n-    for (const DictionaryAttribute & attribute : *dictionary_structure.key)\n-        columns.emplace_back(attribute.type->createColumn());\n-\n-    for (auto idx : ext::range(start, size))\n-    {\n-        const auto & key = keys[idx];\n-        const auto *ptr = key.data;\n-        for (auto & column : columns)\n-            ptr = column->deserializeAndInsertFromArena(ptr);\n-    }\n-\n-    for (size_t i = 0, num_columns = columns.size(); i < num_columns; ++i)\n-        res.emplace_back(\n-            ColumnWithTypeAndName{std::move(columns[i]), (*dictionary_structure.key)[i].type, (*dictionary_structure.key)[i].name});\n-}\n-\n }\ndiff --git a/src/Dictionaries/DictionaryHelpers.h b/src/Dictionaries/DictionaryHelpers.h\nindex 5fda5f2599ea..3e7063bb9ef1 100644\n--- a/src/Dictionaries/DictionaryHelpers.h\n+++ b/src/Dictionaries/DictionaryHelpers.h\n@@ -295,6 +295,28 @@ class DictionaryDefaultValueExtractor\n     bool use_default_value_from_column = false;\n };\n \n+template <DictionaryKeyType key_type>\n+class DictionaryKeysArenaHolder;\n+\n+template <>\n+class DictionaryKeysArenaHolder<DictionaryKeyType::simple>\n+{\n+public:\n+    static Arena * getComplexKeyArena() { return nullptr; }\n+};\n+\n+template <>\n+class DictionaryKeysArenaHolder<DictionaryKeyType::complex>\n+{\n+public:\n+\n+    Arena * getComplexKeyArena() { return &complex_key_arena; }\n+\n+private:\n+    Arena complex_key_arena;\n+};\n+\n+\n template <DictionaryKeyType key_type>\n class DictionaryKeysExtractor\n {\n@@ -302,67 +324,96 @@ class DictionaryKeysExtractor\n     using KeyType = std::conditional_t<key_type == DictionaryKeyType::simple, UInt64, StringRef>;\n     static_assert(key_type != DictionaryKeyType::range, \"Range key type is not supported by DictionaryKeysExtractor\");\n \n-    explicit DictionaryKeysExtractor(const Columns & key_columns, Arena & existing_arena)\n+    explicit DictionaryKeysExtractor(const Columns & key_columns_, Arena * complex_key_arena_)\n+        : key_columns(key_columns_)\n+        , complex_key_arena(complex_key_arena_)\n     {\n         assert(!key_columns.empty());\n \n         if constexpr (key_type == DictionaryKeyType::simple)\n-            keys = getColumnVectorData(key_columns.front());\n-        else\n-            keys = deserializeKeyColumnsInArena(key_columns, existing_arena);\n-    }\n+        {\n+            key_columns[0] = key_columns[0]->convertToFullColumnIfConst();\n \n+            const auto * vector_col = checkAndGetColumn<ColumnVector<UInt64>>(key_columns[0].get());\n+            if (!vector_col)\n+                throw Exception(ErrorCodes::TYPE_MISMATCH, \"Column type mismatch for simple key expected UInt64\");\n+        }\n \n-    const PaddedPODArray<KeyType> & getKeys() const\n-    {\n-        return keys;\n+        keys_size = key_columns.front()->size();\n     }\n \n-private:\n-    static PaddedPODArray<UInt64> getColumnVectorData(const ColumnPtr column)\n+    inline size_t getKeysSize() const\n     {\n-        PaddedPODArray<UInt64> result;\n-\n-        auto full_column = column->convertToFullColumnIfConst();\n-        const auto *vector_col = checkAndGetColumn<ColumnVector<UInt64>>(full_column.get());\n-\n-        if (!vector_col)\n-            throw Exception{ErrorCodes::TYPE_MISMATCH, \"Column type mismatch for simple key expected UInt64\"};\n-\n-        result.assign(vector_col->getData());\n-\n-        return result;\n+        return keys_size;\n     }\n \n-    static PaddedPODArray<StringRef> deserializeKeyColumnsInArena(const Columns & key_columns, Arena & temporary_arena)\n+    inline size_t getCurrentKeyIndex() const\n     {\n-        size_t keys_size = key_columns.front()->size();\n+        return current_key_index;\n+    }\n \n-        PaddedPODArray<StringRef> result;\n-        result.reserve(keys_size);\n+    inline KeyType extractCurrentKey()\n+    {\n+        assert(current_key_index < keys_size);\n \n-        PaddedPODArray<StringRef> temporary_column_data(key_columns.size());\n+        if constexpr (key_type == DictionaryKeyType::simple)\n+        {\n+            const auto & column_vector = static_cast<const ColumnVector<UInt64> &>(*key_columns[0]);\n+            const auto & data = column_vector.getData();\n \n-        for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+            auto key = data[current_key_index];\n+            ++current_key_index;\n+            return key;\n+        }\n+        else\n         {\n             size_t allocated_size_for_columns = 0;\n             const char * block_start = nullptr;\n \n-            for (size_t column_index = 0; column_index < key_columns.size(); ++column_index)\n+            for (const auto & column : key_columns)\n             {\n-                const auto & column = key_columns[column_index];\n-                temporary_column_data[column_index] = column->serializeValueIntoArena(key_index, temporary_arena, block_start);\n-                allocated_size_for_columns += temporary_column_data[column_index].size;\n+                StringRef serialized_data = column->serializeValueIntoArena(current_key_index, *complex_key_arena, block_start);\n+                allocated_size_for_columns += serialized_data.size;\n             }\n \n-            result.push_back(StringRef{block_start, allocated_size_for_columns});\n+            ++current_key_index;\n+            current_complex_key = StringRef{block_start, allocated_size_for_columns};\n+            return  current_complex_key;\n+        }\n+    }\n+\n+    void rollbackCurrentKey() const\n+    {\n+        if constexpr (key_type == DictionaryKeyType::complex)\n+            complex_key_arena->rollback(current_complex_key.size);\n+    }\n+\n+    PaddedPODArray<KeyType> extractAllKeys()\n+    {\n+        PaddedPODArray<KeyType> result;\n+        result.reserve(keys_size - current_key_index);\n+\n+        for (; current_key_index < keys_size;)\n+        {\n+            auto value = extractCurrentKey();\n+            result.emplace_back(value);\n         }\n \n         return result;\n     }\n \n-    PaddedPODArray<KeyType> keys;\n+    void reset()\n+    {\n+        current_key_index = 0;\n+    }\n+private:\n+    Columns key_columns;\n+\n+    size_t keys_size = 0;\n+    size_t current_key_index = 0;\n \n+    KeyType current_complex_key {};\n+    Arena * complex_key_arena;\n };\n \n /**\n@@ -370,9 +421,10 @@ class DictionaryKeysExtractor\n \n  * If column is constant parameter backup_storage is used to store values.\n  */\n+/// TODO: Remove\n template <typename T>\n static const PaddedPODArray<T> & getColumnVectorData(\n-    const IDictionaryBase * dictionary,\n+    const IDictionary * dictionary,\n     const ColumnPtr column,\n     PaddedPODArray<T> & backup_storage)\n {\ndiff --git a/src/Dictionaries/DictionaryStructure.cpp b/src/Dictionaries/DictionaryStructure.cpp\nindex d3ee194bf601..806ee0b80e00 100644\n--- a/src/Dictionaries/DictionaryStructure.cpp\n+++ b/src/Dictionaries/DictionaryStructure.cpp\n@@ -200,8 +200,21 @@ DictionaryStructure::DictionaryStructure(const Poco::Util::AbstractConfiguration\n \n     for (size_t i = 0; i < attributes.size(); ++i)\n     {\n-        const auto & attribute_name = attributes[i].name;\n+        const auto & attribute = attributes[i];\n+        const auto & attribute_name = attribute.name;\n         attribute_name_to_index[attribute_name] = i;\n+\n+        if (attribute.hierarchical)\n+        {\n+            if (id && attribute.underlying_type != AttributeUnderlyingType::utUInt64)\n+                throw Exception(ErrorCodes::TYPE_MISMATCH,\n+                    \"Hierarchical attribute type for dictionary with simple key must be UInt64. Actual ({})\",\n+                    toString(attribute.underlying_type));\n+            else if (key)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Dictionary with complex key does not support hierarchy\");\n+\n+            hierarchical_attribute_index = i;\n+        }\n     }\n \n     if (attributes.empty())\ndiff --git a/src/Dictionaries/DictionaryStructure.h b/src/Dictionaries/DictionaryStructure.h\nindex 2dedb1be0cee..4f03b4ff09e9 100644\n--- a/src/Dictionaries/DictionaryStructure.h\n+++ b/src/Dictionaries/DictionaryStructure.h\n@@ -153,6 +153,8 @@ struct DictionaryStructure final\n     std::unordered_map<std::string, size_t> attribute_name_to_index;\n     std::optional<DictionaryTypedSpecialAttribute> range_min;\n     std::optional<DictionaryTypedSpecialAttribute> range_max;\n+    std::optional<size_t> hierarchical_attribute_index;\n+\n     bool has_expressions = false;\n     bool access_to_key_from_attributes = false;\n \ndiff --git a/src/Dictionaries/DirectDictionary.cpp b/src/Dictionaries/DirectDictionary.cpp\nindex 4cb9e0cd629b..96ef259106ac 100644\n--- a/src/Dictionaries/DirectDictionary.cpp\n+++ b/src/Dictionaries/DirectDictionary.cpp\n@@ -1,158 +1,33 @@\n #include \"DirectDictionary.h\"\n-#include <IO/WriteHelpers.h>\n-#include \"DictionaryBlockInputStream.h\"\n-#include \"DictionaryFactory.h\"\n+\n #include <Core/Defines.h>\n-#include <Functions/FunctionHelpers.h>\n-#include <Columns/ColumnNullable.h>\n-#include <DataTypes/DataTypesDecimal.h>\n #include <Common/HashTable/HashMap.h>\n-#include <Interpreters/AggregationCommon.h>\n+#include <DataStreams/IBlockInputStream.h>\n+#include <DataTypes/DataTypesDecimal.h>\n+#include <Functions/FunctionHelpers.h>\n \n+#include <Dictionaries/DictionaryFactory.h>\n+#include <Dictionaries/HierarchyDictionariesUtils.h>\n \n namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int TYPE_MISMATCH;\n     extern const int UNSUPPORTED_METHOD;\n     extern const int BAD_ARGUMENTS;\n }\n \n-namespace\n-{\n-\n-    inline UInt64 getAt(const PaddedPODArray<UInt64> & arr, const size_t idx)\n-    {\n-        return arr[idx];\n-    }\n-\n-    inline UInt64 getAt(const UInt64 & value, const size_t)\n-    {\n-        return value;\n-    }\n-\n-}\n-\n template <DictionaryKeyType dictionary_key_type>\n DirectDictionary<dictionary_key_type>::DirectDictionary(\n     const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n-    DictionarySourcePtr source_ptr_,\n-    BlockPtr saved_block_)\n+    DictionarySourcePtr source_ptr_)\n     : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n-    , saved_block{std::move(saved_block_)}\n {\n     if (!source_ptr->supportsSelectiveLoad())\n         throw Exception{full_name + \": source cannot be used with DirectDictionary\", ErrorCodes::UNSUPPORTED_METHOD};\n-\n-    setup();\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void DirectDictionary<dictionary_key_type>::toParent(const PaddedPODArray<Key> & ids [[maybe_unused]], PaddedPODArray<Key> & out [[maybe_unused]]) const\n-{\n-    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n-    {\n-        const auto & attribute_name = hierarchical_attribute->name;\n-\n-        auto result_type = std::make_shared<DataTypeUInt64>();\n-        auto input_column = result_type->createColumn();\n-        auto & input_column_typed = assert_cast<ColumnVector<UInt64> &>(*input_column);\n-        auto & data = input_column_typed.getData();\n-        data.insert(ids.begin(), ids.end());\n-\n-        auto column = getColumn({attribute_name}, result_type, {std::move(input_column)}, {result_type}, {nullptr});\n-        const auto & result_column_typed = assert_cast<const ColumnVector<UInt64> &>(*column);\n-        const auto & result_data = result_column_typed.getData();\n-\n-        out.assign(result_data);\n-    }\n-    else\n-        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Hierarchy is not supported for complex key DirectDictionary\");\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-UInt64 DirectDictionary<dictionary_key_type>::getValueOrNullByKey(const Key & to_find) const\n-{\n-    std::vector<Key> required_key = {to_find};\n-\n-    auto stream = source_ptr->loadIds(required_key);\n-    stream->readPrefix();\n-\n-    bool is_found = false;\n-    UInt64 result = hierarchical_attribute->null_value.template get<UInt64>();\n-\n-    while (const auto block = stream->read())\n-    {\n-        const IColumn & id_column = *block.safeGetByPosition(0).column;\n-\n-        for (const size_t attribute_idx : ext::range(0, dict_struct.attributes.size()))\n-        {\n-            if (is_found)\n-                break;\n-\n-            const IColumn & attribute_column = *block.safeGetByPosition(attribute_idx + 1).column;\n-\n-            for (const auto row_idx : ext::range(0, id_column.size()))\n-            {\n-                const auto key = id_column[row_idx].get<UInt64>();\n-\n-                if (key == to_find && hierarchical_attribute->name == attribute_name_by_index.at(attribute_idx))\n-                {\n-                    result = attribute_column[row_idx].get<Key>();\n-                    is_found = true;\n-                    break;\n-                }\n-            }\n-        }\n-    }\n-\n-    stream->readSuffix();\n-\n-    return result;\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-template <typename ChildType, typename AncestorType>\n-void DirectDictionary<dictionary_key_type>::isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    const auto null_value = hierarchical_attribute->null_value.template get<UInt64>();\n-    const auto rows = out.size();\n-\n-    for (const auto row : ext::range(0, rows))\n-    {\n-        auto id = getAt(child_ids, row);\n-        const auto ancestor_id = getAt(ancestor_ids, row);\n-\n-        for (size_t i = 0; id != null_value && id != ancestor_id && i < DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH; ++i)\n-            id = getValueOrNullByKey(id);\n-\n-        out[row] = id != null_value && id == ancestor_id;\n-    }\n-\n-    query_count.fetch_add(rows, std::memory_order_relaxed);\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void DirectDictionary<dictionary_key_type>::isInVectorVector(\n-    const PaddedPODArray<UInt64> & child_ids, const PaddedPODArray<UInt64> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_ids, out);\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void DirectDictionary<dictionary_key_type>::isInVectorConstant(const PaddedPODArray<UInt64> & child_ids, const UInt64 ancestor_id, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_id, out);\n-}\n-\n-template <DictionaryKeyType dictionary_key_type>\n-void DirectDictionary<dictionary_key_type>::isInConstantVector(const UInt64 child_id, const PaddedPODArray<UInt64> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_id, ancestor_ids, out);\n }\n \n template <DictionaryKeyType dictionary_key_type>\n@@ -166,20 +41,20 @@ ColumnPtr DirectDictionary<dictionary_key_type>::getColumn(\n     if constexpr (dictionary_key_type == DictionaryKeyType::complex)\n         dict_struct.validateKeyTypes(key_types);\n \n-    Arena complex_key_arena;\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n+    const auto requested_keys = extractor.extractAllKeys();\n \n     const DictionaryAttribute & attribute = dict_struct.getAttribute(attribute_name, result_type);\n     DefaultValueProvider default_value_provider(attribute.null_value, default_values_column);\n \n-    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, complex_key_arena);\n-    const auto & requested_keys = extractor.getKeys();\n-\n     HashMap<KeyType, size_t> key_to_fetched_index;\n     key_to_fetched_index.reserve(requested_keys.size());\n \n     auto fetched_from_storage = attribute.type->createColumn();\n+\n     size_t fetched_key_index = 0;\n-    size_t requested_attribute_index = attribute_index_by_name.find(attribute_name)->second;\n+    size_t requested_attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n \n     Columns block_key_columns;\n     size_t dictionary_keys_size = dict_struct.getKeysNames().size();\n@@ -191,26 +66,19 @@ ColumnPtr DirectDictionary<dictionary_key_type>::getColumn(\n \n     while (const auto block = stream->read())\n     {\n-        auto block_columns = block.getColumns();\n-\n         /// Split into keys columns and attribute columns\n         for (size_t i = 0; i < dictionary_keys_size; ++i)\n-        {\n-            block_key_columns.emplace_back(*block_columns.begin());\n-            block_columns.erase(block_columns.begin());\n-        }\n+            block_key_columns.emplace_back(block.safeGetByPosition(i).column);\n \n-        DictionaryKeysExtractor<dictionary_key_type> block_keys_extractor(block_key_columns, complex_key_arena);\n-        const auto & block_keys = block_keys_extractor.getKeys();\n-        size_t block_keys_size = block_keys.size();\n+        DictionaryKeysExtractor<dictionary_key_type> block_keys_extractor(block_key_columns, arena_holder.getComplexKeyArena());\n+        auto block_keys = block_keys_extractor.extractAllKeys();\n \n         const auto & block_column = block.safeGetByPosition(dictionary_keys_size + requested_attribute_index).column;\n-        fetched_from_storage->insertRangeFrom(*block_column, 0, block_keys_size);\n+        fetched_from_storage->insertRangeFrom(*block_column, 0, block_keys.size());\n \n-        for (size_t block_key_index = 0; block_key_index < block_keys_size; ++block_key_index)\n+        for (size_t block_key_index = 0; block_key_index < block_keys.size(); ++block_key_index)\n         {\n-            const auto & block_key = block_keys[block_key_index];\n-\n+            auto block_key = block_keys[block_key_index];\n             key_to_fetched_index[block_key] = fetched_key_index;\n             ++fetched_key_index;\n         }\n@@ -223,10 +91,10 @@ ColumnPtr DirectDictionary<dictionary_key_type>::getColumn(\n     Field value_to_insert;\n \n     size_t requested_keys_size = requested_keys.size();\n+\n     auto result = fetched_from_storage->cloneEmpty();\n     result->reserve(requested_keys_size);\n \n-\n     for (size_t requested_key_index = 0; requested_key_index < requested_keys_size; ++requested_key_index)\n     {\n         const auto requested_key = requested_keys[requested_key_index];\n@@ -251,10 +119,9 @@ ColumnUInt8::Ptr DirectDictionary<dictionary_key_type>::hasKeys(const Columns &\n     if constexpr (dictionary_key_type == DictionaryKeyType::complex)\n         dict_struct.validateKeyTypes(key_types);\n \n-    Arena complex_key_arena;\n-\n-    DictionaryKeysExtractor<dictionary_key_type> requested_keys_extractor(key_columns, complex_key_arena);\n-    const auto & requested_keys = requested_keys_extractor.getKeys();\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> requested_keys_extractor(key_columns, arena_holder.getComplexKeyArena());\n+    auto requested_keys = requested_keys_extractor.extractAllKeys();\n     size_t requested_keys_size = requested_keys.size();\n \n     HashMap<KeyType, size_t> requested_key_to_index;\n@@ -279,25 +146,24 @@ ColumnUInt8::Ptr DirectDictionary<dictionary_key_type>::hasKeys(const Columns &\n \n     while (const auto block = stream->read())\n     {\n-        auto block_columns = block.getColumns();\n-\n         /// Split into keys columns and attribute columns\n         for (size_t i = 0; i < dictionary_keys_size; ++i)\n-        {\n-            block_key_columns.emplace_back(*block_columns.begin());\n-            block_columns.erase(block_columns.begin());\n-        }\n+            block_key_columns.emplace_back(block.safeGetByPosition(i).column);\n \n-        DictionaryKeysExtractor<dictionary_key_type> block_keys_extractor(block_key_columns, complex_key_arena);\n-        const auto & block_keys = block_keys_extractor.getKeys();\n+        DictionaryKeysExtractor<dictionary_key_type> block_keys_extractor(block_key_columns, arena_holder.getComplexKeyArena());\n+        size_t block_keys_size = block_keys_extractor.getKeysSize();\n \n-        for (const auto & block_key : block_keys)\n+        for (size_t i = 0; i < block_keys_size; ++i)\n         {\n+            auto block_key = block_keys_extractor.extractCurrentKey();\n+\n             const auto * it = requested_key_to_index.find(block_key);\n             assert(it);\n \n             size_t result_data_found_index = it->getMapped();\n             result_data[result_data_found_index] = true;\n+\n+            block_keys_extractor.rollbackCurrentKey();\n         }\n \n         block_key_columns.clear();\n@@ -310,6 +176,37 @@ ColumnUInt8::Ptr DirectDictionary<dictionary_key_type>::hasKeys(const Columns &\n     return result;\n }\n \n+template <DictionaryKeyType dictionary_key_type>\n+ColumnPtr DirectDictionary<dictionary_key_type>::getHierarchy(\n+    ColumnPtr key_column,\n+    const DataTypePtr & key_type) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::simple)\n+    {\n+        auto result = getKeysHierarchyDefaultImplementation(this, key_column, key_type);\n+        query_count.fetch_add(key_column->size(), std::memory_order_relaxed);\n+        return result;\n+    }\n+    else\n+        return nullptr;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type>\n+ColumnUInt8::Ptr DirectDictionary<dictionary_key_type>::isInHierarchy(\n+    ColumnPtr key_column,\n+    ColumnPtr in_key_column,\n+    const DataTypePtr & key_type) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::simple)\n+    {\n+        auto result = getKeysIsInHierarchyDefaultImplementation(this, key_column, in_key_column, key_type);\n+        query_count.fetch_add(key_column->size(), std::memory_order_relaxed);\n+        return result;\n+    }\n+    else\n+        return nullptr;\n+}\n+\n template <DictionaryKeyType dictionary_key_type>\n BlockInputStreamPtr DirectDictionary<dictionary_key_type>::getSourceBlockInputStream(\n     const Columns & key_columns [[maybe_unused]],\n@@ -342,32 +239,6 @@ BlockInputStreamPtr DirectDictionary<dictionary_key_type>::getSourceBlockInputSt\n     return stream;\n }\n \n-template <DictionaryKeyType dictionary_key_type>\n-void DirectDictionary<dictionary_key_type>::setup()\n-{\n-    /// TODO: Move this to DictionaryStructure\n-    size_t dictionary_attributes_size = dict_struct.attributes.size();\n-    for (size_t i = 0; i < dictionary_attributes_size; ++i)\n-    {\n-        const auto & attribute = dict_struct.attributes[i];\n-        attribute_index_by_name[attribute.name] = i;\n-        attribute_name_by_index[i] = attribute.name;\n-\n-        if (attribute.hierarchical)\n-        {\n-            if constexpr (dictionary_key_type == DictionaryKeyType::complex)\n-                throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                    \"({}): hierarchical attributes are not supported for complex key direct dictionary\",\n-                    full_name);\n-\n-            hierarchical_attribute = &attribute;\n-\n-            if (attribute.underlying_type != AttributeUnderlyingType::utUInt64)\n-                throw Exception{full_name + \": hierarchical attribute must be UInt64.\", ErrorCodes::TYPE_MISMATCH};\n-        }\n-    }\n-}\n-\n template <DictionaryKeyType dictionary_key_type>\n BlockInputStreamPtr DirectDictionary<dictionary_key_type>::getBlockInputStream(const Names & /* column_names */, size_t /* max_block_size */) const\n {\ndiff --git a/src/Dictionaries/DirectDictionary.h b/src/Dictionaries/DirectDictionary.h\nindex 685fd707dedb..6bca6ac6a187 100644\n--- a/src/Dictionaries/DirectDictionary.h\n+++ b/src/Dictionaries/DirectDictionary.h\n@@ -18,11 +18,6 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int BAD_ARGUMENTS;\n-}\n-\n template <DictionaryKeyType dictionary_key_type>\n class DirectDictionary final : public IDictionary\n {\n@@ -33,8 +28,7 @@ class DirectDictionary final : public IDictionary\n     DirectDictionary(\n         const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n-        DictionarySourcePtr source_ptr_,\n-        BlockPtr saved_block_ = nullptr);\n+        DictionarySourcePtr source_ptr_);\n \n     std::string getTypeName() const override\n     {\n@@ -56,7 +50,7 @@ class DirectDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<DirectDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), saved_block);\n+        return std::make_shared<DirectDictionary>(getDictionaryID(), dict_struct, source_ptr->clone());\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -67,26 +61,9 @@ class DirectDictionary final : public IDictionary\n \n     bool isInjective(const std::string & attribute_name) const override\n     {\n-        auto it = attribute_index_by_name.find(attribute_name);\n-\n-        if (it == attribute_index_by_name.end())\n-            throw Exception(ErrorCodes::BAD_ARGUMENTS,\n-                \"({}): no attribute with name ({}) in dictionary\",\n-                full_name,\n-                attribute_name);\n-\n-        return dict_struct.attributes[it->second].injective;\n+        return dict_struct.getAttribute(attribute_name).injective;\n     }\n \n-    bool hasHierarchy() const override { return hierarchical_attribute; }\n-\n-    void toParent(const PaddedPODArray<UInt64> & ids, PaddedPODArray<UInt64> & out) const override;\n-\n-    void isInVectorVector(\n-        const PaddedPODArray<UInt64> & child_ids, const PaddedPODArray<UInt64> & ancestor_ids, PaddedPODArray<UInt8> & out) const override;\n-    void isInVectorConstant(const PaddedPODArray<UInt64> & child_ids, const UInt64 ancestor_id, PaddedPODArray<UInt8> & out) const override;\n-    void isInConstantVector(const UInt64 child_id, const PaddedPODArray<UInt64> & ancestor_ids, PaddedPODArray<UInt8> & out) const override;\n-\n     DictionaryKeyType getKeyType() const override { return dictionary_key_type; }\n \n     ColumnPtr getColumn(\n@@ -98,30 +75,25 @@ class DirectDictionary final : public IDictionary\n \n     ColumnUInt8::Ptr hasKeys(const Columns & key_columns, const DataTypes & key_types) const override;\n \n-    BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;\n+    bool hasHierarchy() const override { return dict_struct.hierarchical_attribute_index.has_value(); }\n \n-private:\n-    void setup();\n+    ColumnPtr getHierarchy(ColumnPtr key_column, const DataTypePtr & key_type) const override;\n \n-    BlockInputStreamPtr getSourceBlockInputStream(const Columns & key_columns, const PaddedPODArray<KeyType> & requested_keys) const;\n+    ColumnUInt8::Ptr isInHierarchy(\n+        ColumnPtr key_column,\n+        ColumnPtr in_key_column,\n+        const DataTypePtr & key_type) const override;\n \n-    UInt64 getValueOrNullByKey(const UInt64 & to_find) const;\n+    BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;\n \n-    template <typename ChildType, typename AncestorType>\n-    void isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n+private:\n+    BlockInputStreamPtr getSourceBlockInputStream(const Columns & key_columns, const PaddedPODArray<KeyType> & requested_keys) const;\n \n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\n \n-    std::unordered_map<std::string, size_t> attribute_index_by_name;\n-    std::unordered_map<size_t, std::string> attribute_name_by_index;\n-\n-    const DictionaryAttribute * hierarchical_attribute = nullptr;\n-\n     mutable std::atomic<size_t> query_count{0};\n-\n-    BlockPtr saved_block;\n };\n \n extern template class DirectDictionary<DictionaryKeyType::simple>;\ndiff --git a/src/Dictionaries/FlatDictionary.cpp b/src/Dictionaries/FlatDictionary.cpp\nindex eb63d7169131..2d8d208d76bc 100644\n--- a/src/Dictionaries/FlatDictionary.cpp\n+++ b/src/Dictionaries/FlatDictionary.cpp\n@@ -1,20 +1,22 @@\n #include \"FlatDictionary.h\"\n \n #include <Core/Defines.h>\n+#include <Common/HashTable/HashMap.h>\n+\n #include <DataTypes/DataTypesDecimal.h>\n #include <IO/WriteHelpers.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnNullable.h>\n #include <Functions/FunctionHelpers.h>\n \n-#include \"DictionaryBlockInputStream.h\"\n-#include \"DictionaryFactory.h\"\n+#include <Dictionaries/DictionaryBlockInputStream.h>\n+#include <Dictionaries/DictionaryFactory.h>\n+#include <Dictionaries/HierarchyDictionariesUtils.h>\n \n namespace DB\n {\n namespace ErrorCodes\n {\n-    extern const int TYPE_MISMATCH;\n     extern const int ARGUMENT_OUT_OF_BOUND;\n     extern const int BAD_ARGUMENTS;\n     extern const int DICTIONARY_IS_EMPTY;\n@@ -24,7 +26,6 @@ namespace ErrorCodes\n static const auto initial_array_size = 1024;\n static const auto max_array_size = 500000;\n \n-\n FlatDictionary::FlatDictionary(\n     const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n@@ -45,69 +46,6 @@ FlatDictionary::FlatDictionary(\n     calculateBytesAllocated();\n }\n \n-\n-void FlatDictionary::toParent(const PaddedPODArray<Key> & ids, PaddedPODArray<Key> & out) const\n-{\n-    const auto null_value = std::get<UInt64>(hierarchical_attribute->null_values);\n-    DictionaryDefaultValueExtractor<UInt64> extractor(null_value);\n-\n-    getItemsImpl<UInt64, UInt64>(\n-        *hierarchical_attribute,\n-        ids,\n-        [&](const size_t row, const UInt64 value) { out[row] = value; },\n-        extractor);\n-}\n-\n-\n-/// Allow to use single value in same way as array.\n-static inline FlatDictionary::Key getAt(const PaddedPODArray<FlatDictionary::Key> & arr, const size_t idx)\n-{\n-    return arr[idx];\n-}\n-static inline FlatDictionary::Key getAt(const FlatDictionary::Key & value, const size_t)\n-{\n-    return value;\n-}\n-\n-template <typename ChildType, typename AncestorType>\n-void FlatDictionary::isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    const auto null_value = std::get<UInt64>(hierarchical_attribute->null_values);\n-    const auto & attr = std::get<ContainerType<Key>>(hierarchical_attribute->arrays);\n-    const auto rows = out.size();\n-\n-    size_t loaded_size = attr.size();\n-    for (const auto row : ext::range(0, rows))\n-    {\n-        auto id = getAt(child_ids, row);\n-        const auto ancestor_id = getAt(ancestor_ids, row);\n-\n-        for (size_t i = 0; id < loaded_size && id != null_value && id != ancestor_id && i < DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH; ++i)\n-            id = attr[id];\n-\n-        out[row] = id != null_value && id == ancestor_id;\n-    }\n-\n-    query_count.fetch_add(rows, std::memory_order_relaxed);\n-}\n-\n-\n-void FlatDictionary::isInVectorVector(\n-    const PaddedPODArray<Key> & child_ids, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_ids, out);\n-}\n-\n-void FlatDictionary::isInVectorConstant(const PaddedPODArray<Key> & child_ids, const Key ancestor_id, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_id, out);\n-}\n-\n-void FlatDictionary::isInConstantVector(const Key child_id, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_id, ancestor_ids, out);\n-}\n-\n ColumnPtr FlatDictionary::getColumn(\n         const std::string & attribute_name,\n         const DataTypePtr & result_type,\n@@ -117,14 +55,16 @@ ColumnPtr FlatDictionary::getColumn(\n {\n     ColumnPtr result;\n \n-    PaddedPODArray<Key> backup_storage;\n+    PaddedPODArray<UInt64> backup_storage;\n     const auto & ids = getColumnVectorData(this, key_columns.front(), backup_storage);\n \n     auto size = ids.size();\n \n-    const auto & attribute = getAttribute(attribute_name);\n     const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n \n+    size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n+    const auto & attribute = attributes[attribute_index];\n+\n     auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n@@ -183,10 +123,9 @@ ColumnPtr FlatDictionary::getColumn(\n     return result;\n }\n \n-\n ColumnUInt8::Ptr FlatDictionary::hasKeys(const Columns & key_columns, const DataTypes &) const\n {\n-    PaddedPODArray<Key> backup_storage;\n+    PaddedPODArray<UInt64> backup_storage;\n     const auto& ids = getColumnVectorData(this, key_columns.front(), backup_storage);\n \n     auto result = ColumnUInt8::create(ext::size(ids));\n@@ -205,24 +144,118 @@ ColumnUInt8::Ptr FlatDictionary::hasKeys(const Columns & key_columns, const Data\n     return result;\n }\n \n+ColumnPtr FlatDictionary::getHierarchy(ColumnPtr key_column, const DataTypePtr &) const\n+{\n+    PaddedPODArray<UInt64> keys_backup_storage;\n+    const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n+\n+    size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+    const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+\n+    const UInt64 null_value = std::get<UInt64>(hierarchical_attribute.null_values);\n+    const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.arrays);\n+\n+    auto is_key_valid_func = [&, this](auto & key)\n+    {\n+        return key < loaded_ids.size() && loaded_ids[key];\n+    };\n+\n+    auto get_parent_key_func = [&, this](auto & hierarchy_key)\n+    {\n+        std::optional<UInt64> result;\n+\n+        if (hierarchy_key >= loaded_ids.size() || !loaded_ids[hierarchy_key])\n+            return result;\n+\n+        result = parent_keys[hierarchy_key];\n+\n+        return result;\n+    };\n+\n+    auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, null_value, is_key_valid_func, get_parent_key_func);\n+\n+    query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+\n+    return dictionary_hierarchy_array;\n+}\n+\n+ColumnUInt8::Ptr FlatDictionary::isInHierarchy(\n+    ColumnPtr key_column,\n+    ColumnPtr in_key_column,\n+    const DataTypePtr &) const\n+{\n+    PaddedPODArray<UInt64> keys_backup_storage;\n+    const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n+\n+    PaddedPODArray<UInt64> keys_in_backup_storage;\n+    const auto & keys_in = getColumnVectorData(this, in_key_column, keys_in_backup_storage);\n+\n+    size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+    const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+\n+    const UInt64 null_value = std::get<UInt64>(hierarchical_attribute.null_values);\n+    const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.arrays);\n+\n+    auto is_key_valid_func = [&, this](auto & key)\n+    {\n+        return key < loaded_ids.size() && loaded_ids[key];\n+    };\n+\n+    auto get_parent_key_func = [&, this](auto & hierarchy_key)\n+    {\n+        std::optional<UInt64> result;\n+\n+        if (hierarchy_key >= loaded_ids.size() || !loaded_ids[hierarchy_key])\n+            return result;\n+\n+        result = parent_keys[hierarchy_key];\n+\n+        return result;\n+    };\n+\n+    auto result = getKeysIsInHierarchyColumn(keys, keys_in, null_value, is_key_valid_func, get_parent_key_func);\n+\n+    query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+\n+    return result;\n+}\n+\n+ColumnPtr FlatDictionary::getDescendants(\n+    ColumnPtr key_column,\n+    const DataTypePtr &,\n+    size_t level) const\n+{\n+    PaddedPODArray<UInt64> keys_backup;\n+    const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+\n+    size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+    const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+    const ContainerType<UInt64> & parent_keys = std::get<ContainerType<UInt64>>(hierarchical_attribute.arrays);\n+\n+    HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+\n+    for (size_t i = 0; i < parent_keys.size(); ++i)\n+    {\n+        auto parent_key = parent_keys[i];\n+\n+        if (loaded_ids[i])\n+            parent_to_child[parent_key].emplace_back(static_cast<UInt64>(i));\n+    }\n+\n+    auto result = getKeysDescendantsArray(keys, parent_to_child, level);\n+\n+    query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+\n+    return result;\n+}\n+\n void FlatDictionary::createAttributes()\n {\n     const auto size = dict_struct.attributes.size();\n     attributes.reserve(size);\n \n     for (const auto & attribute : dict_struct.attributes)\n-    {\n-        attribute_index_by_name.emplace(attribute.name, attributes.size());\n         attributes.push_back(createAttribute(attribute, attribute.null_value));\n-\n-        if (attribute.hierarchical)\n-        {\n-            hierarchical_attribute = &attributes.back();\n-\n-            if (hierarchical_attribute->type != AttributeUnderlyingType::utUInt64)\n-                throw Exception{full_name + \": hierarchical attribute must be UInt64.\", ErrorCodes::TYPE_MISMATCH};\n-        }\n-    }\n }\n \n void FlatDictionary::blockToAttributes(const Block & block)\n@@ -271,7 +304,7 @@ void FlatDictionary::updateData()\n             const auto & saved_id_column = *saved_block->safeGetByPosition(0).column;\n             const auto & update_id_column = *block.safeGetByPosition(0).column;\n \n-            std::unordered_map<Key, std::vector<size_t>> update_ids;\n+            std::unordered_map<UInt64, std::vector<size_t>> update_ids;\n             for (size_t row = 0; row < update_id_column.size(); ++row)\n             {\n                 const auto id = update_id_column.get64(row);\n@@ -280,7 +313,7 @@ void FlatDictionary::updateData()\n \n             const size_t saved_rows = saved_id_column.size();\n             IColumn::Filter filter(saved_rows);\n-            std::unordered_map<Key, std::vector<size_t>>::iterator it;\n+            std::unordered_map<UInt64, std::vector<size_t>>::iterator it;\n \n             for (size_t row = 0; row < saved_id_column.size(); ++row)\n             {\n@@ -385,7 +418,6 @@ void FlatDictionary::createAttributeImpl<String>(Attribute & attribute, const Fi\n     attribute.arrays.emplace<ContainerType<StringRef>>(initial_array_size, StringRef(string_in_arena, string.size()));\n }\n \n-\n FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttribute& attribute, const Field & null_value)\n {\n     auto nullable_set = attribute.is_nullable ? std::make_optional<NullableSet>() : std::optional<NullableSet>{};\n@@ -408,7 +440,7 @@ FlatDictionary::Attribute FlatDictionary::createAttribute(const DictionaryAttrib\n template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n void FlatDictionary::getItemsImpl(\n     const Attribute & attribute,\n-    const PaddedPODArray<Key> & ids,\n+    const PaddedPODArray<UInt64> & ids,\n     ValueSetter && set_value,\n     DefaultValueExtractor & default_value_extractor) const\n {\n@@ -425,7 +457,7 @@ void FlatDictionary::getItemsImpl(\n }\n \n template <typename T>\n-void FlatDictionary::resize(Attribute & attribute, const Key id)\n+void FlatDictionary::resize(Attribute & attribute, const UInt64 id)\n {\n     if (id >= max_array_size)\n         throw Exception{full_name + \": identifier should be less than \" + toString(max_array_size), ErrorCodes::ARGUMENT_OUT_OF_BOUND};\n@@ -440,7 +472,7 @@ void FlatDictionary::resize(Attribute & attribute, const Key id)\n }\n \n template <typename T>\n-void FlatDictionary::setAttributeValueImpl(Attribute & attribute, const Key id, const T & value)\n+void FlatDictionary::setAttributeValueImpl(Attribute & attribute, const UInt64 id, const T & value)\n {\n     auto & array = std::get<ContainerType<T>>(attribute.arrays);\n     array[id] = value;\n@@ -448,13 +480,13 @@ void FlatDictionary::setAttributeValueImpl(Attribute & attribute, const Key id,\n }\n \n template <>\n-void FlatDictionary::setAttributeValueImpl<String>(Attribute & attribute, const Key id, const String & value)\n+void FlatDictionary::setAttributeValueImpl<String>(Attribute & attribute, const UInt64 id, const String & value)\n {\n     const auto * string_in_arena = attribute.string_arena->insert(value.data(), value.size());\n     setAttributeValueImpl(attribute, id, StringRef{string_in_arena, value.size()});\n }\n \n-void FlatDictionary::setAttributeValue(Attribute & attribute, const Key id, const Field & value)\n+void FlatDictionary::setAttributeValue(Attribute & attribute, const UInt64 id, const Field & value)\n {\n     auto type_call = [&](const auto &dictionary_attribute_type)\n     {\n@@ -484,21 +516,11 @@ void FlatDictionary::setAttributeValue(Attribute & attribute, const Key id, cons\n     callOnDictionaryAttributeType(attribute.type, type_call);\n }\n \n-\n-const FlatDictionary::Attribute & FlatDictionary::getAttribute(const std::string & attribute_name) const\n-{\n-    const auto it = attribute_index_by_name.find(attribute_name);\n-    if (it == std::end(attribute_index_by_name))\n-        throw Exception{full_name + \": no such attribute '\" + attribute_name + \"'\", ErrorCodes::BAD_ARGUMENTS};\n-\n-    return attributes[it->second];\n-}\n-\n-PaddedPODArray<FlatDictionary::Key> FlatDictionary::getIds() const\n+PaddedPODArray<UInt64> FlatDictionary::getIds() const\n {\n     const auto ids_count = ext::size(loaded_ids);\n \n-    PaddedPODArray<Key> ids;\n+    PaddedPODArray<UInt64> ids;\n     ids.reserve(ids_count);\n \n     for (auto idx : ext::range(0, ids_count))\n@@ -509,8 +531,7 @@ PaddedPODArray<FlatDictionary::Key> FlatDictionary::getIds() const\n \n BlockInputStreamPtr FlatDictionary::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n {\n-    using BlockInputStreamType = DictionaryBlockInputStream<Key>;\n-    return std::make_shared<BlockInputStreamType>(shared_from_this(), max_block_size, getIds(), column_names);\n+    return std::make_shared<DictionaryBlockInputStream>(shared_from_this(), max_block_size, getIds(), column_names);\n }\n \n void registerDictionaryFlat(DictionaryFactory & factory)\ndiff --git a/src/Dictionaries/FlatDictionary.h b/src/Dictionaries/FlatDictionary.h\nindex f491eb286417..09721bf1a992 100644\n--- a/src/Dictionaries/FlatDictionary.h\n+++ b/src/Dictionaries/FlatDictionary.h\n@@ -59,18 +59,9 @@ class FlatDictionary final : public IDictionary\n \n     bool isInjective(const std::string & attribute_name) const override\n     {\n-        return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;\n+        return dict_struct.getAttribute(attribute_name).injective;\n     }\n \n-    bool hasHierarchy() const override { return hierarchical_attribute; }\n-\n-    void toParent(const PaddedPODArray<Key> & ids, PaddedPODArray<Key> & out) const override;\n-\n-    void isInVectorVector(\n-        const PaddedPODArray<Key> & child_ids, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const override;\n-    void isInVectorConstant(const PaddedPODArray<Key> & child_ids, const Key ancestor_id, PaddedPODArray<UInt8> & out) const override;\n-    void isInConstantVector(const Key child_id, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const override;\n-\n     DictionaryKeyType getKeyType() const override { return DictionaryKeyType::simple; }\n \n     ColumnPtr getColumn(\n@@ -82,13 +73,27 @@ class FlatDictionary final : public IDictionary\n \n     ColumnUInt8::Ptr hasKeys(const Columns & key_columns, const DataTypes & key_types) const override;\n \n+    bool hasHierarchy() const override { return dict_struct.hierarchical_attribute_index.has_value(); }\n+\n+    ColumnPtr getHierarchy(ColumnPtr key_column, const DataTypePtr & key_type) const override;\n+\n+    ColumnUInt8::Ptr isInHierarchy(\n+        ColumnPtr key_column,\n+        ColumnPtr in_key_column,\n+        const DataTypePtr & key_type) const override;\n+\n+    ColumnPtr getDescendants(\n+        ColumnPtr key_column,\n+        const DataTypePtr & key_type,\n+        size_t level) const override;\n+\n     BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;\n \n private:\n     template <typename Value>\n     using ContainerType = PaddedPODArray<Value>;\n \n-    using NullableSet = HashSet<Key, DefaultHash<Key>>;\n+    using NullableSet = HashSet<UInt64, DefaultHash<UInt64>>;\n \n     struct Attribute final\n     {\n@@ -151,24 +156,24 @@ class FlatDictionary final : public IDictionary\n     template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n-        const PaddedPODArray<Key> & ids,\n+        const PaddedPODArray<UInt64> & ids,\n         ValueSetter && set_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n     template <typename T>\n-    void resize(Attribute & attribute, const Key id);\n+    void resize(Attribute & attribute, const UInt64 id);\n \n     template <typename T>\n-    void setAttributeValueImpl(Attribute & attribute, const Key id, const T & value);\n+    void setAttributeValueImpl(Attribute & attribute, const UInt64 id, const T & value);\n \n-    void setAttributeValue(Attribute & attribute, const Key id, const Field & value);\n+    void setAttributeValue(Attribute & attribute, const UInt64 id, const Field & value);\n \n     const Attribute & getAttribute(const std::string & attribute_name) const;\n \n     template <typename ChildType, typename AncestorType>\n     void isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n \n-    PaddedPODArray<Key> getIds() const;\n+    PaddedPODArray<UInt64> getIds() const;\n \n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n@@ -177,7 +182,6 @@ class FlatDictionary final : public IDictionary\n \n     std::map<std::string, size_t> attribute_index_by_name;\n     std::vector<Attribute> attributes;\n-    const Attribute * hierarchical_attribute = nullptr;\n     std::vector<bool> loaded_ids;\n \n     size_t bytes_allocated = 0;\n@@ -185,6 +189,7 @@ class FlatDictionary final : public IDictionary\n     size_t bucket_count = 0;\n     mutable std::atomic<size_t> query_count{0};\n \n+    /// TODO: Remove\n     BlockPtr saved_block;\n };\n \ndiff --git a/src/Dictionaries/HashedDictionary.cpp b/src/Dictionaries/HashedDictionary.cpp\nindex 708be7945f15..d45e4ade1cfc 100644\n--- a/src/Dictionaries/HashedDictionary.cpp\n+++ b/src/Dictionaries/HashedDictionary.cpp\n@@ -1,13 +1,18 @@\n #include \"HashedDictionary.h\"\n+\n #include <ext/size.h>\n-#include \"DictionaryBlockInputStream.h\"\n-#include \"DictionaryFactory.h\"\n-#include \"ClickHouseDictionarySource.h\"\n+\n+#include <absl/container/flat_hash_map.h>\n+\n #include <Core/Defines.h>\n-#include <Functions/FunctionHelpers.h>\n+#include <DataTypes/DataTypesDecimal.h>\n #include <Columns/ColumnsNumber.h>\n #include <Columns/ColumnNullable.h>\n-#include <DataTypes/DataTypesDecimal.h>\n+#include <Functions/FunctionHelpers.h>\n+\n+#include <Dictionaries/DictionaryBlockInputStream.h>\n+#include <Dictionaries/DictionaryFactory.h>\n+#include <Dictionaries/HierarchyDictionariesUtils.h>\n \n namespace\n {\n@@ -15,136 +20,74 @@ namespace\n /// NOTE: Trailing return type is explicitly specified for SFINAE.\n \n /// google::sparse_hash_map\n-template <typename T> auto first(const T & value) -> decltype(value.first) { return value.first; } // NOLINT\n-template <typename T> auto second(const T & value) -> decltype(value.second) { return value.second; } // NOLINT\n+template <typename T> auto getKeyFromCell(const T & value) -> decltype(value->first) { return value->first; } // NOLINT\n+template <typename T> auto getValueFromCell(const T & value) -> decltype(value->second) { return value->second; } // NOLINT\n \n /// HashMap\n-template <typename T> auto first(const T & value) -> decltype(value.getKey()) { return value.getKey(); } // NOLINT\n-template <typename T> auto second(const T & value) -> decltype(value.getMapped()) { return value.getMapped(); } // NOLINT\n+template <typename T> auto getKeyFromCell(const T & value) -> decltype(value->getKey()) { return value->getKey(); } // NOLINT\n+template <typename T> auto getValueFromCell(const T & value) -> decltype(value->getMapped()) { return value->getMapped(); } // NOLINT\n \n }\n \n namespace DB\n {\n+\n namespace ErrorCodes\n {\n-    extern const int TYPE_MISMATCH;\n     extern const int BAD_ARGUMENTS;\n     extern const int DICTIONARY_IS_EMPTY;\n     extern const int UNSUPPORTED_METHOD;\n }\n \n-\n-HashedDictionary::HashedDictionary(\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+HashedDictionary<dictionary_key_type, sparse>::HashedDictionary(\n     const StorageID & dict_id_,\n     const DictionaryStructure & dict_struct_,\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_,\n-    bool sparse_,\n     BlockPtr saved_block_)\n     : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n-    , source_ptr{std::move(source_ptr_)}\n+    , source_ptr(std::move(source_ptr_))\n     , dict_lifetime(dict_lifetime_)\n     , require_nonempty(require_nonempty_)\n-    , sparse(sparse_)\n-    , saved_block{std::move(saved_block_)}\n+    , saved_block(std::move(saved_block_))\n {\n     createAttributes();\n     loadData();\n     calculateBytesAllocated();\n }\n \n-\n-void HashedDictionary::toParent(const PaddedPODArray<Key> & ids, PaddedPODArray<Key> & out) const\n-{\n-    const auto null_value = std::get<UInt64>(hierarchical_attribute->null_values);\n-    DictionaryDefaultValueExtractor<UInt64> extractor(null_value);\n-\n-    getItemsImpl<UInt64, UInt64>(\n-        *hierarchical_attribute,\n-        ids,\n-        [&](const size_t row, const UInt64 value) { out[row] = value; },\n-        extractor);\n-}\n-\n-\n-/// Allow to use single value in same way as array.\n-static inline HashedDictionary::Key getAt(const PaddedPODArray<HashedDictionary::Key> & arr, const size_t idx)\n-{\n-    return arr[idx];\n-}\n-static inline HashedDictionary::Key getAt(const HashedDictionary::Key & value, const size_t)\n-{\n-    return value;\n-}\n-\n-template <typename AttrType, typename ChildType, typename AncestorType>\n-void HashedDictionary::isInAttrImpl(const AttrType & attr, const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    const auto null_value = std::get<UInt64>(hierarchical_attribute->null_values);\n-    const auto rows = out.size();\n-\n-    for (const auto row : ext::range(0, rows))\n-    {\n-        auto id = getAt(child_ids, row);\n-        const auto ancestor_id = getAt(ancestor_ids, row);\n-\n-        for (size_t i = 0; id != null_value && id != ancestor_id && i < DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH; ++i)\n-        {\n-            auto it = attr.find(id);\n-            if (it != std::end(attr))\n-                id = second(*it);\n-            else\n-                break;\n-        }\n-\n-        out[row] = id != null_value && id == ancestor_id;\n-    }\n-\n-    query_count.fetch_add(rows, std::memory_order_relaxed);\n-}\n-template <typename ChildType, typename AncestorType>\n-void HashedDictionary::isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    if (!sparse)\n-        return isInAttrImpl(*std::get<CollectionPtrType<Key>>(hierarchical_attribute->maps), child_ids, ancestor_ids, out);\n-    return isInAttrImpl(*std::get<SparseCollectionPtrType<Key>>(hierarchical_attribute->sparse_maps), child_ids, ancestor_ids, out);\n-}\n-\n-void HashedDictionary::isInVectorVector(\n-    const PaddedPODArray<Key> & child_ids, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_ids, out);\n-}\n-\n-void HashedDictionary::isInVectorConstant(const PaddedPODArray<Key> & child_ids, const Key ancestor_id, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_ids, ancestor_id, out);\n-}\n-\n-void HashedDictionary::isInConstantVector(const Key child_id, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const\n-{\n-    isInImpl(child_id, ancestor_ids, out);\n-}\n-\n-ColumnPtr HashedDictionary::getColumn(\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getColumn(\n     const std::string & attribute_name,\n     const DataTypePtr & result_type,\n     const Columns & key_columns,\n-    const DataTypes &,\n+    const DataTypes & key_types [[maybe_unused]],\n     const ColumnPtr & default_values_column) const\n {\n+    if (dictionary_key_type == DictionaryKeyType::complex)\n+        dict_struct.validateKeyTypes(key_types);\n+\n     ColumnPtr result;\n \n-    PaddedPODArray<Key> backup_storage;\n-    const auto & ids = getColumnVectorData(this, key_columns.front(), backup_storage);\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n \n-    auto size = ids.size();\n+    const size_t size = extractor.getKeysSize();\n \n-    const auto & attribute = getAttribute(attribute_name);\n     const auto & dictionary_attribute = dict_struct.getAttribute(attribute_name, result_type);\n+    const size_t attribute_index = dict_struct.attribute_name_to_index.find(attribute_name)->second;\n+    auto & attribute = attributes[attribute_index];\n+\n+    ColumnUInt8::MutablePtr col_null_map_to;\n+    ColumnUInt8::Container * vec_null_map_to = nullptr;\n+    if (attribute.is_nullable_set)\n+    {\n+        col_null_map_to = ColumnUInt8::create(size, false);\n+        vec_null_map_to = &col_null_map_to->getData();\n+    }\n \n     auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n@@ -159,24 +102,34 @@ ColumnPtr HashedDictionary::getColumn(\n \n         auto column = ColumnProvider::getColumn(dictionary_attribute, size);\n \n-        if constexpr (std::is_same_v<AttributeType, String>)\n+        if constexpr (std::is_same_v<ValueType, StringRef>)\n         {\n             auto * out = column.get();\n \n-            getItemsImpl<StringRef, StringRef>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n-                ids,\n+                extractor,\n                 [&](const size_t, const StringRef value) { out->insertData(value.data, value.size); },\n+                [&](const size_t row)\n+                {\n+                    out->insertDefault();\n+                    (*vec_null_map_to)[row] = true;\n+                },\n                 default_value_extractor);\n         }\n         else\n         {\n             auto & out = column->getData();\n \n-            getItemsImpl<AttributeType, AttributeType>(\n+            getItemsImpl<ValueType>(\n                 attribute,\n-                ids,\n+                extractor,\n                 [&](const size_t row, const auto value) { return out[row] = value; },\n+                [&](const size_t row)\n+                {\n+                    out[row] = 0;\n+                    (*vec_null_map_to)[row] = true;\n+                },\n                 default_value_extractor);\n         }\n \n@@ -185,87 +138,214 @@ ColumnPtr HashedDictionary::getColumn(\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n \n-    if (attribute.nullable_set)\n+    if (attribute.is_nullable_set)\n+        result = ColumnNullable::create(result, std::move(col_null_map_to));\n+\n+    return result;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+ColumnUInt8::Ptr HashedDictionary<dictionary_key_type, sparse>::hasKeys(const Columns & key_columns, const DataTypes & key_types) const\n+{\n+    if (dictionary_key_type == DictionaryKeyType::complex)\n+        dict_struct.validateKeyTypes(key_types);\n+\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> extractor(key_columns, arena_holder.getComplexKeyArena());\n+\n+    size_t keys_size = extractor.getKeysSize();\n+\n+    auto result = ColumnUInt8::create(keys_size, false);\n+    auto & out = result->getData();\n+\n+    if (attributes.empty())\n     {\n-        ColumnUInt8::MutablePtr col_null_map_to = ColumnUInt8::create(size, false);\n-        ColumnUInt8::Container& vec_null_map_to = col_null_map_to->getData();\n+        query_count.fetch_add(keys_size, std::memory_order_relaxed);\n+        return result;\n+    }\n+\n+    const auto & attribute = attributes.front();\n+    bool is_attribute_nullable = attribute.is_nullable_set.has_value();\n \n-        for (size_t row = 0; row < ids.size(); ++row)\n+    getAttributeContainer(0, [&](const auto & container)\n+    {\n+        for (size_t requested_key_index = 0; requested_key_index < keys_size; ++requested_key_index)\n         {\n-            auto id = ids[row];\n+            auto requested_key = extractor.extractCurrentKey();\n+\n+            out[requested_key_index] = container.find(requested_key) != container.end();\n \n-            if (attribute.nullable_set->find(id) != nullptr)\n-                vec_null_map_to[row] = true;\n+            if (is_attribute_nullable && !out[requested_key_index])\n+                out[requested_key_index] = attribute.is_nullable_set->find(requested_key) != nullptr;\n+\n+            extractor.rollbackCurrentKey();\n         }\n+    });\n \n-        result = ColumnNullable::create(result, std::move(col_null_map_to));\n-    }\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n \n     return result;\n }\n \n-ColumnUInt8::Ptr HashedDictionary::hasKeys(const Columns & key_columns, const DataTypes &) const\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getHierarchy(ColumnPtr key_column [[maybe_unused]], const DataTypePtr &) const\n {\n-    PaddedPODArray<Key> backup_storage;\n-    const auto& ids = getColumnVectorData(this, key_columns.front(), backup_storage);\n+    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup_storage;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n \n-    size_t ids_count = ext::size(ids);\n+        size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n \n-    auto result = ColumnUInt8::create(ext::size(ids));\n-    auto& out = result->getData();\n+        const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n+        const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-    const auto & attribute = attributes.front();\n+        const UInt64 null_value = dictionary_attribute.null_value.get<UInt64>();\n+        const CollectionType<UInt64> & parent_keys_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n \n-    auto type_call = [&](const auto & dictionary_attribute_type)\n-    {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        has<AttributeType>(attribute, ids, out);\n-    };\n+        auto is_key_valid_func = [&](auto & key) { return parent_keys_map.find(key) != parent_keys_map.end(); };\n \n-    callOnDictionaryAttributeType(attribute.type, type_call);\n+        auto get_parent_func = [&](auto & hierarchy_key)\n+        {\n+            std::optional<UInt64> result;\n \n-    query_count.fetch_add(ids_count, std::memory_order_relaxed);\n+            auto it = parent_keys_map.find(hierarchy_key);\n \n-    return result;\n+            if (it != parent_keys_map.end())\n+                result = getValueFromCell(it);\n+\n+            return result;\n+        };\n+\n+        auto dictionary_hierarchy_array = getKeysHierarchyArray(keys, null_value, is_key_valid_func, get_parent_func);\n+\n+        query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+\n+        return dictionary_hierarchy_array;\n+    }\n+    else\n+        return nullptr;\n }\n \n-void HashedDictionary::createAttributes()\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+ColumnUInt8::Ptr HashedDictionary<dictionary_key_type, sparse>::isInHierarchy(\n+    ColumnPtr key_column [[maybe_unused]],\n+    ColumnPtr in_key_column [[maybe_unused]],\n+    const DataTypePtr &) const\n {\n-    const auto size = dict_struct.attributes.size();\n-    attributes.reserve(size);\n-\n-    for (const auto & attribute : dict_struct.attributes)\n+    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n     {\n-        attribute_index_by_name.emplace(attribute.name, attributes.size());\n-        attributes.push_back(createAttribute(attribute, attribute.null_value));\n+        PaddedPODArray<UInt64> keys_backup_storage;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup_storage);\n+\n+        PaddedPODArray<UInt64> keys_in_backup_storage;\n+        const auto & keys_in = getColumnVectorData(this, in_key_column, keys_in_backup_storage);\n+\n+        size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+\n+        const auto & dictionary_attribute = dict_struct.attributes[hierarchical_attribute_index];\n+        auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n \n-        if (attribute.hierarchical)\n+        const UInt64 null_value = dictionary_attribute.null_value.get<UInt64>();\n+        const CollectionType<UInt64> & parent_keys_map = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n+\n+        auto is_key_valid_func = [&](auto & key) { return parent_keys_map.find(key) != parent_keys_map.end(); };\n+\n+        auto get_parent_func = [&](auto & hierarchy_key)\n         {\n-            hierarchical_attribute = &attributes.back();\n+            std::optional<UInt64> result;\n \n-            if (hierarchical_attribute->type != AttributeUnderlyingType::utUInt64)\n-                throw Exception{full_name + \": hierarchical attribute must be UInt64.\", ErrorCodes::TYPE_MISMATCH};\n-        }\n+            auto it = parent_keys_map.find(hierarchy_key);\n+\n+            if (it != parent_keys_map.end())\n+                result = getValueFromCell(it);\n+\n+            return result;\n+        };\n+\n+        auto result = getKeysIsInHierarchyColumn(keys, keys_in, null_value, is_key_valid_func, get_parent_func);\n+\n+        query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+\n+        return result;\n     }\n+    else\n+        return nullptr;\n }\n \n-void HashedDictionary::blockToAttributes(const Block & block)\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+ColumnPtr HashedDictionary<dictionary_key_type, sparse>::getDescendants(\n+    ColumnPtr key_column [[maybe_unused]],\n+    const DataTypePtr &,\n+    size_t level [[maybe_unused]]) const\n {\n-    const auto & id_column = *block.safeGetByPosition(0).column;\n+    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n+    {\n+        PaddedPODArray<UInt64> keys_backup;\n+        const auto & keys = getColumnVectorData(this, key_column, keys_backup);\n+\n+        size_t hierarchical_attribute_index = *dict_struct.hierarchical_attribute_index;\n+\n+        const auto & hierarchical_attribute = attributes[hierarchical_attribute_index];\n+        const CollectionType<UInt64> & parent_keys = std::get<CollectionType<UInt64>>(hierarchical_attribute.container);\n \n-    for (const size_t attribute_idx : ext::range(0, attributes.size()))\n+        HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+\n+        for (const auto & [key, value] : parent_keys)\n+            parent_to_child[value].emplace_back(key);\n+\n+        auto result = getKeysDescendantsArray(keys, parent_to_child, level);\n+\n+        query_count.fetch_add(keys.size(), std::memory_order_relaxed);\n+\n+        return result;\n+    }\n+    else\n+        return nullptr;\n+}\n+\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::createAttributes()\n+{\n+    const auto size = dict_struct.attributes.size();\n+    attributes.reserve(size);\n+\n+    for (const auto & dictionary_attribute : dict_struct.attributes)\n     {\n-        const IColumn & attribute_column = *block.safeGetByPosition(attribute_idx + 1).column;\n-        auto & attribute = attributes[attribute_idx];\n+        auto type_call = [&, this](const auto & dictionary_attribute_type)\n+        {\n+            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n+            using AttributeType = typename Type::AttributeType;\n+            using ValueType = DictionaryValueType<AttributeType>;\n \n-        for (const auto row_idx : ext::range(0, id_column.size()))\n-            if (setAttributeValue(attribute, id_column[row_idx].get<UInt64>(), attribute_column[row_idx]))\n-                ++element_count;\n+            auto is_nullable_set = dictionary_attribute.is_nullable ? std::make_optional<NullableSet>() : std::optional<NullableSet>{};\n+            std::unique_ptr<Arena> string_arena = std::is_same_v<AttributeType, String> ? std::make_unique<Arena>() : nullptr;\n+\n+            ValueType default_value;\n+\n+            if constexpr (std::is_same_v<ValueType, StringRef>)\n+            {\n+                string_arena = std::make_unique<Arena>();\n+\n+                const auto & string_null_value = dictionary_attribute.null_value.get<String>();\n+                const size_t string_null_value_size = string_null_value.size();\n+\n+                const char * string_in_arena = string_arena->insert(string_null_value.data(), string_null_value_size);\n+                default_value = {string_in_arena, string_null_value_size};\n+            }\n+            else\n+                default_value = dictionary_attribute.null_value.get<NearestFieldType<ValueType>>();\n+\n+            Attribute attribute{dictionary_attribute.underlying_type, std::move(is_nullable_set), default_value, CollectionType<ValueType>(), std::move(string_arena)};\n+            attributes.emplace_back(std::move(attribute));\n+        };\n+\n+        callOnDictionaryAttributeType(dictionary_attribute.underlying_type, type_call);\n     }\n }\n \n-void HashedDictionary::updateData()\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::updateData()\n {\n     if (!saved_block || saved_block->rows() == 0)\n     {\n@@ -277,6 +357,7 @@ void HashedDictionary::updateData()\n             /// We are using this to keep saved data if input stream consists of multiple blocks\n             if (!saved_block)\n                 saved_block = std::make_shared<DB::Block>(block.cloneEmpty());\n+\n             for (const auto attribute_idx : ext::range(0, attributes.size() + 1))\n             {\n                 const IColumn & update_column = *block.getByPosition(attribute_idx).column.get();\n@@ -288,34 +369,50 @@ void HashedDictionary::updateData()\n     }\n     else\n     {\n+        size_t skip_keys_size_offset = dict_struct.getKeysSize();\n+\n+        Columns saved_block_key_columns;\n+        saved_block_key_columns.reserve(skip_keys_size_offset);\n+\n+        /// Split into keys columns and attribute columns\n+        for (size_t i = 0; i < skip_keys_size_offset; ++i)\n+            saved_block_key_columns.emplace_back(saved_block->safeGetByPosition(i).column);\n+\n+\n+        DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+        DictionaryKeysExtractor<dictionary_key_type> saved_keys_extractor(saved_block_key_columns, arena_holder.getComplexKeyArena());\n+        auto saved_keys_extracted_from_block = saved_keys_extractor.extractAllKeys();\n+\n         auto stream = source_ptr->loadUpdatedAll();\n         stream->readPrefix();\n \n         while (Block block = stream->read())\n         {\n-            const auto & saved_id_column = *saved_block->safeGetByPosition(0).column;\n-            const auto & update_id_column = *block.safeGetByPosition(0).column;\n+            /// TODO: Rewrite\n+            Columns block_key_columns;\n+            block_key_columns.reserve(skip_keys_size_offset);\n \n-            std::unordered_map<Key, std::vector<size_t>> update_ids;\n-            for (size_t row = 0; row < update_id_column.size(); ++row)\n+            /// Split into keys columns and attribute columns\n+            for (size_t i = 0; i < skip_keys_size_offset; ++i)\n+                block_key_columns.emplace_back(block.safeGetByPosition(i).column);\n+\n+            DictionaryKeysExtractor<dictionary_key_type> block_keys_extractor(saved_block_key_columns, arena_holder.getComplexKeyArena());\n+            auto keys_extracted_from_block = block_keys_extractor.extractAllKeys();\n+\n+            absl::flat_hash_map<KeyType, std::vector<size_t>, DefaultHash<KeyType>> update_keys;\n+            for (size_t row = 0; row < keys_extracted_from_block.size(); ++row)\n             {\n-                const auto id = update_id_column.get64(row);\n-                update_ids[id].push_back(row);\n+                auto key = keys_extracted_from_block[row];\n+                update_keys[key].push_back(row);\n             }\n \n-            const size_t saved_rows = saved_id_column.size();\n-            IColumn::Filter filter(saved_rows);\n-            std::unordered_map<Key, std::vector<size_t>>::iterator it;\n+            IColumn::Filter filter(saved_keys_extracted_from_block.size());\n \n-            for (size_t row = 0; row < saved_id_column.size(); ++row)\n+            for (size_t row = 0; row < saved_keys_extracted_from_block.size(); ++row)\n             {\n-                auto id = saved_id_column.get64(row);\n-                it = update_ids.find(id);\n-\n-                if (it != update_ids.end())\n-                    filter[row] = 0;\n-                else\n-                    filter[row] = 1;\n+                auto key = saved_keys_extracted_from_block[row];\n+                auto it = update_keys.find(key);\n+                filter[row] = (it == update_keys.end());\n             }\n \n             auto block_columns = block.mutateColumns();\n@@ -323,12 +420,12 @@ void HashedDictionary::updateData()\n             {\n                 auto & column = saved_block->safeGetByPosition(attribute_idx).column;\n                 const auto & filtered_column = column->filter(filter, -1);\n-\n                 block_columns[attribute_idx]->insertRangeFrom(*filtered_column.get(), 0, filtered_column->size());\n             }\n \n             saved_block->setColumns(std::move(block_columns));\n         }\n+\n         stream->readSuffix();\n     }\n \n@@ -339,324 +436,283 @@ void HashedDictionary::updateData()\n     }\n }\n \n-template <typename T>\n-void HashedDictionary::resize(Attribute & attribute, size_t added_rows)\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::blockToAttributes(const Block & block [[maybe_unused]])\n {\n-    if (!sparse)\n-    {\n-        const auto & map_ref = std::get<CollectionPtrType<T>>(attribute.maps);\n-        added_rows += map_ref->size();\n-        map_ref->reserve(added_rows);\n-    }\n-    else\n-    {\n-        const auto & map_ref = std::get<SparseCollectionPtrType<T>>(attribute.sparse_maps);\n-        added_rows += map_ref->size();\n-        map_ref->resize(added_rows);\n-    }\n-}\n+    size_t skip_keys_size_offset = dict_struct.getKeysSize();\n \n-template <>\n-void HashedDictionary::resize<String>(Attribute & attribute, size_t added_rows)\n-{\n-    resize<StringRef>(attribute, added_rows);\n-}\n+    Columns key_columns;\n+    key_columns.reserve(skip_keys_size_offset);\n \n-void HashedDictionary::resize(size_t added_rows)\n-{\n-    if (!added_rows)\n-        return;\n+    /// Split into keys columns and attribute columns\n+    for (size_t i = 0; i < skip_keys_size_offset; ++i)\n+        key_columns.emplace_back(block.safeGetByPosition(i).column);\n \n-    for (auto & attribute : attributes)\n-    {\n-        auto type_call = [&](const auto & dictionary_attribute_type)\n-        {\n-            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-            using AttributeType = typename Type::AttributeType;\n-            resize<AttributeType>(attribute, added_rows);\n-        };\n+    DictionaryKeysArenaHolder<dictionary_key_type> arena_holder;\n+    DictionaryKeysExtractor<dictionary_key_type> keys_extractor(key_columns, arena_holder.getComplexKeyArena());\n+    const size_t keys_size = keys_extractor.getKeysSize();\n \n-        callOnDictionaryAttributeType(attribute.type, type_call);\n-    }\n-}\n+    Field column_value_to_insert;\n \n-void HashedDictionary::loadData()\n-{\n-    if (!source_ptr->hasUpdateField())\n+    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)\n     {\n-        auto stream = source_ptr->loadAll();\n-\n-        stream->readPrefix();\n+        const IColumn & attribute_column = *block.safeGetByPosition(skip_keys_size_offset + attribute_index).column;\n+        auto & attribute = attributes[attribute_index];\n+        bool attribute_is_nullable = attribute.is_nullable_set.has_value();\n \n-        while (const auto block = stream->read())\n+        getAttributeContainer(attribute_index, [&](auto & container)\n         {\n-            resize(block.rows());\n-            blockToAttributes(block);\n-        }\n+            using ContainerType = std::decay_t<decltype(container)>;\n+            using AttributeValueType = typename ContainerType::mapped_type;\n \n-        stream->readSuffix();\n-    }\n-    else\n-        updateData();\n+            for (size_t key_index = 0; key_index < keys_size; ++key_index)\n+            {\n+                auto key = keys_extractor.extractCurrentKey();\n \n-    if (require_nonempty && 0 == element_count)\n-        throw Exception{full_name + \": dictionary source is empty and 'require_nonempty' property is set.\", ErrorCodes::DICTIONARY_IS_EMPTY};\n-}\n+                auto it = container.find(key);\n+                bool key_is_nullable_and_already_exists = attribute_is_nullable && attribute.is_nullable_set->find(key) != nullptr;\n \n-template <typename T>\n-void HashedDictionary::addAttributeSize(const Attribute & attribute)\n-{\n-    if (!sparse)\n-    {\n-        const auto & map_ref = std::get<CollectionPtrType<T>>(attribute.maps);\n-        bytes_allocated += sizeof(CollectionType<T>) + map_ref->getBufferSizeInBytes();\n-        bucket_count = map_ref->getBufferSizeInCells();\n-    }\n-    else\n-    {\n-        const auto & map_ref = std::get<SparseCollectionPtrType<T>>(attribute.sparse_maps);\n-        bucket_count = map_ref->bucket_count();\n+                if (key_is_nullable_and_already_exists || it != container.end())\n+                {\n+                    keys_extractor.rollbackCurrentKey();\n+                    continue;\n+                }\n \n-        /** TODO: more accurate calculation */\n-        bytes_allocated += sizeof(SparseCollectionType<T>);\n-        bytes_allocated += bucket_count;\n-        bytes_allocated += map_ref->size() * (sizeof(Key) + sizeof(T));\n-    }\n-}\n+                if constexpr (std::is_same_v<KeyType, StringRef>)\n+                    key = copyKeyInArena(key);\n \n-template <>\n-void HashedDictionary::addAttributeSize<String>(const Attribute & attribute)\n-{\n-    addAttributeSize<StringRef>(attribute);\n-    bytes_allocated += sizeof(Arena) + attribute.string_arena->size();\n-}\n+                attribute_column.get(key_index, column_value_to_insert);\n \n-void HashedDictionary::calculateBytesAllocated()\n-{\n-    bytes_allocated += attributes.size() * sizeof(attributes.front());\n+                if (attribute.is_nullable_set && column_value_to_insert.isNull())\n+                {\n+                    attribute.is_nullable_set->insert(key);\n+                    keys_extractor.rollbackCurrentKey();\n+                    continue;\n+                }\n \n-    for (const auto & attribute : attributes)\n-    {\n-        auto type_call = [&](const auto & dictionary_attribute_type)\n-        {\n-            using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-            using AttributeType = typename Type::AttributeType;\n-            addAttributeSize<AttributeType>(attribute);\n-        };\n+                if constexpr (std::is_same_v<AttributeValueType, StringRef>)\n+                {\n+                    String & value_to_insert = column_value_to_insert.get<String>();\n+                    size_t value_to_insert_size = value_to_insert.size();\n \n-        callOnDictionaryAttributeType(attribute.type, type_call);\n-    }\n-}\n+                    const char * string_in_arena = attribute.string_arena->insert(value_to_insert.data(), value_to_insert_size);\n \n-template <typename T>\n-void HashedDictionary::createAttributeImpl(Attribute & attribute, const Field & null_value)\n-{\n-    attribute.null_values = T(null_value.get<T>());\n-    if (!sparse)\n-        attribute.maps = std::make_unique<CollectionType<T>>();\n-    else\n-        attribute.sparse_maps = std::make_unique<SparseCollectionType<T>>();\n-}\n+                    StringRef string_in_arena_reference = StringRef{string_in_arena, value_to_insert_size};\n+                    container.insert({key, string_in_arena_reference});\n+                }\n+                else\n+                {\n+                    auto value_to_insert = column_value_to_insert.get<NearestFieldType<AttributeValueType>>();\n+                    container.insert({key, value_to_insert});\n+                }\n \n-template <>\n-void HashedDictionary::createAttributeImpl<String>(Attribute & attribute, const Field & null_value)\n-{\n-    attribute.string_arena = std::make_unique<Arena>();\n-    const String & string = null_value.get<String>();\n-    const char * string_in_arena = attribute.string_arena->insert(string.data(), string.size());\n-    attribute.null_values.emplace<StringRef>(string_in_arena, string.size());\n+                ++element_count;\n \n-    if (!sparse)\n-        attribute.maps = std::make_unique<CollectionType<StringRef>>();\n-    else\n-        attribute.sparse_maps = std::make_unique<SparseCollectionType<StringRef>>();\n+                keys_extractor.rollbackCurrentKey();\n+            }\n+\n+            keys_extractor.reset();\n+        });\n+    }\n }\n \n-HashedDictionary::Attribute HashedDictionary::createAttribute(const DictionaryAttribute& attribute, const Field & null_value)\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::resize(size_t added_rows)\n {\n-    auto nullable_set = attribute.is_nullable ? std::make_optional<NullableSet>() : std::optional<NullableSet>{};\n-    Attribute attr{attribute.underlying_type, std::move(nullable_set), {}, {}, {}, {}};\n+    if (unlikely(!added_rows))\n+        return;\n \n-    auto type_call = [&, this](const auto &dictionary_attribute_type)\n+    for (size_t attribute_index = 0; attribute_index < attributes.size(); ++attribute_index)\n     {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-        createAttributeImpl<AttributeType>(attr, null_value);\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.underlying_type, type_call);\n+        getAttributeContainer(attribute_index, [added_rows](auto & attribute_map)\n+        {\n+            size_t reserve_size = added_rows + attribute_map.size();\n \n-    return attr;\n+            if constexpr (sparse)\n+                attribute_map.resize(reserve_size);\n+            else\n+                attribute_map.reserve(reserve_size);\n+        });\n+    }\n }\n \n-\n-template <typename AttributeType, typename OutputType, typename MapType, typename ValueSetter, typename DefaultValueExtractor>\n-void HashedDictionary::getItemsAttrImpl(\n-    const MapType & attr,\n-    const PaddedPODArray<Key> & ids,\n-    ValueSetter && set_value,\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+template <typename AttributeType, typename ValueSetter, typename NullableValueSetter, typename DefaultValueExtractor>\n+void HashedDictionary<dictionary_key_type, sparse>::getItemsImpl(\n+    const Attribute & attribute,\n+    DictionaryKeysExtractor<dictionary_key_type> & keys_extractor,\n+    ValueSetter && set_value [[maybe_unused]],\n+    NullableValueSetter && set_nullable_value [[maybe_unused]],\n     DefaultValueExtractor & default_value_extractor) const\n {\n-    const auto rows = ext::size(ids);\n+    const auto & attribute_container = std::get<CollectionType<AttributeType>>(attribute.container);\n+    const size_t keys_size = keys_extractor.getKeysSize();\n \n-    for (const auto i : ext::range(0, rows))\n+    bool is_attribute_nullable = attribute.is_nullable_set.has_value();\n+\n+    for (size_t key_index = 0; key_index < keys_size; ++key_index)\n     {\n-        const auto it = attr.find(ids[i]);\n-        set_value(i, it != attr.end() ? static_cast<OutputType>(second(*it)) : default_value_extractor[i]);\n+        auto key = keys_extractor.extractCurrentKey();\n+\n+        const auto it = attribute_container.find(key);\n+\n+        if (it != attribute_container.end())\n+            set_value(key_index, getValueFromCell(it));\n+        else\n+        {\n+            if (is_attribute_nullable && attribute.is_nullable_set->find(key) != nullptr)\n+                set_nullable_value(key_index);\n+            else\n+                set_value(key_index, default_value_extractor[key_index]);\n+        }\n+\n+        keys_extractor.rollbackCurrentKey();\n     }\n \n-    query_count.fetch_add(rows, std::memory_order_relaxed);\n+    query_count.fetch_add(keys_size, std::memory_order_relaxed);\n }\n \n-template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n-void HashedDictionary::getItemsImpl(\n-    const Attribute & attribute,\n-    const PaddedPODArray<Key> & ids,\n-    ValueSetter && set_value,\n-    DefaultValueExtractor & default_value_extractor) const\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+StringRef HashedDictionary<dictionary_key_type, sparse>::copyKeyInArena(StringRef key)\n {\n-    if (!sparse)\n-        return getItemsAttrImpl<AttributeType, OutputType>(*std::get<CollectionPtrType<AttributeType>>(attribute.maps), ids, set_value, default_value_extractor);\n-    return getItemsAttrImpl<AttributeType, OutputType>(*std::get<SparseCollectionPtrType<AttributeType>>(attribute.sparse_maps), ids, set_value, default_value_extractor);\n+    size_t key_size = key.size;\n+    char * place_for_key = complex_key_arena.alloc(key_size);\n+    memcpy(reinterpret_cast<void *>(place_for_key), reinterpret_cast<const void *>(key.data), key_size);\n+    StringRef updated_key{place_for_key, key_size};\n+    return updated_key;\n }\n \n-\n-template <typename T>\n-bool HashedDictionary::setAttributeValueImpl(Attribute & attribute, const Key id, const T value)\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::loadData()\n {\n-    if (!sparse)\n+    if (!source_ptr->hasUpdateField())\n     {\n-        auto & map = *std::get<CollectionPtrType<T>>(attribute.maps);\n-        return map.insert({id, value}).second;\n+        auto stream = source_ptr->loadAll();\n+\n+        stream->readPrefix();\n+\n+        while (const auto block = stream->read())\n+        {\n+            resize(block.rows());\n+            blockToAttributes(block);\n+        }\n+\n+        stream->readSuffix();\n     }\n     else\n-    {\n-        auto & map = *std::get<SparseCollectionPtrType<T>>(attribute.sparse_maps);\n-        return map.insert({id, value}).second;\n-    }\n-}\n+        updateData();\n \n-template <>\n-bool HashedDictionary::setAttributeValueImpl<String>(Attribute & attribute, const Key id, const String value)\n-{\n-    const auto * string_in_arena = attribute.string_arena->insert(value.data(), value.size());\n-    return setAttributeValueImpl<StringRef>(attribute, id, StringRef{string_in_arena, value.size()});\n+    if (require_nonempty && 0 == element_count)\n+        throw Exception(ErrorCodes::DICTIONARY_IS_EMPTY,\n+            \"({}): dictionary source is empty and 'require_nonempty' property is set.\",\n+            full_name);\n }\n \n-bool HashedDictionary::setAttributeValue(Attribute & attribute, const Key id, const Field & value)\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+void HashedDictionary<dictionary_key_type, sparse>::calculateBytesAllocated()\n {\n-    bool result = false;\n+    bytes_allocated += attributes.size() * sizeof(attributes.front());\n \n-    auto type_call = [&, this](const auto &dictionary_attribute_type)\n+    for (size_t i = 0; i < attributes.size(); ++i)\n     {\n-        using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n-        using AttributeType = typename Type::AttributeType;\n-\n-        if (attribute.nullable_set)\n+        getAttributeContainer(i, [&](const auto & container)\n         {\n-            if (value.isNull())\n+            using ContainerType = std::decay_t<decltype(container)>;\n+            using AttributeValueType = typename ContainerType::mapped_type;\n+\n+            bytes_allocated += sizeof(container);\n+\n+            if constexpr (sparse || std::is_same_v<AttributeValueType, Field>)\n             {\n-                result = attribute.nullable_set->insert(id).second;\n-                return;\n+                bytes_allocated += container.max_size() * (sizeof(KeyType) + sizeof(AttributeValueType));\n+                bucket_count = container.bucket_count();\n             }\n             else\n             {\n-                attribute.nullable_set->erase(id);\n+                bytes_allocated += container.getBufferSizeInBytes();\n+                bucket_count = container.getBufferSizeInCells();\n             }\n-        }\n+        });\n \n-        result = setAttributeValueImpl<AttributeType>(attribute, id, value.get<AttributeType>());\n-    };\n-\n-    callOnDictionaryAttributeType(attribute.type, type_call);\n-\n-    return result;\n-}\n-\n-const HashedDictionary::Attribute & HashedDictionary::getAttribute(const std::string & attribute_name) const\n-{\n-    const auto it = attribute_index_by_name.find(attribute_name);\n-    if (it == std::end(attribute_index_by_name))\n-        throw Exception{full_name + \": no such attribute '\" + attribute_name + \"'\", ErrorCodes::BAD_ARGUMENTS};\n+        if (attributes[i].string_arena)\n+            bytes_allocated += attributes[i].string_arena->size();\n+    }\n \n-    return attributes[it->second];\n+    bytes_allocated += complex_key_arena.size();\n }\n \n-template <typename T>\n-void HashedDictionary::has(const Attribute & attribute, const PaddedPODArray<Key> & ids, PaddedPODArray<UInt8> & out) const\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+BlockInputStreamPtr HashedDictionary<dictionary_key_type, sparse>::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n {\n-    const auto & attr = *std::get<CollectionPtrType<T>>(attribute.maps);\n-    const auto rows = ext::size(ids);\n+    PaddedPODArray<HashedDictionary::KeyType> keys;\n \n-    for (const auto i : ext::range(0, rows))\n+    if (!attributes.empty())\n     {\n-        out[i] = attr.find(ids[i]) != nullptr;\n+        const auto & attribute = attributes.front();\n \n-        if (attribute.nullable_set && !out[i])\n-            out[i] = attribute.nullable_set->find(ids[i]) != nullptr;\n-    }\n-}\n+        getAttributeContainer(0, [&](auto & container)\n+        {\n+            keys.reserve(container.size());\n \n-template <>\n-void HashedDictionary::has<String>(const Attribute & attribute, const PaddedPODArray<Key> & ids, PaddedPODArray<UInt8> & out) const\n-{\n-    has<StringRef>(attribute, ids, out);\n-}\n+            for (const auto & [key, value] : container)\n+            {\n+                (void)(value);\n+                keys.emplace_back(key);\n+            }\n \n-template <typename T, typename AttrType>\n-PaddedPODArray<HashedDictionary::Key> HashedDictionary::getIdsAttrImpl(const AttrType & attr) const\n-{\n-    PaddedPODArray<Key> ids;\n-    ids.reserve(attr.size());\n-    for (const auto & value : attr)\n-        ids.push_back(first(value));\n+            if (attribute.is_nullable_set)\n+            {\n+                const auto & is_nullable_set = *attribute.is_nullable_set;\n+                keys.reserve(is_nullable_set.size());\n \n-    return ids;\n-}\n-template <typename T>\n-PaddedPODArray<HashedDictionary::Key> HashedDictionary::getIds(const Attribute & attribute) const\n-{\n-    if (!sparse)\n-        return getIdsAttrImpl<T>(*std::get<CollectionPtrType<T>>(attribute.maps));\n-    return getIdsAttrImpl<T>(*std::get<SparseCollectionPtrType<T>>(attribute.sparse_maps));\n-}\n+                for (auto & node : is_nullable_set)\n+                    keys.emplace_back(node.getKey());\n+            }\n+        });\n+    }\n \n-template <>\n-PaddedPODArray<HashedDictionary::Key> HashedDictionary::getIds<String>(const Attribute & attribute) const\n-{\n-    return getIds<StringRef>(attribute);\n+    if constexpr (dictionary_key_type == DictionaryKeyType::simple)\n+        return std::make_shared<DictionaryBlockInputStream>(shared_from_this(), max_block_size, std::move(keys), column_names);\n+    else\n+        return std::make_shared<DictionaryBlockInputStream>(shared_from_this(), max_block_size, keys, column_names);\n }\n \n-PaddedPODArray<HashedDictionary::Key> HashedDictionary::getIds() const\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+template <typename GetContainerFunc>\n+void HashedDictionary<dictionary_key_type, sparse>::getAttributeContainer(size_t attribute_index, GetContainerFunc && get_container_func)\n {\n-    const auto & attribute = attributes.front();\n-    PaddedPODArray<HashedDictionary::Key> result;\n+    assert(attribute_index < attributes.size());\n+\n+    auto & attribute = attributes[attribute_index];\n \n     auto type_call = [&](const auto & dictionary_attribute_type)\n     {\n         using Type = std::decay_t<decltype(dictionary_attribute_type)>;\n         using AttributeType = typename Type::AttributeType;\n-        /// TODO: Check if order is satisfied\n-        result = getIds<AttributeType>(attribute);\n+        using ValueType = DictionaryValueType<AttributeType>;\n \n-        if (attribute.nullable_set)\n-        {\n-            for (const auto& value: *attribute.nullable_set)\n-                result.push_back(value.getKey());\n-        }\n+        auto & attribute_container = std::get<CollectionType<ValueType>>(attribute.container);\n+        std::forward<GetContainerFunc>(get_container_func)(attribute_container);\n     };\n \n     callOnDictionaryAttributeType(attribute.type, type_call);\n-\n-    return result;\n }\n \n-BlockInputStreamPtr HashedDictionary::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n+template <typename GetContainerFunc>\n+void HashedDictionary<dictionary_key_type, sparse>::getAttributeContainer(size_t attribute_index, GetContainerFunc && get_container_func) const\n {\n-    using BlockInputStreamType = DictionaryBlockInputStream<Key>;\n-    return std::make_shared<BlockInputStreamType>(shared_from_this(), max_block_size, getIds(), column_names);\n+    const_cast<std::decay_t<decltype(*this)> *>(this)->getAttributeContainer(attribute_index, [&](auto & attribute_container)\n+    {\n+        std::forward<GetContainerFunc>(get_container_func)(attribute_container);\n+    });\n }\n \n+template class HashedDictionary<DictionaryKeyType::simple, true>;\n+template class HashedDictionary<DictionaryKeyType::simple, false>;\n+template class HashedDictionary<DictionaryKeyType::complex, true>;\n+template class HashedDictionary<DictionaryKeyType::complex, false>;\n+\n void registerDictionaryHashed(DictionaryFactory & factory)\n {\n     auto create_layout = [](const std::string & full_name,\n@@ -664,10 +720,13 @@ void registerDictionaryHashed(DictionaryFactory & factory)\n                              const Poco::Util::AbstractConfiguration & config,\n                              const std::string & config_prefix,\n                              DictionarySourcePtr source_ptr,\n+                             DictionaryKeyType dictionary_key_type,\n                              bool sparse) -> DictionaryPtr\n     {\n-        if (dict_struct.key)\n-            throw Exception{\"'key' is not supported for dictionary of layout 'hashed'\", ErrorCodes::UNSUPPORTED_METHOD};\n+        if (dictionary_key_type == DictionaryKeyType::simple && dict_struct.key)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'key' is not supported for simple key hashed dictionary\");\n+        else if (dictionary_key_type == DictionaryKeyType::complex && dict_struct.id)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"'id' is not supported for complex key hashed dictionary\");\n \n         if (dict_struct.range_min || dict_struct.range_max)\n             throw Exception{full_name\n@@ -678,13 +737,34 @@ void registerDictionaryHashed(DictionaryFactory & factory)\n         const auto dict_id = StorageID::fromDictionaryConfig(config, config_prefix);\n         const DictionaryLifetime dict_lifetime{config, config_prefix + \".lifetime\"};\n         const bool require_nonempty = config.getBool(config_prefix + \".require_nonempty\", false);\n-        return std::make_unique<HashedDictionary>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty, sparse);\n+\n+        if (dictionary_key_type == DictionaryKeyType::simple)\n+        {\n+            if (sparse)\n+                return std::make_unique<HashedDictionary<DictionaryKeyType::simple, true>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+            else\n+                return std::make_unique<HashedDictionary<DictionaryKeyType::simple, false>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        }\n+        else\n+        {\n+            if (sparse)\n+                return std::make_unique<HashedDictionary<DictionaryKeyType::complex, true>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+            else\n+                return std::make_unique<HashedDictionary<DictionaryKeyType::complex, false>>(dict_id, dict_struct, std::move(source_ptr), dict_lifetime, require_nonempty);\n+        }\n     };\n+\n     using namespace std::placeholders;\n+\n     factory.registerLayout(\"hashed\",\n-        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e){ return create_layout(a, b, c, d, std::move(e), /* sparse = */ false); }, false);\n+        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e){ return create_layout(a, b, c, d, std::move(e), DictionaryKeyType::simple, /* sparse = */ false); }, false);\n     factory.registerLayout(\"sparse_hashed\",\n-        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e){ return create_layout(a, b, c, d, std::move(e), /* sparse = */ true); }, false);\n+        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e){ return create_layout(a, b, c, d, std::move(e), DictionaryKeyType::simple, /* sparse = */ true); }, false);\n+    factory.registerLayout(\"complex_key_hashed\",\n+        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e){ return create_layout(a, b, c, d, std::move(e), DictionaryKeyType::complex, /* sparse = */ false); }, true);\n+    factory.registerLayout(\"complex_key_sparse_hashed\",\n+        [=](auto && a, auto && b, auto && c, auto && d, DictionarySourcePtr e){ return create_layout(a, b, c, d, std::move(e), DictionaryKeyType::complex, /* sparse = */ true); }, true);\n+\n }\n \n }\ndiff --git a/src/Dictionaries/HashedDictionary.h b/src/Dictionaries/HashedDictionary.h\nindex ab37f1528ca7..3882b6693246 100644\n--- a/src/Dictionaries/HashedDictionary.h\n+++ b/src/Dictionaries/HashedDictionary.h\n@@ -4,17 +4,21 @@\n #include <memory>\n #include <variant>\n #include <optional>\n-#include <Columns/ColumnDecimal.h>\n-#include <Columns/ColumnString.h>\n-#include <Core/Block.h>\n-#include <Common/HashTable/HashMap.h>\n-#include <Common/HashTable/HashSet.h>\n+\n #include <sparsehash/sparse_hash_map>\n #include <ext/range.h>\n-#include \"DictionaryStructure.h\"\n-#include \"IDictionary.h\"\n-#include \"IDictionarySource.h\"\n-#include \"DictionaryHelpers.h\"\n+\n+#include <Common/HashTable/HashMap.h>\n+#include <Common/HashTable/HashSet.h>\n+#include <Core/Block.h>\n+\n+#include <Columns/ColumnDecimal.h>\n+#include <Columns/ColumnString.h>\n+\n+#include <Dictionaries/DictionaryStructure.h>\n+#include <Dictionaries/IDictionary.h>\n+#include <Dictionaries/IDictionarySource.h>\n+#include <Dictionaries/DictionaryHelpers.h>\n \n /** This dictionary stores all content in a hash table in memory\n   * (a separate Key -> Value map for each attribute)\n@@ -24,19 +28,32 @@\n namespace DB\n {\n \n+template <DictionaryKeyType dictionary_key_type, bool sparse>\n class HashedDictionary final : public IDictionary\n {\n public:\n+    using KeyType = std::conditional_t<dictionary_key_type == DictionaryKeyType::simple, UInt64, StringRef>;\n+    static_assert(dictionary_key_type != DictionaryKeyType::range, \"Range key type is not supported by hashed dictionary\");\n+\n     HashedDictionary(\n         const StorageID & dict_id_,\n         const DictionaryStructure & dict_struct_,\n         DictionarySourcePtr source_ptr_,\n         const DictionaryLifetime dict_lifetime_,\n         bool require_nonempty_,\n-        bool sparse_,\n         BlockPtr saved_block_ = nullptr);\n \n-    std::string getTypeName() const override { return sparse ? \"SparseHashed\" : \"Hashed\"; }\n+    std::string getTypeName() const override\n+    {\n+        if constexpr (dictionary_key_type == DictionaryKeyType::simple && sparse)\n+            return \"SparseHashed\";\n+        else if constexpr (dictionary_key_type == DictionaryKeyType::simple && !sparse)\n+            return \"Hashed\";\n+        else if constexpr (dictionary_key_type == DictionaryKeyType::complex && sparse)\n+            return \"ComplexKeySpareseHashed\";\n+        else\n+            return \"ComplexKeyHashed\";\n+    }\n \n     size_t getBytesAllocated() const override { return bytes_allocated; }\n \n@@ -50,7 +67,7 @@ class HashedDictionary final : public IDictionary\n \n     std::shared_ptr<const IExternalLoadable> clone() const override\n     {\n-        return std::make_shared<HashedDictionary>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, sparse, saved_block);\n+        return std::make_shared<HashedDictionary<dictionary_key_type, sparse>>(getDictionaryID(), dict_struct, source_ptr->clone(), dict_lifetime, require_nonempty, saved_block);\n     }\n \n     const IDictionarySource * getSource() const override { return source_ptr.get(); }\n@@ -61,14 +78,10 @@ class HashedDictionary final : public IDictionary\n \n     bool isInjective(const std::string & attribute_name) const override\n     {\n-        return dict_struct.attributes[&getAttribute(attribute_name) - attributes.data()].injective;\n+        return dict_struct.getAttribute(attribute_name).injective;\n     }\n \n-    bool hasHierarchy() const override { return hierarchical_attribute; }\n-\n-    void toParent(const PaddedPODArray<Key> & ids, PaddedPODArray<Key> & out) const override;\n-\n-    DictionaryKeyType getKeyType() const override { return DictionaryKeyType::simple; }\n+    DictionaryKeyType getKeyType() const override { return dictionary_key_type; }\n \n     ColumnPtr getColumn(\n         const std::string& attribute_name,\n@@ -79,36 +92,52 @@ class HashedDictionary final : public IDictionary\n \n     ColumnUInt8::Ptr hasKeys(const Columns & key_columns, const DataTypes & key_types) const override;\n \n-    void isInVectorVector(\n-        const PaddedPODArray<Key> & child_ids, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const override;\n-    void isInVectorConstant(const PaddedPODArray<Key> & child_ids, const Key ancestor_id, PaddedPODArray<UInt8> & out) const override;\n-    void isInConstantVector(const Key child_id, const PaddedPODArray<Key> & ancestor_ids, PaddedPODArray<UInt8> & out) const override;\n+    bool hasHierarchy() const override { return dictionary_key_type == DictionaryKeyType::simple && dict_struct.hierarchical_attribute_index.has_value(); }\n+\n+    ColumnPtr getHierarchy(ColumnPtr key_column, const DataTypePtr & hierarchy_attribute_type) const override;\n+\n+    ColumnUInt8::Ptr isInHierarchy(\n+        ColumnPtr key_column,\n+        ColumnPtr in_key_column,\n+        const DataTypePtr & key_type) const override;\n+\n+    ColumnPtr getDescendants(\n+        ColumnPtr key_column,\n+        const DataTypePtr & key_type,\n+        size_t level) const override;\n \n     BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const override;\n \n private:\n     template <typename Value>\n-    using CollectionType = HashMap<UInt64, Value>;\n-    template <typename Value>\n-    using CollectionPtrType = std::unique_ptr<CollectionType<Value>>;\n+    using CollectionTypeNonSparse = std::conditional_t<\n+        dictionary_key_type == DictionaryKeyType::simple,\n+        HashMap<UInt64, Value>,\n+        HashMapWithSavedHash<StringRef, Value, DefaultHash<StringRef>>>;\n \n #if !defined(ARCADIA_BUILD)\n-    template <typename Value>\n-    using SparseCollectionType = google::sparse_hash_map<UInt64, Value, DefaultHash<UInt64>>;\n+    template <typename Key, typename Value>\n+    using SparseHashMap = google::sparse_hash_map<Key, Value, DefaultHash<Key>>;\n #else\n-    template <typename Value>\n-    using SparseCollectionType = google::sparsehash::sparse_hash_map<UInt64, Value, DefaultHash<UInt64>>;\n+        template <typename Key, typename Value>\n+        using SparseHashMap = google::sparsehash::sparse_hash_map<Key, Value, DefaultHash<Key>>;\n #endif\n \n     template <typename Value>\n-    using SparseCollectionPtrType = std::unique_ptr<SparseCollectionType<Value>>;\n+    using CollectionTypeSparse = std::conditional_t<\n+        dictionary_key_type == DictionaryKeyType::simple,\n+        SparseHashMap<UInt64, Value>,\n+        SparseHashMap<StringRef, Value>>;\n \n-    using NullableSet = HashSet<Key, DefaultHash<Key>>;\n+    template <typename Value>\n+    using CollectionType = std::conditional_t<sparse, CollectionTypeSparse<Value>, CollectionTypeNonSparse<Value>>;\n+\n+    using NullableSet = HashSet<KeyType, DefaultHash<KeyType>>;\n \n     struct Attribute final\n     {\n         AttributeUnderlyingType type;\n-        std::optional<NullableSet> nullable_set;\n+        std::optional<NullableSet> is_nullable_set;\n \n         std::variant<\n             UInt8,\n@@ -127,41 +156,27 @@ class HashedDictionary final : public IDictionary\n             Float64,\n             StringRef>\n             null_values;\n+\n         std::variant<\n-            CollectionPtrType<UInt8>,\n-            CollectionPtrType<UInt16>,\n-            CollectionPtrType<UInt32>,\n-            CollectionPtrType<UInt64>,\n-            CollectionPtrType<UInt128>,\n-            CollectionPtrType<Int8>,\n-            CollectionPtrType<Int16>,\n-            CollectionPtrType<Int32>,\n-            CollectionPtrType<Int64>,\n-            CollectionPtrType<Decimal32>,\n-            CollectionPtrType<Decimal64>,\n-            CollectionPtrType<Decimal128>,\n-            CollectionPtrType<Float32>,\n-            CollectionPtrType<Float64>,\n-            CollectionPtrType<StringRef>>\n-            maps;\n-        std::variant<\n-            SparseCollectionPtrType<UInt8>,\n-            SparseCollectionPtrType<UInt16>,\n-            SparseCollectionPtrType<UInt32>,\n-            SparseCollectionPtrType<UInt64>,\n-            SparseCollectionPtrType<UInt128>,\n-            SparseCollectionPtrType<Int8>,\n-            SparseCollectionPtrType<Int16>,\n-            SparseCollectionPtrType<Int32>,\n-            SparseCollectionPtrType<Int64>,\n-            SparseCollectionPtrType<Decimal32>,\n-            SparseCollectionPtrType<Decimal64>,\n-            SparseCollectionPtrType<Decimal128>,\n-            SparseCollectionPtrType<Float32>,\n-            SparseCollectionPtrType<Float64>,\n-            SparseCollectionPtrType<StringRef>>\n-            sparse_maps;\n+            CollectionType<UInt8>,\n+            CollectionType<UInt16>,\n+            CollectionType<UInt32>,\n+            CollectionType<UInt64>,\n+            CollectionType<UInt128>,\n+            CollectionType<Int8>,\n+            CollectionType<Int16>,\n+            CollectionType<Int32>,\n+            CollectionType<Int64>,\n+            CollectionType<Decimal32>,\n+            CollectionType<Decimal64>,\n+            CollectionType<Decimal128>,\n+            CollectionType<Float32>,\n+            CollectionType<Float64>,\n+            CollectionType<StringRef>>\n+            container;\n+\n         std::unique_ptr<Arena> string_arena;\n+\n     };\n \n     void createAttributes();\n@@ -172,76 +187,47 @@ class HashedDictionary final : public IDictionary\n \n     void loadData();\n \n-    template <typename T>\n-    void addAttributeSize(const Attribute & attribute);\n-\n     void calculateBytesAllocated();\n \n-    template <typename T>\n-    void createAttributeImpl(Attribute & attribute, const Field & null_value);\n-\n-    Attribute createAttribute(const DictionaryAttribute& attribute, const Field & null_value);\n-\n-    template <typename AttributeType, typename OutputType, typename MapType, typename ValueSetter, typename DefaultValueExtractor>\n-    void getItemsAttrImpl(\n-        const MapType & attr,\n-        const PaddedPODArray<Key> & ids,\n-        ValueSetter && set_value,\n-        DefaultValueExtractor & default_value_extractor) const;\n-\n-    template <typename AttributeType, typename OutputType, typename ValueSetter, typename DefaultValueExtractor>\n+    template <typename AttributeType, typename ValueSetter, typename NullableValueSetter, typename DefaultValueExtractor>\n     void getItemsImpl(\n         const Attribute & attribute,\n-        const PaddedPODArray<Key> & ids,\n+        DictionaryKeysExtractor<dictionary_key_type> & keys_extractor,\n         ValueSetter && set_value,\n+        NullableValueSetter && set_nullable_value,\n         DefaultValueExtractor & default_value_extractor) const;\n \n-    template <typename T>\n-    bool setAttributeValueImpl(Attribute & attribute, const Key id, const T value);\n-\n-    bool setAttributeValue(Attribute & attribute, const Key id, const Field & value);\n+    template <typename GetContainerFunc>\n+    void getAttributeContainer(size_t attribute_index, GetContainerFunc && get_container_func);\n \n-    const Attribute & getAttribute(const std::string & attribute_name) const;\n+    template <typename GetContainerFunc>\n+    void getAttributeContainer(size_t attribute_index, GetContainerFunc && get_container_func) const;\n \n-    template <typename T>\n-    void has(const Attribute & attribute, const PaddedPODArray<Key> & ids, PaddedPODArray<UInt8> & out) const;\n-\n-    template <typename T, typename AttrType>\n-    PaddedPODArray<Key> getIdsAttrImpl(const AttrType & attr) const;\n-    template <typename T>\n-    PaddedPODArray<Key> getIds(const Attribute & attribute) const;\n-\n-    PaddedPODArray<Key> getIds() const;\n-\n-    /// Preallocates the hashtable based on query progress\n-    /// (Only while loading all data).\n-    ///\n-    /// @see preallocate\n-    template <typename T>\n-    void resize(Attribute & attribute, size_t added_rows);\n     void resize(size_t added_rows);\n \n-    template <typename AttrType, typename ChildType, typename AncestorType>\n-    void isInAttrImpl(const AttrType & attr, const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n-    template <typename ChildType, typename AncestorType>\n-    void isInImpl(const ChildType & child_ids, const AncestorType & ancestor_ids, PaddedPODArray<UInt8> & out) const;\n+    StringRef copyKeyInArena(StringRef key);\n \n     const DictionaryStructure dict_struct;\n     const DictionarySourcePtr source_ptr;\n     const DictionaryLifetime dict_lifetime;\n     const bool require_nonempty;\n-    const bool sparse;\n \n-    std::map<std::string, size_t> attribute_index_by_name;\n     std::vector<Attribute> attributes;\n-    const Attribute * hierarchical_attribute = nullptr;\n \n     size_t bytes_allocated = 0;\n     size_t element_count = 0;\n     size_t bucket_count = 0;\n     mutable std::atomic<size_t> query_count{0};\n \n+    /// TODO: Remove\n     BlockPtr saved_block;\n+    Arena complex_key_arena;\n };\n \n+extern template class HashedDictionary<DictionaryKeyType::simple, false>;\n+extern template class HashedDictionary<DictionaryKeyType::simple, true>;\n+\n+extern template class HashedDictionary<DictionaryKeyType::complex, false>;\n+extern template class HashedDictionary<DictionaryKeyType::complex, true>;\n+\n }\ndiff --git a/src/Dictionaries/HierarchyDictionariesUtils.cpp b/src/Dictionaries/HierarchyDictionariesUtils.cpp\nnew file mode 100644\nindex 000000000000..fffe0d30e0e2\n--- /dev/null\n+++ b/src/Dictionaries/HierarchyDictionariesUtils.cpp\n@@ -0,0 +1,156 @@\n+#include \"HierarchyDictionariesUtils.h\"\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int UNSUPPORTED_METHOD;\n+}\n+\n+namespace\n+{\n+    /** In case of cache or direct dictionary we does not have structure with child to parent representation.\n+      * This function build such structure calling getColumn for initial keys to request and for next keys in hierarchy,\n+      * until all keys are requested or result key is null value.\n+      * To distinguish null value key and key that is not present in dictionary, we use special default value column\n+      * with max UInt64 value, if result column key has such value we assume that current key is not presented in dictionary storage.\n+      */\n+    HashMap<UInt64, UInt64> getChildToParentHierarchyMapImpl(\n+        const IDictionary * dictionary,\n+        const DictionaryAttribute & hierarchical_attribute,\n+        const PaddedPODArray<UInt64> & initial_keys_to_request,\n+        const DataTypePtr & key_type)\n+    {\n+        UInt64 null_value = hierarchical_attribute.null_value.get<UInt64>();\n+\n+        ColumnPtr key_to_request_column = ColumnVector<UInt64>::create();\n+        auto * key_to_request_column_typed = static_cast<ColumnVector<UInt64> *>(key_to_request_column->assumeMutable().get());\n+\n+        UInt64 key_not_in_storage_value = std::numeric_limits<UInt64>::max();\n+        ColumnPtr key_not_in_storage_default_value_column = ColumnVector<UInt64>::create(initial_keys_to_request.size(), key_not_in_storage_value);\n+\n+        PaddedPODArray<UInt64> & keys_to_request = key_to_request_column_typed->getData();\n+        keys_to_request.assign(initial_keys_to_request);\n+\n+        PaddedPODArray<UInt64> next_keys_to_request;\n+        HashSet<UInt64> already_requested_keys;\n+\n+        HashMap<UInt64, UInt64> child_to_parent_key;\n+\n+        while (!keys_to_request.empty())\n+        {\n+            child_to_parent_key.reserve(child_to_parent_key.size() + keys_to_request.size());\n+\n+            auto parent_key_column = dictionary->getColumn(\n+                hierarchical_attribute.name,\n+                hierarchical_attribute.type,\n+                {key_to_request_column},\n+                {key_type},\n+                key_not_in_storage_default_value_column);\n+\n+            const auto * parent_key_column_typed = checkAndGetColumn<ColumnVector<UInt64>>(*parent_key_column);\n+            if (!parent_key_column_typed)\n+                throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                    \"Parent key column should be UInt64. Actual ({})\",\n+                    hierarchical_attribute.type->getName());\n+\n+            const auto & parent_keys = parent_key_column_typed->getData();\n+            next_keys_to_request.clear();\n+\n+            for (size_t i = 0; i < keys_to_request.size(); ++i)\n+            {\n+                auto key = keys_to_request[i];\n+                auto parent_key = parent_keys[i];\n+\n+                if (parent_key == key_not_in_storage_value)\n+                    continue;\n+\n+                child_to_parent_key[key] = parent_key;\n+\n+                if (parent_key == null_value ||\n+                    already_requested_keys.find(parent_key) != nullptr)\n+                    continue;\n+\n+                already_requested_keys.insert(parent_key);\n+                next_keys_to_request.emplace_back(parent_key);\n+            }\n+\n+            keys_to_request.clear();\n+            keys_to_request.assign(next_keys_to_request);\n+        }\n+\n+        return child_to_parent_key;\n+    }\n+}\n+\n+ColumnPtr getKeysHierarchyDefaultImplementation(const IDictionary * dictionary, ColumnPtr key_column, const DataTypePtr & key_type)\n+{\n+    key_column = key_column->convertToFullColumnIfConst();\n+    const auto * key_column_typed = checkAndGetColumn<ColumnVector<UInt64>>(*key_column);\n+    if (!key_column_typed)\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Key column should be UInt64\");\n+\n+    const auto & dictionary_structure = dictionary->getStructure();\n+    size_t hierarchical_attribute_index = *dictionary_structure.hierarchical_attribute_index;\n+    const auto & hierarchical_attribute = dictionary_structure.attributes[hierarchical_attribute_index];\n+\n+    const PaddedPODArray<UInt64> & requested_keys = key_column_typed->getData();\n+    HashMap<UInt64, UInt64> key_to_parent_key = getChildToParentHierarchyMapImpl(dictionary, hierarchical_attribute, requested_keys, key_type);\n+\n+    auto is_key_valid_func = [&](auto & key) { return key_to_parent_key.find(key) != nullptr; };\n+\n+    auto get_parent_key_func = [&](auto & key)\n+    {\n+        auto it = key_to_parent_key.find(key);\n+        std::optional<UInt64> result = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n+        return result;\n+    };\n+\n+    UInt64 null_value = hierarchical_attribute.null_value.get<UInt64>();\n+\n+    auto dictionary_hierarchy_array = getKeysHierarchyArray(requested_keys, null_value, is_key_valid_func, get_parent_key_func);\n+    return dictionary_hierarchy_array;\n+}\n+\n+ColumnUInt8::Ptr getKeysIsInHierarchyDefaultImplementation(\n+    const IDictionary * dictionary,\n+    ColumnPtr key_column,\n+    ColumnPtr in_key_column,\n+    const DataTypePtr & key_type)\n+{\n+    key_column = key_column->convertToFullColumnIfConst();\n+    in_key_column = in_key_column->convertToFullColumnIfConst();\n+\n+    const auto * key_column_typed = checkAndGetColumn<ColumnVector<UInt64>>(*key_column);\n+    if (!key_column_typed)\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Key column should be UInt64\");\n+\n+    const auto * in_key_column_typed = checkAndGetColumn<ColumnVector<UInt64>>(*in_key_column);\n+    if (!in_key_column_typed)\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Key column should be UInt64\");\n+\n+    const auto & dictionary_structure = dictionary->getStructure();\n+    size_t hierarchical_attribute_index = *dictionary_structure.hierarchical_attribute_index;\n+    const auto & hierarchical_attribute = dictionary_structure.attributes[hierarchical_attribute_index];\n+\n+    const PaddedPODArray<UInt64> & requested_keys = key_column_typed->getData();\n+    HashMap<UInt64, UInt64> key_to_parent_key = getChildToParentHierarchyMapImpl(dictionary, hierarchical_attribute, requested_keys, key_type);\n+\n+    auto is_key_valid_func = [&](auto & key) { return key_to_parent_key.find(key) != nullptr; };\n+\n+    auto get_parent_key_func = [&](auto & key)\n+    {\n+        auto it = key_to_parent_key.find(key);\n+        std::optional<UInt64> result = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n+        return result;\n+    };\n+\n+    UInt64 null_value = hierarchical_attribute.null_value.get<UInt64>();\n+    const auto & in_keys = in_key_column_typed->getData();\n+\n+    auto result = getKeysIsInHierarchyColumn(requested_keys, in_keys, null_value, is_key_valid_func, get_parent_key_func);\n+    return result;\n+}\n+\n+}\ndiff --git a/src/Dictionaries/HierarchyDictionariesUtils.h b/src/Dictionaries/HierarchyDictionariesUtils.h\nnew file mode 100644\nindex 000000000000..8b2fe6ef08eb\n--- /dev/null\n+++ b/src/Dictionaries/HierarchyDictionariesUtils.h\n@@ -0,0 +1,467 @@\n+#pragma once\n+\n+#include <common/types.h>\n+#include <Common/PODArray.h>\n+#include <Common/HashTable/HashMap.h>\n+#include <Common/HashTable/HashSet.h>\n+\n+#include <Columns/IColumn.h>\n+#include <Columns/ColumnVector.h>\n+#include <Columns/ColumnArray.h>\n+\n+#include <Dictionaries/IDictionary.h>\n+\n+namespace DB\n+{\n+\n+namespace detail\n+{\n+    template <typename KeyType>\n+    struct ElementsAndOffsets\n+    {\n+        PaddedPODArray<KeyType> elements;\n+        PaddedPODArray<IColumn::Offset> offsets;\n+    };\n+\n+    template <typename T>\n+    struct IsKeyValidFuncInterface\n+    {\n+        bool operator()(T key [[maybe_unused]]) { return false; }\n+    };\n+\n+    template <typename T>\n+    struct GetParentKeyFuncInterface\n+    {\n+        std::optional<T> operator()(T key [[maybe_unused]]) { return {}; }\n+    };\n+\n+    /** Calculate hierarchy for keys iterating the hierarchy from child to parent using get_parent_key_func provided by client.\n+      * Hierarchy iteration is stopped if key equals null value, get_parent_key_func returns null optional, or hierarchy depth\n+      * greater or equal than DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH.\n+      * IsKeyValidFunc used for each input hierarchy key, if it returns false result hierarchy for that key will have size 0.\n+      * Hierarchy result is ElementsAndOffsets structure, for each element there is hierarchy array,\n+      * with size offset[element_index] - (element_index > 0 ? offset[element_index - 1] : 0).\n+      *\n+      * Example:\n+      * id  parent_id\n+      * 1   0\n+      * 2   1\n+      * 3   1\n+      * 4   2\n+      *\n+      * If hierarchy_null_value will be 0. Requested keys [1, 2, 3, 4, 5].\n+      * Result: [1], [2, 1], [3, 1], [4, 2, 1], []\n+      * Elements: [1, 2, 1, 3, 1, 4, 2, 1]\n+      * Offsets: [1, 3, 5, 8, 8]\n+      */\n+    template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n+    ElementsAndOffsets<KeyType> getHierarchy(\n+        const PaddedPODArray<KeyType> & keys,\n+        const KeyType & hierarchy_null_value,\n+        IsKeyValidFunc && is_key_valid_func,\n+        GetParentKeyFunc && get_parent_key_func)\n+    {\n+        size_t hierarchy_keys_size = keys.size();\n+\n+        PaddedPODArray<KeyType> elements;\n+        elements.reserve(hierarchy_keys_size);\n+\n+        PaddedPODArray<IColumn::Offset> offsets;\n+        offsets.reserve(hierarchy_keys_size);\n+\n+        struct OffsetInArray\n+        {\n+            size_t offset_index;\n+            size_t array_element_offset;\n+        };\n+\n+        HashMap<KeyType, OffsetInArray> already_processes_keys_to_offset;\n+        already_processes_keys_to_offset.reserve(hierarchy_keys_size);\n+\n+        for (size_t i = 0; i < hierarchy_keys_size; ++i)\n+        {\n+            auto hierarchy_key = keys[i];\n+            size_t current_hierarchy_depth = 0;\n+\n+            bool is_key_valid = std::forward<IsKeyValidFunc>(is_key_valid_func)(hierarchy_key);\n+\n+            if (!is_key_valid)\n+            {\n+                offsets.emplace_back(elements.size());\n+                continue;\n+            }\n+\n+            while (true)\n+            {\n+                const auto * it = already_processes_keys_to_offset.find(hierarchy_key);\n+\n+                if (it)\n+                {\n+                    const auto & index = it->getMapped();\n+\n+                    size_t offset = index.offset_index;\n+\n+                    bool is_loop = (offset == offsets.size());\n+\n+                    if (unlikely(is_loop))\n+                        break;\n+\n+                    size_t array_element_offset = index.array_element_offset;\n+\n+                    size_t previous_offset_size = offset > 0 ? offsets[offset - 1] : 0;\n+                    size_t start_index = previous_offset_size + array_element_offset;\n+                    size_t end_index = offsets[offset];\n+\n+                    elements.insertFromItself(elements.begin() + start_index, elements.begin() + end_index);\n+                    break;\n+                }\n+\n+                if (hierarchy_key == hierarchy_null_value || current_hierarchy_depth >= DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH)\n+                    break;\n+\n+                already_processes_keys_to_offset[hierarchy_key] = {offsets.size(), current_hierarchy_depth};\n+                elements.emplace_back(hierarchy_key);\n+                ++current_hierarchy_depth;\n+\n+                std::optional<KeyType> parent_key = std::forward<GetParentKeyFunc>(get_parent_key_func)(hierarchy_key);\n+\n+                if (!parent_key.has_value())\n+                    break;\n+\n+                hierarchy_key = *parent_key;\n+            }\n+\n+            offsets.emplace_back(elements.size());\n+        }\n+\n+        ElementsAndOffsets<KeyType> result = {std::move(elements), std::move(offsets)};\n+\n+        return result;\n+    }\n+\n+    /** Returns array with UInt8 represent if key from in_keys array is in hierarchy of key from keys column.\n+      * If value in result array is 1 that means key from in_keys array is in hierarchy of key from\n+      * keys array with same index, 0 therwise.\n+      * For getting hierarchy implementation uses getKeysHierarchy function.\n+      *\n+      * Not: keys size must be equal to in_keys_size.\n+      */\n+    template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n+    PaddedPODArray<UInt8> getIsInHierarchy(\n+        const PaddedPODArray<KeyType> & keys,\n+        const PaddedPODArray<KeyType> & in_keys,\n+        const KeyType & hierarchy_null_value,\n+        IsKeyValidFunc && is_key_valid_func,\n+        GetParentKeyFunc && get_parent_func)\n+    {\n+        assert(keys.size() == in_keys.size());\n+\n+        PaddedPODArray<UInt8> result;\n+        result.resize_fill(keys.size());\n+\n+        detail::ElementsAndOffsets<KeyType> hierarchy = detail::getHierarchy(\n+            keys,\n+            hierarchy_null_value,\n+            std::forward<IsKeyValidFunc>(is_key_valid_func),\n+            std::forward<GetParentKeyFunc>(get_parent_func));\n+\n+        auto & offsets = hierarchy.offsets;\n+        auto & elements = hierarchy.elements;\n+\n+        for (size_t i = 0; i < offsets.size(); ++i)\n+        {\n+            size_t i_elements_start = i > 0 ? offsets[i - 1] : 0;\n+            size_t i_elements_end = offsets[i];\n+\n+            auto & key_to_find = in_keys[i];\n+\n+            const auto * begin = elements.begin() + i_elements_start;\n+            const auto * end = elements.begin() + i_elements_end;\n+\n+            const auto * it = std::find(begin, end, key_to_find);\n+\n+            bool contains_key = (it != end);\n+            result[i] = contains_key;\n+        }\n+\n+        return result;\n+    }\n+\n+    struct GetAllDescendantsStrategy { size_t level = 0; };\n+    struct GetDescendantsAtSpecificLevelStrategy { size_t level = 0; };\n+\n+    /** Get descendants for keys iterating the hierarchy from parent to child using parent_to_child hash map provided by client.\n+      * GetAllDescendantsStrategy get all descendants for key\n+      * GetDescendantsAtSpecificLevelStrategy get descendants only for specific hierarchy level.\n+      * Hierarchy result is ElementsAndOffsets structure, for each element there is descendants array,\n+      * with size offset[element_index] - (element_index > 0 ? offset[element_index - 1] : 0).\n+      *\n+      * Example:\n+      * id  parent_id\n+      * 1   0\n+      * 2   1\n+      * 3   1\n+      * 4   2\n+      *\n+      * Example. Strategy GetAllDescendantsStrategy.\n+      * Requested keys [0, 1, 2, 3, 4].\n+      * Result: [1, 2, 3, 4], [2, 2, 4], [4], [], []\n+      * Elements: [1, 2, 3, 4, 2, 3, 4, 4]\n+      * Offsets: [4, 7, 8, 8, 8]\n+      *\n+      * Example. Strategy GetDescendantsAtSpecificLevelStrategy with level 1.\n+      * Requested keys [0, 1, 2, 3, 4].\n+      * Result: [1], [2, 3], [4], [], [];\n+      * Offsets: [1, 3, 4, 4, 4];\n+      */\n+    template <typename KeyType, typename Strategy>\n+    ElementsAndOffsets<KeyType> getDescendants(\n+        const PaddedPODArray<KeyType> & keys,\n+        const HashMap<KeyType, PaddedPODArray<KeyType>> & parent_to_child,\n+        Strategy strategy)\n+    {\n+        /// If strategy is GetAllDescendantsStrategy we try to cache and later reuse previously calculated descendants.\n+        /// If strategy is GetDescendantsAtSpecificLevelStrategy we does not use cache strategy.\n+        size_t keys_size = keys.size();\n+\n+        PaddedPODArray<KeyType> descendants;\n+        descendants.reserve(keys_size);\n+\n+        PaddedPODArray<IColumn::Offset> descendants_offsets;\n+        descendants_offsets.reserve(keys_size);\n+\n+        struct Range\n+        {\n+            size_t start_index;\n+            size_t end_index;\n+        };\n+\n+        static constexpr Int64 key_range_requires_update = -1;\n+        HashMap<KeyType, Range> already_processed_keys_to_range [[maybe_unused]];\n+\n+        if constexpr (std::is_same_v<Strategy, GetAllDescendantsStrategy>)\n+            already_processed_keys_to_range.reserve(keys_size);\n+\n+        struct KeyAndDepth\n+        {\n+            KeyType key;\n+            Int64 depth;\n+        };\n+\n+        HashSet<KeyType> already_processed_keys_during_loop;\n+        already_processed_keys_during_loop.reserve(keys_size);\n+\n+        PaddedPODArray<KeyAndDepth> next_keys_to_process_stack;\n+        next_keys_to_process_stack.reserve(keys_size);\n+\n+        Int64 level = static_cast<Int64>(strategy.level);\n+\n+        for (size_t i = 0; i < keys_size; ++i)\n+        {\n+            const KeyType & requested_key = keys[i];\n+\n+            if (parent_to_child.find(requested_key) == nullptr)\n+            {\n+                descendants_offsets.emplace_back(descendants.size());\n+                continue;\n+            }\n+\n+            next_keys_to_process_stack.emplace_back(KeyAndDepth{requested_key, 0});\n+\n+            /** To cache range for key without recursive function calls and custom stack we put special\n+              * signaling value on stack key_range_requires_update.\n+              * When we pop such value from stack that means processing descendants for key is finished\n+              * and we can update range with end_index.\n+              */\n+            while (!next_keys_to_process_stack.empty())\n+            {\n+                KeyAndDepth key_to_process = next_keys_to_process_stack.back();\n+\n+                KeyType key = key_to_process.key;\n+                Int64 depth = key_to_process.depth;\n+                next_keys_to_process_stack.pop_back();\n+\n+                if constexpr (std::is_same_v<Strategy, GetAllDescendantsStrategy>)\n+                {\n+                    /// Update end_index for key\n+                    if (depth == key_range_requires_update)\n+                    {\n+                        auto * it = already_processed_keys_to_range.find(key);\n+                        assert(it);\n+\n+                        auto & range_to_update = it->getMapped();\n+                        range_to_update.end_index = descendants.size();\n+                        continue;\n+                    }\n+                }\n+\n+                if (unlikely(already_processed_keys_during_loop.find(key) != nullptr))\n+                {\n+                    next_keys_to_process_stack.clear();\n+                    break;\n+                }\n+\n+                if constexpr (std::is_same_v<Strategy, GetAllDescendantsStrategy>)\n+                {\n+                    const auto * already_processed_it = already_processed_keys_to_range.find(key);\n+\n+                    if (already_processed_it)\n+                    {\n+                        Range range = already_processed_it->getMapped();\n+\n+                        if (unlikely(range.start_index > range.end_index))\n+                        {\n+                            /// Broken range because there was loop\n+                            already_processed_keys_to_range.erase(key);\n+                        }\n+                        else\n+                        {\n+                            auto insert_start_iterator = descendants.begin() + range.start_index;\n+                            auto insert_end_iterator = descendants.begin() + range.end_index;\n+                            descendants.insertFromItself(insert_start_iterator, insert_end_iterator);\n+                            continue;\n+                        }\n+                    }\n+                }\n+\n+                const auto * it = parent_to_child.find(key);\n+\n+                if (!it || depth >= DBMS_HIERARCHICAL_DICTIONARY_MAX_DEPTH)\n+                    continue;\n+\n+                if constexpr (std::is_same_v<Strategy, GetDescendantsAtSpecificLevelStrategy>)\n+                {\n+                    if (depth > level)\n+                        continue;\n+                }\n+\n+                if constexpr (std::is_same_v<Strategy, GetAllDescendantsStrategy>)\n+                {\n+                    /// Put special signaling value on stack and update cache with range start\n+                    size_t range_start_index = descendants.size();\n+                    already_processed_keys_to_range[key].start_index = range_start_index;\n+                    next_keys_to_process_stack.emplace_back(KeyAndDepth{key, key_range_requires_update});\n+                }\n+\n+                already_processed_keys_during_loop.insert(key);\n+\n+                ++depth;\n+\n+                const auto & children = it->getMapped();\n+\n+                for (auto child_key : children)\n+                {\n+                    /// In case of GetAllDescendantsStrategy we add any descendant to result array\n+                    /// If strategy is GetDescendantsAtSpecificLevelStrategy we require depth == level\n+                    if (std::is_same_v<Strategy, GetAllDescendantsStrategy> || depth == level)\n+                        descendants.emplace_back(child_key);\n+\n+                    next_keys_to_process_stack.emplace_back(KeyAndDepth{child_key, depth});\n+                }\n+            }\n+\n+            already_processed_keys_during_loop.clear();\n+\n+            descendants_offsets.emplace_back(descendants.size());\n+        }\n+\n+        ElementsAndOffsets<KeyType> result = {std::move(descendants), std::move(descendants_offsets)};\n+        return result;\n+    }\n+\n+    /// Converts ElementAndOffsets structure into ArrayColumn\n+    template<typename KeyType>\n+    ColumnPtr convertElementsAndOffsetsIntoArray(ElementsAndOffsets<KeyType> && elements_and_offsets)\n+    {\n+        auto elements_column = ColumnVector<KeyType>::create();\n+        elements_column->getData() = std::move(elements_and_offsets.elements);\n+\n+        auto offsets_column = ColumnVector<IColumn::Offset>::create();\n+        offsets_column->getData() = std::move(elements_and_offsets.offsets);\n+\n+        auto column_array = ColumnArray::create(std::move(elements_column), std::move(offsets_column));\n+\n+        return column_array;\n+    }\n+}\n+\n+/// Returns hierarchy array column for keys\n+template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n+ColumnPtr getKeysHierarchyArray(\n+    const PaddedPODArray<KeyType> & keys,\n+    const KeyType & hierarchy_null_value,\n+    IsKeyValidFunc && is_key_valid_func,\n+    GetParentKeyFunc && get_parent_func)\n+{\n+    auto elements_and_offsets = detail::getHierarchy(\n+        keys,\n+        hierarchy_null_value,\n+        std::forward<IsKeyValidFunc>(is_key_valid_func),\n+        std::forward<GetParentKeyFunc>(get_parent_func));\n+\n+    return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n+}\n+\n+/// Returns is in hierarchy column for keys\n+template <typename KeyType, typename IsKeyValidFunc, typename GetParentKeyFunc>\n+ColumnUInt8::Ptr getKeysIsInHierarchyColumn(\n+    const PaddedPODArray<KeyType> & hierarchy_keys,\n+    const PaddedPODArray<KeyType> & hierarchy_in_keys,\n+    const KeyType & hierarchy_null_value,\n+    IsKeyValidFunc && is_key_valid_func,\n+    GetParentKeyFunc && get_parent_func)\n+{\n+    auto is_in_hierarchy_data = detail::getIsInHierarchy(\n+        hierarchy_keys,\n+        hierarchy_in_keys,\n+        hierarchy_null_value,\n+        std::forward<IsKeyValidFunc>(is_key_valid_func),\n+        std::forward<GetParentKeyFunc>(get_parent_func));\n+\n+    auto result = ColumnUInt8::create();\n+    result->getData() = std::move(is_in_hierarchy_data);\n+\n+    return result;\n+}\n+\n+/// Returns descendants array column for keys\n+template <typename KeyType>\n+ColumnPtr getKeysDescendantsArray(\n+    const PaddedPODArray<KeyType> & requested_keys,\n+    const HashMap<KeyType, PaddedPODArray<KeyType>> & parent_to_child,\n+    size_t level)\n+{\n+    if (level == 0)\n+    {\n+        detail::GetAllDescendantsStrategy strategy { .level = level };\n+        auto elements_and_offsets = detail::getDescendants(requested_keys, parent_to_child, strategy);\n+        return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n+    }\n+    else\n+    {\n+        detail::GetDescendantsAtSpecificLevelStrategy strategy { .level = level };\n+        auto elements_and_offsets = detail::getDescendants(requested_keys, parent_to_child, strategy);\n+        return detail::convertElementsAndOffsetsIntoArray(std::move(elements_and_offsets));\n+    }\n+}\n+\n+/** Default getHierarchy implementation for dictionaries that does not have structure with child to parent representation.\n+  * Implementation will build such structure with getColumn calls, and then getHierarchy for such structure.\n+  * Returns ColumnArray with hierarchy arrays for keys from key_column.\n+  */\n+ColumnPtr getKeysHierarchyDefaultImplementation(\n+    const IDictionary * dictionary,\n+    ColumnPtr key_column,\n+    const DataTypePtr & key_type);\n+\n+/** Default isInHierarchy implementation for dictionaries that does not have structure with child to parent representation.\n+  * Implementation will build such structure with getColumn calls, and then getHierarchy for such structure.\n+  * Returns UInt8 column if key from in_key_column is in key hierarchy from key_column.\n+  */\n+ColumnUInt8::Ptr getKeysIsInHierarchyDefaultImplementation(\n+    const IDictionary * dictionary,\n+    ColumnPtr key_column,\n+    ColumnPtr in_key_column,\n+    const DataTypePtr & key_type);\n+\n+}\ndiff --git a/src/Dictionaries/IDictionary.h b/src/Dictionaries/IDictionary.h\nindex 4d51747a6523..a74453124099 100644\n--- a/src/Dictionaries/IDictionary.h\n+++ b/src/Dictionaries/IDictionary.h\n@@ -24,8 +24,8 @@ namespace ErrorCodes\n     extern const int NOT_IMPLEMENTED;\n }\n \n-struct IDictionaryBase;\n-using DictionaryPtr = std::unique_ptr<IDictionaryBase>;\n+struct IDictionary;\n+using DictionaryPtr = std::unique_ptr<IDictionary>;\n \n /** DictionaryKeyType provides IDictionary client information about\n   * which key type is supported by dictionary.\n@@ -47,13 +47,11 @@ enum class DictionaryKeyType\n /**\n  * Base class for Dictionaries implementation.\n  */\n-struct IDictionaryBase : public IExternalLoadable\n+struct IDictionary : public IExternalLoadable\n {\n-    using Key = UInt64;\n-\n-    IDictionaryBase(const StorageID & dict_id_)\n-    : dict_id(dict_id_)\n-    , full_name(dict_id.getInternalDictionaryName())\n+    explicit IDictionary(const StorageID & dictionary_id_)\n+    : dictionary_id(dictionary_id_)\n+    , full_name(dictionary_id.getInternalDictionaryName())\n     {\n     }\n \n@@ -61,14 +59,14 @@ struct IDictionaryBase : public IExternalLoadable\n     StorageID getDictionaryID() const\n     {\n         std::lock_guard lock{name_mutex};\n-        return dict_id;\n+        return dictionary_id;\n     }\n \n     void updateDictionaryName(const StorageID & new_name) const\n     {\n         std::lock_guard lock{name_mutex};\n-        assert(new_name.uuid == dict_id.uuid && dict_id.uuid != UUIDHelpers::Nil);\n-        dict_id = new_name;\n+        assert(new_name.uuid == dictionary_id.uuid && dictionary_id.uuid != UUIDHelpers::Nil);\n+        dictionary_id = new_name;\n     }\n \n     const std::string & getLoadableName() const override final { return getFullName(); }\n@@ -80,8 +78,9 @@ struct IDictionaryBase : public IExternalLoadable\n \n     std::string getDatabaseOrNoDatabaseTag() const\n     {\n-        if (!dict_id.database_name.empty())\n-            return dict_id.database_name;\n+        if (!dictionary_id.database_name.empty())\n+            return dictionary_id.database_name;\n+\n         return NO_DATABASE_TAG;\n     }\n \n@@ -159,74 +158,65 @@ struct IDictionaryBase : public IExternalLoadable\n         const Columns & key_columns,\n         const DataTypes & key_types) const = 0;\n \n+    virtual bool hasHierarchy() const { return false; }\n+\n+    virtual ColumnPtr getHierarchy(\n+        ColumnPtr key_column [[maybe_unused]],\n+        const DataTypePtr & key_type [[maybe_unused]]) const\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Method getHierarchy is not supported for {} dictionary.\",\n+                        getDictionaryID().getNameForLogs());\n+    }\n+\n+    virtual ColumnUInt8::Ptr isInHierarchy(\n+        ColumnPtr key_column [[maybe_unused]],\n+        ColumnPtr in_key_column [[maybe_unused]],\n+        const DataTypePtr & key_type [[maybe_unused]]) const\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Method isInHierarchy is not supported for {} dictionary.\",\n+                        getDictionaryID().getNameForLogs());\n+    }\n+\n+    virtual ColumnPtr getDescendants(\n+        ColumnPtr key_column [[maybe_unused]],\n+        const DataTypePtr & key_type [[maybe_unused]],\n+        size_t level [[maybe_unused]]) const\n+    {\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"Method getDescendants is not supported for {} dictionary.\",\n+                        getDictionaryID().getNameForLogs());\n+    }\n+\n     virtual BlockInputStreamPtr getBlockInputStream(const Names & column_names, size_t max_block_size) const = 0;\n \n     bool supportUpdates() const override { return true; }\n \n     bool isModified() const override\n     {\n-        auto source = getSource();\n+        const auto * source = getSource();\n         return source && source->isModified();\n     }\n \n     virtual std::exception_ptr getLastException() const { return {}; }\n \n-    std::shared_ptr<IDictionaryBase> shared_from_this()\n+    std::shared_ptr<IDictionary> shared_from_this()\n     {\n-        return std::static_pointer_cast<IDictionaryBase>(IExternalLoadable::shared_from_this());\n+        return std::static_pointer_cast<IDictionary>(IExternalLoadable::shared_from_this());\n     }\n \n-    std::shared_ptr<const IDictionaryBase> shared_from_this() const\n+    std::shared_ptr<const IDictionary> shared_from_this() const\n     {\n-        return std::static_pointer_cast<const IDictionaryBase>(IExternalLoadable::shared_from_this());\n+        return std::static_pointer_cast<const IDictionary>(IExternalLoadable::shared_from_this());\n     }\n \n private:\n     mutable std::mutex name_mutex;\n-    mutable StorageID dict_id;\n+    mutable StorageID dictionary_id;\n \n protected:\n     const String full_name;\n };\n \n-struct IDictionary : IDictionaryBase\n-{\n-    IDictionary(const StorageID & dict_id_) : IDictionaryBase(dict_id_) {}\n-\n-    virtual bool hasHierarchy() const = 0;\n-\n-    virtual void toParent(const PaddedPODArray<Key> & ids, PaddedPODArray<Key> & out) const = 0;\n-\n-    /// TODO: Rewrite\n-    /// Methods for hierarchy.\n-\n-    virtual void isInVectorVector(\n-        const PaddedPODArray<Key> & /*child_ids*/, const PaddedPODArray<Key> & /*ancestor_ids*/, PaddedPODArray<UInt8> & /*out*/) const\n-    {\n-        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n-                        \"Hierarchy is not supported for {} dictionary.\", getDictionaryID().getNameForLogs());\n-    }\n-\n-    virtual void\n-    isInVectorConstant(const PaddedPODArray<Key> & /*child_ids*/, const Key /*ancestor_id*/, PaddedPODArray<UInt8> & /*out*/) const\n-    {\n-        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n-                        \"Hierarchy is not supported for {} dictionary.\", getDictionaryID().getNameForLogs());\n-    }\n-\n-    virtual void\n-    isInConstantVector(const Key /*child_id*/, const PaddedPODArray<Key> & /*ancestor_ids*/, PaddedPODArray<UInt8> & /*out*/) const\n-    {\n-        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n-                        \"Hierarchy is not supported for {} dictionary.\", getDictionaryID().getNameForLogs());\n-    }\n-\n-    void isInConstantConstant(const Key child_id, const Key ancestor_id, UInt8 & out) const\n-    {\n-        PaddedPODArray<UInt8> out_arr(1);\n-        isInVectorConstant(PaddedPODArray<Key>(1, child_id), ancestor_id, out_arr);\n-        out = out_arr[0];\n-    }\n-};\n-\n }\ndiff --git a/src/Dictionaries/IPAddressDictionary.cpp b/src/Dictionaries/IPAddressDictionary.cpp\nindex 4b51d94f0d8e..d66c285bc42a 100644\n--- a/src/Dictionaries/IPAddressDictionary.cpp\n+++ b/src/Dictionaries/IPAddressDictionary.cpp\n@@ -195,7 +195,7 @@ IPAddressDictionary::IPAddressDictionary(\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_)\n-    : IDictionaryBase(dict_id_)\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -804,9 +804,6 @@ static auto keyViewGetter()\n \n BlockInputStreamPtr IPAddressDictionary::getBlockInputStream(const Names & column_names, size_t max_block_size) const\n {\n-    using BlockInputStreamType = DictionaryBlockInputStream<UInt64>;\n-\n-\n     const bool is_ipv4 = std::get_if<IPv4Container>(&ip_column) != nullptr;\n \n     auto get_keys = [is_ipv4](const Columns & columns, const std::vector<DictionaryAttribute> & dict_attributes)\n@@ -827,12 +824,12 @@ BlockInputStreamPtr IPAddressDictionary::getBlockInputStream(const Names & colum\n     if (is_ipv4)\n     {\n         auto get_view = keyViewGetter<ColumnVector<UInt32>, true>();\n-        return std::make_shared<BlockInputStreamType>(\n+        return std::make_shared<DictionaryBlockInputStream>(\n             shared_from_this(), max_block_size, getKeyColumns(), column_names, std::move(get_keys), std::move(get_view));\n     }\n \n     auto get_view = keyViewGetter<ColumnFixedString, false>();\n-    return std::make_shared<BlockInputStreamType>(\n+    return std::make_shared<DictionaryBlockInputStream>(\n         shared_from_this(), max_block_size, getKeyColumns(), column_names, std::move(get_keys), std::move(get_view));\n }\n \ndiff --git a/src/Dictionaries/IPAddressDictionary.h b/src/Dictionaries/IPAddressDictionary.h\nindex dcfb26c3c964..cf79caa75fcd 100644\n--- a/src/Dictionaries/IPAddressDictionary.h\n+++ b/src/Dictionaries/IPAddressDictionary.h\n@@ -20,7 +20,7 @@\n \n namespace DB\n {\n-class IPAddressDictionary final : public IDictionaryBase\n+class IPAddressDictionary final : public IDictionary\n {\n public:\n     IPAddressDictionary(\ndiff --git a/src/Dictionaries/PolygonDictionary.cpp b/src/Dictionaries/PolygonDictionary.cpp\nindex 04559d701c9e..7046741b3a05 100644\n--- a/src/Dictionaries/PolygonDictionary.cpp\n+++ b/src/Dictionaries/PolygonDictionary.cpp\n@@ -30,7 +30,7 @@ IPolygonDictionary::IPolygonDictionary(\n         const DictionaryLifetime dict_lifetime_,\n         InputType input_type_,\n         PointType point_type_)\n-        : IDictionaryBase(dict_id_)\n+        : IDictionary(dict_id_)\n         , dict_struct(dict_struct_)\n         , source_ptr(std::move(source_ptr_))\n         , dict_lifetime(dict_lifetime_)\n@@ -142,7 +142,6 @@ ColumnPtr IPolygonDictionary::getColumn(\n         callOnDictionaryAttributeType(attribute.underlying_type, type_call);\n     }\n \n-\n     query_count.fetch_add(requested_key_points.size(), std::memory_order_relaxed);\n \n     return result;\ndiff --git a/src/Dictionaries/PolygonDictionary.h b/src/Dictionaries/PolygonDictionary.h\nindex b82a8b2928ff..5974e6461a71 100644\n--- a/src/Dictionaries/PolygonDictionary.h\n+++ b/src/Dictionaries/PolygonDictionary.h\n@@ -24,7 +24,7 @@ namespace bg = boost::geometry;\n   * An implementation should inherit from this base class and preprocess the data upon construction if needed.\n   * It must override the find method of this class which retrieves the polygon containing a single point.\n   */\n-class IPolygonDictionary : public IDictionaryBase\n+class IPolygonDictionary : public IDictionary\n {\n public:\n     /** Controls the different types of polygons allowed as input.\ndiff --git a/src/Dictionaries/RangeDictionaryBlockInputStream.h b/src/Dictionaries/RangeDictionaryBlockInputStream.h\nindex 6531f5cba9d3..499eea7152f2 100644\n--- a/src/Dictionaries/RangeDictionaryBlockInputStream.h\n+++ b/src/Dictionaries/RangeDictionaryBlockInputStream.h\n@@ -24,7 +24,7 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n     using Key = UInt64;\n \n     RangeDictionaryBlockInputStream(\n-        std::shared_ptr<const IDictionaryBase> dictionary,\n+        std::shared_ptr<const IDictionary> dictionary,\n         size_t max_block_size,\n         const Names & column_names,\n         PaddedPODArray<Key> && ids_to_fill,\n@@ -49,7 +49,7 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n         const PaddedPODArray<RangeType> & block_start_dates,\n         const PaddedPODArray<RangeType> & block_end_dates) const;\n \n-    std::shared_ptr<const IDictionaryBase> dictionary;\n+    std::shared_ptr<const IDictionary> dictionary;\n     NameSet column_names;\n     PaddedPODArray<Key> ids;\n     PaddedPODArray<RangeType> start_dates;\n@@ -59,7 +59,7 @@ class RangeDictionaryBlockInputStream : public DictionaryBlockInputStreamBase\n \n template <typename RangeType>\n RangeDictionaryBlockInputStream<RangeType>::RangeDictionaryBlockInputStream(\n-    std::shared_ptr<const IDictionaryBase> dictionary_,\n+    std::shared_ptr<const IDictionary> dictionary_,\n     size_t max_block_size_,\n     const Names & column_names_,\n     PaddedPODArray<Key> && ids_,\ndiff --git a/src/Dictionaries/RangeHashedDictionary.cpp b/src/Dictionaries/RangeHashedDictionary.cpp\nindex 4196d6ebd726..30395114a8e6 100644\n--- a/src/Dictionaries/RangeHashedDictionary.cpp\n+++ b/src/Dictionaries/RangeHashedDictionary.cpp\n@@ -76,7 +76,7 @@ RangeHashedDictionary::RangeHashedDictionary(\n     DictionarySourcePtr source_ptr_,\n     const DictionaryLifetime dict_lifetime_,\n     bool require_nonempty_)\n-    : IDictionaryBase(dict_id_)\n+    : IDictionary(dict_id_)\n     , dict_struct(dict_struct_)\n     , source_ptr{std::move(source_ptr_)}\n     , dict_lifetime(dict_lifetime_)\n@@ -185,10 +185,10 @@ ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns & key_columns, con\n     auto range_column_storage_type = std::make_shared<DataTypeInt64>();\n     auto range_column_updated = castColumnAccurate(column_to_cast, range_column_storage_type);\n \n-    PaddedPODArray<Key> key_backup_storage;\n+    PaddedPODArray<UInt64> key_backup_storage;\n     PaddedPODArray<RangeStorageType> range_backup_storage;\n \n-    const PaddedPODArray<Key> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n+    const PaddedPODArray<UInt64> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n     const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, range_column_updated, range_backup_storage);\n \n     const auto & attribute = attributes.front();\n@@ -213,7 +213,7 @@ ColumnUInt8::Ptr RangeHashedDictionary::hasKeys(const Columns & key_columns, con\n template <typename AttributeType>\n ColumnUInt8::Ptr RangeHashedDictionary::hasKeysImpl(\n     const Attribute & attribute,\n-    const PaddedPODArray<Key> & ids,\n+    const PaddedPODArray<UInt64> & ids,\n     const PaddedPODArray<RangeStorageType> & dates) const\n {\n     auto result = ColumnUInt8::create(ids.size());\n@@ -388,10 +388,10 @@ void RangeHashedDictionary::getItemsImpl(\n     ValueSetter && set_value,\n     DefaultValueExtractor & default_value_extractor) const\n {\n-    PaddedPODArray<Key> key_backup_storage;\n+    PaddedPODArray<UInt64> key_backup_storage;\n     PaddedPODArray<RangeStorageType> range_backup_storage;\n \n-    const PaddedPODArray<Key> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n+    const PaddedPODArray<UInt64> & ids = getColumnVectorData(this, key_columns[0], key_backup_storage);\n     const PaddedPODArray<RangeStorageType> & dates = getColumnVectorData(this, key_columns[1], range_backup_storage);\n \n     const auto & attr = *std::get<Ptr<AttributeType>>(attribute.maps);\n@@ -436,7 +436,7 @@ void RangeHashedDictionary::getItemsImpl(\n \n \n template <typename T>\n-void RangeHashedDictionary::setAttributeValueImpl(Attribute & attribute, const Key id, const Range & range, const Field & value)\n+void RangeHashedDictionary::setAttributeValueImpl(Attribute & attribute, const UInt64 id, const Range & range, const Field & value)\n {\n     using ValueType = std::conditional_t<std::is_same_v<T, String>, StringRef, T>;\n     auto & map = *std::get<Ptr<ValueType>>(attribute.maps);\n@@ -480,7 +480,7 @@ void RangeHashedDictionary::setAttributeValueImpl(Attribute & attribute, const K\n         map.insert({id, Values<ValueType>{std::move(value_to_insert)}});\n }\n \n-void RangeHashedDictionary::setAttributeValue(Attribute & attribute, const Key id, const Range & range, const Field & value)\n+void RangeHashedDictionary::setAttributeValue(Attribute & attribute, const UInt64 id, const Range & range, const Field & value)\n {\n     auto type_call = [&](const auto &dictionary_attribute_type)\n     {\n@@ -515,7 +515,7 @@ RangeHashedDictionary::getAttributeWithType(const std::string & attribute_name,\n \n template <typename RangeType>\n void RangeHashedDictionary::getIdsAndDates(\n-    PaddedPODArray<Key> & ids,\n+    PaddedPODArray<UInt64> & ids,\n     PaddedPODArray<RangeType> & start_dates,\n     PaddedPODArray<RangeType> & end_dates) const\n {\n@@ -536,7 +536,7 @@ void RangeHashedDictionary::getIdsAndDates(\n template <typename T, typename RangeType>\n void RangeHashedDictionary::getIdsAndDates(\n     const Attribute & attribute,\n-    PaddedPODArray<Key> & ids,\n+    PaddedPODArray<UInt64> & ids,\n     PaddedPODArray<RangeType> & start_dates,\n     PaddedPODArray<RangeType> & end_dates) const\n {\n@@ -567,7 +567,7 @@ void RangeHashedDictionary::getIdsAndDates(\n template <typename RangeType>\n BlockInputStreamPtr RangeHashedDictionary::getBlockInputStreamImpl(const Names & column_names, size_t max_block_size) const\n {\n-    PaddedPODArray<Key> ids;\n+    PaddedPODArray<UInt64> ids;\n     PaddedPODArray<RangeType> start_dates;\n     PaddedPODArray<RangeType> end_dates;\n     getIdsAndDates(ids, start_dates, end_dates);\ndiff --git a/src/Dictionaries/RangeHashedDictionary.h b/src/Dictionaries/RangeHashedDictionary.h\nindex f2b24e52dfc0..ca2a925df5e3 100644\n--- a/src/Dictionaries/RangeHashedDictionary.h\n+++ b/src/Dictionaries/RangeHashedDictionary.h\n@@ -16,7 +16,7 @@\n \n namespace DB\n {\n-class RangeHashedDictionary final : public IDictionaryBase\n+class RangeHashedDictionary final : public IDictionary\n {\n public:\n     RangeHashedDictionary(\n@@ -160,25 +160,25 @@ class RangeHashedDictionary final : public IDictionaryBase\n     template <typename AttributeType>\n     ColumnUInt8::Ptr hasKeysImpl(\n         const Attribute & attribute,\n-        const PaddedPODArray<Key> & ids,\n+        const PaddedPODArray<UInt64> & ids,\n         const PaddedPODArray<RangeStorageType> & dates) const;\n \n     template <typename T>\n-    static void setAttributeValueImpl(Attribute & attribute, const Key id, const Range & range, const Field & value);\n+    static void setAttributeValueImpl(Attribute & attribute, const UInt64 id, const Range & range, const Field & value);\n \n-    static void setAttributeValue(Attribute & attribute, const Key id, const Range & range, const Field & value);\n+    static void setAttributeValue(Attribute & attribute, const UInt64 id, const Range & range, const Field & value);\n \n     const Attribute & getAttribute(const std::string & attribute_name) const;\n \n     const Attribute & getAttributeWithType(const std::string & name, const AttributeUnderlyingType type) const;\n \n     template <typename RangeType>\n-    void getIdsAndDates(PaddedPODArray<Key> & ids, PaddedPODArray<RangeType> & start_dates, PaddedPODArray<RangeType> & end_dates) const;\n+    void getIdsAndDates(PaddedPODArray<UInt64> & ids, PaddedPODArray<RangeType> & start_dates, PaddedPODArray<RangeType> & end_dates) const;\n \n     template <typename T, typename RangeType>\n     void getIdsAndDates(\n         const Attribute & attribute,\n-        PaddedPODArray<Key> & ids,\n+        PaddedPODArray<UInt64> & ids,\n         PaddedPODArray<RangeType> & start_dates,\n         PaddedPODArray<RangeType> & end_dates) const;\n \ndiff --git a/src/Dictionaries/registerDictionaries.cpp b/src/Dictionaries/registerDictionaries.cpp\nindex a7b3c87267d7..8d24a6ea979f 100644\n--- a/src/Dictionaries/registerDictionaries.cpp\n+++ b/src/Dictionaries/registerDictionaries.cpp\n@@ -57,7 +57,6 @@ void registerDictionaries()\n     {\n         auto & factory = DictionaryFactory::instance();\n         registerDictionaryRangeHashed(factory);\n-        registerDictionaryComplexKeyHashed(factory);\n         registerDictionaryTrie(factory);\n         registerDictionaryFlat(factory);\n         registerDictionaryHashed(factory);\ndiff --git a/src/Dictionaries/ya.make b/src/Dictionaries/ya.make\nindex 4df582111187..dc58d3f0a14b 100644\n--- a/src/Dictionaries/ya.make\n+++ b/src/Dictionaries/ya.make\n@@ -26,7 +26,7 @@ SRCS(\n     CassandraDictionarySource.cpp\n     CassandraHelpers.cpp\n     ClickHouseDictionarySource.cpp\n-    ComplexKeyHashedDictionary.cpp\n+    DictionaryBlockInputStream.cpp\n     DictionaryBlockInputStreamBase.cpp\n     DictionaryFactory.cpp\n     DictionarySourceFactory.cpp\n@@ -48,6 +48,7 @@ SRCS(\n     FlatDictionary.cpp\n     HTTPDictionarySource.cpp\n     HashedDictionary.cpp\n+    HierarchyDictionariesUtils.cpp\n     IPAddressDictionary.cpp\n     LibraryDictionarySource.cpp\n     LibraryDictionarySourceExternal.cpp\ndiff --git a/src/Functions/FunctionsExternalDictionaries.cpp b/src/Functions/FunctionsExternalDictionaries.cpp\nindex f037a3bd8088..79236fb2cf44 100644\n--- a/src/Functions/FunctionsExternalDictionaries.cpp\n+++ b/src/Functions/FunctionsExternalDictionaries.cpp\n@@ -24,6 +24,8 @@ void registerFunctionsExternalDictionaries(FunctionFactory & factory)\n     factory.registerFunction<FunctionDictGetString>();\n     factory.registerFunction<FunctionDictGetHierarchy>();\n     factory.registerFunction<FunctionDictIsIn>();\n+    factory.registerFunction<FunctionDictGetChildren>();\n+    factory.registerFunction<FunctionDictGetDescendants>();\n     factory.registerFunction<FunctionDictGetUInt8OrDefault>();\n     factory.registerFunction<FunctionDictGetUInt16OrDefault>();\n     factory.registerFunction<FunctionDictGetUInt32OrDefault>();\ndiff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex 2c322698327d..0bc22826f4ee 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -28,16 +28,6 @@\n \n #include <Functions/IFunctionImpl.h>\n #include <Functions/FunctionHelpers.h>\n-\n-#include <Dictionaries/FlatDictionary.h>\n-#include <Dictionaries/HashedDictionary.h>\n-#include <Dictionaries/CacheDictionary.h>\n-#include <Dictionaries/ComplexKeyHashedDictionary.h>\n-#include <Dictionaries/RangeHashedDictionary.h>\n-#include <Dictionaries/IPAddressDictionary.h>\n-#include <Dictionaries/PolygonDictionaryImplementations.h>\n-#include <Dictionaries/DirectDictionary.h>\n-\n #include <ext/range.h>\n \n #include <type_traits>\n@@ -49,7 +39,6 @@ namespace ErrorCodes\n {\n     extern const int ILLEGAL_TYPE_OF_ARGUMENT;\n     extern const int UNSUPPORTED_METHOD;\n-    extern const int UNKNOWN_TYPE;\n     extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n     extern const int ILLEGAL_COLUMN;\n     extern const int BAD_ARGUMENTS;\n@@ -77,7 +66,7 @@ class FunctionDictHelper\n public:\n     explicit FunctionDictHelper(const Context & context_) : context(context_) {}\n \n-    std::shared_ptr<const IDictionaryBase> getDictionary(const String & dictionary_name)\n+    std::shared_ptr<const IDictionary> getDictionary(const String & dictionary_name)\n     {\n         auto dict = context.getExternalDictionariesLoader().getDictionary(dictionary_name, context);\n \n@@ -90,9 +79,13 @@ class FunctionDictHelper\n         return dict;\n     }\n \n-    std::shared_ptr<const IDictionaryBase> getDictionary(const ColumnWithTypeAndName & column)\n+    std::shared_ptr<const IDictionary> getDictionary(const ColumnPtr & column)\n     {\n-        const auto * dict_name_col = checkAndGetColumnConst<ColumnString>(column.column.get());\n+        const auto * dict_name_col = checkAndGetColumnConst<ColumnString>(column.get());\n+\n+        if (!dict_name_col)\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Expected const String column\");\n+\n         return getDictionary(dict_name_col->getValue<String>());\n     }\n \n@@ -187,7 +180,7 @@ class FunctionDictHas final : public IFunction\n         if (input_rows_count == 0)\n             return result_type->createColumn();\n \n-        auto dictionary = helper.getDictionary(arguments[0]);\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n         auto dictionary_key_type = dictionary->getKeyType();\n \n         const ColumnWithTypeAndName & key_column_with_type = arguments[1];\n@@ -727,12 +720,16 @@ class FunctionDictGetHierarchy final : public IFunction\n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n-            throw Exception{\"Illegal type \" + arguments[0]->getName() + \" of first argument of function \" + getName()\n-                + \", expected a string.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of first argument of function ({}). Expected String. Actual type ({})\",\n+                getName(),\n+                arguments[0]->getName());\n \n         if (!WhichDataType(arguments[1]).isUInt64())\n-            throw Exception{\"Illegal type \" + arguments[1]->getName() + \" of second argument of function \" + getName()\n-                + \", must be UInt64.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of second argument of function ({}). Expected UInt64. Actual type ({})\",\n+                getName(),\n+                arguments[1]->getName());\n \n         return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n     }\n@@ -744,259 +741,229 @@ class FunctionDictGetHierarchy final : public IFunction\n         if (input_rows_count == 0)\n             return result_type->createColumn();\n \n-        auto dict = helper.getDictionary(arguments[0]);\n-        ColumnPtr res;\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n \n-        /// TODO: Rewrite this\n-        if (!((res = executeDispatch<FlatDictionary>(arguments, result_type, dict))\n-            || (res = executeDispatch<DirectDictionary<DictionaryKeyType::simple>>(arguments, result_type, dict))\n-            || (res = executeDispatch<HashedDictionary>(arguments, result_type, dict))\n-            || (res = executeDispatch<CacheDictionary<DictionaryKeyType::simple>>(arguments, result_type, dict))))\n-            throw Exception{\"Unsupported dictionary type \" + dict->getTypeName(), ErrorCodes::UNKNOWN_TYPE};\n+        if (!dictionary->hasHierarchy())\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                \"Dictionary ({}) does not support hierarchy\",\n+                dictionary->getFullName());\n \n-        return res;\n+        ColumnPtr result = dictionary->getHierarchy(arguments[1].column, std::make_shared<DataTypeUInt64>());\n+        return result;\n     }\n \n-    template <typename DictionaryType>\n-    ColumnPtr executeDispatch(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, const std::shared_ptr<const IDictionaryBase> & dict_ptr) const\n-    {\n-        const auto * dict = typeid_cast<const DictionaryType *>(dict_ptr.get());\n-        if (!dict)\n-            return nullptr;\n+    mutable FunctionDictHelper helper;\n+};\n \n-        if (!dict->hasHierarchy())\n-            throw Exception{\"Dictionary does not have a hierarchy\", ErrorCodes::UNSUPPORTED_METHOD};\n \n-        const auto get_hierarchies = [&] (const PaddedPODArray<UInt64> & in, PaddedPODArray<UInt64> & out, PaddedPODArray<UInt64> & offsets)\n-        {\n-            const auto size = in.size();\n+class FunctionDictIsIn final : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"dictIsIn\";\n \n-            /// copy of `in` array\n-            auto in_array = std::make_unique<PaddedPODArray<UInt64>>(std::begin(in), std::end(in));\n-            /// used for storing and handling result of ::toParent call\n-            auto out_array = std::make_unique<PaddedPODArray<UInt64>>(size);\n-            /// resulting hierarchies\n-            std::vector<std::vector<IDictionary::Key>> hierarchies(size);    /// TODO Bad code, poor performance.\n+    static FunctionPtr create(const Context & context)\n+    {\n+        return std::make_shared<FunctionDictIsIn>(context);\n+    }\n \n-            /// total number of non-zero elements, used for allocating all the required memory upfront\n-            size_t total_count = 0;\n+    explicit FunctionDictIsIn(const Context & context_)\n+        : helper(context_) {}\n \n-            while (true)\n-            {\n-                auto all_zeroes = true;\n+    String getName() const override { return name; }\n \n-                /// erase zeroed identifiers, store non-zeroed ones\n-                for (const auto i : ext::range(0, size))\n-                {\n-                    const auto id = (*in_array)[i];\n-                    if (0 == id)\n-                        continue;\n+private:\n+    size_t getNumberOfArguments() const override { return 3; }\n \n+    bool useDefaultImplementationForConstants() const final { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n \n-                    auto & hierarchy = hierarchies[i];\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        if (!isString(arguments[0]))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of first argument of function ({}). Expected String. Actual type ({})\",\n+                getName(),\n+                arguments[0]->getName());\n \n-                    /// Checking for loop\n-                    if (std::find(std::begin(hierarchy), std::end(hierarchy), id) != std::end(hierarchy))\n-                        continue;\n+        if (!WhichDataType(arguments[1]).isUInt64())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of second argument of function ({}). Expected UInt64. Actual type ({})\",\n+                getName(),\n+                arguments[1]->getName());\n \n-                    all_zeroes = false;\n-                    /// place id at it's corresponding place\n-                    hierarchy.push_back(id);\n+        if (!WhichDataType(arguments[2]).isUInt64())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of third argument of function ({}). Expected UInt64. Actual type ({})\",\n+                getName(),\n+                arguments[2]->getName());\n \n-                    ++total_count;\n-                }\n+        return std::make_shared<DataTypeUInt8>();\n+    }\n \n-                if (all_zeroes)\n-                    break;\n+    bool isDeterministic() const override { return false; }\n \n-                /// translate all non-zero identifiers at once\n-                dict->toParent(*in_array, *out_array);\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n+    {\n+        if (input_rows_count == 0)\n+            return result_type->createColumn();\n \n-                /// we're going to use the `in_array` from this iteration as `out_array` on the next one\n-                std::swap(in_array, out_array);\n-            }\n+        auto dict = helper.getDictionary(arguments[0].column);\n \n-            out.reserve(total_count);\n-            offsets.resize(size);\n+        if (!dict->hasHierarchy())\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Dictionary ({}) does not support hierarchy\", dict->getFullName());\n \n-            for (const auto i : ext::range(0, size))\n-            {\n-                const auto & ids = hierarchies[i];\n-                out.insert_assume_reserved(std::begin(ids), std::end(ids));\n-                offsets[i] = out.size();\n-            }\n-        };\n+        ColumnPtr res = dict->isInHierarchy(arguments[1].column, arguments[2].column, std::make_shared<DataTypeUInt64>());\n \n-        const auto * id_col_untyped = arguments[1].column.get();\n-        if (const auto * id_col = checkAndGetColumn<ColumnUInt64>(id_col_untyped))\n-        {\n-            const auto & in = id_col->getData();\n-            auto backend = ColumnUInt64::create();\n-            auto offsets = ColumnArray::ColumnOffsets::create();\n-            get_hierarchies(in, backend->getData(), offsets->getData());\n-            return ColumnArray::create(std::move(backend), std::move(offsets));\n-        }\n-        else if (const auto * id_col_const = checkAndGetColumnConst<ColumnVector<UInt64>>(id_col_untyped))\n-        {\n-            const PaddedPODArray<UInt64> in(1, id_col_const->getValue<UInt64>());\n-            auto backend = ColumnUInt64::create();\n-            auto offsets = ColumnArray::ColumnOffsets::create();\n-            get_hierarchies(in, backend->getData(), offsets->getData());\n-            auto array = ColumnArray::create(std::move(backend), std::move(offsets));\n-            return result_type->createColumnConst(id_col_const->size(), (*array)[0].get<Array>());\n-        }\n-        else\n-            throw Exception{\"Second argument of function \" + getName() + \" must be UInt64\", ErrorCodes::ILLEGAL_COLUMN};\n+        return res;\n     }\n \n     mutable FunctionDictHelper helper;\n };\n \n-\n-class FunctionDictIsIn final : public IFunction\n+class FunctionDictGetChildren final : public IFunction\n {\n public:\n-    static constexpr auto name = \"dictIsIn\";\n+    static constexpr auto name = \"dictGetChildren\";\n \n     static FunctionPtr create(const Context & context)\n     {\n-        return std::make_shared<FunctionDictIsIn>(context);\n+        return std::make_shared<FunctionDictGetChildren>(context);\n     }\n \n-    explicit FunctionDictIsIn(const Context & context_)\n+    explicit FunctionDictGetChildren(const Context & context_)\n         : helper(context_) {}\n \n     String getName() const override { return name; }\n \n private:\n-    size_t getNumberOfArguments() const override { return 3; }\n+    size_t getNumberOfArguments() const override { return 2; }\n \n     bool useDefaultImplementationForConstants() const final { return true; }\n     ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n+    bool isDeterministic() const override { return false; }\n \n     DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n     {\n         if (!isString(arguments[0]))\n-            throw Exception{\"Illegal type \" + arguments[0]->getName() + \" of first argument of function \" + getName()\n-                + \", expected a string.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of first argument of function ({}). Expected String. Actual type ({})\",\n+                getName(),\n+                arguments[0]->getName());\n \n         if (!WhichDataType(arguments[1]).isUInt64())\n-            throw Exception{\"Illegal type \" + arguments[1]->getName() + \" of second argument of function \" + getName()\n-                + \", must be UInt64.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n-\n-        if (!WhichDataType(arguments[2]).isUInt64())\n-            throw Exception{\"Illegal type \" + arguments[2]->getName() + \" of third argument of function \" + getName()\n-                + \", must be UInt64.\", ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of second argument of function ({}). Expected UInt64. Actual type ({})\",\n+                getName(),\n+                arguments[1]->getName());\n \n-        return std::make_shared<DataTypeUInt8>();\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n     }\n \n-    bool isDeterministic() const override { return false; }\n-\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n         if (input_rows_count == 0)\n             return result_type->createColumn();\n \n-        auto dict = helper.getDictionary(arguments[0]);\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n \n-        ColumnPtr res;\n-        if (!((res = executeDispatch<FlatDictionary>(arguments, dict))\n-            || (res = executeDispatch<DirectDictionary<DictionaryKeyType::simple>>(arguments, dict))\n-            || (res = executeDispatch<HashedDictionary>(arguments, dict))\n-            || (res = executeDispatch<CacheDictionary<DictionaryKeyType::simple>>(arguments, dict))))\n-            throw Exception{\"Unsupported dictionary type \" + dict->getTypeName(), ErrorCodes::UNKNOWN_TYPE};\n+        if (!dictionary->hasHierarchy())\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                \"Dictionary ({}) does not support hierarchy\",\n+                dictionary->getFullName());\n \n-        return res;\n+        ColumnPtr result = dictionary->getDescendants(arguments[1].column, std::make_shared<DataTypeUInt64>(), 1);\n+\n+        return result;\n     }\n \n-    template <typename DictionaryType>\n-    ColumnPtr executeDispatch(const ColumnsWithTypeAndName & arguments, const std::shared_ptr<const IDictionaryBase> & dict_ptr) const\n+    mutable FunctionDictHelper helper;\n+};\n+\n+class FunctionDictGetDescendants final : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"dictGetDescendants\";\n+\n+    static FunctionPtr create(const Context & context)\n     {\n-        const auto * dict = typeid_cast<const DictionaryType *>(dict_ptr.get());\n-        if (!dict)\n-            return nullptr;\n+        return std::make_shared<FunctionDictGetDescendants>(context);\n+    }\n \n-        if (!dict->hasHierarchy())\n-            throw Exception{\"Dictionary does not have a hierarchy\", ErrorCodes::UNSUPPORTED_METHOD};\n+    explicit FunctionDictGetDescendants(const Context & context_)\n+        : helper(context_) {}\n \n-        const auto * child_id_col_untyped = arguments[1].column.get();\n-        const auto * ancestor_id_col_untyped = arguments[2].column.get();\n+    String getName() const override { return name; }\n \n-        if (const auto * child_id_col = checkAndGetColumn<ColumnUInt64>(child_id_col_untyped))\n-            return execute(dict, child_id_col, ancestor_id_col_untyped);\n-        else if (const auto * child_id_col_const = checkAndGetColumnConst<ColumnVector<UInt64>>(child_id_col_untyped))\n-            return execute(dict, child_id_col_const, ancestor_id_col_untyped);\n-        else\n-            throw Exception{\"Illegal column \" + child_id_col_untyped->getName()\n-                + \" of second argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n-    }\n+private:\n+    size_t getNumberOfArguments() const override { return 0; }\n+    bool isVariadic() const override { return true; }\n \n-    template <typename DictionaryType>\n-    ColumnPtr execute(const DictionaryType * dict,\n-                 const ColumnUInt64 * child_id_col, const IColumn * ancestor_id_col_untyped) const\n-    {\n-        if (const auto * ancestor_id_col = checkAndGetColumn<ColumnUInt64>(ancestor_id_col_untyped))\n-        {\n-            auto out = ColumnUInt8::create();\n+    bool useDefaultImplementationForConstants() const final { return true; }\n+    ColumnNumbers getArgumentsThatAreAlwaysConstant() const final { return {0}; }\n+    bool isDeterministic() const override { return false; }\n \n-            const auto & child_ids = child_id_col->getData();\n-            const auto & ancestor_ids = ancestor_id_col->getData();\n-            auto & data = out->getData();\n-            const auto size = child_id_col->size();\n-            data.resize(size);\n \n-            dict->isInVectorVector(child_ids, ancestor_ids, data);\n-            return out;\n-        }\n-        else if (const auto * ancestor_id_col_const = checkAndGetColumnConst<ColumnVector<UInt64>>(ancestor_id_col_untyped))\n+    DataTypePtr getReturnTypeImpl(const DataTypes & arguments) const override\n+    {\n+        size_t arguments_size = arguments.size();\n+        if (arguments_size < 2 || arguments_size > 3)\n         {\n-            auto out = ColumnUInt8::create();\n+            throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH,\n+                \"Illegal arguments size of function ({}). Expects 2 or 3 arguments size. Actual size ({})\",\n+                getName(),\n+                arguments_size);\n+        }\n \n-            const auto & child_ids = child_id_col->getData();\n-            const auto ancestor_id = ancestor_id_col_const->getValue<UInt64>();\n-            auto & data = out->getData();\n-            const auto size = child_id_col->size();\n-            data.resize(size);\n+        if (!isString(arguments[0]))\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of first argument of function ({}). Expected const String. Actual type ({})\",\n+                getName(),\n+                arguments[0]->getName());\n \n-            dict->isInVectorConstant(child_ids, ancestor_id, data);\n-            return out;\n-        }\n-        else\n+        if (!WhichDataType(arguments[1]).isUInt64())\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of second argument of function ({}). Expected UInt64. Actual type ({})\",\n+                getName(),\n+                arguments[1]->getName());\n+\n+        if (arguments.size() == 3 && !isUnsignedInteger(arguments[2]))\n         {\n-            throw Exception{\"Illegal column \" + ancestor_id_col_untyped->getName()\n-                + \" of third argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n+            throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                \"Illegal type of third argument of function ({}). Expected const unsigned integer. Actual type ({})\",\n+                getName(),\n+                arguments[2]->getName());\n         }\n+\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeUInt64>());\n     }\n \n-    template <typename DictionaryType>\n-    ColumnPtr execute(const DictionaryType * dict, const ColumnConst * child_id_col, const IColumn * ancestor_id_col_untyped) const\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type, size_t input_rows_count) const override\n     {\n-        if (const auto * ancestor_id_col = checkAndGetColumn<ColumnUInt64>(ancestor_id_col_untyped))\n-        {\n-            auto out = ColumnUInt8::create();\n+        if (input_rows_count == 0)\n+            return result_type->createColumn();\n \n-            const auto child_id = child_id_col->getValue<UInt64>();\n-            const auto & ancestor_ids = ancestor_id_col->getData();\n-            auto & data = out->getData();\n-            const auto size = child_id_col->size();\n-            data.resize(size);\n+        auto dictionary = helper.getDictionary(arguments[0].column);\n \n-            dict->isInConstantVector(child_id, ancestor_ids, data);\n-            return out;\n-        }\n-        else if (const auto * ancestor_id_col_const = checkAndGetColumnConst<ColumnVector<UInt64>>(ancestor_id_col_untyped))\n+        size_t level = 0;\n+\n+        if (arguments.size() == 3)\n         {\n-            const auto child_id = child_id_col->getValue<UInt64>();\n-            const auto ancestor_id = ancestor_id_col_const->getValue<UInt64>();\n-            UInt8 res = 0;\n+            if (!isColumnConst(*arguments[2].column))\n+                throw Exception(ErrorCodes::ILLEGAL_TYPE_OF_ARGUMENT,\n+                    \"Illegal type of third argument of function ({}). Expected const unsigned integer.\",\n+                    getName());\n \n-            dict->isInConstantConstant(child_id, ancestor_id, res);\n-            return DataTypeUInt8().createColumnConst(child_id_col->size(), res);\n+            level = static_cast<size_t>(arguments[2].column->get64(0));\n         }\n-        else\n-            throw Exception{\"Illegal column \" + ancestor_id_col_untyped->getName()\n-                + \" of third argument of function \" + getName(), ErrorCodes::ILLEGAL_COLUMN};\n+\n+        if (!dictionary->hasHierarchy())\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD,\n+                \"Dictionary ({}) does not support hierarchy\",\n+                dictionary->getFullName());\n+\n+        ColumnPtr res = dictionary->getDescendants(arguments[1].column, std::make_shared<DataTypeUInt64>(), level);\n+\n+        return res;\n     }\n \n     mutable FunctionDictHelper helper;\ndiff --git a/src/Interpreters/ExternalDictionariesLoader.cpp b/src/Interpreters/ExternalDictionariesLoader.cpp\nindex 1632b7cbf78c..8df29459b72f 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.cpp\n+++ b/src/Interpreters/ExternalDictionariesLoader.cpp\n@@ -46,13 +46,13 @@ ExternalLoader::LoadablePtr ExternalDictionariesLoader::create(\n ExternalDictionariesLoader::DictPtr ExternalDictionariesLoader::getDictionary(const std::string & dictionary_name, const Context & context) const\n {\n     std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, context.getCurrentDatabase());\n-    return std::static_pointer_cast<const IDictionaryBase>(load(resolved_dictionary_name));\n+    return std::static_pointer_cast<const IDictionary>(load(resolved_dictionary_name));\n }\n \n ExternalDictionariesLoader::DictPtr ExternalDictionariesLoader::tryGetDictionary(const std::string & dictionary_name, const Context & context) const\n {\n     std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, context.getCurrentDatabase());\n-    return std::static_pointer_cast<const IDictionaryBase>(tryLoad(resolved_dictionary_name));\n+    return std::static_pointer_cast<const IDictionary>(tryLoad(resolved_dictionary_name));\n }\n \n \ndiff --git a/src/Interpreters/ExternalDictionariesLoader.h b/src/Interpreters/ExternalDictionariesLoader.h\nindex 0f64715b2438..ce5b25127410 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.h\n+++ b/src/Interpreters/ExternalDictionariesLoader.h\n@@ -15,7 +15,7 @@ class IExternalLoaderConfigRepository;\n class ExternalDictionariesLoader : public ExternalLoader\n {\n public:\n-    using DictPtr = std::shared_ptr<const IDictionaryBase>;\n+    using DictPtr = std::shared_ptr<const IDictionary>;\n \n     /// Dictionaries will be loaded immediately and then will be updated in separate thread, each 'reload_period' seconds.\n     explicit ExternalDictionariesLoader(Context & global_context_);\ndiff --git a/src/Storages/System/StorageSystemDictionaries.cpp b/src/Storages/System/StorageSystemDictionaries.cpp\nindex cccd23ffbd19..378905b7dc01 100644\n--- a/src/Storages/System/StorageSystemDictionaries.cpp\n+++ b/src/Storages/System/StorageSystemDictionaries.cpp\n@@ -58,7 +58,7 @@ void StorageSystemDictionaries::fillData(MutableColumns & res_columns, const Con\n     const auto & external_dictionaries = context.getExternalDictionariesLoader();\n     for (const auto & load_result : external_dictionaries.getLoadResults())\n     {\n-        const auto dict_ptr = std::dynamic_pointer_cast<const IDictionaryBase>(load_result.object);\n+        const auto dict_ptr = std::dynamic_pointer_cast<const IDictionary>(load_result.object);\n         DictionaryStructure dictionary_structure = ExternalDictionariesLoader::getDictionaryStructure(*load_result.config);\n \n         StorageID dict_id = StorageID::createEmpty();\n",
  "test_patch": "diff --git a/src/Common/tests/gtest_pod_array.cpp b/src/Common/tests/gtest_pod_array.cpp\nindex 63cf7026757a..9cc77b88195e 100644\n--- a/src/Common/tests/gtest_pod_array.cpp\n+++ b/src/Common/tests/gtest_pod_array.cpp\n@@ -33,6 +33,19 @@ TEST(Common, PODArrayInsert)\n     EXPECT_EQ(str, std::string(chars.data(), chars.size()));\n }\n \n+TEST(Common, PODArrayInsertFromItself)\n+{\n+    {\n+        PaddedPODArray<UInt64> array { 1 };\n+\n+        for (size_t i = 0; i < 3; ++i)\n+            array.insertFromItself(array.begin(), array.end());\n+\n+        PaddedPODArray<UInt64> expected {1,1,1,1,1,1,1,1};\n+        ASSERT_EQ(array,expected);\n+    }\n+}\n+\n TEST(Common, PODPushBackRawMany)\n {\n     PODArray<char> chars;\ndiff --git a/src/Dictionaries/tests/gtest_dictionary_ssd_cache_dictionary_storage.cpp b/src/Dictionaries/tests/gtest_dictionary_ssd_cache_dictionary_storage.cpp\nindex 20529e91bd3d..9fd9dc9b78c6 100644\n--- a/src/Dictionaries/tests/gtest_dictionary_ssd_cache_dictionary_storage.cpp\n+++ b/src/Dictionaries/tests/gtest_dictionary_ssd_cache_dictionary_storage.cpp\n@@ -1,7 +1,5 @@\n #if defined(__linux__) || defined(__FreeBSD__)\n \n-#include <iostream>\n-\n #include <gtest/gtest.h>\n \n #include <Dictionaries/SSDCacheDictionaryStorage.h>\ndiff --git a/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp b/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\nnew file mode 100644\nindex 000000000000..064f57dfe112\n--- /dev/null\n+++ b/src/Dictionaries/tests/gtest_hierarchy_dictionaries_utils.cpp\n@@ -0,0 +1,225 @@\n+#include <gtest/gtest.h>\n+\n+#include <Common/HashTable/HashMap.h>\n+\n+#include <Dictionaries/HierarchyDictionariesUtils.h>\n+\n+using namespace DB;\n+\n+TEST(HierarchyDictionariesUtils, getHierarchy)\n+{\n+    {\n+        HashMap<UInt64, UInt64> child_to_parent;\n+        child_to_parent[1] = 0;\n+        child_to_parent[2] = 1;\n+        child_to_parent[3] = 1;\n+        child_to_parent[4] = 2;\n+\n+        auto is_key_valid_func = [&](auto key) { return child_to_parent.find(key) != nullptr; };\n+\n+        auto get_parent_key_func = [&](auto key)\n+        {\n+            auto it = child_to_parent.find(key);\n+            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n+            return value;\n+        };\n+\n+        UInt64 hierarchy_null_value_key = 0;\n+        PaddedPODArray<UInt64> keys = {1, 2, 3, 4, 5};\n+\n+        auto result = DB::detail::getHierarchy(\n+            keys,\n+            hierarchy_null_value_key,\n+            is_key_valid_func,\n+            get_parent_key_func);\n+\n+        const auto & actual_elements = result.elements;\n+        const auto & actual_offsets = result.offsets;\n+\n+        PaddedPODArray<UInt64> expected_elements = {1, 2, 1, 3, 1, 4, 2, 1};\n+        PaddedPODArray<IColumn::Offset> expected_offsets = {1, 3, 5, 8, 8};\n+\n+        ASSERT_EQ(actual_elements, expected_elements);\n+        ASSERT_EQ(actual_offsets, expected_offsets);\n+    }\n+    {\n+        HashMap<UInt64, UInt64> child_to_parent;\n+        child_to_parent[1] = 2;\n+        child_to_parent[2] = 1;\n+\n+        auto is_key_valid_func = [&](auto key) { return child_to_parent.find(key) != nullptr; };\n+\n+        auto get_parent_key_func = [&](auto key)\n+        {\n+            auto it = child_to_parent.find(key);\n+            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n+            return value;\n+        };\n+\n+        UInt64 hierarchy_null_value_key = 0;\n+        PaddedPODArray<UInt64> keys = {1, 2, 3};\n+\n+        auto result = DB::detail::getHierarchy(\n+            keys,\n+            hierarchy_null_value_key,\n+            is_key_valid_func,\n+            get_parent_key_func);\n+\n+        const auto & actual_elements = result.elements;\n+        const auto & actual_offsets = result.offsets;\n+\n+        PaddedPODArray<UInt64> expected_elements = {1, 2, 2};\n+        PaddedPODArray<IColumn::Offset> expected_offsets = {2, 3, 3};\n+\n+        ASSERT_EQ(actual_elements, expected_elements);\n+        ASSERT_EQ(actual_offsets, expected_offsets);\n+    }\n+}\n+\n+TEST(HierarchyDictionariesUtils, getIsInHierarchy)\n+{\n+    {\n+        HashMap<UInt64, UInt64> child_to_parent;\n+        child_to_parent[1] = 0;\n+        child_to_parent[2] = 1;\n+        child_to_parent[3] = 1;\n+        child_to_parent[4] = 2;\n+\n+        auto is_key_valid_func = [&](auto key) { return child_to_parent.find(key) != nullptr; };\n+\n+        auto get_parent_key_func = [&](auto key)\n+        {\n+            auto it = child_to_parent.find(key);\n+            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n+            return value;\n+        };\n+\n+        UInt64 hierarchy_null_value_key = 0;\n+        PaddedPODArray<UInt64> keys = {1, 2, 3, 4, 5};\n+        PaddedPODArray<UInt64> keys_in = {1, 1, 1, 2, 5};\n+\n+        PaddedPODArray<UInt8> actual = DB::detail::getIsInHierarchy(\n+            keys,\n+            keys_in,\n+            hierarchy_null_value_key,\n+            is_key_valid_func,\n+            get_parent_key_func);\n+\n+        PaddedPODArray<UInt8> expected = {1,1,1,1,0};\n+\n+        ASSERT_EQ(actual, expected);\n+    }\n+    {\n+        HashMap<UInt64, UInt64> child_to_parent;\n+        child_to_parent[1] = 2;\n+        child_to_parent[2] = 1;\n+\n+        auto is_key_valid_func = [&](auto key)\n+        {\n+            return child_to_parent.find(key) != nullptr;\n+        };\n+\n+        auto get_parent_key_func = [&](auto key)\n+        {\n+            auto it = child_to_parent.find(key);\n+            std::optional<UInt64> value = (it != nullptr ? std::make_optional(it->getMapped()) : std::nullopt);\n+            return value;\n+        };\n+\n+        UInt64 hierarchy_null_value_key = 0;\n+        PaddedPODArray<UInt64> keys = {1, 2, 3};\n+        PaddedPODArray<UInt64> keys_in = {1, 2, 3};\n+\n+        PaddedPODArray<UInt8> actual = DB::detail::getIsInHierarchy(\n+            keys,\n+            keys_in,\n+            hierarchy_null_value_key,\n+            is_key_valid_func,\n+            get_parent_key_func);\n+\n+        PaddedPODArray<UInt8> expected = {1, 1, 0};\n+        ASSERT_EQ(actual, expected);\n+    }\n+}\n+\n+TEST(HierarchyDictionariesUtils, getDescendants)\n+{\n+    {\n+        HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+        parent_to_child[0].emplace_back(1);\n+        parent_to_child[1].emplace_back(2);\n+        parent_to_child[1].emplace_back(3);\n+        parent_to_child[2].emplace_back(4);\n+\n+        PaddedPODArray<UInt64> keys = {0, 1, 2, 3, 4};\n+\n+        {\n+            auto result = DB::detail::getDescendants(\n+                keys,\n+                parent_to_child,\n+                DB::detail::GetAllDescendantsStrategy());\n+\n+            const auto & actual_elements = result.elements;\n+            const auto & actual_offsets = result.offsets;\n+\n+            PaddedPODArray<UInt64> expected_elements = {1, 2, 3, 4, 2, 3, 4, 4};\n+            PaddedPODArray<IColumn::Offset> expected_offsets = {4, 7, 8, 8, 8};\n+\n+            ASSERT_EQ(actual_elements, expected_elements);\n+            ASSERT_EQ(actual_offsets, expected_offsets);\n+        }\n+        {\n+            auto result = DB::detail::getDescendants(\n+                keys,\n+                parent_to_child,\n+                DB::detail::GetDescendantsAtSpecificLevelStrategy{1});\n+\n+            const auto & actual_elements = result.elements;\n+            const auto & actual_offsets = result.offsets;\n+\n+            PaddedPODArray<UInt64> expected_elements = {1, 2, 3, 4};\n+            PaddedPODArray<IColumn::Offset> expected_offsets = {1, 3, 4, 4, 4};\n+\n+            ASSERT_EQ(actual_elements, expected_elements);\n+            ASSERT_EQ(actual_offsets, expected_offsets);\n+        }\n+    }\n+    {\n+        HashMap<UInt64, PaddedPODArray<UInt64>> parent_to_child;\n+        parent_to_child[1].emplace_back(2);\n+        parent_to_child[2].emplace_back(1);\n+\n+        PaddedPODArray<UInt64> keys = {1, 2, 3};\n+\n+        {\n+            auto result = DB::detail::getDescendants(\n+                keys,\n+                parent_to_child,\n+                DB::detail::GetAllDescendantsStrategy());\n+\n+            const auto & actual_elements = result.elements;\n+            const auto & actual_offsets = result.offsets;\n+\n+            PaddedPODArray<UInt64> expected_elements = {2, 1, 1};\n+            PaddedPODArray<IColumn::Offset> expected_offsets = {2, 3, 3};\n+\n+            ASSERT_EQ(actual_elements, expected_elements);\n+            ASSERT_EQ(actual_offsets, expected_offsets);\n+        }\n+        {\n+            auto result = DB::detail::getDescendants(\n+                keys,\n+                parent_to_child,\n+                DB::detail::GetDescendantsAtSpecificLevelStrategy{1});\n+\n+            const auto & actual_elements = result.elements;\n+            const auto & actual_offsets = result.offsets;\n+\n+            PaddedPODArray<UInt64> expected_elements = {2, 1};\n+            PaddedPODArray<IColumn::Offset> expected_offsets = {1, 2, 2};\n+\n+            ASSERT_EQ(actual_elements, expected_elements);\n+            ASSERT_EQ(actual_offsets, expected_offsets);\n+        }\n+    }\n+}\ndiff --git a/tests/performance/direct_dictionary.xml b/tests/performance/direct_dictionary.xml\nindex 68b52d917dda..97ecdfe3e951 100644\n--- a/tests/performance/direct_dictionary.xml\n+++ b/tests/performance/direct_dictionary.xml\n@@ -1,57 +1,43 @@\n <test max_ignored_relative_change=\"0.3\">\n     <create_query>\n-        CREATE TABLE simple_direct_dictionary_test_table\n+        CREATE TABLE simple_key_direct_dictionary_source_table\n         (\n             id UInt64,\n             value_int UInt64,\n             value_string String,\n             value_decimal Decimal64(8),\n             value_string_nullable Nullable(String)\n-        ) ENGINE = TinyLog;\n-    </create_query>\n-\n-    <create_query>\n-        INSERT INTO simple_direct_dictionary_test_table\n-        SELECT number, number, toString(number), toDecimal64(number, 8), toString(number)\n-        FROM system.numbers\n-        LIMIT 100000;\n+        ) ENGINE = Memory;\n     </create_query>\n \n     <create_query>\n-        CREATE DICTIONARY simple_direct_dictionary\n+        CREATE TABLE complex_key_direct_dictionary_source_table\n         (\n             id UInt64,\n+            id_key String,\n             value_int UInt64,\n             value_string String,\n             value_decimal Decimal64(8),\n             value_string_nullable Nullable(String)\n-        )\n-        PRIMARY KEY id\n-        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_direct_dictionary_test_table'))\n-        LAYOUT(DIRECT())\n+        ) ENGINE = TinyLog;\n     </create_query>\n \n     <create_query>\n-        CREATE TABLE complex_direct_dictionary_test_table\n+        CREATE DICTIONARY simple_key_direct_dictionary\n         (\n             id UInt64,\n-            id_key String,\n             value_int UInt64,\n             value_string String,\n             value_decimal Decimal64(8),\n             value_string_nullable Nullable(String)\n-        ) ENGINE = TinyLog;\n-    </create_query>\n-\n-    <create_query>\n-        INSERT INTO complex_direct_dictionary_test_table\n-        SELECT number, toString(number), number, toString(number), toDecimal64(number, 8), toString(number)\n-        FROM system.numbers\n-        LIMIT 100000;\n+        )\n+        PRIMARY KEY id\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_key_direct_dictionary_source_table'))\n+        LAYOUT(DIRECT())\n     </create_query>\n \n     <create_query>\n-        CREATE DICTIONARY complex_direct_dictionary\n+        CREATE DICTIONARY complex_key_direct_dictionary\n         (\n             id UInt64,\n             id_key String,\n@@ -61,20 +47,76 @@\n             value_string_nullable Nullable(String)\n         )\n         PRIMARY KEY id, id_key\n-        SOURCE(CLICKHOUSE(DB 'default' TABLE 'complex_direct_dictionary_test_table'))\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'complex_key_direct_dictionary_source_table'))\n         LAYOUT(COMPLEX_KEY_DIRECT())\n     </create_query>\n \n-    <query>SELECT dictGet('default.simple_direct_dictionary', 'value_int', number) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictGet('default.simple_direct_dictionary', 'value_string', number) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictGet('default.simple_direct_dictionary', 'value_decimal', number) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictGet('default.simple_direct_dictionary', 'value_string_nullable', number) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictHas('default.simple_direct_dictionary', number) FROM system.numbers LIMIT 150000;</query>\n+    <fill_query>\n+        INSERT INTO simple_key_direct_dictionary_source_table\n+        SELECT number, number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 100000;\n+    </fill_query>\n+\n+    <fill_query>\n+        INSERT INTO complex_key_direct_dictionary_source_table\n+        SELECT number, toString(number), number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 100000;\n+    </fill_query>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>column_name</name>\n+            <values>\n+                <value>'value_int'</value>\n+                <value>'value_string'</value>\n+                <value>'value_decimal'</value>\n+                <value>'value_string_nullable'</value>\n+            </values>\n+        </substitution>\n+\n+        <substitution>\n+            <name>elements_count</name>\n+            <values>\n+                <value>25000</value>\n+                <value>50000</value>\n+                <value>75000</value>\n+                <value>100000</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <query>\n+        SELECT dictGet('default.simple_key_direct_dictionary', {column_name}, number)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+    <query>\n+        SELECT dictHas('default.simple_key_direct_dictionary', number)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT dictGet('default.complex_key_direct_dictionary', {column_name}, (number, toString(number)))\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+    <query>\n+        SELECT dictHas('default.complex_key_direct_dictionary', (number, toString(number)))\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <drop_query>DROP TABLE IF EXISTS simple_key_direct_dictionary_source_table;</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS complex_key_direct_dictionary_source_table;</drop_query>\n \n-    <query>SELECT dictGet('default.complex_direct_dictionary', 'value_int', (number, toString(number))) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictGet('default.complex_direct_dictionary', 'value_string', (number, toString(number))) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictGet('default.complex_direct_dictionary', 'value_decimal', (number, toString(number))) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictGet('default.complex_direct_dictionary', 'value_string_nullable', (number, toString(number))) FROM system.numbers LIMIT 150000;</query>\n-    <query>SELECT dictHas('default.complex_direct_dictionary', (number, toString(number))) FROM system.numbers LIMIT 150000;</query>\n+    <drop_query>DROP DICTIONARY IF EXISTS simple_key_direct_dictionary;</drop_query>\n+    <drop_query>DROP DICTIONARY IF EXISTS complex_key_direct_dictionary;</drop_query>\n \n </test>\ndiff --git a/tests/performance/flat_dictionary.xml b/tests/performance/flat_dictionary.xml\nnew file mode 100644\nindex 000000000000..426aa929bbc5\n--- /dev/null\n+++ b/tests/performance/flat_dictionary.xml\n@@ -0,0 +1,75 @@\n+<test max_ignored_relative_change=\"0.3\">\n+    <create_query>\n+        CREATE TABLE simple_key_flat_dictionary_source_table\n+        (\n+            id UInt64,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY simple_key_flat_dictionary\n+        (\n+            id UInt64,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        )\n+        PRIMARY KEY id\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_key_flat_dictionary_source_table'))\n+        LAYOUT(FLAT())\n+        LIFETIME(MIN 0 MAX 1000)\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO simple_key_flat_dictionary_source_table\n+        SELECT number, number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 500000;\n+    </fill_query>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>column_name</name>\n+            <values>\n+                <value>'value_int'</value>\n+                <value>'value_string'</value>\n+                <value>'value_decimal'</value>\n+                <value>'value_string_nullable'</value>\n+            </values>\n+        </substitution>\n+\n+        <substitution>\n+            <name>elements_count</name>\n+            <values>\n+                <value>250000</value>\n+                <value>500000</value>\n+                <value>750000</value>\n+                <value>1000000</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <query>\n+        SELECT dictGet('default.simple_key_flat_dictionary', {column_name}, number)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAR Null;\n+    </query>\n+\n+    <query>\n+        SELECT dictHas('default.simple_key_flat_dictionary', number)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <drop_query>DROP TABLE IF EXISTS simple_key_flat_dictionary_source_table</drop_query>\n+\n+    <drop_query>DROP DICTIONARY IF EXISTS simple_key_flat_dictionary</drop_query>\n+\n+</test>\ndiff --git a/tests/performance/hashed_dictionary.xml b/tests/performance/hashed_dictionary.xml\nnew file mode 100644\nindex 000000000000..a38d2f30c232\n--- /dev/null\n+++ b/tests/performance/hashed_dictionary.xml\n@@ -0,0 +1,124 @@\n+<test max_ignored_relative_change=\"0.3\">\n+    <create_query>\n+        CREATE TABLE simple_key_hashed_dictionary_source_table\n+        (\n+            id UInt64,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE TABLE complex_key_hashed_dictionary_source_table\n+        (\n+            id UInt64,\n+            id_key String,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        ) ENGINE = Memory;\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY simple_key_hashed_dictionary\n+        (\n+            id UInt64,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        )\n+        PRIMARY KEY id\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'simple_key_hashed_dictionary_source_table'))\n+        LAYOUT(HASHED())\n+        LIFETIME(MIN 0 MAX 1000);\n+    </create_query>\n+\n+    <create_query>\n+        CREATE DICTIONARY complex_key_hashed_dictionary\n+        (\n+            id UInt64,\n+            id_key String,\n+            value_int UInt64,\n+            value_string String,\n+            value_decimal Decimal64(8),\n+            value_string_nullable Nullable(String)\n+        )\n+        PRIMARY KEY id, id_key\n+        SOURCE(CLICKHOUSE(DB 'default' TABLE 'complex_key_hashed_dictionary_source_table'))\n+        LAYOUT(COMPLEX_KEY_HASHED())\n+        LIFETIME(MIN 0 MAX 1000);\n+    </create_query>\n+\n+    <fill_query>\n+        INSERT INTO simple_key_hashed_dictionary_source_table\n+        SELECT number, number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 5000000;\n+    </fill_query>\n+\n+    <fill_query>\n+        INSERT INTO complex_key_hashed_dictionary_source_table\n+        SELECT number, toString(number), number, toString(number), toDecimal64(number, 8), toString(number)\n+        FROM system.numbers\n+        LIMIT 5000000;\n+    </fill_query>\n+\n+    <substitutions>\n+        <substitution>\n+            <name>column_name</name>\n+            <values>\n+                <value>'value_int'</value>\n+                <value>'value_string'</value>\n+                <value>'value_decimal'</value>\n+                <value>'value_string_nullable'</value>\n+            </values>\n+        </substitution>\n+\n+        <substitution>\n+            <name>elements_count</name>\n+            <values>\n+                <value>2500000</value>\n+                <value>5000000</value>\n+                <value>7500000</value>\n+                <value>10000000</value>\n+            </values>\n+        </substitution>\n+    </substitutions>\n+\n+    <query>\n+        SELECT dictGet('default.simple_key_hashed_dictionary', {column_name}, number)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+    <query>\n+        SELECT dictHas('default.simple_key_hashed_dictionary', number)\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <query>\n+        SELECT dictGet('default.complex_key_hashed_dictionary', {column_name}, (number, toString(number)))\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+    <query>\n+        SELECT dictHas('default.complex_key_hashed_dictionary', (number, toString(number)))\n+        FROM system.numbers\n+        LIMIT {elements_count}\n+        FORMAT Null;\n+    </query>\n+\n+    <drop_query>DROP TABLE IF EXISTS simple_key_hashed_dictionary_source_table;</drop_query>\n+    <drop_query>DROP TABLE IF EXISTS complex_key_hashed_dictionary_source_table;</drop_query>\n+\n+    <drop_query>DROP DICTIONARY IF EXISTS simple_key_hashed_dictionary;</drop_query>\n+    <drop_query>DROP DICTIONARY IF EXISTS complex_key_hashed_dictionary;</drop_query>\n+\n+</test>\ndiff --git a/tests/queries/0_stateless/01251_dict_is_in_infinite_loop.reference b/tests/queries/0_stateless/01251_dict_is_in_infinite_loop.reference\nindex 757d2858524a..0a2c97efb42a 100644\n--- a/tests/queries/0_stateless/01251_dict_is_in_infinite_loop.reference\n+++ b/tests/queries/0_stateless/01251_dict_is_in_infinite_loop.reference\n@@ -29,10 +29,10 @@\n 1\n 1\n 1\n-255\n-255\n 0\n-255\n+0\n+0\n+0\n [11,22]\n [22,11]\n [11,22]\ndiff --git a/tests/queries/0_stateless/01765_hashed_dictionary_simple_key.reference b/tests/queries/0_stateless/01765_hashed_dictionary_simple_key.reference\nnew file mode 100644\nindex 000000000000..2cc0a8668a2b\n--- /dev/null\n+++ b/tests/queries/0_stateless/01765_hashed_dictionary_simple_key.reference\n@@ -0,0 +1,132 @@\n+Dictionary hashed_dictionary_simple_key_simple_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tvalue_0\tvalue_second_0\n+1\tvalue_1\tvalue_second_1\n+2\tvalue_2\tvalue_second_2\n+Dictionary sparse_hashed_dictionary_simple_key_simple_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tvalue_0\tvalue_second_0\n+1\tvalue_1\tvalue_second_1\n+2\tvalue_2\tvalue_second_2\n+Dictionary hashed_dictionary_simple_key_complex_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tvalue_0\tvalue_second_0\n+1\tvalue_1\t\\N\n+2\tvalue_2\tvalue_second_2\n+Dictionary sparse_hashed_dictionary_simple_key_complex_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tvalue_0\tvalue_second_0\n+1\tvalue_1\t\\N\n+2\tvalue_2\tvalue_second_2\n+Dictionary hashed_dictionary_simple_key_hierarchy\n+dictGet\n+0\n+0\n+1\n+1\n+2\n+dictGetHierarchy\n+[1]\n+[4,2,1]\n+Dictionary sparse_hashed_dictionary_simple_key_hierarchy\n+dictGet\n+0\n+0\n+1\n+1\n+2\n+dictGetHierarchy\n+[1]\n+[4,2,1]\ndiff --git a/tests/queries/0_stateless/01765_hashed_dictionary_simple_key.sql b/tests/queries/0_stateless/01765_hashed_dictionary_simple_key.sql\nnew file mode 100644\nindex 000000000000..7502c6a93bbe\n--- /dev/null\n+++ b/tests/queries/0_stateless/01765_hashed_dictionary_simple_key.sql\n@@ -0,0 +1,207 @@\n+DROP DATABASE IF EXISTS 01765_db;\n+CREATE DATABASE 01765_db;\n+\n+CREATE TABLE 01765_db.simple_key_simple_attributes_source_table\n+(\n+   id UInt64,\n+   value_first String,\n+   value_second String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO 01765_db.simple_key_simple_attributes_source_table VALUES(0, 'value_0', 'value_second_0');\n+INSERT INTO 01765_db.simple_key_simple_attributes_source_table VALUES(1, 'value_1', 'value_second_1');\n+INSERT INTO 01765_db.simple_key_simple_attributes_source_table VALUES(2, 'value_2', 'value_second_2');\n+\n+CREATE DICTIONARY 01765_db.hashed_dictionary_simple_key_simple_attributes\n+(\n+   id UInt64,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second String DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_simple_attributes_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Dictionary hashed_dictionary_simple_key_simple_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.hashed_dictionary_simple_key_simple_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('01765_db.hashed_dictionary_simple_key_simple_attributes', number) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM 01765_db.hashed_dictionary_simple_key_simple_attributes ORDER BY id;\n+\n+DROP DICTIONARY 01765_db.hashed_dictionary_simple_key_simple_attributes;\n+\n+CREATE DICTIONARY 01765_db.sparse_hashed_dictionary_simple_key_simple_attributes\n+(\n+   id UInt64,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second String DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_simple_attributes_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(SPARSE_HASHED());\n+\n+SELECT 'Dictionary sparse_hashed_dictionary_simple_key_simple_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('01765_db.sparse_hashed_dictionary_simple_key_simple_attributes', number) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM 01765_db.sparse_hashed_dictionary_simple_key_simple_attributes ORDER BY id;\n+\n+DROP DICTIONARY 01765_db.sparse_hashed_dictionary_simple_key_simple_attributes;\n+\n+DROP TABLE 01765_db.simple_key_simple_attributes_source_table;\n+\n+CREATE TABLE 01765_db.simple_key_complex_attributes_source_table\n+(\n+   id UInt64,\n+   value_first String,\n+   value_second Nullable(String)\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO 01765_db.simple_key_complex_attributes_source_table VALUES(0, 'value_0', 'value_second_0');\n+INSERT INTO 01765_db.simple_key_complex_attributes_source_table VALUES(1, 'value_1', NULL);\n+INSERT INTO 01765_db.simple_key_complex_attributes_source_table VALUES(2, 'value_2', 'value_second_2');\n+\n+CREATE DICTIONARY 01765_db.hashed_dictionary_simple_key_complex_attributes\n+(\n+   id UInt64,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second Nullable(String) DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_complex_attributes_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Dictionary hashed_dictionary_simple_key_complex_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.hashed_dictionary_simple_key_complex_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('01765_db.hashed_dictionary_simple_key_complex_attributes', number) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM 01765_db.hashed_dictionary_simple_key_complex_attributes ORDER BY id;\n+\n+DROP DICTIONARY 01765_db.hashed_dictionary_simple_key_complex_attributes;\n+\n+CREATE DICTIONARY 01765_db.sparse_hashed_dictionary_simple_key_complex_attributes\n+(\n+   id UInt64,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second Nullable(String) DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_complex_attributes_source_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Dictionary sparse_hashed_dictionary_simple_key_complex_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_first', number) as value_first,\n+    dictGet('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_second', number) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_first', number, toString('default')) as value_first,\n+    dictGetOrDefault('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', 'value_second', number, toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('01765_db.sparse_hashed_dictionary_simple_key_complex_attributes', number) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM 01765_db.sparse_hashed_dictionary_simple_key_complex_attributes ORDER BY id;\n+\n+DROP DICTIONARY 01765_db.sparse_hashed_dictionary_simple_key_complex_attributes;\n+\n+DROP TABLE 01765_db.simple_key_complex_attributes_source_table;\n+\n+CREATE TABLE 01765_db.simple_key_hierarchy_table\n+(\n+    id UInt64,\n+    parent_id UInt64\n+) ENGINE = TinyLog();\n+\n+INSERT INTO 01765_db.simple_key_hierarchy_table VALUES (1, 0);\n+INSERT INTO 01765_db.simple_key_hierarchy_table VALUES (2, 1);\n+INSERT INTO 01765_db.simple_key_hierarchy_table VALUES (3, 1);\n+INSERT INTO 01765_db.simple_key_hierarchy_table VALUES (4, 2);\n+\n+CREATE DICTIONARY 01765_db.hashed_dictionary_simple_key_hierarchy\n+(\n+   id UInt64,\n+   parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_hierarchy_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Dictionary hashed_dictionary_simple_key_hierarchy';\n+SELECT 'dictGet';\n+SELECT dictGet('01765_db.hashed_dictionary_simple_key_hierarchy', 'parent_id', number) FROM system.numbers LIMIT 5;\n+SELECT 'dictGetHierarchy';\n+SELECT dictGetHierarchy('01765_db.hashed_dictionary_simple_key_hierarchy', toUInt64(1));\n+SELECT dictGetHierarchy('01765_db.hashed_dictionary_simple_key_hierarchy', toUInt64(4));\n+\n+DROP DICTIONARY 01765_db.hashed_dictionary_simple_key_hierarchy;\n+\n+CREATE DICTIONARY 01765_db.sparse_hashed_dictionary_simple_key_hierarchy\n+(\n+   id UInt64,\n+   parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'simple_key_hierarchy_table'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(HASHED());\n+\n+SELECT 'Dictionary sparse_hashed_dictionary_simple_key_hierarchy';\n+SELECT 'dictGet';\n+SELECT dictGet('01765_db.sparse_hashed_dictionary_simple_key_hierarchy', 'parent_id', number) FROM system.numbers LIMIT 5;\n+SELECT 'dictGetHierarchy';\n+SELECT dictGetHierarchy('01765_db.sparse_hashed_dictionary_simple_key_hierarchy', toUInt64(1));\n+SELECT dictGetHierarchy('01765_db.sparse_hashed_dictionary_simple_key_hierarchy', toUInt64(4));\n+\n+DROP DICTIONARY 01765_db.sparse_hashed_dictionary_simple_key_hierarchy;\n+\n+DROP TABLE 01765_db.simple_key_hierarchy_table;\n+\n+DROP DATABASE 01765_db;\ndiff --git a/tests/queries/0_stateless/01766_hashed_dictionary_complex_key.reference b/tests/queries/0_stateless/01766_hashed_dictionary_complex_key.reference\nnew file mode 100644\nindex 000000000000..12c210581c23\n--- /dev/null\n+++ b/tests/queries/0_stateless/01766_hashed_dictionary_complex_key.reference\n@@ -0,0 +1,56 @@\n+Dictionary hashed_dictionary_complex_key_simple_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\tvalue_second_1\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tid_key_0\tvalue_0\tvalue_second_0\n+1\tid_key_1\tvalue_1\tvalue_second_1\n+2\tid_key_2\tvalue_2\tvalue_second_2\n+Dictionary hashed_dictionary_complex_key_complex_attributes\n+dictGet existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGet with non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+value_first_default\tvalue_second_default\n+dictGetOrDefault existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+dictGetOrDefault non existing value\n+value_0\tvalue_second_0\n+value_1\t\\N\n+value_2\tvalue_second_2\n+default\tdefault\n+dictHas\n+1\n+1\n+1\n+0\n+select all values as input stream\n+0\tid_key_0\tvalue_0\tvalue_second_0\n+1\tid_key_1\tvalue_1\t\\N\n+2\tid_key_2\tvalue_2\tvalue_second_2\ndiff --git a/tests/queries/0_stateless/01766_hashed_dictionary_complex_key.sql b/tests/queries/0_stateless/01766_hashed_dictionary_complex_key.sql\nnew file mode 100644\nindex 000000000000..de7ab5b5a1a4\n--- /dev/null\n+++ b/tests/queries/0_stateless/01766_hashed_dictionary_complex_key.sql\n@@ -0,0 +1,98 @@\n+DROP DATABASE IF EXISTS 01766_db;\n+CREATE DATABASE 01766_db;\n+\n+CREATE TABLE 01766_db.complex_key_simple_attributes_source_table\n+(\n+   id UInt64,\n+   id_key String,\n+   value_first String,\n+   value_second String\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO 01766_db.complex_key_simple_attributes_source_table VALUES(0, 'id_key_0', 'value_0', 'value_second_0');\n+INSERT INTO 01766_db.complex_key_simple_attributes_source_table VALUES(1, 'id_key_1', 'value_1', 'value_second_1');\n+INSERT INTO 01766_db.complex_key_simple_attributes_source_table VALUES(2, 'id_key_2', 'value_2', 'value_second_2');\n+\n+CREATE DICTIONARY 01766_db.hashed_dictionary_complex_key_simple_attributes\n+(\n+   id UInt64,\n+   id_key String,\n+   value_first String DEFAULT 'value_first_default',\n+   value_second String DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id, id_key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'complex_key_simple_attributes_source_table' DB '01766_db'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(COMPLEX_KEY_HASHED());\n+\n+SELECT 'Dictionary hashed_dictionary_complex_key_simple_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('01766_db.hashed_dictionary_complex_key_simple_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('01766_db.hashed_dictionary_complex_key_simple_attributes', (number, concat('id_key_', toString(number)))) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM 01766_db.hashed_dictionary_complex_key_simple_attributes ORDER BY (id, id_key);\n+\n+DROP DICTIONARY 01766_db.hashed_dictionary_complex_key_simple_attributes;\n+\n+DROP TABLE 01766_db.complex_key_simple_attributes_source_table;\n+\n+CREATE TABLE 01766_db.complex_key_complex_attributes_source_table\n+(\n+   id UInt64,\n+   id_key String,\n+   value_first String,\n+   value_second Nullable(String)\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO 01766_db.complex_key_complex_attributes_source_table VALUES(0, 'id_key_0', 'value_0', 'value_second_0');\n+INSERT INTO 01766_db.complex_key_complex_attributes_source_table VALUES(1, 'id_key_1', 'value_1', NULL);\n+INSERT INTO 01766_db.complex_key_complex_attributes_source_table VALUES(2, 'id_key_2', 'value_2', 'value_second_2');\n+\n+CREATE DICTIONARY 01766_db.hashed_dictionary_complex_key_complex_attributes\n+(\n+    id UInt64,\n+    id_key String,\n+\n+    value_first String DEFAULT 'value_first_default',\n+    value_second Nullable(String) DEFAULT 'value_second_default'\n+)\n+PRIMARY KEY id, id_key\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'complex_key_complex_attributes_source_table' DB '01766_db'))\n+LIFETIME(MIN 1 MAX 1000)\n+LAYOUT(COMPLEX_KEY_HASHED());\n+\n+SELECT 'Dictionary hashed_dictionary_complex_key_complex_attributes';\n+SELECT 'dictGet existing value';\n+SELECT dictGet('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGet with non existing value';\n+SELECT dictGet('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number)))) as value_first,\n+    dictGet('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number)))) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictGetOrDefault existing value';\n+SELECT dictGetOrDefault('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 3;\n+SELECT 'dictGetOrDefault non existing value';\n+SELECT dictGetOrDefault('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_first', (number, concat('id_key_', toString(number))), toString('default')) as value_first,\n+    dictGetOrDefault('01766_db.hashed_dictionary_complex_key_complex_attributes', 'value_second', (number, concat('id_key_', toString(number))), toString('default')) as value_second FROM system.numbers LIMIT 4;\n+SELECT 'dictHas';\n+SELECT dictHas('01766_db.hashed_dictionary_complex_key_complex_attributes', (number, concat('id_key_', toString(number)))) FROM system.numbers LIMIT 4;\n+SELECT 'select all values as input stream';\n+SELECT * FROM 01766_db.hashed_dictionary_complex_key_complex_attributes ORDER BY (id, id_key);\n+\n+DROP DICTIONARY 01766_db.hashed_dictionary_complex_key_complex_attributes;\n+DROP TABLE 01766_db.complex_key_complex_attributes_source_table;\n+\n+DROP DATABASE 01766_db;\ndiff --git a/tests/queries/0_stateless/01778_hierarchical_dictionaries.reference b/tests/queries/0_stateless/01778_hierarchical_dictionaries.reference\nnew file mode 100644\nindex 000000000000..5fe5f5f1db6a\n--- /dev/null\n+++ b/tests/queries/0_stateless/01778_hierarchical_dictionaries.reference\n@@ -0,0 +1,102 @@\n+Flat dictionary\n+Get hierarchy\n+[]\n+[1]\n+[2,1]\n+[3,1]\n+[4,2,1]\n+[]\n+Get is in hierarchy\n+0\n+1\n+1\n+1\n+1\n+0\n+Get children\n+[1]\n+[2,3]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,2,3,4]\n+[2,3,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[2,3]\n+[4]\n+[]\n+[]\n+[]\n+Hashed dictionary\n+Get hierarchy\n+[]\n+[1]\n+[2,1]\n+[3,1]\n+[4,2,1]\n+[]\n+Get is in hierarchy\n+0\n+1\n+1\n+1\n+1\n+0\n+Get children\n+[1]\n+[3,2]\n+[4]\n+[]\n+[]\n+[]\n+Get all descendants\n+[1,3,2,4]\n+[3,2,4]\n+[4]\n+[]\n+[]\n+[]\n+Get descendants at first level\n+[1]\n+[3,2]\n+[4]\n+[]\n+[]\n+[]\n+Cache dictionary\n+Get hierarchy\n+[]\n+[1]\n+[2,1]\n+[3,1]\n+[4,2,1]\n+[]\n+Get is in hierarchy\n+0\n+1\n+1\n+1\n+1\n+0\n+Direct dictionary\n+Get hierarchy\n+[]\n+[1]\n+[2,1]\n+[3,1]\n+[4,2,1]\n+[]\n+Get is in hierarchy\n+0\n+1\n+1\n+1\n+1\n+0\ndiff --git a/tests/queries/0_stateless/01778_hierarchical_dictionaries.sql b/tests/queries/0_stateless/01778_hierarchical_dictionaries.sql\nnew file mode 100644\nindex 000000000000..f6e1a7c9375c\n--- /dev/null\n+++ b/tests/queries/0_stateless/01778_hierarchical_dictionaries.sql\n@@ -0,0 +1,95 @@\n+DROP DATABASE IF EXISTS 01778_db;\n+CREATE DATABASE 01778_db;\n+\n+CREATE TABLE 01778_db.hierarchy_source_table (id UInt64, parent_id UInt64) ENGINE = TinyLog;\n+INSERT INTO 01778_db.hierarchy_source_table VALUES (1, 0), (2, 1), (3, 1), (4, 2);\n+\n+CREATE DICTIONARY 01778_db.hierarchy_flat_dictionary\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'hierarchy_source_table' DB '01778_db'))\n+LAYOUT(FLAT())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Flat dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('01778_db.hierarchy_flat_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('01778_db.hierarchy_flat_dictionary', number, number) FROM system.numbers LIMIT 6;\n+SELECT 'Get children';\n+SELECT dictGetChildren('01778_db.hierarchy_flat_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('01778_db.hierarchy_flat_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('01778_db.hierarchy_flat_dictionary', number, 1) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY 01778_db.hierarchy_flat_dictionary;\n+\n+CREATE DICTIONARY 01778_db.hierarchy_hashed_dictionary\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'hierarchy_source_table' DB '01778_db'))\n+LAYOUT(HASHED())\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Hashed dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('01778_db.hierarchy_hashed_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('01778_db.hierarchy_hashed_dictionary', number, number) FROM system.numbers LIMIT 6;\n+SELECT 'Get children';\n+SELECT dictGetChildren('01778_db.hierarchy_hashed_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get all descendants';\n+SELECT dictGetDescendants('01778_db.hierarchy_hashed_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get descendants at first level';\n+SELECT dictGetDescendants('01778_db.hierarchy_hashed_dictionary', number, 1) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY 01778_db.hierarchy_hashed_dictionary;\n+\n+CREATE DICTIONARY 01778_db.hierarchy_cache_dictionary\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'hierarchy_source_table' DB '01778_db'))\n+LAYOUT(CACHE(SIZE_IN_CELLS 10))\n+LIFETIME(MIN 1 MAX 1000);\n+\n+SELECT 'Cache dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('01778_db.hierarchy_cache_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('01778_db.hierarchy_cache_dictionary', number, number) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY 01778_db.hierarchy_cache_dictionary;\n+\n+CREATE DICTIONARY 01778_db.hierarchy_direct_dictionary\n+(\n+    id UInt64,\n+    parent_id UInt64 HIERARCHICAL\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'hierarchy_source_table' DB '01778_db'))\n+LAYOUT(DIRECT());\n+\n+SELECT 'Direct dictionary';\n+\n+SELECT 'Get hierarchy';\n+SELECT dictGetHierarchy('01778_db.hierarchy_direct_dictionary', number) FROM system.numbers LIMIT 6;\n+SELECT 'Get is in hierarchy';\n+SELECT dictIsIn('01778_db.hierarchy_direct_dictionary', number, number) FROM system.numbers LIMIT 6;\n+\n+DROP DICTIONARY 01778_db.hierarchy_direct_dictionary;\n+\n+DROP TABLE 01778_db.hierarchy_source_table;\n+DROP DATABASE 01778_db;\ndiff --git a/tests/queries/skip_list.json b/tests/queries/skip_list.json\nindex df2090325a33..627b76827a81 100644\n--- a/tests/queries/skip_list.json\n+++ b/tests/queries/skip_list.json\n@@ -679,6 +679,19 @@\n         \"live_view\",\n         \"memory_leak\",\n         \"memory_limit\",\n-        \"polygon_dicts\" // they use an explicitly specified database\n+        \"polygon_dicts\", // they use an explicitly specified database\n+        \"01658_read_file_to_stringcolumn\",\n+        \"01721_engine_file_truncate_on_insert\", // It's ok to execute in parallel but not several instances of the same test.\n+        \"01702_system_query_log\", // It's ok to execute in parallel with oter tests but not several instances of the same test.\n+        \"01748_dictionary_table_dot\", // creates database\n+        \"00950_dict_get\",\n+        \"01683_flat_dictionary\",\n+        \"01681_cache_dictionary_simple_key\",\n+        \"01682_cache_dictionary_complex_key\",\n+        \"01684_ssd_cache_dictionary_simple_key\",\n+        \"01685_ssd_cache_dictionary_complex_key\",\n+        \"01760_system_dictionaries\",\n+        \"01760_polygon_dictionaries\",\n+        \"01778_hierarchical_dictionaries\"\n     ]\n }\n",
  "problem_statement": "Support bidirectional hierarchies in dictionaries and dictGetChildren/dictGetDescendants\n**Use case**\r\nIt's a frequent use case to get all children/descendants of an element in any data structure representing topology. \r\nClickhouse already has `dictGetHierarchy` that allows to get all parents. \r\nThere is unfortunately no way to get all children of particular elements.\r\n\r\n**Describe the solution you'd like**\r\nSupport additional bidirectional hierarchical dictionaries, or improve current dictionaries to support getting all children within single function call. \r\nsomething like below is needed:\r\n```\r\nselect dictGetChildren( 'dictname',key); -- returns first level children\r\nselect dictGetDescendants( 'dictname',key, lvl); -- returns descendants within levels specified by lvl, if lvl=0 returns all descendants to the end\r\n```\r\n**Describe alternatives you've considered**\r\nthis does the job, but does not scale well. Also given array is copied every time on lambda, it's simply poor performing when there are many rows\r\n```\r\nwith\r\n(\r\nselect groupArray(objid) from selectedobjects\r\n) as filterArr\r\nselect * from allobjects\r\nwhere\r\nhasAny (\r\n    dictGetHierarchy( 'schema.dictname',objid), filterArr\r\n)\r\n```\r\n\r\n**Additional context**\r\nWe discussed it in meetup in May...\r\n\n",
  "hints_text": "",
  "created_at": "2021-03-24T16:32:10Z"
}