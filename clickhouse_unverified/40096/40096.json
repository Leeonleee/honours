{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 40096,
  "instance_id": "ClickHouse__ClickHouse-40096",
  "issue_numbers": [
    "35757"
  ],
  "base_commit": "a8e4f5be0969e5766482c482c9c1889ac8a54437",
  "patch": "diff --git a/programs/client/Client.cpp b/programs/client/Client.cpp\nindex 303c8c2ce4f6..ce98cc2c00e4 100644\n--- a/programs/client/Client.cpp\n+++ b/programs/client/Client.cpp\n@@ -12,6 +12,7 @@\n #include <string>\n #include \"Client.h\"\n #include \"Core/Protocol.h\"\n+#include \"Parsers/formatAST.h\"\n \n #include <base/find_symbols.h>\n \n@@ -514,6 +515,66 @@ static bool queryHasWithClause(const IAST & ast)\n     return false;\n }\n \n+std::optional<bool> Client::processFuzzingStep(const String & query_to_execute, const ASTPtr & parsed_query)\n+{\n+    processParsedSingleQuery(query_to_execute, query_to_execute, parsed_query);\n+\n+    const auto * exception = server_exception ? server_exception.get() : client_exception.get();\n+    // Sometimes you may get TOO_DEEP_RECURSION from the server,\n+    // and TOO_DEEP_RECURSION should not fail the fuzzer check.\n+    if (have_error && exception->code() == ErrorCodes::TOO_DEEP_RECURSION)\n+    {\n+        have_error = false;\n+        server_exception.reset();\n+        client_exception.reset();\n+        return true;\n+    }\n+\n+    if (have_error)\n+    {\n+        fmt::print(stderr, \"Error on processing query '{}': {}\\n\", parsed_query->formatForErrorMessage(), exception->message());\n+\n+        // Try to reconnect after errors, for two reasons:\n+        // 1. We might not have realized that the server died, e.g. if\n+        //    it sent us a <Fatal> trace and closed connection properly.\n+        // 2. The connection might have gotten into a wrong state and\n+        //    the next query will get false positive about\n+        //    \"Unknown packet from server\".\n+        try\n+        {\n+            connection->forceConnected(connection_parameters.timeouts);\n+        }\n+        catch (...)\n+        {\n+            // Just report it, we'll terminate below.\n+            fmt::print(stderr,\n+                \"Error while reconnecting to the server: {}\\n\",\n+                getCurrentExceptionMessage(true));\n+\n+            // The reconnection might fail, but we'll still be connected\n+            // in the sense of `connection->isConnected() = true`,\n+            // in case when the requested database doesn't exist.\n+            // Disconnect manually now, so that the following code doesn't\n+            // have any doubts, and the connection state is predictable.\n+            connection->disconnect();\n+        }\n+    }\n+\n+    if (!connection->isConnected())\n+    {\n+        // Probably the server is dead because we found an assertion\n+        // failure. Fail fast.\n+        fmt::print(stderr, \"Lost connection to the server.\\n\");\n+\n+        // Print the changed settings because they might be needed to\n+        // reproduce the error.\n+        printChangedSettings();\n+\n+        return false;\n+    }\n+\n+    return std::nullopt;\n+}\n \n /// Returns false when server is not available.\n bool Client::processWithFuzzing(const String & full_query)\n@@ -558,18 +619,33 @@ bool Client::processWithFuzzing(const String & full_query)\n     // - SET    -- The time to fuzz the settings has not yet come\n     //             (see comments in Client/QueryFuzzer.cpp)\n     size_t this_query_runs = query_fuzzer_runs;\n-    if (orig_ast->as<ASTInsertQuery>() ||\n-        orig_ast->as<ASTCreateQuery>() ||\n-        orig_ast->as<ASTDropQuery>() ||\n-        orig_ast->as<ASTSetQuery>())\n+    ASTs queries_for_fuzzed_tables;\n+\n+    if (orig_ast->as<ASTSetQuery>())\n     {\n         this_query_runs = 1;\n     }\n+    else if (const auto * create = orig_ast->as<ASTCreateQuery>())\n+    {\n+        if (QueryFuzzer::isSuitableForFuzzing(*create))\n+            this_query_runs = create_query_fuzzer_runs;\n+        else\n+            this_query_runs = 1;\n+    }\n+    else if (const auto * insert = orig_ast->as<ASTInsertQuery>())\n+    {\n+        this_query_runs = 1;\n+        queries_for_fuzzed_tables = fuzzer.getInsertQueriesForFuzzedTables(full_query);\n+    }\n+    else if (const auto * drop = orig_ast->as<ASTDropQuery>())\n+    {\n+        this_query_runs = 1;\n+        queries_for_fuzzed_tables = fuzzer.getDropQueriesForFuzzedTables(*drop);\n+    }\n \n     String query_to_execute;\n-    ASTPtr parsed_query;\n-\n     ASTPtr fuzz_base = orig_ast;\n+\n     for (size_t fuzz_step = 0; fuzz_step < this_query_runs; ++fuzz_step)\n     {\n         fmt::print(stderr, \"Fuzzing step {} out of {}\\n\", fuzz_step, this_query_runs);\n@@ -630,9 +706,9 @@ bool Client::processWithFuzzing(const String & full_query)\n                 continue;\n             }\n \n-            parsed_query = ast_to_process;\n-            query_to_execute = parsed_query->formatForErrorMessage();\n-            processParsedSingleQuery(full_query, query_to_execute, parsed_query);\n+            query_to_execute = ast_to_process->formatForErrorMessage();\n+            if (auto res = processFuzzingStep(query_to_execute, ast_to_process))\n+                return *res;\n         }\n         catch (...)\n         {\n@@ -645,60 +721,6 @@ bool Client::processWithFuzzing(const String & full_query)\n             have_error = true;\n         }\n \n-        const auto * exception = server_exception ? server_exception.get() : client_exception.get();\n-        // Sometimes you may get TOO_DEEP_RECURSION from the server,\n-        // and TOO_DEEP_RECURSION should not fail the fuzzer check.\n-        if (have_error && exception->code() == ErrorCodes::TOO_DEEP_RECURSION)\n-        {\n-            have_error = false;\n-            server_exception.reset();\n-            client_exception.reset();\n-            return true;\n-        }\n-\n-        if (have_error)\n-        {\n-            fmt::print(stderr, \"Error on processing query '{}': {}\\n\", ast_to_process->formatForErrorMessage(), exception->message());\n-\n-            // Try to reconnect after errors, for two reasons:\n-            // 1. We might not have realized that the server died, e.g. if\n-            //    it sent us a <Fatal> trace and closed connection properly.\n-            // 2. The connection might have gotten into a wrong state and\n-            //    the next query will get false positive about\n-            //    \"Unknown packet from server\".\n-            try\n-            {\n-                connection->forceConnected(connection_parameters.timeouts);\n-            }\n-            catch (...)\n-            {\n-                // Just report it, we'll terminate below.\n-                fmt::print(stderr,\n-                    \"Error while reconnecting to the server: {}\\n\",\n-                    getCurrentExceptionMessage(true));\n-\n-                // The reconnection might fail, but we'll still be connected\n-                // in the sense of `connection->isConnected() = true`,\n-                // in case when the requested database doesn't exist.\n-                // Disconnect manually now, so that the following code doesn't\n-                // have any doubts, and the connection state is predictable.\n-                connection->disconnect();\n-            }\n-        }\n-\n-        if (!connection->isConnected())\n-        {\n-            // Probably the server is dead because we found an assertion\n-            // failure. Fail fast.\n-            fmt::print(stderr, \"Lost connection to the server.\\n\");\n-\n-            // Print the changed settings because they might be needed to\n-            // reproduce the error.\n-            printChangedSettings();\n-\n-            return false;\n-        }\n-\n         // Check that after the query is formatted, we can parse it back,\n         // format again and get the same result. Unfortunately, we can't\n         // compare the ASTs, which would be more sensitive to errors. This\n@@ -729,13 +751,12 @@ bool Client::processWithFuzzing(const String & full_query)\n         // query, but second and third.\n         // If you have to add any more workarounds to this check, just remove\n         // it altogether, it's not so useful.\n-        if (parsed_query && !have_error && !queryHasWithClause(*parsed_query))\n+        if (ast_to_process && !have_error && !queryHasWithClause(*ast_to_process))\n         {\n             ASTPtr ast_2;\n             try\n             {\n                 const auto * tmp_pos = query_to_execute.c_str();\n-\n                 ast_2 = parseQuery(tmp_pos, tmp_pos + query_to_execute.size(), false /* allow_multi_statements */);\n             }\n             catch (Exception & e)\n@@ -762,7 +783,7 @@ bool Client::processWithFuzzing(const String & full_query)\n                         \"Got the following (different) text after formatting the fuzzed query and parsing it back:\\n'{}'\\n, expected:\\n'{}'\\n\",\n                         text_3, text_2);\n                     fmt::print(stderr, \"In more detail:\\n\");\n-                    fmt::print(stderr, \"AST-1 (generated by fuzzer):\\n'{}'\\n\", parsed_query->dumpTree());\n+                    fmt::print(stderr, \"AST-1 (generated by fuzzer):\\n'{}'\\n\", ast_to_process->dumpTree());\n                     fmt::print(stderr, \"Text-1 (AST-1 formatted):\\n'{}'\\n\", query_to_execute);\n                     fmt::print(stderr, \"AST-2 (Text-1 parsed):\\n'{}'\\n\", ast_2->dumpTree());\n                     fmt::print(stderr, \"Text-2 (AST-2 formatted):\\n'{}'\\n\", text_2);\n@@ -784,6 +805,7 @@ bool Client::processWithFuzzing(const String & full_query)\n             // so that it doesn't influence the exit code.\n             server_exception.reset();\n             client_exception.reset();\n+            fuzzer.notifyQueryFailed(ast_to_process);\n             have_error = false;\n         }\n         else if (ast_to_process->formatForErrorMessage().size() > 500)\n@@ -800,6 +822,35 @@ bool Client::processWithFuzzing(const String & full_query)\n         }\n     }\n \n+    for (const auto & query : queries_for_fuzzed_tables)\n+    {\n+        std::cout << std::endl;\n+        WriteBufferFromOStream ast_buf(std::cout, 4096);\n+        formatAST(*query, ast_buf, false /*highlight*/);\n+        ast_buf.next();\n+        std::cout << std::endl << std::endl;\n+\n+        try\n+        {\n+            query_to_execute = query->formatForErrorMessage();\n+            if (auto res = processFuzzingStep(query_to_execute, query))\n+                return *res;\n+        }\n+        catch (...)\n+        {\n+            client_exception = std::make_unique<Exception>(getCurrentExceptionMessage(print_stack_trace), getCurrentExceptionCode());\n+            have_error = true;\n+        }\n+\n+        if (have_error)\n+        {\n+            server_exception.reset();\n+            client_exception.reset();\n+            fuzzer.notifyQueryFailed(query);\n+            have_error = false;\n+        }\n+    }\n+\n     return true;\n }\n \n@@ -834,6 +885,7 @@ void Client::addOptions(OptionsDescription & options_description)\n         (\"compression\", po::value<bool>(), \"enable or disable compression (enabled by default for remote communication and disabled for localhost communication).\")\n \n         (\"query-fuzzer-runs\", po::value<int>()->default_value(0), \"After executing every SELECT query, do random mutations in it and run again specified number of times. This is used for testing to discover unexpected corner cases.\")\n+        (\"create-query-fuzzer-runs\", po::value<int>()->default_value(0), \"\")\n         (\"interleave-queries-file\", po::value<std::vector<std::string>>()->multitoken(),\n             \"file path with queries to execute before every file from 'queries-file'; multiple files can be specified (--queries-file file1 file2...); this is needed to enable more aggressive fuzzing of newly added tests (see 'query-fuzzer-runs' option)\")\n \n@@ -994,6 +1046,17 @@ void Client::processOptions(const OptionsDescription & options_description,\n         ignore_error = true;\n     }\n \n+    if ((create_query_fuzzer_runs = options[\"create-query-fuzzer-runs\"].as<int>()))\n+    {\n+        // Fuzzer implies multiquery.\n+        config().setBool(\"multiquery\", true);\n+        // Ignore errors in parsing queries.\n+        config().setBool(\"ignore-error\", true);\n+\n+        global_context->setSetting(\"allow_suspicious_low_cardinality_types\", true);\n+        ignore_error = true;\n+    }\n+\n     if (options.count(\"opentelemetry-traceparent\"))\n     {\n         String traceparent = options[\"opentelemetry-traceparent\"].as<std::string>();\ndiff --git a/programs/client/Client.h b/programs/client/Client.h\nindex 1fec282be516..63f28ca96a28 100644\n--- a/programs/client/Client.h\n+++ b/programs/client/Client.h\n@@ -17,6 +17,7 @@ class Client : public ClientBase\n \n protected:\n     bool processWithFuzzing(const String & full_query) override;\n+    std::optional<bool> processFuzzingStep(const String & query_to_execute, const ASTPtr & parsed_query);\n \n     void connect() override;\n \ndiff --git a/src/Client/ClientBase.h b/src/Client/ClientBase.h\nindex 3a8fea5c0dc6..01edb65e1353 100644\n--- a/src/Client/ClientBase.h\n+++ b/src/Client/ClientBase.h\n@@ -251,6 +251,7 @@ class ClientBase : public Poco::Util::Application, public IHints<2, ClientBase>\n \n     QueryFuzzer fuzzer;\n     int query_fuzzer_runs = 0;\n+    int create_query_fuzzer_runs = 0;\n \n     struct\n     {\ndiff --git a/src/Client/QueryFuzzer.cpp b/src/Client/QueryFuzzer.cpp\nindex 5e231108beda..e6905d8dc3c6 100644\n--- a/src/Client/QueryFuzzer.cpp\n+++ b/src/Client/QueryFuzzer.cpp\n@@ -1,4 +1,22 @@\n #include \"QueryFuzzer.h\"\n+#include <DataTypes/DataTypeArray.h>\n+#include <DataTypes/DataTypeFactory.h>\n+#include <DataTypes/DataTypeFixedString.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypeMap.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeTuple.h>\n+#include <DataTypes/DataTypesNumber.h>\n+#include <DataTypes/DataTypesDecimal.h>\n+#include <DataTypes/IDataType.h>\n+#include <IO/ReadBufferFromString.h>\n+#include <IO/WriteHelpers.h>\n+#include <Parsers/ASTColumnDeclaration.h>\n+#include <Parsers/ASTCreateQuery.h>\n+#include <Parsers/IAST_fwd.h>\n+#include <Parsers/ParserDataType.h>\n+#include <Parsers/ParserInsertQuery.h>\n+#include <Parsers/ASTDropQuery.h>\n \n #include <unordered_set>\n \n@@ -430,6 +448,303 @@ void QueryFuzzer::fuzzWindowFrame(ASTWindowDefinition & def)\n     }\n }\n \n+bool QueryFuzzer::isSuitableForFuzzing(const ASTCreateQuery & create)\n+{\n+    return create.columns_list && create.columns_list->columns;\n+}\n+\n+void QueryFuzzer::fuzzCreateQuery(ASTCreateQuery & create)\n+{\n+    if (create.columns_list && create.columns_list->columns)\n+    {\n+        for (auto & ast : create.columns_list->columns->children)\n+        {\n+            if (auto * column = ast->as<ASTColumnDeclaration>())\n+            {\n+                fuzzColumnDeclaration(*column);\n+            }\n+        }\n+    }\n+\n+    if (create.storage && create.storage->engine)\n+    {\n+        /// Replace ReplicatedMergeTree to ordinary MergeTree\n+        /// to avoid inconsistency of metadata in zookeeper.\n+        auto & engine_name = create.storage->engine->name;\n+        if (startsWith(engine_name, \"Replicated\"))\n+        {\n+            engine_name = engine_name.substr(strlen(\"Replicated\"));\n+            if (auto & arguments = create.storage->engine->arguments)\n+            {\n+                auto & children = arguments->children;\n+                if (children.size() <= 2)\n+                    arguments.reset();\n+                else\n+                    children.erase(children.begin(), children.begin() + 2);\n+            }\n+        }\n+    }\n+\n+    auto full_name = create.getTable();\n+    auto original_name = full_name.substr(0, full_name.find(\"__fuzz_\"));\n+\n+    size_t index = index_of_fuzzed_table[original_name]++;\n+    auto new_name = original_name + \"__fuzz_\" + toString(index);\n+\n+    create.setTable(new_name);\n+\n+    SipHash sip_hash;\n+    sip_hash.update(original_name);\n+    if (create.columns_list)\n+        create.columns_list->updateTreeHash(sip_hash);\n+    if (create.storage)\n+        create.storage->updateTreeHash(sip_hash);\n+\n+    IAST::Hash hash;\n+    sip_hash.get128(hash);\n+\n+    /// Save only tables with unique definition.\n+    if (created_tables_hashes.insert(hash).second)\n+        original_table_name_to_fuzzed[original_name].insert(new_name);\n+}\n+\n+void QueryFuzzer::fuzzColumnDeclaration(ASTColumnDeclaration & column)\n+{\n+    if (column.type)\n+    {\n+        auto data_type = fuzzDataType(DataTypeFactory::instance().get(column.type));\n+\n+        ParserDataType parser;\n+        column.type = parseQuery(parser, data_type->getName(), DBMS_DEFAULT_MAX_QUERY_SIZE, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n+    }\n+}\n+\n+DataTypePtr QueryFuzzer::fuzzDataType(DataTypePtr type)\n+{\n+    /// Do not replace Array/Tuple/etc. with not Array/Tuple too often.\n+    const auto * type_array = typeid_cast<const DataTypeArray *>(type.get());\n+    if (type_array && fuzz_rand() % 4 != 0)\n+        return std::make_shared<DataTypeArray>(fuzzDataType(type_array->getNestedType()));\n+\n+    const auto * type_tuple = typeid_cast<const DataTypeTuple *>(type.get());\n+    if (type_tuple && fuzz_rand() % 4 != 0)\n+    {\n+        DataTypes elements;\n+        for (const auto & element : type_tuple->getElements())\n+            elements.push_back(fuzzDataType(element));\n+\n+        return type_tuple->haveExplicitNames()\n+            ? std::make_shared<DataTypeTuple>(elements, type_tuple->getElementNames())\n+            : std::make_shared<DataTypeTuple>(elements);\n+    }\n+\n+    const auto * type_map = typeid_cast<const DataTypeMap *>(type.get());\n+    if (type_map && fuzz_rand() % 4 != 0)\n+    {\n+        auto key_type = fuzzDataType(type_map->getKeyType());\n+        auto value_type = fuzzDataType(type_map->getValueType());\n+        if (!DataTypeMap::checkKeyType(key_type))\n+            key_type = type_map->getKeyType();\n+\n+        return std::make_shared<DataTypeMap>(key_type, value_type);\n+    }\n+\n+    const auto * type_nullable = typeid_cast<const DataTypeNullable *>(type.get());\n+    if (type_nullable)\n+    {\n+        size_t tmp = fuzz_rand() % 3;\n+        if (tmp == 0)\n+            return fuzzDataType(type_nullable->getNestedType());\n+\n+        if (tmp == 1)\n+        {\n+            auto nested_type = fuzzDataType(type_nullable->getNestedType());\n+            if (nested_type->canBeInsideNullable())\n+                return std::make_shared<DataTypeNullable>(nested_type);\n+        }\n+    }\n+\n+    const auto * type_low_cardinality = typeid_cast<const DataTypeLowCardinality *>(type.get());\n+    if (type_low_cardinality)\n+    {\n+        size_t tmp = fuzz_rand() % 3;\n+        if (tmp == 0)\n+            return fuzzDataType(type_low_cardinality->getDictionaryType());\n+\n+        if (tmp == 1)\n+        {\n+            auto nested_type = fuzzDataType(type_low_cardinality->getDictionaryType());\n+            if (nested_type->canBeInsideLowCardinality())\n+                return std::make_shared<DataTypeLowCardinality>(nested_type);\n+        }\n+    }\n+\n+    size_t tmp = fuzz_rand() % 8;\n+    if (tmp == 0)\n+        return std::make_shared<DataTypeArray>(type);\n+\n+    if (tmp <= 1 && type->canBeInsideNullable())\n+        return std::make_shared<DataTypeNullable>(type);\n+\n+    if (tmp <= 2 && type->canBeInsideLowCardinality())\n+        return std::make_shared<DataTypeLowCardinality>(type);\n+\n+    if (tmp <= 3)\n+        return getRandomType();\n+\n+    return type;\n+}\n+\n+DataTypePtr QueryFuzzer::getRandomType()\n+{\n+    auto type_id = static_cast<TypeIndex>(fuzz_rand() % static_cast<size_t>(TypeIndex::Tuple) + 1);\n+\n+    if (type_id == TypeIndex::Tuple)\n+    {\n+        size_t tuple_size = fuzz_rand() % 6 + 1;\n+        DataTypes elements;\n+        for (size_t i = 0; i < tuple_size; ++i)\n+            elements.push_back(getRandomType());\n+        return std::make_shared<DataTypeTuple>(elements);\n+    }\n+\n+    if (type_id == TypeIndex::Array)\n+        return std::make_shared<DataTypeArray>(getRandomType());\n+\n+/// NOLINTBEGIN(bugprone-macro-parentheses)\n+#define DISPATCH(DECIMAL) \\\n+    if (type_id == TypeIndex::DECIMAL) \\\n+        return std::make_shared<DataTypeDecimal<DECIMAL>>( \\\n+            DataTypeDecimal<DECIMAL>::maxPrecision(), \\\n+            (fuzz_rand() % DataTypeDecimal<DECIMAL>::maxPrecision()) + 1);\n+\n+    DISPATCH(Decimal32)\n+    DISPATCH(Decimal64)\n+    DISPATCH(Decimal128)\n+    DISPATCH(Decimal256)\n+#undef DISPATCH\n+/// NOLINTEND(bugprone-macro-parentheses)\n+\n+    if (type_id == TypeIndex::FixedString)\n+        return std::make_shared<DataTypeFixedString>(fuzz_rand() % 20);\n+\n+    if (type_id == TypeIndex::Enum8)\n+        return std::make_shared<DataTypeUInt8>();\n+\n+    if (type_id == TypeIndex::Enum16)\n+        return std::make_shared<DataTypeUInt16>();\n+\n+    return DataTypeFactory::instance().get(String(magic_enum::enum_name(type_id)));\n+}\n+\n+void QueryFuzzer::fuzzTableName(ASTTableExpression & table)\n+{\n+    if (!table.database_and_table_name || fuzz_rand() % 3 == 0)\n+        return;\n+\n+    const auto * identifier = table.database_and_table_name->as<ASTTableIdentifier>();\n+    if (!identifier)\n+        return;\n+\n+    auto table_id = identifier->getTableId();\n+    if (table_id.empty())\n+        return;\n+\n+    auto it = original_table_name_to_fuzzed.find(table_id.getTableName());\n+    if (it != original_table_name_to_fuzzed.end() && !it->second.empty())\n+    {\n+        auto new_table_name = it->second.begin();\n+        std::advance(new_table_name, fuzz_rand() % it->second.size());\n+        StorageID new_table_id(table_id.database_name, *new_table_name);\n+        table.database_and_table_name = std::make_shared<ASTTableIdentifier>(new_table_id);\n+    }\n+}\n+\n+static ASTPtr tryParseInsertQuery(const String & full_query)\n+{\n+    const char * pos = full_query.data();\n+    const char * end = full_query.data() + full_query.size();\n+\n+    ParserInsertQuery parser(end, false);\n+    String message;\n+\n+    return tryParseQuery(parser, pos, end, message, false, \"\", false, DBMS_DEFAULT_MAX_QUERY_SIZE, DBMS_DEFAULT_MAX_PARSER_DEPTH);\n+}\n+\n+ASTs QueryFuzzer::getInsertQueriesForFuzzedTables(const String & full_query)\n+{\n+    auto parsed_query = tryParseInsertQuery(full_query);\n+    if (!parsed_query)\n+        return {};\n+\n+    const auto & insert = *parsed_query->as<ASTInsertQuery>();\n+    if (!insert.table)\n+        return {};\n+\n+    auto table_name = insert.getTable();\n+    auto it = original_table_name_to_fuzzed.find(table_name);\n+    if (it == original_table_name_to_fuzzed.end())\n+        return {};\n+\n+    ASTs queries;\n+    for (const auto & fuzzed_name : it->second)\n+    {\n+        /// Parse query from scratch for each table instead of clone,\n+        /// to store proper pointers to inlined data,\n+        /// which are not copied during clone.\n+        auto & query = queries.emplace_back(tryParseInsertQuery(full_query));\n+        query->as<ASTInsertQuery>()->setTable(fuzzed_name);\n+    }\n+\n+    return queries;\n+}\n+\n+ASTs QueryFuzzer::getDropQueriesForFuzzedTables(const ASTDropQuery & drop_query)\n+{\n+    if (drop_query.kind != ASTDropQuery::Drop)\n+        return {};\n+\n+    auto table_name = drop_query.getTable();\n+    auto it = index_of_fuzzed_table.find(table_name);\n+    if (it == index_of_fuzzed_table.end())\n+        return {};\n+\n+    ASTs queries;\n+    /// Drop all created tables, not only unique ones.\n+    for (size_t i = 0; i < it->second; ++i)\n+    {\n+        auto fuzzed_name = table_name + \"__fuzz_\" + toString(i);\n+        auto & query = queries.emplace_back(drop_query.clone());\n+        query->as<ASTDropQuery>()->setTable(fuzzed_name);\n+        /// Just in case add IF EXISTS to avoid exceptions.\n+        query->as<ASTDropQuery>()->if_exists = true;\n+    }\n+\n+    index_of_fuzzed_table.erase(it);\n+    original_table_name_to_fuzzed.erase(table_name);\n+\n+    return queries;\n+}\n+\n+void QueryFuzzer::notifyQueryFailed(ASTPtr ast)\n+{\n+    auto remove_fuzzed_table = [this](const auto & table_name)\n+    {\n+        auto pos = table_name.find(\"__fuzz_\");\n+        if (pos != std::string::npos)\n+        {\n+            auto original_name = table_name.substr(0, pos);\n+            original_table_name_to_fuzzed[original_name].erase(table_name);\n+        }\n+    };\n+\n+    if (const auto * create = ast->as<ASTCreateQuery>())\n+        remove_fuzzed_table(create->getTable());\n+\n+    if (const auto * insert = ast->as<ASTInsertQuery>())\n+        remove_fuzzed_table(insert->getTable());\n+}\n+\n void QueryFuzzer::fuzz(ASTs & asts)\n {\n     for (auto & ast : asts)\n@@ -497,6 +812,7 @@ void QueryFuzzer::fuzz(ASTPtr & ast)\n     }\n     else if (auto * table_expr = typeid_cast<ASTTableExpression *>(ast.get()))\n     {\n+        fuzzTableName(*table_expr);\n         fuzz(table_expr->children);\n     }\n     else if (auto * expr_list = typeid_cast<ASTExpressionList *>(ast.get()))\n@@ -563,6 +879,10 @@ void QueryFuzzer::fuzz(ASTPtr & ast)\n             literal->value = fuzzField(literal->value);\n         }\n     }\n+    else if (auto * create_query = typeid_cast<ASTCreateQuery *>(ast.get()))\n+    {\n+        fuzzCreateQuery(*create_query);\n+    }\n     else\n     {\n         fuzz(ast->children);\ndiff --git a/src/Client/QueryFuzzer.h b/src/Client/QueryFuzzer.h\nindex 25bd7f0c88d8..9afe7867dd2b 100644\n--- a/src/Client/QueryFuzzer.h\n+++ b/src/Client/QueryFuzzer.h\n@@ -1,5 +1,6 @@\n #pragma once\n \n+#include <DataTypes/IDataType.h>\n #include <unordered_set>\n #include <unordered_map>\n #include <vector>\n@@ -16,6 +17,11 @@ namespace DB\n \n class ASTExpressionList;\n class ASTOrderByElement;\n+class ASTCreateQuery;\n+class ASTInsertQuery;\n+class ASTColumnDeclaration;\n+class ASTDropQuery;\n+struct ASTTableExpression;\n struct ASTWindowDefinition;\n \n /*\n@@ -54,6 +60,9 @@ struct QueryFuzzer\n     std::unordered_set<const IAST *> debug_visited_nodes;\n     ASTPtr * debug_top_ast = nullptr;\n \n+    std::unordered_map<std::string, std::unordered_set<std::string>> original_table_name_to_fuzzed;\n+    std::unordered_map<std::string, size_t> index_of_fuzzed_table;\n+    std::set<IAST::Hash> created_tables_hashes;\n \n     // This is the only function you have to call -- it will modify the passed\n     // ASTPtr to point to new AST with some random changes.\n@@ -63,18 +72,28 @@ struct QueryFuzzer\n     Field getRandomField(int type);\n     Field fuzzField(Field field);\n     ASTPtr getRandomColumnLike();\n+    DataTypePtr fuzzDataType(DataTypePtr type);\n+    DataTypePtr getRandomType();\n+    ASTs getInsertQueriesForFuzzedTables(const String & full_query);\n+    ASTs getDropQueriesForFuzzedTables(const ASTDropQuery & drop_query);\n+    void notifyQueryFailed(ASTPtr ast);\n     void replaceWithColumnLike(ASTPtr & ast);\n     void replaceWithTableLike(ASTPtr & ast);\n     void fuzzOrderByElement(ASTOrderByElement * elem);\n     void fuzzOrderByList(IAST * ast);\n     void fuzzColumnLikeExpressionList(IAST * ast);\n     void fuzzWindowFrame(ASTWindowDefinition & def);\n+    void fuzzCreateQuery(ASTCreateQuery & create);\n+    void fuzzColumnDeclaration(ASTColumnDeclaration & column);\n+    void fuzzTableName(ASTTableExpression & table);\n     void fuzz(ASTs & asts);\n     void fuzz(ASTPtr & ast);\n     void collectFuzzInfoMain(ASTPtr ast);\n     void addTableLike(ASTPtr ast);\n     void addColumnLike(ASTPtr ast);\n     void collectFuzzInfoRecurse(ASTPtr ast);\n+\n+    static bool isSuitableForFuzzing(const ASTCreateQuery & create);\n };\n \n }\ndiff --git a/src/Storages/MergeTree/registerStorageMergeTree.cpp b/src/Storages/MergeTree/registerStorageMergeTree.cpp\nindex 6982521f76a9..7e2d5e1727b4 100644\n--- a/src/Storages/MergeTree/registerStorageMergeTree.cpp\n+++ b/src/Storages/MergeTree/registerStorageMergeTree.cpp\n@@ -265,7 +265,7 @@ static StoragePtr create(const StorageFactory::Arguments & args)\n \n         if (max_num_params == 0)\n             msg += \"no parameters\";\n-        if (min_num_params == max_num_params)\n+        else if (min_num_params == max_num_params)\n             msg += fmt::format(\"{} parameters: {}\", min_num_params, needed_params);\n         else\n             msg += fmt::format(\"{} to {} parameters: {}\", min_num_params, max_num_params, needed_params);\n",
  "test_patch": "diff --git a/docker/test/fuzzer/allow-nullable-key.xml b/docker/test/fuzzer/allow-nullable-key.xml\nnew file mode 100644\nindex 000000000000..331012a22548\n--- /dev/null\n+++ b/docker/test/fuzzer/allow-nullable-key.xml\n@@ -0,0 +1,6 @@\n+<clickhouse>\n+    <!-- Allow nullable key to avoid errors while fuzzing definitions of tables -->\n+    <merge_tree>\n+        <allow_nullable_key>1</allow_nullable_key>\n+    </merge_tree>\n+</clickhouse>\ndiff --git a/docker/test/fuzzer/run-fuzzer.sh b/docker/test/fuzzer/run-fuzzer.sh\nindex bab87865b42f..7248728864e9 100755\n--- a/docker/test/fuzzer/run-fuzzer.sh\n+++ b/docker/test/fuzzer/run-fuzzer.sh\n@@ -94,6 +94,7 @@ function configure\n     # TODO figure out which ones are needed\n     cp -av --dereference \"$repo_dir\"/tests/config/config.d/listen.xml db/config.d\n     cp -av --dereference \"$script_dir\"/query-fuzzer-tweaks-users.xml db/users.d\n+    cp -av --dereference \"$script_dir\"/allow-nullable-key.xml db/config.d\n \n     cat > db/config.d/core.xml <<EOL\n <clickhouse>\n@@ -240,6 +241,7 @@ quit\n         --receive_data_timeout_ms=10000 \\\n         --stacktrace \\\n         --query-fuzzer-runs=1000 \\\n+        --create-query-fuzzer-runs=50 \\\n         --queries-file $(ls -1 ch/tests/queries/0_stateless/*.sql | sort -R) \\\n         $NEW_TESTS_OPT \\\n         > >(tail -n 100000 > fuzzer.log) \\\n",
  "problem_statement": "Fuzzing of data types in tables\nAST-based query fuzzer should randomly modify data types in CREATE TABLE queries, mostly by wrapping in Nullable, Array and LowCardinality.\n",
  "hints_text": "",
  "created_at": "2022-08-11T02:35:14Z"
}