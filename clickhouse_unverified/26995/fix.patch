diff --git a/src/Dictionaries/CassandraDictionarySource.cpp b/src/Dictionaries/CassandraDictionarySource.cpp
index 8b31b4d6fa22..98928312ec87 100644
--- a/src/Dictionaries/CassandraDictionarySource.cpp
+++ b/src/Dictionaries/CassandraDictionarySource.cpp
@@ -49,7 +49,7 @@ namespace ErrorCodes
     extern const int INVALID_CONFIG_PARAMETER;
 }
 
-CassandraSettings::CassandraSettings(
+CassandraDictionarySource::Configuration::Configuration(
     const Poco::Util::AbstractConfiguration & config,
     const String & config_prefix)
     : host(config.getString(config_prefix + ".host"))
@@ -66,7 +66,7 @@ CassandraSettings::CassandraSettings(
     setConsistency(config.getString(config_prefix + ".consistency", "One"));
 }
 
-void CassandraSettings::setConsistency(const String & config_str)
+void CassandraDictionarySource::Configuration::setConsistency(const String & config_str)
 {
     if (config_str == "One")
         consistency = CASS_CONSISTENCY_ONE;
@@ -96,19 +96,19 @@ static const size_t max_block_size = 8192;
 
 CassandraDictionarySource::CassandraDictionarySource(
     const DictionaryStructure & dict_struct_,
-    const CassandraSettings & settings_,
+    const Configuration & configuration_,
     const Block & sample_block_)
     : log(&Poco::Logger::get("CassandraDictionarySource"))
     , dict_struct(dict_struct_)
-    , settings(settings_)
+    , configuration(configuration_)
     , sample_block(sample_block_)
-    , query_builder(dict_struct, settings.db, "", settings.table, settings.where, IdentifierQuotingStyle::DoubleQuotes)
+    , query_builder(dict_struct, configuration.db, "", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::DoubleQuotes)
 {
-    cassandraCheck(cass_cluster_set_contact_points(cluster, settings.host.c_str()));
-    if (settings.port)
-        cassandraCheck(cass_cluster_set_port(cluster, settings.port));
-    cass_cluster_set_credentials(cluster, settings.user.c_str(), settings.password.c_str());
-    cassandraCheck(cass_cluster_set_consistency(cluster, settings.consistency));
+    cassandraCheck(cass_cluster_set_contact_points(cluster, configuration.host.c_str()));
+    if (configuration.port)
+        cassandraCheck(cass_cluster_set_port(cluster, configuration.port));
+    cass_cluster_set_credentials(cluster, configuration.user.c_str(), configuration.password.c_str());
+    cassandraCheck(cass_cluster_set_consistency(cluster, configuration.consistency));
 }
 
 CassandraDictionarySource::CassandraDictionarySource(
@@ -118,14 +118,14 @@ CassandraDictionarySource::CassandraDictionarySource(
     Block & sample_block_)
     : CassandraDictionarySource(
         dict_struct_,
-        CassandraSettings(config, config_prefix),
+        Configuration(config, config_prefix),
         sample_block_)
 {
 }
 
 void CassandraDictionarySource::maybeAllowFiltering(String & query) const
 {
-    if (!settings.allow_filtering)
+    if (!configuration.allow_filtering)
         return;
     query.pop_back();   /// remove semicolon
     query += " ALLOW FILTERING;";
@@ -141,7 +141,7 @@ Pipe CassandraDictionarySource::loadAll()
 
 std::string CassandraDictionarySource::toString() const
 {
-    return "Cassandra: " + settings.db + '.' + settings.table;
+    return "Cassandra: " + configuration.db + '.' + configuration.table;
 }
 
 Pipe CassandraDictionarySource::loadIds(const std::vector<UInt64> & ids)
@@ -162,7 +162,7 @@ Pipe CassandraDictionarySource::loadKeys(const Columns & key_columns, const std:
     for (const auto & row : requested_rows)
     {
         SipHash partition_key;
-        for (size_t i = 0; i < settings.partition_key_prefix; ++i)
+        for (size_t i = 0; i < configuration.partition_key_prefix; ++i)
             key_columns[i]->updateHashWithValue(row, partition_key);
         partitions[partition_key.get64()].push_back(row);
     }
@@ -170,7 +170,7 @@ Pipe CassandraDictionarySource::loadKeys(const Columns & key_columns, const std:
     Pipes pipes;
     for (const auto & partition : partitions)
     {
-        String query = query_builder.composeLoadKeysQuery(key_columns, partition.second, ExternalQueryBuilder::CASSANDRA_SEPARATE_PARTITION_KEY, settings.partition_key_prefix);
+        String query = query_builder.composeLoadKeysQuery(key_columns, partition.second, ExternalQueryBuilder::CASSANDRA_SEPARATE_PARTITION_KEY, configuration.partition_key_prefix);
         maybeAllowFiltering(query);
         LOG_INFO(log, "Loading keys for partition hash {} using query: {}", partition.first, query);
         pipes.push_back(Pipe(std::make_shared<CassandraSource>(getSession(), query, sample_block, max_block_size)));
diff --git a/src/Dictionaries/CassandraDictionarySource.h b/src/Dictionaries/CassandraDictionarySource.h
index 871e3dc4857b..35419d3ea7df 100644
--- a/src/Dictionaries/CassandraDictionarySource.h
+++ b/src/Dictionaries/CassandraDictionarySource.h
@@ -14,33 +14,35 @@
 namespace DB
 {
 
-struct CassandraSettings
-{
-    String host;
-    UInt16 port;
-    String user;
-    String password;
-    String db;
-    String table;
-
-    CassConsistency consistency;
-    bool allow_filtering;
-    /// TODO get information about key from the driver
-    size_t partition_key_prefix;
-    size_t max_threads;
-    String where;
-
-    CassandraSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix);
-
-    void setConsistency(const String & config_str);
-};
-
 class CassandraDictionarySource final : public IDictionarySource
 {
 public:
+
+    struct Configuration
+    {
+        String host;
+        UInt16 port;
+        String user;
+        String password;
+        String db;
+        String table;
+        String query;
+
+        CassConsistency consistency;
+        bool allow_filtering;
+        /// TODO get information about key from the driver
+        size_t partition_key_prefix;
+        size_t max_threads;
+        String where;
+
+        Configuration(const Poco::Util::AbstractConfiguration & config, const String & config_prefix);
+
+        void setConsistency(const String & config_str);
+    };
+
     CassandraDictionarySource(
         const DictionaryStructure & dict_struct,
-        const CassandraSettings & settings_,
+        const Configuration & configuration,
         const Block & sample_block);
 
     CassandraDictionarySource(
@@ -59,7 +61,7 @@ class CassandraDictionarySource final : public IDictionarySource
 
     DictionarySourcePtr clone() const override
     {
-        return std::make_unique<CassandraDictionarySource>(dict_struct, settings, sample_block);
+        return std::make_unique<CassandraDictionarySource>(dict_struct, configuration, sample_block);
     }
 
     Pipe loadIds(const std::vector<UInt64> & ids) override;
@@ -76,7 +78,7 @@ class CassandraDictionarySource final : public IDictionarySource
 
     Poco::Logger * log;
     const DictionaryStructure dict_struct;
-    const CassandraSettings settings;
+    const Configuration configuration;
     Block sample_block;
     ExternalQueryBuilder query_builder;
 
diff --git a/src/Dictionaries/ClickHouseDictionarySource.cpp b/src/Dictionaries/ClickHouseDictionarySource.cpp
index 8b2373302c81..0f085a7c1a2d 100644
--- a/src/Dictionaries/ClickHouseDictionarySource.cpp
+++ b/src/Dictionaries/ClickHouseDictionarySource.cpp
@@ -67,7 +67,7 @@ ClickHouseDictionarySource::ClickHouseDictionarySource(
     : update_time{std::chrono::system_clock::from_time_t(0)}
     , dict_struct{dict_struct_}
     , configuration{configuration_}
-    , query_builder{dict_struct, configuration.db, "", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks}
+    , query_builder{dict_struct, configuration.db, "", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks}
     , sample_block{sample_block_}
     , context(Context::createCopy(context_))
     , pool{createPool(configuration)}
@@ -83,7 +83,7 @@ ClickHouseDictionarySource::ClickHouseDictionarySource(const ClickHouseDictionar
     , dict_struct{other.dict_struct}
     , configuration{other.configuration}
     , invalidate_query_response{other.invalidate_query_response}
-    , query_builder{dict_struct, configuration.db, "", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks}
+    , query_builder{dict_struct, configuration.db, "", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks}
     , sample_block{other.sample_block}
     , context(Context::createCopy(other.context))
     , pool{createPool(configuration)}
@@ -241,7 +241,8 @@ void registerDictionarySourceClickHouse(DictionarySourceFactory & factory)
             .user = config.getString(settings_config_prefix + ".user", "default"),
             .password = config.getString(settings_config_prefix + ".password", ""),
             .db = config.getString(settings_config_prefix + ".db", default_database),
-            .table = config.getString(settings_config_prefix + ".table"),
+            .table = config.getString(settings_config_prefix + ".table", ""),
+            .query = config.getString(settings_config_prefix + ".query", ""),
             .where = config.getString(settings_config_prefix + ".where", ""),
             .invalidate_query = config.getString(settings_config_prefix + ".invalidate_query", ""),
             .update_field = config.getString(settings_config_prefix + ".update_field", ""),
diff --git a/src/Dictionaries/ClickHouseDictionarySource.h b/src/Dictionaries/ClickHouseDictionarySource.h
index f293c010ec3d..2daa296af3e6 100644
--- a/src/Dictionaries/ClickHouseDictionarySource.h
+++ b/src/Dictionaries/ClickHouseDictionarySource.h
@@ -25,6 +25,7 @@ class ClickHouseDictionarySource final : public IDictionarySource
         const std::string password;
         const std::string db;
         const std::string table;
+        const std::string query;
         const std::string where;
         const std::string invalidate_query;
         const std::string update_field;
diff --git a/src/Dictionaries/ExternalQueryBuilder.cpp b/src/Dictionaries/ExternalQueryBuilder.cpp
index e0920535e335..10c4f67d8090 100644
--- a/src/Dictionaries/ExternalQueryBuilder.cpp
+++ b/src/Dictionaries/ExternalQueryBuilder.cpp
@@ -21,10 +21,23 @@ ExternalQueryBuilder::ExternalQueryBuilder(
     const std::string & db_,
     const std::string & schema_,
     const std::string & table_,
+    const std::string & query_,
     const std::string & where_,
     IdentifierQuotingStyle quoting_style_)
-    : dict_struct(dict_struct_), db(db_), schema(schema_), table(table_), where(where_), quoting_style(quoting_style_)
-{}
+    : dict_struct(dict_struct_)
+    , db(db_)
+    , schema(schema_)
+    , table(table_)
+    , query(query_)
+    , where(where_)
+    , quoting_style(quoting_style_)
+{
+    if (table.empty() && query.empty())
+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Setting `table` or `query` must be non empty");
+
+    if (!query.empty() && (!table.empty() || !where.empty()))
+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Setting `table` or `where` cannot be used with `query` parameter");
+}
 
 
 void ExternalQueryBuilder::writeQuoted(const std::string & s, WriteBuffer & out) const
@@ -52,10 +65,17 @@ void ExternalQueryBuilder::writeQuoted(const std::string & s, WriteBuffer & out)
 
 std::string ExternalQueryBuilder::composeLoadAllQuery() const
 {
-    WriteBufferFromOwnString out;
-    composeLoadAllQuery(out);
-    writeChar(';', out);
-    return out.str();
+    if (query.empty())
+    {
+        WriteBufferFromOwnString out;
+        composeLoadAllQuery(out);
+        writeChar(';', out);
+        return out.str();
+    }
+    else
+    {
+        return query;
+    }
 }
 
 void ExternalQueryBuilder::composeLoadAllQuery(WriteBuffer & out) const
@@ -152,95 +172,135 @@ void ExternalQueryBuilder::composeLoadAllQuery(WriteBuffer & out) const
 std::string ExternalQueryBuilder::composeUpdateQuery(const std::string & update_field, const std::string & time_point) const
 {
     WriteBufferFromOwnString out;
-    composeLoadAllQuery(out);
 
-    if (!where.empty())
-        writeString(" AND ", out);
+    if (query.empty())
+    {
+        composeLoadAllQuery(out);
+
+        if (!where.empty())
+            writeString(" AND ", out);
+        else
+            writeString(" WHERE ", out);
+
+        composeUpdateCondition(update_field, time_point, out);
+
+        writeChar(';', out);
+
+        return out.str();
+    }
     else
-        writeString(" WHERE ", out);
+    {
+        writeString(query, out);
 
-    writeString(update_field, out);
-    writeString(" >= '", out);
-    writeString(time_point, out);
-    writeChar('\'', out);
+        auto condition_position = query.find("{condition}");
+        if (condition_position == std::string::npos)
+        {
+            writeString(" WHERE ", out);
+            composeUpdateCondition(update_field, time_point, out);
+            writeString(";", out);
+
+            return out.str();
+        }
 
-    writeChar(';', out);
-    return out.str();
+        WriteBufferFromOwnString condition_value_buffer;
+        composeUpdateCondition(update_field, time_point, condition_value_buffer);
+        const auto & condition_value = condition_value_buffer.str();
+
+        auto query_copy = query;
+        query_copy.replace(condition_position, condition_value.size(), condition_value);
+
+        return query_copy;
+    }
 }
 
 
-std::string ExternalQueryBuilder::composeLoadIdsQuery(const std::vector<UInt64> & ids)
+std::string ExternalQueryBuilder::composeLoadIdsQuery(const std::vector<UInt64> & ids) const
 {
     if (!dict_struct.id)
         throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Simple key required for method");
 
     WriteBufferFromOwnString out;
-    writeString("SELECT ", out);
 
-    if (!dict_struct.id->expression.empty())
+    if (query.empty())
     {
-        writeParenthesisedString(dict_struct.id->expression, out);
-        writeString(" AS ", out);
-    }
+        writeString("SELECT ", out);
 
-    writeQuoted(dict_struct.id->name, out);
+        if (!dict_struct.id->expression.empty())
+        {
+            writeParenthesisedString(dict_struct.id->expression, out);
+            writeString(" AS ", out);
+        }
 
-    for (const auto & attr : dict_struct.attributes)
-    {
-        writeString(", ", out);
+        writeQuoted(dict_struct.id->name, out);
 
-        if (!attr.expression.empty())
+        for (const auto & attr : dict_struct.attributes)
         {
-            writeParenthesisedString(attr.expression, out);
-            writeString(" AS ", out);
+            writeString(", ", out);
+
+            if (!attr.expression.empty())
+            {
+                writeParenthesisedString(attr.expression, out);
+                writeString(" AS ", out);
+            }
+
+            writeQuoted(attr.name, out);
         }
 
-        writeQuoted(attr.name, out);
-    }
+        writeString(" FROM ", out);
+        if (!db.empty())
+        {
+            writeQuoted(db, out);
+            writeChar('.', out);
+        }
+        if (!schema.empty())
+        {
+            writeQuoted(schema, out);
+            writeChar('.', out);
+        }
 
-    writeString(" FROM ", out);
-    if (!db.empty())
-    {
-        writeQuoted(db, out);
-        writeChar('.', out);
-    }
-    if (!schema.empty())
-    {
-        writeQuoted(schema, out);
-        writeChar('.', out);
-    }
+        writeQuoted(table, out);
 
-    writeQuoted(table, out);
+        writeString(" WHERE ", out);
 
-    writeString(" WHERE ", out);
+        if (!where.empty())
+        {
+            writeString(where, out);
+            writeString(" AND ", out);
+        }
 
-    if (!where.empty())
-    {
-        writeString(where, out);
-        writeString(" AND ", out);
+        composeIdsCondition(ids, out);
+        writeString(";", out);
+
+        return out.str();
     }
+    else
+    {
+        writeString(query, out);
 
-    writeQuoted(dict_struct.id->name, out);
-    writeString(" IN (", out);
+        auto condition_position = query.find("{condition}");
+        if (condition_position == std::string::npos)
+        {
+            writeString(" WHERE ", out);
+            composeIdsCondition(ids, out);
+            writeString(";", out);
 
-    auto first = true;
-    for (const auto id : ids)
-    {
-        if (!first)
-            writeString(", ", out);
+            return out.str();
+        }
 
-        first = false;
-        writeString(DB::toString(id), out);
-    }
+        WriteBufferFromOwnString condition_value_buffer;
+        composeIdsCondition(ids, condition_value_buffer);
+        const auto & condition_value = condition_value_buffer.str();
 
-    writeString(");", out);
+        auto query_copy = query;
+        query_copy.replace(condition_position, condition_value.size(), condition_value);
 
-    return out.str();
+        return query_copy;
+    }
 }
 
 
 std::string ExternalQueryBuilder::composeLoadKeysQuery(
-    const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix)
+    const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix) const
 {
     if (!dict_struct.key)
         throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "Composite key required for method");
@@ -249,99 +309,88 @@ std::string ExternalQueryBuilder::composeLoadKeysQuery(
         throw Exception(ErrorCodes::LOGICAL_ERROR, "The size of key_columns does not equal to the size of dictionary key");
 
     WriteBufferFromOwnString out;
-    writeString("SELECT ", out);
 
-    auto first = true;
-    for (const auto & key_or_attribute : boost::join(*dict_struct.key, dict_struct.attributes))
+    if (query.empty())
     {
-        if (!first)
-            writeString(", ", out);
+        writeString("SELECT ", out);
 
-        first = false;
+        auto first = true;
+        for (const auto & key_or_attribute : boost::join(*dict_struct.key, dict_struct.attributes))
+        {
+            if (!first)
+                writeString(", ", out);
+
+            first = false;
+
+            if (!key_or_attribute.expression.empty())
+            {
+                writeParenthesisedString(key_or_attribute.expression, out);
+                writeString(" AS ", out);
+            }
+
+            writeQuoted(key_or_attribute.name, out);
+        }
 
-        if (!key_or_attribute.expression.empty())
+        writeString(" FROM ", out);
+        if (!db.empty())
         {
-            writeParenthesisedString(key_or_attribute.expression, out);
-            writeString(" AS ", out);
+            writeQuoted(db, out);
+            writeChar('.', out);
+        }
+        if (!schema.empty())
+        {
+            writeQuoted(schema, out);
+            writeChar('.', out);
         }
 
-        writeQuoted(key_or_attribute.name, out);
-    }
+        writeQuoted(table, out);
 
-    writeString(" FROM ", out);
-    if (!db.empty())
-    {
-        writeQuoted(db, out);
-        writeChar('.', out);
-    }
-    if (!schema.empty())
-    {
-        writeQuoted(schema, out);
-        writeChar('.', out);
-    }
+        writeString(" WHERE ", out);
 
-    writeQuoted(table, out);
+        if (!where.empty())
+        {
+            if (method != CASSANDRA_SEPARATE_PARTITION_KEY)
+                writeString("(", out);
+            writeString(where, out);
+            if (method != CASSANDRA_SEPARATE_PARTITION_KEY)
+                writeString(") AND (", out);
+            else
+                writeString(" AND ", out);
+        }
 
-    writeString(" WHERE ", out);
+        composeKeysCondition(key_columns, requested_rows, method, partition_key_prefix, out);
 
-    if (!where.empty())
-    {
-        if (method != CASSANDRA_SEPARATE_PARTITION_KEY)
-            writeString("(", out);
-        writeString(where, out);
-        if (method != CASSANDRA_SEPARATE_PARTITION_KEY)
-            writeString(") AND (", out);
-        else
-            writeString(" AND ", out);
-    }
+        writeString(";", out);
 
-    if (method == AND_OR_CHAIN)
+        return out.str();
+    }
+    else
     {
-        first = true;
-        for (const auto row : requested_rows)
-        {
-            if (!first)
-                writeString(" OR ", out);
+        writeString(query, out);
 
-            first = false;
+        auto condition_position = query.find("{condition}");
+        if (condition_position == std::string::npos)
+        {
+            writeString(" WHERE ", out);
+            composeKeysCondition(key_columns, requested_rows, method, partition_key_prefix, out);
+            writeString(";", out);
 
-            writeString("(", out);
-            composeKeyCondition(key_columns, row, out, 0, key_columns.size());
-            writeString(")", out);
+            return out.str();
         }
-    }
-    else if (method == IN_WITH_TUPLES)
-    {
-        composeInWithTuples(key_columns, requested_rows, out, 0, key_columns.size());
-    }
-    else /* if (method == CASSANDRA_SEPARATE_PARTITION_KEY) */
-    {
-        /// CQL does not allow using OR conditions
-        /// and does not allow using multi-column IN expressions with partition key columns.
-        /// So we have to use multiple queries with conditions like
-        /// (partition_key_1 = val1 AND partition_key_2 = val2 ...) AND (clustering_key_1, ...) IN ((val3, ...), ...)
-        /// for each partition key.
-        /// `partition_key_prefix` is a number of columns from partition key.
-        /// All `requested_rows` must have the same values of partition key.
-        composeKeyCondition(key_columns, requested_rows.at(0), out, 0, partition_key_prefix);
-        if (partition_key_prefix && partition_key_prefix < key_columns.size())
-            writeString(" AND ", out);
-        if (partition_key_prefix < key_columns.size())
-            composeInWithTuples(key_columns, requested_rows, out, partition_key_prefix, key_columns.size());
-    }
 
-    if (!where.empty() && method != CASSANDRA_SEPARATE_PARTITION_KEY)
-    {
-        writeString(")", out);
-    }
+        WriteBufferFromOwnString condition_value_buffer;
+        composeKeysCondition(key_columns, requested_rows, method, partition_key_prefix, condition_value_buffer);
+        const auto & condition_value = condition_value_buffer.str();
 
-    writeString(";", out);
+        auto query_copy = query;
+        query_copy.replace(condition_position, condition_value.size(), condition_value);
 
-    return out.str();
+        return query_copy;
+    }
 }
 
 
-void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, const size_t row, WriteBuffer & out,
+void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, size_t row, WriteBuffer & out,
                                                size_t beg, size_t end) const
 {
     auto first = true;
@@ -363,7 +412,7 @@ void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, cons
 
 
 void ExternalQueryBuilder::composeInWithTuples(const Columns & key_columns, const std::vector<size_t> & requested_rows,
-                                               WriteBuffer & out, size_t beg, size_t end)
+                                               WriteBuffer & out, size_t beg, size_t end) const
 {
     composeKeyTupleDefinition(out, beg, end);
     writeString(" IN (", out);
@@ -403,7 +452,7 @@ void ExternalQueryBuilder::composeKeyTupleDefinition(WriteBuffer & out, size_t b
 }
 
 
-void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const size_t row, WriteBuffer & out, size_t beg, size_t end) const
+void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, size_t row, WriteBuffer & out, size_t beg, size_t end) const
 {
     writeString("(", out);
 
@@ -421,5 +470,75 @@ void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const si
     writeString(")", out);
 }
 
+void ExternalQueryBuilder::composeUpdateCondition(const std::string & update_field, const std::string & time_point, WriteBuffer & out)
+{
+    writeString(update_field, out);
+    writeString(" >= '", out);
+    writeString(time_point, out);
+    writeChar('\'', out);
+}
+
+void ExternalQueryBuilder::composeIdsCondition(const std::vector<UInt64> & ids, WriteBuffer & out) const
+{
+    writeQuoted(dict_struct.id->name, out);
+    writeString(" IN (", out);
+
+    auto first = true;
+    for (const auto id : ids)
+    {
+        if (!first)
+            writeString(", ", out);
+
+        first = false;
+        writeString(DB::toString(id), out);
+    }
+
+    writeString(")", out);
+}
+
+void ExternalQueryBuilder::composeKeysCondition(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix, WriteBuffer & out) const
+{
+    bool first = true;
+
+    if (method == AND_OR_CHAIN)
+    {
+        first = true;
+        for (const auto row : requested_rows)
+        {
+            if (!first)
+                writeString(" OR ", out);
+
+            first = false;
+
+            writeString("(", out);
+            composeKeyCondition(key_columns, row, out, 0, key_columns.size());
+            writeString(")", out);
+        }
+    }
+    else if (method == IN_WITH_TUPLES)
+    {
+        composeInWithTuples(key_columns, requested_rows, out, 0, key_columns.size());
+    }
+    else /* if (method == CASSANDRA_SEPARATE_PARTITION_KEY) */
+    {
+        /// CQL does not allow using OR conditions
+        /// and does not allow using multi-column IN expressions with partition key columns.
+        /// So we have to use multiple queries with conditions like
+        /// (partition_key_1 = val1 AND partition_key_2 = val2 ...) AND (clustering_key_1, ...) IN ((val3, ...), ...)
+        /// for each partition key.
+        /// `partition_key_prefix` is a number of columns from partition key.
+        /// All `requested_rows` must have the same values of partition key.
+        composeKeyCondition(key_columns, requested_rows.at(0), out, 0, partition_key_prefix);
+        if (partition_key_prefix && partition_key_prefix < key_columns.size())
+            writeString(" AND ", out);
+        if (partition_key_prefix < key_columns.size())
+            composeInWithTuples(key_columns, requested_rows, out, partition_key_prefix, key_columns.size());
+    }
+
+    if (!where.empty() && method != CASSANDRA_SEPARATE_PARTITION_KEY)
+    {
+        writeString(")", out);
+    }
+}
 
 }
diff --git a/src/Dictionaries/ExternalQueryBuilder.h b/src/Dictionaries/ExternalQueryBuilder.h
index 9f9ccd65001b..9d79ec3e702f 100644
--- a/src/Dictionaries/ExternalQueryBuilder.h
+++ b/src/Dictionaries/ExternalQueryBuilder.h
@@ -21,6 +21,7 @@ struct ExternalQueryBuilder
     const std::string db;
     const std::string schema;
     const std::string table;
+    const std::string query;
     const std::string where;
 
     IdentifierQuotingStyle quoting_style;
@@ -31,6 +32,7 @@ struct ExternalQueryBuilder
         const std::string & db_,
         const std::string & schema_,
         const std::string & table_,
+        const std::string & query_,
         const std::string & where_,
         IdentifierQuotingStyle quoting_style_);
 
@@ -41,7 +43,7 @@ struct ExternalQueryBuilder
     std::string composeUpdateQuery(const std::string & update_field, const std::string & time_point) const;
 
     /** Generate a query to load data by set of UInt64 keys. */
-    std::string composeLoadIdsQuery(const std::vector<UInt64> & ids);
+    std::string composeLoadIdsQuery(const std::vector<UInt64> & ids) const;
 
     /** Generate a query to load data by set of composite keys.
       * There are three methods of specification of composite keys in WHERE:
@@ -56,7 +58,7 @@ struct ExternalQueryBuilder
         CASSANDRA_SEPARATE_PARTITION_KEY,
     };
 
-    std::string composeLoadKeysQuery(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix = 0);
+    std::string composeLoadKeysQuery(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix = 0) const;
 
 
 private:
@@ -67,16 +69,25 @@ struct ExternalQueryBuilder
     /// In the following methods `beg` and `end` specifies which columns to write in expression
 
     /// Expression in form (x = c1 AND y = c2 ...)
-    void composeKeyCondition(const Columns & key_columns, const size_t row, WriteBuffer & out, size_t beg, size_t end) const;
+    void composeKeyCondition(const Columns & key_columns, size_t row, WriteBuffer & out, size_t beg, size_t end) const;
 
     /// Expression in form (x, y, ...) IN ((c1, c2, ...), ...)
-    void composeInWithTuples(const Columns & key_columns, const std::vector<size_t> & requested_rows, WriteBuffer & out, size_t beg, size_t end);
+    void composeInWithTuples(const Columns & key_columns, const std::vector<size_t> & requested_rows, WriteBuffer & out, size_t beg, size_t end) const;
 
     /// Expression in form (x, y, ...)
     void composeKeyTupleDefinition(WriteBuffer & out, size_t beg, size_t end) const;
 
     /// Expression in form (c1, c2, ...)
-    void composeKeyTuple(const Columns & key_columns, const size_t row, WriteBuffer & out, size_t beg, size_t end) const;
+    void composeKeyTuple(const Columns & key_columns, size_t row, WriteBuffer & out, size_t beg, size_t end) const;
+
+    /// Compose update condition
+    static void composeUpdateCondition(const std::string & update_field, const std::string & time_point, WriteBuffer & out);
+
+    /// Compose ids condition
+    void composeIdsCondition(const std::vector<UInt64> & ids, WriteBuffer & out) const;
+
+    /// Compose keys condition
+    void composeKeysCondition(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix, WriteBuffer & out) const;
 
     /// Write string with specified quoting style.
     void writeQuoted(const std::string & s, WriteBuffer & out) const;
diff --git a/src/Dictionaries/MySQLDictionarySource.cpp b/src/Dictionaries/MySQLDictionarySource.cpp
index c7309ddb950b..2eebb6970d03 100644
--- a/src/Dictionaries/MySQLDictionarySource.cpp
+++ b/src/Dictionaries/MySQLDictionarySource.cpp
@@ -22,6 +22,7 @@ static const size_t default_num_tries_on_connection_loss = 3;
 namespace ErrorCodes
 {
     extern const int SUPPORT_IS_DISABLED;
+    extern const int UNSUPPORTED_METHOD;
 }
 
 void registerDictionarySourceMysql(DictionarySourceFactory & factory)
@@ -41,11 +42,19 @@ void registerDictionarySourceMysql(DictionarySourceFactory & factory)
 
         auto settings_config_prefix = config_prefix + ".mysql";
 
+        auto table = config.getString(settings_config_prefix + ".table", "");
+        auto where = config.getString(settings_config_prefix + ".where", "");
+        auto query = config.getString(settings_config_prefix + ".query", "");
+
+        if (query.empty() && table.empty())
+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, "MySQL dictionary source configuration must contain table or query field");
+
         MySQLDictionarySource::Configuration configuration
         {
             .db = config.getString(settings_config_prefix + ".db", ""),
-            .table = config.getString(settings_config_prefix + ".table"),
-            .where = config.getString(settings_config_prefix + ".where", ""),
+            .table = table,
+            .query = query,
+            .where = where,
             .invalidate_query = config.getString(settings_config_prefix + ".invalidate_query", ""),
             .update_field = config.getString(settings_config_prefix + ".update_field", ""),
             .update_lag = config.getUInt64(settings_config_prefix + ".update_lag", 1),
@@ -94,7 +103,7 @@ MySQLDictionarySource::MySQLDictionarySource(
     , configuration(configuration_)
     , pool(std::move(pool_))
     , sample_block(sample_block_)
-    , query_builder(dict_struct, configuration.db, "", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks)
+    , query_builder(dict_struct, configuration.db, "", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks)
     , load_all_query(query_builder.composeLoadAllQuery())
     , settings(settings_)
 {
@@ -108,7 +117,7 @@ MySQLDictionarySource::MySQLDictionarySource(const MySQLDictionarySource & other
     , configuration(other.configuration)
     , pool(other.pool)
     , sample_block(other.sample_block)
-    , query_builder{dict_struct, configuration.db, "", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks}
+    , query_builder{dict_struct, configuration.db, "", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks}
     , load_all_query{other.load_all_query}
     , last_modification{other.last_modification}
     , invalidate_query_response{other.invalidate_query_response}
@@ -128,7 +137,7 @@ std::string MySQLDictionarySource::getUpdateFieldAndDate()
     else
     {
         update_time = std::chrono::system_clock::now();
-        return query_builder.composeLoadAllQuery();
+        return load_all_query;
     }
 }
 
diff --git a/src/Dictionaries/MySQLDictionarySource.h b/src/Dictionaries/MySQLDictionarySource.h
index 49ddc924a865..afa6aa61d283 100644
--- a/src/Dictionaries/MySQLDictionarySource.h
+++ b/src/Dictionaries/MySQLDictionarySource.h
@@ -35,6 +35,7 @@ class MySQLDictionarySource final : public IDictionarySource
     {
         const std::string db;
         const std::string table;
+        const std::string query;
         const std::string where;
         const std::string invalidate_query;
         const std::string update_field;
diff --git a/src/Dictionaries/PostgreSQLDictionarySource.cpp b/src/Dictionaries/PostgreSQLDictionarySource.cpp
index f226b7a9165e..21b8809bc858 100644
--- a/src/Dictionaries/PostgreSQLDictionarySource.cpp
+++ b/src/Dictionaries/PostgreSQLDictionarySource.cpp
@@ -27,7 +27,7 @@ static const UInt64 max_block_size = 8192;
 
 namespace
 {
-    ExternalQueryBuilder makeExternalQueryBuilder(const DictionaryStructure & dict_struct, const String & schema, const String & table, const String & where)
+    ExternalQueryBuilder makeExternalQueryBuilder(const DictionaryStructure & dict_struct, const String & schema, const String & table, const String & query, const String & where)
     {
         auto schema_value = schema;
         auto table_value = table;
@@ -41,7 +41,7 @@ namespace
             }
         }
         /// Do not need db because it is already in a connection string.
-        return {dict_struct, "", schema_value, table_value, where, IdentifierQuotingStyle::DoubleQuotes};
+        return {dict_struct, "", schema_value, table_value, query, where, IdentifierQuotingStyle::DoubleQuotes};
     }
 }
 
@@ -56,7 +56,7 @@ PostgreSQLDictionarySource::PostgreSQLDictionarySource(
     , pool(std::move(pool_))
     , sample_block(sample_block_)
     , log(&Poco::Logger::get("PostgreSQLDictionarySource"))
-    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.where))
+    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.query, configuration.where))
     , load_all_query(query_builder.composeLoadAllQuery())
 {
 }
@@ -69,7 +69,7 @@ PostgreSQLDictionarySource::PostgreSQLDictionarySource(const PostgreSQLDictionar
     , pool(other.pool)
     , sample_block(other.sample_block)
     , log(&Poco::Logger::get("PostgreSQLDictionarySource"))
-    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.where))
+    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.query, configuration.where))
     , load_all_query(query_builder.composeLoadAllQuery())
     , update_time(other.update_time)
     , invalidate_query_response(other.invalidate_query_response)
@@ -198,6 +198,7 @@ void registerDictionarySourcePostgreSQL(DictionarySourceFactory & factory)
             .db = config.getString(fmt::format("{}.db", settings_config_prefix), ""),
             .schema = config.getString(fmt::format("{}.schema", settings_config_prefix), ""),
             .table = config.getString(fmt::format("{}.table", settings_config_prefix), ""),
+            .query = config.getString(fmt::format("{}.query", settings_config_prefix), ""),
             .where = config.getString(fmt::format("{}.where", settings_config_prefix), ""),
             .invalidate_query = config.getString(fmt::format("{}.invalidate_query", settings_config_prefix), ""),
             .update_field = config.getString(fmt::format("{}.update_field", settings_config_prefix), ""),
diff --git a/src/Dictionaries/PostgreSQLDictionarySource.h b/src/Dictionaries/PostgreSQLDictionarySource.h
index 28ad28661edd..c5ade4d259a2 100644
--- a/src/Dictionaries/PostgreSQLDictionarySource.h
+++ b/src/Dictionaries/PostgreSQLDictionarySource.h
@@ -26,6 +26,7 @@ class PostgreSQLDictionarySource final : public IDictionarySource
         const String db;
         const String schema;
         const String table;
+        const String query;
         const String where;
         const String invalidate_query;
         const String update_field;
diff --git a/src/Dictionaries/XDBCDictionarySource.cpp b/src/Dictionaries/XDBCDictionarySource.cpp
index 26b6c24cd2d4..80d3df1caabc 100644
--- a/src/Dictionaries/XDBCDictionarySource.cpp
+++ b/src/Dictionaries/XDBCDictionarySource.cpp
@@ -34,6 +34,7 @@ namespace
                                                   const std::string & db_,
                                                   const std::string & schema_,
                                                   const std::string & table_,
+                                                  const std::string & query_,
                                                   const std::string & where_,
                                                   IXDBCBridgeHelper & bridge_)
     {
@@ -59,7 +60,7 @@ namespace
                     bridge_.getName());
         }
 
-        return {dict_struct_, db_, schema, table, where_, bridge_.getIdentifierQuotingStyle()};
+        return {dict_struct_, db_, schema, table, query_, where_, bridge_.getIdentifierQuotingStyle()};
     }
 }
 
@@ -78,7 +79,7 @@ XDBCDictionarySource::XDBCDictionarySource(
     , dict_struct(dict_struct_)
     , configuration(configuration_)
     , sample_block(sample_block_)
-    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.db, configuration.schema, configuration.table, configuration.where, *bridge_))
+    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.db, configuration.schema, configuration.table, configuration.query, configuration.where, *bridge_))
     , load_all_query(query_builder.composeLoadAllQuery())
     , bridge_helper(bridge_)
     , bridge_url(bridge_helper->getMainURI())
@@ -119,7 +120,7 @@ std::string XDBCDictionarySource::getUpdateFieldAndDate()
     else
     {
         update_time = std::chrono::system_clock::now();
-        return query_builder.composeLoadAllQuery();
+        return load_all_query;
     }
 }
 
@@ -246,7 +247,8 @@ void registerDictionarySourceXDBC(DictionarySourceFactory & factory)
         {
             .db = config.getString(settings_config_prefix + ".db", ""),
             .schema = config.getString(settings_config_prefix + ".schema", ""),
-            .table = config.getString(settings_config_prefix + ".table"),
+            .table = config.getString(settings_config_prefix + ".table", ""),
+            .query = config.getString(settings_config_prefix + ".query", ""),
             .where = config.getString(settings_config_prefix + ".where", ""),
             .invalidate_query = config.getString(settings_config_prefix + ".invalidate_query", ""),
             .update_field = config.getString(settings_config_prefix + ".update_field", ""),
diff --git a/src/Dictionaries/XDBCDictionarySource.h b/src/Dictionaries/XDBCDictionarySource.h
index ebced022b624..df31e8a87cf9 100644
--- a/src/Dictionaries/XDBCDictionarySource.h
+++ b/src/Dictionaries/XDBCDictionarySource.h
@@ -32,6 +32,7 @@ class XDBCDictionarySource final : public IDictionarySource, WithContext
         const std::string db;
         const std::string schema;
         const std::string table;
+        const std::string query;
         const std::string where;
         const std::string invalidate_query;
         const std::string update_field;
