{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 26995,
  "instance_id": "ClickHouse__ClickHouse-26995",
  "issue_numbers": [
    "1270"
  ],
  "base_commit": "2d4030f98b4f6601b45e4fdbe992eb9022de9d68",
  "patch": "diff --git a/src/Dictionaries/CassandraDictionarySource.cpp b/src/Dictionaries/CassandraDictionarySource.cpp\nindex 8b31b4d6fa22..98928312ec87 100644\n--- a/src/Dictionaries/CassandraDictionarySource.cpp\n+++ b/src/Dictionaries/CassandraDictionarySource.cpp\n@@ -49,7 +49,7 @@ namespace ErrorCodes\n     extern const int INVALID_CONFIG_PARAMETER;\n }\n \n-CassandraSettings::CassandraSettings(\n+CassandraDictionarySource::Configuration::Configuration(\n     const Poco::Util::AbstractConfiguration & config,\n     const String & config_prefix)\n     : host(config.getString(config_prefix + \".host\"))\n@@ -66,7 +66,7 @@ CassandraSettings::CassandraSettings(\n     setConsistency(config.getString(config_prefix + \".consistency\", \"One\"));\n }\n \n-void CassandraSettings::setConsistency(const String & config_str)\n+void CassandraDictionarySource::Configuration::setConsistency(const String & config_str)\n {\n     if (config_str == \"One\")\n         consistency = CASS_CONSISTENCY_ONE;\n@@ -96,19 +96,19 @@ static const size_t max_block_size = 8192;\n \n CassandraDictionarySource::CassandraDictionarySource(\n     const DictionaryStructure & dict_struct_,\n-    const CassandraSettings & settings_,\n+    const Configuration & configuration_,\n     const Block & sample_block_)\n     : log(&Poco::Logger::get(\"CassandraDictionarySource\"))\n     , dict_struct(dict_struct_)\n-    , settings(settings_)\n+    , configuration(configuration_)\n     , sample_block(sample_block_)\n-    , query_builder(dict_struct, settings.db, \"\", settings.table, settings.where, IdentifierQuotingStyle::DoubleQuotes)\n+    , query_builder(dict_struct, configuration.db, \"\", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::DoubleQuotes)\n {\n-    cassandraCheck(cass_cluster_set_contact_points(cluster, settings.host.c_str()));\n-    if (settings.port)\n-        cassandraCheck(cass_cluster_set_port(cluster, settings.port));\n-    cass_cluster_set_credentials(cluster, settings.user.c_str(), settings.password.c_str());\n-    cassandraCheck(cass_cluster_set_consistency(cluster, settings.consistency));\n+    cassandraCheck(cass_cluster_set_contact_points(cluster, configuration.host.c_str()));\n+    if (configuration.port)\n+        cassandraCheck(cass_cluster_set_port(cluster, configuration.port));\n+    cass_cluster_set_credentials(cluster, configuration.user.c_str(), configuration.password.c_str());\n+    cassandraCheck(cass_cluster_set_consistency(cluster, configuration.consistency));\n }\n \n CassandraDictionarySource::CassandraDictionarySource(\n@@ -118,14 +118,14 @@ CassandraDictionarySource::CassandraDictionarySource(\n     Block & sample_block_)\n     : CassandraDictionarySource(\n         dict_struct_,\n-        CassandraSettings(config, config_prefix),\n+        Configuration(config, config_prefix),\n         sample_block_)\n {\n }\n \n void CassandraDictionarySource::maybeAllowFiltering(String & query) const\n {\n-    if (!settings.allow_filtering)\n+    if (!configuration.allow_filtering)\n         return;\n     query.pop_back();   /// remove semicolon\n     query += \" ALLOW FILTERING;\";\n@@ -141,7 +141,7 @@ Pipe CassandraDictionarySource::loadAll()\n \n std::string CassandraDictionarySource::toString() const\n {\n-    return \"Cassandra: \" + settings.db + '.' + settings.table;\n+    return \"Cassandra: \" + configuration.db + '.' + configuration.table;\n }\n \n Pipe CassandraDictionarySource::loadIds(const std::vector<UInt64> & ids)\n@@ -162,7 +162,7 @@ Pipe CassandraDictionarySource::loadKeys(const Columns & key_columns, const std:\n     for (const auto & row : requested_rows)\n     {\n         SipHash partition_key;\n-        for (size_t i = 0; i < settings.partition_key_prefix; ++i)\n+        for (size_t i = 0; i < configuration.partition_key_prefix; ++i)\n             key_columns[i]->updateHashWithValue(row, partition_key);\n         partitions[partition_key.get64()].push_back(row);\n     }\n@@ -170,7 +170,7 @@ Pipe CassandraDictionarySource::loadKeys(const Columns & key_columns, const std:\n     Pipes pipes;\n     for (const auto & partition : partitions)\n     {\n-        String query = query_builder.composeLoadKeysQuery(key_columns, partition.second, ExternalQueryBuilder::CASSANDRA_SEPARATE_PARTITION_KEY, settings.partition_key_prefix);\n+        String query = query_builder.composeLoadKeysQuery(key_columns, partition.second, ExternalQueryBuilder::CASSANDRA_SEPARATE_PARTITION_KEY, configuration.partition_key_prefix);\n         maybeAllowFiltering(query);\n         LOG_INFO(log, \"Loading keys for partition hash {} using query: {}\", partition.first, query);\n         pipes.push_back(Pipe(std::make_shared<CassandraSource>(getSession(), query, sample_block, max_block_size)));\ndiff --git a/src/Dictionaries/CassandraDictionarySource.h b/src/Dictionaries/CassandraDictionarySource.h\nindex 871e3dc4857b..35419d3ea7df 100644\n--- a/src/Dictionaries/CassandraDictionarySource.h\n+++ b/src/Dictionaries/CassandraDictionarySource.h\n@@ -14,33 +14,35 @@\n namespace DB\n {\n \n-struct CassandraSettings\n-{\n-    String host;\n-    UInt16 port;\n-    String user;\n-    String password;\n-    String db;\n-    String table;\n-\n-    CassConsistency consistency;\n-    bool allow_filtering;\n-    /// TODO get information about key from the driver\n-    size_t partition_key_prefix;\n-    size_t max_threads;\n-    String where;\n-\n-    CassandraSettings(const Poco::Util::AbstractConfiguration & config, const String & config_prefix);\n-\n-    void setConsistency(const String & config_str);\n-};\n-\n class CassandraDictionarySource final : public IDictionarySource\n {\n public:\n+\n+    struct Configuration\n+    {\n+        String host;\n+        UInt16 port;\n+        String user;\n+        String password;\n+        String db;\n+        String table;\n+        String query;\n+\n+        CassConsistency consistency;\n+        bool allow_filtering;\n+        /// TODO get information about key from the driver\n+        size_t partition_key_prefix;\n+        size_t max_threads;\n+        String where;\n+\n+        Configuration(const Poco::Util::AbstractConfiguration & config, const String & config_prefix);\n+\n+        void setConsistency(const String & config_str);\n+    };\n+\n     CassandraDictionarySource(\n         const DictionaryStructure & dict_struct,\n-        const CassandraSettings & settings_,\n+        const Configuration & configuration,\n         const Block & sample_block);\n \n     CassandraDictionarySource(\n@@ -59,7 +61,7 @@ class CassandraDictionarySource final : public IDictionarySource\n \n     DictionarySourcePtr clone() const override\n     {\n-        return std::make_unique<CassandraDictionarySource>(dict_struct, settings, sample_block);\n+        return std::make_unique<CassandraDictionarySource>(dict_struct, configuration, sample_block);\n     }\n \n     Pipe loadIds(const std::vector<UInt64> & ids) override;\n@@ -76,7 +78,7 @@ class CassandraDictionarySource final : public IDictionarySource\n \n     Poco::Logger * log;\n     const DictionaryStructure dict_struct;\n-    const CassandraSettings settings;\n+    const Configuration configuration;\n     Block sample_block;\n     ExternalQueryBuilder query_builder;\n \ndiff --git a/src/Dictionaries/ClickHouseDictionarySource.cpp b/src/Dictionaries/ClickHouseDictionarySource.cpp\nindex 8b2373302c81..0f085a7c1a2d 100644\n--- a/src/Dictionaries/ClickHouseDictionarySource.cpp\n+++ b/src/Dictionaries/ClickHouseDictionarySource.cpp\n@@ -67,7 +67,7 @@ ClickHouseDictionarySource::ClickHouseDictionarySource(\n     : update_time{std::chrono::system_clock::from_time_t(0)}\n     , dict_struct{dict_struct_}\n     , configuration{configuration_}\n-    , query_builder{dict_struct, configuration.db, \"\", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks}\n+    , query_builder{dict_struct, configuration.db, \"\", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks}\n     , sample_block{sample_block_}\n     , context(Context::createCopy(context_))\n     , pool{createPool(configuration)}\n@@ -83,7 +83,7 @@ ClickHouseDictionarySource::ClickHouseDictionarySource(const ClickHouseDictionar\n     , dict_struct{other.dict_struct}\n     , configuration{other.configuration}\n     , invalidate_query_response{other.invalidate_query_response}\n-    , query_builder{dict_struct, configuration.db, \"\", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks}\n+    , query_builder{dict_struct, configuration.db, \"\", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks}\n     , sample_block{other.sample_block}\n     , context(Context::createCopy(other.context))\n     , pool{createPool(configuration)}\n@@ -241,7 +241,8 @@ void registerDictionarySourceClickHouse(DictionarySourceFactory & factory)\n             .user = config.getString(settings_config_prefix + \".user\", \"default\"),\n             .password = config.getString(settings_config_prefix + \".password\", \"\"),\n             .db = config.getString(settings_config_prefix + \".db\", default_database),\n-            .table = config.getString(settings_config_prefix + \".table\"),\n+            .table = config.getString(settings_config_prefix + \".table\", \"\"),\n+            .query = config.getString(settings_config_prefix + \".query\", \"\"),\n             .where = config.getString(settings_config_prefix + \".where\", \"\"),\n             .invalidate_query = config.getString(settings_config_prefix + \".invalidate_query\", \"\"),\n             .update_field = config.getString(settings_config_prefix + \".update_field\", \"\"),\ndiff --git a/src/Dictionaries/ClickHouseDictionarySource.h b/src/Dictionaries/ClickHouseDictionarySource.h\nindex f293c010ec3d..2daa296af3e6 100644\n--- a/src/Dictionaries/ClickHouseDictionarySource.h\n+++ b/src/Dictionaries/ClickHouseDictionarySource.h\n@@ -25,6 +25,7 @@ class ClickHouseDictionarySource final : public IDictionarySource\n         const std::string password;\n         const std::string db;\n         const std::string table;\n+        const std::string query;\n         const std::string where;\n         const std::string invalidate_query;\n         const std::string update_field;\ndiff --git a/src/Dictionaries/ExternalQueryBuilder.cpp b/src/Dictionaries/ExternalQueryBuilder.cpp\nindex e0920535e335..10c4f67d8090 100644\n--- a/src/Dictionaries/ExternalQueryBuilder.cpp\n+++ b/src/Dictionaries/ExternalQueryBuilder.cpp\n@@ -21,10 +21,23 @@ ExternalQueryBuilder::ExternalQueryBuilder(\n     const std::string & db_,\n     const std::string & schema_,\n     const std::string & table_,\n+    const std::string & query_,\n     const std::string & where_,\n     IdentifierQuotingStyle quoting_style_)\n-    : dict_struct(dict_struct_), db(db_), schema(schema_), table(table_), where(where_), quoting_style(quoting_style_)\n-{}\n+    : dict_struct(dict_struct_)\n+    , db(db_)\n+    , schema(schema_)\n+    , table(table_)\n+    , query(query_)\n+    , where(where_)\n+    , quoting_style(quoting_style_)\n+{\n+    if (table.empty() && query.empty())\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Setting `table` or `query` must be non empty\");\n+\n+    if (!query.empty() && (!table.empty() || !where.empty()))\n+        throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Setting `table` or `where` cannot be used with `query` parameter\");\n+}\n \n \n void ExternalQueryBuilder::writeQuoted(const std::string & s, WriteBuffer & out) const\n@@ -52,10 +65,17 @@ void ExternalQueryBuilder::writeQuoted(const std::string & s, WriteBuffer & out)\n \n std::string ExternalQueryBuilder::composeLoadAllQuery() const\n {\n-    WriteBufferFromOwnString out;\n-    composeLoadAllQuery(out);\n-    writeChar(';', out);\n-    return out.str();\n+    if (query.empty())\n+    {\n+        WriteBufferFromOwnString out;\n+        composeLoadAllQuery(out);\n+        writeChar(';', out);\n+        return out.str();\n+    }\n+    else\n+    {\n+        return query;\n+    }\n }\n \n void ExternalQueryBuilder::composeLoadAllQuery(WriteBuffer & out) const\n@@ -152,95 +172,135 @@ void ExternalQueryBuilder::composeLoadAllQuery(WriteBuffer & out) const\n std::string ExternalQueryBuilder::composeUpdateQuery(const std::string & update_field, const std::string & time_point) const\n {\n     WriteBufferFromOwnString out;\n-    composeLoadAllQuery(out);\n \n-    if (!where.empty())\n-        writeString(\" AND \", out);\n+    if (query.empty())\n+    {\n+        composeLoadAllQuery(out);\n+\n+        if (!where.empty())\n+            writeString(\" AND \", out);\n+        else\n+            writeString(\" WHERE \", out);\n+\n+        composeUpdateCondition(update_field, time_point, out);\n+\n+        writeChar(';', out);\n+\n+        return out.str();\n+    }\n     else\n-        writeString(\" WHERE \", out);\n+    {\n+        writeString(query, out);\n \n-    writeString(update_field, out);\n-    writeString(\" >= '\", out);\n-    writeString(time_point, out);\n-    writeChar('\\'', out);\n+        auto condition_position = query.find(\"{condition}\");\n+        if (condition_position == std::string::npos)\n+        {\n+            writeString(\" WHERE \", out);\n+            composeUpdateCondition(update_field, time_point, out);\n+            writeString(\";\", out);\n+\n+            return out.str();\n+        }\n \n-    writeChar(';', out);\n-    return out.str();\n+        WriteBufferFromOwnString condition_value_buffer;\n+        composeUpdateCondition(update_field, time_point, condition_value_buffer);\n+        const auto & condition_value = condition_value_buffer.str();\n+\n+        auto query_copy = query;\n+        query_copy.replace(condition_position, condition_value.size(), condition_value);\n+\n+        return query_copy;\n+    }\n }\n \n \n-std::string ExternalQueryBuilder::composeLoadIdsQuery(const std::vector<UInt64> & ids)\n+std::string ExternalQueryBuilder::composeLoadIdsQuery(const std::vector<UInt64> & ids) const\n {\n     if (!dict_struct.id)\n         throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Simple key required for method\");\n \n     WriteBufferFromOwnString out;\n-    writeString(\"SELECT \", out);\n \n-    if (!dict_struct.id->expression.empty())\n+    if (query.empty())\n     {\n-        writeParenthesisedString(dict_struct.id->expression, out);\n-        writeString(\" AS \", out);\n-    }\n+        writeString(\"SELECT \", out);\n \n-    writeQuoted(dict_struct.id->name, out);\n+        if (!dict_struct.id->expression.empty())\n+        {\n+            writeParenthesisedString(dict_struct.id->expression, out);\n+            writeString(\" AS \", out);\n+        }\n \n-    for (const auto & attr : dict_struct.attributes)\n-    {\n-        writeString(\", \", out);\n+        writeQuoted(dict_struct.id->name, out);\n \n-        if (!attr.expression.empty())\n+        for (const auto & attr : dict_struct.attributes)\n         {\n-            writeParenthesisedString(attr.expression, out);\n-            writeString(\" AS \", out);\n+            writeString(\", \", out);\n+\n+            if (!attr.expression.empty())\n+            {\n+                writeParenthesisedString(attr.expression, out);\n+                writeString(\" AS \", out);\n+            }\n+\n+            writeQuoted(attr.name, out);\n         }\n \n-        writeQuoted(attr.name, out);\n-    }\n+        writeString(\" FROM \", out);\n+        if (!db.empty())\n+        {\n+            writeQuoted(db, out);\n+            writeChar('.', out);\n+        }\n+        if (!schema.empty())\n+        {\n+            writeQuoted(schema, out);\n+            writeChar('.', out);\n+        }\n \n-    writeString(\" FROM \", out);\n-    if (!db.empty())\n-    {\n-        writeQuoted(db, out);\n-        writeChar('.', out);\n-    }\n-    if (!schema.empty())\n-    {\n-        writeQuoted(schema, out);\n-        writeChar('.', out);\n-    }\n+        writeQuoted(table, out);\n \n-    writeQuoted(table, out);\n+        writeString(\" WHERE \", out);\n \n-    writeString(\" WHERE \", out);\n+        if (!where.empty())\n+        {\n+            writeString(where, out);\n+            writeString(\" AND \", out);\n+        }\n \n-    if (!where.empty())\n-    {\n-        writeString(where, out);\n-        writeString(\" AND \", out);\n+        composeIdsCondition(ids, out);\n+        writeString(\";\", out);\n+\n+        return out.str();\n     }\n+    else\n+    {\n+        writeString(query, out);\n \n-    writeQuoted(dict_struct.id->name, out);\n-    writeString(\" IN (\", out);\n+        auto condition_position = query.find(\"{condition}\");\n+        if (condition_position == std::string::npos)\n+        {\n+            writeString(\" WHERE \", out);\n+            composeIdsCondition(ids, out);\n+            writeString(\";\", out);\n \n-    auto first = true;\n-    for (const auto id : ids)\n-    {\n-        if (!first)\n-            writeString(\", \", out);\n+            return out.str();\n+        }\n \n-        first = false;\n-        writeString(DB::toString(id), out);\n-    }\n+        WriteBufferFromOwnString condition_value_buffer;\n+        composeIdsCondition(ids, condition_value_buffer);\n+        const auto & condition_value = condition_value_buffer.str();\n \n-    writeString(\");\", out);\n+        auto query_copy = query;\n+        query_copy.replace(condition_position, condition_value.size(), condition_value);\n \n-    return out.str();\n+        return query_copy;\n+    }\n }\n \n \n std::string ExternalQueryBuilder::composeLoadKeysQuery(\n-    const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix)\n+    const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix) const\n {\n     if (!dict_struct.key)\n         throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"Composite key required for method\");\n@@ -249,99 +309,88 @@ std::string ExternalQueryBuilder::composeLoadKeysQuery(\n         throw Exception(ErrorCodes::LOGICAL_ERROR, \"The size of key_columns does not equal to the size of dictionary key\");\n \n     WriteBufferFromOwnString out;\n-    writeString(\"SELECT \", out);\n \n-    auto first = true;\n-    for (const auto & key_or_attribute : boost::join(*dict_struct.key, dict_struct.attributes))\n+    if (query.empty())\n     {\n-        if (!first)\n-            writeString(\", \", out);\n+        writeString(\"SELECT \", out);\n \n-        first = false;\n+        auto first = true;\n+        for (const auto & key_or_attribute : boost::join(*dict_struct.key, dict_struct.attributes))\n+        {\n+            if (!first)\n+                writeString(\", \", out);\n+\n+            first = false;\n+\n+            if (!key_or_attribute.expression.empty())\n+            {\n+                writeParenthesisedString(key_or_attribute.expression, out);\n+                writeString(\" AS \", out);\n+            }\n+\n+            writeQuoted(key_or_attribute.name, out);\n+        }\n \n-        if (!key_or_attribute.expression.empty())\n+        writeString(\" FROM \", out);\n+        if (!db.empty())\n         {\n-            writeParenthesisedString(key_or_attribute.expression, out);\n-            writeString(\" AS \", out);\n+            writeQuoted(db, out);\n+            writeChar('.', out);\n+        }\n+        if (!schema.empty())\n+        {\n+            writeQuoted(schema, out);\n+            writeChar('.', out);\n         }\n \n-        writeQuoted(key_or_attribute.name, out);\n-    }\n+        writeQuoted(table, out);\n \n-    writeString(\" FROM \", out);\n-    if (!db.empty())\n-    {\n-        writeQuoted(db, out);\n-        writeChar('.', out);\n-    }\n-    if (!schema.empty())\n-    {\n-        writeQuoted(schema, out);\n-        writeChar('.', out);\n-    }\n+        writeString(\" WHERE \", out);\n \n-    writeQuoted(table, out);\n+        if (!where.empty())\n+        {\n+            if (method != CASSANDRA_SEPARATE_PARTITION_KEY)\n+                writeString(\"(\", out);\n+            writeString(where, out);\n+            if (method != CASSANDRA_SEPARATE_PARTITION_KEY)\n+                writeString(\") AND (\", out);\n+            else\n+                writeString(\" AND \", out);\n+        }\n \n-    writeString(\" WHERE \", out);\n+        composeKeysCondition(key_columns, requested_rows, method, partition_key_prefix, out);\n \n-    if (!where.empty())\n-    {\n-        if (method != CASSANDRA_SEPARATE_PARTITION_KEY)\n-            writeString(\"(\", out);\n-        writeString(where, out);\n-        if (method != CASSANDRA_SEPARATE_PARTITION_KEY)\n-            writeString(\") AND (\", out);\n-        else\n-            writeString(\" AND \", out);\n-    }\n+        writeString(\";\", out);\n \n-    if (method == AND_OR_CHAIN)\n+        return out.str();\n+    }\n+    else\n     {\n-        first = true;\n-        for (const auto row : requested_rows)\n-        {\n-            if (!first)\n-                writeString(\" OR \", out);\n+        writeString(query, out);\n \n-            first = false;\n+        auto condition_position = query.find(\"{condition}\");\n+        if (condition_position == std::string::npos)\n+        {\n+            writeString(\" WHERE \", out);\n+            composeKeysCondition(key_columns, requested_rows, method, partition_key_prefix, out);\n+            writeString(\";\", out);\n \n-            writeString(\"(\", out);\n-            composeKeyCondition(key_columns, row, out, 0, key_columns.size());\n-            writeString(\")\", out);\n+            return out.str();\n         }\n-    }\n-    else if (method == IN_WITH_TUPLES)\n-    {\n-        composeInWithTuples(key_columns, requested_rows, out, 0, key_columns.size());\n-    }\n-    else /* if (method == CASSANDRA_SEPARATE_PARTITION_KEY) */\n-    {\n-        /// CQL does not allow using OR conditions\n-        /// and does not allow using multi-column IN expressions with partition key columns.\n-        /// So we have to use multiple queries with conditions like\n-        /// (partition_key_1 = val1 AND partition_key_2 = val2 ...) AND (clustering_key_1, ...) IN ((val3, ...), ...)\n-        /// for each partition key.\n-        /// `partition_key_prefix` is a number of columns from partition key.\n-        /// All `requested_rows` must have the same values of partition key.\n-        composeKeyCondition(key_columns, requested_rows.at(0), out, 0, partition_key_prefix);\n-        if (partition_key_prefix && partition_key_prefix < key_columns.size())\n-            writeString(\" AND \", out);\n-        if (partition_key_prefix < key_columns.size())\n-            composeInWithTuples(key_columns, requested_rows, out, partition_key_prefix, key_columns.size());\n-    }\n \n-    if (!where.empty() && method != CASSANDRA_SEPARATE_PARTITION_KEY)\n-    {\n-        writeString(\")\", out);\n-    }\n+        WriteBufferFromOwnString condition_value_buffer;\n+        composeKeysCondition(key_columns, requested_rows, method, partition_key_prefix, condition_value_buffer);\n+        const auto & condition_value = condition_value_buffer.str();\n \n-    writeString(\";\", out);\n+        auto query_copy = query;\n+        query_copy.replace(condition_position, condition_value.size(), condition_value);\n \n-    return out.str();\n+        return query_copy;\n+    }\n }\n \n \n-void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, const size_t row, WriteBuffer & out,\n+void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, size_t row, WriteBuffer & out,\n                                                size_t beg, size_t end) const\n {\n     auto first = true;\n@@ -363,7 +412,7 @@ void ExternalQueryBuilder::composeKeyCondition(const Columns & key_columns, cons\n \n \n void ExternalQueryBuilder::composeInWithTuples(const Columns & key_columns, const std::vector<size_t> & requested_rows,\n-                                               WriteBuffer & out, size_t beg, size_t end)\n+                                               WriteBuffer & out, size_t beg, size_t end) const\n {\n     composeKeyTupleDefinition(out, beg, end);\n     writeString(\" IN (\", out);\n@@ -403,7 +452,7 @@ void ExternalQueryBuilder::composeKeyTupleDefinition(WriteBuffer & out, size_t b\n }\n \n \n-void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const size_t row, WriteBuffer & out, size_t beg, size_t end) const\n+void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, size_t row, WriteBuffer & out, size_t beg, size_t end) const\n {\n     writeString(\"(\", out);\n \n@@ -421,5 +470,75 @@ void ExternalQueryBuilder::composeKeyTuple(const Columns & key_columns, const si\n     writeString(\")\", out);\n }\n \n+void ExternalQueryBuilder::composeUpdateCondition(const std::string & update_field, const std::string & time_point, WriteBuffer & out)\n+{\n+    writeString(update_field, out);\n+    writeString(\" >= '\", out);\n+    writeString(time_point, out);\n+    writeChar('\\'', out);\n+}\n+\n+void ExternalQueryBuilder::composeIdsCondition(const std::vector<UInt64> & ids, WriteBuffer & out) const\n+{\n+    writeQuoted(dict_struct.id->name, out);\n+    writeString(\" IN (\", out);\n+\n+    auto first = true;\n+    for (const auto id : ids)\n+    {\n+        if (!first)\n+            writeString(\", \", out);\n+\n+        first = false;\n+        writeString(DB::toString(id), out);\n+    }\n+\n+    writeString(\")\", out);\n+}\n+\n+void ExternalQueryBuilder::composeKeysCondition(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix, WriteBuffer & out) const\n+{\n+    bool first = true;\n+\n+    if (method == AND_OR_CHAIN)\n+    {\n+        first = true;\n+        for (const auto row : requested_rows)\n+        {\n+            if (!first)\n+                writeString(\" OR \", out);\n+\n+            first = false;\n+\n+            writeString(\"(\", out);\n+            composeKeyCondition(key_columns, row, out, 0, key_columns.size());\n+            writeString(\")\", out);\n+        }\n+    }\n+    else if (method == IN_WITH_TUPLES)\n+    {\n+        composeInWithTuples(key_columns, requested_rows, out, 0, key_columns.size());\n+    }\n+    else /* if (method == CASSANDRA_SEPARATE_PARTITION_KEY) */\n+    {\n+        /// CQL does not allow using OR conditions\n+        /// and does not allow using multi-column IN expressions with partition key columns.\n+        /// So we have to use multiple queries with conditions like\n+        /// (partition_key_1 = val1 AND partition_key_2 = val2 ...) AND (clustering_key_1, ...) IN ((val3, ...), ...)\n+        /// for each partition key.\n+        /// `partition_key_prefix` is a number of columns from partition key.\n+        /// All `requested_rows` must have the same values of partition key.\n+        composeKeyCondition(key_columns, requested_rows.at(0), out, 0, partition_key_prefix);\n+        if (partition_key_prefix && partition_key_prefix < key_columns.size())\n+            writeString(\" AND \", out);\n+        if (partition_key_prefix < key_columns.size())\n+            composeInWithTuples(key_columns, requested_rows, out, partition_key_prefix, key_columns.size());\n+    }\n+\n+    if (!where.empty() && method != CASSANDRA_SEPARATE_PARTITION_KEY)\n+    {\n+        writeString(\")\", out);\n+    }\n+}\n \n }\ndiff --git a/src/Dictionaries/ExternalQueryBuilder.h b/src/Dictionaries/ExternalQueryBuilder.h\nindex 9f9ccd65001b..9d79ec3e702f 100644\n--- a/src/Dictionaries/ExternalQueryBuilder.h\n+++ b/src/Dictionaries/ExternalQueryBuilder.h\n@@ -21,6 +21,7 @@ struct ExternalQueryBuilder\n     const std::string db;\n     const std::string schema;\n     const std::string table;\n+    const std::string query;\n     const std::string where;\n \n     IdentifierQuotingStyle quoting_style;\n@@ -31,6 +32,7 @@ struct ExternalQueryBuilder\n         const std::string & db_,\n         const std::string & schema_,\n         const std::string & table_,\n+        const std::string & query_,\n         const std::string & where_,\n         IdentifierQuotingStyle quoting_style_);\n \n@@ -41,7 +43,7 @@ struct ExternalQueryBuilder\n     std::string composeUpdateQuery(const std::string & update_field, const std::string & time_point) const;\n \n     /** Generate a query to load data by set of UInt64 keys. */\n-    std::string composeLoadIdsQuery(const std::vector<UInt64> & ids);\n+    std::string composeLoadIdsQuery(const std::vector<UInt64> & ids) const;\n \n     /** Generate a query to load data by set of composite keys.\n       * There are three methods of specification of composite keys in WHERE:\n@@ -56,7 +58,7 @@ struct ExternalQueryBuilder\n         CASSANDRA_SEPARATE_PARTITION_KEY,\n     };\n \n-    std::string composeLoadKeysQuery(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix = 0);\n+    std::string composeLoadKeysQuery(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix = 0) const;\n \n \n private:\n@@ -67,16 +69,25 @@ struct ExternalQueryBuilder\n     /// In the following methods `beg` and `end` specifies which columns to write in expression\n \n     /// Expression in form (x = c1 AND y = c2 ...)\n-    void composeKeyCondition(const Columns & key_columns, const size_t row, WriteBuffer & out, size_t beg, size_t end) const;\n+    void composeKeyCondition(const Columns & key_columns, size_t row, WriteBuffer & out, size_t beg, size_t end) const;\n \n     /// Expression in form (x, y, ...) IN ((c1, c2, ...), ...)\n-    void composeInWithTuples(const Columns & key_columns, const std::vector<size_t> & requested_rows, WriteBuffer & out, size_t beg, size_t end);\n+    void composeInWithTuples(const Columns & key_columns, const std::vector<size_t> & requested_rows, WriteBuffer & out, size_t beg, size_t end) const;\n \n     /// Expression in form (x, y, ...)\n     void composeKeyTupleDefinition(WriteBuffer & out, size_t beg, size_t end) const;\n \n     /// Expression in form (c1, c2, ...)\n-    void composeKeyTuple(const Columns & key_columns, const size_t row, WriteBuffer & out, size_t beg, size_t end) const;\n+    void composeKeyTuple(const Columns & key_columns, size_t row, WriteBuffer & out, size_t beg, size_t end) const;\n+\n+    /// Compose update condition\n+    static void composeUpdateCondition(const std::string & update_field, const std::string & time_point, WriteBuffer & out);\n+\n+    /// Compose ids condition\n+    void composeIdsCondition(const std::vector<UInt64> & ids, WriteBuffer & out) const;\n+\n+    /// Compose keys condition\n+    void composeKeysCondition(const Columns & key_columns, const std::vector<size_t> & requested_rows, LoadKeysMethod method, size_t partition_key_prefix, WriteBuffer & out) const;\n \n     /// Write string with specified quoting style.\n     void writeQuoted(const std::string & s, WriteBuffer & out) const;\ndiff --git a/src/Dictionaries/MySQLDictionarySource.cpp b/src/Dictionaries/MySQLDictionarySource.cpp\nindex c7309ddb950b..2eebb6970d03 100644\n--- a/src/Dictionaries/MySQLDictionarySource.cpp\n+++ b/src/Dictionaries/MySQLDictionarySource.cpp\n@@ -22,6 +22,7 @@ static const size_t default_num_tries_on_connection_loss = 3;\n namespace ErrorCodes\n {\n     extern const int SUPPORT_IS_DISABLED;\n+    extern const int UNSUPPORTED_METHOD;\n }\n \n void registerDictionarySourceMysql(DictionarySourceFactory & factory)\n@@ -41,11 +42,19 @@ void registerDictionarySourceMysql(DictionarySourceFactory & factory)\n \n         auto settings_config_prefix = config_prefix + \".mysql\";\n \n+        auto table = config.getString(settings_config_prefix + \".table\", \"\");\n+        auto where = config.getString(settings_config_prefix + \".where\", \"\");\n+        auto query = config.getString(settings_config_prefix + \".query\", \"\");\n+\n+        if (query.empty() && table.empty())\n+            throw Exception(ErrorCodes::UNSUPPORTED_METHOD, \"MySQL dictionary source configuration must contain table or query field\");\n+\n         MySQLDictionarySource::Configuration configuration\n         {\n             .db = config.getString(settings_config_prefix + \".db\", \"\"),\n-            .table = config.getString(settings_config_prefix + \".table\"),\n-            .where = config.getString(settings_config_prefix + \".where\", \"\"),\n+            .table = table,\n+            .query = query,\n+            .where = where,\n             .invalidate_query = config.getString(settings_config_prefix + \".invalidate_query\", \"\"),\n             .update_field = config.getString(settings_config_prefix + \".update_field\", \"\"),\n             .update_lag = config.getUInt64(settings_config_prefix + \".update_lag\", 1),\n@@ -94,7 +103,7 @@ MySQLDictionarySource::MySQLDictionarySource(\n     , configuration(configuration_)\n     , pool(std::move(pool_))\n     , sample_block(sample_block_)\n-    , query_builder(dict_struct, configuration.db, \"\", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks)\n+    , query_builder(dict_struct, configuration.db, \"\", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks)\n     , load_all_query(query_builder.composeLoadAllQuery())\n     , settings(settings_)\n {\n@@ -108,7 +117,7 @@ MySQLDictionarySource::MySQLDictionarySource(const MySQLDictionarySource & other\n     , configuration(other.configuration)\n     , pool(other.pool)\n     , sample_block(other.sample_block)\n-    , query_builder{dict_struct, configuration.db, \"\", configuration.table, configuration.where, IdentifierQuotingStyle::Backticks}\n+    , query_builder{dict_struct, configuration.db, \"\", configuration.table, configuration.query, configuration.where, IdentifierQuotingStyle::Backticks}\n     , load_all_query{other.load_all_query}\n     , last_modification{other.last_modification}\n     , invalidate_query_response{other.invalidate_query_response}\n@@ -128,7 +137,7 @@ std::string MySQLDictionarySource::getUpdateFieldAndDate()\n     else\n     {\n         update_time = std::chrono::system_clock::now();\n-        return query_builder.composeLoadAllQuery();\n+        return load_all_query;\n     }\n }\n \ndiff --git a/src/Dictionaries/MySQLDictionarySource.h b/src/Dictionaries/MySQLDictionarySource.h\nindex 49ddc924a865..afa6aa61d283 100644\n--- a/src/Dictionaries/MySQLDictionarySource.h\n+++ b/src/Dictionaries/MySQLDictionarySource.h\n@@ -35,6 +35,7 @@ class MySQLDictionarySource final : public IDictionarySource\n     {\n         const std::string db;\n         const std::string table;\n+        const std::string query;\n         const std::string where;\n         const std::string invalidate_query;\n         const std::string update_field;\ndiff --git a/src/Dictionaries/PostgreSQLDictionarySource.cpp b/src/Dictionaries/PostgreSQLDictionarySource.cpp\nindex f226b7a9165e..21b8809bc858 100644\n--- a/src/Dictionaries/PostgreSQLDictionarySource.cpp\n+++ b/src/Dictionaries/PostgreSQLDictionarySource.cpp\n@@ -27,7 +27,7 @@ static const UInt64 max_block_size = 8192;\n \n namespace\n {\n-    ExternalQueryBuilder makeExternalQueryBuilder(const DictionaryStructure & dict_struct, const String & schema, const String & table, const String & where)\n+    ExternalQueryBuilder makeExternalQueryBuilder(const DictionaryStructure & dict_struct, const String & schema, const String & table, const String & query, const String & where)\n     {\n         auto schema_value = schema;\n         auto table_value = table;\n@@ -41,7 +41,7 @@ namespace\n             }\n         }\n         /// Do not need db because it is already in a connection string.\n-        return {dict_struct, \"\", schema_value, table_value, where, IdentifierQuotingStyle::DoubleQuotes};\n+        return {dict_struct, \"\", schema_value, table_value, query, where, IdentifierQuotingStyle::DoubleQuotes};\n     }\n }\n \n@@ -56,7 +56,7 @@ PostgreSQLDictionarySource::PostgreSQLDictionarySource(\n     , pool(std::move(pool_))\n     , sample_block(sample_block_)\n     , log(&Poco::Logger::get(\"PostgreSQLDictionarySource\"))\n-    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.where))\n+    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.query, configuration.where))\n     , load_all_query(query_builder.composeLoadAllQuery())\n {\n }\n@@ -69,7 +69,7 @@ PostgreSQLDictionarySource::PostgreSQLDictionarySource(const PostgreSQLDictionar\n     , pool(other.pool)\n     , sample_block(other.sample_block)\n     , log(&Poco::Logger::get(\"PostgreSQLDictionarySource\"))\n-    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.where))\n+    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.schema, configuration.table, configuration.query, configuration.where))\n     , load_all_query(query_builder.composeLoadAllQuery())\n     , update_time(other.update_time)\n     , invalidate_query_response(other.invalidate_query_response)\n@@ -198,6 +198,7 @@ void registerDictionarySourcePostgreSQL(DictionarySourceFactory & factory)\n             .db = config.getString(fmt::format(\"{}.db\", settings_config_prefix), \"\"),\n             .schema = config.getString(fmt::format(\"{}.schema\", settings_config_prefix), \"\"),\n             .table = config.getString(fmt::format(\"{}.table\", settings_config_prefix), \"\"),\n+            .query = config.getString(fmt::format(\"{}.query\", settings_config_prefix), \"\"),\n             .where = config.getString(fmt::format(\"{}.where\", settings_config_prefix), \"\"),\n             .invalidate_query = config.getString(fmt::format(\"{}.invalidate_query\", settings_config_prefix), \"\"),\n             .update_field = config.getString(fmt::format(\"{}.update_field\", settings_config_prefix), \"\"),\ndiff --git a/src/Dictionaries/PostgreSQLDictionarySource.h b/src/Dictionaries/PostgreSQLDictionarySource.h\nindex 28ad28661edd..c5ade4d259a2 100644\n--- a/src/Dictionaries/PostgreSQLDictionarySource.h\n+++ b/src/Dictionaries/PostgreSQLDictionarySource.h\n@@ -26,6 +26,7 @@ class PostgreSQLDictionarySource final : public IDictionarySource\n         const String db;\n         const String schema;\n         const String table;\n+        const String query;\n         const String where;\n         const String invalidate_query;\n         const String update_field;\ndiff --git a/src/Dictionaries/XDBCDictionarySource.cpp b/src/Dictionaries/XDBCDictionarySource.cpp\nindex 26b6c24cd2d4..80d3df1caabc 100644\n--- a/src/Dictionaries/XDBCDictionarySource.cpp\n+++ b/src/Dictionaries/XDBCDictionarySource.cpp\n@@ -34,6 +34,7 @@ namespace\n                                                   const std::string & db_,\n                                                   const std::string & schema_,\n                                                   const std::string & table_,\n+                                                  const std::string & query_,\n                                                   const std::string & where_,\n                                                   IXDBCBridgeHelper & bridge_)\n     {\n@@ -59,7 +60,7 @@ namespace\n                     bridge_.getName());\n         }\n \n-        return {dict_struct_, db_, schema, table, where_, bridge_.getIdentifierQuotingStyle()};\n+        return {dict_struct_, db_, schema, table, query_, where_, bridge_.getIdentifierQuotingStyle()};\n     }\n }\n \n@@ -78,7 +79,7 @@ XDBCDictionarySource::XDBCDictionarySource(\n     , dict_struct(dict_struct_)\n     , configuration(configuration_)\n     , sample_block(sample_block_)\n-    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.db, configuration.schema, configuration.table, configuration.where, *bridge_))\n+    , query_builder(makeExternalQueryBuilder(dict_struct, configuration.db, configuration.schema, configuration.table, configuration.query, configuration.where, *bridge_))\n     , load_all_query(query_builder.composeLoadAllQuery())\n     , bridge_helper(bridge_)\n     , bridge_url(bridge_helper->getMainURI())\n@@ -119,7 +120,7 @@ std::string XDBCDictionarySource::getUpdateFieldAndDate()\n     else\n     {\n         update_time = std::chrono::system_clock::now();\n-        return query_builder.composeLoadAllQuery();\n+        return load_all_query;\n     }\n }\n \n@@ -246,7 +247,8 @@ void registerDictionarySourceXDBC(DictionarySourceFactory & factory)\n         {\n             .db = config.getString(settings_config_prefix + \".db\", \"\"),\n             .schema = config.getString(settings_config_prefix + \".schema\", \"\"),\n-            .table = config.getString(settings_config_prefix + \".table\"),\n+            .table = config.getString(settings_config_prefix + \".table\", \"\"),\n+            .query = config.getString(settings_config_prefix + \".query\", \"\"),\n             .where = config.getString(settings_config_prefix + \".where\", \"\"),\n             .invalidate_query = config.getString(settings_config_prefix + \".invalidate_query\", \"\"),\n             .update_field = config.getString(settings_config_prefix + \".update_field\", \"\"),\ndiff --git a/src/Dictionaries/XDBCDictionarySource.h b/src/Dictionaries/XDBCDictionarySource.h\nindex ebced022b624..df31e8a87cf9 100644\n--- a/src/Dictionaries/XDBCDictionarySource.h\n+++ b/src/Dictionaries/XDBCDictionarySource.h\n@@ -32,6 +32,7 @@ class XDBCDictionarySource final : public IDictionarySource, WithContext\n         const std::string db;\n         const std::string schema;\n         const std::string table;\n+        const std::string query;\n         const std::string where;\n         const std::string invalidate_query;\n         const std::string update_field;\n",
  "test_patch": "diff --git a/tests/integration/test_dictionaries_mysql/test.py b/tests/integration/test_dictionaries_mysql/test.py\nindex fe284f71e00a..fa3855d1e16e 100644\n--- a/tests/integration/test_dictionaries_mysql/test.py\n+++ b/tests/integration/test_dictionaries_mysql/test.py\n@@ -1,4 +1,5 @@\n ## sudo -H pip install PyMySQL\n+import warnings\n import pymysql.cursors\n import pytest\n from helpers.cluster import ClickHouseCluster\n@@ -46,23 +47,114 @@ def started_cluster():\n         cluster.shutdown()\n \n \n-def test_load_mysql_dictionaries(started_cluster):\n-    # Load dictionaries\n+def test_mysql_dictionaries_custom_query_full_load(started_cluster):\n+    mysql_connection = get_mysql_conn(started_cluster)\n+\n+    execute_mysql_query(mysql_connection, \"CREATE TABLE IF NOT EXISTS test.test_table_1 (id Integer, value_1 Text);\")\n+    execute_mysql_query(mysql_connection, \"CREATE TABLE IF NOT EXISTS test.test_table_2 (id Integer, value_2 Text);\")\n+    execute_mysql_query(mysql_connection, \"INSERT INTO test.test_table_1 VALUES (1, 'Value_1');\")\n+    execute_mysql_query(mysql_connection, \"INSERT INTO test.test_table_2 VALUES (1, 'Value_2');\")\n+\n     query = instance.query\n-    query(\"SYSTEM RELOAD DICTIONARIES\")\n+    query(\"\"\"\n+    CREATE DICTIONARY test_dictionary_custom_query\n+    (\n+        id UInt64,\n+        value_1 String,\n+        value_2 String\n+    )\n+    PRIMARY KEY id\n+    LAYOUT(FLAT())\n+    SOURCE(MYSQL(\n+        HOST 'mysql57'\n+        PORT 3306\n+        USER 'root'\n+        PASSWORD 'clickhouse'\n+        QUERY $doc$SELECT id, value_1, value_2 FROM test.test_table_1 INNER JOIN test.test_table_2 USING (id);$doc$))\n+    LIFETIME(0)\n+    \"\"\")\n+\n+    result = query(\"SELECT id, value_1, value_2 FROM test_dictionary_custom_query\")\n+\n+    assert result == '1\\tValue_1\\tValue_2\\n'\n+\n+    query(\"DROP DICTIONARY test_dictionary_custom_query;\")\n+\n+    execute_mysql_query(mysql_connection, \"DROP TABLE test.test_table_1;\")\n+    execute_mysql_query(mysql_connection, \"DROP TABLE test.test_table_2;\")\n+\n+\n+def test_mysql_dictionaries_custom_query_partial_load_simple_key(started_cluster):\n+    mysql_connection = get_mysql_conn(started_cluster)\n+\n+    execute_mysql_query(mysql_connection, \"CREATE TABLE IF NOT EXISTS test.test_table_1 (id Integer, value_1 Text);\")\n+    execute_mysql_query(mysql_connection, \"CREATE TABLE IF NOT EXISTS test.test_table_2 (id Integer, value_2 Text);\")\n+    execute_mysql_query(mysql_connection, \"INSERT INTO test.test_table_1 VALUES (1, 'Value_1');\")\n+    execute_mysql_query(mysql_connection, \"INSERT INTO test.test_table_2 VALUES (1, 'Value_2');\")\n \n-    for n in range(0, 5):\n-        # Create MySQL tables, fill them and create CH dict tables\n-        prepare_mysql_table(started_cluster, 'test', str(n))\n+    query = instance.query\n+    query(\"\"\"\n+    CREATE DICTIONARY test_dictionary_custom_query\n+    (\n+        id UInt64,\n+        value_1 String,\n+        value_2 String\n+    )\n+    PRIMARY KEY id\n+    LAYOUT(DIRECT())\n+    SOURCE(MYSQL(\n+        HOST 'mysql57'\n+        PORT 3306\n+        USER 'root'\n+        PASSWORD 'clickhouse'\n+        QUERY $doc$SELECT id, value_1, value_2 FROM test.test_table_1 INNER JOIN test.test_table_2 USING (id) WHERE {condition};$doc$))\n+    \"\"\")\n+\n+    result = query(\"SELECT dictGet('test_dictionary_custom_query', ('value_1', 'value_2'), toUInt64(1))\")\n+\n+    assert result == \"('Value_1','Value_2')\\n\"\n+\n+    query(\"DROP DICTIONARY test_dictionary_custom_query;\")\n+\n+    execute_mysql_query(mysql_connection, \"DROP TABLE test.test_table_1;\")\n+    execute_mysql_query(mysql_connection, \"DROP TABLE test.test_table_2;\")\n+\n+\n+def test_mysql_dictionaries_custom_query_partial_load_complex_key(started_cluster):\n+    mysql_connection = get_mysql_conn(started_cluster)\n \n-    # Check dictionaries are loaded and have correct number of elements\n-    for n in range(0, 100):\n-        # Force reload of dictionaries (each 10 iteration)\n-        if (n % 10) == 0:\n-            query(\"SYSTEM RELOAD DICTIONARIES\")\n+    execute_mysql_query(mysql_connection, \"CREATE TABLE IF NOT EXISTS test.test_table_1 (id Integer, id_key Text, value_1 Text);\")\n+    execute_mysql_query(mysql_connection, \"CREATE TABLE IF NOT EXISTS test.test_table_2 (id Integer, id_key Text, value_2 Text);\")\n+    execute_mysql_query(mysql_connection, \"INSERT INTO test.test_table_1 VALUES (1, 'Key', 'Value_1');\")\n+    execute_mysql_query(mysql_connection, \"INSERT INTO test.test_table_2 VALUES (1, 'Key', 'Value_2');\")\n \n-        # Check number of row\n-        assert query(\"SELECT count() FROM `test`.`dict_table_{}`\".format('test' + str(n % 5))).rstrip() == '10000'\n+    query = instance.query\n+    query(\"\"\"\n+    CREATE DICTIONARY test_dictionary_custom_query\n+    (\n+        id UInt64,\n+        id_key String,\n+        value_1 String,\n+        value_2 String\n+    )\n+    PRIMARY KEY id, id_key\n+    LAYOUT(COMPLEX_KEY_DIRECT())\n+    SOURCE(MYSQL(\n+        HOST 'mysql57'\n+        PORT 3306\n+        USER 'root'\n+        PASSWORD 'clickhouse'\n+        QUERY $doc$SELECT id, id_key, value_1, value_2 FROM test.test_table_1 INNER JOIN test.test_table_2 USING (id, id_key) WHERE {condition};$doc$))\n+    \"\"\")\n+\n+    result = query(\"SELECT dictGet('test_dictionary_custom_query', ('value_1', 'value_2'), (toUInt64(1), 'Key'))\")\n+\n+    assert result == \"('Value_1','Value_2')\\n\"\n+\n+    query(\"DROP DICTIONARY test_dictionary_custom_query;\")\n+\n+    execute_mysql_query(mysql_connection, \"DROP TABLE test.test_table_1;\")\n+    execute_mysql_query(mysql_connection, \"DROP TABLE test.test_table_2;\")\n \n \n def create_mysql_db(mysql_connection, name):\n@@ -102,9 +194,17 @@ def get_mysql_conn(started_cluster):\n         except Exception as e:\n             errors += [str(e)]\n             time.sleep(1)\n-    \n+\n     raise Exception(\"Connection not establised, {}\".format(errors))\n \n+def execute_mysql_query(connection, query):\n+    logging.debug(\"Execute MySQL query:{}\".format(query))\n+    with warnings.catch_warnings():\n+        warnings.simplefilter(\"ignore\")\n+        with connection.cursor() as cursor:\n+            cursor.execute(query)\n+        connection.commit()\n+\n def create_mysql_table(conn, table_name):\n     with conn.cursor() as cursor:\n         cursor.execute(create_table_mysql_template.format(table_name))\ndiff --git a/tests/integration/test_dictionaries_postgresql/test.py b/tests/integration/test_dictionaries_postgresql/test.py\nindex d35182e15a17..6eb4a04ed2c8 100644\n--- a/tests/integration/test_dictionaries_postgresql/test.py\n+++ b/tests/integration/test_dictionaries_postgresql/test.py\n@@ -90,6 +90,121 @@ def test_load_dictionaries(started_cluster):\n     node1.query(\"DROP DICTIONARY IF EXISTS {}\".format(dict_name))\n \n \n+def test_postgres_dictionaries_custom_query_full_load(started_cluster):\n+    conn = get_postgres_conn(ip=started_cluster.postgres_ip, database=True, port=started_cluster.postgres_port)\n+    cursor = conn.cursor()\n+\n+    cursor.execute(\"CREATE TABLE IF NOT EXISTS test_table_1 (id Integer, value_1 Text);\")\n+    cursor.execute(\"CREATE TABLE IF NOT EXISTS test_table_2 (id Integer, value_2 Text);\")\n+    cursor.execute(\"INSERT INTO test_table_1 VALUES (1, 'Value_1');\")\n+    cursor.execute(\"INSERT INTO test_table_2 VALUES (1, 'Value_2');\")\n+\n+    query = node1.query\n+    query(\"\"\"\n+    CREATE DICTIONARY test_dictionary_custom_query\n+    (\n+        id UInt64,\n+        value_1 String,\n+        value_2 String\n+    )\n+    PRIMARY KEY id\n+    LAYOUT(FLAT())\n+    SOURCE(PostgreSQL(\n+        DB 'clickhouse'\n+        HOST '{}'\n+        PORT {}\n+        USER 'postgres'\n+        PASSWORD 'mysecretpassword'\n+        QUERY $doc$SELECT id, value_1, value_2 FROM test_table_1 INNER JOIN test_table_2 USING (id);$doc$))\n+    LIFETIME(0)\n+    \"\"\".format(started_cluster.postgres_ip, started_cluster.postgres_port))\n+\n+    result = query(\"SELECT id, value_1, value_2 FROM test_dictionary_custom_query\")\n+\n+    assert result == '1\\tValue_1\\tValue_2\\n'\n+\n+    query(\"DROP DICTIONARY test_dictionary_custom_query;\")\n+\n+    cursor.execute(\"DROP TABLE test_table_2;\")\n+    cursor.execute(\"DROP TABLE test_table_1;\")\n+\n+\n+def test_postgres_dictionaries_custom_query_partial_load_simple_key(started_cluster):\n+    conn = get_postgres_conn(ip=started_cluster.postgres_ip, database=True, port=started_cluster.postgres_port)\n+    cursor = conn.cursor()\n+\n+    cursor.execute(\"CREATE TABLE IF NOT EXISTS test_table_1 (id Integer, value_1 Text);\")\n+    cursor.execute(\"CREATE TABLE IF NOT EXISTS test_table_2 (id Integer, value_2 Text);\")\n+    cursor.execute(\"INSERT INTO test_table_1 VALUES (1, 'Value_1');\")\n+    cursor.execute(\"INSERT INTO test_table_2 VALUES (1, 'Value_2');\")\n+\n+    query = node1.query\n+    query(\"\"\"\n+    CREATE DICTIONARY test_dictionary_custom_query\n+    (\n+        id UInt64,\n+        value_1 String,\n+        value_2 String\n+    )\n+    PRIMARY KEY id\n+    LAYOUT(DIRECT())\n+    SOURCE(PostgreSQL(\n+        DB 'clickhouse'\n+        HOST '{}'\n+        PORT {}\n+        USER 'postgres'\n+        PASSWORD 'mysecretpassword'\n+        QUERY $doc$SELECT id, value_1, value_2 FROM test_table_1 INNER JOIN test_table_2 USING (id) WHERE {{condition}};$doc$))\n+    \"\"\".format(started_cluster.postgres_ip, started_cluster.postgres_port))\n+\n+    result = query(\"SELECT dictGet('test_dictionary_custom_query', ('value_1', 'value_2'), toUInt64(1))\")\n+\n+    assert result == '(\\'Value_1\\',\\'Value_2\\')\\n'\n+\n+    query(\"DROP DICTIONARY test_dictionary_custom_query;\")\n+\n+    cursor.execute(\"DROP TABLE test_table_2;\")\n+    cursor.execute(\"DROP TABLE test_table_1;\")\n+\n+\n+def test_postgres_dictionaries_custom_query_partial_load_complex_key(started_cluster):\n+    conn = get_postgres_conn(ip=started_cluster.postgres_ip, database=True, port=started_cluster.postgres_port)\n+    cursor = conn.cursor()\n+\n+    cursor.execute(\"CREATE TABLE IF NOT EXISTS test_table_1 (id Integer, key Text, value_1 Text);\")\n+    cursor.execute(\"CREATE TABLE IF NOT EXISTS test_table_2 (id Integer, key Text, value_2 Text);\")\n+    cursor.execute(\"INSERT INTO test_table_1 VALUES (1, 'Key', 'Value_1');\")\n+    cursor.execute(\"INSERT INTO test_table_2 VALUES (1, 'Key', 'Value_2');\")\n+\n+    query = node1.query\n+    query(\"\"\"\n+    CREATE DICTIONARY test_dictionary_custom_query\n+    (\n+        id UInt64,\n+        key String,\n+        value_1 String,\n+        value_2 String\n+    )\n+    PRIMARY KEY id, key\n+    LAYOUT(COMPLEX_KEY_DIRECT())\n+    SOURCE(PostgreSQL(\n+        DB 'clickhouse'\n+        HOST '{}'\n+        PORT {}\n+        USER 'postgres'\n+        PASSWORD 'mysecretpassword'\n+        QUERY $doc$SELECT id, key, value_1, value_2 FROM test_table_1 INNER JOIN test_table_2 USING (id, key) WHERE {{condition}};$doc$))\n+    \"\"\".format(started_cluster.postgres_ip, started_cluster.postgres_port))\n+\n+    result = query(\"SELECT dictGet('test_dictionary_custom_query', ('value_1', 'value_2'), (toUInt64(1), 'Key'))\")\n+\n+    assert result == '(\\'Value_1\\',\\'Value_2\\')\\n'\n+\n+    query(\"DROP DICTIONARY test_dictionary_custom_query;\")\n+\n+    cursor.execute(\"DROP TABLE test_table_2;\")\n+    cursor.execute(\"DROP TABLE test_table_1;\")\n+\n def test_invalidate_query(started_cluster):\n     conn = get_postgres_conn(ip=started_cluster.postgres_ip, database=True, port=started_cluster.postgres_port)\n     cursor = conn.cursor()\n@@ -158,7 +273,7 @@ def test_dictionary_with_replicas(started_cluster):\n     node1.query(\"DROP DICTIONARY IF EXISTS dict1\")\n \n \n-def test_postgres_scema(started_cluster):\n+def test_postgres_schema(started_cluster):\n     conn = get_postgres_conn(ip=started_cluster.postgres_ip, port=started_cluster.postgres_port, database=True)\n     cursor = conn.cursor()\n \n",
  "problem_statement": "Feature request: custom sql-query for MySQL dictionaries\nI need to make a join to extract needed data from mysql. \r\n\r\n> Example: let's say i have a table **Persons** (personid, name, departmentid), and  **Departments** (departmentid, department_name). And I need a dictionaty to map personid to department_name. \r\n\r\n\r\nCurrently it's not possible to provide custom query to extract data, only one table is supported in &lt;mysql&gt; type of dictionary source. \r\n\r\nThere is a workaround for that, described in that answer https://stackoverflow.com/questions/45594378/clickhouse-dictionaries-with-complex-mysql-queries-for-data-source\r\n\r\nBut it would be nice if clickhouse will support that out-of-the-box.  \n",
  "hints_text": "@filimonov we solved this by using views for the dictionaries to query\r\nWould that work for you?\nViews - are acceptable, but custom query still seems to be better solution. \r\n\r\nWhen using views:\r\n* it breaks single responsibility principle: you need to configure same stuff in 2 places - in view definition, and in dict config file\r\n* more bureaucracy: you need to change DB schema - which can be under version control, and can require rights for creating views, etc.\r\n* creates mess: for big DB with hundreds of tables I prefer to avoid creating extra entities if it's possible.  \r\n",
  "created_at": "2021-07-29T21:43:36Z"
}