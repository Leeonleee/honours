{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 31707,
  "instance_id": "ClickHouse__ClickHouse-31707",
  "issue_numbers": [
    "31662",
    "31426"
  ],
  "base_commit": "80dbe8aaa426fd826a46fa6fbca0d79af94669f8",
  "patch": "diff --git a/src/Functions/FunctionsAES.h b/src/Functions/FunctionsAES.h\nindex 58a7947a1357..d3796081f185 100644\n--- a/src/Functions/FunctionsAES.h\n+++ b/src/Functions/FunctionsAES.h\n@@ -279,37 +279,33 @@ class FunctionEncrypt : public IFunction\n             // That may lead later to reading unallocated data from underlying PaddedPODArray\n             // due to assumption that it is safe to read up to 15 bytes past end.\n             const auto pad_to_next_block = block_size == 1 ? 0 : 1;\n-            for (size_t r = 0; r < input_rows_count; ++r)\n+            for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n             {\n-                resulting_size += (input_column->getDataAt(r).size / block_size + pad_to_next_block) * block_size + 1;\n+                resulting_size += (input_column->getDataAt(row_idx).size / block_size + pad_to_next_block) * block_size + 1;\n                 if constexpr (mode == CipherMode::RFC5116_AEAD_AES_GCM)\n                     resulting_size += tag_size;\n             }\n-#if defined(MEMORY_SANITIZER)\n-            encrypted_result_column_data.resize_fill(resulting_size, 0xFF);\n-#else\n             encrypted_result_column_data.resize(resulting_size);\n-#endif\n         }\n \n         auto * encrypted = encrypted_result_column_data.data();\n \n         KeyHolder<mode> key_holder;\n \n-        for (size_t r = 0; r < input_rows_count; ++r)\n+        for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n-            const auto key_value = key_holder.setKey(key_size, key_column->getDataAt(r));\n+            const auto key_value = key_holder.setKey(key_size, key_column->getDataAt(row_idx));\n             auto iv_value = StringRef{};\n             if (iv_column)\n             {\n-                iv_value = iv_column->getDataAt(r);\n+                iv_value = iv_column->getDataAt(row_idx);\n \n                 /// If the length is zero (empty string is passed) it should be treat as no IV.\n                 if (iv_value.size == 0)\n                     iv_value.data = nullptr;\n             }\n \n-            const StringRef input_value = input_column->getDataAt(r);\n+            const StringRef input_value = input_column->getDataAt(row_idx);\n \n             if constexpr (mode != CipherMode::MySQLCompatibility)\n             {\n@@ -348,7 +344,7 @@ class FunctionEncrypt : public IFunction\n                     // 1.a.2 Set AAD\n                     if (aad_column)\n                     {\n-                        const auto aad_data = aad_column->getDataAt(r);\n+                        const auto aad_data = aad_column->getDataAt(row_idx);\n                         int tmp_len = 0;\n                         if (aad_data.size != 0 && EVP_EncryptUpdate(evp_ctx, nullptr, &tmp_len,\n                                 reinterpret_cast<const unsigned char *>(aad_data.data), aad_data.size) != 1)\n@@ -408,7 +404,7 @@ class FunctionEncrypt : public IFunction\n };\n \n \n-/// AES_decrypt(string, key, block_mode[, init_vector])\n+/// decrypt(string, key, block_mode[, init_vector])\n template <typename Impl>\n class FunctionDecrypt : public IFunction\n {\n@@ -471,7 +467,9 @@ class FunctionDecrypt : public IFunction\n \n         ColumnPtr result_column;\n         if (arguments.size() <= 3)\n+        {\n             result_column = doDecrypt(evp_cipher, input_rows_count, input_column, key_column, nullptr, nullptr);\n+        }\n         else\n         {\n             const auto iv_column = arguments[3].column;\n@@ -548,59 +546,58 @@ class FunctionDecrypt : public IFunction\n \n         {\n             size_t resulting_size = 0;\n-            for (size_t r = 0; r < input_rows_count; ++r)\n+            for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n             {\n-                size_t string_size = input_column->getDataAt(r).size;\n+                size_t string_size = input_column->getDataAt(row_idx).size;\n                 resulting_size += string_size + 1;  /// With terminating zero.\n \n                 if constexpr (mode == CipherMode::RFC5116_AEAD_AES_GCM)\n                 {\n-                    if (string_size < tag_size)\n-                        throw Exception(\"Encrypted data is smaller than the size of additional data for AEAD mode, cannot decrypt.\",\n-                            ErrorCodes::BAD_ARGUMENTS);\n+                    if (string_size > 0)\n+                    {\n+                        if (string_size < tag_size)\n+                            throw Exception(\"Encrypted data is smaller than the size of additional data for AEAD mode, cannot decrypt.\",\n+                                ErrorCodes::BAD_ARGUMENTS);\n \n-                    resulting_size -= tag_size;\n+                        resulting_size -= tag_size;\n+                    }\n                 }\n             }\n \n-#if defined(MEMORY_SANITIZER)\n-            // Pre-fill result column with values to prevent MSAN from dropping dead on\n-            // aes-X-ecb mode with \"WARNING: MemorySanitizer: use-of-uninitialized-value\".\n-            // This is most likely to be caused by the underlying assembler implementation:\n-            // see crypto/aes/aesni-x86_64.s, function aesni_ecb_encrypt\n-            // which msan seems to fail instrument correctly.\n-            decrypted_result_column_data.resize_fill(resulting_size, 0xFF);\n-#else\n             decrypted_result_column_data.resize(resulting_size);\n-#endif\n         }\n \n         auto * decrypted = decrypted_result_column_data.data();\n \n         KeyHolder<mode> key_holder;\n-        for (size_t r = 0; r < input_rows_count; ++r)\n+        for (size_t row_idx = 0; row_idx < input_rows_count; ++row_idx)\n         {\n             // 0: prepare key if required\n-            auto key_value = key_holder.setKey(key_size, key_column->getDataAt(r));\n+            auto key_value = key_holder.setKey(key_size, key_column->getDataAt(row_idx));\n             auto iv_value = StringRef{};\n             if (iv_column)\n             {\n-                iv_value = iv_column->getDataAt(r);\n+                iv_value = iv_column->getDataAt(row_idx);\n \n                 /// If the length is zero (empty string is passed) it should be treat as no IV.\n                 if (iv_value.size == 0)\n                     iv_value.data = nullptr;\n             }\n \n-            auto input_value = input_column->getDataAt(r);\n+            auto input_value = input_column->getDataAt(row_idx);\n+\n             if constexpr (mode == CipherMode::RFC5116_AEAD_AES_GCM)\n             {\n-                // empty plaintext results in empty ciphertext + tag, means there should be at least tag_size bytes.\n-                if (input_value.size < tag_size)\n-                    throw Exception(fmt::format(\"Encrypted data is too short: only {} bytes, \"\n-                            \"should contain at least {} bytes of a tag.\",\n-                            input_value.size, block_size, tag_size), ErrorCodes::BAD_ARGUMENTS);\n-                input_value.size -= tag_size;\n+                if (input_value.size > 0)\n+                {\n+                    // empty plaintext results in empty ciphertext + tag, means there should be at least tag_size bytes.\n+                    if (input_value.size < tag_size)\n+                        throw Exception(fmt::format(\"Encrypted data is too short: only {} bytes, \"\n+                                \"should contain at least {} bytes of a tag.\",\n+                                input_value.size, block_size, tag_size), ErrorCodes::BAD_ARGUMENTS);\n+\n+                    input_value.size -= tag_size;\n+                }\n             }\n \n             if constexpr (mode != CipherMode::MySQLCompatibility)\n@@ -619,8 +616,9 @@ class FunctionDecrypt : public IFunction\n                 }\n             }\n \n-            // Avoid extra work on empty ciphertext/plaintext for some ciphers\n-            if (!(input_value.size == 0 && block_size == 1 && mode != CipherMode::RFC5116_AEAD_AES_GCM))\n+            /// Avoid extra work on empty ciphertext/plaintext. Always decrypt empty to empty.\n+            /// This makes sense for default implementation for NULLs.\n+            if (input_value.size > 0)\n             {\n                 // 1: Init CTX\n                 if constexpr (mode == CipherMode::RFC5116_AEAD_AES_GCM)\n@@ -641,7 +639,7 @@ class FunctionDecrypt : public IFunction\n                     // 1.a.2: Set AAD if present\n                     if (aad_column)\n                     {\n-                        StringRef aad_data = aad_column->getDataAt(r);\n+                        StringRef aad_data = aad_column->getDataAt(row_idx);\n                         int tmp_len = 0;\n                         if (aad_data.size != 0 && EVP_DecryptUpdate(evp_ctx, nullptr, &tmp_len,\n                                 reinterpret_cast<const unsigned char *>(aad_data.data), aad_data.size) != 1)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.reference b/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.reference\nnew file mode 100644\nindex 000000000000..5a3daa6efb88\n--- /dev/null\n+++ b/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.reference\n@@ -0,0 +1,16 @@\n+aes_encrypt_mysql\n+\\N\n+D1B43643E1D0E9390E39BA4EAE150851\n+aes_decrypt_mysql\n+\\N\n+48656C6C6F20576F726C6421\n+encrypt\n+aes-256-ecb\t\\N\n+aes-256-gcm\t\\N\n+aes-256-ecb\tD1B43643E1D0E9390E39BA4EAE150851\n+aes-256-gcm\t219E6478A1A3BB5B686DA4BAD70323F192EFEDCCBBD6F49E78A7E2F6\n+decrypt\n+aes-256-ecb\t\\N\n+aes-256-gcm\t\\N\n+aes-256-ecb\tHello World!\n+aes-256-gcm\tHello World!\ndiff --git a/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.sql b/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.sql\nnew file mode 100644\nindex 000000000000..a029b4afaafc\n--- /dev/null\n+++ b/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.sql\n@@ -0,0 +1,57 @@\n+-- Tags: no-fasttest\n+-- Tag no-fasttest: Depends on OpenSSL\n+\n+-------------------------------------------------------------------------------\n+-- Validate that encrypt/decrypt (and mysql versions) work against Nullable(String).\n+-- null gets encrypted/decrypted as null, non-null encrypted/decrypted as usual.\n+-------------------------------------------------------------------------------\n+-- using nullIf since that is the easiest way to produce `Nullable(String)` with a `null` value\n+\n+-----------------------------------------------------------------------------------------------------------------------------------\n+-- MySQL compatibility\n+SELECT 'aes_encrypt_mysql';\n+\n+SELECT aes_encrypt_mysql('aes-256-ecb', CAST(null as Nullable(String)), 'test_key________________________');\n+\n+WITH 'aes-256-ecb' as mode, 'Hello World!' as plaintext, 'test_key________________________' as key\n+SELECT hex(aes_encrypt_mysql(mode, toNullable(plaintext), key));\n+\n+SELECT 'aes_decrypt_mysql';\n+\n+SELECT aes_decrypt_mysql('aes-256-ecb', CAST(null as Nullable(String)), 'test_key________________________');\n+\n+WITH 'aes-256-ecb' as mode, unhex('D1B43643E1D0E9390E39BA4EAE150851') as ciphertext, 'test_key________________________' as key\n+SELECT hex(aes_decrypt_mysql(mode, toNullable(ciphertext), key));\n+\n+-----------------------------------------------------------------------------------------------------------------------------------\n+-- encrypt both non-null and null values of Nullable(String)\n+SELECT 'encrypt';\n+\n+WITH 'aes-256-ecb' as mode, 'test_key________________________' as key\n+SELECT mode, encrypt(mode, CAST(null as Nullable(String)), key);\n+\n+WITH 'aes-256-gcm' as mode, 'test_key________________________' as key, 'test_iv_____' as iv\n+SELECT mode, encrypt(mode, CAST(null as Nullable(String)), key, iv);\n+\n+WITH 'aes-256-ecb' as mode, 'test_key________________________' as key\n+SELECT mode, hex(encrypt(mode, toNullable('Hello World!'), key));\n+\n+WITH 'aes-256-gcm' as mode, 'test_key________________________' as key, 'test_iv_____' as iv\n+SELECT mode, hex(encrypt(mode, toNullable('Hello World!'), key, iv));\n+\n+-----------------------------------------------------------------------------------------------------------------------------------\n+-- decrypt both non-null and null values of Nullable(String)\n+\n+SELECT 'decrypt';\n+\n+WITH 'aes-256-ecb' as mode, 'test_key________________________' as key\n+SELECT mode, decrypt(mode, CAST(null as Nullable(String)), key);\n+\n+WITH 'aes-256-gcm' as mode, 'test_key________________________' as key, 'test_iv_____' as iv\n+SELECT mode, decrypt(mode, CAST(null as Nullable(String)), key, iv);\n+\n+WITH 'aes-256-ecb' as mode, unhex('D1B43643E1D0E9390E39BA4EAE150851') as ciphertext, 'test_key________________________' as key\n+SELECT mode, decrypt(mode, toNullable(ciphertext), key);\n+\n+WITH 'aes-256-gcm' as mode, unhex('219E6478A1A3BB5B686DA4BAD70323F192EFEDCCBBD6F49E78A7E2F6') as ciphertext, 'test_key________________________' as key, 'test_iv_____' as iv\n+SELECT mode, decrypt(mode, toNullable(ciphertext), key, iv);\n",
  "problem_statement": "Fix decrypt nullable\nChangelog category (leave one):\r\n- Bug Fix (user-visible misbehaviour in official stable or prestable release)\r\n\r\nChangelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nFixed error on decrypting `null`-value with either `decrypt` or `aes_decrypt_mysql` funtions.\r\n...\r\n\r\n\r\nDetailed description / Documentation draft:\r\n...\r\nCloses: #31426\nException while using aes_encrypt_mysql function\nClickHouse v.21.8.10.19\r\n\r\nGot ex\u0441eption when aes_encrypt_mysql got unexpected result as input\r\n\r\ntest case:\r\n````\r\ncreate table test_table\r\n(\r\n    value           Nullable(String),\r\n    encrypted_value Nullable(String)\r\n)\r\n    engine MergeTree order by assumeNotNull(value);\r\n\r\ninsert into test_table\r\nselect 'test_value1', aes_encrypt_mysql('aes-256-ecb', 'test_value1', 'test_key________________________');\r\ninsert into test_table\r\nselect '', aes_encrypt_mysql('aes-256-ecb', '', 'test_key________________________');\r\ninsert into test_table\r\nselect null, aes_encrypt_mysql('aes-256-ecb', null, 'test_key________________________');\r\n\r\nselect aes_decrypt_mysql('aes-256-ecb', value, 'test_key________________________')\r\nfrom test_table\r\n````\r\n\r\ngot `Failed to decrypt. OpenSSL error code: 503316603: while executing 'FUNCTION aes_decrypt_mysql` as exception\n",
  "hints_text": "Fuzzers have found multiple errors.\nDecrypting `null` should result in `null`, but decrypting an empty string would cause an error for most ciphers.",
  "created_at": "2021-11-24T13:50:04Z",
  "modified_files": [
    "src/Functions/FunctionsAES.h"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.reference",
    "b/tests/queries/0_stateless/02124_encrypt_decrypt_nullable.sql"
  ]
}