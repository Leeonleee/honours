{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 67536,
  "instance_id": "ClickHouse__ClickHouse-67536",
  "issue_numbers": [
    "67330"
  ],
  "base_commit": "89551e0043f1fbdefee2fc5fa69cabfcec58d6ca",
  "patch": "diff --git a/src/Analyzer/InterpolateNode.cpp b/src/Analyzer/InterpolateNode.cpp\nindex 97dc79f565bd..17c734cf3868 100644\n--- a/src/Analyzer/InterpolateNode.cpp\n+++ b/src/Analyzer/InterpolateNode.cpp\n@@ -24,7 +24,7 @@ void InterpolateNode::dumpTreeImpl(WriteBuffer & buffer, FormatState & format_st\n {\n     buffer << std::string(indent, ' ') << \"INTERPOLATE id: \" << format_state.getNodeId(this);\n \n-    buffer << '\\n' << std::string(indent + 2, ' ') << \"EXPRESSION\\n\";\n+    buffer << '\\n' << std::string(indent + 2, ' ') << \"EXPRESSION \" << expression_name << \" \\n\";\n     getExpression()->dumpTreeImpl(buffer, format_state, indent + 4);\n \n     buffer << '\\n' << std::string(indent + 2, ' ') << \"INTERPOLATE_EXPRESSION\\n\";\ndiff --git a/src/Analyzer/InterpolateNode.h b/src/Analyzer/InterpolateNode.h\nindex ec493ed8bdde..eb3d64d7170c 100644\n--- a/src/Analyzer/InterpolateNode.h\n+++ b/src/Analyzer/InterpolateNode.h\n@@ -50,6 +50,8 @@ class InterpolateNode final : public IQueryTreeNode\n         return QueryTreeNodeType::INTERPOLATE;\n     }\n \n+    const std::string & getExpressionName() const { return expression_name; }\n+\n     void dumpTreeImpl(WriteBuffer & buffer, FormatState & format_state, size_t indent) const override;\n \n protected:\ndiff --git a/src/Analyzer/Resolve/QueryAnalyzer.cpp b/src/Analyzer/Resolve/QueryAnalyzer.cpp\nindex 767d5c11075e..e973bd8fb346 100644\n--- a/src/Analyzer/Resolve/QueryAnalyzer.cpp\n+++ b/src/Analyzer/Resolve/QueryAnalyzer.cpp\n@@ -64,6 +64,8 @@\n #include <Analyzer/Resolve/TableExpressionsAliasVisitor.h>\n #include <Analyzer/Resolve/ReplaceColumnsVisitor.h>\n \n+#include <Planner/PlannerActionsVisitor.h>\n+\n #include <Core/Settings.h>\n \n namespace ProfileEvents\n@@ -4122,11 +4124,7 @@ void QueryAnalyzer::resolveInterpolateColumnsNodeList(QueryTreeNodePtr & interpo\n     {\n         auto & interpolate_node_typed = interpolate_node->as<InterpolateNode &>();\n \n-        auto * column_to_interpolate = interpolate_node_typed.getExpression()->as<IdentifierNode>();\n-        if (!column_to_interpolate)\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"INTERPOLATE can work only for indentifiers, but {} is found\",\n-                interpolate_node_typed.getExpression()->formatASTForErrorMessage());\n-        auto column_to_interpolate_name = column_to_interpolate->getIdentifier().getFullName();\n+        auto column_to_interpolate_name = interpolate_node_typed.getExpressionName();\n \n         resolveExpressionNode(interpolate_node_typed.getExpression(), scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n \n@@ -4135,14 +4133,11 @@ void QueryAnalyzer::resolveInterpolateColumnsNodeList(QueryTreeNodePtr & interpo\n         auto & interpolation_to_resolve = interpolate_node_typed.getInterpolateExpression();\n         IdentifierResolveScope interpolate_scope(interpolation_to_resolve, &scope /*parent_scope*/);\n \n-        auto fake_column_node = std::make_shared<ColumnNode>(NameAndTypePair(column_to_interpolate_name, interpolate_node_typed.getExpression()->getResultType()), interpolate_node_typed.getExpression());\n+        auto fake_column_node = std::make_shared<ColumnNode>(NameAndTypePair(column_to_interpolate_name, interpolate_node_typed.getExpression()->getResultType()), interpolate_node);\n         if (is_column_constant)\n             interpolate_scope.expression_argument_name_to_node.emplace(column_to_interpolate_name, fake_column_node);\n \n         resolveExpressionNode(interpolation_to_resolve, interpolate_scope, false /*allow_lambda_expression*/, false /*allow_table_expression*/);\n-\n-        if (is_column_constant)\n-            interpolation_to_resolve = interpolation_to_resolve->cloneAndReplace(fake_column_node, interpolate_node_typed.getExpression());\n     }\n }\n \ndiff --git a/src/Planner/CollectTableExpressionData.cpp b/src/Planner/CollectTableExpressionData.cpp\nindex 2fe62aa9be07..c48813a4ed46 100644\n--- a/src/Planner/CollectTableExpressionData.cpp\n+++ b/src/Planner/CollectTableExpressionData.cpp\n@@ -46,7 +46,7 @@ class CollectSourceColumnsVisitor : public InDepthQueryTreeVisitor<CollectSource\n         auto column_source_node = column_node->getColumnSource();\n         auto column_source_node_type = column_source_node->getNodeType();\n \n-        if (column_source_node_type == QueryTreeNodeType::LAMBDA)\n+        if (column_source_node_type == QueryTreeNodeType::LAMBDA || column_source_node_type == QueryTreeNodeType::INTERPOLATE)\n             return;\n \n         /// JOIN using expression\ndiff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp\nindex 968642dc9de4..b837d9428a1e 100644\n--- a/src/Planner/Planner.cpp\n+++ b/src/Planner/Planner.cpp\n@@ -744,6 +744,8 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n         }\n         else\n         {\n+            ActionsDAG rename_dag;\n+\n             for (auto & interpolate_node : interpolate_list_nodes)\n             {\n                 auto & interpolate_node_typed = interpolate_node->as<InterpolateNode &>();\n@@ -772,8 +774,28 @@ void addWithFillStepIfNeeded(QueryPlan & query_plan,\n \n                 const auto * alias_node = &interpolate_actions_dag.addAlias(*interpolate_expression, expression_to_interpolate_name);\n                 interpolate_actions_dag.getOutputs().push_back(alias_node);\n+\n+                /// Here we fix INTERPOLATE by constant expression.\n+                /// Example from 02336_sort_optimization_with_fill:\n+                ///\n+                /// SELECT 5 AS x, 'Hello' AS s ORDER BY x WITH FILL FROM 1 TO 10 INTERPOLATE (s AS s||'A')\n+                ///\n+                /// For this query, INTERPOLATE_EXPRESSION would be : s AS concat(s, 'A'),\n+                /// so that interpolate_actions_dag would have INPUT `s`.\n+                ///\n+                /// However, INPUT `s` does not exist. Instead, we have a constant with execution name 'Hello'_String.\n+                /// To fix this, we prepend a rename : 'Hello'_String -> s\n+                if (const auto * constant_node = interpolate_node_typed.getExpression()->as<const ConstantNode>())\n+                {\n+                    const auto * node = &rename_dag.addInput(alias_node->result_name, alias_node->result_type);\n+                    node = &rename_dag.addAlias(*node, interpolate_node_typed.getExpressionName());\n+                    rename_dag.getOutputs().push_back(node);\n+                }\n             }\n \n+            if (!rename_dag.getOutputs().empty())\n+                interpolate_actions_dag = ActionsDAG::merge(std::move(rename_dag), std::move(interpolate_actions_dag));\n+\n             interpolate_actions_dag.removeUnusedActions();\n         }\n \ndiff --git a/src/Planner/PlannerActionsVisitor.cpp b/src/Planner/PlannerActionsVisitor.cpp\nindex 1960855792c1..574574938441 100644\n--- a/src/Planner/PlannerActionsVisitor.cpp\n+++ b/src/Planner/PlannerActionsVisitor.cpp\n@@ -491,7 +491,16 @@ class ActionsScopeNode\n     {\n         auto it = node_name_to_node.find(node_name);\n         if (it != node_name_to_node.end())\n-            return it->second;\n+        {\n+            /// It is possible that ActionsDAG already has an input with the same name as constant.\n+            /// In this case, prefer constant to input.\n+            /// Constatns affect function return type, which should be consistent with QueryTree.\n+            /// Query example:\n+            /// SELECT materialize(toLowCardinality('b')) || 'a' FROM remote('127.0.0.{1,2}', system, one) GROUP BY 'a'\n+            bool materialized_input = it->second->type == ActionsDAG::ActionType::INPUT && !it->second->column;\n+            if (!materialized_input)\n+                return it->second;\n+        }\n \n         const auto * node = &actions_dag.addColumn(column);\n         node_name_to_node[node->result_name] = node;\ndiff --git a/src/Planner/PlannerExpressionAnalysis.cpp b/src/Planner/PlannerExpressionAnalysis.cpp\nindex 2b67c96d843b..ed3f78193ee8 100644\n--- a/src/Planner/PlannerExpressionAnalysis.cpp\n+++ b/src/Planner/PlannerExpressionAnalysis.cpp\n@@ -462,6 +462,9 @@ SortAnalysisResult analyzeSort(const QueryNode & query_node,\n         for (auto & interpolate_node : interpolate_list_node.getNodes())\n         {\n             auto & interpolate_node_typed = interpolate_node->as<InterpolateNode &>();\n+            if (interpolate_node_typed.getExpression()->getNodeType() == QueryTreeNodeType::CONSTANT)\n+               continue;\n+\n             interpolate_actions_visitor.visit(interpolate_actions_dag, interpolate_node_typed.getInterpolateExpression());\n         }\n \ndiff --git a/src/Processors/QueryPlan/FillingStep.cpp b/src/Processors/QueryPlan/FillingStep.cpp\nindex 81622389adad..8687886447a2 100644\n--- a/src/Processors/QueryPlan/FillingStep.cpp\n+++ b/src/Processors/QueryPlan/FillingStep.cpp\n@@ -2,6 +2,7 @@\n #include <Processors/Transforms/FillingTransform.h>\n #include <QueryPipeline/QueryPipelineBuilder.h>\n #include <IO/Operators.h>\n+#include <Interpreters/ExpressionActions.h>\n #include <Common/JSONBuilder.h>\n \n namespace DB\n@@ -58,14 +59,25 @@ void FillingStep::transformPipeline(QueryPipelineBuilder & pipeline, const Build\n \n void FillingStep::describeActions(FormatSettings & settings) const\n {\n-    settings.out << String(settings.offset, ' ');\n+    String prefix(settings.offset, settings.indent_char);\n+    settings.out << prefix;\n     dumpSortDescription(sort_description, settings.out);\n     settings.out << '\\n';\n+    if (interpolate_description)\n+    {\n+        auto expression = std::make_shared<ExpressionActions>(interpolate_description->actions.clone());\n+        expression->describeActions(settings.out, prefix);\n+    }\n }\n \n void FillingStep::describeActions(JSONBuilder::JSONMap & map) const\n {\n     map.add(\"Sort Description\", explainSortDescription(sort_description));\n+    if (interpolate_description)\n+    {\n+        auto expression = std::make_shared<ExpressionActions>(interpolate_description->actions.clone());\n+        map.add(\"Expression\", expression->toTree());\n+    }\n }\n \n void FillingStep::updateOutputStream()\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00257_shard_no_aggregates_and_constant_keys.reference b/tests/queries/0_stateless/00257_shard_no_aggregates_and_constant_keys.reference\nindex 63b8a9d14fc6..fc77ed8a2412 100644\n--- a/tests/queries/0_stateless/00257_shard_no_aggregates_and_constant_keys.reference\n+++ b/tests/queries/0_stateless/00257_shard_no_aggregates_and_constant_keys.reference\n@@ -8,13 +8,13 @@\n 40\n 41\n \n-0\n+41\n 2\t42\n \n 2\t42\n 43\n \n-0\n+43\n 11\n \n 11\ndiff --git a/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.reference b/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.reference\nnew file mode 100644\nindex 000000000000..584e34c0cdea\n--- /dev/null\n+++ b/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.reference\n@@ -0,0 +1,3 @@\n+ba\n+\\N\n+1\t111111111111111111111111111111111111111\ndiff --git a/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.sql b/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.sql\nnew file mode 100644\nindex 000000000000..b2fd69d75d0b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.sql\n@@ -0,0 +1,26 @@\n+SET allow_experimental_analyzer = 1;\n+\n+SELECT concat(materialize(toLowCardinality('b')), 'a') FROM remote('127.0.0.{1,2}', system, one) GROUP BY 'a';\n+\n+SELECT concat(NULLIF(1, materialize(toLowCardinality(1))), concat(NULLIF(1, 1))) FROM remote('127.0.0.{1,2}', system, one) GROUP BY concat(NULLIF(1, 1));\n+\n+DROP TABLE IF EXISTS test__fuzz_21;\n+CREATE TABLE test__fuzz_21\n+(\n+    `x` Decimal(18, 10)\n+)\n+ENGINE = MergeTree\n+ORDER BY x;\n+\n+INSERT INTO test__fuzz_21 VALUES (1), (2), (3);\n+\n+WITH (\n+        SELECT CAST(toFixedString(toFixedString(materialize(toFixedString('111111111111111111111111111111111111111', 39)), 39), 39), 'UInt128')\n+    ) AS v\n+SELECT\n+    coalesce(materialize(toLowCardinality(toNullable(1))), 10, NULL),\n+    max(v)\n+FROM remote('127.0.0.{1,2}', currentDatabase(), test__fuzz_21)\n+GROUP BY\n+    coalesce(NULL),\n+    coalesce(1, 10, 10, materialize(NULL));\n",
  "problem_statement": "Logical error: wrong column size in CAST\n`Logical error: \\'Expected the argument \u21162 (\\'_CAST(NULL_Nullable(String), \\'Nullable(String)\\'_String)\\' of type Nullable(String)) to have 2 rows, but it has 0\\'`\r\n\r\nhttps://s3.amazonaws.com/clickhouse-test-reports/66837/aec346676127abba85886a828e663ebf05cfa81e/stress_test__tsan_.html\n",
  "hints_text": "Another one https://s3.amazonaws.com/clickhouse-test-reports/67295/82506dfdad482b790fcbc3a2d4d4895c567a51e4/stress_test__msan_.html\nRepro (please don't just post links to stress tests logs):\r\n\r\n```sql\r\nCREATE TABLE test__fuzz_21\r\n(\r\n    `x` Decimal(18, 10)\r\n)\r\nENGINE = MergeTree\r\nORDER BY x;\r\n\r\nINSERT INTO test__fuzz_21 VALUES (1), (2), (3);\r\n\r\nWITH (\r\n        SELECT CAST(toFixedString(toFixedString(materialize(toFixedString('111111111111111111111111111111111111111', 39)), 39), 39), 'UInt128')\r\n    ) AS v\r\nSELECT\r\n    coalesce(materialize(toLowCardinality(toNullable(1))), 10, NULL),\r\n    max(v)\r\nFROM remote('127.0.0.{1,2}', default, test__fuzz_21)\r\nGROUP BY\r\n    coalesce(NULL),\r\n    coalesce(1, 10, 10, materialize(NULL));\r\n```\n```\r\nSELECT concat(NULLIF(1, materialize(toLowCardinality(1))), concat(NULLIF(1, 1))) FROM remote('127.0.0.{1,2}', system, one) GROUP BY concat(NULLIF(1, 1)) SETTINGS allow_experimental_analyzer = 1\r\n```",
  "created_at": "2024-07-31T14:36:05Z",
  "modified_files": [
    "src/Analyzer/InterpolateNode.cpp",
    "src/Analyzer/InterpolateNode.h",
    "src/Analyzer/Resolve/QueryAnalyzer.cpp",
    "src/Planner/CollectTableExpressionData.cpp",
    "src/Planner/Planner.cpp",
    "src/Planner/PlannerActionsVisitor.cpp",
    "src/Planner/PlannerExpressionAnalysis.cpp",
    "src/Processors/QueryPlan/FillingStep.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00257_shard_no_aggregates_and_constant_keys.reference",
    "b/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.reference",
    "b/tests/queries/0_stateless/03215_analyzer_materialized_constants_bug.sql"
  ]
}