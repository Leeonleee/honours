{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 68455,
  "instance_id": "ClickHouse__ClickHouse-68455",
  "issue_numbers": [
    "67792"
  ],
  "base_commit": "d3c9943147ad312b4df3c3c6bcdaf9d7474be2ca",
  "patch": "diff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex ad6b8e13ea6a..aab88c300b87 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -1667,8 +1667,18 @@ class TrimLayer : public Layer\n                 if (!mergeElement())\n                     return false;\n \n-                to_remove = makeASTFunction(\"regexpQuoteMeta\", elements[0]);\n-                elements.clear();\n+                /// Trimming an empty string is a no-op.\n+                ASTLiteral * ast_literal = typeid_cast<ASTLiteral *>(elements[0].get());\n+                if (ast_literal && ast_literal->value.getType() == Field::Types::String && ast_literal->value.safeGet<String>().empty())\n+                {\n+                    noop = true;\n+                }\n+                else\n+                {\n+                    to_remove = makeASTFunction(\"regexpQuoteMeta\", elements[0]);\n+                    elements.clear();\n+                }\n+\n                 state = 2;\n             }\n         }\n@@ -1680,15 +1690,20 @@ class TrimLayer : public Layer\n                 if (!mergeElement())\n                     return false;\n \n-                ASTPtr pattern_node;\n-\n+                if (noop)\n+                {\n+                    /// The operation does nothing.\n+                }\n                 if (char_override)\n                 {\n+                    ASTPtr pattern_node;\n+\n                     auto pattern_func_node = std::make_shared<ASTFunction>();\n                     auto pattern_list_args = std::make_shared<ASTExpressionList>();\n                     if (trim_left && trim_right)\n                     {\n-                        pattern_list_args->children = {\n+                        pattern_list_args->children =\n+                        {\n                             std::make_shared<ASTLiteral>(\"^[\"),\n                             to_remove,\n                             std::make_shared<ASTLiteral>(\"]+|[\"),\n@@ -1701,7 +1716,8 @@ class TrimLayer : public Layer\n                     {\n                         if (trim_left)\n                         {\n-                            pattern_list_args->children = {\n+                            pattern_list_args->children =\n+                            {\n                                 std::make_shared<ASTLiteral>(\"^[\"),\n                                 to_remove,\n                                 std::make_shared<ASTLiteral>(\"]+\")\n@@ -1710,7 +1726,8 @@ class TrimLayer : public Layer\n                         else\n                         {\n                             /// trim_right == false not possible\n-                            pattern_list_args->children = {\n+                            pattern_list_args->children =\n+                            {\n                                 std::make_shared<ASTLiteral>(\"[\"),\n                                 to_remove,\n                                 std::make_shared<ASTLiteral>(\"]+$\")\n@@ -1724,6 +1741,9 @@ class TrimLayer : public Layer\n                     pattern_func_node->children.push_back(pattern_func_node->arguments);\n \n                     pattern_node = std::move(pattern_func_node);\n+\n+                    elements.push_back(pattern_node);\n+                    elements.push_back(std::make_shared<ASTLiteral>(\"\"));\n                 }\n                 else\n                 {\n@@ -1740,12 +1760,6 @@ class TrimLayer : public Layer\n                     }\n                 }\n \n-                if (char_override)\n-                {\n-                    elements.push_back(pattern_node);\n-                    elements.push_back(std::make_shared<ASTLiteral>(\"\"));\n-                }\n-\n                 finished = true;\n             }\n         }\n@@ -1756,7 +1770,10 @@ class TrimLayer : public Layer\n protected:\n     bool getResultImpl(ASTPtr & node) override\n     {\n-        node = makeASTFunction(function_name, std::move(elements));\n+        if (noop)\n+            node = std::move(elements.at(1));\n+        else\n+            node = makeASTFunction(function_name, std::move(elements));\n         return true;\n     }\n \n@@ -1764,6 +1781,7 @@ class TrimLayer : public Layer\n     bool trim_left;\n     bool trim_right;\n     bool char_override = false;\n+    bool noop = false;\n \n     ASTPtr to_remove;\n     String function_name;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03224_trim_empty_string.reference b/tests/queries/0_stateless/03224_trim_empty_string.reference\nnew file mode 100644\nindex 000000000000..46495a40bbf6\n--- /dev/null\n+++ b/tests/queries/0_stateless/03224_trim_empty_string.reference\n@@ -0,0 +1,6 @@\n+foo\n+foo\n+foo\n+\" foo \"\n+\" foo \"\n+\" foo \"\ndiff --git a/tests/queries/0_stateless/03224_trim_empty_string.sql b/tests/queries/0_stateless/03224_trim_empty_string.sql\nnew file mode 100644\nindex 000000000000..444bd1d7c8b3\n--- /dev/null\n+++ b/tests/queries/0_stateless/03224_trim_empty_string.sql\n@@ -0,0 +1,7 @@\n+SELECT trim(LEADING '' FROM 'foo');\n+SELECT trim(TRAILING '' FROM 'foo');\n+SELECT trim(BOTH '' FROM 'foo');\n+\n+SELECT trim(LEADING '' FROM ' foo ') FORMAT CSV;\n+SELECT trim(TRAILING '' FROM ' foo ') FORMAT CSV;\n+SELECT trim(BOTH '' FROM ' foo ') FORMAT CSV;\n",
  "problem_statement": "TRIM does not support empty string as trim_character\n`TRIM(LEADING '' FROM 'foo')` results in an error.\r\n\r\nWhen using the [SPLIT function](https://help.tableau.com/current/pro/desktop/en-us/functions_functions_string.htm#split), Tableau Cloud generates a query like the following:\r\n```sql\r\nSELECT TRIM(TRIM(LEADING '_' FROM TRIM(LEADING SUBSTRING_INDEX(`TEST_TABLE`.`TEST_COLUMN`, '_', (1 - 1)) FROM SUBSTRING_INDEX(`TEST_TABLE`.`TEST_COLUMN`, '_', 1)))) AS `TEST_COLUMN - \u5206\u5272\u6e08\u307f 1`\r\nFROM `TEST_TABLE`\r\nGROUP BY 1\r\nORDER BY `TEST_COLUMN - \u5206\u5272\u6e08\u307f 1` ASC;\r\n```\r\nHowever, this results in the following error:\r\n```\r\nCode: 36. DB::Exception: The pattern argument is not a valid re2 pattern: missing ]: []+: while executing 'FUNCTION replaceRegexpOne(substringIndex(__table1.TEST_COLUMN, '_'_String, 1_UInt8) :: 0, concat('^['_String, regexpQuoteMeta(substringIndex(__table1.TEST_COLUMN, '_'_String, _CAST(0_Int16, 'Int16'_String))), ']+'_String) :: 2, ''_String : 6) -> replaceRegexpOne(substringIndex(__table1.TEST_COLUMN, '_'_String, 1_UInt8), concat('^['_String, regexpQuoteMeta(substringIndex(__table1.TEST_COLUMN, '_'_String, _CAST(0_Int16, 'Int16'_String))), ']+'_String), ''_String) String : 5'. (BAD_ARGUMENTS)\r\n```\r\n**Expected behavior**\r\nLike MySQL, `TRIM(LEADING '' FROM 'foo')` should not result in an error.\r\n\r\n**Error message and/or stacktrace**\r\nStack Trace:\r\n```\r\n0. DB::Exception::Exception(DB::Exception::MessageMasked&&, int, bool) @ 0x000000000d7a923b\r\n1. DB::Exception::Exception(PreformattedMessage&&, int) @ 0x0000000007b64c0c\r\n2. DB::Exception::Exception<String const&>(int, FormatStringHelperImpl<std::type_identity<String const&>::type>, String const&) @ 0x0000000007b771ab\r\n3. DB::FunctionStringReplace<DB::ReplaceRegexpImpl<DB::(anonymous namespace)::NameReplaceRegexpOne, (DB::ReplaceRegexpTraits::Replace)0>, DB::(anonymous namespace)::NameReplaceRegexpOne>::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x000000000c8ef858\r\n4. DB::FunctionToExecutableFunctionAdaptor::executeImpl(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long) const @ 0x0000000007b7c73a\r\n5. DB::IExecutableFunction::executeWithoutLowCardinalityColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x00000000087d90e7\r\n6. DB::IExecutableFunction::executeWithoutSparseColumns(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x00000000087d99fe\r\n7. DB::IExecutableFunction::execute(std::vector<DB::ColumnWithTypeAndName, std::allocator<DB::ColumnWithTypeAndName>> const&, std::shared_ptr<DB::IDataType const> const&, unsigned long, bool) const @ 0x00000000087dad7d\r\n8. DB::ExpressionActions::execute(DB::Block&, unsigned long&, bool, bool) const @ 0x00000000111fe0d9\r\n9. DB::ExpressionTransform::transform(DB::Chunk&) @ 0x00000000130794f6\r\n10. DB::ISimpleTransform::transform(DB::Chunk&, DB::Chunk&) @ 0x000000000dab4573\r\n11. DB::ISimpleTransform::work() @ 0x0000000012e107b2\r\n12. DB::ExecutionThreadContext::executeTask() @ 0x0000000012e2bea7\r\n13. DB::PipelineExecutor::executeStepImpl(unsigned long, std::atomic<bool>*) @ 0x0000000012e20610\r\n14. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<DB::PipelineExecutor::spawnThreads()::$_0, void ()>>(std::__function::__policy_storage const*) @ 0x0000000012e21cce\r\n15. ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::worker(std::__list_iterator<ThreadFromGlobalPoolImpl<false, true>, void*>) @ 0x000000000d8670a9\r\n16. void std::__function::__policy_invoker<void ()>::__call_impl<std::__function::__default_alloc_func<ThreadFromGlobalPoolImpl<false, true>::ThreadFromGlobalPoolImpl<void ThreadPoolImpl<ThreadFromGlobalPoolImpl<false, true>>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>(void&&)::'lambda'(), void ()>>(std::__function::__policy_storage const*) @ 0x000000000d86b1f1\r\n17. void* std::__thread_proxy[abi:v15007]<std::tuple<std::unique_ptr<std::__thread_struct, std::default_delete<std::__thread_struct>>, void ThreadPoolImpl<std::thread>::scheduleImpl<void>(std::function<void ()>, Priority, std::optional<unsigned long>, bool)::'lambda0'()>>(void*) @ 0x000000000d869f69\r\n18. ? @ 0x000076cb917d0609\r\n19. ? @ 0x000076cb916f5353\r\n```\r\n\r\n**Additional context**\r\n* version: ClickHouse 24.8.1.1347\r\n* hash: 1e194596106c727ab3731cc74eab6759969f275d\r\n\r\n\n",
  "hints_text": "Example: https://fiddle.clickhouse.com/48edf25f-09fd-4111-886c-53509b7cb82d\r\n\r\nTRIM is special syntax and mapped to an internal SQL function in src/Parsers/ExpressionListParsers.cpp (`TrimLayer`). In this case, we map to `replaceRegexpOne`.\nShould be easy to fix ... it is a good issue for newcomers.\nlooking into it",
  "created_at": "2024-08-16T15:09:50Z"
}