{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58396,
  "instance_id": "ClickHouse__ClickHouse-58396",
  "issue_numbers": [
    "54963"
  ],
  "base_commit": "ed1221ef4c1f1786203fd763ac81c3cad4f6fbd1",
  "patch": "diff --git a/docs/en/sql-reference/data-types/nullable.md b/docs/en/sql-reference/data-types/nullable.md\nindex 28180f7f9919..5504765e4a08 100644\n--- a/docs/en/sql-reference/data-types/nullable.md\n+++ b/docs/en/sql-reference/data-types/nullable.md\n@@ -4,11 +4,11 @@ sidebar_position: 55\n sidebar_label: Nullable\n ---\n \n-# Nullable(typename)\n+# Nullable(T)\n \n-Allows to store special marker ([NULL](../../sql-reference/syntax.md)) that denotes \u201cmissing value\u201d alongside normal values allowed by `TypeName`. For example, a `Nullable(Int8)` type column can store `Int8` type values, and the rows that do not have a value will store `NULL`.\n+Allows to store special marker ([NULL](../../sql-reference/syntax.md)) that denotes \u201cmissing value\u201d alongside normal values allowed by `T`. For example, a `Nullable(Int8)` type column can store `Int8` type values, and the rows that do not have a value will store `NULL`.\n \n-For a `TypeName`, you can\u2019t use composite data types [Array](../../sql-reference/data-types/array.md), [Map](../../sql-reference/data-types/map.md) and [Tuple](../../sql-reference/data-types/tuple.md). Composite data types can contain `Nullable` type values, such as `Array(Nullable(Int8))`.\n+`T` can\u2019t be any of the composite data types [Array](../../sql-reference/data-types/array.md), [Map](../../sql-reference/data-types/map.md) and [Tuple](../../sql-reference/data-types/tuple.md) but composite data types can contain `Nullable` type values, e.g. `Array(Nullable(Int8))`.\n \n A `Nullable` type field can\u2019t be included in table indexes.\n \ndiff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md\nindex 1639f45e66cd..2120b675c733 100644\n--- a/docs/en/sql-reference/functions/array-functions.md\n+++ b/docs/en/sql-reference/functions/array-functions.md\n@@ -657,6 +657,43 @@ SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;\n \n Array elements set to `NULL` are handled as normal values.\n \n+## arrayShingles\n+\n+Generates an array of \"shingles\", i.e. consecutive sub-arrays with specified length of the input array.\n+\n+**Syntax**\n+\n+``` sql\n+arrayShingles(array, length)\n+```\n+\n+**Arguments**\n+\n+- `array` \u2014 Input array [Array](../../sql-reference/data-types/array.md).\n+- `length` \u2014 The length of each shingle.\n+\n+**Returned value**\n+\n+- An array of generated shingles.\n+\n+Type: [Array](../../sql-reference/data-types/array.md).\n+\n+**Examples**\n+\n+Query:\n+\n+``` sql\n+SELECT arrayShingles([1,2,3,4], 3) as res;\n+```\n+\n+Result:\n+\n+``` text\n+\u250c\u2500res\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2510\n+\u2502 [[1,2,3],[2,3,4]] \u2502\n+\u2514\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2518\n+```\n+\n ## arraySort(\\[func,\\] arr, \u2026) {#sort}\n \n Sorts the elements of the `arr` array in ascending order. If the `func` function is specified, sorting order is determined by the result of the `func` function applied to the elements of the array. If `func` accepts multiple arguments, the `arraySort` function is passed several arrays that the arguments of `func` will correspond to. Detailed examples are shown at the end of `arraySort` description.\ndiff --git a/src/Functions/array/arrayShingles.cpp b/src/Functions/array/arrayShingles.cpp\nnew file mode 100644\nindex 000000000000..ade1cb862f78\n--- /dev/null\n+++ b/src/Functions/array/arrayShingles.cpp\n@@ -0,0 +1,102 @@\n+#include <Columns/ColumnArray.h>\n+#include <DataTypes/DataTypeArray.h>\n+#include <Functions/FunctionFactory.h>\n+#include <Functions/FunctionHelpers.h>\n+#include <IO/WriteHelpers.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+    extern const int ILLEGAL_COLUMN;\n+}\n+\n+class FunctionArrayShingles : public IFunction\n+{\n+public:\n+    static constexpr auto name = \"arrayShingles\";\n+\n+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayShingles>(); }\n+    String getName() const override { return name; }\n+    size_t getNumberOfArguments() const override { return 2; }\n+    bool useDefaultImplementationForConstants() const override { return true; }\n+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }\n+\n+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override\n+    {\n+            FunctionArgumentDescriptors args{\n+                {\"array\", &isArray<IDataType>, nullptr, \"Array\"},\n+                {\"length\", &isInteger<IDataType>, nullptr, \"Integer\"}\n+            };\n+            validateFunctionArgumentTypes(*this, arguments, args);\n+\n+        const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[0].type.get());\n+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(array_type->getNestedType()));\n+    }\n+\n+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t input_rows_count) const override\n+    {\n+        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());\n+        if (!col_array)\n+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, \"Expected array column for function {}\", getName());\n+\n+        const ColumnPtr & col_length = arguments[1].column;\n+\n+        const auto & arr_offsets = col_array->getOffsets();\n+        const auto & arr_values = col_array->getData();\n+\n+        auto col_res_data = arr_values.cloneEmpty();\n+        auto col_res_inner_offsets = ColumnArray::ColumnOffsets::create();\n+        auto col_res_outer_offsets = ColumnArray::ColumnOffsets::create();\n+        IColumn::Offsets & out_offsets_2 = col_res_inner_offsets->getData();\n+        IColumn::Offsets & out_offsets_1 = col_res_outer_offsets->getData();\n+\n+        size_t pos1 = 0, pos2 = 0;\n+        for (size_t row = 0; row < input_rows_count; ++row)\n+        {\n+            const Int64 shingle_length = col_length->getInt(row);\n+            if (shingle_length < 1)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Shingle argument of function {} must be a positive integer.\", getName());\n+\n+            const size_t array_length = arr_offsets[row] - arr_offsets[row - 1];\n+            if (static_cast<size_t>(shingle_length) > array_length)\n+                throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Shingle argument of function {} must less or equal than the array length.\", getName());\n+\n+            for (size_t i = 0; i < array_length - shingle_length + 1; ++i)\n+            {\n+                col_res_data->insertRangeFrom(arr_values, arr_offsets[row - 1] + i, shingle_length);\n+                pos1 += shingle_length;\n+                out_offsets_2.push_back(pos1);\n+            }\n+            pos2 += array_length - shingle_length + 1;\n+            out_offsets_1.push_back(pos2);\n+        }\n+\n+        return ColumnArray::create(\n+            ColumnArray::create(\n+                std::move(col_res_data),\n+                std::move(col_res_inner_offsets)),\n+            std::move(col_res_outer_offsets)\n+        );\n+    }\n+};\n+\n+REGISTER_FUNCTION(ArrayShingles)\n+{\n+    factory.registerFunction<FunctionArrayShingles>(\n+        FunctionDocumentation{\n+            .description = R\"(\n+Generates an array of \"shingles\", i.e. consecutive sub-arrays with specified length of the input array.\n+)\",\n+            .examples{\n+                {\"example 1\", \"SELECT arrayShingles([1,2,3,4,5], 3)\", \"[[1,2,3],[2,3,4],[3,4,5]]\"}\n+            },\n+            .categories = {\"Array\"},\n+        });\n+}\n+\n+}\n+\ndiff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt\nindex c4089b219539..1d771ec685f2 100644\n--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt\n+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt\n@@ -1107,6 +1107,7 @@ arrayRotateLeft\n arrayRotateRight\n arrayShiftLeft\n arrayShiftRight\n+arrayShingles\n arraySlice\n arraySort\n arraySplit\n@@ -2316,6 +2317,7 @@ sqlinsert\n sqlite\n sqrt\n src\n+srcReplicas\n stacktrace\n stacktraces\n startsWith\n@@ -2695,4 +2697,3 @@ znode\n znodes\n zookeeperSessionUptime\n zstd\n-srcReplicas\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02891_array_shingles.reference b/tests/queries/0_stateless/02891_array_shingles.reference\nnew file mode 100644\nindex 000000000000..04f7bfa331f2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02891_array_shingles.reference\n@@ -0,0 +1,41 @@\n+-- negative tests\n+-- const and non-const inputs\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+arr:                                            [1,2,3,4,5]\n+len:                                            1\n+arrayShingles([1, 2, 3, 4, 5], 1):              [[1],[2],[3],[4],[5]]\n+arrayShingles(materialize([1, 2, 3, 4, 5]), 1): [[1],[2],[3],[4],[5]]\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+arr:                                            [1,2,3,4,5]\n+len:                                            3\n+arrayShingles([1, 2, 3, 4, 5], 3):              [[1,2,3],[2,3,4],[3,4,5]]\n+arrayShingles(materialize([1, 2, 3, 4, 5]), 3): [[1,2,3],[2,3,4],[3,4,5]]\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+arr:                                            [1,2,3,4,5]\n+len:                                            5\n+arrayShingles([1, 2, 3, 4, 5], 5):              [[1,2,3,4,5]]\n+arrayShingles(materialize([1, 2, 3, 4, 5]), 5): [[1,2,3,4,5]]\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+arr:                                                        ['ab','c','de','','hi']\n+len:                                                        1\n+arrayShingles(['ab', 'c', 'de', '', 'hi'], 1):              [['ab'],['c'],['de'],[''],['hi']]\n+arrayShingles(materialize(['ab', 'c', 'de', '', 'hi']), 1): [['ab'],['c'],['de'],[''],['hi']]\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+arr:                                                        ['ab','c','de','','hi']\n+len:                                                        3\n+arrayShingles(['ab', 'c', 'de', '', 'hi'], 3):              [['ab','c','de'],['c','de',''],['de','','hi']]\n+arrayShingles(materialize(['ab', 'c', 'de', '', 'hi']), 3): [['ab','c','de'],['c','de',''],['de','','hi']]\n+Row 1:\n+\u2500\u2500\u2500\u2500\u2500\u2500\n+arr:                                                        ['ab','c','de','','hi']\n+len:                                                        5\n+arrayShingles(['ab', 'c', 'de', '', 'hi'], 5):              [['ab','c','de','','hi']]\n+arrayShingles(materialize(['ab', 'c', 'de', '', 'hi']), 5): [['ab','c','de','','hi']]\n+-- special cases\n+[[2],[1]]\n+[[2],[1]]\ndiff --git a/tests/queries/0_stateless/02891_array_shingles.sql b/tests/queries/0_stateless/02891_array_shingles.sql\nnew file mode 100644\nindex 000000000000..f199a445a304\n--- /dev/null\n+++ b/tests/queries/0_stateless/02891_array_shingles.sql\n@@ -0,0 +1,23 @@\n+SELECT '-- negative tests';\n+SELECT arrayShingles(); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayShingles([1, 2, 3, 4, 5]); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayShingles([1, 2, 3, 4, 5], 2, 3); -- { serverError NUMBER_OF_ARGUMENTS_DOESNT_MATCH }\n+SELECT arrayShingles([1, 2, 3, 4, 5], 'str'); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayShingles((1, 2, 3, 4, 5), 0); -- { serverError ILLEGAL_TYPE_OF_ARGUMENT }\n+SELECT arrayShingles([1, 2, 3, 4, 5], 0); -- { serverError BAD_ARGUMENTS }\n+SELECT arrayShingles([1, 2, 3, 4, 5], -2); -- { serverError BAD_ARGUMENTS }\n+SELECT arrayShingles([1, 2, 3, 4, 5], 6); -- { serverError BAD_ARGUMENTS }\n+SELECT arrayShingles([], 1); -- { serverError BAD_ARGUMENTS }\n+\n+SELECT '-- const and non-const inputs';\n+SELECT [1, 2, 3, 4, 5] AS arr, 1 AS len, arrayShingles(arr, len), arrayShingles(materialize(arr), len) FORMAT Vertical;\n+SELECT [1, 2, 3, 4, 5] AS arr, 3 AS len, arrayShingles(arr, len), arrayShingles(materialize(arr), len) FORMAT Vertical;\n+SELECT [1, 2 ,3, 4, 5] AS arr, 5 AS len, arrayShingles(arr, len), arrayShingles(materialize(arr), len) FORMAT Vertical;\n+\n+SELECT ['ab', 'c', 'de', '', 'hi'] AS arr, 1 AS len, arrayShingles(arr, len), arrayShingles(materialize(arr), len) FORMAT Vertical;\n+SELECT ['ab', 'c', 'de', '', 'hi'] AS arr, 3 AS len, arrayShingles(arr, len), arrayShingles(materialize(arr), len) FORMAT Vertical;\n+SELECT ['ab', 'c', 'de', '', 'hi'] AS arr, 5 AS len, arrayShingles(arr, len), arrayShingles(materialize(arr), len) FORMAT Vertical;\n+\n+SELECT '-- special cases';\n+SELECT arrayShingles([toNullable(2), toNullable(1)], 1);\n+SELECT arrayShingles([toLowCardinality(2), toLowCardinality(1)], 1);\n",
  "problem_statement": "`shingles` function for arrays.\n**Use case**\r\n\r\n```\r\nshingles(['Fotograf\u00edas','ganadoras','del','World','Press','Photo','Awards','2014','http','t','co','F1iwa8gSWK'], 3)\r\n= [['Fotograf\u00edas','ganadoras','del'],\r\n   ['ganadoras','del','World'],\r\n   ['del','World','Press'],\r\n   ['World','Press','Photo'],\r\n   ['Press','Photo','Awards'],\r\n   ['Photo','Awards','2014'],\r\n   ['Awards','2014','http'],\r\n   ['2014','http','t'],\r\n   ['http','t','co'],\r\n   ['t','co','F1iwa8gSWK']]\r\n```\n",
  "hints_text": "Workaround:\r\n\r\n```\r\narrayMap(idx -> arraySlice(arr, idx + 1, 3), range(greatest(0, length(arr) - 2))) AS shingles\r\n```\nAnother:\r\n```\r\nWITH ['Fotograf\u00edas','ganadoras','del','World','Press','Photo','Awards','2014','http','t','co','F1iwa8gSWK'] AS arr,\r\narrayShiftLeft(arr, 1) AS arr1, arrayShiftLeft(arr, 2) AS arr2\r\nSELECT arraySlice(arrayZip(arr, arr1, arr2), 1, -2)\r\n```\n@alexey-milovidov I'm willing to take this task.\n@zenmiao7, Thank you, this will be amazing!\n@zenmiao7, How is it going?",
  "created_at": "2024-01-01T14:42:53Z",
  "modified_files": [
    "docs/en/sql-reference/data-types/nullable.md",
    "docs/en/sql-reference/functions/array-functions.md",
    "b/src/Functions/array/arrayShingles.cpp",
    "utils/check-style/aspell-ignore/en/aspell-dict.txt"
  ],
  "modified_test_files": [
    "b/tests/queries/0_stateless/02891_array_shingles.reference",
    "b/tests/queries/0_stateless/02891_array_shingles.sql"
  ]
}