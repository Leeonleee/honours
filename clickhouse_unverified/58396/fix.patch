diff --git a/docs/en/sql-reference/data-types/nullable.md b/docs/en/sql-reference/data-types/nullable.md
index 28180f7f9919..5504765e4a08 100644
--- a/docs/en/sql-reference/data-types/nullable.md
+++ b/docs/en/sql-reference/data-types/nullable.md
@@ -4,11 +4,11 @@ sidebar_position: 55
 sidebar_label: Nullable
 ---
 
-# Nullable(typename)
+# Nullable(T)
 
-Allows to store special marker ([NULL](../../sql-reference/syntax.md)) that denotes “missing value” alongside normal values allowed by `TypeName`. For example, a `Nullable(Int8)` type column can store `Int8` type values, and the rows that do not have a value will store `NULL`.
+Allows to store special marker ([NULL](../../sql-reference/syntax.md)) that denotes “missing value” alongside normal values allowed by `T`. For example, a `Nullable(Int8)` type column can store `Int8` type values, and the rows that do not have a value will store `NULL`.
 
-For a `TypeName`, you can’t use composite data types [Array](../../sql-reference/data-types/array.md), [Map](../../sql-reference/data-types/map.md) and [Tuple](../../sql-reference/data-types/tuple.md). Composite data types can contain `Nullable` type values, such as `Array(Nullable(Int8))`.
+`T` can’t be any of the composite data types [Array](../../sql-reference/data-types/array.md), [Map](../../sql-reference/data-types/map.md) and [Tuple](../../sql-reference/data-types/tuple.md) but composite data types can contain `Nullable` type values, e.g. `Array(Nullable(Int8))`.
 
 A `Nullable` type field can’t be included in table indexes.
 
diff --git a/docs/en/sql-reference/functions/array-functions.md b/docs/en/sql-reference/functions/array-functions.md
index 1639f45e66cd..2120b675c733 100644
--- a/docs/en/sql-reference/functions/array-functions.md
+++ b/docs/en/sql-reference/functions/array-functions.md
@@ -657,6 +657,43 @@ SELECT arraySlice([1, 2, NULL, 4, 5], 2, 3) AS res;
 
 Array elements set to `NULL` are handled as normal values.
 
+## arrayShingles
+
+Generates an array of "shingles", i.e. consecutive sub-arrays with specified length of the input array.
+
+**Syntax**
+
+``` sql
+arrayShingles(array, length)
+```
+
+**Arguments**
+
+- `array` — Input array [Array](../../sql-reference/data-types/array.md).
+- `length` — The length of each shingle.
+
+**Returned value**
+
+- An array of generated shingles.
+
+Type: [Array](../../sql-reference/data-types/array.md).
+
+**Examples**
+
+Query:
+
+``` sql
+SELECT arrayShingles([1,2,3,4], 3) as res;
+```
+
+Result:
+
+``` text
+┌─res───────────────┐
+│ [[1,2,3],[2,3,4]] │
+└───────────────────┘
+```
+
 ## arraySort(\[func,\] arr, …) {#sort}
 
 Sorts the elements of the `arr` array in ascending order. If the `func` function is specified, sorting order is determined by the result of the `func` function applied to the elements of the array. If `func` accepts multiple arguments, the `arraySort` function is passed several arrays that the arguments of `func` will correspond to. Detailed examples are shown at the end of `arraySort` description.
diff --git a/src/Functions/array/arrayShingles.cpp b/src/Functions/array/arrayShingles.cpp
new file mode 100644
index 000000000000..ade1cb862f78
--- /dev/null
+++ b/src/Functions/array/arrayShingles.cpp
@@ -0,0 +1,102 @@
+#include <Columns/ColumnArray.h>
+#include <DataTypes/DataTypeArray.h>
+#include <Functions/FunctionFactory.h>
+#include <Functions/FunctionHelpers.h>
+#include <IO/WriteHelpers.h>
+
+
+namespace DB
+{
+
+namespace ErrorCodes
+{
+    extern const int BAD_ARGUMENTS;
+    extern const int ILLEGAL_COLUMN;
+}
+
+class FunctionArrayShingles : public IFunction
+{
+public:
+    static constexpr auto name = "arrayShingles";
+
+    static FunctionPtr create(ContextPtr) { return std::make_shared<FunctionArrayShingles>(); }
+    String getName() const override { return name; }
+    size_t getNumberOfArguments() const override { return 2; }
+    bool useDefaultImplementationForConstants() const override { return true; }
+    bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & /*arguments*/) const override { return true; }
+
+    DataTypePtr getReturnTypeImpl(const ColumnsWithTypeAndName & arguments) const override
+    {
+            FunctionArgumentDescriptors args{
+                {"array", &isArray<IDataType>, nullptr, "Array"},
+                {"length", &isInteger<IDataType>, nullptr, "Integer"}
+            };
+            validateFunctionArgumentTypes(*this, arguments, args);
+
+        const DataTypeArray * array_type = checkAndGetDataType<DataTypeArray>(arguments[0].type.get());
+        return std::make_shared<DataTypeArray>(std::make_shared<DataTypeArray>(array_type->getNestedType()));
+    }
+
+    ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr & /*result_type*/, size_t input_rows_count) const override
+    {
+        const ColumnArray * col_array = checkAndGetColumn<ColumnArray>(arguments[0].column.get());
+        if (!col_array)
+            throw Exception(ErrorCodes::ILLEGAL_COLUMN, "Expected array column for function {}", getName());
+
+        const ColumnPtr & col_length = arguments[1].column;
+
+        const auto & arr_offsets = col_array->getOffsets();
+        const auto & arr_values = col_array->getData();
+
+        auto col_res_data = arr_values.cloneEmpty();
+        auto col_res_inner_offsets = ColumnArray::ColumnOffsets::create();
+        auto col_res_outer_offsets = ColumnArray::ColumnOffsets::create();
+        IColumn::Offsets & out_offsets_2 = col_res_inner_offsets->getData();
+        IColumn::Offsets & out_offsets_1 = col_res_outer_offsets->getData();
+
+        size_t pos1 = 0, pos2 = 0;
+        for (size_t row = 0; row < input_rows_count; ++row)
+        {
+            const Int64 shingle_length = col_length->getInt(row);
+            if (shingle_length < 1)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Shingle argument of function {} must be a positive integer.", getName());
+
+            const size_t array_length = arr_offsets[row] - arr_offsets[row - 1];
+            if (static_cast<size_t>(shingle_length) > array_length)
+                throw Exception(ErrorCodes::BAD_ARGUMENTS, "Shingle argument of function {} must less or equal than the array length.", getName());
+
+            for (size_t i = 0; i < array_length - shingle_length + 1; ++i)
+            {
+                col_res_data->insertRangeFrom(arr_values, arr_offsets[row - 1] + i, shingle_length);
+                pos1 += shingle_length;
+                out_offsets_2.push_back(pos1);
+            }
+            pos2 += array_length - shingle_length + 1;
+            out_offsets_1.push_back(pos2);
+        }
+
+        return ColumnArray::create(
+            ColumnArray::create(
+                std::move(col_res_data),
+                std::move(col_res_inner_offsets)),
+            std::move(col_res_outer_offsets)
+        );
+    }
+};
+
+REGISTER_FUNCTION(ArrayShingles)
+{
+    factory.registerFunction<FunctionArrayShingles>(
+        FunctionDocumentation{
+            .description = R"(
+Generates an array of "shingles", i.e. consecutive sub-arrays with specified length of the input array.
+)",
+            .examples{
+                {"example 1", "SELECT arrayShingles([1,2,3,4,5], 3)", "[[1,2,3],[2,3,4],[3,4,5]]"}
+            },
+            .categories = {"Array"},
+        });
+}
+
+}
+
diff --git a/utils/check-style/aspell-ignore/en/aspell-dict.txt b/utils/check-style/aspell-ignore/en/aspell-dict.txt
index c4089b219539..1d771ec685f2 100644
--- a/utils/check-style/aspell-ignore/en/aspell-dict.txt
+++ b/utils/check-style/aspell-ignore/en/aspell-dict.txt
@@ -1107,6 +1107,7 @@ arrayRotateLeft
 arrayRotateRight
 arrayShiftLeft
 arrayShiftRight
+arrayShingles
 arraySlice
 arraySort
 arraySplit
@@ -2316,6 +2317,7 @@ sqlinsert
 sqlite
 sqrt
 src
+srcReplicas
 stacktrace
 stacktraces
 startsWith
@@ -2695,4 +2697,3 @@ znode
 znodes
 zookeeperSessionUptime
 zstd
-srcReplicas
