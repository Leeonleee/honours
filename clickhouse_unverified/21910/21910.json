{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 21910,
  "instance_id": "ClickHouse__ClickHouse-21910",
  "issue_numbers": [
    "21560"
  ],
  "base_commit": "07c967b5c7d2ab79540fd3abf97bdfbdce2d66f3",
  "patch": "diff --git a/src/Functions/FunctionsExternalDictionaries.h b/src/Functions/FunctionsExternalDictionaries.h\nindex d699e244f7cc..2c322698327d 100644\n--- a/src/Functions/FunctionsExternalDictionaries.h\n+++ b/src/Functions/FunctionsExternalDictionaries.h\n@@ -75,27 +75,11 @@ namespace ErrorCodes\n class FunctionDictHelper\n {\n public:\n-    explicit FunctionDictHelper(const Context & context_) : context(context_), external_loader(context.getExternalDictionariesLoader()) {}\n+    explicit FunctionDictHelper(const Context & context_) : context(context_) {}\n \n     std::shared_ptr<const IDictionaryBase> getDictionary(const String & dictionary_name)\n     {\n-        String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n-\n-        bool can_load_dictionary = external_loader.hasDictionary(resolved_name);\n-\n-        if (!can_load_dictionary)\n-        {\n-            /// If dictionary not found. And database was not implicitly specified\n-            /// we can qualify dictionary name with current database name.\n-            /// It will help if dictionary is created with DDL and is in current database.\n-            if (dictionary_name.find('.') == std::string::npos)\n-            {\n-                String dictionary_name_with_database = context.getCurrentDatabase() + '.' + dictionary_name;\n-                resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name_with_database);\n-            }\n-        }\n-\n-        auto dict = external_loader.getDictionary(resolved_name);\n+        auto dict = context.getExternalDictionariesLoader().getDictionary(dictionary_name, context);\n \n         if (!access_checked)\n         {\n@@ -134,31 +118,11 @@ class FunctionDictHelper\n \n     DictionaryStructure getDictionaryStructure(const String & dictionary_name) const\n     {\n-        String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n-\n-        auto load_result = external_loader.getLoadResult(resolved_name);\n-        if (!load_result.config)\n-        {\n-            /// If dictionary not found. And database was not implicitly specified\n-            /// we can qualify dictionary name with current database name.\n-            /// It will help if dictionary is created with DDL and is in current database.\n-            if (dictionary_name.find('.') == std::string::npos)\n-            {\n-                String dictionary_name_with_database = context.getCurrentDatabase() + '.' + dictionary_name;\n-                resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name_with_database);\n-                load_result = external_loader.getLoadResult(resolved_name);\n-            }\n-        }\n-\n-        if (!load_result.config)\n-            throw Exception(\"Dictionary \" + backQuote(dictionary_name) + \" not found\", ErrorCodes::BAD_ARGUMENTS);\n-\n-        return ExternalDictionariesLoader::getDictionaryStructure(*load_result.config);\n+        return context.getExternalDictionariesLoader().getDictionaryStructure(dictionary_name, context);\n     }\n \n-    const Context & context;\n private:\n-    const ExternalDictionariesLoader & external_loader;\n+    const Context & context;\n     /// Access cannot be not granted, since in this case checkAccess() will throw and access_checked will not be updated.\n     std::atomic<bool> access_checked = false;\n \ndiff --git a/src/Interpreters/DatabaseCatalog.cpp b/src/Interpreters/DatabaseCatalog.cpp\nindex f27fb93b2d41..f398074da090 100644\n--- a/src/Interpreters/DatabaseCatalog.cpp\n+++ b/src/Interpreters/DatabaseCatalog.cpp\n@@ -910,31 +910,6 @@ String DatabaseCatalog::getPathForUUID(const UUID & uuid)\n     return toString(uuid).substr(0, uuid_prefix_len) + '/' + toString(uuid) + '/';\n }\n \n-String DatabaseCatalog::resolveDictionaryName(const String & name) const\n-{\n-    /// If it's dictionary from Atomic database, then we need to convert qualified name to UUID.\n-    /// Try to split name and get id from associated StorageDictionary.\n-    /// If something went wrong, return name as is.\n-\n-    /// TODO support dot in name for dictionaries in Atomic databases\n-    auto pos = name.find('.');\n-    if (pos == std::string::npos || name.find('.', pos + 1) != std::string::npos)\n-        return name;\n-    String maybe_database_name = name.substr(0, pos);\n-    String maybe_table_name = name.substr(pos + 1);\n-\n-    auto db_and_table = tryGetDatabaseAndTable({maybe_database_name, maybe_table_name}, global_context);\n-    if (!db_and_table.first)\n-        return name;\n-    assert(db_and_table.second);\n-    if (db_and_table.first->getUUID() == UUIDHelpers::Nil)\n-        return name;\n-    if (db_and_table.second->getName() != \"Dictionary\")\n-        return name;\n-\n-    return toString(db_and_table.second->getStorageID().uuid);\n-}\n-\n void DatabaseCatalog::waitTableFinallyDropped(const UUID & uuid)\n {\n     if (uuid == UUIDHelpers::Nil)\ndiff --git a/src/Interpreters/DatabaseCatalog.h b/src/Interpreters/DatabaseCatalog.h\nindex bb82dbfc4407..dad9846da0b5 100644\n--- a/src/Interpreters/DatabaseCatalog.h\n+++ b/src/Interpreters/DatabaseCatalog.h\n@@ -192,9 +192,6 @@ class DatabaseCatalog : boost::noncopyable\n     String getPathForDroppedMetadata(const StorageID & table_id) const;\n     void enqueueDroppedTableCleanup(StorageID table_id, StoragePtr table, String dropped_metadata_path, bool ignore_delay = false);\n \n-    /// Try convert qualified dictionary name to persistent UUID\n-    String resolveDictionaryName(const String & name) const;\n-\n     void waitTableFinallyDropped(const UUID & uuid);\n \n private:\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 03bd370fb8c2..150f177b2b24 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -761,8 +761,8 @@ static bool allowDictJoin(StoragePtr joined_storage, const Context & context, St\n     if (!dict)\n         return false;\n \n-    dict_name = dict->resolvedDictionaryName();\n-    auto dictionary = context.getExternalDictionariesLoader().getDictionary(dict_name);\n+    dict_name = dict->dictionaryName();\n+    auto dictionary = context.getExternalDictionariesLoader().getDictionary(dict_name, context);\n     if (!dictionary)\n         return false;\n \ndiff --git a/src/Interpreters/ExternalDictionariesLoader.cpp b/src/Interpreters/ExternalDictionariesLoader.cpp\nindex 4df4e5f8c1be..1632b7cbf78c 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.cpp\n+++ b/src/Interpreters/ExternalDictionariesLoader.cpp\n@@ -1,6 +1,10 @@\n #include <Interpreters/ExternalDictionariesLoader.h>\n+#include <Interpreters/DatabaseCatalog.h>\n+#include <Interpreters/Context.h>\n #include <Dictionaries/DictionaryFactory.h>\n #include <Dictionaries/DictionaryStructure.h>\n+#include <Databases/IDatabase.h>\n+#include <Storages/IStorage.h>\n \n #if !defined(ARCADIA_BUILD)\n #    include \"config_core.h\"\n@@ -13,10 +17,15 @@\n namespace DB\n {\n \n+namespace ErrorCodes\n+{\n+    extern const int BAD_ARGUMENTS;\n+}\n+\n /// Must not acquire Context lock in constructor to avoid possibility of deadlocks.\n-ExternalDictionariesLoader::ExternalDictionariesLoader(Context & context_)\n+ExternalDictionariesLoader::ExternalDictionariesLoader(Context & global_context_)\n     : ExternalLoader(\"external dictionary\", &Poco::Logger::get(\"ExternalDictionariesLoader\"))\n-    , context(context_)\n+    , global_context(global_context_)\n {\n     setConfigSettings({\"dictionary\", \"name\", \"database\", \"uuid\"});\n     enableAsyncLoading(true);\n@@ -31,9 +40,88 @@ ExternalLoader::LoadablePtr ExternalDictionariesLoader::create(\n     /// For dictionaries from databases (created with DDL queries) we have to perform\n     /// additional checks, so we identify them here.\n     bool dictionary_from_database = !repository_name.empty();\n-    return DictionaryFactory::instance().create(name, config, key_in_config, context, dictionary_from_database);\n+    return DictionaryFactory::instance().create(name, config, key_in_config, global_context, dictionary_from_database);\n+}\n+\n+ExternalDictionariesLoader::DictPtr ExternalDictionariesLoader::getDictionary(const std::string & dictionary_name, const Context & context) const\n+{\n+    std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, context.getCurrentDatabase());\n+    return std::static_pointer_cast<const IDictionaryBase>(load(resolved_dictionary_name));\n+}\n+\n+ExternalDictionariesLoader::DictPtr ExternalDictionariesLoader::tryGetDictionary(const std::string & dictionary_name, const Context & context) const\n+{\n+    std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, context.getCurrentDatabase());\n+    return std::static_pointer_cast<const IDictionaryBase>(tryLoad(resolved_dictionary_name));\n+}\n+\n+\n+void ExternalDictionariesLoader::reloadDictionary(const std::string & dictionary_name, const Context & context) const\n+{\n+    std::string resolved_dictionary_name = resolveDictionaryName(dictionary_name, context.getCurrentDatabase());\n+    loadOrReload(resolved_dictionary_name);\n }\n \n+DictionaryStructure ExternalDictionariesLoader::getDictionaryStructure(const std::string & dictionary_name, const Context & query_context) const\n+{\n+    std::string resolved_name = resolveDictionaryName(dictionary_name, query_context.getCurrentDatabase());\n+\n+    auto load_result = getLoadResult(resolved_name);\n+    if (!load_result.config)\n+        throw Exception(\"Dictionary \" + backQuote(dictionary_name) + \" config not found\", ErrorCodes::BAD_ARGUMENTS);\n+\n+    return ExternalDictionariesLoader::getDictionaryStructure(*load_result.config);\n+}\n+\n+std::string ExternalDictionariesLoader::resolveDictionaryName(const std::string & dictionary_name, const std::string & current_database_name) const\n+{\n+    std::string resolved_name = resolveDictionaryNameFromDatabaseCatalog(dictionary_name);\n+    bool has_dictionary = has(resolved_name);\n+\n+    if (!has_dictionary)\n+    {\n+        /// If dictionary not found. And database was not implicitly specified\n+        /// we can qualify dictionary name with current database name.\n+        /// It will help if dictionary is created with DDL and is in current database.\n+        if (dictionary_name.find('.') == std::string::npos)\n+        {\n+            String dictionary_name_with_database = current_database_name + '.' + dictionary_name;\n+            resolved_name = resolveDictionaryNameFromDatabaseCatalog(dictionary_name_with_database);\n+            has_dictionary = has(resolved_name);\n+        }\n+    }\n+\n+    if (!has_dictionary)\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Dictionary ({}) not found\", backQuote(dictionary_name));\n+\n+    return resolved_name;\n+}\n+\n+std::string ExternalDictionariesLoader::resolveDictionaryNameFromDatabaseCatalog(const std::string & name) const\n+{\n+    /// If it's dictionary from Atomic database, then we need to convert qualified name to UUID.\n+    /// Try to split name and get id from associated StorageDictionary.\n+    /// If something went wrong, return name as is.\n+\n+    auto pos = name.find('.');\n+    if (pos == std::string::npos || name.find('.', pos + 1) != std::string::npos)\n+        return name;\n+\n+    std::string maybe_database_name = name.substr(0, pos);\n+    std::string maybe_table_name = name.substr(pos + 1);\n+\n+    auto [db, table] = DatabaseCatalog::instance().tryGetDatabaseAndTable({maybe_database_name, maybe_table_name}, global_context);\n+    if (!db)\n+        return name;\n+    assert(table);\n+\n+    if (db->getUUID() == UUIDHelpers::Nil)\n+        return name;\n+    if (table->getName() != \"Dictionary\")\n+        return name;\n+\n+    return toString(table->getStorageID().uuid);\n+}\n \n DictionaryStructure\n ExternalDictionariesLoader::getDictionaryStructure(const Poco::Util::AbstractConfiguration & config, const std::string & key_in_config)\ndiff --git a/src/Interpreters/ExternalDictionariesLoader.h b/src/Interpreters/ExternalDictionariesLoader.h\nindex 6e61e9cd62f0..0f64715b2438 100644\n--- a/src/Interpreters/ExternalDictionariesLoader.h\n+++ b/src/Interpreters/ExternalDictionariesLoader.h\n@@ -1,9 +1,11 @@\n #pragma once\n \n-#include <Dictionaries/IDictionary.h>\n-#include <Interpreters/ExternalLoader.h>\n #include <memory>\n \n+#include <Common/quoteString.h>\n+#include <Interpreters/ExternalLoader.h>\n+#include <Dictionaries/IDictionary.h>\n+\n namespace DB\n {\n class Context;\n@@ -16,24 +18,18 @@ class ExternalDictionariesLoader : public ExternalLoader\n     using DictPtr = std::shared_ptr<const IDictionaryBase>;\n \n     /// Dictionaries will be loaded immediately and then will be updated in separate thread, each 'reload_period' seconds.\n-    explicit ExternalDictionariesLoader(Context & context_);\n+    explicit ExternalDictionariesLoader(Context & global_context_);\n \n-    DictPtr getDictionary(const std::string & name) const\n-    {\n-        return std::static_pointer_cast<const IDictionaryBase>(load(name));\n-    }\n+    DictPtr getDictionary(const std::string & dictionary_name, const Context & context) const;\n \n-    DictPtr tryGetDictionary(const std::string & name) const\n-    {\n-        return std::static_pointer_cast<const IDictionaryBase>(tryLoad(name));\n-    }\n+    DictPtr tryGetDictionary(const std::string & dictionary_name, const Context & context) const;\n \n-    bool hasDictionary(const std::string & name) const\n-    {\n-        return has(name);\n-    }\n+    void reloadDictionary(const std::string & dictionary_name, const Context & context) const;\n+\n+    DictionaryStructure getDictionaryStructure(const std::string & dictionary_name, const Context & context) const;\n \n     static DictionaryStructure getDictionaryStructure(const Poco::Util::AbstractConfiguration & config, const std::string & key_in_config = \"dictionary\");\n+\n     static DictionaryStructure getDictionaryStructure(const ObjectConfig & config);\n \n     static void resetAll();\n@@ -42,11 +38,16 @@ class ExternalDictionariesLoader : public ExternalLoader\n     LoadablePtr create(const std::string & name, const Poco::Util::AbstractConfiguration & config,\n             const std::string & key_in_config, const std::string & repository_name) const override;\n \n+    std::string resolveDictionaryName(const std::string & dictionary_name, const std::string & current_database_name) const;\n+\n+    /// Try convert qualified dictionary name to persistent UUID\n+    std::string resolveDictionaryNameFromDatabaseCatalog(const std::string & name) const;\n+\n     friend class StorageSystemDictionaries;\n     friend class DatabaseDictionary;\n \n private:\n-    Context & context;\n+    Context & global_context;\n };\n \n }\ndiff --git a/src/Interpreters/InterpreterSystemQuery.cpp b/src/Interpreters/InterpreterSystemQuery.cpp\nindex 53fb865be2df..32a8f6d1767b 100644\n--- a/src/Interpreters/InterpreterSystemQuery.cpp\n+++ b/src/Interpreters/InterpreterSystemQuery.cpp\n@@ -276,8 +276,10 @@ BlockIO InterpreterSystemQuery::execute()\n         case Type::RELOAD_DICTIONARY:\n         {\n             context.checkAccess(AccessType::SYSTEM_RELOAD_DICTIONARY);\n-            system_context.getExternalDictionariesLoader().loadOrReload(\n-                    DatabaseCatalog::instance().resolveDictionaryName(query.target_dictionary));\n+\n+            auto & external_dictionaries_loader = system_context.getExternalDictionariesLoader();\n+            external_dictionaries_loader.reloadDictionary(query.target_dictionary, context);\n+\n             ExternalDictionariesLoader::resetAll();\n             break;\n         }\ndiff --git a/src/Interpreters/StorageID.h b/src/Interpreters/StorageID.h\nindex ec5ccba37c2e..2b2a8daa009e 100644\n--- a/src/Interpreters/StorageID.h\n+++ b/src/Interpreters/StorageID.h\n@@ -89,7 +89,7 @@ struct StorageID\n                                           const String & config_prefix);\n \n     /// If dictionary has UUID, then use it as dictionary name in ExternalLoader to allow dictionary renaming.\n-    /// DatabaseCatalog::resolveDictionaryName(...) should be used to access such dictionaries by name.\n+    /// ExternalDictnariesLoader::resolveDictionaryName(...) should be used to access such dictionaries by name.\n     String getInternalDictionaryName() const;\n \n private:\ndiff --git a/src/Interpreters/TreeOptimizer.cpp b/src/Interpreters/TreeOptimizer.cpp\nindex 5c6f76c8c29e..3f4c2e74e233 100644\n--- a/src/Interpreters/TreeOptimizer.cpp\n+++ b/src/Interpreters/TreeOptimizer.cpp\n@@ -135,8 +135,7 @@ void optimizeGroupBy(ASTSelectQuery * select_query, const NameSet & source_colum\n                 const auto & dict_name = dict_name_ast->value.safeGet<String>();\n                 const auto & attr_name = attr_name_ast->value.safeGet<String>();\n \n-                String resolved_name = DatabaseCatalog::instance().resolveDictionaryName(dict_name);\n-                const auto & dict_ptr = context.getExternalDictionariesLoader().getDictionary(resolved_name);\n+                const auto & dict_ptr = context.getExternalDictionariesLoader().getDictionary(dict_name, context);\n                 if (!dict_ptr->isInjective(attr_name))\n                 {\n                     ++i;\ndiff --git a/src/Storages/StorageDictionary.cpp b/src/Storages/StorageDictionary.cpp\nindex 32fe7b4c0264..36241cd5582b 100644\n--- a/src/Storages/StorageDictionary.cpp\n+++ b/src/Storages/StorageDictionary.cpp\n@@ -89,13 +89,6 @@ String StorageDictionary::generateNamesAndTypesDescription(const NamesAndTypesLi\n     return ss.str();\n }\n \n-String StorageDictionary::resolvedDictionaryName() const\n-{\n-    if (location == Location::SameDatabaseAndNameAsDictionary)\n-        return dictionary_name;\n-    return DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n-}\n-\n StorageDictionary::StorageDictionary(\n     const StorageID & table_id_,\n     const String & dictionary_name_,\n@@ -140,7 +133,7 @@ Pipe StorageDictionary::read(\n     const size_t max_block_size,\n     const unsigned /*threads*/)\n {\n-    auto dictionary = context.getExternalDictionariesLoader().getDictionary(resolvedDictionaryName());\n+    auto dictionary = context.getExternalDictionariesLoader().getDictionary(dictionary_name, context);\n     auto stream = dictionary->getBlockInputStream(column_names, max_block_size);\n     /// TODO: update dictionary interface for processors.\n     return Pipe(std::make_shared<SourceFromInputStream>(stream));\n@@ -160,8 +153,8 @@ void registerStorageDictionary(StorageFactory & factory)\n \n         if (!args.attach)\n         {\n-            auto resolved = DatabaseCatalog::instance().resolveDictionaryName(dictionary_name);\n-            const auto & dictionary = args.context.getExternalDictionariesLoader().getDictionary(resolved);\n+            const auto & context = args.context;\n+            const auto & dictionary = context.getExternalDictionariesLoader().getDictionary(dictionary_name, context);\n             const DictionaryStructure & dictionary_structure = dictionary->getStructure();\n             checkNamesAndTypesCompatibleWithDictionary(dictionary_name, args.columns, dictionary_structure);\n         }\ndiff --git a/src/Storages/StorageDictionary.h b/src/Storages/StorageDictionary.h\nindex 589ff7d46546..563def8672b2 100644\n--- a/src/Storages/StorageDictionary.h\n+++ b/src/Storages/StorageDictionary.h\n@@ -7,10 +7,12 @@\n namespace DB\n {\n struct DictionaryStructure;\n+class TableFunctionDictionary;\n \n class StorageDictionary final : public ext::shared_ptr_helper<StorageDictionary>, public IStorage\n {\n     friend struct ext::shared_ptr_helper<StorageDictionary>;\n+    friend class TableFunctionDictionary;\n public:\n     std::string getName() const override { return \"Dictionary\"; }\n \n@@ -30,7 +32,6 @@ class StorageDictionary final : public ext::shared_ptr_helper<StorageDictionary>\n     static String generateNamesAndTypesDescription(const NamesAndTypesList & list);\n \n     const String & dictionaryName() const { return dictionary_name; }\n-    String resolvedDictionaryName() const;\n \n     /// Specifies where the table is located relative to the dictionary.\n     enum class Location\ndiff --git a/src/TableFunctions/ITableFunction.h b/src/TableFunctions/ITableFunction.h\nindex 4a73adbdf803..eb5e1618b3ce 100644\n--- a/src/TableFunctions/ITableFunction.h\n+++ b/src/TableFunctions/ITableFunction.h\n@@ -55,7 +55,7 @@ class ITableFunction : public std::enable_shared_from_this<ITableFunction>\n     /// Create storage according to the query.\n     StoragePtr execute(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns_ = {}) const;\n \n-    virtual ~ITableFunction() {}\n+    virtual ~ITableFunction() = default;\n \n private:\n     virtual StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription cached_columns) const = 0;\ndiff --git a/src/TableFunctions/TableFunctionDictionary.cpp b/src/TableFunctions/TableFunctionDictionary.cpp\nnew file mode 100644\nindex 000000000000..722ffccc07d9\n--- /dev/null\n+++ b/src/TableFunctions/TableFunctionDictionary.cpp\n@@ -0,0 +1,63 @@\n+#include <TableFunctions/TableFunctionDictionary.h>\n+\n+#include <Parsers/ASTLiteral.h>\n+\n+#include <Interpreters/Context.h>\n+#include <Interpreters/ExternalDictionariesLoader.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n+\n+#include <Storages/StorageDictionary.h>\n+\n+#include <TableFunctions/TableFunctionFactory.h>\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int LOGICAL_ERROR;\n+    extern const int NUMBER_OF_ARGUMENTS_DOESNT_MATCH;\n+}\n+\n+void TableFunctionDictionary::parseArguments(const ASTPtr & ast_function, const Context & context)\n+{\n+    // Parse args\n+    ASTs & args_func = ast_function->children;\n+\n+    if (args_func.size() != 1)\n+        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Table function ({}) must have arguments.\", quoteString(getName()));\n+\n+    ASTs & args = args_func.at(0)->children;\n+\n+    if (args.size() != 1)\n+        throw Exception(ErrorCodes::NUMBER_OF_ARGUMENTS_DOESNT_MATCH, \"Table function ({}) requires 1 arguments\", quoteString(getName()));\n+\n+    for (auto & arg : args)\n+        arg = evaluateConstantExpressionOrIdentifierAsLiteral(arg, context);\n+\n+    dictionary_name = args[0]->as<ASTLiteral &>().value.safeGet<String>();\n+}\n+\n+ColumnsDescription TableFunctionDictionary::getActualTableStructure(const Context & context) const\n+{\n+    const ExternalDictionariesLoader & external_loader = context.getExternalDictionariesLoader();\n+    auto dictionary_structure = external_loader.getDictionaryStructure(dictionary_name, context);\n+    auto result = ColumnsDescription(StorageDictionary::getNamesAndTypes(dictionary_structure));\n+\n+    return result;\n+}\n+\n+StoragePtr TableFunctionDictionary::executeImpl(\n+    const ASTPtr &, const Context & context, const std::string & table_name, ColumnsDescription) const\n+{\n+    StorageID dict_id(getDatabaseName(), table_name);\n+    auto dictionary_table_structure = getActualTableStructure(context);\n+    return StorageDictionary::create(dict_id, dictionary_name, std::move(dictionary_table_structure), StorageDictionary::Location::Custom);\n+}\n+\n+void registerTableFunctionDictionary(TableFunctionFactory & factory)\n+{\n+    factory.registerFunction<TableFunctionDictionary>();\n+}\n+\n+}\ndiff --git a/src/TableFunctions/TableFunctionDictionary.h b/src/TableFunctions/TableFunctionDictionary.h\nnew file mode 100644\nindex 000000000000..8c518eb79293\n--- /dev/null\n+++ b/src/TableFunctions/TableFunctionDictionary.h\n@@ -0,0 +1,34 @@\n+#pragma once\n+\n+#include <TableFunctions/ITableFunction.h>\n+\n+namespace DB\n+{\n+class Context;\n+\n+/* file(path, format, structure) - creates a temporary storage from file\n+ *\n+ * The file must be in the clickhouse data directory.\n+ * The relative path begins with the clickhouse data directory.\n+ */\n+class TableFunctionDictionary final : public ITableFunction\n+{\n+public:\n+    static constexpr auto name = \"dictionary\";\n+    std::string getName() const override\n+    {\n+        return name;\n+    }\n+\n+    void parseArguments(const ASTPtr & ast_function, const Context & context) override;\n+\n+    ColumnsDescription getActualTableStructure(const Context & context) const override;\n+\n+    StoragePtr executeImpl(const ASTPtr & ast_function, const Context & context, const std::string & table_name, ColumnsDescription) const override;\n+\n+    const char * getStorageTypeName() const override { return \"Dictionary\"; }\n+\n+private:\n+    String dictionary_name;\n+    ColumnsDescription dictionary_columns;\n+};}\ndiff --git a/src/TableFunctions/registerTableFunctions.cpp b/src/TableFunctions/registerTableFunctions.cpp\nindex a6640bbb0e90..2e55c16d815f 100644\n--- a/src/TableFunctions/registerTableFunctions.cpp\n+++ b/src/TableFunctions/registerTableFunctions.cpp\n@@ -40,6 +40,8 @@ void registerTableFunctions()\n #if USE_LIBPQXX\n     registerTableFunctionPostgreSQL(factory);\n #endif\n+\n+    registerTableFunctionDictionary(factory);\n }\n \n }\ndiff --git a/src/TableFunctions/registerTableFunctions.h b/src/TableFunctions/registerTableFunctions.h\nindex 7e9a8ab5b61a..2654ab2afc23 100644\n--- a/src/TableFunctions/registerTableFunctions.h\n+++ b/src/TableFunctions/registerTableFunctions.h\n@@ -41,6 +41,8 @@ void registerTableFunctionMySQL(TableFunctionFactory & factory);\n void registerTableFunctionPostgreSQL(TableFunctionFactory & factory);\n #endif\n \n+void registerTableFunctionDictionary(TableFunctionFactory & factory);\n+\n void registerTableFunctions();\n \n }\ndiff --git a/src/TableFunctions/ya.make b/src/TableFunctions/ya.make\nindex 7bcf5fc53b31..f50e345f2d87 100644\n--- a/src/TableFunctions/ya.make\n+++ b/src/TableFunctions/ya.make\n@@ -12,6 +12,7 @@ SRCS(\n     ITableFunction.cpp\n     ITableFunctionFileLike.cpp\n     ITableFunctionXDBC.cpp\n+    TableFunctionDictionary.cpp\n     TableFunctionFactory.cpp\n     TableFunctionFile.cpp\n     TableFunctionGenerateRandom.cpp\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01764_table_function_dictionary.reference b/tests/queries/0_stateless/01764_table_function_dictionary.reference\nnew file mode 100644\nindex 000000000000..b8e844ab3e9d\n--- /dev/null\n+++ b/tests/queries/0_stateless/01764_table_function_dictionary.reference\n@@ -0,0 +1,2 @@\n+0\t0\n+1\t1\ndiff --git a/tests/queries/0_stateless/01764_table_function_dictionary.sql b/tests/queries/0_stateless/01764_table_function_dictionary.sql\nnew file mode 100644\nindex 000000000000..0168566077d2\n--- /dev/null\n+++ b/tests/queries/0_stateless/01764_table_function_dictionary.sql\n@@ -0,0 +1,25 @@\n+DROP TABLE IF EXISTS table_function_dictionary_source_table;\n+CREATE TABLE table_function_dictionary_source_table\n+(\n+   id UInt64,\n+   value UInt64\n+)\n+ENGINE = TinyLog;\n+\n+INSERT INTO table_function_dictionary_source_table VALUES (0, 0);\n+INSERT INTO table_function_dictionary_source_table VALUES (1, 1);\n+\n+DROP DICTIONARY IF EXISTS table_function_dictionary_test_dictionary;\n+CREATE DICTIONARY table_function_dictionary_test_dictionary\n+(\n+   id UInt64,\n+   value UInt64 DEFAULT 0\n+)\n+PRIMARY KEY id\n+SOURCE(CLICKHOUSE(HOST 'localhost' PORT tcpPort() USER 'default' TABLE 'table_function_dictionary_source_table'))\n+LAYOUT(DIRECT());\n+\n+SELECT * FROM dictionary('table_function_dictionary_test_dictionary');\n+\n+DROP TABLE table_function_dictionary_source_table;\n+DROP DICTIONARY table_function_dictionary_test_dictionary;\n",
  "problem_statement": "FR: Table function dictionary\n### Table function: dictionary\r\n\r\nmotivation: Provide an easy way to inspect dictionaries.\r\n\r\nuse case:  `select * from dictionary(dict)`.\r\n\r\nIt shall behave similar to the following:\r\n```\r\ncreate table xxx (<dictionary_column_definition>) engine Dictionary(dict);\r\nselect * from xxx;\r\ndrop table xxx;\r\n```\r\n\n",
  "hints_text": "cc @kitaisreal \nActually it's useful only for dictionaries created from XML and only if you did not create the Dictionary database:\r\n```\r\nCREATE DATABASE dictionaries ENGINE = Dictionary\r\n```\r\n\r\nBut may be still worth doing.",
  "created_at": "2021-03-19T12:50:27Z"
}