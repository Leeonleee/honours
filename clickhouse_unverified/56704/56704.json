{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 56704,
  "instance_id": "ClickHouse__ClickHouse-56704",
  "issue_numbers": [
    "56673",
    "56672"
  ],
  "base_commit": "4b7c80d824e5bea152bf612b3867b5ddc79d55d4",
  "patch": "diff --git a/src/Compression/CompressionCodecDelta.cpp b/src/Compression/CompressionCodecDelta.cpp\nindex 113535489ac3..924cdd9a60ff 100644\n--- a/src/Compression/CompressionCodecDelta.cpp\n+++ b/src/Compression/CompressionCodecDelta.cpp\n@@ -66,7 +66,7 @@ template <typename T>\n void compressDataForType(const char * source, UInt32 source_size, char * dest)\n {\n     if (source_size % sizeof(T) != 0)\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot delta compress, data size {} is not aligned to {}\", source_size, sizeof(T));\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with Delta codec, data size {} is not aligned to {}\", source_size, sizeof(T));\n \n     T prev_src = 0;\n     const char * const source_end = source + source_size;\n@@ -87,7 +87,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest,\n     const char * const output_end = dest + output_size;\n \n     if (source_size % sizeof(T) != 0)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot delta decompress, data size {} is not aligned to {}\", source_size, sizeof(T));\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Delta-encoded data, data size {} is not aligned to {}\", source_size, sizeof(T));\n \n     T accumulator{};\n     const char * const source_end = source + source_size;\n@@ -95,7 +95,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest,\n     {\n         accumulator += unalignedLoadLittleEndian<T>(source);\n         if (dest + sizeof(accumulator) > output_end) [[unlikely]]\n-            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress delta-encoded data\");\n         unalignedStoreLittleEndian<T>(dest, accumulator);\n \n         source += sizeof(T);\n@@ -133,7 +133,7 @@ UInt32 CompressionCodecDelta::doCompressData(const char * source, UInt32 source_\n void CompressionCodecDelta::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const\n {\n     if (source_size < 2)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress delta-encoded data. File has wrong header\");\n \n     if (uncompressed_size == 0)\n         return;\n@@ -141,13 +141,13 @@ void CompressionCodecDelta::doDecompressData(const char * source, UInt32 source_\n     UInt8 bytes_size = source[0];\n \n     if (!(bytes_size == 1 || bytes_size == 2 || bytes_size == 4 || bytes_size == 8))\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress delta-encoded data. File has wrong header\");\n \n     UInt8 bytes_to_skip = uncompressed_size % bytes_size;\n     UInt32 output_size = uncompressed_size - bytes_to_skip;\n \n     if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress delta-encoded data. File has wrong header\");\n \n     memcpy(dest, &source[2], bytes_to_skip);\n     UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\ndiff --git a/src/Compression/CompressionCodecDoubleDelta.cpp b/src/Compression/CompressionCodecDoubleDelta.cpp\nindex 60e81bbb640b..99089ed6770c 100644\n--- a/src/Compression/CompressionCodecDoubleDelta.cpp\n+++ b/src/Compression/CompressionCodecDoubleDelta.cpp\n@@ -287,7 +287,7 @@ UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest)\n     using SignedDeltaType = typename std::make_signed_t<UnsignedDeltaType>;\n \n     if (source_size % sizeof(ValueType) != 0)\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress, data size {} is not aligned to {}\",\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with DoubleDelta codec, data size {} is not aligned to {}\",\n                         source_size, sizeof(ValueType));\n     const char * source_end = source + source_size;\n     const char * dest_start = dest;\n@@ -381,7 +381,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest,\n \n     prev_value = unalignedLoadLittleEndian<ValueType>(source);\n     if (dest + sizeof(prev_value) > output_end)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress double-delta-encoded data\");\n     unalignedStoreLittleEndian<ValueType>(dest, prev_value);\n \n     source += sizeof(prev_value);\n@@ -394,7 +394,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest,\n     prev_delta = unalignedLoadLittleEndian<UnsignedDeltaType>(source);\n     prev_value = prev_value + static_cast<ValueType>(prev_delta);\n     if (dest + sizeof(prev_value) > output_end)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress double-delta-encoded data\");\n     unalignedStoreLittleEndian<ValueType>(dest, prev_value);\n \n     source += sizeof(prev_delta);\n@@ -427,7 +427,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest,\n         const UnsignedDeltaType delta = double_delta + prev_delta;\n         const ValueType curr_value = prev_value + delta;\n         if (dest + sizeof(curr_value) > output_end)\n-            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress double-delta-encoded data\");\n         unalignedStoreLittleEndian<ValueType>(dest, curr_value);\n         dest += sizeof(curr_value);\n \n@@ -511,18 +511,18 @@ UInt32 CompressionCodecDoubleDelta::doCompressData(const char * source, UInt32 s\n void CompressionCodecDoubleDelta::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const\n {\n     if (source_size < 2)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress double-delta encoded data. File has wrong header\");\n \n     UInt8 bytes_size = source[0];\n \n     if (bytes_size == 0)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress double-delta encoded data. File has wrong header\");\n \n     UInt8 bytes_to_skip = uncompressed_size % bytes_size;\n     UInt32 output_size = uncompressed_size - bytes_to_skip;\n \n     if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress double-delta encoded data. File has wrong header\");\n \n     memcpy(dest, &source[2], bytes_to_skip);\n     UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\ndiff --git a/src/Compression/CompressionCodecFPC.cpp b/src/Compression/CompressionCodecFPC.cpp\nindex 506093bbe49c..81a27e30cd82 100644\n--- a/src/Compression/CompressionCodecFPC.cpp\n+++ b/src/Compression/CompressionCodecFPC.cpp\n@@ -475,19 +475,19 @@ UInt32 CompressionCodecFPC::doCompressData(const char * source, UInt32 source_si\n         default:\n             break;\n     }\n-    throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress. File has incorrect float width\");\n+    throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with FPC codec. File has incorrect float width\");\n }\n \n void CompressionCodecFPC::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const\n {\n     if (source_size < HEADER_SIZE)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress FPC-encoded data. File has wrong header\");\n \n     auto compressed_data = std::as_bytes(std::span(source, source_size));\n     auto compressed_float_width = std::to_integer<UInt8>(compressed_data[0]);\n     auto compressed_level = std::to_integer<UInt8>(compressed_data[1]);\n     if (compressed_level == 0 || compressed_level > MAX_COMPRESSION_LEVEL)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has incorrect level\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress FPC-encoded data. File has incorrect level\");\n \n     auto destination = std::as_writable_bytes(std::span(dest, uncompressed_size));\n     auto src = compressed_data.subspan(HEADER_SIZE);\n@@ -500,7 +500,7 @@ void CompressionCodecFPC::doDecompressData(const char * source, UInt32 source_si\n             FPCOperation<UInt32>(destination, compressed_level).decode(src, uncompressed_size);\n             break;\n         default:\n-            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has incorrect float width\");\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress FPC-encoded data. File has incorrect float width\");\n     }\n }\n \ndiff --git a/src/Compression/CompressionCodecGCD.cpp b/src/Compression/CompressionCodecGCD.cpp\nindex d51e75067a16..8b923d61650d 100644\n--- a/src/Compression/CompressionCodecGCD.cpp\n+++ b/src/Compression/CompressionCodecGCD.cpp\n@@ -1,10 +1,10 @@\n #include <Compression/ICompressionCodec.h>\n-#include <Compression/CompressionInfo.h>\n+#include <Common/Exception.h>\n #include <Compression/CompressionFactory.h>\n-#include <base/unaligned.h>\n+#include <Compression/CompressionInfo.h>\n+#include <DataTypes/IDataType.h>\n #include <Parsers/IAST.h>\n-#include \"Common/Exception.h\"\n-#include \"DataTypes/IDataType.h\"\n+#include <base/unaligned.h>\n \n #include <boost/integer/common_factor.hpp>\n #include <libdivide-config.h>\n@@ -74,29 +74,37 @@ template <typename T>\n void compressDataForType(const char * source, UInt32 source_size, char * dest)\n {\n     if (source_size % sizeof(T) != 0)\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot GCD compress, data size {} is not aligned to {}\", source_size, sizeof(T));\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with GCD codec, data size {} is not aligned to {}\", source_size, sizeof(T));\n \n     const char * const source_end = source + source_size;\n \n-    T gcd_divider = 0;\n+    T gcd = 0;\n     const auto * cur_source = source;\n-    while (gcd_divider != T(1) && cur_source < source_end)\n+    while (gcd != T(1) && cur_source < source_end)\n     {\n         if (cur_source == source)\n-            gcd_divider = unalignedLoad<T>(cur_source);\n+            gcd = unalignedLoad<T>(cur_source);\n         else\n-            gcd_divider = boost::integer::gcd(gcd_divider, unalignedLoad<T>(cur_source));\n+            gcd = boost::integer::gcd(gcd, unalignedLoad<T>(cur_source));\n         cur_source += sizeof(T);\n     }\n \n-    unalignedStore<T>(dest, gcd_divider);\n+    unalignedStore<T>(dest, gcd);\n     dest += sizeof(T);\n \n+    /// GCD compression is pointless if GCD = 1 or GCD = 0 (happens with 0 values in data).\n+    /// In these cases only copy the source to dest, i.e. don't compress.\n+    if (gcd == 0 || gcd == 1)\n+    {\n+        memcpy(dest, source, source_size);\n+        return;\n+    }\n+\n     if constexpr (sizeof(T) <= 8)\n     {\n         /// libdivide supports only UInt32 and UInt64.\n         using LibdivideT = std::conditional_t<sizeof(T) <= 4, UInt32, UInt64>;\n-        libdivide::divider<LibdivideT> divider(static_cast<LibdivideT>(gcd_divider));\n+        libdivide::divider<LibdivideT> divider(static_cast<LibdivideT>(gcd));\n         cur_source = source;\n         while (cur_source < source_end)\n         {\n@@ -110,7 +118,7 @@ void compressDataForType(const char * source, UInt32 source_size, char * dest)\n         cur_source = source;\n         while (cur_source < source_end)\n         {\n-            unalignedStore<T>(dest, unalignedLoad<T>(cur_source) / gcd_divider);\n+            unalignedStore<T>(dest, unalignedLoad<T>(cur_source) / gcd);\n             cur_source += sizeof(T);\n             dest += sizeof(T);\n         }\n@@ -121,10 +129,10 @@ template <typename T>\n void decompressDataForType(const char * source, UInt32 source_size, char * dest, UInt32 output_size)\n {\n     if (source_size % sizeof(T) != 0)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot GCD decompress, data size {} is not aligned to {}\", source_size, sizeof(T));\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data, data size {} is not aligned to {}\", source_size, sizeof(T));\n \n     if (source_size < sizeof(T))\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot GCD decompress, data size {} is less than {}\", source_size, sizeof(T));\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data, data size {} is less than {}\", source_size, sizeof(T));\n \n     const char * const source_end = source + source_size;\n     const char * const dest_end = dest + output_size;\n@@ -132,10 +140,21 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest,\n     const T gcd_multiplier = unalignedLoad<T>(source);\n     source += sizeof(T);\n \n+    /// Handle special cases GCD = 1 and GCD = 0.\n+    if (gcd_multiplier == 0 || gcd_multiplier == 1)\n+    {\n+        /// Subtraction is safe, because we checked that source_size >= sizeof(T)\n+        if (source_size - sizeof(T) != output_size)\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data\");\n+\n+        memcpy(dest, source, source_size);\n+        return;\n+    }\n+\n     while (source < source_end)\n     {\n         if (dest + sizeof(T) > dest_end) [[unlikely]]\n-            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress the data\");\n+            throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data\");\n         unalignedStore<T>(dest, unalignedLoad<T>(source) * gcd_multiplier);\n \n         source += sizeof(T);\n@@ -179,7 +198,7 @@ UInt32 CompressionCodecGCD::doCompressData(const char * source, UInt32 source_si\n void CompressionCodecGCD::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const\n {\n     if (source_size < 2)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data. File has wrong header\");\n \n     if (uncompressed_size == 0)\n         return;\n@@ -187,13 +206,13 @@ void CompressionCodecGCD::doDecompressData(const char * source, UInt32 source_si\n     UInt8 bytes_size = source[0];\n \n     if (!(bytes_size == 1 || bytes_size == 2 || bytes_size == 4 || bytes_size == 8 || bytes_size == 16 || bytes_size == 32))\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data. File has wrong header\");\n \n     UInt8 bytes_to_skip = uncompressed_size % bytes_size;\n     UInt32 output_size = uncompressed_size - bytes_to_skip;\n \n     if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress GCD-encoded data. File has wrong header\");\n \n     memcpy(dest, &source[2], bytes_to_skip);\n     UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\n@@ -227,7 +246,7 @@ UInt8 getGCDBytesSize(const IDataType * column_type)\n {\n     WhichDataType which(column_type);\n     if (!(which.isInt() || which.isUInt() || which.isDecimal() || which.isDateOrDate32() || which.isDateTime() ||which.isDateTime64()))\n-        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD is not applicable for {} because the data type is not of fixed size\",\n+        throw Exception(ErrorCodes::BAD_ARGUMENTS, \"Codec GCD cannot be applied to column {} because it can only be used with Int*, UInt*, Decimal*, Date* or DateTime* types.\",\n             column_type->getName());\n \n     size_t max_size = column_type->getSizeOfValueInMemory();\ndiff --git a/src/Compression/CompressionCodecGorilla.cpp b/src/Compression/CompressionCodecGorilla.cpp\nindex 7e36a424f03d..a41a3d1fe8eb 100644\n--- a/src/Compression/CompressionCodecGorilla.cpp\n+++ b/src/Compression/CompressionCodecGorilla.cpp\n@@ -197,7 +197,7 @@ template <typename T>\n UInt32 compressDataForType(const char * source, UInt32 source_size, char * dest, UInt32 dest_size)\n {\n     if (source_size % sizeof(T) != 0)\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress, data size {} is not aligned to {}\", source_size, sizeof(T));\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with Gorilla codec, data size {} is not aligned to {}\", source_size, sizeof(T));\n \n     const char * const source_end = source + source_size;\n     const char * const dest_start = dest;\n@@ -317,7 +317,7 @@ void decompressDataForType(const char * source, UInt32 source_size, char * dest)\n                 && curr_xored_info.data_bits == 0\n                 && curr_xored_info.trailing_zero_bits == 0) [[unlikely]]\n             {\n-                throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress gorilla-encoded data: corrupted input data.\");\n+                throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded data: corrupted input data.\");\n             }\n \n             xored_data = static_cast<T>(reader.readBits(curr_xored_info.data_bits));\n@@ -410,17 +410,17 @@ UInt32 CompressionCodecGorilla::doCompressData(const char * source, UInt32 sourc\n void CompressionCodecGorilla::doDecompressData(const char * source, UInt32 source_size, char * dest, UInt32 uncompressed_size) const\n {\n     if (source_size < 2)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded data. File has wrong header\");\n \n     UInt8 bytes_size = source[0];\n \n     if (bytes_size == 0)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded data. File has wrong header\");\n \n     UInt8 bytes_to_skip = uncompressed_size % bytes_size;\n \n     if (static_cast<UInt32>(2 + bytes_to_skip) > source_size)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress. File has wrong header\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress Gorilla-encoded data. File has wrong header\");\n \n     memcpy(dest, &source[2], bytes_to_skip);\n     UInt32 source_size_no_header = source_size - bytes_to_skip - 2;\ndiff --git a/src/Compression/CompressionCodecLZ4.cpp b/src/Compression/CompressionCodecLZ4.cpp\nindex ae739ab4e6b4..597c1ba3acbe 100644\n--- a/src/Compression/CompressionCodecLZ4.cpp\n+++ b/src/Compression/CompressionCodecLZ4.cpp\n@@ -96,7 +96,7 @@ void CompressionCodecLZ4::doDecompressData(const char * source, UInt32 source_si\n     bool success = LZ4::decompress(source, dest, source_size, uncompressed_size, lz4_stat);\n \n     if (!success)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress LZ4-encoded data\");\n }\n \n void registerCodecLZ4(CompressionCodecFactory & factory)\n@@ -112,7 +112,7 @@ UInt32 CompressionCodecLZ4HC::doCompressData(const char * source, UInt32 source_\n     auto success = LZ4_compress_HC(source, dest, source_size, LZ4_COMPRESSBOUND(source_size), level);\n \n     if (!success)\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot LZ4_compress_HC\");\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with LZ4 codec\");\n \n     return success;\n }\ndiff --git a/src/Compression/CompressionCodecT64.cpp b/src/Compression/CompressionCodecT64.cpp\nindex ec7922a030d4..bf9a9414bc17 100644\n--- a/src/Compression/CompressionCodecT64.cpp\n+++ b/src/Compression/CompressionCodecT64.cpp\n@@ -483,7 +483,7 @@ UInt32 compressData(const char * src, UInt32 bytes_size, char * dst)\n     static constexpr const UInt32 header_size = 2 * sizeof(UInt64);\n \n     if (bytes_size % sizeof(T))\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress, data size {} is not multiplier of {}\",\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with T64 codec, data size {} is not multiplier of {}\",\n                         bytes_size, sizeof(T));\n \n     UInt32 src_size = bytes_size / sizeof(T);\n@@ -538,11 +538,11 @@ void decompressData(const char * src, UInt32 bytes_size, char * dst, UInt32 unco\n     static constexpr const UInt32 header_size = 2 * sizeof(UInt64);\n \n     if (bytes_size < header_size)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress, data size ({}) is less than the size of T64 header\",\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress T64-encoded data, data size ({}) is less than the size of T64 header\",\n                         bytes_size);\n \n     if (uncompressed_size % sizeof(T))\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress, unexpected uncompressed size ({})\"\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress T64-encoded data, unexpected uncompressed size ({})\"\n                         \" isn't a multiple of the data type size ({})\",\n                         uncompressed_size, sizeof(T));\n \n@@ -571,7 +571,7 @@ void decompressData(const char * src, UInt32 bytes_size, char * dst, UInt32 unco\n     UInt32 dst_shift = sizeof(T) * matrix_size;\n \n     if (!bytes_size || bytes_size % src_shift)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress, data size ({}) is not a multiplier of {}\",\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress T64-encoded data, data size ({}) is not a multiplier of {}\",\n                         bytes_size, src_shift);\n \n     UInt32 num_full = bytes_size / src_shift;\n@@ -666,13 +666,13 @@ UInt32 CompressionCodecT64::doCompressData(const char * src, UInt32 src_size, ch\n             break;\n     }\n \n-    throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with T64\");\n+    throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with T64 codec\");\n }\n \n void CompressionCodecT64::doDecompressData(const char * src, UInt32 src_size, char * dst, UInt32 uncompressed_size) const\n {\n     if (!src_size)\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress with T64\");\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress T64-encoded data\");\n \n     UInt8 cookie = unalignedLoad<UInt8>(src);\n     src += 1;\n@@ -703,7 +703,7 @@ void CompressionCodecT64::doDecompressData(const char * src, UInt32 src_size, ch\n             break;\n     }\n \n-    throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress with T64\");\n+    throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress T64-encoded data\");\n }\n \n uint8_t CompressionCodecT64::getMethodByte() const\ndiff --git a/src/Compression/CompressionCodecZSTD.cpp b/src/Compression/CompressionCodecZSTD.cpp\nindex 891f1acaa9ac..ec37ec6a7b54 100644\n--- a/src/Compression/CompressionCodecZSTD.cpp\n+++ b/src/Compression/CompressionCodecZSTD.cpp\n@@ -82,7 +82,7 @@ UInt32 CompressionCodecZSTD::doCompressData(const char * source, UInt32 source_s\n     ZSTD_freeCCtx(cctx);\n \n     if (ZSTD_isError(compressed_size))\n-        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress block with ZSTD: {}\", std::string(ZSTD_getErrorName(compressed_size)));\n+        throw Exception(ErrorCodes::CANNOT_COMPRESS, \"Cannot compress with ZSTD codec: {}\", std::string(ZSTD_getErrorName(compressed_size)));\n \n     return static_cast<UInt32>(compressed_size);\n }\n@@ -93,7 +93,7 @@ void CompressionCodecZSTD::doDecompressData(const char * source, UInt32 source_s\n     size_t res = ZSTD_decompress(dest, uncompressed_size, source, source_size);\n \n     if (ZSTD_isError(res))\n-        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot ZSTD_decompress: {}\", std::string(ZSTD_getErrorName(res)));\n+        throw Exception(ErrorCodes::CANNOT_DECOMPRESS, \"Cannot decompress ZSTD-encoded data: {}\", std::string(ZSTD_getErrorName(res)));\n }\n \n CompressionCodecZSTD::CompressionCodecZSTD(int level_, int window_log_) : level(level_), enable_long_range(true), window_log(window_log_)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02869_gcd_codec_test_incorrect_type.reference b/tests/queries/0_stateless/02869_gcd_codec_test_incorrect_type.reference\ndeleted file mode 100644\nindex e69de29bb2d1..000000000000\ndiff --git a/tests/queries/0_stateless/02869_gcd_codec_test_incorrect_type.sql b/tests/queries/0_stateless/02869_gcd_codec_test_incorrect_type.sql\ndeleted file mode 100644\nindex 61a964a288f3..000000000000\n--- a/tests/queries/0_stateless/02869_gcd_codec_test_incorrect_type.sql\n+++ /dev/null\n@@ -1,2 +0,0 @@\n-DROP TABLE IF EXISTS table_gcd_codec;\n-CREATE TABLE table_gcd_codec (str String CODEC(GCD, LZ4)) ENGINE = Memory; -- { serverError 36 }\ndiff --git a/tests/queries/0_stateless/02872_gcd_codec.reference b/tests/queries/0_stateless/02872_gcd_codec.reference\nindex 1dd1b67e047d..a8224b85b3c2 100644\n--- a/tests/queries/0_stateless/02872_gcd_codec.reference\n+++ b/tests/queries/0_stateless/02872_gcd_codec.reference\n@@ -1002,3 +1002,203 @@\n 0\n 0\n 0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+0\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02872_gcd_codec.sql b/tests/queries/0_stateless/02872_gcd_codec.sql\nindex 245a1211052e..3020bbc44acd 100644\n--- a/tests/queries/0_stateless/02872_gcd_codec.sql\n+++ b/tests/queries/0_stateless/02872_gcd_codec.sql\n@@ -103,8 +103,24 @@ SELECT * FROM table_gcd_codec_datetime;\n SELECT * FROM table_gcd_codec_datetime64;\n \n \n--- A column with all 0 values can be compressed/decompressed\n+-- A column with all zero values can be compressed/decompressed\n \n-CREATE TEMPORARY TABLE table_gcd_codec_only_zero_values (n UInt8 CODEC(GCD, LZ4)) ENGINE = Memory;\n-INSERT INTO table_gcd_codec_only_zero_values VALUES (0), (0), (0);\n-SELECT * FROM table_gcd_codec_only_zero_values;\n+CREATE TEMPORARY TABLE table_gcd_codec_only_zeros (n UInt8 CODEC(GCD, LZ4)) ENGINE = Memory;\n+INSERT INTO table_gcd_codec_only_zeros VALUES (0), (0), (0);\n+SELECT * FROM table_gcd_codec_only_zeros;\n+\n+-- Tests for Bug #56672:\n+\n+DROP TABLE IF EXISTS table_gcd_codec_one_hundred_zeros;\n+DROP TABLE IF EXISTS table_gcd_codec_one_hundred_ones;\n+\n+CREATE TABLE table_gcd_codec_one_hundred_zeros (a Nullable(Int64) CODEC (GCD,LZ4)) ENGINE=MergeTree ORDER BY ();\n+INSERT INTO table_gcd_codec_one_hundred_zeros SELECT 0 FROM numbers(100);\n+SELECT * FROM table_gcd_codec_one_hundred_zeros;\n+\n+CREATE TABLE table_gcd_codec_one_hundred_ones (a Nullable(Int64) CODEC (GCD,LZ4)) ENGINE=MergeTree Order by ();\n+INSERT INTO table_gcd_codec_one_hundred_ones SELECT 1 FROM numbers(100);\n+SELECT * FROM table_gcd_codec_one_hundred_ones;\n+\n+DROP TABLE table_gcd_codec_one_hundred_zeros;\n+DROP TABLE table_gcd_codec_one_hundred_ones;\n",
  "problem_statement": "Misleading message about GCD codec \"data type is not of fixed size\"\n```sql\r\nCREATE TABLE t (a Float64 CODEC (GCD,LZ4)) ENGINE=MergeTree Order by ();\r\nDB::Exception: Codec GCD is not applicable for Float64 because the data type is not of fixed size. (BAD_ARGUMENTS)\r\n\r\n\r\nCREATE TABLE t (a FixedString(8) CODEC (GCD,LZ4)) ENGINE=MergeTree Order by ();\r\nDB::Exception: Codec GCD is not applicable for Float64 because the data type is not of fixed size. (BAD_ARGUMENTS)\r\n\r\n```\nCrash with GCD Codec\n```sql\r\nCREATE TABLE t (a Nullable(Int64) CODEC (GCD,LZ4)) ENGINE=MergeTree Order by ();\r\n\r\ninsert into t select 0 from numbers(1e2);\r\n\r\n<Fatal> BaseDaemon: ########################################\r\n```\r\n\r\nhttps://fiddle.clickhouse.com/fa623199-a461-498a-92b5-c9c929c93c57\n",
  "hints_text": "\none more crash\r\n\r\n```\r\nCREATE TABLE hits_v1\r\n(\r\n    `WatchID` UInt64 CODEC (GCD,LZ4),\r\n    `JavaEnable` UInt8 CODEC (GCD,LZ4),\r\n    `Title` String,\r\n    `GoodEvent` Int16 CODEC (GCD,LZ4),\r\n    `EventTime` DateTime CODEC (GCD,LZ4),\r\n    `EventDate` Date CODEC (GCD,LZ4),\r\n    `CounterID` UInt32 CODEC (GCD,LZ4),\r\n    `ClientIP` UInt32 CODEC (GCD,LZ4),\r\n    `ClientIP6` FixedString(16),\r\n    `RegionID` UInt32 CODEC (GCD,LZ4),\r\n    `UserID` UInt64 CODEC (GCD,LZ4),\r\n    `CounterClass` Int8,\r\n    `OS` UInt8 CODEC (GCD,LZ4),\r\n    `UserAgent` UInt8 CODEC (GCD,LZ4),\r\n    `URL` String,\r\n    `Referer` String,\r\n    `URLDomain` String,\r\n    `RefererDomain` String,\r\n    `Refresh` UInt8 CODEC (GCD,LZ4),\r\n    `IsRobot` UInt8 CODEC (GCD,LZ4),\r\n    `RefererCategories` Array(UInt16) CODEC (GCD,LZ4),\r\n    `URLCategories` Array(UInt16) CODEC (GCD,LZ4),\r\n    `URLRegions` Array(UInt32) CODEC (GCD,LZ4),\r\n    `RefererRegions` Array(UInt32) CODEC (GCD,LZ4),\r\n    `ResolutionWidth` UInt16 CODEC (GCD,LZ4),\r\n    `ResolutionHeight` UInt16 CODEC (GCD,LZ4),\r\n    `ResolutionDepth` UInt8 CODEC (GCD,LZ4),\r\n    `FlashMajor` UInt8 CODEC (GCD,LZ4),\r\n    `FlashMinor` UInt8 CODEC (GCD,LZ4),\r\n    `FlashMinor2` String,\r\n    `NetMajor` UInt8 CODEC (GCD,LZ4),\r\n    `NetMinor` UInt8 CODEC (GCD,LZ4),\r\n    `UserAgentMajor` UInt16 CODEC (GCD,LZ4),\r\n    `UserAgentMinor` FixedString(2),\r\n    `CookieEnable` UInt8 CODEC (GCD,LZ4),\r\n    `JavascriptEnable` UInt8 CODEC (GCD,LZ4),\r\n    `IsMobile` UInt8 CODEC (GCD,LZ4),\r\n    `MobilePhone` UInt8 CODEC (GCD,LZ4),\r\n    `MobilePhoneModel` String,\r\n    `Params` String,\r\n    `IPNetworkID` UInt32 CODEC (GCD,LZ4),\r\n    `TraficSourceID` Int8,\r\n    `SearchEngineID` UInt16 CODEC (GCD,LZ4),\r\n    `SearchPhrase` String,\r\n    `AdvEngineID` UInt8 CODEC (GCD,LZ4),\r\n    `IsArtifical` UInt8 CODEC (GCD,LZ4),\r\n    `WindowClientWidth` UInt16 CODEC (GCD,LZ4),\r\n    `WindowClientHeight` UInt16 CODEC (GCD,LZ4),\r\n    `ClientTimeZone` Int16 CODEC (GCD,LZ4),\r\n    `ClientEventTime` DateTime CODEC (GCD,LZ4),\r\n    `SilverlightVersion1` UInt8 CODEC (GCD,LZ4),\r\n    `SilverlightVersion2` UInt8 CODEC (GCD,LZ4),\r\n    `SilverlightVersion3` UInt32 CODEC (GCD,LZ4),\r\n    `SilverlightVersion4` UInt16 CODEC (GCD,LZ4),\r\n    `PageCharset` String,\r\n    `CodeVersion` UInt32 CODEC (GCD,LZ4),\r\n    `IsLink` UInt8 CODEC (GCD,LZ4),\r\n    `IsDownload` UInt8 CODEC (GCD,LZ4),\r\n    `IsNotBounce` UInt8 CODEC (GCD,LZ4),\r\n    `FUniqID` UInt64 CODEC (GCD,LZ4),\r\n    `HID` UInt32 CODEC (GCD,LZ4),\r\n    `IsOldCounter` UInt8 CODEC (GCD,LZ4),\r\n    `IsEvent` UInt8 CODEC (GCD,LZ4),\r\n    `IsParameter` UInt8 CODEC (GCD,LZ4),\r\n    `DontCountHits` UInt8 CODEC (GCD,LZ4),\r\n    `WithHash` UInt8 CODEC (GCD,LZ4),\r\n    `HitColor` FixedString(1),\r\n    `UTCEventTime` DateTime CODEC (GCD,LZ4),\r\n    `Age` UInt8 CODEC (GCD,LZ4),\r\n    `Sex` UInt8 CODEC (GCD,LZ4),\r\n    `Income` UInt8 CODEC (GCD,LZ4),\r\n    `Interests` UInt16 CODEC (GCD,LZ4),\r\n    `Robotness` UInt8 CODEC (GCD,LZ4),\r\n    `GeneralInterests` Array(UInt16) CODEC (GCD,LZ4),\r\n    `RemoteIP` UInt32 CODEC (GCD,LZ4),\r\n    `RemoteIP6` FixedString(16),\r\n    `WindowName` Int32,\r\n    `OpenerName` Int32,\r\n    `HistoryLength` Int16 CODEC (GCD,LZ4),\r\n    `BrowserLanguage` FixedString(2),\r\n    `BrowserCountry` FixedString(2),\r\n    `SocialNetwork` String,\r\n    `SocialAction` String,\r\n    `HTTPError` UInt16 CODEC (GCD,LZ4),\r\n    `SendTiming` Int32,\r\n    `DNSTiming` Int32,\r\n    `ConnectTiming` Int32,\r\n    `ResponseStartTiming` Int32,\r\n    `ResponseEndTiming` Int32,\r\n    `FetchTiming` Int32,\r\n    `RedirectTiming` Int32,\r\n    `DOMInteractiveTiming` Int32,\r\n    `DOMContentLoadedTiming` Int32,\r\n    `DOMCompleteTiming` Int32,\r\n    `LoadEventStartTiming` Int32,\r\n    `LoadEventEndTiming` Int32,\r\n    `NSToDOMContentLoadedTiming` Int32,\r\n    `FirstPaintTiming` Int32,\r\n    `RedirectCount` Int8,\r\n    `SocialSourceNetworkID` UInt8 CODEC (GCD,LZ4),\r\n    `SocialSourcePage` String,\r\n    `ParamPrice` Int64,\r\n    `ParamOrderID` String,\r\n    `ParamCurrency` FixedString(3),\r\n    `ParamCurrencyID` UInt16 CODEC (GCD,LZ4),\r\n    `GoalsReached` Array(UInt32) CODEC (GCD,LZ4),\r\n    `OpenstatServiceName` String,\r\n    `OpenstatCampaignID` String,\r\n    `OpenstatAdID` String,\r\n    `OpenstatSourceID` String,\r\n    `UTMSource` String,\r\n    `UTMMedium` String,\r\n    `UTMCampaign` String,\r\n    `UTMContent` String,\r\n    `UTMTerm` String,\r\n    `FromTag` String,\r\n    `HasGCLID` UInt8 CODEC (GCD,LZ4),\r\n    `RefererHash` UInt64 CODEC (GCD,LZ4),\r\n    `URLHash` UInt64 CODEC (GCD,LZ4),\r\n    `CLID` UInt32 CODEC (GCD,LZ4),\r\n    `YCLID` UInt64 CODEC (GCD,LZ4),\r\n    `ShareService` String,\r\n    `ShareURL` String,\r\n    `ShareTitle` String,\r\n    `ParsedParams` Nested(Key1 String, Key2 String, Key3 String, Key4 String, Key5 String, ValueDouble Float64),\r\n    `IslandID` FixedString(16),\r\n    `RequestNum` UInt32 CODEC (GCD,LZ4),\r\n    `RequestTry` UInt8 CODEC (GCD,LZ4)\r\n)\r\nENGINE = MergeTree\r\nPARTITION BY toYYYYMM(EventDate)\r\nORDER BY (CounterID, EventDate, intHash32(UserID))\r\nSAMPLE BY intHash32(UserID)\r\nSETTINGS index_granularity = 8192\r\n```\r\n\r\n```bash\r\nclickhouse-client -q 'insert into hits_v1 format TSV' < hits_v1.tsv\r\n\r\nCode: 209. DB::NetException: Timeout exceeded while writing to socket (127.0.0.1:9000, 300000 ms): data for INSERT was parsed from stdin: (in query: insert into hits_v1 format TSV). (SOCKET_TIMEOUT)\r\n\r\n\r\n2023.11.13 14:20:45.209084 [ 173020 ] {} <Trace> BaseDaemon: Received signal 6\r\n2023.11.13 14:20:45.209314 [ 267535 ] {} <Fatal> BaseDaemon: ########## Short fault info ############\r\n2023.11.13 14:20:45.209350 [ 267535 ] {} <Fatal> BaseDaemon: (version 23.11.1.166, build id: 010F5A9365843031EC185194CA7AA02C1E4911C2, git hash: 1598d76539a6132cbfb22940a468eba19038ec15) (from thread 173021) Received signal 6\r\n2023.11.13 14:20:45.209377 [ 267535 ] {} <Fatal> BaseDaemon: Signal description: Aborted\r\n2023.11.13 14:20:45.209384 [ 267535 ] {} <Fatal> BaseDaemon:\r\n2023.11.13 14:20:45.209403 [ 267535 ] {} <Fatal> BaseDaemon: Stack trace: 0x0000ffff86208d78 0x0000ffff861f5aac 0x0000aaaac68903a4 0x0000aaaac6857af8 0x0000aaaac684b454 0x0000aaaac7e43958 0x0000aaaac7f96770 0x0000aaaac6993e68 0x0000aaaa\r\nc6994250 0x0000aaaac7f92968 0x0000aaaac7f914e4 0x0000aaaac7f8fea0 0x0000aaaac80a270c 0x0000aaaac80cd98c 0x0000aaaac81cc4b8 0x0000aaaac8695d84 0x0000aaaac85e9f2c 0x0000aaaac85e9c70 0x0000aaaac85e93e8 0x0000aaaac83b02ec 0x0000aaaac83a85f4\r\n 0x0000aaaac83a8114 0x0000aaaac83b8380 0x0000aaaac8354ce4 0x0000aaaac8362008 0x0000aaaaca86f044 0x0000aaaaca870560 0x0000aaaaca9afd7c 0x0000aaaaca9adf24 0x0000ffff8634f624 0x0000ffff862a649c\r\n2023.11.13 14:20:45.209412 [ 267535 ] {} <Fatal> BaseDaemon: ########################################\r\n2023.11.13 14:20:45.209461 [ 267535 ] {} <Fatal> BaseDaemon: (version 23.11.1.166, build id: 010F5A9365843031EC185194CA7AA02C1E4911C2, git hash: 1598d76539a6132cbfb22940a468eba19038ec15) (from thread 173021) (query_id: 29892e65-c13d-47b\r\nf-9edb-cb728f2d4530) (query: insert into hits_v1 format TSV) Received signal Aborted (6)\r\n2023.11.13 14:20:45.209482 [ 267535 ] {} <Fatal> BaseDaemon:\r\n2023.11.13 14:20:45.209496 [ 267535 ] {} <Fatal> BaseDaemon: Stack trace: 0x0000ffff86208d78 0x0000ffff861f5aac 0x0000aaaac68903a4 0x0000aaaac6857af8 0x0000aaaac684b454 0x0000aaaac7e43958 0x0000aaaac7f96770 0x0000aaaac6993e68 0x0000aaaa\r\nc6994250 0x0000aaaac7f92968 0x0000aaaac7f914e4 0x0000aaaac7f8fea0 0x0000aaaac80a270c 0x0000aaaac80cd98c 0x0000aaaac81cc4b8 0x0000aaaac8695d84 0x0000aaaac85e9f2c 0x0000aaaac85e9c70 0x0000aaaac85e93e8 0x0000aaaac83b02ec 0x0000aaaac83a85f4\r\n 0x0000aaaac83a8114 0x0000aaaac83b8380 0x0000aaaac8354ce4 0x0000aaaac8362008 0x0000aaaaca86f044 0x0000aaaaca870560 0x0000aaaaca9afd7c 0x0000aaaaca9adf24 0x0000ffff8634f624 0x0000ffff862a649c\r\n2023.11.13 14:20:45.209550 [ 267535 ] {} <Fatal> BaseDaemon: 2. ? @ 0x0000000000033d78 in /usr/lib/aarch64-linux-gnu/libc-2.31.so\r\n2023.11.13 14:20:45.209569 [ 267535 ] {} <Fatal> BaseDaemon: 3. ? @ 0x0000000000020aac in /usr/lib/aarch64-linux-gnu/libc-2.31.so\r\n2023.11.13 14:20:45.209632 [ 267535 ] {} <Fatal> BaseDaemon: 4. DB::CompressionCodecGCD::doCompressData(char const*, unsigned int, char*) const @ 0x0000000010b403a4 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209660 [ 267535 ] {} <Fatal> BaseDaemon: 5. DB::CompressionCodecMultiple::doCompressData(char const*, unsigned int, char*) const @ 0x0000000010b07af8 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209692 [ 267535 ] {} <Fatal> BaseDaemon: 6. DB::CompressedWriteBuffer::nextImpl() @ 0x0000000010afb454 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209735 [ 267535 ] {} <Fatal> BaseDaemon: 7. DB::HashingWriteBuffer::nextImpl() @ 0x00000000120f3958 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209798 [ 267535 ] {} <Fatal> BaseDaemon: 8. void std::__function::__policy_invoker<void (DB::ISerialization::SubstreamPath const&)>::__call_impl<std::__function::__default_alloc_func<DB::MergeTreeDataPartWriterWide::getCurrentMarksForColumn(DB::NameAndTypePair const&, std::set<String, std::less<String>, std::allocator<String>>&)::$_0, void (DB::ISerialization::SubstreamPath const&)>>(std::__function::__policy_storage const*, DB::ISerialization::SubstreamPath const&) @ 0x0000000012246770 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209836 [ 267535 ] {} <Fatal> BaseDaemon: 9. DB::ISerialization::enumerateStreams(DB::ISerialization::EnumerateStreamsSettings&, std::function<void (DB::ISerialization::SubstreamPath const&)> const&, DB::ISerialization::SubstreamData const&) const @ 0x0000000010c43e68 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209874 [ 267535 ] {} <Fatal> BaseDaemon: 10. DB::ISerialization::enumerateStreams(std::function<void (DB::ISerialization::SubstreamPath const&)> const&, std::shared_ptr<DB::IDataType const> const&, COW<DB::IColumn>::immutable_ptr<DB::IColumn> const&) const @ 0x0000000010c44250 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209919 [ 267535 ] {} <Fatal> BaseDaemon: 11. DB::MergeTreeDataPartWriterWide::getCurrentMarksForColumn(DB::NameAndTypePair const&, std::set<String, std::less<String>, std::allocator<String>>&) @ 0x0000000012242968 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209950 [ 267535 ] {} <Fatal> BaseDaemon: 12. DB::MergeTreeDataPartWriterWide::writeColumn(DB::NameAndTypePair const&, DB::IColumn const&, std::set<String, std::less<String>, std::allocator<String>>&, std::vector<DB::Granule, std::allocator<DB::Granule>> const&) @ 0x00000000122414e4 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.209988 [ 267535 ] {} <Fatal> BaseDaemon: 13. DB::MergeTreeDataPartWriterWide::write(DB::Block const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 63ul, 64ul> const*) @ 0x000000001223fea0 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.210028 [ 267535 ] {} <Fatal> BaseDaemon: 14. DB::MergedBlockOutputStream::writeWithPermutation(DB::Block const&, DB::PODArray<unsigned long, 4096ul, Allocator<false, false>, 63ul, 64ul> const*) @ 0x000000001235270c in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.210068 [ 267535 ] {} <Fatal> BaseDaemon: 15. DB::MergeTreeDataWriter::writeTempPartImpl(DB::BlockWithPartition&, std::shared_ptr<DB::StorageInMemoryMetadata const> const&, std::shared_ptr<DB::Context const>, long, bool) @ 0x000000001237d98c in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.210100 [ 267535 ] {} <Fatal> BaseDaemon: 16. DB::MergeTreeSink::consume(DB::Chunk) @ 0x000000001247c4b8 in /usr/bin/clickhouse\r\n2023.11.13 14:20:45.210133 [ 267535 ] {} <Fatal> BaseDaemon: 17. DB::SinkToStorage::onConsume(DB::Chunk) @ 0x0000000012945d84 in /usr/bin/clickhouse\r\n```",
  "created_at": "2023-11-13T20:51:13Z"
}