diff --git a/programs/format/Format.cpp b/programs/format/Format.cpp
index a434c9171e91..f07387bd3952 100644
--- a/programs/format/Format.cpp
+++ b/programs/format/Format.cpp
@@ -264,7 +264,11 @@ int mainEntryClickHouseFormat(int argc, char ** argv)
                     if (!backslash)
                     {
                         WriteBufferFromOwnString str_buf;
-                        formatAST(*res, str_buf, hilite, oneline || approx_query_length < max_line_length);
+                        bool oneline_current_query = oneline || approx_query_length < max_line_length;
+                        IAST::FormatSettings settings(str_buf, oneline_current_query, hilite);
+                        settings.show_secrets = true;
+                        settings.print_pretty_type_names = !oneline_current_query;
+                        res->format(settings);
 
                         if (insert_query_payload)
                         {
@@ -307,7 +311,11 @@ int mainEntryClickHouseFormat(int argc, char ** argv)
                     else
                     {
                         WriteBufferFromOwnString str_buf;
-                        formatAST(*res, str_buf, hilite, oneline);
+                        bool oneline_current_query = oneline || approx_query_length < max_line_length;
+                        IAST::FormatSettings settings(str_buf, oneline_current_query, hilite);
+                        settings.show_secrets = true;
+                        settings.print_pretty_type_names = !oneline_current_query;
+                        res->format(settings);
 
                         auto res_string = str_buf.str();
                         WriteBufferFromOStream res_cout(std::cout, 4096);
diff --git a/src/Client/ClientBase.cpp b/src/Client/ClientBase.cpp
index 187ef079edab..74357d33f1c4 100644
--- a/src/Client/ClientBase.cpp
+++ b/src/Client/ClientBase.cpp
@@ -331,7 +331,11 @@ ASTPtr ClientBase::parseQuery(const char *& pos, const char * end, const Setting
     {
         output_stream << std::endl;
         WriteBufferFromOStream res_buf(output_stream, 4096);
-        formatAST(*res, res_buf);
+        IAST::FormatSettings format_settings(res_buf, /* one_line */ false);
+        format_settings.hilite = true;
+        format_settings.show_secrets = true;
+        format_settings.print_pretty_type_names = true;
+        res->format(format_settings);
         res_buf.finalize();
         output_stream << std::endl << std::endl;
     }
diff --git a/src/Core/ExternalTable.cpp b/src/Core/ExternalTable.cpp
index c2bcf6ec6516..4ff0d7092d89 100644
--- a/src/Core/ExternalTable.cpp
+++ b/src/Core/ExternalTable.cpp
@@ -85,7 +85,7 @@ void BaseExternalTable::parseStructureFromStructureField(const std::string & arg
         /// We use `formatWithPossiblyHidingSensitiveData` instead of `getColumnNameWithoutAlias` because `column->type` is an ASTFunction.
         /// `getColumnNameWithoutAlias` will return name of the function with `(arguments)` even if arguments is empty.
         if (column)
-            structure.emplace_back(column->name, column->type->formatWithPossiblyHidingSensitiveData(0, true, true));
+            structure.emplace_back(column->name, column->type->formatWithPossiblyHidingSensitiveData(0, true, true, false));
         else
             throw Exception(ErrorCodes::BAD_ARGUMENTS, "Error while parsing table structure: expected column definition, got {}", child->formatForErrorMessage());
     }
@@ -102,7 +102,7 @@ void BaseExternalTable::parseStructureFromTypesField(const std::string & argumen
         throw Exception(ErrorCodes::BAD_ARGUMENTS, "Error while parsing table structure: {}", error);
 
     for (size_t i = 0; i < type_list_raw->children.size(); ++i)
-        structure.emplace_back("_" + toString(i + 1), type_list_raw->children[i]->formatWithPossiblyHidingSensitiveData(0, true, true));
+        structure.emplace_back("_" + toString(i + 1), type_list_raw->children[i]->formatWithPossiblyHidingSensitiveData(0, true, true, false));
 }
 
 void BaseExternalTable::initSampleBlock()
diff --git a/src/Core/Settings.h b/src/Core/Settings.h
index 0d84ad9022aa..d8837d26e54b 100644
--- a/src/Core/Settings.h
+++ b/src/Core/Settings.h
@@ -882,7 +882,7 @@ class IColumn;
     M(Bool, use_json_alias_for_old_object_type, false, "When enabled, JSON type alias will create old experimental Object type instead of a new JSON type", 0) \
     M(Bool, allow_create_index_without_type, false, "Allow CREATE INDEX query without TYPE. Query will be ignored. Made for SQL compatibility tests.", 0) \
     M(Bool, create_index_ignore_unique, false, "Ignore UNIQUE keyword in CREATE UNIQUE INDEX. Made for SQL compatibility tests.", 0) \
-    M(Bool, print_pretty_type_names, true, "Print pretty type names in DESCRIBE query and toTypeName() function", 0) \
+    M(Bool, print_pretty_type_names, true, "Print pretty type names in the DESCRIBE query and `toTypeName` function, as well as in the `SHOW CREATE TABLE` query and the `formatQuery` function.", 0) \
     M(Bool, create_table_empty_primary_key_by_default, false, "Allow to create *MergeTree tables with empty primary key when ORDER BY and PRIMARY KEY not specified", 0) \
     M(Bool, allow_named_collection_override_by_default, true, "Allow named collections' fields override by default.", 0) \
     M(SQLSecurityType, default_normal_view_sql_security, SQLSecurityType::INVOKER, "Allows to set a default value for SQL SECURITY option when creating a normal view.", 0) \
diff --git a/src/DataTypes/IDataType.cpp b/src/DataTypes/IDataType.cpp
index 7fd8a85aeca5..49e5b2d022e9 100644
--- a/src/DataTypes/IDataType.cpp
+++ b/src/DataTypes/IDataType.cpp
@@ -8,7 +8,6 @@
 #include <Common/quoteString.h>
 
 #include <IO/WriteHelpers.h>
-#include <IO/Operators.h>
 
 #include <DataTypes/IDataType.h>
 #include <DataTypes/DataTypeCustom.h>
diff --git a/src/Databases/DatabaseOnDisk.cpp b/src/Databases/DatabaseOnDisk.cpp
index c80e4def94ec..81378fc1c642 100644
--- a/src/Databases/DatabaseOnDisk.cpp
+++ b/src/Databases/DatabaseOnDisk.cpp
@@ -504,7 +504,7 @@ void DatabaseOnDisk::renameTable(
 }
 
 
-/// It returns create table statement (even if table is detached)
+/// It returns the create table statement (even if table is detached)
 ASTPtr DatabaseOnDisk::getCreateTableQueryImpl(const String & table_name, ContextPtr, bool throw_on_error) const
 {
     ASTPtr ast;
diff --git a/src/Functions/formatQuery.cpp b/src/Functions/formatQuery.cpp
index 9591ea95254e..be633bdfe375 100644
--- a/src/Functions/formatQuery.cpp
+++ b/src/Functions/formatQuery.cpp
@@ -43,6 +43,7 @@ class FunctionFormatQuery : public IFunction
         max_query_size = settings.max_query_size;
         max_parser_depth = settings.max_parser_depth;
         max_parser_backtracks = settings.max_parser_backtracks;
+        print_pretty_type_names = settings.print_pretty_type_names;
     }
 
     String getName() const override { return name; }
@@ -138,7 +139,11 @@ class FunctionFormatQuery : public IFunction
                 }
             }
 
-            formatAST(*ast, buf, /*hilite*/ false, /*single_line*/ output_formatting == OutputFormatting::SingleLine);
+            IAST::FormatSettings settings(buf, output_formatting == OutputFormatting::SingleLine, /*hilite*/ false);
+            settings.show_secrets = true;
+            settings.print_pretty_type_names = print_pretty_type_names;
+            ast->format(settings);
+
             auto formatted = buf.stringView();
 
             const size_t res_data_new_size = res_data_size + formatted.size() + 1;
@@ -165,6 +170,7 @@ class FunctionFormatQuery : public IFunction
     size_t max_query_size;
     size_t max_parser_depth;
     size_t max_parser_backtracks;
+    bool print_pretty_type_names;
 };
 
 }
diff --git a/src/Interpreters/InterpreterShowCreateQuery.cpp b/src/Interpreters/InterpreterShowCreateQuery.cpp
index e5549b2e5396..3de6b7556098 100644
--- a/src/Interpreters/InterpreterShowCreateQuery.cpp
+++ b/src/Interpreters/InterpreterShowCreateQuery.cpp
@@ -97,7 +97,12 @@ QueryPipeline InterpreterShowCreateQuery::executeImpl()
     }
 
     MutableColumnPtr column = ColumnString::create();
-    column->insert(format({.ctx = getContext(), .query = *create_query, .one_line = false}));
+    column->insert(format(
+    {
+        .ctx = getContext(),
+        .query = *create_query,
+        .one_line = false
+    }));
 
     return QueryPipeline(std::make_shared<SourceFromSingleChunk>(Block{{
         std::move(column),
diff --git a/src/Interpreters/executeQuery.cpp b/src/Interpreters/executeQuery.cpp
index fe87eed55701..decc16a3704c 100644
--- a/src/Interpreters/executeQuery.cpp
+++ b/src/Interpreters/executeQuery.cpp
@@ -786,7 +786,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
             /// Verify that AST formatting is consistent:
             /// If you format AST, parse it back, and format it again, you get the same string.
 
-            String formatted1 = ast->formatWithPossiblyHidingSensitiveData(0, true, true);
+            String formatted1 = ast->formatWithPossiblyHidingSensitiveData(0, true, true, false);
 
             /// The query can become more verbose after formatting, so:
             size_t new_max_query_size = max_query_size > 0 ? (1000 + 2 * max_query_size) : 0;
@@ -811,7 +811,7 @@ static std::tuple<ASTPtr, BlockIO> executeQueryImpl(
 
             chassert(ast2);
 
-            String formatted2 = ast2->formatWithPossiblyHidingSensitiveData(0, true, true);
+            String formatted2 = ast2->formatWithPossiblyHidingSensitiveData(0, true, true, false);
 
             if (formatted1 != formatted2)
                 throw Exception(ErrorCodes::LOGICAL_ERROR,
diff --git a/src/Interpreters/formatWithPossiblyHidingSecrets.h b/src/Interpreters/formatWithPossiblyHidingSecrets.h
index ea8c295b1695..14e84f1d1a42 100644
--- a/src/Interpreters/formatWithPossiblyHidingSecrets.h
+++ b/src/Interpreters/formatWithPossiblyHidingSecrets.h
@@ -25,7 +25,8 @@ inline String format(const SecretHidingFormatSettings & settings)
         && settings.ctx->getSettingsRef().format_display_secrets_in_show_and_select
         && settings.ctx->getAccess()->isGranted(AccessType::displaySecretsInShowAndSelect);
 
-    return settings.query.formatWithPossiblyHidingSensitiveData(settings.max_length, settings.one_line, show_secrets);
+    return settings.query.formatWithPossiblyHidingSensitiveData(
+        settings.max_length, settings.one_line, show_secrets, settings.ctx->getSettingsRef().print_pretty_type_names);
 }
 
 }
diff --git a/src/Parsers/ASTColumnDeclaration.cpp b/src/Parsers/ASTColumnDeclaration.cpp
index c96499095d54..23d653012f86 100644
--- a/src/Parsers/ASTColumnDeclaration.cpp
+++ b/src/Parsers/ASTColumnDeclaration.cpp
@@ -66,17 +66,13 @@ void ASTColumnDeclaration::formatImpl(const FormatSettings & format_settings, Fo
 {
     frame.need_parens = false;
 
-    /// We have to always backquote column names to avoid ambiguouty with INDEX and other declarations in CREATE query.
+    /// We have to always backquote column names to avoid ambiguity with INDEX and other declarations in CREATE query.
     format_settings.ostr << backQuote(name);
 
     if (type)
     {
         format_settings.ostr << ' ';
-
-        FormatStateStacked type_frame = frame;
-        type_frame.indent = 0;
-
-        type->formatImpl(format_settings, state, type_frame);
+        type->formatImpl(format_settings, state, frame);
     }
 
     if (null_modifier)
diff --git a/src/Parsers/ASTDataType.cpp b/src/Parsers/ASTDataType.cpp
index 3c17ae8c380a..4211347fb74a 100644
--- a/src/Parsers/ASTDataType.cpp
+++ b/src/Parsers/ASTDataType.cpp
@@ -40,12 +40,22 @@ void ASTDataType::formatImpl(const FormatSettings & settings, FormatState & stat
     {
         settings.ostr << '(' << (settings.hilite ? hilite_none : "");
 
-        for (size_t i = 0, size = arguments->children.size(); i < size; ++i)
+        if (!settings.one_line && settings.print_pretty_type_names && name == "Tuple")
         {
-            if (i != 0)
-                settings.ostr << ", ";
-
-            arguments->children[i]->formatImpl(settings, state, frame);
+            ++frame.indent;
+            std::string indent_str = settings.one_line ? "" : "
" + std::string(4 * frame.indent, ' ');
+            for (size_t i = 0, size = arguments->children.size(); i < size; ++i)
+            {
+                if (i != 0)
+                    settings.ostr << ',';
+                settings.ostr << indent_str;
+                arguments->children[i]->formatImpl(settings, state, frame);
+            }
+        }
+        else
+        {
+            frame.expression_list_prepend_whitespace = false;
+            arguments->formatImpl(settings, state, frame);
         }
 
         settings.ostr << (settings.hilite ? hilite_function : "") << ')';
diff --git a/src/Parsers/ASTExpressionList.cpp b/src/Parsers/ASTExpressionList.cpp
index 61ac482af827..f345b0c6a6f1 100644
--- a/src/Parsers/ASTExpressionList.cpp
+++ b/src/Parsers/ASTExpressionList.cpp
@@ -42,7 +42,8 @@ void ASTExpressionList::formatImpl(const FormatSettings & settings, FormatState
 
 void ASTExpressionList::formatImplMultiline(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
 {
-    std::string indent_str = "
" + std::string(4 * (frame.indent + 1), ' ');
+    ++frame.indent;
+    std::string indent_str = "
" + std::string(4 * frame.indent, ' ');
 
     if (frame.expression_list_prepend_whitespace)
     {
@@ -50,8 +51,6 @@ void ASTExpressionList::formatImplMultiline(const FormatSettings & settings, For
             settings.ostr << ' ';
     }
 
-    ++frame.indent;
-
     for (size_t i = 0, size = children.size(); i < size; ++i)
     {
         if (i && separator)
diff --git a/src/Parsers/ASTNameTypePair.cpp b/src/Parsers/ASTNameTypePair.cpp
index e4066081a9b9..1515700365f6 100644
--- a/src/Parsers/ASTNameTypePair.cpp
+++ b/src/Parsers/ASTNameTypePair.cpp
@@ -23,12 +23,8 @@ ASTPtr ASTNameTypePair::clone() const
 
 void ASTNameTypePair::formatImpl(const FormatSettings & settings, FormatState & state, FormatStateStacked frame) const
 {
-    std::string indent_str = settings.one_line ? "" : std::string(4 * frame.indent, ' ');
-
-    settings.ostr << indent_str << backQuoteIfNeed(name) << ' ';
+    settings.ostr << backQuoteIfNeed(name) << ' ';
     type->formatImpl(settings, state, frame);
 }
 
 }
-
-
diff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp
index 37d7f458d613..5bd2c92c60ae 100644
--- a/src/Parsers/IAST.cpp
+++ b/src/Parsers/IAST.cpp
@@ -165,11 +165,12 @@ size_t IAST::checkDepthImpl(size_t max_depth) const
     return res;
 }
 
-String IAST::formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets) const
+String IAST::formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets, bool print_pretty_type_names) const
 {
     WriteBufferFromOwnString buf;
     FormatSettings settings(buf, one_line);
     settings.show_secrets = show_secrets;
+    settings.print_pretty_type_names = print_pretty_type_names;
     format(settings);
     return wipeSensitiveDataAndCutToLength(buf.str(), max_length);
 }
diff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h
index e2cf75796678..2293d50b0eca 100644
--- a/src/Parsers/IAST.h
+++ b/src/Parsers/IAST.h
@@ -201,6 +201,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
         bool show_secrets; /// Show secret parts of the AST (e.g. passwords, encryption keys).
         char nl_or_ws; /// Newline or whitespace.
         LiteralEscapingStyle literal_escaping_style;
+        bool print_pretty_type_names;
 
         explicit FormatSettings(
             WriteBuffer & ostr_,
@@ -209,7 +210,8 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
             bool always_quote_identifiers_ = false,
             IdentifierQuotingStyle identifier_quoting_style_ = IdentifierQuotingStyle::Backticks,
             bool show_secrets_ = true,
-            LiteralEscapingStyle literal_escaping_style_ = LiteralEscapingStyle::Regular)
+            LiteralEscapingStyle literal_escaping_style_ = LiteralEscapingStyle::Regular,
+            bool print_pretty_type_names_ = false)
             : ostr(ostr_)
             , one_line(one_line_)
             , hilite(hilite_)
@@ -218,6 +220,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
             , show_secrets(show_secrets_)
             , nl_or_ws(one_line ? ' ' : '
')
             , literal_escaping_style(literal_escaping_style_)
+            , print_pretty_type_names(print_pretty_type_names_)
         {
         }
 
@@ -230,6 +233,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
             , show_secrets(other.show_secrets)
             , nl_or_ws(other.nl_or_ws)
             , literal_escaping_style(other.literal_escaping_style)
+            , print_pretty_type_names(other.print_pretty_type_names)
         {
         }
 
@@ -251,7 +255,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
     /// The state that is copied when each node is formatted. For example, nesting level.
     struct FormatStateStacked
     {
-        UInt8 indent = 0;
+        UInt16 indent = 0;
         bool need_parens = false;
         bool expression_list_always_start_on_new_line = false;  /// Line feed and indent before expression list even if it's of single element.
         bool expression_list_prepend_whitespace = false; /// Prepend whitespace (if it is required)
@@ -274,7 +278,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
 
     /// Secrets are displayed regarding show_secrets, then SensitiveDataMasker is applied.
     /// You can use Interpreters/formatWithPossiblyHidingSecrets.h for convenience.
-    String formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets) const;
+    String formatWithPossiblyHidingSensitiveData(size_t max_length, bool one_line, bool show_secrets, bool print_pretty_type_names) const;
 
     /** formatForLogging and formatForErrorMessage always hide secrets. This inconsistent
       * behaviour is due to the fact such functions are called from Client which knows nothing about
@@ -283,12 +287,12 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS
       */
     String formatForLogging(size_t max_length = 0) const
     {
-        return formatWithPossiblyHidingSensitiveData(max_length, true, false);
+        return formatWithPossiblyHidingSensitiveData(max_length, true, false, false);
     }
 
     String formatForErrorMessage() const
     {
-        return formatWithPossiblyHidingSensitiveData(0, true, false);
+        return formatWithPossiblyHidingSensitiveData(0, true, false, false);
     }
 
     virtual bool hasSecretParts() const { return childrenHaveSecretParts(); }
