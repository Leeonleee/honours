{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 25894,
  "instance_id": "ClickHouse__ClickHouse-25894",
  "issue_numbers": [
    "25578"
  ],
  "base_commit": "1e85ea50fa053e3eaa9cbc98681ffa45c12461aa",
  "patch": "diff --git a/src/Interpreters/HashJoin.cpp b/src/Interpreters/HashJoin.cpp\nindex 1d112a7c5484..323c821c4424 100644\n--- a/src/Interpreters/HashJoin.cpp\n+++ b/src/Interpreters/HashJoin.cpp\n@@ -27,6 +27,7 @@\n #include <Core/ColumnNumbers.h>\n #include <Common/typeid_cast.h>\n #include <Common/assert_cast.h>\n+\n namespace DB\n {\n \n@@ -289,13 +290,11 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n         if (table_join->getDictionaryReader())\n         {\n             assert(disjuncts_num == 1);\n-            LOG_DEBUG(log, \"Performing join over dict\");\n             data->type = Type::DICT;\n \n             data->maps.resize(disjuncts_num);\n             std::get<MapsOne>(data->maps[0]).create(Type::DICT);\n-            key_sizes.resize(1);\n-            chooseMethod(key_columns, key_sizes[0]); /// init key_sizes\n+            chooseMethod(kind, key_columns, key_sizes.emplace_back()); /// init key_sizes\n         }\n         else if (strictness == ASTTableJoin::Strictness::Asof)\n         {\n@@ -321,13 +320,13 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n             /// Therefore, add it back in such that it can be extracted appropriately from the full stored\n             /// key_columns and key_sizes\n             auto & asof_key_sizes = key_sizes.emplace_back();\n-            data->type = chooseMethod(key_columns, asof_key_sizes);\n+            data->type = chooseMethod(kind, key_columns, asof_key_sizes);\n             asof_key_sizes.push_back(asof_size);\n         }\n         else\n         {\n             /// Choose data structure to use for JOIN.\n-            auto current_join_method = chooseMethod(key_columns, key_sizes.emplace_back());\n+            auto current_join_method = chooseMethod(kind, key_columns, key_sizes.emplace_back());\n             if (data->type == Type::EMPTY)\n                 data->type = current_join_method;\n             else if (data->type != current_join_method)\n@@ -337,14 +336,20 @@ HashJoin::HashJoin(std::shared_ptr<TableJoin> table_join_, const Block & right_s\n \n     for (auto & maps : data->maps)\n         dataMapInit(maps);\n+\n+    LOG_DEBUG(log, \"Join type: {}, kind: {}, strictness: {}\", data->type, kind, strictness);\n }\n \n-HashJoin::Type HashJoin::chooseMethod(const ColumnRawPtrs & key_columns, Sizes & key_sizes)\n+HashJoin::Type HashJoin::chooseMethod(ASTTableJoin::Kind kind, const ColumnRawPtrs & key_columns, Sizes & key_sizes)\n {\n     size_t keys_size = key_columns.size();\n \n     if (keys_size == 0)\n-        return Type::CROSS;\n+    {\n+        if (isCrossOrComma(kind))\n+            return Type::CROSS;\n+        return Type::EMPTY;\n+    }\n \n     bool all_fixed = true;\n     size_t keys_bytes = 0;\n@@ -446,6 +451,23 @@ class KeyGetterForDict\n     std::vector<size_t> positions;\n };\n \n+/// Dummy key getter, always find nothing, used for JOIN ON NULL\n+template <typename Mapped>\n+class KeyGetterEmpty\n+{\n+public:\n+    struct MappedType\n+    {\n+        using mapped_type = Mapped;\n+    };\n+\n+    using FindResult = ColumnsHashing::columns_hashing_impl::FindResultImpl<Mapped, true>;\n+\n+    KeyGetterEmpty() = default;\n+\n+    FindResult findKey(MappedType, size_t, const Arena &) { return FindResult(); }\n+};\n+\n template <HashJoin::Type type, typename Value, typename Mapped>\n struct KeyGetterForTypeImpl;\n \n@@ -723,8 +745,6 @@ Block HashJoin::structureRightBlock(const Block & block) const\n \n bool HashJoin::addJoinedBlock(const Block & source_block, bool check_limits)\n {\n-    if (empty())\n-        throw Exception(\"Logical error: HashJoin was not initialized\", ErrorCodes::LOGICAL_ERROR);\n     if (overDictionary())\n         throw Exception(\"Logical error: insert into hash-map in HashJoin over dictionary\", ErrorCodes::LOGICAL_ERROR);\n \n@@ -1373,12 +1393,28 @@ IColumn::Filter switchJoinRightColumns(\n     constexpr bool is_asof_join = STRICTNESS == ASTTableJoin::Strictness::Asof;\n     switch (type)\n     {\n+        case HashJoin::Type::EMPTY:\n+        {\n+            if constexpr (!is_asof_join)\n+            {\n+                using KeyGetter = KeyGetterEmpty<typename Maps::MappedType>;\n+                std::vector<KeyGetter> key_getter_vector;\n+                key_getter_vector.emplace_back();\n+\n+                using MapTypeVal = typename KeyGetter::MappedType;\n+                std::vector<const MapTypeVal *> a_map_type_vector;\n+                a_map_type_vector.emplace_back();\n+                return joinRightColumnsSwitchNullability<KIND, STRICTNESS, KeyGetter>(\n+                        std::move(key_getter_vector), a_map_type_vector, added_columns, used_flags);\n+            }\n+            throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys. Type: {}\", type);\n+        }\n     #define M(TYPE) \\\n         case HashJoin::Type::TYPE: \\\n             {                                                           \\\n             using MapTypeVal = const typename std::remove_reference_t<decltype(Maps::TYPE)>::element_type; \\\n             using KeyGetter = typename KeyGetterForType<HashJoin::Type::TYPE, MapTypeVal>::Type; \\\n-            std::vector<const MapTypeVal*> a_map_type_vector(mapv.size()); \\\n+            std::vector<const MapTypeVal *> a_map_type_vector(mapv.size()); \\\n             std::vector<KeyGetter> key_getter_vector;                     \\\n             for (size_t d = 0; d < added_columns.join_on_keys.size(); ++d)                   \\\n             {       \\\n@@ -1393,7 +1429,7 @@ IColumn::Filter switchJoinRightColumns(\n     #undef M\n \n         default:\n-            throw Exception(\"Unsupported JOIN keys. Type: \" + toString(static_cast<UInt32>(type)), ErrorCodes::UNSUPPORTED_JOIN_KEYS);\n+            throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys (type: {})\", type);\n     }\n }\n \n@@ -1828,7 +1864,7 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n {\n public:\n     NotJoinedHash(const HashJoin & parent_, UInt64 max_block_size_)\n-        : parent(parent_), max_block_size(max_block_size_)\n+        : parent(parent_), max_block_size(max_block_size_), current_block_start(0)\n     {}\n \n     Block getEmptyBlock() override { return parent.savedBlockSample().cloneEmpty(); }\n@@ -1836,13 +1872,20 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n     size_t fillColumns(MutableColumns & columns_right) override\n     {\n         size_t rows_added = 0;\n-        auto fill_callback = [&](auto, auto strictness, auto & map)\n+        if (unlikely(parent.data->type == HashJoin::Type::EMPTY))\n+        {\n+            rows_added = fillColumnsFromData(parent.data->blocks, columns_right);\n+        }\n+        else\n         {\n-            rows_added = fillColumnsFromMap<strictness>(map, columns_right);\n-        };\n+            auto fill_callback = [&](auto, auto strictness, auto & map)\n+            {\n+                rows_added = fillColumnsFromMap<strictness>(map, columns_right);\n+            };\n \n-        if (!joinDispatch(parent.kind, parent.strictness, parent.data->maps.front(), fill_callback))\n-            throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown JOIN strictness '{}' (must be on of: ANY, ALL, ASOF)\", parent.strictness);\n+            if (!joinDispatch(parent.kind, parent.strictness, parent.data->maps.front(), fill_callback))\n+                throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown JOIN strictness '{}' (must be on of: ANY, ALL, ASOF)\", parent.strictness);\n+        }\n \n         if constexpr (!multiple_disjuncts)\n         {\n@@ -1856,10 +1899,48 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n     const HashJoin & parent;\n     UInt64 max_block_size;\n \n+    size_t current_block_start;\n+\n     std::any position;\n     std::optional<HashJoin::BlockNullmapList::const_iterator> nulls_position;\n     std::optional<BlocksList::const_iterator> used_position;\n \n+    size_t fillColumnsFromData(const BlocksList & blocks, MutableColumns & columns_right)\n+    {\n+        if (!position.has_value())\n+            position = std::make_any<BlocksList::const_iterator>(blocks.begin());\n+\n+        auto & block_it = std::any_cast<BlocksList::const_iterator &>(position);\n+        auto end = blocks.end();\n+\n+        size_t rows_added = 0;\n+        for (; block_it != end; ++block_it)\n+        {\n+            size_t rows_from_block = std::min<size_t>(max_block_size - rows_added, block_it->rows() - current_block_start);\n+            for (size_t j = 0; j < columns_right.size(); ++j)\n+            {\n+                const auto & col = block_it->getByPosition(j).column;\n+                columns_right[j]->insertRangeFrom(*col, current_block_start, rows_from_block);\n+            }\n+            rows_added += rows_from_block;\n+\n+            if (rows_added >= max_block_size)\n+            {\n+                /// How many rows have been read\n+                current_block_start += rows_from_block;\n+                if (block_it->rows() <= current_block_start)\n+                {\n+                    /// current block was fully read\n+                    ++block_it;\n+                    current_block_start = 0;\n+                }\n+                break;\n+            }\n+            current_block_start = 0;\n+        }\n+        return rows_added;\n+    }\n+\n     template <ASTTableJoin::Strictness STRICTNESS, typename Maps>\n     size_t fillColumnsFromMap(const Maps & maps, MutableColumns & columns_keys_and_right)\n     {\n@@ -1871,8 +1952,7 @@ class NotJoinedHash final : public NotJoinedBlocks::RightColumnsFiller\n             APPLY_FOR_JOIN_VARIANTS(M)\n         #undef M\n             default:\n-                throw Exception(\"Unsupported JOIN keys. Type: \" + toString(static_cast<UInt32>(parent.data->type)),\n-                                ErrorCodes::UNSUPPORTED_JOIN_KEYS);\n+                throw Exception(ErrorCodes::UNSUPPORTED_JOIN_KEYS, \"Unsupported JOIN keys (type: {})\", parent.data->type)   ;\n         }\n \n         __builtin_unreachable();\ndiff --git a/src/Interpreters/HashJoin.h b/src/Interpreters/HashJoin.h\nindex f41f63a6a55a..50c8b2c55ee6 100644\n--- a/src/Interpreters/HashJoin.h\n+++ b/src/Interpreters/HashJoin.h\n@@ -231,6 +231,7 @@ class HashJoin : public IJoin\n     template <typename Mapped>\n     struct MapsTemplate\n     {\n+        using MappedType = Mapped;\n         std::unique_ptr<FixedHashMap<UInt8, Mapped>>                  key8;\n         std::unique_ptr<FixedHashMap<UInt16, Mapped>>                 key16;\n         std::unique_ptr<HashMap<UInt32, Mapped, HashCRC32<UInt32>>>   key32;\n@@ -411,7 +412,7 @@ class HashJoin : public IJoin\n \n     void joinBlockImplCross(Block & block, ExtraBlockPtr & not_processed) const;\n \n-    static Type chooseMethod(const ColumnRawPtrs & key_columns, Sizes & key_sizes);\n+    static Type chooseMethod(ASTTableJoin::Kind kind, const ColumnRawPtrs & key_columns, Sizes & key_sizes);\n \n     bool empty() const;\n     bool overDictionary() const;\ndiff --git a/src/Interpreters/TableJoin.cpp b/src/Interpreters/TableJoin.cpp\nindex ad16cc5af7f1..e657bf38e494 100644\n--- a/src/Interpreters/TableJoin.cpp\n+++ b/src/Interpreters/TableJoin.cpp\n@@ -108,6 +108,16 @@ TableJoin::TableJoin(const Settings & settings, VolumePtr tmp_volume_)\n {\n }\n \n+void TableJoin::resetKeys()\n+{\n+    clauses.clear();\n+\n+    key_asts_left.clear();\n+    key_asts_right.clear();\n+    left_type_map.clear();\n+    right_type_map.clear();\n+}\n+\n void TableJoin::resetCollected()\n {\n     clauses.clear();\n@@ -224,6 +234,13 @@ Names TableJoin::requiredJoinedNames() const\n     for (const auto & joined_column : columns_added_by_join)\n         required_columns_set.insert(joined_column.name);\n \n+    /*\n+     * In case of `SELECT count() FROM ... JOIN .. ON NULL` required columns set for right table is empty.\n+     * But we have to get at least one column from right table to know the number of rows.\n+     */\n+    if (required_columns_set.empty() && !columns_from_joined_table.empty())\n+        return {columns_from_joined_table.begin()->name};\n+\n     return Names(required_columns_set.begin(), required_columns_set.end());\n }\n \n@@ -352,9 +369,7 @@ bool TableJoin::sameStrictnessAndKind(ASTTableJoin::Strictness strictness_, ASTT\n \n bool TableJoin::oneDisjunct() const\n {\n-    if (!isCrossOrComma(kind()))\n-        assert(!clauses.empty());\n-    return clauses.size() <= 1;\n+    return clauses.size() == 1;\n }\n \n bool TableJoin::allowMergeJoin() const\n@@ -650,4 +665,10 @@ void TableJoin::assertHasOneOnExpr() const\n     }\n }\n \n+void TableJoin::resetToCross()\n+{\n+    this->resetKeys();\n+    this->table_join.kind = ASTTableJoin::Kind::Cross;\n+}\n+\n }\ndiff --git a/src/Interpreters/TableJoin.h b/src/Interpreters/TableJoin.h\nindex 7cd53442ffd7..956fed99fb87 100644\n--- a/src/Interpreters/TableJoin.h\n+++ b/src/Interpreters/TableJoin.h\n@@ -48,7 +48,6 @@ enum class JoinTableSide\n \n class TableJoin\n {\n-\n public:\n     using NameToTypeMap = std::unordered_map<String, DataTypePtr>;\n \n@@ -285,6 +284,10 @@ class TableJoin\n     Block getRequiredRightKeys(const Block & right_table_keys, std::vector<String> & keys_sources) const;\n \n     String renamedRightColumnName(const String & name) const;\n+\n+    void resetKeys();\n+    void resetToCross();\n+\n     std::unordered_map<String, String> leftToRightKeyRemap() const;\n \n     void setStorageJoin(std::shared_ptr<StorageJoin> storage);\ndiff --git a/src/Interpreters/TreeRewriter.cpp b/src/Interpreters/TreeRewriter.cpp\nindex 571958a1f79b..ef8446eb4b94 100644\n--- a/src/Interpreters/TreeRewriter.cpp\n+++ b/src/Interpreters/TreeRewriter.cpp\n@@ -1,3 +1,4 @@\n+#include <algorithm>\n #include <Core/Settings.h>\n #include <Core/NamesAndTypes.h>\n \n@@ -22,6 +23,7 @@\n #include <Interpreters/getTableExpressions.h>\n #include <Interpreters/TreeOptimizer.h>\n #include <Interpreters/replaceAliasColumnsInQuery.h>\n+#include <Interpreters/evaluateConstantExpression.h>\n #include <Interpreters/PredicateExpressionsOptimizer.h>\n \n #include <Parsers/ASTExpressionList.h>\n@@ -33,6 +35,8 @@\n \n #include <DataTypes/NestedUtils.h>\n #include <DataTypes/DataTypeNullable.h>\n+#include <DataTypes/DataTypeLowCardinality.h>\n+#include <DataTypes/DataTypesNumber.h>\n \n #include <IO/WriteHelpers.h>\n #include <Storages/IStorage.h>\n@@ -564,9 +568,68 @@ void setJoinStrictness(ASTSelectQuery & select_query, JoinStrictness join_defaul\n     out_table_join = table_join;\n }\n \n+/// Evaluate expression and return boolean value if it can be interpreted as bool.\n+/// Only UInt8 or NULL are allowed.\n+/// Returns `false` for 0 or NULL values, `true` for any non-negative value.\n+std::optional<bool> tryEvaluateConstCondition(ASTPtr expr, ContextPtr context)\n+{\n+    if (!expr)\n+        return {};\n+\n+    Field eval_res;\n+    DataTypePtr eval_res_type;\n+    try\n+    {\n+        std::tie(eval_res, eval_res_type) = evaluateConstantExpression(expr, context);\n+    }\n+    catch (DB::Exception &)\n+    {\n+        /// not a constant expression\n+        return {};\n+    }\n+    /// UInt8, maybe Nullable, maybe LowCardinality, and NULL are allowed\n+    eval_res_type = removeNullable(removeLowCardinality(eval_res_type));\n+    if (auto which = WhichDataType(eval_res_type); !which.isUInt8() && !which.isNothing())\n+        return {};\n+\n+    if (eval_res.isNull())\n+        return false;\n+\n+    UInt8 res = eval_res.template safeGet<UInt8>();\n+    return res > 0;\n+}\n+\n+bool tryJoinOnConst(TableJoin & analyzed_join, ASTPtr & on_expression, ContextPtr context)\n+{\n+    bool join_on_value;\n+    if (auto eval_const_res = tryEvaluateConstCondition(on_expression, context))\n+        join_on_value = *eval_const_res;\n+    else\n+        return false;\n+\n+    if (!analyzed_join.forceHashJoin())\n+        throw Exception(ErrorCodes::NOT_IMPLEMENTED,\n+                        \"JOIN ON constant ({}) supported only with join algorithm 'hash'\",\n+                        queryToString(on_expression));\n+\n+    on_expression = nullptr;\n+    if (join_on_value)\n+    {\n+        LOG_DEBUG(&Poco::Logger::get(\"TreeRewriter\"), \"Join on constant executed as cross join\");\n+        analyzed_join.resetToCross();\n+    }\n+    else\n+    {\n+        LOG_DEBUG(&Poco::Logger::get(\"TreeRewriter\"), \"Join on constant executed as empty join\");\n+        analyzed_join.resetKeys();\n+    }\n+\n+    return true;\n+}\n+\n /// Find the columns that are obtained by JOIN.\n-void collectJoinedColumns(TableJoin & analyzed_join, const ASTTableJoin & table_join,\n-                          const TablesWithColumns & tables, const Aliases & aliases)\n+void collectJoinedColumns(TableJoin & analyzed_join, ASTTableJoin & table_join,\n+                          const TablesWithColumns & tables, const Aliases & aliases, ContextPtr context)\n {\n     assert(tables.size() >= 2);\n \n@@ -599,29 +662,41 @@ void collectJoinedColumns(TableJoin & analyzed_join, const ASTTableJoin & table_\n             assert(analyzed_join.oneDisjunct());\n         }\n \n-        if (analyzed_join.getClauses().empty())\n-                throw DB::Exception(ErrorCodes::INVALID_JOIN_ON_EXPRESSION,\n-                                    \"Cannot get JOIN keys from JOIN ON section: '{}'\",\n-                                    queryToString(table_join.on_expression));\n+        auto check_keys_empty = [] (auto e) { return e.key_names_left.empty(); };\n \n-        for (const auto & onexpr : analyzed_join.getClauses())\n+        /// All clauses should to have keys or be empty simultaneously\n+        bool all_keys_empty = std::all_of(analyzed_join.getClauses().begin(), analyzed_join.getClauses().end(), check_keys_empty);\n+        if (all_keys_empty)\n+        {\n+            /// Try join on constant (cross or empty join) or fail\n+            if (is_asof)\n+                throw Exception(ErrorCodes::INVALID_JOIN_ON_EXPRESSION,\n+                                \"Cannot get JOIN keys from JOIN ON section: {}\", queryToString(table_join.on_expression));\n+\n+            bool join_on_const_ok = tryJoinOnConst(analyzed_join, table_join.on_expression, context);\n+            if (!join_on_const_ok)\n+                throw Exception(ErrorCodes::INVALID_JOIN_ON_EXPRESSION,\n+                                \"Cannot get JOIN keys from JOIN ON section: {}\", queryToString(table_join.on_expression));\n+        }\n+        else\n         {\n-            if (onexpr.key_names_left.empty())\n+            bool any_keys_empty = std::any_of(analyzed_join.getClauses().begin(), analyzed_join.getClauses().end(), check_keys_empty);\n+\n+            if (any_keys_empty)\n                 throw DB::Exception(ErrorCodes::INVALID_JOIN_ON_EXPRESSION,\n                                     \"Cannot get JOIN keys from JOIN ON section: '{}'\",\n                                     queryToString(table_join.on_expression));\n-        }\n \n-        if (is_asof)\n-        {\n-            if (!analyzed_join.oneDisjunct())\n-                throw DB::Exception(ErrorCodes::NOT_IMPLEMENTED, \"ASOF join doesn't support multiple ORs for keys in JOIN ON section\");\n-            data.asofToJoinKeys();\n-        }\n-\n-        if (!analyzed_join.oneDisjunct() && !analyzed_join.forceHashJoin())\n-            throw DB::Exception(ErrorCodes::NOT_IMPLEMENTED, \"Only `hash` join supports multiple ORs for keys in JOIN ON section\");\n+            if (is_asof)\n+            {\n+                if (!analyzed_join.oneDisjunct())\n+                    throw DB::Exception(ErrorCodes::NOT_IMPLEMENTED, \"ASOF join doesn't support multiple ORs for keys in JOIN ON section\");\n+                data.asofToJoinKeys();\n+            }\n \n+            if (!analyzed_join.oneDisjunct() && !analyzed_join.forceHashJoin())\n+                throw DB::Exception(ErrorCodes::NOT_IMPLEMENTED, \"Only `hash` join supports multiple ORs for keys in JOIN ON section\");\n+        }\n     }\n }\n \n@@ -1052,7 +1127,7 @@ TreeRewriterResultPtr TreeRewriter::analyzeSelect(\n \n     auto * table_join_ast = select_query->join() ? select_query->join()->table_join->as<ASTTableJoin>() : nullptr;\n     if (table_join_ast && tables_with_columns.size() >= 2)\n-        collectJoinedColumns(*result.analyzed_join, *table_join_ast, tables_with_columns, result.aliases);\n+        collectJoinedColumns(*result.analyzed_join, *table_join_ast, tables_with_columns, result.aliases, getContext());\n \n     result.aggregates = getAggregates(query, *select_query);\n     result.window_function_asts = getWindowFunctions(query, *select_query);\ndiff --git a/src/Interpreters/join_common.cpp b/src/Interpreters/join_common.cpp\nindex bf5d30437ec1..f123435b5fed 100644\n--- a/src/Interpreters/join_common.cpp\n+++ b/src/Interpreters/join_common.cpp\n@@ -580,11 +580,10 @@ NotJoinedBlocks::NotJoinedBlocks(std::unique_ptr<RightColumnsFiller> filler_,\n     }\n \n     if (column_indices_left.size() + column_indices_right.size() + same_result_keys.size() != result_sample_block.columns())\n-        throw Exception(\"Error in columns mapping in RIGHT|FULL JOIN. Left: \" + toString(column_indices_left.size()) +\n-                        \", right: \" + toString(column_indices_right.size()) +\n-                        \", same: \" + toString(same_result_keys.size()) +\n-                        \", result: \" + toString(result_sample_block.columns()),\n-                        ErrorCodes::LOGICAL_ERROR);\n+        throw Exception(ErrorCodes::LOGICAL_ERROR,\n+                        \"Error in columns mapping in RIGHT|FULL JOIN. Left: {}, right: {}, same: {}, result: {}\",\n+                        column_indices_left.size(), column_indices_right.size(),\n+                        same_result_keys.size(), result_sample_block.columns());\n }\n \n void NotJoinedBlocks::setRightIndex(size_t right_pos, size_t result_position)\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02000_join_on_const.reference b/tests/queries/0_stateless/02000_join_on_const.reference\nnew file mode 100644\nindex 000000000000..b9494e4689c1\n--- /dev/null\n+++ b/tests/queries/0_stateless/02000_join_on_const.reference\n@@ -0,0 +1,31 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+- ON NULL -\n+- inner -\n+- left -\n+1\t0\n+2\t0\n+- right -\n+0\t2\n+0\t3\n+- full -\n+0\t2\n+0\t3\n+1\t0\n+2\t0\n+- inner -\n+- left -\n+1\t\\N\n+2\t\\N\n+- right -\n+\\N\t2\n+\\N\t3\n+- full -\n+\\N\t2\n+\\N\t3\n+1\t\\N\n+2\t\\N\ndiff --git a/tests/queries/0_stateless/02000_join_on_const.sql b/tests/queries/0_stateless/02000_join_on_const.sql\nnew file mode 100644\nindex 000000000000..f6d686cf9bc4\n--- /dev/null\n+++ b/tests/queries/0_stateless/02000_join_on_const.sql\n@@ -0,0 +1,55 @@\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+\n+CREATE TABLE t1 (id Int) ENGINE = Memory;\n+CREATE TABLE t2 (id Int) ENGINE = Memory;\n+\n+INSERT INTO t1 VALUES (1), (2);\n+INSERT INTO t2 VALUES (2), (3);\n+\n+SELECT 70 = 10 * sum(t1.id) + sum(t2.id) AND count() == 4 FROM t1 JOIN t2 ON 1 = 1;\n+SELECT 70 = 10 * sum(t1.id) + sum(t2.id) AND count() == 4 FROM t1 JOIN t2 ON 1;\n+SELECT 70 = 10 * sum(t1.id) + sum(t2.id) AND count() == 4 FROM t1 JOIN t2 ON 2 = 2 AND 3 = 3;\n+SELECT 70 = 10 * sum(t1.id) + sum(t2.id) AND count() == 4 FROM t1 INNER ANY JOIN t2 ON toNullable(1);\n+SELECT 70 = 10 * sum(t1.id) + sum(t2.id) AND count() == 4 FROM t1 INNER ANY JOIN t2 ON toLowCardinality(1);\n+SELECT 70 = 10 * sum(t1.id) + sum(t2.id) AND count() == 4 FROM t1 INNER ANY JOIN t2 ON toLowCardinality(toNullable(1));\n+\n+SELECT * FROM t1 INNER ANY JOIN t2 ON toNullable(toLowCardinality(1)); -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON toUInt16(1); -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON toInt8(1); -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON 256; -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON -1; -- { serverError 403 }\n+SELECT * FROM t1 INNER ANY JOIN t2 ON toString(1); -- { serverError 403 }\n+\n+SELECT '- ON NULL -';\n+\n+SELECT '- inner -';\n+SELECT * FROM t1 INNER ANY JOIN t2 ON NULL;\n+SELECT * FROM t1 INNER ANY JOIN t2 ON 0;\n+SELECT * FROM t1 INNER ANY JOIN t2 ON 1 = 2;\n+SELECT '- left -';\n+SELECT * FROM t1 LEFT JOIN t2 ON NULL ORDER BY t1.id, t2.id;\n+SELECT '- right -';\n+SELECT * FROM t1 RIGHT JOIN t2 ON NULL ORDER BY t1.id, t2.id;\n+SELECT '- full -';\n+SELECT * FROM t1 FULL JOIN t2 ON NULL ORDER BY t1.id, t2.id;\n+\n+SELECT '- inner -';\n+SELECT * FROM t1 INNER ANY JOIN t2 ON NULL ORDER BY t1.id NULLS FIRST, t2.id SETTINGS join_use_nulls = 1;\n+SELECT '- left -';\n+SELECT * FROM t1 LEFT JOIN t2 ON NULL ORDER BY t1.id NULLS FIRST, t2.id SETTINGS join_use_nulls = 1;\n+SELECT '- right -';\n+SELECT * FROM t1 RIGHT JOIN t2 ON NULL ORDER BY t1.id NULLS FIRST, t2.id SETTINGS join_use_nulls = 1;\n+SELECT '- full -';\n+SELECT * FROM t1 FULL JOIN t2 ON NULL ORDER BY t1.id NULLS FIRST, t2.id SETTINGS join_use_nulls = 1;\n+\n+SELECT * FROM t1 JOIN t2 ON 1 = 1 SETTINGS join_algorithm = 'partial_merge'; -- { serverError 48 }\n+SELECT * FROM t1 JOIN t2 ON 1 = 1 SETTINGS join_algorithm = 'auto'; -- { serverError 48 }\n+SELECT * FROM t1 JOIN t2 ON NULL SETTINGS join_algorithm = 'partial_merge'; -- { serverError 48 }\n+SELECT * FROM t1 LEFT JOIN t2 ON NULL SETTINGS join_algorithm = 'partial_merge'; -- { serverError 48 }\n+SELECT * FROM t1 RIGHT JOIN t2 ON NULL SETTINGS join_algorithm = 'auto'; -- { serverError 48 }\n+SELECT * FROM t1 FULL JOIN t2 ON NULL SETTINGS join_algorithm = 'partial_merge'; -- { serverError 48 }\n+\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+\ndiff --git a/tests/queries/0_stateless/02001_join_on_const_bs_long.reference b/tests/queries/0_stateless/02001_join_on_const_bs_long.reference\nnew file mode 100644\nindex 000000000000..b45724ee906d\n--- /dev/null\n+++ b/tests/queries/0_stateless/02001_join_on_const_bs_long.reference\n@@ -0,0 +1,41 @@\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\n+1\ndiff --git a/tests/queries/0_stateless/02001_join_on_const_bs_long.sql.j2 b/tests/queries/0_stateless/02001_join_on_const_bs_long.sql.j2\nnew file mode 100644\nindex 000000000000..1726bcb7062c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02001_join_on_const_bs_long.sql.j2\n@@ -0,0 +1,27 @@\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n+\n+CREATE TABLE t1 (id Int) ENGINE = MergeTree ORDER BY id;\n+CREATE TABLE t2 (id Int) ENGINE = MergeTree ORDER BY id;\n+\n+INSERT INTO t1 VALUES (1), (2);\n+INSERT INTO t2 SELECT number + 5 AS x FROM (SELECT * FROM system.numbers LIMIT 1111);\n+\n+SET max_block_size = 100;\n+\n+SELECT count() == 2222 FROM t1 JOIN t2 ON 1 = 1;\n+\n+{% for bs in [90, 95, 99, 100, 101, 110, 111, 128] -%}\n+\n+SET max_block_size = {{ bs }};\n+\n+SELECT count() == 0 FROM t1 JOIN t2 ON 1 = 2;\n+SELECT count() == 2 FROM t1 LEFT JOIN t2 ON 1 = 2;\n+SELECT count() == 1111  FROM t1 RIGHT JOIN t2 ON 1 = 2;\n+SELECT count() == 1113  FROM t1 FULL JOIN t2 ON 1 = 2;\n+SELECT max(blockSize()) <= {{ bs }} FROM t1 FULL JOIN t2 ON 1 = 2;\n+\n+{% endfor %}\n+\n+DROP TABLE IF EXISTS t1;\n+DROP TABLE IF EXISTS t2;\n",
  "problem_statement": "Support `LEFT JOIN ... ON 1 = 1` expression\n**Usage**\r\nPostgres, MySQL, and Oracle support the expression `LEFT JOIN ... ON 1 = 1`, but ClickHouse does not.\r\n\r\nIt may be possible to replace `LEFT JOIN ... ON 1 = 1` with `CROSS JOIN`, but I want to use the query in the same form for lots of databases.\r\n\r\nPlease support the expression `LEFT JOIN ... ON 1 = 1`.\r\n\r\n\r\n**Detailed SQL**\r\n```SQL\r\nCREATE TABLE test\r\n(\r\n    `name` Nullable(String),\r\n    `id` int\r\n)\r\nENGINE = Log();\r\n\r\ninsert into test values ('a', 1) ('b', 2) (null, 3);\r\n\r\nselect * from test t1 left join (select * from test ) t2 on 1 = 1   \r\n-- DB::Exception: Not equi-join ON expression: 1 = 1. No columns in one of equality side.: While processing 1 = 1.\r\n```\r\n\n",
  "hints_text": "",
  "created_at": "2021-07-01T13:19:23Z"
}