{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 34892,
  "instance_id": "ClickHouse__ClickHouse-34892",
  "issue_numbers": [
    "33757"
  ],
  "base_commit": "222b9640709f2bd2a0f1042041edcac8067a126c",
  "patch": "diff --git a/src/Parsers/ExpressionElementParsers.cpp b/src/Parsers/ExpressionElementParsers.cpp\nindex 1de9adb834eb..81d6f34aced7 100644\n--- a/src/Parsers/ExpressionElementParsers.cpp\n+++ b/src/Parsers/ExpressionElementParsers.cpp\n@@ -53,89 +53,6 @@ namespace ErrorCodes\n }\n \n \n-bool ParserArray::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ASTPtr contents_node;\n-    ParserExpressionList contents(false);\n-\n-    if (pos->type != TokenType::OpeningSquareBracket)\n-        return false;\n-    ++pos;\n-\n-    if (!contents.parse(pos, contents_node, expected))\n-        return false;\n-\n-    if (pos->type != TokenType::ClosingSquareBracket)\n-        return false;\n-    ++pos;\n-\n-    auto function_node = std::make_shared<ASTFunction>();\n-    function_node->name = \"array\";\n-    function_node->arguments = contents_node;\n-    function_node->children.push_back(contents_node);\n-    node = function_node;\n-\n-    return true;\n-}\n-\n-\n-bool ParserParenthesisExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ASTPtr contents_node;\n-    ParserExpressionList contents(false);\n-\n-    if (pos->type != TokenType::OpeningRoundBracket)\n-        return false;\n-    ++pos;\n-\n-    if (!contents.parse(pos, contents_node, expected))\n-        return false;\n-\n-    bool is_elem = true;\n-    if (pos->type == TokenType::Comma)\n-    {\n-        is_elem = false;\n-        ++pos;\n-    }\n-\n-    if (pos->type != TokenType::ClosingRoundBracket)\n-        return false;\n-    ++pos;\n-\n-    const auto & expr_list = contents_node->as<ASTExpressionList &>();\n-\n-    /// Empty expression in parentheses is not allowed.\n-    if (expr_list.children.empty())\n-    {\n-        expected.add(pos, \"non-empty parenthesized list of expressions\");\n-        return false;\n-    }\n-\n-    /// Special case for one-element tuple.\n-    if (expr_list.children.size() == 1 && is_elem)\n-    {\n-        auto * ast_literal = expr_list.children.front()->as<ASTLiteral>();\n-        /// But only if its argument is not tuple,\n-        /// since otherwise it will do incorrect transformation:\n-        ///\n-        ///     (foo,bar) IN (('foo','bar')) -> (foo,bar) IN ('foo','bar')\n-        if (!(ast_literal && ast_literal->value.getType() == Field::Types::Tuple))\n-        {\n-            node = expr_list.children.front();\n-            return true;\n-        }\n-    }\n-\n-    auto function_node = std::make_shared<ASTFunction>();\n-    function_node->name = \"tuple\";\n-    function_node->arguments = contents_node;\n-    function_node->children.push_back(contents_node);\n-    node = function_node;\n-\n-    return true;\n-}\n-\n-\n bool ParserSubquery::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     ASTPtr select_node;\n@@ -282,850 +199,10 @@ ASTPtr createFunctionCast(const ASTPtr & expr_ast, const ASTPtr & type_ast)\n {\n     /// Convert to canonical representation in functional form: CAST(expr, 'type')\n     auto type_literal = std::make_shared<ASTLiteral>(queryToString(type_ast));\n-\n-    auto expr_list_args = std::make_shared<ASTExpressionList>();\n-    expr_list_args->children.push_back(expr_ast);\n-    expr_list_args->children.push_back(std::move(type_literal));\n-\n-    auto func_node = std::make_shared<ASTFunction>();\n-    func_node->name = \"CAST\";\n-    func_node->arguments = std::move(expr_list_args);\n-    func_node->children.push_back(func_node->arguments);\n-\n-    return func_node;\n+    return makeASTFunction(\"CAST\", expr_ast, std::move(type_literal));\n }\n \n \n-namespace\n-{\n-    bool parseCastAs(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /** Possible variants for cast operator cast(expr [[AS] alias_1] AS Type), cast(expr [[AS] alias_1], type_expr [[as] alias_2]).\n-          * First try to match with cast(expr [[AS] alias_1] AS Type)\n-          * Then try to match with cast(expr [[AS] alias_1], type_expr [[as] alias_2]).\n-          */\n-\n-        ASTPtr expr_node;\n-        ASTPtr type_node;\n-        ASTPtr identifier_node;\n-\n-        if (ParserExpression().parse(pos, expr_node, expected))\n-        {\n-            ParserKeyword as_keyword_parser(\"AS\");\n-            bool parse_as = as_keyword_parser.ignore(pos, expected);\n-\n-            /// CAST (a b AS UInt32) OR CAST (a b, expr)\n-\n-            if (!parse_as && ParserIdentifier().parse(pos, identifier_node, expected))\n-            {\n-                expr_node->setAlias(getIdentifierName(identifier_node));\n-                parse_as = as_keyword_parser.ignore(pos, expected);\n-            }\n-\n-            if (parse_as)\n-            {\n-                /// CAST (a AS Type) OR CAST (a AS b AS Type) OR CAST (a AS b, expr)\n-\n-                auto begin = pos;\n-                auto expected_copy = expected;\n-                bool next_identifier = ParserIdentifier().ignore(begin, expected_copy);\n-                bool next_identifier_with_comma = next_identifier && ParserToken(TokenType::Comma).ignore(begin, expected_copy);\n-                bool next_identifier_with_as\n-                    = next_identifier && !next_identifier_with_comma && as_keyword_parser.ignore(begin, expected_copy);\n-\n-                if (next_identifier_with_as)\n-                {\n-                    if (ParserIdentifier().parse(pos, identifier_node, expected) && as_keyword_parser.ignore(pos, expected))\n-                        expr_node->setAlias(getIdentifierName(identifier_node));\n-                    else\n-                        return false;\n-                }\n-\n-                if (!next_identifier_with_comma && ParserDataType().parse(pos, type_node, expected))\n-                {\n-                    node = createFunctionCast(expr_node, type_node);\n-                    return true;\n-                }\n-            }\n-\n-            /// CAST(a AS b, expr)\n-\n-            if (parse_as)\n-            {\n-                if (ParserIdentifier().parse(pos, identifier_node, expected))\n-                    expr_node->setAlias(getIdentifierName(identifier_node));\n-                else\n-                    return false;\n-            }\n-\n-            if (ParserToken(TokenType::Comma).ignore(pos, expected)\n-                && ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, type_node, expected))\n-            {\n-                node = makeASTFunction(\"CAST\", expr_node, type_node);\n-                return true;\n-            }\n-        }\n-\n-        return false;\n-    }\n-\n-    bool parseSubstring(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /// Either SUBSTRING(expr FROM start) or SUBSTRING(expr FROM start FOR length) or SUBSTRING(expr, start, length)\n-        /// The latter will be parsed normally as a function later.\n-\n-        ParserKeyword as_keyword_parser(\"AS\");\n-        ParserIdentifier identifier_parser;\n-\n-        ASTPtr expr_node;\n-        ASTPtr start_node;\n-        ASTPtr length_node;\n-\n-        if (!ParserExpression().parse(pos, expr_node, expected))\n-            return false;\n-\n-        auto from_keyword_parser = ParserKeyword(\"FROM\");\n-        bool from_exists = from_keyword_parser.check(pos, expected);\n-\n-        if (!from_exists && pos->type != TokenType::Comma)\n-        {\n-            ASTPtr identifier_node;\n-            bool parsed_as = as_keyword_parser.ignore(pos, expected);\n-            bool parsed_identifer = identifier_parser.parse(pos, identifier_node, expected);\n-\n-            if (parsed_as && !parsed_identifer)\n-                return false;\n-\n-            if (parsed_identifer)\n-                expr_node->setAlias(getIdentifierName(identifier_node));\n-\n-            from_exists = from_keyword_parser.check(pos, expected);\n-        }\n-\n-        if (pos->type == TokenType::Comma)\n-        {\n-            if (from_exists)\n-                return false;\n-\n-            ++pos;\n-        }\n-\n-        if (!ParserExpression().parse(pos, start_node, expected))\n-            return false;\n-\n-        auto for_keyword_parser = ParserKeyword(\"FOR\");\n-        bool for_exists = for_keyword_parser.check(pos, expected);\n-        if (!for_exists && pos->type != TokenType::Comma)\n-        {\n-            ASTPtr identifier_node;\n-            bool parsed_as = as_keyword_parser.ignore(pos, expected);\n-            bool parsed_identifer = identifier_parser.parse(pos, identifier_node, expected);\n-            if (parsed_as && !parsed_identifer)\n-                return false;\n-\n-            if (parsed_identifer)\n-                start_node->setAlias(getIdentifierName(identifier_node));\n-\n-            for_exists = for_keyword_parser.check(pos, expected);\n-        }\n-\n-        bool need_parse_length_expression = for_exists;\n-        if (pos->type == TokenType::Comma)\n-        {\n-            if (for_exists)\n-                return false;\n-\n-            ++pos;\n-            need_parse_length_expression = true;\n-        }\n-\n-        if (need_parse_length_expression\n-            && !ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, length_node, expected))\n-            return false;\n-\n-        /// Convert to canonical representation in functional form: SUBSTRING(expr, start, length)\n-        if (length_node)\n-            node = makeASTFunction(\"substring\", expr_node, start_node, length_node);\n-        else\n-            node = makeASTFunction(\"substring\", expr_node, start_node);\n-\n-        return true;\n-    }\n-\n-    bool parseTrim(bool trim_left, bool trim_right, IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /// Handles all possible TRIM/LTRIM/RTRIM call variants ([[LEADING|TRAILING|BOTH] trim_character FROM] input_string)\n-\n-        std::string func_name;\n-        bool char_override = false;\n-        ASTPtr expr_node;\n-        ASTPtr pattern_node;\n-        ASTPtr to_remove;\n-\n-        if (!trim_left && !trim_right)\n-        {\n-            if (ParserKeyword(\"BOTH\").ignore(pos, expected))\n-            {\n-                trim_left = true;\n-                trim_right = true;\n-                char_override = true;\n-            }\n-            else if (ParserKeyword(\"LEADING\").ignore(pos, expected))\n-            {\n-                trim_left = true;\n-                char_override = true;\n-            }\n-            else if (ParserKeyword(\"TRAILING\").ignore(pos, expected))\n-            {\n-                trim_right = true;\n-                char_override = true;\n-            }\n-            else\n-            {\n-                trim_left = true;\n-                trim_right = true;\n-            }\n-\n-            if (char_override)\n-            {\n-                if (!ParserExpression().parse(pos, to_remove, expected))\n-                    return false;\n-\n-                auto from_keyword_parser = ParserKeyword(\"FROM\");\n-                bool from_exists = from_keyword_parser.check(pos, expected);\n-\n-                if (!from_exists)\n-                {\n-                    ASTPtr identifier_node;\n-                    bool parsed_as = ParserKeyword(\"AS\").ignore(pos, expected);\n-                    bool parsed_identifer = ParserIdentifier().parse(pos, identifier_node, expected);\n-\n-                    if (parsed_as && !parsed_identifer)\n-                        return false;\n-\n-                    if (parsed_identifer)\n-                        to_remove->setAlias(getIdentifierName(identifier_node));\n-\n-                    from_exists = from_keyword_parser.check(pos, expected);\n-                }\n-\n-                if (!from_exists)\n-                    return false;\n-\n-                auto quote_meta_func_node = std::make_shared<ASTFunction>();\n-                auto quote_meta_list_args = std::make_shared<ASTExpressionList>();\n-                quote_meta_list_args->children = {to_remove};\n-\n-                quote_meta_func_node->name = \"regexpQuoteMeta\";\n-                quote_meta_func_node->arguments = std::move(quote_meta_list_args);\n-                quote_meta_func_node->children.push_back(quote_meta_func_node->arguments);\n-\n-                to_remove = std::move(quote_meta_func_node);\n-            }\n-        }\n-\n-        if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, expr_node, expected))\n-            return false;\n-\n-        /// Convert to regexp replace function call\n-\n-        if (char_override)\n-        {\n-            auto pattern_func_node = std::make_shared<ASTFunction>();\n-            auto pattern_list_args = std::make_shared<ASTExpressionList>();\n-            if (trim_left && trim_right)\n-            {\n-                pattern_list_args->children\n-                    = {std::make_shared<ASTLiteral>(\"^[\"),\n-                       to_remove,\n-                       std::make_shared<ASTLiteral>(\"]+|[\"),\n-                       to_remove,\n-                       std::make_shared<ASTLiteral>(\"]+$\")};\n-                func_name = \"replaceRegexpAll\";\n-            }\n-            else\n-            {\n-                if (trim_left)\n-                {\n-                    pattern_list_args->children = {std::make_shared<ASTLiteral>(\"^[\"), to_remove, std::make_shared<ASTLiteral>(\"]+\")};\n-                }\n-                else\n-                {\n-                    /// trim_right == false not possible\n-                    pattern_list_args->children = {std::make_shared<ASTLiteral>(\"[\"), to_remove, std::make_shared<ASTLiteral>(\"]+$\")};\n-                }\n-                func_name = \"replaceRegexpOne\";\n-            }\n-\n-            pattern_func_node->name = \"concat\";\n-            pattern_func_node->arguments = std::move(pattern_list_args);\n-            pattern_func_node->children.push_back(pattern_func_node->arguments);\n-\n-            pattern_node = std::move(pattern_func_node);\n-        }\n-        else\n-        {\n-            if (trim_left && trim_right)\n-            {\n-                func_name = \"trimBoth\";\n-            }\n-            else\n-            {\n-                if (trim_left)\n-                {\n-                    func_name = \"trimLeft\";\n-                }\n-                else\n-                {\n-                    /// trim_right == false not possible\n-                    func_name = \"trimRight\";\n-                }\n-            }\n-        }\n-\n-        if (char_override)\n-            node = makeASTFunction(func_name, expr_node, pattern_node, std::make_shared<ASTLiteral>(\"\"));\n-        else\n-            node = makeASTFunction(func_name, expr_node);\n-        return true;\n-    }\n-\n-    bool parseExtract(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /// First try to match with date extract operator EXTRACT(part FROM date)\n-        /// Then with function extract(haystack, pattern)\n-\n-        IParser::Pos begin = pos;\n-        IntervalKind interval_kind;\n-\n-        if (parseIntervalKind(pos, expected, interval_kind))\n-        {\n-            ASTPtr expr;\n-\n-            ParserKeyword s_from(\"FROM\");\n-            ParserExpressionWithOptionalAlias elem_parser(true /*allow_alias_without_as_keyword*/);\n-\n-            if (s_from.ignore(pos, expected) && elem_parser.parse(pos, expr, expected))\n-            {\n-                node = makeASTFunction(interval_kind.toNameOfFunctionExtractTimePart(), expr);\n-                return true;\n-            }\n-        }\n-\n-        pos = begin;\n-\n-        ASTPtr expr_list;\n-        if (!ParserExpressionList(true /*allow_alias_without_as_keyword*/).parse(pos, expr_list, expected))\n-            return false;\n-\n-        auto res = std::make_shared<ASTFunction>();\n-        res->name = \"extract\";\n-        res->arguments = expr_list;\n-        res->children.push_back(res->arguments);\n-        node = std::move(res);\n-        return true;\n-    }\n-\n-    bool parsePosition(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /// First try to match with position(needle IN haystack)\n-        /// Then with position(haystack, needle[, start_pos])\n-\n-        ParserExpressionWithOptionalAlias expr_parser(true /*allow_alias_without_as_keyword*/);\n-\n-        ASTPtr first_arg_expr_node;\n-        if (!expr_parser.parse(pos, first_arg_expr_node, expected))\n-        {\n-            return false;\n-        }\n-\n-        ASTFunction * func_in = typeid_cast<ASTFunction *>(first_arg_expr_node.get());\n-        if (func_in && func_in->name == \"in\")\n-        {\n-            ASTExpressionList * in_args = typeid_cast<ASTExpressionList *>(func_in->arguments.get());\n-            if (in_args && in_args->children.size() == 2)\n-            {\n-                node = makeASTFunction(\"position\", in_args->children[1], in_args->children[0]);\n-                return true;\n-            }\n-        }\n-\n-        if (pos->type != TokenType::Comma)\n-            return false;\n-        ++pos;\n-\n-        ASTPtr second_arg_expr_node;\n-        if (!expr_parser.parse(pos, second_arg_expr_node, expected))\n-        {\n-            return false;\n-        }\n-\n-        ASTPtr start_pos_expr_node;\n-        if (pos->type == TokenType::Comma)\n-        {\n-            ++pos;\n-\n-            if (!expr_parser.parse(pos, start_pos_expr_node, expected))\n-                return false;\n-        }\n-\n-        auto arguments = std::make_shared<ASTExpressionList>();\n-        arguments->children.push_back(std::move(first_arg_expr_node));\n-        arguments->children.push_back(std::move(second_arg_expr_node));\n-\n-        if (start_pos_expr_node)\n-            arguments->children.push_back(std::move(start_pos_expr_node));\n-\n-        auto res = std::make_shared<ASTFunction>();\n-        res->name = \"position\";\n-        res->arguments = std::move(arguments);\n-        res->children.push_back(res->arguments);\n-        node = std::move(res);\n-        return true;\n-    }\n-\n-    bool parseDateAdd(const char * function_name, IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /// First to match with function(unit, offset, timestamp)\n-        /// Then with function(offset, timestamp)\n-\n-        ASTPtr timestamp_node;\n-        ASTPtr offset_node;\n-\n-        IntervalKind interval_kind;\n-        ASTPtr interval_func_node;\n-        if (parseIntervalKind(pos, expected, interval_kind))\n-        {\n-            if (pos->type != TokenType::Comma)\n-                return false;\n-            ++pos;\n-\n-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, offset_node, expected))\n-                return false;\n-\n-            if (pos->type != TokenType::Comma)\n-                return false;\n-            ++pos;\n-\n-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, timestamp_node, expected))\n-                return false;\n-            auto interval_expr_list_args = std::make_shared<ASTExpressionList>();\n-            interval_expr_list_args->children = {offset_node};\n-\n-            interval_func_node = std::make_shared<ASTFunction>();\n-            interval_func_node->as<ASTFunction &>().name = interval_kind.toNameOfFunctionToIntervalDataType();\n-            interval_func_node->as<ASTFunction &>().arguments = std::move(interval_expr_list_args);\n-            interval_func_node->as<ASTFunction &>().children.push_back(interval_func_node->as<ASTFunction &>().arguments);\n-        }\n-        else\n-        {\n-            ASTPtr expr_list;\n-            if (!ParserExpressionList(true /*allow_alias_without_as_keyword*/).parse(pos, expr_list, expected))\n-                return false;\n-\n-            auto res = std::make_shared<ASTFunction>();\n-            res->name = function_name;\n-            res->arguments = expr_list;\n-            res->children.push_back(res->arguments);\n-            node = std::move(res);\n-            return true;\n-        }\n-\n-        node = makeASTFunction(function_name, timestamp_node, interval_func_node);\n-        return true;\n-    }\n-\n-    bool parseDateDiff(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        /// First to match with dateDiff(unit, startdate, enddate, [timezone])\n-        /// Then with dateDiff('unit', startdate, enddate, [timezone])\n-\n-        ASTPtr left_node;\n-        ASTPtr right_node;\n-\n-        IntervalKind interval_kind;\n-        if (parseIntervalKind(pos, expected, interval_kind))\n-        {\n-            if (pos->type != TokenType::Comma)\n-                return false;\n-            ++pos;\n-\n-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, left_node, expected))\n-                return false;\n-\n-            if (pos->type != TokenType::Comma)\n-                return false;\n-            ++pos;\n-\n-            if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, right_node, expected))\n-                return false;\n-\n-            ASTPtr timezone_node;\n-\n-            if (pos->type == TokenType::Comma)\n-            {\n-                /// Optional timezone\n-                ++pos;\n-\n-                if (!ParserExpressionWithOptionalAlias(true /*allow_alias_without_as_keyword*/).parse(pos, timezone_node, expected))\n-                    return false;\n-            }\n-\n-            auto interval_literal = std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit());\n-            if (timezone_node)\n-                node = makeASTFunction(\"dateDiff\", std::move(interval_literal), std::move(left_node), std::move(right_node), std::move(timezone_node));\n-            else\n-                node = makeASTFunction(\"dateDiff\", std::move(interval_literal), std::move(left_node), std::move(right_node));\n-\n-            return true;\n-        }\n-\n-        ASTPtr expr_list;\n-        if (!ParserExpressionList(true /*allow_alias_without_as_keyword*/).parse(pos, expr_list, expected))\n-            return false;\n-\n-        auto res = std::make_shared<ASTFunction>();\n-        res->name = \"dateDiff\";\n-        res->arguments = expr_list;\n-        res->children.push_back(res->arguments);\n-        node = std::move(res);\n-\n-        return true;\n-    }\n-\n-    bool parseExists(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        if (!ParserSelectWithUnionQuery().parse(pos, node, expected))\n-            return false;\n-\n-        auto subquery = std::make_shared<ASTSubquery>();\n-        subquery->children.push_back(node);\n-        node = makeASTFunction(\"exists\", subquery);\n-        return true;\n-    }\n-\n-    bool parseGrouping(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n-    {\n-        ASTPtr expr_list;\n-        if (!ParserExpressionList(false, false).parse(pos, expr_list, expected))\n-            return false;\n-\n-        auto res = std::make_shared<ASTFunction>();\n-        res->name = \"grouping\";\n-        res->arguments = expr_list;\n-        res->children.push_back(res->arguments);\n-        node = std::move(res);\n-        return true;\n-    }\n-}\n-\n-\n-bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ParserIdentifier id_parser;\n-\n-    bool has_all = false;\n-    bool has_distinct = false;\n-\n-    ASTPtr identifier;\n-    ASTPtr query;\n-    ASTPtr expr_list_args;\n-    ASTPtr expr_list_params;\n-\n-    if (is_table_function)\n-    {\n-        if (ParserTableFunctionView().parse(pos, node, expected))\n-            return true;\n-    }\n-\n-    if (!id_parser.parse(pos, identifier, expected))\n-        return false;\n-\n-    if (pos->type != TokenType::OpeningRoundBracket)\n-        return false;\n-    ++pos;\n-\n-    /// Avoid excessive backtracking.\n-    //pos.putBarrier();\n-\n-    /// Special cases for expressions that look like functions but contain some syntax sugar:\n-\n-    /// CAST, EXTRACT, POSITION, EXISTS\n-    /// DATE_ADD, DATEADD, TIMESTAMPADD, DATE_SUB, DATESUB, TIMESTAMPSUB,\n-    /// DATE_DIFF, DATEDIFF, TIMESTAMPDIFF, TIMESTAMP_DIFF,\n-    /// SUBSTRING, TRIM, LTRIM, RTRIM, POSITION\n-\n-    /// Can be parsed as a composition of functions, but the contents must be unwrapped:\n-    /// POSITION(x IN y) -> POSITION(in(x, y)) -> POSITION(y, x)\n-\n-    /// Can be parsed as a function, but not always:\n-    /// CAST(x AS type) - alias has to be unwrapped\n-    /// CAST(x AS type(params))\n-\n-    /// Can be parsed as a function, but some identifier arguments have special meanings.\n-    /// DATE_ADD(MINUTE, x, y) -> addMinutes(x, y)\n-    /// DATE_DIFF(MINUTE, x, y)\n-\n-    /// Have keywords that have to processed explicitly:\n-    /// EXTRACT(x FROM y)\n-    /// TRIM(BOTH|LEADING|TRAILING x FROM y)\n-    /// SUBSTRING(x FROM a)\n-    /// SUBSTRING(x FROM a FOR b)\n-\n-    String function_name = getIdentifierName(identifier);\n-    String function_name_lowercase = Poco::toLower(function_name);\n-\n-    std::optional<bool> parsed_special_function;\n-\n-    if (function_name_lowercase == \"cast\")\n-        parsed_special_function = parseCastAs(pos, node, expected);\n-    else if (function_name_lowercase == \"extract\")\n-        parsed_special_function = parseExtract(pos, node, expected);\n-    else if (function_name_lowercase == \"substring\")\n-        parsed_special_function = parseSubstring(pos, node, expected);\n-    else if (function_name_lowercase == \"position\")\n-        parsed_special_function = parsePosition(pos, node, expected);\n-    else if (function_name_lowercase == \"exists\")\n-        parsed_special_function = parseExists(pos, node, expected);\n-    else if (function_name_lowercase == \"trim\")\n-        parsed_special_function = parseTrim(false, false, pos, node, expected);\n-    else if (function_name_lowercase == \"ltrim\")\n-        parsed_special_function = parseTrim(true, false, pos, node, expected);\n-    else if (function_name_lowercase == \"rtrim\")\n-        parsed_special_function = parseTrim(false, true, pos, node, expected);\n-    else if (function_name_lowercase == \"dateadd\" || function_name_lowercase == \"date_add\"\n-        || function_name_lowercase == \"timestampadd\" || function_name_lowercase == \"timestamp_add\")\n-        parsed_special_function = parseDateAdd(\"plus\", pos, node, expected);\n-    else if (function_name_lowercase == \"datesub\" || function_name_lowercase == \"date_sub\"\n-        || function_name_lowercase == \"timestampsub\" || function_name_lowercase == \"timestamp_sub\")\n-        parsed_special_function = parseDateAdd(\"minus\", pos, node, expected);\n-    else if (function_name_lowercase == \"datediff\" || function_name_lowercase == \"date_diff\"\n-        || function_name_lowercase == \"timestampdiff\" || function_name_lowercase == \"timestamp_diff\")\n-        parsed_special_function = parseDateDiff(pos, node, expected);\n-    else if (function_name_lowercase == \"grouping\")\n-        parsed_special_function = parseGrouping(pos, node, expected);\n-\n-    if (parsed_special_function.has_value())\n-        return parsed_special_function.value() && ParserToken(TokenType::ClosingRoundBracket).ignore(pos);\n-\n-    auto pos_after_bracket = pos;\n-    auto old_expected = expected;\n-\n-    ParserKeyword all(\"ALL\");\n-    ParserKeyword distinct(\"DISTINCT\");\n-\n-    if (all.ignore(pos, expected))\n-        has_all = true;\n-\n-    if (distinct.ignore(pos, expected))\n-        has_distinct = true;\n-\n-    if (!has_all && all.ignore(pos, expected))\n-        has_all = true;\n-\n-    if (has_all && has_distinct)\n-        return false;\n-\n-    if (has_all || has_distinct)\n-    {\n-        /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier\n-        if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)\n-        {\n-            pos = pos_after_bracket;\n-            expected = old_expected;\n-            has_all = false;\n-            has_distinct = false;\n-        }\n-    }\n-\n-    ParserExpressionList contents(false, is_table_function);\n-\n-    const char * contents_begin = pos->begin;\n-    if (!contents.parse(pos, expr_list_args, expected))\n-        return false;\n-    const char * contents_end = pos->begin;\n-\n-    if (pos->type != TokenType::ClosingRoundBracket)\n-        return false;\n-    ++pos;\n-\n-    /** Check for a common error case - often due to the complexity of quoting command-line arguments,\n-      *  an expression of the form toDate(2014-01-01) appears in the query instead of toDate('2014-01-01').\n-      * If you do not report that the first option is an error, then the argument will be interpreted as 2014 - 01 - 01 - some number,\n-      *  and the query silently returns an unexpected result.\n-      */\n-    if (function_name == \"toDate\"\n-        && contents_end - contents_begin == strlen(\"2014-01-01\")\n-        && contents_begin[0] >= '2' && contents_begin[0] <= '3'\n-        && contents_begin[1] >= '0' && contents_begin[1] <= '9'\n-        && contents_begin[2] >= '0' && contents_begin[2] <= '9'\n-        && contents_begin[3] >= '0' && contents_begin[3] <= '9'\n-        && contents_begin[4] == '-'\n-        && contents_begin[5] >= '0' && contents_begin[5] <= '9'\n-        && contents_begin[6] >= '0' && contents_begin[6] <= '9'\n-        && contents_begin[7] == '-'\n-        && contents_begin[8] >= '0' && contents_begin[8] <= '9'\n-        && contents_begin[9] >= '0' && contents_begin[9] <= '9')\n-    {\n-        std::string contents_str(contents_begin, contents_end - contents_begin);\n-        throw Exception(\"Argument of function toDate is unquoted: toDate(\" + contents_str + \"), must be: toDate('\" + contents_str + \"')\"\n-            , ErrorCodes::SYNTAX_ERROR);\n-    }\n-\n-    /// The parametric aggregate function has two lists (parameters and arguments) in parentheses. Example: quantile(0.9)(x).\n-    if (allow_function_parameters && pos->type == TokenType::OpeningRoundBracket)\n-    {\n-        ++pos;\n-\n-        /// Parametric aggregate functions cannot have DISTINCT in parameters list.\n-        if (has_distinct)\n-            return false;\n-\n-        expr_list_params = expr_list_args;\n-        expr_list_args = nullptr;\n-\n-        pos_after_bracket = pos;\n-        old_expected = expected;\n-\n-        if (all.ignore(pos, expected))\n-            has_all = true;\n-\n-        if (distinct.ignore(pos, expected))\n-            has_distinct = true;\n-\n-        if (!has_all && all.ignore(pos, expected))\n-            has_all = true;\n-\n-        if (has_all && has_distinct)\n-            return false;\n-\n-        if (has_all || has_distinct)\n-        {\n-            /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier\n-            if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)\n-            {\n-                pos = pos_after_bracket;\n-                expected = old_expected;\n-                has_distinct = false;\n-            }\n-        }\n-\n-        if (!contents.parse(pos, expr_list_args, expected))\n-            return false;\n-\n-        if (pos->type != TokenType::ClosingRoundBracket)\n-            return false;\n-        ++pos;\n-    }\n-\n-    auto function_node = std::make_shared<ASTFunction>();\n-    tryGetIdentifierNameInto(identifier, function_node->name);\n-\n-    /// func(DISTINCT ...) is equivalent to funcDistinct(...)\n-    if (has_distinct)\n-        function_node->name += \"Distinct\";\n-\n-    function_node->arguments = expr_list_args;\n-    function_node->children.push_back(function_node->arguments);\n-\n-    if (expr_list_params)\n-    {\n-        function_node->parameters = expr_list_params;\n-        function_node->children.push_back(function_node->parameters);\n-    }\n-\n-    ParserKeyword filter(\"FILTER\");\n-    ParserKeyword over(\"OVER\");\n-\n-    if (filter.ignore(pos, expected))\n-    {\n-        // We are slightly breaking the parser interface by parsing the window\n-        // definition into an existing ASTFunction. Normally it would take a\n-        // reference to ASTPtr and assign it the new node. We only have a pointer\n-        // of a different type, hence this workaround with a temporary pointer.\n-        ASTPtr function_node_as_iast = function_node;\n-\n-        ParserFilterClause filter_parser;\n-        if (!filter_parser.parse(pos, function_node_as_iast, expected))\n-            return false;\n-    }\n-\n-    if (over.ignore(pos, expected))\n-    {\n-        function_node->is_window_function = true;\n-\n-        ASTPtr function_node_as_iast = function_node;\n-\n-        ParserWindowReference window_reference;\n-        if (!window_reference.parse(pos, function_node_as_iast, expected))\n-            return false;\n-    }\n-\n-    node = function_node;\n-    return true;\n-}\n-\n-bool ParserTableFunctionView::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ParserIdentifier id_parser;\n-    ParserSelectWithUnionQuery select;\n-\n-    ASTPtr identifier;\n-    ASTPtr query;\n-\n-    bool if_permitted = false;\n-\n-    if (ParserKeyword{\"VIEWIFPERMITTED\"}.ignore(pos, expected))\n-        if_permitted = true;\n-    else if (!ParserKeyword{\"VIEW\"}.ignore(pos, expected))\n-        return false;\n-\n-    if (pos->type != TokenType::OpeningRoundBracket)\n-        return false;\n-\n-    ++pos;\n-\n-    bool maybe_an_subquery = pos->type == TokenType::OpeningRoundBracket;\n-\n-    if (!select.parse(pos, query, expected))\n-        return false;\n-\n-    auto & select_ast = query->as<ASTSelectWithUnionQuery &>();\n-    if (select_ast.list_of_selects->children.size() == 1 && maybe_an_subquery)\n-    {\n-        // It's an subquery. Bail out.\n-        return false;\n-    }\n-\n-    ASTPtr else_ast;\n-    if (if_permitted)\n-    {\n-        if (!ParserKeyword{\"ELSE\"}.ignore(pos, expected))\n-            return false;\n-\n-        if (!ParserWithOptionalAlias{std::make_unique<ParserFunction>(true, true), true}.parse(pos, else_ast, expected))\n-            return false;\n-    }\n-\n-    if (pos->type != TokenType::ClosingRoundBracket)\n-        return false;\n-\n-    ++pos;\n-\n-    auto expr_list = std::make_shared<ASTExpressionList>();\n-    expr_list->children.push_back(query);\n-    if (if_permitted)\n-        expr_list->children.push_back(else_ast);\n-\n-    auto function_node = std::make_shared<ASTFunction>();\n-    tryGetIdentifierNameInto(identifier, function_node->name);\n-    function_node->name = if_permitted ? \"viewIfPermitted\" : \"view\";\n-    function_node->arguments = expr_list;\n-    function_node->children.push_back(function_node->arguments);\n-    node = function_node;\n-    return true;\n-}\n-\n bool ParserFilterClause::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     assert(node);\n@@ -1865,42 +942,63 @@ bool ParserStringLiteral::parseImpl(Pos & pos, ASTPtr & node, Expected & expecte\n     return true;\n }\n \n+template <typename Collection>\n+struct CollectionOfLiteralsLayer\n+{\n+    explicit CollectionOfLiteralsLayer(IParser::Pos & pos) : literal_begin(pos)\n+    {\n+        ++pos;\n+    }\n+\n+    IParser::Pos literal_begin;\n+    Collection arr;\n+};\n+\n template <typename Collection>\n bool ParserCollectionOfLiterals<Collection>::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     if (pos->type != opening_bracket)\n         return false;\n \n-    Pos literal_begin = pos;\n+    std::vector<CollectionOfLiteralsLayer<Collection>> layers;\n+    layers.emplace_back(pos);\n+    pos.increaseDepth();\n \n-    Collection arr;\n     ParserLiteral literal_p;\n-    ParserCollectionOfLiterals<Collection> collection_p(opening_bracket, closing_bracket);\n \n-    ++pos;\n     while (pos.isValid())\n     {\n-        if (!arr.empty())\n+        if (!layers.back().arr.empty())\n         {\n             if (pos->type == closing_bracket)\n             {\n                 std::shared_ptr<ASTLiteral> literal;\n \n                 /// Parse one-element tuples (e.g. (1)) later as single values for backward compatibility.\n-                if (std::is_same_v<Collection, Tuple> && arr.size() == 1)\n+                if (std::is_same_v<Collection, Tuple> && layers.back().arr.size() == 1)\n                     return false;\n \n-                literal = std::make_shared<ASTLiteral>(std::move(arr));\n-                literal->begin = literal_begin;\n+                literal = std::make_shared<ASTLiteral>(std::move(layers.back().arr));\n+                literal->begin = layers.back().literal_begin;\n                 literal->end = ++pos;\n-                node = literal;\n-                return true;\n+\n+                layers.pop_back();\n+                pos.decreaseDepth();\n+\n+                if (layers.empty())\n+                {\n+                    node = literal;\n+                    return true;\n+                }\n+\n+                layers.back().arr.push_back(literal->value);\n+                continue;\n             }\n             else if (pos->type == TokenType::Comma)\n             {\n                 ++pos;\n             }\n-            else if (pos->type == TokenType::Colon && std::is_same_v<Collection, Map> && arr.size() % 2 == 1)\n+            else if (pos->type == TokenType::Colon && std::is_same_v<Collection, Map> && layers.back().arr.size() % 2 == 1)\n             {\n                 ++pos;\n             }\n@@ -1912,10 +1010,17 @@ bool ParserCollectionOfLiterals<Collection>::parseImpl(Pos & pos, ASTPtr & node,\n         }\n \n         ASTPtr literal_node;\n-        if (!literal_p.parse(pos, literal_node, expected) && !collection_p.parse(pos, literal_node, expected))\n+        if (literal_p.parse(pos, literal_node, expected))\n+        {\n+            layers.back().arr.push_back(literal_node->as<ASTLiteral &>().value);\n+        }\n+        else if (pos->type == opening_bracket)\n+        {\n+            layers.emplace_back(pos);\n+            pos.increaseDepth();\n+        }\n+        else\n             return false;\n-\n-        arr.push_back(literal_node->as<ASTLiteral &>().value);\n     }\n \n     expected.add(pos, getTokenName(closing_bracket));\n@@ -2093,7 +1198,7 @@ bool ParserColumnsTransformers::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n         ASTPtr func_name;\n         ASTPtr expr_list_args;\n         auto opos = pos;\n-        if (ParserLambdaExpression().parse(pos, lambda, expected))\n+        if (ParserExpression().parse(pos, lambda, expected))\n         {\n             if (const auto * func = lambda->as<ASTFunction>(); func && func->name == \"lambda\")\n             {\n@@ -2396,38 +1501,10 @@ bool ParserMySQLGlobalVariable::parseImpl(Pos & pos, ASTPtr & node, Expected & e\n     }\n \n     auto name_literal = std::make_shared<ASTLiteral>(name);\n-\n-    auto expr_list_args = std::make_shared<ASTExpressionList>();\n-    expr_list_args->children.push_back(std::move(name_literal));\n-\n-    auto function_node = std::make_shared<ASTFunction>();\n-    function_node->name = \"globalVariable\";\n-    function_node->arguments = expr_list_args;\n-    function_node->children.push_back(expr_list_args);\n-\n-    node = function_node;\n+    node = makeASTFunction(\"globalVariable\", name_literal);\n     node->setAlias(\"@@\" + name);\n-    return true;\n-}\n \n-\n-bool ParserExpressionElement::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    return ParserSubquery().parse(pos, node, expected)\n-        || ParserCastOperator().parse(pos, node, expected)\n-        || ParserTupleOfLiterals().parse(pos, node, expected)\n-        || ParserParenthesisExpression().parse(pos, node, expected)\n-        || ParserArrayOfLiterals().parse(pos, node, expected)\n-        || ParserArray().parse(pos, node, expected)\n-        || ParserLiteral().parse(pos, node, expected)\n-        || ParserCase().parse(pos, node, expected)\n-        || ParserColumnsMatcher().parse(pos, node, expected) /// before ParserFunction because it can be also parsed as a function.\n-        || ParserFunction().parse(pos, node, expected)\n-        || ParserQualifiedAsterisk().parse(pos, node, expected)\n-        || ParserAsterisk().parse(pos, node, expected)\n-        || ParserCompoundIdentifier(false, true).parse(pos, node, expected)\n-        || ParserSubstitution().parse(pos, node, expected)\n-        || ParserMySQLGlobalVariable().parse(pos, node, expected);\n+    return true;\n }\n \n \ndiff --git a/src/Parsers/ExpressionElementParsers.h b/src/Parsers/ExpressionElementParsers.h\nindex 3883631b61cb..f538555f0c1d 100644\n--- a/src/Parsers/ExpressionElementParsers.h\n+++ b/src/Parsers/ExpressionElementParsers.h\n@@ -9,26 +9,6 @@ namespace DB\n {\n \n \n-class ParserArray : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"array\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-/** If in parenthesis an expression from one element - returns this element in `node`;\n-  *  or if there is a SELECT subquery in parenthesis, then this subquery returned in `node`;\n-  *  otherwise returns `tuple` function from the contents of brackets.\n-  */\n-class ParserParenthesisExpression : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"parenthesized expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n /** The SELECT subquery is in parenthesis.\n   */\n class ParserSubquery : public IParserBase\n@@ -141,36 +121,6 @@ class ParserColumnsMatcher : public IParserBase\n     ColumnTransformers allowed_transformers;\n };\n \n-/** A function, for example, f(x, y + 1, g(z)).\n-  * Or an aggregate function: sum(x + f(y)), corr(x, y). The syntax is the same as the usual function.\n-  * Or a parametric aggregate function: quantile(0.9)(x + y).\n-  *  Syntax - two pairs of parentheses instead of one. The first is for parameters, the second for arguments.\n-  * For functions, the DISTINCT modifier can be specified, for example, count(DISTINCT x, y).\n-  */\n-class ParserFunction : public IParserBase\n-{\n-public:\n-    explicit ParserFunction(bool allow_function_parameters_ = true, bool is_table_function_ = false)\n-        : allow_function_parameters(allow_function_parameters_), is_table_function(is_table_function_)\n-    {\n-    }\n-\n-protected:\n-    const char * getName() const override { return \"function\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-    bool allow_function_parameters;\n-    bool is_table_function;\n-};\n-\n-// A special function parser for view and viewIfPermitted table functions.\n-// It parses an SELECT query as its argument and doesn't support getColumnName().\n-class ParserTableFunctionView : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"function\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n // Allows to make queries like SELECT SUM(<expr>) FILTER(WHERE <cond>) FROM ...\n class ParserFilterClause : public IParserBase\n {\n@@ -394,16 +344,6 @@ class ParserMySQLGlobalVariable : public IParserBase\n };\n \n \n-/** The expression element is one of: an expression in parentheses, an array, a literal, a function, an identifier, an asterisk.\n-  */\n-class ParserExpressionElement : public IParserBase\n-{\n-protected:\n-    const char * getName() const override { return \"element of expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n /** An expression element, possibly with an alias, if appropriate.\n   */\n class ParserWithOptionalAlias : public IParserBase\ndiff --git a/src/Parsers/ExpressionListParsers.cpp b/src/Parsers/ExpressionListParsers.cpp\nindex 4e88e5c68e6a..f7a016a59e40 100644\n--- a/src/Parsers/ExpressionListParsers.cpp\n+++ b/src/Parsers/ExpressionListParsers.cpp\n@@ -19,80 +19,21 @@\n #include <Parsers/parseIntervalKind.h>\n #include <Common/StringUtils/StringUtils.h>\n \n-using namespace std::literals;\n-\n-\n-namespace DB\n-{\n-\n-const char * ParserMultiplicativeExpression::operators[] =\n-{\n-    \"*\",     \"multiply\",\n-    \"/\",     \"divide\",\n-    \"%\",     \"modulo\",\n-    \"MOD\",   \"modulo\",\n-    \"DIV\",   \"intDiv\",\n-    nullptr\n-};\n-\n-const char * ParserUnaryExpression::operators[] =\n-{\n-    \"-\",     \"negate\",\n-    \"NOT\",   \"not\",\n-    nullptr\n-};\n-\n-const char * ParserAdditiveExpression::operators[] =\n-{\n-    \"+\",     \"plus\",\n-    \"-\",     \"minus\",\n-    nullptr\n-};\n+#include <Parsers/ParserSelectWithUnionQuery.h>\n \n-const char * ParserComparisonExpression::operators[] =\n-{\n-    \"==\",            \"equals\",\n-    \"!=\",            \"notEquals\",\n-    \"<>\",            \"notEquals\",\n-    \"<=\",            \"lessOrEquals\",\n-    \">=\",            \"greaterOrEquals\",\n-    \"<\",             \"less\",\n-    \">\",             \"greater\",\n-    \"=\",             \"equals\",\n-    \"LIKE\",          \"like\",\n-    \"ILIKE\",         \"ilike\",\n-    \"NOT LIKE\",      \"notLike\",\n-    \"NOT ILIKE\",     \"notILike\",\n-    \"IN\",            \"in\",\n-    \"NOT IN\",        \"notIn\",\n-    \"GLOBAL IN\",     \"globalIn\",\n-    \"GLOBAL NOT IN\", \"globalNotIn\",\n-    nullptr\n-};\n+#include <Common/logger_useful.h>\n+#include <Parsers/queryToString.h>\n \n-const char * ParserComparisonExpression::overlapping_operators_to_skip[] =\n-{\n-    \"IN PARTITION\",\n-    nullptr\n-};\n+using namespace std::literals;\n \n-const char * ParserLogicalNotExpression::operators[] =\n-{\n-    \"NOT\", \"not\",\n-    nullptr\n-};\n \n-const char * ParserArrayElementExpression::operators[] =\n+namespace DB\n {\n-    \"[\", \"arrayElement\",\n-    nullptr\n-};\n \n-const char * ParserTupleElementExpression::operators[] =\n+namespace ErrorCodes\n {\n-    \".\", \"tupleElement\",\n-    nullptr\n-};\n+    extern const int SYNTAX_ERROR;\n+}\n \n \n bool ParserList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n@@ -298,7 +239,7 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node\n         if (first)\n         {\n             ASTPtr elem;\n-            if (!first_elem_parser->parse(pos, elem, expected))\n+            if (!elem_parser->parse(pos, elem, expected))\n                 return false;\n \n             node = elem;\n@@ -307,16 +248,7 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node\n         else\n         {\n             /// try to find any of the valid operators\n-\n             const char ** it;\n-            Expected stub;\n-            for (it = overlapping_operators_to_skip; *it; ++it)\n-                if (ParserKeyword{*it}.checkWithoutMoving(pos, stub))\n-                    break;\n-\n-            if (*it)\n-                break;\n-\n             for (it = operators; *it; it += 2)\n                 if (parseOperator(pos, *it, expected))\n                     break;\n@@ -324,40 +256,13 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node\n             if (!*it)\n                 break;\n \n-            /// the function corresponding to the operator\n-            auto function = std::make_shared<ASTFunction>();\n-\n-            /// function arguments\n-            auto exp_list = std::make_shared<ASTExpressionList>();\n-\n             ASTPtr elem;\n-            SubqueryFunctionType subquery_function_type = SubqueryFunctionType::NONE;\n-\n-            if (comparison_expression)\n-            {\n-                if (ParserKeyword(\"ANY\").ignore(pos, expected))\n-                    subquery_function_type = SubqueryFunctionType::ANY;\n-                else if (ParserKeyword(\"ALL\").ignore(pos, expected))\n-                    subquery_function_type = SubqueryFunctionType::ALL;\n-            }\n \n-            if (subquery_function_type != SubqueryFunctionType::NONE && !ParserSubquery().parse(pos, elem, expected))\n-                subquery_function_type = SubqueryFunctionType::NONE;\n-\n-            if (subquery_function_type == SubqueryFunctionType::NONE\n-                && !(remaining_elem_parser ? remaining_elem_parser : first_elem_parser)->parse(pos, elem, expected))\n+            if (!elem_parser->parse(pos, elem, expected))\n                 return false;\n \n             /// the first argument of the function is the previous element, the second is the next one\n-            function->name = it[1];\n-            function->arguments = exp_list;\n-            function->children.push_back(exp_list);\n-\n-            exp_list->children.push_back(node);\n-            exp_list->children.push_back(elem);\n-\n-            if (comparison_expression && subquery_function_type != SubqueryFunctionType::NONE && !modifyAST(function, subquery_function_type))\n-                return false;\n+            auto function = makeASTFunction(it[1], node, elem);\n \n             /** special exception for the access operator to the element of the array `x[y]`, which\n               * contains the infix part '[' and the suffix ''] '(specified as' [')\n@@ -381,369 +286,24 @@ bool ParserLeftAssociativeBinaryOperatorList::parseImpl(Pos & pos, ASTPtr & node\n }\n \n \n-bool ParserVariableArityOperatorList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ASTPtr arguments;\n-\n-    if (!elem_parser->parse(pos, node, expected))\n-        return false;\n-\n-    while (true)\n-    {\n-        if (!parseOperator(pos, infix, expected))\n-            break;\n-\n-        if (!arguments)\n-        {\n-            node = makeASTFunction(function_name, node);\n-            arguments = node->as<ASTFunction &>().arguments;\n-        }\n-\n-        ASTPtr elem;\n-        if (!elem_parser->parse(pos, elem, expected))\n-            return false;\n-\n-        arguments->children.push_back(elem);\n-    }\n-\n-    return true;\n-}\n-\n-bool ParserBetweenExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    /// For the expression (subject [NOT] BETWEEN left AND right)\n-    /// create an AST the same as for (subject >= left AND subject <= right).\n-\n-    ParserKeyword s_not(\"NOT\");\n-    ParserKeyword s_between(\"BETWEEN\");\n-    ParserKeyword s_and(\"AND\");\n-\n-    ASTPtr subject;\n-    ASTPtr left;\n-    ASTPtr right;\n-\n-    if (!elem_parser.parse(pos, subject, expected))\n-        return false;\n-\n-    bool negative = s_not.ignore(pos, expected);\n-\n-    if (!s_between.ignore(pos, expected))\n-    {\n-        if (negative)\n-            --pos;\n-\n-        /// No operator was parsed, just return element.\n-        node = subject;\n-    }\n-    else\n-    {\n-        if (!elem_parser.parse(pos, left, expected))\n-            return false;\n-\n-        if (!s_and.ignore(pos, expected))\n-            return false;\n-\n-        if (!elem_parser.parse(pos, right, expected))\n-            return false;\n-\n-        auto f_combined_expression = std::make_shared<ASTFunction>();\n-        auto args_combined_expression = std::make_shared<ASTExpressionList>();\n-\n-        /// [NOT] BETWEEN left AND right\n-        auto f_left_expr = std::make_shared<ASTFunction>();\n-        auto args_left_expr = std::make_shared<ASTExpressionList>();\n-\n-        auto f_right_expr = std::make_shared<ASTFunction>();\n-        auto args_right_expr = std::make_shared<ASTExpressionList>();\n-\n-        args_left_expr->children.emplace_back(subject);\n-        args_left_expr->children.emplace_back(left);\n-\n-        args_right_expr->children.emplace_back(subject);\n-        args_right_expr->children.emplace_back(right);\n-\n-        if (negative)\n-        {\n-            /// NOT BETWEEN\n-            f_left_expr->name = \"less\";\n-            f_right_expr->name = \"greater\";\n-            f_combined_expression->name = \"or\";\n-        }\n-        else\n-        {\n-            /// BETWEEN\n-            f_left_expr->name = \"greaterOrEquals\";\n-            f_right_expr->name = \"lessOrEquals\";\n-            f_combined_expression->name = \"and\";\n-        }\n-\n-        f_left_expr->arguments = args_left_expr;\n-        f_left_expr->children.emplace_back(f_left_expr->arguments);\n-\n-        f_right_expr->arguments = args_right_expr;\n-        f_right_expr->children.emplace_back(f_right_expr->arguments);\n-\n-        args_combined_expression->children.emplace_back(f_left_expr);\n-        args_combined_expression->children.emplace_back(f_right_expr);\n-\n-        f_combined_expression->arguments = args_combined_expression;\n-        f_combined_expression->children.emplace_back(f_combined_expression->arguments);\n-\n-        node = f_combined_expression;\n-    }\n-\n-    return true;\n-}\n-\n-bool ParserTernaryOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ParserToken symbol1(TokenType::QuestionMark);\n-    ParserToken symbol2(TokenType::Colon);\n-\n-    ASTPtr elem_cond;\n-    ASTPtr elem_then;\n-    ASTPtr elem_else;\n-\n-    if (!elem_parser.parse(pos, elem_cond, expected))\n-        return false;\n-\n-    if (!symbol1.ignore(pos, expected))\n-        node = elem_cond;\n-    else\n-    {\n-        if (!elem_parser.parse(pos, elem_then, expected))\n-            return false;\n-\n-        if (!symbol2.ignore(pos, expected))\n-            return false;\n-\n-        if (!elem_parser.parse(pos, elem_else, expected))\n-            return false;\n-\n-        /// the function corresponding to the operator\n-        auto function = std::make_shared<ASTFunction>();\n-\n-        /// function arguments\n-        auto exp_list = std::make_shared<ASTExpressionList>();\n-\n-        function->name = \"if\";\n-        function->arguments = exp_list;\n-        function->children.push_back(exp_list);\n-\n-        exp_list->children.push_back(elem_cond);\n-        exp_list->children.push_back(elem_then);\n-        exp_list->children.push_back(elem_else);\n-\n-        node = function;\n-    }\n-\n-    return true;\n-}\n-\n-\n-bool ParserLambdaExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ParserToken arrow(TokenType::Arrow);\n-    ParserToken open(TokenType::OpeningRoundBracket);\n-    ParserToken close(TokenType::ClosingRoundBracket);\n-\n-    Pos begin = pos;\n-\n-    do\n-    {\n-        ASTPtr inner_arguments;\n-        ASTPtr expression;\n-\n-        bool was_open = false;\n-\n-        if (open.ignore(pos, expected))\n-        {\n-            was_open = true;\n-        }\n-\n-        if (!ParserList(std::make_unique<ParserIdentifier>(), std::make_unique<ParserToken>(TokenType::Comma)).parse(pos, inner_arguments, expected))\n-            break;\n-\n-        if (was_open)\n-        {\n-            if (!close.ignore(pos, expected))\n-                break;\n-        }\n-\n-        if (!arrow.ignore(pos, expected))\n-            break;\n-\n-        if (!elem_parser.parse(pos, expression, expected))\n-            return false;\n-\n-        /// lambda(tuple(inner_arguments), expression)\n-\n-        auto lambda = std::make_shared<ASTFunction>();\n-        node = lambda;\n-        lambda->name = \"lambda\";\n-\n-        auto outer_arguments = std::make_shared<ASTExpressionList>();\n-        lambda->arguments = outer_arguments;\n-        lambda->children.push_back(lambda->arguments);\n-\n-        auto tuple = std::make_shared<ASTFunction>();\n-        outer_arguments->children.push_back(tuple);\n-        tuple->name = \"tuple\";\n-        tuple->arguments = inner_arguments;\n-        tuple->children.push_back(inner_arguments);\n-\n-        outer_arguments->children.push_back(expression);\n-\n-        return true;\n-    }\n-    while (false);\n-\n-    pos = begin;\n-    return elem_parser.parse(pos, node, expected);\n-}\n-\n-\n-bool ParserTableFunctionExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    if (ParserTableFunctionView().parse(pos, node, expected))\n-        return true;\n-    ParserKeyword s_settings(\"SETTINGS\");\n-    if (s_settings.ignore(pos, expected))\n-    {\n-        ParserSetQuery parser_settings(true);\n-        if (parser_settings.parse(pos, node, expected))\n-            return true;\n-    }\n-    return elem_parser.parse(pos, node, expected);\n-}\n-\n-\n-bool ParserPrefixUnaryOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    /// try to find any of the valid operators\n-    const char ** it;\n-    for (it = operators; *it; it += 2)\n-    {\n-        if (parseOperator(pos, *it, expected))\n-            break;\n-    }\n-\n-    /// Let's parse chains of the form `NOT NOT x`. This is hack.\n-    /** This is done, because among the unary operators there is only a minus and NOT.\n-      * But for a minus the chain of unary operators does not need to be supported.\n-      */\n-    size_t count = 1;\n-    if (it[0] && 0 == strncmp(it[0], \"NOT\", 3))\n-    {\n-        while (true)\n-        {\n-            const char ** jt;\n-            for (jt = operators; *jt; jt += 2)\n-                if (parseOperator(pos, *jt, expected))\n-                    break;\n-\n-            if (!*jt)\n-                break;\n-\n-            ++count;\n-        }\n-    }\n-\n-    ASTPtr elem;\n-    if (!elem_parser->parse(pos, elem, expected))\n-        return false;\n-\n-    if (!*it)\n-        node = elem;\n-    else\n-    {\n-        for (size_t i = 0; i < count; ++i)\n-        {\n-            /// the function corresponding to the operator\n-            auto function = std::make_shared<ASTFunction>();\n-\n-            /// function arguments\n-            auto exp_list = std::make_shared<ASTExpressionList>();\n-\n-            function->name = it[1];\n-            function->arguments = exp_list;\n-            function->children.push_back(exp_list);\n-\n-            if (node)\n-                exp_list->children.push_back(node);\n-            else\n-                exp_list->children.push_back(elem);\n-\n-            node = function;\n-        }\n-    }\n-\n-    return true;\n-}\n-\n-\n-bool ParserUnaryExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    /// As an exception, negative numbers should be parsed as literals, and not as an application of the operator.\n-\n-    if (pos->type == TokenType::Minus)\n-    {\n-        Pos begin = pos;\n-        if (ParserCastOperator().parse(pos, node, expected))\n-            return true;\n-\n-        pos = begin;\n-        if (ParserLiteral().parse(pos, node, expected))\n-            return true;\n-\n-        pos = begin;\n-    }\n-\n-    return operator_parser.parse(pos, node, expected);\n-}\n-\n-\n-bool ParserCastExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+ASTPtr makeBetweenOperator(bool negative, ASTs arguments)\n {\n-    ASTPtr expr_ast;\n-    if (!elem_parser->parse(pos, expr_ast, expected))\n-        return false;\n+    // SUBJECT = arguments[0], LEFT = arguments[1], RIGHT = arguments[2]\n \n-    ASTPtr type_ast;\n-    if (ParserToken(TokenType::DoubleColon).ignore(pos, expected)\n-        && ParserDataType().parse(pos, type_ast, expected))\n+    if (negative)\n     {\n-        node = createFunctionCast(expr_ast, type_ast);\n+        auto f_left_expr = makeASTFunction(\"less\", arguments[0], arguments[1]);\n+        auto f_right_expr = makeASTFunction(\"greater\", arguments[0], arguments[2]);\n+        return makeASTFunction(\"or\", f_left_expr, f_right_expr);\n     }\n     else\n     {\n-        node = expr_ast;\n+        auto f_left_expr = makeASTFunction(\"greaterOrEquals\", arguments[0], arguments[1]);\n+        auto f_right_expr = makeASTFunction(\"lessOrEquals\", arguments[0], arguments[2]);\n+        return makeASTFunction(\"and\", f_left_expr, f_right_expr);\n     }\n-\n-    return true;\n-}\n-\n-\n-bool ParserArrayElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected &expected)\n-{\n-    return ParserLeftAssociativeBinaryOperatorList{\n-        operators,\n-        std::make_unique<ParserCastExpression>(std::make_unique<ParserExpressionElement>()),\n-        std::make_unique<ParserExpressionWithOptionalAlias>(false)\n-    }.parse(pos, node, expected);\n-}\n-\n-\n-bool ParserTupleElementExpression::parseImpl(Pos & pos, ASTPtr & node, Expected &expected)\n-{\n-    return ParserLeftAssociativeBinaryOperatorList{\n-        operators,\n-        std::make_unique<ParserCastExpression>(std::make_unique<ParserArrayElementExpression>()),\n-        std::make_unique<ParserUnsignedInteger>()\n-    }.parse(pos, node, expected);\n }\n \n-\n ParserExpressionWithOptionalAlias::ParserExpressionWithOptionalAlias(bool allow_alias_without_as_keyword, bool is_table_function)\n     : impl(std::make_unique<ParserWithOptionalAlias>(\n         is_table_function ? ParserPtr(std::make_unique<ParserTableFunctionExpression>()) : ParserPtr(std::make_unique<ParserExpression>()),\n@@ -760,7 +320,6 @@ bool ParserExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expect\n         .parse(pos, node, expected);\n }\n \n-\n bool ParserNotEmptyExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n     return nested_parser.parse(pos, node, expected) && !node->children.empty();\n@@ -836,221 +395,2135 @@ bool ParserTTLExpressionList::parseImpl(Pos & pos, ASTPtr & node, Expected & exp\n }\n \n \n-bool ParserNullityChecking::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParserKeyValuePair::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    ASTPtr node_comp;\n-    if (!elem_parser.parse(pos, node_comp, expected))\n-        return false;\n+    ParserIdentifier id_parser;\n+    ParserLiteral literal_parser;\n+    ParserFunction func_parser;\n \n-    ParserKeyword s_is{\"IS\"};\n-    ParserKeyword s_not{\"NOT\"};\n-    ParserKeyword s_null{\"NULL\"};\n+    ASTPtr identifier;\n+    ASTPtr value;\n+    bool with_brackets = false;\n+    if (!id_parser.parse(pos, identifier, expected))\n+        return false;\n \n-    if (s_is.ignore(pos, expected))\n+    /// If it's neither literal, nor identifier, nor function, than it's possible list of pairs\n+    if (!func_parser.parse(pos, value, expected) && !literal_parser.parse(pos, value, expected) && !id_parser.parse(pos, value, expected))\n     {\n-        bool is_not = false;\n-        if (s_not.ignore(pos, expected))\n-            is_not = true;\n+        ParserKeyValuePairsList kv_pairs_list;\n+        ParserToken open(TokenType::OpeningRoundBracket);\n+        ParserToken close(TokenType::ClosingRoundBracket);\n \n-        if (!s_null.ignore(pos, expected))\n+        if (!open.ignore(pos))\n             return false;\n \n-        auto args = std::make_shared<ASTExpressionList>();\n-        args->children.push_back(node_comp);\n+        if (!kv_pairs_list.parse(pos, value, expected))\n+            return false;\n \n-        auto function = std::make_shared<ASTFunction>();\n-        function->name = is_not ? \"isNotNull\" : \"isNull\";\n-        function->arguments = args;\n-        function->children.push_back(function->arguments);\n+        if (!close.ignore(pos))\n+            return false;\n \n-        node = function;\n+        with_brackets = true;\n     }\n-    else\n-        node = node_comp;\n-\n-    return true;\n-}\n \n-bool ParserDateOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+    auto pair = std::make_shared<ASTPair>(with_brackets);\n+    pair->first = Poco::toLower(identifier->as<ASTIdentifier>()->name());\n+    pair->set(pair->second, value);\n+    node = pair;\n+    return true;\n+}\n+\n+bool ParserKeyValuePairsList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ParserList parser(std::make_unique<ParserKeyValuePair>(), std::make_unique<ParserNothing>(), true, 0);\n+    return parser.parse(pos, node, expected);\n+}\n+\n+\n+enum class Action\n+{\n+    NONE,\n+    OPERAND,\n+    OPERATOR\n+};\n+\n+/** Operator types are needed for special handling of certain operators.\n+  * Operators can be grouped into some type if they have similar behaviour.\n+  * Certain operators are unique in terms of their behaviour, so they are assigned a separate type.\n+  */\n+enum class OperatorType\n+{\n+    None,\n+    Comparison,\n+    Mergeable,\n+    ArrayElement,\n+    TupleElement,\n+    IsNull,\n+    StartBetween,\n+    StartNotBetween,\n+    FinishBetween,\n+    StartIf,\n+    FinishIf,\n+    Cast,\n+    Lambda\n+};\n+\n+/** Operator struct stores parameters of the operator:\n+  *  - function_name  name of the function that operator will create\n+  *  - priority       priority of the operator relative to the other operators\n+  *  - arity          the amount of arguments that operator will consume\n+  *  - type           type of the operator that defines its behaviour\n+  */\n+struct Operator\n+{\n+    Operator() = default;\n+\n+    Operator(const std::string & function_name_, int priority_, int arity_ = 2, OperatorType type_ = OperatorType::None)\n+        : type(type_), priority(priority_), arity(arity_), function_name(function_name_) {}\n+\n+    OperatorType type;\n+    int priority;\n+    int arity;\n+    std::string function_name;\n+};\n+\n+enum class Checkpoint\n+{\n+    None,\n+    Interval,\n+    Case\n+};\n+\n+/** Layer is a class that represents context for parsing certain element,\n+  *  that consists of other elements e.g. f(x1, x2, x3)\n+  *\n+  *  - Manages operands and operators for the future elements (arguments)\n+  *  - Combines operands and operator into one element\n+  *  - Parsers separators and endings\n+  *  - Combines resulting elements into a function\n+  */\n+\n+class Layer\n+{\n+public:\n+    explicit Layer(bool allow_alias_ = true, bool allow_alias_without_as_keyword_ = true) :\n+        allow_alias(allow_alias_), allow_alias_without_as_keyword(allow_alias_without_as_keyword_)\n+    {\n+    }\n+\n+    virtual ~Layer() = default;\n+\n+    bool popOperator(Operator & op)\n+    {\n+        if (operators.empty())\n+            return false;\n+\n+        op = std::move(operators.back());\n+        operators.pop_back();\n+\n+        return true;\n+    }\n+\n+    void pushOperator(Operator op)\n+    {\n+        operators.push_back(std::move(op));\n+    }\n+\n+    bool popOperand(ASTPtr & op)\n+    {\n+        if (operands.empty())\n+            return false;\n+\n+        op = std::move(operands.back());\n+        operands.pop_back();\n+\n+        return true;\n+    }\n+\n+    void pushOperand(ASTPtr op)\n+    {\n+        operands.push_back(std::move(op));\n+    }\n+\n+    void pushResult(ASTPtr op)\n+    {\n+        elements.push_back(std::move(op));\n+    }\n+\n+    virtual bool getResult(ASTPtr & node)\n+    {\n+        if (elements.size() == 1)\n+        {\n+            node = std::move(elements[0]);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    virtual bool parse(IParser::Pos & /*pos*/, Expected & /*expected*/, Action & /*action*/) = 0;\n+\n+    bool isFinished() const\n+    {\n+        return finished;\n+    }\n+\n+    int previousPriority() const\n+    {\n+        if (operators.empty())\n+            return 0;\n+\n+        return operators.back().priority;\n+    }\n+\n+    OperatorType previousType() const\n+    {\n+        if (operators.empty())\n+            return OperatorType::None;\n+\n+        return operators.back().type;\n+    }\n+\n+    int isCurrentElementEmpty() const\n+    {\n+        return operators.empty() && operands.empty();\n+    }\n+\n+    bool popLastNOperands(ASTs & asts, size_t n)\n+    {\n+        if (n > operands.size())\n+            return false;\n+\n+        asts.reserve(asts.size() + n);\n+\n+        auto start = operands.begin() + operands.size() - n;\n+        asts.insert(asts.end(), std::make_move_iterator(start), std::make_move_iterator(operands.end()));\n+        operands.erase(start, operands.end());\n+\n+        return true;\n+    }\n+\n+    /// Merge operators and operands into a single element (column), then push it to 'elements' vector.\n+    ///  Operators are previously sorted in ascending order of priority\n+    ///  (operator with priority 1 has higher priority than operator with priority 2),\n+    ///  so we can just merge them with operands starting from the end.\n+    ///\n+    /// If we fail here it means that the query was incorrect and we should return an error.\n+    ///\n+    bool mergeElement(bool push_to_elements = true)\n+    {\n+        Operator cur_op;\n+        while (popOperator(cur_op))\n+        {\n+            ASTPtr function;\n+\n+            // Special case of ternary operator\n+            if (cur_op.type == OperatorType::StartIf)\n+                return false;\n+\n+            if (cur_op.type == OperatorType::FinishIf)\n+            {\n+                Operator tmp;\n+                if (!popOperator(tmp) || tmp.type != OperatorType::StartIf)\n+                    return false;\n+            }\n+\n+            // Special case of a BETWEEN b AND c operator\n+            if (cur_op.type == OperatorType::StartBetween || cur_op.type == OperatorType::StartNotBetween)\n+                return false;\n+\n+            if (cur_op.type == OperatorType::FinishBetween)\n+            {\n+                Operator tmp_op;\n+                if (!popOperator(tmp_op))\n+                    return false;\n+\n+                if (tmp_op.type != OperatorType::StartBetween && tmp_op.type != OperatorType::StartNotBetween)\n+                    return false;\n+\n+                bool negative = tmp_op.type == OperatorType::StartNotBetween;\n+\n+                ASTs arguments;\n+                if (!popLastNOperands(arguments, 3))\n+                    return false;\n+\n+                function = makeBetweenOperator(negative, arguments);\n+            }\n+            else\n+            {\n+                function = makeASTFunction(cur_op.function_name);\n+\n+                if (!popLastNOperands(function->children[0]->children, cur_op.arity))\n+                    return false;\n+            }\n+\n+            pushOperand(function);\n+        }\n+\n+        ASTPtr node;\n+        if (!popOperand(node))\n+            return false;\n+\n+        bool res = isCurrentElementEmpty();\n+\n+        if (push_to_elements)\n+            pushResult(node);\n+        else\n+            pushOperand(node);\n+\n+        return res;\n+    }\n+\n+    bool parseLambda()\n+    {\n+        // 0. If empty - create function tuple with 0 args\n+        if (isCurrentElementEmpty())\n+        {\n+            auto function = makeASTFunction(\"tuple\");\n+            pushOperand(function);\n+            return true;\n+        }\n+\n+        if (operands.size() != 1 || !operators.empty() || !mergeElement())\n+            return false;\n+\n+        /// 1. If there is already tuple do nothing\n+        if (tryGetFunctionName(elements.back()) == \"tuple\")\n+        {\n+            pushOperand(elements.back());\n+            elements.pop_back();\n+        }\n+        /// 2. Put all elements in a single tuple\n+        else\n+        {\n+            auto function = makeASTFunction(\"tuple\", elements);\n+            elements.clear();\n+            pushOperand(function);\n+        }\n+        return true;\n+    }\n+\n+    /// Put 'node' identifier into the last operand as its alias\n+    bool insertAlias(ASTPtr node)\n+    {\n+        if (!mergeElement(false))\n+            return false;\n+\n+        if (operands.empty())\n+            return false;\n+\n+        if (auto * ast_with_alias = dynamic_cast<ASTWithAlias *>(operands.back().get()))\n+        {\n+            tryGetIdentifierNameInto(node, ast_with_alias->alias);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    bool is_table_function = false;\n+\n+    /// 'AND' in operator '... BETWEEN ... AND ...'  mirrors logical operator 'AND'.\n+    ///  In order to distinguish them we keep a counter of BETWEENs without matching ANDs.\n+    int between_counter = 0;\n+\n+    bool allow_alias = true;\n+    bool allow_alias_without_as_keyword = true;\n+\n+    std::optional<std::pair<IParser::Pos, Checkpoint>> saved_checkpoint;\n+    Checkpoint current_checkpoint = Checkpoint::None;\n+\n+protected:\n+    std::vector<Operator> operators;\n+    ASTs operands;\n+    ASTs elements;\n+    bool finished = false;\n+    int state = 0;\n+};\n+\n+\n+class ExpressionLayer : public Layer\n+{\n+public:\n+\n+    explicit ExpressionLayer(bool is_table_function_) : Layer(false, false)\n+    {\n+        is_table_function = is_table_function_;\n+    }\n+\n+    bool getResult(ASTPtr & node) override\n+    {\n+        /// We can exit the main cycle outside the parse() function,\n+        ///  so we need to merge the element here\n+        if (!mergeElement())\n+            return false;\n+\n+        if (elements.size() == 1)\n+        {\n+            node = std::move(elements[0]);\n+            return true;\n+        }\n+\n+        return false;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & /*expected*/, Action & /*action*/) override\n+    {\n+        if (pos->type == TokenType::Comma)\n+            finished = true;\n+\n+        return true;\n+    }\n+};\n+\n+\n+/// Basic layer for a function with certain separator and end tokens:\n+///  1. If we parse a separator we should merge current operands and operators\n+///     into one element and push in to 'elements' vector.\n+///  2. If we parse an ending token, we should merge everything as in (1) and\n+///     also set 'finished' flag.\n+template <TokenType separator, TokenType end>\n+class BaseLayer : public Layer\n+{\n+public:\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        if (ParserToken(separator).ignore(pos, expected))\n+        {\n+            action = Action::OPERAND;\n+            return mergeElement();\n+        }\n+\n+        if (ParserToken(end).ignore(pos, expected))\n+        {\n+            action = Action::OPERATOR;\n+\n+            if (!isCurrentElementEmpty() || !elements.empty())\n+                if (!mergeElement())\n+                    return false;\n+\n+            finished = true;\n+        }\n+\n+        return true;\n+    }\n+};\n+\n+\n+class OrdinaryFunctionLayer : public Layer\n+{\n+public:\n+    explicit OrdinaryFunctionLayer(String function_name_, bool allow_function_parameters_ = true)\n+        : function_name(function_name_), allow_function_parameters(allow_function_parameters_){}\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        ///   | 0 |      1      |     2    |\n+        ///  f(ALL ...)(ALL ...) FILTER ...\n+        ///\n+        /// 0. Parse ALL and DISTINCT qualifiers (-> 1)\n+        /// 1. Parse all the arguments and ending token (-> 2), possibly with parameters list (-> 1)\n+        /// 2. Create function, possibly parse FILTER and OVER window definitions (finished)\n+\n+        if (state == 0)\n+        {\n+            state = 1;\n+\n+            auto pos_after_bracket = pos;\n+            auto old_expected = expected;\n+\n+            ParserKeyword all(\"ALL\");\n+            ParserKeyword distinct(\"DISTINCT\");\n+\n+            if (all.ignore(pos, expected))\n+                has_all = true;\n+\n+            if (distinct.ignore(pos, expected))\n+                has_distinct = true;\n+\n+            if (!has_all && all.ignore(pos, expected))\n+                has_all = true;\n+\n+            if (has_all && has_distinct)\n+                return false;\n+\n+            if (has_all || has_distinct)\n+            {\n+                /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier\n+                if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)\n+                {\n+                    pos = pos_after_bracket;\n+                    expected = old_expected;\n+                    has_all = false;\n+                    has_distinct = false;\n+                }\n+            }\n+\n+            contents_begin = pos->begin;\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserToken(TokenType::Comma).ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+                return mergeElement();\n+            }\n+\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                action = Action::OPERATOR;\n+\n+                if (!isCurrentElementEmpty() || !elements.empty())\n+                    if (!mergeElement())\n+                        return false;\n+\n+                contents_end = pos->begin;\n+\n+                /** Check for a common error case - often due to the complexity of quoting command-line arguments,\n+                 *  an expression of the form toDate(2014-01-01) appears in the query instead of toDate('2014-01-01').\n+                 * If you do not report that the first option is an error, then the argument will be interpreted as 2014 - 01 - 01 - some number,\n+                 *  and the query silently returns an unexpected elements.\n+                 */\n+                if (function_name == \"toDate\"\n+                    && contents_end - contents_begin == strlen(\"2014-01-01\")\n+                    && contents_begin[0] >= '2' && contents_begin[0] <= '3'\n+                    && contents_begin[1] >= '0' && contents_begin[1] <= '9'\n+                    && contents_begin[2] >= '0' && contents_begin[2] <= '9'\n+                    && contents_begin[3] >= '0' && contents_begin[3] <= '9'\n+                    && contents_begin[4] == '-'\n+                    && contents_begin[5] >= '0' && contents_begin[5] <= '9'\n+                    && contents_begin[6] >= '0' && contents_begin[6] <= '9'\n+                    && contents_begin[7] == '-'\n+                    && contents_begin[8] >= '0' && contents_begin[8] <= '9'\n+                    && contents_begin[9] >= '0' && contents_begin[9] <= '9')\n+                {\n+                    std::string contents_str(contents_begin, contents_end - contents_begin);\n+                    throw Exception(\"Argument of function toDate is unquoted: toDate(\" + contents_str + \"), must be: toDate('\" + contents_str + \"')\"\n+                        , ErrorCodes::SYNTAX_ERROR);\n+                }\n+\n+                if (allow_function_parameters && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))\n+                {\n+                    parameters = std::make_shared<ASTExpressionList>();\n+                    std::swap(parameters->children, elements);\n+                    action = Action::OPERAND;\n+\n+                    /// Parametric aggregate functions cannot have DISTINCT in parameters list.\n+                    if (has_distinct)\n+                        return false;\n+\n+                    auto pos_after_bracket = pos;\n+                    auto old_expected = expected;\n+\n+                    ParserKeyword all(\"ALL\");\n+                    ParserKeyword distinct(\"DISTINCT\");\n+\n+                    if (all.ignore(pos, expected))\n+                        has_all = true;\n+\n+                    if (distinct.ignore(pos, expected))\n+                        has_distinct = true;\n+\n+                    if (!has_all && all.ignore(pos, expected))\n+                        has_all = true;\n+\n+                    if (has_all && has_distinct)\n+                        return false;\n+\n+                    if (has_all || has_distinct)\n+                    {\n+                        /// case f(ALL), f(ALL, x), f(DISTINCT), f(DISTINCT, x), ALL and DISTINCT should be treat as identifier\n+                        if (pos->type == TokenType::Comma || pos->type == TokenType::ClosingRoundBracket)\n+                        {\n+                            pos = pos_after_bracket;\n+                            expected = old_expected;\n+                            has_distinct = false;\n+                        }\n+                    }\n+                }\n+                else\n+                {\n+                    state = 2;\n+                }\n+            }\n+        }\n+\n+        if (state == 2)\n+        {\n+            if (has_distinct)\n+                function_name += \"Distinct\";\n+\n+            auto function_node = makeASTFunction(function_name, std::move(elements));\n+\n+            if (parameters)\n+            {\n+                function_node->parameters = parameters;\n+                function_node->children.push_back(function_node->parameters);\n+            }\n+\n+            ParserKeyword filter(\"FILTER\");\n+            ParserKeyword over(\"OVER\");\n+\n+            if (filter.ignore(pos, expected))\n+            {\n+                // We are slightly breaking the parser interface by parsing the window\n+                // definition into an existing ASTFunction. Normally it would take a\n+                // reference to ASTPtr and assign it the new node. We only have a pointer\n+                // of a different type, hence this workaround with a temporary pointer.\n+                ASTPtr function_node_as_iast = function_node;\n+\n+                // Recursion\n+                ParserFilterClause filter_parser;\n+                if (!filter_parser.parse(pos, function_node_as_iast, expected))\n+                    return false;\n+            }\n+\n+            if (over.ignore(pos, expected))\n+            {\n+                function_node->is_window_function = true;\n+\n+                ASTPtr function_node_as_iast = function_node;\n+\n+                // Recursion\n+                ParserWindowReference window_reference;\n+                if (!window_reference.parse(pos, function_node_as_iast, expected))\n+                    return false;\n+            }\n+\n+            elements = {function_node};\n+            finished = true;\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    bool has_all = false;\n+    bool has_distinct = false;\n+\n+    const char * contents_begin;\n+    const char * contents_end;\n+\n+    String function_name;\n+    ASTPtr parameters;\n+\n+    bool allow_function_parameters;\n+};\n+\n+/// Layer for priority brackets and tuple function\n+class RoundBracketsLayer : public Layer\n+{\n+public:\n+    bool getResult(ASTPtr & node) override\n+    {\n+        // Round brackets can mean priority operator as well as function tuple()\n+        if (!is_tuple && elements.size() == 1)\n+            node = std::move(elements[0]);\n+        else\n+            node = makeASTFunction(\"tuple\", std::move(elements));\n+\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        if (ParserToken(TokenType::Comma).ignore(pos, expected))\n+        {\n+            action = Action::OPERAND;\n+            is_tuple = true;\n+            if (!mergeElement())\n+                return false;\n+        }\n+\n+        if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+        {\n+            action = Action::OPERATOR;\n+\n+            if (!isCurrentElementEmpty())\n+                if (!mergeElement())\n+                    return false;\n+\n+            // Special case for (('a', 'b')) -> tuple(('a', 'b'))\n+            if (!is_tuple && elements.size() == 1)\n+                if (auto * literal = elements[0]->as<ASTLiteral>())\n+                    if (literal->value.getType() == Field::Types::Tuple)\n+                        is_tuple = true;\n+\n+            finished = true;\n+        }\n+\n+        return true;\n+    }\n+private:\n+    bool is_tuple = false;\n+};\n+\n+/// Layer for array square brackets operator\n+class ArrayLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingSquareBracket>\n+{\n+public:\n+    bool getResult(ASTPtr & node) override\n+    {\n+        node = makeASTFunction(\"array\", std::move(elements));\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        return BaseLayer::parse(pos, expected, action);\n+    }\n+};\n+\n+/// Layer for arrayElement square brackets operator\n+///  This layer does not create a function, it is only needed to parse closing token\n+///  and return only one element.\n+class ArrayElementLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingSquareBracket>\n+{\n+public:\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        return BaseLayer::parse(pos, expected, action);\n+    }\n+};\n+\n+class CastLayer : public Layer\n+{\n+public:\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// CAST(x [AS alias1], T [AS alias2]) or CAST(x [AS alias1] AS T)\n+        ///\n+        /// 0. Parse all the cases (-> 1)\n+        /// 1. Parse closing token (finished)\n+\n+        ParserKeyword as_keyword_parser(\"AS\");\n+        ASTPtr alias;\n+\n+        /// expr AS type\n+        if (state == 0)\n+        {\n+            ASTPtr type_node;\n+\n+            if (as_keyword_parser.ignore(pos, expected))\n+            {\n+                auto old_pos = pos;\n+\n+                if (ParserIdentifier().parse(pos, alias, expected) &&\n+                    as_keyword_parser.ignore(pos, expected) &&\n+                    ParserDataType().parse(pos, type_node, expected) &&\n+                    ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+                {\n+                    if (!insertAlias(alias))\n+                        return false;\n+\n+                    if (!mergeElement())\n+                        return false;\n+\n+                    elements = {createFunctionCast(elements[0], type_node)};\n+                    finished = true;\n+                    return true;\n+                }\n+\n+                pos = old_pos;\n+\n+                if (ParserIdentifier().parse(pos, alias, expected) &&\n+                    ParserToken(TokenType::Comma).ignore(pos, expected))\n+                {\n+                    action = Action::OPERAND;\n+                    if (!insertAlias(alias))\n+                        return false;\n+\n+                    if (!mergeElement())\n+                        return false;\n+\n+                    state = 1;\n+                    return true;\n+                }\n+\n+                pos = old_pos;\n+\n+                if (ParserDataType().parse(pos, type_node, expected) &&\n+                    ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+                {\n+                    if (!mergeElement())\n+                        return false;\n+\n+                    elements = {createFunctionCast(elements[0], type_node)};\n+                    finished = true;\n+                    return true;\n+                }\n+\n+                return false;\n+            }\n+\n+            if (ParserToken(TokenType::Comma).ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+\n+                state = 1;\n+                return true;\n+            }\n+        }\n+        if (state == 1)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                elements = {makeASTFunction(\"CAST\", elements[0], elements[1])};\n+                finished = true;\n+                return true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+};\n+\n+class ExtractLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingRoundBracket>\n+{\n+public:\n+    bool getResult(ASTPtr & node) override\n+    {\n+        if (state == 2)\n+        {\n+            if (elements.empty())\n+                return false;\n+\n+            node = makeASTFunction(interval_kind.toNameOfFunctionExtractTimePart(), elements[0]);\n+        }\n+        else\n+        {\n+            node = makeASTFunction(\"extract\", std::move(elements));\n+        }\n+\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// extract(haystack, pattern) or EXTRACT(DAY FROM Date)\n+        ///\n+        /// 0. If we parse interval_kind and 'FROM' keyword (-> 2), otherwise (-> 1)\n+        /// 1. Basic parser\n+        /// 2. Parse closing bracket (finished)\n+\n+        if (state == 0)\n+        {\n+            IParser::Pos begin = pos;\n+            ParserKeyword s_from(\"FROM\");\n+\n+            if (parseIntervalKind(pos, expected, interval_kind) && s_from.ignore(pos, expected))\n+            {\n+                state = 2;\n+                return true;\n+            }\n+            else\n+            {\n+                state = 1;\n+                pos = begin;\n+            }\n+        }\n+\n+        if (state == 1)\n+        {\n+            return BaseLayer::parse(pos, expected, action);\n+        }\n+\n+        if (state == 2)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                finished = true;\n+                return true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    IntervalKind interval_kind;\n+};\n+\n+class SubstringLayer : public Layer\n+{\n+public:\n+    bool getResult(ASTPtr & node) override\n+    {\n+        node = makeASTFunction(\"substring\", std::move(elements));\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// Either SUBSTRING(expr FROM start [FOR length]) or SUBSTRING(expr, start, length)\n+        ///\n+        /// 0: Parse first separator: FROM or comma (-> 1)\n+        /// 1: Parse second separator: FOR or comma (-> 2)\n+        /// 1 or 2: Parse closing bracket (finished)\n+\n+        if (state == 0)\n+        {\n+            if (ParserToken(TokenType::Comma).ignore(pos, expected) ||\n+                ParserKeyword(\"FROM\").ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+\n+                state = 1;\n+            }\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserToken(TokenType::Comma).ignore(pos, expected) ||\n+                ParserKeyword(\"FOR\").ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+\n+                state = 2;\n+            }\n+        }\n+\n+        if (state == 1 || state == 2)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+};\n+\n+class PositionLayer : public Layer\n+{\n+public:\n+    bool getResult(ASTPtr & node) override\n+    {\n+        if (state == 2)\n+            std::swap(elements[1], elements[0]);\n+\n+        node = makeASTFunction(\"position\", std::move(elements));\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// position(haystack, needle[, start_pos]) or position(needle IN haystack)\n+        ///\n+        /// 0: Parse separator: comma (-> 1) or IN (-> 2)\n+        /// 1: Parse second separator: comma\n+        /// 1 or 2: Parse closing bracket (finished)\n+\n+        if (state == 0)\n+        {\n+            if (ParserToken(TokenType::Comma).ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+\n+                state = 1;\n+            }\n+            if (ParserKeyword(\"IN\").ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+\n+                state = 2;\n+            }\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserToken(TokenType::Comma).ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+            }\n+        }\n+\n+        if (state == 1 || state == 2)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+};\n+\n+\n+class ExistsLayer : public Layer\n+{\n+public:\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & /*action*/) override\n+    {\n+        ASTPtr node;\n+\n+        // Recursion\n+        if (!ParserSelectWithUnionQuery().parse(pos, node, expected))\n+            return false;\n+\n+        if (!ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            return false;\n+\n+        auto subquery = std::make_shared<ASTSubquery>();\n+        subquery->children.push_back(node);\n+        elements = {makeASTFunction(\"exists\", subquery)};\n+\n+        finished = true;\n+\n+        return true;\n+    }\n+};\n+\n+class TrimLayer : public Layer\n+{\n+public:\n+    TrimLayer(bool trim_left_, bool trim_right_) : trim_left(trim_left_), trim_right(trim_right_)\n+    {\n+    }\n+\n+    bool getResult(ASTPtr & node) override\n+    {\n+        node = makeASTFunction(function_name, std::move(elements));\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// Handles all possible TRIM/LTRIM/RTRIM call variants\n+        ///\n+        /// 0: If flags 'trim_left' and 'trim_right' are set (-> 2).\n+        ///    If not, try to parse 'BOTH', 'LEADING', 'TRAILING' keywords,\n+        ///    then if char_override (-> 1), else (-> 2)\n+        /// 1. Parse 'FROM' keyword (-> 2)\n+        /// 2. Parse closing token, choose name, add arguments (finished)\n+\n+        if (state == 0)\n+        {\n+            if (!trim_left && !trim_right)\n+            {\n+                if (ParserKeyword(\"BOTH\").ignore(pos, expected))\n+                {\n+                    trim_left = true;\n+                    trim_right = true;\n+                    char_override = true;\n+                }\n+                else if (ParserKeyword(\"LEADING\").ignore(pos, expected))\n+                {\n+                    trim_left = true;\n+                    char_override = true;\n+                }\n+                else if (ParserKeyword(\"TRAILING\").ignore(pos, expected))\n+                {\n+                    trim_right = true;\n+                    char_override = true;\n+                }\n+                else\n+                {\n+                    trim_left = true;\n+                    trim_right = true;\n+                }\n+\n+                if (char_override)\n+                    state = 1;\n+                else\n+                    state = 2;\n+            }\n+            else\n+            {\n+                state = 2;\n+            }\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserKeyword(\"FROM\").ignore(pos, expected))\n+            {\n+                action = Action::OPERAND;\n+\n+                if (!mergeElement())\n+                    return false;\n+\n+                to_remove = makeASTFunction(\"regexpQuoteMeta\", elements[0]);\n+                elements.clear();\n+                state = 2;\n+            }\n+        }\n+\n+        if (state == 2)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                ASTPtr pattern_node;\n+\n+                if (char_override)\n+                {\n+                    auto pattern_func_node = std::make_shared<ASTFunction>();\n+                    auto pattern_list_args = std::make_shared<ASTExpressionList>();\n+                    if (trim_left && trim_right)\n+                    {\n+                        pattern_list_args->children = {\n+                            std::make_shared<ASTLiteral>(\"^[\"),\n+                            to_remove,\n+                            std::make_shared<ASTLiteral>(\"]+|[\"),\n+                            to_remove,\n+                            std::make_shared<ASTLiteral>(\"]+$\")\n+                        };\n+                        function_name = \"replaceRegexpAll\";\n+                    }\n+                    else\n+                    {\n+                        if (trim_left)\n+                        {\n+                            pattern_list_args->children = {\n+                                std::make_shared<ASTLiteral>(\"^[\"),\n+                                to_remove,\n+                                std::make_shared<ASTLiteral>(\"]+\")\n+                            };\n+                        }\n+                        else\n+                        {\n+                            /// trim_right == false not possible\n+                            pattern_list_args->children = {\n+                                std::make_shared<ASTLiteral>(\"[\"),\n+                                to_remove,\n+                                std::make_shared<ASTLiteral>(\"]+$\")\n+                            };\n+                        }\n+                        function_name = \"replaceRegexpOne\";\n+                    }\n+\n+                    pattern_func_node->name = \"concat\";\n+                    pattern_func_node->arguments = std::move(pattern_list_args);\n+                    pattern_func_node->children.push_back(pattern_func_node->arguments);\n+\n+                    pattern_node = std::move(pattern_func_node);\n+                }\n+                else\n+                {\n+                    if (trim_left && trim_right)\n+                    {\n+                        function_name = \"trimBoth\";\n+                    }\n+                    else\n+                    {\n+                        if (trim_left)\n+                            function_name = \"trimLeft\";\n+                        else\n+                            function_name = \"trimRight\";\n+                    }\n+                }\n+\n+                if (char_override)\n+                {\n+                    elements.push_back(pattern_node);\n+                    elements.push_back(std::make_shared<ASTLiteral>(\"\"));\n+                }\n+\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+private:\n+    bool trim_left;\n+    bool trim_right;\n+    bool char_override = false;\n+\n+    ASTPtr to_remove;\n+    String function_name;\n+};\n+\n+\n+class DateAddLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingRoundBracket>\n+{\n+public:\n+    explicit DateAddLayer(const char * function_name_) : function_name(function_name_)\n+    {\n+    }\n+\n+    bool getResult(ASTPtr & node) override\n+    {\n+        if (parsed_interval_kind)\n+        {\n+            elements[0] = makeASTFunction(interval_kind.toNameOfFunctionToIntervalDataType(), elements[0]);\n+            node = makeASTFunction(function_name, elements[1], elements[0]);\n+        }\n+        else\n+            node = makeASTFunction(function_name, std::move(elements));\n+\n+        return true;\n+    }\n+\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// DATEADD(YEAR, 1, date) or DATEADD(INTERVAL 1 YEAR, date);\n+        ///\n+        /// 0. Try to parse interval_kind (-> 1)\n+        /// 1. Basic parser\n+\n+        if (state == 0)\n+        {\n+            if (parseIntervalKind(pos, expected, interval_kind))\n+            {\n+                if (!ParserToken(TokenType::Comma).ignore(pos, expected))\n+                    return false;\n+\n+                action = Action::OPERAND;\n+                parsed_interval_kind = true;\n+            }\n+\n+            state = 1;\n+        }\n+\n+        if (state == 1)\n+        {\n+            return BaseLayer::parse(pos, expected, action);\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    IntervalKind interval_kind;\n+    const char * function_name;\n+    bool parsed_interval_kind = false;\n+};\n+\n+\n+class DateDiffLayer : public BaseLayer<TokenType::Comma, TokenType::ClosingRoundBracket>\n+{\n+public:\n+    bool getResult(ASTPtr & node) override\n+    {\n+        if (parsed_interval_kind)\n+        {\n+            if (elements.size() == 2)\n+                node = makeASTFunction(\"dateDiff\", std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit()), elements[0], elements[1]);\n+            else if (elements.size() == 3)\n+                node = makeASTFunction(\"dateDiff\", std::make_shared<ASTLiteral>(interval_kind.toDateDiffUnit()), elements[0], elements[1], elements[2]);\n+            else\n+                return false;\n+        }\n+        else\n+        {\n+            node = makeASTFunction(\"dateDiff\", std::move(elements));\n+        }\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// 0. Try to parse interval_kind (-> 1)\n+        /// 1. Basic parser\n+\n+        if (state == 0)\n+        {\n+            if (parseIntervalKind(pos, expected, interval_kind))\n+            {\n+                parsed_interval_kind = true;\n+\n+                if (!ParserToken(TokenType::Comma).ignore(pos, expected))\n+                    return false;\n+            }\n+\n+            state = 1;\n+        }\n+\n+        if (state == 1)\n+        {\n+            return BaseLayer::parse(pos, expected, action);\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    IntervalKind interval_kind;\n+    bool parsed_interval_kind = false;\n+};\n+\n+\n+class IntervalLayer : public Layer\n+{\n+public:\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// INTERVAL 1 HOUR or INTERVAL expr HOUR\n+        ///\n+        /// 0. Try to parse interval_kind (-> 1)\n+        /// 1. Basic parser\n+\n+        if (state == 0)\n+        {\n+            auto begin = pos;\n+            auto init_expected = expected;\n+            ASTPtr string_literal;\n+            //// A String literal followed INTERVAL keyword,\n+            /// the literal can be a part of an expression or\n+            /// include Number and INTERVAL TYPE at the same time\n+            if (ParserStringLiteral{}.parse(pos, string_literal, expected))\n+            {\n+                String literal;\n+                if (string_literal->as<ASTLiteral &>().value.tryGet(literal))\n+                {\n+                    Tokens tokens(literal.data(), literal.data() + literal.size());\n+                    IParser::Pos token_pos(tokens, 0);\n+                    Expected token_expected;\n+                    ASTPtr expr;\n+\n+                    if (!ParserNumber{}.parse(token_pos, expr, token_expected))\n+                    {\n+                        return false;\n+                    }\n+                    else\n+                    {\n+                        /// case: INTERVAL '1' HOUR\n+                        /// back to begin\n+                        if (!token_pos.isValid())\n+                        {\n+                            pos = begin;\n+                            expected = init_expected;\n+                        }\n+                        else\n+                        {\n+                            /// case: INTERVAL '1 HOUR'\n+                            if (!parseIntervalKind(token_pos, token_expected, interval_kind))\n+                                return false;\n+\n+                            elements = {makeASTFunction(interval_kind.toNameOfFunctionToIntervalDataType(), expr)};\n+                            finished = true;\n+                            return true;\n+                        }\n+                    }\n+                }\n+            }\n+            state = 1;\n+            return true;\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (action == Action::OPERATOR && parseIntervalKind(pos, expected, interval_kind))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                elements = {makeASTFunction(interval_kind.toNameOfFunctionToIntervalDataType(), elements)};\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    IntervalKind interval_kind;\n+};\n+\n+/// Layer for table function 'view' and 'viewIfPermitted'\n+class ViewLayer : public Layer\n+{\n+public:\n+    explicit ViewLayer(bool if_permitted_) : if_permitted(if_permitted_) {}\n+\n+    bool getResult(ASTPtr & node) override\n+    {\n+        if (if_permitted)\n+            node = makeASTFunction(\"viewIfPermitted\", std::move(elements));\n+        else\n+            node = makeASTFunction(\"view\", std::move(elements));\n+\n+        return true;\n+    }\n+\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & /*action*/) override\n+    {\n+        /// view(SELECT ...)\n+        /// viewIfPermitted(SELECT ... ELSE func(...))\n+        ///\n+        /// 0. Parse the SELECT query and if 'if_permitted' parse 'ELSE' keyword (-> 1) else (finished)\n+        /// 1. Parse closing token\n+\n+        if (state == 0)\n+        {\n+            ASTPtr query;\n+\n+            bool maybe_an_subquery = pos->type == TokenType::OpeningRoundBracket;\n+\n+            if (!ParserSelectWithUnionQuery().parse(pos, query, expected))\n+                return false;\n+\n+            auto & select_ast = query->as<ASTSelectWithUnionQuery &>();\n+            if (select_ast.list_of_selects->children.size() == 1 && maybe_an_subquery)\n+            {\n+                // It's an subquery. Bail out.\n+                return false;\n+            }\n+\n+            pushResult(query);\n+\n+            if (!if_permitted)\n+            {\n+                if (!ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+                    return false;\n+\n+                finished = true;\n+                return true;\n+            }\n+\n+            if (!ParserKeyword{\"ELSE\"}.ignore(pos, expected))\n+                return false;\n+\n+            state = 1;\n+            return true;\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserToken(TokenType::ClosingRoundBracket).ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    bool if_permitted;\n+};\n+\n+\n+class CaseLayer : public Layer\n+{\n+public:\n+    bool parse(IParser::Pos & pos, Expected & expected, Action & action) override\n+    {\n+        /// CASE [x] WHEN expr THEN expr [WHEN expr THEN expr [...]] [ELSE expr] END\n+        ///\n+        /// 0. Check if we have case expression [x] (-> 1)\n+        /// 1. Parse keywords: WHEN (-> 2), ELSE (-> 3), END (finished)\n+        /// 2. Parse THEN keyword (-> 1)\n+        /// 3. Parse END keyword (finished)\n+\n+        if (state == 0)\n+        {\n+            auto old_pos = pos;\n+            has_case_expr = !ParserKeyword(\"WHEN\").ignore(pos, expected);\n+            pos = old_pos;\n+\n+            state = 1;\n+        }\n+\n+        if (state == 1)\n+        {\n+            if (ParserKeyword(\"WHEN\").ignore(pos, expected))\n+            {\n+                if ((has_case_expr || !elements.empty()) && !mergeElement())\n+                    return false;\n+\n+                action = Action::OPERAND;\n+                state = 2;\n+            }\n+            else if (ParserKeyword(\"ELSE\").ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                action = Action::OPERAND;\n+                state = 3;\n+            }\n+            else if (ParserKeyword(\"END\").ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                Field field_with_null;\n+                ASTLiteral null_literal(field_with_null);\n+                elements.push_back(std::make_shared<ASTLiteral>(null_literal));\n+\n+                if (has_case_expr)\n+                    elements = {makeASTFunction(\"caseWithExpression\", elements)};\n+                else\n+                    elements = {makeASTFunction(\"multiIf\", elements)};\n+                finished = true;\n+            }\n+        }\n+\n+        if (state == 2)\n+        {\n+            if (ParserKeyword(\"THEN\").ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                action = Action::OPERAND;\n+                state = 1;\n+            }\n+        }\n+\n+        if (state == 3)\n+        {\n+            if (ParserKeyword(\"END\").ignore(pos, expected))\n+            {\n+                if (!mergeElement())\n+                    return false;\n+\n+                if (has_case_expr)\n+                    elements = {makeASTFunction(\"caseWithExpression\", elements)};\n+                else\n+                    elements = {makeASTFunction(\"multiIf\", elements)};\n+\n+                finished = true;\n+            }\n+        }\n+\n+        return true;\n+    }\n+\n+private:\n+    bool has_case_expr;\n+};\n+\n+\n+std::unique_ptr<Layer> getFunctionLayer(ASTPtr identifier, bool is_table_function, bool allow_function_parameters_ = true)\n+{\n+    /// Special cases for expressions that look like functions but contain some syntax sugar:\n+\n+    /// CAST, EXTRACT, POSITION, EXISTS\n+    /// DATE_ADD, DATEADD, TIMESTAMPADD, DATE_SUB, DATESUB, TIMESTAMPSUB,\n+    /// DATE_DIFF, DATEDIFF, TIMESTAMPDIFF, TIMESTAMP_DIFF,\n+    /// SUBSTRING, TRIM, LTRIM, RTRIM, POSITION\n+\n+    /// Can be parsed as a composition of functions, but the contents must be unwrapped:\n+    /// POSITION(x IN y) -> POSITION(in(x, y)) -> POSITION(y, x)\n+\n+    /// Can be parsed as a function, but not always:\n+    /// CAST(x AS type) - alias has to be unwrapped\n+    /// CAST(x AS type(params))\n+\n+    /// Can be parsed as a function, but some identifier arguments have special meanings.\n+    /// DATE_ADD(MINUTE, x, y) -> addMinutes(x, y)\n+    /// DATE_DIFF(MINUTE, x, y)\n+\n+    /// Have keywords that have to processed explicitly:\n+    /// EXTRACT(x FROM y)\n+    /// TRIM(BOTH|LEADING|TRAILING x FROM y)\n+    /// SUBSTRING(x FROM a)\n+    /// SUBSTRING(x FROM a FOR b)\n+\n+    String function_name = getIdentifierName(identifier);\n+    String function_name_lowercase = Poco::toLower(function_name);\n+\n+    if (is_table_function)\n+    {\n+        if (function_name_lowercase == \"view\")\n+            return std::make_unique<ViewLayer>(false);\n+        else if (function_name_lowercase == \"viewifpermitted\")\n+            return std::make_unique<ViewLayer>(true);\n+    }\n+\n+    if (function_name_lowercase == \"cast\")\n+        return std::make_unique<CastLayer>();\n+    else if (function_name_lowercase == \"extract\")\n+        return std::make_unique<ExtractLayer>();\n+    else if (function_name_lowercase == \"substring\")\n+        return std::make_unique<SubstringLayer>();\n+    else if (function_name_lowercase == \"position\")\n+        return std::make_unique<PositionLayer>();\n+    else if (function_name_lowercase == \"exists\")\n+        return std::make_unique<ExistsLayer>();\n+    else if (function_name_lowercase == \"trim\")\n+        return std::make_unique<TrimLayer>(false, false);\n+    else if (function_name_lowercase == \"ltrim\")\n+        return std::make_unique<TrimLayer>(true, false);\n+    else if (function_name_lowercase == \"rtrim\")\n+        return std::make_unique<TrimLayer>(false, true);\n+    else if (function_name_lowercase == \"dateadd\" || function_name_lowercase == \"date_add\"\n+        || function_name_lowercase == \"timestampadd\" || function_name_lowercase == \"timestamp_add\")\n+        return std::make_unique<DateAddLayer>(\"plus\");\n+    else if (function_name_lowercase == \"datesub\" || function_name_lowercase == \"date_sub\"\n+        || function_name_lowercase == \"timestampsub\" || function_name_lowercase == \"timestamp_sub\")\n+        return std::make_unique<DateAddLayer>(\"minus\");\n+    else if (function_name_lowercase == \"datediff\" || function_name_lowercase == \"date_diff\"\n+        || function_name_lowercase == \"timestampdiff\" || function_name_lowercase == \"timestamp_diff\")\n+        return std::make_unique<DateDiffLayer>();\n+    else if (function_name_lowercase == \"grouping\")\n+        return std::make_unique<OrdinaryFunctionLayer>(function_name_lowercase, allow_function_parameters_);\n+    else\n+        return std::make_unique<OrdinaryFunctionLayer>(function_name, allow_function_parameters_);\n+}\n+\n+\n+bool ParseCastExpression(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    IParser::Pos begin = pos;\n+\n+    if (ParserCastOperator().parse(pos, node, expected))\n+        return true;\n+\n+    pos = begin;\n+\n+    /// As an exception, negative numbers should be parsed as literals, and not as an application of the operator.\n+    if (pos->type == TokenType::Minus)\n+    {\n+        if (ParserLiteral().parse(pos, node, expected))\n+            return true;\n+    }\n+    return false;\n+}\n+\n+bool ParseDateOperatorExpression(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n {\n     auto begin = pos;\n \n     /// If no DATE keyword, go to the nested parser.\n     if (!ParserKeyword(\"DATE\").ignore(pos, expected))\n-        return next_parser.parse(pos, node, expected);\n+        return false;\n \n     ASTPtr expr;\n     if (!ParserStringLiteral().parse(pos, expr, expected))\n     {\n         pos = begin;\n-        return next_parser.parse(pos, node, expected);\n+        return false;\n     }\n \n-    /// the function corresponding to the operator\n-    auto function = std::make_shared<ASTFunction>();\n-\n-    /// function arguments\n-    auto exp_list = std::make_shared<ASTExpressionList>();\n-\n-    /// the first argument of the function is the previous element, the second is the next one\n-    function->name = \"toDate\";\n-    function->arguments = exp_list;\n-    function->children.push_back(exp_list);\n-\n-    exp_list->children.push_back(expr);\n-\n-    node = function;\n+    node = makeASTFunction(\"toDate\", expr);\n     return true;\n }\n \n-bool ParserTimestampOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+bool ParseTimestampOperatorExpression(IParser::Pos & pos, ASTPtr & node, Expected & expected)\n {\n     auto begin = pos;\n \n     /// If no TIMESTAMP keyword, go to the nested parser.\n     if (!ParserKeyword(\"TIMESTAMP\").ignore(pos, expected))\n-        return next_parser.parse(pos, node, expected);\n+        return false;\n \n     ASTPtr expr;\n     if (!ParserStringLiteral().parse(pos, expr, expected))\n     {\n         pos = begin;\n-        return next_parser.parse(pos, node, expected);\n+        return false;\n     }\n \n-    /// the function corresponding to the operator\n-    auto function = std::make_shared<ASTFunction>();\n+    node = makeASTFunction(\"toDateTime\", expr);\n \n-    /// function arguments\n-    auto exp_list = std::make_shared<ASTExpressionList>();\n+    return true;\n+}\n \n-    /// the first argument of the function is the previous element, the second is the next one\n-    function->name = \"toDateTime\";\n-    function->arguments = exp_list;\n-    function->children.push_back(exp_list);\n+struct ParserExpressionImpl\n+{\n+    static std::vector<std::pair<const char *, Operator>> operators_table;\n+    static std::vector<std::pair<const char *, Operator>> unary_operators_table;\n+    static const char * overlapping_operators_to_skip[];\n \n-    exp_list->children.push_back(expr);\n+    static Operator finish_between_operator;\n \n-    node = function;\n-    return true;\n+    ParserCompoundIdentifier identifier_parser{false, true};\n+    ParserNumber number_parser;\n+    ParserAsterisk asterisk_parser;\n+    ParserLiteral literal_parser;\n+    ParserTupleOfLiterals tuple_literal_parser;\n+    ParserArrayOfLiterals array_literal_parser;\n+    ParserSubstitution substitution_parser;\n+    ParserMySQLGlobalVariable mysql_global_variable_parser;\n+\n+    ParserKeyword any_parser{\"ANY\"};\n+    ParserKeyword all_parser{\"ALL\"};\n+\n+    // Recursion\n+    ParserQualifiedAsterisk qualified_asterisk_parser;\n+    ParserColumnsMatcher columns_matcher_parser;\n+    ParserSubquery subquery_parser;\n+\n+    bool parse(std::unique_ptr<Layer> start, IParser::Pos & pos, ASTPtr & node, Expected & expected);\n+\n+    using Layers = std::vector<std::unique_ptr<Layer>>;\n+\n+    Action tryParseOperand(Layers & layers, IParser::Pos & pos, Expected & expected);\n+    static Action tryParseOperator(Layers & layers, IParser::Pos & pos, Expected & expected);\n+};\n+\n+\n+bool ParserExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    auto start = std::make_unique<ExpressionLayer>(false);\n+    return ParserExpressionImpl().parse(std::move(start), pos, node, expected);\n }\n \n-bool ParserIntervalOperatorExpression::parseArgumentAndIntervalKind(\n-    Pos & pos, ASTPtr & expr, IntervalKind & interval_kind, Expected & expected)\n+bool ParserTableFunctionExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n {\n-    auto begin = pos;\n-    auto init_expected = expected;\n-    ASTPtr string_literal;\n-    //// A String literal followed INTERVAL keyword,\n-    /// the literal can be a part of an expression or\n-    /// include Number and INTERVAL TYPE at the same time\n-    if (ParserStringLiteral{}.parse(pos, string_literal, expected))\n+    auto start = std::make_unique<ExpressionLayer>(true);\n+    return ParserExpressionImpl().parse(std::move(start), pos, node, expected);\n+}\n+\n+bool ParserArray::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    auto start = std::make_unique<ArrayLayer>();\n+    return ParserToken(TokenType::OpeningSquareBracket).ignore(pos, expected)\n+        && ParserExpressionImpl().parse(std::move(start), pos, node, expected);\n+}\n+\n+bool ParserFunction::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    ASTPtr identifier;\n+\n+    if (ParserIdentifier(true).parse(pos, identifier, expected)\n+        && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))\n+    {\n+        auto start = getFunctionLayer(identifier, is_table_function, allow_function_parameters);\n+        start->is_table_function = is_table_function;\n+        return ParserExpressionImpl().parse(std::move(start), pos, node, expected);\n+    }\n+    else\n+    {\n+        return false;\n+    }\n+}\n+\n+std::vector<std::pair<const char *, Operator>> ParserExpressionImpl::operators_table({\n+        {\"->\",            Operator(\"lambda\",          1,  2, OperatorType::Lambda)},\n+        {\"?\",             Operator(\"\",                2,  0, OperatorType::StartIf)},\n+        {\":\",             Operator(\"if\",              3,  3, OperatorType::FinishIf)},\n+        {\"OR\",            Operator(\"or\",              3,  2, OperatorType::Mergeable)},\n+        {\"AND\",           Operator(\"and\",             4,  2, OperatorType::Mergeable)},\n+        {\"BETWEEN\",       Operator(\"\",                6,  0, OperatorType::StartBetween)},\n+        {\"NOT BETWEEN\",   Operator(\"\",                6,  0, OperatorType::StartNotBetween)},\n+        {\"IS NULL\",       Operator(\"isNull\",          8,  1, OperatorType::IsNull)},\n+        {\"IS NOT NULL\",   Operator(\"isNotNull\",       8,  1, OperatorType::IsNull)},\n+        {\"==\",            Operator(\"equals\",          9,  2, OperatorType::Comparison)},\n+        {\"!=\",            Operator(\"notEquals\",       9,  2, OperatorType::Comparison)},\n+        {\"<>\",            Operator(\"notEquals\",       9,  2, OperatorType::Comparison)},\n+        {\"<=\",            Operator(\"lessOrEquals\",    9,  2, OperatorType::Comparison)},\n+        {\">=\",            Operator(\"greaterOrEquals\", 9,  2, OperatorType::Comparison)},\n+        {\"<\",             Operator(\"less\",            9,  2, OperatorType::Comparison)},\n+        {\">\",             Operator(\"greater\",         9,  2, OperatorType::Comparison)},\n+        {\"=\",             Operator(\"equals\",          9,  2, OperatorType::Comparison)},\n+        {\"LIKE\",          Operator(\"like\",            9)},\n+        {\"ILIKE\",         Operator(\"ilike\",           9)},\n+        {\"NOT LIKE\",      Operator(\"notLike\",         9)},\n+        {\"NOT ILIKE\",     Operator(\"notILike\",        9)},\n+        {\"IN\",            Operator(\"in\",              9)},\n+        {\"NOT IN\",        Operator(\"notIn\",           9)},\n+        {\"GLOBAL IN\",     Operator(\"globalIn\",        9)},\n+        {\"GLOBAL NOT IN\", Operator(\"globalNotIn\",     9)},\n+        {\"||\",            Operator(\"concat\",          10, 2, OperatorType::Mergeable)},\n+        {\"+\",             Operator(\"plus\",            11)},\n+        {\"-\",             Operator(\"minus\",           11)},\n+        {\"*\",             Operator(\"multiply\",        12)},\n+        {\"/\",             Operator(\"divide\",          12)},\n+        {\"%\",             Operator(\"modulo\",          12)},\n+        {\"MOD\",           Operator(\"modulo\",          12)},\n+        {\"DIV\",           Operator(\"intDiv\",          12)},\n+        {\".\",             Operator(\"tupleElement\",    14, 2, OperatorType::TupleElement)},\n+        {\"[\",             Operator(\"arrayElement\",    14, 2, OperatorType::ArrayElement)},\n+        {\"::\",            Operator(\"CAST\",            14, 2, OperatorType::Cast)},\n+    });\n+\n+std::vector<std::pair<const char *, Operator>> ParserExpressionImpl::unary_operators_table({\n+        {\"NOT\",           Operator(\"not\",             5,  1)},\n+        {\"-\",             Operator(\"negate\",          13, 1)}\n+    });\n+\n+Operator ParserExpressionImpl::finish_between_operator = Operator(\"\", 7, 0, OperatorType::FinishBetween);\n+\n+const char * ParserExpressionImpl::overlapping_operators_to_skip[] =\n+{\n+    \"IN PARTITION\",\n+    nullptr\n+};\n+\n+bool ParserExpressionImpl::parse(std::unique_ptr<Layer> start, IParser::Pos & pos, ASTPtr & node, Expected & expected)\n+{\n+    Action next = Action::OPERAND;\n+\n+    Layers layers;\n+    layers.push_back(std::move(start));\n+\n+    while (true)\n     {\n-        String literal;\n-        if (string_literal->as<ASTLiteral &>().value.tryGet(literal))\n+        while (pos.isValid())\n         {\n-            Tokens tokens(literal.data(), literal.data() + literal.size());\n-            Pos token_pos(tokens, 0);\n-            Expected token_expected;\n+            if (!layers.back()->parse(pos, expected, next))\n+                break;\n \n-            if (!ParserNumber{}.parse(token_pos, expr, token_expected))\n-                return false;\n+            if (layers.back()->isFinished())\n+            {\n+                if (layers.size() == 1)\n+                    break;\n+\n+                next = Action::OPERATOR;\n+\n+                ASTPtr res;\n+                if (!layers.back()->getResult(res))\n+                    break;\n+\n+                layers.pop_back();\n+                layers.back()->pushOperand(res);\n+                continue;\n+            }\n+\n+            if (next == Action::OPERAND)\n+                next = tryParseOperand(layers, pos, expected);\n             else\n+                next = tryParseOperator(layers, pos, expected);\n+\n+            if (next == Action::NONE)\n+                break;\n+        }\n+\n+        /// When we exit the loop we should be on the 1st level\n+        if (layers.size() == 1 && layers.back()->getResult(node))\n+            return true;\n+\n+        layers.pop_back();\n+\n+        /// We try to check whether there was a checkpoint\n+        while (!layers.empty() && !layers.back()->saved_checkpoint)\n+            layers.pop_back();\n+\n+        if (layers.empty())\n+            return false;\n+\n+        /// Currently all checkpoints are located in operand section\n+        next = Action::OPERAND;\n+\n+        auto saved_checkpoint = layers.back()->saved_checkpoint.value();\n+        layers.back()->saved_checkpoint.reset();\n+\n+        pos = saved_checkpoint.first;\n+        layers.back()->current_checkpoint = saved_checkpoint.second;\n+    }\n+}\n+\n+Action ParserExpressionImpl::tryParseOperand(Layers & layers, IParser::Pos & pos, Expected & expected)\n+{\n+    ASTPtr tmp;\n+\n+    if (layers.front()->is_table_function)\n+    {\n+        if (typeid_cast<ViewLayer *>(layers.back().get()))\n+        {\n+            if (identifier_parser.parse(pos, tmp, expected)\n+                && ParserToken(TokenType::OpeningRoundBracket).ignore(pos, expected))\n+            {\n+                layers.push_back(getFunctionLayer(tmp, layers.front()->is_table_function));\n+                return Action::OPERAND;\n+            }\n+            return Action::NONE;\n+        }\n+\n+        /// Current element should be empty (there should be no other operands or operators)\n+        /// to parse SETTINGS in table function\n+        if (layers.back()->isCurrentElementEmpty())\n+        {\n+            auto old_pos = pos;\n+            ParserKeyword s_settings(\"SETTINGS\");\n+            if (s_settings.ignore(pos, expected))\n             {\n-                /// case: INTERVAL '1' HOUR\n-                /// back to begin\n-                if (!token_pos.isValid())\n+                ParserSetQuery parser_settings(true);\n+                if (parser_settings.parse(pos, tmp, expected))\n                 {\n-                    pos = begin;\n-                    expected = init_expected;\n+                    layers.back()->pushOperand(tmp);\n+                    return Action::OPERAND;\n                 }\n                 else\n-                    /// case: INTERVAL '1 HOUR'\n-                    return parseIntervalKind(token_pos, token_expected, interval_kind);\n+                {\n+                    pos = old_pos;\n+                }\n             }\n         }\n     }\n-    // case: INTERVAL expr HOUR\n-    if (!ParserExpressionWithOptionalAlias(false).parse(pos, expr, expected))\n-        return false;\n-    return parseIntervalKind(pos, expected, interval_kind);\n-}\n \n-bool ParserIntervalOperatorExpression::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    auto begin = pos;\n+    /// Special case for cast expression\n+    if (layers.back()->previousType() != OperatorType::TupleElement &&\n+        ParseCastExpression(pos, tmp, expected))\n+    {\n+        layers.back()->pushOperand(std::move(tmp));\n+        return Action::OPERATOR;\n+    }\n+\n+    if (layers.back()->previousType() == OperatorType::Comparison)\n+    {\n+        SubqueryFunctionType subquery_function_type = SubqueryFunctionType::NONE;\n \n-    /// If no INTERVAL keyword, go to the nested parser.\n-    if (!ParserKeyword(\"INTERVAL\").ignore(pos, expected))\n-        return next_parser.parse(pos, node, expected);\n+        if (any_parser.ignore(pos, expected) && subquery_parser.parse(pos, tmp, expected))\n+            subquery_function_type = SubqueryFunctionType::ANY;\n+        else if (all_parser.ignore(pos, expected) && subquery_parser.parse(pos, tmp, expected))\n+            subquery_function_type = SubqueryFunctionType::ALL;\n \n-    ASTPtr expr;\n-    IntervalKind interval_kind;\n-    if (!parseArgumentAndIntervalKind(pos, expr, interval_kind, expected))\n+        if (subquery_function_type != SubqueryFunctionType::NONE)\n+        {\n+            Operator prev_op;\n+            ASTPtr function, argument;\n+\n+            if (!layers.back()->popOperator(prev_op))\n+                return Action::NONE;\n+            if (!layers.back()->popOperand(argument))\n+                return Action::NONE;\n+\n+            function = makeASTFunction(prev_op.function_name, argument, tmp);\n+\n+            if (!modifyAST(function, subquery_function_type))\n+                return Action::NONE;\n+\n+            layers.back()->pushOperand(std::move(function));\n+            return Action::OPERATOR;\n+        }\n+    }\n+\n+    /// Try to find any unary operators\n+    auto cur_op = unary_operators_table.begin();\n+    for (; cur_op != unary_operators_table.end(); ++cur_op)\n     {\n-        pos = begin;\n-        return next_parser.parse(pos, node, expected);\n+        if (parseOperator(pos, cur_op->first, expected))\n+            break;\n+    }\n+\n+    if (cur_op != unary_operators_table.end())\n+    {\n+        layers.back()->pushOperator(cur_op->second);\n+        return Action::OPERAND;\n     }\n \n-    /// the function corresponding to the operator\n-    auto function = std::make_shared<ASTFunction>();\n+    auto old_pos = pos;\n+    auto current_checkpoint = layers.back()->current_checkpoint;\n+    layers.back()->current_checkpoint = Checkpoint::None;\n \n-    /// function arguments\n-    auto exp_list = std::make_shared<ASTExpressionList>();\n+    if (current_checkpoint != Checkpoint::Interval && parseOperator(pos, \"INTERVAL\", expected))\n+    {\n+        layers.back()->saved_checkpoint = {old_pos, Checkpoint::Interval};\n+        layers.push_back(std::make_unique<IntervalLayer>());\n+        return Action::OPERAND;\n+    }\n+    else if (current_checkpoint != Checkpoint::Case && parseOperator(pos, \"CASE\", expected))\n+    {\n+        layers.back()->saved_checkpoint = {old_pos, Checkpoint::Case};\n+        layers.push_back(std::make_unique<CaseLayer>());\n+        return Action::OPERAND;\n+    }\n \n-    /// the first argument of the function is the previous element, the second is the next one\n-    function->name = interval_kind.toNameOfFunctionToIntervalDataType();\n-    function->arguments = exp_list;\n-    function->children.push_back(exp_list);\n+    if (ParseDateOperatorExpression(pos, tmp, expected) ||\n+        ParseTimestampOperatorExpression(pos, tmp, expected) ||\n+        tuple_literal_parser.parse(pos, tmp, expected) ||\n+        array_literal_parser.parse(pos, tmp, expected) ||\n+        number_parser.parse(pos, tmp, expected) ||\n+        literal_parser.parse(pos, tmp, expected) ||\n+        asterisk_parser.parse(pos, tmp, expected) ||\n+        qualified_asterisk_parser.parse(pos, tmp, expected) ||\n+        columns_matcher_parser.parse(pos, tmp, expected))\n+    {\n+        layers.back()->pushOperand(std::move(tmp));\n+    }\n+    else if (identifier_parser.parse(pos, tmp, expected))\n+    {\n+        if (pos->type == TokenType::OpeningRoundBracket)\n+        {\n+            ++pos;\n+            layers.push_back(getFunctionLayer(tmp, layers.front()->is_table_function));\n+            return Action::OPERAND;\n+        }\n+        else\n+        {\n+            layers.back()->pushOperand(std::move(tmp));\n+        }\n+    }\n+    else if (substitution_parser.parse(pos, tmp, expected))\n+    {\n+        layers.back()->pushOperand(std::move(tmp));\n+    }\n+    else if (pos->type == TokenType::OpeningRoundBracket)\n+    {\n+        if (subquery_parser.parse(pos, tmp, expected))\n+        {\n+            layers.back()->pushOperand(std::move(tmp));\n+            return Action::OPERATOR;\n+        }\n \n-    exp_list->children.push_back(expr);\n+        ++pos;\n+        layers.push_back(std::make_unique<RoundBracketsLayer>());\n+        return Action::OPERAND;\n+    }\n+    else if (pos->type == TokenType::OpeningSquareBracket)\n+    {\n+        ++pos;\n+        layers.push_back(std::make_unique<ArrayLayer>());\n+        return Action::OPERAND;\n+    }\n+    else if (mysql_global_variable_parser.parse(pos, tmp, expected))\n+    {\n+        layers.back()->pushOperand(std::move(tmp));\n+    }\n+    else\n+    {\n+        return Action::NONE;\n+    }\n \n-    node = function;\n-    return true;\n+    return Action::OPERATOR;\n }\n \n-bool ParserKeyValuePair::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n+Action ParserExpressionImpl::tryParseOperator(Layers & layers, IParser::Pos & pos, Expected & expected)\n {\n-    ParserIdentifier id_parser;\n-    ParserLiteral literal_parser;\n-    ParserFunction func_parser;\n+    ASTPtr tmp;\n+\n+    /// ParserExpression can be called in this part of the query:\n+    ///  ALTER TABLE partition_all2 CLEAR INDEX [ p ] IN PARTITION ALL\n+    ///\n+    /// 'IN PARTITION' here is not an 'IN' operator, so we should stop parsing immediately\n+    Expected stub;\n+    for (const char ** it = overlapping_operators_to_skip; *it; ++it)\n+        if (ParserKeyword{*it}.checkWithoutMoving(pos, stub))\n+            return Action::NONE;\n+\n+    /// Try to find operators from 'operators_table'\n+    auto cur_op = operators_table.begin();\n+    for (; cur_op != operators_table.end(); ++cur_op)\n+    {\n+        if (parseOperator(pos, cur_op->first, expected))\n+            break;\n+    }\n \n-    ASTPtr identifier;\n-    ASTPtr value;\n-    bool with_brackets = false;\n-    if (!id_parser.parse(pos, identifier, expected))\n-        return false;\n+    if (cur_op == operators_table.end())\n+    {\n+        auto old_pos = pos;\n+        if (layers.back()->allow_alias && ParserAlias(layers.back()->allow_alias_without_as_keyword).parse(pos, tmp, expected))\n+        {\n+            if (layers.back()->insertAlias(tmp))\n+                return Action::OPERATOR;\n+        }\n+        pos = old_pos;\n+        return Action::NONE;\n+    }\n \n-    /// If it's neither literal, nor identifier, nor function, than it's possible list of pairs\n-    if (!func_parser.parse(pos, value, expected) && !literal_parser.parse(pos, value, expected) && !id_parser.parse(pos, value, expected))\n+    auto op = cur_op->second;\n+\n+    if (op.type == OperatorType::Lambda)\n     {\n-        ParserKeyValuePairsList kv_pairs_list;\n-        ParserToken open(TokenType::OpeningRoundBracket);\n-        ParserToken close(TokenType::ClosingRoundBracket);\n+        if (!layers.back()->parseLambda())\n+            return Action::NONE;\n \n-        if (!open.ignore(pos))\n-            return false;\n+        layers.back()->pushOperator(op);\n+        return Action::OPERAND;\n+    }\n \n-        if (!kv_pairs_list.parse(pos, value, expected))\n-            return false;\n+    /// 'AND' can be both boolean function and part of the '... BETWEEN ... AND ...' operator\n+    if (op.function_name == \"and\" && layers.back()->between_counter)\n+    {\n+        layers.back()->between_counter--;\n+        op = finish_between_operator;\n+    }\n \n-        if (!close.ignore(pos))\n-            return false;\n+    while (layers.back()->previousPriority() >= op.priority)\n+    {\n+        ASTPtr function;\n+        Operator prev_op;\n+        layers.back()->popOperator(prev_op);\n \n-        with_brackets = true;\n+        /// Mergeable operators are operators that are merged into one function:\n+        /// For example: 'a OR b OR c' -> 'or(a, b, c)' and not 'or(or(a,b), c)'\n+        if (prev_op.type == OperatorType::Mergeable && op.function_name == prev_op.function_name)\n+        {\n+            op.arity += prev_op.arity - 1;\n+            break;\n+        }\n+\n+        if (prev_op.type == OperatorType::FinishBetween)\n+        {\n+            Operator tmp_op;\n+            if (!layers.back()->popOperator(tmp_op))\n+                return Action::NONE;\n+\n+            if (tmp_op.type != OperatorType::StartBetween && tmp_op.type != OperatorType::StartNotBetween)\n+                return Action::NONE;\n+\n+            bool negative = tmp_op.type == OperatorType::StartNotBetween;\n+\n+            ASTs arguments;\n+            if (!layers.back()->popLastNOperands(arguments, 3))\n+                return Action::NONE;\n+\n+            function = makeBetweenOperator(negative, arguments);\n+        }\n+        else\n+        {\n+            function = makeASTFunction(prev_op.function_name);\n+\n+            if (!layers.back()->popLastNOperands(function->children[0]->children, prev_op.arity))\n+                return Action::NONE;\n+        }\n+\n+        layers.back()->pushOperand(function);\n     }\n \n-    auto pair = std::make_shared<ASTPair>(with_brackets);\n-    pair->first = Poco::toLower(identifier->as<ASTIdentifier>()->name());\n-    pair->set(pair->second, value);\n-    node = pair;\n-    return true;\n-}\n+    layers.back()->pushOperator(op);\n \n-bool ParserKeyValuePairsList::parseImpl(Pos & pos, ASTPtr & node, Expected & expected)\n-{\n-    ParserList parser(std::make_unique<ParserKeyValuePair>(), std::make_unique<ParserNothing>(), true, 0);\n-    return parser.parse(pos, node, expected);\n+    if (op.type == OperatorType::ArrayElement)\n+        layers.push_back(std::make_unique<ArrayElementLayer>());\n+\n+\n+    Action next = Action::OPERAND;\n+\n+    /// isNull & isNotNull are postfix unary operators\n+    if (op.type == OperatorType::IsNull)\n+        next = Action::OPERATOR;\n+\n+    if (op.type == OperatorType::StartBetween || op.type == OperatorType::StartNotBetween)\n+        layers.back()->between_counter++;\n+\n+    if (op.type == OperatorType::Cast)\n+    {\n+        next = Action::OPERATOR;\n+\n+        ASTPtr type_ast;\n+        if (!ParserDataType().parse(pos, type_ast, expected))\n+            return Action::NONE;\n+\n+        layers.back()->pushOperand(std::make_shared<ASTLiteral>(queryToString(type_ast)));\n+    }\n+\n+    return next;\n }\n \n }\ndiff --git a/src/Parsers/ExpressionListParsers.h b/src/Parsers/ExpressionListParsers.h\nindex 05c7ec946eee..653654e5a33a 100644\n--- a/src/Parsers/ExpressionListParsers.h\n+++ b/src/Parsers/ExpressionListParsers.h\n@@ -116,75 +116,40 @@ class ParserUnionList : public IParserBase\n     SelectUnionModes union_modes;\n };\n \n-/** An expression with an infix binary left-associative operator.\n-  * For example, a + b - c + d.\n-  */\n-class ParserLeftAssociativeBinaryOperatorList : public IParserBase\n-{\n-private:\n-    Operators_t operators;\n-    Operators_t overlapping_operators_to_skip = { (const char *[]){ nullptr } };\n-    ParserPtr first_elem_parser;\n-    ParserPtr remaining_elem_parser;\n-    /// =, !=, <, > ALL (subquery) / ANY (subquery)\n-    bool comparison_expression = false;\n-\n-public:\n-    /** `operators_` - allowed operators and their corresponding functions\n-      */\n-    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_, ParserPtr && first_elem_parser_)\n-        : operators(operators_), first_elem_parser(std::move(first_elem_parser_))\n-    {\n-    }\n-\n-    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_,\n-            Operators_t overlapping_operators_to_skip_, ParserPtr && first_elem_parser_, bool comparison_expression_ = false)\n-        : operators(operators_), overlapping_operators_to_skip(overlapping_operators_to_skip_),\n-          first_elem_parser(std::move(first_elem_parser_)), comparison_expression(comparison_expression_)\n-    {\n-    }\n-\n-    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_, ParserPtr && first_elem_parser_,\n-        ParserPtr && remaining_elem_parser_)\n-        : operators(operators_), first_elem_parser(std::move(first_elem_parser_)),\n-          remaining_elem_parser(std::move(remaining_elem_parser_))\n-    {\n-    }\n \n+class ParserArray : public IParserBase\n+{\n protected:\n-    const char * getName() const override { return \"list, delimited by binary operators\"; }\n-\n+    const char * getName() const override { return \"array\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n-\n-/** Expression with an infix operator of arbitrary arity.\n-  * For example, a AND b AND c AND d.\n+/** A function, for example, f(x, y + 1, g(z)).\n+  * Or an aggregate function: sum(x + f(y)), corr(x, y). The syntax is the same as the usual function.\n+  * Or a parametric aggregate function: quantile(0.9)(x + y).\n+  *  Syntax - two pairs of parentheses instead of one. The first is for parameters, the second for arguments.\n+  * For functions, the DISTINCT modifier can be specified, for example, count(DISTINCT x, y).\n   */\n-class ParserVariableArityOperatorList : public IParserBase\n+class ParserFunction : public IParserBase\n {\n-private:\n-    const char * infix;\n-    const char * function_name;\n-    ParserPtr elem_parser;\n-\n public:\n-    ParserVariableArityOperatorList(const char * infix_, const char * function_, ParserPtr && elem_parser_)\n-        : infix(infix_), function_name(function_), elem_parser(std::move(elem_parser_))\n+    explicit ParserFunction(bool allow_function_parameters_ = true, bool is_table_function_ = false)\n+        : allow_function_parameters(allow_function_parameters_), is_table_function(is_table_function_)\n     {\n     }\n \n protected:\n-    const char * getName() const override { return \"list, delimited by operator of variable arity\"; }\n-\n+    const char * getName() const override { return \"function\"; }\n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n+    bool allow_function_parameters;\n+    bool is_table_function;\n };\n \n \n-/** An expression with a prefix unary operator.\n-  * Example, NOT x.\n+/** An expression with an infix binary left-associative operator.\n+  * For example, a + b - c + d.\n   */\n-class ParserPrefixUnaryOperatorExpression : public IParserBase\n+class ParserLeftAssociativeBinaryOperatorList : public IParserBase\n {\n private:\n     Operators_t operators;\n@@ -193,260 +158,20 @@ class ParserPrefixUnaryOperatorExpression : public IParserBase\n public:\n     /** `operators_` - allowed operators and their corresponding functions\n       */\n-    ParserPrefixUnaryOperatorExpression(Operators_t operators_, ParserPtr && elem_parser_)\n+    ParserLeftAssociativeBinaryOperatorList(Operators_t operators_, ParserPtr && elem_parser_)\n         : operators(operators_), elem_parser(std::move(elem_parser_))\n     {\n     }\n \n protected:\n-    const char * getName() const override { return \"expression with prefix unary operator\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-/// CAST operator \"::\". This parser is used if left argument\n-/// of operator cannot be read as simple literal from text of query.\n-/// Example: \"[1, 1 + 1, 1 + 2]::Array(UInt8)\"\n-class ParserCastExpression : public IParserBase\n-{\n-private:\n-    ParserPtr elem_parser;\n-\n-public:\n-    explicit ParserCastExpression(ParserPtr && elem_parser_)\n-        : elem_parser(std::move(elem_parser_))\n-    {\n-    }\n-\n-protected:\n-    const char * getName() const override { return \"CAST expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-class ParserArrayElementExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-\n-protected:\n-    const char * getName() const  override{ return \"array element expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-class ParserTupleElementExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-\n-protected:\n-    const char * getName() const override { return \"tuple element expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-class ParserUnaryExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-    ParserPrefixUnaryOperatorExpression operator_parser {operators, std::make_unique<ParserCastExpression>(std::make_unique<ParserTupleElementExpression>())};\n-\n-protected:\n-    const char * getName() const override { return \"unary expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-class ParserMultiplicativeExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-    ParserLeftAssociativeBinaryOperatorList operator_parser {operators, std::make_unique<ParserUnaryExpression>()};\n-\n-protected:\n-    const char * getName() const  override { return \"multiplicative expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-/// DATE operator. \"DATE '2001-01-01'\" would be parsed as \"toDate('2001-01-01')\".\n-class ParserDateOperatorExpression : public IParserBase\n-{\n-protected:\n-    ParserMultiplicativeExpression next_parser;\n-\n-    const char * getName() const  override { return \"DATE operator expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-/// TIMESTAMP operator. \"TIMESTAMP '2001-01-01 12:34:56'\" would be parsed as \"toDateTime('2001-01-01 12:34:56')\".\n-class ParserTimestampOperatorExpression : public IParserBase\n-{\n-protected:\n-    ParserDateOperatorExpression next_parser;\n-\n-    const char * getName() const  override { return \"TIMESTAMP operator expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-/// Optional conversion to INTERVAL data type. Example: \"INTERVAL x SECOND\" parsed as \"toIntervalSecond(x)\".\n-class ParserIntervalOperatorExpression : public IParserBase\n-{\n-protected:\n-    ParserTimestampOperatorExpression next_parser;\n-\n-    const char * getName() const  override { return \"INTERVAL operator expression\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-\n-private:\n-    static bool parseArgumentAndIntervalKind(Pos & pos, ASTPtr & expr, IntervalKind & interval_kind, Expected & expected);\n-};\n-\n-class ParserAdditiveExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-    ParserLeftAssociativeBinaryOperatorList operator_parser {operators, std::make_unique<ParserIntervalOperatorExpression>()};\n-\n-protected:\n-    const char * getName() const  override { return \"additive expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-\n-class ParserConcatExpression : public IParserBase\n-{\n-    ParserVariableArityOperatorList operator_parser {\"||\", \"concat\", std::make_unique<ParserAdditiveExpression>()};\n-\n-protected:\n-    const char * getName() const override { return \"string concatenation expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-\n-class ParserBetweenExpression : public IParserBase\n-{\n-private:\n-    ParserConcatExpression elem_parser;\n-\n-protected:\n-    const char * getName() const override { return \"BETWEEN expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-class ParserComparisonExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-    static const char * overlapping_operators_to_skip[];\n-    ParserLeftAssociativeBinaryOperatorList operator_parser {operators,\n-        overlapping_operators_to_skip, std::make_unique<ParserBetweenExpression>(), true};\n-\n-protected:\n-    const char * getName() const  override{ return \"comparison expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-/** Parser for nullity checking with IS (NOT) NULL.\n-  */\n-class ParserNullityChecking : public IParserBase\n-{\n-private:\n-    ParserComparisonExpression elem_parser;\n-\n-protected:\n-    const char * getName() const override { return \"nullity checking\"; }\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n-};\n-\n-\n-class ParserLogicalNotExpression : public IParserBase\n-{\n-private:\n-    static const char * operators[];\n-    ParserPrefixUnaryOperatorExpression operator_parser {operators, std::make_unique<ParserNullityChecking>()};\n-\n-protected:\n-    const char * getName() const  override{ return \"logical-NOT expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-\n-class ParserLogicalAndExpression : public IParserBase\n-{\n-private:\n-    ParserVariableArityOperatorList operator_parser {\"AND\", \"and\", std::make_unique<ParserLogicalNotExpression>()};\n-\n-protected:\n-    const char * getName() const override { return \"logical-AND expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-\n-class ParserLogicalOrExpression : public IParserBase\n-{\n-private:\n-    ParserVariableArityOperatorList operator_parser {\"OR\", \"or\", std::make_unique<ParserLogicalAndExpression>()};\n-\n-protected:\n-    const char * getName() const override { return \"logical-OR expression\"; }\n-\n-    bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override\n-    {\n-        return operator_parser.parse(pos, node, expected);\n-    }\n-};\n-\n-\n-/** An expression with ternary operator.\n-  * For example, a = 1 ? b + 1 : c * 2.\n-  */\n-class ParserTernaryOperatorExpression : public IParserBase\n-{\n-private:\n-    ParserLogicalOrExpression elem_parser;\n-\n-protected:\n-    const char * getName() const override { return \"expression with ternary operator\"; }\n+    const char * getName() const override { return \"list, delimited by binary operators\"; }\n \n     bool parseImpl(Pos & pos, ASTPtr & node, Expected & expected) override;\n };\n \n \n-class ParserLambdaExpression : public IParserBase\n+class ParserExpression : public IParserBase\n {\n-private:\n-    ParserTernaryOperatorExpression elem_parser;\n-\n protected:\n     const char * getName() const override { return \"lambda expression\"; }\n \n@@ -457,9 +182,6 @@ class ParserLambdaExpression : public IParserBase\n // It's used to parse expressions in table function.\n class ParserTableFunctionExpression : public IParserBase\n {\n-private:\n-    ParserLambdaExpression elem_parser;\n-\n protected:\n     const char * getName() const override { return \"table function expression\"; }\n \n@@ -467,13 +189,10 @@ class ParserTableFunctionExpression : public IParserBase\n };\n \n \n-using ParserExpression = ParserLambdaExpression;\n-\n-\n class ParserExpressionWithOptionalAlias : public IParserBase\n {\n public:\n-    explicit ParserExpressionWithOptionalAlias(bool allow_alias_without_as_keyword, bool is_table_function = false);\n+    explicit ParserExpressionWithOptionalAlias(bool allow_alias_without_as_keyword_, bool is_table_function_ = false);\n protected:\n     ParserPtr impl;\n \ndiff --git a/src/Parsers/IAST.cpp b/src/Parsers/IAST.cpp\nindex f1557076a07e..65740f290b5c 100644\n--- a/src/Parsers/IAST.cpp\n+++ b/src/Parsers/IAST.cpp\n@@ -138,14 +138,28 @@ void IAST::updateTreeHashImpl(SipHash & hash_state) const\n }\n \n \n-size_t IAST::checkDepthImpl(size_t max_depth, size_t level) const\n+size_t IAST::checkDepthImpl(size_t max_depth) const\n {\n-    size_t res = level + 1;\n-    for (const auto & child : children)\n+    std::vector<std::pair<ASTPtr, size_t>> stack;\n+    stack.reserve(children.size());\n+\n+    for (const auto & i: children)\n+        stack.push_back({i, 1});\n+\n+    size_t res = 0;\n+\n+    while (!stack.empty())\n     {\n-        if (level >= max_depth)\n+        auto top = stack.back();\n+        stack.pop_back();\n+\n+        if (top.second >= max_depth)\n             throw Exception(\"AST is too deep. Maximum: \" + toString(max_depth), ErrorCodes::TOO_DEEP_AST);\n-        res = std::max(res, child->checkDepthImpl(max_depth, level + 1));\n+\n+        res = std::max(res, top.second);\n+\n+        for (const auto & i: top.first->children)\n+            stack.push_back({i, top.second + 1});\n     }\n \n     return res;\ndiff --git a/src/Parsers/IAST.h b/src/Parsers/IAST.h\nindex e91d419acd84..bba878e4769c 100644\n--- a/src/Parsers/IAST.h\n+++ b/src/Parsers/IAST.h\n@@ -92,7 +92,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n       */\n     size_t checkDepth(size_t max_depth) const\n     {\n-        return checkDepthImpl(max_depth, 0);\n+        return checkDepthImpl(max_depth);\n     }\n \n     /** Get total number of tree elements\n@@ -273,7 +273,7 @@ class IAST : public std::enable_shared_from_this<IAST>, public TypePromotion<IAS\n     static const char * hilite_none;\n \n private:\n-    size_t checkDepthImpl(size_t max_depth, size_t level) const;\n+    size_t checkDepthImpl(size_t max_depth) const;\n \n     /** Forward linked list of ASTPtr to delete.\n       * Used in IAST destructor to avoid possible stack overflow.\ndiff --git a/src/Parsers/ParserCreateFunctionQuery.cpp b/src/Parsers/ParserCreateFunctionQuery.cpp\nindex 08df6d8da7a9..2b3cf98a8a79 100644\n--- a/src/Parsers/ParserCreateFunctionQuery.cpp\n+++ b/src/Parsers/ParserCreateFunctionQuery.cpp\n@@ -20,7 +20,7 @@ bool ParserCreateFunctionQuery::parseImpl(IParser::Pos & pos, ASTPtr & node, Exp\n     ParserKeyword s_on(\"ON\");\n     ParserIdentifier function_name_p;\n     ParserKeyword s_as(\"AS\");\n-    ParserLambdaExpression lambda_p;\n+    ParserExpression lambda_p;\n \n     ASTPtr function_name;\n     ASTPtr function_core;\ndiff --git a/src/Parsers/ParserCreateQuery.cpp b/src/Parsers/ParserCreateQuery.cpp\nindex 08240abe8c64..fc90f9ce3ed2 100644\n--- a/src/Parsers/ParserCreateQuery.cpp\n+++ b/src/Parsers/ParserCreateQuery.cpp\n@@ -152,7 +152,7 @@ bool ParserConstraintDeclaration::parseImpl(Pos & pos, ASTPtr & node, Expected &\n     ParserKeyword s_assume(\"ASSUME\");\n \n     ParserIdentifier name_p;\n-    ParserLogicalOrExpression expression_p;\n+    ParserExpression expression_p;\n \n     ASTPtr name;\n     ASTPtr expr;\n@@ -858,8 +858,8 @@ bool ParserCreateWindowViewQuery::parseImpl(Pos & pos, ASTPtr & node, Expected &\n     ParserStorage storage_p;\n     ParserStorage storage_inner;\n     ParserTablePropertiesDeclarationList table_properties_p;\n-    ParserIntervalOperatorExpression watermark_p;\n-    ParserIntervalOperatorExpression lateness_p;\n+    ParserExpression watermark_p;\n+    ParserExpression lateness_p;\n     ParserSelectWithUnionQuery select_p;\n \n     ASTPtr table;\ndiff --git a/src/Parsers/ParserCreateQuery.h b/src/Parsers/ParserCreateQuery.h\nindex f56e0a4c3a0e..b5480fa6eae6 100644\n--- a/src/Parsers/ParserCreateQuery.h\n+++ b/src/Parsers/ParserCreateQuery.h\n@@ -134,7 +134,7 @@ bool IParserColumnDeclaration<NameParser>::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_remove{\"REMOVE\"};\n     ParserKeyword s_type{\"TYPE\"};\n     ParserKeyword s_collate{\"COLLATE\"};\n-    ParserTernaryOperatorExpression expr_parser;\n+    ParserExpression expr_parser;\n     ParserStringLiteral string_literal_parser;\n     ParserLiteral literal_parser;\n     ParserCodec codec_parser;\ndiff --git a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\nindex 44bb7fb60577..9910c73e5415 100644\n--- a/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\n+++ b/src/Parsers/ParserDictionaryAttributeDeclaration.cpp\n@@ -20,7 +20,7 @@ bool ParserDictionaryAttributeDeclaration::parseImpl(Pos & pos, ASTPtr & node, E\n     ParserKeyword s_is_object_id{\"IS_OBJECT_ID\"};\n     ParserLiteral default_parser;\n     ParserArrayOfLiterals array_literals_parser;\n-    ParserTernaryOperatorExpression expression_parser;\n+    ParserExpression expression_parser;\n \n     /// mandatory attribute name\n     ASTPtr name;\ndiff --git a/src/Parsers/ParserExternalDDLQuery.cpp b/src/Parsers/ParserExternalDDLQuery.cpp\nindex 87630777fa66..4839ce73614a 100644\n--- a/src/Parsers/ParserExternalDDLQuery.cpp\n+++ b/src/Parsers/ParserExternalDDLQuery.cpp\n@@ -3,7 +3,7 @@\n #include <Parsers/ASTExternalDDLQuery.h>\n #include <Parsers/ASTSelectWithUnionQuery.h>\n #include <Parsers/CommonParsers.h>\n-#include <Parsers/ExpressionElementParsers.h>\n+#include <Parsers/ExpressionListParsers.h>\n #include <Parsers/ParserDropQuery.h>\n #include <Parsers/ParserExternalDDLQuery.h>\n #include <Parsers/ParserRenameQuery.h>\ndiff --git a/src/Parsers/ParserTablesInSelectQuery.cpp b/src/Parsers/ParserTablesInSelectQuery.cpp\nindex 8137093b9905..ef39df8ca523 100644\n--- a/src/Parsers/ParserTablesInSelectQuery.cpp\n+++ b/src/Parsers/ParserTablesInSelectQuery.cpp\n@@ -226,7 +226,7 @@ bool ParserTablesInSelectQueryElement::parseImpl(Pos & pos, ASTPtr & node, Expec\n             else if (ParserKeyword(\"ON\").ignore(pos, expected))\n             {\n                 /// OR is operator with lowest priority, so start parsing from it.\n-                if (!ParserLogicalOrExpression().parse(pos, table_join->on_expression, expected))\n+                if (!ParserExpression().parse(pos, table_join->on_expression, expected))\n                     return false;\n             }\n             else\ndiff --git a/src/TableFunctions/Hive/TableFunctionHive.cpp b/src/TableFunctions/Hive/TableFunctionHive.cpp\nindex ea682ce8c1f7..7e14f5ca3003 100644\n--- a/src/TableFunctions/Hive/TableFunctionHive.cpp\n+++ b/src/TableFunctions/Hive/TableFunctionHive.cpp\n@@ -61,7 +61,7 @@ namespace DB\n         ColumnsDescription /*cached_columns_*/) const\n     {\n         const Settings & settings = context_->getSettings();\n-        ParserLambdaExpression partition_by_parser;\n+        ParserExpression partition_by_parser;\n         ASTPtr partition_by_ast = parseQuery(\n             partition_by_parser,\n             \"(\" + partition_by_def + \")\",\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00984_parser_stack_overflow.reference b/tests/queries/0_stateless/00984_parser_stack_overflow.reference\nindex a46c80e92337..0cf6a1f96df3 100644\n--- a/tests/queries/0_stateless/00984_parser_stack_overflow.reference\n+++ b/tests/queries/0_stateless/00984_parser_stack_overflow.reference\n@@ -1,6 +1,4 @@\n exceeded\n exceeded\n-exceeded\n-exceeded\n 20002\n 1\ndiff --git a/tests/queries/0_stateless/00984_parser_stack_overflow.sh b/tests/queries/0_stateless/00984_parser_stack_overflow.sh\nindex 329e51e774ad..a7854b91ee27 100755\n--- a/tests/queries/0_stateless/00984_parser_stack_overflow.sh\n+++ b/tests/queries/0_stateless/00984_parser_stack_overflow.sh\n@@ -1,4 +1,5 @@\n #!/usr/bin/env bash\n+# Tags: no-asan\n \n # Such a huge timeout mostly for debug build.\n CLICKHOUSE_CURL_TIMEOUT=60\ndiff --git a/tests/queries/0_stateless/01062_max_parser_depth.reference b/tests/queries/0_stateless/01062_max_parser_depth.reference\nindex 3efc4f06710e..fc9c24676eb6 100644\n--- a/tests/queries/0_stateless/01062_max_parser_depth.reference\n+++ b/tests/queries/0_stateless/01062_max_parser_depth.reference\n@@ -1,4 +1,3 @@\n -\n-Maximum parse depth (42) exceeded.\n -\n-Maximum parse depth (20) exceeded.\n+-\ndiff --git a/tests/queries/0_stateless/01062_max_parser_depth.sh b/tests/queries/0_stateless/01062_max_parser_depth.sh\nindex 27593272f920..baebd7becd85 100755\n--- a/tests/queries/0_stateless/01062_max_parser_depth.sh\n+++ b/tests/queries/0_stateless/01062_max_parser_depth.sh\n@@ -9,3 +9,4 @@ echo -\n echo 'select (1+1)*(2+1)' | ${CLICKHOUSE_CURL} -sSg \"${CLICKHOUSE_URL}&max_parser_depth=42\" -d @- 2>&1 | grep -oP \"Maximum parse depth .* exceeded.\"\n echo -\n echo 'select 1' | ${CLICKHOUSE_CURL} -sSg \"${CLICKHOUSE_URL}&max_parser_depth=20\" -d @- 2>&1 | grep -oP \"Maximum parse depth .* exceeded.\"\n+echo -\ndiff --git a/tests/queries/0_stateless/01196_max_parser_depth.reference b/tests/queries/0_stateless/01196_max_parser_depth.reference\nindex 072fc270acd9..d2222a8b8952 100644\n--- a/tests/queries/0_stateless/01196_max_parser_depth.reference\n+++ b/tests/queries/0_stateless/01196_max_parser_depth.reference\n@@ -1,4 +1,5 @@\n-Code: 306\n-Code: 306\n-Code: 306\n-Code: 306\n+Code: 167\n+Code: 167\n+Code: 167\n+Code: 167\n+Code: 167\ndiff --git a/tests/queries/0_stateless/01196_max_parser_depth.sh b/tests/queries/0_stateless/01196_max_parser_depth.sh\nindex ae4851bf0c34..57283feb7f0e 100755\n--- a/tests/queries/0_stateless/01196_max_parser_depth.sh\n+++ b/tests/queries/0_stateless/01196_max_parser_depth.sh\n@@ -6,6 +6,6 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n \n { printf \"select \"; for _ in {1..1000}; do printf \"coalesce(null, \"; done; printf \"1\"; for _ in {1..1000}; do printf \")\"; done; } > \"${CLICKHOUSE_TMP}\"/query\n \n-cat \"${CLICKHOUSE_TMP}\"/query | $CLICKHOUSE_CLIENT 2>&1 | grep -o -F 'Code: 306'\n-cat \"${CLICKHOUSE_TMP}\"/query | $CLICKHOUSE_LOCAL 2>&1 | grep -o -F 'Code: 306'\n-cat \"${CLICKHOUSE_TMP}\"/query | $CLICKHOUSE_CURL --data-binary @- -vsS \"$CLICKHOUSE_URL\" 2>&1 | grep -o -F 'Code: 306'\n+cat \"${CLICKHOUSE_TMP}\"/query | $CLICKHOUSE_CLIENT 2>&1 | grep -o -F 'Code: 167'\n+cat \"${CLICKHOUSE_TMP}\"/query | $CLICKHOUSE_LOCAL 2>&1 | grep -o -F 'Code: 167'\n+cat \"${CLICKHOUSE_TMP}\"/query | $CLICKHOUSE_CURL --data-binary @- -vsS \"$CLICKHOUSE_URL\" 2>&1 | grep -o -F 'Code: 167'\n",
  "problem_statement": "Lower amount of recursion in Parser\nWe are using hand-written recursive descent parser and it is alright.\r\n\r\nBut it is using too deep recursion to parse expression with operators.\r\nSomething like 10 stack frames to parse any expression element.\r\n\r\nWe can get rid of the excessive recursion by using \"precendence climbing\" method or similar:\r\nhttps://en.wikipedia.org/wiki/Operator-precedence_parser\r\n\r\nIt is like parsing expression greedy from left to right and binding the operators to arguments according to the priorities.\r\n\r\nWe have the following operators:\r\n\r\n```\r\na[b]\r\na.b\r\n\r\n-a\r\n+a\r\n\r\nNOT a\r\n\r\nDATE a\r\nTIMESTAMP a\r\n\r\nINTERVAL a UNIT\r\n\r\na IS NULL\r\na IS NOT NULL\r\n\r\na::Type\r\n\r\na + b\r\na - b\r\na * b\r\na / b\r\na % b\r\na DIV b\r\na MOD b\r\na || b\r\n\r\na < b\r\na > b\r\na <= b\r\na >= b\r\na = b\r\na == b\r\na != b\r\na <> b\r\n\r\na AND b\r\na OR b\r\n\r\na ? b : c\r\na BETWEEN b AND c\r\n\r\n[a, b...]\r\n(a, b...)\r\n\r\nf(a, b...)\r\n\r\na -> b\r\n\r\na AS b\r\na b          - only in SELECT expression list\r\n\r\nCASE a WHEN b THEN c ... [ELSE d] END\r\nCASE WHEN a THEN b ... [ELSE d] END\r\n```\r\n\r\nIt is ok if you slightly change some relative priorities of the operators or break some very strange cases.\r\n\r\nExample showing too deep recursion:\r\n\r\n```\r\nclickhouse-local --max_parser_depth 100000 --query \"SELECT f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f(f())))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))))\"\r\nAborted (core dumped)\r\n```\r\n\r\nLess than 1000 levels of nesting are exhausting 2 MiB stack.\n",
  "hints_text": "",
  "created_at": "2022-02-24T17:46:58Z",
  "modified_files": [
    "src/Parsers/ExpressionElementParsers.cpp",
    "src/Parsers/ExpressionElementParsers.h",
    "src/Parsers/ExpressionListParsers.cpp",
    "src/Parsers/ExpressionListParsers.h",
    "src/Parsers/IAST.cpp",
    "src/Parsers/IAST.h",
    "src/Parsers/ParserCreateFunctionQuery.cpp",
    "src/Parsers/ParserCreateQuery.cpp",
    "src/Parsers/ParserCreateQuery.h",
    "src/Parsers/ParserDictionaryAttributeDeclaration.cpp",
    "src/Parsers/ParserExternalDDLQuery.cpp",
    "src/Parsers/ParserTablesInSelectQuery.cpp",
    "src/TableFunctions/Hive/TableFunctionHive.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/00984_parser_stack_overflow.reference",
    "tests/queries/0_stateless/00984_parser_stack_overflow.sh",
    "tests/queries/0_stateless/01062_max_parser_depth.reference",
    "tests/queries/0_stateless/01062_max_parser_depth.sh",
    "tests/queries/0_stateless/01196_max_parser_depth.reference",
    "tests/queries/0_stateless/01196_max_parser_depth.sh"
  ]
}