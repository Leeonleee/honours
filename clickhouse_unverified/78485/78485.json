{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 78485,
  "instance_id": "ClickHouse__ClickHouse-78485",
  "issue_numbers": [
    "65607",
    "69373"
  ],
  "base_commit": "c554cb9ec90c377b28688dc5f098b8a6b0dbdf41",
  "patch": "diff --git a/src/Interpreters/evaluateConstantExpression.cpp b/src/Interpreters/evaluateConstantExpression.cpp\nindex bc1a5d054a18..5e56a4be2727 100644\n--- a/src/Interpreters/evaluateConstantExpression.cpp\n+++ b/src/Interpreters/evaluateConstantExpression.cpp\n@@ -747,10 +747,13 @@ std::optional<ConstantVariants> evaluateExpressionOverConstantCondition(\n     const ContextPtr & context,\n     size_t max_elements)\n {\n-    auto inverted_dag = KeyCondition::cloneASTWithInversionPushDown({predicate}, context);\n-    auto matches = matchTrees(expr, inverted_dag, false);\n+    if (!predicate)\n+        return {};\n+\n+    ActionsDAGWithInversionPushDown filter_dag(predicate, context);\n+    auto matches = matchTrees(expr, *filter_dag.dag, false);\n \n-    auto predicates = analyze(inverted_dag.getOutputs().at(0), matches, context, max_elements);\n+    auto predicates = analyze(filter_dag.predicate, matches, context, max_elements);\n \n     if (!predicates)\n         return {};\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex c4db5c838c31..eae38c263034 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1650,8 +1650,10 @@ static void buildIndexes(\n \n     const auto & settings = context->getSettingsRef();\n \n+    ActionsDAGWithInversionPushDown filter_dag((filter_actions_dag ? filter_actions_dag->getOutputs().front() : nullptr), context);\n+\n     indexes.emplace(\n-        ReadFromMergeTree::Indexes{KeyCondition{filter_actions_dag, context, primary_key_column_names, primary_key.expression}});\n+        ReadFromMergeTree::Indexes{KeyCondition{filter_dag, context, primary_key_column_names, primary_key.expression}});\n \n     if (metadata_snapshot->hasPartitionKey())\n     {\n@@ -1659,12 +1661,12 @@ static void buildIndexes(\n         auto minmax_columns_names = MergeTreeData::getMinMaxColumnsNames(partition_key);\n         auto minmax_expression_actions = MergeTreeData::getMinMaxExpr(partition_key, ExpressionActionsSettings(context));\n \n-        indexes->minmax_idx_condition.emplace(filter_actions_dag, context, minmax_columns_names, minmax_expression_actions);\n-        indexes->partition_pruner.emplace(metadata_snapshot, filter_actions_dag, context, false /* strict */);\n+        indexes->minmax_idx_condition.emplace(filter_dag, context, minmax_columns_names, minmax_expression_actions);\n+        indexes->partition_pruner.emplace(metadata_snapshot, filter_dag, context, false /* strict */);\n     }\n \n-    indexes->part_values = MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(metadata_snapshot, data, parts, filter_actions_dag, context);\n-    MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(indexes->part_offset_condition, filter_actions_dag, context);\n+    indexes->part_values = MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(metadata_snapshot, data, parts, filter_dag.predicate, context);\n+    MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(indexes->part_offset_condition, filter_dag.predicate, context);\n \n     indexes->use_skip_indexes = settings[Setting::use_skip_indexes];\n     if (query_info.isFinal() && !settings[Setting::use_skip_indexes_if_final])\n@@ -1748,17 +1750,20 @@ static void buildIndexes(\n         {\n #if USE_USEARCH\n             if (const auto * vector_similarity_index = typeid_cast<const MergeTreeIndexVectorSimilarity *>(index_helper.get()))\n-                condition = vector_similarity_index->createIndexCondition(filter_actions_dag, context, vector_search_parameters);\n+                condition = vector_similarity_index->createIndexCondition(filter_dag.predicate, context, vector_search_parameters);\n #endif\n             if (const auto * legacy_vector_similarity_index = typeid_cast<const MergeTreeIndexLegacyVectorSimilarity *>(index_helper.get()))\n-                condition = legacy_vector_similarity_index->createIndexCondition(filter_actions_dag, context);\n+                condition = legacy_vector_similarity_index->createIndexCondition(filter_dag.predicate, context);\n \n             if (!condition)\n                 throw Exception(ErrorCodes::LOGICAL_ERROR, \"Unknown vector search index {}\", index_helper->index.name);\n         }\n         else\n         {\n-            condition = index_helper->createIndexCondition(filter_actions_dag, context);\n+            if (!filter_dag.predicate)\n+                continue;\n+\n+            condition = index_helper->createIndexCondition(filter_dag.predicate, context);\n         }\n \n         if (!condition->alwaysUnknownOrTrue())\ndiff --git a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\nindex 586183698f75..ed41b8eb10ca 100644\n--- a/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n+++ b/src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp\n@@ -481,7 +481,8 @@ Pipe ReadFromSystemNumbersStep::makePipe()\n     chassert(numbers_storage.step != UInt64{0});\n \n     /// Build rpn of query filters\n-    KeyCondition condition(filter_actions_dag ? &*filter_actions_dag : nullptr, context, column_names, key_expression);\n+    ActionsDAGWithInversionPushDown inverted_dag(filter_actions_dag ? filter_actions_dag->getOutputs().front() : nullptr, context);\n+    KeyCondition condition(inverted_dag, context, column_names, key_expression);\n \n     if (condition.extractPlainRanges(ranges))\n     {\ndiff --git a/src/Processors/SourceWithKeyCondition.cpp b/src/Processors/SourceWithKeyCondition.cpp\nindex 90867e4e0a6a..12f8b39e1ae8 100644\n--- a/src/Processors/SourceWithKeyCondition.cpp\n+++ b/src/Processors/SourceWithKeyCondition.cpp\n@@ -8,8 +8,9 @@ namespace DB\n \n void SourceWithKeyCondition::setKeyConditionImpl(const std::optional<ActionsDAG> & filter_actions_dag, ContextPtr context, const Block & keys)\n {\n+    ActionsDAGWithInversionPushDown inverted_dag(filter_actions_dag ? filter_actions_dag->getOutputs().front() : nullptr, context);\n     key_condition = std::make_shared<const KeyCondition>(\n-        filter_actions_dag ? &*filter_actions_dag : nullptr,\n+        inverted_dag,\n         context,\n         keys.getNames(),\n         std::make_shared<ExpressionActions>(ActionsDAG(keys.getColumnsWithTypeAndName())));\ndiff --git a/src/Storages/Hive/StorageHive.cpp b/src/Storages/Hive/StorageHive.cpp\nindex 3f7b655f7a00..c0cc6847e7de 100644\n--- a/src/Storages/Hive/StorageHive.cpp\n+++ b/src/Storages/Hive/StorageHive.cpp\n@@ -641,7 +641,8 @@ HiveFiles StorageHive::collectHiveFilesFromPartition(\n         for (size_t i = 0; i < partition_names.size(); ++i)\n             ranges.emplace_back(fields[i]);\n \n-        const KeyCondition partition_key_condition(filter_actions_dag, getContext(), partition_names, partition_minmax_idx_expr);\n+        ActionsDAGWithInversionPushDown inverted_dag(filter_actions_dag->getOutputs().front(), context_);\n+        const KeyCondition partition_key_condition(inverted_dag, getContext(), partition_names, partition_minmax_idx_expr);\n         if (!partition_key_condition.checkInHyperrectangle(ranges, partition_types).can_be_true)\n             return {};\n     }\n@@ -709,7 +710,8 @@ HiveFilePtr StorageHive::getHiveFileIfNeeded(\n \n     if (prune_level >= PruneLevel::File)\n     {\n-        const KeyCondition hivefile_key_condition(filter_actions_dag, getContext(), hivefile_name_types.getNames(), hivefile_minmax_idx_expr);\n+        ActionsDAGWithInversionPushDown inverted_dag(filter_actions_dag->getOutputs().front(), context_);\n+        const KeyCondition hivefile_key_condition(inverted_dag, getContext(), hivefile_name_types.getNames(), hivefile_minmax_idx_expr);\n         if (hive_file->useFileMinMaxIndex())\n         {\n             /// Load file level minmax index and apply\ndiff --git a/src/Storages/MergeTree/KeyCondition.cpp b/src/Storages/MergeTree/KeyCondition.cpp\nindex 9eea8dbda3e0..9599f5f9f9bd 100644\n--- a/src/Storages/MergeTree/KeyCondition.cpp\n+++ b/src/Storages/MergeTree/KeyCondition.cpp\n@@ -572,19 +572,30 @@ ASTPtr cloneASTWithInversionPushDown(const ASTPtr node, const bool need_inversio\n     return need_inversion ? makeASTFunction(\"not\", cloned_node) : cloned_node;\n }\n \n-static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n+static bool isTrivialCast(const ActionsDAG::Node & node)\n+{\n+    if (node.function_base->getName() != \"CAST\" || node.children.size() != 2 || node.children[1]->type != ActionsDAG::ActionType::COLUMN)\n+        return false;\n+\n+    const auto * column_const = typeid_cast<const ColumnConst *>(node.children[1]->column.get());\n+    if (!column_const)\n+        return false;\n+\n+    Field field = column_const->getField();\n+    if (field.getType() != Field::Types::String)\n+        return false;\n+\n+    auto type_name = field.safeGet<String>();\n+    return node.children[0]->result_type->getName() == type_name;\n+}\n+\n+static const ActionsDAG::Node & cloneDAGWithInversionPushDown(\n     const ActionsDAG::Node & node,\n     ActionsDAG & inverted_dag,\n-    std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> to_inverted,\n+    std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> & inputs_mapping,\n     const ContextPtr & context,\n     const bool need_inversion)\n {\n-    {\n-        auto it = to_inverted.find(&node);\n-        if (it != to_inverted.end())\n-            return *it->second;\n-    }\n-\n     const ActionsDAG::Node * res = nullptr;\n     bool handled_inversion = false;\n \n@@ -592,8 +603,12 @@ static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n     {\n         case (ActionsDAG::ActionType::INPUT):\n         {\n-            /// Note: inputs order is not important here. Will match columns by names.\n-            res = &inverted_dag.addInput({node.column, node.result_type, node.result_name});\n+            auto & input = inputs_mapping[&node];\n+            if (input == nullptr)\n+                /// Note: inputs order is not important here. Will match columns by names.\n+                input = &inverted_dag.addInput({node.column, node.result_type, node.result_name});\n+\n+            res = input;\n             break;\n         }\n         case (ActionsDAG::ActionType::COLUMN):\n@@ -617,13 +632,13 @@ static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n         case (ActionsDAG::ActionType::ALIAS):\n         {\n             /// Ignore aliases\n-            res = &cloneASTWithInversionPushDown(*node.children.front(), inverted_dag, to_inverted, context, need_inversion);\n+            res = &cloneDAGWithInversionPushDown(*node.children.front(), inverted_dag, inputs_mapping, context, need_inversion);\n             handled_inversion = true;\n             break;\n         }\n         case (ActionsDAG::ActionType::ARRAY_JOIN):\n         {\n-            const auto & arg = cloneASTWithInversionPushDown(*node.children.front(), inverted_dag, to_inverted, context, false);\n+            const auto & arg = cloneDAGWithInversionPushDown(*node.children.front(), inverted_dag, inputs_mapping, context, false);\n             res = &inverted_dag.addArrayJoin(arg, {});\n             break;\n         }\n@@ -632,7 +647,7 @@ static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n             auto name = node.function_base->getName();\n             if (name == \"not\")\n             {\n-                res = &cloneASTWithInversionPushDown(*node.children.front(), inverted_dag, to_inverted, context, !need_inversion);\n+                res = &cloneDAGWithInversionPushDown(*node.children.front(), inverted_dag, inputs_mapping, context, !need_inversion);\n                 handled_inversion = true;\n             }\n             else if (name == \"indexHint\")\n@@ -646,19 +661,29 @@ static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n                         children = index_hint_dag.getOutputs();\n \n                         for (auto & arg : children)\n-                            arg = &cloneASTWithInversionPushDown(*arg, inverted_dag, to_inverted, context, need_inversion);\n+                            arg = &cloneDAGWithInversionPushDown(*arg, inverted_dag, inputs_mapping, context, need_inversion);\n                     }\n                 }\n \n                 res = &inverted_dag.addFunction(node.function_base, children, \"\");\n                 handled_inversion = true;\n             }\n+            else if (name == \"materialize\")\n+            {\n+                /// Remove \"materialize\" from index analysis.\n+                res = &cloneDAGWithInversionPushDown(*node.children.front(), inverted_dag, inputs_mapping, context, need_inversion);\n+            }\n+            else if (isTrivialCast(node))\n+            {\n+                /// Remove trivial cast and keep its first argument.\n+                res = &cloneDAGWithInversionPushDown(*node.children.front(), inverted_dag, inputs_mapping, context, need_inversion);\n+            }\n             else if (need_inversion && (name == \"and\" || name == \"or\"))\n             {\n                 ActionsDAG::NodeRawConstPtrs children(node.children);\n \n                 for (auto & arg : children)\n-                    arg = &cloneASTWithInversionPushDown(*arg, inverted_dag, to_inverted, context, need_inversion);\n+                    arg = &cloneDAGWithInversionPushDown(*arg, inverted_dag, inputs_mapping, context, need_inversion);\n \n                 FunctionOverloadResolverPtr function_builder;\n \n@@ -679,7 +704,7 @@ static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n                 ActionsDAG::NodeRawConstPtrs children(node.children);\n \n                 for (auto & arg : children)\n-                    arg = &cloneASTWithInversionPushDown(*arg, inverted_dag, to_inverted, context, false);\n+                    arg = &cloneDAGWithInversionPushDown(*arg, inverted_dag, inputs_mapping, context, false);\n \n                 auto it = inverse_relations.find(name);\n                 if (it != inverse_relations.end())\n@@ -723,10 +748,22 @@ static const ActionsDAG::Node & cloneASTWithInversionPushDown(\n     if (!handled_inversion && need_inversion)\n         res = &inverted_dag.addFunction(FunctionFactory::instance().get(\"not\", context), {res}, \"\");\n \n-    to_inverted[&node] = res;\n     return *res;\n }\n \n+static ActionsDAG cloneDAGWithInversionPushDown(const ActionsDAG::Node * predicate, const ContextPtr & context)\n+{\n+    ActionsDAG res;\n+\n+    std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> inputs_mapping;\n+\n+    predicate = &DB::cloneDAGWithInversionPushDown(*predicate, res, inputs_mapping, context, false);\n+\n+    res.getOutputs() = {predicate};\n+\n+    return res;\n+}\n+\n const std::unordered_map<String, KeyCondition::SpaceFillingCurveType> KeyCondition::space_filling_curve_name_to_type {\n         {\"mortonEncode\", SpaceFillingCurveType::Morton},\n         {\"hilbertEncode\", SpaceFillingCurveType::Hilbert}\n@@ -758,26 +795,6 @@ static bool mayExistOnBloomFilter(const KeyCondition::BloomFilterData & conditio\n     return true;\n }\n \n-ActionsDAG KeyCondition::cloneASTWithInversionPushDown(ActionsDAG::NodeRawConstPtrs nodes, const ContextPtr & context)\n-{\n-    ActionsDAG res;\n-\n-    std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> to_inverted;\n-\n-    for (auto & node : nodes)\n-        node = &DB::cloneASTWithInversionPushDown(*node, res, to_inverted, context, false);\n-\n-    if (nodes.size() > 1)\n-    {\n-        auto function_builder = FunctionFactory::instance().get(\"and\", context);\n-        nodes = {&res.addFunction(function_builder, std::move(nodes), \"\")};\n-    }\n-\n-    res.getOutputs().swap(nodes);\n-\n-    return res;\n-}\n-\n /** Calculate expressions, that depend only on constants.\n   * For index to work when something like \"WHERE Date = toDate(now())\" is written.\n   */\n@@ -846,8 +863,26 @@ void KeyCondition::getAllSpaceFillingCurves()\n     }\n }\n \n+ActionsDAGWithInversionPushDown::ActionsDAGWithInversionPushDown(const ActionsDAG::Node * predicate_, const ContextPtr & context)\n+{\n+    if (!predicate_)\n+        return;\n+\n+    /** When non-strictly monotonic functions are employed in functional index (e.g. ORDER BY toStartOfHour(dateTime)),\n+    * the use of NOT operator in predicate will result in the indexing algorithm leave out some data.\n+    * This is caused by rewriting in KeyCondition::tryParseAtomFromAST of relational operators to less strict\n+    * when parsing the AST into internal RPN representation.\n+    * To overcome the problem, before parsing the AST we transform it to its semantically equivalent form where all NOT's\n+    * are pushed down and applied (when possible) to leaf nodes.\n+    */\n+    dag = cloneDAGWithInversionPushDown(predicate_, context);\n+\n+    predicate = dag->getOutputs()[0];\n+}\n+\n+\n KeyCondition::KeyCondition(\n-    const ActionsDAG * filter_dag,\n+    const ActionsDAGWithInversionPushDown & filter_dag,\n     ContextPtr context,\n     const Names & key_column_names_,\n     const ExpressionActionsPtr & key_expr_,\n@@ -872,7 +907,7 @@ KeyCondition::KeyCondition(\n     if (context->getSettingsRef()[Setting::analyze_index_with_space_filling_curves])\n         getAllSpaceFillingCurves();\n \n-    if (!filter_dag)\n+    if (!filter_dag.predicate)\n     {\n         has_filter = false;\n         relaxed = true;\n@@ -882,19 +917,7 @@ KeyCondition::KeyCondition(\n \n     has_filter = true;\n \n-    /** When non-strictly monotonic functions are employed in functional index (e.g. ORDER BY toStartOfHour(dateTime)),\n-      * the use of NOT operator in predicate will result in the indexing algorithm leave out some data.\n-      * This is caused by rewriting in KeyCondition::tryParseAtomFromAST of relational operators to less strict\n-      * when parsing the AST into internal RPN representation.\n-      * To overcome the problem, before parsing the AST we transform it to its semantically equivalent form where all NOT's\n-      * are pushed down and applied (when possible) to leaf nodes.\n-      */\n-    auto inverted_dag = cloneASTWithInversionPushDown({filter_dag->getOutputs().at(0)}, context);\n-    assert(inverted_dag.getOutputs().size() == 1);\n-\n-    const auto * inverted_dag_filter_node = inverted_dag.getOutputs()[0];\n-\n-    RPNBuilder<RPNElement> builder(inverted_dag_filter_node, context, [&](const RPNBuilderTreeNode & node, RPNElement & out)\n+    RPNBuilder<RPNElement> builder(filter_dag.predicate, context, [&](const RPNBuilderTreeNode & node, RPNElement & out)\n     {\n         return extractAtomFromTree(node, out);\n     });\ndiff --git a/src/Storages/MergeTree/KeyCondition.h b/src/Storages/MergeTree/KeyCondition.h\nindex ec7126d2d8e2..c20881a0b723 100644\n--- a/src/Storages/MergeTree/KeyCondition.h\n+++ b/src/Storages/MergeTree/KeyCondition.h\n@@ -28,6 +28,18 @@ struct ActionDAGNodes;\n class MergeTreeSetIndex;\n \n \n+/// Canonize the predicate\n+/// * push down NOT to leaf nodes\n+/// * remove aliases and re-generate function names\n+/// * remove unneeded functions (e.g. materialize)\n+struct ActionsDAGWithInversionPushDown\n+{\n+    std::optional<ActionsDAG> dag;\n+    const ActionsDAG::Node * predicate = nullptr;\n+\n+    explicit ActionsDAGWithInversionPushDown(const ActionsDAG::Node * predicate_, const ContextPtr & context);\n+};\n+\n /** Condition on the index.\n   *\n   * Consists of the conditions for the key belonging to all possible ranges or sets,\n@@ -41,7 +53,7 @@ class KeyCondition\n public:\n     /// Construct key condition from ActionsDAG nodes\n     KeyCondition(\n-        const ActionsDAG * filter_dag,\n+        const ActionsDAGWithInversionPushDown & filter_dag,\n         ContextPtr context,\n         const Names & key_column_names,\n         const ExpressionActionsPtr & key_expr,\n@@ -149,8 +161,6 @@ class KeyCondition\n         DataTypePtr current_type,\n         bool single_point = false);\n \n-    static ActionsDAG cloneASTWithInversionPushDown(ActionsDAG::NodeRawConstPtrs nodes, const ContextPtr & context);\n-\n     bool matchesExactContinuousRange() const;\n \n     /// Extract plain ranges of the condition.\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 9fec37e6c8ff..9ecdb402292f 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -641,13 +641,14 @@ ConditionSelectivityEstimator MergeTreeData::getConditionSelectivityEstimatorByP\n \n     const auto & parts = assert_cast<const MergeTreeData::SnapshotData &>(*storage_snapshot->data).parts;\n \n-    if (parts.empty())\n+    if (parts.empty() || !filter_dag)\n         return {};\n \n     ASTPtr expression_ast;\n \n     ConditionSelectivityEstimator estimator;\n-    PartitionPruner partition_pruner(storage_snapshot->metadata, filter_dag, local_context);\n+    ActionsDAGWithInversionPushDown inverted_dag(filter_dag->getOutputs().front(), local_context);\n+    PartitionPruner partition_pruner(storage_snapshot->metadata, inverted_dag, local_context);\n \n     if (partition_pruner.isUseless())\n     {\n@@ -1379,7 +1380,9 @@ std::optional<UInt64> MergeTreeData::totalRowsByPartitionPredicateImpl(\n         if (!virtual_columns_block.has(input->result_name))\n             valid = false;\n \n-    PartitionPruner partition_pruner(metadata_snapshot, &*filter_dag, local_context, true /* strict */);\n+    ActionsDAGWithInversionPushDown inverted_dag(filter_dag->getOutputs().front(), local_context);\n+\n+    PartitionPruner partition_pruner(metadata_snapshot, inverted_dag, local_context, true /* strict */);\n     if (partition_pruner.isUseless() && !valid)\n         return {};\n \n@@ -7613,10 +7616,11 @@ Block MergeTreeData::getMinMaxCountProjectionBlock(\n             auto minmax_columns_names = getMinMaxColumnsNames(partition_key);\n             minmax_columns_types = getMinMaxColumnsTypes(partition_key);\n \n+            ActionsDAGWithInversionPushDown inverted_dag(filter_dag->getOutputs().front(), query_context);\n             minmax_idx_condition.emplace(\n-                filter_dag, query_context, minmax_columns_names,\n+                inverted_dag, query_context, minmax_columns_names,\n                 getMinMaxExpr(partition_key, ExpressionActionsSettings(query_context)));\n-            partition_pruner.emplace(metadata_snapshot, filter_dag, query_context, false /* strict */);\n+            partition_pruner.emplace(metadata_snapshot, inverted_dag, query_context, false /* strict */);\n         }\n \n         const auto * predicate = filter_dag->getOutputs().at(0);\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex c886f7c99aaa..352fdf75c920 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -473,9 +473,9 @@ MergeTreeDataSelectSamplingData MergeTreeDataSelectExecutor::getSampling(\n }\n \n void MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(\n-    std::optional<KeyCondition> & part_offset_condition, const ActionsDAG * filter_dag, ContextPtr context)\n+    std::optional<KeyCondition> & part_offset_condition, const ActionsDAG::Node * predicate, ContextPtr context)\n {\n-    if (!filter_dag)\n+    if (!predicate)\n         return;\n \n     auto part_offset_type = std::make_shared<DataTypeUInt64>();\n@@ -484,7 +484,7 @@ void MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(\n         = {ColumnWithTypeAndName(part_offset_type->createColumn(), part_offset_type, \"_part_offset\"),\n            ColumnWithTypeAndName(part_type->createColumn(), part_type, \"_part\")};\n \n-    auto dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(filter_dag->getOutputs().at(0), &sample);\n+    auto dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(predicate, &sample);\n     if (!dag)\n         return;\n \n@@ -494,7 +494,7 @@ void MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(\n         return;\n \n     part_offset_condition.emplace(KeyCondition{\n-        &*dag,\n+        ActionsDAGWithInversionPushDown(dag->getOutputs().front(), context),\n         context,\n         sample.getNames(),\n         std::make_shared<ExpressionActions>(ActionsDAG(sample.getColumnsWithTypeAndName()), ExpressionActionsSettings{}),\n@@ -505,14 +505,14 @@ std::optional<std::unordered_set<String>> MergeTreeDataSelectExecutor::filterPar\n     const StorageMetadataPtr & metadata_snapshot,\n     const MergeTreeData & data,\n     const MergeTreeData::DataPartsVector & parts,\n-    const ActionsDAG * filter_dag,\n+    const ActionsDAG::Node * predicate,\n     ContextPtr context)\n {\n-    if (!filter_dag)\n+    if (!predicate)\n         return {};\n \n     auto sample = data.getHeaderWithVirtualsForFilter(metadata_snapshot);\n-    auto dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(filter_dag->getOutputs().at(0), &sample);\n+    auto dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(predicate, &sample);\n     if (!dag)\n         return {};\n \ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\nindex 67e02eee6546..9a753202c5fc 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n@@ -6,6 +6,7 @@\n #include <Storages/MergeTree/RangesInDataPart.h>\n #include <Storages/MergeTree/PartitionPruner.h>\n #include <Processors/QueryPlan/ReadFromMergeTree.h>\n+#include <Interpreters/ActionsDAG.h>\n \n \n namespace DB\n@@ -159,7 +160,7 @@ class MergeTreeDataSelectExecutor\n \n     /// If possible, construct optional key condition from predicates containing _part_offset column.\n     static void buildKeyConditionFromPartOffset(\n-        std::optional<KeyCondition> & part_offset_condition, const ActionsDAG * filter_dag, ContextPtr context);\n+        std::optional<KeyCondition> & part_offset_condition, const ActionsDAG::Node * predicate, ContextPtr context);\n \n     /// If possible, filter using expression on virtual columns.\n     /// Example: SELECT count() FROM table WHERE _part = 'part_name'\n@@ -168,7 +169,7 @@ class MergeTreeDataSelectExecutor\n         const StorageMetadataPtr & metadata_snapshot,\n         const MergeTreeData & data,\n         const MergeTreeData::DataPartsVector & parts,\n-        const ActionsDAG * filter_dag,\n+        const ActionsDAG::Node * predicate,\n         ContextPtr context);\n \n     /// Filter parts using minmax index and partition key.\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp b/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp\nindex 38f6d2336e71..239fba5ebb0c 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp\n@@ -17,7 +17,6 @@\n #include <Parsers/ASTIdentifier.h>\n #include <Parsers/ASTSubquery.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n #include <Storages/MergeTree/RPNBuilder.h>\n \n \n@@ -188,21 +187,17 @@ bool maybeTrueOnBloomFilter(const IColumn * hash_column, const BloomFilterPtr &\n }\n \n MergeTreeIndexConditionBloomFilter::MergeTreeIndexConditionBloomFilter(\n-    const ActionsDAG * filter_actions_dag, ContextPtr context_, const Block & header_, size_t hash_functions_)\n+    const ActionsDAG::Node * predicate, ContextPtr context_, const Block & header_, size_t hash_functions_)\n     : WithContext(context_), header(header_), hash_functions(hash_functions_)\n {\n-    if (!filter_actions_dag)\n+    if (!predicate)\n     {\n         rpn.push_back(RPNElement::FUNCTION_UNKNOWN);\n         return;\n     }\n \n-    /// Clone ActionsDAG with re-generated column name for constants.\n-    /// DAG from the query (with enabled analyzer) uses suffixes for constants, like 1_UInt8.\n-    /// DAG from the skip indexes does not use it. This breaks matching by column name sometimes.\n-    auto cloned_filter_actions_dag = cloneFilterDAGForIndexesAnalysis(*filter_actions_dag);\n     RPNBuilder<RPNElement> builder(\n-        cloned_filter_actions_dag.getOutputs().at(0),\n+        predicate,\n         context_,\n         [&](const RPNBuilderTreeNode & node, RPNElement & out) { return extractAtomFromTree(node, out); });\n     rpn = std::move(builder).extractRPN();\n@@ -898,9 +893,9 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexBloomFilter::createIndexAggregator(con\n     return std::make_shared<MergeTreeIndexAggregatorBloomFilter>(bits_per_row, hash_functions, index.column_names);\n }\n \n-MergeTreeIndexConditionPtr MergeTreeIndexBloomFilter::createIndexCondition(const ActionsDAG * filter_actions_dag, ContextPtr context) const\n+MergeTreeIndexConditionPtr MergeTreeIndexBloomFilter::createIndexCondition(const ActionsDAG::Node * predicate, ContextPtr context) const\n {\n-    return std::make_shared<MergeTreeIndexConditionBloomFilter>(filter_actions_dag, context, index.sample_block, hash_functions);\n+    return std::make_shared<MergeTreeIndexConditionBloomFilter>(predicate, context, index.sample_block, hash_functions);\n }\n \n static void assertIndexColumnsType(const Block & header)\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilter.h b/src/Storages/MergeTree/MergeTreeIndexBloomFilter.h\nindex 884cb099a768..2e943ae27034 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilter.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilter.h\n@@ -74,7 +74,7 @@ class MergeTreeIndexConditionBloomFilter final : public IMergeTreeIndexCondition\n         std::vector<std::pair<size_t, ColumnPtr>> predicate;\n     };\n \n-    MergeTreeIndexConditionBloomFilter(const ActionsDAG * filter_actions_dag, ContextPtr context_, const Block & header_, size_t hash_functions_);\n+    MergeTreeIndexConditionBloomFilter(const ActionsDAG::Node * predicate, ContextPtr context_, const Block & header_, size_t hash_functions_);\n \n     bool alwaysUnknownOrTrue() const override;\n \n@@ -147,7 +147,7 @@ class MergeTreeIndexBloomFilter final : public IMergeTreeIndex\n \n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n \n-    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n+    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n private:\n     size_t bits_per_row;\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\nindex 4e531583d2d0..416287a8fed3 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp\n@@ -15,7 +15,6 @@\n #include <Interpreters/misc.h>\n #include <Parsers/ASTSelectQuery.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n #include <Storages/MergeTree/RPNBuilder.h>\n \n #include <Poco/Logger.h>\n@@ -146,7 +145,7 @@ void MergeTreeIndexAggregatorBloomFilterText::update(const Block & block, size_t\n }\n \n MergeTreeConditionBloomFilterText::MergeTreeConditionBloomFilterText(\n-    const ActionsDAG * filter_actions_dag,\n+    const ActionsDAG::Node * predicate,\n     ContextPtr context,\n     const Block & index_sample_block,\n     const BloomFilterParameters & params_,\n@@ -156,18 +155,14 @@ MergeTreeConditionBloomFilterText::MergeTreeConditionBloomFilterText(\n     , params(params_)\n     , token_extractor(token_extactor_)\n {\n-    if (!filter_actions_dag)\n+    if (!predicate)\n     {\n         rpn.push_back(RPNElement::FUNCTION_UNKNOWN);\n         return;\n     }\n \n-    /// Clone ActionsDAG with re-generated column name for constants.\n-    /// DAG from the query (with enabled analyzer) uses suffixes for constants, like 1_UInt8.\n-    /// DAG from the skip indexes does not use it. This breaks matching by column name sometimes.\n-    auto cloned_filter_actions_dag = cloneFilterDAGForIndexesAnalysis(*filter_actions_dag);\n     RPNBuilder<RPNElement> builder(\n-        cloned_filter_actions_dag.getOutputs().at(0),\n+        predicate,\n         context,\n         [&](const RPNBuilderTreeNode & node, RPNElement & out) { return extractAtomFromTree(node, out); });\n     rpn = std::move(builder).extractRPN();\n@@ -756,9 +751,9 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexBloomFilterText::createIndexAggregator\n }\n \n MergeTreeIndexConditionPtr MergeTreeIndexBloomFilterText::createIndexCondition(\n-        const ActionsDAG * filter_dag, ContextPtr context) const\n+        const ActionsDAG::Node * predicate, ContextPtr context) const\n {\n-    return std::make_shared<MergeTreeConditionBloomFilterText>(filter_dag, context, index.sample_block, params, token_extractor.get());\n+    return std::make_shared<MergeTreeConditionBloomFilterText>(predicate, context, index.sample_block, params, token_extractor.get());\n }\n \n MergeTreeIndexPtr bloomFilterIndexTextCreator(\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.h b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.h\nindex c0b419fdb2f9..cc3e6ee0f15a 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexBloomFilterText.h\n@@ -64,7 +64,7 @@ class MergeTreeConditionBloomFilterText final : public IMergeTreeIndexCondition\n {\n public:\n     MergeTreeConditionBloomFilterText(\n-            const ActionsDAG * filter_actions_dag,\n+            const ActionsDAG::Node * predicate,\n             ContextPtr context,\n             const Block & index_sample_block,\n             const BloomFilterParameters & params_,\n@@ -166,7 +166,7 @@ class MergeTreeIndexBloomFilterText final : public IMergeTreeIndex\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n \n     MergeTreeIndexConditionPtr createIndexCondition(\n-            const ActionsDAG * filter_dag, ContextPtr context) const override;\n+            const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n     BloomFilterParameters params;\n     /// Function for selecting next token.\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexGin.cpp b/src/Storages/MergeTree/MergeTreeIndexGin.cpp\nindex bb97ac7d6f31..64b73be33675 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexGin.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexGin.cpp\n@@ -15,7 +15,6 @@\n #include <Interpreters/Set.h>\n #include <Interpreters/misc.h>\n #include <Storages/MergeTree/MergeTreeData.h>\n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n #include <Storages/MergeTree/RPNBuilder.h>\n #include <Common/OptimizedRegularExpression.h>\n #include <algorithm>\n@@ -190,7 +189,7 @@ void MergeTreeIndexAggregatorGin::update(const Block & block, size_t * pos, size\n }\n \n MergeTreeIndexConditionGin::MergeTreeIndexConditionGin(\n-    const ActionsDAG * filter_actions_dag,\n+    const ActionsDAG::Node * predicate,\n     ContextPtr context_,\n     const Block & index_sample_block,\n     const GinFilterParameters & params_,\n@@ -199,19 +198,15 @@ MergeTreeIndexConditionGin::MergeTreeIndexConditionGin(\n     , params(params_)\n     , token_extractor(token_extactor_)\n {\n-    if (!filter_actions_dag)\n+    if (!predicate)\n     {\n         rpn.push_back(RPNElement::FUNCTION_UNKNOWN);\n         return;\n     }\n \n-    /// Clone ActionsDAG with re-generated column name for constants.\n-    /// DAG from the query (with enabled analyzer) uses suffixes for constants, like 1_UInt8.\n-    /// DAG from the skip indexes does not use it. This breaks matching by column name sometimes.\n-    auto cloned_filter_actions_dag = cloneFilterDAGForIndexesAnalysis(*filter_actions_dag);\n     rpn = std::move(\n             RPNBuilder<RPNElement>(\n-                    cloned_filter_actions_dag.getOutputs().at(0), context_,\n+                    predicate, context_,\n                     [&](const RPNBuilderTreeNode & node, RPNElement & out)\n                     {\n                         return this->traverseAtomAST(node, out);\n@@ -777,9 +772,9 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexGin::createIndexAggregatorForPart(cons\n }\n \n MergeTreeIndexConditionPtr MergeTreeIndexGin::createIndexCondition(\n-        const ActionsDAG * filter_actions_dag, ContextPtr context) const\n+    const ActionsDAG::Node * predicate, ContextPtr context) const\n {\n-    return std::make_shared<MergeTreeIndexConditionGin>(filter_actions_dag, context, index.sample_block, params, token_extractor.get());\n+    return std::make_shared<MergeTreeIndexConditionGin>(predicate, context, index.sample_block, params, token_extractor.get());\n };\n \n MergeTreeIndexPtr ginIndexCreator(\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexGin.h b/src/Storages/MergeTree/MergeTreeIndexGin.h\nindex dc7cb28386aa..063a4c5c3603 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexGin.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexGin.h\n@@ -65,7 +65,7 @@ class MergeTreeIndexConditionGin final : public IMergeTreeIndexCondition, WithCo\n {\n public:\n     MergeTreeIndexConditionGin(\n-            const ActionsDAG * filter_actions_dag,\n+            const ActionsDAG::Node * predicate,\n             ContextPtr context,\n             const Block & index_sample_block,\n             const GinFilterParameters & params_,\n@@ -172,7 +172,7 @@ class MergeTreeIndexGin final : public IMergeTreeIndex\n     MergeTreeIndexGranulePtr createIndexGranule() const override;\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n     MergeTreeIndexAggregatorPtr createIndexAggregatorForPart(const GinIndexStorePtr & store, const MergeTreeWriterSettings & /*settings*/) const override;\n-    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n+    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n     GinFilterParameters params;\n     /// Function for selecting next token.\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexHypothesis.cpp b/src/Storages/MergeTree/MergeTreeIndexHypothesis.cpp\nindex 4bce5f34a1bb..307226d661b2 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexHypothesis.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexHypothesis.cpp\n@@ -78,7 +78,7 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexHypothesis::createIndexAggregator(cons\n }\n \n MergeTreeIndexConditionPtr MergeTreeIndexHypothesis::createIndexCondition(\n-    const ActionsDAG *, ContextPtr) const\n+    const ActionsDAG::Node *, ContextPtr) const\n {\n     throw Exception(ErrorCodes::LOGICAL_ERROR, \"Not supported\");\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexHypothesis.h b/src/Storages/MergeTree/MergeTreeIndexHypothesis.h\nindex dfdc1f29dc17..9832b0d9a2ff 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexHypothesis.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexHypothesis.h\n@@ -71,7 +71,7 @@ class MergeTreeIndexHypothesis : public IMergeTreeIndex\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n \n     MergeTreeIndexConditionPtr createIndexCondition(\n-        const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n+        const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n     MergeTreeIndexMergedConditionPtr createIndexMergedCondition(\n         const SelectQueryInfo & query_info, StorageMetadataPtr storage_metadata) const override;\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.cpp b/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.cpp\nindex 954ce3360d27..3cf015adbe1f 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.cpp\n@@ -23,7 +23,7 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexLegacyVectorSimilarity::createIndexAgg\n     throw Exception(ErrorCodes::ILLEGAL_INDEX, \"Indexes of type 'annoy' or 'usearch' are no longer supported. Please drop and recreate the index as type 'vector_similarity'\");\n }\n \n-MergeTreeIndexConditionPtr MergeTreeIndexLegacyVectorSimilarity::createIndexCondition(const ActionsDAG *, ContextPtr) const\n+MergeTreeIndexConditionPtr MergeTreeIndexLegacyVectorSimilarity::createIndexCondition(const ActionsDAG::Node *, ContextPtr) const\n {\n     throw Exception(ErrorCodes::ILLEGAL_INDEX, \"Indexes of type 'annoy' or 'usearch' are no longer supported. Please drop and recreate the index as type 'vector_similarity'\");\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.h b/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.h\nindex 12e997463a07..9772ff1802a8 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.h\n@@ -17,7 +17,7 @@ class MergeTreeIndexLegacyVectorSimilarity : public IMergeTreeIndex\n \n     MergeTreeIndexGranulePtr createIndexGranule() const override;\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings &) const override;\n-    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n+    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n     bool isVectorSimilarityIndex() const override { return true; }\n };\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp b/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp\nindex 4d7870c4dba5..f9fdc2c97cd0 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexMinMax.cpp\n@@ -161,17 +161,17 @@ void MergeTreeIndexAggregatorMinMax::update(const Block & block, size_t * pos, s\n namespace\n {\n \n-KeyCondition buildCondition(const IndexDescription & index, const ActionsDAG * filter_actions_dag, ContextPtr context)\n+KeyCondition buildCondition(const IndexDescription & index, const ActionsDAGWithInversionPushDown & filter_dag, ContextPtr context)\n {\n-    return KeyCondition{filter_actions_dag, context, index.column_names, index.expression};\n+    return KeyCondition{filter_dag, context, index.column_names, index.expression};\n }\n \n }\n \n MergeTreeIndexConditionMinMax::MergeTreeIndexConditionMinMax(\n-    const IndexDescription & index, const ActionsDAG * filter_actions_dag, ContextPtr context)\n+    const IndexDescription & index, const ActionsDAGWithInversionPushDown & filter_dag, ContextPtr context)\n     : index_data_types(index.data_types)\n-    , condition(buildCondition(index, filter_actions_dag, context))\n+    , condition(buildCondition(index, filter_dag, context))\n {\n }\n \n@@ -199,9 +199,10 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexMinMax::createIndexAggregator(const Me\n }\n \n MergeTreeIndexConditionPtr MergeTreeIndexMinMax::createIndexCondition(\n-    const ActionsDAG * filter_actions_dag, ContextPtr context) const\n+    const ActionsDAG::Node * predicate, ContextPtr context) const\n {\n-    return std::make_shared<MergeTreeIndexConditionMinMax>(index, filter_actions_dag, context);\n+    ActionsDAGWithInversionPushDown filter_dag(predicate, context);\n+    return std::make_shared<MergeTreeIndexConditionMinMax>(index, filter_dag, context);\n }\n \n MergeTreeIndexFormat MergeTreeIndexMinMax::getDeserializedFormat(const IDataPartStorage & data_part_storage, const std::string & relative_path_prefix) const\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexMinMax.h b/src/Storages/MergeTree/MergeTreeIndexMinMax.h\nindex 229d16ff008f..049219fb1c0e 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexMinMax.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexMinMax.h\n@@ -52,7 +52,7 @@ class MergeTreeIndexConditionMinMax final : public IMergeTreeIndexCondition\n public:\n     MergeTreeIndexConditionMinMax(\n         const IndexDescription & index,\n-        const ActionsDAG * filter_actions_dag,\n+        const ActionsDAGWithInversionPushDown & filter_dag,\n         ContextPtr context);\n \n     bool alwaysUnknownOrTrue() const override;\n@@ -79,7 +79,7 @@ class MergeTreeIndexMinMax : public IMergeTreeIndex\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n \n     MergeTreeIndexConditionPtr createIndexCondition(\n-        const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n+        const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n     const char* getSerializedFileExtension() const override { return \".idx2\"; }\n     MergeTreeIndexFormat getDeserializedFormat(const IDataPartStorage & data_part_storage, const std::string & path_prefix) const override; /// NOLINT\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexSet.cpp b/src/Storages/MergeTree/MergeTreeIndexSet.cpp\nindex 0419d423f238..16102136eea9 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexSet.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexSet.cpp\n@@ -18,9 +18,6 @@\n #include <Functions/indexHint.h>\n #include <Planner/PlannerActionsVisitor.h>\n \n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n-\n-\n namespace DB\n {\n \n@@ -342,14 +339,14 @@ MergeTreeIndexGranulePtr MergeTreeIndexAggregatorSet::getGranuleAndReset()\n     return granule;\n }\n \n-KeyCondition buildCondition(const IndexDescription & index, const ActionsDAG * filter_actions_dag, ContextPtr context)\n+KeyCondition buildCondition(const IndexDescription & index, const ActionsDAGWithInversionPushDown & filter_dag, ContextPtr context)\n {\n-    return KeyCondition{filter_actions_dag, context, index.column_names, index.expression};\n+    return KeyCondition{filter_dag, context, index.column_names, index.expression};\n }\n \n MergeTreeIndexConditionSet::MergeTreeIndexConditionSet(\n     size_t max_rows_,\n-    const ActionsDAG * filter_dag,\n+    const ActionsDAGWithInversionPushDown & filter_dag,\n     ContextPtr context,\n     const IndexDescription & index_description)\n     : index_name(index_description.name)\n@@ -361,21 +358,18 @@ MergeTreeIndexConditionSet::MergeTreeIndexConditionSet(\n         if (!key_columns.contains(name))\n             key_columns.insert(name);\n \n-    if (!filter_dag)\n+    if (!filter_dag.predicate)\n         return;\n \n-    /// Clone ActionsDAG with re-generated column name for constants.\n-    /// DAG from the query (with enabled analyzer) uses suffixes for constants, like 1_UInt8.\n-    /// DAG from the skip indexes does not use it. This breaks matching by column name sometimes.\n-    auto filter_actions_dag = cloneFilterDAGForIndexesAnalysis(*filter_dag);\n     std::vector<FutureSetPtr> sets_to_prepare;\n-    if (checkDAGUseless(*filter_actions_dag.getOutputs().at(0), context, sets_to_prepare))\n+    if (checkDAGUseless(*filter_dag.predicate, context, sets_to_prepare))\n         return;\n     /// Try to run subqueries, don't use index if failed (e.g. if use_index_for_in_with_subqueries is disabled).\n     for (auto & set : sets_to_prepare)\n         if (!set->buildOrderedSetInplace(context))\n             return;\n \n+    auto filter_actions_dag = filter_dag.dag->clone();\n     const auto * filter_actions_dag_node = filter_actions_dag.getOutputs().at(0);\n \n     std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> node_to_result_node;\n@@ -755,9 +749,10 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexSet::createIndexAggregator(const Merge\n }\n \n MergeTreeIndexConditionPtr MergeTreeIndexSet::createIndexCondition(\n-    const ActionsDAG * filter_actions_dag, ContextPtr context) const\n+    const ActionsDAG::Node * predicate, ContextPtr context) const\n {\n-    return std::make_shared<MergeTreeIndexConditionSet>(max_rows, filter_actions_dag, context, index);\n+    ActionsDAGWithInversionPushDown filter_dag(predicate, context);\n+    return std::make_shared<MergeTreeIndexConditionSet>(max_rows, filter_dag, context, index);\n }\n \n MergeTreeIndexPtr setIndexCreator(const IndexDescription & index)\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexSet.h b/src/Storages/MergeTree/MergeTreeIndexSet.h\nindex bfb95b39ad8c..9902c2ee6dc6 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexSet.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexSet.h\n@@ -100,7 +100,7 @@ class MergeTreeIndexConditionSet final : public IMergeTreeIndexCondition\n public:\n     MergeTreeIndexConditionSet(\n         size_t max_rows_,\n-        const ActionsDAG * filter_dag,\n+        const ActionsDAGWithInversionPushDown & filter_dag,\n         ContextPtr context,\n         const IndexDescription & index_description);\n \n@@ -168,7 +168,7 @@ class MergeTreeIndexSet final : public IMergeTreeIndex\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n \n     MergeTreeIndexConditionPtr createIndexCondition(\n-            const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n+        const ActionsDAG::Node * predicate, ContextPtr context) const override;\n \n     size_t max_rows = 0;\n };\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexUtils.cpp b/src/Storages/MergeTree/MergeTreeIndexUtils.cpp\ndeleted file mode 100644\nindex bee0c4c9a3f0..000000000000\n--- a/src/Storages/MergeTree/MergeTreeIndexUtils.cpp\n+++ /dev/null\n@@ -1,150 +0,0 @@\n-#include <Storages/MergeTree/MergeTreeIndexUtils.h>\n-\n-#include <Parsers/ASTExpressionList.h>\n-#include <Parsers/ASTFunction.h>\n-#include <Parsers/ASTSelectQuery.h>\n-#include <Parsers/ASTLiteral.h>\n-#include <Columns/ColumnConst.h>\n-#include <Functions/IFunction.h>\n-\n-namespace DB\n-{\n-\n-ASTPtr buildFilterNode(const ASTPtr & select_query, ASTs additional_filters)\n-{\n-    auto & select_query_typed = select_query->as<ASTSelectQuery &>();\n-\n-    ASTs filters;\n-    if (select_query_typed.where())\n-        filters.push_back(select_query_typed.where());\n-\n-    if (select_query_typed.prewhere())\n-        filters.push_back(select_query_typed.prewhere());\n-\n-    filters.insert(filters.end(), additional_filters.begin(), additional_filters.end());\n-\n-    if (filters.empty())\n-        return nullptr;\n-\n-    ASTPtr filter_node;\n-\n-    if (filters.size() == 1)\n-    {\n-        filter_node = filters.front();\n-    }\n-    else\n-    {\n-        auto function = std::make_shared<ASTFunction>();\n-\n-        function->name = \"and\";\n-        function->arguments = std::make_shared<ASTExpressionList>();\n-        function->children.push_back(function->arguments);\n-        function->arguments->children = std::move(filters);\n-\n-        filter_node = std::move(function);\n-    }\n-\n-    return filter_node;\n-}\n-\n-namespace\n-{\n-\n-bool isTrivialCast(const ActionsDAG::Node & node)\n-{\n-    if (node.function_base->getName() != \"CAST\" || node.children.size() != 2 || node.children[1]->type != ActionsDAG::ActionType::COLUMN)\n-        return false;\n-\n-    const auto * column_const = typeid_cast<const ColumnConst *>(node.children[1]->column.get());\n-    if (!column_const)\n-        return false;\n-\n-    Field field = column_const->getField();\n-    if (field.getType() != Field::Types::String)\n-        return false;\n-\n-    auto type_name = field.safeGet<String>();\n-    return node.children[0]->result_type->getName() == type_name;\n-}\n-\n-const ActionsDAG::Node & cloneFilterDAGNodeForIndexesAnalysis(\n-    const ActionsDAG::Node & node,\n-    ActionsDAG & new_dag,\n-    std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> & cloned_nodes)\n-{\n-    auto it = cloned_nodes.find(&node);\n-    if (it != cloned_nodes.end())\n-        return *it->second;\n-\n-    const ActionsDAG::Node * res;\n-    switch (node.type)\n-    {\n-        case (ActionsDAG::ActionType::INPUT):\n-        {\n-            res = &new_dag.addInput({node.column, node.result_type, node.result_name});\n-            break;\n-        }\n-        case (ActionsDAG::ActionType::COLUMN):\n-        {\n-            String name;\n-            if (const auto * column_const = typeid_cast<const ColumnConst *>(node.column.get());\n-                column_const && column_const->getDataType() != TypeIndex::Function)\n-            {\n-                /// Re-generate column name for constant.\n-                name = ASTLiteral(column_const->getField()).getColumnName();\n-            }\n-            else\n-                name = node.result_name;\n-\n-            res = &new_dag.addColumn({node.column, node.result_type, name});\n-            break;\n-        }\n-        case (ActionsDAG::ActionType::ALIAS):\n-        {\n-            auto arg = cloneFilterDAGNodeForIndexesAnalysis(*node.children.front(), new_dag, cloned_nodes);\n-            res = &new_dag.addAlias(arg, node.result_name);\n-            break;\n-        }\n-        case (ActionsDAG::ActionType::ARRAY_JOIN):\n-        {\n-            auto arg = cloneFilterDAGNodeForIndexesAnalysis(*node.children.front(), new_dag, cloned_nodes);\n-            res = &new_dag.addArrayJoin(arg, {});\n-            break;\n-        }\n-        case (ActionsDAG::ActionType::FUNCTION):\n-        {\n-            if (isTrivialCast(node))\n-            {\n-                /// Remove trivial cast and keep its first argument.\n-                res = &cloneFilterDAGNodeForIndexesAnalysis(*node.children[0], new_dag, cloned_nodes);\n-            }\n-            else\n-            {\n-                ActionsDAG::NodeRawConstPtrs children(node.children);\n-                for (auto & arg : children)\n-                    arg = &cloneFilterDAGNodeForIndexesAnalysis(*arg, new_dag, cloned_nodes);\n-                res = &new_dag.addFunction(node.function_base, children, \"\");\n-            }\n-            break;\n-        }\n-    }\n-\n-    cloned_nodes[&node] = res;\n-    return *res;\n-}\n-\n-}\n-\n-ActionsDAG cloneFilterDAGForIndexesAnalysis(const ActionsDAG & dag)\n-{\n-    ActionsDAG new_dag;\n-    std::unordered_map<const ActionsDAG::Node *, const ActionsDAG::Node *> cloned_nodes;\n-    ActionsDAG::NodeRawConstPtrs outputs = dag.getOutputs();\n-    for (auto & node : outputs)\n-        node = &cloneFilterDAGNodeForIndexesAnalysis(*node, new_dag, cloned_nodes);\n-\n-    new_dag.getOutputs().swap(outputs);\n-    return new_dag;\n-}\n-\n-}\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexUtils.h b/src/Storages/MergeTree/MergeTreeIndexUtils.h\ndeleted file mode 100644\nindex e8ff7240e1c5..000000000000\n--- a/src/Storages/MergeTree/MergeTreeIndexUtils.h\n+++ /dev/null\n@@ -1,20 +0,0 @@\n-#pragma once\n-\n-#include <Parsers/IAST_fwd.h>\n-#include <Interpreters/ActionsDAG.h>\n-\n-namespace DB\n-{\n-\n-/** Build AST filter node for index analysis from WHERE and PREWHERE sections of select query and additional filters.\n-  * If select query does not have WHERE and PREWHERE and additional filters are empty null is returned.\n-  */\n-ASTPtr buildFilterNode(const ASTPtr & select_query, ASTs additional_filters = {});\n-\n-/// Clone ActionsDAG with re-generated column name for constants.\n-/// DAG from the query (with enabled analyzer) uses suffixes for constants, like 1_UInt8.\n-/// DAG from the skip indexes does not use it. This breaks matching by column name sometimes.\n-/// Also remove useless CASTs to the same type (CAST(column, 'Type') where column already has type Type).\n-ActionsDAG cloneFilterDAGForIndexesAnalysis(const ActionsDAG & dag);\n-\n-}\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\nindex 35daf696e56a..ca87cb149541 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\n+++ b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp\n@@ -513,12 +513,12 @@ MergeTreeIndexAggregatorPtr MergeTreeIndexVectorSimilarity::createIndexAggregato\n     return std::make_shared<MergeTreeIndexAggregatorVectorSimilarity>(index.name, index.sample_block, dimensions, metric_kind, scalar_kind, usearch_hnsw_params);\n }\n \n-MergeTreeIndexConditionPtr MergeTreeIndexVectorSimilarity::createIndexCondition(const ActionsDAG * /*filter_actions_dag*/, ContextPtr /*context*/) const\n+MergeTreeIndexConditionPtr MergeTreeIndexVectorSimilarity::createIndexCondition(const ActionsDAG::Node * /*predicate*/, ContextPtr /*context*/) const\n {\n     throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Function not supported for vector similarity index\");\n }\n \n-MergeTreeIndexConditionPtr MergeTreeIndexVectorSimilarity::createIndexCondition(const ActionsDAG * /*filter_actions_dag*/, ContextPtr context, const std::optional<VectorSearchParameters> & parameters) const\n+MergeTreeIndexConditionPtr MergeTreeIndexVectorSimilarity::createIndexCondition(const ActionsDAG::Node * /*predicate*/, ContextPtr context, const std::optional<VectorSearchParameters> & parameters) const\n {\n     const String & index_column = index.column_names[0];\n     return std::make_shared<MergeTreeIndexConditionVectorSimilarity>(parameters, index_column, metric_kind, context);\ndiff --git a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\nindex 9e2b854f15f8..15c7f2c08964 100644\n--- a/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\n+++ b/src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h\n@@ -176,8 +176,8 @@ class MergeTreeIndexVectorSimilarity : public IMergeTreeIndex\n \n     MergeTreeIndexGranulePtr createIndexGranule() const override;\n     MergeTreeIndexAggregatorPtr createIndexAggregator(const MergeTreeWriterSettings & settings) const override;\n-    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG * filter_actions_dag, ContextPtr context) const override;\n-    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG * filter_actions_dag, ContextPtr context, const std::optional<VectorSearchParameters> & parameters) const override;\n+    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG::Node * predicate, ContextPtr context) const override;\n+    MergeTreeIndexConditionPtr createIndexCondition(const ActionsDAG::Node * predicate, ContextPtr context, const std::optional<VectorSearchParameters> & parameters) const override;\n     bool isVectorSimilarityIndex() const override { return true; }\n \n private:\ndiff --git a/src/Storages/MergeTree/MergeTreeIndices.h b/src/Storages/MergeTree/MergeTreeIndices.h\nindex d1a4d051ebec..22dba58311cf 100644\n--- a/src/Storages/MergeTree/MergeTreeIndices.h\n+++ b/src/Storages/MergeTree/MergeTreeIndices.h\n@@ -2,6 +2,7 @@\n #include \"config.h\"\n \n #include <Storages/IndicesDescription.h>\n+#include <Interpreters/ActionsDAG.h>\n \n #include <memory>\n #include <string>\n@@ -214,11 +215,11 @@ struct IMergeTreeIndex\n     }\n \n     virtual MergeTreeIndexConditionPtr createIndexCondition(\n-        const ActionsDAG * filter_actions_dag, ContextPtr context) const = 0;\n+        const ActionsDAG::Node * predicate, ContextPtr context) const = 0;\n \n     /// The vector similarity index overrides this method\n     virtual MergeTreeIndexConditionPtr createIndexCondition(\n-        const ActionsDAG * /*filter_actions_dag*/, ContextPtr /*context*/,\n+        const ActionsDAG::Node * /*predicate*/, ContextPtr /*context*/,\n         const std::optional<VectorSearchParameters> & /*parameters*/) const\n     {\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED,\ndiff --git a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\nindex cdd7952b648a..25be7867959b 100644\n--- a/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n+++ b/src/Storages/MergeTree/MergeTreeSequentialSource.cpp\n@@ -360,7 +360,8 @@ class ReadFromPart final : public ISourceStep\n         {\n             const auto & primary_key = storage_snapshot->metadata->getPrimaryKey();\n             const Names & primary_key_column_names = primary_key.column_names;\n-            KeyCondition key_condition(&*filter, context, primary_key_column_names, primary_key.expression);\n+            ActionsDAGWithInversionPushDown filter_dag(filter->getOutputs().front(), context);\n+            KeyCondition key_condition(filter_dag, context, primary_key_column_names, primary_key.expression);\n             LOG_DEBUG(log, \"Key condition: {}\", key_condition.toString());\n \n             if (!key_condition.alwaysFalse())\ndiff --git a/src/Storages/MergeTree/PartitionPruner.cpp b/src/Storages/MergeTree/PartitionPruner.cpp\nindex 0a51336845da..3f0e0b9332e2 100644\n--- a/src/Storages/MergeTree/PartitionPruner.cpp\n+++ b/src/Storages/MergeTree/PartitionPruner.cpp\n@@ -4,9 +4,9 @@\n namespace DB\n {\n \n-PartitionPruner::PartitionPruner(const StorageMetadataPtr & metadata, const ActionsDAG * filter_actions_dag, ContextPtr context, bool strict)\n+PartitionPruner::PartitionPruner(const StorageMetadataPtr & metadata, const ActionsDAGWithInversionPushDown & filter_dag, ContextPtr context, bool strict)\n     : partition_key(MergeTreePartition::adjustPartitionKey(metadata, context))\n-    , partition_condition(filter_actions_dag, context, partition_key.column_names, partition_key.expression, true /* single_point */)\n+    , partition_condition(filter_dag, context, partition_key.column_names, partition_key.expression, true /* single_point */)\n     , useless((strict && partition_condition.isRelaxed()) || partition_condition.alwaysUnknownOrTrue())\n {\n }\ndiff --git a/src/Storages/MergeTree/PartitionPruner.h b/src/Storages/MergeTree/PartitionPruner.h\nindex d89dfb7b2456..714b07bf61a3 100644\n--- a/src/Storages/MergeTree/PartitionPruner.h\n+++ b/src/Storages/MergeTree/PartitionPruner.h\n@@ -13,7 +13,7 @@ namespace DB\n class PartitionPruner\n {\n public:\n-    PartitionPruner(const StorageMetadataPtr & metadata, const ActionsDAG * filter_actions_dag, ContextPtr context, bool strict = false);\n+    PartitionPruner(const StorageMetadataPtr & metadata, const ActionsDAGWithInversionPushDown & filter_dag, ContextPtr context, bool strict = false);\n \n     bool canBePruned(const IMergeTreeDataPart & part) const;\n \ndiff --git a/src/Storages/ObjectStorage/DataLakes/DeltaLake/PartitionPruner.cpp b/src/Storages/ObjectStorage/DataLakes/DeltaLake/PartitionPruner.cpp\nindex 9a487b6cd617..c2b4754e116b 100644\n--- a/src/Storages/ObjectStorage/DataLakes/DeltaLake/PartitionPruner.cpp\n+++ b/src/Storages/ObjectStorage/DataLakes/DeltaLake/PartitionPruner.cpp\n@@ -73,8 +73,9 @@ PartitionPruner::PartitionPruner(\n             partition_columns_description,\n             context);\n \n+        DB::ActionsDAGWithInversionPushDown inverted_dag(filter_dag.getOutputs().front(), context);\n         key_condition.emplace(\n-            &filter_dag, context, partition_key.column_names, partition_key.expression, true /* single_point */);\n+            inverted_dag, context, partition_key.column_names, partition_key.expression, true /* single_point */);\n     }\n }\n \ndiff --git a/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFilesPruning.cpp b/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFilesPruning.cpp\nindex 246af3f2d457..59d2234ea1a7 100644\n--- a/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFilesPruning.cpp\n+++ b/src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFilesPruning.cpp\n@@ -145,7 +145,10 @@ ManifestFilesPruner::ManifestFilesPruner(\n     {\n         partition_key = &manifest_file.getPartitionKeyDescription();\n         if (transformed_dag != nullptr)\n-            partition_key_condition.emplace(transformed_dag.get(), context, partition_key->column_names, partition_key->expression, true /* single_point */);\n+        {\n+            ActionsDAGWithInversionPushDown inverted_dag(transformed_dag->getOutputs().front(), context);\n+            partition_key_condition.emplace(inverted_dag, context, partition_key->column_names, partition_key->expression, true /* single_point */);\n+        }\n     }\n \n     if (manifest_file.hasBoundsInfoInManifests() && transformed_dag != nullptr)\n@@ -163,7 +166,8 @@ ManifestFilesPruner::ManifestFilesPruner(\n                 ExpressionActionsPtr expression = std::make_shared<ExpressionActions>(\n                     ActionsDAG({name_and_type}), ExpressionActionsSettings(context));\n \n-                min_max_key_conditions.emplace(used_column_id, KeyCondition(transformed_dag.get(), context, {name_and_type.name}, expression));\n+                ActionsDAGWithInversionPushDown inverted_dag(transformed_dag->getOutputs().front(), context);\n+                min_max_key_conditions.emplace(used_column_id, KeyCondition(inverted_dag, context, {name_and_type.name}, expression));\n             }\n         }\n     }\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/01888_bloom_filter_hasAny.sql b/tests/queries/0_stateless/01888_bloom_filter_hasAny.sql\nindex aef32791fd43..dcd0a1346ee8 100644\n--- a/tests/queries/0_stateless/01888_bloom_filter_hasAny.sql\n+++ b/tests/queries/0_stateless/01888_bloom_filter_hasAny.sql\n@@ -25,7 +25,7 @@ SELECT count() FROM bftest WHERE hasAny(x, []) FORMAT Null;\n SELECT count() FROM bftest WHERE hasAny(x, [1]) FORMAT Null;\n \n -- can't use bloom_filter with `hasAny` on non-constant arguments (just like `has`)\n-SELECT count() FROM bftest WHERE hasAny(x, materialize([1,2,3])) FORMAT Null; -- { serverError INDEX_NOT_USED }\n+SELECT count() FROM bftest WHERE hasAny(x, [1,2,k]) FORMAT Null; -- { serverError INDEX_NOT_USED }\n \n -- NULLs are not Ok\n SELECT count() FROM bftest WHERE hasAny(x, [NULL,-42]) FORMAT Null; -- { serverError INDEX_NOT_USED }\ndiff --git a/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql b/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql\nindex 02ac22796864..1058f8df774e 100644\n--- a/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql\n+++ b/tests/queries/0_stateless/02013_bloom_filter_hasAll.sql\n@@ -26,7 +26,7 @@ SELECT count() FROM bftest WHERE hasAll(x, []) FORMAT Null;\n SELECT count() FROM bftest WHERE hasAll(x, [1]) FORMAT Null;\n \n -- can't use bloom_filter with `hasAll` on non-constant arguments (just like `has`)\n-SELECT count() FROM bftest WHERE hasAll(x, materialize([1,2,3])) FORMAT Null; -- { serverError INDEX_NOT_USED }\n+SELECT count() FROM bftest WHERE hasAll(x, [1,2,k]) FORMAT Null; -- { serverError INDEX_NOT_USED }\n \n -- NULLs are not Ok\n SELECT count() FROM bftest WHERE hasAll(x, [NULL,-42]) FORMAT Null; -- { serverError INDEX_NOT_USED }\ndiff --git a/tests/queries/0_stateless/03262_filter_push_down_view.reference b/tests/queries/0_stateless/03262_filter_push_down_view.reference\nindex 275ff18f73be..5ea796009596 100644\n--- a/tests/queries/0_stateless/03262_filter_push_down_view.reference\n+++ b/tests/queries/0_stateless/03262_filter_push_down_view.reference\n@@ -1,2 +1,2 @@\n-Condition: and((materialize(auid) in [1, 1]), (_CAST(toDate(ts)) in (-Inf, 1703980800]))\n+Condition: and((auid in [1, 1]), (_CAST(toDate(ts)) in (-Inf, 1703980800]))\n Granules: 1/3\ndiff --git a/tests/queries/0_stateless/03266_lowcardinality_string_monotonicity.reference b/tests/queries/0_stateless/03266_lowcardinality_string_monotonicity.reference\nindex 5970daf13c81..4ff3a7d8661b 100644\n--- a/tests/queries/0_stateless/03266_lowcardinality_string_monotonicity.reference\n+++ b/tests/queries/0_stateless/03266_lowcardinality_string_monotonicity.reference\n@@ -1,2 +1,2 @@\n Condition: (CAST(s, \\'LowCardinality(String)\\') in [\\'42\\', \\'42\\'])\n-Condition: (CAST(s, \\'String\\') in [\\'42\\', \\'42\\'])\n+Condition: (s in [\\'42\\', \\'42\\'])\ndiff --git a/tests/queries/0_stateless/03302_analyzer_distributed_filter_push_down.reference b/tests/queries/0_stateless/03302_analyzer_distributed_filter_push_down.reference\nindex c726ebc1ad32..aafeb8a46849 100644\n--- a/tests/queries/0_stateless/03302_analyzer_distributed_filter_push_down.reference\n+++ b/tests/queries/0_stateless/03302_analyzer_distributed_filter_push_down.reference\n@@ -517,7 +517,7 @@ Union\n         PrimaryKey\n           Keys: \n             n\n-          Condition: (materialize(n) in [100, 100])\n+          Condition: (n in [100, 100])\n           Parts: 1/1\n           Granules: 1/62\n   Expression ((Project names + Projection))\n@@ -554,6 +554,6 @@ Union\n               PrimaryKey\n                 Keys: \n                   n\n-                Condition: (materialize(n) in [100, 100])\n+                Condition: (n in [100, 100])\n                 Parts: 1/1\n                 Granules: 1/62\ndiff --git a/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.reference b/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.reference\nnew file mode 100644\nindex 000000000000..8b0fbcc5b084\n--- /dev/null\n+++ b/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.reference\n@@ -0,0 +1,30 @@\n+index is applied while using column alias\n+Expression ((Projection + Before ORDER BY))\n+  Expression\n+    ReadFromMergeTree (default.t)\n+    Indexes:\n+      PrimaryKey\n+        Condition: true\n+        Parts: 1/1\n+        Granules: 8/8\n+      Skip\n+        Name: ngrams\n+        Description: ngrambf_v1 GRANULARITY 1\n+        Parts: 0/1\n+        Granules: 0/8\n+Expression ((Project names + Projection))\n+  Expression\n+    ReadFromMergeTree (default.t)\n+    Indexes:\n+      PrimaryKey\n+        Condition: true\n+        Parts: 1/1\n+        Granules: 8/8\n+      Skip\n+        Name: ngrams\n+        Description: ngrambf_v1 GRANULARITY 1\n+        Parts: 0/1\n+        Granules: 0/8\n+index is applied to view\n+0\n+0\ndiff --git a/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.sql b/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.sql\nnew file mode 100644\nindex 000000000000..c959b56d93c5\n--- /dev/null\n+++ b/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.sql\n@@ -0,0 +1,51 @@\n+-- Tags: no-random-merge-tree-settings, no-random-settings, no-parallel-replicas\n+\n+--- #65607\n+select 'index is applied while using column alias';\n+\n+drop table if exists t;\n+CREATE TABLE t\n+(\n+    `tenant` String,\n+    `recordTimestamp` Int64,\n+    `responseBody` String,\n+    `colAlias` String ALIAS responseBody || 'something else',\n+    INDEX ngrams colAlias TYPE ngrambf_v1(3, 2097152, 3, 0) GRANULARITY 1,\n+)\n+ENGINE = MergeTree\n+ORDER BY recordTimestamp\n+SETTINGS index_granularity = 8192, index_granularity_bytes = '10Mi';\n+\n+INSERT INTO t SELECT toString(number), number, toString(number) from numbers(65536);\n+\n+explain indexes=1 select tenant,recordTimestamp from t where colAlias like '%abcd%' settings enable_analyzer=0;\n+explain indexes=1 select tenant,recordTimestamp from t where colAlias like '%abcd%' settings enable_analyzer=1;\n+\n+\n+--- #69373\n+select 'index is applied to view';\n+\n+drop table if exists tab_v1;\n+CREATE TABLE tab_v1\n+(\n+    content String,\n+    INDEX idx_content_bloom content TYPE bloom_filter(0.01)\n+)\n+ENGINE = MergeTree\n+ORDER BY content;\n+\n+drop table if exists tab_v3;\n+CREATE VIEW tab_v3\n+AS SELECT * FROM tab_v1;\n+\n+INSERT INTO tab_v1 (content) VALUES ('aaa bbb'), ('ccc ddd');\n+\n+SELECT count()\n+FROM tab_v3\n+WHERE content = 'iii'\n+SETTINGS force_data_skipping_indices='idx_content_bloom', enable_analyzer=0;\n+\n+SELECT count()\n+FROM tab_v3\n+WHERE content = 'iii'\n+SETTINGS force_data_skipping_indices='idx_content_bloom', enable_analyzer=1;\n",
  "problem_statement": "Different behavior of skip index with alias in latest version\nVersion 24.2.3.70, index used:\n```sql\nCREATE TABLE t\n(\n    `tenant` String,\n    `recordTimestamp` Int64,\n    `responseBody` String,\n    `colAlias` String ALIAS responseBody || 'something else',\n    INDEX ngrams colAlias TYPE ngrambf_v1(3, 2097152, 3, 0) GRANULARITY 1,\n)\nENGINE = MergeTree\nPARTITION BY (tenant, toDate(recordTimestamp))\nORDER BY recordTimestamp;\n\nINSERT INTO t SELECT * FROM generateRandom('tenant String, recordTimestamp Int64, responseBody String') LIMIT 100;\n\nset send_logs_level='debug';\n\nexplain indexes=1 select tenant,recordTimestamp from t where colAlias like '%abcd%';\n\nExpression ((Projection + Before ORDER BY))\n  Expression\n    ReadFromMergeTree (default.t)\n    Indexes:\n      MinMax\n        Condition: true\n        Parts: 98/98\n        Granules: 98/98\n      Partition\n        Condition: true\n        Parts: 98/98\n        Granules: 98/98\n      PrimaryKey\n        Condition: true\n        Parts: 98/98\n        Granules: 98/98\n      Skip\n        Name: ngrams\n        Description: ngrambf_v1 GRANULARITY 1\n        Parts: 0/98\n        Granules: 0/98\n```\nhttps://fiddle.clickhouse.com/e4b3bc3b-7b1e-4284-9705-5b16a0475138\n\n24.3 and later versions, index not used:\nhttps://fiddle.clickhouse.com/0b617027-0173-43d2-9606-1b09596afa1d\n\n```sql\nExpression ((Project names + Projection))\n  Expression\n    ReadFromMergeTree (default.t)\n    Indexes:\n      MinMax\n        Condition: true\n        Parts: 89/89\n        Granules: 89/89\n      Partition\n        Condition: true\n        Parts: 89/89\n        Granules: 89/89\n      PrimaryKey\n        Condition: true\n        Parts: 89/89\n        Granules: 89/89\n```\n\nAnalyzer: Skipping indexes don't work with VIEWs\n**Describe the unexpected behaviour**\r\nNewer versions of clickhouse don't use indices on views which are defined as union\r\n\r\n**How to reproduce**\r\n```\r\nCREATE TABLE tab_v1\r\n(\r\n    content String,\r\n    INDEX idx_content_bloom content TYPE bloom_filter(0.01)\r\n)\r\nENGINE = MergeTree\r\nORDER BY content\r\n\r\nCREATE TABLE tab_v2\r\n(\r\n    content String,\r\n    INDEX idx_content_bloom content TYPE bloom_filter(0.01)\r\n)\r\nENGINE = MergeTree\r\nORDER BY content\r\n\r\n\r\nCREATE VIEW tab_v3\r\nAS SELECT *\r\nFROM tab_v1\r\nUNION ALL\r\nSELECT *\r\nFROM tab_v2\r\n\r\nINSERT INTO tab_v1 (content) VALUES ('aaa bbb'), ('ccc ddd')\r\nINSERT INTO tab_v2 (content) VALUES ('eee fff'), ('ggg hhh')\r\n\r\n\r\nSELECT *\r\nFROM tab_v3\r\nWHERE content = 'iii'\r\nSETTINGS force_data_skipping_indices='idx_content_bloom'\r\n```\r\n\r\n**Expected behavior**\r\nRunning on version `24.8.4.13` results on this:\r\n```\r\nCode: 277. DB::Exception: Received from localhost:9000. DB::Exception: Index `idx_content_bloom` is not used and setting 'force_data_skipping_indices' contains it. (INDEX_NOT_USED)\r\n```\r\n\r\n**However, works fine on `23.10.3`**\r\n\r\n\r\n**Additional context**\r\nJust found a workaround for this, disabling `allow_experimental_analyzer`:\r\n```\r\nSELECT *\r\nFROM tab_v3\r\nWHERE content = 'iii'\r\nSETTINGS force_data_skipping_indices='idx_content_bloom',allow_experimental_analyzer=0\r\n```\n",
  "hints_text": "Because of experimental analyzer\r\n\r\nhttps://fiddle.clickhouse.com/d78734f6-0647-43e7-b68f-ddda593326d7\n`union` is not required https://fiddle.clickhouse.com/d268b30a-906d-496a-b275-b552cb78fbc9\nAny update on this one ? This is very painful as disabling the analyzer cause a lot other problems ",
  "created_at": "2025-03-31T17:12:16Z",
  "modified_files": [
    "src/Interpreters/evaluateConstantExpression.cpp",
    "src/Processors/QueryPlan/ReadFromMergeTree.cpp",
    "src/Processors/QueryPlan/ReadFromSystemNumbersStep.cpp",
    "src/Processors/SourceWithKeyCondition.cpp",
    "src/Storages/Hive/StorageHive.cpp",
    "src/Storages/MergeTree/KeyCondition.cpp",
    "src/Storages/MergeTree/KeyCondition.h",
    "src/Storages/MergeTree/MergeTreeData.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp",
    "src/Storages/MergeTree/MergeTreeDataSelectExecutor.h",
    "src/Storages/MergeTree/MergeTreeIndexBloomFilter.cpp",
    "src/Storages/MergeTree/MergeTreeIndexBloomFilter.h",
    "src/Storages/MergeTree/MergeTreeIndexBloomFilterText.cpp",
    "src/Storages/MergeTree/MergeTreeIndexBloomFilterText.h",
    "src/Storages/MergeTree/MergeTreeIndexGin.cpp",
    "src/Storages/MergeTree/MergeTreeIndexGin.h",
    "src/Storages/MergeTree/MergeTreeIndexHypothesis.cpp",
    "src/Storages/MergeTree/MergeTreeIndexHypothesis.h",
    "src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.cpp",
    "src/Storages/MergeTree/MergeTreeIndexLegacyVectorSimilarity.h",
    "src/Storages/MergeTree/MergeTreeIndexMinMax.cpp",
    "src/Storages/MergeTree/MergeTreeIndexMinMax.h",
    "src/Storages/MergeTree/MergeTreeIndexSet.cpp",
    "src/Storages/MergeTree/MergeTreeIndexSet.h",
    "src/Storages/MergeTree/MergeTreeIndexUtils.cpp",
    "src/Storages/MergeTree/MergeTreeIndexUtils.h",
    "src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.cpp",
    "src/Storages/MergeTree/MergeTreeIndexVectorSimilarity.h",
    "src/Storages/MergeTree/MergeTreeIndices.h",
    "src/Storages/MergeTree/MergeTreeSequentialSource.cpp",
    "src/Storages/MergeTree/PartitionPruner.cpp",
    "src/Storages/MergeTree/PartitionPruner.h",
    "src/Storages/ObjectStorage/DataLakes/DeltaLake/PartitionPruner.cpp",
    "src/Storages/ObjectStorage/DataLakes/Iceberg/ManifestFilesPruning.cpp"
  ],
  "modified_test_files": [
    "tests/queries/0_stateless/01888_bloom_filter_hasAny.sql",
    "tests/queries/0_stateless/02013_bloom_filter_hasAll.sql",
    "tests/queries/0_stateless/03262_filter_push_down_view.reference",
    "tests/queries/0_stateless/03266_lowcardinality_string_monotonicity.reference",
    "tests/queries/0_stateless/03302_analyzer_distributed_filter_push_down.reference",
    "b/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.reference",
    "b/tests/queries/0_stateless/03402_secondary_indexes_analyzer_bugs.sql"
  ]
}