{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 47610,
  "instance_id": "ClickHouse__ClickHouse-47610",
  "issue_numbers": [
    "45668"
  ],
  "base_commit": "634ab620a7238ff3302cd9308c63dd63ea3e3aba",
  "patch": "diff --git a/src/CMakeLists.txt b/src/CMakeLists.txt\nindex 62005c76ce05..f6727bad0e82 100644\n--- a/src/CMakeLists.txt\n+++ b/src/CMakeLists.txt\n@@ -608,7 +608,8 @@ if (ENABLE_TESTS)\n         dbms\n         clickhouse_common_config\n         clickhouse_common_zookeeper\n-        string_utils)\n+        string_utils\n+        hilite_comparator)\n \n     if (TARGET ch_contrib::simdjson)\n         target_link_libraries(unit_tests_dbms PRIVATE ch_contrib::simdjson)\ndiff --git a/src/Parsers/ASTCreateQuery.cpp b/src/Parsers/ASTCreateQuery.cpp\nindex e28e863c21ff..196681a8801b 100644\n--- a/src/Parsers/ASTCreateQuery.cpp\n+++ b/src/Parsers/ASTCreateQuery.cpp\n@@ -440,10 +440,10 @@ void ASTCreateQuery::formatQueryImpl(const FormatSettings & settings, FormatStat\n     if (select)\n     {\n         settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS\"\n-                      << (comment ? \"(\" : \"\")\n-                      << settings.nl_or_ws << (settings.hilite ? hilite_none : \"\");\n+                      << settings.nl_or_ws\n+                      << (comment ? \"(\" : \"\") << (settings.hilite ? hilite_none : \"\");\n         select->formatImpl(settings, state, frame);\n-        settings.ostr << (comment ? \")\" : \"\");\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << (comment ? \")\" : \"\") << (settings.hilite ? hilite_none : \"\");\n     }\n \n     if (comment)\ndiff --git a/src/Parsers/ASTDictionary.cpp b/src/Parsers/ASTDictionary.cpp\nindex 66c1c3791b88..e33a7de6836f 100644\n--- a/src/Parsers/ASTDictionary.cpp\n+++ b/src/Parsers/ASTDictionary.cpp\n@@ -161,8 +161,9 @@ void ASTDictionary::formatImpl(const FormatSettings & settings, FormatState & st\n \n     if (source)\n     {\n-        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << settings.nl_or_ws << \"SOURCE(\"\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << settings.nl_or_ws << \"SOURCE\"\n             << (settings.hilite ? hilite_none : \"\");\n+        settings.ostr << \"(\";\n         source->formatImpl(settings, state, frame);\n         settings.ostr << \")\";\n     }\ndiff --git a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\nindex 760b96b09271..daf708c9478c 100644\n--- a/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\n+++ b/src/Parsers/ASTDictionaryAttributeDeclaration.cpp\n@@ -56,16 +56,16 @@ void ASTDictionaryAttributeDeclaration::formatImpl(const FormatSettings & settin\n     }\n \n     if (hierarchical)\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"HIERARCHICAL\";\n+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"HIERARCHICAL\" << (settings.hilite ? hilite_none : \"\");\n \n     if (bidirectional)\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"BIDIRECTIONAL\";\n+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"BIDIRECTIONAL\" << (settings.hilite ? hilite_none : \"\");\n \n     if (injective)\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"INJECTIVE\";\n+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"INJECTIVE\" << (settings.hilite ? hilite_none : \"\");\n \n     if (is_object_id)\n-        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"IS_OBJECT_ID\";\n+        settings.ostr << ' ' << (settings.hilite ? hilite_keyword : \"\") << \"IS_OBJECT_ID\" << (settings.hilite ? hilite_none : \"\");\n }\n \n }\ndiff --git a/src/Parsers/ASTFunction.cpp b/src/Parsers/ASTFunction.cpp\nindex fa4874d89b6a..99c2dbabdd7f 100644\n--- a/src/Parsers/ASTFunction.cpp\n+++ b/src/Parsers/ASTFunction.cpp\n@@ -692,12 +692,15 @@ void ASTFunction::formatImplWithoutAlias(const FormatSettings & settings, Format\n     {\n         std::string nl_or_nothing = settings.one_line ? \"\" : \"\\n\";\n         std::string indent_str = settings.one_line ? \"\" : std::string(4u * frame.indent, ' ');\n-        settings.ostr << (settings.hilite ? hilite_function : \"\") << name << \"(\" << nl_or_nothing;\n+        settings.ostr << (settings.hilite ? hilite_function : \"\") << name << (settings.hilite ? hilite_none : \"\");\n+        settings.ostr << (settings.hilite ? hilite_function : \"\") << \"(\" << (settings.hilite ? hilite_none : \"\");\n+        settings.ostr << nl_or_nothing;\n         FormatStateStacked frame_nested = frame;\n         frame_nested.need_parens = false;\n         ++frame_nested.indent;\n         query->formatImpl(settings, state, frame_nested);\n-        settings.ostr << nl_or_nothing << indent_str << \")\";\n+        settings.ostr << nl_or_nothing << indent_str;\n+        settings.ostr << (settings.hilite ? hilite_function : \"\") << \")\" << (settings.hilite ? hilite_none : \"\");\n         return;\n     }\n \ndiff --git a/src/Parsers/ASTKillQueryQuery.cpp b/src/Parsers/ASTKillQueryQuery.cpp\nindex 8bf99312544d..a3c0f48f28aa 100644\n--- a/src/Parsers/ASTKillQueryQuery.cpp\n+++ b/src/Parsers/ASTKillQueryQuery.cpp\n@@ -29,11 +29,13 @@ void ASTKillQueryQuery::formatQueryImpl(const FormatSettings & settings, FormatS\n             break;\n     }\n \n+    settings.ostr << (settings.hilite ? hilite_none : \"\");\n+\n     formatOnCluster(settings);\n \n     if (where_expression)\n     {\n-        settings.ostr << \" WHERE \" << (settings.hilite ? hilite_none : \"\");\n+        settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" WHERE \" << (settings.hilite ? hilite_none : \"\");\n         where_expression->formatImpl(settings, state, frame);\n     }\n \ndiff --git a/src/Parsers/ASTWithAlias.cpp b/src/Parsers/ASTWithAlias.cpp\nindex 88f6568a7196..1b5397654fd8 100644\n--- a/src/Parsers/ASTWithAlias.cpp\n+++ b/src/Parsers/ASTWithAlias.cpp\n@@ -20,7 +20,9 @@ void ASTWithAlias::formatImpl(const FormatSettings & settings, FormatState & sta\n     /// This is needed because the query can become extraordinary large after substitution of aliases.\n     if (!alias.empty() && !state.printed_asts_with_alias.emplace(frame.current_select, alias, getTreeHash()).second)\n     {\n+        settings.ostr << (settings.hilite ? IAST::hilite_identifier : \"\");\n         settings.writeIdentifier(alias);\n+        settings.ostr << (settings.hilite ? IAST::hilite_none : \"\");\n     }\n     else\n     {\ndiff --git a/src/Parsers/ASTWithElement.cpp b/src/Parsers/ASTWithElement.cpp\nindex b517509c4bc3..c2cb1177c171 100644\n--- a/src/Parsers/ASTWithElement.cpp\n+++ b/src/Parsers/ASTWithElement.cpp\n@@ -18,7 +18,9 @@ void ASTWithElement::formatImpl(const FormatSettings & settings, FormatState & s\n {\n     std::string indent_str = settings.one_line ? \"\" : std::string(4 * frame.indent, ' ');\n \n+    settings.ostr << (settings.hilite ? hilite_alias : \"\");\n     settings.writeIdentifier(name);\n+    settings.ostr << (settings.hilite ? hilite_none : \"\");\n     settings.ostr << (settings.hilite ? hilite_keyword : \"\") << \" AS\" << (settings.hilite ? hilite_none : \"\");\n     settings.ostr << settings.nl_or_ws << indent_str;\n     dynamic_cast<const ASTWithAlias &>(*subquery).formatImplWithoutAlias(settings, state, frame);\ndiff --git a/src/Parsers/CMakeLists.txt b/src/Parsers/CMakeLists.txt\nindex 73d46593e042..d5cf2bd47849 100644\n--- a/src/Parsers/CMakeLists.txt\n+++ b/src/Parsers/CMakeLists.txt\n@@ -22,3 +22,7 @@ endif()\n if (ENABLE_FUZZING)\n     add_subdirectory(fuzzers)\n endif()\n+\n+if (ENABLE_TESTS)\n+    add_subdirectory(HiliteComparator)\n+endif ()\ndiff --git a/src/Parsers/HiliteComparator/CMakeLists.txt b/src/Parsers/HiliteComparator/CMakeLists.txt\nnew file mode 100644\nindex 000000000000..0e68b19be087\n--- /dev/null\n+++ b/src/Parsers/HiliteComparator/CMakeLists.txt\n@@ -0,0 +1,7 @@\n+include(\"${ClickHouse_SOURCE_DIR}/cmake/dbms_glob_sources.cmake\")\n+\n+add_headers_and_sources(hilite_comparator .)\n+\n+add_library(hilite_comparator ${hilite_comparator_sources})\n+\n+target_link_libraries(hilite_comparator PRIVATE dbms)\ndiff --git a/src/Parsers/HiliteComparator/HiliteComparator.cpp b/src/Parsers/HiliteComparator/HiliteComparator.cpp\nnew file mode 100644\nindex 000000000000..0c12c6e821cc\n--- /dev/null\n+++ b/src/Parsers/HiliteComparator/HiliteComparator.cpp\n@@ -0,0 +1,98 @@\n+#include \"HiliteComparator.h\"\n+\n+namespace HiliteComparator\n+{\n+\n+void consume_hilites(const char * & ptr, Hilite * last_hilite)\n+{\n+    while (true)\n+    {\n+        bool changed_hilite = false;\n+        for (Hilite hilite : hilites)\n+        {\n+            if (std::string_view(ptr).starts_with(hilite))\n+            {\n+                ptr += strlen(hilite);\n+                changed_hilite = true;\n+                if (last_hilite != nullptr)\n+                    *last_hilite = hilite;\n+            }\n+        }\n+        if (!changed_hilite)\n+            break;\n+    }\n+}\n+\n+bool are_equal_with_hilites_removed(std::string_view left, std::string_view right)\n+{\n+    return remove_hilites(left) == remove_hilites(right);\n+}\n+\n+String remove_hilites(std::string_view string)\n+{\n+    const char * ptr = string.begin();\n+    String string_without_hilites;\n+    while (true)\n+    {\n+        consume_hilites(ptr);\n+        if (ptr == string.end())\n+            return string_without_hilites;\n+        string_without_hilites += *(ptr++);\n+    }\n+}\n+\n+/*\n+ * Hilited queries cannot be compared symbol-by-symbol, as there's some frivolousness introduced with the hilites. Specifically:\n+ * 1. Whitespaces could be hilited with any hilite type.\n+ * 2. Hilite could or could be not reset with hilite_none before the next hilite, i.e. the following strings a and b are equal:\n+ *      a. hilite_keyword foo hilite_none hilite_operator +\n+ *      b. hilite_keyword foo hilite_operator +\n+ */\n+bool are_equal_with_hilites(std::string_view left, std::string_view right, bool check_end_without_hilite)\n+{\n+    const char * left_it = left.begin();\n+    const char * right_it = right.begin();\n+    Hilite left_hilite = DB::IAST::hilite_none;\n+    Hilite right_hilite = DB::IAST::hilite_none;\n+\n+    while (true)\n+    {\n+        // For each argument, consume all prefix hilites, and update the current hilite to be the last one.\n+        consume_hilites(left_it, &left_hilite);\n+        consume_hilites(right_it, &right_hilite);\n+\n+        if (left_it == left.end() && right_it == right.end())\n+        {\n+            if (left_hilite != right_hilite)\n+                return false;\n+            if (check_end_without_hilite)\n+                if (left_hilite != DB::IAST::hilite_none)\n+                    throw std::logic_error(\"Expected string ends with a hilite\");\n+            return true;\n+        }\n+\n+        if (left_it == left.end() || right_it == right.end())\n+            return false;\n+\n+        // Lookup one character.\n+        // Check characters match.\n+        if (*left_it != *right_it)\n+            return false;\n+\n+        // Check hilites match if it's not a whitespace.\n+        if (!std::isspace(*left_it) && left_hilite != right_hilite)\n+            return false;\n+\n+        // Consume one character.\n+        left_it++;\n+        right_it++;\n+    }\n+}\n+\n+bool are_equal_with_hilites_and_end_without_hilite(std::string_view left, std::string_view right)\n+{\n+    return are_equal_with_hilites(left, right, true);\n+}\n+\n+\n+}\ndiff --git a/src/Parsers/HiliteComparator/HiliteComparator.h b/src/Parsers/HiliteComparator/HiliteComparator.h\nnew file mode 100644\nindex 000000000000..137c5892b3a7\n--- /dev/null\n+++ b/src/Parsers/HiliteComparator/HiliteComparator.h\n@@ -0,0 +1,48 @@\n+#pragma once\n+\n+#include <Parsers/IAST.h>\n+#include <string>\n+#include <string_view>\n+\n+\n+namespace HiliteComparator\n+{\n+\n+using Hilite = const char *;\n+\n+static const std::vector<Hilite> hilites = {\n+        DB::IAST::hilite_keyword,\n+        DB::IAST::hilite_identifier,\n+        DB::IAST::hilite_function,\n+        DB::IAST::hilite_operator,\n+        DB::IAST::hilite_alias,\n+        DB::IAST::hilite_substitution,\n+        DB::IAST::hilite_none\n+    };\n+\n+/*\n+ * Consume all prefix hilites, by moving `ptr` to\n+ * If `last_hilite` is not `nullptr`, update the last hilite to be the last hilite of the prefix hilites.\n+ */\n+void consume_hilites(const char * & ptr, Hilite * last_hilite = nullptr);\n+\n+String remove_hilites(std::string_view string);\n+\n+/*\n+ * Copies both strings, for the simplicity of the implementation.\n+ */\n+bool are_equal_with_hilites_removed(std::string_view left, std::string_view right);\n+\n+/*\n+ * Hilited queries cannot be compared symbol-by-symbol, as there's some frivolousness introduced with the hilites. Specifically:\n+ * 1. Whitespaces could be hilited with any hilite type.\n+ * 2. Hilite could or could be not reset with hilite_none before the next hilite, i.e. the following strings a and b are equal:\n+ *      a. hilite_keyword foo hilite_none hilite_operator +\n+ *      b. hilite_keyword foo hilite_operator +\n+ */\n+bool are_equal_with_hilites(std::string_view left, std::string_view right, bool check_end_without_hilite);\n+\n+// Google tests's ASSERT_PRED_2 doesn't see overloads with default parameter values.\n+bool are_equal_with_hilites_and_end_without_hilite(std::string_view left, std::string_view right);\n+\n+}\n",
  "test_patch": "diff --git a/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp b/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp\nnew file mode 100644\nindex 000000000000..785e83d09cc8\n--- /dev/null\n+++ b/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp\n@@ -0,0 +1,98 @@\n+#include <gtest/gtest.h>\n+#include <Parsers/IAST.h>\n+#include <Parsers/HiliteComparator/HiliteComparator.h>\n+\n+using namespace HiliteComparator;\n+\n+TEST(HiliteComparator, ConsumeHilites)\n+{\n+    using namespace DB;\n+    // The order is different from the order in HILITES on purpose.\n+    String s;\n+    s += IAST::hilite_keyword;\n+    s += IAST::hilite_alias;\n+    s += IAST::hilite_identifier;\n+    s += IAST::hilite_none;\n+    s += IAST::hilite_operator;\n+    s += IAST::hilite_substitution;\n+    s += IAST::hilite_function;\n+    s += \"test\";\n+    s += IAST::hilite_keyword;\n+    const char * ptr = s.c_str();\n+    const char * expected_ptr = strchr(ptr, 't');\n+    const char * last_hilite = nullptr;\n+    consume_hilites(ptr, &last_hilite);\n+    ASSERT_EQ(expected_ptr, ptr);\n+    ASSERT_TRUE(last_hilite != nullptr);\n+    ASSERT_EQ(IAST::hilite_function, last_hilite);\n+}\n+\n+TEST(HiliteComparator, RemoveHilites)\n+{\n+    using namespace DB;\n+    String s;\n+    s += IAST::hilite_keyword;\n+    s += \"te\";\n+    s += IAST::hilite_alias;\n+    s += IAST::hilite_identifier;\n+    s += \"s\";\n+    s += IAST::hilite_none;\n+    s += \"t\";\n+    s += IAST::hilite_operator;\n+    s += IAST::hilite_substitution;\n+    s += IAST::hilite_function;\n+    ASSERT_EQ(\"test\", remove_hilites(s));\n+}\n+\n+TEST(HiliteComparator, AreEqualWithHilites)\n+{\n+    using namespace DB;\n+    String s = IAST::hilite_keyword;\n+    ASSERT_THROW(are_equal_with_hilites(s, s, true), std::logic_error);\n+    ASSERT_TRUE(are_equal_with_hilites(s, s, false));\n+}\n+\n+TEST(HiliteComparator, AreEqualWithHilitesAndEndWithoutHilite)\n+{\n+    using namespace DB;\n+\n+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, \"\", \"\");\n+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, \"\", IAST::hilite_none);\n+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, IAST::hilite_none, \"\");\n+    ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, IAST::hilite_none, IAST::hilite_none);\n+\n+    {\n+        String s;\n+        s += IAST::hilite_none;\n+        s += \"select\";\n+        s += IAST::hilite_none;\n+        ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, s, \"select\");\n+    }\n+\n+    {\n+        String s;\n+        s += DB::IAST::hilite_none;\n+        s += \"\\n sel\";\n+        s += DB::IAST::hilite_none;\n+        s += \"ect\";\n+        s += DB::IAST::hilite_none;\n+        ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, s, \"\\n select\");\n+    }\n+\n+    {\n+        String left;\n+        left += DB::IAST::hilite_keyword;\n+        left += \"keyword long\";\n+        left += DB::IAST::hilite_none;\n+\n+        String right;\n+        right += DB::IAST::hilite_keyword;\n+        right += \"keyword\";\n+        right += DB::IAST::hilite_none;\n+        right += \" \";\n+        right += DB::IAST::hilite_keyword;\n+        right += \"long\";\n+        right += DB::IAST::hilite_none;\n+        ASSERT_PRED2(are_equal_with_hilites_and_end_without_hilite, left, right);\n+    }\n+}\ndiff --git a/src/Parsers/tests/gtest_format_hiliting.cpp b/src/Parsers/tests/gtest_format_hiliting.cpp\nnew file mode 100644\nindex 000000000000..d0ce8f2c897e\n--- /dev/null\n+++ b/src/Parsers/tests/gtest_format_hiliting.cpp\n@@ -0,0 +1,133 @@\n+#include <unordered_set>\n+\n+#include <Parsers/IAST.h>\n+#include <Parsers/ParserQuery.h>\n+#include <Parsers/parseQuery.h>\n+#include <Parsers/HiliteComparator/HiliteComparator.h>\n+#include <gtest/gtest.h>\n+#include <Common/StackTrace.h>\n+\n+\n+String hilite(const String & s, const char * hilite_type)\n+{\n+    return hilite_type + s + DB::IAST::hilite_none;\n+}\n+\n+String keyword(const String & s)\n+{\n+    return hilite(s, DB::IAST::hilite_keyword);\n+}\n+\n+String identifier(const String & s)\n+{\n+    return hilite(s, DB::IAST::hilite_identifier);\n+}\n+\n+String alias(const String & s)\n+{\n+    return hilite(s, DB::IAST::hilite_alias);\n+}\n+\n+String op(const String & s)\n+{\n+    return hilite(s, DB::IAST::hilite_operator);\n+}\n+\n+String function(const String & s)\n+{\n+    return hilite(s, DB::IAST::hilite_function);\n+}\n+\n+String substitution(const String & s)\n+{\n+    return hilite(s, DB::IAST::hilite_substitution);\n+}\n+\n+\n+void compare(const String & expected, const String & query)\n+{\n+    using namespace DB;\n+    ParserQuery parser(query.data() + query.size());\n+    ASTPtr ast = parseQuery(parser, query, 0, 0);\n+\n+    WriteBufferFromOwnString write_buffer;\n+    IAST::FormatSettings settings(write_buffer, true);\n+    settings.hilite = true;\n+    ast->format(settings);\n+\n+    ASSERT_PRED2(HiliteComparator::are_equal_with_hilites_removed, expected, write_buffer.str());\n+    ASSERT_PRED2(HiliteComparator::are_equal_with_hilites_and_end_without_hilite, expected, write_buffer.str());\n+}\n+\n+const std::vector<std::pair<std::string, std::string>> expected_and_query_pairs = {\n+    // Simple select\n+    {\n+        keyword(\"SELECT \") + \"* \" + keyword(\"FROM \") + identifier(\"table\"),\n+        \"select * from table\"\n+    },\n+\n+    // ASTWithElement\n+    {\n+        keyword(\"WITH \") + alias(\"alias \") + keyword(\"AS \")\n+            + \"(\" + keyword(\"SELECT \") + \"* \" + keyword(\"FROM \") + identifier(\"table\") + \") \"\n+            + keyword(\"SELECT \") + \"* \" + keyword(\"FROM \") + identifier(\"table\"),\n+        \"with alias as (select * from table) select * from table\"\n+    },\n+\n+    // ASTWithAlias\n+    {\n+        keyword(\"SELECT \") + identifier(\"a \") + op(\"+ \") + \"1 \" + keyword(\"AS \") + alias(\"b\") + \", \" + identifier(\"b\"),\n+        \"select a + 1 as b, b\"\n+    },\n+\n+    // ASTFunction\n+    {\n+        keyword(\"SELECT \") + \"* \" + keyword(\"FROM \")\n+            + function(\"view(\") + keyword(\"SELECT \") + \"* \" + keyword(\"FROM \") + identifier(\"table\") + function(\")\"),\n+        \"select * from view(select * from table)\"\n+    },\n+\n+    // ASTDictionaryAttributeDeclaration\n+    {\n+        keyword(\"CREATE DICTIONARY \") + \"name \"\n+            + \"(`Name` \" + function(\"ClickHouseDataType \")\n+            + keyword(\"DEFAULT \") + \"'' \"\n+            + keyword(\"EXPRESSION \") + function(\"rand64() \")\n+            + keyword(\"IS_OBJECT_ID\") + \")\",\n+        \"CREATE DICTIONARY name (`Name` ClickHouseDataType DEFAULT '' EXPRESSION rand64() IS_OBJECT_ID)\"\n+    },\n+\n+    // ASTDictionary, SOURCE keyword\n+    {\n+        keyword(\"CREATE DICTIONARY \") + \"name \"\n+            + \"(`Name` \" + function(\"ClickHouseDataType \")\n+            + keyword(\"DEFAULT \") + \"'' \"\n+            + keyword(\"EXPRESSION \") + function(\"rand64() \")\n+            + keyword(\"IS_OBJECT_ID\") + \") \"\n+            + keyword(\"SOURCE\") + \"(\" + keyword(\"FILE\") + \"(\" + keyword(\"PATH \") + \"'path'))\",\n+        \"CREATE DICTIONARY name (`Name` ClickHouseDataType DEFAULT '' EXPRESSION rand64() IS_OBJECT_ID) \"\n+        \"SOURCE(FILE(PATH 'path'))\"\n+    },\n+\n+    // ASTKillQueryQuery\n+    {\n+        keyword(\"KILL QUERY ON CLUSTER \") + \"clustername \"\n+            + keyword(\"WHERE \") + identifier(\"user \") + op(\"= \") + \"'username' \"\n+            + keyword(\"SYNC\"),\n+        \"KILL QUERY ON CLUSTER clustername WHERE user = 'username' SYNC\"\n+    },\n+\n+    // ASTCreateQuery\n+    {\n+        keyword(\"CREATE TABLE \") + \"name \" + keyword(\"AS (SELECT \") + \"*\" + keyword(\") \")\n+            + keyword(\"COMMENT \") + \"'hello'\",\n+        \"CREATE TABLE name AS (SELECT *) COMMENT 'hello'\"\n+    },\n+};\n+\n+\n+TEST(FormatHiliting, Queries)\n+{\n+    for (const auto & [expected, query] : expected_and_query_pairs)\n+        compare(expected, query);\n+}\n",
  "problem_statement": "clickhouse-format doesn't hilite some identifiers\nHey!\r\n\r\n1. In this query the `identifier` is not hilited \u2014 is it intended behaviour? I think it should either be hilited as an identifier, or an alias.\r\n```\r\n$ ./clickhouse-format --hilite --query \"with identifier as (select * from table) select * from table\"\r\nWITH identifier AS\r\n    (\r\n        SELECT *\r\n        FROM table\r\n    )\r\n```\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Parsers/ASTWithElement.cpp#L21\r\n\r\n![image](https://user-images.githubusercontent.com/5155395/214872393-ab697d98-26a7-45d7-9579-d19071debd43.png)\r\n\r\n2. And also there's another identifier output without being hilited, but I cannot come up with the query which corresponds to this code - any help?\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Parsers/ASTWithAlias.cpp#L23\r\n\r\n3. There seems to be an inconsistensy of manually applied hilite, as it's never removed within this if:\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Parsers/ASTFunction.cpp#L585\n",
  "hints_text": "1. Looks like a bug. Let's highlight.\n2. `clickhouse format --hilite --query \"select a + 1 as b, a + 1 as b\"`.\n3. Also bug\r\n`clickhouse format --hilite --query \"select * from view(select 1 from table group by 1) where 1\"`\r\n![image](https://user-images.githubusercontent.com/4092911/214894166-42d35a02-6314-4e79-acb7-4fe8b41e5a5e.png)\r\nsecond select should not be highlighted \n> 2. `clickhouse format --hilite --query \"select a + 1 as b, a + 1 as b\"`.\r\n![image](https://user-images.githubusercontent.com/5155395/214898670-cb1eabd1-e9fc-426d-b659-1c77b0f8bb37.png)\r\n\r\nThanks! I will hilite the second `b` as an identifier, then.\nAnother bug, as agreed with Nikolai.\r\n\r\nUsing `hilite_none` when it doesn't do anything. Not visible to user.\r\nhttps://github.com/ClickHouse/ClickHouse/blob/master/src/Parsers/ASTSystemQuery.cpp#L203",
  "created_at": "2023-03-15T11:55:39Z",
  "modified_files": [
    "src/CMakeLists.txt",
    "src/Parsers/ASTCreateQuery.cpp",
    "src/Parsers/ASTDictionary.cpp",
    "src/Parsers/ASTDictionaryAttributeDeclaration.cpp",
    "src/Parsers/ASTFunction.cpp",
    "src/Parsers/ASTKillQueryQuery.cpp",
    "src/Parsers/ASTWithAlias.cpp",
    "src/Parsers/ASTWithElement.cpp",
    "src/Parsers/CMakeLists.txt",
    "b/src/Parsers/HiliteComparator/CMakeLists.txt",
    "b/src/Parsers/HiliteComparator/HiliteComparator.cpp",
    "b/src/Parsers/HiliteComparator/HiliteComparator.h"
  ],
  "modified_test_files": [
    "b/src/Parsers/HiliteComparator/tests/gtest_hilite_comparator.cpp",
    "b/src/Parsers/tests/gtest_format_hiliting.cpp"
  ]
}