{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 50531,
  "instance_id": "ClickHouse__ClickHouse-50531",
  "issue_numbers": [
    "50323",
    "48272"
  ],
  "base_commit": "959f66eb8a7611101c98d69dfbae61eda4c7476d",
  "patch": "diff --git a/base/base/find_symbols.h b/base/base/find_symbols.h\nindex a8747ecc9b70..83232669c047 100644\n--- a/base/base/find_symbols.h\n+++ b/base/base/find_symbols.h\n@@ -2,6 +2,7 @@\n \n #include <cstdint>\n #include <string>\n+#include <array>\n \n #if defined(__SSE2__)\n     #include <emmintrin.h>\ndiff --git a/programs/copier/ShardPartitionPiece.h b/programs/copier/ShardPartitionPiece.h\nindex aba378d466d9..453364c0fc80 100644\n--- a/programs/copier/ShardPartitionPiece.h\n+++ b/programs/copier/ShardPartitionPiece.h\n@@ -2,6 +2,8 @@\n \n #include <base/types.h>\n \n+#include <vector>\n+\n namespace DB\n {\n \ndiff --git a/src/Access/Common/AccessFlags.h b/src/Access/Common/AccessFlags.h\nindex 270ee1c0045c..c9672da7d926 100644\n--- a/src/Access/Common/AccessFlags.h\n+++ b/src/Access/Common/AccessFlags.h\n@@ -4,6 +4,7 @@\n #include <bitset>\n #include <cstring>\n #include <vector>\n+#include <unordered_map>\n \n \n namespace DB\ndiff --git a/src/AggregateFunctions/AggregateFunctionAvg.h b/src/AggregateFunctions/AggregateFunctionAvg.h\nindex a86c7d042fc3..37f20fca01c8 100644\n--- a/src/AggregateFunctions/AggregateFunctionAvg.h\n+++ b/src/AggregateFunctions/AggregateFunctionAvg.h\n@@ -146,8 +146,8 @@ class AggregateFunctionAvgBase : public\n         for (const auto & argument : this->argument_types)\n             can_be_compiled &= canBeNativeType(*argument);\n \n-        auto return_type = this->getResultType();\n-        can_be_compiled &= canBeNativeType(*return_type);\n+        const auto & result_type = this->getResultType();\n+        can_be_compiled &= canBeNativeType(*result_type);\n \n         return can_be_compiled;\n     }\n@@ -198,8 +198,8 @@ class AggregateFunctionAvgBase : public\n         auto * denominator_ptr = b.CreateConstGEP1_32(b.getInt8Ty(), aggregate_data_ptr, denominator_offset);\n         auto * denominator_value = b.CreateLoad(denominator_type, denominator_ptr);\n \n-        auto * double_numerator = nativeCast<Numerator>(b, numerator_value, b.getDoubleTy());\n-        auto * double_denominator = nativeCast<Denominator>(b, denominator_value, b.getDoubleTy());\n+        auto * double_numerator = nativeCast<Numerator>(b, numerator_value, this->getResultType());\n+        auto * double_denominator = nativeCast<Denominator>(b, denominator_value, this->getResultType());\n \n         return b.CreateFDiv(double_numerator, double_denominator);\n     }\n@@ -308,7 +308,7 @@ class AggregateFunctionAvg : public AggregateFunctionAvgBase<AvgFieldType<T>, UI\n \n #if USE_EMBEDDED_COMPILER\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n@@ -316,7 +316,7 @@ class AggregateFunctionAvg : public AggregateFunctionAvgBase<AvgFieldType<T>, UI\n \n         auto * numerator_ptr = aggregate_data_ptr;\n         auto * numerator_value = b.CreateLoad(numerator_type, numerator_ptr);\n-        auto * value_cast_to_numerator = nativeCast(b, arguments_types[0], argument_values[0], numerator_type);\n+        auto * value_cast_to_numerator = nativeCast(b, arguments[0], toNativeDataType<Numerator>());\n         auto * numerator_result_value = numerator_type->isIntegerTy() ? b.CreateAdd(numerator_value, value_cast_to_numerator) : b.CreateFAdd(numerator_value, value_cast_to_numerator);\n         b.CreateStore(numerator_result_value, numerator_ptr);\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionAvgWeighted.h b/src/AggregateFunctions/AggregateFunctionAvgWeighted.h\nindex bc3e3a32a716..5a3869032cad 100644\n--- a/src/AggregateFunctions/AggregateFunctionAvgWeighted.h\n+++ b/src/AggregateFunctions/AggregateFunctionAvgWeighted.h\n@@ -30,7 +30,7 @@ class AggregateFunctionAvgWeighted final :\n \n     using Numerator = typename Base::Numerator;\n     using Denominator = typename Base::Denominator;\n-     using Fraction = typename Base::Fraction;\n+    using Fraction = typename Base::Fraction;\n \n     void NO_SANITIZE_UNDEFINED add(AggregateDataPtr __restrict place, const IColumn ** columns, size_t row_num, Arena *) const override\n     {\n@@ -55,7 +55,7 @@ class AggregateFunctionAvgWeighted final :\n         return can_be_compiled;\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n@@ -63,8 +63,9 @@ class AggregateFunctionAvgWeighted final :\n         auto * numerator_ptr = aggregate_data_ptr;\n         auto * numerator_value = b.CreateLoad(numerator_type, numerator_ptr);\n \n-        auto * argument = nativeCast(b, arguments_types[0], argument_values[0], numerator_type);\n-        auto * weight = nativeCast(b, arguments_types[1], argument_values[1], numerator_type);\n+        auto numerator_data_type = toNativeDataType<Numerator>();\n+        auto * argument = nativeCast(b, arguments[0], numerator_data_type);\n+        auto * weight = nativeCast(b, arguments[1], numerator_data_type);\n \n         llvm::Value * value_weight_multiplication = argument->getType()->isIntegerTy() ? b.CreateMul(argument, weight) : b.CreateFMul(argument, weight);\n         auto * numerator_result_value = numerator_type->isIntegerTy() ? b.CreateAdd(numerator_value, value_weight_multiplication) : b.CreateFAdd(numerator_value, value_weight_multiplication);\n@@ -75,7 +76,7 @@ class AggregateFunctionAvgWeighted final :\n         static constexpr size_t denominator_offset = offsetof(Fraction, denominator);\n         auto * denominator_ptr = b.CreateConstInBoundsGEP1_64(b.getInt8Ty(), aggregate_data_ptr, denominator_offset);\n \n-        auto * weight_cast_to_denominator = nativeCast(b, arguments_types[1], argument_values[1], denominator_type);\n+        auto * weight_cast_to_denominator = nativeCast(b, arguments[1], toNativeDataType<Denominator>());\n \n         auto * denominator_value = b.CreateLoad(denominator_type, denominator_ptr);\n         auto * denominator_value_updated = denominator_type->isIntegerTy() ? b.CreateAdd(denominator_value, weight_cast_to_denominator) : b.CreateFAdd(denominator_value, weight_cast_to_denominator);\ndiff --git a/src/AggregateFunctions/AggregateFunctionBitwise.h b/src/AggregateFunctions/AggregateFunctionBitwise.h\nindex 6c94a72bf32e..71479b309c7c 100644\n--- a/src/AggregateFunctions/AggregateFunctionBitwise.h\n+++ b/src/AggregateFunctions/AggregateFunctionBitwise.h\n@@ -148,7 +148,7 @@ class AggregateFunctionBitwise final : public IAggregateFunctionDataHelper<Data,\n         Data::compileCreate(builder, value_ptr);\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes &, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n@@ -157,8 +157,7 @@ class AggregateFunctionBitwise final : public IAggregateFunctionDataHelper<Data,\n         auto * value_ptr = aggregate_data_ptr;\n         auto * value = b.CreateLoad(return_type, value_ptr);\n \n-        const auto & argument_value = argument_values[0];\n-        auto * result_value = Data::compileUpdate(builder, value, argument_value);\n+        auto * result_value = Data::compileUpdate(builder, value, arguments[0].value);\n \n         b.CreateStore(result_value, value_ptr);\n     }\ndiff --git a/src/AggregateFunctions/AggregateFunctionCount.h b/src/AggregateFunctions/AggregateFunctionCount.h\nindex 848a8a4b6035..77d3bfeb448a 100644\n--- a/src/AggregateFunctions/AggregateFunctionCount.h\n+++ b/src/AggregateFunctions/AggregateFunctionCount.h\n@@ -165,7 +165,7 @@ class AggregateFunctionCount final : public IAggregateFunctionDataHelper<Aggrega\n         b.CreateMemSet(aggregate_data_ptr, llvm::ConstantInt::get(b.getInt8Ty(), 0), sizeof(AggregateFunctionCountData), llvm::assumeAligned(this->alignOfData()));\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes &, const std::vector<llvm::Value *> &) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType &) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n@@ -309,13 +309,13 @@ class AggregateFunctionCountNotNullUnary final\n         b.CreateMemSet(aggregate_data_ptr, llvm::ConstantInt::get(b.getInt8Ty(), 0), sizeof(AggregateFunctionCountData), llvm::assumeAligned(this->alignOfData()));\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes &, const std::vector<llvm::Value *> & values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n         auto * return_type = toNativeType(b, this->getResultType());\n \n-        auto * is_null_value = b.CreateExtractValue(values[0], {1});\n+        auto * is_null_value = b.CreateExtractValue(arguments[0].value, {1});\n         auto * increment_value = b.CreateSelect(is_null_value, llvm::ConstantInt::get(return_type, 0), llvm::ConstantInt::get(return_type, 1));\n \n         auto * count_value_ptr = aggregate_data_ptr;\ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.cpp b/src/AggregateFunctions/AggregateFunctionIf.cpp\nindex 20bdb32796a9..87fa82395079 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.cpp\n+++ b/src/AggregateFunctions/AggregateFunctionIf.cpp\n@@ -188,18 +188,18 @@ class AggregateFunctionIfNullUnary final\n         return canBeNativeType(*this->argument_types.back()) && this->nested_function->isCompilable();\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-        const auto & nullable_type = arguments_types[0];\n-        const auto & nullable_value = argument_values[0];\n+        const auto & nullable_type = arguments[0].type;\n+        const auto & nullable_value = arguments[0].value;\n \n         auto * wrapped_value = b.CreateExtractValue(nullable_value, {0});\n         auto * is_null_value = b.CreateExtractValue(nullable_value, {1});\n \n-        const auto & predicate_type = arguments_types[argument_values.size() - 1];\n-        auto * predicate_value = argument_values[argument_values.size() - 1];\n+        const auto & predicate_type = arguments.back().type;\n+        auto * predicate_value = arguments.back().value;\n         auto * is_predicate_true = nativeBoolCast(b, predicate_type, predicate_value);\n \n         auto * head = b.GetInsertBlock();\n@@ -219,7 +219,7 @@ class AggregateFunctionIfNullUnary final\n             b.CreateStore(llvm::ConstantInt::get(b.getInt8Ty(), 1), aggregate_data_ptr);\n \n         auto * aggregate_data_ptr_with_prefix_size_offset = b.CreateConstInBoundsGEP1_64(b.getInt8Ty(), aggregate_data_ptr, this->prefix_size);\n-        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, { removeNullable(nullable_type) }, { wrapped_value });\n+        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, { ValueWithType(wrapped_value, removeNullable(nullable_type)) });\n         b.CreateBr(join_block);\n \n         b.SetInsertPoint(join_block);\n@@ -370,38 +370,31 @@ class AggregateFunctionIfNullVariadic final : public AggregateFunctionNullBase<\n         return canBeNativeType(*this->argument_types.back()) && this->nested_function->isCompilable();\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n-        /// TODO: Check\n-\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-        size_t arguments_size = arguments_types.size();\n+        size_t arguments_size = arguments.size();\n \n-        DataTypes non_nullable_types;\n-        std::vector<llvm::Value * > wrapped_values;\n-        std::vector<llvm::Value * > is_null_values;\n+        ValuesWithType wrapped_arguments;\n+        wrapped_arguments.reserve(arguments_size);\n \n-        non_nullable_types.resize(arguments_size);\n-        wrapped_values.resize(arguments_size);\n-        is_null_values.resize(arguments_size);\n+        std::vector<llvm::Value * > is_null_values;\n \n         for (size_t i = 0; i < arguments_size; ++i)\n         {\n-            const auto & argument_value = argument_values[i];\n+            const auto & argument_value = arguments[i].value;\n+            const auto & argument_type = arguments[i].type;\n \n             if (is_nullable[i])\n             {\n                 auto * wrapped_value = b.CreateExtractValue(argument_value, {0});\n-                is_null_values[i] = b.CreateExtractValue(argument_value, {1});\n-\n-                wrapped_values[i] = wrapped_value;\n-                non_nullable_types[i] = removeNullable(arguments_types[i]);\n+                is_null_values.emplace_back(b.CreateExtractValue(argument_value, {1}));\n+                wrapped_arguments.emplace_back(wrapped_value, removeNullable(argument_type));\n             }\n             else\n             {\n-                wrapped_values[i] = argument_value;\n-                non_nullable_types[i] = arguments_types[i];\n+                wrapped_arguments.emplace_back(argument_value, argument_type);\n             }\n         }\n \n@@ -415,9 +408,6 @@ class AggregateFunctionIfNullVariadic final : public AggregateFunctionNullBase<\n \n         for (auto * is_null_value : is_null_values)\n         {\n-            if (!is_null_value)\n-                continue;\n-\n             auto * values_have_null = b.CreateLoad(b.getInt1Ty(), values_have_null_ptr);\n             b.CreateStore(b.CreateOr(values_have_null, is_null_value), values_have_null_ptr);\n         }\n@@ -426,8 +416,8 @@ class AggregateFunctionIfNullVariadic final : public AggregateFunctionNullBase<\n \n         b.SetInsertPoint(join_block_after_null_checks);\n \n-        const auto & predicate_type = arguments_types[argument_values.size() - 1];\n-        auto * predicate_value = argument_values[argument_values.size() - 1];\n+        const auto & predicate_type = arguments.back().type;\n+        auto * predicate_value = arguments.back().value;\n         auto * is_predicate_true = nativeBoolCast(b, predicate_type, predicate_value);\n \n         auto * if_true = llvm::BasicBlock::Create(head->getContext(), \"if_true\", head->getParent());\n@@ -444,7 +434,7 @@ class AggregateFunctionIfNullVariadic final : public AggregateFunctionNullBase<\n             b.CreateStore(llvm::ConstantInt::get(b.getInt8Ty(), 1), aggregate_data_ptr);\n \n         auto * aggregate_data_ptr_with_prefix_size_offset = b.CreateConstInBoundsGEP1_64(b.getInt8Ty(), aggregate_data_ptr, this->prefix_size);\n-        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, non_nullable_types, wrapped_values);\n+        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, wrapped_arguments);\n         b.CreateBr(join_block);\n \n         b.SetInsertPoint(join_block);\ndiff --git a/src/AggregateFunctions/AggregateFunctionIf.h b/src/AggregateFunctions/AggregateFunctionIf.h\nindex cd7d7e27a250..afab861e2020 100644\n--- a/src/AggregateFunctions/AggregateFunctionIf.h\n+++ b/src/AggregateFunctions/AggregateFunctionIf.h\n@@ -223,12 +223,12 @@ class AggregateFunctionIf final : public IAggregateFunctionHelper<AggregateFunct\n         nested_func->compileCreate(builder, aggregate_data_ptr);\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-        const auto & predicate_type = arguments_types[argument_values.size() - 1];\n-        auto * predicate_value = argument_values[argument_values.size() - 1];\n+        const auto & predicate_type = arguments.back().type;\n+        auto * predicate_value = arguments.back().value;\n \n         auto * head = b.GetInsertBlock();\n \n@@ -242,21 +242,9 @@ class AggregateFunctionIf final : public IAggregateFunctionHelper<AggregateFunct\n \n         b.SetInsertPoint(if_true);\n \n-        size_t arguments_size_without_predicate = arguments_types.size() - 1;\n-\n-        DataTypes argument_types_without_predicate;\n-        std::vector<llvm::Value *> argument_values_without_predicate;\n-\n-        argument_types_without_predicate.resize(arguments_size_without_predicate);\n-        argument_values_without_predicate.resize(arguments_size_without_predicate);\n-\n-        for (size_t i = 0; i < arguments_size_without_predicate; ++i)\n-        {\n-            argument_types_without_predicate[i] = arguments_types[i];\n-            argument_values_without_predicate[i] = argument_values[i];\n-        }\n-\n-        nested_func->compileAdd(builder, aggregate_data_ptr, argument_types_without_predicate, argument_values_without_predicate);\n+        ValuesWithType arguments_without_predicate = arguments;\n+        arguments_without_predicate.pop_back();\n+        nested_func->compileAdd(builder, aggregate_data_ptr, arguments_without_predicate);\n \n         b.CreateBr(join_block);\n \ndiff --git a/src/AggregateFunctions/AggregateFunctionMinMaxAny.h b/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\nindex 94c0d60be81e..5312df32459f 100644\n--- a/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\n+++ b/src/AggregateFunctions/AggregateFunctionMinMaxAny.h\n@@ -1459,11 +1459,11 @@ class AggregateFunctionsSingleValue final : public IAggregateFunctionDataHelper<\n         b.CreateMemSet(aggregate_data_ptr, llvm::ConstantInt::get(b.getInt8Ty(), 0), this->sizeOfData(), llvm::assumeAligned(this->alignOfData()));\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes &, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         if constexpr (Data::is_compilable)\n         {\n-            Data::compileChangeIfBetter(builder, aggregate_data_ptr, argument_values[0]);\n+            Data::compileChangeIfBetter(builder, aggregate_data_ptr, arguments[0].value);\n         }\n         else\n         {\ndiff --git a/src/AggregateFunctions/AggregateFunctionNull.h b/src/AggregateFunctions/AggregateFunctionNull.h\nindex de7b190c9499..6b6580bf4c4a 100644\n--- a/src/AggregateFunctions/AggregateFunctionNull.h\n+++ b/src/AggregateFunctions/AggregateFunctionNull.h\n@@ -378,12 +378,12 @@ class AggregateFunctionNullUnary final\n \n #if USE_EMBEDDED_COMPILER\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-        const auto & nullable_type = arguments_types[0];\n-        const auto & nullable_value = argument_values[0];\n+        const auto & nullable_type = arguments[0].type;\n+        const auto & nullable_value = arguments[0].value;\n \n         auto * wrapped_value = b.CreateExtractValue(nullable_value, {0});\n         auto * is_null_value = b.CreateExtractValue(nullable_value, {1});\n@@ -405,7 +405,7 @@ class AggregateFunctionNullUnary final\n             b.CreateStore(llvm::ConstantInt::get(b.getInt8Ty(), 1), aggregate_data_ptr);\n \n         auto * aggregate_data_ptr_with_prefix_size_offset = b.CreateConstInBoundsGEP1_64(b.getInt8Ty(), aggregate_data_ptr, this->prefix_size);\n-        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, { removeNullable(nullable_type) }, { wrapped_value });\n+        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, { ValueWithType(wrapped_value, removeNullable(nullable_type)) });\n         b.CreateBr(join_block);\n \n         b.SetInsertPoint(join_block);\n@@ -568,36 +568,32 @@ class AggregateFunctionNullVariadic final : public AggregateFunctionNullBase<\n \n #if USE_EMBEDDED_COMPILER\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-        size_t arguments_size = arguments_types.size();\n+        size_t arguments_size = arguments.size();\n \n-        DataTypes non_nullable_types;\n-        std::vector<llvm::Value * > wrapped_values;\n-        std::vector<llvm::Value * > is_null_values;\n+        ValuesWithType wrapped_arguments;\n+        wrapped_arguments.reserve(arguments_size);\n \n-        non_nullable_types.resize(arguments_size);\n-        wrapped_values.resize(arguments_size);\n-        is_null_values.resize(arguments_size);\n+        std::vector<llvm::Value *> is_null_values;\n+        is_null_values.reserve(arguments_size);\n \n         for (size_t i = 0; i < arguments_size; ++i)\n         {\n-            const auto & argument_value = argument_values[i];\n+            const auto & argument_value = arguments[i].value;\n+            const auto & argument_type = arguments[i].type;\n \n             if (is_nullable[i])\n             {\n                 auto * wrapped_value = b.CreateExtractValue(argument_value, {0});\n-                is_null_values[i] = b.CreateExtractValue(argument_value, {1});\n-\n-                wrapped_values[i] = wrapped_value;\n-                non_nullable_types[i] = removeNullable(arguments_types[i]);\n+                is_null_values.emplace_back(b.CreateExtractValue(argument_value, {1}));\n+                wrapped_arguments.emplace_back(wrapped_value, removeNullable(argument_type));\n             }\n             else\n             {\n-                wrapped_values[i] = argument_value;\n-                non_nullable_types[i] = arguments_types[i];\n+                wrapped_arguments.emplace_back(argument_value, argument_type);\n             }\n         }\n \n@@ -612,9 +608,6 @@ class AggregateFunctionNullVariadic final : public AggregateFunctionNullBase<\n \n         for (auto * is_null_value : is_null_values)\n         {\n-            if (!is_null_value)\n-                continue;\n-\n             auto * values_have_null = b.CreateLoad(b.getInt1Ty(), values_have_null_ptr);\n             b.CreateStore(b.CreateOr(values_have_null, is_null_value), values_have_null_ptr);\n         }\n@@ -630,7 +623,7 @@ class AggregateFunctionNullVariadic final : public AggregateFunctionNullBase<\n             b.CreateStore(llvm::ConstantInt::get(b.getInt8Ty(), 1), aggregate_data_ptr);\n \n         auto * aggregate_data_ptr_with_prefix_size_offset = b.CreateConstInBoundsGEP1_64(b.getInt8Ty(), aggregate_data_ptr, this->prefix_size);\n-        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, arguments_types, wrapped_values);\n+        this->nested_function->compileAdd(b, aggregate_data_ptr_with_prefix_size_offset, wrapped_arguments);\n         b.CreateBr(join_block);\n \n         b.SetInsertPoint(join_block);\ndiff --git a/src/AggregateFunctions/AggregateFunctionSum.h b/src/AggregateFunctions/AggregateFunctionSum.h\nindex f77d1dae36fa..bb0804c14b32 100644\n--- a/src/AggregateFunctions/AggregateFunctionSum.h\n+++ b/src/AggregateFunctions/AggregateFunctionSum.h\n@@ -588,7 +588,7 @@ class AggregateFunctionSum final : public IAggregateFunctionDataHelper<Data, Agg\n         b.CreateStore(llvm::Constant::getNullValue(return_type), aggregate_sum_ptr);\n     }\n \n-    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const DataTypes & arguments_types, const std::vector<llvm::Value *> & argument_values) const override\n+    void compileAdd(llvm::IRBuilderBase & builder, llvm::Value * aggregate_data_ptr, const ValuesWithType & arguments) const override\n     {\n         llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n@@ -597,10 +597,7 @@ class AggregateFunctionSum final : public IAggregateFunctionDataHelper<Data, Agg\n         auto * sum_value_ptr = aggregate_data_ptr;\n         auto * sum_value = b.CreateLoad(return_type, sum_value_ptr);\n \n-        const auto & argument_type = arguments_types[0];\n-        const auto & argument_value = argument_values[0];\n-\n-        auto * value_cast_to_result = nativeCast(b, argument_type, argument_value, return_type);\n+        auto * value_cast_to_result = nativeCast(b, arguments[0], this->getResultType());\n         auto * sum_result_value = sum_value->getType()->isIntegerTy() ? b.CreateAdd(sum_value, value_cast_to_result) : b.CreateFAdd(sum_value, value_cast_to_result);\n \n         b.CreateStore(sum_result_value, sum_value_ptr);\ndiff --git a/src/AggregateFunctions/IAggregateFunction.h b/src/AggregateFunctions/IAggregateFunction.h\nindex ddc0535d0e4a..df08b6f21096 100644\n--- a/src/AggregateFunctions/IAggregateFunction.h\n+++ b/src/AggregateFunctions/IAggregateFunction.h\n@@ -6,6 +6,7 @@\n #include <Core/Block.h>\n #include <Core/ColumnNumbers.h>\n #include <Core/Field.h>\n+#include <Core/ValuesWithType.h>\n #include <Interpreters/Context_fwd.h>\n #include <base/types.h>\n #include <Common/Exception.h>\n@@ -389,7 +390,7 @@ class IAggregateFunction : public std::enable_shared_from_this<IAggregateFunctio\n     }\n \n     /// compileAdd should generate code for updating aggregate function state stored in aggregate_data_ptr\n-    virtual void compileAdd(llvm::IRBuilderBase & /*builder*/, llvm::Value * /*aggregate_data_ptr*/, const DataTypes & /*arguments_types*/, const std::vector<llvm::Value *> & /*arguments_values*/) const\n+    virtual void compileAdd(llvm::IRBuilderBase & /*builder*/, llvm::Value * /*aggregate_data_ptr*/, const ValuesWithType & /*arguments*/) const\n     {\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"{} is not JIT-compilable\", getName());\n     }\ndiff --git a/src/Common/assertProcessUserMatchesDataOwner.h b/src/Common/assertProcessUserMatchesDataOwner.h\nindex b31d795da71f..7a6c5d363350 100644\n--- a/src/Common/assertProcessUserMatchesDataOwner.h\n+++ b/src/Common/assertProcessUserMatchesDataOwner.h\n@@ -1,5 +1,7 @@\n #pragma once\n+\n #include <string>\n+#include <functional>\n \n namespace DB\n {\ndiff --git a/src/Core/QualifiedTableName.h b/src/Core/QualifiedTableName.h\nindex 3310130629dc..bf05bd59caf7 100644\n--- a/src/Core/QualifiedTableName.h\n+++ b/src/Core/QualifiedTableName.h\n@@ -127,7 +127,7 @@ namespace fmt\n         template <typename FormatContext>\n         auto format(const DB::QualifiedTableName & name, FormatContext & ctx)\n         {\n-            return format_to(ctx.out(), \"{}.{}\", DB::backQuoteIfNeed(name.database), DB::backQuoteIfNeed(name.table));\n+            return fmt::format_to(ctx.out(), \"{}.{}\", DB::backQuoteIfNeed(name.database), DB::backQuoteIfNeed(name.table));\n         }\n     };\n }\ndiff --git a/src/Core/ValueWithType.h b/src/Core/ValueWithType.h\nnew file mode 100644\nindex 000000000000..b5f61a1c5f7f\n--- /dev/null\n+++ b/src/Core/ValueWithType.h\n@@ -0,0 +1,26 @@\n+#pragma once\n+\n+#include <DataTypes/IDataType.h>\n+\n+namespace llvm\n+{\n+    class Value;\n+}\n+\n+namespace DB\n+{\n+\n+/// LLVM value with its data type\n+struct ValueWithType\n+{\n+    llvm::Value * value = nullptr;\n+    DataTypePtr type;\n+\n+    ValueWithType() = default;\n+    ValueWithType(llvm::Value * value_, DataTypePtr type_)\n+        : value(value_)\n+        , type(std::move(type_))\n+    {}\n+};\n+\n+}\ndiff --git a/src/Core/ValuesWithType.h b/src/Core/ValuesWithType.h\nnew file mode 100644\nindex 000000000000..920604191979\n--- /dev/null\n+++ b/src/Core/ValuesWithType.h\n@@ -0,0 +1,13 @@\n+#pragma once\n+\n+#include <vector>\n+\n+#include <Core/ValueWithType.h>\n+\n+\n+namespace DB\n+{\n+\n+using ValuesWithType = std::vector<ValueWithType>;\n+\n+}\ndiff --git a/src/DataTypes/IDataType.h b/src/DataTypes/IDataType.h\nindex 7cc18fea00c4..7a705e8fd190 100644\n--- a/src/DataTypes/IDataType.h\n+++ b/src/DataTypes/IDataType.h\n@@ -532,11 +532,6 @@ inline bool isNotDecimalButComparableToDecimal(const DataTypePtr & data_type)\n     return which.isInt() || which.isUInt() || which.isFloat();\n }\n \n-inline bool isCompilableType(const DataTypePtr & data_type)\n-{\n-    return data_type->isValueRepresentedByNumber() && !isDecimal(data_type);\n-}\n-\n inline bool isBool(const DataTypePtr & data_type)\n {\n     return data_type->getName() == \"Bool\";\ndiff --git a/src/DataTypes/Native.cpp b/src/DataTypes/Native.cpp\nnew file mode 100644\nindex 000000000000..6f1ea851dce8\n--- /dev/null\n+++ b/src/DataTypes/Native.cpp\n@@ -0,0 +1,200 @@\n+#include <DataTypes/Native.h>\n+\n+#if USE_EMBEDDED_COMPILER\n+#    include <DataTypes/DataTypeNullable.h>\n+#    include <Columns/ColumnConst.h>\n+#    include <Columns/ColumnNullable.h>\n+\n+\n+namespace DB\n+{\n+\n+namespace ErrorCodes\n+{\n+    extern const int NOT_IMPLEMENTED;\n+    extern const int LOGICAL_ERROR;\n+}\n+\n+bool typeIsSigned(const IDataType & type)\n+{\n+    WhichDataType data_type(type);\n+    return data_type.isNativeInt() || data_type.isFloat() || data_type.isEnum() || data_type.isDate32();\n+}\n+\n+llvm::Type * toNullableType(llvm::IRBuilderBase & builder, llvm::Type * type)\n+{\n+    auto * is_null_type = builder.getInt1Ty();\n+    return llvm::StructType::get(type, is_null_type);\n+}\n+\n+bool canBeNativeType(const IDataType & type)\n+{\n+    WhichDataType data_type(type);\n+\n+    if (data_type.isNullable())\n+    {\n+        const auto & data_type_nullable = static_cast<const DataTypeNullable&>(type);\n+        return canBeNativeType(*data_type_nullable.getNestedType());\n+    }\n+\n+    return data_type.isNativeInt() || data_type.isNativeUInt() || data_type.isFloat() || data_type.isDate()\n+        || data_type.isDate32() || data_type.isDateTime() || data_type.isEnum();\n+}\n+\n+bool canBeNativeType(const DataTypePtr & type)\n+{\n+    return canBeNativeType(*type);\n+}\n+\n+llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const IDataType & type)\n+{\n+    WhichDataType data_type(type);\n+\n+    if (data_type.isNullable())\n+    {\n+        const auto & data_type_nullable = static_cast<const DataTypeNullable&>(type);\n+        auto * nested_type = toNativeType(builder, *data_type_nullable.getNestedType());\n+        return toNullableType(builder, nested_type);\n+    }\n+\n+    /// LLVM doesn't have unsigned types, it has unsigned instructions.\n+    if (data_type.isInt8() || data_type.isUInt8())\n+        return builder.getInt8Ty();\n+    else if (data_type.isInt16() || data_type.isUInt16() || data_type.isDate())\n+        return builder.getInt16Ty();\n+    else if (data_type.isInt32() || data_type.isUInt32() || data_type.isDate32() || data_type.isDateTime())\n+        return builder.getInt32Ty();\n+    else if (data_type.isInt64() || data_type.isUInt64())\n+        return builder.getInt64Ty();\n+    else if (data_type.isFloat32())\n+        return builder.getFloatTy();\n+    else if (data_type.isFloat64())\n+        return builder.getDoubleTy();\n+    else if (data_type.isEnum8())\n+        return builder.getInt8Ty();\n+    else if (data_type.isEnum16())\n+        return builder.getInt16Ty();\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid cast to native type\");\n+}\n+\n+llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const DataTypePtr & type)\n+{\n+    return toNativeType(builder, *type);\n+}\n+\n+llvm::Value * nativeBoolCast(llvm::IRBuilderBase & b, const DataTypePtr & from_type, llvm::Value * value)\n+{\n+    if (from_type->isNullable())\n+    {\n+        auto * inner = nativeBoolCast(b, removeNullable(from_type), b.CreateExtractValue(value, {0}));\n+        return b.CreateAnd(b.CreateNot(b.CreateExtractValue(value, {1})), inner);\n+    }\n+\n+    auto * zero = llvm::Constant::getNullValue(value->getType());\n+\n+    if (value->getType()->isIntegerTy())\n+        return b.CreateICmpNE(value, zero);\n+    else if (value->getType()->isFloatingPointTy())\n+        return b.CreateFCmpUNE(value, zero);\n+\n+    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot cast non-number {} to bool\", from_type->getName());\n+}\n+\n+llvm::Value * nativeBoolCast(llvm::IRBuilderBase & b, const ValueWithType & value_with_type)\n+{\n+    return nativeBoolCast(b, value_with_type.type, value_with_type.value);\n+}\n+\n+llvm::Value * nativeCast(llvm::IRBuilderBase & b, const DataTypePtr & from_type, llvm::Value * value, const DataTypePtr & to_type)\n+{\n+    if (from_type->equals(*to_type))\n+    {\n+        return value;\n+    }\n+    else if (from_type->isNullable() && to_type->isNullable())\n+    {\n+        auto * inner = nativeCast(b, removeNullable(from_type), b.CreateExtractValue(value, {0}), to_type);\n+        return b.CreateInsertValue(inner, b.CreateExtractValue(value, {1}), {1});\n+    }\n+    else if (from_type->isNullable())\n+    {\n+        return nativeCast(b, removeNullable(from_type), b.CreateExtractValue(value, {0}), to_type);\n+    }\n+    else if (to_type->isNullable())\n+    {\n+        auto * from_native_type = toNativeType(b, from_type);\n+        auto * inner = nativeCast(b, from_type, value, removeNullable(to_type));\n+        return b.CreateInsertValue(llvm::Constant::getNullValue(from_native_type), inner, {0});\n+    }\n+    else\n+    {\n+        auto * from_native_type = toNativeType(b, from_type);\n+        auto * to_native_type = toNativeType(b, to_type);\n+\n+        if (from_native_type == to_native_type)\n+            return value;\n+        else if (from_native_type->isIntegerTy() && to_native_type->isFloatingPointTy())\n+            return typeIsSigned(*from_type) ? b.CreateSIToFP(value, to_native_type) : b.CreateUIToFP(value, to_native_type);\n+        else if (from_native_type->isFloatingPointTy() && to_native_type->isIntegerTy())\n+            return typeIsSigned(*to_type) ? b.CreateFPToSI(value, to_native_type) : b.CreateFPToUI(value, to_native_type);\n+        else if (from_native_type->isIntegerTy() && from_native_type->isIntegerTy())\n+            return b.CreateIntCast(value, to_native_type, typeIsSigned(*from_type));\n+        else if (to_native_type->isFloatingPointTy() && to_native_type->isFloatingPointTy())\n+            return b.CreateFPCast(value, to_native_type);\n+    }\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR,\n+        \"Invalid cast to native value from type {} to type {}\",\n+        from_type->getName(),\n+        to_type->getName());\n+}\n+\n+llvm::Value * nativeCast(llvm::IRBuilderBase & b, const ValueWithType & value, const DataTypePtr & to_type)\n+{\n+    return nativeCast(b, value.type, value.value, to_type);\n+}\n+\n+llvm::Constant * getColumnNativeValue(llvm::IRBuilderBase & builder, const DataTypePtr & column_type, const IColumn & column, size_t index)\n+{\n+    if (const auto * constant = typeid_cast<const ColumnConst *>(&column))\n+        return getColumnNativeValue(builder, column_type, constant->getDataColumn(), 0);\n+\n+    auto * type = toNativeType(builder, column_type);\n+\n+    WhichDataType column_data_type(column_type);\n+    if (column_data_type.isNullable())\n+    {\n+        const auto & nullable_data_type = assert_cast<const DataTypeNullable &>(*column_type);\n+        const auto & nullable_column = assert_cast<const ColumnNullable &>(column);\n+\n+        auto * value = getColumnNativeValue(builder, nullable_data_type.getNestedType(), nullable_column.getNestedColumn(), index);\n+        auto * is_null = llvm::ConstantInt::get(type->getContainedType(1), nullable_column.isNullAt(index));\n+\n+        return llvm::ConstantStruct::get(static_cast<llvm::StructType *>(type), value, is_null);\n+    }\n+    else if (column_data_type.isFloat32())\n+    {\n+        return llvm::ConstantFP::get(type, assert_cast<const ColumnVector<Float32> &>(column).getElement(index));\n+    }\n+    else if (column_data_type.isFloat64())\n+    {\n+        return llvm::ConstantFP::get(type, assert_cast<const ColumnVector<Float64> &>(column).getElement(index));\n+    }\n+    else if (column_data_type.isNativeUInt() || column_data_type.isDate() || column_data_type.isDateTime())\n+    {\n+        return llvm::ConstantInt::get(type, column.getUInt(index));\n+    }\n+    else if (column_data_type.isNativeInt() || column_data_type.isEnum() || column_data_type.isDate32())\n+    {\n+        return llvm::ConstantInt::get(type, column.getInt(index));\n+    }\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR,\n+        \"Cannot get native value for column with type {}\",\n+        column_type->getName());\n+}\n+\n+}\n+\n+#endif\ndiff --git a/src/DataTypes/Native.h b/src/DataTypes/Native.h\nindex a3c8486fa604..7fee452b1f08 100644\n--- a/src/DataTypes/Native.h\n+++ b/src/DataTypes/Native.h\n@@ -4,84 +4,30 @@\n \n #if USE_EMBEDDED_COMPILER\n #    include <Common/Exception.h>\n-\n+#    include <Core/ValueWithType.h>\n #    include <DataTypes/IDataType.h>\n-#    include <DataTypes/DataTypeNullable.h>\n-#    include <Columns/ColumnConst.h>\n-#    include <Columns/ColumnNullable.h>\n #    include <llvm/IR/IRBuilder.h>\n \n \n namespace DB\n {\n-namespace ErrorCodes\n-{\n-    extern const int NOT_IMPLEMENTED;\n-}\n \n-static inline bool typeIsSigned(const IDataType & type)\n-{\n-    WhichDataType data_type(type);\n-    return data_type.isNativeInt() || data_type.isFloat() || data_type.isEnum();\n-}\n-\n-static inline llvm::Type * toNullableType(llvm::IRBuilderBase & builder, llvm::Type * type)\n+namespace ErrorCodes\n {\n-    auto * is_null_type = builder.getInt1Ty();\n-    return llvm::StructType::get(type, is_null_type);\n+    extern const int LOGICAL_ERROR;\n }\n \n-static inline llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const IDataType & type)\n-{\n-    WhichDataType data_type(type);\n+/// Returns true if type is signed, false otherwise\n+bool typeIsSigned(const IDataType & type);\n \n-    if (data_type.isNullable())\n-    {\n-        const auto & data_type_nullable = static_cast<const DataTypeNullable&>(type);\n-        auto * wrapped = toNativeType(builder, *data_type_nullable.getNestedType());\n-        auto * is_null_type = builder.getInt1Ty();\n-        return wrapped ? llvm::StructType::get(wrapped, is_null_type) : nullptr;\n-    }\n+/// Cast LLVM type to nullable LLVM type\n+llvm::Type * toNullableType(llvm::IRBuilderBase & builder, llvm::Type * type);\n \n-    /// LLVM doesn't have unsigned types, it has unsigned instructions.\n-    if (data_type.isInt8() || data_type.isUInt8())\n-        return builder.getInt8Ty();\n-    else if (data_type.isInt16() || data_type.isUInt16() || data_type.isDate())\n-        return builder.getInt16Ty();\n-    else if (data_type.isInt32() || data_type.isUInt32() || data_type.isDate32() || data_type.isDateTime())\n-        return builder.getInt32Ty();\n-    else if (data_type.isInt64() || data_type.isUInt64())\n-        return builder.getInt64Ty();\n-    else if (data_type.isFloat32())\n-        return builder.getFloatTy();\n-    else if (data_type.isFloat64())\n-        return builder.getDoubleTy();\n-    else if (data_type.isEnum8())\n-        return builder.getInt8Ty();\n-    else if (data_type.isEnum16())\n-        return builder.getInt16Ty();\n+/// Returns true if type can be native LLVM type, false otherwise\n+bool canBeNativeType(const IDataType & type);\n \n-    return nullptr;\n-}\n-\n-template <typename ToType>\n-static inline llvm::Type * toNativeType(llvm::IRBuilderBase & builder)\n-{\n-    if constexpr (std::is_same_v<ToType, Int8> || std::is_same_v<ToType, UInt8>)\n-        return builder.getInt8Ty();\n-    else if constexpr (std::is_same_v<ToType, Int16> || std::is_same_v<ToType, UInt16>)\n-        return builder.getInt16Ty();\n-    else if constexpr (std::is_same_v<ToType, Int32> || std::is_same_v<ToType, UInt32>)\n-        return builder.getInt32Ty();\n-    else if constexpr (std::is_same_v<ToType, Int64> || std::is_same_v<ToType, UInt64>)\n-        return builder.getInt64Ty();\n-    else if constexpr (std::is_same_v<ToType, Float32>)\n-        return builder.getFloatTy();\n-    else if constexpr (std::is_same_v<ToType, Float64>)\n-        return builder.getDoubleTy();\n-\n-    return nullptr;\n-}\n+/// Returns true if type can be native LLVM type, false otherwise\n+bool canBeNativeType(const DataTypePtr & type);\n \n template <typename Type>\n static inline bool canBeNativeType()\n@@ -94,189 +40,71 @@ static inline bool canBeNativeType()\n         return true;\n     else if constexpr (std::is_same_v<Type, Int64> || std::is_same_v<Type, UInt64>)\n         return true;\n-    else if constexpr (std::is_same_v<Type, Float32>)\n-        return true;\n-    else if constexpr (std::is_same_v<Type, Float64>)\n+    else if constexpr (std::is_same_v<Type, Float32> || std::is_same_v<Type, Float64>)\n         return true;\n \n     return false;\n }\n \n-static inline bool canBeNativeType(const IDataType & type)\n-{\n-    WhichDataType data_type(type);\n-\n-    if (data_type.isNullable())\n-    {\n-        const auto & data_type_nullable = static_cast<const DataTypeNullable&>(type);\n-        return canBeNativeType(*data_type_nullable.getNestedType());\n-    }\n-\n-    return data_type.isNativeInt() || data_type.isNativeUInt() || data_type.isFloat() || data_type.isDate()\n-        || data_type.isDate32() || data_type.isDateTime() || data_type.isEnum();\n-}\n+/// Cast type to native LLVM type\n+llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const IDataType & type);\n \n-static inline llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const DataTypePtr & type)\n-{\n-    return toNativeType(builder, *type);\n-}\n+/// Cast type to native LLVM type\n+llvm::Type * toNativeType(llvm::IRBuilderBase & builder, const DataTypePtr & type);\n \n-static inline llvm::Value * nativeBoolCast(llvm::IRBuilder<> & b, const DataTypePtr & from_type, llvm::Value * value)\n+template <typename ToType>\n+static inline llvm::Type * toNativeType(llvm::IRBuilderBase & builder)\n {\n-    if (from_type->isNullable())\n-    {\n-        auto * inner = nativeBoolCast(b, removeNullable(from_type), b.CreateExtractValue(value, {0}));\n-        return b.CreateAnd(b.CreateNot(b.CreateExtractValue(value, {1})), inner);\n-    }\n-    auto * zero = llvm::Constant::getNullValue(value->getType());\n-\n-    if (value->getType()->isIntegerTy())\n-        return b.CreateICmpNE(value, zero);\n-    if (value->getType()->isFloatingPointTy())\n-        return b.CreateFCmpUNE(value, zero);\n+    if constexpr (std::is_same_v<ToType, Int8> || std::is_same_v<ToType, UInt8>)\n+        return builder.getInt8Ty();\n+    else if constexpr (std::is_same_v<ToType, Int16> || std::is_same_v<ToType, UInt16>)\n+        return builder.getInt16Ty();\n+    else if constexpr (std::is_same_v<ToType, Int32> || std::is_same_v<ToType, UInt32>)\n+        return builder.getInt32Ty();\n+    else if constexpr (std::is_same_v<ToType, Int64> || std::is_same_v<ToType, UInt64>)\n+        return builder.getInt64Ty();\n+    else if constexpr (std::is_same_v<ToType, Float32>)\n+        return builder.getFloatTy();\n+    else if constexpr (std::is_same_v<ToType, Float64>)\n+        return builder.getDoubleTy();\n \n-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot cast non-number {} to bool\", from_type->getName());\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid cast to native type\");\n }\n \n-static inline llvm::Value * nativeCast(llvm::IRBuilder<> & b, const DataTypePtr & from, llvm::Value * value, llvm::Type * to_type)\n+template <typename ToType>\n+static inline DataTypePtr toNativeDataType()\n {\n-    auto * from_type = value->getType();\n-\n-    if (from_type == to_type)\n-        return value;\n-    else if (from_type->isIntegerTy() && to_type->isFloatingPointTy())\n-        return typeIsSigned(*from) ? b.CreateSIToFP(value, to_type) : b.CreateUIToFP(value, to_type);\n-    else if (from_type->isFloatingPointTy() && to_type->isIntegerTy())\n-        return typeIsSigned(*from) ? b.CreateFPToSI(value, to_type) : b.CreateFPToUI(value, to_type);\n-    else if (from_type->isIntegerTy() && to_type->isIntegerTy())\n-        return b.CreateIntCast(value, to_type, typeIsSigned(*from));\n-    else if (from_type->isFloatingPointTy() && to_type->isFloatingPointTy())\n-        return b.CreateFPCast(value, to_type);\n-\n-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot cast {} to requested type\", from->getName());\n+    if constexpr (std::is_same_v<ToType, Int8> || std::is_same_v<ToType, UInt8> ||\n+        std::is_same_v<ToType, Int16> || std::is_same_v<ToType, UInt16> ||\n+        std::is_same_v<ToType, Int32> || std::is_same_v<ToType, UInt32> ||\n+        std::is_same_v<ToType, Int64> || std::is_same_v<ToType, UInt64> ||\n+        std::is_same_v<ToType, Float32> || std::is_same_v<ToType, Float64>)\n+        return std::make_shared<DataTypeNumber<ToType>>();\n+\n+    throw Exception(ErrorCodes::LOGICAL_ERROR, \"Invalid cast to native data type\");\n }\n \n-template <typename FromType>\n-static inline llvm::Value * nativeCast(llvm::IRBuilder<> & b, llvm::Value * value, llvm::Type * to_type)\n-{\n-    auto * from_type = value->getType();\n-\n-    static constexpr bool from_type_is_signed = std::numeric_limits<FromType>::is_signed;\n+/// Cast LLVM value with type to bool\n+llvm::Value * nativeBoolCast(llvm::IRBuilderBase & b, const DataTypePtr & from_type, llvm::Value * value);\n \n-    if (from_type == to_type)\n-        return value;\n-    else if (from_type->isIntegerTy() && to_type->isFloatingPointTy())\n-        return from_type_is_signed ? b.CreateSIToFP(value, to_type) : b.CreateUIToFP(value, to_type);\n-    else if (from_type->isFloatingPointTy() && to_type->isIntegerTy())\n-        return from_type_is_signed ? b.CreateFPToSI(value, to_type) : b.CreateFPToUI(value, to_type);\n-    else if (from_type->isIntegerTy() && to_type->isIntegerTy())\n-        return b.CreateIntCast(value, to_type, from_type_is_signed);\n-    else if (from_type->isFloatingPointTy() && to_type->isFloatingPointTy())\n-        return b.CreateFPCast(value, to_type);\n+/// Cast LLVM value with type to bool\n+llvm::Value * nativeBoolCast(llvm::IRBuilderBase & b, const ValueWithType & value_with_type);\n \n-    throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"Cannot cast {} to requested type\", TypeName<FromType>);\n-}\n-\n-static inline llvm::Value * nativeCast(llvm::IRBuilder<> & b, const DataTypePtr & from, llvm::Value * value, const DataTypePtr & to)\n-{\n-    auto * n_to = toNativeType(b, to);\n+/// Cast LLVM value with type to specified type\n+llvm::Value * nativeCast(llvm::IRBuilderBase & b, const DataTypePtr & from_type, llvm::Value * value, const DataTypePtr & to_type);\n \n-    if (value->getType() == n_to)\n-    {\n-        return value;\n-    }\n-    else if (from->isNullable() && to->isNullable())\n-    {\n-        auto * inner = nativeCast(b, removeNullable(from), b.CreateExtractValue(value, {0}), to);\n-        return b.CreateInsertValue(inner, b.CreateExtractValue(value, {1}), {1});\n-    }\n-    else if (from->isNullable())\n-    {\n-        return nativeCast(b, removeNullable(from), b.CreateExtractValue(value, {0}), to);\n-    }\n-    else if (to->isNullable())\n-    {\n-        auto * inner = nativeCast(b, from, value, removeNullable(to));\n-        return b.CreateInsertValue(llvm::Constant::getNullValue(n_to), inner, {0});\n-    }\n+/// Cast LLVM value with type to specified type\n+llvm::Value * nativeCast(llvm::IRBuilderBase & b, const ValueWithType & value, const DataTypePtr & to_type);\n \n-    return nativeCast(b, from, value, n_to);\n-}\n-\n-static inline std::pair<llvm::Value *, llvm::Value *> nativeCastToCommon(llvm::IRBuilder<> & b, const DataTypePtr & lhs_type, llvm::Value * lhs, const DataTypePtr & rhs_type, llvm::Value * rhs) /// NOLINT\n+template <typename FromType>\n+static inline llvm::Value * nativeCast(llvm::IRBuilderBase & b, llvm::Value * value, const DataTypePtr & to)\n {\n-    llvm::Type * common;\n-\n-    bool lhs_is_signed = typeIsSigned(*lhs_type);\n-    bool rhs_is_signed = typeIsSigned(*rhs_type);\n-\n-    if (lhs->getType()->isIntegerTy() && rhs->getType()->isIntegerTy())\n-    {\n-        /// if one integer has a sign bit, make sure the other does as well. llvm generates optimal code\n-        /// (e.g. uses overflow flag on x86) for (word size + 1)-bit integer operations.\n-\n-        size_t lhs_bit_width = lhs->getType()->getIntegerBitWidth() + (!lhs_is_signed && rhs_is_signed);\n-        size_t rhs_bit_width = rhs->getType()->getIntegerBitWidth() + (!rhs_is_signed && lhs_is_signed);\n-\n-        size_t max_bit_width = std::max(lhs_bit_width, rhs_bit_width);\n-        common = b.getIntNTy(static_cast<unsigned>(max_bit_width));\n-    }\n-    else\n-    {\n-        /// TODO: Check\n-        /// (double, float) or (double, int_N where N <= double's mantissa width) -> double\n-        common = b.getDoubleTy();\n-    }\n-\n-    auto * cast_lhs_to_common = nativeCast(b, lhs_type, lhs, common);\n-    auto * cast_rhs_to_common = nativeCast(b, rhs_type, rhs, common);\n-\n-    return std::make_pair(cast_lhs_to_common, cast_rhs_to_common);\n+    auto native_data_type = toNativeDataType<FromType>();\n+    return nativeCast(b, native_data_type, value, to);\n }\n \n-static inline llvm::Constant * getColumnNativeValue(llvm::IRBuilderBase & builder, const DataTypePtr & column_type, const IColumn & column, size_t index)\n-{\n-    if (const auto * constant = typeid_cast<const ColumnConst *>(&column))\n-    {\n-        return getColumnNativeValue(builder, column_type, constant->getDataColumn(), 0);\n-    }\n-\n-    WhichDataType column_data_type(column_type);\n-\n-    auto * type = toNativeType(builder, column_type);\n-\n-    if (!type || column.size() <= index)\n-        return nullptr;\n-\n-    if (column_data_type.isNullable())\n-    {\n-        const auto & nullable_data_type = assert_cast<const DataTypeNullable &>(*column_type);\n-        const auto & nullable_column = assert_cast<const ColumnNullable &>(column);\n-\n-        auto * value = getColumnNativeValue(builder, nullable_data_type.getNestedType(), nullable_column.getNestedColumn(), index);\n-        auto * is_null = llvm::ConstantInt::get(type->getContainedType(1), nullable_column.isNullAt(index));\n-\n-        return value ? llvm::ConstantStruct::get(static_cast<llvm::StructType *>(type), value, is_null) : nullptr;\n-    }\n-    else if (column_data_type.isFloat32())\n-    {\n-        return llvm::ConstantFP::get(type, assert_cast<const ColumnVector<Float32> &>(column).getElement(index));\n-    }\n-    else if (column_data_type.isFloat64())\n-    {\n-        return llvm::ConstantFP::get(type, assert_cast<const ColumnVector<Float64> &>(column).getElement(index));\n-    }\n-    else if (column_data_type.isNativeUInt() || column_data_type.isDate() || column_data_type.isDateTime())\n-    {\n-        return llvm::ConstantInt::get(type, column.getUInt(index));\n-    }\n-    else if (column_data_type.isNativeInt() || column_data_type.isEnum() || column_data_type.isDate32())\n-    {\n-        return llvm::ConstantInt::get(type, column.getInt(index));\n-    }\n-\n-    return nullptr;\n-}\n+/// Get column value for specified index as LLVM constant\n+llvm::Constant * getColumnNativeValue(llvm::IRBuilderBase & builder, const DataTypePtr & column_type, const IColumn & column, size_t index);\n \n }\n \ndiff --git a/src/Functions/FunctionBinaryArithmetic.h b/src/Functions/FunctionBinaryArithmetic.h\nindex b205822aab56..c699da4eaf60 100644\n--- a/src/Functions/FunctionBinaryArithmetic.h\n+++ b/src/Functions/FunctionBinaryArithmetic.h\n@@ -2046,51 +2046,68 @@ ColumnPtr executeStringInteger(const ColumnsWithTypeAndName & arguments, const A\n     }\n \n #if USE_EMBEDDED_COMPILER\n-    bool isCompilableImpl(const DataTypes & arguments) const override\n+    bool isCompilableImpl(const DataTypes & arguments, const DataTypePtr & result_type) const override\n     {\n         if (2 != arguments.size())\n             return false;\n \n+        if (!canBeNativeType(*arguments[0]) || !canBeNativeType(*arguments[1]) || !canBeNativeType(*result_type))\n+            return false;\n+\n+        WhichDataType data_type_lhs(arguments[0]);\n+        WhichDataType data_type_rhs(arguments[1]);\n+        if ((data_type_lhs.isDateOrDate32() || data_type_lhs.isDateTime()) ||\n+            (data_type_rhs.isDateOrDate32() || data_type_rhs.isDateTime()))\n+            return false;\n+\n         return castBothTypes(arguments[0].get(), arguments[1].get(), [&](const auto & left, const auto & right)\n         {\n             using LeftDataType = std::decay_t<decltype(left)>;\n             using RightDataType = std::decay_t<decltype(right)>;\n-            if constexpr (std::is_same_v<DataTypeFixedString, LeftDataType> || std::is_same_v<DataTypeFixedString, RightDataType> || std::is_same_v<DataTypeString, LeftDataType> || std::is_same_v<DataTypeString, RightDataType>)\n-                return false;\n-            else\n+            if constexpr (!std::is_same_v<DataTypeFixedString, LeftDataType> &&\n+                !std::is_same_v<DataTypeFixedString, RightDataType> &&\n+                !std::is_same_v<DataTypeString, LeftDataType> &&\n+                !std::is_same_v<DataTypeString, RightDataType>)\n             {\n                 using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;\n                 using OpSpec = Op<typename LeftDataType::FieldType, typename RightDataType::FieldType>;\n-                return !std::is_same_v<ResultDataType, InvalidType> && !IsDataTypeDecimal<ResultDataType> && OpSpec::compilable;\n+                if constexpr (!std::is_same_v<ResultDataType, InvalidType> && !IsDataTypeDecimal<ResultDataType> && OpSpec::compilable)\n+                    return true;\n             }\n+            return false;\n         });\n     }\n \n-    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, Values values) const override\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const ValuesWithType & arguments, const DataTypePtr & result_type) const override\n     {\n-        assert(2 == types.size() && 2 == values.size());\n+        assert(2 == arguments.size());\n \n         llvm::Value * result = nullptr;\n-        castBothTypes(types[0].get(), types[1].get(), [&](const auto & left, const auto & right)\n+        castBothTypes(arguments[0].type.get(), arguments[1].type.get(), [&](const auto & left, const auto & right)\n         {\n             using LeftDataType = std::decay_t<decltype(left)>;\n             using RightDataType = std::decay_t<decltype(right)>;\n-            if constexpr (!std::is_same_v<DataTypeFixedString, LeftDataType> && !std::is_same_v<DataTypeFixedString, RightDataType> && !std::is_same_v<DataTypeString, LeftDataType> && !std::is_same_v<DataTypeString, RightDataType>)\n+            if constexpr (!std::is_same_v<DataTypeFixedString, LeftDataType> &&\n+                !std::is_same_v<DataTypeFixedString, RightDataType> &&\n+                !std::is_same_v<DataTypeString, LeftDataType> &&\n+                !std::is_same_v<DataTypeString, RightDataType>)\n             {\n                 using ResultDataType = typename BinaryOperationTraits<Op, LeftDataType, RightDataType>::ResultDataType;\n                 using OpSpec = Op<typename LeftDataType::FieldType, typename RightDataType::FieldType>;\n                 if constexpr (!std::is_same_v<ResultDataType, InvalidType> && !IsDataTypeDecimal<ResultDataType> && OpSpec::compilable)\n                 {\n                     auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n-                    auto type = std::make_shared<ResultDataType>();\n-                    auto * lval = nativeCast(b, types[0], values[0], type);\n-                    auto * rval = nativeCast(b, types[1], values[1], type);\n+                    auto * lval = nativeCast(b, arguments[0], result_type);\n+                    auto * rval = nativeCast(b, arguments[1], result_type);\n                     result = OpSpec::compile(b, lval, rval, std::is_signed_v<typename ResultDataType::FieldType>);\n+\n                     return true;\n                 }\n             }\n+\n             return false;\n         });\n+\n         return result;\n     }\n #endif\ndiff --git a/src/Functions/FunctionIfBase.h b/src/Functions/FunctionIfBase.h\nindex 4c9ecf78a128..2d5f42a53a09 100644\n--- a/src/Functions/FunctionIfBase.h\n+++ b/src/Functions/FunctionIfBase.h\n@@ -2,6 +2,7 @@\n \n #include <Functions/IFunction.h>\n #include <DataTypes/Native.h>\n+#include <DataTypes/DataTypeNullable.h>\n \n #include \"config.h\"\n \n@@ -12,8 +13,11 @@ class FunctionIfBase : public IFunction\n {\n #if USE_EMBEDDED_COMPILER\n public:\n-    bool isCompilableImpl(const DataTypes & types) const override\n+    bool isCompilableImpl(const DataTypes & types, const DataTypePtr & result_type) const override\n     {\n+        if (!canBeNativeType(result_type))\n+            return false;\n+\n         /// It's difficult to compare Date and DateTime - cannot use JIT compilation.\n         bool has_date = false;\n         bool has_datetime = false;\n@@ -31,43 +35,43 @@ class FunctionIfBase : public IFunction\n             if (has_date && has_datetime)\n                 return false;\n \n-            if (!isCompilableType(type_removed_nullable))\n+            if (!canBeNativeType(type_removed_nullable))\n                 return false;\n         }\n+\n         return true;\n     }\n \n-    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, Values values) const override\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const ValuesWithType & arguments, const DataTypePtr & result_type) const override\n     {\n         auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n-        auto return_type = getReturnTypeImpl(types);\n \n         auto * head = b.GetInsertBlock();\n         auto * join = llvm::BasicBlock::Create(head->getContext(), \"join_block\", head->getParent());\n \n         std::vector<std::pair<llvm::BasicBlock *, llvm::Value *>> returns;\n-        for (size_t i = 0; i + 1 < types.size(); i += 2)\n+        for (size_t i = 0; i + 1 < arguments.size(); i += 2)\n         {\n             auto * then = llvm::BasicBlock::Create(head->getContext(), \"then_\" + std::to_string(i), head->getParent());\n             auto * next = llvm::BasicBlock::Create(head->getContext(), \"next_\" + std::to_string(i), head->getParent());\n-            auto * cond = values[i];\n+            const auto & cond = arguments[i];\n \n-            b.CreateCondBr(nativeBoolCast(b, types[i], cond), then, next);\n+            b.CreateCondBr(nativeBoolCast(b, cond), then, next);\n             b.SetInsertPoint(then);\n \n-            auto * value = nativeCast(b, types[i + 1], values[i + 1], return_type);\n+            auto * value = nativeCast(b, arguments[i + 1], result_type);\n             returns.emplace_back(b.GetInsertBlock(), value);\n             b.CreateBr(join);\n             b.SetInsertPoint(next);\n         }\n \n-        auto * else_value = nativeCast(b, types.back(), values.back(), return_type);\n+        auto * else_value = nativeCast(b, arguments.back(), result_type);\n         returns.emplace_back(b.GetInsertBlock(), else_value);\n         b.CreateBr(join);\n \n         b.SetInsertPoint(join);\n \n-        auto * phi = b.CreatePHI(toNativeType(b, return_type), static_cast<unsigned>(returns.size()));\n+        auto * phi = b.CreatePHI(toNativeType(b, result_type), static_cast<unsigned>(returns.size()));\n         for (const auto & [block, value] : returns)\n             phi->addIncoming(value, block);\n \ndiff --git a/src/Functions/FunctionUnaryArithmetic.h b/src/Functions/FunctionUnaryArithmetic.h\nindex 4098d58299ca..259dc1c42ba5 100644\n--- a/src/Functions/FunctionUnaryArithmetic.h\n+++ b/src/Functions/FunctionUnaryArithmetic.h\n@@ -477,31 +477,45 @@ class FunctionUnaryArithmetic : public IFunction\n     }\n \n #if USE_EMBEDDED_COMPILER\n-    bool isCompilableImpl(const DataTypes & arguments) const override\n+    bool isCompilableImpl(const DataTypes & arguments, const DataTypePtr & result_type) const override\n     {\n         if (1 != arguments.size())\n             return false;\n \n+        if (!canBeNativeType(*arguments[0]) || !canBeNativeType(*result_type))\n+            return false;\n+\n         return castType(arguments[0].get(), [&](const auto & type)\n         {\n             using DataType = std::decay_t<decltype(type)>;\n             if constexpr (std::is_same_v<DataTypeFixedString, DataType> || std::is_same_v<DataTypeString, DataType>)\n+            {\n                 return false;\n+            }\n             else\n-                return !IsDataTypeDecimal<DataType> && Op<typename DataType::FieldType>::compilable;\n+            {\n+                using T0 = typename DataType::FieldType;\n+                using T1 = typename Op<T0>::ResultType;\n+                if constexpr (!std::is_same_v<T1, InvalidType> && !IsDataTypeDecimal<DataType> && Op<T0>::compilable)\n+                    return true;\n+            }\n+\n+            return false;\n         });\n     }\n \n-    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, Values values) const override\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const ValuesWithType & arguments, const DataTypePtr & result_type) const override\n     {\n-        assert(1 == types.size() && 1 == values.size());\n+        assert(1 == arguments.size());\n \n         llvm::Value * result = nullptr;\n-        castType(types[0].get(), [&](const auto & type)\n+        castType(arguments[0].type.get(), [&](const auto & type)\n         {\n             using DataType = std::decay_t<decltype(type)>;\n             if constexpr (std::is_same_v<DataTypeFixedString, DataType> || std::is_same_v<DataTypeString, DataType>)\n+            {\n                 return false;\n+            }\n             else\n             {\n                 using T0 = typename DataType::FieldType;\n@@ -509,13 +523,16 @@ class FunctionUnaryArithmetic : public IFunction\n                 if constexpr (!std::is_same_v<T1, InvalidType> && !IsDataTypeDecimal<DataType> && Op<T0>::compilable)\n                 {\n                     auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n-                    auto * v = nativeCast(b, types[0], values[0], std::make_shared<DataTypeNumber<T1>>());\n+                    auto * v = nativeCast(b, arguments[0], result_type);\n                     result = Op<T0>::compile(b, v, is_signed_v<T1>);\n+\n                     return true;\n                 }\n             }\n+\n             return false;\n         });\n+\n         return result;\n     }\n #endif\ndiff --git a/src/Functions/FunctionsComparison.h b/src/Functions/FunctionsComparison.h\nindex 08bc350c1d42..66269f72866f 100644\n--- a/src/Functions/FunctionsComparison.h\n+++ b/src/Functions/FunctionsComparison.h\n@@ -1382,37 +1382,6 @@ class FunctionComparison : public IFunction\n             return executeGeneric(col_with_type_and_name_left, col_with_type_and_name_right);\n         }\n     }\n-\n-#if USE_EMBEDDED_COMPILER\n-    bool isCompilableImpl(const DataTypes & types) const override\n-    {\n-        if (2 != types.size())\n-            return false;\n-\n-        WhichDataType data_type_lhs(types[0]);\n-        WhichDataType data_type_rhs(types[1]);\n-\n-        auto is_big_integer = [](WhichDataType type) { return type.isUInt64() || type.isInt64(); };\n-\n-        if ((is_big_integer(data_type_lhs) && data_type_rhs.isFloat())\n-            || (is_big_integer(data_type_rhs) && data_type_lhs.isFloat())\n-            || (data_type_lhs.isDate() && data_type_rhs.isDateTime())\n-            || (data_type_rhs.isDate() && data_type_lhs.isDateTime()))\n-            return false; /// TODO: implement (double, int_N where N > double's mantissa width)\n-\n-        return isCompilableType(types[0]) && isCompilableType(types[1]);\n-    }\n-\n-    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, Values values) const override\n-    {\n-        assert(2 == types.size() && 2 == values.size());\n-\n-        auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n-        auto [x, y] = nativeCastToCommon(b, types[0], values[0], types[1], values[1]);\n-        auto * result = CompileOp<Op>::compile(b, x, y, typeIsSigned(*types[0]) || typeIsSigned(*types[1]));\n-        return b.CreateSelect(result, b.getInt8(1), b.getInt8(0));\n-    }\n-#endif\n };\n \n }\ndiff --git a/src/Functions/FunctionsLogical.h b/src/Functions/FunctionsLogical.h\nindex b2a59c51123e..a25bffcdd73b 100644\n--- a/src/Functions/FunctionsLogical.h\n+++ b/src/Functions/FunctionsLogical.h\n@@ -184,41 +184,46 @@ class FunctionAnyArityLogical : public IFunction\n     ColumnPtr getConstantResultForNonConstArguments(const ColumnsWithTypeAndName & arguments, const DataTypePtr & result_type) const override;\n \n #if USE_EMBEDDED_COMPILER\n-    bool isCompilableImpl(const DataTypes &) const override { return useDefaultImplementationForNulls(); }\n+    bool isCompilableImpl(const DataTypes &, const DataTypePtr &) const override { return useDefaultImplementationForNulls(); }\n \n-    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, Values values) const override\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const ValuesWithType & values, const DataTypePtr &) const override\n     {\n-        assert(!types.empty() && !values.empty());\n+        assert(!values.empty());\n \n         auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n         if constexpr (!Impl::isSaturable())\n         {\n-            auto * result = nativeBoolCast(b, types[0], values[0]);\n-            for (size_t i = 1; i < types.size(); ++i)\n-                result = Impl::apply(b, result, nativeBoolCast(b, types[i], values[i]));\n+            auto * result = nativeBoolCast(b, values[0]);\n+            for (size_t i = 1; i < values.size(); ++i)\n+                result = Impl::apply(b, result, nativeBoolCast(b, values[i]));\n             return b.CreateSelect(result, b.getInt8(1), b.getInt8(0));\n         }\n+\n         constexpr bool break_on_true = Impl::isSaturatedValue(true);\n         auto * next = b.GetInsertBlock();\n         auto * stop = llvm::BasicBlock::Create(next->getContext(), \"\", next->getParent());\n         b.SetInsertPoint(stop);\n+\n         auto * phi = b.CreatePHI(b.getInt8Ty(), static_cast<unsigned>(values.size()));\n-        for (size_t i = 0; i < types.size(); ++i)\n+\n+        for (size_t i = 0; i < values.size(); ++i)\n         {\n             b.SetInsertPoint(next);\n-            auto * value = values[i];\n-            auto * truth = nativeBoolCast(b, types[i], value);\n-            if (!types[i]->equals(DataTypeUInt8{}))\n+            auto * value = values[i].value;\n+            auto * truth = nativeBoolCast(b, values[i]);\n+            if (!values[i].type->equals(DataTypeUInt8{}))\n                 value = b.CreateSelect(truth, b.getInt8(1), b.getInt8(0));\n             phi->addIncoming(value, b.GetInsertBlock());\n-            if (i + 1 < types.size())\n+            if (i + 1 < values.size())\n             {\n                 next = llvm::BasicBlock::Create(next->getContext(), \"\", next->getParent());\n                 b.CreateCondBr(truth, break_on_true ? stop : next, break_on_true ? next : stop);\n             }\n         }\n+\n         b.CreateBr(stop);\n         b.SetInsertPoint(stop);\n+\n         return phi;\n     }\n #endif\n@@ -248,12 +253,12 @@ class FunctionUnaryLogical : public IFunction\n     ColumnPtr executeImpl(const ColumnsWithTypeAndName & arguments, const DataTypePtr &, size_t /*input_rows_count*/) const override;\n \n #if USE_EMBEDDED_COMPILER\n-    bool isCompilableImpl(const DataTypes &) const override { return true; }\n+    bool isCompilableImpl(const DataTypes &, const DataTypePtr &) const override { return true; }\n \n-    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const DataTypes & types, Values values) const override\n+    llvm::Value * compileImpl(llvm::IRBuilderBase & builder, const ValuesWithType & values, const DataTypePtr &) const override\n     {\n         auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n-        return b.CreateSelect(Impl<UInt8>::apply(b, nativeBoolCast(b, types[0], values[0])), b.getInt8(1), b.getInt8(0));\n+        return b.CreateSelect(Impl<UInt8>::apply(b, nativeBoolCast(b, values[0])), b.getInt8(1), b.getInt8(0));\n     }\n #endif\n };\ndiff --git a/src/Functions/IFunction.cpp b/src/Functions/IFunction.cpp\nindex 7563135f21f5..650b54d9a377 100644\n--- a/src/Functions/IFunction.cpp\n+++ b/src/Functions/IFunction.cpp\n@@ -484,59 +484,74 @@ DataTypePtr IFunctionOverloadResolver::getReturnTypeWithoutLowCardinality(const\n \n static std::optional<DataTypes> removeNullables(const DataTypes & types)\n {\n+    bool has_nullable = false;\n     for (const auto & type : types)\n     {\n         if (!typeid_cast<const DataTypeNullable *>(type.get()))\n             continue;\n+\n+        has_nullable = true;\n+        break;\n+    }\n+\n+    if (has_nullable)\n+    {\n         DataTypes filtered;\n+        filtered.reserve(types.size());\n+\n         for (const auto & sub_type : types)\n             filtered.emplace_back(removeNullable(sub_type));\n+\n         return filtered;\n     }\n+\n     return {};\n }\n \n-bool IFunction::isCompilable(const DataTypes & arguments) const\n+bool IFunction::isCompilable(const DataTypes & arguments, const DataTypePtr & result_type) const\n {\n-\n     if (useDefaultImplementationForNulls())\n-        if (auto denulled = removeNullables(arguments))\n-            return isCompilableImpl(*denulled);\n-    return isCompilableImpl(arguments);\n+        if (auto denulled_arguments = removeNullables(arguments))\n+            return isCompilableImpl(*denulled_arguments, result_type);\n+\n+    return isCompilableImpl(arguments, result_type);\n }\n \n-llvm::Value * IFunction::compile(llvm::IRBuilderBase & builder, const DataTypes & arguments, Values values) const\n+llvm::Value * IFunction::compile(llvm::IRBuilderBase & builder, const ValuesWithType & arguments, const DataTypePtr & result_type) const\n {\n-    auto denulled_arguments = removeNullables(arguments);\n-    if (useDefaultImplementationForNulls() && denulled_arguments)\n+    DataTypes arguments_types;\n+    arguments_types.reserve(arguments.size());\n+\n+    for (const auto & argument : arguments)\n+        arguments_types.push_back(argument.type);\n+\n+    auto denulled_arguments_types = removeNullables(arguments_types);\n+    if (useDefaultImplementationForNulls() && denulled_arguments_types)\n     {\n         auto & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-        std::vector<llvm::Value*> unwrapped_values;\n-        std::vector<llvm::Value*> is_null_values;\n+        ValuesWithType unwrapped_arguments;\n+        unwrapped_arguments.reserve(arguments.size());\n \n-        unwrapped_values.reserve(arguments.size());\n-        is_null_values.reserve(arguments.size());\n+        std::vector<llvm::Value*> is_null_values;\n \n         for (size_t i = 0; i < arguments.size(); ++i)\n         {\n-            auto * value = values[i];\n+            const auto & argument = arguments[i];\n+            llvm::Value * unwrapped_value = argument.value;\n \n-            WhichDataType data_type(arguments[i]);\n-            if (data_type.isNullable())\n+            if (argument.type->isNullable())\n             {\n-                unwrapped_values.emplace_back(b.CreateExtractValue(value, {0}));\n-                is_null_values.emplace_back(b.CreateExtractValue(value, {1}));\n-            }\n-            else\n-            {\n-                unwrapped_values.emplace_back(value);\n+                unwrapped_value = b.CreateExtractValue(argument.value, {0});\n+                is_null_values.emplace_back(b.CreateExtractValue(argument.value, {1}));\n             }\n+\n+            unwrapped_arguments.emplace_back(unwrapped_value, (*denulled_arguments_types)[i]);\n         }\n \n-        auto * result = compileImpl(builder, *denulled_arguments, unwrapped_values);\n+        auto * result = compileImpl(builder, unwrapped_arguments, removeNullable(result_type));\n \n-        auto * nullable_structure_type = toNativeType(b, makeNullable(getReturnTypeImpl(*denulled_arguments)));\n+        auto * nullable_structure_type = toNativeType(b, makeNullable(getReturnTypeImpl(*denulled_arguments_types)));\n         auto * nullable_structure_value = llvm::Constant::getNullValue(nullable_structure_type);\n \n         auto * nullable_structure_with_result_value = b.CreateInsertValue(nullable_structure_value, result, {0});\n@@ -548,7 +563,7 @@ llvm::Value * IFunction::compile(llvm::IRBuilderBase & builder, const DataTypes\n         return b.CreateInsertValue(nullable_structure_with_result_value, nullable_structure_result_null, {1});\n     }\n \n-    return compileImpl(builder, arguments, std::move(values));\n+    return compileImpl(builder, arguments, result_type);\n }\n \n #endif\ndiff --git a/src/Functions/IFunction.h b/src/Functions/IFunction.h\nindex cf2dcc9617e6..433cb61d04e9 100644\n--- a/src/Functions/IFunction.h\n+++ b/src/Functions/IFunction.h\n@@ -3,6 +3,7 @@\n #include <Core/ColumnNumbers.h>\n #include <Core/ColumnsWithTypeAndName.h>\n #include <Core/Field.h>\n+#include <Core/ValuesWithType.h>\n #include <Core/Names.h>\n #include <Core/IResolvedFunction.h>\n #include <Common/Exception.h>\n@@ -121,8 +122,6 @@ class IExecutableFunction\n \n using ExecutableFunctionPtr = std::shared_ptr<IExecutableFunction>;\n \n-using Values = std::vector<llvm::Value *>;\n-\n /** Function with known arguments and return type (when the specific overload was chosen).\n   * It is also the point where all function-specific properties are known.\n   */\n@@ -162,7 +161,7 @@ class IFunctionBase : public IResolvedFunction\n       *       templates with default arguments is impossible and including LLVM in such a generic header\n       *       as this one is a major pain.\n       */\n-    virtual llvm::Value * compile(llvm::IRBuilderBase & /*builder*/, Values /*values*/) const\n+    virtual llvm::Value * compile(llvm::IRBuilderBase & /*builder*/, const ValuesWithType & /*arguments*/) const\n     {\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"{} is not JIT-compilable\", getName());\n     }\n@@ -530,9 +529,9 @@ class IFunction\n \n #if USE_EMBEDDED_COMPILER\n \n-    bool isCompilable(const DataTypes & arguments) const;\n+    bool isCompilable(const DataTypes & arguments, const DataTypePtr & result_type) const;\n \n-    llvm::Value * compile(llvm::IRBuilderBase &, const DataTypes & arguments, Values values) const;\n+    llvm::Value * compile(llvm::IRBuilderBase & builder, const ValuesWithType & arguments, const DataTypePtr & result_type) const;\n \n #endif\n \n@@ -540,9 +539,9 @@ class IFunction\n \n #if USE_EMBEDDED_COMPILER\n \n-    virtual bool isCompilableImpl(const DataTypes &) const { return false; }\n+    virtual bool isCompilableImpl(const DataTypes & /*arguments*/, const DataTypePtr & /*result_type*/) const { return false; }\n \n-    virtual llvm::Value * compileImpl(llvm::IRBuilderBase &, const DataTypes &, Values) const\n+    virtual llvm::Value * compileImpl(llvm::IRBuilderBase & /*builder*/, const ValuesWithType & /*arguments*/, const DataTypePtr & /*result_type*/) const\n     {\n         throw Exception(ErrorCodes::NOT_IMPLEMENTED, \"{} is not JIT-compilable\", getName());\n     }\ndiff --git a/src/Functions/IFunctionAdaptors.h b/src/Functions/IFunctionAdaptors.h\nindex 4ecb45167cc2..123fdbc2f50f 100644\n--- a/src/Functions/IFunctionAdaptors.h\n+++ b/src/Functions/IFunctionAdaptors.h\n@@ -55,11 +55,11 @@ class FunctionToFunctionBaseAdaptor final : public IFunctionBase\n \n #if USE_EMBEDDED_COMPILER\n \n-    bool isCompilable() const override { return function->isCompilable(getArgumentTypes()); }\n+    bool isCompilable() const override { return function->isCompilable(getArgumentTypes(), getResultType()); }\n \n-    llvm::Value * compile(llvm::IRBuilderBase & builder, Values values) const override\n+    llvm::Value * compile(llvm::IRBuilderBase & builder, const ValuesWithType & compile_arguments) const override\n     {\n-        return function->compile(builder, getArgumentTypes(), std::move(values));\n+        return function->compile(builder, compile_arguments, getResultType());\n     }\n \n #endif\ndiff --git a/src/Interpreters/ExpressionJIT.cpp b/src/Interpreters/ExpressionJIT.cpp\nindex dfc88e970528..0eacb598fbe9 100644\n--- a/src/Interpreters/ExpressionJIT.cpp\n+++ b/src/Interpreters/ExpressionJIT.cpp\n@@ -160,9 +160,9 @@ class LLVMFunction : public IFunctionBase\n \n     bool isCompilable() const override { return true; }\n \n-    llvm::Value * compile(llvm::IRBuilderBase & builder, Values values) const override\n+    llvm::Value * compile(llvm::IRBuilderBase & builder, const ValuesWithType & arguments) const override\n     {\n-        return dag.compile(builder, values);\n+        return dag.compile(builder, arguments).value;\n     }\n \n     bool isSuitableForShortCircuitArgumentsExecution(const DataTypesWithConstInfo & arguments) const override\ndiff --git a/src/Interpreters/JIT/CHJIT.h b/src/Interpreters/JIT/CHJIT.h\nindex cde1129c010d..fc8838024263 100644\n--- a/src/Interpreters/JIT/CHJIT.h\n+++ b/src/Interpreters/JIT/CHJIT.h\n@@ -19,14 +19,14 @@ class JITModuleMemoryManager;\n class JITSymbolResolver;\n class JITCompiler;\n \n-/** Custom jit implementation\n+/** Custom JIT implementation.\n   * Main use cases:\n   * 1. Compiled functions in module.\n   * 2. Release memory for compiled functions.\n   *\n   * In LLVM library there are 2 main JIT stacks MCJIT and ORCv2.\n   *\n-  * Main reasons for custom implementation vs MCJIT\n+  * Main reasons for custom implementation vs MCJIT.\n   * MCJIT keeps llvm::Module and compiled object code before linking process after module was compiled.\n   * llvm::Module can be removed, but compiled object code cannot be removed. Memory for compiled code\n   * will be release only during MCJIT instance destruction. It is too expensive to create MCJIT\ndiff --git a/src/Interpreters/JIT/CompileDAG.cpp b/src/Interpreters/JIT/CompileDAG.cpp\nindex 2c5c7731150c..6da17fb4c676 100644\n--- a/src/Interpreters/JIT/CompileDAG.cpp\n+++ b/src/Interpreters/JIT/CompileDAG.cpp\n@@ -16,19 +16,14 @@\n namespace DB\n {\n \n-namespace ErrorCodes\n-{\n-    extern const int LOGICAL_ERROR;\n-}\n-\n-llvm::Value * CompileDAG::compile(llvm::IRBuilderBase & builder, Values input_nodes_values) const\n+ValueWithType CompileDAG::compile(llvm::IRBuilderBase & builder, const ValuesWithType & input_nodes_values) const\n {\n     assert(input_nodes_values.size() == getInputNodesCount());\n \n     llvm::IRBuilder<> & b = static_cast<llvm::IRBuilder<> &>(builder);\n \n-    PaddedPODArray<llvm::Value *> compiled_values;\n-    compiled_values.resize_fill(nodes.size());\n+    ValuesWithType compiled_values;\n+    compiled_values.resize(nodes.size());\n \n     size_t input_nodes_values_index = 0;\n     size_t compiled_values_index = 0;\n@@ -44,31 +39,26 @@ llvm::Value * CompileDAG::compile(llvm::IRBuilderBase & builder, Values input_no\n             case CompileType::CONSTANT:\n             {\n                 auto * native_value = getColumnNativeValue(b, node.result_type, *node.column, 0);\n-                if (!native_value)\n-                    throw Exception(ErrorCodes::LOGICAL_ERROR,\n-                    \"Cannot find native value for constant column with type {}\",\n-                    node.result_type->getName());\n-\n-                compiled_values[compiled_values_index] = native_value;\n+                compiled_values[compiled_values_index] = {native_value, node.result_type};\n                 break;\n             }\n             case CompileType::FUNCTION:\n             {\n-                Values temporary_values;\n+                ValuesWithType temporary_values;\n                 temporary_values.reserve(node.arguments.size());\n \n                 for (auto argument_index : node.arguments)\n                 {\n-                    assert(compiled_values[argument_index] != nullptr);\n+                    assert(compiled_values[argument_index].value != nullptr);\n                     temporary_values.emplace_back(compiled_values[argument_index]);\n                 }\n \n-                compiled_values[compiled_values_index] = node.function->compile(builder, temporary_values);\n+                compiled_values[compiled_values_index] = {node.function->compile(builder, temporary_values), node.result_type};\n                 break;\n             }\n             case CompileType::INPUT:\n             {\n-                compiled_values[compiled_values_index] = input_nodes_values[input_nodes_values_index];\n+                compiled_values[compiled_values_index] = {input_nodes_values[input_nodes_values_index].value, node.result_type};\n                 ++input_nodes_values_index;\n                 break;\n             }\ndiff --git a/src/Interpreters/JIT/CompileDAG.h b/src/Interpreters/JIT/CompileDAG.h\nindex a05fa6295612..77a02230f55e 100644\n--- a/src/Interpreters/JIT/CompileDAG.h\n+++ b/src/Interpreters/JIT/CompileDAG.h\n@@ -53,7 +53,7 @@ class CompileDAG\n         std::vector<size_t> arguments;\n     };\n \n-    llvm::Value * compile(llvm::IRBuilderBase & builder, Values input_nodes_values) const;\n+    ValueWithType compile(llvm::IRBuilderBase & builder, const ValuesWithType & input_nodes_values_with_type) const;\n \n     std::string dump() const;\n \ndiff --git a/src/Interpreters/JIT/compileFunction.cpp b/src/Interpreters/JIT/compileFunction.cpp\nindex a72334338617..fb8dec665b41 100644\n--- a/src/Interpreters/JIT/compileFunction.cpp\n+++ b/src/Interpreters/JIT/compileFunction.cpp\n@@ -9,6 +9,8 @@\n #include <Common/Stopwatch.h>\n #include <Common/ProfileEvents.h>\n #include <DataTypes/Native.h>\n+#include <DataTypes/DataTypeNullable.h>\n+#include <Columns/ColumnNullable.h>\n #include <Interpreters/JIT/CHJIT.h>\n \n namespace\n@@ -107,7 +109,7 @@ static void compileFunction(llvm::Module & module, const IFunctionBase & functio\n \n     /// Initialize column row values\n \n-    Values arguments;\n+    ValuesWithType arguments;\n     arguments.reserve(function_argument_types.size());\n \n     for (size_t i = 0; i < function_argument_types.size(); ++i)\n@@ -116,30 +118,30 @@ static void compileFunction(llvm::Module & module, const IFunctionBase & functio\n         const auto & type = function_argument_types[i];\n \n         auto * column_data_ptr = column.data_ptr;\n-        auto * column_element_value = b.CreateLoad(column.data_element_type, b.CreateGEP(column.data_element_type, column_data_ptr, counter_phi));\n+        auto * column_element_value = b.CreateLoad(column.data_element_type, b.CreateInBoundsGEP(column.data_element_type, column_data_ptr, counter_phi));\n \n         if (!type->isNullable())\n         {\n-            arguments.emplace_back(column_element_value);\n+            arguments.emplace_back(column_element_value, type);\n             continue;\n         }\n \n-        auto * column_is_null_element_value = b.CreateLoad(b.getInt8Ty(), b.CreateGEP(b.getInt8Ty(), column.null_data_ptr, counter_phi));\n+        auto * column_is_null_element_value = b.CreateLoad(b.getInt8Ty(), b.CreateInBoundsGEP(b.getInt8Ty(), column.null_data_ptr, counter_phi));\n         auto * is_null = b.CreateICmpNE(column_is_null_element_value, b.getInt8(0));\n         auto * nullable_unitialized = llvm::Constant::getNullValue(toNullableType(b, column.data_element_type));\n         auto * nullable_value = b.CreateInsertValue(b.CreateInsertValue(nullable_unitialized, column_element_value, {0}), is_null, {1});\n-        arguments.emplace_back(nullable_value);\n+        arguments.emplace_back(nullable_value, type);\n     }\n \n     /// Compile values for column rows and store compiled value in result column\n \n-    auto * result = function.compile(b, std::move(arguments));\n-    auto * result_column_element_ptr = b.CreateGEP(columns.back().data_element_type, columns.back().data_ptr, counter_phi);\n+    auto * result = function.compile(b, arguments);\n+    auto * result_column_element_ptr = b.CreateInBoundsGEP(columns.back().data_element_type, columns.back().data_ptr, counter_phi);\n \n     if (columns.back().null_data_ptr)\n     {\n         b.CreateStore(b.CreateExtractValue(result, {0}), result_column_element_ptr);\n-        auto * result_column_is_null_element_ptr = b.CreateGEP(b.getInt8Ty(), columns.back().null_data_ptr, counter_phi);\n+        auto * result_column_is_null_element_ptr = b.CreateInBoundsGEP(b.getInt8Ty(), columns.back().null_data_ptr, counter_phi);\n         auto * is_result_column_element_null = b.CreateSelect(b.CreateExtractValue(result, {1}), b.getInt8(1), b.getInt8(0));\n         b.CreateStore(is_result_column_element_null, result_column_is_null_element_ptr);\n     }\n@@ -298,24 +300,24 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n     else\n         aggregation_place = places_arg;\n \n-    std::vector<llvm::Value *> function_arguments_values;\n+    ValuesWithType function_arguments;\n     previous_columns_size = 0;\n \n     for (const auto & function : functions)\n     {\n-        auto arguments_types = function.function->getArgumentTypes();\n+        const auto & arguments_types = function.function->getArgumentTypes();\n         size_t function_arguments_size = arguments_types.size();\n \n         for (size_t column_argument_index = 0; column_argument_index < function_arguments_size; ++column_argument_index)\n         {\n             auto & column = columns[previous_columns_size + column_argument_index];\n-            auto & argument_type = arguments_types[column_argument_index];\n+            const auto & argument_type = arguments_types[column_argument_index];\n \n             auto * column_data_element = b.CreateLoad(column.data_element_type, b.CreateGEP(column.data_element_type, column.data_ptr, counter_phi));\n \n             if (!argument_type->isNullable())\n             {\n-                function_arguments_values.push_back(column_data_element);\n+                function_arguments.emplace_back(column_data_element, argument_type);\n                 continue;\n             }\n \n@@ -324,16 +326,16 @@ static void compileAddIntoAggregateStatesFunctions(llvm::Module & module,\n             auto * nullable_unitialized = llvm::Constant::getNullValue(toNullableType(b, column.data_element_type));\n             auto * first_insert = b.CreateInsertValue(nullable_unitialized, column_data_element, {0});\n             auto * nullable_value = b.CreateInsertValue(first_insert, is_null, {1});\n-            function_arguments_values.push_back(nullable_value);\n+            function_arguments.emplace_back(nullable_value, argument_type);\n         }\n \n         size_t aggregate_function_offset = function.aggregate_data_offset;\n         auto * aggregation_place_with_offset = b.CreateConstInBoundsGEP1_64(b.getInt8Ty(), aggregation_place, aggregate_function_offset);\n \n         const auto * aggregate_function_ptr = function.function;\n-        aggregate_function_ptr->compileAdd(b, aggregation_place_with_offset, arguments_types, function_arguments_values);\n+        aggregate_function_ptr->compileAdd(b, aggregation_place_with_offset, function_arguments);\n \n-        function_arguments_values.clear();\n+        function_arguments.clear();\n \n         previous_columns_size += function_arguments_size;\n     }\ndiff --git a/src/Storages/MergeTree/ParallelReplicasReadingCoordinator.cpp b/src/Storages/MergeTree/ParallelReplicasReadingCoordinator.cpp\nindex bb044d15ba2d..2814d13cff01 100644\n--- a/src/Storages/MergeTree/ParallelReplicasReadingCoordinator.cpp\n+++ b/src/Storages/MergeTree/ParallelReplicasReadingCoordinator.cpp\n@@ -43,7 +43,7 @@ struct fmt::formatter<DB::Part>\n     template <typename FormatContext>\n     auto format(const DB::Part & part, FormatContext & ctx)\n     {\n-        return format_to(ctx.out(), \"{} in replicas [{}]\", part.description.describe(), fmt::join(part.replicas, \", \"));\n+        return fmt::format_to(ctx.out(), \"{} in replicas [{}]\", part.description.describe(), fmt::join(part.replicas, \", \"));\n     }\n };\n \ndiff --git a/src/Storages/MergeTree/RangesInDataPart.cpp b/src/Storages/MergeTree/RangesInDataPart.cpp\nindex 6203f9f74832..e64e9ab0b2a6 100644\n--- a/src/Storages/MergeTree/RangesInDataPart.cpp\n+++ b/src/Storages/MergeTree/RangesInDataPart.cpp\n@@ -15,7 +15,7 @@ struct fmt::formatter<DB::RangesInDataPartDescription>\n     template <typename FormatContext>\n     auto format(const DB::RangesInDataPartDescription & range, FormatContext & ctx)\n     {\n-        return format_to(ctx.out(), \"{}\", range.describe());\n+        return fmt::format_to(ctx.out(), \"{}\", range.describe());\n     }\n };\n \n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02771_jit_functions_comparison_crash.reference b/tests/queries/0_stateless/02771_jit_functions_comparison_crash.reference\nnew file mode 100644\nindex 000000000000..e69de29bb2d1\ndiff --git a/tests/queries/0_stateless/02771_jit_functions_comparison_crash.sql b/tests/queries/0_stateless/02771_jit_functions_comparison_crash.sql\nnew file mode 100644\nindex 000000000000..e02f1a3382d2\n--- /dev/null\n+++ b/tests/queries/0_stateless/02771_jit_functions_comparison_crash.sql\n@@ -0,0 +1,36 @@\n+SET compile_expressions = 1;\n+SET min_count_to_compile_expression = 0;\n+\n+DROP TABLE IF EXISTS test_table_1;\n+CREATE TABLE test_table_1\n+(\n+    pkey UInt32,\n+    c8 UInt32,\n+    c9 String,\n+    c10 Float32,\n+    c11 String\n+) ENGINE = MergeTree ORDER BY pkey;\n+\n+DROP TABLE IF EXISTS test_table_2;\n+CREATE TABLE test_table_2\n+(\n+    vkey UInt32,\n+    pkey UInt32,\n+    c15 UInt32\n+) ENGINE = MergeTree ORDER BY vkey;\n+\n+WITH test_cte AS\n+(\n+    SELECT\n+        ref_10.c11 as c_2_c2350_1,\n+        ref_9.c9 as c_2_c2351_2\n+    FROM\n+        test_table_1 as ref_9\n+        RIGHT OUTER JOIN test_table_1 as ref_10 ON (ref_9.c11 = ref_10.c9)\n+        INNER JOIN test_table_2 as ref_11 ON (ref_10.c8 = ref_11.vkey)\n+    WHERE ((ref_10.pkey + ref_11.pkey) BETWEEN ref_11.vkey AND (CASE WHEN (-30.87 >= ref_9.c10) THEN ref_11.c15 ELSE ref_11.pkey END))\n+)\n+SELECT ref_13.c_2_c2350_1 as c_2_c2357_3 FROM test_cte as ref_13 WHERE (ref_13.c_2_c2351_2) in (select ref_14.c_2_c2351_2 as c_5_c2352_0 FROM test_cte as ref_14);\n+\n+DROP TABLE test_table_1;\n+DROP TABLE test_table_2;\ndiff --git a/tests/queries/0_stateless/02772_jit_date_time_add.reference b/tests/queries/0_stateless/02772_jit_date_time_add.reference\nnew file mode 100644\nindex 000000000000..dec7d2fabd2e\n--- /dev/null\n+++ b/tests/queries/0_stateless/02772_jit_date_time_add.reference\n@@ -0,0 +1,1 @@\n+\\N\ndiff --git a/tests/queries/0_stateless/02772_jit_date_time_add.sql b/tests/queries/0_stateless/02772_jit_date_time_add.sql\nnew file mode 100644\nindex 000000000000..61028ac41722\n--- /dev/null\n+++ b/tests/queries/0_stateless/02772_jit_date_time_add.sql\n@@ -0,0 +1,6 @@\n+SET compile_expressions = 1;\n+SET min_count_to_compile_expression = 0;\n+\n+SELECT DISTINCT result FROM (SELECT toStartOfFifteenMinutes(toDateTime(toStartOfFifteenMinutes(toDateTime(1000.0001220703125) + (number * 65536))) + (number * 9223372036854775807)) AS result FROM system.numbers LIMIT 1048576) ORDER BY result DESC NULLS FIRST FORMAT Null; -- { serverError 407 }\n+SELECT DISTINCT result FROM (SELECT toStartOfFifteenMinutes(toDateTime(toStartOfFifteenMinutes(toDateTime(1000.0001220703125) + (number * 65536))) + toInt64(number * 9223372036854775807)) AS result FROM system.numbers LIMIT 1048576) ORDER BY result DESC NULLS FIRST FORMAT Null;\n+SELECT round(round(round(round(round(100)), round(round(round(round(NULL), round(65535)), toTypeName(now() + 9223372036854775807) LIKE 'DateTime%DateTime%DateTime%DateTime%', round(-2)), 255), round(NULL))));\n",
  "problem_statement": "Crash at llvm::X86InstrInfo::copyPhysReg\n**Describe what's wrong**\r\n\r\nThe SELECT statement makes the server crash.\r\n\r\n**Does it reproduce on recent release?**\r\n\r\nIt can be reproduced in the latest version.\r\n\r\n**How to reproduce**\r\n\r\nVersion: 23.5.1 (commit 806ef08e5f6b3fc93993d19aac505290e9bfa554)\r\n\r\nEasy reproduce in ClickHouse fiddle: https://fiddle.clickhouse.com/d399218b-824f-41b9-9d6e-fb824152c759\r\n\r\n_Set up database_\r\n\r\n```sql\r\ncreate table t1 (pkey UInt32, c8 UInt32, c9 String, c10 Float32, c11 String, primary key(c8)) engine = ReplacingMergeTree;\r\ncreate table t3 (vkey UInt32, pkey UInt32, c15 UInt32) engine = Log;\r\n```\r\n\r\n_Bug-triggering query_\r\n\r\n```sql\r\nwith cte_4 as (\r\n  select  \r\n    ref_10.c11 as c_2_c2350_1, \r\n    ref_9.c9 as c_2_c2351_2\r\n  from \r\n    t1 as ref_9\r\n          right outer join t1 as ref_10\r\n          on (ref_9.c11 = ref_10.c9)\r\n        inner join t3 as ref_11\r\n        on (ref_10.c8 = ref_11.vkey)\r\n  where ((ref_10.pkey + ref_11.pkey) between ref_11.vkey and (case when (-30.87 >= ref_9.c10) then ref_11.c15 else ref_11.pkey end)))\r\nselect  \r\n    ref_13.c_2_c2350_1 as c_2_c2357_3\r\n  from \r\n    cte_4 as ref_13\r\n  where (ref_13.c_2_c2351_2) in (\r\n        select  \r\n          ref_14.c_2_c2351_2 as c_5_c2352_0\r\n        from \r\n          cte_4 as ref_14);\r\n```\r\n\r\n**Expected behavior**\r\n\r\nNo crash.\r\n\r\n**Actual behavior**\r\n\r\nThe server crashes.\r\n\r\nThe log:\r\n\r\n```\r\n[a42dd51a4b55] 2023.05.29 17:47:57.669009 [ 1780230 ] <Fatal> BaseDaemon: ########################################\r\n[a42dd51a4b55] 2023.05.29 17:47:57.669257 [ 1780230 ] <Fatal> BaseDaemon: (version 23.5.1.1, build id: 91219368B241C6A86EEC6081927CBB6262DAE94A) (from thread 1779924) (query_id: 925605fe-1d79-40fd-8e27-39136e849fa0) (query: with cte_4 as (\r\n  select  \r\n    ref_10.c11 as c_2_c2350_1, \r\n    ref_9.c9 as c_2_c2351_2\r\n  from \r\n    t1 as ref_9\r\n          right outer join t1 as ref_10\r\n          on (ref_9.c11 = ref_10.c9)\r\n        inner join t3 as ref_11\r\n        on (ref_10.c8 = ref_11.vkey)\r\n  where ((ref_10.pkey + ref_11.pkey) between ref_11.vkey and (case when (-30.87 >= ref_9.c10) then ref_11.c15 else ref_11.pkey end)))\r\nselect  \r\n    ref_13.c_2_c2350_1 as c_2_c2357_3\r\n  from \r\n    cte_4 as ref_13\r\n  where (ref_13.c_2_c2351_2) in (\r\n        select  \r\n          ref_14.c_2_c2351_2 as c_5_c2352_0\r\n        from \r\n          cte_4 as ref_14);) Received signal Aborted (6)\r\n[a42dd51a4b55] 2023.05.29 17:47:57.669393 [ 1780230 ] <Fatal> BaseDaemon: \r\n[a42dd51a4b55] 2023.05.29 17:47:57.669460 [ 1780230 ] <Fatal> BaseDaemon: Stack trace: 0x00007f569f5f500b 0x00007f569f5d4859 0x000000001a294cd8 0x000000001a294b86 0x0000000018e3f1b5 0x000000001955baa5 0x00000000193a3f4c 0x000000001a1a8b8a 0x000000001a1b0793 0x000000001a1a97a8 0x00000000174b0eea 0x00000000174afd3c 0x00000000174afa57 0x00000000174bb69e 0x0000000016bc5e06 0x00000000166d4b29 0x0000000016852bfc 0x00000000184348f9 0x000000001843758b 0x000000001844d623 0x00000000171690c3 0x000000001742aee7 0x00000000174281ef 0x00000000180bde24 0x00000000180ce159 0x000000001a68b547 0x000000001a68ba2d 0x000000001a7f2727 0x000000001a7f0342 0x00007f569f7ac609 0x00007f569f6d1133\r\n[a42dd51a4b55] 2023.05.29 17:47:57.669540 [ 1780230 ] <Fatal> BaseDaemon: 3. raise @ 0x00007f569f5f500b in ?\r\n[a42dd51a4b55] 2023.05.29 17:47:57.669604 [ 1780230 ] <Fatal> BaseDaemon: 4. abort @ 0x00007f569f5d4859 in ?\r\n[a42dd51a4b55] 2023.05.29 17:47:59.098108 [ 1780230 ] <Fatal> BaseDaemon: 5. llvm::report_fatal_error(llvm::Twine const&, bool) @ 0x000000001a294cd8 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:00.516065 [ 1780230 ] <Fatal> BaseDaemon: 6. ? @ 0x000000001a294b86 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:01.869262 [ 1780230 ] <Fatal> BaseDaemon: 7. llvm::X86InstrInfo::copyPhysReg(llvm::MachineBasicBlock&, llvm::MachineInstrBundleIterator<llvm::MachineInstr, false>, llvm::DebugLoc const&, llvm::MCRegister, llvm::MCRegister, bool) const @ 0x0000000018e3f1b5 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:03.209189 [ 1780230 ] <Fatal> BaseDaemon: 8. (anonymous namespace)::ExpandPostRA::runOnMachineFunction(llvm::MachineFunction&) @ 0x000000001955baa5 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:04.634853 [ 1780230 ] <Fatal> BaseDaemon: 9. llvm::MachineFunctionPass::runOnFunction(llvm::Function&) @ 0x00000000193a3f4c in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:05.983760 [ 1780230 ] <Fatal> BaseDaemon: 10. llvm::FPPassManager::runOnFunction(llvm::Function&) @ 0x000000001a1a8b8a in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:07.316860 [ 1780230 ] <Fatal> BaseDaemon: 11. llvm::FPPassManager::runOnModule(llvm::Module&) @ 0x000000001a1b0793 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:08.701261 [ 1780230 ] <Fatal> BaseDaemon: 12. llvm::legacy::PassManagerImpl::run(llvm::Module&) @ 0x000000001a1a97a8 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:08.741010 [ 1780230 ] <Fatal> BaseDaemon: 13. ./build/./src/Interpreters/JIT/CHJIT.cpp:0: DB::JITCompiler::compile(llvm::Module&) @ 0x00000000174b0eea in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:08.778865 [ 1780230 ] <Fatal> BaseDaemon: 14. ./build/./src/Interpreters/JIT/CHJIT.cpp:0: DB::CHJIT::compileModule(std::unique_ptr<llvm::Module, std::default_delete<llvm::Module>>) @ 0x00000000174afd3c in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:08.811988 [ 1780230 ] <Fatal> BaseDaemon: 15. ./build/./src/Interpreters/JIT/CHJIT.cpp:361: DB::CHJIT::compileModule(std::function<void (llvm::Module&)>) @ 0x00000000174afa57 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:08.843042 [ 1780230 ] <Fatal> BaseDaemon: 16.1. inlined from ./build/./contrib/llvm-project/libcxx/include/__functional/function.h:818: ~__policy_func\r\n[a42dd51a4b55] 2023.05.29 17:48:08.843208 [ 1780230 ] <Fatal> BaseDaemon: 16.2. inlined from ./build/./contrib/llvm-project/libcxx/include/__functional/function.h:1174: ~function\r\n[a42dd51a4b55] 2023.05.29 17:48:08.843259 [ 1780230 ] <Fatal> BaseDaemon: 16. ./build/./src/Interpreters/JIT/compileFunction.cpp:167: DB::compileFunction(DB::CHJIT&, DB::IFunctionBase const&) @ 0x00000000174bb69e in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:08.881692 [ 1780230 ] <Fatal> BaseDaemon: 17.1. inlined from ./build/./contrib/llvm-project/libcxx/include/new:246: void* std::__libcpp_operator_new[abi:v15000]<unsigned long>(unsigned long)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.881856 [ 1780230 ] <Fatal> BaseDaemon: 17.2. inlined from ./build/./contrib/llvm-project/libcxx/include/new:272: std::__libcpp_allocate[abi:v15000](unsigned long, unsigned long)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.881956 [ 1780230 ] <Fatal> BaseDaemon: 17.3. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/allocator.h:112: std::allocator<std::__shared_ptr_emplace<DB::CompiledFunctionHolder, std::allocator<DB::CompiledFunctionHolder>>>::allocate[abi:v15000](unsigned long)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882017 [ 1780230 ] <Fatal> BaseDaemon: 17.4. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/allocator_traits.h:262: std::allocator_traits<std::allocator<std::__shared_ptr_emplace<DB::CompiledFunctionHolder, std::allocator<DB::CompiledFunctionHolder>>>>::allocate[abi:v15000](std::allocator<std::__shared_ptr_emplace<DB::CompiledFunctionHolder, std::allocator<DB::CompiledFunctionHolder>>>&, unsigned long)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882079 [ 1780230 ] <Fatal> BaseDaemon: 17.5. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/allocation_guard.h:53: __allocation_guard<std::allocator<DB::CompiledFunctionHolder> >\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882136 [ 1780230 ] <Fatal> BaseDaemon: 17.6. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:952: std::shared_ptr<DB::CompiledFunctionHolder> std::allocate_shared[abi:v15000]<DB::CompiledFunctionHolder, std::allocator<DB::CompiledFunctionHolder>, DB::CompiledFunction&, void>(std::allocator<DB::CompiledFunctionHolder> const&, DB::CompiledFunction&)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882201 [ 1780230 ] <Fatal> BaseDaemon: 17.7. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/shared_ptr.h:962: std::shared_ptr<DB::CompiledFunctionHolder> std::make_shared[abi:v15000]<DB::CompiledFunctionHolder, DB::CompiledFunction&, void>(DB::CompiledFunction&)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882256 [ 1780230 ] <Fatal> BaseDaemon: 17.8. inlined from ./build/./src/Interpreters/ExpressionJIT.cpp:304: operator()\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882311 [ 1780230 ] <Fatal> BaseDaemon: 17.9. inlined from ./build/./src/Common/CacheBase.h:148: std::pair<std::shared_ptr<DB::CompiledExpressionCacheEntry>, bool> DB::CacheBase<wide::integer<128ul, unsigned int>, DB::CompiledExpressionCacheEntry, UInt128Hash, DB::CompiledFunctionWeightFunction>::getOrSet<DB::compile(DB::CompileDAG const&, unsigned long)::$_0>(wide::integer<128ul, unsigned int> const&, DB::compile(DB::CompileDAG const&, unsigned long)::$_0&&)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882380 [ 1780230 ] <Fatal> BaseDaemon: 17.10. inlined from ./build/./src/Interpreters/ExpressionJIT.cpp:300: DB::compile(DB::CompileDAG const&, unsigned long)\r\n[a42dd51a4b55] 2023.05.29 17:48:08.882459 [ 1780230 ] <Fatal> BaseDaemon: 17. ./build/./src/Interpreters/ExpressionJIT.cpp:593: DB::ActionsDAG::compileFunctions(unsigned long, std::unordered_set<DB::ActionsDAG::Node const*, std::hash<DB::ActionsDAG::Node const*>, std::equal_to<DB::ActionsDAG::Node const*>, std::allocator<DB::ActionsDAG::Node const*>> const&) @ 0x0000000016bc5e06 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.196679 [ 1780230 ] <Fatal> BaseDaemon: 18. ./build/./src/Interpreters/ActionsDAG.cpp:1070: DB::ActionsDAG::compileExpressions(unsigned long, std::unordered_set<DB::ActionsDAG::Node const*, std::hash<DB::ActionsDAG::Node const*>, std::equal_to<DB::ActionsDAG::Node const*>, std::allocator<DB::ActionsDAG::Node const*>> const&) @ 0x00000000166d4b29 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.262428 [ 1780230 ] <Fatal> BaseDaemon: 19. ./build/./src/Interpreters/ExpressionActions.cpp:0: DB::ExpressionActions::ExpressionActions(std::shared_ptr<DB::ActionsDAG>, DB::ExpressionActionsSettings const&) @ 0x0000000016852bfc in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.286035 [ 1780230 ] <Fatal> BaseDaemon: 20. ./build/./src/Processors/QueryPlan/FilterStep.cpp:57: DB::FilterStep::transformPipeline(DB::QueryPipelineBuilder&, DB::BuildQueryPipelineSettings const&) @ 0x00000000184348f9 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.303390 [ 1780230 ] <Fatal> BaseDaemon: 21. ./build/./src/Processors/QueryPlan/ITransformingStep.cpp:0: DB::ITransformingStep::updatePipeline(std::vector<std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>, std::allocator<std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>>>, DB::BuildQueryPipelineSettings const&) @ 0x000000001843758b in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.347798 [ 1780230 ] <Fatal> BaseDaemon: 22.1. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:302: std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>::reset[abi:v15000](DB::QueryPipelineBuilder*)\r\n[a42dd51a4b55] 2023.05.29 17:48:09.347968 [ 1780230 ] <Fatal> BaseDaemon: 22.2. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:225: std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>::operator=[abi:v15000](std::unique_ptr<DB::QueryPipelineBuilder, std::default_delete<DB::QueryPipelineBuilder>>&&)\r\n[a42dd51a4b55] 2023.05.29 17:48:09.348027 [ 1780230 ] <Fatal> BaseDaemon: 22. ./build/./src/Processors/QueryPlan/QueryPlan.cpp:189: DB::QueryPlan::buildQueryPipeline(DB::QueryPlanOptimizationSettings const&, DB::BuildQueryPipelineSettings const&) @ 0x000000001844d623 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.403658 [ 1780230 ] <Fatal> BaseDaemon: 23. ./build/./src/Interpreters/InterpreterSelectWithUnionQuery.cpp:379: DB::InterpreterSelectWithUnionQuery::execute() @ 0x00000000171690c3 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.494530 [ 1780230 ] <Fatal> BaseDaemon: 24. ./build/./src/Interpreters/executeQuery.cpp:0: DB::executeQueryImpl(char const*, char const*, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum, DB::ReadBuffer*) @ 0x000000001742aee7 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.595519 [ 1780230 ] <Fatal> BaseDaemon: 25. ./build/./src/Interpreters/executeQuery.cpp:1180: DB::executeQuery(String const&, std::shared_ptr<DB::Context>, bool, DB::QueryProcessingStage::Enum) @ 0x00000000174281ef in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.666398 [ 1780230 ] <Fatal> BaseDaemon: 26. ./build/./src/Server/TCPHandler.cpp:0: DB::TCPHandler::runImpl() @ 0x00000000180bde24 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.781625 [ 1780230 ] <Fatal> BaseDaemon: 27. ./build/./src/Server/TCPHandler.cpp:2045: DB::TCPHandler::run() @ 0x00000000180ce159 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.785181 [ 1780230 ] <Fatal> BaseDaemon: 28. ./build/./base/poco/Net/src/TCPServerConnection.cpp:57: Poco::Net::TCPServerConnection::start() @ 0x000000001a68b547 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.790956 [ 1780230 ] <Fatal> BaseDaemon: 29.1. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:48: std::default_delete<Poco::Net::TCPServerConnection>::operator()[abi:v15000](Poco::Net::TCPServerConnection*) const\r\n[a42dd51a4b55] 2023.05.29 17:48:09.791106 [ 1780230 ] <Fatal> BaseDaemon: 29.2. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:305: std::unique_ptr<Poco::Net::TCPServerConnection, std::default_delete<Poco::Net::TCPServerConnection>>::reset[abi:v15000](Poco::Net::TCPServerConnection*)\r\n[a42dd51a4b55] 2023.05.29 17:48:09.791166 [ 1780230 ] <Fatal> BaseDaemon: 29.3. inlined from ./build/./contrib/llvm-project/libcxx/include/__memory/unique_ptr.h:259: ~unique_ptr\r\n[a42dd51a4b55] 2023.05.29 17:48:09.791221 [ 1780230 ] <Fatal> BaseDaemon: 29. ./build/./base/poco/Net/src/TCPServerDispatcher.cpp:116: Poco::Net::TCPServerDispatcher::run() @ 0x000000001a68ba2d in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.797885 [ 1780230 ] <Fatal> BaseDaemon: 30. ./build/./base/poco/Foundation/src/ThreadPool.cpp:202: Poco::PooledThread::run() @ 0x000000001a7f2727 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.803906 [ 1780230 ] <Fatal> BaseDaemon: 31.1. inlined from ./build/./base/poco/Foundation/include/Poco/SharedPtr.h:139: Poco::SharedPtr<Poco::Runnable, Poco::ReferenceCounter, Poco::ReleasePolicy<Poco::Runnable>>::assign(Poco::Runnable*)\r\n[a42dd51a4b55] 2023.05.29 17:48:09.804065 [ 1780230 ] <Fatal> BaseDaemon: 31.2. inlined from ./build/./base/poco/Foundation/include/Poco/SharedPtr.h:180: Poco::SharedPtr<Poco::Runnable, Poco::ReferenceCounter, Poco::ReleasePolicy<Poco::Runnable>>::operator=(Poco::Runnable*)\r\n[a42dd51a4b55] 2023.05.29 17:48:09.804116 [ 1780230 ] <Fatal> BaseDaemon: 31. ./build/./base/poco/Foundation/src/Thread_POSIX.cpp:350: Poco::ThreadImpl::runnableEntry(void*) @ 0x000000001a7f0342 in /usr/bin/clickhouse\r\n[a42dd51a4b55] 2023.05.29 17:48:09.804233 [ 1780230 ] <Fatal> BaseDaemon: 32. ? @ 0x00007f569f7ac609 in ?\r\n[a42dd51a4b55] 2023.05.29 17:48:09.804315 [ 1780230 ] <Fatal> BaseDaemon: 33. clone @ 0x00007f569f6d1133 in ?\r\n[a42dd51a4b55] 2023.05.29 17:48:09.804386 [ 1780230 ] <Fatal> BaseDaemon: Integrity check of the executable skipped because the reference checksum could not be read.\r\nError on processing query: Code: 32. DB::Exception: Attempt to read after eof: while receiving packet from localhost:9000. (ATTEMPT_TO_READ_AFTER_EOF) (version 23.5.1.1)\r\n(query: with cte_4 as (\r\n  select  \r\n    ref_10.c11 as c_2_c2350_1, \r\n    ref_9.c9 as c_2_c2351_2\r\n  from \r\n    t1 as ref_9\r\n          right outer join t1 as ref_10\r\n          on (ref_9.c11 = ref_10.c9)\r\n        inner join t3 as ref_11\r\n        on (ref_10.c8 = ref_11.vkey)\r\n  where ((ref_10.pkey + ref_11.pkey) between ref_11.vkey and (case when (-30.87 >= ref_9.c10) then ref_11.c15 else ref_11.pkey end)))\r\nselect  \r\n    ref_13.c_2_c2350_1 as c_2_c2357_3\r\n  from \r\n    cte_4 as ref_13\r\n  where (ref_13.c_2_c2351_2) in (\r\n        select  \r\n          ref_14.c_2_c2351_2 as c_5_c2352_0\r\n        from \r\n          cte_4 as ref_14);)\r\n```\r\n**Additional context**\r\n\r\nThe earliest reproducible version is 22.10 in fiddle: https://fiddle.clickhouse.com/3e5f6a67-80cf-415e-bfc1-d5f18cbf4313\r\n\r\n\r\n\r\n\r\n\n01680_date_time_add_ubsan is flaky (due to a bug in JIT)\nSeems everything was fine until yesterday:\r\n\r\n```\r\nSELECT\r\n  toStartOfDay(check_start_time) as t,\r\n  count() as runs,\r\n  100 * countIf(test_status != 'OK') / runs as failure_percentage\r\nFROM checks\r\nWHERE\r\n    test_name = '01680_date_time_add_ubsan'\r\n    AND pull_request_number = 0\r\n    AND check_start_time > today() - interval 30 day\r\nGROUP BY t\r\nORDER by t\r\n```\r\n\r\n\r\n\r\n\u2116 | t | runs | failure_percentage\r\n-- | -- | -- | --\r\n1 | 2023-03-01 00:00:00 | 190 | 0\r\n2 | 2023-03-02 00:00:00 | 198 | 0\r\n3 | 2023-03-03 00:00:00 | 219 | 0\r\n4 | 2023-03-04 00:00:00 | 61 | 0\r\n5 | 2023-03-05 00:00:00 | 50 | 0\r\n6 | 2023-03-06 00:00:00 | 82 | 0\r\n7 | 2023-03-07 00:00:00 | 158 | 0\r\n8 | 2023-03-08 00:00:00 | 265 | 0\r\n9 | 2023-03-09 00:00:00 | 176 | 0\r\n10 | 2023-03-10 00:00:00 | 150 | 0\r\n11 | 2023-03-11 00:00:00 | 107 | 0\r\n12 | 2023-03-12 00:00:00 | 66 | 0\r\n13 | 2023-03-13 00:00:00 | 83 | 0\r\n14 | 2023-03-14 00:00:00 | 166 | 0\r\n15 | 2023-03-15 00:00:00 | 210 | 0\r\n16 | 2023-03-16 00:00:00 | 133 | 0\r\n17 | 2023-03-17 00:00:00 | 166 | 0\r\n18 | 2023-03-18 00:00:00 | 190 | 0\r\n19 | 2023-03-19 00:00:00 | 50 | 0\r\n20 | 2023-03-20 00:00:00 | 202 | 0\r\n21 | 2023-03-21 00:00:00 | 228 | 0\r\n22 | 2023-03-22 00:00:00 | 237 | 0\r\n23 | 2023-03-23 00:00:00 | 198 | 0\r\n24 | 2023-03-24 00:00:00 | 211 | 0\r\n25 | 2023-03-25 00:00:00 | 88 | 0\r\n26 | 2023-03-26 00:00:00 | 79 | 0\r\n27 | 2023-03-27 00:00:00 | 209 | 0\r\n28 | 2023-03-28 00:00:00 | 245 | 0\r\n29 | 2023-03-29 00:00:00 | 260 | 0\r\n30 | 2023-03-30 00:00:00 | 339 | 0.2949852507374631\r\n31 | 2023-03-31 00:00:00 | 120 | 19.166666666666668\r\n\r\n\r\nExample: https://s3.amazonaws.com/clickhouse-test-reports/0/8994305fb3364098b2ce43fc5d92fb1196e6df43/stateless_tests__release__databaseordinary_.html\r\n\r\n```\r\n2023-03-31 05:47:04 The query succeeded but the server error '407' was expected (query: SELECT DISTINCT result FROM (SELECT toStartOfFifteenMinutes(toDateTime(toStartOfFifteenMinutes(toDateTime(1000.0001220703125) + (number * 65536))) + (number * 9223372036854775807)) AS result FROM system.numbers LIMIT 1048576) ORDER BY result DESC NULLS FIRST FORMAT Null; -- { serverError 407 }).\r\n2023-03-31 05:47:04 \r\n2023-03-31 05:47:04 stdout:\r\n2023-03-31 05:47:04 \\N\r\n2023-03-31 05:47:04 \r\n2023-03-31 05:47:04 Settings used in the test: --max_insert_threads=11 --group_by_two_level_threshold=29673 --group_by_two_level_threshold_bytes=43004415 --distributed_aggregation_memory_efficient=0 --fsync_metadata=0 --output_format_parallel_formatting=1 --input_format_parallel_parsing=1 --min_chunk_bytes_for_parallel_parsing=7451526 --max_read_buffer_size=943333 --prefer_localhost_replica=0 --max_block_size=72709 --max_threads=45 --optimize_or_like_chain=0 --optimize_read_in_order=0 --read_in_order_two_level_merge_threshold=69 --optimize_aggregation_in_order=1 --aggregation_in_order_max_block_bytes=35738655 --min_compress_block_size=1648817 --max_compress_block_size=290228 --use_uncompressed_cache=0 --min_bytes_to_use_direct_io=10312023578 --min_bytes_to_use_mmap_io=139391117 --local_filesystem_read_method=pread --remote_filesystem_read_method=threadpool --local_filesystem_read_prefetch=0 --remote_filesystem_read_prefetch=0 --compile_expressions=1 --compile_aggregate_expressions=0 --compile_sort_description=1 --merge_tree_coarse_index_granularity=3 --optimize_distinct_in_order=0 --optimize_sorting_by_input_stream_properties=1 --http_response_buffer_size=4866157 --http_wait_end_of_query=False --enable_memory_bound_merging_of_aggregation_results=1 --min_count_to_compile_expression=0 --min_count_to_compile_aggregate_expression=0 --min_count_to_compile_sort_description=0\r\n2023-03-31 05:47:04 \r\n2023-03-31 05:47:04 MergeTree settings used in test: --ratio_of_defaults_for_sparse_serialization=1.0 --prefer_fetch_merged_part_size_threshold=2987423327 --vertical_merge_algorithm_min_rows_to_activate=1 --vertical_merge_algorithm_min_columns_to_activate=63 --min_merge_bytes_to_use_direct_io=10737418240 --index_granularity_bytes=25281005 --merge_max_block_size=14399 --index_granularity=63978 --min_bytes_for_wide_part=1073741824\r\n2023-03-31 05:47:04 \r\n2023-03-31 05:47:04 Database: test_zqfna9mk\r\n```\r\n\n",
  "hints_text": "\n",
  "created_at": "2023-06-03T18:32:59Z"
}