{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 58731,
  "instance_id": "ClickHouse__ClickHouse-58731",
  "issue_numbers": [
    "58149"
  ],
  "base_commit": "9cfdff2ddb280b5db537d210e76e4a606878e460",
  "patch": "diff --git a/src/Common/ICachePolicyUserQuota.h b/src/Common/ICachePolicyUserQuota.h\nindex 6fa4f7947cb1..d6555785f4a4 100644\n--- a/src/Common/ICachePolicyUserQuota.h\n+++ b/src/Common/ICachePolicyUserQuota.h\n@@ -25,6 +25,9 @@ class ICachePolicyUserQuota\n     /// Is the user allowed to write a new entry into the cache?\n     virtual bool approveWrite(const UUID & user_id, size_t entry_size_in_bytes) const = 0;\n \n+    /// Clears the policy contents\n+    virtual void clear() = 0;\n+\n     virtual ~ICachePolicyUserQuota() = default;\n };\n \n@@ -38,6 +41,7 @@ class NoCachePolicyUserQuota : public ICachePolicyUserQuota\n     void increaseActual(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) override {}\n     void decreaseActual(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) override {}\n     bool approveWrite(const UUID & /*user_id*/, size_t /*entry_size_in_bytes*/) const override { return true; }\n+    void clear() override {}\n };\n \n \ndiff --git a/src/Common/TTLCachePolicy.h b/src/Common/TTLCachePolicy.h\nindex 338cc543385a..8960b742c74f 100644\n--- a/src/Common/TTLCachePolicy.h\n+++ b/src/Common/TTLCachePolicy.h\n@@ -38,12 +38,12 @@ class PerUserTTLCachePolicyUserQuota : public ICachePolicyUserQuota\n     bool approveWrite(const UUID & user_id, size_t entry_size_in_bytes) const override\n     {\n         auto it_actual = actual.find(user_id);\n-        Resources actual_for_user{.size_in_bytes = 0, .num_items = 0}; /// assume zero actual resource consumption is user isn't found\n+        Resources actual_for_user{.size_in_bytes = 0, .num_items = 0}; /// if no user is found, the default is no resource consumption\n         if (it_actual != actual.end())\n             actual_for_user = it_actual->second;\n \n         auto it_quota = quotas.find(user_id);\n-        Resources quota_for_user{.size_in_bytes = std::numeric_limits<size_t>::max(), .num_items = std::numeric_limits<size_t>::max()}; /// assume no threshold if no quota is found\n+        Resources quota_for_user{.size_in_bytes = std::numeric_limits<size_t>::max(), .num_items = std::numeric_limits<size_t>::max()}; /// if no user is found, the default is no threshold\n         if (it_quota != quotas.end())\n             quota_for_user = it_quota->second;\n \n@@ -54,16 +54,21 @@ class PerUserTTLCachePolicyUserQuota : public ICachePolicyUserQuota\n             quota_for_user.num_items = std::numeric_limits<UInt64>::max();\n \n         /// Check size quota\n-        if (actual_for_user.size_in_bytes + entry_size_in_bytes >= quota_for_user.size_in_bytes)\n+        if (actual_for_user.size_in_bytes + entry_size_in_bytes > quota_for_user.size_in_bytes)\n             return false;\n \n         /// Check items quota\n-        if (quota_for_user.num_items + 1 >= quota_for_user.num_items)\n+        if (actual_for_user.num_items + 1 > quota_for_user.num_items)\n             return false;\n \n         return true;\n     }\n \n+    void clear() override\n+    {\n+        actual.clear();\n+    }\n+\n     struct Resources\n     {\n         size_t size_in_bytes = 0;\n@@ -125,6 +130,7 @@ class TTLCachePolicy : public ICachePolicy<Key, Mapped, HashFunction, WeightFunc\n     void clear() override\n     {\n         cache.clear();\n+        Base::user_quotas->clear();\n     }\n \n     void remove(const Key & key) override\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/02494_query_cache_user_quotas_after_drop.reference b/tests/queries/0_stateless/02494_query_cache_user_quotas_after_drop.reference\nnew file mode 100644\nindex 000000000000..5bfc400b254c\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_user_quotas_after_drop.reference\n@@ -0,0 +1,13 @@\n+a\n+b\n+1\n+c\n+d\n+3\n+--\n+a\n+b\n+1\n+c\n+d\n+3\ndiff --git a/tests/queries/0_stateless/02494_query_cache_user_quotas_after_drop.sql b/tests/queries/0_stateless/02494_query_cache_user_quotas_after_drop.sql\nnew file mode 100644\nindex 000000000000..f09e43ee0520\n--- /dev/null\n+++ b/tests/queries/0_stateless/02494_query_cache_user_quotas_after_drop.sql\n@@ -0,0 +1,41 @@\n+-- Tags: no-parallel\n+-- Tag no-parallel: Messes with internal cache\n+\n+-- Tests per-user quotas of the query cache. Settings 'query_cache_max_size_in_bytes' and 'query_cache_max_entries' are actually supposed to\n+-- be used in a settings profile, together with a readonly constraint. For simplicity, test both settings stand-alone in a stateless test\n+-- instead of an integration test - the relevant logic will still be covered by that.\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+-- Run SELECT with quota that current user may write only 1 entry in the query cache\n+SET query_cache_max_entries = 1;\n+SELECT 'a' SETTINGS use_query_cache = true;\n+SELECT 'b' SETTINGS use_query_cache = true;\n+SELECT count(*) FROM system.query_cache; -- expect 1 entry\n+\n+-- Run SELECTs again but w/o quota\n+SET query_cache_max_entries = DEFAULT;\n+SELECT 'c' SETTINGS use_query_cache = true;\n+SELECT 'd' SETTINGS use_query_cache = true;\n+SELECT count(*) FROM system.query_cache; -- expect 3 entries\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+-- Run the same as above after a DROP QUERY CACHE.\n+SELECT '--';\n+\n+SET query_cache_max_entries = 1;\n+SELECT 'a' SETTINGS use_query_cache = true;\n+SELECT 'b' SETTINGS use_query_cache = true;\n+SELECT count(*) FROM system.query_cache; -- expect 1 entry\n+\n+-- Run SELECTs again but w/o quota\n+SET query_cache_max_entries = DEFAULT;\n+SELECT 'c' SETTINGS use_query_cache = true;\n+SELECT 'd' SETTINGS use_query_cache = true;\n+SELECT count(*) FROM system.query_cache; -- expect 3 entries\n+\n+SYSTEM DROP QUERY CACHE;\n+\n+-- SELECT '---';\n+\n",
  "problem_statement": "is query_cache_max_entries working?\nversion 23.11.3.23  \r\n\r\nThis one is a bit odd. I swear I saw it working ONCE, but never after this again. Restarting clickhouse-server doesn't help. I hope this is reproducible this way:\r\n\r\n```sql\r\nsystem drop query cache;\r\nset query_cache_max_entries = 0; -- default setting\r\nselect 1 settings use_query_cache=1;\r\nselect 2 settings use_query_cache=1;\r\nset query_cache_max_entries = 3;\r\nselect 3 settings use_query_cache=1;\r\nselect 4 settings use_query_cache=1;\r\nselect * from system.query_cache;\r\n```\r\n\r\nThe cache should now show 3 entries. (I believe this was also the case for me).\r\nNow repeat the same procedure (dropping query cache also first). And the cache will remain empty. After this only `set query_cache_max_entries = 0;` will store new entries in the cache.\r\n\r\nIs anyone seeing this behavior as well?\r\n\r\n\r\n\n",
  "hints_text": "",
  "created_at": "2024-01-11T23:22:58Z"
}