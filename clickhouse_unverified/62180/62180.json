{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 62180,
  "instance_id": "ClickHouse__ClickHouse-62180",
  "issue_numbers": [
    "35215"
  ],
  "base_commit": "b6d46317d1bd9fd88aebdddf55d1c0046321de69",
  "patch": "diff --git a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\nindex b40fea47b3cc..64111602458f 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeUseAggregateProjection.cpp\n@@ -432,13 +432,12 @@ AggregateProjectionCandidates getAggregateProjectionCandidates(\n {\n     const auto & keys = aggregating.getParams().keys;\n     const auto & aggregates = aggregating.getParams().aggregates;\n-    Block key_virtual_columns = reading.getMergeTreeData().getHeaderWithVirtualsForFilter();\n+    const auto metadata = reading.getStorageMetadata();\n+    Block key_virtual_columns = reading.getMergeTreeData().getHeaderWithVirtualsForFilter(metadata);\n \n     AggregateProjectionCandidates candidates;\n \n     const auto & parts = reading.getParts();\n-\n-    const auto metadata = reading.getStorageMetadata();\n     ContextPtr context = reading.getContext();\n \n     const auto & projections = metadata->projections;\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex bee42c3dddec..6bdd060513c9 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -1415,7 +1415,8 @@ static void buildIndexes(\n         indexes->partition_pruner.emplace(metadata_snapshot, filter_actions_dag, context, false /* strict */);\n     }\n \n-    indexes->part_values = MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(data, parts, filter_actions_dag, context);\n+    indexes->part_values\n+        = MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(metadata_snapshot, data, parts, filter_actions_dag, context);\n     MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(indexes->part_offset_condition, filter_actions_dag, context);\n \n     indexes->use_skip_indexes = settings.use_skip_indexes;\ndiff --git a/src/Storages/MergeTree/MergeTreeData.cpp b/src/Storages/MergeTree/MergeTreeData.cpp\nindex 5d4c3ab078e5..a948d80396a7 100644\n--- a/src/Storages/MergeTree/MergeTreeData.cpp\n+++ b/src/Storages/MergeTree/MergeTreeData.cpp\n@@ -1031,19 +1031,26 @@ void MergeTreeData::MergingParams::check(const StorageInMemoryMetadata & metadat\n \n const Names MergeTreeData::virtuals_useful_for_filter = {\"_part\", \"_partition_id\", \"_part_uuid\", \"_partition_value\", \"_part_data_version\"};\n \n-Block MergeTreeData::getHeaderWithVirtualsForFilter() const\n+Block MergeTreeData::getHeaderWithVirtualsForFilter(const StorageMetadataPtr & metadata) const\n {\n+    const auto columns = metadata->getColumns().getAllPhysical();\n     Block header;\n     auto virtuals_desc = getVirtualsPtr();\n     for (const auto & name : virtuals_useful_for_filter)\n+    {\n+        if (columns.contains(name))\n+            continue;\n         if (auto column = virtuals_desc->tryGet(name))\n             header.insert({column->type->createColumn(), column->type, name});\n+    }\n+\n     return header;\n }\n \n-Block MergeTreeData::getBlockWithVirtualsForFilter(const MergeTreeData::DataPartsVector & parts, bool ignore_empty) const\n+Block MergeTreeData::getBlockWithVirtualsForFilter(\n+    const StorageMetadataPtr & metadata, const MergeTreeData::DataPartsVector & parts, bool ignore_empty) const\n {\n-    auto block = getHeaderWithVirtualsForFilter();\n+    auto block = getHeaderWithVirtualsForFilter(metadata);\n \n     for (const auto & part_or_projection : parts)\n     {\n@@ -1072,7 +1079,7 @@ std::optional<UInt64> MergeTreeData::totalRowsByPartitionPredicateImpl(\n         return 0;\n \n     auto metadata_snapshot = getInMemoryMetadataPtr();\n-    auto virtual_columns_block = getBlockWithVirtualsForFilter({parts[0]});\n+    auto virtual_columns_block = getBlockWithVirtualsForFilter(metadata_snapshot, {parts[0]});\n \n     auto filter_dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(filter_actions_dag->getOutputs().at(0), nullptr);\n     if (!filter_dag)\n@@ -1091,7 +1098,7 @@ std::optional<UInt64> MergeTreeData::totalRowsByPartitionPredicateImpl(\n     std::unordered_set<String> part_values;\n     if (valid)\n     {\n-        virtual_columns_block = getBlockWithVirtualsForFilter(parts);\n+        virtual_columns_block = getBlockWithVirtualsForFilter(metadata_snapshot, parts);\n         VirtualColumnUtils::filterBlockWithDAG(filter_dag, virtual_columns_block, local_context);\n         part_values = VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_part\");\n         if (part_values.empty())\n@@ -6694,11 +6701,11 @@ Block MergeTreeData::getMinMaxCountProjectionBlock(\n     };\n \n     Block virtual_columns_block;\n-    auto virtual_block = getHeaderWithVirtualsForFilter();\n+    auto virtual_block = getHeaderWithVirtualsForFilter(metadata_snapshot);\n     bool has_virtual_column = std::any_of(required_columns.begin(), required_columns.end(), [&](const auto & name) { return virtual_block.has(name); });\n     if (has_virtual_column || filter_dag)\n     {\n-        virtual_columns_block = getBlockWithVirtualsForFilter(parts, /*ignore_empty=*/ true);\n+        virtual_columns_block = getBlockWithVirtualsForFilter(metadata_snapshot, parts, /*ignore_empty=*/true);\n         if (virtual_columns_block.rows() == 0)\n             return {};\n     }\ndiff --git a/src/Storages/MergeTree/MergeTreeData.h b/src/Storages/MergeTree/MergeTreeData.h\nindex d21f87c337ef..85537ce4a24a 100644\n--- a/src/Storages/MergeTree/MergeTreeData.h\n+++ b/src/Storages/MergeTree/MergeTreeData.h\n@@ -990,10 +990,11 @@ class MergeTreeData : public IStorage, public WithMutableContext\n     static const Names virtuals_useful_for_filter;\n \n     /// Construct a sample block of virtual columns.\n-    Block getHeaderWithVirtualsForFilter() const;\n+    Block getHeaderWithVirtualsForFilter(const StorageMetadataPtr & metadata) const;\n \n     /// Construct a block consisting only of possible virtual columns for part pruning.\n-    Block getBlockWithVirtualsForFilter(const MergeTreeData::DataPartsVector & parts, bool ignore_empty = false) const;\n+    Block getBlockWithVirtualsForFilter(\n+        const StorageMetadataPtr & metadata, const MergeTreeData::DataPartsVector & parts, bool ignore_empty = false) const;\n \n     /// In merge tree we do inserts with several steps. One of them:\n     /// X. write part to temporary directory with some temp name\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\nindex bcc936c57396..345872efddf9 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.cpp\n@@ -473,6 +473,7 @@ void MergeTreeDataSelectExecutor::buildKeyConditionFromPartOffset(\n }\n \n std::optional<std::unordered_set<String>> MergeTreeDataSelectExecutor::filterPartsByVirtualColumns(\n+    const StorageMetadataPtr & metadata_snapshot,\n     const MergeTreeData & data,\n     const MergeTreeData::DataPartsVector & parts,\n     const ActionsDAGPtr & filter_dag,\n@@ -481,12 +482,12 @@ std::optional<std::unordered_set<String>> MergeTreeDataSelectExecutor::filterPar\n     if (!filter_dag)\n         return {};\n \n-    auto sample = data.getHeaderWithVirtualsForFilter();\n+    auto sample = data.getHeaderWithVirtualsForFilter(metadata_snapshot);\n     auto dag = VirtualColumnUtils::splitFilterDagForAllowedInputs(filter_dag->getOutputs().at(0), &sample);\n     if (!dag)\n         return {};\n \n-    auto virtual_columns_block = data.getBlockWithVirtualsForFilter(parts);\n+    auto virtual_columns_block = data.getBlockWithVirtualsForFilter(metadata_snapshot, parts);\n     VirtualColumnUtils::filterBlockWithDAG(dag, virtual_columns_block, context);\n     return VirtualColumnUtils::extractSingleValueFromBlock<String>(virtual_columns_block, \"_part\");\n }\ndiff --git a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\nindex b1afd7e66683..ecccd6d55e39 100644\n--- a/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n+++ b/src/Storages/MergeTree/MergeTreeDataSelectExecutor.h\n@@ -166,6 +166,7 @@ class MergeTreeDataSelectExecutor\n     /// Example: SELECT count() FROM table WHERE _part = 'part_name'\n     /// If expression found, return a set with allowed part names (std::nullopt otherwise).\n     static std::optional<std::unordered_set<String>> filterPartsByVirtualColumns(\n+        const StorageMetadataPtr & metadata_snapshot,\n         const MergeTreeData & data,\n         const MergeTreeData::DataPartsVector & parts,\n         const ActionsDAGPtr & filter_dag,\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/03033_virtual_column_override.reference b/tests/queries/0_stateless/03033_virtual_column_override.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03033_virtual_column_override.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/03033_virtual_column_override.sql b/tests/queries/0_stateless/03033_virtual_column_override.sql\nnew file mode 100644\nindex 000000000000..49258bbb5337\n--- /dev/null\n+++ b/tests/queries/0_stateless/03033_virtual_column_override.sql\n@@ -0,0 +1,3 @@\n+DROP TABLE IF EXISTS override_test;\n+CREATE TABLE override_test (_part UInt32) ENGINE = MergeTree ORDER BY tuple() AS SELECT 1;\n+SELECT _part FROM override_test;\ndiff --git a/tests/queries/0_stateless/03093_virtual_column_override_group_by.reference b/tests/queries/0_stateless/03093_virtual_column_override_group_by.reference\nnew file mode 100644\nindex 000000000000..d00491fd7e5b\n--- /dev/null\n+++ b/tests/queries/0_stateless/03093_virtual_column_override_group_by.reference\n@@ -0,0 +1,1 @@\n+1\ndiff --git a/tests/queries/0_stateless/03093_virtual_column_override_group_by.sql b/tests/queries/0_stateless/03093_virtual_column_override_group_by.sql\nnew file mode 100644\nindex 000000000000..168d38a15b5a\n--- /dev/null\n+++ b/tests/queries/0_stateless/03093_virtual_column_override_group_by.sql\n@@ -0,0 +1,2 @@\n+CREATE TABLE override_test__fuzz_45 (`_part` Float32) ENGINE = MergeTree ORDER BY tuple() AS SELECT 1;\n+SELECT _part FROM override_test__fuzz_45 GROUP BY materialize(6), 1;\n",
  "problem_statement": "Overriding of virtual columns doesn't work\n```sql\r\nCREATE TABLE mt_test (_part UInt32) ENGINE = MergeTree ORDER BY tuple()\r\n\r\nINSERT INTO mt_test VALUES (1);\r\n\r\nSELECT _part FROM mt_test;\r\n\r\nReceived exception from server (version 22.3.1):\r\nCode: 352. DB::Exception: Received from localhost:9000. DB::Exception: Block structure mismatch in (columns with identical name must have identical structure) stream: different types:\r\n_part UInt32 UInt32(size = 0)\r\n_part String String(size = 0). (AMBIGUOUS_COLUMN_NAME)\r\n```\r\n\r\nIt's expected that virtual column can be overridden. If there exists column with the same name as some virtual column in table definition, it's preferred for reading in queries. \r\n\n",
  "hints_text": "+1, this logic will be better.\nI have a question, if we execute `SELECT _part, _part,_part, _part from mt_test`, what should we return? if we override the virtual column,how can we return virtual column if we really need.\nWorks fine right and it's understood that having the ability of overriding the virtual columns is desirable. Let's add a test and close this",
  "created_at": "2024-04-02T14:25:05Z"
}