{
  "repo": "ClickHouse/ClickHouse",
  "pull_number": 42829,
  "instance_id": "ClickHouse__ClickHouse-42829",
  "issue_numbers": [
    "39157"
  ],
  "base_commit": "61baf3b441a459277452054160ae79dbff4368d8",
  "patch": "diff --git a/src/Core/Settings.h b/src/Core/Settings.h\nindex 5c6ca1a1d572..1213b866b151 100644\n--- a/src/Core/Settings.h\n+++ b/src/Core/Settings.h\n@@ -576,6 +576,7 @@ static constexpr UInt64 operator\"\"_GiB(unsigned long long value)\n     M(UInt64, query_plan_max_optimizations_to_apply, 10000, \"Limit the total number of optimizations applied to query plan. If zero, ignored. If limit reached, throw exception\", 0) \\\n     M(Bool, query_plan_filter_push_down, true, \"Allow to push down filter by predicate query plan step\", 0) \\\n     M(Bool, query_plan_optimize_primary_key, true, \"Analyze primary key using query plan (instead of AST)\", 0) \\\n+    M(Bool, query_plan_read_in_order, true, \"Use query plan for read-in-order optimisation\", 0) \\\n     M(UInt64, regexp_max_matches_per_row, 1000, \"Max matches of any single regexp per row, used to safeguard 'extractAllGroupsHorizontal' against consuming too much memory with greedy RE.\", 0) \\\n     \\\n     M(UInt64, limit, 0, \"Limit on read rows from the most 'end' result for select query, default 0 means no limit length\", 0) \\\ndiff --git a/src/Interpreters/ActionsDAG.cpp b/src/Interpreters/ActionsDAG.cpp\nindex 3dc855b93fff..e0844b2dca73 100644\n--- a/src/Interpreters/ActionsDAG.cpp\n+++ b/src/Interpreters/ActionsDAG.cpp\n@@ -1169,6 +1169,17 @@ ActionsDAGPtr ActionsDAG::makeAddingColumnActions(ColumnWithTypeAndName column)\n \n ActionsDAGPtr ActionsDAG::merge(ActionsDAG && first, ActionsDAG && second)\n {\n+    first.mergeInplace(std::move(second));\n+\n+    /// Drop unused inputs and, probably, some actions.\n+    first.removeUnusedActions();\n+\n+    return std::make_shared<ActionsDAG>(std::move(first));\n+}\n+\n+void ActionsDAG::mergeInplace(ActionsDAG && second)\n+{\n+    auto & first = *this;\n     /// first: x (1), x (2), y ==> x (2), z, x (3)\n     /// second: x (1), x (2), x (3) ==> x (3), x (2), x (1)\n     /// merge: x (1), x (2), x (3), y =(first)=> x (2), z, x (4), x (3) =(second)=> x (3), x (4), x (2), z\n@@ -1256,11 +1267,6 @@ ActionsDAGPtr ActionsDAG::merge(ActionsDAG && first, ActionsDAG && second)\n     first.nodes.splice(first.nodes.end(), std::move(second.nodes));\n \n     first.projected_output = second.projected_output;\n-\n-    /// Drop unused inputs and, probably, some actions.\n-    first.removeUnusedActions();\n-\n-    return std::make_shared<ActionsDAG>(std::move(first));\n }\n \n ActionsDAG::SplitResult ActionsDAG::split(std::unordered_set<const Node *> split_nodes) const\ndiff --git a/src/Interpreters/ActionsDAG.h b/src/Interpreters/ActionsDAG.h\nindex 76273463dce2..75438025c07b 100644\n--- a/src/Interpreters/ActionsDAG.h\n+++ b/src/Interpreters/ActionsDAG.h\n@@ -273,6 +273,11 @@ class ActionsDAG\n     /// Otherwise, any two actions may be combined.\n     static ActionsDAGPtr merge(ActionsDAG && first, ActionsDAG && second);\n \n+    /// The result is similar to merge(*this, second);\n+    /// Invariant : no nodes are removed from the first (this) DAG.\n+    /// So that pointers to nodes are kept valid.\n+    void mergeInplace(ActionsDAG && second);\n+\n     using SplitResult = std::pair<ActionsDAGPtr, ActionsDAGPtr>;\n \n     /// Split ActionsDAG into two DAGs, where first part contains all nodes from split_nodes and their children.\ndiff --git a/src/Interpreters/ExpressionAnalyzer.cpp b/src/Interpreters/ExpressionAnalyzer.cpp\nindex 9daa42bf4991..d40d886de621 100644\n--- a/src/Interpreters/ExpressionAnalyzer.cpp\n+++ b/src/Interpreters/ExpressionAnalyzer.cpp\n@@ -1944,7 +1944,7 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n         }\n \n         optimize_read_in_order =\n-            settings.optimize_read_in_order\n+            settings.optimize_read_in_order && (!settings.query_plan_read_in_order)\n             && storage\n             && query.orderBy()\n             && !query_analyzer.hasAggregation()\n@@ -1952,13 +1952,6 @@ ExpressionAnalysisResult::ExpressionAnalysisResult(\n             && !query.final()\n             && join_allow_read_in_order;\n \n-        if (storage && optimize_read_in_order)\n-        {\n-            Names columns_for_sorting_key = metadata_snapshot->getColumnsRequiredForSortingKey();\n-            additional_required_columns_after_prewhere.insert(additional_required_columns_after_prewhere.end(),\n-                columns_for_sorting_key.begin(), columns_for_sorting_key.end());\n-        }\n-\n         /// If there is aggregation, we execute expressions in SELECT and ORDER BY on the initiating server, otherwise on the source servers.\n         query_analyzer.appendSelect(chain, only_types || (need_aggregate ? !second_stage : !first_stage));\n \ndiff --git a/src/Interpreters/IInterpreterUnionOrSelectQuery.h b/src/Interpreters/IInterpreterUnionOrSelectQuery.h\nindex a1c86f9de857..6f893d4703e6 100644\n--- a/src/Interpreters/IInterpreterUnionOrSelectQuery.h\n+++ b/src/Interpreters/IInterpreterUnionOrSelectQuery.h\n@@ -58,6 +58,8 @@ class IInterpreterUnionOrSelectQuery : public IInterpreter\n     /// Add limits from external query.\n     void addStorageLimits(const StorageLimitsList & limits);\n \n+    ContextPtr getContext() const { return context; }\n+\n protected:\n     ASTPtr query_ptr;\n     ContextMutablePtr context;\ndiff --git a/src/Interpreters/InterpreterExplainQuery.cpp b/src/Interpreters/InterpreterExplainQuery.cpp\nindex fb8d3c6049fa..2864b433e007 100644\n--- a/src/Interpreters/InterpreterExplainQuery.cpp\n+++ b/src/Interpreters/InterpreterExplainQuery.cpp\n@@ -419,19 +419,23 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n             auto settings = checkAndGetSettings<QueryPlanSettings>(ast.getSettings());\n             QueryPlan plan;\n \n+            ContextPtr context;\n+\n             if (getContext()->getSettingsRef().allow_experimental_analyzer)\n             {\n                 InterpreterSelectQueryAnalyzer interpreter(ast.getExplainedQuery(), options, getContext());\n+                context = interpreter.getContext();\n                 plan = std::move(interpreter).extractQueryPlan();\n             }\n             else\n             {\n                 InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), options);\n                 interpreter.buildQueryPlan(plan);\n+                context = interpreter.getContext();\n             }\n \n             if (settings.optimize)\n-                plan.optimize(QueryPlanOptimizationSettings::fromContext(getContext()));\n+                plan.optimize(QueryPlanOptimizationSettings::fromContext(context));\n \n             if (settings.json)\n             {\n@@ -461,21 +465,24 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n             {\n                 auto settings = checkAndGetSettings<QueryPipelineSettings>(ast.getSettings());\n                 QueryPlan plan;\n+                ContextPtr context;\n \n                 if (getContext()->getSettingsRef().allow_experimental_analyzer)\n                 {\n                     InterpreterSelectQueryAnalyzer interpreter(ast.getExplainedQuery(), options, getContext());\n+                    context = interpreter.getContext();\n                     plan = std::move(interpreter).extractQueryPlan();\n                 }\n                 else\n                 {\n                     InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), options);\n                     interpreter.buildQueryPlan(plan);\n+                    context = interpreter.getContext();\n                 }\n \n                 auto pipeline = plan.buildQueryPipeline(\n-                    QueryPlanOptimizationSettings::fromContext(getContext()),\n-                    BuildQueryPipelineSettings::fromContext(getContext()));\n+                    QueryPlanOptimizationSettings::fromContext(context),\n+                    BuildQueryPipelineSettings::fromContext(context));\n \n                 if (settings.graph)\n                 {\n@@ -511,16 +518,18 @@ QueryPipeline InterpreterExplainQuery::executeImpl()\n \n             auto settings = checkAndGetSettings<QueryPlanSettings>(ast.getSettings());\n             QueryPlan plan;\n+            ContextPtr context;\n \n             InterpreterSelectWithUnionQuery interpreter(ast.getExplainedQuery(), getContext(), SelectQueryOptions());\n             interpreter.buildQueryPlan(plan);\n+            context = interpreter.getContext();\n             // collect the selected marks, rows, parts during build query pipeline.\n             plan.buildQueryPipeline(\n-                QueryPlanOptimizationSettings::fromContext(getContext()),\n-                BuildQueryPipelineSettings::fromContext(getContext()));\n+                QueryPlanOptimizationSettings::fromContext(context),\n+                BuildQueryPipelineSettings::fromContext(context));\n \n             if (settings.optimize)\n-                plan.optimize(QueryPlanOptimizationSettings::fromContext(getContext()));\n+                plan.optimize(QueryPlanOptimizationSettings::fromContext(context));\n             plan.explainEstimate(res_columns);\n             insert_buf = false;\n             break;\ndiff --git a/src/Interpreters/InterpreterSelectQuery.cpp b/src/Interpreters/InterpreterSelectQuery.cpp\nindex d8ac263e3d15..dd3267361e24 100644\n--- a/src/Interpreters/InterpreterSelectQuery.cpp\n+++ b/src/Interpreters/InterpreterSelectQuery.cpp\n@@ -1447,17 +1447,12 @@ void InterpreterSelectQuery::executeImpl(QueryPlan & query_plan, std::optional<P\n                         for (const auto & key_name : key_names)\n                             order_descr.emplace_back(key_name);\n \n+                        SortingStep::Settings sort_settings(*context);\n+\n                         auto sorting_step = std::make_unique<SortingStep>(\n                             plan.getCurrentDataStream(),\n                             std::move(order_descr),\n-                            settings.max_block_size,\n-                            0 /* LIMIT */,\n-                            SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),\n-                            settings.max_bytes_before_remerge_sort,\n-                            settings.remerge_sort_lowered_memory_bytes_ratio,\n-                            settings.max_bytes_before_external_sort,\n-                            this->context->getTempDataOnDisk(),\n-                            settings.min_free_disk_space_for_temporary_data,\n+                            0 /* LIMIT */, sort_settings,\n                             settings.optimize_sorting_by_input_stream_properties);\n                         sorting_step->setStepDescription(fmt::format(\"Sort {} before JOIN\", join_pos));\n                         plan.addStep(std::move(sorting_step));\n@@ -2617,17 +2612,13 @@ void InterpreterSelectQuery::executeWindow(QueryPlan & query_plan)\n         // happens in case of `over ()`.\n         if (!window.full_sort_description.empty() && (i == 0 || !sortIsPrefix(window, *windows_sorted[i - 1])))\n         {\n+            SortingStep::Settings sort_settings(*context);\n+\n             auto sorting_step = std::make_unique<SortingStep>(\n                 query_plan.getCurrentDataStream(),\n                 window.full_sort_description,\n-                settings.max_block_size,\n                 0 /* LIMIT */,\n-                SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),\n-                settings.max_bytes_before_remerge_sort,\n-                settings.remerge_sort_lowered_memory_bytes_ratio,\n-                settings.max_bytes_before_external_sort,\n-                context->getTempDataOnDisk(),\n-                settings.min_free_disk_space_for_temporary_data,\n+                sort_settings,\n                 settings.optimize_sorting_by_input_stream_properties);\n             sorting_step->setStepDescription(\"Sorting for window '\" + window.window_name + \"'\");\n             query_plan.addStep(std::move(sorting_step));\n@@ -2675,18 +2666,14 @@ void InterpreterSelectQuery::executeOrder(QueryPlan & query_plan, InputOrderInfo\n \n     const Settings & settings = context->getSettingsRef();\n \n+    SortingStep::Settings sort_settings(*context);\n+\n     /// Merge the sorted blocks.\n     auto sorting_step = std::make_unique<SortingStep>(\n         query_plan.getCurrentDataStream(),\n         output_order_descr,\n-        settings.max_block_size,\n         limit,\n-        SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),\n-        settings.max_bytes_before_remerge_sort,\n-        settings.remerge_sort_lowered_memory_bytes_ratio,\n-        settings.max_bytes_before_external_sort,\n-        context->getTempDataOnDisk(),\n-        settings.min_free_disk_space_for_temporary_data,\n+        sort_settings,\n         settings.optimize_sorting_by_input_stream_properties);\n \n     sorting_step->setStepDescription(\"Sorting for ORDER BY\");\ndiff --git a/src/Planner/Planner.cpp b/src/Planner/Planner.cpp\nindex 97f82d06463c..56cc73456cef 100644\n--- a/src/Planner/Planner.cpp\n+++ b/src/Planner/Planner.cpp\n@@ -571,17 +571,13 @@ void Planner::buildQueryPlanIfNeeded()\n             if (!window_description.full_sort_description.empty() &&\n                 (i == 0 || !sortDescriptionIsPrefix(window_description.full_sort_description, window_descriptions[i - 1].full_sort_description)))\n             {\n+                SortingStep::Settings sort_settings(*query_context);\n+\n                 auto sorting_step = std::make_unique<SortingStep>(\n                     query_plan.getCurrentDataStream(),\n                     window_description.full_sort_description,\n-                    settings.max_block_size,\n                     0 /*limit*/,\n-                    SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),\n-                    settings.max_bytes_before_remerge_sort,\n-                    settings.remerge_sort_lowered_memory_bytes_ratio,\n-                    settings.max_bytes_before_external_sort,\n-                    query_context->getTempDataOnDisk(),\n-                    settings.min_free_disk_space_for_temporary_data,\n+                    sort_settings,\n                     settings.optimize_sorting_by_input_stream_properties);\n \n                 sorting_step->setStepDescription(\"Sorting for window '\" + window_description.window_name + \"'\");\n@@ -673,18 +669,14 @@ void Planner::buildQueryPlanIfNeeded()\n \n         const Settings & settings = query_context->getSettingsRef();\n \n+        SortingStep::Settings sort_settings(*query_context);\n+\n         /// Merge the sorted blocks\n         auto sorting_step = std::make_unique<SortingStep>(\n             query_plan.getCurrentDataStream(),\n             sort_description,\n-            settings.max_block_size,\n             partial_sorting_limit,\n-            SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),\n-            settings.max_bytes_before_remerge_sort,\n-            settings.remerge_sort_lowered_memory_bytes_ratio,\n-            settings.max_bytes_before_external_sort,\n-            query_context->getTempDataOnDisk(),\n-            settings.min_free_disk_space_for_temporary_data,\n+            sort_settings,\n             settings.optimize_sorting_by_input_stream_properties);\n \n         sorting_step->setStepDescription(\"Sorting for ORDER BY\");\ndiff --git a/src/Planner/PlannerJoinTree.cpp b/src/Planner/PlannerJoinTree.cpp\nindex 4cb446a65a0b..4e50a20bbd69 100644\n--- a/src/Planner/PlannerJoinTree.cpp\n+++ b/src/Planner/PlannerJoinTree.cpp\n@@ -528,17 +528,13 @@ QueryPlan buildQueryPlanForJoinNode(QueryTreeNodePtr join_tree_node,\n             for (const auto & key_name : key_names)\n                 sort_description.emplace_back(key_name);\n \n+            SortingStep::Settings sort_settings(*query_context);\n+\n             auto sorting_step = std::make_unique<SortingStep>(\n                 plan.getCurrentDataStream(),\n                 std::move(sort_description),\n-                settings.max_block_size,\n                 0 /*limit*/,\n-                SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode),\n-                settings.max_bytes_before_remerge_sort,\n-                settings.remerge_sort_lowered_memory_bytes_ratio,\n-                settings.max_bytes_before_external_sort,\n-                query_context->getTempDataOnDisk(),\n-                settings.min_free_disk_space_for_temporary_data,\n+                sort_settings,\n                 settings.optimize_sorting_by_input_stream_properties);\n             sorting_step->setStepDescription(fmt::format(\"Sort {} before JOIN\", join_table_side));\n             plan.addStep(std::move(sorting_step));\ndiff --git a/src/Processors/QueryPlan/Optimizations/Optimizations.h b/src/Processors/QueryPlan/Optimizations/Optimizations.h\nindex 25825f2f5b93..973304b366b2 100644\n--- a/src/Processors/QueryPlan/Optimizations/Optimizations.h\n+++ b/src/Processors/QueryPlan/Optimizations/Optimizations.h\n@@ -9,12 +9,13 @@ namespace DB\n namespace QueryPlanOptimizations\n {\n \n-/// This is the main function which optimizes the whole QueryPlan tree.\n-void optimizeTree(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);\n+/// Main functions which optimize QueryPlan tree.\n+/// First pass (ideally) apply local idempotent operations on top of Plan.\n+void optimizeTreeFirstPass(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);\n+/// Second pass is used to apply read-in-order and attach a predicate to PK.\n+void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes);\n \n-void optimizePrimaryKeyCondition(QueryPlan::Node & root);\n-\n-/// Optimization is a function applied to QueryPlan::Node.\n+/// Optimization (first pass) is a function applied to QueryPlan::Node.\n /// It can read and update subtree of specified node.\n /// It return the number of updated layers of subtree if some change happened.\n /// It must guarantee that the structure of tree is correct.\n@@ -29,10 +30,10 @@ struct Optimization\n     const bool QueryPlanOptimizationSettings::* const is_enabled{};\n };\n \n-/// Move ARRAY JOIN up if possible.\n+/// Move ARRAY JOIN up if possible\n size_t tryLiftUpArrayJoin(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);\n \n-/// Move LimitStep down if possible.\n+/// Move LimitStep down if possible\n size_t tryPushDownLimit(QueryPlan::Node * parent_node, QueryPlan::Nodes &);\n \n /// Split FilterStep into chain `ExpressionStep -> FilterStep`, where FilterStep contains minimal number of nodes.\n@@ -55,7 +56,14 @@ size_t tryExecuteFunctionsAfterSorting(QueryPlan::Node * parent_node, QueryPlan:\n size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);\n \n /// Reading in order from MergeTree table if DISTINCT columns match or form a prefix of MergeTree sorting key\n-size_t tryDistinctReadInOrder(QueryPlan::Node * node, QueryPlan::Nodes & nodes);\n+size_t tryDistinctReadInOrder(QueryPlan::Node * node);\n+\n+/// Put some steps under union, so that plan optimisation could be applied to union parts separately.\n+/// For example, the plan can be rewritten like:\n+///                      - Something -                    - Expression - Something -\n+/// - Expression - Union - Something -     =>     - Union - Expression - Something -\n+///                      - Something -                    - Expression - Something -\n+size_t tryLiftUpUnion(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes);\n \n inline const auto & getOptimizations()\n {\n@@ -67,12 +75,24 @@ inline const auto & getOptimizations()\n         {tryPushDownFilter, \"pushDownFilter\", &QueryPlanOptimizationSettings::filter_push_down},\n         {tryExecuteFunctionsAfterSorting, \"liftUpFunctions\", &QueryPlanOptimizationSettings::optimize_plan},\n         {tryReuseStorageOrderingForWindowFunctions, \"reuseStorageOrderingForWindowFunctions\", &QueryPlanOptimizationSettings::optimize_plan},\n-        {tryDistinctReadInOrder, \"distinctReadInOrder\", &QueryPlanOptimizationSettings::distinct_in_order},\n+        {tryLiftUpUnion, \"liftUpUnion\", &QueryPlanOptimizationSettings::optimize_plan},\n     }};\n \n     return optimizations;\n }\n \n+struct Frame\n+{\n+    QueryPlan::Node * node = nullptr;\n+    size_t next_child = 0;\n+};\n+\n+using Stack = std::vector<Frame>;\n+\n+/// Second pass optimizations\n+void optimizePrimaryKeyCondition(const Stack & stack);\n+void optimizeReadInOrder(QueryPlan::Node & node, QueryPlan::Nodes & nodes);\n+\n }\n \n }\ndiff --git a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp\nindex 2342f961751c..88c0f346e9ab 100644\n--- a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.cpp\n@@ -12,6 +12,7 @@ QueryPlanOptimizationSettings QueryPlanOptimizationSettings::fromSettings(const\n     settings.max_optimizations_to_apply = from.query_plan_max_optimizations_to_apply;\n     settings.filter_push_down = from.query_plan_filter_push_down;\n     settings.distinct_in_order = from.optimize_distinct_in_order;\n+    settings.read_in_order = from.optimize_read_in_order && from.query_plan_read_in_order;\n     return settings;\n }\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h\nindex 0da89f28aad3..7185d2fe869c 100644\n--- a/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h\n+++ b/src/Processors/QueryPlan/Optimizations/QueryPlanOptimizationSettings.h\n@@ -24,6 +24,9 @@ struct QueryPlanOptimizationSettings\n     /// if distinct in order optimization is enabled\n     bool distinct_in_order = false;\n \n+    /// If read-in-order optimisation is enabled\n+    bool read_in_order = true;\n+\n     static QueryPlanOptimizationSettings fromSettings(const Settings & from);\n     static QueryPlanOptimizationSettings fromContext(ContextPtr from);\n };\ndiff --git a/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp b/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp\nindex 38cb6f3d3c52..3677a1581c43 100644\n--- a/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/distinctReadInOrder.cpp\n@@ -7,7 +7,7 @@\n \n namespace DB::QueryPlanOptimizations\n {\n-size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)\n+size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node)\n {\n     /// check if it is preliminary distinct node\n     DistinctStep * pre_distinct = nullptr;\n@@ -22,7 +22,7 @@ size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)\n     /// walk through the plan\n     /// (1) check if nodes below preliminary distinct preserve sorting\n     /// (2) gather transforming steps to update their sorting properties later\n-    std::vector<ITransformingStep *> steps2update;\n+    std::vector<ITransformingStep *> steps_to_update;\n     QueryPlan::Node * node = parent_node;\n     while (!node->children.empty())\n     {\n@@ -34,7 +34,7 @@ size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)\n         if (!traits.preserves_sorting)\n             return 0;\n \n-        steps2update.push_back(step);\n+        steps_to_update.push_back(step);\n \n         node = node->children.front();\n     }\n@@ -90,11 +90,11 @@ size_t tryDistinctReadInOrder(QueryPlan::Node * parent_node, QueryPlan::Nodes &)\n \n     /// update data stream's sorting properties for found transforms\n     const DataStream * input_stream = &read_from_merge_tree->getOutputStream();\n-    while (!steps2update.empty())\n+    while (!steps_to_update.empty())\n     {\n-        steps2update.back()->updateInputStream(*input_stream);\n-        input_stream = &steps2update.back()->getOutputStream();\n-        steps2update.pop_back();\n+        steps_to_update.back()->updateInputStream(*input_stream);\n+        input_stream = &steps_to_update.back()->getOutputStream();\n+        steps_to_update.pop_back();\n     }\n \n     return 0;\ndiff --git a/src/Processors/QueryPlan/Optimizations/liftUpUnion.cpp b/src/Processors/QueryPlan/Optimizations/liftUpUnion.cpp\nnew file mode 100644\nindex 000000000000..35d8b1a35e43\n--- /dev/null\n+++ b/src/Processors/QueryPlan/Optimizations/liftUpUnion.cpp\n@@ -0,0 +1,65 @@\n+#include <Processors/QueryPlan/Optimizations/Optimizations.h>\n+#include <Processors/QueryPlan/UnionStep.h>\n+#include <Processors/QueryPlan/ExpressionStep.h>\n+#include <Interpreters/ActionsDAG.h>\n+\n+namespace DB::QueryPlanOptimizations\n+{\n+\n+size_t tryLiftUpUnion(QueryPlan::Node * parent_node, QueryPlan::Nodes & nodes)\n+{\n+    if (parent_node->children.empty())\n+        return 0;\n+\n+    QueryPlan::Node * child_node = parent_node->children.front();\n+    auto & parent = parent_node->step;\n+    auto & child = child_node->step;\n+\n+    auto * union_step = typeid_cast<UnionStep *>(child.get());\n+    if (!union_step)\n+        return 0;\n+\n+    if (auto * expression = typeid_cast<ExpressionStep *>(parent.get()))\n+    {\n+        /// Union does not change header.\n+        /// We can push down expression and update header.\n+        auto union_input_streams = child->getInputStreams();\n+        for (auto & input_stream : union_input_streams)\n+            input_stream.header = expression->getOutputStream().header;\n+\n+        ///                    - Something\n+        /// Expression - Union - Something\n+        ///                    - Something\n+\n+        child = std::make_unique<UnionStep>(union_input_streams, union_step->getMaxThreads());\n+\n+        std::swap(parent, child);\n+        std::swap(parent_node->children, child_node->children);\n+        std::swap(parent_node->children.front(), child_node->children.front());\n+\n+        ///       - Expression - Something\n+        /// Union - Something\n+        ///       - Something\n+\n+        for (size_t i = 1; i < parent_node->children.size(); ++i)\n+        {\n+            auto & expr_node = nodes.emplace_back();\n+            expr_node.children.push_back(parent_node->children[i]);\n+            parent_node->children[i] = &expr_node;\n+\n+            expr_node.step = std::make_unique<ExpressionStep>(\n+                expr_node.children.front()->step->getOutputStream(),\n+                expression->getExpression()->clone());\n+        }\n+\n+        ///       - Expression - Something\n+        /// Union - Expression - Something\n+        ///       - Expression - Something\n+\n+        return 3;\n+    }\n+\n+    return 0;\n+}\n+\n+}\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp b/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp\nindex 984c76701ba6..cac4944bad7a 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizePrimaryKeyCondition.cpp\n@@ -9,49 +9,32 @@\n namespace DB::QueryPlanOptimizations\n {\n \n-void optimizePrimaryKeyCondition(QueryPlan::Node & root)\n+void optimizePrimaryKeyCondition(const Stack & stack)\n {\n-    struct Frame\n-    {\n-        QueryPlan::Node * node = nullptr;\n-        size_t next_child = 0;\n-    };\n+    const auto & frame = stack.back();\n \n-    std::vector<Frame> stack;\n-    stack.push_back({.node = &root});\n+    auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(frame.node->step.get());\n+    auto * read_from_merge = typeid_cast<ReadFromMerge *>(frame.node->step.get());\n \n-    while (!stack.empty())\n-    {\n-        auto & frame = stack.back();\n+    if (!read_from_merge && !read_from_merge_tree)\n+        return;\n \n-        /// Traverse all children first.\n-        if (frame.next_child < frame.node->children.size())\n+    for (auto iter = stack.rbegin() + 1; iter != stack.rend(); ++iter)\n+    {\n+        if (auto * filter_step = typeid_cast<FilterStep *>(iter->node->step.get()))\n         {\n-            auto next_frame = Frame{.node = frame.node->children[frame.next_child]};\n-            ++frame.next_child;\n-            stack.push_back(next_frame);\n-            continue;\n+            if (read_from_merge_tree)\n+                read_from_merge_tree->addFilter(filter_step->getExpression(), filter_step->getFilterColumnName());\n+            if (read_from_merge)\n+                read_from_merge->addFilter(filter_step->getExpression(), filter_step->getFilterColumnName());\n         }\n-\n-        auto add_read_from_storage_filter = [&](auto & storage)\n-        {\n-            for (auto iter = stack.rbegin() + 1; iter != stack.rend(); ++iter)\n-            {\n-                if (auto * filter_step = typeid_cast<FilterStep *>(iter->node->step.get()))\n-                    storage.addFilter(filter_step->getExpression(), filter_step->getFilterColumnName());\n-                else if (typeid_cast<ExpressionStep *>(iter->node->step.get()))\n-                    continue;\n-                else\n-                    break;\n-            }\n-        };\n-\n-        if (auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(frame.node->step.get()))\n-            add_read_from_storage_filter(*read_from_merge_tree);\n-        else if (auto * read_from_merge = typeid_cast<ReadFromMerge *>(frame.node->step.get()))\n-            add_read_from_storage_filter(*read_from_merge);\n-\n-        stack.pop_back();\n+        /// Note: actually, plan optimizations merge Filter and Expression steps.\n+        /// Ideally, chain should look like (Expression -> ...) -> (Filter -> ...) -> ReadFromStorage,\n+        /// So this is likely not needed.\n+        else if (typeid_cast<ExpressionStep *>(iter->node->step.get()))\n+            continue;\n+        else\n+            break;\n     }\n }\n \ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp b/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp\nnew file mode 100644\nindex 000000000000..ac131a1b67cb\n--- /dev/null\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeReadInOrder.cpp\n@@ -0,0 +1,953 @@\n+#include <Parsers/ASTWindowDefinition.h>\n+#include <Processors/QueryPlan/Optimizations/Optimizations.h>\n+#include <Processors/QueryPlan/ITransformingStep.h>\n+#include <Processors/QueryPlan/AggregatingStep.h>\n+#include <Processors/QueryPlan/ExpressionStep.h>\n+#include <Processors/QueryPlan/JoinStep.h>\n+#include <Processors/QueryPlan/ArrayJoinStep.h>\n+#include <Processors/QueryPlan/CreatingSetsStep.h>\n+#include <Processors/QueryPlan/CubeStep.h>\n+#include <Processors/QueryPlan/ReadFromMergeTree.h>\n+#include <Processors/QueryPlan/SortingStep.h>\n+#include <Processors/QueryPlan/TotalsHavingStep.h>\n+#include <Processors/QueryPlan/DistinctStep.h>\n+#include <Processors/QueryPlan/UnionStep.h>\n+#include <Processors/QueryPlan/WindowStep.h>\n+#include <Interpreters/ActionsDAG.h>\n+#include <Interpreters/ArrayJoinAction.h>\n+#include <Interpreters/InterpreterSelectQuery.h>\n+#include <Interpreters/TableJoin.h>\n+#include <Common/typeid_cast.h>\n+#include <Storages/StorageMerge.h>\n+#include <Functions/IFunction.h>\n+#include <DataTypes/DataTypeAggregateFunction.h>\n+#include <Columns/IColumn.h>\n+#include <stack>\n+\n+\n+namespace DB::QueryPlanOptimizations\n+{\n+\n+ISourceStep * checkSupportedReadingStep(IQueryPlanStep * step)\n+{\n+    if (auto * reading = typeid_cast<ReadFromMergeTree *>(step))\n+    {\n+        /// Already read-in-order, skip.\n+        if (reading->getQueryInfo().input_order_info)\n+            return nullptr;\n+\n+        const auto & sorting_key = reading->getStorageMetadata()->getSortingKey();\n+        if (sorting_key.column_names.empty())\n+            return nullptr;\n+\n+        return reading;\n+    }\n+\n+    if (auto * merge = typeid_cast<ReadFromMerge *>(step))\n+    {\n+        const auto & tables = merge->getSelectedTables();\n+        if (tables.empty())\n+            return nullptr;\n+\n+        for (const auto & table : tables)\n+        {\n+            auto storage = std::get<StoragePtr>(table);\n+            const auto & sorting_key = storage->getInMemoryMetadataPtr()->getSortingKey();\n+            if (sorting_key.column_names.empty())\n+                return nullptr;\n+        }\n+\n+        return merge;\n+    }\n+\n+    return nullptr;\n+}\n+\n+QueryPlan::Node * findReadingStep(QueryPlan::Node & node)\n+{\n+    IQueryPlanStep * step = node.step.get();\n+    if (auto * reading = checkSupportedReadingStep(step))\n+        return &node;\n+\n+    if (node.children.size() != 1)\n+        return nullptr;\n+\n+    if (typeid_cast<ExpressionStep *>(step) || typeid_cast<FilterStep *>(step) || typeid_cast<ArrayJoinStep *>(step))\n+        return findReadingStep(*node.children.front());\n+\n+    if (auto * distinct = typeid_cast<DistinctStep *>(step); distinct && distinct->isPreliminary())\n+        return findReadingStep(*node.children.front());\n+\n+    return nullptr;\n+}\n+\n+/// FixedColumns are columns which values become constants after filtering.\n+/// In a query \"SELECT x, y, z FROM table WHERE x = 1 AND y = 'a' ORDER BY x, y, z\"\n+/// Fixed columns are 'x' and 'y'.\n+using FixedColumns = std::unordered_set<const ActionsDAG::Node *>;\n+\n+/// Right now we find only simple cases like 'and(..., and(..., and(column = value, ...), ...'\n+/// Injective functions are supported here. For a condition 'injectiveFunction(x) = 5' column 'x' is fixed.\n+void appendFixedColumnsFromFilterExpression(const ActionsDAG::Node & filter_expression, FixedColumns & fixed_columns)\n+{\n+    std::stack<const ActionsDAG::Node *> stack;\n+    stack.push(&filter_expression);\n+\n+    while (!stack.empty())\n+    {\n+        const auto * node = stack.top();\n+        stack.pop();\n+        if (node->type == ActionsDAG::ActionType::FUNCTION)\n+        {\n+            const auto & name = node->function_base->getName();\n+            if (name == \"and\")\n+            {\n+                for (const auto * arg : node->children)\n+                    stack.push(arg);\n+            }\n+            else if (name == \"equals\")\n+            {\n+                const ActionsDAG::Node * maybe_fixed_column = nullptr;\n+                size_t num_constant_columns = 0;\n+                for (const auto & child : node->children)\n+                {\n+                    if (child->column)\n+                        ++num_constant_columns;\n+                    else\n+                        maybe_fixed_column = child;\n+                }\n+\n+                if (maybe_fixed_column && num_constant_columns + 1 == node->children.size())\n+                {\n+                    //std::cerr << \"====== Added fixed column \" << maybe_fixed_column->result_name << ' ' << static_cast<const void *>(maybe_fixed_column) << std::endl;\n+                    fixed_columns.insert(maybe_fixed_column);\n+\n+                    /// Support injective functions chain.\n+                    const ActionsDAG::Node * maybe_injective = maybe_fixed_column;\n+                    while (maybe_injective->type == ActionsDAG::ActionType::FUNCTION\n+                        && maybe_injective->children.size() == 1\n+                        && maybe_injective->function_base->isInjective({}))\n+                    {\n+                        maybe_injective = maybe_injective->children.front();\n+                        fixed_columns.insert(maybe_injective);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void appendExpression(ActionsDAGPtr & dag, const ActionsDAGPtr & expression)\n+{\n+    if (dag)\n+        dag->mergeInplace(std::move(*expression->clone()));\n+    else\n+        dag = expression->clone();\n+}\n+\n+/// This function builds a common DAG which is a gerge of DAGs from Filter and Expression steps chain.\n+/// Additionally, build a set of fixed columns.\n+void buildSortingDAG(QueryPlan::Node & node, ActionsDAGPtr & dag, FixedColumns & fixed_columns, size_t & limit)\n+{\n+    IQueryPlanStep * step = node.step.get();\n+    if (auto * reading = typeid_cast<ReadFromMergeTree *>(step))\n+    {\n+        if (const auto * prewhere_info = reading->getPrewhereInfo())\n+        {\n+            /// Should ignore limit if there is filtering.\n+            limit = 0;\n+\n+            if (prewhere_info->prewhere_actions)\n+            {\n+                //std::cerr << \"====== Adding prewhere \" << std::endl;\n+                appendExpression(dag, prewhere_info->prewhere_actions);\n+                if (const auto * filter_expression = dag->tryFindInOutputs(prewhere_info->prewhere_column_name))\n+                    appendFixedColumnsFromFilterExpression(*filter_expression, fixed_columns);\n+            }\n+        }\n+        return;\n+    }\n+\n+    if (node.children.size() != 1)\n+        return;\n+\n+    buildSortingDAG(*node.children.front(), dag, fixed_columns, limit);\n+\n+    if (auto * expression = typeid_cast<ExpressionStep *>(step))\n+    {\n+        const auto & actions = expression->getExpression();\n+\n+        /// Should ignore limit because arrayJoin() can reduce the number of rows in case of empty array.\n+        if (actions->hasArrayJoin())\n+            limit = 0;\n+\n+        appendExpression(dag, actions);\n+    }\n+\n+    if (auto * filter = typeid_cast<FilterStep *>(step))\n+    {\n+        /// Should ignore limit if there is filtering.\n+        limit = 0;\n+\n+        appendExpression(dag, filter->getExpression());\n+        if (const auto * filter_expression = dag->tryFindInOutputs(filter->getFilterColumnName()))\n+            appendFixedColumnsFromFilterExpression(*filter_expression, fixed_columns);\n+    }\n+\n+    if (auto * array_join = typeid_cast<ArrayJoinStep *>(step))\n+    {\n+        /// Should ignore limit because ARRAY JOIN can reduce the number of rows in case of empty array.\n+        /// But in case of LEFT ARRAY JOIN the result number of rows is always bigger.\n+        if (!array_join->arrayJoin()->is_left)\n+            limit = 0;\n+\n+        const auto & array_joined_columns = array_join->arrayJoin()->columns;\n+\n+        /// Remove array joined columns from outputs.\n+        /// Types are changed after ARRAY JOIN, and we can't use this columns anyway.\n+        ActionsDAG::NodeRawConstPtrs outputs;\n+        outputs.reserve(dag->getOutputs().size());\n+\n+        for (const auto & output : dag->getOutputs())\n+        {\n+            if (!array_joined_columns.contains(output->result_name))\n+                outputs.push_back(output);\n+        }\n+    }\n+}\n+\n+/// Add more functions to fixed columns.\n+/// Functions result is fixed if all arguments are fixed or constants.\n+void enreachFixedColumns(const ActionsDAG & dag, FixedColumns & fixed_columns)\n+{\n+    struct Frame\n+    {\n+        const ActionsDAG::Node * node;\n+        size_t next_child = 0;\n+    };\n+\n+    std::stack<Frame> stack;\n+    std::unordered_set<const ActionsDAG::Node *> visited;\n+    for (const auto & node : dag.getNodes())\n+    {\n+        if (visited.contains(&node))\n+            continue;\n+\n+        stack.push({&node});\n+        visited.insert(&node);\n+        while (!stack.empty())\n+        {\n+            auto & frame = stack.top();\n+            for (; frame.next_child < frame.node->children.size(); ++frame.next_child)\n+                if (!visited.contains(frame.node->children[frame.next_child]))\n+                    break;\n+\n+            if (frame.next_child < frame.node->children.size())\n+            {\n+                const auto * child = frame.node->children[frame.next_child];\n+                visited.insert(child);\n+                stack.push({child});\n+                ++frame.next_child;\n+            }\n+            else\n+            {\n+                /// Ignore constants here, will check them separately\n+                if (!frame.node->column)\n+                {\n+                    if (frame.node->type == ActionsDAG::ActionType::ALIAS)\n+                    {\n+                        if (fixed_columns.contains(frame.node->children.at(0)))\n+                            fixed_columns.insert(frame.node);\n+                    }\n+                    else if (frame.node->type == ActionsDAG::ActionType::FUNCTION)\n+                    {\n+                        if (frame.node->function_base->isDeterministicInScopeOfQuery())\n+                        {\n+                            //std::cerr << \"*** enreachFixedColumns check \" << frame.node->result_name << std::endl;\n+                            bool all_args_fixed_or_const = true;\n+                            for (const auto * child : frame.node->children)\n+                            {\n+                                if (!child->column && !fixed_columns.contains(child))\n+                                {\n+                                    //std::cerr << \"*** enreachFixedColumns fail \" << child->result_name <<  ' ' << static_cast<const void *>(child) << std::endl;\n+                                    all_args_fixed_or_const = false;\n+                                }\n+                            }\n+\n+                            if (all_args_fixed_or_const)\n+                            {\n+                                //std::cerr << \"*** enreachFixedColumns add \" << frame.node->result_name << ' ' << static_cast<const void *>(frame.node) << std::endl;\n+                                fixed_columns.insert(frame.node);\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                stack.pop();\n+            }\n+        }\n+    }\n+}\n+\n+/// This structure stores a node mapping from one DAG to another.\n+/// The rule is following:\n+/// * Input nodes are mapped by name.\n+/// * Function is mapped to function if all children are mapped and function names are same.\n+/// * Alias is mapped to it's children mapping.\n+/// * Monotonic function can be mapped to it's children mapping if direct mapping does not exist.\n+///   In this case, information about monotonicity is filled.\n+/// * Mapped node is nullptr if there is no mapping found.\n+///\n+/// Overall, directly mapped nodes represent equal calculations.\n+/// Notes:\n+/// * Mapped DAG can contain many nodes which represent the same calculation.\n+///   In this case mapping is ambiguous and only one node is mapped.\n+/// * Aliases for mapped DAG are not supported.\n+/// DAG for PK does not contain aliases and ambiguous nodes.\n+struct MatchedTrees\n+{\n+    /// Monotonicity is calculated for monotonic functions chain.\n+    /// Chain is not strict if there is any non-strict monotonic function.\n+    struct Monotonicity\n+    {\n+        int direction = 1;\n+        bool strict = true;\n+    };\n+\n+    struct Match\n+    {\n+        const ActionsDAG::Node * node = nullptr;\n+        std::optional<Monotonicity> monotonicity;\n+    };\n+\n+    using Matches = std::unordered_map<const ActionsDAG::Node *, Match>;\n+};\n+\n+MatchedTrees::Matches matchTrees(const ActionsDAG & inner_dag, const ActionsDAG & outer_dag)\n+{\n+    using Parents = std::set<const ActionsDAG::Node *>;\n+    std::unordered_map<const ActionsDAG::Node *, Parents> inner_parents;\n+    std::unordered_map<std::string_view, const ActionsDAG::Node *> inner_inputs;\n+\n+    {\n+        std::stack<const ActionsDAG::Node *> stack;\n+        for (const auto * out : inner_dag.getOutputs())\n+        {\n+            if (inner_parents.contains(out))\n+                continue;\n+\n+            stack.push(out);\n+            inner_parents.emplace(out, Parents());\n+            while (!stack.empty())\n+            {\n+                const auto * node = stack.top();\n+                stack.pop();\n+\n+                if (node->type == ActionsDAG::ActionType::INPUT)\n+                    inner_inputs.emplace(node->result_name, node);\n+\n+                for (const auto * child : node->children)\n+                {\n+                    auto [it, inserted] = inner_parents.emplace(child, Parents());\n+                    it->second.emplace(node);\n+\n+                    if (inserted)\n+                        stack.push(child);\n+                }\n+            }\n+        }\n+    }\n+\n+    struct Frame\n+    {\n+        const ActionsDAG::Node * node;\n+        ActionsDAG::NodeRawConstPtrs mapped_children;\n+    };\n+\n+    MatchedTrees::Matches matches;\n+    std::stack<Frame> stack;\n+\n+    for (const auto & node : outer_dag.getNodes())\n+    {\n+        if (matches.contains(&node))\n+            continue;\n+\n+        stack.push(Frame{&node, {}});\n+        while (!stack.empty())\n+        {\n+            auto & frame = stack.top();\n+            frame.mapped_children.reserve(frame.node->children.size());\n+\n+            while (frame.mapped_children.size() < frame.node->children.size())\n+            {\n+                const auto * child = frame.node->children[frame.mapped_children.size()];\n+                auto it = matches.find(child);\n+                if (it == matches.end())\n+                {\n+                    /// If match map does not contain a child, it was not visited.\n+                    stack.push(Frame{child, {}});\n+                    break;\n+                }\n+                /// A node from found match may be nullptr.\n+                /// It means that node is visited, but no match was found.\n+                frame.mapped_children.push_back(it->second.node);\n+            }\n+\n+            if (frame.mapped_children.size() < frame.node->children.size())\n+                continue;\n+\n+            /// Create an empty match for current node.\n+            /// natch.node will be set if match is found.\n+            auto & match = matches[frame.node];\n+\n+            if (frame.node->type == ActionsDAG::ActionType::INPUT)\n+            {\n+                const ActionsDAG::Node * mapped = nullptr;\n+                if (auto it = inner_inputs.find(frame.node->result_name); it != inner_inputs.end())\n+                    mapped = it->second;\n+\n+                match.node = mapped;\n+            }\n+            else if (frame.node->type == ActionsDAG::ActionType::ALIAS)\n+            {\n+                match = matches[frame.node->children.at(0)];\n+            }\n+            else if (frame.node->type == ActionsDAG::ActionType::FUNCTION)\n+            {\n+\n+                //std::cerr << \"... Processing \" << frame.node->function_base->getName() << std::endl;\n+\n+                bool found_all_children = true;\n+                for (const auto * child : frame.mapped_children)\n+                    if (!child)\n+                        found_all_children = false;\n+\n+                if (found_all_children && !frame.mapped_children.empty())\n+                {\n+                    Parents container;\n+                    Parents * intersection = &inner_parents[frame.mapped_children[0]];\n+\n+                    if (frame.mapped_children.size() > 1)\n+                    {\n+                        std::vector<Parents *> other_parents;\n+                        size_t mapped_children_size = frame.mapped_children.size();\n+                        other_parents.reserve(mapped_children_size);\n+                        for (size_t i = 1; i < mapped_children_size; ++i)\n+                            other_parents.push_back(&inner_parents[frame.mapped_children[i]]);\n+\n+                        for (const auto * parent : *intersection)\n+                        {\n+                            bool is_common = true;\n+                            for (const auto * set : other_parents)\n+                            {\n+                                if (!set->contains(parent))\n+                                {\n+                                    is_common = false;\n+                                    break;\n+                                }\n+                            }\n+\n+                            if (is_common)\n+                                container.insert(parent);\n+                        }\n+\n+                        intersection = &container;\n+                    }\n+\n+                    //std::cerr << \".. Candidate parents \" << intersection->size() << std::endl;\n+\n+                    if (!intersection->empty())\n+                    {\n+                        auto func_name = frame.node->function_base->getName();\n+                        for (const auto * parent : *intersection)\n+                        {\n+                            //std::cerr << \".. candidate \" << parent->result_name << std::endl;\n+                            if (parent->type == ActionsDAG::ActionType::FUNCTION && func_name == parent->function_base->getName())\n+                            {\n+                                const auto & children = parent->children;\n+                                size_t num_children = children.size();\n+                                if (frame.mapped_children.size() == num_children)\n+                                {\n+                                    bool all_children_matched = true;\n+                                    for (size_t i = 0; all_children_matched && i < num_children; ++i)\n+                                        all_children_matched = frame.mapped_children[i] == children[i];\n+\n+                                    if (all_children_matched)\n+                                    {\n+                                        match.node = parent;\n+                                        break;\n+                                    }\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+\n+                if (!match.node && frame.node->function_base->hasInformationAboutMonotonicity())\n+                {\n+                    size_t num_const_args = 0;\n+                    const ActionsDAG::Node * monotonic_child = nullptr;\n+                    for (const auto * child : frame.node->children)\n+                    {\n+                        if (child->column)\n+                            ++num_const_args;\n+                        else\n+                            monotonic_child = child;\n+                    }\n+\n+                    if (monotonic_child && num_const_args + 1 == frame.node->children.size())\n+                    {\n+                        const auto & child_match = matches[monotonic_child];\n+                        if (child_match.node)\n+                        {\n+                            auto info = frame.node->function_base->getMonotonicityForRange(*monotonic_child->result_type, {}, {});\n+                            if (info.is_monotonic)\n+                            {\n+                                MatchedTrees::Monotonicity monotonicity;\n+                                monotonicity.direction *= info.is_positive ? 1 : -1;\n+                                monotonicity.strict = info.is_strict;\n+\n+                                if (child_match.monotonicity)\n+                                {\n+                                    monotonicity.direction *= child_match.monotonicity->direction;\n+                                    if (!child_match.monotonicity->strict)\n+                                        monotonicity.strict = false;\n+                                }\n+\n+                                match.node = child_match.node;\n+                                match.monotonicity = monotonicity;\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+\n+            stack.pop();\n+        }\n+    }\n+\n+    return matches;\n+}\n+\n+InputOrderInfoPtr buildInputOrderInfo(\n+    const FixedColumns & fixed_columns,\n+    const ActionsDAGPtr & dag,\n+    const SortDescription & description,\n+    const ActionsDAG & sorting_key_dag,\n+    const Names & sorting_key_columns,\n+    size_t limit)\n+{\n+    //std::cerr << \"------- buildInputOrderInfo \" << std::endl;\n+    SortDescription order_key_prefix_descr;\n+    order_key_prefix_descr.reserve(description.size());\n+\n+    MatchedTrees::Matches matches;\n+    FixedColumns fixed_key_columns;\n+\n+    if (dag)\n+    {\n+        matches = matchTrees(sorting_key_dag, *dag);\n+\n+        for (const auto & [node, match] : matches)\n+        {\n+            //std::cerr << \"------- matching \" << static_cast<const void *>(node) << \" \" << node->result_name\n+            //    << \" to \" << static_cast<const void *>(match.node) << \" \" << (match.node ? match.node->result_name : \"\") << std::endl;\n+            if (!match.monotonicity || match.monotonicity->strict)\n+            {\n+                if (match.node && fixed_columns.contains(node))\n+                    fixed_key_columns.insert(match.node);\n+            }\n+        }\n+\n+        enreachFixedColumns(sorting_key_dag, fixed_key_columns);\n+    }\n+\n+    /// This is a result direction we will read from MergeTree\n+    ///  1 - in order,\n+    /// -1 - in reverse order,\n+    ///  0 - usual read, don't apply optimization\n+    ///\n+    /// So far, 0 means any direction is possible. It is ok for constant prefix.\n+    int read_direction = 0;\n+    size_t next_description_column = 0;\n+    size_t next_sort_key = 0;\n+\n+    while (next_description_column < description.size() && next_sort_key < sorting_key_columns.size())\n+    {\n+        const auto & sorting_key_column = sorting_key_columns[next_sort_key];\n+        const auto & sort_column_description = description[next_description_column];\n+\n+        /// If required order depend on collation, it cannot be matched with primary key order.\n+        /// Because primary keys cannot have collations.\n+        if (sort_column_description.collator)\n+            break;\n+\n+        /// Direction for current sort key.\n+        int current_direction = 0;\n+        bool strict_monotonic = true;\n+\n+        const ActionsDAG::Node * sort_column_node = sorting_key_dag.tryFindInOutputs(sorting_key_column);\n+        /// This should not happen.\n+        if (!sort_column_node)\n+            break;\n+\n+        if (!dag)\n+        {\n+            /// This is possible if there were no Expression or Filter steps in Plan.\n+            /// Example: SELECT * FROM tab ORDER BY a, b\n+\n+            if (sort_column_node->type != ActionsDAG::ActionType::INPUT)\n+                break;\n+\n+            if (sort_column_description.column_name != sorting_key_column)\n+                break;\n+\n+            current_direction = sort_column_description.direction;\n+\n+\n+            //std::cerr << \"====== (no dag) Found direct match\" << std::endl;\n+\n+            ++next_description_column;\n+            ++next_sort_key;\n+        }\n+        else\n+        {\n+            const ActionsDAG::Node * sort_node = dag->tryFindInOutputs(sort_column_description.column_name);\n+             /// It is possible when e.g. sort by array joined column.\n+            if (!sort_node)\n+                break;\n+\n+            const auto & match = matches[sort_node];\n+\n+            //std::cerr << \"====== Finding match for \" << sort_column_node->result_name << ' ' << static_cast<const void *>(sort_column_node) << std::endl;\n+\n+            if (match.node && match.node == sort_column_node)\n+            {\n+                //std::cerr << \"====== Found direct match\" << std::endl;\n+\n+                /// We try to find the match first even if column is fixed. In this case, potentially more keys will match.\n+                /// Example: 'table (x Int32, y Int32) ORDER BY x + 1, y + 1'\n+                ///          'SELECT x, y FROM table WHERE x = 42 ORDER BY x + 1, y + 1'\n+                /// Here, 'x + 1' would be a fixed point. But it is reasonable to read-in-order.\n+\n+                current_direction = sort_column_description.direction;\n+                if (match.monotonicity)\n+                {\n+                    current_direction *= match.monotonicity->direction;\n+                    strict_monotonic = match.monotonicity->strict;\n+                }\n+\n+                ++next_description_column;\n+                ++next_sort_key;\n+            }\n+            else if (fixed_key_columns.contains(sort_column_node))\n+            {\n+                //std::cerr << \"+++++++++ Found fixed key by match\" << std::endl;\n+                ++next_sort_key;\n+            }\n+            else\n+            {\n+\n+                //std::cerr << \"====== Check for fixed const : \" << bool(sort_node->column) << \" fixed : \" << fixed_columns.contains(sort_node) << std::endl;\n+                bool is_fixed_column = sort_node->column || fixed_columns.contains(sort_node);\n+                if (!is_fixed_column)\n+                    break;\n+\n+                order_key_prefix_descr.push_back(sort_column_description);\n+                ++next_description_column;\n+            }\n+        }\n+\n+        /// read_direction == 0 means we can choose any global direction.\n+        /// current_direction == 0 means current key if fixed and any direction is possible for it.\n+        if (current_direction && read_direction && current_direction != read_direction)\n+            break;\n+\n+        if (read_direction == 0)\n+            read_direction = current_direction;\n+\n+        if (current_direction)\n+            order_key_prefix_descr.push_back(sort_column_description);\n+\n+        if (current_direction && !strict_monotonic)\n+            break;\n+    }\n+\n+    if (read_direction == 0 || order_key_prefix_descr.empty())\n+        return nullptr;\n+\n+    return std::make_shared<InputOrderInfo>(order_key_prefix_descr, next_sort_key, read_direction, limit);\n+}\n+\n+InputOrderInfoPtr buildInputOrderInfo(\n+    ReadFromMergeTree * reading,\n+    const FixedColumns & fixed_columns,\n+    const ActionsDAGPtr & dag,\n+    const SortDescription & description,\n+    size_t limit)\n+{\n+    const auto & sorting_key = reading->getStorageMetadata()->getSortingKey();\n+    const auto & sorting_key_columns = sorting_key.column_names;\n+\n+    return buildInputOrderInfo(\n+        fixed_columns,\n+        dag, description,\n+        sorting_key.expression->getActionsDAG(), sorting_key_columns,\n+        limit);\n+}\n+\n+InputOrderInfoPtr buildInputOrderInfo(\n+    ReadFromMerge * merge,\n+    const FixedColumns & fixed_columns,\n+    const ActionsDAGPtr & dag,\n+    const SortDescription & description,\n+    size_t limit)\n+{\n+    const auto & tables = merge->getSelectedTables();\n+\n+    InputOrderInfoPtr order_info;\n+    for (const auto & table : tables)\n+    {\n+        auto storage = std::get<StoragePtr>(table);\n+        const auto & sorting_key = storage->getInMemoryMetadataPtr()->getSortingKey();\n+        const auto & sorting_key_columns = sorting_key.column_names;\n+\n+        if (sorting_key_columns.empty())\n+            return nullptr;\n+\n+        auto table_order_info = buildInputOrderInfo(\n+            fixed_columns,\n+            dag, description,\n+            sorting_key.expression->getActionsDAG(), sorting_key_columns,\n+            limit);\n+\n+        if (!table_order_info)\n+            return nullptr;\n+\n+        if (!order_info)\n+            order_info = table_order_info;\n+        else if (*order_info != *table_order_info)\n+            return nullptr;\n+    }\n+\n+    return order_info;\n+}\n+\n+InputOrderInfoPtr buildInputOrderInfo(SortingStep & sorting, QueryPlan::Node & node)\n+{\n+    QueryPlan::Node * reading_node = findReadingStep(node);\n+    if (!reading_node)\n+        return nullptr;\n+\n+    const auto & description = sorting.getSortDescription();\n+    size_t limit = sorting.getLimit();\n+\n+    ActionsDAGPtr dag;\n+    FixedColumns fixed_columns;\n+    buildSortingDAG(node, dag, fixed_columns, limit);\n+\n+    if (dag && !fixed_columns.empty())\n+        enreachFixedColumns(*dag, fixed_columns);\n+\n+    if (auto * reading = typeid_cast<ReadFromMergeTree *>(reading_node->step.get()))\n+    {\n+\n+        //std::cerr << \"---- optimizeReadInOrder found mt\" << std::endl;\n+        auto order_info = buildInputOrderInfo(\n+            reading,\n+            fixed_columns,\n+            dag, description,\n+            limit);\n+\n+        if (order_info)\n+            reading->requestReadingInOrder(order_info->used_prefix_of_sorting_key_size, order_info->direction, order_info->limit);\n+\n+        return order_info;\n+    }\n+    else if (auto * merge = typeid_cast<ReadFromMerge *>(reading_node->step.get()))\n+    {\n+        auto order_info = buildInputOrderInfo(\n+            merge,\n+            fixed_columns,\n+            dag, description,\n+            limit);\n+\n+        if (order_info)\n+            merge->requestReadingInOrder(order_info);\n+\n+        return order_info;\n+    }\n+\n+    return nullptr;\n+}\n+\n+void optimizeReadInOrder(QueryPlan::Node & node, QueryPlan::Nodes & nodes)\n+{\n+    if (node.children.size() != 1)\n+        return;\n+\n+    auto * sorting = typeid_cast<SortingStep *>(node.step.get());\n+    if (!sorting)\n+        return;\n+\n+    //std::cerr << \"---- optimizeReadInOrder found sorting\" << std::endl;\n+\n+    if (sorting->getType() != SortingStep::Type::Full)\n+        return;\n+\n+    if (typeid_cast<UnionStep *>(node.children.front()->step.get()))\n+    {\n+        auto & union_node = node.children.front();\n+\n+        std::vector<InputOrderInfoPtr> infos;\n+        const SortDescription * max_sort_descr = nullptr;\n+        infos.reserve(node.children.size());\n+        for (auto * child : union_node->children)\n+        {\n+            infos.push_back(buildInputOrderInfo(*sorting, *child));\n+\n+            if (infos.back() && (!max_sort_descr || max_sort_descr->size() < infos.back()->sort_description_for_merging.size()))\n+                max_sort_descr = &infos.back()->sort_description_for_merging;\n+        }\n+\n+        if (!max_sort_descr || max_sort_descr->empty())\n+            return;\n+\n+        for (size_t i = 0; i < infos.size(); ++i)\n+        {\n+            const auto & info = infos[i];\n+            auto & child = union_node->children[i];\n+\n+            QueryPlanStepPtr additional_sorting;\n+\n+            if (!info)\n+            {\n+                auto limit = sorting->getLimit();\n+                /// If we have limit, it's better to sort up to full description and apply limit.\n+                /// We cannot sort up to partial read-in-order description with limit cause result set can be wrong.\n+                const auto & descr = limit ? sorting->getSortDescription() : *max_sort_descr;\n+                additional_sorting = std::make_unique<SortingStep>(\n+                    child->step->getOutputStream(),\n+                    descr,\n+                    limit, /// TODO: support limit with ties\n+                    sorting->getSettings(),\n+                    false);\n+            }\n+            else if (info->sort_description_for_merging.size() < max_sort_descr->size())\n+            {\n+                additional_sorting = std::make_unique<SortingStep>(\n+                    child->step->getOutputStream(),\n+                    info->sort_description_for_merging,\n+                    *max_sort_descr,\n+                    sorting->getSettings().max_block_size,\n+                    0); /// TODO: support limit with ties\n+            }\n+\n+            if (additional_sorting)\n+            {\n+                auto & sort_node = nodes.emplace_back();\n+                sort_node.step = std::move(additional_sorting);\n+                sort_node.children.push_back(child);\n+                child = &sort_node;\n+            }\n+        }\n+\n+        sorting->convertToFinishSorting(*max_sort_descr);\n+    }\n+    else if (auto order_info = buildInputOrderInfo(*sorting, *node.children.front()))\n+    {\n+        sorting->convertToFinishSorting(order_info->sort_description_for_merging);\n+    }\n+}\n+\n+/// This optimisation is obsolete and will be removed.\n+/// optimizeReadInOrder covers it.\n+size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*nodes*/)\n+{\n+    /// Find the following sequence of steps, add InputOrderInfo and apply prefix sort description to\n+    /// SortingStep:\n+    /// WindowStep <- SortingStep <- [Expression] <- ReadFromMergeTree\n+\n+    auto * window_node = parent_node;\n+    auto * window = typeid_cast<WindowStep *>(window_node->step.get());\n+    if (!window)\n+        return 0;\n+    if (window_node->children.size() != 1)\n+        return 0;\n+\n+    auto * sorting_node = window_node->children.front();\n+    auto * sorting = typeid_cast<SortingStep *>(sorting_node->step.get());\n+    if (!sorting)\n+        return 0;\n+    if (sorting_node->children.size() != 1)\n+        return 0;\n+\n+    auto * possible_read_from_merge_tree_node = sorting_node->children.front();\n+\n+    if (typeid_cast<ExpressionStep *>(possible_read_from_merge_tree_node->step.get()))\n+    {\n+        if (possible_read_from_merge_tree_node->children.size() != 1)\n+            return 0;\n+\n+        possible_read_from_merge_tree_node = possible_read_from_merge_tree_node->children.front();\n+    }\n+\n+    auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(possible_read_from_merge_tree_node->step.get());\n+    if (!read_from_merge_tree)\n+    {\n+        return 0;\n+    }\n+\n+    auto context = read_from_merge_tree->getContext();\n+    const auto & settings = context->getSettings();\n+    if (!settings.optimize_read_in_window_order || (settings.optimize_read_in_order && settings.query_plan_read_in_order) || context->getSettingsRef().allow_experimental_analyzer)\n+    {\n+        return 0;\n+    }\n+\n+    const auto & query_info = read_from_merge_tree->getQueryInfo();\n+    const auto * select_query = query_info.query->as<ASTSelectQuery>();\n+\n+    /// TODO: Analyzer syntax analyzer result\n+    if (!query_info.syntax_analyzer_result)\n+        return 0;\n+\n+    ManyExpressionActions order_by_elements_actions;\n+    const auto & window_desc = window->getWindowDescription();\n+\n+    for (const auto & actions_dag : window_desc.partition_by_actions)\n+    {\n+        order_by_elements_actions.emplace_back(\n+            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));\n+    }\n+\n+    for (const auto & actions_dag : window_desc.order_by_actions)\n+    {\n+        order_by_elements_actions.emplace_back(\n+            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));\n+    }\n+\n+    auto order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n+            *select_query,\n+            order_by_elements_actions,\n+            window->getWindowDescription().full_sort_description,\n+            query_info.syntax_analyzer_result);\n+\n+    /// If we don't have filtration, we can pushdown limit to reading stage for optimizations.\n+    UInt64 limit = (select_query->hasFiltration() || select_query->groupBy()) ? 0 : InterpreterSelectQuery::getLimitForSorting(*select_query, context);\n+\n+    auto order_info = order_optimizer->getInputOrder(\n+            query_info.projection ? query_info.projection->desc->metadata : read_from_merge_tree->getStorageMetadata(),\n+            context,\n+            limit);\n+\n+    if (order_info)\n+    {\n+        read_from_merge_tree->requestReadingInOrder(order_info->used_prefix_of_sorting_key_size, order_info->direction, order_info->limit);\n+        sorting->convertToFinishSorting(order_info->sort_description_for_merging);\n+    }\n+\n+    return 0;\n+}\n+\n+}\ndiff --git a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\nindex ff30cfd8cf34..f514e145a92f 100644\n--- a/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\n+++ b/src/Processors/QueryPlan/Optimizations/optimizeTree.cpp\n@@ -14,7 +14,7 @@ namespace ErrorCodes\n namespace QueryPlanOptimizations\n {\n \n-void optimizeTree(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes)\n+void optimizeTreeFirstPass(const QueryPlanOptimizationSettings & settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes)\n {\n     if (!settings.optimize_plan)\n         return;\n@@ -98,5 +98,38 @@ void optimizeTree(const QueryPlanOptimizationSettings & settings, QueryPlan::Nod\n     }\n }\n \n+void optimizeTreeSecondPass(const QueryPlanOptimizationSettings & optimization_settings, QueryPlan::Node & root, QueryPlan::Nodes & nodes)\n+{\n+    Stack stack;\n+    stack.push_back({.node = &root});\n+\n+    while (!stack.empty())\n+    {\n+        auto & frame = stack.back();\n+\n+        if (frame.next_child == 0)\n+        {\n+            if (optimization_settings.read_in_order)\n+                optimizeReadInOrder(*frame.node, nodes);\n+\n+            if (optimization_settings.distinct_in_order)\n+                tryDistinctReadInOrder(frame.node);\n+        }\n+\n+        /// Traverse all children first.\n+        if (frame.next_child < frame.node->children.size())\n+        {\n+            auto next_frame = Frame{.node = frame.node->children[frame.next_child]};\n+            ++frame.next_child;\n+            stack.push_back(next_frame);\n+            continue;\n+        }\n+\n+        optimizePrimaryKeyCondition(stack);\n+\n+        stack.pop_back();\n+    }\n+}\n+\n }\n }\ndiff --git a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp b/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp\ndeleted file mode 100644\nindex c74b5ed915b5..000000000000\n--- a/src/Processors/QueryPlan/Optimizations/reuseStorageOrderingForWindowFunctions.cpp\n+++ /dev/null\n@@ -1,115 +0,0 @@\n-#include <Parsers/ASTWindowDefinition.h>\n-#include <Processors/QueryPlan/Optimizations/Optimizations.h>\n-#include <Processors/QueryPlan/ITransformingStep.h>\n-#include <Processors/QueryPlan/AggregatingStep.h>\n-#include <Processors/QueryPlan/ExpressionStep.h>\n-#include <Processors/QueryPlan/JoinStep.h>\n-#include <Processors/QueryPlan/ArrayJoinStep.h>\n-#include <Processors/QueryPlan/CreatingSetsStep.h>\n-#include <Processors/QueryPlan/CubeStep.h>\n-#include <Processors/QueryPlan/ReadFromMergeTree.h>\n-#include <Processors/QueryPlan/SortingStep.h>\n-#include <Processors/QueryPlan/TotalsHavingStep.h>\n-#include <Processors/QueryPlan/DistinctStep.h>\n-#include <Processors/QueryPlan/UnionStep.h>\n-#include <Processors/QueryPlan/WindowStep.h>\n-#include <Interpreters/ActionsDAG.h>\n-#include <Interpreters/ArrayJoinAction.h>\n-#include <Interpreters/InterpreterSelectQuery.h>\n-#include <Interpreters/TableJoin.h>\n-#include <Common/typeid_cast.h>\n-#include <DataTypes/DataTypeAggregateFunction.h>\n-#include <Columns/IColumn.h>\n-\n-\n-namespace DB::QueryPlanOptimizations\n-{\n-\n-size_t tryReuseStorageOrderingForWindowFunctions(QueryPlan::Node * parent_node, QueryPlan::Nodes & /*nodes*/)\n-{\n-    /// Find the following sequence of steps, add InputOrderInfo and apply prefix sort description to\n-    /// SortingStep:\n-    /// WindowStep <- SortingStep <- [Expression] <- ReadFromMergeTree\n-\n-    auto * window_node = parent_node;\n-    auto * window = typeid_cast<WindowStep *>(window_node->step.get());\n-    if (!window)\n-        return 0;\n-    if (window_node->children.size() != 1)\n-        return 0;\n-\n-    auto * sorting_node = window_node->children.front();\n-    auto * sorting = typeid_cast<SortingStep *>(sorting_node->step.get());\n-    if (!sorting)\n-        return 0;\n-    if (sorting_node->children.size() != 1)\n-        return 0;\n-\n-    auto * possible_read_from_merge_tree_node = sorting_node->children.front();\n-\n-    if (typeid_cast<ExpressionStep *>(possible_read_from_merge_tree_node->step.get()))\n-    {\n-        if (possible_read_from_merge_tree_node->children.size() != 1)\n-            return 0;\n-\n-        possible_read_from_merge_tree_node = possible_read_from_merge_tree_node->children.front();\n-    }\n-\n-    auto * read_from_merge_tree = typeid_cast<ReadFromMergeTree *>(possible_read_from_merge_tree_node->step.get());\n-    if (!read_from_merge_tree)\n-    {\n-        return 0;\n-    }\n-\n-    auto context = read_from_merge_tree->getContext();\n-    if (!context->getSettings().optimize_read_in_window_order || context->getSettingsRef().allow_experimental_analyzer)\n-    {\n-        return 0;\n-    }\n-\n-    const auto & query_info = read_from_merge_tree->getQueryInfo();\n-    const auto * select_query = query_info.query->as<ASTSelectQuery>();\n-\n-    /// TODO: Analyzer syntax analyzer result\n-    if (!query_info.syntax_analyzer_result)\n-        return 0;\n-\n-    ManyExpressionActions order_by_elements_actions;\n-    const auto & window_desc = window->getWindowDescription();\n-\n-    for (const auto & actions_dag : window_desc.partition_by_actions)\n-    {\n-        order_by_elements_actions.emplace_back(\n-            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));\n-    }\n-\n-    for (const auto & actions_dag : window_desc.order_by_actions)\n-    {\n-        order_by_elements_actions.emplace_back(\n-            std::make_shared<ExpressionActions>(actions_dag, ExpressionActionsSettings::fromContext(context, CompileExpressions::yes)));\n-    }\n-\n-    auto order_optimizer = std::make_shared<ReadInOrderOptimizer>(\n-            *select_query,\n-            order_by_elements_actions,\n-            window->getWindowDescription().full_sort_description,\n-            query_info.syntax_analyzer_result);\n-\n-    /// If we don't have filtration, we can pushdown limit to reading stage for optimizations.\n-    UInt64 limit = (select_query->hasFiltration() || select_query->groupBy()) ? 0 : InterpreterSelectQuery::getLimitForSorting(*select_query, context);\n-\n-    auto order_info = order_optimizer->getInputOrder(\n-            query_info.projection ? query_info.projection->desc->metadata : read_from_merge_tree->getStorageMetadata(),\n-            context,\n-            limit);\n-\n-    if (order_info)\n-    {\n-        read_from_merge_tree->requestReadingInOrder(order_info->used_prefix_of_sorting_key_size, order_info->direction, order_info->limit);\n-        sorting->convertToFinishSorting(order_info->sort_description_for_merging);\n-    }\n-\n-    return 0;\n-}\n-\n-}\ndiff --git a/src/Processors/QueryPlan/QueryPlan.cpp b/src/Processors/QueryPlan/QueryPlan.cpp\nindex 5a92bcb41ee6..e1662d430158 100644\n--- a/src/Processors/QueryPlan/QueryPlan.cpp\n+++ b/src/Processors/QueryPlan/QueryPlan.cpp\n@@ -447,8 +447,8 @@ void QueryPlan::explainPipeline(WriteBuffer & buffer, const ExplainPipelineOptio\n \n void QueryPlan::optimize(const QueryPlanOptimizationSettings & optimization_settings)\n {\n-    QueryPlanOptimizations::optimizeTree(optimization_settings, *root, nodes);\n-    QueryPlanOptimizations::optimizePrimaryKeyCondition(*root);\n+    QueryPlanOptimizations::optimizeTreeFirstPass(optimization_settings, *root, nodes);\n+    QueryPlanOptimizations::optimizeTreeSecondPass(optimization_settings, *root, nodes);\n }\n \n void QueryPlan::explainEstimate(MutableColumns & columns)\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.cpp b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\nindex b268e7deff02..59f3e094cb75 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.cpp\n@@ -67,7 +67,7 @@ static MergeTreeReaderSettings getMergeTreeReaderSettings(\n     };\n }\n \n-static const PrewhereInfoPtr & getPrewhereInfo(const SelectQueryInfo & query_info)\n+static const PrewhereInfoPtr & getPrewhereInfoFromQueryInfo(const SelectQueryInfo & query_info)\n {\n     return query_info.projection ? query_info.projection->prewhere_info\n                                  : query_info.prewhere_info;\n@@ -90,7 +90,7 @@ ReadFromMergeTree::ReadFromMergeTree(\n     bool enable_parallel_reading)\n     : ISourceStep(DataStream{.header = MergeTreeBaseSelectProcessor::transformHeader(\n         storage_snapshot_->getSampleBlockForColumns(real_column_names_),\n-        getPrewhereInfo(query_info_),\n+        getPrewhereInfoFromQueryInfo(query_info_),\n         data_.getPartitionValueType(),\n         virt_column_names_)})\n     , reader_settings(getMergeTreeReaderSettings(context_, query_info_))\n@@ -99,7 +99,7 @@ ReadFromMergeTree::ReadFromMergeTree(\n     , virt_column_names(std::move(virt_column_names_))\n     , data(data_)\n     , query_info(query_info_)\n-    , prewhere_info(getPrewhereInfo(query_info))\n+    , prewhere_info(getPrewhereInfoFromQueryInfo(query_info))\n     , actions_settings(ExpressionActionsSettings::fromContext(context_))\n     , storage_snapshot(std::move(storage_snapshot_))\n     , metadata_for_reading(storage_snapshot->getMetadataForQuery())\n@@ -441,6 +441,25 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n     if (info.sum_marks == 0)\n         return {};\n \n+    /// PREWHERE actions can remove some input columns (which are needed only for prewhere condition).\n+    /// In case of read-in-order, PREWHERE is executed before sorting. But removed columns could be needed for sorting key.\n+    /// To fix this, we prohibit removing any input in prewhere actions. Instead, projection actions will be added after sorting.\n+    /// See 02354_read_in_order_prewhere.sql as an example.\n+    bool have_input_columns_removed_after_prewhere = false;\n+    if (prewhere_info && prewhere_info->prewhere_actions)\n+    {\n+        auto & outputs = prewhere_info->prewhere_actions->getOutputs();\n+        std::unordered_set<const ActionsDAG::Node *> outputs_set(outputs.begin(), outputs.end());\n+        for (const auto * input :  prewhere_info->prewhere_actions->getInputs())\n+        {\n+            if (!outputs_set.contains(input))\n+            {\n+                outputs.push_back(input);\n+                have_input_columns_removed_after_prewhere = true;\n+            }\n+        }\n+    }\n+\n     /// Let's split ranges to avoid reading much data.\n     auto split_ranges = [rows_granularity = data_settings->index_granularity, max_block_size = max_block_size]\n         (const auto & ranges, int direction)\n@@ -567,6 +586,10 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n                                         info.use_uncompressed_cache, input_order_info->limit));\n     }\n \n+    Block pipe_header;\n+    if (!pipes.empty())\n+        pipe_header = pipes.front().getHeader();\n+\n     if (need_preliminary_merge)\n     {\n         size_t prefix_size = input_order_info->used_prefix_of_sorting_key_size;\n@@ -588,9 +611,6 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n \n         for (auto & pipe : pipes)\n         {\n-            /// Drop temporary columns, added by 'sorting_key_prefix_expr'\n-            out_projection = createProjection(pipe.getHeader());\n-\n             pipe.addSimpleTransform([sorting_key_expr](const Block & header)\n             {\n                 return std::make_shared<ExpressionTransform>(header, sorting_key_expr);\n@@ -610,6 +630,10 @@ Pipe ReadFromMergeTree::spreadMarkRangesAmongStreamsWithOrder(\n         }\n     }\n \n+    if (!pipes.empty() && (need_preliminary_merge || have_input_columns_removed_after_prewhere))\n+        /// Drop temporary columns, added by 'sorting_key_prefix_expr'\n+        out_projection = createProjection(pipe_header);\n+\n     return Pipe::unitePipes(std::move(pipes));\n }\n \n@@ -1062,6 +1086,8 @@ void ReadFromMergeTree::requestReadingInOrder(size_t prefix_size, int direction,\n     else\n         query_info.input_order_info = order_info;\n \n+    reader_settings.read_in_order = true;\n+\n     /// update sort info for output stream\n     SortDescription sort_description;\n     const Names & sorting_key_columns = storage_snapshot->getMetadataForQuery()->getSortingKeyColumns();\n@@ -1074,14 +1100,14 @@ void ReadFromMergeTree::requestReadingInOrder(size_t prefix_size, int direction,\n             break;\n         sort_description.emplace_back(column_name, sort_direction);\n     }\n-    if (sort_description.empty())\n-        throw Exception(ErrorCodes::LOGICAL_ERROR, \"Sort description can't be empty when reading in order\");\n-\n-    const size_t used_prefix_of_sorting_key_size = order_info->used_prefix_of_sorting_key_size;\n-    if (sort_description.size() > used_prefix_of_sorting_key_size)\n-        sort_description.resize(used_prefix_of_sorting_key_size);\n-    output_stream->sort_description = std::move(sort_description);\n-    output_stream->sort_scope = DataStream::SortScope::Stream;\n+    if (!sort_description.empty())\n+    {\n+        const size_t used_prefix_of_sorting_key_size = order_info->used_prefix_of_sorting_key_size;\n+        if (sort_description.size() > used_prefix_of_sorting_key_size)\n+            sort_description.resize(used_prefix_of_sorting_key_size);\n+        output_stream->sort_description = std::move(sort_description);\n+        output_stream->sort_scope = DataStream::SortScope::Stream;\n+    }\n }\n \n ReadFromMergeTree::AnalysisResult ReadFromMergeTree::getAnalysisResult() const\ndiff --git a/src/Processors/QueryPlan/ReadFromMergeTree.h b/src/Processors/QueryPlan/ReadFromMergeTree.h\nindex 15258eb6c407..808e849fe037 100644\n--- a/src/Processors/QueryPlan/ReadFromMergeTree.h\n+++ b/src/Processors/QueryPlan/ReadFromMergeTree.h\n@@ -150,6 +150,7 @@ class ReadFromMergeTree final : public ISourceStep\n     ContextPtr getContext() const { return context; }\n     const SelectQueryInfo & getQueryInfo() const { return query_info; }\n     StorageMetadataPtr getStorageMetadata() const { return metadata_for_reading; }\n+    const PrewhereInfo * getPrewhereInfo() const { return prewhere_info.get(); }\n \n     void requestReadingInOrder(size_t prefix_size, int direction, size_t limit);\n \n@@ -163,7 +164,7 @@ class ReadFromMergeTree final : public ISourceStep\n         return 1;\n     }\n \n-    const MergeTreeReaderSettings reader_settings;\n+    MergeTreeReaderSettings reader_settings;\n \n     MergeTreeData::DataPartsVector prepared_parts;\n     Names real_column_names;\ndiff --git a/src/Processors/QueryPlan/SortingStep.cpp b/src/Processors/QueryPlan/SortingStep.cpp\nindex bb58eff2f13a..8766c0ba3356 100644\n--- a/src/Processors/QueryPlan/SortingStep.cpp\n+++ b/src/Processors/QueryPlan/SortingStep.cpp\n@@ -23,6 +23,23 @@ namespace ErrorCodes\n     extern const int LOGICAL_ERROR;\n }\n \n+SortingStep::Settings::Settings(const Context & context)\n+{\n+    const auto & settings = context.getSettingsRef();\n+    max_block_size = settings.max_block_size;\n+    size_limits = SizeLimits(settings.max_rows_to_sort, settings.max_bytes_to_sort, settings.sort_overflow_mode);\n+    max_bytes_before_remerge = settings.max_bytes_before_remerge_sort;\n+    remerge_lowered_memory_bytes_ratio = settings.remerge_sort_lowered_memory_bytes_ratio;\n+    max_bytes_before_external_sort = settings.max_bytes_before_external_sort;\n+    tmp_data = context.getTempDataOnDisk();\n+    min_free_disk_space = settings.min_free_disk_space_for_temporary_data;\n+}\n+\n+SortingStep::Settings::Settings(size_t max_block_size_)\n+{\n+    max_block_size = max_block_size_;\n+}\n+\n static ITransformingStep::Traits getTraits(size_t limit)\n {\n     return ITransformingStep::Traits\n@@ -42,29 +59,17 @@ static ITransformingStep::Traits getTraits(size_t limit)\n SortingStep::SortingStep(\n     const DataStream & input_stream,\n     SortDescription description_,\n-    size_t max_block_size_,\n     UInt64 limit_,\n-    SizeLimits size_limits_,\n-    size_t max_bytes_before_remerge_,\n-    double remerge_lowered_memory_bytes_ratio_,\n-    size_t max_bytes_before_external_sort_,\n-    TemporaryDataOnDiskScopePtr tmp_data_,\n-    size_t min_free_disk_space_,\n+    const Settings & settings_,\n     bool optimize_sorting_by_input_stream_properties_)\n     : ITransformingStep(input_stream, input_stream.header, getTraits(limit_))\n     , type(Type::Full)\n     , result_description(std::move(description_))\n-    , max_block_size(max_block_size_)\n     , limit(limit_)\n-    , size_limits(size_limits_)\n-    , max_bytes_before_remerge(max_bytes_before_remerge_)\n-    , remerge_lowered_memory_bytes_ratio(remerge_lowered_memory_bytes_ratio_)\n-    , max_bytes_before_external_sort(max_bytes_before_external_sort_)\n-    , tmp_data(tmp_data_)\n-    , min_free_disk_space(min_free_disk_space_)\n+    , sort_settings(settings_)\n     , optimize_sorting_by_input_stream_properties(optimize_sorting_by_input_stream_properties_)\n {\n-    if (max_bytes_before_external_sort && tmp_data == nullptr)\n+    if (sort_settings.max_bytes_before_external_sort && sort_settings.tmp_data == nullptr)\n         throw Exception(\"Temporary data storage for external sorting is not provided\", ErrorCodes::LOGICAL_ERROR);\n \n     /// TODO: check input_stream is partially sorted by the same description.\n@@ -82,8 +87,8 @@ SortingStep::SortingStep(\n     , type(Type::FinishSorting)\n     , prefix_description(std::move(prefix_description_))\n     , result_description(std::move(result_description_))\n-    , max_block_size(max_block_size_)\n     , limit(limit_)\n+    , sort_settings(max_block_size_)\n {\n     /// TODO: check input_stream is sorted by prefix_description.\n     output_stream->sort_description = result_description;\n@@ -98,9 +103,10 @@ SortingStep::SortingStep(\n     : ITransformingStep(input_stream, input_stream.header, getTraits(limit_))\n     , type(Type::MergingSorted)\n     , result_description(std::move(sort_description_))\n-    , max_block_size(max_block_size_)\n     , limit(limit_)\n+    , sort_settings(max_block_size_)\n {\n+    sort_settings.max_block_size = max_block_size_;\n     /// TODO: check input_stream is partially sorted (each port) by the same description.\n     output_stream->sort_description = result_description;\n     output_stream->sort_scope = DataStream::SortScope::Global;\n@@ -155,7 +161,7 @@ void SortingStep::finishSorting(\n                 increase_sort_description_compile_attempts = false;\n \n             return std::make_shared<FinishSortingTransform>(\n-                header, input_sort_desc, result_sort_desc, max_block_size, limit_, increase_sort_description_compile_attempts_current);\n+                header, input_sort_desc, result_sort_desc, sort_settings.max_block_size, limit_, increase_sort_description_compile_attempts_current);\n         });\n }\n \n@@ -168,7 +174,7 @@ void SortingStep::mergingSorted(QueryPipelineBuilder & pipeline, const SortDescr\n             pipeline.getHeader(),\n             pipeline.getNumStreams(),\n             result_sort_desc,\n-            max_block_size,\n+            sort_settings.max_block_size,\n             SortingQueueStrategy::Batch,\n             limit_);\n \n@@ -197,14 +203,14 @@ void SortingStep::mergeSorting(QueryPipelineBuilder & pipeline, const SortDescri\n             return std::make_shared<MergeSortingTransform>(\n                 header,\n                 result_sort_desc,\n-                max_block_size,\n+                sort_settings.max_block_size,\n                 limit_,\n                 increase_sort_description_compile_attempts_current,\n-                max_bytes_before_remerge / pipeline.getNumStreams(),\n-                remerge_lowered_memory_bytes_ratio,\n-                max_bytes_before_external_sort,\n-                std::make_unique<TemporaryDataOnDisk>(tmp_data, CurrentMetrics::TemporaryFilesForSort),\n-                min_free_disk_space);\n+                sort_settings.max_bytes_before_remerge / pipeline.getNumStreams(),\n+                sort_settings.remerge_lowered_memory_bytes_ratio,\n+                sort_settings.max_bytes_before_external_sort,\n+                std::make_unique<TemporaryDataOnDisk>(sort_settings.tmp_data, CurrentMetrics::TemporaryFilesForSort),\n+                sort_settings.min_free_disk_space);\n         });\n }\n \n@@ -223,7 +229,7 @@ void SortingStep::fullSort(QueryPipelineBuilder & pipeline, const SortDescriptio\n \n         StreamLocalLimits limits;\n         limits.mode = LimitsMode::LIMITS_CURRENT; //-V1048\n-        limits.size_limits = size_limits;\n+        limits.size_limits = sort_settings.size_limits;\n \n         pipeline.addSimpleTransform(\n             [&](const Block & header, QueryPipelineBuilder::StreamType stream_type) -> ProcessorPtr\n@@ -241,7 +247,7 @@ void SortingStep::fullSort(QueryPipelineBuilder & pipeline, const SortDescriptio\n     if (pipeline.getNumStreams() > 1)\n     {\n         auto transform = std::make_shared<MergingSortedTransform>(\n-            pipeline.getHeader(), pipeline.getNumStreams(), result_sort_desc, max_block_size, SortingQueueStrategy::Batch, limit_);\n+            pipeline.getHeader(), pipeline.getNumStreams(), result_sort_desc, sort_settings.max_block_size, SortingQueueStrategy::Batch, limit_);\n \n         pipeline.addTransform(std::move(transform));\n     }\ndiff --git a/src/Processors/QueryPlan/SortingStep.h b/src/Processors/QueryPlan/SortingStep.h\nindex d8d86b8cf1da..c8b890dac902 100644\n--- a/src/Processors/QueryPlan/SortingStep.h\n+++ b/src/Processors/QueryPlan/SortingStep.h\n@@ -11,18 +11,33 @@ namespace DB\n class SortingStep : public ITransformingStep\n {\n public:\n+    enum class Type\n+    {\n+        Full,\n+        FinishSorting,\n+        MergingSorted,\n+    };\n+\n+    struct Settings\n+    {\n+        size_t max_block_size;\n+        SizeLimits size_limits;\n+        size_t max_bytes_before_remerge = 0;\n+        double remerge_lowered_memory_bytes_ratio = 0;\n+        size_t max_bytes_before_external_sort = 0;\n+        TemporaryDataOnDiskScopePtr tmp_data = nullptr;\n+        size_t min_free_disk_space = 0;\n+\n+        explicit Settings(const Context & context);\n+        explicit Settings(size_t max_block_size_);\n+    };\n+\n     /// Full\n     SortingStep(\n         const DataStream & input_stream,\n         SortDescription description_,\n-        size_t max_block_size_,\n         UInt64 limit_,\n-        SizeLimits size_limits_,\n-        size_t max_bytes_before_remerge_,\n-        double remerge_lowered_memory_bytes_ratio_,\n-        size_t max_bytes_before_external_sort_,\n-        TemporaryDataOnDiskScopePtr tmp_data_,\n-        size_t min_free_disk_space_,\n+        const Settings & settings_,\n         bool optimize_sorting_by_input_stream_properties_);\n \n     /// FinishSorting\n@@ -47,6 +62,7 @@ class SortingStep : public ITransformingStep\n     void describeActions(JSONBuilder::JSONMap & map) const override;\n     void describeActions(FormatSettings & settings) const override;\n \n+    UInt64 getLimit() const { return limit; }\n     /// Add limit or change it to lower value.\n     void updateLimit(size_t limit_);\n \n@@ -54,6 +70,9 @@ class SortingStep : public ITransformingStep\n \n     void convertToFinishSorting(SortDescription prefix_description);\n \n+    Type getType() const { return type; }\n+    const Settings & getSettings() const { return sort_settings; }\n+\n private:\n     void updateOutputStream() override;\n \n@@ -67,27 +86,14 @@ class SortingStep : public ITransformingStep\n         UInt64 limit_,\n         bool skip_partial_sort = false);\n \n-    enum class Type\n-    {\n-        Full,\n-        FinishSorting,\n-        MergingSorted,\n-    };\n-\n     Type type;\n \n     SortDescription prefix_description;\n     const SortDescription result_description;\n-    const size_t max_block_size;\n     UInt64 limit;\n-    SizeLimits size_limits;\n \n-    size_t max_bytes_before_remerge = 0;\n-    double remerge_lowered_memory_bytes_ratio = 0;\n-    size_t max_bytes_before_external_sort = 0;\n-    TemporaryDataOnDiskScopePtr tmp_data = nullptr;\n+    Settings sort_settings;\n \n-    size_t min_free_disk_space = 0;\n     const bool optimize_sorting_by_input_stream_properties = false;\n };\n \ndiff --git a/src/Storages/StorageMerge.cpp b/src/Storages/StorageMerge.cpp\nindex 7fb21b7e0536..3c4fa3674d28 100644\n--- a/src/Storages/StorageMerge.cpp\n+++ b/src/Storages/StorageMerge.cpp\n@@ -364,9 +364,13 @@ void ReadFromMerge::initializePipeline(QueryPipelineBuilder & pipeline, const Bu\n     size_t num_streams = static_cast<size_t>(requested_num_streams * num_streams_multiplier);\n     size_t remaining_streams = num_streams;\n \n-    InputOrderInfoPtr input_sorting_info;\n-    if (query_info.order_optimizer)\n+    if (order_info)\n+    {\n+         query_info.input_order_info = order_info;\n+    }\n+    else if (query_info.order_optimizer)\n     {\n+        InputOrderInfoPtr input_sorting_info;\n         for (auto it = selected_tables.begin(); it != selected_tables.end(); ++it)\n         {\n             auto storage_ptr = std::get<1>(*it);\ndiff --git a/src/Storages/StorageMerge.h b/src/Storages/StorageMerge.h\nindex 334063211001..54f3999514d0 100644\n--- a/src/Storages/StorageMerge.h\n+++ b/src/Storages/StorageMerge.h\n@@ -144,6 +144,10 @@ class ReadFromMerge final : public ISourceStep\n         added_filter_nodes.nodes.push_back(&expression->findInOutputs(column_name));\n     }\n \n+    const StorageListWithLocks & getSelectedTables() const { return selected_tables; }\n+\n+    void requestReadingInOrder(InputOrderInfoPtr order_info_) { order_info = order_info_; }\n+\n private:\n     const size_t required_max_block_size;\n     const size_t requested_num_streams;\n@@ -165,6 +169,8 @@ class ReadFromMerge final : public ISourceStep\n \n     std::string added_filter_column_name;\n \n+    InputOrderInfoPtr order_info;\n+\n     struct AliasData\n     {\n         String name;\n",
  "test_patch": "diff --git a/tests/queries/0_stateless/00940_order_by_read_in_order_query_plan.reference b/tests/queries/0_stateless/00940_order_by_read_in_order_query_plan.reference\nnew file mode 100644\nindex 000000000000..f08c4cfd3e5e\n--- /dev/null\n+++ b/tests/queries/0_stateless/00940_order_by_read_in_order_query_plan.reference\n@@ -0,0 +1,405 @@\n+-- { echoOn }\n+\n+-- Exact match, single key\n+select * from tab order by (a + b) * c;\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC\n+select * from tab order by (a + b) * c desc;\n+4\t4\t4\t4\n+4\t4\t4\t4\n+3\t3\t3\t3\n+3\t3\t3\t3\n+2\t2\t2\t2\n+2\t2\t2\t2\n+1\t1\t1\t1\n+1\t1\t1\t1\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC\n+  Result sort description: multiply(plus(a, b), c) DESC\n+-- Exact match, full key\n+select * from tab order by (a + b) * c, sin(a / b);\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, sin(a / b)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+select * from tab order by (a + b) * c desc, sin(a / b) desc;\n+4\t4\t4\t4\n+4\t4\t4\t4\n+3\t3\t3\t3\n+3\t3\t3\t3\n+2\t2\t2\t2\n+2\t2\t2\t2\n+1\t1\t1\t1\n+1\t1\t1\t1\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, sin(a / b) desc) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC, sin(divide(a, b)) DESC\n+  Result sort description: multiply(plus(a, b), c) DESC, sin(divide(a, b)) DESC\n+-- Exact match, mixed direction\n+select * from tab order by (a + b) * c desc, sin(a / b);\n+4\t4\t4\t4\n+4\t4\t4\t4\n+3\t3\t3\t3\n+3\t3\t3\t3\n+2\t2\t2\t2\n+2\t2\t2\t2\n+1\t1\t1\t1\n+1\t1\t1\t1\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, sin(a / b)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC\n+  Result sort description: multiply(plus(a, b), c) DESC, sin(divide(a, b)) ASC\n+select * from tab order by (a + b) * c, sin(a / b) desc;\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, sin(a / b) desc) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) DESC\n+-- Wrong order, full sort\n+select * from tab order by sin(a / b), (a + b) * c;\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from tab order by sin(a / b), (a + b) * c) where explain ilike '%sort description%';\n+  Sort description: sin(divide(a, b)) ASC, multiply(plus(a, b), c) ASC\n+-- Fixed point\n+select * from tab where (a + b) * c = 8 order by sin(a / b);\n+2\t2\t2\t2\n+2\t2\t2\t2\n+select * from (explain plan actions = 1 select * from tab where (a + b) * c = 8 order by sin(a / b)) where explain ilike '%sort description%';\n+  Prefix sort description: sin(divide(a, b)) ASC\n+  Result sort description: sin(divide(a, b)) ASC\n+select * from tab where d + 1 = 2 order by (d + 1) * 4, (a + b) * c;\n+1\t1\t1\t1\n+1\t1\t1\t1\n+select * from (explain plan actions = 1 select * from tab where d + 1 = 2 order by (d + 1) * 4, (a + b) * c) where explain ilike '%sort description%';\n+  Prefix sort description: multiply(plus(d, 1), 4) ASC, multiply(plus(a, b), c) ASC\n+  Result sort description: multiply(plus(d, 1), 4) ASC, multiply(plus(a, b), c) ASC\n+select * from tab where d + 1 = 3 and (a + b) = 4 and c = 2 order by (d + 1) * 4, sin(a / b);\n+2\t2\t2\t2\n+2\t2\t2\t2\n+select * from (explain plan actions = 1 select * from tab where d + 1 = 3 and (a + b) = 4 and c = 2 order by (d + 1) * 4, sin(a / b)) where explain ilike '%sort description%';\n+  Prefix sort description: multiply(plus(d, 1), 4) ASC, sin(divide(a, b)) ASC\n+  Result sort description: multiply(plus(d, 1), 4) ASC, sin(divide(a, b)) ASC\n+-- Wrong order with fixed point\n+select * from tab where (a + b) * c = 8 order by sin(b / a);\n+2\t2\t2\t2\n+2\t2\t2\t2\n+select * from (explain plan actions = 1 select * from tab where (a + b) * c = 8 order by sin(b / a)) where explain ilike '%sort description%';\n+  Sort description: sin(divide(b, a)) ASC\n+-- Monotonicity\n+select * from tab order by intDiv((a + b) * c, 2);\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from tab order by intDiv((a + b) * c, 2)) where explain like '%sort description%';\n+  Prefix sort description: intDiv(multiply(plus(a, b), c), 2) ASC\n+  Result sort description: intDiv(multiply(plus(a, b), c), 2) ASC\n+select * from tab order by intDiv((a + b) * c, 2), sin(a / b);\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from tab order by intDiv((a + b) * c, 2), sin(a / b)) where explain like '%sort description%';\n+  Prefix sort description: intDiv(multiply(plus(a, b), c), 2) ASC\n+  Result sort description: intDiv(multiply(plus(a, b), c), 2) ASC, sin(divide(a, b)) ASC\n+-- select * from tab order by (a + b) * c, intDiv(sin(a / b), 2);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, intDiv(sin(a / b), 2)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC, intDiv(sin(divide(a, b)), 2) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, intDiv(sin(divide(a, b)), 2) ASC\n+-- select * from tab order by (a + b) * c desc , intDiv(sin(a / b), 2);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc , intDiv(sin(a / b), 2)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC\n+  Result sort description: multiply(plus(a, b), c) DESC, intDiv(sin(divide(a, b)), 2) ASC\n+-- select * from tab order by (a + b) * c, intDiv(sin(a / b), 2) desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, intDiv(sin(a / b), 2) desc) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, intDiv(sin(divide(a, b)), 2) DESC\n+-- select * from tab order by (a + b) * c desc, intDiv(sin(a / b), 2) desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, intDiv(sin(a / b), 2) desc) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC, intDiv(sin(divide(a, b)), 2) DESC\n+  Result sort description: multiply(plus(a, b), c) DESC, intDiv(sin(divide(a, b)), 2) DESC\n+-- select * from tab order by (a + b) * c desc, intDiv(sin(a / b), -2);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, intDiv(sin(a / b), -2)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC, intDiv(sin(divide(a, b)), -2) ASC\n+  Result sort description: multiply(plus(a, b), c) DESC, intDiv(sin(divide(a, b)), -2) ASC\n+-- select * from tab order by (a + b) * c desc, intDiv(intDiv(sin(a / b), -2), -3);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, intDiv(intDiv(sin(a / b), -2), -3)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) DESC\n+  Result sort description: multiply(plus(a, b), c) DESC, intDiv(intDiv(sin(divide(a, b)), -2), -3) ASC\n+-- select * from tab order by (a + b) * c, intDiv(intDiv(sin(a / b), -2), -3);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, intDiv(intDiv(sin(a / b), -2), -3)) where explain like '%sort description%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC, intDiv(intDiv(sin(divide(a, b)), -2), -3) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, intDiv(intDiv(sin(divide(a, b)), -2), -3) ASC\n+-- Aliases\n+select * from (select *, a + b as x from tab) order by x * c;\n+0\t0\t0\t0\t0\n+0\t0\t0\t0\t0\n+1\t1\t1\t1\t2\n+1\t1\t1\t1\t2\n+2\t2\t2\t2\t4\n+2\t2\t2\t2\t4\n+3\t3\t3\t3\t6\n+3\t3\t3\t3\t6\n+4\t4\t4\t4\t8\n+4\t4\t4\t4\t8\n+select * from (explain plan actions = 1 select * from (select *, a + b as x from tab) order by x * c) where explain like '%sort description%';\n+  Prefix sort description: multiply(x, c) ASC\n+  Result sort description: multiply(x, c) ASC\n+select * from (select *, a + b as x, a / b as y from tab) order by x * c, sin(y);\n+0\t0\t0\t0\t0\tnan\n+0\t0\t0\t0\t0\tnan\n+1\t1\t1\t1\t2\t1\n+1\t1\t1\t1\t2\t1\n+2\t2\t2\t2\t4\t1\n+2\t2\t2\t2\t4\t1\n+3\t3\t3\t3\t6\t1\n+3\t3\t3\t3\t6\t1\n+4\t4\t4\t4\t8\t1\n+4\t4\t4\t4\t8\t1\n+select * from (explain plan actions = 1 select * from (select *, a + b as x, a / b as y from tab) order by x * c, sin(y)) where explain like '%sort description%';\n+  Prefix sort description: multiply(x, c) ASC, sin(y) ASC\n+  Result sort description: multiply(x, c) ASC, sin(y) ASC\n+select * from (select *, a / b as y from (select *, a + b as x from tab)) order by x * c, sin(y);\n+0\t0\t0\t0\t0\tnan\n+0\t0\t0\t0\t0\tnan\n+1\t1\t1\t1\t2\t1\n+1\t1\t1\t1\t2\t1\n+2\t2\t2\t2\t4\t1\n+2\t2\t2\t2\t4\t1\n+3\t3\t3\t3\t6\t1\n+3\t3\t3\t3\t6\t1\n+4\t4\t4\t4\t8\t1\n+4\t4\t4\t4\t8\t1\n+select * from (explain plan actions = 1 select * from (select *, a / b as y from (select *, a + b as x from tab)) order by x * c, sin(y)) where explain like '%sort description%';\n+  Prefix sort description: multiply(x, c) ASC, sin(y) ASC\n+  Result sort description: multiply(x, c) ASC, sin(y) ASC\n+-- { echoOn }\n+\n+select * from tab2 order by toTimeZone(toTimezone(x, 'UTC'), 'CET'), intDiv(intDiv(y, -2), -3);\n+2020-02-02 00:00:00\t0\t0\n+2020-02-02 00:00:00\t0\t0\n+2020-02-03 00:00:00\t1\t1\n+2020-02-03 00:00:00\t1\t1\n+2020-02-04 00:00:00\t2\t2\n+2020-02-04 00:00:00\t2\t2\n+2020-02-05 00:00:00\t3\t3\n+2020-02-05 00:00:00\t3\t3\n+select * from (explain plan actions = 1 select * from tab2 order by toTimeZone(toTimezone(x, 'UTC'), 'CET'), intDiv(intDiv(y, -2), -3)) where explain like '%sort description%';\n+  Prefix sort description: toTimeZone(toTimezone(x, \\'UTC\\'), \\'CET\\') ASC, intDiv(intDiv(y, -2), -3) ASC\n+  Result sort description: toTimeZone(toTimezone(x, \\'UTC\\'), \\'CET\\') ASC, intDiv(intDiv(y, -2), -3) ASC\n+select * from tab2 order by toStartOfDay(x), intDiv(intDiv(y, -2), -3);\n+2020-02-02 00:00:00\t0\t0\n+2020-02-02 00:00:00\t0\t0\n+2020-02-03 00:00:00\t1\t1\n+2020-02-03 00:00:00\t1\t1\n+2020-02-04 00:00:00\t2\t2\n+2020-02-04 00:00:00\t2\t2\n+2020-02-05 00:00:00\t3\t3\n+2020-02-05 00:00:00\t3\t3\n+select * from (explain plan actions = 1 select * from tab2 order by toStartOfDay(x), intDiv(intDiv(y, -2), -3)) where explain like '%sort description%';\n+  Prefix sort description: toStartOfDay(x) ASC\n+  Result sort description: toStartOfDay(x) ASC, intDiv(intDiv(y, -2), -3) ASC\n+-- select * from tab2 where toTimezone(x, 'CET') = '2020-02-03 01:00:00' order by intDiv(intDiv(y, -2), -3);\n+select * from (explain plan actions = 1 select * from tab2 where toTimezone(x, 'CET') = '2020-02-03 01:00:00' order by intDiv(intDiv(y, -2), -3)) where explain like '%sort description%';\n+  Prefix sort description: intDiv(intDiv(y, -2), -3) ASC\n+  Result sort description: intDiv(intDiv(y, -2), -3) ASC\n+-- { echoOn }\n+\n+-- Union (not fully supported)\n+select * from (select * from tab union all select * from tab3) order by (a + b) * c, sin(a / b);\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab3) order by (a + b) * c, sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+        ReadType: InOrder\n+        ReadType: InOrder\n+select * from (select * from tab where (a + b) * c = 8 union all select * from tab3 where (a + b) * c = 18) order by sin(a / b);\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+select * from (explain plan actions = 1 select * from (select * from tab where (a + b) * c = 8 union all select * from tab3 where (a + b) * c = 18) order by sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+  Prefix sort description: sin(divide(a, b)) ASC\n+  Result sort description: sin(divide(a, b)) ASC\n+          ReadType: InOrder\n+          ReadType: InOrder\n+select * from (select * from tab where (a + b) * c = 8 union all select * from tab4) order by sin(a / b);\n+2\t2\t2\t2\n+2\t2\t2\t2\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t4\t4\t4\n+1\t1\t1\t1\n+2\t2\t2\t2\n+3\t3\t3\t3\n+4\t4\t4\t4\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from (select * from tab where (a + b) * c = 8 union all select * from tab4) order by sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+  Prefix sort description: sin(divide(a, b)) ASC\n+  Result sort description: sin(divide(a, b)) ASC\n+          ReadType: InOrder\n+        ReadType: InOrder\n+select * from (select * from tab union all select * from tab5) order by (a + b) * c;\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5) order by (a + b) * c) where explain like '%sort description%' or explain like '%ReadType%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC\n+        ReadType: InOrder\n+        ReadType: InOrder\n+select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b);\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+1\t1\t1\t1\n+2\t2\t2\t2\n+2\t2\t2\t2\n+2\t2\t2\t2\n+2\t2\t2\t2\n+3\t3\t3\t3\n+3\t3\t3\t3\n+3\t3\t3\t3\n+3\t3\t3\t3\n+4\t4\t4\t4\n+4\t4\t4\t4\n+4\t4\t4\t4\n+4\t4\t4\t4\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+  Prefix sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+  Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+        ReadType: InOrder\n+      Prefix sort description: multiply(plus(a, b), c) ASC\n+      Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+          ReadType: InOrder\n+-- Union with limit\n+select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b) limit 3;\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b) limit 3) where explain ilike '%sort description%' or explain like '%ReadType%' or explain like '%Limit%';\n+  Limit (preliminary LIMIT (without OFFSET))\n+  Limit 3\n+    Prefix sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+    Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+    Limit 3\n+          ReadType: InOrder\n+        Prefix sort description: multiply(plus(a, b), c) ASC\n+        Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+            ReadType: InOrder\n+-- In this example, we read-in-order from tab up to ((a + b) * c, sin(a / b)) and from tab5 up to ((a + b) * c).\n+-- In case of tab5, there would be two finish sorting transforms: ((a + b) * c) -> ((a + b) * c, sin(a / b)) -> ((a + b) * c, sin(a / b), d).\n+-- It's important that ((a + b) * c) -> ((a + b) * c does not have LIMIT. We can add LIMIT WITH TIES later, when sorting alog support it.\n+-- In case of tab4, we do full sorting by ((a + b) * c, sin(a / b), d) with LIMIT. We can replace it to sorting by ((a + b) * c, sin(a / b)) and LIMIT WITH TIES, when sorting alog support it.\n+select * from (select * from tab union all select * from tab5 union all select * from tab4) order by (a + b) * c, sin(a / b), d limit 3;\n+0\t0\t0\t0\n+0\t0\t0\t0\n+0\t0\t0\t0\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5 union all select * from tab4) order by (a + b) * c, sin(a / b), d limit 3) where explain ilike '%sort description%' or explain like '%ReadType%' or explain like '%Limit%';\n+  Limit (preliminary LIMIT (without OFFSET))\n+  Limit 3\n+    Prefix sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+    Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC, d ASC\n+    Limit 3\n+          ReadType: InOrder\n+        Prefix sort description: multiply(plus(a, b), c) ASC\n+        Result sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC\n+            ReadType: InOrder\n+        Sort description: multiply(plus(a, b), c) ASC, sin(divide(a, b)) ASC, d ASC\n+        Limit 3\n+            ReadType: Default\ndiff --git a/tests/queries/0_stateless/00940_order_by_read_in_order_query_plan.sql b/tests/queries/0_stateless/00940_order_by_read_in_order_query_plan.sql\nnew file mode 100644\nindex 000000000000..e694ccf84ee5\n--- /dev/null\n+++ b/tests/queries/0_stateless/00940_order_by_read_in_order_query_plan.sql\n@@ -0,0 +1,144 @@\n+SET optimize_read_in_order = 1, query_plan_read_in_order=1;\n+\n+create table tab (a UInt32, b UInt32, c UInt32, d UInt32) engine = MergeTree order by ((a + b) * c, sin(a / b));\n+insert into tab select number, number, number, number from numbers(5);\n+insert into tab select number, number, number, number from numbers(5);\n+\n+-- { echoOn }\n+\n+-- Exact match, single key\n+select * from tab order by (a + b) * c;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c) where explain like '%sort description%';\n+\n+select * from tab order by (a + b) * c desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc) where explain like '%sort description%';\n+\n+-- Exact match, full key\n+select * from tab order by (a + b) * c, sin(a / b);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, sin(a / b)) where explain like '%sort description%';\n+\n+select * from tab order by (a + b) * c desc, sin(a / b) desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, sin(a / b) desc) where explain like '%sort description%';\n+\n+-- Exact match, mixed direction\n+select * from tab order by (a + b) * c desc, sin(a / b);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, sin(a / b)) where explain like '%sort description%';\n+\n+select * from tab order by (a + b) * c, sin(a / b) desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, sin(a / b) desc) where explain like '%sort description%';\n+\n+-- Wrong order, full sort\n+select * from tab order by sin(a / b), (a + b) * c;\n+select * from (explain plan actions = 1 select * from tab order by sin(a / b), (a + b) * c) where explain ilike '%sort description%';\n+\n+-- Fixed point\n+select * from tab where (a + b) * c = 8 order by sin(a / b);\n+select * from (explain plan actions = 1 select * from tab where (a + b) * c = 8 order by sin(a / b)) where explain ilike '%sort description%';\n+\n+select * from tab where d + 1 = 2 order by (d + 1) * 4, (a + b) * c;\n+select * from (explain plan actions = 1 select * from tab where d + 1 = 2 order by (d + 1) * 4, (a + b) * c) where explain ilike '%sort description%';\n+\n+select * from tab where d + 1 = 3 and (a + b) = 4 and c = 2 order by (d + 1) * 4, sin(a / b);\n+select * from (explain plan actions = 1 select * from tab where d + 1 = 3 and (a + b) = 4 and c = 2 order by (d + 1) * 4, sin(a / b)) where explain ilike '%sort description%';\n+\n+-- Wrong order with fixed point\n+select * from tab where (a + b) * c = 8 order by sin(b / a);\n+select * from (explain plan actions = 1 select * from tab where (a + b) * c = 8 order by sin(b / a)) where explain ilike '%sort description%';\n+\n+-- Monotonicity\n+select * from tab order by intDiv((a + b) * c, 2);\n+select * from (explain plan actions = 1 select * from tab order by intDiv((a + b) * c, 2)) where explain like '%sort description%';\n+\n+select * from tab order by intDiv((a + b) * c, 2), sin(a / b);\n+select * from (explain plan actions = 1 select * from tab order by intDiv((a + b) * c, 2), sin(a / b)) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c, intDiv(sin(a / b), 2);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, intDiv(sin(a / b), 2)) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c desc , intDiv(sin(a / b), 2);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc , intDiv(sin(a / b), 2)) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c, intDiv(sin(a / b), 2) desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, intDiv(sin(a / b), 2) desc) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c desc, intDiv(sin(a / b), 2) desc;\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, intDiv(sin(a / b), 2) desc) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c desc, intDiv(sin(a / b), -2);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, intDiv(sin(a / b), -2)) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c desc, intDiv(intDiv(sin(a / b), -2), -3);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c desc, intDiv(intDiv(sin(a / b), -2), -3)) where explain like '%sort description%';\n+\n+-- select * from tab order by (a + b) * c, intDiv(intDiv(sin(a / b), -2), -3);\n+select * from (explain plan actions = 1 select * from tab order by (a + b) * c, intDiv(intDiv(sin(a / b), -2), -3)) where explain like '%sort description%';\n+\n+-- Aliases\n+select * from (select *, a + b as x from tab) order by x * c;\n+select * from (explain plan actions = 1 select * from (select *, a + b as x from tab) order by x * c) where explain like '%sort description%';\n+\n+select * from (select *, a + b as x, a / b as y from tab) order by x * c, sin(y);\n+select * from (explain plan actions = 1 select * from (select *, a + b as x, a / b as y from tab) order by x * c, sin(y)) where explain like '%sort description%';\n+\n+select * from (select *, a / b as y from (select *, a + b as x from tab)) order by x * c, sin(y);\n+select * from (explain plan actions = 1 select * from (select *, a / b as y from (select *, a + b as x from tab)) order by x * c, sin(y)) where explain like '%sort description%';\n+\n+-- { echoOff }\n+\n+create table tab2 (x DateTime, y UInt32, z UInt32) engine = MergeTree order by (x, y);\n+insert into tab2 select toDate('2020-02-02') + number, number, number from numbers(4);\n+insert into tab2 select toDate('2020-02-02') + number, number, number from numbers(4);\n+\n+-- { echoOn }\n+\n+select * from tab2 order by toTimeZone(toTimezone(x, 'UTC'), 'CET'), intDiv(intDiv(y, -2), -3);\n+select * from (explain plan actions = 1 select * from tab2 order by toTimeZone(toTimezone(x, 'UTC'), 'CET'), intDiv(intDiv(y, -2), -3)) where explain like '%sort description%';\n+\n+select * from tab2 order by toStartOfDay(x), intDiv(intDiv(y, -2), -3);\n+select * from (explain plan actions = 1 select * from tab2 order by toStartOfDay(x), intDiv(intDiv(y, -2), -3)) where explain like '%sort description%';\n+\n+-- select * from tab2 where toTimezone(x, 'CET') = '2020-02-03 01:00:00' order by intDiv(intDiv(y, -2), -3);\n+select * from (explain plan actions = 1 select * from tab2 where toTimezone(x, 'CET') = '2020-02-03 01:00:00' order by intDiv(intDiv(y, -2), -3)) where explain like '%sort description%';\n+\n+-- { echoOff }\n+\n+create table tab3 (a UInt32, b UInt32, c UInt32, d UInt32) engine = MergeTree order by ((a + b) * c, sin(a / b));\n+insert into tab3 select number, number, number, number from numbers(5);\n+insert into tab3 select number, number, number, number from numbers(5);\n+\n+create table tab4 (a UInt32, b UInt32, c UInt32, d UInt32) engine = MergeTree order by sin(a / b);\n+insert into tab4 select number, number, number, number from numbers(5);\n+insert into tab4 select number, number, number, number from numbers(5);\n+\n+create table tab5 (a UInt32, b UInt32, c UInt32, d UInt32) engine = MergeTree order by (a + b) * c;\n+insert into tab5 select number, number, number, number from numbers(5);\n+insert into tab5 select number, number, number, number from numbers(5);\n+\n+-- { echoOn }\n+\n+-- Union (not fully supported)\n+select * from (select * from tab union all select * from tab3) order by (a + b) * c, sin(a / b);\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab3) order by (a + b) * c, sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+\n+select * from (select * from tab where (a + b) * c = 8 union all select * from tab3 where (a + b) * c = 18) order by sin(a / b);\n+select * from (explain plan actions = 1 select * from (select * from tab where (a + b) * c = 8 union all select * from tab3 where (a + b) * c = 18) order by sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+\n+select * from (select * from tab where (a + b) * c = 8 union all select * from tab4) order by sin(a / b);\n+select * from (explain plan actions = 1 select * from (select * from tab where (a + b) * c = 8 union all select * from tab4) order by sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+\n+select * from (select * from tab union all select * from tab5) order by (a + b) * c;\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5) order by (a + b) * c) where explain like '%sort description%' or explain like '%ReadType%';\n+\n+select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b);\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b)) where explain like '%sort description%' or explain like '%ReadType%';\n+\n+-- Union with limit\n+select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b) limit 3;\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5) order by (a + b) * c, sin(a / b) limit 3) where explain ilike '%sort description%' or explain like '%ReadType%' or explain like '%Limit%';\n+\n+-- In this example, we read-in-order from tab up to ((a + b) * c, sin(a / b)) and from tab5 up to ((a + b) * c).\n+-- In case of tab5, there would be two finish sorting transforms: ((a + b) * c) -> ((a + b) * c, sin(a / b)) -> ((a + b) * c, sin(a / b), d).\n+-- It's important that ((a + b) * c) -> ((a + b) * c does not have LIMIT. We can add LIMIT WITH TIES later, when sorting alog support it.\n+-- In case of tab4, we do full sorting by ((a + b) * c, sin(a / b), d) with LIMIT. We can replace it to sorting by ((a + b) * c, sin(a / b)) and LIMIT WITH TIES, when sorting alog support it.\n+select * from (select * from tab union all select * from tab5 union all select * from tab4) order by (a + b) * c, sin(a / b), d limit 3;\n+select * from (explain plan actions = 1 select * from (select * from tab union all select * from tab5 union all select * from tab4) order by (a + b) * c, sin(a / b), d limit 3) where explain ilike '%sort description%' or explain like '%ReadType%' or explain like '%Limit%';\ndiff --git a/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference\nindex 45a1a094c494..8c8bb73b8012 100644\n--- a/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference\n+++ b/tests/queries/0_stateless/01562_optimize_monotonous_functions_in_order_by.reference\n@@ -17,7 +17,7 @@ ORDER BY toDate(timestamp) ASC\n LIMIT 10\n Expression (Projection)\n   Limit (preliminary LIMIT (without OFFSET))\n-    Sorting\n+    Sorting (Sorting for ORDER BY)\n       Expression (Before ORDER BY)\n         ReadFromMergeTree (default.test_order_by)\n SELECT\n@@ -30,7 +30,7 @@ ORDER BY\n LIMIT 10\n Expression (Projection)\n   Limit (preliminary LIMIT (without OFFSET))\n-    Sorting\n+    Sorting (Sorting for ORDER BY)\n       Expression (Before ORDER BY)\n         ReadFromMergeTree (default.test_order_by)\n SELECT\ndiff --git a/tests/queries/0_stateless/01576_alias_column_rewrite.reference b/tests/queries/0_stateless/01576_alias_column_rewrite.reference\nindex 830db82274f1..2b7fdfaa6422 100644\n--- a/tests/queries/0_stateless/01576_alias_column_rewrite.reference\n+++ b/tests/queries/0_stateless/01576_alias_column_rewrite.reference\n@@ -28,12 +28,12 @@ Expression (Projection)\n         ReadFromMergeTree (default.test_table)\n Expression (Projection)\n   Limit (preliminary LIMIT (without OFFSET))\n-    Sorting\n+    Sorting (Sorting for ORDER BY)\n       Expression (Before ORDER BY)\n         ReadFromMergeTree (default.test_table)\n Expression ((Projection + Before ORDER BY [lifted up part]))\n   Limit (preliminary LIMIT (without OFFSET))\n-    Sorting\n+    Sorting (Sorting for ORDER BY)\n       Expression (Before ORDER BY)\n         ReadFromMergeTree (default.test_table)\n optimize_aggregation_in_order\ndiff --git a/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order.sh b/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order.sh\nindex 328d181fadd7..a606f1a2f9ea 100755\n--- a/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order.sh\n+++ b/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order.sh\n@@ -19,25 +19,25 @@ $CLICKHOUSE_CLIENT -q \"optimize table ${name}_n_x final\"\n \n echo 'Partial sorting plan'\n echo '  optimize_read_in_window_order=0'\n-$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_window_order=0\" | grep -i \"sort description\"\n+$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_order=0,optimize_read_in_window_order=0\" | grep -i \"sort description\"\n \n echo '  optimize_read_in_window_order=1'\n-$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_window_order=1\" | grep -i \"sort description\"\n+$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_order=1\" | grep -i \"sort description\"\n \n echo 'No sorting plan'\n echo '  optimize_read_in_window_order=0'\n-$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=0\" | grep -i \"sort description\"\n+$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=0,optimize_read_in_window_order=0\" | grep -i \"sort description\"\n \n echo '  optimize_read_in_window_order=1'\n-$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=1\" | grep -i \"sort description\"\n+$CLICKHOUSE_CLIENT -q \"explain plan actions=1, description=1 select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=1\" | grep -i \"sort description\"\n \n echo 'Complex ORDER BY'\n $CLICKHOUSE_CLIENT -q \"CREATE TABLE ${name}_complex (unique1 Int32, unique2 Int32, ten Int32) ENGINE=MergeTree ORDER BY tuple() SETTINGS index_granularity = 8192\"\n $CLICKHOUSE_CLIENT -q \"INSERT INTO ${name}_complex VALUES (1, 2, 3), (2, 3, 4), (3, 4, 5)\"\n echo '  optimize_read_in_window_order=0'\n-$CLICKHOUSE_CLIENT -q \"SELECT ten, sum(unique1) + sum(unique2) AS res, rank() OVER (ORDER BY sum(unique1) + sum(unique2) ASC) AS rank FROM ${name}_complex GROUP BY ten ORDER BY ten ASC SETTINGS optimize_read_in_window_order=0\"\n+$CLICKHOUSE_CLIENT -q \"SELECT ten, sum(unique1) + sum(unique2) AS res, rank() OVER (ORDER BY sum(unique1) + sum(unique2) ASC) AS rank FROM ${name}_complex GROUP BY ten ORDER BY ten ASC SETTINGS optimize_read_in_order=0,optimize_read_in_window_order=0\"\n echo '  optimize_read_in_window_order=1'\n-$CLICKHOUSE_CLIENT -q \"SELECT ten, sum(unique1) + sum(unique2) AS res, rank() OVER (ORDER BY sum(unique1) + sum(unique2) ASC) AS rank FROM ${name}_complex GROUP BY ten ORDER BY ten ASC SETTINGS optimize_read_in_window_order=1\"\n+$CLICKHOUSE_CLIENT -q \"SELECT ten, sum(unique1) + sum(unique2) AS res, rank() OVER (ORDER BY sum(unique1) + sum(unique2) ASC) AS rank FROM ${name}_complex GROUP BY ten ORDER BY ten ASC SETTINGS optimize_read_in_order=1\"\n \n $CLICKHOUSE_CLIENT -q \"drop table ${name}\"\n $CLICKHOUSE_CLIENT -q \"drop table ${name}_n\"\ndiff --git a/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order_long.sh b/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order_long.sh\nindex 297688a29c32..fc79725aebef 100755\n--- a/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order_long.sh\n+++ b/tests/queries/0_stateless/01655_plan_optimizations_optimize_read_in_window_order_long.sh\n@@ -19,16 +19,16 @@ $CLICKHOUSE_CLIENT -q \"create table ${name}_n_x engine=MergeTree order by (n, x)\n $CLICKHOUSE_CLIENT -q \"optimize table ${name}_n final\"\n $CLICKHOUSE_CLIENT -q \"optimize table ${name}_n_x final\"\n \n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_window_order=0, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_window_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\"\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_order=0, optimize_read_in_window_order=0, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n SETTINGS optimize_read_in_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\"\n \n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=0, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\"\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=0, optimize_read_in_window_order=0, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\"\n \n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (PARTITION BY n ORDER BY x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=0, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (PARTITION BY n ORDER BY x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\"\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (PARTITION BY n ORDER BY x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=0, optimize_read_in_window_order=0, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (PARTITION BY n ORDER BY x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\"\n \n-$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (PARTITION BY n+x%2 ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_window_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n+$CLICKHOUSE_CLIENT -q \"select n, sum(x) OVER (PARTITION BY n+x%2 ORDER BY n, x ROWS BETWEEN 100 PRECEDING AND CURRENT ROW) from ${name}_n_x SETTINGS optimize_read_in_order=1, max_memory_usage=$max_memory_usage, max_threads=1 format Null\" 2>&1 | grep -F -q \"MEMORY_LIMIT_EXCEEDED\" && echo 'OK' || echo 'FAIL'\n \n $CLICKHOUSE_CLIENT -q \"drop table ${name}\"\n $CLICKHOUSE_CLIENT -q \"drop table ${name}_n\"\ndiff --git a/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference b/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference\nindex 9592ed5691d6..9016e7311064 100644\n--- a/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference\n+++ b/tests/queries/0_stateless/01952_optimize_distributed_group_by_sharding_key.reference\n@@ -18,11 +18,12 @@ Union\n explain select distinct on (k1) k2 from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)); -- not optimized\n Expression (Projection)\n   LimitBy\n-    Expression (Before LIMIT BY)\n-      Union\n+    Union\n+      Expression (Before LIMIT BY)\n         LimitBy\n           Expression ((Before LIMIT BY + (Before ORDER BY + (Convert VIEW subquery result to VIEW table structure + (Materialize constants after VIEW subquery + (Projection + Before ORDER BY))))))\n             ReadFromStorage (SystemNumbers)\n+      Expression\n         ReadFromRemote (Read from remote replica)\n explain select distinct on (k1, k2) v from remote('127.{1,2}', view(select 1 k1, 2 k2, 3 v from numbers(2)), cityHash64(k1, k2)); -- optimized\n Union\ndiff --git a/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.reference b/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.reference\nindex b73ab43cabb6..fc8a8ffc5511 100644\n--- a/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.reference\n+++ b/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.reference\n@@ -4,3 +4,5 @@\n 2\n 3\n 4\n+10\n+20\ndiff --git a/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.sql b/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.sql\nindex 9846c1208a13..314d0610d128 100644\n--- a/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.sql\n+++ b/tests/queries/0_stateless/02155_read_in_order_max_rows_to_read.sql\n@@ -13,8 +13,7 @@ SELECT a FROM t_max_rows_to_read WHERE a = 10 SETTINGS max_rows_to_read = 4;\n \n SELECT a FROM t_max_rows_to_read ORDER BY a LIMIT 5 SETTINGS max_rows_to_read = 12;\n \n--- This should work, but actually it doesn't. Need to investigate.\n--- SELECT a FROM t_max_rows_to_read WHERE a > 10 ORDER BY a LIMIT 5 SETTINGS max_rows_to_read = 20;\n+SELECT a FROM t_max_rows_to_read WHERE a = 10 OR a = 20 SETTINGS max_rows_to_read = 12;\n \n SELECT a FROM t_max_rows_to_read ORDER BY a LIMIT 20 FORMAT Null SETTINGS max_rows_to_read = 12; -- { serverError 158 }\n SELECT a FROM t_max_rows_to_read WHERE a > 10 ORDER BY a LIMIT 5 FORMAT Null SETTINGS max_rows_to_read = 12; -- { serverError 158 }\ndiff --git a/tests/queries/0_stateless/02317_distinct_in_order_optimization_explain.reference b/tests/queries/0_stateless/02317_distinct_in_order_optimization_explain.reference\nindex 2511c806e1bf..f85b9cd9e866 100644\n--- a/tests/queries/0_stateless/02317_distinct_in_order_optimization_explain.reference\n+++ b/tests/queries/0_stateless/02317_distinct_in_order_optimization_explain.reference\n@@ -59,8 +59,6 @@ Sorting (Stream): a ASC, b ASC\n -- check that reading in order optimization for ORDER BY and DISTINCT applied correctly in the same query\n -- disabled, check that sorting description for ReadFromMergeTree match ORDER BY columns\n Sorting (Stream): a ASC\n-Sorting (Stream): a ASC\n-Sorting (Stream): a ASC\n -- enabled, check that ReadFromMergeTree sorting description is overwritten by DISTINCT optimization i.e. it contains columns from DISTINCT clause\n Sorting (Stream): a ASC, b ASC\n Sorting (Stream): a ASC, b ASC\n@@ -71,12 +69,8 @@ Sorting (Stream): a DESC, b DESC\n Sorting (Stream): a DESC, b DESC\n -- enabled, check that ReadFromMergeTree sorting description is NOT overwritten by DISTINCT optimization (1), - it contains columns from ORDER BY clause\n Sorting (Stream): a ASC, b ASC\n-Sorting (Stream): a ASC, b ASC\n-Sorting (Stream): a ASC, b ASC\n -- enabled, check that ReadFromMergeTree sorting description is NOT overwritten by DISTINCT optimization (2), - direction used from ORDER BY clause\n Sorting (Stream): a DESC, b DESC\n-Sorting (Stream): a DESC, b DESC\n-Sorting (Stream): a DESC, b DESC\n -- enabled, check that disabling other 'read in order' optimizations do not disable distinct in order optimization\n Sorting (Stream): a ASC, b ASC\n Sorting (Stream): a ASC, b ASC\ndiff --git a/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.reference b/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.reference\nindex a7498e68bc08..ba924f5daa2d 100644\n--- a/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.reference\n+++ b/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.reference\n@@ -1,82 +1,86 @@\n -- EXPLAIN PLAN sorting for MergeTree w/o sorting key\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting ORDER BY a\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting ORDER BY a\n Sorting (Global): a ASC\n Sorting (Sorting for ORDER BY)\n Sorting (Global): a ASC\n Sorting (None)\n Sorting (None)\n -- disable optimization -> sorting order is NOT propagated from subquery -> full sort\n--- QUERY: set optimize_sorting_by_input_stream_properties=0;set max_threads=1;EXPLAIN PIPELINE SELECT a FROM (SELECT a FROM optimize_sorting) ORDER BY a\n-MergeSortingTransform\n-LimitsCheckingTransform\n-PartialSortingTransform\n+-- QUERY: set optimize_sorting_by_input_stream_properties=0;set query_plan_read_in_order=0;set max_threads=3;EXPLAIN PIPELINE SELECT a FROM (SELECT a FROM optimize_sorting) ORDER BY a\n+MergingSortedTransform 3 \u2192 1\n+MergeSortingTransform \u00d7 3\n+LimitsCheckingTransform \u00d7 3\n+PartialSortingTransform \u00d7 3\n -- enable optimization -> sorting order is propagated from subquery -> merge sort\n--- QUERY: set optimize_sorting_by_input_stream_properties=1;set max_threads=1;EXPLAIN PIPELINE SELECT a FROM (SELECT a FROM optimize_sorting) ORDER BY a\n-MergeSortingTransform\n+-- QUERY: set optimize_sorting_by_input_stream_properties=1;set query_plan_read_in_order=1;set optimize_read_in_order=1;set max_threads=3;EXPLAIN PIPELINE SELECT a FROM (SELECT a FROM optimize_sorting) ORDER BY a\n+MergingSortedTransform 3 \u2192 1\n -- enable optimization -> there is no sorting order to propagate from subquery -> full sort\n--- QUERY: set optimize_sorting_by_input_stream_properties=1;set max_threads=1;EXPLAIN PIPELINE SELECT c FROM (SELECT c FROM optimize_sorting) ORDER BY c\n-MergeSortingTransform\n-LimitsCheckingTransform\n-PartialSortingTransform\n+-- QUERY: set optimize_sorting_by_input_stream_properties=1;set query_plan_read_in_order=1;set optimize_read_in_order=1;set max_threads=3;EXPLAIN PIPELINE SELECT c FROM (SELECT c FROM optimize_sorting) ORDER BY c\n+MergingSortedTransform 3 \u2192 1\n+MergeSortingTransform \u00d7 3\n+LimitsCheckingTransform \u00d7 3\n+PartialSortingTransform \u00d7 3\n -- ExpressionStep preserves sort mode\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting ORDER BY a\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting ORDER BY a\n Sorting (Global): a ASC\n+Sorting (Sorting for ORDER BY)\n Sorting (Global): a ASC\n+Sorting (Chunk): a ASC\n Sorting (Stream): a ASC\n-Sorting (Stream): a ASC\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting ORDER BY a+1\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting ORDER BY a+1\n Sorting (None)\n Sorting (Sorting for ORDER BY)\n Sorting (Global): plus(a, 1) ASC\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n -- ExpressionStep breaks sort mode\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a+1 FROM optimize_sorting ORDER BY a+1\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a+1 FROM optimize_sorting ORDER BY a+1\n Sorting (Global): plus(a, 1) ASC\n Sorting (Sorting for ORDER BY)\n Sorting (Global): plus(a, 1) ASC\n Sorting (None)\n Sorting (Chunk): a ASC\n -- FilterStep preserves sort mode\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting WHERE a > 0\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting WHERE a > 0\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting WHERE a+1 > 0\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM optimize_sorting WHERE a+1 > 0\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a, a+1 FROM optimize_sorting WHERE a+1 > 0\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a, a+1 FROM optimize_sorting WHERE a+1 > 0\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n -- FilterStep breaks sort mode\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a > 0 FROM optimize_sorting WHERE a > 0\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a > 0 FROM optimize_sorting WHERE a > 0\n Sorting (None)\n Sorting (None)\n Sorting (Chunk): a ASC\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a+1 FROM optimize_sorting WHERE a+1 > 0\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a+1 FROM optimize_sorting WHERE a+1 > 0\n Sorting (None)\n Sorting (None)\n Sorting (Chunk): a ASC\n -- aliases break sorting order\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM (SELECT sipHash64(a) AS a FROM (SELECT a FROM optimize_sorting ORDER BY a)) ORDER BY a\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a FROM (SELECT sipHash64(a) AS a FROM (SELECT a FROM optimize_sorting ORDER BY a)) ORDER BY a\n Sorting (Global): a ASC\n Sorting (Sorting for ORDER BY)\n Sorting (Global): a ASC\n Sorting (None)\n+Sorting (Sorting for ORDER BY)\n Sorting (Global): a ASC\n-Sorting (Stream): a ASC\n+Sorting (Chunk): a ASC\n Sorting (Stream): a ASC\n -- aliases DONT break sorting order\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a, b FROM (SELECT x AS a, y AS b FROM (SELECT a AS x, b AS y FROM optimize_sorting) ORDER BY x, y)\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a, b FROM (SELECT x AS a, y AS b FROM (SELECT a AS x, b AS y FROM optimize_sorting) ORDER BY x, y)\n Sorting (Global): x ASC, y ASC\n Sorting (Sorting for ORDER BY)\n Sorting (Global): x ASC, y ASC\n Sorting (Chunk): a ASC, b ASC\n-Sorting (Chunk): a ASC, b ASC\n+Sorting (Stream): a ASC, b ASC\n -- actions chain breaks sorting order: input(column a)->sipHash64(column a)->alias(sipHash64(column a), a)->plus(alias a, 1)\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a, z FROM (SELECT sipHash64(a) AS a, a + 1 AS z FROM (SELECT a FROM optimize_sorting ORDER BY a + 1)) ORDER BY a + 1\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN actions=1, header=1, sorting=1 SELECT a, z FROM (SELECT sipHash64(a) AS a, a + 1 AS z FROM (SELECT a FROM optimize_sorting ORDER BY a + 1)) ORDER BY a + 1\n Sorting (None)\n Sorting (Sorting for ORDER BY)\n Sorting (Global): plus(a, 1) ASC\n@@ -86,8 +90,9 @@ Sorting (Global): plus(a, 1) ASC\n Sorting (Chunk): a ASC\n Sorting (Chunk): a ASC\n -- check that correct sorting info is provided in case of only prefix of sorting key is in ORDER BY clause but all sorting key columns returned by query\n--- QUERY: set optimize_read_in_order=1;EXPLAIN PLAN sorting=1 SELECT a, b FROM optimize_sorting ORDER BY a\n+-- QUERY: set optimize_read_in_order=1;set max_threads=3;EXPLAIN PLAN sorting=1 SELECT a, b FROM optimize_sorting ORDER BY a\n Sorting (Global): a ASC\n+Sorting (Sorting for ORDER BY)\n Sorting (Global): a ASC\n-Sorting (Stream): a ASC\n+Sorting (Chunk): a ASC, b ASC\n Sorting (Stream): a ASC\ndiff --git a/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.sh b/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.sh\nindex a308d9bcbc1a..62051701cb6a 100755\n--- a/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.sh\n+++ b/tests/queries/0_stateless/02377_optimize_sorting_by_input_stream_properties_explain.sh\n@@ -4,9 +4,9 @@ CURDIR=$(cd \"$(dirname \"${BASH_SOURCE[0]}\")\" && pwd)\n # shellcheck source=../shell_config.sh\n . \"$CURDIR\"/../shell_config.sh\n \n-DISABLE_OPTIMIZATION=\"set optimize_sorting_by_input_stream_properties=0;set max_threads=1\"\n-ENABLE_OPTIMIZATION=\"set optimize_sorting_by_input_stream_properties=1;set max_threads=1\"\n-MAKE_OUTPUT_STABLE=\"set optimize_read_in_order=1\"\n+DISABLE_OPTIMIZATION=\"set optimize_sorting_by_input_stream_properties=0;set query_plan_read_in_order=0;set max_threads=3\"\n+ENABLE_OPTIMIZATION=\"set optimize_sorting_by_input_stream_properties=1;set query_plan_read_in_order=1;set optimize_read_in_order=1;set max_threads=3\"\n+MAKE_OUTPUT_STABLE=\"set optimize_read_in_order=1;set max_threads=3\"\n GREP_SORTING=\"grep 'PartialSortingTransform\\|LimitsCheckingTransform\\|MergeSortingTransform\\|MergingSortedTransform'\"\n GREP_SORTMODE=\"grep 'Sorting ('\"\n TRIM_LEADING_SPACES=\"sed -e 's/^[ \\t]*//'\"\ndiff --git a/tests/queries/0_stateless/02381_join_dup_columns_in_plan.reference b/tests/queries/0_stateless/02381_join_dup_columns_in_plan.reference\nindex d2f1b4efdd51..bbf288c45d7a 100644\n--- a/tests/queries/0_stateless/02381_join_dup_columns_in_plan.reference\n+++ b/tests/queries/0_stateless/02381_join_dup_columns_in_plan.reference\n@@ -8,22 +8,19 @@ Header: key String\n     Header: key String\n       ReadFromStorage\n       Header: dummy UInt8\n-    Expression\n+    Union\n     Header: s2.key String\n             value String\n-      Union\n-      Header: key String\n+      Expression\n+      Header: s2.key String\n               value String\n-        Expression\n-        Header: key String\n-                value String\n-          ReadFromStorage\n-          Header: dummy UInt8\n-        Expression\n-        Header: key String\n-                value String\n-          ReadFromStorage\n-          Header: dummy UInt8\n+        ReadFromStorage\n+        Header: dummy UInt8\n+      Expression\n+      Header: s2.key String\n+              value String\n+        ReadFromStorage\n+        Header: dummy UInt8\n Expression\n Header: key String\n         value String\n@@ -40,19 +37,16 @@ Header: key String\n     Sorting\n     Header: s2.key String\n             value String\n-      Expression\n+      Union\n       Header: s2.key String\n               value String\n-        Union\n-        Header: key String\n+        Expression\n+        Header: s2.key String\n                 value String\n-          Expression\n-          Header: key String\n-                  value String\n-            ReadFromStorage\n-            Header: dummy UInt8\n-          Expression\n-          Header: key String\n-                  value String\n-            ReadFromStorage\n-            Header: dummy UInt8\n+          ReadFromStorage\n+          Header: dummy UInt8\n+        Expression\n+        Header: s2.key String\n+                value String\n+          ReadFromStorage\n+          Header: dummy UInt8\n",
  "problem_statement": "prewhere action should preserve sorting columns\n### Changelog category (leave one):\r\n- Bug Fix (user-visible misbehavior in official stable or prestable release)\r\n\r\n### Changelog entry (a user-readable short description of the changes that goes to CHANGELOG.md):\r\nFixed error `Not found column Type in block` in selects with `PREWHERE` and read-in-order optimizations.\r\n\r\ncloses #37381\r\ncloses #36043\n",
  "hints_text": "can you backport this pr to old stable releases?\n@orloffv definitely",
  "created_at": "2022-10-31T13:57:39Z"
}